<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Rust Edition Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/edition-guide";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/print.md`;
                    } else {
                        canonical_href = `${base}/${lang}/print.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("en");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Edition Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to The Rust Edition Guide! "Editions" are Rust's way of introducing
changes into the language that would not otherwise be backwards
compatible.</p>
<p>In this guide, we'll discuss:</p>
<ul>
<li>What editions are</li>
<li>Which changes are contained in each edition</li>
<li>How to migrate your code from one edition to another</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-are-editions"><a class="header" href="#what-are-editions">What are Editions?</a></h1>
<p>In May 2015, the <a href="https://blog.rust-lang.org/2015/05/15/Rust-1.0.html">release of Rust 1.0</a> established "<a href="https://blog.rust-lang.org/2014/10/30/Stability.html">stability without stagnation</a>" as a core Rust axiom. Since then, Rust has committed to a pivotal rule: once a feature is <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">released through stable</a>, contributors will continue to support that feature for all future releases.</p>
<p>However, there are times when it's useful to make backwards-incompatible changes to the language. A common example is the introduction of a new keyword. For instance, early versions of Rust didn't feature the <code>async</code> and <code>await</code> keywords.</p>
<p>If Rust had suddenly introduced these new keywords, some code would have broken: <code>let async = 1;</code> would no longer work.</p>
<p>Rust uses <strong>editions</strong> to solve this problem. When there are backwards-incompatible changes, they are pushed into the next edition. Since editions are opt-in, existing crates won't use the changes unless they explicitly migrate into the new edition. For example, the latest version of Rust doesn't treat <code>async</code> as a keyword unless edition 2018 or later is chosen.</p>
<p>Each crate chooses its edition <a href="https://doc.rust-lang.org/cargo/reference/manifest.html#the-edition-field">within its <code>Cargo.toml</code> file</a>. When creating a new crate with Cargo, it will automatically select the newest stable edition.</p>
<h2 id="editions-do-not-split-the-ecosystem"><a class="header" href="#editions-do-not-split-the-ecosystem">Editions do not split the ecosystem</a></h2>
<p>When creating editions, there is one most consequential rule: crates in one edition <strong>must</strong> seamlessly interoperate with those compiled with other editions.</p>
<p>In other words, each crate can decide when to migrate to a new edition independently. This decision is 'private' - it won't affect other crates in the ecosystem.</p>
<p>For Rust, this required compatibility implies some limits on the kinds of changes that can be featured in an edition. As a result, changes found in new Rust editions tend to be 'skin deep'. All Rust code - regardless of edition - will ultimately compile down to the same internal representation within the compiler.</p>
<h2 id="edition-migration-is-easy-and-largely-automated"><a class="header" href="#edition-migration-is-easy-and-largely-automated">Edition migration is easy and largely automated</a></h2>
<p>Rust aims to make upgrading to a new edition an easy process. When a new edition releases, crate authors may use <a href="https://doc.rust-lang.org/cargo/commands/cargo-fix.html">automatic migration tooling within <code>cargo</code></a> to migrate. Cargo will then make minor changes to the code to make it compatible with the new version.</p>
<p>For example, when migrating to Rust 2018, anything named <code>async</code> will now use the equivalent <a href="https://doc.rust-lang.org/rust-by-example/compatibility/raw_identifiers.html">raw identifier syntax</a>: <code>r#async</code>.</p>
<p>Cargo's automatic migrations aren't perfect: there may still be corner cases where manual changes are required. It aims to avoid changes to semantics that could affect the correctness or performance of the code.</p>
<h2 id="what-this-guide-covers"><a class="header" href="#what-this-guide-covers">What this guide covers</a></h2>
<p>In addition to tooling, this Rust Edition Guide also covers the changes that are part of each edition. It describes each change and links to additional details, if available. It also covers corner cases or tricky details crate authors should be aware of.</p>
<p>Crate authors should find:</p>
<ul>
<li>An overview of editions</li>
<li>A migration guide for specific editions</li>
<li>A quick troubleshooting reference when automated tooling isn't working.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-new-project"><a class="header" href="#creating-a-new-project">Creating a new project</a></h1>
<p>A new project created with Cargo is configured to use the latest edition by
default:</p>
<pre><code class="language-console">$ cargo new foo
    Creating binary (application) `foo` package
note: see more `Cargo.toml` keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
$ cat foo/Cargo.toml
[package]
name = "foo"
version = "0.1.0"
edition = "2024"

[dependencies]
</code></pre>
<p>That <code>edition = "2024"</code> setting configures your package to be built using the
Rust 2024 edition. No further configuration needed!</p>
<p>You can use the <code>--edition &lt;YEAR&gt;</code> option of <code>cargo new</code> to create the project
using some specific edition. For example, creating a new project to use the
Rust 2018 edition could be done like this:</p>
<pre><code class="language-console">$ cargo new --edition 2018 foo
    Creating binary (application) `foo` package
note: see more `Cargo.toml` keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
$ cat foo/Cargo.toml
[package]
name = "foo"
version = "0.1.0"
edition = "2018"

[dependencies]
</code></pre>
<p>Don't worry about accidentally using an invalid year for the edition; the
<code>cargo new</code> invocation will not accept an invalid edition year value:</p>
<pre><code class="language-console">$ cargo new --edition 2019 foo
error: invalid value '2019' for '--edition &lt;YEAR&gt;'
  [possible values: 2015, 2018, 2021, 2024]

  tip: a similar value exists: '2021'

For more information, try '--help'.
</code></pre>
<p>You can change the value of the <code>edition</code> key by simply editing the
<code>Cargo.toml</code> file. For example, to cause your package to be built using the
Rust 2015 edition, you would set the key as in the following example:</p>
<pre><code class="language-toml">[package]
name = "foo"
version = "0.1.0"
edition = "2015"

[dependencies]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transitioning-an-existing-project-to-a-new-edition"><a class="header" href="#transitioning-an-existing-project-to-a-new-edition">Transitioning an existing project to a new edition</a></h1>
<p>Rust includes tooling to automatically transition a project from one edition to the next.
It will update your source code so that it is compatible with the next edition.
Briefly, the steps to update to the next edition are:</p>
<ol>
<li>Run <code>cargo update</code> to update your dependencies to the latest versions.</li>
<li>Run <code>cargo fix --edition</code></li>
<li>Edit <code>Cargo.toml</code> and set the <code>edition</code> field to the next edition, for example <code>edition = "2024"</code></li>
<li>Run <code>cargo build</code> or <code>cargo test</code> to verify the fixes worked.</li>
<li>Run <code>cargo fmt</code> to reformat your project.</li>
</ol>
<p>The following sections dig into the details of these steps, and some of the issues you may encounter along the way.</p>
<blockquote>
<p>It's our intention that the migration to new editions is as smooth an
experience as possible. If it's difficult for you to upgrade to the latest edition,
we consider that a bug. If you run into problems with this process, please
<a href="https://github.com/rust-lang/rust/issues/new/choose">file a bug report</a>. Thank you!</p>
</blockquote>
<h2 id="starting-the-migration"><a class="header" href="#starting-the-migration">Starting the migration</a></h2>
<p>As an example, let's take a look at transitioning from the 2015 edition to the 2018 edition.
The steps are essentially the same when transitioning to other editions like 2021.</p>
<p>Imagine we have a crate that has this code in <code>src/lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(&amp;self, i32);
}
<span class="boring">}</span></code></pre></pre>
<p>This code uses an anonymous parameter, that <code>i32</code>. This is <a href="editions/../rust-2018/trait-system/no-anon-params.html">not
supported in Rust 2018</a>, and
so this would fail to compile. Let's get this code up to date!</p>
<h2 id="updating-your-dependencies"><a class="header" href="#updating-your-dependencies">Updating your dependencies</a></h2>
<p>Before we get started, it is recommended to update your dependencies. Some dependencies, particularly some proc-macros or dependencies that do build-time code generation, may have compatibility issues with newer editions. New releases may have been made since you last updated which may fix these issues. Run the following:</p>
<pre><code class="language-console">cargo update
</code></pre>
<p>After updating, you may want to run your tests to verify everything is working. If you are using a source control tool such as <code>git</code>, you may want to commit these changes separately to keep a logical separation of commits.</p>
<h2 id="updating-your-code-to-be-compatible-with-the-new-edition"><a class="header" href="#updating-your-code-to-be-compatible-with-the-new-edition">Updating your code to be compatible with the new edition</a></h2>
<p>Your code may or may not use features that are incompatible with the new edition.
In order to help transition to the next edition, Cargo includes the <a href="editions/../../cargo/commands/cargo-fix.html"><code>cargo fix</code></a> subcommand to automatically update your source code.
To start, let's run it:</p>
<pre><code class="language-console">cargo fix --edition
</code></pre>
<p>This will check your code, and automatically fix any issues that it can.
Let's look at <code>src/lib.rs</code> again:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(&amp;self, _: i32);
}
<span class="boring">}</span></code></pre></pre>
<p>It's re-written our code to introduce a parameter name for that <code>i32</code> value.
In this case, since it had no name, <code>cargo fix</code> will replace it with <code>_</code>,
which is conventional for unused variables.</p>
<p><code>cargo fix</code> can't always fix your code automatically.
If <code>cargo fix</code> can't fix something, it will print the warning that it cannot fix
to the console. If you see one of these warnings, you'll have to update your code manually.
See the <a href="editions/advanced-migrations.html">Advanced migration strategies</a> chapter for more on working with the migration process, and read the chapters in this guide which explain which changes are needed.
If you have problems, please seek help at the <a href="https://users.rust-lang.org/">user's forums</a>.</p>
<h2 id="enabling-the-new-edition-to-use-new-features"><a class="header" href="#enabling-the-new-edition-to-use-new-features">Enabling the new edition to use new features</a></h2>
<p>In order to use some new features, you must explicitly opt in to the new
edition. Once you're ready to continue, change your <code>Cargo.toml</code> to add the new
<code>edition</code> key/value pair. For example:</p>
<pre><code class="language-toml">[package]
name = "foo"
version = "0.1.0"
edition = "2018"
</code></pre>
<p>If there's no <code>edition</code> key, Cargo will default to Rust 2015. But in this case,
we've chosen <code>2018</code>, and so our code will compile with Rust 2018!</p>
<h2 id="testing-your-code-in-the-new-edition"><a class="header" href="#testing-your-code-in-the-new-edition">Testing your code in the new edition</a></h2>
<p>The next step is to test your project on the new edition.
Run your project tests to verify that everything still works, such as running <a href="editions/../../cargo/commands/cargo-test.html"><code>cargo test</code></a>.
If new warnings are issued, you may want to consider running <code>cargo fix</code> again (without the <code>--edition</code> flag) to apply any suggestions given by the compiler.</p>
<p>At this point, you may still need to do some manual changes. For example, the automatic migration does not update doctests, and build-time code generation or macros may need manual updating. See the <a href="editions/advanced-migrations.html">advanced migrations chapter</a> for more information.</p>
<p>Congrats! Your code is now valid in both Rust 2015 and Rust 2018!</p>
<h2 id="reformatting-with-rustfmt"><a class="header" href="#reformatting-with-rustfmt">Reformatting with rustfmt</a></h2>
<p>If you use <a href="https://github.com/rust-lang/rustfmt">rustfmt</a> to automatically maintain formatting within your project, then you should consider reformatting using the new formatting rules of the new edition.</p>
<p>Before reformatting, if you are using a source control tool such as <code>git</code>, you may want to commit all the changes you have made up to this point before taking this step. It can be useful to put formatting changes in a separate commit, because then you can see which changes are just formatting versus other code changes, and also possibly ignore the formatting changes in <code>git blame</code>.</p>
<pre><code class="language-console">cargo fmt
</code></pre>
<p>See the <a href="editions/../rust-2024/rustfmt-style-edition.html">style editions chapter</a> for more information.</p>
<h2 id="migrating-to-an-unstable-edition"><a class="header" href="#migrating-to-an-unstable-edition">Migrating to an unstable edition</a></h2>
<p>After an edition is released, there is roughly a three year window before the next edition.
During that window, new features may be added to the next edition, which will only be available on the <a href="editions/../../book/appendix-07-nightly-rust.html">nightly channel</a>.
If you want to help test those new features before they are stabilized, you can use the nightly channel to try them out.</p>
<p>The steps are roughly similar to the stable channel:</p>
<ol>
<li>Install the most recent nightly: <code>rustup update nightly</code>.</li>
<li>Run <code>cargo +nightly fix --edition</code>.</li>
<li>Edit <code>Cargo.toml</code> and place <code>cargo-features = ["edition20xx"]</code> at the top (above <code>[package]</code>), and change the edition field to say <code>edition = "20xx"</code> where <code>20xx</code> is the edition you are upgrading to.</li>
<li>Run <code>cargo +nightly check</code> to verify it now works in the new edition.</li>
</ol>
<blockquote>
<p><strong>⚠ Caution</strong>: Features implemented in the next edition may not have automatic migrations implemented with <code>cargo fix</code>, and the features themselves may not be finished.
When possible, this guide should contain information about which features are implemented
on nightly along with more information about their status.
A few months before the edition is stabilized, all of the new features should be fully implemented, and the <a href="https://blog.rust-lang.org/">Rust Blog</a> will announce a call for testing.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-migration-strategies"><a class="header" href="#advanced-migration-strategies">Advanced migration strategies</a></h1>
<h2 id="how-migrations-work"><a class="header" href="#how-migrations-work">How migrations work</a></h2>
<p><a href="editions/../../cargo/commands/cargo-fix.html"><code>cargo fix --edition</code></a> works by running the equivalent of <a href="editions/../../cargo/commands/cargo-check.html"><code>cargo check</code></a> on your project with special <a href="editions/../../rustc/lints/index.html">lints</a> enabled which will detect code that may not compile in the next edition.
These lints include instructions on how to modify the code to make it compatible on both the current and the next edition.
<code>cargo fix</code> applies these changes to the source code, and then runs <code>cargo check</code> again to verify that the fixes work.
If the fixes fail, then it will back out the changes and display a warning.</p>
<p>Changing the code to be simultaneously compatible with both the current and next edition makes it easier to incrementally migrate the code.
If the automated migration does not completely succeed, or requires manual help, you can iterate while staying on the original edition before changing <code>Cargo.toml</code> to use the next edition.</p>
<p>The lints that <code>cargo fix --edition</code> apply are part of a <a href="editions/../../rustc/lints/groups.html">lint group</a>.
For example, when migrating from 2018 to 2021, Cargo uses the <code>rust-2021-compatibility</code> group of lints to fix the code.
Check the <a href="editions/advanced-migrations.html#partial-migration-with-broken-code">Partial migration</a> section below for tips on using individual lints to help with migration.</p>
<p><code>cargo fix</code> may run <code>cargo check</code> multiple times.
For example, after applying one set of fixes, this may trigger new warnings which require further fixes.
Cargo repeats this until no new warnings are generated.</p>
<h2 id="migrating-multiple-configurations"><a class="header" href="#migrating-multiple-configurations">Migrating multiple configurations</a></h2>
<p><code>cargo fix</code> can only work with a single configuration at a time.
If you use <a href="editions/../../cargo/reference/features.html">Cargo features</a> or <a href="editions/../../reference/conditional-compilation.html">conditional compilation</a>, then you may need to run <code>cargo fix</code> multiple times with different flags.</p>
<p>For example, if you have code that uses <code>#[cfg]</code> attributes to include different code for different platforms, you may need to run <code>cargo fix</code> with the <code>--target</code> option to fix for different targets.
This may require moving your code between machines if you don't have cross-compiling available.</p>
<p>Similarly, if you have conditions on Cargo features, like <code>#[cfg(feature = "my-optional-thing")]</code>, it is recommended to use the <code>--all-features</code> flag to allow <code>cargo fix</code> to migrate all the code behind those feature gates.
If you want to migrate feature code individually, you can use the <code>--features</code> flag to migrate one at a time.</p>
<h2 id="migrating-a-large-project-or-workspace"><a class="header" href="#migrating-a-large-project-or-workspace">Migrating a large project or workspace</a></h2>
<p>You can migrate a large project incrementally to make the process easier if you run into problems.</p>
<p>In a <a href="editions/../../cargo/reference/workspaces.html">Cargo workspace</a>, each package defines its own edition, so the process naturally involves migrating one package at a time.</p>
<p>Within a <a href="editions/../../cargo/reference/manifest.html#the-package-section">Cargo package</a>, you can either migrate the entire package at once, or migrate individual <a href="editions/../../cargo/reference/cargo-targets.html">Cargo targets</a> one at a time.
For example, if you have multiple binaries, tests, and examples, you can use specific target selection flags with <code>cargo fix --edition</code> to migrate just that one target.
By default, <code>cargo fix</code> uses <code>--all-targets</code>.</p>
<p>For even more advanced cases, you can specify the edition for each individual target in <code>Cargo.toml</code> like this:</p>
<pre><code class="language-toml">[[bin]]
name = "my-binary"
edition = "2018"
</code></pre>
<p>This usually should not be required, but is an option if you have a lot of targets and are having difficulty migrating them all together.</p>
<h2 id="partial-migration-with-broken-code"><a class="header" href="#partial-migration-with-broken-code">Partial migration with broken code</a></h2>
<p>Sometimes the fixes suggested by the compiler may fail to work.
When this happens, Cargo will report a warning indicating what happened and what the error was.
However, by default it will automatically back out the changes it made.
It can be helpful to keep the code in the broken state and manually resolve the issue.
Some of the fixes may have been correct, and the broken fix may be <em>mostly</em> correct, but just need minor tweaking.</p>
<p>In this situation, use the <code>--broken-code</code> option with <code>cargo fix</code> to tell Cargo not to back out the changes.
Then, you can go manually inspect the error and investigate what is needed to fix it.</p>
<p>Another option to incrementally migrate a project is to apply individual fixes separately, one at a time.
You can do this by adding the individual lints as warnings, and then either running <code>cargo fix</code> (without the <code>--edition</code> flag) or using your editor or IDE to apply its suggestions if it supports "Quick Fixes".</p>
<p>For example, the 2018 edition uses the <a href="editions/../../rustc/lints/listing/allowed-by-default.html#keyword-idents"><code>keyword-idents</code></a> lint to fix any conflicting keywords.
You can add <code>#![warn(keyword_idents)]</code> to the top of each crate (like at the top of <code>src/lib.rs</code> or <code>src/main.rs</code>).
Then, running <code>cargo fix</code> will apply just the suggestions for that lint.</p>
<p>You can see the list of lints enabled for each edition in the <a href="editions/../../rustc/lints/groups.html">lint group</a> page, or run the <code>rustc -Whelp</code> command.</p>
<h2 id="migrating-macros"><a class="header" href="#migrating-macros">Migrating macros</a></h2>
<p>Some macros may require manual work to fix them for the next edition.
For example, <code>cargo fix --edition</code> may not be able to automatically fix a macro that generates syntax that does not work in the next edition.</p>
<p>This may be a problem for both <a href="editions/../../reference/procedural-macros.html">proc macros</a> and <code>macro_rules</code>-style macros.
<code>macro_rules</code> macros can sometimes be automatically updated if the macro is used within the same crate, but there are several situations where it cannot.
Proc macros in general cannot be automatically fixed at all.</p>
<p>For example, if we migrate a crate containing this (contrived) macro <code>foo</code> from 2015 to 2018, <code>foo</code> would not be automatically fixed.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! foo {
    () =&gt; {
        let dyn = 1;
        println!("it is {}", dyn);
    };
}
<span class="boring">}</span></code></pre></pre>
<p>When this macro is defined in a 2015 crate, it can be used from a crate of any other edition due to macro hygiene (discussed below).
In 2015, <code>dyn</code> is a normal identifier and can be used without restriction.</p>
<p>However, in 2018, <code>dyn</code> is no longer a valid identifier.
When using <code>cargo fix --edition</code> to migrate to 2018, Cargo won't display any warnings or errors at all.
However, <code>foo</code> won't work when called from any crate.</p>
<p>If you have macros, you are encouraged to make sure you have tests that fully cover the macro's syntax.
You may also want to test the macros by importing and using them in crates from multiple editions, just to ensure it works correctly everywhere.
If you run into issues, you'll need to read through the chapters of this guide to understand how the code can be changed to work across all editions.</p>
<h3 id="macro-hygiene"><a class="header" href="#macro-hygiene">Macro hygiene</a></h3>
<p>Macros use a system called "edition hygiene" where the tokens within a macro are marked with which edition they come from.
This allows external macros to be called from crates of varying editions without needing to worry about which edition it is called from.</p>
<p>Let's take a closer look at the example above that defines a <code>macro_rules</code> macro using <code>dyn</code> as an identifier.
If that macro was defined in a crate using the 2015 edition, then that macro works fine, even if it were called from a 2018 crate where <code>dyn</code> is a keyword and that would normally be a syntax error.
The <code>let dyn = 1;</code> tokens are marked as being from 2015, and the compiler will remember that wherever that code gets expanded.
The parser looks at the edition of the tokens to know how to interpret it.</p>
<p>The problem arises when changing the edition to 2018 in the crate where it is defined.
Now, those tokens are tagged with the 2018 edition, and those will fail to parse.
However, since we never called the macro from our crate, <code>cargo fix --edition</code> never had a chance to inspect the macro and fix it.</p>
<!-- TODO: hopefully someday, the reference will have chapters on how expansion works, and this can link there for actual details. -->
<h2 id="documentation-tests"><a class="header" href="#documentation-tests">Documentation tests</a></h2>
<p>At this time, <code>cargo fix</code> is not able to update <a href="editions/../../rustdoc/documentation-tests.html">documentation tests</a>.
After updating the edition in <code>Cargo.toml</code>, you should run <code>cargo test</code> to ensure everything still passes.
If your documentation tests use syntax that is not supported in the new edition, you will need to update them manually.</p>
<p>In rare cases, you can manually set the edition for each test.
For example, you can use the <a href="editions/../../rustdoc/documentation-tests.html#attributes"><code>edition2018</code> annotation</a> on the triple backticks to tell <code>rustdoc</code> which edition to use.</p>
<h2 id="generated-code"><a class="header" href="#generated-code">Generated code</a></h2>
<p>Another area where the automated fixes cannot apply is if you have a build script which generates Rust code at compile time (see <a href="editions/../../cargo/reference/build-script-examples.html#code-generation">Code generation</a> for an example).
In this situation, if you end up with code that doesn't work in the next edition, you will need to manually change the build script to generate code that is compatible.</p>
<h2 id="migrating-non-cargo-projects"><a class="header" href="#migrating-non-cargo-projects">Migrating non-Cargo projects</a></h2>
<p>If your project is not using Cargo as a build system, it may still be possible to make use of the automated lints to assist migrating to the next edition.
You can enable the migration lints as described above by enabling the appropriate <a href="editions/../../rustc/lints/groups.html">lint group</a>.
For example, you can use the <code>#![warn(rust_2021_compatibility)]</code> attribute or the <code>-Wrust-2021-compatibility</code> or <code>--force-warns=rust-2021-compatibility</code> <a href="editions/../../rustc/lints/levels.html#via-compiler-flag">CLI flag</a>.</p>
<p>The next step is to apply those lints to your code.
There are several options here:</p>
<ul>
<li>Manually read the warnings and apply the suggestions recommended by the compiler.</li>
<li>Use an editor or IDE that supports automatically applying suggestions.
For example, <a href="https://code.visualstudio.com/">Visual Studio Code</a> with the <a href="https://marketplace.visualstudio.com/items?itemName=matklad.rust-analyzer">Rust Analyzer extension</a> has the ability to use the "Quick Fix" links to automatically apply suggestions.
Many other editors and IDEs have similar functionality.</li>
<li>Write a migration tool using the <a href="https://crates.io/crates/rustfix"><code>rustfix</code></a> library.
This is the library that Cargo uses internally to take the <a href="editions/../../rustc/json.html">JSON messages</a> from the compiler and modify the source code.
Check the <a href="https://github.com/rust-lang/cargo/tree/master/crates/rustfix/examples"><code>examples</code> directory</a> for examples of how to use the library.</li>
</ul>
<h2 id="writing-idiomatic-code-in-a-new-edition"><a class="header" href="#writing-idiomatic-code-in-a-new-edition">Writing idiomatic code in a new edition</a></h2>
<p>Editions are not only about new features and removing old ones.
In any programming language, idioms change over time, and Rust is no exception.
While old code will continue to compile, it might be written with different idioms today.</p>
<p>For example, in Rust 2015, external crates must be listed with <code>extern crate</code> like this:</p>
<pre><code class="language-rust ignore">// src/lib.rs
extern crate rand;</code></pre>
<p>In Rust 2018, it is <a href="editions/../rust-2018/path-changes.html#no-more-extern-crate">no longer necessary</a> to include these items.</p>
<p><code>cargo fix</code> has the <code>--edition-idioms</code> option to automatically transition some of these idioms to the new syntax.</p>
<blockquote>
<p><strong>Warning</strong>: The current <em>"idiom lints"</em> are known to have some problems.
They may make incorrect suggestions which may fail to compile.
The current lints are:</p>
<ul>
<li>Edition 2018:
<ul>
<li><a href="editions/../../rustc/lints/listing/allowed-by-default.html#unused-extern-crates"><code>unused-extern-crates</code></a></li>
<li><a href="editions/../../rustc/lints/listing/allowed-by-default.html#explicit-outlives-requirements"><code>explicit-outlives-requirements</code></a></li>
</ul>
</li>
<li>Edition 2021 does not have any idiom lints.</li>
</ul>
<p>The following instructions are recommended only for the intrepid who are willing to work through a few compiler/Cargo bugs!
If you run into problems, you can try the <code>--broken-code</code> option <a href="editions/advanced-migrations.html#partial-migration-with-broken-code">described above</a> to make as much progress as possible, and then resolve the remaining issues manually.</p>
</blockquote>
<p>With that out of the way, we can instruct Cargo to fix our code snippet with:</p>
<pre><code class="language-console">cargo fix --edition-idioms
</code></pre>
<p>Afterwards, the line with <code>extern crate rand;</code> in <code>src/lib.rs</code> will be removed.</p>
<p>We're now more idiomatic, and we didn't have to fix our code manually!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-2015"><a class="header" href="#rust-2015">Rust 2015</a></h1>
<p>Rust 2015 has a theme of "stability". It commenced with the release of 1.0,
and is the "default edition". The edition system was conceived in late 2017,
but Rust 1.0 was released in May of 2015. As such, 2015 is the edition
that you get when you don't specify any particular edition, for backwards
compatibility reasons.</p>
<p>"Stability" is the theme of Rust 2015 because 1.0 marked a huge change in
Rust development. Previous to Rust 1.0, Rust was changing on a daily basis.
This made it very difficult to write large software in Rust, and made it
difficult to learn. With the release of Rust 1.0 and Rust 2015, we committed
to backwards compatibility, ensuring a solid foundation for people to build
projects on top of.</p>
<p>Since it's the default edition, there's no way to port your code to Rust
2015; it just <em>is</em>. You'll be transitioning <em>away</em> from 2015, but never
really <em>to</em> 2015. As such, there's not much else to say about it!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-2018"><a class="header" href="#rust-2018">Rust 2018</a></h1>
<div class="table-wrapper"><table><thead><tr><th>Info</th><th></th></tr></thead><tbody>
<tr><td>RFC</td><td><a href="https://rust-lang.github.io/rfcs/2052-epochs.html">#2052</a>, which also proposed the Edition system</td></tr>
<tr><td>Release version</td><td><a href="https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html">1.31.0</a></td></tr>
</tbody></table>
</div>
<p>The edition system was created for the release of Rust 2018. The release of the Rust 2018 edition coincided with a number of other features all coordinated around the theme of <em>productivity</em>. The majority of those features were backwards compatible and are now available on all editions; however, some of those changes required the edition mechanism (most notably the <a href="rust-2018/path-changes.html">module system changes</a>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="path-and-module-system-changes"><a class="header" href="#path-and-module-system-changes">Path and module system changes</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" /></p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<ul>
<li>Paths in <code>use</code> declarations now work the same as other paths.</li>
<li>Paths starting with <code>::</code> must now be followed with an external crate.</li>
<li>Paths in <code>pub(in path)</code> visibility modifiers must now start with <code>crate</code>, <code>self</code>, or <code>super</code>.</li>
</ul>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>The module system is often one of the hardest things for people new to Rust. Everyone
has their own things that take time to master, of course, but there's a root
cause for why it's so confusing to many: while there are simple and
consistent rules defining the module system, their consequences can feel
inconsistent, counterintuitive and mysterious.</p>
<p>As such, the 2018 edition of Rust introduces a few new module system
features, but they end up <em>simplifying</em> the module system, to make it more
clear as to what is going on.</p>
<p>Here's a brief summary:</p>
<ul>
<li><code>extern crate</code> is no longer needed in 99% of circumstances.</li>
<li>The <code>crate</code> keyword refers to the current crate.</li>
<li>Paths may start with a crate name, even within submodules.</li>
<li>Paths starting with <code>::</code> must reference an external crate.</li>
<li>A <code>foo.rs</code> and <code>foo/</code> subdirectory may coexist; <code>mod.rs</code> is no longer needed
when placing submodules in a subdirectory.</li>
<li>Paths in <code>use</code> declarations work the same as other paths.</li>
</ul>
<p>These may seem like arbitrary new rules when put this way, but the mental
model is now significantly simplified overall. Read on for more details!</p>
<h2 id="more-details"><a class="header" href="#more-details">More details</a></h2>
<p>Let's talk about each new feature in turn.</p>
<h3 id="no-more-extern-crate"><a class="header" href="#no-more-extern-crate">No more <code>extern crate</code></a></h3>
<p>This one is quite straightforward: you no longer need to write <code>extern crate</code> to
import a crate into your project. Before:</p>
<pre><code class="language-rust ignore">// Rust 2015

extern crate futures;

mod submodule {
    use futures::Future;
}</code></pre>
<p>After:</p>
<pre><code class="language-rust ignore">// Rust 2018

mod submodule {
    use futures::Future;
}</code></pre>
<p>Now, to add a new crate to your project, you can add it to your <code>Cargo.toml</code>,
and then there is no step two. If you're not using Cargo, you already had to pass
<code>--extern</code> flags to give <code>rustc</code> the location of external crates, so you'd just
keep doing what you were doing there as well.</p>
<h4 id="an-exception"><a class="header" href="#an-exception">An exception</a></h4>
<p>There's one exception to this rule, and that's the "sysroot" crates. These are the
crates distributed with Rust itself.</p>
<p>Usually these are only needed in very specialized situations. Starting in
1.41, <code>rustc</code> accepts the <code>--extern=CRATE_NAME</code> flag which automatically adds
the given crate name in a way similar to <code>extern crate</code>. Build tools may use
this to inject sysroot crates into the crate's prelude. Cargo does not have a
general way to express this, though it uses it for <code>proc_macro</code> crates.</p>
<p>Some examples of needing to explicitly import sysroot crates are:</p>
<ul>
<li><a href="rust-2018/../../std/index.html"><code>std</code></a>: Usually this is not necessary, because <code>std</code> is automatically
imported unless the crate is marked with <a href="rust-2018/../../reference/names/preludes.html#the-no_std-attribute"><code>#![no_std]</code></a>.</li>
<li><a href="rust-2018/../../core/index.html"><code>core</code></a>: Usually this is not necessary, because <code>core</code> is automatically
imported, unless the crate is marked with <a href="https://github.com/rust-lang/rust/issues/29639"><code>#![no_core]</code></a>. For
example, some of the internal crates used by the standard library itself
need this.</li>
<li><a href="rust-2018/../../proc_macro/index.html"><code>proc_macro</code></a>: This is automatically imported by Cargo if it is a
proc-macro crate starting in 1.42. <code>extern crate proc_macro;</code> would be
needed if you want to support older releases, or if using another build tool
that does not pass the appropriate <code>--extern</code> flags to <code>rustc</code>.</li>
<li><a href="rust-2018/../../alloc/index.html"><code>alloc</code></a>: Items in the <code>alloc</code> crate are usually accessed via re-exports in
the <code>std</code> crate. If you are working with a <code>no_std</code> crate that supports
allocation, then you may need to explicitly import <code>alloc</code>.</li>
<li><a href="rust-2018/../../test/index.html"><code>test</code></a>: This is only available on the <a href="rust-2018/../../book/appendix-07-nightly-rust.html">nightly channel</a>, and is usually
only used for the unstable benchmark support.</li>
</ul>
<h4 id="macros"><a class="header" href="#macros">Macros</a></h4>
<p>One other use for <code>extern crate</code> was to import macros; that's no longer needed.
Macros may be imported with <code>use</code> like any other item. For example, the
following use of <code>extern crate</code>:</p>
<pre><code class="language-rust ignore">#[macro_use]
extern crate bar;

fn main() {
    baz!();
}</code></pre>
<p>Can be changed to something like the following:</p>
<pre><code class="language-rust ignore">use bar::baz;

fn main() {
    baz!();
}</code></pre>
<h4 id="renaming-crates"><a class="header" href="#renaming-crates">Renaming crates</a></h4>
<p>If you've been using <code>as</code> to rename your crate like this:</p>
<pre><code class="language-rust ignore">extern crate futures as f;

use f::Future;</code></pre>
<p>then removing the <code>extern crate</code> line on its own won't work. You'll need to do this:</p>
<pre><code class="language-rust ignore">use futures as f;

use self::f::Future;</code></pre>
<p>This change will need to happen in any module that uses <code>f</code>.</p>
<h3 id="the-crate-keyword-refers-to-the-current-crate"><a class="header" href="#the-crate-keyword-refers-to-the-current-crate">The <code>crate</code> keyword refers to the current crate</a></h3>
<p>In <code>use</code> declarations and in other code, you can refer to the root of the
current crate with the <code>crate::</code> prefix. For instance, <code>crate::foo::bar</code> will
always refer to the name <code>bar</code> inside the module <code>foo</code>, from anywhere else in
the same crate.</p>
<p>The prefix <code>::</code> previously referred to either the crate root or an external
crate; it now unambiguously refers to an external crate. For instance,
<code>::foo::bar</code> always refers to the name <code>bar</code> inside the external crate <code>foo</code>.</p>
<h3 id="extern-crate-paths"><a class="header" href="#extern-crate-paths">Extern crate paths</a></h3>
<p>Previously, using an external crate in a module without a <code>use</code> import
required a leading <code>::</code> on the path.</p>
<pre><code class="language-rust ignore">// Rust 2015

extern crate chrono;

fn foo() {
    // this works in the crate root
    let x = chrono::Utc::now();
}

mod submodule {
    fn function() {
        // but in a submodule it requires a leading :: if not imported with `use`
        let x = ::chrono::Utc::now();
    }
}</code></pre>
<p>Now, extern crate names are in scope in the entire crate, including
submodules.</p>
<pre><code class="language-rust ignore">// Rust 2018

fn foo() {
    // this works in the crate root
    let x = chrono::Utc::now();
}

mod submodule {
    fn function() {
        // crates may be referenced directly, even in submodules
        let x = chrono::Utc::now();
    }
}</code></pre>
<p>If you have a local module or item with the same name as an external crate, a
path beginning with that name will be taken to refer to the local module or
item. To explicitly refer to the external crate, use the <code>::name</code> form.</p>
<h3 id="no-more-modrs"><a class="header" href="#no-more-modrs">No more <code>mod.rs</code></a></h3>
<p>In Rust 2015, if you have a submodule:</p>
<pre><code class="language-rust ignore">// This `mod` declaration looks for the `foo` module in
// `foo.rs` or `foo/mod.rs`.
mod foo;</code></pre>
<p>It can live in <code>foo.rs</code> or <code>foo/mod.rs</code>. If it has submodules of its own, it
<em>must</em> be <code>foo/mod.rs</code>. So a <code>bar</code> submodule of <code>foo</code> would live at
<code>foo/bar.rs</code>.</p>
<p>In Rust 2018 the restriction that a module with submodules must be named
<code>mod.rs</code> is lifted. <code>foo.rs</code> can just be <code>foo.rs</code>,
and the submodule is still <code>foo/bar.rs</code>. This eliminates the special
name, and if you have a bunch of files open in your editor, you can clearly
see their names, instead of having a bunch of tabs named <code>mod.rs</code>.</p>
<table>
  <thead>
    <tr>
      <th>Rust 2015</th>
      <th>Rust 2018</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
<pre>
.
├── lib.rs
└── foo/
    ├── mod.rs
    └── bar.rs
</pre>
    </td>
    <td>
<pre>
.
├── lib.rs
├── foo.rs
└── foo/
    └── bar.rs
</pre>
      </td>
    </tr>
  </tbody>
</table>
<h3 id="use-paths"><a class="header" href="#use-paths"><code>use</code> paths</a></h3>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.32-brightgreen.svg" alt="Minimum Rust version: 1.32" /></p>
<p>Rust 2018 simplifies and unifies path handling compared to Rust 2015. In Rust
2015, paths work differently in <code>use</code> declarations than they do elsewhere. In
particular, paths in <code>use</code> declarations would always start from the crate
root, while paths in other code implicitly started from the current scope.
Those differences didn't have any effect in the top-level module, which meant
that everything would seem straightforward until working on a project large
enough to have submodules.</p>
<p>In Rust 2018, paths in <code>use</code> declarations and in other code work the same way,
both in the top-level module and in any submodule. You can use a relative path
from the current scope, a path starting from an external crate name, or a path
starting with <code>::</code>, <code>crate</code>, <code>super</code>, or <code>self</code>.</p>
<p>Code that looked like this:</p>
<pre><code class="language-rust ignore">// Rust 2015

extern crate futures;

use futures::Future;

mod foo {
    pub struct Bar;
}

use foo::Bar;

fn my_poll() -&gt; futures::Poll { ... }

enum SomeEnum {
    V1(usize),
    V2(String),
}

fn func() {
    let five = std::sync::Arc::new(5);
    use SomeEnum::*;
    match ... {
        V1(i) =&gt; { ... }
        V2(s) =&gt; { ... }
    }
}</code></pre>
<p>will look exactly the same in Rust 2018, except that you can delete the <code>extern crate</code> line:</p>
<pre><code class="language-rust ignore">// Rust 2018

use futures::Future;

mod foo {
    pub struct Bar;
}

use foo::Bar;

fn my_poll() -&gt; futures::Poll { ... }

enum SomeEnum {
    V1(usize),
    V2(String),
}

fn func() {
    let five = std::sync::Arc::new(5);
    use SomeEnum::*;
    match ... {
        V1(i) =&gt; { ... }
        V2(s) =&gt; { ... }
    }
}</code></pre>
<p>The same code will also work completely unmodified in a submodule:</p>
<pre><code class="language-rust ignore">// Rust 2018

mod submodule {
    use futures::Future;

    mod foo {
        pub struct Bar;
    }

    use foo::Bar;

    fn my_poll() -&gt; futures::Poll { ... }

    enum SomeEnum {
        V1(usize),
        V2(String),
    }

    fn func() {
        let five = std::sync::Arc::new(5);
        use SomeEnum::*;
        match ... {
            V1(i) =&gt; { ... }
            V2(s) =&gt; { ... }
        }
    }
}</code></pre>
<p>This makes it easy to move code around in a project, and avoids introducing
additional complexity to multi-module projects.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="anonymous-trait-function-parameters-deprecated"><a class="header" href="#anonymous-trait-function-parameters-deprecated">Anonymous trait function parameters deprecated</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" /></p>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/stable/reference/items/traits.html#parameter-patterns">Trait function parameters</a> may use any irrefutable pattern when the function has a body.</li>
</ul>
<h2 id="details"><a class="header" href="#details">Details</a></h2>
<p>In accordance with RFC <a href="https://github.com/rust-lang/rfcs/pull/1685">#1685</a>,
parameters in trait method declarations are no longer allowed to be anonymous.</p>
<p>For example, in the 2015 edition, this was allowed:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(&amp;self, u8);
}
<span class="boring">}</span></code></pre></pre>
<p>In the 2018 edition, all parameters must be given an argument name  (even if it's just
<code>_</code>):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(&amp;self, baz: u8);
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="new-keywords"><a class="header" href="#new-keywords">New keywords</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.27-brightgreen.svg" alt="Minimum Rust version: 1.27" /></p>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<ul>
<li><code>dyn</code> is a <a href="https://doc.rust-lang.org/reference/keywords.html#strict-keywords">strict keyword</a>, in 2015 it is a <a href="https://doc.rust-lang.org/reference/keywords.html#weak-keywords">weak keyword</a>.</li>
<li><code>async</code> and <code>await</code> are <a href="https://doc.rust-lang.org/reference/keywords.html#strict-keywords">strict keywords</a>.</li>
<li><code>try</code> is a <a href="https://doc.rust-lang.org/reference/keywords.html#reserved-keywords">reserved keyword</a>.</li>
</ul>
<h2 id="motivation-1"><a class="header" href="#motivation-1">Motivation</a></h2>
<h3 id="dyn-trait-for-trait-objects"><a class="header" href="#dyn-trait-for-trait-objects"><code>dyn Trait</code> for trait objects</a></h3>
<p>The <code>dyn Trait</code> feature is the new syntax for using trait objects. In short:</p>
<ul>
<li><code>Box&lt;Trait&gt;</code> becomes <code>Box&lt;dyn Trait&gt;</code></li>
<li><code>&amp;Trait</code> and <code>&amp;mut Trait</code> become <code>&amp;dyn Trait</code> and <code>&amp;mut dyn Trait</code></li>
</ul>
<p>And so on. In code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {}

impl Trait for i32 {}

// old
fn function1() -&gt; Box&lt;Trait&gt; {
<span class="boring">unimplemented!()
</span>}

// new
fn function2() -&gt; Box&lt;dyn Trait&gt; {
<span class="boring">unimplemented!()
</span>}
<span class="boring">}</span></code></pre></pre>
<p>That's it!</p>
<h4 id="why"><a class="header" href="#why">Why?</a></h4>
<p>Using just the trait name for trait objects turned out to be a bad decision.
The current syntax is often ambiguous and confusing, even to veterans,
and favors a feature that is not more frequently used than its alternatives,
is sometimes slower, and often cannot be used at all when its alternatives can.</p>
<p>Furthermore, with <code>impl Trait</code> arriving, "<code>impl Trait</code> vs <code>dyn Trait</code>" is much
more symmetric, and therefore a bit nicer, than "<code>impl Trait</code> vs <code>Trait</code>".
<code>impl Trait</code> is explained <a href="rust-2018/../../rust-by-example/trait/impl_trait.html">here</a>.</p>
<p>In the new edition, you should therefore prefer <code>dyn Trait</code> to just <code>Trait</code>
where you need a trait object.</p>
<h3 id="async-and-await"><a class="header" href="#async-and-await"><code>async</code> and <code>await</code></a></h3>
<p>These keywords are reserved to implement the async-await feature of Rust, which was ultimately <a href="https://blog.rust-lang.org/2019/11/07/Async-await-stable.html">released to stable in 1.39.0</a>.</p>
<h3 id="try-keyword"><a class="header" href="#try-keyword"><code>try</code> keyword</a></h3>
<p>The <code>try</code> keyword is reserved for use in <code>try</code> blocks, which have not (as of this writing) been stabilized (<a href="https://github.com/rust-lang/rust/issues/31436">tracking issue</a>)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="method-dispatch-for-raw-pointers-to-inference-variables"><a class="header" href="#method-dispatch-for-raw-pointers-to-inference-variables">Method dispatch for raw pointers to inference variables</a></h1>
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<ul>
<li>The <a href="https://github.com/rust-lang/rust/issues/46906"><code>tyvar_behind_raw_pointer</code></a> lint is now a hard error.</li>
</ul>
<h2 id="details-1"><a class="header" href="#details-1">Details</a></h2>
<p>See Rust issue <a href="https://github.com/rust-lang/rust/issues/46906">#46906</a> for details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-changes"><a class="header" href="#cargo-changes">Cargo changes</a></h1>
<h2 id="summary-4"><a class="header" href="#summary-4">Summary</a></h2>
<ul>
<li>If there is a target definition in a <code>Cargo.toml</code> manifest, it no longer
automatically disables automatic discovery of other targets.</li>
<li>Target paths of the form <code>src/{target_name}.rs</code> are no longer inferred for
targets where the <code>path</code> field is not set.</li>
<li><code>cargo install</code> for the current directory is no longer allowed, you must
specify <code>cargo install --path .</code> to install the current package.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-2021"><a class="header" href="#rust-2021">Rust 2021</a></h1>
<div class="table-wrapper"><table><thead><tr><th>Info</th><th></th></tr></thead><tbody>
<tr><td>RFC</td><td><a href="https://github.com/rust-lang/rfcs/pull/3085">#3085</a></td></tr>
<tr><td>Release version</td><td>1.56.0</td></tr>
</tbody></table>
</div>
<p>The Rust 2021 Edition contains several changes that bring new capabilities and more consistency to the language,
and opens up room for expansion in the future.
The following chapters dive into the details of each change,
and they include guidance on migrating your existing code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="additions-to-the-prelude"><a class="header" href="#additions-to-the-prelude">Additions to the prelude</a></h1>
<h2 id="summary-5"><a class="header" href="#summary-5">Summary</a></h2>
<ul>
<li>The <code>TryInto</code>, <code>TryFrom</code> and <code>FromIterator</code> traits are now part of the prelude.</li>
<li>This might make calls to trait methods ambiguous which could make some code fail to compile.</li>
</ul>
<h2 id="details-2"><a class="header" href="#details-2">Details</a></h2>
<p>The <a href="https://doc.rust-lang.org/stable/std/prelude/index.html">prelude of the standard library</a>
is the module containing everything that is automatically imported in every module.
It contains commonly used items such as <code>Option</code>, <code>Vec</code>, <code>drop</code>, and <code>Clone</code>.</p>
<p>The Rust compiler prioritizes any manually imported items over those
from the prelude, to make sure additions to the prelude will not break any existing code.
For example, if you have a crate or module called <code>example</code> containing a <code>pub struct Option;</code>,
then <code>use example::*;</code> will make <code>Option</code> unambiguously refer to the one from <code>example</code>;
not the one from the standard library.</p>
<p>However, adding a <em>trait</em> to the prelude can break existing code in a subtle way.
For example, a call to <code>x.try_into()</code> which comes from a <code>MyTryInto</code> trait might fail
to compile if <code>std</code>'s <code>TryInto</code> is also imported, because the call to <code>try_into</code> is now
ambiguous and could come from either trait. This is the reason we haven't added <code>TryInto</code>
to the prelude yet, since there is a lot of code that would break this way.</p>
<p>As a solution, Rust 2021 will use a new prelude.
It's identical to the current one, except for three new additions:</p>
<ul>
<li><a href="https://doc.rust-lang.org/stable/std/convert/trait.TryInto.html"><code>std::convert::TryInto</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/std/convert/trait.TryFrom.html"><code>std::convert::TryFrom</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/std/iter/trait.FromIterator.html"><code>std::iter::FromIterator</code></a></li>
</ul>
<p>The tracking issue <a href="https://github.com/rust-lang/rust/issues/85684">can be found here</a>.</p>
<h2 id="migration"><a class="header" href="#migration">Migration</a></h2>
<p>As a part of the 2021 edition a migration lint, <code>rust_2021_prelude_collisions</code>, has been added in order to aid in automatic migration of Rust 2018 codebases to Rust 2021.</p>
<p>In order to migrate your code to be Rust 2021 Edition compatible, run:</p>
<pre><code class="language-sh">cargo fix --edition
</code></pre>
<p>The lint detects cases where functions or methods are called that have the same name as the methods defined in one of the new prelude traits. In some cases, it may rewrite your calls in various ways to ensure that you continue to call the same function you did before.</p>
<p>If you'd like to migrate your code manually or better understand what <code>cargo fix</code> is doing, below we've outlined the situations where a migration is needed along with a counter example of when it's not needed.</p>
<h3 id="migration-needed"><a class="header" href="#migration-needed">Migration needed</a></h3>
<h4 id="conflicting-trait-methods"><a class="header" href="#conflicting-trait-methods">Conflicting trait methods</a></h4>
<p>When two traits that are in scope have the same method name, it is ambiguous which trait method should be used. For example:</p>
<pre><pre class="playground"><code class="language-rust">trait MyTrait&lt;A&gt; {
  // This name is the same as the `from_iter` method on the `FromIterator` trait from `std`.  
  fn from_iter(x: Option&lt;A&gt;);
}

impl&lt;T&gt; MyTrait&lt;()&gt; for Vec&lt;T&gt; {
  fn from_iter(_: Option&lt;()&gt;) {}
}

fn main() {
  // Vec&lt;T&gt; implements both `std::iter::FromIterator` and `MyTrait` 
  // If both traits are in scope (as would be the case in Rust 2021),
  // then it becomes ambiguous which `from_iter` method to call
  &lt;Vec&lt;i32&gt;&gt;::from_iter(None);
}</code></pre></pre>
<p>We can fix this by using fully qualified syntax:</p>
<pre><code class="language-rust ignore">fn main() {
  // Now it is clear which trait method we're referring to
  &lt;Vec&lt;i32&gt; as MyTrait&lt;()&gt;&gt;::from_iter(None);
}</code></pre>
<h4 id="inherent-methods-on-dyn-trait-objects"><a class="header" href="#inherent-methods-on-dyn-trait-objects">Inherent methods on <code>dyn Trait</code> objects</a></h4>
<p>Some users invoke methods on a <code>dyn Trait</code> value where the method name overlaps with a new prelude trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod submodule {
  pub trait MyTrait {
    // This has the same name as `TryInto::try_into`
    fn try_into(&amp;self) -&gt; Result&lt;u32, ()&gt;;
  }
}

// `MyTrait` isn't in scope here and can only be referred to through the path `submodule::MyTrait`
fn bar(f: Box&lt;dyn submodule::MyTrait&gt;) {
  // If `std::convert::TryInto` is in scope (as would be the case in Rust 2021),
  // then it becomes ambiguous which `try_into` method to call
  f.try_into();
}
<span class="boring">}</span></code></pre></pre>
<p>Unlike with static dispatch methods, calling a trait method on a trait object does not require that the trait be in scope. The code above works
as long as there is no trait in scope with a conflicting method name. When the <code>TryInto</code> trait is in scope (which is the case in Rust 2021),
this causes an ambiguity. Should the call be to <code>MyTrait::try_into</code> or <code>std::convert::TryInto::try_into</code>?</p>
<p>In these cases, we can fix this by adding an additional dereferences or otherwise clarify the type of the method receiver. This ensures that
the <code>dyn Trait</code> method is chosen, versus the methods from the prelude trait. For example, turning <code>f.try_into()</code> above into <code>(&amp;*f).try_into()</code>
ensures that we're calling <code>try_into</code> on the <code>dyn MyTrait</code> which can only refer to the <code>MyTrait::try_into</code> method.</p>
<h3 id="no-migration-needed"><a class="header" href="#no-migration-needed">No migration needed</a></h3>
<h4 id="inherent-methods"><a class="header" href="#inherent-methods">Inherent methods</a></h4>
<p>Many types define their own inherent methods with the same name as a trait method. For instance, below the struct <code>MyStruct</code> implements <code>from_iter</code> which shares the same name with the method from the trait <code>FromIterator</code> found in the standard library:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::iter::IntoIterator;

struct MyStruct {
  data: Vec&lt;u32&gt;
}

impl MyStruct {
  // This has the same name as `std::iter::FromIterator::from_iter`
  fn from_iter(iter: impl IntoIterator&lt;Item = u32&gt;) -&gt; Self {
    Self {
      data: iter.into_iter().collect()
    }
  }
}

impl std::iter::FromIterator&lt;u32&gt; for MyStruct {
    fn from_iter&lt;I: IntoIterator&lt;Item = u32&gt;&gt;(iter: I) -&gt; Self {
      Self {
        data: iter.into_iter().collect()
      }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Inherent methods always take precedent over trait methods so there's no need for any migration.</p>
<h3 id="implementation-reference"><a class="header" href="#implementation-reference">Implementation Reference</a></h3>
<p>The lint needs to take a couple of factors into account when determining whether or not introducing 2021 Edition to a codebase will cause a name resolution collision (thus breaking the code after changing edition). These factors include:</p>
<ul>
<li>Is the call a <a href="https://doc.rust-lang.org/reference/expressions/call-expr.html#disambiguating-function-calls">fully-qualified call</a> or does it use <a href="https://doc.rust-lang.org/reference/expressions/method-call-expr.html">dot-call method syntax</a>?
<ul>
<li>This will affect how the name is resolved due to auto-reference and auto-dereferencing on method call syntax. Manually dereferencing/referencing will allow specifying priority in the case of dot-call method syntax, while fully-qualified call requires specification of the type and the trait name in the method path (e.g. <code>&lt;Type as Trait&gt;::method</code>)</li>
</ul>
</li>
<li>Is this an <a href="https://doc.rust-lang.org/reference/items/implementations.html#inherent-implementations">inherent method</a> or <a href="https://doc.rust-lang.org/reference/items/implementations.html#trait-implementations">a trait method</a>?
<ul>
<li>Inherent methods that take <code>self</code> will take priority over <code>TryInto::try_into</code> as inherent methods take priority over trait methods, but inherent methods that take <code>&amp;self</code> or <code>&amp;mut self</code> won't take priority due to requiring a auto-reference (while <code>TryInto::try_into</code> does not, as it takes <code>self</code>)</li>
</ul>
</li>
<li>Is the origin of this method from <code>core</code>/<code>std</code>? (As the traits can't have a collision with themselves)</li>
<li>Does the given type implement the trait it could have a collision against?</li>
<li>Is the method being called via dynamic dispatch? (i.e. is the <code>self</code> type <code>dyn Trait</code>)
<ul>
<li>If so, trait imports don't affect resolution, and no migration lint needs to occur</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="default-cargo-feature-resolver"><a class="header" href="#default-cargo-feature-resolver">Default Cargo feature resolver</a></h1>
<h2 id="summary-6"><a class="header" href="#summary-6">Summary</a></h2>
<ul>
<li><code>edition = "2021"</code> implies <code>resolver = "2"</code> in <code>Cargo.toml</code>.</li>
</ul>
<h2 id="details-3"><a class="header" href="#details-3">Details</a></h2>
<p>Since Rust 1.51.0, Cargo has opt-in support for a <a href="rust-2021/../../cargo/reference/resolver.html#feature-resolver-version-2">new feature resolver</a>
which can be activated with <code>resolver = "2"</code> in <code>Cargo.toml</code>.</p>
<p>Starting in Rust 2021, this will be the default.
That is, writing <code>edition = "2021"</code> in <code>Cargo.toml</code> will imply <code>resolver = "2"</code>.</p>
<p>The resolver is a global setting for a <a href="rust-2021/../../cargo/reference/workspaces.html">workspace</a>, and the setting is ignored in dependencies.
The setting is only honored for the top-level package of the workspace.
If you are using a <a href="rust-2021/../../cargo/reference/workspaces.html#virtual-workspace">virtual workspace</a>, you will still need to explicitly set the <a href="rust-2021/../../cargo/reference/resolver.html#resolver-versions"><code>resolver</code> field</a>
in the <code>[workspace]</code> definition if you want to opt-in to the new resolver.</p>
<p>The new feature resolver no longer merges all requested features for
crates that are depended on in multiple ways.
See <a href="https://blog.rust-lang.org/2021/03/25/Rust-1.51.0.html#cargos-new-feature-resolver">the announcement of Rust 1.51</a> for details.</p>
<h2 id="migration-1"><a class="header" href="#migration-1">Migration</a></h2>
<p>There are no automated migration tools for updating for the new resolver.
For most projects, there are usually few or no changes as a result of updating.</p>
<p>When updating with <code>cargo fix --edition</code>, Cargo will display a report if the new resolver will build dependencies with different features.
It may look something like this:</p>
<blockquote>
<p>note: Switching to Edition 2021 will enable the use of the version 2 feature resolver in Cargo.
This may cause some dependencies to be built with fewer features enabled than previously.
More information about the resolver changes may be found at <a href="https://doc.rust-lang.org/nightly/edition-guide/rust-2021/default-cargo-resolver.html">https://doc.rust-lang.org/nightly/edition-guide/rust-2021/default-cargo-resolver.html</a><br>
When building the following dependencies, the given features will no longer be used:</p>
<pre><code class="language-text">  bstr v0.2.16: default, lazy_static, regex-automata, unicode
  libz-sys v1.1.3 (as host dependency): libc
</code></pre>
</blockquote>
<p>This lets you know that certain dependencies will no longer be built with the given features.</p>
<h3 id="build-failures"><a class="header" href="#build-failures">Build failures</a></h3>
<p>There may be some circumstances where your project may not build correctly after the change.
If a dependency declaration in one package assumes that certain features are enabled in another, and those features are now disabled, it may fail to compile.</p>
<p>For example, let's say we have a dependency like this:</p>
<pre><code class="language-toml"># Cargo.toml

[dependencies]
bstr = { version = "0.2.16", default-features = false }
# ...
</code></pre>
<p>And somewhere in our dependency tree, another package has this:</p>
<pre><code class="language-toml"># Another package's Cargo.toml

[build-dependencies]
bstr = "0.2.16"
</code></pre>
<p>In our package, we've been using the <a href="https://docs.rs/bstr/0.2.16/bstr/trait.ByteSlice.html#method.words_with_breaks"><code>words_with_breaks</code></a> method from <code>bstr</code>, which requires <code>bstr</code>'s  "unicode" feature to be enabled.
This has historically worked because Cargo unified the features of <code>bstr</code> between the two packages.
However, after updating to Rust 2021, the new resolver will build <code>bstr</code> twice, once with the default features (as a build dependency), and once with no features (as our normal dependency).
Since <code>bstr</code> is now being built without the "unicode" feature, the <code>words_with_breaks</code> method doesn't exist, and the build will fail with an error that the method is missing.</p>
<p>The solution here is to ensure that the dependency is declared with the features you are actually using.
For example:</p>
<pre><code class="language-toml">[dependencies]
bstr = { version = "0.2.16", default-features = false, features = ["unicode"] }
</code></pre>
<p>In some cases, this may be a problem with a third-party dependency that you don't have direct control over.
You can consider submitting a patch to that project to try to declare the correct set of features for the problematic dependency.
Alternatively, you can add features to any dependency from within your own <code>Cargo.toml</code> file.
For example, if the <code>bstr</code> example given above was declared in some third-party dependency, you can just copy the correct dependency declaration into your own project.
The features will be unified, as long as they match the unification rules of the new resolver. Those are:</p>
<ul>
<li>Features enabled on platform-specific dependencies for targets not currently being built are ignored.</li>
<li>Build-dependencies and proc-macros do not share features with normal dependencies.</li>
<li>Dev-dependencies do not activate features unless building a target that needs them (like tests or examples).</li>
</ul>
<p>A real-world example is using <a href="https://crates.io/crates/diesel"><code>diesel</code></a> and <a href="https://crates.io/crates/diesel_migrations"><code>diesel_migrations</code></a>.
These packages provide database support, and the database is selected using a feature, like this:</p>
<pre><code class="language-toml">[dependencies]
diesel = { version = "1.4.7", features = ["postgres"] }
diesel_migrations = "1.4.0"
</code></pre>
<p>The problem is that <code>diesel_migrations</code> has an internal proc-macro which itself depends on <code>diesel</code>, and the proc-macro assumes its own copy of <code>diesel</code> has the same features enabled as the rest of the dependency graph.
After updating to the new resolver, it fails to build because now there are two copies of <code>diesel</code>, and the one built for the proc-macro is missing the "postgres" feature.</p>
<p>A solution here is to add <code>diesel</code> as a build-dependency with the required features, for example:</p>
<pre><code class="language-toml">[build-dependencies]
diesel = { version = "1.4.7", features = ["postgres"] }
</code></pre>
<p>This causes Cargo to add "postgres" as a feature for host dependencies (proc-macros and build-dependencies).
Now, the <code>diesel_migrations</code> proc-macro will get the "postgres" feature enabled, and it will build correctly.</p>
<p>The 2.0 release of <code>diesel</code> (currently in development) does not have this problem as it has been restructured to not have this dependency requirement.</p>
<h3 id="exploring-features"><a class="header" href="#exploring-features">Exploring features</a></h3>
<p>The <a href="rust-2021/../../cargo/commands/cargo-tree.html"><code>cargo tree</code></a> command has had substantial improvements to help with the migration to the new resolver.
<code>cargo tree</code> can be used to explore the dependency graph, and to see which features are being enabled, and importantly <em>why</em> they are being enabled.</p>
<p>One option is to use the <code>--duplicates</code> flag (<code>-d</code> for short), which will tell you when a package is being built multiple times.
Taking the <code>bstr</code> example from earlier, we might see:</p>
<pre><code class="language-console">&gt; cargo tree -d
bstr v0.2.16
└── foo v0.1.0 (/MyProjects/foo)

bstr v0.2.16
[build-dependencies]
└── bar v0.1.0
    └── foo v0.1.0 (/MyProjects/foo)

</code></pre>
<p>This output tells us that <code>bstr</code> is built twice, and shows the chain of dependencies that led to its inclusion in both cases.</p>
<p>You can print which features each package is using with the <code>-f</code> flag, like this:</p>
<pre><code class="language-console">cargo tree -f '{p} {f}'
</code></pre>
<p>This tells Cargo to change the "format" of the output, where it will print both the package and the enabled features.</p>
<p>You can also use the <code>-e</code> flag to tell it which "edges" to display.
For example, <code>cargo tree -e features</code> will show in-between each dependency which features are being added by each dependency.
This option becomes more useful with the <code>-i</code> flag which can be used to "invert" the tree.
This allows you to see how features <em>flow</em> into a given dependency.
For example, let's say the dependency graph is large, and we're not quite sure who is depending on <code>bstr</code>, the following command will show that:</p>
<pre><code class="language-console">&gt; cargo tree -e features -i bstr
bstr v0.2.16
├── bstr feature "default"
│   [build-dependencies]
│   └── bar v0.1.0
│       └── bar feature "default"
│           └── foo v0.1.0 (/MyProjects/foo)
├── bstr feature "lazy_static"
│   └── bstr feature "unicode"
│       └── bstr feature "default" (*)
├── bstr feature "regex-automata"
│   └── bstr feature "unicode" (*)
├── bstr feature "std"
│   └── bstr feature "default" (*)
└── bstr feature "unicode" (*)
</code></pre>
<p>This snippet of output shows that the project <code>foo</code> depends on <code>bar</code> with the "default" feature.
Then, <code>bar</code> depends on <code>bstr</code> as a build-dependency with the "default" feature.
We can further see that <code>bstr</code>'s  "default" feature enables "unicode" (among other features).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intoiterator-for-arrays"><a class="header" href="#intoiterator-for-arrays">IntoIterator for arrays</a></h1>
<h2 id="summary-7"><a class="header" href="#summary-7">Summary</a></h2>
<ul>
<li>Arrays implement <code>IntoIterator</code> in <em>all</em> editions.</li>
<li>Calls to <code>IntoIterator::into_iter</code> are <em>hidden</em> in Rust 2015 and Rust 2018 when using method call syntax
(i.e., <code>array.into_iter()</code>). So, <code>array.into_iter()</code> still resolves to <code>(&amp;array).into_iter()</code> as it
has before.</li>
<li><code>array.into_iter()</code> changes meaning to be the call to <code>IntoIterator::into_iter</code> in Rust 2021.</li>
</ul>
<h2 id="details-4"><a class="header" href="#details-4">Details</a></h2>
<p>Until Rust 1.53, only <em>references</em> to arrays implement <code>IntoIterator</code>.
This means you can iterate over <code>&amp;[1, 2, 3]</code> and <code>&amp;mut [1, 2, 3]</code>,
but not over <code>[1, 2, 3]</code> directly.</p>
<pre><code class="language-rust ignore">for &amp;e in &amp;[1, 2, 3] {} // Ok :)

for e in [1, 2, 3] {} // Error :(</code></pre>
<p>This has been <a href="https://github.com/rust-lang/rust/issues/25725">a long-standing issue</a>, but the solution is not as simple as it seems.
Just <a href="https://github.com/rust-lang/rust/pull/65819">adding the trait implementation</a> would break existing code.
<code>array.into_iter()</code> already compiles today because that implicitly calls
<code>(&amp;array).into_iter()</code> due to <a href="https://doc.rust-lang.org/book/ch05-03-method-syntax.html#wheres-the---operator">how method call syntax works</a>.
Adding the trait implementation would change the meaning.</p>
<p>Usually this type of breakage (adding a trait implementation) is categorized as 'minor' and acceptable.
But in this case there is too much code that would be broken by it.</p>
<p>It has been suggested many times to "only implement <code>IntoIterator</code> for arrays in Rust 2021".
However, this is simply not possible.
You can't have a trait implementation exist in one edition and not in another,
since editions can be mixed.</p>
<p>Instead, the trait implementation was added in <em>all</em> editions (starting in Rust 1.53.0)
but with a small hack to avoid breakage until Rust 2021.
In Rust 2015 and 2018 code, the compiler will still resolve <code>array.into_iter()</code>
to <code>(&amp;array).into_iter()</code> like before, as if the trait implementation does not exist.
This <em>only</em> applies to the <code>.into_iter()</code> method call syntax.
It does not affect any other syntax such as <code>for e in [1, 2, 3]</code>, <code>iter.zip([1, 2, 3])</code> or
<code>IntoIterator::into_iter([1, 2, 3])</code>.
Those will start to work in <em>all</em> editions.</p>
<p>While it's a shame that this required a small hack to avoid breakage,
this solution keeps the difference between the editions to an absolute minimum.</p>
<h2 id="migration-2"><a class="header" href="#migration-2">Migration</a></h2>
<p>A lint, <code>array_into_iter</code>, gets triggered whenever there is some call to <code>into_iter()</code> that will change
meaning in Rust 2021. The <code>array_into_iter</code> lint has already been a warning by default on all editions
since the 1.41 release (with several enhancements made in 1.55). If your code is already warning free,
then it should already be ready to go for Rust 2021!</p>
<p>You can automatically migrate your code to be Rust 2021 Edition compatible or ensure it is already compatible by
running:</p>
<pre><code class="language-sh">cargo fix --edition
</code></pre>
<p>Because the difference between editions is small, the migration to Rust 2021 is fairly straight-forward.</p>
<p>For method calls of <code>into_iter</code> on arrays, the elements being implemented will change from references to owned values.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
  let array = [1u8, 2, 3];
  for x in array.into_iter() {
    // x is a `&amp;u8` in Rust 2015 and Rust 2018
    // x is a `u8` in Rust 2021
  }
}</code></pre></pre>
<p>The most straightforward way to migrate in Rust 2021, is by keeping the exact behavior from previous editions
by calling <code>iter()</code> which also iterates over owned arrays by reference:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
  let array = [1u8, 2, 3];
  for x in array.iter() { // &lt;- This line changed
    // x is a `&amp;u8` in all editions
  }
}</code></pre></pre>
<h3 id="optional-migration"><a class="header" href="#optional-migration">Optional migration</a></h3>
<p>If you are using fully qualified method syntax (i.e., <code>IntoIterator::into_iter(array)</code>) in a previous edition,
this can be upgraded to method call syntax (i.e., <code>array.into_iter()</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="disjoint-capture-in-closures"><a class="header" href="#disjoint-capture-in-closures">Disjoint capture in closures</a></h1>
<h2 id="summary-8"><a class="header" href="#summary-8">Summary</a></h2>
<ul>
<li><code>|| a.x + 1</code> now captures only <code>a.x</code> instead of <code>a</code>.</li>
<li>This can cause things to be dropped at different times or affect whether closures implement traits like <code>Send</code> or <code>Clone</code>.
<ul>
<li>If possible changes are detected, <code>cargo fix</code> will insert statements like <code>let _ = &amp;a</code> to force a closure to capture the entire variable.</li>
</ul>
</li>
</ul>
<h2 id="details-5"><a class="header" href="#details-5">Details</a></h2>
<p><a href="https://doc.rust-lang.org/book/ch13-01-closures.html">Closures</a>
automatically capture anything that you refer to from within their body.
For example, <code>|| a + 1</code> automatically captures a reference to <code>a</code> from the surrounding context.</p>
<p>In Rust 2018 and before, closures capture entire variables, even if the closure only uses one field.
For example, <code>|| a.x + 1</code> captures a reference to <code>a</code> and not just <code>a.x</code>.
Capturing <code>a</code> in its entirety prevents mutation or moves from other fields of <code>a</code>, so that code like this does not compile:</p>
<pre><code class="language-rust ignore">let a = SomeStruct::new();
drop(a.x); // Move out of one field of the struct
println!("{}", a.y); // Ok: Still use another field of the struct
let c = || println!("{}", a.y); // Error: Tries to capture all of `a`
c();</code></pre>
<p>Starting in Rust 2021, closures captures are more precise. Typically they will only capture the fields they use (in some cases, they might capture more than just what they use, see the Rust reference for full details). Therefore, the above example will compile fine in Rust 2021.</p>
<p>Disjoint capture was proposed as part of <a href="https://github.com/rust-lang/rfcs/blob/master/text/2229-capture-disjoint-fields.md">RFC 2229</a> and the RFC contains details about the motivation.</p>
<h2 id="migration-3"><a class="header" href="#migration-3">Migration</a></h2>
<p>As a part of the 2021 edition a migration lint, <code>rust_2021_incompatible_closure_captures</code>, has been added in order to aid in automatic migration of Rust 2018 codebases to Rust 2021.</p>
<p>In order to migrate your code to be Rust 2021 Edition compatible, run:</p>
<pre><code class="language-sh">cargo fix --edition
</code></pre>
<p>Below is an examination of how to manually migrate code to use closure captures that are compatible with Rust 2021 should the automatic migration fail
or you would like to better understand how the migration works.</p>
<p>Changing the variables captured by a closure can cause programs to change behavior or to stop compiling in two cases:</p>
<ul>
<li>changes to drop order, or when destructors run (<a href="rust-2021/disjoint-capture-in-closures.html#drop-order">details</a>);</li>
<li>changes to which traits a closure implements (<a href="rust-2021/disjoint-capture-in-closures.html#trait-implementations">details</a>).</li>
</ul>
<p>Whenever any of the scenarios below are detected, <code>cargo fix</code> will insert a "dummy let" into your closure to force it to capture the entire variable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = (vec![22], vec![23]);
let c = move || {
    // "Dummy let" that forces `x` to be captured in its entirety
    let _ = &amp;x;

    // Otherwise, only `x.0` would be captured here
    println!("{:?}", x.0);
};
<span class="boring">}</span></code></pre></pre>
<p>This is a conservative analysis: in many cases, these dummy lets can be safely removed and your program will work fine.</p>
<h3 id="wild-card-patterns"><a class="header" href="#wild-card-patterns">Wild Card Patterns</a></h3>
<p>Closures now only capture data that needs to be read, which means the following closures will not capture <code>x</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 10;
let c = || {
    let _ = x; // no-op
};

let c = || match x {
    _ =&gt; println!("Hello World!")
};
<span class="boring">}</span></code></pre></pre>
<p>The <code>let _ = x</code> statement here is a no-op, since the <code>_</code> pattern completely ignores the right-hand side, and <code>x</code> is a reference to a place in memory (in this case, a variable).</p>
<p>This change by itself (capturing fewer values) doesn't trigger any suggestions, but it may do so in conjunction with the "drop order" change below.</p>
<p><strong>Subtle:</strong> There are other similar expressions, such as the "dummy lets" <code>let _ = &amp;x</code> that we insert, which are not no-ops. This is because the right-hand side (<code>&amp;x</code>) is not a reference to a place in memory, but rather an expression that must first be evaluated (and whose result is then discarded).</p>
<h3 id="drop-order"><a class="header" href="#drop-order">Drop Order</a></h3>
<p>When a closure takes ownership of a value from a variable <code>t</code>, that value is then dropped when the closure is dropped, and not when the variable <code>t</code> goes out of scope:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn move_value&lt;T&gt;(_: T){}
</span>{
    let t = (vec![0], vec![0]);

    {
        let c = || move_value(t); // t is moved here
    } // c is dropped, which drops the tuple `t` as well
} // t goes out of scope here
<span class="boring">}</span></code></pre></pre>
<p>The above code will run the same in both Rust 2018 and Rust 2021. However, in cases where the closure only takes ownership of <em>part</em> of a variable, there can be differences:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn move_value&lt;T&gt;(_: T){}
</span>{
    let t = (vec![0], vec![0]);

    {
        let c = || {
            // In Rust 2018, captures all of `t`.
            // In Rust 2021, captures only `t.0`
            move_value(t.0);
        };

        // In Rust 2018, `c` (and `t`) are both dropped when we
        // exit this block.
        //
        // In Rust 2021, `c` and `t.0` are both dropped when we
        // exit this block.
    }

// In Rust 2018, the value from `t` has been moved and is
// not dropped.
//
// In Rust 2021, the value from `t.0` has been moved, but `t.1`
// remains, so it will be dropped here.
}
<span class="boring">}</span></code></pre></pre>
<p>In most cases, dropping values at different times just affects when memory is freed and is not important. However, some <code>Drop</code> impls (aka, destructors) have side-effects, and changing the drop order in those cases can alter the semantics of your program. In such cases, the compiler will suggest inserting a dummy <code>let</code> to force the entire variable to be captured.</p>
<h3 id="trait-implementations"><a class="header" href="#trait-implementations">Trait implementations</a></h3>
<p>Closures automatically implement the following traits based on what values they capture:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a>: if all captured values are <code>Clone</code>.</li>
<li><a href="https://doc.rust-lang.org/nightly/reference/special-types-and-traits.html#auto-traits">Auto traits</a> like <a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>, <a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>, and <a href="https://doc.rust-lang.org/std/panic/trait.UnwindSafe.html"><code>UnwindSafe</code></a>: if all captured values implement the given trait.</li>
</ul>
<p>In Rust 2021, since different values are being captured, this can affect what traits a closure will implement. The migration lints test each closure to see whether it would have implemented a given trait before and whether it still implements it now; if they find that a trait used to be implemented but no longer is, then "dummy lets" are inserted.</p>
<p>For instance, a common way to allow passing around raw pointers between threads is to wrap them in a struct and then implement <code>Send</code>/<code>Sync</code> auto trait for the wrapper. The closure that is passed to <code>thread::spawn</code> uses the specific fields within the wrapper but the entire wrapper is captured regardless. Since the wrapper is <code>Send</code>/<code>Sync</code>, the code is considered safe and therefore compiles successfully.</p>
<p>With disjoint captures, only the specific field mentioned in the closure gets captured, which wasn't originally <code>Send</code>/<code>Sync</code> defeating the purpose of the wrapper.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::thread;

struct Ptr(*mut i32);
unsafe impl Send for Ptr {}


let mut x = 5;
let px = Ptr(&amp;mut x as *mut i32);

let c = thread::spawn(move || {
    unsafe {
        *(px.0) += 10;
    }
}); // Closure captured px.0 which is not Send
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panic-macro-consistency"><a class="header" href="#panic-macro-consistency">Panic macro consistency</a></h1>
<h2 id="summary-9"><a class="header" href="#summary-9">Summary</a></h2>
<ul>
<li><code>panic!(..)</code> now always uses <code>format_args!(..)</code>, just like <code>println!()</code>.</li>
<li><code>panic!("{")</code> is no longer accepted, without escaping the <code>{</code> as <code>{{</code>.</li>
<li><code>panic!(x)</code> is no longer accepted if <code>x</code> is not a string literal.
<ul>
<li>Use <code>std::panic::panic_any(x)</code> to panic with a non-string payload.</li>
<li>Or use <code>panic!("{}", x)</code> to use <code>x</code>'s <code>Display</code> implementation.</li>
</ul>
</li>
<li>The same applies to <code>assert!(expr, ..)</code>.</li>
</ul>
<h2 id="details-6"><a class="header" href="#details-6">Details</a></h2>
<p>The <code>panic!()</code> macro is one of Rust's most well known macros.
However, it has <a href="https://github.com/rust-lang/rfcs/blob/master/text/3007-panic-plan.md">some subtle surprises</a>
that we can't just change due to backwards compatibility.</p>
<pre><code class="language-rust ignore">// Rust 2018
panic!("{}", 1); // Ok, panics with the message "1"
panic!("{}"); // Ok, panics with the message "{}"</code></pre>
<p>The <code>panic!()</code> macro only uses string formatting when it's invoked with more than one argument.
When invoked with a single argument, it doesn't even look at that argument.</p>
<pre><code class="language-rust ignore">// Rust 2018
let a = "{";
println!(a); // Error: First argument must be a format string literal
panic!(a); // Ok: The panic macro doesn't care</code></pre>
<p>It even accepts non-strings such as <code>panic!(123)</code>, which is uncommon and rarely useful since it
produces a surprisingly unhelpful message: <code>panicked at 'Box&lt;Any&gt;'</code>.</p>
<p>This will especially be a problem once
<a href="https://rust-lang.github.io/rfcs/2795-format-args-implicit-identifiers.html">implicit format arguments</a>
are stabilized.
That feature will make <code>println!("hello {name}")</code> a short-hand for <code>println!("hello {}", name)</code>.
However, <code>panic!("hello {name}")</code> would not work as expected,
since <code>panic!()</code> doesn't process a single argument as format string.</p>
<p>To avoid that confusing situation, Rust 2021 features a more consistent <code>panic!()</code> macro.
The new <code>panic!()</code> macro will no longer accept arbitrary expressions as the only argument.
It will, just like <code>println!()</code>, always process the first argument as format string.
Since <code>panic!()</code> will no longer accept arbitrary payloads,
<a href="https://doc.rust-lang.org/stable/std/panic/fn.panic_any.html"><code>panic_any()</code></a>
will be the only way to panic with something other than a formatted string.</p>
<pre><code class="language-rust ignore">// Rust 2021
panic!("{}", 1); // Ok, panics with the message "1"
panic!("{}"); // Error, missing argument
panic!(a); // Error, must be a string literal</code></pre>
<p>In addition, <code>core::panic!()</code> and <code>std::panic!()</code> will be identical in Rust 2021.
Currently, there are some historical differences between those two,
which can be noticeable when switching <code>#![no_std]</code> on or off.</p>
<h2 id="migration-4"><a class="header" href="#migration-4">Migration</a></h2>
<p>A lint, <code>non_fmt_panics</code>, gets triggered whenever there is some call to <code>panic</code> that uses some
deprecated behavior that will error in Rust 2021. The <code>non_fmt_panics</code> lint has already been a warning
by default on all editions since the 1.50 release (with several enhancements made in later releases).
If your code is already warning free, then it should already be ready to go for Rust 2021!</p>
<p>You can automatically migrate your code to be Rust 2021 Edition compatible or ensure it is already compatible by
running:</p>
<pre><code class="language-sh">cargo fix --edition
</code></pre>
<p>Should you choose or need to manually migrate, you'll need to update all panic invocations to either use the same
formatting as <code>println</code> or use <code>std::panic::panic_any</code> to panic with non-string data.</p>
<p>For example, in the case of <code>panic!(MyStruct)</code>, you'll need to convert to using <code>std::panic::panic_any</code> (note
that this is a function not a macro): <code>std::panic::panic_any(MyStruct)</code>.</p>
<p>In the case of panic messages that include curly braces but the wrong number of arguments (e.g., <code>panic!("Some curlies: {}")</code>),
you can panic with the string literal by either using the same syntax as <code>println!</code> (i.e., <code>panic!("{}", "Some curlies: {}")</code>)
or by escaping the curly braces (i.e., <code>panic!("Some curlies: {{}}")</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reserved-syntax"><a class="header" href="#reserved-syntax">Reserved syntax</a></h1>
<h2 id="summary-10"><a class="header" href="#summary-10">Summary</a></h2>
<ul>
<li><code>any_identifier#</code>, <code>any_identifier"..."</code>, <code>any_identifier'...'</code>, and <code>'any_identifier#</code> are now reserved syntax, and no longer tokenize.</li>
<li>This is mostly relevant to macros. E.g. <code>quote!{ #a#b }</code> is no longer accepted.</li>
<li>It doesn't treat keywords specially, so e.g. <code>match"..." {}</code> is no longer accepted.</li>
<li>Insert whitespace between the identifier and the subsequent <code>#</code>, <code>"</code>, or <code>'</code>
to avoid errors.</li>
<li>Edition migrations will help you insert whitespace in such cases.</li>
</ul>
<h2 id="details-7"><a class="header" href="#details-7">Details</a></h2>
<p>To make space for new syntax in the future,
we've decided to reserve syntax for prefixed identifiers, literals, and lifetimes:
<code>prefix#identifier</code>, <code>prefix"string"</code>, <code>prefix'c'</code>, <code>prefix#123</code>, and <code>'prefix#</code>,
where <code>prefix</code> can be any identifier.
(Except those prefixes that already have a meaning, such as <code>b'...'</code> (byte
chars) and <code>r"..."</code> (raw strings).)</p>
<p>This provides syntax we can expand into in the future without requiring an
edition boundary. We may use this for temporary syntax until the next edition,
or for permanent syntax if appropriate.</p>
<p>Without an edition, this would be a breaking change, since macros can currently
accept syntax such as <code>hello"world"</code>, which they will see as two separate
tokens: <code>hello</code> and <code>"world"</code>. The (automatic) fix is simple though: just
insert a space: <code>hello "world"</code>. Likewise, <code>prefix#ident</code> should become
<code>prefix #ident</code>. Edition migrations will help with this fix.</p>
<p>Other than turning these into a tokenization error,
<a href="https://github.com/rust-lang/rfcs/pull/3101">the RFC</a> does not attach a meaning to any prefix yet.
Assigning meaning to specific prefixes is left to future proposals,
which will now—thanks to reserving these prefixes—not be breaking changes.</p>
<p>Some new prefixes you might potentially see in the future (though we haven't
committed to any of them yet):</p>
<ul>
<li>
<p><code>k#keyword</code> to allow writing keywords that don't exist yet in the current edition.
For example, while <code>async</code> is not a keyword in edition 2015,
this prefix would've allowed us to accept <code>k#async</code> in edition 2015
without having to wait for edition 2018 to reserve <code>async</code> as a keyword.</p>
</li>
<li>
<p><code>f""</code> as a short-hand for a format string.
For example, <code>f"hello {name}"</code> as a short-hand for the equivalent <code>format!()</code> invocation.</p>
</li>
<li>
<p><code>s""</code> for <code>String</code> literals.</p>
</li>
</ul>
<h2 id="migration-5"><a class="header" href="#migration-5">Migration</a></h2>
<p>As a part of the 2021 edition a migration lint, <a href="rust-2021/../../rustc/lints/listing/allowed-by-default.html#rust-2021-prefixes-incompatible-syntax"><code>rust_2021_prefixes_incompatible_syntax</code></a>, has been added in order to aid in automatic migration of Rust 2018 codebases to Rust 2021.</p>
<p>In order to migrate your code to be Rust 2021 Edition compatible, run:</p>
<pre><code class="language-sh">cargo fix --edition
</code></pre>
<p>Should you want or need to manually migrate your code, migration is fairly straight-forward.</p>
<p>Let's say you have a macro that is defined like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! my_macro {
    ($a:tt $b:tt) =&gt; {};
}
<span class="boring">}</span></code></pre></pre>
<p>In Rust 2015 and 2018 it's legal for this macro to be called like so with no space between the first token tree and the second:</p>
<pre><code class="language-rust ignore">my_macro!(z"hey");</code></pre>
<p>This <code>z</code> prefix is no longer allowed in Rust 2021, so in order to call this macro, you must add a space after the prefix like so:</p>
<pre><code class="language-rust ignore">my_macro!(z "hey");</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="raw-lifetimes"><a class="header" href="#raw-lifetimes">Raw lifetimes</a></h1>
<h2 id="summary-11"><a class="header" href="#summary-11">Summary</a></h2>
<ul>
<li><code>'r#ident_or_keyword</code> is now allowed as a lifetime, which allows using keywords such as <code>'r#fn</code>.</li>
</ul>
<h2 id="details-8"><a class="header" href="#details-8">Details</a></h2>
<p>Raw lifetimes are introduced in the 2021 edition to support the ability to migrate to newer editions that introduce new keywords. This is analogous to <a href="rust-2021/../../reference/identifiers.html#raw-identifiers">raw identifiers</a> which provide the same functionality for identifiers. For example, the 2024 edition introduced the <code>gen</code> keyword. Since lifetimes cannot be keywords, this would cause code that use a lifetime <code>'gen</code> to fail to compile. Raw lifetimes allow the migration lint to modify those lifetimes to <code>'r#gen</code> which do allow keywords.</p>
<p>In editions prior to 2021, raw lifetimes are parsed as separate tokens. For example <code>'r#foo</code> is parsed as three tokens: <code>'r</code>, <code>#</code>, and <code>foo</code>.</p>
<h2 id="migration-6"><a class="header" href="#migration-6">Migration</a></h2>
<p>As a part of the 2021 edition a migration lint, <a href="rust-2021/../../rustc/lints/listing/allowed-by-default.html#rust-2021-prefixes-incompatible-syntax"><code>rust_2021_prefixes_incompatible_syntax</code></a>, has been added in order to aid in automatic migration of Rust 2018 codebases to Rust 2021.</p>
<p>In order to migrate your code to be Rust 2021 Edition compatible, run:</p>
<pre><code class="language-sh">cargo fix --edition
</code></pre>
<p>Should you want or need to manually migrate your code, migration is fairly straight-forward.</p>
<p>Let's say you have a macro that is defined like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! my_macro {
    ($a:tt $b:tt $c:tt) =&gt; {};
}
<span class="boring">}</span></code></pre></pre>
<p>In Rust 2015 and 2018 it's legal for this macro to be called like so with no space between the tokens:</p>
<pre><code class="language-rust ignore">my_macro!('r#foo);</code></pre>
<p>In the 2021 edition, this is now parsed as a single token. In order to call this macro, you must add a space before the identifier like so:</p>
<pre><code class="language-rust ignore">my_macro!('r# foo);</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="warnings-promoted-to-errors"><a class="header" href="#warnings-promoted-to-errors">Warnings promoted to errors</a></h1>
<h2 id="summary-12"><a class="header" href="#summary-12">Summary</a></h2>
<ul>
<li>Code that triggered the <code>bare_trait_objects</code> and <code>ellipsis_inclusive_range_patterns</code> lints will error in Rust 2021.</li>
</ul>
<h2 id="details-9"><a class="header" href="#details-9">Details</a></h2>
<p>Two existing lints are becoming hard errors in Rust 2021, but these lints will remain warnings in older editions.</p>
<h3 id="bare_trait_objects"><a class="header" href="#bare_trait_objects"><code>bare_trait_objects</code>:</a></h3>
<p>The use of the <code>dyn</code> keyword to identify <a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html">trait objects</a>
will be mandatory in Rust 2021.</p>
<p>For example, the following code which does not include the <code>dyn</code> keyword in <code>&amp;MyTrait</code>
will produce an error instead of just a lint in Rust 2021:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait MyTrait {}

pub fn my_function(_trait_object: &amp;MyTrait) { // should be `&amp;dyn MyTrait`
  unimplemented!()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="ellipsis_inclusive_range_patterns"><a class="header" href="#ellipsis_inclusive_range_patterns"><code>ellipsis_inclusive_range_patterns</code>:</a></h3>
<p>The <a href="https://doc.rust-lang.org/stable/reference/patterns.html#range-patterns">deprecated <code>...</code> syntax</a>
for inclusive range patterns (i.e., ranges where the end value is <em>included</em> in the range) is no longer
accepted in Rust 2021. It has been superseded by <code>..=</code>, which is consistent with expressions.</p>
<p>For example, the following code which uses <code>...</code> in a pattern will produce an error instead of
just a lint in Rust 2021:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn less_or_eq_to_100(n: u8) -&gt; bool {
  matches!(n, 0...100) // should be `0..=100`
}
<span class="boring">}</span></code></pre></pre>
<h2 id="migrations"><a class="header" href="#migrations">Migrations</a></h2>
<p>If your Rust 2015 or 2018 code does not produce any warnings for <code>bare_trait_objects</code>
or <code>ellipsis_inclusive_range_patterns</code> and you've not allowed these lints through the
use of <code>#![allow()]</code> or some other mechanism, then there's no need to migrate.</p>
<p>To automatically migrate any crate that uses <code>...</code> in patterns or does not use <code>dyn</code> with
trait objects, you can run <code>cargo fix --edition</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="or-patterns-in-macro-rules"><a class="header" href="#or-patterns-in-macro-rules">Or patterns in macro-rules</a></h1>
<h2 id="summary-13"><a class="header" href="#summary-13">Summary</a></h2>
<ul>
<li>How patterns work in <code>macro_rules</code> macros changes slightly:
<ul>
<li><code>$_:pat</code> in <code>macro_rules</code> now matches usage of <code>|</code> too: e.g. <code>A | B</code>.</li>
<li>The new <code>$_:pat_param</code> behaves like <code>$_:pat</code> did before; it does not match (top level) <code>|</code>.</li>
<li><code>$_:pat_param</code> is available in all editions.</li>
</ul>
</li>
</ul>
<h2 id="details-10"><a class="header" href="#details-10">Details</a></h2>
<p>Starting in Rust 1.53.0, <a href="https://doc.rust-lang.org/stable/reference/patterns.html">patterns</a>
are extended to support <code>|</code> nested anywhere in the pattern.
This enables you to write <code>Some(1 | 2)</code> instead of <code>Some(1) | Some(2)</code>.
Since this was simply not allowed before, this is not a breaking change.</p>
<p>However, this change also affects <a href="https://doc.rust-lang.org/stable/reference/macros-by-example.html"><code>macro_rules</code> macros</a>.
Such macros can accept patterns using the <code>:pat</code> fragment specifier.
Currently, <code>:pat</code> does <em>not</em> match top level <code>|</code>, since before Rust 1.53,
not all patterns (at all nested levels) could contain a <code>|</code>.
Macros that accept patterns like <code>A | B</code>,
such as <a href="https://doc.rust-lang.org/1.51.0/std/macro.matches.html"><code>matches!()</code></a>
use something like <code>$($_:pat)|+</code>.</p>
<p>Because this would potentially break existing macros, the meaning of <code>:pat</code> did
not change in Rust 1.53.0 to include <code>|</code>. Instead, that change happens in Rust 2021.
In the new edition, the <code>:pat</code> fragment specifier <em>will</em> match <code>A | B</code>.</p>
<p><code>$_:pat</code> fragments in Rust 2021 cannot be followed by an explicit <code>|</code>. Since there are times
that one still wishes to match pattern fragments followed by a <code>|</code>, the fragment specified <code>:pat_param</code>
has been added to retain the older behavior.</p>
<p>It's important to remember that editions are <em>per crate</em>, so the only relevant edition is the edition
of the crate where the macro is defined. The edition of the crate where the macro is used does not
change how the macro works.</p>
<h2 id="migration-7"><a class="header" href="#migration-7">Migration</a></h2>
<p>A lint, <code>rust_2021_incompatible_or_patterns</code>, gets triggered whenever there is a use <code>$_:pat</code> which
will change meaning in Rust 2021.</p>
<p>You can automatically migrate your code to be Rust 2021 Edition compatible or ensure it is already compatible by
running:</p>
<pre><code class="language-sh">cargo fix --edition
</code></pre>
<p>If you have a macro which relies on <code>$_:pat</code> not matching the top level use of <code>|</code> in patterns,
you'll need to change each occurrence of <code>$_:pat</code> to <code>$_:pat_param</code>.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! my_macro { 
	($x:pat | $y:pat) =&gt; {
		// TODO: implementation
	} 
}

// This macro works in Rust 2018 since `$x:pat` does not match against `|`:
my_macro!(1 | 2);

// In Rust 2021 however, the `$_:pat` fragment matches `|` and is not allowed
// to be followed by a `|`. To make sure this macro still works in Rust 2021
// change the macro to the following:
macro_rules! my_macro { 
	($x:pat_param | $y:pat) =&gt; { // &lt;- this line is different
		// TODO: implementation
	} 
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c-string-literals"><a class="header" href="#c-string-literals">C-string literals</a></h1>
<h2 id="summary-14"><a class="header" href="#summary-14">Summary</a></h2>
<ul>
<li>Literals of the form <code>c"foo"</code> or <code>cr"foo"</code> represent a string of type <a href="rust-2021/../../core/ffi/struct.CStr.html"><code>&amp;core::ffi::CStr</code></a>.</li>
</ul>
<h2 id="details-11"><a class="header" href="#details-11">Details</a></h2>
<p>Starting with Rust 1.77, C-strings can be written using C-string literal syntax with the <code>c</code> or <code>cr</code> prefix.</p>
<p>Previously, it was challenging to properly produce a valid string literal that could interoperate with C APIs which terminate with a NUL byte.
The <a href="https://crates.io/crates/cstr"><code>cstr</code></a> crate was a popular solution, but that required compiling a proc-macro which was quite expensive.
Now, C-strings can be written directly using literal syntax notation, which will generate a value of type <a href="rust-2021/../../core/ffi/struct.CStr.html"><code>&amp;core::ffi::CStr</code></a> which is automatically terminated with a NUL byte.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use core::ffi::CStr;
</span>
assert_eq!(c"hello", CStr::from_bytes_with_nul(b"hello\0").unwrap());
assert_eq!(
    c"byte escapes \xff work",
    CStr::from_bytes_with_nul(b"byte escapes \xff work\0").unwrap()
);
assert_eq!(
    c"unicode escapes \u{00E6} work",
    CStr::from_bytes_with_nul(b"unicode escapes \xc3\xa6 work\0").unwrap()
);
assert_eq!(
    c"unicode characters αβγ encoded as UTF-8",
    CStr::from_bytes_with_nul(
        b"unicode characters \xce\xb1\xce\xb2\xce\xb3 encoded as UTF-8\0"
    )
    .unwrap()
);
assert_eq!(
    c"strings can continue \
        on multiple lines",
    CStr::from_bytes_with_nul(b"strings can continue on multiple lines\0").unwrap()
);
<span class="boring">}</span></code></pre></pre>
<p>C-strings do not allow interior NUL bytes (such as with a <code>\0</code> escape).</p>
<p>Similar to regular strings, C-strings also support "raw" syntax with the <code>cr</code> prefix.
These raw C-strings do not process backslash escapes which can make it easier to write strings that contain backslashes.
Double-quotes can be included by surrounding the quotes with the <code>#</code> character.
Multiple <code>#</code> characters can be used to avoid ambiguity with internal <code>"#</code> sequences.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(cr"foo", c"foo");
// Number signs can be used to embed interior double quotes.
assert_eq!(cr#""foo""#, c"\"foo\"");
// This requires two #.
assert_eq!(cr##""foo"#"##, c"\"foo\"#");
// Escapes are not processed.
assert_eq!(cr"C:\foo", c"C:\\foo");
<span class="boring">}</span></code></pre></pre>
<p>See <a href="rust-2021/../../reference/tokens.html#c-string-and-raw-c-string-literals">The Reference</a> for more details.</p>
<h2 id="migration-8"><a class="header" href="#migration-8">Migration</a></h2>
<p>Migration is only necessary for macros which may have been assuming a sequence of tokens that looks similar to <code>c"…"</code> or <code>cr"…"</code>, which previous to the 2021 edition would tokenize as two separate tokens, but in 2021 appears as a single token.</p>
<p>As part of the <a href="rust-2021/reserved-syntax.html">syntax reservation</a> for the 2021 edition, any macro input which may run into this issue should issue a warning from the <code>rust_2021_prefixes_incompatible_syntax</code> migration lint.
See that chapter for more detail.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-2024"><a class="header" href="#rust-2024">Rust 2024</a></h1>
<div class="table-wrapper"><table><thead><tr><th>Info</th><th></th></tr></thead><tbody>
<tr><td>RFC</td><td><a href="https://rust-lang.github.io/rfcs/3501-edition-2024.html">#3501</a></td></tr>
<tr><td>Release version</td><td>1.85.0</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="language"><a class="header" href="#language">Language</a></h1>
<p>The following chapters detail changes to the language in the 2024 Edition.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rpit-lifetime-capture-rules"><a class="header" href="#rpit-lifetime-capture-rules">RPIT lifetime capture rules</a></h1>
<p>This chapter describes changes related to the <strong>Lifetime Capture Rules 2024</strong> introduced in <a href="https://github.com/rust-lang/rfcs/pull/3498">RFC 3498</a>, including how to use opaque type <em>precise capturing</em> (introduced in <a href="https://github.com/rust-lang/rfcs/pull/3617">RFC 3617</a>) to migrate your code.</p>
<h2 id="summary-15"><a class="header" href="#summary-15">Summary</a></h2>
<ul>
<li>In Rust 2024, <em>all</em> in-scope generic parameters, including lifetime parameters, are implicitly captured when the <code>use&lt;..&gt;</code> bound is not present.</li>
<li>Uses of the <code>Captures</code> trick (<code>Captures&lt;..&gt;</code> bounds) and of the outlives trick (e.g. <code>'_</code> bounds) can be replaced by <code>use&lt;..&gt;</code> bounds (in all editions) or removed entirely (in Rust 2024).</li>
</ul>
<h2 id="details-12"><a class="header" href="#details-12">Details</a></h2>
<h3 id="capturing"><a class="header" href="#capturing">Capturing</a></h3>
<p><em>Capturing</em> a generic parameter in an RPIT (return-position impl Trait) opaque type allows for that parameter to be used in the corresponding hidden type.  In Rust 1.82, we added <code>use&lt;..&gt;</code> bounds that allow specifying explicitly which generic parameters to capture.  Those will be helpful for migrating your code to Rust 2024, and will be helpful in this chapter for explaining how the edition-specific implicit capturing rules work.  These <code>use&lt;..&gt;</code> bounds look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn capture&lt;'a, T&gt;(x: &amp;'a (), y: T) -&gt; impl Sized + use&lt;'a, T&gt; {
    //                                ~~~~~~~~~~~~~~~~~~~~~~~
    //                             This is the RPIT opaque type.
    //
    //                                It captures `'a` and `T`.
    (x, y)
  //~~~~~~
  // The hidden type is: `(&amp;'a (), T)`.
  //
  // This type can use `'a` and `T` because they were captured.
}
<span class="boring">}</span></code></pre></pre>
<p>The generic parameters that are captured affect how the opaque type can be used.  E.g., this is an error because the lifetime is captured despite the fact that the hidden type does not use the lifetime:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn capture&lt;'a&gt;(_: &amp;'a ()) -&gt; impl Sized + use&lt;'a&gt; {}

fn test&lt;'a&gt;(x: &amp;'a ()) -&gt; impl Sized + 'static {
    capture(x)
    //~^ ERROR lifetime may not live long enough
}
<span class="boring">}</span></code></pre></pre>
<p>Conversely, this is OK:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn capture&lt;'a&gt;(_: &amp;'a ()) -&gt; impl Sized + use&lt;&gt; {}

fn test&lt;'a&gt;(x: &amp;'a ()) -&gt; impl Sized + 'static {
    capture(x) //~ OK
}
<span class="boring">}</span></code></pre></pre>
<h3 id="edition-specific-rules-when-no-use-bound-is-present"><a class="header" href="#edition-specific-rules-when-no-use-bound-is-present">Edition-specific rules when no <code>use&lt;..&gt;</code> bound is present</a></h3>
<p>If the <code>use&lt;..&gt;</code> bound is not present, then the compiler uses edition-specific rules to decide which in-scope generic parameters to capture implicitly.</p>
<p>In all editions, all in-scope type and const generic parameters are captured implicitly when the <code>use&lt;..&gt;</code> bound is not present.  E.g.:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f_implicit&lt;T, const C: usize&gt;() -&gt; impl Sized {}
//                                    ~~~~~~~~~~
//                         No `use&lt;..&gt;` bound is present here.
//
// In all editions, the above is equivalent to:
fn f_explicit&lt;T, const C: usize&gt;() -&gt; impl Sized + use&lt;T, C&gt; {}
<span class="boring">}</span></code></pre></pre>
<p>In Rust 2021 and earlier editions, when the <code>use&lt;..&gt;</code> bound is not present, generic lifetime parameters are only captured when they appear syntactically within a bound in RPIT opaque types in the signature of bare functions and associated functions and methods within inherent impls.  However, starting in Rust 2024, these in-scope generic lifetime parameters are unconditionally captured.  E.g.:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f_implicit(_: &amp;()) -&gt; impl Sized {}
// In Rust 2021 and earlier, the above is equivalent to:
fn f_2021(_: &amp;()) -&gt; impl Sized + use&lt;&gt; {}
// In Rust 2024 and later, it's equivalent to:
fn f_2024(_: &amp;()) -&gt; impl Sized + use&lt;'_&gt; {}
<span class="boring">}</span></code></pre></pre>
<p>This makes the behavior consistent with RPIT opaque types in the signature of associated functions and methods within trait impls, uses of RPIT within trait definitions (RPITIT), and opaque <code>Future</code> types created by <code>async fn</code>, all of which implicitly capture all in-scope generic lifetime parameters in all editions when the <code>use&lt;..&gt;</code> bound is not present.</p>
<h3 id="outer-generic-parameters"><a class="header" href="#outer-generic-parameters">Outer generic parameters</a></h3>
<p>Generic parameters from an outer impl are considered to be in scope when deciding what is implicitly captured.  E.g.:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S&lt;T, const C: usize&gt;((T, [(); C]));
impl&lt;T, const C: usize&gt; S&lt;T, C&gt; {
//   ~~~~~~~~~~~~~~~~~
// These generic parameters are in scope.
    fn f_implicit&lt;U&gt;() -&gt; impl Sized {}
    //            ~       ~~~~~~~~~~
    //            ^ This generic is in scope too.
    //                    ^
    //                    |
    //     No `use&lt;..&gt;` bound is present here.
    //
    // In all editions, it's equivalent to:
    fn f_explicit&lt;U&gt;() -&gt; impl Sized + use&lt;T, U, C&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<h3 id="lifetimes-from-higher-ranked-binders"><a class="header" href="#lifetimes-from-higher-ranked-binders">Lifetimes from higher-ranked binders</a></h3>
<p>Similarly, generic lifetime parameters introduced into scope by a higher-ranked <code>for&lt;..&gt;</code> binder are considered to be in scope.  E.g.:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Tr&lt;'a&gt; { type Ty; }
impl Tr&lt;'_&gt; for () { type Ty = (); }

fn f_implicit() -&gt; impl for&lt;'a&gt; Tr&lt;'a, Ty = impl Copy&gt; {}
// In Rust 2021 and earlier, the above is equivalent to:
fn f_2021() -&gt; impl for&lt;'a&gt; Tr&lt;'a, Ty = impl Copy + use&lt;&gt;&gt; {}
// In Rust 2024 and later, it's equivalent to:
//fn f_2024() -&gt; impl for&lt;'a&gt; Tr&lt;'a, Ty = impl Copy + use&lt;'a&gt;&gt; {}
//                                        ~~~~~~~~~~~~~~~~~~~~
// However, note that the capturing of higher-ranked lifetimes in
// nested opaque types is not yet supported.
<span class="boring">}</span></code></pre></pre>
<h3 id="argument-position-impl-trait-apit"><a class="header" href="#argument-position-impl-trait-apit">Argument position impl Trait (APIT)</a></h3>
<p>Anonymous (i.e. unnamed) generic parameters created by the use of APIT (argument position impl Trait) are considered to be in scope.  E.g.:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f_implicit(_: impl Sized) -&gt; impl Sized {}
//               ~~~~~~~~~~
//           This is called APIT.
//
// The above is *roughly* equivalent to:
fn f_explicit&lt;_0: Sized&gt;(_: _0) -&gt; impl Sized + use&lt;_0&gt; {}
<span class="boring">}</span></code></pre></pre>
<p>Note that the former is not <em>exactly</em> equivalent to the latter because, by naming the generic parameter, turbofish syntax can now be used to provide an argument for it.  There is no way to explicitly include an anonymous generic parameter in a <code>use&lt;..&gt;</code> bound other than by converting it to a named generic parameter.</p>
<h2 id="migration-9"><a class="header" href="#migration-9">Migration</a></h2>
<h3 id="migrating-while-avoiding-overcapturing"><a class="header" href="#migrating-while-avoiding-overcapturing">Migrating while avoiding overcapturing</a></h3>
<p>The <code>impl_trait_overcaptures</code> lint flags RPIT opaque types that will capture additional lifetimes in Rust 2024.  This lint is part of the <code>rust-2024-compatibility</code> lint group which is automatically applied when running <code>cargo fix --edition</code>.  In most cases, the lint can automatically insert <code>use&lt;..&gt;</code> bounds where needed such that no additional lifetimes are captured in Rust 2024.</p>
<p>To migrate your code to be compatible with Rust 2024, run:</p>
<pre><code class="language-sh">cargo fix --edition
</code></pre>
<p>For example, this will change:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;'a&gt;(x: &amp;'a ()) -&gt; impl Sized { *x }
<span class="boring">}</span></code></pre></pre>
<p>...into:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;'a&gt;(x: &amp;'a ()) -&gt; impl Sized + use&lt;&gt; { *x }
<span class="boring">}</span></code></pre></pre>
<p>Without this <code>use&lt;&gt;</code> bound, in Rust 2024, the opaque type would capture the <code>'a</code> lifetime parameter.  By adding this bound, the migration lint preserves the existing semantics.</p>
<h3 id="migrating-cases-involving-apit"><a class="header" href="#migrating-cases-involving-apit">Migrating cases involving APIT</a></h3>
<p>In some cases, the lint cannot make the change automatically because a generic parameter needs to be given a name so that it can appear within a <code>use&lt;..&gt;</code> bound.  In these cases, the lint will alert you that a change may need to be made manually.  E.g., given:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;'a&gt;(x: &amp;'a (), y: impl Sized) -&gt; impl Sized { (*x, y) }
//   ^^                ~~~~~~~~~~
//               This is a use of APIT.
//
//~^ WARN `impl Sized` will capture more lifetimes than possibly intended in edition 2024
//~| NOTE specifically, this lifetime is in scope but not mentioned in the type's bounds
<span class="boring">
</span><span class="boring">fn test&lt;'a&gt;(x: &amp;'a (), y: ()) -&gt; impl Sized + 'static {
</span><span class="boring">    f(x, y)
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>The code cannot be converted automatically because of the use of APIT and the fact that the generic type parameter must be named in the <code>use&lt;..&gt;</code> bound.  To convert this code to Rust 2024 without capturing the lifetime, you must name that type parameter.  E.g.:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![deny(impl_trait_overcaptures)]
</span>fn f&lt;'a, T: Sized&gt;(x: &amp;'a (), y: T) -&gt; impl Sized + use&lt;T&gt; { (*x, y) }
//       ~~~~~~~~
// The type parameter has been named here.
<span class="boring">
</span><span class="boring">fn test&lt;'a&gt;(x: &amp;'a (), y: ()) -&gt; impl Sized + use&lt;&gt; {
</span><span class="boring">    f(x, y)
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Note that this changes the API of the function slightly as a type argument can now be explicitly provided for this parameter using turbofish syntax.  If this is undesired, you might consider instead whether you can simply continue to omit the <code>use&lt;..&gt;</code> bound and allow the lifetime to be captured.  This might be particularly desirable if you might in the future want to use that lifetime in the hidden type and would like to save space for that.</p>
<h3 id="migrating-away-from-the-captures-trick"><a class="header" href="#migrating-away-from-the-captures-trick">Migrating away from the <code>Captures</code> trick</a></h3>
<p>Prior to the introduction of precise capturing <code>use&lt;..&gt;</code> bounds in Rust 1.82, correctly capturing a lifetime in an RPIT opaque type often required using the <code>Captures</code> trick.  E.g.:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[doc(hidden)]
pub trait Captures&lt;T: ?Sized&gt; {}
impl&lt;T: ?Sized, U: ?Sized&gt; Captures&lt;T&gt; for U {}

fn f&lt;'a, T&gt;(x: &amp;'a (), y: T) -&gt; impl Sized + Captures&lt;(&amp;'a (), T)&gt; {
//                                           ~~~~~~~~~~~~~~~~~~~~~
//                            This is called the `Captures` trick.
    (x, y)
}
<span class="boring">
</span><span class="boring">fn test&lt;'t, 'x&gt;(t: &amp;'t (), x: &amp;'x ()) {
</span><span class="boring">    f(t, x);
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>With the <code>use&lt;..&gt;</code> bound syntax, the <code>Captures</code> trick is no longer needed and can be replaced with the following in all editions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;'a, T&gt;(x: &amp;'a (), y: T) -&gt; impl Sized + use&lt;'a, T&gt; {
    (x, y)
}
<span class="boring">
</span><span class="boring">fn test&lt;'t, 'x&gt;(t: &amp;'t (), x: &amp;'x ()) {
</span><span class="boring">    f(t, x);
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>In Rust 2024, the <code>use&lt;..&gt;</code> bound can often be omitted entirely, and the above can be written simply as:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;'a, T&gt;(x: &amp;'a (), y: T) -&gt; impl Sized {
    (x, y)
}
<span class="boring">
</span><span class="boring">fn test&lt;'t, 'x&gt;(t: &amp;'t (), x: &amp;'x ()) {
</span><span class="boring">    f(t, x);
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>There is no automatic migration for this, and the <code>Captures</code> trick still works in Rust 2024, but you might want to consider migrating code manually away from using this old trick.</p>
<h3 id="migrating-away-from-the-outlives-trick"><a class="header" href="#migrating-away-from-the-outlives-trick">Migrating away from the outlives trick</a></h3>
<p>Prior to the introduction of precise capturing <code>use&lt;..&gt;</code> bounds in Rust 1.82, it was common to use the "outlives trick" when a lifetime needed to be used in the hidden type of some opaque.  E.g.:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;'a, T: 'a&gt;(x: &amp;'a (), y: T) -&gt; impl Sized + 'a {
    //    ~~~~                                 ~~~~
    //    ^                     This is the outlives trick.
    //    |
    // This bound is needed only for the trick.
    (x, y)
//  ~~~~~~
// The hidden type is `(&amp;'a (), T)`.
}
<span class="boring">}</span></code></pre></pre>
<p>This trick was less baroque than the <code>Captures</code> trick, but also less correct.  As we can see in the example above, even though any lifetime components within <code>T</code> are independent from the lifetime <code>'a</code>, we're required to add a <code>T: 'a</code> bound in order to make the trick work.  This created undue and surprising restrictions on callers.</p>
<p>Using precise capturing, you can write the above instead, in all editions, as:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;T&gt;(x: &amp;(), y: T) -&gt; impl Sized + use&lt;'_, T&gt; {
    (x, y)
}
<span class="boring">
</span><span class="boring">fn test&lt;'t, 'x&gt;(t: &amp;'t (), x: &amp;'x ()) {
</span><span class="boring">   f(t, x);
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>In Rust 2024, the <code>use&lt;..&gt;</code> bound can often be omitted entirely, and the above can be written simply as:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;T&gt;(x: &amp;(), y: T) -&gt; impl Sized {
    (x, y)
}
<span class="boring">
</span><span class="boring">fn test&lt;'t, 'x&gt;(t: &amp;'t (), x: &amp;'x ()) {
</span><span class="boring">   f(t, x);
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>There is no automatic migration for this, and the outlives trick still works in Rust 2024, but you might want to consider migrating code manually away from using this old trick.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="if-let-temporary-scope"><a class="header" href="#if-let-temporary-scope"><code>if let</code> temporary scope</a></h1>
<h2 id="summary-16"><a class="header" href="#summary-16">Summary</a></h2>
<ul>
<li>In an <code>if let $pat = $expr { .. } else { .. }</code> expression, the temporary values generated from evaluating <code>$expr</code> will be dropped before the program enters the <code>else</code> branch instead of after.</li>
</ul>
<h2 id="details-13"><a class="header" href="#details-13">Details</a></h2>
<p>The 2024 Edition changes the drop scope of <a href="rust-2024/../../reference/expressions.html#temporaries">temporary values</a> in the scrutinee<sup class="footnote-reference"><a href="#scrutinee">1</a></sup> of an <code>if let</code> expression. This is intended to help reduce the potentially unexpected behavior involved with the temporary living for too long.</p>
<p>Before 2024, the temporaries could be extended beyond the <code>if let</code> expression itself. For example:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Before 2024
<span class="boring">use std::sync::RwLock;
</span>
fn f(value: &amp;RwLock&lt;Option&lt;bool&gt;&gt;) {
    if let Some(x) = *value.read().unwrap() {
        println!("value is {x}");
    } else {
        let mut v = value.write().unwrap();
        if v.is_none() {
            *v = Some(true);
        }
    }
    // &lt;--- Read lock is dropped here in 2021
}
<span class="boring">}</span></code></pre></pre>
<p>In this example, the temporary read lock generated by the call to <code>value.read()</code> will not be dropped until after the <code>if let</code> expression (that is, after the <code>else</code> block). In the case where the <code>else</code> block is executed, this causes a deadlock when it attempts to acquire a write lock.</p>
<p>The 2024 Edition shortens the lifetime of the temporaries to the point where the then-block is completely evaluated or the program control enters the <code>else</code> block.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Starting with 2024
<span class="boring">use std::sync::RwLock;
</span>
fn f(value: &amp;RwLock&lt;Option&lt;bool&gt;&gt;) {
    if let Some(x) = *value.read().unwrap() {
        println!("value is {x}");
    }
    // &lt;--- Read lock is dropped here in 2024
    else {
        let mut v = value.write().unwrap();
        if v.is_none() {
            *v = Some(true);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>See the <a href="rust-2024/../../reference/destructors.html#temporary-scopes">temporary scope rules</a> for more information about how temporary scopes are extended. See the <a href="rust-2024/temporary-tail-expr-scope.html">tail expression temporary scope</a> chapter for a similar change made to tail expressions.</p>
<div class="footnote-definition" id="scrutinee"><sup class="footnote-definition-label">1</sup>
<p>The <a href="rust-2024/../../reference/glossary.html#scrutinee">scrutinee</a> is the expression being matched on in the <code>if let</code> expression.</p>
</div>
<h2 id="migration-10"><a class="header" href="#migration-10">Migration</a></h2>
<p>It is always safe to rewrite <code>if let</code> with a <code>match</code>. The temporaries of the <code>match</code> scrutinee are extended past the end of the <code>match</code> expression (typically to the end of the statement), which is the same as the 2021 behavior of <code>if let</code>.</p>
<p>The <a href="rust-2024/../../rustc/lints/listing/allowed-by-default.html#if-let-rescope"><code>if_let_rescope</code></a> lint suggests a fix when a lifetime issue arises due to this change or the lint detects that a temporary value with a custom, non-trivial <code>Drop</code> destructor is generated from the scrutinee of the <code>if let</code>. For instance, the earlier example may be rewritten into the following when the suggestion from <code>cargo fix</code> is accepted:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::sync::RwLock;
</span>fn f(value: &amp;RwLock&lt;Option&lt;bool&gt;&gt;) {
    match *value.read().unwrap() {
        Some(x) =&gt; {
            println!("value is {x}");
        }
        _ =&gt; {
            let mut s = value.write().unwrap();
            if s.is_none() {
                *s = Some(true);
            }
        }
    }
    // &lt;--- Read lock is dropped here in both 2021 and 2024
}
<span class="boring">}</span></code></pre></pre>
<p>In this particular example, that's probably not what you want due to the aforementioned deadlock! However, some scenarios may be assuming that the temporaries are held past the <code>else</code> clause, in which case you may want to retain the old behavior.</p>
<p>The <a href="rust-2024/../../rustc/lints/listing/allowed-by-default.html#if-let-rescope"><code>if_let_rescope</code></a> lint is part of the <code>rust-2024-compatibility</code> lint group which is included in the automatic edition migration. In order to migrate your code to be Rust 2024 Edition compatible, run:</p>
<pre><code class="language-sh">cargo fix --edition
</code></pre>
<p>After the migration, it is recommended that you review all of the changes of <code>if let</code> to <code>match</code> and decide what is the behavior that you need with respect to when temporaries are dropped. If you determine that the change is unnecessary, then you can revert the change back to <code>if let</code>.</p>
<p>If you want to manually inspect these warnings without performing the edition migration, you can enable the lint with:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add this to the root of your crate to do a manual migration.
#![warn(if_let_rescope)]
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tail-expression-temporary-scope"><a class="header" href="#tail-expression-temporary-scope">Tail expression temporary scope</a></h1>
<h2 id="summary-17"><a class="header" href="#summary-17">Summary</a></h2>
<ul>
<li>Temporary values generated in evaluation of the tail expression of a <a href="rust-2024/../../reference/items/functions.html">function</a> or closure body, or a <a href="rust-2024/../../reference/expressions/block-expr.html">block</a> may now be dropped before local variables, and are sometimes not extended to the next larger temporary scope.</li>
</ul>
<h2 id="details-14"><a class="header" href="#details-14">Details</a></h2>
<p>The 2024 Edition changes the drop order of <a href="rust-2024/../../reference/expressions.html#temporaries">temporary values</a> in tail expressions. It often comes as a surprise that, before the 2024 Edition, temporary values in tail expressions can live longer than the block itself, and are dropped later than the local variable bindings, as in the following example:</p>
<pre><pre class="playground"><code class="language-rust edition2021 compile_fail E0597"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Before 2024
<span class="boring">use std::cell::RefCell;
</span>fn f() -&gt; usize {
    let c = RefCell::new("..");
    c.borrow().len() // error[E0597]: `c` does not live long enough
}
<span class="boring">}</span></code></pre></pre>
<p>This yields the following error with the 2021 Edition:</p>
<pre><code class="language-text">error[E0597]: `c` does not live long enough
 --&gt; src/lib.rs:4:5
  |
3 |     let c = RefCell::new("..");
  |         - binding `c` declared here
4 |     c.borrow().len() // error[E0597]: `c` does not live long enough
  |     ^---------
  |     |
  |     borrowed value does not live long enough
  |     a temporary with access to the borrow is created here ...
5 | }
  | -
  | |
  | `c` dropped here while still borrowed
  | ... and the borrow might be used here, when that temporary is dropped and runs the destructor for type `Ref&lt;'_, &amp;str&gt;`
  |
  = note: the temporary is part of an expression at the end of a block;
          consider forcing this temporary to be dropped sooner, before the block's local variables are dropped
help: for example, you could save the expression's value in a new local variable `x` and then make `x` be the expression at the end of the block
  |
4 |     let x = c.borrow().len(); x // error[E0597]: `c` does not live long enough
  |     +++++++                 +++

For more information about this error, try `rustc --explain E0597`.
</code></pre>
<p>In 2021 the local variable <code>c</code> is dropped before the temporary created by <code>c.borrow()</code>. The 2024 Edition changes this so that the temporary value <code>c.borrow()</code> is dropped first, followed by dropping the local variable <code>c</code>, allowing the code to compile as expected.</p>
<h3 id="temporary-scope-may-be-narrowed"><a class="header" href="#temporary-scope-may-be-narrowed">Temporary scope may be narrowed</a></h3>
<p>When a temporary is created in order to evaluate an expression, the temporary is dropped based on the <a href="rust-2024/../../reference/destructors.html#temporary-scopes">temporary scope rules</a>. Those rules define how long the temporary will be kept alive. Before 2024, temporaries from tail expressions of a block would be extended outside of the block to the next temporary scope boundary. In many cases this would be the end of a statement or function body. In 2024, the temporaries of the tail expression may now be dropped immediately at the end of the block (before any local variables in the block).</p>
<p>This narrowing of the temporary scope may cause programs to fail to compile in 2024. For example:</p>
<pre><pre class="playground"><code class="language-rust edition2024 E0716 compile_fail">// This example works in 2021, but fails to compile in 2024.
fn main() {
    let x = { &amp;String::from("1234") }.len();
}</code></pre></pre>
<p>In this example, in 2021, the temporary <code>String</code> is extended outside of the block, past the call to <code>len()</code>, and is dropped at the end of the statement. In 2024, it is dropped immediately at the end of the block, causing a compile error about the temporary being dropped while borrowed.</p>
<p>The solution for these kinds of situations is to lift the block expression out to a local variable so that the temporary lives long enough:</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let s = { &amp;String::from("1234") };
    let x = s.len();
}</code></pre></pre>
<p>This particular example takes advantage of <a href="rust-2024/../../reference/destructors.html#temporary-lifetime-extension">temporary lifetime extension</a>. Temporary lifetime extension is a set of specific rules which allow temporaries to live longer than they normally would. Because the <code>String</code> temporary is behind a reference, the <code>String</code> temporary is extended long enough for the next statement to call <code>len()</code> on it.</p>
<p>See the <a href="rust-2024/temporary-if-let-scope.html"><code>if let</code> temporary scope</a> chapter for a similar change made to temporary scopes of <code>if let</code> expressions.</p>
<h2 id="migration-11"><a class="header" href="#migration-11">Migration</a></h2>
<p>Unfortunately, there are no semantics-preserving rewrites to shorten the lifetime for temporary values in tail expressions<sup class="footnote-reference"><a href="#RFC3606">1</a></sup>. The <a href="rust-2024/../../rustc/lints/listing/allowed-by-default.html#tail-expr-drop-order"><code>tail_expr_drop_order</code></a> lint detects if a temporary value with a custom, non-trivial <code>Drop</code> destructor is generated in a tail expression. Warnings from this lint will appear when running <code>cargo fix --edition</code>, but will otherwise not automatically make any changes. It is recommended to manually inspect the warnings and determine whether or not you need to make any adjustments.</p>
<p>If you want to manually inspect these warnings without performing the edition migration, you can enable the lint with:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add this to the root of your crate to do a manual migration.
#![warn(tail_expr_drop_order)]
<span class="boring">}</span></code></pre></pre>
<div class="footnote-definition" id="RFC3606"><sup class="footnote-definition-label">1</sup>
<p>Details are documented at <a href="https://github.com/rust-lang/rfcs/pull/3606">RFC 3606</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="match-ergonomics-reservations"><a class="header" href="#match-ergonomics-reservations">Match ergonomics reservations</a></h1>
<h2 id="summary-18"><a class="header" href="#summary-18">Summary</a></h2>
<ul>
<li>Writing <code>mut</code>, <code>ref</code>, or <code>ref mut</code> on a binding is only allowed within a pattern when the pattern leading up to that binding is fully explicit (i.e. when it does not use match ergonomics).
<ul>
<li>Put differently, when the default binding mode is not <code>move</code>, writing <code>mut</code>, <code>ref</code>, or <code>ref mut</code> on a binding is an error.</li>
</ul>
</li>
<li>Reference patterns (<code>&amp;</code> or <code>&amp;mut</code>) are only allowed within the fully-explicit prefix of a pattern.
<ul>
<li>Put differently, reference patterns can only match against references in the scrutinee when the default binding mode is <code>move</code>.</li>
</ul>
</li>
</ul>
<h2 id="details-15"><a class="header" href="#details-15">Details</a></h2>
<h3 id="background"><a class="header" href="#background">Background</a></h3>
<p>Within <code>match</code>, <code>let</code>, and other constructs, we match a <em>pattern</em> against a <em>scrutinee</em>.  E.g.:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let &amp;[&amp;mut [ref x]] = &amp;[&amp;mut [()]]; // x: &amp;()
//  ~~~~~~~~~~~~~~~   ~~~~~~~~~~~~
//      Pattern        Scrutinee
<span class="boring">}</span></code></pre></pre>
<p>Such a pattern is called fully explicit because it does not elide (i.e. "skip" or "pass") any references within the scrutinee.  By contrast, this otherwise-equivalent pattern is not fully explicit:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let [[x]] = &amp;[&amp;mut [()]]; // x: &amp;()
<span class="boring">}</span></code></pre></pre>
<p>Patterns such as this are said to be using match ergonomics, originally introduced in <a href="https://github.com/rust-lang/rfcs/pull/2005">RFC 2005</a>.</p>
<p>Under match ergonomics, as we incrementally match a pattern against a scrutinee, we keep track of the default binding mode.  This mode can be one of <code>move</code>, <code>ref mut</code>, or <code>ref</code>, and it starts as <code>move</code>.  When we reach a binding, unless an explicit binding mode is provided, the default binding mode is used to decide the binding's type.</p>
<p>For example, here we provide an explicit binding mode, causing <code>x</code> to be bound by reference:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ref x = (); // &amp;()
<span class="boring">}</span></code></pre></pre>
<p>By contrast:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let [x] = &amp;[()]; // &amp;()
<span class="boring">}</span></code></pre></pre>
<p>Here, in the pattern, we pass the outer shared reference in the scrutinee.  This causes the default binding mode to switch from <code>move</code> to <code>ref</code>.  Since there is no explicit binding mode specified, the <code>ref</code> binding mode is used when binding <code>x</code>.</p>
<h3 id="mut-restriction"><a class="header" href="#mut-restriction"><code>mut</code> restriction</a></h3>
<p>In Rust 2021 and earlier editions, we allow this oddity:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let [x, mut y] = &amp;[(), ()]; // x: &amp;(), mut y: ()
<span class="boring">}</span></code></pre></pre>
<p>Here, because we pass the shared reference in the pattern, the default binding mode switches to <code>ref</code>.  But then, in these editions, writing <code>mut</code> on the binding resets the default binding mode to <code>move</code>.</p>
<p>This can be surprising as it's not intuitive that mutability should affect the type.</p>
<p>To leave space to fix this, in Rust 2024 it's an error to write <code>mut</code> on a binding when the default binding mode is not <code>move</code>.  That is, <code>mut</code> can only be written on a binding when the pattern (leading up to that binding) is fully explicit.</p>
<p>In Rust 2024, we can write the above example as:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let &amp;[ref x, mut y] = &amp;[(), ()]; // x: &amp;(), mut y: ()
<span class="boring">}</span></code></pre></pre>
<h3 id="ref--ref-mut-restriction"><a class="header" href="#ref--ref-mut-restriction"><code>ref</code> / <code>ref mut</code> restriction</a></h3>
<p>In Rust 2021 and earlier editions, we allow:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let [ref x] = &amp;[()]; // x: &amp;()
<span class="boring">}</span></code></pre></pre>
<p>Here, the <code>ref</code> explicit binding mode is redundant, as by passing the shared reference (i.e. not mentioning it in the pattern), the binding mode switches to <code>ref</code>.</p>
<p>To leave space for other language possibilities, we are disallowing explicit binding modes where they are redundant in Rust 2024.  We can rewrite the above example as simply:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let [x] = &amp;[()]; // x: &amp;()
<span class="boring">}</span></code></pre></pre>
<h3 id="reference-patterns-restriction"><a class="header" href="#reference-patterns-restriction">Reference patterns restriction</a></h3>
<p>In Rust 2021 and earlier editions, we allow this oddity:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let [&amp;x, y] = &amp;[&amp;(), &amp;()]; // x: (), y: &amp;&amp;()
<span class="boring">}</span></code></pre></pre>
<p>Here, the <code>&amp;</code> in the pattern both matches against the reference on <code>&amp;()</code> and resets the default binding mode to <code>move</code>.  This can be surprising because the single <code>&amp;</code> in the pattern causes a larger than expected change in the type by removing both layers of references.</p>
<p>To leave space to fix this, in Rust 2024 it's an error to write <code>&amp;</code> or <code>&amp;mut</code> in the pattern when the default binding mode is not <code>move</code>.  That is, <code>&amp;</code> or <code>&amp;mut</code> can only be written when the pattern (leading up to that point) is fully explicit.</p>
<p>In Rust 2024, we can write the above example as:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let &amp;[&amp;x, ref y] = &amp;[&amp;(), &amp;()];
<span class="boring">}</span></code></pre></pre>
<h2 id="migration-12"><a class="header" href="#migration-12">Migration</a></h2>
<p>The <a href="rust-2024/../../rustc/lints/listing/allowed-by-default.html#rust-2024-incompatible-pat"><code>rust_2024_incompatible_pat</code></a> lint flags patterns that are not allowed in Rust 2024.  This lint is part of the <code>rust-2024-compatibility</code> lint group which is automatically applied when running <code>cargo fix --edition</code>.  This lint will automatically convert affected patterns to fully explicit patterns that work correctly in Rust 2024 and in all prior editions.</p>
<p>To migrate your code to be compatible with Rust 2024, run:</p>
<pre><code class="language-sh">cargo fix --edition
</code></pre>
<p>For example, this will convert this...</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let [x, mut y] = &amp;[(), ()];
let [ref x] = &amp;[()];
let [&amp;x, y] = &amp;[&amp;(), &amp;()];
<span class="boring">}</span></code></pre></pre>
<p>...into this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let &amp;[ref x, mut y] = &amp;[(), ()];
let &amp;[ref x] = &amp;[()];
let &amp;[&amp;x, ref y] = &amp;[&amp;(), &amp;()];
<span class="boring">}</span></code></pre></pre>
<p>Alternatively, you can manually enable the lint to find patterns that will need to be migrated:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add this to the root of your crate to do a manual migration.
#![warn(rust_2024_incompatible_pat)]
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unsafe-extern-blocks"><a class="header" href="#unsafe-extern-blocks">Unsafe <code>extern</code> blocks</a></h1>
<h2 id="summary-19"><a class="header" href="#summary-19">Summary</a></h2>
<ul>
<li><a href="rust-2024/../../reference/items/external-blocks.html"><code>extern</code> blocks</a> must now be marked with the <code>unsafe</code> keyword.</li>
</ul>
<h2 id="details-16"><a class="header" href="#details-16">Details</a></h2>
<p>Rust 1.82 added the ability in all editions to mark <a href="rust-2024/../../reference/items/external-blocks.html"><code>extern</code> blocks</a> with the <code>unsafe</code> keyword.<sup class="footnote-reference"><a href="#RFC3484">1</a></sup> Adding the <code>unsafe</code> keyword helps to emphasize that it is the responsibility of the author of the <code>extern</code> block to ensure that the signatures are correct. If the signatures are not correct, then it may result in undefined behavior.</p>
<p>The syntax for an unsafe <code>extern</code> block looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe extern "C" {
    // sqrt (from libm) may be called with any `f64`
    pub safe fn sqrt(x: f64) -&gt; f64;

    // strlen (from libc) requires a valid pointer,
    // so we mark it as being an unsafe fn
    pub unsafe fn strlen(p: *const std::ffi::c_char) -&gt; usize;

    // this function doesn't say safe or unsafe, so it defaults to unsafe
    pub fn free(p: *mut core::ffi::c_void);

    pub safe static IMPORTANT_BYTES: [u8; 256];
}
<span class="boring">}</span></code></pre></pre>
<p>In addition to being able to mark an <code>extern</code> block as <code>unsafe</code>, you can also specify if individual items in the <code>extern</code> block are <code>safe</code> or <code>unsafe</code>. Items marked as <code>safe</code> can be used without an <code>unsafe</code> block.</p>
<p>Starting with the 2024 Edition, it is now required to include the <code>unsafe</code> keyword on an <code>extern</code> block. This is intended to make it very clear that there are safety requirements that must be upheld by the extern definitions.</p>
<div class="footnote-definition" id="RFC3484"><sup class="footnote-definition-label">1</sup>
<p>See <a href="https://github.com/rust-lang/rfcs/blob/master/text/3484-unsafe-extern-blocks.md">RFC 3484</a> for the original proposal.</p>
</div>
<h2 id="migration-13"><a class="header" href="#migration-13">Migration</a></h2>
<p>The <a href="rust-2024/../../rustc/lints/listing/allowed-by-default.html#missing-unsafe-on-extern"><code>missing_unsafe_on_extern</code></a> lint can update <code>extern</code> blocks to add the <code>unsafe</code> keyword. The lint is part of the <code>rust-2024-compatibility</code> lint group which is included in the automatic edition migration. In order to migrate your code to be Rust 2024 Edition compatible, run:</p>
<pre><code class="language-sh">cargo fix --edition
</code></pre>
<p>Just beware that this automatic migration will not be able to verify that the signatures in the <code>extern</code> block are correct. It is still your responsibility to manually review their definition.</p>
<p>Alternatively, you can manually enable the lint to find places where there are <code>unsafe</code> blocks that need to be updated.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add this to the root of your crate to do a manual migration.
#![warn(missing_unsafe_on_extern)]
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unsafe-attributes"><a class="header" href="#unsafe-attributes">Unsafe attributes</a></h1>
<h2 id="summary-20"><a class="header" href="#summary-20">Summary</a></h2>
<ul>
<li>The following attributes must now be marked as <code>unsafe</code>:
<ul>
<li><a href="rust-2024/../../reference/abi.html#the-export_name-attribute"><code>export_name</code></a></li>
<li><a href="rust-2024/../../reference/abi.html#the-link_section-attribute"><code>link_section</code></a></li>
<li><a href="rust-2024/../../reference/abi.html#the-no_mangle-attribute"><code>no_mangle</code></a></li>
</ul>
</li>
</ul>
<h2 id="details-17"><a class="header" href="#details-17">Details</a></h2>
<p>Rust 1.82 added the ability in all editions to mark certain attributes as <code>unsafe</code> to indicate that they have soundness requirements that must be upheld.<sup class="footnote-reference"><a href="#RFC3325">1</a></sup> The syntax for an unsafe attribute looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// SAFETY: there is no other global function of this name
#[unsafe(no_mangle)]
pub fn example() {}
<span class="boring">}</span></code></pre></pre>
<p>Marking the attribute with <code>unsafe</code> highlights that there are safety requirements that must be upheld that the compiler cannot verify on its own.</p>
<p>Starting with the 2024 Edition, it is now required to mark these attributes as <code>unsafe</code>. The following section describes the safety requirements for these attributes.</p>
<div class="footnote-definition" id="RFC3325"><sup class="footnote-definition-label">1</sup>
<p>See <a href="https://rust-lang.github.io/rfcs/3325-unsafe-attributes.html">RFC 3325</a> for the original proposal.</p>
</div>
<h3 id="safety-requirements"><a class="header" href="#safety-requirements">Safety requirements</a></h3>
<p>The <a href="rust-2024/../../reference/abi.html#the-no_mangle-attribute"><code>no_mangle</code></a>, <a href="rust-2024/../../reference/abi.html#the-export_name-attribute"><code>export_name</code></a>, and <a href="rust-2024/../../reference/abi.html#the-link_section-attribute"><code>link_section</code></a> attributes influence the symbol names and linking behavior of items. Care must be taken to ensure that these attributes are used correctly.</p>
<p>Because the set of symbols across all linked libraries is a global namespace, there can be issues if there is a symbol name collision between libraries. Typically this isn't an issue for normally defined functions because <a href="rust-2024/../../rustc/symbol-mangling/index.html">symbol mangling</a> helps ensure that the symbol name is unique. However, attributes like <code>export_name</code> can upset that assumption of uniqueness.</p>
<p>For example, in previous editions the following crashes on most Unix-like platforms despite containing only safe code:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021">fn main() {
    println!("Hello, world!");
}

#[export_name = "malloc"]
fn foo() -&gt; usize { 1 }</code></pre></pre>
<p>In the 2024 Edition, it is now required to mark these attributes as unsafe to emphasize that it is required to ensure that the symbol is defined correctly:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// SAFETY: There should only be a single definition of the loop symbol.
#[unsafe(export_name="loop")]
fn arduino_loop() {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h2 id="migration-14"><a class="header" href="#migration-14">Migration</a></h2>
<p>The <a href="rust-2024/../../rustc/lints/listing/allowed-by-default.html#unsafe-attr-outside-unsafe"><code>unsafe_attr_outside_unsafe</code></a> lint can update these attributes to use the <code>unsafe(...)</code> format. The lint is part of the <code>rust-2024-compatibility</code> lint group which is included in the automatic edition migration. In order to migrate your code to be Rust 2024 Edition compatible, run:</p>
<pre><code class="language-sh">cargo fix --edition
</code></pre>
<p>Just beware that this automatic migration will not be able to verify that these attributes are being used correctly. It is still your responsibility to manually review their usage.</p>
<p>Alternatively, you can manually enable the lint to find places where these attributes need to be updated.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add this to the root of your crate to do a manual migration.
#![warn(unsafe_attr_outside_unsafe)]
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unsafe_op_in_unsafe_fn-warning"><a class="header" href="#unsafe_op_in_unsafe_fn-warning">unsafe_op_in_unsafe_fn warning</a></h1>
<h2 id="summary-21"><a class="header" href="#summary-21">Summary</a></h2>
<ul>
<li>The <a href="rust-2024/../../rustc/lints/listing/allowed-by-default.html#unsafe-op-in-unsafe-fn"><code>unsafe_op_in_unsafe_fn</code></a> lint now warns by default.
This warning detects calls to unsafe operations in unsafe functions without an explicit unsafe block.</li>
</ul>
<h2 id="details-18"><a class="header" href="#details-18">Details</a></h2>
<p>The <a href="rust-2024/../../rustc/lints/listing/allowed-by-default.html#unsafe-op-in-unsafe-fn"><code>unsafe_op_in_unsafe_fn</code></a> lint will fire if there are <a href="rust-2024/../../reference/unsafety.html">unsafe operations</a> in an unsafe function without an explicit <a href="rust-2024/../../reference/expressions/block-expr.html#unsafe-blocks"><code>unsafe {}</code> block</a>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![warn(unsafe_op_in_unsafe_fn)]
</span>unsafe fn get_unchecked&lt;T&gt;(x: &amp;[T], i: usize) -&gt; &amp;T {
  x.get_unchecked(i) // WARNING: requires unsafe block
}
<span class="boring">}</span></code></pre></pre>
<p>The solution is to wrap any unsafe operations in an <code>unsafe</code> block:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![deny(unsafe_op_in_unsafe_fn)]
</span>unsafe fn get_unchecked&lt;T&gt;(x: &amp;[T], i: usize) -&gt; &amp;T {
  unsafe { x.get_unchecked(i) }
}
<span class="boring">}</span></code></pre></pre>
<p>This change is intended to help protect against accidental use of unsafe operations in an unsafe function.
The <code>unsafe</code> function keyword was performing two roles.
One was to declare that <em>calling</em> the function requires unsafe, and that the caller is responsible to uphold additional safety requirements.
The other role was to allow the use of unsafe operations inside of the function.
This second role was determined to be too risky without explicit <code>unsafe</code> blocks.</p>
<p>More information and motivation may be found in <a href="https://rust-lang.github.io/rfcs/2585-unsafe-block-in-unsafe-fn.html">RFC #2585</a>.</p>
<h2 id="migration-15"><a class="header" href="#migration-15">Migration</a></h2>
<p>The <a href="rust-2024/../../rustc/lints/listing/allowed-by-default.html#unsafe-op-in-unsafe-fn"><code>unsafe_op_in_unsafe_fn</code></a> lint is part of the <code>rust-2024-compatibility</code> lint group.
In order to migrate your code to be Rust 2024 Edition compatible, run:</p>
<pre><code class="language-sh">cargo fix --edition
</code></pre>
<p>Alternatively, you can manually enable the lint to find places where unsafe blocks need to be added, or switch it to <code>allow</code> to silence the lint completely.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add this to the root of your crate to do a manual migration.
#![warn(unsafe_op_in_unsafe_fn)]
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="disallow-references-to-static-mut"><a class="header" href="#disallow-references-to-static-mut">Disallow references to static mut</a></h1>
<h2 id="summary-22"><a class="header" href="#summary-22">Summary</a></h2>
<ul>
<li>The <a href="rust-2024/../../rustc/lints/listing/warn-by-default.html#static-mut-refs"><code>static_mut_refs</code></a> lint level is now <code>deny</code> by default.
This checks for taking a shared or mutable reference to a <code>static mut</code>.</li>
</ul>
<h2 id="details-19"><a class="header" href="#details-19">Details</a></h2>
<p>The <a href="rust-2024/../../rustc/lints/listing/warn-by-default.html#static-mut-refs"><code>static_mut_refs</code></a> lint detects taking a reference to a <a href="rust-2024/../../reference/items/static-items.html#mutable-statics"><code>static mut</code></a>. In the 2024 Edition, this lint is now <code>deny</code> by default to emphasize that you should avoid making these references.</p>
<!-- edition2024 -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut X: i32 = 23;
static mut Y: i32 = 24;

unsafe {
    let y = &amp;X;             // ERROR: shared reference to mutable static
    let ref x = X;          // ERROR: shared reference to mutable static
    let (x, y) = (&amp;X, &amp;Y);  // ERROR: shared reference to mutable static
}
<span class="boring">}</span></code></pre></pre>
<p>Merely taking such a reference in violation of Rust's mutability XOR aliasing requirement has always been <em>instantaneous</em> <a href="rust-2024/../../reference/behavior-considered-undefined.html">undefined behavior</a>, <strong>even if the reference is never read from or written to</strong>.  Furthermore, upholding mutability XOR aliasing for a <code>static mut</code> requires <em>reasoning about your code globally</em>, which can be particularly difficult in the face of reentrancy and/or multithreading.</p>
<p>Note that there are some cases where implicit references are automatically created without a visible <code>&amp;</code> operator. For example, these situations will also trigger the lint:</p>
<!-- edition2024 -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut NUMS: &amp;[u8; 3] = &amp;[0, 1, 2];

unsafe {
    println!("{NUMS:?}");   // ERROR: shared reference to mutable static
    let n = NUMS.len();     // ERROR: shared reference to mutable static
}
<span class="boring">}</span></code></pre></pre>
<h2 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h2>
<p>Wherever possible, it is <strong>strongly recommended</strong> to use instead an <em>immutable</em> <code>static</code> of a type that provides <em>interior mutability</em> behind some <em>locally-reasoned abstraction</em> (which greatly reduces the complexity of ensuring that Rust's mutability XOR aliasing requirement is upheld).</p>
<p>In situations where no locally-reasoned abstraction is possible and you are therefore compelled still to reason globally about accesses to your <code>static</code> variable, you must now use raw pointers such as can be obtained via the <a href="rust-2024/../../reference/expressions/operator-expr.html#raw-borrow-operators"><code>&amp;raw const</code> or <code>&amp;raw mut</code> operators</a>.  By first obtaining a raw pointer rather than directly taking a reference, (the safety requirements of) accesses through that pointer will be more familiar to <code>unsafe</code> developers and can be deferred until/limited to smaller regions of code.</p>
<p>Note that the following examples are just illustrations and are not intended as full-fledged implementations. Do not copy these as-is. There are details for your specific situation that may require alterations to fit your needs. These are intended to help you see different ways to approach your problem.</p>
<p>It is recommended to read the documentation for the specific types in the standard library, the reference on <a href="rust-2024/../../reference/behavior-considered-undefined.html">undefined behavior</a>, the <a href="rust-2024/../../nomicon/index.html">Rustonomicon</a>, and if you are having questions to reach out on one of the Rust forums such as the <a href="https://users.rust-lang.org/">Users Forum</a>.</p>
<h3 id="dont-use-globals"><a class="header" href="#dont-use-globals">Don't use globals</a></h3>
<p>This is probably something you already know, but if possible it is best to avoid mutable global state. Of course this can be a little more awkward or difficult at times, particularly if you need to pass a mutable reference around between many functions.</p>
<h3 id="atomics"><a class="header" href="#atomics">Atomics</a></h3>
<p>The <a href="rust-2024/../../std/sync/atomic/index.html">atomic types</a> provide integers, pointers, and booleans that can be used in a <code>static</code> (without <code>mut</code>).</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::sync::atomic::Ordering;
</span><span class="boring">use std::sync::atomic::AtomicU64;
</span>
// Change from this:
//   static mut COUNTER: u64 = 0;
// to this:
static COUNTER: AtomicU64 = AtomicU64::new(0);

fn main() {
    // Be sure to analyze your use case to determine the correct Ordering to use.
    COUNTER.fetch_add(1, Ordering::Relaxed);
}</code></pre></pre>
<h3 id="mutex-or-rwlock"><a class="header" href="#mutex-or-rwlock">Mutex or RwLock</a></h3>
<p>When your type is more complex than an atomic, consider using a <a href="rust-2024/../../std/sync/struct.Mutex.html"><code>Mutex</code></a> or <a href="rust-2024/../../std/sync/struct.RwLock.html"><code>RwLock</code></a> to ensure proper access to the global value.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::collections::VecDeque;
</span>
// Change from this:
//     static mut QUEUE: VecDeque&lt;String&gt; = VecDeque::new();
// to this:
static QUEUE: Mutex&lt;VecDeque&lt;String&gt;&gt; = Mutex::new(VecDeque::new());

fn main() {
    QUEUE.lock().unwrap().push_back(String::from("abc"));
    let first = QUEUE.lock().unwrap().pop_front();
}</code></pre></pre>
<h3 id="oncelock-or-lazylock"><a class="header" href="#oncelock-or-lazylock">OnceLock or LazyLock</a></h3>
<p>If you are using a <code>static mut</code> because you need to do some one-time initialization that can't be <code>const</code>, you can instead reach for <a href="rust-2024/../../std/sync/struct.OnceLock.html"><code>OnceLock</code></a> or <a href="rust-2024/../../std/sync/struct.LazyLock.html"><code>LazyLock</code></a> instead.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::sync::LazyLock;
</span><span class="boring">
</span><span class="boring">struct GlobalState;
</span><span class="boring">
</span><span class="boring">impl GlobalState {
</span><span class="boring">    fn new() -&gt; GlobalState {
</span><span class="boring">        GlobalState
</span><span class="boring">    }
</span><span class="boring">    fn example(&amp;self) {}
</span><span class="boring">}
</span>
// Instead of some temporary or uninitialized type like:
//     static mut STATE: Option&lt;GlobalState&gt; = None;
// use this instead:
static STATE: LazyLock&lt;GlobalState&gt; = LazyLock::new(|| {
    GlobalState::new()
});

fn main() {
    STATE.example();
}</code></pre></pre>
<p><a href="rust-2024/../../std/sync/struct.OnceLock.html"><code>OnceLock</code></a> is similar to <a href="rust-2024/../../std/sync/struct.LazyLock.html"><code>LazyLock</code></a>, but can be used if you need to pass information into the constructor, which can work well with single initialization points (like <code>main</code>), or if the inputs are available wherever you access the global.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::sync::OnceLock;
</span><span class="boring">
</span><span class="boring">struct GlobalState;
</span><span class="boring">
</span><span class="boring">impl GlobalState {
</span><span class="boring">    fn new(verbose: bool) -&gt; GlobalState {
</span><span class="boring">        GlobalState
</span><span class="boring">    }
</span><span class="boring">    fn example(&amp;self) {}
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Args {
</span><span class="boring">    verbose: bool
</span><span class="boring">}
</span><span class="boring">fn parse_arguments() -&gt; Args {
</span><span class="boring">    Args { verbose: true }
</span><span class="boring">}
</span>
static STATE: OnceLock&lt;GlobalState&gt; = OnceLock::new();

fn main() {
    let args = parse_arguments();
    let state = GlobalState::new(args.verbose);
    let _ = STATE.set(state);
    // ...
    STATE.get().unwrap().example();
}</code></pre></pre>
<h3 id="no_std-one-time-initialization"><a class="header" href="#no_std-one-time-initialization"><code>no_std</code> one-time initialization</a></h3>
<p>This example is similar to <a href="rust-2024/../../std/sync/struct.OnceLock.html"><code>OnceLock</code></a> in that it provides one-time initialization of a global, but it does not require <code>std</code> which is useful in a <code>no_std</code> context. Assuming your target supports atomics, then you can use an atomic to check for the initialization of the global. The pattern might look something like this:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use core::sync::atomic::AtomicUsize;
</span><span class="boring">use core::sync::atomic::Ordering;
</span><span class="boring">
</span><span class="boring">struct Args {
</span><span class="boring">    verbose: bool,
</span><span class="boring">}
</span><span class="boring">fn parse_arguments() -&gt; Args {
</span><span class="boring">    Args { verbose: true }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct GlobalState {
</span><span class="boring">    verbose: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl GlobalState {
</span><span class="boring">    const fn default() -&gt; GlobalState {
</span><span class="boring">        GlobalState { verbose: false }
</span><span class="boring">    }
</span><span class="boring">    fn new(verbose: bool) -&gt; GlobalState {
</span><span class="boring">        GlobalState { verbose }
</span><span class="boring">    }
</span><span class="boring">    fn example(&amp;self) {}
</span><span class="boring">}
</span>
const UNINITIALIZED: usize = 0;
const INITIALIZING: usize = 1;
const INITIALIZED: usize = 2;

static STATE_INITIALIZED: AtomicUsize = AtomicUsize::new(UNINITIALIZED);
static mut STATE: GlobalState = GlobalState::default();

fn set_global_state(state: GlobalState) {
    if STATE_INITIALIZED
        .compare_exchange(
            UNINITIALIZED,
            INITIALIZING,
            Ordering::SeqCst,
            Ordering::SeqCst,
        )
        .is_ok()
    {
        // SAFETY: The reads and writes to STATE are guarded with the INITIALIZED guard.
        unsafe {
            STATE = state;
        }
        STATE_INITIALIZED.store(INITIALIZED, Ordering::SeqCst);
    } else {
        panic!("already initialized, or concurrent initialization");
    }
}

fn get_state() -&gt; &amp;'static GlobalState {
    if STATE_INITIALIZED.load(Ordering::Acquire) != INITIALIZED {
        panic!("not initialized");
    } else {
        // SAFETY: Mutable access is not possible after state has been initialized.
        unsafe { &amp;*&amp;raw const STATE }
    }
}

fn main() {
    let args = parse_arguments();
    let state = GlobalState::new(args.verbose);
    set_global_state(state);
    // ...
    let state = get_state();
    state.example();
}</code></pre></pre>
<p>This example assumes you can put some default value in the static before it is initialized (the const <code>default</code> constructor in this example). If that is not possible, consider using either <a href="rust-2024/../../core/mem/union.MaybeUninit.html"><code>MaybeUninit</code></a>, or dynamic trait dispatch (with a dummy type that implements a trait), or some other approach to have a default placeholder.</p>
<p>There are community-provided crates that can provide similar one-time initialization, such as the <a href="https://crates.io/crates/static_cell"><code>static-cell</code></a> crate (which supports targets that do not have atomics by using <a href="https://crates.io/crates/portable-atomic"><code>portable-atomic</code></a>).</p>
<h3 id="raw-pointers"><a class="header" href="#raw-pointers">Raw pointers</a></h3>
<p>In some cases you can continue to use <code>static mut</code>, but avoid creating references. For example, if you just need to pass <a href="rust-2024/../../reference/types/pointer.html#raw-pointers-const-and-mut">raw pointers</a> into a C library, don't create an intermediate reference. Instead you can use <a href="rust-2024/../../reference/expressions/operator-expr.html#raw-borrow-operators">raw borrow operators</a>, like in the following example:</p>
<pre><pre class="playground"><code class="language-rust edition2024 no_run"><span class="boring">#[repr(C)]
</span><span class="boring">struct GlobalState {
</span><span class="boring">    value: i32
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl GlobalState {
</span><span class="boring">    const fn new() -&gt; GlobalState {
</span><span class="boring">        GlobalState { value: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span>
static mut STATE: GlobalState = GlobalState::new();

unsafe extern "C" {
    fn example_ffi(state: *mut GlobalState);
}

fn main() {
    unsafe {
        // Change from this:
        //     example_ffi(&amp;mut STATE as *mut GlobalState);
        // to this:
        example_ffi(&amp;raw mut STATE);
    }
}</code></pre></pre>
<p>Just beware that you still need to uphold the aliasing constraints around mutable pointers. This may require some internal or external synchronization or proofs about how it is used across threads, interrupt handlers, and reentrancy.</p>
<h3 id="unsafecell-with-sync"><a class="header" href="#unsafecell-with-sync"><code>UnsafeCell</code> with <code>Sync</code></a></h3>
<p><a href="rust-2024/../../std/cell/struct.UnsafeCell.html"><code>UnsafeCell</code></a> does not impl <code>Sync</code>, so it cannot be used in a <code>static</code>. You can create your own wrapper around <a href="rust-2024/../../std/cell/struct.UnsafeCell.html"><code>UnsafeCell</code></a> to add a <code>Sync</code> impl so that it can be used in a <code>static</code> to implement interior mutability. This approach can be useful if you have external locks or other guarantees that uphold the safety invariants required for mutable pointers.</p>
<p>Note that this is largely the same as the <a href="rust-2024/static-mut-references.html#raw-pointers">raw pointers</a> example. The wrapper helps to emphasize how you are using the type, and focus on which safety requirements you should be careful of. But otherwise they are roughly the same.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::cell::UnsafeCell;
</span><span class="boring">
</span><span class="boring">fn with_interrupts_disabled&lt;T: Fn()&gt;(f: T) {
</span><span class="boring">    // A real example would disable interrupts.
</span><span class="boring">    f();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[repr(C)]
</span><span class="boring">struct GlobalState {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl GlobalState {
</span><span class="boring">    const fn new() -&gt; GlobalState {
</span><span class="boring">        GlobalState { value: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span>
#[repr(transparent)]
pub struct SyncUnsafeCell&lt;T&gt;(UnsafeCell&lt;T&gt;);

unsafe impl&lt;T: Sync&gt; Sync for SyncUnsafeCell&lt;T&gt; {}

static STATE: SyncUnsafeCell&lt;GlobalState&gt; = SyncUnsafeCell(UnsafeCell::new(GlobalState::new()));

fn set_value(value: i32) {
    with_interrupts_disabled(|| {
        let state = STATE.0.get();
        unsafe {
            // SAFETY: This value is only ever read in our interrupt handler,
            // and interrupts are disabled, and we only use this in one thread.
            (*state).value = value;
        }
    });
}
<span class="boring">}</span></code></pre></pre>
<p>The standard library has a nightly-only (unstable) variant of <a href="rust-2024/../../std/cell/struct.UnsafeCell.html"><code>UnsafeCell</code></a> called <a href="rust-2024/../../std/cell/struct.SyncUnsafeCell.html"><code>SyncUnsafeCell</code></a>. This example above shows a very simplified version of the standard library type, but would be used roughly the same way. It can provide even better isolation, so do check out its implementation for more details.</p>
<p>This example includes a fictional <code>with_interrupts_disabled</code> function which is the type of thing you might see in an embedded environment. For example, the <a href="https://crates.io/crates/critical-section"><code>critical-section</code></a> crate provides a similar kind of functionality that could be used for an embedded environment.</p>
<h3 id="safe-references"><a class="header" href="#safe-references">Safe references</a></h3>
<p>In some cases it may be safe to create a reference of a <code>static mut</code>. The whole point of the <a href="rust-2024/../../rustc/lints/listing/warn-by-default.html#static-mut-refs"><code>static_mut_refs</code></a> lint is that this is very hard to do correctly! However, that's not to say it is <em>impossible</em>. If you have a situation where you can guarantee that the aliasing requirements are upheld, such as guaranteeing the static is narrowly scoped (only used in a small module or function), has some internal or external synchronization, accounts for interrupt handlers and reentrancy, panic safety, drop handlers, etc., then taking a reference may be fine.</p>
<p>There are two approaches you can take for this. You can either allow the <a href="rust-2024/../../rustc/lints/listing/warn-by-default.html#static-mut-refs"><code>static_mut_refs</code></a> lint (preferably as narrowly as you can), or convert raw pointers to a reference, as with <code>&amp;mut *&amp;raw mut MY_STATIC</code>.</p>
<!-- TODO: Should we prefer one or the other here? -->
<h4 id="short-lived-references"><a class="header" href="#short-lived-references">Short-lived references</a></h4>
<p>If you must create a reference to a <code>static mut</code>, then it is recommended to minimize the scope of how long that reference exists. Avoid squirreling the reference away somewhere, or keeping it alive through a large section of code. Keeping it short-lived helps with auditing, and verifying that exclusive access is maintained for the duration. Using pointers should be your default unit, and only convert the pointer to a reference on demand when absolutely required.</p>
<h2 id="migration-16"><a class="header" href="#migration-16">Migration</a></h2>
<p>There is no automatic migration to fix these references to <code>static mut</code>. To avoid undefined behavior you must rewrite your code to use a different approach as recommended in the <a href="rust-2024/static-mut-references.html#alternatives">Alternatives</a> section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="never-type-fallback-change"><a class="header" href="#never-type-fallback-change">Never type fallback change</a></h1>
<h2 id="summary-23"><a class="header" href="#summary-23">Summary</a></h2>
<ul>
<li>Never type (<code>!</code>) to any type ("never-to-any") coercions fall back to never type (<code>!</code>) rather than to unit type (<code>()</code>).</li>
<li>The <a href="rust-2024/../../rustc/lints/listing/warn-by-default.html#never-type-fallback-flowing-into-unsafe"><code>never_type_fallback_flowing_into_unsafe</code></a> lint is now <code>deny</code> by default.</li>
</ul>
<h2 id="details-20"><a class="header" href="#details-20">Details</a></h2>
<p>When the compiler sees a value of type <code>!</code> (never) in a <a href="rust-2024/../../reference/type-coercions.html#coercion-sites">coercion site</a>, it implicitly inserts a coercion to allow the type checker to infer any type:</p>
<pre><pre class="playground"><code class="language-rust should_panic"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![feature(never_type)]
</span>// This:
let x: u8 = panic!();

// ...is (essentially) turned by the compiler into:
let x: u8 = absurd(panic!());

// ...where `absurd` is the following function
// (it's sound because `!` always marks unreachable code):
fn absurd&lt;T&gt;(x: !) -&gt; T { x }
<span class="boring">}</span></code></pre></pre>
<p>This can lead to compilation errors if the type cannot be inferred:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0282"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![feature(never_type)]
</span><span class="boring">fn absurd&lt;T&gt;(x: !) -&gt; T { x }
</span>// This:
{ panic!() };

// ...gets turned into this:
{ absurd(panic!()) }; //~ ERROR can't infer the type of `absurd`
<span class="boring">}</span></code></pre></pre>
<p>To prevent such errors, the compiler remembers where it inserted <code>absurd</code> calls, and if it can't infer the type, it uses the fallback type instead:</p>
<pre><pre class="playground"><code class="language-rust should_panic"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![feature(never_type)]
</span><span class="boring">fn absurd&lt;T&gt;(x: !) -&gt; T { x }
</span>type Fallback = /* An arbitrarily selected type! */ !;
{ absurd::&lt;Fallback&gt;(panic!()) }
<span class="boring">}</span></code></pre></pre>
<p>This is what is known as "never type fallback".</p>
<p>Historically, the fallback type has been <code>()</code> (unit).  This caused <code>!</code> to spontaneously coerce to <code>()</code> even when the compiler would not infer <code>()</code> without the fallback.  That was confusing and has prevented the stabilization of the <code>!</code> type.</p>
<p>In the 2024 edition, the fallback type is now <code>!</code>.  (We plan to make this change across all editions at a later date.)  This makes things work more intuitively.  Now when you pass <code>!</code> and there is no reason to coerce it to something else, it is kept as <code>!</code>.</p>
<p>In some cases your code might depend on the fallback type being <code>()</code>, so this can cause compilation errors or changes in behavior.</p>
<h3 id="never_type_fallback_flowing_into_unsafe"><a class="header" href="#never_type_fallback_flowing_into_unsafe"><code>never_type_fallback_flowing_into_unsafe</code></a></h3>
<p>The default level of the <a href="rust-2024/../../rustc/lints/listing/warn-by-default.html#never-type-fallback-flowing-into-unsafe"><code>never_type_fallback_flowing_into_unsafe</code></a> lint has been raised from <code>warn</code> to <code>deny</code> in the 2024 Edition. This lint helps detect a particular interaction with the fallback to <code>!</code> and <code>unsafe</code> code which may lead to undefined behavior. See the link for a complete description.</p>
<h2 id="migration-17"><a class="header" href="#migration-17">Migration</a></h2>
<p>There is no automatic fix, but there is automatic detection of code that will be broken by the edition change.  While still on a previous edition you will see warnings if your code will be broken.</p>
<p>The fix is to specify the type explicitly so that the fallback type is not used.  Unfortunately, it might not be trivial to see which type needs to be specified.</p>
<p>One of the most common patterns broken by this change is using <code>f()?;</code> where <code>f</code> is generic over the <code>Ok</code>-part of the return type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![allow(dependency_on_unit_never_type_fallback)]
</span><span class="boring">fn outer&lt;T&gt;(x: T) -&gt; Result&lt;T, ()&gt; {
</span>fn f&lt;T: Default&gt;() -&gt; Result&lt;T, ()&gt; {
    Ok(T::default())
}

f()?;
<span class="boring">Ok(x)
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>You might think that, in this example, type <code>T</code> can't be inferred.  However, due to the current desugaring of the <code>?</code> operator, it was inferred as <code>()</code>, and it will now be inferred as <code>!</code>.</p>
<p>To fix the issue you need to specify the <code>T</code> type explicitly:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![deny(dependency_on_unit_never_type_fallback)]
</span><span class="boring">fn outer&lt;T&gt;(x: T) -&gt; Result&lt;T, ()&gt; {
</span><span class="boring">fn f&lt;T: Default&gt;() -&gt; Result&lt;T, ()&gt; {
</span><span class="boring">    Ok(T::default())
</span><span class="boring">}
</span>f::&lt;()&gt;()?;
// ...or:
() = f()?;
<span class="boring">Ok(x)
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Another relatively common case is panicking in a closure:</p>
<pre><pre class="playground"><code class="language-rust should_panic"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![allow(dependency_on_unit_never_type_fallback)]
</span>trait Unit {}
impl Unit for () {}

fn run&lt;R: Unit&gt;(f: impl FnOnce() -&gt; R) {
    f();
}

run(|| panic!());
<span class="boring">}</span></code></pre></pre>
<p>Previously <code>!</code> from the <code>panic!</code> coerced to <code>()</code> which implements <code>Unit</code>.  However now the <code>!</code> is kept as <code>!</code> so this code fails because <code>!</code> doesn't implement <code>Unit</code>.  To fix this you can specify the return type of the closure:</p>
<pre><pre class="playground"><code class="language-rust edition2024 should_panic"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![deny(dependency_on_unit_never_type_fallback)]
</span><span class="boring">trait Unit {}
</span><span class="boring">impl Unit for () {}
</span><span class="boring">
</span><span class="boring">fn run&lt;R: Unit&gt;(f: impl FnOnce() -&gt; R) {
</span><span class="boring">    f();
</span><span class="boring">}
</span>run(|| -&gt; () { panic!() });
<span class="boring">}</span></code></pre></pre>
<p>A similar case to that of <code>f()?</code> can be seen when using a <code>!</code>-typed expression in one branch and a function with an unconstrained return type in the other:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![allow(dependency_on_unit_never_type_fallback)]
</span>if true {
    Default::default()
} else {
    return
};
<span class="boring">}</span></code></pre></pre>
<p>Previously <code>()</code> was inferred as the return type of <code>Default::default()</code> because <code>!</code> from <code>return</code> was spuriously coerced to <code>()</code>.  Now, <code>!</code> will be inferred instead causing this code to not compile because <code>!</code> does not implement <code>Default</code>.</p>
<p>Again, this can be fixed by specifying the type explicitly:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![deny(dependency_on_unit_never_type_fallback)]
</span>() = if true {
    Default::default()
} else {
    return
};

// ...or:

if true {
    &lt;() as Default&gt;::default()
} else {
    return
};
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macro-fragment-specifiers"><a class="header" href="#macro-fragment-specifiers">Macro Fragment Specifiers</a></h1>
<h2 id="summary-24"><a class="header" href="#summary-24">Summary</a></h2>
<ul>
<li>The <code>expr</code> <a href="rust-2024/../../reference/macros-by-example.html#metavariables">fragment specifier</a> now also supports <code>const</code> and <code>_</code> expressions.</li>
<li>The <code>expr_2021</code> fragment specifier has been added for backwards compatibility.</li>
</ul>
<h2 id="details-21"><a class="header" href="#details-21">Details</a></h2>
<p>As new syntax is added to Rust, existing <code>macro_rules</code> fragment specifiers are sometimes not allowed to match on the new syntax in order to retain backwards compatibility. Supporting the new syntax in the old fragment specifiers is sometimes deferred until the next edition, which provides an opportunity to update them.</p>
<p>Indeed this happened with <a href="rust-2024/../../reference/expressions/block-expr.html#const-blocks"><code>const</code> expressions</a> added in 1.79 and <a href="rust-2024/../../reference/expressions/underscore-expr.html"><code>_</code> expressions</a> added in 1.59. In the 2021 Edition and earlier, the <code>expr</code> fragment specifier does <em>not</em> match those expressions. This is because you may have a scenario like:</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! example {
    ($e:expr) =&gt; { println!("first rule"); };
    (const $e:expr) =&gt; { println!("second rule"); };
}

fn main() {
    example!(const { 1 + 1 });
}</code></pre></pre>
<p>Here, in the 2021 Edition, the macro will match the <em>second</em> rule. If earlier editions had changed <code>expr</code> to match the newly introduced <code>const</code> expressions, then it would match the <em>first</em> rule, which would be a breaking change.</p>
<p>In the 2024 Edition, <code>expr</code> specifiers now also match <code>const</code> and <code>_</code> expressions. To support the old behavior, the <code>expr_2021</code> fragment specifier has been added which does <em>not</em> match the new expressions.</p>
<h2 id="migration-18"><a class="header" href="#migration-18">Migration</a></h2>
<p>The <a href="rust-2024/../../rustc/lints/listing/allowed-by-default.html#edition-2024-expr-fragment-specifier"><code>edition_2024_expr_fragment_specifier</code></a> lint will change all uses of the <code>expr</code> specifier to <code>expr_2021</code> to ensure that the behavior of existing macros does not change. The lint is part of the <code>rust-2024-compatibility</code> lint group which is included in the automatic edition migration. In order to migrate your code to be Rust 2024 Edition compatible, run:</p>
<pre><code class="language-sh">cargo fix --edition
</code></pre>
<p>In <em>most</em> cases, you will likely want to keep the <code>expr</code> specifier instead, in order to support the new expressions. You will need to review your macro to determine if there are other rules that would otherwise match with <code>const</code> or <code>_</code> and determine if there is a conflict. If you want the new behavior, just revert any changes made by the lint.</p>
<p>Alternatively, you can manually enable the lint to find macros where you may need to update the <code>expr</code> specifier.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add this to the root of your crate to do a manual migration.
#![warn(edition_2024_expr_fragment_specifier)]
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="missing-macro-fragment-specifiers"><a class="header" href="#missing-macro-fragment-specifiers">Missing macro fragment specifiers</a></h1>
<h2 id="summary-25"><a class="header" href="#summary-25">Summary</a></h2>
<ul>
<li>The <a href="rust-2024/../../rustc/lints/listing/deny-by-default.html#missing-fragment-specifier"><code>missing_fragment_specifier</code></a> lint is now a hard error.</li>
</ul>
<h2 id="details-22"><a class="header" href="#details-22">Details</a></h2>
<p>The <a href="rust-2024/../../rustc/lints/listing/deny-by-default.html#missing-fragment-specifier"><code>missing_fragment_specifier</code></a> lint detects a situation when an <strong>unused</strong> pattern in a <code>macro_rules!</code> macro definition has a meta-variable (e.g. <code>$e</code>) that is not followed by a fragment specifier (e.g. <code>:expr</code>). This is now a hard error in the 2024 Edition.</p>
<pre><pre class="playground"><code class="language-rust compile_fail">macro_rules! foo {
   () =&gt; {};
   ($name) =&gt; { }; // ERROR: missing fragment specifier
}

fn main() {
   foo!();
}</code></pre></pre>
<p>Calling the macro with arguments that would match a rule with a missing specifier (e.g., <code>foo!($name)</code>) is a hard error in all editions. However, simply defining a macro with missing fragment specifiers is not, though we did add a lint in Rust 1.17.</p>
<p>We'd like to make this a hard error in all editions, but there would be too much breakage right now. So we're starting by making this a hard error in Rust 2024.<sup class="footnote-reference"><a href="#future-incompat">1</a></sup></p>
<div class="footnote-definition" id="future-incompat"><sup class="footnote-definition-label">1</sup>
<p>The lint is marked as a "future-incompatible" warning to indicate that it may become a hard error in all editions in a future release. See <a href="https://github.com/rust-lang/rust/issues/40107">#40107</a> for more information.</p>
</div>
<h2 id="migration-19"><a class="header" href="#migration-19">Migration</a></h2>
<p>To migrate your code to the 2024 Edition, remove the unused matcher rule from the macro. The <a href="rust-2024/../../rustc/lints/listing/deny-by-default.html#missing-fragment-specifier"><code>missing_fragment_specifier</code></a> lint is on by default in all editions, and should alert you to macros with this issue.</p>
<p>There is no automatic migration for this change. We expect that this style of macro is extremely rare. The lint has been a future-incompatibility lint since Rust 1.17, a deny-by-default lint since Rust 1.20, and since Rust 1.82, it has warned about dependencies that are using this pattern.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gen-keyword"><a class="header" href="#gen-keyword"><code>gen</code> keyword</a></h1>
<h2 id="summary-26"><a class="header" href="#summary-26">Summary</a></h2>
<ul>
<li><code>gen</code> is a <a href="rust-2024/../../reference/keywords.html#reserved-keywords">reserved keyword</a>.</li>
</ul>
<h2 id="details-23"><a class="header" href="#details-23">Details</a></h2>
<p>The <code>gen</code> keyword has been reserved as part of <a href="https://rust-lang.github.io/rfcs/3513-gen-blocks.html">RFC #3513</a> to introduce "gen blocks" in a future release of Rust. <code>gen</code> blocks will provide a way to make it easier to write certain kinds of iterators. Reserving the keyword now will make it easier to stabilize <code>gen</code> blocks before the next edition.</p>
<h2 id="migration-20"><a class="header" href="#migration-20">Migration</a></h2>
<p>Introducing the <code>gen</code> keyword can cause a problem for any identifiers that are already called <code>gen</code>. For example, any variable or function name called <code>gen</code> would clash with the new keyword. To overcome this, Rust supports the <code>r#</code> prefix for a <a href="rust-2024/../../reference/identifiers.html#raw-identifiers">raw identifier</a>, which allows identifiers to overlap with keywords.</p>
<p>The <a href="rust-2024/../../rustc/lints/listing/allowed-by-default.html#keyword-idents-2024"><code>keyword_idents_2024</code></a> lint will automatically modify any identifier named <code>gen</code> to be <code>r#gen</code> so that code continues to work on both editions. This lint is part of the <code>rust-2024-compatibility</code> lint group, which will automatically be applied when running <code>cargo fix --edition</code>. To migrate your code to be Rust 2024 Edition compatible, run:</p>
<pre><code class="language-sh">cargo fix --edition
</code></pre>
<p>For example, this will change:</p>
<pre><pre class="playground"><code class="language-rust">fn gen() {
    println!("generating!");
}

fn main() {
    gen();
}</code></pre></pre>
<p>to be:</p>
<pre><pre class="playground"><code class="language-rust">fn r#gen() {
    println!("generating!");
}

fn main() {
    r#gen();
}</code></pre></pre>
<p>Alternatively, you can manually enable the lint to find places where <code>gen</code> identifiers need to be modified to <code>r#gen</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add this to the root of your crate to do a manual migration.
#![warn(keyword_idents_2024)]
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reserved-syntax-1"><a class="header" href="#reserved-syntax-1">Reserved syntax</a></h1>
<h2 id="summary-27"><a class="header" href="#summary-27">Summary</a></h2>
<ul>
<li>Unprefixed guarded strings of the form <code>#"foo"#</code> are reserved for future use.</li>
<li>Two or more <code>#</code> characters are reserved for future use.</li>
</ul>
<h2 id="details-24"><a class="header" href="#details-24">Details</a></h2>
<p><a href="https://rust-lang.github.io/rfcs/3593-unprefixed-guarded-strings.html">RFC 3593</a> reserved syntax in the 2024 Edition for guarded string literals that do not have a prefix to make room for possible future language changes. The 2021 Edition <a href="rust-2024/../rust-2021/reserved-syntax.html">reserved syntax</a> for guarded strings with a prefix, such as <code>ident##"foo"##</code>. The 2024 Edition extends that to also reserve strings without the <code>ident</code> prefix.</p>
<p>There are two reserved syntaxes:</p>
<ul>
<li>One or more <code>#</code> characters immediately followed by a <a href="rust-2024/../../reference/tokens.html#string-literals">string literal</a>.</li>
<li>Two or more <code>#</code> characters in a row (not separated by whitespace).</li>
</ul>
<p>This reservation is done across an edition boundary because of interactions with tokenization and macros. For example, consider this macro:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! demo {
    ( $a:tt ) =&gt; { println!("one token") };
    ( $a:tt $b:tt $c:tt ) =&gt; { println!("three tokens") };
}

demo!("foo");
demo!(r#"foo"#);
demo!(#"foo"#);
demo!(###)
<span class="boring">}</span></code></pre></pre>
<p>Prior to the 2024 Edition, this produces:</p>
<pre><code class="language-text">one token
one token
three tokens
three tokens
</code></pre>
<p>Starting in the 2024 Edition, the <code>#"foo"#</code> line and the <code>###</code> line now generates a compile error because those forms are now reserved.</p>
<h2 id="migration-21"><a class="header" href="#migration-21">Migration</a></h2>
<p>The <a href="rust-2024/../../rustc/lints/listing/allowed-by-default.html#rust-2024-guarded-string-incompatible-syntax"><code>rust_2024_guarded_string_incompatible_syntax</code></a> lint will identify any tokens that match the reserved syntax, and will suggest a modification to insert spaces where necessary to ensure the tokens continue to be parsed separately.</p>
<p>The lint is part of the <code>rust-2024-compatibility</code> lint group which is included in the automatic edition migration. In order to migrate your code to be Rust 2024 Edition compatible, run:</p>
<pre><code class="language-sh">cargo fix --edition
</code></pre>
<p>Alternatively, you can manually enable the lint to find macro calls where you may need to update the tokens:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add this to the root of your crate to do a manual migration.
#![warn(rust_2024_guarded_string_incompatible_syntax)]
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-library"><a class="header" href="#standard-library">Standard library</a></h1>
<p>The following chapters detail changes to the standard library in the 2024 Edition.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changes-to-the-prelude"><a class="header" href="#changes-to-the-prelude">Changes to the prelude</a></h1>
<h2 id="summary-28"><a class="header" href="#summary-28">Summary</a></h2>
<ul>
<li>The <a href="rust-2024/../../std/future/trait.Future.html"><code>Future</code></a> and <a href="rust-2024/../../std/future/trait.IntoFuture.html"><code>IntoFuture</code></a> traits are now part of the prelude.</li>
<li>This might make calls to trait methods ambiguous which could make some code fail to compile.</li>
</ul>
<h2 id="details-25"><a class="header" href="#details-25">Details</a></h2>
<p>The <a href="rust-2024/../../std/prelude/index.html">prelude of the standard library</a> is the module containing everything that is automatically imported in every module.
It contains commonly used items such as <code>Option</code>, <code>Vec</code>, <code>drop</code>, and <code>Clone</code>.</p>
<p>The Rust compiler prioritizes any manually imported items over those from the prelude,
to make sure additions to the prelude will not break any existing code.
For example, if you have a crate or module called <code>example</code> containing a <code>pub struct Option;</code>,
then <code>use example::*;</code> will make <code>Option</code> unambiguously refer to the one from <code>example</code>;
not the one from the standard library.</p>
<p>However, adding a <em>trait</em> to the prelude can break existing code in a subtle way.
For example, a call to <code>x.poll()</code> which comes from a <code>MyPoller</code> trait might fail to compile if <code>std</code>'s <code>Future</code> is also imported, because the call to <code>poll</code> is now ambiguous and could come from either trait.</p>
<p>As a solution, Rust 2024 will use a new prelude.
It's identical to the current one, except for the following changes:</p>
<ul>
<li>Added:
<ul>
<li><a href="rust-2024/../../std/future/trait.Future.html"><code>std::future::Future</code></a></li>
<li><a href="rust-2024/../../std/future/trait.IntoFuture.html"><code>std::future::IntoFuture</code></a></li>
</ul>
</li>
</ul>
<h2 id="migration-22"><a class="header" href="#migration-22">Migration</a></h2>
<h3 id="conflicting-trait-methods-1"><a class="header" href="#conflicting-trait-methods-1">Conflicting trait methods</a></h3>
<p>When two traits that are in scope have the same method name, it is ambiguous which trait method should be used. For example:</p>
<pre><pre class="playground"><code class="language-rust edition2021">trait MyPoller {
    // This name is the same as the `poll` method on the `Future` trait from `std`.
    fn poll(&amp;self) {
        println!("polling");
    }
}

impl&lt;T&gt; MyPoller for T {}

fn main() {
    // Pin&lt;&amp;mut async {}&gt; implements both `std::future::Future` and `MyPoller`.
    // If both traits are in scope (as would be the case in Rust 2024),
    // then it becomes ambiguous which `poll` method to call
    core::pin::pin!(async {}).poll();
}</code></pre></pre>
<p>We can fix this so that it works on all editions by using fully qualified syntax:</p>
<pre><code class="language-rust ignore">fn main() {
    // Now it is clear which trait method we're referring to
    &lt;_ as MyPoller&gt;::poll(&amp;core::pin::pin!(async {}));
}</code></pre>
<p>The <a href="rust-2024/../../rustc/lints/listing/allowed-by-default.html#rust-2024-prelude-collisions"><code>rust_2024_prelude_collisions</code></a> lint will automatically modify any ambiguous method calls to use fully qualified syntax. This lint is part of the <code>rust-2024-compatibility</code> lint group, which will automatically be applied when running <code>cargo fix --edition</code>. To migrate your code to be Rust 2024 Edition compatible, run:</p>
<pre><code class="language-sh">cargo fix --edition
</code></pre>
<p>Alternatively, you can manually enable the lint to find places where these qualifications need to be added:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add this to the root of your crate to do a manual migration.
#![warn(rust_2024_prelude_collisions)]
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="add-intoiterator-for-boxt"><a class="header" href="#add-intoiterator-for-boxt">Add <code>IntoIterator</code> for <code>Box&lt;[T]&gt;</code></a></h1>
<h2 id="summary-29"><a class="header" href="#summary-29">Summary</a></h2>
<ul>
<li>Boxed slices implement <a href="rust-2024/../../std/iter/trait.IntoIterator.html"><code>IntoIterator</code></a> in <em>all</em> editions.</li>
<li>Calls to <a href="rust-2024/../../std/iter/trait.IntoIterator.html#tymethod.into_iter"><code>IntoIterator::into_iter</code></a> are <em>hidden</em> in editions prior to 2024 when using method call syntax (i.e., <code>boxed_slice.into_iter()</code>). So, <code>boxed_slice.into_iter()</code> still resolves to <code>(&amp;(*boxed_slice)).into_iter()</code> as it has before.</li>
<li><code>boxed_slice.into_iter()</code> changes meaning to call <a href="rust-2024/../../std/iter/trait.IntoIterator.html#tymethod.into_iter"><code>IntoIterator::into_iter</code></a> in Rust 2024.</li>
</ul>
<h2 id="details-26"><a class="header" href="#details-26">Details</a></h2>
<p>Until Rust 1.80, <code>IntoIterator</code> was not implemented for boxed slices. In prior versions, if you called <code>.into_iter()</code> on a boxed slice, the method call would automatically dereference from <code>Box&lt;[T]&gt;</code> to <code>&amp;[T]</code>, and return an iterator that yielded references of <code>&amp;T</code>. For example, the following worked in prior versions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example of behavior in previous editions.
let my_boxed_slice: Box&lt;[u32]&gt; = vec![1, 2, 3].into_boxed_slice();
// Note: .into_iter() was required in versions older than 1.80
for x in my_boxed_slice.into_iter() {
    // x is of type &amp;u32 in editions prior to 2024
}
<span class="boring">}</span></code></pre></pre>
<p>In Rust 1.80, implementations of <code>IntoIterator</code> were added for boxed slices. This allows iterating over elements of the slice by-value instead of by-reference:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// NEW as of 1.80, all editions
let my_boxed_slice: Box&lt;[u32]&gt; = vec![1, 2, 3].into_boxed_slice();
for x in my_boxed_slice { // notice no need for calling .into_iter()
    // x is of type u32
}
<span class="boring">}</span></code></pre></pre>
<p>This example is allowed on all editions because previously this was an error since <code>for</code> loops do not automatically dereference like the <code>.into_iter()</code> method call does.</p>
<p>However, this would normally be a breaking change because existing code that manually called <code>.into_iter()</code> on a boxed slice would change from having an iterator over references to an iterator over values. To resolve this problem, method calls of <code>.into_iter()</code> on boxed slices have edition-dependent behavior. In editions before 2024, it continues to return an iterator over references, and starting in Edition 2024 it returns an iterator over values.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example of changed behavior in Edition 2024
let my_boxed_slice: Box&lt;[u32]&gt; = vec![1, 2, 3].into_boxed_slice();
// Example of old code that still manually calls .into_iter()
for x in my_boxed_slice.into_iter() {
    // x is now type u32 in Edition 2024
}
<span class="boring">}</span></code></pre></pre>
<h2 id="migration-23"><a class="header" href="#migration-23">Migration</a></h2>
<p>The <a href="rust-2024/../../rustc/lints/listing/warn-by-default.html#boxed-slice-into-iter"><code>boxed_slice_into_iter</code></a> lint will automatically modify any calls to <code>.into_iter()</code> on boxed slices to call <code>.iter()</code> instead to retain the old behavior of yielding references. This lint is part of the <code>rust-2024-compatibility</code> lint group, which will automatically be applied when running <code>cargo fix --edition</code>. To migrate your code to be Rust 2024 Edition compatible, run:</p>
<pre><code class="language-sh">cargo fix --edition
</code></pre>
<p>For example, this will change:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_boxed_slice: Box&lt;[u32]&gt; = vec![1, 2, 3].into_boxed_slice();
    for x in my_boxed_slice.into_iter() {
        // x is of type &amp;u32
    }
}</code></pre></pre>
<p>to be:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_boxed_slice: Box&lt;[u32]&gt; = vec![1, 2, 3].into_boxed_slice();
    for x in my_boxed_slice.iter() {
        // x is of type &amp;u32
    }
}</code></pre></pre>
<p>The <a href="rust-2024/../../rustc/lints/listing/warn-by-default.html#boxed-slice-into-iter"><code>boxed_slice_into_iter</code></a> lint is defaulted to warn on all editions, so unless you have manually silenced the lint, you should already see it before you migrate.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unsafe-functions"><a class="header" href="#unsafe-functions">Unsafe functions</a></h1>
<h2 id="summary-30"><a class="header" href="#summary-30">Summary</a></h2>
<ul>
<li>The following functions are now marked <a href="rust-2024/../../reference/unsafe-keyword.html#unsafe-functions-unsafe-fn"><code>unsafe</code></a>:
<ul>
<li><a href="rust-2024/../../std/env/fn.set_var.html"><code>std::env::set_var</code></a></li>
<li><a href="rust-2024/../../std/env/fn.remove_var.html"><code>std::env::remove_var</code></a></li>
<li><a href="rust-2024/../../std/os/unix/process/trait.CommandExt.html#method.before_exec"><code>std::os::unix::process::CommandExt::before_exec</code></a></li>
</ul>
</li>
</ul>
<h2 id="details-27"><a class="header" href="#details-27">Details</a></h2>
<p>Over time it has become evident that certain functions in the standard library should have been marked as <code>unsafe</code>. However, adding <code>unsafe</code> to a function can be a breaking change since it requires existing code to be placed in an <code>unsafe</code> block. To avoid the breaking change, these functions are marked as <code>unsafe</code> starting in the 2024 Edition, while not requiring <code>unsafe</code> in previous editions.</p>
<h3 id="stdenvset_var-remove_var"><a class="header" href="#stdenvset_var-remove_var"><code>std::env::{set_var, remove_var}</code></a></h3>
<p>It can be unsound to call <a href="rust-2024/../../std/env/fn.set_var.html"><code>std::env::set_var</code></a> or <a href="rust-2024/../../std/env/fn.remove_var.html"><code>std::env::remove_var</code></a> in a multi-threaded program due to safety limitations of the way the process environment is handled on some platforms. The standard library originally defined these as safe functions, but it was later determined that was not correct.</p>
<p>It is important to ensure that these functions are not called when any other thread might be running. See the <a href="rust-2024/../../std/env/fn.set_var.html#safety">Safety</a> section of the function documentation for more details.</p>
<h3 id="stdosunixprocesscommandextbefore_exec"><a class="header" href="#stdosunixprocesscommandextbefore_exec"><code>std::os::unix::process::CommandExt::before_exec</code></a></h3>
<p>The <a href="rust-2024/../../std/os/unix/process/trait.CommandExt.html#method.before_exec"><code>std::os::unix::process::CommandExt::before_exec</code></a> function is a unix-specific function which provides a way to run a closure before calling <code>exec</code>. This function was deprecated in the 1.37 release, and replaced with <a href="rust-2024/../../std/os/unix/process/trait.CommandExt.html#tymethod.pre_exec"><code>pre_exec</code></a> which does the same thing, but is marked as <code>unsafe</code>.</p>
<p>Even though <code>before_exec</code> is deprecated, it is now correctly marked as <code>unsafe</code> starting in the 2024 Edition. This should help ensure that any legacy code which has not already migrated to <code>pre_exec</code> to require an <code>unsafe</code> block.</p>
<p>There are very strict safety requirements for the <code>before_exec</code> closure to satisfy. See the <a href="rust-2024/../../std/os/unix/process/trait.CommandExt.html#notes-and-safety">Safety section</a> for more details.</p>
<h2 id="migration-24"><a class="header" href="#migration-24">Migration</a></h2>
<p>To make your code compile in both the 2021 and 2024 editions, you will need to make sure that these functions are called only from within <code>unsafe</code> blocks.</p>
<p><strong>⚠ Caution</strong>: It is important that you manually inspect the calls to these functions and possibly rewrite your code to satisfy the preconditions of those functions. In particular, <code>set_var</code> and <code>remove_var</code> should not be called if there might be multiple threads running. You may need to elect to use a different mechanism other than environment variables to manage your use case.</p>
<p>The <a href="rust-2024/../../rustc/lints/listing/allowed-by-default.html#deprecated-safe-2024"><code>deprecated_safe_2024</code></a> lint will automatically modify any use of these functions to be wrapped in an <code>unsafe</code> block so that it can compile on both editions. This lint is part of the <code>rust-2024-compatibility</code> lint group, which will automatically be applied when running <code>cargo fix --edition</code>. To migrate your code to be Rust 2024 Edition compatible, run:</p>
<pre><code class="language-sh">cargo fix --edition
</code></pre>
<p>For example, this will change:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    std::env::set_var("FOO", "123");
}</code></pre></pre>
<p>to be:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // TODO: Audit that the environment access only happens in single-threaded code.
    unsafe { std::env::set_var("FOO", "123") };
}</code></pre></pre>
<p>Just beware that this automatic migration will not be able to verify that these functions are being used correctly. It is still your responsibility to manually review their usage.</p>
<p>Alternatively, you can manually enable the lint to find places these functions are called:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add this to the root of your crate to do a manual migration.
#![warn(deprecated_safe_2024)]
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo"><a class="header" href="#cargo">Cargo</a></h1>
<p>The following chapters detail changes to Cargo in the 2024 Edition.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-rust-version-aware-resolver"><a class="header" href="#cargo-rust-version-aware-resolver">Cargo: Rust-version aware resolver</a></h1>
<h2 id="summary-31"><a class="header" href="#summary-31">Summary</a></h2>
<ul>
<li><code>edition = "2024"</code> implies <code>resolver = "3"</code> in <code>Cargo.toml</code> which enables a Rust-version aware dependency resolver.</li>
</ul>
<h2 id="details-28"><a class="header" href="#details-28">Details</a></h2>
<p>Since Rust 1.84.0, Cargo has opt-in support for compatibility with
<a href="rust-2024/../../cargo/reference/rust-version.html"><code>package.rust-version</code></a> to be considered when selecting dependency versions
by setting <a href="rust-2024/../../cargo/reference/config.html#resolverincompatible-rust-versions"><code>resolver.incompatible-rust-version = "fallback"</code></a> in <code>.cargo/config.toml</code>.</p>
<p>Starting in Rust 2024, this will be the default.
That is, writing <code>edition = "2024"</code> in <code>Cargo.toml</code> will imply <code>resolver = "3"</code>
which will imply <a href="rust-2024/../../cargo/reference/config.html#resolverincompatible-rust-versions"><code>resolver.incompatible-rust-version = "fallback"</code></a>.</p>
<p>The resolver is a global setting for a <a href="rust-2024/../../cargo/reference/workspaces.html">workspace</a>, and the setting is ignored in dependencies.
The setting is only honored for the top-level package of the workspace.
If you are using a <a href="rust-2024/../../cargo/reference/workspaces.html#virtual-workspace">virtual workspace</a>, you will still need to explicitly set the <a href="rust-2024/../../cargo/reference/resolver.html#resolver-versions"><code>resolver</code> field</a>
in the <code>[workspace]</code> definition if you want to opt-in to the new resolver.</p>
<p>For more details on how Rust-version aware dependency resolution works, see <a href="rust-2024/../../cargo/reference/resolver.html#rust-version">the Cargo book</a>.</p>
<h2 id="migration-25"><a class="header" href="#migration-25">Migration</a></h2>
<p>There are no automated migration tools for updating for the new resolver.</p>
<p>We recommend projects
<a href="rust-2024/../../cargo/guide/continuous-integration.html#verifying-latest-dependencies">verify against the latest dependencies in CI</a>
to catch bugs in dependencies as soon as possible.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-table-and-key-name-consistency"><a class="header" href="#cargo-table-and-key-name-consistency">Cargo: Table and key name consistency</a></h1>
<h2 id="summary-32"><a class="header" href="#summary-32">Summary</a></h2>
<ul>
<li>Several table and key names in <code>Cargo.toml</code> have been removed where there were previously two ways to specify the same thing.
<ul>
<li>Removed <code>[project]</code>; use <code>[package]</code> instead.</li>
<li>Removed <code>default_features</code>; use <code>default-features</code> instead.</li>
<li>Removed <code>crate_type</code>; use <code>crate-type</code> instead.</li>
<li>Removed <code>proc_macro</code>; use <code>proc-macro</code> instead.</li>
<li>Removed <code>dev_dependencies</code>; use <code>dev-dependencies</code> instead.</li>
<li>Removed <code>build_dependencies</code>; use <code>build-dependencies</code> instead.</li>
</ul>
</li>
</ul>
<h2 id="details-29"><a class="header" href="#details-29">Details</a></h2>
<p>Several table and keys names are no longer allowed in the 2024 Edition.
There were two ways to specify these tables or keys, and this helps ensure there is only one way to specify them.</p>
<p>Some were due to a change in decisions over time, and some were inadvertent implementation artifacts.
In order to avoid confusion, and to enforce a single style for specifying these tables and keys, only one variant is now allowed.</p>
<p>For example:</p>
<pre><code class="language-toml">[dev_dependencies]
rand = { version = "0.8.5", default_features = false }
</code></pre>
<p>Should be changed to:</p>
<pre><code class="language-toml">[dev-dependencies]
rand = { version = "0.8.5", default-features = false }
</code></pre>
<p>Notice that the underscores were changed to dashes for <code>dev_dependencies</code> and <code>default_features</code>.</p>
<h2 id="migration-26"><a class="header" href="#migration-26">Migration</a></h2>
<p>When using <code>cargo fix --edition</code>, Cargo will automatically update your <code>Cargo.toml</code> file to use the preferred table and key names.</p>
<p>If you would prefer to update your <code>Cargo.toml</code> manually, be sure to go through the list above and make sure only the new forms are used.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-reject-unused-inherited-default-features"><a class="header" href="#cargo-reject-unused-inherited-default-features">Cargo: Reject unused inherited default-features</a></h1>
<h2 id="summary-33"><a class="header" href="#summary-33">Summary</a></h2>
<ul>
<li><code>default-features = false</code> is no longer allowed in an inherited workspace dependency if the workspace dependency specifies <code>default-features = true</code> (or does not specify <code>default-features</code>).</li>
</ul>
<h2 id="details-30"><a class="header" href="#details-30">Details</a></h2>
<p><a href="rust-2024/../../cargo/reference/specifying-dependencies.html#inheriting-a-dependency-from-a-workspace">Workspace inheritance</a> allows you to specify dependencies in one place (the workspace), and then to refer to those workspace dependencies from within a package.
There was an inadvertent interaction with how <code>default-features</code> is specified that is no longer allowed in the 2024 Edition.</p>
<p>Unless the workspace specifies <code>default-features = false</code>, it is no longer allowed to specify <code>default-features = false</code> in an inherited package dependency.
For example, with a workspace that specifies:</p>
<pre><code class="language-toml">[workspace.dependencies]
regex = "1.10.4"
</code></pre>
<p>The following is now an error:</p>
<pre><code class="language-toml">[package]
name = "foo"
version = "1.0.0"
edition = "2024"

[dependencies]
regex = { workspace = true, default-features = false }  # ERROR
</code></pre>
<p>The reason for this change is to avoid confusion when specifying <code>default-features = false</code> when the default feature is already enabled, since it has no effect.</p>
<p>If you want the flexibility of deciding whether or not a dependency enables the default-features of a dependency, be sure to set <code>default-features = false</code> in the workspace definition.
Just beware that if you build multiple workspace members at the same time, the features will be unified so that if one member sets <code>default-features = true</code> (which is the default if not explicitly set), the default-features will be enabled for all members using that dependency.</p>
<h2 id="migration-27"><a class="header" href="#migration-27">Migration</a></h2>
<p>When using <code>cargo fix --edition</code>, Cargo will automatically update your <code>Cargo.toml</code> file to remove <code>default-features = false</code> in this situation.</p>
<p>If you would prefer to update your <code>Cargo.toml</code> manually, check for any warnings when running a build and remove the corresponding entries.
Previous editions should display something like:</p>
<pre><code class="language-text">warning: /home/project/Cargo.toml: `default-features` is ignored for regex,
since `default-features` was not specified for `workspace.dependencies.regex`,
this could become a hard error in the future
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rustdoc"><a class="header" href="#rustdoc">Rustdoc</a></h1>
<p>The following chapters detail changes to Rustdoc in the 2024 Edition.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rustdoc-combined-tests"><a class="header" href="#rustdoc-combined-tests">Rustdoc combined tests</a></h1>
<h2 id="summary-34"><a class="header" href="#summary-34">Summary</a></h2>
<ul>
<li><a href="rust-2024/../../rustdoc/write-documentation/documentation-tests.html">Doctests</a> are now combined into a single binary which should result in a significant performance improvement.</li>
</ul>
<h2 id="details-31"><a class="header" href="#details-31">Details</a></h2>
<p>Prior the the 2024 Edition, rustdoc's "test" mode would compile each code block in your documentation as a separate executable. Although this was relatively simple to implement, it resulted in a significant performance burden when there were a large number of documentation tests. Starting with the 2024 Edition, rustdoc will attempt to combine documentation tests into a single binary, significantly reducing the overhead for compiling doctests.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Adds two numbers
///
/// ```
/// assert_eq!(add(1, 1), 2);
/// ```
pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

/// Subtracts two numbers
///
/// ```
/// assert_eq!(subtract(2, 1), 1);
/// ```
pub fn subtract(left: u64, right: u64) -&gt; u64 {
    left - right
}
<span class="boring">}</span></code></pre></pre>
<p>In this example, the two doctests will now be compiled into a single executable. Rustdoc will essentially place each example in a separate function within a single binary. The tests still run in independent processes as they did before, so any global state (like global statics) should still continue to work correctly.<sup class="footnote-reference"><a href="#implementation">1</a></sup></p>
<p>This change is only available in the 2024 Edition to avoid potential incompatibilities with existing doctests which may not work in a combined executable. However, these incompatibilities are expected to be extremely rare.</p>
<div class="footnote-definition" id="implementation"><sup class="footnote-definition-label">1</sup>
<p>For more information on the details of how this work, see <a href="https://blog.guillaume-gomez.fr/articles/2024-08-17+Doctests+-+How+were+they+improved%3F">"Doctests - How were they improved?"</a>.</p>
</div>
<h3 id="standalone_crate-tag"><a class="header" href="#standalone_crate-tag"><code>standalone_crate</code> tag</a></h3>
<p>In some situations it is not possible for rustdoc to combine examples into a single executable. Rustdoc will attempt to automatically detect if this is not possible. For example, a test will not be combined with others if it:</p>
<ul>
<li>Uses the <a href="rust-2024/../../rustdoc/write-documentation/documentation-tests.html#attributes"><code>compile_fail</code></a> tag, which indicates that the example should fail to compile.</li>
<li>Uses an <a href="rust-2024/../../rustdoc/write-documentation/documentation-tests.html#attributes"><code>edition</code></a> tag, which indicates the edition of the example.<sup class="footnote-reference"><a href="#edition-tag">2</a></sup></li>
<li>Uses global attributes, like the <a href="rust-2024/../../std/alloc/trait.GlobalAlloc.html"><code>global_allocator</code></a> attribute, which could potentially interfere with other tests.</li>
<li>Defines any crate-wide attributes (like <code>#![feature(...)]</code>).</li>
<li>Defines a macro that uses <code>$crate</code>, because the <code>$crate</code> path will not work correctly.</li>
</ul>
<p>However, rustdoc is not able to automatically determine <em>all</em> situations where an example cannot be combined with other examples. In these situations, you can add the <code>standalone_crate</code> language tag to indicate that the example should be built as a separate executable. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! ```
//! let location = std::panic::Location::caller();
//! assert_eq!(location.line(), 5);
//! ```
<span class="boring">}</span></code></pre></pre>
<p>This is sensitive to the code structure of how the example is compiled and won't work with the "combined" approach because the line numbers will shift depending on how the doctests are combined. In these situations, you can add the <code>standalone_crate</code> tag to force the example to be built separately just as it was in previous editions. E.g.:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! ```standalone_crate
//! let location = std::panic::Location::caller();
//! assert_eq!(location.line(), 5);
//! ```
<span class="boring">}</span></code></pre></pre>
<div class="footnote-definition" id="edition-tag"><sup class="footnote-definition-label">2</sup>
<p>Note that rustdoc will only combine tests if the entire crate is Edition 2024 or greater. Using the <code>edition2024</code> tag in older editions will not result in those tests being combined.</p>
</div>
<h2 id="migration-28"><a class="header" href="#migration-28">Migration</a></h2>
<p>There is no automatic migration to determine which doctests need to be annotated with the <code>standalone_crate</code> tag. It's very unlikely that any given doctest will not work correctly when migrated. We suggest that you update your crate to the 2024 Edition and then run your documentation tests and see if any fail. If one does, you will need to analyze whether it can be rewritten to be compatible with the combined approach, or alternatively, add the <code>standalone_crate</code> tag to retain the previous behavior.</p>
<p>Some things to watch out for and avoid are:</p>
<ul>
<li>Checking the values of <a href="https://doc.rust-lang.org/std/panic/struct.Location.html"><code>std::panic::Location</code></a> or things that make use of <code>Location</code>. The location of the code is now different since multiple tests are now located in the same test crate.</li>
<li>Checking the value of <a href="https://doc.rust-lang.org/std/any/fn.type_name.html"><code>std::any::type_name</code></a>, which now has a different module path.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rustdoc-nested-include-change"><a class="header" href="#rustdoc-nested-include-change">Rustdoc nested <code>include!</code> change</a></h1>
<h2 id="summary-35"><a class="header" href="#summary-35">Summary</a></h2>
<p>When a doctest is included with <code>include_str!</code>, if that doctest itself also uses <code>include!</code>, <code>include_str!</code>, or <code>include_bytes!</code>, the path is resolved relative to the Markdown file, rather than to the Rust source file.</p>
<h2 id="details-32"><a class="header" href="#details-32">Details</a></h2>
<p>Prior to the 2024 edition, adding documentation with <code>#[doc=include_str!("path/file.md")]</code> didn't carry span information into any doctests in that file. As a result, if the Markdown file was in a different directory than the source, any paths included had to be specified relative to the source file.</p>
<p>For example, consider a library crate with these files:</p>
<ul>
<li><code>Cargo.toml</code></li>
<li><code>README.md</code></li>
<li><code>src/</code>
<ul>
<li><code>lib.rs</code></li>
</ul>
</li>
<li><code>examples/</code>
<ul>
<li><code>data.bin</code></li>
</ul>
</li>
</ul>
<p>Let's say that <code>lib.rs</code> contains this:</p>
<pre><code class="language-rust ignore">#![doc=include_str!("../README.md")]</code></pre>
<p>And assume this <code>README.md</code> file:</p>
<pre><code class="language-markdown">```
let _ = include_bytes!("../examples/data.bin");
//                      ^^^ notice this
```
</code></pre>
<p>Prior to the 2024 edition, the path in <code>README.md</code> needed to be relative to the <code>lib.rs</code> file. In 2024 and later, it is now relative to <code>README.md</code> itself, so we would update <code>README.md</code> to:</p>
<pre><code class="language-markdown">```
let _ = include_bytes!("examples/data.bin");
```
</code></pre>
<h2 id="migration-29"><a class="header" href="#migration-29">Migration</a></h2>
<p>There is no automatic migration to convert the paths in affected doctests. If one of your doctests is affected, you'll see an error like this after migrating to the new edition when building your tests:</p>
<pre><code class="language-text">error: couldn't read `../examples/data.bin`: No such file or directory (os error 2)
 --&gt; src/../README.md:2:24
  |
2 | let _ = include_bytes!("../examples/data.bin");
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  = note: this error originates in the macro `include_bytes` (in Nightly builds, run with -Z macro-backtrace for more info)
help: there is a file with the same name in a different directory
  |
2 | let _ = include_bytes!("examples/data.bin");
  |                        ~~~~~~~~~~~~~~~~~~~
</code></pre>
<p>To migrate your doctests to Rust 2024, update any affected paths to be relative to the file containing the doctests.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rustfmt"><a class="header" href="#rustfmt">Rustfmt</a></h1>
<p>The following chapters detail changes to Rustfmt in the 2024 Edition.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rustfmt-style-edition"><a class="header" href="#rustfmt-style-edition">Rustfmt: Style edition</a></h1>
<h2 id="summary-36"><a class="header" href="#summary-36">Summary</a></h2>
<p>User can now control which style edition to use with <code>rustfmt</code>.</p>
<h2 id="details-33"><a class="header" href="#details-33">Details</a></h2>
<p>The default formatting produced by Rustfmt is governed
by the rules in the <a href="rust-2024/../../style-guide/index.html">Rust Style Guide</a>.</p>
<p>Additionally, Rustfmt has a formatting stability guarantee that aims
to avoid causing noisy formatting churn for users when updating a
Rust toolchain. This stability guarantee essentially means that a newer
version of Rustfmt cannot modify the <em>successfully formatted</em> output
that was produced by a previous version of Rustfmt.</p>
<p>The combination of those two constraints had historically locked both
the Style Guide and the default formatting behavior in Rustfmt. This
impasse caused various challenges, such as preventing the ability to
iterate on style improvements, and requiring Rustfmt to maintain legacy
formatting quirks that were obviated long ago (e.g. nested tuple access).</p>
<p><a href="https://rust-lang.github.io/rfcs/3338-style-evolution.html">RFC 3338</a> resolved this impasse by establishing a mechanism for the
Rust Style Guide to be aligned to Rust's Edition model wherein the
Style Guide could evolve across Editions, and <code>rustfmt</code> would allow users
to specify their desired Edition of the Style Guide, referred to as the Style Edition.</p>
<p>In the 2024 Edition, <code>rustfmt</code> now supports the ability for users to control
the Style Edition used for formatting. The 2024 Edition of the Style Guide also
includes enhancements to the Style Guide which are detailed elsewhere in this Edition Guide.</p>
<p>By default <code>rustfmt</code> will use the same Style Edition as the standard Rust Edition
used for parsing, but the Style Edition can also be overridden and configured separately.</p>
<p>There are multiple ways to run <code>rustfmt</code> with the 2024 Style Edition:</p>
<p>With a <code>Cargo.toml</code> file that has <code>edition</code> set to <code>2024</code>, run:</p>
<pre><code class="language-sh">cargo fmt
</code></pre>
<p>Or run <code>rustfmt</code> directly with <code>2024</code> for the edition to use the 2024 edition
for both parsing and the 2024 edition of the Style Guide:</p>
<pre><code class="language-sh">rustfmt lib.rs --edition 2024
</code></pre>
<p>The style edition can also be set in a <code>rustfmt.toml</code> configuration file:</p>
<pre><code class="language-toml">style_edition = "2024"
</code></pre>
<p>Which is then used when running <code>rustfmt</code> directly:</p>
<pre><code class="language-sh">rustfmt lib.rs
</code></pre>
<p>Alternatively, the style edition can be specified directly from <code>rustfmt</code> options:</p>
<pre><code class="language-sh">rustfmt lib.rs --style-edition 2024
</code></pre>
<h2 id="migration-30"><a class="header" href="#migration-30">Migration</a></h2>
<p>Running <code>cargo fmt</code> or <code>rustfmt</code> with the 2024 edition or style edition will
automatically migrate formatting over to the 2024 style edition formatting.</p>
<p>Projects who have contributors that may utilize their editor's format-on-save
features are also strongly encouraged to add a <code>.rustfmt.toml</code> file to their project
that includes the corresponding <code>style_edition</code> utilized within their project, or to
encourage their users to ensure their local editor format-on-save feature is
configured to use that same <code>style_edition</code>.</p>
<p>This is to ensure that the editor format-on-save output is consistent with the
output when <code>cargo fmt</code> is manually executed by the developer, or the project's CI
process (many editors will run <code>rustfmt</code> directly which by default uses the 2015
edition, whereas <code>cargo fmt</code> uses the edition specified in the <code>Cargo.toml</code> file)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rustfmt-formatting-fixes"><a class="header" href="#rustfmt-formatting-fixes">Rustfmt: Formatting fixes</a></h1>
<h2 id="summary-37"><a class="header" href="#summary-37">Summary</a></h2>
<ul>
<li>Fixes to various formatting scenarios.</li>
</ul>
<h2 id="details-34"><a class="header" href="#details-34">Details</a></h2>
<p>The 2024 style edition introduces several fixes to various formatting scenarios.</p>
<h3 id="dont-align-unrelated-trailing-comments-after-items-or-at-the-end-of-blocks"><a class="header" href="#dont-align-unrelated-trailing-comments-after-items-or-at-the-end-of-blocks">Don't align unrelated trailing comments after items or at the end of blocks</a></h3>
<!--
https://github.com/rust-lang/rustfmt/pull/3833
-->
<p>Previously rustfmt would assume that a comment on a line following an item with a trailing comment should be indented to match the trailing comment. This has been changed so that those comments are not indented.</p>
<p><strong>Style edition 2021:</strong></p>
<pre><code class="language-rust ignore">pub const IFF_MULTICAST: ::c_int = 0x0000000800; // Supports multicast
                                                 // Multicast using broadcst. add.

pub const SQ_CRETAB: u16 = 0x000e; // CREATE TABLE
pub const SQ_DRPTAB: u16 = 0x000f; // DROP TABLE
pub const SQ_CREIDX: u16 = 0x0010; // CREATE INDEX
                                   //const SQ_DRPIDX: u16 = 0x0011; // DROP INDEX
                                   //const SQ_GRANT: u16 = 0x0012;  // GRANT
                                   //const SQ_REVOKE: u16 = 0x0013; // REVOKE

fn foo() {
    let f = bar(); // Donec consequat mi. Quisque vitae dolor. Integer lobortis. Maecenas id nulla. Lorem.
                   // Id turpis. Nam posuere lectus vitae nibh. Etiam tortor orci, sagittis
                   // malesuada, rhoncus quis, hendrerit eget, libero. Quisque commodo nulla at
    let b = baz();

    let normalized = self.ctfont.all_traits().normalized_weight(); // [-1.0, 1.0]
                                                                   // TODO(emilio): It may make sense to make this range [.01, 10.0], to align
                                                                   // with css-fonts-4's range of [1, 1000].
}</code></pre>
<p><strong>Style edition 2024:</strong></p>
<pre><code class="language-rust ignore">pub const IFF_MULTICAST: ::c_int = 0x0000000800; // Supports multicast
// Multicast using broadcst. add.

pub const SQ_CRETAB: u16 = 0x000e; // CREATE TABLE
pub const SQ_DRPTAB: u16 = 0x000f; // DROP TABLE
pub const SQ_CREIDX: u16 = 0x0010; // CREATE INDEX
//const SQ_DRPIDX: u16 = 0x0011; // DROP INDEX
//const SQ_GRANT: u16 = 0x0012;  // GRANT
//const SQ_REVOKE: u16 = 0x0013; // REVOKE

fn foo() {
    let f = bar(); // Donec consequat mi. Quisque vitae dolor. Integer lobortis. Maecenas id nulla. Lorem.
    // Id turpis. Nam posuere lectus vitae nibh. Etiam tortor orci, sagittis
    // malesuada, rhoncus quis, hendrerit eget, libero. Quisque commodo nulla at
    let b = baz();

    let normalized = self.ctfont.all_traits().normalized_weight(); // [-1.0, 1.0]
    // TODO(emilio): It may make sense to make this range [.01, 10.0], to align
    // with css-fonts-4's range of [1, 1000].
}</code></pre>
<h3 id="dont-indent-strings-in-comments"><a class="header" href="#dont-indent-strings-in-comments">Don't indent strings in comments</a></h3>
<!--
https://github.com/rust-lang/rustfmt/pull/3284

https://github.com/rust-lang/rustfmt/pull/3326 -- Fixes this in macros.

NOTE: This also claims to change other things (such as idempotency), but that seems like it was independently fixed in previous versions.
-->
<p>Previously rustfmt would incorrectly attempt to format strings in comments.</p>
<p><strong>Original:</strong></p>
<pre><code class="language-rust ignore">pub fn main() {
    /*   let s = String::from(
        "
hello
world
",
    ); */
}</code></pre>
<p><strong>Style edition 2021:</strong></p>
<pre><code class="language-rust ignore">pub fn main() {
    /*   let s = String::from(
            "
    hello
    world
    ",
        ); */
}</code></pre>
<p><strong>Style edition 2024:</strong></p>
<p>No change from original.</p>
<h3 id="long-strings-dont-prevent-formatting-expressions"><a class="header" href="#long-strings-dont-prevent-formatting-expressions">Long strings don't prevent formatting expressions</a></h3>
<!--
https://github.com/rust-lang/rustfmt/issues/5577#issuecomment-1331628360
https://github.com/rust-lang/rustfmt/issues/4800
-->
<p>In some situations, long strings would previously prevent the expression from being formatted.</p>
<p><strong>Style edition 2021:</strong></p>
<pre><code class="language-rust ignore">fn main() {
    let value = if x == "Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum." { 0 } else {10};

    let x = Testing {
              foo: "long_long_long_long_long_long_long_lo_long_long_long_long_long_long__long_long_long_long_long_long_",
bar: "long_long_long_long_long_long_long_long_long_long_lo_long_long_lolong_long_long_lo_long_long_lolong_long_long_lo_long_long_lo",
};
}</code></pre>
<p><strong>Style edition 2024:</strong></p>
<pre><code class="language-rust ignore">fn main() {
    let value = if x
        == "Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum."
    {
        0
    } else {
        10
    };

    let x = Testing {
        foo: "long_long_long_long_long_long_long_lo_long_long_long_long_long_long__long_long_long_long_long_long_",
        bar: "long_long_long_long_long_long_long_long_long_long_lo_long_long_lolong_long_long_lo_long_long_lolong_long_long_lo_long_long_lo",
    };
}</code></pre>
<h3 id="fixed-indentation-of-generics-in-impl-blocks"><a class="header" href="#fixed-indentation-of-generics-in-impl-blocks">Fixed indentation of generics in impl blocks</a></h3>
<!--
https://github.com/rust-lang/rustfmt/pull/3856
-->
<p>Generics in <code>impl</code> items had excessive indentation.</p>
<p><strong>Style edition 2021:</strong></p>
<pre><code class="language-rust ignore">impl&lt;
        Target: FromEvent&lt;A&gt; + FromEvent&lt;B&gt;,
        A: Widget2&lt;Ctx = C&gt;,
        B: Widget2&lt;Ctx = C&gt;,
        C: for&lt;'a&gt; CtxFamily&lt;'a&gt;,
    &gt; Widget2 for WidgetEventLifter&lt;Target, A, B&gt;
{
    type Ctx = C;
    type Event = Vec&lt;Target&gt;;
}</code></pre>
<p><strong>Style edition 2024:</strong></p>
<pre><code class="language-rust ignore">impl&lt;
    Target: FromEvent&lt;A&gt; + FromEvent&lt;B&gt;,
    A: Widget2&lt;Ctx = C&gt;,
    B: Widget2&lt;Ctx = C&gt;,
    C: for&lt;'a&gt; CtxFamily&lt;'a&gt;,
&gt; Widget2 for WidgetEventLifter&lt;Target, A, B&gt;
{
    type Ctx = C;
    type Event = Vec&lt;Target&gt;;
}</code></pre>
<h3 id="use-correct-indentation-when-formatting-a-complex-fn"><a class="header" href="#use-correct-indentation-when-formatting-a-complex-fn">Use correct indentation when formatting a complex <code>fn</code></a></h3>
<!--
https://github.com/rust-lang/rustfmt/pull/3731
-->
<p>In some cases, a complex <code>fn</code> signature could end up with an unusual indentation that is now fixed.</p>
<p><strong>Style edition 2021:</strong></p>
<pre><code class="language-rust ignore">fn build_sorted_static_get_entry_names(
    mut entries: Vec&lt;(u8, &amp;'static str)&gt;,
) -&gt; (impl Fn(
    AlphabeticalTraversal,
    Box&lt;dyn dirents_sink::Sink&lt;AlphabeticalTraversal&gt;&gt;,
) -&gt; BoxFuture&lt;'static, Result&lt;Box&lt;dyn dirents_sink::Sealed&gt;, Status&gt;&gt;
        + Send
        + Sync
        + 'static) {
}</code></pre>
<p><strong>Style edition 2024:</strong></p>
<pre><code class="language-rust ignore">fn build_sorted_static_get_entry_names(
    mut entries: Vec&lt;(u8, &amp;'static str)&gt;,
) -&gt; (
    impl Fn(
        AlphabeticalTraversal,
        Box&lt;dyn dirents_sink::Sink&lt;AlphabeticalTraversal&gt;&gt;,
    ) -&gt; BoxFuture&lt;'static, Result&lt;Box&lt;dyn dirents_sink::Sealed&gt;, Status&gt;&gt;
    + Send
    + Sync
    + 'static
) {
}</code></pre>
<h3 id="avoid-extra-space-in-nested-tuple-indexing-expression"><a class="header" href="#avoid-extra-space-in-nested-tuple-indexing-expression">Avoid extra space in nested tuple indexing expression</a></h3>
<!--
https://github.com/rust-lang/rustfmt/pull/4503
-->
<p>Nested tuple indexing expressions would incorrectly include an extra space.</p>
<p><strong>Style edition 2021:</strong></p>
<pre><code class="language-rust ignore">fn main() {
    let _ = ((1,),).0 .0;
}</code></pre>
<p><strong>Style edition 2024:</strong></p>
<pre><code class="language-rust ignore">fn main() {
    let _ = ((1,),).0.0;
}</code></pre>
<h3 id="end-returnbreakcontinue-inside-a-block-in-a-match-with-a-semicolon"><a class="header" href="#end-returnbreakcontinue-inside-a-block-in-a-match-with-a-semicolon">End return/break/continue inside a block in a match with a semicolon</a></h3>
<!--
https://github.com/rust-lang/rustfmt/pull/3223
https://github.com/rust-lang/rustfmt/pull/3250
-->
<p>A <code>return</code>, <code>break</code>, or <code>continue</code> inside a block in a match arm was incorrectly missing a semicolon.</p>
<p><strong>Style edition 2021:</strong></p>
<pre><code class="language-rust ignore">fn foo() {
    match 0 {
        0 =&gt; {
            return AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        }
        _ =&gt; "",
    };
}</code></pre>
<p><strong>Style edition 2024:</strong></p>
<pre><code class="language-rust ignore">fn foo() {
    match 0 {
        0 =&gt; {
            return AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
        }
        _ =&gt; "",
    };
}</code></pre>
<h3 id="long-array-and-slice-patterns-are-now-wrapped"><a class="header" href="#long-array-and-slice-patterns-are-now-wrapped">Long array and slice patterns are now wrapped</a></h3>
<!--
https://github.com/rust-lang/rustfmt/pull/4994
-->
<p>Long array and slice patterns were not getting wrapped properly.</p>
<p><strong>Style edition 2021:</strong></p>
<pre><code class="language-rust ignore">fn main() {
    let [aaaaaaaaaaaaaaaaaaaaaaaaaa, bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb, cccccccccccccccccccccccccc, ddddddddddddddddddddddddd] =
        panic!();
}</code></pre>
<p><strong>Style edition 2024:</strong></p>
<pre><code class="language-rust ignore">fn main() {
    let [
        aaaaaaaaaaaaaaaaaaaaaaaaaa,
        bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb,
        cccccccccccccccccccccccccc,
        ddddddddddddddddddddddddd,
    ] = panic!();
}</code></pre>
<h3 id="format-the-last-expression-statement-as-an-expression"><a class="header" href="#format-the-last-expression-statement-as-an-expression">Format the last expression-statement as an expression</a></h3>
<!--
https://github.com/rust-lang/rustfmt/pull/3631
https://github.com/rust-lang/rustfmt/pull/3338
-->
<p>The last statement in a block which is an expression is now formatted as an expression.</p>
<p><strong>Style edition 2021:</strong></p>
<pre><code class="language-rust ignore">fn main() {
    let toto = || {
        if true {
            42
        } else {
            24
        }
    };

    {
        T
    }
}</code></pre>
<p><strong>Style edition 2024:</strong></p>
<pre><code class="language-rust ignore">fn main() {
    let toto = || {
        if true { 42 } else { 24 }
    };

    { T }
}</code></pre>
<h3 id="same-formatting-between-function-and-macro-calls"><a class="header" href="#same-formatting-between-function-and-macro-calls">Same formatting between function and macro calls</a></h3>
<!--
https://github.com/rust-lang/rustfmt/pull/3298
-->
<p>Some formatting is now the same in a macro invocation as it is in a function call.</p>
<p><strong>Style edition 2021:</strong></p>
<pre><code class="language-rust ignore">fn main() {
    macro_call!(HAYSTACK
        .par_iter()
        .find_any(|&amp;&amp;x| x[0] % 1000 == 999)
        .is_some());

    fn_call(
        HAYSTACK
            .par_iter()
            .find_any(|&amp;&amp;x| x[0] % 1000 == 999)
            .is_some(),
    );
}</code></pre>
<p><strong>Style edition 2024:</strong></p>
<pre><code class="language-rust ignore">fn main() {
    macro_call!(
        HAYSTACK
            .par_iter()
            .find_any(|&amp;&amp;x| x[0] % 1000 == 999)
            .is_some()
    );

    fn_call(
        HAYSTACK
            .par_iter()
            .find_any(|&amp;&amp;x| x[0] % 1000 == 999)
            .is_some(),
    );
}</code></pre>
<h3 id="force-block-closures-for-closures-with-a-single-loop-body"><a class="header" href="#force-block-closures-for-closures-with-a-single-loop-body">Force block closures for closures with a single loop body</a></h3>
<!--
https://github.com/rust-lang/rustfmt/pull/3334
-->
<p>Closures with a single loop are now formatted as a block expression.</p>
<p><strong>Style edition 2021:</strong></p>
<pre><code class="language-rust ignore">fn main() {
    thread::spawn(|| loop {
        println!("iteration");
    });
}</code></pre>
<p><strong>Style edition 2024:</strong></p>
<pre><code class="language-rust ignore">fn main() {
    thread::spawn(|| {
        loop {
            println!("iteration");
        }
    });
}</code></pre>
<h3 id="empty-lines-in-where-clauses-are-now-removed"><a class="header" href="#empty-lines-in-where-clauses-are-now-removed">Empty lines in where clauses are now removed</a></h3>
<!--
https://github.com/rust-lang/rustfmt/pull/5867
-->
<p>Empty lines in a <code>where</code> clause are now removed.</p>
<p><strong>Style edition 2021:</strong></p>
<pre><code class="language-rust ignore">fn foo&lt;T&gt;(_: T)
where
    T: std::fmt::Debug,

    T: std::fmt::Display,
{
}</code></pre>
<p><strong>Style edition 2024:</strong></p>
<pre><code class="language-rust ignore">fn foo&lt;T&gt;(_: T)
where
    T: std::fmt::Debug,
    T: std::fmt::Display,
{
}</code></pre>
<h3 id="fixed-formatting-of-a-let-else-statement-with-an-attribute"><a class="header" href="#fixed-formatting-of-a-let-else-statement-with-an-attribute">Fixed formatting of a let-else statement with an attribute</a></h3>
<!--
https://github.com/rust-lang/rustfmt/pull/5902
-->
<p>If a let-else statement had an attribute, then it would cause the <code>else</code> clause to incorrectly wrap the <code>else</code> part separately.</p>
<p><strong>Style edition 2021:</strong></p>
<pre><code class="language-rust ignore">fn main() {
    #[cfg(target_os = "linux")]
    let x = 42
    else {
        todo!()
    };

    // This is the same without an attribute.
    let x = 42 else { todo!() };
}</code></pre>
<p><strong>Style edition 2024:</strong></p>
<pre><code class="language-rust ignore">fn main() {
    #[cfg(target_os = "linux")]
    let x = 42 else { todo!() };

    // This is the same without an attribute.
    let x = 42 else { todo!() };
}</code></pre>
<h3 id="off-by-one-error-for-wrapping-enum-variant-doc-comments"><a class="header" href="#off-by-one-error-for-wrapping-enum-variant-doc-comments">Off-by-one error for wrapping enum variant doc comments</a></h3>
<!--
https://github.com/rust-lang/rustfmt/pull/6000
-->
<p>When using the <code>wrap_comments</code> feature, the comments were being wrapped at a column width off-by-one.</p>
<p><strong>Original:</strong></p>
<pre><code class="language-rust ignore">pub enum Severity {
    /// But here, this comment is 120 columns wide and the formatter wants to split it up onto two separate lines still.
    Error,
    /// This comment is 119 columns wide and works perfectly. Lorem ipsum. lorem ipsum. lorem ipsum. lorem ipsum lorem.
    Warning,
}</code></pre>
<p><strong>Style edition 2021:</strong></p>
<pre><code class="language-rust ignore">pub enum Severity {
    /// But here, this comment is 120 columns wide and the formatter wants to split it up onto two separate lines
    /// still.
    Error,
    /// This comment is 119 columns wide and works perfectly. Lorem ipsum. lorem ipsum. lorem ipsum. lorem ipsum lorem.
    Warning,
}</code></pre>
<p><strong>Style edition 2024:</strong></p>
<pre><code class="language-rust ignore">pub enum Severity {
    /// But here, this comment is 120 columns wide and the formatter wants to split it up onto two separate lines still.
    Error,
    /// This comment is 119 columns wide and works perfectly. Lorem ipsum. lorem ipsum. lorem ipsum. lorem ipsum lorem.
    Warning,
}</code></pre>
<h3 id="off-by-one-error-for-format_macro_matchers"><a class="header" href="#off-by-one-error-for-format_macro_matchers">Off-by-one error for <code>format_macro_matchers</code></a></h3>
<!--
https://github.com/rust-lang/rustfmt/pull/5582
-->
<p>When using the <code>format_macro_matchers</code> feature, the matcher was being wrapped at a column width off-by-one.</p>
<p><strong>Style edition 2021:</strong></p>
<pre><code class="language-rust ignore">macro_rules! test {
    ($aasdfghj:expr, $qwertyuiop:expr, $zxcvbnmasdfghjkl:expr, $aeiouaeiouaeio:expr, $add:expr) =&gt; {{
        return;
    }};
}</code></pre>
<p><strong>Style edition 2024:</strong></p>
<pre><code class="language-rust ignore">macro_rules! test {
    (
        $aasdfghj:expr, $qwertyuiop:expr, $zxcvbnmasdfghjkl:expr, $aeiouaeiouaeio:expr, $add:expr
    ) =&gt; {{
        return;
    }};
}</code></pre>
<h3 id="fixed-failure-with--in-comment-after-match-"><a class="header" href="#fixed-failure-with--in-comment-after-match-">Fixed failure with <code>=&gt;</code> in comment after match <code>=&gt;</code></a></h3>
<!--
https://github.com/rust-lang/rustfmt/pull/6092
-->
<p>In certain circumstances if a comment contained a <code>=&gt;</code> after the <code>=&gt;</code> in a match expression, this would cause a failure to format correctly.</p>
<p><strong>Style edition 2021:</strong></p>
<pre><code class="language-rust ignore">fn main() {
    match a {
        _ =&gt;
        // comment with =&gt;
                {
            println!("A")
        }
    }
}</code></pre>
<p><strong>Style edition 2024:</strong></p>
<pre><code class="language-rust ignore">fn main() {
    match a {
        _ =&gt;
        // comment with =&gt;
        {
            println!("A")
        }
    }
}</code></pre>
<h3 id="multiple-inner-attributes-in-a-match-expression-indented-incorrectly"><a class="header" href="#multiple-inner-attributes-in-a-match-expression-indented-incorrectly">Multiple inner attributes in a match expression indented incorrectly</a></h3>
<!--
https://github.com/rust-lang/rustfmt/pull/6148
-->
<p>Multiple inner attributes in a match expression were being indented incorrectly.</p>
<p><strong>Style edition 2021:</strong></p>
<pre><code class="language-rust ignore">pub fn main() {
    match a {
        #![attr1]
    #![attr2]
        _ =&gt; None,
    }
}</code></pre>
<p><strong>Style edition 2024:</strong></p>
<pre><code class="language-rust ignore">pub fn main() {
    match a {
        #![attr1]
        #![attr2]
        _ =&gt; None,
    }
}</code></pre>
<h2 id="migration-31"><a class="header" href="#migration-31">Migration</a></h2>
<p>The change can be applied automatically by running <code>cargo fmt</code> or <code>rustfmt</code> with the 2024 Edition. See the <a href="rust-2024/rustfmt-style-edition.html">Style edition</a> chapter for more information on migrating and how style editions work.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rustfmt-raw-identifier-sorting"><a class="header" href="#rustfmt-raw-identifier-sorting">Rustfmt: Raw identifier sorting</a></h1>
<h2 id="summary-38"><a class="header" href="#summary-38">Summary</a></h2>
<p><code>rustfmt</code> now properly sorts <a href="rust-2024/../../reference/identifiers.html#raw-identifiers">raw identifiers</a>.</p>
<h2 id="details-35"><a class="header" href="#details-35">Details</a></h2>
<p>The <a href="rust-2024/../../style-guide/index.html">Rust Style Guide</a> includes <a href="rust-2024/../../style-guide/index.html#sorting">rules for sorting</a> that <code>rustfmt</code> applies in various contexts, such as on imports.</p>
<p>Prior to the 2024 Edition, when sorting rustfmt would use the leading <code>r#</code> token instead of the ident which led to unwanted results. For example:</p>
<pre><code class="language-rust ignore">use websocket::client::ClientBuilder;
use websocket::r#async::futures::Stream;
use websocket::result::WebSocketError;</code></pre>
<p>In the 2024 Edition, <code>rustfmt</code> now produces:</p>
<pre><code class="language-rust ignore">use websocket::r#async::futures::Stream;
use websocket::client::ClientBuilder;
use websocket::result::WebSocketError;</code></pre>
<h2 id="migration-32"><a class="header" href="#migration-32">Migration</a></h2>
<p>The change can be applied automatically by running <code>cargo fmt</code> or <code>rustfmt</code> with the 2024 Edition. See the <a href="rust-2024/rustfmt-style-edition.html">Style edition</a> chapter for more information on migrating and how style editions work.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rustfmt-version-sorting"><a class="header" href="#rustfmt-version-sorting">Rustfmt: Version sorting</a></h1>
<h2 id="summary-39"><a class="header" href="#summary-39">Summary</a></h2>
<p><code>rustfmt</code> utilizes a new sorting algorithm.</p>
<h2 id="details-36"><a class="header" href="#details-36">Details</a></h2>
<p>The <a href="rust-2024/../../style-guide/index.html">Rust Style Guide</a> includes <a href="rust-2024/../../style-guide/index.html#sorting">rules for sorting</a> that <code>rustfmt</code> applies in various contexts, such as on imports.</p>
<p>Previous versions of the Style Guide and Rustfmt generally used an "ASCIIbetical" based approach. In the 2024 Edition this is changed to use a version-sort like algorithm that compares Unicode characters lexicographically and provides better results in ASCII digit comparisons.</p>
<p>For example with a given (unsorted) input:</p>
<pre><code class="language-rust ignore">use std::num::{NonZeroU32, NonZeroU16, NonZeroU8, NonZeroU64};
use std::io::{Write, Read, stdout, self};</code></pre>
<p>In the prior Editions, <code>rustfmt</code> would have produced:</p>
<pre><code class="language-rust ignore">use std::io::{self, stdout, Read, Write};
use std::num::{NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8};</code></pre>
<p>In the 2024 Edition, <code>rustfmt</code> now produces:</p>
<pre><code class="language-rust ignore">use std::io::{self, Read, Write, stdout};
use std::num::{NonZeroU8, NonZeroU16, NonZeroU32, NonZeroU64};</code></pre>
<h2 id="migration-33"><a class="header" href="#migration-33">Migration</a></h2>
<p>The change can be applied automatically by running <code>cargo fmt</code> or <code>rustfmt</code> with the 2024 Edition. See the <a href="rust-2024/rustfmt-style-edition.html">Style edition</a> chapter for more information on migrating and how style editions work.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/language-picker.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
