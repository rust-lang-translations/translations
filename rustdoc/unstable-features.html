<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Unstable features - The rustdoc book</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/rustdoc";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/unstable-features.md`;
                    } else {
                        canonical_href = `${base}/${lang}/unstable-features.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("en");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The rustdoc book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="unstable-features"><a class="header" href="#unstable-features">Unstable features</a></h1>
<p>Rustdoc is under active development, and like the Rust compiler, some features are only available
on nightly releases. Some of these features are new and need some more testing before they're able to be
released to the world at large, and some of them are tied to features in the Rust compiler that are unstable. Several features here require a matching <code>#![feature(...)]</code> attribute to
enable, and thus are more fully documented in the <a href="../unstable-book/index.html">Unstable Book</a>. Those sections will link over
there as necessary.</p>
<h2 id="nightly-gated-functionality"><a class="header" href="#nightly-gated-functionality">Nightly-gated functionality</a></h2>
<p>These features just require a nightly build to operate. Unlike the other features on this page,
these don't need to be "turned on" with a command-line flag or a <code>#![feature(...)]</code> attribute in
your crate. This can give them some subtle fallback modes when used on a stable release, so be
careful!</p>
<h3 id="error-numbers-for-compile-fail-doctests"><a class="header" href="#error-numbers-for-compile-fail-doctests">Error numbers for <code>compile-fail</code> doctests</a></h3>
<p>As detailed in <a href="write-documentation/documentation-tests.html#attributes">the chapter on documentation tests</a>, you can add a
<code>compile_fail</code> attribute to a doctest to state that the test should fail to compile. However, on
nightly, you can optionally add an error number to state that a doctest should emit a specific error
number:</p>
<pre><code class="language-markdown">```compile_fail,E0044
extern { fn some_func&lt;T&gt;(x: T); }
```
</code></pre>
<p>This is used by the error index to ensure that the samples that correspond to a given error number
properly emit that error code. However, these error codes aren't guaranteed to be the only thing
that a piece of code emits from version to version, so this is unlikely to be stabilized in the
future.</p>
<p>Attempting to use these error numbers on stable will result in the code sample being interpreted as
plain text.</p>
<h3 id="missing_doc_code_examples-lint"><a class="header" href="#missing_doc_code_examples-lint"><code>missing_doc_code_examples</code> lint</a></h3>
<p>This lint will emit a warning if an item doesn't have a code example in its documentation.
It can be enabled using:</p>
<pre><code class="language-rust ignore (nightly)">#![deny(rustdoc::missing_doc_code_examples)]</code></pre>
<p>It is not emitted for items that cannot be instantiated/called such as fields, variants, modules,
associated trait/impl items, impl blocks, statics and constants.
It is also not emitted for foreign items, aliases, extern crates and imports.</p>
<h2 id="extensions-to-the-doc-attribute"><a class="header" href="#extensions-to-the-doc-attribute">Extensions to the <code>#[doc]</code> attribute</a></h2>
<p>These features operate by extending the <code>#[doc]</code> attribute, and thus can be caught by the compiler
and enabled with a <code>#![feature(...)]</code> attribute in your crate.</p>
<h3 id="adding-your-trait-to-the-notable-traits-dialog"><a class="header" href="#adding-your-trait-to-the-notable-traits-dialog">Adding your trait to the "Notable traits" dialog</a></h3>
<ul>
<li>Tracking issue: <a href="https://github.com/rust-lang/rust/issues/45040">#45040</a></li>
</ul>
<p>Rustdoc keeps a list of a few traits that are believed to be "fundamental" to
types that implement them. These traits are intended to be the primary interface
for their implementers, and are often most of the API available to be documented
on their types. For this reason, Rustdoc will track when a given type implements
one of these traits and call special attention to it when a function returns one
of these types. This is the "Notable traits" dialog, accessible as a circled <code>i</code>
button next to the function, which, when clicked, shows the dialog.</p>
<p>In the standard library, some of the traits that are part of this list are
<code>Iterator</code>, <code>Future</code>, <code>io::Read</code>, and <code>io::Write</code>. However, rather than being
implemented as a hard-coded list, these traits have a special marker attribute
on them: <code>#[doc(notable_trait)]</code>. This means that you can apply this attribute
to your own trait to include it in the "Notable traits" dialog in documentation.</p>
<p>The <code>#[doc(notable_trait)]</code> attribute currently requires the <code>#![feature(doc_notable_trait)]</code>
feature gate. For more information, see <a href="../unstable-book/language-features/doc-notable-trait.html">its chapter in the Unstable Book</a>
and <a href="https://github.com/rust-lang/rust/issues/45040">its tracking issue</a>.</p>
<h3 id="exclude-certain-dependencies-from-documentation"><a class="header" href="#exclude-certain-dependencies-from-documentation">Exclude certain dependencies from documentation</a></h3>
<ul>
<li>Tracking issue: <a href="https://github.com/rust-lang/rust/issues/44027">#44027</a></li>
</ul>
<p>The standard library uses several dependencies which, in turn, use several types and traits from the
standard library. In addition, there are several compiler-internal crates that are not considered to
be part of the official standard library, and thus would be a distraction to include in
documentation. It's not enough to exclude their crate documentation, since information about trait
implementations appears on the pages for both the type and the trait, which can be in different
crates!</p>
<p>To prevent internal types from being included in documentation, the standard library adds an
attribute to their <code>extern crate</code> declarations: <code>#[doc(masked)]</code>. This causes Rustdoc to "mask out"
types from these crates when building lists of trait implementations.</p>
<p>The <code>#[doc(masked)]</code> attribute is intended to be used internally, and requires the
<code>#![feature(doc_masked)]</code> feature gate.  For more information, see <a href="../unstable-book/language-features/doc-masked.html">its chapter in the Unstable
Book</a> and <a href="https://github.com/rust-lang/rust/issues/44027">its tracking issue</a>.</p>
<h3 id="document-primitives"><a class="header" href="#document-primitives">Document primitives</a></h3>
<p>This is for Rust compiler internal use only.</p>
<p>Since primitive types are defined in the compiler, there's no place to attach documentation
attributes. The <code>#[rustc_doc_primitive = "..."]</code> attribute is used by the standard library to
provide a way to generate documentation for primitive types, and requires <code>#![feature(rustc_attrs)]</code>
to enable.</p>
<h3 id="document-keywords"><a class="header" href="#document-keywords">Document keywords</a></h3>
<p>This is for internal use in the std library.</p>
<p>Rust keywords are documented in the standard library (look for <code>match</code> for example).</p>
<p>To do so, the <code>#[doc(keyword = "...")]</code> attribute is used. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(rustdoc_internals)]
#![allow(internal_features)]

<span class="boring">fn main() {
</span>/// Some documentation about the keyword.
#[doc(keyword = "break")]
mod empty_mod {}
<span class="boring">}</span></code></pre></pre>
<h3 id="document-builtin-attributes"><a class="header" href="#document-builtin-attributes">Document builtin attributes</a></h3>
<p>This is for internal use in the std library.</p>
<p>Rust builtin attributes are documented in the standard library (look for <code>repr</code> for example).</p>
<p>To do so, the <code>#[doc(attribute = "...")]</code> attribute is used. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(rustdoc_internals)]
#![allow(internal_features)]

<span class="boring">fn main() {
</span>/// Some documentation about the attribute.
#[doc(attribute = "repr")]
mod empty_mod {}
<span class="boring">}</span></code></pre></pre>
<h3 id="use-the-rust-logo-as-the-crate-logo"><a class="header" href="#use-the-rust-logo-as-the-crate-logo">Use the Rust logo as the crate logo</a></h3>
<p>This is for official Rust project use only.</p>
<p>Internal Rustdoc pages like settings.html and scrape-examples-help.html show the Rust logo.
This logo is tracked as a static resource. The attribute <code>#![doc(rust_logo)]</code> makes this same
built-in resource act as the main logo.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(rustdoc_internals)]
#![allow(internal_features)]
#![doc(rust_logo)]
<span class="boring">fn main() {
</span>//! This crate has the Rust(tm) branding on it.
<span class="boring">}</span></code></pre></pre>
<h2 id="effects-of-other-nightly-features"><a class="header" href="#effects-of-other-nightly-features">Effects of other nightly features</a></h2>
<p>These nightly-only features are not primarily related to Rustdoc,
but have convenient effects on the documentation produced.</p>
<h3 id="fundamental-types"><a class="header" href="#fundamental-types"><code>fundamental</code> types</a></h3>
<p>Annotating a type with <code>#[fundamental]</code> primarily influences coherence rules about generic types,
i.e., they alter whether other crates can provide implementations for that type.
The unstable book <a href="https://doc.rust-lang.org/unstable-book/language-features/fundamental.html">links to further information</a>.</p>
<p>For documentation, this has an additional side effect:
If a method is implemented on <code>F&lt;T&gt;</code> (or <code>F&lt;&amp;T&gt;</code>),
where <code>F</code> is a fundamental type,
then the method is not only documented at the page about <code>F</code>,
but also on the page about <code>T</code>.
In a sense, it makes the type transparent to Rustdoc.
This is especially convenient for types that work as annotated pointers,
such as <code>Pin&lt;&amp;mut T&gt;</code>,
as it ensures that methods only implemented through those annotated pointers
can still be found with the type they act on.</p>
<p>If the <code>fundamental</code> feature's effect on coherence is not intended,
such a type can be marked as fundamental only for purposes of documentation
by introducing a custom feature and
limiting the use of <code>fundamental</code> to when documentation is built.</p>
<h2 id="unstable-command-line-arguments"><a class="header" href="#unstable-command-line-arguments">Unstable command-line arguments</a></h2>
<p>These features are enabled by passing a command-line flag to Rustdoc, but the flags in question are
themselves marked as unstable. To use any of these options, pass <code>-Z unstable-options</code> as well as
the flag in question to Rustdoc on the command-line. To do this from Cargo, you can either use the
<code>RUSTDOCFLAGS</code> environment variable or the <code>cargo rustdoc</code> command.</p>
<h3 id="--merge---parts-out-dir-and---include-parts-dir"><a class="header" href="#--merge---parts-out-dir-and---include-parts-dir"><code>--merge</code>, <code>--parts-out-dir</code>, and <code>--include-parts-dir</code></a></h3>
<p>These options control how rustdoc handles files that combine data from multiple crates.</p>
<p>By default, they act like <code>--merge=shared</code> is set, and <code>--parts-out-dir</code> and <code>--include-parts-dir</code>
are turned off. The <code>--merge=shared</code> mode causes rustdoc to load the existing data in the out-dir,
combine the new crate data into it, and write the result. This is very easy to use in scripts that
manually invoke rustdoc, but it's also slow, because it performs O(crates) work on
every crate, meaning it performs O(crates<sup>2</sup>) work.</p>
<pre><code class="language-console">$ rustdoc crate1.rs --out-dir=doc
$ cat doc/search.index/crateNames/*
rd_("fcrate1")
$ rustdoc crate2.rs --out-dir=doc
$ cat doc/search.index/crateNames/*
rd_("fcrate1fcrate2")
</code></pre>
<p>To delay shared-data merging until the end of a build, so that you only have to perform O(crates)
work, use <code>--merge=none</code> on every crate except the last one, which will use <code>--merge=finalize</code>.</p>
<pre><code class="language-console">$ rustdoc +nightly crate1.rs --merge=none --parts-out-dir=crate1.d -Zunstable-options
$ cat doc/search.index/crateNames/*
cat: 'doc/search.index/crateNames/*': No such file or directory
$ rustdoc +nightly crate2.rs --merge=finalize --include-parts-dir=crate1.d -Zunstable-options
$ cat doc/search.index/crateNames/*
rd_("fcrate1fcrate2")
</code></pre>
<h3 id="--document-hidden-items-show-items-that-are-dochidden"><a class="header" href="#--document-hidden-items-show-items-that-are-dochidden"><code>--document-hidden-items</code>: Show items that are <code>#[doc(hidden)]</code></a></h3>
<p><span id="document-hidden-items"></span></p>
<p>By default, <code>rustdoc</code> does not document items that are annotated with
<a href="write-documentation/the-doc-attribute.html#hidden"><code>#[doc(hidden)]</code></a>.</p>
<p><code>--document-hidden-items</code> causes all items to be documented as if they did not have <code>#[doc(hidden)]</code>, except that hidden items will be shown with a ðŸ‘» icon.</p>
<p>Here is a table that fully describes which items are documented with each combination of <code>--document-hidden-items</code> and <code>--document-private-items</code>:</p>
<div class="table-wrapper"><table><thead><tr><th>rustdoc flags</th><th>items that will be documented</th></tr></thead><tbody>
<tr><td>neither flag</td><td>only public items that are not hidden</td></tr>
<tr><td>only <code>--document-hidden-items</code></td><td>all public items</td></tr>
<tr><td>only <code>--document-private-items</code></td><td>all items that are not hidden</td></tr>
<tr><td>both flags</td><td>all items</td></tr>
</tbody></table>
</div>
<h3 id="--markdown-before-content-include-rendered-markdown-before-the-content"><a class="header" href="#--markdown-before-content-include-rendered-markdown-before-the-content"><code>--markdown-before-content</code>: include rendered Markdown before the content</a></h3>
<ul>
<li>Tracking issue: <a href="https://github.com/rust-lang/rust/issues/44027">#44027</a></li>
</ul>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs -Z unstable-options --markdown-before-content extra.md
$ rustdoc README.md -Z unstable-options --markdown-before-content extra.md
</code></pre>
<p>Just like <code>--html-before-content</code>, this allows you to insert extra content inside the <code>&lt;body&gt;</code> tag
but before the other content <code>rustdoc</code> would normally produce in the rendered documentation.
However, instead of directly inserting the file verbatim, <code>rustdoc</code> will pass the files through a
Markdown renderer before inserting the result into the file.</p>
<h3 id="--markdown-after-content-include-rendered-markdown-after-the-content"><a class="header" href="#--markdown-after-content-include-rendered-markdown-after-the-content"><code>--markdown-after-content</code>: include rendered Markdown after the content</a></h3>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs -Z unstable-options --markdown-after-content extra.md
$ rustdoc README.md -Z unstable-options --markdown-after-content extra.md
</code></pre>
<p>Just like <code>--html-after-content</code>, this allows you to insert extra content before the <code>&lt;/body&gt;</code> tag
but after the other content <code>rustdoc</code> would normally produce in the rendered documentation.
However, instead of directly inserting the file verbatim, <code>rustdoc</code> will pass the files through a
Markdown renderer before inserting the result into the file.</p>
<h3 id="--playground-url-control-the-location-of-the-playground"><a class="header" href="#--playground-url-control-the-location-of-the-playground"><code>--playground-url</code>: control the location of the playground</a></h3>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs -Z unstable-options --playground-url https://play.rust-lang.org/
</code></pre>
<p>When rendering a crate's docs, this flag gives the base URL of the Rust Playground, to use for
generating <code>Run</code> buttons. Unlike <code>--markdown-playground-url</code>, this argument works for standalone
Markdown files <em>and</em> Rust crates. This works the same way as adding <code>#![doc(html_playground_url = "url")]</code> to your crate root, as mentioned in <a href="write-documentation/the-doc-attribute.html#html_playground_url">the chapter about the <code>#[doc]</code>
attribute</a>. Please be aware that the official Rust Playground at
https://play.rust-lang.org does not have every crate available, so if your examples require your
crate, make sure the playground you provide has your crate available.</p>
<p>If both <code>--playground-url</code> and <code>--markdown-playground-url</code> are present when rendering a standalone
Markdown file, the URL given to <code>--markdown-playground-url</code> will take precedence. If both
<code>--playground-url</code> and <code>#![doc(html_playground_url = "url")]</code> are present when rendering crate docs,
the attribute will take precedence.</p>
<h2 id="--sort-modules-by-appearance-control-how-items-on-module-pages-are-sorted"><a class="header" href="#--sort-modules-by-appearance-control-how-items-on-module-pages-are-sorted"><code>--sort-modules-by-appearance</code>: control how items on module pages are sorted</a></h2>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs -Z unstable-options --sort-modules-by-appearance
</code></pre>
<p>Ordinarily, when <code>rustdoc</code> prints items in module pages, it will sort them alphabetically (taking
some consideration for their stability, and names that end in a number). Giving this flag to
<code>rustdoc</code> will disable this sorting and instead make it print the items in the order they appear in
the source.</p>
<h2 id="--show-type-layout-add-a-section-to-each-types-docs-describing-its-memory-layout"><a class="header" href="#--show-type-layout-add-a-section-to-each-types-docs-describing-its-memory-layout"><code>--show-type-layout</code>: add a section to each type's docs describing its memory layout</a></h2>
<ul>
<li>Tracking issue: <a href="https://github.com/rust-lang/rust/issues/113248">#113248</a></li>
</ul>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs -Z unstable-options --show-type-layout
</code></pre>
<p>When this flag is passed, rustdoc will add a "Layout" section at the bottom of
each type's docs page that includes a summary of the type's memory layout as
computed by rustc. For example, rustdoc will show the size in bytes that a value
of that type will take in memory.</p>
<p>Note that most layout information is <strong>completely unstable</strong> and may even differ
between compilations.</p>
<h2 id="--resource-suffix-modifying-the-name-of-cssjavascript-in-crate-docs"><a class="header" href="#--resource-suffix-modifying-the-name-of-cssjavascript-in-crate-docs"><code>--resource-suffix</code>: modifying the name of CSS/JavaScript in crate docs</a></h2>
<ul>
<li>Tracking issue: <a href="https://github.com/rust-lang/rust/issues/54765">#54765</a></li>
</ul>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs -Z unstable-options --resource-suffix suf
</code></pre>
<p>When rendering docs, <code>rustdoc</code> creates several CSS and JavaScript files as part of the output. Since
all these files are linked from every page, changing where they are can be cumbersome if you need to
specially cache them. This flag will rename all these files in the output to include the suffix in
the filename. For example, <code>light.css</code> would become <code>light-suf.css</code> with the above command.</p>
<h2 id="--extern-html-root-url-control-how-rustdoc-links-to-non-local-crates"><a class="header" href="#--extern-html-root-url-control-how-rustdoc-links-to-non-local-crates"><code>--extern-html-root-url</code>: control how rustdoc links to non-local crates</a></h2>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs -Z unstable-options --extern-html-root-url some-crate=https://example.com/some-crate/1.0.1
</code></pre>
<p>Ordinarily, when rustdoc wants to link to a type from a different crate, it looks in two places:
docs that already exist in the output directory, or the <code>#![doc(doc_html_root)]</code> set in the other
crate. However, if you want to link to docs that exist in neither of those places, you can use these
flags to control that behavior. When the <code>--extern-html-root-url</code> flag is given with a name matching
one of your dependencies, rustdoc use that URL for those docs. Keep in mind that if those docs exist
in the output directory, those local docs will still override this flag.</p>
<p>The names in this flag are first matched against the names given in the <code>--extern name=</code> flags,
which allows selecting between multiple crates with the same name (e.g. multiple versions of
the same crate). For transitive dependencies that haven't been loaded via an <code>--extern</code> flag, matching
falls backs to using crate names only, without ability to distinguish between multiple crates with
the same name.</p>
<h2 id="-z-force-unstable-if-unmarked"><a class="header" href="#-z-force-unstable-if-unmarked"><code>-Z force-unstable-if-unmarked</code></a></h2>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs -Z force-unstable-if-unmarked
</code></pre>
<p>This is an internal flag intended for the standard library and compiler that applies an
<code>#[unstable]</code> attribute to any dependent crate that doesn't have another stability attribute. This
allows <code>rustdoc</code> to be able to generate documentation for the compiler crates and the standard
library, as an equivalent command-line argument is provided to <code>rustc</code> when building those crates.</p>
<h2 id="--index-page-provide-a-top-level-landing-page-for-docs"><a class="header" href="#--index-page-provide-a-top-level-landing-page-for-docs"><code>--index-page</code>: provide a top-level landing page for docs</a></h2>
<p>This feature allows you to generate an index-page with a given markdown file. A good example of it
is the <a href="https://doc.rust-lang.org/nightly/index.html">rust documentation index</a>.</p>
<p>With this, you'll have a page which you can customize as much as you want at the top of your crates.</p>
<p>Using <code>index-page</code> option enables <code>enable-index-page</code> option as well.</p>
<h2 id="--enable-index-page-generate-a-default-index-page-for-docs"><a class="header" href="#--enable-index-page-generate-a-default-index-page-for-docs"><code>--enable-index-page</code>: generate a default index page for docs</a></h2>
<p>This feature allows the generation of a default index-page which lists the generated crates.</p>
<h2 id="--no-capture-disable-output-capture-for-test"><a class="header" href="#--no-capture-disable-output-capture-for-test"><code>--no-capture</code>: disable output capture for test</a></h2>
<p>When this flag is used with <code>--test</code>, the output (stdout and stderr) of your tests won't be
captured by rustdoc. Instead, the output will be directed to your terminal,
as if you had run the test executable manually. This is especially useful
for debugging your tests!</p>
<h2 id="--check-only-checks-the-documentation"><a class="header" href="#--check-only-checks-the-documentation"><code>--check</code>: only checks the documentation</a></h2>
<p>When this flag is supplied, rustdoc will type check and lint your code, but will not generate any
documentation or run your doctests.</p>
<p>Using this flag looks like:</p>
<pre><code class="language-bash">rustdoc -Z unstable-options --check src/lib.rs
</code></pre>
<h2 id="--static-root-path-control-how-static-files-are-loaded-in-html-output"><a class="header" href="#--static-root-path-control-how-static-files-are-loaded-in-html-output"><code>--static-root-path</code>: control how static files are loaded in HTML output</a></h2>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs -Z unstable-options --static-root-path '/cache/'
</code></pre>
<p>This flag controls how rustdoc links to its static files on HTML pages. If you're hosting a lot of
crates' docs generated by the same version of rustdoc, you can use this flag to cache rustdoc's CSS,
JavaScript, and font files in a single location, rather than duplicating it once per "doc root"
(grouping of crate docs generated into the same output directory, like with <code>cargo doc</code>). Per-crate
files like the search index will still load from the documentation root, but anything that gets
renamed with <code>--resource-suffix</code> will load from the given path.</p>
<h2 id="--persist-doctests-persist-doctest-executables-after-running"><a class="header" href="#--persist-doctests-persist-doctest-executables-after-running"><code>--persist-doctests</code>: persist doctest executables after running</a></h2>
<ul>
<li>Tracking issue: <a href="https://github.com/rust-lang/rust/issues/56925">#56925</a></li>
</ul>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs --test -Z unstable-options --persist-doctests target/rustdoctest
</code></pre>
<p>This flag allows you to keep doctest executables around after they're compiled or run.
Usually, rustdoc will immediately discard a compiled doctest after it's been tested, but
with this option, you can keep those binaries around for farther testing.</p>
<h2 id="--show-coverage-calculate-the-percentage-of-items-with-documentation"><a class="header" href="#--show-coverage-calculate-the-percentage-of-items-with-documentation"><code>--show-coverage</code>: calculate the percentage of items with documentation</a></h2>
<ul>
<li>Tracking issue: <a href="https://github.com/rust-lang/rust/issues/58154">#58154</a></li>
</ul>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs -Z unstable-options --show-coverage
</code></pre>
<p>It generates something like this:</p>
<pre><code class="language-bash">+-------------------------------------+------------+------------+------------+------------+
| File                                | Documented | Percentage |   Examples | Percentage |
+-------------------------------------+------------+------------+------------+------------+
| lib.rs                              |          4 |     100.0% |          1 |      25.0% |
+-------------------------------------+------------+------------+------------+------------+
| Total                               |          4 |     100.0% |          1 |      25.0% |
+-------------------------------------+------------+------------+------------+------------+
</code></pre>
<p>If you want to determine how many items in your crate are documented, pass this flag to rustdoc.
When it receives this flag, it will count the public items in your crate that have documentation,
and print out the counts and a percentage instead of generating docs.</p>
<p>Some methodology notes about what rustdoc counts in this metric:</p>
<ul>
<li>Rustdoc will only count items from your crate (i.e. items re-exported from other crates don't
count).</li>
<li>Docs written directly onto inherent impl blocks are not counted, even though their doc comments
are displayed, because the common pattern in Rust code is to write all inherent methods into the
same impl block.</li>
<li>Items in a trait implementation are not counted, as those impls will inherit any docs from the
trait itself.</li>
<li>By default, only public items are counted. To count private items as well, pass
<code>--document-private-items</code> at the same time.</li>
</ul>
<p>Public items that are not documented can be seen with the built-in <code>missing_docs</code> lint. Private
items that are not documented can be seen with Clippy's <code>missing_docs_in_private_items</code> lint.</p>
<p>Calculating code examples follows these rules:</p>
<ol>
<li>These items aren't accounted by default:</li>
</ol>
<ul>
<li>struct/union field</li>
<li>enum variant</li>
<li>constant</li>
<li>static</li>
<li>typedef</li>
</ul>
<ol start="2">
<li>If one of the previously listed items has a code example, then it'll be counted.</li>
</ol>
<h3 id="json-output"><a class="header" href="#json-output">JSON output</a></h3>
<p>When using <code>--output-format json</code> with this option, it will display the coverage information in
JSON format. For example, here is the JSON for a file with one documented item and one
undocumented item:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// This item has documentation
pub fn foo() {}

pub fn no_documentation() {}
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-json">{"no_std.rs":{"total":3,"with_docs":1,"total_examples":3,"with_examples":0}}
</code></pre>
<p>Note that the third item is the crate root, which in this case is undocumented.</p>
<p>If you want the JSON output to be displayed on <code>stdout</code> instead of having a file generated, you can
use <code>-o -</code>.</p>
<h2 id="-w--output-format-output-format"><a class="header" href="#-w--output-format-output-format"><code>-w</code>/<code>--output-format</code>: output format</a></h2>
<h3 id="json"><a class="header" href="#json">json</a></h3>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/rust/issues/76578">#76578</a></li>
</ul>
<p><code>--output-format json</code> emits documentation in the experimental
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustdoc_json_types/">JSON format</a>.</p>
<p>JSON Output for toolchain crates (<code>std</code>, <code>alloc</code>, <code>core</code>, <code>test</code>, and <code>proc_macro</code>)
is available via the <code>rust-docs-json</code> rustup component.</p>
<pre><code class="language-shell">rustup component add --toolchain nightly rust-docs-json
</code></pre>
<p>Then the json files will be present in the <code>share/doc/rust/json/</code> directory
of the rustup toolchain directory.</p>
<p>It can also be used with <code>--show-coverage</code>. Take a look at its
<a href="#--show-coverage-calculate-the-percentage-of-items-with-documentation">documentation</a> for more
information.</p>
<h3 id="doctest"><a class="header" href="#doctest">doctest</a></h3>
<ul>
<li>Tracking issue: <a href="https://github.com/rust-lang/rust/issues/134529">#134529</a></li>
</ul>
<p><code>--output-format doctest</code> emits JSON on stdout which gives you information about doctests in the
provided crate.</p>
<p>You can use this option like this:</p>
<pre><code class="language-bash">rustdoc -Zunstable-options --output-format=doctest src/lib.rs
</code></pre>
<p>For this rust code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// ```
/// #![allow(dead_code)]
/// let x = 12;
/// Ok(())
/// ```
pub trait Trait {}
<span class="boring">}</span></code></pre></pre>
<p>The generated output (formatted) will look like this:</p>
<pre><code class="language-json">{
  "format_version": 2,
  "doctests": [
    {
      "file": "src/lib.rs",
      "line": 1,
      "doctest_attributes": {
        "original": "",
        "should_panic": false,
        "no_run": false,
        "ignore": "None",
        "rust": true,
        "test_harness": false,
        "compile_fail": false,
        "standalone_crate": false,
        "error_codes": [],
        "edition": null,
        "added_css_classes": [],
        "unknown": []
      },
      "original_code": "#![allow(dead_code)]\nlet x = 12;\nOk(())",
      "doctest_code": {
        "crate_level": "#![allow(unused)]\n#![allow(dead_code)]\n\n",
        "code": "let x = 12;\nOk(())",
        "wrapper": {
          "before": "fn main() { fn _inner() -&gt; core::result::Result&lt;(), impl core::fmt::Debug&gt; {\n",
          "after": "\n} _inner().unwrap() }",
          "returns_result": true
        }
      },
      "name": "src/lib.rs - (line 1)"
    }
  ]
}
</code></pre>
<ul>
<li><code>format_version</code> gives you the current version of the generated JSON. If we change the output in any way, the number will increase.</li>
<li><code>doctests</code> contains the list of doctests present in the crate.
<ul>
<li><code>file</code> is the file path where the doctest is located.</li>
<li><code>line</code> is the line where the doctest starts (so where the ``` is located in the current code).</li>
<li><code>doctest_attributes</code> contains computed information about the attributes used on the doctests. For more information about doctest attributes, take a look <a href="write-documentation/documentation-tests.html#attributes">here</a>.</li>
<li><code>original_code</code> is the code as written in the source code before rustdoc modifies it.</li>
<li><code>doctest_code</code> is the code modified by rustdoc that will be run. If there is a fatal syntax error, this field will not be present.
<ul>
<li><code>crate_level</code> is the crate level code (like attributes or <code>extern crate</code>) that will be added at the top-level of the generated doctest.</li>
<li><code>code</code> is "naked" doctest without anything from <code>crate_level</code> and <code>wrapper</code> content.</li>
<li><code>wrapper</code> contains extra code that will be added before and after <code>code</code>.
<ul>
<li><code>returns_result</code> is a boolean. If <code>true</code>, it means that the doctest returns a <code>Result</code> type.</li>
</ul>
</li>
</ul>
</li>
<li><code>name</code> is the name generated by rustdoc which represents this doctest.</li>
</ul>
</li>
</ul>
<h3 id="html"><a class="header" href="#html">html</a></h3>
<p><code>--output-format html</code> has no effect, as the default output is HTML. This is
accepted on stable, even though the other options for this flag aren't.</p>
<h2 id="--with-examples-include-examples-of-uses-of-items-as-documentation"><a class="header" href="#--with-examples-include-examples-of-uses-of-items-as-documentation"><code>--with-examples</code>: include examples of uses of items as documentation</a></h2>
<ul>
<li>Tracking issue: <a href="https://github.com/rust-lang/rust/issues/88791">#88791</a></li>
</ul>
<p>This option, combined with <code>--scrape-examples-target-crate</code> and
<code>--scrape-examples-output-path</code>, is used to implement the functionality in <a href="https://github.com/rust-lang/rfcs/pull/3123">RFC
#3123</a>. Uses of an item (currently
functions / call-sites) are found in a crate and its reverse-dependencies, and
then the uses are included as documentation for that item. This feature is
intended to be used via <code>cargo doc --scrape-examples</code>, but the rustdoc-only
workflow looks like:</p>
<pre><code class="language-bash">$ rustdoc examples/ex.rs -Z unstable-options \
    --extern foobar=target/deps/libfoobar.rmeta \
    --scrape-examples-target-crate foobar \
    --scrape-examples-output-path output.calls
$ rustdoc src/lib.rs -Z unstable-options --with-examples output.calls
</code></pre>
<p>First, the library must be checked to generate an <code>rmeta</code>. Then a
reverse-dependency like <code>examples/ex.rs</code> is given to rustdoc with the target
crate being documented (<code>foobar</code>) and a path to output the calls
(<code>output.calls</code>). Then, the generated calls file can be passed via
<code>--with-examples</code> to the subsequent documentation of <code>foobar</code>.</p>
<p>To scrape examples from test code, e.g. functions marked <code>#[test]</code>, then
add the <code>--scrape-tests</code> flag.</p>
<h2 id="--generate-link-to-definition-generate-links-on-types-in-source-code"><a class="header" href="#--generate-link-to-definition-generate-links-on-types-in-source-code"><code>--generate-link-to-definition</code>: Generate links on types in source code</a></h2>
<ul>
<li>Tracking issue: <a href="https://github.com/rust-lang/rust/issues/89095">#89095</a></li>
</ul>
<p>This flag enables the generation of links in the source code pages which allow the reader
to jump to a type definition.</p>
<h3 id="--test-builder-rustc-like-program-to-build-tests"><a class="header" href="#--test-builder-rustc-like-program-to-build-tests"><code>--test-builder</code>: <code>rustc</code>-like program to build tests</a></h3>
<ul>
<li>Tracking issue: <a href="https://github.com/rust-lang/rust/issues/102981">#102981</a></li>
</ul>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc --test-builder /path/to/rustc src/lib.rs
</code></pre>
<p>Rustdoc will use the provided program to compile tests instead of the default <code>rustc</code> program from
the sysroot.</p>
<h3 id="--test-builder-wrapper-wrap-calls-to-the-test-builder"><a class="header" href="#--test-builder-wrapper-wrap-calls-to-the-test-builder"><code>--test-builder-wrapper</code>: wrap calls to the test builder</a></h3>
<ul>
<li>Tracking issue: <a href="https://github.com/rust-lang/rust/issues/102981">#102981</a></li>
</ul>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc -Zunstable-options --test-builder-wrapper /path/to/rustc-wrapper src/lib.rs
$ rustdoc -Zunstable-options \
    --test-builder-wrapper rustc-wrapper1 \
    --test-builder-wrapper rustc-wrapper2 \
    --test-builder rustc \
    src/lib.rs
</code></pre>
<p>Similar to cargo <code>build.rustc-wrapper</code> option, this flag takes a <code>rustc</code> wrapper program.
The first argument to the program will be the test builder program.</p>
<p>This flag can be passed multiple times to nest wrappers.</p>
<h2 id="passing-arguments-to-rustc-when-compiling-doctests"><a class="header" href="#passing-arguments-to-rustc-when-compiling-doctests">Passing arguments to rustc when compiling doctests</a></h2>
<p>You can use the <code>--doctest-build-arg</code> flag if you want to add options when compiling the
doctest. For example if you have:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// ```
/// #![deny(warnings)]
/// #![feature(async_await)]
///
/// let x = 12;
/// ```
pub struct Bar;
<span class="boring">}</span></code></pre></pre>
<p>And you run <code>rustdoc --test</code> on it, you will get:</p>
<pre><code class="language-console">running 1 test
test foo.rs - Bar (line 1) ... FAILED

failures:

---- foo.rs - Bar (line 1) stdout ----
error: the feature `async_await` has been stable since 1.39.0 and no longer requires an attribute to enable
 --&gt; foo.rs:2:12
  |
3 | #![feature(async_await)]
  |            ^^^^^^^^^^^
  |
note: the lint level is defined here
 --&gt; foo.rs:1:9
  |
2 | #![deny(warnings)]
  |         ^^^^^^^^
  = note: `#[deny(stable_features)]` implied by `#[deny(warnings)]`

error: aborting due to 1 previous error

Couldn't compile the test.

failures:
    foo.rs - Bar (line 1)

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.03s
</code></pre>
<p>But if you can limit the lint level to warning by using <code>--doctest-build-arg=--cap-lints=warn</code>:</p>
<pre><code class="language-console">$ rustdoc --test --doctest-build-arg=--cap-lints=warn file.rs

running 1 test
test tests/rustdoc-ui/doctest/rustflags.rs - Bar (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.06s
</code></pre>
<p>In order to pass multiple arguments to the underlying compiler,
pass <code>--doctest-build-arg ARG</code> for each argument <code>ARG</code>.</p>
<h2 id="--generate-macro-expansion-generate-macros-expansion-toggles-in-source-code"><a class="header" href="#--generate-macro-expansion-generate-macros-expansion-toggles-in-source-code"><code>--generate-macro-expansion</code>: Generate macros expansion toggles in source code</a></h2>
<p>This flag enables the generation of toggles to expand macros in the HTML source code pages.</p>
<h2 id="doccfg-and-docauto_cfg"><a class="header" href="#doccfg-and-docauto_cfg"><code>#[doc(cfg)]</code> and <code>#[doc(auto_cfg)]</code></a></h2>
<p>This feature aims at providing rustdoc users the possibility to add visual markers to the rendered documentation to know under which conditions an item is available (currently possible through the following unstable feature: <code>doc_cfg</code>).</p>
<p>It does not aim to allow having a same item with different <code>cfg</code>s to appear more than once in the generated documentation.</p>
<p>It does not aim to document items which are <em>inactive</em> under the current configuration (i.e., â€œ<code>cfg</code>ed outâ€).</p>
<p>This features adds the following attributes:</p>
<ul>
<li><code>#[doc(auto_cfg)]</code>/<code>#[doc(auto_cfg = true)]</code>/<code>#[doc(auto_cfg = false)]</code></li>
<li><code>#[doc(cfg(...))]</code></li>
<li><code>#![doc(auto_cfg(hide(...)))]</code> / <code>#[doc(auto_cfg(show(...)))]</code></li>
</ul>
<p>All of these attributes can be added to a module or to the crate root, and they will be inherited by the child items unless another attribute overrides it. This is why "opposite" attributes like <code>auto_cfg(hide(...))</code> and <code>auto_cfg(show(...))</code> are provided: they allow a child item to override its parent.</p>
<h3 id="doccfg"><a class="header" href="#doccfg"><code>#[doc(cfg(...))]</code></a></h3>
<p>This attribute provides a standardized format to override <code>#[cfg()]</code> attributes to document conditionally available items. Example:</p>
<pre><code class="language-rust ignore (nightly)">// the "real" cfg condition
#[cfg(feature = "futures-io")]
// the `doc(cfg())` so it's displayed to the readers
#[doc(cfg(feature = "futures-io"))]
pub mod futures {}</code></pre>
<p>It will display in the documentation for this module:</p>
<pre><code class="language-text">This is supported on feature="futures-io" only.
</code></pre>
<p>You can use it to display information in generated documentation, whether or not there is a <code>#[cfg()]</code> attribute:</p>
<pre><code class="language-rust ignore (nightly)">#[doc(cfg(feature = "futures-io"))]
pub mod futures {}</code></pre>
<p>It will be displayed exactly the same as the previous code.</p>
<p>This attribute has the same syntax as conditional compilation, but it only causes documentation to be added. This means <code>#[doc(cfg(not(windows)))]</code> will not cause your docs to be hidden on non-windows targets, even though <code>#[cfg(not(windows))]</code> does do that.</p>
<p>If <code>doc(auto_cfg)</code> is enabled on the item, <code>doc(cfg)</code> will override it anyway so in the two previous examples, even if the <code>doc(auto_cfg)</code> feature was enabled, it would still display the same thing.</p>
<p>This attribute works on modules and on items.</p>
<h3 id="docauto_cfghide"><a class="header" href="#docauto_cfghide"><code>#[doc(auto_cfg(hide(...)))]</code></a></h3>
<p>This attribute is used to prevent some <code>cfg</code> to be generated in the visual markers. It only applies to <code>#[doc(auto_cfg = true)]</code>, not to <code>#[doc(cfg(...))]</code>. So in the previous example:</p>
<pre><code class="language-rust ignore (nightly)">#[cfg(any(unix, feature = "futures-io"))]
pub mod futures {}</code></pre>
<p>It currently displays both <code>unix</code> and <code>feature = "futures-io"</code> into the documentation, which is not great. To prevent the <code>unix</code> cfg to ever be displayed, you can use this attribute at the crate root level:</p>
<pre><code class="language-rust ignore (nightly)">#![doc(auto_cfg(hide(unix)))]</code></pre>
<p>Or directly on a given item/module as it covers any of the item's descendants:</p>
<pre><code class="language-rust ignore (nightly)">#[doc(auto_cfg(hide(unix)))]
#[cfg(any(unix, feature = "futures-io"))]
pub mod futures {
    // `futures` and all its descendants won't display "unix" in their cfgs.
}</code></pre>
<p>Then, the <code>unix</code> cfg will never be displayed into the documentation.</p>
<p>Rustdoc currently hides <code>doc</code> and <code>doctest</code> attributes by default and reserves the right to change the list of "hidden by default" attributes.</p>
<p>The attribute accepts only a list of identifiers or key/value items. So you can write:</p>
<pre><code class="language-rust ignore (nightly)">#[doc(auto_cfg(hide(unix, doctest, feature = "something")))]
#[doc(auto_cfg(hide()))]</code></pre>
<p>But you cannot write:</p>
<pre><code class="language-rust ignore (nightly)">#[doc(auto_cfg(hide(not(unix))))]</code></pre>
<p>So if we use <code>doc(auto_cfg(hide(unix)))</code>, it means it will hide all mentions of <code>unix</code>:</p>
<pre><code class="language-rust ignore (nightly)">#[cfg(unix)] // nothing displayed
#[cfg(any(unix))] // nothing displayed
#[cfg(any(unix, windows))] // only `windows` displayed</code></pre>
<p>However, it only impacts the <code>unix</code> cfg, not the feature:</p>
<pre><code class="language-rust ignore (nightly)">#[cfg(feature = "unix")] // `feature = "unix"` is displayed</code></pre>
<p>If <code>cfg_auto(show(...))</code> and <code>cfg_auto(hide(...))</code> are used to show/hide a same <code>cfg</code> on a same item, it'll emit an error. Example:</p>
<pre><code class="language-rust ignore (nightly)">#[doc(auto_cfg(hide(unix)))]
#[doc(auto_cfg(show(unix)))] // Error!
pub fn foo() {}</code></pre>
<p>Using this attribute will re-enable <code>auto_cfg</code> if it was disabled at this location:</p>
<pre><code class="language-rust ignore (nightly)">#[doc(auto_cfg = false)] // Disabling `auto_cfg`
pub fn foo() {}</code></pre>
<p>And using <code>doc(auto_cfg)</code> will re-enable it:</p>
<pre><code class="language-rust ignore (nightly)">#[doc(auto_cfg = false)] // Disabling `auto_cfg`
pub mod module {
    #[doc(auto_cfg(hide(unix)))] // `auto_cfg` is re-enabled.
    pub fn foo() {}
}</code></pre>
<p>However, using <code>doc(auto_cfg = ...)</code> and <code>doc(auto_cfg(...))</code> on the same item will emit an error:</p>
<pre><code class="language-rust ignore (nightly)">#[doc(auto_cfg = false)]
#[doc(auto_cfg(hide(unix)))] // error
pub fn foo() {}</code></pre>
<p>The reason behind this is that <code>doc(auto_cfg = ...)</code> enables or disables the feature, whereas <code>doc(auto_cfg(...))</code> enables it unconditionally, making the first attribute to appear useless as it will be overidden by the next <code>doc(auto_cfg)</code> attribute.</p>
<h3 id="docauto_cfgshow"><a class="header" href="#docauto_cfgshow"><code>#[doc(auto_cfg(show(...)))]</code></a></h3>
<p>This attribute does the opposite of <code>#[doc(auto_cfg(hide(...)))]</code>: if you used <code>#[doc(auto_cfg(hide(...)))]</code> and want to revert its effect on an item and its descendants, you can use <code>#[doc(auto_cfg(show(...)))]</code>.
It only applies to <code>#[doc(auto_cfg = true)]</code>, not to <code>#[doc(cfg(...))]</code>.</p>
<p>For example:</p>
<pre><code class="language-rust ignore (nightly)">#[doc(auto_cfg(hide(unix)))]
#[cfg(any(unix, feature = "futures-io"))]
pub mod futures {
    // `futures` and all its descendants won't display "unix" in their cfgs.
    #[doc(auto_cfg(show(unix)))]
    pub mod child {
        // `child` and all its descendants will display "unix" in their cfgs.
    }
}</code></pre>
<p>The attribute accepts only a list of identifiers or key/value items. So you can write:</p>
<pre><code class="language-rust ignore (nightly)">#[doc(auto_cfg(show(unix, doctest, feature = "something")))]
#[doc(auto_cfg(show()))]</code></pre>
<p>But you cannot write:</p>
<pre><code class="language-rust ignore (nightly)">#[doc(auto_cfg(show(not(unix))))]</code></pre>
<p>If <code>auto_cfg(show(...))</code> and <code>auto_cfg(hide(...))</code> are used to show/hide a same <code>cfg</code> on a same item, it'll emit an error. Example:</p>
<pre><code class="language-rust ignore (nightly)">#[doc(auto_cfg(show(unix)))]
#[doc(auto_cfg(hide(unix)))] // Error!
pub fn foo() {}</code></pre>
<p>Using this attribute will re-enable <code>auto_cfg</code> if it was disabled at this location:</p>
<pre><code class="language-rust ignore (nightly)">#[doc(auto_cfg = false)] // Disabling `auto_cfg`
#[doc(auto_cfg(show(unix)))] // `auto_cfg` is re-enabled.
pub fn foo() {}</code></pre>
<h3 id="docauto_cfgdocauto_cfg--truedocauto_cfg--false"><a class="header" href="#docauto_cfgdocauto_cfg--truedocauto_cfg--false"><code>#[doc(auto_cfg)</code>/<code>#[doc(auto_cfg = true)]</code>/<code>#[doc(auto_cfg = false)]</code></a></h3>
<p>By default, <code>#[doc(auto_cfg)]</code> is enabled at the crate-level. When it's enabled, Rustdoc will automatically display <code>cfg(...)</code> compatibility information as-if the same <code>#[doc(cfg(...))]</code> had been specified.</p>
<p>This attribute impacts the item on which it is used and its descendants.</p>
<p>So if we take back the previous example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = "futures-io")]
pub mod futures {}
<span class="boring">}</span></code></pre></pre>
<p>There's no need to "duplicate" the <code>cfg</code> into a <code>doc(cfg())</code> to make Rustdoc display it.</p>
<p>In some situations, the detailed conditional compilation rules used to implement the feature might not serve as good documentation (for example, the list of supported platforms might be very long, and it might be better to document them in one place). To turn it off, add the <code>#[doc(auto_cfg = false)]</code> attribute on the item.</p>
<p>If no argument is specified (ie <code>#[doc(auto_cfg)]</code>), it's the same as writing <code>#[doc(auto_cfg = true)]</code>.</p>
<h2 id="inheritance"><a class="header" href="#inheritance">Inheritance</a></h2>
<p>Rustdoc merges <code>cfg</code> attributes from parent modules to its children. For example, in this case, the module <code>non_unix</code> will describe the entire compatibility matrix for the module, and not just its directly attached information:</p>
<pre><code class="language-rust ignore (nightly)">#[doc(cfg(any(windows, unix)))]
pub mod desktop {
    #[doc(cfg(not(unix)))]
    pub mod non_unix {
        // ...
    }
}</code></pre>
<p>This code will display:</p>
<pre><code class="language-text">Available on (Windows or Unix) and non-Unix only.
</code></pre>
<h3 id="re-exports-and-inlining"><a class="header" href="#re-exports-and-inlining">Re-exports and inlining</a></h3>
<p><code>cfg</code> attributes of a re-export are never merged with the re-exported item(s) attributes except if the re-export has the <code>#[doc(inline)]</code> attribute. In this case, the <code>cfg</code> of the re-exported item will be merged with the re-export's.</p>
<p>When talking about "attributes merge", we mean that if the re-export has <code>#[cfg(unix)]</code> and the re-exported item has <code>#[cfg(feature = "foo")]</code>, you will only see <code>cfg(unix)</code> on the re-export and only <code>cfg(feature = "foo")</code> on the re-exported item, unless the re-export has <code>#[doc(inline)]</code>, then you will only see the re-exported item with both <code>cfg(unix)</code> and <code>cfg(feature = "foo")</code>.</p>
<p>Example:</p>
<pre><code class="language-rust ignore (nightly)">#[doc(cfg(any(windows, unix)))]
pub mod desktop {
    #[doc(cfg(not(unix)))]
    pub mod non_unix {
        // code
    }
}

#[doc(cfg(target_os = "freebsd"))]
pub use desktop::non_unix as non_unix_desktop;
#[doc(cfg(target_os = "macos"))]
#[doc(inline)]
pub use desktop::non_unix as inlined_non_unix_desktop;</code></pre>
<p>In this example, <code>non_unix_desktop</code> will only display <code>cfg(target_os = "freeebsd")</code> and not display any <code>cfg</code> from <code>desktop::non_unix</code>.</p>
<p>On the contrary, <code>inlined_non_unix_desktop</code> will have cfgs from both the re-export and the re-exported item.</p>
<p>So that also means that if a crate re-exports a foreign item, unless it has <code>#[doc(inline)]</code>, the <code>cfg</code> and <code>doc(cfg)</code> attributes will not be visible:</p>
<pre><code class="language-rust ignore (nightly)">// dep:
#[cfg(feature = "a")]
pub struct S;

// crate using dep:

// There will be no mention of `feature = "a"` in the documentation.
pub use dep::S as Y;</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="advanced-features.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="deprecated-features.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="advanced-features.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="deprecated-features.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
