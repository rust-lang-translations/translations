<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust 도구 패키징 및 배포 - Command Line Applications in Rust</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/rust-cli";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/tutorial/packaging.md`;
                    } else {
                        canonical_href = `${base}/${lang}/tutorial/packaging.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../src/special-content.css">
        <link rel="stylesheet" href="../theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Command Line Applications in Rust</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-도구-패키징-및-배포"><a class="header" href="#rust-도구-패키징-및-배포">Rust 도구 패키징 및 배포</a></h1>
<p>프로그램이 다른 사람들이 사용할 준비가 되었다고 확신한다면 패키징하고 출시할 시간입니다!</p>
<p>몇 가지 접근 방식이 있으며, “가장 빠른 설정“에서 “사용자에게 가장 편리한“까지 세 가지를 살펴보겠습니다.</p>
<h2 id="가장-빠른-방법-cargo-publish"><a class="header" href="#가장-빠른-방법-cargo-publish">가장 빠른 방법: <code>cargo publish</code></a></h2>
<p>앱을 게시하는 가장 쉬운 방법은 cargo를 사용하는 것입니다. 프로젝트에 외부 의존성을 추가한 방법을 기억하십니까? Cargo는 기본 “크레이트 레지스트리“인 <a href="https://crates.io/">crates.io</a>에서 다운로드했습니다. <code>cargo publish</code>를 사용하면 <a href="https://crates.io/">crates.io</a>에 크레이트를 게시할 수도 있습니다. 그리고 이것은 바이너리 대상이 있는 크레이트를 포함하여 모든 크레이트에서 작동합니다.</p>
<p><a href="https://crates.io/">crates.io</a>에 크레이트를 게시하는 것은 매우 간단합니다. 아직 계정이 없다면 <a href="https://crates.io/">crates.io</a>에서 계정을 만드세요. 현재 이것은 GitHub에서 인증을 통해 수행되므로 GitHub 계정이 있어야 합니다(그리고 거기에 로그인해야 함). 다음으로 로컬 컴퓨터에서 cargo를 사용하여 로그인합니다. 이를 위해 <a href="https://crates.io/me">crates.io 계정 페이지</a>로 이동하여 새 토큰을 만든 다음 <code>cargo login &lt;your-new-token&gt;</code>을 실행합니다. 컴퓨터당 한 번만 수행하면 됩니다. 이에 대한 자세한 내용은 cargo의 <a href="https://doc.rust-lang.org/1.39.0/cargo/reference/publishing.html">게시 가이드</a>에서 확인할 수 있습니다.</p>
<p>이제 cargo와 crates.io가 당신을 알았으므로 크레이트를 게시할 준비가 되었습니다. 서둘러 새 크레이트(버전)를 게시하기 전에 <code>Cargo.toml</code>을 다시 한 번 열고 필요한 메타데이터를 추가했는지 확인하는 것이 좋습니다. 설정할 수 있는 모든 가능한 필드는 <a href="https://doc.rust-lang.org/1.39.0/cargo/reference/manifest.html">cargo의 매니페스트 형식</a>에 대한 문서에서 찾을 수 있습니다. 다음은 몇 가지 일반적인 항목에 대한 간략한 개요입니다.</p>
<pre><code class="language-toml">[package]
name = "grrs"
version = "0.1.0"
authors = ["Your Name &lt;your@email.com&gt;"]
license = "MIT OR Apache-2.0"
description = "A tool to search files"
readme = "README.md"
homepage = "https://github.com/you/grrs"
repository = "https://github.com/you/grrs"
keywords = ["cli", "search", "demo"]
categories = ["command-line-utilities"]
</code></pre>
<aside class="note">
<p><strong>참고:</strong> 이 예제에는 Rust 프로젝트에 대한 일반적인 선택인 필수 라이선스 필드가 포함되어 있습니다. 컴파일러 자체에도 사용되는 동일한 라이선스입니다. 또한 <code>README.md</code> 파일을 참조합니다. 프로젝트에 대한 간략한 설명이 포함되어야 하며 크레이트의 crates.io 페이지뿐만 아니라 GitHub가 리포지토리 페이지에 기본적으로 표시하는 내용에도 포함됩니다.</p>
</aside>
<h3 id="cratesio에서-바이너리를-설치하는-방법"><a class="header" href="#cratesio에서-바이너리를-설치하는-방법">crates.io에서 바이너리를 설치하는 방법</a></h3>
<p>crates.io에 크레이트를 게시하는 방법을 보았고 설치하는 방법이 궁금할 것입니다. <code>cargo build</code>(또는 유사한 명령)를 실행할 때 cargo가 다운로드하고 컴파일하는 라이브러리와 달리 바이너리를 명시적으로 설치하도록 지시해야 합니다.</p>
<p>이것은 <code>cargo install &lt;crate-name&gt;</code>을 사용하여 수행됩니다. 기본적으로 크레이트를 다운로드하고 포함된 모든 바이너리 대상( “릴리스” 모드이므로 시간이 걸릴 수 있음)을 컴파일하고 <code>~/.cargo/bin/</code> 디렉토리에 복사합니다. (셸이 바이너리를 찾기 위해 해당 위치를 보도록 해야 합니다!)</p>
<p>git 리포지토리에서 크레이트를 설치하고, 크레이트의 특정 바이너리만 설치하고, 설치할 대체 디렉토리를 지정할 수도 있습니다. 자세한 내용은 <code>cargo install --help</code>를 참조하세요.</p>
<h3 id="사용-시기"><a class="header" href="#사용-시기">사용 시기</a></h3>
<p><code>cargo install</code>은 바이너리 크레이트를 설치하는 간단한 방법입니다. Rust 개발자가 사용하기에 매우 편리하지만 몇 가지 중요한 단점이 있습니다. 항상 소스를 처음부터 컴파일하므로 도구 사용자는 컴퓨터에 Rust, cargo 및 프로젝트에 필요한 다른 모든 시스템 의존성을 설치해야 합니다. 큰 Rust 코드베이스를 컴파일하는 데도 시간이 걸릴 수 있습니다.</p>
<p>다른 Rust 개발자를 대상으로 하는 도구를 배포하는 데 사용하는 것이 가장 좋습니다. 예를 들어 <code>cargo-tree</code> 또는 <code>cargo-outdated</code>와 같은 많은 cargo 하위 명령을 설치할 수 있습니다.</p>
<h2 id="바이너리-배포"><a class="header" href="#바이너리-배포">바이너리 배포</a></h2>
<p>Rust는 네이티브 코드로 컴파일되고 기본적으로 모든 의존성을 정적으로 연결하는 언어입니다. <code>grrs</code>라는 바이너리가 포함된 프로젝트에서 <code>cargo build</code>를 실행하면 <code>grrs</code>라는 바이너리 파일이 생성됩니다. 시도해 보세요. <code>cargo build</code>를 사용하면 <code>target/debug/grrs</code>가 되고, <code>cargo build --release</code>를 실행하면 <code>target/release/grrs</code>가 됩니다. 대상 시스템에 외부 라이브러리를 명시적으로 설치해야 하는 크레이트(예: 시스템의 OpenSSL 버전 사용)를 사용하지 않는 한 이 바이너리는 공통 시스템 라이브러리에만 의존합니다. 즉, 해당 파일을 가져와 동일한 운영 체제를 실행하는 사람들에게 보내면 실행할 수 있습니다.</p>
<p>이것은 이미 매우 강력합니다! 방금 본 <code>cargo install</code>의 두 가지 단점을 해결합니다. 사용자 컴퓨터에 Rust를 설치할 필요가 없으며 컴파일하는 데 1분이 걸리는 대신 즉시 바이너리를 실행할 수 있습니다.</p>
<p>따라서 보시다시피 <code>cargo build</code>는 <em>이미</em> 우리를 위해 바이너리를 빌드합니다. 유일한 문제는 모든 플랫폼에서 작동하도록 보장되지 않는다는 것입니다. Windows 컴퓨터에서 <code>cargo build</code>를 실행하면 기본적으로 Mac에서 작동하는 바이너리를 얻을 수 없습니다. 흥미로운 모든 플랫폼에 대해 이러한 바이너리를 자동으로 생성하는 방법이 있습니까?</p>
<h3 id="ci에서-바이너리-릴리스-빌드"><a class="header" href="#ci에서-바이너리-릴리스-빌드">CI에서 바이너리 릴리스 빌드</a></h3>
<p>도구가 오픈 소스이고 GitHub에서 호스팅되는 경우 <a href="https://travis-ci.com/">Travis CI</a>와 같은 무료 CI(지속적 통합) 서비스를 설정하는 것이 매우 쉽습니다. (다른 플랫폼에서도 작동하는 다른 서비스가 있지만 Travis는 매우 인기가 있습니다.) 이것은 기본적으로 리포지토리에 변경 사항을 푸시할 때마다 가상 머신에서 설정 명령을 실행합니다. 이러한 명령이 무엇인지, 그리고 실행되는 컴퓨터 유형은 구성 가능합니다. 예를 들어 Rust와 몇 가지 일반적인 빌드 도구가 설치된 컴퓨터에서 <code>cargo test</code>를 실행하는 것이 좋습니다. 실패하면 가장 최근 변경 사항에 문제가 있음을 알 수 있습니다.</p>
<p>이것을 사용하여 바이너리를 빌드하고 GitHub에 업로드할 수도 있습니다! 실제로 <code>cargo build --release</code>를 실행하고 바이너리를 어딘가에 업로드하면 모든 준비가 완료된 것일까요? 그렇지 않습니다. 빌드하는 바이너리가 가능한 한 많은 시스템과 호환되는지 확인해야 합니다. 예를 들어 Linux에서는 현재 시스템용으로 컴파일하는 대신 <code>x86_64-unknown-linux-musl</code> 대상을 위해 컴파일하여 기본 시스템 라이브러리에 의존하지 않도록 할 수 있습니다. macOS에서는 <code>MACOSX_DEPLOYMENT_TARGET</code>을 <code>10.7</code>로 설정하여 10.7 및 이전 버전에 있는 시스템 기능에만 의존하도록 할 수 있습니다.</p>
<p>Linux 및 macOS의 경우 <a href="https://github.com/rustwasm/wasm-pack/blob/51e6351c28fbd40745719e6d4a7bf26dadd30c85/.travis.yml#L74-L91">여기</a>에서, Windows(AppVeyor 사용)의 경우 <a href="https://github.com/rustwasm/wasm-pack/blob/51e6351c28fbd40745719e6d4a7bf26dadd30c85/.appveyor.yml">여기</a>에서 이 접근 방식을 사용하여 바이너리를 빌드하는 한 가지 예를 볼 수 있습니다.</p>
<p>또 다른 방법은 바이너리를 빌드하는 데 필요한 모든 도구가 포함된 사전 빌드된 (Docker) 이미지를 사용하는 것입니다. 이를 통해 더 이국적인 플랫폼도 쉽게 타겟팅할 수 있습니다. <a href="https://github.com/japaric/trust">trust</a> 프로젝트에는 프로젝트에 포함할 수 있는 스크립트와 이를 설정하는 방법에 대한 지침이 포함되어 있습니다. 또한 AppVeyor를 사용하는 Windows도 지원합니다.</p>
<p>로컬에서 설정하고 자신의 컴퓨터에서 릴리스 파일을 생성하려는 경우에도 trust를 살펴보십시오. 내부적으로 <a href="https://github.com/rust-embedded/cross">cross</a>를 사용하며, 이는 cargo와 유사하게 작동하지만 Docker 컨테이너 내부의 cargo 프로세스로 명령을 전달합니다. 이미지의 정의는 <a href="https://github.com/rust-embedded/cross">cross의 리포지토리</a>에서도 사용할 수 있습니다.</p>
<h3 id="이러한-바이너리를-설치하는-방법"><a class="header" href="#이러한-바이너리를-설치하는-방법">이러한 바이너리를 설치하는 방법</a></h3>
<p>사용자를 <a href="https://github.com/rustwasm/wasm-pack/releases/tag/v0.5.1">이것과 같은</a> 릴리스 페이지로 안내하면 방금 만든 아티팩트를 다운로드할 수 있습니다. 방금 생성한 릴리스 아티팩트는 특별한 것이 아닙니다. 결국 바이너리가 포함된 아카이브 파일일 뿐입니다! 즉, 도구 사용자는 브라우저로 다운로드하고 압축을 풀고(종종 자동으로 발생) 바이너리를 원하는 위치에 복사할 수 있습니다.</p>
<p>이것은 수동으로 프로그램을 “설치“하는 데 약간의 경험이 필요하므로 이 프로그램을 설치하는 방법에 대한 섹션을 README 파일에 추가하고 싶을 것입니다.</p>
<aside class="note">
<p><strong>참고:</strong> <a href="https://github.com/japaric/trust">trust</a>를 사용하여 바이너리를 빌드하고 GitHub 릴리스에 추가한 경우 <code>curl -LSfs https://japaric.github.io/trust/install.sh | sh -s -- --git your-name/repo-name</code>을 실행하도록 사람들에게 알려줄 수도 있습니다. 이것이 더 쉽다고 생각한다면 말입니다.</p>
</aside>
<h3 id="사용-시기-1"><a class="header" href="#사용-시기-1">사용 시기</a></h3>
<p>바이너리 릴리스를 갖는 것은 일반적으로 좋은 생각이며 단점이 거의 없습니다. 사용자가 도구를 수동으로 설치하고 업데이트해야 하는 문제를 해결하지는 않지만 Rust를 설치할 필요 없이 최신 릴리스 버전을 빠르게 얻을 수 있습니다.</p>
<h3 id="바이너리-외에-무엇을-패키징해야-할까요"><a class="header" href="#바이너리-외에-무엇을-패키징해야-할까요">바이너리 외에 무엇을 패키징해야 할까요</a></h3>
<p>지금 사용자가 릴리스 빌드를 다운로드하면 바이너리 파일만 포함된 <code>.tar.gz</code> 파일을 받게 됩니다. 따라서 예제 프로젝트에서는 실행할 수 있는 단일 <code>grrs</code> 파일만 받게 됩니다. 하지만 리포지토리에 이미 가지고 있는 파일 중 사용자가 원할 수 있는 파일이 더 있습니다. 예를 들어 이 도구를 사용하는 방법을 알려주는 README 파일과 라이선스 파일이 있습니다. 이미 가지고 있으므로 추가하기 쉽습니다.</p>
<p>하지만 특히 명령줄 도구에 의미 있는 더 흥미로운 파일이 있습니다. README 파일 외에 man 페이지와 셸에 가능한 플래그 완성을 추가하는 구성 파일도 함께 제공하는 것은 어떻습니까? 이것들을 수동으로 작성할 수 있지만, 우리가 사용하는 인수 구문 분석 라이브러리인 <em>clap</em>(clap이 기반으로 함)에는 이러한 모든 파일을 생성하는 방법이 있습니다. 자세한 내용은 <a href="../in-depth/docs.html">이 심층 장</a>을 참조하세요.</p>
<h2 id="앱을-패키지-리포지토리에-넣기"><a class="header" href="#앱을-패키지-리포지토리에-넣기">앱을 패키지 리포지토리에 넣기</a></h2>
<p>지금까지 본 두 가지 접근 방식은 일반적으로 컴퓨터에 소프트웨어를 설치하는 방식이 아닙니다. 특히 대부분의 운영 체제에서 전역 패키지 관리자를 사용하여 설치하는 명령줄 도구입니다. 사용자를 위한 이점은 매우 분명합니다. 다른 도구를 설치하는 것과 동일한 방식으로 프로그램을 설치할 수 있다면 프로그램을 설치하는 방법에 대해 생각할 필요가 없습니다. 이러한 패키지 관리자는 또한 사용자가 새 버전을 사용할 수 있을 때 프로그램을 업데이트할 수 있도록 합니다.</p>
<p>안타깝게도 다른 시스템을 지원한다는 것은 이러한 다른 시스템이 어떻게 작동하는지 살펴봐야 한다는 것을 의미합니다. 일부의 경우 리포지토리에 파일을 추가하는 것만큼 쉬울 수 있습니다(예: macOS의 <code>brew</code>용으로 <a href="https://github.com/BurntSushi/ripgrep/blob/31adff6f3c4bfefc9e77df40871f2989443e6827/pkg/brew/ripgrep-bin.rb">이것</a>과 같은 Formula 파일 추가). 그러나 다른 경우에는 종종 직접 패치를 보내고 도구를 해당 리포지토리에 추가해야 합니다. <a href="https://crates.io/crates/cargo-bundle">cargo-bundle</a>, <a href="https://crates.io/crates/cargo-deb">cargo-deb</a> 및 <a href="https://crates.io/crates/cargo-aur">cargo-aur</a>와 같은 유용한 도구가 있지만, 작동 방식과 이러한 다른 시스템에 대해 도구를 올바르게 패키징하는 방법을 설명하는 것은 이 장의 범위를 벗어납니다.</p>
<p>대신 Rust로 작성되었고 많은 다른 패키지 관리자에서 사용할 수 있는 도구를 살펴보겠습니다.</p>
<h3 id="예-ripgrep"><a class="header" href="#예-ripgrep">예: ripgrep</a></h3>
<p><a href="https://github.com/BurntSushi/ripgrep">ripgrep</a>은 <code>grep</code>/<code>ack</code>/<code>ag</code>의 대안이며 Rust로 작성되었습니다. 매우 성공적이며 많은 운영 체제용으로 패키징되었습니다. README의 <a href="https://github.com/BurntSushi/ripgrep/tree/31adff6f3c4bfefc9e77df40871f2989443e6827#installation">“설치” 섹션</a>을 살펴보세요!</p>
<p>설치 방법에 대한 몇 가지 다른 옵션을 나열합니다. 바이너리가 포함된 GitHub 릴리스에 대한 링크로 시작하여 직접 다운로드할 수 있습니다. 그런 다음 여러 다른 패키지 관리자를 사용하여 설치하는 방법을 나열합니다. 마지막으로 <code>cargo install</code>을 사용하여 설치할 수도 있습니다.</p>
<p>이것은 매우 좋은 생각인 것 같습니다. 여기에 제시된 접근 방식 중 하나를 선택하지 말고 <code>cargo install</code>로 시작하여 바이너리 릴리스를 추가하고 마지막으로 시스템 패키지 관리자를 사용하여 도구를 배포하기 시작하십시오.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../tutorial/testing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../in-depth/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../tutorial/testing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../in-depth/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/language-picker.js"></script>


    </div>
    </body>
</html>
