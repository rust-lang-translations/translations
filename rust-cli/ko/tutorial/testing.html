<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>테스트 - Command Line Applications in Rust</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/rust-cli";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/tutorial/testing.md`;
                    } else {
                        canonical_href = `${base}/${lang}/tutorial/testing.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../src/special-content.css">
        <link rel="stylesheet" href="../theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Command Line Applications in Rust</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="테스트"><a class="header" href="#테스트">테스트</a></h1>
<p>Over decades of software development, people have discovered one truth: Untested software rarely works. Many people would go as far as saying that most tested software doesn’t work either. But we are all optimists here, right? To ensure that your program does what you expect it to do, it is wise to test it.</p>
<p>A good starting point is to write a <code>README</code> file that describes what your program should do, and when you feel ready to make a new release, go through the <code>README</code> and ensure that the behavior is still as expected. You can make this a more rigorous exercise by also writing down how your program should react to erroneous inputs.</p>
<p>여기 또 다른 멋진 아이디어가 있습니다. 코드를 작성하기 전에 <code>README</code>를 작성하세요.</p>
<aside>
<p><strong>참고:</strong> <a href="https://en.wikipedia.org/wiki/Test-driven_development">테스트 주도 개발</a>(TDD)에 대해 들어본 적이 없다면 살펴보세요.</p>
</aside>
<h2 id="자동화된-테스트"><a class="header" href="#자동화된-테스트">자동화된 테스트</a></h2>
<p>이제 이것은 모두 괜찮지만 이 모든 것을 수동으로 수행하시겠습니까? 시간이 많이 걸릴 수 있습니다. 동시에 많은 사람들이 컴퓨터에 일을 시키는 것을 즐기게 되었습니다. 이러한 테스트를 자동화하는 방법에 대해 이야기해 봅시다.</p>
<p>Rust has a built-in test framework, so let’s start by writing our first test:</p>
<pre><code class="language-rust ignore"><span class="boring">fn answer() -&gt; i32 {
</span><span class="boring">  42
</span><span class="boring">}
</span><span class="boring">
</span>#[test]
fn check_answer_validity() {
    assert_eq!(answer(), 42);
}</code></pre>
<p>이 코드 조각을 패키지의 거의 모든 소스 파일에 넣을 수 있으며 <code>cargo test</code>가 이를 찾아 실행합니다. 여기서 핵심은 <code>#[test]</code> 속성입니다. 이를 통해 빌드 시스템이 이러한 함수를 검색하고 테스트로 실행하여 패닉이 발생하지 않는지 확인할 수 있습니다.</p>
<aside class="exercise">
<p><strong>독자를 위한 연습:</strong> 이 테스트가 작동하도록 만드세요.</p>
<p>다음과 같은 출력이 표시되어야 합니다.</p>
<pre><code class="language-text">running 1 test
test check_answer_validity ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
</aside>
<p>Now that we’ve seen <em>how</em> we can write tests, we still need to figure out <em>what</em> to test. As you’ve seen, it takes little code to write assertions for functions, but a CLI application is often more than one function! Worse, it often deals with user input, reads files, and writes output.</p>
<h2 id="코드를-테스트-가능하게-만들기"><a class="header" href="#코드를-테스트-가능하게-만들기">코드를 테스트 가능하게 만들기</a></h2>
<p>There are two complementary approaches to testing functionality. One is to test the small units that you use to build your complete application. These are called “unit tests”. Another is to test the final application from the outside, called black box tests or integration tests. Let’s begin with the first one.</p>
<p>To figure out what we should test, let’s see what our program features are. <code>grrs</code> is supposed to print out the lines that match a given pattern, so let’s write unit tests for <em>exactly this</em>. We want to ensure that our most important piece of logic works, and we want to do it in a way that is not dependent on any of the setup code we have around it like the CLI arguments.</p>
<p><code>grrs</code>의 <a href="impl-draft.html">첫 번째 구현</a>으로 돌아가서 <code>main</code> 함수에 이 코드 블록을 추가했습니다.</p>
<pre><code class="language-rust ignore">// ...
for line in content.lines() {
    if line.contains(&amp;args.pattern) {
        println!("{}", line);
    }
}</code></pre>
<p>Sadly, this is not very easy to test. First of all, it’s in the main function, so we can’t easily call it. This is fixed by moving this piece of code into a function:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn find_matches(content: &amp;str, pattern: &amp;str) {
    for line in content.lines() {
        if line.contains(pattern) {
            println!("{}", line);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Now, we can call this function in our test and see what its output is:</p>
<pre><code class="language-rust ignore">#[test]
fn find_a_match() {
    find_matches("lorem ipsum\ndolor sit amet", "lorem");
    assert_eq!( // 어...</code></pre>
<p>아니면… 할 수 있을까요? 지금 <code>find_matches</code>는 <code>stdout</code>, 즉 터미널에 직접 인쇄합니다. 테스트에서 이것을 쉽게 캡처할 수 없습니다! 이것은 구현 후에 테스트를 작성할 때 종종 발생하는 문제입니다. 우리는 사용되는 컨텍스트에 확고하게 통합된 함수를 작성했습니다.</p>
<aside class="note">
<p><strong>Note:</strong> This is totally fine when writing small CLI applications. There’s no need to make everything testable! It is important to think about which parts of your code you might want to write unit tests for. While we’ll see that it’s straightforward to change this function to be testable, this is not always the case.</p>
</aside>
<p>Alright, how can we make this testable? We’ll need to capture the output somehow. Rust’s standard library has some neat abstractions for dealing with I/O (input/output), and we’ll make use of one called <a href="https://doc.rust-lang.org/1.39.0/std/io/trait.Write.html"><code>std::io::Write</code></a>. This is a <a href="https://doc.rust-lang.org/book/ch10-02-traits.html">trait</a> that abstracts over things we can write to, which includes strings and <code>stdout</code>.</p>
<p>If this is the first time you’ve heard “trait” in the context of Rust, you are in for a treat. Traits are one of the most powerful features of Rust. You can think of them like interfaces in Java or type classes in Haskell, whatever you are more familiar with. They allow you to abstract over behavior that can be shared by different types. Code that uses traits can express ideas in very generic and flexible ways. This means it can also get difficult to read. Don’t let that intimidate you. Even people who have used Rust for years don’t always get what generic code does immediately. In that case, it helps to think of concrete uses. In our case, the behavior that we abstract over is “write to it”. Examples for the types that implement (<code>impl</code>) it include the terminal’s standard output, files, a buffer in memory, or TCP network connections. Scroll down in the <a href="https://doc.rust-lang.org/1.39.0/std/io/trait.Write.html">documentation for <code>std::io::Write</code></a> to see a list of “Implementors”.</p>
<p>With that knowledge, let’s change our function to accept a third parameter. It can be any type that implements <code>Write</code>. This way, we can supply a simple string in our tests and make assertions on it. Here is how we can write this version of <code>find_matches</code>:</p>
<pre><code class="language-rust ignore">fn find_matches(content: &amp;str, pattern: &amp;str, mut writer: impl std::io::Write) {
    for line in content.lines() {
        if line.contains(pattern) {
            writeln!(writer, "{}", line);
        }
    }
}</code></pre>
<p>The new parameter is <code>mut writer</code>, i.e., a mutable thing we call “writer”. Its type is <code>impl std::io::Write</code>, which you can read as a placeholder for any type that implements the <code>Write</code> trait. Note how we replaced the <code>println!(…)</code> we used earlier with <code>writeln!(writer, …)</code>. <code>println!</code> works the same as <code>writeln!</code>, but it always uses standard output.</p>
<p>Now, we can test for the output:</p>
<pre><code class="language-rust ignore">#[test]
fn find_a_match() {
    let mut result = Vec::new();
    find_matches("lorem ipsum\ndolor sit amet", "lorem", &amp;mut result);
    assert_eq!(result, b"lorem ipsum\n");
}</code></pre>
<p>To use this in our application code, we have to change the call to <code>find_matches</code> in <code>main</code> by adding <a href="https://doc.rust-lang.org/1.39.0/std/io/fn.stdout.html"><code>&amp;mut std::io::stdout()</code></a> as the third parameter. Here’s an example of a main function that builds on what we’ve seen in the previous chapters and uses our extracted <code>find_matches</code> function:</p>
<pre><code class="language-rust ignore">fn main() -&gt; Result&lt;()&gt; {
    let args = Cli::parse();
    let content = std::fs::read_to_string(&amp;args.path)
        .with_context(|| format!("could not read file `{}`", args.path.display()))?;

    find_matches(&amp;content, &amp;args.pattern, &amp;mut std::io::stdout());

    Ok(())
}</code></pre>
<aside class="note">
<p><strong>Note:</strong> Since <code>stdout</code> expects bytes (not strings), we use <code>std::io::Write</code> instead of <code>std::fmt::Write</code>. As a result, we give an empty vector as <code>writer</code> in our tests (its type will be inferred to <code>Vec&lt;u8&gt;</code>), and in the <code>assert_eq!</code>, we use <code>b"foo"</code>. The <code>b</code> prefix makes this a <em>byte string literal</em>, so its type is going to be <code>&amp;[u8]</code> instead of <code>&amp;str</code>.</p>
</aside>
<aside class="note">
<p><strong>참고:</strong> 이 함수가 <code>String</code>을 반환하도록 만들 수도 있지만 그렇게 하면 동작이 변경됩니다. 터미널에 직접 쓰는 대신 모든 것을 문자열로 수집하고 마지막에 모든 결과를 한 번에 덤프합니다.</p>
</aside>
<aside class="exercise">
<p><strong>Exercise for the reader:</strong> <a href="https://doc.rust-lang.org/1.39.0/std/macro.writeln.html"><code>writeln!</code></a> returns an <a href="https://doc.rust-lang.org/1.39.0/std/io/type.Result.html"><code>io::Result</code></a> because writing can fail (for example, when the buffer is full and cannot be expanded). Add error handling to <code>find_matches</code>.</p>
</aside>
<p>We’ve just seen how to make this piece of code testable. We have:</p>
<ol>
<li>Identified one of the core pieces of our application.</li>
<li>Put it into its own function.</li>
<li>Made it more flexible.</li>
</ol>
<p>목표는 테스트 가능하게 만드는 것이었지만, 우리가 얻은 결과는 실제로 매우 관용적이고 재사용 가능한 Rust 코드 조각입니다. 정말 멋집니다!</p>
<h2 id="코드를-라이브러리-및-바이너리-대상으로-분할"><a class="header" href="#코드를-라이브러리-및-바이너리-대상으로-분할">코드를 라이브러리 및 바이너리 대상으로 분할</a></h2>
<p>We can do one more thing here. So far, we’ve put everything we wrote into the <code>src/main.rs</code> file. This means our current project produces a single binary, but we can also make our code available as a library like this:</p>
<ol>
<li><code>find_matches</code> 함수를 새 <code>src/lib.rs</code>에 넣습니다.</li>
<li>Add a <code>pub</code> in front of the <code>fn</code> to make it something that users of our library can access (i.e. <code>pub fn find_matches</code>).</li>
<li><code>src/main.rs</code>에서 <code>find_matches</code>를 제거합니다.</li>
<li>In <code>fn main</code>, prepend the call to <code>find_matches</code> with <code>grrs::</code> so that it’s now <code>grrs::find_matches(…)</code>. This means it uses the function from the library we just wrote!</li>
</ol>
<p>The way Rust deals with projects is quite flexible, and it’s a good idea to think about what to put into the library part of your crate early on. You can, for example, think about writing a library for your application-specific logic first and then use it in your CLI just like any other library. Or, if your project has multiple binaries, you can put the common functionality into the library part of that crate.</p>
<aside class="note">
<p><strong>Note:</strong> Speaking of putting everything into a <code>src/main.rs</code>, if we continue to do that, it’ll become difficult to read. The <a href="https://doc.rust-lang.org/1.39.0/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">module system</a> can help you structure and organize your code.</p>
</aside>
<h2 id="실행하여-cli-응용-프로그램-테스트"><a class="header" href="#실행하여-cli-응용-프로그램-테스트">실행하여 CLI 응용 프로그램 테스트</a></h2>
<p>Thus far, we’ve gone out of our way to test the <em>business logic</em> of our application, which turned out to be the <code>find_matches</code> function. This is very valuable and is a great first step towards a well-tested code base. Usually, these kinds of tests are called “unit tests”.</p>
<p>There is a lot of code we aren’t testing: Everything that we wrote to deal with the outside world! Imagine you wrote the main function but accidentally left in a hard-coded string instead of using the argument of the user-supplied path. We should write tests for that, too! This level of testing is often called integration testing or system testing.</p>
<p>At its core, we are still writing functions and annotating them with <code>#[test]</code>. It’s just a matter of what we do inside these functions. For example, we’ll want to use the main binary of our project and run it like a regular program. We will put these tests into a new file in a new directory: <code>tests/cli.rs</code>.</p>
<aside>
<p><strong>Note:</strong> By convention, <code>cargo</code> will look for integration tests in the <code>tests/</code> directory. Similarly, it will look for benchmarks in <code>benches/</code> and examples in <code>examples/</code>. These conventions also extend to your main source code: libraries have a <code>src/lib.rs</code> file, the main binary is <code>src/main.rs</code>, and if there are multiple binaries, cargo expects them to be in <code>src/bin/&lt;name&gt;.rs</code>. Following these conventions will make your code base more discoverable by people used to reading Rust code.</p>
</aside>
<p><code>grrs</code> is a small tool that searches for a string in a file. We have already tested that we can find a match. Let’s think about what other functionality we can test.</p>
<p>Here is what I came up with:</p>
<ul>
<li>파일이 존재하지 않으면 어떻게 됩니까?</li>
<li>일치하는 항목이 없을 때 출력은 무엇입니까?</li>
<li>인수 중 하나(또는 둘 다)를 잊어버리면 프로그램이 오류와 함께 종료됩니까?</li>
</ul>
<p>These are all valid test cases. Additionally, we should include one test case for the happy path: we found at least one match and we print it.</p>
<p>To make these kinds of tests easier, we’re going to use the <a href="https://docs.rs/assert_cmd"><code>assert_cmd</code></a> crate. It has a bunch of neat helpers that allow us to run our main binary and see how it behaves. We’ll also add the <a href="https://docs.rs/predicates"><code>predicates</code></a> crate, which helps us write assertions that <code>assert_cmd</code> can test against and that have great error messages. We won’t add those dependencies to the main list, but to a <code>dev dependencies</code> section in our <code>Cargo.toml</code>. They are only required when developing the crate, not when using it.</p>
<pre><code class="language-toml">[dev-dependencies]
assert_cmd = "2.0.14"
predicates = "3.1.0"
</code></pre>
<p>This sounds like a lot of setup. Nevertheless, let’s dive right in and create our <code>tests/cli.rs</code> file:</p>
<pre><code class="language-rust ignore">use assert_cmd::cargo::*; // Import cargo_bin_cmd! macro and methods
use predicates::prelude::*; // 어설션 작성에 사용

#[test]
fn file_doesnt_exist() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut cmd = cargo_bin_cmd!("grrs");

    cmd.arg("foobar").arg("test/file/doesnt/exist");
    cmd.assert()
        .failure()
        .stderr(predicate::str::contains("could not read file"));

    Ok(())
}
</code></pre>
<p>You can run this test with <code>cargo test</code>, just like the tests we wrote above. It might take a little longer the first time as <code>Command::cargo_bin("grrs")</code> needs to compile your main binary.</p>
<h2 id="테스트-파일-생성"><a class="header" href="#테스트-파일-생성">테스트 파일 생성</a></h2>
<p>The test we’ve just seen only checks that our program writes an error message when the input file doesn’t exist. That’s an important test to have, but maybe not the most important one. Let’s test that we will actually print the matches we found in a file!</p>
<p>We’ll need to have a file whose content we know so that we can know what our program <em>should</em> return and check this expectation in our code. One idea might be to add a file to the project with custom content and use that in our tests. Another would be to create temporary files in our tests. For this tutorial, we’ll have a look at the latter approach. It is more flexible and will work for other cases; for example, when you are testing programs that change the files.</p>
<p>이러한 임시 파일을 만들려면 <a href="https://docs.rs/assert_fs"><code>assert_fs</code></a> 크레이트를 사용할 것입니다. <code>Cargo.toml</code>의 <code>dev-dependencies</code>에 추가해 봅시다.</p>
<pre><code class="language-toml">assert_fs = "1.1.1"
</code></pre>
<p>Here is a new test case that creates a temp file (a “named” one so we can get its path), fills it with some text, and then runs our program to see if we get the correct output. You can write it below the other test case. When the variable <code>file</code> goes out of scope at the end of the function, the actual temporary file will automatically get deleted.</p>
<pre><code class="language-rust ignore">
#[test]
fn find_content_in_file() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let file = assert_fs::NamedTempFile::new("sample.txt")?;
    file.write_str("A test\nActual content\nMore content\nAnother test")?;

    let mut cmd = cargo_bin_cmd!("grrs");
    cmd.arg("test").arg(file.path());
    cmd.assert()
        .success()
        .stdout(predicate::str::contains("A test\nAnother test"));

    Ok(())
}</code></pre>
<aside class="exercise">
<p><strong>독자를 위한 연습:</strong> 빈 문자열을 패턴으로 전달하기 위한 통합 테스트를 추가하세요. 필요에 따라 프로그램을 조정하세요.</p>
</aside>
<h2 id="무엇을-테스트해야-할까요"><a class="header" href="#무엇을-테스트해야-할까요">무엇을 테스트해야 할까요?</a></h2>
<p>While it can certainly be fun to write integration tests, it will take some time to write them as well as to update them when your application’s behavior changes. To make sure you use your time wisely, you should ask yourself what you should test.</p>
<p>In general, it’s a good idea to write integration tests for all types of behavior that a user can observe. This means that you don’t need to cover all edge cases. It usually suffices to have examples for the different types and rely on unit tests to cover the edge cases.</p>
<p>It is also a good idea not to focus your tests on things you can’t actively control. It would be a bad idea to test the exact layout of <code>--help</code> since it is generated for you. Instead, you might just want to check that certain elements are present.</p>
<p>Depending on the nature of your program, you can also try to add more testing techniques. For example, if you have extracted parts of your program and find yourself writing a lot of example cases as unit tests while trying to come up with all the edge cases, you should look into <a href="https://docs.rs/proptest"><code>proptest</code></a>. If you have a program that consumes arbitrary files and parses them, try to write a <a href="https://rust-fuzz.github.io/book/introduction.html">fuzzer</a> to find bugs in edge cases.</p>
<aside>
<p><strong>참고:</strong> 이 장에서 사용된 전체 실행 가능한 소스 코드는 <a href="https://github.com/rust-cli/book/tree/master/src/tutorial/testing">이 책의 리포지토리</a>에서 찾을 수 있습니다.</p>
</aside>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../tutorial/output.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../tutorial/packaging.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../tutorial/output.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../tutorial/packaging.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/language-picker.js"></script>


    </div>
    </body>
</html>
