<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>테스트 - Command Line Applications in Rust</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/rust-cli";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/tutorial/testing.md`;
                    } else {
                        canonical_href = `${base}/${lang}/tutorial/testing.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../src/special-content.css">
        <link rel="stylesheet" href="../theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Command Line Applications in Rust</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="테스트"><a class="header" href="#테스트">테스트</a></h1>
<p>수십 년간의 소프트웨어 개발을 통해 사람들은 한 가지 진실을 발견했습니다. 테스트되지 않은 소프트웨어는 거의 작동하지 않습니다. (많은 사람들은 “대부분의 테스트된 소프트웨어도 작동하지 않는다“고까지 말할 것입니다. 하지만 우리는 모두 여기서 낙관주의자입니다, 그렇죠?) 따라서 프로그램이 예상대로 작동하는지 확인하려면 테스트하는 것이 현명합니다.</p>
<p>이를 수행하는 한 가지 쉬운 방법은 프로그램이 수행해야 할 작업을 설명하는 <code>README</code> 파일을 작성하는 것입니다. 그리고 새 릴리스를 만들 준비가 되면 <code>README</code>를 살펴보고 동작이 여전히 예상대로인지 확인합니다. 프로그램이 잘못된 입력에 어떻게 반응해야 하는지 기록하여 이 연습을 더 엄격하게 만들 수도 있습니다.</p>
<p>여기 또 다른 멋진 아이디어가 있습니다. 코드를 작성하기 전에 <code>README</code>를 작성하세요.</p>
<aside>
<p><strong>참고:</strong> <a href="https://en.wikipedia.org/wiki/Test-driven_development">테스트 주도 개발</a>(TDD)에 대해 들어본 적이 없다면 살펴보세요.</p>
</aside>
<h2 id="자동화된-테스트"><a class="header" href="#자동화된-테스트">자동화된 테스트</a></h2>
<p>이제 이것은 모두 괜찮지만 이 모든 것을 수동으로 수행하시겠습니까? 시간이 많이 걸릴 수 있습니다. 동시에 많은 사람들이 컴퓨터에 일을 시키는 것을 즐기게 되었습니다. 이러한 테스트를 자동화하는 방법에 대해 이야기해 봅시다.</p>
<p>Rust에는 내장 테스트 프레임워크가 있으므로 첫 번째 테스트를 작성하는 것부터 시작하겠습니다.</p>
<pre><code class="language-rust ignore"><span class="boring">fn answer() -&gt; i32 {
</span><span class="boring">  42
</span><span class="boring">}
</span><span class="boring">
</span>#[test]
fn check_answer_validity() {
    assert_eq!(answer(), 42);
}</code></pre>
<p>이 코드 조각을 패키지의 거의 모든 소스 파일에 넣을 수 있으며 <code>cargo test</code>가 이를 찾아 실행합니다. 여기서 핵심은 <code>#[test]</code> 속성입니다. 이를 통해 빌드 시스템이 이러한 함수를 검색하고 테스트로 실행하여 패닉이 발생하지 않는지 확인할 수 있습니다.</p>
<aside class="exercise">
<p><strong>독자를 위한 연습:</strong> 이 테스트가 작동하도록 만드세요.</p>
<p>다음과 같은 출력이 표시되어야 합니다.</p>
<pre><code class="language-text">running 1 test
test check_answer_validity ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
</aside>
<p>이제 테스트를 작성하는 _방법_을 보았으므로 _무엇_을 테스트해야 하는지 알아내야 합니다. 보시다시피 함수에 대한 어설션을 작성하는 것은 매우 쉽습니다. 하지만 CLI 응용 프로그램은 종종 하나 이상의 함수입니다! 더 나쁜 것은 종종 사용자 입력을 처리하고 파일을 읽고 출력을 쓴다는 것입니다.</p>
<h2 id="코드를-테스트-가능하게-만들기"><a class="header" href="#코드를-테스트-가능하게-만들기">코드를 테스트 가능하게 만들기</a></h2>
<p>기능을 테스트하는 데는 두 가지 보완적인 접근 방식이 있습니다. 완전한 응용 프로그램을 구성하는 작은 단위를 테스트하는 것을 “단위 테스트“라고 합니다. 최종 응용 프로그램을 “외부에서” 테스트하는 것을 “블랙박스 테스트” 또는 “통합 테스트“라고도 합니다. 첫 번째부터 시작하겠습니다.</p>
<p>무엇을 테스트해야 하는지 알아보기 위해 프로그램 기능이 무엇인지 살펴보겠습니다. 주로 <code>grrs</code>는 주어진 패턴과 일치하는 줄을 인쇄해야 합니다. 따라서 _정확히 이것_에 대한 단위 테스트를 작성해 봅시다. 가장 중요한 로직이 작동하는지 확인하고 싶고, 주변에 있는 설정 코드(예: CLI 인수 처리)에 의존하지 않는 방식으로 수행하고 싶습니다.</p>
<p><code>grrs</code>의 <a href="impl-draft.html">첫 번째 구현</a>으로 돌아가서 <code>main</code> 함수에 이 코드 블록을 추가했습니다.</p>
<pre><code class="language-rust ignore">// ...
for line in content.lines() {
    if line.contains(&amp;args.pattern) {
        println!("{}", line);
    }
}</code></pre>
<p>안타깝게도 이것은 테스트하기가 쉽지 않습니다. 우선, <code>main</code> 함수에 있으므로 쉽게 호출할 수 없습니다. 이 코드 조각을 함수로 옮기면 쉽게 해결할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn find_matches(content: &amp;str, pattern: &amp;str) {
    for line in content.lines() {
        if line.contains(pattern) {
            println!("{}", line);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>이제 테스트에서 이 함수를 호출하고 출력이 무엇인지 확인할 수 있습니다.</p>
<pre><code class="language-rust ignore">#[test]
fn find_a_match() {
    find_matches("lorem ipsum\ndolor sit amet", "lorem");
    assert_eq!( // 어...</code></pre>
<p>아니면… 할 수 있을까요? 지금 <code>find_matches</code>는 <code>stdout</code>, 즉 터미널에 직접 인쇄합니다. 테스트에서 이것을 쉽게 캡처할 수 없습니다! 이것은 구현 후에 테스트를 작성할 때 종종 발생하는 문제입니다. 우리는 사용되는 컨텍스트에 확고하게 통합된 함수를 작성했습니다.</p>
<aside class="note">
<p><strong>참고:</strong> 이것은 작은 CLI 응용 프로그램을 작성할 때 완전히 괜찮습니다. 모든 것을 테스트 가능하게 만들 필요는 없습니다! 그러나 코드의 어떤 부분에 대해 단위 테스트를 작성하고 싶은지 생각하는 것이 중요합니다. 이 함수를 테스트 가능하게 변경하는 것이 쉽다는 것을 알게 되겠지만 항상 그런 것은 아닙니다.</p>
</aside>
<p>좋습니다, 어떻게 테스트 가능하게 만들 수 있을까요? 어떻게든 출력을 캡처해야 합니다. Rust의 표준 라이브러리에는 I/O(입력/출력)를 처리하기 위한 몇 가지 깔끔한 추상화가 있으며 <a href="https://doc.rust-lang.org/1.39.0/std/io/trait.Write.html"><code>std::io::Write</code></a>라는 것을 사용할 것입니다. 이것은 문자열뿐만 아니라 <code>stdout</code>도 포함하여 우리가 쓸 수 있는 것들을 추상화하는 <a href="https://doc.rust-lang.org/book/ch10-02-traits.html">특성</a>입니다.</p>
<p>Rust의 맥락에서 “특성“이라는 말을 처음 들어본다면, 당신은 운이 좋습니다. 특성은 Rust의 가장 강력한 기능 중 하나입니다. Java의 인터페이스나 Haskell의 유형 클래스(어느 쪽이 더 익숙하든)와 같다고 생각할 수 있습니다. 이를 통해 다른 유형에서 공유할 수 있는 동작을 추상화할 수 있습니다. 특성을 사용하는 코드는 매우 일반적이고 유연한 방식으로 아이디어를 표현할 수 있습니다. 하지만 이것은 읽기 어려워질 수도 있다는 것을 의미합니다. 겁먹지 마세요. 수년 동안 Rust를 사용해 온 사람들조차도 제네릭 코드가 즉시 무엇을 하는지 항상 이해하지는 못합니다. 이 경우 구체적인 용도를 생각하는 것이 도움이 됩니다. 예를 들어, 우리의 경우 추상화하는 동작은 “쓰기“입니다. 이를 구현하는( “impl”) 유형의 예로는 터미널의 표준 출력, 파일, 메모리의 버퍼 또는 TCP 네트워크 연결이 있습니다. (<a href="https://doc.rust-lang.org/1.39.0/std/io/trait.Write.html"><code>std::io::Write</code>에 대한 문서</a>에서 “구현자” 목록을 보려면 아래로 스크롤하세요.)</p>
<p>그 지식을 바탕으로 함수가 세 번째 매개변수를 받도록 변경해 봅시다. <code>Write</code>를 구현하는 모든 유형이어야 합니다. 이렇게 하면 테스트에서 간단한 문자열을 제공하고 이에 대한 어설션을 만들 수 있습니다. 다음은 이 버전의 <code>find_matches</code>를 작성하는 방법입니다.</p>
<pre><code class="language-rust ignore">fn find_matches(content: &amp;str, pattern: &amp;str, mut writer: impl std::io::Write) {
    for line in content.lines() {
        if line.contains(pattern) {
            writeln!(writer, "{}", line);
        }
    }
}</code></pre>
<p>새 매개변수는 <code>mut writer</code>, 즉 “writer“라고 부르는 변경 가능한 것입니다. 유형은 <code>impl std::io::Write</code>이며, 이는 “<code>Write</code> 특성을 구현하는 모든 유형에 대한 자리 표시자“로 읽을 수 있습니다. 또한 이전에 사용했던 <code>println!(…)</code>을 <code>writeln!(writer, …)</code>으로 바꾼 방법도 주목하세요. <code>println!</code>은 <code>writeln!</code>과 동일하게 작동하지만 항상 표준 출력을 사용합니다.</p>
<p>이제 출력을 테스트할 수 있습니다.</p>
<pre><code class="language-rust ignore">#[test]
fn find_a_match() {
    let mut result = Vec::new();
    find_matches("lorem ipsum\ndolor sit amet", "lorem", &amp;mut result);
    assert_eq!(result, b"lorem ipsum\n");
}</code></pre>
<p>이제 응용 프로그램 코드에서 이것을 사용하려면 <code>main</code>에서 <code>find_matches</code>에 대한 호출을 세 번째 매개변수로 <a href="https://doc.rust-lang.org/1.39.0/std/io/fn.stdout.html"><code>&amp;mut std::io::stdout()</code></a>을 추가하여 변경해야 합니다. 다음은 이전 장에서 본 내용을 기반으로 하고 추출된 <code>find_matches</code> 함수를 사용하는 <code>main</code> 함수의 예입니다.</p>
<pre><code class="language-rust ignore">fn main() -&gt; Result&lt;()&gt; {
    let args = Cli::parse();
    let content = std::fs::read_to_string(&amp;args.path)
        .with_context(|| format!("could not read file `{}`", args.path.display()))?;

    find_matches(&amp;content, &amp;args.pattern, &amp;mut std::io::stdout());

    Ok(())
}</code></pre>
<aside class="note">
<p><strong>참고:</strong> <code>stdout</code>은 바이트(문자열이 아님)를 예상하므로 <code>std::fmt::Write</code> 대신 <code>std::io::Write</code>를 사용합니다. 결과적으로 테스트에서 빈 벡터를 “writer“로 제공하고(유형은 <code>Vec&lt;u8&gt;</code>로 유추됨), <code>assert_eq!</code>에서는 <code>b"foo"</code>를 사용합니다. (<code>b</code> 접두사는 이것을 _바이트 문자열 리터럴_로 만들므로 유형은 <code>&amp;str</code> 대신 <code>&amp;[u8]</code>가 됩니다).</p>
</aside>
<aside class="note">
<p><strong>참고:</strong> 이 함수가 <code>String</code>을 반환하도록 만들 수도 있지만 그렇게 하면 동작이 변경됩니다. 터미널에 직접 쓰는 대신 모든 것을 문자열로 수집하고 마지막에 모든 결과를 한 번에 덤프합니다.</p>
</aside>
<aside class="exercise">
<p><strong>독자를 위한 연습:</strong> <a href="https://doc.rust-lang.org/1.39.0/std/macro.writeln.html"><code>writeln!</code></a>은 예를 들어 버퍼가 가득 차서 확장할 수 없을 때 쓰기가 실패할 수 있기 때문에 <a href="https://doc.rust-lang.org/1.39.0/std/io/type.Result.html"><code>io::Result</code></a>를 반환합니다. <code>find_matches</code>에 오류 처리를 추가하세요.</p>
</aside>
<p>이 코드 조각을 쉽게 테스트할 수 있는 방법을 방금 보았습니다. 우리는</p>
<ol>
<li>우리 응용 프로그램의 핵심 부분 중 하나를 식별했습니다.</li>
<li>자체 함수에 넣었습니다.</li>
<li>그리고 더 유연하게 만들었습니다.</li>
</ol>
<p>목표는 테스트 가능하게 만드는 것이었지만, 우리가 얻은 결과는 실제로 매우 관용적이고 재사용 가능한 Rust 코드 조각입니다. 정말 멋집니다!</p>
<h2 id="코드를-라이브러리-및-바이너리-대상으로-분할"><a class="header" href="#코드를-라이브러리-및-바이너리-대상으로-분할">코드를 라이브러리 및 바이너리 대상으로 분할</a></h2>
<p>여기서 한 가지 더 할 수 있습니다. 지금까지 작성한 모든 것을 <code>src/main.rs</code> 파일에 넣었습니다. 이것은 현재 프로젝트가 단일 바이너리를 생성한다는 것을 의미합니다. 하지만 다음과 같이 코드를 라이브러리로 사용할 수도 있습니다.</p>
<ol>
<li><code>find_matches</code> 함수를 새 <code>src/lib.rs</code>에 넣습니다.</li>
<li><code>fn</code> 앞에 <code>pub</code>를 추가하여(<code>pub fn find_matches</code>가 되도록) 라이브러리 사용자가 액세스할 수 있도록 합니다.</li>
<li><code>src/main.rs</code>에서 <code>find_matches</code>를 제거합니다.</li>
<li><code>fn main</code>에서 <code>find_matches</code>에 대한 호출 앞에 <code>grrs::</code>를 붙여 이제 <code>grrs::find_matches(…)</code>가 되도록 합니다. 이것은 방금 작성한 라이브러리의 함수를 사용한다는 것을 의미합니다!</li>
</ol>
<p>Rust가 프로젝트를 처리하는 방식은 매우 유연하며 크레이트의 라이브러리 부분에 무엇을 넣을지 미리 생각하는 것이 좋습니다. 예를 들어, 응용 프로그램별 로직을 위한 라이브러리를 먼저 작성한 다음 다른 라이브러리처럼 CLI에서 사용할 수 있습니다. 또는 프로젝트에 여러 바이너리가 있는 경우 공통 기능을 해당 크레이트의 라이브러리 부분에 넣을 수 있습니다.</p>
<aside class="note">
<p><strong>참고:</strong> 모든 것을 <code>src/main.rs</code>에 넣는 것에 대해 말하자면, 계속 그렇게 하면 읽기 어려워질 것입니다. <a href="https://doc.rust-lang.org/1.39.0/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">모듈 시스템</a>은 코드를 구조화하고 구성하는 데 도움이 될 수 있습니다.</p>
</aside>
<h2 id="실행하여-cli-응용-프로그램-테스트"><a class="header" href="#실행하여-cli-응용-프로그램-테스트">실행하여 CLI 응용 프로그램 테스트</a></h2>
<p>지금까지 우리는 응용 프로그램의 _비즈니스 로직_을 테스트하기 위해 많은 노력을 기울였으며, 이는 <code>find_matches</code> 함수로 판명되었습니다. 이것은 매우 가치가 있으며 잘 테스트된 코드 기반을 향한 훌륭한 첫 걸음입니다. (일반적으로 이러한 종류의 테스트를 “단위 테스트“라고 합니다.)</p>
<p>하지만 테스트하지 않는 코드가 많이 있습니다. 외부 세계를 처리하기 위해 작성한 모든 것입니다! <code>main</code> 함수를 작성했지만 사용자 제공 경로의 인수를 사용하는 대신 하드 코딩된 문자열을 실수로 남겨 두었다고 상상해 보십시오. 이에 대한 테스트도 작성해야 합니다! (이 수준의 테스트는 종종 “통합 테스트” 또는 “시스템 테스트“라고 합니다.)</p>
<p>핵심적으로 우리는 여전히 함수를 작성하고 <code>#[test]</code>로 주석을 답니다. 이러한 함수 내부에서 무엇을 하는지가 문제입니다. 예를 들어, 프로젝트의 주 바이너리를 사용하고 일반 프로그램처럼 실행하고 싶을 것입니다. 또한 이러한 테스트를 새 디렉토리의 새 파일인 <code>tests/cli.rs</code>에 넣을 것입니다.</p>
<aside>
<p><strong>참고:</strong> 규칙에 따라 <code>cargo</code>는 <code>tests/</code> 디렉토리에서 통합 테스트를 찾습니다. 마찬가지로 <code>benches/</code>에서 벤치마크를, <code>examples/</code>에서 예제를 찾습니다. 이러한 규칙은 주 소스 코드에도 적용됩니다. 라이브러리에는 <code>src/lib.rs</code> 파일이 있고, 주 바이너리는 <code>src/main.rs</code>이거나, 여러 바이너리가 있는 경우 cargo는 <code>src/bin/&lt;name&gt;.rs</code>에 있을 것으로 예상합니다. 이러한 규칙을 따르면 Rust 코드를 읽는 데 익숙한 사람들이 코드 기반을 더 쉽게 찾을 수 있습니다.</p>
</aside>
<p>다시 말해, <code>grrs</code>는 파일에서 문자열을 검색하는 작은 도구입니다. 이전에 일치 항목을 찾을 수 있는지 테스트했습니다. 테스트할 수 있는 다른 기능에 대해 생각해 봅시다.</p>
<p>제가 생각해 낸 것은 다음과 같습니다.</p>
<ul>
<li>파일이 존재하지 않으면 어떻게 됩니까?</li>
<li>일치하는 항목이 없을 때 출력은 무엇입니까?</li>
<li>인수 중 하나(또는 둘 다)를 잊어버리면 프로그램이 오류와 함께 종료됩니까?</li>
</ul>
<p>이것들은 모두 유효한 테스트 사례입니다. 또한 “해피 패스“에 대한 테스트 사례도 하나 포함해야 합니다. 즉, 하나 이상의 일치 항목을 찾았고 이를 인쇄합니다.</p>
<p>이러한 종류의 테스트를 더 쉽게 만들기 위해 <a href="https://docs.rs/assert_cmd"><code>assert_cmd</code></a> 크레이트를 사용할 것입니다. 여기에는 주 바이너리를 실행하고 동작 방식을 볼 수 있는 깔끔한 도우미가 많이 있습니다. 또한 <code>assert_cmd</code>가 테스트할 수 있는(그리고 훌륭한 오류 메시지가 있는) 어설션을 작성하는 데 도움이 되는 <a href="https://docs.rs/predicates"><code>predicates</code></a> 크레이트도 추가할 것입니다. 이러한 의존성은 주 목록이 아닌 <code>Cargo.toml</code>의 “개발 의존성” 섹션에 추가할 것입니다. 크레이트를 사용할 때가 아니라 개발할 때만 필요합니다.</p>
<pre><code class="language-toml">[dev-dependencies]
assert_cmd = "2.0.14"
predicates = "3.1.0"
</code></pre>
<p>설정이 많은 것 같습니다. 그럼에도 불구하고 바로 시작하여 <code>tests/cli.rs</code> 파일을 만들어 봅시다.</p>
<pre><code class="language-rust ignore">use assert_cmd::prelude::*; // 명령에 메서드 추가
use predicates::prelude::*; // 어설션 작성에 사용
use std::process::Command; // 프로그램 실행

#[test]
fn file_doesnt_exist() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut cmd = Command::cargo_bin("grrs")?;

    cmd.arg("foobar").arg("test/file/doesnt/exist");
    cmd.assert()
        .failure()
        .stderr(predicate::str::contains("could not read file"));

    Ok(())
}</code></pre>
<p>위에서 작성한 테스트와 마찬가지로 <code>cargo test</code>로 이 테스트를 실행할 수 있습니다. <code>Command::cargo_bin("grrs")</code>가 주 바이너리를 컴파일해야 하므로 처음에는 시간이 조금 더 걸릴 수 있습니다.</p>
<h2 id="테스트-파일-생성"><a class="header" href="#테스트-파일-생성">테스트 파일 생성</a></h2>
<p>방금 본 테스트는 입력 파일이 없을 때 프로그램이 오류 메시지를 작성하는지 확인하는 것뿐입니다. 이것은 중요한 테스트이지만 가장 중요한 테스트는 아닐 수 있습니다. 이제 파일에서 찾은 일치 항목을 실제로 인쇄하는지 테스트해 봅시다!</p>
<p>우리는 내용물을 아는 파일이 필요하므로 프로그램이 <em>반환해야</em> 하는 것을 알고 코드에서 이 기대를 확인할 수 있습니다. 한 가지 아이디어는 사용자 지정 콘텐츠가 있는 파일을 프로젝트에 추가하고 테스트에서 사용하는 것입니다. 다른 하나는 테스트에서 임시 파일을 만드는 것입니다. 이 튜토리얼에서는 후자의 접근 방식을 살펴보겠습니다. 주로 더 유연하고 다른 경우에도 작동하기 때문입니다. 예를 들어 파일을 변경하는 프로그램을 테스트할 때입니다.</p>
<p>이러한 임시 파일을 만들려면 <a href="https://docs.rs/assert_fs"><code>assert_fs</code></a> 크레이트를 사용할 것입니다. <code>Cargo.toml</code>의 <code>dev-dependencies</code>에 추가해 봅시다.</p>
<pre><code class="language-toml">assert_fs = "1.1.1"
</code></pre>
<p>다음은 다른 테스트 사례 아래에 작성할 수 있는 새 테스트 사례입니다. 먼저 임시 파일(경로를 얻을 수 있도록 “이름이 지정된” 파일)을 만들고 일부 텍스트로 채운 다음 프로그램을 실행하여 올바른 출력을 얻는지 확인합니다. <code>file</code>이 범위를 벗어나면(함수 끝에서) 실제 임시 파일이 자동으로 삭제됩니다.</p>
<pre><code class="language-rust ignore">use assert_fs::prelude::*;

#[test]
fn find_content_in_file() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let file = assert_fs::NamedTempFile::new("sample.txt")?;
    file.write_str("A test\nActual content\nMore content\nAnother test")?;

    let mut cmd = Command::cargo_bin("grrs")?;
    cmd.arg("test").arg(file.path());
    cmd.assert()
        .success()
        .stdout(predicate::str::contains("A test\nAnother test"));

    Ok(())
}</code></pre>
<aside class="exercise">
<p><strong>독자를 위한 연습:</strong> 빈 문자열을 패턴으로 전달하기 위한 통합 테스트를 추가하세요. 필요에 따라 프로그램을 조정하세요.</p>
</aside>
<h2 id="무엇을-테스트해야-할까요"><a class="header" href="#무엇을-테스트해야-할까요">무엇을 테스트해야 할까요?</a></h2>
<p>통합 테스트를 작성하는 것이 확실히 재미있을 수 있지만, 작성하는 데 시간이 걸리고 응용 프로그램의 동작이 변경될 때 업데이트하는 데도 시간이 걸립니다. 시간을 현명하게 사용하려면 무엇을 테스트해야 하는지 자문해야 합니다.</p>
<p>일반적으로 사용자가 관찰할 수 있는 모든 유형의 동작에 대해 통합 테스트를 작성하는 것이 좋습니다. 즉, 모든 엣지 케이스를 다룰 필요는 없습니다. 일반적으로 다른 유형에 대한 예제를 갖고 단위 테스트에 의존하여 엣지 케이스를 다루는 것으로 충분합니다.</p>
<p>또한 적극적으로 제어할 수 없는 것에 테스트를 집중하지 않는 것이 좋습니다. <code>--help</code>의 정확한 레이아웃은 자동으로 생성되므로 테스트하는 것은 좋지 않습니다. 대신 특정 요소가 있는지 확인하고 싶을 수 있습니다.</p>
<p>프로그램의 성격에 따라 더 많은 테스트 기술을 추가해 볼 수도 있습니다. 예를 들어, 프로그램의 일부를 추출하고 모든 엣지 케이스를 생각해 내려고 노력하면서 단위 테스트로 많은 예제 사례를 작성하는 자신을 발견하면 <a href="https://docs.rs/proptest"><code>proptest</code></a>를 살펴보아야 합니다. 임의의 파일을 사용하고 구문 분석하는 프로그램이 있는 경우 <a href="https://rust-fuzz.github.io/book/introduction.html">퍼저</a>를 작성하여 엣지 케이스에서 버그를 찾아보십시오.</p>
<aside>
<p><strong>참고:</strong> 이 장에서 사용된 전체 실행 가능한 소스 코드는 <a href="https://github.com/rust-cli/book/tree/master/src/tutorial/testing">이 책의 리포지토리</a>에서 찾을 수 있습니다.</p>
</aside>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../tutorial/output.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../tutorial/packaging.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../tutorial/output.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../tutorial/packaging.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/language-picker.js"></script>


    </div>
    </body>
</html>
