<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Command Line Applications in Rust</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/rust-cli";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/print.md`;
                    } else {
                        canonical_href = `${base}/${lang}/print.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/special-content.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Command Line Applications in Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust의-명령줄-앱"><a class="header" href="#rust의-명령줄-앱">Rust의 명령줄 앱</a></h1>
<p>Rust는 정적으로 컴파일되고, 훌륭한 도구와 빠르게 성장하는 생태계를 갖춘 빠른 언어입니다. 따라서 명령줄 응용 프로그램을 작성하는 데 매우 적합합니다. 작고, 이식 가능하며, 빠르게 실행되어야 합니다. 명령줄 응용 프로그램은 Rust 학습을 시작하거나 팀에 Rust를 소개하는 좋은 방법이기도 합니다!</p>
<p>간단한 명령줄 인터페이스(CLI)를 사용하여 프로그램을 작성하는 것은 언어에 익숙하지 않고 감을 잡고 싶은 초보자에게 훌륭한 연습입니다. 그러나 이 주제에는 나중에야 드러나는 많은 측면이 있습니다.</p>
<p>이 책은 다음과 같이 구성되어 있습니다. 빠른 튜토리얼로 시작하여 작동하는 CLI 도구를 완성하게 됩니다. Rust의 몇 가지 핵심 개념과 CLI 응용 프로그램의 주요 측면을 접하게 될 것입니다. 그 다음에는 이러한 측면 중 일부에 대해 더 자세히 설명하는 장이 이어집니다.</p>
<p>CLI 응용 프로그램에 바로 뛰어들기 전에 마지막으로 한 가지: 이 책에서 오류를 발견하거나 더 많은 콘텐츠를 작성하는 데 도움을 주고 싶다면 <a href="https://github.com/rust-cli/book">CLI 책 리포지토리</a>에서 소스를 찾을 수 있습니다. 여러분의 피드백을 기다리겠습니다! 감사합니다!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="15분-만에-명령줄-앱을-작성하여-rust-배우기"><a class="header" href="#15분-만에-명령줄-앱을-작성하여-rust-배우기">15분 만에 명령줄 앱을 작성하여 Rust 배우기</a></h1>
<p>이 튜토리얼은 <a href="https://rust-lang.org/">Rust</a>로 CLI(명령줄 인터페이스) 응용 프로그램을 작성하는 과정을 안내합니다. 실행 중인 프로그램(1.3장 정도)을 갖게 되기까지 약 15분이 소요됩니다. 그 후에는 작은 도구를 출시할 수 있는 지점에 도달할 때까지 프로그램을 계속 수정할 것입니다.</p>
<p>시작하는 방법과 더 많은 정보를 찾을 수 있는 위치에 대한 모든 필수 사항을 배우게 됩니다. 지금 당장 알 필요가 없는 부분은 건너뛰거나 언제든지 뛰어들 수 있습니다.</p>
<aside>
<p><strong>전제 조건:</strong> 이 튜토리얼은 프로그래밍에 대한 일반적인 소개를 대체하지 않으며 몇 가지 일반적인 개념에 익숙해야 합니다. 명령줄/터미널 사용에 익숙해야 합니다. 이미 다른 언어를 몇 가지 알고 있다면 Rust와의 좋은 첫 만남이 될 수 있습니다.</p>
<p><strong>도움 받기:</strong> 어느 시점에서든 사용된 기능에 압도되거나 혼란스러우면 Rust와 함께 제공되는 광범위한 공식 문서, 특히 The Rust Programming Language 책을 참조하세요. 대부분의 Rust 설치(<code>rustup doc</code>)와 함께 제공되며 <a href="https://doc.rust-lang.org">doc.rust-lang.org</a>에서 온라인으로 볼 수 있습니다.</p>
<p>질문하는 것도 매우 환영합니다. Rust 커뮤니티는 친절하고 도움이 되는 것으로 알려져 있습니다. <a href="https://www.rust-lang.org/community">커뮤니티 페이지</a>를 방문하여 사람들이 Rust에 대해 토론하는 장소 목록을 확인하세요.</p>
</aside>
<p>어떤 종류의 프로젝트를 작성하고 싶으신가요? 간단한 것부터 시작해 봅시다. 작은 <code>grep</code> 클론을 작성해 봅시다. 즉, 문자열과 경로를 제공하면 주어진 문자열을 포함하는 줄만 인쇄하는 도구입니다. <code>grrs</code>(“그래스”로 발음)라고 부릅시다.</p>
<p>결국에는 다음과 같이 도구를 실행할 수 있기를 원합니다.</p>
<pre><code class="language-console">$ cat test.txt
foo: 10
bar: 20
baz: 30
$ grrs foo test.txt
foo: 10
$ grrs --help
[some help text explaining the available options]
</code></pre>
<aside class="note">
<p><strong>참고:</strong> 이 책은 <a href="https://doc.rust-lang.org/edition-guide/index.html">Rust 2018</a>용으로 작성되었습니다. 코드 예제는 Rust 2015에서도 사용할 수 있지만 약간 수정해야 할 수도 있습니다. 예를 들어 <code>extern crate foo;</code> 호출을 추가해야 합니다.</p>
<p>Rust 1.31.0 이상을 실행하고 <code>Cargo.toml</code> 파일의 <code>[package]</code> 섹션에 <code>edition = "2018"</code>이 설정되어 있는지 확인하세요.</p>
</aside>
<div style="break-before: page; page-break-before: always;"></div><h1 id="프로젝트-설정"><a class="header" href="#프로젝트-설정">프로젝트 설정</a></h1>
<p>아직 설치하지 않았다면 컴퓨터에 <a href="https://www.rust-lang.org/tools/install">Rust를 설치</a>하세요(몇 분밖에 걸리지 않습니다). 그런 다음 터미널을 열고 응용 프로그램 코드를 넣을 디렉토리로 이동합니다.</p>
<p>프로그래밍 프로젝트를 저장하는 디렉토리에서 <code>cargo new grrs</code>를 실행하여 시작합니다. 새로 생성된 <code>grrs</code> 디렉토리를 보면 Rust 프로젝트의 일반적인 설정을 찾을 수 있습니다.</p>
<ul>
<li>프로젝트에 대한 메타데이터를 포함하는 <code>Cargo.toml</code> 파일, 우리가 사용하는 의존성/외부 라이브러리 목록 포함.</li>
<li>(주) 바이너리의 진입점인 <code>src/main.rs</code> 파일.</li>
</ul>
<p><code>grrs</code> 디렉토리에서 <code>cargo run</code>을 실행하고 “Hello World“를 얻을 수 있다면 모든 설정이 완료된 것입니다.</p>
<h2 id="어떻게-보일-수-있는지"><a class="header" href="#어떻게-보일-수-있는지">어떻게 보일 수 있는지</a></h2>
<pre><code class="language-console">$ cargo new grrs
     Created binary (application) `grrs` package
$ cd grrs/
$ cargo run
   Compiling grrs v0.1.0 (/Users/pascal/code/grrs)
    Finished dev [unoptimized + debuginfo] target(s) in 0.70s
     Running `target/debug/grrs`
Hello, world!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="명령줄-인수-구문-분석"><a class="header" href="#명령줄-인수-구문-분석">명령줄 인수 구문 분석</a></h1>
<p>CLI 도구의 일반적인 호출은 다음과 같습니다.</p>
<pre><code class="language-console">$ grrs foobar test.txt
</code></pre>
<p>우리는 프로그램이 <code>test.txt</code>를 보고 <code>foobar</code>를 포함하는 줄을 인쇄하기를 기대합니다. 하지만 이 두 값을 어떻게 얻을 수 있을까요?</p>
<p>The text after the name of the program is often called the “command-line arguments”, or “command-line flags” (especially when they look like <code>--this</code>). Internally, the operating system usually represents them as a list of strings. Generally, they get separated by spaces.</p>
<p>There are many ways to think about these arguments and how to parse them into something easier to work with. You will also need to tell the users of your program which arguments they need to give and in which format they are expected.</p>
<h2 id="인수-가져오기"><a class="header" href="#인수-가져오기">인수 가져오기</a></h2>
<p>The standard library contains the function <a href="https://doc.rust-lang.org/1.39.0/std/env/fn.args.html"><code>std::env::args()</code></a> that gives you an <a href="https://doc.rust-lang.org/1.39.0/std/iter/index.html">iterator</a> of the given arguments. The first entry (at index <code>0</code>) will be the name used to invoke your program (e.g. <code>grrs</code>). The ones that follow are what the user wrote afterwards.</p>
<p>Getting the raw arguments this way is straightforward (in file <code>src/main.rs</code>):</p>
<pre><code class="language-rust ignore">fn main() {
    let pattern = std::env::args().nth(1).expect("no pattern given");
    let path = std::env::args().nth(2).expect("no path given");

    println!("pattern: {:?}, path: {:?}", pattern, path)
}</code></pre>
<p><code>cargo run</code>을 사용하여 실행할 수 있으며, <code>--</code> 뒤에 인수를 작성하여 전달합니다.</p>
<pre><code class="language-console">$ cargo run -- some-pattern some-file
    Finished dev [unoptimized + debuginfo] target(s) in 0.11s
     Running `target/debug/grrs some-pattern some-file`
pattern: "some-pattern", path: "some-file"
</code></pre>
<h2 id="cli-arguments-as-data-types"><a class="header" href="#cli-arguments-as-data-types">CLI arguments as data types</a></h2>
<p>텍스트 뭉치로 생각하는 대신 CLI 인수를 프로그램에 대한 입력을 나타내는 사용자 지정 데이터 유형으로 생각하는 것이 종종 더 좋습니다.</p>
<p>Looking at <code>grrs foobar test.txt</code>, there are two arguments: first, the <code>pattern</code> (the string to look for), and then, the <code>path</code> (the file to look in).</p>
<p>What more can we say about them? Well, for a start, both are required. We haven’t talked about any default values, so we expect our users to always provide two values. Furthermore, we can say a bit about their types: The pattern is expected to be a string while the second argument is expected to be a path to a file.</p>
<p>Rust에서는 처리하는 데이터를 중심으로 프로그램을 구성하는 것이 일반적이므로 이러한 CLI 인수를 보는 방식이 매우 적합합니다. 이것부터 시작해 봅시다(<code>src/main.rs</code> 파일에서 <code>fn main() {</code> 이전).</p>
<pre><code class="language-rust ignore">struct Cli {
    pattern: String,
    path: std::path::PathBuf,
}</code></pre>
<p>This defines a new structure (a <a href="https://doc.rust-lang.org/1.39.0/book/ch05-00-structs.html"><code>struct</code></a>) that has two fields to store data in: <code>pattern</code> and <code>path</code>.</p>
<aside>
<p><strong>참고:</strong> <a href="https://doc.rust-lang.org/1.39.0/std/path/struct.PathBuf.html"><code>PathBuf</code></a>는 <a href="https://doc.rust-lang.org/1.39.0/std/string/struct.String.html"><code>String</code></a>과 같지만 크로스 플랫폼에서 작동하는 파일 시스템 경로용입니다.</p>
</aside>
<p>Now, we still need to convert the actual arguments into this form. One option would be to manually parse the list of strings we get from the operating system and build the structure ourselves. It would look something like this:</p>
<pre><code class="language-rust ignore">fn main() {
    let pattern = std::env::args().nth(1).expect("no pattern given");
    let path = std::env::args().nth(2).expect("no path given");

    let args = Cli {
        pattern,
        path: std::path::PathBuf::from(path),
    };

    println!("pattern: {:?}, path: {:?}", args.pattern, args.path);
}</code></pre>
<p>이것은 작동하지만 그다지 편리하지 않습니다. <code>--pattern="foo"</code> 또는 <code>--pattern "foo"</code>를 지원해야 하는 요구 사항을 어떻게 처리하시겠습니까? <code>--help</code>를 어떻게 구현하시겠습니까?</p>
<h2 id="clap으로-cli-인수-구문-분석"><a class="header" href="#clap으로-cli-인수-구문-분석">Clap으로 CLI 인수 구문 분석</a></h2>
<p>A more convenient way is to use one of the many available libraries. The most popular library for parsing command-line arguments is called <a href="https://docs.rs/clap/"><code>clap</code></a>. It has all the functionality you’d expect, including support for sub-commands, <a href="https://docs.rs/clap_complete/">shell completions</a>, and great help messages.</p>
<p>먼저 <code>Cargo.toml</code> 파일의 <code>[dependencies]</code> 섹션에 <code>clap = { version = "4.0", features = ["derive"] }</code>를 추가하여 <code>clap</code>을 가져옵니다.</p>
<p>Now, we can write <code>use clap::Parser;</code> in our code and add <code>#[derive(Parser)]</code> right above our <code>struct Cli</code>. Let’s also write some documentation comments along the way.</p>
<p>다음과 같이 보일 것입니다(<code>src/main.rs</code> 파일에서 <code>fn main() {</code> 이전).</p>
<pre><code class="language-rust ignore">use clap::Parser;

/// 파일에서 패턴을 검색하고 해당 패턴을 포함하는 줄을 표시합니다.
#[derive(Parser)]
struct Cli {
    /// 찾을 패턴
    pattern: String,
    /// 읽을 파일의 경로
    path: std::path::PathBuf,
}</code></pre>
<aside class="node">
<p><strong>참고:</strong> 필드에 추가할 수 있는 사용자 지정 속성이 많이 있습니다. 예를 들어 <code>-o</code> 또는 <code>--output</code> 뒤의 인수에 이 필드를 사용하려면 <code>#[arg(short = 'o', long = "output")]</code>를 추가합니다. 자세한 내용은 <a href="https://docs.rs/clap/">clap 문서</a>를 참조하세요.</p>
</aside>
<p><code>Cli</code> 구조체 바로 아래에 템플릿에 <code>main</code> 함수가 포함되어 있습니다. 프로그램이 시작되면 이 함수를 호출합니다.</p>
<pre><code class="language-rust ignore">fn main() {
    let args = Cli::parse();

    println!("pattern: {:?}, path: {:?}", args.pattern, args.path)
}</code></pre>
<p>이렇게 하면 인수를 <code>Cli</code> 구조체로 구문 분석하려고 시도합니다.</p>
<p>But what if that fails? That’s the beauty of this approach: Clap knows which fields to expect and their expected format. It can automatically generate a nice <code>--help</code> message as well as give some great errors to suggest you pass <code>--output</code> when you wrote <code>--putput</code>.</p>
<aside class="note">
<p><strong>참고:</strong> <code>parse</code> 메서드는 <code>main</code> 함수에서 사용하기 위한 것입니다. 실패하면 오류 또는 도움말 메시지를 인쇄하고 즉시 프로그램을 종료합니다. 다른 곳에서는 사용하지 마세요!</p>
</aside>
<h2 id="마무리"><a class="header" href="#마무리">마무리</a></h2>
<p>이제 코드는 다음과 같아야 합니다.</p>
<pre><code class="language-rust ignore">use clap::Parser;

/// 파일에서 패턴을 검색하고 해당 패턴을 포함하는 줄을 표시합니다.
#[derive(Parser)]
struct Cli {
    /// 찾을 패턴
    pattern: String,
    /// 읽을 파일의 경로
    path: std::path::PathBuf,
}

fn main() {
    let args = Cli::parse();

    println!("pattern: {:?}, path: {:?}", args.pattern, args.path)
}</code></pre>
<p>인수 없이 실행:</p>
<pre><code class="language-console">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 10.16s
     Running `target/debug/grrs`
error: The following required arguments were not provided:
    &lt;pattern&gt;
    &lt;path&gt;

USAGE:
    grrs &lt;pattern&gt; &lt;path&gt;

For more information try --help
</code></pre>
<p>인수를 전달하여 실행:</p>
<pre><code class="language-console">$ cargo run -- some-pattern some-file
    Finished dev [unoptimized + debuginfo] target(s) in 0.11s
     Running `target/debug/grrs some-pattern some-file`
pattern: "some-pattern", path: "some-file"
</code></pre>
<p>출력은 프로그램이 인수를 <code>Cli</code> 구조체로 성공적으로 구문 분석했음을 보여줍니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="_grrs_의-첫-번째-구현"><a class="header" href="#_grrs_의-첫-번째-구현">_grrs_의 첫 번째 구현</a></h1>
<p>명령줄 인수에 대한 마지막 장 이후에 입력 데이터가 있으므로 실제 도구를 작성하기 시작할 수 있습니다. 현재 <code>main</code> 함수에는 이 줄만 포함되어 있습니다.</p>
<pre><code class="language-rust ignore">    let args = Cli::parse();</code></pre>
<p>We can drop the <code>println</code> statement that we put there temporarily to demonstrate that our program works as expected.</p>
<p>받은 파일을 여는 것부터 시작합시다.</p>
<pre><code class="language-rust ignore">    let content = std::fs::read_to_string(&amp;args.path).expect("could not read file");</code></pre>
<aside>
<p><strong>Note:</strong> See that <a href="https://doc.rust-lang.org/1.39.0/std/result/enum.Result.html#method.expect"><code>.expect</code></a> method here? This is a shortcut function that will make the program exit immediately when the value (in this case, the input file) could not be read. It’s not very pretty, and in the next chapter on <a href="tutorial/./errors.html">Nicer error reporting</a>, we will look at how to improve this.</p>
</aside>
<p>이제 줄을 반복하고 패턴을 포함하는 각 줄을 인쇄해 봅시다.</p>
<pre><code class="language-rust ignore">    for line in content.lines() {
        if line.contains(&amp;args.pattern) {
            println!("{}", line);
        }
    }</code></pre>
<h2 id="마무리-1"><a class="header" href="#마무리-1">마무리</a></h2>
<p>이제 코드는 다음과 같아야 합니다.</p>
<pre><code class="language-rust ignore">use clap::Parser;

/// 파일에서 패턴을 검색하고 해당 패턴을 포함하는 줄을 표시합니다.
#[derive(Parser)]
struct Cli {
    /// 찾을 패턴
    pattern: String,
    /// 읽을 파일의 경로
    path: std::path::PathBuf,
}

fn main() {
    let args = Cli::parse();
    let content = std::fs::read_to_string(&amp;args.path).expect("could not read file");

    for line in content.lines() {
        if line.contains(&amp;args.pattern) {
            println!("{}", line);
        }
    }
}</code></pre>
<p>시도해 보세요. <code>cargo run -- main src/main.rs</code>가 이제 작동해야 합니다!</p>
<aside class="exercise">
<p><strong>Exercise for the reader:</strong> This is not the best implementation as it will read the whole file into memory, no matter how large the file may be. Find a way to optimize it! (One idea might be to use a <a href="https://doc.rust-lang.org/1.39.0/std/io/struct.BufReader.html"><code>BufReader</code></a> instead of <code>read_to_string()</code>.)</p>
</aside>
<div style="break-before: page; page-break-before: always;"></div><h1 id="더-나은-오류-보고"><a class="header" href="#더-나은-오류-보고">더 나은 오류 보고</a></h1>
<p>We all can do nothing but accept the fact that errors will occur. In contrast to many other languages, it’s very hard not to notice and deal with this reality when using Rust because it doesn’t have exceptions. All possible error states are often encoded in the return types of functions.</p>
<h2 id="결과"><a class="header" href="#결과">결과</a></h2>
<p>A function like <a href="https://doc.rust-lang.org/1.39.0/std/fs/fn.read_to_string.html"><code>read_to_string</code></a> doesn’t return a string. Instead, it returns a <a href="https://doc.rust-lang.org/1.39.0/std/result/index.html"><code>Result</code></a> that contains either a <code>String</code> or an error of some type. In this case, <a href="https://doc.rust-lang.org/1.39.0/std/io/type.Result.html"><code>std::io::Error</code></a>.</p>
<p>어느 것인지 어떻게 알 수 있습니까? <code>Result</code>는 <code>enum</code>이므로 <code>match</code>를 사용하여 어떤 변형인지 확인할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = std::fs::read_to_string("test.txt");
match result {
    Ok(content) =&gt; { println!("File content: {}", content); }
    Err(error) =&gt; { println!("Oh noes: {}", error); }
}
<span class="boring">}</span></code></pre></pre>
<aside>
<p><strong>Note:</strong> Not sure what enums are or how they work in Rust? <a href="https://doc.rust-lang.org/1.39.0/book/ch06-00-enums.html">Check out this chapter of the Rust book</a> to get up to speed.</p>
</aside>
<h2 id="언래핑"><a class="header" href="#언래핑">언래핑</a></h2>
<p>Now, we were able to access the content of the file, but we can’t really do anything with it after the <code>match</code> block. For this, we’ll need to deal with the error case. While it’s a challenge that all arms of a <code>match</code> block need to return something of the same type, there’s a neat trick to get around that:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = std::fs::read_to_string("test.txt");
let content = match result {
    Ok(content) =&gt; { content },
    Err(error) =&gt; { panic!("Can't deal with {}, just exit here", error); }
};
println!("file content: {}", content);
<span class="boring">}</span></code></pre></pre>
<p>We can use the String in <code>content</code> after the match block, but if <code>result</code> were an error, the String wouldn’t exist. That’s fine because the program would exit before it ever reached a point where we use <code>content</code>.</p>
<p>This may seem drastic, but it’s very convenient. If your program needs to read that file and can’t do anything if the file doesn’t exist, exiting is a valid strategy. There’s even a shortcut method on <a href="https://doc.rust-lang.org/1.39.0/std/result/index.html"><code>Result</code></a> called <code>unwrap</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let content = std::fs::read_to_string("test.txt").unwrap();
<span class="boring">}</span></code></pre></pre>
<h2 id="패닉할-필요-없음"><a class="header" href="#패닉할-필요-없음">패닉할 필요 없음</a></h2>
<p>Of course, aborting the program is not the only way to deal with errors. Instead of using <code>panic!</code>, we can just use <code>return</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span>let result = std::fs::read_to_string("test.txt");
let content = match result {
    Ok(content) =&gt; { content },
    Err(error) =&gt; { return Err(error.into()); }
};
<span class="boring">Ok(())
</span><span class="boring">}</span></code></pre></pre>
<p>However, this changes the return type in our function. There was something hidden in our examples all this time: The function signature this code lives in. And in this last example with <code>return</code>, it becomes important. Here’s the <em>full</em> example:</p>
<pre><pre class="playground"><code class="language-rust no_run">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let result = std::fs::read_to_string("test.txt");
    let content = match result {
        Ok(content) =&gt; { content },
        Err(error) =&gt; { return Err(error.into()); }
    };
    println!("file content: {}", content);
    Ok(())
}</code></pre></pre>
<p>Our return type is a <code>Result</code>! This is why we can write <code>return Err(error);</code> in the second match arm. See how there is an <code>Ok(())</code> at the bottom? It’s the default return value of the function and means: “Result is okay, and has no content”.</p>
<aside>
<p><strong>Note:</strong> Why is this not written as <code>return Ok(());</code>? It easily could be – this is totally valid as well. The last expression of any block in Rust is its return value, and it is customary to omit a needless <code>return</code>.</p>
</aside>
<h2 id="물음표"><a class="header" href="#물음표">물음표</a></h2>
<p><code>.unwrap()</code>를 호출하는 것이 오류 암에 <code>panic!</code>이 있는 <code>match</code>의 바로 가기인 것처럼, 오류 암에 <code>return</code>이 있는 <code>match</code>에 대한 또 다른 바로 가기가 있습니다. <code>?</code>입니다.</p>
<p>맞습니다, 물음표입니다. 이 연산자를 <code>Result</code> 유형의 값에 추가할 수 있으며 Rust는 내부적으로 이를 우리가 방금 작성한 <code>match</code>와 매우 유사한 것으로 확장합니다.</p>
<p>시도해 보세요.</p>
<pre><pre class="playground"><code class="language-rust no_run">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let content = std::fs::read_to_string("test.txt")?;
    println!("file content: {}", content);
    Ok(())
}</code></pre></pre>
<p>매우 간결합니다!</p>
<aside>
<p><strong>Note:</strong> There are a few more things happening here that are not required to understand to work with this. For example, the error type in our <code>main</code> function is <code>Box&lt;dyn std::error::Error&gt;</code>, but we’ve seen above that <code>read_to_string</code> returns a <a href="https://doc.rust-lang.org/1.39.0/std/io/type.Result.html"><code>std::io::Error</code></a>. This works because <code>?</code> expands to code that  <em>converts</em> error types.</p>
<p><code>Box&lt;dyn std::error::Error&gt;</code> is also an interesting type. It’s a <code>Box</code> that can contain <em>any</em> type that implements the standard <a href="https://doc.rust-lang.org/1.39.0/std/error/trait.Error.html"><code>Error</code></a> trait. This means that all errors can be put into this box, and we can use <code>?</code> on all of the usual functions that return a <code>Result</code>.</p>
</aside>
<h2 id="컨텍스트-제공"><a class="header" href="#컨텍스트-제공">컨텍스트 제공</a></h2>
<p>The errors you get when using <code>?</code> in your <code>main</code> function are okay, but they are not great. For example, when you run <code>std::fs::read_to_string("test.txt")?</code> and the file <code>test.txt</code> doesn’t exist, you get this output:</p>
<pre><code class="language-text">Error: Os { code: 2, kind: NotFound, message: "No such file or directory" }
</code></pre>
<p>In cases where your code doesn’t actually contain the file name, it would be hard to tell which file was <code>NotFound</code>. There are multiple ways to deal with this.</p>
<p>For one, we can create our own error type and use that to build a custom error message:</p>
<pre><code class="language-rust ignore">#[derive(Debug)]
struct CustomError(String);

fn main() -&gt; Result&lt;(), CustomError&gt; {
    let path = "test.txt";
    let content = std::fs::read_to_string(path)
        .map_err(|err| CustomError(format!("Error reading `{}`: {}", path, err)))?;
    println!("file content: {}", content);
    Ok(())
}</code></pre>
<p>Running this, we’ll get our custom error message:</p>
<pre><code class="language-text">Error: CustomError("Error reading `test.txt`: No such file or directory (os error 2)")
</code></pre>
<p>Not very pretty, but we can adapt the debug output for our type later on.</p>
<p>This pattern is very common. It has one problem though: We don’t store the original error, only its string representation. The popular <a href="https://docs.rs/anyhow"><code>anyhow</code></a> library has a neat solution for that: Its <a href="https://docs.rs/anyhow/1.0/anyhow/trait.Context.html"><code>Context</code></a> trait can be used to add a description similar to our <code>CustomError</code> type. Additionally, it keeps the original error, so we get a “chain” of error messages pointing to the root cause.</p>
<p>먼저 <code>Cargo.toml</code> 파일의 <code>[dependencies]</code> 섹션에 <code>anyhow = "1.0"</code>을 추가하여 <code>anyhow</code> 크레이트를 가져옵니다.</p>
<p>The full example will look like this:</p>
<pre><code class="language-rust ignore">use anyhow::{Context, Result};

fn main() -&gt; Result&lt;()&gt; {
    let path = "test.txt";
    let content = std::fs::read_to_string(path)
        .with_context(|| format!("could not read file `{}`", path))?;
    println!("file content: {}", content);
    Ok(())
}</code></pre>
<p>오류가 인쇄됩니다.</p>
<pre><code class="language-text">Error: could not read file `test.txt`

Caused by:
    No such file or directory (os error 2)
</code></pre>
<h2 id="마무리-2"><a class="header" href="#마무리-2">마무리</a></h2>
<p>이제 코드는 다음과 같아야 합니다.</p>
<pre><code class="language-rust ignore">use anyhow::{Context, Result};
use clap::Parser;

/// 파일에서 패턴을 검색하고 해당 패턴을 포함하는 줄을 표시합니다.
#[derive(Parser)]
struct Cli {
    /// 찾을 패턴
    pattern: String,
    /// 읽을 파일의 경로
    path: std::path::PathBuf,
}

fn main() -&gt; Result&lt;()&gt; {
    let args = Cli::parse();

    let content = std::fs::read_to_string(&amp;args.path)
        .with_context(|| format!("could not read file `{}`", args.path.display()))?;

    for line in content.lines() {
        if line.contains(&amp;args.pattern) {
            println!("{}", line);
        }
    }

    Ok(())
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="출력"><a class="header" href="#출력">출력</a></h1>
<h2 id="hello-world-인쇄"><a class="header" href="#hello-world-인쇄">“Hello World” 인쇄</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!("Hello World");
<span class="boring">}</span></code></pre></pre>
<p>Well, that was easy. Great! Onto the next topic.</p>
<h2 id="println-사용"><a class="header" href="#println-사용"><code>println!</code> 사용</a></h2>
<p>You can pretty much print all the things you like with the <code>println!</code> macro. This macro has some pretty amazing capabilities, but also a special syntax. It expects a string literal that contains placeholders as the first parameter. The string will be filled in by the values of the parameters that follow as further arguments.</p>
<p>예를 들어:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 42;
println!("My lucky number is {}.", x);
<span class="boring">}</span></code></pre></pre>
<p>will print:</p>
<pre><code class="language-console">My lucky number is 42.
</code></pre>
<p>The curly braces (<code>{}</code>) in the string above is one of these placeholders. This is the default placeholder type that tries to print the given value in a human readable way. For numbers and strings, this works very well, but not all types can do that. This is why there is also a “debug representation” that you can get by filling the braces of the placeholder like this: <code>{:?}</code>.</p>
<p>예를 들어:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let xs = vec![1, 2, 3];
println!("The list is: {:?}", xs);
<span class="boring">}</span></code></pre></pre>
<p>will print:</p>
<pre><code class="language-console">The list is: [1, 2, 3]
</code></pre>
<p>If you want your own data types to be printable for debugging and logging, you can typically add a <code>#[derive(Debug)]</code> above their definition.</p>
<aside>
<p><strong>Note:</strong> “User-friendly” printing is done using the <a href="https://doc.rust-lang.org/1.39.0/std/fmt/trait.Display.html"><code>Display</code></a> trait and debug output (human-readable but targeted at developers) uses the <a href="https://doc.rust-lang.org/1.39.0/std/fmt/trait.Debug.html"><code>Debug</code></a> trait. You can find more information about the syntax you can use in <code>println!</code> in the <a href="https://doc.rust-lang.org/1.39.0/std/fmt/index.html">documentation for the <code>std::fmt</code> module</a>.</p>
</aside>
<h2 id="오류-인쇄"><a class="header" href="#오류-인쇄">오류 인쇄</a></h2>
<p>오류 인쇄는 사용자와 다른 도구가 출력을 파일이나 더 많은 도구로 파이프할 수 있도록 <code>stderr</code>를 통해 수행해야 합니다.</p>
<aside>
<p><strong>Note:</strong> On most operating systems, a program can write to two output streams: <code>stdout</code> and <code>stderr</code>. <code>stdout</code> is for the program’s actual output while <code>stderr</code> allows errors and other messages to be kept separate from <code>stdout</code>. That way, output can be stored to a file or piped to another program while errors are shown to the user.</p>
</aside>
<p>In Rust, this is achieved with <code>println!</code> and <code>eprintln!</code>, the former printing to <code>stdout</code> and the latter to <code>stderr</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!("This is information");
eprintln!("This is an error! :(");
<span class="boring">}</span></code></pre></pre>
<aside>
<p><strong>Beware</strong>: Printing <a href="https://en.wikipedia.org/wiki/ANSI_escape_code">escape codes</a> can be dangerous and put the user’s terminal into a weird state. Always be careful when manually printing them!</p>
<p>Ideally, you should be using a crate like <code>ansi_term</code> when dealing with raw escape codes to make your (and your user’s) life easier.</p>
</aside>
<h2 id="인쇄-성능에-대한-참고-사항"><a class="header" href="#인쇄-성능에-대한-참고-사항">인쇄 성능에 대한 참고 사항</a></h2>
<p>터미널에 인쇄하는 것은 놀라울 정도로 느립니다! 루프에서 <code>println!</code>과 같은 것을 호출하면 그렇지 않으면 빠른 프로그램에서 쉽게 병목 현상이 발생할 수 있습니다. 이를 가속화하기 위해 할 수 있는 두 가지가 있습니다.</p>
<p>First, you might want to reduce the number of writes that actually “flush” to the terminal. <code>println!</code> tells the system to flush to the terminal <em>every</em> time because it is common to print each new line. If you don’t need that, you can wrap your <code>stdout</code> handle in a <a href="https://doc.rust-lang.org/1.39.0/std/io/struct.BufWriter.html"><code>BufWriter</code></a>, which buffers up to 8 kB by default. You can still call <code>.flush()</code> on this <code>BufWriter</code> when you want to print immediately.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{self, Write};

let stdout = io::stdout(); // 전역 stdout 엔터티 가져오기
let mut handle = io::BufWriter::new(stdout); // 선택 사항: 해당 핸들을 버퍼로 래핑
writeln!(handle, "foo: {}", 42); // 여기에 오류가 있는 경우 `?` 추가
<span class="boring">}</span></code></pre></pre>
<p>둘째, <code>stdout</code>(또는 <code>stderr</code>)에 대한 잠금을 획득하고 <code>writeln!</code>을 사용하여 직접 인쇄하는 것이 도움이 됩니다. 이렇게 하면 시스템이 <code>stdout</code>을 반복해서 잠그고 잠금 해제하는 것을 방지할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{self, Write};

let stdout = io::stdout(); // 전역 stdout 엔터티 가져오기
let mut handle = stdout.lock(); // 잠금 획득
writeln!(handle, "foo: {}", 42); // 여기에 오류가 있는 경우 `?` 추가
<span class="boring">}</span></code></pre></pre>
<p>두 가지 접근 방식을 결합할 수도 있습니다.</p>
<h2 id="진행률-표시줄-표시"><a class="header" href="#진행률-표시줄-표시">진행률 표시줄 표시</a></h2>
<p>Some CLI applications run less than a second while others take minutes or hours. If you are writing one of the latter types of programs, you might want to show the user that something is happening. For this, you should try to print useful status updates, ideally in a form that can be easily consumed.</p>
<p><a href="https://crates.io/crates/indicatif">indicatif</a> 크레이트를 사용하여 프로그램에 진행률 표시줄과 작은 스피너를 추가할 수 있습니다. 다음은 간단한 예입니다.</p>
<pre><code class="language-rust ignore">fn main() {
    let pb = indicatif::ProgressBar::new(100);
    for i in 0..100 {
        do_hard_work();
        pb.println(format!("[+] finished #{}", i));
        pb.inc(1);
    }
    pb.finish_with_message("done");
}</code></pre>
<p>자세한 내용은 <a href="https://docs.rs/indicatif">문서</a> 및 <a href="https://github.com/console-rs/indicatif/tree/main/examples">예제</a>를 참조하세요.</p>
<h2 id="로깅"><a class="header" href="#로깅">로깅</a></h2>
<p>To make it easier to understand what is happening in our program, we might want to add some log statements. This is usually easy while writing your application, and it will become super helpful when running this program again in half a year. In some ways, logging is the same as using <code>println!</code> except that you can specify the importance of a message. The levels you can usually use are <em>error</em>, <em>warn</em>, <em>info</em>, <em>debug</em>, and <em>trace</em> (<em>error</em> has the highest priority, <em>trace</em> the lowest).</p>
<p>To add simple logging to your application, you’ll need two things: The <a href="https://crates.io/crates/log">log</a> crate (this contains macros named after the log level) and an <em>adapter</em> that actually writes the log output somewhere useful. Having the ability to use log adapters is very flexible: You can, for example, use them to write logs not only to the terminal but also to <a href="https://en.wikipedia.org/wiki/Syslog">syslog</a> or to a central log server.</p>
<p>Since we are only concerned with writing a CLI application, an easy adapter to use is <a href="https://crates.io/crates/env_logger">env_logger</a>. It’s called “env” logger because you can use an environment variable to specify which parts of your application you want to log and at which level you want to log them. It will prefix your log messages with a timestamp and the module where the log messages come from. Since libraries can also use <code>log</code>, you easily configure their log output, too.</p>
<p>다음은 간단한 예입니다.</p>
<pre><code class="language-rust ignore">use log::{info, warn};

fn main() {
    env_logger::init();
    info!("starting up");
    warn!("oops, nothing implemented!");
}</code></pre>
<p>이 파일을 <code>src/bin/output-log.rs</code>로 가지고 있다고 가정하면 Linux 및 macOS에서 다음과 같이 실행할 수 있습니다.</p>
<pre><code class="language-console">$ env RUST_LOG=info cargo run --bin output-log
    Finished dev [unoptimized + debuginfo] target(s) in 0.17s
     Running `target/debug/output-log`
[2018-11-30T20:25:52Z INFO  output_log] starting up
[2018-11-30T20:25:52Z WARN  output_log] oops, nothing implemented!
</code></pre>
<p>Windows PowerShell에서는 다음과 같이 실행할 수 있습니다.</p>
<pre><code class="language-console">$ $env:RUST_LOG="info"
$ cargo run --bin output-log
    Finished dev [unoptimized + debuginfo] target(s) in 0.17s
     Running `target/debug/output-log.exe`
[2018-11-30T20:25:52Z INFO  output_log] starting up
[2018-11-30T20:25:52Z WARN  output_log] oops, nothing implemented!
</code></pre>
<p>Windows CMD에서는 다음과 같이 실행할 수 있습니다.</p>
<pre><code class="language-console">$ set RUST_LOG=info
$ cargo run --bin output-log
    Finished dev [unoptimized + debuginfo] target(s) in 0.17s
     Running `target/debug/output-log.exe`
[2018-11-30T20:25:52Z INFO  output_log] starting up
[2018-11-30T20:25:52Z WARN  output_log] oops, nothing implemented!
</code></pre>
<p><code>RUST_LOG</code> is the name of the environment variable you can use to set your log settings. <code>env_logger</code> also contains a builder so you can programmatically adjust these settings like showing <em>info</em> level messages by default.</p>
<p>There are a lot of alternative logging adapters out there as well as alternatives and extensions to <code>log</code>. If you know your application will have a lot to log, make sure to review them and make your users’ lives easier.</p>
<aside>
<p><strong>Tip:</strong> Experience has shown that even mildly useful CLI programs can end up being used for years to come, especially if they were meant as a temporary solution. If your application doesn’t work and someone (e.g., you, in the future) needs to figure out why, being able to pass <code>--verbose</code> to get additional log output can make the difference between minutes and hours of debugging. The <a href="https://crates.io/crates/clap-verbosity-flag">clap-verbosity-flag</a> crate contains a quick way to add a <code>--verbose</code> to a project using <code>clap</code>.</p>
</aside>
<div style="break-before: page; page-break-before: always;"></div><h1 id="테스트"><a class="header" href="#테스트">테스트</a></h1>
<p>Over decades of software development, people have discovered one truth: Untested software rarely works. Many people would go as far as saying that most tested software doesn’t work either. But we are all optimists here, right? To ensure that your program does what you expect it to do, it is wise to test it.</p>
<p>A good starting point is to write a <code>README</code> file that describes what your program should do, and when you feel ready to make a new release, go through the <code>README</code> and ensure that the behavior is still as expected. You can make this a more rigorous exercise by also writing down how your program should react to erroneous inputs.</p>
<p>여기 또 다른 멋진 아이디어가 있습니다. 코드를 작성하기 전에 <code>README</code>를 작성하세요.</p>
<aside>
<p><strong>참고:</strong> <a href="https://en.wikipedia.org/wiki/Test-driven_development">테스트 주도 개발</a>(TDD)에 대해 들어본 적이 없다면 살펴보세요.</p>
</aside>
<h2 id="자동화된-테스트"><a class="header" href="#자동화된-테스트">자동화된 테스트</a></h2>
<p>이제 이것은 모두 괜찮지만 이 모든 것을 수동으로 수행하시겠습니까? 시간이 많이 걸릴 수 있습니다. 동시에 많은 사람들이 컴퓨터에 일을 시키는 것을 즐기게 되었습니다. 이러한 테스트를 자동화하는 방법에 대해 이야기해 봅시다.</p>
<p>Rust has a built-in test framework, so let’s start by writing our first test:</p>
<pre><code class="language-rust ignore"><span class="boring">fn answer() -&gt; i32 {
</span><span class="boring">  42
</span><span class="boring">}
</span><span class="boring">
</span>#[test]
fn check_answer_validity() {
    assert_eq!(answer(), 42);
}</code></pre>
<p>이 코드 조각을 패키지의 거의 모든 소스 파일에 넣을 수 있으며 <code>cargo test</code>가 이를 찾아 실행합니다. 여기서 핵심은 <code>#[test]</code> 속성입니다. 이를 통해 빌드 시스템이 이러한 함수를 검색하고 테스트로 실행하여 패닉이 발생하지 않는지 확인할 수 있습니다.</p>
<aside class="exercise">
<p><strong>독자를 위한 연습:</strong> 이 테스트가 작동하도록 만드세요.</p>
<p>다음과 같은 출력이 표시되어야 합니다.</p>
<pre><code class="language-text">running 1 test
test check_answer_validity ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
</aside>
<p>Now that we’ve seen <em>how</em> we can write tests, we still need to figure out <em>what</em> to test. As you’ve seen, it takes little code to write assertions for functions, but a CLI application is often more than one function! Worse, it often deals with user input, reads files, and writes output.</p>
<h2 id="코드를-테스트-가능하게-만들기"><a class="header" href="#코드를-테스트-가능하게-만들기">코드를 테스트 가능하게 만들기</a></h2>
<p>There are two complementary approaches to testing functionality. One is to test the small units that you use to build your complete application. These are called “unit tests”. Another is to test the final application from the outside, called black box tests or integration tests. Let’s begin with the first one.</p>
<p>To figure out what we should test, let’s see what our program features are. <code>grrs</code> is supposed to print out the lines that match a given pattern, so let’s write unit tests for <em>exactly this</em>. We want to ensure that our most important piece of logic works, and we want to do it in a way that is not dependent on any of the setup code we have around it like the CLI arguments.</p>
<p><code>grrs</code>의 <a href="tutorial/impl-draft.html">첫 번째 구현</a>으로 돌아가서 <code>main</code> 함수에 이 코드 블록을 추가했습니다.</p>
<pre><code class="language-rust ignore">// ...
for line in content.lines() {
    if line.contains(&amp;args.pattern) {
        println!("{}", line);
    }
}</code></pre>
<p>Sadly, this is not very easy to test. First of all, it’s in the main function, so we can’t easily call it. This is fixed by moving this piece of code into a function:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn find_matches(content: &amp;str, pattern: &amp;str) {
    for line in content.lines() {
        if line.contains(pattern) {
            println!("{}", line);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Now, we can call this function in our test and see what its output is:</p>
<pre><code class="language-rust ignore">#[test]
fn find_a_match() {
    find_matches("lorem ipsum\ndolor sit amet", "lorem");
    assert_eq!( // 어...</code></pre>
<p>아니면… 할 수 있을까요? 지금 <code>find_matches</code>는 <code>stdout</code>, 즉 터미널에 직접 인쇄합니다. 테스트에서 이것을 쉽게 캡처할 수 없습니다! 이것은 구현 후에 테스트를 작성할 때 종종 발생하는 문제입니다. 우리는 사용되는 컨텍스트에 확고하게 통합된 함수를 작성했습니다.</p>
<aside class="note">
<p><strong>Note:</strong> This is totally fine when writing small CLI applications. There’s no need to make everything testable! It is important to think about which parts of your code you might want to write unit tests for. While we’ll see that it’s straightforward to change this function to be testable, this is not always the case.</p>
</aside>
<p>Alright, how can we make this testable? We’ll need to capture the output somehow. Rust’s standard library has some neat abstractions for dealing with I/O (input/output), and we’ll make use of one called <a href="https://doc.rust-lang.org/1.39.0/std/io/trait.Write.html"><code>std::io::Write</code></a>. This is a <a href="https://doc.rust-lang.org/book/ch10-02-traits.html">trait</a> that abstracts over things we can write to, which includes strings and <code>stdout</code>.</p>
<p>If this is the first time you’ve heard “trait” in the context of Rust, you are in for a treat. Traits are one of the most powerful features of Rust. You can think of them like interfaces in Java or type classes in Haskell, whatever you are more familiar with. They allow you to abstract over behavior that can be shared by different types. Code that uses traits can express ideas in very generic and flexible ways. This means it can also get difficult to read. Don’t let that intimidate you. Even people who have used Rust for years don’t always get what generic code does immediately. In that case, it helps to think of concrete uses. In our case, the behavior that we abstract over is “write to it”. Examples for the types that implement (<code>impl</code>) it include the terminal’s standard output, files, a buffer in memory, or TCP network connections. Scroll down in the <a href="https://doc.rust-lang.org/1.39.0/std/io/trait.Write.html">documentation for <code>std::io::Write</code></a> to see a list of “Implementors”.</p>
<p>With that knowledge, let’s change our function to accept a third parameter. It can be any type that implements <code>Write</code>. This way, we can supply a simple string in our tests and make assertions on it. Here is how we can write this version of <code>find_matches</code>:</p>
<pre><code class="language-rust ignore">fn find_matches(content: &amp;str, pattern: &amp;str, mut writer: impl std::io::Write) {
    for line in content.lines() {
        if line.contains(pattern) {
            writeln!(writer, "{}", line);
        }
    }
}</code></pre>
<p>The new parameter is <code>mut writer</code>, i.e., a mutable thing we call “writer”. Its type is <code>impl std::io::Write</code>, which you can read as a placeholder for any type that implements the <code>Write</code> trait. Note how we replaced the <code>println!(…)</code> we used earlier with <code>writeln!(writer, …)</code>. <code>println!</code> works the same as <code>writeln!</code>, but it always uses standard output.</p>
<p>Now, we can test for the output:</p>
<pre><code class="language-rust ignore">#[test]
fn find_a_match() {
    let mut result = Vec::new();
    find_matches("lorem ipsum\ndolor sit amet", "lorem", &amp;mut result);
    assert_eq!(result, b"lorem ipsum\n");
}</code></pre>
<p>To use this in our application code, we have to change the call to <code>find_matches</code> in <code>main</code> by adding <a href="https://doc.rust-lang.org/1.39.0/std/io/fn.stdout.html"><code>&amp;mut std::io::stdout()</code></a> as the third parameter. Here’s an example of a main function that builds on what we’ve seen in the previous chapters and uses our extracted <code>find_matches</code> function:</p>
<pre><code class="language-rust ignore">fn main() -&gt; Result&lt;()&gt; {
    let args = Cli::parse();
    let content = std::fs::read_to_string(&amp;args.path)
        .with_context(|| format!("could not read file `{}`", args.path.display()))?;

    find_matches(&amp;content, &amp;args.pattern, &amp;mut std::io::stdout());

    Ok(())
}</code></pre>
<aside class="note">
<p><strong>Note:</strong> Since <code>stdout</code> expects bytes (not strings), we use <code>std::io::Write</code> instead of <code>std::fmt::Write</code>. As a result, we give an empty vector as <code>writer</code> in our tests (its type will be inferred to <code>Vec&lt;u8&gt;</code>), and in the <code>assert_eq!</code>, we use <code>b"foo"</code>. The <code>b</code> prefix makes this a <em>byte string literal</em>, so its type is going to be <code>&amp;[u8]</code> instead of <code>&amp;str</code>.</p>
</aside>
<aside class="note">
<p><strong>참고:</strong> 이 함수가 <code>String</code>을 반환하도록 만들 수도 있지만 그렇게 하면 동작이 변경됩니다. 터미널에 직접 쓰는 대신 모든 것을 문자열로 수집하고 마지막에 모든 결과를 한 번에 덤프합니다.</p>
</aside>
<aside class="exercise">
<p><strong>Exercise for the reader:</strong> <a href="https://doc.rust-lang.org/1.39.0/std/macro.writeln.html"><code>writeln!</code></a> returns an <a href="https://doc.rust-lang.org/1.39.0/std/io/type.Result.html"><code>io::Result</code></a> because writing can fail (for example, when the buffer is full and cannot be expanded). Add error handling to <code>find_matches</code>.</p>
</aside>
<p>We’ve just seen how to make this piece of code testable. We have:</p>
<ol>
<li>Identified one of the core pieces of our application.</li>
<li>Put it into its own function.</li>
<li>Made it more flexible.</li>
</ol>
<p>목표는 테스트 가능하게 만드는 것이었지만, 우리가 얻은 결과는 실제로 매우 관용적이고 재사용 가능한 Rust 코드 조각입니다. 정말 멋집니다!</p>
<h2 id="코드를-라이브러리-및-바이너리-대상으로-분할"><a class="header" href="#코드를-라이브러리-및-바이너리-대상으로-분할">코드를 라이브러리 및 바이너리 대상으로 분할</a></h2>
<p>We can do one more thing here. So far, we’ve put everything we wrote into the <code>src/main.rs</code> file. This means our current project produces a single binary, but we can also make our code available as a library like this:</p>
<ol>
<li><code>find_matches</code> 함수를 새 <code>src/lib.rs</code>에 넣습니다.</li>
<li>Add a <code>pub</code> in front of the <code>fn</code> to make it something that users of our library can access (i.e. <code>pub fn find_matches</code>).</li>
<li><code>src/main.rs</code>에서 <code>find_matches</code>를 제거합니다.</li>
<li>In <code>fn main</code>, prepend the call to <code>find_matches</code> with <code>grrs::</code> so that it’s now <code>grrs::find_matches(…)</code>. This means it uses the function from the library we just wrote!</li>
</ol>
<p>The way Rust deals with projects is quite flexible, and it’s a good idea to think about what to put into the library part of your crate early on. You can, for example, think about writing a library for your application-specific logic first and then use it in your CLI just like any other library. Or, if your project has multiple binaries, you can put the common functionality into the library part of that crate.</p>
<aside class="note">
<p><strong>Note:</strong> Speaking of putting everything into a <code>src/main.rs</code>, if we continue to do that, it’ll become difficult to read. The <a href="https://doc.rust-lang.org/1.39.0/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">module system</a> can help you structure and organize your code.</p>
</aside>
<h2 id="실행하여-cli-응용-프로그램-테스트"><a class="header" href="#실행하여-cli-응용-프로그램-테스트">실행하여 CLI 응용 프로그램 테스트</a></h2>
<p>Thus far, we’ve gone out of our way to test the <em>business logic</em> of our application, which turned out to be the <code>find_matches</code> function. This is very valuable and is a great first step towards a well-tested code base. Usually, these kinds of tests are called “unit tests”.</p>
<p>There is a lot of code we aren’t testing: Everything that we wrote to deal with the outside world! Imagine you wrote the main function but accidentally left in a hard-coded string instead of using the argument of the user-supplied path. We should write tests for that, too! This level of testing is often called integration testing or system testing.</p>
<p>At its core, we are still writing functions and annotating them with <code>#[test]</code>. It’s just a matter of what we do inside these functions. For example, we’ll want to use the main binary of our project and run it like a regular program. We will put these tests into a new file in a new directory: <code>tests/cli.rs</code>.</p>
<aside>
<p><strong>Note:</strong> By convention, <code>cargo</code> will look for integration tests in the <code>tests/</code> directory. Similarly, it will look for benchmarks in <code>benches/</code> and examples in <code>examples/</code>. These conventions also extend to your main source code: libraries have a <code>src/lib.rs</code> file, the main binary is <code>src/main.rs</code>, and if there are multiple binaries, cargo expects them to be in <code>src/bin/&lt;name&gt;.rs</code>. Following these conventions will make your code base more discoverable by people used to reading Rust code.</p>
</aside>
<p><code>grrs</code> is a small tool that searches for a string in a file. We have already tested that we can find a match. Let’s think about what other functionality we can test.</p>
<p>Here is what I came up with:</p>
<ul>
<li>파일이 존재하지 않으면 어떻게 됩니까?</li>
<li>일치하는 항목이 없을 때 출력은 무엇입니까?</li>
<li>인수 중 하나(또는 둘 다)를 잊어버리면 프로그램이 오류와 함께 종료됩니까?</li>
</ul>
<p>These are all valid test cases. Additionally, we should include one test case for the happy path: we found at least one match and we print it.</p>
<p>To make these kinds of tests easier, we’re going to use the <a href="https://docs.rs/assert_cmd"><code>assert_cmd</code></a> crate. It has a bunch of neat helpers that allow us to run our main binary and see how it behaves. We’ll also add the <a href="https://docs.rs/predicates"><code>predicates</code></a> crate, which helps us write assertions that <code>assert_cmd</code> can test against and that have great error messages. We won’t add those dependencies to the main list, but to a <code>dev dependencies</code> section in our <code>Cargo.toml</code>. They are only required when developing the crate, not when using it.</p>
<pre><code class="language-toml">[dev-dependencies]
assert_cmd = "2.0.14"
predicates = "3.1.0"
</code></pre>
<p>This sounds like a lot of setup. Nevertheless, let’s dive right in and create our <code>tests/cli.rs</code> file:</p>
<pre><code class="language-rust ignore">use assert_cmd::cargo::*; // Import cargo_bin_cmd! macro and methods
use predicates::prelude::*; // 어설션 작성에 사용

#[test]
fn file_doesnt_exist() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut cmd = cargo_bin_cmd!("grrs");

    cmd.arg("foobar").arg("test/file/doesnt/exist");
    cmd.assert()
        .failure()
        .stderr(predicate::str::contains("could not read file"));

    Ok(())
}
</code></pre>
<p>You can run this test with <code>cargo test</code>, just like the tests we wrote above. It might take a little longer the first time as <code>Command::cargo_bin("grrs")</code> needs to compile your main binary.</p>
<h2 id="테스트-파일-생성"><a class="header" href="#테스트-파일-생성">테스트 파일 생성</a></h2>
<p>The test we’ve just seen only checks that our program writes an error message when the input file doesn’t exist. That’s an important test to have, but maybe not the most important one. Let’s test that we will actually print the matches we found in a file!</p>
<p>We’ll need to have a file whose content we know so that we can know what our program <em>should</em> return and check this expectation in our code. One idea might be to add a file to the project with custom content and use that in our tests. Another would be to create temporary files in our tests. For this tutorial, we’ll have a look at the latter approach. It is more flexible and will work for other cases; for example, when you are testing programs that change the files.</p>
<p>이러한 임시 파일을 만들려면 <a href="https://docs.rs/assert_fs"><code>assert_fs</code></a> 크레이트를 사용할 것입니다. <code>Cargo.toml</code>의 <code>dev-dependencies</code>에 추가해 봅시다.</p>
<pre><code class="language-toml">assert_fs = "1.1.1"
</code></pre>
<p>Here is a new test case that creates a temp file (a “named” one so we can get its path), fills it with some text, and then runs our program to see if we get the correct output. You can write it below the other test case. When the variable <code>file</code> goes out of scope at the end of the function, the actual temporary file will automatically get deleted.</p>
<pre><code class="language-rust ignore">
#[test]
fn find_content_in_file() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let file = assert_fs::NamedTempFile::new("sample.txt")?;
    file.write_str("A test\nActual content\nMore content\nAnother test")?;

    let mut cmd = cargo_bin_cmd!("grrs");
    cmd.arg("test").arg(file.path());
    cmd.assert()
        .success()
        .stdout(predicate::str::contains("A test\nAnother test"));

    Ok(())
}</code></pre>
<aside class="exercise">
<p><strong>독자를 위한 연습:</strong> 빈 문자열을 패턴으로 전달하기 위한 통합 테스트를 추가하세요. 필요에 따라 프로그램을 조정하세요.</p>
</aside>
<h2 id="무엇을-테스트해야-할까요"><a class="header" href="#무엇을-테스트해야-할까요">무엇을 테스트해야 할까요?</a></h2>
<p>While it can certainly be fun to write integration tests, it will take some time to write them as well as to update them when your application’s behavior changes. To make sure you use your time wisely, you should ask yourself what you should test.</p>
<p>In general, it’s a good idea to write integration tests for all types of behavior that a user can observe. This means that you don’t need to cover all edge cases. It usually suffices to have examples for the different types and rely on unit tests to cover the edge cases.</p>
<p>It is also a good idea not to focus your tests on things you can’t actively control. It would be a bad idea to test the exact layout of <code>--help</code> since it is generated for you. Instead, you might just want to check that certain elements are present.</p>
<p>Depending on the nature of your program, you can also try to add more testing techniques. For example, if you have extracted parts of your program and find yourself writing a lot of example cases as unit tests while trying to come up with all the edge cases, you should look into <a href="https://docs.rs/proptest"><code>proptest</code></a>. If you have a program that consumes arbitrary files and parses them, try to write a <a href="https://rust-fuzz.github.io/book/introduction.html">fuzzer</a> to find bugs in edge cases.</p>
<aside>
<p><strong>참고:</strong> 이 장에서 사용된 전체 실행 가능한 소스 코드는 <a href="https://github.com/rust-cli/book/tree/master/src/tutorial/testing">이 책의 리포지토리</a>에서 찾을 수 있습니다.</p>
</aside>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-도구-패키징-및-배포"><a class="header" href="#rust-도구-패키징-및-배포">Rust 도구 패키징 및 배포</a></h1>
<p>프로그램이 다른 사람들이 사용할 준비가 되었다고 확신한다면 패키징하고 출시할 시간입니다!</p>
<p>There are a few approaches, and we’ll look at three of them from quickest to set up to most convenient for users.</p>
<h2 id="가장-빠른-방법-cargo-publish"><a class="header" href="#가장-빠른-방법-cargo-publish">가장 빠른 방법: <code>cargo publish</code></a></h2>
<p>The easiest way to publish your app is with cargo. Do you remember how we added external dependencies to our project? Cargo downloaded them from its default crate registry: <a href="https://crates.io/">crates.io</a>. With <code>cargo publish</code>, you can publish crates to <a href="https://crates.io/">crates.io</a>, and this works for all crates, including those with binary targets.</p>
<p>Publishing a crate to <a href="https://crates.io/">crates.io</a> can be done in a few steps. First, if you haven’t already, create an account on <a href="https://crates.io/">crates.io</a>, which is done by authorizing you on GitHub, so you’ll need to have a GitHub account and be logged in there. Second, you log in using cargo on your local machine. For that, go to your <a href="https://crates.io/me">crates.io account page</a>, create a new token, and run <code>cargo login &lt;your-new-token&gt;</code>. You only need to do this once per computer. You can learn more about this in cargo’s <a href="https://doc.rust-lang.org/1.39.0/cargo/reference/publishing.html">publishing guide</a>.</p>
<p>Now that cargo and crates.io know you, you are ready to publish crates. Before you hastily go ahead and publish a new crate version, it’s a good idea to open your <code>Cargo.toml</code> once more and make sure you added the necessary metadata. You can find all the possible fields you can set in the documentation for <a href="https://doc.rust-lang.org/1.39.0/cargo/reference/manifest.html">cargo’s manifest format</a>. Here’s a quick overview of some common entries:</p>
<pre><code class="language-toml">[package]
name = "grrs"
version = "0.1.0"
authors = ["Your Name &lt;your@email.com&gt;"]
license = "MIT OR Apache-2.0"
description = "A tool to search files"
readme = "README.md"
homepage = "https://github.com/you/grrs"
repository = "https://github.com/you/grrs"
keywords = ["cli", "search", "demo"]
categories = ["command-line-utilities"]
</code></pre>
<aside class="note">
<p><strong>Note:</strong> This example includes the mandatory license field with a common choice for Rust projects: The same license that is used for the compiler itself. It also refers to a <code>README.md</code> file. It should include a quick description of what your project is about and will be included not only on the crates.io page of your crate, but GitHub shows it by default on repository pages.</p>
</aside>
<h3 id="cratesio에서-바이너리를-설치하는-방법"><a class="header" href="#cratesio에서-바이너리를-설치하는-방법">crates.io에서 바이너리를 설치하는 방법</a></h3>
<p>We’ve seen how to publish a crate to crates.io, and you might be wondering how to install it. In contrast to libraries, which cargo will download and compile for you when you run <code>cargo build</code> or a similar command, you’ll need to tell it to explicitly install binaries.</p>
<p>This is done using <code>cargo install &lt;crate-name&gt;</code>. It will download the crate by default, compile all the binary targets it contains (in “release” mode, so it might take a while) and copy them into the <code>~/.cargo/bin/</code> directory. Make sure that your shell knows to look there for binaries!</p>
<p>git 리포지토리에서 크레이트를 설치하고, 크레이트의 특정 바이너리만 설치하고, 설치할 대체 디렉토리를 지정할 수도 있습니다. 자세한 내용은 <code>cargo install --help</code>를 참조하세요.</p>
<h3 id="사용-시기"><a class="header" href="#사용-시기">사용 시기</a></h3>
<p><code>cargo install</code> is a simple way to install a binary crate. It’s very convenient for Rust developers to use but has some significant downsides: Since it will always compile your source from scratch, users of your tool will need to have Rust, cargo, and all other system dependencies that your project requires installed on their machine. Compiling large Rust codebases can take some time.</p>
<p>It’s best to use this for distributing tools that are targeted at other Rust developers. For example, a lot of cargo subcommands like <code>cargo-tree</code> or <code>cargo-outdated</code> can be installed with it.</p>
<h2 id="바이너리-배포"><a class="header" href="#바이너리-배포">바이너리 배포</a></h2>
<p>Rust is a language that compiles to native code and statically links all dependencies by default. When you run <code>cargo build</code> on your project that contains a binary called <code>grrs</code>, you’ll end up with a binary file called <code>grrs</code>. Try it out! Using <code>cargo build</code>, it’ll be <code>target/debug/grrs</code>, and when you run <code>cargo build --release</code>, it’ll be <code>target/release/grrs</code>. Unless you use crates that explicitly need external libraries installed on the target system (like using the system’s version of OpenSSL), this binary will only depend on common system libraries. That means, you take that one file, send it to people running the same operating system as you, and they’ll be able to run it.</p>
<p>이것은 이미 매우 강력합니다! 방금 본 <code>cargo install</code>의 두 가지 단점을 해결합니다. 사용자 컴퓨터에 Rust를 설치할 필요가 없으며 컴파일하는 데 1분이 걸리는 대신 즉시 바이너리를 실행할 수 있습니다.</p>
<p>As we’ve seen, <code>cargo build</code> <em>already</em> builds binaries for us. The issue is that those are not guaranteed to work on all platforms. If you run <code>cargo build</code> on your Windows machine, you won’t get a binary that works on a Mac by default. Is there a way to generate these binaries for all of the target platforms automatically?</p>
<h3 id="ci에서-바이너리-릴리스-빌드"><a class="header" href="#ci에서-바이너리-릴리스-빌드">CI에서 바이너리 릴리스 빌드</a></h3>
<p>If your tool is open sourced and hosted on GitHub, it’s quite easy to set up a free CI (continuous integration) service like <a href="https://travis-ci.com/">Travis CI</a>. There are other services that offer this functionality, but Travis is very popular. This runs setup commands in a virtual machine each time you push changes to your repository. What those commands are, and the types of machines they run on, is configurable. For example, a good idea is to run <code>cargo test</code> on a machine with Rust and some common build tools installed. If this fails, you know there are issues in the most recent changes.</p>
<p>We can also use this to build binaries and upload them to GitHub! If we run <code>cargo build --release</code> and upload the binary somewhere, we should be all set, right? Not quite. We still need to make sure the binaries we build are compatible with as many systems as possible. For example, on Linux we can compile for the current system or the <code>x86_64-unknown-linux-musl</code> target and not depend on default system libraries. On macOS, we can set <code>MACOSX_DEPLOYMENT_TARGET</code> to <code>10.7</code> to only depend on system features present in versions 10.7 and older.</p>
<p>You can see one example of building binaries using this approach <a href="https://github.com/rustwasm/wasm-pack/blob/51e6351c28fbd40745719e6d4a7bf26dadd30c85/.travis.yml#L74-L91">here</a> for Linux and macOS and <a href="https://github.com/rustwasm/wasm-pack/blob/51e6351c28fbd40745719e6d4a7bf26dadd30c85/.appveyor.yml">here</a> for Windows using AppVeyor.</p>
<p>Another way is to use pre-built (i.e. Docker) images that contain all the tools we need to build binaries. This allows us to easily target more exotic platforms as well. The <a href="https://github.com/japaric/trust">trust</a> project contains scripts that you can include in your project and instructions on how to set this up. It also includes support for Windows using AppVeyor.</p>
<p>If you’d rather set this up locally and generate the release files on your own machine, have a look at <a href="https://github.com/japaric/trust">trust</a>. It uses <a href="https://github.com/rust-embedded/cross">cross</a> internally, which works similar to cargo but forwards commands to a cargo process inside a Docker container. The definitions of the images are also available in <a href="https://github.com/rust-embedded/cross">cross’ repository</a>.</p>
<h3 id="이러한-바이너리를-설치하는-방법"><a class="header" href="#이러한-바이너리를-설치하는-방법">이러한 바이너리를 설치하는 방법</a></h3>
<p>You point your users to your release page that might look something <a href="https://github.com/rustwasm/wasm-pack/releases/tag/v0.5.1">like this one</a>, and they can download the artifacts we’ve just created. The release artifacts we’ve generated are nothing special. They are just archive files that contain our binaries! This means that users of your tool can download them with their browser, extract them (often automatically), and copy the binaries to a place they like.</p>
<p>This does require some experience with manually installing programs, so you want to add a section to your README file on how to install this program.</p>
<aside class="note">
<p><strong>Note:</strong> If you use <a href="https://github.com/japaric/trust">trust</a> to build your binaries and add them to GitHub releases, you can also tell people to run <code>curl -LSfs https://japaric.github.io/trust/install.sh | sh -s -- --git your-name/repo-name</code> if you think that makes it easier.</p>
</aside>
<h3 id="사용-시기-1"><a class="header" href="#사용-시기-1">사용 시기</a></h3>
<p>Having binary releases is a good idea in general. There’s hardly any downside to it. It does not solve the problem of users having to manually install and update your tools, but they can quickly get the latest release’s version without the need to install Rust.</p>
<h3 id="바이너리-외에-무엇을-패키징해야-할까요"><a class="header" href="#바이너리-외에-무엇을-패키징해야-할까요">바이너리 외에 무엇을 패키징해야 할까요</a></h3>
<p>Right now, when a user downloads our release builds, they will get a <code>.tar.gz</code> file that only contains binary files. In our example project, they will just get a single <code>grrs</code> file they can run, but there are more files we already have in our repository that they might want to have. The README file that tells them how to use this tool and the license file(s), for example. Since we already have them, they are easy to add.</p>
<p>There are more interesting files that make sense, especially for command-line tools. How about we ship a man page in addition to that README file and config files that add completions of the possible flags to your shell? You can write these by hand, but <em>clap</em>, the argument parsing library we use (which clap builds upon) has a way to generate all these files for us. See <a href="tutorial/../in-depth/docs.html">this in-depth chapter</a> for more details.</p>
<h2 id="앱을-패키지-리포지토리에-넣기"><a class="header" href="#앱을-패키지-리포지토리에-넣기">앱을 패키지 리포지토리에 넣기</a></h2>
<p>Both approaches we’ve seen so far are not how you typically install software on your machine, especially for command-line tools that you install using global package managers on most operating systems. The advantages for users are quite obvious: There is no need to think about how to install your program if it can be installed the same way as they install other tools. These package managers also allow users to update their programs when a new version is available.</p>
<p>Sadly, supporting different systems means you’ll have to look at how these different systems work. For some, it might be as easy as adding a file to your repository (e.g. adding a Formula file like <a href="https://github.com/BurntSushi/ripgrep/blob/31adff6f3c4bfefc9e77df40871f2989443e6827/pkg/brew/ripgrep-bin.rb">this</a> for macOS’s <code>brew</code>), but for others, you’ll often need to send in patches yourself and add your tool to their repositories. There are helpful tools like <a href="https://crates.io/crates/cargo-bundle">cargo-bundle</a>, <a href="https://crates.io/crates/cargo-deb">cargo-deb</a>, and <a href="https://crates.io/crates/cargo-aur">cargo-aur</a>, but describing how they work and how to correctly package your tool for those different systems is beyond the scope of this chapter.</p>
<p>대신 Rust로 작성되었고 많은 다른 패키지 관리자에서 사용할 수 있는 도구를 살펴보겠습니다.</p>
<h3 id="예-ripgrep"><a class="header" href="#예-ripgrep">예: ripgrep</a></h3>
<p><a href="https://github.com/BurntSushi/ripgrep">ripgrep</a>은 <code>grep</code>/<code>ack</code>/<code>ag</code>의 대안이며 Rust로 작성되었습니다. 매우 성공적이며 많은 운영 체제용으로 패키징되었습니다. README의 <a href="https://github.com/BurntSushi/ripgrep/tree/31adff6f3c4bfefc9e77df40871f2989443e6827#installation">“설치” 섹션</a>을 살펴보세요!</p>
<p>Note that it lists a few different options on how you can install it: It starts with a link to the GitHub releases, which contain the binaries so that you can download them directly, it lists how to install it using a bunch of different package managers, and you can also install it using <code>cargo install</code>.</p>
<p>This seems like a very good idea. Don’t pick and choose one of the approaches presented here. Start with <code>cargo install</code> and add binary releases before finally distributing your tool using system package managers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="심층-주제"><a class="header" href="#심층-주제">심층 주제</a></h1>
<p>명령줄 응용 프로그램을 작성할 때 신경 쓸 수 있는 몇 가지 세부 정보를 다루는 작은 장 모음입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="신호-처리"><a class="header" href="#신호-처리">신호 처리</a></h1>
<p>명령줄 응용 프로그램과 같은 프로세스는 운영 체제에서 보낸 신호에 반응해야 합니다. 가장 일반적인 예는 아마도 프로세스에 종료를 알리는 신호인 <kbd>Ctrl</kbd>+<kbd>C</kbd>일 것입니다. Rust 프로그램에서 신호를 처리하려면 이러한 신호를 수신하는 방법과 이에 반응하는 방법을 고려해야 합니다.</p>
<aside>
<p><strong>참고:</strong> 응용 프로그램이 정상적으로 종료될 필요가 없다면 기본 처리가 괜찮습니다(즉, 즉시 종료하고 OS가 열린 파일 핸들과 같은 리소스를 정리하도록 함). 이 경우: 이 장에서 설명하는 것을 할 필요가 없습니다!</p>
<p>그러나 자체적으로 정리해야 하는 응용 프로그램의 경우 이 장은 매우 관련성이 높습니다! 예를 들어, 응용 프로그램이 네트워크 연결을 제대로 닫아야 하는 경우(상대방 프로세스에 “안녕“이라고 말함), 임시 파일을 제거하거나 시스템 설정을 재설정해야 하는 경우 계속 읽으십시오.</p>
</aside>
<h2 id="운영-체제-간의-차이점"><a class="header" href="#운영-체제-간의-차이점">운영 체제 간의 차이점</a></h2>
<p>Unix 시스템(Linux, macOS, FreeBSD 등)에서는 프로세스가 <a href="https://manpages.ubuntu.com/manpages/bionic/en/man7/signal.7.html">신호</a>를 수신할 수 있습니다. 기본(OS 제공) 방식으로 반응하거나, 신호를 가로채 프로그램 정의 방식으로 처리하거나, 신호를 완전히 무시할 수 있습니다.</p>
<p>Windows에는 신호가 없습니다. 이벤트가 발생할 때 실행되는 콜백을 정의하기 위해 <a href="https://docs.microsoft.com/en-us/windows/console/console-control-handlers">콘솔 핸들러</a>를 사용할 수 있습니다. 또한 0으로 나누기, 잘못된 액세스 예외, 스택 오버플로 등과 같은 다양한 유형의 시스템 예외를 처리하는 <a href="https://docs.microsoft.com/en-us/windows/desktop/debug/structured-exception-handling">구조적 예외 처리</a>도 있습니다.</p>
<h2 id="먼저-ctrlc-처리"><a class="header" href="#먼저-ctrlc-처리">먼저: Ctrl+C 처리</a></h2>
<p><a href="https://crates.io/crates/ctrlc">ctrlc</a> 크레이트는 이름에서 알 수 있듯이 크로스 플랫폼 방식으로 사용자가 <kbd>Ctrl</kbd>+<kbd>C</kbd>를 누르는 것에 반응할 수 있도록 합니다. 크레이트를 사용하는 주요 방법은 다음과 같습니다.</p>
<pre><code class="language-rust ignore">use std::{thread, time::Duration};

fn main() {
    ctrlc::set_handler(move || {
        println!("received Ctrl+C!");
    })
    .expect("Error setting Ctrl-C handler");

    // 다음 코드는 실제 작업을 수행하며 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;C&lt;/kbd&gt;를 눌러 중단할 수 있습니다.
    // 예: 몇 초 동안 기다려 봅시다.
    thread::sleep(Duration::from_secs(2));
}</code></pre>
<p>물론 이것은 그다지 도움이 되지 않습니다. 메시지만 인쇄하고 프로그램은 중지하지 않습니다.</p>
<p>실제 프로그램에서는 신호 핸들러에 변수를 설정하고 프로그램의 여러 위치에서 확인하는 것이 좋습니다. 예를 들어, 신호 핸들러에 <code>Arc&lt;AtomicBool&gt;</code>(스레드 간에 공유 가능한 부울)을 설정하고, 핫 루프에서 또는 스레드를 기다릴 때 주기적으로 해당 값을 확인하고 참이 되면 중단할 수 있습니다.</p>
<h2 id="다른-유형의-신호-처리"><a class="header" href="#다른-유형의-신호-처리">다른 유형의 신호 처리</a></h2>
<p><a href="https://crates.io/crates/ctrlc">ctrlc</a> 크레이트는 <kbd>Ctrl</kbd>+<kbd>C</kbd> 또는 Unix 시스템에서 <code>SIGINT</code>(“인터럽트” 신호)라고 하는 것만 처리합니다. 더 많은 Unix 신호에 반응하려면 <a href="https://crates.io/crates/signal-hook">signal-hook</a>을 살펴보아야 합니다. 디자인은 <a href="https://vorner.github.io/2018/06/28/signal-hook.html">이 블로그 게시물</a>에 설명되어 있으며 현재 가장 광범위한 커뮤니티 지원을 받는 라이브러리입니다.</p>
<p>다음은 간단한 예입니다.</p>
<pre><code class="language-rust ignore">use signal_hook::{consts::SIGINT, iterator::Signals};
use std::{error::Error, thread, time::Duration};

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let mut signals = Signals::new([SIGINT])?;

    thread::spawn(move || {
        for sig in signals.forever() {
            println!("Received signal {:?}", sig);
        }
    });

    // 다음 코드는 실제 작업을 수행하며 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;C&lt;/kbd&gt;를 눌러 중단할 수 있습니다.
    // 예: 몇 초 동안 기다려 봅시다.
    thread::sleep(Duration::from_secs(2));

    Ok(())
}</code></pre>
<h2 id="채널-사용"><a class="header" href="#채널-사용">채널 사용</a></h2>
<p>변수를 설정하고 프로그램의 다른 부분이 확인하도록 하는 대신 채널을 사용할 수 있습니다. 신호 핸들러가 신호를 수신할 때마다 값을 방출하는 채널을 만듭니다. 응용 프로그램 코드에서는 이 채널과 다른 채널을 스레드 간의 동기화 지점으로 사용합니다. <a href="https://crates.io/crates/crossbeam-channel">crossbeam-channel</a>을 사용하면 다음과 같이 보일 것입니다.</p>
<pre><code class="language-rust ignore">use std::time::Duration;
use crossbeam_channel::{bounded, tick, Receiver, select};
use anyhow::Result;

fn ctrl_channel() -&gt; Result&lt;Receiver&lt;()&gt;, ctrlc::Error&gt; {
    let (sender, receiver) = bounded(100);
    ctrlc::set_handler(move || {
        let _ = sender.send(());
    })?;

    Ok(receiver)
}

fn main() -&gt; Result&lt;()&gt; {
    let ctrl_c_events = ctrl_channel()?;
    let ticks = tick(Duration::from_secs(1));

    loop {
        select! {
            recv(ticks) -&gt; _ =&gt; {
                println!("working!");
            }
            recv(ctrl_c_events) -&gt; _ =&gt; {
                println!();
                println!("Goodbye!");
                break;
            }
        }
    }

    Ok(())
}</code></pre>
<h2 id="퓨처-및-스트림-사용"><a class="header" href="#퓨처-및-스트림-사용">퓨처 및 스트림 사용</a></h2>
<p><a href="https://tokio.rs/">tokio</a>를 사용하고 있다면 비동기 패턴과 이벤트 기반 디자인으로 응용 프로그램을 작성하고 있을 가능성이 높습니다. crossbeam의 채널을 직접 사용하는 대신 signal-hook의 <code>tokio-support</code> 기능을 활성화할 수 있습니다. 이렇게 하면 signal-hook의 <code>Signals</code> 유형에서 <a href="https://docs.rs/signal-hook/0.1.6/signal_hook/iterator/struct.Signals.html#method.into_async"><code>.into_async()</code></a>를 호출하여 <code>futures::Stream</code>을 구현하는 새 유형을 얻을 수 있습니다.</p>
<h2 id="첫-번째-ctrlc를-처리하는-동안-다른-ctrlc를-수신하면-어떻게-해야-합니까"><a class="header" href="#첫-번째-ctrlc를-처리하는-동안-다른-ctrlc를-수신하면-어떻게-해야-합니까">첫 번째 Ctrl+C를 처리하는 동안 다른 Ctrl+C를 수신하면 어떻게 해야 합니까?</a></h2>
<p>대부분의 사용자는 <kbd>Ctrl</kbd>+<kbd>C</kbd>를 누른 다음 프로그램이 종료될 때까지 몇 초 동안 기다리거나 무슨 일이 일어나고 있는지 알려줍니다. 그렇게 하지 않으면 <kbd>Ctrl</kbd>+<kbd>C</kbd>를 다시 누릅니다. 일반적인 동작은 응용 프로그램을 즉시 종료하는 것입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="구성-파일-사용"><a class="header" href="#구성-파일-사용">구성 파일 사용</a></h1>
<p>구성을 처리하는 것은 특히 단기 및 장기 파일에 대한 자체 위치를 가진 여러 운영 체제를 지원하는 경우 성가실 수 있습니다.</p>
<p>이에 대한 여러 가지 해결책이 있으며, 일부는 다른 것보다 더 저수준입니다.</p>
<p>이를 위해 사용하기 가장 쉬운 크레이트는 <a href="https://docs.rs/confy/0.3.1/confy/"><code>confy</code></a>입니다. 응용 프로그램 이름을 묻고 <code>struct</code>( <code>Serialize</code>, <code>Deserialize</code>인)를 통해 구성 레이아웃을 지정하도록 요구하면 나머지는 알아서 처리합니다!</p>
<pre><code class="language-rust ignore">#[derive(Debug, Serialize, Deserialize)]
struct MyConfig {
    name: String,
    comfy: bool,
    foo: i64,
}

fn main() -&gt; Result&lt;(), io::Error&gt; {
    let cfg: MyConfig = confy::load("my_app")?;
    println!("{:#?}", cfg);
    Ok(())
}</code></pre>
<p>물론 구성 가능성을 포기하는 대신 사용하기가 매우 쉽습니다. 하지만 간단한 구성만 원한다면 이 크레이트가 적합할 수 있습니다!</p>
<h2 id="구성-환경"><a class="header" href="#구성-환경">구성 환경</a></h2>
<aside class="todo">
<p><strong>TODO</strong></p>
<ol>
<li>기존 크레이트 평가</li>
<li>Cli-args + 여러 구성 + 환경 변수</li>
<li><a href="https://docs.rs/configure/0.1.1/configure/"><code>configure</code></a>가 이 모든 것을 할 수 있습니까? 멋진 래퍼가 있습니까?</li>
</ol>
</aside>
<div style="break-before: page; page-break-before: always;"></div><h1 id="종료-코드"><a class="header" href="#종료-코드">종료 코드</a></h1>
<p>프로그램이 항상 성공하는 것은 아닙니다. 오류가 발생하면 필요한 정보를 올바르게 내보내야 합니다. <a href="in-depth/human-communication.html">사용자에게 오류 알리기</a> 외에도 대부분의 시스템에서 프로세스가 종료될 때 종료 코드(0에서 255 사이의 정수는 대부분의 플랫폼과 호환됨)를 내보냅니다. 프로그램 상태에 대한 올바른 코드를 내보내야 합니다. 예를 들어 이상적인 경우 프로그램이 성공하면 <code>0</code>으로 종료해야 합니다.</p>
<p>오류가 발생하면 좀 더 복잡해집니다. 실제로는 많은 도구가 일반적인 실패가 발생하면 <code>1</code>로 종료됩니다. 현재 Rust는 프로세스가 패닉할 때 <code>101</code>의 종료 코드를 설정합니다. 그 외에도 사람들은 프로그램에서 많은 작업을 수행했습니다.</p>
<p>그래서 무엇을 해야 할까요? BSD 생태계는 종료 코드에 대한 일반적인 정의를 수집했습니다( <a href="https://www.freebsd.org/cgi/man.cgi?query=sysexits&amp;apropos=0&amp;sektion=0&amp;manpath=FreeBSD+11.2-stable&amp;arch=default&amp;format=html">여기</a>에서 찾을 수 있음). Rust 라이브러리 <a href="https://crates.io/crates/exitcode"><code>exitcode</code></a>는 이러한 동일한 코드를 제공하며 응용 프로그램에서 사용할 준비가 되어 있습니다. 사용 가능한 값에 대한 API 문서를 참조하십시오.</p>
<p><code>Cargo.toml</code>에 <code>exitcode</code> 의존성을 추가한 후 다음과 같이 사용할 수 있습니다.</p>
<pre><code class="language-rust ignore">fn main() {
    // ...실제 작업...
    match result {
        Ok(_) =&gt; {
            println!("Done!");
            std::process::exit(exitcode::OK);
        }
        Err(CustomError::CantReadConfig(e)) =&gt; {
            eprintln!("Error: {}", e);
            std::process::exit(exitcode::CONFIG);
        }
        Err(e) =&gt; {
            eprintln!("Error: {}", e);
            std::process::exit(exitcode::DATAERR);
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="사람과-소통하기"><a class="header" href="#사람과-소통하기">사람과 소통하기</a></h1>
<p>먼저 튜토리얼의 <a href="in-depth/../tutorial/output.html">CLI 출력 장</a>을 읽으십시오. 터미널에 출력을 작성하는 방법을 다루고, 이 장에서는 _무엇_을 출력할지에 대해 이야기합니다.</p>
<h2 id="모든-것이-괜찮을-때"><a class="header" href="#모든-것이-괜찮을-때">모든 것이 괜찮을 때</a></h2>
<p>모든 것이 괜찮을 때도 응용 프로그램의 진행 상황을 보고하는 것이 유용합니다. 이러한 메시지에서 유익하고 간결하게 작성하십시오. 로그에 지나치게 기술적인 용어를 사용하지 마십시오. 기억하세요: 응용 프로그램이 충돌하는 것이 아니므로 사용자가 오류를 찾아볼 이유가 없습니다.</p>
<p>가장 중요하게는 통신 스타일을 일관되게 유지하십시오. 동일한 접두사와 문장 구조를 사용하여 로그를 쉽게 훑어볼 수 있도록 하십시오.</p>
<p>응용 프로그램 출력이 무엇을 하고 있으며 사용자에게 어떤 영향을 미치는지에 대한 이야기를 들려주도록 노력하십시오. 여기에는 관련된 단계의 타임라인을 표시하거나 장기 실행 작업에 대한 진행률 표시줄 및 표시기를 표시하는 것이 포함될 수 있습니다. 사용자는 응용 프로그램이 따라갈 수 없는 신비한 작업을 수행하고 있다는 느낌을 받아서는 안 됩니다.</p>
<h2 id="무슨-일이-일어나고-있는지-알기-어려울-때"><a class="header" href="#무슨-일이-일어나고-있는지-알기-어려울-때">무슨 일이 일어나고 있는지 알기 어려울 때</a></h2>
<p>비정상 상태를 전달할 때는 일관성을 유지하는 것이 중요합니다. 엄격한 로깅 수준을 따르지 않는 과도한 로깅 응용 프로그램은 로깅하지 않는 응용 프로그램과 동일하거나 더 적은 정보를 제공합니다.</p>
<p>이 때문에 이벤트의 심각도와 관련된 메시지를 정의하는 것이 중요합니다. 그런 다음 일관된 로그 수준을 사용하십시오. 이렇게 하면 사용자는 <code>--verbose</code> 플래그 또는 환경 변수( <code>RUST_LOG</code> 등)를 통해 로깅 양을 직접 선택할 수 있습니다.</p>
<p>일반적으로 사용되는 <code>log</code> 크레이트는 <a href="https://docs.rs/log/0.4.4/log/enum.Level.html">다음과 같은 수준을 정의합니다</a>(심각도 증가 순서):</p>
<ul>
<li>trace</li>
<li>debug</li>
<li>info</li>
<li>warning</li>
<li>error</li>
</ul>
<p>_info_를 기본 로그 수준으로 생각하는 것이 좋습니다. 음, 유익한 출력에 사용하십시오. (더 조용한 출력 스타일을 선호하는 일부 응용 프로그램은 기본적으로 경고 및 오류만 표시할 수 있습니다.)</p>
<p>또한 로그 메시지 전반에 걸쳐 유사한 접두사와 문장 구조를 사용하는 것이 항상 좋습니다. 이렇게 하면 <code>grep</code>과 같은 도구를 사용하여 필터링하기 쉽습니다. 메시지는 필터링된 로그에서 유용할 만큼 충분한 컨텍스트를 제공해야 하며 동시에 <em>너무</em> 장황하지 않아야 합니다.</p>
<h3 id="예제-로그-문"><a class="header" href="#예제-로그-문">예제 로그 문</a></h3>
<pre><code class="language-console">error: could not find `Cargo.toml` in `/home/you/project/`
</code></pre>
<pre><code class="language-console">=&gt; Downloading repository index
=&gt; Downloading packages...
</code></pre>
<p>다음 로그 출력은 <a href="https://crates.io/crates/wasm-pack">wasm-pack</a>에서 가져온 것입니다.</p>
<pre><code class="language-console"> [1/7] Adding WASM target...
 [2/7] Compiling to WASM...
 [3/7] Creating a pkg directory...
 [4/7] Writing a package.json...
 &gt; [WARN]: Field `description` is missing from Cargo.toml. It is not necessary, but recommended
 &gt; [WARN]: Field `repository` is missing from Cargo.toml. It is not necessary, but recommended
 &gt; [WARN]: Field `license` is missing from Cargo.toml. It is not necessary, but recommended
 [5/7] Copying over your README...
 &gt; [WARN]: origin crate has no README
 [6/7] Installing WASM-bindgen...
 &gt; [INFO]: wasm-bindgen already installed
 [7/7] Running WASM-bindgen...
 Done in 1 second
</code></pre>
<h2 id="패닉-시"><a class="header" href="#패닉-시">패닉 시</a></h2>
<p>종종 잊혀지는 한 가지 측면은 프로그램이 충돌할 때도 무언가를 출력한다는 것입니다. Rust에서 “충돌“은 대부분 “패닉“입니다(즉, “운영 체제가 프로세스를 종료“하는 것과 대조되는 “제어된 충돌”). 기본적으로 패닉이 발생하면 “패닉 핸들러“가 콘솔에 일부 정보를 인쇄합니다.</p>
<p>예를 들어, <code>cargo new --bin foo</code>로 새 바이너리 프로젝트를 만들고 <code>fn main</code>의 내용을 <code>panic!("Hello World")</code>로 바꾸면 프로그램을 실행할 때 다음과 같은 결과가 나옵니다.</p>
<pre><code class="language-console">thread 'main' panicked at 'Hello, world!', src/main.rs:2:5
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>이것은 개발자인 당신에게 유용한 정보입니다. (놀랍게도 프로그램이 <code>main.rs</code> 파일의 2행 때문에 충돌했습니다). 하지만 소스 코드에 액세스할 수 없는 사용자에게는 그다지 가치가 없습니다. 사실, 혼란스러울 가능성이 높습니다. 그렇기 때문에 사용자에게 더 초점을 맞춘 출력을 제공하는 사용자 지정 패닉 핸들러를 추가하는 것이 좋습니다.</p>
<p>정확히 그렇게 하는 라이브러리 중 하나는 <a href="https://crates.io/crates/human-panic">human-panic</a>입니다. CLI 프로젝트에 추가하려면 가져와서 <code>main</code> 함수의 시작 부분에서 <code>setup_panic!()</code> 매크로를 호출합니다.</p>
<pre><code class="language-rust ignore">use human_panic::setup_panic;

fn main() {
   setup_panic!();

   panic!("Hello world")
}</code></pre>
<p>이제 매우 친근한 메시지가 표시되며 사용자에게 무엇을 할 수 있는지 알려줍니다.</p>
<pre><code class="language-console">Well, this is embarrassing.

foo had a problem and crashed. To help us diagnose the problem you can send us a crash report.

We have generated a report file at "/var/folders/n3/dkk459k908lcmkzwcmq0tcv00000gn/T/report-738e1bec-5585-47a4-8158-f1f7227f0168.toml". Submit an issue or email with the subject of "foo Crash Report" and include the report as an attachment.

- Authors: Your Name &lt;your.name@example.com&gt;

We take privacy seriously, and do not perform any automated error collection. In order to improve the software, we rely on people to submit reports.

Thank you kindly!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="기계와-소통하기"><a class="header" href="#기계와-소통하기">기계와 소통하기</a></h1>
<p>명령줄 도구의 힘은 결합할 수 있을 때 진정으로 빛을 발합니다. 이것은 새로운 아이디어가 아닙니다. 사실, 이것은 <a href="https://en.wikipedia.org/wiki/Unix_philosophy">Unix 철학</a>의 문장입니다.</p>
<blockquote>
<p>모든 프로그램의 출력이 아직 알려지지 않은 다른 프로그램의 입력이 될 것으로 예상하십시오.</p>
</blockquote>
<p>우리 프로그램이 이 기대를 충족하면 사용자는 행복할 것입니다. 이것이 잘 작동하도록 하려면 사람들에게 보기 좋은 출력뿐만 아니라 다른 프로그램에 필요한 맞춤 버전도 제공해야 합니다. 이를 수행하는 방법을 살펴봅시다.</p>
<aside>
<p><strong>Note:</strong> Make sure to read <a href="in-depth/../tutorial/output.html">the chapter on CLI output</a> in the tutorial first. It covers how to write output to the terminal.</p>
</aside>
<h2 id="누가-이것을-읽고-있습니까"><a class="header" href="#누가-이것을-읽고-있습니까">누가 이것을 읽고 있습니까?</a></h2>
<p>먼저 물어볼 질문은 다음과 같습니다. 우리의 출력은 화려한 터미널 앞의 사람을 위한 것인가요, 아니면 다른 프로그램을 위한 것인가요? 답하기 위해 <a href="https://doc.rust-lang.org/stable/std/io/trait.IsTerminal.html">IsTerminal</a> 특성을 사용할 수 있습니다.</p>
<pre><code class="language-rust ignore">use std::io::IsTerminal;

if std::io::stdout().is_terminal() {
    println!("I'm a terminal");
} else {
    println!("I'm not");
}</code></pre>
<p>출력을 읽을 사람에 따라 추가 정보를 추가할 수 있습니다. 예를 들어, 무작위 Rust 프로젝트에서 <code>ls</code>를 실행하면 다음과 같은 것을 볼 수 있습니다. 예를 들어 사람들은 색상을 좋아합니다.</p>
<pre><code class="language-console">$ ls
CODE_OF_CONDUCT.md   LICENSE-APACHE       examples
CONTRIBUTING.md      LICENSE-MIT          proptest-regressions
Cargo.lock           README.md            src
Cargo.toml           convey_derive        target
</code></pre>
<p>이 스타일은 사람들을 위해 만들어졌기 때문에 대부분의 구성에서는 <code>src</code>와 같은 일부 이름을 색상으로 표시하여 디렉토리임을 보여줍니다. 대신 파일이나 <code>cat</code>과 같은 프로그램으로 파이프하면 <code>ls</code>가 출력을 조정합니다. 터미널 창에 맞는 열을 사용하는 대신 각 항목을 자체 줄에 인쇄합니다. 색상도 출력하지 않습니다.</p>
<pre><code class="language-console">$ ls | cat
CODE_OF_CONDUCT.md
CONTRIBUTING.md
Cargo.lock
Cargo.toml
LICENSE-APACHE
LICENSE-MIT
README.md
convey_derive
examples
proptest-regressions
src
target
</code></pre>
<h2 id="기계를-위한-쉬운-출력-형식"><a class="header" href="#기계를-위한-쉬운-출력-형식">기계를 위한 쉬운 출력 형식</a></h2>
<p>역사적으로 명령줄 도구가 생성한 유일한 유형의 출력은 문자열이었습니다. 이것은 일반적으로 텍스트를 읽고 그 의미를 추론할 수 있는 터미널 앞의 사람들에게는 괜찮습니다. 그러나 다른 프로그램은 일반적으로 그 능력이 없습니다. <code>ls</code>와 같은 도구의 출력을 이해하는 유일한 방법은 프로그램 작성자가 <code>ls</code>가 출력하는 모든 것에 대해 작동하는 파서를 포함한 경우입니다.</p>
<p>이것은 종종 출력이 구문 분석하기 쉬운 것으로 제한된다는 것을 의미합니다. 각 레코드가 자체 줄에 있고 각 줄에 탭으로 구분된 콘텐츠가 포함된 TSV(탭으로 구분된 값)와 같은 형식은 매우 인기가 있습니다. 텍스트 줄을 기반으로 하는 이러한 간단한 형식은 <code>grep</code>과 같은 도구를 <code>ls</code>와 같은 도구의 출력에 사용할 수 있도록 합니다. <code>| grep Cargo</code>는 줄이 <code>ls</code>에서 왔는지 파일에서 왔는지 신경 쓰지 않고 줄별로 필터링합니다.</p>
<p>이것의 단점은 <code>ls</code>가 제공한 모든 디렉토리를 필터링하기 위해 간단한 <code>grep</code> 호출을 사용할 수 없다는 것입니다. 이를 위해서는 각 디렉토리 항목에 추가 데이터가 포함되어야 합니다.</p>
<h2 id="기계를-위한-json-출력"><a class="header" href="#기계를-위한-json-출력">기계를 위한 JSON 출력</a></h2>
<p>탭으로 구분된 값은 구조화된 데이터를 출력하는 간단한 방법이지만 다른 프로그램이 어떤 필드를 예상해야 하는지(및 어떤 순서로) 알아야 하며 다른 유형의 메시지를 출력하기 어렵습니다. 예를 들어, 우리 프로그램이 소비자에게 현재 다운로드를 기다리고 있다고 메시지를 보내고 그 후 받은 데이터를 설명하는 메시지를 출력한다고 가정해 봅시다. 이것들은 매우 다른 종류의 메시지이며 TSV 출력에서 이를 통합하려고 하면 차별화할 방법을 발명해야 합니다. 가변 길이 항목의 두 목록을 포함하는 메시지를 인쇄하려고 할 때도 마찬가지입니다.</p>
<p>그럼에도 불구하고 대부분의 프로그래밍 언어/환경에서 쉽게 구문 분석할 수 있는 형식을 선택하는 것이 좋습니다. 따라서 지난 몇 년 동안 많은 응용 프로그램이 <a href="https://www.json.org/">JSON</a>으로 데이터를 출력하는 기능을 갖추게 되었습니다. 거의 모든 언어에 파서가 존재할 만큼 간단하지만 많은 경우에 유용할 만큼 강력합니다. 사람이 읽을 수 있는 텍스트 형식이지만 많은 사람들이 JSON 데이터를 구문 분석하고 데이터를 JSON으로 직렬화하는 데 매우 빠른 구현을 작업했습니다.</p>
<p>위 설명에서 프로그램에서 작성하는 “메시지“에 대해 이야기했습니다. 이것은 출력을 생각하는 좋은 방법입니다. 프로그램이 반드시 하나의 데이터 덩어리만 출력하는 것이 아니라 실행 중에 많은 다른 정보를 방출할 수 있습니다. JSON을 출력할 때 이 접근 방식을 지원하는 한 가지 쉬운 방법은 메시지당 하나의 JSON 문서를 작성하고 각 JSON 문서를 새 줄에 넣는 것입니다(때로는 <a href="https://en.wikipedia.org/wiki/JSON_streaming#Line-delimited_JSON">줄 구분 JSON</a>이라고 함). 이렇게 하면 일반 <code>println!</code>을 사용하는 것처럼 구현을 간단하게 만들 수 있습니다.</p>
<p>다음은 <a href="https://crates.io/crates/serde_json">serde_json</a>의 <code>json!</code> 매크로를 사용하여 Rust 소스 코드에 유효한 JSON을 빠르게 작성하는 간단한 예입니다.</p>
<pre><code class="language-rust ignore">use clap::Parser;
use serde_json::json;

/// 파일에서 패턴을 검색하고 해당 패턴을 포함하는 줄을 표시합니다.
#[derive(Parser)]
struct Cli {
    /// 사람이 읽을 수 있는 메시지 대신 JSON 출력
    #[arg(long = "json")]
    json: bool,
}

fn main() {
    let args = Cli::parse();
    if args.json {
        println!(
            "{}",
            json!({
                "type": "message",
                "content": "Hello world",
            })
        );
    } else {
        println!("Hello world");
    }
}</code></pre>
<p>그리고 여기 출력이 있습니다.</p>
<pre><code class="language-console">$ cargo run -q
Hello world
$ cargo run -q -- --json
{"content":"Hello world","type":"message"}
</code></pre>
<p>(<code>cargo</code>를 <code>-q</code>와 함께 실행하면 일반 출력이 억제됩니다. <code>--</code> 뒤의 인수는 프로그램에 전달됩니다.)</p>
<h3 id="실용적인-예-ripgrep"><a class="header" href="#실용적인-예-ripgrep">실용적인 예: ripgrep</a></h3>
<p>_<a href="https://github.com/BurntSushi/ripgrep">ripgrep</a>_은 <em>grep</em> 또는 _ag_의 대안이며 Rust로 작성되었습니다. 기본적으로 다음과 같은 출력을 생성합니다.</p>
<pre><code class="language-console">$ rg default
src/lib.rs
37:    Output::default()

src/components/span.rs
6:    Span::default()
</code></pre>
<p>하지만 <code>--json</code>을 제공하면 다음과 같이 인쇄됩니다.</p>
<pre><code class="language-console">$ rg default --json
{"type":"begin","data":{"path":{"text":"src/lib.rs"}}}
{"type":"match","data":{"path":{"text":"src/lib.rs"},"lines":{"text":"    Output::default()\n"},"line_number":37,"absolute_offset":761,"submatches":[{"match":{"text":"default"},"start":12,"end":19}]}}
{"type":"end","data":{"path":{"text":"src/lib.rs"},"binary_offset":null,"stats":{"elapsed":{"secs":0,"nanos":137622,"human":"0.000138s"},"searches":1,"searches_with_match":1,"bytes_searched":6064,"bytes_printed":256,"matched_lines":1,"matches":1}}}
{"type":"begin","data":{"path":{"text":"src/components/span.rs"}}}
{"type":"match","data":{"path":{"text":"src/components/span.rs"},"lines":{"text":"    Span::default()\n"},"line_number":6,"absolute_offset":117,"submatches":[{"match":{"text":"default"},"start":10,"end":17}]}}
{"type":"end","data":{"path":{"text":"src/components/span.rs"},"binary_offset":null,"stats":{"elapsed":{"secs":0,"nanos":22025,"human":"0.000022s"},"searches":1,"searches_with_match":1,"bytes_searched":5221,"bytes_printed":277,"matched_lines":1,"matches":1}}}
{"data":{"elapsed_total":{"human":"0.006995s","nanos":6994920,"secs":0},"stats":{"bytes_printed":533,"bytes_searched":11285,"elapsed":{"human":"0.000160s","nanos":159647,"secs":0},"matched_lines":2,"matches":2,"searches":2,"searches_with_match":2}},"type":"summary"}
</code></pre>
<p>보시다시피 각 JSON 문서는 <code>type</code> 필드를 포함하는 객체(맵)입니다. 이를 통해 <code>rg</code>에 대한 간단한 프런트엔드를 작성하여 문서를 수신하는 대로 읽고 _ripgrep_이 아직 검색 중일 때도 일치 항목(파일 포함)을 표시할 수 있습니다.</p>
<aside>
<p><strong>참고:</strong> 이것이 Visual Studio Code가 코드 검색에 _ripgrep_을 사용하는 방식입니다.</p>
</aside>
<h2 id="파이프된-입력을-처리하는-방법"><a class="header" href="#파이프된-입력을-처리하는-방법">파이프된 입력을 처리하는 방법</a></h2>
<p>파일의 단어 수를 읽는 프로그램이 있다고 가정해 봅시다.</p>
<pre><code class="language-rust ignore">use clap::Parser;
use std::path::PathBuf;

/// 파일의 줄 수 계산
#[derive(Parser)]
#[command(arg_required_else_help = true)]
struct Cli {
    /// 읽을 파일의 경로
    file: PathBuf,
}

fn main() {
    let args = Cli::parse();
    let mut word_count = 0;
    let file = args.file;

    for line in std::fs::read_to_string(&amp;file).unwrap().lines() {
        word_count += line.split(' ').count();
    }

    println!("Words in {}: {}", file.to_str().unwrap(), word_count)
}</code></pre>
<p>파일 경로를 가져와 줄별로 읽고 공백으로 구분된 단어 수를 계산합니다.</p>
<p>실행하면 파일의 총 단어 수가 출력됩니다.</p>
<pre><code class="language-console">$ cargo run README.md
Words in README.md: 47
</code></pre>
<p>하지만 프로그램으로 파이프된 단어 수를 세고 싶다면 어떻게 될까요? Rust 프로그램은 표준 라이브러리의 <a href="https://doc.rust-lang.org/std/io/fn.stdin.html">stdin 함수</a>를 통해 얻을 수 있는 <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html">Stdin 구조체</a>를 사용하여 stdin을 통해 전달된 데이터를 읽을 수 있습니다. 파일 줄을 읽는 것과 유사하게 stdin에서 줄을 읽을 수 있습니다.</p>
<p>stdin을 통해 파이프된 단어를 계산하는 프로그램입니다.</p>
<pre><code class="language-rust ignore">use clap::{CommandFactory, Parser};
use std::{
    fs::File,
    io::{stdin, BufRead, BufReader, IsTerminal},
    path::PathBuf,
};

/// 파일 또는 stdin의 줄 수 계산
#[derive(Parser)]
#[command(arg_required_else_help = true)]
struct Cli {
    /// 읽을 파일의 경로, stdin에서 읽으려면 - 사용(tty여서는 안 됨)
    file: PathBuf,
}

fn main() {
    let args = Cli::parse();

    let word_count;
    let mut file = args.file;

    if file == PathBuf::from("-") {
        if stdin().is_terminal() {
            Cli::command().print_help().unwrap();
            ::std::process::exit(2);
        }

        file = PathBuf::from("&lt;stdin&gt;");
        word_count = words_in_buf_reader(BufReader::new(stdin().lock()));
    } else {
        word_count = words_in_buf_reader(BufReader::new(File::open(&amp;file).unwrap()));
    }

    println!("Words from {}: {}", file.to_string_lossy(), word_count)
}

fn words_in_buf_reader&lt;R: BufRead&gt;(buf_reader: R) -&gt; usize {
    let mut count = 0;
    for line in buf_reader.lines() {
        count += line.unwrap().split(' ').count()
    }
    count
}</code></pre>
<p><code>stdin</code>에서 읽으려는 의도를 나타내는 <code>-</code>를 사용하여 텍스트를 파이프한 프로그램으로 실행하면 단어 수가 출력됩니다.</p>
<pre><code class="language-console">$ echo "hi there friend" | cargo run -- -
Words from stdin: 3
</code></pre>
<p>런타임에 입력되는 텍스트가 아니라 프로그램으로 파이프되는 입력을 예상하기 때문에 stdin이 대화형이 아니어야 합니다. stdin이 tty인 경우 작동하지 않는 이유를 명확히 하기 위해 도움말 문서를 출력합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cli-앱용-문서-렌더링"><a class="header" href="#cli-앱용-문서-렌더링">CLI 앱용 문서 렌더링</a></h1>
<p>CLI의 문서는 일반적으로 명령의 <code>--help</code> 섹션과 매뉴얼(<code>man</code>) 페이지로 구성됩니다.</p>
<p>둘 다 <a href="https://crates.io/crates/clap"><code>clap</code></a>을 사용할 때 <a href="https://crates.io/crates/clap_mangen"><code>clap_mangen</code></a> 크레이트를 통해 자동으로 생성될 수 있습니다.</p>
<pre><code class="language-rust ignore">#[derive(Parser)]
pub struct Head {
    /// 로드할 파일
    pub file: PathBuf,
    /// 인쇄할 줄 수
    #[arg(short = "n", default_value = "5")]
    pub count: usize,
}</code></pre>
<p>둘째, 코드로 앱을 정의한 후 컴파일 시간에 매뉴얼 파일을 생성하기 위해 <code>build.rs</code>를 사용해야 합니다.</p>
<p>명심해야 할 몇 가지 사항이 있습니다(바이너리를 패키징하는 방법 등). 하지만 지금은 <code>man</code> 파일을 <code>src</code> 폴더 옆에 두겠습니다.</p>
<pre><code class="language-rust ignore">use clap::CommandFactory;

#[path="src/cli.rs"]
mod cli;

fn main() -&gt; std::io::Result&lt;()&gt; {
    let out_dir = std::path::PathBuf::from(std::env::var_os("OUT_DIR").ok_or_else(|| std::io::ErrorKind::NotFound)?);
    let cmd = cli::Head::command();

    let man = clap_mangen::Man::new(cmd);
    let mut buffer: Vec&lt;u8&gt; = Default::default();
    man.render(&amp;mut buffer)?;

    std::fs::write(out_dir.join("head.1"), buffer)?;

    Ok(())
}</code></pre>
<p>이제 응용 프로그램을 컴파일하면 프로젝트 디렉토리에 <code>head.1</code> 파일이 생성됩니다.</p>
<p><code>man</code>에서 열면 무료 문서를 감상할 수 있습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="리소스"><a class="header" href="#리소스">리소스</a></h1>
<p>협업 / 도움</p>
<ul>
<li><a href="https://discord.com/channels/273534239310479360/943315667430563862">cli-and-tui Discord 채널</a></li>
</ul>
<h2 id="이-책에서-참조된-크레이트"><a class="header" href="#이-책에서-참조된-크레이트">이 책에서 참조된 크레이트</a></h2>
<ul>
<li><a href="https://crates.io/crates/anyhow">anyhow</a> - 쉬운 오류 처리를 위한 <code>anyhow::Error</code> 제공</li>
<li><a href="https://crates.io/crates/assert_cmd">assert_cmd</a> - CLI 통합 테스트 단순화</li>
<li><a href="https://crates.io/crates/assert_fs">assert_fs</a> - 입력 파일 설정 및 출력 파일 테스트</li>
<li><a href="https://crates.io/crates/clap-verbosity-flag">clap-verbosity-flag</a> - clap CLI에 <code>--verbose</code> 플래그 추가</li>
<li><a href="https://crates.io/crates/clap">clap</a> - 명령줄 인수 파서</li>
<li><a href="https://crates.io/crates/confy">confy</a> - 보일러플레이트 없는 구성 관리</li>
<li><a href="https://crates.io/crates/crossbeam-channel">crossbeam-channel</a> - 메시지 전달을 위한 다중 생산자 다중 소비자 채널 제공</li>
<li><a href="https://crates.io/crates/ctrlc">ctrlc</a> - 쉬운 ctrl-c 핸들러</li>
<li><a href="https://crates.io/crates/env_logger">env_logger</a> - 환경 변수를 통해 구성 가능한 로거 구현</li>
<li><a href="https://crates.io/crates/exitcode">exitcode</a> - 시스템 종료 코드 상수</li>
<li><a href="https://crates.io/crates/human-panic">human-panic</a> - 패닉 메시지 핸들러</li>
<li><a href="https://crates.io/crates/indicatif">indicatif</a> - 진행률 표시줄 및 스피너</li>
<li><a href="https://crates.io/crates/log">log</a> - 구현에 추상화된 로깅 제공</li>
<li><a href="https://crates.io/crates/predicates">predicates</a> - 부울 값 술어 함수 구현</li>
<li><a href="https://crates.io/crates/proptest">proptest</a> - 속성 테스트 프레임워크</li>
<li><a href="https://crates.io/crates/serde_json">serde_json</a> - JSON으로 직렬화/역직렬화</li>
<li><a href="https://crates.io/crates/signal-hook">signal-hook</a> - UNIX 신호 처리</li>
<li><a href="https://crates.io/crates/tokio">tokio</a> - 비동기 런타임</li>
<li><a href="https://crates.io/crates/wasm-pack">wasm-pack</a> - WebAssembly 빌드 도구</li>
</ul>
<h2 id="기타-크레이트"><a class="header" href="#기타-크레이트">기타 크레이트</a></h2>
<p>Rust 크레이트의 끊임없이 변화하는 환경 때문에 크레이트를 찾을 수 있는 좋은 장소는 <a href="https://lib.rs">lib.rs</a> 크레이트 인덱스이며, 다음을 포함합니다.</p>
<ul>
<li><a href="https://lib.rs/command-line-interface">명령줄 인터페이스</a></li>
<li><a href="https://lib.rs/config">구성</a></li>
<li><a href="https://lib.rs/database">데이터베이스 인터페이스</a></li>
<li><a href="https://lib.rs/encoding">인코딩</a></li>
<li><a href="https://lib.rs/filesystem">파일 시스템</a></li>
<li><a href="https://lib.rs/web-programming/http-client">HTTP 클라이언트</a></li>
<li><a href="https://lib.rs/os">운영 체제</a></li>
</ul>
<p>기타 리소스:</p>
<ul>
<li><a href="https://rust-lang-nursery.github.io/rust-cookbook/">Rust Cookbook</a></li>
<li><a href="https://github.com/rosetta-rs">rosetta-rs</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/language-picker.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
