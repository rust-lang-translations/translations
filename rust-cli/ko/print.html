<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Command Line Applications in Rust</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/rust-cli";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/print.md`;
                    } else {
                        canonical_href = `${base}/${lang}/print.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/special-content.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Command Line Applications in Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust의-명령줄-앱"><a class="header" href="#rust의-명령줄-앱">Rust의 명령줄 앱</a></h1>
<p>Rust는 정적으로 컴파일되고, 훌륭한 도구와 빠르게 성장하는 생태계를 갖춘 빠른 언어입니다. 따라서 명령줄 응용 프로그램을 작성하는 데 매우 적합합니다. 작고, 이식 가능하며, 빠르게 실행되어야 합니다. 명령줄 응용 프로그램은 Rust 학습을 시작하거나 팀에 Rust를 소개하는 좋은 방법이기도 합니다!</p>
<p>간단한 명령줄 인터페이스(CLI)를 사용하여 프로그램을 작성하는 것은 언어에 익숙하지 않고 감을 잡고 싶은 초보자에게 훌륭한 연습입니다. 그러나 이 주제에는 나중에야 드러나는 많은 측면이 있습니다.</p>
<p>이 책은 다음과 같이 구성되어 있습니다. 빠른 튜토리얼로 시작하여 작동하는 CLI 도구를 완성하게 됩니다. Rust의 몇 가지 핵심 개념과 CLI 응용 프로그램의 주요 측면을 접하게 될 것입니다. 그 다음에는 이러한 측면 중 일부에 대해 더 자세히 설명하는 장이 이어집니다.</p>
<p>CLI 응용 프로그램에 바로 뛰어들기 전에 마지막으로 한 가지: 이 책에서 오류를 발견하거나 더 많은 콘텐츠를 작성하는 데 도움을 주고 싶다면 <a href="https://github.com/rust-cli/book">CLI 책 리포지토리</a>에서 소스를 찾을 수 있습니다. 여러분의 피드백을 기다리겠습니다! 감사합니다!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="15분-만에-명령줄-앱을-작성하여-rust-배우기"><a class="header" href="#15분-만에-명령줄-앱을-작성하여-rust-배우기">15분 만에 명령줄 앱을 작성하여 Rust 배우기</a></h1>
<p>이 튜토리얼은 <a href="https://rust-lang.org/">Rust</a>로 CLI(명령줄 인터페이스) 응용 프로그램을 작성하는 과정을 안내합니다. 실행 중인 프로그램(1.3장 정도)을 갖게 되기까지 약 15분이 소요됩니다. 그 후에는 작은 도구를 출시할 수 있는 지점에 도달할 때까지 프로그램을 계속 수정할 것입니다.</p>
<p>시작하는 방법과 더 많은 정보를 찾을 수 있는 위치에 대한 모든 필수 사항을 배우게 됩니다. 지금 당장 알 필요가 없는 부분은 건너뛰거나 언제든지 뛰어들 수 있습니다.</p>
<aside>
<p><strong>전제 조건:</strong> 이 튜토리얼은 프로그래밍에 대한 일반적인 소개를 대체하지 않으며 몇 가지 일반적인 개념에 익숙해야 합니다. 명령줄/터미널 사용에 익숙해야 합니다. 이미 다른 언어를 몇 가지 알고 있다면 Rust와의 좋은 첫 만남이 될 수 있습니다.</p>
<p><strong>도움 받기:</strong> 어느 시점에서든 사용된 기능에 압도되거나 혼란스러우면 Rust와 함께 제공되는 광범위한 공식 문서, 특히 The Rust Programming Language 책을 참조하세요. 대부분의 Rust 설치(<code>rustup doc</code>)와 함께 제공되며 <a href="https://doc.rust-lang.org">doc.rust-lang.org</a>에서 온라인으로 볼 수 있습니다.</p>
<p>질문하는 것도 매우 환영합니다. Rust 커뮤니티는 친절하고 도움이 되는 것으로 알려져 있습니다. <a href="https://www.rust-lang.org/community">커뮤니티 페이지</a>를 방문하여 사람들이 Rust에 대해 토론하는 장소 목록을 확인하세요.</p>
</aside>
<p>어떤 종류의 프로젝트를 작성하고 싶으신가요? 간단한 것부터 시작해 봅시다. 작은 <code>grep</code> 클론을 작성해 봅시다. 즉, 문자열과 경로를 제공하면 주어진 문자열을 포함하는 줄만 인쇄하는 도구입니다. <code>grrs</code>(“그래스”로 발음)라고 부릅시다.</p>
<p>결국에는 다음과 같이 도구를 실행할 수 있기를 원합니다.</p>
<pre><code class="language-console">$ cat test.txt
foo: 10
bar: 20
baz: 30
$ grrs foo test.txt
foo: 10
$ grrs --help
[some help text explaining the available options]
</code></pre>
<aside class="note">
<p><strong>참고:</strong> 이 책은 <a href="https://doc.rust-lang.org/edition-guide/index.html">Rust 2018</a>용으로 작성되었습니다. 코드 예제는 Rust 2015에서도 사용할 수 있지만 약간 수정해야 할 수도 있습니다. 예를 들어 <code>extern crate foo;</code> 호출을 추가해야 합니다.</p>
<p>Rust 1.31.0 이상을 실행하고 <code>Cargo.toml</code> 파일의 <code>[package]</code> 섹션에 <code>edition = "2018"</code>이 설정되어 있는지 확인하세요.</p>
</aside>
<div style="break-before: page; page-break-before: always;"></div><h1 id="프로젝트-설정"><a class="header" href="#프로젝트-설정">프로젝트 설정</a></h1>
<p>아직 설치하지 않았다면 컴퓨터에 <a href="https://www.rust-lang.org/tools/install">Rust를 설치</a>하세요(몇 분밖에 걸리지 않습니다). 그런 다음 터미널을 열고 응용 프로그램 코드를 넣을 디렉토리로 이동합니다.</p>
<p>프로그래밍 프로젝트를 저장하는 디렉토리에서 <code>cargo new grrs</code>를 실행하여 시작합니다. 새로 생성된 <code>grrs</code> 디렉토리를 보면 Rust 프로젝트의 일반적인 설정을 찾을 수 있습니다.</p>
<ul>
<li>프로젝트에 대한 메타데이터를 포함하는 <code>Cargo.toml</code> 파일, 우리가 사용하는 의존성/외부 라이브러리 목록 포함.</li>
<li>(주) 바이너리의 진입점인 <code>src/main.rs</code> 파일.</li>
</ul>
<p><code>grrs</code> 디렉토리에서 <code>cargo run</code>을 실행하고 “Hello World“를 얻을 수 있다면 모든 설정이 완료된 것입니다.</p>
<h2 id="어떻게-보일-수-있는지"><a class="header" href="#어떻게-보일-수-있는지">어떻게 보일 수 있는지</a></h2>
<pre><code class="language-console">$ cargo new grrs
     Created binary (application) `grrs` package
$ cd grrs/
$ cargo run
   Compiling grrs v0.1.0 (/Users/pascal/code/grrs)
    Finished dev [unoptimized + debuginfo] target(s) in 0.70s
     Running `target/debug/grrs`
Hello, world!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="명령줄-인수-구문-분석"><a class="header" href="#명령줄-인수-구문-분석">명령줄 인수 구문 분석</a></h1>
<p>CLI 도구의 일반적인 호출은 다음과 같습니다.</p>
<pre><code class="language-console">$ grrs foobar test.txt
</code></pre>
<p>우리는 프로그램이 <code>test.txt</code>를 보고 <code>foobar</code>를 포함하는 줄을 인쇄하기를 기대합니다. 하지만 이 두 값을 어떻게 얻을 수 있을까요?</p>
<p>프로그램 이름 뒤의 텍스트는 종종 “명령줄 인수” 또는 “명령줄 플래그”(특히 <code>--this</code>처럼 보일 때)라고 합니다. 내부적으로 운영 체제는 일반적으로 이를 문자열 목록으로 나타냅니다. 대략적으로 말하면 공백으로 구분됩니다.</p>
<p>이러한 인수에 대해 생각하고 더 쉽게 작업할 수 있는 것으로 구문 분석하는 방법에는 여러 가지가 있습니다. 또한 프로그램 사용자에게 어떤 인수를 어떤 형식으로 제공해야 하는지 알려야 합니다.</p>
<h2 id="인수-가져오기"><a class="header" href="#인수-가져오기">인수 가져오기</a></h2>
<p>The standard library contains the function <a href="https://doc.rust-lang.org/1.39.0/std/env/fn.args.html"><code>std::env::args()</code></a> that gives you an <a href="https://doc.rust-lang.org/1.39.0/std/iter/index.html">iterator</a> of the given arguments. The first entry (at index <code>0</code>) will be the name your program was called as (e.g. <code>grrs</code>), the ones that follow are what the user wrote afterwards.</p>
<p>이러한 방식으로 원시 인수를 얻는 것은 매우 쉽습니다(<code>src/main.rs</code> 파일에서).</p>
<pre><code class="language-rust ignore">fn main() {
    let pattern = std::env::args().nth(1).expect("no pattern given");
    let path = std::env::args().nth(2).expect("no path given");

    println!("pattern: {:?}, path: {:?}", pattern, path)
}</code></pre>
<p><code>cargo run</code>을 사용하여 실행할 수 있으며, <code>--</code> 뒤에 인수를 작성하여 전달합니다.</p>
<pre><code class="language-console">$ cargo run -- some-pattern some-file
    Finished dev [unoptimized + debuginfo] target(s) in 0.11s
     Running `target/debug/grrs some-pattern some-file`
pattern: "some-pattern", path: "some-file"
</code></pre>
<h2 id="데이터-유형으로서의-cli-인수"><a class="header" href="#데이터-유형으로서의-cli-인수">데이터 유형으로서의 CLI 인수</a></h2>
<p>텍스트 뭉치로 생각하는 대신 CLI 인수를 프로그램에 대한 입력을 나타내는 사용자 지정 데이터 유형으로 생각하는 것이 종종 더 좋습니다.</p>
<p><code>grrs foobar test.txt</code>를 보세요. 두 개의 인수가 있습니다. 첫 번째는 <code>pattern</code>(찾을 문자열)이고 두 번째는 <code>path</code>(찾을 파일)입니다.</p>
<p>그것들에 대해 더 무엇을 말할 수 있을까요? 음, 우선 둘 다 필요합니다. 기본값에 대해 이야기하지 않았으므로 사용자가 항상 두 값을 제공할 것으로 예상합니다. 또한 유형에 대해 약간 말할 수 있습니다. 패턴은 문자열이어야 하고 두 번째 인수는 파일 경로여야 합니다.</p>
<p>Rust에서는 처리하는 데이터를 중심으로 프로그램을 구성하는 것이 일반적이므로 이러한 CLI 인수를 보는 방식이 매우 적합합니다. 이것부터 시작해 봅시다(<code>src/main.rs</code> 파일에서 <code>fn main() {</code> 이전).</p>
<pre><code class="language-rust ignore">struct Cli {
    pattern: String,
    path: std::path::PathBuf,
}</code></pre>
<p>이것은 데이터를 저장할 두 개의 필드, 즉 <code>pattern</code>과 <code>path</code>를 가진 새로운 구조체(<a href="https://doc.rust-lang.org/1.39.0/book/ch05-00-structs.html"><code>struct</code></a>)를 정의합니다.</p>
<aside>
<p><strong>참고:</strong> <a href="https://doc.rust-lang.org/1.39.0/std/path/struct.PathBuf.html"><code>PathBuf</code></a>는 <a href="https://doc.rust-lang.org/1.39.0/std/string/struct.String.html"><code>String</code></a>과 같지만 크로스 플랫폼에서 작동하는 파일 시스템 경로용입니다.</p>
</aside>
<p>이제 프로그램이 얻은 실제 인수를 이 형식으로 가져와야 합니다. 한 가지 옵션은 운영 체제에서 얻은 문자열 목록을 수동으로 구문 분석하고 구조를 직접 빌드하는 것입니다. 다음과 같이 보일 것입니다.</p>
<pre><code class="language-rust ignore">fn main() {
    let pattern = std::env::args().nth(1).expect("no pattern given");
    let path = std::env::args().nth(2).expect("no path given");

    let args = Cli {
        pattern,
        path: std::path::PathBuf::from(path),
    };

    println!("pattern: {:?}, path: {:?}", args.pattern, args.path);
}</code></pre>
<p>이것은 작동하지만 그다지 편리하지 않습니다. <code>--pattern="foo"</code> 또는 <code>--pattern "foo"</code>를 지원해야 하는 요구 사항을 어떻게 처리하시겠습니까? <code>--help</code>를 어떻게 구현하시겠습니까?</p>
<h2 id="clap으로-cli-인수-구문-분석"><a class="header" href="#clap으로-cli-인수-구문-분석">Clap으로 CLI 인수 구문 분석</a></h2>
<p>더 좋은 방법은 사용 가능한 많은 라이브러리 중 하나를 사용하는 것입니다. 명령줄 인수를 구문 분석하는 가장 인기 있는 라이브러리는 <a href="https://docs.rs/clap/"><code>clap</code></a>입니다. 하위 명령, <a href="https://docs.rs/clap_complete/">셸 완성</a> 및 훌륭한 도움말 메시지를 포함하여 기대하는 모든 기능을 갖추고 있습니다.</p>
<p>먼저 <code>Cargo.toml</code> 파일의 <code>[dependencies]</code> 섹션에 <code>clap = { version = "4.0", features = ["derive"] }</code>를 추가하여 <code>clap</code>을 가져옵니다.</p>
<p>이제 코드에 <code>use clap::Parser;</code>를 작성하고 <code>struct Cli</code> 바로 위에 <code>#[derive(Parser)]</code>를 추가할 수 있습니다. 그 과정에서 몇 가지 문서 주석도 작성해 봅시다.</p>
<p>다음과 같이 보일 것입니다(<code>src/main.rs</code> 파일에서 <code>fn main() {</code> 이전).</p>
<pre><code class="language-rust ignore">use clap::Parser;

/// 파일에서 패턴을 검색하고 해당 패턴을 포함하는 줄을 표시합니다.
#[derive(Parser)]
struct Cli {
    /// 찾을 패턴
    pattern: String,
    /// 읽을 파일의 경로
    path: std::path::PathBuf,
}</code></pre>
<aside class="node">
<p><strong>참고:</strong> 필드에 추가할 수 있는 사용자 지정 속성이 많이 있습니다. 예를 들어 <code>-o</code> 또는 <code>--output</code> 뒤의 인수에 이 필드를 사용하려면 <code>#[arg(short = 'o', long = "output")]</code>를 추가합니다. 자세한 내용은 <a href="https://docs.rs/clap/">clap 문서</a>를 참조하세요.</p>
</aside>
<p><code>Cli</code> 구조체 바로 아래에 템플릿에 <code>main</code> 함수가 포함되어 있습니다. 프로그램이 시작되면 이 함수를 호출합니다.</p>
<pre><code class="language-rust ignore">fn main() {
    let args = Cli::parse();

    println!("pattern: {:?}, path: {:?}", args.pattern, args.path)
}</code></pre>
<p>이렇게 하면 인수를 <code>Cli</code> 구조체로 구문 분석하려고 시도합니다.</p>
<p>하지만 실패하면 어떻게 될까요? 이것이 이 접근 방식의 장점입니다. Clap은 어떤 필드를 예상해야 하는지, 그리고 예상 형식이 무엇인지 알고 있습니다. <code>--help</code> 메시지를 자동으로 생성하고 <code>--putput</code>을 작성했을 때 <code>--output</code>을 전달하도록 제안하는 훌륭한 오류를 제공할 수 있습니다.</p>
<aside class="note">
<p><strong>참고:</strong> <code>parse</code> 메서드는 <code>main</code> 함수에서 사용하기 위한 것입니다. 실패하면 오류 또는 도움말 메시지를 인쇄하고 즉시 프로그램을 종료합니다. 다른 곳에서는 사용하지 마세요!</p>
</aside>
<h2 id="마무리"><a class="header" href="#마무리">마무리</a></h2>
<p>이제 코드는 다음과 같아야 합니다.</p>
<pre><code class="language-rust ignore">use clap::Parser;

/// 파일에서 패턴을 검색하고 해당 패턴을 포함하는 줄을 표시합니다.
#[derive(Parser)]
struct Cli {
    /// 찾을 패턴
    pattern: String,
    /// 읽을 파일의 경로
    path: std::path::PathBuf,
}

fn main() {
    let args = Cli::parse();

    println!("pattern: {:?}, path: {:?}", args.pattern, args.path)
}</code></pre>
<p>인수 없이 실행:</p>
<pre><code class="language-console">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 10.16s
     Running `target/debug/grrs`
error: The following required arguments were not provided:
    &lt;pattern&gt;
    &lt;path&gt;

USAGE:
    grrs &lt;pattern&gt; &lt;path&gt;

For more information try --help
</code></pre>
<p>인수를 전달하여 실행:</p>
<pre><code class="language-console">$ cargo run -- some-pattern some-file
    Finished dev [unoptimized + debuginfo] target(s) in 0.11s
     Running `target/debug/grrs some-pattern some-file`
pattern: "some-pattern", path: "some-file"
</code></pre>
<p>출력은 프로그램이 인수를 <code>Cli</code> 구조체로 성공적으로 구문 분석했음을 보여줍니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="_grrs_의-첫-번째-구현"><a class="header" href="#_grrs_의-첫-번째-구현">_grrs_의 첫 번째 구현</a></h1>
<p>명령줄 인수에 대한 마지막 장 이후에 입력 데이터가 있으므로 실제 도구를 작성하기 시작할 수 있습니다. 현재 <code>main</code> 함수에는 이 줄만 포함되어 있습니다.</p>
<pre><code class="language-rust ignore">    let args = Cli::parse();</code></pre>
<p>(프로그램이 예상대로 작동하는지 보여주기 위해 임시로 넣은 <code>println</code> 문은 삭제합니다.)</p>
<p>받은 파일을 여는 것부터 시작합시다.</p>
<pre><code class="language-rust ignore">    let content = std::fs::read_to_string(&amp;args.path).expect("could not read file");</code></pre>
<aside>
<p><strong>참고:</strong> 여기에서 <a href="https://doc.rust-lang.org/1.39.0/std/result/enum.Result.html#method.expect"><code>.expect</code></a> 메서드를 보시겠습니까? 이것은 값(이 경우 입력 파일)을 읽을 수 없을 때 프로그램을 즉시 종료시키는 바로 가기 함수입니다. 그다지 예쁘지는 않으며 다음 장인 <a href="tutorial/./errors.html">더 나은 오류 보고</a>에서 이를 개선하는 방법을 살펴보겠습니다.</p>
</aside>
<p>이제 줄을 반복하고 패턴을 포함하는 각 줄을 인쇄해 봅시다.</p>
<pre><code class="language-rust ignore">    for line in content.lines() {
        if line.contains(&amp;args.pattern) {
            println!("{}", line);
        }
    }</code></pre>
<h2 id="마무리-1"><a class="header" href="#마무리-1">마무리</a></h2>
<p>이제 코드는 다음과 같아야 합니다.</p>
<pre><code class="language-rust ignore">use clap::Parser;

/// 파일에서 패턴을 검색하고 해당 패턴을 포함하는 줄을 표시합니다.
#[derive(Parser)]
struct Cli {
    /// 찾을 패턴
    pattern: String,
    /// 읽을 파일의 경로
    path: std::path::PathBuf,
}

fn main() {
    let args = Cli::parse();
    let content = std::fs::read_to_string(&amp;args.path).expect("could not read file");

    for line in content.lines() {
        if line.contains(&amp;args.pattern) {
            println!("{}", line);
        }
    }
}</code></pre>
<p>시도해 보세요. <code>cargo run -- main src/main.rs</code>가 이제 작동해야 합니다!</p>
<aside class="exercise">
<p><strong>독자를 위한 연습:</strong> 이것은 최상의 구현이 아닙니다. 파일이 아무리 크더라도 전체 파일을 메모리로 읽어들입니다. 최적화할 방법을 찾아보세요! (한 가지 아이디어는 <code>read_to_string()</code> 대신 <a href="https://doc.rust-lang.org/1.39.0/std/io/struct.BufReader.html"><code>BufReader</code></a>를 사용하는 것일 수 있습니다.)</p>
</aside>
<div style="break-before: page; page-break-before: always;"></div><h1 id="더-나은-오류-보고"><a class="header" href="#더-나은-오류-보고">더 나은 오류 보고</a></h1>
<p>우리 모두는 오류가 발생할 것이라는 사실을 받아들일 수밖에 없습니다. 그리고 다른 많은 언어와 달리 Rust를 사용할 때 이 현실을 알아차리고 처리하지 않기가 매우 어렵습니다. 예외가 없기 때문에 모든 가능한 오류 상태는 종종 함수의 반환 유형에 인코딩됩니다.</p>
<h2 id="결과"><a class="header" href="#결과">결과</a></h2>
<p><a href="https://doc.rust-lang.org/1.39.0/std/fs/fn.read_to_string.html"><code>read_to_string</code></a>와 같은 함수는 문자열을 반환하지 않습니다. 대신 <code>String</code> 또는 일부 유형의 오류(이 경우 <a href="https://doc.rust-lang.org/1.39.0/std/io/type.Result.html"><code>std::io::Error</code></a>)를 포함하는 <a href="https://doc.rust-lang.org/1.39.0/std/result/index.html"><code>Result</code></a>를 반환합니다.</p>
<p>어느 것인지 어떻게 알 수 있습니까? <code>Result</code>는 <code>enum</code>이므로 <code>match</code>를 사용하여 어떤 변형인지 확인할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = std::fs::read_to_string("test.txt");
match result {
    Ok(content) =&gt; { println!("File content: {}", content); }
    Err(error) =&gt; { println!("Oh noes: {}", error); }
}
<span class="boring">}</span></code></pre></pre>
<aside>
<p><strong>참고:</strong> 열거형이 무엇인지 또는 Rust에서 어떻게 작동하는지 잘 모르시겠습니까? <a href="https://doc.rust-lang.org/1.39.0/book/ch06-00-enums.html">Rust 책의 이 장</a>을 확인하여 속도를 높이세요.</p>
</aside>
<h2 id="언래핑"><a class="header" href="#언래핑">언래핑</a></h2>
<p>이제 파일 내용에 액세스할 수 있었지만 <code>match</code> 블록 이후에는 실제로 아무것도 할 수 없습니다. 이를 위해 오류 사례를 어떻게든 처리해야 합니다. 문제는 <code>match</code> 블록의 모든 암이 동일한 유형의 무언가를 반환해야 한다는 것입니다. 하지만 이를 해결할 수 있는 멋진 트릭이 있습니다.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = std::fs::read_to_string("test.txt");
let content = match result {
    Ok(content) =&gt; { content },
    Err(error) =&gt; { panic!("Can't deal with {}, just exit here", error); }
};
println!("file content: {}", content);
<span class="boring">}</span></code></pre></pre>
<p><code>match</code> 블록 뒤에 <code>content</code>의 문자열을 사용할 수 있습니다. <code>result</code>가 오류였다면 문자열이 존재하지 않았을 것입니다. 하지만 프로그램이 <code>content</code>를 사용하는 지점에 도달하기 전에 종료되므로 괜찮습니다.</p>
<p>이것은 과감해 보일 수 있지만 매우 편리합니다. 프로그램이 해당 파일을 읽어야 하고 파일이 없으면 아무것도 할 수 없는 경우 종료하는 것이 유효한 전략입니다. <code>Result</code>에는 <code>unwrap</code>이라는 바로 가기 메서드도 있습니다.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let content = std::fs::read_to_string("test.txt").unwrap();
<span class="boring">}</span></code></pre></pre>
<h2 id="패닉할-필요-없음"><a class="header" href="#패닉할-필요-없음">패닉할 필요 없음</a></h2>
<p>물론 프로그램을 중단하는 것이 오류를 처리하는 유일한 방법은 아닙니다. <code>panic!</code> 대신 <code>return</code>을 쉽게 작성할 수도 있습니다.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span>let result = std::fs::read_to_string("test.txt");
let content = match result {
    Ok(content) =&gt; { content },
    Err(error) =&gt; { return Err(error.into()); }
};
<span class="boring">Ok(())
</span><span class="boring">}</span></code></pre></pre>
<p>그러나 이것은 우리 함수에 필요한 반환 유형을 변경합니다. 실제로 이번에는 우리 예제에 숨겨진 것이 있었습니다. 이 코드가 있는 함수 서명입니다. 그리고 <code>return</code>이 있는 이 마지막 예제에서는 중요해집니다. 다음은 <em>전체</em> 예제입니다.</p>
<pre><pre class="playground"><code class="language-rust no_run">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let result = std::fs::read_to_string("test.txt");
    let content = match result {
        Ok(content) =&gt; { content },
        Err(error) =&gt; { return Err(error.into()); }
    };
    println!("file content: {}", content);
    Ok(())
}</code></pre></pre>
<p>우리의 반환 유형은 <code>Result</code>입니다! 이것이 두 번째 <code>match</code> 암에 <code>return Err(error);</code>를 쓸 수 있는 이유입니다. 맨 아래에 <code>Ok(())</code>가 있는 것을 보시겠습니까? 이것은 함수의 기본 반환 값이며 “결과가 정상이며 내용이 없습니다“를 의미합니다.</p>
<aside>
<p><strong>참고:</strong> 이것이 <code>return Ok(());</code>로 작성되지 않은 이유는 무엇입니까? 쉽게 그럴 수 있습니다. 이것도 완전히 유효합니다. Rust의 모든 블록의 마지막 표현식은 반환 값이며 불필요한 <code>return</code>을 생략하는 것이 일반적입니다.</p>
</aside>
<h2 id="물음표"><a class="header" href="#물음표">물음표</a></h2>
<p><code>.unwrap()</code>를 호출하는 것이 오류 암에 <code>panic!</code>이 있는 <code>match</code>의 바로 가기인 것처럼, 오류 암에 <code>return</code>이 있는 <code>match</code>에 대한 또 다른 바로 가기가 있습니다. <code>?</code>입니다.</p>
<p>맞습니다, 물음표입니다. 이 연산자를 <code>Result</code> 유형의 값에 추가할 수 있으며 Rust는 내부적으로 이를 우리가 방금 작성한 <code>match</code>와 매우 유사한 것으로 확장합니다.</p>
<p>시도해 보세요.</p>
<pre><pre class="playground"><code class="language-rust no_run">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let content = std::fs::read_to_string("test.txt")?;
    println!("file content: {}", content);
    Ok(())
}</code></pre></pre>
<p>매우 간결합니다!</p>
<aside>
<p><strong>참고:</strong> 여기에는 이 작업을 이해하는 데 필요하지 않은 몇 가지 추가 사항이 있습니다. 예를 들어 <code>main</code> 함수의 오류 유형은 <code>Box&lt;dyn std::error::Error&gt;</code>입니다. 하지만 위에서 <code>read_to_string</code>이 <a href="https://doc.rust-lang.org/1.39.0/std/io/type.Result.html"><code>std::io::Error</code></a>를 반환하는 것을 보았습니다. 이것은 <code>?</code>가 오류 유형을 _변환_하는 코드로 확장되기 때문에 작동합니다.</p>
<p><code>Box&lt;dyn std::error::Error&gt;</code>도 흥미로운 유형입니다. 표준 <a href="https://doc.rust-lang.org/1.39.0/std/error/trait.Error.html"><code>Error</code></a> 특성을 구현하는 <em>모든</em> 유형을 포함할 수 있는 <code>Box</code>입니다. 즉, 기본적으로 모든 오류를 이 상자에 넣을 수 있으므로 <code>Result</code>를 반환하는 모든 일반적인 함수에서 <code>?</code>를 사용할 수 있습니다.</p>
</aside>
<h2 id="컨텍스트-제공"><a class="header" href="#컨텍스트-제공">컨텍스트 제공</a></h2>
<p><code>main</code> 함수에서 <code>?</code>를 사용할 때 발생하는 오류는 괜찮지만 훌륭하지는 않습니다. 예를 들어 <code>std::fs::read_to_string("test.txt")?</code>를 실행하지만 <code>test.txt</code> 파일이 없으면 다음과 같은 출력이 표시됩니다.</p>
<pre><code class="language-text">Error: Os { code: 2, kind: NotFound, message: "No such file or directory" }
</code></pre>
<p>코드에 파일 이름이 문자 그대로 포함되지 않은 경우 어떤 파일이 <code>NotFound</code>인지 알기가 매우 어려울 것입니다. 이를 처리하는 방법에는 여러 가지가 있습니다.</p>
<p>예를 들어, 자체 오류 유형을 만든 다음 이를 사용하여 사용자 지정 오류 메시지를 빌드할 수 있습니다.</p>
<pre><code class="language-rust ignore">#[derive(Debug)]
struct CustomError(String);

fn main() -&gt; Result&lt;(), CustomError&gt; {
    let path = "test.txt";
    let content = std::fs::read_to_string(path)
        .map_err(|err| CustomError(format!("Error reading `{}`: {}", path, err)))?;
    println!("file content: {}", content);
    Ok(())
}</code></pre>
<p>이제 이것을 실행하면 사용자 지정 오류 메시지가 표시됩니다.</p>
<pre><code class="language-text">Error: CustomError("Error reading `test.txt`: No such file or directory (os error 2)")
</code></pre>
<p>별로 예쁘지는 않지만 나중에 우리 유형에 대한 디버그 출력을 쉽게 조정할 수 있습니다.</p>
<p>이 패턴은 실제로 매우 일반적입니다. 하지만 한 가지 문제가 있습니다. 원래 오류는 저장하지 않고 문자열 표현만 저장합니다. 자주 사용되는 <a href="https://docs.rs/anyhow"><code>anyhow</code></a> 라이브러리에는 이에 대한 깔끔한 해결책이 있습니다. <code>CustomError</code> 유형과 유사하게 <a href="https://docs.rs/anyhow/1.0/anyhow/trait.Context.html"><code>Context</code></a> 특성을 사용하여 설명을 추가할 수 있습니다. 또한 원래 오류도 유지하므로 근본 원인을 지적하는 오류 메시지의 “체인“을 얻을 수 있습니다.</p>
<p>먼저 <code>Cargo.toml</code> 파일의 <code>[dependencies]</code> 섹션에 <code>anyhow = "1.0"</code>을 추가하여 <code>anyhow</code> 크레이트를 가져옵니다.</p>
<p>전체 예제는 다음과 같습니다.</p>
<pre><code class="language-rust ignore">use anyhow::{Context, Result};

fn main() -&gt; Result&lt;()&gt; {
    let path = "test.txt";
    let content = std::fs::read_to_string(path)
        .with_context(|| format!("could not read file `{}`", path))?;
    println!("file content: {}", content);
    Ok(())
}</code></pre>
<p>오류가 인쇄됩니다.</p>
<pre><code class="language-text">Error: could not read file `test.txt`

Caused by:
    No such file or directory (os error 2)
</code></pre>
<h2 id="마무리-2"><a class="header" href="#마무리-2">마무리</a></h2>
<p>이제 코드는 다음과 같아야 합니다.</p>
<pre><code class="language-rust ignore">use anyhow::{Context, Result};
use clap::Parser;

/// 파일에서 패턴을 검색하고 해당 패턴을 포함하는 줄을 표시합니다.
#[derive(Parser)]
struct Cli {
    /// 찾을 패턴
    pattern: String,
    /// 읽을 파일의 경로
    path: std::path::PathBuf,
}

fn main() -&gt; Result&lt;()&gt; {
    let args = Cli::parse();

    let content = std::fs::read_to_string(&amp;args.path)
        .with_context(|| format!("could not read file `{}`", args.path.display()))?;

    for line in content.lines() {
        if line.contains(&amp;args.pattern) {
            println!("{}", line);
        }
    }

    Ok(())
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="출력"><a class="header" href="#출력">출력</a></h1>
<h2 id="hello-world-인쇄"><a class="header" href="#hello-world-인쇄">“Hello World” 인쇄</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!("Hello World");
<span class="boring">}</span></code></pre></pre>
<p>음, 쉬웠습니다. 좋습니다, 다음 주제로 넘어갑시다.</p>
<h2 id="println-사용"><a class="header" href="#println-사용"><code>println!</code> 사용</a></h2>
<p><code>println!</code> 매크로를 사용하여 원하는 모든 것을 거의 인쇄할 수 있습니다. 이 매크로는 몇 가지 놀라운 기능을 가지고 있지만 특별한 구문도 있습니다. 첫 번째 매개변수로 문자열 리터럴을 작성해야 하며, 여기에는 추가 인수로 따르는 매개변수 값으로 채워질 자리 표시자가 포함됩니다.</p>
<p>예를 들어:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 42;
println!("My lucky number is {}.", x);
<span class="boring">}</span></code></pre></pre>
<p>인쇄됩니다</p>
<pre><code class="language-console">My lucky number is 42.
</code></pre>
<p>위 문자열의 중괄호(<code>{}</code>)는 이러한 자리 표시자 중 하나입니다. 이것은 주어진 값을 사람이 읽을 수 있는 방식으로 인쇄하려고 시도하는 기본 자리 표시자 유형입니다. 숫자와 문자열의 경우 매우 잘 작동하지만 모든 유형이 그렇게 할 수 있는 것은 아닙니다. 이것이 “디버그 표현“도 있는 이유이며, 자리 표시자의 중괄호를 다음과 같이 채워서 얻을 수 있습니다. <code>{:?}</code>.</p>
<p>예를 들어,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let xs = vec![1, 2, 3];
println!("The list is: {:?}", xs);
<span class="boring">}</span></code></pre></pre>
<p>인쇄됩니다</p>
<pre><code class="language-console">The list is: [1, 2, 3]
</code></pre>
<p>자체 데이터 유형을 디버깅 및 로깅을 위해 인쇄할 수 있도록 하려면 대부분의 경우 정의 위에 <code>#[derive(Debug)]</code>를 추가할 수 있습니다.</p>
<aside>
<p><strong>참고:</strong> “사용자 친화적인” 인쇄는 <a href="https://doc.rust-lang.org/1.39.0/std/fmt/trait.Display.html"><code>Display</code></a> 특성을 사용하여 수행되며, 디버그 출력(사람이 읽을 수 있지만 개발자를 대상으로 함)은 <a href="https://doc.rust-lang.org/1.39.0/std/fmt/trait.Debug.html"><code>Debug</code></a> 특성을 사용합니다. <code>println!</code>에서 사용할 수 있는 구문에 대한 자세한 내용은 <a href="https://doc.rust-lang.org/1.39.0/std/fmt/index.html"><code>std::fmt</code> 모듈에 대한 문서</a>에서 찾을 수 있습니다.</p>
</aside>
<h2 id="오류-인쇄"><a class="header" href="#오류-인쇄">오류 인쇄</a></h2>
<p>오류 인쇄는 사용자와 다른 도구가 출력을 파일이나 더 많은 도구로 파이프할 수 있도록 <code>stderr</code>를 통해 수행해야 합니다.</p>
<aside>
<p><strong>참고:</strong> 대부분의 운영 체제에서 프로그램은 <code>stdout</code>과 <code>stderr</code>라는 두 개의 출력 스트림에 쓸 수 있습니다. <code>stdout</code>은 프로그램의 실제 출력용이고, <code>stderr</code>는 오류 및 기타 메시지를 <code>stdout</code>과 분리하여 유지할 수 있도록 합니다. 이렇게 하면 오류가 사용자에게 표시되는 동안 출력을 파일에 저장하거나 다른 프로그램으로 파이프할 수 있습니다.</p>
</aside>
<p>Rust에서는 <code>println!</code>과 <code>eprintln!</code>을 사용하여 이를 달성합니다. 전자는 <code>stdout</code>에 인쇄하고 후자는 <code>stderr</code>에 인쇄합니다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!("This is information");
eprintln!("This is an error! :(");
<span class="boring">}</span></code></pre></pre>
<aside>
<p><strong>주의</strong>: <a href="https://en.wikipedia.org/wiki/ANSI_escape_code">이스케이프 코드</a>를 인쇄하는 것은 위험할 수 있으며 사용자의 터미널을 이상한 상태로 만들 수 있습니다. 수동으로 인쇄할 때는 항상 주의하세요!</p>
<p>이상적으로는 원시 이스케이프 코드를 처리할 때 <code>ansi_term</code>과 같은 크레이트를 사용하여 자신(과 사용자)의 삶을 더 쉽게 만들어야 합니다.</p>
</aside>
<h2 id="인쇄-성능에-대한-참고-사항"><a class="header" href="#인쇄-성능에-대한-참고-사항">인쇄 성능에 대한 참고 사항</a></h2>
<p>터미널에 인쇄하는 것은 놀라울 정도로 느립니다! 루프에서 <code>println!</code>과 같은 것을 호출하면 그렇지 않으면 빠른 프로그램에서 쉽게 병목 현상이 발생할 수 있습니다. 이를 가속화하기 위해 할 수 있는 두 가지가 있습니다.</p>
<p>First, you might want to reduce the number of writes that actually “flush” to the terminal. <code>println!</code> tells the system to flush to the terminal <em>every</em> time, because it is common to print each new line. If you don’t need that, you can wrap your <code>stdout</code> handle in a <a href="https://doc.rust-lang.org/1.39.0/std/io/struct.BufWriter.html"><code>BufWriter</code></a> which by default buffers up to 8 kB. (You can still call <code>.flush()</code> on this <code>BufWriter</code> when you want to print immediately.)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{self, Write};

let stdout = io::stdout(); // 전역 stdout 엔터티 가져오기
let mut handle = io::BufWriter::new(stdout); // 선택 사항: 해당 핸들을 버퍼로 래핑
writeln!(handle, "foo: {}", 42); // 여기에 오류가 있는 경우 `?` 추가
<span class="boring">}</span></code></pre></pre>
<p>둘째, <code>stdout</code>(또는 <code>stderr</code>)에 대한 잠금을 획득하고 <code>writeln!</code>을 사용하여 직접 인쇄하는 것이 도움이 됩니다. 이렇게 하면 시스템이 <code>stdout</code>을 반복해서 잠그고 잠금 해제하는 것을 방지할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{self, Write};

let stdout = io::stdout(); // 전역 stdout 엔터티 가져오기
let mut handle = stdout.lock(); // 잠금 획득
writeln!(handle, "foo: {}", 42); // 여기에 오류가 있는 경우 `?` 추가
<span class="boring">}</span></code></pre></pre>
<p>두 가지 접근 방식을 결합할 수도 있습니다.</p>
<h2 id="진행률-표시줄-표시"><a class="header" href="#진행률-표시줄-표시">진행률 표시줄 표시</a></h2>
<p>일부 CLI 응용 프로그램은 1초 미만으로 실행되고 다른 응용 프로그램은 몇 분 또는 몇 시간이 걸립니다. 후자의 유형의 프로그램을 작성하는 경우 사용자에게 무언가 일어나고 있음을 보여주고 싶을 수 있습니다. 이를 위해 유용한 상태 업데이트를 인쇄해야 하며, 이상적으로는 쉽게 사용할 수 있는 형식으로 인쇄해야 합니다.</p>
<p><a href="https://crates.io/crates/indicatif">indicatif</a> 크레이트를 사용하여 프로그램에 진행률 표시줄과 작은 스피너를 추가할 수 있습니다. 다음은 간단한 예입니다.</p>
<pre><code class="language-rust ignore">fn main() {
    let pb = indicatif::ProgressBar::new(100);
    for i in 0..100 {
        do_hard_work();
        pb.println(format!("[+] finished #{}", i));
        pb.inc(1);
    }
    pb.finish_with_message("done");
}</code></pre>
<p>자세한 내용은 <a href="https://docs.rs/indicatif">문서</a> 및 <a href="https://github.com/console-rs/indicatif/tree/main/examples">예제</a>를 참조하세요.</p>
<h2 id="로깅"><a class="header" href="#로깅">로깅</a></h2>
<p>프로그램에서 무슨 일이 일어나고 있는지 더 쉽게 이해하기 위해 몇 가지 로그 문을 추가하고 싶을 수 있습니다. 이것은 일반적으로 응용 프로그램을 작성하는 동안 쉽습니다. 하지만 반년 후에 이 프로그램을 다시 실행하면 매우 유용할 것입니다. 어떤 면에서 로깅은 <code>println!</code>을 사용하는 것과 동일하지만 메시지의 중요도를 지정할 수 있다는 점이 다릅니다. 일반적으로 사용할 수 있는 수준은 <em>error</em>, <em>warn</em>, <em>info</em>, <em>debug</em> 및 _trace_입니다(_error_가 가장 높은 우선순위를 갖고 _trace_가 가장 낮음).</p>
<p>응용 프로그램에 간단한 로깅을 추가하려면 두 가지가 필요합니다. <a href="https://crates.io/crates/log">log</a> 크레이트(로그 수준의 이름을 딴 매크로 포함)와 실제로 로그 출력을 유용한 곳에 쓰는 _어댑터_입니다. 로그 어댑터를 사용하는 기능은 매우 유연합니다. 예를 들어 터미널뿐만 아니라 <a href="https://en.wikipedia.org/wiki/Syslog">syslog</a> 또는 중앙 로그 서버에도 로그를 쓰는 데 사용할 수 있습니다.</p>
<p>지금은 CLI 응용 프로그램을 작성하는 데만 관심이 있으므로 사용하기 쉬운 어댑터는 <a href="https://crates.io/crates/env_logger">env_logger</a>입니다. 응용 프로그램의 어떤 부분을 기록할지(그리고 어떤 수준에서 기록할지) 지정하는 데 환경 변수를 사용할 수 있기 때문에 “env” 로거라고 합니다. 로그 메시지 앞에 타임스탬프와 로그 메시지가 온 모듈을 접두사로 붙입니다. 라이브러리도 <code>log</code>를 사용할 수 있으므로 로그 출력을 쉽게 구성할 수 있습니다.</p>
<p>다음은 간단한 예입니다.</p>
<pre><code class="language-rust ignore">use log::{info, warn};

fn main() {
    env_logger::init();
    info!("starting up");
    warn!("oops, nothing implemented!");
}</code></pre>
<p>이 파일을 <code>src/bin/output-log.rs</code>로 가지고 있다고 가정하면 Linux 및 macOS에서 다음과 같이 실행할 수 있습니다.</p>
<pre><code class="language-console">$ env RUST_LOG=info cargo run --bin output-log
    Finished dev [unoptimized + debuginfo] target(s) in 0.17s
     Running `target/debug/output-log`
[2018-11-30T20:25:52Z INFO  output_log] starting up
[2018-11-30T20:25:52Z WARN  output_log] oops, nothing implemented!
</code></pre>
<p>Windows PowerShell에서는 다음과 같이 실행할 수 있습니다.</p>
<pre><code class="language-console">$ $env:RUST_LOG="info"
$ cargo run --bin output-log
    Finished dev [unoptimized + debuginfo] target(s) in 0.17s
     Running `target/debug/output-log.exe`
[2018-11-30T20:25:52Z INFO  output_log] starting up
[2018-11-30T20:25:52Z WARN  output_log] oops, nothing implemented!
</code></pre>
<p>Windows CMD에서는 다음과 같이 실행할 수 있습니다.</p>
<pre><code class="language-console">$ set RUST_LOG=info
$ cargo run --bin output-log
    Finished dev [unoptimized + debuginfo] target(s) in 0.17s
     Running `target/debug/output-log.exe`
[2018-11-30T20:25:52Z INFO  output_log] starting up
[2018-11-30T20:25:52Z WARN  output_log] oops, nothing implemented!
</code></pre>
<p><code>RUST_LOG</code>는 로그 설정을 지정하는 데 사용할 수 있는 환경 변수의 이름입니다. <code>env_logger</code>에는 이러한 설정을 프로그래밍 방식으로 조정하고 예를 들어 기본적으로 <em>info</em> 수준 메시지를 표시할 수 있는 빌더도 포함되어 있습니다.</p>
<p>대체 로깅 어댑터가 많이 있으며 <code>log</code>에 대한 대안 또는 확장도 있습니다. 응용 프로그램에 기록할 내용이 많다는 것을 알고 있다면 이를 검토하고 사용자의 삶을 더 쉽게 만드십시오.</p>
<aside>
<p><strong>Tip:</strong> Experience has shown that even mildly useful CLI programs can end up being used for years to come. (Especially if they were meant as a temporary solution.) If your application doesn’t work and someone (e.g., you, in the future) needs to figure out why, being able to pass <code>--verbose</code> to get additional log output can make the difference between minutes and hours of debugging. The <a href="https://crates.io/crates/clap-verbosity-flag">clap-verbosity-flag</a> crate contains a quick way to add a <code>--verbose</code> to a project using <code>clap</code>.</p>
</aside>
<div style="break-before: page; page-break-before: always;"></div><h1 id="테스트"><a class="header" href="#테스트">테스트</a></h1>
<p>수십 년간의 소프트웨어 개발을 통해 사람들은 한 가지 진실을 발견했습니다. 테스트되지 않은 소프트웨어는 거의 작동하지 않습니다. (많은 사람들은 “대부분의 테스트된 소프트웨어도 작동하지 않는다“고까지 말할 것입니다. 하지만 우리는 모두 여기서 낙관주의자입니다, 그렇죠?) 따라서 프로그램이 예상대로 작동하는지 확인하려면 테스트하는 것이 현명합니다.</p>
<p>이를 수행하는 한 가지 쉬운 방법은 프로그램이 수행해야 할 작업을 설명하는 <code>README</code> 파일을 작성하는 것입니다. 그리고 새 릴리스를 만들 준비가 되면 <code>README</code>를 살펴보고 동작이 여전히 예상대로인지 확인합니다. 프로그램이 잘못된 입력에 어떻게 반응해야 하는지 기록하여 이 연습을 더 엄격하게 만들 수도 있습니다.</p>
<p>여기 또 다른 멋진 아이디어가 있습니다. 코드를 작성하기 전에 <code>README</code>를 작성하세요.</p>
<aside>
<p><strong>참고:</strong> <a href="https://en.wikipedia.org/wiki/Test-driven_development">테스트 주도 개발</a>(TDD)에 대해 들어본 적이 없다면 살펴보세요.</p>
</aside>
<h2 id="자동화된-테스트"><a class="header" href="#자동화된-테스트">자동화된 테스트</a></h2>
<p>이제 이것은 모두 괜찮지만 이 모든 것을 수동으로 수행하시겠습니까? 시간이 많이 걸릴 수 있습니다. 동시에 많은 사람들이 컴퓨터에 일을 시키는 것을 즐기게 되었습니다. 이러한 테스트를 자동화하는 방법에 대해 이야기해 봅시다.</p>
<p>Rust에는 내장 테스트 프레임워크가 있으므로 첫 번째 테스트를 작성하는 것부터 시작하겠습니다.</p>
<pre><code class="language-rust ignore"><span class="boring">fn answer() -&gt; i32 {
</span><span class="boring">  42
</span><span class="boring">}
</span><span class="boring">
</span>#[test]
fn check_answer_validity() {
    assert_eq!(answer(), 42);
}</code></pre>
<p>이 코드 조각을 패키지의 거의 모든 소스 파일에 넣을 수 있으며 <code>cargo test</code>가 이를 찾아 실행합니다. 여기서 핵심은 <code>#[test]</code> 속성입니다. 이를 통해 빌드 시스템이 이러한 함수를 검색하고 테스트로 실행하여 패닉이 발생하지 않는지 확인할 수 있습니다.</p>
<aside class="exercise">
<p><strong>독자를 위한 연습:</strong> 이 테스트가 작동하도록 만드세요.</p>
<p>다음과 같은 출력이 표시되어야 합니다.</p>
<pre><code class="language-text">running 1 test
test check_answer_validity ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
</aside>
<p>이제 테스트를 작성하는 _방법_을 보았으므로 _무엇_을 테스트해야 하는지 알아내야 합니다. 보시다시피 함수에 대한 어설션을 작성하는 것은 매우 쉽습니다. 하지만 CLI 응용 프로그램은 종종 하나 이상의 함수입니다! 더 나쁜 것은 종종 사용자 입력을 처리하고 파일을 읽고 출력을 쓴다는 것입니다.</p>
<h2 id="코드를-테스트-가능하게-만들기"><a class="header" href="#코드를-테스트-가능하게-만들기">코드를 테스트 가능하게 만들기</a></h2>
<p>기능을 테스트하는 데는 두 가지 보완적인 접근 방식이 있습니다. 완전한 응용 프로그램을 구성하는 작은 단위를 테스트하는 것을 “단위 테스트“라고 합니다. 최종 응용 프로그램을 “외부에서” 테스트하는 것을 “블랙박스 테스트” 또는 “통합 테스트“라고도 합니다. 첫 번째부터 시작하겠습니다.</p>
<p>무엇을 테스트해야 하는지 알아보기 위해 프로그램 기능이 무엇인지 살펴보겠습니다. 주로 <code>grrs</code>는 주어진 패턴과 일치하는 줄을 인쇄해야 합니다. 따라서 _정확히 이것_에 대한 단위 테스트를 작성해 봅시다. 가장 중요한 로직이 작동하는지 확인하고 싶고, 주변에 있는 설정 코드(예: CLI 인수 처리)에 의존하지 않는 방식으로 수행하고 싶습니다.</p>
<p><code>grrs</code>의 <a href="tutorial/impl-draft.html">첫 번째 구현</a>으로 돌아가서 <code>main</code> 함수에 이 코드 블록을 추가했습니다.</p>
<pre><code class="language-rust ignore">// ...
for line in content.lines() {
    if line.contains(&amp;args.pattern) {
        println!("{}", line);
    }
}</code></pre>
<p>안타깝게도 이것은 테스트하기가 쉽지 않습니다. 우선, <code>main</code> 함수에 있으므로 쉽게 호출할 수 없습니다. 이 코드 조각을 함수로 옮기면 쉽게 해결할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn find_matches(content: &amp;str, pattern: &amp;str) {
    for line in content.lines() {
        if line.contains(pattern) {
            println!("{}", line);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>이제 테스트에서 이 함수를 호출하고 출력이 무엇인지 확인할 수 있습니다.</p>
<pre><code class="language-rust ignore">#[test]
fn find_a_match() {
    find_matches("lorem ipsum\ndolor sit amet", "lorem");
    assert_eq!( // 어...</code></pre>
<p>아니면… 할 수 있을까요? 지금 <code>find_matches</code>는 <code>stdout</code>, 즉 터미널에 직접 인쇄합니다. 테스트에서 이것을 쉽게 캡처할 수 없습니다! 이것은 구현 후에 테스트를 작성할 때 종종 발생하는 문제입니다. 우리는 사용되는 컨텍스트에 확고하게 통합된 함수를 작성했습니다.</p>
<aside class="note">
<p><strong>참고:</strong> 이것은 작은 CLI 응용 프로그램을 작성할 때 완전히 괜찮습니다. 모든 것을 테스트 가능하게 만들 필요는 없습니다! 그러나 코드의 어떤 부분에 대해 단위 테스트를 작성하고 싶은지 생각하는 것이 중요합니다. 이 함수를 테스트 가능하게 변경하는 것이 쉽다는 것을 알게 되겠지만 항상 그런 것은 아닙니다.</p>
</aside>
<p>좋습니다, 어떻게 테스트 가능하게 만들 수 있을까요? 어떻게든 출력을 캡처해야 합니다. Rust의 표준 라이브러리에는 I/O(입력/출력)를 처리하기 위한 몇 가지 깔끔한 추상화가 있으며 <a href="https://doc.rust-lang.org/1.39.0/std/io/trait.Write.html"><code>std::io::Write</code></a>라는 것을 사용할 것입니다. 이것은 문자열뿐만 아니라 <code>stdout</code>도 포함하여 우리가 쓸 수 있는 것들을 추상화하는 <a href="https://doc.rust-lang.org/book/ch10-02-traits.html">특성</a>입니다.</p>
<p>Rust의 맥락에서 “특성“이라는 말을 처음 들어본다면, 당신은 운이 좋습니다. 특성은 Rust의 가장 강력한 기능 중 하나입니다. Java의 인터페이스나 Haskell의 유형 클래스(어느 쪽이 더 익숙하든)와 같다고 생각할 수 있습니다. 이를 통해 다른 유형에서 공유할 수 있는 동작을 추상화할 수 있습니다. 특성을 사용하는 코드는 매우 일반적이고 유연한 방식으로 아이디어를 표현할 수 있습니다. 하지만 이것은 읽기 어려워질 수도 있다는 것을 의미합니다. 겁먹지 마세요. 수년 동안 Rust를 사용해 온 사람들조차도 제네릭 코드가 즉시 무엇을 하는지 항상 이해하지는 못합니다. 이 경우 구체적인 용도를 생각하는 것이 도움이 됩니다. 예를 들어, 우리의 경우 추상화하는 동작은 “쓰기“입니다. 이를 구현하는( “impl”) 유형의 예로는 터미널의 표준 출력, 파일, 메모리의 버퍼 또는 TCP 네트워크 연결이 있습니다. (<a href="https://doc.rust-lang.org/1.39.0/std/io/trait.Write.html"><code>std::io::Write</code>에 대한 문서</a>에서 “구현자” 목록을 보려면 아래로 스크롤하세요.)</p>
<p>그 지식을 바탕으로 함수가 세 번째 매개변수를 받도록 변경해 봅시다. <code>Write</code>를 구현하는 모든 유형이어야 합니다. 이렇게 하면 테스트에서 간단한 문자열을 제공하고 이에 대한 어설션을 만들 수 있습니다. 다음은 이 버전의 <code>find_matches</code>를 작성하는 방법입니다.</p>
<pre><code class="language-rust ignore">fn find_matches(content: &amp;str, pattern: &amp;str, mut writer: impl std::io::Write) {
    for line in content.lines() {
        if line.contains(pattern) {
            writeln!(writer, "{}", line);
        }
    }
}</code></pre>
<p>새 매개변수는 <code>mut writer</code>, 즉 “writer“라고 부르는 변경 가능한 것입니다. 유형은 <code>impl std::io::Write</code>이며, 이는 “<code>Write</code> 특성을 구현하는 모든 유형에 대한 자리 표시자“로 읽을 수 있습니다. 또한 이전에 사용했던 <code>println!(…)</code>을 <code>writeln!(writer, …)</code>으로 바꾼 방법도 주목하세요. <code>println!</code>은 <code>writeln!</code>과 동일하게 작동하지만 항상 표준 출력을 사용합니다.</p>
<p>이제 출력을 테스트할 수 있습니다.</p>
<pre><code class="language-rust ignore">#[test]
fn find_a_match() {
    let mut result = Vec::new();
    find_matches("lorem ipsum\ndolor sit amet", "lorem", &amp;mut result);
    assert_eq!(result, b"lorem ipsum\n");
}</code></pre>
<p>이제 응용 프로그램 코드에서 이것을 사용하려면 <code>main</code>에서 <code>find_matches</code>에 대한 호출을 세 번째 매개변수로 <a href="https://doc.rust-lang.org/1.39.0/std/io/fn.stdout.html"><code>&amp;mut std::io::stdout()</code></a>을 추가하여 변경해야 합니다. 다음은 이전 장에서 본 내용을 기반으로 하고 추출된 <code>find_matches</code> 함수를 사용하는 <code>main</code> 함수의 예입니다.</p>
<pre><code class="language-rust ignore">fn main() -&gt; Result&lt;()&gt; {
    let args = Cli::parse();
    let content = std::fs::read_to_string(&amp;args.path)
        .with_context(|| format!("could not read file `{}`", args.path.display()))?;

    find_matches(&amp;content, &amp;args.pattern, &amp;mut std::io::stdout());

    Ok(())
}</code></pre>
<aside class="note">
<p><strong>참고:</strong> <code>stdout</code>은 바이트(문자열이 아님)를 예상하므로 <code>std::fmt::Write</code> 대신 <code>std::io::Write</code>를 사용합니다. 결과적으로 테스트에서 빈 벡터를 “writer“로 제공하고(유형은 <code>Vec&lt;u8&gt;</code>로 유추됨), <code>assert_eq!</code>에서는 <code>b"foo"</code>를 사용합니다. (<code>b</code> 접두사는 이것을 _바이트 문자열 리터럴_로 만들므로 유형은 <code>&amp;str</code> 대신 <code>&amp;[u8]</code>가 됩니다).</p>
</aside>
<aside class="note">
<p><strong>참고:</strong> 이 함수가 <code>String</code>을 반환하도록 만들 수도 있지만 그렇게 하면 동작이 변경됩니다. 터미널에 직접 쓰는 대신 모든 것을 문자열로 수집하고 마지막에 모든 결과를 한 번에 덤프합니다.</p>
</aside>
<aside class="exercise">
<p><strong>독자를 위한 연습:</strong> <a href="https://doc.rust-lang.org/1.39.0/std/macro.writeln.html"><code>writeln!</code></a>은 예를 들어 버퍼가 가득 차서 확장할 수 없을 때 쓰기가 실패할 수 있기 때문에 <a href="https://doc.rust-lang.org/1.39.0/std/io/type.Result.html"><code>io::Result</code></a>를 반환합니다. <code>find_matches</code>에 오류 처리를 추가하세요.</p>
</aside>
<p>이 코드 조각을 쉽게 테스트할 수 있는 방법을 방금 보았습니다. 우리는</p>
<ol>
<li>우리 응용 프로그램의 핵심 부분 중 하나를 식별했습니다.</li>
<li>자체 함수에 넣었습니다.</li>
<li>그리고 더 유연하게 만들었습니다.</li>
</ol>
<p>목표는 테스트 가능하게 만드는 것이었지만, 우리가 얻은 결과는 실제로 매우 관용적이고 재사용 가능한 Rust 코드 조각입니다. 정말 멋집니다!</p>
<h2 id="코드를-라이브러리-및-바이너리-대상으로-분할"><a class="header" href="#코드를-라이브러리-및-바이너리-대상으로-분할">코드를 라이브러리 및 바이너리 대상으로 분할</a></h2>
<p>여기서 한 가지 더 할 수 있습니다. 지금까지 작성한 모든 것을 <code>src/main.rs</code> 파일에 넣었습니다. 이것은 현재 프로젝트가 단일 바이너리를 생성한다는 것을 의미합니다. 하지만 다음과 같이 코드를 라이브러리로 사용할 수도 있습니다.</p>
<ol>
<li><code>find_matches</code> 함수를 새 <code>src/lib.rs</code>에 넣습니다.</li>
<li><code>fn</code> 앞에 <code>pub</code>를 추가하여(<code>pub fn find_matches</code>가 되도록) 라이브러리 사용자가 액세스할 수 있도록 합니다.</li>
<li><code>src/main.rs</code>에서 <code>find_matches</code>를 제거합니다.</li>
<li><code>fn main</code>에서 <code>find_matches</code>에 대한 호출 앞에 <code>grrs::</code>를 붙여 이제 <code>grrs::find_matches(…)</code>가 되도록 합니다. 이것은 방금 작성한 라이브러리의 함수를 사용한다는 것을 의미합니다!</li>
</ol>
<p>Rust가 프로젝트를 처리하는 방식은 매우 유연하며 크레이트의 라이브러리 부분에 무엇을 넣을지 미리 생각하는 것이 좋습니다. 예를 들어, 응용 프로그램별 로직을 위한 라이브러리를 먼저 작성한 다음 다른 라이브러리처럼 CLI에서 사용할 수 있습니다. 또는 프로젝트에 여러 바이너리가 있는 경우 공통 기능을 해당 크레이트의 라이브러리 부분에 넣을 수 있습니다.</p>
<aside class="note">
<p><strong>참고:</strong> 모든 것을 <code>src/main.rs</code>에 넣는 것에 대해 말하자면, 계속 그렇게 하면 읽기 어려워질 것입니다. <a href="https://doc.rust-lang.org/1.39.0/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">모듈 시스템</a>은 코드를 구조화하고 구성하는 데 도움이 될 수 있습니다.</p>
</aside>
<h2 id="실행하여-cli-응용-프로그램-테스트"><a class="header" href="#실행하여-cli-응용-프로그램-테스트">실행하여 CLI 응용 프로그램 테스트</a></h2>
<p>지금까지 우리는 응용 프로그램의 _비즈니스 로직_을 테스트하기 위해 많은 노력을 기울였으며, 이는 <code>find_matches</code> 함수로 판명되었습니다. 이것은 매우 가치가 있으며 잘 테스트된 코드 기반을 향한 훌륭한 첫 걸음입니다. (일반적으로 이러한 종류의 테스트를 “단위 테스트“라고 합니다.)</p>
<p>하지만 테스트하지 않는 코드가 많이 있습니다. 외부 세계를 처리하기 위해 작성한 모든 것입니다! <code>main</code> 함수를 작성했지만 사용자 제공 경로의 인수를 사용하는 대신 하드 코딩된 문자열을 실수로 남겨 두었다고 상상해 보십시오. 이에 대한 테스트도 작성해야 합니다! (이 수준의 테스트는 종종 “통합 테스트” 또는 “시스템 테스트“라고 합니다.)</p>
<p>핵심적으로 우리는 여전히 함수를 작성하고 <code>#[test]</code>로 주석을 답니다. 이러한 함수 내부에서 무엇을 하는지가 문제입니다. 예를 들어, 프로젝트의 주 바이너리를 사용하고 일반 프로그램처럼 실행하고 싶을 것입니다. 또한 이러한 테스트를 새 디렉토리의 새 파일인 <code>tests/cli.rs</code>에 넣을 것입니다.</p>
<aside>
<p><strong>참고:</strong> 규칙에 따라 <code>cargo</code>는 <code>tests/</code> 디렉토리에서 통합 테스트를 찾습니다. 마찬가지로 <code>benches/</code>에서 벤치마크를, <code>examples/</code>에서 예제를 찾습니다. 이러한 규칙은 주 소스 코드에도 적용됩니다. 라이브러리에는 <code>src/lib.rs</code> 파일이 있고, 주 바이너리는 <code>src/main.rs</code>이거나, 여러 바이너리가 있는 경우 cargo는 <code>src/bin/&lt;name&gt;.rs</code>에 있을 것으로 예상합니다. 이러한 규칙을 따르면 Rust 코드를 읽는 데 익숙한 사람들이 코드 기반을 더 쉽게 찾을 수 있습니다.</p>
</aside>
<p>다시 말해, <code>grrs</code>는 파일에서 문자열을 검색하는 작은 도구입니다. 이전에 일치 항목을 찾을 수 있는지 테스트했습니다. 테스트할 수 있는 다른 기능에 대해 생각해 봅시다.</p>
<p>제가 생각해 낸 것은 다음과 같습니다.</p>
<ul>
<li>파일이 존재하지 않으면 어떻게 됩니까?</li>
<li>일치하는 항목이 없을 때 출력은 무엇입니까?</li>
<li>인수 중 하나(또는 둘 다)를 잊어버리면 프로그램이 오류와 함께 종료됩니까?</li>
</ul>
<p>이것들은 모두 유효한 테스트 사례입니다. 또한 “해피 패스“에 대한 테스트 사례도 하나 포함해야 합니다. 즉, 하나 이상의 일치 항목을 찾았고 이를 인쇄합니다.</p>
<p>이러한 종류의 테스트를 더 쉽게 만들기 위해 <a href="https://docs.rs/assert_cmd"><code>assert_cmd</code></a> 크레이트를 사용할 것입니다. 여기에는 주 바이너리를 실행하고 동작 방식을 볼 수 있는 깔끔한 도우미가 많이 있습니다. 또한 <code>assert_cmd</code>가 테스트할 수 있는(그리고 훌륭한 오류 메시지가 있는) 어설션을 작성하는 데 도움이 되는 <a href="https://docs.rs/predicates"><code>predicates</code></a> 크레이트도 추가할 것입니다. 이러한 의존성은 주 목록이 아닌 <code>Cargo.toml</code>의 “개발 의존성” 섹션에 추가할 것입니다. 크레이트를 사용할 때가 아니라 개발할 때만 필요합니다.</p>
<pre><code class="language-toml">[dev-dependencies]
assert_cmd = "2.0.14"
predicates = "3.1.0"
</code></pre>
<p>설정이 많은 것 같습니다. 그럼에도 불구하고 바로 시작하여 <code>tests/cli.rs</code> 파일을 만들어 봅시다.</p>
<pre><code class="language-rust ignore">use assert_cmd::prelude::*; // 명령에 메서드 추가
use predicates::prelude::*; // 어설션 작성에 사용
use std::process::Command; // 프로그램 실행

#[test]
fn file_doesnt_exist() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut cmd = Command::cargo_bin("grrs")?;

    cmd.arg("foobar").arg("test/file/doesnt/exist");
    cmd.assert()
        .failure()
        .stderr(predicate::str::contains("could not read file"));

    Ok(())
}</code></pre>
<p>위에서 작성한 테스트와 마찬가지로 <code>cargo test</code>로 이 테스트를 실행할 수 있습니다. <code>Command::cargo_bin("grrs")</code>가 주 바이너리를 컴파일해야 하므로 처음에는 시간이 조금 더 걸릴 수 있습니다.</p>
<h2 id="테스트-파일-생성"><a class="header" href="#테스트-파일-생성">테스트 파일 생성</a></h2>
<p>방금 본 테스트는 입력 파일이 없을 때 프로그램이 오류 메시지를 작성하는지 확인하는 것뿐입니다. 이것은 중요한 테스트이지만 가장 중요한 테스트는 아닐 수 있습니다. 이제 파일에서 찾은 일치 항목을 실제로 인쇄하는지 테스트해 봅시다!</p>
<p>우리는 내용물을 아는 파일이 필요하므로 프로그램이 <em>반환해야</em> 하는 것을 알고 코드에서 이 기대를 확인할 수 있습니다. 한 가지 아이디어는 사용자 지정 콘텐츠가 있는 파일을 프로젝트에 추가하고 테스트에서 사용하는 것입니다. 다른 하나는 테스트에서 임시 파일을 만드는 것입니다. 이 튜토리얼에서는 후자의 접근 방식을 살펴보겠습니다. 주로 더 유연하고 다른 경우에도 작동하기 때문입니다. 예를 들어 파일을 변경하는 프로그램을 테스트할 때입니다.</p>
<p>이러한 임시 파일을 만들려면 <a href="https://docs.rs/assert_fs"><code>assert_fs</code></a> 크레이트를 사용할 것입니다. <code>Cargo.toml</code>의 <code>dev-dependencies</code>에 추가해 봅시다.</p>
<pre><code class="language-toml">assert_fs = "1.1.1"
</code></pre>
<p>다음은 다른 테스트 사례 아래에 작성할 수 있는 새 테스트 사례입니다. 먼저 임시 파일(경로를 얻을 수 있도록 “이름이 지정된” 파일)을 만들고 일부 텍스트로 채운 다음 프로그램을 실행하여 올바른 출력을 얻는지 확인합니다. <code>file</code>이 범위를 벗어나면(함수 끝에서) 실제 임시 파일이 자동으로 삭제됩니다.</p>
<pre><code class="language-rust ignore">use assert_fs::prelude::*;

#[test]
fn find_content_in_file() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let file = assert_fs::NamedTempFile::new("sample.txt")?;
    file.write_str("A test\nActual content\nMore content\nAnother test")?;

    let mut cmd = Command::cargo_bin("grrs")?;
    cmd.arg("test").arg(file.path());
    cmd.assert()
        .success()
        .stdout(predicate::str::contains("A test\nAnother test"));

    Ok(())
}</code></pre>
<aside class="exercise">
<p><strong>독자를 위한 연습:</strong> 빈 문자열을 패턴으로 전달하기 위한 통합 테스트를 추가하세요. 필요에 따라 프로그램을 조정하세요.</p>
</aside>
<h2 id="무엇을-테스트해야-할까요"><a class="header" href="#무엇을-테스트해야-할까요">무엇을 테스트해야 할까요?</a></h2>
<p>통합 테스트를 작성하는 것이 확실히 재미있을 수 있지만, 작성하는 데 시간이 걸리고 응용 프로그램의 동작이 변경될 때 업데이트하는 데도 시간이 걸립니다. 시간을 현명하게 사용하려면 무엇을 테스트해야 하는지 자문해야 합니다.</p>
<p>일반적으로 사용자가 관찰할 수 있는 모든 유형의 동작에 대해 통합 테스트를 작성하는 것이 좋습니다. 즉, 모든 엣지 케이스를 다룰 필요는 없습니다. 일반적으로 다른 유형에 대한 예제를 갖고 단위 테스트에 의존하여 엣지 케이스를 다루는 것으로 충분합니다.</p>
<p>또한 적극적으로 제어할 수 없는 것에 테스트를 집중하지 않는 것이 좋습니다. <code>--help</code>의 정확한 레이아웃은 자동으로 생성되므로 테스트하는 것은 좋지 않습니다. 대신 특정 요소가 있는지 확인하고 싶을 수 있습니다.</p>
<p>프로그램의 성격에 따라 더 많은 테스트 기술을 추가해 볼 수도 있습니다. 예를 들어, 프로그램의 일부를 추출하고 모든 엣지 케이스를 생각해 내려고 노력하면서 단위 테스트로 많은 예제 사례를 작성하는 자신을 발견하면 <a href="https://docs.rs/proptest"><code>proptest</code></a>를 살펴보아야 합니다. 임의의 파일을 사용하고 구문 분석하는 프로그램이 있는 경우 <a href="https://rust-fuzz.github.io/book/introduction.html">퍼저</a>를 작성하여 엣지 케이스에서 버그를 찾아보십시오.</p>
<aside>
<p><strong>참고:</strong> 이 장에서 사용된 전체 실행 가능한 소스 코드는 <a href="https://github.com/rust-cli/book/tree/master/src/tutorial/testing">이 책의 리포지토리</a>에서 찾을 수 있습니다.</p>
</aside>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-도구-패키징-및-배포"><a class="header" href="#rust-도구-패키징-및-배포">Rust 도구 패키징 및 배포</a></h1>
<p>프로그램이 다른 사람들이 사용할 준비가 되었다고 확신한다면 패키징하고 출시할 시간입니다!</p>
<p>몇 가지 접근 방식이 있으며, “가장 빠른 설정“에서 “사용자에게 가장 편리한“까지 세 가지를 살펴보겠습니다.</p>
<h2 id="가장-빠른-방법-cargo-publish"><a class="header" href="#가장-빠른-방법-cargo-publish">가장 빠른 방법: <code>cargo publish</code></a></h2>
<p>앱을 게시하는 가장 쉬운 방법은 cargo를 사용하는 것입니다. 프로젝트에 외부 의존성을 추가한 방법을 기억하십니까? Cargo는 기본 “크레이트 레지스트리“인 <a href="https://crates.io/">crates.io</a>에서 다운로드했습니다. <code>cargo publish</code>를 사용하면 <a href="https://crates.io/">crates.io</a>에 크레이트를 게시할 수도 있습니다. 그리고 이것은 바이너리 대상이 있는 크레이트를 포함하여 모든 크레이트에서 작동합니다.</p>
<p><a href="https://crates.io/">crates.io</a>에 크레이트를 게시하는 것은 매우 간단합니다. 아직 계정이 없다면 <a href="https://crates.io/">crates.io</a>에서 계정을 만드세요. 현재 이것은 GitHub에서 인증을 통해 수행되므로 GitHub 계정이 있어야 합니다(그리고 거기에 로그인해야 함). 다음으로 로컬 컴퓨터에서 cargo를 사용하여 로그인합니다. 이를 위해 <a href="https://crates.io/me">crates.io 계정 페이지</a>로 이동하여 새 토큰을 만든 다음 <code>cargo login &lt;your-new-token&gt;</code>을 실행합니다. 컴퓨터당 한 번만 수행하면 됩니다. 이에 대한 자세한 내용은 cargo의 <a href="https://doc.rust-lang.org/1.39.0/cargo/reference/publishing.html">게시 가이드</a>에서 확인할 수 있습니다.</p>
<p>이제 cargo와 crates.io가 당신을 알았으므로 크레이트를 게시할 준비가 되었습니다. 서둘러 새 크레이트(버전)를 게시하기 전에 <code>Cargo.toml</code>을 다시 한 번 열고 필요한 메타데이터를 추가했는지 확인하는 것이 좋습니다. 설정할 수 있는 모든 가능한 필드는 <a href="https://doc.rust-lang.org/1.39.0/cargo/reference/manifest.html">cargo의 매니페스트 형식</a>에 대한 문서에서 찾을 수 있습니다. 다음은 몇 가지 일반적인 항목에 대한 간략한 개요입니다.</p>
<pre><code class="language-toml">[package]
name = "grrs"
version = "0.1.0"
authors = ["Your Name &lt;your@email.com&gt;"]
license = "MIT OR Apache-2.0"
description = "A tool to search files"
readme = "README.md"
homepage = "https://github.com/you/grrs"
repository = "https://github.com/you/grrs"
keywords = ["cli", "search", "demo"]
categories = ["command-line-utilities"]
</code></pre>
<aside class="note">
<p><strong>참고:</strong> 이 예제에는 Rust 프로젝트에 대한 일반적인 선택인 필수 라이선스 필드가 포함되어 있습니다. 컴파일러 자체에도 사용되는 동일한 라이선스입니다. 또한 <code>README.md</code> 파일을 참조합니다. 프로젝트에 대한 간략한 설명이 포함되어야 하며 크레이트의 crates.io 페이지뿐만 아니라 GitHub가 리포지토리 페이지에 기본적으로 표시하는 내용에도 포함됩니다.</p>
</aside>
<h3 id="cratesio에서-바이너리를-설치하는-방법"><a class="header" href="#cratesio에서-바이너리를-설치하는-방법">crates.io에서 바이너리를 설치하는 방법</a></h3>
<p>crates.io에 크레이트를 게시하는 방법을 보았고 설치하는 방법이 궁금할 것입니다. <code>cargo build</code>(또는 유사한 명령)를 실행할 때 cargo가 다운로드하고 컴파일하는 라이브러리와 달리 바이너리를 명시적으로 설치하도록 지시해야 합니다.</p>
<p>이것은 <code>cargo install &lt;crate-name&gt;</code>을 사용하여 수행됩니다. 기본적으로 크레이트를 다운로드하고 포함된 모든 바이너리 대상( “릴리스” 모드이므로 시간이 걸릴 수 있음)을 컴파일하고 <code>~/.cargo/bin/</code> 디렉토리에 복사합니다. (셸이 바이너리를 찾기 위해 해당 위치를 보도록 해야 합니다!)</p>
<p>git 리포지토리에서 크레이트를 설치하고, 크레이트의 특정 바이너리만 설치하고, 설치할 대체 디렉토리를 지정할 수도 있습니다. 자세한 내용은 <code>cargo install --help</code>를 참조하세요.</p>
<h3 id="사용-시기"><a class="header" href="#사용-시기">사용 시기</a></h3>
<p><code>cargo install</code>은 바이너리 크레이트를 설치하는 간단한 방법입니다. Rust 개발자가 사용하기에 매우 편리하지만 몇 가지 중요한 단점이 있습니다. 항상 소스를 처음부터 컴파일하므로 도구 사용자는 컴퓨터에 Rust, cargo 및 프로젝트에 필요한 다른 모든 시스템 의존성을 설치해야 합니다. 큰 Rust 코드베이스를 컴파일하는 데도 시간이 걸릴 수 있습니다.</p>
<p>다른 Rust 개발자를 대상으로 하는 도구를 배포하는 데 사용하는 것이 가장 좋습니다. 예를 들어 <code>cargo-tree</code> 또는 <code>cargo-outdated</code>와 같은 많은 cargo 하위 명령을 설치할 수 있습니다.</p>
<h2 id="바이너리-배포"><a class="header" href="#바이너리-배포">바이너리 배포</a></h2>
<p>Rust는 네이티브 코드로 컴파일되고 기본적으로 모든 의존성을 정적으로 연결하는 언어입니다. <code>grrs</code>라는 바이너리가 포함된 프로젝트에서 <code>cargo build</code>를 실행하면 <code>grrs</code>라는 바이너리 파일이 생성됩니다. 시도해 보세요. <code>cargo build</code>를 사용하면 <code>target/debug/grrs</code>가 되고, <code>cargo build --release</code>를 실행하면 <code>target/release/grrs</code>가 됩니다. 대상 시스템에 외부 라이브러리를 명시적으로 설치해야 하는 크레이트(예: 시스템의 OpenSSL 버전 사용)를 사용하지 않는 한 이 바이너리는 공통 시스템 라이브러리에만 의존합니다. 즉, 해당 파일을 가져와 동일한 운영 체제를 실행하는 사람들에게 보내면 실행할 수 있습니다.</p>
<p>이것은 이미 매우 강력합니다! 방금 본 <code>cargo install</code>의 두 가지 단점을 해결합니다. 사용자 컴퓨터에 Rust를 설치할 필요가 없으며 컴파일하는 데 1분이 걸리는 대신 즉시 바이너리를 실행할 수 있습니다.</p>
<p>따라서 보시다시피 <code>cargo build</code>는 <em>이미</em> 우리를 위해 바이너리를 빌드합니다. 유일한 문제는 모든 플랫폼에서 작동하도록 보장되지 않는다는 것입니다. Windows 컴퓨터에서 <code>cargo build</code>를 실행하면 기본적으로 Mac에서 작동하는 바이너리를 얻을 수 없습니다. 흥미로운 모든 플랫폼에 대해 이러한 바이너리를 자동으로 생성하는 방법이 있습니까?</p>
<h3 id="ci에서-바이너리-릴리스-빌드"><a class="header" href="#ci에서-바이너리-릴리스-빌드">CI에서 바이너리 릴리스 빌드</a></h3>
<p>도구가 오픈 소스이고 GitHub에서 호스팅되는 경우 <a href="https://travis-ci.com/">Travis CI</a>와 같은 무료 CI(지속적 통합) 서비스를 설정하는 것이 매우 쉽습니다. (다른 플랫폼에서도 작동하는 다른 서비스가 있지만 Travis는 매우 인기가 있습니다.) 이것은 기본적으로 리포지토리에 변경 사항을 푸시할 때마다 가상 머신에서 설정 명령을 실행합니다. 이러한 명령이 무엇인지, 그리고 실행되는 컴퓨터 유형은 구성 가능합니다. 예를 들어 Rust와 몇 가지 일반적인 빌드 도구가 설치된 컴퓨터에서 <code>cargo test</code>를 실행하는 것이 좋습니다. 실패하면 가장 최근 변경 사항에 문제가 있음을 알 수 있습니다.</p>
<p>이것을 사용하여 바이너리를 빌드하고 GitHub에 업로드할 수도 있습니다! 실제로 <code>cargo build --release</code>를 실행하고 바이너리를 어딘가에 업로드하면 모든 준비가 완료된 것일까요? 그렇지 않습니다. 빌드하는 바이너리가 가능한 한 많은 시스템과 호환되는지 확인해야 합니다. 예를 들어 Linux에서는 현재 시스템용으로 컴파일하는 대신 <code>x86_64-unknown-linux-musl</code> 대상을 위해 컴파일하여 기본 시스템 라이브러리에 의존하지 않도록 할 수 있습니다. macOS에서는 <code>MACOSX_DEPLOYMENT_TARGET</code>을 <code>10.7</code>로 설정하여 10.7 및 이전 버전에 있는 시스템 기능에만 의존하도록 할 수 있습니다.</p>
<p>Linux 및 macOS의 경우 <a href="https://github.com/rustwasm/wasm-pack/blob/51e6351c28fbd40745719e6d4a7bf26dadd30c85/.travis.yml#L74-L91">여기</a>에서, Windows(AppVeyor 사용)의 경우 <a href="https://github.com/rustwasm/wasm-pack/blob/51e6351c28fbd40745719e6d4a7bf26dadd30c85/.appveyor.yml">여기</a>에서 이 접근 방식을 사용하여 바이너리를 빌드하는 한 가지 예를 볼 수 있습니다.</p>
<p>또 다른 방법은 바이너리를 빌드하는 데 필요한 모든 도구가 포함된 사전 빌드된 (Docker) 이미지를 사용하는 것입니다. 이를 통해 더 이국적인 플랫폼도 쉽게 타겟팅할 수 있습니다. <a href="https://github.com/japaric/trust">trust</a> 프로젝트에는 프로젝트에 포함할 수 있는 스크립트와 이를 설정하는 방법에 대한 지침이 포함되어 있습니다. 또한 AppVeyor를 사용하는 Windows도 지원합니다.</p>
<p>로컬에서 설정하고 자신의 컴퓨터에서 릴리스 파일을 생성하려는 경우에도 trust를 살펴보십시오. 내부적으로 <a href="https://github.com/rust-embedded/cross">cross</a>를 사용하며, 이는 cargo와 유사하게 작동하지만 Docker 컨테이너 내부의 cargo 프로세스로 명령을 전달합니다. 이미지의 정의는 <a href="https://github.com/rust-embedded/cross">cross의 리포지토리</a>에서도 사용할 수 있습니다.</p>
<h3 id="이러한-바이너리를-설치하는-방법"><a class="header" href="#이러한-바이너리를-설치하는-방법">이러한 바이너리를 설치하는 방법</a></h3>
<p>사용자를 <a href="https://github.com/rustwasm/wasm-pack/releases/tag/v0.5.1">이것과 같은</a> 릴리스 페이지로 안내하면 방금 만든 아티팩트를 다운로드할 수 있습니다. 방금 생성한 릴리스 아티팩트는 특별한 것이 아닙니다. 결국 바이너리가 포함된 아카이브 파일일 뿐입니다! 즉, 도구 사용자는 브라우저로 다운로드하고 압축을 풀고(종종 자동으로 발생) 바이너리를 원하는 위치에 복사할 수 있습니다.</p>
<p>이것은 수동으로 프로그램을 “설치“하는 데 약간의 경험이 필요하므로 이 프로그램을 설치하는 방법에 대한 섹션을 README 파일에 추가하고 싶을 것입니다.</p>
<aside class="note">
<p><strong>참고:</strong> <a href="https://github.com/japaric/trust">trust</a>를 사용하여 바이너리를 빌드하고 GitHub 릴리스에 추가한 경우 <code>curl -LSfs https://japaric.github.io/trust/install.sh | sh -s -- --git your-name/repo-name</code>을 실행하도록 사람들에게 알려줄 수도 있습니다. 이것이 더 쉽다고 생각한다면 말입니다.</p>
</aside>
<h3 id="사용-시기-1"><a class="header" href="#사용-시기-1">사용 시기</a></h3>
<p>바이너리 릴리스를 갖는 것은 일반적으로 좋은 생각이며 단점이 거의 없습니다. 사용자가 도구를 수동으로 설치하고 업데이트해야 하는 문제를 해결하지는 않지만 Rust를 설치할 필요 없이 최신 릴리스 버전을 빠르게 얻을 수 있습니다.</p>
<h3 id="바이너리-외에-무엇을-패키징해야-할까요"><a class="header" href="#바이너리-외에-무엇을-패키징해야-할까요">바이너리 외에 무엇을 패키징해야 할까요</a></h3>
<p>지금 사용자가 릴리스 빌드를 다운로드하면 바이너리 파일만 포함된 <code>.tar.gz</code> 파일을 받게 됩니다. 따라서 예제 프로젝트에서는 실행할 수 있는 단일 <code>grrs</code> 파일만 받게 됩니다. 하지만 리포지토리에 이미 가지고 있는 파일 중 사용자가 원할 수 있는 파일이 더 있습니다. 예를 들어 이 도구를 사용하는 방법을 알려주는 README 파일과 라이선스 파일이 있습니다. 이미 가지고 있으므로 추가하기 쉽습니다.</p>
<p>하지만 특히 명령줄 도구에 의미 있는 더 흥미로운 파일이 있습니다. README 파일 외에 man 페이지와 셸에 가능한 플래그 완성을 추가하는 구성 파일도 함께 제공하는 것은 어떻습니까? 이것들을 수동으로 작성할 수 있지만, 우리가 사용하는 인수 구문 분석 라이브러리인 <em>clap</em>(clap이 기반으로 함)에는 이러한 모든 파일을 생성하는 방법이 있습니다. 자세한 내용은 <a href="tutorial/../in-depth/docs.html">이 심층 장</a>을 참조하세요.</p>
<h2 id="앱을-패키지-리포지토리에-넣기"><a class="header" href="#앱을-패키지-리포지토리에-넣기">앱을 패키지 리포지토리에 넣기</a></h2>
<p>지금까지 본 두 가지 접근 방식은 일반적으로 컴퓨터에 소프트웨어를 설치하는 방식이 아닙니다. 특히 대부분의 운영 체제에서 전역 패키지 관리자를 사용하여 설치하는 명령줄 도구입니다. 사용자를 위한 이점은 매우 분명합니다. 다른 도구를 설치하는 것과 동일한 방식으로 프로그램을 설치할 수 있다면 프로그램을 설치하는 방법에 대해 생각할 필요가 없습니다. 이러한 패키지 관리자는 또한 사용자가 새 버전을 사용할 수 있을 때 프로그램을 업데이트할 수 있도록 합니다.</p>
<p>안타깝게도 다른 시스템을 지원한다는 것은 이러한 다른 시스템이 어떻게 작동하는지 살펴봐야 한다는 것을 의미합니다. 일부의 경우 리포지토리에 파일을 추가하는 것만큼 쉬울 수 있습니다(예: macOS의 <code>brew</code>용으로 <a href="https://github.com/BurntSushi/ripgrep/blob/31adff6f3c4bfefc9e77df40871f2989443e6827/pkg/brew/ripgrep-bin.rb">이것</a>과 같은 Formula 파일 추가). 그러나 다른 경우에는 종종 직접 패치를 보내고 도구를 해당 리포지토리에 추가해야 합니다. <a href="https://crates.io/crates/cargo-bundle">cargo-bundle</a>, <a href="https://crates.io/crates/cargo-deb">cargo-deb</a> 및 <a href="https://crates.io/crates/cargo-aur">cargo-aur</a>와 같은 유용한 도구가 있지만, 작동 방식과 이러한 다른 시스템에 대해 도구를 올바르게 패키징하는 방법을 설명하는 것은 이 장의 범위를 벗어납니다.</p>
<p>대신 Rust로 작성되었고 많은 다른 패키지 관리자에서 사용할 수 있는 도구를 살펴보겠습니다.</p>
<h3 id="예-ripgrep"><a class="header" href="#예-ripgrep">예: ripgrep</a></h3>
<p><a href="https://github.com/BurntSushi/ripgrep">ripgrep</a>은 <code>grep</code>/<code>ack</code>/<code>ag</code>의 대안이며 Rust로 작성되었습니다. 매우 성공적이며 많은 운영 체제용으로 패키징되었습니다. README의 <a href="https://github.com/BurntSushi/ripgrep/tree/31adff6f3c4bfefc9e77df40871f2989443e6827#installation">“설치” 섹션</a>을 살펴보세요!</p>
<p>설치 방법에 대한 몇 가지 다른 옵션을 나열합니다. 바이너리가 포함된 GitHub 릴리스에 대한 링크로 시작하여 직접 다운로드할 수 있습니다. 그런 다음 여러 다른 패키지 관리자를 사용하여 설치하는 방법을 나열합니다. 마지막으로 <code>cargo install</code>을 사용하여 설치할 수도 있습니다.</p>
<p>이것은 매우 좋은 생각인 것 같습니다. 여기에 제시된 접근 방식 중 하나를 선택하지 말고 <code>cargo install</code>로 시작하여 바이너리 릴리스를 추가하고 마지막으로 시스템 패키지 관리자를 사용하여 도구를 배포하기 시작하십시오.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="심층-주제"><a class="header" href="#심층-주제">심층 주제</a></h1>
<p>명령줄 응용 프로그램을 작성할 때 신경 쓸 수 있는 몇 가지 세부 정보를 다루는 작은 장 모음입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="신호-처리"><a class="header" href="#신호-처리">신호 처리</a></h1>
<p>명령줄 응용 프로그램과 같은 프로세스는 운영 체제에서 보낸 신호에 반응해야 합니다. 가장 일반적인 예는 아마도 프로세스에 종료를 알리는 신호인 <kbd>Ctrl</kbd>+<kbd>C</kbd>일 것입니다. Rust 프로그램에서 신호를 처리하려면 이러한 신호를 수신하는 방법과 이에 반응하는 방법을 고려해야 합니다.</p>
<aside>
<p><strong>참고:</strong> 응용 프로그램이 정상적으로 종료될 필요가 없다면 기본 처리가 괜찮습니다(즉, 즉시 종료하고 OS가 열린 파일 핸들과 같은 리소스를 정리하도록 함). 이 경우: 이 장에서 설명하는 것을 할 필요가 없습니다!</p>
<p>그러나 자체적으로 정리해야 하는 응용 프로그램의 경우 이 장은 매우 관련성이 높습니다! 예를 들어, 응용 프로그램이 네트워크 연결을 제대로 닫아야 하는 경우(상대방 프로세스에 “안녕“이라고 말함), 임시 파일을 제거하거나 시스템 설정을 재설정해야 하는 경우 계속 읽으십시오.</p>
</aside>
<h2 id="운영-체제-간의-차이점"><a class="header" href="#운영-체제-간의-차이점">운영 체제 간의 차이점</a></h2>
<p>Unix 시스템(Linux, macOS, FreeBSD 등)에서는 프로세스가 <a href="https://manpages.ubuntu.com/manpages/bionic/en/man7/signal.7.html">신호</a>를 수신할 수 있습니다. 기본(OS 제공) 방식으로 반응하거나, 신호를 가로채 프로그램 정의 방식으로 처리하거나, 신호를 완전히 무시할 수 있습니다.</p>
<p>Windows에는 신호가 없습니다. 이벤트가 발생할 때 실행되는 콜백을 정의하기 위해 <a href="https://docs.microsoft.com/en-us/windows/console/console-control-handlers">콘솔 핸들러</a>를 사용할 수 있습니다. 또한 0으로 나누기, 잘못된 액세스 예외, 스택 오버플로 등과 같은 다양한 유형의 시스템 예외를 처리하는 <a href="https://docs.microsoft.com/en-us/windows/desktop/debug/structured-exception-handling">구조적 예외 처리</a>도 있습니다.</p>
<h2 id="먼저-ctrlc-처리"><a class="header" href="#먼저-ctrlc-처리">먼저: Ctrl+C 처리</a></h2>
<p><a href="https://crates.io/crates/ctrlc">ctrlc</a> 크레이트는 이름에서 알 수 있듯이 크로스 플랫폼 방식으로 사용자가 <kbd>Ctrl</kbd>+<kbd>C</kbd>를 누르는 것에 반응할 수 있도록 합니다. 크레이트를 사용하는 주요 방법은 다음과 같습니다.</p>
<pre><code class="language-rust ignore">use std::{thread, time::Duration};

fn main() {
    ctrlc::set_handler(move || {
        println!("received Ctrl+C!");
    })
    .expect("Error setting Ctrl-C handler");

    // 다음 코드는 실제 작업을 수행하며 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;C&lt;/kbd&gt;를 눌러 중단할 수 있습니다.
    // 예: 몇 초 동안 기다려 봅시다.
    thread::sleep(Duration::from_secs(2));
}</code></pre>
<p>물론 이것은 그다지 도움이 되지 않습니다. 메시지만 인쇄하고 프로그램은 중지하지 않습니다.</p>
<p>실제 프로그램에서는 신호 핸들러에 변수를 설정하고 프로그램의 여러 위치에서 확인하는 것이 좋습니다. 예를 들어, 신호 핸들러에 <code>Arc&lt;AtomicBool&gt;</code>(스레드 간에 공유 가능한 부울)을 설정하고, 핫 루프에서 또는 스레드를 기다릴 때 주기적으로 해당 값을 확인하고 참이 되면 중단할 수 있습니다.</p>
<h2 id="다른-유형의-신호-처리"><a class="header" href="#다른-유형의-신호-처리">다른 유형의 신호 처리</a></h2>
<p><a href="https://crates.io/crates/ctrlc">ctrlc</a> 크레이트는 <kbd>Ctrl</kbd>+<kbd>C</kbd> 또는 Unix 시스템에서 <code>SIGINT</code>(“인터럽트” 신호)라고 하는 것만 처리합니다. 더 많은 Unix 신호에 반응하려면 <a href="https://crates.io/crates/signal-hook">signal-hook</a>을 살펴보아야 합니다. 디자인은 <a href="https://vorner.github.io/2018/06/28/signal-hook.html">이 블로그 게시물</a>에 설명되어 있으며 현재 가장 광범위한 커뮤니티 지원을 받는 라이브러리입니다.</p>
<p>다음은 간단한 예입니다.</p>
<pre><code class="language-rust ignore">use signal_hook::{consts::SIGINT, iterator::Signals};
use std::{error::Error, thread, time::Duration};

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let mut signals = Signals::new([SIGINT])?;

    thread::spawn(move || {
        for sig in signals.forever() {
            println!("Received signal {:?}", sig);
        }
    });

    // 다음 코드는 실제 작업을 수행하며 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;C&lt;/kbd&gt;를 눌러 중단할 수 있습니다.
    // 예: 몇 초 동안 기다려 봅시다.
    thread::sleep(Duration::from_secs(2));

    Ok(())
}</code></pre>
<h2 id="채널-사용"><a class="header" href="#채널-사용">채널 사용</a></h2>
<p>변수를 설정하고 프로그램의 다른 부분이 확인하도록 하는 대신 채널을 사용할 수 있습니다. 신호 핸들러가 신호를 수신할 때마다 값을 방출하는 채널을 만듭니다. 응용 프로그램 코드에서는 이 채널과 다른 채널을 스레드 간의 동기화 지점으로 사용합니다. <a href="https://crates.io/crates/crossbeam-channel">crossbeam-channel</a>을 사용하면 다음과 같이 보일 것입니다.</p>
<pre><code class="language-rust ignore">use std::time::Duration;
use crossbeam_channel::{bounded, tick, Receiver, select};
use anyhow::Result;

fn ctrl_channel() -&gt; Result&lt;Receiver&lt;()&gt;, ctrlc::Error&gt; {
    let (sender, receiver) = bounded(100);
    ctrlc::set_handler(move || {
        let _ = sender.send(());
    })?;

    Ok(receiver)
}

fn main() -&gt; Result&lt;()&gt; {
    let ctrl_c_events = ctrl_channel()?;
    let ticks = tick(Duration::from_secs(1));

    loop {
        select! {
            recv(ticks) -&gt; _ =&gt; {
                println!("working!");
            }
            recv(ctrl_c_events) -&gt; _ =&gt; {
                println!();
                println!("Goodbye!");
                break;
            }
        }
    }

    Ok(())
}</code></pre>
<h2 id="퓨처-및-스트림-사용"><a class="header" href="#퓨처-및-스트림-사용">퓨처 및 스트림 사용</a></h2>
<p><a href="https://tokio.rs/">tokio</a>를 사용하고 있다면 비동기 패턴과 이벤트 기반 디자인으로 응용 프로그램을 작성하고 있을 가능성이 높습니다. crossbeam의 채널을 직접 사용하는 대신 signal-hook의 <code>tokio-support</code> 기능을 활성화할 수 있습니다. 이렇게 하면 signal-hook의 <code>Signals</code> 유형에서 <a href="https://docs.rs/signal-hook/0.1.6/signal_hook/iterator/struct.Signals.html#method.into_async"><code>.into_async()</code></a>를 호출하여 <code>futures::Stream</code>을 구현하는 새 유형을 얻을 수 있습니다.</p>
<h2 id="첫-번째-ctrlc를-처리하는-동안-다른-ctrlc를-수신하면-어떻게-해야-합니까"><a class="header" href="#첫-번째-ctrlc를-처리하는-동안-다른-ctrlc를-수신하면-어떻게-해야-합니까">첫 번째 Ctrl+C를 처리하는 동안 다른 Ctrl+C를 수신하면 어떻게 해야 합니까?</a></h2>
<p>대부분의 사용자는 <kbd>Ctrl</kbd>+<kbd>C</kbd>를 누른 다음 프로그램이 종료될 때까지 몇 초 동안 기다리거나 무슨 일이 일어나고 있는지 알려줍니다. 그렇게 하지 않으면 <kbd>Ctrl</kbd>+<kbd>C</kbd>를 다시 누릅니다. 일반적인 동작은 응용 프로그램을 즉시 종료하는 것입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="구성-파일-사용"><a class="header" href="#구성-파일-사용">구성 파일 사용</a></h1>
<p>구성을 처리하는 것은 특히 단기 및 장기 파일에 대한 자체 위치를 가진 여러 운영 체제를 지원하는 경우 성가실 수 있습니다.</p>
<p>이에 대한 여러 가지 해결책이 있으며, 일부는 다른 것보다 더 저수준입니다.</p>
<p>이를 위해 사용하기 가장 쉬운 크레이트는 <a href="https://docs.rs/confy/0.3.1/confy/"><code>confy</code></a>입니다. 응용 프로그램 이름을 묻고 <code>struct</code>( <code>Serialize</code>, <code>Deserialize</code>인)를 통해 구성 레이아웃을 지정하도록 요구하면 나머지는 알아서 처리합니다!</p>
<pre><code class="language-rust ignore">#[derive(Debug, Serialize, Deserialize)]
struct MyConfig {
    name: String,
    comfy: bool,
    foo: i64,
}

fn main() -&gt; Result&lt;(), io::Error&gt; {
    let cfg: MyConfig = confy::load("my_app")?;
    println!("{:#?}", cfg);
    Ok(())
}</code></pre>
<p>물론 구성 가능성을 포기하는 대신 사용하기가 매우 쉽습니다. 하지만 간단한 구성만 원한다면 이 크레이트가 적합할 수 있습니다!</p>
<h2 id="구성-환경"><a class="header" href="#구성-환경">구성 환경</a></h2>
<aside class="todo">
<p><strong>TODO</strong></p>
<ol>
<li>기존 크레이트 평가</li>
<li>Cli-args + 여러 구성 + 환경 변수</li>
<li><a href="https://docs.rs/configure/0.1.1/configure/"><code>configure</code></a>가 이 모든 것을 할 수 있습니까? 멋진 래퍼가 있습니까?</li>
</ol>
</aside>
<div style="break-before: page; page-break-before: always;"></div><h1 id="종료-코드"><a class="header" href="#종료-코드">종료 코드</a></h1>
<p>프로그램이 항상 성공하는 것은 아닙니다. 오류가 발생하면 필요한 정보를 올바르게 내보내야 합니다. <a href="in-depth/human-communication.html">사용자에게 오류 알리기</a> 외에도 대부분의 시스템에서 프로세스가 종료될 때 종료 코드(0에서 255 사이의 정수는 대부분의 플랫폼과 호환됨)를 내보냅니다. 프로그램 상태에 대한 올바른 코드를 내보내야 합니다. 예를 들어 이상적인 경우 프로그램이 성공하면 <code>0</code>으로 종료해야 합니다.</p>
<p>오류가 발생하면 좀 더 복잡해집니다. 실제로는 많은 도구가 일반적인 실패가 발생하면 <code>1</code>로 종료됩니다. 현재 Rust는 프로세스가 패닉할 때 <code>101</code>의 종료 코드를 설정합니다. 그 외에도 사람들은 프로그램에서 많은 작업을 수행했습니다.</p>
<p>그래서 무엇을 해야 할까요? BSD 생태계는 종료 코드에 대한 일반적인 정의를 수집했습니다( <a href="https://www.freebsd.org/cgi/man.cgi?query=sysexits&amp;apropos=0&amp;sektion=0&amp;manpath=FreeBSD+11.2-stable&amp;arch=default&amp;format=html">여기</a>에서 찾을 수 있음). Rust 라이브러리 <a href="https://crates.io/crates/exitcode"><code>exitcode</code></a>는 이러한 동일한 코드를 제공하며 응용 프로그램에서 사용할 준비가 되어 있습니다. 사용 가능한 값에 대한 API 문서를 참조하십시오.</p>
<p><code>Cargo.toml</code>에 <code>exitcode</code> 의존성을 추가한 후 다음과 같이 사용할 수 있습니다.</p>
<pre><code class="language-rust ignore">fn main() {
    // ...실제 작업...
    match result {
        Ok(_) =&gt; {
            println!("Done!");
            std::process::exit(exitcode::OK);
        }
        Err(CustomError::CantReadConfig(e)) =&gt; {
            eprintln!("Error: {}", e);
            std::process::exit(exitcode::CONFIG);
        }
        Err(e) =&gt; {
            eprintln!("Error: {}", e);
            std::process::exit(exitcode::DATAERR);
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="사람과-소통하기"><a class="header" href="#사람과-소통하기">사람과 소통하기</a></h1>
<p>먼저 튜토리얼의 <a href="in-depth/../tutorial/output.html">CLI 출력 장</a>을 읽으십시오. 터미널에 출력을 작성하는 방법을 다루고, 이 장에서는 _무엇_을 출력할지에 대해 이야기합니다.</p>
<h2 id="모든-것이-괜찮을-때"><a class="header" href="#모든-것이-괜찮을-때">모든 것이 괜찮을 때</a></h2>
<p>모든 것이 괜찮을 때도 응용 프로그램의 진행 상황을 보고하는 것이 유용합니다. 이러한 메시지에서 유익하고 간결하게 작성하십시오. 로그에 지나치게 기술적인 용어를 사용하지 마십시오. 기억하세요: 응용 프로그램이 충돌하는 것이 아니므로 사용자가 오류를 찾아볼 이유가 없습니다.</p>
<p>가장 중요하게는 통신 스타일을 일관되게 유지하십시오. 동일한 접두사와 문장 구조를 사용하여 로그를 쉽게 훑어볼 수 있도록 하십시오.</p>
<p>응용 프로그램 출력이 무엇을 하고 있으며 사용자에게 어떤 영향을 미치는지에 대한 이야기를 들려주도록 노력하십시오. 여기에는 관련된 단계의 타임라인을 표시하거나 장기 실행 작업에 대한 진행률 표시줄 및 표시기를 표시하는 것이 포함될 수 있습니다. 사용자는 응용 프로그램이 따라갈 수 없는 신비한 작업을 수행하고 있다는 느낌을 받아서는 안 됩니다.</p>
<h2 id="무슨-일이-일어나고-있는지-알기-어려울-때"><a class="header" href="#무슨-일이-일어나고-있는지-알기-어려울-때">무슨 일이 일어나고 있는지 알기 어려울 때</a></h2>
<p>비정상 상태를 전달할 때는 일관성을 유지하는 것이 중요합니다. 엄격한 로깅 수준을 따르지 않는 과도한 로깅 응용 프로그램은 로깅하지 않는 응용 프로그램과 동일하거나 더 적은 정보를 제공합니다.</p>
<p>이 때문에 이벤트의 심각도와 관련된 메시지를 정의하는 것이 중요합니다. 그런 다음 일관된 로그 수준을 사용하십시오. 이렇게 하면 사용자는 <code>--verbose</code> 플래그 또는 환경 변수( <code>RUST_LOG</code> 등)를 통해 로깅 양을 직접 선택할 수 있습니다.</p>
<p>일반적으로 사용되는 <code>log</code> 크레이트는 <a href="https://docs.rs/log/0.4.4/log/enum.Level.html">다음과 같은 수준을 정의합니다</a>(심각도 증가 순서):</p>
<ul>
<li>trace</li>
<li>debug</li>
<li>info</li>
<li>warning</li>
<li>error</li>
</ul>
<p>_info_를 기본 로그 수준으로 생각하는 것이 좋습니다. 음, 유익한 출력에 사용하십시오. (더 조용한 출력 스타일을 선호하는 일부 응용 프로그램은 기본적으로 경고 및 오류만 표시할 수 있습니다.)</p>
<p>또한 로그 메시지 전반에 걸쳐 유사한 접두사와 문장 구조를 사용하는 것이 항상 좋습니다. 이렇게 하면 <code>grep</code>과 같은 도구를 사용하여 필터링하기 쉽습니다. 메시지는 필터링된 로그에서 유용할 만큼 충분한 컨텍스트를 제공해야 하며 동시에 <em>너무</em> 장황하지 않아야 합니다.</p>
<h3 id="예제-로그-문"><a class="header" href="#예제-로그-문">예제 로그 문</a></h3>
<pre><code class="language-console">error: could not find `Cargo.toml` in `/home/you/project/`
</code></pre>
<pre><code class="language-console">=&gt; Downloading repository index
=&gt; Downloading packages...
</code></pre>
<p>다음 로그 출력은 <a href="https://crates.io/crates/wasm-pack">wasm-pack</a>에서 가져온 것입니다.</p>
<pre><code class="language-console"> [1/7] Adding WASM target...
 [2/7] Compiling to WASM...
 [3/7] Creating a pkg directory...
 [4/7] Writing a package.json...
 &gt; [WARN]: Field `description` is missing from Cargo.toml. It is not necessary, but recommended
 &gt; [WARN]: Field `repository` is missing from Cargo.toml. It is not necessary, but recommended
 &gt; [WARN]: Field `license` is missing from Cargo.toml. It is not necessary, but recommended
 [5/7] Copying over your README...
 &gt; [WARN]: origin crate has no README
 [6/7] Installing WASM-bindgen...
 &gt; [INFO]: wasm-bindgen already installed
 [7/7] Running WASM-bindgen...
 Done in 1 second
</code></pre>
<h2 id="패닉-시"><a class="header" href="#패닉-시">패닉 시</a></h2>
<p>종종 잊혀지는 한 가지 측면은 프로그램이 충돌할 때도 무언가를 출력한다는 것입니다. Rust에서 “충돌“은 대부분 “패닉“입니다(즉, “운영 체제가 프로세스를 종료“하는 것과 대조되는 “제어된 충돌”). 기본적으로 패닉이 발생하면 “패닉 핸들러“가 콘솔에 일부 정보를 인쇄합니다.</p>
<p>예를 들어, <code>cargo new --bin foo</code>로 새 바이너리 프로젝트를 만들고 <code>fn main</code>의 내용을 <code>panic!("Hello World")</code>로 바꾸면 프로그램을 실행할 때 다음과 같은 결과가 나옵니다.</p>
<pre><code class="language-console">thread 'main' panicked at 'Hello, world!', src/main.rs:2:5
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>이것은 개발자인 당신에게 유용한 정보입니다. (놀랍게도 프로그램이 <code>main.rs</code> 파일의 2행 때문에 충돌했습니다). 하지만 소스 코드에 액세스할 수 없는 사용자에게는 그다지 가치가 없습니다. 사실, 혼란스러울 가능성이 높습니다. 그렇기 때문에 사용자에게 더 초점을 맞춘 출력을 제공하는 사용자 지정 패닉 핸들러를 추가하는 것이 좋습니다.</p>
<p>정확히 그렇게 하는 라이브러리 중 하나는 <a href="https://crates.io/crates/human-panic">human-panic</a>입니다. CLI 프로젝트에 추가하려면 가져와서 <code>main</code> 함수의 시작 부분에서 <code>setup_panic!()</code> 매크로를 호출합니다.</p>
<pre><code class="language-rust ignore">use human_panic::setup_panic;

fn main() {
   setup_panic!();

   panic!("Hello world")
}</code></pre>
<p>이제 매우 친근한 메시지가 표시되며 사용자에게 무엇을 할 수 있는지 알려줍니다.</p>
<pre><code class="language-console">Well, this is embarrassing.

foo had a problem and crashed. To help us diagnose the problem you can send us a crash report.

We have generated a report file at "/var/folders/n3/dkk459k908lcmkzwcmq0tcv00000gn/T/report-738e1bec-5585-47a4-8158-f1f7227f0168.toml". Submit an issue or email with the subject of "foo Crash Report" and include the report as an attachment.

- Authors: Your Name &lt;your.name@example.com&gt;

We take privacy seriously, and do not perform any automated error collection. In order to improve the software, we rely on people to submit reports.

Thank you kindly!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="기계와-소통하기"><a class="header" href="#기계와-소통하기">기계와 소통하기</a></h1>
<p>명령줄 도구의 힘은 결합할 수 있을 때 진정으로 빛을 발합니다. 이것은 새로운 아이디어가 아닙니다. 사실, 이것은 <a href="https://en.wikipedia.org/wiki/Unix_philosophy">Unix 철학</a>의 문장입니다.</p>
<blockquote>
<p>모든 프로그램의 출력이 아직 알려지지 않은 다른 프로그램의 입력이 될 것으로 예상하십시오.</p>
</blockquote>
<p>우리 프로그램이 이 기대를 충족하면 사용자는 행복할 것입니다. 이것이 잘 작동하도록 하려면 사람들에게 보기 좋은 출력뿐만 아니라 다른 프로그램에 필요한 맞춤 버전도 제공해야 합니다. 이를 수행하는 방법을 살펴봅시다.</p>
<aside>
<p><strong>Note:</strong> Make sure to read <a href="in-depth/../tutorial/output.html">the chapter on CLI output</a> in the tutorial first. It covers how to write output to the terminal.</p>
</aside>
<h2 id="누가-이것을-읽고-있습니까"><a class="header" href="#누가-이것을-읽고-있습니까">누가 이것을 읽고 있습니까?</a></h2>
<p>먼저 물어볼 질문은 다음과 같습니다. 우리의 출력은 화려한 터미널 앞의 사람을 위한 것인가요, 아니면 다른 프로그램을 위한 것인가요? 답하기 위해 <a href="https://doc.rust-lang.org/stable/std/io/trait.IsTerminal.html">IsTerminal</a> 특성을 사용할 수 있습니다.</p>
<pre><code class="language-rust ignore">use std::io::IsTerminal;

if std::io::stdout().is_terminal() {
    println!("I'm a terminal");
} else {
    println!("I'm not");
}</code></pre>
<p>출력을 읽을 사람에 따라 추가 정보를 추가할 수 있습니다. 예를 들어, 무작위 Rust 프로젝트에서 <code>ls</code>를 실행하면 다음과 같은 것을 볼 수 있습니다. 예를 들어 사람들은 색상을 좋아합니다.</p>
<pre><code class="language-console">$ ls
CODE_OF_CONDUCT.md   LICENSE-APACHE       examples
CONTRIBUTING.md      LICENSE-MIT          proptest-regressions
Cargo.lock           README.md            src
Cargo.toml           convey_derive        target
</code></pre>
<p>이 스타일은 사람들을 위해 만들어졌기 때문에 대부분의 구성에서는 <code>src</code>와 같은 일부 이름을 색상으로 표시하여 디렉토리임을 보여줍니다. 대신 파일이나 <code>cat</code>과 같은 프로그램으로 파이프하면 <code>ls</code>가 출력을 조정합니다. 터미널 창에 맞는 열을 사용하는 대신 각 항목을 자체 줄에 인쇄합니다. 색상도 출력하지 않습니다.</p>
<pre><code class="language-console">$ ls | cat
CODE_OF_CONDUCT.md
CONTRIBUTING.md
Cargo.lock
Cargo.toml
LICENSE-APACHE
LICENSE-MIT
README.md
convey_derive
examples
proptest-regressions
src
target
</code></pre>
<h2 id="기계를-위한-쉬운-출력-형식"><a class="header" href="#기계를-위한-쉬운-출력-형식">기계를 위한 쉬운 출력 형식</a></h2>
<p>역사적으로 명령줄 도구가 생성한 유일한 유형의 출력은 문자열이었습니다. 이것은 일반적으로 텍스트를 읽고 그 의미를 추론할 수 있는 터미널 앞의 사람들에게는 괜찮습니다. 그러나 다른 프로그램은 일반적으로 그 능력이 없습니다. <code>ls</code>와 같은 도구의 출력을 이해하는 유일한 방법은 프로그램 작성자가 <code>ls</code>가 출력하는 모든 것에 대해 작동하는 파서를 포함한 경우입니다.</p>
<p>이것은 종종 출력이 구문 분석하기 쉬운 것으로 제한된다는 것을 의미합니다. 각 레코드가 자체 줄에 있고 각 줄에 탭으로 구분된 콘텐츠가 포함된 TSV(탭으로 구분된 값)와 같은 형식은 매우 인기가 있습니다. 텍스트 줄을 기반으로 하는 이러한 간단한 형식은 <code>grep</code>과 같은 도구를 <code>ls</code>와 같은 도구의 출력에 사용할 수 있도록 합니다. <code>| grep Cargo</code>는 줄이 <code>ls</code>에서 왔는지 파일에서 왔는지 신경 쓰지 않고 줄별로 필터링합니다.</p>
<p>이것의 단점은 <code>ls</code>가 제공한 모든 디렉토리를 필터링하기 위해 간단한 <code>grep</code> 호출을 사용할 수 없다는 것입니다. 이를 위해서는 각 디렉토리 항목에 추가 데이터가 포함되어야 합니다.</p>
<h2 id="기계를-위한-json-출력"><a class="header" href="#기계를-위한-json-출력">기계를 위한 JSON 출력</a></h2>
<p>탭으로 구분된 값은 구조화된 데이터를 출력하는 간단한 방법이지만 다른 프로그램이 어떤 필드를 예상해야 하는지(및 어떤 순서로) 알아야 하며 다른 유형의 메시지를 출력하기 어렵습니다. 예를 들어, 우리 프로그램이 소비자에게 현재 다운로드를 기다리고 있다고 메시지를 보내고 그 후 받은 데이터를 설명하는 메시지를 출력한다고 가정해 봅시다. 이것들은 매우 다른 종류의 메시지이며 TSV 출력에서 이를 통합하려고 하면 차별화할 방법을 발명해야 합니다. 가변 길이 항목의 두 목록을 포함하는 메시지를 인쇄하려고 할 때도 마찬가지입니다.</p>
<p>그럼에도 불구하고 대부분의 프로그래밍 언어/환경에서 쉽게 구문 분석할 수 있는 형식을 선택하는 것이 좋습니다. 따라서 지난 몇 년 동안 많은 응용 프로그램이 <a href="https://www.json.org/">JSON</a>으로 데이터를 출력하는 기능을 갖추게 되었습니다. 거의 모든 언어에 파서가 존재할 만큼 간단하지만 많은 경우에 유용할 만큼 강력합니다. 사람이 읽을 수 있는 텍스트 형식이지만 많은 사람들이 JSON 데이터를 구문 분석하고 데이터를 JSON으로 직렬화하는 데 매우 빠른 구현을 작업했습니다.</p>
<p>위 설명에서 프로그램에서 작성하는 “메시지“에 대해 이야기했습니다. 이것은 출력을 생각하는 좋은 방법입니다. 프로그램이 반드시 하나의 데이터 덩어리만 출력하는 것이 아니라 실행 중에 많은 다른 정보를 방출할 수 있습니다. JSON을 출력할 때 이 접근 방식을 지원하는 한 가지 쉬운 방법은 메시지당 하나의 JSON 문서를 작성하고 각 JSON 문서를 새 줄에 넣는 것입니다(때로는 <a href="https://en.wikipedia.org/wiki/JSON_streaming#Line-delimited_JSON">줄 구분 JSON</a>이라고 함). 이렇게 하면 일반 <code>println!</code>을 사용하는 것처럼 구현을 간단하게 만들 수 있습니다.</p>
<p>다음은 <a href="https://crates.io/crates/serde_json">serde_json</a>의 <code>json!</code> 매크로를 사용하여 Rust 소스 코드에 유효한 JSON을 빠르게 작성하는 간단한 예입니다.</p>
<pre><code class="language-rust ignore">use clap::Parser;
use serde_json::json;

/// 파일에서 패턴을 검색하고 해당 패턴을 포함하는 줄을 표시합니다.
#[derive(Parser)]
struct Cli {
    /// 사람이 읽을 수 있는 메시지 대신 JSON 출력
    #[arg(long = "json")]
    json: bool,
}

fn main() {
    let args = Cli::parse();
    if args.json {
        println!(
            "{}",
            json!({
                "type": "message",
                "content": "Hello world",
            })
        );
    } else {
        println!("Hello world");
    }
}</code></pre>
<p>그리고 여기 출력이 있습니다.</p>
<pre><code class="language-console">$ cargo run -q
Hello world
$ cargo run -q -- --json
{"content":"Hello world","type":"message"}
</code></pre>
<p>(<code>cargo</code>를 <code>-q</code>와 함께 실행하면 일반 출력이 억제됩니다. <code>--</code> 뒤의 인수는 프로그램에 전달됩니다.)</p>
<h3 id="실용적인-예-ripgrep"><a class="header" href="#실용적인-예-ripgrep">실용적인 예: ripgrep</a></h3>
<p>_<a href="https://github.com/BurntSushi/ripgrep">ripgrep</a>_은 <em>grep</em> 또는 _ag_의 대안이며 Rust로 작성되었습니다. 기본적으로 다음과 같은 출력을 생성합니다.</p>
<pre><code class="language-console">$ rg default
src/lib.rs
37:    Output::default()

src/components/span.rs
6:    Span::default()
</code></pre>
<p>하지만 <code>--json</code>을 제공하면 다음과 같이 인쇄됩니다.</p>
<pre><code class="language-console">$ rg default --json
{"type":"begin","data":{"path":{"text":"src/lib.rs"}}}
{"type":"match","data":{"path":{"text":"src/lib.rs"},"lines":{"text":"    Output::default()\n"},"line_number":37,"absolute_offset":761,"submatches":[{"match":{"text":"default"},"start":12,"end":19}]}}
{"type":"end","data":{"path":{"text":"src/lib.rs"},"binary_offset":null,"stats":{"elapsed":{"secs":0,"nanos":137622,"human":"0.000138s"},"searches":1,"searches_with_match":1,"bytes_searched":6064,"bytes_printed":256,"matched_lines":1,"matches":1}}}
{"type":"begin","data":{"path":{"text":"src/components/span.rs"}}}
{"type":"match","data":{"path":{"text":"src/components/span.rs"},"lines":{"text":"    Span::default()\n"},"line_number":6,"absolute_offset":117,"submatches":[{"match":{"text":"default"},"start":10,"end":17}]}}
{"type":"end","data":{"path":{"text":"src/components/span.rs"},"binary_offset":null,"stats":{"elapsed":{"secs":0,"nanos":22025,"human":"0.000022s"},"searches":1,"searches_with_match":1,"bytes_searched":5221,"bytes_printed":277,"matched_lines":1,"matches":1}}}
{"data":{"elapsed_total":{"human":"0.006995s","nanos":6994920,"secs":0},"stats":{"bytes_printed":533,"bytes_searched":11285,"elapsed":{"human":"0.000160s","nanos":159647,"secs":0},"matched_lines":2,"matches":2,"searches":2,"searches_with_match":2}},"type":"summary"}
</code></pre>
<p>보시다시피 각 JSON 문서는 <code>type</code> 필드를 포함하는 객체(맵)입니다. 이를 통해 <code>rg</code>에 대한 간단한 프런트엔드를 작성하여 문서를 수신하는 대로 읽고 _ripgrep_이 아직 검색 중일 때도 일치 항목(파일 포함)을 표시할 수 있습니다.</p>
<aside>
<p><strong>참고:</strong> 이것이 Visual Studio Code가 코드 검색에 _ripgrep_을 사용하는 방식입니다.</p>
</aside>
<h2 id="파이프된-입력을-처리하는-방법"><a class="header" href="#파이프된-입력을-처리하는-방법">파이프된 입력을 처리하는 방법</a></h2>
<p>파일의 단어 수를 읽는 프로그램이 있다고 가정해 봅시다.</p>
<pre><code class="language-rust ignore">use clap::Parser;
use std::path::PathBuf;

/// 파일의 줄 수 계산
#[derive(Parser)]
#[command(arg_required_else_help = true)]
struct Cli {
    /// 읽을 파일의 경로
    file: PathBuf,
}

fn main() {
    let args = Cli::parse();
    let mut word_count = 0;
    let file = args.file;

    for line in std::fs::read_to_string(&amp;file).unwrap().lines() {
        word_count += line.split(' ').count();
    }

    println!("Words in {}: {}", file.to_str().unwrap(), word_count)
}</code></pre>
<p>파일 경로를 가져와 줄별로 읽고 공백으로 구분된 단어 수를 계산합니다.</p>
<p>실행하면 파일의 총 단어 수가 출력됩니다.</p>
<pre><code class="language-console">$ cargo run README.md
Words in README.md: 47
</code></pre>
<p>하지만 프로그램으로 파이프된 단어 수를 세고 싶다면 어떻게 될까요? Rust 프로그램은 표준 라이브러리의 <a href="https://doc.rust-lang.org/std/io/fn.stdin.html">stdin 함수</a>를 통해 얻을 수 있는 <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html">Stdin 구조체</a>를 사용하여 stdin을 통해 전달된 데이터를 읽을 수 있습니다. 파일 줄을 읽는 것과 유사하게 stdin에서 줄을 읽을 수 있습니다.</p>
<p>stdin을 통해 파이프된 단어를 계산하는 프로그램입니다.</p>
<pre><code class="language-rust ignore">use clap::{CommandFactory, Parser};
use std::{
    fs::File,
    io::{stdin, BufRead, BufReader, IsTerminal},
    path::PathBuf,
};

/// 파일 또는 stdin의 줄 수 계산
#[derive(Parser)]
#[command(arg_required_else_help = true)]
struct Cli {
    /// 읽을 파일의 경로, stdin에서 읽으려면 - 사용(tty여서는 안 됨)
    file: PathBuf,
}

fn main() {
    let args = Cli::parse();

    let word_count;
    let mut file = args.file;

    if file == PathBuf::from("-") {
        if stdin().is_terminal() {
            Cli::command().print_help().unwrap();
            ::std::process::exit(2);
        }

        file = PathBuf::from("&lt;stdin&gt;");
        word_count = words_in_buf_reader(BufReader::new(stdin().lock()));
    } else {
        word_count = words_in_buf_reader(BufReader::new(File::open(&amp;file).unwrap()));
    }

    println!("Words from {}: {}", file.to_string_lossy(), word_count)
}

fn words_in_buf_reader&lt;R: BufRead&gt;(buf_reader: R) -&gt; usize {
    let mut count = 0;
    for line in buf_reader.lines() {
        count += line.unwrap().split(' ').count()
    }
    count
}</code></pre>
<p><code>stdin</code>에서 읽으려는 의도를 나타내는 <code>-</code>를 사용하여 텍스트를 파이프한 프로그램으로 실행하면 단어 수가 출력됩니다.</p>
<pre><code class="language-console">$ echo "hi there friend" | cargo run -- -
Words from stdin: 3
</code></pre>
<p>런타임에 입력되는 텍스트가 아니라 프로그램으로 파이프되는 입력을 예상하기 때문에 stdin이 대화형이 아니어야 합니다. stdin이 tty인 경우 작동하지 않는 이유를 명확히 하기 위해 도움말 문서를 출력합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cli-앱용-문서-렌더링"><a class="header" href="#cli-앱용-문서-렌더링">CLI 앱용 문서 렌더링</a></h1>
<p>CLI의 문서는 일반적으로 명령의 <code>--help</code> 섹션과 매뉴얼(<code>man</code>) 페이지로 구성됩니다.</p>
<p>둘 다 <a href="https://crates.io/crates/clap"><code>clap</code></a>을 사용할 때 <a href="https://crates.io/crates/clap_mangen"><code>clap_mangen</code></a> 크레이트를 통해 자동으로 생성될 수 있습니다.</p>
<pre><code class="language-rust ignore">#[derive(Parser)]
pub struct Head {
    /// 로드할 파일
    pub file: PathBuf,
    /// 인쇄할 줄 수
    #[arg(short = "n", default_value = "5")]
    pub count: usize,
}</code></pre>
<p>둘째, 코드로 앱을 정의한 후 컴파일 시간에 매뉴얼 파일을 생성하기 위해 <code>build.rs</code>를 사용해야 합니다.</p>
<p>명심해야 할 몇 가지 사항이 있습니다(바이너리를 패키징하는 방법 등). 하지만 지금은 <code>man</code> 파일을 <code>src</code> 폴더 옆에 두겠습니다.</p>
<pre><code class="language-rust ignore">use clap::CommandFactory;

#[path="src/cli.rs"]
mod cli;

fn main() -&gt; std::io::Result&lt;()&gt; {
    let out_dir = std::path::PathBuf::from(std::env::var_os("OUT_DIR").ok_or_else(|| std::io::ErrorKind::NotFound)?);
    let cmd = cli::Head::command();

    let man = clap_mangen::Man::new(cmd);
    let mut buffer: Vec&lt;u8&gt; = Default::default();
    man.render(&amp;mut buffer)?;

    std::fs::write(out_dir.join("head.1"), buffer)?;

    Ok(())
}</code></pre>
<p>이제 응용 프로그램을 컴파일하면 프로젝트 디렉토리에 <code>head.1</code> 파일이 생성됩니다.</p>
<p><code>man</code>에서 열면 무료 문서를 감상할 수 있습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="리소스"><a class="header" href="#리소스">리소스</a></h1>
<p>협업 / 도움</p>
<ul>
<li><a href="https://discord.com/channels/273534239310479360/943315667430563862">cli-and-tui Discord 채널</a></li>
</ul>
<h2 id="이-책에서-참조된-크레이트"><a class="header" href="#이-책에서-참조된-크레이트">이 책에서 참조된 크레이트</a></h2>
<ul>
<li><a href="https://crates.io/crates/anyhow">anyhow</a> - 쉬운 오류 처리를 위한 <code>anyhow::Error</code> 제공</li>
<li><a href="https://crates.io/crates/assert_cmd">assert_cmd</a> - CLI 통합 테스트 단순화</li>
<li><a href="https://crates.io/crates/assert_fs">assert_fs</a> - 입력 파일 설정 및 출력 파일 테스트</li>
<li><a href="https://crates.io/crates/clap-verbosity-flag">clap-verbosity-flag</a> - clap CLI에 <code>--verbose</code> 플래그 추가</li>
<li><a href="https://crates.io/crates/clap">clap</a> - 명령줄 인수 파서</li>
<li><a href="https://crates.io/crates/confy">confy</a> - 보일러플레이트 없는 구성 관리</li>
<li><a href="https://crates.io/crates/crossbeam-channel">crossbeam-channel</a> - 메시지 전달을 위한 다중 생산자 다중 소비자 채널 제공</li>
<li><a href="https://crates.io/crates/ctrlc">ctrlc</a> - 쉬운 ctrl-c 핸들러</li>
<li><a href="https://crates.io/crates/env_logger">env_logger</a> - 환경 변수를 통해 구성 가능한 로거 구현</li>
<li><a href="https://crates.io/crates/exitcode">exitcode</a> - 시스템 종료 코드 상수</li>
<li><a href="https://crates.io/crates/human-panic">human-panic</a> - 패닉 메시지 핸들러</li>
<li><a href="https://crates.io/crates/indicatif">indicatif</a> - 진행률 표시줄 및 스피너</li>
<li><a href="https://crates.io/crates/log">log</a> - 구현에 추상화된 로깅 제공</li>
<li><a href="https://crates.io/crates/predicates">predicates</a> - 부울 값 술어 함수 구현</li>
<li><a href="https://crates.io/crates/proptest">proptest</a> - 속성 테스트 프레임워크</li>
<li><a href="https://crates.io/crates/serde_json">serde_json</a> - JSON으로 직렬화/역직렬화</li>
<li><a href="https://crates.io/crates/signal-hook">signal-hook</a> - UNIX 신호 처리</li>
<li><a href="https://crates.io/crates/tokio">tokio</a> - 비동기 런타임</li>
<li><a href="https://crates.io/crates/wasm-pack">wasm-pack</a> - WebAssembly 빌드 도구</li>
</ul>
<h2 id="기타-크레이트"><a class="header" href="#기타-크레이트">기타 크레이트</a></h2>
<p>Rust 크레이트의 끊임없이 변화하는 환경 때문에 크레이트를 찾을 수 있는 좋은 장소는 <a href="https://lib.rs">lib.rs</a> 크레이트 인덱스이며, 다음을 포함합니다.</p>
<ul>
<li><a href="https://lib.rs/command-line-interface">명령줄 인터페이스</a></li>
<li><a href="https://lib.rs/config">구성</a></li>
<li><a href="https://lib.rs/database">데이터베이스 인터페이스</a></li>
<li><a href="https://lib.rs/encoding">인코딩</a></li>
<li><a href="https://lib.rs/filesystem">파일 시스템</a></li>
<li><a href="https://lib.rs/web-programming/http-client">HTTP 클라이언트</a></li>
<li><a href="https://lib.rs/os">운영 체제</a></li>
</ul>
<p>기타 리소스:</p>
<ul>
<li><a href="https://rust-lang-nursery.github.io/rust-cookbook/">Rust Cookbook</a></li>
<li><a href="https://github.com/rosetta-rs">rosetta-rs</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/language-picker.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
