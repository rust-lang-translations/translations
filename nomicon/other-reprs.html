<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Other reprs - The Rustonomicon</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/nomicon";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/other-reprs.md`;
                    } else {
                        canonical_href = `${base}/${lang}/other-reprs.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("en");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="The Dark Arts of Advanced and Unsafe Rust Programming">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/nomicon.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rustonomicon</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="alternative-representations"><a class="header" href="#alternative-representations">Alternative representations</a></h1>
<p>Rust allows you to specify alternative data layout strategies from the default.</p>
<h2 id="reprc"><a class="header" href="#reprc">repr(C)</a></h2>
<p>This is the most important <code>repr</code>. It has fairly simple intent: do what C does.
The order, size, and alignment of fields is exactly what you would expect from C
or C++. The type is also passed across <code>extern "C"</code> function call boundaries the
same way C would pass the corresponding type. Any type you expect to pass through an FFI boundary should have
<code>repr(C)</code>, as C is the lingua-franca of the programming world. This is also
necessary to soundly do more elaborate tricks with data layout such as
reinterpreting values as a different type.</p>
<p>We strongly recommend using <a href="https://rust-lang.github.io/rust-bindgen/">rust-bindgen</a> and/or <a href="https://github.com/eqrion/cbindgen">cbindgen</a> to manage your FFI
boundaries for you. The Rust team works closely with those projects to ensure
that they work robustly and are compatible with current and future guarantees
about type layouts and <code>repr</code>s.</p>
<p>The interaction of <code>repr(C)</code> with Rust's more exotic data layout features must be
kept in mind. Due to its dual purpose as "for FFI" and "for layout control",
<code>repr(C)</code> can be applied to types that will be nonsensical or problematic if
passed through the FFI boundary.</p>
<ul>
<li>
<p>ZSTs are still zero-sized, even though this is not a standard behavior in
C, and is explicitly contrary to the behavior of an empty type in C++, which
says they should still consume a byte of space.</p>
</li>
<li>
<p>DST pointers (wide pointers) and tuples are not a concept
in C, and as such are never FFI-safe.</p>
</li>
<li>
<p>Enums with fields also aren't a concept in C or C++, but a valid bridging
of the types <a href="https://github.com/rust-lang/rfcs/blob/master/text/2195-really-tagged-unions.md">is defined</a>.</p>
</li>
<li>
<p>If <code>T</code> is an <a href="ffi.html#the-nullable-pointer-optimization">FFI-safe non-nullable pointer
type</a>,
<code>Option&lt;T&gt;</code> is guaranteed to have the same layout and ABI as <code>T</code> and is
therefore also FFI-safe. As of this writing, this covers <code>&amp;</code>, <code>&amp;mut</code>,
and function pointers, all of which can never be null.</p>
</li>
<li>
<p>Tuple structs are like structs with regards to <code>repr(C)</code>, as the only
difference from a struct is that the fields arenâ€™t named.</p>
</li>
<li>
<p><code>repr(C)</code> is equivalent to one of <code>repr(u*)</code> (see the next section) for
fieldless enums. The chosen size and sign is the default enum size and sign for the target platform's C
application binary interface (ABI). Note that enum representation in C is implementation
defined, so this is really a "best guess". In particular, this may be incorrect
when the C code of interest is compiled with certain flags.</p>
</li>
<li>
<p>Fieldless enums with <code>repr(C)</code> or <code>repr(u*)</code> still may not be set to an
integer value without a corresponding variant, even though this is
permitted behavior in C or C++. It is undefined behavior to (unsafely)
construct an instance of an enum that does not match one of its
variants. (This allows exhaustive matches to continue to be written and
compiled as normal.)</p>
</li>
</ul>
<h2 id="reprtransparent"><a class="header" href="#reprtransparent">repr(transparent)</a></h2>
<p><code>#[repr(transparent)]</code> can only be used on a struct or single-variant enum that has a single non-zero-sized field (there may be additional zero-sized fields).
The effect is that the layout and ABI of the whole struct/enum is guaranteed to be the same as that one field.</p>
<blockquote>
<p>NOTE: There's a <code>transparent_unions</code> nightly feature to apply <code>repr(transparent)</code> to unions,
but it hasn't been stabilized due to design concerns. See the <a href="https://github.com/rust-lang/rust/issues/60405">tracking issue</a> for more details.</p>
</blockquote>
<p>The goal is to make it possible to transmute between the single field and the
struct/enum. An example of that is <a href="../std/cell/struct.UnsafeCell.html"><code>UnsafeCell</code></a>, which can be transmuted into
the type it wraps (<a href="../std/cell/struct.UnsafeCell.html"><code>UnsafeCell</code></a> also uses the unstable <a href="https://github.com/rust-lang/rust/pull/68491">no_niche</a>,
so its ABI is not actually guaranteed to be the same when nested in other types).</p>
<p>Also, passing the struct/enum through FFI where the inner field type is expected on
the other side is guaranteed to work. In particular, this is necessary for
<code>struct Foo(f32)</code> or <code>enum Foo { Bar(f32) }</code> to always have the same ABI as <code>f32</code>.</p>
<p>This repr is only considered part of the public ABI of a type if either the single
field is <code>pub</code>, or if its layout is documented in prose. Otherwise, the layout should
not be relied upon by other crates.</p>
<p>More details are in the <a href="https://github.com/rust-lang/rfcs/blob/master/text/1758-repr-transparent.md">RFC 1758</a> and the <a href="https://rust-lang.github.io/rfcs/2645-transparent-unions.html">RFC 2645</a>.</p>
<h2 id="repru-repri"><a class="header" href="#repru-repri">repr(u*), repr(i*)</a></h2>
<p>These specify the size and sign to make a fieldless enum. If the discriminant overflows
the integer it has to fit in, it will produce a compile-time error. You can
manually ask Rust to allow this by setting the overflowing element to explicitly
be 0. However Rust will not allow you to create an enum where two variants have
the same discriminant.</p>
<p>The term "fieldless enum" only means that the enum doesn't have data in any
of its variants. A fieldless enum without a <code>repr</code> is
still a Rust native type, and does not have a stable layout or representation.
Adding a <code>repr(u*)</code>/<code>repr(i*)</code> causes it to be treated exactly like the specified
integer type for layout purposes (except that the compiler will still exploit its
knowledge of "invalid" values at this type to optimize enum layout, such as when
this enum is wrapped in <code>Option</code>). Note that the function call ABI for these
types is still in general unspecified, except that across <code>extern "C"</code> calls they
are ABI-compatible with C enums of the same sign and size.</p>
<p>If the enum has fields, the effect is similar to the effect of <code>repr(C)</code>
in that there is a defined layout of the type. This makes it possible to
pass the enum to C code, or access the type's raw representation and directly
manipulate its tag and fields. See <a href="https://github.com/rust-lang/rfcs/blob/master/text/2195-really-tagged-unions.md">the RFC</a> for details.</p>
<p>These <code>repr</code>s have no effect on a struct.</p>
<p>Adding an explicit <code>repr(u*)</code>, <code>repr(i*)</code>, or <code>repr(C)</code> to an enum with fields suppresses the null-pointer optimization, like:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::mem::size_of;
</span>enum MyOption&lt;T&gt; {
    Some(T),
    None,
}

#[repr(u8)]
enum MyReprOption&lt;T&gt; {
    Some(T),
    None,
}

assert_eq!(8, size_of::&lt;MyOption&lt;&amp;u16&gt;&gt;());
assert_eq!(16, size_of::&lt;MyReprOption&lt;&amp;u16&gt;&gt;());
<span class="boring">}</span></code></pre></pre>
<p>This optimization still applies to fieldless enums with an explicit <code>repr(u*)</code>, <code>repr(i*)</code>, or <code>repr(C)</code>.</p>
<h2 id="reprpacked-reprpackedn"><a class="header" href="#reprpacked-reprpackedn">repr(packed), repr(packed(n))</a></h2>
<p><code>repr(packed(n))</code> (where <code>n</code> is a power of two) forces the type to have an
alignment of <em>at most</em> <code>n</code>. Most commonly used without an explicit <code>n</code>,
<code>repr(packed)</code> is equivalent to <code>repr(packed(1))</code> which forces Rust to strip
any padding, and only align the type to a byte. This may improve the memory
footprint, but will likely have other negative side-effects.</p>
<p>In particular, most architectures <em>strongly</em> prefer values to be naturally
aligned. This may mean that unaligned loads are penalized (x86), or even fault
(some ARM chips). For simple cases like directly loading or storing a packed
field, the compiler might be able to paper over alignment issues with shifts
and masks. However if you take a reference to a packed field, it's unlikely
that the compiler will be able to emit code to avoid an unaligned load.</p>
<p><a href="https://github.com/rust-lang/rust/issues/27060">As this can cause undefined behavior</a>, the lint has been implemented
and it will become a hard error.</p>
<p><code>repr(packed)/repr(packed(n))</code> is not to be used lightly. Unless you have
extreme requirements, this should not be used.</p>
<p>This repr is a modifier on <code>repr(C)</code> and <code>repr(Rust)</code>. For FFI compatibility
you most likely always want to be explicit: <code>repr(C, packed)</code>.</p>
<h2 id="repralignn"><a class="header" href="#repralignn">repr(align(n))</a></h2>
<p><code>repr(align(n))</code> (where <code>n</code> is a power of two) forces the type to have an
alignment of <em>at least</em> <code>n</code>.</p>
<p>This enables several tricks, like making sure neighboring elements of an array
never share the same cache line with each other (which may speed up certain
kinds of concurrent code).</p>
<p>This is a modifier on <code>repr(C)</code> and <code>repr(Rust)</code>. It is incompatible with
<code>repr(packed)</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="exotic-sizes.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ownership.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="exotic-sizes.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ownership.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
