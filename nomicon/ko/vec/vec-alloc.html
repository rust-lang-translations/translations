<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>할당하기 - The Rustonomicon</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/nomicon";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/vec/vec-alloc.md`;
                    } else {
                        canonical_href = `${base}/${lang}/vec/vec-alloc.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="The Dark Arts of Advanced and Unsafe Rust Programming">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/nomicon.css">
        <link rel="stylesheet" href="../theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rustonomicon</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="메모리-할당하기"><a class="header" href="#메모리-할당하기">메모리 할당하기</a></h1>
<p>NonNull을 사용하는 것은 Vec(그리고 실제로 모든 표준 라이브러리 컬렉션)의 중요한 기능에 걸림돌이 됩니다. 빈 Vec을 생성할 때는 실제로 메모리를 전혀 할당하지 않는다는 점입니다. 이는 크기가 0인 메모리 블록을 할당하는 것과는 다릅니다. 전역 할당자(global allocator)는 크기가 0인 할당을 허용하지 않기 때문입니다(이는 정의되지 않은 동작을 초래합니다!). 그렇다면 할당을 할 수 없으면서 ptr에 null 포인터를 넣을 수도 없다면, Vec::new에서 무엇을 해야 할까요? 음, 그냥 그곳에 다른 쓰레기 값을 넣어두면 됩니다!</p>
<p>이는 전혀 문제가 되지 않습니다. 할당이 없음을 나타내는 파수꾼(sentinel) 값으로 이미 <code>cap == 0</code>을 사용하고 있기 때문입니다. 거의 모든 코드에서 이를 특별히 처리할 필요조차 없습니다. 어차피 보통 <code>cap &gt; len</code>이나 <code>len &gt; 0</code>인지 확인해야 하기 때문입니다. 여기에 넣는 것이 권장되는 러스트 값은 <code>mem::align_of::&lt;T&gt;()</code>입니다. <code>NonNull</code>은 이를 위한 편의 기능인 <code>NonNull::dangling()</code>을 제공합니다. 실제 할당된 메모리는 없지만 <code>null</code>을 사용하면 컴파일러가 원치 않는 동작을 할 수 있는 곳이 꽤 많으므로, 그럴 때 <code>dangling</code>을 사용하게 됩니다.</p>
<p>그래서:</p>
<!-- ignore: explanation code -->
<pre><code class="language-rust ignore">use std::mem;

impl&lt;T&gt; Vec&lt;T&gt; {
    pub fn new() -&gt; Self {
        assert!(mem::size_of::&lt;T&gt;() != 0, "아직 ZST를 처리할 준비가 되지 않았습니다");
        Vec {
            ptr: NonNull::dangling(),
            len: 0,
            cap: 0,
        }
    }
}
<span class="boring">fn main() {}</span></code></pre>
<p>여기에 단언문(assert)을 살짝 끼워 넣은 이유는 크기가 0인 타입(ZST)은 코드 전반에 걸쳐 특별한 처리가 필요하기 때문입니다. 일단 이 문제는 나중에 다루고 싶습니다. 이 단언문이 없다면, 초기 초안 중 일부는 아주 끔찍한 일을 저지를 것입니다.</p>
<p>다음으로 우리가 정말로 공간을 원할 때 무엇을 해야 할지 알아내야 합니다. 이를 위해 안정적인(stable) 러스트의 <a href="../../alloc/alloc/index.html"><code>std::alloc</code></a>에서 제공하는 전역 할당 함수인 <a href="../../alloc/alloc/fn.alloc.html"><code>alloc</code></a>, <a href="../../alloc/alloc/fn.realloc.html"><code>realloc</code></a>, <a href="../../alloc/alloc/fn.dealloc.html"><code>dealloc</code></a>을 사용합니다. 이 함수들은 <a href="../../std/alloc/struct.Global.html"><code>std::alloc::Global</code></a> 타입이 안정화된 이후에는 해당 타입의 메서드들로 대체되면서 사라질 예정입니다.</p>
<p>또한 메모리 부족(OOM) 상황을 처리할 방법이 필요합니다. 표준 라이브러리는 <a href="../../alloc/alloc/fn.handle_alloc_error.html"><code>alloc::handle_alloc_error</code></a> 함수를 제공하는데, 이 함수는 플랫폼별 방식에 따라 프로그램을 중단(abort)시킵니다. 패닉을 발생시키지 않고 중단하는 이유는 언와인딩(unwinding) 과정에서 추가적인 할당이 발생할 수 있기 때문입니다. 할당자가 방금 "메모리가 부족하다"고 했는데 추가 할당을 시도하는 것은 좋은 생각이 아닌 것 같습니다.</p>
<p>물론 대부분의 플랫폼에서 전통적인 방식으로 메모리가 부족해지는 일은 거의 없으므로 이는 조금 우스운 일일 수 있습니다. 실제로 메모리를 전부 사용하기 시작하면 운영 체제가 다른 수단을 통해 애플리케이션을 강제 종료할 가능성이 높습니다. 우리가 OOM을 유발할 수 있는 가장 가능성 높은 방법은 한 번에 터무니없는 양의 메모리(예: 이론적 주소 공간의 절반)를 요구하는 것입니다. 그런 경우라면 패닉을 발생시켜도 별다른 나쁜 일은 일어나지 않을 것이며 아마 괜찮을 것입니다. 그럼에도 불구하고 우리는 가능한 한 표준 라이브러리와 유사하게 만들고 싶으므로, 그냥 전체 프로그램을 종료할 것입니다.</p>
<p>좋습니다. 이제 용량 확장(growing) 로직을 작성해 봅시다. 대략적으로 다음과 같은 로직을 원합니다:</p>
<pre><code class="language-text">if cap == 0:
    allocate()
    cap = 1
else:
    reallocate()
    cap *= 2
</code></pre>
<p>하지만 러스트에서 지원하는 유일한 할당자 API는 너무 저수준이라 꽤 많은 추가 작업을 해야 합니다. 또한 아주 큰 할당이나 빈 할당에서 발생할 수 있는 몇 가지 특별한 상황에 대해서도 대비해야 합니다.</p>
<p>특히 <code>ptr::offset</code>은 우리에게 많은 문제를 일으킬 것입니다. 이는 LLVM의 GEP inbounds 명령어의 의미론을 가지고 있기 때문입니다. 만약 이 명령어를 다뤄보지 않은 행운아라면, GEP에 대한 기본적인 이야기는 이렇습니다: 별칭 분석(alias analysis), 별칭 분석, 그리고 별칭 분석입니다. 최적화 컴파일러가 데이터 의존성과 별칭에 대해 추론할 수 있는 능력은 매우 중요합니다.</p>
<p>간단한 예로, 다음 코드 조각을 고려해 보십시오:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">*x *= 7;
*y *= 3;</code></pre>
<p>만약 컴파일러가 <code>x</code>와 <code>y</code>가 메모리의 서로 다른 위치를 가리키고 있음을 증명할 수 있다면, 이론적으로 두 연산은 (예를 들어 서로 다른 레지스터에 로드하여 독립적으로 작업함으로써) 병렬로 실행될 수 있습니다. 하지만 일반적인 상황에서 컴파일러는 이를 수행할 수 없습니다. x와 y가 메모리의 동일한 위치를 가리킨다면, 연산이 동일한 값에 대해 수행되어야 하며 나중에 단순히 병합될 수 없기 때문입니다.</p>
<p>GEP inbounds를 사용할 때, 당신은 수행하려는 오프셋이 단일 "할당된" 개체의 범위 내에 있음을 LLVM에 명시적으로 알리는 것입니다. 그 결과로 얻는 궁극적인 이득은, 두 포인터가 서로 겹치지 않는 두 객체를 가리키는 것으로 알려져 있다면 LLVM이 그 포인터들의 모든 오프셋 또한 서로 별칭되지 않는다고 가정할 수 있다는 점입니다 (메모리의 엉뚱한 곳에 도달하지 않을 것이기 때문입니다). LLVM은 GEP 오프셋 작업에 고도로 최적화되어 있으며, 그중에서도 inbounds 오프셋이 가장 뛰어나므로 가능한 한 많이 사용하는 것이 중요합니다.</p>
<p>이것이 GEP에 대한 이야기입니다. 그렇다면 이것이 어떻게 우리에게 문제를 일으킬 수 있을까요?</p>
<p>첫 번째 문제는 우리가 배열을 인덱싱할 때는 부호 없는 정수(unsigned integers)를 사용하지만, GEP(결과적으로 <code>ptr::offset</code>)는 부호 있는 정수(signed integer)를 받는다는 점입니다. 이는 겉보기에 유효해 보이는 배열 인덱스의 절반이 GEP에서 오버플로를 일으켜 실제로는 엉뚱한 방향으로 가게 된다는 것을 의미합니다! 따라서 모든 할당을 <code>isize::MAX</code>개 요소로 제한해야 합니다. 이는 사실 바이트 크기 객체들에 대해서만 걱정하면 된다는 뜻이기도 합니다. 예를 들어 <code>isize::MAX</code>를 넘어서는 개수의 <code>u16</code>은 시스템의 모든 메모리를 고갈시킬 것이기 때문입니다. 하지만 누군가 <code>isize::MAX</code>개 미만의 객체 배열을 바이트 단위로 재해석하는 미묘한 예외 상황을 방지하기 위해, 표준 라이브러리(std)는 모든 할당을 <code>isize::MAX</code> 바이트로 제한합니다.</p>
<p>현재 러스트가 지원하는 모든 64비트 타겟에서 우리는 인위적으로 64비트 주소 공간 전체보다 훨씬 적은 공간으로 제한되어 있습니다(현대적인 x64 플랫폼은 48비트 주소 지정만 노출함). 따라서 메모리가 먼저 고갈될 것이라고 믿어도 좋습니다. 하지만 32비트 타겟, 특히 주소 공간을 더 많이 사용하기 위한 확장 기능(PAE x86 또는 x32)이 있는 경우에는 이론적으로 <code>isize::MAX</code> 바이트를 넘는 메모리를 성공적으로 할당하는 것이 가능할 수 있습니다.</p>
<p>하지만 이것은 튜토리얼이므로, 영리한 플랫폼별 <code>cfg</code>를 사용하기보다는 여기서 특별히 최적화하지 않고 무조건적으로 체크하도록 하겠습니다.</p>
<p>우리가 걱정해야 할 또 다른 예외 상황은 빈 할당(empty allocations)입니다. 걱정해야 할 빈 할당에는 두 가지 종류가 있습니다: 모든 T에 대해 <code>cap = 0</code>인 경우와, 크기가 0인 타입에 대해 <code>cap &gt; 0</code>인 경우입니다.</p>
<p>이러한 경우들이 까다로운 이유는 LLVM이 말하는 "할당됨(allocated)"이 무엇을 의미하는지에 달려 있기 때문입니다. LLVM의 할당 개념은 우리가 평소에 사용하는 것보다 훨씬 더 추상적입니다. LLVM은 다양한 언어의 의미론 및 사용자 정의 할당자와 연동되어야 하므로, 할당을 아주 상세하게 이해할 수는 없습니다. 대신 할당의 주요 개념은 "다른 것과 겹치지 않는다"는 것입니다. 즉, 힙 할당, 스택 할당, 전역 변수들이 무작위로 겹치지 않는다는 점입니다. 네, 바로 별칭 분석에 관한 이야기입니다. 따라서 러스트는 _일관성_만 유지된다면 기술적으로 할당의 개념을 조금 느슨하게 다룰 수 있습니다.</p>
<p>빈 할당 사례로 돌아가서, 제네릭 코드의 결과로 0만큼 오프셋(offset)을 수행하려는 곳들이 몇 군데 있습니다. 그렇다면 질문은 이렇습니다: 그렇게 하는 것이 일관성이 있을까요? 크기가 0인 타입(ZST)의 경우, 임의의 개수만큼 GEP inbounds 오프셋을 수행하는 것이 실제로 일관성이 있다고 결론지었습니다. 모든 요소가 공간을 차지하지 않으므로 이는 런타임에 아무 작업도 수행하지 않으며(no-op), <code>0x01</code> 위치에 무한한 수의 ZST가 할당되어 있다고 가정해도 괜찮습니다. 어떤 할당자도 그 주소를 할당하지 않을 것입니다. 할당자는 <code>0x00</code>을 할당하지 않으며, 보통 1바이트보다 높은 최소 정렬 단위로 할당하기 때문입니다. 또한 일반적으로 메모리의 첫 번째 페이지 전체(많은 플랫폼에서 4k 전체)는 어차피 할당되지 않도록 보호됩니다.</p>
<p>하지만 크기가 0보다 큰 타입은 어떨까요? 그 경우는 조금 더 까다롭습니다. 원칙적으로 0만큼 오프셋하는 것은 LLVM에 아무런 정보도 주지 않는다고 주장할 수 있습니다: 주소 앞이나 뒤에 요소가 있을 수 있지만 어느 쪽인지 알 수 없기 때문입니다. 하지만 우리는 보수적으로 이것이 나쁜 영향을 줄 수 있다고 가정하기로 했습니다. 따라서 이 경우에 대해 명시적으로 대비할 것입니다.</p>
<p><em>휴우</em></p>
<p>좋습니다. 이제 부수적인 이야기들은 치워두고, 실제로 메모리를 할당해 봅시다:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">use std::alloc::{self, Layout};

impl&lt;T&gt; Vec&lt;T&gt; {
    fn grow(&amp;mut self) {
        let (new_cap, new_layout) = if self.cap == 0 {
            (1, Layout::array::&lt;T&gt;(1))
        } else {
            // self.cap &lt;= isize::MAX이므로 이는 오버플로할 수 없습니다.
            let new_cap = 2 * self.cap;
            (new_cap, Layout::array::&lt;T&gt;(new_cap))
        };

        // `Layout::array` checks that the number of bytes allocated is
        // in 1..=isize::MAX and will error otherwise.  An allocation of
        // 0 bytes isn't possible thanks to the above condition.
        let new_layout = new_layout.expect("할당이 너무 큼");

        let new_ptr = if self.cap == 0 {
            unsafe { alloc::alloc(new_layout) }
        } else {
            let old_layout = Layout::array::&lt;T&gt;(self.cap).unwrap();
            let old_ptr = self.ptr.as_ptr() as *mut u8;
            unsafe { alloc::realloc(old_ptr, old_layout, new_layout.size()) }
        };

        // 할당이 실패하면 `new_ptr`은 null이 되며, 이 경우 프로그램을 중단(abort)합니다.
        self.ptr = match NonNull::new(new_ptr as *mut T) {
            Some(p) =&gt; p,
            None =&gt; alloc::handle_alloc_error(new_layout),
        };
        self.cap = new_cap;
    }
}
<span class="boring">fn main() {}</span></code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../vec/vec-layout.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../vec/vec-push-pop.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../vec/vec-layout.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../vec/vec-push-pop.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/language-picker.js"></script>


    </div>
    </body>
</html>
