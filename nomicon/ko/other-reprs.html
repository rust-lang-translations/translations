<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>다른 repr들 - The Rustonomicon</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/nomicon";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/other-reprs.md`;
                    } else {
                        canonical_href = `${base}/${lang}/other-reprs.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="The Dark Arts of Advanced and Unsafe Rust Programming">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/nomicon.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rustonomicon</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="alternative-representations"><a class="header" href="#alternative-representations">Alternative representations</a></h1>
<p>Rust allows you to specify alternative data layout strategies from the default. There's also the <a href="https://rust-lang.github.io/unsafe-code-guidelines/layout.html">unsafe code guidelines</a> (note that it's <strong>NOT</strong> normative).</p>
<h2 id="reprc"><a class="header" href="#reprc">repr(C)</a></h2>
<p>This is the most important <code>repr</code>. It has fairly simple intent: do what C does. The order, size, and alignment of fields is exactly what you would expect from C or C++. The type is also passed across <code>extern "C"</code> function call boundaries the same way C would pass the corresponding type. Any type you expect to pass through an FFI boundary should have <code>repr(C)</code>, as C is the lingua-franca of the programming world. This is also necessary to soundly do more elaborate tricks with data layout such as reinterpreting values as a different type.</p>
<p>We strongly recommend using <a href="https://rust-lang.github.io/rust-bindgen/">rust-bindgen</a> and/or <a href="https://github.com/eqrion/cbindgen">cbindgen</a> to manage your FFI boundaries for you. The Rust team works closely with those projects to ensure that they work robustly and are compatible with current and future guarantees about type layouts and <code>repr</code>s.</p>
<p>The interaction of <code>repr(C)</code> with Rust's more exotic data layout features must be kept in mind. Due to its dual purpose as "for FFI" and "for layout control", <code>repr(C)</code> can be applied to types that will be nonsensical or problematic if passed through the FFI boundary.</p>
<ul>
<li>
<p>ZSTs are still zero-sized, even though this is not a standard behavior in C, and is explicitly contrary to the behavior of an empty type in C++, which says they should still consume a byte of space.</p>
</li>
<li>
<p>DST pointers (wide pointers) and tuples are not a concept in C, and as such are never FFI-safe.</p>
</li>
<li>
<p>Enums with fields also aren't a concept in C or C++, but a valid bridging of the types <a href="https://github.com/rust-lang/rfcs/blob/master/text/2195-really-tagged-unions.md">is defined</a>.</p>
</li>
<li>
<p>If <code>T</code> is an <a href="ffi.html#the-nullable-pointer-optimization">FFI-safe non-nullable pointer type</a>, <code>Option&lt;T&gt;</code> is guaranteed to have the same layout and ABI as <code>T</code> and is therefore also FFI-safe. As of this writing, this covers <code>&amp;</code>, <code>&amp;mut</code>, and function pointers, all of which can never be null.</p>
</li>
<li>
<p>Tuple structs are like structs with regards to <code>repr(C)</code>, as the only difference from a struct is that the fields aren’t named.</p>
</li>
<li>
<p><code>repr(C)</code> is equivalent to one of <code>repr(u*)</code> (see the next section) for fieldless enums. The chosen size and sign is the default enum size and sign for the target platform's C application binary interface (ABI). Note that enum representation in C is implementation defined, so this is really a "best guess". In particular, this may be incorrect when the C code of interest is compiled with certain flags.</p>
</li>
<li>
<p>Fieldless enums with <code>repr(C)</code> or <code>repr(u*)</code> still may not be set to an integer value without a corresponding variant, even though this is permitted behavior in C or C++. It is undefined behavior to (unsafely) construct an instance of an enum that does not match one of its variants. (This allows exhaustive matches to continue to be written and compiled as normal.)</p>
</li>
</ul>
<h2 id="reprtransparent"><a class="header" href="#reprtransparent">repr(transparent)</a></h2>
<p><code>#[repr(transparent)]</code> can only be used on a struct or single-variant enum that has a single non-zero-sized field (there may be additional zero-sized fields). The effect is that the layout and ABI of the whole struct/enum is guaranteed to be the same as that one field.</p>
<blockquote>
<p>NOTE: There's a <code>transparent_unions</code> nightly feature to apply <code>repr(transparent)</code> to unions, but it hasn't been stabilized due to design concerns. See the <a href="https://github.com/rust-lang/rust/issues/60405">tracking issue</a> for more details.</p>
</blockquote>
<p>The goal is to make it possible to transmute between the single field and the struct/enum. An example of that is <a href="../std/cell/struct.UnsafeCell.html"><code>UnsafeCell</code></a>, which can be transmuted into the type it wraps (<a href="../std/cell/struct.UnsafeCell.html"><code>UnsafeCell</code></a> also uses the unstable <a href="https://github.com/rust-lang/rust/pull/68491">no_niche</a>, so its ABI is not actually guaranteed to be the same when nested in other types).</p>
<p>Also, passing the struct/enum through FFI where the inner field type is expected on the other side is guaranteed to work. In particular, this is necessary for <code>struct Foo(f32)</code> or <code>enum Foo { Bar(f32) }</code> to always have the same ABI as <code>f32</code>.</p>
<p>This repr is only considered part of the public ABI of a type if either the single field is <code>pub</code>, or if its layout is documented in prose. Otherwise, the layout should not be relied upon by other crates.</p>
<p>More details are in the <a href="https://github.com/rust-lang/rfcs/blob/master/text/1758-repr-transparent.md">RFC 1758</a> and the <a href="https://rust-lang.github.io/rfcs/2645-transparent-unions.html">RFC 2645</a>.</p>
<h2 id="repru-repri"><a class="header" href="#repru-repri">repr(u*), repr(i*)</a></h2>
<p>These specify the size and sign to make a fieldless enum. If the discriminant overflows the integer it has to fit in, it will produce a compile-time error. You can manually ask Rust to allow this by setting the overflowing element to explicitly be 0. However Rust will not allow you to create an enum where two variants have the same discriminant.</p>
<p>The term "fieldless enum" only means that the enum doesn't have data in any of its variants. A fieldless enum without a <code>repr</code> is still a Rust native type, and does not have a stable layout or representation. Adding a <code>repr(u*)</code>/<code>repr(i*)</code> causes it to be treated exactly like the specified integer type for layout purposes (except that the compiler will still exploit its knowledge of "invalid" values at this type to optimize enum layout, such as when this enum is wrapped in <code>Option</code>). Note that the function call ABI for these types is still in general unspecified, except that across <code>extern "C"</code> calls they are ABI-compatible with C enums of the same sign and size.</p>
<p>If the enum has fields, the effect is similar to the effect of <code>repr(C)</code> in that there is a defined layout of the type. This makes it possible to pass the enum to C code, or access the type's raw representation and directly manipulate its tag and fields. See <a href="https://github.com/rust-lang/rfcs/blob/master/text/2195-really-tagged-unions.md">the RFC</a> for details.</p>
<p>These <code>repr</code>s have no effect on a struct.</p>
<p>Adding an explicit <code>repr(u*)</code>, <code>repr(i*)</code>, or <code>repr(C)</code> to an enum with fields suppresses the null-pointer optimization, like:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::mem::size_of;
</span>enum MyOption&lt;T&gt; {
    Some(T),
    None,
}

#[repr(u8)]
enum MyReprOption&lt;T&gt; {
    Some(T),
    None,
}

assert_eq!(8, size_of::&lt;MyOption&lt;&amp;u16&gt;&gt;());
assert_eq!(16, size_of::&lt;MyReprOption&lt;&amp;u16&gt;&gt;());
<span class="boring">}</span></code></pre></pre>
<p>This optimization still applies to fieldless enums with an explicit <code>repr(u*)</code>, <code>repr(i*)</code>, or <code>repr(C)</code>.</p>
<h2 id="reprpacked-reprpackedn"><a class="header" href="#reprpacked-reprpackedn">repr(packed), repr(packed(n))</a></h2>
<p><code>repr(packed(n))</code> (where <code>n</code> is a power of two) forces the type to have an alignment of <em>at most</em> <code>n</code>. Most commonly used without an explicit <code>n</code>, <code>repr(packed)</code> is equivalent to <code>repr(packed(1))</code> which forces Rust to strip any padding, and only align the type to a byte. This may improve the memory footprint, but will likely have other negative side-effects.</p>
<p>In particular, most architectures <em>strongly</em> prefer values to be naturally aligned. This may mean that unaligned loads are penalized (x86), or even fault (some ARM chips). For simple cases like directly loading or storing a packed field, the compiler might be able to paper over alignment issues with shifts and masks. However if you take a reference to a packed field, it's unlikely that the compiler will be able to emit code to avoid an unaligned load.</p>
<p><a href="https://github.com/rust-lang/rust/issues/27060">As this can cause undefined behavior</a>, the lint has been implemented and it will become a hard error.</p>
<p><code>repr(packed)/repr(packed(n))</code> is not to be used lightly. Unless you have extreme requirements, this should not be used.</p>
<p>This repr is a modifier on <code>repr(C)</code> and <code>repr(Rust)</code>. For FFI compatibilty you most likely always want to be explicit: <code>repr(C, packed)</code>.</p>
<h2 id="repralignn"><a class="header" href="#repralignn">repr(align(n))</a></h2>
<p><code>repr(align(n))</code> (where <code>n</code> is a power of two) forces the type to have an alignment of <em>at least</em> <code>n</code>.</p>
<p>This enables several tricks, like making sure neighboring elements of an array never share the same cache line with each other (which may speed up certain kinds of concurrent code).</p>
<p>This is a modifier on <code>repr(C)</code> and <code>repr(Rust)</code>. It is incompatible with <code>repr(packed)</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="exotic-sizes.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ownership.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="exotic-sizes.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ownership.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
