<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>아토믹 - The Rustonomicon</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/nomicon";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/atomics.md`;
                    } else {
                        canonical_href = `${base}/${lang}/atomics.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="The Dark Arts of Advanced and Unsafe Rust Programming">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/nomicon.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rustonomicon</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="아토믹"><a class="header" href="#아토믹">아토믹</a></h1>
<p>러스트는 C++20의 아토믹 메모리 모델을 아주 노골적으로 그대로 상속받습니다. 이는 이 모델이 특별히 훌륭하거나 이해하기 쉬워서가 아닙니다. 실제로 이 모델은 꽤 복잡하며 <a href="http://plv.mpi-sws.org/c11comp/popl15.pdf">여러 결함</a>이 있는 것으로 알려져 있습니다. 오히려, 이는 _모든 사람_이 아토믹을 모델링하는 데 꽤 서툴다는 사실에 대한 실용적인 양보입니다. 적어도 우리는 C/C++ 메모리 모델을 둘러싼 기존 도구와 연구의 혜택을 누릴 수 있습니다. (이 모델은 종종 "C/C++11" 또는 그냥 "C11"이라고 불립니다. C는 C++ 메모리 모델을 그대로 복사하며, C++11은 이 모델의 첫 번째 버전이었으나 그 이후로 몇 가지 버그 수정이 있었습니다.)</p>
<p>이 책에서 모델을 완전히 설명하려고 하는 것은 거의 가망이 없습니다. 이는 실질적으로 제대로 이해하려면 책 한 권이 필요한, 광기를 유발하는 인과 관계 그래프로 정의되어 있습니다. 아주 상세한 내용을 원한다면 <a href="https://en.cppreference.com/w/cpp/atomic/memory_order">C++ 사양</a>을 확인해야 합니다. 그래도 우리는 기본 사항과 러스트 개발자가 직면하는 몇 가지 문제를 다루려고 노력할 것입니다.</p>
<p>C++ 메모리 모델은 근본적으로 우리가 원하는 의미론, 컴파일러가 원하는 최적화, 그리고 하드웨어가 원하는 일관성 없는 혼돈 사이의 간극을 메우려는 시도입니다. _우리_는 그저 프로그램을 작성하고 우리가 말한 그대로 실행되기를 원합니다. 하지만, 알다시피, 빠르게 말이죠. 정말 좋지 않을까요?</p>
<h2 id="컴파일러-재배치-compiler-reordering"><a class="header" href="#컴파일러-재배치-compiler-reordering">컴파일러 재배치 (Compiler Reordering)</a></h2>
<p>컴파일러는 근본적으로 데이터 의존성을 줄이고 죽은 코드를 제거하기 위해 온갖 종류의 복잡한 변환을 수행할 수 있기를 원합니다. 특히, 이벤트의 실제 순서를 근본적으로 바꾸거나 이벤트가 아예 발생하지 않게 만들 수도 있습니다! 우리가 다음과 같이 작성한다면:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">x = 1;
y = 3;
x = 2;</code></pre>
<p>컴파일러는 프로그램이 다음과 같이 동작하는 것이 가장 좋다고 결론 내릴 수 있습니다:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">x = 2;
y = 3;</code></pre>
<p>이는 이벤트의 순서를 뒤집고 하나의 이벤트를 완전히 제거했습니다. 단일 스레드 관점에서는 이를 전혀 관찰할 수 없습니다. 모든 문이 실행된 후 우리는 정확히 동일한 상태에 있게 됩니다. 하지만 프로그램이 멀티 스레드라면, 우리는 <code>y</code>가 할당되기 전에 <code>x</code>가 실제로 1로 할당되는 것에 의존하고 있었을지도 모릅니다. 우리는 컴파일러가 이러한 종류의 최적화를 수행할 수 있기를 바랍니다. 성능을 크게 향상시킬 수 있기 때문입니다. 반면에, 우리는 프로그램이 _우리가 말한 대로 수행_하는 것에 의존할 수 있기를 원하기도 합니다.</p>
<h2 id="하드웨어-재배치-hardware-reordering"><a class="header" href="#하드웨어-재배치-hardware-reordering">하드웨어 재배치 (Hardware Reordering)</a></h2>
<p>반면에, 컴파일러가 우리가 원하는 것을 완전히 이해하고 우리의 소원을 존중한다고 해도, 하드웨어가 우리를 곤경에 빠뜨릴 수 있습니다. 문제는 메모리 계층 구조의 형태로 CPU에서 발생합니다. 하드웨어 어딘가에 전역 공유 메모리 공간이 실제로 존재하지만, 각 CPU 코어의 관점에서 보면 그것은 <em>너무나 멀고</em> <em>너무나 느립니다</em>. 각 CPU는 차라리 로컬 데이터 캐시로 작업하고 싶어 하며, 실제로 캐시에 해당 메모리가 없을 때만 공유 메모리와 대화하는 모든 고통을 겪습니다.</p>
<p>결국 그것이 캐시의 존재 이유 아니겠습니까? 캐시에서 읽을 때마다 공유 메모리로 달려가서 변경되지 않았는지 다시 확인해야 한다면, 무슨 의미가 있을까요? 결론적으로 하드웨어는 <em>한</em> 스레드에서 어떤 순서로 발생한 이벤트가 <em>다른</em> 스레드에서도 같은 순서로 발생한다고 보장하지 않습니다. 이를 보장하려면, 우리는 CPU에게 조금 덜 똑똑하게 굴라고 말하는 특별한 명령을 내려야 합니다.</p>
<p>예를 들어, 우리가 컴파일러를 설득하여 다음 로직을 방출하게 했다고 가정해 봅시다:</p>
<pre><code class="language-text">initial state: x = 0, y = 1

THREAD 1        THREAD 2
y = 3;          if x == 1 {
x = 1;              y *= 2;
                }
</code></pre>
<p>이상적으로 이 프로그램은 2가지 가능한 최종 상태를 가집니다:</p>
<ul>
<li><code>y = 3</code>: (스레드 1이 완료되기 전에 스레드 2가 확인을 수행함)</li>
<li><code>y = 6</code>: (스레드 1이 완료된 후에 스레드 2가 확인을 수행함)</li>
</ul>
<p>하지만 하드웨어가 가능하게 하는 세 번째 잠재적 상태가 있습니다:</p>
<ul>
<li><code>y = 2</code>: (스레드 2가 <code>x = 1</code>은 보았지만 <code>y = 3</code>은 보지 못했고, 그 후 <code>y = 3</code>을 덮어씀)</li>
</ul>
<p>CPU 종류에 따라 서로 다른 보장을 제공한다는 점은 주목할 만합니다. 하드웨어를 두 가지 범주, 즉 강하게 정렬된(strongly-ordered) 것과 약하게 정렬된(weakly-ordered) 것으로 나누는 것이 일반적입니다. 가장 눈에 띄게 x86/64는 강력한 정렬 보장을 제공하는 반면, ARM은 약한 정렬 보장을 제공합니다. 이는 동시성 프로그래밍에 두 가지 결과를 가져옵니다:</p>
<ul>
<li>
<p>강하게 정렬된 하드웨어에서 더 강력한 보장을 요구하는 것은 저렴하거나 심지어 무료일 수 있습니다. 그들은 이미 무조건적으로 강력한 보장을 제공하기 때문입니다. 더 약한 보장은 약하게 정렬된 하드웨어에서만 성능 이득을 얻을 수 있습니다.</p>
</li>
<li>
<p>강하게 정렬된 하드웨어에서 너무 약한 보장을 요구하는 경우, 프로그램이 엄밀히 말해 틀렸음에도 불구하고 <em>우연히</em> 작동할 가능성이 더 높습니다. 가능하다면 동시성 알고리즘은 약하게 정렬된 하드웨어에서 테스트해야 합니다.</p>
</li>
</ul>
<h2 id="데이터-접근-data-accesses"><a class="header" href="#데이터-접근-data-accesses">데이터 접근 (Data Accesses)</a></h2>
<p>C++ 메모리 모델은 우리 프로그램의 _인과 관계(causality)_에 대해 이야기할 수 있게 함으로써 간극을 메우려고 시도합니다. 일반적으로 이는 프로그램의 부분들과 그것들을 실행하는 스레드들 사이에 <em>발생 전(happens before)</em> 관계를 확립하는 방식입니다. 이는 엄격한 발생 전 관계가 확립되지 않은 곳에서는 하드웨어와 컴파일러가 프로그램을 더 공격적으로 최적화할 수 있는 여지를 주지만, 관계가 확립된 곳에서는 더 주의하도록 강제합니다. 우리가 이러한 관계를 전달하는 방식은 _데이터 접근_과 _아토믹 접근_을 통해서입니다.</p>
<p>데이터 접근은 프로그래밍 세계의 기본입니다. 이들은 근본적으로 동기화되지 않으며 컴파일러는 이들을 공격적으로 최적화할 자유가 있습니다. 특히, 데이터 접근은 프로그램이 단일 스레드라는 가정하에 컴파일러에 의해 자유롭게 재배치될 수 있습니다. 하드웨어 또한 데이터 접근에서 이루어진 변경 사항을 다른 스레드에 원하는 만큼 게으르고 비일관적으로 전파할 자유가 있습니다. 가장 치명적인 것은, 데이터 접근이 바로 데이터 경쟁이 발생하는 원인이라는 점입니다. 데이터 접근은 하드웨어와 컴파일러에게는 매우 친화적이지만, 우리가 보았듯이 동기화된 코드를 작성하려고 할 때 <em>끔찍한</em> 의미론을 제공합니다. 사실, 끔찍하다는 표현도 부족합니다.</p>
<p><strong>데이터 접근만을 사용하여 올바른 동기화 코드를 작성하는 것은 말 그대로 불가능합니다.</strong></p>
<p>아토믹 접근은 우리 프로그램이 멀티 스레드임을 하드웨어와 컴파일러에 알리는 방법입니다. 각 아토믹 접근은 다른 접근들과 어떤 종류의 관계를 맺는지 지정하는 _정렬(ordering)_로 표시될 수 있습니다. 실제로는, 이것은 컴파일러와 하드웨어에게 그들이 할 수 <em>없는</em> 특정 작업들을 말해주는 것으로 귀결됩니다. 컴파일러의 경우, 이는 주로 명령어의 재배치를 중심으로 돌아갑니다. 하드웨어의 경우, 이는 주로 쓰기가 다른 스레드에 전파되는 방식을 중심으로 돌아갑니다. 러스트가 노출하는 정렬 집합은 다음과 같습니다:</p>
<ul>
<li>순차적 일관성 (Sequentially Consistent, SeqCst)</li>
<li>릴리스 (Release)</li>
<li>어콰이어 (Acquire)</li>
<li>릴랙스드 (Relaxed)</li>
</ul>
<p>(참고: 우리는 C++의 <em>consume</em> 정렬을 명시적으로 노출하지 않습니다)</p>
<p>TODO: 부정적 추론 vs 긍정적 추론? TODO: "동기화하는 것을 잊을 수 없음"</p>
<h2 id="순차적-일관성-sequentially-consistent"><a class="header" href="#순차적-일관성-sequentially-consistent">순차적 일관성 (Sequentially Consistent)</a></h2>
<p>순차적 일관성(Sequentially Consistent)은 가장 강력한 정렬로, 다른 모든 정렬의 제약 조건을 포함합니다. 직관적으로, 순차적으로 일관된 작업은 재배치될 수 없습니다. <code>SeqCst</code> 접근 전후에 발생하는 한 스레드의 모든 접근은 그 전후에 머무릅니다. 순차적으로 일관된 아토믹과 데이터 접근만을 사용하는 데이터 경쟁 없는 프로그램은 모든 스레드가 동의하는 단일 전역 실행 순서가 있다는 아주 좋은 속성을 가집니다. 이 실행은 추론하기에도 매우 좋습니다. 각 스레드의 개별 실행을 인터리빙(interleaving)한 것일 뿐이기 때문입니다. 더 약한 아토믹 정렬을 사용하기 시작하면 이 속성은 유지되지 않습니다.</p>
<p>순차적 일관성의 상대적인 개발자 친화성은 공짜가 아닙니다. 강하게 정렬된 플랫폼에서도 순차적 일관성은 메모리 펜스(memory fence) 방출을 수반합니다.</p>
<p>실제로는 프로그램의 정확성을 위해 순차적 일관성이 필요한 경우는 드뭅니다. 하지만 다른 메모리 순서에 대해 확신이 없다면 순차적 일관성이 확실히 올바른 선택입니다. 프로그램이 필요 이상으로 조금 느리게 실행되는 것이 잘못 실행되는 것보다 확실히 낫습니다! 나중에 아토믹 연산을 더 약한 일관성으로 다운그레이드하는 것도 기계적으로 매우 간단합니다. 그냥 <code>SeqCst</code>를 <code>Relaxed</code>로 바꾸면 끝입니다! 물론, 이 변환이 _올바르다_는 것을 증명하는 것은 완전히 다른 문제입니다.</p>
<h2 id="어콰이어-릴리스-acquire-release"><a class="header" href="#어콰이어-릴리스-acquire-release">어콰이어-릴리스 (Acquire-Release)</a></h2>
<p>어콰이어(Acquire)와 릴리스(Release)는 주로 쌍을 이루도록 의도되었습니다. 그들의 이름이 사용 사례를 암시합니다. 즉, 잠금을 획득(acquire)하고 해제(release)하며, 임계 영역(critical section)이 겹치지 않도록 보장하는 데 완벽하게 적합합니다.</p>
<p>직관적으로, 어콰이어 접근은 그 이후의 모든 접근이 그 이후에 머무르도록 보장합니다. 하지만 어콰이어 이전에 발생하는 작업은 자유롭게 재배치되어 그 이후에 발생할 수 있습니다. 마찬가지로, 릴리스 접근은 그 이전의 모든 접근이 그 이전에 머무르도록 보장합니다. 하지만 릴리스 이후에 발생하는 작업은 자유롭게 재배치되어 그 이전에 발생할 수 있습니다.</p>
<p>스레드 A가 메모리의 한 위치를 릴리스하고, 그 후 스레드 B가 메모리의 <em>동일한</em> 위치를 어콰이어하면, 인과 관계가 성립됩니다. A의 릴리스 이전에 발생한 모든 쓰기(비원자적 및 릴랙스드 아토믹 쓰기 포함)는 B가 어콰이어한 후에 관찰됩니다. 하지만 다른 어떤 스레드와도 인과 관계가 성립하지 않습니다. 마찬가지로, A와 B가 메모리의 <em>서로 다른</em> 위치에 접근한다면 인과 관계는 성립하지 않습니다.</p>
<p>따라서 릴리스-어콰이어의 기본적인 사용법은 간단합니다. 임계 영역을 시작하기 위해 메모리 위치를 어콰이어하고, 끝내기 위해 해당 위치를 릴리스합니다. 예를 들어, 간단한 스핀락은 다음과 같을 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::Arc;
use std::sync::atomic::{AtomicBool, Ordering};
use std::thread;

fn main() {
    let lock = Arc::new(AtomicBool::new(false)); // 값은 "잠겨 있습니까?"에 답합니다.

    // ... 어떻게든 스레드들에게 잠금을 분배 ...

    // 값을 true로 설정하여 잠금 획득을 시도합니다.
    while lock.compare_and_swap(false, true, Ordering::Acquire) { }
    // 루프를 빠져나왔으므로, 성공적으로 잠금을 획득했습니다!

    // ... 무시무시한 데이터 접근 ...

    // 좋아, 다 끝났으니 잠금을 해제합니다.
    lock.store(false, Ordering::Release);
}</code></pre></pre>
<p>강하게 정렬된 플랫폼에서 대부분의 접근은 릴리스 또는 어콰이어 의미론을 가지므로, 릴리스와 어콰이어는 종종 완전히 무료입니다. 약하게 정렬된 플랫폼에서는 그렇지 않습니다.</p>
<h2 id="릴랙스드-relaxed"><a class="header" href="#릴랙스드-relaxed">릴랙스드 (Relaxed)</a></h2>
<p>릴랙스드(Relaxed) 접근은 절대적으로 가장 약합니다. 자유롭게 재배치될 수 있으며 발생 전 관계를 제공하지 않습니다. 그럼에도 불구하고, 릴랙스드 연산은 여전히 원자적(atomic)입니다. 즉, 데이터 접근으로 간주되지 않으며 이에 대해 수행되는 모든 읽기-수정-쓰기 작업은 원자적으로 발생합니다. 릴랙스드 연산은 반드시 일어나기를 원하지만 그 외에는 특별히 신경 쓰지 않는 작업에 적합합니다. 예를 들어, 카운터를 사용하여 다른 접근을 동기화하지 않는다면 릴랙스드 <code>fetch_add</code>를 사용하여 여러 스레드에서 안전하게 카운터를 증가시킬 수 있습니다.</p>
<p>강하게 정렬된 플랫폼에서는 어차피 릴리스-어콰이어 의미론을 제공하는 경우가 많으므로 연산을 릴랙스드로 만드는 이점은 거의 없습니다. 하지만 약하게 정렬된 플랫폼에서는 릴랙스드 연산이 더 저렴할 수 있습니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="send-and-sync.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="vec/vec.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="send-and-sync.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="vec/vec.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
