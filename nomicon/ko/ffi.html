<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>FFI - The Rustonomicon</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/nomicon";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ffi.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ffi.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="The Dark Arts of Advanced and Unsafe Rust Programming">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/nomicon.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rustonomicon</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="외부-함수-인터페이스-foreign-function-interface-ffi"><a class="header" href="#외부-함수-인터페이스-foreign-function-interface-ffi">외부 함수 인터페이스 (Foreign Function Interface, FFI)</a></h1>
<h2 id="소개"><a class="header" href="#소개">소개</a></h2>
<p>이 가이드는 외부 코드용 바인딩 작성을 소개하기 위해 <a href="https://github.com/google/snappy">snappy</a> 압축/해제 라이브러리를 사용할 것입니다. 러스트는 현재 C++ 라이브러리를 직접 호출할 수 없지만, snappy는 (<a href="https://github.com/google/snappy/blob/master/snappy-c.h"><code>snappy-c.h</code></a>에 문서화된) C 인터페이스를 포함하고 있습니다.</p>
<h2 id="libc에-대한-참고-사항"><a class="header" href="#libc에-대한-참고-사항">libc에 대한 참고 사항</a></h2>
<p>이 예제들 중 다수는 다른 기능들 외에도 C 타입들에 대한 다양한 타입 정의를 제공하는 <a href="https://crates.io/crates/libc"><code>libc</code> 크레이트</a>를 사용합니다. 직접 이 예제들을 실행해 보려면 <code>Cargo.toml</code>에 <code>libc</code>를 추가해야 합니다:</p>
<pre><code class="language-toml">[dependencies]
libc = "0.2.0"
</code></pre>
<h2 id="외부-함수-호출하기"><a class="header" href="#외부-함수-호출하기">외부 함수 호출하기</a></h2>
<p>다음은 snappy가 설치되어 있다면 컴파일될, 외부 함수를 호출하는 최소한의 예제입니다:</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore">use libc::size_t;

#[link(name = "snappy")]
extern {
    fn snappy_max_compressed_length(source_length: size_t) -&gt; size_t;
}

fn main() {
    let x = unsafe { snappy_max_compressed_length(100) };
    println!("100바이트 버퍼의 최대 압축 길이: {}", x);
}</code></pre>
<p><code>extern</code> 블록은 외부 라이브러리에 있는 함수 시그니처들의 목록이며, 이 경우에는 플랫폼의 C ABI를 사용합니다. <code>#[link(...)]</code> 속성은 링커에게 snappy 라이브러리와 링크하여 심볼들이 해결되도록 지시하는 데 사용됩니다.</p>
<p>외부 함수들은 비안전(unsafe)한 것으로 간주되므로, 그 호출은 그 안에 포함된 모든 것이 정말로 안전하다는 컴파일러에 대한 약속으로서 <code>unsafe {}</code>로 감싸야 합니다. C 라이브러리들은 종종 스레드 안전하지 않은 인터페이스를 노출하며, 포인터 인자를 받는 거의 모든 함수는 포인터가 매달려 있을(dangling) 수 있으므로 모든 가능한 입력에 대해 유효하지 않습니다. 또한 원시 포인터는 러스트의 안전한 메모리 모델을 벗어납니다.</p>
<p>외부 함수에 대한 인자 타입을 선언할 때, 러스트 컴파일러는 선언이 올바른지 확인할 수 없습니다. 따라서 이를 올바르게 지정하는 것은 런타임에 바인딩이 올바르게 유지되도록 하는 일의 일부입니다.</p>
<p><code>extern</code> 블록을 확장하여 전체 snappy API를 다룰 수 있습니다:</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore">use libc::{c_int, size_t};

#[link(name = "snappy")]
extern {
    fn snappy_compress(input: *const u8,
                       input_length: size_t,
                       compressed: *mut u8,
                       compressed_length: *mut size_t) -&gt; c_int;
    fn snappy_uncompress(compressed: *const u8,
                         compressed_length: size_t,
                         uncompressed: *mut u8,
                         uncompressed_length: *mut size_t) -&gt; c_int;
    fn snappy_max_compressed_length(source_length: size_t) -&gt; size_t;
    fn snappy_uncompressed_length(compressed: *const u8,
                                  compressed_length: size_t,
                                  result: *mut size_t) -&gt; c_int;
    fn snappy_validate_compressed_buffer(compressed: *const u8,
                                         compressed_length: size_t) -&gt; c_int;
}
<span class="boring">fn main() {}</span></code></pre>
<h2 id="안전한-인터페이스-만들기"><a class="header" href="#안전한-인터페이스-만들기">안전한 인터페이스 만들기</a></h2>
<p>메모리 안전성을 제공하고 벡터와 같은 고수준 개념을 활용하기 위해 원시 C API를 래핑할 필요가 있습니다. 라이브러리는 안전한 고수준 인터페이스만을 노출하고 비안전한 내부 세부 사항은 숨기기로 선택할 수 있습니다.</p>
<p>버퍼를 기대하는 함수들을 래핑하려면 러스트 벡터를 메모리 포인터로 조작하기 위해 <code>slice::raw</code> 모듈을 사용해야 합니다. 러스트의 벡터는 연속된 메모리 블록임이 보장됩니다. 길이는 현재 포함된 요소의 수이고, 용량은 할당된 메모리에 들어갈 수 있는 총 요소 수입니다. 길이는 용량보다 작거나 같습니다.</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore"><span class="boring">use libc::{c_int, size_t};
</span><span class="boring">unsafe fn snappy_validate_compressed_buffer(_: *const u8, _: size_t) -&gt; c_int { 0 }
</span><span class="boring">fn main() {}
</span>pub fn validate_compressed_buffer(src: &amp;[u8]) -&gt; bool {
    unsafe {
        snappy_validate_compressed_buffer(src.as_ptr(), src.len() as size_t) == 0
    }
}</code></pre>
<p>위의 <code>validate_compressed_buffer</code> 래퍼는 <code>unsafe</code> 블록을 사용하지만, 함수 시그니처에서 <code>unsafe</code>를 뺌으로써 모든 입력에 대해 호출이 안전하다는 것을 보장합니다.</p>
<p><code>snappy_compress</code>와 <code>snappy_uncompress</code> 함수는 출력물을 담을 버퍼도 할당해야 하므로 더 복잡합니다.</p>
<p><code>snappy_max_compressed_length</code> 함수는 압축된 출력을 담기에 충분한 최대 용량을 가진 벡터를 할당하는 데 사용될 수 있습니다. 그런 다음 이 벡터는 <code>snappy_compress</code> 함수에 출력 매개변수로 전달될 수 있습니다. 또한 압축 후 실제 길이를 가져와서 벡터의 길이를 설정하기 위한 출력 매개변수도 전달됩니다.</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore"><span class="boring">use libc::{size_t, c_int};
</span><span class="boring">unsafe fn snappy_compress(a: *const u8, b: size_t, c: *mut u8,
</span><span class="boring">                          d: *mut size_t) -&gt; c_int { 0 }
</span><span class="boring">unsafe fn snappy_max_compressed_length(a: size_t) -&gt; size_t { a }
</span><span class="boring">fn main() {}
</span>pub fn compress(src: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
    unsafe {
        let srclen = src.len() as size_t;
        let psrc = src.as_ptr();

        let mut dstlen = snappy_max_compressed_length(srclen);
        let mut dst = Vec::with_capacity(dstlen as usize);
        let pdst = dst.as_mut_ptr();

        snappy_compress(psrc, srclen, pdst, &amp;mut dstlen);
        dst.set_len(dstlen as usize);
        dst
    }
}</code></pre>
<p>압축 해제도 비슷합니다. snappy는 압축 형식의 일부로 압축되지 않은 크기를 저장하며, <code>snappy_uncompressed_length</code>는 필요한 정확한 버퍼 크기를 가져올 것이기 때문입니다.</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore"><span class="boring">use libc::{size_t, c_int};
</span><span class="boring">unsafe fn snappy_uncompress(compressed: *const u8,
</span><span class="boring">                            compressed_length: size_t,
</span><span class="boring">                            uncompressed: *mut u8,
</span><span class="boring">                            uncompressed_length: *mut size_t) -&gt; c_int { 0 }
</span><span class="boring">unsafe fn snappy_uncompressed_length(compressed: *const u8,
</span><span class="boring">                                     compressed_length: size_t,
</span><span class="boring">                                     result: *mut size_t) -&gt; c_int { 0 }
</span><span class="boring">fn main() {}
</span>pub fn uncompress(src: &amp;[u8]) -&gt; Option&lt;Vec&lt;u8&gt;&gt; {
    unsafe {
        let srclen = src.len() as size_t;
        let psrc = src.as_ptr();

        let mut dstlen: size_t = 0;
        snappy_uncompressed_length(psrc, srclen, &amp;mut dstlen);

        let mut dst = Vec::with_capacity(dstlen as usize);
        let pdst = dst.as_mut_ptr();

        if snappy_uncompress(psrc, srclen, pdst, &amp;mut dstlen) == 0 {
            dst.set_len(dstlen as usize);
            Some(dst)
        } else {
            None // SNAPPY_INVALID_INPUT
        }
    }
}</code></pre>
<p>그 다음, 이것들을 어떻게 사용하는지 보여주기 위한 테스트를 추가할 수 있습니다.</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore"><span class="boring">use libc::{c_int, size_t};
</span><span class="boring">unsafe fn snappy_compress(input: *const u8,
</span><span class="boring">                          input_length: size_t,
</span><span class="boring">                          compressed: *mut u8,
</span><span class="boring">                          compressed_length: *mut size_t)
</span><span class="boring">                          -&gt; c_int { 0 }
</span><span class="boring">unsafe fn snappy_uncompress(compressed: *const u8,
</span><span class="boring">                            compressed_length: size_t,
</span><span class="boring">                            uncompressed: *mut u8,
</span><span class="boring">                            uncompressed_length: *mut size_t)
</span><span class="boring">                            -&gt; c_int { 0 }
</span><span class="boring">unsafe fn snappy_max_compressed_length(source_length: size_t) -&gt; size_t { 0 }
</span><span class="boring">unsafe fn snappy_uncompressed_length(compressed: *const u8,
</span><span class="boring">                                     compressed_length: size_t,
</span><span class="boring">                                     result: *mut size_t)
</span><span class="boring">                                     -&gt; c_int { 0 }
</span><span class="boring">unsafe fn snappy_validate_compressed_buffer(compressed: *const u8,
</span><span class="boring">                                            compressed_length: size_t)
</span><span class="boring">                                            -&gt; c_int { 0 }
</span><span class="boring">fn main() { }
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn valid() {
        let d = vec![0xde, 0xad, 0xd0, 0x0d];
        let c: &amp;[u8] = &amp;compress(&amp;d);
        assert!(validate_compressed_buffer(c));
        assert!(uncompress(c) == Some(d));
    }

    #[test]
    fn invalid() {
        let d = vec![0, 0, 0, 0];
        assert!(!validate_compressed_buffer(&amp;d));
        assert!(uncompress(&amp;d).is_none());
    }

    #[test]
    fn empty() {
        let d = vec![];
        assert!(!validate_compressed_buffer(&amp;d));
        assert!(uncompress(&amp;d).is_none());
        let c = compress(&amp;d);
        assert!(validate_compressed_buffer(&amp;c));
        assert!(uncompress(&amp;c) == Some(d));
    }
}</code></pre>
<h2 id="소멸자"><a class="header" href="#소멸자">소멸자</a></h2>
<p>외부 라이브러리들은 종종 자원의 소유권을 호출한 코드에 넘겨줍니다. 이런 일이 발생하면, 우리는 안전을 제공하고 이러한 자원들의 해제를 보장하기 위해(특히 패닉이 발생한 경우) 러스트의 소멸자를 사용해야 합니다.</p>
<p>소멸자에 대한 자세한 내용은 <a href="../std/ops/trait.Drop.html">Drop 트레잇</a>을 참조하십시오.</p>
<h2 id="c에서-러스트-코드-호출하기"><a class="header" href="#c에서-러스트-코드-호출하기">C에서 러스트 코드 호출하기</a></h2>
<p>러스트 코드를 C에서 호출할 수 있는 방식으로 컴파일하고 싶을 수 있습니다. 이는 꽤 쉽지만, 몇 가지가 필요합니다.</p>
<h3 id="러스트-측"><a class="header" href="#러스트-측">러스트 측</a></h3>
<p>먼저, <code>rust_from_c</code>라는 이름의 라이브러리 크레이트가 있다고 가정합니다. <code>lib.rs</code>에는 다음과 같은 러스트 코드가 있어야 합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021">#[no_mangle]
pub extern "C" fn hello_from_rust() {
    println!("러스트에서 인사드립니다!");
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>"<a href="ffi.html#foreign-calling-conventions">외부 호출 규약(Foreign Calling Conventions)</a>" 섹션에서 논의할 것과 같습니다. <code>no_mangle</code> 속성은 러스트의 이름 맹글링(name mangling)을 꺼서, 링크할 수 있는 잘 정의된 심볼을 갖게 합니다."<a href="ffi.html#foreign-calling-conventions">외부 호출 규약(Foreign Calling Conventions)</a>" 섹션에서 논의할 것과 같습니다. <code>no_mangle</code> 속성은 러스트의 이름 맹글링(name mangling)을 꺼서, 링크할 수 있는 잘 정의된 심볼을 갖게 합니다.</p>
<p>그 다음, C에서 호출할 수 있는 공유 라이브러리로 러스트 코드를 컴파일하려면 <code>Cargo.toml</code>에 다음을 추가하십시오:</p>
<pre><code class="language-toml">[lib]
crate-type = ["cdylib"]
</code></pre>
<p>(참고: <code>staticlib</code> 크레이트 타입을 사용할 수도 있지만, 일부 링크 플래그를 조정해야 합니다.)(참고: <code>staticlib</code> 크레이트 타입을 사용할 수도 있지만, 일부 링크 플래그를 조정해야 합니다.)</p>
<p><code>cargo build</code>를 실행하면 러스트 측 준비는 끝납니다.</p>
<h3 id="c-측"><a class="header" href="#c-측">C 측</a></h3>
<p><code>hello_from_rust</code> 함수를 호출할 C 파일을 만들고 <code>gcc</code>로 컴파일할 것입니다.</p>
<p>C 파일은 다음과 같아야 합니다:</p>
<pre><code class="language-c">extern void hello_from_rust();

int main(void) {
    hello_from_rust();
    return 0;
}
</code></pre>
<p>파일 이름을 <code>call_rust.c</code>로 짓고 크레이트 루트에 둡니다. 컴파일을 위해 다음을 실행하십시오:</p>
<pre><code class="language-sh">gcc call_rust.c -o call_rust -lrust_from_c -L./target/debug
</code></pre>
<p><code>-l</code>과 <code>-L</code>은 gcc에게 우리의 러스트 라이브러리를 찾을 위치를 알려줍니다.</p>
<p>마지막으로, <code>LD_LIBRARY_PATH</code>를 지정하여 C에서 러스트 코드를 호출할 수 있습니다:</p>
<pre><code class="language-sh">$ LD_LIBRARY_PATH=./target/debug ./call_rust
Hello from Rust!
</code></pre>
<p>이게 전부입니다! 더 실질적인 예제는 <a href="https://github.com/eqrion/cbindgen"><code>cbindgen</code></a>을 확인해 보십시오.</p>
<h2 id="c-코드에서-러스트-함수로의-콜백"><a class="header" href="#c-코드에서-러스트-함수로의-콜백">C 코드에서 러스트 함수로의 콜백</a></h2>
<p>일부 외부 라이브러리는 현재 상태나 중간 데이터를 호출자에게 보고하기 위해 콜백 사용을 요구합니다. 러스트에서 정의된 함수를 외부 라이브러리에 전달하는 것이 가능합니다. 이를 위한 요구 사항은 콜백 함수가 C 코드에서 호출 가능하도록 올바른 호출 규약과 함께 <code>extern</code>으로 표시되어야 한다는 것입니다.</p>
<p>그 후 콜백 함수는 등록 호출을 통해 C 라이브러리로 전달될 수 있으며, 그 후 거기에서 호출될 수 있습니다.</p>
<p>기본적인 예제는 다음과 같습니다:</p>
<p>러스트 코드:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021">extern fn callback(a: i32) {
    println!("C에서 값 {0}과(와) 함께 호출되었습니다", a);
}

#[link(name = "extlib")]
extern {
   fn register_callback(cb: extern fn(i32)) -&gt; i32;
   fn trigger_callback();
}

fn main() {
    unsafe {
        register_callback(callback);
        trigger_callback(); // 콜백을 트리거합니다.
    }
}</code></pre></pre>
<p>C 코드:</p>
<pre><code class="language-c">typedef void (*rust_callback)(int32_t);
rust_callback cb;

int32_t register_callback(rust_callback callback) {
    cb = callback;
    return 1;
}

void trigger_callback() {
  cb(7); // 러스트의 callback(7)을 호출할 것입니다.
}
</code></pre>
<p>이 예제에서 러스트의 <code>main()</code>은 C의 <code>trigger_callback()</code>을 호출하고, 이는 다시 러스트의 <code>callback()</code>을 호출할 것입니다.</p>
<h2 id="러스트-객체를-대상으로-하는-콜백"><a class="header" href="#러스트-객체를-대상으로-하는-콜백">러스트 객체를 대상으로 하는 콜백</a></h2>
<p>앞의 예제는 C 코드에서 전역 함수를 호출하는 방법을 보여주었습니다. 하지만 종종 특정 러스트 객체를 대상으로 콜백을 호출하고 싶을 때가 있습니다. 이는 각각의 C 객체에 대한 래퍼를 나타내는 객체일 수 있습니다.</p>
<p>이는 객체에 대한 원시 포인터를 C 라이브러리에 전달함으로써 달성할 수 있습니다. 그러면 C 라이브러리는 알림에 러스트 객체에 대한 포인터를 포함할 수 있습니다. 이를 통해 콜백이 참조된 러스트 객체에 비안전하게 접근할 수 있게 됩니다.</p>
<p>러스트 코드:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021">struct RustObject {
    a: i32,
    // 다른 멤버들...
}

extern "C" fn callback(target: *mut RustObject, a: i32) {
    println!("C에서 값 {0}과(와) 함께 호출되었습니다", a);
    unsafe {
        // 콜백으로부터 받은 값으로 RustObject의 값을 업데이트합니다:
        (*target).a = a;
    }
}

#[link(name = "extlib")]
extern {
   fn register_callback(target: *mut RustObject,
                        cb: extern fn(*mut RustObject, i32)) -&gt; i32;
   fn trigger_callback();
}

fn main() {
    // 콜백에서 참조될 객체를 생성합니다:
    let mut rust_object = Box::new(RustObject { a: 5 });

    unsafe {
        register_callback(&amp;mut *rust_object, callback);
        trigger_callback();
    }
}</code></pre></pre>
<p>C 코드:</p>
<pre><code class="language-c">typedef void (*rust_callback)(void*, int32_t);
void* cb_target;
rust_callback cb;

int32_t register_callback(void* callback_target, rust_callback callback) {
    cb_target = callback_target;
    cb = callback;
    return 1;
}

void trigger_callback() {
  cb(cb_target, 7); // 러스트의 callback(&amp;rustObject, 7)을 호출할 것입니다.
}
</code></pre>
<h2 id="비동기-콜백"><a class="header" href="#비동기-콜백">비동기 콜백</a></h2>
<p>이전에 주어진 예제들에서 콜백은 외부 C 라이브러리에 대한 함수 호출의 직접적인 반응으로 호출됩니다. 콜백 실행을 위해 현재 스레드의 제어권이 러스트에서 C로, 다시 러스트로 전환되지만, 결국 콜백은 콜백을 트리거한 함수를 호출한 동일한 스레드에서 실행됩니다.</p>
<p>외부 라이브러리가 자체 스레드를 생성하고 거기서 콜백을 호출하면 상황은 더 복잡해집니다. 이런 경우 콜백 내부에서 러스트 데이터 구조에 접근하는 것은 특히 비안전하므로 적절한 동기화 메커니즘을 사용해야 합니다. 뮤텍스와 같은 고전적인 동기화 메커니즘 외에도, 러스트에서는 채널(<code>std::sync::mpsc</code>)을 사용하여 콜백을 호출한 C 스레드에서 러스트 스레드로 데이터를 전달하는 방법이 있습니다.</p>
<p>비동기 콜백이 러스트 주소 공간의 특정 객체를 대상으로 한다면, 해당 러스트 객체가 파괴된 후에는 C 라이브러리가 더 이상 콜백을 수행하지 않는 것이 절대적으로 필요합니다. 이는 객체의 소멸자에서 콜백 등록을 해제하고, 등록 해제 후에는 어떤 콜백도 수행되지 않음을 보장하도록 라이브러리를 설계함으로써 달성할 수 있습니다.비동기 콜백이 러스트 주소 공간의 특정 객체를 대상으로 한다면, 해당 러스트 객체가 파괴된 후에는 C 라이브러리가 더 이상 콜백을 수행하지 않는 것이 절대적으로 필요합니다. 이는 객체의 소멸자에서 콜백 등록을 해제하고, 등록 해제 후에는 어떤 콜백도 수행되지 않음을 보장하도록 라이브러리를 설계함으로써 달성할 수 있습니다.</p>
<h2 id="링킹-linking"><a class="header" href="#링킹-linking">링킹 (Linking)</a></h2>
<p><code>extern</code> 블록의 <code>link</code> 속성은 rustc에게 네이티브 라이브러리와 링크하는 방법을 지시하는 기본적인 빌딩 블록을 제공합니다. 오늘날 허용되는 link 속성 형식은 두 가지입니다:</p>
<ul>
<li><code>#[link(name = "foo")]</code></li>
<li><code>#[link(name = "foo", kind = "bar")]</code></li>
</ul>
<p>이 두 경우 모두 <code>foo</code>는 링크하려는 네이티브 라이브러리의 이름이며, 두 번째 경우의 <code>bar</code>는 컴파일러가 링크하려는 네이티브 라이브러리의 타입입니다. 현재 세 가지 종류의 네이티브 라이브러리가 알려져 있습니다:</p>
<ul>
<li>동적 - <code>#[link(name = "readline")]</code></li>
<li>정적 - <code>#[link(name = "my_build_dependency", kind = "static")]</code></li>
<li>프레임워크 - <code>#[link(name = "CoreFoundation", kind = "framework")]</code></li>
</ul>
<p>프레임워크는 macOS 타겟에서만 사용할 수 있음에 유의하십시오.</p>
<p>서로 다른 <code>kind</code> 값들은 네이티브 라이브러리가 링킹에 어떻게 참여하는지를 구분하기 위한 것입니다. 링킹 관점에서 러스트 컴파일러는 두 가지 종류의 아티팩트를 생성합니다: 부분적(rlib/staticlib) 아티팩트와 최종적(dylib/binary) 아티팩트입니다. 네이티브 동적 라이브러리와 프레임워크 의존성은 최종 아티팩트 경계까지 전파되지만, 정적 라이브러리 의존성은 전혀 전파되지 않습니다. 정적 라이브러리는 이어지는 아티팩트에 직접 통합되기 때문입니다.</p>
<p>이 모델이 어떻게 사용될 수 있는지 몇 가지 예시는 다음과 같습니다:</p>
<ul>
<li>
<p>네이티브 빌드 의존성. 때때로 러스트 코드를 작성할 때 C/C++ 글루(glue) 코드가 필요하지만, C/C++ 코드를 라이브러리 형식으로 배포하는 것이 부담스러울 수 있습니다. 이런 경우 코드는 <code>libfoo.a</code>로 아카이브되고, 러스트 크레이트는 <code>#[link(name = "foo", kind = "static")]</code>를 통해 의존성을 선언할 것입니다.</p>
<p>크레이트의 출력 형식에 관계없이 네이티브 정적 라이브러리가 출력물에 포함되므로, 네이티브 정적 라이브러리를 별도로 배포할 필요가 없습니다.</p>
</li>
<li>
<p>일반적인 동적 의존성. (<code>readline</code>과 같은) 일반적인 시스템 라이브러리는 수많은 시스템에서 사용할 수 있으며, 종종 이러한 라이브러리의 정적 복사본을 찾을 수 없습니다. 러스트 크레이트에 이러한 의존성이 포함되면 (rlib과 같은) 부분적 타겟은 라이브러리에 링크되지 않지만, rlib이 최종 타겟(예: 바이너리)에 포함될 때 네이티브 라이브러리가 링크됩니다.</p>
</li>
</ul>
<p>macOS에서 프레임워크는 동적 라이브러리와 동일한 의미론으로 동작합니다.</p>
<h2 id="비안전-블록-unsafe-blocks"><a class="header" href="#비안전-블록-unsafe-blocks">비안전 블록 (Unsafe blocks)</a></h2>
<p>원시 포인터 역참조나 비안전(unsafe)으로 표시된 함수 호출과 같은 일부 연산은 비안전 블록 내부에서만 허용됩니다. 비안전 블록은 비안전성을 격리하며, 비안전성이 블록 밖으로 새어 나오지 않는다는 컴파일러에 대한 약속입니다.</p>
<p>반면 비안전 함수는 이를 세상에 알립니다. 비안전 함수는 다음과 같이 작성됩니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn kaboom(ptr: *const i32) -&gt; i32 { *ptr }
<span class="boring">}</span></code></pre></pre>
<p>이 함수는 <code>unsafe</code> 블록이나 다른 <code>unsafe</code> 함수 내에서만 호출될 수 있습니다.</p>
<h2 id="외부-전역-변수-접근하기"><a class="header" href="#외부-전역-변수-접근하기">외부 전역 변수 접근하기</a></h2>
<p>외부 API는 전역 상태를 추적하는 등의 작업을 수행하는 전역 변수를 내보내는 경우가 많습니다. 이러한 변수에 접근하려면, <code>extern</code> 블록 내에서 <code>static</code> 키워드로 선언해야 합니다:</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore">#[link(name = "readline")]
extern {
    static rl_readline_version: libc::c_int;
}

fn main() {
    println!("readline 버전 {}이(가) 설치되어 있습니다.",
             unsafe { rl_readline_version as i32 });
}</code></pre>
<p>또는 외부 인터페이스가 제공하는 전역 상태를 변경해야 할 수도 있습니다. 이를 위해 <code>mut</code>으로 정적 변수(statics)를 선언하여 변경할 수 있게 할 수 있습니다.</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore">use std::ffi::CString;
use std::ptr;

#[link(name = "readline")]
extern {
    static mut rl_prompt: *const libc::c_char;
}

fn main() {
    let prompt = CString::new("[my-awesome-shell] $").unwrap();
    unsafe {
        rl_prompt = prompt.as_ptr();

        println!("{:?}", rl_prompt);

        rl_prompt = ptr::null();
    }
}</code></pre>
<p><code>static mut</code>과의 모든 상호작용(읽기 및 쓰기 모두)은 안전하지 않다는 점에 유의하십시오. 전역 가변 상태를 다루는 것은 상당한 주의를 요합니다.</p>
<h2 id="외부-호출-규약-foreign-calling-conventions"><a class="header" href="#외부-호출-규약-foreign-calling-conventions">외부 호출 규약 (Foreign calling conventions)</a></h2>
<p>대부분의 외부 코드는 C ABI를 노출하며, 러스트는 외부 함수를 호출할 때 기본적으로 플랫폼의 C 호출 규약을 사용합니다. 일부 외부 함수, 특히 윈도우 API는 다른 호출 규약을 사용합니다. 러스트는 어떤 규약을 사용할지 컴파일러에게 알려주는 방법을 제공합니다:</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore">#[cfg(all(target_os = "win32", target_arch = "x86"))]
#[link(name = "kernel32")]
#[allow(non_snake_case)]
extern "stdcall" {
    fn SetEnvironmentVariableA(n: *const u8, v: *const u8) -&gt; libc::c_int;
}
<span class="boring">fn main() { }</span></code></pre>
<p>이는 전체 <code>extern</code> 블록에 적용됩니다. 지원되는 ABI 제약 조건 목록은 다음과 같습니다:</p>
<ul>
<li><code>stdcall</code></li>
<li><code>aapcs</code></li>
<li><code>cdecl</code></li>
<li><code>fastcall</code></li>
<li><code>thiscall</code></li>
<li><code>vectorcall</code> 이는 현재 <code>abi_vectorcall</code> 게이트 뒤에 숨겨져 있으며 변경될 수 있습니다.</li>
<li><code>Rust</code></li>
<li><code>rust-intrinsic</code></li>
<li><code>system</code></li>
<li><code>C</code></li>
<li><code>win64</code></li>
<li><code>sysv64</code></li>
</ul>
<p>이 목록의 대부분의 ABI는 자명하지만, <code>system</code> ABI는 약간 생소할 수 있습니다. 이 제약 조건은 타겟의 라이브러리와 상호 운용하기 위해 적절한 ABI가 무엇이든 선택합니다. 예를 들어, x86 아키텍처의 win32에서 이는 사용되는 ABI가 <code>stdcall</code>임을 의미합니다. 그러나 x86_64에서 윈도우는 <code>C</code> 호출 규약을 사용하므로 <code>C</code>가 사용됩니다. 이는 이전 예제에서 x86뿐만 아니라 모든 윈도우 시스템에 대한 블록을 정의하기 위해 <code>extern "system" { ... }</code>을 사용할 수 있었음을 의미합니다.</p>
<h2 id="외부-코드와의-상호-운용성"><a class="header" href="#외부-코드와의-상호-운용성">외부 코드와의 상호 운용성</a></h2>
<p>러스트는 <code>#[repr(C)]</code> 속성이 적용된 경우에만 <code>struct</code>의 레이아웃이 플랫폼의 C 표현과 호환됨을 보장합니다. <code>#[repr(C, packed)]</code>는 패딩 없이 구조체 멤버를 배치하는 데 사용할 수 있습니다. <code>#[repr(C)]</code>는 열거형(enum)에도 적용될 수 있습니다.</p>
<p>러스트의 소유된 박스(<code>Box&lt;T&gt;</code>)는 내부 객체를 가리키는 핸들로서 null이 될 수 없는 포인터를 사용합니다. 하지만 이들은 내부 할당자에 의해 관리되므로 수동으로 생성해서는 안 됩니다. 참조는 해당 타입으로 직접 향하는 null이 될 수 없는 포인터라고 안전하게 가정할 수 있습니다. 하지만 빌림 검사나 가변성 규칙을 어기는 것이 안전하다고 보장되지는 않으므로, 필요한 경우에는 원시 포인터(<code>*</code>)를 사용하는 것을 선호하십시오. 컴파일러가 원시 포인터에 대해서는 그만큼 많은 가정을 할 수 없기 때문입니다.</p>
<p>벡터와 문자열은 동일한 기본 메모리 레이아웃을 공유하며, <code>vec</code> 및 <code>str</code> 모듈에는 C API와 작업하기 위한 유틸리티들이 준비되어 있습니다. 하지만 문자열은 <code>\0</code>으로 끝나지 않습니다. C와의 상호 운용성을 위해 NUL로 끝나는 문자열이 필요하다면 <code>std::ffi</code> 모듈의 <code>CString</code> 타입을 사용해야 합니다.</p>
<p><a href="https://crates.io/crates/libc">crates.io의 <code>libc</code> 크레이트</a>는 <code>libc</code> 모듈에 C 표준 라이브러리를 위한 타입 별칭과 함수 정의를 포함하고 있으며, 러스트는 기본적으로 <code>libc</code> 및 <code>libm</code>과 링크됩니다.</p>
<h2 id="가변-인자-함수-variadic-functions"><a class="header" href="#가변-인자-함수-variadic-functions">가변 인자 함수 (Variadic functions)</a></h2>
<p>C에서 함수는 '가변 인자'를 가질 수 있습니다. 즉, 가변적인 개수의 인자를 받을 수 있음을 의미합니다. 러스트에서는 외부 함수 선언의 인자 목록 안에 <code>...</code>를 지정함으로써 이를 달성할 수 있습니다:</p>
<pre><code class="language-no_run">extern {
    fn foo(x: i32, ...);
}

fn main() {
    unsafe {
        foo(10, 20, 30, 40, 50);
    }
}
</code></pre>
<p>일반적인 러스트 함수는 가변 인자를 가질 수 <em>없습니다</em>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 이 코드는 컴파일되지 않습니다

fn foo(x: i32, ...) {}
<span class="boring">}</span></code></pre></pre>
<h2 id="널-포인터-최적화nullable-pointer-optimization"><a class="header" href="#널-포인터-최적화nullable-pointer-optimization">"널 포인터 최적화(nullable pointer optimization)"</a></h2>
<p>특정 러스트 타입들은 절대 <code>null</code>이 될 수 없도록 정의되어 있습니다. 여기에는 참조(<code>&amp;T</code>, <code>&amp;mut T</code>), 박스(<code>Box&lt;T&gt;</code>), 그리고 함수 포인터(<code>extern "abi" fn()</code>)가 포함됩니다. C와 인터페이스할 때 <code>null</code>일 수 있는 포인터가 자주 사용되는데, 러스트 타입과의 변환을 처리하기 위해 지저분한 <code>transmute</code>나 안전하지 않은 코드가 필요해 보일 수 있습니다. 하지만 이러한 유효하지 않은 값을 생성하거나 다루려는 시도는 **정의되지 않은 동작(undefined behavior)**이므로, 대신 다음과 같은 우회 방법을 사용해야 합니다.</p>
<p>특별한 경우로, <code>enum</code>이 정확히 두 개의 변형(variant)을 가지고 있고, 그중 하나는 데이터를 포함하지 않으며 다른 하나는 위에서 나열한 널 불가 타입 중 하나의 필드를 포함한다면, 그 <code>enum</code>은 "널 포인터 최적화" 대상이 됩니다. 이는 판별자(discriminant)를 위한 추가 공간이 필요하지 않음을 의미합니다. 대신, 비어 있는 변형은 널 불가 필드에 <code>null</code> 값을 넣음으로써 표현됩니다. 이를 "최적화"라고 부르지만, 다른 최적화와 달리 대상 타입에 대해 적용됨이 보장됩니다.</p>
<p>널 포인터 최적화를 활용하는 가장 흔한 타입은 <code>Option&lt;T&gt;</code>이며, 여기서 <code>None</code>은 <code>null</code>에 해당합니다. 따라서 <code>Option&lt;extern "C" fn(c_int) -&gt; c_int&gt;</code>는 C ABI를 사용하는 널 가능(nullable) 함수 포인터를 표현하는 올바른 방법입니다 (C 타입 <code>int (*)(int)</code>에 해당).</p>
<p>여기 인위적인 예제가 하나 있습니다. 어떤 C 라이브러리에 특정 상황에서 호출되는 콜백을 등록하는 기능이 있다고 가정해 봅시다. 이 콜백은 함수 포인터와 정수를 전달받으며, 해당 정수를 인자로 하여 함수를 실행해야 합니다. 따라서 우리는 FFI 경계를 양방향으로 넘나드는 함수 포인터를 갖게 됩니다.</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore">use libc::c_int;

<span class="boring">#[cfg(hidden)]
</span>extern "C" {
    /// 콜백을 등록합니다.
    fn register(cb: Option&lt;extern "C" fn(Option&lt;extern "C" fn(c_int) -&gt; c_int&gt;, c_int) -&gt; c_int&gt;);
}
<span class="boring">unsafe fn register(_: Option&lt;extern "C" fn(Option&lt;extern "C" fn(c_int) -&gt; c_int&gt;,
</span><span class="boring">                                           c_int) -&gt; c_int&gt;)
</span><span class="boring">{}
</span>
/// 이 꽤 쓸모없는 함수는 C로부터 함수 포인터와 정수를 전달받아,
/// 해당 정수를 인자로 하여 함수를 호출한 결과를 반환합니다.
/// 함수가 제공되지 않은 경우, 기본적으로 정수를 제곱합니다.
extern "C" fn apply(process: Option&lt;extern "C" fn(c_int) -&gt; c_int&gt;, int: c_int) -&gt; c_int {
    match process {
        Some(f) =&gt; f(int),
        None    =&gt; int * int
    }
}

fn main() {
    unsafe {
        register(Some(apply));
    }
}</code></pre>
<p>그리고 C 측 코드는 다음과 같습니다:</p>
<pre><code class="language-c">void register(int (*f)(int (*)(int), int)) {
    ...
}
</code></pre>
<p><code>transmute</code>가 필요 없습니다!</p>
<h2 id="ffi와-언와인딩-ffi-and-unwinding"><a class="header" href="#ffi와-언와인딩-ffi-and-unwinding">FFI와 언와인딩 (FFI and unwinding)</a></h2>
<p>FFI와 작업할 때는 언와인딩(unwinding)에 유의하는 것이 중요합니다. 대부분의 ABI 문자열은 <code>-unwind</code> 접미사가 있는 것과 없는 것의 두 가지 변형으로 제공됩니다. <code>Rust</code> ABI는 항상 언와인딩을 허용하므로, <code>Rust-unwind</code> ABI는 따로 없습니다.</p>
<p>만약 러스트의 <code>panic</code>이나 외부(예: C++) 예외가 FFI 경계를 넘나들 것으로 예상된다면, 해당 경계는 적절한 <code>-unwind</code> ABI 문자열을 사용해야 합니다. 반대로, 언와인딩이 ABI 경계를 넘지 않을 것으로 예상된다면, <code>-unwind</code>가 없는 ABI 문자열 중 하나를 사용하십시오.</p>
<blockquote>
<p>참고: <code>panic=abort</code>로 컴파일하면, <code>panic</code>을 일으키는 함수에 지정된 ABI와 관계없이 <code>panic!</code>은 즉시 프로세스를 중단시킵니다.</p>
</blockquote>
<p>만약 언와인딩 연산이 언와인딩이 허용되지 않는 ABI 경계를 만나게 되면, 그 동작은 언와인딩의 원천(러스트 <code>panic</code> 또는 외부 예외)에 따라 달라집니다:</p>
<ul>
<li><code>panic</code>은 프로세스를 안전하게 중단(abort)시킵니다.</li>
<li>러스트로 들어오는 외부 예외는 정의되지 않은 동작을 유발합니다.</li>
</ul>
<p><code>catch_unwind</code>와 외부 예외 사이의 상호작용은 <strong>정의되지 않았으며</strong>, <code>panic</code>과 외부 예외 포착 메커니즘(특히 C++의 <code>try</code>/<code>catch</code>) 사이의 상호작용도 마찬가지입니다.</p>
<h3 id="c-unwind를-사용한-러스트-panic"><a class="header" href="#c-unwind를-사용한-러스트-panic"><code>"C-unwind"</code>를 사용한 러스트 <code>panic</code></a></h3>
<!-- ignore: using unstable feature -->
<pre><code class="language-rust ignore">#[no_mangle]
extern "C-unwind" fn example() {
    panic!("어라");
}</code></pre>
<p>이 함수는 (<code>panic=unwind</code>로 컴파일되었을 때) C++ 스택 프레임을 언와인딩하는 것이 허용됩니다.</p>
<pre><code class="language-text">[Rust function with `catch_unwind`, which stops the unwinding]
      |
     ...
      |
[C++ frames]
      |                           ^
      | (calls)                   | (unwinding
      v                           |  goes this
[Rust function `example`]         |  way)
      |                           |
      +--- rust function panics --+
</code></pre>
<p>C++ 프레임에 객체가 있다면, 그들의 소멸자가 호출될 것입니다.</p>
<h3 id="c-unwind를-사용한-c-throw"><a class="header" href="#c-unwind를-사용한-c-throw"><code>"C-unwind"</code>를 사용한 C++ <code>throw</code></a></h3>
<!-- ignore: using unstable feature -->
<pre><code class="language-rust ignore">#[link(...)]
extern "C-unwind" {
    // 예외를 던질 수 있는 C++ 함수
    fn may_throw();
}

#[no_mangle]
extern "C-unwind" fn rust_passthrough() {
    let b = Box::new(5);
    unsafe { may_throw(); }
    println!("{:?}", &amp;b);
}</code></pre>
<p><code>try</code> 블록이 있는 C++ 함수는 <code>rust_passthrough</code>를 호출하고 <code>may_throw</code>에 의해 던져진 예외를 <code>catch</code>할 수 있습니다.</p>
<pre><code class="language-text">[C++ function with `try` block that invokes `rust_passthrough`]
      |
     ...
      |
[Rust function `rust_passthrough`]
      |                            ^
      | (calls)                    | (unwinding
      v                            |  goes this
[C++ function `may_throw`]         |  way)
      |                            |
      +--- C++ function throws ----+
</code></pre>
<p>만약 <code>may_throw</code>가 예외를 던진다면 <code>b</code>는 드롭될 것입니다. 그렇지 않다면 <code>5</code>가 출력될 것입니다.</p>
<h3 id="panic은-abi-경계에서-멈출-수-있습니다"><a class="header" href="#panic은-abi-경계에서-멈출-수-있습니다"><code>panic</code>은 ABI 경계에서 멈출 수 있습니다</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
extern "C" fn assert_nonzero(input: u32) {
    assert!(input != 0)
}
<span class="boring">}</span></code></pre></pre>
<p>만약 <code>assert_nonzero</code>가 인자 <code>0</code>과 함께 호출되면, 런타임은 <code>panic=abort</code>로 컴파일되었는지 여부와 관계없이 프로세스를 (안전하게) 중단시킬 것임을 보장합니다.</p>
<h3 id="panic을-선제적으로-포착하기"><a class="header" href="#panic을-선제적으로-포착하기"><code>panic</code>을 선제적으로 포착하기</a></h3>
<p>패닉이 발생할 수 있는 러스트 코드를 작성 중이고, 패닉 시 프로세스가 중단되는 것을 원치 않는다면 <a href="../std/panic/fn.catch_unwind.html"><code>catch_unwind</code></a>를 사용해야 합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::panic::catch_unwind;

#[no_mangle]
pub extern "C" fn oh_no() -&gt; i32 {
    let result = catch_unwind(|| {
        panic!("이크!");
    });
    match result {
        Ok(_) =&gt; 0,
        Err(_) =&gt; 1,
    }
}

fn main() {}</code></pre></pre>
<p><a href="../std/panic/fn.catch_unwind.html"><code>catch_unwind</code></a>은 언와인딩 패닉만을 포착하며, 프로세스를 중단시키는 패닉은 포착하지 못한다는 점에 유의하십시오. 자세한 내용은 <a href="../std/panic/fn.catch_unwind.html"><code>catch_unwind</code></a> 문서를 참조하십시오.</p>
<h2 id="불투명한opaque-구조체-표현하기"><a class="header" href="#불투명한opaque-구조체-표현하기">불투명한(opaque) 구조체 표현하기</a></h2>
<p>때때로 C 라이브러리는 어떤 것에 대한 포인터를 제공하고 싶어 하지만, 그 내부 세부 사항을 알리고 싶어 하지 않습니다. 안정적이고 간단한 방법은 <code>void *</code> 인자를 사용하는 것입니다.</p>
<pre><code class="language-c">void foo(void *arg);
void bar(void *arg);
</code></pre>
<p>우리는 러스트에서 <code>c_void</code> 타입을 사용하여 이를 표현할 수 있습니다:</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore">extern "C" {
    pub fn foo(arg: *mut libc::c_void);
    pub fn bar(arg: *mut libc::c_void);
}
<span class="boring">fn main() {}</span></code></pre>
<p>This is a perfectly valid way of handling the situation. However, we can do a bit better. To solve this, some C libraries will instead create a <code>struct</code>, where the details and memory layout of the struct are private. This gives some amount of type safety. These structures are called ‘opaque’. Here’s an example, in C:</p>
<pre><code class="language-c">struct Foo; /* Foo는 구조체이지만, 그 내용은 공개 인터페이스의 일부가 아닙니다 */
struct Bar;
void foo(struct Foo *arg);
void bar(struct Bar *arg);
</code></pre>
<p>러스트에서 이를 구현하기 위해, 우리만의 불투명 타입을 만들어 봅시다:</p>
<pre><pre class="playground"><code class="language-rust edition2021">#[repr(C)]
pub struct Foo {
    _data: (),
    _marker:
        core::marker::PhantomData&lt;(*mut u8, core::marker::PhantomPinned)&gt;,
}
#[repr(C)]
pub struct Bar {
    _data: (),
    _marker:
        core::marker::PhantomData&lt;(*mut u8, core::marker::PhantomPinned)&gt;,
}

extern "C" {
    pub fn foo(arg: *mut Foo);
    pub fn bar(arg: *mut Bar);
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>최소한 하나의 비공개 필드를 포함하고 생성자를 제공하지 않음으로써, 우리는 이 모듈 밖에서는 인스턴스화할 수 없는 불투명 타입을 만듭니다. (필드가 없는 구조체는 누구나 인스턴스화할 수 있습니다.) 또한 이 타입을 FFI에서 사용하기를 원하므로 <code>#[repr(C)]</code>를 추가해야 합니다. 마커는 컴파일러가 구조체를 <code>Send</code>, <code>Sync</code>로 표시하지 않도록 보장하며, <code>Unpin</code>도 적용되지 않도록 합니다. (<code>*mut u8</code>은 <code>Send</code>나 <code>Sync</code>가 아니며, <code>PhantomPinned</code>는 <code>Unpin</code>이 아닙니다.)</p>
<p>하지만 우리의 <code>Foo</code>와 <code>Bar</code> 타입은 서로 다르기 때문에, 둘 사이에 타입 안전성이 확보됩니다. 따라서 실수로 <code>Foo</code>에 대한 포인터를 <code>bar()</code>에 전달하는 일을 방지할 수 있습니다.</p>
<p>비어 있는 열거형(enum)을 FFI 타입으로 사용하는 것은 정말 좋지 않은 생각입니다. 컴파일러는 비어 있는 열거형이 거주 불가능(uninhabited)하다는 것에 의존하므로, <code>&amp;Empty</code> 타입의 값을 다루는 것은 매우 위험하며 정의되지 않은 동작을 유발하여 비정상적인 프로그램 동작으로 이어질 수 있습니다.</p>
<blockquote>
<p><strong>참고:</strong> 가장 간단한 방법은 "외부 타입(extern types)"을 사용하는 것입니다. 하지만 현재(2021년 6월 기준) 불안정한 상태이며 해결되지 않은 질문들이 남아 있습니다. 자세한 내용은 <a href="https://rust-lang.github.io/rfcs/1861-extern-types.html">RFC 페이지</a>와 <a href="https://github.com/rust-lang/rust/issues/43467">트래킹 이슈</a>를 참조하십시오.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="arc-mutex/arc-final.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="beneath-std.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="arc-mutex/arc-final.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="beneath-std.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
