<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>미확인 - The Rustonomicon</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/nomicon";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/unchecked-uninit.md`;
                    } else {
                        canonical_href = `${base}/${lang}/unchecked-uninit.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="The Dark Arts of Advanced and Unsafe Rust Programming">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/nomicon.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rustonomicon</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="확인되지-않은-초기화되지-않은-메모리"><a class="header" href="#확인되지-않은-초기화되지-않은-메모리">확인되지 않은 초기화되지 않은 메모리</a></h1>
<p>이 규칙에 대한 흥미로운 예외 중 하나는 배열로 작업할 때입니다. 안전한 러스트는 배열을 부분적으로 초기화하는 것을 허용하지 않습니다. 배열을 초기화할 때는 <code>let x = [val; N]</code>을 사용하여 모든 값을 동일하게 설정하거나, <code>let x = [val1, val2, val3]</code>과 같이 각 요소를 개별적으로 지정해야 합니다. 불행히도 이는 상당히 경직되어 있으며, 특히 배열을 더 점진적이거나 동적인 방식으로 초기화해야 할 때 더욱 그렇습니다.</p>
<p>비안전한 러스트는 이 문제를 해결하기 위해 강력한 도구인 <a href="../core/mem/union.MaybeUninit.html"><code>MaybeUninit</code></a>를 제공합니다. 이 타입은 아직 완전히 초기화되지 않은 메모리를 다루는 데 사용될 수 있습니다.</p>
<p><code>MaybeUninit</code>을 사용하면 다음과 같이 배열을 요소별로 하나씩 초기화할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem::{self, MaybeUninit};

// 배열의 크기는 하드코딩되어 있지만 변경하기 쉽습니다(즉, 상수만 변경하면 충분합니다).
// 하지만 이 방식은 [a, b, c] 구문을 사용하여 배열을 초기화할 수 없음을 의미합니다.
// 그 구문을 사용하면 `SIZE` 상수와 동기화 상태를 유지해야 하기 때문입니다!
const SIZE: usize = 10;

let x = {
    // `MaybeUninit`의 초기화되지 않은 배열을 생성합니다. 여기서 `assume_init`은
    // 안전합니다. 우리가 여기서 초기화했다고 주장하는 타입은 여러 개의
    // `MaybeUninit`들이며, 이것들은 초기화를 필요로 하지 않기 때문입니다.
    let mut x: [MaybeUninit&lt;Box&lt;u32&gt;&gt;; SIZE] = unsafe {
        MaybeUninit::uninit().assume_init()
    };

    // `MaybeUninit`을 드롭하는 것은 아무 일도 하지 않습니다. 따라서 `ptr::write` 대신
    // 원시 포인터 할당을 사용해도 이전의 초기화되지 않은 값이 드롭되지 않습니다.
    // Box는 패닉을 일으키지 않으므로 예외 안전성(exception safety)은 고려 대상이 아닙니다.
    for i in 0..SIZE {
        x[i] = MaybeUninit::new(Box::new(i as u32));
    }

    // 모든 것이 초기화되었습니다. 배열을 초기화된 타입으로 트랜스뮤트합니다.
    unsafe { mem::transmute::&lt;_, [Box&lt;u32&gt;; SIZE]&gt;(x) }
};

dbg!(x);
<span class="boring">}</span></code></pre></pre>
<p>이 코드는 세 단계로 진행됩니다:</p>
<ol>
<li>
<p><code>MaybeUninit&lt;T&gt;</code>의 배열을 생성합니다. 현재의 안정 버전 러스트에서는 이를 위해 unsafe 코드를 사용해야 합니다. 즉, 초기화되지 않은 메모리 조각(<code>MaybeUninit::uninit()</code>)을 취하고 그것을 완전히 초기화했다고 주장(<a href="../core/mem/union.MaybeUninit.html#method.assume_init"><code>assume_init()</code></a>)하는 것입니다. 실제로는 초기화하지 않았기 때문에 이는 어처구니없어 보일 수 있습니다! 이것이 올바른 이유는 배열 자체가 실제로 초기화를 필요로 하지 않는 <code>MaybeUninit</code>들로만 구성되어 있기 때문입니다. 대부분의 다른 타입들에 대해 <code>MaybeUninit::uninit().assume_init()</code>을 수행하는 것은 해당 타입의 유효하지 않은 인스턴스를 생성하게 되며, 따라서 정의되지 않은 동작을 일으키게 됩니다.</p>
</li>
<li>
<p>배열을 초기화합니다. 여기서 미묘한 점은 보통 러스트 타입 검사기가 이미 초기화되었다고 간주하는 값(예: <code>x[i]</code>)에 <code>=</code>을 사용하여 할당할 때, 좌변에 저장되어 있던 이전 값이 드롭된다는 것입니다. 이는 재앙이 될 것입니다. 하지만 이 경우 좌변의 타입은 <code>MaybeUninit&lt;Box&lt;u32&gt;&gt;</code>이며, 이를 드롭하는 것은 아무런 일도 하지 않습니다! 이 <code>drop</code> 이슈에 대한 자세한 논의는 아래를 참조하세요.</p>
</li>
<li>
<p>마지막으로, <code>MaybeUninit</code>을 제거하기 위해 배열의 타입을 변경해야 합니다. 현재 안정 버전 러스트에서는 이를 위해 <code>transmute</code>가 필요합니다. 이 트랜스뮤트는 적법한데, 메모리상에서 <code>MaybeUninit&lt;T&gt;</code>는 <code>T</code>와 동일하게 보이기 때문입니다.</p>
<p>하지만 일반적으로 <code>Container&lt;MaybeUninit&lt;T&gt;&gt;</code>가 <code>Container&lt;T&gt;</code>와 동일하게 보이는 것은 아닙니다! 예를 들어 <code>Container</code>가 <code>Option</code>이고 <code>T</code>가 <code>bool</code>이라면, <code>Option&lt;bool&gt;</code>은 <code>bool</code>이 단 두 개의 유효한 값만을 가진다는 점을 활용하지만, <code>Option&lt;MaybeUninit&lt;bool&gt;&gt;</code>은 <code>bool</code>이 초기화될 필요가 없으므로 그렇게 할 수 없습니다.</p>
<p>따라서 <code>MaybeUninit</code>을 트랜스뮤트로 제거하는 것이 허용되는지는 <code>Container</code>에 달려 있습니다. 배열의 경우에는 허용됩니다(결국 표준 라이브러리에서도 적절한 메서드를 제공함으로써 이를 인정하게 될 것입니다).</p>
</li>
</ol>
<p>중간에 있는 루프, 특히 할당 연산자와 <code>drop</code>의 상호 작용에 대해 좀 더 시간을 할애해 볼 가치가 있습니다. 만약 우리가 다음과 같이 쓴다면:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">*x[i].as_mut_ptr() = Box::new(i as u32); // 틀림!</code></pre>
<p>실제로 <code>Box&lt;u32&gt;</code>를 덮어쓰게 되어 초기화되지 않은 데이터에 대한 <code>drop</code>이 발생하고, 이는 커다란 슬픔과 고통을 초래할 것입니다.</p>
<p>어떤 이유로 <code>MaybeUninit::new</code>를 사용할 수 없는 경우의 올바른 대안은 <a href="../core/ptr/index.html"><code>ptr</code></a> 모듈을 사용하는 것입니다. 특히 이 모듈은 이전 값을 드롭하지 않고 메모리 위치에 바이트를 할당할 수 있게 해주는 세 가지 함수를 제공합니다: <a href="../core/ptr/fn.write.html"><code>write</code></a>, <a href="../std/ptr/fn.copy.html"><code>copy</code></a>, 그리고 <a href="../std/ptr/fn.copy_nonoverlapping.html"><code>copy_nonoverlapping</code></a>입니다.</p>
<ul>
<li><code>ptr::write(ptr, val)</code>는 <code>val</code>을 받아서 <code>ptr</code>이 가리키는 주소로 이동시킵니다.</li>
<li><code>ptr::copy(src, dest, count)</code>는 <code>count</code>개의 <code>T</code> 아이템이 차지할 비트를 <code>src</code>에서 <code>dest</code>로 복사합니다. (이는 C의 <code>memmove</code>와 동일합니다. 인자 순서가 반대임에 유의하세요!)</li>
<li><code>ptr::copy_nonoverlapping(src, dest, count)</code>는 <code>copy</code>와 동일한 작업을 수행하지만, 두 메모리 범위가 겹치지 않는다는 가정하에 조금 더 빠릅니다. (이는 C의 <code>memcpy</code>와 동일합니다. 인자 순서가 반대임에 유의하세요!)</li>
</ul>
<p>말할 필요도 없이, 이 함수들을 잘못 사용하면 심각한 혼란이나 문자 그대로의 정의되지 않은 동작을 야기할 것입니다. 이 함수들 _자체_의 유일한 요구 사항은 읽고 쓰려는 위치가 할당되어 있고 적절하게 정렬되어 있어야 한다는 것뿐입니다. 하지만 임의의 비트를 임의의 메모리 위치에 쓰는 행위가 시스템을 망가뜨릴 수 있는 방법은 기본적으로 셀 수 없이 많습니다!</p>
<p><code>Drop</code>을 구현하지 않거나 <code>Drop</code> 타입을 포함하지 않는 타입들에 대해서는 <code>ptr::write</code> 방식의 복잡한 처리를 걱정할 필요가 없다는 점에 주목할 가치가 있습니다. 러스트가 그것들을 드롭하려고 시도하지 않는다는 것을 알기 때문입니다. 이것이 우리가 위 예제에서 의존했던 점입니다.</p>
<p>하지만 초기화되지 않은 메모리를 다룰 때는, 여러분이 만든 이러한 값들이 완전히 초기화되기 전에 러스트가 그것들을 드롭하려고 시도하지 않는지 항상 경계해야 합니다. 변수의 스코프를 통과하는 모든 제어 경로는 변수가 끝나기 전에(소멸자가 있는 경우) 값을 초기화해야 합니다. <em><a href="unwinding.html">여기에는 패닉이 발생하는 코드도 포함됩니다</a></em>. <code>MaybeUninit</code>은 여기서 약간의 도움이 되는데, 내용물을 암시적으로 드롭하지 않기 때문입니다. 하지만 패닉이 발생할 경우 이것이 의미하는 바는, 아직 초기화되지 않은 부분에 대한 이중 해제(double-free) 대신, 이미 초기화된 부분에 대한 메모리 누수가 발생한다는 것뿐입니다.</p>
<p>참고로, <code>ptr</code> 메서드를 사용하려면 먼저 초기화하려는 데이터에 대한 _원시 포인터_를 얻어야 합니다. 초기화되지 않은 데이터에 대한 _참조_를 생성하는 것은 불법이며, 이는 해당 원시 포인터를 얻을 때 매우 주의해야 함을 의미합니다:</p>
<ul>
<li><code>T</code> 타입의 배열에 대해서는, <code>base_ptr: *mut T</code>일 때 <code>base_ptr.add(idx)</code>를 사용하여 배열 인덱스 <code>idx</code>의 주소를 계산할 수 있습니다. 이는 메모리상에서 배열이 어떻게 배치되는지에 의존합니다.</li>
<li>하지만 구조체의 경우, 일반적으로 그것이 어떻게 배치되어 있는지 알 수 없으며, <code>&amp;mut base_ptr.field</code>를 사용할 수도 없습니다. 그렇게 하는 것은 참조를 생성하는 것이기 때문입니다. 따라서 <a href="../reference/types/pointer.html#r-type.pointer.raw.constructor">원시 참조(raw reference)</a> 구문을 주의해서 사용해야 합니다. 이 구문은 중간 참조를 생성하지 않고 필드에 대한 원시 포인터를 생성합니다:</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::{ptr, mem::MaybeUninit};

struct Demo {
    field: bool,
}

let mut uninit = MaybeUninit::&lt;Demo&gt;::uninit();
// `&amp;uninit.as_mut().field`는 초기화되지 않은 `bool`에 대한 참조를 생성하게 되며,
// 따라서 정의되지 않은 동작이 됩니다!
let f1_ptr = unsafe { &amp;raw mut (*uninit.as_mut_ptr()).field };
unsafe { f1_ptr.write(true); }

let init = unsafe { uninit.assume_init() };
<span class="boring">}</span></code></pre></pre>
<p>마지막으로 한 마디 더 하자면, 오래된 러스트 코드를 읽다 보면 이제는 권장되지 않는(deprecated) <code>mem::uninitialized</code> 함수를 마주칠 수 있습니다. 이 함수는 예전에 스택상의 초기화되지 않은 메모리를 다루는 유일한 방법이었지만, 언어의 나머지 부분들과 적절히 통합되는 것이 불가능하다는 것이 밝혀졌습니다. 새로운 코드에서는 항상 대신 <code>MaybeUninit</code>을 사용하고, 기회가 될 때 오래된 코드를 포팅하세요.</p>
<p>초기화되지 않은 메모리를 다루는 법은 이 정도면 충분합니다! 기본적으로 어디에서도 초기화되지 않은 메모리를 전달받을 것이라고 예상하지 않으므로, 이를 어딘가로 전달해야 한다면 정말로, <em>진짜로</em> 주의를 기울이시기 바랍니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="drop-flags.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="obrm.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="drop-flags.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="obrm.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
