<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Rustonomicon</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/nomicon";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/print.md`;
                    } else {
                        canonical_href = `${base}/${lang}/print.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="The Dark Arts of Advanced and Unsafe Rust Programming">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/nomicon.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rustonomicon</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="러스트노미콘"><a class="header" href="#러스트노미콘">러스트노미콘</a></h1>
<div class="warning">
<p>Warning: This book is incomplete. Documenting everything and rewriting outdated parts take a while. See the <a href="https://github.com/rust-lang/nomicon/issues">issue tracker</a> to check what's missing/outdated, and if there are any mistakes or ideas that haven't been reported, feel free to open a new issue there.</p>
</div>
<h2 id="안전하지-않은-러스트의-어두운-기술"><a class="header" href="#안전하지-않은-러스트의-어두운-기술">안전하지 않은 러스트의 어두운 기술</a></h2>
<blockquote>
<p>이 지식은 명시적이든 묵시적이든 어떠한 종류의 보증도 없이 '있는 그대로' 제공됩니다. 여기에는 당신의 정신을 산산조각 내고 알 수 없는 무한한 우주 속으로 당신의 마음을 표류하게 할 형언할 수 없는 공포를 풀어놓는 것에 대한 보증이 포함되지만 이에 국한되지 않습니다.</p>
</blockquote>
<p>러스트노미콘은 안전하지 않은 러스트 프로그램을 작성할 때 이해해야 할 모든 끔찍한 세부 사항을 파고듭니다.</p>
<p>러스트 프로그램을 작성하는 길고 행복한 경력을 원한다면, 지금 당장 이 책을 잊고 돌아가야 합니다. 이 책은 필수가 아닙니다. 하지만 안전하지 않은 코드를 작성하거나 언어의 내부를 파고들고 싶다면, 이 책은 많은 유용한 정보를 담고 있습니다.</p>
<p>Unlike <em><a href="../book/index.html">The Rust Programming Language</a></em>, we will be assuming considerable prior knowledge. In particular, you should be comfortable with basic systems programming and Rust. If you don't feel comfortable with these topics, you should consider reading <a href="../book/index.html">The Book</a> first. That said, we won't assume you have read it, and we will take care to occasionally give a refresher on the basics where appropriate. You can skip straight to this book if you want; just know that we won't be explaining everything from the ground up.</p>
<p>이 책은 주로 <a href="../reference/index.html">참조서</a>의 고급 동반자 역할을 합니다. 참조서가 언어의 모든 부분의 구문과 의미를 자세히 설명하는 반면, 러스트노미콘은 이러한 부분들을 함께 사용하는 방법과 그렇게 할 때 발생할 수 있는 문제들을 설명합니다.</p>
<p>참조서는 참조, 소멸자, 언와인딩의 구문과 의미를 알려주지만, 이들을 결합하는 것이 어떻게 예외 안전성 문제로 이어질 수 있는지, 또는 그러한 문제들을 어떻게 다루어야 하는지는 알려주지 않습니다.</p>
<p>러스트노미콘과 참조서가 잘 동기화되지 않아 중복된 내용이 있을 수 있다는 점에 유의해야 합니다. 일반적으로 두 문서가 일치하지 않는 경우, 참조서가 올바르다고 가정해야 합니다(아직 규범적인 것으로 간주되지는 않지만, 더 잘 관리되고 있습니다).</p>
<p>Topics that are within the scope of this book include: the meaning of (un)safety, unsafe primitives provided by the language and standard library, techniques for creating safe abstractions with those unsafe primitives, subtyping and variance, exception-safety (panic/unwind-safety), working with uninitialized memory, type punning, concurrency, interoperating with other languages (FFI), optimization tricks, how constructs lower to compiler/OS/hardware primitives, how to <strong>not</strong> make the memory model people angry, how you're <strong>going</strong> to make the memory model people angry, and more.</p>
<p>러스트노미콘은 표준 라이브러리의 모든 단일 API의 의미와 보증을 상세하게 설명하는 곳이 아니며, 러스트의 모든 기능을 상세하게 설명하는 곳도 아닙니다.</p>
<p>Unless otherwise noted, Rust code in this book uses the Rust 2024 edition.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="안전한-코드와-안전하지-않은-코드를-만나다"><a class="header" href="#안전한-코드와-안전하지-않은-코드를-만나다">안전한 코드와 안전하지 않은 코드를 만나다</a></h1>
<p><img src="img/safeandunsafe.svg" alt="안전한 코드와 안전하지 않은 코드" /></p>
<p>It would be great to not have to worry about low-level implementation details. Who could possibly care how much space the empty tuple occupies? Sadly, it sometimes matters and we need to worry about it. The most common reason developers start to care about implementation details is performance, but more importantly, these details can become a matter of correctness when interfacing directly with hardware, operating systems, or other languages.</p>
<p>안전한 프로그래밍 언어에서 구현 세부 사항이 중요해지기 시작할 때, 프로그래머는 일반적으로 세 가지 선택지가 있습니다:</p>
<ul>
<li>컴파일러/런타임이 최적화를 수행하도록 코드를 조작합니다.</li>
<li>원하는 구현을 얻기 위해 더 비관용적이거나 번거로운 설계를 채택합니다.</li>
<li>해당 세부 사항을 처리할 수 있는 언어로 구현을 다시 작성합니다.</li>
</ul>
<p>마지막 옵션의 경우, 프로그래머들이 사용하는 언어는 주로 _C_입니다. 이는 C 인터페이스만 선언하는 시스템과 인터페이스하기 위해 종종 필요합니다.</p>
<p>불행히도 C는 사용하기에 믿을 수 없을 정도로 안전하지 않으며(때로는 타당한 이유로), 다른 언어와 상호 운용하려고 할 때 이러한 불안전성은 증폭됩니다. C와 다른 언어가 무엇이 일어나고 있는지 동의하고 서로의 영역을 침범하지 않도록 주의해야 합니다.</p>
<p>그렇다면 이것이 러스트와 무슨 관련이 있을까요?</p>
<p>음, C와 달리 러스트는 안전한 프로그래밍 언어입니다.</p>
<p>하지만 C와 마찬가지로 러스트는 안전하지 않은 프로그래밍 언어입니다.</p>
<p>더 정확히 말하면, 러스트는 안전한 프로그래밍 언어와 안전하지 않은 프로그래밍 언어를 모두 _포함_합니다.</p>
<p>러스트는 두 가지 프로그래밍 언어의 조합으로 생각할 수 있습니다: _안전한 러스트_와 <em>안전하지 않은 러스트</em>. 편리하게도 이 이름들은 정확히 그 의미를 가집니다. 안전한 러스트는 안전합니다. 안전하지 않은 러스트는, 음, 그렇지 않습니다. 사실, 안전하지 않은 러스트는 우리가 <em>정말로</em> 안전하지 않은 일들을 할 수 있게 해줍니다. 러스트 저자들이 하지 말라고 간청할 일들이지만, 우리는 어쨌든 할 것입니다.</p>
<p>안전한 러스트는 <em>진정한</em> 러스트 프로그래밍 언어입니다. 안전한 러스트만 작성한다면, 타입 안전성이나 메모리 안전성에 대해 걱정할 필요가 없을 것입니다. 매달린 포인터, 해제 후 사용, 또는 다른 종류의 정의되지 않은 동작(UB)을 겪을 일은 없을 것입니다.</p>
<p>표준 라이브러리는 또한 순수하고 관용적인 안전한 러스트로 고성능 애플리케이션과 라이브러리를 작성할 수 있도록 충분한 유틸리티를 제공합니다.</p>
<p>But maybe you want to talk to another language. Maybe you're writing a low-level abstraction not exposed by the standard library. Maybe you're <em>writing</em> the standard library (which is written entirely in Rust). Maybe you need to do something the type-system doesn't understand and just <em>frob some dang bits</em>. Maybe you need Unsafe Rust.</p>
<p>안전하지 않은 러스트는 모든 규칙과 의미론이 안전한 러스트와 정확히 같습니다. 단지 확실히 안전하지 않은 <em>추가적인</em> 작업(다음 섹션에서 정의할 것임)을 할 수 있게 해줄 뿐입니다.</p>
<p>이러한 분리의 가치는 C와 같은 안전하지 않은 언어를 사용하는 이점, 즉 구현 세부 사항에 대한 저수준 제어를 얻으면서도, 완전히 다른 안전한 언어와 통합하려고 할 때 발생하는 대부분의 문제 없이 가능하게 합니다.</p>
<p>여전히 몇 가지 문제가 있습니다. 가장 주목할 만한 것은 타입 시스템이 가정하는 속성을 인지하고 안전하지 않은 러스트와 상호 작용하는 모든 코드에서 이를 감사해야 한다는 것입니다. 이것이 이 책의 목적입니다: 이러한 가정과 관리 방법을 가르치는 것입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="안전한-코드와-안전하지-않은-코드는-어떻게-상호작용하는가"><a class="header" href="#안전한-코드와-안전하지-않은-코드는-어떻게-상호작용하는가">안전한 코드와 안전하지 않은 코드는 어떻게 상호작용하는가</a></h1>
<p>안전한 러스트와 안전하지 않은 러스트의 관계는 무엇일까요? 이들은 어떻게 상호 작용할까요?</p>
<p>안전한 러스트와 안전하지 않은 러스트의 분리는 <code>unsafe</code> 키워드로 제어되며, 이는 둘 사이의 인터페이스 역할을 합니다. 이것이 안전한 러스트가 안전한 언어라고 말할 수 있는 이유입니다. 모든 안전하지 않은 부분은 <code>unsafe</code> 경계 뒤에만 존재합니다. 원한다면 <code>#[forbid(unsafe_code)]</code>를 코드베이스에 넣어 안전한 러스트만 작성하고 있음을 정적으로 보장할 수도 있습니다. 이는 임베디드 러스트에서 흔히 사용되는 관행으로, 전체 애플리케이션은 종종 안전한 러스트로 작성되고, <code>unsafe</code> 코드는 작은 HAL(하드웨어 추상화 계층) 크레이트에 국한됩니다.</p>
<p><code>unsafe</code> 키워드는 두 가지 용도로 사용됩니다. 컴파일러가 확인할 수 없는 계약의 존재를 선언하고, 프로그래머가 이러한 계약이 준수되었음을 확인했음을 선언하는 것입니다.</p>
<p>You can use <code>unsafe</code> to indicate the existence of unchecked contracts on <em>functions</em> and <em>trait declarations</em>. On functions, <code>unsafe</code> means that users of the function must check that function's documentation to ensure they are using it in a way that maintains the contracts the function requires. On trait declarations, <code>unsafe</code> means that implementors of the trait must check the trait documentation to ensure their implementation maintains the contracts the trait requires.</p>
<p>블록에 <code>unsafe</code>를 사용하여 그 안에서 수행되는 모든 안전하지 않은 작업이 해당 작업의 계약을 준수하는지 확인되었음을 선언할 수 있습니다. 예를 들어, <a href="../std/primitive.slice.html#method.get_unchecked"><code>slice::get_unchecked</code></a>에 전달된 인덱스가 범위 내에 있습니다.</p>
<p>트레잇 구현에 <code>unsafe</code>를 사용하여 해당 구현이 트레잇의 계약을 준수함을 선언할 수 있습니다. 예를 들어, <a href="../std/marker/trait.Send.html"><code>Send</code></a>를 구현하는 타입이 실제로 다른 스레드로 이동해도 안전하다는 것을 선언할 수 있습니다.</p>
<p>표준 라이브러리에는 다음을 포함한 여러 안전하지 않은 함수가 있습니다:</p>
<ul>
<li><a href="../std/primitive.slice.html#method.get_unchecked"><code>slice::get_unchecked</code></a>`는 검사되지 않은 인덱싱을 수행하여 메모리 안전성을 자유롭게 위반할 수 있습니다.</li>
<li><a href="../std/mem/fn.transmute.html"><code>mem::transmute</code></a> reinterprets some value as having a given type, bypassing type safety in arbitrary ways (see <a href="conversions.html">conversions</a> for details).</li>
<li>크기가 지정된 타입에 대한 모든 원시 포인터는 전달된 오프셋이 <a href="../std/primitive.pointer.html#method.offset">"범위 내"</a>에 있지 않으면 정의되지 않은 동작을 호출하는 <a href="../std/primitive.pointer.html#method.offset"><code>offset</code></a> 메서드를 가집니다.</li>
<li>모든 FFI(외부 함수 인터페이스) 함수는 다른 언어가 러스트 컴파일러가 확인할 수 없는 임의의 작업을 수행할 수 있기 때문에 <code>unsafe</code>로 호출해야 합니다.</li>
</ul>
<p>As of Rust 1.29.2, the standard library defines the following unsafe traits (there are others, but they are not stabilized yet and some of them may never be):</p>
<ul>
<li><a href="../std/marker/trait.Send.html"><code>Send</code></a>`는 구현체가 다른 스레드로 안전하게 전송(이동)될 수 있음을 약속하는 마커 트레잇(API가 없는 트레잇)입니다.</li>
<li><a href="../std/marker/trait.Sync.html"><code>Sync</code></a>`는 구현체가 스레드 간에 참조를 안전하게 공유할 수 있음을 약속하는 마커 트레잇(API가 없는 트레잇)입니다.</li>
<li><a href="../std/alloc/trait.GlobalAlloc.html"><code>GlobalAlloc</code></a> allows customizing the memory allocator of the whole program.</li>
</ul>
<p>러스트 표준 라이브러리의 많은 부분도 내부적으로 안전하지 않은 러스트를 사용합니다. 이러한 구현은 일반적으로 엄격하게 수동으로 검사되었으므로, 이러한 구현 위에 구축된 안전한 러스트 인터페이스는 안전하다고 가정할 수 있습니다.</p>
<p>The need for all of this separation boils down to a single fundamental property of Safe Rust, the <em>soundness property</em>:</p>
<p><strong>어떤 경우에도 안전한 러스트는 정의되지 않은 동작을 유발할 수 없습니다.</strong></p>
<p>안전/비안전 분리의 설계는 안전한 러스트와 안전하지 않은 러스트 사이에 비대칭적인 신뢰 관계가 있음을 의미합니다. 안전한 러스트는 자신이 접하는 모든 안전하지 않은 러스트가 올바르게 작성되었다고 본질적으로 신뢰해야 합니다. 반면에 안전하지 않은 러스트는 주의 없이는 안전한 러스트를 신뢰할 수 없습니다.</p>
<p>예를 들어, 러스트에는 <a href="../std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a> 및 <a href="../std/cmp/trait.Ord.html"><code>Ord</code></a> 트레잇이 있어 단순히 비교할 수 있는 타입과 "전체" 순서(기본적으로 비교가 합리적으로 작동함을 의미)를 제공하는 타입을 구분합니다.</p>
<p><a href="../std/collections/struct.BTreeMap.html"><code>BTreeMap</code></a><code>은 부분적으로 정렬된 타입에는 적합하지 않으므로, 키가 </code>Ord<code>를 구현하도록 요구합니다. 그러나 </code>BTreeMap<code>은 구현 내부에 안전하지 않은 러스트 코드를 가지고 있습니다. 허술한 </code>Ord<code>구현(안전하게 작성할 수 있음)이 정의되지 않은 동작을 유발하는 것은 용납할 수 없으므로,</code>BTreeMap<code>의 안전하지 않은 코드는 </code>Ord<code>를 요구하는 전체적인 목적에도 불구하고 실제로는 완전하지 않은 </code>Ord` 구현에 대해 견고하도록 작성되어야 합니다.</p>
<p>안전하지 않은 러스트 코드는 안전한 러스트 코드가 올바르게 작성되었다고 신뢰할 수 없습니다. 그렇다고 해도, <code>BTreeMap</code>은 전체 순서가 없는 값을 입력하면 여전히 완전히 불규칙하게 작동할 것입니다. 단지 정의되지 않은 동작을 유발하지는 않을 것입니다.</p>
<p><code>BTreeMap</code>이 <code>Ord</code>가 안전하다는 이유로 신뢰할 수 없다면, 왜 <em>어떤</em> 안전한 코드도 신뢰할 수 있는지 궁금할 수 있습니다. 예를 들어 <code>BTreeMap</code>은 정수와 슬라이스가 올바르게 구현되었다고 가정합니다. 그것들도 안전하겠죠?</p>
<p>차이점은 범위에 있습니다. <code>BTreeMap</code>이 정수와 슬라이스에 의존할 때, 이는 매우 특정한 구현에 의존하는 것입니다. 이는 이점에 대비하여 측정할 수 있는 위험입니다. 이 경우 위험은 기본적으로 0입니다. 정수와 슬라이스가 고장 나면 _모든 사람_이 고장 납니다. 또한, <code>BTreeMap</code>을 유지 관리하는 동일한 사람들이 유지 관리하므로, 이들을 쉽게 추적할 수 있습니다.</p>
<p>On the other hand, <code>BTreeMap</code>'s key type is generic. Trusting its <code>Ord</code> implementation means trusting every <code>Ord</code> implementation in the past, present, and future. Here the risk is high: someone somewhere is going to make a mistake and mess up their <code>Ord</code> implementation, or even just straight up lie about providing a total ordering because "it seems to work". When that happens, <code>BTreeMap</code> needs to be prepared.</p>
<p>동일한 논리가 올바르게 작동하도록 전달된 클로저를 신뢰하는 데에도 적용됩니다.</p>
<p>이러한 무한한 일반 신뢰 문제는 <code>unsafe</code> 트레잇이 해결하기 위해 존재하는 문제입니다. <code>BTreeMap</code> 타입은 이론적으로 <code>Ord</code> 대신 <code>UnsafeOrd</code>라는 새로운 트레잇을 키가 구현하도록 요구할 수 있으며, 이는 다음과 같을 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cmp::Ordering;

unsafe trait UnsafeOrd {
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering;
}
<span class="boring">}</span></code></pre></pre>
<p>그러면 타입은 <code>unsafe</code>를 사용하여 <code>UnsafeOrd</code>를 구현하고, 해당 구현이 트레잇이 기대하는 모든 계약을 유지함을 보장했음을 나타냅니다. 이 상황에서 <code>BTreeMap</code> 내부의 안전하지 않은 러스트는 키 타입의 <code>UnsafeOrd</code> 구현이 올바르다고 신뢰하는 것이 정당화될 것입니다. 만약 그렇지 않다면, 이는 안전하지 않은 트레잇 구현의 잘못이며, 이는 러스트의 안전 보장과 일치합니다.</p>
<p>트레잇을 <code>unsafe</code>로 표시할지 여부는 API 설계 선택입니다. 안전한 트레잇은 구현하기 쉽지만, 이에 의존하는 모든 안전하지 않은 코드는 잘못된 동작에 대해 방어해야 합니다. 트레잇을 <code>unsafe</code>로 표시하면 이 책임이 구현자에게 전가됩니다. 러스트는 전통적으로 트레잇을 <code>unsafe</code>로 표시하는 것을 피했는데, 이는 안전하지 않은 러스트를 만연하게 만들어 바람직하지 않기 때문입니다.</p>
<p><code>Send</code> and <code>Sync</code> are marked unsafe because thread safety is a <em>fundamental property</em> that unsafe code can't possibly hope to defend against in the way it could defend against a buggy <code>Ord</code> implementation. Similarly, <code>GlobalAlloc</code> is keeping accounts of all the memory in the program and other things like <code>Box</code> or <code>Vec</code> that build on top of it. If it does something weird (giving the same chunk of memory to another request when it is still in use), there's no chance to detect that and do anything about it.</p>
<p>자신만의 트레잇을 <code>unsafe</code>로 표시할지 여부는 동일한 종류의 고려 사항에 따라 달라집니다. <code>unsafe</code> 코드가 트레잇의 깨진 구현에 대해 합리적으로 방어할 수 없다면, 트레잇을 <code>unsafe</code>로 표시하는 것이 합리적인 선택입니다.</p>
<p>As an aside, while <code>Send</code> and <code>Sync</code> are <code>unsafe</code> traits, they are <em>also</em> automatically implemented for types when such derivations are provably safe to do. <code>Send</code> is automatically derived for all types composed only of values whose types also implement <code>Send</code>. <code>Sync</code> is automatically derived for all types composed only of values whose types also implement <code>Sync</code>. This minimizes the pervasive unsafety of making these two traits <code>unsafe</code>. And not many people are going to <em>implement</em> memory allocators (or use them directly, for that matter).</p>
<p>이것이 안전한 러스트와 안전하지 않은 러스트 사이의 균형입니다. 분리는 안전한 러스트를 가능한 한 인체공학적으로 사용하도록 설계되었지만, 안전하지 않은 러스트를 작성할 때는 추가적인 노력과 주의가 필요합니다. 이 책의 나머지 부분은 주로 취해야 할 주의 사항과 안전하지 않은 러스트가 준수해야 하는 계약에 대한 논의입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="안전하지-않은-rust가-할-수-있는-일"><a class="header" href="#안전하지-않은-rust가-할-수-있는-일">안전하지 않은 Rust가 할 수 있는 일</a></h1>
<p>안전하지 않은 Rust에서 다른 유일한 점은 다음을 수행할 수 있다는 것입니다.</p>
<ul>
<li>원시 포인터 역참조</li>
<li>안전하지 않은 함수 호출(C 함수, 컴파일러 내장 함수 및 원시 할당자 포함)</li>
<li>안전하지 않은 트레잇 구현</li>
<li>변경 가능한 정적 변수 접근 또는 수정</li>
<li><code>union</code>의 필드 접근</li>
</ul>
<p>이게 전부입니다. 이러한 작업이 Unsafe에 맡겨진 이유는 이 중 어느 것이든 잘못 사용하면 항상 두려운 정의되지 않은 동작이 발생하기 때문입니다. 정의되지 않은 동작을 호출하면 컴파일러는 프로그램에 임의로 나쁜 짓을 할 수 있는 모든 권한을 갖게 됩니다. 정의되지 않은 동작을 호출해서는 <em>절대</em> 안 됩니다.</p>
<p>C와 달리 Rust에서 정의되지 않은 동작은 범위가 매우 제한적입니다. 핵심 언어는 다음 사항을 방지하는 데 중점을 둡니다.</p>
<ul>
<li>매달려 있거나 정렬되지 않은 포인터 역참조(아래 참조)</li>
<li><a href="references.html">포인터 별칭 규칙</a> 위반</li>
<li>잘못된 호출 ABI로 함수를 호출하거나 잘못된 해제 ABI로 함수에서 해제하는 경우.</li>
<li><a href="races.html">데이터 경쟁</a> 유발</li>
<li>현재 실행 스레드가 지원하지 않는 <a href="../reference/attributes/codegen.html#the-target_feature-attribute">대상 기능</a>으로 컴파일된 코드 실행</li>
<li>(단독으로 또는 <code>enum</code>/<code>struct</code>/배열/튜플과 같은 복합 타입의 필드로) 유효하지 않은 값 생성:
<ul>
<li>0 또는 1이 아닌 <code>bool</code></li>
<li>유효하지 않은 판별자를 가진 <code>enum</code></li>
<li>널 <code>fn</code> 포인터</li>
<li>범위 [0x0, 0xD7FF] 및 [0xE000, 0x10FFFF] 밖에 있는 <code>char</code></li>
<li><code>!</code> (모든 값이 이 타입에 대해 유효하지 않음)</li>
<li>정수(<code>i*</code>/<code>u*</code>), 부동 소수점 값(<code>f*</code>), 또는 <a href="uninitialized.html">초기화되지 않은 메모리</a>에서 읽은 원시 포인터, 또는 <code>str</code>의 초기화되지 않은 메모리.</li>
<li>매달려 있거나, 정렬되지 않았거나, 유효하지 않은 값을 가리키는 참조/<code>Box</code>.</li>
<li>와이드 참조, <code>Box</code> 또는 원시 포인터에 유효하지 않은 메타데이터가 있는 경우:
<ul>
<li><code>dyn Trait</code> 메타데이터는 포인터나 참조가 가리키는 실제 동적 트레잇과 일치하는 <code>Trait</code>에 대한 vtable 포인터가 아닌 경우 유효하지 않습니다.</li>
<li>슬라이스 메타데이터는 길이가 유효한 <code>usize</code>가 아닌 경우(즉, 초기화되지 않은 메모리에서 읽어서는 안 됨) 유효하지 않습니다.</li>
</ul>
</li>
<li>null인 <a href="../std/ptr/struct.NonNull.html"><code>NonNull</code></a>과 같이 사용자 정의 유효하지 않은 값을 가진 타입이 해당 값 중 하나인 경우. (사용자 정의 유효하지 않은 값 요청은 불안정한 기능이지만, 'NonNull'과 같은 일부 안정적인 libstd 타입은 이를 사용합니다.)</li>
</ul>
</li>
</ul>
<p>"정의되지 않은 동작"에 대한 자세한 설명은 <a href="../reference/behavior-considered-undefined.html">참조</a>를 참조하십시오.</p>
<p>값 "생성"은 값이 할당되거나, 함수/기본 연산에 전달되거나, 함수/기본 연산에서 반환될 때마다 발생합니다.</p>
<p>참조/포인터는 null이거나 가리키는 모든 바이트가 동일한 할당의 일부가 아닌 경우 "댕글링" 상태입니다(따라서 특히 모든 바이트는 <em>어떤</em> 할당의 일부여야 합니다). 가리키는 바이트 범위는 포인터 값과 포인티 타입의 크기에 의해 결정됩니다. 결과적으로 범위가 비어 있으면 "댕글링"은 "null"과 같습니다. 슬라이스와 문자열은 전체 범위를 가리키므로 길이 메타데이터가 너무 크지 않도록 하는 것이 중요합니다(특히 할당, 따라서 슬라이스와 문자열은 <code>isize::MAX</code> 바이트보다 클 수 없습니다). 어떤 이유로 이것이 너무 번거롭다면 원시 포인터 사용을 고려하십시오.</p>
<p>이것이 전부입니다. 이것이 Rust에 내장된 정의되지 않은 동작의 모든 원인입니다. 물론, 안전하지 않은 함수와 트레잇은 프로그램이 정의되지 않은 동작을 피하기 위해 유지해야 하는 임의의 다른 제약 조건을 자유롭게 선언할 수 있습니다. 예를 들어, 할당자 API는 할당되지 않은 메모리를 해제하는 것이 정의되지 않은 동작이라고 선언합니다.</p>
<p>그러나 이러한 제약 조건 위반은 일반적으로 위 문제 중 하나로 전이적으로 이어질 뿐입니다. 일부 추가 제약 조건은 코드를 최적화하는 방법에 대한 특별한 가정을 하는 컴파일러 내장 함수에서 파생될 수도 있습니다. 예를 들어, Vec 및 Box는 포인터가 항상 null이 아니어야 하는 내장 함수를 사용합니다.</p>
<p>Rust는 다른 의심스러운 작업에 대해서는 상당히 관대합니다. Rust는 다음을 "안전"하다고 간주합니다.</p>
<ul>
<li>교착 상태</li>
<li><a href="races.html">경쟁 조건</a>을 가짐</li>
<li>메모리 누수</li>
<li>정수 오버플로( '+ ' 등 내장 연산자 사용 시)</li>
<li>프로그램 중단</li>
<li>운영 데이터베이스 삭제</li>
</ul>
<p>자세한 내용은 <a href="../reference/behavior-not-considered-unsafe.html">참조</a>를 참조하십시오.</p>
<p>그러나 실제로 그런 일을 하는 프로그램은 <em>아마도</em> 잘못되었을 것입니다. Rust는 이러한 일을 드물게 만드는 많은 도구를 제공하지만, 이러한 문제를 범주적으로 방지하는 것은 비현실적인 것으로 간주됩니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="안전하지-않은-코드와-함께-작업하기"><a class="header" href="#안전하지-않은-코드와-함께-작업하기">안전하지 않은 코드와 함께 작업하기</a></h1>
<p>Rust는 일반적으로 범위가 지정되고 이진적인 방식으로 Unsafe Rust에 대해 이야기할 수 있는 도구만 제공합니다. 불행히도 현실은 그보다 훨씬 더 복잡합니다. 예를 들어 다음 장난감 함수를 고려하십시오.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn index(idx: usize, arr: &amp;[u8]) -&gt; Option&lt;u8&gt; {
    if idx &lt; arr.len() {
        unsafe {
            Some(*arr.get_unchecked(idx))
        }
    } else {
        None
    }
}
<span class="boring">}</span></code></pre></pre>
<p>이 함수는 안전하고 정확합니다. 인덱스가 범위 내에 있는지 확인하고, 그렇다면 확인되지 않은 방식으로 배열에 인덱싱합니다. 우리는 이렇게 올바르게 안전하지 않게 구현된 함수를 _건전하다_고 말하며, 이는 안전한 코드가 이를 통해 정의되지 않은 동작을 유발할 수 없음을 의미합니다(기억하세요, 이것이 안전한 Rust의 단일 기본 속성입니다).</p>
<p>그러나 이렇게 사소한 함수에서도 unsafe 블록의 범위는 의심스럽습니다. '&lt;'를 '&lt;='로 변경하는 것을 고려하십시오.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn index(idx: usize, arr: &amp;[u8]) -&gt; Option&lt;u8&gt; {
    if idx &lt;= arr.len() {
        unsafe {
            Some(*arr.get_unchecked(idx))
        }
    } else {
        None
    }
}
<span class="boring">}</span></code></pre></pre>
<p>이 프로그램은 이제 _불건전_하며, 안전한 Rust가 정의되지 않은 동작을 유발할 수 있으며, <em>우리는 안전한 코드만 수정했습니다</em>. 이것이 안전의 근본적인 문제입니다. 즉, 비지역적입니다. 우리의 안전하지 않은 작업의 건전성은 필연적으로 다른 "안전한" 작업에 의해 설정된 상태에 따라 달라집니다.</p>
<p>안전은 비안전을 선택한다고 해서 다른 종류의 임의의 나쁜 점을 고려할 필요가 없다는 의미에서 모듈식입니다. 예를 들어, 슬라이스에 대한 확인되지 않은 인덱싱을 수행한다고 해서 갑자기 슬라이스가 null이거나 초기화되지 않은 메모리를 포함하는 것에 대해 걱정할 필요는 없습니다. 근본적으로 아무것도 바뀌지 않습니다. 그러나 안전은 프로그램이 본질적으로 상태 저장 방식이며 안전하지 않은 작업이 임의의 다른 상태에 따라 달라질 수 있다는 의미에서 모듈식이 <em>아닙니다</em>.</p>
<p>이 비지역성은 실제 영구 상태를 통합할 때 훨씬 더 악화됩니다. 'Vec'의 간단한 구현을 고려하십시오.</p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::ptr;

// 참고: 이 정의는 순진합니다. Vec 구현에 대한 장을 참조하십시오.
pub struct Vec&lt;T&gt; {
    ptr: *mut T,
    len: usize,
    cap: usize,
}

// 참고: 이 구현은 크기가 0인 타입을 올바르게 처리하지 않습니다.
// Vec 구현에 대한 장을 참조하십시오.
impl&lt;T&gt; Vec&lt;T&gt; {
    pub fn push(&amp;mut self, elem: T) {
        if self.len == self.cap {
            // 이 예제에서는 중요하지 않음
            self.reallocate();
        }
        unsafe {
            ptr::write(self.ptr.add(self.len), elem);
            self.len += 1;
        }
    }
<span class="boring">    fn reallocate(&amp;mut self) { }
</span>}

<span class="boring">fn main() {}</span></code></pre></pre>
<p>이 코드는 합리적으로 감사하고 비공식적으로 확인할 수 있을 만큼 간단합니다. 이제 다음 메서드를 추가하는 것을 고려하십시오.</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">fn make_room(&amp;mut self) {
    // 용량 늘리기
    self.cap += 1;
}</code></pre>
<p>이 코드는 100% 안전한 Rust이지만 완전히 불건전합니다. 용량을 변경하면 Vec의 불변성('cap'이 Vec에 할당된 공간을 반영한다는 것)을 위반합니다. 이것은 나머지 Vec이 방어할 수 있는 것이 아닙니다. 확인할 방법이 없기 때문에 용량 필드를 신뢰해야 <em>합니다</em>.</p>
<p>구조체 필드의 불변성에 의존하기 때문에 이 'unsafe' 코드는 전체 함수를 오염시키는 것 이상으로 전체 _모듈_을 오염시킵니다. 일반적으로 unsafe 코드의 범위를 제한하는 유일한 확실한 방법은 개인 정보 보호를 사용하는 모듈 경계입니다.</p>
<p>그러나 이것은 <em>완벽하게</em> 작동합니다. 'make_room'의 존재는 Vec의 건전성에 문제가 되지 않습니다. 왜냐하면 우리가 그것을 공개로 표시하지 않았기 때문입니다. 이 함수를 정의하는 모듈만 호출할 수 있습니다. 또한 'make_room'은 Vec의 개인 필드에 직접 액세스하므로 Vec과 동일한 모듈에서만 작성할 수 있습니다.</p>
<p>따라서 복잡한 불변성에 의존하는 완전히 안전한 추상화를 작성하는 것이 가능합니다. 이것은 안전한 Rust와 안전하지 않은 Rust 간의 관계에 _중요_합니다.</p>
<p>우리는 이미 Unsafe 코드가 <em>일부</em> 안전한 코드를 신뢰해야 하지만 <em>일반적인</em> 안전한 코드를 신뢰해서는 안 된다는 것을 보았습니다. 개인 정보 보호는 비슷한 이유로 unsafe 코드에 중요합니다. 즉, 우주의 모든 안전한 코드가 우리의 신뢰할 수 있는 상태를 망치는 것을 신뢰하지 않아도 되도록 합니다.</p>
<p>안전은 살아있다!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust의-데이터-표현"><a class="header" href="#rust의-데이터-표현">Rust의 데이터 표현</a></h1>
<p>저수준 프로그래밍은 데이터 레이아웃에 많은 신경을 씁니다. 이것은 큰 문제입니다. 또한 언어의 나머지 부분에 널리 영향을 미치므로 Rust에서 데이터가 어떻게 표현되는지 파고드는 것부터 시작하겠습니다.</p>
<p>이 장은 이상적으로는 <a href="../reference/type-layout.html">참조의 타입 레이아웃 섹션</a>과 일치하며, 이에 의해 중복됩니다. 이 책이 처음 작성되었을 때 참조는 완전히 망가져 있었고, Rustonomicon은 참조의 부분적인 대체 역할을 하려고 했습니다. 이제는 그렇지 않으므로 이 장 전체를 이상적으로 삭제할 수 있습니다.</p>
<p>이 장을 조금 더 유지하겠지만, 이상적으로는 새로운 사실이나 개선 사항을 참조에 대신 기여해야 합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reprrust"><a class="header" href="#reprrust">repr(Rust)</a></h1>
<p>무엇보다도 모든 타입에는 바이트 단위로 지정된 정렬이 있습니다. 타입의 정렬은 값을 저장할 수 있는 유효한 주소를 지정합니다. 정렬이 'n'인 값은 'n'의 배수인 주소에만 저장해야 합니다. 따라서 정렬 2는 짝수 주소에 저장해야 함을 의미하고, 1은 어디에나 저장할 수 있음을 의미합니다. 정렬은 최소 1이며 항상 2의 거듭제곱입니다.</p>
<p>기본 타입은 일반적으로 크기에 맞춰 정렬되지만, 이는 플랫폼별 동작입니다. 예를 들어, x86에서 'u64'와 'f64'는 종종 4바이트(32비트)에 정렬됩니다.</p>
<p>타입의 크기는 항상 정렬의 배수여야 합니다(0은 모든 정렬에 대해 유효한 크기임). 이렇게 하면 해당 타입의 배열은 항상 크기의 배수로 오프셋하여 인덱싱할 수 있습니다. <a href="exotic-sizes.html#dynamically-sized-types-dsts">동적으로 크기가 지정된 타입</a>의 경우 타입의 크기와 정렬이 정적으로 알려지지 않을 수 있습니다.</p>
<p>Rust는 복합 데이터를 배치하는 다음과 같은 방법을 제공합니다.</p>
<ul>
<li>구조체 (명명된 곱 타입)</li>
<li>튜플 (익명 곱 타입)</li>
<li>배열 (동종 곱 타입)</li>
<li>열거형 (명명된 합 타입 -- 태그된 공용체)</li>
<li>공용체 (태그 없는 공용체)</li>
</ul>
<p>열거형의 어떤 변형도 연관된 데이터를 갖지 않으면 <em>필드 없는</em> 열거형이라고 합니다.</p>
<p>기본적으로 복합 구조체는 필드 정렬의 최댓값과 동일한 정렬을 갖습니다. 따라서 러스트는 모든 필드가 적절하게 정렬되고 전체 타입의 크기가 정렬의 배수가 되도록 필요한 경우 패딩을 삽입합니다. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A {
    a: u8,
    b: u32,
    c: u16,
}
<span class="boring">}</span></code></pre></pre>
<p>기본 타입을 각각의 크기에 맞춰 정렬하는 타겟에서는 32비트 정렬됩니다. 따라서 전체 구조체는 32비트의 배수인 크기를 갖게 됩니다. 다음과 같이 될 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A {
    a: u8,
    _pad1: [u8; 3], // `b`를 정렬하기 위해
    b: u32,
    c: u16,
    _pad2: [u8; 2], // 전체 크기를 4의 배수로 만들기 위해
}
<span class="boring">}</span></code></pre></pre>
<p>또는 다음과 같을 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A {
    b: u32,
    c: u16,
    a: u8,
    _pad: u8,
}
<span class="boring">}</span></code></pre></pre>
<p>이러한 타입들에 대해서는 _간접 참조(indirection)_가 없습니다. C에서 기대하는 것처럼 모든 데이터는 구조체 내에 저장됩니다. 하지만 배열(밀밀하게 패킹되어 순서대로 배치됨)을 제외하고, 데이터의 레이아웃은 기본적으로 지정되지 않습니다. 다음 두 구조체 정의가 주어졌을 때:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A {
    a: i32,
    b: u64,
}

struct B {
    a: i32,
    b: u64,
}
<span class="boring">}</span></code></pre></pre>
<p>러스트는 A의 두 인스턴스가 정확히 동일한 방식으로 데이터를 배치하도록 <em>보장합니다</em>. 하지만 러스트는 현재 A의 인스턴스가 B의 인스턴스와 동일한 필드 순서나 패딩을 갖는다는 것을 보장하지 <em>않습니다</em>.</p>
<p>작성된 대로의 A와 B를 보면 이 점이 지나치게 세세해 보일 수 있지만, 러스트의 다른 여러 기능으로 인해 언어가 복잡한 방식으로 데이터 레이아웃을 다루는 것이 바람직합니다.</p>
<p>예를 들어, 다음 구조체를 고려해 보세요:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;T, U&gt; {
    count: u16,
    data1: T,
    data2: U,
}
<span class="boring">}</span></code></pre></pre>
<p>이제 <code>Foo&lt;u32, u16&gt;</code>과 <code>Foo&lt;u16, u32&gt;</code>의 단형성화(monomorphization)를 고려해 보세요. 러스트가 지정된 순서대로 필드를 배치한다면, 정렬 요구 사항을 충족하기 위해 구조체의 값을 패딩할 것으로 예상됩니다. 따라서 러스트가 필드 순서를 변경하지 않는다면 다음과 같이 생성될 것입니다:</p>
<!-- ignore: explanation code -->
<pre><code class="language-rust ignore">struct Foo&lt;u16, u32&gt; {
    count: u16,
    data1: u16,
    data2: u32,
}

struct Foo&lt;u32, u16&gt; {
    count: u16,
    _pad1: u16,
    data1: u32,
    data2: u16,
    _pad2: u16,
}</code></pre>
<p>후자의 경우는 단순히 공간을 낭비합니다. 최적의 공간 사용을 위해서는 서로 다른 단형성화가 _서로 다른 필드 순서_를 가져야 합니다.</p>
<p>열거형(Enum)은 이러한 고려 사항을 훨씬 더 복잡하게 만듭니다. 단순하게 다음과 같은 열거형을 생각해보면:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Foo {
    A(u32),
    B(u64),
    C(u8),
}
<span class="boring">}</span></code></pre></pre>
<p>다음과 같이 배치될 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct FooRepr {
    data: u64, // 이는 `tag`에 따라 u64, u32 또는 u8 중 하나입니다
    tag: u8,   // 0 = A, 1 = B, 2 = C
}
<span class="boring">}</span></code></pre></pre>
<p>그리고 실제로 이것이 대략적인 배치 방식입니다(<code>tag</code>의 크기와 위치에 따라 다를 수 있음).</p>
<p>하지만 이러한 표현이 비효율적인 경우가 몇 가지 있습니다. 그 전형적인 사례가 러스트의 "널 포인터 최적화(null pointer optimization)"입니다. 하나의 외부 유닛 변형(예: <code>None</code>)과 (잠재적으로 중첩된) null이 불가능한 포인터 변형(예: <code>Some(&amp;T)</code>)으로 구성된 열거형은 태그를 필요로 하지 않습니다. 널 포인터는 안전하게 유닛(<code>None</code>) 변형으로 해석될 수 있습니다. 그 결과, 예를 들어 <code>size_of::&lt;Option&lt;&amp;T&gt;&gt;() == size_of::&lt;&amp;T&gt;()</code>가 성립합니다.</p>
<p>러스트에는 <code>Box&lt;T&gt;</code>, <code>Vec&lt;T&gt;</code>, <code>String</code>, <code>&amp;T</code>, <code>&amp;mut T</code>와 같이 null이 불가능한 포인터이거나 이를 포함하는 타입이 많습니다. 이와 유사하게, 중첩된 열거형들이 정의상 유효한 값의 범위가 제한되어 있다는 점을 이용해 태그들을 하나의 판별자(discriminant)로 모으는 것을 상상할 수 있습니다. 원칙적으로 열거형은 금지된 값을 가진 중첩된 타입 전체에 비트를 저장하는 상당히 정교한 알고리즘을 사용할 수 있습니다. 따라서 오늘날 열거형 레이아웃을 지정하지 않은 상태로 두는 것이 <em>특히</em> 바람직합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="이례적인-크기의-타입"><a class="header" href="#이례적인-크기의-타입">이례적인 크기의 타입</a></h1>
<p>대부분의 경우, 우리는 타입이 정적으로 알려진 양수의 크기를 가질 것으로 기대합니다. 하지만 러스트에서는 항상 그런 것은 아닙니다.</p>
<h2 id="동적으로-크기가-지정된-타입dsts"><a class="header" href="#동적으로-크기가-지정된-타입dsts">동적으로 크기가 지정된 타입(DSTs)</a></h2>
<p>러스트는 동적으로 크기가 지정된 타입(DSTs)을 지원합니다. 이는 정적으로 알려진 크기나 정렬이 없는 타입입니다. 겉보기에는 조금 말이 안 되는 것 같을 수 있습니다. 러스트가 무언가를 올바르게 다루려면 그것의 크기와 정렬을 <em>반드시</em> 알아야 하기 때문입니다! 이런 점에서 DST는 일반적인 타입이 아닙니다. 정적으로 알려진 크기가 없기 때문에, 이러한 타입은 포인터 뒤에만 존재할 수 있습니다. 따라서 DST에 대한 모든 포인터는 포인터와 그것들을 "완성하는" 정보로 구성된 <em>와이드(wide)</em> 포인터가 됩니다(이에 대한 자세한 내용은 아래를 참조하세요).</p>
<p>언어에서 노출하는 두 가지 주요 DST가 있습니다:</p>
<ul>
<li>트레잇 객체(trait objects): <code>dyn MyTrait</code></li>
<li>슬라이스(slices): <a href="../std/primitive.slice.html"><code>[T]</code></a>, <a href="../std/primitive.str.html"><code>str</code></a> 등</li>
</ul>
<p>트레잇 객체는 지정된 트레잇을 구현하는 어떤 타입을 나타냅니다. 원래의 구체적인 타입은 타입 사용에 필요한 모든 정보를 담고 있는 vtable을 이용한 런타임 리플렉션을 위해 <em>지워집니다(erased)</em>. 트레잇 객체 포인터를 완성하는 정보는 vtable 포인터입니다. 피지칭자(pointee)의 런타임 크기는 vtable에서 동적으로 요청할 수 있습니다.</p>
<p>슬라이스는 단순히 어떤 연속적인 저장 공간(일반적으로 배열이나 <code>Vec</code>)에 대한 뷰입니다. 슬라이스 포인터를 완성하는 정보는 단순히 그것이 가리키는 요소의 개수입니다. 피지칭자의 런타임 크기는 단순히 요소의 정적으로 알려진 크기에 요소의 개수를 곱한 값입니다.</p>
<p>구조체는 실제로 마지막 필드로 단일 DST를 직접 저장할 수 있지만, 이 경우 해당 구조체 역시 DST가 됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 스택에 직접 저장할 수 없음
struct MySuperSlice {
    info: u32,
    data: [u8],
}
<span class="boring">}</span></code></pre></pre>
<p>불행히도, 이러한 타입은 생성할 방법이 없다면 거의 무용지물입니다. 현재 사용자 정의 DST를 만드는 유일하게 제대로 지원되는 방법은 타입을 제네릭으로 만들고 _언사이징 강제 변환(unsizing coercion)_을 수행하는 것입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024">struct MySuperSliceable&lt;T: ?Sized&gt; {
    info: u32,
    data: T,
}

fn main() {
    let sized: MySuperSliceable&lt;[u8; 8]&gt; = MySuperSliceable {
        info: 17,
        data: [0; 8],
    };

    let dynamic: &amp;MySuperSliceable&lt;[u8]&gt; = &amp;sized;

    // 출력: "17 [0, 0, 0, 0, 0, 0, 0, 0]"
    println!("{} {:?}", dynamic.info, &amp;dynamic.data);
}</code></pre></pre>
<p>(그렇습니다. 사용자 정의 DST는 현재로서는 상당히 미완성된 기능입니다.)</p>
<h2 id="크기가-0인-타입zsts"><a class="header" href="#크기가-0인-타입zsts">크기가 0인 타입(ZSTs)</a></h2>
<p>러스트는 또한 공간을 차지하지 않는 타입을 지정할 수 있게 해줍니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Nothing; // 필드 없음 = 크기 없음

// 모든 필드가 크기 없음 = 크기 없음
struct LotsOfNothing {
    foo: Nothing,
    qux: (),      // 빈 튜플은 크기가 없음
    baz: [u8; 0], // 빈 배열은 크기가 없음
}
<span class="boring">}</span></code></pre></pre>
<p>크기가 0인 타입(ZSTs)은 그 자체로는 분명한 이유로 꽤 무용지물입니다. 하지만 러스트의 많은 기묘한 레이아웃 선택과 마찬가지로, 이들의 잠재력은 제네릭 문맥에서 실현됩니다. 러스트는 ZST를 생성하거나 저장하는 모든 작업이 무연산(no-op)으로 축소될 수 있음을 잘 알고 있습니다. 우선, 그것을 저장하는 것은 의미조차 없습니다. 공간을 전혀 차지하지 않기 때문입니다. 또한 해당 타입의 값은 단 하나뿐이므로, 그것을 로드하는 모든 작업은 그냥 허공(aether)에서 생성해낼 수 있습니다. 이 또한 공간을 차지하지 않으므로 무연산입니다.</p>
<p>이것의 가장 극단적인 예 중 하나는 집합(Set)과 맵(Map)입니다. <code>Map&lt;Key, Value&gt;</code>가 주어졌을 때, <code>Set&lt;Key&gt;</code>를 단순히 <code>Map&lt;Key, UselessJunk&gt;</code>를 감싸는 얇은 래퍼로 구현하는 것이 일반적입니다. 많은 언어에서 이는 <code>UselessJunk</code>를 위한 공간을 할당하고, 그것을 저장하고 로드한 뒤 버리는 작업을 필요로 합니다. 이것이 불필요하다는 것을 증명하는 것은 컴파일러에게 어려운 분석일 것입니다.</p>
<p>하지만 러스트에서는 단순히 <code>Set&lt;Key&gt; = Map&lt;Key, ()&gt;</code>라고 말할 수 있습니다. 이제 러스트는 모든 로드와 저장이 무의미하고 어떤 할당도 크기를 갖지 않는다는 것을 정적으로 압니다. 그 결과, 단형성화된 코드는 기본적으로 <code>HashMap</code>이 값을 지원하기 위해 가져야 하는 오버헤드가 전혀 없는 <code>HashSet</code>의 커스텀 구현체가 됩니다.</p>
<p>안전한 코드는 ZST에 대해 걱정할 필요가 없지만, <em>안전하지 않은(unsafe)</em> 코드는 크기가 없는 타입의 결과에 주의해야 합니다. 특히, 포인터 오프셋은 무연산이며, 할당자는 일반적으로 <a href="../std/alloc/trait.GlobalAlloc.html#tymethod.alloc">0이 아닌 크기를 요구합니다</a>.</p>
<p>Note that references to ZSTs (including empty slices), just like all other references, must be non-null and suitably aligned. However, loading or storing through a null pointer to a ZST is not <a href="what-unsafe-does.html">undefined behavior</a>, unlike pointers to other types.</p>
<h2 id="빈-타입empty-types"><a class="header" href="#빈-타입empty-types">빈 타입(Empty Types)</a></h2>
<p>러스트는 또한 <em>심지어 인스턴스화할 수도 없는</em> 타입을 선언할 수 있게 해줍니다. 이러한 타입은 타입 수준에서만 논의될 수 있으며, 값 수준에서는 절대 존재할 수 없습니다. 빈 타입은 변형(variant)이 없는 열거형(enum)을 지정하여 선언할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Void {} // 변형 없음 = 비어 있음(EMPTY)
<span class="boring">}</span></code></pre></pre>
<p>빈 타입은 ZST보다 훨씬 더 미미한 존재입니다. 빈 타입을 사용하는 주된 동기 부여 사례는 타입 수준의 도달 불가능성(type-level unreachability)입니다. 예를 들어, 어떤 API가 일반적으로 <code>Result</code>를 반환해야 하지만, 특정한 경우에는 실제로는 절대 실패하지 않는(infallible) 상황을 가정해 봅시다. <code>Result&lt;T, Void&gt;</code>를 반환함으로써 이를 타입 수준에서 전달하는 것이 가능합니다. 이 API의 사용자는 이 값이 <code>Err</code>이 되는 것이 _정적으로 불가능_하다는 것을 알기 때문에 안심하고 <code>unwrap</code>할 수 있습니다. <code>Err</code>이 되려면 <code>Void</code> 타입의 값을 제공해야 하기 때문입니다.</p>
<p>원칙적으로 러스트는 이 사실에 기반하여 흥미로운 분석과 최적화를 수행할 수 있습니다. 예를 들어, <code>Result&lt;T, Void&gt;</code>는 단순히 <code>T</code>로 표현되는데, 이는 <code>Err</code> 케이스가 실제로 존재하지 않기 때문입니다(엄밀히 말하면 이는 보장되지 않는 최적화일 뿐이므로, 예를 들어 하나를 다른 하나로 <code>transmute</code>하는 것은 여전히 정의되지 않은 동작입니다).</p>
<p>다음 코드도 컴파일됩니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Void {}

let res: Result&lt;u32, Void&gt; = Ok(0);

// Err가 더 이상 존재하지 않으므로, Ok는 실제로 반박 불가능(irrefutable)합니다.
let Ok(num) = res;
<span class="boring">}</span></code></pre></pre>
<p>빈 타입에 관한 한 가지 마지막 미묘한 세부 사항은 빈 타입에 대한 원시 포인터를 생성하는 것은 실제로 유효하지만, 이를 역참조하는 것은 말이 되지 않으므로 정의되지 않은 동작이라는 점입니다.</p>
<p>C의 <code>void*</code> 타입을 <code>*const Void</code>로 모델링하는 것은 권장하지 않습니다. 많은 사람들이 그렇게 하기 시작했지만, 곧 문제에 봉착했습니다. 러스트는 unsafe 코드를 통해 빈 타입을 인스턴스화하려는 시도에 대해 별다른 안전 장치가 없으며, 그렇게 할 경우 정의되지 않은 동작이 발생하기 때문입니다. 특히 개발자들이 원시 포인터를 참조로 변환하는 습관이 있었는데, <code>&amp;Void</code>를 생성하는 것 <em>역시</em> 정의되지 않은 동작이라는 점이 문제가 되었습니다.</p>
<p><code>*const ()</code>(또는 그와 동등한 타입)는 <code>void*</code> 용도로 꽤 잘 작동하며, 안전성 문제 없이 참조로 변환될 수 있습니다. 여전히 값을 읽거나 쓰려는 시도를 막지는 못하지만, 적어도 정의되지 않은 동작 대신 무연산으로 컴파일됩니다.</p>
<h2 id="외부-타입extern-types"><a class="header" href="#외부-타입extern-types">외부 타입(Extern Types)</a></h2>
<p>알 수 없는 크기를 가진 적절한 타입인 _외부 타입(extern types)_을 추가하자는 <a href="https://github.com/rust-lang/rfcs/blob/master/text/1861-extern-types.md">승인된 RFC</a>가 있습니다. 이는 러스트 개발자들이 C의 <code>void*</code> 및 기타 "선언되었으나 정의되지 않은" 타입들을 더 정확하게 모델링할 수 있게 해줄 것입니다. 하지만 러스트 2018 기준으로, <a href="https://github.com/rust-lang/rust/issues/43467">이 기능은 <code>size_of_val::&lt;MyExternType&gt;()</code>이 어떻게 작동해야 하는지에 대한 문제로 교착 상태에 빠져 있습니다</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="대체-표현alternative-representations"><a class="header" href="#대체-표현alternative-representations">대체 표현(Alternative representations)</a></h1>
<p>Rust allows you to specify alternative data layout strategies from the default.</p>
<h2 id="reprc"><a class="header" href="#reprc">repr(C)</a></h2>
<p>이것은 가장 중요한 <code>repr</code>입니다. 이것의 의도는 상당히 단순합니다. 즉, C가 하는 대로 하는 것입니다. 필드의 순서, 크기 및 정렬은 C 또는 C++에서 기대하는 것과 정확히 일치합니다. 또한 이 타입은 C가 해당 타입을 전달하는 것과 동일한 방식으로 <code>extern "C"</code> 함수 호출 경계를 넘나듭니다. FFI 경계를 통과할 것으로 예상되는 모든 타입은 <code>repr(C)</code>를 가져야 합니다. C는 프로그래밍 세계의 공용어(lingua-franca)이기 때문입니다. 이는 또한 값을 다른 타입으로 재해석하는 것과 같이 데이터 레이아웃을 이용한 더 정교한 기술을 안정적으로 수행하는 데 필요합니다.</p>
<p>FFI 경계를 관리하기 위해 <a href="https://rust-lang.github.io/rust-bindgen/">rust-bindgen</a> 및/또는 <a href="https://github.com/eqrion/cbindgen">cbindgen</a>을 사용하는 것을 강력히 권장합니다. 러스트 팀은 이러한 프로젝트들과 긴밀히 협력하여, 이들이 견고하게 작동하고 타입 레이아웃 및 <code>repr</code>에 대한 현재 및 미래의 보증과 호환되도록 보장합니다.</p>
<p><code>repr(C)</code>와 러스트의 더 이례적인 데이터 레이아웃 기능 간의 상호 작용을 염두에 두어야 합니다. "FFI용" 및 "레이아웃 제어용"이라는 이중 목적 때문에, <code>repr(C)</code>는 FFI 경계를 통과할 경우 무의미하거나 문제가 될 수 있는 타입에도 적용될 수 있습니다.</p>
<ul>
<li>
<p>ZST는 여전히 크기가 0입니다. 비록 이것이 C의 표준 동작은 아니며, 한 바이트의 공간을 소비해야 한다는 C++의 빈 타입 동작과도 명시적으로 반대되지만 말입니다.</p>
</li>
<li>
<p>DST 포인터(와이드 포인터)와 튜플은 C에는 없는 개념이므로, 결코 FFI에 안전하지(FFI-safe) 않습니다.</p>
</li>
<li>
<p>필드가 있는 열거형 또한 C나 C++에는 없는 개념이지만, 타입들 간의 유효한 가교(bridging)가 <a href="https://github.com/rust-lang/rfcs/blob/master/text/2195-really-tagged-unions.md">정의되어 있습니다</a>.</p>
</li>
<li>
<p><code>T</code>가 <a href="ffi.html#the-nullable-pointer-optimization">FFI에 안전한 null이 불가능한 포인터 타입</a>인 경우, <code>Option&lt;T&gt;</code>는 <code>T</code>와 동일한 레이아웃 및 ABI를 갖는 것이 보장되며 따라서 FFI에도 안전합니다. 이 글을 쓰는 시점에서 이는 <code>&amp;</code>, <code>&amp;mut</code>, 그리고 절대 null이 될 수 없는 함수 포인터들을 포함합니다.</p>
</li>
<li>
<p>튜플 구조체는 필드 이름이 없다는 점만 제외하면 구조체와 동일하므로 <code>repr(C)</code>에 관해서는 구조체와 같습니다.</p>
</li>
<li>
<p><code>repr(C)</code>는 필드 없는 열거형에 대해 <code>repr(u*)</code>(다음 섹션 참조) 중 하나와 동일합니다. 선택되는 크기와 부호는 대상 플랫폼의 C 응용 프로그램 이진 인터페이스(ABI)에 대한 기본 열거형 크기 및 부호입니다. C에서 열거형 표현은 구현에 따라 다르므로, 이는 실제로는 "최선의 추측"입니다. 특히, 관심 있는 C 코드가 특정 플래그로 컴파일된 경우 이는 올바르지 않을 수 있습니다.</p>
</li>
<li>
<p><code>repr(C)</code> 또는 <code>repr(u*)</code>가 있는 필드 없는 열거형은 C나 C++에서는 허용되는 동작임에도 불구하고, 여전히 대응하는 변형(variant) 없이 정수 값으로 설정될 수 없습니다. 변형 중 하나와 일치하지 않는 열거형 인스턴스를 (안전하지 않게) 생성하는 것은 정의되지 않은 동작입니다. (이를 통해 모든 경우를 다루는 매치(exhaustive match)가 정상적으로 작성되고 컴파일될 수 있습니다.)</p>
</li>
</ul>
<h2 id="reprtransparent"><a class="header" href="#reprtransparent">repr(transparent)</a></h2>
<p><code>#[repr(transparent)]</code>는 단일한 0이 아닌 크기의 필드를 가진 구조체나 단일 변형 열거형에만 사용할 수 있습니다(추가적인 크기 0 필드가 있을 수 있습니다). 그 효과는 전체 구조체/열거형의 레이아웃과 ABI가 해당 단일 필드와 동일함이 보장된다는 것입니다.</p>
<blockquote>
<p>참고: 공용체(union)에 <code>repr(transparent)</code>를 적용하기 위한 <code>transparent_unions</code> 나이틀리 기능이 있지만, 설계상의 우려로 인해 아직 안정화되지 않았습니다. 자세한 내용은 <a href="https://github.com/rust-lang/rust/issues/60405">트래킹 이슈</a>를 참조하세요.</p>
</blockquote>
<p>그 목표는 단일 필드와 구조체/열거형 간의 <code>transmute</code>를 가능하게 하는 것입니다. 그 예로 <a href="../std/cell/struct.UnsafeCell.html"><code>UnsafeCell</code></a>이 있는데, 이는 자신이 감싸고 있는 타입으로 <code>transmute</code> 될 수 있습니다. (<a href="../std/cell/struct.UnsafeCell.html"><code>UnsafeCell</code></a>은 또한 불안정한 <a href="https://github.com/rust-lang/rust/pull/68491">no_niche</a>를 사용하므로, 다른 타입 내에 중첩될 때 ABI가 동일하다고 보장되지는 않습니다.)</p>
<p>또한, 반대편에서 내부 필드 타입을 기대하는 FFI를 통해 구조체/열거형을 전달하는 것도 정상적으로 작동함이 보장됩니다. 특히, 이는 <code>struct Foo(f32)</code> 또는 <code>enum Foo { Bar(f32) }</code>가 항상 <code>f32</code>와 동일한 ABI를 갖도록 하는 데 필요합니다.</p>
<p>이 repr은 단일 필드가 <code>pub</code>이거나 레이아웃이 글로 문서화된 경우에만 타입의 공개 ABI의 일부로 간주됩니다. 그렇지 않으면 다른 크레이트에서 이 레이아웃에 의존해서는 안 됩니다.</p>
<p>더 자세한 내용은 <a href="https://github.com/rust-lang/rfcs/blob/master/text/1758-repr-transparent.md">RFC 1758</a> 및 <a href="https://rust-lang.github.io/rfcs/2645-transparent-unions.html">RFC 2645</a>에 있습니다.</p>
<h2 id="repru-repri"><a class="header" href="#repru-repri">repr(u*), repr(i*)</a></h2>
<p>이것들은 필드 없는 열거형의 크기와 부호를 지정합니다. 만약 판별자(discriminant)가 들어갈 정수 타입을 오버플로하면 컴파일 타임 에러가 발생합니다. 오버플로하는 요소를 명시적으로 0으로 설정하여 러스트가 이를 허용하도록 수동으로 요청할 수 있습니다. 하지만 러스트는 두 변형이 동일한 판별자를 갖는 열거형을 만드는 것을 허용하지 않습니다.</p>
<p>"필드 없는 열거형"이라는 용어는 단순히 열거형의 어떤 변형도 데이터를 가지고 있지 않다는 것을 의미합니다. <code>repr</code>이 없는 필드 없는 열거형은 여전히 러스트 고유 타입이며, 안정적인 레이아웃이나 표현을 갖지 않습니다. <code>repr(u*)</code>/<code>repr(i*)</code>를 추가하면 레이아웃 목적으로 지정된 정수 타입과 정확히 동일하게 처리됩니다(다만 컴파일러는 이 열거형이 <code>Option</code>으로 감싸질 때와 같이 열거형 레이아웃을 최적화하기 위해 이 타입의 "유효하지 않은" 값에 대한 지식을 여전히 활용합니다). 이러한 타입들에 대한 함수 호출 ABI는 일반적으로 여전히 지정되지 않았지만, <code>extern "C"</code> 호출 시에는 동일한 부호와 크기를 가진 C 열거형과 ABI 호환됩니다.</p>
<p>열거형에 필드가 있는 경우, 그 효과는 타입의 정의된 레이아웃이 있다는 점에서 <code>repr(C)</code>의 효과와 유사합니다. 이를 통해 열거형을 C 코드로 전달하거나, 타입의 원시 표현에 접근하여 태그와 필드를 직접 조작할 수 있습니다. 자세한 내용은 <a href="https://github.com/rust-lang/rfcs/blob/master/text/2195-really-tagged-unions.md">RFC</a>를 참조하세요.</p>
<p>이러한 <code>repr</code>들은 구조체에는 아무런 영향을 주지 않습니다.</p>
<p>필드가 있는 열거형에 명시적인 <code>repr(u*)</code>, <code>repr(i*)</code>, 또는 <code>repr(C)</code>를 추가하면 다음과 같이 널 포인터 최적화(null-pointer optimization)가 억제됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::mem::size_of;
</span>enum MyOption&lt;T&gt; {
    Some(T),
    None,
}

#[repr(u8)]
enum MyReprOption&lt;T&gt; {
    Some(T),
    None,
}

assert_eq!(8, size_of::&lt;MyOption&lt;&amp;u16&gt;&gt;());
assert_eq!(16, size_of::&lt;MyReprOption&lt;&amp;u16&gt;&gt;());
<span class="boring">}</span></code></pre></pre>
<p>이 최적화는 명시적인 <code>repr(u*)</code>, <code>repr(i*)</code>, 또는 <code>repr(C)</code>가 있는 필드 없는 열거형에는 여전히 적용됩니다.</p>
<h2 id="reprpacked-reprpackedn"><a class="header" href="#reprpacked-reprpackedn">repr(packed), repr(packed(n))</a></h2>
<p><code>repr(packed(n))</code>(<code>n</code>은 2의 거듭제곱)은 타입이 <em>최대</em> <code>n</code>의 정렬을 갖도록 강제합니다. 명시적인 <code>n</code> 없이 가장 흔히 사용되는 <code>repr(packed)</code>는 <code>repr(packed(1))</code>과 동일하며, 이는 러스트가 모든 패딩을 제거하고 타입을 바이트 단위로만 정렬하도록 강제합니다. 이는 메모리 사용량을 개선할 수 있지만, 다른 부정적인 부작용을 일으킬 가능성이 높습니다.</p>
<p>특히 대부분의 아키텍처는 값이 자연스럽게 정렬되는 것을 <em>강력하게</em> 선호합니다. 이는 정렬되지 않은 로드가 성능 저하를 일으키거나(x86), 심지어 오류를 발생시킬 수 있음(일부 ARM 칩)을 의미합니다. 패킹된 필드를 직접 로드하거나 저장하는 것과 같은 단순한 경우에는 컴파일러가 시프트와 마스크 연산으로 정렬 문제를 보완할 수 있습니다. 하지만 패킹된 필드에 대한 참조를 취하는 경우, 컴파일러가 정렬되지 않은 로드를 피하기 위한 코드를 생성할 가능성은 낮습니다.</p>
<p><a href="https://github.com/rust-lang/rust/issues/27060">이것은 정의되지 않은 동작을 일으킬 수 있으므로</a>, 린트(lint)가 구현되었으며 앞으로는 치명적인 에러(hard error)가 될 것입니다.</p>
<p><code>repr(packed)/repr(packed(n))</code>은 가볍게 사용해서는 안 됩니다. 아주 극단적인 요구 사항이 없는 한 사용하지 말아야 합니다.</p>
<p>This repr is a modifier on <code>repr(C)</code> and <code>repr(Rust)</code>. For FFI compatibility you most likely always want to be explicit: <code>repr(C, packed)</code>.</p>
<h2 id="repralignn"><a class="header" href="#repralignn">repr(align(n))</a></h2>
<p><code>repr(align(n))</code>(<code>n</code>은 2의 거듭제곱)은 타입이 <em>최소</em> <code>n</code>의 정렬을 갖도록 강제합니다.</p>
<p>이를 통해 배열의 인접한 요소들이 서로 동일한 캐시 라인을 공유하지 않도록 보장하는 것과 같은 여러 기술이 가능해집니다(이는 특정 종류의 동시성 코드의 속도를 높일 수 있습니다).</p>
<p>이것은 <code>repr(C)</code> 및 <code>repr(Rust)</code>에 대한 수식어입니다. <code>repr(packed)</code>와는 호환되지 않습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="소유권과-수명ownership-and-lifetimes"><a class="header" href="#소유권과-수명ownership-and-lifetimes">소유권과 수명(Ownership and Lifetimes)</a></h1>
<p>소유권은 러스트의 획기적인 기능입니다. 소유권 덕분에 러스트는 가비지 컬렉션을 피하면서도 완전히 메모리에 안전하고 효율적일 수 있습니다. 소유권 시스템에 대해 자세히 알아보기 전에, 이 설계의 동기를 먼저 살펴보겠습니다.</p>
<p>우리는 여러분이 가비지 컬렉션(GC)이 항상 최적의 솔루션은 아니며, 일부 상황에서는 메모리를 수동으로 관리하는 것이 바람직하다는 점을 받아들인다고 가정하겠습니다. 만약 이것을 받아들이지 못하신다면, 다른 언어를 추천해 드려도 될까요?</p>
<p>GC에 대해 어떻게 생각하든, GC가 코드를 안전하게 만드는 데 <em>엄청난</em> 혜택을 준다는 것은 매우 분명합니다. 여러분은 어떤 것이 <em>너무 일찍</em> 사라지는 것에 대해 걱정할 필요가 없습니다(물론 여전히 그것을 가리키고 싶은지는 별개의 문제입니다만...). 이것은 C와 C++ 프로그램이 다루어야 하는 만연한 문제입니다. GC가 없는 언어를 사용해 본 우리 모두가 한 번쯤 저질러 봤을 법한 간단한 실수를 예로 들어보겠습니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn as_str(data: &amp;u32) -&gt; &amp;str {
    // 문자열 계산
    let s = format!("{}", data);

    // 오 안 돼! 이 함수 내에서만 존재하는 무언가에 대한
    // 참조를 반환했습니다!
    // 댕글링 포인터! 해제 후 사용(Use after free)! 아아!
    // (이 코드는 러스트에서 컴파일되지 않습니다)
    &amp;s
}
<span class="boring">}</span></code></pre></pre>
<p>이것이 바로 러스트의 소유권 시스템이 해결하고자 하는 문제입니다. 러스트는 <code>&amp;s</code>가 유효한 범위를 알고 있으며, 따라서 그것이 탈출(escape)하는 것을 막을 수 있습니다. 하지만 이는 C 컴파일러도 그럴듯하게 잡아낼 수 있는 간단한 사례입니다. 코드가 커지고 포인터가 다양한 함수를 거치면서 상황은 더 복잡해집니다. 결국 C 컴파일러는 한계에 부딪혀 코드가 불건전하다는 것을 증명하기 위한 충분한 탈출 분석(escape analysis)을 수행할 수 없게 됩니다. 결과적으로 프로그램이 올바르다는 가정하에 수락할 수밖에 없습니다.</p>
<p>러스트에서는 이런 일이 절대 일어나지 않습니다. 모든 것이 건전하다는 것을 컴파일러에게 증명하는 것은 프로그래머의 몫입니다.</p>
<p>물론 소유권에 대한 러스트의 이야기는 단순히 참조가 지칭 대상의 범위를 벗어나지 않는지 확인하는 것보다 훨씬 더 복잡합니다. 포인터가 항상 유효하도록 보장하는 것은 이보다 훨씬 복잡하기 때문입니다. 예를 들어 이 코드에서,</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut data = vec![1, 2, 3];
// 내부 참조 획득
let x = &amp;data[0];

// 오 안 돼! `push`는 `data`의 배후 저장 공간이 재할당되도록 만듭니다.
// 댕글링 포인터! 해제 후 사용! 아아!
// (이 코드는 러스트에서 컴파일되지 않습니다)
data.push(4);

println!("{}", x);
<span class="boring">}</span></code></pre></pre>
<p>단순한 범위 분석으로는 이 버그를 방지하기에 불충분합니다. <code>data</code>는 실제로 우리가 필요한 만큼 오래 살기 때문입니다. 하지만 우리가 그 내부를 참조하는 동안 그것이 _변경_되었습니다. 이것이 바로 러스트가 모든 참조에 대해 지칭 대상과 그 소유자를 동결(freeze)하도록 요구하는 이유입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="참조"><a class="header" href="#참조">참조</a></h1>
<p>참조에는 두 가지 종류가 있습니다.</p>
<ul>
<li>공유 참조: <code>&amp;</code></li>
<li>가변 참조: <code>&amp;mut</code></li>
</ul>
<p>이들은 다음 규칙을 따릅니다.</p>
<ul>
<li>참조는 그 지칭 대상(referent)보다 오래 살 수 없습니다.</li>
<li>가변 참조는 별칭(alias)될 수 없습니다.</li>
</ul>
<p>그게 전부입니다. 이것이 참조가 따르는 전체 모델입니다.</p>
<p>물론, 우리는 _별칭(aliased)_이 무엇을 의미하는지 정의해야 할 것입니다.</p>
<pre><code class="language-text">error[E0425]: 이 스코프에서 `aliased`라는 값을 찾을 수 없습니다
 --&gt; &lt;rust.rs&gt;:2:20
  |
2 |     println!("{}", aliased);
  |                    ^^^^^^^ 이 스코프에서 찾을 수 없음

error: 이전 에러로 인해 중단됨
</code></pre>
<p>불행히도, 러스트는 아직 실제로 별칭 모델을 정의하지 않았습니다. 🙀</p>
<p>러스트 개발자들이 언어의 의미론(semantics)을 구체화하기를 기다리는 동안, 다음 섹션에서 일반적인 별칭이 무엇인지, 그리고 그것이 왜 중요한지 논의해 보겠습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="별칭"><a class="header" href="#별칭">별칭</a></h1>
<p>먼저, 몇 가지 중요한 주의 사항을 짚고 넘어가겠습니다.</p>
<ul>
<li>
<p>논의를 위해 가능한 한 가장 넓은 의미의 별칭(aliasing) 정의를 사용할 것입니다. 러스트의 실제 정의는 아마도 가변성(mutation)과 생존성(liveness)을 고려하여 더 제한적일 것입니다.</p>
</li>
<li>
<p>우리는 단일 스레드이며 인터럽트가 없는 실행 환경을 가정할 것입니다. 또한 메모리 맵 하드웨어와 같은 것들도 무시할 것입니다. 러스트는 별도로 명시하지 않는 한 이러한 일이 발생하지 않는다고 가정합니다. 자세한 내용은 <a href="concurrency.html">동시성 장</a>을 참조하세요.</p>
</li>
</ul>
<p>그 점을 염두에 두고, 우리가 사용할 정의는 다음과 같습니다: 변수와 포인터가 겹치는 메모리 영역을 참조한다면 이들은 서로 <em>별칭(alias)</em> 관계에 있습니다.</p>
<h2 id="별칭이-중요한-이유"><a class="header" href="#별칭이-중요한-이유">별칭이 중요한 이유</a></h2>
<p>그렇다면 왜 별칭에 신경을 써야 할까요?</p>
<p>간단한 함수를 하나 고려해 보겠습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn compute(input: &amp;u32, output: &amp;mut u32) {
    if *input &gt; 10 {
        *output = 1;
    }
    if *input &gt; 5 {
        *output *= 2;
    }
    // `input &gt; 10`인 경우 `output`이 `2`가 된다는 점을 기억하세요
}
<span class="boring">}</span></code></pre></pre>
<p>우리는 이 함수를 다음과 같이 최적화하고 <em>싶을</em> 것입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn compute(input: &amp;u32, output: &amp;mut u32) {
    let cached_input = *input; // *input을 레지스터에 유지합니다.
    if cached_input &gt; 10 {
        // 입력값이 10보다 크면, 이전 코드는 출력값을 1로 설정한 다음 두 배로 늘려
        // 결과적으로 출력값이 2가 됩니다(`&gt;10`은 `&gt;5`를 의미하기 때문입니다).
        // 여기서는 중복 할당을 피하고 직접 2로 설정합니다.
        *output = 2;
    } else if cached_input &gt; 5 {
        *output *= 2;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>러스트에서 이 최적화는 건전(sound)해야 합니다. 거의 모든 다른 언어에서는 (전역 분석이 없다면) 그렇지 않을 것입니다. 이는 최적화가 별칭이 발생하지 않는다는 사실에 의존하기 때문인데, 대부분의 언어는 이 부분에서 상당히 자유롭습니다. 구체적으로, 우리는 <code>compute(&amp;x, &amp;mut x)</code>와 같이 <code>input</code>과 <code>output</code>이 겹치게 만드는 함수 인자를 걱정해야 합니다.</p>
<p>해당 입력이 주어지면, 다음과 같이 실행될 수 있습니다:</p>
<!-- ignore: expanded code -->
<pre><code class="language-rust ignore">                    //  input ==  output == 0xabad1dea
                    // *input == *output == 20
if *input &gt; 10 {    // 참 (*input == 20)
    *output = 1;    // 또한 input과 output이 같으므로 *input도 덮어씁니다.
}
if *input &gt; 5 {     // 거짓 (*input == 1)
    *output *= 2;
}
                    // *input == *output == 1</code></pre>
<p>우리의 최적화된 함수는 이 입력에 대해 <code>*output == 2</code>를 생성하므로, 최적화의 정확성은 이 입력이 불가능하다는 사실에 의존합니다.</p>
<p>러스트에서 우리는 <code>&amp;mut</code>이 별칭되는 것이 허용되지 않으므로 이 입력이 불가능해야 한다는 것을 압니다. 따라서 우리는 그 가능성을 안전하게 배제하고 이 최적화를 수행할 수 있습니다. 대부분의 다른 언어에서 이 입력은 전적으로 가능하며, 반드시 고려되어야 합니다.</p>
<p>이것이 바로 별칭 분석(alias analysis)이 중요한 이유입니다. 별칭 분석을 통해 컴파일러는 유용한 최적화를 수행할 수 있습니다! 몇 가지 예를 들어보겠습니다.</p>
<ul>
<li>어떤 포인터도 해당 값의 메모리에 접근하지 않음을 증명하여 값을 레지스터에 유지</li>
<li>마지막으로 읽은 이후 해당 메모리에 쓰기가 발생하지 않았음을 증명하여 중복된 읽기 제거</li>
<li>다음 쓰기 이전에 해당 메모리를 읽지 않음을 증명하여 불필요한 쓰기 제거</li>
<li>서로 의존하지 않음을 증명하여 읽기 및 쓰기 작업의 순서를 변경하거나 이동</li>
</ul>
<p>이러한 최적화들은 루프 벡터화(loop vectorization), 상수 전파(constant propagation), 데드 코드 제거(dead code elimination)와 같은 더 큰 최적화의 건전성을 증명하는 데에도 기여합니다.</p>
<p>이전 예제에서 우리는 <code>&amp;mut u32</code>가 별칭될 수 없다는 사실을 이용하여 <code>*output</code>에 대한 쓰기가 <code>*input</code>에 영향을 미칠 수 없음을 증명했습니다. 이를 통해 <code>*input</code>을 레지스터에 캐싱하고 읽기 작업을 하나 줄일 수 있었습니다.</p>
<p>이 읽기 작업을 캐싱함으로써, 우리는 <code>&gt; 10</code> 분기에서의 쓰기가 <code>&gt; 5</code> 분기 진입 여부에 영향을 줄 수 없다는 것을 알게 되었습니다. 덕분에 <code>*input &gt; 10</code>인 경우 <code>*output</code>을 두 배로 만드는 읽기-수정-쓰기(read-modify-write) 작업도 제거할 수 있었습니다.</p>
<p>별칭 분석에 대해 기억해야 할 핵심은 쓰기 작업이 최적화의 주된 장애물이라는 점입니다. 즉, 프로그램의 다른 부분으로 읽기 작업을 옮기지 못하게 막는 유일한 요인은 해당 읽기 작업이 동일한 위치에 대한 쓰기 작업과 순서가 뒤바뀔 가능성입니다.</p>
<p>예를 들어, 함수를 다음과 같이 수정하면 별칭에 대해 걱정할 필요가 없습니다. <code>*output</code>에 대한 유일한 쓰기 작업을 함수의 맨 마지막으로 옮겼기 때문입니다. 이를 통해 그 이전에 발생하는 <code>*input</code> 읽기 작업들의 순서를 자유롭게 조정할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn compute(input: &amp;u32, output: &amp;mut u32) {
    let mut temp = *output;
    if *input &gt; 10 {
        temp = 1;
    }
    if *input &gt; 5 {
        temp *= 2;
    }
    *output = temp;
}
<span class="boring">}</span></code></pre></pre>
<p>우리는 여전히 <code>input</code>이 <code>temp</code>와 별칭 관계가 아니라고 가정하기 위해 별칭 분석에 의존하고 있지만, 그 증명은 훨씬 간단합니다. 지역 변수의 값은 그것이 선언되기 전에 존재했던 것들에 의해 별칭될 수 없기 때문입니다. 이는 모든 언어가 자유롭게 하는 가정이며, 따라서 이 버전의 함수는 어떤 언어에서든 우리가 원하는 방식으로 최적화될 수 있습니다.</p>
<p>이것이 러스트가 사용할 "별칭"의 정의에 생존성(liveness)과 가변성(mutation)의 개념이 포함될 가능성이 높은 이유입니다. 실제로 메모리에 쓰기가 발생하지 않는다면 별칭이 발생하는지 여부는 중요하지 않기 때문입니다.</p>
<p>물론 러스트를 위한 완전한 별칭 모델은 함수 호출(우리가 보지 못하는 것을 수정할 수 있음), 원시 포인터(그 자체로는 별칭 요구 사항이 없음), 그리고 <code>UnsafeCell</code>(<code>&amp;</code>의 지칭 대상을 수정할 수 있게 함)과 같은 것들도 고려해야 합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="수명"><a class="header" href="#수명">수명</a></h1>
<p>러스트는 _수명(lifetimes)_을 통해 이러한 규칙들을 강제합니다. 수명은 참조가 유효해야 하는 코드의 명명된 영역입니다. 이러한 영역은 프로그램의 실행 경로에 대응하므로 상당히 복잡할 수 있습니다. 심지어 실행 경로에 구멍이 있을 수도 있는데, 참조가 다시 사용되기 전에 재초기화된다면 그 전까지는 참조를 무효화하는 것이 가능하기 때문입니다. 참조를 포함하거나 포함하는 척하는 타입들 또한 수명으로 태그될 수 있으며, 이를 통해 러스트는 이들이 무효화되는 것을 방지할 수 있습니다.</p>
<p>대부분의 예제에서 수명은 스코프(scope)와 일치할 것입니다. 이는 예제가 단순하기 때문입니다. 수명이 스코프와 일치하지 않는 더 복잡한 사례들은 아래에서 설명합니다.</p>
<p>함수 본문 내에서 러스트는 일반적으로 관련된 수명을 명시적으로 명명하는 것을 허용하지 않습니다. 지역 문맥에서는 수명에 대해 이야기할 필요가 거의 없기 때문입니다. 러스트는 모든 정보를 가지고 있으며 가능한 한 최적으로 모든 것을 해결할 수 있습니다. 여러분이 직접 작성해야 했을 많은 익명 스코프와 임시 변수들이 코드가 "그냥 작동(Just Work)"하도록 자주 도입됩니다.</p>
<p>하지만 함수 경계를 넘어서면 수명에 대해 이야기하기 시작해야 합니다. 수명은 어포스트로피와 함께 표기합니다: <code>'a</code>, <code>'static</code>. 수명에 익숙해지기 위해, 우리는 실제로 스코프에 수명을 라벨링하는 것이 허용된다고 가정하고 이 장의 시작 부분에 나왔던 예제들의 설탕을 제거(desugar)해 보겠습니다.</p>
<p>원래 우리의 예제들은 스코프와 수명 주변에 <em>공격적인</em> 문법 설탕(당도가 매우 높은 액상 과당 수준의)을 사용했습니다. 모든 것을 명시적으로 작성하는 것은 <em>매우 시끄럽기</em> 때문입니다. 모든 러스트 코드는 "명백한" 것들에 대한 공격적인 추론과 생략에 의존합니다.</p>
<p>특히 흥미로운 문법 설탕 중 하나는 각 <code>let</code> 문이 암시적으로 스코프를 도입한다는 점입니다. 대부분의 경우 이는 중요하지 않습니다. 하지만 서로를 참조하는 변수들의 경우에는 중요합니다. 간단한 예로, 이 간단한 러스트 코드의 설탕을 완전히 제거해 보겠습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 0;
let y = &amp;x;
let z = &amp;y;
<span class="boring">}</span></code></pre></pre>
<p>빌림 검사기(borrow checker)는 항상 수명의 범위를 최소화하려고 노력하므로, 아마도 다음과 같이 설탕이 제거될 것입니다.</p>
<!-- ignore: desugared code -->
<pre><code class="language-rust ignore">// 참고: `'a: {` 및 `&amp;'b x`는 유효한 구문이 아닙니다!
'a: {
    let x: i32 = 0;
    'b: {
        // 수명 `'b`를 사용하는 것으로 충분하므로 그것이 사용됩니다.
        let y: &amp;'b i32 = &amp;'b x;
        'c: {
            // `'c`도 마찬가지입니다.
            let z: &amp;'c &amp;'b i32 = &amp;'c y; // "i32에 대한 참조에 대한 참조" (수명이 주석으로 표시됨)
        }
    }
}</code></pre>
<p>와... 정말 끔찍하네요. 이 작업을 쉽게 만들어 준 러스트에게 감사하는 시간을 잠시 가집시다.</p>
<p>참조를 외부 스코프로 전달하면 러스트는 더 큰 수명을 추론합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 0;
let z;
let y = &amp;x;
z = y;
<span class="boring">}</span></code></pre></pre>
<!-- ignore: desugared code -->
<pre><code class="language-rust ignore">'a: {
    let x: i32 = 0;
    'b: {
        let z: &amp;'b i32;
        'c: {
            // `x`에 대한 참조가 스코프 `'b`로 전달되므로
            // 여기서는 반드시 `'b`를 사용해야 합니다.
            let y: &amp;'b i32 = &amp;'b x;
            z = y;
        }
    }
}</code></pre>
<h2 id="예제-지칭-대상보다-오래-사는-참조"><a class="header" href="#예제-지칭-대상보다-오래-사는-참조">예제: 지칭 대상보다 오래 사는 참조</a></h2>
<p>좋습니다. 이전에 보았던 몇 가지 예제들을 다시 살펴보겠습니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn as_str(data: &amp;u32) -&gt; &amp;str {
    let s = format!("{}", data);
    &amp;s
}
<span class="boring">}</span></code></pre></pre>
<p>다음과 같이 설탕이 제거됩니다.</p>
<!-- ignore: desugared code -->
<pre><code class="language-rust ignore">fn as_str&lt;'a&gt;(data: &amp;'a u32) -&gt; &amp;'a str {
    'b: {
        let s = format!("{}", data);
        return &amp;'a s;
    }
}</code></pre>
<p><code>as_str</code>의 이 시그니처는 <em>어떤</em> 수명을 가진 <code>u32</code>에 대한 참조를 받아, 그와 <em>동일한 기간</em> 동안 살 수 있는 <code>str</code>에 대한 참조를 생성할 수 있음을 약속합니다. 벌써 이 시그니처가 왜 문제가 될 수 있는지 알 수 있습니다. 이는 기본적으로 <code>u32</code>에 대한 참조가 시작된 스코프 어딘가에서, 혹은 그보다 <em>훨씬 이전</em> 어딘가에서 <code>str</code>을 찾아낼 것이라는 의미입니다. 이는 좀 무리한 요구입니다.</p>
<p>그다음 문자열 <code>s</code>를 계산하고 그에 대한 참조를 반환합니다. 함수의 계약에서 참조가 <code>'a</code>보다 오래 살아야 한다고 했으므로, 우리는 참조의 수명을 <code>'a</code>로 추론합니다. 불행히도 <code>s</code>는 스코프 <code>'b</code>에서 정의되었으므로, 이것이 건전하려면 <code>'b</code>가 <code>'a</code>를 포함해야만 합니다. 하지만 <code>'a</code>는 함수 호출 자체를 포함해야 하므로 이는 명백히 거짓입니다. 따라서 우리는 참조의 수명이 그 지칭 대상보다 오래 지속되는 상황을 만들었으며, 이는 우리가 참조가 할 수 없다고 말한 <em>정확히 첫 번째</em> 규칙을 위반한 것입니다. 컴파일러는 당연히 우리 면전에 대고 폭발할 것입니다.</p>
<p>이를 더 명확히 하기 위해 예제를 확장해 볼 수 있습니다.</p>
<!-- ignore: desugared code -->
<pre><code class="language-rust ignore">fn as_str&lt;'a&gt;(data: &amp;'a u32) -&gt; &amp;'a str {
    'b: {
        let s = format!("{}", data);
        return &amp;'a s
    }
}

fn main() {
    'c: {
        let x: u32 = 0;
        'd: {
            // 빌림이 `x`가 유효한 전체 스코프 동안 지속될 필요가 없으므로
            // 익명 스코프가 도입됩니다. `as_str`의 반환값은
            // 이 함수 호출 이전의 어딘가에서 `str`을 찾아야 합니다.
            // 당연히 그런 일은 일어나지 않습니다.
            println!("{}", as_str::&lt;'d&gt;(&amp;'d x));
        }
    }
}</code></pre>
<p>이런!</p>
<p>물론, 이 함수를 올바르게 작성하는 방법은 다음과 같습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn to_string(data: &amp;u32) -&gt; String {
    format!("{}", data)
}
<span class="boring">}</span></code></pre></pre>
<p>반환하기 위해서는 함수 내부에서 소유권을 가진 값을 생성해야 합니다! <code>&amp;'a str</code>을 반환할 수 있는 유일한 방법은 그것이 <code>&amp;'a u32</code>의 필드에 있는 경우였을 텐데, 지금은 명백히 그렇지 않습니다.</p>
<p>(사실 전역 상수로 간주되어 스택의 맨 아래에 거주하는 문자열 리터럴을 반환할 수도 있었겠지만, 이는 구현을 <em>약간</em> 제한하게 됩니다.)</p>
<h2 id="예제-가변-참조-별칭하기"><a class="header" href="#예제-가변-참조-별칭하기">예제: 가변 참조 별칭하기</a></h2>
<p>다른 예제는 어떨까요?</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut data = vec![1, 2, 3];
let x = &amp;data[0];
data.push(4);
println!("{}", x);
<span class="boring">}</span></code></pre></pre>
<!-- ignore: desugared code -->
<pre><code class="language-rust ignore">'a: {
    let mut data: Vec&lt;i32&gt; = vec![1, 2, 3];
    'b: {
        // 'b는 이 빌림이 필요한 만큼의 크기입니다
        // (`println!`까지만 도달하면 됩니다)
        let x: &amp;'b i32 = Index::index::&lt;'b&gt;(&amp;'b data, 0);
        'c: {
            // `&amp;mut`가 더 오래 지속될 필요가 없으므로
            // 임시 스코프가 사용됩니다.
            Vec::push(&amp;'c mut data, 4);
        }
        println!("{}", x);
    }
}</code></pre>
<p>여기서의 문제는 조금 더 미묘하고 흥미롭습니다. 우리는 러스트가 다음과 같은 이유로 이 프로그램을 거부하기를 원합니다: <code>push</code>를 하기 위해 <code>data</code>에 대한 가변 참조를 얻으려 할 때, <code>data</code>의 자손인 <code>x</code>에 대한 활성 공유 참조가 존재합니다. 이는 별칭된 가변 참조를 생성하게 되며, 이는 참조의 <em>두 번째</em> 규칙을 위반하는 것입니다.</p>
<p>하지만 러스트가 이 프로그램이 나쁘다고 판단하는 근거는 이것과는 <em>전혀 다릅니다</em>. 러스트는 <code>x</code>가 <code>data</code>의 하위 경로에 대한 참조라는 것을 이해하지 못합니다. <code>Vec</code>에 대해서도 전혀 모릅니다. 러스트가 보는 것은 <code>x</code>가 출력되기 위해 <code>'b</code> 동안 살아야 한다는 것입니다. 그에 따라 <code>Index::index</code>의 시그니처는 우리가 <code>data</code>로부터 취하는 참조가 <code>'b</code> 동안 살아남을 것을 요구합니다. 우리가 <code>push</code>를 호출하려 할 때, 러스트는 우리가 <code>&amp;'c mut data</code>를 만들려는 것을 보게 됩니다. 러스트는 <code>'c</code>가 <code>'b</code> 내에 포함되어 있음을 알고, <code>&amp;'b data</code>가 여전히 살아있어야 하므로 프로그램을 거부합니다!</p>
<p>여기서 우리는 수명 시스템이 우리가 실제로 보존하고자 하는 참조 의미론(semantics)보다 훨씬 더 거칠다는 것을 알 수 있습니다. 대부분의 경우 <em>그것은 완전히 괜찮습니다</em>. 덕분에 프로그래머가 컴파일러에게 하루 종일 프로그램을 설명하느라 시간을 허비하지 않아도 되기 때문입니다. 하지만 이는 러스트의 <em>진정한</em> 의미론 관점에서는 완전히 올바른 여러 프로그램이 수명이 너무 단순하다는 이유로 거부됨을 의미하기도 합니다.</p>
<h2 id="수명이-다루는-영역"><a class="header" href="#수명이-다루는-영역">수명이 다루는 영역</a></h2>
<p>참조(때때로 _빌림_이라고 불림)는 그것이 생성된 지점부터 마지막 사용 지점까지 <em>살아있습니다(alive)</em>. 빌려온 값은 살아있는 빌림보다 더 오래 살기만 하면 됩니다. 이는 간단해 보이지만 몇 가지 미묘한 점이 있습니다.</p>
<p>다음 코드는 컴파일됩니다. <code>x</code>를 출력한 후에는 더 이상 필요하지 않으므로, 그것이 댕글링 상태이든 별칭 상태이든 상관없기 때문입니다(변수 <code>x</code>가 <em>기술적으로는</em> 스코프 끝까지 존재하더라도 말입니다).</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut data = vec![1, 2, 3];
let x = &amp;data[0];
println!("{}", x);
// 이것은 괜찮습니다. x는 더 이상 필요하지 않습니다.
data.push(4);
<span class="boring">}</span></code></pre></pre>
<p>하지만 값에 소멸자(destructor)가 있는 경우, 소멸자는 스코프 끝에서 실행됩니다. 그리고 소멸자를 실행하는 것은 사용(use)으로 간주되며, 분명히 그것이 마지막 사용이 됩니다. 따라서 이 코드는 컴파일되지 <em>않을</em> 것입니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct X&lt;'a&gt;(&amp;'a i32);

impl Drop for X&lt;'_&gt; {
    fn drop(&amp;mut self) {}
}

let mut data = vec![1, 2, 3];
let x = X(&amp;data[0]);
println!("{:?}", x);
data.push(4);
// 여기서 소멸자가 실행되므로 컴파일에 실패합니다.
<span class="boring">}</span></code></pre></pre>
<p>컴파일러에게 <code>x</code>가 더 이상 유효하지 않음을 알리는 한 가지 방법은 <code>data.push(4)</code> 이전에 <code>drop(x)</code>를 사용하는 것입니다.</p>
<p>더 나아가, 대여의 마지막 사용이 여러 개일 수 있습니다. 예를 들어 조건문의 각 분기마다 있을 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn some_condition() -&gt; bool { true }
</span>let mut data = vec![1, 2, 3];
let x = &amp;data[0];

if some_condition() {
    println!("{}", x); // 이 분기에서 `x`의 마지막 사용입니다.
    data.push(4);      // 따라서 여기서 push할 수 있습니다.
} else {
    // 여기서는 `x`의 사용이 없으므로, 사실상 마지막 사용은 예제 상단에서 x를 생성한 시점입니다.
    data.push(5);
}
<span class="boring">}</span></code></pre></pre>
<p>그리고 수명에는 공백이 있을 수 있습니다. 또는 동일한 지역 변수에 묶인 두 개의 서로 다른 대여로 볼 수도 있습니다. 이는 루프 주변에서 종종 발생합니다(루프 끝에서 변수에 새 값을 쓰고 다음 반복문의 시작 부분에서 마지막으로 사용하는 경우).</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut data = vec![1, 2, 3];
// 이 mut은 참조가 가리키는 위치를 변경할 수 있게 해줍니다.
let mut x = &amp;data[0];

println!("{}", x); // 이 대여의 마지막 사용입니다.
data.push(4);
x = &amp;data[3]; // 여기서 새로운 대여를 시작합니다.
println!("{}", x);
<span class="boring">}</span></code></pre></pre>
<p>역사적으로 러스트는 대여를 스코프 끝까지 유지했으므로, 이 예제들은 이전 컴파일러에서 컴파일에 실패할 수 있습니다. 또한, 러스트가 대여의 생존 기간을 적절히 단축하지 못해 컴파일되어야 할 것 같음에도 실패하는 몇 가지 예외적인 사례들이 여전히 존재합니다. 이러한 문제들은 시간이 지나면서 해결될 것입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="수명의-한계"><a class="header" href="#수명의-한계">수명의 한계</a></h1>
<p>다음 코드가 주어졌을 때:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024">#[derive(Debug)]
struct Foo;

impl Foo {
    fn mutate_and_share(&amp;mut self) -&gt; &amp;Self { &amp;*self }
    fn share(&amp;self) {}
}

fn main() {
    let mut foo = Foo;
    let loan = foo.mutate_and_share();
    foo.share();
    println!("{:?}", loan);
}</code></pre></pre>
<p>이 코드가 컴파일될 것이라고 예상할 수 있습니다. 우리는 <code>foo</code>를 일시적으로 가변 대여(mutably borrows)한 후 공유 참조(shared reference)만을 반환하는 <code>mutate_and_share</code>를 호출합니다. 따라서 <code>foo</code>가 가변 대여된 상태가 아니어야 하므로 <code>foo.share()</code>가 성공할 것이라고 예상할 수 있습니다.</p>
<p>하지만 컴파일을 시도하면:</p>
<pre><code class="language-text">error[E0502]: `foo`가 이미 가변으로 대여되었으므로 불변으로 대여할 수 없습니다
  --&gt; src/main.rs:12:5
   |
11 |     let loan = foo.mutate_and_share();
   |                --- 여기서 가변 대여가 발생함
12 |     foo.share();
   |     ^^^ 여기서 불변 대여가 발생함
13 |     println!("{:?}", loan);
</code></pre>
<p>무슨 일이 일어난 걸까요? 음, 우리는 <a href="lifetimes.html#example-aliasing-a-mutable-reference">이전 섹션의 예제 2</a>와 정확히 같은 논리를 얻게 됩니다. 프로그램의 문법 설탕을 제거하면 다음과 같습니다:</p>
<!-- ignore: desugared code -->
<pre><code class="language-rust ignore">struct Foo;

impl Foo {
    fn mutate_and_share&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a Self { &amp;'a *self }
    fn share&lt;'a&gt;(&amp;'a self) {}
}

fn main() {
    'b: {
        let mut foo: Foo = Foo;
        'c: {
            let loan: &amp;'c Foo = Foo::mutate_and_share::&lt;'c&gt;(&amp;'c mut foo);
            'd: {
                Foo::share::&lt;'d&gt;(&amp;'d foo);
            }
            println!("{:?}", loan);
        }
    }
}</code></pre>
<p>수명 시스템은 <code>loan</code>의 수명과 <code>mutate_and_share</code>의 시그니처 때문에 <code>&amp;mut foo</code>의 수명을 <code>'c</code>로 확장해야 합니다. 그런 다음 우리가 <code>share</code>를 호출하려고 할 때, 시스템은 우리가 <code>&amp;'c mut foo</code>를 별칭(alias)하려고 한다는 것을 감지하고 에러를 터뜨립니다!</p>
<p>이 프로그램은 우리가 실제로 신경 쓰는 참조 의미론에 따르면 분명히 올바르지만, 수명 시스템이 너무 거칠어서(coarse-grained) 이를 처리하지 못합니다.</p>
<h2 id="부적절하게-축소된-대여improperly-reduced-borrows"><a class="header" href="#부적절하게-축소된-대여improperly-reduced-borrows">부적절하게 축소된 대여(Improperly reduced borrows)</a></h2>
<p>다음 코드는 컴파일에 실패합니다. 러스트가 변수 <code>map</code>이 두 번 대여되는 것을 보고, 두 번째 대여가 발생하기 전에 첫 번째 대여의 필요성이 사라진다는 것을 추론하지 못하기 때문입니다. 이는 러스트가 보수적으로 첫 번째 대여에 전체 스코프를 사용하도록 대체하기 때문에 발생합니다. 이것은 결국 수정될 것입니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::collections::HashMap;
</span><span class="boring">use std::hash::Hash;
</span>fn get_default&lt;'m, K, V&gt;(map: &amp;'m mut HashMap&lt;K, V&gt;, key: K) -&gt; &amp;'m mut V
where
    K: Clone + Eq + Hash,
    V: Default,
{
    match map.get_mut(&amp;key) {
        Some(value) =&gt; value,
        None =&gt; {
            map.insert(key.clone(), V::default());
            map.get_mut(&amp;key).unwrap()
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>부과된 수명 제한 때문에 <code>&amp;mut map</code>의 수명이 다른 가변 대여와 겹쳐서 컴파일 에러가 발생합니다:</p>
<pre><code class="language-text">error[E0499]: cannot borrow `*map` as mutable more than once at a time
  --&gt; src/main.rs:12:13
   |
4  |   fn get_default&lt;'m, K, V&gt;(map: &amp;'m mut HashMap&lt;K, V&gt;, key: K) -&gt; &amp;'m mut V
   |                  -- lifetime `'m` defined here
...
9  |       match map.get_mut(&amp;key) {
   |       -     --- first mutable borrow occurs here
   |  _____|
   | |
10 | |         Some(value) =&gt; value,
11 | |         None =&gt; {
12 | |             map.insert(key.clone(), V::default());
   | |             ^^^ second mutable borrow occurs here
13 | |             map.get_mut(&amp;key).unwrap()
14 | |         }
15 | |     }
   | |_____- returning this value requires that `*map` is borrowed for `'m`
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="수명-생략"><a class="header" href="#수명-생략">수명 생략</a></h1>
<p>일반적인 패턴을 더 인체공학적으로 만들기 위해, 러스트는 함수 시그니처에서 수명을 _생략(elide)_할 수 있게 허용합니다.</p>
<p>_수명 위치(lifetime position)_는 타입 내에서 수명을 쓸 수 있는 모든 곳을 말합니다.</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">&amp;'a T
&amp;'a mut T
T&lt;'a&gt;</code></pre>
<p>수명 위치는 "입력" 또는 "출력"으로 나타날 수 있습니다.</p>
<ul>
<li>
<p><code>fn</code> 정의, <code>fn</code> 타입, 그리고 트레잇 <code>Fn</code>, <code>FnMut</code>, <code>FnOnce</code>의 경우, 입력은 형식 인자의 타입을 가리키며 출력은 결과 타입을 가리킵니다. 따라서 <code>fn foo(s: &amp;str) -&gt; (&amp;str, &amp;str)</code>는 입력 위치에서 하나의 수명을, 출력 위치에서 두 개의 수명을 생략했습니다. <code>fn</code> 메서드 정의의 입력 위치에는 메서드의 <code>impl</code> 헤더에 나타나는 수명(또는 기본 메서드의 경우 트레잇 헤더에 나타나는 수명)은 포함되지 않는다는 점에 유의하세요.</p>
</li>
<li>
<p><code>impl</code> 헤더의 경우, 모든 타입은 입력입니다. 따라서 <code>impl Trait&lt;&amp;T&gt; for Struct&lt;&amp;T&gt;</code>는 입력 위치에서 두 개의 수명을 생략했으며, <code>impl Struct&lt;&amp;T&gt;</code>는 하나를 생략했습니다.</p>
</li>
</ul>
<p>생략 규칙은 다음과 같습니다.</p>
<ul>
<li>
<p>입력 위치에서 생략된 각 수명은 서로 다른 수명 매개변수가 됩니다.</p>
</li>
<li>
<p>입력 수명 위치가 (생략되었든 아니든) 정확히 하나만 있다면, 해당 수명이 <em>모든</em> 생략된 출력 수명에 할당됩니다.</p>
</li>
<li>
<p>입력 수명 위치가 여러 개 있지만 그중 하나가 <code>&amp;self</code> 또는 <code>&amp;mut self</code>라면, <code>self</code>의 수명이 <em>모든</em> 생략된 출력 수명에 할당됩니다.</p>
</li>
<li>
<p>그렇지 않은 경우, 출력 수명을 생략하는 것은 에러입니다.</p>
</li>
</ul>
<p>예제:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">fn print(s: &amp;str);                                      // 생략됨
fn print&lt;'a&gt;(s: &amp;'a str);                               // 확장됨

fn debug(lvl: usize, s: &amp;str);                          // 생략됨
fn debug&lt;'a&gt;(lvl: usize, s: &amp;'a str);                   // 확장됨

fn substr(s: &amp;str, until: usize) -&gt; &amp;str;               // 생략됨
fn substr&lt;'a&gt;(s: &amp;'a str, until: usize) -&gt; &amp;'a str;     // 확장됨

fn get_str() -&gt; &amp;str;                                   // 불법(ILLEGAL)

fn frob(s: &amp;str, t: &amp;str) -&gt; &amp;str;                      // 불법(ILLEGAL)

fn get_mut(&amp;mut self) -&gt; &amp;mut T;                        // 생략됨
fn get_mut&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a mut T;              // 확장됨

fn args&lt;T: ToCStr&gt;(&amp;mut self, args: &amp;[T]) -&gt; &amp;mut Command                  // 생략됨
fn args&lt;'a, 'b, T: ToCStr&gt;(&amp;'a mut self, args: &amp;'b [T]) -&gt; &amp;'a mut Command // 확장됨

fn new(buf: &amp;mut [u8]) -&gt; BufWriter;                    // 생략됨
fn new(buf: &amp;mut [u8]) -&gt; BufWriter&lt;'_&gt;;                // 생략됨 (`rust_2018_idioms` 적용)
fn new&lt;'a&gt;(buf: &amp;'a mut [u8]) -&gt; BufWriter&lt;'a&gt;          // 확장됨</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="무한-수명"><a class="header" href="#무한-수명">무한 수명</a></h1>
<p>안전하지 않은 코드는 종종 허공에서 참조나 수명을 생성해내기도 합니다. 이러한 수명은 <em>무한한(unbounded)</em> 상태로 세상에 나옵니다. 가장 흔한 원인은 역참조된 원시 포인터에 대한 참조를 얻는 것인데, 이는 무한한 수명을 가진 참조를 생성합니다. 이러한 수명은 문맥이 요구하는 만큼 커집니다. 사실 이것은 단순히 <code>'static</code>이 되는 것보다 더 강력한데, 예를 들어 <code>&amp;'static &amp;'a T</code>는 타입 검사에 실패하지만 무한한 수명은 필요에 따라 <code>&amp;'a &amp;'a T</code>로 완벽하게 맞춰질 수 있기 때문입니다. 하지만 대부분의 의도와 목적에서 이러한 무한한 수명은 <code>'static</code>으로 간주될 수 있습니다.</p>
<p><code>'static</code>인 참조는 거의 없으므로, 이는 아마도 틀렸을 것입니다. <code>transmute</code>와 <code>transmute_copy</code>가 다른 두 가지 주요 원인입니다. 특히 함수 경계를 넘을 때는 무한한 수명을 가능한 한 빨리 제한하도록 노력해야 합니다.</p>
<p>함수가 주어졌을 때, 입력에서 파생되지 않은 모든 출력 수명은 무한합니다. 예를 들어:</p>
<!-- no_run: This example exhibits undefined behavior. -->
<pre><pre class="playground"><code class="language-rust no_run edition2024">fn get_str&lt;'a&gt;(s: *const String) -&gt; &amp;'a str {
    unsafe { &amp;*s }
}

fn main() {
    let soon_dropped = String::from("hello");
    let dangling = get_str(&amp;soon_dropped);
    drop(soon_dropped);
    println!("잘못된 str: {}", dangling); // 잘못된 str: gӚ_`
}</code></pre></pre>
<p>The easiest way to avoid unbounded lifetimes is to use lifetime elision at the function boundary. If an output lifetime is elided, then it <em>must</em> be bounded by an input lifetime. Of course it might be bounded by the <em>wrong</em> lifetime, but this will usually just cause a compiler error, rather than allow memory safety to be trivially violated.</p>
<p>함수 내에서 수명을 제한하는 것은 더 에러가 발생하기 쉽습니다. 수명을 제한하는 가장 안전하고 쉬운 방법은 제한된 수명을 가진 함수에서 그것을 반환하는 것입니다. 하지만 이것이 불가능하다면, 특정 수명을 가진 위치에 참조를 배치할 수 있습니다. 불행히도 함수에 관련된 모든 수명을 명명하는 것은 불가능합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="고차-트레잇-바운드higher-rank-trait-bounds-hrtbs"><a class="header" href="#고차-트레잇-바운드higher-rank-trait-bounds-hrtbs">고차 트레잇 바운드(Higher-Rank Trait Bounds, HRTBs)</a></h1>
<p>러스트의 <code>Fn</code> 트레잇은 약간 마법 같습니다. 예를 들어, 우리는 다음과 같은 코드를 작성할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024">struct Closure&lt;F&gt; {
    data: (u8, u16),
    func: F,
}

impl&lt;F&gt; Closure&lt;F&gt;
    where F: Fn(&amp;(u8, u16)) -&gt; &amp;u8,
{
    fn call(&amp;self) -&gt; &amp;u8 {
        (self.func)(&amp;self.data)
    }
}

fn do_it(data: &amp;(u8, u16)) -&gt; &amp;u8 { &amp;data.0 }

fn main() {
    let clo = Closure { data: (0, 1), func: do_it };
    println!("{}", clo.call());
}</code></pre></pre>
<p>만약 이 코드를 <a href="lifetimes.html">수명 섹션</a>에서 했던 것과 같은 방식으로 순진하게 설탕을 제거하려고 하면, 몇 가지 문제에 봉착하게 됩니다.</p>
<!-- ignore: desugared code -->
<pre><code class="language-rust ignore">// 참고: `&amp;'b data.0` 및 `'x: {`는 유효한 구문이 아닙니다!
struct Closure&lt;F&gt; {
    data: (u8, u16),
    func: F,
}

impl&lt;F&gt; Closure&lt;F&gt;
    // where F: Fn(&amp;'??? (u8, u16)) -&gt; &amp;'??? u8,
{
    fn call&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a u8 {
        (self.func)(&amp;self.data)
    }
}

fn do_it&lt;'b&gt;(data: &amp;'b (u8, u16)) -&gt; &amp;'b u8 { &amp;'b data.0 }

fn main() {
    'x: {
        let clo = Closure { data: (0, 1), func: do_it };
        println!("{}", clo.call());
    }
}</code></pre>
<p><code>F</code>의 트레잇 바운드에 있는 수명을 도대체 어떻게 표현해야 할까요? 거기에 어떤 수명을 제공해야 하지만, 우리가 신경 쓰는 수명은 <code>call</code>의 본문에 들어가기 전에는 명명할 수 없습니다! 또한 그것은 고정된 수명도 아닙니다. <code>call</code>은 그 시점에 <code>&amp;self</code>가 가지게 되는 <em>어떤</em> 수명과도 작동합니다.</p>
<p>이 작업에는 고차 트레잇 바운드(HRTBs)의 마법이 필요합니다. 이를 설탕 제거하는 방식은 다음과 같습니다:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">where for&lt;'a&gt; F: Fn(&amp;'a (u8, u16)) -&gt; &amp;'a u8,</code></pre>
<p>또는:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">where F: for&lt;'a&gt; Fn(&amp;'a (u8, u16)) -&gt; &amp;'a u8,</code></pre>
<p>(<code>Fn(a, b, c) -&gt; d</code> 자체는 불안정한 <em>진짜</em> <code>Fn</code> 트레잇에 대한 설탕일 뿐입니다)</p>
<p><code>for&lt;'a&gt;</code>는 "<code>'a</code>의 모든 선택에 대하여"라고 읽을 수 있으며, 기본적으로 F가 만족해야 하는 트레잇 바운드의 _무한한 리스트_를 생성합니다. 강렬하죠. <code>Fn</code> 트레잇 이외의 곳에서 HRTBs를 마주치는 경우는 많지 않으며, 심지어 그런 경우에도 일반적인 케이스를 위한 멋진 마법 설탕이 있습니다.</p>
<p>요약하자면, 원래 코드를 더 명시적으로 다음과 같이 다시 쓸 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024">struct Closure&lt;F&gt; {
    data: (u8, u16),
    func: F,
}

impl&lt;F&gt; Closure&lt;F&gt;
    where for&lt;'a&gt; F: Fn(&amp;'a (u8, u16)) -&gt; &amp;'a u8,
{
    fn call(&amp;self) -&gt; &amp;u8 {
        (self.func)(&amp;self.data)
    }
}

fn do_it(data: &amp;(u8, u16)) -&gt; &amp;u8 { &amp;data.0 }

fn main() {
    let clo = Closure { data: (0, 1), func: do_it };
    println!("{}", clo.call());
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="서브타이핑과-공변성"><a class="header" href="#서브타이핑과-공변성">서브타이핑과 공변성</a></h1>
<p>러스트는 대여와 소유권 간의 관계를 추적하기 위해 수명을 사용합니다. 하지만 수명을 단순히 구현하면 너무 제한적이거나 정의되지 않은 동작을 허용하게 될 수 있습니다.</p>
<p>수명의 유연한 사용을 허용하면서도 오용을 방지하기 위해, 러스트는 **서브타이핑(subtyping)**과 **공변성(variance)**을 사용합니다.</p>
<p>예제를 통해 시작해 보겠습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024">// 참고: debug는 *동일한* 수명을 가진 두 개의 매개변수를 기대합니다
fn debug&lt;'a&gt;(a: &amp;'a str, b: &amp;'a str) {
    println!("a = {a:?} b = {b:?}");
}

fn main() {
    let hello: &amp;'static str = "hello";
    {
        let world = String::from("world");
        let world = &amp;world; // 'world는 'static보다 수명이 짧습니다
        debug(hello, world);
    }
}</code></pre></pre>
<p>보수적인 수명 구현에서는 <code>hello</code>와 <code>world</code>가 서로 다른 수명을 가지므로 다음과 같은 에러를 보게 될 것입니다.</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:10:16
   |
10 |         debug(hello, world);
   |                      ^
   |                      |
   |                      expected `&amp;'static str`, found struct `&amp;'world str`
</code></pre>
<p>이것은 꽤 안타까운 일입니다. 이 경우 우리가 원하는 것은 <em>적어도</em> <code>'world</code>만큼 오래 사는 모든 타입을 수용하는 것입니다. 수명에 서브타이핑을 적용해 봅시다.</p>
<h2 id="서브타이핑subtyping"><a class="header" href="#서브타이핑subtyping">서브타이핑(Subtyping)</a></h2>
<p>서브타이핑은 하나의 타입을 다른 타입 대신 사용할 수 있다는 개념입니다.</p>
<p><code>Sub</code>가 <code>Super</code>의 서브타입이라고 정의합시다(이 장 전체에서 <code>Sub &lt;: Super</code>라는 표기법을 사용할 것입니다).</p>
<p>이것이 우리에게 시사하는 바는 <code>Super</code>가 정의하는 _요구 사항_의 집합을 <code>Sub</code>가 완전히 만족시킨다는 것입니다. <code>Sub</code>는 그보다 더 많은 요구 사항을 가질 수도 있습니다.</p>
<p>이제 수명과 함께 서브타이핑을 사용하기 위해, 수명의 요구 사항을 정의해야 합니다.</p>
<blockquote>
<p><code>'a</code>는 코드의 영역을 정의합니다.</p>
</blockquote>
<p>이제 수명에 대한 요구 사항 집합이 정의되었으므로, 이들이 서로 어떻게 관련되는지 정의할 수 있습니다.</p>
<blockquote>
<p><code>'long</code>이 <code>'short</code>를 <strong>완전히 포함하는</strong> 코드 영역을 정의할 때만 <code>'long &lt;: 'short</code>가 성립합니다.</p>
</blockquote>
<p><code>'long</code>은 <code>'short</code>보다 더 큰 영역을 정의할 수 있지만, 이는 여전히 우리의 정의에 부합합니다.</p>
<blockquote>
<p>이 장의 나머지 부분에서 보게 되겠지만, 서브타이핑은 이보다 훨씬 복잡하고 미묘합니다. 하지만 이 간단한 규칙은 99%의 경우에 매우 좋은 직관을 제공합니다. 그리고 안전하지 않은 코드를 작성하지 않는 한, 컴파일러가 여러분을 위해 모든 코너 케이스를 자동으로 처리해 줄 것입니다.</p>
</blockquote>
<blockquote>
<p>하지만 여기는 러스트노미콘입니다. 우리는 안전하지 않은 코드를 작성하고 있으므로, 이 모든 것이 실제로 어떻게 작동하는지, 그리고 우리가 어떻게 망칠 수 있는지 이해해야 합니다.</p>
</blockquote>
<p>위의 예제로 돌아가서, 우리는 <code>'static &lt;: 'world</code>라고 말할 수 있습니다. 지금은 수명의 서브타입이 참조를 통해 전달될 수 있다는 개념도 받아들입시다(<a href="subtyping.html#variance">공변성</a>에서 자세히 다룰 예정입니다). 즉, <code>&amp;'static str</code>은 <code>&amp;'world str</code>의 서브타입이므로, <code>&amp;'static str</code>을 <code>&amp;'world str</code>로 "다운그레이드"할 수 있습니다. 그러면 위의 예제는 컴파일될 것입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn debug&lt;'a&gt;(a: &amp;'a str, b: &amp;'a str) {
    println!("a = {a:?} b = {b:?}");
}

fn main() {
    let hello: &amp;'static str = "hello";
    {
        let world = String::from("world");
        let world = &amp;world; // 'world는 'static보다 수명이 짧습니다
        debug(hello, world); // hello는 조용히 `&amp;'static str`에서 `&amp;'world str`로 다운그레이드됩니다
    }
}</code></pre></pre>
<h2 id="공변성variance"><a class="header" href="#공변성variance">공변성(Variance)</a></h2>
<p>위에서 우리는 <code>'static &lt;: 'b</code>가 <code>&amp;'static T &lt;: &amp;'b T</code>를 의미한다는 사실을 대충 넘어갔습니다. 이는 _공변성(variance)_이라고 알려진 속성을 사용합니다. 하지만 항상 이 예제처럼 간단한 것은 아닙니다. 이를 이해하기 위해 예제를 조금 확장해 보겠습니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0597 edition2024">fn assign&lt;T&gt;(input: &amp;mut T, val: T) {
    *input = val;
}

fn main() {
    let mut hello: &amp;'static str = "hello";
    {
        let world = String::from("world");
        assign(&amp;mut hello, &amp;world);
    }
    println!("{hello}"); // 해제 후 사용(use after free) 😿
}</code></pre></pre>
<p><code>assign</code>에서 우리는 <code>hello</code> 참조가 <code>world</code>를 가리키도록 설정하고 있습니다. 하지만 그 후 <code>world</code>가 스코프를 벗어나고, 나중에 <code>println!</code>에서 <code>hello</code>가 사용됩니다!</p>
<p>이것은 전형적인 해제 후 사용 버그입니다!</p>
<p>우리의 첫 번째 본능은 <code>assign</code> 구현을 탓하는 것이겠지만, 여기에는 잘못된 것이 전혀 없습니다. <code>T</code>를 <code>T</code>에 할당하고 싶어 하는 것은 놀라운 일이 아닙니다.</p>
<p>문제는 <code>&amp;mut &amp;'static str</code>과 <code>&amp;mut &amp;'b str</code>가 호환된다고 가정할 수 없다는 점입니다. 이는 <code>'static</code>이 <code>'b</code>의 서브타입이라 하더라도, <code>&amp;mut &amp;'static str</code>는 <code>&amp;mut &amp;'b str</code>의 _서브타입_이 될 수 <strong>없음</strong>을 의미합니다.</p>
<p>공변성은 러스트가 제네릭 매개변수를 통해 서브타입 관계를 정의하기 위해 차용한 개념입니다.</p>
<blockquote>
<p>참고: 편의를 위해 <code>T</code>에 대해 쉽게 이야기할 수 있도록 제네릭 타입 <code>F&lt;T&gt;</code>를 정의하겠습니다. 문맥상 명확하기를 바랍니다.</p>
</blockquote>
<p>타입 <code>F</code>의 _공변성_은 입력의 서브타이핑이 출력의 서브타이핑에 어떤 영향을 미치는지에 대한 것입니다. 러스트에는 세 가지 종류의 공변성이 있습니다. <code>Sub</code>가 <code>Super</code>의 서브타입인 두 타입 <code>Sub</code>와 <code>Super</code>가 주어졌을 때:</p>
<ul>
<li><code>F&lt;Sub&gt;</code>가 <code>F&lt;Super&gt;</code>의 서브타입이면 <code>F</code>는 **공변적(covariant)**입니다 (서브타입 속성이 전달됨)</li>
<li><code>F&lt;Super&gt;</code>가 <code>F&lt;Sub&gt;</code>의 서브타입이면 <code>F</code>는 **반공변적(contravariant)**입니다 (서브타입 속성이 "뒤집힘")</li>
<li>그렇지 않으면 <code>F</code>는 **불변적(invariant)**입니다 (서브타이핑 관계가 존재하지 않음)</li>
</ul>
<p>위의 예제를 기억한다면, <code>'a &lt;: 'b</code>일 때 <code>&amp;'a T</code>를 <code>&amp;'b T</code>의 서브타입으로 취급하는 것이 괜찮았습니다. 따라서 우리는 <code>&amp;'a T</code>가 <code>'a</code>에 대해 _공변적_이라고 말할 수 있습니다.</p>
<p>Also, we saw that it was not ok for us to treat <code>&amp;mut &amp;'a T</code> as a subtype of <code>&amp;mut &amp;'b T</code>, therefore we can say that <code>&amp;mut T</code> is <em>invariant</em> over <code>T</code></p>
<p>다음은 몇 가지 다른 제네릭 타입과 그 공변성에 대한 표입니다:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th style="text-align: center">'a</th><th style="text-align: center">T</th><th style="text-align: center">U</th></tr></thead><tbody>
<tr><td><code>&amp;'a T </code></td><td style="text-align: center">공변(covariant)</td><td style="text-align: center">공변(covariant)</td><td style="text-align: center"></td></tr>
<tr><td><code>&amp;'a mut T</code></td><td style="text-align: center">공변(covariant)</td><td style="text-align: center">불변(invariant)</td><td style="text-align: center"></td></tr>
<tr><td><code>Box&lt;T&gt;</code></td><td style="text-align: center"></td><td style="text-align: center">공변(covariant)</td><td style="text-align: center"></td></tr>
<tr><td><code>Vec&lt;T&gt;</code></td><td style="text-align: center"></td><td style="text-align: center">공변(covariant)</td><td style="text-align: center"></td></tr>
<tr><td><code>UnsafeCell&lt;T&gt;</code></td><td style="text-align: center"></td><td style="text-align: center">불변(invariant)</td><td style="text-align: center"></td></tr>
<tr><td><code>Cell&lt;T&gt;</code></td><td style="text-align: center"></td><td style="text-align: center">불변(invariant)</td><td style="text-align: center"></td></tr>
<tr><td><code>fn(T) -&gt; U</code></td><td style="text-align: center"></td><td style="text-align: center"><strong>반공변(contravariant)</strong></td><td style="text-align: center">공변(covariant)</td></tr>
<tr><td><code>*const T</code></td><td style="text-align: center"></td><td style="text-align: center">공변(covariant)</td><td style="text-align: center"></td></tr>
<tr><td><code>*mut T</code></td><td style="text-align: center"></td><td style="text-align: center">불변(invariant)</td><td style="text-align: center"></td></tr>
</tbody></table>
</div>
<p>이들 중 일부는 다른 것들과의 관계를 통해 간단히 설명될 수 있습니다.</p>
<ul>
<li><code>Vec&lt;T&gt;</code>와 다른 모든 소유 포인터 및 컬렉션은 <code>Box&lt;T&gt;</code>와 동일한 논리를 따릅니다</li>
<li><code>Cell&lt;T&gt;</code>와 다른 모든 내부 가변성 타입은 <code>UnsafeCell&lt;T&gt;</code>와 동일한 논리를 따릅니다</li>
<li><code>UnsafeCell&lt;T&gt;</code>는 내부 가변성을 가지므로 <code>&amp;mut T</code>와 동일한 공변성 속성을 가집니다</li>
<li><code>*const T</code>는 <code>&amp;T</code>의 논리를 따릅니다</li>
<li><code>*mut T</code>는 <code>&amp;mut T</code>(또는 <code>UnsafeCell&lt;T&gt;</code>)의 논리를 따릅니다</li>
</ul>
<p>더 많은 타입에 대해서는 참조서의 <a href="../reference/subtyping.html#variance">"공변성" 섹션</a>을 확인하세요.</p>
<blockquote>
<p>참고: 언어에서 반공변성의 <em>유일한</em> 원천은 함수의 인자입니다. 이것이 실제로 실전에서 반공변성이 많이 등장하지 않는 이유입니다. 반공변성을 호출하려면 특정 수명을 가진 참조를 받는 함수 포인터를 사용하는 고차 프로그래밍이 필요합니다(일반적인 "아무 수명이나" 받는 것과는 대조적인데, 후자는 서브타이핑과 독립적으로 작동하는 고차 수명으로 들어갑니다).</p>
</blockquote>
<p>이제 공변성에 대해 좀 더 형식적으로 이해했으니, 몇 가지 예제를 더 자세히 살펴보겠습니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0597 edition2024">fn assign&lt;T&gt;(input: &amp;mut T, val: T) {
    *input = val;
}

fn main() {
    let mut hello: &amp;'static str = "hello";
    {
        let world = String::from("world");
        assign(&amp;mut hello, &amp;world);
    }
    println!("{hello}");
}</code></pre></pre>
<p>그리고 이것을 실행하면 무엇을 얻게 될까요?</p>
<pre><code class="language-text">error[E0597]: `world`가 충분히 오래 살지 않습니다
  --&gt; src/main.rs:9:28
   |
6  |     let mut hello: &amp;'static str = "hello";
   |                    ------------ 타입 주석은 `world`가 `'static` 동안 대여될 것을 요구합니다
...
9  |         assign(&amp;mut hello, &amp;world);
   |                            ^^^^^^ 대여된 값이 충분히 오래 살지 않습니다
10 |     }
   |     - `world`가 여기서 드롭되지만 여전히 대여 중입니다
</code></pre>
<p>좋습니다. 컴파일되지 않는군요! 여기서 무슨 일이 일어나고 있는지 자세히 분석해 봅시다.</p>
<p>먼저 <code>assign</code> 함수를 살펴봅시다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn assign&lt;T&gt;(input: &amp;mut T, val: T) {
    *input = val;
}
<span class="boring">}</span></code></pre></pre>
<p>이 함수가 하는 일은 가변 참조와 값을 받아서 지칭 대상을 덮어쓰는 것뿐입니다. 이 함수에서 중요한 점은 타입 동일성 제약을 생성한다는 것입니다. 시그니처에서 지칭 대상과 값이 <em>정확히 같은</em> 타입이어야 한다고 명확하게 명시하고 있습니다.</p>
<p>한편, 호출자에서는 <code>&amp;mut &amp;'static str</code>과 <code>&amp;'world str</code>을 전달합니다.</p>
<p><code>&amp;mut T</code>는 <code>T</code>에 대해 불변적이므로, 컴파일러는 첫 번째 인자에 어떤 서브타이핑도 적용할 수 없다고 결론 내립니다. 따라서 <code>T</code>는 정확히 <code>&amp;'static str</code>이어야 합니다.</p>
<p>이는 <code>&amp;T</code>의 경우와는 반대됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn debug&lt;T: std::fmt::Debug&gt;(a: T, b: T) {
    println!("a = {a:?} b = {b:?}");
}
<span class="boring">}</span></code></pre></pre>
<p>여기서도 마찬가지로 <code>a</code>와 <code>b</code>는 같은 타입 <code>T</code>를 가져야 합니다. 하지만 <code>&amp;'a T</code>는 <code>'a</code>에 대해 _공변적_이므로 서브타이핑을 수행할 수 있습니다. 따라서 컴파일러는 <code>&amp;'static str</code>이 <code>&amp;'b str</code>의 서브타입인 경우에만 <code>&amp;'b str</code>이 될 수 있다고 결정합니다. 이는 <code>'static &lt;: 'b</code>일 때 성립합니다. 이것은 참이므로 컴파일러는 기꺼이 이 코드를 계속 컴파일합니다.</p>
<p>알고 보니, Box(그리고 Vec, HashMap 등)가 공변적이어도 괜찮은 이유는 수명이 공변적이어도 괜찮은 이유와 꽤 비슷합니다. 가변 참조와 같은 것에 넣으려고 하는 순간 불변성을 상속받게 되어 나쁜 짓을 하는 것이 방지됩니다.</p>
<p>하지만 Box는 우리가 부분적으로 대충 넘어갔던 참조의 값에 의한(by-value) 측면에 집중하기 쉽게 해줍니다.</p>
<p>값이 항상 자유롭게 별칭되는 것을 허용하는 많은 언어들과 달리, 러스트는 매우 엄격한 규칙을 가지고 있습니다. 값을 변경하거나 이동할 수 있다면, 당신만이 그 값에 접근할 수 있는 유일한 존재임이 보장됩니다.</p>
<p>다음 코드를 고려해 보세요:</p>
<pre><code class="language-rust ignore">let hello: Box&lt;&amp;'static str&gt; = Box::new("hello");

let mut world: Box&lt;&amp;'b str&gt;;
world = hello;</code></pre>
<p><code>hello</code>가 <code>'static</code> 동안 살아있었다는 사실을 잊어버린 것은 전혀 문제가 되지 않습니다. <code>hello</code>를 <code>'b</code> 동안만 살아있다고 아는 변수로 이동시키는 순간, <strong>우리는 그것이 더 오래 산다는 것을 기억하는 우주의 유일한 존재를 파괴했기 때문입니다</strong>!</p>
<p>설명할 것이 하나 남았습니다: 함수 포인터.</p>
<p><code>fn(T) -&gt; U</code>가 <code>U</code>에 대해 공변적이어야 하는 이유를 알아보기 위해 다음 시그니처를 고려해 보세요:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">fn get_str() -&gt; &amp;'a str;</code></pre>
<p>이 함수는 어떤 수명 <code>'a</code>에 의해 제한된 <code>str</code>을 생성한다고 주장합니다. 따라서 대신 다음 시그니처를 가진 함수를 제공하는 것은 완전히 유효합니다.</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">fn get_static() -&gt; &amp;'static str;</code></pre>
<p>따라서 함수가 호출될 때 기대하는 것은 적어도 <code>'a</code> 수명만큼 사는 <code>&amp;str</code>일 뿐이며, 값이 실제로 더 오래 사는지는 중요하지 않습니다.</p>
<p>하지만 동일한 논리가 _인자_에는 적용되지 않습니다. 다음을 만족시키려 한다고 가정해 보세요:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">fn store_ref(&amp;'a str);</code></pre>
<p>다음을 사용해서:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">fn store_static(&amp;'static str);</code></pre>
<p>첫 번째 함수는 적어도 <code>'a</code>만큼 사는 한 어떤 문자열 참조든 받을 수 있지만, 두 번째 함수는 <code>'static</code>보다 짧게 사는 문자열 참조를 받을 수 없으므로 충돌이 발생합니다. 여기서는 공변성이 작동하지 않습니다. 하지만 뒤집어 보면 실제로 <em>작동합니다</em>! <code>&amp;'static str</code>을 처리할 수 있는 함수가 필요하다면, <em>어떤</em> 참조 수명이라도 처리할 수 있는 함수는 확실히 잘 작동할 것입니다.</p>
<p>실제로 확인해 봅시다</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">use std::cell::RefCell;
</span>thread_local! {
    pub static StaticVecs: RefCell&lt;Vec&lt;&amp;'static str&gt;&gt; = RefCell::new(Vec::new());
}

/// 주어진 입력을 스레드 로컬 `Vec&lt;&amp;'static str&gt;`에 저장합니다
fn store(input: &amp;'static str) {
    StaticVecs.with_borrow_mut(|v| v.push(input));
}

/// 입력을 가지고 함수를 호출합니다 (반드시 같은 수명이어야 합니다!)
fn demo&lt;'a&gt;(input: &amp;'a str, f: fn(&amp;'a str)) {
    f(input);
}

fn main() {
    demo("hello", store); // "hello"는 'static입니다. `store`를 문제없이 호출할 수 있습니다

    {
        let smuggle = String::from("smuggle");

        // `&amp;smuggle`은 static이 아닙니다. 만약 `store`를 `&amp;smuggle`로 호출한다면,
        // 유효하지 않은 수명을 `StaticVecs`에 넣게 됩니다.
        // 따라서 `fn(&amp;'static str)`은 `fn(&amp;'a str)`의 서브타입이 될 수 없습니다
        demo(&amp;smuggle, store);
    }

    // 해제 후 사용(use after free) 😿
    StaticVecs.with_borrow(|v| println!("{v:?}"));
}</code></pre></pre>
<p>이것이 바로 함수 타입이 언어의 다른 것들과 달리 그 인자에 대해 **반공변성(contravariant)**을 갖는 이유입니다.</p>
<p>표준 라이브러리가 제공하는 타입들의 경우는 이 정도로 충분하지만, 여러분이 직접 정의하는 타입의 공변성은 어떻게 결정될까요? 비공식적으로 말하자면, 구조체는 필드의 공변성을 상속합니다. 만약 구조체 <code>MyType</code>이 필드 <code>a</code>에서 사용되는 제네릭 인자 <code>A</code>를 가지고 있다면, <code>MyType</code>의 <code>A</code>에 대한 공변성은 정확히 <code>a</code>의 <code>A</code>에 대한 공변성과 같습니다.</p>
<p>하지만 <code>A</code>가 여러 필드에서 사용된다면 다음과 같습니다.</p>
<ul>
<li><code>A</code>를 사용하는 모든 곳이 공변적이라면, <code>MyType</code>은 <code>A</code>에 대해 공변합니다.</li>
<li><code>A</code>를 사용하는 모든 곳이 반공변적이라면, <code>MyType</code>은 <code>A</code>에 대해 반공변합니다.</li>
<li>그렇지 않으면 <code>MyType</code>은 <code>A</code>에 대해 불변입니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::Cell;

struct MyType&lt;'a, 'b, A: 'a, B: 'b, C, D, E, F, G, H, In, Out, Mixed&gt; {
    a: &amp;'a A,     // 'a와 A에 대해 공변
    b: &amp;'b mut B, // 'b에 대해 공변이고 B에 대해 불변

    c: *const C,  // C에 대해 공변
    d: *mut D,    // D에 대해 불변

    e: E,         // E에 대해 공변
    f: Vec&lt;F&gt;,    // F에 대해 공변
    g: Cell&lt;G&gt;,   // G에 대해 불변

    h1: H,        // ...가 아니었다면 H에 대해서도 공변이었을 것입니다
    h2: Cell&lt;H&gt;,  // H에 대해 불변입니다. 모든 충돌에서 불변성이 우선하기 때문입니다.

    i: fn(In) -&gt; Out,       // In에 대해 반공변, Out에 대해 공변

    k1: fn(Mixed) -&gt; usize, // ...가 아니었다면 Mixed에 대해 반공변이었을 것입니다
    k2: Mixed,              // Mixed에 대해 불변입니다. 모든 충돌에서 불변성이 우선하기 때문입니다.
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="드롭-체크"><a class="header" href="#드롭-체크">드롭 체크</a></h1>
<p>우리는 수명이 매달린 참조(dangling references)를 읽지 않도록 보장하는 몇 가지 간단한 규칙을 제공하는 것을 보았습니다. 하지만 지금까지 우리는 <em>outlives</em> 관계를 포함적인(inclusive) 방식으로만 다루어 왔습니다. 즉, <code>'a: 'b</code>라고 말할 때, <code>'a</code>가 <code>'b</code>와 <em>정확히</em> 같은 기간 동안 사는 것도 괜찮았습니다. 언뜻 보기에 이는 무의미한 구분처럼 보입니다. 어떤 것도 다른 것과 동시에 드롭(dropped)되지 않으니까요, 그렇죠? 이것이 우리가 <code>let</code> 문을 다음과 같이 설탕 제거(desugaring)하여 사용한 이유입니다.</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">let x;
let y;</code></pre>
<p>다음과 같이 설탕 제거됨:</p>
<!-- ignore: desugared code -->
<pre><code class="language-rust ignore">{
    let x;
    {
        let y;
    }
}</code></pre>
<p>스코프를 사용하여 설탕 제거를 할 수 없는 더 복잡한 상황들이 있지만, 순서는 여전히 정의되어 있습니다. 변수는 정의된 역순으로 드롭되고, 구조체와 튜플의 필드는 정의된 순서대로 드롭됩니다. 드롭 순서에 대한 더 자세한 내용은 <a href="https://github.com/rust-lang/rfcs/blob/master/text/1857-stabilize-drop-order.md">RFC 1857</a>에서 확인할 수 있습니다.</p>
<p>이렇게 해봅시다:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">let tuple = (vec![], vec![]);</code></pre>
<p>왼쪽 벡터가 먼저 드롭됩니다. 하지만 이것이 대여 검사기(borrow checker)의 관점에서 오른쪽 벡터가 왼쪽 벡터보다 엄격하게 더 오래 산다는 것을 의미할까요? 대답은 _아니오_입니다. 대여 검사기는 튜플의 필드를 개별적으로 추적할 수도 있겠지만, 대여 검사기가 이해하지 못하는 순수 라이브러리 코드를 통해 수동으로 드롭되는 벡터 요소의 경우, 무엇이 무엇보다 더 오래 사는지 결정할 수 없을 것입니다.</p>
<p>그렇다면 왜 우리가 이것에 신경을 써야 할까요? 타입 시스템이 주의를 기울이지 않으면 실수로 매달린 포인터를 만들 수 있기 때문입니다. 다음의 간단한 프로그램을 고려해 보세요.</p>
<pre><pre class="playground"><code class="language-rust edition2024">struct Inspector&lt;'a&gt;(&amp;'a u8);

struct World&lt;'a&gt; {
    inspector: Option&lt;Inspector&lt;'a&gt;&gt;,
    days: Box&lt;u8&gt;,
}

fn main() {
    let mut world = World {
        inspector: None,
        days: Box::new(1),
    };
    world.inspector = Some(Inspector(&amp;world.days));
}</code></pre></pre>
<p>이 프로그램은 완전히 건전하며 현재 컴파일됩니다. <code>days</code>가 <code>inspector</code>보다 엄격하게 더 오래 살지 않는다는 사실은 중요하지 않습니다. <code>inspector</code>가 살아있는 동안은 <code>days</code>도 살아있기 때문입니다.</p>
<p>하지만 소멸자를 추가하면, 프로그램은 더 이상 컴파일되지 않습니다!</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024">struct Inspector&lt;'a&gt;(&amp;'a u8);

impl&lt;'a&gt; Drop for Inspector&lt;'a&gt; {
    fn drop(&amp;mut self) {
        println!("은퇴까지 고작 {}일 남았었는데!", self.0);
    }
}

struct World&lt;'a&gt; {
    inspector: Option&lt;Inspector&lt;'a&gt;&gt;,
    days: Box&lt;u8&gt;,
}

fn main() {
    let mut world = World {
        inspector: None,
        days: Box::new(1),
    };
    world.inspector = Some(Inspector(&amp;world.days));
    // 만약 `days`가 우연히 먼저 드롭된다고 가정해 봅시다.
    // 그러면 Inspector가 드롭될 때, 이미 해제된 메모리를 읽으려고 시도할 것입니다!
}</code></pre></pre>
<pre><code class="language-text">error[E0597]: `world.days` does not live long enough
  --&gt; src/main.rs:19:38
   |
19 |     world.inspector = Some(Inspector(&amp;world.days));
   |                                      ^^^^^^^^^^^ borrowed value does not live long enough
...
22 | }
   | -
   | |
   | `world.days` dropped here while still borrowed
   | borrow might be used here, when `world` is dropped and runs the destructor for type `World&lt;'_&gt;`
</code></pre>
<p>필드의 순서를 바꾸거나 구조체 대신 튜플을 사용해 볼 수도 있지만, 여전히 컴파일되지 않을 것입니다.</p>
<p>Drop을 구현하면 Inspector가 소멸하는 동안 임의의 코드를 실행할 수 있게 됩니다. 이는 자신만큼 오래 살아야 하는 타입들이 실제로는 먼저 파괴되었다는 것을 잠재적으로 관찰할 수 있음을 의미합니다.</p>
<p>흥미롭게도, 제네릭 타입만이 이를 걱정해야 합니다. 제네릭이 아니라면, 가질 수 있는 유일한 수명은 진정으로 <em>영원히</em> 사는 <code>'static</code>뿐이기 때문입니다. 이것이 바로 이 문제를 _건전한 제네릭 드롭(sound generic drop)_이라고 부르는 이유입니다. 건전한 제네릭 드롭은 _드롭 검사기(drop checker)_에 의해 강제됩니다. 이 글을 쓰는 시점에서 드롭 검사기(dropck라고도 함)가 타입을 검증하는 방식에 대한 세부적인 사항 중 일부는 아직 정해지지 않았습니다. 하지만 '커다란 규칙(The Big Rule)'은 우리가 이 섹션 전체에서 집중해 온 미묘한 차이입니다.</p>
<p><strong>제네릭 타입이 건전하게 드롭을 구현하려면, 그 제네릭 인자들이 해당 타입보다 엄격하게 더 오래 살아야 합니다.</strong></p>
<p>이 규칙을 준수하는 것은 (대개) 대여 검사기를 만족시키기 위해 필요합니다. 이 규칙을 준수하는 것은 건전함을 보장하기에 충분하지만 필수적인 것은 아닙니다. 즉, 여러분의 타입이 이 규칙을 따른다면 드롭하는 것이 확실히 건전합니다.</p>
<p>위의 규칙을 항상 만족해야 할 필요가 없는 이유는, 일부 <code>Drop</code> 구현이 타입상으로는 접근할 수 있음에도 불구하고 빌린 데이터에 접근하지 않거나, 우리가 특정 드롭 순서를 알고 있어서 대여 검사기가 모르더라도 빌린 데이터가 여전히 유효하기 때문입니다.</p>
<p>예를 들어, 위 <code>Inspector</code> 예제의 이 변형은 빌려온 데이터에 절대 접근하지 않습니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024">struct Inspector&lt;'a&gt;(&amp;'a u8, &amp;'static str);

impl&lt;'a&gt; Drop for Inspector&lt;'a&gt; {
    fn drop(&amp;mut self) {
        println!("Inspector(_, {})는 언제 검사하지 *않아야* 할지 알고 있습니다.", self.1);
    }
}

struct World&lt;'a&gt; {
    inspector: Option&lt;Inspector&lt;'a&gt;&gt;,
    days: Box&lt;u8&gt;,
}

fn main() {
    let mut world = World {
        inspector: None,
        days: Box::new(1),
    };
    world.inspector = Some(Inspector(&amp;world.days, "gadget"));
    // 만약 `days`가 우연히 먼저 드롭된다고 가정해 봅시다.
    // Inspector가 드롭되더라도, 소멸자는 빌려온 `days`에 접근하지 않을 것입니다.
}</code></pre></pre>
<p>마찬가지로, 이 변형 또한 빌려온 데이터에 절대 접근하지 않습니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024">struct Inspector&lt;T&gt;(T, &amp;'static str);

impl&lt;T&gt; Drop for Inspector&lt;T&gt; {
    fn drop(&amp;mut self) {
        println!("Inspector(_, {})는 언제 검사하지 *않아야* 할지 알고 있습니다.", self.1);
    }
}

struct World&lt;T&gt; {
    inspector: Option&lt;Inspector&lt;T&gt;&gt;,
    days: Box&lt;u8&gt;,
}

fn main() {
    let mut world = World {
        inspector: None,
        days: Box::new(1),
    };
    world.inspector = Some(Inspector(&amp;world.days, "gadget"));
    // 만약 `days`가 우연히 먼저 드롭된다고 가정해 봅시다.
    // Inspector가 드롭되더라도, 소멸자는 빌려온 `days`에 접근하지 않을 것입니다.
}</code></pre></pre>
<p>하지만 위 두 변형 모두 <code>fn main</code> 분석 과정에서 <code>days</code>가 충분히 오래 살지 않는다는 이유로 대여 검사기에 의해 거부됩니다.</p>
<p>그 이유는 <code>main</code>의 빌림 검사 분석이 각 <code>Inspector</code>의 <code>Drop</code> 구현 내부를 모르기 때문입니다. 빌림 검사기가 <code>main</code>을 분석하는 동안 아는 한, 검사기(inspector)의 소멸자 본문은 빌려온 데이터에 접근할 수도 있습니다.</p>
<p>따라서 드롭 검사기는 값 안에 있는 모든 빌려온 데이터가 해당 값보다 엄격하게 더 오래 살도록 강제합니다.</p>
<h2 id="탈출구-an-escape-hatch"><a class="header" href="#탈출구-an-escape-hatch">탈출구 (An Escape Hatch)</a></h2>
<p>드롭 검사를 규정하는 정확한 규칙은 미래에 덜 제한적으로 변할 수도 있습니다.</p>
<p>The current analysis is deliberately conservative; it forces all borrowed data in a value to outlive that value, which is certainly sound.</p>
<p>미래 버전의 언어에서는 분석이 더 정밀해져서, 건전한 코드가 안전하지 않다는 이유로 거부되는 사례를 줄일 수 있을 것입니다. 이는 위에서 살펴본 파괴되는 동안 검사하지 않는 두 <code>Inspector</code>와 같은 사례를 해결하는 데 도움이 될 것입니다.</p>
<p>그동안은 제네릭 타입의 소멸자가 만료된 데이터에 접근하지 않는다는 것이 (비안전하게) 보장됨을 단언(assert)하기 위해 사용할 수 있는 불안정(unstable) 속성이 있습니다. 타입 자체는 접근 능력을 제공하더라도 말이죠.</p>
<p>그 속성은 <code>may_dangle</code>이라고 불리며 <a href="https://github.com/rust-lang/rfcs/blob/master/text/1327-dropck-param-eyepatch.md">RFC 1327</a>에서 도입되었습니다. 위의 <code>Inspector</code>에 적용하려면 다음과 같이 작성합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024">#![feature(dropck_eyepatch)]

struct Inspector&lt;'a&gt;(&amp;'a u8, &amp;'static str);

unsafe impl&lt;#[may_dangle] 'a&gt; Drop for Inspector&lt;'a&gt; {
    fn drop(&amp;mut self) {
        println!("Inspector(_, {})는 언제 검사하지 *않아야* 할지 알고 있습니다.", self.1);
    }
}

struct World&lt;'a&gt; {
    days: Box&lt;u8&gt;,
    inspector: Option&lt;Inspector&lt;'a&gt;&gt;,
}

fn main() {
    let mut world = World {
        inspector: None,
        days: Box::new(1),
    };
    world.inspector = Some(Inspector(&amp;world.days, "gadget"));
}</code></pre></pre>
<p>이 속성을 사용하려면 <code>Drop</code> 구현을 <code>unsafe</code>로 표시해야 합니다. 컴파일러는 잠재적으로 만료된 데이터(예: 위의 <code>self.0</code>)에 접근하지 않는다는 암묵적인 단언을 검사하지 않기 때문입니다.</p>
<p>이 속성은 임의의 개수의 수명 및 타입 매개변수에 적용될 수 있습니다. 다음 예제에서, 우리는 수명 <code>'b</code>를 가진 참조 뒤의 데이터에 접근하지 않으며 <code>T</code>는 이동되거나 드롭되는 용도로만 사용된다고 단언합니다. 하지만 <code>'a</code>와 <code>U</code>에서는 이 속성을 생략했는데, 해당 수명과 타입을 가진 데이터에는 실제로 접근하기 때문입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span>#![feature(dropck_eyepatch)]
<span class="boring">fn main() {
</span>use std::fmt::Display;

struct Inspector&lt;'a, 'b, T, U: Display&gt;(&amp;'a u8, &amp;'b u8, T, U);

unsafe impl&lt;'a, #[may_dangle] 'b, #[may_dangle] T, U: Display&gt; Drop for Inspector&lt;'a, 'b, T, U&gt; {
    fn drop(&amp;mut self) {
        println!("Inspector({}, _, _, {})", self.0, self.3);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>위의 경우처럼 그런 접근이 발생할 수 없음이 명백할 때도 있습니다. 하지만 제네릭 타입 매개변수를 다룰 때는 그런 접근이 간접적으로 발생할 수 있습니다. 간접적인 접근의 예는 다음과 같습니다:</p>
<ul>
<li>콜백 호출,</li>
<li>트레잇 메서드 호출을 경유.</li>
</ul>
<p>(구현 전문화(impl specialization)와 같이 미래에 언어에 추가될 변경 사항들이 이런 간접 접근의 또 다른 통로를 열 수도 있습니다.)</p>
<p>콜백 호출의 예시는 다음과 같습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Inspector&lt;T&gt;(T, &amp;'static str, Box&lt;for &lt;'r&gt; fn(&amp;'r T) -&gt; String&gt;);

impl&lt;T&gt; Drop for Inspector&lt;T&gt; {
    fn drop(&amp;mut self) {
        // `self.2` 호출은 가령 `T`가 `&amp;'a _`라면 빌림에 접근할 수 있습니다.
        println!("Inspector({}, {})는 무의식중에 만료된 데이터를 검사합니다.",
                 (self.2)(&amp;self.0), self.1);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>트레잇 메서드 호출의 예시는 다음과 같습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;

struct Inspector&lt;T: fmt::Display&gt;(T, &amp;'static str);

impl&lt;T: fmt::Display&gt; Drop for Inspector&lt;T&gt; {
    fn drop(&amp;mut self) {
        // 아래에는 숨겨진 `&lt;T as Display&gt;::fmt` 호출이 있으며,
        // 가령 `T`가 `&amp;'a _`라면 빌림에 접근할 수 있습니다.
        println!("Inspector({}, {})는 무의식중에 만료된 데이터를 검사합니다.",
                 self.0, self.1);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>물론, 이러한 모든 접근은 소멸자 내에 직접 작성되는 대신 소멸자가 호출하는 다른 메서드 내에 더 깊이 숨겨져 있을 수도 있습니다.</p>
<p>소멸자에서 <code>&amp;'a u8</code>에 접근하는 위의 모든 사례에서 <code>#[may_dangle]</code> 속성을 추가하면, 빌림 검사기가 잡아내지 못하는 오용에 타입이 취약해져 대혼란을 초래하게 됩니다. 속성을 추가하지 않는 것이 좋습니다.</p>
<h2 id="드롭-순서에-관한-관련-사이드-노트"><a class="header" href="#드롭-순서에-관한-관련-사이드-노트">드롭 순서에 관한 관련 사이드 노트</a></h2>
<p>구조체 내부 필드의 드롭 순서는 정의되어 있지만, 여기에 의존하는 것은 깨지기 쉽고 미묘합니다. 순서가 중요하다면 <a href="../std/mem/struct.ManuallyDrop.html"><code>ManuallyDrop</code></a> 래퍼를 사용하는 것이 더 좋습니다.</p>
<h2 id="드롭-검사기에-대한-내용은-이게-전부인가요"><a class="header" href="#드롭-검사기에-대한-내용은-이게-전부인가요">드롭 검사기에 대한 내용은 이게 전부인가요?</a></h2>
<p>알고 보니 unsafe 코드를 작성할 때, 우리는 일반적으로 드롭 검사기를 위해 올바른 일을 하는 것에 대해 전혀 걱정할 필요가 없습니다. 하지만 걱정해야 할 한 가지 특별한 경우가 있는데, 그것은 다음 섹션에서 살펴보겠습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="팬텀-데이터"><a class="header" href="#팬텀-데이터">팬텀 데이터</a></h1>
<p>unsafe 코드로 작업할 때, 타입이나 수명이 구조체와 논리적으로 연관되어 있지만 실제로는 필드의 일부가 아닌 상황에 처할 때가 많습니다. 이는 수명에서 가장 흔히 발생합니다. 예를 들어, <code>&amp;'a [T]</code>에 대한 <code>Iter</code>는 (대략) 다음과 같이 정의됩니다:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Iter&lt;'a, T: 'a&gt; {
    ptr: *const T,
    end: *const T,
}
<span class="boring">}</span></code></pre></pre>
<p>하지만 <code>'a</code>가 구조체 본문 내에서 사용되지 않기 때문에, 이것은 _무한(unbounded)_합니다. <a href="https://rust-lang.github.io/rfcs/0738-variance.html#the-corner-case-unused-parameters-and-parameters-that-are-only-used-unsafely">이것이 역사적으로 일으킨 문제들 때문에</a>, 구조체 정의에서 무한한 수명과 타입은 _금지_됩니다. 따라서 우리는 어떤 식으로든 본문에서 이 타입들을 참조해야 합니다. 이를 올바르게 하는 것은 올바른 공변성(variance)과 드롭 검사를 위해 필수적입니다.</p>
<p>우리는 특별한 마커 타입인 <code>PhantomData</code>를 사용하여 이 작업을 수행합니다. <code>PhantomData</code>는 공간을 차지하지 않지만, 정적 분석을 목적으로 주어진 타입의 필드를 시뮬레이션합니다. 이는 타입 시스템에 원하는 공변성 종류를 명시적으로 알려주는 것보다 에러가 덜 발생한다고 간주되며, 동시에 오토 트레잇(auto traits)이나 드롭 검사에 필요한 정보와 같은 다른 유용한 것들도 제공합니다.</p>
<p><code>Iter</code>는 논리적으로 여러 개의 <code>&amp;'a T</code>를 포함하므로, 이것이 바로 우리가 <code>PhantomData</code>에게 시뮬레이션하라고 지시하는 것입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::marker;

struct Iter&lt;'a, T: 'a&gt; {
    ptr: *const T,
    end: *const T,
    _marker: marker::PhantomData&lt;&amp;'a T&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>이게 전부입니다. 수명은 제한될 것이고, 여러분의 반복자(iterator)는 <code>'a</code>와 <code>T</code>에 대해 공변적이 될 것입니다. 모든 것이 그냥 잘 작동합니다.</p>
<h2 id="제네릭-매개변수와-드롭-검사"><a class="header" href="#제네릭-매개변수와-드롭-검사">제네릭 매개변수와 드롭 검사</a></h2>
<p>과거에는 고려해야 할 또 다른 사항이 있었습니다.</p>
<p>이 문서 자체에서도 예전에는 다음과 같이 말했습니다:</p>
<blockquote>
<p>또 다른 중요한 예는 <code>Vec</code>인데, 이는 (대략) 다음과 같이 정의됩니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Vec&lt;T&gt; {
    data: *const T, // 공변성을 위한 *const!
    len: usize,
    cap: usize,
}
<span class="boring">}</span></code></pre></pre>
<p>이전 예제와 달리, 모든 것이 우리가 원하는 대로인 것처럼 <em>보입니다</em>. <code>Vec</code>으로의 모든 제네릭 인자가 적어도 하나의 필드에 나타납니다. 준비 끝!</p>
<p>아니요.</p>
<p>드롭 검사기는 관대하게도 <code>Vec&lt;T&gt;</code>가 <code>T</code> 타입의 어떤 값도 소유하지 않는다고 판단할 것입니다. 이는 결국 드롭 검사 건전성을 판단할 때 <code>Vec</code>의 소멸자에서 <code>T</code>를 드롭하는 것에 대해 걱정할 필요가 없다는 결론으로 이어집니다. 이는 다시 사람들이 <code>Vec</code>의 소멸자를 사용해 불건전성(unsoundness)을 만들어낼 수 있게 허용하게 됩니다.</p>
<p>우리가 <code>T</code> 타입의 값을 <em>실제로</em> 소유하고 있으며, 따라서 <em>우리가</em> 드롭될 때 일부 <code>T</code>들을 드롭할 수 있다는 것을 드롭 검사기에게 알리기 위해서는, 정확히 그 사실을 명시하는 추가적인 <code>PhantomData</code>를 더해야 합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::marker;

struct Vec&lt;T&gt; {
    data: *const T, // 공변성을 위한 *const!
    len: usize,
    cap: usize,
    _owns_T: marker::PhantomData&lt;T&gt;,
}
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>하지만 <a href="https://rust-lang.github.io/rfcs/1238-nonparametric-dropck.html">RFC 1238</a> 이후로, <strong>이것은 더 이상 사실이 아니며 필요하지도 않습니다</strong>.</p>
<p>만약 여러분이 다음과 같이 작성한다면:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Vec&lt;T&gt; {
    data: *const T, // 공변성을 위한 `*const`!
    len: usize,
    cap: usize,
}

<span class="boring">#[cfg(any())]
</span>impl&lt;T&gt; Drop for Vec&lt;T&gt; { /* … */ }
<span class="boring">}</span></code></pre></pre>
<p>그 <code>impl&lt;T&gt; Drop for Vec&lt;T&gt;</code>의 존재로 인해 러스트는 해당 <code>Vec&lt;T&gt;</code>가 <code>T</code> 타입의 값을 _소유_한다고 간주하게 됩니다 (더 정확히는: <code>Drop</code> 구현에서 <code>T</code> 타입의 값을 사용할 수 있다고 봅니다). 따라서 러스트는 <code>Vec&lt;T&gt;</code>가 드롭될 때 그것들이 _댕글링(dangle)_되도록 허용하지 않을 것입니다.</p>
<p>타입에 이미 <code>Drop</code> 구현이 있는 경우, <strong>추가적인 <code>_owns_T: PhantomData&lt;T&gt;</code> 필드를 더하는 것은 드롭 검사 관점에서 <em>불필요하며</em> 아무것도 달성하지 못합니다</strong> (여전히 공변성과 오토 트레잇에는 영향을 미칩니다).</p>
<ul>
<li>(고급 엣지 케이스: <code>PhantomData</code>를 포함하는 타입에 <code>Drop</code> 구현이 전혀 없더라도, (드롭 글루가 있는 <em>다른</em> 필드를 가짐으로써) 여전히 드롭 글루가 있다면, 여기서 언급된 드롭 검사/<code>#[may_dangle]</code> 고려 사항들이 그대로 적용됩니다. <code>PhantomData&lt;T&gt;</code> 필드는 포함하는 타입이 스코프를 벗어날 때마다 <code>T</code>가 드롭 가능할 것을 요구하게 됩니다.)</li>
</ul>
<hr />
<p>하지만 이런 상황은 때때로 지나치게 제한적인 코드로 이어질 수 있습니다. 이것이 바로 표준 라이브러리가 이 문서 자체에서 경고했던 과거의 "검사되지 않는" 드롭 검사 동작으로 되돌아가기 위해 불안정하고 <code>unsafe</code>한 속성인 <code>#[may_dangle]</code> 속성을 사용하는 이유입니다.</p>
<h3 id="예외-표준-라이브러리와-불안정한-may_dangle의-특별한-사례"><a class="header" href="#예외-표준-라이브러리와-불안정한-may_dangle의-특별한-사례">예외: 표준 라이브러리와 불안정한 <code>#[may_dangle]</code>의 특별한 사례</a></h3>
<p>자신만의 라이브러리 코드만 작성한다면 이 섹션은 건너뛰어도 됩니다. 하지만 실제 <code>Vec</code> 정의에서 표준 라이브러리가 무엇을 하는지 궁금하다면, 건전성을 위해 여전히 <code>_owns_T: PhantomData&lt;T&gt;</code> 필드를 사용해야 한다는 것을 눈치챌 것입니다.</p>
<details><summary>Click here to see why</summary>
<p>다음 예제를 고려해 봅시다:</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let mut v: Vec&lt;&amp;str&gt; = Vec::new();
    let s: String = "Short-lived".into();
    v.push(&amp;s);
    drop(s);
} // &lt;- 여기서 `v`가 드롭됩니다</code></pre></pre>
<p>고전적인 <code>impl&lt;T&gt; Drop for Vec&lt;T&gt; {</code> 정의를 사용하면, 위 코드는 <a href="https://rust.godbolt.org/z/ans15Kqz3">거부됩니다</a>.</p>
<p>실제로 이 경우 우리는 문자열에 대한 <code>'s</code> 수명을 가진 참조들의 벡터인 <code>Vec&lt;&amp;'s str&gt;</code>을 가지고 있습니다. 하지만 <code>let s: String</code>의 경우 <code>Vec</code>보다 먼저 드롭되므로, <code>Vec</code>이 드롭되고 <code>impl&lt;'s&gt; Drop for Vec&lt;&amp;'s str&gt;</code>이 사용될 시점에는 <code>'s</code>가 <strong>만료된(expired)</strong> 상태입니다.</p>
<p>이는 만약 그런 <code>Drop</code>이 사용된다면, 그것은 <em>만료된</em> 혹은 <em>댕글링된</em> 수명 <code>'s</code>를 다루게 된다는 것을 의미합니다. 하지만 이는 함수 시그니처에 포함된 모든 러스트 참조가 기본적으로 댕글링되지 않으며 역참조가 유효해야 한다는 러스트의 원칙에 어긋납니다.</p>
<p>이것이 러스트가 이 조각을 보수적으로 거부해야 하는 이유입니다.</p>
<p>그럼에도 불구하고 실제 <code>Vec</code>의 경우, <code>Drop</code> 구현은 <code>&amp;'s str</code>에 신경 쓰지 않습니다. 왜냐하면 <code>&amp;'s str</code>은 <em>자체적인 드롭 글루가 없기</em> 때문입니다. <code>Vec</code>은 오직 배후 버퍼를 해제하기만을 원할 뿐입니다.</p>
<p>달리 말하면, <code>Vec</code>을 특별 케이스로 처리하거나 <code>Vec</code>의 어떤 특별한 속성에 의존함으로써 위의 코드가 어떻게든 받아들여질 수 있다면 좋을 것입니다. 즉, <code>Vec</code>은 _드롭될 때 자신이 들고 있는 <code>&amp;'s str</code>들을 사용하지 않겠다고 약속_할 수 있을 것입니다.</p>
<p>이것이 바로 <code>#[may_dangle]</code>을 통해 표현할 수 있는 <code>unsafe</code>한 약속의 종류입니다:</p>
<pre><code class="language-rust  ignore">unsafe impl&lt;#[may_dangle] 's&gt; Drop for Vec&lt;&amp;'s str&gt; { /* … */ }</code></pre>
<p>또는 더 일반적으로는 다음과 같습니다:</p>
<pre><code class="language-rust  ignore">unsafe impl&lt;#[may_dangle] T&gt; Drop for Vec&lt;T&gt; { /* … */ }</code></pre>
<p>이는 드롭되는 인스턴스의 타입 매개변수가 댕글링되어서는 안 된다는 러스트 드롭 검사기의 보수적인 가정을 선택적으로 벗어나기(opt out) 위한 <code>unsafe</code>한 방법입니다.</p>
<p>표준 라이브러리에서처럼 이렇게 할 때는 <code>T</code> 자체가 드롭 글루(drop glue)를 가지고 있는 경우를 주의해야 합니다. 이 예시에서, <code>&amp;'s str</code>들을 <code>struct PrintOnDrop&lt;'s&gt;(&amp;'s str);</code>로 바꾼다고 상상해 보세요. 이 구조체는 <code>Drop</code> 구현 내에서 내부의 <code>&amp;'s str</code>을 역참조하여 화면에 출력할 것입니다.</p>
<p>실제로 <code>Drop for Vec&lt;T&gt;</code>는 배후 버퍼를 해제하기 전에, 각 <code>T</code> 아이템이 드롭 글루를 가지고 있다면 그것들을 전이적으로(transitively) 드롭해야 합니다. <code>PrintOnDrop&lt;'s&gt;</code>의 경우, <code>Drop for Vec&lt;PrintOnDrop&lt;'s&gt;&gt;</code>는 버퍼 해제 전에 <code>PrintOnDrop&lt;'s&gt;</code> 요소들을 전이적으로 드롭해야 함을 의미합니다.</p>
<p>따라서 우리가 <code>'s</code>가 <code>#[may_dangle]</code>하다고 말한 것은 지나치게 느슨한 표현이었습니다. 우리는 차라리 이렇게 말하고 싶을 것입니다: "<code>'s</code>는 전이적인 드롭 글루에 관여하지 않는 한 댕글링될 수 있다". 또는 더 일반적으로, "<code>T</code>는 전이적인 드롭 글루에 관여하지 않는 한 댕글링될 수 있다". 이 "예외의 예외"는 우리가 <strong><code>T</code>를 소유하고 있을 때</strong>마다 발생하는 만연한 상황입니다. 이것이 바로 러스트의 <code>#[may_dangle]</code>이 이러한 예외 상황을 알 만큼 충분히 똑똑한 이유이며, 따라서 <em>제네릭 매개변수가 구조체의 필드에 의해 소유되는 방식(owned fashion)으로 유지될 때</em> 이 기능은 비활성화될 것입니다.</p>
<p>그렇기 때문에 표준 라이브러리는 결국 다음과 같은 형태가 됩니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(any())]
</span>// 우리는 `Vec`을 드롭할 때 `T`를 사용하지 않겠다고 새끼손가락 걸고 약속합니다...
unsafe impl&lt;#[may_dangle] T&gt; Drop for Vec&lt;T&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            if mem::needs_drop::&lt;T&gt;() {
                /* ... 즉, 여기를 제외하고는 말이죠 ... */
                ptr::drop_in_place::&lt;[T]&gt;(/* … */);
            }
            // ...
            dealloc(/* … */)
            // ...
        }
    }
}

struct Vec&lt;T&gt; {
    // ... `Vec`이 `T` 아이템들을 소유하고 있으며
    // 따라서 드롭 시점에 `T` 아이템들을 드롭할 수 있다는 사실만 제외하고 말이죠!
    _owns_T: core::marker::PhantomData&lt;T&gt;,

    ptr: *const T, // 공변성을 위한 `*const` (하지만 이것은 그 자체로 `T`에 대한 소유권을 표현하지는 않습니다)
    len: usize,
    cap: usize,
}
<span class="boring">}</span></code></pre></pre>
</details>
<hr />
<p>할당된 메모리를 소유하는 원시 포인터는 매우 흔한 패턴이어서, 표준 라이브러리는 스스로를 위해 <code>Unique&lt;T&gt;</code>라는 유틸리티를 만들었습니다. 이 유틸리티는 다음과 같은 특징을 가집니다:</p>
<ul>
<li>공변성을 위해 <code>*const T</code>를 감쌉니다</li>
<li><code>PhantomData&lt;T&gt;</code>를 포함합니다</li>
<li>T가 포함된 것처럼 <code>Send</code>/<code>Sync</code>를 자동으로 파생합니다</li>
<li>널 포인터 최적화를 위해 포인터를 <code>NonZero</code>로 표시합니다</li>
</ul>
<h2 id="phantomdata-패턴-표"><a class="header" href="#phantomdata-패턴-표"><code>PhantomData</code> 패턴 표</a></h2>
<p>다음은 <code>PhantomData</code>가 사용될 수 있는 모든 멋진 방법들을 정리한 표입니다:</p>
<div class="table-wrapper"><table><thead><tr><th>팬텀 타입</th><th style="text-align: center"><code>'a</code>의 공변성</th><th style="text-align: center"><code>T</code>의 공변성</th><th style="text-align: center"><code>Send</code>/<code>Sync</code><br/>(혹은 그 결여)</th><th style="text-align: center">드롭 글루에서의 <code>'a</code> 또는 <code>T</code> 댕글링<br/>(예: <code>#[may_dangle] Drop</code>)</th></tr></thead><tbody>
<tr><td><code>PhantomData&lt;T&gt;</code></td><td style="text-align: center">-</td><td style="text-align: center"><strong>공변(covariant)</strong></td><td style="text-align: center">상속됨</td><td style="text-align: center">허용되지 않음 ("<code>T</code>를 소유함")</td></tr>
<tr><td><code>PhantomData&lt;&amp;'a T&gt;</code></td><td style="text-align: center"><strong>공변(covariant)</strong></td><td style="text-align: center"><strong>공변(covariant)</strong></td><td style="text-align: center"><code>Send + Sync</code><br/><code>T : Sync</code> 요구됨</td><td style="text-align: center">허용됨</td></tr>
<tr><td><code>PhantomData&lt;&amp;'a mut T&gt;</code></td><td style="text-align: center"><strong>공변(covariant)</strong></td><td style="text-align: center"><strong>불변(invariant)</strong></td><td style="text-align: center">상속됨</td><td style="text-align: center">허용됨</td></tr>
<tr><td><code>PhantomData&lt;*const T&gt;</code></td><td style="text-align: center">-</td><td style="text-align: center"><strong>공변(covariant)</strong></td><td style="text-align: center"><code>!Send + !Sync</code></td><td style="text-align: center">허용됨</td></tr>
<tr><td><code>PhantomData&lt;*mut T&gt;</code></td><td style="text-align: center">-</td><td style="text-align: center"><strong>불변(invariant)</strong></td><td style="text-align: center"><code>!Send + !Sync</code></td><td style="text-align: center">허용됨</td></tr>
<tr><td><code>PhantomData&lt;fn(T)&gt;</code></td><td style="text-align: center">-</td><td style="text-align: center"><strong>반공변(contravariant)</strong></td><td style="text-align: center"><code>Send + Sync</code></td><td style="text-align: center">허용됨</td></tr>
<tr><td><code>PhantomData&lt;fn() -&gt; T&gt;</code></td><td style="text-align: center">-</td><td style="text-align: center"><strong>공변(covariant)</strong></td><td style="text-align: center"><code>Send + Sync</code></td><td style="text-align: center">허용됨</td></tr>
<tr><td><code>PhantomData&lt;fn(T) -&gt; T&gt;</code></td><td style="text-align: center">-</td><td style="text-align: center"><strong>불변(invariant)</strong></td><td style="text-align: center"><code>Send + Sync</code></td><td style="text-align: center">허용됨</td></tr>
<tr><td><code>PhantomData&lt;Cell&lt;&amp;'a ()&gt;&gt;</code></td><td style="text-align: center"><strong>불변(invariant)</strong></td><td style="text-align: center">-</td><td style="text-align: center"><code>Send + !Sync</code></td><td style="text-align: center">허용됨</td></tr>
</tbody></table>
</div>
<ul>
<li>참고: <code>Unpin</code> 오토 트레잇을 취소(opt out)하려면 대신 전용 타입인 <a href="../core/marker/struct.PhantomPinned.html"><code>PhantomPinned</code></a>이 필요합니다.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="차용-분할"><a class="header" href="#차용-분할">차용 분할</a></h1>
<p>가변 참조의 상호 배제(mutual exclusion) 속성은 복합 구조체로 작업할 때 매우 제한적일 수 있습니다. 빌림 검사기(borrowck)는 몇 가지 기본적인 사항은 이해하지만, 꽤 쉽게 한계에 부딪힙니다. 구조체에 대해서는 충분히 이해하고 있어서, 구조체의 서로 겹치지 않는(disjoint) 필드들을 동시에 대여하는 것이 가능하다는 것을 압니다. 따라서 다음과 같은 코드는 오늘날 정상적으로 작동합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    a: i32,
    b: i32,
    c: i32,
}

let mut x = Foo {a: 0, b: 0, c: 0};
let a = &amp;mut x.a;
let b = &amp;mut x.b;
let c = &amp;x.c;
*b += 1;
let c2 = &amp;x.c;
*a += 10;
println!("{} {} {} {}", a, b, c, c2);
<span class="boring">}</span></code></pre></pre>
<p>하지만 빌림 검사기는 배열이나 슬라이스를 전혀 이해하지 못하므로, 다음과 같은 코드는 작동하지 않습니다:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = [1, 2, 3];
let a = &amp;mut x[0];
let b = &amp;mut x[1];
println!("{} {}", a, b);
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-text">error[E0499]: `x[..]`를 한 번에 두 번 이상 가변으로 대여할 수 없습니다
 --&gt; src/lib.rs:4:18
  |
3 |     let a = &amp;mut x[0];
  |                  ---- 첫 번째 가변 대여가 여기서 발생함
4 |     let b = &amp;mut x[1];
  |                  ^^^^ 두 번째 가변 대여가 여기서 발생함
5 |     println!("{} {}", a, b);
6 | }
  | - 첫 번째 대여가 여기서 끝남

error: 이전 에러로 인해 중단됨
</code></pre>
<p>빌림 검사기가 이 간단한 사례를 이해할 수 있을 것이라는 기대는 해볼 수 있겠지만, 트리와 같은 일반적인 컨테이너 타입에서 서로 겹치지 않음을 이해하는 것은 분명히 가망이 없습니다. 특히 서로 다른 키들이 실제로 <em>같은</em> 값을 가리키는 경우라면 더더욱 그렇습니다.</p>
<p>우리가 하려는 일이 괜찮다는 것을 빌림 검사기에게 "가르치기" 위해, 우리는 unsafe 코드로 내려가야 합니다. 예를 들어, 가변 슬라이스는 슬라이스를 소비하고 두 개의 가변 슬라이스를 반환하는 <code>split_at_mut</code> 함수를 노출합니다. 하나는 인덱스의 왼쪽 전부를 위한 것이고, 다른 하나는 오른쪽 전부를 위한 것입니다. 직관적으로 우리는 이 슬라이스들이 겹치지 않으며 따라서 별칭이 발생하지 않으므로 안전하다는 것을 압니다. 하지만 그 구현에는 약간의 비안전성(unsafety)이 필요합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::slice::from_raw_parts_mut;
</span><span class="boring">struct FakeSlice&lt;T&gt;(T);
</span><span class="boring">impl&lt;T&gt; FakeSlice&lt;T&gt; {
</span><span class="boring">fn len(&amp;self) -&gt; usize { unimplemented!() }
</span><span class="boring">fn as_mut_ptr(&amp;mut self) -&gt; *mut T { unimplemented!() }
</span>pub fn split_at_mut(&amp;mut self, mid: usize) -&gt; (&amp;mut [T], &amp;mut [T]) {
    let len = self.len();
    let ptr = self.as_mut_ptr();

    unsafe {
        assert!(mid &lt;= len);

        (from_raw_parts_mut(ptr, mid),
         from_raw_parts_mut(ptr.add(mid), len - mid))
    }
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>이것은 사실 약간 미묘합니다. 같은 값에 대해 두 개의 <code>&amp;mut</code>를 만드는 상황을 피하기 위해, 우리는 원시 포인터를 통해 완전히 새로운 슬라이스를 명시적으로 생성합니다.</p>
<p>하지만 가변 참조를 생성하는 반복자가 어떻게 작동하는지는 훨씬 더 미묘합니다. 반복자 트레잇은 다음과 같이 정의됩니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>이 정의에 따르면, <code>Self::Item</code>은 <code>self</code>와 아무런 연결 고리가 없습니다. 이는 우리가 <code>next</code>를 여러 번 연속해서 호출하고, 모든 결과들을 <em>동시에</em> 들고 있을 수 있음을 의미합니다. 이는 정확히 이러한 의미론을 가진 값에 의한(by-value) 반복자에게는 완벽하게 괜찮습니다. 공유 참조의 경우에도 동일한 대상에 대해 임의의 개수만큼 참조를 허용하므로 괜찮습니다 (물론 반복자는 공유되는 대상과는 별개의 객체여야 합니다).</p>
<p>하지만 가변 참조는 이를 엉망으로 만듭니다. 언뜻 보기에는 동일한 객체에 대해 여러 개의 가변 참조를 생성할 수 있으므로 이 API와 완전히 호환되지 않는 것처럼 보일 수 있습니다!</p>
<p>하지만 반복자는 일회성(one-shot) 객체이기 때문에 실제로 <em>작동합니다</em>. <code>IterMut</code>가 생성하는 모든 것은 기껏해야 한 번만 생성되므로, 우리는 실제로 동일한 데이터 조각에 대해 여러 개의 가변 참조를 생성하지 않습니다.</p>
<p>놀랍게도, 가변 반복자를 구현할 때 많은 타입들에 대해 unsafe 코드가 필요하지 않습니다!</p>
<p>예를 들어, 여기 단일 연결 리스트(singly linked list)가 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {}
</span>type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

pub struct LinkedList&lt;T&gt; {
    head: Link&lt;T&gt;,
}

pub struct IterMut&lt;'a, T: 'a&gt;(Option&lt;&amp;'a mut Node&lt;T&gt;&gt;);

impl&lt;T&gt; LinkedList&lt;T&gt; {
    fn iter_mut(&amp;mut self) -&gt; IterMut&lt;T&gt; {
        IterMut(self.head.as_mut().map(|node| &amp;mut **node))
    }
}

impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
    type Item = &amp;'a mut T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.0.take().map(|node| {
            self.0 = node.next.as_mut().map(|node| &amp;mut **node);
            &amp;mut node.elem
        })
    }
}</code></pre></pre>
<p>여기 가변 슬라이스가 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {}
</span>use std::mem;

pub struct IterMut&lt;'a, T: 'a&gt;(&amp;'a mut[T]);

impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
    type Item = &amp;'a mut T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let slice = mem::take(&amp;mut self.0);
        if slice.is_empty() { return None; }

        let (l, r) = slice.split_at_mut(1);
        self.0 = r;
        l.get_mut(0)
    }
}

impl&lt;'a, T&gt; DoubleEndedIterator for IterMut&lt;'a, T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let slice = mem::take(&amp;mut self.0);
        if slice.is_empty() { return None; }

        let new_len = slice.len() - 1;
        let (l, r) = slice.split_at_mut(new_len);
        self.0 = l;
        r.get_mut(0)
    }
}</code></pre></pre>
<p>그리고 여기 이진 트리(binary tree)가 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {}
</span>use std::collections::VecDeque;

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    left: Link&lt;T&gt;,
    right: Link&lt;T&gt;,
}

pub struct Tree&lt;T&gt; {
    root: Link&lt;T&gt;,
}

struct NodeIterMut&lt;'a, T: 'a&gt; {
    elem: Option&lt;&amp;'a mut T&gt;,
    left: Option&lt;&amp;'a mut Node&lt;T&gt;&gt;,
    right: Option&lt;&amp;'a mut Node&lt;T&gt;&gt;,
}

enum State&lt;'a, T: 'a&gt; {
    Elem(&amp;'a mut T),
    Node(&amp;'a mut Node&lt;T&gt;),
}

pub struct IterMut&lt;'a, T: 'a&gt;(VecDeque&lt;NodeIterMut&lt;'a, T&gt;&gt;);

impl&lt;T&gt; Tree&lt;T&gt; {
    pub fn iter_mut(&amp;mut self) -&gt; IterMut&lt;T&gt; {
        let mut deque = VecDeque::new();
        if let Some(root) = self.root.as_mut() {
            deque.push_front(root.iter_mut());
        }
        IterMut(deque)
    }
}

impl&lt;T&gt; Node&lt;T&gt; {
    pub fn iter_mut(&amp;mut self) -&gt; NodeIterMut&lt;T&gt; {
        NodeIterMut {
            elem: Some(&amp;mut self.elem),
            left: self.left.as_deref_mut(),
            right: self.right.as_deref_mut(),
        }
    }
}

impl&lt;'a, T&gt; Iterator for NodeIterMut&lt;'a, T&gt; {
    type Item = State&lt;'a, T&gt;;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.left.take().map(State::Node).or_else(|| {
            self.elem
                .take()
                .map(State::Elem)
                .or_else(|| self.right.take().map(State::Node))
        })
    }
}

impl&lt;'a, T&gt; DoubleEndedIterator for NodeIterMut&lt;'a, T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.right.take().map(State::Node).or_else(|| {
            self.elem
                .take()
                .map(State::Elem)
                .or_else(|| self.left.take().map(State::Node))
        })
    }
}

impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
    type Item = &amp;'a mut T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        loop {
            match self.0.front_mut().and_then(Iterator::next) {
                Some(State::Elem(elem)) =&gt; return Some(elem),
                Some(State::Node(node)) =&gt; self.0.push_front(node.iter_mut()),
                None =&gt; {
                    self.0.pop_front()?;
                }
            }
        }
    }
}

impl&lt;'a, T&gt; DoubleEndedIterator for IterMut&lt;'a, T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        loop {
            match self.0.back_mut().and_then(DoubleEndedIterator::next_back) {
                Some(State::Elem(elem)) =&gt; return Some(elem),
                Some(State::Node(node)) =&gt; self.0.push_back(node.iter_mut()),
                None =&gt; {
                    self.0.pop_back()?;
                }
            }
        }
    }
}</code></pre></pre>
<p>이 모든 것들은 완전히 안전하며 안정(stable) 버전 러스트에서 작동합니다! 이는 궁극적으로 이전에 보았던 간단한 구조체 사례에서 비롯됩니다. 러스트는 가변 참조를 하위 필드들로 안전하게 분할할 수 있음을 이해합니다. 우리는 <code>Option</code>을 통해 참조를 영구적으로 소비하도록 인코딩할 수 있습니다 (또는 슬라이스의 경우, 빈 슬라이스로 교체하는 방식을 사용할 수 있습니다).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="타입-변환"><a class="header" href="#타입-변환">타입 변환</a></h1>
<p>결국 모든 것은 어딘가에 있는 비트들의 뭉치일 뿐이며, 타입 시스템은 우리가 그 비트들을 올바르게 사용하도록 돕기 위해 존재합니다. 비트에 타입을 부여할 때 발생하는 두 가지 일반적인 문제가 있습니다. 하나는 그 비트들을 정확히 다른 타입으로 재해석(reinterpret)해야 하는 것이고, 다른 하나는 비트를 변경하여 다른 타입에 대해 동등한 의미를 갖도록 하는 것입니다. 러스트는 중요한 속성들을 타입 시스템에 인코딩하는 것을 권장하기 때문에, 이러한 문제들은 매우 흔하게 발생합니다. 따라서 러스트는 이를 해결하기 위한 여러 가지 방법을 제공합니다.</p>
<p>먼저 안전한(Safe) 러스트가 값을 재해석하기 위해 제공하는 방법들을 살펴보겠습니다. 이를 수행하는 가장 사소한 방법은 값을 구성 요소로 해체한 다음, 그것들로 새로운 타입을 만드는 것입니다. 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    x: u32,
    y: u16,
}

struct Bar {
    a: u32,
    b: u16,
}

fn reinterpret(foo: Foo) -&gt; Bar {
    let Foo { x, y } = foo;
    Bar { a: x, b: y }
}
<span class="boring">}</span></code></pre></pre>
<p>하지만 이 방식은 기껏해야 번거로울 뿐입니다. 일반적인 변환을 위해, 러스트는 더 인체공학적인 대안들을 제공합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="강제-변환"><a class="header" href="#강제-변환">강제 변환</a></h1>
<p>타입은 특정 문맥에서 암시적으로 강제 변환(coerced)될 수 있습니다. 이러한 변화는 일반적으로 타입의 _약화(weakening)_이며, 주로 포인터와 수명에 집중되어 있습니다. 이것들은 대부분 러스트가 더 많은 경우에 "그냥 작동"하도록 만들기 위해 존재하며, 대체로 무해합니다.</p>
<p>모든 강제 변환 종류에 대한 포괄적인 목록은 참조서의 <a href="../reference/type-coercions.html#coercion-types">강제 변환 종류(Coercion types)</a> 섹션을 확인하세요.</p>
<p>트레잇 매칭 시에는 강제 변환을 수행하지 않는다는 점에 유의하세요 (수신자(receiver)의 경우는 제외하며, <a href="./dot-operator.html">다음 페이지</a>를 참조하세요). 어떤 타입 <code>U</code>에 대한 <code>impl</code>이 있고 <code>T</code>가 <code>U</code>로 강제 변환될 수 있다고 해서, 그것이 <code>T</code>에 대한 구현이 되는 것은 아닙니다. 예를 들어, 다음 코드는 <code>t</code>를 <code>&amp;T</code>로 강제 변환할 수 있고 <code>&amp;T</code>에 대한 <code>impl</code>이 있음에도 불구하고 타입 검사를 통과하지 못합니다:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024">trait Trait {}

fn foo&lt;X: Trait&gt;(t: X) {}

impl&lt;'a&gt; Trait for &amp;'a i32 {}

fn main() {
    let t: &amp;mut i32 = &amp;mut 0;
    foo(t);
}</code></pre></pre>
<p>이는 다음과 같이 실패합니다:</p>
<pre><code class="language-text">error[E0277]: the trait bound `&amp;mut i32: Trait` is not satisfied
 --&gt; src/main.rs:9:9
  |
3 | fn foo&lt;X: Trait&gt;(t: X) {}
  |           ----- required by this bound in `foo`
...
9 |     foo(t);
  |         ^ the trait `Trait` is not implemented for `&amp;mut i32`
  |
  = help: the following implementations were found:
            &lt;&amp;'a i32 as Trait&gt;
  = note: `Trait` is implemented for `&amp;i32`, but not for `&amp;mut i32`
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="점-연산자"><a class="header" href="#점-연산자">점 연산자</a></h1>
<p>The dot operator will perform a lot of magic to convert types. It will perform auto-referencing, auto-dereferencing, and coercion until types match. The detailed mechanics of method lookup are defined <a href="https://rustc-dev-guide.rust-lang.org/hir-typeck/method-lookup.html">here</a>, but here is a brief overview that outlines the main steps.</p>
<p>수신자(<code>self</code>, <code>&amp;self</code>, 또는 <code>&amp;mut self</code> 매개변수)를 가진 함수 <code>foo</code>가 있다고 가정해 봅시다. <code>value.foo()</code>를 호출하면, 컴파일러는 함수의 올바른 구현을 호출하기 전에 <code>Self</code>가 어떤 타입인지 결정해야 합니다. 이 예제에서 <code>value</code>는 <code>T</code> 타입을 가진다고 하겠습니다.</p>
<p>어떤 타입에 대해 함수를 호출하고 있는지 정확히 하기 위해 <a href="../book/ch19-03-advanced-traits.html#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name">정규화된 구문(fully-qualified syntax)</a>을 사용하겠습니다.</p>
<ul>
<li>먼저, 컴파일러는 <code>T::foo(value)</code>를 직접 호출할 수 있는지 확인합니다. 이를 "값에 의한(by value)" 메서드 호출이라고 합니다.</li>
<li>만약 이 함수를 호출할 수 없다면(예를 들어 함수가 잘못된 타입을 가졌거나 <code>Self</code>에 대해 트레잇이 구현되지 않은 경우), 컴파일러는 자동 참조를 추가하려고 시도합니다. 즉, <code>&lt;&amp;T&gt;::foo(value)</code>와 <code>&lt;&amp;mut T&gt;::foo(value)</code>를 시도해 봅니다. 이를 "자동 참조(autoref)" 메서드 호출이라고 합니다.</li>
<li>이 후보들 중 어느 것도 작동하지 않으면, <code>T</code>를 역참조하고 다시 시도합니다. 이는 <code>Deref</code> 트레잇을 사용합니다. 만약 <code>T: Deref&lt;Target = U&gt;</code>라면 <code>T</code> 대신 <code>U</code> 타입으로 다시 시도합니다. <code>T</code>를 역참조할 수 없는 경우, <code>T</code>를 <em>언사이징(unsizing)</em> 해볼 수도 있습니다. 이는 <code>T</code>가 컴파일 타임에 알려진 크기 매개변수를 가지고 있다면, 메서드 조회를 위해 그것을 "잊어버리는" 것을 의미합니다. 예를 들어, 이 언사이징 단계는 배열의 크기를 "잊음"으로써 <code>[i32; 2]</code>를 <code>[i32]</code>로 변환할 수 있습니다.</li>
</ul>
<p>다음은 메서드 조회 알고리즘의 예시입니다:</p>
<pre><code class="language-rust ignore">let array: Rc&lt;Box&lt;[T; 3]&gt;&gt; = ...;
let first_entry = array[0];</code></pre>
<p>배열이 이토록 많은 간접 참조 뒤에 숨어 있을 때, 컴파일러는 실제로 어떻게 <code>array[0]</code>을 계산할까요? 먼저, <code>array[0]</code>은 실제로는 <a href="../std/ops/trait.Index.html"><code>Index</code></a> 트레잇에 대한 구문 설탕일 뿐입니다. 컴파일러는 <code>array[0]</code>을 <code>array.index(0)</code>으로 변환합니다. 이제 컴파일러는 함수를 호출할 수 있도록 <code>array</code>가 <code>Index</code>를 구현하는지 확인합니다.</p>
<p>그다음 컴파일러는 <code>Rc&lt;Box&lt;[T; 3]&gt;&gt;</code>가 <code>Index</code>를 구현하는지 확인하지만, 구현하지 않으며 <code>&amp;Rc&lt;Box&lt;[T; 3]&gt;&gt;</code>나 <code>&amp;mut Rc&lt;Box&lt;[T; 3]&gt;&gt;</code>도 마찬가지입니다. 어느 것도 작동하지 않았으므로, 컴파일러는 <code>Rc&lt;Box&lt;[T; 3]&gt;&gt;</code>를 <code>Box&lt;[T; 3]&gt;</code>로 역참조하고 다시 시도합니다. <code>Box&lt;[T; 3]&gt;</code>, <code>&amp;Box&lt;[T; 3]&gt;</code>, <code>&amp;mut Box&lt;[T; 3]&gt;</code>도 <code>Index</code>를 구현하지 않으므로 다시 역참조합니다. <code>[T; 3]</code>과 그 자동 참조들도 <code>Index</code>를 구현하지 않습니다. <code>[T; 3]</code>은 더 이상 역참조할 수 없으므로, 컴파일러는 이를 언사이징하여 <code>[T]</code>를 얻습니다. 마침내 <code>[T]</code>가 <code>Index</code>를 구현하고 있으므로, 이제 실제 <code>index</code> 함수를 호출할 수 있습니다.</p>
<p>점 연산자가 작동하는 더 복잡한 다음 예제를 고려해 보세요:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_stuff&lt;T: Clone&gt;(value: &amp;T) {
    let cloned = value.clone();
}
<span class="boring">}</span></code></pre></pre>
<p><code>cloned</code>는 어떤 타입일까요? 먼저 컴파일러는 값에 의해 호출할 수 있는지 확인합니다. <code>value</code>의 타입은 <code>&amp;T</code>이므로, <code>clone</code> 함수의 시그니처는 <code>fn clone(&amp;T) -&gt; T</code>가 됩니다. 컴파일러는 <code>T: Clone</code>임을 알고 있으므로 <code>cloned: T</code>임을 찾아냅니다.</p>
<p><code>T: Clone</code> 제약이 제거되면 어떻게 될까요? <code>T</code>에 대한 <code>Clone</code> 구현이 없으므로 값에 의해 호출할 수 없게 됩니다. 따라서 컴파일러는 자동 참조에 의한 호출을 시도합니다. 이 경우 <code>Self = &amp;T</code>이므로 함수의 시그니처는 <code>fn clone(&amp;&amp;T) -&gt; &amp;T</code>가 됩니다. 컴파일러는 <code>&amp;T: Clone</code>임을 확인하고, <code>cloned: &amp;T</code>라고 추론합니다.</p>
<p>다음은 자동 참조 동작이 미묘한 효과를 만들어내는 또 다른 예시입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">
</span>#[derive(Clone)]
struct Container&lt;T&gt;(Arc&lt;T&gt;);

fn clone_containers&lt;T&gt;(foo: &amp;Container&lt;i32&gt;, bar: &amp;Container&lt;T&gt;) {
    let foo_cloned = foo.clone();
    let bar_cloned = bar.clone();
}
<span class="boring">}</span></code></pre></pre>
<p><code>foo_cloned</code>와 <code>bar_cloned</code>는 어떤 타입일까요? <code>Container&lt;i32&gt;: Clone</code>임을 알고 있으므로, 컴파일러는 <code>clone</code>을 값에 의해 호출하여 <code>foo_cloned: Container&lt;i32&gt;</code>를 얻습니다. 하지만 <code>bar_cloned</code>는 실제로는 <code>&amp;Container&lt;T&gt;</code> 타입을 가집니다. 이것은 말이 안 되는 것 같습니다. <code>Container</code>에 <code>#[derive(Clone)]</code>을 추가했으니 반드시 <code>Clone</code>을 구현해야 합니다! 자세히 살펴보면, <code>derive</code> 매크로에 의해 생성된 코드는 (대략) 다음과 같습니다:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Clone for Container&lt;T&gt; where T: Clone {
    fn clone(&amp;self) -&gt; Self {
        Self(Arc::clone(&amp;self.0))
    }
}</code></pre>
<p>자동으로 파생된 <code>Clone</code> 구현은 <a href="../std/clone/trait.Clone.html#derivable"><code>T: Clone</code>인 경우에만 정의되므로</a>, 제네릭 <code>T</code>에 대해 <code>Container&lt;T&gt;: Clone</code> 구현은 존재하지 않습니다. 컴파일러는 <code>&amp;Container&lt;T&gt;</code>가 <code>Clone</code>을 구현하는지 확인하는데, 실제로 구현하고 있습니다. 따라서 <code>clone</code>이 자동 참조에 의해 호출되었다고 추론하여, <code>bar_cloned</code>는 <code>&amp;Container&lt;T&gt;</code> 타입을 갖게 됩니다.</p>
<p>우리는 <code>T: Clone</code>을 요구하지 않고 수동으로 <code>Clone</code>을 구현함으로써 이를 해결할 수 있습니다:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Clone for Container&lt;T&gt; {
    fn clone(&amp;self) -&gt; Self {
        Self(Arc::clone(&amp;self.0))
    }
}</code></pre>
<p>이제 타입 검사기는 <code>bar_cloned: Container&lt;T&gt;</code>라고 추론합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="캐스트"><a class="header" href="#캐스트">캐스트</a></h1>
<p>캐스트(Casts)는 강제 변환(coercions)의 슈퍼셋입니다. 모든 강제 변환은 캐스트를 통해 명시적으로 호출될 수 있습니다. 하지만 일부 변환은 반드시 캐스트가 필요합니다. 강제 변환은 흔하고 대체로 무해하지만, 이러한 "진정한 캐스트"는 드물고 잠재적으로 위험합니다. 따라서 캐스트는 <code>as</code> 키워드를 사용하여 명시적으로 호출해야 합니다: <code>expr as Type</code>.</p>
<p>참조서에서 <a href="../reference/expressions/operator-expr.html#type-cast-expressions">모든 진정한 캐스트</a>와 <a href="../reference/expressions/operator-expr.html#semantics">캐스팅 의미론</a>에 대한 포괄적인 목록을 찾을 수 있습니다.</p>
<h2 id="캐스팅의-안전성"><a class="header" href="#캐스팅의-안전성">캐스팅의 안전성</a></h2>
<p>진정한 캐스트는 주로 원시 포인터와 기본 숫자 타입들을 중심으로 이루어집니다. 위험함에도 불구하고, 이러한 캐스트들은 런타임에 실패하지 않습니다. 만약 캐스트가 어떤 미묘한 코너 케이스를 유발하더라도, 그것이 발생했다는 어떠한 징후도 제공되지 않을 것입니다. 캐스트는 그냥 성공할 것입니다. 그렇다 하더라도, 캐스트는 타입 수준에서 유효해야 하며, 그렇지 않으면 정적으로 차단됩니다. 예를 들어, <code>7u8 as bool</code>은 컴파일되지 않습니다.</p>
<p>그렇기는 하지만, 캐스트는 그 자체만으로는 일반적으로 메모리 안전성을 위반할 수 없기 때문에 <code>unsafe</code>가 아닙니다. 예를 들어, 정수를 원시 포인터로 변환하는 것은 아주 쉽게 끔찍한 일로 이어질 수 있습니다. 하지만 포인터 자체를 생성하는 행위는 안전합니다. 왜냐하면 실제로 원시 포인터를 사용하는 것 자체가 이미 <code>unsafe</code>로 표시되어 있기 때문입니다.</p>
<h2 id="캐스팅에-관한-몇-가지-참고-사항"><a class="header" href="#캐스팅에-관한-몇-가지-참고-사항">캐스팅에 관한 몇 가지 참고 사항</a></h2>
<h3 id="원시-슬라이스-캐스팅-시의-길이"><a class="header" href="#원시-슬라이스-캐스팅-시의-길이">원시 슬라이스 캐스팅 시의 길이</a></h3>
<p>원시 슬라이스를 캐스팅할 때 길이는 조정되지 않음에 유의하세요. <code>*const [u16] as *const [u8]</code>은 원래 메모리의 절반만 포함하는 슬라이스를 생성합니다.</p>
<h3 id="이행성transitivity"><a class="header" href="#이행성transitivity">이행성(Transitivity)</a></h3>
<p>캐스팅은 이행적이지 않습니다. 즉, <code>e as U1 as U2</code>가 유효한 표현식이라 하더라도 <code>e as U2</code>가 반드시 유효한 것은 아닙니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="트랜스뮤트"><a class="header" href="#트랜스뮤트">트랜스뮤트</a></h1>
<p>타입 시스템이여, 우리 길을 비켜라! 우리는 이 비트들을 재해석하거나, 그러다 죽을 것입니다! 이 책이 비안전한(unsafe) 일을 하는 것에 관한 것이긴 하지만, 이 섹션에서 다루는 작업들 대신 다른 방법(Another Way)을 찾기 위해 깊이 고민해야 한다는 점은 아무리 강조해도 지나치지 않습니다. 이것은 정말로, 진정으로 러스트에서 할 수 있는 가장 끔찍하게 비안전한 일입니다. 여기서의 가드레일은 치실 수준에 불과합니다.</p>
<p><a href="../std/mem/fn.transmute.html"><code>mem::transmute&lt;T, U&gt;</code></a>는 <code>T</code> 타입의 값을 받아서 <code>U</code> 타입으로 재해석합니다. 유일한 제한은 <code>T</code>와 <code>U</code>가 같은 크기를 가졌음이 검증되어야 한다는 것뿐입니다. 이것으로 정의되지 않은 동작(Undefined Behavior)을 일으킬 수 있는 방법은 상상을 초월할 정도로 많습니다.</p>
<ul>
<li>
<p>무엇보다도, 유효하지 않은 상태를 가진 <em>어떤</em> 타입의 인스턴스를 생성하는 것이든, 예측할 수 없는 임의의 혼란을 야기할 것입니다. <code>3</code>을 <code>bool</code>로 트랜스뮤트(transmute)하지 마세요. 심지어 그 <code>bool</code>로 아무것도 <em>하지</em> 않더라도 말입니다. 그냥 하지 마세요.</p>
</li>
<li>
<p>트랜스뮤트는 오버로드된 반환 타입을 가집니다. 만약 반환 타입을 명시하지 않으면, 추론을 만족시키기 위해 의외의 타입이 생성될 수 있습니다.</p>
</li>
<li>
<p><code>&amp;</code>를 <code>&amp;mut</code>로 트랜스뮤트하는 것은 정의되지 않은 동작입니다. 특정 사용 사례가 안전해 <em>보일</em> 수도 있지만, 러스트 최적화기는 공유 참조가 그 수명 동안 변하지 않을 것이라고 가정할 자유가 있으며, 따라서 그러한 트랜스뮤트는 그 가정을 위반하게 된다는 점에 유의하세요. 요컨대:</p>
<ul>
<li><code>&amp;</code>를 <code>&amp;mut</code>로 트랜스뮤트하는 것은 <em>언제나</em> 정의되지 않은 동작입니다.</li>
<li>아니요, 그렇게 할 수 없습니다.</li>
<li>아니요, 당신은 특별하지 않습니다.</li>
</ul>
</li>
<li>
<p>명시적인 수명을 제공하지 않고 참조로 트랜스뮤트하면 <a href="./unbounded-lifetimes.html">무한 수명(unbounded lifetime)</a>이 생성됩니다.</p>
</li>
<li>
<p>서로 다른 복합 타입 간에 트랜스뮤트할 때는, 그들의 레이아웃이 동일한지 확인해야 합니다! 만약 레이아웃이 다르다면 잘못된 필드에 잘못된 데이터가 채워질 것이고, 이는 여러분을 불행하게 만들 뿐만 아니라 정의되지 않은 동작이 될 수도 있습니다(위 내용을 참조하세요).</p>
<p>그렇다면 레이아웃이 같은지 어떻게 알 수 있을까요? <code>repr(C)</code> 타입과 <code>repr(transparent)</code> 타입의 경우 레이아웃이 정밀하게 정의되어 있습니다. 하지만 일반적인 <code>repr(Rust)</code>의 경우 그렇지 않습니다. 심지어 같은 제네릭 타입의 서로 다른 인스턴스들도 완전히 다른 레이아웃을 가질 수 있습니다. <code>Vec&lt;i32&gt;</code>와 <code>Vec&lt;u32&gt;</code>는 필드 순서가 같을 수도 있고, 다를 수도 있습니다. 데이터 레이아웃에 대해 정확히 무엇이 보장되고 무엇이 보장되지 않는지에 대한 세부 사항은 여전히 <a href="https://rust-lang.github.io/unsafe-code-guidelines/layout.html">UCG WG</a>에서 논의 중입니다.</p>
</li>
</ul>
<p><a href="../std/mem/fn.transmute_copy.html"><code>mem::transmute_copy&lt;T, U&gt;</code></a>는 어쩐지 이보다 훨씬 더 비안전합니다. 이 함수는 <code>&amp;T</code>에서 <code>size_of&lt;U&gt;</code> 바이트만큼을 복사하여 <code>U</code>로 해석합니다. <code>mem::transmute</code>가 가진 크기 체크가 여기서는 사라졌지만(접두사만 복사하는 것이 유효할 수도 있기 때문입니다), <code>U</code>가 <code>T</code>보다 크면 정의되지 않은 동작입니다.</p>
<p>물론 원시 포인터 캐스트나 <code>union</code>을 사용하여 이러한 함수들의 모든 기능을 구현할 수 있지만, 린트(lint)나 다른 기본적인 상태 체크(sanity check)를 전혀 받을 수 없습니다. 원시 포인터 캐스트와 <code>union</code>이 마법처럼 위의 규칙들을 피해가게 해주는 것은 아닙니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="초기화되지-않은-메모리-작업하기"><a class="header" href="#초기화되지-않은-메모리-작업하기">초기화되지 않은 메모리 작업하기</a></h1>
<p>러스트 프로그램에서 런타임에 할당된 모든 메모리는 <em>초기화되지 않은(uninitialized)</em> 상태로 시작됩니다. 이 상태에서 메모리의 값은 결정되지 않은 비트 더미일 뿐이며, 해당 메모리 위치에 있어야 할 타입의 유효한 상태를 반영하지 않을 수도 있습니다. 이 메모리를 <em>어떠한</em> 타입의 값으로든 해석하려고 시도하는 것은 정의되지 않은 동작을 야기할 것입니다. 절대 하지 마세요.</p>
<p>러스트는 초기화되지 않은 메모리를 확인된(안전한) 방식과 확인되지 않은(비안전한) 방식으로 다룰 수 있는 메커니즘을 제공합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="확인된-초기화되지-않은-메모리"><a class="header" href="#확인된-초기화되지-않은-메모리">확인된 초기화되지 않은 메모리</a></h1>
<p>C와 마찬가지로, 러스트의 모든 스택 변수는 값이 명시적으로 할당되기 전까지는 초기화되지 않은 상태입니다. C와 달리, 러스트는 값을 할당하기 전에는 결코 읽을 수 없도록 정적으로 방지합니다:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024">fn main() {
    let x: i32;
    println!("{}", x);
}</code></pre></pre>
<pre><code class="language-text">  |
3 |     println!("{}", x);
  |                    ^ 초기화되지 않았을 가능성이 있는 `x`를 사용함
</code></pre>
<p>이는 기본적인 분기 분석(branch analysis)에 근거합니다. 모든 분기는 <code>x</code>가 처음 사용되기 전에 반드시 값을 할당해야 합니다. 간단히 말해서 "<code>x</code>는 초기화됨(init)" 혹은 "<code>x</code>는 미초기화됨(uninit)"이라고도 합니다.</p>
<p>흥미롭게도, 모든 분기가 정확히 한 번만 할당한다면 지연된 초기화(delayed initialization)를 수행하기 위해 변수를 가변(mutable)으로 설정할 필요가 없습니다. 하지만 분석 과정에서 상수 분석(constant analysis) 등을 활용하지는 않습니다. 따라서 다음 코드는 컴파일됩니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let x: i32;

    if true {
        x = 1;
    } else {
        x = 2;
    }

    println!("{}", x);
}</code></pre></pre>
<p>하지만 다음 코드는 컴파일되지 않습니다:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024">fn main() {
    let x: i32;
    if true {
        x = 1;
    }
    println!("{}", x);
}</code></pre></pre>
<pre><code class="language-text">  |
6 |     println!("{}", x);
  |                    ^ 초기화되지 않았을 가능성이 있는 `x`를 사용함
</code></pre>
<p>반면 다음 코드는 컴파일됩니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let x: i32;
    if true {
        x = 1;
        println!("{}", x);
    }
    // 초기화되지 않은 분기가 있더라도 상관없습니다.
    // 해당 분기에서는 그 값을 사용하지 않기 때문입니다.
}</code></pre></pre>
<p>물론 분석 과정에서 실제 값을 고려하지는 않지만, 의존성과 제어 흐름에 대해서는 비교적 정교한 이해를 가지고 있습니다. 예를 들어, 다음 코드는 작동합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: i32;

loop {
    // 러스트는 이 분기가 무조건적으로 실행될 것이라는 점을 이해하지 못합니다.
    // 실제 값에 의존하기 때문입니다.
    if true {
        // 하지만 무조건적으로 루프를 빠져나오기(break) 때문에
        // 이 분기가 한 번만 실행될 것이라는 점은 이해합니다.
        // 따라서 `x`를 가변(mutable)으로 표시할 필요가 없습니다.
        x = 0;
        break;
    }
}
// 또한 break문에 도달하지 않고서는 여기로 올 수 없다는 것도 알고 있습니다.
// 따라서 여기서 `x`는 반드시 초기화되어 있어야 합니다!
println!("{}", x);
<span class="boring">}</span></code></pre></pre>
<p>변수에서 값을 꺼내어 이동시키면(move), 해당 값의 타입이 <code>Copy</code>가 아닐 경우 그 변수는 논리적으로 초기화되지 않은 상태가 됩니다. 즉:</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let x = 0;
    let y = Box::new(0);
    let z1 = x; // i32은 Copy이므로 x는 여전히 유효합니다
    let z2 = y; // Box는 Copy가 아니므로 y는 이제 논리적으로 초기화되지 않은 상태입니다
}</code></pre></pre>
<p>하지만 이 예제에서 <code>y</code>를 재할당하려면 <code>y</code>를 가변(mutable)으로 표시해야 <em>할 것입니다</em>. 안전한 러스트 프로그램이 <code>y</code>의 값이 변했다는 것을 관찰할 수 있기 때문입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let mut y = Box::new(0);
    let z = y; // Box는 Copy가 아니므로 y는 이제 논리적으로 초기화되지 않은 상태입니다
    y = Box::new(1); // y를 재초기화
}</code></pre></pre>
<p>그렇지 않으면 <code>y</code>는 마치 아주 새로운 변수인 것처럼 다뤄집니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="드롭-플래그"><a class="header" href="#드롭-플래그">드롭 플래그</a></h1>
<p>이전 섹션의 예제들은 러스트에게 흥미로운 과제를 던져줍니다. 우리는 메모리 위치를 조건부로 초기화, 미초기화, 그리고 재초기화하는 것이 완전히 안전하게 가능하다는 것을 보았습니다. <code>Copy</code> 타입의 경우, 그것들은 단지 무작위적인 비트 더미일 뿐이므로 특별히 주목할 만한 점은 없습니다. 하지만 소멸자(destructor)를 가진 타입들의 경우는 이야기가 다릅니다. 러스트는 변수에 값이 할당되거나 변수가 스코프를 벗어날 때마다 소멸자를 호출해야 할지 말아야 할지를 알아야 합니다. 조건부 초기화가 이루어지는 상황에서 어떻게 이를 수행할 수 있을까요?</p>
<p>모든 할당이 이 문제를 걱정해야 하는 것은 아닙니다. 특히 역참조(dereference)를 통한 할당은 무조건 드롭(drop)을 수행하며, <code>let</code>을 통한 할당은 무조건 드롭을 수행하지 않습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = Box::new(0); // let은 새로운 변수를 만드므로, 결코 드롭할 필요가 없습니다
let y = &amp;mut x;
*y = Box::new(1); // 역참조는 지칭 대상이 초기화되었다고 가정하므로, 항상 드롭합니다
<span class="boring">}</span></code></pre></pre>
<p>이는 이전에 초기화된 변수나 그 하위 필드를 덮어쓸 때만 문제가 됩니다.</p>
<p>알고 보니 러스트는 실제로 타입이 드롭되어야 하는지 여부를 <em>런타임에</em> 추적합니다. 변수가 초기화되거나 미초기화됨에 따라, 해당 변수에 대한 _드롭 플래그(drop flag)_가 토글됩니다. 변수가 드롭될 필요가 있을 때, 이 플래그를 확인하여 실제로 드롭을 수행할지 결정합니다.</p>
<p>물론, 값의 초기화 상태가 프로그램의 모든 시점에서 정적으로 알려질 수 있는 경우도 많습니다. 이런 경우 컴파일러는 이론적으로 더 효율적인 코드를 생성할 수 있습니다! 예를 들어, 분기 없는 직선적인 코드는 다음과 같은 _정적 드롭 의미론(static drop semantics)_을 갖습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = Box::new(0); // x는 미초기화 상태였음. 그냥 덮어씀.
let mut y = x;           // y는 미초기화 상태였음. 그냥 덮어쓰고 x를 미초기화 상태로 만듦.
x = Box::new(0);         // x는 미초기화 상태였음. 그냥 덮어씀.
y = x;                   // y는 초기화된 상태였음. y를 드롭하고, 덮어쓰고, x를 미초기화 상태로 만듦!
                         // y가 스코프를 벗어남. y는 초기화된 상태였음. y를 드롭!
                         // x가 스코프를 벗어남. x는 미초기화 상태였음. 아무것도 하지 않음.
<span class="boring">}</span></code></pre></pre>
<p>마찬가지로, 모든 분기가 초기화와 관련하여 동일하게 동작하는 분기 코드도 정적 드롭 의미론을 갖습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let condition = true;
</span>let mut x = Box::new(0);    // x는 미초기화 상태였음. 그냥 덮어씀.
if condition {
    drop(x)                 // x가 이동됨. x를 미초기화 상태로 만듦.
} else {
    println!("{}", x);
    drop(x)                 // x가 이동됨. x를 미초기화 상태로 만듦.
}
x = Box::new(0);            // x는 미초기화 상태였음. 그냥 덮어씀.
                            // x가 스코프를 벗어남. x는 초기화된 상태였음. x를 드롭!
<span class="boring">}</span></code></pre></pre>
<p>하지만 다음과 같은 코드는 올바르게 드롭하기 위해 <em>런타임</em> 정보가 필요합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let condition = true;
</span>let x;
if condition {
    x = Box::new(0);        // x는 미초기화 상태였음. 그냥 덮어씀.
    println!("{}", x);
}
                            // x가 스코프를 벗어남. x는 미초기화 상태일 수 있음.
                            // 플래그를 확인!
<span class="boring">}</span></code></pre></pre>
<p>물론, 이 경우에는 정적 드롭 의미론을 다시 확보하는 것이 매우 쉽습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let condition = true;
</span>if condition {
    let x = Box::new(0);
    println!("{}", x);
}
<span class="boring">}</span></code></pre></pre>
<p>드롭 플래그는 스택에서 추적됩니다. 이전 버전의 러스트에서는 <code>Drop</code>을 구현하는 타입의 숨겨진 필드에 드롭 플래그가 저장되었습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="확인되지-않은-초기화되지-않은-메모리"><a class="header" href="#확인되지-않은-초기화되지-않은-메모리">확인되지 않은 초기화되지 않은 메모리</a></h1>
<p>이 규칙에 대한 흥미로운 예외 중 하나는 배열로 작업할 때입니다. 안전한 러스트는 배열을 부분적으로 초기화하는 것을 허용하지 않습니다. 배열을 초기화할 때는 <code>let x = [val; N]</code>을 사용하여 모든 값을 동일하게 설정하거나, <code>let x = [val1, val2, val3]</code>과 같이 각 요소를 개별적으로 지정해야 합니다. 불행히도 이는 상당히 경직되어 있으며, 특히 배열을 더 점진적이거나 동적인 방식으로 초기화해야 할 때 더욱 그렇습니다.</p>
<p>비안전한 러스트는 이 문제를 해결하기 위해 강력한 도구인 <a href="../core/mem/union.MaybeUninit.html"><code>MaybeUninit</code></a>를 제공합니다. 이 타입은 아직 완전히 초기화되지 않은 메모리를 다루는 데 사용될 수 있습니다.</p>
<p><code>MaybeUninit</code>을 사용하면 다음과 같이 배열을 요소별로 하나씩 초기화할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem::{self, MaybeUninit};

// 배열의 크기는 하드코딩되어 있지만 변경하기 쉽습니다(즉, 상수만 변경하면 충분합니다).
// 하지만 이 방식은 [a, b, c] 구문을 사용하여 배열을 초기화할 수 없음을 의미합니다.
// 그 구문을 사용하면 `SIZE` 상수와 동기화 상태를 유지해야 하기 때문입니다!
const SIZE: usize = 10;

let x = {
    // Create an uninitialized array of `MaybeUninit`.
    let mut x = [const { MaybeUninit::uninit() }; SIZE];

    // `MaybeUninit`을 드롭하는 것은 아무 일도 하지 않습니다. 따라서 `ptr::write` 대신
    // 원시 포인터 할당을 사용해도 이전의 초기화되지 않은 값이 드롭되지 않습니다.
    // Box는 패닉을 일으키지 않으므로 예외 안전성(exception safety)은 고려 대상이 아닙니다.
    for i in 0..SIZE {
        x[i] = MaybeUninit::new(Box::new(i as u32));
    }

    // 모든 것이 초기화되었습니다. 배열을 초기화된 타입으로 트랜스뮤트합니다.
    unsafe { mem::transmute::&lt;_, [Box&lt;u32&gt;; SIZE]&gt;(x) }
};

println!("{x:?}");
<span class="boring">}</span></code></pre></pre>
<p>이 코드는 세 단계로 진행됩니다:</p>
<ol>
<li>
<p>Create an array of <code>MaybeUninit&lt;T&gt;</code>.</p>
</li>
<li>
<p>배열을 초기화합니다. 여기서 미묘한 점은 보통 러스트 타입 검사기가 이미 초기화되었다고 간주하는 값(예: <code>x[i]</code>)에 <code>=</code>을 사용하여 할당할 때, 좌변에 저장되어 있던 이전 값이 드롭된다는 것입니다. 이는 재앙이 될 것입니다. 하지만 이 경우 좌변의 타입은 <code>MaybeUninit&lt;Box&lt;u32&gt;&gt;</code>이며, 이를 드롭하는 것은 아무런 일도 하지 않습니다! 이 <code>drop</code> 이슈에 대한 자세한 논의는 아래를 참조하세요.</p>
</li>
<li>
<p>마지막으로, <code>MaybeUninit</code>을 제거하기 위해 배열의 타입을 변경해야 합니다. 현재 안정 버전 러스트에서는 이를 위해 <code>transmute</code>가 필요합니다. 이 트랜스뮤트는 적법한데, 메모리상에서 <code>MaybeUninit&lt;T&gt;</code>는 <code>T</code>와 동일하게 보이기 때문입니다.</p>
<p>하지만 일반적으로 <code>Container&lt;MaybeUninit&lt;T&gt;&gt;</code>가 <code>Container&lt;T&gt;</code>와 동일하게 보이는 것은 아닙니다! 예를 들어 <code>Container</code>가 <code>Option</code>이고 <code>T</code>가 <code>bool</code>이라면, <code>Option&lt;bool&gt;</code>은 <code>bool</code>이 단 두 개의 유효한 값만을 가진다는 점을 활용하지만, <code>Option&lt;MaybeUninit&lt;bool&gt;&gt;</code>은 <code>bool</code>이 초기화될 필요가 없으므로 그렇게 할 수 없습니다.</p>
<p>따라서 <code>MaybeUninit</code>을 트랜스뮤트로 제거하는 것이 허용되는지는 <code>Container</code>에 달려 있습니다. 배열의 경우에는 허용됩니다(결국 표준 라이브러리에서도 적절한 메서드를 제공함으로써 이를 인정하게 될 것입니다).</p>
</li>
</ol>
<p>중간에 있는 루프, 특히 할당 연산자와 <code>drop</code>의 상호 작용에 대해 좀 더 시간을 할애해 볼 가치가 있습니다. 만약 우리가 다음과 같이 쓴다면:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">*x[i].as_mut_ptr() = Box::new(i as u32); // 틀림!</code></pre>
<p>실제로 <code>Box&lt;u32&gt;</code>를 덮어쓰게 되어 초기화되지 않은 데이터에 대한 <code>drop</code>이 발생하고, 이는 커다란 슬픔과 고통을 초래할 것입니다.</p>
<p>어떤 이유로 <code>MaybeUninit::new</code>를 사용할 수 없는 경우의 올바른 대안은 <a href="../core/ptr/index.html"><code>ptr</code></a> 모듈을 사용하는 것입니다. 특히 이 모듈은 이전 값을 드롭하지 않고 메모리 위치에 바이트를 할당할 수 있게 해주는 세 가지 함수를 제공합니다: <a href="../core/ptr/fn.write.html"><code>write</code></a>, <a href="../std/ptr/fn.copy.html"><code>copy</code></a>, 그리고 <a href="../std/ptr/fn.copy_nonoverlapping.html"><code>copy_nonoverlapping</code></a>입니다.</p>
<ul>
<li><code>ptr::write(ptr, val)</code>는 <code>val</code>을 받아서 <code>ptr</code>이 가리키는 주소로 이동시킵니다.</li>
<li><code>ptr::copy(src, dest, count)</code>는 <code>count</code>개의 <code>T</code> 아이템이 차지할 비트를 <code>src</code>에서 <code>dest</code>로 복사합니다. (이는 C의 <code>memmove</code>와 동일합니다. 인자 순서가 반대임에 유의하세요!)</li>
<li><code>ptr::copy_nonoverlapping(src, dest, count)</code>는 <code>copy</code>와 동일한 작업을 수행하지만, 두 메모리 범위가 겹치지 않는다는 가정하에 조금 더 빠릅니다. (이는 C의 <code>memcpy</code>와 동일합니다. 인자 순서가 반대임에 유의하세요!)</li>
</ul>
<p>말할 필요도 없이, 이 함수들을 잘못 사용하면 심각한 혼란이나 문자 그대로의 정의되지 않은 동작을 야기할 것입니다. 이 함수들 _자체_의 유일한 요구 사항은 읽고 쓰려는 위치가 할당되어 있고 적절하게 정렬되어 있어야 한다는 것뿐입니다. 하지만 임의의 비트를 임의의 메모리 위치에 쓰는 행위가 시스템을 망가뜨릴 수 있는 방법은 기본적으로 셀 수 없이 많습니다!</p>
<p><code>Drop</code>을 구현하지 않거나 <code>Drop</code> 타입을 포함하지 않는 타입들에 대해서는 <code>ptr::write</code> 방식의 복잡한 처리를 걱정할 필요가 없다는 점에 주목할 가치가 있습니다. 러스트가 그것들을 드롭하려고 시도하지 않는다는 것을 알기 때문입니다. 이것이 우리가 위 예제에서 의존했던 점입니다.</p>
<p>하지만 초기화되지 않은 메모리를 다룰 때는, 여러분이 만든 이러한 값들이 완전히 초기화되기 전에 러스트가 그것들을 드롭하려고 시도하지 않는지 항상 경계해야 합니다. 변수의 스코프를 통과하는 모든 제어 경로는 변수가 끝나기 전에(소멸자가 있는 경우) 값을 초기화해야 합니다. <em><a href="unwinding.html">여기에는 패닉이 발생하는 코드도 포함됩니다</a></em>. <code>MaybeUninit</code>은 여기서 약간의 도움이 되는데, 내용물을 암시적으로 드롭하지 않기 때문입니다. 하지만 패닉이 발생할 경우 이것이 의미하는 바는, 아직 초기화되지 않은 부분에 대한 이중 해제(double-free) 대신, 이미 초기화된 부분에 대한 메모리 누수가 발생한다는 것뿐입니다.</p>
<p>참고로, <code>ptr</code> 메서드를 사용하려면 먼저 초기화하려는 데이터에 대한 _원시 포인터_를 얻어야 합니다. 초기화되지 않은 데이터에 대한 _참조_를 생성하는 것은 불법이며, 이는 해당 원시 포인터를 얻을 때 매우 주의해야 함을 의미합니다:</p>
<ul>
<li><code>T</code> 타입의 배열에 대해서는, <code>base_ptr: *mut T</code>일 때 <code>base_ptr.add(idx)</code>를 사용하여 배열 인덱스 <code>idx</code>의 주소를 계산할 수 있습니다. 이는 메모리상에서 배열이 어떻게 배치되는지에 의존합니다.</li>
<li>하지만 구조체의 경우, 일반적으로 그것이 어떻게 배치되어 있는지 알 수 없으며, <code>&amp;mut base_ptr.field</code>를 사용할 수도 없습니다. 그렇게 하는 것은 참조를 생성하는 것이기 때문입니다. 따라서 <a href="../reference/types/pointer.html#r-type.pointer.raw.constructor">원시 참조(raw reference)</a> 구문을 주의해서 사용해야 합니다. 이 구문은 중간 참조를 생성하지 않고 필드에 대한 원시 포인터를 생성합니다:</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::{ptr, mem::MaybeUninit};

struct Demo {
    field: bool,
}

let mut uninit = MaybeUninit::&lt;Demo&gt;::uninit();
// `&amp;uninit.as_mut().field`는 초기화되지 않은 `bool`에 대한 참조를 생성하게 되며,
// 따라서 정의되지 않은 동작이 됩니다!
let f1_ptr = unsafe { &amp;raw mut (*uninit.as_mut_ptr()).field };
unsafe { f1_ptr.write(true); }

let init = unsafe { uninit.assume_init() };
<span class="boring">}</span></code></pre></pre>
<p>마지막으로 한 마디 더 하자면, 오래된 러스트 코드를 읽다 보면 이제는 권장되지 않는(deprecated) <code>mem::uninitialized</code> 함수를 마주칠 수 있습니다. 이 함수는 예전에 스택상의 초기화되지 않은 메모리를 다루는 유일한 방법이었지만, 언어의 나머지 부분들과 적절히 통합되는 것이 불가능하다는 것이 밝혀졌습니다. 새로운 코드에서는 항상 대신 <code>MaybeUninit</code>을 사용하고, 기회가 될 때 오래된 코드를 포팅하세요.</p>
<p>초기화되지 않은 메모리를 다루는 법은 이 정도면 충분합니다! 기본적으로 어디에서도 초기화되지 않은 메모리를 전달받을 것이라고 예상하지 않으므로, 이를 어딘가로 전달해야 한다면 정말로, <em>진짜로</em> 주의를 기울이시기 바랍니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="소유권-기반-자원-관리obrm의-위험성"><a class="header" href="#소유권-기반-자원-관리obrm의-위험성">소유권 기반 자원 관리(OBRM)의 위험성</a></h1>
<p>소유권 기반 자원 관리(OBRM, 일명 RAII: 자원 획득은 초기화임)는 러스트에서 아주 많이 접하게 될 개념입니다. 특히 표준 라이브러리를 사용한다면 더욱 그렇습니다.</p>
<p>대략적으로 이 패턴은 다음과 같습니다. 자원을 획득하기 위해, 그 자원을 관리하는 객체를 생성합니다. 자원을 해제하려면 단순히 그 객체를 파괴하면 되며, 그러면 객체가 여러분을 대신해 자원을 정리합니다. 이 패턴이 관리하는 가장 흔한 "자원"은 바로 _메모리_입니다. <code>Box</code>, <code>Rc</code>, 그리고 기본적으로 <code>std::collections</code>에 있는 모든 것은 메모리를 올바르게 관리할 수 있게 해주는 편의 도구들입니다. 이는 러스트에서 특히 중요한데, 메모리 관리를 위해 의존할 수 있는 보편적인 가비지 컬렉터(GC)가 없기 때문입니다. 사실 이것이 바로 핵심입니다. 러스트는 제어(control)에 관한 언어입니다. 하지만 우리는 메모리에만 국한되지 않습니다. 스레드, 파일, 소켓과 같은 거의 모든 다른 시스템 자원들도 이러한 종류의 API를 통해 노출됩니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="생성자"><a class="header" href="#생성자">생성자</a></h1>
<p>사용자 정의 타입의 인스턴스를 생성하는 방법은 정확히 하나뿐입니다. 이름을 부르고, 모든 필드를 한 번에 초기화하는 것입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    a: u8,
    b: u32,
    c: bool,
}

enum Bar {
    X(u32),
    Y(bool),
}

struct Unit;

let foo = Foo { a: 0, b: 1, c: false };
let bar = Bar::X(0);
let empty = Unit;
<span class="boring">}</span></code></pre></pre>
<p>그게 전부입니다. 타입을 생성하는 다른 모든 방법은 단지 무언가 작업을 수행하고 결국에는 "유일한 진실된 생성자(The One True Constructor)"로 귀결되는 아주 평범한 함수를 호출하는 것뿐입니다.</p>
<p>C++와 달리, 러스트는 수많은 내장 생성자들을 제공하지 않습니다. 복사(Copy), 기본(Default), 할당(Assignment), 이동(Move) 등 그 어떤 생성자도 없습니다. 그 이유는 다양하지만, 대체로 _명시적이어야 한다_는 러스트의 철학으로 귀결됩니다.</p>
<p>러스트에서 이동 생성자는 의미가 없습니다. 왜냐하면 타입이 자신의 메모리상 위치에 "신경 쓰도록" 허용하지 않기 때문입니다. 모든 타입은 메모리의 다른 곳으로 아무렇게나 복사(memcopy)될 준비가 되어 있어야 합니다. 이는 스택에 존재하면서도 이동 가능한 순수 침입형 연결 리스트(intrusive linked lists)와 같은 것들이 러스트에서는 (안전하게) 불가능함을 의미합니다.</p>
<p>할당 생성자와 복사 생성자 역시 존재하지 않습니다. 이동 의미론(move semantics)이 러스트의 유일한 의미론이기 때문입니다. 기껏해야 <code>x = y</code>는 y의 비트를 x 변수로 옮길 뿐입니다. 러스트는 C++의 복사 중심 의미론을 제공하기 위해 <code>Copy</code>와 <code>Clone</code>이라는 두 가지 기능을 제공합니다. <code>Clone</code>은 복사 생성자에 해당하는 개념이지만, 결코 암시적으로 호출되지 않습니다. 복제하고 싶은 요소에 대해 명시적으로 <code>clone</code>을 호출해야 합니다. <code>Copy</code>는 <code>Clone</code>의 특별한 사례로, 그 구현은 단순히 "비트를 복사하는 것"입니다. <code>Copy</code> 타입들은 이동될 때마다 암시적으로 복제되지만, <code>Copy</code>의 정의에 따라 이는 이전 복사본을 미초기화 상태로 취급하지 않는 것일 뿐이며, 사실상 아무런 작업도 수행하지 않는 것(no-op)과 같습니다.</p>
<p>러스트는 기본 생성자에 해당하는 <code>Default</code> 트레잇을 제공하지만, 이 트레잇이 직접적으로 사용되는 경우는 드뭅니다. 변수가 <a href="uninitialized.html">암시적으로 초기화되지 않기 때문입니다</a>. <code>Default</code>는 기본적으로 제네릭 프로그래밍에서만 유용합니다. 구체적인 문맥에서는, 타입이 일종의 "기본" 생성자 역할을 하는 정적 <code>new</code> 메서드를 제공할 것입니다. 이는 다른 언어의 <code>new</code>와는 아무런 관련이 없으며 특별한 의미도 없습니다. 단지 명명 규칙일 뿐입니다.</p>
<p>TODO: "placement new"에 대해 이야기하기?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="소멸자"><a class="header" href="#소멸자">소멸자</a></h1>
<p>언어가 제공하는 것은 <code>Drop</code> 트레잇을 통한 완전한 자동 소멸자입니다. 이 트레잇은 다음과 같은 메서드를 제공합니다:</p>
<!-- ignore: function header -->
<pre><code class="language-rust ignore">fn drop(&amp;mut self);</code></pre>
<p>이 메서드는 해당 타입이 하던 일을 어떻게든 마무리할 수 있는 시간을 줍니다.</p>
<p><strong><code>drop</code>이 실행된 후, 러스트는 재귀적으로 <code>self</code>의 모든 필드들을 드롭하려고 시도할 것입니다.</strong></p>
<p>이는 자식 요소들을 드롭하기 위해 "소멸자 상용구(boilerplate)"를 작성하지 않아도 되게 해주는 편의 기능입니다. 만약 구조체가 자식 요소들을 드롭하는 것 외에 특별한 드롭 로직이 없다면, <code>Drop</code>을 구현할 필요가 전혀 없음을 의미합니다!</p>
<p><strong>러스트 1.0에서는 이러한 동작을 방지할 수 있는 안정적인 방법이 없습니다.</strong></p>
<p><code>&amp;mut self</code>를 받는다는 것은, 설령 재귀적 드롭을 억제할 수 있다 하더라도 러스트가 예를 들어 <code>self</code>에서 필드를 밖으로 이동시키는 행위 등을 방지할 것임을 의미합니다. 대부분의 타입에 대해서는 이것으로 충분히 괜찮습니다.</p>
<p>예를 들어, <code>Box</code>의 커스텀 구현은 다음과 같이 <code>Drop</code>을 작성할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024">#![feature(ptr_internals, allocator_api)]

use std::alloc::{Allocator, Global, GlobalAlloc, Layout};
use std::mem;
use std::ptr::{drop_in_place, NonNull, Unique};

struct Box&lt;T&gt;{ ptr: Unique&lt;T&gt; }

impl&lt;T&gt; Drop for Box&lt;T&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            drop_in_place(self.ptr.as_ptr());
            let c: NonNull&lt;T&gt; = self.ptr.into();
            Global.deallocate(c.cast(), Layout::new::&lt;T&gt;())
        }
    }
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>그리고 이는 잘 작동합니다. 러스트가 <code>ptr</code> 필드를 드롭하러 갈 때, 실제 <code>Drop</code> 구현이 없는 <a href="phantom-data.html">Unique</a>만을 보게 되기 때문입니다. 마찬가지로 <code>drop</code>이 종료되면 <code>ptr</code>에 접근할 수 없게 되므로, 아무도 그것을 해제 후 사용(use-after-free)할 수 없습니다.</p>
<p>하지만 다음과 같은 코드는 작동하지 않을 것입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024">#![feature(allocator_api, ptr_internals)]

use std::alloc::{Allocator, Global, GlobalAlloc, Layout};
use std::ptr::{drop_in_place, Unique, NonNull};
use std::mem;

struct Box&lt;T&gt;{ ptr: Unique&lt;T&gt; }

impl&lt;T&gt; Drop for Box&lt;T&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            drop_in_place(self.ptr.as_ptr());
            let c: NonNull&lt;T&gt; = self.ptr.into();
            Global.deallocate(c.cast(), Layout::new::&lt;T&gt;());
        }
    }
}

struct SuperBox&lt;T&gt; { my_box: Box&lt;T&gt; }

impl&lt;T&gt; Drop for SuperBox&lt;T&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            // 고도로 최적화됨: Box의 내용물을 드롭하지 않고
            // 대신 메모리 해제만 수행합니다
            let c: NonNull&lt;T&gt; = self.my_box.ptr.into();
            Global.deallocate(c.cast::&lt;u8&gt;(), Layout::new::&lt;T&gt;());
        }
    }
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p><code>SuperBox</code>의 소멸자에서 <code>box</code>의 포인터를 해제한 후에도, 러스트는 기꺼이 <code>box</code>에게 스스로를 <code>Drop</code>하라고 지시할 것입니다. 그러면 모든 것이 해제 후 사용(use-after-frees) 및 이중 해제(double-frees)로 인해 폭발할 것입니다.</p>
<p>재귀적 드롭 동작은 <code>Drop</code> 구현 여부와 관계없이 모든 구조체와 열거형에 적용된다는 점에 유의하세요. 따라서 다음과 같은 경우</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Boxy&lt;T&gt; {
    data1: Box&lt;T&gt;,
    data2: Box&lt;T&gt;,
    info: u32,
}
<span class="boring">}</span></code></pre></pre>
<p>자체적으로 <code>Drop</code>을 구현하지 않았더라도, 그것이 드롭될 "상황"이 되면 <code>data1</code>과 <code>data2</code> 필드의 소멸자가 호출될 것입니다. 우리는 이러한 타입을 스스로가 <code>Drop</code>은 아닐지라도 <em>드롭이 필요한(needs Drop)</em> 타입이라고 부릅니다.</p>
<p>마찬가지로,</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Link {
    Next(Box&lt;Link&gt;),
    None,
}
<span class="boring">}</span></code></pre></pre>
<p>인스턴스가 <code>Next</code> 변형(variant)을 저장하고 있을 때만 내부의 <code>Box</code> 필드가 드롭될 것입니다.</p>
<p>일반적으로 이는 데이터 레이아웃을 리팩토링할 때 드롭을 추가하거나 제거하는 것에 대해 걱정할 필요가 없게 해주므로 매우 훌륭하게 작동합니다. 하지만 소멸자를 사용해 더 까다로운 작업을 수행해야 하는 유효한 사용 사례들도 분명히 존재합니다.</p>
<p>재귀적 드롭을 재정의하고 <code>drop</code> 중에 <code>Self</code>로부터 필드를 밖으로 이동시키는 것을 허용하는 전형적인 안전한 해결책은 <code>Option</code>을 사용하는 것입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024">#![feature(allocator_api, ptr_internals)]

use std::alloc::{Allocator, GlobalAlloc, Global, Layout};
use std::ptr::{drop_in_place, Unique, NonNull};
use std::mem;

struct Box&lt;T&gt;{ ptr: Unique&lt;T&gt; }

impl&lt;T&gt; Drop for Box&lt;T&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            drop_in_place(self.ptr.as_ptr());
            let c: NonNull&lt;T&gt; = self.ptr.into();
            Global.deallocate(c.cast(), Layout::new::&lt;T&gt;());
        }
    }
}

struct SuperBox&lt;T&gt; { my_box: Option&lt;Box&lt;T&gt;&gt; }

impl&lt;T&gt; Drop for SuperBox&lt;T&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            // 고도로 최적화됨: Box의 내용물을 드롭하지 않고
            // 대신 메모리 해제만 수행합니다. 러스트가 이를 드롭하려고 시도하지 않도록
            // `box` 필드를 `None`으로 설정해야 합니다.
            let my_box = self.my_box.take().unwrap();
            let c: NonNull&lt;T&gt; = my_box.ptr.into();
            Global.deallocate(c.cast(), Layout::new::&lt;T&gt;());
            mem::forget(my_box);
        }
    }
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>하지만 이는 상당히 기묘한 의미론을 갖습니다. 항상 <code>Some</code>이어야 하는 필드가 단지 소멸자에서 발생하는 일 때문에 <code>None</code>이 될 수도 있다고 말하는 꼴이기 때문입니다. 물론 반대로 생각하면 이는 일리가 있습니다. 소멸자 중에 <code>self</code>에 대해 임의의 메서드를 호출할 수 있는데, 필드를 미초기화한 후에는 그렇게 하지 못하도록 막아야 하기 때문입니다. 물론 그것이 소멸자 내부에서 다른 임의의 유효하지 않은 상태를 만드는 것까지 막아주는 것은 아닙니다.</p>
<p>전체적으로 봤을 때 이는 괜찮은 선택입니다. 분명히 기본적으로 선택해야 할 방법입니다. 하지만 미래에는 필드가 자동으로 드롭되지 않아야 함을 알리는 더 세련된(first-class) 방법이 도입될 것으로 기대합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="누수"><a class="header" href="#누수">누수</a></h1>
<p>소유권 기반 자원 관리는 구성을 단순화하기 위해 고안되었습니다. 객체를 생성할 때 자원을 획득하고, 객체가 파괴될 때 자원을 해제합니다. 파괴 처리가 자동으로 이루어지므로 자원 해제를 잊어버릴 염려가 없으며, 최대한 빨리 자원이 해제됩니다! 분명히 이는 완벽하며 우리의 모든 문제가 해결된 것 같습니다.</p>
<p>하지만 모든 것은 끔찍하며, 우리는 해결해야 할 새롭고 기이한 문제들을 마주하게 되었습니다.</p>
<p>많은 사람들이 러스트가 자원 누수를 완전히 제거한다고 믿고 싶어 합니다. 실질적으로 이는 대체로 사실입니다. 안전한 러스트 프로그램이 통제되지 않은 방식으로 자원을 누수하는 것을 본다면 놀라실 것입니다.</p>
<p>하지만 이론적인 관점에서 보면, 어떻게 보더라도 결코 그렇지 않습니다. 엄밀한 의미에서 "누수(leaking)"는 너무나 추상적인 개념이어서 방지하는 것이 불가능합니다. 프로그램 시작 시점에 컬렉션을 초기화하고 소멸자가 있는 수많은 객체들로 채운 뒤, 그 컬렉션을 한 번도 참조하지 않는 무한 이벤트 루프에 진입하는 것은 매우 쉽습니다. 그러면 그 컬렉션은 프로그램이 종료될 때까지(그 시점에는 어차피 OS가 모든 자원을 회수하겠지만) 소중한 자원들을 붙잡고 무의미하게 자리만 차지하고 있을 것입니다.</p>
<p>더 제한적인 형태의 누수를 고려해 봅시다. 즉, 도달 불가능한 값의 드롭을 수행하지 못하는 경우입니다. 러스트는 이 또한 방지하지 않습니다. 사실 러스트에는 _이를 수행하기 위한 함수_가 있습니다: 바로 <code>mem::forget</code>입니다. 이 함수는 전달받은 값을 소비하고는 <em>그 소멸자를 실행하지 않습니다</em>.</p>
<p>과거에 <code>mem::forget</code>은 소멸자 호출을 빠뜨리는 것이 대체로 바람직하지 않은 행동이기에 (특수한 unsafe 코드에는 유용함에도 불구하고) 일종의 경고 의미로 <code>unsafe</code>로 표시되었습니다. 하지만 이는 지지받기 어려운 입장이라는 판단이 내려졌습니다. 안전한 코드에서도 소멸자 호출을 수행하지 못하게 만드는 방법은 매우 많기 때문입니다. 가장 유명한 예시는 내부 가변성(interior mutability)을 사용하여 참조 횟수 계산(reference-counted) 포인터의 순환 참조를 만드는 것입니다.</p>
<p>안전한 코드에서 소멸자 누수가 발생하지 않는다고 가정하는 것은 합리적입니다. 소멸자를 누수하는 프로그램은 대개 잘못된 것이기 때문입니다. 하지만 <em>비안전한(unsafe)</em> 코드는 안전성을 보장하기 위해 소멸자가 반드시 실행될 것이라고 믿어서는 안 됩니다. 대부분의 타입에 대해 이는 큰 문제가 아닙니다. 소멸자가 누수된다면 해당 타입은 정의상 접근이 불가능하므로 상관없지 않겠습니까? 예를 들어, <code>Box&lt;u8&gt;</code>을 누수한다면 메모리를 낭비하게 되겠지만 그것이 메모리 안전성을 위반하지는 않습니다.</p>
<p>하지만 소멸자 누수와 관련하여 주의해야 할 대상은 <em>프록시(proxy)</em> 타입들입니다. 이것들은 별개의 객체에 대한 접근을 관리하지만, 실제로 그 객체를 소유하지는 않는 타입들입니다. 프록시 객체는 꽤 드물며, 여러분이 신경 써야 할 프록시 객체는 더욱 드뭅니다. 하지만 여기서는 표준 라이브러리에 있는 세 가지 흥미로운 예시에 집중해 보겠습니다:</p>
<ul>
<li><code>vec::Drain</code></li>
<li><code>Rc</code></li>
<li><code>thread::scoped::JoinGuard</code></li>
</ul>
<h2 id="드레인"><a class="header" href="#드레인">드레인</a></h2>
<p><code>drain</code>은 컨테이너를 소비하지 않고 컨테이너 내부의 데이터를 밖으로 이동시키는 컬렉션 API입니다. 이를 통해 우리는 <code>Vec</code>의 모든 내용물에 대한 소유권을 가져온 뒤 해당 <code>Vec</code>의 할당된 메모리를 재사용할 수 있습니다. <code>drain</code>은 <code>Vec</code>의 내용물을 값으로 반환하는 반복자(<code>Drain</code>)를 생성합니다.</p>
<p>이제 반복 중간의 <code>Drain</code>을 고려해 봅시다. 일부 값은 밖으로 이동되었고, 다른 값들은 아직 남아 있습니다. 이는 <code>Vec</code>의 일부가 이제 논리적으로 초기화되지 않은 데이터로 가득 차 있음을 의미합니다! 값을 제거할 때마다 <code>Vec</code>의 모든 요소들을 앞으로 당길 수도 있겠지만, 이는 심각한 성능 저하를 초래할 것입니다.</p>
<p>대신, 우리는 <code>Drain</code>이 드롭될 때 <code>Vec</code>의 저장 공간을 복구해주기를 원합니다. 드롭될 때 남은 반복을 끝까지 수행하고, 제거되지 않은 요소들을 앞으로 당기고(drain은 하위 범위를 지원하므로), <code>Vec</code>의 <code>len</code>을 수정해야 합니다. 이는 심지어 언와인딩(unwinding)에도 안전합니다! 참 쉽죠!</p>
<p>이제 다음 상황을 고려해 봅시다:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">let mut vec = vec![Box::new(0); 4];

{
    // 드레인을 시작합니다. 이제 vec에 직접 접근할 수 없습니다.
    let mut drainer = vec.drain(..);

    // 두 개의 요소를 꺼내고 즉시 드롭합니다.
    drainer.next();
    drainer.next();

    // 드레이너를 제거하지만, 소멸자를 호출하지는 않습니다.
    mem::forget(drainer);
}

// 맙소사, `vec[0]`이 드롭되었습니다. 우리는 이미 해제된 메모리를 가리키는 포인터를 읽고 있습니다!
println!("{}", vec[0]);</code></pre>
<p>이것은 분명히 좋지 않은 상황입니다. 불행히도 우리는 진퇴양난에 빠져 있습니다. 모든 단계에서 일관된 상태를 유지하는 것은 엄청난 비용이 들며(이 API의 모든 이점을 상쇄할 것입니다), 일관된 상태를 유지하지 못하면 안전한 코드에서 정의되지 않은 동작이 발생하게 됩니다(API가 불건전해집니다).</p>
<p>그렇다면 우리는 무엇을 할 수 있을까요? 음, 우리는 아주 단순하고 일관된 상태를 선택할 수 있습니다. 반복을 시작할 때 <code>Vec</code>의 길이를 0으로 설정하고, 소멸자에서 필요한 경우 이를 복구하는 것입니다. 그렇게 하면 모든 것이 정상적으로 실행될 때 최소한의 오버헤드로 원하는 동작을 얻을 수 있습니다. 하지만 누군가가 <em>뻔뻔하게도</em> 반복 중간에 <code>mem::forget</code>을 호출한다면, 그로 인해 발생하는 일은 단지 _더 많은 누수_가 발생하는 것뿐입니다(그리고 <code>Vec</code>을 예상치 못했지만 어쨌든 일관된 상태로 남겨둘 것입니다). 우리는 <code>mem::forget</code>이 안전하다는 것을 받아들였으므로, 이는 분명히 안전합니다. 우리는 누수가 더 많은 누수를 일으키는 것을 _누수 증폭(leak amplification)_이라고 부릅니다.</p>
<h2 id="rc"><a class="header" href="#rc">Rc</a></h2>
<p><code>Rc</code>는 언뜻 보기에 프록시 값이 전혀 아닌 것처럼 보이기 때문에 흥미로운 사례입니다. 결국 <code>Rc</code>는 자신이 가리키는 데이터를 관리하며, 어떤 값에 대한 모든 <code>Rc</code>들을 드롭하면 해당 값도 드롭되기 때문입니다. <code>Rc</code>를 누수시키는 것은 특별히 위험해 보이지 않습니다. 참조 횟수를 영구적으로 증가된 상태로 남겨두어 데이터가 해제되거나 드롭되는 것을 방지하겠지만, 이는 <code>Box</code>와 마찬가지인 것 같습니다, 그렇죠?</p>
<p>아니요.</p>
<p>간략화된 <code>Rc</code> 구현을 고려해 봅시다:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">struct Rc&lt;T&gt; {
    ptr: *mut RcBox&lt;T&gt;,
}

struct RcBox&lt;T&gt; {
    data: T,
    ref_count: usize,
}

impl&lt;T&gt; Rc&lt;T&gt; {
    fn new(data: T) -&gt; Self {
        unsafe {
            // heap::allocate가 이런 식으로 작동하면 좋지 않을까요?
            let ptr = heap::allocate::&lt;RcBox&lt;T&gt;&gt;();
            ptr::write(ptr, RcBox {
                data,
                ref_count: 1,
            });
            Rc { ptr }
        }
    }

    fn clone(&amp;self) -&gt; Self {
        unsafe {
            (*self.ptr).ref_count += 1;
        }
        Rc { ptr: self.ptr }
    }
}

impl&lt;T&gt; Drop for Rc&lt;T&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            (*self.ptr).ref_count -= 1;
            if (*self.ptr).ref_count == 0 {
                // 데이터를 드롭하고 메모리를 해제합니다
                ptr::read(self.ptr);
                heap::deallocate(self.ptr);
            }
        }
    }
}</code></pre>
<p>이 코드에는 암시적이고 미묘한 가정이 포함되어 있습니다. 메모리에 <code>usize::MAX</code> 개 이상의 <code>Rc</code>가 있을 수 없으므로 <code>ref_count</code>가 <code>usize</code>에 딱 맞을 것이라는 가정입니다. 하지만 이는 <code>ref_count</code>가 메모리에 있는 <code>Rc</code>의 개수를 정확히 반영한다는 것을 전제로 하는데, 우리는 <code>mem::forget</code>으로 인해 이것이 거짓이 될 수 있음을 압니다. <code>mem::forget</code>을 사용하면 <code>ref_count</code>를 오버플로시킬 수 있고, 여전히 <code>Rc</code>가 남아있음에도 불구하고 0까지 떨어뜨릴 수 있습니다. 그러면 기분 좋게(?) 내부 데이터를 해제 후 사용(use-after-free)하게 됩니다. 정말 정말 좋지 않은 일이죠.</p>
<p>이는 <code>ref_count</code>를 확인하고 어떤 조치를 취함으로써 해결할 수 있습니다. 표준 라이브러리의 입장은 그냥 중단(abort)하는 것인데, 프로그램이 지독하게 타락해버렸기 때문입니다. 또한, <em>세상에나</em> 이건 정말 말도 안 되는 특수한 사례입니다.</p>
<h2 id="threadscopedjoinguard"><a class="header" href="#threadscopedjoinguard">thread::scoped::JoinGuard</a></h2>
<blockquote>
<p>참고: 이 API는 이미 표준 라이브러리에서 제거되었습니다. 더 자세한 내용은 <a href="https://github.com/rust-lang/rust/issues/24292">이슈 #24292</a>를 참조하세요.</p>
<p>이 섹션이 여기에 남아있는 이유는, 표준 라이브러리의 일부인지 여부와 관계없이 이 예제가 여전히 중요하다고 생각하기 때문입니다.</p>
</blockquote>
<p><code>thread::scoped</code> API는 부모 스레드의 스택에 있는 데이터를 참조하는 자식 스레드를 별도의 동기화 없이 생성할 수 있도록 고안되었습니다. 이는 공유된 데이터가 스코프를 벗어나기 전에 부모 스레드가 반드시 자식 스레드를 조인(join)하도록 보장함으로써 가능했습니다.</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">pub fn scoped&lt;'a, F&gt;(f: F) -&gt; JoinGuard&lt;'a&gt;
    where F: FnOnce() + Send + 'a</code></pre>
<p>여기서 <code>f</code>는 다른 스레드에서 실행될 클로저입니다. <code>F: Send + 'a</code>라는 것은 이 클로저가 <code>'a</code> 동안 살아있는 데이터를 캡처하며, 그 데이터를 소유하거나 캡처된 데이터가 <code>Sync</code>임을(즉, <code>&amp;data</code>가 <code>Send</code>임을) 의미합니다.</p>
<p><code>JoinGuard</code>는 수명을 가지고 있기 때문에, 캡처한 모든 데이터를 부모 스레드에서 대여 중인 상태로 유지합니다. 이는 <code>JoinGuard</code>가 다른 스레드가 작업 중인 데이터보다 오래 살 수 없음을 의미합니다. <code>JoinGuard</code>가 실제로 드롭될 때, 부모 스레드를 차단(block)하여 캡처된 데이터가 부모 스레드에서 스코프를 벗어나기 전에 자식 스레드가 반드시 종료되도록 보장합니다.</p>
<p>사용법은 다음과 같았습니다:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">let mut data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
{
    let mut guards = vec![];
    for x in &amp;mut data {
        // 가변 참조를 클로저로 이동시키고, 다른 스레드에서 실행합니다.
        // 클로저는 내부에 저장된 가변 참조 `x`에 의해 수명이 제한됩니다.
        // 반환되는 가드(guard)는 클로저의 수명을 할당받으므로,
        // `x`가 그랬던 것처럼 `data`를 가변으로 대여합니다.
        // 이는 가드가 사라지기 전까지는 `data`에 접근할 수 없음을 의미합니다.
        let guard = thread::scoped(move || {
            *x *= 2;
        });
        // 나중에 사용하기 위해 스레드 가드를 저장합니다
        guards.push(guard);
    }
    // 모든 가드들이 여기서 드롭되어 스레드들이 조인되도록 강제합니다
    // (이 스레드는 다른 스레드들이 종료될 때까지 여기서 차단됩니다).
    // 스레드들이 조인되면 대여가 만료되고 데이터에 다시 접근할 수 있게 됩니다.
}
// 여기서 데이터는 확실하게 변경된 상태입니다.</code></pre>
<p>원칙적으로 이는 완벽하게 작동합니다! 러스트의 소유권 시스템이 이를 완벽하게 보장합니다! 하지만... 안전을 위해 소멸자가 반드시 호출되어야 한다는 점에 의존하고 있습니다.</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">let mut data = Box::new(0);
{
    let guard = thread::scoped(|| {
        // 이것은 기껏해야 데이터 경쟁이고, 최악의 경우 해제 후 사용(use-after-free)이기도 합니다.
        *data += 1;
    });
    // 가드가 잊혀졌기 때문에(forgotten), 이 스레드를 차단하지 않고 대여를 만료시킵니다.
    mem::forget(guard);
}
// 따라서 스코프 스레드가 박스에 접근하려고 시도할지도 모르는 상황에서 여기서 박스가 드롭됩니다.</code></pre>
<p>이런. 여기서는 소멸자의 실행이 API의 근간이었는데, 결국 이 방식은 폐기되고 완전히 다른 설계로 대체되어야 했습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="언와인딩"><a class="header" href="#언와인딩">언와인딩</a></h1>
<p>러스트는 <em>계층화된</em> 에러 처리 체계를 가지고 있습니다:</p>
<ul>
<li>어떤 것이 합리적으로 부재할 가능성이 있다면, <code>Option</code>을 사용합니다.</li>
<li>무언가 잘못되었지만 합리적으로 처리 가능하다면, <code>Result</code>를 사용합니다.</li>
<li>무언가 잘못되었는데 합리적으로 처리할 수 없다면, 스레드는 패닉(panic)을 일으킵니다.</li>
<li>치명적인 일이 발생하면, 프로그램은 중단(abort)됩니다.</li>
</ul>
<p>대부분의 상황에서는 <code>Option</code>과 <code>Result</code>가 압도적으로 선호됩니다. 특히 이들은 API 사용자의 재량에 따라 패닉이나 중단으로 승격될 수 있기 때문입니다. 패닉은 스레드의 정상적인 실행을 멈추고 스택을 언와인드(unwind)하며, 마치 모든 함수가 즉시 반환된 것처럼 소멸자들을 호출합니다.</p>
<p>1.0 버전 기준으로, 패닉에 대해 러스트는 두 가지 생각을 가지고 있습니다. 아주 먼 옛날, 러스트는 얼랑(Erlang)과 훨씬 더 비슷했습니다. 얼랑처럼 러스트도 경량 태스크(lightweight tasks)를 가졌고, 태스크가 감당할 수 없는 상태에 도달하면 패닉과 함께 스스로 죽도록 고안되었습니다. 자바나 C++의 예외와는 달리, 패닉은 아무 때나 잡힐 수 없었습니다. 패닉은 태스크의 소유자만이 잡을 수 있었고, 그 시점에서 처리되지 않으면 <em>그</em> 태스크 자체가 패닉을 일으켰습니다.</p>
<p>언와인딩은 이 이야기에서 매우 중요했습니다. 태스크의 소멸자가 호출되지 않으면 메모리와 기타 시스템 자원이 누수될 것이기 때문입니다. 태스크가 정상적인 실행 도중에 죽을 수도 있는 환경에서, 이는 러스트를 장시간 실행되는 시스템에 부적합하게 만들었을 것입니다!</p>
<p>오늘날 우리가 아는 러스트가 만들어지면서, 추상화를 줄이려는 움직임 속에 이런 스타일의 프로그래밍은 점차 유행에서 멀어지게 되었습니다. 경량 태스크들은 중량급 OS 스레드들에게 자리를 내주고 사라졌습니다. 여전히 1.0 안정 버전 러스트에서 패닉은 부모 스레드에 의해서만 잡힐 수 있습니다. 이는 패닉을 잡기 위해 OS 스레드를 통째로 하나 띄워야 함을 의미합니다! 이는 안타깝게도 제로 비용 추상화라는 러스트의 철학과 충돌합니다.</p>
<p>스레드를 생성하지 않고도 패닉을 잡을 수 있게 해주는 <a href="https://doc.rust-lang.org/std/panic/fn.catch_unwind.html"><code>catch_unwind</code></a>라는 API가 있습니다. 하지만 우리는 여전히 이를 자제해서 사용하기를 권장합니다. 특히 러스트의 현재 언와인딩 구현은 "언와인드되지 않는" 경우에 매우 최적화되어 있습니다. 프로그램이 언와인드되지 않는다면, 언와인드될 _준비_가 되어 있다는 것만으로 인한 런타임 비용은 없어야 합니다. 그 결과, 실제로 언와인딩이 일어날 때는 자바(Java)와 같은 언어보다 더 많은 비용이 듭니다. 정상적인 상황에서 언와인드가 발생하도록 프로그램을 설계하지 마세요. 이상적으로는 프로그래밍 에러나 <em>극단적인</em> 문제가 발생했을 때만 패닉을 일으켜야 합니다.</p>
<p>러스트의 언와인딩 전략은 다른 언어의 언와인딩과 근본적으로 호환되도록 명시되어 있지 않습니다. 따라서 다른 언어에서 러스트로, 혹은 러스트에서 다른 언어로 언와인드하는 것은 정의되지 않은 동작입니다. FFI 경계에서는 <em>반드시</em> 모든 패닉을 잡아야 합니다! 그 시점에서 무엇을 할지는 여러분에게 달려 있지만, <em>어떤 조치든</em> 취해야 합니다. 이를 소홀히 한다면 기껏해야 애플리케이션이 완전히 망가져서 중단되겠지만, 최악의 경우 애플리케이션이 중단되지 <em>않고</em> 완전히 엉망이 된 상태로 계속 실행될 것입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="예외-안전성"><a class="header" href="#예외-안전성">예외 안전성</a></h1>
<p>프로그램이 언와인딩을 가급적 자제해야 하긴 하지만, 패닉이 <em>발생할 수 있는</em> 코드는 매우 많습니다. <code>None</code>을 언랩하거나, 범위를 벗어난 인덱스에 접근하거나, 0으로 나누면 프로그램은 패닉을 일으킵니다. 디버그 빌드에서는 모든 산술 연산이 오버플로 시 패닉을 일으킬 수 있습니다. 매우 주의를 기울여 실행되는 코드를 엄격하게 통제하지 않는 한, 거의 모든 것이 언와인드될 수 있으며 이에 대비해야 합니다.</p>
<p>언와인딩에 대비하는 것을 프로그래밍 일반에서는 흔히 _예외 안전성(exception safety)_이라고 부릅니다. 러스트에서는 고려해야 할 두 가지 수준의 예외 안전성이 있습니다:</p>
<ul>
<li>
<p>비안전한(unsafe) 코드에서, 우리는 메모리 안전성을 위반하지 않을 정도의 예외 안전성을 <em>반드시</em> 확보해야 합니다. 이를 <em>최소한의(minimal)</em> 예외 안전성이라고 부르겠습니다.</p>
</li>
<li>
<p>안전한 코드에서, 프로그램이 올바른 일을 수행할 정도의 예외 안전성을 갖추는 것은 <em>바람직합니다</em>. 이를 <em>최대한의(maximal)</em> 예외 안전성이라고 부르겠습니다.</p>
</li>
</ul>
<p>러스트의 많은 부분이 그렇듯, 비안전한(Unsafe) 코드는 언와인딩과 관련하여 잘못된 안전한(Safe) 코드를 다룰 준비가 되어 있어야 합니다. 일시적으로 불건전한 상태를 만드는 코드는 패닉이 발생했을 때 그 상태가 사용되지 않도록 주의해야 합니다. 일반적으로 이는 불건전한 상태가 존재하는 동안에는 패닉이 발생하지 않는 코드만 실행되도록 하거나, 패닉 발생 시 상태를 정리하는 가드(guard)를 만드는 것을 의미합니다. 이것이 패닉이 관찰하는 상태가 반드시 완전히 일관된 상태여야 함을 의미하지는 않습니다. 그저 <em>안전한(safe)</em> 상태임만 보장하면 됩니다.</p>
<p>대부분의 비안전한 코드는 말단(leaf) 함수에 해당하므로 예외 안전성을 확보하기가 비교적 쉽습니다. 실행되는 모든 코드를 제어하며, 그 코드의 대부분은 패닉을 일으키지 않기 때문입니다. 하지만 비안전한 코드가 일시적으로 초기화되지 않은 데이터 배열을 다루면서 호출자가 제공한 코드를 반복적으로 호출하는 일은 드물지 않습니다. 이러한 코드는 예외 안전성을 신중하게 고려해야 합니다.</p>
<h2 id="vecpush_all"><a class="header" href="#vecpush_all">Vec::push_all</a></h2>
<p><code>Vec::push_all</code>은 전문화(specialization) 없이도 슬라이스를 통해 <code>Vec</code>을 효율적으로 확장하기 위해 임시로 고안된 방법입니다. 다음은 간단한 구현 예시입니다:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">impl&lt;T: Clone&gt; Vec&lt;T&gt; {
    fn push_all(&amp;mut self, to_push: &amp;[T]) {
        self.reserve(to_push.len());
        unsafe {
            // 방금 예약했으므로 오버플로가 발생할 수 없습니다
            self.set_len(self.len() + to_push.len());

            for (i, x) in to_push.iter().enumerate() {
                self.ptr().add(i).write(x.clone());
            }
        }
    }
}</code></pre>
<p>확실히 용량이 있다는 것을 알기 때문에 불필요한 용량 및 <code>len</code> 체크를 피하기 위해 <code>push</code>를 우회했습니다. 로직 자체는 완전히 올바르지만, 우리 코드에는 미묘한 문제가 있습니다. 바로 예외에 안전하지 않다는 것입니다! <code>set_len</code>, <code>add</code>, <code>write</code>는 모두 괜찮지만, 우리가 간과한 패닉 폭탄은 바로 <code>clone</code>입니다.</p>
<p><code>Clone</code>은 우리의 통제권을 완전히 벗어나 있으며 언제든지 패닉을 일으킬 수 있습니다. 만약 패닉이 발생하면, 함수는 <code>Vec</code>의 길이가 너무 크게 설정된 상태로 조기에 종료될 것입니다. 이후 <code>Vec</code>을 들여다보거나 드롭하면, 초기화되지 않은 메모리를 읽게 될 것입니다!</p>
<p>이 경우 해결책은 꽤 간단합니다. 이미 복제된 값들이 반드시 드롭되도록 보장하고 싶다면, 루프를 돌 때마다 <code>len</code>을 설정하면 됩니다. 단순히 초기화되지 않은 메모리가 노출되지 않도록만 보장하고 싶다면, 루프가 끝난 뒤에 <code>len</code>을 설정하면 됩니다.</p>
<h2 id="binaryheapsift_up"><a class="header" href="#binaryheapsift_up">BinaryHeap::sift_up</a></h2>
<p>힙(heap)에서 요소를 위로 끌어올리는 것(bubbling up)은 <code>Vec</code>을 확장하는 것보다 조금 더 복잡합니다. 의사코드(pseudocode)는 다음과 같습니다:</p>
<pre><code class="language-text">bubble_up(heap, index):
    while index != 0 &amp;&amp; heap[index] &lt; heap[parent(index)]:
        heap.swap(index, parent(index))
        index = parent(index)
</code></pre>
<p>이 코드를 그대로 러스트로 옮기는 것은 전혀 문제가 없지만, 성능 면에서 아쉬운 점이 있습니다. <code>self</code> 요소가 불필요하게 반복적으로 스왑(swap)된다는 것입니다. 우리는 차라리 다음과 같은 방식을 원할 것입니다:</p>
<pre><code class="language-text">bubble_up(heap, index):
    let elem = heap[index]
    while index != 0 &amp;&amp; elem &lt; heap[parent(index)]:
        heap[index] = heap[parent(index)]
        index = parent(index)
    heap[index] = elem
</code></pre>
<p>이 코드는 각 요소가 가능한 한 적게 복사되도록 보장합니다(일반적으로 <code>elem</code>이 두 번 복사되는 것은 필수적입니다). 하지만 이제 예외 안전성 문제가 발생합니다! 어느 시점에서든 하나의 값이 두 개의 복사본으로 존재하게 됩니다. 만약 이 함수 내에서 패닉이 발생하면 무언가가 이중 드롭(double-dropped)될 것입니다. 안타깝게도 우리는 이 코드를 완전히 통제할 수도 없습니다. 저 비교(comparison) 로직은 사용자가 정의한 것이기 때문입니다!</p>
<p><code>Vec</code>과는 달리, 여기서는 해결책이 그리 간단하지 않습니다. 한 가지 방법은 사용자 정의 코드와 unsafe 코드를 두 개의 별도 단계로 나누는 것입니다:</p>
<pre><code class="language-text">bubble_up(heap, index):
    let end_index = index;
    while end_index != 0 &amp;&amp; heap[index] &lt; heap[parent(end_index)]:
        end_index = parent(end_index)

    let elem = heap[index]
    while index != end_index:
        heap[index] = heap[parent(index)]
        index = parent(index)
    heap[index] = elem
</code></pre>
<p>이제 사용자 정의 코드에서 문제가 발생하더라도 더 이상 상관없습니다. 아직 힙의 상태를 실제로 건드리지 않았기 때문입니다. 일단 우리가 힙을 조작하기 시작하면, 우리가 신뢰하는 데이터와 함수들로만 작업하게 되므로 패닉에 대한 걱정이 없습니다.</p>
<p>아마도 이런 설계가 마음에 들지 않으실 수도 있습니다. 이건 분명히 반칙이죠! 게다가 복잡한 힙 순회를 _두 번_이나 해야 한다니요! 알겠습니다, 정면 돌파해 봅시다. 신뢰할 수 없는 코드와 unsafe 코드를 <em>진짜로</em> 섞어보겠습니다.</p>
<p>만약 러스트에 자바와 같은 <code>try</code>와 <code>finally</code>가 있었다면, 다음과 같이 할 수 있었을 것입니다:</p>
<pre><code class="language-text">bubble_up(heap, index):
    let elem = heap[index]
    try:
        while index != 0 &amp;&amp; elem &lt; heap[parent(index)]:
            heap[index] = heap[parent(index)]
            index = parent(index)
    finally:
        heap[index] = elem
</code></pre>
<p>기본적인 아이디어는 간단합니다. 비교 과정에서 패닉이 발생하면, 떠돌고 있는 요소를 논리적으로 초기화되지 않은 인덱스에 던져 넣고 빠져나오는 것입니다. 힙을 관찰하는 누군가는 잠재적으로 <em>일관되지 않은</em> 힙을 보게 되겠지만, 적어도 이중 드롭(double-drops)을 일으키지는 않을 것입니다! 알고리즘이 정상적으로 종료된다면, 이 작업은 우리가 원래 마무리하려던 방식과 정확히 일치하게 됩니다.</p>
<p>안타깝게도 러스트에는 그런 구조가 없으므로, 우리가 직접 만들어야 합니다! 이를 수행하는 방법은 알고리즘의 상태를 별도의 구조체에 저장하고, "finally" 로직을 위해 소멸자를 활용하는 것입니다. 패닉이 발생하든 말든, 그 소멸자는 실행되어 뒷정리를 해줄 것입니다.</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">struct Hole&lt;'a, T: 'a&gt; {
    data: &amp;'a mut [T],
    /// `elt`는 생성 시부터 드롭될 때까지 항상 `Some`입니다.
    elt: Option&lt;T&gt;,
    pos: usize,
}

impl&lt;'a, T&gt; Hole&lt;'a, T&gt; {
    fn new(data: &amp;'a mut [T], pos: usize) -&gt; Self {
        unsafe {
            let elt = ptr::read(&amp;data[pos]);
            Hole {
                data,
                elt: Some(elt),
                pos,
            }
        }
    }

    fn pos(&amp;self) -&gt; usize { self.pos }

    fn removed(&amp;self) -&gt; &amp;T { self.elt.as_ref().unwrap() }

    fn get(&amp;self, index: usize) -&gt; &amp;T { &amp;self.data[index] }

    unsafe fn move_to(&amp;mut self, index: usize) {
        let index_ptr: *const _ = &amp;self.data[index];
        let hole_ptr = &amp;mut self.data[self.pos];
        ptr::copy_nonoverlapping(index_ptr, hole_ptr, 1);
        self.pos = index;
    }
}

impl&lt;'a, T&gt; Drop for Hole&lt;'a, T&gt; {
    fn drop(&amp;mut self) {
        // 구멍을 다시 채웁니다
        unsafe {
            let pos = self.pos;
            ptr::write(&amp;mut self.data[pos], self.elt.take().unwrap());
        }
    }
}

impl&lt;T: Ord&gt; BinaryHeap&lt;T&gt; {
    fn sift_up(&amp;mut self, pos: usize) {
        unsafe {
            // `pos`에 있는 값을 꺼내고 구멍을 만듭니다.
            let mut hole = Hole::new(&amp;mut self.data, pos);

            while hole.pos() != 0 {
                let parent = parent(hole.pos());
                if hole.removed() &lt;= hole.get(parent) { break }
                hole.move_to(parent);
            }
            // 패닉 여부와 관계없이 여기서 구멍은 무조건 채워집니다!
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="오염"><a class="header" href="#오염">오염</a></h1>
<p>모든 비안전한(unsafe) 코드가 최소한의 예외 안전성을 보장해야 <em>함에도</em> 불구하고, 모든 타입이 <em>최대한의</em> 예외 안전성을 보장하는 것은 아닙니다. 설령 타입이 보장한다 하더라도, 여러분의 코드가 그 타입에 추가적인 의미를 부여했을 수 있습니다. 예를 들어, 정수는 분명 예외에 안전하지만 그 자체로는 아무런 의미론을 갖지 않습니다. 패닉이 발생하는 코드가 정수를 올바르게 업데이트하지 못하여 일관되지 않은 프로그램 상태를 만들 가능성이 있습니다.</p>
<p>이는 <em>보통</em> 괜찮습니다. 예외를 목격한 모든 것은 곧 파괴될 것이기 때문입니다. 예를 들어, <code>Vec</code>을 다른 스레드로 보냈는데 그 스레드가 패닉을 일으킨다면, <code>Vec</code>이 이상한 상태에 있더라도 상관없습니다. 해당 <code>Vec</code>은 드롭되어 영원히 사라질 것이기 때문입니다. 하지만 어떤 타입들은 패닉 경계를 넘어 값을 밀수하는 데 특히 능숙합니다.</p>
<p>이러한 타입들은 패닉을 목격했을 때 스스로를 명시적으로 _오염(poison)_시키기로 선택할 수 있습니다. 오염시킨다고 해서 특별한 일이 벌어지는 것은 아닙니다. 일반적으로는 정상적인 사용이 계속되는 것을 막는다는 의미입니다. 이것의 가장 눈에 띄는 예는 표준 라이브러리의 <code>Mutex</code> 타입입니다. <code>Mutex</code>는 자신의 <code>MutexGuard</code>(락을 획득했을 때 반환하는 것) 중 하나가 패닉 도중에 드롭되면 스스로를 오염시킵니다. 이후 해당 <code>Mutex</code>에 락을 걸려는 모든 시도는 <code>Err</code>을 반환하거나 패닉을 일으키게 됩니다.</p>
<p><code>Mutex</code>가 오염시키는 것은 러스트가 보통 신경 쓰는 의미에서의 진정한 안전을 위한 것은 아닙니다. <code>Mutex</code>가 락이 걸린 상태에서 패닉을 목격했을 때, 그로부터 나오는 데이터를 맹목적으로 사용하는 것에 대한 안전 장치로서 오염시키는 것입니다. 그런 <code>Mutex</code> 안의 데이터는 수정되는 도중이었을 가능성이 높으며, 따라서 일관되지 않거나 불완전한 상태일 수 있습니다. 중요한 점은, 올바르게 작성되었다면 이러한 타입으로 메모리 안전성을 위반할 수는 없다는 것입니다. 결국 최소한의 예외 안전성은 갖추어야 하니까요!</p>
<p>하지만 <code>Mutex</code>가 예를 들어 실제로는 힙 속성을 갖지 않는 <code>BinaryHeap</code>을 포함하고 있다면, 그것을 사용하는 어떤 코드도 작성자의 의도대로 작동하지 않을 가능성이 높습니다. 따라서 프로그램은 정상적으로 진행되어서는 안 됩니다. 그럼에도 불구하고, 여러분이 그 값으로 무언가를 할 수 있다는 확신이 120% 있다면, <code>Mutex</code>는 어쨌든 락을 획득할 수 있는 메서드를 제공합니다. 어쨌든 <em>안전하긴</em> 하니까요. 단지 결과가 무의미할 뿐일 수도 있습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="동시성과-병렬성"><a class="header" href="#동시성과-병렬성">동시성과 병렬성</a></h1>
<p>러스트라는 언어 자체가 동시성이나 병렬성을 어떻게 수행해야 하는지에 대해 딱히 정해진 의견을 가지고 있는 것은 아닙니다. 표준 라이브러리는 OS 스레드와 블로킹 시스템 호출을 노출하는데, 이는 모든 환경에서 제공되며 비교적 논란의 여지 없는 방식으로 추상화를 제공할 수 있을 만큼 균일하기 때문입니다. 메시지 패싱, 그린 스레드, 그리고 비동기 API들은 워낙 다양해서 그것들을 추상화하려고 하면 1.0 버전에서는 감당하기 힘든 트레이드오프들이 발생할 수밖에 없었습니다.</p>
<p>하지만 러스트가 동시성을 모델링하는 방식 덕분에, 라이브러리 형태로 여러분만의 동시성 패러다임을 설계하고 다른 모든 사람의 코드가 여러분의 것과 함께 "그냥 작동"하도록 만드는 것이 비교적 쉽습니다. 적절한 수명과 <code>Send</code>, <code>Sync</code> 제약만 요구하면 만사형통입니다. 경주(races)를 시작할 준비가 된 것이죠. 아니, 오히려... 데이터 경쟁(races)이... 없는... 상태가 되는 것이죠.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="데이터-경쟁과-경쟁-조건"><a class="header" href="#데이터-경쟁과-경쟁-조건">데이터 경쟁과 경쟁 조건</a></h1>
<p>안전한 러스트는 데이터 경쟁이 없음을 보장하며, 데이터 경쟁은 다음과 같이 정의됩니다:</p>
<ul>
<li>둘 이상의 스레드가 동시에 메모리 위치에 접근함</li>
<li>그중 하나 이상이 쓰기 작업임</li>
<li>그중 하나 이상이 동기화되지 않음</li>
</ul>
<p>데이터 경쟁은 정의되지 않은 동작을 유발하며, 따라서 안전한 러스트에서는 수행할 수 없습니다. 데이터 경쟁은 <em>주로</em> 러스트의 소유권 시스템만으로 방지됩니다. 가변 참조를 별칭(alias)하는 것이 불가능하므로 데이터 경쟁이 일어날 수 없습니다. 내부 가변성은 이를 더 복잡하게 만드는데, 이것이 바로 우리에게 <code>Send</code>와 <code>Sync</code> 트레잇이 있는 주된 이유입니다(자세한 내용은 다음 섹션을 참조하세요).</p>
<p><strong>하지만 러스트는 일반적인 경쟁 조건(race conditions)을 방지하지는 않습니다.</strong></p>
<p>스케줄러를 직접 통제하지 못하는 상황에서는 이를 방지하는 것이 수학적으로 불가능하며, 일반적인 OS 환경이 바로 그러합니다. 만약 선점(preemption)을 제어할 수 있다면 일반적인 경쟁을 방지하는 것이 <em>가능할 수도</em> 있습니다. 이러한 기법은 <a href="https://github.com/rtic-rs/rtic">RTIC</a>과 같은 프레임워크에서 사용됩니다. 하지만 실제로 스케줄링에 대한 제어권을 갖는 경우는 매우 드뭅니다.</p>
<p>이러한 이유로, 러스트에서 교착 상태(deadlock)에 빠지거나 잘못된 동기화로 인해 무의미한 동작을 수행하는 것은 "안전한(safe)" 것으로 간주됩니다. 이는 일반적인 경쟁 조건 또는 자원 경쟁으로 알려져 있습니다. 분명히 그런 프로그램은 좋지 않지만, 러스트가 모든 논리적 에러를 방지할 수는 없습니다.</p>
<p>어떠한 경우에도 경쟁 조건 자체가 러스트 프로그램에서 메모리 안전성을 위반할 수는 없습니다. 오직 다른 비안전한(unsafe) 코드와 결합될 때만 경쟁 조건이 실제로 메모리 안전성을 위반할 수 있습니다. 예를 들어, 올바른 프로그램은 다음과 같습니다:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::thread;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::Arc;

let data = vec![1, 2, 3, 4];
// Arc를 사용하여 AtomicUsize가 저장된 메모리가 다른 스레드에 의해 증가될 수 있도록
// 계속 존재하게 합니다. 우리가 그보다 먼저 실행을 완전히 마쳐도 말이죠.
// thread::spawn의 수명 요구 사항 때문에 Arc 없이는 프로그램이 컴파일되지 않습니다!
let idx = Arc::new(AtomicUsize::new(0));
let other_idx = idx.clone();

// `move`는 other_idx를 값으로 캡처하여 이 스레드로 이동시킵니다
thread::spawn(move || {
    // idx를 변경하는 것은 괜찮습니다. 이 값은
    // 아토믹(atomic)이므로 데이터 경쟁을 일으킬 수 없기 때문입니다.
    other_idx.fetch_add(10, Ordering::SeqCst);
});

// 아토믹에서 로드한 값으로 인덱싱합니다. 이는 안전합니다. 아토믹 메모리를
// 단 한 번만 읽고, 그 복사본을 Vec의 인덱싱 구현에 전달하기 때문입니다.
// 이 인덱싱은 올바르게 범위를 체크하며, 중간에 값이 바뀔 염려가 없습니다.
// 하지만 우리가 생성한 스레드가 이 코드가 실행되기 전에 인덱스를 증가시켰다면
// 패닉이 발생할 수 있습니다. 프로그램의 올바른 실행(패닉이 발생하는 것은 대개 올바르지 않음)이
// 스레드 실행 순서에 달려 있으므로, 이는 경쟁 조건(race condition)입니다.
println!("{}", data[idx.load(Ordering::SeqCst)]);
<span class="boring">}</span></code></pre></pre>
<p>만약 우리가 미리 범위 체크를 한 뒤, 체크되지 않은 값으로 데이터를 비안전하게 접근한다면 경쟁 조건이 메모리 안전성을 위반하게 만들 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::thread;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::Arc;

let data = vec![1, 2, 3, 4];

let idx = Arc::new(AtomicUsize::new(0));
let other_idx = idx.clone();

// `move`는 other_idx를 값으로 캡처하여 이 스레드로 이동시킵니다
thread::spawn(move || {
    // idx를 변경하는 것은 괜찮습니다. 이 값은
    // 아토믹(atomic)이므로 데이터 경쟁을 일으킬 수 없기 때문입니다.
    other_idx.fetch_add(10, Ordering::SeqCst);
});

if idx.load(Ordering::SeqCst) &lt; data.len() {
    unsafe {
        // 범위 체크를 한 뒤에 idx를 잘못 로드하고 있습니다.
        // 값이 변했을 수 있습니다. 이는 경쟁 조건이며, 우리가 `unsafe`한
        // `get_unchecked`를 사용하기로 했기 때문에 *위험*합니다.
        println!("{}", data.get_unchecked(idx.load(Ordering::SeqCst)));
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="send와-sync"><a class="header" href="#send와-sync">Send와 Sync</a></h1>
<p>하지만 모든 것이 상속된 가변성(inherited mutability)을 따르는 것은 아닙니다. 어떤 타입들은 메모리 위치를 수정하면서 동시에 여러 개의 별칭(alias)을 갖는 것을 허용합니다. 이러한 타입들이 동기화를 사용하여 접근을 관리하지 않는 한, 그것들은 절대로 스레드 세이프(thread-safe)하지 않습니다. 러스트는 <code>Send</code>와 <code>Sync</code> 트레잇을 통해 이를 규정합니다.</p>
<ul>
<li>어떤 타입을 다른 스레드로 보내는 것이 안전하다면, 그 타입은 <code>Send</code>입니다.</li>
<li>스레드 간에 공유하는 것이 안전하다면 그 타입은 <code>Sync</code>입니다(<code>&amp;T</code>가 <code>Send</code>라면 <code>T</code>는 <code>Sync</code>이고, 그 역도 성립합니다).</li>
</ul>
<p><code>Send</code>와 <code>Sync</code>는 러스트 동시성 이야기의 핵심입니다. 따라서 이들을 올바르게 작동시키기 위한 상당한 양의 특별한 도구들이 존재합니다. 무엇보다도, 이들은 <a href="safe-unsafe-meaning.html">비안전 트레잇</a>입니다. 이는 이들을 구현하는 것이 안전하지 않으며, 다른 비안전 코드는 이들이 올바르게 구현되었다고 가정할 수 있다는 것을 의미합니다. 이들은 <em>마커 트레잇</em>(메서드와 같은 연관 항목이 없음)이기 때문에, 올바르게 구현되었다는 것은 단순히 구현체가 가져야 할 고유한 속성을 가지고 있음을 의미합니다. <code>Send</code>나 <code>Sync</code>를 잘못 구현하면 정의되지 않은 동작을 유발할 수 있습니다.</p>
<p><code>Send</code>와 <code>Sync</code>는 또한 자동으로 파생되는 트레잇입니다. 이는 다른 모든 트레잇과 달리, 어떤 타입이 전적으로 <code>Send</code> 또는 <code>Sync</code>인 타입들로만 구성되어 있다면, 그 타입도 <code>Send</code> 또는 <code>Sync</code>가 된다는 것을 의미합니다. 거의 모든 기본 타입은 <code>Send</code>이자 <code>Sync</code>이며, 결과적으로 여러분이 다루게 될 거의 모든 타입은 <code>Send</code>이자 <code>Sync</code>입니다.</p>
<p>주요 예외는 다음과 같습니다:</p>
<ul>
<li>원시 포인터는 <code>Send</code>도 아니고 <code>Sync</code>도 아닙니다(안전 장치가 없기 때문입니다).</li>
<li><code>UnsafeCell</code>은 <code>Sync</code>가 아닙니다(따라서 <code>Cell</code>과 <code>RefCell</code>도 아닙니다).</li>
<li><code>Rc</code>는 <code>Send</code>나 <code>Sync</code>가 아닙니다(참조 카운트가 공유되며 동기화되지 않기 때문입니다).</li>
</ul>
<p><code>Rc</code>와 <code>UnsafeCell</code>은 매우 근본적으로 스레드에 안전하지 않습니다. 이들은 동기화되지 않은 공유 가변 상태를 가능하게 합니다. 하지만 엄밀히 말하면 원시 포인터는 일종의 _린트(lint)_로서 스레드에 안전하지 않다고 표시된 것입니다. 원시 포인터로 유용한 작업을 하려면 역참조가 필요한데, 이는 이미 안전하지 않습니다. 그런 의미에서, 원시 포인터를 스레드 세이프하다고 표시해도 "괜찮다"고 주장할 수도 있습니다.</p>
<p>하지만 원시 포인터를 포함하는 타입들이 자동으로 스레드 세이프하다고 표시되는 것을 방지하기 위해 이들이 스레드에 안전하지 않은 것이 중요합니다. 이러한 타입들은 사소하지 않은 추적되지 않는 소유권을 가지고 있으며, 작성자가 반드시 스레드 안전성에 대해 깊이 고민했을 것 같지는 않습니다. <code>Rc</code>의 경우, <code>*mut</code>를 포함하며 확실히 스레드 세이프하지 않은 타입의 좋은 예입니다.</p>
<p>자동으로 파생되지 않는 타입들도 원한다면 간단히 이들을 구현할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyBox(*mut u8);

unsafe impl Send for MyBox {}
unsafe impl Sync for MyBox {}
<span class="boring">}</span></code></pre></pre>
<p>어떤 타입이 부적절하게 <code>Send</code>나 <code>Sync</code>로 자동 파생되는 <em>믿을 수 없을 정도로 드문</em> 경우에는, <code>Send</code>와 <code>Sync</code> 구현을 제거할 수도 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span>#![feature(negative_impls)]

<span class="boring">fn main() {
</span>// 어떤 동기화 기본 요소를 위한 마법 같은 의미론이 있습니다!
struct SpecialThreadToken(u8);

impl !Send for SpecialThreadToken {}
impl !Sync for SpecialThreadToken {}
<span class="boring">}</span></code></pre></pre>
<p><em>그 자체로는</em> <code>Send</code>와 <code>Sync</code>를 잘못 파생하는 것이 불가능하다는 점에 유의하세요. 다른 비안전 코드에 의해 특별한 의미가 부여된 타입들만이 잘못된 <code>Send</code> 또는 <code>Sync</code>로 인해 문제를 일으킬 수 있습니다.</p>
<p>대부분의 원시 포인터 사용은 <code>Send</code>와 <code>Sync</code>가 파생될 수 있도록 충분한 추상화 뒤에 캡슐화되어야 합니다. 예를 들어, 러스트의 모든 표준 컬렉션은 할당과 복잡한 소유권을 관리하기 위해 원시 포인터를 광범위하게 사용함에도 불구하고 (<code>Send</code>와 <code>Sync</code> 타입을 포함할 때) <code>Send</code>이자 <code>Sync</code>입니다. 마찬가지로, 이러한 컬렉션에 대한 대부분의 반복자(iterator)들도 컬렉션에 대한 <code>&amp;</code>나 <code>&amp;mut</code>처럼 동작하므로 <code>Send</code>이자 <code>Sync</code>입니다.</p>
<h2 id="예제"><a class="header" href="#예제">예제</a></h2>
<p><a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box</code></a>는 <a href="https://manishearth.github.io/blog/2017/01/10/rust-tidbits-box-is-special/">여러 이유</a>로 인해 컴파일러에 의해 자체적인 특별한 내장 타입으로 구현되어 있지만, <code>Send</code>와 <code>Sync</code>를 구현하는 것이 언제 건전한지에 대한 예를 보기 위해 비슷한 동작을 하는 무언가를 직접 구현해 볼 수 있습니다. 이것을 <code>Carton</code>이라고 부르기로 합시다.</p>
<p>스택에 할당된 값을 가져와 힙으로 전송하는 코드를 작성하는 것으로 시작합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub mod libc {
</span><span class="boring">   pub use ::std::os::raw::{c_int, c_void};
</span><span class="boring">   #[allow(non_camel_case_types)]
</span><span class="boring">   pub type size_t = usize;
</span><span class="boring">   unsafe extern "C" { pub fn posix_memalign(memptr: *mut *mut c_void, align: size_t, size: size_t) -&gt; c_int; }
</span><span class="boring">}
</span>use std::{
    mem::{align_of, size_of},
    ptr,
    cmp::max,
};

struct Carton&lt;T&gt;(ptr::NonNull&lt;T&gt;);

impl&lt;T&gt; Carton&lt;T&gt; {
    pub fn new(value: T) -&gt; Self {
        // T 하나를 저장할 수 있을 만큼의 힙 메모리를 할당합니다.
        assert_ne!(size_of::&lt;T&gt;(), 0, "크기가 0인 타입은 이 예제의 범위를 벗어납니다");
        let mut memptr: *mut T = ptr::null_mut();
        unsafe {
            let ret = libc::posix_memalign(
                (&amp;mut memptr as *mut *mut T).cast(),
                max(align_of::&lt;T&gt;(), size_of::&lt;usize&gt;()),
                size_of::&lt;T&gt;()
            );
            assert_eq!(ret, 0, "할당 실패 또는 잘못된 정렬");
        };

        // NonNull은 포인터가 null이 아님을 강제하는 래퍼일 뿐입니다.
        let ptr = {
            // 안전성: memptr은 참조로부터 생성했고 배타적인 접근 권한을 가지고 있으므로
            // 역참조 가능합니다.
            ptr::NonNull::new(memptr)
                .expect("posix_memalign이 0을 반환하면 null이 아님을 보장함")
        };

        // 스택에서 힙에 할당한 위치로 값을 이동합니다.
        unsafe {
            // 안전성: null이 아니라면, posix_memalign은 쓰기에 유효하고
            // 적절히 정렬된 포인터를 제공합니다.
            ptr.as_ptr().write(value);
        }

        Self(ptr)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>이것은 별로 유용하지 않습니다. 사용자가 우리에게 값을 주면, 그들은 그것에 접근할 방법이 없기 때문입니다. <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box</code></a>는 <a href="https://doc.rust-lang.org/core/ops/trait.Deref.html"><code>Deref</code></a>와 <a href="https://doc.rust-lang.org/core/ops/trait.DerefMut.html"><code>DerefMut</code></a>를 구현하여 내부 값에 접근할 수 있게 합니다. 우리도 그렇게 해봅시다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::{Deref, DerefMut};

<span class="boring">struct Carton&lt;T&gt;(std::ptr::NonNull&lt;T&gt;);
</span><span class="boring">
</span>impl&lt;T&gt; Deref for Carton&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        unsafe {
            // 안전성: 포인터는 [`Self::new`]의 로직에 의해 정렬되고, 초기화되었으며,
            //   역참조 가능합니다. 우리는 읽는이가 Carton을 대여하도록 요구하며,
            //   반환 값의 수명은 입력의 수명으로 생략됩니다.
            //   이는 반환된 참조가 드롭될 때까지 아무도 Carton의 내용을
            //   변경할 수 없도록 대여 검사기가 강제한다는 것을 의미합니다.
            self.0.as_ref()
        }
    }
}

impl&lt;T&gt; DerefMut for Carton&lt;T&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
        unsafe {
            // 안전성: 포인터는 [`Self::new`]의 로직에 의해 정렬되고, 초기화되었으며,
            //   역참조 가능합니다. 우리는 쓰는이가 Carton을 가변 대여하도록 요구하며,
            //   반환 값의 수명은 입력의 수명으로 생략됩니다.
            //   이는 반환된 가변 참조가 드롭될 때까지 다른 누구도 Carton의
            //   내용에 접근할 수 없도록 대여 검사기가 강제한다는 것을 의미합니다.
            self.0.as_mut()
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>마지막으로, 우리의 <code>Carton</code>이 <code>Send</code>이고 <code>Sync</code>인지 생각해 봅시다. 배타적 접근을 강제하지 않으면서 다른 무언가와 가변 상태를 공유하지 않는 한, 어떤 것은 안전하게 <code>Send</code>가 될 수 있습니다. 각 <code>Carton</code>은 유일한 포인터를 가지고 있으므로 문제 없습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Carton&lt;T&gt;(std::ptr::NonNull&lt;T&gt;);
</span>// 안전성: 우리 외에는 아무도 원시 포인터를 가지고 있지 않으므로,
// T가 안전하게 전송될 수 있다면 Carton을 다른 스레드로 안전하게 전송할 수 있습니다.
unsafe impl&lt;T&gt; Send for Carton&lt;T&gt; where T: Send {}
<span class="boring">}</span></code></pre></pre>
<p><code>Sync</code>는 어떨까요? <code>Carton</code>이 <code>Sync</code>가 되려면, 다른 <code>&amp;Carton</code>에서 읽거나 쓰고 있는 동안 <code>&amp;Carton</code>에 저장된 무언가에 쓸 수 없도록 강제해야 합니다. 포인터에 쓰려면 <code>&amp;mut Carton</code>이 필요하고, 대여 검사기가 가변 참조의 배타성을 강제하므로, <code>Carton</code>을 <code>Sync</code>로 만드는 데에도 건전성 문제는 없습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Carton&lt;T&gt;(std::ptr::NonNull&lt;T&gt;);
</span>// 안전성: 동기화되지 않은 방식(`Deref` 등)으로 `&amp;Carton&lt;T&gt;`에서 `&amp;T`로 가는
// 공개된 방법이 존재하므로, `T`가 `Sync`가 아니면 `Carton&lt;T&gt;`도 `Sync`일 수
// 없습니다.
// 반대로, `Carton` 자체는 내부 가변성을 전혀 사용하지 않습니다.
// 모든 변경은 배타적 참조(`&amp;mut`)를 통해 수행됩니다. 이는 `Carton&lt;T&gt;`가
// `Sync`이기 위해 `T`가 `Sync`인 것으로 충분하다는 것을 의미합니다:
unsafe impl&lt;T&gt; Sync for Carton&lt;T&gt; where T: Sync  {}
<span class="boring">}</span></code></pre></pre>
<p>우리의 타입이 <code>Send</code>이고 <code>Sync</code>라고 주장할 때, 우리는 보통 포함된 모든 타입이 <code>Send</code>이고 <code>Sync</code>임을 강제해야 합니다. 표준 라이브러리 타입처럼 동작하는 사용자 정의 타입을 작성할 때, 우리는 동일한 요구 사항을 갖는다고 주장할 수 있습니다. 예를 들어, 다음 코드는 동일한 종류의 <code>Box</code>가 <code>Send</code>라면 <code>Carton</code>도 <code>Send</code>라고 주장하는데, 이 경우 이는 <code>T</code>가 <code>Send</code>라는 말과 같습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Carton&lt;T&gt;(std::ptr::NonNull&lt;T&gt;);
</span>unsafe impl&lt;T&gt; Send for Carton&lt;T&gt; where Box&lt;T&gt;: Send {}
<span class="boring">}</span></code></pre></pre>
<p>지금 <code>Carton&lt;T&gt;</code>는 할당한 메모리를 절대 해제하지 않으므로 메모리 누수가 있습니다. 이를 수정하면 <code>Send</code>가 되기 위해 충족해야 할 새로운 요구 사항이 생깁니다. 우리는 다른 스레드에서 수행된 할당으로 얻은 포인터에 대해 <code>free</code>를 호출할 수 있는지 알아야 합니다. <a href="https://linux.die.net/man/3/free"><code>libc::free</code></a> 문서에서 이것이 사실임을 확인할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Carton&lt;T&gt;(std::ptr::NonNull&lt;T&gt;);
</span><span class="boring">mod libc {
</span><span class="boring">    pub use ::std::os::raw::c_void;
</span><span class="boring">    unsafe extern "C" { pub fn free(p: *mut c_void); }
</span><span class="boring">}
</span>impl&lt;T&gt; Drop for Carton&lt;T&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            libc::free(self.0.as_ptr().cast());
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>이것이 성립하지 않는 좋은 예는 <code>MutexGuard</code>입니다. <a href="https://doc.rust-lang.org/std/sync/struct.MutexGuard.html#impl-Send-for-MutexGuard%3C&#x27;_,+T%3E"><code>Send</code>가 아님</a>에 주목하세요. <code>MutexGuard</code>의 구현은 다른 스레드에서 획득한 잠금을 해제하려고 시도하지 않도록 보장해야 하는 <a href="https://github.com/rust-lang/rust/issues/23465#issuecomment-82730326">라이브러리를 사용합니다</a>. 만약 <code>MutexGuard</code>를 다른 스레드로 보낼(<code>Send</code>) 수 있다면, 소멸자가 보낸 스레드에서 실행되어 요구 사항을 위반하게 될 것입니다. <code>MutexGuard</code>는 여전히 <code>Sync</code>일 수 있는데, 다른 스레드로 보낼 수 있는 것은 <code>&amp;MutexGuard</code>뿐이고 참조를 드롭하는 것은 아무 일도 하지 않기 때문입니다.</p>
<p>TODO: 무엇이 <code>Send</code>나 <code>Sync</code>가 될 수 있고 없는지 더 잘 설명해야 함. 데이터 경쟁에만 호소하는 것으로 충분한가?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="아토믹"><a class="header" href="#아토믹">아토믹</a></h1>
<p>Rust pretty blatantly just inherits the memory model for atomics from C++20. This is not due to this model being particularly excellent or easy to understand. Indeed, this model is quite complex and known to have <a href="http://plv.mpi-sws.org/c11comp/popl15.pdf">several flaws</a>. Rather, it is a pragmatic concession to the fact that <em>everyone</em> is pretty bad at modeling atomics. At the very least, we can benefit from existing tooling and research around the C/C++ memory model. (You'll often see this model referred to as "C/C++11" or just "C11". C just copies the C++ memory model; and C++11 was the first version of the model but it has received some bugfixes since then.)</p>
<p>이 책에서 모델을 완전히 설명하려고 하는 것은 거의 가망이 없습니다. 이는 실질적으로 제대로 이해하려면 책 한 권이 필요한, 광기를 유발하는 인과 관계 그래프로 정의되어 있습니다. 아주 상세한 내용을 원한다면 <a href="https://en.cppreference.com/w/cpp/atomic/memory_order">C++ 사양</a>을 확인해야 합니다. 그래도 우리는 기본 사항과 러스트 개발자가 직면하는 몇 가지 문제를 다루려고 노력할 것입니다.</p>
<p>C++ 메모리 모델은 근본적으로 우리가 원하는 의미론, 컴파일러가 원하는 최적화, 그리고 하드웨어가 원하는 일관성 없는 혼돈 사이의 간극을 메우려는 시도입니다. _우리_는 그저 프로그램을 작성하고 우리가 말한 그대로 실행되기를 원합니다. 하지만, 알다시피, 빠르게 말이죠. 정말 좋지 않을까요?</p>
<h2 id="컴파일러-재배치-compiler-reordering"><a class="header" href="#컴파일러-재배치-compiler-reordering">컴파일러 재배치 (Compiler Reordering)</a></h2>
<p>컴파일러는 근본적으로 데이터 의존성을 줄이고 죽은 코드를 제거하기 위해 온갖 종류의 복잡한 변환을 수행할 수 있기를 원합니다. 특히, 이벤트의 실제 순서를 근본적으로 바꾸거나 이벤트가 아예 발생하지 않게 만들 수도 있습니다! 우리가 다음과 같이 작성한다면:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">x = 1;
y = 3;
x = 2;</code></pre>
<p>컴파일러는 프로그램이 다음과 같이 동작하는 것이 가장 좋다고 결론 내릴 수 있습니다:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">x = 2;
y = 3;</code></pre>
<p>이는 이벤트의 순서를 뒤집고 하나의 이벤트를 완전히 제거했습니다. 단일 스레드 관점에서는 이를 전혀 관찰할 수 없습니다. 모든 문이 실행된 후 우리는 정확히 동일한 상태에 있게 됩니다. 하지만 프로그램이 멀티 스레드라면, 우리는 <code>y</code>가 할당되기 전에 <code>x</code>가 실제로 1로 할당되는 것에 의존하고 있었을지도 모릅니다. 우리는 컴파일러가 이러한 종류의 최적화를 수행할 수 있기를 바랍니다. 성능을 크게 향상시킬 수 있기 때문입니다. 반면에, 우리는 프로그램이 _우리가 말한 대로 수행_하는 것에 의존할 수 있기를 원하기도 합니다.</p>
<h2 id="하드웨어-재배치-hardware-reordering"><a class="header" href="#하드웨어-재배치-hardware-reordering">하드웨어 재배치 (Hardware Reordering)</a></h2>
<p>반면에, 컴파일러가 우리가 원하는 것을 완전히 이해하고 우리의 소원을 존중한다고 해도, 하드웨어가 우리를 곤경에 빠뜨릴 수 있습니다. 문제는 메모리 계층 구조의 형태로 CPU에서 발생합니다. 하드웨어 어딘가에 전역 공유 메모리 공간이 실제로 존재하지만, 각 CPU 코어의 관점에서 보면 그것은 <em>너무나 멀고</em> <em>너무나 느립니다</em>. 각 CPU는 차라리 로컬 데이터 캐시로 작업하고 싶어 하며, 실제로 캐시에 해당 메모리가 없을 때만 공유 메모리와 대화하는 모든 고통을 겪습니다.</p>
<p>결국 그것이 캐시의 존재 이유 아니겠습니까? 캐시에서 읽을 때마다 공유 메모리로 달려가서 변경되지 않았는지 다시 확인해야 한다면, 무슨 의미가 있을까요? 결론적으로 하드웨어는 <em>한</em> 스레드에서 어떤 순서로 발생한 이벤트가 <em>다른</em> 스레드에서도 같은 순서로 발생한다고 보장하지 않습니다. 이를 보장하려면, 우리는 CPU에게 조금 덜 똑똑하게 굴라고 말하는 특별한 명령을 내려야 합니다.</p>
<p>예를 들어, 우리가 컴파일러를 설득하여 다음 로직을 방출하게 했다고 가정해 봅시다:</p>
<pre><code class="language-text">initial state: x = 0, y = 1

THREAD 1        THREAD 2
y = 3;          if x == 1 {
x = 1;              y *= 2;
                }
</code></pre>
<p>이상적으로 이 프로그램은 2가지 가능한 최종 상태를 가집니다:</p>
<ul>
<li><code>y = 3</code>: (스레드 1이 완료되기 전에 스레드 2가 확인을 수행함)</li>
<li><code>y = 6</code>: (스레드 1이 완료된 후에 스레드 2가 확인을 수행함)</li>
</ul>
<p>하지만 하드웨어가 가능하게 하는 세 번째 잠재적 상태가 있습니다:</p>
<ul>
<li><code>y = 2</code>: (스레드 2가 <code>x = 1</code>은 보았지만 <code>y = 3</code>은 보지 못했고, 그 후 <code>y = 3</code>을 덮어씀)</li>
</ul>
<p>CPU 종류에 따라 서로 다른 보장을 제공한다는 점은 주목할 만합니다. 하드웨어를 두 가지 범주, 즉 강하게 정렬된(strongly-ordered) 것과 약하게 정렬된(weakly-ordered) 것으로 나누는 것이 일반적입니다. 가장 눈에 띄게 x86/64는 강력한 정렬 보장을 제공하는 반면, ARM은 약한 정렬 보장을 제공합니다. 이는 동시성 프로그래밍에 두 가지 결과를 가져옵니다:</p>
<ul>
<li>
<p>강하게 정렬된 하드웨어에서 더 강력한 보장을 요구하는 것은 저렴하거나 심지어 무료일 수 있습니다. 그들은 이미 무조건적으로 강력한 보장을 제공하기 때문입니다. 더 약한 보장은 약하게 정렬된 하드웨어에서만 성능 이득을 얻을 수 있습니다.</p>
</li>
<li>
<p>강하게 정렬된 하드웨어에서 너무 약한 보장을 요구하는 경우, 프로그램이 엄밀히 말해 틀렸음에도 불구하고 <em>우연히</em> 작동할 가능성이 더 높습니다. 가능하다면 동시성 알고리즘은 약하게 정렬된 하드웨어에서 테스트해야 합니다.</p>
</li>
</ul>
<h2 id="데이터-접근-data-accesses"><a class="header" href="#데이터-접근-data-accesses">데이터 접근 (Data Accesses)</a></h2>
<p>C++ 메모리 모델은 우리 프로그램의 _인과 관계(causality)_에 대해 이야기할 수 있게 함으로써 간극을 메우려고 시도합니다. 일반적으로 이는 프로그램의 부분들과 그것들을 실행하는 스레드들 사이에 <em>발생 전(happens before)</em> 관계를 확립하는 방식입니다. 이는 엄격한 발생 전 관계가 확립되지 않은 곳에서는 하드웨어와 컴파일러가 프로그램을 더 공격적으로 최적화할 수 있는 여지를 주지만, 관계가 확립된 곳에서는 더 주의하도록 강제합니다. 우리가 이러한 관계를 전달하는 방식은 _데이터 접근_과 _아토믹 접근_을 통해서입니다.</p>
<p>데이터 접근은 프로그래밍 세계의 기본입니다. 이들은 근본적으로 동기화되지 않으며 컴파일러는 이들을 공격적으로 최적화할 자유가 있습니다. 특히, 데이터 접근은 프로그램이 단일 스레드라는 가정하에 컴파일러에 의해 자유롭게 재배치될 수 있습니다. 하드웨어 또한 데이터 접근에서 이루어진 변경 사항을 다른 스레드에 원하는 만큼 게으르고 비일관적으로 전파할 자유가 있습니다. 가장 치명적인 것은, 데이터 접근이 바로 데이터 경쟁이 발생하는 원인이라는 점입니다. 데이터 접근은 하드웨어와 컴파일러에게는 매우 친화적이지만, 우리가 보았듯이 동기화된 코드를 작성하려고 할 때 <em>끔찍한</em> 의미론을 제공합니다. 사실, 끔찍하다는 표현도 부족합니다.</p>
<p><strong>데이터 접근만을 사용하여 올바른 동기화 코드를 작성하는 것은 말 그대로 불가능합니다.</strong></p>
<p>아토믹 접근은 우리 프로그램이 멀티 스레드임을 하드웨어와 컴파일러에 알리는 방법입니다. 각 아토믹 접근은 다른 접근들과 어떤 종류의 관계를 맺는지 지정하는 _정렬(ordering)_로 표시될 수 있습니다. 실제로는, 이것은 컴파일러와 하드웨어에게 그들이 할 수 <em>없는</em> 특정 작업들을 말해주는 것으로 귀결됩니다. 컴파일러의 경우, 이는 주로 명령어의 재배치를 중심으로 돌아갑니다. 하드웨어의 경우, 이는 주로 쓰기가 다른 스레드에 전파되는 방식을 중심으로 돌아갑니다. 러스트가 노출하는 정렬 집합은 다음과 같습니다:</p>
<ul>
<li>순차적 일관성 (Sequentially Consistent, SeqCst)</li>
<li>릴리스 (Release)</li>
<li>어콰이어 (Acquire)</li>
<li>릴랙스드 (Relaxed)</li>
</ul>
<p>(참고: 우리는 C++의 <em>consume</em> 정렬을 명시적으로 노출하지 않습니다)</p>
<p>TODO: 부정적 추론 vs 긍정적 추론? TODO: "동기화하는 것을 잊을 수 없음"</p>
<h2 id="순차적-일관성-sequentially-consistent"><a class="header" href="#순차적-일관성-sequentially-consistent">순차적 일관성 (Sequentially Consistent)</a></h2>
<p>순차적 일관성(Sequentially Consistent)은 가장 강력한 정렬로, 다른 모든 정렬의 제약 조건을 포함합니다. 직관적으로, 순차적으로 일관된 작업은 재배치될 수 없습니다. <code>SeqCst</code> 접근 전후에 발생하는 한 스레드의 모든 접근은 그 전후에 머무릅니다. 순차적으로 일관된 아토믹과 데이터 접근만을 사용하는 데이터 경쟁 없는 프로그램은 모든 스레드가 동의하는 단일 전역 실행 순서가 있다는 아주 좋은 속성을 가집니다. 이 실행은 추론하기에도 매우 좋습니다. 각 스레드의 개별 실행을 인터리빙(interleaving)한 것일 뿐이기 때문입니다. 더 약한 아토믹 정렬을 사용하기 시작하면 이 속성은 유지되지 않습니다.</p>
<p>순차적 일관성의 상대적인 개발자 친화성은 공짜가 아닙니다. 강하게 정렬된 플랫폼에서도 순차적 일관성은 메모리 펜스(memory fence) 방출을 수반합니다.</p>
<p>실제로는 프로그램의 정확성을 위해 순차적 일관성이 필요한 경우는 드뭅니다. 하지만 다른 메모리 순서에 대해 확신이 없다면 순차적 일관성이 확실히 올바른 선택입니다. 프로그램이 필요 이상으로 조금 느리게 실행되는 것이 잘못 실행되는 것보다 확실히 낫습니다! 나중에 아토믹 연산을 더 약한 일관성으로 다운그레이드하는 것도 기계적으로 매우 간단합니다. 그냥 <code>SeqCst</code>를 <code>Relaxed</code>로 바꾸면 끝입니다! 물론, 이 변환이 _올바르다_는 것을 증명하는 것은 완전히 다른 문제입니다.</p>
<h2 id="어콰이어-릴리스-acquire-release"><a class="header" href="#어콰이어-릴리스-acquire-release">어콰이어-릴리스 (Acquire-Release)</a></h2>
<p>어콰이어(Acquire)와 릴리스(Release)는 주로 쌍을 이루도록 의도되었습니다. 그들의 이름이 사용 사례를 암시합니다. 즉, 잠금을 획득(acquire)하고 해제(release)하며, 임계 영역(critical section)이 겹치지 않도록 보장하는 데 완벽하게 적합합니다.</p>
<p>직관적으로, 어콰이어 접근은 그 이후의 모든 접근이 그 이후에 머무르도록 보장합니다. 하지만 어콰이어 이전에 발생하는 작업은 자유롭게 재배치되어 그 이후에 발생할 수 있습니다. 마찬가지로, 릴리스 접근은 그 이전의 모든 접근이 그 이전에 머무르도록 보장합니다. 하지만 릴리스 이후에 발생하는 작업은 자유롭게 재배치되어 그 이전에 발생할 수 있습니다.</p>
<p>스레드 A가 메모리의 한 위치를 릴리스하고, 그 후 스레드 B가 메모리의 <em>동일한</em> 위치를 어콰이어하면, 인과 관계가 성립됩니다. A의 릴리스 이전에 발생한 모든 쓰기(비원자적 및 릴랙스드 아토믹 쓰기 포함)는 B가 어콰이어한 후에 관찰됩니다. 하지만 다른 어떤 스레드와도 인과 관계가 성립하지 않습니다. 마찬가지로, A와 B가 메모리의 <em>서로 다른</em> 위치에 접근한다면 인과 관계는 성립하지 않습니다.</p>
<p>따라서 릴리스-어콰이어의 기본적인 사용법은 간단합니다. 임계 영역을 시작하기 위해 메모리 위치를 어콰이어하고, 끝내기 위해 해당 위치를 릴리스합니다. 예를 들어, 간단한 스핀락은 다음과 같을 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::sync::Arc;
use std::sync::atomic::{AtomicBool, Ordering};
use std::thread;

fn main() {
    let lock = Arc::new(AtomicBool::new(false)); // 값은 "잠겨 있습니까?"에 답합니다.

    // ... 어떻게든 스레드들에게 잠금을 분배 ...

    // 값을 true로 설정하여 잠금 획득을 시도합니다.
    while lock.compare_and_swap(false, true, Ordering::Acquire) { }
    // 루프를 빠져나왔으므로, 성공적으로 잠금을 획득했습니다!

    // ... 무시무시한 데이터 접근 ...

    // 좋아, 다 끝났으니 잠금을 해제합니다.
    lock.store(false, Ordering::Release);
}</code></pre></pre>
<p>강하게 정렬된 플랫폼에서 대부분의 접근은 릴리스 또는 어콰이어 의미론을 가지므로, 릴리스와 어콰이어는 종종 완전히 무료입니다. 약하게 정렬된 플랫폼에서는 그렇지 않습니다.</p>
<h2 id="릴랙스드-relaxed"><a class="header" href="#릴랙스드-relaxed">릴랙스드 (Relaxed)</a></h2>
<p>릴랙스드(Relaxed) 접근은 절대적으로 가장 약합니다. 자유롭게 재배치될 수 있으며 발생 전 관계를 제공하지 않습니다. 그럼에도 불구하고, 릴랙스드 연산은 여전히 원자적(atomic)입니다. 즉, 데이터 접근으로 간주되지 않으며 이에 대해 수행되는 모든 읽기-수정-쓰기 작업은 원자적으로 발생합니다. 릴랙스드 연산은 반드시 일어나기를 원하지만 그 외에는 특별히 신경 쓰지 않는 작업에 적합합니다. 예를 들어, 카운터를 사용하여 다른 접근을 동기화하지 않는다면 릴랙스드 <code>fetch_add</code>를 사용하여 여러 스레드에서 안전하게 카운터를 증가시킬 수 있습니다.</p>
<p>강하게 정렬된 플랫폼에서는 어차피 릴리스-어콰이어 의미론을 제공하는 경우가 많으므로 연산을 릴랙스드로 만드는 이점은 거의 없습니다. 하지만 약하게 정렬된 플랫폼에서는 릴랙스드 연산이 더 저렴할 수 있습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="예제-vec-구현하기"><a class="header" href="#예제-vec-구현하기">예제: Vec 구현하기</a></h1>
<p>모든 것을 종합하기 위해, 우리는 <code>std::Vec</code>을 처음부터 작성해 볼 것입니다. 우리는 안정적인(stable) 러스트로 제한할 것입니다. 특히 코드를 조금 더 좋게 만들거나 효율적으로 만들 수 있는 내장 함수(intrinsic)는 영구적으로 불안정하므로 사용하지 않을 것입니다. 비록 많은 내장 함수들이 다른 곳에서 안정화되기는 하지만요(<code>std::ptr</code>과 <code>std::mem</code>은 많은 내장 함수들로 구성되어 있습니다).</p>
<p>궁극적으로 이는 우리의 구현이 가능한 모든 최적화를 활용하지 못할 수도 있음을 의미하지만, 결코 <em>순진한(naive)</em> 구현은 아닐 것입니다. 우리는 문제가 <em>정말로</em> 그럴 가치가 없을 때조차도, 확실히 세부적인 사항들까지 파고들 것입니다.</p>
<p>고급을 원하셨죠. 고급으로 가봅시다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="레이아웃"><a class="header" href="#레이아웃">레이아웃</a></h1>
<p>먼저, 구조체 레이아웃을 생각해내야 합니다. Vec은 세 부분으로 구성됩니다: 할당에 대한 포인터, 할당의 크기, 그리고 초기화된 요소의 개수입니다.</p>
<p>단순하게 생각하면, 우리는 이런 디자인을 원할 것입니다:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">pub struct Vec&lt;T&gt; {
    ptr: *mut T,
    cap: usize,
    len: usize,
}</code></pre>
<p>그리고 실제로 이것은 컴파일될 것입니다. 불행히도, 이것은 너무 엄격할 것입니다. 컴파일러는 우리에게 너무 엄격한 공변성을 부여할 것입니다. 그래서 <code>&amp;Vec&lt;&amp;'a str&gt;</code>이 예상되는 곳에 <code>&amp;Vec&lt;&amp;'static str&gt;</code>를 사용할 수 없을 것입니다. 공변성에 대한 모든 세부 사항은 <a href="vec/../ownership.html">소유권과 수명 장</a>을 참조하세요.</p>
<p>소유권 장에서 보았듯이, 표준 라이브러리는 자신이 소유한 할당에 대한 원시 포인터를 가질 때 <code>*mut T</code> 대신 <code>Unique&lt;T&gt;</code>를 사용합니다. 하지만 Unique는 불안정하므로 가능하다면 사용하고 싶지 않습니다.</p>
<p>요약하자면, Unique는 다음을 선언하는 원시 포인터의 래퍼입니다:</p>
<ul>
<li>우리는 <code>T</code>에 대해 공변입니다</li>
<li>우리는 <code>T</code> 타입의 값을 소유할 수 있습니다(여기 예제에서는 관련이 없지만, 진짜 <code>std::vec::Vec&lt;T&gt;</code>가 이것을 필요로 하는 이유는 <a href="vec/../phantom-data.html">PhantomData 장</a>을 참조하세요).</li>
<li>T가 Send/Sync이면 우리도 Send/Sync입니다</li>
<li>우리의 포인터는 절대 null이 아닙니다(따라서 Option&lt;Vec<T>&gt;는 널 포인터 최적화가 적용됩니다)</li>
</ul>
<p>우리는 위의 모든 요구 사항을 안정적인(stable) 러스트에서 구현할 수 있습니다. 이를 위해 Unique<T> 대신 원시 포인터의 또 다른 래퍼인 NonNull<T>를 사용할 것입니다. NonNull<T>는 위의 두 가지 속성, 즉 T에 대해 공변하며 절대 null이 아님을 선언하는 속성을 제공합니다. T가 Send/Sync일 때 Send/Sync를 구현함으로써 Unique<T>를 사용하는 것과 동일한 결과를 얻을 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::ptr::NonNull;

pub struct Vec&lt;T&gt; {
    ptr: NonNull&lt;T&gt;,
    cap: usize,
    len: usize,
}

unsafe impl&lt;T: Send&gt; Send for Vec&lt;T&gt; {}
unsafe impl&lt;T: Sync&gt; Sync for Vec&lt;T&gt; {}
<span class="boring">fn main() {}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="메모리-할당하기"><a class="header" href="#메모리-할당하기">메모리 할당하기</a></h1>
<p>NonNull을 사용하는 것은 Vec(그리고 실제로 모든 표준 라이브러리 컬렉션)의 중요한 기능에 걸림돌이 됩니다. 빈 Vec을 생성할 때는 실제로 메모리를 전혀 할당하지 않는다는 점입니다. 이는 크기가 0인 메모리 블록을 할당하는 것과는 다릅니다. 전역 할당자(global allocator)는 크기가 0인 할당을 허용하지 않기 때문입니다(이는 정의되지 않은 동작을 초래합니다!). 그렇다면 할당을 할 수 없으면서 ptr에 null 포인터를 넣을 수도 없다면, Vec::new에서 무엇을 해야 할까요? 음, 그냥 그곳에 다른 쓰레기 값을 넣어두면 됩니다!</p>
<p>이는 전혀 문제가 되지 않습니다. 할당이 없음을 나타내는 파수꾼(sentinel) 값으로 이미 <code>cap == 0</code>을 사용하고 있기 때문입니다. 거의 모든 코드에서 이를 특별히 처리할 필요조차 없습니다. 어차피 보통 <code>cap &gt; len</code>이나 <code>len &gt; 0</code>인지 확인해야 하기 때문입니다. 여기에 넣는 것이 권장되는 러스트 값은 <code>mem::align_of::&lt;T&gt;()</code>입니다. <code>NonNull</code>은 이를 위한 편의 기능인 <code>NonNull::dangling()</code>을 제공합니다. 실제 할당된 메모리는 없지만 <code>null</code>을 사용하면 컴파일러가 원치 않는 동작을 할 수 있는 곳이 꽤 많으므로, 그럴 때 <code>dangling</code>을 사용하게 됩니다.</p>
<p>그래서:</p>
<!-- ignore: explanation code -->
<pre><code class="language-rust ignore">use std::mem;

impl&lt;T&gt; Vec&lt;T&gt; {
    pub fn new() -&gt; Self {
        assert!(mem::size_of::&lt;T&gt;() != 0, "아직 ZST를 처리할 준비가 되지 않았습니다");
        Vec {
            ptr: NonNull::dangling(),
            len: 0,
            cap: 0,
        }
    }
}
<span class="boring">fn main() {}</span></code></pre>
<p>여기에 단언문(assert)을 살짝 끼워 넣은 이유는 크기가 0인 타입(ZST)은 코드 전반에 걸쳐 특별한 처리가 필요하기 때문입니다. 일단 이 문제는 나중에 다루고 싶습니다. 이 단언문이 없다면, 초기 초안 중 일부는 아주 끔찍한 일을 저지를 것입니다.</p>
<p>다음으로 우리가 정말로 공간을 원할 때 무엇을 해야 할지 알아내야 합니다. 이를 위해 안정적인(stable) 러스트의 <a href="vec/../../alloc/alloc/index.html"><code>std::alloc</code></a>에서 제공하는 전역 할당 함수인 <a href="vec/../../alloc/alloc/fn.alloc.html"><code>alloc</code></a>, <a href="vec/../../alloc/alloc/fn.realloc.html"><code>realloc</code></a>, <a href="vec/../../alloc/alloc/fn.dealloc.html"><code>dealloc</code></a>을 사용합니다. 이 함수들은 <a href="vec/../../std/alloc/struct.Global.html"><code>std::alloc::Global</code></a> 타입이 안정화된 이후에는 해당 타입의 메서드들로 대체되면서 사라질 예정입니다.</p>
<p>또한 메모리 부족(OOM) 상황을 처리할 방법이 필요합니다. 표준 라이브러리는 <a href="vec/../../alloc/alloc/fn.handle_alloc_error.html"><code>alloc::handle_alloc_error</code></a> 함수를 제공하는데, 이 함수는 플랫폼별 방식에 따라 프로그램을 중단(abort)시킵니다. 패닉을 발생시키지 않고 중단하는 이유는 언와인딩(unwinding) 과정에서 추가적인 할당이 발생할 수 있기 때문입니다. 할당자가 방금 "메모리가 부족하다"고 했는데 추가 할당을 시도하는 것은 좋은 생각이 아닌 것 같습니다.</p>
<p>물론 대부분의 플랫폼에서 전통적인 방식으로 메모리가 부족해지는 일은 거의 없으므로 이는 조금 우스운 일일 수 있습니다. 실제로 메모리를 전부 사용하기 시작하면 운영 체제가 다른 수단을 통해 애플리케이션을 강제 종료할 가능성이 높습니다. 우리가 OOM을 유발할 수 있는 가장 가능성 높은 방법은 한 번에 터무니없는 양의 메모리(예: 이론적 주소 공간의 절반)를 요구하는 것입니다. 그런 경우라면 패닉을 발생시켜도 별다른 나쁜 일은 일어나지 않을 것이며 아마 괜찮을 것입니다. 그럼에도 불구하고 우리는 가능한 한 표준 라이브러리와 유사하게 만들고 싶으므로, 그냥 전체 프로그램을 종료할 것입니다.</p>
<p>좋습니다. 이제 용량 확장(growing) 로직을 작성해 봅시다. 대략적으로 다음과 같은 로직을 원합니다:</p>
<pre><code class="language-text">if cap == 0:
    allocate()
    cap = 1
else:
    reallocate()
    cap *= 2
</code></pre>
<p>하지만 러스트에서 지원하는 유일한 할당자 API는 너무 저수준이라 꽤 많은 추가 작업을 해야 합니다. 또한 아주 큰 할당이나 빈 할당에서 발생할 수 있는 몇 가지 특별한 상황에 대해서도 대비해야 합니다.</p>
<p>특히 <code>ptr::offset</code>은 우리에게 많은 문제를 일으킬 것입니다. 이는 LLVM의 GEP inbounds 명령어의 의미론을 가지고 있기 때문입니다. 만약 이 명령어를 다뤄보지 않은 행운아라면, GEP에 대한 기본적인 이야기는 이렇습니다: 별칭 분석(alias analysis), 별칭 분석, 그리고 별칭 분석입니다. 최적화 컴파일러가 데이터 의존성과 별칭에 대해 추론할 수 있는 능력은 매우 중요합니다.</p>
<p>간단한 예로, 다음 코드 조각을 고려해 보십시오:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">*x *= 7;
*y *= 3;</code></pre>
<p>만약 컴파일러가 <code>x</code>와 <code>y</code>가 메모리의 서로 다른 위치를 가리키고 있음을 증명할 수 있다면, 이론적으로 두 연산은 (예를 들어 서로 다른 레지스터에 로드하여 독립적으로 작업함으로써) 병렬로 실행될 수 있습니다. 하지만 일반적인 상황에서 컴파일러는 이를 수행할 수 없습니다. x와 y가 메모리의 동일한 위치를 가리킨다면, 연산이 동일한 값에 대해 수행되어야 하며 나중에 단순히 병합될 수 없기 때문입니다.</p>
<p>GEP inbounds를 사용할 때, 당신은 수행하려는 오프셋이 단일 "할당된" 개체의 범위 내에 있음을 LLVM에 명시적으로 알리는 것입니다. 그 결과로 얻는 궁극적인 이득은, 두 포인터가 서로 겹치지 않는 두 객체를 가리키는 것으로 알려져 있다면 LLVM이 그 포인터들의 모든 오프셋 또한 서로 별칭되지 않는다고 가정할 수 있다는 점입니다 (메모리의 엉뚱한 곳에 도달하지 않을 것이기 때문입니다). LLVM은 GEP 오프셋 작업에 고도로 최적화되어 있으며, 그중에서도 inbounds 오프셋이 가장 뛰어나므로 가능한 한 많이 사용하는 것이 중요합니다.</p>
<p>이것이 GEP에 대한 이야기입니다. 그렇다면 이것이 어떻게 우리에게 문제를 일으킬 수 있을까요?</p>
<p>첫 번째 문제는 우리가 배열을 인덱싱할 때는 부호 없는 정수(unsigned integers)를 사용하지만, GEP(결과적으로 <code>ptr::offset</code>)는 부호 있는 정수(signed integer)를 받는다는 점입니다. 이는 겉보기에 유효해 보이는 배열 인덱스의 절반이 GEP에서 오버플로를 일으켜 실제로는 엉뚱한 방향으로 가게 된다는 것을 의미합니다! 따라서 모든 할당을 <code>isize::MAX</code>개 요소로 제한해야 합니다. 이는 사실 바이트 크기 객체들에 대해서만 걱정하면 된다는 뜻이기도 합니다. 예를 들어 <code>isize::MAX</code>를 넘어서는 개수의 <code>u16</code>은 시스템의 모든 메모리를 고갈시킬 것이기 때문입니다. 하지만 누군가 <code>isize::MAX</code>개 미만의 객체 배열을 바이트 단위로 재해석하는 미묘한 예외 상황을 방지하기 위해, 표준 라이브러리(std)는 모든 할당을 <code>isize::MAX</code> 바이트로 제한합니다.</p>
<p>현재 러스트가 지원하는 모든 64비트 타겟에서 우리는 인위적으로 64비트 주소 공간 전체보다 훨씬 적은 공간으로 제한되어 있습니다(현대적인 x64 플랫폼은 48비트 주소 지정만 노출함). 따라서 메모리가 먼저 고갈될 것이라고 믿어도 좋습니다. 하지만 32비트 타겟, 특히 주소 공간을 더 많이 사용하기 위한 확장 기능(PAE x86 또는 x32)이 있는 경우에는 이론적으로 <code>isize::MAX</code> 바이트를 넘는 메모리를 성공적으로 할당하는 것이 가능할 수 있습니다.</p>
<p>하지만 이것은 튜토리얼이므로, 영리한 플랫폼별 <code>cfg</code>를 사용하기보다는 여기서 특별히 최적화하지 않고 무조건적으로 체크하도록 하겠습니다.</p>
<p>우리가 걱정해야 할 또 다른 예외 상황은 빈 할당(empty allocations)입니다. 걱정해야 할 빈 할당에는 두 가지 종류가 있습니다: 모든 T에 대해 <code>cap = 0</code>인 경우와, 크기가 0인 타입에 대해 <code>cap &gt; 0</code>인 경우입니다.</p>
<p>이러한 경우들이 까다로운 이유는 LLVM이 말하는 "할당됨(allocated)"이 무엇을 의미하는지에 달려 있기 때문입니다. LLVM의 할당 개념은 우리가 평소에 사용하는 것보다 훨씬 더 추상적입니다. LLVM은 다양한 언어의 의미론 및 사용자 정의 할당자와 연동되어야 하므로, 할당을 아주 상세하게 이해할 수는 없습니다. 대신 할당의 주요 개념은 "다른 것과 겹치지 않는다"는 것입니다. 즉, 힙 할당, 스택 할당, 전역 변수들이 무작위로 겹치지 않는다는 점입니다. 네, 바로 별칭 분석에 관한 이야기입니다. 따라서 러스트는 _일관성_만 유지된다면 기술적으로 할당의 개념을 조금 느슨하게 다룰 수 있습니다.</p>
<p>빈 할당 사례로 돌아가서, 제네릭 코드의 결과로 0만큼 오프셋(offset)을 수행하려는 곳들이 몇 군데 있습니다. 그렇다면 질문은 이렇습니다: 그렇게 하는 것이 일관성이 있을까요? 크기가 0인 타입(ZST)의 경우, 임의의 개수만큼 GEP inbounds 오프셋을 수행하는 것이 실제로 일관성이 있다고 결론지었습니다. 모든 요소가 공간을 차지하지 않으므로 이는 런타임에 아무 작업도 수행하지 않으며(no-op), <code>0x01</code> 위치에 무한한 수의 ZST가 할당되어 있다고 가정해도 괜찮습니다. 어떤 할당자도 그 주소를 할당하지 않을 것입니다. 할당자는 <code>0x00</code>을 할당하지 않으며, 보통 1바이트보다 높은 최소 정렬 단위로 할당하기 때문입니다. 또한 일반적으로 메모리의 첫 번째 페이지 전체(많은 플랫폼에서 4k 전체)는 어차피 할당되지 않도록 보호됩니다.</p>
<p>하지만 크기가 0보다 큰 타입은 어떨까요? 그 경우는 조금 더 까다롭습니다. 원칙적으로 0만큼 오프셋하는 것은 LLVM에 아무런 정보도 주지 않는다고 주장할 수 있습니다: 주소 앞이나 뒤에 요소가 있을 수 있지만 어느 쪽인지 알 수 없기 때문입니다. 하지만 우리는 보수적으로 이것이 나쁜 영향을 줄 수 있다고 가정하기로 했습니다. 따라서 이 경우에 대해 명시적으로 대비할 것입니다.</p>
<p><em>휴우</em></p>
<p>좋습니다. 이제 부수적인 이야기들은 치워두고, 실제로 메모리를 할당해 봅시다:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">use std::alloc::{self, Layout};

impl&lt;T&gt; Vec&lt;T&gt; {
    fn grow(&amp;mut self) {
        let (new_cap, new_layout) = if self.cap == 0 {
            (1, Layout::array::&lt;T&gt;(1))
        } else {
            // self.cap &lt;= isize::MAX이므로 이는 오버플로할 수 없습니다.
            let new_cap = 2 * self.cap;
            (new_cap, Layout::array::&lt;T&gt;(new_cap))
        };

        // `Layout::array` checks that the number of bytes allocated is
        // in 1..=isize::MAX and will error otherwise.  An allocation of
        // 0 bytes isn't possible thanks to the above condition.
        let new_layout = new_layout.expect("할당이 너무 큼");

        let new_ptr = if self.cap == 0 {
            unsafe { alloc::alloc(new_layout) }
        } else {
            let old_layout = Layout::array::&lt;T&gt;(self.cap).unwrap();
            let old_ptr = self.ptr.as_ptr() as *mut u8;
            unsafe { alloc::realloc(old_ptr, old_layout, new_layout.size()) }
        };

        // 할당이 실패하면 `new_ptr`은 null이 되며, 이 경우 프로그램을 중단(abort)합니다.
        self.ptr = match NonNull::new(new_ptr as *mut T) {
            Some(p) =&gt; p,
            None =&gt; alloc::handle_alloc_error(new_layout),
        };
        self.cap = new_cap;
    }
}
<span class="boring">fn main() {}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="푸시와-팝"><a class="header" href="#푸시와-팝">푸시와 팝</a></h1>
<p>좋습니다. 초기화도 할 수 있고, 할당도 할 수 있습니다. 이제 실제 기능을 몇 가지 구현해 봅시다! <code>push</code>부터 시작하겠습니다. <code>push</code>가 해야 할 일은 용량이 가득 찼는지 확인하여 늘리고, 다음 인덱스에 무조건 값을 쓰고, 길이를 증가시키는 것뿐입니다.</p>
<p>값을 쓸 때는 우리가 쓰려는 메모리를 평가(evaluate)하지 않도록 주의해야 합니다. 최악의 경우 그곳은 할당자로부터 받은 정말로 초기화되지 않은 메모리일 것이고, 운이 좋아도 이전에 꺼낸(popped) 어떤 오래된 값의 비트들이 남아 있을 것입니다. 어느 쪽이든, 단순히 메모리를 인덱싱하고 역참조할 수는 없습니다. 그렇게 하면 해당 메모리를 T의 유효한 인스턴스로 평가하려고 하기 때문입니다. 더 나쁜 것은, <code>foo[idx] = x</code>와 같은 식은 <code>foo[idx]</code>의 이전 값에 대해 <code>drop</code>을 호출하려고 시도할 것입니다!</p>
<p>이를 수행하는 올바른 방법은 <code>ptr::write</code>를 사용하는 것입니다. 이 함수는 우리가 제공한 값의 비트로 대상 주소를 무작정 덮어씁니다. 이 과정에는 어떤 평가도 개입하지 않습니다.</p>
<p><code>push</code>의 경우, (push를 호출하기 전의) 이전 길이가 0이라면 0번째 인덱스에 값을 쓰고 싶을 것입니다. 따라서 이전 길이만큼 오프셋(offset)해야 합니다.</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">pub fn push(&amp;mut self, elem: T) {
    if self.len == self.cap { self.grow(); }

    unsafe {
        ptr::write(self.ptr.as_ptr().add(self.len), elem);
    }

    // 실패할 수 없습니다. 실패하기 전에 메모리 부족(OOM)이 발생할 것입니다.
    self.len += 1;
}</code></pre>
<p>간단하죠! <code>pop</code>은 어떨까요? 이번에는 접근하려는 인덱스가 초기화되어 있지만, 러스트는 단순히 메모리 위치를 역참조해서 값을 꺼내오게 두지 않을 것입니다. 그렇게 하면 해당 메모리가 초기화되지 않은 상태로 남기 때문입니다! 이를 위해 우리는 <code>ptr::read</code>가 필요합니다. 이 함수는 단순히 대상 주소에서 비트들을 복사해서 T 타입의 값으로 해석합니다. 이는 사실 해당 주소에 완벽하게 유효한 T의 인스턴스가 있음에도 불구하고, 그 위치의 메모리를 논리적으로 초기화되지 않은 상태로 남깁니다.</p>
<p><code>pop</code>의 경우, 예를 들어 이전 길이가 1이라면 0번째 인덱스에서 값을 읽어오고 싶을 것입니다. 따라서 새로운 길이만큼 오프셋해야 합니다.</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
    if self.len == 0 {
        None
    } else {
        self.len -= 1;
        unsafe {
            Some(ptr::read(self.ptr.as_ptr().add(self.len)))
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="할당-해제"><a class="header" href="#할당-해제">할당 해제</a></h1>
<p>다음으로, 엄청난 양의 자원을 누수하지 않도록 Drop을 구현해야 합니다. 가장 쉬운 방법은 <code>pop</code>이 None을 반환할 때까지 계속 호출한 다음, 버퍼를 할당 해제하는 것입니다. 만약 <code>T: !Drop</code>이라면 <code>pop</code>을 호출할 필요가 없다는 점에 유의하십시오. 이론적으로는 러스트에게 <code>T</code>가 <code>needs_drop</code>인지 물어보고 <code>pop</code> 호출을 생략할 수 있습니다. 하지만 실제로는 LLVM이 이와 같이 단순하고 부작용 없는 코드를 제거하는 데 <em>정말로</em> 능숙하므로, 코드가 제거되지 않는다는 것을 발견하지 않는 한 굳이 신경 쓰지 않아도 됩니다 (이 경우에는 제거됩니다).</p>
<p><code>self.cap == 0</code>일 때는 <code>alloc::dealloc</code>을 호출해서는 안 됩니다. 이 경우에는 실제로 어떤 메모리도 할당하지 않았기 때문입니다.</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">impl&lt;T&gt; Drop for Vec&lt;T&gt; {
    fn drop(&amp;mut self) {
        if self.cap != 0 {
            while let Some(_) = self.pop() { }
            let layout = Layout::array::&lt;T&gt;(self.cap).unwrap();
            unsafe {
                alloc::dealloc(self.ptr.as_ptr() as *mut u8, layout);
            }
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="역참조"><a class="header" href="#역참조">역참조</a></h1>
<p>좋습니다! 이제 꽤 괜찮은 최소한의 스택이 구현되었습니다. 우리는 push와 pop을 할 수 있고, 뒷정리도 할 수 있습니다. 하지만 우리가 원할 법한 기능들이 아직 많이 남아 있습니다. 특히, 우리는 제대로 된 배열을 가지고 있지만 슬라이스(slice) 기능은 전혀 없습니다. 이는 사실 꽤 쉽게 해결할 수 있습니다: <code>Deref&lt;Target=[T]&gt;</code>를 구현하면 됩니다. 이렇게 하면 우리 Vec은 온갖 상황에서 마법처럼 슬라이스로 강제 변환(coerce)되고 슬라이스처럼 동작하게 될 것입니다.</p>
<p>우리에게 필요한 것은 <code>slice::from_raw_parts</code>뿐입니다. 이 함수는 빈 슬라이스를 올바르게 처리해 줍니다. 나중에 크기가 0인 타입(ZST) 지원을 설정하면 그것들에 대해서도 그냥 잘 작동할 것입니다.</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">use std::ops::Deref;

impl&lt;T&gt; Deref for Vec&lt;T&gt; {
    type Target = [T];
    fn deref(&amp;self) -&gt; &amp;[T] {
        unsafe {
            std::slice::from_raw_parts(self.ptr.as_ptr(), self.len)
        }
    }
}</code></pre>
<p>DerefMut도 구현해 봅시다:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">use std::ops::DerefMut;

impl&lt;T&gt; DerefMut for Vec&lt;T&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut [T] {
        unsafe {
            std::slice::from_raw_parts_mut(self.ptr.as_ptr(), self.len)
        }
    }
}</code></pre>
<p>이제 우리는 <code>len</code>, <code>first</code>, <code>last</code>, 인덱싱, 슬라이싱, 정렬, <code>iter</code>, <code>iter_mut</code> 등 슬라이스가 제공하는 온갖 부가 기능들을 사용할 수 있게 되었습니다. 멋지네요!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="삽입과-제거"><a class="header" href="#삽입과-제거">삽입과 제거</a></h1>
<p>슬라이스에서 제공하지 <em>않는</em> 기능은 <code>insert</code>와 <code>remove</code>입니다. 다음으로 이것들을 구현해 봅시다.</p>
<p>Insert는 대상 인덱스에 있는 모든 요소를 오른쪽으로 한 칸씩 이동시켜야 합니다. 이를 위해 우리는 C의 <code>memmove</code>에 해당하는 <code>ptr::copy</code>를 사용해야 합니다. 이 함수는 메모리 덩어리를 한 위치에서 다른 위치로 복사하며, 원본과 대상이 겹치는 경우(여기서는 반드시 발생합니다)를 올바르게 처리합니다.</p>
<p>인덱스 <code>i</code>에 삽입한다면, 이전 길이를 사용하여 <code>[i .. len]</code> 범위를 <code>[i+1 .. len+1]</code> 위치로 이동시키고 싶을 것입니다.</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">pub fn insert(&amp;mut self, index: usize, elem: T) {
    // 참고: 모든 요소 다음에 삽입하는 것도 유효하므로 `&lt;=`를 사용합니다.
    // 이는 push와 동일한 동작이 됩니다.
    assert!(index &lt;= self.len, "인덱스 범위를 벗어남");
    if self.len == self.cap { self.grow(); }

    unsafe {
        // ptr::copy(src, dest, len): "src에서 dest로 len개의 요소를 복사"
        ptr::copy(
            self.ptr.as_ptr().add(index),
            self.ptr.as_ptr().add(index + 1),
            self.len - index,
        );
        ptr::write(self.ptr.as_ptr().add(index), elem);
    }

    self.len += 1;
}</code></pre>
<p>Remove는 반대로 동작합니다. 우리는 <em>새로운</em> 길이를 사용하여 <code>[i+1 .. len+1]</code> 범위의 모든 요소를 <code>[i .. len]</code> 위치로 이동시켜야 합니다.</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">pub fn remove(&amp;mut self, index: usize) -&gt; T {
    // 참고: 모든 요소 다음의 위치를 삭제하는 것은 유효하지 않으므로 `&lt;`를 사용합니다.
    assert!(index &lt; self.len, "인덱스 범위를 벗어남");
    unsafe {
        self.len -= 1;
        let result = ptr::read(self.ptr.as_ptr().add(index));
        ptr::copy(
            self.ptr.as_ptr().add(index + 1),
            self.ptr.as_ptr().add(index),
            self.len - index,
        );
        result
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intoiter"><a class="header" href="#intoiter">IntoIter</a></h1>
<p>이제 반복자(iterator)를 작성해 봅시다. <code>iter</code>와 <code>iter_mut</code>는 Deref의 마법 덕분에 이미 작성된 것이나 다름없습니다. 하지만 슬라이스는 제공할 수 없지만 Vec은 제공하는 두 가지 흥미로운 반복자가 있습니다: <code>into_iter</code>와 <code>drain</code>입니다.</p>
<p>IntoIter는 Vec을 값으로 소비(consume)하며, 결과적으로 그 요소들을 값으로 생성할 수 있습니다. 이를 가능하게 하기 위해, IntoIter는 Vec의 할당에 대한 제어권을 가져와야 합니다.</p>
<p>IntoIter는 양쪽 끝에서 읽을 수 있도록 DoubleEnded여야 합니다. 뒤에서부터 읽는 것은 단순히 <code>pop</code>을 호출하는 것으로 구현할 수 있지만, 앞에서부터 읽는 것은 더 어렵습니다. <code>remove(0)</code>을 호출할 수도 있겠지만, 이는 매우 비효율적일 것입니다. 대신 우리는 <code>ptr::read</code>를 사용하여 버퍼를 전혀 변경하지 않고 Vec의 양쪽 끝에서 값을 복사해올 것입니다.</p>
<p>이를 위해 우리는 배열 반복에 매우 흔히 쓰이는 C의 관용구를 사용할 것입니다. 두 개의 포인터를 만들 것입니다. 하나는 배열의 시작을 가리키고, 다른 하나는 배열의 끝에서 한 요소 다음을 가리킵니다. 한쪽 끝에서 요소를 원할 때마다, 해당 끝이 가리키는 값을 읽어오고 포인터를 한 칸 이동시킵니다. 두 포인터가 같아지면 모든 작업이 끝난 것입니다.</p>
<p><code>next</code>와 <code>next_back</code>에서 읽기와 오프셋의 순서가 반대임에 유의하십시오. <code>next_back</code>의 경우 포인터는 항상 다음에 읽으려는 요소 뒤에 위치하는 반면, <code>next</code>의 경우 포인터는 항상 다음에 읽으려는 요소 위에 위치합니다. 왜 그런지 이해하기 위해, 단 하나의 요소만 남고 나머지는 모두 생성된 경우를 생각해 보십시오.</p>
<p>배열은 다음과 같은 모습일 것입니다:</p>
<pre><code class="language-text">          S  E
[X, X, X, O, X, X, X]
</code></pre>
<p>만약 E가 다음에 생성할 요소를 직접 가리키고 있다면, 더 이상 생성할 요소가 없는 경우와 구별할 수 없게 될 것입니다.</p>
<p>반복 과정 중에는 실제로 필요하지 않지만, IntoIter가 드롭될 때 메모리를 해제하기 위해 Vec의 할당 정보도 계속 유지해야 합니다.</p>
<p>따라서 우리는 다음과 같은 구조체를 사용할 것입니다:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">pub struct IntoIter&lt;T&gt; {
    buf: NonNull&lt;T&gt;,
    cap: usize,
    start: *const T,
    end: *const T,
}</code></pre>
<p>그리고 초기화 코드는 다음과 같습니다:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">impl&lt;T&gt; IntoIterator for Vec&lt;T&gt; {
    type Item = T;
    type IntoIter = IntoIter&lt;T&gt;;
    fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        // Vec을 드롭하지 않도록 주의하십시오. 버퍼가 해제될 수 있습니다.
        let vec = ManuallyDrop::new(self);

        // Vec은 Drop을 구현하므로 구조 해체(destructure)할 수 없습니다.
        let ptr = vec.ptr;
        let cap = vec.cap;
        let len = vec.len;

        IntoIter {
            buf: ptr,
            cap,
            start: ptr.as_ptr(),
            end: if cap == 0 {
                // 이 포인터로부터 오프셋을 할당할 수 없습니다. 할당된 메모리가 아닙니다!
                ptr.as_ptr()
            } else {
                unsafe { ptr.as_ptr().add(len) }
            },
        }
    }
}</code></pre>
<p>다음은 정방향 반복입니다:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.start == self.end {
            None
        } else {
            unsafe {
                let result = ptr::read(self.start);
                self.start = self.start.offset(1);
                Some(result)
            }
        }
    }

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        let len = (self.end as usize - self.start as usize)
                  / mem::size_of::&lt;T&gt;();
        (len, Some(len))
    }
}</code></pre>
<p>그리고 다음은 역방향 반복입니다.</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">impl&lt;T&gt; DoubleEndedIterator for IntoIter&lt;T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.start == self.end {
            None
        } else {
            unsafe {
                self.end = self.end.offset(-1);
                Some(ptr::read(self.end))
            }
        }
    }
}</code></pre>
<p>IntoIter는 할당에 대한 소유권을 가지므로, 메모리를 해제하기 위해 Drop을 구현해야 합니다. 또한 아직 생성되지 않은 상태로 남아 있는 요소들을 드롭하기 위해서도 Drop 구현이 필요합니다.</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">impl&lt;T&gt; Drop for IntoIter&lt;T&gt; {
    fn drop(&amp;mut self) {
        if self.cap != 0 {
            // 남은 요소들을 드롭합니다.
            for _ in &amp;mut *self {}
            let layout = Layout::array::&lt;T&gt;(self.cap).unwrap();
            unsafe {
                alloc::dealloc(self.buf.as_ptr() as *mut u8, layout);
            }
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rawvec"><a class="header" href="#rawvec">RawVec</a></h1>
<p>여기서 흥미로운 상황에 도달했습니다. Vec과 IntoIter 모두에서 버퍼를 지정하고 그 메모리를 해제하는 로직이 중복되었습니다. 이제 구현을 완료하고 실제로 로직이 중복된다는 점을 확인했으니, 로직을 압축할 좋은 시기입니다.</p>
<p>우리는 <code>(ptr, cap)</code> 쌍을 추상화하여, 할당, 확장, 해제 로직을 부여할 것입니다.</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">struct RawVec&lt;T&gt; {
    ptr: NonNull&lt;T&gt;,
    cap: usize,
}

unsafe impl&lt;T: Send&gt; Send for RawVec&lt;T&gt; {}
unsafe impl&lt;T: Sync&gt; Sync for RawVec&lt;T&gt; {}

impl&lt;T&gt; RawVec&lt;T&gt; {
    fn new() -&gt; Self {
        assert!(mem::size_of::&lt;T&gt;() != 0, "TODO: ZST 지원 구현");
        RawVec {
            ptr: NonNull::dangling(),
            cap: 0,
        }
    }

    fn grow(&amp;mut self) {
        // self.cap &lt;= isize::MAX임을 보장하므로 오버플로할 수 없습니다.
        let new_cap = if self.cap == 0 { 1 } else { 2 * self.cap };

        // Layout::array는 바이트 수가 usize::MAX 이하인지 확인하지만,
        // old_layout.size() &lt;= isize::MAX이므로 이는 중복 확인입니다.
        // 따라서 `unwrap`은 절대 실패하지 않아야 합니다.
        let new_layout = Layout::array::&lt;T&gt;(new_cap).unwrap();

        // 새로운 할당이 `isize::MAX` 바이트를 초과하지 않도록 보장합니다.
        assert!(new_layout.size() &lt;= isize::MAX as usize, "할당이 너무 큼");

        let new_ptr = if self.cap == 0 {
            unsafe { alloc::alloc(new_layout) }
        } else {
            let old_layout = Layout::array::&lt;T&gt;(self.cap).unwrap();
            let old_ptr = self.ptr.as_ptr() as *mut u8;
            unsafe { alloc::realloc(old_ptr, old_layout, new_layout.size()) }
        };

        // 할당이 실패하면 `new_ptr`은 null이 되며, 이 경우 프로그램을 중단(abort)합니다.
        self.ptr = match NonNull::new(new_ptr as *mut T) {
            Some(p) =&gt; p,
            None =&gt; alloc::handle_alloc_error(new_layout),
        };
        self.cap = new_cap;
    }
}

impl&lt;T&gt; Drop for RawVec&lt;T&gt; {
    fn drop(&amp;mut self) {
        if self.cap != 0 {
            let layout = Layout::array::&lt;T&gt;(self.cap).unwrap();
            unsafe {
                alloc::dealloc(self.ptr.as_ptr() as *mut u8, layout);
            }
        }
    }
}</code></pre>
<p>그리고 Vec을 다음과 같이 변경합니다:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">pub struct Vec&lt;T&gt; {
    buf: RawVec&lt;T&gt;,
    len: usize,
}

impl&lt;T&gt; Vec&lt;T&gt; {
    fn ptr(&amp;self) -&gt; *mut T {
        self.buf.ptr.as_ptr()
    }

    fn cap(&amp;self) -&gt; usize {
        self.buf.cap
    }

    pub fn new() -&gt; Self {
        Vec {
            buf: RawVec::new(),
            len: 0,
        }
    }

    // push/pop/insert/remove는 거의 변하지 않았습니다:
    // * `self.ptr.as_ptr() -&gt; self.ptr()`
    // * `self.cap -&gt; self.cap()`
    // * `self.grow() -&gt; self.buf.grow()`
}

impl&lt;T&gt; Drop for Vec&lt;T&gt; {
    fn drop(&amp;mut self) {
        while let Some(_) = self.pop() {}
        // 할당 해제는 RawVec에 의해 처리됩니다.
    }
}</code></pre>
<p>마지막으로 IntoIter를 정말로 단순화할 수 있습니다:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">pub struct IntoIter&lt;T&gt; {
    _buf: RawVec&lt;T&gt;, // 우리는 사실 이것에 신경 쓰지 않습니다. 그저 존재하기만 하면 됩니다.
    start: *const T,
    end: *const T,
}

// next와 next_back은 buf를 참조하지 않았으므로 문자 그대로 변하지 않았습니다.

impl&lt;T&gt; Drop for IntoIter&lt;T&gt; {
    fn drop(&amp;mut self) {
        // 모든 요소가 읽혔는지만 확인하면 됩니다.
        // 버퍼는 나중에 스스로 정리될 것입니다.
        for _ in &amp;mut *self {}
    }
}

impl&lt;T&gt; IntoIterator for Vec&lt;T&gt; {
    type Item = T;
    type IntoIter = IntoIter&lt;T&gt;;
    fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        // buf는 Copy가 아니고 Vec은 Drop을 구현하므로 (구조 해체할 수 없음),
        // ptr::read를 사용하여 비안전하게 buf를 꺼내와야 합니다.
        let buf = unsafe { ptr::read(&amp;self.buf) };
        let len = self.len;
        mem::forget(self);

        IntoIter {
            start: buf.ptr.as_ptr(),
            end: if buf.cap == 0 {
                // 할당된 부분의 일부가 아니라면 포인터에서 오프셋을 계산할 수 없습니다.
                buf.ptr.as_ptr()
            } else {
                unsafe { buf.ptr.as_ptr().add(len) }
            },
            _buf: buf,
        }
    }
}</code></pre>
<p>훨씬 낫네요.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="드레인-1"><a class="header" href="#드레인-1">드레인</a></h1>
<p>이제 Drain으로 넘어가 봅시다. Drain은 IntoIter와 거의 동일하지만, Vec을 소비하는 대신 대여(borrow)하며 할당된 메모리를 그대로 둡니다. 우선은 가장 기본적인 전체 범위 버전을 구현해 보겠습니다.</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">use std::marker::PhantomData;

struct Drain&lt;'a, T: 'a&gt; {
    // 여기서 수명을 제한해야 하므로, 의미론적으로 우리가 포함하고 있는
    // `&amp;'a mut Vec&lt;T&gt;`를 사용합니다. 우리는 그저 `pop()`과 `remove(0)`을
    // 호출할 뿐입니다.
    vec: PhantomData&lt;&amp;'a mut Vec&lt;T&gt;&gt;,
    start: *const T,
    end: *const T,
}

impl&lt;'a, T&gt; Iterator for Drain&lt;'a, T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.start == self.end {
            None</code></pre>
<p>잠깐만요, 이거 좀 익숙해 보이네요. 좀 더 압축해 봅시다. IntoIter와 Drain은 완전히 동일한 구조를 가지고 있으니, 그냥 따로 분리해 냅시다.</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">struct RawValIter&lt;T&gt; {
    start: *const T,
    end: *const T,
}

impl&lt;T&gt; RawValIter&lt;T&gt; {
    // 연관된 수명이 없으므로 생성하기에 안전하지 않습니다.
    // 이는 RawValIter를 실제 할당된 것과 동일한 구조체에 저장하기 위해
    // 필요합니다. 내부 구현 세부 사항이므로 괜찮습니다.
    unsafe fn new(slice: &amp;[T]) -&gt; Self {
        RawValIter {
            start: slice.as_ptr(),
            end: if slice.len() == 0 {
                // `len = 0`이면 실제로는 할당된 메모리가 아닙니다.
                // GEP를 통해 LLVM에 잘못된 정보를 줄 수 있으므로
                // 오프셋을 계산하는 것을 피해야 합니다.
                slice.as_ptr()
            } else {
                slice.as_ptr().add(slice.len())
            }
        }
    }
}

// Iterator 및 DoubleEndedIterator 구현은 IntoIter와 동일합니다.</code></pre>
<p>그리고 IntoIter는 다음과 같이 바뀝니다:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">pub struct IntoIter&lt;T&gt; {
    _buf: RawVec&lt;T&gt;, // 우리는 사실 이것에 신경 쓰지 않습니다. 그저 존재하기만 하면 됩니다.
    iter: RawValIter&lt;T&gt;,
}

impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;T&gt; { self.iter.next() }
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) { self.iter.size_hint() }
}

impl&lt;T&gt; DoubleEndedIterator for IntoIter&lt;T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;T&gt; { self.iter.next_back() }
}

impl&lt;T&gt; Drop for IntoIter&lt;T&gt; {
    fn drop(&amp;mut self) {
        for _ in &amp;mut *self {}
    }
}

impl&lt;T&gt; IntoIterator for Vec&lt;T&gt; {
    type Item = T;
    type IntoIter = IntoIter&lt;T&gt;;
    fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        unsafe {
            let iter = RawValIter::new(&amp;self);

            let buf = ptr::read(&amp;self.buf);
            mem::forget(self);

            IntoIter {
                iter,
                _buf: buf,
            }
        }
    }
}</code></pre>
<p>Drain이 임의의 하위 범위와 작동하도록 업그레이드하기 쉽게 만들기 위해, 이 디자인에 몇 가지 독특한 점들을 남겨두었습니다. 특히 RawValIter가 드롭될 때 스스로를 비우도록(drain) 할 수도 있었지만, 더 복잡한 Drain에서는 제대로 작동하지 않을 것입니다. 또한 Drain 초기화를 단순화하기 위해 슬라이스를 받습니다.</p>
<p>좋습니다, 이제 Drain은 정말 간단합니다:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">use std::marker::PhantomData;

pub struct Drain&lt;'a, T: 'a&gt; {
    vec: PhantomData&lt;&amp;'a mut Vec&lt;T&gt;&gt;,
    iter: RawValIter&lt;T&gt;,
}

impl&lt;'a, T&gt; Iterator for Drain&lt;'a, T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;T&gt; { self.iter.next() }
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) { self.iter.size_hint() }
}

impl&lt;'a, T&gt; DoubleEndedIterator for Drain&lt;'a, T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;T&gt; { self.iter.next_back() }
}

impl&lt;'a, T&gt; Drop for Drain&lt;'a, T&gt; {
    fn drop(&amp;mut self) {
        for _ in &amp;mut *self {}
    }
}

impl&lt;T&gt; Vec&lt;T&gt; {
    pub fn drain(&amp;mut self) -&gt; Drain&lt;T&gt; {
        let iter = unsafe { RawValIter::new(&amp;self) };

        // 이는 mem::forget에 대한 안전장치입니다. Drain이 잊혀지면(forgotten),
        // Vec의 전체 내용을 누수하게 됩니다. 어차피 언젠가는 이 작업을
        // 수행해야 하므로, 지금 하는 게 어떨까요?
        self.len = 0;

        Drain {
            iter,
            vec: PhantomData,
        }
    }
}</code></pre>
<p><code>mem::forget</code> 문제에 대한 자세한 내용은 <a href="vec/../leaking.html">누수 섹션</a>을 참조하십시오.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="크기-0-타입-처리"><a class="header" href="#크기-0-타입-처리">크기 0 타입 처리</a></h1>
<p>때가 되었습니다. 우리는 크기가 0인 타입(ZST)이라는 유령과 싸워볼 것입니다. 안전한 러스트는 이에 대해 전혀 신경 쓸 필요가 없지만, Vec은 원시 포인터와 원시 할당을 집중적으로 사용하며, 이 두 가지가 바로 ZST에 주의해야 할 것들입니다. 우리는 다음 두 가지를 조심해야 합니다:</p>
<ul>
<li>원시 할당자 API에 할당 크기로 0을 전달하면 정의되지 않은 동작(UB)이 발생합니다.</li>
<li>ZST에 대해 원시 포인터 오프셋 계산은 아무 일도 하지 않으므로(no-op), 우리의 C 스타일 포인터 반복자를 망가뜨릴 것입니다.</li>
</ul>
<p>다행히도 우리는 포인터 반복자와 할당 처리를 각각 <code>RawValIter</code>와 <code>RawVec</code>으로 추상화해 두었습니다. 참으로 신기할 정도로 편리하군요.</p>
<h2 id="크기가-0인-타입-할당하기"><a class="header" href="#크기가-0인-타입-할당하기">크기가 0인 타입 할당하기</a></h2>
<p>그렇다면 할당자 API가 0 크기 할당을 지원하지 않는다면, 도대체 할당된 메모리로 무엇을 저장해야 할까요? 당연히 <code>NonNull::dangling()</code>입니다! ZST는 정확히 하나의 값만 가지므로 거의 모든 연산이 아무 일도 하지 않으며, 따라서 이를 저장하거나 로드할 때 어떤 상태도 고려할 필요가 없습니다. 이는 사실 <code>ptr::read</code>와 <code>ptr::write</code>에도 해당됩니다. 이들은 포인터를 전혀 쳐다보지도 않을 것입니다. 따라서 우리는 포인터를 변경할 필요가 전혀 없습니다.</p>
<p>하지만 오버플로가 발생하기 전에 메모리가 먼저 고갈될 것이라는 이전의 믿음은 ZST에 대해서는 더 이상 유효하지 않음에 유의하십시오. 우리는 ZST에 대해 용량(capacity) 오버플로를 명시적으로 방지해야 합니다.</p>
<p>현재 우리의 구조 덕분에, <code>RawVec</code>의 각 메서드에 하나씩 총 3개의 방어 로직을 작성하기만 하면 됩니다.</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">impl&lt;T&gt; RawVec&lt;T&gt; {
    fn new() -&gt; Self {
        // 이 분기는 컴파일 타임에 제거되어야 합니다.
        let cap = if mem::size_of::&lt;T&gt;() == 0 { usize::MAX } else { 0 };

        // `NonNull::dangling()`은 "할당되지 않음"과 "0 크기 할당"의 두 가지 역할을 모두 수행합니다.
        RawVec {
            ptr: NonNull::dangling(),
            cap,
        }
    }

    fn grow(&amp;mut self) {
        // T의 크기가 0일 때 용량을 usize::MAX로 설정하므로,
        // 여기에 도달했다는 것은 반드시 Vec이 가득 찼음을 의미합니다.
        assert!(mem::size_of::&lt;T&gt;() != 0, "용량 오버플로");

        let (new_cap, new_layout) = if self.cap == 0 {
            (1, Layout::array::&lt;T&gt;(1).unwrap())
        } else {
            // self.cap &lt;= isize::MAX임을 보장하므로 오버플로할 수 없습니다.
            let new_cap = 2 * self.cap;

            // `Layout::array`는 바이트 수가 usize::MAX 이하인지 확인하지만,
            // old_layout.size() &lt;= isize::MAX이므로 이는 중복 확인입니다.
            // 따라서 `unwrap`은 절대 실패하지 않아야 합니다.
            let new_layout = Layout::array::&lt;T&gt;(new_cap).unwrap();
            (new_cap, new_layout)
        };

        // 새로운 할당이 `isize::MAX` 바이트를 초과하지 않도록 보장합니다.
        assert!(new_layout.size() &lt;= isize::MAX as usize, "할당이 너무 큼");

        let new_ptr = if self.cap == 0 {
            unsafe { alloc::alloc(new_layout) }
        } else {
            let old_layout = Layout::array::&lt;T&gt;(self.cap).unwrap();
            let old_ptr = self.ptr.as_ptr() as *mut u8;
            unsafe { alloc::realloc(old_ptr, old_layout, new_layout.size()) }
        };

        // 할당이 실패하면 `new_ptr`은 null이 되며, 이 경우 프로그램을 중단(abort)합니다.
        self.ptr = match NonNull::new(new_ptr as *mut T) {
            Some(p) =&gt; p,
            None =&gt; alloc::handle_alloc_error(new_layout),
        };
        self.cap = new_cap;
    }
}

impl&lt;T&gt; Drop for RawVec&lt;T&gt; {
    fn drop(&amp;mut self) {
        let elem_size = mem::size_of::&lt;T&gt;();

        if self.cap != 0 &amp;&amp; elem_size != 0 {
            unsafe {
                alloc::dealloc(
                    self.ptr.as_ptr() as *mut u8,
                    Layout::array::&lt;T&gt;(self.cap).unwrap(),
                );
            }
        }
    }
}</code></pre>
<p>됐습니다. 이제 크기가 0인 타입을 밀어 넣고(pushing) 뽑아내는(popping) 것이 가능해졌습니다. 하지만 슬라이스 Deref를 통해 제공되지 않는 우리의 반복자들은 여전히 고장 난 상태입니다.</p>
<h2 id="크기가-0인-타입-반복하기"><a class="header" href="#크기가-0인-타입-반복하기">크기가 0인 타입 반복하기</a></h2>
<p>크기가 0일 때 오프셋 계산은 아무 일도 하지 않습니다. 이는 우리의 현재 설계에서 <code>start</code>와 <code>end</code>가 항상 동일한 값으로 초기화되어, 반복자가 아무것도 생성하지 않을 것임을 의미합니다. 현재 이 문제에 대한 해결책은 포인터를 정수로 변환하여 증가시킨 뒤, 다시 포인터로 변환하는 것입니다.</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">impl&lt;T&gt; RawValIter&lt;T&gt; {
    unsafe fn new(slice: &amp;[T]) -&gt; Self {
        RawValIter {
            start: slice.as_ptr(),
            end: if mem::size_of::&lt;T&gt;() == 0 {
                ((slice.as_ptr() as usize) + slice.len()) as *const _
            } else if slice.len() == 0 {
                slice.as_ptr()
            } else {
                slice.as_ptr().add(slice.len())
            },
        }
    }
}</code></pre>
<p>이제 또 다른 버그가 생겼습니다. 반복자가 아예 실행되지 않는 대신, 이제는 <em>영원히</em> 실행됩니다. 우리는 반복자 구현에서도 동일한 기술을 써야 합니다. 또한, 우리의 <code>size_hint</code> 계산 코드는 ZST에 대해 0으로 나누기를 시도할 것입니다. 우리는 기본적으로 두 포인터를 바이트를 가리키는 것처럼 다룰 것이므로, 크기 0을 1로 나누도록 매핑할 것입니다. 다음은 <code>next</code>가 될 코드입니다:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
    if self.start == self.end {
        None
    } else {
        unsafe {
            let result = ptr::read(self.start);
            self.start = if mem::size_of::&lt;T&gt;() == 0 {
                (self.start as usize + 1) as *const _
            } else {
                self.start.offset(1)
            };
            Some(result)
        }
    }
}</code></pre>
<p>"버그"가 보이시나요? 아무도 못 봤을 겁니다! 원작자조차 몇 년 후에야 이 페이지에 링크를 걸다가 문제를 발견했습니다. 이 코드는 반복자 포인터를 _카운터_로 오용하여 포인터를 정렬되지 않은 상태로 만들기 때문에 다소 미심쩍습니다! ZST를 사용할 때 우리의 _유일한 임무_는 포인터를 정렬된 상태로 유지하는 것인데 말이죠! <em>이마를 탁 칩니다</em></p>
<p>원시 포인터가 항상 정렬되어 있을 필요는 없으므로, 포인터를 카운터로 사용하는 기본적인 기법은 <em>괜찮습니다</em>. 하지만 <code>ptr::read</code>에 전달될 때는 반드시 정렬되어 있어야 합니다! ZST에 대해 <code>ptr::read</code>는 아무 일도 하지 않으므로 이는 <em>아마도</em> 불필요한 세세함일 수 있지만, 조금 더 책임감을 가지고 ZST 경로에서는 <code>NonNull::dangling</code>에서 읽어오도록 합시다.</p>
<p>(또는 ZST 경로에서 <code>read_unaligned</code>를 호출할 수도 있습니다. 어느 쪽이든 괜찮습니다. 어차피 아무것도 없는 상태에서 값을 만들어내는 것이고, 결국 아무 일도 하지 않는 것으로 컴파일되기 때문입니다.)</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">impl&lt;T&gt; Iterator for RawValIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.start == self.end {
            None
        } else {
            unsafe {
                if mem::size_of::&lt;T&gt;() == 0 {
                    self.start = (self.start as usize + 1) as *const _;
                    Some(ptr::read(NonNull::&lt;T&gt;::dangling().as_ptr()))
                } else {
                    let old_ptr = self.start;
                    self.start = self.start.offset(1);
                    Some(ptr::read(old_ptr))
                }
            }
        }
    }

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        let elem_size = mem::size_of::&lt;T&gt;();
        let len = (self.end as usize - self.start as usize)
                  / if elem_size == 0 { 1 } else { elem_size };
        (len, Some(len))
    }
}

impl&lt;T&gt; DoubleEndedIterator for RawValIter&lt;T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.start == self.end {
            None
        } else {
            unsafe {
                if mem::size_of::&lt;T&gt;() == 0 {
                    self.end = (self.end as usize - 1) as *const _;
                    Some(ptr::read(NonNull::&lt;T&gt;::dangling().as_ptr()))
                } else {
                    self.end = self.end.offset(-1);
                    Some(ptr::read(self.end))
                }
            }
        }
    }
}</code></pre>
<p>이제 끝났습니다. 반복이 잘 작동합니다!</p>
<p>One last thing we need to consider is that when our vector is dropped, it deallocates the memory that was allocated while it was alive. With ZSTs, we didn't allocate any memory; in fact, we never do. So, right now, our code has unsoundness: we're still trying to deallocate a <code>NonNull::dangling()</code> pointer that we use to simulate the ZST in our vector. This means we'd cause undefined behavior if we tried to deallocate something we never allocated (obviously, and for good reasons). To fix this, in our <code>RawVec</code>'s <code>Drop</code> trait, we're going to tweak it to ensure we only deallocate types that are sized.</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Drop for RawVec&lt;T&gt; {
    fn drop(&amp;mut self) {
        println!("RawVec&lt;T&gt; Drop called, deallocating memory");
        if self.cap != 0 &amp;&amp; std::mem::size_of::&lt;T&gt;() &gt; 0 {
            let layout = std::alloc::Layout::array::&lt;T&gt;(self.cap).unwrap();
            unsafe {
                std::alloc::dealloc(self.ptr.as_ptr() as *mut _, layout);
            }
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="최종-코드"><a class="header" href="#최종-코드">최종 코드</a></h1>
<pre><pre class="playground"><code class="language-rust edition2024">use std::alloc::{self, Layout};
use std::marker::PhantomData;
use std::mem;
use std::ops::{Deref, DerefMut};
use std::ptr::{self, NonNull};

struct RawVec&lt;T&gt; {
    ptr: NonNull&lt;T&gt;,
    cap: usize,
}

unsafe impl&lt;T: Send&gt; Send for RawVec&lt;T&gt; {}
unsafe impl&lt;T: Sync&gt; Sync for RawVec&lt;T&gt; {}

impl&lt;T&gt; RawVec&lt;T&gt; {
    fn new() -&gt; Self {
        // !0은 usize::MAX입니다. 이 분기는 컴파일 타임에 제거되어야 합니다.
        let cap = if mem::size_of::&lt;T&gt;() == 0 { !0 } else { 0 };

        // `NonNull::dangling()`은 "할당되지 않음"과 "0 크기 할당"의 두 가지 역할을 모두 수행합니다.
        RawVec {
            ptr: NonNull::dangling(),
            cap,
        }
    }

    fn grow(&amp;mut self) {
        // T의 크기가 0일 때 용량을 usize::MAX로 설정하므로,
        // 여기에 도달했다는 것은 반드시 Vec이 가득 찼음을 의미합니다.
        assert!(mem::size_of::&lt;T&gt;() != 0, "용량 오버플로");

        let (new_cap, new_layout) = if self.cap == 0 {
            (1, Layout::array::&lt;T&gt;(1))
        } else {
            // self.cap &lt;= isize::MAX이므로 이는 오버플로할 수 없습니다.
            let new_cap = 2 * self.cap;
            (new_cap, Layout::array::&lt;T&gt;(new_cap))
        };

        // `Layout::array` checks that the number of bytes allocated is
        // in 1..=isize::MAX and will error otherwise.  An allocation of
        // 0 bytes isn't possible thanks to the above condition.
        let new_layout = new_layout.expect("할당이 너무 큼");

        let new_ptr = if self.cap == 0 {
            unsafe { alloc::alloc(new_layout) }
        } else {
            let old_layout = Layout::array::&lt;T&gt;(self.cap).unwrap();
            let old_ptr = self.ptr.as_ptr() as *mut u8;
            unsafe { alloc::realloc(old_ptr, old_layout, new_layout.size()) }
        };

        // 할당이 실패하면 `new_ptr`은 null이 되며, 이 경우 프로그램을 중단(abort)합니다.
        self.ptr = match NonNull::new(new_ptr as *mut T) {
            Some(p) =&gt; p,
            None =&gt; alloc::handle_alloc_error(new_layout),
        };
        self.cap = new_cap;
    }
}

impl&lt;T&gt; Drop for RawVec&lt;T&gt; {
    fn drop(&amp;mut self) {
        let elem_size = mem::size_of::&lt;T&gt;();

        if self.cap != 0 &amp;&amp; elem_size != 0 {
            unsafe {
                alloc::dealloc(
                    self.ptr.as_ptr() as *mut u8,
                    Layout::array::&lt;T&gt;(self.cap).unwrap(),
                );
            }
        }
    }
}

pub struct Vec&lt;T&gt; {
    buf: RawVec&lt;T&gt;,
    len: usize,
}

impl&lt;T&gt; Vec&lt;T&gt; {
    fn ptr(&amp;self) -&gt; *mut T {
        self.buf.ptr.as_ptr()
    }

    fn cap(&amp;self) -&gt; usize {
        self.buf.cap
    }

    pub fn new() -&gt; Self {
        Vec {
            buf: RawVec::new(),
            len: 0,
        }
    }
    pub fn push(&amp;mut self, elem: T) {
        if self.len == self.cap() {
            self.buf.grow();
        }

        unsafe {
            ptr::write(self.ptr().add(self.len), elem);
        }

        // 오버플로할 수 없습니다. 오버플로하기 전에 메모리 부족(OOM)이 발생할 것입니다.
        self.len += 1;
    }

    pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.len == 0 {
            None
        } else {
            self.len -= 1;
            unsafe { Some(ptr::read(self.ptr().add(self.len))) }
        }
    }

    pub fn insert(&amp;mut self, index: usize, elem: T) {
        assert!(index &lt;= self.len, "인덱스 범위를 벗어남");
        if self.len == self.cap() {
            self.buf.grow();
        }

        unsafe {
            ptr::copy(
                self.ptr().add(index),
                self.ptr().add(index + 1),
                self.len - index,
            );
            ptr::write(self.ptr().add(index), elem);
        }

        self.len += 1;
    }

    pub fn remove(&amp;mut self, index: usize) -&gt; T {
        assert!(index &lt; self.len, "인덱스 범위를 벗어남");

        self.len -= 1;

        unsafe {
            let result = ptr::read(self.ptr().add(index));
            ptr::copy(
                self.ptr().add(index + 1),
                self.ptr().add(index),
                self.len - index,
            );
            result
        }
    }

    pub fn drain(&amp;mut self) -&gt; Drain&lt;T&gt; {
        let iter = unsafe { RawValIter::new(&amp;self) };

        // 이는 mem::forget에 대한 안전장치입니다. Drain이 잊혀지면(forgotten),
        // Vec의 전체 내용을 누수하게 됩니다. 어차피 언젠가는 이 작업을
        // 수행해야 하므로, 지금 하는 게 어떨까요?
        self.len = 0;

        Drain {
            iter,
            vec: PhantomData,
        }
    }
}

impl&lt;T&gt; Drop for Vec&lt;T&gt; {
    fn drop(&amp;mut self) {
        while let Some(_) = self.pop() {}
        // 할당 해제는 RawVec에 의해 처리됩니다.
    }
}

impl&lt;T&gt; Deref for Vec&lt;T&gt; {
    type Target = [T];
    fn deref(&amp;self) -&gt; &amp;[T] {
        unsafe { std::slice::from_raw_parts(self.ptr(), self.len) }
    }
}

impl&lt;T&gt; DerefMut for Vec&lt;T&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut [T] {
        unsafe { std::slice::from_raw_parts_mut(self.ptr(), self.len) }
    }
}

impl&lt;T&gt; IntoIterator for Vec&lt;T&gt; {
    type Item = T;
    type IntoIter = IntoIter&lt;T&gt;;
    fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        let (iter, buf) = unsafe {
            (RawValIter::new(&amp;self), ptr::read(&amp;self.buf))
        };

        mem::forget(self);

        IntoIter {
            iter,
            _buf: buf,
        }
    }
}

struct RawValIter&lt;T&gt; {
    start: *const T,
    end: *const T,
}

impl&lt;T&gt; RawValIter&lt;T&gt; {
    unsafe fn new(slice: &amp;[T]) -&gt; Self {
        RawValIter {
            start: slice.as_ptr(),
            end: if mem::size_of::&lt;T&gt;() == 0 {
                ((slice.as_ptr() as usize) + slice.len()) as *const _
            } else if slice.len() == 0 {
                slice.as_ptr()
            } else {
                slice.as_ptr().add(slice.len())
            },
        }
    }
}

impl&lt;T&gt; Iterator for RawValIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.start == self.end {
            None
        } else {
            unsafe {
                if mem::size_of::&lt;T&gt;() == 0 {
                    self.start = (self.start as usize + 1) as *const _;
                    Some(ptr::read(NonNull::&lt;T&gt;::dangling().as_ptr()))
                } else {
                    let old_ptr = self.start;
                    self.start = self.start.offset(1);
                    Some(ptr::read(old_ptr))
                }
            }
        }
    }

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        let elem_size = mem::size_of::&lt;T&gt;();
        let len = (self.end as usize - self.start as usize)
                  / if elem_size == 0 { 1 } else { elem_size };
        (len, Some(len))
    }
}

impl&lt;T&gt; DoubleEndedIterator for RawValIter&lt;T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.start == self.end {
            None
        } else {
            unsafe {
                if mem::size_of::&lt;T&gt;() == 0 {
                    self.end = (self.end as usize - 1) as *const _;
                    Some(ptr::read(NonNull::&lt;T&gt;::dangling().as_ptr()))
                } else {
                    self.end = self.end.offset(-1);
                    Some(ptr::read(self.end))
                }
            }
        }
    }
}

pub struct IntoIter&lt;T&gt; {
    _buf: RawVec&lt;T&gt;, // 우리는 사실 이것에 신경 쓰지 않습니다. 그저 존재하기만 하면 됩니다.
    iter: RawValIter&lt;T&gt;,
}

impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.iter.next()
    }
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        self.iter.size_hint()
    }
}

impl&lt;T&gt; DoubleEndedIterator for IntoIter&lt;T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.iter.next_back()
    }
}

impl&lt;T&gt; Drop for IntoIter&lt;T&gt; {
    fn drop(&amp;mut self) {
        for _ in &amp;mut *self {}
    }
}

pub struct Drain&lt;'a, T: 'a&gt; {
    vec: PhantomData&lt;&amp;'a mut Vec&lt;T&gt;&gt;,
    iter: RawValIter&lt;T&gt;,
}

impl&lt;'a, T&gt; Iterator for Drain&lt;'a, T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.iter.next()
    }
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        self.iter.size_hint()
    }
}

impl&lt;'a, T&gt; DoubleEndedIterator for Drain&lt;'a, T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.iter.next_back()
    }
}

impl&lt;'a, T&gt; Drop for Drain&lt;'a, T&gt; {
    fn drop(&amp;mut self) {
        // 반복자를 미리 비웁니다(pre-drain).
        for _ in &amp;mut *self {}
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    tests::create_push_pop();
</span><span class="boring">    tests::iter_test();
</span><span class="boring">    tests::test_drain();
</span><span class="boring">    tests::test_zst();
</span><span class="boring">    println!("모든 테스트가 성공적으로 종료되었습니다");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn create_push_pop() {
</span><span class="boring">        let mut v = Vec::new();
</span><span class="boring">        v.push(1);
</span><span class="boring">        assert_eq!(1, v.len());
</span><span class="boring">        assert_eq!(1, v[0]);
</span><span class="boring">        for i in v.iter_mut() {
</span><span class="boring">            *i += 1;
</span><span class="boring">        }
</span><span class="boring">        v.insert(0, 5);
</span><span class="boring">        let x = v.pop();
</span><span class="boring">        assert_eq!(Some(2), x);
</span><span class="boring">        assert_eq!(1, v.len());
</span><span class="boring">        v.push(10);
</span><span class="boring">        let x = v.remove(0);
</span><span class="boring">        assert_eq!(5, x);
</span><span class="boring">        assert_eq!(1, v.len());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn iter_test() {
</span><span class="boring">        let mut v = Vec::new();
</span><span class="boring">        for i in 0..10 {
</span><span class="boring">            v.push(Box::new(i))
</span><span class="boring">        }
</span><span class="boring">        let mut iter = v.into_iter();
</span><span class="boring">        let first = iter.next().unwrap();
</span><span class="boring">        let last = iter.next_back().unwrap();
</span><span class="boring">        drop(iter);
</span><span class="boring">        assert_eq!(0, *first);
</span><span class="boring">        assert_eq!(9, *last);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn test_drain() {
</span><span class="boring">        let mut v = Vec::new();
</span><span class="boring">        for i in 0..10 {
</span><span class="boring">            v.push(Box::new(i))
</span><span class="boring">        }
</span><span class="boring">        {
</span><span class="boring">            let mut drain = v.drain();
</span><span class="boring">            let first = drain.next().unwrap();
</span><span class="boring">            let last = drain.next_back().unwrap();
</span><span class="boring">            assert_eq!(0, *first);
</span><span class="boring">            assert_eq!(9, *last);
</span><span class="boring">        }
</span><span class="boring">        assert_eq!(0, v.len());
</span><span class="boring">        v.push(Box::new(1));
</span><span class="boring">        assert_eq!(1, *v.pop().unwrap());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn test_zst() {
</span><span class="boring">        let mut v = Vec::new();
</span><span class="boring">        for _i in 0..10 {
</span><span class="boring">            v.push(())
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let mut count = 0;
</span><span class="boring">
</span><span class="boring">        for _ in v.into_iter() {
</span><span class="boring">            count += 1
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        assert_eq!(10, count);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arc와-mutex-구현하기"><a class="header" href="#arc와-mutex-구현하기">Arc와 Mutex 구현하기</a></h1>
<p>이론을 아는 것도 좋지만, 무언가를 이해하는 가장 좋은 방법은 직접 사용해 보는 것입니다. 아토믹(atomics)과 내부 가변성(interior mutability)을 더 잘 이해하기 위해, 우리는 표준 라이브러리의 <code>Arc</code>와 <code>Mutex</code> 타입을 직접 구현해 볼 것입니다.</p>
<p>TODO: <code>Mutex</code> 장 작성하기.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arc-구현하기"><a class="header" href="#arc-구현하기">Arc 구현하기</a></h1>
<p>이 섹션에서는 <code>std::sync::Arc</code>의 단순화된 버전을 구현해 볼 것입니다. 이전에 만든 <a href="arc-mutex/../vec/vec.html"><code>Vec</code> 구현</a>과 마찬가지로, 표준 라이브러리만큼 많은 최적화나 내장 함수(intrinsics), 또는 불안정한 코드를 활용하지는 않을 것입니다.</p>
<p>이 구현은 표준 라이브러리의 구현을 느슨하게 따릅니다(기술적으로는 실제 구현 위치인 1.49 버전의 <code>alloc::sync</code>에서 가져왔습니다). 하지만 약한 참조(weak references)는 구현을 다소 복잡하게 만들므로 현재로서는 지원하지 않을 것입니다.</p>
<p>이 섹션은 현재 활발히 작성 중인 내용임에 유의하십시오.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="레이아웃-1"><a class="header" href="#레이아웃-1">레이아웃</a></h1>
<p>먼저 우리가 구현할 <code>Arc</code>의 레이아웃을 만들어 봅시다.</p>
<p><code>Arc&lt;T&gt;</code>는 힙에 할당된 <code>T</code> 타입 값에 대한 스레드 안전한 공유 소유권을 제공합니다. 러스트에서 공유는 불변성을 의미하므로, 해당 값에 대한 접근을 관리하는 장치를 설계할 필요는 없겠죠? 비록 Mutex와 같은 내부 가변성 타입들이 Arc 사용자들에게 공유 가변성을 가능하게 해주지만, Arc 자체는 이러한 문제들에 관여할 필요가 없습니다.</p>
<p>하지만 Arc가 가변성에 관여해야 하는 곳이 딱 한 군데 있습니다: 바로 파괴(destruction) 시점입니다. Arc의 모든 소유자가 사라지면, 우리는 그 내용을 <code>drop</code>하고 할당된 메모리를 해제할 수 있어야 합니다. 따라서 소유자가 자신이 <em>마지막</em> 소유자인지 알 수 있는 방법이 필요하며, 이를 위한 가장 간단한 방법은 소유자의 수를 세는 것, 즉 참조 횟수 계산(Reference Counting)입니다.</p>
<p>불행히도 이 참조 횟수는 본질적으로 공유된 가변 상태이므로, Arc는 동기화에 대해 <em>반드시</em> 고민해야 합니다. 이를 위해 Mutex를 사용할 수도 있겠지만, 그건 너무 과합니다. 대신 우리는 아토믹(atomics)을 사용할 것입니다. 그리고 모든 소유자는 이미 T의 할당에 대한 포인터가 필요하므로, 참조 횟수도 동일한 할당 영역에 두는 것이 좋겠습니다.</p>
<p>단순하게 생각하면 다음과 같은 모습일 것입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic;

pub struct Arc&lt;T&gt; {
    ptr: *mut ArcInner&lt;T&gt;,
}

pub struct ArcInner&lt;T&gt; {
    rc: atomic::AtomicUsize,
    data: T,
}
<span class="boring">}</span></code></pre></pre>
<p>이렇게 작성해도 컴파일은 되겠지만, 올바르지 않습니다. 우선 컴파일러가 너무 엄격한 공변성(variance)을 부여할 것입니다. 예를 들어, <code>Arc&lt;&amp;'a str&gt;</code>이 예상되는 곳에 <code>Arc&lt;&amp;'static str&gt;</code>를 사용할 수 없게 됩니다. 더 중요한 점은, 드롭 검사기(drop checker)에게 잘못된 소유권 정보를 제공하게 된다는 것입니다. 컴파일러는 우리가 <code>T</code> 타입의 값을 소유하지 않는다고 가정할 것이기 때문입니다. 이 구조체는 값에 대한 공유 소유권을 제공하므로, 어느 시점에는 데이터를 완전히 소유하는 인스턴스가 존재하게 됩니다. 공변성과 드롭 검사에 대한 자세한 내용은 <a href="arc-mutex/../ownership.html">소유권과 수명 장</a>을 참조하십시오.</p>
<p>첫 번째 문제를 해결하기 위해 <code>NonNull&lt;T&gt;</code>를 사용할 수 있습니다. <code>NonNull&lt;T&gt;</code>는 다음을 선언하는 원시 포인터의 래퍼입니다:</p>
<ul>
<li>우리는 <code>T</code>에 대해 공변입니다</li>
<li>우리의 포인터는 절대 null이 아닙니다</li>
</ul>
<p>두 번째 문제를 해결하기 위해 <code>ArcInner&lt;T&gt;</code>를 포함하는 <code>PhantomData</code> 마커를 추가할 수 있습니다. 이는 드롭 검사기에게 우리가 <code>ArcInner&lt;T&gt;</code>(그 자체로 <code>T</code>를 포함함) 타입의 값을 소유하고 있다는 개념을 알려줍니다.</p>
<p>이러한 변경을 통해 최종적인 구조를 얻게 됩니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::marker::PhantomData;
use std::ptr::NonNull;
use std::sync::atomic::AtomicUsize;

pub struct Arc&lt;T&gt; {
    ptr: NonNull&lt;ArcInner&lt;T&gt;&gt;,
    phantom: PhantomData&lt;ArcInner&lt;T&gt;&gt;,
}

pub struct ArcInner&lt;T&gt; {
    rc: AtomicUsize,
    data: T,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="기본-코드"><a class="header" href="#기본-코드">기본 코드</a></h1>
<p>이제 <code>Arc</code> 구현을 위한 레이아웃을 결정했으니, 기본적인 코드를 만들어 봅시다.</p>
<h2 id="arc-생성하기"><a class="header" href="#arc-생성하기">Arc 생성하기</a></h2>
<p>먼저 <code>Arc&lt;T&gt;</code>를 생성하는 방법이 필요합니다.</p>
<p>이는 꽤 간단합니다. <code>ArcInner&lt;T&gt;</code>를 박스(box)에 넣고 그것에 대한 <code>NonNull&lt;T&gt;</code> 포인터를 얻기만 하면 됩니다.</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">impl&lt;T&gt; Arc&lt;T&gt; {
    pub fn new(data: T) -&gt; Arc&lt;T&gt; {
        // 첫 번째 참조가 현재 포인터이므로 참조 횟수를 1로 시작합니다.
        let boxed = Box::new(ArcInner {
            rc: AtomicUsize::new(1),
            data,
        });
        Arc {
            // It is okay to call `.unwrap()` here as we get a pointer from
            // `Box::into_raw` which is guaranteed to not be null.
            ptr: NonNull::new(Box::into_raw(boxed)).unwrap(),
            phantom: PhantomData,
        }
    }
}</code></pre>
<h2 id="send와-sync-1"><a class="header" href="#send와-sync-1">Send와 Sync</a></h2>
<p>우리는 동시성 기본 요소를 만들고 있으므로, 이를 스레드 간에 보낼 수 있어야 합니다. 따라서 우리는 <code>Send</code>와 <code>Sync</code> 마커 트레잇을 구현할 수 있습니다. 이에 대한 자세한 내용은 <a href="arc-mutex/../send-and-sync.html"><code>Send</code>와 <code>Sync</code> 섹션</a>을 참조하십시오.</p>
<p>이는 다음과 같은 이유로 괜찮습니다:</p>
<ul>
<li><code>Arc</code> 내부의 값에 대한 가변 참조를 얻는 것은 오직 해당 데이터를 참조하는 유일한 <code>Arc</code>일 때만 가능합니다 (이는 <code>Drop</code> 시에만 발생합니다).</li>
<li>공유된 가변 참조 횟수 계산을 위해 아토믹(atomics)을 사용합니다.</li>
</ul>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">unsafe impl&lt;T: Sync + Send&gt; Send for Arc&lt;T&gt; {}
unsafe impl&lt;T: Sync + Send&gt; Sync for Arc&lt;T&gt; {}</code></pre>
<p>우리는 <code>T: Sync + Send</code> 바운드가 필요합니다. 만약 이러한 바운드를 제공하지 않는다면, <code>Arc</code>를 통해 스레드에 안전하지 않은 값을 스레드 경계를 넘어 공유하는 것이 가능해지며, 이는 데이터 경쟁이나 불건전성을 초래할 수 있기 때문입니다.</p>
<p>예를 들어, 이러한 바운드가 없다면 <code>Arc&lt;Rc&lt;u32&gt;&gt;</code>가 <code>Sync</code>나 <code>Send</code>가 될 것이고, 이는 <code>Arc</code>로부터 <code>Rc</code>를 클론하여 (완전히 새로운 <code>Rc</code>를 생성하지 않고도) 스레드 간에 전송할 수 있음을 의미합니다. <code>Rc</code>는 스레드에 안전하지 않으므로 이는 데이터 경쟁을 일으킬 것입니다.</p>
<h2 id="arcinner-가져오기"><a class="header" href="#arcinner-가져오기"><code>ArcInner</code> 가져오기</a></h2>
<p><code>NonNull&lt;T&gt;</code> 포인터를 <code>&amp;T</code>로 역참조하기 위해 <code>NonNull::as_ref</code>를 호출할 수 있습니다. 일반적인 <code>as_ref</code> 함수와 달리 이는 비안전(unsafe)하므로, 다음과 같이 호출해야 합니다:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">unsafe { self.ptr.as_ref() }</code></pre>
<p>우리는 이 코드 조각을 이 코드 내에서 몇 번 사용할 것입니다 (보통 연관된 <code>let</code> 바인딩과 함께).</p>
<p>이 비안전함은 괜찮습니다. 이 <code>Arc</code>가 살아있는 동안 내부 포인터가 유효함이 보장되기 때문입니다.</p>
<h2 id="역참조-1"><a class="header" href="#역참조-1">역참조</a></h2>
<p>좋습니다. 이제 <code>Arc</code>를 만들 수 있게 되었습니다 (곧 올바르게 클론하고 파괴할 수도 있게 될 것입니다). 그런데 내부의 데이터에는 어떻게 접근할까요?</p>
<p>지금 우리에게 필요한 것은 <code>Deref</code> 구현입니다.</p>
<p>트레잇을 임포트해야 합니다:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">use std::ops::Deref;</code></pre>
<p>그리고 여기 그 구현이 있습니다:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">impl&lt;T&gt; Deref for Arc&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        let inner = unsafe { self.ptr.as_ref() };
        &amp;inner.data
    }
}</code></pre>
<p>꽤 간단하죠? 이는 단순히 <code>NonNull</code> 포인터를 <code>ArcInner&lt;T&gt;</code>로 역참조한 다음, 내부 데이터에 대한 참조를 가져옵니다.</p>
<h2 id="코드"><a class="header" href="#코드">코드</a></h2>
<p>이 섹션의 모든 코드는 다음과 같습니다:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">use std::ops::Deref;

impl&lt;T&gt; Arc&lt;T&gt; {
    pub fn new(data: T) -&gt; Arc&lt;T&gt; {
        // 첫 번째 참조가 현재 포인터이므로 참조 횟수를 1로 시작합니다.
        let boxed = Box::new(ArcInner {
            rc: AtomicUsize::new(1),
            data,
        });
        Arc {
            // It is okay to call `.unwrap()` here as we get a pointer from
            // `Box::into_raw` which is guaranteed to not be null.
            ptr: NonNull::new(Box::into_raw(boxed)).unwrap(),
            phantom: PhantomData,
        }
    }
}

unsafe impl&lt;T: Sync + Send&gt; Send for Arc&lt;T&gt; {}
unsafe impl&lt;T: Sync + Send&gt; Sync for Arc&lt;T&gt; {}


impl&lt;T&gt; Deref for Arc&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        let inner = unsafe { self.ptr.as_ref() };
        &amp;inner.data
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="클로닝"><a class="header" href="#클로닝">클로닝</a></h1>
<p>기본적인 코드가 설정되었으므로, 이제 <code>Arc</code>를 클론할 방법이 필요합니다.</p>
<p>기본적으로, 우리는 다음을 수행해야 합니다:</p>
<ol>
<li>원자적 참조 횟수를 증가시킵니다.</li>
<li>내부 포인터로부터 <code>Arc</code>의 새로운 인스턴스를 생성합니다.</li>
</ol>
<p>먼저 <code>ArcInner</code>에 접근해야 합니다:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">let inner = unsafe { self.ptr.as_ref() };</code></pre>
<p>다음과 같이 원자적 참조 횟수를 업데이트할 수 있습니다:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">let old_rc = inner.rc.fetch_add(1, Ordering::???);</code></pre>
<p>그런데 여기서 어떤 정렬(ordering)을 사용해야 할까요? 클론하는 동안에는 내부 값을 수정하지 않으므로, 클론 시에 아토믹 동기화가 필요한 코드는 딱히 없습니다. 따라서 여기서는 <code>Relaxed</code> 정렬을 사용할 수 있습니다. 이는 발생 전(happens-before) 관계를 함축하지는 않지만 원자적입니다. 하지만 Arc를 <code>Drop</code>할 때는 참조 횟수를 감소시킬 때 원자적 동기화가 필요합니다. 이에 대해서는 <a href="arc-mutex/arc-drop.html"><code>Arc</code>의 <code>Drop</code> 구현 섹션</a>에서 더 자세히 설명합니다. 아토믹 관계와 <code>Relaxed</code> 정렬에 대한 자세한 내용은 <a href="arc-mutex/../atomics.html">아토믹 섹션</a>을 참조하십시오.</p>
<p>따라서 코드는 다음과 같이 됩니다:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">let old_rc = inner.rc.fetch_add(1, Ordering::Relaxed);</code></pre>
<p><code>Ordering</code>을 사용하기 위해 임포트를 하나 더 추가해야 합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic::Ordering;
<span class="boring">}</span></code></pre></pre>
<p>하지만 현재 이 구현에는 한 가지 문제가 있습니다. 누군가 수많은 Arc를 <code>mem::forget</code>하기로 결정한다면 어떻게 될까요? 우리가 지금까지 작성한(그리고 작성할) 코드는 참조 횟수가 메모리에 있는 Arc의 수를 정확히 나타낸다고 가정하지만, <code>mem::forget</code>을 사용하면 이 가정이 깨집니다. 따라서 Arc들이 <code>Drop</code>되어 참조 횟수가 감소하지 않은 채 계속해서 클론된다면, 오버플로가 발생할 수 있습니다! 이는 해제 후 사용(use-after-free)을 초래하며, 이는 <strong>매우 끔찍한 일입니다!</strong></p>
<p>이를 처리하기 위해, 참조 횟수가 임의의 값(<code>AtomicUsize</code>로 저장하므로 <code>usize::MAX</code> 미만)을 넘지 않는지 확인하고, 무언가 조치를 취해야 합니다.</p>
<p>표준 라이브러리의 구현은 어떤 스레드에서든 참조 횟수가 <code>isize::MAX</code>(<code>usize::MAX</code>의 약 절반)에 도달하면 프로그램을 그냥 중단(abort)시키기로 결정했습니다. 이는 일반적인 코드에서는 발생할 가능성이 매우 희박하며, 만약 발생한다면 프로그램이 매우 비정상적인 상태일 것이기 때문입니다. 또한 약 20억 개의 스레드(일부 64비트 머신에서는 약 <strong>900경</strong> 개)가 동시에 참조 횟수를 증가시키지는 않을 것이라는 가정하에 내린 결정입니다. 우리도 똑같이 할 것입니다.</p>
<p>이 동작을 구현하는 것은 꽤 간단합니다:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">if old_rc &gt;= isize::MAX as usize {
    std::process::abort();
}</code></pre>
<p>그런 다음, <code>Arc</code>의 새로운 인스턴스를 반환해야 합니다:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">Self {
    ptr: self.ptr,
    phantom: PhantomData
}</code></pre>
<p>이제 이 모든 것을 <code>Clone</code> 구현 내부에 담아봅시다:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">use std::sync::atomic::Ordering;

impl&lt;T&gt; Clone for Arc&lt;T&gt; {
    fn clone(&amp;self) -&gt; Arc&lt;T&gt; {
        let inner = unsafe { self.ptr.as_ref() };
        // 여기서는 내부 데이터를 수정하거나 접근하지 않으므로 아토믹 동기화가
        // 필요 없기 때문에 릴랙스드(relaxed) 정렬을 사용해도 괜찮습니다.
        let old_rc = inner.rc.fetch_add(1, Ordering::Relaxed);

        if old_rc &gt;= isize::MAX as usize {
            std::process::abort();
        }

        Self {
            ptr: self.ptr,
            phantom: PhantomData,
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="드롭하기"><a class="header" href="#드롭하기">드롭하기</a></h1>
<p>이제 참조 횟수를 줄이고, 횟수가 충분히 낮아지면 데이터를 드롭할 방법이 필요합니다. 그렇지 않으면 데이터는 힙에 영원히 남아있게 될 것입니다.</p>
<p>이를 위해 <code>Drop</code>을 구현할 수 있습니다.</p>
<p>기본적으로, 우리는 다음을 수행해야 합니다:</p>
<ol>
<li>참조 횟수를 감소시킵니다.</li>
<li>데이터에 대한 참조가 하나만 남았다면:</li>
<li>데이터의 사용과 삭제가 재배치되는 것을 방지하기 위해 아토믹 펜스를 칩니다.</li>
<li>내부 데이터를 드롭합니다.</li>
</ol>
<p>먼저 <code>ArcInner</code>에 접근해야 합니다:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">let inner = unsafe { self.ptr.as_ref() };</code></pre>
<p>이제 참조 횟수를 감소시켜야 합니다. 코드를 간결하게 만들기 위해, <code>fetch_sub</code>에서 반환된 값(감소시키기 전의 참조 횟수 값)이 <code>1</code>이 아니라면 (즉, 우리가 마지막 참조가 아니라면) 그냥 반환하도록 할 수 있습니다.</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">if inner.rc.fetch_sub(1, Ordering::Release) != 1 {
    return;
}</code></pre>
<p>그 다음, 데이터의 사용과 삭제가 재배치되는 것을 방지하기 위해 아토믹 펜스를 생성해야 합니다. <a href="https://github.com/rust-lang/rust/blob/e1884a8e3c3e813aada8254edfa120e85bf5ffca/library/alloc/src/sync.rs#L1440-L1467">표준 라이브러리의 <code>Arc</code> 구현</a>에 설명된 대로입니다:</p>
<blockquote>
<p>이 펜스는 데이터의 사용과 삭제가 재배치되는 것을 방지하기 위해 필요합니다. 참조 횟수를 줄이는 작업이 <code>Release</code>로 표시되어 있기 때문에, 이 <code>Acquire</code> 펜스와 동기화됩니다. 이는 데이터의 사용이 참조 횟수 감소보다 먼저 발생하고, 이는 다시 펜스보다 먼저 발생하며, 이는 최종적으로 데이터의 삭제보다 먼저 발생함을 의미합니다.</p>
<p><a href="https://www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html">Boost 문서</a>에 설명된 대로:</p>
<blockquote>
<p>한 스레드에서의 객체에 대한 모든 가능한 접근(기존 참조를 통한 접근)이 다른 스레드에서의 객체 삭제보다 반드시 _먼저 발생(happen before)_하도록 강제하는 것이 중요합니다. 이는 참조를 드롭한 후의 "release" 연산(이 참조를 통한 객체 접근은 분명히 그 전에 발생했어야 함)과, 객체를 삭제하기 전의 "acquire" 연산을 통해 달성됩니다.</p>
</blockquote>
<p>특히, Arc의 내용은 보통 불변이지만, <code>Mutex&lt;T&gt;</code>와 같은 것을 통해 내부 쓰기가 발생할 수 있습니다. Mutex는 삭제될 때 어콰이어되지 않으므로, 스레드 A에서의 쓰기를 스레드 B에서 실행되는 소멸자에게 보이게 하기 위해 Mutex의 동기화 로직에 의존할 수 없습니다.</p>
<p>또한 여기서의 Acquire 펜스는 아마도 Acquire 로드(load)로 대체될 수 있으며, 이는 경쟁이 심한 상황에서 성능을 향상시킬 수 있습니다. <a href="https://github.com/rust-lang/rust/pull/41714">2</a>를 참조하십시오.</p>
</blockquote>
<p>이를 위해 다음과 같이 합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::sync::atomic::Ordering;
</span>use std::sync::atomic;
atomic::fence(Ordering::Acquire);
<span class="boring">}</span></code></pre></pre>
<p>마지막으로, 데이터 자체를 드롭할 수 있습니다. 우리는 <code>Box::from_raw</code>를 사용하여 박스에 담긴 <code>ArcInner&lt;T&gt;</code>와 그 데이터를 드롭합니다. 이 함수는 <code>NonNull&lt;T&gt;</code>가 아닌 <code>*mut T</code>를 받으므로, <code>NonNull::as_ptr</code>을 사용하여 변환해야 합니다.</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">unsafe { Box::from_raw(self.ptr.as_ptr()); }</code></pre>
<p>우리는 우리가 <code>ArcInner</code>에 대한 마지막 포인터를 가지고 있다는 것과 그 포인터가 유효하다는 것을 알고 있으므로, 이는 안전합니다.</p>
<p>이제 이 모든 것을 <code>Drop</code> 구현 내부에 담아봅시다:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">impl&lt;T&gt; Drop for Arc&lt;T&gt; {
    fn drop(&amp;mut self) {
        let inner = unsafe { self.ptr.as_ref() };
        if inner.rc.fetch_sub(1, Ordering::Release) != 1 {
            return;
        }
        // 이 펜스는 데이터의 사용과 삭제가 재배치되는 것을 방지하기 위해
        // 필요합니다.
        atomic::fence(Ordering::Acquire);
        // 우리가 `ArcInner`에 대한 마지막 포인터를 가지고 있고 그 포인터가
        // 유효하다는 것을 알고 있으므로 이는 안전합니다.
        unsafe { Box::from_raw(self.ptr.as_ptr()); }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="최종-코드-1"><a class="header" href="#최종-코드-1">최종 코드</a></h1>
<p>주석을 추가하고 임포트 순서를 조정한 최종 코드는 다음과 같습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::marker::PhantomData;
use std::ops::Deref;
use std::ptr::NonNull;
use std::sync::atomic::{self, AtomicUsize, Ordering};

pub struct Arc&lt;T&gt; {
    ptr: NonNull&lt;ArcInner&lt;T&gt;&gt;,
    phantom: PhantomData&lt;ArcInner&lt;T&gt;&gt;,
}

pub struct ArcInner&lt;T&gt; {
    rc: AtomicUsize,
    data: T,
}

impl&lt;T&gt; Arc&lt;T&gt; {
    pub fn new(data: T) -&gt; Arc&lt;T&gt; {
        // 첫 번째 참조가 현재 포인터이므로 참조 횟수를 1로 시작합니다.
        let boxed = Box::new(ArcInner {
            rc: AtomicUsize::new(1),
            data,
        });
        Arc {
            // It is okay to call `.unwrap()` here as we get a pointer from
            // `Box::into_raw` which is guaranteed to not be null.
            ptr: NonNull::new(Box::into_raw(boxed)).unwrap(),
            phantom: PhantomData,
        }
    }
}

unsafe impl&lt;T: Sync + Send&gt; Send for Arc&lt;T&gt; {}
unsafe impl&lt;T: Sync + Send&gt; Sync for Arc&lt;T&gt; {}

impl&lt;T&gt; Deref for Arc&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        let inner = unsafe { self.ptr.as_ref() };
        &amp;inner.data
    }
}

impl&lt;T&gt; Clone for Arc&lt;T&gt; {
    fn clone(&amp;self) -&gt; Arc&lt;T&gt; {
        let inner = unsafe { self.ptr.as_ref() };
        // 여기서는 내부 데이터를 수정하거나 접근하지 않으므로 아토믹 동기화가
        // 필요 없기 때문에 릴랙스드(relaxed) 정렬을 사용해도 괜찮습니다.
        let old_rc = inner.rc.fetch_add(1, Ordering::Relaxed);

        if old_rc &gt;= isize::MAX as usize {
            std::process::abort();
        }

        Self {
            ptr: self.ptr,
            phantom: PhantomData,
        }
    }
}

impl&lt;T&gt; Drop for Arc&lt;T&gt; {
    fn drop(&amp;mut self) {
        let inner = unsafe { self.ptr.as_ref() };
        if inner.rc.fetch_sub(1, Ordering::Release) != 1 {
            return;
        }
        // 이 펜스는 데이터의 사용과 삭제가 재배치되는 것을 방지하기 위해
        // 필요합니다.
        atomic::fence(Ordering::Acquire);
        // 우리가 `ArcInner`에 대한 마지막 포인터를 가지고 있고 그 포인터가
        // 유효하다는 것을 알고 있으므로 이는 안전합니다.
        unsafe { Box::from_raw(self.ptr.as_ptr()); }
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="외부-함수-인터페이스-foreign-function-interface-ffi"><a class="header" href="#외부-함수-인터페이스-foreign-function-interface-ffi">외부 함수 인터페이스 (Foreign Function Interface, FFI)</a></h1>
<h2 id="소개"><a class="header" href="#소개">소개</a></h2>
<p>이 가이드는 외부 코드용 바인딩 작성을 소개하기 위해 <a href="https://github.com/google/snappy">snappy</a> 압축/해제 라이브러리를 사용할 것입니다. 러스트는 현재 C++ 라이브러리를 직접 호출할 수 없지만, snappy는 (<a href="https://github.com/google/snappy/blob/master/snappy-c.h"><code>snappy-c.h</code></a>에 문서화된) C 인터페이스를 포함하고 있습니다.</p>
<h2 id="libc에-대한-참고-사항"><a class="header" href="#libc에-대한-참고-사항">libc에 대한 참고 사항</a></h2>
<p>Many of these examples use <a href="https://crates.io/crates/libc">the <code>libc</code> crate</a>, which provides various type definitions for C types, among other things. If you’re trying out these examples yourself, you’ll need to add <code>libc</code> to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
libc = "0.2.0"
</code></pre>
<h2 id="prepare-the-build-script"><a class="header" href="#prepare-the-build-script">Prepare the build script</a></h2>
<p>Because <a href="https://github.com/google/snappy">snappy</a> is a static library by default, so there is no stdc++ linked in the output artifact. In order to use this foreign library in Rust, we have to manually specify that we want to link stdc++ std to our project. The easiest way to do this is by setting up a build script.</p>
<p>First edit <code>Cargo.toml</code>, inside <code>package</code> add <code>build = "build.rs"</code>:</p>
<pre><code class="language-toml">[package]
...
build = "build.rs"
</code></pre>
<p>Then create a new file at the root of your workspace, named <code>build.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024">// build.rs
fn main() {
    println!("cargo:rustc-link-lib=dylib=stdc++"); // This line may be unnecessary for some environments.
    println!("cargo:rustc-link-search=&lt;YOUR SNAPPY LIBRARY PATH&gt;");
}</code></pre></pre>
<p>For more information, please read <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">The Cargo Book - build script</a>.</p>
<h2 id="외부-함수-호출하기"><a class="header" href="#외부-함수-호출하기">외부 함수 호출하기</a></h2>
<p>다음은 snappy가 설치되어 있다면 컴파일될, 외부 함수를 호출하는 최소한의 예제입니다:</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore">use libc::size_t;

#[link(name = "snappy")]
unsafe extern "C" {
    fn snappy_max_compressed_length(source_length: size_t) -&gt; size_t;
}

fn main() {
    let x = unsafe { snappy_max_compressed_length(100) };
    println!("100바이트 버퍼의 최대 압축 길이: {}", x);
}</code></pre>
<p>The <code>extern</code> block is a list of function signatures in a foreign library, in this case with the platform's C ABI. The <code>#[link(...)]</code> attribute is used to instruct the linker to link against the snappy library so the symbols can be resolved.</p>
<p>외부 함수들은 비안전(unsafe)한 것으로 간주되므로, 그 호출은 그 안에 포함된 모든 것이 정말로 안전하다는 컴파일러에 대한 약속으로서 <code>unsafe {}</code>로 감싸야 합니다. C 라이브러리들은 종종 스레드 안전하지 않은 인터페이스를 노출하며, 포인터 인자를 받는 거의 모든 함수는 포인터가 매달려 있을(dangling) 수 있으므로 모든 가능한 입력에 대해 유효하지 않습니다. 또한 원시 포인터는 러스트의 안전한 메모리 모델을 벗어납니다.</p>
<p>외부 함수에 대한 인자 타입을 선언할 때, 러스트 컴파일러는 선언이 올바른지 확인할 수 없습니다. 따라서 이를 올바르게 지정하는 것은 런타임에 바인딩이 올바르게 유지되도록 하는 일의 일부입니다.</p>
<p><code>extern</code> 블록을 확장하여 전체 snappy API를 다룰 수 있습니다:</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore">use libc::{c_int, size_t};

#[link(name = "snappy")]
unsafe extern "C" {
    fn snappy_compress(input: *const u8,
                       input_length: size_t,
                       compressed: *mut u8,
                       compressed_length: *mut size_t) -&gt; c_int;
    fn snappy_uncompress(compressed: *const u8,
                         compressed_length: size_t,
                         uncompressed: *mut u8,
                         uncompressed_length: *mut size_t) -&gt; c_int;
    fn snappy_max_compressed_length(source_length: size_t) -&gt; size_t;
    fn snappy_uncompressed_length(compressed: *const u8,
                                  compressed_length: size_t,
                                  result: *mut size_t) -&gt; c_int;
    fn snappy_validate_compressed_buffer(compressed: *const u8,
                                         compressed_length: size_t) -&gt; c_int;
}
<span class="boring">fn main() {}</span></code></pre>
<h2 id="안전한-인터페이스-만들기"><a class="header" href="#안전한-인터페이스-만들기">안전한 인터페이스 만들기</a></h2>
<p>메모리 안전성을 제공하고 벡터와 같은 고수준 개념을 활용하기 위해 원시 C API를 래핑할 필요가 있습니다. 라이브러리는 안전한 고수준 인터페이스만을 노출하고 비안전한 내부 세부 사항은 숨기기로 선택할 수 있습니다.</p>
<p>Wrapping the functions which expect buffers involves using the <code>slice::raw</code> module to manipulate Rust's vectors as pointers to memory. Rust's vectors are guaranteed to be a contiguous block of memory. The length is the number of elements currently contained, and the capacity is the total size in elements of the allocated memory. The length is less than or equal to the capacity.</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore"><span class="boring">use libc::{c_int, size_t};
</span><span class="boring">unsafe fn snappy_validate_compressed_buffer(_: *const u8, _: size_t) -&gt; c_int { 0 }
</span><span class="boring">fn main() {}
</span>pub fn validate_compressed_buffer(src: &amp;[u8]) -&gt; bool {
    unsafe {
        snappy_validate_compressed_buffer(src.as_ptr(), src.len() as size_t) == 0
    }
}</code></pre>
<p>위의 <code>validate_compressed_buffer</code> 래퍼는 <code>unsafe</code> 블록을 사용하지만, 함수 시그니처에서 <code>unsafe</code>를 뺌으로써 모든 입력에 대해 호출이 안전하다는 것을 보장합니다.</p>
<p><code>snappy_compress</code>와 <code>snappy_uncompress</code> 함수는 출력물을 담을 버퍼도 할당해야 하므로 더 복잡합니다.</p>
<p><code>snappy_max_compressed_length</code> 함수는 압축된 출력을 담기에 충분한 최대 용량을 가진 벡터를 할당하는 데 사용될 수 있습니다. 그런 다음 이 벡터는 <code>snappy_compress</code> 함수에 출력 매개변수로 전달될 수 있습니다. 또한 압축 후 실제 길이를 가져와서 벡터의 길이를 설정하기 위한 출력 매개변수도 전달됩니다.</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore"><span class="boring">use libc::{size_t, c_int};
</span><span class="boring">unsafe fn snappy_compress(a: *const u8, b: size_t, c: *mut u8,
</span><span class="boring">                          d: *mut size_t) -&gt; c_int { 0 }
</span><span class="boring">unsafe fn snappy_max_compressed_length(a: size_t) -&gt; size_t { a }
</span><span class="boring">fn main() {}
</span>pub fn compress(src: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
    unsafe {
        let srclen = src.len() as size_t;
        let psrc = src.as_ptr();

        let mut dstlen = snappy_max_compressed_length(srclen);
        let mut dst = Vec::with_capacity(dstlen as usize);
        let pdst = dst.as_mut_ptr();

        snappy_compress(psrc, srclen, pdst, &amp;mut dstlen);
        dst.set_len(dstlen as usize);
        dst
    }
}</code></pre>
<p>압축 해제도 비슷합니다. snappy는 압축 형식의 일부로 압축되지 않은 크기를 저장하며, <code>snappy_uncompressed_length</code>는 필요한 정확한 버퍼 크기를 가져올 것이기 때문입니다.</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore"><span class="boring">use libc::{size_t, c_int};
</span><span class="boring">unsafe fn snappy_uncompress(compressed: *const u8,
</span><span class="boring">                            compressed_length: size_t,
</span><span class="boring">                            uncompressed: *mut u8,
</span><span class="boring">                            uncompressed_length: *mut size_t) -&gt; c_int { 0 }
</span><span class="boring">unsafe fn snappy_uncompressed_length(compressed: *const u8,
</span><span class="boring">                                     compressed_length: size_t,
</span><span class="boring">                                     result: *mut size_t) -&gt; c_int { 0 }
</span><span class="boring">fn main() {}
</span>pub fn uncompress(src: &amp;[u8]) -&gt; Option&lt;Vec&lt;u8&gt;&gt; {
    unsafe {
        let srclen = src.len() as size_t;
        let psrc = src.as_ptr();

        let mut dstlen: size_t = 0;
        snappy_uncompressed_length(psrc, srclen, &amp;mut dstlen);

        let mut dst = Vec::with_capacity(dstlen as usize);
        let pdst = dst.as_mut_ptr();

        if snappy_uncompress(psrc, srclen, pdst, &amp;mut dstlen) == 0 {
            dst.set_len(dstlen as usize);
            Some(dst)
        } else {
            None // SNAPPY_INVALID_INPUT
        }
    }
}</code></pre>
<p>그 다음, 이것들을 어떻게 사용하는지 보여주기 위한 테스트를 추가할 수 있습니다.</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore"><span class="boring">use libc::{c_int, size_t};
</span><span class="boring">unsafe fn snappy_compress(input: *const u8,
</span><span class="boring">                          input_length: size_t,
</span><span class="boring">                          compressed: *mut u8,
</span><span class="boring">                          compressed_length: *mut size_t)
</span><span class="boring">                          -&gt; c_int { 0 }
</span><span class="boring">unsafe fn snappy_uncompress(compressed: *const u8,
</span><span class="boring">                            compressed_length: size_t,
</span><span class="boring">                            uncompressed: *mut u8,
</span><span class="boring">                            uncompressed_length: *mut size_t)
</span><span class="boring">                            -&gt; c_int { 0 }
</span><span class="boring">unsafe fn snappy_max_compressed_length(source_length: size_t) -&gt; size_t { 0 }
</span><span class="boring">unsafe fn snappy_uncompressed_length(compressed: *const u8,
</span><span class="boring">                                     compressed_length: size_t,
</span><span class="boring">                                     result: *mut size_t)
</span><span class="boring">                                     -&gt; c_int { 0 }
</span><span class="boring">unsafe fn snappy_validate_compressed_buffer(compressed: *const u8,
</span><span class="boring">                                            compressed_length: size_t)
</span><span class="boring">                                            -&gt; c_int { 0 }
</span><span class="boring">fn main() { }
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn valid() {
        let d = vec![0xde, 0xad, 0xd0, 0x0d];
        let c: &amp;[u8] = &amp;compress(&amp;d);
        assert!(validate_compressed_buffer(c));
        assert!(uncompress(c) == Some(d));
    }

    #[test]
    fn invalid() {
        let d = vec![0, 0, 0, 0];
        assert!(!validate_compressed_buffer(&amp;d));
        assert!(uncompress(&amp;d).is_none());
    }

    #[test]
    fn empty() {
        let d = vec![];
        assert!(!validate_compressed_buffer(&amp;d));
        assert!(uncompress(&amp;d).is_none());
        let c = compress(&amp;d);
        assert!(validate_compressed_buffer(&amp;c));
        assert!(uncompress(&amp;c) == Some(d));
    }
}</code></pre>
<h2 id="소멸자-1"><a class="header" href="#소멸자-1">소멸자</a></h2>
<p>Foreign libraries often hand off ownership of resources to the calling code. When this occurs, we must use Rust's destructors to provide safety and guarantee the release of these resources (especially in the case of a panic).</p>
<p>For more information about destructors, see the <a href="../std/ops/trait.Drop.html">Drop trait</a>.</p>
<h2 id="c에서-러스트-코드-호출하기"><a class="header" href="#c에서-러스트-코드-호출하기">C에서 러스트 코드 호출하기</a></h2>
<p>You may wish to compile Rust code in a way that can be called from C. This is fairly easy, but requires a few things.</p>
<h3 id="러스트-측"><a class="header" href="#러스트-측">러스트 측</a></h3>
<p>먼저, <code>rust_from_c</code>라는 이름의 라이브러리 크레이트가 있다고 가정합니다. <code>lib.rs</code>에는 다음과 같은 러스트 코드가 있어야 합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024">#[unsafe(no_mangle)]
pub extern "C" fn hello_from_rust() {
    println!("러스트에서 인사드립니다!");
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>"<a href="ffi.html#foreign-calling-conventions">외부 호출 규약(Foreign Calling Conventions)</a>" 섹션에서 논의할 것과 같습니다. <code>no_mangle</code> 속성은 러스트의 이름 맹글링(name mangling)을 꺼서, 링크할 수 있는 잘 정의된 심볼을 갖게 합니다."<a href="ffi.html#foreign-calling-conventions">외부 호출 규약(Foreign Calling Conventions)</a>" 섹션에서 논의할 것과 같습니다. <code>no_mangle</code> 속성은 러스트의 이름 맹글링(name mangling)을 꺼서, 링크할 수 있는 잘 정의된 심볼을 갖게 합니다.</p>
<p>그 다음, C에서 호출할 수 있는 공유 라이브러리로 러스트 코드를 컴파일하려면 <code>Cargo.toml</code>에 다음을 추가하십시오:</p>
<pre><code class="language-toml">[lib]
crate-type = ["cdylib"]
</code></pre>
<p>(NOTE: We could also use the <code>staticlib</code> crate type but it also requires tweaking some linking flags.)</p>
<p><code>cargo build</code>를 실행하면 러스트 측 준비는 끝납니다.</p>
<h3 id="c-측"><a class="header" href="#c-측">C 측</a></h3>
<p><code>hello_from_rust</code> 함수를 호출할 C 파일을 만들고 <code>gcc</code>로 컴파일할 것입니다.</p>
<p>C 파일은 다음과 같아야 합니다:</p>
<pre><code class="language-c">extern void hello_from_rust();

int main(void) {
    hello_from_rust();
    return 0;
}
</code></pre>
<p>파일 이름을 <code>call_rust.c</code>로 짓고 크레이트 루트에 둡니다. 컴파일을 위해 다음을 실행하십시오:</p>
<pre><code class="language-sh">gcc call_rust.c -o call_rust -lrust_from_c -L./target/debug
</code></pre>
<p><code>-l</code>과 <code>-L</code>은 gcc에게 우리의 러스트 라이브러리를 찾을 위치를 알려줍니다.</p>
<p>마지막으로, <code>LD_LIBRARY_PATH</code>를 지정하여 C에서 러스트 코드를 호출할 수 있습니다:</p>
<pre><code class="language-sh">$ LD_LIBRARY_PATH=./target/debug ./call_rust
Hello from Rust!
</code></pre>
<p>That's it! For a more realistic example, check the <a href="https://github.com/eqrion/cbindgen"><code>cbindgen</code></a>.</p>
<h2 id="c-코드에서-러스트-함수로의-콜백"><a class="header" href="#c-코드에서-러스트-함수로의-콜백">C 코드에서 러스트 함수로의 콜백</a></h2>
<p>일부 외부 라이브러리는 현재 상태나 중간 데이터를 호출자에게 보고하기 위해 콜백 사용을 요구합니다. 러스트에서 정의된 함수를 외부 라이브러리에 전달하는 것이 가능합니다. 이를 위한 요구 사항은 콜백 함수가 C 코드에서 호출 가능하도록 올바른 호출 규약과 함께 <code>extern</code>으로 표시되어야 한다는 것입니다.</p>
<p>그 후 콜백 함수는 등록 호출을 통해 C 라이브러리로 전달될 수 있으며, 그 후 거기에서 호출될 수 있습니다.</p>
<p>기본적인 예제는 다음과 같습니다:</p>
<p>러스트 코드:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024">extern fn callback(a: i32) {
    println!("C에서 값 {0}과(와) 함께 호출되었습니다", a);
}

#[link(name = "extlib")]
unsafe extern {
   fn register_callback(cb: extern fn(i32)) -&gt; i32;
   fn trigger_callback();
}

fn main() {
    unsafe {
        register_callback(callback);
        trigger_callback(); // 콜백을 트리거합니다.
    }
}</code></pre></pre>
<p>C 코드:</p>
<pre><code class="language-c">typedef void (*rust_callback)(int32_t);
rust_callback cb;

int32_t register_callback(rust_callback callback) {
    cb = callback;
    return 1;
}

void trigger_callback() {
  cb(7); // 러스트의 callback(7)을 호출할 것입니다.
}
</code></pre>
<p>이 예제에서 러스트의 <code>main()</code>은 C의 <code>trigger_callback()</code>을 호출하고, 이는 다시 러스트의 <code>callback()</code>을 호출할 것입니다.</p>
<h2 id="러스트-객체를-대상으로-하는-콜백"><a class="header" href="#러스트-객체를-대상으로-하는-콜백">러스트 객체를 대상으로 하는 콜백</a></h2>
<p>앞의 예제는 C 코드에서 전역 함수를 호출하는 방법을 보여주었습니다. 하지만 종종 특정 러스트 객체를 대상으로 콜백을 호출하고 싶을 때가 있습니다. 이는 각각의 C 객체에 대한 래퍼를 나타내는 객체일 수 있습니다.</p>
<p>이는 객체에 대한 원시 포인터를 C 라이브러리에 전달함으로써 달성할 수 있습니다. 그러면 C 라이브러리는 알림에 러스트 객체에 대한 포인터를 포함할 수 있습니다. 이를 통해 콜백이 참조된 러스트 객체에 비안전하게 접근할 수 있게 됩니다.</p>
<p>러스트 코드:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024">struct RustObject {
    a: i32,
    // 다른 멤버들...
}

unsafe extern "C" fn callback(target: *mut RustObject, a: i32) {
    println!("C에서 값 {0}과(와) 함께 호출되었습니다", a);
    unsafe {
        // 콜백으로부터 받은 값으로 RustObject의 값을 업데이트합니다:
        (*target).a = a;
    }
}

#[link(name = "extlib")]
unsafe extern {
   fn register_callback(target: *mut RustObject,
                        cb: unsafe extern fn(*mut RustObject, i32)) -&gt; i32;
   fn trigger_callback();
}

fn main() {
    // 콜백에서 참조될 객체를 생성합니다:
    let mut rust_object = Box::new(RustObject { a: 5 });

    unsafe {
        register_callback(&amp;mut *rust_object, callback);
        trigger_callback();
    }
}</code></pre></pre>
<p>C 코드:</p>
<pre><code class="language-c">typedef void (*rust_callback)(void*, int32_t);
void* cb_target;
rust_callback cb;

int32_t register_callback(void* callback_target, rust_callback callback) {
    cb_target = callback_target;
    cb = callback;
    return 1;
}

void trigger_callback() {
  cb(cb_target, 7); // 러스트의 callback(&amp;rustObject, 7)을 호출할 것입니다.
}
</code></pre>
<h2 id="비동기-콜백"><a class="header" href="#비동기-콜백">비동기 콜백</a></h2>
<p>이전에 주어진 예제들에서 콜백은 외부 C 라이브러리에 대한 함수 호출의 직접적인 반응으로 호출됩니다. 콜백 실행을 위해 현재 스레드의 제어권이 러스트에서 C로, 다시 러스트로 전환되지만, 결국 콜백은 콜백을 트리거한 함수를 호출한 동일한 스레드에서 실행됩니다.</p>
<p>외부 라이브러리가 자체 스레드를 생성하고 거기서 콜백을 호출하면 상황은 더 복잡해집니다. 이런 경우 콜백 내부에서 러스트 데이터 구조에 접근하는 것은 특히 비안전하므로 적절한 동기화 메커니즘을 사용해야 합니다. 뮤텍스와 같은 고전적인 동기화 메커니즘 외에도, 러스트에서는 채널(<code>std::sync::mpsc</code>)을 사용하여 콜백을 호출한 C 스레드에서 러스트 스레드로 데이터를 전달하는 방법이 있습니다.</p>
<p>비동기 콜백이 러스트 주소 공간의 특정 객체를 대상으로 한다면, 해당 러스트 객체가 파괴된 후에는 C 라이브러리가 더 이상 콜백을 수행하지 않는 것이 절대적으로 필요합니다. 이는 객체의 소멸자에서 콜백 등록을 해제하고, 등록 해제 후에는 어떤 콜백도 수행되지 않음을 보장하도록 라이브러리를 설계함으로써 달성할 수 있습니다.비동기 콜백이 러스트 주소 공간의 특정 객체를 대상으로 한다면, 해당 러스트 객체가 파괴된 후에는 C 라이브러리가 더 이상 콜백을 수행하지 않는 것이 절대적으로 필요합니다. 이는 객체의 소멸자에서 콜백 등록을 해제하고, 등록 해제 후에는 어떤 콜백도 수행되지 않음을 보장하도록 라이브러리를 설계함으로써 달성할 수 있습니다.</p>
<h2 id="링킹-linking"><a class="header" href="#링킹-linking">링킹 (Linking)</a></h2>
<p><code>extern</code> 블록의 <code>link</code> 속성은 rustc에게 네이티브 라이브러리와 링크하는 방법을 지시하는 기본적인 빌딩 블록을 제공합니다. 오늘날 허용되는 link 속성 형식은 두 가지입니다:</p>
<ul>
<li><code>#[link(name = "foo")]</code></li>
<li><code>#[link(name = "foo", kind = "bar")]</code></li>
</ul>
<p>이 두 경우 모두 <code>foo</code>는 링크하려는 네이티브 라이브러리의 이름이며, 두 번째 경우의 <code>bar</code>는 컴파일러가 링크하려는 네이티브 라이브러리의 타입입니다. 현재 세 가지 종류의 네이티브 라이브러리가 알려져 있습니다:</p>
<ul>
<li>동적 - <code>#[link(name = "readline")]</code></li>
<li>정적 - <code>#[link(name = "my_build_dependency", kind = "static")]</code></li>
<li>프레임워크 - <code>#[link(name = "CoreFoundation", kind = "framework")]</code></li>
</ul>
<p>프레임워크는 macOS 타겟에서만 사용할 수 있음에 유의하십시오.</p>
<p>서로 다른 <code>kind</code> 값들은 네이티브 라이브러리가 링킹에 어떻게 참여하는지를 구분하기 위한 것입니다. 링킹 관점에서 러스트 컴파일러는 두 가지 종류의 아티팩트를 생성합니다: 부분적(rlib/staticlib) 아티팩트와 최종적(dylib/binary) 아티팩트입니다. 네이티브 동적 라이브러리와 프레임워크 의존성은 최종 아티팩트 경계까지 전파되지만, 정적 라이브러리 의존성은 전혀 전파되지 않습니다. 정적 라이브러리는 이어지는 아티팩트에 직접 통합되기 때문입니다.</p>
<p>이 모델이 어떻게 사용될 수 있는지 몇 가지 예시는 다음과 같습니다:</p>
<ul>
<li>
<p>네이티브 빌드 의존성. 때때로 러스트 코드를 작성할 때 C/C++ 글루(glue) 코드가 필요하지만, C/C++ 코드를 라이브러리 형식으로 배포하는 것이 부담스러울 수 있습니다. 이런 경우 코드는 <code>libfoo.a</code>로 아카이브되고, 러스트 크레이트는 <code>#[link(name = "foo", kind = "static")]</code>를 통해 의존성을 선언할 것입니다.</p>
<p>크레이트의 출력 형식에 관계없이 네이티브 정적 라이브러리가 출력물에 포함되므로, 네이티브 정적 라이브러리를 별도로 배포할 필요가 없습니다.</p>
</li>
<li>
<p>일반적인 동적 의존성. (<code>readline</code>과 같은) 일반적인 시스템 라이브러리는 수많은 시스템에서 사용할 수 있으며, 종종 이러한 라이브러리의 정적 복사본을 찾을 수 없습니다. 러스트 크레이트에 이러한 의존성이 포함되면 (rlib과 같은) 부분적 타겟은 라이브러리에 링크되지 않지만, rlib이 최종 타겟(예: 바이너리)에 포함될 때 네이티브 라이브러리가 링크됩니다.</p>
</li>
</ul>
<p>macOS에서 프레임워크는 동적 라이브러리와 동일한 의미론으로 동작합니다.</p>
<h2 id="비안전-블록-unsafe-blocks"><a class="header" href="#비안전-블록-unsafe-blocks">비안전 블록 (Unsafe blocks)</a></h2>
<p>원시 포인터 역참조나 비안전(unsafe)으로 표시된 함수 호출과 같은 일부 연산은 비안전 블록 내부에서만 허용됩니다. 비안전 블록은 비안전성을 격리하며, 비안전성이 블록 밖으로 새어 나오지 않는다는 컴파일러에 대한 약속입니다.</p>
<p>반면 비안전 함수는 이를 세상에 알립니다. 비안전 함수는 다음과 같이 작성됩니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn kaboom(ptr: *const i32) -&gt; i32 { *ptr }
<span class="boring">}</span></code></pre></pre>
<p>이 함수는 <code>unsafe</code> 블록이나 다른 <code>unsafe</code> 함수 내에서만 호출될 수 있습니다.</p>
<h2 id="외부-전역-변수-접근하기"><a class="header" href="#외부-전역-변수-접근하기">외부 전역 변수 접근하기</a></h2>
<p>외부 API는 전역 상태를 추적하는 등의 작업을 수행하는 전역 변수를 내보내는 경우가 많습니다. 이러한 변수에 접근하려면, <code>extern</code> 블록 내에서 <code>static</code> 키워드로 선언해야 합니다:</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore">#[link(name = "readline")]
unsafe extern {
    static rl_readline_version: libc::c_int;
}

fn main() {
    println!("readline 버전 {}이(가) 설치되어 있습니다.",
             unsafe { rl_readline_version as i32 });
}</code></pre>
<p>또는 외부 인터페이스가 제공하는 전역 상태를 변경해야 할 수도 있습니다. 이를 위해 <code>mut</code>으로 정적 변수(statics)를 선언하여 변경할 수 있게 할 수 있습니다.</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore">use std::ffi::CString;
use std::ptr;

#[link(name = "readline")]
unsafe extern {
    static mut rl_prompt: *const libc::c_char;
}

fn main() {
    let prompt = CString::new("[my-awesome-shell] $").unwrap();
    unsafe {
        rl_prompt = prompt.as_ptr();

        println!("{:?}", rl_prompt);

        rl_prompt = ptr::null();
    }
}</code></pre>
<p><code>static mut</code>과의 모든 상호작용(읽기 및 쓰기 모두)은 안전하지 않다는 점에 유의하십시오. 전역 가변 상태를 다루는 것은 상당한 주의를 요합니다.</p>
<h2 id="외부-호출-규약-foreign-calling-conventions"><a class="header" href="#외부-호출-규약-foreign-calling-conventions">외부 호출 규약 (Foreign calling conventions)</a></h2>
<p>대부분의 외부 코드는 C ABI를 노출하며, 러스트는 외부 함수를 호출할 때 기본적으로 플랫폼의 C 호출 규약을 사용합니다. 일부 외부 함수, 특히 윈도우 API는 다른 호출 규약을 사용합니다. 러스트는 어떤 규약을 사용할지 컴파일러에게 알려주는 방법을 제공합니다:</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore">#[cfg(all(target_os = "win32", target_arch = "x86"))]
#[link(name = "kernel32")]
#[allow(non_snake_case)]
unsafe extern "stdcall" {
    fn SetEnvironmentVariableA(n: *const u8, v: *const u8) -&gt; libc::c_int;
}
<span class="boring">fn main() { }</span></code></pre>
<p>이는 전체 <code>extern</code> 블록에 적용됩니다. 지원되는 ABI 제약 조건 목록은 다음과 같습니다:</p>
<ul>
<li><code>stdcall</code></li>
<li><code>aapcs</code></li>
<li><code>cdecl</code></li>
<li><code>fastcall</code></li>
<li><code>thiscall</code></li>
<li><code>vectorcall</code> 이는 현재 <code>abi_vectorcall</code> 게이트 뒤에 숨겨져 있으며 변경될 수 있습니다.</li>
<li><code>Rust</code></li>
<li><code>system</code></li>
<li><code>C</code></li>
<li><code>win64</code></li>
<li><code>sysv64</code></li>
</ul>
<p>Most of the ABIs in this list are self-explanatory, but the <code>system</code> ABI may seem a little odd. This constraint selects whatever the appropriate ABI is for interoperating with the target's libraries. For example, on win32 with a x86 architecture, this means that the abi used would be <code>stdcall</code>. On x86_64, however, windows uses the <code>C</code> calling convention, so <code>C</code> would be used. This means that in our previous example, we could have used <code>extern "system" { ... }</code> to define a block for all windows systems, not only x86 ones.</p>
<h2 id="외부-코드와의-상호-운용성"><a class="header" href="#외부-코드와의-상호-운용성">외부 코드와의 상호 운용성</a></h2>
<p>러스트는 <code>#[repr(C)]</code> 속성이 적용된 경우에만 <code>struct</code>의 레이아웃이 플랫폼의 C 표현과 호환됨을 보장합니다. <code>#[repr(C, packed)]</code>는 패딩 없이 구조체 멤버를 배치하는 데 사용할 수 있습니다. <code>#[repr(C)]</code>는 열거형(enum)에도 적용될 수 있습니다.</p>
<p>러스트의 소유된 박스(<code>Box&lt;T&gt;</code>)는 내부 객체를 가리키는 핸들로서 null이 될 수 없는 포인터를 사용합니다. 하지만 이들은 내부 할당자에 의해 관리되므로 수동으로 생성해서는 안 됩니다. 참조는 해당 타입으로 직접 향하는 null이 될 수 없는 포인터라고 안전하게 가정할 수 있습니다. 하지만 빌림 검사나 가변성 규칙을 어기는 것이 안전하다고 보장되지는 않으므로, 필요한 경우에는 원시 포인터(<code>*</code>)를 사용하는 것을 선호하십시오. 컴파일러가 원시 포인터에 대해서는 그만큼 많은 가정을 할 수 없기 때문입니다.</p>
<p>벡터와 문자열은 동일한 기본 메모리 레이아웃을 공유하며, <code>vec</code> 및 <code>str</code> 모듈에는 C API와 작업하기 위한 유틸리티들이 준비되어 있습니다. 하지만 문자열은 <code>\0</code>으로 끝나지 않습니다. C와의 상호 운용성을 위해 NUL로 끝나는 문자열이 필요하다면 <code>std::ffi</code> 모듈의 <code>CString</code> 타입을 사용해야 합니다.</p>
<p><a href="https://crates.io/crates/libc">crates.io의 <code>libc</code> 크레이트</a>는 <code>libc</code> 모듈에 C 표준 라이브러리를 위한 타입 별칭과 함수 정의를 포함하고 있으며, 러스트는 기본적으로 <code>libc</code> 및 <code>libm</code>과 링크됩니다.</p>
<h2 id="가변-인자-함수-variadic-functions"><a class="header" href="#가변-인자-함수-variadic-functions">가변 인자 함수 (Variadic functions)</a></h2>
<p>C에서 함수는 '가변 인자'를 가질 수 있습니다. 즉, 가변적인 개수의 인자를 받을 수 있음을 의미합니다. 러스트에서는 외부 함수 선언의 인자 목록 안에 <code>...</code>를 지정함으로써 이를 달성할 수 있습니다:</p>
<pre><code class="language-no_run">unsafe extern {
    fn foo(x: i32, ...);
}

fn main() {
    unsafe {
        foo(10, 20, 30, 40, 50);
    }
}
</code></pre>
<p>일반적인 러스트 함수는 가변 인자를 가질 수 <em>없습니다</em>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 이 코드는 컴파일되지 않습니다

fn foo(x: i32, ...) {}
<span class="boring">}</span></code></pre></pre>
<h2 id="널-포인터-최적화nullable-pointer-optimization"><a class="header" href="#널-포인터-최적화nullable-pointer-optimization">"널 포인터 최적화(nullable pointer optimization)"</a></h2>
<p>특정 러스트 타입들은 절대 <code>null</code>이 될 수 없도록 정의되어 있습니다. 여기에는 참조(<code>&amp;T</code>, <code>&amp;mut T</code>), 박스(<code>Box&lt;T&gt;</code>), 그리고 함수 포인터(<code>extern "abi" fn()</code>)가 포함됩니다. C와 인터페이스할 때 <code>null</code>일 수 있는 포인터가 자주 사용되는데, 러스트 타입과의 변환을 처리하기 위해 지저분한 <code>transmute</code>나 안전하지 않은 코드가 필요해 보일 수 있습니다. 하지만 이러한 유효하지 않은 값을 생성하거나 다루려는 시도는 **정의되지 않은 동작(undefined behavior)**이므로, 대신 다음과 같은 우회 방법을 사용해야 합니다.</p>
<p>특별한 경우로, <code>enum</code>이 정확히 두 개의 변형(variant)을 가지고 있고, 그중 하나는 데이터를 포함하지 않으며 다른 하나는 위에서 나열한 널 불가 타입 중 하나의 필드를 포함한다면, 그 <code>enum</code>은 "널 포인터 최적화" 대상이 됩니다. 이는 판별자(discriminant)를 위한 추가 공간이 필요하지 않음을 의미합니다. 대신, 비어 있는 변형은 널 불가 필드에 <code>null</code> 값을 넣음으로써 표현됩니다. 이를 "최적화"라고 부르지만, 다른 최적화와 달리 대상 타입에 대해 적용됨이 보장됩니다.</p>
<p>널 포인터 최적화를 활용하는 가장 흔한 타입은 <code>Option&lt;T&gt;</code>이며, 여기서 <code>None</code>은 <code>null</code>에 해당합니다. 따라서 <code>Option&lt;extern "C" fn(c_int) -&gt; c_int&gt;</code>는 C ABI를 사용하는 널 가능(nullable) 함수 포인터를 표현하는 올바른 방법입니다 (C 타입 <code>int (*)(int)</code>에 해당).</p>
<p>여기 인위적인 예제가 하나 있습니다. 어떤 C 라이브러리에 특정 상황에서 호출되는 콜백을 등록하는 기능이 있다고 가정해 봅시다. 이 콜백은 함수 포인터와 정수를 전달받으며, 해당 정수를 인자로 하여 함수를 실행해야 합니다. 따라서 우리는 FFI 경계를 양방향으로 넘나드는 함수 포인터를 갖게 됩니다.</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore">use libc::c_int;

<span class="boring">#[cfg(hidden)]
</span>unsafe extern "C" {
    /// 콜백을 등록합니다.
    fn register(cb: Option&lt;extern "C" fn(Option&lt;extern "C" fn(c_int) -&gt; c_int&gt;, c_int) -&gt; c_int&gt;);
}
<span class="boring">unsafe fn register(_: Option&lt;extern "C" fn(Option&lt;extern "C" fn(c_int) -&gt; c_int&gt;,
</span><span class="boring">                                           c_int) -&gt; c_int&gt;)
</span><span class="boring">{}
</span>
/// 이 꽤 쓸모없는 함수는 C로부터 함수 포인터와 정수를 전달받아,
/// 해당 정수를 인자로 하여 함수를 호출한 결과를 반환합니다.
/// 함수가 제공되지 않은 경우, 기본적으로 정수를 제곱합니다.
extern "C" fn apply(process: Option&lt;extern "C" fn(c_int) -&gt; c_int&gt;, int: c_int) -&gt; c_int {
    match process {
        Some(f) =&gt; f(int),
        None    =&gt; int * int
    }
}

fn main() {
    unsafe {
        register(Some(apply));
    }
}</code></pre>
<p>그리고 C 측 코드는 다음과 같습니다:</p>
<pre><code class="language-c">void register(int (*f)(int (*)(int), int)) {
    ...
}
</code></pre>
<p><code>transmute</code>가 필요 없습니다!</p>
<h2 id="ffi와-언와인딩-ffi-and-unwinding"><a class="header" href="#ffi와-언와인딩-ffi-and-unwinding">FFI와 언와인딩 (FFI and unwinding)</a></h2>
<p>FFI와 작업할 때는 언와인딩(unwinding)에 유의하는 것이 중요합니다. 대부분의 ABI 문자열은 <code>-unwind</code> 접미사가 있는 것과 없는 것의 두 가지 변형으로 제공됩니다. <code>Rust</code> ABI는 항상 언와인딩을 허용하므로, <code>Rust-unwind</code> ABI는 따로 없습니다.</p>
<p>만약 러스트의 <code>panic</code>이나 외부(예: C++) 예외가 FFI 경계를 넘나들 것으로 예상된다면, 해당 경계는 적절한 <code>-unwind</code> ABI 문자열을 사용해야 합니다. 반대로, 언와인딩이 ABI 경계를 넘지 않을 것으로 예상된다면, <code>-unwind</code>가 없는 ABI 문자열 중 하나를 사용하십시오.</p>
<blockquote>
<p>참고: <code>panic=abort</code>로 컴파일하면, <code>panic</code>을 일으키는 함수에 지정된 ABI와 관계없이 <code>panic!</code>은 즉시 프로세스를 중단시킵니다.</p>
</blockquote>
<p>만약 언와인딩 연산이 언와인딩이 허용되지 않는 ABI 경계를 만나게 되면, 그 동작은 언와인딩의 원천(러스트 <code>panic</code> 또는 외부 예외)에 따라 달라집니다:</p>
<ul>
<li><code>panic</code>은 프로세스를 안전하게 중단(abort)시킵니다.</li>
<li>러스트로 들어오는 외부 예외는 정의되지 않은 동작을 유발합니다.</li>
</ul>
<p><code>catch_unwind</code>와 외부 예외 사이의 상호작용은 <strong>정의되지 않았으며</strong>, <code>panic</code>과 외부 예외 포착 메커니즘(특히 C++의 <code>try</code>/<code>catch</code>) 사이의 상호작용도 마찬가지입니다.</p>
<h3 id="c-unwind를-사용한-러스트-panic"><a class="header" href="#c-unwind를-사용한-러스트-panic"><code>"C-unwind"</code>를 사용한 러스트 <code>panic</code></a></h3>
<!-- ignore: using unstable feature -->
<pre><code class="language-rust ignore">#[unsafe(no_mangle)]
unsafe extern "C-unwind" fn example() {
    panic!("어라");
}</code></pre>
<p>이 함수는 (<code>panic=unwind</code>로 컴파일되었을 때) C++ 스택 프레임을 언와인딩하는 것이 허용됩니다.</p>
<pre><code class="language-text">[Rust function with `catch_unwind`, which stops the unwinding]
      |
     ...
      |
[C++ frames]
      |                           ^
      | (calls)                   | (unwinding
      v                           |  goes this
[Rust function `example`]         |  way)
      |                           |
      +--- rust function panics --+
</code></pre>
<p>C++ 프레임에 객체가 있다면, 그들의 소멸자가 호출될 것입니다.</p>
<h3 id="c-unwind를-사용한-c-throw"><a class="header" href="#c-unwind를-사용한-c-throw"><code>"C-unwind"</code>를 사용한 C++ <code>throw</code></a></h3>
<!-- ignore: using unstable feature -->
<pre><code class="language-rust ignore">#[link(...)]
unsafe extern "C-unwind" {
    // 예외를 던질 수 있는 C++ 함수
    fn may_throw();
}

#[unsafe(no_mangle)]
unsafe extern "C-unwind" fn rust_passthrough() {
    let b = Box::new(5);
    unsafe { may_throw(); }
    println!("{:?}", &amp;b);
}</code></pre>
<p><code>try</code> 블록이 있는 C++ 함수는 <code>rust_passthrough</code>를 호출하고 <code>may_throw</code>에 의해 던져진 예외를 <code>catch</code>할 수 있습니다.</p>
<pre><code class="language-text">[C++ function with `try` block that invokes `rust_passthrough`]
      |
     ...
      |
[Rust function `rust_passthrough`]
      |                            ^
      | (calls)                    | (unwinding
      v                            |  goes this
[C++ function `may_throw`]         |  way)
      |                            |
      +--- C++ function throws ----+
</code></pre>
<p>만약 <code>may_throw</code>가 예외를 던진다면 <code>b</code>는 드롭될 것입니다. 그렇지 않다면 <code>5</code>가 출력될 것입니다.</p>
<h3 id="panic은-abi-경계에서-멈출-수-있습니다"><a class="header" href="#panic은-abi-경계에서-멈출-수-있습니다"><code>panic</code>은 ABI 경계에서 멈출 수 있습니다</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[unsafe(no_mangle)]
extern "C" fn assert_nonzero(input: u32) {
    assert!(input != 0)
}
<span class="boring">}</span></code></pre></pre>
<p>만약 <code>assert_nonzero</code>가 인자 <code>0</code>과 함께 호출되면, 런타임은 <code>panic=abort</code>로 컴파일되었는지 여부와 관계없이 프로세스를 (안전하게) 중단시킬 것임을 보장합니다.</p>
<h3 id="panic을-선제적으로-포착하기"><a class="header" href="#panic을-선제적으로-포착하기"><code>panic</code>을 선제적으로 포착하기</a></h3>
<p>패닉이 발생할 수 있는 러스트 코드를 작성 중이고, 패닉 시 프로세스가 중단되는 것을 원치 않는다면 <a href="../std/panic/fn.catch_unwind.html"><code>catch_unwind</code></a>를 사용해야 합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::panic::catch_unwind;

#[unsafe(no_mangle)]
pub extern "C" fn oh_no() -&gt; i32 {
    let result = catch_unwind(|| {
        panic!("이크!");
    });
    match result {
        Ok(_) =&gt; 0,
        Err(_) =&gt; 1,
    }
}

fn main() {}</code></pre></pre>
<p><a href="../std/panic/fn.catch_unwind.html"><code>catch_unwind</code></a>은 언와인딩 패닉만을 포착하며, 프로세스를 중단시키는 패닉은 포착하지 못한다는 점에 유의하십시오. 자세한 내용은 <a href="../std/panic/fn.catch_unwind.html"><code>catch_unwind</code></a> 문서를 참조하십시오.</p>
<h2 id="불투명한opaque-구조체-표현하기"><a class="header" href="#불투명한opaque-구조체-표현하기">불투명한(opaque) 구조체 표현하기</a></h2>
<p>때때로 C 라이브러리는 어떤 것에 대한 포인터를 제공하고 싶어 하지만, 그 내부 세부 사항을 알리고 싶어 하지 않습니다. 안정적이고 간단한 방법은 <code>void *</code> 인자를 사용하는 것입니다.</p>
<pre><code class="language-c">void foo(void *arg);
void bar(void *arg);
</code></pre>
<p>우리는 러스트에서 <code>c_void</code> 타입을 사용하여 이를 표현할 수 있습니다:</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore">unsafe extern "C" {
    pub fn foo(arg: *mut libc::c_void);
    pub fn bar(arg: *mut libc::c_void);
}
<span class="boring">fn main() {}</span></code></pre>
<p>This is a perfectly valid way of handling the situation. However, we can do a bit better. To solve this, some C libraries will instead create a <code>struct</code>, where the details and memory layout of the struct are private. This gives some amount of type safety. These structures are called ‘opaque’. Here’s an example, in C:</p>
<pre><code class="language-c">struct Foo; /* Foo는 구조체이지만, 그 내용은 공개 인터페이스의 일부가 아닙니다 */
struct Bar;
void foo(struct Foo *arg);
void bar(struct Bar *arg);
</code></pre>
<p>러스트에서 이를 구현하기 위해, 우리만의 불투명 타입을 만들어 봅시다:</p>
<pre><pre class="playground"><code class="language-rust edition2024">#[repr(C)]
pub struct Foo {
    _data: (),
    _marker:
        core::marker::PhantomData&lt;(*mut u8, core::marker::PhantomPinned)&gt;,
}
#[repr(C)]
pub struct Bar {
    _data: (),
    _marker:
        core::marker::PhantomData&lt;(*mut u8, core::marker::PhantomPinned)&gt;,
}

unsafe extern "C" {
    pub fn foo(arg: *mut Foo);
    pub fn bar(arg: *mut Bar);
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>By including at least one private field and no constructor, we create an opaque type that we can't instantiate outside of this module. (A struct with no field could be instantiated by anyone.) We also want to use this type in FFI, so we have to add <code>#[repr(C)]</code>. The marker ensures the compiler does not mark the struct as <code>Send</code>, <code>Sync</code>, and <code>Unpin</code>. (<code>*mut u8</code> is not <code>Send</code> or <code>Sync</code>, <code>PhantomPinned</code> is not <code>Unpin</code>)</p>
<p>하지만 우리의 <code>Foo</code>와 <code>Bar</code> 타입은 서로 다르기 때문에, 둘 사이에 타입 안전성이 확보됩니다. 따라서 실수로 <code>Foo</code>에 대한 포인터를 <code>bar()</code>에 전달하는 일을 방지할 수 있습니다.</p>
<p>비어 있는 열거형(enum)을 FFI 타입으로 사용하는 것은 정말 좋지 않은 생각입니다. 컴파일러는 비어 있는 열거형이 거주 불가능(uninhabited)하다는 것에 의존하므로, <code>&amp;Empty</code> 타입의 값을 다루는 것은 매우 위험하며 정의되지 않은 동작을 유발하여 비정상적인 프로그램 동작으로 이어질 수 있습니다.</p>
<blockquote>
<p><strong>참고:</strong> 가장 간단한 방법은 "외부 타입(extern types)"을 사용하는 것입니다. 하지만 현재(2021년 6월 기준) 불안정한 상태이며 해결되지 않은 질문들이 남아 있습니다. 자세한 내용은 <a href="https://rust-lang.github.io/rfcs/1861-extern-types.html">RFC 페이지</a>와 <a href="https://github.com/rust-lang/rust/issues/43467">트래킹 이슈</a>를 참조하십시오.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="std-아래"><a class="header" href="#std-아래"><code>std</code> 아래</a></h1>
<p>이 섹션은 보통 <code>std</code> 크레이트에서 제공하는 기능들 중 <code>#![no_std]</code> 개발자들이 <code>#![no_std]</code> 바이너리 크레이트를 빌드하기 위해 직접 다루어야(즉, 제공해야) 하는 기능들을 문서화합니다.</p>
<h2 id="libc-사용하기"><a class="header" href="#libc-사용하기"><code>libc</code> 사용하기</a></h2>
<p><code>#[no_std]</code> 실행 파일을 빌드하려면 <code>libc</code>가 의존성으로 필요합니다. <code>Cargo.toml</code> 파일에서 다음과 같이 지정할 수 있습니다:</p>
<pre><code class="language-toml">[dependencies]
libc = { version = "0.2.146", default-features = false }
</code></pre>
<p>기본 기능(default features)이 비활성화되었음에 유의하십시오. 이는 매우 중요한 단계입니다. <strong><code>libc</code>의 기본 기능은 <code>std</code> 크레이트를 포함하므로 반드시 비활성화해야 합니다.</strong></p>
<p>또는 아래 예제에 나와 있는 것처럼 <code>extern crate libc;</code> 선언과 함께 불안정한 <code>rustc_private</code> 기능을 사용할 수도 있습니다. windows-msvc 타겟은 libc를 필요로 하지 않으며, 이에 따라 그들의 sysroot에는 <code>libc</code> 크레이트가 없다는 점에 유의하십시오. 아래의 <code>extern crate libc;</code>는 필요하지 않으며, windows-msvc 타겟에서 이를 사용하는 것은 컴파일 에러가 될 것입니다.</p>
<h2 id="std-없이-실행-파일-작성하기"><a class="header" href="#std-없이-실행-파일-작성하기"><code>std</code> 없이 실행 파일 작성하기</a></h2>
<p><code>#![no_std]</code> 실행 파일을 생성하려면 아마도 나이틀리 버전의 컴파일러가 필요할 것입니다. 많은 플랫폼에서 불안정한 <a href="https://doc.rust-lang.org/nightly/unstable-book/language-features/lang-items.html">언어 항목(lang item)</a>인 <code>eh_personality</code>를 제공해야 하기 때문입니다.</p>
<p>타겟에 적합한 진입점(entry point) 심볼을 정의해야 합니다. 예를 들어, 타겟과 관련된 <code>main</code>, <code>_start</code>, <code>WinMain</code> 또는 기타 시작점이 될 수 있습니다. 또한, 컴파일러가 진입점을 직접 생성하려고 시도하는 것을 방지하기 위해 <code>#![no_main]</code> 속성을 사용해야 합니다.</p>
<p>추가로, <a href="panic-handler.html">패닉 핸들러 함수</a>를 정의해야 합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024">#![feature(lang_items, core_intrinsics, rustc_private)]
#![allow(internal_features)]
#![no_std]
#![no_main]

// cfg(unix) 플랫폼에서 `panic = "unwind"` 빌드에 필요합니다.
#![feature(panic_unwind)]
extern crate unwind;

// crt0.o가 필요로 할 가능성이 높은 시스템 libc 라이브러리를 가져옵니다.
#[cfg(not(windows))]
extern crate libc;

use core::ffi::{c_char, c_int};
use core::panic::PanicInfo;

// 이 프로그램의 진입점입니다.
#[unsafe(no_mangle)] // 이 심볼이 `main`으로 출력에 포함되도록 보장합니다.
extern "C" fn main(_argc: c_int, _argv: *const *const c_char) -&gt; c_int {
    0
}

// 이 함수들은 컴파일러에 의해 사용되지만, 이런 빈 프로그램에는 사용되지 않습니다.
// 이들은 보통 `std`에 의해 제공됩니다.
#[lang = "eh_personality"]
fn rust_eh_personality() {}
#[panic_handler]
fn panic_handler(_info: &amp;PanicInfo) -&gt; ! { core::intrinsics::abort() }</code></pre></pre>
<p>rustup을 통해 표준 라이브러리의 바이너리 릴리스를 사용할 수 없는 타겟으로 작업하고 (아마도 <code>core</code> 크레이트를 직접 빌드하고 있음을 의미함), compiler-rt 내장 함수가 필요한 경우(즉, 실행 파일을 빌드할 때 <code>undefined reference to `__aeabi_memcpy'</code>와 같은 링커 에러가 발생하는 경우), 해당 내장 함수를 얻고 링커 에러를 해결하기 위해 <a href="https://crates.io/crates/compiler_builtins"><code>compiler_builtins</code> 크레이트</a>에 수동으로 링크해야 합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panic_handler"><a class="header" href="#panic_handler">#[panic_handler]</a></h1>
<p><code>#[panic_handler]</code>는 <code>#![no_std]</code> 애플리케이션에서 <code>panic!</code>의 동작을 정의하는 데 사용됩니다. <code>#[panic_handler]</code> 속성은 <code>fn(&amp;PanicInfo) -&gt; !</code> 시그니처를 가진 함수에 적용되어야 하며, 해당 함수는 바이너리 / dylib / cdylib 크레이트의 의존성 그래프 내에 단 _한 번_만 나타나야 합니다. <code>PanicInfo</code>의 API는 <a href="../core/panic/struct.PanicInfo.html">API 문서</a>에서 확인할 수 있습니다.</p>
<p><code>#![no_std]</code> 애플리케이션에는 <em>표준</em> 출력이 없으며 일부 <code>#![no_std]</code> 애플리케이션(예: 임베디드 애플리케이션)은 개발 및 릴리스에 따라 다른 패닉 동작이 필요하므로, <code>#[panic_handler]</code>만 포함하는 패닉 크레이트를 갖는 것이 도움이 될 수 있습니다. 이렇게 하면 애플리케이션은 단순히 다른 패닉 크레이트에 링크함으로써 패닉 동작을 쉽게 교체할 수 있습니다.</p>
<p>아래 예제는 애플리케이션이 개발 프로필(<code>cargo build</code>)로 컴파일되었는지 또는 릴리스 프로필(<code>cargo build --release</code>)로 컴파일되었는지에 따라 다른 패닉 동작을 갖는 것을 보여줍니다.</p>
<p><code>panic-semihosting</code> 크레이트 -- 세미호스팅을 사용하여 호스트 stderr에 패닉 메시지를 기록합니다:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">#![no_std]

use core::fmt::{Write, self};
use core::panic::PanicInfo;

struct HStderr {
    // ..
<span class="boring">    _0: (),
</span>}
<span class="boring">
</span><span class="boring">impl HStderr {
</span><span class="boring">    fn new() -&gt; HStderr { HStderr { _0: () } }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl fmt::Write for HStderr {
</span><span class="boring">    fn write_str(&amp;mut self, _: &amp;str) -&gt; fmt::Result { Ok(()) }
</span><span class="boring">}
</span>
#[panic_handler]
fn panic(info: &amp;PanicInfo) -&gt; ! {
    let mut host_stderr = HStderr::new();

    // "panicked at '$reason', src/main.rs:27:4"를 호스트 stderr에 기록합니다.
    writeln!(host_stderr, "{}", info).ok();

    loop {}
}</code></pre>
<p><code>panic-halt</code> 크레이트 -- 패닉 시 스레드를 중단합니다. 메시지는 버려집니다:</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">#![no_std]

use core::panic::PanicInfo;

#[panic_handler]
fn panic(_info: &amp;PanicInfo) -&gt; ! {
    loop {}
}</code></pre>
<p><code>app</code> 크레이트:</p>
<!-- ignore: requires the above crates -->
<pre><code class="language-rust ignore">#![no_std]

// dev 프로필
#[cfg(debug_assertions)]
extern crate panic_semihosting;

// release 프로필
#[cfg(not(debug_assertions))]
extern crate panic_halt;

fn main() {
    // ..
}</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/language-picker.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
