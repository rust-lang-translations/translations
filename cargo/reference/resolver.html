<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Dependency Resolution - The Cargo Book</title>


        <!-- Custom HTML head -->
        <style>
            dd {
                margin-bottom: 1em;
            }
        </style>
        
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/cargo";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/reference/resolver.md`;
                    } else {
                        canonical_href = `${base}/${lang}/reference/resolver.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("en");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Cargo Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/cargo/edit/master/src/doc/src/reference/resolver.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="dependency-resolution"><a class="header" href="#dependency-resolution">Dependency Resolution</a></h1>
<p>One of Cargo’s primary tasks is to determine the versions of dependencies to
use based on the version requirements specified in each package. This process
is called “dependency resolution” and is performed by the “resolver”. The
result of the resolution is stored in the <code>Cargo.lock</code> file which “locks” the
dependencies to specific versions, and keeps them fixed over time.
The <a href="../commands/cargo-tree.html"><code>cargo tree</code></a> command can be used to visualize the result of the
resolver.</p>
<h2 id="constraints-and-heuristics"><a class="header" href="#constraints-and-heuristics">Constraints and Heuristics</a></h2>
<p>In many cases there is no single “best” dependency resolution.
The resolver operates under various constraints and heuristics to find a generally applicable resolution.
To understand how these interact, it is helpful to have a coarse understanding of how dependency resolution works.</p>
<p>This pseudo-code approximates what Cargo’s resolver does:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn resolve(workspace: &amp;[Package], policy: Policy) -&gt; Option&lt;ResolveGraph&gt; {
    let dep_queue = Queue::new(workspace);
    let resolved = ResolveGraph::new();
    resolve_next(pkq_queue, resolved, policy)
}

fn resolve_next(dep_queue: Queue, resolved: ResolveGraph, policy: Policy) -&gt; Option&lt;ResolveGraph&gt; {
    let Some(dep_spec) = policy.pick_next_dep(dep_queue) else {
        // Done
        return Some(resolved);
    };

    if let Some(resolved) = policy.try_unify_version(dep_spec, resolved.clone()) {
        return Some(resolved);
    }

    let dep_versions = dep_spec.lookup_versions()?;
    let mut dep_versions = policy.filter_versions(dep_spec, dep_versions);
    while let Some(dep_version) = policy.pick_next_version(&amp;mut dep_versions) {
        if policy.needs_version_unification(dep_version, &amp;resolved) {
            continue;
        }

        let mut dep_queue = dep_queue.clone();
        dep_queue.enqueue(dep_version.dependencies);
        let mut resolved = resolved.clone();
        resolved.register(dep_version);
        if let Some(resolved) = resolve_next(dep_queue, resolved) {
            return Some(resolved);
        }
    }

    // No valid solution found, backtrack and `pick_next_version`
    None
}
<span class="boring">}</span></code></pre></pre>
<p>Key steps:</p>
<ul>
<li>Walking dependencies (<code>pick_next_dep</code>):
The order dependencies are walked can affect
how related version requirements for the same dependency get resolved, see unifying versions,
and how much the resolver backtracks, affecting resolver performance,</li>
<li>Unifying versions (<code>try_unify_version</code>, <code>needs_version_unification</code>):
Cargo reuses versions where possible to reduce build times and allow types from common dependencies to be passed between APIs.
If multiple versions would have been unified if it wasn’t for conflicts in their <a href="specifying-dependencies.html">dependency specifications</a>, Cargo will backtrack, erroring if no solution is found, rather than selecting multiple versions.
A <a href="specifying-dependencies.html">dependency specification</a> or Cargo may decide that a version is undesirable,
preferring to backtrack or error rather than use it.</li>
<li>Preferring versions (<code>pick_next_version</code>):
Cargo may decide that it should prefer a specific version,
falling back to the next version when backtracking.</li>
</ul>
<h3 id="version-numbers"><a class="header" href="#version-numbers">Version numbers</a></h3>
<p>Generally, Cargo prefers the highest version currently available.</p>
<p>For example, if you had a package in the resolve graph with:</p>
<pre><code class="language-toml">[dependencies]
bitflags = "*"
</code></pre>
<p>If at the time the <code>Cargo.lock</code> file is generated, the greatest version of
<code>bitflags</code> is <code>1.2.1</code>, then the package will use <code>1.2.1</code>.</p>
<p>For an example of a possible exception, see <a href="#rust-version">Rust version</a>.</p>
<h3 id="version-requirements"><a class="header" href="#version-requirements">Version requirements</a></h3>
<p>Package specify what versions they support, rejecting all others, through
<a href="specifying-dependencies.html#version-requirement-syntax">version requirements</a>.</p>
<p>For example, if you had a package in the resolve graph with:</p>
<pre><code class="language-toml">[dependencies]
bitflags = "1.0"  # meaning `&gt;=1.0.0,&lt;2.0.0`
</code></pre>
<p>If at the time the <code>Cargo.lock</code> file is generated, the greatest version of
<code>bitflags</code> is <code>1.2.1</code>, then the package will use <code>1.2.1</code> because it is the
greatest within the compatibility range. If <code>2.0.0</code> is published, it will
still use <code>1.2.1</code> because <code>2.0.0</code> is considered incompatible.</p>
<h3 id="semver-compatibility"><a class="header" href="#semver-compatibility">SemVer compatibility</a></h3>
<p>Cargo assumes packages follow <a href="https://semver.org/">SemVer</a> and will unify dependency versions if they are
<a href="https://semver.org/">SemVer</a> compatible according to the <a href="specifying-dependencies.html#default-requirements">Caret version requirements</a>.
If two compatible versions cannot be unified because of conflicting version requirements,
Cargo will error.</p>
<p>See the <a href="semver.html">SemVer Compatibility</a> chapter for guidance on what is considered a
“compatible” change.</p>
<p>Examples:</p>
<p>The following two packages will have their dependencies on <code>bitflags</code> unified because any version picked will be compatible with each other.</p>
<pre><code class="language-toml"># Package A
[dependencies]
bitflags = "1.0"  # meaning `&gt;=1.0.0,&lt;2.0.0`

# Package B
[dependencies]
bitflags = "1.1"  # meaning `&gt;=1.1.0,&lt;2.0.0`
</code></pre>
<p>The following packages will error because the version requirements conflict, selecting two distinct compatible versions.</p>
<pre><code class="language-toml"># Package A
[dependencies]
log = "=0.4.11"

# Package B
[dependencies]
log = "=0.4.8"
</code></pre>
<p>The following two packages will not have their dependencies on <code>rand</code> unified because only incompatible versions are available for each.
Instead, two different versions (e.g. 0.6.5 and 0.7.3) will be resolved and built.
This can lead to potential problems, see the <a href="#version-incompatibility-hazards">Version-incompatibility hazards</a> section for more details.</p>
<pre><code class="language-toml"># Package A
[dependencies]
rand = "0.7"  # meaning `&gt;=0.7.0,&lt;0.8.0`

# Package B
[dependencies]
rand = "0.6"  # meaning `&gt;=0.6.0,&lt;0.7.0`
</code></pre>
<p>Generally, the following two packages will not have their dependencies unified because incompatible versions are available that satisfy the version requirements:
Instead, two different versions (e.g. 0.6.5 and 0.7.3) will be resolved and built.
The application of other constraints or heuristics may cause these to be unified,
picking one version (e.g. 0.6.5).</p>
<pre><code class="language-toml"># Package A
[dependencies]
rand = "&gt;=0.6,&lt;0.8.0"

# Package B
[dependencies]
rand = "0.6"  # meaning `&gt;=0.6.0,&lt;0.7.0`
</code></pre>
<h4 id="version-incompatibility-hazards"><a class="header" href="#version-incompatibility-hazards">Version-incompatibility hazards</a></h4>
<p>When multiple versions of a crate appear in the resolve graph, this can cause
problems when types from those crates are exposed by the crates using them.
This is because the types and items are considered different by the Rust
compiler, even if they have the same name. Libraries should take care when
publishing a SemVer-incompatible version (for example, publishing <code>2.0.0</code>
after <code>1.0.0</code> has been in use), particularly for libraries that are widely
used.</p>
<p>The “<a href="https://github.com/dtolnay/semver-trick">semver trick</a>” is a workaround for this problem of publishing a breaking
change while retaining compatibility with older versions. The linked page goes
into detail about what the problem is and how to address it. In short, when a
library wants to publish a SemVer-breaking release, publish the new release,
and also publish a point release of the previous version that reexports the
types from the newer version.</p>
<p>These incompatibilities usually manifest as a compile-time error, but
sometimes they will only appear as a runtime misbehavior. For example, let’s
say there is a common library named <code>foo</code> that ends up appearing with both
version <code>1.0.0</code> and <code>2.0.0</code> in the resolve graph. If <a href="../../std/any/trait.Any.html#method.downcast_ref"><code>downcast_ref</code></a> is used
on a object created by a library using version <code>1.0.0</code>, and the code calling
<code>downcast_ref</code> is downcasting to a type from version <code>2.0.0</code>, the downcast
will fail at runtime.</p>
<p>It is important to make sure that if you have multiple versions of a library
that you are properly using them, especially if it is ever possible for the
types from different versions to be used together. The <a href="../commands/cargo-tree.html"><code>cargo tree -d</code></a> command can be used to identify duplicate versions and
where they come from. Similarly, it is important to consider the impact on the
ecosystem if you publish a SemVer-incompatible version of a popular library.</p>
<h3 id="rust-version"><a class="header" href="#rust-version">Rust version</a></h3>
<p>To support developing software with a minimum supported <a href="rust-version.html">Rust version</a>,
the resolver can take into account a dependency version’s compatibility with your Rust version.
This is controlled by the config field <a href="config.html#resolverincompatible-rust-versions"><code>resolver.incompatible-rust-versions</code></a>.</p>
<p>With the <code>fallback</code> setting, the resolver will prefer packages with a Rust version that is
less than or equal to your own Rust version.
For example, you are using Rust 1.85 to develop the following package:</p>
<pre><code class="language-toml">[package]
name = "my-cli"
rust-version = "1.62"

[dependencies]
clap = "4.0"  # resolves to 4.0.32
</code></pre>
<p>The resolver would pick version 4.0.32 because it has a Rust version of 1.60.0.</p>
<ul>
<li>4.0.0 is not picked because it is a <a href="#version-numbers">lower version number</a> despite it also having a Rust version of 1.60.0.</li>
<li>4.5.20 is not picked because it is incompatible with <code>my-cli</code>’s Rust version of 1.62 despite having a much <a href="#version-numbers">higher version</a> and it has a Rust version of 1.74.0 which is compatible with your 1.85 toolchain.</li>
</ul>
<p>If a version requirement does not include a Rust version compatible dependency version,
the resolver won’t error but will instead pick a version, even if its potentially suboptimal.
For example, you change the dependency on <code>clap</code>:</p>
<pre><code class="language-toml">[package]
name = "my-cli"
rust-version = "1.62"

[dependencies]
clap = "4.2"  # resolves to 4.5.20
</code></pre>
<p>No version of <code>clap</code> matches that <a href="#version-requirements">version requirement</a>
that is compatible with Rust version 1.62.
The resolver will then pick an incompatible version, like 4.5.20 despite it having a Rust version of 1.74.</p>
<p>When the resolver selects a dependency version of a package,
it does not know all the workspace members that will eventually have a transitive dependency on that version
and so it cannot take into account only the Rust versions relevant for that dependency.
The resolver has heuristics to find a “good enough” solution when workspace members have different Rust versions.
This applies even for packages in a workspace without a Rust version.</p>
<p>When a workspace has members with different Rust versions,
the resolver may pick a lower dependency version than necessary.
For example, you have the following workspace members:</p>
<pre><code class="language-toml">[package]
name = "a"
rust-version = "1.62"

[package]
name = "b"

[dependencies]
clap = "4.2"  # resolves to 4.5.20
</code></pre>
<p>Though package <code>b</code> does not have a Rust version and could use a higher version like 4.5.20,
4.0.32 will be selected because of package <code>a</code>’s Rust version of 1.62.</p>
<p>Or the resolver may pick too high of a version.
For example, you have the following workspace members:</p>
<pre><code class="language-toml">[package]
name = "a"
rust-version = "1.62"

[dependencies]
clap = "4.2"  # resolves to 4.5.20

[package]
name = "b"

[dependencies]
clap = "4.5"  # resolves to 4.5.20
</code></pre>
<p>Though each package has a version requirement for <code>clap</code> that would meet its own Rust version,
because of <a href="#version-numbers">version unification</a>,
the resolver will need to pick one version that works in both cases and that would be a version like 4.5.20.</p>
<h3 id="features"><a class="header" href="#features">Features</a></h3>
<p>For the purpose of generating <code>Cargo.lock</code>, the resolver builds the dependency
graph as-if all <a href="features.html">features</a> of all <a href="workspaces.html">workspace</a> members are enabled. This
ensures that any optional dependencies are available and properly resolved
with the rest of the graph when features are added or removed with the
<a href="features.html#command-line-feature-options"><code>--features</code> command-line flag</a>.
The resolver runs a second time to determine the actual features used when
<em>compiling</em> a crate, based on the features selected on the command-line.</p>
<p>Dependencies are resolved with the union of all features enabled on them. For
example, if one package depends on the <a href="https://crates.io/crates/im"><code>im</code></a> package with the <a href="https://github.com/bodil/im-rs/blob/v15.0.0/Cargo.toml#L46"><code>serde</code>
dependency</a> enabled and another package depends on it with the <a href="https://github.com/bodil/im-rs/blob/v15.0.0/Cargo.toml#L47"><code>rayon</code>
dependency</a> enabled, then <code>im</code> will be built with both features enabled, and
the <code>serde</code> and <code>rayon</code> crates will be included in the resolve graph. If no
packages depend on <code>im</code> with those features, then those optional dependencies
will be ignored, and they will not affect resolution.</p>
<p>When building multiple packages in a workspace (such as with <code>--workspace</code> or
multiple <code>-p</code> flags), the features of the dependencies of all of those
packages are unified. If you have a circumstance where you want to avoid that
unification for different workspace members, you will need to build them via
separate <code>cargo</code> invocations.</p>
<p>The resolver will skip over versions of packages that are missing required
features. For example, if a package depends on version <code>^1</code> of <a href="https://crates.io/crates/regex"><code>regex</code></a> with
the <a href="https://github.com/rust-lang/regex/blob/1.3.0/Cargo.toml#L56"><code>perf</code> feature</a>, then the oldest version it can select is <code>1.3.0</code>,
because versions prior to that did not contain the <code>perf</code> feature. Similarly,
if a feature is removed from a new release, then packages that require that
feature will be stuck on the older releases that contain that feature. It is
discouraged to remove features in a SemVer-compatible release. Beware that
optional dependencies also define an implicit feature, so removing an optional
dependency or making it non-optional can cause problems, see <a href="semver.html#cargo-remove-opt-dep">removing an
optional dependency</a>.</p>
<h4 id="feature-resolver-version-2"><a class="header" href="#feature-resolver-version-2">Feature resolver version 2</a></h4>
<p>When <code>resolver = "2"</code> is specified in <code>Cargo.toml</code> (see <a href="#resolver-versions">resolver
versions</a> below), a different feature resolver is used
which uses a different algorithm for unifying features. The version <code>"1"</code>
resolver will unify features for a package no matter where it is specified.
The version <code>"2"</code> resolver will avoid unifying features in the following
situations:</p>
<ul>
<li>
<p>Features for target-specific dependencies are not enabled if the target is
not currently being built. For example:</p>
<pre><code class="language-toml">[dependencies.common]
version = "1.0"
features = ["f1"]

[target.'cfg(windows)'.dependencies.common]
version = "1.0"
features = ["f2"]
</code></pre>
<p>When building this example for a non-Windows platform, the <code>f2</code> feature will
<em>not</em> be enabled.</p>
</li>
<li>
<p>Features enabled on <a href="specifying-dependencies.html#build-dependencies">build-dependencies</a> or proc-macros will not be unified
when those same dependencies are used as a normal dependency. For example:</p>
<pre><code class="language-toml">[dependencies]
log = "0.4"

[build-dependencies]
log = {version = "0.4", features=['std']}
</code></pre>
<p>When building the build script, the <code>log</code> crate will be built with the <code>std</code>
feature. When building the library of your package, it will not enable the
feature.</p>
</li>
<li>
<p>Features enabled on <a href="specifying-dependencies.html#development-dependencies">dev-dependencies</a> will not be unified when those same
dependencies are used as a normal dependency, unless those dev-dependencies
are currently being built. For example:</p>
<pre><code class="language-toml">[dependencies]
serde = {version = "1.0", default-features = false}

[dev-dependencies]
serde = {version = "1.0", features = ["std"]}
</code></pre>
<p>In this example, the library will normally link against <code>serde</code> without the
<code>std</code> feature. However, when built as a test or example, it will include the
<code>std</code> feature. For example, <code>cargo test</code> or <code>cargo build --all-targets</code> will
unify these features. Note that dev-dependencies in dependencies are always
ignored, this is only relevant for the top-level package or workspace
members.</p>
</li>
</ul>
<h3 id="links"><a class="header" href="#links"><code>links</code></a></h3>
<p>The <a href="manifest.html#the-links-field"><code>links</code> field</a> is used to ensure only one copy of a native library is
linked into a binary. The resolver will attempt to find a graph where there is
only one instance of each <code>links</code> name. If it is unable to find a graph that
satisfies that constraint, it will return an error.</p>
<p>For example, it is an error if one package depends on <a href="https://crates.io/crates/libgit2-sys"><code>libgit2-sys</code></a> version
<code>0.11</code> and another depends on <code>0.12</code>, because Cargo is unable to unify those,
but they both link to the <code>git2</code> native library. Due to this requirement, it
is encouraged to be very careful when making SemVer-incompatible releases with
the <code>links</code> field if your library is in common use.</p>
<h3 id="yanked-versions"><a class="header" href="#yanked-versions">Yanked versions</a></h3>
<p><a href="publishing.html#cargo-yank">Yanked releases</a> are those that are marked that they should not be
used. When the resolver is building the graph, it will ignore all yanked
releases unless they already exist in the <code>Cargo.lock</code> file or are explicitly
requested by the <a href="../commands/cargo-update.html#option-cargo-update---precise"><code>--precise</code></a> flag of <code>cargo update</code> (nightly only).</p>
<h2 id="dependency-updates"><a class="header" href="#dependency-updates">Dependency updates</a></h2>
<p>Dependency resolution is automatically performed by all Cargo commands that
need to know about the dependency graph. For example, <a href="../commands/cargo-build.html"><code>cargo build</code></a> will run
the resolver to discover all the dependencies to build. After the first time
it runs, the result is stored in the <code>Cargo.lock</code> file. Subsequent commands
will run the resolver, keeping dependencies locked to the versions in
<code>Cargo.lock</code> <em>if it can</em>.</p>
<p>If the dependency list in <code>Cargo.toml</code> has been modified, for example changing
the version of a dependency from <code>1.0</code> to <code>2.0</code>, then the resolver will select
a new version for that dependency that matches the new requirements. If that
new dependency introduces new requirements, those new requirements may also
trigger additional updates. The <code>Cargo.lock</code> file will be updated with the new
result. The <code>--locked</code> or <code>--frozen</code> flags can be used to change this behavior
to prevent automatic updates when requirements change, and return an error
instead.</p>
<p><a href="../commands/cargo-update.html"><code>cargo update</code></a> can be used to update the entries in <code>Cargo.lock</code> when new
versions are published. Without any options, it will attempt to update all
packages in the lock file. The <code>-p</code> flag can be used to target the update for
a specific package, and other flags such as <code>--recursive</code> or <code>--precise</code> can
be used to control how versions are selected.</p>
<h2 id="overrides"><a class="header" href="#overrides">Overrides</a></h2>
<p>Cargo has several mechanisms to override dependencies within the graph. The
<a href="overriding-dependencies.html">Overriding Dependencies</a> chapter goes into detail on how to use overrides.
The overrides appear as an overlay to a registry, replacing the patched
version with the new entry. Otherwise, resolution is performed like normal.</p>
<h2 id="dependency-kinds"><a class="header" href="#dependency-kinds">Dependency kinds</a></h2>
<p>There are three kinds of dependencies in a package: normal, <a href="specifying-dependencies.html#build-dependencies">build</a>, and
<a href="specifying-dependencies.html#development-dependencies">dev</a>. For the most part these are all treated the same from
the perspective of the resolver. One difference is that dev-dependencies for
non-workspace members are always ignored, and do not influence resolution.</p>
<p><a href="specifying-dependencies.html#platform-specific-dependencies">Platform-specific dependencies</a> with the <code>[target]</code> table are resolved as-if
all platforms are enabled. In other words, the resolver ignores the platform
or <code>cfg</code> expression.</p>
<h3 id="dev-dependency-cycles"><a class="header" href="#dev-dependency-cycles">dev-dependency cycles</a></h3>
<p>Usually the resolver does not allow cycles in the graph, but it does allow
them for <a href="specifying-dependencies.html#development-dependencies">dev-dependencies</a>. For example, project “foo” has a dev-dependency
on “bar”, which has a normal dependency on “foo” (usually as a “path”
dependency). This is allowed because there isn’t really a cycle from the
perspective of the build artifacts. In this example, the “foo” library is
built (which does not need “bar” because “bar” is only used for tests), and
then “bar” can be built depending on “foo”, then the “foo” tests can be built
linking to “bar”.</p>
<p>Beware that this can lead to confusing errors. In the case of building library
unit tests, there are actually two copies of the library linked into the final
test binary: the one that was linked with “bar”, and the one built that
contains the unit tests. Similar to the issues highlighted in the
<a href="#version-incompatibility-hazards">Version-incompatibility hazards</a> section, the types between the two are not
compatible. Be careful when exposing types of “foo” from “bar” in this
situation, since the “foo” unit tests won’t treat them the same as the local
types.</p>
<p>If possible, try to split your package into multiple packages and restructure
it so that it remains strictly acyclic.</p>
<h2 id="resolver-versions"><a class="header" href="#resolver-versions">Resolver versions</a></h2>
<p>Different resolver behavior can be specified through the resolver
version in <code>Cargo.toml</code> like this:</p>
<pre><code class="language-toml">[package]
name = "my-package"
version = "1.0.0"
resolver = "2"
</code></pre>
<ul>
<li><code>"1"</code> (default)</li>
<li><code>"2"</code> (<a href="manifest.html#the-edition-field"><code>edition = "2021"</code></a> default): Introduces changes in <a href="#features">feature
unification</a>. See the <a href="features.html#feature-resolver-version-2">features chapter</a> for more
details.</li>
<li><code>"3"</code> (<a href="manifest.html#the-edition-field"><code>edition = "2024"</code></a> default, requires Rust 1.84+): Change the default for <a href="config.html#resolverincompatible-rust-versions"><code>resolver.incompatible-rust-versions</code></a> from <code>allow</code> to <code>fallback</code></li>
</ul>
<p>The resolver is a global option that affects the entire workspace. The
<code>resolver</code> version in dependencies is ignored, only the value in the top-level
package will be used. If using a <a href="workspaces.html#virtual-workspace">virtual workspace</a>, the version should be
specified in the <code>[workspace]</code> table, for example:</p>
<pre><code class="language-toml">[workspace]
members = ["member1", "member2"]
resolver = "2"
</code></pre>
<blockquote>
<p><strong>MSRV:</strong> Requires 1.51+</p>
</blockquote>
<h2 id="recommendations"><a class="header" href="#recommendations">Recommendations</a></h2>
<p>The following are some recommendations for setting the version within your
package, and for specifying dependency requirements. These are general
guidelines that should apply to common situations, but of course some
situations may require specifying unusual requirements.</p>
<ul>
<li>
<p>Follow the <a href="semver.html">SemVer guidelines</a> when deciding how to update your version
number, and whether or not you will need to make a SemVer-incompatible
version change.</p>
</li>
<li>
<p>Use caret requirements for dependencies, such as <code>"1.2.3"</code>, for most
situations. This ensures that the resolver can be maximally flexible in
choosing a version while maintaining build compatibility.</p>
<ul>
<li>Specify all three components with the version you are currently using.
This helps set the minimum version that will be used, and ensures that
other users won’t end up with an older version of the dependency that
might be missing something that your package requires.</li>
<li>Avoid <code>*</code> requirements, as they are not allowed on <a href="https://crates.io/">crates.io</a>, and they
can pull in SemVer-breaking changes during a normal <code>cargo update</code>.</li>
<li>Avoid overly broad version requirements. For example, <code>&gt;=2.0.0</code> can pull
in any SemVer-incompatible version, like version <code>5.0.0</code>, which can result
in broken builds in the future.</li>
<li>Avoid overly narrow version requirements if possible. For example, if you
specify a tilde requirement like <code>bar="~1.3"</code>, and another package
specifies a requirement of <code>bar="1.4"</code>, this will fail to resolve, even
though minor releases should be compatible.</li>
</ul>
</li>
<li>
<p>Try to keep the dependency versions up-to-date with the actual minimum
versions that your library requires. For example, if you have a requirement
of <code>bar="1.0.12"</code>, and then in a future release you start using new features
added in the <code>1.1.0</code> release of “bar”, update your dependency requirement to
<code>bar="1.1.0"</code>.</p>
<p>If you fail to do this, it may not be immediately obvious because Cargo can
opportunistically choose the newest version when you run a blanket <code>cargo update</code>. However, if another user depends on your library, and runs <code>cargo update your-library</code>, it will <em>not</em> automatically update “bar” if it is
locked in their <code>Cargo.lock</code>. It will only update “bar” in that situation if
the dependency declaration is also updated. Failure to do so can cause
confusing build errors for the user using <code>cargo update your-library</code>.</p>
</li>
<li>
<p>If two packages are tightly coupled, then an <code>=</code> dependency requirement may
help ensure that they stay in sync. For example, a library with a companion
proc-macro library will sometimes make assumptions between the two libraries
that won’t work well if the two are out of sync (and it is never expected to
use the two libraries independently). The parent library can use an <code>=</code>
requirement on the proc-macro, and re-export the macros for easy access.</p>
</li>
<li>
<p><code>0.0.x</code> versions can be used for packages that are permanently unstable.</p>
</li>
</ul>
<p>In general, the stricter you make the dependency requirements, the more likely
it will be for the resolver to fail. Conversely, if you use requirements that
are too loose, it may be possible for new versions to be published that will
break the build.</p>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<p>The following illustrates some problems you may experience, and some possible
solutions.</p>
<h3 id="why-was-a-dependency-included"><a class="header" href="#why-was-a-dependency-included">Why was a dependency included?</a></h3>
<p>Say you see dependency <code>rand</code> in the <code>cargo check</code> output but don’t think it’s needed and want to understand why it’s being pulled in.</p>
<p>You can run</p>
<pre><code class="language-console">$ cargo tree --workspace --target all --all-features --invert rand
rand v0.8.5
└── ...

rand v0.8.5
└── ...
</code></pre>
<h3 id="why-was-that-feature-on-this-dependency-enabled"><a class="header" href="#why-was-that-feature-on-this-dependency-enabled">Why was that feature on this dependency enabled?</a></h3>
<p>You might identify that it was an activated feature that caused <code>rand</code> to show up.  <strong>To figure out which package activated the feature, you can add the <code>--edges features</code></strong></p>
<pre><code class="language-console">$ cargo tree --workspace --target all --all-features --edges features --invert rand
rand v0.8.5
└── ...

rand v0.8.5
└── ...
</code></pre>
<h3 id="unexpected-dependency-duplication"><a class="header" href="#unexpected-dependency-duplication">Unexpected dependency duplication</a></h3>
<p>You see multiple instances of <code>rand</code> when you run</p>
<pre><code class="language-console">$ cargo tree --workspace --target all --all-features --duplicates
rand v0.7.3
└── ...

rand v0.8.5
└── ...
</code></pre>
<p>The resolver algorithm has converged on a solution that includes two copies of a
dependency when one would suffice. For example:</p>
<pre><code class="language-toml"># Package A
[dependencies]
rand = "0.7"

# Package B
[dependencies]
rand = "&gt;=0.6"  # note: open requirements such as this are discouraged
</code></pre>
<p>In this example, Cargo may build two copies of the <code>rand</code> crate, even though a
single copy at version <code>0.7.3</code> would meet all requirements. This is because the
resolver’s algorithm favors building the latest available version of <code>rand</code> for
Package B, which is <code>0.8.5</code> at the time of this writing, and that is
incompatible with Package A’s specification. The resolver’s algorithm does not
currently attempt to “deduplicate” in this situation.</p>
<p>The use of open-ended version requirements like <code>&gt;=0.6</code> is discouraged in Cargo.
But, if you run into this situation, the <a href="../commands/cargo-update.html"><code>cargo update</code></a> command with the
<code>--precise</code> flag can be used to manually remove such duplications.</p>
<h3 id="why-wasnt-a-newer-version-selected"><a class="header" href="#why-wasnt-a-newer-version-selected">Why wasn’t a newer version selected?</a></h3>
<p>Say you noticed that the latest version of a dependency wasn’t selected when you ran:</p>
<pre><code class="language-console">$ cargo update
</code></pre>
<p>You can enable some extra logging to see why this happened:</p>
<pre><code class="language-console">$ env CARGO_LOG=cargo::core::resolver=trace cargo update
</code></pre>
<p><strong>Note:</strong> Cargo log targets and levels may change over time.</p>
<h3 id="semver-breaking-patch-release-breaks-the-build"><a class="header" href="#semver-breaking-patch-release-breaks-the-build">SemVer-breaking patch release breaks the build</a></h3>
<p>Sometimes a project may inadvertently publish a point release with a
SemVer-breaking change. When users update with <code>cargo update</code>, they will pick
up this new release, and then their build may break. In this situation, it is
recommended that the project should <a href="publishing.html#cargo-yank">yank</a> the release, and either remove the
SemVer-breaking change, or publish it as a new SemVer-major version increase.</p>
<p>If the change happened in a third-party project, if possible try to
(politely!) work with the project to resolve the issue.</p>
<p>While waiting for the release to be yanked, some workarounds depend on the
circumstances:</p>
<ul>
<li>If your project is the end product (such as a binary executable), just avoid
updating the offending package in <code>Cargo.lock</code>. This can be done with the
<code>--precise</code> flag in <a href="../commands/cargo-update.html"><code>cargo update</code></a>.</li>
<li>If you publish a binary on <a href="https://crates.io/">crates.io</a>, then you can temporarily add an <code>=</code>
requirement to force the dependency to a specific good version.
<ul>
<li>Binary projects can alternatively recommend users to use the <code>--locked</code>
flag with <a href="../commands/cargo-install.html"><code>cargo install</code></a> to use the original <code>Cargo.lock</code> that contains
the known good version.</li>
</ul>
</li>
<li>Libraries may also consider publishing a temporary new release with stricter
requirements that avoid the troublesome dependency. You may want to consider
using range requirements (instead of <code>=</code>) to avoid overly-strict
requirements that may conflict with other packages using the same
dependency. Once the problem has been resolved, you can publish another
point release that relaxes the dependency back to a caret requirement.</li>
<li>If it looks like the third-party project is unable or unwilling to yank the
release, then one option is to update your code to be compatible with the
changes, and update the dependency requirement to set the minimum version to
the new release. You will also need to consider if this is a SemVer-breaking
change of your own library, for example if it exposes types from the
dependency.</li>
</ul>
<script>
(function() {
    var fragments = {
        "#version-metadata": "specifying-dependencies.html#version-metadata",
        "#pre-releases": "specifying-dependencies.html#pre-releases",
        "#other-constraints": "#constraints-and-heuristics",
    };
    var target = fragments[window.location.hash];
    if (target) {
        var url = window.location.toString();
        var base = url.substring(0, url.lastIndexOf('/'));
        window.location.replace(base + "/" + target);
    }
})();
</script>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../reference/source-replacement.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../reference/features.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../reference/source-replacement.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../reference/features.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/language-picker.js"></script>


    </div>
    </body>
</html>
