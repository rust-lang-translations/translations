<!DOCTYPE HTML>
<html lang="ja" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Build Script Examples - The Cargo Book</title>


        <!-- Custom HTML head -->
        <style>
            dd {
                margin-bottom: 1em;
            }
        </style>
        
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/cargo";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/reference/build-script-examples.md`;
                    } else {
                        canonical_href = `${base}/${lang}/reference/build-script-examples.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ja");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/cargo.css">
        <link rel="stylesheet" href="../theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Cargo Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/cargo/edit/master/src/doc/src/reference/build-script-examples.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="build-script-examples"><a class="header" href="#build-script-examples">Build Script Examples</a></h1>
<p>The following sections illustrate some examples of writing build scripts.</p>
<p>Some common build script functionality can be found via crates on <a href="https://crates.io/">crates.io</a>. Check out the <a href="https://crates.io/keywords/build-dependencies"><code>build-dependencies</code> keyword</a> to see what is available. The following is a sample of some popular crates<sup class="footnote-reference"><a href="#†">1</a></sup>:</p>
<ul>
<li><a href="https://crates.io/crates/bindgen"><code>bindgen</code></a> — Automatically generate Rust FFI bindings to C libraries.</li>
<li><a href="https://crates.io/crates/cc"><code>cc</code></a> — Compiles C/C++/assembly.</li>
<li><a href="https://crates.io/crates/pkg-config"><code>pkg-config</code></a> — Detect system libraries using the <code>pkg-config</code> utility.</li>
<li><a href="https://crates.io/crates/cmake"><code>cmake</code></a> — Runs the <code>cmake</code> build tool to build a native library.</li>
<li><a href="https://crates.io/crates/autocfg"><code>autocfg</code></a>, <a href="https://crates.io/crates/rustc_version"><code>rustc_version</code></a>, <a href="https://crates.io/crates/version_check"><code>version_check</code></a> — These crates provide ways to implement conditional compilation based on the current <code>rustc</code> such as the version of the compiler.</li>
</ul>
<div class="footnote-definition" id="†"><sup class="footnote-definition-label">1</sup>
<p>This list is not an endorsement. Evaluate your dependencies to see which is right for your project.</p>
</div>
<h2 id="code-generation"><a class="header" href="#code-generation">Code generation</a></h2>
<p>Some Cargo packages need to have code generated just before they are compiled for various reasons. Here we’ll walk through a simple example which generates a library call as part of the build script.</p>
<p>First, let’s take a look at the directory structure of this package:</p>
<pre><code class="language-text">.
├── Cargo.toml
├── build.rs
└── src
    └── main.rs

1 directory, 3 files
</code></pre>
<p>Here we can see that we have a <code>build.rs</code> build script and our binary in <code>main.rs</code>. This package has a basic manifest:</p>
<pre><code class="language-toml"># Cargo.toml

[package]
name = "hello-from-generated-code"
version = "0.1.0"
edition = "2024"
</code></pre>
<p>Let’s see what’s inside the build script:</p>
<pre><pre class="playground"><code class="language-rust no_run">// build.rs

use std::env;
use std::fs;
use std::path::Path;

fn main() {
    let out_dir = env::var_os("OUT_DIR").unwrap();
    let dest_path = Path::new(&amp;out_dir).join("hello.rs");
    fs::write(
        &amp;dest_path,
        "pub fn message() -&gt; &amp;'static str {
            \"Hello, World!\"
        }
        "
    ).unwrap();
    println!("cargo::rerun-if-changed=build.rs");
}</code></pre></pre>
<p>There’s a couple of points of note here:</p>
<ul>
<li>The script uses the <code>OUT_DIR</code> environment variable to discover where the output files should be located. It can use the process’ current working directory to find where the input files should be located, but in this case we don’t have any input files.</li>
<li>In general, build scripts should not modify any files outside of <code>OUT_DIR</code>. It may seem fine on the first blush, but it does cause problems when you use such crate as a dependency, because there’s an <em>implicit</em> invariant that sources in <code>.cargo/registry</code> should be immutable. <code>cargo</code> won’t allow such scripts when packaging.
<ul>
<li>Sometimes, projects want to check in a generated file, and treat it as source code. However, in this case, the file shouldn’t be generated from <code>build.rs</code>. Instead, have a test or similar which checks that the file precisely matches the generated version <em>and fails if the result doesn’t match</em>, and run that test as part of your CI. (The test can generate a temporary file to compare to, and if you want to update the generated file, you can replace the checked-in file with that temporary file.)</li>
</ul>
</li>
<li>This script is relatively simple as it just writes out a small generated file. One could imagine that other more complex operations could take place such as generating a Rust module from a C header file or another language definition, for example.</li>
<li>The <a href="build-scripts.html#rerun-if-changed"><code>rerun-if-changed</code> instruction</a> tells Cargo that the build script only needs to re-run if the build script itself changes. Without this line, Cargo will automatically run the build script if any file in the package changes. If your code generation uses some input files, this is where you would print a list of each of those files.</li>
</ul>
<p>Next, let’s peek at the library itself:</p>
<pre><code class="language-rust ignore">// src/main.rs

include!(concat!(env!("OUT_DIR"), "/hello.rs"));

fn main() {
    println!("{}", message());
}</code></pre>
<p>This is where the real magic happens. The library is using the rustc-defined <a href="../../std/macro.include.html"><code>include!</code> macro</a> in combination with the <a href="../../std/macro.concat.html"><code>concat!</code></a> and <a href="../../std/macro.env.html"><code>env!</code></a> macros to include the generated file (<code>hello.rs</code>) into the crate’s compilation.</p>
<p>Using the structure shown here, crates can include any number of generated files from the build script itself.</p>
<h2 id="building-a-native-library"><a class="header" href="#building-a-native-library">Building a native library</a></h2>
<p>Sometimes it’s necessary to build some native C or C++ code as part of a package. This is another excellent use case of leveraging the build script to build a native library before the Rust crate itself. As an example, we’ll create a Rust library which calls into C to print “Hello, World!”.</p>
<p>Like above, let’s first take a look at the package layout:</p>
<pre><code class="language-text">.
├── Cargo.toml
├── build.rs
└── src
    ├── hello.c
    └── main.rs

1 directory, 4 files
</code></pre>
<p>Pretty similar to before! Next, the manifest:</p>
<pre><code class="language-toml"># Cargo.toml

[package]
name = "hello-world-from-c"
version = "0.1.0"
edition = "2024"
</code></pre>
<p>For now we’re not going to use any build dependencies, so let’s take a look at the build script now:</p>
<pre><pre class="playground"><code class="language-rust no_run">// build.rs

use std::process::Command;
use std::env;
use std::path::Path;

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();

    // Note that there are a number of downsides to this approach, the comments
    // below detail how to improve the portability of these commands.
    Command::new("gcc").args(&amp;["src/hello.c", "-c", "-fPIC", "-o"])
                       .arg(&amp;format!("{}/hello.o", out_dir))
                       .status().unwrap();
    Command::new("ar").args(&amp;["crus", "libhello.a", "hello.o"])
                      .current_dir(&amp;Path::new(&amp;out_dir))
                      .status().unwrap();

    println!("cargo::rustc-link-search=native={}", out_dir);
    println!("cargo::rustc-link-lib=static=hello");
    println!("cargo::rerun-if-changed=src/hello.c");
}</code></pre></pre>
<p>This build script starts out by compiling our C file into an object file (by invoking <code>gcc</code>) and then converting this object file into a static library (by invoking <code>ar</code>). The final step is feedback to Cargo itself to say that our output was in <code>out_dir</code> and the compiler should link the crate to <code>libhello.a</code> statically via the <code>-l static=hello</code> flag.</p>
<p>Note that there are a number of drawbacks to this hard-coded approach:</p>
<ul>
<li>The <code>gcc</code> command itself is not portable across platforms. For example it’s unlikely that Windows platforms have <code>gcc</code>, and not even all Unix platforms may have <code>gcc</code>. The <code>ar</code> command is also in a similar situation.</li>
<li>These commands do not take cross-compilation into account. If we’re cross compiling for a platform such as Android it’s unlikely that <code>gcc</code> will produce an ARM executable.</li>
</ul>
<p>Not to fear, though, this is where a <code>build-dependencies</code> entry would help! The Cargo ecosystem has a number of packages to make this sort of task much easier, portable, and standardized. Let’s try the <a href="https://crates.io/crates/cc"><code>cc</code> crate</a> from <a href="https://crates.io/">crates.io</a>. First, add it to the <code>build-dependencies</code> in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[build-dependencies]
cc = "1.0"
</code></pre>
<p>And rewrite the build script to use this crate:</p>
<pre><code class="language-rust ignore">// build.rs

fn main() {
    cc::Build::new()
        .file("src/hello.c")
        .compile("hello");
    println!("cargo::rerun-if-changed=src/hello.c");
}</code></pre>
<p>The <a href="https://crates.io/crates/cc"><code>cc</code> crate</a> abstracts a range of build script requirements for C code:</p>
<ul>
<li>It invokes the appropriate compiler (MSVC for windows, <code>gcc</code> for MinGW, <code>cc</code> for Unix platforms, etc.).</li>
<li>It takes the <code>TARGET</code> variable into account by passing appropriate flags to the compiler being used.</li>
<li>Other environment variables, such as <code>OPT_LEVEL</code>, <code>DEBUG</code>, etc., are all handled automatically.</li>
<li>The stdout output and <code>OUT_DIR</code> locations are also handled by the <code>cc</code> library.</li>
</ul>
<p>Here we can start to see some of the major benefits of farming as much functionality as possible out to common build dependencies rather than duplicating logic across all build scripts!</p>
<p>Back to the case study though, let’s take a quick look at the contents of the <code>src</code> directory:</p>
<pre><code class="language-c">// src/hello.c

#include &lt;stdio.h&gt;

void hello() {
    printf("Hello, World!\n");
}
</code></pre>
<pre><code class="language-rust ignore">// src/main.rs

// Note the lack of the `#[link]` attribute. We’re delegating the responsibility
// of selecting what to link over to the build script rather than hard-coding
// it in the source file.
unsafe extern { fn hello(); }

fn main() {
    unsafe { hello(); }
}</code></pre>
<p>And there we go! This should complete our example of building some C code from a Cargo package using the build script itself. This also shows why using a build dependency can be crucial in many situations and even much more concise!</p>
<p>We’ve also seen a brief example of how a build script can use a crate as a dependency purely for the build process and not for the crate itself at runtime.</p>
<h2 id="linking-to-system-libraries"><a class="header" href="#linking-to-system-libraries">Linking to system libraries</a></h2>
<p>This example demonstrates how to link a system library and how the build script is used to support this use case.</p>
<p>Quite frequently a Rust crate wants to link to a native library provided on the system to bind its functionality or just use it as part of an implementation detail. This is quite a nuanced problem when it comes to performing this in a platform-agnostic fashion. It is best, if possible, to farm out as much of this as possible to make this as easy as possible for consumers.</p>
<p>For this example, we will be creating a binding to the system’s zlib library. This is a library that is commonly found on most Unix-like systems that provides data compression. This is already wrapped up in the <a href="https://crates.io/crates/libz-sys"><code>libz-sys</code> crate</a>, but for this example, we’ll do an extremely simplified version. Check out <a href="https://github.com/rust-lang/libz-sys">the source code</a> for the full example.</p>
<p>To make it easy to find the location of the library, we will use the <a href="https://crates.io/crates/pkg-config"><code>pkg-config</code> crate</a>. This crate uses the system’s <code>pkg-config</code> utility to discover information about a library. It will automatically tell Cargo what is needed to link the library. This will likely only work on Unix-like systems with <code>pkg-config</code> installed. Let’s start by setting up the manifest:</p>
<pre><code class="language-toml"># Cargo.toml

[package]
name = "libz-sys"
version = "0.1.0"
edition = "2024"
links = "z"

[build-dependencies]
pkg-config = "0.3.16"
</code></pre>
<p>Take note that we included the <code>links</code> key in the <code>package</code> table. This tells Cargo that we are linking to the <code>libz</code> library. See <a href="#using-another-sys-crate">“Using another sys crate”</a> for an example that will leverage this.</p>
<p>The build script is fairly simple:</p>
<pre><code class="language-rust ignore">// build.rs

fn main() {
    pkg_config::Config::new().probe("zlib").unwrap();
    println!("cargo::rerun-if-changed=build.rs");
}</code></pre>
<p>Let’s round out the example with a basic FFI binding:</p>
<pre><code class="language-rust ignore">// src/lib.rs

use std::os::raw::{c_uint, c_ulong};

unsafe extern "C" {
    pub fn crc32(crc: c_ulong, buf: *const u8, len: c_uint) -&gt; c_ulong;
}

#[test]
fn test_crc32() {
    let s = "hello";
    unsafe {
        assert_eq!(crc32(0, s.as_ptr(), s.len() as c_uint), 0x3610a686);
    }
}</code></pre>
<p>Run <code>cargo build -vv</code> to see the output from the build script. On a system with <code>libz</code> already installed, it may look something like this:</p>
<pre><code class="language-text">[libz-sys 0.1.0] cargo::rustc-link-search=native=/usr/lib
[libz-sys 0.1.0] cargo::rustc-link-lib=z
[libz-sys 0.1.0] cargo::rerun-if-changed=build.rs
</code></pre>
<p>Nice! <code>pkg-config</code> did all the work of finding the library and telling Cargo where it is.</p>
<p>It is not unusual for packages to include the source for the library, and build it statically if it is not found on the system, or if a feature or environment variable is set. For example, the real <a href="https://crates.io/crates/libz-sys"><code>libz-sys</code> crate</a> checks the environment variable <code>LIBZ_SYS_STATIC</code> or the <code>static</code> feature to build it from source instead of using the system library. Check out <a href="https://github.com/rust-lang/libz-sys">the source</a> for a more complete example.</p>
<h2 id="using-another-sys-crate"><a class="header" href="#using-another-sys-crate">Using another <code>sys</code> crate</a></h2>
<p>When using the <code>links</code> key, crates may set metadata that can be read by other crates that depend on it. This provides a mechanism to communicate information between crates. In this example, we’ll be creating a C library that makes use of zlib from the real <a href="https://crates.io/crates/libz-sys"><code>libz-sys</code> crate</a>.</p>
<p>If you have a C library that depends on zlib, you can leverage the <a href="https://crates.io/crates/libz-sys"><code>libz-sys</code> crate</a> to automatically find it or build it. This is great for cross-platform support, such as Windows where zlib is not usually installed. <code>libz-sys</code> <a href="https://github.com/rust-lang/libz-sys/blob/3c594e677c79584500da673f918c4d2101ac97a1/build.rs#L156">sets the <code>include</code> metadata</a> to tell other packages where to find the header files for zlib. Our build script can read that metadata with the <code>DEP_Z_INCLUDE</code> environment variable. Here’s an example:</p>
<pre><code class="language-toml"># Cargo.toml

[package]
name = "z_user"
version = "0.1.0"
edition = "2024"

[dependencies]
libz-sys = "1.0.25"

[build-dependencies]
cc = "1.0.46"
</code></pre>
<p>Here we have included <code>libz-sys</code> which will ensure that there is only one <code>libz</code> used in the final library, and give us access to it from our build script:</p>
<pre><code class="language-rust ignore">// build.rs

fn main() {
    let mut cfg = cc::Build::new();
    cfg.file("src/z_user.c");
    if let Some(include) = std::env::var_os("DEP_Z_INCLUDE") {
        cfg.include(include);
    }
    cfg.compile("z_user");
    println!("cargo::rerun-if-changed=src/z_user.c");
}</code></pre>
<p>With <code>libz-sys</code> doing all the heavy lifting, the C source code may now include the zlib header, and it should find the header, even on systems where it isn’t already installed.</p>
<pre><code class="language-c">// src/z_user.c

#include "zlib.h"

// … rest of code that makes use of zlib.
</code></pre>
<h2 id="conditional-compilation"><a class="header" href="#conditional-compilation">Conditional compilation</a></h2>
<p>A build script may emit <a href="build-scripts.html#rustc-cfg"><code>rustc-cfg</code> instructions</a> which can enable conditions that can be checked at compile time. In this example, we’ll take a look at how the <a href="https://crates.io/crates/openssl"><code>openssl</code> crate</a> uses this to support multiple versions of the OpenSSL library.</p>
<p>The <a href="https://crates.io/crates/openssl-sys"><code>openssl-sys</code> crate</a> implements building and linking the OpenSSL library. It supports multiple different implementations (like LibreSSL) and multiple versions. It makes use of the <code>links</code> key so that it may pass information to other build scripts. One of the things it passes is the <code>version_number</code> key, which is the version of OpenSSL that was detected. The code in the build script looks something <a href="https://github.com/sfackler/rust-openssl/blob/dc72a8e2c429e46c275e528b61a733a66e7877fc/openssl-sys/build/main.rs#L216">like this</a>:</p>
<pre><code class="language-rust ignore">println!("cargo::metadata=version_number={openssl_version:x}");</code></pre>
<p>This instruction causes the <code>DEP_OPENSSL_VERSION_NUMBER</code> environment variable to be set in any crates that directly depend on <code>openssl-sys</code>.</p>
<p>The <code>openssl</code> crate, which provides the higher-level interface, specifies <code>openssl-sys</code> as a dependency. The <code>openssl</code> build script can read the version information generated by the <code>openssl-sys</code> build script with the <code>DEP_OPENSSL_VERSION_NUMBER</code> environment variable. It uses this to generate some <a href="https://github.com/sfackler/rust-openssl/blob/dc72a8e2c429e46c275e528b61a733a66e7877fc/openssl/build.rs#L18-L36"><code>cfg</code> values</a>:</p>
<pre><code class="language-rust ignore">// (portion of build.rs)

println!("cargo::rustc-check-cfg=cfg(ossl101,ossl102)");
println!("cargo::rustc-check-cfg=cfg(ossl110,ossl110g,ossl111)");

if let Ok(version) = env::var("DEP_OPENSSL_VERSION_NUMBER") {
    let version = u64::from_str_radix(&amp;version, 16).unwrap();

    if version &gt;= 0x1_00_01_00_0 {
        println!("cargo::rustc-cfg=ossl101");
    }
    if version &gt;= 0x1_00_02_00_0 {
        println!("cargo::rustc-cfg=ossl102");
    }
    if version &gt;= 0x1_01_00_00_0 {
        println!("cargo::rustc-cfg=ossl110");
    }
    if version &gt;= 0x1_01_00_07_0 {
        println!("cargo::rustc-cfg=ossl110g");
    }
    if version &gt;= 0x1_01_01_00_0 {
        println!("cargo::rustc-cfg=ossl111");
    }
}</code></pre>
<p>These <code>cfg</code> values can then be used with the <a href="../../reference/conditional-compilation.html#the-cfg-attribute"><code>cfg</code> attribute</a> or the <a href="../../std/macro.cfg.html"><code>cfg</code> macro</a> to conditionally include code. For example, SHA3 support was added in OpenSSL 1.1.1, so it is <a href="https://github.com/sfackler/rust-openssl/blob/dc72a8e2c429e46c275e528b61a733a66e7877fc/openssl/src/hash.rs#L67-L85">conditionally excluded</a> for older versions:</p>
<pre><code class="language-rust ignore">// (portion of openssl crate)

#[cfg(ossl111)]
pub fn sha3_224() -&gt; MessageDigest {
    unsafe { MessageDigest(ffi::EVP_sha3_224()) }
}</code></pre>
<p>Of course, one should be careful when using this, since it makes the resulting binary even more dependent on the build environment. In this example, if the binary is distributed to another system, it may not have the exact same shared libraries, which could cause problems.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../reference/build-scripts.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../reference/build-cache.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../reference/build-scripts.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../reference/build-cache.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/language-picker.js"></script>


    </div>
    </body>
</html>
