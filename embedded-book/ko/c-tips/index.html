<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>임베디드 C 개발자를 위한 팁 - The Embedded Rust Book</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/embedded-book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/c-tips/index.md`;
                    } else {
                        canonical_href = `${base}/${lang}/c-tips/index.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Embedded Rust Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="임베디드-c-개발자를-위한-팁"><a class="header" href="#임베디드-c-개발자를-위한-팁">임베디드 C 개발자를 위한 팁</a></h1>
<p>이 장에서는 Rust 작성을 시작하려는 숙련된 임베디드 C 개발자에게 유용할 수 있는 다양한 팁을 수집합니다. 특히 C에서 이미 익숙할 수 있는 것들이 Rust에서 어떻게 다른지 강조할 것입니다.</p>
<h2 id="전처리기"><a class="header" href="#전처리기">전처리기</a></h2>
<p>임베디드 C에서는 다음과 같은 다양한 목적으로 전처리기를 사용하는 것이 매우 일반적입니다.</p>
<ul>
<li><code>#ifdef</code>를 사용한 컴파일 타임 코드 블록 선택</li>
<li>컴파일 타임 배열 크기 및 계산</li>
<li>일반적인 패턴을 단순화하기 위한 매크로 (함수 호출 오버헤드를 피하기 위해)</li>
</ul>
<p>Rust에는 전처리기가 없으므로 이러한 많은 사용 사례가 다르게 처리됩니다. 이 섹션의 나머지 부분에서는 전처리기 사용에 대한 다양한 대안을 다룹니다.</p>
<h3 id="컴파일-타임-코드-선택"><a class="header" href="#컴파일-타임-코드-선택">컴파일 타임 코드 선택</a></h3>
<p>Rust에서 <code>#ifdef ... #endif</code>와 가장 가까운 것은 <a href="https://doc.rust-lang.org/cargo/reference/manifest.html#the-features-section">Cargo 기능</a>입니다. 이것들은 C 전처리기보다 약간 더 형식적입니다. 모든 가능한 기능은 크레이트별로 명시적으로 나열되며 켜거나 끌 수만 있습니다. 기능은 크레이트를 종속성으로 나열할 때 켜지며 추가적입니다. 종속성 트리의 모든 크레이트가 다른 크레이트에 대한 기능을 활성화하면 해당 기능은 해당 크레이트의 모든 사용자에게 활성화됩니다.</p>
<p>예를 들어, 신호 처리 기본 요소 라이브러리를 제공하는 크레이트가 있을 수 있습니다. 각 기본 요소는 컴파일하는 데 추가 시간이 걸리거나 피하고 싶은 큰 상수 테이블을 선언할 수 있습니다. <code>Cargo.toml</code>에서 각 구성 요소에 대한 Cargo 기능을 선언할 수 있습니다.</p>
<pre><code class="language-toml">[features]
FIR = []
IIR = []
</code></pre>
<p>그런 다음 코드에서 <code>#[cfg(feature="FIR")]</code>을 사용하여 포함할 내용을 제어합니다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 최상위 lib.rs에서

#[cfg(feature="FIR")]
pub mod fir;

#[cfg(feature="IIR")]
pub mod iir;
<span class="boring">}</span></code></pre></pre>
<p>마찬가지로 기능이 활성화되지 <em>않은</em> 경우에만 코드 블록을 포함하거나 기능의 조합이 활성화되거나 활성화되지 않은 경우에만 포함할 수 있습니다.</p>
<p>또한 Rust는 아키텍처에 따라 다른 코드를 선택하기 위해 <code>target_arch</code>와 같이 사용할 수 있는 여러 가지 자동으로 설정된 조건을 제공합니다. 조건부 컴파일 지원에 대한 자세한 내용은 Rust 참조의 <a href="https://doc.rust-lang.org/reference/conditional-compilation.html">조건부 컴파일</a> 장을 참조하십시오.</p>
<p>조건부 컴파일은 다음 문장이나 블록에만 적용됩니다. 현재 범위에서 블록을 사용할 수 없는 경우 <code>cfg</code> 속성을 여러 번 사용해야 합니다. 대부분의 경우 모든 코드를 포함하고 컴파일러가 최적화할 때 죽은 코드를 제거하도록 허용하는 것이 더 낫다는 점은 주목할 가치가 있습니다. 이는 사용자와 사용자에게 더 간단하며 일반적으로 컴파일러는 사용되지 않는 코드를 제거하는 데 좋은 역할을 합니다.</p>
<h3 id="컴파일-타임-크기-및-계산"><a class="header" href="#컴파일-타임-크기-및-계산">컴파일 타임 크기 및 계산</a></h3>
<p>Rust는 컴파일 타임에 평가될 수 있음이 보장되는 함수인 <code>const fn</code>을 지원하므로 배열 크기와 같이 상수가 필요한 곳에 사용할 수 있습니다. 이것은 위에서 언급한 기능과 함께 사용할 수 있습니다. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn array_size() -&gt; usize {
    #[cfg(feature="use_more_ram")]
    { 1024 }
    #[cfg(not(feature="use_more_ram"))]
    { 128 }
}

static BUF: [u32; array_size()] = [0u32; array_size()];
<span class="boring">}</span></code></pre></pre>
<p>이것들은 1.31부터 안정적인 Rust에 새로 추가되었으므로 문서는 아직 부족합니다. 이 글을 쓰는 시점에서 <code>const fn</code>에서 사용할 수 있는 기능도 매우 제한적입니다. 향후 Rust 릴리스에서는 <code>const fn</code>에서 허용되는 내용이 확장될 것으로 예상됩니다.</p>
<h3 id="매크로"><a class="header" href="#매크로">매크로</a></h3>
<p>Rust는 매우 강력한 <a href="https://doc.rust-lang.org/book/ch19-06-macros.html">매크로 시스템</a>을 제공합니다. C 전처리기는 소스 코드의 텍스트에 거의 직접적으로 작동하는 반면, Rust 매크로 시스템은 더 높은 수준에서 작동합니다. Rust 매크로에는 _예제별 매크로_와 _절차적 매크로_의 두 가지 종류가 있습니다. 전자는 더 간단하고 가장 일반적입니다. 함수 호출처럼 보이며 완전한 표현식, 문장, 항목 또는 패턴으로 확장될 수 있습니다. 절차적 매크로는 더 복잡하지만 Rust 언어에 매우 강력한 추가 기능을 허용합니다. 임의의 Rust 구문을 새로운 Rust 구문으로 변환할 수 있습니다.</p>
<p>일반적으로 C 전처리기 매크로를 사용했을 수 있는 곳에서는 대신 예제별 매크로가 작업을 수행할 수 있는지 확인하는 것이 좋습니다. 크레이트에서 정의하고 자신의 크레이트에서 쉽게 사용하거나 다른 사용자를 위해 내보낼 수 있습니다. 완전한 표현식, 문장, 항목 또는 패턴으로 확장되어야 하므로 변수 이름의 일부나 목록의 불완전한 항목 집합으로 확장되는 매크로와 같은 C 전처리기 매크로의 일부 사용 사례는 작동하지 않는다는 점에 유의하십시오.</p>
<p>Cargo 기능과 마찬가지로 매크로가 필요한지 여부를 고려해 볼 가치가 있습니다. 많은 경우 일반 함수가 더 이해하기 쉽고 매크로와 동일한 코드로 인라인됩니다. <code>#[inline]</code> 및 <code>#[inline(always)]</code> <a href="https://doc.rust-lang.org/reference/attributes.html#inline-attribute">속성</a>은 이 프로세스에 대한 추가 제어를 제공하지만 여기에서도 주의해야 합니다. 컴파일러는 적절한 경우 동일한 크레이트의 함수를 자동으로 인라인하므로 부적절하게 강제하면 실제로 성능이 저하될 수 있습니다.</p>
<p>전체 Rust 매크로 시스템을 설명하는 것은 이 팁 페이지의 범위를 벗어나므로 자세한 내용은 Rust 설명서를 참조하는 것이 좋습니다.</p>
<h2 id="빌드-시스템"><a class="header" href="#빌드-시스템">빌드 시스템</a></h2>
<p>대부분의 Rust 크레이트는 Cargo를 사용하여 빌드됩니다(필수는 아님). 이것은 전통적인 빌드 시스템의 많은 어려운 문제를 해결합니다. 그러나 빌드 프로세스를 사용자 정의하고 싶을 수도 있습니다. Cargo는 이 목적을 위해 <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html"><code>build.rs</code> 스크립트</a>를 제공합니다. 이들은 필요에 따라 Cargo 빌드 시스템과 상호 작용할 수 있는 Rust 스크립트입니다.</p>
<p>빌드 스크립트의 일반적인 사용 사례는 다음과 같습니다.</p>
<ul>
<li>빌드 시간 정보 제공, 예를 들어 빌드 날짜 또는 Git 커밋 해시를 실행 파일에 정적으로 포함</li>
<li>선택된 기능 또는 기타 로직에 따라 빌드 시 링커 스크립트 생성</li>
<li>Cargo 빌드 구성 변경</li>
<li>링크할 추가 정적 라이브러리 추가</li>
</ul>
<p>현재 빌드 후 스크립트에 대한 지원은 없습니다. 이는 빌드 객체에서 바이너리를 자동으로 생성하거나 빌드 정보를 인쇄하는 것과 같은 작업에 전통적으로 사용했을 수 있습니다.</p>
<h3 id="크로스-컴파일"><a class="header" href="#크로스-컴파일">크로스 컴파일</a></h3>
<p>빌드 시스템으로 Cargo를 사용하면 크로스 컴파일도 단순화됩니다. 대부분의 경우 Cargo에 <code>--target thumbv6m-none-eabi</code>를 알려주고 <code>target/thumbv6m-none-eabi/debug/myapp</code>에서 적절한 실행 파일을 찾으면 충분합니다.</p>
<p>Rust에서 기본적으로 지원하지 않는 플랫폼의 경우 해당 대상에 대해 <code>libcore</code>를 직접 빌드해야 합니다. 이러한 플랫폼에서는 Cargo를 대신하여 <code>libcore</code>를 자동으로 빌드해 주는 <a href="https://github.com/japaric/xargo">Xargo</a>를 사용할 수 있습니다.</p>
<h2 id="이터레이터-vs-배열-접근"><a class="header" href="#이터레이터-vs-배열-접근">이터레이터 vs 배열 접근</a></h2>
<p>C에서는 아마도 인덱스를 통해 배열에 직접 접근하는 데 익숙할 것입니다.</p>
<pre><code class="language-c">int16_t arr[16];
int i;
for(i=0; i&lt;sizeof(arr)/sizeof(arr[0]); i++) {
    process(arr[i]);
}
</code></pre>
<p>Rust에서는 이것이 안티패턴입니다. 인덱스 접근은 더 느릴 수 있고(경계 검사가 필요하므로) 다양한 컴파일러 최적화를 방해할 수 있습니다. 이것은 중요한 차이점이며 반복할 가치가 있습니다. Rust는 메모리 안전을 보장하기 위해 수동 배열 인덱싱에서 범위를 벗어난 접근을 확인하는 반면, C는 배열 외부를 기꺼이 인덱싱합니다.</p>
<p>대신 이터레이터를 사용하세요:</p>
<pre><code class="language-rust ignore">let arr = [0u16; 16];
for element in arr.iter() {
    process(*element);
}</code></pre>
<p>이터레이터는 C에서 수동으로 구현해야 하는 연결, 압축, 열거, 최소 또는 최대 찾기, 합계 등과 같은 강력한 기능을 제공합니다. 이터레이터 메서드는 또한 연결될 수 있어 매우 읽기 쉬운 데이터 처리 코드를 제공합니다.</p>
<p>See the <a href="https://doc.rust-lang.org/book/ch13-02-iterators.html">Iterators in the Book</a> and <a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html">Iterator documentation</a> for more details.</p>
<h2 id="참조-vs-포인터"><a class="header" href="#참조-vs-포인터">참조 vs 포인터</a></h2>
<p>Rust에서 포인터(<a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer"><em>원시 포인터</em></a>라고 불림)는 존재하지만, 역참조하는 것이 항상 <code>unsafe</code>로 간주되므로 특정 상황에서만 사용됩니다. Rust는 포인터 뒤에 무엇이 있을지에 대한 일반적인 보장을 제공할 수 없습니다.</p>
<p>대부분의 경우, 우리는 대신 <code>&amp;</code> 기호로 표시되는 <em>참조</em> 또는 <code>&amp;mut</code>로 표시되는 _가변 참조_를 사용합니다. 참조는 기본 값에 접근하기 위해 역참조될 수 있다는 점에서 포인터와 유사하게 동작하지만, Rust의 소유권 시스템의 핵심 부분입니다. Rust는 주어진 시간에 동일한 값에 대해 하나의 가변 참조 <em>또는</em> 여러 개의 비가변 참조만 가질 수 있도록 엄격하게 강제합니다.</p>
<p>실제로 이는 데이터에 대한 가변 접근이 필요한지 여부에 대해 더 신중해야 함을 의미합니다. C에서는 기본값이 가변이며 <code>const</code>에 대해 명시해야 하지만, Rust에서는 그 반대입니다.</p>
<p>원시 포인터를 여전히 사용할 수 있는 한 가지 상황은 하드웨어와 직접 상호 작용하는 경우(예: 버퍼에 대한 포인터를 DMA 주변 장치 레지스터에 쓰는 경우)이며, 모든 주변 장치 접근 크레이트에서 메모리 매핑된 레지스터를 읽고 쓸 수 있도록 내부적으로도 사용됩니다.</p>
<h2 id="휘발성-접근"><a class="header" href="#휘발성-접근">휘발성 접근</a></h2>
<p>C에서는 개별 변수에 <code>volatile</code>을 표시하여 컴파일러에게 변수 값이 접근 사이에 변경될 수 있음을 나타낼 수 있습니다. 휘발성 변수는 임베디드 컨텍스트에서 메모리 매핑된 레지스터에 일반적으로 사용됩니다.</p>
<p>Rust에서는 변수를 <code>volatile</code>로 표시하는 대신, 휘발성 접근을 수행하기 위해 특정 메서드를 사용합니다: <a href="https://doc.rust-lang.org/core/ptr/fn.read_volatile.html"><code>core::ptr::read_volatile</code></a> 및 <a href="https://doc.rust-lang.org/core/ptr/fn.write_volatile.html"><code>core::ptr::write_volatile</code></a>. 이 메서드들은 <code>*const T</code> 또는 <code>*mut T</code>(<em>원시 포인터</em>, 위에서 논의됨)를 받아 휘발성 읽기 또는 쓰기를 수행합니다.</p>
<p>예를 들어, C에서는 다음과 같이 작성할 수 있습니다.</p>
<pre><code class="language-c">volatile bool signalled = false;

void ISR() {
    // 인터럽트가 발생했음을 알립니다
    signalled = true;
}

void driver() {
    while(true) {
        // 신호가 올 때까지 대기
        while(!signalled) { WFI(); }
        // 신호 표시기 재설정
        signalled = false;
        // 인터럽트를 기다리던 작업을 수행
        run_task();
    }
}
</code></pre>
<p>Rust에서 이에 상응하는 것은 각 접근에 휘발성 메서드를 사용하는 것입니다.</p>
<pre><code class="language-rust ignore">static mut SIGNALLED: bool = false;

#[interrupt]
fn ISR() {
    // 인터럽트가 발생했음을 알립니다
    // (실제 코드에서는 원자적 타입과 같은 더 높은 수준의 기본 요소를 고려해야 합니다).
    unsafe { core::ptr::write_volatile(&amp;mut SIGNALLED, true) };
}

fn driver() {
    loop {
        // 신호가 올 때까지 대기
        while unsafe { !core::ptr::read_volatile(&amp;SIGNALLED) } {}
        // 신호 표시기 재설정
        unsafe { core::ptr::write_volatile(&amp;mut SIGNALLED, false) };
        // 인터럽트를 기다리던 작업을 수행
        run_task();
    }
}</code></pre>
<p>코드 샘플에서 몇 가지 주목할 점이 있습니다.</p>
<ul>
<li><code>&amp;mut SIGNALLED</code>를 <code>*mut T</code>를 요구하는 함수에 전달할 수 있습니다. <code>&amp;mut T</code>는 자동으로 <code>*mut T</code>로 변환되기 때문입니다(<code>*const T</code>도 마찬가지입니다).</li>
<li><code>read_volatile</code>/<code>write_volatile</code> 메서드는 <code>unsafe</code> 함수이므로 <code>unsafe</code> 블록이 필요합니다. 안전한 사용을 보장하는 것은 프로그래머의 책임입니다. 자세한 내용은 메서드 문서를 참조하십시오.</li>
</ul>
<p>이러한 함수를 코드에서 직접 요구하는 경우는 드뭅니다. 일반적으로 상위 수준 라이브러리에서 처리해 주기 때문입니다. 메모리 매핑된 주변 장치의 경우 주변 장치 접근 크레이트가 휘발성 접근을 자동으로 구현하며, 동시성 기본 요소의 경우 더 나은 추상화가 제공됩니다(<a href="../concurrency/index.html">동시성 장</a> 참조).</p>
<h2 id="팩-및-정렬된-타입"><a class="header" href="#팩-및-정렬된-타입">팩 및 정렬된 타입</a></h2>
<p>임베디드 C에서는 특정 하드웨어 또는 프로토콜 요구 사항을 충족하기 위해 변수가 특정 정렬을 가져야 하거나 구조체가 정렬되지 않고 팩되어야 한다고 컴파일러에 알리는 것이 일반적입니다.</p>
<p>Rust에서는 이것이 구조체 또는 유니온의 <code>repr</code> 속성에 의해 제어됩니다. 기본 표현은 레이아웃을 보장하지 않으므로 하드웨어 또는 C와 상호 운용되는 코드에는 사용해서는 안 됩니다. 컴파일러는 구조체 멤버를 재정렬하거나 패딩을 삽입할 수 있으며, 동작은 Rust의 향후 버전에서 변경될 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust">struct Foo {
    x: u16,
    y: u8,
    z: u16,
}

fn main() {
    let v = Foo { x: 0, y: 0, z: 0 };
    println!("{:p} {:p} {:p}", &amp;v.x, &amp;v.y, &amp;v.z);
}

// 0x7ffecb3511d0 0x7ffecb3511d4 0x7ffecb3511d2
// 패킹 개선을 위해 순서가 x, z, y로 변경되었습니다.</code></pre></pre>
<p>C와 상호 운용 가능한 레이아웃을 보장하려면 <code>repr(C)</code>를 사용하세요.</p>
<pre><pre class="playground"><code class="language-rust">#[repr(C)]
struct Foo {
    x: u16,
    y: u8,
    z: u16,
}

fn main() {
    let v = Foo { x: 0, y: 0, z: 0 };
    println!("{:p} {:p} {:p}", &amp;v.x, &amp;v.y, &amp;v.z);
}

// 0x7fffd0d84c60 0x7fffd0d84c62 0x7fffd0d84c64
// 순서는 유지되며 레이아웃은 시간이 지나도 변경되지 않습니다.
// `z`는 2바이트 정렬되어 있으므로 `y`와 `z` 사이에 1바이트 패딩이 존재합니다.</code></pre></pre>
<p>팩된 표현을 보장하려면 <code>repr(packed)</code>를 사용하세요.</p>
<pre><pre class="playground"><code class="language-rust">#[repr(packed)]
struct Foo {
    x: u16,
    y: u8,
    z: u16,
}

fn main() {
    let v = Foo { x: 0, y: 0, z: 0 };
    // 참조는 항상 정렬되어야 하므로, 구조체 필드의 주소를 확인하려면
    // `&amp;v.x`를 단순히 출력하는 대신 `std::ptr::addr_of!()`를 사용하여 원시 포인터를 얻습니다.
    let px = std::ptr::addr_of!(v.x);
    let py = std::ptr::addr_of!(v.y);
    let pz = std::ptr::addr_of!(v.z);
    println!("{:p} {:p} {:p}", px, py, pz);
}

// 0x7ffd33598490 0x7ffd33598492 0x7ffd33598493
// `y`와 `z` 사이에 패딩이 삽입되지 않아 `z`가 정렬되지 않았습니다.</code></pre></pre>
<p><code>repr(packed)</code>를 사용하면 타입의 정렬도 <code>1</code>로 설정됩니다.</p>
<p>마지막으로, 특정 정렬을 지정하려면 <code>repr(align(n))</code>을 사용하세요. 여기서 <code>n</code>은 정렬할 바이트 수이며 (2의 거듭제곱이어야 합니다):</p>
<pre><pre class="playground"><code class="language-rust">#[repr(C)]
#[repr(align(4096))]
struct Foo {
    x: u16,
    y: u8,
    z: u16,
}

fn main() {
    let v = Foo { x: 0, y: 0, z: 0 };
    let u = Foo { x: 0, y: 0, z: 0 };
    println!("{:p} {:p} {:p}", &amp;v.x, &amp;v.y, &amp;v.z);
    println!("{:p} {:p} {:p}", &amp;u.x, &amp;u.y, &amp;u.z);
}

// 0x7ffec909a000 0x7ffec909a002 0x7ffec909a004
// 0x7ffec909b000 0x7ffec909b002 0x7ffec909b004
// 두 인스턴스 `u`와 `v`는 4096바이트 정렬에 배치되었으며,
// 주소 끝의 `000`으로 증명됩니다.</code></pre></pre>
<p><code>repr(C)</code>와 <code>repr(align(n))</code>을 결합하여 정렬되고 C 호환 가능한 레이아웃을 얻을 수 있습니다. <code>repr(packed)</code>는 정렬을 <code>1</code>로 설정하므로 <code>repr(align(n))</code>과 <code>repr(packed)</code>를 결합하는 것은 허용되지 않습니다. 또한 <code>repr(packed)</code> 타입이 <code>repr(align(n))</code> 타입을 포함하는 것도 허용되지 않습니다.</p>
<p>타입 레이아웃에 대한 자세한 내용은 Rust 참조의 <a href="https://doc.rust-lang.org/reference/type-layout.html">타입 레이아웃</a> 장을 참조하십시오.</p>
<h2 id="기타-자료"><a class="header" href="#기타-자료">기타 자료</a></h2>
<ul>
<li>이 책에서:
<ul>
<li><a href="../interoperability/c-with-rust.html">Rust와 함께하는 약간의 C</a></li>
<li><a href="../interoperability/rust-with-c.html">C와 함께하는 약간의 Rust</a></li>
</ul>
</li>
<li><a href="https://docs.rust-embedded.org/faq.html">Rust 임베디드 FAQ</a></li>
<li><a href="http://blahg.josefsipek.net/?p=580">C 프로그래머를 위한 Rust 포인터</a></li>
<li><a href="https://github.com/diwic/reffers-rs/blob/master/docs/Pointers.md">포인터를 사용했었는데 - 이제 무엇을?</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../design-patterns/hal/gpio.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../interoperability/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../design-patterns/hal/gpio.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../interoperability/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/language-picker.js"></script>


    </div>
    </body>
</html>
