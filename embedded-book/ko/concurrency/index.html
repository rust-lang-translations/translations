<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>동시성 - The Embedded Rust Book</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/embedded-book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/concurrency/index.md`;
                    } else {
                        canonical_href = `${base}/${lang}/concurrency/index.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Embedded Rust Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="동시성"><a class="header" href="#동시성">동시성</a></h1>
<p>동시성은 프로그램의 다른 부분이 다른 시간에 또는 순서에 관계없이 실행될 수 있을 때 발생합니다. 임베디드 컨텍스트에서는 다음을 포함합니다:</p>
<ul>
<li>관련 인터럽트가 발생할 때마다 실행되는 인터럽트 핸들러,</li>
<li>마이크로프로세서가 프로그램의 여러 부분 사이를 정기적으로 전환하는 다양한 형태의 멀티스레딩,</li>
<li>일부 시스템에서는 각 코어가 동시에 프로그램의 다른 부분을 독립적으로 실행할 수 있는 다중 코어 마이크로프로세서.</li>
</ul>
<p>많은 임베디드 프로그램이 인터럽트를 처리해야 하므로 동시성은 조만간 발생할 것이며, 미묘하고 어려운 버그가 많이 발생할 수 있는 곳이기도 합니다. 다행히 Rust는 올바른 코드를 작성하는 데 도움이 되는 여러 추상화와 안전 보장을 제공합니다.</p>
<h2 id="동시성-없음"><a class="header" href="#동시성-없음">동시성 없음</a></h2>
<p>임베디드 프로그램에서 가장 간단한 동시성은 동시성이 없는 것입니다. 소프트웨어는 단일 메인 루프로 구성되어 계속 실행되며, 인터럽트는 전혀 없습니다. 때로는 이것이 당면한 문제에 완벽하게 적합합니다! 일반적으로 루프는 일부 입력을 읽고, 일부 처리를 수행하며, 일부 출력을 작성합니다.</p>
<pre><code class="language-rust ignore">#[entry]
fn main() {
    let peripherals = setup_peripherals();
    loop {
        let inputs = read_inputs(&amp;peripherals);
        let outputs = process(inputs);
        write_outputs(&amp;peripherals, outputs);
    }
}</code></pre>
<p>동시성이 없으므로 프로그램의 여러 부분 간에 데이터를 공유하거나 주변 장치에 대한 접근을 동기화하는 것에 대해 걱정할 필요가 없습니다. 이러한 간단한 접근 방식으로 해결할 수 있다면 훌륭한 해결책이 될 수 있습니다.</p>
<h2 id="전역-가변-데이터"><a class="header" href="#전역-가변-데이터">전역 가변 데이터</a></h2>
<p>비임베디드 Rust와 달리, 일반적으로 힙 할당을 생성하고 새로 생성된 스레드에 해당 데이터에 대한 참조를 전달하는 사치를 누릴 수 없습니다. 대신, 인터럽트 핸들러는 언제든지 호출될 수 있으며 우리가 사용하는 공유 메모리에 접근하는 방법을 알아야 합니다. 가장 낮은 수준에서는 인터럽트 핸들러와 메인 코드 모두 참조할 수 있는 <em>정적으로 할당된</em> 가변 메모리가 있어야 함을 의미합니다.</p>
<p>Rust에서 이러한 <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#accessing-or-modifying-a-mutable-static-variable"><code>static mut</code></a> 변수는 읽거나 쓰기에는 항상 안전하지 않습니다. 특별한 주의를 기울이지 않으면 변수에 대한 접근이 해당 변수에 접근하는 인터럽트에 의해 중간에 중단되는 경쟁 조건을 유발할 수 있기 때문입니다.</p>
<p>이러한 동작이 코드에서 미묘한 오류를 유발할 수 있는 예시로, 매 1초마다 일부 입력 신호의 상승 에지를 세는 임베디드 프로그램(주파수 카운터)을 고려해 보십시오:</p>
<pre><code class="language-rust ignore">static mut COUNTER: u32 = 0;

#[entry]
fn main() -&gt; ! {
    set_timer_1hz();
    let mut last_state = false;
    loop {
        let state = read_signal_level();
        if state &amp;&amp; !last_state {
            // 위험 - 실제로는 안전하지 않음! 데이터 경쟁을 유발할 수 있습니다.
            unsafe { COUNTER += 1 };
        }
        last_state = state;
    }
}

#[interrupt]
fn timer() {
    unsafe { COUNTER = 0; }
}</code></pre>
<p>매초 타이머 인터럽트는 카운터를 0으로 재설정합니다. 한편, 메인 루프는 지속적으로 신호를 측정하고 낮음에서 높음으로의 변경을 감지하면 카운터를 증가시킵니다. <code>COUNTER</code>는 <code>static mut</code>이므로 <code>unsafe</code>를 사용하여 접근해야 했으며, 이는 컴파일러에게 정의되지 않은 동작을 유발하지 않겠다고 약속하는 것을 의미합니다. 경쟁 조건을 발견할 수 있습니까? <code>COUNTER</code>의 증가는 원자적이라고 보장되지 않습니다. 실제로 대부분의 임베디드 플랫폼에서는 로드, 증가, 저장으로 분할됩니다. 로드 후 저장 전에 인터럽트가 발생하면 인터럽트가 반환된 후 0으로 재설정하는 것이 무시되고 해당 기간 동안 두 배 많은 전환을 계산하게 됩니다.</p>
<h2 id="임계-영역"><a class="header" href="#임계-영역">임계 영역</a></h2>
<p>그렇다면 데이터 경쟁에 대해 무엇을 할 수 있을까요? 간단한 접근 방식은 인터럽트가 비활성화된 컨텍스트인 _임계 영역_을 사용하는 것입니다. <code>main</code>에서 <code>COUNTER</code>에 대한 접근을 임계 영역으로 래핑하면 <code>COUNTER</code> 증가가 끝날 때까지 타이머 인터럽트가 발생하지 않도록 할 수 있습니다:</p>
<pre><code class="language-rust ignore">static mut COUNTER: u32 = 0;

#[entry]
fn main() -&gt; ! {
    set_timer_1hz();
    let mut last_state = false;
    loop {
        let state = read_signal_level();
        if state &amp;&amp; !last_state {
            // 새 임계 영역은 COUNTER에 대한 동기화된 접근을 보장합니다
            cortex_m::interrupt::free(|_| {
                unsafe { COUNTER += 1 };
            });
        }
        last_state = state;
    }
}

#[interrupt]
fn timer() {
    unsafe { COUNTER = 0; }
}</code></pre>
<p>이 예에서는 <code>cortex_m::interrupt::free</code>를 사용하지만 다른 플랫폼에는 임계 영역에서 코드를 실행하기 위한 유사한 메커니즘이 있습니다. 이것은 또한 인터럽트를 비활성화하고 일부 코드를 실행한 다음 인터럽트를 다시 활성화하는 것과 동일합니다.</p>
<p>두 가지 이유로 타이머 인터럽트 내부에 임계 영역을 넣을 필요가 없었습니다:</p>
<ul>
<li><code>COUNTER</code>에 0을 쓰는 것은 읽지 않기 때문에 경쟁의 영향을 받지 않습니다.</li>
<li>어쨌든 <code>main</code> 스레드에 의해 중단되지 않습니다.</li>
</ul>
<p><code>COUNTER</code>가 서로를 _선점_할 수 있는 여러 인터럽트 핸들러에 의해 공유되고 있었다면 각각 임계 영역이 필요할 수도 있습니다.<code>COUNTER</code>가 서로를 _선점_할 수 있는 여러 인터럽트 핸들러에 의해 공유되고 있었다면 각각 임계 영역이 필요할 수도 있습니다.</p>
<p>이것은 즉각적인 문제를 해결하지만, 여전히 신중하게 추론해야 하는 많은 안전하지 않은 코드를 작성해야 하며, 불필요하게 임계 영역을 사용하고 있을 수도 있습니다. 각 임계 영역은 일시적으로 인터럽트 처리를 일시 중지하므로 추가 코드 크기 및 더 높은 인터럽트 대기 시간 및 지터(인터럽트 처리에 더 오래 걸릴 수 있으며 처리될 때까지의 시간이 더 가변적임)와 관련된 비용이 발생합니다. 이것이 문제인지는 시스템에 따라 다르지만 일반적으로 피하는 것이 좋습니다.이것은 즉각적인 문제를 해결하지만, 여전히 신중하게 추론해야 하는 많은 안전하지 않은 코드를 작성해야 하며, 불필요하게 임계 영역을 사용하고 있을 수도 있습니다. 각 임계 영역은 일시적으로 인터럽트 처리를 일시 중지하므로 추가 코드 크기 및 더 높은 인터럽트 대기 시간 및 지터(인터럽트 처리에 더 오래 걸릴 수 있으며 처리될 때까지의 시간이 더 가변적임)와 관련된 비용이 발생합니다. 이것이 문제인지는 시스템에 따라 다르지만 일반적으로 피하는 것이 좋습니다.</p>
<p>임계 영역이 인터럽트가 발생하지 않도록 보장하지만 다중 코어 시스템에서는 독점성을 보장하지 않는다는 점은 주목할 가치가 있습니다! 다른 코어는 인터럽트 없이도 코어와 동일한 메모리에 행복하게 접근할 수 있습니다. 다중 코어를 사용하는 경우 더 강력한 동기화 기본 요소가 필요합니다.임계 영역이 인터럽트가 발생하지 않도록 보장하지만 다중 코어 시스템에서는 독점성을 보장하지 않는다는 점은 주목할 가치가 있습니다! 다른 코어는 인터럽트 없이도 코어와 동일한 메모리에 행복하게 접근할 수 있습니다. 다중 코어를 사용하는 경우 더 강력한 동기화 기본 요소가 필요합니다.</p>
<h2 id="원자적-접근"><a class="header" href="#원자적-접근">원자적 접근</a></h2>
<p>일부 플랫폼에서는 읽기-수정-쓰기 작업에 대한 보장을 제공하는 특수 원자적 명령을 사용할 수 있습니다. 특히 Cortex-M의 경우: <code>thumbv6</code>(Cortex-M0, Cortex-M0+)는 원자적 로드 및 저장 명령만 제공하는 반면, <code>thumbv7</code>(Cortex-M3 이상)은 전체 비교 및 교환(CAS) 명령을 제공합니다. 이러한 CAS 명령은 모든 인터럽트를 비활성화하는 강력한 방법에 대한 대안을 제공합니다. 증가를 시도할 수 있으며 대부분의 경우 성공하지만 중단된 경우 전체 증가 작업을 자동으로 다시 시도합니다. 이러한 원자적 작업은 다중 코어에서도 안전합니다.일부 플랫폼에서는 읽기-수정-쓰기 작업에 대한 보장을 제공하는 특수 원자적 명령을 사용할 수 있습니다. 특히 Cortex-M의 경우: <code>thumbv6</code>(Cortex-M0, Cortex-M0+)는 원자적 로드 및 저장 명령만 제공하는 반면, <code>thumbv7</code>(Cortex-M3 이상)은 전체 비교 및 교환(CAS) 명령을 제공합니다. 이러한 CAS 명령은 모든 인터럽트를 비활성화하는 강력한 방법에 대한 대안을 제공합니다. 증가를 시도할 수 있으며 대부분의 경우 성공하지만 중단된 경우 전체 증가 작업을 자동으로 다시 시도합니다. 이러한 원자적 작업은 다중 코어에서도 안전합니다.</p>
<pre><code class="language-rust ignore">use core::sync::atomic::{AtomicUsize, Ordering};

static COUNTER: AtomicUsize = AtomicUsize::new(0);

#[entry]
fn main() -&gt; ! {
    set_timer_1hz();
    let mut last_state = false;
    loop {
        let state = read_signal_level();
        if state &amp;&amp; !last_state {
            // `fetch_add`를 사용하여 COUNTER에 원자적으로 1을 더합니다
            COUNTER.fetch_add(1, Ordering::Relaxed);
        }
        last_state = state;
    }
}

#[interrupt]
fn timer() {
    // `store`를 사용하여 COUNTER에 직접 0을 씁니다
    COUNTER.store(0, Ordering::Relaxed)
}</code></pre>
<p>이번에는 <code>COUNTER</code>가 안전한 <code>static</code> 변수입니다. <code>AtomicUsize</code> 타입 덕분에 <code>COUNTER</code>는 인터럽트를 비활성화하지 않고도 인터럽트 핸들러와 메인 스레드 모두에서 안전하게 수정할 수 있습니다. 가능하면 이것이 더 나은 해결책이지만 플랫폼에서 지원되지 않을 수 있습니다.이번에는 <code>COUNTER</code>가 안전한 <code>static</code> 변수입니다. <code>AtomicUsize</code> 타입 덕분에 <code>COUNTER</code>는 인터럽트를 비활성화하지 않고도 인터럽트 핸들러와 메인 스레드 모두에서 안전하게 수정할 수 있습니다. 가능하면 이것이 더 나은 해결책이지만 플랫폼에서 지원되지 않을 수 있습니다.</p>
<p><a href="https://doc.rust-lang.org/core/sync/atomic/enum.Ordering.html"><code>Ordering</code></a>에 대한 참고 사항: 이것은 컴파일러와 하드웨어가 명령을 재정렬하는 방식에 영향을 미치며 캐시 가시성에도 영향을 미칩니다. 대상이 단일 코어 플랫폼이라고 가정하면 이 특정 경우에 <code>Relaxed</code>가 충분하고 가장 효율적인 선택입니다. 더 엄격한 순서는 컴파일러가 원자적 작업 주위에 메모리 장벽을 내보내도록 합니다. 원자적 작업을 사용하는 목적에 따라 이것이 필요할 수도 있고 필요하지 않을 수도 있습니다! 원자적 모델의 정확한 세부 사항은 복잡하며 다른 곳에서 가장 잘 설명되어 있습니다.<a href="https://doc.rust-lang.org/core/sync/atomic/enum.Ordering.html"><code>Ordering</code></a>에 대한 참고 사항: 이것은 컴파일러와 하드웨어가 명령을 재정렬하는 방식에 영향을 미치며 캐시 가시성에도 영향을 미칩니다. 대상이 단일 코어 플랫폼이라고 가정하면 이 특정 경우에 <code>Relaxed</code>가 충분하고 가장 효율적인 선택입니다. 더 엄격한 순서는 컴파일러가 원자적 작업 주위에 메모리 장벽을 내보내도록 합니다. 원자적 작업을 사용하는 목적에 따라 이것이 필요할 수도 있고 필요하지 않을 수도 있습니다! 원자적 모델의 정확한 세부 사항은 복잡하며 다른 곳에서 가장 잘 설명되어 있습니다.</p>
<p>원자성과 순서에 대한 자세한 내용은 <a href="https://doc.rust-lang.org/nomicon/atomics.html">노미콘</a>을 참조하십시오.</p>
<h2 id="추상화-보내기-및-동기화"><a class="header" href="#추상화-보내기-및-동기화">추상화, 보내기 및 동기화</a></h2>
<p>위의 해결책 중 어느 것도 특별히 만족스럽지 않습니다. 매우 신중하게 확인해야 하는 <code>unsafe</code> 블록이 필요하며 인체공학적이지 않습니다. 분명히 Rust에서는 더 잘할 수 있습니다!</p>
<p>카운터를 코드의 다른 곳에서 안전하게 사용할 수 있는 안전한 인터페이스로 추상화할 수 있습니다. 이 예에서는 임계 영역 카운터를 사용하지만 원자적 연산으로 매우 유사한 작업을 수행할 수 있습니다.</p>
<pre><code class="language-rust ignore">use core::cell::UnsafeCell;
use cortex_m::interrupt;

// 우리 카운터는 Rust의 내부 가변성의 핵심인 UnsafeCell&lt;u32&gt;를 감싸는 래퍼일 뿐입니다. 내부 가변성을 사용하면 COUNTER를 'static mut' 대신 'static'으로 만들 수 있지만 여전히 카운터 값을 변경할 수 있습니다.
struct CSCounter(UnsafeCell&lt;u32&gt;);

const CS_COUNTER_INIT: CSCounter = CSCounter(UnsafeCell::new(0));

impl CSCounter {
    pub fn reset(&amp;self, _cs: &amp;interrupt::CriticalSection) {
        // CriticalSection을 전달하도록 요구함으로써, 우리는 CriticalSection 내에서 작동해야 함을 알고 있으므로 이 안전하지 않은 블록(UnsafeCell::get을 호출하는 데 필요)을 자신 있게 사용할 수 있습니다.
        unsafe { *self.0.get() = 0 };
    }

    pub fn increment(&amp;self, _cs: &amp;interrupt::CriticalSection) {
        unsafe { *self.0.get() += 1 };
    }
}

// 정적 CSCounter를 허용하는 데 필요합니다. 아래 설명을 참조하십시오.
unsafe impl Sync for CSCounter {}

// COUNTER는 내부 가변성을 사용하므로 더 이상 'mut'가 아닙니다. 따라서 더 이상 접근하기 위해 안전하지 않은 블록이 필요하지 않습니다.
static COUNTER: CSCounter = CS_COUNTER_INIT;

#[entry]
fn main() -&gt; ! {
    set_timer_1hz();
    let mut last_state = false;
    loop {
        let state = read_signal_level();
        if state &amp;&amp; !last_state {
            // 여기에는 안전하지 않은 것이 없습니다!
            interrupt::free(|cs| COUNTER.increment(cs));
        }
        last_state = state;
    }
}

#[interrupt]
fn timer() {
    // 다른 인터럽트가 이 인터럽트를 선점할 수 없다는 것을 알고 있음에도 불구하고 유효한 cs 토큰을 얻기 위해 여기에 임계 영역을 입력해야 합니다.
    interrupt::free(|cs| COUNTER.reset(cs));

    // 정말 원한다면 오버헤드를 피하기 위해 안전하지 않은 코드를 사용하여 가짜 CriticalSection을 생성할 수 있습니다.
    // let cs = unsafe { interrupt::CriticalSection::new() };
}</code></pre>
<p>우리는 <code>unsafe</code> 코드를 신중하게 계획된 추상화 내부로 옮겼고, 이제 애플리케이션 코드에는 <code>unsafe</code> 블록이 포함되지 않습니다.</p>
<p>이 설계는 애플리케이션이 <code>CriticalSection</code> 토큰을 전달하도록 요구합니다. 이러한 토큰은 <code>interrupt::free</code>에 의해서만 안전하게 생성되므로, 하나를 전달하도록 요구함으로써 실제로 잠금을 수행하지 않고도 임계 영역 내에서 작동하고 있음을 보장합니다. 이 보장은 컴파일러에 의해 정적으로 제공됩니다. <code>cs</code>와 관련된 런타임 오버헤드는 없습니다. 여러 카운터가 있는 경우 여러 중첩된 임계 영역을 요구하지 않고도 모두 동일한 <code>cs</code>를 부여할 수 있습니다.</p>
<p>이것은 또한 Rust의 동시성에 대한 중요한 주제인 <a href="https://doc.rust-lang.org/nomicon/send-and-sync.html"><code>Send</code> 및 <code>Sync</code></a> 특성을 제기합니다. Rust 책을 요약하면, 타입은 다른 스레드로 안전하게 이동할 수 있을 때 Send이고, 여러 스레드 간에 안전하게 공유할 수 있을 때 Sync입니다. 임베디드 컨텍스트에서 우리는 인터럽트가 애플리케이션 코드와 별도의 스레드에서 실행되는 것으로 간주하므로, 인터럽트와 메인 코드 모두에서 접근하는 변수는 Sync여야 합니다.</p>
<p>Rust의 대부분의 타입에 대해 이 두 특성은 컴파일러에 의해 자동으로 파생됩니다. 그러나 <code>CSCounter</code>는 <a href="https://doc.rust-lang.org/core/cell/struct.UnsafeCell.html"><code>UnsafeCell</code></a>을 포함하므로 Sync가 아니므로 <code>static CSCounter</code>를 만들 수 없습니다. <code>static</code> 변수는 여러 스레드에서 접근할 수 있으므로 <em>반드시</em> Sync여야 합니다.</p>
<p><code>CSCounter</code>가 실제로 스레드 간에 안전하게 공유되도록 처리했음을 컴파일러에 알리기 위해 Sync 특성을 명시적으로 구현합니다. 이전의 임계 영역 사용과 마찬가지로 이것은 단일 코어 플랫폼에서만 안전합니다. 다중 코어의 경우 안전을 보장하기 위해 더 많은 노력이 필요합니다.</p>
<h2 id="뮤텍스"><a class="header" href="#뮤텍스">뮤텍스</a></h2>
<p>카운터 문제에 특정한 유용한 추상화를 만들었지만 동시성에 사용되는 일반적인 추상화가 많이 있습니다.</p>
<p>One such <em>synchronisation primitive</em> is a mutex, short for mutual exclusion. These constructs ensure exclusive access to a variable, such as our counter. A thread can attempt to <em>lock</em> (or <em>acquire</em>) the mutex, and either succeeds immediately, or blocks waiting for the lock to be acquired, or returns an error that the mutex could not be locked. While that thread holds the lock, it is granted access to the protected data. When the thread is done, it <em>unlocks</em> (or <em>releases</em>) the mutex, allowing another thread to lock it. In Rust, we would usually implement the unlock using the <a href="https://doc.rust-lang.org/core/ops/trait.Drop.html"><code>Drop</code></a> trait to ensure it is always released when the mutex goes out of scope.</p>
<p>인터럽트 핸들러와 함께 뮤텍스를 사용하는 것은 까다로울 수 있습니다. 인터럽트 핸들러가 차단되는 것은 일반적으로 허용되지 않으며, 메인 스레드가 잠금을 해제하기를 기다리며 차단되는 것은 특히 재앙적일 것입니다. 그러면 _교착 상태_가 발생하기 때문입니다(실행이 인터럽트 핸들러에 머물기 때문에 메인 스레드는 잠금을 절대 해제하지 않습니다). 교착 상태는 안전하지 않은 것으로 간주되지 않으며, 안전한 Rust에서도 가능합니다.</p>
<p>이러한 동작을 완전히 피하기 위해, 카운터 예제와 같이 잠그기 위해 임계 영역이 필요한 뮤텍스를 구현할 수 있습니다. 임계 영역이 잠금만큼 오래 지속되어야 하는 한, 뮤텍스의 잠금/잠금 해제 상태를 추적할 필요 없이 래핑된 변수에 대한 독점적인 접근 권한을 가질 수 있습니다.</p>
<p>사실 이것은 <code>cortex_m</code> 크레이트에서 우리를 위해 수행됩니다! 우리는 그것을 사용하여 카운터를 작성할 수 있었습니다:</p>
<pre><code class="language-rust ignore">use core::cell::Cell;
use cortex_m::interrupt::Mutex;

static COUNTER: Mutex&lt;Cell&lt;u32&gt;&gt; = Mutex::new(Cell::new(0));

#[entry]
fn main() -&gt; ! {
    set_timer_1hz();
    let mut last_state = false;
    loop {
        let state = read_signal_level();
        if state &amp;&amp; !last_state {
            interrupt::free(|cs|
                COUNTER.borrow(cs).set(COUNTER.borrow(cs).get() + 1));
        }
        last_state = state;
    }
}

#[interrupt]
fn timer() {
    // 뮤텍스를 만족시키기 위해 여기에 임계 영역을 입력해야 합니다.
    interrupt::free(|cs| COUNTER.borrow(cs).set(0));
}</code></pre>
<p>이제 우리는 <a href="https://doc.rust-lang.org/core/cell/struct.Cell.html"><code>Cell</code></a>을 사용하고 있습니다. 이것은 형제인 <code>RefCell</code>과 함께 안전한 내부 가변성을 제공하는 데 사용됩니다. 우리는 이미 Rust의 내부 가변성의 가장 낮은 계층인 <code>UnsafeCell</code>을 보았습니다. 이것은 값에 대한 여러 개의 가변 참조를 얻을 수 있지만 안전하지 않은 코드로만 가능합니다. <code>Cell</code>은 <code>UnsafeCell</code>과 같지만 안전한 인터페이스를 제공합니다. 현재 값의 복사본을 가져오거나 교체하는 것만 허용하고 참조를 가져오는 것은 허용하지 않으며, Sync가 아니므로 스레드 간에 공유할 수 없습니다. 이러한 제약 조건은 사용하기에 안전하다는 것을 의미하지만, <code>static</code>은 Sync여야 하므로 <code>static</code> 변수에서 직접 사용할 수 없습니다.</p>
<p>그렇다면 위의 예제는 왜 작동할까요? <code>Mutex&lt;T&gt;</code>는 <code>Cell</code>과 같이 Send인 모든 <code>T</code>에 대해 Sync를 구현합니다. 임계 영역 동안에만 내용에 대한 접근을 허용하기 때문에 안전하게 이 작업을 수행할 수 있습니다. 따라서 우리는 안전하지 않은 코드 없이 안전한 카운터를 얻을 수 있습니다!</p>
<p>이것은 우리 카운터의 <code>u32</code>와 같은 간단한 타입에는 좋지만, 복사가 아닌 더 복잡한 타입은 어떻습니까? 임베디드 컨텍스트에서 매우 일반적인 예는 일반적으로 복사가 아닌 주변 장치 구조체입니다. 이를 위해 <code>RefCell</code>을 사용할 수 있습니다.</p>
<h2 id="주변-장치-공유"><a class="header" href="#주변-장치-공유">주변 장치 공유</a></h2>
<p><code>svd2rust</code> 및 유사한 추상화를 사용하여 생성된 장치 크레이트는 한 번에 주변 장치 구조체의 인스턴스가 하나만 존재하도록 강제하여 주변 장치에 대한 안전한 접근을 제공합니다. 이것은 안전을 보장하지만 메인 스레드와 인터럽트 핸들러 모두에서 주변 장치에 접근하기 어렵게 만듭니다.</p>
<p>주변 장치 접근을 안전하게 공유하기 위해 이전에 본 <code>Mutex</code>를 사용할 수 있습니다. 또한 한 번에 주변 장치에 대한 참조가 하나만 제공되도록 런타임 검사를 사용하는 <a href="https://doc.rust-lang.org/core/cell/struct.RefCell.html"><code>RefCell</code></a>을 사용해야 합니다. 이것은 일반 <code>Cell</code>보다 오버헤드가 더 많지만, 복사본이 아닌 참조를 제공하므로 한 번에 하나만 존재하는지 확인해야 합니다.</p>
<p>마지막으로, 메인 코드에서 초기화된 후 주변 장치를 공유 변수로 이동하는 방법을 고려해야 합니다. 이를 위해 <code>Option</code> 타입을 사용할 수 있으며, <code>None</code>으로 초기화한 다음 나중에 주변 장치의 인스턴스로 설정합니다.</p>
<pre><code class="language-rust ignore">use core::cell::RefCell;
use cortex_m::interrupt::{self, Mutex};
use stm32f4::stm32f405;

static MY_GPIO: Mutex&lt;RefCell&lt;Option&lt;stm32f405::GPIOA&gt;&gt;&gt; =
    Mutex::new(RefCell::new(None));

#[entry]
fn main() -&gt; ! {
    // 주변 장치 싱글톤을 얻고 구성합니다.
    // 이 예제는 svd2rust에서 생성된 크레이트에서 가져왔지만
    // 대부분의 임베디드 장치 크레이트는 유사합니다.
    let dp = stm32f405::Peripherals::take().unwrap();
    let gpioa = &amp;dp.GPIOA;

    // Some sort of configuration function.
    // Assume it sets PA0 to an input and PA1 to an output.
    configure_gpio(gpioa);

    // GPIOA를 뮤텍스에 저장하고 이동합니다.
    interrupt::free(|cs| MY_GPIO.borrow(cs).replace(Some(dp.GPIOA)));
    // 더 이상 'gpioa' 또는 'dp.GPIOA'를 사용할 수 없으며, 대신 뮤텍스를 통해 접근해야 합니다.

    // MY_GPIO를 설정한 후에만 인터럽트를 활성화하도록 주의하십시오.
    // 그렇지 않으면 인터럽트가 여전히 None을 포함하는 동안 발생할 수 있으며,
    // 작성된 대로('unwrap()' 포함) 패닉이 발생합니다.
    set_timer_1hz();
    let mut last_state = false;
    loop {
        // 이제 뮤텍스를 통해 상태를 디지털 입력으로 읽습니다
        let state = interrupt::free(|cs| {
            let gpioa = MY_GPIO.borrow(cs).borrow();
            gpioa.as_ref().unwrap().idr.read().idr0().bit_is_set()
        });

        if state &amp;&amp; !last_state {
            // PA0에서 상승 에지를 감지하면 PA1을 높게 설정합니다.
            interrupt::free(|cs| {
                let gpioa = MY_GPIO.borrow(cs).borrow();
                gpioa.as_ref().unwrap().odr.modify(|_, w| w.odr1().set_bit());
            });
        }
        last_state = state;
    }
}

#[interrupt]
fn timer() {
    // 이번에는 인터럽트에서 PA0을 지우기만 하면 됩니다.
    interrupt::free(|cs| {
        // 인터럽트가 MY_GPIO가 설정된 후에 활성화되지 않았다는 것을 알고 있으므로 `unwrap()`을 사용할 수 있습니다. 그렇지 않으면 None 값의 가능성을 처리해야 합니다.
        let gpioa = MY_GPIO.borrow(cs).borrow();
        gpioa.as_ref().unwrap().odr.modify(|_, w| w.odr1().clear_bit());
    });
}</code></pre>
<p>상당히 많은 내용이므로 중요한 부분을 분석해 보겠습니다.</p>
<pre><code class="language-rust ignore">static MY_GPIO: Mutex&lt;RefCell&lt;Option&lt;stm32f405::GPIOA&gt;&gt;&gt; =
    Mutex::new(RefCell::new(None));</code></pre>
<p>이제 공유 변수는 <code>Option</code>을 포함하는 <code>RefCell</code> 주위의 <code>Mutex</code>입니다. <code>Mutex</code>는 임계 영역 동안에만 접근할 수 있도록 보장하므로 일반 <code>RefCell</code>이 Sync가 아니더라도 변수를 Sync로 만듭니다. <code>RefCell</code>은 <code>GPIOA</code>를 사용하는 데 필요한 참조를 사용하여 내부 가변성을 제공합니다. <code>Option</code>을 사용하면 이 변수를 빈 값으로 초기화하고 나중에 실제로 변수를 이동할 수 있습니다. 주변 장치 싱글톤에 정적으로 접근할 수 없으며 런타임에만 접근할 수 있으므로 이것이 필요합니다.</p>
<pre><code class="language-rust ignore">interrupt::free(|cs| MY_GPIO.borrow(cs).replace(Some(dp.GPIOA)));</code></pre>
<p>임계 영역 내에서 뮤텍스에 대해 <code>borrow()</code>를 호출할 수 있으며, 이는 <code>RefCell</code>에 대한 참조를 제공합니다. 그런 다음 <code>replace()</code>를 호출하여 새 값을 <code>RefCell</code>로 이동합니다.</p>
<pre><code class="language-rust ignore">interrupt::free(|cs| {
    let gpioa = MY_GPIO.borrow(cs).borrow();
    gpioa.as_ref().unwrap().odr.modify(|_, w| w.odr1().set_bit());
});</code></pre>
<p>마지막으로, <code>MY_GPIO</code>를 안전하고 동시적인 방식으로 사용합니다. 임계 영역은 평소와 같이 인터럽트 발생을 방지하고 뮤텍스를 빌릴 수 있도록 합니다. 그런 다음 <code>RefCell</code>은 <code>&amp;Option&lt;GPIOA&gt;</code>를 제공하고 빌린 상태로 유지되는 기간을 추적합니다. 해당 참조가 범위를 벗어나면 <code>RefCell</code>은 더 이상 빌리지 않았음을 나타내도록 업데이트됩니다.</p>
<p><code>GPIOA</code>를 <code>&amp;Option</code> 밖으로 이동할 수 없으므로 <code>as_ref()</code>를 사용하여 <code>&amp;Option&lt;&amp;GPIOA&gt;</code>로 변환해야 합니다. 마지막으로 <code>unwrap()</code>하여 주변 장치를 수정할 수 있는 <code>&amp;GPIOA</code>를 얻을 수 있습니다.</p>
<p>공유 리소스에 대한 가변 참조가 필요한 경우 <code>borrow_mut</code> 및 <code>deref_mut</code>를 대신 사용해야 합니다. 다음 코드는 TIM2 타이머를 사용하는 예제를 보여줍니다.</p>
<pre><code class="language-rust ignore">use core::cell::RefCell;
use core::ops::DerefMut;
use cortex_m::interrupt::{self, Mutex};
use cortex_m::asm::wfi;
use stm32f4::stm32f405;

static G_TIM: Mutex&lt;RefCell&lt;Option&lt;Timer&lt;stm32::TIM2&gt;&gt;&gt;&gt; =
	Mutex::new(RefCell::new(None));

#[entry]
fn main() -&gt; ! {
    let mut cp = cm::Peripherals::take().unwrap();
    let dp = stm32f405::Peripherals::take().unwrap();

    // 어떤 종류의 타이머 구성 함수입니다.
    // TIM2 타이머, 해당 NVIC 인터럽트를 구성하고
    // 마지막으로 타이머를 시작한다고 가정합니다.
// 어떤 종류의 타이머 구성 함수입니다.
    // TIM2 타이머, 해당 NVIC 인터럽트를 구성하고
    // 마지막으로 타이머를 시작한다고 가정합니다.
    let tim = configure_timer_interrupt(&amp;mut cp, dp);

    interrupt::free(|cs| {
        G_TIM.borrow(cs).replace(Some(tim));
    });

    loop {
        wfi();
    }
}

#[interrupt]
fn timer() {
    interrupt::free(|cs| {
        if let Some(ref mut tim)) =  G_TIM.borrow(cs).borrow_mut().deref_mut() {
            tim.start(1.hz());
        }
    });
}
</code></pre>
<p>휴! 이것은 안전하지만 다루기에는 약간 번거롭습니다. 우리가 할 수 있는 다른 일이 있을까요?</p>
<h2 id="rtic"><a class="header" href="#rtic">RTIC</a></h2>
<p>RTIC 프레임워크(실시간 인터럽트 기반 동시성의 약자)는 한 가지 대안입니다. 정적 우선순위를 적용하고 'static mut' 변수("리소스")에 대한 액세스를 추적하여 공유 리소스에 항상 안전하게 액세스할 수 있도록 정적으로 보장하며, 항상 임계 영역에 들어가고 참조 계산(예: 'RefCell')을 사용하는 오버헤드가 필요하지 않습니다. 이는 교착 상태가 없음을 보장하고 매우 낮은 시간 및 메모리 오버헤드를 제공하는 등 여러 가지 이점이 있습니다.</p>
<p>이 프레임워크에는 명시적인 공유 상태의 필요성을 줄여주는 메시지 전달과 같은 다른 기능과 주어진 시간에 실행되도록 작업을 예약하는 기능이 포함되어 있어 주기적인 작업을 구현하는 데 사용할 수 있습니다. 자세한 내용은 <a href="https://rtic.rs">설명서</a>를 확인하십시오!</p>
<h2 id="실시간-운영-체제"><a class="header" href="#실시간-운영-체제">실시간 운영 체제</a></h2>
<p>임베디드 동시성을 위한 또 다른 일반적인 모델은 실시간 운영 체제(RTOS)입니다. 현재 Rust에서는 잘 연구되지 않았지만 기존 임베디드 개발에서는 널리 사용됩니다. 오픈 소스 예로는 <a href="https://freertos.org/">FreeRTOS</a> 및 <a href="http://chibios.org/">ChibiOS</a>가 있습니다. 이러한 RTOS는 스레드가 제어를 양보할 때(협력적 멀티태스킹이라고 함) 또는 일반 타이머 또는 인터럽트(선점형 멀티태스킹)를 기반으로 CPU가 전환하는 여러 애플리케이션 스레드를 실행하기 위한 지원을 제공합니다. RTOS는 일반적으로 뮤텍스 및 기타 동기화 기본 요소를 제공하며 종종 DMA 엔진과 같은 하드웨어 기능과 상호 운용됩니다.</p>
<p>이 글을 쓰는 시점에는 참고할 만한 Rust RTOS 예제가 많지 않지만 흥미로운 분야이므로 이 공간을 주목하십시오!</p>
<h2 id="다중-코어"><a class="header" href="#다중-코어">다중 코어</a></h2>
<p>임베디드 프로세서에 두 개 이상의 코어가 있는 것이 더 일반적이 되어 동시성에 복잡성을 한층 더 더합니다. 임계 영역을 사용하는 모든 예제(<code>cortex_m::interrupt::Mutex</code> 포함)는 유일한 다른 실행 스레드가 인터럽트 스레드라고 가정하지만 다중 코어 시스템에서는 더 이상 그렇지 않습니다. 대신 다중 코어용으로 설계된 동기화 기본 요소(대칭 다중 처리를 위해 SMP라고도 함)가 필요합니다.</p>
<p>처리 시스템이 모든 코어에서 원자성이 유지되도록 보장하므로 일반적으로 이전에 본 원자적 명령을 사용합니다.</p>
<p>이러한 주제를 자세히 다루는 것은 현재 이 책의 범위를 벗어나지만 일반적인 패턴은 단일 코어의 경우와 동일합니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../portability/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../collections/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../portability/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../collections/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/language-picker.js"></script>


    </div>
    </body>
</html>
