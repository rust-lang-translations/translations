<!DOCTYPE HTML>
<html lang="ru" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Пути для ссылки на элемент в дереве модулей - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ru");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Пути-для-ссылки-на-элемент-в-дереве-модулей"><a class="header" href="#Пути-для-ссылки-на-элемент-в-дереве-модулей">Пути для ссылки на элемент в дереве модулей</a></h2>
<p>Чтобы показать Rust, где искать элемент в дереве модулей, мы используем путь: так же, как мы используем путь при навигации по файловой системе. Чтобы вызвать функцию, нам нужно знать её путь.</p>
<p>Пути бывают двух видов:</p>
<ul>
<li><em>Абсолютный путь</em> — это полный путь, начинающийся от корня крейта; для кода из внешнего крейта абсолютный путь начинается с имени крейта, а для кода из текущего крейта он начинается со слова <code>crate</code>.</li>
<li><em>Относительный путь</em> — это путь, начинающийся с текущего модуля и использующий ключевые слова <code>self</code> и <code>super</code> или идентификатор в текущем модуле.</li>
</ul>
<p>Как абсолютные, так и относительные пути состоят из одного или нескольких идентификаторов, разделяемых двойными двоеточиями (<code>::</code>).</p>
<p>Вернёмся к Листингу 7-1. Скажем, мы хотим вызвать функцию <code>add_to_waitlist</code>. Это то же самое, что спросить: какой путь до функции <code>add_to_waitlist</code>? В Листинге 7-3 мы немного упростили код Листинга 7-1, удалив некоторые модули и функции.</p>
<p>Мы покажем два способа вызова функции <code>add_to_waitlist</code> из новой функции  <code>eat_at_restaurant</code>, определённой в корне крейта. Эти пути правильные, но остаётся ещё одна проблема, которая не позволит этому примеру скомпилироваться как есть. Мы скоро объясним, какая именно.</p>
<p>Функция <code>eat_at_restaurant</code> является частью общедоступного API нашего библиотечного крейта, поэтому мы помечаем её ключевым словом <code>pub</code>. В разделе <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#%D0%A0%D0%B0%D1%81%D0%BA%D1%80%D1%8B%D1%82%D0%B8%D0%B5-%D0%BF%D1%83%D1%82%D0%B5%D0%B9-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D0%BE%D0%B3%D0%BE-%D1%81%D0%BB%D0%BE%D0%B2%D0%B0-pub">"Раскрытие путей с помощью ключевого слова <code>pub</code>"</a><!-- ignore --> мы рассмотрим <code>pub</code> более подробно.</p>
<Listing number="7-3" file-name="src/lib.rs" caption="Calling the `add_to_waitlist` function using absolute and relative paths">
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Абсолютный путь
    crate::front_of_house::hosting::add_to_waitlist();

    // Относительный путь
    front_of_house::hosting::add_to_waitlist();
}</code></pre>
</Listing>
<p>В первом вызове функции <code>add_to_waitlist</code> из <code>eat_at_restaurant</code> мы используем абсолютный путь. Функция <code>add_to_waitlist</code> определена в том же крейте, что и <code>eat_at_restaurant</code>, и это означает, что мы можем использовать ключевое слово <code>crate</code> в начале абсолютного пути. Затем мы подключаем каждый из последующих дочерних модулей, пока не составим путь до <code>add_to_waitlist</code>. Вы можете представить себе файловую систему с такой же структурой: мы указываем путь <code>/front_of_house/hosting/add_to_waitlist</code> для запуска программы <code>add_to_waitlist</code>; использование имени <code>crate</code> в качестве корня крейта аналогично использованию <code>/</code> для указания корня файловой системы в вашей оболочке (shell).</p>
<p>Во втором вызове <code>add_to_waitlist</code> из <code>eat_at_restaurant</code> мы используем относительный путь. Путь начинается с имени модуля <code>front_of_house</code>, определённого на том же уровне дерева модулей, что и <code>eat_at_restaurant</code>. Аналогом пути в файловой системе было бы <code>front_of_house/hosting/add_to_waitlist</code>. Начало пути с имени модуля означает, что путь является относительным.</p>
<p>Выбор, использовать относительный или абсолютный путь, является решением, которое вы примете на основании вашего проекта. Решение зависит от того, с какой вероятностью вы переместите объявление элемента отдельно от или вместе с кодом, использующим этот элемент. Например, в случае перемещения модуля <code>front_of_house</code> и его функции <code>eat_at_restaurant</code> в другой модуль с именем <code>customer_experience</code>, будет необходимо обновить абсолютный путь до <code>add_to_waitlist</code>, но относительный путь всё равно будет действителен. Однако, если мы переместим отдельно функцию <code>eat_at_restaurant</code> в модуль с именем <code>dining</code>, то абсолютный путь вызова <code>add_to_waitlist</code> останется прежним, а относительный путь нужно будет обновить. Мы предпочитаем указывать абсолютные пути, потому что это позволяет проще перемещать определения кода и вызовы элементов независимо друг от друга.</p>
<p>Давайте попробуем скомпилировать код из Листинга 7-3 и выяснить, почему он всё ещё не компилируется. Ошибка, которую мы получаем, показана в Листинге 7-4.</p>
<Listing number="7-4" caption="Compiler errors from building the code in Listing 7-3">
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `hosting` is private
 --&gt; src/lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^  --------------- function `add_to_waitlist` is not publicly re-exported
  |                            |
  |                            private module
  |
note: the module `hosting` is defined here
 --&gt; src/lib.rs:2:5
  |
2 |     mod hosting {
  |     ^^^^^^^^^^^

error[E0603]: module `hosting` is private
  --&gt; src/lib.rs:12:21
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^  --------------- function `add_to_waitlist` is not publicly re-exported
   |                     |
   |                     private module
   |
note: the module `hosting` is defined here
  --&gt; src/lib.rs:2:5
   |
2  |     mod hosting {
   |     ^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` (lib) due to 2 previous errors
</code></pre>
</Listing>
<p>Сообщения об ошибках говорят о том, что модуль <code>hosting</code> является приватным. Другими словами, у нас есть правильные пути к модулю <code>hosting</code> и функции <code>add_to_waitlist</code>, но Rust не позволяет нам использовать их, потому что у него нет доступа к приватным определениям. В Rust все элементы (функции, методы, структуры, перечисления, модули и константы) по умолчанию являются закрытыми для родительских модулей. Если вы хотите сделать элемент (например, функцию или структуру) приватным, вы помещаете его в модуль.</p>
<p>Элементы в родительском модуле не могут использовать приватные элементы внутри дочерних модулей, но элементы в дочерних модулях могут использовать элементы своих модулей-предков. Это связано с тем, что дочерние модули оборачивают и скрывают детали своей реализации, но дочерние модули могут видеть контекст, в котором они определены. Продолжая нашу метафору, подумайте о правилах приватности как о задней части ресторана: то, что там происходит, скрыто от клиентов ресторана, но офис-менеджеры могут видеть и делать всё в ресторане, которым они управляют.</p>
<p>В Rust решили, что система модулей должна функционировать таким образом, чтобы по умолчанию скрывать детали реализации. Таким образом, вы знаете, какие части внутреннего кода вы можете менять, не нарушая работы внешнего кода. Тем не менее, Rust даёт нам возможность открывать внутренние части кода дочерних модулей для внешних модулей-предков, используя ключевое слово <code>pub</code>, чтобы делать элемент общедоступным.</p>
<h3 id="Раскрытие-путей-с-помощью-ключевого-слова-pub"><a class="header" href="#Раскрытие-путей-с-помощью-ключевого-слова-pub">Раскрытие путей с помощью ключевого слова <code>pub</code></a></h3>
<p>Давайте вернёмся к ошибке в Листинге 7-4, которая говорит, что модуль <code>hosting</code> является приватным. Мы хотим, чтобы функция <code>eat_at_restaurant</code> из родительского модуля имела доступ к функции <code>add_to_waitlist</code> в дочернем модуле, поэтому мы помечаем модуль <code>hosting</code> ключевым словом <code>pub</code>, как показано в Листинге 7-5.</p>
<Listing number="7-5" file-name="src/lib.rs" caption="Declaring the `hosting` module as `pub` to use it from `eat_at_restaurant`">
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

// -- код сокращён --
<span class="boring">pub fn eat_at_restaurant() {
</span><span class="boring">    // Абсолютный путь
</span><span class="boring">    crate::front_of_house::hosting::add_to_waitlist();
</span><span class="boring">
</span><span class="boring">    // Относительный путь
</span><span class="boring">    front_of_house::hosting::add_to_waitlist();
</span><span class="boring">}</span></code></pre>
</Listing>
<p>К сожалению, код в Листинге 7-5 всё ещё приводит к ошибке, показанной в Листинге 7-6.</p>
<Listing number="7-6" caption="Compiler errors from building the code in Listing 7-5">
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: function `add_to_waitlist` is private
 --&gt; src/lib.rs:9:37
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                                     ^^^^^^^^^^^^^^^ private function
  |
note: the function `add_to_waitlist` is defined here
 --&gt; src/lib.rs:3:9
  |
3 |         fn add_to_waitlist() {}
  |         ^^^^^^^^^^^^^^^^^^^^

error[E0603]: function `add_to_waitlist` is private
  --&gt; src/lib.rs:12:30
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                              ^^^^^^^^^^^^^^^ private function
   |
note: the function `add_to_waitlist` is defined here
  --&gt; src/lib.rs:3:9
   |
3  |         fn add_to_waitlist() {}
   |         ^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` (lib) due to 2 previous errors
</code></pre>
</Listing>
<p>Что произошло? Добавление ключевого слова <code>pub</code> перед <code>mod hosting</code> сделало модуль общедоступным. После этого изменения, если мы можем получить доступ к модулю <code>front_of_house</code>, то мы можем получить доступ к модулю <code>hosting</code>. Но <em>содержимое</em> модуля <code>hosting</code> всё ещё является приватным: превращение модуля в общедоступный модуль не делает его содержимое общедоступным. Ключевое слово <code>pub</code> позволяет внешнему коду в модулях-предках обращаться только к модулю, без доступа ко внутреннему коду. Поскольку модули являются контейнерами, мы мало что можем сделать, просто сделав модуль общедоступным; нам нужно пойти дальше и сделать один или несколько элементов в модуле общедоступными.</p>
<p>Ошибки в Листинге 7-6 говорят, что функция <code>add_to_waitlist</code> является приватной. Правила приватности применяются к структурам, перечислениям, функциям и методам, также как и к модулям.</p>
<p>Давайте сделаем функцию <code>add_to_waitlist</code> также общедоступной, добавив ключевое слово <code>pub</code> перед её определением, как показано в Листинге 7-7.</p>
<Listing number="7-7" file-name="src/lib.rs" caption="Adding the `pub` keyword to `mod hosting` and `fn add_to_waitlist` lets us call the function from `eat_at_restaurant`">
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

// -- код сокращён --
<span class="boring">pub fn eat_at_restaurant() {
</span><span class="boring">    // Абсолютный путь
</span><span class="boring">    crate::front_of_house::hosting::add_to_waitlist();
</span><span class="boring">
</span><span class="boring">    // Относительный путь
</span><span class="boring">    front_of_house::hosting::add_to_waitlist();
</span><span class="boring">}</span></code></pre>
</Listing>
<p>Код наконец-то компилируется! Чтобы понять, почему добавление ключевого слова <code>pub</code> позволяет нам использовать эти пути для <code>add_to_waitlist</code> в соответствии с правилами приватности, давайте рассмотрим абсолютный и относительный пути.</p>
<p>В случае абсолютного пути, мы начинаем с <code>crate</code>, корня дерева модулей нашего крейта. Модуль <code>front_of_house</code> определён в корне крейта. Хотя <code>front_of_house</code> не является общедоступным, но поскольку функция <code>eat_at_restaurant</code> определена в том же модуле, что и <code>front_of_house</code> (то есть, <code>eat_at_restaurant</code> и <code>front_of_house</code> являются потомками одного родителя), мы можем ссылаться на <code>front_of_house</code> из <code>eat_at_restaurant</code>. Далее идёт модуль <code>hosting</code>, помеченный как <code>pub</code>. Мы можем получить доступ к родительскому модулю модуля <code>hosting</code>, поэтому мы можем получить доступ и к <code>hosting</code>. Наконец, функция <code>add_to_waitlist</code> помечена как <code>pub</code>, и так как мы можем получить доступ к её родительскому модулю, то вызов этой функции разрешён!</p>
<p>В случае относительного пути, логика такая же, как для абсолютного пути, за исключением первого шага: вместо того, чтобы начинаться с корня крейта, путь начинается с <code>front_of_house</code>. Модуль <code>front_of_house</code> определён в том же модуле, что и <code>eat_at_restaurant</code>, поэтому относительный путь, начинающийся с модуля, в котором определена <code>eat_at_restaurant</code>, тоже работает. Тогда по причине того, что <code>hosting</code> и <code>add_to_waitlist</code> помечены как <code>pub</code>, остальная часть пути работает и вызов этой функции разрешён!</p>
<p>Если вы планируете предоставить общий доступ к своему библиотечному крейту, чтобы другие проекты могли использовать ваш код, помните: ваш общедоступный API — это ваш контракт с пользователями вашего крейта, определяющий, как они могут взаимодействовать с вашим кодом. Есть много соображений по поводу управления изменениями в вашем общедоступном API, чтобы сделать зависимость от вашего крейта необременительной. Эти соображения выходят за рамки этой книги; если вам интересна эта тема, ознакомьтесь с <a href="https://rust-lang.github.io/api-guidelines/">The Rust API Guidelines</a>.</p>
<blockquote>
<h4 id="Лучшие-практики-для-пакетов-с-бинарным-и-библиотечным-крейтами"><a class="header" href="#Лучшие-практики-для-пакетов-с-бинарным-и-библиотечным-крейтами">Лучшие практики для пакетов с бинарным и библиотечным крейтами</a></h4>
<p>Мы упоминали, что пакет может содержать как корневой модуль бинарного крейта <em>src/main.rs</em>, так и корневой модуль библиотечного крейта <em>src/lib.rs</em>, и оба крейта будут по умолчанию иметь имя пакета. Как правило, пакеты с таким шаблоном, содержащим как библиотечный, так и бинарный крейт, будут иметь достаточно кода в бинарном крейте, чтобы запустить исполняемый файл, который вызывает код из библиотечного крейта. Это позволяет другим проектам извлечь выгоду из большей части функциональности, предоставляемой пакетом, поскольку код библиотечного крейта могут использовать и другие.</p>
<p>Дерево модулей должно быть определено в <em>src/lib.rs</em>. После этого, любые общедоступные элементы можно использовать в бинарном крейте, начав пути с имени пакета. Бинарный крейт становится пользователем библиотечного крейта точно так же, как полностью внешний крейт использует библиотечный крейт: он может использовать только общедоступный API. Это поможет вам разрабатывать хороший API, так как вы не только автор, но и пользователь!</p>
<p>В <a href="ch12-00-an-io-project.html">Главе 12</a><!-- ignore --> мы покажем эту практику организации кода на примере консольной программы, которая будет содержать как бинарный, так и библиотечный крейты.</p>
</blockquote>
<h3 id="Определение-относительных-путей-с-помощью-super"><a class="header" href="#Определение-относительных-путей-с-помощью-super">Определение относительных путей с помощью <code>super</code></a></h3>
<p>Также можно построить относительные пути, которые начинаются в родительском (а не текущем) модуле, используя ключевое слово <code>super</code> в начале пути. Это похоже на синтаксис <code>..</code> пути файловой системы. Использование <code>super</code> позволяет нам сослаться на элемент, который, как мы знаем, находится в родительском модуле, что может упростить переупорядочение дерева модулей, чем когда модуль тесно связан с родителем, но родитель может когда-нибудь быть перемещён в другое место в дереве модулей.</p>
<p>Рассмотрим код в Листинге 7-8, где моделируется ситуация, в которой повар исправляет неправильный заказ и лично приносит его клиенту. Функция <code>fix_incorrect_order</code> вызывает функцию <code>deliver_order</code>, определённую в родительском модуле, указывая путь к <code>deliver_order</code>, начинающийся с <code>super</code>:</p>
<Listing number="7-8" file-name="src/lib.rs" caption="Calling a function using a relative path starting with `super`">
<pre><code class="language-rust noplayground test_harness">fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order();
    }

    fn cook_order() {}
}</code></pre>
</Listing>
<p>Функция <code>fix_incorrect_order</code> находится в модуле <code>back_of_house</code>, поэтому мы можем использовать <code>super</code> для перехода к родительскому модулю модуля <code>back_of_house</code>, который в этом случае является <code>crate</code> (то есть, корнем). В этом модуле мы ищем <code>deliver_order</code> и находим его. Успех! Мы думаем, что модуль <code>back_of_house</code> и функция <code>deliver_order</code>, скорее всего, останутся в тех же родственных отношениях друг с другом, и должны будут быть перемещены вместе, если мы решим реорганизовать дерево модулей крейта. Поэтому мы использовали <code>super</code>, чтобы в будущем у нас было меньше мест для обновления кода, если этот код будет перемещён в другой модуль.</p>
<h3 id="Указание-общедоступности-структур-и-перечислений"><a class="header" href="#Указание-общедоступности-структур-и-перечислений">Указание общедоступности структур и перечислений</a></h3>
<p>Мы также можем использовать <code>pub</code> для обозначения структур и перечислений как общедоступных, но есть несколько дополнительных деталей использования <code>pub</code> со структурами и перечислениями. Если мы используем <code>pub</code> перед определением структуры, мы делаем структуру общедоступной, но поля структуры по-прежнему остаются приватными. Мы можем сделать каждое поле общедоступным или нет в каждом конкретном случае. В Листинге 7-9 мы определили общедоступную структуру <code>back_of_house::Breakfast</code> с общедоступным полем <code>toast</code> и с приватным полем <code>seasonal_fruit</code>. Это моделирует случай в ресторане, когда клиент может выбрать тип хлеба, который подаётся с едой, а шеф-повар решает какие фрукты сопровождают еду, исходя из того, что сезонно и что есть в наличии. Доступные фрукты быстро меняются, поэтому клиенты не могут выбирать фрукты или даже увидеть, какие фрукты они получат.</p>
<Listing number="7-9" file-name="src/lib.rs" caption="A struct with some public fields and some private fields">
<pre><code class="language-rust noplayground">mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &amp;str) -&gt; Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("персики"),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // Заказываем летом завтрак с ржаным хлебом.
    let mut meal = back_of_house::Breakfast::summer("ржаной");
    // Передумали насчёт хлеба, который мы хотим.
    meal.toast = String::from("пшеничный");
    println!("Я хочу {} тост, пожалуйста.", meal.toast);

    // Следующая строчка, если мы раскомментируем её, не скомпилируется:
    // нам не разрешено знать или изменять сезонный фрукт, который нам подадут.
    // meal.seasonal_fruit = String::from("черника");
}</code></pre>
</Listing>
<p>Поскольку поле <code>toast</code> в структуре <code>back_of_house::Breakfast</code> является открытым, то в функции <code>eat_at_restaurant</code> можно писать и читать поле <code>toast</code>, используя обращение через точку. Обратите внимание, что мы не можем использовать поле <code>seasonal_fruit</code> в <code>eat_at_restaurant</code>, потому что <code>seasonal_fruit</code> является приватным. Попробуйте раскомментировать последнюю строчку, пытающуюся использовать значение поля <code>seasonal_fruit</code>, чтобы увидеть, какую ошибку вы получите!</p>
<p>Также обратите внимание, что поскольку <code>back_of_house::Breakfast</code> имеет приватное поле, то структура должна предоставить публичную ассоциированную функцию, которая создаёт экземпляр <code>Breakfast</code> (мы назвали её <code>summer</code>). Если бы <code>Breakfast</code> не имел такой функции, мы бы не могли создать экземпляр <code>Breakfast</code> внутри <code>eat_at_restaurant</code>, потому что мы не смогли бы установить значение приватного поля <code>seasonal_fruit</code> в функции <code>eat_at_restaurant</code>.</p>
<p>В отличие от структуры, если мы сделаем общедоступным перечисление, то все его варианты будут общедоступными. Нужно только указать <code>pub</code> перед ключевым словом <code>enum</code>, как показано в Листинге 7-10.</p>
<Listing number="7-10" file-name="src/lib.rs" caption="Designating an enum as public makes all its variants public.">
<pre><code class="language-rust noplayground">mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}</code></pre>
</Listing>
<p>Поскольку мы сделали перечисление <code>Appetizer</code> общедоступным, мы можем использовать варианты <code>Soup</code> и <code>Salad</code> в функции <code>eat_at_restaurant</code>.</p>
<p>Перечисления не очень полезны, если их варианты не являются общедоступными: аннотирование всех вариантов перечисления как <code>pub</code> было бы раздражающе нудным. По этой причине варианты перечислений по умолчанию являются общедоступными. Структуры часто полезны, если их поля не являются общедоступными, поэтому поля структуры следуют общему правилу, согласно которому, всё по умолчанию является приватным, если не указано <code>pub</code>.</p>
<p>Есть ещё одна ситуация с <code>pub</code>, которую мы не освещали, и это последняя особенность системы модулей: ключевое слово <code>use</code>. Мы сначала опишем <code>use</code> само по себе, а затем покажем, как сочетать <code>pub</code> и <code>use</code> вместе.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch07-02-defining-modules-to-control-scope-and-privacy.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch07-02-defining-modules-to-control-scope-and-privacy.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
