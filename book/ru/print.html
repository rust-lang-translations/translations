<!DOCTYPE HTML>
<html lang="ru" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Rust Programming Language</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/print.md`;
                    } else {
                        canonical_href = `${base}/${lang}/print.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ru");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="–Ø–∑—ã–∫-–ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è-rust"><a class="header" href="#–Ø–∑—ã–∫-–ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è-rust">–Ø–∑—ã–∫ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è Rust</a></h1>
<p><em>–æ—Ç –°—Ç–∏–≤–∞ –ö–ª–∞–±–Ω–∏–∫–∞, –ö—ç—Ä–æ–ª –ù–∏–∫–æ–ª—Å –∏ –ö—Ä–∏—Å–∞ –ö—Ä–∏—á–æ, –ø—Ä–∏ –ø–æ–¥–¥–µ—Ä–∂–∫–µ –°–æ–æ–±—â–µ—Å—Ç–≤–∞ Rust</em></p>
<p>–≠—Ç–∞ –≤–µ—Ä—Å–∏—è –∫–Ω–∏–≥–∏ –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ—Ç, —á—Ç–æ –≤—ã –∏—Å–ø–æ–ª—å–∑—É–µ—Ç–µ Rust 1.82.0 (–≤—ã–ø—É—â–µ–Ω 17.10.2024) –∏–ª–∏ –±–æ–ª–µ–µ –ø–æ–∑–¥–Ω—é—é –≤–µ—Ä—Å–∏—é. –°–º–æ—Ç—Ä–∏—Ç–µ <a href="ch01-01-installation.html">—Ä–∞–∑–¥–µ–ª "–£—Å—Ç–∞–Ω–æ–≤–∫–∞" –ì–ª–∞–≤—ã 1</a><!-- ignore --> —á—Ç–æ–±—ã —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∏–ª–∏ –æ–±–Ω–æ–≤–∏—Ç—å Rust.</p>
<p>–û—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–∞—è –∞–Ω–≥–ª–∏–π—Å–∫–∞—è –≤–µ–±-–≤–µ—Ä—Å–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ –æ–Ω–ª–∞–π–Ω –Ω–∞ <a href="https://doc.rust-lang.org/stable/book/">https://doc.rust-lang.org/stable/book/</a> –∏ –æ—Ñ—Ñ–ª–∞–π–Ω, –µ—Å–ª–∏ –≤—ã —É—Å—Ç–∞–Ω–æ–≤–∏–ª–∏ Rust —Å –ø–æ–º–æ—â—å—é <code>rustup</code>. –í—ã–ø–æ–ª–Ω–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É <code>rustup doc --book</code>, —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å –≤–∞—à—É –ª–æ–∫–∞–ª—å–Ω—É—é –∫–æ–ø–∏—é –∫–Ω–∏–≥–∏.</p>
<p>–¢–∞–∫–∂–µ –¥–æ—Å—Ç—É–ø–Ω—ã –Ω–µ—Å–∫–æ–ª—å–∫–æ <a href="appendix-06-translation.html">–ø–µ—Ä–µ–≤–æ–¥–æ–≤</a> –æ—Ç —Å–æ–æ–±—â–µ—Å—Ç–≤–∞. <em>(–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫–∞: –≤—ã –º–æ–∂–µ—Ç–µ –Ω–∞–ª–µ—Ç—É –ø–µ—Ä–µ–∫–ª—é—á–∞—Ç—å—Å—è –º–µ–∂–¥—É –ø–µ—Ä–µ–≤–æ–¥–∞–º–∏, —Å–¥–µ–ª–∞–Ω–Ω—ã–º–∏ –≤</em> —ç—Ç–æ–π <em>—Å–∏—Å—Ç–µ–º–µ, –æ—Ç–∫—Ä—ã–≤ –º–µ–Ω—é –Ω–∞ –∫–Ω–æ–ø–∫—É –≥–ª–æ–±—É—Å–∞. <strong>–ö—Ä–æ–º–µ —Ç–æ–≥–æ, –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫ –Ω–∞ —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ –Ω–∞—Å—Ç–æ—è—Ç–µ–ª—å–Ω–æ –ø—Ä–æ—Å–∏—Ç –≤–∞—Å –ø–∏—Å–∞—Ç—å –æ –∑–∞–º–µ—á–µ–Ω–Ω—ã—Ö –ø—Ä–æ–±–ª–µ–º–∞—Ö –≤ <a href="https://t.me/rustlang_ru_translations">—á–∞—Ç –≤ –¢–µ–ª–µ–≥—Ä–∞–º</a> ‚Äî –∑–∞–º–µ—á–µ–Ω–Ω—ã–µ –≤–∞–º–∏ –æ—à–∏–±–∫–∏ –±—É–¥—É—Ç –∏—Å–ø—Ä–∞–≤–ª—è—Ç—å—Å—è. –ó–∞—Ä–∞–Ω–µ–µ –±–æ–ª—å—à–æ–µ —Å–ø–∞—Å–∏–±–æ!</strong>)</em></p>
<p>–≠—Ç–∞ –∫–Ω–∏–≥–∞ (–∞–Ω–≥–ª–∏–π—Å–∫–∏–π –æ—Ä–∏–≥–∏–Ω–∞–ª) —Ç–∞–∫–∂–µ –¥–æ—Å—Ç—É–ø–Ω–∞ –≤ <a href="https://nostarch.com/rust-programming-language-2nd-edition">–ø–µ—á–∞—Ç–Ω–æ–º –∏ —ç–ª–µ–∫—Ç—Ä–æ–Ω–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ –≤ –∏–∑–¥–∞—Ç–µ–ª—å—Å—Ç–≤–µ No Starch Press</a>.</p>
<blockquote>
<p><strong>üö® –ü—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ—Ç–µ –±–æ–ª–µ–µ –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–µ –æ–±—É—á–µ–Ω–∏–µ? –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥—É—é –≤–µ—Ä—Å–∏—é —ç—Ç–æ–π –∫–Ω–∏–≥–∏, –≤–∫–ª—é—á–∞—é—â—É—é –≤ —Å–µ–±—è –≤–æ–ø—Ä–æ—Å—ã, –∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞, –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏, –∏ –º–Ω–æ–≥–æ–µ –¥—Ä—É–≥–æ–µ</strong>: <a href="https://rust-book.cs.brown.edu">https://rust-book.cs.brown.edu</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="–ü—Ä–µ–¥–∏—Å–ª–æ–≤–∏–µ"><a class="header" href="#–ü—Ä–µ–¥–∏—Å–ª–æ–≤–∏–µ">–ü—Ä–µ–¥–∏—Å–ª–æ–≤–∏–µ</a></h1>
<p>–ù–∞ –ø–µ—Ä–≤—ã–π –≤–∑–≥–ª—è–¥ —ç—Ç–æ –Ω–µ –∑–∞–º–µ—Ç–Ω–æ, –Ω–æ —è–∑—ã–∫ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è Rust –≤ —Å–≤–æ–µ–π –æ—Å–Ω–æ–≤–µ —Å–æ—Å—Ä–µ–¥–æ—Ç–æ—á–µ–Ω –Ω–∞ <em>—Ä–∞—Å—à–∏—Ä–µ–Ω–∏–∏ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π</em>: –≤–Ω–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–æ–≥–æ, —á—Ç–æ –∑–∞ –∫–æ–¥ –≤—ã –ø–∏—à–µ—Ç–µ, Rust –Ω–∞–¥–µ–ª—è–µ—Ç –≤–∞—Å —Å–∏–ª–æ–π –¥–æ—Å—Ç–∏–≥–∞—Ç—å –±–æ–ª—å—à–µ–≥–æ, –ø–æ–º–æ–≥–∞–µ—Ç –≤–∞–º —É–≤–µ—Ä–µ–Ω–Ω–æ —Ä–∞–±–æ—Ç–∞—Ç—å –Ω–∞–¥ –∑–∞–¥–∞—á–∞–º–∏ –±–æ–ª–µ–µ —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–Ω—ã–º–∏, —á–µ–º –≤—ã –ø—Ä–∏–≤—ã–∫–ª–∏.</p>
<p>–í–æ–∑—å–º—ë–º, –∫ –ø—Ä–∏–º–µ—Ä—É, —Å–∏—Å—Ç–µ–º–Ω–æ–µ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ. –û–Ω–æ —Å–≤—è–∑–∞–Ω–æ —Å –ø—Ä—è–º—ã–º —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º –ø–∞–º—è—Ç—å—é, –Ω–∏–∑–∫–æ—É—Ä–æ–≤–Ω–µ–≤—ã–º –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ–º –¥–∞–Ω–Ω—ã—Ö –∏ –ø–∞—Ä–∞–ª–ª–µ–ª–∏–∑–º–æ–º. –≠—Ç–∞ –æ–±–ª–∞—Å—Ç—å –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è —Ç—Ä–∞–¥–∏—Ü–∏–æ–Ω–Ω–æ –≤–∏–¥–∏—Ç—Å—è –∫–∞–∫ —ç–∑–æ—Ç–µ—Ä–∏—á–µ—Å–∫–æ–µ –∏—Å–∫—É—Å—Å—Ç–≤–æ, –≥–¥–µ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –æ—à–∏–±–∫–∏ —Å–∫—Ä—ã–≤–∞—é—Ç—Å—è –≤ –∫–∞–∂–¥–æ–π —Ç—Ä–µ—Ç—å–µ–π —Å—Ç—Ä–æ—á–∫–µ –∫–æ–¥–∞, –∏ —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç—ã –∫–æ—Ç–æ—Ä–æ–≥–æ —Ç—Ä–∞—Ç—è—Ç –º–Ω–æ–≥–∏–µ –±–µ—Å—Ü–µ–Ω–Ω—ã–µ –≥–æ–¥—ã, —á—Ç–æ–±—ã –Ω–∞—É—á–∏—Ç—å—Å—è –∏–∑–±–µ–≥–∞—Ç—å –∏–∑–≤–µ—Å—Ç–Ω—ã—Ö –ª–æ–≤—É—à–µ–∫. –î–∞–∂–µ —Ç–µ, –∫—Ç–æ –∑–∞–Ω–∏–º–∞–µ—Ç—Å—è –Ω–∏–∑–∫–æ—É—Ä–æ–≤–Ω–µ–≤—ã–º –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ–º, –¥–µ–ª–∞—é—Ç –≤—Å—ë —Å –æ—Å—Ç–æ—Ä–æ–∂–Ω–æ—Å—Ç—å—é, –¥–∞–±—ã –∏—Ö –∫–æ–¥ –Ω–µ –∫–∏—à–µ–ª —ç–∫—Å–ø–ª–æ–π—Ç–∞–º–∏, –≤—ã–ª–µ—Ç–∞–º–∏ –∏ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω–∏—è–º–∏ –¥–∞–Ω–Ω—ã—Ö.</p>
<p>Rust —Ä–∞–∑—Ä—É—à–∞–µ—Ç —ç—Ç–∏ –ø—Ä–µ–≥—Ä–∞–¥—ã, –Ω–∞ –∫–æ—Ä–Ω—é –ø—Ä–µ—Å–µ–∫–∞—è —Ä–∞–∑–¥—Ä–∞–∂–∞—é—â–∏–µ –æ—à–∏–±–∫–∏ –∏ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è—è —É–¥–æ–±–Ω—ã–π, –≤—ã–≤–µ—Ä–µ–Ω–Ω—ã–π –Ω–∞–±–æ—Ä –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤, –ø–æ–º–æ–≥–∞—é—â–∏–π –≤–∞–º –≤ —Ä–∞–±–æ—Ç–µ. –ü—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç—ã, —Ç—Ä–µ–±—É—é—â–∏–µ –≥–ª—É–±–æ–∫–æ–≥–æ –∫–æ–Ω—Ç—Ä–æ–ª—è –Ω–∞–¥ –ø—Ä–æ–≥—Ä–∞–º–º–æ–π, –Ω–µ –ø–æ—Ç–µ—Ä—è—é—Ç –µ–≥–æ, –æ–±—Ä–∞—Ç–∏–≤—à–∏—Å—å –∫ Rust, –Ω–æ –ø—Ä–∏–æ–±—Ä–µ—Ç—É—Ç —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å –≤ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–∏ –≤—ã–ª–µ—Ç–æ–≤ –∏ –¥—ã—Ä –≤ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –∏–∑-–∑–∞ –±–∞–Ω–∞–ª—å–Ω–æ—Å—Ç–µ–π. –ò —Ç–∞–∫–∞—è —Å–∏–ª–∞ –¥–æ—Å—Ç–∞–Ω–µ—Ç—Å—è –≤–∞–º –±–µ–∑ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –∏–∑—É—á–∞—Ç—å –±–æ–ª—å–Ω—ã–µ –º–µ—Å—Ç–∞ –∫–∞–ø—Ä–∏–∑–Ω—ã—Ö –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤. –ë–æ–ª–µ–µ —Ç–æ–≥–æ, —è–∑—ã–∫ —Å–ø—Ä–æ–µ–∫—Ç—Ä–∏—Ä–æ–≤–∞–Ω —Ç–∞–∫, —á—Ç–æ–±—ã –ø—Ä–æ–¥–≤–∏–≥–∞—Ç—å –≤–∞—Å –∫ –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ–º—É –∏ –Ω–∞–¥—ë–∂–Ω–æ–º—É —Ä–µ—à–µ–Ω–∏—é –∑–∞–¥–∞—á, –∫–æ—Ç–æ—Ä–æ–µ –±—É–¥–µ—Ç —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ –∫–∞–∫ –≤ –ø–ª–∞–Ω–µ –±—ã—Å—Ç—Ä–æ–¥–µ–π—Å—Ç–≤–∏—è, —Ç–∞–∫ –∏ –≤ –ø–ª–∞–Ω–µ —Ä–∞—Å—Ö–æ–¥–∞ –ø–∞–º—è—Ç–∏.</p>
<p>–ü—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç—ã, —É–∂–µ —Ä–∞–±–æ—Ç–∞—é—â–∏–µ –Ω–∞ –±–ª–∏–∑–∫–æ–º –∫ –º–∞—à–∏–Ω–µ —É—Ä–æ–≤–Ω–µ, –º–æ–≥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Rust, —á—Ç–æ–±—ã  —Ä–∞—Å—à–∏—Ä–∏—Ç—å —Å–≤–æ–∏ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏. –ù–∞–ø—Ä–∏–º–µ—Ä, –≤–Ω–µ–¥—Ä–µ–Ω–∏–µ –ø–∞—Ä–∞–ª–ª–µ–ª–∏–∑–º–∞ –≤ Rust –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –±–µ–∑–æ–ø–∞—Å–Ω–æ: –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –æ—Ç–ª–æ–≤–∏—Ç –ø—Ä–∏–º–∏—Ç–∏–≤–Ω—ã–µ –æ—à–∏–±–∫–∏ –∑–∞ –≤–∞—Å. –í—ã —Å–º–æ–∂–µ—Ç–µ –ø—Ä–æ–≤–µ—Å—Ç–∏ –±–æ–ª–µ–µ –º–æ—â–Ω—ã–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –≤ —Å–≤–æ—ë–º –∫–æ–¥–µ, –Ω–µ –ø–µ—Ä–µ–∂–∏–≤–∞—è, —á—Ç–æ —Å–ª—É—á–∞–π–Ω–æ –≤–Ω–µ—Å—ë—Ç–µ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –æ—à–∏–±–∫–∏ –∏–ª–∏ —É—è–∑–≤–∏–º–æ—Å—Ç–∏.</p>
<p>–û–¥–Ω–∞–∫–æ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ Rust –Ω–µ –∑–∞–∫–∞–Ω—á–∏–≤–∞—é—Ç—Å—è –Ω–∞ —Å–∏—Å—Ç–µ–º–Ω–æ–º –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–∏. –û–Ω –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –≤—ã—Ä–∞–∑–∏—Ç–µ–ª–µ–Ω –∏ —ç—Ä–≥–æ–Ω–æ–º–∏—á–µ–Ω, —á—Ç–æ–±—ã —Å–æ–∑–¥–∞–≤–∞—Ç—å –∫–æ–Ω—Å–æ–ª—å–Ω—ã–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è, –≤–µ–±-—Å–µ—Ä–≤–µ—Ä—ã, –∏ –º–Ω–æ–≥–æ–µ –¥—Ä—É–≥–æ–µ: –≤—ã –Ω–∞–π–¥—ë—Ç–µ –ø—Ä–µ–∫—Ä–∞—Å–Ω—ã–µ –ø—Ä–∏–º–µ—Ä—ã –¥–∞–ª–µ–µ –≤ –∫–Ω–∏–≥–µ. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ Rust –ø–æ–∑–≤–æ–ª–∏—Ç –≤–∞–º –ø–æ–ª—É—á–∏—Ç—å –∑–Ω–∞–Ω–∏—è, –∫–æ—Ç–æ—Ä—ã–µ –ø—Ä–∏–≥–æ–¥—è—Ç—Å—è –∏ –≤ –¥—Ä—É–≥–∏—Ö –æ–±–ª–∞—Å—Ç—è—Ö. –ù–∞–ø—Ä–∏–º–µ—Ä, –≤—ã –º–æ–∂–µ—Ç–µ –∏–∑—É—á–∏—Ç—å Rust, –Ω–∞–ø–∏—Å–∞–≤ –≤–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ, –∞ –∑–∞—Ç–µ–º –ø—Ä–∏–º–µ–Ω–∏—Ç—å –∏–∑—É—á–µ–Ω–Ω—ã–µ –∏–¥–µ–∏ –≤ —Ä–∞–±–æ—Ç–µ —Å Raspberry Pi.</p>
<p>–≠—Ç–∞ –∫–Ω–∏–≥–∞ –ø–æ–ª–Ω–æ—Å—Ç—å—é –æ—Ö–≤–∞—Ç—ã–≤–∞–µ—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ Rust, –∫–æ—Ç–æ—Ä—ã–µ –¥–µ–ª–∞—é—Ç –µ–≥–æ —Å—Ç–æ–ª—å –≤—ã—Ä–∞–∑–∏—Ç–µ–ª—å–Ω—ã–º –∏ –ø—Ä–∏—è—Ç–Ω—ã–º. –ü–µ—Ä–µ–¥ –≤–∞–º–∏ ‚Äî —É–¥–æ–±–Ω—ã–π –∏ –¥–æ—Å—Ç—É–ø–Ω—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫, –∫–æ—Ç–æ—Ä—ã–π –Ω–µ —Ç–æ–ª—å–∫–æ –¥–∞—Å—Ç –ø–æ–Ω–∏–º–∞–Ω–∏–µ —è–∑—ã–∫–∞ Rust, –Ω–æ —Ç–∞–∫–∂–µ —Ä–∞—Å—à–∏—Ä–∏—Ç –≤–∞—à–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –æ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–∏ –≤ —Ü–µ–ª–æ–º. –ò—Ç–∞–∫, –ø—Ä–∏–≥–æ—Ç–æ–≤—å—Ç–µ—Å—å –æ—Ç–∫—Ä—ã–≤–∞—Ç—å –Ω–æ–≤–æ–µ ‚Äî –¥–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –°–æ–æ–±—â–µ—Å—Ç–≤–æ Rust!</p>
<p>‚Äî –ù–∏–∫–æ–ª–∞—Å –ú–∞—Ç—Å–∞–∫–∏—Å –∏ –ê–∞—Ä–æ–Ω –¢—É—Ä–æ–Ω</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="–í–≤–µ–¥–µ–Ω–∏–µ"><a class="header" href="#–í–≤–µ–¥–µ–Ω–∏–µ">–í–≤–µ–¥–µ–Ω–∏–µ</a></h1>
<blockquote>
<p>–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: —ç—Ç–∞ —Ä–µ–¥–∞–∫—Ü–∏—è –∫–Ω–∏–≥–∏ —Ç–∞–∫–∞—è –∂–µ, –∫–∞–∫ –∏ –∫–Ω–∏–≥–∞ <a href="https://nostarch.com/rust-programming-language-2nd-edition">The Rust Programming Language</a>, –¥–æ—Å—Ç—É–ø–Ω–∞—è –≤ –ø–µ—á–∞—Ç–∏ –≤ —ç–ª–µ–∫—Ç—Ä–æ–Ω–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ –≤ –∏–∑–¥–∞—Ç–µ–ª—å—Å—Ç–≤–µ <a href="https://nostarch.com/">No Starch Press</a>.</p>
</blockquote>
<p>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ <em>The Rust Programming Language</em> ‚Äî –æ–∑–Ω–∞–∫–æ–º–∏—Ç–µ–ª—å–Ω—É—é –∫–Ω–∏–≥—É –æ Rust. –Ø–∑—ã–∫ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è Rust –ø–æ–º–æ–∂–µ—Ç –≤–∞–º –±—ã—Å—Ç—Ä–æ –ø–∏—Å–∞—Ç—å –±–æ–ª–µ–µ –Ω–∞–¥—ë–∂–Ω–æ–µ –ø—Ä–æ–≥—Ä–∞–º–º–Ω–æ–µ –æ–±–µ—Å–ø–µ—á–µ–Ω–∏–µ. –í—ã—Å–æ–∫–æ—É—Ä–æ–≤–Ω–µ–≤–∞—è —ç—Ä–≥–æ–Ω–æ–º–∏–∫–∞ –∏ –Ω–∏–∑–∫–æ—É—Ä–æ–≤–Ω–µ–≤—ã–π –∫–æ–Ω—Ç—Ä–æ–ª—å —á–∞—Å—Ç–æ —Å—Ç–∞–Ω–æ–≤—è—Ç—Å—è –Ω–µ—Å–æ–≤–º–µ—Å—Ç–∏–º—ã–º–∏ —Ü–µ–ª—è–º–∏ –ø—Ä–∏ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ –Ω–æ–≤–æ–≥–æ —è–∑—ã–∫–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è. Rust –±—Ä–æ—Å–∞–µ—Ç –≤—ã–∑–æ–≤ —ç—Ç–æ–º—É –ø—Ä–æ—Ç–∏–≤–æ—Ä–µ—á–∏—é. –ë–∞–ª–∞–Ω—Å–∏—Ä—É—è –º–µ–∂–¥—É –º–æ—â–Ω–æ–π —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–π –≤—ã—Ä–∞–∑–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é –∏ –ø—Ä–æ—Å—Ç–æ—Ç–æ–π –ª–æ–≥–∏–∫–∏ –ø—Ä–æ–≥—Ä–∞–º–º, Rust –¥–∞—ë—Ç –≤–∞–º –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å —É–ø—Ä–∞–≤–ª—è—Ç—å –Ω–∏–∑–∫–æ—É—Ä–æ–≤–Ω–µ–≤—ã–º–∏ –¥–µ—Ç–∞–ª—è–º–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –ø–∞–º—è—Ç–∏) –±–µ–∑ —Ö–ª–æ–ø–æ—Ç, –æ–±—ã—á–Ω–æ –æ–∂–∏–¥–∞–µ–º—ã—Ö –æ—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –ø–æ–¥–æ–±–Ω–æ–≥–æ –∫–æ–Ω—Ç—Ä–æ–ª—è.</p>
<h2 id="–ö–æ–º—É-rust-–ø—Ä–∏–¥—ë—Ç—Å—è-–ø–æ-–¥—É—à–µ"><a class="header" href="#–ö–æ–º—É-rust-–ø—Ä–∏–¥—ë—Ç—Å—è-–ø–æ-–¥—É—à–µ">–ö–æ–º—É Rust –ø—Ä–∏–¥—ë—Ç—Å—è –ø–æ –¥—É—à–µ</a></h2>
<p>–†—è–¥ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–µ–π Rust –¥–µ–ª–∞–µ—Ç –µ–≥–æ –ø—Ä–µ–≤–æ—Å—Ö–æ–¥–Ω—ã–º –¥–ª—è –º–Ω–æ–≥–∏—Ö –≥—Ä—É–ø–ø –ª—é–¥–µ–π. –í–∑–≥–ª—è–Ω–µ–º –Ω–∞ –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –Ω–∞–∏–±–æ–ª–µ–µ –≤–∞–∂–Ω—ã–µ –∏–∑ –Ω–∏—Ö.</p>
<h3 id="–ö–æ–º–∞–Ω–¥—ã-—Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤"><a class="header" href="#–ö–æ–º–∞–Ω–¥—ã-—Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤">–ö–æ–º–∞–Ω–¥—ã —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤</a></h3>
<p>Rust –∑–∞—Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–ª —Å–µ–±—è –∫–∞–∫ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏–≤–Ω—ã–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–Ω–æ–π —Ä–∞–±–æ—Ç—ã –±–æ–ª—å—à–∏—Ö –∫–æ–º–∞–Ω–¥ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ —Å —Ä–∞–∑–Ω—ã–º —É—Ä–æ–≤–Ω–µ–º –∫–≤–∞–ª–∏—Ñ–∏–∫–∞—Ü–∏–∏. –ù–∏–∑–∫–æ- —É—Ä–æ–≤–Ω–µ–≤—ã–π –∫–æ–¥ –ø–æ–¥–≤–µ—Ä–∂–µ–Ω —Ä–∞–∑–Ω—ã–º —Ç–æ–Ω–∫–∏–º –æ—à–∏–±–∫–∞–º, –∫–æ—Ç–æ—Ä—ã–µ –≤–æ –º–Ω–æ–∂–µ—Å—Ç–≤–µ –¥—Ä—É–≥–∏—Ö —è–∑—ã–∫–æ–≤ –º–æ–∂–Ω–æ –æ—Ç–ª–æ–≤–∏—Ç—å —Ç–æ–ª—å–∫–æ —á–µ—Ä–µ–∑ –æ–±—ä—ë–º–Ω–æ–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –¥–æ—Ç–æ—à–Ω—É—é –ø—Ä–æ–≤–µ—Ä–∫—É –∫–æ–¥–∞ –æ–ø—ã—Ç–Ω—ã–º–∏ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞–º–∏. –í Rust, –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –∏–≥—Ä–∞–µ—Ç —Ä–æ–ª—å –≤—Ä–∞—Ç–∞—Ä—è, –Ω–µ –ø–æ–∑–≤–æ–ª—è—è –∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞—Ç—å—Å—è –ø—Ä–æ–≥—Ä–∞–º–º–∞–º, —Å–æ–¥–µ—Ä–∂–∞—â–∏–º —Ä–∞–∑–ª–∏—á–Ω—ã–µ —Ç—Ä—É–¥–Ω–æ—É–ª–æ–≤–∏–º—ã–µ –æ—à–∏–±–∫–∏ (–≤ —Ç–æ–º —á–∏—Å–ª–µ, –æ—à–∏–±–∫–∏ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–≥–æ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è). –†–∞–±–æ—Ç–∞—è —Å –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–æ–º –∑–∞–æ–¥–Ω–æ, –∫–æ–º–∞–Ω–¥—ã —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ –º–æ–≥—É—Ç —Å–æ—Å—Ä–µ–¥–æ—Ç–∞—á–∏–≤–∞—Ç—å—Å—è –Ω–∞ –ø—Ä–æ–≥—Ä–∞–º–º–Ω–æ–π –ª–æ–≥–∏–∫–µ, –æ—Å—Ç–∞–≤–ª—è—è –Ω–∞ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–µ –æ—Ö–æ—Ç—É –∑–∞ –±–∞–≥–∞–º–∏.</p>
<p>Rust —Ç–∞–∫–∂–µ –ø—Ä–∏–≤–Ω–æ—Å–∏—Ç —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏ –≤ –º–∏—Ä —Å–∏—Å—Ç–µ–º–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è:</p>
<ul>
<li>Cargo ‚Äî –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π –∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç —Å–±–æ—Ä–∫–∏, –¥–µ–ª–∞—é—â–∏–π –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ,–∫–æ–º–ø–∏–ª—è—Ü–∏—é –∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π –±–µ–∑–ø—Ä–æ–±–ª–µ–º–Ω—ã–º –∏ —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–Ω—ã–º –≤ —Ä–∞–º–∫–∞—Ö –≤—Å–µ–π —ç–∫–æ—Å–∏—Å—Ç–µ–º—ãRust.</li>
<li>Rustfmt ‚Äî –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è, –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É—é—â–∏–π –µ–¥–∏–Ω–æ–æ–±—Ä–∞–∑–∏–µ —Å—Ç–∏–ª—è –ø—Ä–æ–≥—Ä–∞–º–º, –Ω–∞–ø–∏—Å–∞–Ω–Ω—ã—Ö —Ä–∞–∑–Ω—ã–º–∏ –ª—é–¥—å–º–∏.</li>
<li>rust-analyzer ‚Äî —Å—Ä–µ–¥—Å—Ç–≤–æ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ –≤ –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å—Ä–µ–¥—ã —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏ (IDE) –∞–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏—è –∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –æ—à–∏–±–æ–∫.</li>
</ul>
<p>–ë–ª–∞–≥–æ–¥–∞—Ä—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—é —ç—Ç–∏—Ö –∏ –¥—Ä—É–≥–∏—Ö –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ —ç–∫–æ—Å–∏—Å—Ç–µ–º—ã Rust, —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–ø–æ—Å–æ–±–Ω—ã –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ —Ä–∞–±–æ—Ç–∞—Ç—å –Ω–∞–¥ –ø—Ä–æ–≥—Ä–∞–º–º–∞–º–∏ —Å–∏—Å—Ç–µ–º–Ω–æ–≥–æ —É—Ä–æ–≤–Ω—è.</p>
<h3 id="–£—á–∞—â–∏–µ—Å—è"><a class="header" href="#–£—á–∞—â–∏–µ—Å—è">–£—á–∞—â–∏–µ—Å—è</a></h3>
<p>Rust –ø–æ–¥–æ–π–¥—ë—Ç —É—á–∞—â–∏–º—Å—è –∏ –≤—Å–µ–º —Ç–µ–º, –∫—Ç–æ –∑–∞–∏–Ω—Ç–µ—Ä–µ—Å–æ–≤–∞–Ω –≤ –∏–∑—É—á–µ–Ω–∏–∏ –Ω–∏–∑–∫–æ—É—Ä–æ–≤–Ω–µ–≤—ã—Ö –∫–æ–Ω—Ü–µ–ø—Ü–∏–π. –ò—Å–ø–æ–ª—å–∑—É—è Rust, –º–Ω–æ–≥–∏–µ –ª—é–¥–∏ –∏–∑—É—á–∏–ª–∏ —Ç–∞–∫–∏–µ —Ç–µ–º—ã, –∫–∞–∫ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∞ –æ–ø–µ—Ä–∞—Ü–∏–æ–Ω–Ω—ã—Ö —Å–∏—Å—Ç–µ–º. –°–æ–æ–±—â–µ—Å—Ç–≤–æ Rust –æ—á–µ–Ω—å –ø—Ä–∏–≤–µ—Ç–ª–∏–≤–æ: –º–Ω–æ–≥–∏–µ –≥–æ—Ç–æ–≤—ã –ø–æ–º–æ—á—å —É—á–∞—â–∏–º—Å—è —Å –∏—Ö –≤–æ–ø—Ä–æ—Å–∞–º–∏. –ö–æ–º–∞–Ω–¥—ã —ç–Ω—Ç—É–∑–∏–∞—Å—Ç–æ–≤ Rust –ø—Ä–∏–∫–ª–∞–¥—ã–≤–∞—é—Ç –±–æ–ª—å—à–∏–µ —É—Å–∏–ª–∏—è –∫ —Ç–æ–º—É, —á—Ç–æ–±—ã —Å–¥–µ–ª–∞—Ç—å –∏–∑—É—á–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è –¥–æ—Å—Ç—É–ø–Ω—ã–º –±–æ–ª—å—à–µ–º—É —á–∏—Å–ª—É –ª—é–¥–µ–π, –æ—Å–æ–±–µ–Ω–Ω–æ –Ω–æ–≤–∏—á–∫–∞–º –≤ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–∏ –≤ —Ü–µ–ª–æ–º. –û–¥–Ω–∏–º –∏–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —ç—Ç–∏—Ö —É—Å–∏–ª–∏–π  –∏ —è–≤–ª—è–µ—Ç—Å—è —ç—Ç–∞ –∫–Ω–∏–≥–∞.</p>
<h3 id="–ö–æ–º–ø–∞–Ω–∏–∏"><a class="header" href="#–ö–æ–º–ø–∞–Ω–∏–∏">–ö–æ–º–ø–∞–Ω–∏–∏</a></h3>
<p>–°–æ—Ç–Ω–∏ –∫–æ–º–ø–∞–Ω–∏–π, –±–æ–ª—å—à–∏—Ö –∏ –º–∞–ª–µ–Ω—å–∫–∏—Ö, –ø—Ä–∏–º–µ–Ω—è—é—Ç Rust –¥–ª—è –º–Ω–æ–∂–µ—Å—Ç–≤–∞ –∑–∞–¥–∞—á, —Ç–∞–∫–∏—Ö –∫–∞–∫ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∞ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏, –≤–µ–±-—Å–µ—Ä–≤–∏—Å–æ–≤, –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ DevOps, –≤—Å—Ç—Ä–∞–∏–≤–∞–µ–º—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤; –∞–Ω–∞–ª–∏–∑ –∏ –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∞—É–¥–∏–æ –∏ –≤–∏–¥–µ–æ; —Å–æ–∑–¥–∞–Ω–∏–µ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç; –±–∏–æ–∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–∫–∞; —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–∏—Å–∫–æ–≤—ã—Ö —Å–∏—Å—Ç–µ–º, –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞ –≤–µ—â–µ–π; –º–∞—à–∏–Ω–Ω–æ–µ –æ–±—É—á–µ–Ω–∏–µ; –∏, –Ω–∞–∫–æ–Ω–µ—Ü –∏ –Ω–∞–ø—Ä–∏–º–µ—Ä, —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∞ –æ—Å–Ω–æ–≤–Ω—ã—Ö —á–∞—Å—Ç–µ–π –±—Ä–∞—É–∑–µ—Ä–∞ Firefox.</p>
<h3 id="–†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∏-–æ—Ç–∫—Ä—ã—Ç–æ–≥–æ-–ø—Ä–æ–≥—Ä–∞–º–º–Ω–æ–≥–æ-–æ–±–µ—Å–ø–µ—á–µ–Ω–∏—è"><a class="header" href="#–†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∏-–æ—Ç–∫—Ä—ã—Ç–æ–≥–æ-–ø—Ä–æ–≥—Ä–∞–º–º–Ω–æ–≥–æ-–æ–±–µ—Å–ø–µ—á–µ–Ω–∏—è">–†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∏ –æ—Ç–∫—Ä—ã—Ç–æ–≥–æ –ø—Ä–æ–≥—Ä–∞–º–º–Ω–æ–≥–æ –æ–±–µ—Å–ø–µ—á–µ–Ω–∏—è</a></h3>
<p>–ú–∏—Ä Rust —Å —Ä–∞–¥–æ—Å—Ç—å—é –ø—Ä–∏–º–µ—Ç –ª—é–¥–µ–π, –∂–µ–ª–∞—é—â–∏—Ö —Ä–∞–∑–≤–∏—Ç—å —ç—Ç–æ—Ç —è–∑—ã–∫, –ø–æ—Å—Ç—Ä–æ–∏—Ç—å —Å–ø–ª–æ—á—ë–Ω–Ω–æ–µ –°–æ–æ–±—â–µ—Å—Ç–≤–æ, —Å–æ–∑–¥–∞—Ç—å –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –∏ —Å—Ä–µ–¥—Å—Ç–≤–∞ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏. –ú—ã –±—É–¥–µ–º –±–ª–∞–≥–æ–¥–∞—Ä–Ω—ã –∑–∞ –≤–∞—à –≤–∫–ª–∞–¥ –≤ Rust.</p>
<h3 id="–õ—é–¥–∏-—Ü–µ–Ω—è—â–∏–µ-—Å–∫–æ—Ä–æ—Å—Ç—å-–∏-—É—Å—Ç–æ–π—á–∏–≤–æ—Å—Ç—å"><a class="header" href="#–õ—é–¥–∏-—Ü–µ–Ω—è—â–∏–µ-—Å–∫–æ—Ä–æ—Å—Ç—å-–∏-—É—Å—Ç–æ–π—á–∏–≤–æ—Å—Ç—å">–õ—é–¥–∏, —Ü–µ–Ω—è—â–∏–µ —Å–∫–æ—Ä–æ—Å—Ç—å –∏ —É—Å—Ç–æ–π—á–∏–≤–æ—Å—Ç—å</a></h3>
<p>Rust –±—É–¥–µ—Ç –ø—Ä–∏—è—Ç–µ–Ω –¥–ª—è –ª—é–¥–µ–π, —Ç—Ä–µ–±—É—é—â–∏—Ö –æ—Ç —è–∑—ã–∫–∞ —Å–∫–æ—Ä–æ—Å—Ç–∏ –∏ —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏. –ü–æ–¥ —Å–∫–æ—Ä–æ—Å—Ç—å—é –º—ã –ø–æ–Ω–∏–º–∞–µ–º –∫–∞–∫ —Å–∫–æ—Ä–æ—Å—Ç—å –∏—Å–ø–æ–ª–µ–Ω–∏—è –ø—Ä–æ–≥—Ä–∞–º–º, —Ç–∞–∫ –∏ —Å–∫–æ—Ä–æ—Å—Ç—å –∏—Ö —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏. –ü—Ä–æ–≤–µ—Ä–∫–∏ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞ Rust –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É—é—Ç —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å –ø—Ä–∏ —Ä–∞–∑–≤–∏—Ç–∏–∏ –∏ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–µ. –≠—Ç–æ –≤—ã–≥–æ–¥–Ω–æ –æ—Ç–ª–∏—á–∞–µ—Ç Rust –æ—Ç —è–∑—ã–∫–æ–≤, –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—â–∏—Ö —ç—Ç–∏ –ø—Ä–æ–≤–µ—Ä–∫–∏, –∏ –ø–æ—Ç–æ–º—É –Ω–∞–∫–æ–ø–∏–≤—à–∏—Ö –±–æ–ª—å—à–∏–µ –∫–æ–¥–æ–≤—ã–µ –±–∞–∑—ã, –∫–æ—Ç–æ—Ä—ã–µ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∏ —á–∞—Å—Ç–æ –æ–ø–∞—Å–∞—é—Ç—Å—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å. –ë–ª–∞–≥–æ–¥–∞—Ä—è –∞–±—Å—Ç—Ä–∞–∫—Ü–∏—è–º —Å –Ω—É–ª–µ–≤–æ–π —Å—Ç–æ–∏–º–æ—Å—Ç—å—é (–≤—ã—Å–æ–∫–æ—É—Ä–æ–≤–Ω–µ–≤—ã–º –º–µ—Ö–∞–Ω–∏–∑–º–∞–º, –∫–æ–º–ø–∏–ª–∏—Ä—É—é—â–∏–º—Å—è –≤ –Ω–∏–∑–∫–æ—É—Ä–æ–≤–Ω–µ–≤—ã–π –∫–æ–¥, —Å—Ç–æ–ª—å –∂–µ –±—ã—Å—Ç—Ä—ã–π, –∫–∞–∫ –∏ –Ω–∞–ø–∏—Å–∞–Ω–Ω—ã–π –≤—Ä—É—á–Ω—É—é), Rust —Å—Ç—Ä–µ–º–∏—Ç—Å—è —Å–¥–µ–ª–∞—Ç—å –∫–æ–¥ –∏ –±–µ–∑–æ–ø–∞—Å–Ω—ã–º, –∏ –±—ã—Å—Ç—Ä—ã–º.</p>
<p>Rust –Ω–∞–¥–µ–µ—Ç—Å—è –∑–∞–∏–Ω—Ç–µ—Ä–µ—Å–æ–≤–∞—Ç—å –∏ –¥—Ä—É–≥–∏—Ö –ª—é–¥–µ–π. –¢–µ –≥—Ä—É–ø–ø—ã, —á—Ç–æ –±—ã–ª–∏ —É–ø–æ–º—è–Ω—É—Ç—ã, ‚Äî —ç—Ç–æ –ª–∏—à—å —Å–∞–º—ã–µ –∑–∞–º–µ—Ç–Ω—ã–µ —Å—Ç–æ—Ä–æ–Ω—ã. –í —Ü–µ–ª–æ–º, –∫–ª—é—á–µ–≤–æ–µ —Å—Ç—Ä–µ–º–ª–µ–Ω–∏–µ Rust ‚Äî —ç—Ç–æ –∏–∑–±–∞–≤–∏—Ç—å –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç–æ–≤ –æ—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –∏–¥—Ç–∏ –Ω–∞ –∫–æ–º–ø—Ä–æ–º–∏—Å—Å—ã, –Ω–∞ –∫–æ—Ç–æ—Ä—ã–µ —Ç–µ —à–ª–∏ –¥–µ—Å—è—Ç–∏–ª–µ—Ç–∏—è–º–∏. Rust ‚Äî —ç—Ç–æ —Å–ø–æ—Å–æ–± –ø–æ–ª—É—á–∏—Ç—å –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –∏ –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ—Å—Ç—å <em>–≤–º–µ—Å—Ç–µ</em> —Å–æ —Å–∫–æ—Ä–æ—Å—Ç—å—é –∏ —ç—Ä–≥–æ–Ω–æ–º–∏–∫–æ–π. –ü–æ–∑–Ω–∞–∫–æ–º—å—Ç–µ—Å—å —Å Rust, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ–≥–æ, –¥–∞–π—Ç–µ –µ–º—É —à–∞–Ω—Å ‚Äî –∏ –ø–æ—Å–º–æ—Ç—Ä–∏—Ç–µ, –Ω–∞—Å–∫–æ–ª—å–∫–æ –æ–Ω –≤–∞–º –ø–æ–Ω—Ä–∞–≤–∏—Ç—Å—è.</p>
<h2 id="–ö–æ–º—É-–±—É–¥–µ—Ç-–ø–æ–ª–µ–∑–Ω–∞-—ç—Ç–∞-–∫–Ω–∏–≥–∞"><a class="header" href="#–ö–æ–º—É-–±—É–¥–µ—Ç-–ø–æ–ª–µ–∑–Ω–∞-—ç—Ç–∞-–∫–Ω–∏–≥–∞">–ö–æ–º—É –±—É–¥–µ—Ç –ø–æ–ª–µ–∑–Ω–∞ —ç—Ç–∞ –∫–Ω–∏–≥–∞</a></h2>
<p>–≠—Ç–∞ –∫–Ω–∏–≥–∞ –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ—Ç, —á—Ç–æ –≤—ã —É–∂–µ –∑–Ω–∞–∫–æ–º—ã —Å –∫–∞–∫–∏–º-–Ω–∏–±—É–¥—å –¥—Ä—É–≥–∏–º —è–∑—ã–∫–æ–º –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è, –Ω–æ –Ω–∞–º –Ω–µ –±—É–¥–µ—Ç –≤–∞–∂–Ω–æ, —Å –∫–∞–∫–∏–º –∏–º–µ–Ω–Ω–æ. –ú—ã –ø–æ—Å—Ç–∞—Ä–∞–µ–º—Å—è –∏–∑–ª–æ–∂–∏—Ç—å –º–∞—Ç–µ—Ä–∏–∞–ª –¥–æ—Å—Ç—É–ø–Ω–æ ‚Äî –≤–Ω–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∏–º–µ—é—â–µ–≥–æ—Å—è —É –≤–∞—Å –Ω–∞ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –Ω–∞–≤—ã–∫–∞. –ú—ã –Ω–µ –±—É–¥–µ–º —Ç—Ä–∞—Ç–∏—Ç—å –º–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ –Ω–∞ –æ–±—Å—É–∂–¥–µ–Ω–∏–µ —Ç–æ–≥–æ, <em>—á–µ–º</em> —è–≤–ª—è–µ—Ç—Å—è –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–ª–∏ –∫–∞–∫ –º—ã—Å–ª–∏—Ç—å –æ –Ω—ë–º. –ï—Å–ª–∏ –≤—ã —Å–æ–≤–µ—Ä—à–µ–Ω–Ω–æ –Ω–æ–≤—ã –≤ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–∏, –≤–∞–º –±—É–¥–µ—Ç –∫—Ä–∞–π–Ω–µ –ø–æ–ª–µ–∑–Ω–æ –¥–ª—è –Ω–∞—á–∞–ª–∞ –≥–¥–µ-–ª–∏–±–æ –æ–∑–Ω–∞–∫–æ–º–∏—Ç—å—Å—è —Å –µ–≥–æ –æ—Å–Ω–æ–≤–∞–º–∏.</p>
<h2 id="–ö–∞–∫-—á–∏—Ç–∞—Ç—å-—ç—Ç—É-–∫–Ω–∏–≥—É"><a class="header" href="#–ö–∞–∫-—á–∏—Ç–∞—Ç—å-—ç—Ç—É-–∫–Ω–∏–≥—É">–ö–∞–∫ —á–∏—Ç–∞—Ç—å —ç—Ç—É –∫–Ω–∏–≥—É</a></h2>
<p>–≠—Ç–∞ –∫–Ω–∏–≥–∞ –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ—Ç, —á—Ç–æ –≤—ã –±—É–¥–µ—Ç–µ –µ—ë —á–∏—Ç–∞—Ç—å –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ, –æ—Ç –Ω–∞—á–∞–ª–∞ –¥–æ –∫–æ–Ω—Ü–∞. –ü–æ—Å–ª–µ–¥—É—é—â–∏–µ –≥–ª–∞–≤—ã –æ–ø–∏—Ä–∞—é—Ç—Å—è –Ω–∞ –∏–∑—É—á–µ–Ω–Ω–æ–µ –≤ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö, –∏ –±–æ–ª–µ–µ —Ä–∞–Ω–Ω–∏–µ –º–æ–≥—É—Ç –æ—Ö–≤–∞—Ç—ã–≤–∞—Ç—å –æ—Ç–¥–µ–ª—å–Ω—ã–µ —Ç–µ–º—ã –ª–∏—à—å –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–Ω–æ, —Å —É—á—ë—Ç–æ–º —Ç–æ–≥–æ, —á—Ç–æ –≤—Å—ë –ø—Ä–æ–ø—É—â–µ–Ω–Ω–æ–µ –±—É–¥–µ—Ç –ø–æ–¥—Ä–æ–±–Ω–æ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–æ –¥–∞–ª–µ–µ.</p>
<p>–í —ç—Ç–æ–π –∫–Ω–∏–≥–µ –≤—ã –Ω–∞–π–¥—ë—Ç–µ –¥–≤–∞ –≤–∏–¥–∞ –≥–ª–∞–≤: —Ç–µ–æ—Ä–µ—Ç–∏—á–µ—Å–∫–∏–µ –∏ –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ. –í —Ç–µ–æ—Ä–µ—Ç–∏—á–µ—Å–∫–∏—Ö –≥–ª–∞–≤–∞—Ö –≤—ã –±—É–¥–µ—Ç–µ –∏–∑—É—á–∞—Ç—å —Ä–∞–∑–Ω—ã–µ –≥—Ä–∞–Ω–∏ —è–∑—ã–∫–∞ Rust. –í –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏—Ö –≥–ª–∞–≤–∞—Ö –º—ã –±—É–¥–µ–º –≤–º–µ—Å—Ç–µ —Å –≤–∞–º–∏ —Ä–∞–∑—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –Ω–µ–±–æ–ª—å—à–∏–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã, –ø—Ä–∏–º–µ–Ω—è—è –≤—Å—ë, —á—Ç–æ –≤—ã –∏–∑—É—á–∏–ª–∏ —Ä–∞–Ω–µ–µ. –ì–ª–∞–≤—ã 2, 12 –∏ 21 ‚Äî –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ, –æ—Å—Ç–∞–ª—å–Ω—ã–µ ‚Äî —Ç–µ–æ—Ä–µ—Ç–∏—á–µ—Å–∫–∏–µ.</p>
<p>–ì–ª–∞–≤–∞ 1 –æ–±—ä—è—Å–Ω—è–µ—Ç, –∫–∞–∫ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å Rust, –Ω–∞–ø–∏—Å–∞—Ç—å "Hello, world!" –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Cargo ‚Äî –ø–∞–∫–µ—Ç–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä –∏ —Å–∏—Å—Ç–µ–º—É —Å–±–æ—Ä–∫–∏ Rust. –ì–ª–∞–≤–∞ 2 ‚Äî —ç—Ç–æ –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–æ–µ –≤–≤–µ–¥–µ–Ω–∏–µ –≤ –Ω–∞–ø–∏—Å–∞–Ω–∏–µ –ø—Ä–æ–≥—Ä–∞–º–º –Ω–∞ Rust, –≤ —Ä–∞–º–∫–∞—Ö –∫–æ—Ç–æ—Ä–æ–≥–æ –≤—ã –Ω–∞–ø–∏—à–µ—Ç–µ –∏–≥—Ä—É –≤ —É–≥–∞–¥–∞–π–∫—É. –í –Ω–µ–π –º—ã –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–Ω–æ —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º —Å–∞–º—ã–µ –æ—Å–Ω–æ–≤—ã, –∞ –≤ —Å–ª–µ–¥—É—é—â–∏—Ö —á–∞—Å—Ç—è—Ö –º—ã –±—É–¥–µ–º –∏–∑—É—á–∞—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –¥–µ—Ç–∞–ª–∏. –ï—Å–ª–∏ –≤—ã —Ö–æ—Ç–∏—Ç–µ —Å—Ä–∞–∑—É –ø—Ä–∏—Å—Ç—É–ø–∏—Ç—å –∫ —Ä–∞–±–æ—Ç–µ, –≤—ã –º–æ–∂–µ—Ç–µ –Ω–∞—á–∞—Ç—å –ø—Ä—è–º–æ —Å –ì–ª–∞–≤—ã 2. –ì–ª–∞–≤–∞ 3 —Ä–∞—Å–∫—Ä–æ–µ—Ç —Ç–æ—Ç —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª Rust, –∫–æ—Ç–æ—Ä—ã–π –≤—ã –ø—Ä–∏–≤—ã–∫–ª–∏ –≤–∏–¥–µ—Ç—å –≤ –¥—Ä—É–≥–∏—Ö –ø–æ–¥–æ–±–Ω—ã—Ö —è–∑—ã–∫–∞—Ö –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è, –∞ –≤ –ì–ª–∞–≤–µ 4 –≤—ã –∏–∑—É—á–∏—Ç–µ –º–µ—Ö–∞–Ω–∏–∑–º –≤–ª–∞–¥–µ–Ω–∏—è. –ï—Å–ª–∏ –≤—ã —Ö–æ—Ç–µ–ª–∏ –±—ã —Å–Ω–∞—á–∞–ª–∞ –∏–∑—É—á–∏—Ç—å —Ç–µ–æ—Ä–∏—é, —Ç–æ –≤—ã –º–æ–∂–µ—Ç–µ —Å–Ω–∞—á–∞–ª–∞ –ø—Ä–æ—á–µ—Å—Ç—å –ì–ª–∞–≤—É 3, –∞ –ø–æ—Ç–æ–º –≤–µ—Ä–Ω—É—Ç—å—Å—è –∫ –ì–ª–∞–≤–µ 2, –∫–æ–≥–¥–∞ –∑–∞—Ö–æ—Ç–∏—Ç–µ –∑–∞—Ö–æ—Ç–∏—Ç–µ –ø–æ—Ä–∞–±–æ—Ç–∞—Ç—å –Ω–∞–¥ –ø—Ä–æ–µ–∫—Ç–æ–º, –ø—Ä–∏–º–µ–Ω—è—è –∏–∑—É—á–µ–Ω–Ω–æ–µ.</p>
<p>–í –ì–ª–∞–≤–µ 5 –æ–±—Å—É–∂–¥–∞—é—Ç—Å—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –∏ –º–µ—Ç–æ–¥—ã. –ì–ª–∞–≤–∞ 6 –æ—Ö–≤–∞—Ç—ã–≤–∞–µ—Ç –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è, –≤—ã—Ä–∞–∂–µ–Ω–∏–µ <code>match</code> –∏ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏—é —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è <code>if let</code>. –°—Ç—Ä—É–∫—Ç—É—Ä—ã –∏ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –ø—Ä–∏–≥–æ–¥—è—Ç—Å—è –≤–∞–º –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã—Ö —Ç–∏–ø–æ–≤ –¥–∞–Ω–Ω—ã—Ö.</p>
<p>–í –ì–ª–∞–≤–µ 7 –≤—ã –ø–æ–∑–Ω–∞–∫–æ–º–∏—Ç–µ—Å—å —Å —Å–∏—Å—Ç–µ–º–æ–π –º–æ–¥—É–ª–µ–π –∏ –ø—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç–∏ Rust, –∫–æ—Ç–æ—Ä–∞—è –ø–æ–º–æ–∂–µ—Ç –≤–∞–º –æ—Ä–≥–∞–Ω–∏–∑–æ–≤—ã–≤–∞—Ç—å —Å–≤–æ–π –∫–æ–¥ –∏ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –¥–ª—è –Ω–µ–≥–æ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –º–µ–∂–ø—Ä–æ–≥—Ä–∞–º–º–Ω–æ–≥–æ  –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è (API ‚Äî Application Programming Interface). –ì–ª–∞–≤–∞ 8 –ø–æ—Å–≤—è—â–µ–Ω–∞ –æ—Å–Ω–æ–≤–Ω—ã–º —Å—Ç—Ä—É–∫—Ç—É—Ä–∞–º –¥–∞–Ω–Ω—ã—Ö, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ–º—ã—Ö —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–æ–π: –≤–µ–∫—Ç–æ—Ä–∞–º, —Å—Ç—Ä–æ–∫–∞–º, —Ö–µ—à-—Ç–∞–±–ª–∏—Ü–∞–º. –í –ì–ª–∞–≤–µ 9 –º—ã –æ–±—Å—É–¥–∏–º –≤–∑–≥–ª—è–¥ Rust –Ω–∞ –æ–±—Ä–∞–±–æ—Ç–∫—É –æ—à–∏–±–æ–∫ –∏ –µ—ë —Å—Ä–µ–¥—Å—Ç–≤–∞.</p>
<p>–í –ì–ª–∞–≤–µ 10 —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞—é—Ç—Å—è –æ–±–æ–±—â—ë–Ω–Ω—ã–µ —Ç–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö, —Ç—Ä–µ–π—Ç—ã –∏ –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ ‚Äî —Å—Ä–µ–¥—Å—Ç–≤–∞, –ø–æ–∑–≤–æ–ª—è—é—â–∏–µ –æ–ø—Ä–µ–¥–µ–ª—è—Ç—å —Å—Ö–æ–∂–µ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ —Å—Ä–∞–∑—É –¥–ª—è –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Ç–∏–ø–æ–≤. –ì–ª–∞–≤–∞ 11 –ø–æ—Å–≤—è—â–µ–Ω–∞ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—é; –≥–∞—Ä–∞–Ω—Ç–∏–∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ Rust –æ—Ç–≤–µ—á–∞—é—Ç –∑–∞ —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫—É—é –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å –≤–∞—à–∏—Ö –ø—Ä–æ–≥—Ä–∞–º–º, –∞ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ–Ω–∞–¥–æ–±–∏—Ç—Å—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–æ–∫ –ª–æ–≥–∏—á–µ—Å–∫–æ–π –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç–∏. –í –ì–ª–∞–≤–µ 12 –º—ã –Ω–∞–ø–∏—à–µ–º –ø—Ä–æ–≥—Ä–∞–º–º—É, —Ä–µ–∞–ª–∏–∑—É—é—â—É—é –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–æ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏ —É—Ç–∏–ª–∏—Ç—ã –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏ <code>grep</code> ‚Äî –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞ –ø–æ–ª–Ω–æ—Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ –ø–æ–∏—Å–∫–∞ –ø–æ —Ñ–∞–π–ª—É. –û–Ω–∞ –ø–æ—Ç—Ä–µ–±—É–µ—Ç –º–Ω–æ–≥–æ–µ –∏–∑ —Ç–æ–≥–æ, —á—Ç–æ –º—ã –∏–∑—É—á–∏–º –∫ —ç—Ç–æ–º—É –º–æ–º–µ–Ω—Ç—É.</p>
<p>–í –ì–ª–∞–≤–µ 13 —Ä–µ—á—å –∏–¥—ë—Ç –æ –∑–∞–º—ã–∫–∞–Ω–∏—è—Ö –∏ –∏—Ç–µ—Ä–∞—Ç–æ—Ä–∞—Ö: –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç—è—Ö Rust, –≤–∑—è—Ç—ã—Ö –∏–∑ —Ñ—É–Ω–∫—Ü–æ–Ω–∞–ª—å–Ω—ã—Ö —è–∑—ã–∫–æ–≤ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è. –í –ì–ª–∞–≤–µ 14 –º—ã –ø–æ–¥—Ä–æ–±–Ω–µ–µ –∏–∑—É—á–∏–º Cargo –∏ –ø–æ–≥–æ–≤–æ—Ä–∏–º –æ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–∏–∏ –≤–∞—à–∏—Ö –±–∏–±–ª–∏–æ—Ç–µ–∫ —Å—Ä–µ–¥–∏ –¥—Ä—É–≥–∏—Ö —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤. –í –ì–ª–∞–≤–µ 15 –æ–±—Å—É–∂–¥–∞—é—Ç—Å—è —É–º–Ω—ã–µ —É–∫–∞–∑–∞—Ç–µ–ª–∏, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ–º—ã–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–æ–π, –∞ —Ç–∞–∫–∂–µ —Ç—Ä–µ–π—Ç—ã, –ª–µ–∂–∞—â–∏–µ –≤ –∏—Ö –æ—Å–Ω–æ–≤–µ.</p>
<p>–í –ì–ª–∞–≤–µ 16 –º—ã –ø—Ä–æ–π–¥—ë–º—Å—è –ø–æ —Ä–∞–∑–ª–∏—á–Ω—ã–º –º–æ–¥–µ–ª—è–º –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è –∏ –æ–±—Å—É–¥–∏–º, –∫–∞–∫ Rust –ø–æ–º–æ–≥–∞–µ—Ç –ø–∏—Å–∞—Ç—å –±–µ–∑–æ–ø–∞—Å–Ω—ã–µ –º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω—ã–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã. –í –ì–ª–∞–≤–µ 17 –º—ã –∏–∑—É—á–∏–º —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è –∏ –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ–º—É—é –∏–º–∏ –æ–±–ª–µ–≥—á—ë–Ω–Ω—É—é –º–æ–¥–µ–ª—å –ø–∞—Ä–∞–ª–ª–µ–ª–∏–∑–º–∞.</p>
<p>–í –ì–ª–∞–≤–µ 18 —Å—Ä–∞–≤–Ω–∏–≤–∞—é—Ç—Å—è —à–∏—Ä–æ–∫–æ –∏–∑–≤–µ—Å—Ç–Ω—ã–µ –∏–¥–µ–∏ –∏–∑ –ø–∞—Ä–∞–¥–∏–≥–º—ã –æ–±—ä–µ–∫—Ç–Ω–æ-–æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è –∏ –∞–Ω–∞–ª–æ–≥–∏—á–Ω—ã–µ –∏–º —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –Ω–∞ Rust.</p>
<p>–ì–ª–∞–≤–∞ 19 —Å–æ–¥–µ—Ä–∂–∏—Ç —Å–ø—Ä–∞–≤–∫—É –ø–æ —à–∞–±–ª–æ–Ω–∞–º –∏ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—é —Å —à–∞–±–ª–æ–Ω–æ–º, —è–≤–ª—è—é—â–∏–º–∏—Å—è –º–æ—â–Ω—ã–º —Å—Ä–µ–¥—Å—Ç–≤–æ–º –≤—ã—Ä–∞–∂–µ–Ω–∏—è —Ä–∞–∑–ª–∏—á–Ω—ã—Ö –∏–¥–µ–π –≤ –ø—Ä–æ–≥—Ä–∞–º–º–∞—Ö –Ω–∞ Rust. –í –ì–ª–∞–≤–µ 20 —Ä–µ—á—å –ø–æ–π–¥—ë—Ç –æ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã—Ö —Ç–µ–º–∞—Ö, —Ç–∞–∫–∏—Ö –∫–∞–∫ –Ω–µ–±–µ–∑–æ–ø–∞—Å–Ω–æ–µ –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–æ Rust, –º–∞–∫—Ä–æ—Å—ã, –∏ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –∫–∞—Å–∞—Ç–µ–ª—å–Ω–æ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏, —Ç—Ä–µ–π—Ç–æ–≤, —Ç–∏–ø–æ–≤, —Ñ—É–Ω–∫—Ü–∏–π –∏ –∑–∞–º—ã–∫–∞–Ω–∏–π.</p>
<p>–í –ì–ª–∞–≤–µ 21 –º—ã –Ω–∞–ø–∏—à–µ–º —Å–≤–æ–π –Ω–∏–∑–∫–æ—É—Ä–æ–≤–Ω–µ–≤—ã–π –º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω—ã–π –≤–µ–±-—Å–µ—Ä–≤–µ—Ä!</p>
<p>–ù–∞–∫–æ–Ω–µ—Ü, –µ—Å—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π, —Å–æ–¥–µ—Ä–∂–∞—â–∏—Ö –ø–æ–ª–µ–∑–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —è–∑—ã–∫–µ –≤ –±–æ–ª–µ–µ —Å—É—Ö–æ–º, —Å–ø—Ä–∞–≤–æ—á–Ω–æ–º –≤–∏–¥–µ. –í <strong>–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ A</strong> —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞—é—Ç—Å—è –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ Rust; –≤ <strong>–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ B</strong>  ‚Äî –æ–ø–µ—Ä–∞—Ç–æ—Ä—ã –∏ —Å–∏–º–≤–æ–ª—ã; –≤ <strong>–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ C</strong> ‚Äî –≤—ã–≤–æ–¥–∏–º—ã–µ —Ç—Ä–µ–π—Ç—ã, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ–º—ã–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–æ–π; –≤ <strong>–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ D</strong> ‚Äî –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –ø–æ–ª–µ–∑–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏; –≤ <strong>–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ E</strong> ‚Äî —Ä–µ–¥–∞–∫—Ü–∏–∏ Rust. –í <strong>–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ F</strong> –≤—ã –Ω–∞–π–¥—ë—Ç–µ –ø–µ—Ä–µ–≤–æ–¥—ã —ç—Ç–æ–π –∫–Ω–∏–≥–∏, –∞ –≤ <strong>–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ G</strong> –≤—ã —É–∑–Ω–∞–µ—Ç–µ, –∫–∞–∫ —Ä–∞–∑—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è Rust –∏ —á—Ç–æ —Ç–∞–∫–æ–µ Nightly Rust. <em>(–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫–∞: –ø–µ—Ä–µ–≤–æ–¥—ã, –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–Ω—ã–µ –≤ –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ F, –≤—ã–ø–æ–ª–Ω–µ–Ω—ã –≤ —Å—Ç–æ—Ä–æ–Ω–Ω–∏—Ö —Ä–∞–∑—Ä–æ–∑–Ω–µ–Ω–Ω—ã—Ö —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è—Ö. –ü–µ—Ä–µ–≤–æ–¥—ã, –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ –≤</em> —ç—Ç–æ–π <em>—Å–∏—Å—Ç–µ–º–µ, –≤—Å–µ–≥–¥–∞ –¥–æ—Å—Ç—É–ø–Ω—ã –≤ –º–µ–Ω—é –ø–æ –∫–Ω–æ–ø–∫–µ –≥–ª–æ–±—É—Å–∞ —Å–ø—Ä–∞–≤–∞ —Å–≤–µ—Ä—Ö—É.)</em></p>
<p>–ù–µ—Ç –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ —Å–ø–æ—Å–æ–±–∞ —á—Ç–µ–Ω–∏—è —ç—Ç–æ–π –∫–Ω–∏–≥–∏: –µ—Å–ª–∏ –≤—ã —Ö–æ—Ç–∏—Ç–µ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å —á—Ç–æ-–ª–∏–±–æ –∏ –ø–æ–π—Ç–∏ –≤–ø–µ—Ä—ë–¥ ‚Äî –¥–µ—Ä–∑–∞–π—Ç–µ! –í–æ–∑–º–æ–∂–Ω–æ, –≤–∞–º –ø–æ–Ω–∞–¥–æ–±–∏—Ç—Å—è –≤–µ—Ä–Ω—É—Ç—å—Å—è –∫ –ø—Ä–µ–¥—ã–¥—É—â–∏–º –≥–ª–∞–≤–∞–º, –µ—Å–ª–∏ –≤—ã –ø–æ—á—É–≤—Å—Ç–≤—É–µ—Ç–µ —Å–µ–±—è –Ω–µ—É–≤–µ—Ä–µ–Ω–Ω–æ. –í –ª—é–±–æ–º —Å–ª—É—á–∞–µ: –¥–µ–ª–∞–π—Ç–µ —Ç–∞–∫, –∫–∞–∫ –≤–∞–º –±—É–¥–µ—Ç —É–¥–æ–±–Ω–æ.</p>
<p><span id="ferris"></span></p>
<p>–í–∞–∂–Ω–æ–π —á–∞—Å—Ç—å—é –ø—Ä–æ—Ü–µ—Å—Å–∞ –æ–±—É—á–µ–Ω–∏—è —è–∑—ã–∫—É Rust —è–≤–ª—è–µ—Ç—Å—è –æ–±—É—á–µ–Ω–∏–µ —á—Ç–µ–Ω–∏—é —Å–æ–æ–±—â–µ–Ω–∏–π –æ–± –æ—à–∏–±–∫–∞—Ö –∏ –≤—ã–≤–æ–¥–∞ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞: –æ–Ω–∏ –±—É–¥—É—Ç –Ω–∞–ø—Ä–∞–≤–ª—è—Ç—å –≤–∞—Å –∫ –∂–µ–ª–∞–µ–º–æ–º—É —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É. –°–æ–±—Å—Ç–≤–µ–Ω–Ω–æ, –º—ã –±—É–¥–µ–º –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –±–æ–ª—å—à–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–∏–º–µ—Ä–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ –∫–æ–º–ø–∏–ª–∏—Ä—É—é—Ç—Å—è, –≤–º–µ—Å—Ç–µ —Å –∏—Ö –æ—à–∏–±–∫–∞–º–∏ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏. –ü–æ–º–Ω–∏—Ç–µ: –Ω–µ —Ñ–∞–∫—Ç, —á—Ç–æ –≤–∑—è–≤ –ª—é–±–æ–π –ø—Ä–∏–º–µ—Ä, –æ–Ω —Å–∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è! –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –ø—Ä–æ—á–∏—Ç–∞–ª–∏ —Å–≤—è–∑–∞–Ω–Ω—ã–π —Å —ç—Ç–∏–º –ø—Ä–∏–º–µ—Ä–æ–º —Ç–µ–∫—Å—Ç –∏ –ø–æ—Å–º–æ—Ç—Ä–µ–ª–∏, –Ω–µ –ø–æ–¥—Ä–∞–∑—É–º–µ–≤–∞–µ—Ç—Å—è –ª–∏ –Ω–µ—É–¥–∞—á–∞ –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ –µ–≥–æ –∑–∞–ø—É—Å—Ç–∏—Ç—å. –ë—ã—Å—Ç—Ä–æ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∑–∞–≤–µ–¥–æ–º–æ –Ω–µ—Ä–∞–±–æ—á–∏–π –∫–æ–¥ –≤–∞–º –ø–æ–º–æ–∂–µ—Ç –§–µ—Ä—Ä–∏—Å:</p>
<div class="table-wrapper"><table><thead><tr><th>–§–µ—Ä—Ä–∏—Å</th><th>–ß—Ç–æ –∏–º–µ–µ—Ç –≤ –≤–∏–¥—É</th></tr></thead><tbody>
<tr><td><img src="img/ferris/does_not_compile.svg" class="ferris-explain" alt="–§–µ—Ä—Ä–∏—Å —Å–æ –∑–Ω–∞–∫–æ–º –≤–æ–ø—Ä–æ—Å–∞"/></td><td></td></tr>
<tr><td>–≠—Ç–æ—Ç –∫–æ–¥ –Ω–µ –∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è!</td><td></td></tr>
<tr><td><img src="img/ferris/panics.svg" class="ferris-explain" alt="–§–µ—Ä—Ä–∏—Å –≤–æ–∑–¥–µ–ª –∫–ª–µ—à–Ω–∏ –≤–≤–µ—Ä—Ö"/></td><td></td></tr>
<tr><td>–≠—Ç–æ—Ç –∫–æ–¥ –ø—Ä–∏–≤–µ–¥—ë—Ç –∫ –ø–∞–Ω–∏–∫–µ!</td><td></td></tr>
<tr><td><img src="img/ferris/not_desired_behavior.svg" class="ferris-explain" alt="–§–µ—Ä—Ä–∏—Å –ø–æ–¥–Ω—è–ª –æ–¥–Ω—É –∫–ª–µ—à–Ω—é, –∫–∞–∫ –±—ã –ø–æ–∂–∏–º–∞—è –ø–ª–µ—á–∞–º–∏"/></td><td></td></tr>
<tr><td>–≠—Ç–æ—Ç –∫–æ–¥ –≤–µ–¥—ë—Ç —Å–µ–±—è –Ω–µ —Ç–∞–∫, –∫–∞–∫ –∑–∞–¥—É–º–∞–Ω–æ.</td><td></td></tr>
</tbody></table>
</div>
<p>–í –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–µ —Å–ª—É—á–∞–µ–≤, –º—ã –ø—Ä–∏–≤–µ–¥—ë–º –≤–∞—Å –∫ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ–π –≤–µ—Ä—Å–∏–∏ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –ø—Ä–∏–º–µ—Ä–æ–≤.</p>
<h2 id="–ò—Å—Ö–æ–¥–Ω—ã–π-–∫–æ–¥"><a class="header" href="#–ò—Å—Ö–æ–¥–Ω—ã–π-–∫–æ–¥">–ò—Å—Ö–æ–¥–Ω—ã–π –∫–æ–¥</a></h2>
<p>–ò—Å—Ö–æ–¥–Ω—ã–µ —Ñ–∞–π–ª—ã, –∏–∑ –∫–æ—Ç–æ—Ä—ã—Ö —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–∞ —ç—Ç–∞ –∫–Ω–∏–≥–∞, –º–æ–∂–Ω–æ –Ω–∞–π—Ç–∏ –Ω–∞ <a href="https://github.com/rust-lang/book/tree/main/src">GitHub</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="–ù–∞—á–∞–ª–æ"><a class="header" href="#–ù–∞—á–∞–ª–æ">–ù–∞—á–∞–ª–æ</a></h1>
<p>–ù–∞—á–Ω—ë–º –≤–∞—à–µ –ø—É—Ç–µ—à–µ—Å—Ç–≤–∏–µ –≤ –º–∏—Ä Rust! –ù–∞–º –ø—Ä–µ–¥—Å—Ç–æ–∏—Ç –∏–∑—É—á–∏—Ç—å –æ—á–µ–Ω—å –º–Ω–æ–≥–æ–µ, –Ω–æ —Å –∫–∞–∂–¥—ã–º –ø–µ—Ä–µ–π–¥—ë–Ω–Ω—ã–º —Ä—É–±–µ–∂–æ–º –≤–∞–º –±—É–¥–µ—Ç –ª–µ–≥—á–µ. –í —ç—Ç–æ–π –≥–ª–∞–≤–µ –º—ã –æ–±—Å—É–¥–∏–º:</p>
<ul>
<li>–£—Å—Ç–∞–Ω–æ–≤–∫—É Rust –Ω–∞ Linux, macOS –∏ Windows</li>
<li>–°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã, –ø–µ—á–∞—Ç–∞—é—â–µ–π <code>Hello, world!</code></li>
<li>–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ <code>cargo</code> ‚Äî –ø–∞–∫–µ—Ç–Ω–æ–≥–æ –º–µ–Ω–µ–¥–∂–µ—Ä–∞ –∏ —Å–∏—Å—Ç–µ–º—ã —Å–±–æ—Ä–∫–∏ Rust</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–£—Å—Ç–∞–Ω–æ–≤–∫–∞"><a class="header" href="#–£—Å—Ç–∞–Ω–æ–≤–∫–∞">–£—Å—Ç–∞–Ω–æ–≤–∫–∞</a></h2>
<p>–ü–µ—Ä–≤—ã–º –¥–µ–ª–æ–º —É—Å—Ç–∞–Ω–æ–≤–∏–º Rust. –î–ª—è —ç—Ç–æ–≥–æ –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º <code>rustup</code> ‚Äî –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏, –ø–æ–∑–≤–æ–ª—è—é—â–µ–µ —É–ø—Ä–∞–≤–ª—è—Ç—å –≤–µ—Ä—Å–∏—è–º–∏ Rust –∏ –Ω–µ–∫–æ—Ç–æ—Ä—ã–º–∏ –¥—Ä—É–≥–∏–º–∏ –æ—Å–Ω–æ–≤–Ω—ã–º–∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞–º–∏. –í–∞–º –ø–æ–Ω–∞–¥–æ–±–∏—Ç—Å—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç—É.</p>
<blockquote>
<p>–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: –ï—Å–ª–∏ –ø–æ –∫–∞–∫–æ–π-—Ç–æ –ø—Ä–∏—á–∏–Ω–µ –≤—ã –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ—Ç–µ –Ω–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å <code>rustup</code>, –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ <a href="https://forge.rust-lang.org/infra/other-installation-methods.html">—Å—Ç—Ä–∞–Ω–∏—Ü–µ –¥—Ä—É–≥–∏—Ö –º–µ—Ç–æ–¥–æ–≤ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ Rust</a>.</p>
</blockquote>
<p>–°–ª–µ–¥—É—è –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –Ω–∏–∂–µ, –≤—ã —É—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –ø–æ—Å–ª–µ–¥–Ω—é—é —Å—Ç–∞–±–∏–ª—å–Ω—É—é –≤–µ—Ä—Å–∏—é –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞ Rust. –°—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å Rust –≤–∫–ª—é—á–∞–µ—Ç –≤ —Å–µ–±—è –≥–∞—Ä–∞–Ω—Ç–∏–∏ —Ç–æ–≥–æ, —á—Ç–æ –≤—Å–µ –∫–æ–º–ø–∏–ª–∏—Ä—É—é—â–∏–µ—Å—è –ø—Ä–∏–º–µ—Ä—ã  –∏–∑ —ç—Ç–æ–π –∫–Ω–∏–≥–∏ –±—É–¥—É—Ç –∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞—Ç—å—Å—è –∏ —Å –±–æ–ª–µ–µ –Ω–æ–≤–æ–π –≤–µ—Ä—Å–∏–µ–π Rust. –°–æ–æ–±—â–µ–Ω–∏—è –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞ –º–æ–≥—É—Ç –Ω–µ—Å–∫–æ–ª—å–∫–æ –æ—Ç–ª–∏—á–∞—Ç—å—Å—è –æ—Ç –≤–µ—Ä—Å–∏–∏ –∫ –≤–µ—Ä—Å–∏–∏, –ø–æ—Å–∫–æ–ª—å–∫—É Rust –ø–æ—Å—Ç–æ—è–Ω–Ω–æ —Å–æ–≤–µ—Ä—à–µ–Ω—Å—Ç–≤—É–µ—Ç —Å–≤–æ—ë –æ–±—â–µ–Ω–∏–µ —Å –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç–æ–º –∏ –º–µ–Ω—è–µ—Ç –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è –∏ —Å–æ–æ–±—â–µ–Ω–∏—è –æ–± –æ—à–∏–±–∫–∞—Ö. –ò–Ω—ã–º–∏ —Å–ª–æ–≤–∞–º–∏, –ª—é–±–∞—è –±–æ–ª–µ–µ –Ω–æ–≤–∞—è –∏ —Å—Ç–∞–±–∏–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è Rust, —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω–∞—è –ø–æ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –Ω–∏–∂–µ, –±—É–¥–µ—Ç —Ä–µ–∞–ª–∏–∑–æ–≤—ã–≤–∞—Ç—å –æ–ø–∏—Å–∞–Ω–Ω–æ–µ –≤ —ç—Ç–æ–π –∫–Ω–∏–≥–µ —Ç–∞–∫, –∫–∞–∫ –æ–∂–∏–¥–∞–µ—Ç—Å—è.</p>
<blockquote>
<h3 id="–î–æ–≥–æ–≤–æ—Ä—ë–Ω–Ω–æ—Å—Ç—å-–æ-—Å—Ç–∏–ª–µ-–∫–æ–Ω—Å–æ–ª—å–Ω—ã—Ö-–∫–æ–º–∞–Ω–¥-–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"><a class="header" href="#–î–æ–≥–æ–≤–æ—Ä—ë–Ω–Ω–æ—Å—Ç—å-–æ-—Å—Ç–∏–ª–µ-–∫–æ–Ω—Å–æ–ª—å–Ω—ã—Ö-–∫–æ–º–∞–Ω–¥-–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è">–î–æ–≥–æ–≤–æ—Ä—ë–Ω–Ω–æ—Å—Ç—å –æ —Å—Ç–∏–ª–µ –∫–æ–Ω—Å–æ–ª—å–Ω—ã—Ö –∫–æ–º–∞–Ω–¥ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è</a></h3>
<p>–í —ç—Ç–æ–π –∏ –ø–æ—Å–ª–µ–¥—É—é—â–∏—Ö –≥–ª–∞–≤–∞—Ö –∫–Ω–∏–≥–∏ –º—ã –±—É–¥–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –∫–æ–Ω—Å–æ–ª—å–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã. –°—Ç—Ä–æ–∫–∏, –∫–æ—Ç–æ—Ä—ã–µ –≤–∞–º –Ω—É–∂–Ω–æ –±—É–¥–µ—Ç –≤–≤–æ–¥–∏—Ç—å –≤ —Ç–µ—Ä–º–∏–Ω–∞–ª, –Ω–∞—á–∏–Ω–∞—é—Ç—Å—è —Å <code>$</code>. –í–∞–º –Ω–µ –Ω—É–∂–Ω–æ –≤–≤–æ–¥–∏—Ç—å —Å–∞–º —Å–∏–º–≤–æ–ª <code>$</code>, —ç—Ç–æ –ª–∏—à—å –æ–±–æ–∑–Ω–∞—á–µ–Ω–∏–µ –Ω–∞—á–∞–ª–∞ –æ—Ç–¥–µ–ª—å–Ω–æ–π –∫–æ–º–∞–Ω–¥—ã. –°—Ç—Ä–æ–∫–∏, –Ω–µ –Ω–∞—á–∏–Ω–∞—é—â–∏–µ—Å—è —Å <code>$</code>, –æ–±—ã—á–Ω–æ —è–≤–ª—è—é—Ç—Å—è –≤—ã—Ö–æ–¥–æ–º –ø—Ä–µ–¥—ã–¥—É—â–µ–π –∫–æ–º–∞–Ω–¥—ã. –ö—Ä–æ–º–µ —Ç–æ–≥–æ, –º—ã –±—É–¥–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∑–Ω–∞–∫ <code>&gt;</code> –¥–ª—è –ø—Ä–∏–º–µ—Ä–æ–≤, —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã—Ö –¥–ª—è PowerShell.</p>
</blockquote>
<h3 id="–£—Å—Ç–∞–Ω–æ–≤–∫–∞-rustup-–Ω–∞-linux-–∏-macos"><a class="header" href="#–£—Å—Ç–∞–Ω–æ–≤–∫–∞-rustup-–Ω–∞-linux-–∏-macos">–£—Å—Ç–∞–Ω–æ–≤–∫–∞ <code>rustup</code> –Ω–∞ Linux –∏ macOS</a></h3>
<p>–ï—Å–ª–∏ –≤—ã –∏—Å–ø–æ–ª—å–∑—É–µ—Ç–µ Linux –∏–ª–∏ macOS, –æ—Ç–∫—Ä–æ–π—Ç–µ —Ç–µ—Ä–º–∏–Ω–∞–ª –∏ –≤–≤–µ–¥–∏—Ç–µ —Å–ª–µ–¥—É—é—â—É—é –∫–æ–º–∞–Ω–¥—É:</p>
<pre><code class="language-console">$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
</code></pre>
<p>–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ —Å–∫–∞—á–∏–≤–∞–µ—Ç —Å–∫—Ä–∏–ø—Ç –∏ –∑–∞–ø—É—Å–∫–∞–µ—Ç —É—Å—Ç–∞–Ω–æ–≤–∫—É –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞ <code>rustup</code>, –∫–æ—Ç–æ—Ä—ã–π —É—Å—Ç–∞–Ω–æ–≤–∏—Ç –ø–æ—Å–ª–µ–¥–Ω—é—é —Å—Ç–∞–±–∏–ª—å–Ω—É—é –≤–µ—Ä—Å–∏—é Rust. –í –ø—Ä–æ—Ü–µ—Å—Å–µ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ —Å –≤–∞—Å –º–æ–∂–µ—Ç –ø–æ—Ç—Ä–µ–±–æ–≤–∞—Ç—å—Å—è –ø–∞—Ä–æ–ª—å. –ï—Å–ª–∏ —É—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø—Ä–æ–π–¥—ë—Ç —É—Å–ø–µ—à–Ω–æ, –≤—ã —É–≤–∏–¥–∏—Ç–µ —Ç–∞–∫–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ:</p>
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<p>–í–∞–º —Ç–∞–∫–∂–µ –ø–æ–Ω–∞–¥–æ–±–∏—Ç—Å—è <em>–∫–æ–º–ø–æ–Ω–æ–≤—â–∏–∫</em> (<em>linker</em>) ‚Äî –ø—Ä–æ–≥—Ä–∞–º–º–∞, –∏—Å–ø–æ–ª—å–∑—É–µ–º–∞—è Rust –¥–ª—è —Å–≤—è–∑—ã–≤–∞–Ω–∏—è –∫–æ–º–ø–∏–ª–∏—Ä—É–µ–º–æ–≥–æ –∫–æ–¥–∞ –≤ –æ–¥–∏–Ω —Ñ–∞–π–ª. –°–∫–æ—Ä–µ–µ –≤—Å–µ–≥–æ, –æ–¥–∏–Ω —É –≤–∞—Å —É–∂–µ –µ—Å—Ç—å. –ù–æ –µ—Å–ª–∏ –≤—ã –≤—Å—ë –∂–µ –ø–æ–ª—É—á–∞–µ—Ç–µ –æ—à–∏–±–∫–∏ –∫–æ–º–ø–æ–Ω–æ–≤–∫–∏, –≤–∞–º –Ω—É–∂–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä C, –∫–æ—Ç–æ—Ä—ã–π –æ–±—ã—á–Ω–æ –≤–∫–ª—é—á–∞–µ—Ç –≤ —Å–µ–±—è –∏ –∫–æ–º–ø–æ–Ω–æ–≤—â–∏–∫. –ö–æ–º–ø–∏–ª—è—Ç–æ—Ä C –±—É–¥–µ—Ç —Ç–∞–∫–∂–µ –ø–æ–ª–µ–∑–µ–Ω —Ç–µ–º, —á—Ç–æ –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—ë–Ω–Ω—ã–µ –ø–∞–∫–µ—Ç—ã Rust –æ–ø–∏—Ä–∞—é—Ç—Å—è –Ω–∞ –∫–æ–¥ –Ω–∞ C, –∞ –ø–æ—Ç–æ–º—É —Ç—Ä–µ–±—É—é—Ç –µ–≥–æ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä.</p>
<p>–ù–∞ macOS, –≤—ã –º–æ–∂–µ—Ç–µ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä C, –≤—ã–ø–æ–ª–Ω–∏–≤ —ç—Ç—É –∫–æ–º–∞–Ω–¥—É:</p>
<pre><code class="language-console">$ xcode-select --install
</code></pre>
<p>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º Linux, –≤ –æ–±—â–µ–º —Å–ª—É—á–∞–µ, –ø–æ–Ω–∞–¥–æ–±–∏—Ç—Å—è —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å GCC –∏–ª–∏ Clang ‚Äî –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–∏ —Å –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–µ–π –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –¥–∏—Å—Ç—Ä–∏–±—É—Ç–∏–≤–∞. –ù–∞–ø—Ä–∏–º–µ—Ä, –µ—Å–ª–∏ –≤—ã –∏—Å–ø–æ–ª—å–∑—É–µ—Ç–µ Ubuntu, —Ç–æ –º–æ–∂–µ—Ç–µ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–∞–∫–µ—Ç <code>build-essential</code>.</p>
<h3 id="–£—Å—Ç–∞–Ω–æ–≤–∫–∞-rustup-–Ω–∞-windows"><a class="header" href="#–£—Å—Ç–∞–Ω–æ–≤–∫–∞-rustup-–Ω–∞-windows">–£—Å—Ç–∞–Ω–æ–≤–∫–∞ <code>rustup</code> –Ω–∞ Windows</a></h3>
<p>–î–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –Ω–∞ Windows –ø–µ—Ä–µ–π–¥–∏—Ç–µ –Ω–∞ [https://www.rust-lang.org/tools/install] (https://www.rust-lang.org/tools/install) –∏ –≤—ã–ø–æ–ª–Ω–∏—Ç–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é –ø–æ —É—Å—Ç–∞–Ω–æ–≤–∫–µ Rust. –í –∫–∞–∫–æ–π-—Ç–æ –º–æ–º–µ–Ω—Ç —É—Å—Ç–∞–Ω–æ–≤–∫–∏, –≤–∞–º –º–æ–∂–µ—Ç –ø–æ–Ω–∞–¥–æ–±–∏—Ç—Å—è —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å Visual Studio. –° –Ω–µ–π –≤—ã –ø–æ–ª—É—á–∏—Ç–µ –∫–æ–º–ø–æ–Ω–æ–≤—â–∏–∫ –∏ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏, –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –¥–ª—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏. –ï—Å–ª–∏ –Ω–∞ –¥–∞–Ω–Ω–æ–º —à–∞–≥–µ –≤–∞–º –Ω—É–∂–Ω–∞ –ø–æ–º–æ—â—å, –ø–æ—Å–µ—Ç–∏—Ç–µ [https://rust-lang.github.io/" "rustup/installation/windows-msvc.html](https://rust-lang.github.io/rustup/" "installation/windows-msvc.html).</p>
<p>–û—Å—Ç–∞–≤—à–∞—è—Å—è —á–∞—Å—Ç—å —ç—Ç–æ–π –∫–Ω–∏–≥–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –∫–æ–º–∞–Ω–¥—ã, –∫–æ—Ç–æ—Ä—ã–µ –±—É–¥—É—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –∫–∞–∫ –≤ <em>cmd.exe</em>, —Ç–∞–∫ –∏ –≤ PowerShell. –ï—Å–ª–∏ –±—É–¥—É—Ç –∫–∞–∫–∏–µ-—Ç–æ —Å–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫–∏–µ –æ—Ç–ª–∏—á–∏—è, –º—ã –æ–±—ä—è—Å–Ω–∏–º, —á—Ç–æ –∏–º–µ–Ω–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å.</p>
<h3 id="–†–µ—à–µ–Ω–∏–µ-–ø—Ä–æ–±–ª–µ–º"><a class="header" href="#–†–µ—à–µ–Ω–∏–µ-–ø—Ä–æ–±–ª–µ–º">–†–µ—à–µ–Ω–∏–µ –ø—Ä–æ–±–ª–µ–º</a></h3>
<p>–ß—Ç–æ–±—ã –ø—Ä–æ–≤–µ—Ä–∏—Ç—å, —á—Ç–æ –≤—ã –ø—Ä–∞–≤–∏–ª—å–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–∏–ª–∏ Rust, –æ—Ç–∫—Ä–æ–π—Ç–µ —Ç–µ—Ä–º–∏–Ω–∞–ª –∏ –≤–≤–µ–¥–∏—Ç–µ —ç—Ç—É –∫–æ–º–∞–Ω–¥—É:</p>
<pre><code class="language-console">$ rustc --version
</code></pre>
<p>–í—ã –¥–æ–ª–∂–Ω—ã —É–≤–∏–¥–µ—Ç—å –Ω–æ–º–µ—Ä –≤–µ—Ä—Å–∏–∏, —Ö–µ—à –∫–æ–º–º–∏—Ç–∞ –∏ –¥–∞—Ç—É –∫–æ–º–º–∏—Ç–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–π –≤—ã–ø—É—â–µ–Ω–Ω–æ–π —Å—Ç–∞–±–∏–ª—å–Ω–æ–π –≤–µ—Ä—Å–∏–∏ –≤–æ—Ç –≤ —Ç–∞–∫–æ–º —Ñ–æ—Ä–º–∞—Ç–µ:</p>
<pre><code class="language-text">rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre>
<p>–ï—Å–ª–∏ –≤—ã –≤–∏–¥–∏—Ç–µ —ç—Ç–∏ –¥–∞–Ω–Ω—ã–µ, –∑–Ω–∞—á–∏—Ç, –≤—ã —É—Å–ø–µ—à–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–∏–ª–∏ Rust! –ï—Å–ª–∏ –∂–µ –Ω–µ –≤–∏–¥–∏—Ç–µ, —Ç–æ –ø—Ä–æ–≤–µ—Ä—å—Ç–µ, –µ—Å—Ç—å –∏ Rust –≤ –≤–∞—à–µ–π —Å–∏—Å—Ç–µ–º–Ω–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π %PATH%:</p>
<p>–í Windows CMD –≤–≤–µ–¥–∏—Ç–µ:</p>
<pre><code class="language-console">&gt; echo %PATH%
</code></pre>
<p>–í PowerShell –≤–≤–µ–¥–∏—Ç–µ:</p>
<pre><code class="language-powershell">&gt; echo $env:Path
</code></pre>
<p>–ù–∞ Linux –∏ macOS –≤–≤–µ–¥–∏—Ç–µ:</p>
<pre><code class="language-console">$ echo $PATH
</code></pre>
<p>–ï—Å–ª–∏ –≤—Å—ë –≤—ã–≥–ª—è–¥–∏—Ç –≤–µ—Ä–Ω–æ, –Ω–æ Rust –≤—Å—ë –µ—â—ë –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç, –µ—Å—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –º–µ—Å—Ç, –≥–¥–µ –≤–∞–º –º–æ–≥—É—Ç –ø–æ–º–æ—á—å. –í—ã –º–æ–∂–µ—Ç–µ –Ω–∞–π—Ç–∏ –ø–ª–æ—â–∞–¥–∫–∏ –¥–ª—è –æ–±—â–µ–Ω–∏—è —Å –¥—Ä—É–≥–∏–º–∏ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç–∞–º–∏ –Ω–∞ Rust –Ω–∞ <a href="https://www.rust-lang.org/community">—Å—Ç—Ä–∞–Ω–∏—Ü–µ –°–æ–æ–±—â–µ—Å—Ç–≤–∞</a>.</p>
<h3 id="–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ-–∏-–¥–µ–∏–Ω—Å—Ç–∞–ª–ª—è—Ü–∏—è"><a class="header" href="#–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ-–∏-–¥–µ–∏–Ω—Å—Ç–∞–ª–ª—è—Ü–∏—è">–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏ –¥–µ–∏–Ω—Å—Ç–∞–ª–ª—è—Ü–∏—è</a></h3>
<p>–û–¥–Ω–∞–∂–¥—ã —É—Å—Ç–∞–Ω–æ–≤–∏–≤ Rust —á–µ—Ä–µ–∑ <code>rustup</code>, –≤—ã –º–æ–∂–µ—Ç–µ –ª–µ–≥–∫–æ –µ–≥–æ –æ–±–Ω–æ–≤–∏—Ç—å. –û—Ç–∫—Ä–æ–π—Ç–µ –∫–æ–Ω—Å–æ–ª—å –∏ –≤—ã–ø–æ–ª–Ω–∏—Ç–µ —Å–ª–µ–¥—É—é—â—É—é –∫–æ–º–∞–Ω–¥—É:</p>
<pre><code class="language-console">$ rustup update
</code></pre>
<p>–î–ª—è —É–¥–∞–ª–µ–Ω–∏—è Rust –∏ <code>rustup</code> –∑–∞–ø—É—Å—Ç–∏—Ç–µ —Å–∫—Ä–∏–ø—Ç –¥–µ–∏–Ω—Å—Ç–∞–ª–ª—è—Ü–∏–∏:</p>
<pre><code class="language-console">$ rustup self uninstall
</code></pre>
<h3 id="–õ–æ–∫–∞–ª—å–Ω–æ-—É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω–∞—è-–¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è"><a class="header" href="#–õ–æ–∫–∞–ª—å–Ω–æ-—É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω–∞—è-–¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è">–õ–æ–∫–∞–ª—å–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω–∞—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è</a></h3>
<p>–£—Å—Ç–∞–Ω–æ–≤–∫–∞ Rust –≤–∫–ª—é—á–∞–µ—Ç –≤ —Å–µ–±—è —É—Å—Ç–∞–Ω–æ–≤–∫—É –ª–æ–∫–∞–ª—å–Ω–æ–π –∫–æ–ø–∏–∏ –≤—Å–µ–π –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏, —Ç–∞–∫ —á—Ç–æ –≤—ã –º–æ–∂–µ—Ç–µ —á–∏—Ç–∞—Ç—å –µ—ë –±–µ–∑ –¥–æ—Å—Ç—É–ø–∞ –∫ —Å–µ—Ç–∏. –ó–∞–ø—É—Å—Ç–∏—Ç–µ <code>rustup doc</code>, —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å –ª–æ–∫–∞–ª—å–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—É—é –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é –≤ —Å–≤–æ—ë–º –±—Ä–∞—É–∑–µ—Ä–µ.</p>
<p>–ï—Å–ª–∏ –≤—ã –≤—Å—Ç—Ä–µ—á–∞–µ—Ç–µ —Ç–∏–ø –∏–ª–∏ —Ñ—É–Ω–∫—Ü–∏—é, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ–º—ã–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–æ–π, –∏ –Ω–µ –∑–Ω–∞–µ—Ç–µ, –∫–∞–∫ –∏—Ö –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å, –∏–∑—É—á–∏—Ç–µ –∏—Ö API –≤ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏!</p>
<h3 id="–¢–µ–∫—Å—Ç–æ–≤—ã–µ-—Ä–µ–¥–∞–∫—Ç–æ—Ä—ã-–∏-–∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ-—Å—Ä–µ–¥—ã-—Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏-ide"><a class="header" href="#–¢–µ–∫—Å—Ç–æ–≤—ã–µ-—Ä–µ–¥–∞–∫—Ç–æ—Ä—ã-–∏-–∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ-—Å—Ä–µ–¥—ã-—Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏-ide">–¢–µ–∫—Å—Ç–æ–≤—ã–µ —Ä–µ–¥–∞–∫—Ç–æ—Ä—ã –∏ –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å—Ä–µ–¥—ã —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏ (IDE)</a></h3>
<p>–≠—Ç–∞ –∫–Ω–∏–≥–∞ –Ω–µ –ø–æ–¥—Ä–∞–∑—É–º–µ–≤–∞–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∫–∞–∫–æ–≥–æ-–ª–∏–±–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞ –¥–ª—è —Ä–∞–∑–±—Ä–∞–±–æ—Ç–∫–∏ –Ω–∞ Rust. –í–∞–º –±—É–¥–µ—Ç –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–∂–µ –ª–∏—à—å –ª—é–±–æ–≥–æ —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞! –¢–µ–º –Ω–µ –º–µ–Ω–µ–µ, –º–Ω–æ–≥–∏–µ —Ç–µ–∫—Å—Ç–æ–≤—ã–µ —Ä–µ–¥–∞–∫—Ç–æ—Ä—ã –∏ IDE (integrated development environment) –∏–º–µ—é—Ç –≤—Å—Ç—Ä–æ–µ–Ω–Ω—É—é –ø–æ–¥–¥–µ—Ä–∂–∫—É Rust. –í—ã –º–æ–∂–µ—Ç–µ —Å–ø–∏—Å–æ–∫ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Ä–µ–¥–∞–∫—Ç–æ—Ä–æ–≤ –∏ IDE –Ω–∞ <a href="https://www.rust-lang.org/tools">—Å—Ç—Ä–∞–Ω–∏—Ü–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hello-world"><a class="header" href="#hello-world">Hello, World!</a></h2>
<p>–ò—Ç–∞–∫, –ø–æ—Å–∫–æ–ª—å–∫—É –≤—ã —É—Å—Ç–∞–Ω–æ–≤–∏–ª–∏ Rust, –ø—Ä–∏—Å—Ç—É–ø–∏–º –∫ –Ω–∞–ø–∏—Å–∞–Ω–∏—é –≤–∞—à–µ–π –ø–µ—Ä–≤–æ–π –ø—Ä–æ–≥—Ä–∞–º–º—ã –Ω–∞ –Ω—ë–º. –ü–æ —Ç—Ä–∞–¥–∏—Ü–∏–∏, –ø—Ä–∏ –∏–∑—É—á–µ–Ω–∏–∏ –Ω–æ–≤–æ–≥–æ —è–∑—ã–∫–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è –ø–µ—Ä–≤–æ–π –ø—Ä–æ–≥—Ä–∞–º–º–æ–π –ø–∏—à–µ—Ç—Å—è –≤—ã–≤–æ–¥ —Ç–µ–∫—Å—Ç–∞ <code>Hello, world!</code> –Ω–∞ —ç–∫—Ä–∞–Ω. –≠—Ç–æ–π –ø—Ä–æ–≥—Ä–∞–º–º–æ–π –º—ã —Å–µ–π—á–∞—Å –∏ –∑–∞–π–º—ë–º—Å—è.</p>
<blockquote>
<p>–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: —ç—Ç–∞ –∫–Ω–∏–≥–∞ –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ—Ç –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –±–∞–∑–æ–≤—ã–µ –Ω–∞–≤—ã–∫–∏ —Ä–∞–±–æ—Ç—ã —Å –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–æ–π. Rust –ø—Ä–µ–¥—ä—è–≤–ª—è–µ—Ç –æ—Å–æ–±—ã—Ö —Ç—Ä–µ–±–æ–≤–∞–Ω–∏–π –∫ –≤–∞—à–µ–º—É –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞—Ä–∏—é –∏–ª–∏ —Ä–∞–∑–º–µ—â–µ–Ω–∏—é –∫–æ–¥–∞, —Ç–∞–∫ —á—Ç–æ –µ—Å–ª–∏ –≤—ã –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ–ª–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å IDE –≤–º–µ—Å—Ç–æ –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏ ‚Äî –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ª—é–±–∏–º—É—é. –ú–Ω–æ–≥–∏–µ IDE –≤ —Ç–æ–π –∏–ª–∏ –∏–Ω–æ–π –º–µ—Ä–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç Rust; –ø–æ–¥—Ä–æ–±–Ω–æ—Å—Ç–∏ –º–æ–∂–µ—Ç–µ —É–∑–Ω–∞—Ç—å –≤ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ –≤–∞—à–µ–π IDE. –ö–æ–º–∞–Ω–¥–∞ Rust –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Å–∏—Å—Ç–µ–º—É <code>rust-analyzer</code>, –æ–±–µ—Å–ø–µ—á–∏–≤–∞—é—â—É—é –ø—Ä–µ–≤–æ—Å—Ö–æ–¥–Ω—É—é –ø–æ–¥–¥–µ—Ä–∂–∫—É Rust –≤–æ –º–Ω–æ–≥–∏—Ö IDE. –ò—â–∏—Ç–µ –ø–æ–¥—Ä–æ–±–Ω–æ—Å—Ç–∏ –≤ <a href="appendix-04-useful-development-tools.html">–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ D</a> <!--ignore -->.</p>
</blockquote>
<h3 id="–°–æ–∑–¥–∞–Ω–∏–µ-–¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏-–ø—Ä–æ–µ–∫—Ç–∞"><a class="header" href="#–°–æ–∑–¥–∞–Ω–∏–µ-–¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏-–ø—Ä–æ–µ–∫—Ç–∞">–°–æ–∑–¥–∞–Ω–∏–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –ø—Ä–æ–µ–∫—Ç–∞</a></h3>
<p>–ü–µ—Ä–≤—ã–º –¥–µ–ª–æ–º, —Å–æ–∑–¥–∞–¥–∏–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –≤–∞—à–µ–≥–æ –∫–æ–¥–∞ –Ω–∞ Rust. –ù–µ–≤–∞–∂–Ω–æ, –≥–¥–µ –≤—ã —Ö–æ—Ç–∏—Ç–µ —Ä–∞—Å–ø–æ–ª–∞–≥–∞—Ç—å —Å–≤–æ–π –∫–æ–¥, –Ω–æ –º—ã –ø—Ä–µ–¥–ª–∞–≥–∞–µ–º –≤–∞–º –≤—ã–¥–µ–ª–∏—Ç—å –æ—Ç–¥–µ–ª—å–Ω—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–π –∏ –ø—Ä–æ–µ–∫—Ç–æ–≤ –∏–∑ —ç—Ç–æ–π –∫–Ω–∏–≥–∏.</p>
<p>–û—Ç–∫—Ä–æ–π—Ç–µ —Ç–µ—Ä–º–∏–Ω–∞–ª –∏ –≤–≤–µ–¥–∏—Ç–µ —Å–ª–µ–¥—É—é—â–∏–µ –∫–æ–º–∞–Ω–¥—ã, —á—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é "projects" –∏ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è –ø—Ä–æ–µ–∫—Ç–∞ "Hello, world!" –≤–Ω—É—Ç—Ä–∏ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ <em>projects</em>.</p>
<p>–î–ª—è Linux, macOS –∏ PowerShell –Ω–∞ Windows, –≤–≤–µ–¥–∏—Ç–µ —ç—Ç–æ:</p>
<pre><code class="language-console">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<p>–î–ª—è Windows CMD, –≤–≤–µ–¥–∏—Ç–µ —ç—Ç–æ:</p>
<pre><code class="language-cmd">&gt; mkdir "%USERPROFILE%\projects"
&gt; cd /d "%USERPROFILE%\projects"
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<h3 id="–ù–∞–ø–∏—Å–∞–Ω–∏–µ-–∏-–∑–∞–ø—É—Å–∫-–ø—Ä–æ–≥—Ä–∞–º–º—ã-–Ω–∞-rust"><a class="header" href="#–ù–∞–ø–∏—Å–∞–Ω–∏–µ-–∏-–∑–∞–ø—É—Å–∫-–ø—Ä–æ–≥—Ä–∞–º–º—ã-–Ω–∞-rust">–ù–∞–ø–∏—Å–∞–Ω–∏–µ –∏ –∑–∞–ø—É—Å–∫ –ø—Ä–æ–≥—Ä–∞–º–º—ã –Ω–∞ Rust</a></h3>
<p>–î–∞–ª–µ–µ. –°–æ–∑–¥–∞–¥–∏–º –∏—Å—Ö–æ–¥–Ω—ã–π —Ñ–∞–π–ª –∏ –Ω–∞–∑–æ–≤—ë–º –µ–≥–æ <em>main.rs</em>. –§–∞–π–ª—ã Rust –≤—Å–µ–≥–¥–∞ –æ–∫–∞–Ω—á–∏–≤–∞—é—Ç—Å—è —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ–º <em>.rs</em>. –ï—Å–ª–∏ –≤—ã –∏—Å–ø–æ–ª—å–∑—É–µ—Ç–µ –±–æ–ª—å—à–µ –æ–¥–Ω–æ–≥–æ —Å–ª–æ–≤–∞ –≤ –Ω–∞–∑–≤–∞–Ω–∏–∏ —Ñ–∞–π–ª–∞, —Å–ª–µ–¥—É–µ—Ç –æ—Ç–±–∏–≤–∞—Ç—å —Å–ª–æ–≤–∞ –¥—Ä—É–≥ –æ—Ç –¥—Ä—É–≥–∞ –Ω–∏–∂–Ω–∏–º –ø–æ–¥—á—ë—Ä–∫–∏–≤–∞–Ω–∏–µ–º. –ù–∞–ø—Ä–∏–º–µ—Ä, –≤–º–µ—Å—Ç–æ <em>helloworld.rs</em> –ª—É—á—à–µ –Ω–∞–ø–∏—à–∏—Ç–µ <em>hello_world.rs</em>.</p>
<p>–¢–µ–ø–µ—Ä—å –æ—Ç–∫—Ä–æ–π—Ç–µ —Ç–æ–ª—å–∫–æ —á—Ç–æ —Å–æ–∑–¥–∞–Ω–Ω—ã–π —Ñ–∞–π–ª <em>main.rs</em> –∏ –∑–∞–ø–æ–ª–Ω–∏—Ç–µ –µ–≥–æ –∫–æ–¥–æ–º –∏–∑ –õ–∏—Å—Ç–∏–Ω–≥–∞ 1-1.</p>
<Listing number="1-1" file-name="main.rs" caption="A program that prints `Hello, world!`">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    println!("Hello, world!");
}</code></pre></pre>
</Listing>
<p>–°–æ—Ö—Ä–∞–Ω–∏—Ç–µ —Ñ–∞–π–ª –∏ –≤–µ—Ä–Ω–∏—Ç–µ—Å—å –∫ –∫–æ–Ω—Å–æ–ª–∏. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –≤—ã –Ω–∞—Ö–æ–¥–∏—Ç–µ—Å—å –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ <em>~/projects/hello_world</em>. –ù–∞ Linux –∏ macOS, –≤–≤–µ–¥–∏—Ç–µ —Å–ª–µ–¥—É—é—â–∏–µ –∫–æ–º–∞–Ω–¥—ã, —á—Ç–æ–±—ã —Å–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞—Ç—å –∏ –∑–∞–ø—É—Å—Ç–∏—Ç—å —Ñ–∞–π–ª:</p>
<pre><code class="language-console">$ rustc main.rs
$ ./main
Hello, world!
</code></pre>
<p>–ù–∞ Windows, –≤–≤–µ–¥–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É <code>.\main.exe</code> –≤–º–µ—Å—Ç–æ <code>./main</code>:</p>
<pre><code class="language-powershell">&gt; rustc main.rs
&gt; .\main.exe
Hello, world!
</code></pre>
<p>–ù–µ–∑–∞–≤–∏—Å–∏–º–æ –æ—Ç –≤–∞—à–µ–π –æ–ø–µ—Ä–∞—Ü–∏–æ–Ω–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã, –≤ –∫–æ–Ω—Å–æ–ª–∏ –¥–æ–ª–∂–Ω–∞ –Ω–∞–ø–µ—á–∞—Ç–∞—Ç—å—Å—è —Å—Ç—Ä–æ–∫–∞ <code>Hello, world!</code>. –ï—Å–ª–∏ —ç—Ç–æ–≥–æ –Ω–µ –ø—Ä–æ–∏–∑–æ—à–ª–æ, –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –ø—É–Ω–∫—Ç—É <a href="ch01-01-installation.html#%D0%A0%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC">"–†–µ—à–µ–Ω–∏–µ –ø—Ä–æ–±–ª–µ–º"</a><!-- ignore --> —Ä–∞–∑–¥–µ–ª–∞ "–£—Å—Ç–∞–Ω–æ–≤–∫–∞", —á—Ç–æ–±—ã –Ω–∞–π—Ç–∏ –≤–æ–∑–º–æ–∂–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ.</p>
<p>–ï—Å–ª–∏ –∂–µ –≤—ã –≤–∏–¥–∏—Ç–µ <code>Hello, world!</code>, –ø—Ä–∏–º–∏—Ç–µ –ø–æ–∑–¥—Ä–∞–≤–ª–µ–Ω–∏—è! –í—ã –Ω–∞–ø–∏—Å–∞–ª–∏ —Å–≤–æ—é –ø–µ—Ä–≤—É—é –ø—Ä–æ–≥—Ä–∞–º–º—É –Ω–∞ Rust, –∏ —Å—Ç–∞–ª–∏ Rust-–ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç–æ–º. –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!</p>
<h3 id="–£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ-–ø—Ä–æ–≥—Ä–∞–º–º—ã-–Ω–∞-rust"><a class="header" href="#–£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ-–ø—Ä–æ–≥—Ä–∞–º–º—ã-–Ω–∞-rust">–£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –ø—Ä–æ–≥—Ä–∞–º–º—ã –Ω–∞ Rust</a></h3>
<p>–î–∞–≤–∞–π—Ç–µ –¥–µ—Ç–∞–ª—å–Ω–æ —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º –Ω–∞—à—É –ø—Ä–æ–≥—Ä–∞–º–º—É. –í–æ—Ç –ø–µ—Ä–≤–∞—è –¥–µ—Ç–∞–ª—å–∫–∞ –ø–∞–∑–ª–∞:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {

}</code></pre></pre>
<p>–≠—Ç–∏ —Å—Ç—Ä–æ—á–∫–∏ –æ–ø—Ä–µ–¥–µ–ª—è—é—Ç —Ñ—É–Ω–∫—Ü–∏—é –ø–æ–¥ –Ω–∞–∑–≤–∞–Ω–∏–µ–º <code>main</code>. –§—É–Ω–∫—Ü–∏—è <code>main</code> –æ—Å–æ–±–µ–Ω–Ω–∞: —Å –Ω–µ—ë –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã. –ú—ã –≤–∏–¥–∏–º, —á—Ç–æ –ø–µ—Ä–≤–∞—è —Å—Ç—Ä–æ–∫–∞ –æ–±—ä—è–≤–ª—è–µ—Ç —Ñ—É–Ω–∫—Ü–∏—é <code>main</code>, –Ω–µ –∏–º–µ—é—â—É—é –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –∏ –Ω–∏—á–µ–≥–æ –Ω–µ –≤–æ–∑–≤—Ä–∞—â–∞—é—â—É—é. –ï—Å–ª–∏ –±—ã –æ–Ω–∞ –∏–º–µ–ª–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã, —Ç–æ –æ–Ω–∏ –±—ã–ª–∏ –±—ã –∑–∞–∫–ª—é—á–µ–Ω—ã –≤ —Å–∫–æ–±–∫–∏ <code>()</code>.</p>
<p>–¢–µ–ª–æ —Ñ—É–Ω–∫—Ü–∏–∏ –∑–∞–∫–ª—é—á–µ–Ω–æ –≤ <code>{}</code>. Rust —Ç—Ä–µ–±—É–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ñ–∏–≥—É—Ä–Ω—ã–µ —Å–∫–æ–±–∫–∏ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ç–µ–ª–∞ —Ñ—É–Ω–∫—Ü–∏–π. –ü—Ä–∏–Ω—è—Ç—ã–º —Å—Ç–∏–ª–µ–º —è–≤–ª—è–µ—Ç—Å—è –ø–æ—Å—Ç–∞–≤–∏—Ç—å –æ—Ç–∫—Ä—ã–≤–∞—é—â—É—é —Ñ–∏–≥—É—Ä–Ω—É—é —Å–∫–æ–±–∫—É –Ω–∞ —Ç–æ–π –∂–µ —Å—Ç—Ä–æ–∫–µ, –≥–¥–µ –æ–±—ä—è–≤–ª—è–µ—Ç—Å—è —Ñ—É–Ω–∫—Ü–∏—è, –æ—Ç–¥–µ–ª–∏–≤ –æ–±—ä—è–≤–ª–µ–Ω–∏–µ –æ—Ç —Å–∫–æ–±–∫–∏ –ø—Ä–æ–±–µ–ª–æ–º.</p>
<blockquote>
<p>–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: –ï—Å–ª–∏ –≤—ã —Ö–æ—Ç–∏—Ç–µ –≤—Å—é–¥—É —Å–æ–±–ª—é–¥–∞—Ç—å —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –µ–¥–∏–Ω–æ–æ–±—Ä–∞–∑–Ω—ã–π —Å—Ç–∏–ª—å, –≤—ã –º–æ–∂–µ—Ç–µ –≤–æ—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–º —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è <code>rustfmt</code>. (–±–æ–ª—å—à–µ –æ <code>rustfmt</code> –º–æ–∂–Ω–æ —É–∑–Ω–∞—Ç—å –≤ <a href="appendix-04-useful-development-tools.html">–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ D</a> <!-- ignore -->). –≠—Ç–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –ø–æ—Å—Ç–∞–≤–ª—è–µ—Ç—Å—è –≤–º–µ—Å—Ç–µ —Å <code>rustc</code>, —Ç–∞–∫ —á—Ç–æ –æ–Ω –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —É–∂–µ –Ω–∞ –≤–∞—à–µ–º –∫–æ–º–ø—å—é—Ç–µ—Ä–µ!</p>
</blockquote>
<p>–¢–µ–ª–æ —Ñ—É–Ω–∫—Ü–∏–∏ <code>main</code> —Å–æ–¥–µ—Ä–∂–∏—Ç —Å–ª–µ–¥—É—é—â–∏–π –∫–æ–¥:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!("Hello, world!");
<span class="boring">}</span></code></pre></pre>
<p>–≠—Ç–∞ —Å—Ç—Ä–æ—á–∫–∞ –¥–µ–ª–∞–µ—Ç –≤—Å—é —Ä–∞–±–æ—Ç—É –≤ –Ω–∞—à–µ–π –º–∞–ª–µ–Ω—å–∫–æ–π –ø—Ä–æ–≥—Ä–∞–º–º–µ: –æ–Ω–∞ –ø–µ—á–∞—Ç–∞–µ—Ç —Ç–µ–∫—Å—Ç –Ω–∞ —ç–∫—Ä–∞–Ω. –ú—ã –º–æ–∂–µ–º –≤—ã–¥–µ–ª–∏—Ç—å –∑–¥–µ—Å—å —Ç—Ä–∏ –≤–∞–∂–Ω—ã—Ö –¥–µ—Ç–∞–ª–∏:</p>
<p>–í–æ-–ø–µ—Ä–≤—ã—Ö, <code>println!</code> –≤—ã–∑—ã–≤–∞–µ—Ç –º–∞–∫—Ä–æ—Å. –ï—Å–ª–∏ –±—ã –≤–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ –º—ã –≤—ã–∑—ã–≤–∞–ª–∏ —Ñ—É–Ω–∫—Ü–∏—é, –æ–Ω–∞ –±—ã –Ω–∞–∑—ã–≤–∞–ª–∞—Å—å <code>println</code> (–±–µ–∑ –∑–Ω–∞–∫–∞ <code>!</code>). –ú—ã –æ–±—Å—É–¥–∏–º –º–∞–∫—Ä–æ—Å—ã –¥–µ—Ç–∞–ª—å–Ω–µ–µ –≤ –ì–ª–∞–≤–µ 20. –ü–æ–∫–∞ —á—Ç–æ –≤–∞–º –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∑–Ω–∞—Ç—å, —á—Ç–æ –∑–Ω–∞–∫ <code>!</code> –æ–∑–Ω–∞—á–∞–µ—Ç –≤—ã–∑–æ–≤ –º–∞–∫—Ä–æ—Å–∞, –∞ –Ω–µ –æ–±—ã—á–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏, –∏ —á—Ç–æ –º–∞–∫—Ä–æ—Å –Ω–µ –≤—Å–µ–≥–¥–∞ –≤–µ–¥—ë—Ç —Å–µ–±—è –∫–∞–∫ —Ñ—É–Ω–∫—Ü–∏—è.</p>
<p>–í–æ-–≤—Ç–æ—Ä—ã—Ö, –≤—ã –≤–∏–¥–∏—Ç–µ —Å—Ç—Ä–æ–∫—É <code>"Hello, world!"</code>. –ú—ã –ø–µ—Ä–µ–¥–∞—ë–º —ç—Ç—É —Å—Ç—Ä–æ–∫—É –∫–∞–∫ –∞—Ä–≥—É–º–µ–Ω—Ç –º–∞–∫—Ä–æ—Å—É <code>println!</code>, –∏ –æ–Ω–∞ –∂–µ –≤—ã–≤–æ–¥–∏—Ç—Å—è –Ω–∞ —ç–∫—Ä–∞–Ω.</p>
<p>Third, we end the line with a semicolon (<code>;</code>), which indicates that this expression is over and the next one is ready to begin. Most lines of Rust code end with a semicolon.</p>
<h3 id="–ö–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞–Ω–∏–µ-–∏-–∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ--—ç—Ç–æ-—Ä–∞–∑–Ω—ã–µ-—à–∞–≥–∏"><a class="header" href="#–ö–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞–Ω–∏–µ-–∏-–∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ--—ç—Ç–æ-—Ä–∞–∑–Ω—ã–µ-—à–∞–≥–∏">–ö–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ ‚Äî —ç—Ç–æ —Ä–∞–∑–Ω—ã–µ —à–∞–≥–∏</a></h3>
<p>–î–∞–≤–∞–π—Ç–µ —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º –∫–∞–∂–¥—ã–π —à–∞–≥ –ø—Ä–æ—Ü–µ—Å—Å–∞ –∑–∞–ø—É—Å–∫–∞ –ø—Ä–æ–≥—Ä–∞–º–º—ã.</p>
<p>–ü–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º –ø—Ä–æ–≥—Ä–∞–º–º—ã –Ω–∞ Rust, –≤—ã –¥–æ–ª–∂–Ω—ã –µ—ë —Å–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞—Ç—å, –∏—Å–ø–æ–ª—å–∑—É—è –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä Rust. –í–≤–µ–¥–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É <code>rustc</code> –≤ —Ç–µ—Ä–º–∏–Ω–∞–ª –∏ –ø–µ—Ä–µ–¥–∞–π—Ç–µ –≤ –∫–∞—á–µ—Å—Ç–≤–µ –µ–π –∞—Ä–≥—É–º–µ–Ω—Ç–∞ –∏–º—è —Ñ–∞–π–ª–∞ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ –∫–æ–¥–∞:</p>
<pre><code class="language-console">$ rustc main.rs
</code></pre>
<p>If you have a C or C++ background, you‚Äôll notice that this is similar to <code>gcc</code> or <code>clang</code>. After compiling successfully, Rust outputs a binary executable.</p>
<p>–í Linux, macOS –∏ PowerShell –Ω–∞ Windows, –≤—ã –º–æ–∂–µ—Ç–µ —É–≤–∏–¥–µ—Ç—å –∏—Å–ø–æ–ª–Ω—è–µ–º—ã–π —Ñ–∞–π–ª, –≤–≤–µ–¥—è –∫–æ–º–∞–Ω–¥—É <code>ls</code> –≤ –∫–æ–Ω—Å–æ–ª—å:</p>
<pre><code class="language-console">$ ls
main  main.rs
</code></pre>
<p>–ù–∞ Linux –∏ macOS –≤—ã —É–≤–∏–¥–∏—Ç–µ –¥–≤–∞ —Ñ–∞–π–ª–∞. –ù–∞ Windows –≤—ã —É–≤–∏–¥–∏—Ç–µ —Ç—Ä–∏. –ï—Å–ª–∏ –≤—ã –∏—Å–ø–æ–ª—å–∑—É–µ—Ç–µ CMD –Ω–∞ Windows, –≤–≤–µ–¥–∏—Ç–µ —ç—Ç–æ:</p>
<pre><code class="language-cmd">&gt; dir /B %= the /B option says to only show the file names =%
main.exe
main.pdb
main.rs
</code></pre>
<p>–í—ã —É–≤–∏–¥–∏—Ç–µ —Ñ–∞–π–ª –∏—Å—Ö–æ–¥–Ω–æ–≥–æ –∫–æ–¥–∞ —Å —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ–º <em>.rs</em>, –∏—Å–ø–æ–ª–Ω—è–µ–º—ã–π —Ñ–∞–π–ª (<em>main.exe</em> –Ω–∞ Windows –∏ <em>main</em> –Ω–∞ –¥—Ä—É–≥–∏—Ö –æ–ø–µ—Ä–∞—Ü–∏–æ–Ω–Ω—ã—Ö —Å–∏—Å—Ç–µ–º–∞—Ö), –∏, –µ—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç–µ Windows, —Ñ–∞–π–ª –æ—Ç–ª–∞–¥–æ—á–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ —Å —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ–º <em>.pdb</em>. –ó–∞—É–ø—Å—Ç–∏—Ç–µ —Ñ–∞–π–ª <em>main</em> –∏–ª–∏ <em>main.exe</em>; –≤–æ—Ç —Ç–∞–∫:</p>
<pre><code class="language-console">$ ./main # or .\main.exe on Windows
</code></pre>
<p>–ï—Å–ª–∏ –≤–∞—à <em>main.rs</em> —Å–æ–¥–µ—Ä–∂–∏—Ç –ø—Ä–æ–≥—Ä–∞–º–º—É "Hello, world!", —Ç–æ –∏—Å–ø–æ–ª–Ω—è–µ–º—ã–π —Ñ–∞–π–ª –≤—ã–≤–µ–¥–µ—Ç <code>Hello, world!</code> –≤ –∫–æ–Ω—Å–æ–ª—å.</p>
<p>–ï—Å–ª–∏ –≤—ã –±–æ–ª–µ–µ –∑–Ω–∞–∫–æ–º—ã —Å –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–º–∏ —è–∑—ã–∫–∞–º–∏ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è, —Ç–∞–∫–∏–º–∏ –∫–∞–∫ Ruby, Python –∏–ª–∏ JavaScript, –≤–∞–º –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–µ–ø—Ä–∏–≤—ã—á–Ω–æ –≤—ã–ø–æ–ª–Ω—è—Ç—å —Å–±–æ—Ä–∫—É –∏ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã –∫–∞–∫ –æ—Ç–¥–µ–ª—å–Ω—ã–µ —à–∞–≥–∏. Rust ‚Äî —è–∑—ã–∫ —Å <em>–ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–π –∫–æ–º–ø–∏–ª—è—Ü–∏–µ–π</em>, —á—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –≤—ã –º–æ–∂–µ—Ç–µ —Å–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–æ–≥—Ä–∞–º–º—É –∏ –æ—Ç–¥–∞—Ç—å –∏—Å–ø–æ–ª–Ω—è–µ–º—ã–π —Ñ–∞–π–ª –¥—Ä—É–≥–æ–º—É —á–µ–ª–æ–≤–µ–∫—É, –∏ –æ–Ω —Å–º–æ–∂–µ—Ç –µ–≥–æ –∑–∞–ø—É—Å—Ç–∏—Ç—å –±–µ–∑ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—Ç—å Rust. –ï—Å–ª–∏ –∂–µ –≤—ã –¥–∞–¥–∏—Ç–µ –∫–æ–º—É-—Ç–æ —Ñ–∞–π–ª <em>.rb</em>, <em>.py</em> –∏–ª–∏ <em>.js</em>, –¥—Ä—É–≥–æ–º—É —á–µ–ª–æ–≤–µ–∫—É –ø–æ—Ç—Ä–µ–±—É–µ—Ç—Å—è —Å–Ω–∞—á–∞–ª–∞ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å (—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ) Ruby, Python –∏–ª–∏ JavaScript. –û–¥–Ω–∞–∫–æ, –≤ —ç—Ç–∏—Ö —è–∑—ã–∫–∞—Ö –≤–∞–º –Ω—É–∂–Ω–∞ –ª–∏—à—å –æ–¥–Ω–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–ª—è —Å–±–æ—Ä–∫–∏ –∏ –∑–∞–ø—É—Å–∫–∞ –≤–∞—à–∏—Ö –ø—Ä–æ–≥—Ä–∞–º–º. –í—Å—ë –≤ –¥–∏–∑–∞–π–Ω–µ —è–∑—ã–∫–æ–≤ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è ‚Äî –∫–æ–º–ø—Ä–æ–º–∏—Å—Å.</p>
<p>–ü—Ä—è–º–∞—è –∫–æ–º–ø–∏–ª—è—Ü–∏—è —á–µ—Ä–µ–∑ <code>rustc</code> –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–∞ –¥–ª—è –Ω–µ–±–æ–ª—å—à–∏—Ö –ø—Ä–æ–≥—Ä–∞–º–º, –Ω–æ –ø–æ –º–µ—Ä–µ –∏—Ö —Ä–æ—Å—Ç–∞ –≤–∞–º –ø–æ—Ç—Ä–µ–±—É–µ—Ç—Å—è —É–ø—Ä–∞–≤–ª—è—Ç—å —Ä–∞–∑–ª–∏—á–Ω—ã–º–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏ –∏ –¥–µ–ª–∞—Ç—å –≤–∞—à –∫–æ–¥ –ª—ë–≥–∫–∏–º –¥–ª—è —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–∏—è. –í —Å–ª–µ–¥—É—é—â–µ–º —Ä–∞–∑–¥–µ–ª–µ –º—ã –ø–æ–∫–∞–∂–µ–º –≤–∞–º Cargo ‚Äî –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç, –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–π –¥–ª—è –Ω–∞–ø–∏—Å–∞–Ω–∏—è –ø—Ä–∏–∫–ª–∞–¥–Ω—ã—Ö –ø—Ä–æ–≥—Ä–∞–º–º –Ω–∞ Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hello-cargo"><a class="header" href="#hello-cargo">Hello, Cargo!</a></h2>
<p>Cargo ‚Äî —ç—Ç–æ —Å–∏—Å—Ç–µ–º–∞ —Å–±–æ—Ä–∫–∏ –∏ –º–µ–Ω–µ–¥–∂–µ—Ä –ø–∞–∫–µ—Ç–æ–≤ —è–∑—ã–∫–∞ Rust. –ú–Ω–æ–≥–∏–µ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç—ã –Ω–∞ Rust –∏—Å–ø–æ–ª—å–∑—É—é—Ç –µ–≥–æ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–≤–æ–∏–º–∏ –ø—Ä–æ–µ–∫—Ç–∞–º–∏, –ø–æ—Å–∫–æ–ª—å–∫—É Cargo –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –Ω–∞ —Å–µ–±—è –±–æ–ª—å—à–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–±–æ—Ç, —Ç–∞–∫–∏—Ö –∫–∞–∫ —Å–±–æ—Ä–∫–∞ –≤–∞—à–µ–≥–æ –∫–æ–¥–∞, –∑–∞–≥—Ä—É–∑–∫–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö –≤–∞—à–µ–º—É –∫–æ–¥—É –±–∏–±–ª–∏–æ—Ç–µ–∫ –∏ –∏—Ö –∂–µ —Å–±–æ—Ä–∫–∞. (–ú—ã –±—É–¥–µ–º –Ω–∞–∑—ã–≤–∞—Ç—å –±–∏–±–ª–∏–æ—Ç–µ–∫–∏, –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –≤–∞—à–µ–º—É –∫–æ–¥—É, <em>–∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—è–º–∏</em>.)</p>
<p>–ü—Ä–æ—Å—Ç–µ–π—à–∏–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã –Ω–∞ Rust (–≤—Ä–æ–¥–µ —Ç–æ–π, —á—Ç–æ –º—ã –Ω–∞–ø–∏—Å–∞–ª–∏), –Ω–µ –∏–º–µ—é—Ç –Ω–∏–∫–∞–∫–∏—Ö –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π. –ï—Å–ª–∏ –±—ã –º—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ Cargo –¥–ª—è —Å–±–æ—Ä–∫–∏ –Ω–∞—à–µ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞ "Hello, world!", –æ–Ω –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª –±—ã –ª–∏—à—å —Ç–æ—Ç —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª Cargo, –∫–æ—Ç–æ—Ä—ã–π –æ—Ç–≤–µ—á–∞–µ—Ç –∑–∞ —Å–±–æ—Ä–∫—É –∫–æ–¥–∞. –ü–æ –º–µ—Ä–µ —Ç–æ–≥–æ, –∫–∞–∫ –≤—ã –±—É–¥–µ—Ç–µ –ø–∏—Å–∞—Ç—å –≤—Å—ë –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω—ã–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã –Ω–∞ Rust, –≤—ã –Ω–∞—á–Ω—ë—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏; —Ç–∞–∫ —á—Ç–æ –µ—Å–ª–∏ –≤—ã –±—É–¥–µ—Ç–µ –≤–æ –≤—Å–µ—Ö —Å–≤–æ–∏—Ö –ø—Ä–æ–µ–∫—Ç–∞—Ö –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Cargo —Å —Å–∞–º–æ–≥–æ –Ω–∞—á–∞–ª–∞, –≤–∞–º –±—É–¥–µ—Ç –ª–µ–≥—á–µ –¥–æ–±–∞–≤–ª—è—Ç—å –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏.</p>
<p>–ü–æ—Å–∫–æ–ª—å–∫—É –ø–æ–¥–∞–≤–ª—è—é—â–µ–µ –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–æ –ø—Ä–æ–µ–∫—Ç–æ–≤ –Ω–∞ Rust –∏—Å–ø–æ–ª—å–∑—É–µ—Ç Cargo, –æ—Å—Ç–∞–≤—à–∞—è—Å—è —á–∞—Å—Ç—å —ç—Ç–æ–π –∫–Ω–∏–≥–∏ –±—É–¥–µ—Ç –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞—Ç—å –µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∏ –≤–∞–º–∏. Cargo –ø–æ—Å—Ç–∞–≤–ª—è–µ—Ç—Å—è –≤–º–µ—Å—Ç–µ —Å Rust, –µ—Å–ª–∏ –≤—ã –∏—Å–ø–æ–ª—å–∑—É–µ—Ç–µ –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ —É—Å—Ç–∞–Ω–æ–≤–∫–∏, –æ–ø–∏—Å–∞–Ω–Ω—ã–π –≤ —Ä–∞–∑–¥–µ–ª–µ <a href="ch01-01-installation.html#%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0">"–£—Å—Ç–∞–Ω–æ–≤–∫–∞"</a><!-- ignore -->. –ï—Å–ª–∏ –≤—ã —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–ª–∏ Rust –∏–Ω—ã–º–∏ —Å—Ä–µ–¥—Å—Ç–≤–∞–º–∏, –≤—ã –º–æ–∂–µ—Ç–µ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å, —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –ª–∏ —É –≤–∞—Å Cargo, –≤–≤–µ–¥—è —ç—Ç—É –∫–æ–º–∞–Ω–¥—É:</p>
<pre><code class="language-console">$ cargo --version
</code></pre>
<p>–ï—Å–ª–∏ –≤—ã –≤–∏–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –≤–µ—Ä—Å–∏–∏, —Ç–æ Cargo —É –≤–∞—Å –µ—Å—Ç—å! –ï—Å–ª–∏ –∂–µ –≤–∏–¥–∏—Ç–µ –æ—à–∏–±–∫—É, –≤—Ä–æ–¥–µ <code>command not found</code>, –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ –≤–∞—à–µ–≥–æ –º–µ—Ç–æ–¥–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏, —á—Ç–æ–±—ã —É–∑–Ω–∞—Ç—å, –∫–∞–∫ –æ—Ç–¥–µ–ª—å–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å Cargo.</p>
<h3 id="–°–æ–∑–¥–∞–Ω–∏–µ-–ø—Ä–æ–µ–∫—Ç–∞-—á–µ—Ä–µ–∑-cargo"><a class="header" href="#–°–æ–∑–¥–∞–Ω–∏–µ-–ø—Ä–æ–µ–∫—Ç–∞-—á–µ—Ä–µ–∑-cargo">–°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–æ–µ–∫—Ç–∞ —á–µ—Ä–µ–∑ Cargo</a></h3>
<p>–°–æ–∑–¥–∞–¥–∏–º –Ω–æ–≤—ã–π –ø—Ä–æ–µ–∫—Ç —á–µ—Ä–µ–∑ Cargo –∏ –ø–æ—Å–º–æ—Ç—Ä–∏–º, —á–µ–º –æ–Ω –±—É–¥–µ—Ç –æ—Ç–ª–∏—á–∞—Ç—å—Å—è –æ—Ç –ø—Ä–æ–µ–∫—Ç–∞ "Hello, world!", –Ω–∞–ø–∏—Å–∞–Ω–Ω–æ–≥–æ –Ω–∞–º–∏ —Ä–∞–Ω–µ–µ. –ü–µ—Ä–µ–π–¥–∏—Ç–µ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é <em>projects</em> (–∏–ª–∏ —Ç—É–¥–∞, –∫—É–¥–∞ –≤—ã —Ä–µ—à–∏–ª–∏ —Å–æ—Ö—Ä–∞–Ω—è—Ç—å —Å–≤–æ–π –∫–æ–¥) –∏ –≤—ã–ø–æ–ª–Ω–∏—Ç–µ (–Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –æ—Ç –≤–∞—à–µ–π –æ–ø–µ—Ä–∞—Ü–∏–æ–Ω–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã) —ç—Ç–∏ –∫–æ–º–∞–Ω–¥—ã:</p>
<pre><code class="language-console">$ cargo new hello_cargo
$ cd hello_cargo
</code></pre>
<p>–ü–µ—Ä–≤–∞—è –∫–æ–º–∞–Ω–¥–∞ —Å–æ–∑–¥–∞—ë—Ç –Ω–æ–≤—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –∏ –ø—Ä–æ–µ–∫—Ç –ø–æ–¥ –Ω–∞–∑–≤–∞–Ω–∏–µ–º <em>hello_cargo</em>. –ú—ã –Ω–∞–∑–≤–∞–ª–∏ –ø—Ä–æ–µ–∫—Ç <em>hello_cargo</em>, —Ç–∞–∫ —á—Ç–æ Cargo —Å–æ–∑–¥–∞–ª –µ–≥–æ —Ñ–∞–π–ª—ã –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ —Å —Ç–∞–∫–∏–º –∂–µ –Ω–∞–∑–≤–∞–Ω–∏–µ–º.</p>
<p>–ü–µ—Ä–µ–π–¥–∏—Ç–µ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é <em>hello_cargo</em> –∏ –ø–æ—Å–º–æ—Ç—Ä–∏—Ç–µ —Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤. –í—ã —É–≤–∏–¥–∏—Ç–µ, —á—Ç–æ Cargo —Ç–∞–∫–∂–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–ª –¥–≤–∞ —Ñ–∞–π–ª–∞ –∏ –æ–¥–Ω—É –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é: —Ñ–∞–π–ª <em>Cargo.toml</em> –∏ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é <em>src</em> —Å —Ñ–∞–π–ª–æ–º <em>main.rs</em> –≤–Ω—É—Ç—Ä–∏.</p>
<p>Cargo —Ç–∞–∫–∂–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–ª –Ω–æ–≤—ã–π Git-—Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π –∏ —Å–æ–∑–¥–∞–ª —Ñ–∞–π–ª <em>.gitignore</em>. –§–∞–π–ª—ã Git –Ω–µ –±—É–¥—É—Ç –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è, –µ—Å–ª–∏ –≤—ã –≤—ã–ø–æ–ª–Ω–∏—Ç–µ <code>cargo new</code> –≤ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–º —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏. –í–ø—Ä–æ—á–µ–º, –≤—ã –º–æ–∂–µ—Ç–µ –ø–µ—Ä–µ–ø–∏—Å–∞—Ç—å —ç—Ç–æ –ø–æ–≤–µ–¥–µ–Ω–∏–µ, –∏—Å–ø–æ–ª—å–∑—É—è <code>cargo new --vcs=git</code>.</p>
<blockquote>
<p>–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é, –≤ –∫–∞—á–µ—Å—Ç–≤–µ —Å–∏—Å—Ç–µ–º—ã –≤–µ—Ä—Å–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è Git. –í—ã –∏–∑–º–µ–Ω–∏—Ç—å <code>cargo new</code> –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –¥—Ä—É–≥—É—é —Å–∏—Å—Ç–µ–º—É –≤–µ—Ä—Å–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è (version control system) –∏–ª–∏ –≤–æ–≤—Å–µ –æ—Ç–∫–∞–∑–∞—Ç—å—Å—è –æ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Å–∏—Å—Ç–µ–º—ã –≤–µ—Ä—Å–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è, –∏—Å–ø–æ–ª—å–∑—É—è —Ñ–ª–∞–≥ <code>--vcs</code>. –í—ã–ø–æ–ª–Ω–∏—Ç–µ <code>cargo new --help</code>, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å –¥–æ—Å—Ç—É–ø–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã.</p>
</blockquote>
<p>–û—Ç–∫—Ä–æ–π—Ç–µ —Ñ–∞–π–ª <em>Cargo.toml</em> –≤ –≤–∞—à–µ–º —Ç–µ–∫—Å—Ç–æ–≤–æ–º —Ä–µ–¥–∞–∫—Ç–æ—Ä–µ. –û–Ω –¥–æ–ª–∂–µ–Ω –≤—ã–≥–ª—è–¥–µ—Ç—å –∫–∞–∫ –∫–æ–¥ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 1-2.</p>
<Listing number="1-2" file-name="Cargo.toml" caption="Contents of *Cargo.toml* generated by `cargo new`">
<pre><code class="language-toml">[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

[dependencies]
</code></pre>
</Listing>
<p>–≠—Ç–æ—Ç —Ñ–∞–π–ª –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —Ñ–æ—Ä–º–∞—Ç <a href="https://toml.io"><em>TOML</em></a><!-- ignore --> (<em>Tom‚Äôs Obvious, Minimal Language</em>), –ø—Ä–∏–Ω—è—Ç—ã–π –≤ Cargo –¥–ª—è —Ñ–∞–π–ª–æ–≤ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏.</p>
<p>–ü–µ—Ä–≤–∞—è —Å—Ç—Ä–æ—á–∫–∞, <code>[package]</code> ‚Äî —ç—Ç–æ –∑–∞–≥–æ–ª–æ–≤–æ–∫ —Ä–∞–∑–¥–µ–ª–∞, –æ–±–æ–∑–Ω–∞—á–∞—é—â–∏–π, —á—Ç–æ –≤—Å–µ —Å–ª–µ–¥—É—é—â–∏–µ —Å—Ç—Ä–æ—á–∫–∏ –∑–∞–¥–∞—é—Ç –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –ø–∞–∫–µ—Ç–∞. –ü–æ–∑–∂–µ –º—ã –¥–æ–±–∞–≤–∏–º –±–æ–ª—å—à–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –≤ —ç—Ç–æ—Ç —Ä–∞–∑–¥–µ–ª, –∞ —Ç–∞–∫–∂–µ –¥–æ–±–∞–≤–∏–º –Ω–æ–≤—ã–µ —Ä–∞–∑–¥–µ–ª—ã.</p>
<p>–°–ª–µ–¥—É—é—â–∏–µ —Ç—Ä–∏ —Å—Ç—Ä–æ—á–∫–∏ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—é—Ç –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é, –Ω–µ–æ–±—Ö–æ–¥–∏–º—É—é Cargo –¥–ª—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –≤–∞—à–µ–π –ø—Ä–æ–≥—Ä–∞–º–º—ã: –Ω–∞–∑–≤–∞–Ω–∏–µ, –≤–µ—Ä—Å–∏—é –∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º—É—é —Ä–µ–¥–∞–∫—Ü–∏—é Rust. –ú—ã –æ–±—Å—É–¥–∏–º –∫–ª—é—á –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ <code>edition</code> –≤ <a href="appendix-05-editions.html">–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ E</a><!-- ignore -->.</p>
<p>–ü–æ—Å–ª–µ–¥–Ω—è—è —Å—Ç—Ä–æ—á–∫–∞, <code>[dependencies]</code> ‚Äî —ç—Ç–æ –Ω–∞—á–∞–ª–æ —Ä–∞–∑–¥–µ–ª–∞, –≥–¥–µ –≤–∞–º –Ω—É–∂–Ω–æ —É–∫–∞–∑—ã–≤–∞—Ç—å –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –≤–∞–≥–µ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞. –ü–∞–∫–µ—Ç—ã –∫–æ–¥–∞ –Ω–∞ Rust –Ω–∞–∑—ã–≤–∞—é—Ç—Å—è <em>–∫—Ä–µ–π—Ç–∞–º–∏</em> (<em>crates</em>). –î–ª—è –Ω–∞—à–µ–≥–æ —Ç–µ–∫—É—â–µ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞ –Ω–∞–º –Ω–µ –Ω—É–∂–Ω—ã –Ω–∏–∫–∞–∫–∏–µ –¥—Ä—É–≥–∏–µ –∫—Ä–µ–π—Ç—ã, –Ω–æ –≤ –ì–ª–∞–≤–µ 2 –æ–Ω–∏ –Ω–∞–º –ø–æ–Ω–∞–¥–æ–±—è—Ç—Å—è, –∏ —Ç–æ–≥–¥–∞ –∂–µ –º—ã –≤–æ—Å–ø–æ–ª—å–∑—É–µ–º—Å—è —Ä–∞–∑–¥–µ–ª–æ–º –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π.</p>
<p>–¢–µ–ø–µ—Ä—å –æ—Ç–∫—Ä–æ–π—Ç–µ <em>src/main.rs</em> –∏ –≤–∑–≥–ª—è–Ω–∏—Ç–µ –Ω–∞ –∫–æ–¥:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    println!("Hello, world!");
}</code></pre></pre>
<p>Cargo —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–ª –ø—Ä–æ–≥—Ä–∞–º–º—É "Hello, world!" ‚Äî –ø—Ä—è–º–æ —Ç–∞–∫—É—é –∂–µ, –∫–∞–∫—É—é –º—ã –Ω–∞–ø–∏—Å–∞–ª–∏ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 1-1! –í–æ–æ–±—â–µ, –≤—Å—è —Ä–∞–∑–Ω–∏—Ü–∞ –º–µ–∂–¥—É –Ω–∞—à–∏–º –ø—Ä–æ–µ–∫—Ç–æ–º –∏ –ø—Ä–æ–µ–∫—Ç–æ–º, —Å–æ–∑–¥–∞–Ω–Ω—ã–º Cargo, —Å–æ—Å—Ç–æ–∏—Ç –ª–∏—à—å –≤ —Ç–æ–º, —á—Ç–æ Cargo –ø–æ–º–µ—Å—Ç–∏–ª –∫–æ–¥ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ <em>src</em> –∏ —Å–æ–∑–¥–∞–ª –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω—ã–π —Ñ–∞–π–ª <em>Cargo.toml</em> –≤ –∫–æ—Ä–Ω–µ–≤–æ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –ø—Ä–æ–µ–∫—Ç–∞.</p>
<p>Cargo –æ–∂–∏–¥–∞–µ—Ç, —á—Ç–æ –≤–∞—à–∏ –∏—Å—Ö–æ–¥–Ω—ã–µ —Ñ–∞–π–ª—ã –±—É–¥—É—Ç –Ω–∞—Ö–æ–¥–∏—Ç—å—Å—è –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ <em>src</em>. –ö–æ—Ä–Ω–µ–≤–∞—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –ø—Ä–æ–µ–∫—Ç–∞ –ø—Ä–µ–¥–Ω–∞–∑–Ω–∞—á–µ–Ω–∞ –ª–∏—à—å –¥–ª—è —Ñ–∞–π–ª–æ–≤ README, –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –ª–∏—Ü–µ–Ω–∑–∏—è—Ö, –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤ –∏ –≤—Å–µ–≥–æ –ø—Ä–æ—á–µ–≥–æ, —á—Ç–æ –Ω–µ –æ—Ç–Ω–æ—Å–∏—Ç—Å—è –∫ –Ω–µ–ø–æ—Å—Ä–µ–¥—Å—Ç–≤–µ–Ω–Ω–æ –∫–æ–¥—É. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ Cargo –ø–æ–º–æ–∂–µ—Ç –≤–∞–º –æ—Ä–≥–∞–Ω–∏–∑–æ–≤—ã–≤–∞—Ç—å —Å–≤–æ–∏ –ø—Ä–æ–µ–∫—Ç—ã. –° –Ω–∏–º –¥–ª—è –≤—Å–µ–≥–æ –Ω–∞–π–¥—ë—Ç—Å—è –º–µ—Å—Ç–æ, –∏ –≤—Å—ë —Ä–∞–∑–º–µ—Å—Ç–∏—Ç—Å—è –Ω–∞ —Å–≤–æ–∏—Ö –º–µ—Å—Ç–∞—Ö.</p>
<p>–ï—Å–ª–∏ –≤—ã —Å–æ–∑–¥–∞–ª–∏ —Å–≤–æ–π –ø—Ä–æ–µ–∫—Ç –±–µ–∑ Cargo (–Ω–∞–ø—Ä–∏–º–µ—Ä, –∫–∞–∫ –º—ã —Ä–∞–Ω–µ–µ —Å–¥–µ–ª–∞–ª–∏ —Å –ø—Ä–æ–µ–∫—Ç–æ–º "Hello, world!"), –≤—ã –º–æ–∂–µ—Ç–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å –µ–≥–æ –≤ –ø—Ä–æ–µ–∫—Ç, –∏—Å–ø–æ–ª—å–∑—É—é—â–∏–π Cargo. –ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç–µ –∫–æ–¥ –ø—Ä–æ–µ–∫—Ç–∞ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é <em>src</em> –∏ —Å–æ–∑–¥–∞–π—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ñ–∞–π–ª <em>Cargo.toml</em>. –ü—Ä–æ—â–µ –≤—Å–µ–≥–æ –ø–æ–ª—É—á–∏—Ç—å —Ç–∞–∫–æ–π —Ñ–∞–π–ª –º–æ–∂–Ω–æ, –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–≤ –∫–æ–º–∞–Ω–¥—É <code>cargo init</code> ‚Äî –æ–Ω–∞ —Å–æ–∑–¥–∞—Å—Ç –µ–≥–æ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.</p>
<h3 id="–°–±–æ—Ä–∫–∞-–∏-–∑–∞–ø—É—Å–∫-–ø—Ä–æ–µ–∫—Ç–∞-—Å-–ø–æ–º–æ—â—å—é-cargo"><a class="header" href="#–°–±–æ—Ä–∫–∞-–∏-–∑–∞–ø—É—Å–∫-–ø—Ä–æ–µ–∫—Ç–∞-—Å-–ø–æ–º–æ—â—å—é-cargo">–°–±–æ—Ä–∫–∞ –∏ –∑–∞–ø—É—Å–∫ –ø—Ä–æ–µ–∫—Ç–∞ —Å –ø–æ–º–æ—â—å—é Cargo</a></h3>
<p>–ü–æ—Å–º–æ—Ç—Ä–∏–º, —á–µ–º –æ—Å–æ–±–µ–Ω–Ω—ã —Å–±–æ—Ä–∫–∞ –∏ –∑–∞–ø—É—Å–∫ –ø—Ä–æ–≥—Ä–∞–º–º—ã "Hello, world!" —Å –ø–æ–º–æ—â—å—é Cargo! –ü–µ—Ä–µ–π–¥–∏—Ç–µ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é <em>hello_cargo</em> –∏ —Å–æ–±–µ—Ä–∏—Ç–µ –ø—Ä–æ–µ–∫—Ç, –≤–≤–µ–¥—è —Å–ª–µ–¥—É—é—â—É—é –∫–æ–º–∞–Ω–¥—É:</p>
<pre><code class="language-console">$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
<p>–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ —Å–æ–∑–¥–∞—ë—Ç –∏—Å–ø–æ–ª–Ω—è–µ–º—ã–π —Ñ–∞–π–ª –ø–æ –ø—É—Ç–∏ <em>target/debug/hello_cargo</em> (–∏–ª–∏  <em>target\debug\hello_cargo.exe</em> –Ω–∞ Windows), –∞ –Ω–µ –∫–æ—Ä–Ω–µ–≤–æ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –ø—Ä–æ–µ–∫—Ç–∞. –ü–æ—Å–∫–æ–ª—å–∫—É –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Å–±–æ—Ä–∫–∞ –≤ —Ä–µ–∂–∏–º–µ –æ—Ç–ª–∞–¥–∫–∏ (debug), Cargo –ø–æ–ª–æ–∂–∏–ª –±–∏–Ω–∞—Ä–Ω—ã–π —Ñ–∞–π–ª –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –ø–æ–¥ –Ω–∞–∑–≤–∞–Ω–∏–µ–º <em>debug</em>. –í—ã –º–æ–∂–µ—Ç–µ –∑–∞–ø—É—Å—Ç–∏—Ç—å –∏—Å–ø–æ–ª–Ω—è–µ–º—ã–π —Ñ–∞–π–ª, –Ω–∞–ø–∏—Å–∞–≤ –≤ –∫–æ–Ω—Å–æ–ª–∏:</p>
<pre><code class="language-console">$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
Hello, world!
</code></pre>
<p>–ï—Å–ª–∏ –≤—Å—ë —Ö–æ—Ä–æ—à–æ, –≤—ã —É–≤–∏–¥–∏—Ç–µ <code>Hello, world!</code> –≤ —Ç–µ—Ä–º–∏–Ω–∞–ª–µ. –ó–∞–ø—É—Å–∫  <code>cargo build</code> –≤ –ø–µ—Ä–≤—ã–π —Ä–∞–∑ –ø—Ä–∏–≤–æ–¥–∏—Ç –∫ –ø–æ—è–≤–ª–µ–Ω–∏—é –Ω–æ–≤–æ–≥–æ —Ñ–∞–π–ª–∞ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –ø—Ä–æ–µ–∫—Ç–∞: <em>Cargo.lock</em>. –≠—Ç–æ—Ç —Ñ–∞–π–ª —Ö—Ä–∞–Ω–∏—Ç —Ç–æ—á–Ω—ã–µ –≤–µ—Ä—Å–∏–∏ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π, –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã—Ö –≤ –≤–∞—à–µ–º –ø—Ä–æ–µ–∫—Ç–µ. –ù–∞—à –ø—Ä–æ–µ–∫—Ç –Ω–µ –∏–º–µ–µ—Ç –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π, —Ç–∞–∫ —á—Ç–æ —ç—Ç–æ—Ç —Ñ–∞–π–ª —Å–ª–µ–≥–∫–∞ –ø—É—Å—Ç. –í–∞–º –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –ø–æ–Ω–∞–¥–æ–±–∏—Ç—Å—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —ç—Ç–æ—Ç —Ñ–∞–π–ª –≤—Ä—É—á–Ω—É—é; Cargo –±—É–¥–µ—Ç —É–ø—Ä–∞–≤–ª—è—Ç—å –∏–º —Å–∞–º–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω–æ.</p>
<p>–ú—ã —Ç–æ–ª—å–∫–æ —á—Ç–æ —Å–æ–±—Ä–∞–ª–∏ –ø—Ä–æ–µ–∫—Ç —Å –ø–æ–º–æ—â—å—é <code>cargo build</code> –∏ –∑–∞–ø—É—Å—Ç–∏–ª–∏ –µ–≥–æ —á–µ—Ä–µ–∑ <code>./target/debug/hello_cargo</code>, –Ω–æ –º—ã —Ç–∞–∫–∂–µ –º–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å <code>cargo run</code>, —á—Ç–æ–±—ã –æ–¥–Ω–æ–π –∫–æ–º–∞–Ω–¥–æ–π —Å–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞—Ç—å –∫–æ–¥ –∏ –∑–∞—Ç–µ–º –∑–∞–ø—É—Å—Ç–∏—Ç—å –ø–æ–ª—É—á–µ–Ω–Ω—ã–π –∏—Å–ø–æ–ª–Ω—è–µ–º—ã–π —Ñ–∞–π–ª:</p>
<pre><code class="language-console">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ <code>cargo run</code> —É–¥–æ–±–Ω–µ–µ, —á–µ–º –Ω–µ–æ–±–æ—Ö–æ–¥–∏–º–æ—Å—Ç—å –ø–æ–º–Ω–∏—Ç—å –≤—ã–ø–æ–ª–Ω—è—Ç—å <code>cargo build</code> –∏ –∑–∞—Ç–µ–º –∑–∞–ø—É—Å–∫–∞—Ç—å –ø—Ä–æ–≥—Ä–∞–º–º—É, –æ–±—Ä–∞—â–∞—è—Å—å –ø–æ –ø–æ–ª–Ω–æ–º—É –ø—É—Ç–∏, —Ç–∞–∫ —á—Ç–æ –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–æ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç–æ–≤ –ø—Ä–∏–º–µ–Ω—è—é—Ç <code>cargo run</code>.</p>
<p>–û—Ç–º–µ—Ç–∏–º, —á—Ç–æ –≤ —ç—Ç–æ—Ç —Ä–∞–∑ –º—ã –Ω–µ —É–≤–∏–¥–µ–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–π Cargo –æ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ <code>hello_cargo</code>. Cargo –ø–æ–Ω—è–ª, —á—Ç–æ —Ñ–∞–π–ª—ã –ø—Ä–æ–µ–∫—Ç–∞ –Ω–µ –ø–æ–º–µ–Ω—è–ª–∏—Å—å, —Ç–∞–∫ —á—Ç–æ –æ–Ω –Ω–µ —Å—Ç–∞–ª –ø—Ä–æ–≤–æ–¥–∏—Ç—å –ø–µ—Ä–µ—Å–±–æ—Ä–∫—É –∏ –ø—Ä–æ—Å—Ç–æ –∑–∞–ø—É—Å—Ç–∏–ª –∏–º–µ—é—â–∏–π—Å—è –±–∏–Ω–∞—Ä–Ω—ã–π —Ñ–∞–π–ª. –ï—Å–ª–∏ –±—ã –≤—ã –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–ª–∏ –∏—Å—Ö–æ–¥–Ω—ã–π –∫–æ–¥, Cargo –±—ã –ø–µ—Ä–µ—Å–æ–±—Ä–∞–ª –ø—Ä–æ–µ–∫—Ç –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º, –∏ –≤—ã –±—ã —É–≤–∏–¥–µ–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤—Ä–æ–¥–µ —Ç–∞–∫–æ–≥–æ:</p>
<pre><code class="language-console">$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Cargo —Ç–∞–∫–∂–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç –∫–æ–º–∞–Ω–¥—É <code>cargo check</code>. –≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –±—ã—Å—Ç—Ä–æ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –≤–∞—à –∫–æ–¥, —á—Ç–æ–±—ã —É–±–µ–¥–∏—Ç—å—Å—è, —á—Ç–æ –æ–Ω –∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è; –æ–¥–Ω–∞–∫–æ, –æ–Ω–∞ –Ω–µ —Å–æ–∑–¥–∞—ë—Ç –∏—Å–ø–æ–ª–Ω—è–µ–º—ã–π —Ñ–∞–π–ª:</p>
<pre><code class="language-console">$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
<p>–ü–æ—á–µ–º—É –≤–∞–º –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–µ –Ω—É–∂–µ–Ω –∏—Å–ø–æ–ª–Ω—è–µ–º—ã–π —Ñ–∞–π–ª? –ß–∞—Å—Ç–æ –ø—Ä–æ–≤–µ—Ä–∫–∞ —á–µ—Ä–µ–∑ <code>cargo check</code> –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ –±—ã—Å—Ç—Ä–µ–µ, —á–µ–º <code>cargo build</code>, –ø–æ—Å–∫–æ–ª—å–∫—É –æ–Ω–∞ –Ω–µ –≤—ã–ø–æ–ª–Ω—è–µ—Ç –Ω–µ–ø–æ—Å—Ä–µ–¥—Å—Ç–≤–µ–Ω–Ω–æ –∫–æ–º–ø–∏–ª—è—Ü–∏—é –ø—Ä–æ–≥—Ä–∞–º–º—ã. –ï—Å–ª–∏ –≤—ã –±—É–¥–µ—Ç–µ –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏ –ø—Ä–æ–≤–µ—Ä—è—Ç—å —Å–≤–æ–π –∫–æ–¥ –ø–æ –º–µ—Ä–µ –Ω–∞–ø–∏—Å–∞–Ω–∏—è, –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ <code>cargo check</code> –ø–æ–∑–≤–æ–ª–∏—Ç –±–µ–∑ –±–æ–ª—å—à–∏—Ö —Ç—Ä–∞—Ç –≤—Ä–µ–º–µ–Ω–∏ —É–±–µ–∂–¥–∞—Ç—å—Å—è, —á—Ç–æ –ø—Ä–æ–µ–∫—Ç –≤—Å—ë –µ—â—ë –∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è! –ü–æ—ç—Ç–æ–º—É, –º–Ω–æ–≥–∏–µ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç—ã –Ω–∞ Rust –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏ –∑–∞–ø—É—Å–∫–∞—é—Ç <code>cargo check</code> –ø–æ –º–µ—Ä–µ —Ä–∞–±–æ—Ç—ã –Ω–∞–¥ –ø—Ä–æ–≥—Ä–∞–º–º–æ–π. –ê <code>cargo build</code> –ø—Ä–∏–º–µ–Ω—è–µ—Ç—Å—è —Ç–æ–≥–¥–∞, –∫–æ–≥–¥–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∞ –≥–æ—Ç–æ–≤–∞ –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é.</p>
<p>–ü–æ–≤—Ç–æ—Ä–∏–º —Ç–æ, —á—Ç–æ –º—ã —É–∑–Ω–∞–ª–∏ –æ Cargo:</p>
<ul>
<li>–ú—ã –º–æ–∂–µ–º —Å–æ–∑–¥–∞–≤–∞—Ç—å –ø—Ä–æ–µ–∫—Ç—ã, –∏—Å–ø–æ–ª—å–∑—É—è <code>cargo new</code>.</li>
<li>–ú—ã –º–æ–∂–µ–º —Å–æ–±–∏—Ä–∞—Ç—å –ø—Ä–æ–µ–∫—Ç—ã, –∏—Å–ø–æ–ª—å–∑—É—è <code>cargo build</code>.</li>
<li>–ú—ã –º–æ–∂–µ–º —Å–æ–±–∏—Ä–∞—Ç—å –∏ –∑–∞–ø—É—Å–∫–∞—Ç—å –ø—Ä–æ–µ–∫—Ç—ã –æ–¥–Ω–æ–π –∫–æ–º–∞–Ω–¥–æ–π <code>cargo run</code>.</li>
<li>–ú—ã –º–æ–∂–µ–º –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –∫–æ–¥ –Ω–∞ –æ—à–∏–±–∫–∏ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏, –Ω–µ —Å–æ–∑–¥–∞–≤–∞—è –∏—Å–ø–æ–ª–Ω—è–µ–º—ã–π —Ñ–∞–π–ª, –∏—Å–ø–æ–ª—å–∑—É—è <code>cargo check</code>.</li>
<li>Cargo —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–±–æ—Ä–∫–∏ –Ω–µ –≤ –∫–æ—Ä–Ω–µ–≤—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –ø—Ä–æ–µ–∫—Ç–∞, –∞ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é <em>target/debug</em>.</li>
</ul>
<p>–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–º –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–æ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è Cargo —è–≤–ª—è–µ—Ç—Å—è —Ç–æ, —á—Ç–æ –µ–≥–æ –∫–æ–º–∞–Ω–¥—ã –±—É–¥—É—Ç –æ–¥–∏–Ω–∞–∫–æ–≤—ã –¥–ª—è –ª—é–±—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–æ–Ω–Ω—ã—Ö —Å–∏—Å—Ç–µ–º. –¢–∞–∫ —á—Ç–æ —Å —ç—Ç–æ–≥–æ –º–æ–º–µ–Ω—Ç—ã –º—ã –±–æ–ª–µ–µ –Ω–µ –±—É–¥–µ–º –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è—Ç—å –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏, —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –¥–ª—è Linux –∏ macOS –∏–ª–∏ Windows.</p>
<h3 id="–°–æ–∑–¥–∞–Ω–∏–µ-—Ä–µ–ª–∏–∑–Ω–æ–π-–≤–µ—Ä—Å–∏–∏"><a class="header" href="#–°–æ–∑–¥–∞–Ω–∏–µ-—Ä–µ–ª–∏–∑–Ω–æ–π-–≤–µ—Ä—Å–∏–∏">–°–æ–∑–¥–∞–Ω–∏–µ —Ä–µ–ª–∏–∑–Ω–æ–π –≤–µ—Ä—Å–∏–∏</a></h3>
<p>–ö–æ–≥–¥–∞ –≤–∞—à –ø—Ä–æ–µ–∫—Ç –Ω–∞–∫–æ–Ω–µ—Ü-—Ç–æ –≥–æ—Ç–æ–≤ –≤ —Ä–µ–ª–∏–∑—É, –≤—ã –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å <code>cargo build --release</code>, —á—Ç–æ–±—ã —Å–æ–±—Ä–∞—Ç—å –µ–≥–æ —Å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è–º–∏. –≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ —Å–æ–∑–¥–∞—Å—Ç –∏—Å–ø–æ–ª–Ω—è–µ–º—ã–π —Ñ–∞–π–ª –Ω–µ –≤ <em>target/debug</em>, –∞ –≤ <em>target/release</em>. –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –¥–µ–ª–∞—é—Ç –≤–∞—à –∫–æ–¥ –Ω–∞ Rust –±–æ–ª–µ–µ –±—ã—Å—Ç—Ä—ã–º, –Ω–æ –∏—Ö –≤–∫–ª—é—á–µ–Ω–∏–µ —Ç–∞–∫–∂–µ —É–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏. –ü–æ—ç—Ç–æ–º—É –µ—Å—Ç—å –¥–≤–∞ –ø—Ä–æ—Ñ–∏–ª—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏: –æ–¥–∏–Ω –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏, –∫–æ–≥–¥–∞ –≤—ã —Ö–æ—Ç–∏—Ç–µ –±—ã—Å—Ç—Ä–æ –∏ —á–∞—Å—Ç–æ –ø–µ—Ä–µ—Å–æ–±–∏—Ä–∞—Ç—å –ø—Ä–æ–µ–∫—Ç; –∏ –¥—Ä—É–≥–æ–π, –¥–ª—è —Å–±–æ—Ä–∫–∏ –æ–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω–æ–π –≤–µ—Ä—Å–∏–∏ –ø—Ä–æ–≥—Ä–∞–º–º—ã, –∫–æ—Ç–æ—Ä–∞—è –±—É–¥–µ—Ç —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—è—Ç—å—Å—è —Å—Ä–µ–¥–∏ –∫–æ–Ω–µ—á–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∏ –∫–æ—Ç–æ—Ä–∞—è –ø–æ—Ç–æ–º—É –¥–æ–ª–∂–Ω–∞ —Ä–∞–±–æ—Ç–∞—Ç—å –ø—Ä–µ–¥–µ–ª—å–Ω–æ –±—ã—Å—Ç—Ä–æ. –ï—Å–ª–∏ –≤—ã –∑–∞–º–µ—Ä—è–µ—Ç–µ –±—ã—Å—Ç—Ä–æ–¥–µ–π—Å—Ç–≤–∏–µ —Å–≤–æ–µ–≥–æ –∫–æ–¥–∞, –Ω–µ –∑–∞–±—É–¥—å—Ç–µ —Å–æ–±—Ä–∞—Ç—å –µ–≥–æ —á–µ—Ä–µ–∑ <code>cargo build --release</code>, –∞ –∑–∞–º–µ—Ä—ã –ø—Ä–æ–≤–æ–¥–∏—Ç–µ –Ω–∞–¥ –∏—Å–ø–æ–ª–Ω—è–µ–º—ã–º —Ñ–∞–π–ª–æ–º –∏–∑ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ <em>target/release</em>.</p>
<h3 id="cargo-–∫–∞–∫-—Å–æ–≥–ª–∞—à–µ–Ω–∏–µ-–º–µ–∂–¥—É-–ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç–∞–º–∏"><a class="header" href="#cargo-–∫–∞–∫-—Å–æ–≥–ª–∞—à–µ–Ω–∏–µ-–º–µ–∂–¥—É-–ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç–∞–º–∏">Cargo –∫–∞–∫ —Å–æ–≥–ª–∞—à–µ–Ω–∏–µ –º–µ–∂–¥—É –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç–∞–º–∏</a></h3>
<p>–ü—Ä–∏ —Ä–∞–±–æ—Ç–µ —Å –º–∞–ª–µ–Ω—å–∫–∏–º–∏ –ø—Ä–æ–µ–∫—Ç–∞–º–∏, Cargo –Ω–µ —Å–∏–ª—å–Ω–æ –ø–æ–ª–µ–∑–Ω–µ–µ <code>rustc</code>, –Ω–æ –æ–Ω –±—É–¥–µ—Ç –ø–æ–ª–µ–∑–µ–Ω, –∫–æ–≥–¥–∞ –≤–∞—à–∏ –ø—Ä–æ–≥—Ä–∞–º–º—ã —Å—Ç–∞–Ω—É—Ç –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω—ã–º–∏. –ö–æ–≥–¥–∞ –≤–∞—à–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∞ —Ä–∞–∑—Ä–∞—Å—Ç—ë—Ç—Å—è –¥–æ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Ñ–∞–π–ª–æ–≤ –∏–ª–∏ –µ–π –ø–æ–Ω–∞–¥–æ–±–∏—Ç—Å—è –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å, —Å—Ç–æ–∏—Ç –¥–∞—Ç—å Cargo —É–ø—Ä–∞–≤–ª—è—Ç—å —Å–±–æ—Ä–∫–æ–π.</p>
<p>–ü—É—Å—Ç—å –ø—Ä–æ–µ–∫—Ç <code>hello_cargo</code> –∏ –ø—Ä–æ—Å—Ç–æ–π, –Ω–æ –Ω–∞ –µ–≥–æ –ø—Ä–∏–º–µ—Ä–µ –≤–∏–¥–Ω–æ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Ä–µ–∞–ª—å–Ω–æ–≥–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞, –∫–æ—Ç–æ—Ä—ã–π –±—É–¥–µ—Ç —Å –≤–∞–º–∏ –Ω–∞ –ø—Ä–æ—Ç—è–∂–µ–Ω–∏–∏ –≤—Å–µ–≥–æ –≤–∞—à–µ–≥–æ –ø—É—Ç–∏ –≤ Rust. –ö–æ–≥–¥–∞ –≤–∞–º –ø–æ–Ω–∞–¥–æ–±–∏—Ç—Å—è —Ä–∞–±–æ—Ç–∞—Ç—å –Ω–∞–¥ –ø—Ä–æ–µ–∫—Ç–∞–º–∏, —Ä–∞–∑–º–µ—â—ë–Ω–Ω—ã–º–∏ –≤ —Å–µ—Ç–∏, –≤—ã –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å–ª–µ–¥—É—é—â–∏–µ –∫–æ–º–∞–Ω–¥—ã, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –∫–æ–¥ –∏–∑ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è Git, –ø–µ—Ä–µ–π—Ç–∏ –≤ –µ–≥–æ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é, –∏ —Å–æ–±—Ä–∞—Ç—å:</p>
<pre><code class="language-console">$ git clone example.org/someproject
$ cd someproject
$ cargo build
</code></pre>
<p>–ë–æ–ª—å—à–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ Cargo –º–æ–∂–Ω–æ –Ω–∞–π—Ç–∏ –≤ <a href="https://doc.rust-lang.org/cargo/">–µ–≥–æ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏</a>.</p>
<h2 id="–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏"><a class="header" href="#–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏">–ü–æ–¥–≤–µ–¥—ë–º –∏—Ç–æ–≥–∏</a></h2>
<p>–≠—Ç–æ –±—ã–ª –æ—á–µ–Ω—å —Ö–æ—Ä–æ—à–∏–π —Å—Ç–∞—Ä—Ç –≤–∞—à–µ–≥–æ –ø—É—Ç–µ—à–µ—Å—Ç–≤–∏—è –≤ –º–∏—Ä Rust! –í —ç—Ç–æ–π –≥–ª–∞–≤–µ –≤—ã —É–∑–Ω–∞–ª–∏, –∫–∞–∫:</p>
<ul>
<li>–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω—é—é —Å—Ç–∞–±–∏–ª—å–Ω—É—é –≤–µ—Ä—Å–∏—é Rust, –∏—Å–ø–æ–ª—å–∑—É—è <code>rustup</code></li>
<li>–û–±–Ω–æ–≤–∏—Ç—å—Å—è –¥–æ –±–æ–ª–µ–µ –Ω–æ–≤–æ–π –≤–µ—Ä—Å–∏–∏ Rust</li>
<li>–û—Ç–∫—Ä—ã—Ç—å –ª–æ–∫–∞–ª—å–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—É—é –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é</li>
<li>–ù–∞–ø–∏—Å–∞—Ç—å –∏ –∑–∞–ø—É—Å—Ç–∏—Ç—å –ø—Ä–æ–≥—Ä–∞–º–º—É "Hello, world!" –Ω–∞–ø—Ä—è–º—É—é —Å –ø–æ–º–æ—â—å—é <code>rustc</code></li>
<li>–°–æ–∑–¥–∞—Ç—å –∏ –∑–∞–ø—É—Å—Ç–∏—Ç—å –Ω–æ–≤—ã–π –ø—Ä–æ–µ–∫—Ç, –∏—Å–ø–æ–ª—å–∑—É—è –∫–æ–º–∞–Ω–¥—ã Cargo</li>
</ul>
<p>–û—Ç–ª–∏—á–Ω–∞—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å —Å–æ–∑–¥–∞—Ç—å –±–æ–ª–µ–µ —Å—É—â–µ—Å—Ç–≤–µ–Ω–Ω—É—é –ø—Ä–æ–≥—Ä–∞–º–º—É –∏ –Ω–∞—É—á–∏—Ç—å—Å—è —á–∏—Ç–∞—Ç—å –∏ –ø–∏—Å–∞—Ç—å –∫–æ–¥ –Ω–∞ Rust. –í –ì–ª–∞–≤–µ 2 –º—ã –Ω–∞–ø–∏—à–µ–º –∏–≥—Ä—É –≤ —É–≥–∞–¥–∞–π–∫—É. –ù–æ, –µ—Å–ª–∏ –≤—ã —Ö–æ—Ç–µ–ª–∏ –±—ã –∏–∑—É—á–∏—Ç—å, –∫–∞–∫ –≤ Rust —É—Å—Ç—Ä–æ–µ–Ω—ã –æ–±—â–∏–µ –ø–æ–Ω—è—Ç–∏—è –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è, –ø–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –ì–ª–∞–≤—É 3 –∏ –ø–æ—Ç–æ–º –≤–µ—Ä–Ω–∏—Ç–µ—Å—å –∫ –ì–ª–∞–≤–µ 2.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="–ü—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ-–∏–≥—Ä—ã-–≤-—É–≥–∞–¥–∞–π–∫—É"><a class="header" href="#–ü—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ-–∏–≥—Ä—ã-–≤-—É–≥–∞–¥–∞–π–∫—É">–ü—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–≥—Ä—ã –≤ —É–≥–∞–¥–∞–π–∫—É</a></h1>
<p>–û–∫—É–Ω—ë–º—Å—è –≤ –º–∏—Ä Rust, –≤–º–µ—Å—Ç–µ —Å–æ–∑–¥–∞–≤ –ø—Ä–∏–∫–ª–∞–¥–Ω–æ–π –ø—Ä–æ–µ–∫—Ç! –≠—Ç–∞ –≥–ª–∞–≤–∞ –ø–æ–∑–Ω–∞–∫–æ–º–∏—Ç –≤–∞—Å —Å –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ –Ω–∞–∏–±–æ–ª–µ–µ –≤–∞–∂–Ω—ã–º–∏ –∫–æ–Ω—Ü–µ–ø—Ü–∏—è–º–∏ Rust, –ø–æ–∫–∞–∑–∞–≤, –∫–∞–∫ –∏—Ö –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤ —Ä–µ–∞–ª—å–Ω–æ–π –ø—Ä–æ–≥—Ä–∞–º–º–µ. –í—ã —É–∑–Ω–∞–µ—Ç–µ –æ <code>let</code>, <code>match</code>, –º–µ—Ç–æ–¥–∞—Ö, –∞—Å—Å–æ—Ü–∏–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏—è—Ö, –≤–Ω–µ—à–Ω–∏—Ö –∫—Ä–µ–π—Ç–∞—Ö –∏ –º–Ω–æ–≥–æ–º –¥—Ä—É–≥–æ–º! –í –¥–∞–ª—å–Ω–µ–π—à–∏—Ö –≥–ª–∞–≤–∞—Ö –º—ã –∏–∑—É—á–∏–º –≤—Å—ë –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–Ω–æ–µ –ø–æ–¥—Ä–æ–±–Ω–µ–µ. –í —ç—Ç–æ–π –≥–ª–∞–≤–µ –≤—ã –ø—Ä–∏–∫–æ—Å–Ω—ë—Ç–µ—Å—å —Ç–æ–ª—å–∫–æ –∫ —Å–∞–º—ã–º –æ—Å–Ω–æ–≤–∞–º.</p>
<p>–ú—ã —Ä–µ–∞–ª–∏–∑—É–µ–º –∫–ª–∞—Å—Å–∏—á–µ—Å–∫—É—é –∑–∞–¥–∞—á–∫—É –¥–ª—è –Ω–æ–≤–∏—á–∫–∞: –∏–≥—Ä—É –≤ —É–≥–∞–¥—ã–≤–∞–Ω–∏–µ —á–∏—Å–ª–∞. –û–Ω–∞ –±—É–¥–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å —Å–ª–µ–¥—É—é—â–∏–º –æ–±—Ä–∞–∑–æ–º: –ø—Ä–æ–≥—Ä–∞–º–º–∞ –∑–∞–≥–∞–¥–∞–µ—Ç —Å–ª—É—á–∞–π–Ω–æ–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ –æ—Ç 1 –¥–æ 100; –∑–∞—Ç–µ–º –æ–Ω–∞ –∑–∞–ø—Ä–æ—Å–∏—Ç —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤–≤–æ–¥ –¥–æ–≥–∞–¥–∫–∏ –≤ –∫–æ–Ω—Å–æ–ª—å. –ü—Ä–æ–≥—Ä–∞–º–º–∞ —Å–æ–æ–±—â–∏—Ç, –±–æ–ª—å—à–µ –∏–ª–∏ –º–µ–Ω—å—à–µ –ª–∏ –¥–æ–≥–∞–¥–∫–∞, —á–µ–º –∑–∞–≥–∞–¥–∞–Ω–Ω–æ–µ —á–∏—Å–ª–æ. –ï—Å–ª–∏ –¥–æ–≥–∞–¥–∫–∞ –æ–∫–∞–∂–µ—Ç—Å—è –≤–µ—Ä–Ω–æ–π, –∏–≥—Ä–∞ –≤—ã–≤–µ–¥–µ—Ç –ø–æ–∑–¥—Ä–∞–≤–∏—Ç–µ–ª—å–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ –∑–∞–≤–µ—Ä—à–∏—Ç—Å—è.</p>
<h2 id="–°–æ–∑–¥–∞–Ω–∏–µ-–Ω–æ–≤–æ–≥–æ-–ø—Ä–æ–µ–∫—Ç–∞"><a class="header" href="#–°–æ–∑–¥–∞–Ω–∏–µ-–Ω–æ–≤–æ–≥–æ-–ø—Ä–æ–µ–∫—Ç–∞">–°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞</a></h2>
<p>–ß—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –ø—Ä–æ–µ–∫—Ç, –ø–µ—Ä–µ–π–¥–∏—Ç–µ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é <em>projects</em>, —Å–æ–∑–¥–∞–Ω–Ω—É—é –≤–∞–º–∏ –≤ –ì–ª–∞–≤–µ 1, –∏ –≤–æ—Å–ø–æ–ª—å–∑—É–π—Ç–µ—Å—å Cargo, –≤–æ—Ç —Ç–∞–∫:</p>
<pre><code class="language-console">$ cargo new guessing_game
$ cd guessing_game
</code></pre>
<p>–ü–µ—Ä–≤–∞—è –∫–æ–º–∞–Ω–¥–∞ (<code>cargo new</code>) –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –∏–º—è –ø—Ä–æ–µ–∫—Ç–∞ (<code>guessing_game</code>) –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–µ—Ä–≤–æ–≥–æ –∞—Ä–≥—É–º–µ–Ω—Ç–∞. –í—Ç–æ—Ä–∞—è –∫–æ–º–∞–Ω–¥–∞ –æ—Å—É—â–µ—Å—Ç–≤–ª—è–µ—Ç –ø–µ—Ä–µ—Ö–æ–¥ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –ø—Ä–æ–µ–∫—Ç–∞.</p>
<p>–ü–æ—Å–º–æ—Ç—Ä–∏–º –Ω–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ñ–∞–π–ª <em>Cargo.toml</em>:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial
rm -rf no-listing-01-cargo-new
cargo new no-listing-01-cargo-new --name guessing_game
cd no-listing-01-cargo-new
cargo run > output.txt 2>&1
cd ../../..
-->
<p><span class="filename">–§–∞–π–ª: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
version = "0.1.0"
edition = "2021"

[dependencies]
</code></pre>
<p>–ö–∞–∫ –≤—ã —É–≤–∏–¥–µ–ª–∏ –≤ –ì–ª–∞–≤–µ 1, <code>cargo new</code> –Ω–∞—á–∏–Ω–∞–µ—Ç –Ω–æ–≤—ã–π –ø—Ä–æ–µ–∫—Ç —Å–æ–∑–¥–∞–Ω–∏–µ–º –ø—Ä–æ–≥—Ä–∞–º–º—ã "Hello, world!". –ü–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –≤ —Ñ–∞–π–ª <em>src/main.rs</em>:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    println!("Hello, world!");
}</code></pre></pre>
<p>–¢–µ–ø–µ—Ä—å —Å–∫–æ–º–ø–∏–ª–∏—Ä—É–µ–º –∏ –∑–∞–ø—É—Å—Ç–∏–º —ç—Ç—É –ø—Ä–æ–≥—Ä–∞–º–º—É –æ–¥–Ω–æ–π –∫–æ–º–∞–Ω–¥–æ–π ‚Äî <code>cargo run</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.20s
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
<p>–ö–æ–º–∞–Ω–¥–∞ <code>run</code> –æ—Å–æ–±–µ–Ω–Ω–æ –ø–æ–ª–µ–∑–Ω–∞ —Ç–æ–≥–¥–∞, –∫–æ–≥–¥–∞ –≤—ã —Ä–∞–∑—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç–µ –ø—Ä–æ–µ–∫—Ç –º–µ–ª–∫–∏–º–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è–º–∏ (–∏–º–µ–Ω–Ω–æ —Ç–∞–∫ –º—ã –∏ –±—É–¥–µ–º –¥–µ–ª–∞—Ç—å –Ω–∞—à—É –∏–≥—Ä—É!), —Ç–µ—Å—Ç–∏—Ä—É—è –∫–∞–∂–¥—É—é –∏—Ç–µ—Ä–∞—Ü–∏—é –ø–µ—Ä–µ–¥ —Ç–µ–º, –∫–∞–∫ –∏–¥—Ç–∏ –¥–∞–ª—å—à–µ.</p>
<p>–°–Ω–æ–≤–∞ –æ—Ç–∫—Ä–æ–π—Ç–µ —Ñ–∞–π–ª <em>src/main.rs</em>. –í–µ—Å—å –∫–æ–¥ –Ω–∞—à–µ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞ –≤—ã –±—É–¥–µ—Ç–µ –ø–∏—Å–∞—Ç—å –∏–º–µ–Ω–Ω–æ –≤ –Ω—ë–º.</p>
<h2 id="–û–±—Ä–∞–±–æ—Ç–∫–∞-–¥–æ–≥–∞–¥–∫–∏"><a class="header" href="#–û–±—Ä–∞–±–æ—Ç–∫–∞-–¥–æ–≥–∞–¥–∫–∏">–û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–æ–≥–∞–¥–∫–∏</a></h2>
<p>–ü–µ—Ä–≤–∞—è —á–∞—Å—Ç—å –∏–≥—Ä—ã –≤ —É–≥–∞–¥–∞–π–∫—É –±—É–¥–µ—Ç –ø—Ä–æ—Å–∏—Ç—å –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤–≤–æ–¥, –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –µ–≥–æ, –∏ –ø—Ä–æ–≤–µ—Ä—è—Ç—å, –∏–º–µ–µ—Ç –ª–∏ –≤–≤–æ–¥ –æ–∂–∏–¥–∞–µ–º—ã–π –≤–∏–¥. –î–ª—è –Ω–∞—á–∞–ª–∞, –ø–æ–∑–≤–æ–ª–∏–º –∏–≥—Ä–æ–∫—É –≤–≤–µ—Å—Ç–∏ –¥–æ–≥–∞–¥–∫—É. –ü–æ–º–µ—Å—Ç–∏—Ç–µ –∫–æ–¥ –∏–∑ –õ–∏—Å—Ç–∏–Ω–≥–∞ 2-1 –≤ <em>src/main.rs</em>.</p>
<Listing number="2-1" file-name="src/main.rs" caption="Code that gets a guess from the user and prints it">
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!("–£–≥–∞–¥–∞–π—Ç–µ —á–∏—Å–ª–æ!");

    println!("–í–≤–µ–¥–∏—Ç–µ —Å–≤–æ—é –¥–æ–≥–∞–¥–∫—É.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–µ—Å—Ç—å –≤–≤–æ–¥.");

    println!("–í—ã –ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏–ª–∏: {}", guess);
}</code></pre>
</Listing>
<p>–í —ç—Ç–æ–º –∫–æ–¥–µ –º–Ω–æ–≥–æ –Ω–æ–≤–æ–≥–æ, —Ç–∞–∫ —á—Ç–æ –¥–∞–≤–∞–π—Ç–µ –∏–∑—É—á–∏–º –µ–≥–æ —Å—Ç—Ä–æ—á–∫–∞ –∑–∞ —Å—Ç—Ä–æ—á–∫–æ–π. –ß—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π –≤–≤–æ–¥ –∏ –∑–∞—Ç–µ–º (–ø–æ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏) –Ω–∞–ø–µ—á–∞—Ç–∞—Ç—å –µ–≥–æ, –Ω–∞–º –Ω—É–∂–Ω–æ –ø–æ–¥–∫–ª—é—á–∏—Ç—å –±–∏–±–ª–∏–æ—Ç–µ–∫—É –≤–≤–æ–¥–∞-–≤—ã–≤–æ–¥–∞ <code>io</code> –≤ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏. –ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ <code>io</code> –≤—Ö–æ–¥–∏—Ç –≤ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—É—é –±–∏–±–ª–∏–æ—Ç–µ–∫—É, —Ç–∞–∫–∂–µ –∏–∑–≤–µ—Å—Ç–Ω—É—é –∫–∞–∫ <code>std</code>:</p>
<pre><code class="language-rust ignore">use std::io;
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("–£–≥–∞–¥–∞–π—Ç–µ —á–∏—Å–ª–æ!");
</span><span class="boring">
</span><span class="boring">    println!("–í–≤–µ–¥–∏—Ç–µ —Å–≤–æ—é –¥–æ–≥–∞–¥–∫—É.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–µ—Å—Ç—å –≤–≤–æ–¥.");
</span><span class="boring">
</span><span class="boring">    println!("–í—ã –ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏–ª–∏: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>Rust –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –ø–æ–¥–∫–ª—é—á–∞–µ—Ç –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –≤–∞–∂–Ω—ã–µ —á–∞—Å—Ç–∏ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –≤ –∫–∞–∂–¥—É—é –ø—Ä–æ–≥—Ä–∞–º–º—É. –≠—Ç–æ –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–æ –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è <em>prelude</em>, –∏ —Å –µ–≥–æ —Å–æ—Å—Ç–∞–≤–æ–º –≤—ã –º–æ–∂–µ—Ç–µ –æ–∑–Ω–∞–∫–æ–º–∏—Ç—å—Å—è –≤ <a href="https://doc.rust-lang.org/std/prelude/index.html">–¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏</a>.</p>
<p>–ï—Å–ª–∏ —Ç–∏–ø, –∫–æ—Ç–æ—Ä—ã–π –≤—ã —Ö–æ—Ç–∏—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å, –Ω–µ –≤—Ö–æ–¥–∏—Ç –≤ prelude, –≤–∞–º –Ω—É–∂–Ω–æ —è–≤–Ω–æ –ø–æ–¥–∫–ª—é—á–∏—Ç—å —ç—Ç–æ—Ç —Ç–∏–ø –∫ –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏ –ø—Ä–æ–≥—Ä–∞–º–º—ã, –∏—Å–ø–æ–ª—å–∑—É—è –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é <code>use</code>. –ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ <code>std::io</code> –¥–∞—Å—Ç –≤–∞–º –Ω–∞–±–æ—Ä –ø–æ–ª–µ–∑–Ω—ã—Ö –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π, –≤–∫–ª—é—á–∞—è –ø–æ–ª—É—á–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ –≤–≤–æ–¥–∞.</p>
<p>–ö–∞–∫ –≤—ã —É–≤–∏–¥–µ–ª–∏ –≤ –ì–ª–∞–≤–µ 1, —Ñ—É–Ω–∫—Ü–∏—è <code>main</code> ‚Äî —ç—Ç–æ —Ç–æ—á–∫–∞ –≤—Ö–æ–¥–∞ –≤ –ø—Ä–æ–≥—Ä–∞–º–º—É:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span>fn main() {
<span class="boring">    println!("–£–≥–∞–¥–∞–π—Ç–µ —á–∏—Å–ª–æ!");
</span><span class="boring">
</span><span class="boring">    println!("–í–≤–µ–¥–∏—Ç–µ —Å–≤–æ—é –¥–æ–≥–∞–¥–∫—É.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–µ—Å—Ç—å –≤–≤–æ–¥.");
</span><span class="boring">
</span><span class="boring">    println!("–í—ã –ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏–ª–∏: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>–ù–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è –æ–±—ä—è–≤–ª—è–µ—Ç—Å—è –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–æ–º <code>fn</code>. –ü—É—Å—Ç—ã–µ –∫—Ä—É–≥–ª—ã–µ —Å–∫–æ–±–∫–∏ <code>()</code> –æ–±–æ–∑–Ω–∞—á–∞—é—Ç, —á—Ç–æ —ç—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –Ω–µ –∏–º–µ–µ—Ç –ø–∞—Ä–∞–º–µ—Ç–æ–≤. –û—Ç–∫—Ä—ã–≤–∞—é—â–∞—è –∏–≥—É—Ä–Ω–∞—è —Å–∫–æ–±–∫–∞ <code>{</code> –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç –Ω–∞—á–∞–ª–æ —Ç–µ–ª–∞ —Ñ—É–Ω–∫—Ü–∏–∏.</p>
<p>–ö–∞–∫ –≤—ã —Ç–∞–∫–∂–µ —É–∑–Ω–∞–ª–∏ –≤ –ì–ª–∞–≤–µ 1, <code>println!</code> ‚Äî —ç—Ç–æ –º–∞–∫—Ä–æ—Å, –ø–µ—á–∞—Ç–∞—é—â–∏–π —Å—Ç—Ä–æ–∫—É –Ω–∞ —ç–∫—Ä–∞–Ω:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    println!("–£–≥–∞–¥–∞–π—Ç–µ —á–∏—Å–ª–æ!");

    println!("–í–≤–µ–¥–∏—Ç–µ —Å–≤–æ—é –¥–æ–≥–∞–¥–∫—É.");
<span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–µ—Å—Ç—å –≤–≤–æ–¥.");
</span><span class="boring">
</span><span class="boring">    println!("–í—ã –ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏–ª–∏: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>–≠—Ç–æ—Ç –∫–æ–¥ –ø–µ—á–∞—Ç–∞–µ—Ç —Ñ—Ä–∞–∑—ã: —Å–æ–æ–±—â–∞—é—â—É—é –æ —Å—É—Ç–∏ –∏–≥—Ä—ã –∏ –∑–∞–ø—Ä–∞—à–∏–≤–∞—é—â—É—é –≤–≤–æ–¥ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è</p>
<h3 id="–•—Ä–∞–Ω–µ–Ω–∏–µ-–∑–Ω–∞—á–µ–Ω–∏–π-—Å-–ø–æ–º–æ—â—å—é-–ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö"><a class="header" href="#–•—Ä–∞–Ω–µ–Ω–∏–µ-–∑–Ω–∞—á–µ–Ω–∏–π-—Å-–ø–æ–º–æ—â—å—é-–ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö">–•—Ä–∞–Ω–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏–π —Å –ø–æ–º–æ—â—å—é –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö</a></h3>
<p>–î–∞–ª–µ–µ! –°–æ–∑–¥–∞–¥–∏–º <em>–ø–µ—Ä–µ–º–µ–Ω–Ω—É—é</em> –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ –≤–≤–æ–¥–∞, –≤–æ—Ç —Ç–∞–∫:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("–£–≥–∞–¥–∞–π—Ç–µ —á–∏—Å–ª–æ!");
</span><span class="boring">
</span><span class="boring">    println!("–í–≤–µ–¥–∏—Ç–µ —Å–≤–æ—é –¥–æ–≥–∞–¥–∫—É.");
</span><span class="boring">
</span>    let mut guess = String::new();
<span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–µ—Å—Ç—å –≤–≤–æ–¥.");
</span><span class="boring">
</span><span class="boring">    println!("–í—ã –ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏–ª–∏: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>–ü—Ä–æ–≥—Ä–∞–º–º–∞ —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –∏–Ω—Ç–µ—Ä–µ—Å–Ω–µ–µ! –í —ç—Ç–æ–π —Å—Ç—Ä–æ—á–∫–µ, –Ω–∞ —Å–∞–º–æ–º –¥–µ–ª–µ, –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –æ—á–µ–Ω—å –º–Ω–æ–≥–æ–µ. –ú—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é <code>let</code> –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π. –í–æ—Ç –µ—â—ë –ø—Ä–∏–º–µ—Ä:</p>
<pre><code class="language-rust ignore">let apples = 5;</code></pre>
<p>–≠—Ç–∞ —Å—Ç—Ä–æ–∫–∞ —Å–æ–∑–¥–∞—ë—Ç –Ω–æ–≤—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –ø–æ–¥ –Ω–∞–∑–≤–∞–Ω–∏–µ–º <code>apples</code> –∏ —Å–≤—è–∑—ã–≤–∞–µ—Ç —Å –Ω–µ–π –∑–Ω–∞—á–µ–Ω–∏–µ 5. –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é, –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –≤ Rust –Ω–µ–∏–∑–º–µ–Ω—è–µ–º—ã, —Ç–æ –µ—Å—Ç—å –æ–¥–Ω–∞–∂–¥—ã —Å–≤—è–∑–∞–≤ –∏—Ö —Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º, –º—ã –±–æ–ª—å—à–µ –Ω–µ —Å–º–æ–∂–µ–º –µ–≥–æ –∏–∑–º–µ–Ω–∏—Ç—å. –ú—ã –æ–±—Å—É–¥–∏–º —ç—Ç–æ –ø–æ–¥—Ä–æ–±–Ω–µ–µ –≤ —Ä–∞–∑–¥–µ–ª–µ <a href="ch03-01-variables-and-mutability.html#%D0%9F%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D0%B8-%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D1%8F%D0%B5%D0%BC%D0%BE%D1%81%D1%82%D1%8C">"–ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏ –∏–∑–º–µ–Ω—è–µ–º–æ—Å—Ç—å"</a><!-- ignore --> –ì–ª–∞–≤—ã 3. –ß—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å –∏–∑–º–µ–Ω—è–µ–º—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é, –º—ã –¥–æ–±–∞–≤–∏–º <code>mut</code> –ø–µ—Ä–µ–¥ –∏–º–µ–Ω–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π:</p>
<pre><code class="language-rust ignore">let apples = 5; // –Ω–µ–∏–∑–º–µ–Ω—è–µ–º–∞
let mut bananas = 5; // –∏–∑–º–µ–Ω—è–µ–º–∞</code></pre>
<blockquote>
<p>–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: —Å–∏–º–≤–æ–ª—ã <code>//</code> –æ–±–æ–∑–Ω–∞—á–∞—é—Ç –Ω–∞—á–∞–ª–æ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è, –ø—Ä–æ–¥–æ–ª–∂–∞—é—â–µ–≥–æ—Å—è –¥–æ –∫–æ–Ω—Ü–∞ —Å—Ç—Ä–æ–∫–∏. Rust –∏–≥–Ω–æ—Ä–∏—Ä—É–µ—Ç –≤–µ—Å—å —Ç–µ–∫—Å—Ç –≤ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è—Ö. –ú—ã –¥–µ—Ç–∞–ª—å–Ω–µ–µ –æ–±—Å—É–¥–∏–º –∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤ <a href="ch03-04-comments.html">–ì–ª–∞–≤–µ 3</a><!-- ignore -->.</p>
</blockquote>
<p>–í–µ—Ä–Ω—ë–º—Å—è –∫ –ø—Ä–æ–≥—Ä–∞–º–º–µ –∏–≥—Ä—ã –≤ —É–≥–∞–¥–∞–π–∫—É. –¢–µ–ø–µ—Ä—å –≤—ã –∑–Ω–∞–µ—Ç–µ, —á—Ç–æ <code>let mut guess</code> —Å–æ–∑–¥–∞—ë—Ç –∏–∑–º–µ–Ω—è–µ–º—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é <code>guess</code>. –ó–Ω–∞–∫ —Ä–∞–≤–µ–Ω—Å—Ç–≤–∞ (<code>=</code>) –≥–æ–≤–æ—Ä–∏—Ç –æ —Ç–æ–º, —á—Ç–æ –º—ã —Ö–æ—Ç–∏–º —Å–≤—è–∑–∞—Ç—å —á—Ç–æ –±—ã —Ç–æ –Ω–∏ –±—ã–ª–æ —Å –¥–∞–Ω–Ω–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π. –ó–Ω–∞—á–µ–Ω–∏–µ, —Å –∫–æ—Ç–æ—Ä—ã–º —Å–≤—è–∑—ã–≤–∞–µ—Ç—Å—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è <code>guess</code>, —Ä–∞—Å–ø–æ–ª–∞–≥–∞–µ—Ç—Å—è —Å–ø—Ä–∞–≤–∞ –æ—Ç –∑–Ω–∞–∫–∞ —Ä–∞–≤–µ–Ω—Å—Ç–≤–∞; –æ–Ω–æ —è–≤–ª—è–µ—Ç—Å—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–º –≤—ã–∑–æ–≤–∞ —Ñ—É–Ω–∫—Ü–∏–∏ <code>String::new</code> ‚Äî —Ñ—É–Ω–∫—Ü–∏–∏, –≤–æ–∑–≤—Ä–∞—â–∞—é—â–µ–π –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Ç–∏–ø–∞ <code>String</code>. [<code>String</code>](https://doc.rust-lang.org/std/string/struct. String.html)<!-- ignore --> ‚Äî —ç—Ç–æ —Ç–∏–ø —Å—Ç—Ä–æ–∫–∏, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ–º—ã–π —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–æ–π. –û–Ω –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Å–æ–±–æ–π —Å—Ç—Ä–æ–∫—É —Ç–µ–∫—Å—Ç–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –¥–ª–∏–Ω—ã –≤ –∫–æ–¥–∏—Ä–æ–≤–∫–µ UTF-8.</p>
<p>–°–∏–º–≤–æ–ª—ã "::" –≤ —á–∞—Å—Ç–∏ <code>::new</code> –ø–æ–∫–∞–∑—ã–≤–∞—é—Ç, —á—Ç–æ <code>new</code> ‚Äî —Ñ—É–Ω–∫—Ü–∏—è, –∞—Å—Å–æ—Ü–∏–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å —Ç–∏–ø–æ–º <code>String</code>. <em>–ê—Å—Å–æ—Ü–∏–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è</em> ‚Äî —ç—Ç–æ —Ñ—É–Ω–∫—Ü–∏—è, —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–∞—è –Ω–∞ —Ç–∏–ø–µ (–≤ –¥–∞–Ω–Ω–æ–º —Å–ª—É—á–∞–µ ‚Äî –Ω–∞ <code>String</code>). –§—É–Ω–∫—Ü–∏—è <code>new</code> —Å–æ–∑–¥–∞—ë—Ç –Ω–æ–≤—É—é, –ø—É—Å—Ç—É—é —Å—Ç—Ä–æ–∫—É. –ú–Ω–æ–≥–∏–µ —Ç–∏–ø—ã –∏–º–µ—é—Ç –∞—Å—Å–æ—Ü–∏–∏—Ä–æ–≤–∞–Ω–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é <code>new</code>, –ø–æ—Å–∫–æ–ª—å–∫—É —ç—Ç–æ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ, —Ç–∏–ø–∏—á–Ω–æ–µ –∏–º—è –¥–ª—è —Ñ—É–Ω–∫—Ü–∏–∏, —Å–æ–∑–¥–∞—é—â–µ–π –Ω–µ–∫–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Ç–∏–ø–∞, –∫–æ—Ç–æ—Ä–æ–µ –º–æ–∂–Ω–æ –Ω–∞–∑–≤–∞—Ç—å –Ω–æ–≤—ã–º.</p>
<p>–í —Å–æ–≤–æ–∫—É–ø–Ω–æ—Å—Ç–∏, —Å—Ç—Ä–æ—á–∫–∞ <code>let mut guess = String::new();</code> —Å–æ–∑–¥–∞—ë—Ç –∏–∑–º–µ–Ω—è–µ–º—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é, —Å–≤—è–∑–∞–Ω–Ω—É—é —Å –Ω–æ–≤—ã–º, –ø—É—Å—Ç—ã–º —ç–∫–∑–µ–º–ø–ª—è—Ä–æ–º —Ç–∏–ø–∞ <code>String</code>. –§—É—Ö!</p>
<h3 id="–ü–æ–ª—É—á–µ–Ω–∏–µ-–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ-–≤–≤–æ–¥–∞"><a class="header" href="#–ü–æ–ª—É—á–µ–Ω–∏–µ-–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ-–≤–≤–æ–¥–∞">–ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ –≤–≤–æ–¥–∞</a></h3>
<p>–ù–∞–ø–æ–º–Ω–∏–º, —á—Ç–æ –º—ã –ø–æ–¥–∫–ª—é—á–∏–ª–∏ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å –≤–≤–æ–¥–∞-–≤—ã–≤–æ–¥–∞ –∏–∑ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏, –Ω–∞–ø–∏—Å–∞–≤ <code>use std::io;</code> –≤ –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–æ—á–∫–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã. –¢–µ–ø–µ—Ä—å –≤—ã–∑–æ–≤–µ–º —Ñ—É–Ω–∫—Ü–∏—é <code>stdin</code> –∏–∑ –º–æ–¥—É–ª—è <code>io</code>, –∫–æ—Ç–æ—Ä–∞—è –ø–æ–∑–≤–æ–ª–∏—Ç –Ω–∞–º –ø–æ–ª—É—á–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π –≤–≤–æ–¥:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("–£–≥–∞–¥–∞–π—Ç–µ —á–∏—Å–ª–æ!");
</span><span class="boring">
</span><span class="boring">    println!("–í–≤–µ–¥–∏—Ç–µ —Å–≤–æ—é –¥–æ–≥–∞–¥–∫—É.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span>    io::stdin()
        .read_line(&amp;mut guess)
<span class="boring">        .expect("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–µ—Å—Ç—å –≤–≤–æ–¥.");
</span><span class="boring">
</span><span class="boring">    println!("–í—ã –ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏–ª–∏: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>–ï—Å–ª–∏ –±—ã –º—ã –Ω–µ –∏—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–ª–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫—É <code>io</code> —Å –ø–æ–º–æ—â—å—é <code>use std::io;</code> –≤ –Ω–∞—á–∞–ª–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã, –º—ã –≤—Å—ë –µ—â—ë –º–æ–≥–ª–∏ –±—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω—É–∂–Ω—É—é –Ω–∞–º —Ñ—É–Ω–∫—Ü–∏—é, –≤—ã–∑–≤–∞–≤ –µ—ë –∫–∞–∫ <code>std::io::stdin</code>. –§—É–Ω–∫—Ü–∏—è <code>stdin</code> –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —ç–∫–∑–µ–º–ø–ª—è—Ä —Ç–∏–ø–∞ <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore -->, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—â–µ–≥–æ –¥–µ–∫–æ–¥–µ—Ä —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–≥–æ –ø–æ—Ç–æ–∫–∞ –≤–≤–æ–¥–∞.</p>
<p>–î–∞–ª–µ–µ, —Å—Ç—Ä–æ—á–∫–∞ <code>.read_line(&amp;mut guess)</code> –≤—ã–∑—ã–≤–∞–µ—Ç –º–µ—Ç–æ–¥ <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a> <!--ignore --> –¥–µ–∫–æ–¥–µ—Ä–∞ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–≥–æ –ø–æ—Ç–æ–∫–∞ –≤–≤–æ–¥–∞, –≤–æ–∑–≤—Ä–∞—â–∞—é—â–∏–π –≤–≤–æ–¥ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è. –ú—ã —Ç–∞–∫–∂–µ –ø–µ—Ä–µ–¥–∞—ë–º —Å—Ç—Ä–æ—á–∫—É <code>&amp;mut guess</code> –≤ –∫–∞—á–µ—Å—Ç–≤–µ –∞—Ä–≥—É–º–µ–Ω—Ç–∞ –º–µ—Ç–æ–¥—É <code>read_line</code>, —Ç–µ–º —Å–∞–º—ã–º —Å–æ–æ–±—â–∞—è, –≥–¥–µ –º—ã —Ö–æ—Ç–∏–º —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π –≤–≤–æ–¥. –ú–µ—Ç–æ–¥ <code>read_line</code> –±–µ—Ä—ë—Ç –≤—Å—ë, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞–ø–µ—á–∞—Ç–∞–ª –≤ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –ø–æ—Ç–æ–∫ –≤–≤–æ–¥–∞, –∏ –ø—Ä–∏–ø–∏—Å—ã–≤–∞–µ—Ç —ç—Ç–æ –∫ —Å—Ç—Ä–æ–∫–µ (–Ω–µ –ø–µ—Ä–µ–ø–∏—Å—ã–≤–∞—è –µ—ë —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ), —Ç–∞–∫ —á—Ç–æ –∑–¥–µ—Å—å –º—ã –ø–µ—Ä–µ–¥–∞—ë–º –Ω–∞—à—É —Å—Ç—Ä–æ–∫—É –≤ –∫–∞—á–µ—Å—Ç–≤–µ –∞—Ä–≥—É–º–µ–Ω—Ç–∞. –ü–µ—Ä–µ–¥–∞–≤–∞–µ–º–∞—è —Å—Ç—Ä–æ–∫–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –∏–∑–º–µ–Ω—è–µ–º–æ–π, —á—Ç–æ–±—ã –º–µ—Ç–æ–¥ –º–æ–≥ –∏–∑–º–µ–Ω–∏—Ç—å —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Å—Ç—Ä–æ–∫–∏.</p>
<p>–ó–Ω–∞–∫ <code>&amp;</code> –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –º—ã –ø–µ—Ä–µ–¥–∞—ë–º –º–µ—Ç–æ–¥—É –Ω–µ —Å–∞–º–æ –∑–Ω–∞—á–µ–Ω–∏–µ, –∞ <em>—Å—Å—ã–ª–∫—É</em> –Ω–∞ –µ–≥–æ –æ–±–ª–∞—Å—Ç—å –ø–∞–º—è—Ç–∏. –≠—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç –¥–∞–≤–∞—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–∏–º —á–∞—Å—Ç—è–º –ø—Ä–æ–≥—Ä–∞–º–º—ã –¥–æ—Å—Ç—É–ø –∫ –æ–¥–Ω–æ–π –∏ —Ç–æ–π –∂–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏, –±–µ–∑ –Ω–µ–æ–±–æ—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –º–Ω–æ–≥–æ–∫—Ä–∞—Ç–Ω–æ –∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –µ—ë. –°—Å—ã–ª–∫–∏ ‚Äî –≤–µ—â—å –º–Ω–æ–≥–æ–≥—Ä–∞–Ω–Ω–∞—è, –∏ –æ–¥–Ω–∏–º –∏–∑ –æ—Å–Ω–æ–≤–Ω—ã—Ö –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤ Rust —è–≤–ª—è–µ—Ç—Å—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –∏ –ø—Ä–æ—Å—Ç–æ—Ç–∞ –∏—Ö –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è. –ö–∞—Å–∞—Ç–µ–ª—å–Ω–æ –≤—Å–µ–≥–æ, —á—Ç–æ –º—ã –æ–±—Å—É–¥–∏–ª–∏: –Ω–∞ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –≤–∞–º –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∑–Ω–∞—Ç—å, —á—Ç–æ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏ —Å—Å—ã–ª–∫–∏ –Ω–µ–∏–∑–º–µ–Ω—è–µ–º—ã. –ü–æ—ç—Ç–æ–º—É –Ω–∞–º –ø—Ä–∏—à–ª–æ—Å—å –Ω–∞–ø–∏—Å–∞—Ç—å <code>&amp;mut guess</code> –≤–º–µ—Å—Ç–æ <code>&amp;guess</code>, —á—Ç–æ–±—ã —Å–¥–µ–ª–∞—Ç—å –ø–æ–ª—É—á–∏—Ç—å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∏–∑–º–µ–Ω—è—Ç—å –Ω—É–∂–Ω—É—é –Ω–∞–º –æ–±–ª–∞—Å—Ç—å –ø–∞–º—è—Ç–∏. (–í –ì–ª–∞–≤–µ 4 —Å—Å—ã–ª–∫–∏ –±—É–¥—É—Ç —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω—ã –ø–æ–¥—Ä–æ–±–Ω–µ–µ.)</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="handling-potential-failure-with-the-result-type"></a></p>
<h3 id="–û–±—Ä–∞–±–æ—Ç–∫–∞-–≤–æ–∑–º–æ–∂–Ω—ã—Ö-–æ—à–∏–±–æ–∫-—Å-–ø–æ–º–æ—â—å—é-result"><a class="header" href="#–û–±—Ä–∞–±–æ—Ç–∫–∞-–≤–æ–∑–º–æ–∂–Ω—ã—Ö-–æ—à–∏–±–æ–∫-—Å-–ø–æ–º–æ—â—å—é-result">–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–æ–∑–º–æ–∂–Ω—ã—Ö –æ—à–∏–±–æ–∫ —Å –ø–æ–º–æ—â—å—é <code>Result</code></a></h3>
<p>–ú—ã –µ—â—ë –Ω–µ –∑–∞–∫–æ–Ω—á–∏–ª–∏ —Å —Ç–æ–π —Å—Ç—Ä–æ—á–∫–æ–π, —Ç–æ–π –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é –º–µ—Ç–æ–¥–æ–≤. –¢–µ–ø–µ—Ä—å –º—ã –æ–±—Å—É–¥–∏–º —Ç—Ä–µ—Ç—å—é —Å—Ç—Ä–æ—á–∫—É, –æ–¥–Ω–∞–∫–æ —Å—Ç–æ–∏—Ç –æ—Ç–º–µ—Ç–∏—Ç—å, —á—Ç–æ, –ª–æ–≥–∏—á–µ—Å–∫–∏, —ç—Ç–æ –≤—Å—ë –æ–¥–Ω–∞ —Å—Ç—Ä–æ–∫–∞ –∫–æ–¥–∞. –í–æ—Ç —Å—Ç—Ä–æ—á–∫–∞, –æ –∫–æ—Ç–æ—Ä–æ–π –º—ã –≥–æ–≤–æ—Ä–∏–º:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("–£–≥–∞–¥–∞–π—Ç–µ —á–∏—Å–ª–æ!");
</span><span class="boring">
</span><span class="boring">    println!("–í–≤–µ–¥–∏—Ç–µ —Å–≤–æ—é –¥–æ–≥–∞–¥–∫—É.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span>        .expect("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–µ—Å—Ç—å –≤–≤–æ–¥.");
<span class="boring">
</span><span class="boring">    println!("–í—ã –ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏–ª–∏: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>–ú—ã –º–æ–≥–ª–∏ –±—ã –ø–µ—Ä–µ–ø–∏—Å–∞—Ç—å –≤—Å—é —Å—Ç—Ä–æ–∫—É –∫–æ–¥–∞ –≤–æ—Ç —Ç–∞–∫:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess).expect("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–µ—Å—Ç—å –≤–≤–æ–¥.");</code></pre>
<p>–û–¥–Ω–∞–∫–æ, –æ–¥–Ω—É –¥–ª–∏–Ω–Ω—É—é —Å—Ç—Ä–æ—á–∫—É —á–∏—Ç–∞—Ç—å –±—ã–ª–æ –±—ã —Ç—è–∂–µ–ª–æ, —Ç–∞–∫ —á—Ç–æ –º—ã –µ—ë —Ä–∞–∑–¥–µ–ª–∏–ª–∏, –ø–µ—Ä–µ–Ω–µ—Å—è –≤—ã–∑–æ–≤—ã –º–µ—Ç–æ–¥–æ–≤ (<code>.method_name()</code>) –Ω–∞ –Ω–æ–≤—ã–µ —Å—Ç—Ä–æ—á–∫–∏ –∏ –æ—Ç–±–∏–≤ –∏—Ö –ø—Ä–æ–±–µ–ª–∞–º–∏ –æ—Ç –∫—Ä–∞—è. –¢–µ–ø–µ—Ä—å –æ–±—Å—É–¥–∏–º, —á—Ç–æ –∏–º–µ–Ω–Ω–æ –¥–µ–ª–∞–µ—Ç —ç—Ç–∞ —Å—Ç—Ä–æ–∫–∞.</p>
<p>–ö–∞–∫ —Ä–∞–Ω–µ–µ —É–ø–æ–º–∏–Ω–∞–ª–æ—Å—å, <code>read_line</code> –ø–æ–º–µ—â–∞–µ—Ç –≤—Å—ë, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤–≤—ë–ª –≤ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –ø–æ—Ç–æ–∫ –≤—ã–≤–æ–¥–∞, –≤ —Å—Ç—Ä–æ–∫—É, –ø–æ–ª—É—á–∞–µ–º—É—é –∫–∞–∫ –∞—Ä–≥—É–º–µ–Ω—Ç. –ù–æ –æ–Ω —Ç–∞–∫–∂–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ —Ç–∏–ø–∞ <code>Result</code>. <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a><!--ignore --> ‚Äî —ç—Ç–æ <a href="ch06-00-enums.html"><em>–ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ</em></a><!-- ignore -->, —Ç–æ –µ—Å—Ç—å —Ç–∏–ø, –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω –æ–¥–Ω–∏–º –∏–∑ –≤–æ–∑–º–æ–∂–Ω—ã—Ö —Å–æ—Å—Ç–æ—è–Ω–∏–π. –ú—ã –Ω–∞–∑—ã–≤–∞–µ–º –∫–∞–∂–¥–æ–µ —Ç–∞–∫–æ–µ –≤–æ–∑–º–æ–∂–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ <em>–≤–∞—Ä–∏–∞–Ω—Ç–æ–º.</em></p>
<p>–í <a href="ch06-00-enums.html">–ì–ª–∞–≤–µ 6</a><!-- ignore --> –º—ã –≤ –¥–µ—Ç–∞–ª—è—Ö –æ–±—Å—É–¥–∏–º –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è. –ü–æ–∫–∞ –≤–∞–º –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∑–Ω–∞—Ç—å, —á—Ç–æ —Ç–∏–ø <code>Result</code> ‚Äî —ç—Ç–æ —Ç–∏–ø, –≤–∞—Ä–∏–∞–Ω—Ç—ã –∫–æ—Ç–æ—Ä–æ–≥–æ —Ö—Ä–∞–Ω—è—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫.</p>
<p>–í–∞—Ä–∏–∞–Ω—Ç–∞–º–∏ —Ç–∏–ø–∞ <code>Result</code> —è–≤–ª—è—é—Ç—Å—è <code>Ok</code> –∏ <code>Err</code>. –í–∞—Ä–∏–∞–Ω—Ç <code>Ok</code> –æ–∑–Ω–∞—á–∞–µ—Ç —É—Å–ø–µ—à–Ω–æ–µ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –∏ —Å–æ–¥–µ—Ä–∂–∏—Ç –≤ —Å–µ–±–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –µ—ë –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è. –í–∞—Ä–∏–∞–Ω—Ç <code>Err</code> –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –æ–ø–µ—Ä–∞—Ü–∏—é –Ω–µ —É–¥–∞–ª–æ—Å—å –∏—Å–ø–æ–ª–Ω–∏—Ç—å, –∏ —Å–æ–¥–µ—Ä–∂–∏—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –æ—à–∏–±–∫–µ.</p>
<p>–î–ª—è –∑–Ω–∞—á–µ–Ω–∏–π —Ç–∏–ø–∞ <code>Result</code> —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ –º–µ—Ç–æ–¥–æ–≤. –ù–∞–ø—Ä–∏–º–µ—Ä ‚Äî –º–µ—Ç–æ–¥ <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.expect"><code>expect</code> method</a><!-- ignore -->. –ï—Å–ª–∏ —ç—Ç–æ—Ç –º–µ—Ç–æ–¥ –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –Ω–∞ <code>Err</code>, –æ–Ω –≤—ã–∑–æ–≤–µ—Ç —Å–±–æ–π –ø—Ä–æ–≥—Ä–∞–º–º—ã –∏ –≤—ã–≤–µ–¥–µ—Ç –Ω–∞ —ç–∫—Ä–∞–Ω —Å–æ–æ–±—â–µ–Ω–∏–µ, –ø–µ—Ä–µ–¥–∞–Ω–Ω–æ–µ –µ–º—É –∫–∞–∫ –∞—Ä–≥—É–º–µ–Ω—Ç. (–ï—Å–ª–∏ –º–µ—Ç–æ–¥ <code>read_line</code> –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç <code>Err</code>, —Ç–æ —Å–∫–æ—Ä–µ–µ –≤—Å–µ–≥–æ, –ø—Ä–æ–∏–∑–æ—à–ª–∞ –∫–∞–∫–∞—è-—Ç–æ —Å–∏—Å—Ç–µ–º–Ω–∞—è –æ—à–∏–±–∫–∞.) –ï—Å–ª–∏ –º–µ—Ç–æ–¥ <code>expect</code> –±—É–¥–µ—Ç –≤—ã–∑–≤–∞–Ω –Ω–∞ <code>Ok</code>, –æ–Ω –≤–µ—Ä–Ω—ë—Ç –∑–Ω–∞—á–µ–Ω–∏–µ, —Ö—Ä–∞–Ω–∏–º–æ–µ –≤ <code>Ok</code> (–≤ –Ω–∞—à–µ–º —Å–ª—É—á–∞–µ: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π –≤–≤–æ–¥).</p>
<p>–ï—Å–ª–∏ –≤—ã –Ω–µ –≤—ã–∑–æ–≤–∏—Ç–µ <code>expect</code>, —Ç–æ –ø—Ä–æ–≥—Ä–∞–º–º–∞ —Å–∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è, –Ω–æ –≤—ã –ø–æ–ª—É—á–∏—Ç–µ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ:</p>
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `Result` that must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
10 |     let _ = io::stdin().read_line(&amp;mut guess);
   |     +++++++

warning: `guessing_game` (bin "guessing_game") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>Rust –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–∞–µ—Ç –≤–∞—Å, —á—Ç–æ: 1) –≤—ã –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Ç–∏–ø–∞ <code>Result</code>, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–µ –º–µ—Ç–æ–¥–æ–º <code>read_line</code>, –∏ 2) –≤—ã –Ω–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç–µ –≤–æ–∑–º–æ–∂–Ω—É—é –æ—à–∏–±–∫—É, —Å –∫–æ—Ç–æ—Ä–æ–π –º–æ–∂–µ—Ç –∑–∞–≤–µ—Ä—à–∏—Ç—å—Å—è –≤—ã–∑–æ–≤ —ç—Ç–æ–≥–æ –º–µ—Ç–æ–¥–∞.</p>
<p>–ü—Ä–∞–≤–∏–ª—å–Ω—ã–π —Å–ø–æ—Å–æ–± –∏–∑–±–∞–≤–∏—Ç—å—Å—è –æ—Ç —Ç–∞–∫–∏—Ö –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–π ‚Äî —ç—Ç–æ –ø–∏—Å–∞—Ç—å –∫–æ–¥ —Å –æ–±—Ä–∞–±–æ—Ç–∫–∞–º–∏ –æ—à–∏–±–æ–∫. –û–¥–Ω–∞–∫–æ, –≤ –Ω–∞—à–µ–º —Å–ª—É—á–∞–µ, –º—ã —Ö–æ—Ç–∏–º –ø—Ä–æ—Å—Ç–æ –∞–≤–∞—Ä–∏–π–Ω–æ –∑–∞–≤–µ—Ä—à–∏—Ç—å –Ω–∞—à—É –ø—Ä–æ–≥—Ä–∞–º–º—É, –µ—Å–ª–∏ —á—Ç–æ-—Ç–æ –ø–æ–π–¥—ë—Ç –Ω–µ —Ç–∞–∫, –ø–æ—ç—Ç–æ–º—É –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ <code>expect</code> –¥–æ–ø—É—Å—Ç–∏–º–æ. –ë–æ–ª—å—à–µ –æ–± –æ–±—Ä–∞–±–æ—Ç–∫–µ –æ—à–∏–±–æ–∫ –≤—ã —É–∑–Ω–∞–µ—Ç–µ –≤ [–ì–ª–∞–≤–µ 9] (ch09-02-recoverable-errors-with-result.html)<!-- ignore -->.</p>
<h3 id="–ü–µ—á–∞—Ç—å-–∑–Ω–∞—á–µ–Ω–∏–π-–ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö-—Å-–ø–æ–º–æ—â—å—é-–º–µ—Ç–æ–∫-–ø–æ–¥—Å—Ç–∞–Ω–æ–≤–∫–∏-println"><a class="header" href="#–ü–µ—á–∞—Ç—å-–∑–Ω–∞—á–µ–Ω–∏–π-–ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö-—Å-–ø–æ–º–æ—â—å—é-–º–µ—Ç–æ–∫-–ø–æ–¥—Å—Ç–∞–Ω–æ–≤–∫–∏-println">–ü–µ—á–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–π –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö —Å –ø–æ–º–æ—â—å—é –º–µ—Ç–æ–∫ –ø–æ–¥—Å—Ç–∞–Ω–æ–≤–∫–∏ <code>println!</code></a></h3>
<p>–ù–µ —Å—á–∏—Ç–∞—è –∑–∞–∫—Ä—ã–≤–∞—é—â–µ–π —Ñ–∏–≥—É—Ä–Ω–æ–π —Å–∫–æ–±–∫–∏, –Ω–∞–º –ø–æ–∫–∞ —á—Ç–æ –æ—Å—Ç–∞–ª–æ—Å—å –æ–±—Å—É–¥–∏—Ç—å –ª–∏—à—å –æ–¥–Ω—É —Å—Ç—Ä–æ—á–∫—É:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("–£–≥–∞–¥–∞–π—Ç–µ —á–∏—Å–ª–æ!");
</span><span class="boring">
</span><span class="boring">    println!("–í–≤–µ–¥–∏—Ç–µ —Å–≤–æ—é –¥–æ–≥–∞–¥–∫—É.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–µ—Å—Ç—å –≤–≤–æ–¥.");
</span><span class="boring">
</span>    println!("–í—ã –ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏–ª–∏: {}", guess);
<span class="boring">}</span></code></pre>
<p>–≠—Ç–∞ —Å—Ç—Ä–æ—á–∫–∞ –ø–µ—á–∞—Ç–∞–µ—Ç —Å—Ç—Ä–æ–∫—É, —Å–æ–¥–µ—Ä–∂–∞—â—É—é –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π –≤–≤–æ–¥. –ü–∞—Ä–∞ —Ñ–∏–≥—É—Ä–Ω—ã—Ö —Å–∫–æ–±–æ–∫ <code>{}</code> ‚Äî —ç—Ç–æ –º–µ—Ç–∫–∞ –ø–æ–¥—Å—Ç–∞–Ω–æ–≤–∫–∏. –ü—Ä–µ–¥—Å—Ç–∞–≤—å—Ç–µ, —á—Ç–æ <code>{}</code> ‚Äî —ç—Ç–æ –∫–ª–µ—à–Ω–∏ –∫—Ä–∞–±–∏–∫–∞, –¥–µ—Ä–∂–∞—â–µ–≥–æ –º–µ–∂–¥—É –Ω–∏–º–∏ –∑–Ω–∞—á–µ–Ω–∏–µ. –ï—Å–ª–∏ –≤–∞–º –Ω—É–∂–Ω–æ –Ω–∞–ø–µ—á–∞—Ç–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ, —Å–æ–¥–µ—Ä–∂–∞—â–µ–µ—Å—è –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π, –≤—ã –º–æ–∂–µ—Ç–µ –∑–∞–∫–ª—é—á–∏—Ç—å –µ–≥–æ —Å—Ä–∞–∑—É –≤ —Ñ–∏–≥—É—Ä–Ω—ã–µ —Å–∫–æ–±–∫–∏. –ï—Å–ª–∏ –∂–µ –Ω—É–∂–Ω–æ –Ω–∞–ø–µ—á–∞—Ç–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è –∫–∞–∫–∏—Ö-—Ç–æ –≤—ã—Ä–∞–∂–µ–Ω–∏–π –∏ –≤—ã –Ω–µ —Ö–æ—Ç–∏—Ç–µ –∑–∞–ø–∏—Å—ã–≤–∞—Ç—å –∏—Ö –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ, —Ç–æ –≤—ã –º–æ–∂–µ—Ç–µ —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é –ø–µ—Ä–µ—á–∏—Å–ª–∏—Ç—å –≤—ã—Ä–∞–∂–µ–Ω–∏—è –ø–æ—Å–ª–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–π —Å—Ç—Ä–æ–∫–∏ ‚Äî –æ–Ω–∏ –±—É–¥—É—Ç –ø–æ–¥—Å—Ç–∞–≤–ª–µ–Ω—ã –≤ –º–µ—Ç–∫–∏ –ø–æ–¥—Å—Ç–∞–Ω–æ–≤–∫–∏ –≤ —Ç–æ–º –∂–µ –ø–æ—Ä—è–¥–∫–µ, –≤ –∫–∞–∫–æ–º –≤—ã –∏—Ö –ø–µ—Ä–µ—á–∏—Å–ª–∏–ª–∏. –í–æ—Ç —Ç–∞–∫ –±—É–¥–µ—Ç –≤—ã–≥–ª—è–¥–µ—Ç—å –≤—ã–≤–æ–¥ –∑–Ω–∞—á–µ–Ω–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –∏ –≤—ã—Ä–∞–∂–µ–Ω–∏—è –æ–¥–Ω–∏–º –≤—ã–∑–æ–≤–æ–º <code>println!</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = 10;

println!("x = {x} –∏ y + 2 = {}", y + 2);
<span class="boring">}</span></code></pre></pre>
<p>–≠—Ç–æ—Ç –∫–æ–¥ –Ω–∞–ø–µ—á–∞—Ç–∞–µ—Ç <code>x = 5 –∏ y + 2 = 12</code>.</p>
<h3 id="–ü—Ä–æ–≤–µ—Ä—è–µ–º-–ø–µ—Ä–≤—É—é-—á–∞—Å—Ç—å"><a class="header" href="#–ü—Ä–æ–≤–µ—Ä—è–µ–º-–ø–µ—Ä–≤—É—é-—á–∞—Å—Ç—å">–ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–≤—É—é —á–∞—Å—Ç—å</a></h3>
<p>–ü—Ä–æ–≤–µ—Ä–∏–º –ø–µ—Ä–≤—É—é —á–∞—Å—Ç—å –∏–≥—Ä—ã –≤ —É–≥–∞–¥–∞–π–∫—É. –ó–∞–ø—É—Å—Ç–∏–º –µ—ë, –∏—Å–ø–æ–ª—å–∑—É—è <code>cargo run</code>:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-01/
cargo clean
cargo run
input 6 -->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
–£–≥–∞–¥–∞–π—Ç–µ —á–∏—Å–ª–æ!
–í–≤–µ–¥–∏—Ç–µ —Å–≤–æ—é –¥–æ–≥–∞–¥–∫—É.
6
–í—ã –ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏–ª–∏: 6
</code></pre>
<p>–ü–µ—Ä–≤–∞—è —á–∞—Å—Ç—å –ø—Ä–æ–≥—Ä–∞–º–º—ã –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –∏ —Ä–∞–±–æ—Ç–∞–µ—Ç, –∫–∞–∫ –∑–∞–¥—É–º–∞–Ω–æ: –º—ã –ø—Ä–∏–Ω–∏–º–∞–µ–º –≤–≤–æ–¥ —Å –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã –∏ –∑–∞—Ç–µ–º –ø–µ—á–∞—Ç–∞–µ–º –µ–≥–æ.</p>
<h2 id="–ì–µ–Ω–µ—Ä–∞—Ü–∏—è-—Å–µ–∫—Ä–µ—Ç–Ω–æ–≥–æ-—á–∏—Å–ª–∞"><a class="header" href="#–ì–µ–Ω–µ—Ä–∞—Ü–∏—è-—Å–µ–∫—Ä–µ—Ç–Ω–æ–≥–æ-—á–∏—Å–ª–∞">–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–µ–∫—Ä–µ—Ç–Ω–æ–≥–æ —á–∏—Å–ª–∞</a></h2>
<p>–î–∞–ª–µ–µ! –ù–∞–º –Ω—É–∂–Ω–æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Å–µ–∫—Ä–µ—Ç–Ω–æ–µ —á–∏—Å–ª–æ, –∫–æ—Ç–æ—Ä–æ–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∏ –±—É–¥–µ—Ç –ø—ã—Ç–∞—Ç—å—Å—è —É–≥–∞–¥–∞—Ç—å. –°–µ–∫—Ä–µ—Ç–Ω–æ–µ —á–∏—Å–ª–æ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å —Ä–∞–∑–Ω—ã–º –æ—Ç –∏–≥—Ä—ã –∫ –∏–≥—Ä–µ, —á—Ç–æ–±—ã –≤ –Ω–µ—ë –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –º–æ–∂–Ω–æ –±—ã–ª–æ –∏–≥—Ä–∞—Ç—å. –ú—ã –±—É–¥–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å–ª—É—á–∞–π–Ω–æ–µ —á–∏—Å–ª–æ –æ—Ç 1 –¥–æ 100, —Ç–∞–∫ —á—Ç–æ –∏–≥—Ä–∞ –Ω–µ –±—É–¥–µ—Ç —Å–∏–ª—å–Ω–æ —Å–ª–æ–∂–Ω–æ–π. –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª —Ä–∞–±–æ—Ç—ã —Å–æ —Å–ª—É—á–∞–π–Ω—ã–º–∏ —á–∏—Å–ª–∞–º–∏ –≤—Å—ë –µ—â—ë –Ω–µ –≤—Ö–æ–¥–∏—Ç –≤ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—É—é –±–∏–±–ª–∏–æ—Ç–µ–∫—É Rust, –æ–¥–Ω–∞–∫–æ –ö–æ–º–∞–Ω–¥–∞ Rust –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç <a href="https://crates.io/crates/rand">–∫—Ä–µ–π—Ç <code>rand</code></a>, —Ä–µ–∞–ª–∏–∑—É—é—â–∏–π –≤—Å—ë –Ω—É–∂–Ω–æ–µ.</p>
<h3 id="–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ-–∫—Ä–µ–π—Ç–æ–≤-–¥–ª—è-—Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è-–≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π"><a class="header" href="#–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ-–∫—Ä–µ–π—Ç–æ–≤-–¥–ª—è-—Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è-–≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π">–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∫—Ä–µ–π—Ç–æ–≤ –¥–ª—è —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π</a></h3>
<p>–ü–æ–º–Ω–∏—Ç–µ, —á—Ç–æ –∫—Ä–µ–π—Ç ‚Äî —ç—Ç–æ –Ω–∞–±–æ—Ä –∏—Å—Ö–æ–¥–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤ –∫–æ–¥–∞ –Ω–∞ —è–∑—ã–∫–µ Rust. –ü—Ä–æ–µ–∫—Ç, –∫–æ—Ç–æ—Ä—ã–π –º—ã —Å–µ–π—á–∞—Å –¥–µ–ª–∞–µ–º, ‚Äî —ç—Ç–æ <em>–±–∏–Ω–∞—Ä–Ω—ã–π (binary) –∫—Ä–µ–π—Ç</em>, —Ç–æ –µ—Å—Ç—å —Å–æ–±–∏—Ä–∞–µ–º—ã–π –≤ –∏—Å–ø–æ–ª–Ω—è–µ–º—É—é –ø—Ä–æ–≥—Ä–∞–º–º—É. –ö—Ä–µ–π—Ç <code>rand</code> ‚Äî —ç—Ç–æ <em>–±–∏–±–ª–∏–æ—Ç–µ—á–Ω—ã–π (library) –∫—Ä–µ–π—Ç</em>, —Ç–æ –µ—Å—Ç—å —Å–æ–¥–µ—Ä–∂–∞—â–∏–π –∫–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –≤—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç—Å—è –≤ –¥—Ä—É–≥–∏–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã –∏ —Å–∞–º –ø–æ —Å–µ–±–µ –Ω–µ –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è.</p>
<p>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≤–Ω–µ—à–Ω–∏–º–∏ –∫—Ä–µ–π—Ç–∞–º–∏ ‚Äî —ç—Ç–æ –∫–æ–Ω—ë–∫ Cargo. –ß—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫—Ä–µ–π—Ç <code>rand</code>, –Ω–∞–º –Ω—É–∂–Ω–æ –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —Ñ–∞–π–ª <em>Cargo.toml</em>, —á—Ç–æ–±—ã –≤–∫–ª—é—á–∏—Ç—å —ç—Ç–æ—Ç –∫—Ä–µ–π—Ç –∫–∞–∫ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å. –û—Ç–∫—Ä–æ–π—Ç–µ —ç—Ç–æ—Ç —Ñ–∞–π–ª –∏ –¥–æ–±–∞–≤—å—Ç–µ —Å—Ç—Ä–æ—á–∫–∏ –Ω–∏–∂–µ –≤ –µ–≥–æ –∫–æ–Ω–µ—Ü (—Ç–æ –µ—Å—Ç—å –ø–æ–¥ <code>[dependencies]</code> ‚Äî –∑–∞–≥–æ–ª–æ–≤–∫–æ–º —Ä–∞–∑–¥–µ–ª–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π). –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –≤—ã –ø–æ–¥–∫–ª—é—á–∏–ª–∏ –≤–µ—Ä—Å–∏—é <code>rand</code> —Ä–æ–≤–Ω–æ —Ç–∞–∫—É—é –∂–µ, —á—Ç–æ –∏ –º—ã, –∏–Ω–∞—á–µ –Ω–∞—à–∏ –ø—Ä–∏–º–µ—Ä—ã –º–æ–≥—É—Ç –Ω–µ –∑–∞—Ä–∞–±–æ—Ç–∞—Ç—å —É –≤–∞—Å.</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
* ch14-03-cargo-workspaces.md
-->
<p><span class="filename">–§–∞–π–ª: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = "0.8.5"
</code></pre>
<p>–ö —Ä–∞–∑–¥–µ–ª–∞–º –≤ —Ñ–∞–π–ª–µ <em>Cargo.toml</em> –æ—Ç–Ω–æ—Å–∏—Ç—Å—è –≤—Å—ë, —á—Ç–æ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –º–µ–∂–¥—É –∑–∞–≥–æ–ª–æ–≤–∫–æ–º —Ä–∞–∑–¥–µ–ª–∞ –∏ –∑–∞–≥–æ–ª–æ–≤–∫–æ–º —Å–ª–µ–¥—É—é—â–µ–≥–æ —Ä–∞–∑–¥–µ–ª–∞. –í <code>[dependencies]</code> –≤—ã —É–∫–∞–∑—ã–≤–∞–µ—Ç–µ, –∫–∞–∫–∏–µ –≤–Ω–µ—à–Ω–∏–µ –∫—Ä–µ–π—Ç—ã –∫–∞–∫–∏—Ö –≤–µ—Ä—Å–∏–π —Ç—Ä–µ–±—É–µ—Ç –≤–∞—à –ø—Ä–æ–µ–∫—Ç. –í –¥–∞–Ω–Ω–æ–º —Å–ª—É—á–∞–µ, –º—ã –∫–æ–Ω–∫—Ä–µ—Ç–∏–∑–∏—Ä—É–µ–º –≤–µ—Ä—Å–∏—é –∫—Ä–µ–π—Ç–∞ <code>rand</code> —Å –ø–æ–º–æ—â—å—é —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞ <code>0.8.5</code>. Cargo –æ–ø–∏—Ä–∞–µ—Ç—Å—è –Ω–∞ <a href="http://semver.org/lang/ru">–°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–æ–µ –≤–µ—Ä—Å–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ (Semantic Versioning, <em>SemVer</em>)</a><!-- ignore --> ‚Äî —Å–∏—Å—Ç–µ–º—É –∑–∞–ø–∏—Å–∏ –≤–µ—Ä—Å–∏–π –ø—Ä–æ–≥—Ä–∞–º–º. –°–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ç–æ—Ä –≤–µ—Ä—Å–∏–∏ <code>0.8.5</code> –Ω–∞ —Å–∞–º–æ–º –¥–µ–ª–µ —è–≤–ª—è–µ—Ç—Å—è —Å–æ–∫—Ä–∞—â–µ–Ω–∏–µ–º –¥–ª—è <code>^0.8.5</code>, –æ–∑–Ω–∞—á–∞—é—â–µ–≥–æ –ª—é–±—É—é –≤–µ—Ä—Å–∏—é –ø—Ä–æ–≥—Ä–∞–º–º—ã –Ω–µ –±–æ–ª–µ–µ —Ä–∞–Ω–Ω—é—é, —á–µ–º 0.8.5, –Ω–æ –Ω–µ –±–æ–ª–µ–µ –Ω–æ–≤—É—é, —á–µ–º 0.9.0.</p>
<p>Cargo —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç, —á—Ç–æ –≤–µ—Ä—Å–∏–∏, –≤—Ö–æ–¥—è—â–∏–µ –≤ –¥–∞–Ω–Ω—ã–π –ø—Ä–æ–º–µ–∂—É—Ç–æ–∫, –∏–º–µ—é—Ç API, —Å–æ–≤–º–µ—Å—Ç–∏–º—ã–π —Å API –∫—Ä–µ–π—Ç–∞ –≤–µ—Ä—Å–∏–∏ 0.8.5. –≠—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç –ø–æ–¥–∫–ª—é—á–∞—Ç—å –±–æ–ª–µ–µ –Ω–æ–≤—ã–µ –≤–µ—Ä—Å–∏–∏ –∫—Ä–µ–π—Ç–∞, –∏ –ø—Ä–∏ —ç—Ç–æ–º –¥–∞—ë—Ç –≥–∞—Ä–∞–Ω—Ç–∏—é, —á—Ç–æ –ø—Ä–∏–≤–µ–¥—ë–Ω–Ω—ã–µ –≤ —ç—Ç–æ–π –≥–ª–∞–≤–µ –ø—Ä–∏–º–µ—Ä—ã –±—É–¥—É—Ç –∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞—Ç—å—Å—è. –õ—é–±–∞—è –≤–µ—Ä—Å–∏—è –æ—Ç 0.9.0 –∏ –≤—ã—à–µ –Ω–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –±—É–¥–µ—Ç –∏–º–µ—Ç—å —Ç–∞–∫–æ–π –∂–µ API, –∫–∞–∫ –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–π –≤ –ø—Ä–∏–º–µ—Ä–∞—Ö –¥–∞–ª–µ–µ.</p>
<p>–¢–µ–ø–µ—Ä—å, –Ω–∏—á–µ–≥–æ –Ω–µ –º–µ–Ω—è—è –≤ –ø—Ä–æ–≥—Ä–∞–º–º–µ, –¥–∞–≤–∞–π—Ç–µ —Å–æ–±–µ—Ä—ë–º –ø—Ä–æ–µ–∫—Ç, –∫–∞–∫ –ø–æ–∫–∞–∑–∞–Ω–æ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 2-2.</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
rm Cargo.lock
cargo clean
cargo build -->
<Listing number="2-2" caption="The output from running `cargo build` after adding the rand crate as a dependency">
<pre><code class="language-console">$ cargo build
    Updating crates.io index
     Locking 16 packages to latest compatible versions
      Adding wasi v0.11.0+wasi-snapshot-preview1 (latest: v0.13.3+wasi-0.2.2)
      Adding zerocopy v0.7.35 (latest: v0.8.9)
      Adding zerocopy-derive v0.7.35 (latest: v0.8.9)
  Downloaded syn v2.0.87
  Downloaded 1 crate (278.1 KB) in 0.16s
   Compiling proc-macro2 v1.0.89
   Compiling unicode-ident v1.0.13
   Compiling libc v0.2.161
   Compiling cfg-if v1.0.0
   Compiling byteorder v1.5.0
   Compiling getrandom v0.2.15
   Compiling rand_core v0.6.4
   Compiling quote v1.0.37
   Compiling syn v2.0.87
   Compiling zerocopy-derive v0.7.35
   Compiling zerocopy v0.7.35
   Compiling ppv-lite86 v0.2.20
   Compiling rand_chacha v0.3.1
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 3.69s
</code></pre>
</Listing>
<p>–ï—Å–ª–∏ –≤—ã –ø—Ä–æ–¥–µ–ª–∞–µ—Ç–µ –≤—Å—ë –Ω–∞ —Å–≤–æ–µ–π –º–∞—à–∏–Ω–µ, –≤—ã –º–æ–∂–µ—Ç–µ —É–≤–∏–¥–µ—Ç—å –¥—Ä—É–≥–∏–µ (–Ω–æ –≤—Å—ë –µ—â—ë –æ–±—Ä–∞—Ç–Ω–æ —Å–æ–≤–º–µ—Å—Ç–∏–º—ã–µ; —Å–ø–∞—Å–∏–±–æ SemVer!) –≤–µ—Ä—Å–∏–∏ –∫—Ä–µ–π—Ç–æ–≤ –∏ –¥—Ä—É–≥–∏–µ –ø–µ—á–∞—Ç–∞–µ–º—ã–µ —Å—Ç—Ä–æ—á–∫–∏ (–≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –≤–∞—à–µ–π –æ–ø–µ—Ä–∞—Ü–∏–æ–Ω–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã), –∏ –æ–Ω–∏ –º–æ–≥—É—Ç –±—ã—Ç—å —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω—ã –≤ –¥—Ä—É–≥–æ–º –ø–æ—Ä—è–¥–∫–µ.</p>
<p>–ö–æ–≥–¥–∞ –º—ã –ø–æ–¥–∫–ª—é—á–∞–µ–º –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å, Cargo —Å–æ–±–∏—Ä–∞–µ—Ç –≤—Å—ë, —á—Ç–æ –æ–Ω–∞ —Å–∞–º–∞ —Ç—Ä–µ–±—É–µ—Ç, –∏—Å–ø–æ–ª—å–∑—É—è <em>—Ä–µ–µ—Å—Ç—Ä</em> (<em>registry</em>), –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—â–∏–π —Å–æ–±–æ–π –∫–æ–ø–∏—é –¥–∞–Ω–Ω—ã—Ö —Å —Å–∞–π—Ç–∞ <a href="https://crates.io/">Crates.io</a>. Crates.io ‚Äî —ç—Ç–æ —á–∞—Å—Ç—å —ç–∫–æ—Å–∏—Å—Ç–µ–º—ã Rust, –º–µ—Å—Ç–æ –¥–ª—è –ø—É–±–ª–∏–∫–∞—Ü–∏–∏ –ø—Ä–æ–µ–∫—Ç–æ–≤ —Å –æ—Ç–∫—Ä—ã—Ç—ã–º –∏—Å—Ö–æ–¥–Ω—ã–º –∫–æ–¥–æ–º, –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–∞–∂–¥–æ–º—É.</p>
<p>–ü–æ—Å–ª–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ä–µ–µ—Å—Ç—Ä–∞, Cargo –ø—Ä–æ–≤–µ—Ä—è–µ—Ç —Ä–∞–∑–¥–µ–ª <code>[dependencies]</code> –∏ —Å–∫–∞—á–∏–≤–∞–µ—Ç –≤—Å–µ –∫—Ä–µ–π—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –µ—â—ë –Ω–µ —Å–∫–∞—á–∞–Ω—ã. –í –Ω–∞—à–µ–º —Å–ª—É—á–∞–µ, –º—ã –ø–æ–¥–∫–ª—é—á–∞–µ–º –∫–∞–∫ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å –ª–∏—à—å –∫—Ä–µ–π—Ç <code>rand</code>, –æ–¥–Ω–∞–∫–æ Cargo —Ç–∞–∫–∂–µ –∑–∞–≥—Ä—É–∂–∞–µ—Ç –≤—Å—ë, —á—Ç–æ —Ç—Ä–µ–±—É–µ—Ç—Å—è —É–∂–µ —Å–∞–º–æ–º—É –∫—Ä–µ–π—Ç—É <code>rand</code>. –ü–æ—Å–ª–µ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è –∫—Ä–µ–π—Ç–æ–≤, Rust –∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç –∏—Ö, –∞ –∑–∞—Ç–µ–º –∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç –∏ –ø—Ä–æ–µ–∫—Ç.</p>
<p>–ï—Å–ª–∏ –≤—ã —Å—Ä–∞–∑—É –∂–µ –≤–Ω–æ–≤—å –∑–∞–ø—É—Å—Ç–∏—Ç–µ <code>cargo build</code>, –Ω–∏—á–µ–≥–æ –Ω–µ –∏–∑–º–µ–Ω–∏–≤ –≤ –ø—Ä–æ–µ–∫—Ç–µ, –≤—ã –Ω–µ —É–≤–∏–¥–∏—Ç–µ –Ω–∏—á–µ–≥–æ, –∫—Ä–æ–º–µ —Å—Ç—Ä–æ–∫–∏ <code>Finished</code>. Cargo –≤–∏–¥–∏—Ç, —á—Ç–æ –≤—ã –Ω–∏—á–µ–≥–æ –Ω–µ –ø–æ–º–µ–Ω—è–ª–∏ –≤ —Ñ–∞–π–ª–µ <em>Cargo.toml</em>, –∏ –æ–Ω –ø–æ–º–Ω–∏—Ç, —á—Ç–æ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ —É–∂–µ –±—ã–ª–∏ —Å–∫–∞—á–∞–Ω—ã –∏ —Å–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞–Ω—ã. Cargo —Ç–∞–∫–∂–µ –≤–∏–¥–∏—Ç, —á—Ç–æ –≤—ã –Ω–∏—á–µ–≥–æ –Ω–µ –ø–æ–º–µ–Ω—è–ª–∏ –∏ –≤ –∏—Å—Ö–æ–¥–Ω–æ–º –∫–æ–¥–µ, —Ç–∞–∫ —á—Ç–æ –æ–Ω —Å–æ–≤–µ—Ä—à–µ–Ω–Ω–æ –Ω–∏—á–µ–≥–æ –Ω–µ –ø–µ—Ä–µ–∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç. –ü–æ—Å–∫–æ–ª—å–∫—É –¥–µ–ª–∞—Ç—å –µ–º—É –±–æ–ª—å—à–µ –∏ –Ω–µ—á–µ–≥–æ, –æ–Ω –ø—Ä–æ—Å—Ç–æ —Å–æ–æ–±—â–∞–µ—Ç –æ–± —É—Å–ø–µ—à–Ω–æ–π —Å–±–æ—Ä–∫–µ.</p>
<p>–ï—Å–ª–∏ –≤—ã –æ—Ç–∫—Ä–æ–µ—Ç–µ —Ñ–∞–π–ª <em>src/main.rs</em> –∏ –≤–Ω–µ—Å—ë—Ç–µ –∫–∞–∫–∏–µ-–Ω–∏–±—É–¥—å –∏–∑–º–µ–Ω–µ–Ω–∏—è, —Å–æ—Ö—Ä–∞–Ω–∏—Ç–µ –∏—Ö –∏ –µ—â—ë —Ä–∞–∑ –∑–∞–ø—É—Å–∏—Ç–∏—Ç–µ —Å–±–æ—Ä–∫—É, –≤—ã —É–≤–∏–¥–∏—Ç–µ –ª–∏—à—å –¥–≤–µ —Å—Ç—Ä–æ—á–∫–∏ –≤—ã–≤–æ–¥–∞:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
touch src/main.rs
cargo build -->
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s
</code></pre>
<p>–≠—Ç–∏ —Å—Ç—Ä–æ—á–∫–∏ –ø–æ–∫–∞–∑—ã–≤–∞—é—Ç, —á—Ç–æ Cargo –ø–µ—Ä–µ—Å–æ–±—Ä–∞–ª –ª–∏—à—å –≤–∞—à –∫–æ–¥, –ø–æ—Å–∫–æ–ª—å–∫—É —É–≤–∏–¥–µ–ª –Ω–µ–±–æ–ª—å—à–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ –≤ —Ñ–∞–π–ª–µ <em>src/main.rs</em>. –í–∞—à–∏ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –Ω–µ –ø–æ–º–µ–Ω—è–ª–∏—Å—å, –ø–æ—ç—Ç–æ–º—É Cargo –Ω–µ —Å—Ç–∞–ª –∏—Ö –µ—â—ë —Ä–∞–∑ –∑–∞–≥—Ä—É–∂–∞—Ç—å –∏ –∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞—Ç—å.</p>
<h4 id="–û–±–µ—Å–ø–µ—á–µ–Ω–∏–µ-–≤–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º–æ—Å—Ç–∏-—Å–±–æ—Ä–æ–∫-—Å-–ø–æ–º–æ—â—å—é-—Ñ–∞–π–ª–∞-cargolock"><a class="header" href="#–û–±–µ—Å–ø–µ—á–µ–Ω–∏–µ-–≤–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º–æ—Å—Ç–∏-—Å–±–æ—Ä–æ–∫-—Å-–ø–æ–º–æ—â—å—é-—Ñ–∞–π–ª–∞-cargolock">–û–±–µ—Å–ø–µ—á–µ–Ω–∏–µ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º–æ—Å—Ç–∏ —Å–±–æ—Ä–æ–∫ —Å –ø–æ–º–æ—â—å—é —Ñ–∞–π–ª–∞ <em>Cargo.lock</em></a></h4>
<p>–í Cargo –µ—Å—Ç—å –º–µ—Ö–∞–Ω–∏–∑–º, –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É—é—â–∏–π –∫–∞–∂–¥–æ–º—É (–≤ —Ç–æ–º —á–∏—Å–ª–µ, –∏ –≤–∞–º) –ø–µ—Ä–µ—Å–æ–±—Ä–∞—Ç—å –≤–∞—à –ø—Ä–æ–µ–∫—Ç —Å –≤ —Ç–æ—á–Ω–æ—Å—Ç–∏ –æ–¥–∏–Ω–∞–∫–æ–≤—ã–º–∏ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—è–º–∏: Cargo –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ —Ç–µ –≤–µ—Ä—Å–∏–∏ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π, –∫–æ—Ç–æ—Ä—ã–µ –≤—ã –æ–ø—Ä–µ–¥–µ–ª–∏–ª–∏, –ø–æ–∫–∞ –Ω–µ —É–∫–∞–∂–µ—Ç–µ –æ–±—Ä–∞—Ç–Ω–æ–µ. –ù–∞–ø—Ä–∏–º–µ—Ä, –¥–æ–ø—É—Å—Ç–∏–º, —á—Ç–æ –Ω–∞ —Å–ª–µ–¥—É—é—â–µ–π –Ω–µ–¥–µ–ª–µ –≤—ã—Ö–æ–¥–∏—Ç –≤–µ—Ä—Å–∏—è 0.8.6 –∫—Ä–µ–π—Ç–∞ <code>rand</code>, –∏ —ç—Ç–∞ –≤–µ—Ä—Å–∏—è —Å–æ–¥–µ—Ä–∂–∏—Ç –≤–∞–∂–Ω—ã–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è –æ—à–∏–±–æ–∫, –Ω–æ —Ç–∞–∫–∂–µ –≤–∫–ª—é—á–∞–µ—Ç –ø—Ä–µ–∫—Ä–∞—â–µ–Ω–∏–µ –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –Ω–µ–∫–æ—Ç–æ—Ä–æ–π —á–∞—Å—Ç–∏ API, –∫–æ—Ç–æ—Ä—É—é –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ –≤—ã. –ß—Ç–æ–±—ã –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å —Ç–∞–∫–æ–π —Å–ª—É—á–∞–π, Rust —Å–æ–∑–¥–∞–µ—Ç —Ñ–∞–π–ª <em>Cargo.lock</em> –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –∑–∞–ø—É—Å–∫–µ <code>cargo build</code>; –º—ã —Ç–æ–∂–µ —É–∂–µ –∏–º–µ–µ–º —Ç–∞–∫–æ–π —Ñ–∞–π–ª –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ <em>guessing_game</em>.</p>
<p>–ö–æ–≥–¥–∞ –≤—ã –≤–ø–µ—Ä–≤—ã–µ —Å–æ–±–∏—Ä–∞–µ—Ç–µ –ø—Ä–æ–µ–∫—Ç, Cargo –≤—ã—è—Å–Ω—è–µ—Ç –≤—Å—ë –æ –≤–µ—Ä—Å–∏—è—Ö –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π, –∫–æ—Ç–æ—Ä—ã–µ —É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä—è—é—Ç —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º, –∏ –∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –Ω–∏—Ö –≤ —Ñ–∞–π–ª <em>Cargo.lock</em>. –ö–æ–≥–¥–∞ –≤—ã –µ—â—ë —Ä–∞–∑ —Å–æ–±–µ—Ä—ë—Ç–µ –ø—Ä–æ–µ–∫—Ç, Cargo —É–≤–∏–¥–∏—Ç, —á—Ç–æ —Ñ–∞–π–ª <em>Cargo.lock</em> —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –∏ –≤–æ—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —É–∫–∞–∑–∞–Ω–Ω—ã–º–∏ –≤ –Ω—ë–º –≤–µ—Ä—Å–∏—è–º–∏. –≠—Ç–æ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –¥–µ–ª–∞–µ—Ç –≤–∞—à –∫–æ–¥ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º—ã–º. –ò–Ω—ã–º–∏ —Å–ª–æ–≤–∞–º–∏, –≤–∞—à –ø—Ä–æ–µ–∫—Ç –ø—Ä–æ–¥–æ–ª–∂–∏—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤–µ—Ä—Å–∏—é 0.8.5 –¥–æ —Ç–µ—Ö –ø–æ—Ä, –ø–æ–∫–∞ –≤—ã –Ω–µ –æ–±–Ω–æ–≤–∏—Ç–µ—Å—å —è–≤–Ω–æ ‚Äî –∏ –≤—Å—ë –±–ª–∞–≥–æ–¥–∞—Ä—è —Ñ–∞–π–ª—É <em>Cargo.lock</em>. –ü–æ—Å–∫–æ–ª—å–∫—É —Ñ–∞–π–ª <em>Cargo.lock</em> –≤–∞–∂–µ–Ω –¥–ª—è –æ–±–µ—Å–ø–µ—á–µ–Ω–∏—è –≤–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º–æ—Å—Ç–∏ —Å–±–æ—Ä–æ–∫, –æ–Ω —á–∞—Å—Ç–æ –≤–∫–ª—é—á–∞–µ—Ç—Å—è –≤ —Å–∏—Å—Ç–µ–º—É —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤–µ—Ä—Å–∏—è–º–∏ –≤–º–µ—Å—Ç–µ —Å –æ—Å—Ç–∞–ª—å–Ω—ã–º –∫–æ–¥–æ–º –≤–∞—à–µ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞.</p>
<h4 id="–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ-–∫—Ä–µ–π—Ç–∞-–¥–æ-–Ω–æ–≤–µ–π—à–µ–π-–≤–µ—Ä—Å–∏–∏"><a class="header" href="#–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ-–∫—Ä–µ–π—Ç–∞-–¥–æ-–Ω–æ–≤–µ–π—à–µ–π-–≤–µ—Ä—Å–∏–∏">–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫—Ä–µ–π—Ç–∞ –¥–æ –Ω–æ–≤–µ–π—à–µ–π –≤–µ—Ä—Å–∏–∏</a></h4>
<p>–ö–æ–≥–¥–∞ –≤—ã <em>–∑–∞—Ö–æ—Ç–∏—Ç–µ</em> –æ–±–Ω–æ–≤–∏—Ç—å –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–π –∫—Ä–µ–π—Ç, –≤—ã –º–æ–∂–µ—Ç–µ –≤–æ—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –∫–æ–º–∞–¥–æ–π Cargo <code>update</code>. –û–Ω–∞, –∏–≥–Ω–æ—Ä–∏—Ä—É—è —Ñ–∞–π–ª <em>Cargo.lock</em>, –∑–∞–Ω–æ–≤–æ –æ—Ç—ã—â–µ—Ç –ø–æ—Å–ª–µ–¥–Ω–∏–µ –≤–µ—Ä—Å–∏–∏, –ø–æ–¥—Ö–æ–¥—è—â–∏–µ –≤–∞—à–∏–º —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏—è–º –≤ <em>Cargo.toml</em>. Cargo –∑–∞—Ç–µ–º –ø–µ—Ä–µ–ø–∏—à–µ—Ç —ç—Ç–∏ –≤–µ—Ä—Å–∏–∏ –≤ —Ñ–∞–π–ª <em>Cargo.lock</em>. –í –Ω–∞—à–µ–º —Å–ª—É—á–∞–µ, Cargo –±—É–¥–µ—Ç –∏—Å–∫–∞—Ç—å —Ç–æ–ª—å–∫–æ —Ç–µ –≤–µ—Ä—Å–∏–∏, —á—Ç–æ –±—É–¥—É—Ç —Å—Ç–∞—Ä—à–µ 0.8.5 –∏ –º–ª–∞–¥—à–µ 0.9.0. –ï—Å–ª–∏ <code>rand</code> –ø–æ–ª—É—á–∏–ª –¥–≤–µ –Ω–æ–≤—ã–µ –≤–µ—Ä—Å–∏–∏ ‚Äî 0.8.6 –∏ 0.9.0, ‚Äî —Ç–æ, –∑–∞–ø—É—Å—Ç–∏–≤ <code>cargo update</code>, –≤—ã —É–≤–∏–¥–∏—Ç–µ –ø–æ–¥–æ–±–Ω—ã–π –≤—ã–≤–æ–¥:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
cargo update
assuming there is a new 0.8.x version of rand; otherwise use another update
as a guide to creating the hypothetical output shown here -->
<pre><code class="language-console">$ cargo update
    Updating crates.io index
    Updating rand v0.8.5 -&gt; v0.8.6
</code></pre>
<p>Cargo –∏–≥–Ω–æ—Ä–∏—Ä—É–µ—Ç —Ä–µ–ª–∏–∑ 0.9.0. –ï—Å–ª–∏ –≤—ã –ø–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –≤ —Ñ–∞–π–ª <em>Cargo.lock</em>, –≤—ã —Ç–∞–∫–∂–µ —É–≤–∏–¥–∏—Ç–µ, —á—Ç–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º–∞—è —Ç–µ–ø–µ—Ä—å –≤–µ—Ä—Å–∏—è –∫—Ä–µ–π—Ç–∞ <code>rand</code> ‚Äî 0.8.6. –ß—Ç–æ–±—ã—Ü –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤–µ—Ä—Å–∏—é 0.9.0 (–∏–ª–∏ –ª—é–±—É—é –¥—Ä—É–≥—É—é –≤–µ—Ä—Å–∏—é 0.9.<em>x</em>), –≤–∞–º –Ω—É–∂–Ω–æ –æ–±–Ω–æ–≤–∏—Ç—å —Ñ–∞–π–ª <em>Cargo.toml</em>, —á—Ç–æ–±—ã –æ–Ω –≤—ã–≥–ª—è–¥–µ–ª –≤–æ—Ç —Ç–∞–∫:</p>
<pre><code class="language-toml">[dependencies]
rand = "0.9.0"
</code></pre>
<p>–í —Å–ª–µ–¥—É—é—â–∏–π —Ä–∞–∑, –∫–æ–≥–¥–∞ –≤—ã –∑–∞–ø—É—Å—Ç–∏—Ç–µ <code>cargo build</code>, Cargo –æ–±–Ω–æ–≤–∏—Ç —Ä–µ–µ—Å—Ç—Ä –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫—Ä–µ–π—Ç–æ–≤ –∏ –æ–±–Ω–æ–≤–∏—Ç –≤–∞—à—É –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å <code>rand</code> —Å–æ–≥–ª–∞—Å–Ω–æ –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–π –≤–∞–º–∏ –Ω–æ–≤–æ–π –≤–µ—Ä—Å–∏–∏.</p>
<p>–ú—ã –æ—Å—Ç–∞–≤–∏–º –ø–æ–¥—Ä–æ–±–Ω–æ—Å—Ç–∏ –æ [Cargo](https://rust-lang-translations.org/ cargo/)<!-- ignore --> –∏ [–µ–≥–æ —ç–∫–æ—Å–∏—Å—Ç–µ–º–µ](https://rust-lang-translations.org/cargo/ reference/publishing.html)<!-- ignore --> –¥–æ –ì–ª–∞–≤—ã 14. Cargo –¥–µ–ª–∞–µ—Ç –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≤–∞—à–µ–≥–æ –∫–æ–¥–∞ –¥—Ä—É–≥–∏–º–∏ –ª—é–¥—å–º–∏ (–∏ –Ω–∞–æ–±–æ—Ä–æ—Ç) –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ –±–æ–ª–µ–µ –ø—Ä–æ—Å—Ç—ã–º, —Ç–∞–∫ —á—Ç–æ —É –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç–æ–≤ –Ω–∞ Rust –µ—Å—Ç—å –æ—Ç–ª–∏—á–Ω–∞—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –ø–∏—Å–∞—Ç—å –Ω–µ–±–æ–ª—å—à–∏–µ –ø—Ä–æ–µ–∫—Ç—ã, —Å–æ–±—Ä–∞–Ω–Ω—ã–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –ø–∞–∫–µ—Ç–æ–≤.</p>
<h3 id="–ì–µ–Ω–µ—Ä–∞—Ü–∏—è-—Å–ª—É—á–∞–π–Ω–æ–≥–æ-—á–∏—Å–ª–∞"><a class="header" href="#–ì–µ–Ω–µ—Ä–∞—Ü–∏—è-—Å–ª—É—á–∞–π–Ω–æ–≥–æ-—á–∏—Å–ª–∞">–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ —á–∏—Å–ª–∞</a></h3>
<p>–ü—Ä–∏–º–µ–Ω–∏–º <code>rand</code> –¥–ª—è –∑–∞–≥–∞–¥—ã–≤–∞–Ω–∏—è —á–∏—Å–ª–∞. –û–±–Ω–æ–≤–∏—Ç–µ —Ñ–∞–π–ª <em>src/main.rs</em>, –ø–æ–º–µ—Å—Ç–∏–≤ –≤ –Ω–µ–≥–æ –∫–æ–¥ –õ–∏—Å—Ç–∏–Ω–≥–∞ 2-3.</p>
<Listing number="2-3" file-name="src/main.rs" caption="Adding code to generate a random number">
<pre><code class="language-rust ignore">use std::io;
use rand::Rng;

fn main() {
    println!("–£–≥–∞–¥–∞–π—Ç–µ —á–∏—Å–ª–æ!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    println!("–ó–∞–≥–∞–¥–∞–Ω–Ω–æ–µ —á–∏—Å–ª–æ: {secret_number}");

    println!("–í–≤–µ–¥–∏—Ç–µ —Å–≤–æ—é –¥–æ–≥–∞–¥–∫—É.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–µ—Å—Ç—å –≤–≤–æ–¥.");

    println!("–í—ã –ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏–ª–∏: {guess}");
}</code></pre>
</Listing>
<p>–í–æ-–ø–µ—Ä–≤—ã—Ö, –º—ã –¥–æ–±–∞–≤–∏–ª–∏ —Å—Ç—Ä–æ—á–∫—É <code>use rand::Rng;</code>. –¢—Ä–µ–π—Ç <code>Rng</code> –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç –º–µ—Ç–æ–¥—ã, —Ä–µ–∞–ª–∏–∑—É–µ–º—ã–µ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–º —Å–ª—É—á–∞–π–Ω—ã—Ö —á–∏—Å–µ–ª, —Ç–∞–∫ —á—Ç–æ —á—Ç–æ–±—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç—Ç–∏ –º–µ—Ç–æ–¥—ã, —ç—Ç–æ—Ç —Ç—Ä–µ–π—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏. –¢—Ä–µ–π—Ç—ã –±—É–¥—É—Ç —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω—ã –≤ –ì–ª–∞–≤–µ 10.</p>
<p>–í–æ-–≤—Ç–æ—Ä—ã—Ö, –º—ã –¥–æ–±–∞–≤–∏–ª–∏ –¥–≤–µ —Å—Ç—Ä–æ—á–∫–∏ –≤ —Å–µ—Ä–µ–¥–∏–Ω–µ. –í –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–æ—á–∫–µ –º—ã –≤—ã–∑—ã–≤–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é <code>rand::thread_rng</code>, –≤–æ–∑–≤—Ä–∞—â–∞—é—â—É—é –Ω–∞–º –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä —Å–ª—É—á–∞–π–Ω—ã—Ö —á–∏—Å–µ–ª (–ª–æ–∫–∞–ª—å–Ω—ã–π –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ –ø–æ—Ç–æ–∫–∞ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è –∏ –∑–∞–ø—É—â–µ–Ω–Ω—ã–π –æ–ø–µ—Ä–∞—Ü–∏–æ–Ω–Ω–æ–π —Å–∏—Å—Ç–µ–º–æ–π). –ó–∞—Ç–µ–º –º—ã –≤—ã–∑—ã–≤–∞–µ–º –º–µ—Ç–æ–¥ <code>gen_range</code> –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞ —Å–ª—É—á–∞–π–Ω—ã—Ö —á–∏—Å–µ–ª. –≠—Ç–æ—Ç –º–µ—Ç–æ–¥ –æ–ø—Ä–µ–¥–µ–ª—ë–Ω —Ç—Ä–µ–π—Ç–æ–º <code>Rng</code>, –∫–æ—Ç–æ—Ä—ã–π –º—ã –¥–æ–±–∞–≤–∏–ª–∏ –≤ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–µ–π <code>use rand::Rng;</code>. –ú–µ—Ç–æ–¥ <code>gen_range</code> –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –≤ –∫–∞—á–µ—Å—Ç–≤–µ –∞—Ä–≥—É–º–µ–Ω—Ç–∞ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ –¥–∏–∞–ø–∞–∑–æ–Ω–∞ –∑–Ω–∞—á–µ–Ω–∏–π –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ª—É—á–∞–π–Ω–æ–µ —á–∏—Å–ª–æ –∏–∑ —ç—Ç–æ–≥–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ –¥–∏–∞–ø–∞–∑–æ–Ω–∞ –∑–Ω–∞—á–µ–Ω–∏–π –∏–º–µ–µ—Ç –≤–∏–¥ <code>start..=end</code>; –æ–Ω–æ –≤–∫–ª—é—á–∞–µ—Ç –≤ —Å–µ–±—è –∫–∞–∫ –Ω–∏–∂–Ω—é—é, —Ç–∞–∫ –∏ –≤–µ—Ä—Ö–Ω—é—é –≥—Ä–∞–Ω–∏—Ü—ã. –í—ã—Ä–∞–∂–µ–Ω–∏–µ <code>1..=100</code> —Ç–µ–º —Å–∞–º—ã–º –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –Ω–∞–º —Ç—Ä–µ–±—É–µ—Ç—Å—è —Å–ª—É—á–∞–π–Ω–æ–µ —á–∏—Å–ª–æ –æ—Ç 1 –¥–æ 100, –≤–∫–ª—é—á–∞—è –∏ 1, –∏ 100.</p>
<blockquote>
<p>–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: –í—ã –ø–æ—á—Ç–∏ –Ω–∞–≤–µ—Ä–Ω—è–∫–∞ –Ω–µ –±—É–¥–µ—Ç–µ –∑–Ω–∞—Ç—å, –∫–∞–∫–∏–µ —Ç—Ä–µ–π—Ç—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏  –∫–∞–∫–∏–µ –º–µ—Ç–æ–¥—ã –∏ —Ñ—É–Ω–∫—Ü–∏–∏ –≤—ã–∑—ã–≤–∞—Ç—å –∏–∑ –∫—Ä–µ–π—Ç–∞. –í —ç—Ç–æ–º —Å–ª—É—á–∞–µ –≤–∞–º –ø–æ–º–æ–∂–µ—Ç –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –∫—Ä–µ–π—Ç–∞. –° –Ω–µ–π —Å–≤—è–∑–∞–Ω–∞ –µ—â—ë –æ–¥–Ω–∞ –ø—Ä–∏—è—Ç–Ω–∞—è –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç—å Cargo: –∫–æ–º–º–∞–Ω–¥–∞ <code>cargo doc --open</code> —Å–æ–±–µ—Ä—ë—Ç –≤—Å—é –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ–º—É—é –≤–∞—à–∏–º–∏ –∫—Ä–µ–π—Ç–∞–º–∏-–∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—è–º–∏, –∏ –æ—Ç–∫—Ä–æ–µ—Ç –µ—ë –∞–≤—Ç–æ–Ω–æ–º–Ω—É—é –∫–æ–ø–∏—é –≤ –±—Ä–∞—É–∑–µ—Ä–µ. –¢–∞–∫, –µ—Å–ª–∏ –≤–∞–º –∏–Ω—Ç–µ—Ä–µ—Å–Ω–∞—è –¥—Ä—É–≥–∞—è —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å –∫—Ä–µ–π—Ç–∞ <code>rand</code>, –≤—ã –º–æ–∂–µ—Ç–µ –Ω–∞–π—Ç–∏ –µ—ë –≤ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏: –≤—ã–ø–æ–ª–Ω–∏—Ç–µ <code>cargo doc --open</code> –∏ –∫–ª–∏–∫–Ω–∏—Ç–µ –ø–æ <code>rand</code> –Ω–∞ –ª–µ–≤–æ–π –ø–∞–Ω–µ–ª–∏.</p>
</blockquote>
<p>–í—Ç–æ—Ä–∞—è –Ω–æ–≤–∞—è —Å—Ç—Ä–æ—á–∫–∞ –ø–µ—á–∞—Ç–∞–µ—Ç —Å–µ–∫—Ä–µ—Ç–Ω–æ–µ —á–∏—Å–ª–æ. –≠—Ç–æ –ø–æ–ª–µ–∑–Ω–æ, –∫–æ–≥–¥–∞ –º—ã —Ä–∞–∑—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø—Ä–æ–≥—Ä–∞–º–º—É, –Ω–æ –º—ã —É–¥–∞–ª–∏–º —ç—Ç–æ –ø–æ–≤–µ–¥–µ–Ω–∏–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã –∏–∑ —Ñ–∏–Ω–∞–ª—å–Ω–æ–π –≤–µ—Ä—Å–∏–∏. –ù–æ –æ—á–µ–Ω—å-—Ç–æ –∏ –∏–≥—Ä–æ–π –±—É–¥–µ—Ç –ø—Ä–æ–≥—Ä–∞–º–º–∞, —Å–æ–æ–±—â–∞—é—â–∞—è –æ—Ç–≤–µ—Ç —Å—Ä–∞–∑—É –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ!</p>
<p>–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∑–∞–ø—É—Å—Ç–∏—Ç—å –ø—Ä–æ–≥—Ä–∞–º–º—É –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ä–∞–∑:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-03/
cargo run
4
cargo run
5
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
–£–≥–∞–¥–∞–π—Ç–µ —á–∏—Å–ª–æ!
–ó–∞–≥–∞–¥–∞–Ω–Ω–æ–µ —á–∏—Å–ª–æ: 7
–í–≤–µ–¥–∏—Ç–µ —Å–≤–æ—é –¥–æ–≥–∞–¥–∫—É.
4
–í—ã –ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏–ª–∏: 4

$ cargo run
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
–£–≥–∞–¥–∞–π—Ç–µ —á–∏—Å–ª–æ!
–ó–∞–≥–∞–¥–∞–Ω–Ω–æ–µ —á–∏—Å–ª–æ: 83
–í–≤–µ–¥–∏—Ç–µ —Å–≤–æ—é –¥–æ–≥–∞–¥–∫—É.
5
–í—ã –ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏–ª–∏: 5
</code></pre>
<p>–í—ã –¥–æ–ª–∂–Ω—ã —É–≤–∏–¥–µ—Ç—å —Ä–∞–∑–Ω—ã–µ —Å–ª—É—á–∞–π–Ω—ã–µ —á–∏—Å–ª–∞, –∏ –æ–Ω–∏ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –æ—Ç 1 –¥–æ 100. –û—Ç–ª–∏—á–Ω–∞—è —Ä–∞–±–æ—Ç–∞!</p>
<h2 id="–°—Ä–∞–≤–Ω–µ–Ω–∏–µ-–¥–æ–≥–∞–¥–∫–∏-—Å-–∑–∞–≥–∞–¥–∞–Ω–Ω—ã–º-—á–∏—Å–ª–æ–º"><a class="header" href="#–°—Ä–∞–≤–Ω–µ–Ω–∏–µ-–¥–æ–≥–∞–¥–∫–∏-—Å-–∑–∞–≥–∞–¥–∞–Ω–Ω—ã–º-—á–∏—Å–ª–æ–º">–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –¥–æ–≥–∞–¥–∫–∏ —Å –∑–∞–≥–∞–¥–∞–Ω–Ω—ã–º —á–∏—Å–ª–æ–º</a></h2>
<p>–¢–µ–ø–µ—Ä—å –º—ã –∏–º–µ–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π –≤–≤–æ–¥ –∏ —Å–ª—É—á–∞–π–Ω–æ–µ —á–∏—Å–ª–æ, –∞ –∑–Ω–∞—á–∏—Ç, –º—ã –º–æ–∂–µ–º –∏—Ö —Å—Ä–∞–≤–Ω–∏—Ç—å. –≠—Ç–æ—Ç —à–∞–≥ –ø–æ–∫–∞–∑–∞–Ω –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 2-4. –û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ —ç—Ç–æ—Ç –∫–æ–¥ –Ω–µ —Å–∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è.</p>
<Listing number="2-4" file-name="src/main.rs" caption="Handling the possible return values of comparing two numbers">
<pre><code class="language-rust ignore does_not_compile">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">    println!("–£–≥–∞–¥–∞–π—Ç–µ —á–∏—Å–ª–æ!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("–ó–∞–≥–∞–¥–∞–Ω–Ω–æ–µ —á–∏—Å–ª–æ: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("–í–≤–µ–¥–∏—Ç–µ —Å–≤–æ—é –¥–æ–≥–∞–¥–∫—É.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–µ—Å—Ç—å –≤–≤–æ–¥.");
</span>
    println!("–í—ã –ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏–ª–∏: {guess}");

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!("–°–ª–∏—à–∫–æ–º –º–∞–ª–µ–Ω—å–∫–æ–µ!"),
        Ordering::Greater =&gt; println!("–°–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–µ!"),
        Ordering::Equal =&gt; println!("–í—ã –ø–æ–±–µ–¥–∏–ª–∏!"),
    }
}</code></pre>
</Listing>
<p>–í–æ-–ø–µ—Ä–≤—ã—Ö, –≤—ã –¥–æ–±–∞–≤–∏–ª–∏ –µ—â—ë –æ–¥–Ω—É –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é —Å <code>use</code>, –ø–æ–¥–∫–ª—é—á–∏–≤ –≤ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ —Ç–∏–ø –∏–∑ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –ø–æ–¥ –Ω–∞–∑–≤–∞–Ω–∏–µ–º <code>std::cmp::Ordering</code>. –¢–∏–ø <code>Ordering</code> ‚Äî —ç—Ç–æ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ, –≤–∞—Ä–∏–∞–Ω—Ç–∞–º–∏ –∫–æ—Ç–æ—Ä–æ–≥–æ —è–≤–ª—è—é—Ç—Å—è <code>Less</code>, <code>Greater</code> –∏ <code>Equal</code>. –û–Ω–∏ –æ—Ç–≤–µ—á–∞—é—Ç –≤—Å–µ–º –≤–æ–∑–º–æ–∂–Ω—ã–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º —Å—Ä–∞–≤–Ω–µ–Ω–∏—è –¥–≤—É—Ö –∑–Ω–∞—á–µ–Ω–∏–π.</p>
<p>–ó–∞—Ç–µ–º, –º—ã –¥–æ–±–∞–≤–∏–ª–∏ –ø—è—Ç—å –Ω–æ–≤—ã—Ö —Å—Ç—Ä–æ—á–µ–∫ –≤ –∫–æ–Ω—Ü–µ, –∏—Å–ø–æ–ª—å–∑—É—é—â–∏—Ö —Ç–∏–ø <code>Ordering</code>. –ú–µ—Ç–æ–¥ <code>cmp</code> —Å—Ä–∞–≤–Ω–∏–≤–∞–µ—Ç –¥–≤–∞ –∑–Ω–∞—á–µ–Ω–∏—è; –æ–Ω –º–æ–∂–µ—Ç –±—ã—Ç—å –≤—ã–∑–≤–∞–Ω –Ω–∞ –≤—Å—ë–º, —á—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å —Å—Ä–∞–≤–Ω–∏–º–æ. –û–Ω –±–µ—Ä—ë—Ç —Å—Å—ã–ª–∫—É –Ω–∞ —Ç–æ, —Å —á–µ–º –≤—ã —Ö–æ—Ç–∏—Ç–µ —Å—Ä–∞–≤–Ω–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ. –í –Ω–∞—à–µ–º —Å–ª—É—á–∞–µ –æ–Ω —Å—Ä–∞–≤–Ω–∏–≤–∞–µ—Ç <code>guess</code> —Å <code>secret_number</code>. –ú–µ—Ç–æ–¥ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤–∞—Ä–∏–∞–Ω—Ç –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è <code>Ordering</code> (–∫–æ—Ç–æ—Ä–æ–µ –º—ã —Ä–∞–Ω–µ–µ –ø–æ–¥–∫–ª—é—á–∏–ª–∏ –≤ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–µ–π —Å <code>use</code>). –ú—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º –≤—ã—Ä–∞–∂–µ–Ω–∏–µ <a href="ch06-02-match.html"><code>match</code></a><!-- ignore --> –¥–ª—è —Ç–æ–≥–æ, —á—Ç–æ–±—ã –≤—ã–±—Ä–∞—Ç—å —á—Ç–æ –¥–µ–ª–∞—Ç—å –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –≤–∞—Ä–∏–∞–Ω—Ç–∞ <code>Ordering</code>, –≤–æ–∑–≤—Ä–∞—â—ë–Ω–Ω–æ–≥–æ –≤—ã–∑–æ–≤–æ–º –º–µ—Ç–æ–¥–∞ <code>cmp</code> –Ω–∞ <code>guess</code> –∏ <code>secret_number</code>.</p>
<p>–í—ã—Ä–∞–∂–µ–Ω–∏–µ <code>match</code> —Å–æ—Å—Ç–æ–∏—Ç –∏–∑ <em>–≤–µ—Ç–≤–µ–π</em>. –ö–∞–∂–¥–∞—è –≤–µ—Ç–≤—å –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å <em>—à–∞–±–ª–æ–Ω–∞</em>, —Å –∫–æ—Ç–æ—Ä—ã–º —Å–æ–ø–æ—Å—Ç–∞–≤–ª—è–µ—Ç—Å—è –ø–µ—Ä–µ–¥–∞–Ω–Ω–æ–µ –≤ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏—é <code>match</code>, –∏ –∑–∞–∫–∞–Ω—á–∏–≤–∞–µ—Ç—Å—è –∫–æ–¥–æ–º, –∫–æ—Ç–æ—Ä—ã–π –∏—Å–ø–æ–ª–Ω–∏—Ç—Å—è, –µ—Å–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ —Å–æ–ø–æ—Å—Ç–∞–≤–∏—Ç—Å—è —Å —à–∞–±–ª–æ–Ω–æ–º. –ó–Ω–∞—á–µ–Ω–∏–µ —Å—Ä–∞–≤–Ω–∏–≤–∞–µ—Ç—Å—è —Å —à–∞–±–ª–æ–Ω–∞–º–∏ –≤ –ø–æ—Ä—è–¥–∫–µ –∏—Ö –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è. –®–∞–±–ª–æ–Ω—ã –∏ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏—è <code>match</code> ‚Äî —ç—Ç–æ –æ—á–µ–Ω—å –º–æ—â–Ω—ã–µ —Å—Ä–µ–¥—Å—Ç–≤–∞ —è–∑—ã–∫–∞ Rust: –æ–Ω–∏ –¥–∞—é—Ç –≤–∞–º –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å 1) —É—á–∏—Ç—ã–≤–∞—Ç—å —Ä–∞–∑–ª–∏—á–Ω—ã–µ —Ä–∞–∑–≤–∏—Ç–∏—è —Å–æ–±—ã—Ç–∏–π –∏ 2) –¥–µ–ª–∞—Ç—å —ç—Ç–æ –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ. –≠—Ç–∏ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏ –±—É–¥—É—Ç —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω—ã –≤ –ì–ª–∞–≤–µ 6 –∏ –ì–ª–∞–≤–µ 9, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ.</p>
<p>–†–∞—Å—Å–º–æ—Ç—Ä–∏–º –Ω–∞—à –≤—ã—à–µ–ø—Ä–∏–≤–µ–¥—ë–Ω–Ω—ã–π –ø—Ä–∏–º–µ—Ä —Å –≤—ã—Ä–∞–∂–µ–Ω–∏–µ–º <code>match</code>. –ü—Ä–µ–¥–ø–æ–ª–æ–∂–∏–º, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –¥–∞–ª –¥–æ–≥–∞–¥–∫—É 50, –∞ –∑–∞–≥–∞–¥–∞–Ω–æ –±—ã–ª–æ —á–∏—Å–ª–æ 38.</p>
<p>–ï—Å–ª–∏ –º—ã —Å—Ä–∞–≤–Ω–∏–º 50 —Å 38, –º–µ—Ç–æ–¥ <code>cmp</code> –≤–µ—Ä–Ω—ë—Ç <code>Ordering::Greater</code>, –ø–æ—Å–∫–æ–ª—å–∫—É 50 –±–æ–ª—å—à–µ 38. –í—ã—Ä–∞–∂–µ–Ω–∏–µ <code>match</code> –±–µ—Ä—ë—Ç –∑–Ω–∞—á–µ–Ω–∏–µ <code>Ordering::Greater</code> –∏ –Ω–∞—á–∏–Ω–∞–µ—Ç –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ –ø—Ä–æ–≤–µ—Ä—è—Ç—å –∫–∞–∂–¥—ã–π —à–∞–±–ª–æ–Ω. –û–Ω–æ —Å–º–æ—Ç—Ä–∏—Ç –Ω–∞ –ø–µ—Ä–≤—ã–π —à–∞–±–ª–æ–Ω ‚Äî <code>Ordering::Less</code> ‚Äî –∏ –≤–∏–¥–∏—Ç, —á—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ <code>Ordering::Greater</code> –Ω–µ —Å–æ–ø–æ—Å—Ç–∞–≤–∏–º–æ —Å –Ω–∏–º, –∞ –ø–æ—Ç–æ–º—É –∫–æ–¥ —ç—Ç–æ–π –≤–µ—Ç–≤–∏ –∏–≥–Ω–æ—Ä–∏—Ä—É–µ—Ç—Å—è, –∏ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å —à–∞–±–ª–æ–Ω–∞–º–∏ –∏–¥—ë—Ç –¥–∞–ª—å—à–µ. –°–ª–µ–¥—É—é—â–∏–π —à–∞–±–ª–æ–Ω ‚Äî <code>Ordering::Greater</code>, –∏ –æ–Ω <em>—Å–æ–ø–æ—Å—Ç–∞–≤–ª—è–µ—Ç—Å—è</em> —Å <code>Ordering::Greater</code>! –°–≤—è–∑–∞–Ω–Ω—ã–π —Å —à–∞–±–ª–æ–Ω–æ–º –∫–æ–¥ –∏—Å–ø–æ–ª–Ω—è–µ—Ç—Å—è, –∏ –Ω–∞ —ç–∫—Ä–∞–Ω –ø–µ—á–∞—Ç–∞–µ—Ç—Å—è <code>Too big!</code>. –í—ã—Ä–∞–∂–µ–Ω–∏–µ <code>match</code> –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è –ø–æ—Å–ª–µ –ø–µ—Ä–≤–æ–≥–æ —É—Å–ø–µ—à–Ω–æ–≥–æ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è, –∏ –ø—Ä–æ–≤–µ—Ä–æ–∫ —Å –æ—Å—Ç–∞–≤—à–∏–º–∏—Å—è —à–∞–±–ª–æ–Ω–∞–º–∏ –Ω–µ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç.</p>
<p>–û–¥–Ω–∞–∫–æ, –∫–æ–¥ –õ–∏—Å—Ç–∏–Ω–∞ 2-4 –≤—Å—ë –µ—â—ë –Ω–µ –±—É–¥–µ—Ç –∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞—Ç—å—Å—è:</p>
<!--
The error numbers in this output should be that of the code **WITHOUT** the
anchor or snip comments
-->
<pre><code class="language-console">$ cargo build
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_core v0.6.2
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
   --&gt; src/main.rs:22:21
    |
22  |     match guess.cmp(&amp;secret_number) {
    |                 --- ^^^^^^^^^^^^^^ expected `&amp;String`, found `&amp;{integer}`
    |                 |
    |                 arguments to this method are incorrect
    |
    = note: expected reference `&amp;String`
               found reference `&amp;{integer}`
note: method defined here
   --&gt; file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/core/src/cmp.rs:838:8
    |
838 |     fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering;
    |        ^^^

For more information about this error, try `rustc --explain E0308`.
error: could not compile `guessing_game` (bin "guessing_game") due to 1 previous error
</code></pre>
<p>–í —Å–µ—Ä–¥—Ü–µ –æ—à–∏–±–∫–∏ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ <em>–Ω–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–∏ —Ç–∏–ø–æ–≤</em>. Rust ‚Äî —è–∑—ã–∫ —Å —Å–∏–ª—å–Ω–æ–π —Å—Ç–∞—Ç–∏—á–µ—Å–∫–æ–π —Ç–∏–ø–∏–∑–∞—Ü–∏–µ–π. –û–¥–Ω–∞–∫–æ, –æ–Ω —Ç–∞–∫–∂–µ —Å–ø–æ—Å–æ–±–µ–Ω —Å–∞–º–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω–æ –≤—ã–≤–µ—Å—Ç–∏ —Ç–∏–ø. –ö–æ–≥–¥–∞ –º—ã –ø–∏—à–µ–º <code>let mut guess = String::new()</code>, Rust –º–æ–∂–µ—Ç –≤—ã–≤–µ—Å—Ç–∏, —á—Ç–æ <code>guess</code> –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —Ç–∏–ø–∞ <code>String</code>, –∞ –ø–æ—Ç–æ–º—É —Å –Ω–∞—Å –Ω–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è —É—Ç–æ—á–Ω—è—Ç—å —Ç–∏–ø. <code>secret_number</code> –∂–µ ‚Äî —ç—Ç–æ —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã–π —Ç–∏–ø. –¢–∏–ø–æ–≤ Rust, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—Ç—å —á–∏—Å–ª–∞ –æ—Ç 1 –¥–æ 100, –º–Ω–æ–∂–µ—Å—Ç–≤–æ: <code>i32</code>, –∑–Ω–∞–∫–æ–≤–æ–µ 32-–±–∏—Ç–Ω–æ–µ —á–∏—Å–ª–æ; <code>u32</code>, –±–µ–∑–∑–Ω–∞–∫–æ–≤–æ–µ 32-–±–∏—Ç–Ω–æ–µ —á–∏—Å–ª–æ; <code>i64</code>, –∑–Ω–∞–∫–æ–≤–æ–µ 64-–±–∏—Ç–Ω–æ–µ —á–∏—Å–ª–æ; –∏ —Ç–∞–∫ –¥–∞–ª–µ–µ. –í —Å–ª—É—á–∞–µ —Ä–∞–≤–Ω–æ–≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —á–∏—Å–ª–æ–≤—ã—Ö —Ç–∏–ø–æ–≤, Rust –≤—ã–≤–æ–¥–∏—Ç –¥–ª—è —á–∏—Å–ª–∞ —Ç–∏–ø <code>i32</code>. –≠—Ç–æ –æ–Ω –∏ –¥–µ–ª–∞–µ—Ç —Å <code>secret_number</code> ‚Äî –≤—ã–≤–æ–¥–∏—Ç <code>i32</code>, –ø–æ–∫–∞ –Ω–µ –ø–æ—è–≤–∏—Ç—Å—è –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è, –∫–æ—Ç–æ—Ä–∞—è –∑–∞—Å—Ç–∞–≤–∏–ª–∞ –±—ã Rust –≤—ã–≤–µ—Å—Ç–∏ –¥—Ä—É–≥–æ–π —Ç–∏–ø. –ü—Ä–∏—á–∏–Ω–æ–π –∂–µ –æ—à–∏–±–∫–∏ —è–≤–ª—è–µ—Ç—Å—è –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –≤ Rust —Å—Ä–∞–≤–Ω–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è —Å—Ç—Ä–æ–∫–æ–≤–æ–≥–æ –∏ —á–∏—Å–ª–æ–≤–æ–≥–æ —Ç–∏–ø–æ–≤.</p>
<p>–í –∫–æ–Ω–µ—á–Ω–æ–º —Å—á—ë—Ç–µ, –º—ã —Ö–æ—Ç–∏–º –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å —Å—Ç—Ä–æ–∫—É <code>String</code>, –ø–æ–ª—É—á–∞–µ–º—É—é –ø—Ä–æ–≥—Ä–∞–º–º–æ–π –∏–∑ –≤–≤–æ–¥–∞, –≤ —á–∏—Å–ª–æ–≤–æ–π —Ç–∏–ø, –∫–æ—Ç–æ—Ä—ã–π –º—ã –∏ —Å–º–æ–∂–µ–º —Å—Ä–∞–≤–Ω–∏—Ç—å —Å —Å–µ–∫—Ä–µ—Ç–Ω—ã–º —á–∏—Å–ª–æ–º. –ú—ã —Å–¥–µ–ª–∞–µ–º —ç—Ç–æ, –¥–æ–±–∞–≤–∏–≤ –æ–¥–Ω—É —Å—Ç—Ä–æ—á–∫—É –≤ —Ç–µ–ª–æ —Ñ—É–Ω–∫—Ü–∏–∏ <code>main</code> ...</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("–£–≥–∞–¥–∞–π—Ç–µ —á–∏—Å–ª–æ!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("–ó–∞–≥–∞–¥–∞–Ω–Ω–æ–µ —á–∏—Å–ª–æ: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("–í–≤–µ–¥–∏—Ç–µ —Å–≤–æ—é –¥–æ–≥–∞–¥–∫—É.");
</span><span class="boring">
</span>    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–µ—Å—Ç—å –≤–≤–æ–¥.");

    let guess: u32 = guess.trim().parse().expect("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ!");

    println!("–í—ã –ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏–ª–∏: {guess}");

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!("–°–ª–∏—à–∫–æ–º –º–∞–ª–µ–Ω—å–∫–æ–µ!"),
        Ordering::Greater =&gt; println!("–°–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–µ!"),
        Ordering::Equal =&gt; println!("–í—ã –ø–æ–±–µ–¥–∏–ª–∏!"),
    }
<span class="boring">}</span></code></pre>
<p>... –≤–æ—Ç —ç—Ç—É —Å—Ç—Ä–æ—á–∫—É:</p>
<pre><code class="language-rust ignore">let guess: u32 = guess.trim().parse().expect("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ!");</code></pre>
<p>–ó–¥–µ—Å—å –º—ã —Å–æ–∑–¥–∞—ë–º –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é <code>guess</code>. –ù–æ —Ç–æ–ª—å–∫–æ... –≤ –ø—Ä–æ–≥—Ä–∞–º–º–µ –∂–µ —É–∂–µ –µ—Å—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è <code>guess</code>, –≤–µ—Ä–Ω–æ? –î–∞, —ç—Ç–æ —Ç–∞–∫, –≤ —Å–∞–º–æ–º –¥–µ–ª–µ; –Ω–æ Rust –ø–æ–∑–≤–æ–ª—è–µ—Ç –ø–µ—Ä–µ–æ–±—ä—è–≤–ª—è—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ, –ø—Ä–∏—Å–≤–∞–∏–≤–∞—è –∏–º –Ω–æ–≤—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è (–∏ –¥–∞–∂–µ –¥—Ä—É–≥–∏—Ö —Ç–∏–ø–æ–≤). –≠—Ç–æ –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è <em>–∑–∞—Ç–µ–Ω–µ–Ω–∏–µ–º</em>; –æ–Ω–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏–º—è –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –≤–º–µ—Å—Ç–æ —Ç–æ–≥–æ, —á—Ç–æ–±—ã —Å–æ–∑–¥–∞–≤–∞—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–¥–∏–Ω–∞–∫–æ–≤–æ–≥–æ —Å–º—ã—Å–ª–∞, –Ω–æ —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ (–Ω–∞–ø—Ä–∏–º–µ—Ä, <code>guess_str</code> –∏ <code>guess</code>). –ú—ã –æ–±—Å—É–¥–∏–º —ç—Ç–æ –¥–µ—Ç–∞–ª—å–Ω–µ–µ –≤ <a href="ch03-01-variables-and-mutability.html#%D0%97%D0%B0%D1%82%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5">–ì–ª–∞–≤–µ 3</a><!-- ignore -->, –∞ –ø–æ–∫–∞ –ø—Ä–æ—Å—Ç–æ –∑–Ω–∞–π—Ç–µ, —á—Ç–æ –∑–∞—Ç–µ–Ω–µ–Ω–∏–µ —á–∞—Å—Ç–æ –ø–æ–ª–µ–∑–Ω–æ, –∫–æ–≥–¥–∞ –≤–∞–º –Ω—É–∂–Ω–æ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ –æ–¥–Ω–æ–≥–æ —Ç–∏–ø–∞ –≤ –¥—Ä—É–≥–æ–π.</p>
<p>–ú—ã —Å–≤—è–∑—ã–≤–∞–µ–º —ç—Ç—É –Ω–æ–≤—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é —Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º –≤—ã—Ä–∞–∂–µ–Ω–∏—è <code>guess.trim().parse()</code>. –í –Ω—ë–º, <code>guess</code> ‚Äî —ç—Ç–æ –Ω–∞–∑–≤–∞–Ω–∏–µ —É–∂–µ —Ä–∞–Ω–µ–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π: –Ω–∞—à–µ–π –∏–∑–Ω–∞—á–∞–ª—å–Ω–æ–π <code>guess</code>, —Å–æ–¥–µ—Ä–∂–∞—â–µ–π –≤–≤–æ–¥ –≤ –≤–∏–¥–µ —Å—Ç—Ä–æ–∫–∏. –ú–µ—Ç–æ–¥ <code>trim</code>, —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π –¥–ª—è —ç–∫–∑–µ–º–ø–ª—è—Ä–æ–≤ <code>String</code>, —É–±–∏—Ä–∞–µ—Ç –Ω–∞—á–∞–ª—å–Ω—ã–µ –∏ –∫–æ–Ω–µ—á–Ω—ã–µ –ø—Ä–æ–±–µ–ª—ã ‚Äî –Ω–∞–º –Ω—É–∂–Ω–æ —ç—Ç–æ —Å–¥–µ–ª–∞—Ç—å –ø–µ—Ä–µ–¥ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–µ–π —Å—Ç—Ä–æ–∫–∏ –≤ —á–∏—Å–ª–æ —Ç–∏–ø–∞ <code>u32</code> (—Ü–µ–ª–æ–µ, –±–µ–∑–∑–Ω–∞–∫–æ–≤–æ–µ, 32-–±–∏—Ç–Ω–æ–µ). –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –¥–æ–ª–∂–µ–Ω –Ω–∞–∂–∞—Ç—å <kbd>Enter</kbd>, —á—Ç–æ–±—ã <code>read_line</code> –∏—Å–ø–æ–ª–Ω–∏–ª—Å—è –∏ —Å—á–∏—Ç–∞–ª –≤–≤–µ–¥—ë–Ω–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é. –û–¥–Ω–∞–∫–æ —Å—á–∏—Ç–∞–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞ –±—É–¥–µ—Ç –≤–∫–ª—é—á–∞—Ç—å –≤ —Å–µ–±—è —Å–∏–º–≤–æ–ª –Ω–∞—á–∞–ª–∞ –Ω–æ–≤–æ–π —Å—Ç—Ä–æ–∫–∏. –ù–∞–ø—Ä–∏–º–µ—Ä, –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞–ø–µ—á–∞—Ç–∞–µ—Ç <kbd>5</kbd> –∏ –ø–æ—Ç–æ–º –Ω–∞–∂–º—ë—Ç <kbd>Enter</kbd>, <code>guess</code> –±—É–¥–µ—Ç –≤—ã–≥–ª—è–¥–µ—Ç—å –≤–æ—Ç —Ç–∞–∫: <code>5\n</code>. <code>\n</code> ‚Äî —ç—Ç–æ –æ–±–æ–∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è —Å–∏–º–≤–æ–ª–∞ –Ω–∞—á–∞–ª–∞ –Ω–æ–≤–æ–π —Å—Ç—Ä–æ–∫–∏. (–°—Ç–æ–∏—Ç –æ—Ç–º–µ—Ç–∏—Ç—å, —á—Ç–æ –Ω–∞ Windows –Ω–∞–∂–∞—Ç–∏–µ <kbd>Enter</kbd> —Å–æ–ø—Ä–æ–≤–æ–∂–¥–∞–µ—Ç—Å—è –≤–æ–∑–≤—Ä–∞—Ç–æ–º –∫–∞—Ä–µ—Ç–∫–∏, –∏ —Ç–æ–ª—å–∫–æ –ø–æ—Ç–æ–º —Å–∏–º–≤–æ–ª–æ–º –Ω–∞—á–∞–ª–∞ –Ω–æ–≤–æ–π —Å—Ç—Ä–æ–∫–∏, —á—Ç–æ –≤—Å—ë –≤–º–µ—Å—Ç–µ –¥–∞—ë—Ç <code>\r\n</code>.) –ú–µ—Ç–æ–¥ <code>trim</code> —Å–º–æ–∂–µ—Ç —É–±—Ä–∞—Ç—å –∫–∞–∫ <code>\n</code>, —Ç–∞–∫ –∏ <code>\r\n</code>, –∏ –≤–µ—Ä–Ω—ë—Ç –ø—Ä–æ—Å—Ç–æ —Å—Ç—Ä–æ–∫—É <code>5</code>.</p>
<p><a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse">–ú–µ—Ç–æ–¥ <code>parse</code> —Å—Ç—Ä–æ–∫</a> <!-- ignore --> –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Å—Ç—Ä–æ–∫—É –∫ –¥—Ä—É–≥–æ–º—É —Ç–∏–ø—É. –í –Ω–∞—à–µ–º —Å–ª—É—á–∞–µ, –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ –¥–ª—è –ø—Ä–∏–≤–µ–¥–µ–Ω–∏—è —Å—Ç—Ä–æ–∫–∏ –∫ —á–∏—Å–ª—É. –ù–∞–º –Ω—É–∂–Ω–æ —É–∫–∞–∑–∞—Ç—å Rust, –∫ –∫–∞–∫–æ–º—É –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º—É —á–∏—Å–ª–æ–≤–æ–º—É —Ç–∏–ø—É –º—ã —Ö–æ—Ç–∏–º –ø—Ä–∏–≤–µ—Å—Ç–∏ –Ω–∞—à –≤–≤–æ–¥, –∏ –¥–ª—è —ç—Ç–æ–≥–æ –º—ã —è–≤–Ω–æ —É–∫–∞–∑—ã–≤–∞–µ–º —Ç–∏–ø –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π: <code>let guess: u32</code>. –î–≤–æ–µ—Ç–æ—á–∏–µ (<code>:</code>) –ø–æ—Å–ª–µ <code>guess</code> –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –∞–Ω–Ω–æ—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Ç–∏–ø–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π. –í Rust –µ—Å—Ç—å –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ —á–∏—Å–ª–æ–≤—ã–µ —Ç–∏–ø—ã; –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã–π –Ω–∞–º–∏ —Ç–∏–ø <code>u32</code> –æ–∑–Ω–∞—á–∞–µ—Ç —Ü–µ–ª–æ–µ –±–µ–∑–∑–Ω–∞–∫–æ–≤–æ–µ 32-–±–∏—Ç–Ω–æ–µ —á–∏—Å–ª–æ ‚Äî —Ö–æ—Ä–æ—à–∏–π –≤—ã–±–æ—Ä –¥–ª—è –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –Ω–µ–±–æ–ª—å—à–∏—Ö –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã—Ö —á–∏—Å–µ–ª. –í—ã —É–∑–Ω–∞–µ—Ç–µ –±–æ–ª—å—à–µ –æ –¥—Ä—É–≥–∏—Ö —á–∏—Å–ª–æ–≤—ã—Ö —Ç–∏–ø–∞—Ö –≤ <a href="ch03-02-data-types.html#%D0%A6%D0%B5%D0%BB%D0%BE%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B">–ì–ª–∞–≤–µ 3</a><!-- ignore -->.</p>
<p>–í –¥–æ–±–∞–≤–æ–∫, –∞–Ω–Ω–æ—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ <code>guess</code> —Ç–∏–ø–æ–º <code>u32</code> –∏ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å <code>secret_number</code> –ø–æ–∑–≤–æ–ª—è—é—Ç Rust –≤—ã–≤–µ—Å—Ç–∏, —á—Ç–æ <code>secret_number</code> —Ç–æ–∂–µ –¥–æ–ª–∂–Ω–∞ –∏–º–µ—Ç—å —Ç–∏–ø <code>u32</code>. –¢–µ–ø–µ—Ä—å –º—ã –Ω–∞–∫–æ–Ω–µ—Ü-—Ç–æ —Å—Ä–∞–≤–Ω–∏–≤–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –æ–¥–∏–Ω–∞–∫–æ–≤—ã—Ö —Ç–∏–ø–æ–≤!</p>
<p>–ú–µ—Ç–æ–¥ <code>parse</code> –º–æ–∂–µ—Ç –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å –≤ —Ü–∏—Ñ—Ä—ã —Ç–æ–ª—å–∫–æ —Ç–µ —Å–∏–º–≤–æ–ª—ã —Å—Ç—Ä–æ–∫–∏, –∫–æ—Ç–æ—Ä—ã–µ —Ü–∏—Ñ—Ä—ã –∂–µ –∏ –æ–±–æ–∑–Ω–∞—á–∞—é—Ç, –∞ –ø–æ—Ç–æ–º—É –æ–Ω –º–æ–∂–µ—Ç –ª–µ–≥–∫–æ –≤—ã–∑–≤–∞—Ç—å –æ—à–∏–±–∫—É. –ù–∞–ø—Ä–∏–º–µ—Ä, —Å—Ç—Ä–æ–∫—É <code>Aüëç%</code> –Ω–∏–∫–∞–∫ –Ω–µ–ª—å–∑—è –±—É–¥–µ—Ç –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å –≤ —á–∏—Å–ª–æ. –ü–æ—ç—Ç–æ–º—É, –ø–æ—Å–∫–æ–ª—å–∫—É –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –º–æ–∂–µ—Ç –∑–∞–≤–µ—Ä—à–∏—Ç—å—Å—è —Å –æ—à–∏–±–∫–æ–π, –º–µ—Ç–æ–¥ <code>parse</code> –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–∏–ø <code>Result</code> ‚Äî —Ç–∞–∫ –∂–µ, –∫–∞–∫ –∏ –º–µ—Ç–æ–¥ <code>read_line</code> (—á—Ç–æ –æ–±—Å—É–∂–¥–∞–ª–æ—Å—å —Ä–∞–Ω–µ–µ –≤ –ø–æ–¥—Ä–∞–∑–¥–µ–ª–µ <a href="ch02-00-guessing-game-tutorial.html#%D0%9E%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0-%D0%B2%D0%BE%D0%B7%D0%BC%D0%BE%D0%B6%D0%BD%D1%8B%D1%85-%D0%BE%D1%88%D0%B8%D0%B1%D0%BE%D0%BA-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-result">"–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–æ–∑–º–æ–∂–Ω—ã—Ö –æ—à–∏–±–æ–∫ —Å –ø–æ–º–æ—â—å—é <code>Result</code>"</a><!-- ignore -->). –í—ã –æ–±—Ä–∞–±–æ—Ç–∞–µ–º <code>Result</code> —Ç–∞–∫ –∂–µ, –∫–∞–∫ –∏ –¥–æ —ç—Ç–æ–≥–æ: —Å –ø–æ–º–æ—â—å—é –º–µ—Ç–æ–¥–∞ <code>expect</code>. –ï—Å–ª–∏ <code>parse</code> –Ω–µ —Å–º–æ–∂–µ—Ç —Å–æ–∑–¥–∞—Ç—å –∏–∑ —Å—Ç—Ä–æ–∫–∏ —á–∏—Å–ª–æ, —Ç–æ –æ–Ω –≤–µ—Ä–Ω—ë—Ç –≤–∞—Ä–∏–∞–Ω—Ç <code>Err</code> —Ç–∏–ø–∞ <code>Result</code>, –∞ <code>expect</code> –≤—ã–∑–æ–≤–µ—Ç —Å–±–æ–π –∏ –Ω–∞–ø–µ—á–∞—Ç–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –º—ã –µ–º—É –ø–µ—Ä–µ–¥–∞–ª–∏. –ï—Å–ª–∏ <code>parse</code> —Å–º–æ–∂–µ—Ç –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å —Å—Ç—Ä–æ–∫—É –≤ —á–∏—Å–ª–æ –∏ –ø–æ—Ç–æ–º—É –≤–µ—Ä–Ω—ë—Ç –≤–∞—Ä–∏–∞–Ω—Ç <code>Ok</code> —Ç–∏–ø–∞ <code>Result</code>, <code>expect</code> –≤–µ—Ä–Ω—ë—Ç —á–∏—Å–ª–æ, —É–ø–∞–∫–æ–≤–∞–Ω–Ω–æ–µ –≤ <code>Ok</code>.</p>
<p>–¢–µ–ø–µ—Ä—å –∑–∞–ø—É—Å—Ç–∏–º –Ω–∞—à—É –ø—Ä–æ–≥—Ä–∞–º–º—É:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/
touch src/main.rs
cargo run
  76
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.26s
     Running `target/debug/guessing_game`
–£–≥–∞–¥–∞–π—Ç–µ —á–∏—Å–ª–æ!
–ó–∞–≥–∞–¥–∞–Ω–Ω–æ–µ —á–∏—Å–ª–æ: 58
–í–≤–µ–¥–∏—Ç–µ —Å–≤–æ—é –¥–æ–≥–∞–¥–∫—É.
  76
–í—ã –ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏–ª–∏: 76
–°–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–µ!
</code></pre>
<p>–û—Ç–ª–∏—á–Ω–æ! –ü—É—Å—Ç—å –ø—Ä–æ–≥—Ä–∞–º–º–∞ –∏ –¥–æ–±–∞–≤–ª—è–µ—Ç –ø–∞—Ä—É –ø—Ä–æ–±–µ–ª–æ–≤ –ø–µ—Ä–µ–¥ –¥–æ–≥–∞–¥–∫–æ–π, –ø—Ä–æ–≥—Ä–∞–º–º–∞ –≤—Å—ë-—Ç–∞–∫–∏ –ø–æ–Ω–∏–º–∞–µ—Ç, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏–ª —á–∏—Å–ª–æ 76. –ó–∞–ø—É—Å—Ç–∏—Ç–µ –ø—Ä–æ–≥—Ä–∞–º–º—É –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ä–∞–∑, —á—Ç–æ–±—ã –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Ä–∞–∑–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ —Å —Ä–∞–∑–Ω—ã–º–∏ –≤–≤–µ–¥—ë–Ω–Ω—ã–º–∏ —á–∏—Å–ª–∞–º–∏: –ø—Ä–∞–≤–∏–ª—å–Ω—É—é –¥–æ–≥–∞–¥–∫—É, —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à—É—é –¥–æ–≥–∞–¥–∫—É –∏ —Å–ª–∏—à–∫–æ–º –º–∞–ª–µ–Ω—å–∫—É—é.</p>
<p>–ë–æ–ª—å—à–∞—è —á–∞—Å—Ç—å –∏–≥—Ä—ã –≥–æ—Ç–æ–≤–∞, –Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø–æ–∫–∞ —á—Ç–æ –º–æ–∂–µ—Ç —Å–¥–µ–ª–∞—Ç—å –¥–∞—Ç—å –æ–¥–Ω—É –¥–æ–≥–∞–¥–∫—É. –ò–∑–º–µ–Ω–∏–º —ç—Ç–æ, –¥–æ–±–∞–≤–∏–≤ —Ü–∏–∫–ª!</p>
<h2 id="–í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å-–¥–∞—Ç—å-–¥–æ–≥–∞–¥–∫—É-–Ω–µ-–æ–¥–∏–Ω-—Ä–∞–∑-—Å-–ø–æ–º–æ—â—å—é-—Ü–∏–∫–ª–æ–≤"><a class="header" href="#–í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å-–¥–∞—Ç—å-–¥–æ–≥–∞–¥–∫—É-–Ω–µ-–æ–¥–∏–Ω-—Ä–∞–∑-—Å-–ø–æ–º–æ—â—å—é-—Ü–∏–∫–ª–æ–≤">–í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –¥–∞—Ç—å –¥–æ–≥–∞–¥–∫—É –Ω–µ –æ–¥–∏–Ω —Ä–∞–∑ —Å –ø–æ–º–æ—â—å—é —Ü–∏–∫–ª–æ–≤</a></h2>
<p>–ö–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ <code>loop</code> —Å–æ–∑–¥–∞—ë—Ç –±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π —Ü–∏–∫–ª. –ú—ã –¥–æ–±–∞–≤–∏–º —Ü–∏–∫–ª, —á—Ç–æ–±—ã –¥–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –±–æ–ª—å—à–µ –ø–æ–ø—ã—Ç–æ–∫ —É–≥–∞–¥–∞—Ç—å —á–∏—Å–ª–æ:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("–£–≥–∞–¥–∞–π—Ç–µ —á–∏—Å–ª–æ!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--

    println!("–ó–∞–≥–∞–¥–∞–Ω–Ω–æ–µ —á–∏—Å–ª–æ: {secret_number}");

    loop {
        println!("–í–≤–µ–¥–∏—Ç–µ —Å–≤–æ—é –¥–æ–≥–∞–¥–∫—É.");

        // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--

<span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–µ—Å—Ç—å –≤–≤–æ–¥.");
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ!");
</span><span class="boring">
</span><span class="boring">        println!("–í—ã –ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏–ª–∏: {guess}");
</span><span class="boring">
</span>        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("–°–ª–∏—à–∫–æ–º –º–∞–ª–µ–Ω—å–∫–æ–µ!"),
            Ordering::Greater =&gt; println!("–°–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–µ!"),
            Ordering::Equal =&gt; println!("–í—ã –ø–æ–±–µ–¥–∏–ª–∏!"),
        }
    }
}</code></pre>
<p>–ö–∞–∫ –≤—ã –º–æ–∂–µ—Ç–µ –≤–∏–¥–µ—Ç—å, –º—ã –ø–µ—Ä–µ–º–µ—Å—Ç–∏–ª–∏ –≤–µ—Å—å –∫–æ–¥ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–æ–≥–∞–¥–∫–∏ –≤ —Ü–∏–∫–ª. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –æ—Ç–±–∏–ª–∏ —Å—Ç—Ä–æ—á–∫–∏ –æ—Ç –ª–µ–≤–æ–≥–æ –∫—Ä–∞—è –µ—â—ë —á–µ—Ç—ã—Ä—å–º—è –ø—Ä–æ–±–µ–ª–∞–º–∏ –∫–∞–∂–¥—É—é, –∏ —Å–Ω–æ–≤–∞ –∑–∞–ø—É—Å—Ç–∏—Ç–µ –ø—Ä–æ–≥—Ä–∞–º–º—É. –ü—Ä–æ–≥—Ä–∞–º–º–∞ —Ç–µ–ø–µ—Ä—å –±—É–¥–µ—Ç —Å–ø—Ä–∞—à–∏–≤–∞—Ç—å –¥–æ–≥–∞–¥–∫—É –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ, –∏ —ç—Ç–æ —Å–æ–∑–¥–∞–ª–æ –Ω–∞–º –Ω–æ–≤—É—é –ø—Ä–æ–±–ª–µ–º—É: –∏–≥—Ä–∞ –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –∑–∞–∫–æ–Ω—á–∏—Ç—Å—è!</p>
<p>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å, –∫–æ–Ω–µ—á–Ω–æ, –≤—Å–µ–≥–¥–∞ –º–æ–∂–µ—Ç –ø—Ä–µ—Ä–≤–∞—Ç—å –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã —Å–æ—á–µ—Ç–∞–Ω–∏–µ–º –∫–ª–∞–≤–∏—à <kbd>ctrl</kbd>-<kbd>c</kbd>. –ï—Å—Ç—å –∏ –¥—Ä—É–≥–∞—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –Ω–∞—à—É –ø—Ä–æ–≥—Ä–∞–º–º—É-–ª—É–¥–æ–º–∞–Ω–∞: –∫–∞–∫ –º—ã –æ–±—Å—É–¥–∏–ª–∏ –≤ –ø–æ–¥—Ä–∞–∑–¥–µ–ª–µ <a href="ch02-00-guessing-game-tutorial.html#%D0%A1%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B4%D0%BE%D0%B3%D0%B0%D0%B4%D0%BA%D0%B8-%D1%81-%D0%B7%D0%B0%D0%B3%D0%B0%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D0%BC-%D1%87%D0%B8%D1%81%D0%BB%D0%BE%D0%BC">"–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –¥–æ–≥–∞–¥–∫–∏ —Å –∑–∞–≥–∞–¥–∞–Ω–Ω—ã–º —á–∏—Å–ª–æ–º"</a>, –∫–æ–≥–¥–∞ –≥–æ–≤–æ—Ä–∏–ª–∏ –æ <code>parse</code>, –≤–≤–æ–¥ –Ω–µ —á–∏—Å–ª–∞ –≤—ã–∑–æ–≤–µ—Ç –∞–≤–∞—Ä–∏–π–Ω—É—é –æ—Å—Ç–∞–Ω–æ–≤–∫—É –ø—Ä–æ–≥—Ä–∞–º–º—ã. –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –º–æ–∂–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç—Ç–æ—Ç —ç–∫—Å–ø–ª–æ–π—Ç, —á—Ç–æ–±—ã –≤—ã–π—Ç–∏ –∏–∑ –∏–≥—Ä—ã:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-04-looping/
touch src/main.rs
cargo run
(too small guess)
(too big guess)
(correct guess)
quit
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.23s
     Running `target/debug/guessing_game`
–£–≥–∞–¥–∞–π—Ç–µ —á–∏—Å–ª–æ!
–ó–∞–≥–∞–¥–∞–Ω–Ω–æ–µ —á–∏—Å–ª–æ: 59
–í–≤–µ–¥–∏—Ç–µ —Å–≤–æ—é –¥–æ–≥–∞–¥–∫—É.
45
–í—ã –ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏–ª–∏: 45
–°–ª–∏—à–∫–æ–º –º–∞–ª–µ–Ω—å–∫–æ–µ!
–í–≤–µ–¥–∏—Ç–µ —Å–≤–æ—é –¥–æ–≥–∞–¥–∫—É.
60
–í—ã –ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏–ª–∏: 60
–°–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–µ!
–í–≤–µ–¥–∏—Ç–µ —Å–≤–æ—é –¥–æ–≥–∞–¥–∫—É.
59
–í—ã –ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏–ª–∏: 59
–í—ã –ø–æ–±–µ–¥–∏–ª–∏!
–í–≤–µ–¥–∏—Ç–µ —Å–≤–æ—é –¥–æ–≥–∞–¥–∫—É.
quit
thread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/main.rs:28:47
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>–í–≤–æ–¥ —Å–ª–æ–≤–∞ <code>quit</code> –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç –ø—Ä–æ–≥—Ä–∞–º–º—É, –Ω–æ –∫–∞–∫ –≤—ã –º–æ–∂–µ—Ç–µ –∑–∞–º–µ—Ç–∏—Ç—å, —ç—Ç–æ –ø—Ä–æ–∏–∑–æ–π–¥—ë—Ç –ø—Ä–∏ –ª—é–±–æ–º –Ω–µ—á–∏—Å–ª–æ–≤–æ–º –≤–≤–æ–¥–µ. –¢–∞–∫–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã, –º—è–≥–∫–æ –≥–æ–≤–æ—Ä—è, –Ω–µ–æ–ø—Ç–∏–º–∞–ª—å–Ω–æ. –ú—ã —Ö–æ—Ç–∏–º, —á—Ç–æ–±—ã –∏–≥—Ä–∞ –∑–∞–≤–µ—Ä—à–∞–ª–∞—Å—å, –∫–æ–≥–¥–∞ –¥–æ–≥–∞–¥–∫–∞ –∏–≥—Ä–æ–∫–∞ –æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π.</p>
<h3 id="–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ-–∏–≥—Ä—ã-–ø–æ—Å–ª–µ-–ø—Ä–∞–≤–∏–ª—å–Ω–æ–π-–¥–æ–≥–∞–¥–∫–∏"><a class="header" href="#–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ-–∏–≥—Ä—ã-–ø–æ—Å–ª–µ-–ø—Ä–∞–≤–∏–ª—å–Ω–æ–π-–¥–æ–≥–∞–¥–∫–∏">–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –∏–≥—Ä—ã –ø–æ—Å–ª–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –¥–æ–≥–∞–¥–∫–∏</a></h3>
<p>–ó–∞–ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä—É–µ–º –≤—ã—Ö–æ–¥ –∏–∑ –∏–≥—Ä—ã, –∫–æ–≥–¥–∞ –∏–≥—Ä–æ–∫ –ø–æ–±–µ–∂–¥–∞–µ—Ç. –î–ª—è —ç—Ç–æ–≥–æ, –∏—Å–ø–æ–ª—å–∑—É–µ–º –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é <code>break</code>:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("–£–≥–∞–¥–∞–π—Ç–µ —á–∏—Å–ª–æ!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("–ó–∞–≥–∞–¥–∞–Ω–Ω–æ–µ —á–∏—Å–ª–æ: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!("–í–≤–µ–¥–∏—Ç–µ —Å–≤–æ—é –¥–æ–≥–∞–¥–∫—É.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–µ—Å—Ç—å –≤–≤–æ–¥.");
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ!");
</span><span class="boring">
</span><span class="boring">        println!("–í—ã –ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏–ª–∏: {guess}");
</span><span class="boring">
</span>        // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("–°–ª–∏—à–∫–æ–º –º–∞–ª–µ–Ω—å–∫–æ–µ!"),
            Ordering::Greater =&gt; println!("–°–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–µ!"),
            Ordering::Equal =&gt; {
                println!("–í—ã –ø–æ–±–µ–¥–∏–ª–∏!");
                break;
            }
        }
    }
}</code></pre>
<p>–°—Ç—Ä–æ–∫–∞ <code>break</code> –ø–æ—Å–ª–µ <code>You win!</code> –∑–∞—Å—Ç–∞–≤–ª—è–µ—Ç –ø—Ä–æ–≥—Ä–∞–º–º—É –ø–æ–∫–∏–Ω—É—Ç—å —Ü–∏–∫–ª, –∫–æ–≥–¥–∞ –∏–≥—Ä–æ–∫ –¥–µ–ª–∞–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω—É—é –¥–æ–≥–∞–¥–∫—É. –í—ã—Ö–æ–¥ –∏–∑ —Ü–∏–∫–ª–∞ —Ç–∞–∫–∂–µ –æ–∑–Ω–∞—á–∞–µ—Ç –∫–æ–Ω–µ—Ü –ø—Ä–æ–≥—Ä–∞–º–º—ã, –ø–æ—Å–∫–æ–ª—å–∫—É —Ü–∏–∫–ª –æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è –ø–æ—Å–ª–µ–¥–Ω–µ–π —á–∞—Å—Ç—å—é <code>main</code>.</p>
<h3 id="–û–±—Ä–∞–±–æ—Ç–∫–∞-–Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ-–≤–≤–æ–¥–∞"><a class="header" href="#–û–±—Ä–∞–±–æ—Ç–∫–∞-–Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ-–≤–≤–æ–¥–∞">–û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –≤–≤–æ–¥–∞</a></h3>
<p>–ß—Ç–æ–±—ã —Å–¥–µ–ª–∞—Ç—å –ø–æ–≤–µ–¥–µ–Ω–∏–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã –µ—â—ë –ª—É—á—à–µ, –∑–∞–º–µ–Ω–∏–º –ø—Ä–µ–¥–Ω–∞–º–µ—Ä–µ–Ω–Ω—ã–π –≤—ã–ª–µ—Ç –ø—Ä–æ–≥—Ä–∞–º–º—ã –ø—Ä–∏ –Ω–µ—á–∏—Å–ª–æ–≤–æ–º –≤–≤–æ–¥–µ –Ω–∞ –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–∞–∫–æ–≥–æ –≤–≤–æ–¥–∞, –¥–∞–¥–∏–º –∏–≥—Ä–æ–∫—É –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å. –ú—ã —Å–¥–µ–ª–∞–µ–º —ç—Ç–æ, –∏–∑–º–µ–Ω–∏–≤ —Å—Ç—Ä–æ—á–∫—É, –≥–¥–µ <code>guess</code> –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è –∏–∑ <code>String</code> –≤ <code>u32</code>. –ò–∑–º–µ–Ω–µ–Ω–∏–µ –ø–æ–∫–∞–∑–∞–Ω–æ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 2-5.</p>
<Listing number="2-5" file-name="src/main.rs" caption="Ignoring a non-number guess and asking for another guess instead of crashing the program">
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("–£–≥–∞–¥–∞–π—Ç–µ —á–∏—Å–ª–æ!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("–ó–∞–≥–∞–¥–∞–Ω–Ω–æ–µ —á–∏—Å–ª–æ: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!("–í–≤–µ–¥–∏—Ç–µ —Å–≤–æ—é –¥–æ–≥–∞–¥–∫—É.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span>        // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--

        io::stdin()
            .read_line(&amp;mut guess)
            .expect("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–µ—Å—Ç—å –≤–≤–æ–¥.");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!("–í—ã –ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏–ª–∏: {guess}");

        // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!("–°–ª–∏—à–∫–æ–º –º–∞–ª–µ–Ω—å–∫–æ–µ!"),
</span><span class="boring">            Ordering::Greater =&gt; println!("–°–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–µ!"),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!("–í—ã –ø–æ–±–µ–¥–∏–ª–∏!");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>We switch from an <code>expect</code> call to a <code>match</code> expression to move from crashing on an error to handling the error. Remember that <code>parse</code> returns a <code>Result</code> type and <code>Result</code> is an enum that has the variants <code>Ok</code> and <code>Err</code>. We‚Äôre using a <code>match</code> expression here, as we did with the <code>Ordering</code> result of the <code>cmp</code> method.</p>
<p>–ï—Å–ª–∏ <code>parse</code> –º–æ–∂–µ—Ç –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å —Å—Ç—Ä–æ–∫—É –≤ —á–∏—Å–ª–æ, –æ–Ω –≤–µ—Ä–Ω—ë—Ç –∑–Ω–∞—á–µ–Ω–∏–µ <code>Ok</code>, —Å–æ–¥–µ—Ä–∂–∞—â–µ–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è ‚Äî —á–∏—Å–ª–æ. –≠—Ç–æ—Ç <code>Ok</code> —Å–æ–ø–æ—Å—Ç–∞–≤–∏—Ç—Å—è —Å —à–∞–±–ª–æ–Ω–æ–º –ø–µ—Ä–≤–æ–π –≤–µ—Ç–≤–∏, –∏ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ <code>match</code> –ø—Ä–æ—Å—Ç–æ –≤–µ—Ä–Ω—ë—Ç –∑–Ω–∞—á–µ–Ω–∏–µ <code>num</code>, –∫–æ—Ç–æ—Ä–æ–µ –¥–æ —ç—Ç–æ–≥–æ —Å–æ–∑–¥–∞–ª–æ <code>parse</code> –∏ –ø–æ–º–µ—Å—Ç–∏–ª–æ –≤ –∑–Ω–∞—á–µ–Ω–∏–µ <code>Ok</code>. –≠—Ç–æ —á–∏—Å–ª–æ –±—É–¥–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ –≤ —Å–æ–∑–¥–∞–Ω–Ω–æ–π –Ω–∞–º–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π <code>guess</code>.</p>
<p>–ï—Å–ª–∏ <code>parse</code> <em>–Ω–µ</em> —Å–º–æ–∂–µ—Ç —Å–¥–µ–ª–∞—Ç—å –∏–∑ —Å—Ç—Ä–æ–∫–∏ —á–∏—Å–ª–æ, –æ–Ω –≤–µ—Ä–Ω—ë—Ç –∑–Ω–∞—á–µ–Ω–∏–µ <code>Err</code>, —Å–æ–¥–µ—Ä–∂–∞—â–µ–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –æ—à–∏–±–∫–µ. –ó–Ω–∞—á–µ–Ω–∏–µ <code>Err</code> –Ω–µ —Å–æ–ø–æ—Å—Ç–∞–≤–∏—Ç—Å—è —Å —à–∞–±–ª–æ–Ω–æ–º <code>Ok(num)</code> –ø–µ—Ä–≤–æ–π –≤–µ—Ç–≤–∏ <code>match</code>, –Ω–æ —Å–æ–ø–æ—Å—Ç–∞–≤–∏—Ç—Å—è —Å —à–∞–±–ª–æ–Ω–æ–º <code>Err(_)</code> –≤—Ç–æ—Ä–æ–π –≤–µ—Ç–≤–∏. –ù–∏–∂–Ω–µ–µ –ø–æ–¥—á—ë—Ä–∫–∏–≤–∞–Ω–∏–µ <code>_</code> ‚Äî —ç—Ç–æ —à–∞–±–ª–æ–Ω, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π –ª—é–±–æ–º—É –∑–Ω–∞—á–µ–Ω–∏—é; –≤ –Ω–∞—à–µ–º –ø—Ä–∏–º–µ—Ä–µ –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ, —á—Ç–æ–±—ã —Å–∫–∞–∑–∞—Ç—å, —á—Ç–æ —à–∞–±–ª–æ–Ω –≤—Ç–æ—Ä–æ–π –≤–µ—Ç–≤–∏ –¥–æ–ª–∂–µ–Ω —Å–æ–ø–æ—Å—Ç–∞–≤–∏—Ç—å—Å—è —Å –ª—é–±—ã–º <code>Err</code>, –∫–∞–∫—É—é –±—ã –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–Ω —Å —Å–æ–±–æ–π –Ω–∏ –Ω—ë—Å. –¢–∞–∫ —á—Ç–æ –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏, –ø—Ä–æ–≥—Ä–∞–º–º–∞ –∏—Å–ø–æ–ª–Ω–∏—Ç –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é –≤—Ç–æ—Ä–æ–π –≤–µ—Ç–≤–∏ ‚Äî <code>continue</code>. –û–Ω–∞ —Å–æ–æ–±—â–∞–µ—Ç –ø—Ä–æ–≥—Ä–∞–º–º–µ, —á—Ç–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —Å—Ä–∞–∑—É –ø–µ—Ä–µ–π—Ç–∏ –Ω–∞ —Å–ª–µ–¥—É—é—â—É—é –∏—Ç–µ—Ä–∞—Ü–∏—é —Ü–∏–∫–ª–∞ <code>loop</code> –∏ –∑–∞–ø—Ä–æ—Å–∏—Ç—å –¥—Ä—É–≥—É—é –¥–æ–≥–∞–¥–∫—É. –¢–µ–ø–µ—Ä—å –Ω–∞—à–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∞ —Ä–∞—Ü–∏–æ–Ω–∞–ª—å–Ω–æ –∏–≥–Ω–æ—Ä–∏—Ä—É–µ—Ç –≤—Å–µ –æ—à–∏–±–∫–∏, —Å –∫–æ—Ç–æ—Ä—ã–º–∏ –º–æ–∂–µ—Ç –∑–∞–≤–µ—Ä—à–∏—Ç—å—Å—è <code>parse</code>!</p>
<p>–¢–µ–ø–µ—Ä—å –≤—Å—è –ø—Ä–æ–≥—Ä–∞–º–º–∞ –¥–æ–ª–∂–Ω–∞ —Ä–∞–±–æ—Ç–∞—Ç—å –Ω—É–∂–Ω—ã–º –æ–±—Ä–∞–∑–æ–º. –ü–æ–ø—Ä–æ–±—É–µ–º:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-05/
cargo run
(too small guess)
(too big guess)
foo
(correct guess)
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s
     Running `target/debug/guessing_game`
–£–≥–∞–¥–∞–π—Ç–µ —á–∏—Å–ª–æ!
–ó–∞–≥–∞–¥–∞–Ω–Ω–æ–µ —á–∏—Å–ª–æ: 61
–í–≤–µ–¥–∏—Ç–µ —Å–≤–æ—é –¥–æ–≥–∞–¥–∫—É.
10
–í—ã –ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏–ª–∏: 10
–°–ª–∏—à–∫–æ–º –º–∞–ª–µ–Ω—å–∫–æ–µ!
–í–≤–µ–¥–∏—Ç–µ —Å–≤–æ—é –¥–æ–≥–∞–¥–∫—É.
99
–í—ã –ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏–ª–∏: 99
–°–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–µ!
–í–≤–µ–¥–∏—Ç–µ —Å–≤–æ—é –¥–æ–≥–∞–¥–∫—É.
foo
–í–≤–µ–¥–∏—Ç–µ —Å–≤–æ—é –¥–æ–≥–∞–¥–∫—É.
61
–í—ã –ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏–ª–∏: 61
–í—ã –ø–æ–±–µ–¥–∏–ª–∏!
</code></pre>
<p>–ó–∞–º–µ—á–∞—Ç–µ–ª—å–Ω–æ! –ù–∞–º –Ω—É–∂–Ω–æ –≤–Ω–µ—Å—Ç–∏ —Ç–æ–ª—å–∫–æ –µ—â—ë –æ–¥–Ω—É –Ω–µ–±–æ–ª—å—à—É—é –ø–æ—Å–ª–µ–¥–Ω—é—é –ø—Ä–∞–≤–∫—É. –í—Å–ø–æ–º–Ω–∏–º, —á—Ç–æ –ø—Ä–æ–≥—Ä–∞–º–º–∞ –≤—Å—ë –µ—â—ë –ø–µ—á–∞—Ç–∞–µ—Ç –∑–∞–≥–∞–¥–∞–Ω–Ω–æ–µ —á–∏—Å–ª–æ. –≠—Ç–æ –±—ã–ª–æ –ø–æ–ª–µ–∑–Ω–æ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è, –Ω–æ –¥–ª—è –∏–≥—Ä—ã —ç—Ç–æ –±–µ—Å—Å–º—ã—Å–ª–µ–Ω–Ω–æ. –£–¥–∞–ª–∏–º —Å—Ç—Ä–æ—á–∫—É —Å <code>println!</code>, –∫–æ—Ç–æ—Ä–∞—è –ø–µ—á–∞—Ç–∞–µ—Ç –∑–∞–≥–∞–¥–∞–Ω–Ω–æ–µ —á–∏—Å–ª–æ. –í –õ–∏—Å—Ç–∏–Ω–≥–µ 2-6 –ø—Ä–∏–≤–µ–¥—ë–Ω –æ–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω—ã–π –∫–æ–¥ –ø—Ä–æ–≥—Ä–∞–º–º—ã.</p>
<Listing number="2-6" file-name="src/main.rs" caption="Complete guessing game code">
<pre><code class="language-rust ignore">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!("–£–≥–∞–¥–∞–π—Ç–µ —á–∏—Å–ª–æ!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    loop {
        println!("–í–≤–µ–¥–∏—Ç–µ —Å–≤–æ—é –¥–æ–≥–∞–¥–∫—É.");

        let mut guess = String::new();

        io::stdin()
            .read_line(&amp;mut guess)
            .expect("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–µ—Å—Ç—å –≤–≤–æ–¥.");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!("–í—ã –ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏–ª–∏: {guess}");

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("–°–ª–∏—à–∫–æ–º –º–∞–ª–µ–Ω—å–∫–æ–µ!"),
            Ordering::Greater =&gt; println!("–°–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–µ!"),
            Ordering::Equal =&gt; {
                println!("–í—ã –ø–æ–±–µ–¥–∏–ª–∏!");
                break;
            }
        }
    }
}</code></pre>
</Listing>
<p>–ò–≥—Ä–∞ –≥–æ—Ç–æ–≤–∞. –•–æ—Ä–æ—à–∞—è —Ä–∞–±–æ—Ç–∞, –ø–æ–∑–¥—Ä–∞–≤–ª—è–µ–º!</p>
<h2 id="–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-1"><a class="header" href="#–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-1">–ü–æ–¥–≤–µ–¥—ë–º –∏—Ç–æ–≥–∏</a></h2>
<p>–≠—Ç–æ—Ç –ø—Ä–∏–∫–ª–∞–¥–Ω–æ–π –ø—Ä–æ–µ–∫—Ç –ø–æ–∑–Ω–∞–∫–æ–º–∏–ª –≤–∞—Å —Å–æ –º–Ω–æ–≥–∏–º–∏ –∫–æ–Ω—Ü–µ–ø—Ü–∏—è–º–∏ Rust: <code>let</code>, <code>match</code>, —Ñ—É–Ω–∫—Ü–∏—è–º–∏, –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –≤–Ω–µ—à–Ω–∏—Ö –∫—Ä–µ–π—Ç–æ–≤ –∏ –º–Ω–æ–≥–∏–º –¥—Ä—É–≥–∏–º. –í –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Å–ª–µ–¥—É—é—â–∏—Ö –≥–ª–∞–≤–∞—Ö –≤—ã –∏–∑—É—á–∏—Ç–µ —ç—Ç–∞ –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏ –ø–æ–¥—Ä–æ–±–Ω–µ–µ. –ì–ª–∞–≤–∞ 3 —Ä–∞—Å—Å–∫–∞–∂–µ—Ç –æ–± –æ–±—â–∏—Ö –ø–æ–Ω—è—Ç–∏—è—Ö –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è, –ø—Ä–∏—Å—É—â–∏—Ö –∏ Rust, —Ç–∞–∫–∏—Ö –∫–∞–∫ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ, —Ç–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö –∏ —Ñ—É–Ω–∫—Ü–∏—è—Ö, –∞ —Ç–∞–∫–∂–µ –ø–æ–∫–∞–∂–µ—Ç, –∫–∞–∫ –∏—Ö –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å. –ì–ª–∞–≤–∞ 4 –ø–æ—Å–≤—è—â–µ–Ω–∞ —Å–∏—Å—Ç–µ–º–µ –≤–ª–∞–¥–µ–Ω–∏—è ‚Äî –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏ Rust, —Å–∏–ª—å–Ω–æ –≤—ã–¥–µ–ª—è—é—â–µ–π –µ–≥–æ —Å—Ä–µ–¥–∏ –¥—Ä—É–≥–∏—Ö —è–∑—ã–∫–æ–≤ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è. –í –ì–ª–∞–≤–µ 5 –æ–±—Å—É–∂–¥–∞—é—Ç—Å—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –∏ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –º–µ—Ç–æ–¥–∞, –∞ –ì–ª–∞–≤–∞ 6 –æ–±—ä—è—Å–Ω—è–µ—Ç —Ä–∞–±–æ—Ç—É —Å –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è–º–∏.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="–û–±—â–∏–µ-–ø–æ–Ω—è—Ç–∏—è-–ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è"><a class="header" href="#–û–±—â–∏–µ-–ø–æ–Ω—è—Ç–∏—è-–ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è">–û–±—â–∏–µ –ø–æ–Ω—è—Ç–∏—è –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è</a></h1>
<p>–≠—Ç–∞ –≥–ª–∞–≤–∞ –ø–æ—Å–≤—è—â–µ–Ω–∞ —Ç–µ–º –≤–µ—â–∞–º, –∫–æ—Ç–æ—Ä—ã–µ –≤—Å—Ç—Ä–µ—á–∞—é—Ç—Å—è –ø–æ–π—á—Ç–∏ –≤–æ –≤—Å–µ—Ö —è–∑—ã–∫–∞—Ö –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è, –∏ —Ç–æ–º—É, –∫–∞–∫ –æ–Ω–∏ —Ä–∞–±–æ—Ç–∞—é—Ç –≤ Rust. –ë–æ–ª—å—à–∏–Ω—Å—Ç–≤–æ —è–∑—ã–∫–æ–≤ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è –∏–º–µ—é—Ç –º–Ω–æ–≥–æ –æ–±—â–µ–≥–æ. –ù–∏ –æ–¥–Ω–∞ –∏–∑ –∏–¥–µ–π, —á—Ç–æ –±—É–¥—É—Ç –≤ —ç—Ç–æ–π –≥–ª–∞–≤–µ, –Ω–µ —è–≤–ª—è–µ—Ç—Å—è —É–Ω–∏–∫–∞–ª—å–Ω–æ–π –¥–ª—è Rust, –Ω–æ –æ–±—Å—É–∂–¥–∞—Ç—å –º—ã –∏—Ö –±—É–¥–µ–º –∏–º–µ–Ω–Ω–æ –≤ –µ–≥–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ, —Å –æ–±—ä—è—Å–Ω–µ–Ω–∏–µ–º –∏—Ö —Ä–æ–ª–∏ –∏ –ø—Ä–∞–≤–∏–ª –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è.</p>
<p>–ì–æ–≤–æ—Ä—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ, –≤—ã –∏–∑—É—á–∏—Ç–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ, –æ—Å–Ω–æ–≤–Ω—ã–µ —Ç–∏–ø—ã, —Ñ—É–Ω–∫—Ü–∏–∏, –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ—Ç–æ–∫–æ–º –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è. –≠—Ç–æ ‚Äî –æ—Å–Ω–æ–≤—ã: –≤—ã –≤—Å—Ç—Ä–µ—Ç–∏—Ç–µ –∏—Ö –≤ –∫–∞–∂–¥–æ–π –ø—Ä–æ–≥—Ä–∞–º–º–µ –Ω–∞ Rust; –æ–Ω–∏ —Å—Ç–∞–Ω—É—Ç –¥–ª—è –≤–∞—Å —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–æ–º –¥–ª—è –¥–∞–ª—å–Ω–µ–π—à–µ–π —Ä–∞–±–æ—Ç—ã.</p>
<blockquote>
<h4 id="–ö–ª—é—á–µ–≤—ã–µ-—Å–ª–æ–≤–∞"><a class="header" href="#–ö–ª—é—á–µ–≤—ã–µ-—Å–ª–æ–≤–∞">–ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞</a></h4>
<p>–í Rust, –∫–∞–∫ –∏ –≤ –ª—é–±–æ–º –¥—Ä—É–≥–æ–º —è–∑—ã–∫–µ, –æ–ø—Ä–µ–¥–µ–ª—ë–Ω –Ω–∞–±–æ—Ä <em>–∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤</em> ‚Äî —Å–ª–æ–≤, –≤—ã–¥–µ–ª–µ–Ω–Ω—ã—Ö —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ –¥–ª—è –∑–∞–ø–∏—Å–∏ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–π —è–∑—ã–∫–∞. –ü–æ–º–Ω–∏—Ç–µ, —á—Ç–æ –≤—ã –Ω–µ –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏—Ö –≤ –∫–∞—á–µ—Å—Ç–≤–µ –∏–º—ë–Ω –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –∏–ª–∏ —Ñ—É–Ω–∫—Ü–∏–π. –ú–Ω–æ–≥–∏–µ –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –∏–º–µ—é—Ç –±–æ–ª–µ–µ –æ–¥–Ω–æ–≥–æ —Å–ª—É—á–∞—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è; –≤—ã –±—É–¥–µ—Ç–µ –∏—Ö –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –¥–ª—è –º–Ω–æ–∂–µ—Å—Ç–≤–∞ —Ä–∞–∑–Ω—ã—Ö –∑–∞–¥–∞—á –≤ Rust. –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –Ω–µ –∏–º–µ—é—Ç –Ω–∏–∫–∞–∫–æ–π —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏ ‚Äî –æ–Ω–∏ –∑–∞—Ä–µ–∑–µ—Ä–≤–∏—Ä–æ–≤–∞–Ω—ã –¥–ª—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç –±—ã—Ç—å –¥–æ–±–∞–≤–ª–µ–Ω—ã –≤ Rust –≤ –±—É–¥—É—â–µ–º. –í—ã –º–æ–∂–µ—Ç–µ –Ω–∞–π—Ç–∏ —Å–ø–∏—Å–æ–∫ –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤ –≤ <a href="appendix-01-keywords.html">–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ –ê</a><!-- ignore -->.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ-–∏-–∏–∑–º–µ–Ω—è–µ–º–æ—Å—Ç—å"><a class="header" href="#–ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ-–∏-–∏–∑–º–µ–Ω—è–µ–º–æ—Å—Ç—å">–ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏ –∏–∑–º–µ–Ω—è–µ–º–æ—Å—Ç—å</a></h2>
<p>–ö–∞–∫ —É–ø–æ–º–∏–Ω–∞–ª–æ—Å—å –≤ —Ä–∞–∑–¥–µ–ª–µ <a href="ch02-00-guessing-game-tutorial.html#%D0%A5%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B9-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85">"–•—Ä–∞–Ω–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏–π —Å –ø–æ–º–æ—â—å—é –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö"</a> <!-- ignore -->, –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –Ω–µ–∏–∑–º–µ–Ω—è–µ–º—ã. –≠—Ç–æ ‚Äî –æ–¥–Ω–æ –∏–∑ —Å—Ä–µ–¥—Å—Ç–≤ Rust, –ø–æ–±—É–∂–¥–∞—é—â–µ–µ –≤–∞—Å –ø–∏—Å–∞—Ç—å –∫–æ–¥ —Ç–∞–∫, —á—Ç–æ–±—ã –æ–Ω –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –∏ –ª—ë–≥–∫–æ–≥–æ –ø–∞—Ä–∞–ª–ª–µ–ª–∏–∑–º–∞, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ–º—ã–µ —è–∑—ã–∫–æ–º. –û–¥–Ω–∞–∫–æ, –≤—ã –≤—Å—ë –∂–µ –º–æ–∂–µ—Ç–µ –¥–µ–ª–∞—Ç—å —Å–≤–æ–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏–∑–º–µ–Ω—è–µ–º—ã–º–∏. –î–∞–≤–∞–π—Ç–µ —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º, –∫–∞–∫ –∏ –ø–æ—á–µ–º—É Rust –ø–æ–±—É–∂–¥–∞–µ—Ç –≤–∞—Å –æ—Ç–¥–∞–≤–∞—Ç—å –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏–µ –Ω–µ–∏–∑–º–µ–Ω—è–µ–º–æ—Å—Ç–∏ –¥–∞–Ω–Ω—ã—Ö, –∏ –ø–æ—á–µ–º—É –≤–∞–º –∏–Ω–æ–≥–¥–∞ –º–æ–∂–µ—Ç –∑–∞—Ö–æ—Ç–µ—Ç—å—Å—è –æ—Ç–∫–∞–∑–∞—Ç—å—Å—è –æ—Ç –Ω–µ—ë.</p>
<p>–ï—Å–ª–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –Ω–µ–∏–∑–º–µ–Ω—è–µ–º–∞, —Ç–æ –æ–¥–Ω–∞–∂–¥—ã –ø—Ä–∏—Å–≤–æ–∏–≤ –µ–π –∑–Ω–∞—á–µ–Ω–∏–µ, –≤—ã –Ω–µ —Å–º–æ–∂–µ—Ç–µ –µ–≥–æ –ø–æ–º–µ–Ω—è—Ç—å. –ß—Ç–æ–±—ã –ø—Ä–æ–∏–ª–ª—é—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å —ç—Ç–æ, —Å–æ–∑–¥–∞–¥–∏–º –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ <em>projects</em> –Ω–æ–≤—ã–π –ø—Ä–æ–µ–∫—Ç <em>variables</em>. –í—ã–ø–æ–ª–Ω–∏–º –¥–ª—è —ç—Ç–æ–≥–æ –∫–æ–º–∞–Ω–¥—É <code>cargo new variables</code>.</p>
<p>–ó–∞—Ç–µ–º, –≤ –≤–∞—à–µ–π –Ω–æ–≤–æ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ <em>variables</em>, –æ—Ç–∫—Ä–æ–π—Ç–µ <em>src/main.rs</em> –∏ –∑–∞–º–µ–Ω–∏—Ç–µ –µ–≥–æ –∫–æ–¥ —Ç–µ–º, —á—Ç–æ –Ω–∏–∂–µ (–ø–æ–∫–∞ —á—Ç–æ –æ–Ω –Ω–µ –±—É–¥–µ—Ç –∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞—Ç—å—Å—è):</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    println!("–ó–Ω–∞—á–µ–Ω–∏–µ x: {x}");
    x = 6;
    println!("–ó–Ω–∞—á–µ–Ω–∏–µ x: {x}");
}</code></pre>
<p>Save and run the program using <code>cargo run</code>. You should receive an error message regarding an immutability error, as shown in this output:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         - first assignment to `x`
3 |     println!("–ó–Ω–∞—á–µ–Ω–∏–µ x: {x}");
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable
  |
help: consider making this binding mutable
  |
2 |     let mut x = 5;
  |         +++

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` (bin "variables") due to 1 previous error
</code></pre>
<p>–≠—Ç–æ—Ç –ø—Ä–∏–º–µ—Ä –¥–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä—É–µ—Ç, –∫–∞–∫ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –ø–æ–º–æ–≥–∞–µ—Ç –≤–∞–º –Ω–∞—Ö–æ–¥–∏—Ç—å –æ—à–∏–±–∫–∏ –≤ –≤–∞—à–∏—Ö –ø—Ä–æ–≥—Ä–∞–º–º–∞—Ö. –û—à–∏–±–∫–∏ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞ –º–æ–≥—É—Ç –±—ã—Ç—å –≤–≤–æ–¥—è—â–∏–º–∏ –≤ —Å—Ç—É–ø–æ—Ä, –Ω–æ –Ω–∞ –¥–µ–ª–µ –æ–Ω–∏ –≤—Å–µ–≥–æ –ª–∏—à—å –∑–Ω–∞—á–∞—Ç, —á—Ç–æ –≤–∞—à–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç –Ω–µ —Ç–∞–∫, –∫–∞–∫ –≤—ã –æ—Ç –Ω–µ—ë, —Å–∫–æ—Ä–µ–µ –≤—Å–µ–≥–æ, –æ–∂–∏–¥–∞–µ—Ç–µ. –û–Ω–∏ <em>–Ω–µ</em> –æ–∑–Ω–∞—á–∞—é—Ç, —á—Ç–æ –≤—ã ‚Äî –ø–ª–æ—Ö–æ–π –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç! –û–ø—ã—Ç–Ω—ã–µ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç—ã –Ω–∞ Rust —Ä–µ–≥—É–ª—è—Ä–Ω–æ —Å—Ç–∞–ª–∫–∏–≤–∞—é—Ç—Å—è —Å –æ—à–∏–±–∫–∞–º–∏ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞.</p>
<p>–í—ã –ø–æ–ª—É—á–∏–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ (<code>cannot assign twice to immutable variable `x`</code>), –ø–æ—Å–∫–æ–ª—å–∫—É –ø—ã—Ç–∞–µ—Ç–µ—Å—å —Å–≤—è–∑–∞—Ç—å –≤—Ç–æ—Ä–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Å –Ω–µ–∏–∑–º–µ–Ω—è–µ–º–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π <code>x</code>.</p>
<p>–≠—Ç–æ –≤–∞–∂–Ω–æ, —á—Ç–æ –º—ã –ø–æ–ª—É—á–∞–µ–º –æ—à–∏–±–∫–∏, —Å–≤—è–∑–∞–Ω–Ω—ã–µ —Å –Ω–µ–∏–∑–º–µ–Ω—è–º–æ—Å—Ç—å—é, –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏, –ø–æ—Å–∫–æ–ª—å–∫—É –æ–Ω–∏ —á–∞—Å—Ç–æ —Å—Ç–∞–Ω–æ–≤—è—Ç—Å—è –ø—Ä–∏—á–∏–Ω–æ–π —Ä–∞–∑–Ω—ã—Ö –±–∞–≥–æ–≤. –ï—Å–ª–∏ –æ–¥–Ω–∞ —á–∞—Å—Ç—å –Ω–∞—à–µ–≥–æ –∫–æ–¥–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç –≤ –ø—Ä–µ–¥–ø–æ–ª–æ–∂–µ–Ω–∏–∏ –æ —Ç–æ–º, –¥–∞–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –∏–∑–º–µ–Ω–∏—Ç—Å—è, –Ω–æ –¥—Ä—É–≥–∞—è —á–∞—Å—Ç—å –∫–æ–¥–∞ —ç—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ –º–µ–Ω—è–µ—Ç, —Ç–æ –ø–µ—Ä–≤–∞—è —á–∞—Å—Ç—å –Ω–∞–≤–µ—Ä–Ω—è–∫–∞ –±—É–¥–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –Ω–µ —Ç–∞–∫, –∫–∞–∫ –∑–∞–¥—É–º–∞–Ω–æ. –ü—Ä–∏—á–∏–Ω—É –ø–æ–¥–æ–±–Ω—ã—Ö –±–∞–≥–æ–≤, –∫–æ–≥–¥–∞ –æ–Ω–∏ –ø—Ä–æ—è–≤–ª—è—é—Ç —Å–µ–±—è, –±—ã–≤–∞–µ—Ç –æ—á–µ–Ω—å —Ç—è–∂–µ–ª–æ –æ—Ç—ã—Å–∫–∞—Ç—å ‚Äî –æ—Å–æ–±–µ–Ω–Ω–æ, –µ—Å–ª–∏ –≤—Ç–æ—Ä–∞—è —á–∞—Å—Ç—å –∫–æ–¥–∞ –≤—Ç–æ—Ä–≥–∞–µ—Ç—Å—è –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é <em>–ª–∏—à—å –∏–Ω–æ–≥–¥–∞</em>. –ö–æ–º–ø–∏–ª—è—Ç–æ—Ä Rust –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç, —á—Ç–æ –µ—Å–ª–∏ –≤—ã —É–∫–∞–∑–∞–ª–∏, —á—Ç–æ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –Ω–µ –∏–∑–º–µ–Ω–∏—Ç—Å—è, –æ–Ω–∞ –≤ —Å–∞–º–æ–º –¥–µ–ª–µ –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –∏–∑–º–µ–Ω–∏—Ç—Å—è, —Ç–∞–∫ —á—Ç–æ –≤–∞–º –Ω–µ –Ω—É–∂–Ω–æ –ø–æ—Å—Ç–æ—è–Ω–Ω–æ –¥–µ—Ä–∂–∞—Ç—å –≤ –≥–æ–ª–æ–≤–µ –ø–∞–º—è—Ç—å –æ —Ç–æ–º, —á—Ç–æ –º–æ–∂–µ—Ç –∏–∑–º–µ–Ω—è—Ç—å—Å—è, –∞ —á—Ç–æ ‚Äî –Ω–µ—Ç. –í–∞—à –∫–æ–¥ —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –±–∞–Ω–∞–ª—å–Ω–æ –ø—Ä–æ—â–µ –ø–æ–Ω–∏–º–∞—Ç—å.</p>
<p>–û–¥–Ω–∞–∫–æ –∏–∑–º–µ–Ω—è–µ–º–æ—Å—Ç—å —Ç–æ–∂–µ –∫—Ä–∞–π–Ω–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–∞; –æ–Ω–∞ —Ç–æ–∂–µ –Ω—É–∂–Ω–∞, —á—Ç–æ–±—ã –ø–∏—Å–∞—Ç—å –ø—Ä–æ—Å—Ç–æ–π –∏ —è—Å–Ω—ã–π –∫–æ–¥. –•–æ—Ç—è –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –Ω–µ–∏–∑–º–µ–Ω—è–µ–º—ã, –≤—ã –º–æ–∂–µ—Ç–µ —Å–¥–µ–ª–∞—Ç—å –∏—Ö –∏–∑–º–µ–Ω—è–µ–º—ã–º–∏, –¥–æ–±–∞–≤–∏–≤ –ø–µ—Ä–µ–¥ –Ω–∞–∑–≤–∞–Ω–∏–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π <code>mut</code> ‚Äî –ø—Ä—è–º–æ –∫–∞–∫ –≤—ã –¥–µ–ª–∞–ª–∏ –≤ <a href="ch02-00-guessing-game-tutorial.html#%D0%A5%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B9-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85">–ì–ª–∞–≤–µ 2</a><!-- ignore -->. –î–æ–±–∞–≤–ª–µ–Ω–∏–µ <code>mut</code> —Ç–∞–∫–∂–µ —Å–ª—É–∂–∏—Ç –∫–∞–∫ –º–∞—Ä–∫–µ—Ä –±—É–¥—É—â–∏–º —á–∏—Ç–∞—Ç–µ–ª—è–º –≤–∞—à–µ–≥–æ –∫–æ–¥–∞: –æ–Ω –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç, —á—Ç–æ –¥—Ä—É–≥–∏v —á–∞—Å—Ç—è–º –∫–æ–¥–∞ –º–æ–∂–Ω–æ –∏–∑–º–µ–Ω—è—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ —ç—Ç–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π.</p>
<p>–ù–∞–ø—Ä–∏–º–µ—Ä, –¥–∞–≤–∞–π—Ç–µ –ø–æ–º–µ–Ω—è–µ–º <em>src/main.rs</em> –≤–æ—Ç —Ç–∞–∫:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut x = 5;
    println!("–ó–Ω–∞—á–µ–Ω–∏–µ x: {x}");
    x = 6;
    println!("–ó–Ω–∞—á–µ–Ω–∏–µ x: {x}");
}</code></pre></pre>
<p>–ö–æ–≥–¥–∞ –º—ã —Ç–µ–ø–µ—Ä—å –∑–∞–ø—É—Å—Ç–∏–º –ø—Ä–æ–≥—Ä–∞–º–º—É, –º—ã —É–≤–∏–¥–∏–º:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
–ó–Ω–∞—á–µ–Ω–∏–µ x: 5
–ó–Ω–∞—á–µ–Ω–∏–µ x: 6
</code></pre>
<p>–ú—ã —Å–º–æ–≥–ª–∏ –ø–æ–º–µ–Ω—è—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ, —Å–≤—è–∑–∞–Ω–Ω–æ–µ —Å <code>x</code>, —Å <code>5</code> –Ω–∞ <code>6</code>, –ø–æ—Å–∫–æ–ª—å–∫—É –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ <code>mut</code>. –í –∫–æ–Ω–µ—á–Ω–æ–º —Å—á—ë—Ç–µ, –≤–æ–ø—Ä–æ—Å –æ–± –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ –∏–∑–º–µ–Ω—è–µ–º–æ—Å—Ç–∏ –æ—Å—Ç–∞—ë—Ç—Å—è –∑–∞ –≤–∞–º–∏ –∏ –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è —Ç–µ–º, –∫–∞–∫–æ–µ —Ä–µ—à–µ–Ω–∏–µ, –ø–æ –≤–∞—à–µ–º—É –º–Ω–µ–Ω–∏—é, –±—É–¥–µ—Ç —á–∏—â–µ.</p>
<h3 id="–ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã"><a class="header" href="#–ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã">–ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã</a></h3>
<p>–ö–∞–∫ –∏ –Ω–µ–∏–∑–º–µ–Ω—è–µ–º—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ, <em>–∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã</em> ‚Äî —ç—Ç–æ –ø—Ä–∏–≤—è–∑–∞–Ω–Ω—ã–µ –∫ –∏–º–µ–Ω–∏ –Ω–µ–∏–∑–º–µ–Ω—è–µ–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è. –û–¥–Ω–∞–∫–æ, –º–µ–∂–¥—É –∫–æ–Ω—Å—Ç–∞–Ω—Ç–∞–º–∏ –∏ –Ω–µ–∏–∑–º–µ–Ω—è–µ–º—ã–º–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–º–∏ —Ä–∞–∑–Ω–∏—Ü–∞ –µ—Å—Ç—å.</p>
<p>–í–æ-–ø–µ—Ä–≤—ã—Ö, –≤—ã –Ω–µ –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å <code>mut</code> —Å –∫–æ–Ω—Å—Ç–∞–Ω—Ç–∞–º–∏. –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –Ω–µ –ø—Ä–æ—Å—Ç–æ –Ω–µ–∏–∑–º–µ–Ω—è–µ–º—ã –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é ‚Äî –æ–Ω–∏ –≤–æ–æ–±—â–µ –Ω–µ–∏–∑–º–µ–Ω—è–µ–º—ã, –≤—Å–µ–≥–¥–∞. –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –æ–±—ä—è–≤–ª—è—é—Ç—Å—è —Å –ø–æ–º–æ—â—å—é –∫–ª—é—á–µ–≤–æ–≥–æ —Å–ª–æ–≤–∞ <code>const</code> (–≤–º–µ—Å—Ç–æ –∫–ª—é—á–µ–≤–æ–≥–æ —Å–ª–æ–≤–∞ <code>let</code>), –∞ —Ç–∞–∫–∂–µ –æ–Ω–∏ <em>–¥–æ–ª–∂–Ω—ã</em> –±—ã—Ç—å –∞–Ω–Ω–æ—Ç–∏—Ä–æ–≤–∞–Ω—ã —Ç–∏–ø–æ–º. –ú—ã —Ä–∞—Å—Å–∫–∞–∂–µ–º –ø–æ–¥—Ä–æ–±–Ω–µ–µ –æ —Ç–∏–ø–∞—Ö –∏ –∞–Ω–Ω–æ—Ç–∞—Ü–∏—è—Ö —Ç–∏–ø–∞ –≤ —Å–ª–µ–¥—É—é—â–µ–º —Ä–∞–∑–¥–µ–ª–µ ‚Äî <a href="ch03-02-data-types.html#%D0%A2%D0%B8%D0%BF%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85">"–¢–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö"</a><!-- ignore -->; —Ç–∞–∫ —á—Ç–æ –ø–æ–∫–∞ —á—Ç–æ –Ω–µ –∑–∞–¥—É–º—ã–≤–∞–π—Ç–µ—Å—å –º–Ω–æ–≥–æ –æ –¥–µ—Ç–∞–ª—è—Ö. –ü—Ä–æ—Å—Ç–æ –ø–æ–º–Ω–∏—Ç–µ, —á—Ç–æ –≤—ã –æ–±—è–∑–∞–Ω—ã –∞–Ω–Ω–æ—Ç–∏—Ä–æ–≤–∞—Ç—å —Ç–∏–ø –∫–æ–Ω—Å—Ç–∞–Ω—Ç.</p>
<p>–ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –º–æ–≥—É—Ç –±—ã—Ç—å –æ–±—ä—è–≤–ª–µ–Ω—ã –≤ –ª—é–±–æ–π –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏, –≤ —Ç–æ–º —á–∏—Å–ª–µ –∏ –≤ –≥–ª–æ–±–∞–ª—å–Ω–æ–π, —á—Ç–æ –¥–µ–ª–∞–µ—Ç –∏—Ö –ø–æ–ª–µ–∑–Ω—ã–º–∏ –¥–ª—è –æ–±—ä—è–≤–ª–µ–Ω–∏—è –∑–Ω–∞—á–µ–Ω–∏–π, –∫–æ—Ç–æ—Ä—ã–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –≤ –ø—Ä–æ–≥—Ä–∞–º–º–µ –ø–æ–≤—Å–µ–º–µ—Å—Ç–Ω–æ.</p>
<p>–ü–æ—Å–ª–µ–¥–Ω–µ–µ –æ—Ç–ª–∏—á–∏–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç –æ—Ç –Ω–µ–∏–∑–º–µ–Ω—è–µ–º—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö —Å–æ—Å—Ç–æ–∏—Ç –≤ —Ç–æ–º, —á—Ç–æ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã –º–æ–≥—É—Ç —Å–≤—è–∑—ã–≤–∞—Ç—å—Å—è —Ç–æ–ª—å–∫–æ —Å –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã–º–∏ –≤—ã—Ä–∞–∂–µ–Ω–∏—è–º–∏ ‚Äî —Ç–æ –µ—Å—Ç—å —Ç–∞–∫–∏–º–∏, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç –±—ã—Ç—å –≤—ã—á–∏—Å–ª–µ–Ω—ã –Ω–∞ —ç—Ç–∞–ø–µ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏.</p>
<p>–í–æ—Ç –ø—Ä–∏–º–µ—Ä –æ–±—ä—è–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
<span class="boring">}</span></code></pre></pre>
<p>The constant‚Äôs name is <code>THREE_HOURS_IN_SECONDS</code> and its value is set to the result of multiplying 60 (the number of seconds in a minute) by 60 (the number of minutes in an hour) by 3 (the number of hours we want to count in this program). Rust‚Äôs naming convention for constants is to use all uppercase with underscores between words. The compiler is able to evaluate a limited set of operations at compile time, which lets us choose to write out this value in a way that‚Äôs easier to understand and verify, rather than setting this constant to the value 10,800. See the <a href="../reference/const_eval.html">Rust Reference‚Äôs section on constant evaluation</a> for more information on what operations can be used when declaring constants.</p>
<p>–ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã —Å—É—â–µ—Å—Ç–≤—É—é—Ç –≤ –ø–∞–º—è—Ç–∏ –≤ —Ç–µ—á–µ–Ω–∏–µ –≤—Å–µ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è –ø—Ä–æ–≥—Ä–∞–º–º—ã ‚Äî –≤ —Ç–æ–π –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏, –≤ –∫–æ—Ç–æ—Ä–æ–π –±—ã–ª–∏ –æ–±—ä—è–≤–ª–µ–Ω—ã. –≠—Ç–æ —Å–≤–æ–π—Å—Ç–≤–æ –¥–µ–ª–∞–µ—Ç –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã –ø–æ–ª–µ–∑–Ω—ã–º–∏ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –∑–Ω–∞—á–µ–Ω–∏–π –≤ –ø—Ä–æ–≥—Ä–∞–º–º–µ, –º–Ω–æ–≥–∏–º —á–∞—Å—Ç—è–º –∫–æ—Ç–æ—Ä–æ–π –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –∑–Ω–∞—Ç—å, –Ω–∞–ø—Ä–∏–º–µ—Ä, —Å–∫–æ—Ä–æ—Å—Ç—å —Å–≤–µ—Ç–∞ –∏–ª–∏ –æ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–µ –æ—á–∫–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–∂–µ—Ç –ø–æ–ª—É—á–∏—Ç—å –∏–≥—Ä–æ–∫.</p>
<p>–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç –¥–ª—è –∏–º–µ–Ω–æ–≤–∞–Ω–∏—è –∂—ë—Å—Ç–∫–æ –∑–∞–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π, –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã—Ö –≤ –≤–∞—à–µ–π –ø—Ä–æ–≥—Ä–∞–º–º–µ —Ç—É—Ç –∏ —Ç–∞–º, —Ç–∞–∫–∂–µ –ø–æ–ª–µ–∑–Ω–æ —Ç–µ–º, —á—Ç–æ –≤—Å–µ, –∫—Ç–æ –±—É–¥—É—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –Ω–∞–¥ –≤–∞—à–∏–º –∫–æ–¥–æ–º, –±—É–¥—É—Ç –∏–º–µ—Ç—å –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –æ —Å–º—ã—Å–ª–µ –≤—Å—Ç—Ä–µ—á–∞—é—â–∏—Ö—Å—è –∑–Ω–∞—á–µ–Ω–∏–π. –≠—Ç–∞ –∂–µ –ø—Ä–∞–∫—Ç–∏–∫–∞ –ø–æ–∑–≤–æ–ª—è–µ—Ç –≤—ã–¥–µ–ª—è—Ç—å –≤ –æ–¥–Ω–æ –º–µ—Å—Ç–æ —Ç–∞–∫–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è, –∫–æ—Ç–æ—Ä—ã–µ –∂—ë—Å—Ç–∫–æ –∫–æ–¥–∏—Ä—É—é—Ç—Å—è, –Ω–æ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ –º–æ–≥—É—Ç –∏–∑–º–µ–Ω–∏—Ç—å—Å—è –≤ –±—É–¥—É—â–µ–º.</p>
<h3 id="–ó–∞—Ç–µ–Ω–µ–Ω–∏–µ"><a class="header" href="#–ó–∞—Ç–µ–Ω–µ–Ω–∏–µ">–ó–∞—Ç–µ–Ω–µ–Ω–∏–µ</a></h3>
<p>–ö–∞–∫ –≤—ã —É–≤–∏–¥–µ–ª–∏ –≤ <a href="ch02-00-guessing-game-tutorial.html#%D0%A1%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B4%D0%BE%D0%B3%D0%B0%D0%B4%D0%BA%D0%B8-%D1%81-%D0%B7%D0%B0%D0%B3%D0%B0%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D0%BC-%D1%87%D0%B8%D1%81%D0%BB%D0%BE%D0%BC">–ì–ª–∞–≤–µ 2</a> <!-- ignore -->,–≤—ã –º–æ–∂–µ—Ç–µ –æ–±—ä—è–≤–∏—Ç—å –Ω–æ–≤—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é —Å —Ç–µ–º –∂–µ –∏–º–µ–Ω–µ–º, –∫–æ—Ç–æ—Ä–æ–µ –Ω–æ—Å–∏—Ç —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è. –°—á–∏—Ç–∞–µ—Ç—Å—è, —á—Ç–æ —Å—Ç–∞—Ä–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è <em>–∑–∞—Ç–µ–Ω—è–µ—Ç—Å—è</em> –Ω–æ–≤–æ–π, —á—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –ø—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ –¥–∞–Ω–Ω–æ–≥–æ –∏–º–µ–Ω–∏ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –±—É–¥–µ—Ç –∏—Å–∫–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –∏–º–µ–Ω–Ω–æ –≤ –Ω–æ–≤–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π. –°—Ç–∞—Ä–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –Ω–µ –±—É–¥–µ—Ç –≤–∏–¥–Ω–∞ –¥–æ —Ç–µ—Ö –ø–æ—Ä, –ø–æ–∫–∞ –Ω–µ –∑–∞–∫–æ–Ω—á–∏—Ç—Å—è –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ –Ω–æ–≤–æ–π. –ö—Ä–æ–º–µ —Ç–æ–≥–æ, –∑–∞—Ç–µ–Ω—è—é—â–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è —Å–∞–º–∞ –º–æ–∂–µ—Ç –±—ã—Ç—å –∑–∞—Ç–µ–Ω—ë–Ω–Ω–æ–π. –ú—ã –º–æ–∂–µ–º –∑–∞—Ç–µ–Ω–∏—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é, –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–≤ –µ—ë –∂–µ –∏–º—è –∏ –ø–æ–≤—Ç–æ—Ä–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–≤ –µ–≥–æ —Å –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–æ–º <code>let</code>; –≤–æ—Ç —Ç–∞–∫:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("–ó–Ω–∞—á–µ–Ω–∏–µ x –≤–æ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–π –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏: {x}");
    }

    println!("–ó–Ω–∞—á–µ–Ω–∏–µ x: {x}");
}</code></pre></pre>
<p>–°–Ω–∞—á–∞–ª–∞, —ç—Ç–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∞ —Å–≤—è–∑—ã–≤–∞–µ—Ç <code>x</code> —Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º <code>5</code>. –ó–∞—Ç–µ–º –æ–Ω–∞ —Å–æ–∑–¥–∞—ë—Ç –Ω–æ–≤—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é <code>x</code>, –ø–æ–≤—Ç–æ—Ä–Ω–æ –∏—Å–ø–æ–ª—å–∑—É—è –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏—é <code>let x =</code>, –ø—Ä–∏—Å–≤–∞–∏–≤–∞—è –Ω–æ–≤–æ–≥–æ <code>x</code> –∑–Ω–∞—á–µ–Ω–∏–µ —Å—Ç–∞—Ä–æ–≥–æ <code>x</code> –∏ –ø—Ä–∏–±–∞–≤–ª—è—è –∫ –Ω–µ–º—É <code>1</code>; –Ω–æ–≤—ã–π <code>x</code> —Ç–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º –∏–º–µ–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ <code>6</code> . –ó–∞—Ç–µ–º, –≤–æ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–π –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏, —Å–æ–∑–¥–∞–≤–∞–µ–º–æ–π —Ñ–∏–≥—É—Ä–Ω—ã–º–∏ —Å–∫–æ–±–∫–∞–º–∏, —Ç—Ä–µ—Ç—å—é –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é <code>let</code> —Ç–∞–∫–∂–µ –∑–∞—Ç–µ–Ω—è–µ—Ç <code>x</code> –∏ —Å–æ–∑–¥–∞—ë—Ç –Ω–æ–≤—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é, —É–º–Ω–æ–∂–∞—è –ø—Ä–µ–¥—ã–¥—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–∞ <code>2</code> –∏ –ø—Ä–∏–ø–∏—Å—ã–≤–∞—è —Ç–µ–º —Å–∞–º—ã–º –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π <code>x</code> –∑–Ω–∞—á–µ–Ω–∏–µ <code>12</code>. –ö–æ–≥–¥–∞ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∑–∞–∫–∞–Ω—á–∏–≤–∞–µ—Ç—Å—è, –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ –∑–∞—Ç–µ–Ω–µ–Ω–∏–µ —Ç–∞–∫–∂–µ –∑–∞–∫–∞–Ω—á–∏–≤–∞–µ—Ç—Å—è, –∏ <code>x</code> –æ–±—Ä–∞—Ç–Ω–æ —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è —Ä–∞–≤–Ω—ã–º <code>6</code>. –ï—Å–ª–∏ –º—ã –∑–∞–ø—É—Å—Ç–∏–º –ø—Ä–æ–≥—Ä–∞–º–º—É, –µ—ë –≤—ã–≤–æ–¥ –±—É–¥–µ—Ç —Ç–∞–∫–æ–≤:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
–ó–Ω–∞—á–µ–Ω–∏–µ x –≤–æ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–π –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏: 12
–ó–Ω–∞—á–µ–Ω–∏–µ x: 6
</code></pre>
<p>–≠—Ñ—Ñ–µ–∫—Ç –∑–∞—Ç–µ–Ω–µ–Ω–∏—è –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è –æ—Ç —Ç–æ–≥–æ, —á—Ç–æ–±—ã –æ–±–æ–∑–Ω–∞—á–∏—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –∫–∞–∫ <code>mut</code>, –ø–æ—Å–∫–æ–ª—å–∫—É –º—ã –ø–æ–ª—É—á–∏–º –æ—à–∏–±–∫—É –≤—Ä–µ–º–µ–Ω–∏ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏, –µ—Å–ª–∏ —Å–ª—É—á–∞–π–Ω–æ –ø–æ–ø—ã—Ç–∞–µ–º—Å—è –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ —ç—Ç–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –±–µ–∑ –∫–ª—é—á–µ–≤–æ–≥–æ —Å–ª–æ–≤–∞ <code>let</code>. –ò—Å–ø–æ–ª—å–∑—É—è <code>let</code>, –º—ã –º–æ–∂–µ–º –ø—Ä–æ–≤–µ—Å—Ç–∏ –Ω–µ–±–æ–ª—å—à–∏–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –∑–Ω–∞—á–µ–Ω–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π, —Å–æ—Ö—Ä–∞–Ω—è—è –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –Ω–µ–∏–∑–º–µ–Ω—è–µ–º–æ–π –ø–æ—Å–ª–µ —ç—Ç–∏—Ö –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–π.</p>
<p>–î—Ä—É–≥–∏–º –æ—Ç–ª–∏—á–∏–µ–º –º–µ–∂–¥—É <code>mut</code> –∏ –∑–∞—Ç–µ–Ω–µ–Ω–∏–µ–º —è–≤–ª—è–µ—Ç—Å—è —Ç–æ, —á—Ç–æ –ø–æ—Å–∫–æ–ª—å–∫—É –º—ã, –ø–æ —Å—É—Ç–∏, —Å–æ–∑–¥–∞—ë–º –Ω–æ–≤—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é (–ø–æ—Å–∫–æ–ª—å–∫—É –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ <code>let</code>), –º—ã –º–æ–∂–µ–º –ø–æ–º–µ–Ω—è—Ç—å —Ç–∏–ø –∑–Ω–∞—á–µ–Ω–∏—è, –Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–æ –∂–µ —Å–∞–º–æ–µ –∏–º—è –¥–ª—è —Å–≤—è–∑–∞–Ω–Ω–æ–π —Å –Ω–∏–º –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π. –ù–∞–ø—Ä–∏–º–µ—Ä, –¥–æ–ø—É—Å—Ç–∏–º, –Ω–∞—à–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∞ —Å–ø—Ä–∞—à–∏–≤–∞–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, —Å–∫–æ–ª—å–∫–∏–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º –ø—Ä–æ–±–µ–ª–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Ö–æ—á–µ—Ç –æ—Ç–±–∏—Ç—å –Ω–µ–∫–æ—Ç–æ—Ä—ã–π —Ç–µ–∫—Å—Ç, –∏ –ø—Ä–æ—Å–∏—Ç –¥–ª—è —ç—Ç–æ–≥–æ —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–µ–ø–æ—Å—Ä–µ–¥—Å—Ç–≤–µ–Ω–Ω–æ –Ω—É–∂–Ω—ã–µ –Ω–µ—Å–∫–æ–ª—å–∫–æ –∑–Ω–∞–∫–æ–≤ –ø—Ä–æ–±–µ–ª–∞. –ú—ã –º–æ–∂–µ–º —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–≤–µ–¥—ë–Ω–Ω—ã—Ö –ø—Ä–æ–±–µ–ª–æ–≤ –≤ –≤–∏–¥–µ —á–∏—Å–ª–∞ –≤–æ—Ç —Ç–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let spaces = "   ";
    let spaces = spaces.len();
<span class="boring">}</span></code></pre></pre>
<p>–ü–µ—Ä–≤–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è <code>spaces</code> –∏–º–µ–µ—Ç —Å—Ç—Ä–æ–∫–æ–≤—ã–π —Ç–∏–ø, –∞ –≤—Ç–æ—Ä–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è <code>spaces</code> –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Å–æ–±–æ–π —á–∏—Å–ª–æ. –° –∑–∞—Ç–µ–Ω–µ–Ω–∏–µ–º –º—ã –º–æ–∂–µ–º –Ω–µ —Å–æ–∑–¥–∞–≤–∞—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö —Å –Ω–∞–∑–≤–∞–Ω–∏—è–º–∏ –≤—Ä–æ–¥–µ <code>spaces_str</code> –∏ <code>spaces_num</code>. –í–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ –º—ã –º–æ–∂–µ–º —Å–¥–µ–ª–∞—Ç—å –ø—Ä–æ—â–µ: –ø—Ä–æ—Å—Ç–æ –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏–º—è <code>spaces</code>. –ë–æ–ª–µ–µ —Ç–æ–≥–æ: –µ—Å–ª–∏ –º—ã –ø–æ–ø—Ä–æ–±—É–µ–º —Ä–µ—à–∏—Ç—å –Ω–∞—à—É –∑–∞–¥–∞—á—É —Å –ø–æ–º–æ—â—å—é <code>mut</code>, –∫–∞–∫ –ø–æ–∫–∞–∑–∞–Ω–æ –Ω–∏–∂–µ, —Ç–æ –º—ã –ø–æ–ª—É—á–∏–º –æ—à–∏–±–∫—É –∫–æ–º–ø–∏–ª—è—Ü–∏–∏:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut spaces = "   ";
    spaces = spaces.len();
<span class="boring">}</span></code></pre>
<p>–û—à–∏–±–∫–∞ —Å–æ–æ–±—â–∞–µ—Ç, —á—Ç–æ –º—ã –Ω–µ –º–æ–∂–µ–º –∏–∑–º–µ–Ω—è—Ç—å —Ç–∏–ø –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 --&gt; src/main.rs:3:14
  |
2 |     let mut spaces = "   ";
  |                      ----- expected due to this value
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&amp;str`, found `usize`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `variables` (bin "variables") due to 1 previous error
</code></pre>
<p>–¢–µ–ø–µ—Ä—å –º—ã –∑–Ω–∞–µ–º, –∫–∞–∫ —Ä–∞–±–æ—Ç–∞—é—Ç –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ. –î–∞–≤–∞–π—Ç–µ —Ç–µ–ø–µ—Ä—å –ø–æ–¥—Ä–æ–±–Ω–µ–µ –ø–æ—Å–º–æ—Ç—Ä–∏–º –Ω–∞ —Ç–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö, –∫–æ—Ç–æ—Ä—ã–µ —ç—Ç–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –º–æ–≥—É—Ç —Ö—Ä–∞–Ω–∏—Ç—å.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–¢–∏–ø—ã-–¥–∞–Ω–Ω—ã—Ö"><a class="header" href="#–¢–∏–ø—ã-–¥–∞–Ω–Ω—ã—Ö">–¢–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö</a></h2>
<p>–ö–∞–∂–¥–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –≤ Rust –∏–º–µ–µ—Ç –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã–π <em>—Ç–∏–ø –¥–∞–Ω–Ω—ã—Ö</em>, —Å–æ–æ–±—â–∞—é—â–∏–π –æ —Ç–æ–º, —á—Ç–æ —ç—Ç–æ –∑–∞ –∑–Ω–∞—á–µ–Ω–∏–µ –∏ –∫–∞–∫ —Å –Ω–∏–º —Ä–∞–±–æ—Ç–∞—Ç—å. –ú—ã –ø–æ—Å–º–æ—Ç—Ä–∏–º –Ω–∞ –¥–≤–µ –≥—Ä—É–ø–ø—ã —Ç–∏–ø–æ–≤ –¥–∞–Ω–Ω—ã—Ö: –Ω–µ–¥–µ–ª–∏–º—ã–µ –∏ —Å–æ—Å—Ç–∞–≤–Ω—ã–µ.</p>
<p>–ù–µ –∑–∞–±—ã–≤–∞–π—Ç–µ, —á—Ç–æ Rust ‚Äî —è–∑—ã–∫ —Å–æ <em>—Å—Ç–∞—Ç–∏—á–µ—Å–∫–æ–π —Ç–∏–ø–∏–∑–∞—Ü–∏–µ–π</em>. –≠—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ —Ç–∏–ø—ã –≤—Å–µ—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –∏–∑–≤–µ—Å—Ç–Ω—ã —É–∂–µ –Ω–∞ —ç—Ç–∞–ø–µ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏. –ö–æ–º–ø–∏–ª—è—Ç–æ—Ä –æ–±—ã—á–Ω–æ –º–æ–∂–µ—Ç —Å–∞–º–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω–æ –≤—ã–≤–µ—Å—Ç–∏ —Ç–∏–ø –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π, –æ—Å–Ω–æ–≤—ã–≤–∞—è—Å—å –Ω–∞ –µ—ë –∑–Ω–∞—á–µ–Ω–∏–∏ –∏ —Ç–æ–º, –∫–∞–∫ –æ–Ω–∞ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è. –í —Ç–µ—Ö —Å–ª—É—á–∞—è—Ö, –∫–æ–≥–¥–∞ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –Ω–µ –º–æ–∂–µ—Ç –≤—ã–≤–µ—Å—Ç–∏ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —Ç–∏–ø (–Ω–∞–ø—Ä–∏–º–µ—Ä, –∫–∞–∫ –≤ —Ç–æ–º —Å–ª—É—á–∞–µ, –∫–æ–≥–¥–∞ –º—ã –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤—ã–≤–∞–ª–∏ <code>String</code> –∫ —á–∏—Å–ª–µ–Ω–Ω–æ–º—É —Ç–∏–ø—É –¥–∞–Ω–Ω—ã—Ö –º–µ—Ç–æ–¥–æ–º <code>parse</code> –≤ —Ä–∞–∑–¥–µ–ª–µ <a href="ch02-00-guessing-game-tutorial.html#%D0%A1%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B4%D0%BE%D0%B3%D0%B0%D0%B4%D0%BA%D0%B8-%D1%81-%D0%B7%D0%B0%D0%B3%D0%B0%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D0%BC-%D1%87%D0%B8%D1%81%D0%BB%D0%BE%D0%BC">"–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –¥–æ–≥–∞–¥–∫–∏ —Å –∑–∞–≥–∞–¥–∞–Ω–Ω—ã–º —á–∏—Å–ª–æ–º"</a><!-- ignore --> –ì–ª–∞–≤—ã 2), –º—ã –¥–æ–ª–∂–Ω—ã —è–≤–Ω–æ –∞–Ω–Ω–æ—Ç–∏—Ä–æ–≤–∞—Ç—å —Ç–∏–ø; –≤–æ—Ç —Ç–∞–∫:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let guess: u32 = "42".parse().expect("–ù–µ —á–∏—Å–ª–æ!");
<span class="boring">}</span></code></pre></pre>
<p>–ï—Å–ª–∏ –º—ã –Ω–µ –¥–æ–±–∞–≤–∏–º –∞–Ω–Ω–æ—Ç–∞—Ü–∏—é —Ç–∏–ø–∞ (<code>: u32</code>) –≤ –∫–æ–¥–µ –≤—ã—à–µ, Rust —Å–æ–æ–±—â–∏—Ç –æ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–π –æ—à–∏–±–∫–µ, –æ–∑–Ω–∞—á–∞—é—â–µ–π, —á—Ç–æ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä—É –Ω—É–∂–Ω–æ –±–æ–ª—å—à–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –≤—ã–≤–æ–¥–∞ —Ç–∏–ø–∞:</p>
<pre><code class="language-console">$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0284]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("–ù–µ —á–∏—Å–ª–æ!");
  |         ^^^^^        ----- type must be known at this point
  |
  = note: cannot satisfy `&lt;_ as FromStr&gt;::Err == _`
help: consider giving `guess` an explicit type
  |
2 |     let guess: /* Type */ = "42".parse().expect("–ù–µ —á–∏—Å–ª–æ!");
  |              ++++++++++++

For more information about this error, try `rustc --explain E0284`.
error: could not compile `no_type_annotations` (bin "no_type_annotations") due to 1 previous error
</code></pre>
<p>–î–ª—è –¥—Ä—É–≥–∏—Ö —Ç–∏–ø–æ–≤ –¥–∞–Ω–Ω—ã—Ö –∞–Ω–Ω–æ—Ç–∞—Ü–∏–∏ –±—É–¥—É—Ç —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ –æ—Ç–ª–∏—á–∞—Ç—å—Å—è.</p>
<h3 id="–ù–µ–¥–µ–ª–∏–º—ã–µ-—Ç–∏–ø—ã"><a class="header" href="#–ù–µ–¥–µ–ª–∏–º—ã–µ-—Ç–∏–ø—ã">–ù–µ–¥–µ–ª–∏–º—ã–µ —Ç–∏–ø—ã</a></h3>
<p><em>–ù–µ–¥–µ–ª–∏–º—ã–π</em> —Ç–∏–ø –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç –æ–¥–∏—á–Ω–æ—á–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ. Rust –∏–º–µ–µ—Ç —á–µ—Ç—ã—Ä–µ –±–∞–∑–æ–≤—ã—Ö –Ω–µ–¥–µ–ª–∏–º—ã—Ö —Ç–∏–ø–∞: —Ü–µ–ª—ã–µ —á–∏—Å–ª–∞, —á–∏—Å–ª–∞ —Å –ø–ª–∞–≤–∞—é—â–µ–π —Ç–æ—á–∫–æ–π, –ª–æ–≥–∏—á–µ—Å–∫–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è, –∞ —Ç–∞–∫–∂–µ —Å–∏–º–≤–æ–ª—ã. –û–Ω–∏ –º–æ–≥—É—Ç –≤–∞–º –ø–æ–∫–∞–∑–∞—Ç—å—Å—è –∑–Ω–∞–∫–æ–º—ã–º–∏ –ø–æ –¥—Ä—É–≥–∏–º —è–∑—ã–∫–∞–º –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è. –ü–æ—Å–º–æ—Ç—Ä–∏–º, –∫–∞–∫ –æ–Ω–∏ –≤—Å–µ —Ä–∞–±–æ—Ç–∞—é—Ç –≤ Rust.</p>
<h4 id="–¶–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã–µ-—Ç–∏–ø—ã"><a class="header" href="#–¶–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã–µ-—Ç–∏–ø—ã">–¶–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã–µ —Ç–∏–ø—ã</a></h4>
<p><em>–¶–µ–ª–æ–µ</em> —á–∏—Å–ª–æ ‚Äî —ç—Ç–æ —á–∏—Å–ª–æ –±–µ–∑ –¥—Ä–æ–±–Ω–æ–π —á–∞—Å—Ç–∏. –ú—ã —É–∂–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ –æ–¥–∏–Ω —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã–π —Ç–∏–ø: –≤ –ì–ª–∞–≤–µ 2 –Ω–∞–º –ø–æ–Ω–∞–¥–æ–±–∏–ª—Å—è —Ç–∏–ø <code>u32</code>. –≠—Ç–æ –∏–º—è —Ç–∏–ø–∞ —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ —Ç–æ, —á—Ç–æ –æ–Ω –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ —ç—Ç–æ–≥–æ —Ç–∏–ø–∞ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—Ç –±–µ–∑–∑–Ω–∞–∫–æ–≤–æ–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ (–∑–Ω–∞–∫–æ–≤–æ–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ –Ω–∞—á–∏–Ω–∞–ª–æ—Å—å –±—ã –Ω–µ —Å <code>u</code>, –∞ —Å <code>i</code>), –∑–∞–Ω–∏–º–∞—é—â–µ–µ 32 –±–∏—Ç–∞ –ø–∞–º—è—Ç–∏. –¢–∞–±–ª–∏—Ü–∞ 3-1 –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã–µ —Ç–∏–ø—ã Rust. –ú—ã –º–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ª—é–±–æ–π –∏–∑ –Ω–∏—Ö –¥–ª—è –æ–±—ä—è–≤–ª–µ–Ω–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π, —Ö—Ä–∞–Ω—è—â–µ–π —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ.</p>
<p><span class="caption">–¢–∞–±–ª–∏—Ü–∞ 3-1: –¶–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã–µ —Ç–∏–ø—ã –≤ Rust</span></p>
<div class="table-wrapper"><table><thead><tr><th>–î–ª–∏–Ω–∞</th><th>–ó–Ω–∞–∫–æ–≤—ã–µ</th><th>–ë–µ–∑–∑–Ω–∞–∫–æ–≤—ã–µ</th></tr></thead><tbody>
<tr><td>8-–±–∏—Ç–Ω—ã–µ</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16-–±–∏—Ç–Ω—ã–µ</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32-–±–∏—Ç–Ω—ã–µ</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64-–±–∏—Ç–Ω—ã–µ</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128-–±–∏—Ç–Ω—ã–µ</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td>—Ä–∞–∑—Ä—è–¥–Ω–æ—Å—Ç–∏ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
</div>
<p>–ù–∞ –∫–∞–∂–¥—É—é –¥–ª–∏–Ω—É –≤ –±–∏—Ç–∞—Ö –ø—Ä–∏—Ö–æ–¥–∏—Ç—Å—è –¥–≤–∞ –≤–∞—Ä–∏–∞–Ω—Ç–∞: –∑–Ω–∞–∫–æ–≤–æ–µ –∏ –±–µ–∑–∑–Ω–∞–∫–æ–≤–æ–µ —Ü–µ–ª—ã–µ. –¢–µ—Ä–º–∏–Ω—ã <em>–∑–Ω–∞–∫–æ–≤–æ–µ</em> –∏ <em>–±–µ–∑–∑–Ω–∞–∫–æ–≤–æ–µ</em> –æ–∑–Ω–∞—á–∞—é—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –¥–ª—è —á–∏—Å–ª–∞ –ø—Ä–∏–Ω–∏–º–∞—Ç—å –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è; –¥—Ä—É–≥–∏–º–∏ —Å–ª–æ–≤–∞–º–∏, –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –ª–∏ —á–∏—Å–ª—É –∏–º–µ—Ç—å –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã–π –∑–Ω–∞–∫ (—ç—Ç–æ –±—É–¥—É—Ç –∑–Ω–∞–∫–æ–≤—ã–µ —Ü–µ–ª—ã–µ), –∏–ª–∏ –∂–µ –æ–Ω–æ –æ–¥–Ω–æ–∑–Ω–∞—á–Ω–æ –±—É–¥–µ—Ç –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º –∏ –ø–æ—Ç–æ–º—É –º–æ–∂–µ—Ç —Ö—Ä–∞–Ω–∏—Ç—å—Å—è –±–µ–∑ –∑–Ω–∞–∫–∞ (—ç—Ç–æ –±—É–¥—É—Ç –±–µ–∑–∑–Ω–∞–∫–æ–≤—ã–µ —Ü–µ–ª—ã–µ). –ü—Ä–µ–¥—Å—Ç–∞–≤—å—Ç–µ, —á—Ç–æ –∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç–µ —á–∏—Å–ª–∞ –Ω–∞ –±—É–º–∞–≥–µ: –µ—Å–ª–∏ –≤–∞–º –≤–∞–∂–Ω–æ –∑–Ω–∞—Ç—å –∑–Ω–∞–∫, –≤—ã –±—É–¥–µ—Ç–µ —Ç—Ä–∞—Ç–∏—Ç—å –º–µ—Å—Ç–æ –Ω–∞ –∑–∞–ø–∏—Å—å –∑–Ω–∞–∫–∞ "–ø–ª—é—Å" –∏–ª–∏ "–º–∏–Ω—É—Å"; –µ—Å–ª–∏ –∂–µ –≤—ã –∑–Ω–∞–µ—Ç–µ, —á—Ç–æ —Ç–æ—á–Ω–æ —Ä–∞–±–æ—Ç–∞–µ—Ç–µ —Å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º–∏ —á–∏—Å–ª–∞–º–∏, –≤—ã –Ω–µ —Ç—Ä–∞—Ç–∏—Ç–µ –º–µ—Å—Ç–æ –Ω–∞ –∑–Ω–∞–∫. –ó–Ω–∞–∫–æ–≤—ã–µ —Ü–µ–ª—ã–µ —Ö—Ä–∞–Ω—è—Ç—Å—è –≤ –ø–∞–º—è—Ç–∏ —Å –ø–æ–º–æ—â—å—é <a href="https://ru.wikipedia.org/wiki/%D0%94%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4">–¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–≥–æ –∫–æ–¥–∞</a><!-- ignore -->.</p>
<p>–ö–∞–∂–¥—ã–π –∑–Ω–∞–∫–æ–≤—ã–π —Ç–∏–ø –º–æ–∂–µ—Ç —Ö—Ä–∞–Ω–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è –æ—Ç ‚àí(2<sup>n ‚àí 1</sup>) –¥–æ 2<sup>n ‚àí 1</sup> ‚àí 1 –≤–∫–ª—é—á–∏—Ç–µ–ª—å–Ω–æ, –≥–¥–µ <em>n</em> ‚Äî –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –±–∏—Ç –Ω–∞ –¥–∞–Ω–Ω–æ–µ —á–∏—Å–ª–æ. –¢–∞–∫, —Ç–∏–ø <code>i8</code> —Ö—Ä–∞–Ω–∏—Ç –∑–Ω–∞—á–µ–Ω–∏—è –æ—Ç ‚àí(2<sup>7</sup>) –¥–æ 2<sup>7</sup> ‚àí 1, —á—Ç–æ —Ä–∞–≤–Ω–æ –ø—Ä–µ–¥–µ–ª–∞–º –æ—Ç ‚àí128 –¥–æ 127. –ë–µ–∑–∑–Ω–∞–∫–æ–≤—ã–µ —Ç–∏–ø—ã –º–æ–≥—É—Ç —Ö—Ä–∞–Ω–∏—Ç—å —á–∏—Å–ª–∞ –æ—Ç 0 –¥–æ 2<sup>n</sup> ‚àí 1, —Ç–∞–∫ —á—Ç–æ —Ç–∏–ø <code>u8</code> –º–æ–∂–µ—Ç —Ö—Ä–∞–Ω–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è –æ—Ç 0 –¥–æ 2<sup>8</sup> ‚àí 1, —á—Ç–æ —Ä–∞–≤–Ω–æ –ø—Ä–µ–¥–µ–ª–∞–º –æ—Ç 0 –¥–æ 255.</p>
<p>–ö—Ä–æ–º–µ —Ç–æ–≥–æ, –µ—Å—Ç—å —Ç–∏–ø—ã <code>isize</code> –∏ <code>usize</code>, –∫–æ—Ç–æ—Ä—ã–µ –∑–∞–≤–∏—Å—è—Ç –æ—Ç —Ä–∞–∑—Ä—è–¥–Ω–æ—Å—Ç–∏ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã –∫–æ–º–ø—å—é—Ç–µ—Ä–∞, –Ω–∞ –∫–æ—Ç–æ—Ä–æ–º –≤—ã –∑–∞–ø—É—Å–∫–∞–µ—Ç–µ –ø—Ä–æ–≥—Ä–∞–º–º—É; –æ–Ω–∏ –Ω–∞—Ö–æ–¥—è—Ç—Å—è –≤ –∫–æ–Ω—Ü–µ –Ω–∞—à–µ–π —Ç–∞–±–ª–∏—Ü—ã. –≠—Ç–∏ —Ç–∏–ø—ã –±—É–¥—É—Ç 64-–±–∏—Ç–Ω—ã–º–∏, –µ—Å–ª–∏ –≤—ã —Ä–∞–±–æ—Ç–∞–µ—Ç–µ –Ω–∞ –º–∞—à–∏–Ω–µ —Å 64-–±–∏—Ç–Ω–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–æ–π, –∏ –±—É–¥—É—Ç 32-–±–∏—Ç–Ω—ã–º–∏, –µ—Å–ª–∏ –≤—ã —Ä–∞–±–æ—Ç–∞–µ—Ç–µ –Ω–∞ –º–∞—à–∏–Ω–µ —Å 32-–±–∏—Ç–Ω–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–æ–π.</p>
<p>–í—ã –º–æ–∂–µ—Ç–µ –∑–∞–ø–∏—Å—ã–≤–∞—Ç—å –ª–∏—Ç–µ—Ä–∞–ª—ã —Ü–µ–ª—ã—Ö —á–∏—Å–µ–ª –≤ –ª—é–±–æ–º —Ñ–æ—Ä–º–∞—Ç–µ –∏–∑ —Ç–µ—Ö, —á—Ç–æ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω—ã –≤ –¢–∞–±–ª–∏—Ü–µ 3-2. –°—Ç–æ–∏—Ç –æ—Ç–º–µ—Ç–∏—Ç—å, —á—Ç–æ —Ç–∏–ø –ª–∏—Ç–µ—Ä–∞–ª–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç –±—ã—Ç—å –æ—Ç–Ω–µ—Å–µ–Ω—ã –∫ —Ä–∞–∑–Ω—ã–º —Ç–∏–ø–∞–º, –º–æ–∂–µ—Ç –±—ã—Ç—å –æ–ø—Ä–µ–¥–µ–ª—ë–Ω —è–≤–Ω–æ —Å –ø–æ–º–æ—â—å—é —Å—É—Ñ—Ñ–∏–∫—Å–∞ —Ç–∏–ø–∞, –Ω–∞–ø—Ä–∏–º–µ—Ä: <code>57u8</code>. –í —á–∏—Å–ª–æ–≤—ã—Ö –ª–∏—Ç–µ—Ä–∞–ª–∞—Ö –º–æ–∂–Ω–æ —Ç–∞–∫–∂–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∑–Ω–∞–∫ <code>_</code> –∫–∞–∫ —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞ —á—Ç–µ–Ω–∏—è: –Ω–∞–ø—Ä–∏–º–µ—Ä, –∑–∞–ø–∏—Å—å <code>1_000</code> –±—É–¥–µ—Ç —ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–Ω–∞ –∑–∞–ø–∏—Å–∏ <code>1000</code>.</p>
<p><span class="caption">–¢–∞–±–ª–∏—Ü–∞ 3-2: –¶–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã–µ –ª–∏—Ç–µ—Ä–∞–ª—ã –≤ Rust</span></p>
<div class="table-wrapper"><table><thead><tr><th>–õ–∏—Ç–µ—Ä–∞–ª—ã</th><th>–ü—Ä–∏–º–µ—Ä</th></tr></thead><tbody>
<tr><td>–î–µ—Å—è—Ç–∏—á–Ω—ã–π</td><td><code>98_222</code></td></tr>
<tr><td>–®–µ—Å—Ç–Ω–∞–¥—Ü–∞—Ç–µ—Ä–∏—á–Ω—ã–π</td><td><code>0xff</code></td></tr>
<tr><td>–í–æ—Å—å–º–µ—Ä–∏—á–Ω—ã–π</td><td><code>0o77</code></td></tr>
<tr><td>–î–≤–æ–∏—á–Ω—ã–π</td><td><code>0b1111_0000</code></td></tr>
<tr><td>–ë–∞–π—Ç (—Ç–æ–ª—å–∫–æ —Ç–∏–ø <code>u8</code>)</td><td><code>b'A'</code></td></tr>
</tbody></table>
</div>
<p>–ö–∞–∫ –ø–æ–Ω—è—Ç—å, –∫–∞–∫–æ–π –∏–∑ —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã—Ö —Ç–∏–ø–æ–≤ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å? –ï—Å–ª–∏ –≤—ã —Å–æ–º–Ω–µ–≤–∞–µ—Ç–µ—Å—å, —Ç–æ –ø—Ä–∏—Å–ª—É—à–∞–π—Ç–µ—Å—å –∫ Rust: –≤—ã–≤–æ–¥–∏–º—ã–π –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é —Ç–∏–ø <code>i32</code> –±—É–¥–µ—Ç –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Ö–æ—Ä–æ—à –¥–ª—è –º–Ω–æ–≥–∏—Ö —Å–∏—Ç—É–∞—Ü–∏–π. –û—Å–Ω–æ–≤–Ω–æ–µ –∂–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Ç–∏–ø–æ–≤ <code>isize</code> –∏ <code>usize</code> ‚Äî –æ–±—Ä–∞—â–µ–Ω–∏–µ –∫ —ç–ª–µ–º–µ–Ω—Ç–∞–º –∫–æ–ª–ª–µ–∫—Ü–∏–∏ –ø–æ –∏–Ω–¥–µ–∫—Å—É.</p>
<blockquote>
<h5 id="–¶–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω–æ–µ-–ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ"><a class="header" href="#–¶–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω–æ–µ-–ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ">–¶–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω–æ–µ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ</a></h5>
<p>–î–æ–ø—É—Å—Ç–∏–º, —É –≤–∞—Å –µ—Å—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è —Ç–∏–ø–∞ <code>u8</code>, –∫–æ—Ç–æ—Ä–∞—è –º–æ–∂–µ—Ç –ø—Ä–∏–Ω–∏–º–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è –æ—Ç 0 –¥–æ 255. –ï—Å–ª–∏ –≤—ã –ø–æ–ø—ã—Ç–∞–µ—Ç–µ—Å—å –ø—Ä–∏–ø–∏—Å–∞—Ç—å —ç—Ç–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –∑–Ω–∞—á–µ–Ω–∏–µ –∑–∞ —ç—Ç–∏–º–∏ –ø—Ä–µ–¥–µ–ª–∞–º–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, 270), –ø—Ä–æ–∏–∑–æ–π–¥—ë—Ç <em>—Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω–æ–µ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ</em>, –∫–æ—Ç–æ—Ä–æ–µ –º–æ–∂–µ—Ç –ø—Ä–∏–≤–µ—Å—Ç–∏ –∫ –¥–≤—É–º —Ä–∞–∑–ª–∏—á–Ω—ã–º —Å–∏—Ç—É–∞—Ü–∏—è–º. –ï—Å–ª–∏ –≤—ã —Å–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞–ª–∏ –ø—Ä–æ–≥—Ä–∞–º–º—É –≤ —Ä–µ–∂–∏–º–µ –æ—Ç–ª–∞–¥–∫–∏, Rust –≤–∫–ª—é—á–∏–ª –≤ –Ω–µ—ë –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–∞ —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω–æ–µ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä—ã–µ –≤—ã–∑–æ–≤—É—Ç <em>–ø–∞–Ω–∏–∫—É</em>, –µ—Å–ª–∏ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ –ø—Ä–æ–∏–∑–æ–π–¥—ë—Ç. –í Rust –ø–æ–¥ —Ç–µ—Ä–º–∏–Ω–æ–º <em>–ø–∞–Ω–∏–∫–∞</em> –ø–æ–Ω–∏–º–∞–µ—Ç—Å—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã —Å –æ—à–∏–±–∫–æ–π. –ë–æ–ª—å—à–µ –æ –ø–∞–Ω–∏–∫–µ –º—ã –ø–æ–≥–æ–≤–æ—Ä–∏–º –≤ —Ä–∞–∑–¥–µ–ª–µ <a href="ch09-01-unrecoverable-errors-with-panic.html">"–ù–µ—É—Å—Ç—Ä–∞–Ω–∏–º—ã–µ –æ—à–∏–±–∫–∏ —Å panic!"</a><!-- ignore --> –ì–ª–∞–≤—ã 9.</p>
<p>–ö–æ–≥–¥–∞ –≤—ã –∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç–µ –ø—Ä–æ–≥—Ä–∞–º–º—É –≤ —Ä–µ–ª–∏–∑–Ω–æ–º —Ä–µ–∂–∏–º–µ (–∏—Å–ø–æ–ª—å–∑—É—è —Ñ–ª–∞–≥ <code>--release</code>), Rust <em>–Ω–µ</em> –≤–∫–ª—é—á–∞–µ—Ç –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–∞ —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω–æ–µ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ –∏ –Ω–µ –≤—ã–∑—ã–≤–∞–µ—Ç –ø–∞–Ω–∏–∫–∏ –≤ –µ–≥–æ —Å–ª—É—á–∞–µ. –í–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ, Rust –≤—ã–ø–æ–ª–Ω—è–µ—Ç <em>–æ–±—Ä–∞—â–µ–Ω–∏–µ –ø–æ –º–æ–¥—É–ª—é</em>. –ö—Ä–∞—Ç–∫–æ –≥–æ–≤–æ—Ä—è, –∑–Ω–∞—á–µ–Ω–∏—è, –ø—Ä–µ–≤—ã—à–∞—é—â–∏–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Ç–∏–ø–∞, "–æ–±–æ—Ä–∞—á–∏–≤–∞—é—Ç—Å—è" –ø–æ –º–æ–¥—É–ª—é –¥–æ —á–∏—Å–ª–∞, –∫–æ—Ç–æ—Ä–æ–µ –±—É–¥–µ—Ç –Ω–∞—Ö–æ–¥–∏—Ç—å—Å—è –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö —Ç–∏–ø–∞. –í —Å–ª—É—á–∞–µ —Ç–∏–ø–∞ <code>u8</code>, –∑–Ω–∞—á–µ–Ω–∏–µ 256 —Å—Ç–∞–Ω–µ—Ç 0, –∑–Ω–∞—á–µ–Ω–∏–µ 257 —Å—Ç–∞–Ω–µ—Ç 1, –∏ —Ç–∞–∫ –¥–∞–ª–µ–µ. –ü—Ä–æ–≥—Ä–∞–º–º–∞ –Ω–µ –≤—ã–∑–æ–≤–µ—Ç –ø–∞–Ω–∏–∫—É, –Ω–æ –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –±—É–¥–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ –Ω–µ —Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –≤—ã, —Å–∫–æ—Ä–µ–µ –≤—Å–µ–≥–æ, –æ–∂–∏–¥–∞–µ—Ç–µ. –ü–æ–ª–∞–≥–∞—Ç—å—Å—è –Ω–∞ –æ–±—Ä–∞—â–µ–Ω–∏–µ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏—è –ø–æ –º–æ–¥—É–ª—é —Å—á–∏—Ç–∞–µ—Ç—Å—è –æ—à–∏–±–∫–æ–π.</p>
<p>–ß—Ç–æ–±—ã —è–≤–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏—è, –≤—ã –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–∞–±–æ—Ä –º–µ—Ç–æ–¥–æ–≤ –±–∞–∑–æ–≤—ã—Ö —á–∏—Å–ª–æ–≤—ã—Ö —Ç–∏–ø–æ–≤, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ–º—ã–π —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–æ–π:</p>
<ul>
<li>–ú–µ—Ç–æ–¥—ã <code>wrapping_*</code> (–Ω–∞–ø—Ä–∏–º–µ—Ä, <code>wrapping_add</code>) –æ–±—Ä–∞—Ç—è—Ç –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ –ø–æ –º–æ–¥—É–ª—é ‚Äî –∫–∞–∫ –≤ —Ä–µ–ª–∏–∑–Ω–æ–º —Ä–µ–∂–∏–º–µ, —Ç–∞–∫ –∏ –≤ —Ä–µ–∂–∏–º–µ –æ—Ç–ª–∞–¥–∫–∏.</li>
<li>–ú–µ—Ç–æ–¥—ã <code>checked_*</code> –≤–µ—Ä–Ω—É—Ç –∑–Ω–∞—á–µ–Ω–∏–µ <code>None</code>, –µ—Å–ª–∏ –ø—Ä–æ–∏–∑–æ–π–¥—ë—Ç –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ.</li>
<li>–ú–µ—Ç–æ–¥—ã <code>overflowing_*</code> –≤–µ—Ä–Ω—É—Ç —á–∏—Å–ª–æ –∏ –ª–æ–≥–∏—á–µ—Å–∫–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ, —Å–æ–æ–±—â–∞—é—â–µ–µ –æ —Ç–æ–º, –ø—Ä–æ–∏–∑–æ—à–ª–æ –ª–∏ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ.</li>
<li>–ú–µ—Ç–æ–¥—ã <code>saturating_*</code> –≤–µ—Ä–Ω—É—Ç –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∏–ª–∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Ç–∏–ø–∞ (–≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–æ–≥–æ, –º–µ–Ω—å—à–µ –ª–∏ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ, —á–µ–º –º–∏–Ω–∏–º—É–º —Ç–∏–ø–∞, –∏–ª–∏ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ –±–æ–ª—å—à–µ, —á–µ–º –º–∞–∫—Å–∏–º—É–º).</li>
</ul>
</blockquote>
<h4 id="–¢–∏–ø—ã-—á–∏—Å–µ–ª-—Å-–ø–ª–∞–≤–∞—é—â–µ–π-—Ç–æ—á–∫–æ–π"><a class="header" href="#–¢–∏–ø—ã-—á–∏—Å–µ–ª-—Å-–ø–ª–∞–≤–∞—é—â–µ–π-—Ç–æ—á–∫–æ–π">–¢–∏–ø—ã —á–∏—Å–µ–ª —Å –ø–ª–∞–≤–∞—é—â–µ–π —Ç–æ—á–∫–æ–π</a></h4>
<p>Rust —Ç–∞–∫–∂–µ –∏–º–µ–µ—Ç –¥–≤–∞ –±–∞–∑–æ–≤—ã—Ö —Ç–∏–ø–∞ <em>—á–∏—Å–µ–ª —Å –ø–ª–∞–≤–∞—é—â–µ–π —Ç–æ—á–∫–æ–π</em> ‚Äî —á–∏—Å–µ–ª —Å –¥–µ—Å—è—Ç–∏—á–Ω–æ–π –¥—Ä–æ–±–Ω–æ–π —á–∞—Å—Ç—å—é. –ö —ç—Ç–∏–º —Ç–∏–ø–∞–º –æ—Ç–Ω–æ—Å—è—Ç—Å—è —Ç–∏–ø—ã <code>f32</code> –∏ <code>f64</code>, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ –∑–∞–Ω–∏–º–∞—é—â–∏–µ –≤ –ø–∞–º—è—Ç–∏ 32 –∏ 64 –±–∏—Ç–∞. –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ç–∏–ø <code>f64</code>, –ø–æ—Å–∫–æ–ª—å–∫—É –Ω–∞ –Ω–æ–≤—ã—Ö –¶–ü –æ–Ω —Å—Ä–∞–≤–Ω–∏–º –ø–æ –±—ã—Å—Ç—Ä–æ–¥–µ–π—Å—Ç–≤–∏—é —Å <code>f32</code>, –Ω–æ –ø—Ä–∏ —ç—Ç–æ–º –¥–∞—ë—Ç –±–æ–ª—å—à—É—é —Ç–æ—á–Ω–æ—Å—Ç—å. –í—Å–µ —Ç–∏–ø—ã —á–∏—Å–µ–ª —Å –ø–ª–∞–≤–∞—é—â–µ–π —Ç–æ—á–∫–æ–π ‚Äî –∑–Ω–∞–∫–æ–≤—ã–µ.</p>
<p>–í–æ—Ç –ø—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —á–∏—Å–µ–ª —Å –ø–ª–∞–≤–∞—é—â–µ–π —Ç–æ—á–∫–æ–π:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}</code></pre></pre>
<p>–ß–∏—Å–ª–∞ —Å –ø–ª–∞–≤–∞—é—â–µ–π —Ç–æ—á–∫–æ–π —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω—ã –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–∏ —Å–æ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–æ–º IEEE-754.</p>
<h4 id="–û–ø–µ—Ä–∞—Ü–∏–∏-–Ω–∞–¥-—á–∏—Å–ª–∞–º–∏"><a class="header" href="#–û–ø–µ—Ä–∞—Ü–∏–∏-–Ω–∞–¥-—á–∏—Å–ª–∞–º–∏">–û–ø–µ—Ä–∞—Ü–∏–∏ –Ω–∞–¥ —á–∏—Å–ª–∞–º–∏</a></h4>
<p>Rust –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –±–∞–∑–æ–≤—ã–µ –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –Ω–∞–¥ —á–∏—Å–ª–æ–≤—ã–º–∏ —Ç–∏–ø–∞–º–∏: —Å–ª–æ–∂–µ–Ω–∏–µ, –≤—ã—á–∏—Ç–∞–Ω–∏–µ, —É–º–Ω–æ–∂–µ–Ω–∏–µ, –¥–µ–ª–µ–Ω–∏–µ –∏ –≤–∑—è—Ç–∏–µ –æ—Å—Ç–∞—Ç–∫–∞ –æ—Ç –¥–µ–ª–µ–Ω–∏—è. –¶–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω–æ–µ –¥–µ–ª–µ–Ω–∏–µ –æ—Ç–±—Ä–∞—Å—ã–≤–∞–µ—Ç –¥—Ä–æ–±–Ω—É—é —á–∞—Å—Ç—å. –ö–æ–¥ –Ω–∏–∂–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –ø—Ä–∏–º–µ—Ä—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –æ–ø–µ—Ä–∞—Ü–∏–π –Ω–∞–¥ —á–∏—Å–ª–∞–º–∏ –∏ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ <code>let</code>:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    // —Å–ª–æ–∂–µ–Ω–∏–µ
    let sum = 5 + 10;

    // –≤—ã—á–∏—Ç–∞–Ω–∏–µ
    let difference = 95.5 - 4.3;

    // —É–º–Ω–æ–∂–µ–Ω–∏–µ
    let product = 4 * 30;

    // –¥–µ–ª–µ–Ω–∏–µ
    let quotient = 56.7 / 32.2;
    let truncated = -5 / 3; // –±—É–¥–µ—Ç —Ä–∞–≤–Ω–æ -1

    // –æ—Å—Ç–∞—Ç–æ–∫ –æ—Ç –¥–µ–ª–µ–Ω–∏—è
    let remainder = 43 % 5;
}</code></pre></pre>
<p>–í –∫–∞–∂–¥–æ–π —Å—Ç—Ä–æ—á–∫–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –æ–ø–µ—Ä–∞—Ç–æ—Ä –∏ –≤—ã—á–∏—Å–ª—è–µ—Ç—Å—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç, –∫–æ—Ç–æ—Ä—ã–π –ø—Ä–∏–≤—è–∑—ã–≤–∞–µ—Ç—Å—è –∫ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π. <a href="appendix-02-operators.html">–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ B</a><!-- ignore --> —Å–æ–¥–µ—Ä–∂–∏—Ç —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤ –≤ Rust.</p>
<h4 id="–õ–æ–≥–∏—á–µ—Å–∫–∏–π-—Ç–∏–ø"><a class="header" href="#–õ–æ–≥–∏—á–µ—Å–∫–∏–π-—Ç–∏–ø">–õ–æ–≥–∏—á–µ—Å–∫–∏–π —Ç–∏–ø</a></h4>
<p>–ö–∞–∫ –∏ –≤ –¥—Ä—É–≥–∏—Ö —è–∑—ã–∫–∞—Ö –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è, –ª–æ–≥–∏—á–µ—Å–∫–∏–π —Ç–∏–ø –≤ Rust –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω –¥–≤—É–º—è –≤–æ–∑–º–æ–∂–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏: <code>true</code> –∏ <code>false</code>. –õ–æ–≥–∏—á–µ—Å–∫–∏–π —Ç–∏–ø –∑–∞–Ω–∏–º–∞–µ—Ç –æ–¥–∏–Ω –±–∞–π—Ç –≤ –ø–∞–º—è—Ç–∏. –õ–æ–≥–∏—á–µ—Å–∫–∏–π —Ç–∏–ø –∞–Ω–Ω–æ—Ç–∏—Ä—É–µ—Ç—Å—è —Å–ª–æ–≤–æ–º <code>bool</code>; –Ω–∞–ø—Ä–∏–º–µ—Ä:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let t = true;

    let f: bool = false; // —Å —è–≤–Ω–æ–π –∞–Ω–Ω–æ—Ç–∞—Ü–∏–µ–π —Ç–∏–ø–∞
}</code></pre></pre>
<p>–û—Å–Ω–æ–≤–Ω—ã–º –º–µ—Å—Ç–æ–º, –≥–¥–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –ª–æ–≥–∏—á–µ—Å–∫–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è, —è–≤–ª—è—é—Ç—Å—è —É—Å–ª–æ–≤–Ω—ã–µ –≤—ã—Ä–∞–∂–µ–Ω–∏—è, –≤—Ä–æ–¥–µ –≤—ã—Ä–∞–∂–µ–Ω–∏—è <code>if</code>. –ú—ã —Ä–∞—Å—Å–∫–∞–∂–µ–º –æ —Ç–æ–º, –∫–∞–∫ —Ä–∞—é–æ—Ç–∞—é—Ç –≤—ã—Ä–∞–∂–µ–Ω–∏—è <code>if</code>, –≤ —Ä–∞–∑–¥–µ–ª–µ <a href="ch03-05-control-flow.html#%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BC">"–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ—Ç–æ–∫–æ–º"</a><!-- ignore -->.</p>
<h4 id="–¢–∏–ø-—Å–∏–º–≤–æ–ª–∞"><a class="header" href="#–¢–∏–ø-—Å–∏–º–≤–æ–ª–∞">–¢–∏–ø —Å–∏–º–≤–æ–ª–∞</a></h4>
<p>–¢–∏–ø <code>char</code> ‚Äî —ç—Ç–æ –ø—Ä–æ—Å—Ç–µ–π—à–∏–π —Ç–∏–ø, —Ä–µ–∞–ª–∏–∑—É—é—â–∏–π —Å–∏–º–≤–æ–ª. –í–æ—Ç –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø—Ä–∏–º–µ—Ä–æ–≤ –æ–±—ä—è–≤–ª–µ–Ω–∏—è –∑–Ω–∞—á–µ–Ω–∏–π —Ç–∏–ø–∞ <code>char</code>:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let c = 'z';
    let z: char = '‚Ñ§'; // —Å —è–≤–Ω–æ–π –∞–Ω–Ω–æ—Ç–∞—Ü–∏–µ–π —Ç–∏–ø–∞
    let heart_eyed_cat = 'üòª';
}</code></pre></pre>
<p>–û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ –º—ã –∑–∞–∫–ª—é—á–∞–µ–º –ª–∏—Ç–µ—Ä–∞–ª <code>char</code> –≤ –æ–¥–∏–Ω–æ—á–Ω—ã–µ –∫–∞–≤—ã—á–∫–∏, —Ç–æ–≥–¥–∞ –∫–∞–∫ —Å—Ç—Ä–æ–∫–∏ –æ–±—Ä–∞–º–ª—è—é—Ç—Å—è –¥–≤–æ–π–Ω—ã–º–∏ –∫–∞–≤—ã—á–∫–∞–º–∏. –¢–∏–ø <code>char</code> –∑–∞–Ω–∏–º–∞–µ—Ç –≤ –ø–∞–º—è—Ç–∏ —á–µ—Ç—ã—Ä–µ –±–∞–π—Ç–∞ –∏ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Å–æ–±–æ–π —Å–∏–º–≤–æ–ª Unicode, —Ç–æ –µ—Å—Ç—å –æ–Ω –º–æ–∂–µ—Ç –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—Ç—å –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ –±–æ–ª—å—à–µ —Å–∏–º–≤–æ–ª–æ–≤, —á–µ–º ASCII. –î–∏–∞–∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –∑–Ω–∞–∫–∏, –∫–∏—Ç–∞–π—Å–∫–∏–µ –∏–µ—Ä–æ–≥–ª–∏—Ñ—ã, —è–ø–æ–Ω—Å–∫–∏–µ –∫–∞–Ω–¥–∑–∏, –∫–∞—Ç–∞–∫–∞–Ω—É –∏ —Ö–∏—Ä–∞–≥–∞–Ω—É, –∫–æ—Ä–µ–π—Å–∫–∏–π —Ö–∞–Ω–≥—ã–ª—å, —ç–º–æ–¥–∑–∏, –ø—Ä–æ–±–µ–ª—ã –Ω—É–ª–µ–≤–æ–π —à–∏—Ä–∏–Ω—ã ‚Äî –≤—Å—ë —ç—Ç–æ –¥–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è —Ç–∏–ø–∞ <code>char</code> –≤ Rust. –°–∏–º–≤–æ–ª—ã Unicode –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∞—Ç –ø—Ä–æ–º–µ–∂—É—Ç–∫—É –æ—Ç <code>U+0000</code> –¥–æ <code>U+D7FF</code> –∏ –æ—Ç <code>U+E000</code> –¥–æ <code>U+10FFFF</code> –≤–∫–ª—é—á–∏—Ç–µ–ª—å–Ω–æ. –û–¥–Ω–∞–∫–æ, –∫–∞–∫ —Ç–∞–∫–æ–≤–æ–≥–æ, –ø–æ–Ω—è—Ç–∏—è "—Å–∏–º–≤–æ–ª" –≤ Unicode –Ω–µ—Ç, —Ç–∞–∫ —á—Ç–æ –≤–∞—à–µ –∏–Ω—Ç—É–∏—Ç–∏–≤–Ω–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –æ —Ç–æ–º, —á—Ç–æ —Ç–∞–∫–æ–µ "—Å–∏–º–≤–æ–ª", –º–æ–∂–µ—Ç –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–æ–≤–∞—Ç—å —Ç–æ–º—É, —á–µ–º –º–æ–∂–µ—Ç —è–≤–ª—è—Ç—å—Å—è –∑–Ω–∞—á–µ–Ω–∏–µ —Ç–∏–ø–∞ <code>char</code>. –ú—ã –æ–±—Å—É–¥–∏–º —ç—Ç–æ –ø–æ–¥—Ä–æ–±–Ω–µ–µ –≤ —Ä–∞–∑–¥–µ–ª–µ <a href="ch08-02-strings.html#%D0%A5%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D1%82%D0%B5%D0%BA%D1%81%D1%82%D0%B0-%D0%B2-%D0%BA%D0%BE%D0%B4%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B5-utf-8-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-%D1%81%D1%82%D1%80%D0%BE%D0%BA">"–•—Ä–∞–Ω–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ –≤ –∫–æ–¥–∏—Ä–æ–≤–∫–µ UTF-8 —Å –ø–æ–º–æ—â—å—é —Å—Ç—Ä–æ–∫"</a><!-- ignore --> –ì–ª–∞–≤—ã 8.</p>
<h3 id="–°–æ—Å—Ç–∞–≤–Ω—ã–µ-—Ç–∏–ø—ã"><a class="header" href="#–°–æ—Å—Ç–∞–≤–Ω—ã–µ-—Ç–∏–ø—ã">–°–æ—Å—Ç–∞–≤–Ω—ã–µ —Ç–∏–ø—ã</a></h3>
<p><em>–°–æ—Å—Ç–∞–≤–Ω—ã–µ —Ç–∏–ø—ã</em> —Å–æ–±–∏—Ä–∞—é—Ç—Å—è –∏–∑ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –¥—Ä—É–≥–∏—Ö —Ç–∏–ø–æ–≤. Rust –∏–º–µ–µ—Ç –¥–≤–∞ –±–∞–∑–æ–≤—ã—Ö —Å–æ—Å—Ç–∞–≤–Ω—ã—Ö —Ç–∏–ø–∞: –∫–æ—Ä—Ç–µ–∂–∏ –∏ –º–∞—Å—Å–∏–≤—ã.</p>
<h4 id="–¢–∏–ø-–∫–æ—Ä—Ç–µ–∂–∞"><a class="header" href="#–¢–∏–ø-–∫–æ—Ä—Ç–µ–∂–∞">–¢–∏–ø –∫–æ—Ä—Ç–µ–∂–∞</a></h4>
<p><em>–ö–æ—Ä—Ç–µ–∂</em> ‚Äî —ç—Ç–æ –Ω–∞–∏–±–æ–ª–µ–µ –æ–±—â–∏–π —Å–ø–æ—Å–æ–± –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∏ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ –≤ –æ–¥–∏–Ω —Å–æ—Å—Ç–∞–≤–Ω–æ–π —Ç–∏–ø. –î–ª–∏–Ω–∞ –∫–æ—Ä—Ç–µ–∂–µ–π –ø–æ—Å—Ç–æ—è–Ω–Ω–∞: –≤—ã –Ω–µ –º–æ–∂–µ—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –≤ –∫–æ—Ä—Ç–µ–∂ –∏–ª–∏ —É–±—Ä–∞—Ç—å —á—Ç–æ-–ª–∏–±–æ –∏–∑ –Ω–µ–≥–æ.</p>
<p>–ö–æ—Ä—Ç–µ–∂ –∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è –∫–∞–∫ –∑–∞–∫–ª—é—á—ë–Ω–Ω—ã–π –≤ –∫—Ä—É–≥–ª—ã–µ —Å–∫–æ–±–∫–∏ —Å–ø–∏—Å–æ–∫ –∑–Ω–∞—á–µ–Ω–∏–π, —Ä–∞–∑–¥–µ–ª—ë–Ω–Ω—ã—Ö –∑–∞–ø—è—Ç—ã–º–∏. –ö–∞–∂–¥–∞—è —ç–ª–µ–º–µ–Ω—Ç –∫–æ—Ä—Ç–µ–∂–∞ –∏–º–µ–µ—Ç —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–π —Ç–∏–ø, –∏ —Ç–∏–ø—ã —Ä–∞–∑–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–æ–≥—É—Ç –Ω–µ —Å–æ–≤–ø–∞–¥–∞—Ç—å. –í –ø—Ä–∏–º–µ—Ä–µ –Ω–∏–∂–µ –º—ã —Å–æ–∑–¥–∞—ë–º –∫–æ—Ä—Ç–µ–∂ –∏ (—á—Ç–æ –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ) –∞–Ω–Ω–æ—Ç–∏—Ä—É–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é, —Å –∫–æ—Ç–æ—Ä–æ–π –æ–Ω –±—É–¥–µ—Ç —Å–≤—è–∑–∞–Ω:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}</code></pre></pre>
<p>–ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è <code>tup</code> —Å–≤—è–∑—ã–≤–∞–µ—Ç—Å—è —Å–æ –≤—Å–µ–º –∫–æ—Ä—Ç–µ–∂–µ–º —Ü–µ–ª–∏–∫–æ–º, –ø–æ—Å–∫–æ–ª—å–∫—É –∫–æ—Ä—Ç–µ–∂ ‚Äî —ç—Ç–æ –µ–¥–∏–Ω—ã–π —Å–æ—Å—Ç–∞–≤–Ω–æ–π —Ç–∏–ø. –ß—Ç–æ–±—ã —Ä–∞–∑–ª–æ–∂–∏—Ç—å –∫–æ—Ä—Ç–µ–∂ –Ω–∞ –µ–≥–æ —á–∞—Å—Ç–∏, –º—ã –º–æ–∂–µ–º –≤–æ—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ–º —Å —à–∞–±–ª–æ–Ω–æ–º; –≤–æ—Ç —Ç–∞–∫:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("–ó–Ω–∞—á–µ–Ω–∏–µ y: {y}");
}</code></pre></pre>
<p>–≠—Ç–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∞ —Å–æ–∑–¥–∞—ë—Ç –∫–æ—Ä—Ç–µ–∂ –∏ —Å–≤—è–∑—ã–≤–∞–µ—Ç —Å –Ω–∏–º –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é <code>tup</code>. –ó–∞—Ç–µ–º –æ–Ω–∞ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç <code>let</code> –∏ –ø—Ä–∏–º–µ–Ω—è–µ—Ç —à–∞–±–ª–æ–Ω, —á—Ç–æ–±—ã –∏–∑–≤–ª–µ—á—å –∏–∑ <code>tup</code> —Ç—Ä–∏ –æ—Ç–¥–µ–ª—å–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö: <code>x</code>, <code>y</code> –∏ <code>z</code>. –≠—Ç–æ –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è <em>–¥–µ—Å—Ç—Ä—É–∫—Ç—É—Ä–∏–∑–∞—Ü–∏–µ–π</em>, –ø–æ—Å–∫–æ–ª—å–∫—É —Ä–∞–∑–±–∏–≤–∞–µ—Ç –µ–¥–∏–Ω—ã–π –∫–æ—Ä—Ç–µ–∂ –Ω–∞ —Ç—Ä–∏ —á–∞—Å—Ç–∏. –ù–∞–∫–æ–Ω–µ—Ü, –ø—Ä–æ–≥—Ä–∞–º–º–∞ –ø–µ—á–∞—Ç–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ <code>y</code>, —Ç–æ –µ—Å—Ç—å <code>6.4</code>.</p>
<p>–ú—ã —Ç–∞–∫–∂–µ –º–æ–∂–µ–º –ø–æ–ª—É—á–∏—Ç—å –ø—Ä—è–º–æ–π –¥–æ—Å—Ç—É–ø –∫ —ç–ª–µ–º–µ–Ω—Ç—É –∫–æ—Ä—Ç–µ–∂–∞, –¥–æ–ø–∏—Å–∞–≤ –ø–æ—Å–ª–µ –∏–º–µ–Ω–∏ –∫–æ—Ä—Ç–µ–∂–∞ —Ç–æ—á–∫—É –∏ –∏–Ω–¥–µ–∫—Å –∏–Ω—Ç–µ—Ä–µ—Å—É—é—â–µ–≥–æ –Ω–∞—Å —ç–ª–µ–º–µ–Ω—Ç–∞; –Ω–∞–ø—Ä–∏–º–µ—Ä:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}</code></pre></pre>
<p>–≠—Ç–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∞ —Å–æ–∑–¥–∞—ë—Ç –∫–æ—Ä—Ç–µ–∂ <code>x</code> –∏ –∑–∞—Ç–µ–º –ø–æ–ª—É—á–∞–µ—Ç –∫–∞–∂–¥—ã–π –µ–≥–æ —ç–ª–µ–º–µ–Ω—Ç, –∏—Å–ø–æ–ª—å–∑—É—è –æ–±—Ä–∞—â–µ–Ω–∏–µ –ø–æ –∏–Ω–¥–µ–∫—Å—É. –ö–∞–∫ –∏ –≤ –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–µ —è–∑—ã–∫–æ–≤ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è, –∏–Ω–¥–µ–∫—Å–∞—Ü–∏—è –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å –Ω—É–ª—è.</p>
<p>–ö–æ—Ä—Ç–µ–∂ –±–µ–∑ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ ‚Äî –æ—Å–æ–±–µ–Ω–Ω—ã–π, –æ–Ω –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è <em>unit</em>. –ó–Ω–∞—á–µ–Ω–∏–µ —ç—Ç–æ–≥–æ —Ç–∏–ø–∞ –∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è —Ç–∞–∫ –∂–µ, –∫–∞–∫ –∏ —Å–∞–º —Ç–∏–ø: <code>()</code>. Unit –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Å–æ–±–æ–π –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è –∏–ª–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è. –í—ã—Ä–∞–∂–µ–Ω–∏—è –Ω–µ—è–≤–Ω–æ –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç unit, –µ—Å–ª–∏ –Ω–µ –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç —á—Ç–æ-–ª–∏–±–æ –¥—Ä—É–≥–æ–µ.</p>
<h4 id="–¢–∏–ø-–º–∞—Å—Å–∏–≤–∞"><a class="header" href="#–¢–∏–ø-–º–∞—Å—Å–∏–≤–∞">–¢–∏–ø –º–∞—Å—Å–∏–≤–∞</a></h4>
<p>–î—Ä—É–≥–æ–π –±–∞–∑–æ–≤–æ–π –∫–æ–ª–ª–µ–∫—Ü–∏–µ–π –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π —è–≤–ª—è–µ—Ç—Å—è <em>–º–∞—Å—Å–∏–≤</em>. –í –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω–æ—Å—Ç—å –∫–æ—Ä—Ç–µ–∂—É, –≤—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –º–∞—Å—Å–∏–≤–∞ –¥–æ–ª–∂–Ω—ã –∏–º–µ—Ç—å –æ–¥–∏–Ω–∞–∫–æ–≤—ã–π —Ç–∏–ø. –í –æ—Ç–ª–∏—á–∏–µ –æ—Ç –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –¥—Ä—É–≥–∏—Ö —è–∑—ã–∫–æ–≤ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è, –º–∞—Å—Å–∏–≤—ã –≤ Rust –∏–º–µ—é—Ç –ø–æ—Å—Ç–æ—è–Ω–Ω—É—é –¥–ª–∏–Ω—É.</p>
<p>–ú–∞—Å—Å–∏–≤ –∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è –∫–∞–∫ –∑–∞–∫–ª—é—á—ë–Ω–Ω—ã–π –≤ –∫–≤–∞–¥—Ä–∞—Ç–Ω—ã–µ —Å–∫–æ–±–∫–∏ —Å–ø–∏—Å–æ–∫ –∑–Ω–∞—á–µ–Ω–∏–π, —Ä–∞–∑–¥–µ–ª—ë–Ω–Ω—ã—Ö –∑–∞–ø—è—Ç—ã–º–∏:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let a = [1, 2, 3, 4, 5];
}</code></pre></pre>
<p>–ú–∞—Å—Å–∏–≤—ã –Ω—É–∂–Ω—ã —Ç–æ–≥–¥–∞, –∫–æ–≥–¥–∞ –≤–∞–º –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —Ä–∞–∑–º–µ—Å—Ç–∏—Ç—å –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –¥–∞–Ω–Ω—ã–µ –Ω–∞ —Å—Ç–µ–∫–µ (–ø–æ–¥–æ–±–Ω–æ —Ç–∏–ø–∞–º, —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–Ω—ã–º –Ω–∞–º–∏ —Ä–∞–Ω–µ–µ), –∞ –Ω–µ –≤ –∫—É—á–µ (–∫—É—á—É –∏ —Å—Ç–µ–∫ –º—ã –æ–±—Å—É–¥–∏–º –ø–æ–¥—Ä–æ–±–Ω–µ–µ –≤ <a href="ch04-01-what-is-ownership.html#%D0%A1%D1%82%D0%B5%D0%BA-%D0%B8-%D0%BA%D1%83%D1%87%D0%B0">–ì–ª–∞–≤–µ 4</a><!-- ignore -->), –∏–ª–∏ –∫–æ–≥–¥–∞ –≤–∞–º –Ω—É–∂–Ω–æ —Ç–æ—á–Ω–æ –±—ã—Ç—å —É–≤–µ—Ä–µ–Ω–Ω—ã–º, —á—Ç–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —Å—Ç—Ä–æ–≥–æ –ø–æ—Å—Ç–æ—è–Ω–Ω–æ. –ë–æ–ª–µ–µ –≥–∏–±–∫–∏–º —Ç–∏–ø–æ–º, —á–µ–º –º–∞—Å—Å–∏–≤, —è–≤–ª—è–µ—Ç—Å—è –≤–µ–∫—Ç–æ—Ä. <em>–í–µ–∫—Ç–æ—Ä</em> ‚Äî —ç—Ç–æ –ø–æ—Ö–æ–∂–∏–π –Ω–∞ –º–∞—Å—Å–∏–≤ —Ç–∏–ø –∫–æ–ª–ª–µ–∫—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ–º—ã–π —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–æ–π. –í–µ–∫—Ç–æ—Ä <em>–º–æ–∂–Ω–æ</em> —Å–æ–∫—Ä–∞—â–∞—Ç—å –∏–ª–∏ —É–¥–ª–∏–Ω—è—Ç—å. –ï—Å–ª–∏ –≤—ã —Å–æ–º–Ω–µ–≤–∞–µ—Ç–µ—Å—å, —á—Ç–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å: –º–∞—Å—Å–∏–≤ –∏–ª–∏ –≤–µ–∫—Ç–æ—Ä, –≤–æ–∑–º–æ–∂–Ω–æ, –≤–∞–º –Ω—É–∂–µ–Ω –≤–µ–∫—Ç–æ—Ä. –í–µ–∫—Ç–æ—Ä—ã –±—É–¥—É—Ç —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω—ã –ø–æ–¥—Ä–æ–±–Ω–µ–µ –≤ <a href="ch08-01-vectors.html">–ì–ª–∞–≤–µ 8</a><!-- ignore -->.</p>
<p>–û–¥–Ω–∞–∫–æ, –º–∞—Å—Å–∏–≤—ã –±—É–¥—É—Ç –ø–æ–ª–µ–∑–Ω—ã –≤ —Ç–æ–º —Å–ª—É—á–∞–µ, –µ—Å–ª–∏ –≤—ã —Ç–æ—á–Ω–æ –∑–Ω–∞–µ—Ç–µ, —á—Ç–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –∏–∑–º–µ–Ω–∏—Ç—Å—è. –ù–∞–ø—Ä–∏–º–µ—Ä, –µ—Å–ª–∏ –≤ —Å–≤–æ–µ–π –ø—Ä–æ–≥—Ä–∞–º–º–µ –≤—ã –∏—Å–ø–æ–ª—å–∑—É–µ—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏—è –º–µ—Å—è—Ü–µ–≤, –≤–∞–º, –≤–µ—Ä–æ—è—Ç–Ω–æ, –ø–æ–Ω–∞–¥–æ–±–∏—Ç—Å—è –∏–º–µ–Ω–Ω–æ –º–∞—Å—Å–∏–≤, –ø–æ—Å–∫–æ–ª—å–∫—É –≤—ã —Ç–æ—á–Ω–æ –∑–Ω–∞–µ—Ç–µ, —á—Ç–æ –æ–Ω –≤—Å–µ–≥–¥–∞ –±—É–¥–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å 12 —ç–ª–µ–º–µ–Ω—Ç–æ–≤:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let months = ["–Ø–Ω–≤–∞—Ä—å", "–§–µ–≤—Ä–∞–ª—å", "–ú–∞—Ä—Ç", "–ê–ø—Ä–µ–ª—å", "–ú–∞–π", "–ò—é–Ω—å", "–ò—é–ª—å",
              "–ê–≤–≥—É—Å—Ç", "–°–µ–Ω—Ç—è–±—Ä—å", "–û–∫—Ç—è–±—Ä—å", "–ù–æ—è–±—Ä—å", "–î–µ–∫–∞–±—Ä—å"];
<span class="boring">}</span></code></pre></pre>
<p>–¢–∏–ø –º–∞—Å—Å–∏–≤–∞ –∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è –∫–∞–∫ —Ä–∞–∑–¥–µ–ª—ë–Ω–Ω–∞—è —Ç–æ—á–∫–æ–π —Å –∑–∞–ø—è—Ç–æ–π –∏ –∑–∞–∫–ª—é—á—ë–Ω–Ω–∞—è –≤ –∫–≤–∞–¥—Ä–∞—Ç–Ω—ã–µ —Å–∫–æ–±–∫–∏ –ø–∞—Ä–∞ –∏–∑ —Ç–∏–ø–∞, –∫ –∫–æ—Ç–æ—Ä–æ–º—É –±—É–¥–µ—Ç –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∞—Ç—å –∫–∞–∂–¥—ã–π —ç–ª–µ–º–µ–Ω—Ç, –∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞. –ù–∞–ø—Ä–∏–º–µ—Ä:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];
<span class="boring">}</span></code></pre></pre>
<p><code>i32</code> ‚Äî —ç—Ç–æ —Ç–∏–ø –∫–∞–∂–¥–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –º–∞—Å—Å–∏–≤–∞. –°—Ç–æ—è—â–∞—è –ø–æ—Å–ª–µ —Ç–æ—á–∫–∏ —Å –∑–∞–ø—è—Ç–æ–π <code>5</code> –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –º–∞—Å—Å–∏–≤ —Å–æ–¥–µ—Ä–∂–∏—Ç –ø—è—Ç—å —ç–ª–µ–º–µ–Ω—Ç–æ–≤.</p>
<p>–í—ã —Ç–∞–∫–∂–µ –º–æ–∂–µ—Ç–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –º–∞—Å—Å–∏–≤ –æ–¥–∏–Ω–∞–∫–æ–≤—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π. –î–ª—è —ç—Ç–æ–≥–æ –≤–æ–∑—å–º–∏—Ç–µ –∑–∞–ø–∏—Å—å —Ç–∏–ø–∞ –º–∞—Å—Å–∏–≤–∞ –∏ –≤–º–µ—Å—Ç–æ —Ç–∏–ø–∞ –≤—Å–µ—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∑–∞–ø–∏—à–∏—Ç–µ –∂–µ–ª–∞–µ–º—ã–π –ª–∏—Ç–µ—Ä–∞–ª; –≤–æ—Ç —Ç–∞–∫:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [3; 5];
<span class="boring">}</span></code></pre></pre>
<p>–ú–∞—Å—Å–∏–≤ –ø–æ–¥ –Ω–∞–∑–≤–∞–Ω–∏–µ–º <code>a</code> —Å–æ–¥–µ—Ä–∂–∏—Ç <code>5</code> —ç–ª–µ–º–µ–Ω—Ç–æ–≤, –∫–∞–∂–¥—ã–π –∏–∑ –∫–æ—Ç–æ—Ä—ã—Ö –±—É–¥–µ—Ç —Ä–∞–≤–µ–Ω <code>3</code>. –≠—Ç–∞ –∑–∞–ø–∏—Å—å —ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–Ω–∞ <code>let a = [3, 3, 3, 3, 3];</code>, –Ω–æ, –æ—á–µ–≤–∏–¥–Ω–æ, –∑–∞–ø–∏—Å—å –≤—ã—à–µ –∫—É–¥–∞ –ø—Ä–æ—â–µ –∏ –ø—Ä–æ–∑—Ä–∞—á–Ω–µ–µ.</p>
<h5 id="–ü–æ–ª—É—á–µ–Ω–∏–µ-—ç–ª–µ–º–µ–Ω—Ç–æ–≤-–º–∞—Å—Å–∏–≤–∞"><a class="header" href="#–ü–æ–ª—É—á–µ–Ω–∏–µ-—ç–ª–µ–º–µ–Ω—Ç–æ–≤-–º–∞—Å—Å–∏–≤–∞">–ü–æ–ª—É—á–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞</a></h5>
<p>–ú–∞—Å—Å–∏–≤ ‚Äî —ç—Ç–æ –µ–¥–∏–Ω—ã–π —É—á–∞—Å—Ç–æ–∫ –ø–∞–º—è—Ç–∏ –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–≥–æ –∏–∑–≤–µ—Å—Ç–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞, —Ä–∞–∑–º–µ—â–∞–µ–º—ã–π –Ω–∞ —Å—Ç–µ–∫–µ. –í—ã –º–æ–∂–µ—Ç–µ –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ —ç–ª–µ–º–µ–Ω—Ç–∞–º –º–∞—Å—Å–∏–≤–∞, –æ–±—Ä–∞—â–∞—è—Å—å –∫ –Ω–∏–º –ø–æ –∏–Ω–¥–µ–∫—Å—É; –≤–æ—Ç —Ç–∞–∫:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}</code></pre></pre>
<p>–í —ç—Ç–æ–º –ø—Ä–∏–º–µ—Ä–µ, –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è <code>first</code> –∏–º–µ–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ <code>1</code>, –ø–æ—Å–∫–æ–ª—å–∫—É —ç—Ç–æ ‚Äî –∑–Ω–∞—á–µ–Ω–∏–µ –º–∞—Å—Å–∏–≤–∞ –ø–æ –∏–Ω–¥–µ–∫—Å—É <code>[0]</code>. –ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è <code>second</code> –∏–º–µ–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ <code>2</code>, –ø–æ–ª—É—á–µ–Ω–Ω–æ–µ –∏–∑ –º–∞—Å—Å–∏–≤–∞ –ø–æ –∏–Ω–¥–µ–∫—Å—É <code>[1]</code>.</p>
<h5 id="–û–±—Ä–∞—â–µ–Ω–∏–µ-–∫-—ç–ª–µ–º–µ–Ω—Ç—É-–º–∞—Å—Å–∏–≤–∞-–∑–∞-–µ–≥–æ-–ø—Ä–µ–¥–µ–ª–∞–º–∏"><a class="header" href="#–û–±—Ä–∞—â–µ–Ω–∏–µ-–∫-—ç–ª–µ–º–µ–Ω—Ç—É-–º–∞—Å—Å–∏–≤–∞-–∑–∞-–µ–≥–æ-–ø—Ä–µ–¥–µ–ª–∞–º–∏">–û–±—Ä–∞—â–µ–Ω–∏–µ –∫ —ç–ª–µ–º–µ–Ω—Ç—É –º–∞—Å—Å–∏–≤–∞ –∑–∞ –µ–≥–æ –ø—Ä–µ–¥–µ–ª–∞–º–∏</a></h5>
<p>–î–∞–≤–∞–π—Ç–µ –ø–æ—Å–º–æ—Ç—Ä–∏–º, —á—Ç–æ –±—É–¥–µ—Ç, –µ—Å–ª–∏ –ø–æ–ø—ã—Ç–∞—Ç—å—Å—è –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ —ç–ª–µ–º–µ–Ω—Ç—É, –∫–æ—Ç–æ—Ä—ã–π –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ –º–∞—Å—Å–∏–≤–∞. –î–æ–ø—É—Å—Ç–∏–º, –≤—ã –ø–∏—à–µ—Ç–µ –≤–æ—Ç —Ç–∞–∫–æ–π –∫–æ–¥, –ø–æ—Ö–æ–∂–∏–π –Ω–∞ –∏–≥—Ä—É –≤ —É–≥–∞–¥–∞–π–∫—É –∏–∑ –ì–ª–∞–≤—ã 2, –∏ –∑–∞–ø—É—Å–∫–∞–µ—Ç–µ –µ–≥–æ. –ü—Ä–æ–≥—Ä–∞–º–º–∞ –∑–∞–ø—Ä–æ—Å–∏—Ç —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–Ω–¥–µ–∫—Å –¥–ª—è –æ–±—Ä–∞—â–µ–Ω–∏—è –∫ –º–∞—Å—Å–∏–≤—É:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><code class="language-rust ignore panics">use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∏–Ω–¥–µ–∫—Å —ç–ª–µ–º–µ–Ω—Ç–∞ –º–∞—Å—Å–∏–≤–∞.");

    let mut index = String::new();

    io::stdin()
        .read_line(&amp;mut index)
        .expect("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–µ—Å—Ç—å –≤–≤–æ–¥.");

    let index: usize = index
        .trim()
        .parse()
        .expect("–í–≤–µ–¥–µ–Ω–æ –Ω–µ —á–∏—Å–ª–æ");

    let element = a[index];

    println!("–ó–Ω–∞—á–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–∞ –º–∞—Å—Å–∏–≤–∞ –ø–æ –∏–Ω–¥–µ–∫—Å—É {index}: {element}");
}</code></pre>
<p>–≠—Ç–æ—Ç –∫–æ–¥ –∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è –±–µ–∑ –ø—Ä–æ–±–ª–µ–º. –ï—Å–ª–∏ –≤—ã –∑–∞–ø—É—Å—Ç–∏—Ç–µ —ç—Ç–æ—Ç –∫–æ–¥ —Å –ø–æ–º–æ—â—å—é <code>cargo run</code> –∏ –≤–≤–µ–¥—ë—Ç–µ <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code> –∏–ª–∏ <code>4</code>, –ø—Ä–æ–≥—Ä–∞–º–º–∞ –Ω–∞–ø–µ—á–∞—Ç–∞–µ—Ç –≤—ã–≤–æ–¥ —Å —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–º –∏–Ω–¥–µ–∫—Å—É —ç–ª–µ–º–µ–Ω—Ç–æ–º –º–∞—Å—Å–∏–≤–∞. –ï—Å–ª–∏ –∂–µ –≤—ã –≤–≤–µ–¥—ë—Ç–µ –∫–∞–∫–æ–µ-–Ω–∏–±—É–¥—å –≤—ã—Ö–æ–¥—è—â–µ–µ –∑–∞ –ø—Ä–µ–¥–µ–ª—ã –º–∞—Å—Å–∏–≤–∞ —á–∏—Å–ª–æ (–Ω–∞–ø—Ä–∏–º–µ—Ä, <code>10</code>), –≤—ã —É–≤–∏–¥–∏—Ç–µ –≤—ã–≤–æ–¥ –≤—Ä–æ–¥–µ —Ç–∞–∫–æ–≥–æ:</p>
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access
cargo run
10
-->
<pre><code class="language-console">thread 'main' panicked at src/main.rs:19:19:
index out of bounds: the len is 5 but the index is 10
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>–ü—Ä–æ–≥—Ä–∞–º–º–∞ –≤—ã–∑–≤–∞–ª–∞ –æ—à–∏–±–∫—É <em>–∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è</em> –≤ —Å—Ç—Ä–æ—á–∫–µ, –ø–æ–ø—ã—Ç–∞–≤—à–µ–π—Å—è –æ–±—Ä–∞—Ç–∏—Ç—å—Å—è –∫–æ –∑–Ω–∞—á–µ–Ω–∏—é –ø–æ –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ–º—É –∏–Ω–¥–µ–∫—Å—É. –ü—Ä–æ–≥—Ä–∞–º–º–∞ –∑–∞–≤–µ—Ä—à–∏–ª–∞—Å—å —Å —Å–æ–æ–±—â–µ–Ω–∏–µ–º –æ–± –æ—à–∏–±–∫–µ –∏ –Ω–µ –∏—Å–ø–æ–ª–Ω–∏–ª–∞ –ø–æ—Å–ª–µ–¥–Ω—é—é –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é <code>println!</code>. –ö–æ–≥–¥–∞ –≤—ã –ø—ã—Ç–∞–µ—Ç–µ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ —ç–ª–µ–º–µ–Ω—Ç—É –ø–æ –∏–Ω–¥–µ–∫—Å—É, Rust –±—É–¥–µ—Ç –ø—Ä–æ–≤–µ—Ä—è—Ç—å, –º–µ–Ω—å—à–µ –ª–∏ –≤–≤–µ–¥—ë–Ω–Ω—ã–π –≤–∞–º–∏ –∏–Ω–¥–µ–∫—Å, —á–µ–º –¥–ª–∏–Ω–∞ –º–∞—Å—Å–∏–≤–∞. –ï—Å–ª–∏ –∏–Ω–¥–µ–∫—Å –±–æ–ª—å—à–µ –∏–ª–∏ —Ä–∞–≤–µ–Ω –¥–ª–∏–Ω–µ –º–∞—Å—Å–∏–≤–∞, Rust –≤—ã–∑–æ–≤–µ—Ç –ø–∞–Ω–∏–∫—É. –≠—Ç–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –∏–º–µ–Ω–Ω–æ –≤–æ –≤—Ä–µ–º—è –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è –ø—Ä–æ–≥—Ä–∞–º–º—ã (–æ—Å–æ–±–µ–Ω–Ω–æ –≤ –ø—Ä–æ–≥—Ä–∞–º–º–∞—Ö, –ø–æ–¥–æ–±–Ω—ã—Ö –ø—Ä–∏–º–µ—Ä—É –≤—ã—à–µ), –ø–æ—Å–∫–æ–ª—å–∫—É –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –Ω–µ –º–æ–∂–µ—Ç –∑–Ω–∞—Ç—å, –∫–∞–∫–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –≤–≤–µ–¥—ë—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å.</p>
<p>–≠—Ç–æ ‚Äî –Ω–∞–≥–ª—è–¥–Ω—ã–π –ø—Ä–∏–º–µ—Ä –ø—Ä–∏–Ω—Ü–∏–ø–æ–≤ –æ–±–µ—Å–ø–µ—á–µ–Ω–∏—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –ø–∞–º—è—Ç–∏ –≤ Rust. –í–æ –º–Ω–æ–≥–∏—Ö –Ω–∏–∑–∫–æ—É—Ä–æ–≤–Ω–µ–≤—ã—Ö —è–∑—ã–∫–∞—Ö –ø–æ–¥–æ–±–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–µ –ø—Ä–æ–≤–æ–¥—è—Ç—Å—è, –∞ –ø–æ—Ç–æ–º—É –æ–±—Ä–∞—â–µ–Ω–∏–µ –∫ —ç–ª–µ–º–µ–Ω—Ç–∞–º –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ –º–∞—Å—Å–∏–≤–∞ –ø—Ä–∏–≤–æ–¥–∏—Ç –∫ –ø–æ–ª—É—á–µ–Ω–∏—é –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö. Rust –∑–∞—â–∏—â–∞–µ—Ç –≤–∞—Å –æ—Ç –ø–æ–¥–æ–±–Ω—ã—Ö –æ—à–∏–±–æ–∫, –º–≥–Ω–æ–≤–µ–Ω–Ω–æ –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—è –ø—Ä–æ–≥—Ä–∞–º–º—É –≤–º–µ—Å—Ç–æ —Ç–æ–≥–æ, —á—Ç–æ–±—ã –¥–∞—Ç—å –¥–æ—Å—Ç—É–ø –∫ –ø–∞–º—è—Ç–∏ –∏ –¥–∞—Ç—å –≤–∞–º –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å —Å –Ω–µ–π —Ä–∞–±–æ—Ç–∞—Ç—å. –ì–ª–∞–≤–∞ 9 –ø–æ–¥—Ä–æ–±–Ω–µ–µ –æ—Å–≤–µ—â–∞–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∫—É –æ—à–∏–±–æ–∫ –≤ Rust –∏ —Å–ø–æ—Å–æ–±—ã –Ω–∞–ø–∏—Å–∞–Ω–∏—è –±–æ–ª–µ–µ —á–∏—Ç–∞–µ–º–æ–≥–æ –∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –∫–æ–¥–∞ ‚Äî —Ç–∞–∫–æ–≥–æ, –∫–æ—Ç–æ—Ä—ã–π –Ω–µ –∑–∞–ø–∞–Ω–∏–∫—É–µ—Ç –∏ –Ω–µ –ø–æ–∑–≤–æ–ª–∏—Ç –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –æ–±—Ä–∞—â–∞—Ç—å—Å—è –∫ –ø–∞–º—è—Ç–∏.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–§—É–Ω–∫—Ü–∏–∏"><a class="header" href="#–§—É–Ω–∫—Ü–∏–∏">–§—É–Ω–∫—Ü–∏–∏</a></h2>
<p>–§—É–Ω–∫—Ü–∏–∏ ‚Äî —ç—Ç–æ –Ω–µ–æ—Ç—ä–µ–º–ª–µ–º–∞—è —á–∞—Å—Ç—å –ø—Ä–æ–≥—Ä–∞–º–º –Ω–∞ Rust. –í—ã —É–∂–µ —É–≤–∏–¥–µ–ª–∏ –æ–¥–Ω—É –∏–∑ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –Ω–∞–∏–±–æ–ª–µ–µ –≤–∞–∂–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π —è–∑—ã–∫–∞ ‚Äî —Ñ—É–Ω–∫—Ü–∏—é <code>main</code>, —è–≤–ª—è—é—â—É—é—Å—è —Ç–æ—á–∫–æ–π –≤—Ö–æ–¥–∞ –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∞. –í—ã —Ç–∞–∫–∂–µ –∑–Ω–∞–∫–æ–º—ã —Å –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–æ–º <code>fn</code>, –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–º –¥–ª—è –æ–±—ä—è–≤–ª–µ–Ω–∏—è –Ω–æ–≤—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π.</p>
<p>–ü—Ä–∏–Ω—è—Ç—ã–º –≤ Rust —Å—Ç–∏–ª–µ–º –Ω–∞–ø–∏—Å–∞–Ω–∏—è –∏–º—ë–Ω —Ñ—É–Ω–∫—Ü–∏–π –∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö —è–≤–ª—è–µ—Ç—Å—è <em>snake case</em> ‚Äî –≤ –Ω—ë–º –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –±—É–∫–≤—ã —Ç–æ–ª—å–∫–æ –≤ –Ω–∏–∂–Ω–µ–º —Ä–µ–≥–∏—Å—Ç—Ä–µ, –∞ —Å–ª–æ–≤–∞ —Ä–∞–∑–¥–µ–ª—è—é—Ç—Å—è –Ω–∏–∂–Ω–∏–º–∏ –ø–æ–¥—á—ë—Ä–∫–∏–≤–∞–Ω–∏—è–º–∏. –í–æ—Ç –ø—Ä–æ–≥—Ä–∞–º–º–∞, —Å–æ–¥–µ—Ä–∂–∞—â–∞—è –ø—Ä–∏–º–µ—Ä –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ñ—É–Ω–∫—Ü–∏–∏:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    println!("Hello, world!");

    another_function();
}

fn another_function() {
    println!("–î—Ä—É–≥–∞—è —Ñ—É–Ω–∫—Ü–∏—è.");
}</code></pre></pre>
<p>–§—É–Ω–∫—Ü–∏—è –≤ Rust –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è —Å –ø–æ–º–æ—â—å—é <code>fn</code>, –∑–∞ –∫–æ—Ç–æ—Ä—ã–º —Å–ª–µ–¥—É–µ—Ç –∏–º—è —Ñ—É–Ω–∫—Ü–∏–∏ –∏ –ø–∞—Ä–∞ –∫—Ä—É–≥–ª—ã—Ö —Å–∫–æ–±–æ–∫. –§–∏–≥—É—Ä–Ω—ã–µ —Å–∫–æ–±–∫–∏ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –¥–ª—è —É–∫–∞–∑–∞–Ω–∏—è –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä—É, –≥–¥–µ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è –∏ –∑–∞–∫–∞–Ω—á–∏–≤–∞–µ—Ç—Å—è —Ç–µ–ª–æ —Ñ—É–Ω–∫—Ü–∏–∏.</p>
<p>–ú—ã –º–æ–∂–µ–º –≤—ã–∑–≤–∞—Ç—å –ª—é–±—É—é –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—É—é –Ω–∞–º–∏ —Ñ—É–Ω–∫—Ü–∏—é, –Ω–∞–ø–∏—Å–∞–≤ –µ—ë –∏–º—è –∏ –ø–∞—Ä—É –∫—Ä—É–≥–ª—ã—Ö —Å–∫–æ–±–æ–∫. –ü–æ—Å–∫–æ–ª—å–∫—É <code>another_function</code> –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ –≤ –ø—Ä–æ–≥—Ä–∞–º–º–µ, –æ–Ω–∞ –º–æ–∂–µ—Ç –±—ã—Ç—å –≤—ã–∑–≤–∞–Ω–∞ –∏–∑ —Ñ—É–Ω–∫—Ü–∏–∏ <code>main</code>. –û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ –º—ã –æ–ø—Ä–µ–¥–µ–ª–∏–ª–∏ <code>another_function</code> <em>–ø–æ—Å–ª–µ</em> —Ñ—É–Ω–∫—Ü–∏–µ–π <code>main</code>, –æ–¥–Ω–∞–∫–æ –º—ã –º–æ–≥–ª–∏ –±—ã –µ—ë –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∏ –ø–µ—Ä–µ–¥ –Ω–µ–π. Rust –Ω–µ—Ç —Ä–∞–∑–Ω–∏—Ü—ã, –≤ –∫–∞–∫–æ–º –ø–æ—Ä—è–¥–∫–µ –≤—ã –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç–µ —Ñ—É–Ω–∫—Ü–∏–∏ ‚Äî –≤–∞–∂–Ω–æ —Ç–æ–ª—å–∫–æ, —á—Ç–æ–±—ã –æ–Ω–∏ –±—ã–ª–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω—ã –≤ —Ç–æ–π –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏, –∏–∑ –∫–æ—Ç–æ—Ä–æ–π –∏—Ö –ø–æ–ª—É—á–∏—Ç—Å—è –≤—ã–∑–≤–∞—Ç—å —Ç–∞–º, –≥–¥–µ –æ–Ω–∏ –Ω—É–∂–Ω—ã.</p>
<p>–°–æ–∑–¥–∞–¥–∏–º –Ω–æ–≤—ã–π –∏—Å–ø–æ–ª–Ω—è–µ–º—ã–π –ø—Ä–æ–µ–∫—Ç –ø–æ–¥ –Ω–∞–∑–≤–∞–Ω–∏–µ–º <em>functions</em>, —á—Ç–æ–±—ã –≤ –Ω—ë–º –∏–∑—É—á–∏—Ç—å —Ä–∞–±–æ—Ç—É —Ñ—É–Ω–∫—Ü–∏–π. –ü–æ–º–µ—Å—Ç–∏—Ç–µ –ø—Ä–∏–º–µ—Ä <code>another_function</code> –≤ <em>src/main.rs</em> –∏ –∑–∞–ø—É—Å—Ç–∏—Ç–µ –µ–≥–æ. –í—ã —É–≤–∏–¥–∏—Ç–µ —Å–ª–µ–¥—É—é—â–∏–π –≤—ã–≤–æ–¥:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.28s
     Running `target/debug/functions`
Hello, world!
–î—Ä—É–≥–∞—è —Ñ—É–Ω–∫—Ü–∏—è.
</code></pre>
<p>–í—ã—Ä–∞–∂–µ–Ω–∏—è –∏—Å–ø–æ–ª–Ω—è—é—Ç—Å—è –≤ —Ç–æ–º –ø–æ—Ä—è–¥–∫–µ, –≤ –∫–∞–∫–æ–º –æ–Ω–∏ –∑–∞–ø–∏—Å–∞–Ω—ã –≤ —Ñ—É–Ω–∫—Ü–∏–∏ <code>main</code>. –ü–µ—Ä–≤—ã–º –ø–µ—á–∞—Ç–∞–µ—Ç—Å—è —Å–æ–æ–±—â–µ–Ω–∏–µ "Hello, world!", –∏ —Ç–æ–ª—å–∫–æ –ø–æ—Ç–æ–º –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è <code>another_function</code> –∏ –ø–µ—á–∞—Ç–∞–µ—Ç—Å—è –µ—ë —Å–æ–æ–±—â–µ–Ω–∏–µ.</p>
<h3 id="–ü–∞—Ä–∞–º–µ—Ç—Ä—ã"><a class="header" href="#–ü–∞—Ä–∞–º–µ—Ç—Ä—ã">–ü–∞—Ä–∞–º–µ—Ç—Ä—ã</a></h3>
<p>–ú—ã –º–æ–∂–µ–º –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ñ—É–Ω–∫—Ü–∏—é —Å <em>–ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏</em> ‚Äî —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–º–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–º–∏, —è–≤–ª—è—é—â–∏–º–∏—Å—è —á–∞—Å—Ç—å—é —Å–∏–≥–Ω–∞—Ç—É—Ä—ã —Ñ—É–Ω–∫—Ü–∏–∏. –ï—Å–ª–∏ —Ñ—É–Ω–∫—Ü–∏—è –∏–º–µ–µ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä—ã, —Ç–æ —á—Ç–æ–±—ã –µ—ë –≤—ã–∑–≤–∞—Ç—å, –≤—ã –¥–æ–ª–∂–Ω—ã –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–∏—Ç—å –µ–π –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –∫–∞–∂–¥–æ–≥–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞. –°—Ç—Ä–æ–≥–æ –≥–æ–≤–æ—Ä—è, –ø–µ—Ä–µ–¥–∞–≤–∞–µ–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –Ω–∞–∑—ã–≤–∞—é—Ç—Å—è <em>–∞—Ä–≥—É–º–µ–Ω—Ç–∞–º–∏</em>, –Ω–æ –≤ –æ–±–∏—Ö–æ–¥–µ —Å–ª–æ–≤–∞ <em>–ø–∞—Ä–∞–º–µ—Ç—Ä</em> –∏ <em>–∞—Ä–≥—É–º–µ–Ω—Ç</em> –≤–∑–∞–∏–º–æ–∑–∞–º–µ–Ω—è–µ–º—ã –∏ –º–æ–≥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è —á—Ç–æ–±—ã –≥–æ–≤–æ—Ä–∏—Ç—å –∫–∞–∫ –æ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –≤ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–∏ —Ñ—É–Ω–∫—Ü–∏–∏, —Ç–∞–∫ –∏ –æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏—è—Ö, –ø–µ—Ä–µ–¥–∞–≤–∞–µ–º—ã—Ö —Ñ—É–Ω–∫—Ü–∏–∏ –ø—Ä–∏ –µ—ë –≤—ã–∑–æ–≤–µ.</p>
<p>–î–æ–±–∞–≤–∏–º —Ñ—É–Ω–∫—Ü–∏–∏ <code>another_function</code> –ø–∞—Ä–∞–º–µ—Ç—Ä:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!("–ó–Ω–∞—á–µ–Ω–∏–µ x: {x}");
}</code></pre></pre>
<p>–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∑–∞–ø—É—Å—Ç–∏—Ç—å —ç—Ç—É –ø—Ä–æ–≥—Ä–∞–º–º—É. –í—ã –¥–æ–ª–∂–Ω—ã —É–≤–∏–¥–µ—Ç—å —Å–ª–µ–¥—É—é—â–∏–π –≤—ã–≤–æ–¥:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.21s
     Running `target/debug/functions`
–ó–Ω–∞—á–µ–Ω–∏–µ x: 5
</code></pre>
<p>–§—É–Ω–∫—Ü–∏—è <code>another_function</code> –∏–º–µ–µ—Ç –æ–¥–∏–Ω –ø–∞—Ä–∞–º–µ—Ç—Ä –ø–æ–¥ –Ω–∞–∑–≤–∞–Ω–∏–µ–º <code>x</code>. –¢–∏–ø <code>x</code> –æ–ø—Ä–µ–¥–µ–ª—ë–Ω –∫–∞–∫ <code>i32</code>. –ö–æ–≥–¥–∞ –º—ã –≤—ã–∑—ã–≤–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é <code>another_function</code> —Å –∞—Ä–≥—É–º–µ–Ω—Ç–æ–º <code>5</code>, –º–∞–∫—Ä–æ—Å <code>println!</code> –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é <code>x</code> –Ω–∞—à–µ–π —Ñ—É–Ω–∫—Ü–∏–∏ –∏ –ø–æ–º–µ—â–∞–µ—Ç –≤–º–µ—Å—Ç–æ –Ω–µ—ë –µ—ë –∑–Ω–∞—á–µ–Ω–∏–µ <code>5</code> –Ω–∞ –º–µ—Å—Ç–æ –º–µ—Ç–∫–∏ –ø–æ–¥—Å—Ç–∞–Ω–æ–≤–∫–∏.</p>
<p>–í—ã <em>–¥–æ–ª–∂–Ω—ã</em> —É–∫–∞–∑—ã–≤–∞—Ç—å —Ç–∏–ø –∫–∞–∂–¥–æ–≥–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –ø—Ä–∏ –æ–±—ä—è–≤–ª–µ–Ω–∏–∏ —Ñ—É–Ω–∫—Ü–∏–∏. –¢–∞–∫–∞—è –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç—å Rust —Å–¥–µ–ª–∞–Ω–∞ –Ω–∞–º–µ—Ä–µ–Ω–Ω–æ: —Ç—Ä–µ–±—É—è –∞–Ω–Ω–æ—Ç–∏—Ä–æ–≤–∞—Ç—å —Ç–∏–ø —Å—Ä–∞–∑—É –ø—Ä–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–∏ —Ñ—É–Ω–∫—Ü–∏–∏, –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –∏–∑–±–∞–≤–ª—è–µ—Ç –≤–∞—Å –æ—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ —Å–∞–º–æ–º—É —É—Ç–æ—á–Ω—è—Ç—å —Ç–∏–ø –ø—Ä–∏ –∫–∞–∂–¥–æ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ —Ñ—É–Ω–∫—Ü–∏–∏. –ö–æ–º–ø–∏–ª—è—Ç–æ—Ä —Ç–∞–∫–∂–µ –º–æ–∂–µ—Ç –¥–∞—Ç—å –±–æ–ª–µ–µ –ø–æ–ª–µ–∑–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –æ–± –æ—à–∏–±–∫–∞—Ö, –µ—Å–ª–∏ –±—É–¥–µ—Ç –∑–Ω–∞—Ç—å, –∫–∞–∫–∏–µ —Ç–∏–ø—ã —Ñ—É–Ω–∫—Ü–∏—è –æ–∂–∏–¥–∞–µ—Ç –ø–æ–ª—É—á–∏—Ç—å.</p>
<p>–ß—Ç–æ–±—ã –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ñ—É–Ω–∫—Ü–∏—é —Å –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏, —Ä–∞–∑–¥–µ–ª–∏—Ç–µ –∏—Ö –∑–∞–ø—è—Ç—ã–º–∏; –≤–æ—Ç —Ç–∞–∫:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    print_labeled_measurement(5, '—á');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("–§–∏–∑–∏—á–µ—Å–∫–∞—è –≤–µ–ª–∏—á–∏–Ω–∞: {value}{unit_label}");
}</code></pre></pre>
<p>–í —ç—Ç–æ–º –ø—Ä–∏–º–µ—Ä–µ –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è —Ñ—É–Ω–∫—Ü–∏—è <code>print_labeled_measurement</code>, –∏–º–µ—é—â–∞—è –¥–≤–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞. –ü–µ—Ä–≤—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä <code>value</code> –∏–º–µ–µ—Ç —Ç–∏–ø <code>i32</code>. –í—Ç–æ—Ä–æ–π ‚Äî <code>unit_label</code>, –∏–º–µ–µ—Ç —Ç–∏–ø <code>char</code>. –î–∞–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ø–µ—á–∞—Ç–∞–µ—Ç –≤–µ–ª–∏—á–∏–Ω—É <code>value</code> —Å –µ—ë —Ä–∞–∑–º–µ—Ä–Ω–æ—Å—Ç—å—é <code>unit_label</code>.</p>
<p>–ó–∞–ø—É—Å—Ç–∏—Ç–µ —ç—Ç–æ—Ç –∫–æ–¥. –î–ª—è —ç—Ç–æ–≥–æ –∑–∞–º–µ–Ω–∏—Ç–µ –∫–æ–¥ –≤ –≤–∞—à–µ–º —Ñ–∞–π–ª–µ <em>src/main.rs</em> –ø—Ä–æ–µ–∫—Ç–∞ <em>functions</em> –ø—Ä–∏–º–µ—Ä–æ–º –≤—ã—à–µ –∏ –∑–∞–ø—É—Å—Ç–∏—Ç–µ –µ–≥–æ —Å –ø–æ–º–æ—â—å—é <code>cargo run</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/functions`
–§–∏–∑–∏—á–µ—Å–∫–∞—è –≤–µ–ª–∏—á–∏–Ω–∞: 5—á
</code></pre>
<p>–ü–æ—Å–∫–æ–ª—å–∫—É –º—ã –≤—ã–∑–≤–∞–ª–∏ —Ñ—É–Ω–∫—Ü–∏—é —Å –∞—Ä–≥—É–º–µ–Ω—Ç–∞–º–∏ <code>5</code> –∏ <code>'—á'</code> (—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º <code>value</code> –∏ <code>unit_label</code>), –≤—ã–≤–æ–¥ –ø—Ä–æ–≥—Ä–∞–º–º—ã —Å–æ–¥–µ—Ä–∂–∏—Ç —ç—Ç–∏ –∑–Ω–∞—á–µ–Ω–∏—è.</p>
<h3 id="–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏-–∏-–≤—ã—Ä–∞–∂–µ–Ω–∏—è"><a class="header" href="#–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏-–∏-–≤—ã—Ä–∞–∂–µ–Ω–∏—è">–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –∏ –≤—ã—Ä–∞–∂–µ–Ω–∏—è</a></h3>
<p>–¢–µ–ª–æ —Ñ—É–Ω–∫—Ü–∏–∏ —Å–æ—Å—Ç–æ–∏—Ç –∏–∑ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–π –∏ (–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ) –≤—ã—Ä–∞–∂–µ–Ω–∏—è –≤ –∫–æ–Ω—Ü–µ. –ü–æ–∫–∞ —á—Ç–æ –Ω–∏ –æ–¥–Ω–∞ –∏–∑ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–Ω—ã—Ö –Ω–∞–º–∏ —Ñ—É–Ω–∫—Ü–∏–π –Ω–µ –∏–º–µ–ª–∞ –∑–∞–≤–µ—Ä—à–∞—é—â–µ–≥–æ –≤—ã—Ä–∞–∂–µ–Ω–∏—è, –Ω–æ –≤—ã —É–∂–µ –≤–∏–¥–µ–ª–∏ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–π –≤ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è—Ö. –ü–æ—Å–∫–æ–ª—å–∫—É Rust ‚Äî —ç—Ç–æ —è–∑—ã–∫, –æ—Å–Ω–æ–≤–µ–Ω–Ω—ã–π –Ω–∞ –≤—ã—Ä–∞–∂–µ–Ω–∏—è—Ö, –≤–∞–∂–Ω–æ –ø–æ–Ω—è—Ç—å —Ä–∞–∑–Ω–∏—Ü—É –º–µ–∂–¥—É –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è–º–∏ –∏ –≤—ã—Ä–∞–∂–µ–Ω–∏—è–º–∏; –¥—Ä—É–≥–∏–µ —è–∑—ã–∫–∏ —á–∞—Å—Ç–æ –Ω–µ –∏–º–µ—é—Ç –ø–æ–¥–æ–±–Ω–æ–≥–æ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è. –î–∞–≤–∞–π—Ç–µ –ø–æ—Å–º–æ—Ç—Ä–∏–º, —á–µ–º —è–≤–ª—è—é—Ç—Å—è –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –∏ –≤—ã—Ä–∞–∂–µ–Ω–∏—è –∏ –∫–∞–∫ –∏—Ö –æ—Ç–ª–∏—á–∏—è –≤–ª–∏—è—é—Ç –Ω–∞ —Ä–∞–±–æ—Ç—É —Ñ—É–Ω–∫—Ü–∏–π.</p>
<ul>
<li><strong>–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è</strong> ‚Äî —ç—Ç–æ –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ; –æ–Ω–∞ –Ω–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ.</li>
<li><strong>–í—ã—Ä–∞–∂–µ–Ω–∏–µ</strong> ‚Äî —ç—Ç–æ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –≤—ã—á–∏—Å–ª–µ–Ω–∏–π, –ø—Ä–æ–∏–∑–≤–æ–¥—è—â–∞—è –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ.</li>
</ul>
<p>–ù–∞ —Å–∞–º–æ–º –¥–µ–ª–µ, –º—ã —É–∂–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –∏ –≤—ã—Ä–∞–∂–µ–Ω–∏—è. –°–æ–∑–¥–∞–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –∏ –ø—Ä–∏–ø–∏—Å—ã–≤–∞–Ω–∏–µ –µ–π –∑–Ω–∞—á–µ–Ω–∏—è —Å –ø–æ–º–æ—â—å—é –∫–ª—é—á–µ–≥–æ–≤–æ–≥–æ —Å–ª–æ–≤–∞ <code>let</code> ‚Äî —ç—Ç–æ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è. –ü–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –≤ –õ–∏—Å—Ç–∏–Ω–≥ 3-1: <code>let y = 6;</code> —è–≤–ª—è–µ—Ç—Å—è –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–µ–π.</p>
<Listing number="3-1" file-name="src/main.rs" caption="A `main` function declaration containing one statement">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let y = 6;
}</code></pre></pre>
</Listing>
<p>–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ñ—É–Ω–∫—Ü–∏–π ‚Äî —ç—Ç–æ —Ç–æ–∂–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è; –≤–æ–æ–±—â–µ, –≤–µ—Å—å –ø—Ä–µ–¥—ã–¥—É—â–∏–π –ø—Ä–∏–º–µ—Ä —Å–∞–º –ø–æ —Å–µ–±–µ —è–≤–ª—è–µ—Ç—Å—è –≤—ã—Ä–∞–∂–µ–Ω–∏–µ–º. (–ù–æ –∫–∞–∫ –º—ã —É–≤–∏–¥–∏–º –¥–∞–ª–µ–µ, <em>–≤—ã–∑–æ–≤</em> —Ñ—É–Ω–∫—Ü–∏–∏ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–µ–π –Ω–µ —è–≤–ª—è–µ—Ç—Å—è.)</p>
<p>–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –Ω–µ –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç –∑–Ω–∞—á–µ–Ω–∏–π. –°–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ, –≤—ã –Ω–µ –º–æ–∂–µ—Ç–µ –ø—Ä–∏—Å–≤–æ–∏—Ç—å –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é <code>let</code> –¥—Ä—É–≥–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π, –∫–∞–∫ –≤ –∫–æ–¥–µ –Ω–∏–∂–µ ‚Äî –≤—ã –ø–æ–ª—É—á–∏—Ç–µ –æ—à–∏–±–∫—É:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = (let y = 6);
}</code></pre>
<p>–ï—Å–ª–∏ –≤—ã –∑–∞–ø—É—Å—Ç–∏—Ç–µ —ç—Ç—É –ø—Ä–æ–≥—Ä–∞–º–º—É, –≤—ã –ø–æ–ª—É—á–∏—Ç–µ —Å–ª–µ–¥—É—é—â—É—é –æ—à–∏–±–∫—É:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found `let` statement
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^
  |
  = note: only supported directly in conditions of `if` and `while` expressions

warning: unnecessary parentheses around assigned value
 --&gt; src/main.rs:2:13
  |
2 |     let x = (let y = 6);
  |             ^         ^
  |
  = note: `#[warn(unused_parens)]` on by default
help: remove these parentheses
  |
2 -     let x = (let y = 6);
2 +     let x = let y = 6;
  |

warning: `functions` (bin "functions") generated 1 warning
error: could not compile `functions` (bin "functions") due to 1 previous error; 1 warning emitted
</code></pre>
<p>–í—ã—Ä–∞–∂–µ–Ω–∏–µ <code>let y = 6</code> –Ω–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–π, —Ç–∞–∫ —á—Ç–æ <code>x</code> –Ω–µ —Å —á–µ–º —Å–≤—è–∑—ã–≤–∞—Ç—å. –≠—Ç–æ –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è –æ—Ç —Ç–æ–≥–æ, —á—Ç–æ –æ–±—ã—á–Ω–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –≤ –¥—Ä—É–≥–∏—Ö —è–∑—ã–∫–∞—Ö, –≤—Ä–æ–¥–µ C –∏–ª–∏ Ruby: –≤ –Ω–∏—Ö –ø—Ä–∏—Å–≤–æ–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—Ä–∏—Å–≤–æ–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ. –í —Ç–∞–∫–∏—Ö —è–∑—ã–∫–∞—Ö –≤–æ–∑–º–æ–∂–Ω—ã –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –≤—Ä–æ–¥–µ <code>x = y = 6</code>: –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π <code>y</code> –±—É–¥–µ—Ç –ø—Ä–∏—Å–≤–æ–µ–Ω–∞ <code>6</code>, –∏ —ç—Ç–æ –ø—Ä–∏—Å–≤–æ–µ–Ω–∏–µ —Å–∞–º–æ –ø–æ —Å–µ–±–µ –≤–µ—Ä–Ω—ë—Ç —Ç—É –∂–µ <code>6</code> –∏ –ø—Ä–∏—Å–≤–æ–∏—Ç –µ—ë –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π <code>x</code>. –í Rust —Ç–∞–∫–æ–µ —Å–¥–µ–ª–∞—Ç—å –Ω–µ –≤—ã–π–¥–µ—Ç.</p>
<p>–í—ã—Ä–∞–∂–µ–Ω–∏—è –≤—ã—á–∏—Å–ª—è—é—Ç—Å—è –≤ –∑–Ω–∞—á–µ–Ω–∏–µ; –æ–Ω–∏ —Å–æ—Å—Ç–∞–≤–ª—è—é—Ç –æ—Å–Ω–æ–≤–Ω—É—é –¥–æ–ª—é –∫–æ–¥–∞, –∫–æ—Ç–æ—Ä—ã–π –≤—ã –±—É–¥–µ—Ç–µ –ø–∏—Å–∞—Ç—å –Ω–∞ Rust. –ù–∞–ø—Ä–∏–º–µ—Ä, –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ (–≤—Ä–æ–¥–µ <code>5 + 6</code>) —è–≤–ª—è—é—Ç—Å—è –≤—ã—Ä–∞–∂–µ–Ω–∏—è–º–∏ (–≤—ã—Ä–∞–∂–µ–Ω–∏–µ <code>5 + 6</code> –≤—ã—á–∏—Å–ª–∏—Ç—Å—è –≤ –∑–Ω–∞—á–µ–Ω–∏–µ <code>11</code>). –í—ã—Ä–∞–∂–µ–Ω–∏—è –º–æ–≥—É—Ç –±—ã—Ç—å —á–∞—Å—Ç—å—é –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–π: –Ω–∞–ø—Ä–∏–º–µ—Ä, <code>6</code> –≤ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ <code>let y = 6;</code> –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 3-1 —è–≤–ª—è–µ—Ç—Å—è –≤—ã—Ä–∞–∂–µ–Ω–∏–µ–º, –∫–æ—Ç–æ—Ä–æ–µ –≤—ã—á–∏—Å–ª—è–µ—Ç—Å—è –≤ –∑–Ω–∞—á–µ–Ω–∏–µ <code>6</code>. –í—ã–∑–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏ —Ç–æ–∂–µ —è–≤–ª—è–µ—Ç—Å—è –≤—ã—Ä–∞–∂–µ–Ω–∏–µ–º, —Ä–∞–≤–Ω–æ –∫–∞–∫ –∏ –≤—ã–∑–æ–≤ –º–∞–∫—Ä–æ—Å–∞. –ù–æ–≤—ã–π –±–ª–æ–∫ –∫–æ–¥–∞, –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã–π —Ñ–∏–≥—É—Ä–Ω—ã–º–∏ —Å–∫–æ–±–∫–∞–º–∏, —Ç–æ–∂–µ —è–≤–ª—è–µ—Ç—Å—è –≤—ã—Ä–∞–∂–µ–Ω–∏–µ–º; –Ω–∞–ø—Ä–∏–º–µ—Ä:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("–ó–Ω–∞—á–µ–Ω–∏–µ y: {y}");
}</code></pre></pre>
<p>–≠—Ç–æ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ ...</p>
<pre><code class="language-rust ignore">{
    let x = 3;
    x + 1
}</code></pre>
<p>... —è–≤–ª—è–µ—Ç—Å—è –±–ª–æ–∫–æ–º –∫–æ–¥–∞, –∫–æ—Ç–æ—Ä—ã–π (–≤ –¥–∞–Ω–Ω–æ–º —Å–ª—É—á–∞–µ) –≤—ã—á–∏—Å–ª—è–µ—Ç—Å—è –≤ <code>4</code>. –≠—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ, –∫–∞–∫ —á–∞—Å—Ç—å –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ <code>let</code>, —Å–≤—è–∑—ã–≤–∞–µ—Ç—Å—è —Å –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π <code>y</code>. –û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ —Å—Ç—Ä–æ–∫–∞ <code>x + 1</code> –Ω–µ –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è —Ç–æ—á–∫–æ–π —Å –∑–∞–ø—è—Ç–æ–π. –í—ã—Ä–∞–∂–µ–Ω–∏—è –Ω–µ –≤–∫–ª—é—á–∞—é—Ç –≤ —Å–µ–±—è —Ç–æ—á–∫—É —Å –∑–∞–ø—è—Ç–æ–π. –ï—Å–ª–∏ –≤—ã –¥–æ–±–∞–≤–∏—Ç–µ —Ç–æ—á–∫—É —Å –∑–∞–ø—è—Ç–æ–π –≤ –∫–æ–Ω–µ—Ü –≤—ã—Ä–∞–∂–µ–Ω–∏—è, –≤—ã –ø—Ä–µ–≤—Ä–∞—Ç–∏—Ç–µ –µ–≥–æ –≤ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é, –∏ –æ–Ω–æ –ø–µ—Ä–µ—Å—Ç–∞–Ω–µ—Ç –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ, –≤ –∫–æ—Ç–æ—Ä–æ–µ –≤—ã—á–∏—Å–ª—è–µ—Ç—Å—è. –ü–æ–º–Ω–∏—Ç–µ –æ–± —ç—Ç–æ–º, –ø–æ–∫–∞ –º—ã –±—É–¥–µ–º —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞—Ç—å –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏–π —Ñ—É–Ω–∫—Ü–∏—è–º–∏ –∏ –≤—ã—Ä–∞–∂–µ–Ω–∏—è–º–∏.</p>
<h3 id="–§—É–Ω–∫—Ü–∏–∏-–≤–æ–∑–≤—Ä–∞—â–∞—é—â–∏–µ-–∑–Ω–∞—á–µ–Ω–∏—è"><a class="header" href="#–§—É–Ω–∫—Ü–∏–∏-–≤–æ–∑–≤—Ä–∞—â–∞—é—â–∏–µ-–∑–Ω–∞—á–µ–Ω–∏—è">–§—É–Ω–∫—Ü–∏–∏, –≤–æ–∑–≤—Ä–∞—â–∞—é—â–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è</a></h3>
<p>–§—É–Ω–∫—Ü–∏–∏ –º–æ–≥—É—Ç –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è –∫–æ–¥—É, –∫–æ—Ç–æ—Ä—ã–π –∏—Ö –≤—ã–∑—ã–≤–∞–µ—Ç. –í–æ–∑–≤—Ä–∞—â–∞–µ–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –Ω–µ –æ–±–æ–∑–Ω–∞—á–∞—é—Ç—Å—è –∏–º–µ–Ω–∞–º–∏, –Ω–æ –º—ã –¥–æ–ª–∂–Ω—ã —É–∫–∞–∑—ã–≤–∞—Ç—å –∏—Ö —Ç–∏–ø –ø–æ—Å–ª–µ —Å—Ç—Ä–µ–ª–∫–∏ (<code>-&gt;</code>). –í Rust, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º —Ñ—É–Ω–∫—Ü–∏–∏ —è–≤–ª—è–µ—Ç—Å—è –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –≤—ã—Ä–∞–∂–µ–Ω–∏—è –≤ –µ—ë —Ç–µ–ª–µ. –í—ã –º–æ–∂–µ—Ç–µ –≤–µ—Ä–Ω—É—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ —Ñ—É–Ω–∫—Ü–∏–∏ —Ä–∞–Ω—å—à–µ –µ—ë –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è, –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–≤ –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ <code>return</code> –∏ —É–∫–∞–∑–∞–≤ –∑–Ω–∞—á–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—Ç–∏—Ç–µ –≤–µ—Ä–Ω—É—Ç—å, –Ω–æ –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–æ —Ñ—É–Ω–∫—Ü–∏–π –Ω–µ—è–≤–Ω–æ –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –≤—ã—Ä–∞–∂–µ–Ω–∏—è. –í–æ—Ç –ø—Ä–∏–º–µ—Ä —Ñ—É–Ω–∫—Ü–∏–∏, –≤–æ–∑–≤—Ä–∞—â–∞—é—â–µ–π –∑–Ω–∞—á–µ–Ω–∏–µ:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn five() -&gt; i32 {
    5
}

fn main() {
    let x = five();

    println!("–ó–Ω–∞—á–µ–Ω–∏–µ x: {x}");
}</code></pre></pre>
<p>–í —Ñ—É–Ω–∫—Ü–∏–∏ <code>five</code> –Ω–µ—Ç –Ω–∏ –≤—ã–∑–æ–≤–æ–≤ —Ñ—É–Ω–∫—Ü–∏–π, –Ω–∏ –º–∞–∫—Ä–æ—Å–æ–≤, –Ω–∏ –¥–∞–∂–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–π <code>let</code> ‚Äî —Ç–æ–ª—å–∫–æ –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ–µ —á–∏—Å–ª–æ <code>5</code>. –≠—Ç–æ –∞–±—Å–æ–ª—é—Ç–Ω–æ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –≤ —è–∑—ã–∫–µ Rust. –û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—ã–π —Ç–∏–ø —Ñ—É–Ω–∫—Ü–∏–∏ —Ç–æ–∂–µ —É–∫–∞–∑–∞–Ω ‚Äî –ø—Ä–∏–ø–∏—Å–∫–æ–π <code>-&gt; i32</code>. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∑–∞–ø—É—Å—Ç–∏—Ç—å —ç—Ç–æ—Ç –ø—Ä–∏–º–µ—Ä; –≤—ã –¥–æ–ª–∂–Ω—ã —É–≤–∏–¥–µ—Ç—å –≤—ã–≤–æ–¥ —Ç–∞–∫–æ–π –∂–µ, –∫–∞–∫ —ç—Ç–æ—Ç:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/functions`
–ó–Ω–∞—á–µ–Ω–∏–µ x: 5
</code></pre>
<p><code>5</code> –≤ —Ñ—É–Ω–∫—Ü–∏–∏ <code>five</code> ‚Äî —ç—Ç–æ –µ—ë –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ, –ø–æ—ç—Ç–æ–º—É —Ç–∏–ø –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è –æ–ø—Ä–µ–¥–µ–ª—ë–Ω –∫–∞–∫ <code>i32</code>. –†–∞—Å—Å–º–æ—Ç—Ä–∏–º —ç—Ç–æ –≤–Ω–∏–º–∞—Ç–µ–ª—å–Ω–µ–µ: –∑–¥–µ—Å—å –µ—Å—Ç—å –¥–≤–∞ –≤–∞–∂–Ω—ã—Ö –º–æ–º–µ–Ω—Ç–∞. –í–æ-–ø–µ—Ä–≤—ã—Ö, —Å—Ç—Ä–æ—á–∫–∞ <code>let x = five();</code> –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç, —á—Ç–æ –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π. –ü–æ—Å–∫–æ–ª—å–∫—É —Ñ—É–Ω–∫—Ü–∏—è <code>five</code> –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç <code>5</code>, —ç—Ç–∞ —Å—Ç—Ä–æ—á–∫–∞ —ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–Ω–∞ —Å—Ç—Ä–æ—á–∫–µ –Ω–∏–∂–µ:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}</span></code></pre></pre>
<p>–í–æ-–≤—Ç–æ—Ä—ã—Ö, —Ñ—É–Ω–∫—Ü–∏—è <code>five</code> –Ω–µ –∏–º–µ–µ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –∏ —É –Ω–µ—ë –æ–ø—Ä–µ–¥–µ–ª—ë–Ω —Ç–∏–ø –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è. –û–¥–Ω–∞–∫–æ —Ç–µ–ª–æ–º —Ñ—É–Ω–∫—Ü–∏–∏ —è–≤–ª—è–µ—Ç—Å—è –ø—Ä–æ—Å—Ç–æ <code>5</code> –±–µ–∑ —Ç–æ—á–∫–∏ —Å –∑–∞–ø—è—Ç–æ–π, —Ç–∞–∫ –∫–∞–∫ —ç—Ç–æ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ –≤—ã—á–∏—Å–ª—è–µ—Ç—Å—è –≤ –∑–Ω–∞—á–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –º—ã —Ö–æ—Ç–∏–º –≤–µ—Ä–Ω—É—Ç—å.</p>
<p>–ü–æ—Å–º–æ—Ç—Ä–∏–º –Ω–∞ –¥—Ä—É–≥–æ–π –ø—Ä–∏–º–µ—Ä:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = plus_one(5);

    println!("–ó–Ω–∞—á–µ–Ω–∏–µ x: {x}");
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1
}</code></pre></pre>
<p>–ó–∞–ø—É—Å–∫ —ç—Ç–æ–≥–æ –∫–æ–¥–∞ –Ω–∞–ø–µ—á–∞—Ç–∞–µ—Ç <code>–ó–Ω–∞—á–µ–Ω–∏–µ x: 6</code>. –ù–æ –µ—Å—Ç—å –º—ã –ø–æ—Å—Ç–∞–≤–∏–º —Ç–æ—á–∫—É —Å –∑–∞–ø—è—Ç–æ–π –≤ –∫–æ–Ω—Ü–µ —Å—Ç—Ä–æ–∫–∏ <code>x + 1</code> (–ø—Ä–µ–≤—Ä–∞—Ç–∏–≤ –µ—ë —Ç–µ–º —Å–∞–º—ã–º –∏–∑ –≤—ã—Ä–∞–∂–µ–Ω–∏—è –≤ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é), –º—ã –ø–æ–ª—É—á–∏–º –æ—à–∏–±–∫—É:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = plus_one(5);

    println!("–ó–Ω–∞—á–µ–Ω–∏–µ x: {x}");
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1;
}</code></pre>
<p>–ö–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞–Ω–∏–µ —ç—Ç–æ–≥–æ –∫–æ–¥–∞ –≤—ã–∑–æ–≤–µ—Ç –æ—à–∏–±–∫—É:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:24
  |
7 | fn plus_one(x: i32) -&gt; i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
8 |     x + 1;
  |          - help: remove this semicolon to return this value

For more information about this error, try `rustc --explain E0308`.
error: could not compile `functions` (bin "functions") due to 1 previous error
</code></pre>
<p>–ì–ª–∞–≤–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ (<code>mismatched types</code>) –≤—ã–∑–≤–∞–Ω–æ –ø—Ä–æ–±–ª–µ–º–æ–π –≤ –æ–ø—Ä–µ–¥–µ–ª—è–µ–º–æ–π –Ω–∞–º–∏ —Ñ—É–Ω–∫—Ü–∏–∏. –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ <code>plus_one</code> –≥–æ–≤–æ—Ä–∏—Ç –æ —Ç–æ–º, —á—Ç–æ –æ–Ω–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç <code>i32</code>, –Ω–æ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –Ω–∏ –≤–æ —á—Ç–æ –Ω–µ –≤—ã—á–∏—Å–ª—è–µ—Ç—Å—è, —á—Ç–æ –≤—ã—Ä–∞–∂–∞–µ—Ç—Å—è –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ–º —Ç–∏–ø–∞ <code>()</code> ‚Äî unit. –°–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ, —Ñ—É–Ω–∫—Ü–∏–∏ –Ω–µ—á–µ–≥–æ –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å, –∏ —ç—Ç–æ –ø—Ä–æ—Ç–∏–≤–æ—Ä–µ—á–∏—Ç –µ—ë –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—é, —á—Ç–æ –∏ –≤—ã–∑—ã–≤–∞–µ—Ç –æ—à–∏–±–∫—É –∫–æ–º–ø–∏–ª—è—Ü–∏–∏. –í –≤—ã–≤–æ–¥–µ –≤—ã—à–µ, Rust –ø—Ä–µ–¥–ª–∞–≥–∞–µ—Ç –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–µ (–∏, –≤ –æ–±—â–µ–º-—Ç–æ, –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ) —Ä–µ—à–µ–Ω–∏–µ –ø—Ä–æ–±–ª–µ–º—ã: —É–±—Ä–∞—Ç—å —Ç–æ—á–∫—É —Å –∑–∞–ø—è—Ç–æ–π.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏"><a class="header" href="#–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏">–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏</a></h2>
<p>–í—Å–µ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç—ã —Å—Ç—Ä–µ–º—è—Ç—Å—è –∫ —Ç–æ–º—É, —á—Ç–æ–±—ã –∏—Ö –∫–æ–¥ –±—ã–ª –ø—Ä–æ—Å—Ç –≤ –ø–æ–Ω–∏–º–∞–Ω–∏–∏, –Ω–æ –∏–Ω–æ–≥–¥–∞ —Ç—Ä–µ–±—É–µ—Ç—Å—è –ø–æ—è—Å–Ω–∏—Ç—å –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ —É—á–∞—Å—Ç–∫–∏ –ø—Ä–æ–≥—Ä–∞–º–º—ã. –í —ç—Ç–∏—Ö —Å–ª—É—á–∞—è—Ö –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç—ã –æ—Å—Ç–∞–≤–ª—è—é—Ç <em>–∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏</em> –≤ –∏—Å—Ö–æ–¥–Ω–æ–º –∫–æ–¥–µ. –ö–æ–º–ø–∏–ª—è—Ç–æ—Ä –∏—Ö –ø—Ä–æ–∏–≥–Ω–æ—Ä–∏—Ä—É–µ—Ç, –Ω–æ –ª—é–¥—è–º, –∫–æ—Ç–æ—Ä—ã–µ –±—É–¥—É—Ç —á–∏—Ç–∞—Ç—å –∏—Å—Ö–æ–¥–Ω—ã–π –∫–æ–¥, –æ–Ω–∏ –ø—Ä–∏–≥–æ–¥—è—Ç—Å—è.</p>
<p>–í–æ—Ç –ø—Ä–æ—Å—Ç–æ–π –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// hello, world
<span class="boring">}</span></code></pre></pre>
<p>–í Rust –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –Ω–∞—á–∏–Ω–∞—é—Ç—Å—è —Å –¥–≤–æ–π–Ω–æ–≥–æ —Å–ª–µ—à–∞ –∏ –ø—Ä–æ–¥–æ–ª–∂–∞—é—Ç—Å—è –¥–æ –∫–æ–Ω—Ü–∞ —Å—Ç—Ä–æ–∫–∏. –ß—Ç–æ–±—ã —Å–¥–µ–ª–∞—Ç—å –º–Ω–æ–≥–æ—Å—Ç—Ä–æ—á–Ω—ã–π –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π, –≤–∞–º –Ω—É–∂–Ω–æ –Ω–∞—á–∞—Ç—å –∫–∞–∂–¥—ã–π –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π —Å <code>//</code>; –≤–æ—Ç —Ç–∞–∫:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// –ú—ã –¥–µ–ª–∞–µ–º —Ç—É—Ç —á—Ç–æ-—Ç–æ —Å—Ç–æ–ª—å —Å–ª–æ–∂–Ω–æ–µ, —á—Ç–æ –Ω–∞–º –Ω—É–∂–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å—Ç—Ä–æ—á–µ–∫,
// —á—Ç–æ–±—ã —É–º–µ—Å—Ç–∏—Ç—å –∏—Å—á–µ—Ä–ø—ã–≤–∞—é—â–µ–µ –æ–±—ä—è—Å–Ω–µ–Ω–∏–µ! –£—Ö! –ù–∞–¥–µ—é—Å—å, —ç—Ç–æ—Ç –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π
// –æ–±—ä—è—Å–Ω–∏—Ç, —á—Ç–æ —Ç—É—Ç –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç.
<span class="boring">}</span></code></pre></pre>
<p>–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ —Ç–∞–∫–∂–µ –º–æ–∂–Ω–æ —Ä–∞—Å–ø–æ–ª–∞–≥–∞—Ç—å –∏ –≤ –∫–æ–Ω—Ü–µ —Å—Ç—Ä–æ–∫ —Å –∫–æ–¥–æ–º:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let lucky_number = 7; // –ú–Ω–µ —Å–µ–≥–æ–¥–Ω—è –ø–æ–≤–µ–∑—ë—Ç
}</code></pre></pre>
<p>–ù–æ —á–∞—â–µ –≤—ã –±—É–¥–µ—Ç–µ –≤–∏–¥–µ—Ç—å –∏—Ö –Ω–∞ –æ—Ç–¥–µ–ª—å–Ω–æ–π —Å—Ç—Ä–æ—á–∫–µ –Ω–∞–¥ –∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–µ–º—ã–º –∫–æ–¥–æ–º:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    // –ú–Ω–µ —Å–µ–≥–æ–¥–Ω—è –ø–æ–≤–µ–∑—ë—Ç
    let lucky_number = 7;
}</code></pre></pre>
<p>–í Rust —Ç–∞–∫–∂–µ –µ—Å—Ç—å –¥—Ä—É–≥–æ–π –≤–∏–¥ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è: –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–æ–Ω–Ω—ã–π. –ú—ã –æ–±—Å—É–¥–∏–º —Ç–∞–∫–∏–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –≤ —Ä–∞–∑–¥–µ–ª–µ <a href="ch14-02-publishing-to-crates-io.html">"–ü—É–±–ª–∏–∫–∞—Ü–∏—è –∫—Ä–µ–π—Ç–∞ –Ω–∞ Crates.io"</a><!-- ignore --> –ì–ª–∞–≤—ã 14.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ-–ø–æ—Ç–æ–∫–æ–º"><a class="header" href="#–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ-–ø–æ—Ç–æ–∫–æ–º">–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ—Ç–æ–∫–æ–º</a></h2>
<p>–í–∞–∂–Ω–µ–π—à–µ–π —á–∞—Å—Ç—å—é –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–∞ —è–∑—ã–∫–æ–≤ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è —è–≤–ª—è—é—Ç—Å—è –æ–ø–µ—Ä–∞—Ç–æ—Ä—ã –≤–µ—Ç–≤–ª–µ–Ω–∏—è –∏ —Ü–∏–∫–ª—ã ‚Äî –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏, –ø–æ–∑–≤–æ–ª—è—é—â–∏–µ –∑–∞–ø—É—Å–∫–∞—Ç—å –∫–æ–¥, —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ (–∏–ª–∏: –ø–æ–∫–∞) –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ —É—Å–ª–æ–≤–∏–µ –∏—Å—Ç–∏–Ω–Ω–æ. –ù–∞–∏–±–æ–ª–µ–µ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—ë–Ω–Ω—ã–º–∏ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏—è–º–∏, –ø–æ–∑–≤–æ–ª—è—é—â–∏–º–∏ –≤–∞–º —É–ø—Ä–∞–≤–ª—è—Ç—å –ø–æ—Ç–æ–∫–æ–º –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è –ø—Ä–æ–≥—Ä–∞–º–º—ã –Ω–∞ Rust, —è–≤–ª—è—é—Ç—Å—è –≤—ã—Ä–∞–∂–µ–Ω–∏—è <code>if</code> –∏ —Ü–∏–∫–ª—ã.</p>
<h3 id="–í—ã—Ä–∞–∂–µ–Ω–∏—è-if"><a class="header" href="#–í—ã—Ä–∞–∂–µ–Ω–∏—è-if">–í—ã—Ä–∞–∂–µ–Ω–∏—è <code>if</code></a></h3>
<p>–í—ã—Ä–∞–∂–µ–Ω–∏–µ <code>if</code> –ø–æ–∑–≤–æ–ª—è–µ—Ç –≤–∞–º –∏—Å–ø–æ–ª–Ω—è—Ç—å –∫–æ–¥ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∏—Å—Ç–∏–Ω–Ω–æ—Å—Ç–∏ —É—Å–ª–æ–≤–∏–π. –í—ã –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç–µ —É—Å–ª–æ–≤–∏–µ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è, –∞ –ø–æ—Ç–æ–º –∏—Å–ø–æ–ª—å–∑—É–µ—Ç–µ <code>if</code>, —á—Ç–æ–±—ã —É–∫–∞–∑–∞—Ç—å –ø—Ä–æ–≥—Ä–∞–º–º–µ: "–ò—Å–ø–æ–ª–Ω–∏ —ç—Ç–æ—Ç –∫–æ–¥, –µ—Å–ª–∏ —É—Å–ª–æ–≤–∏–µ –∏—Å—Ç–∏–Ω–Ω–æ; –∏–Ω–∞—á–µ ‚Äî –Ω–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞–π".</p>
<p>–°–æ–∑–¥–∞–π—Ç–µ –Ω–æ–≤—ã–π –ø—Ä–æ–µ–∫—Ç –≤ —Å–≤–æ–µ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ <em>projects</em> –∏ –Ω–∞–∑–æ–≤–∏—Ç–µ –µ–≥–æ <em>branches</em>. –í –Ω—ë–º –º—ã –±—É–¥–µ–º –∏–∑—É—á–∞—Ç—å –≤—ã—Ä–∞–∂–µ–Ω–∏–µ <code>if</code>. –ó–∞–ø–æ–ª–Ω–∏—Ç–µ —Ñ–∞–π–ª <em>src/main.rs</em> —ç—Ç–∏–º –∫–æ–¥–æ–º:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let number = 3;

    if number &lt; 5 {
        println!("—É—Å–ª–æ–≤–∏–µ –æ–∫–∞–∑–∞–ª–æ—Å—å –∏—Å—Ç–∏–Ω–Ω–æ");
    } else {
        println!("—É—Å–ª–æ–≤–∏–µ –æ–∫–∞–∑–∞–ª–æ—Å—å –ª–æ–∂–Ω–æ");
    }
}</code></pre></pre>
<p>–í—Å–µ –≤—ã—Ä–∞–∂–µ–Ω–∏—è <code>if</code> —Å–æ—Å—Ç–æ—è—Ç —Å –∫–ª—é—á–µ–≤–æ–≥–æ —Å–ª–æ–≤–∞ <code>if</code> –∏ —Å–ª–µ–¥—É—é—â–µ–≥–æ –∑–∞ –Ω–∏–º —É—Å–ª–æ–≤–∏—è. –í –Ω–∞—à–µ–º —Å–ª—É—á–∞–µ, —É—Å–ª–æ–≤–∏–µ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç, –º–µ–Ω—å—à–µ –ª–∏, —á–µ–º 5, –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è <code>number</code>. –í —Ñ–∏–≥—É—Ä–Ω—ã—Ö —Å–∫–æ–±–∫–∞—Ö, —Å—Ä–∞–∑—É –ø–æ—Å–ª–µ —É—Å–ª–æ–≤–∏—è, –º—ã —Ä–∞–∑–º–µ—â–∞–µ–º –∫–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –Ω–∞–¥–æ –∏—Å–ø–æ–ª–Ω–∏—Ç—å, –µ—Å–ª–∏ —É—Å–ª–æ–≤–∏–µ –∏—Å—Ç–∏–Ω–Ω–æ. –ë–ª–æ–∫–∏ –∫–æ–¥–∞, —Å–≤—è–∑–∞–Ω–Ω—ã–µ —Å —É—Å–ª–æ–≤–∏—è–º–∏ –≤ –≤—ã—Ä–∞–∂–µ–Ω–∏—è—Ö <code>if</code>, –∏–Ω–æ–≥–¥–∞ –Ω–∞–∑—ã–≤–∞—é—Ç—Å—è <em>–≤–µ—Ç–≤—è–º–∏</em> ‚Äî –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ –≤–µ—Ç–≤—è–º –≤ –≤—ã—Ä–∞–∂–µ–Ω–∏–∏ <code>match</code>, –∫–æ—Ç–æ—Ä–æ–µ –º—ã –æ–±—Å—É–∂–¥–∞–ª–∏ –≤ —Ä–∞–∑–¥–µ–ª–µ ["–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –¥–æ–≥–∞–¥–∫–∏ —Å –∑–∞–≥–∞–¥–∞–Ω–Ω—ã–º —á–∏—Å–ª–æ–º"] (ch02-00-guessing-game-tutorial.html#–°—Ä–∞–≤–Ω–µ–Ω–∏–µ-–¥–æ–≥–∞–¥–∫–∏-—Å-–∑–∞–≥–∞–¥–∞–Ω–Ω—ã–º-—á–∏—Å–ª–æ–º) <!-- ignore --> –ì–ª–∞–≤—ã 2.</p>
<p>–≠—Ç–æ –Ω–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ, –Ω–æ –º—ã –º–æ–∂–µ–º –¥–æ–±–∞–≤–∏—Ç—å –≤—ã—Ä–∞–∂–µ–Ω–∏–µ <code>else</code>, –∫–æ—Ç–æ—Ä–æ–µ —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ –∫–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –Ω—É–∂–Ω–æ –∑–∞–ø—É—Å—Ç–∏—Ç—å –≤ —Å–ª—É—á–∞–µ, –µ—Å–ª–∏ —É—Å–ª–æ–≤–∏–µ –æ–∫–∞–∑–∞–ª–æ—Å—å –ª–æ–∂–Ω—ã–º. –ï—Å–ª–∏ –≤—ã –Ω–µ –Ω–∞–ø–∏—à–µ—Ç–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ <code>else</code>, –∞ —É—Å–ª–æ–≤–∏–µ –æ–∫–∞–∂–µ—Ç—Å—è –ª–æ–∂–Ω—ã–º, –ø—Ä–æ–≥—Ä–∞–º–º–∞ –ø—Ä–æ—Å—Ç–æ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç –±–ª–æ–∫ –∫–æ–¥–∞ –ø—Ä–∏ <code>if</code> –∏ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç –∏—Å–ø–æ–ª–Ω—è—Ç—å –≤—Å—ë, —á—Ç–æ —Å–ª–µ–¥—É–µ—Ç –∑–∞ –Ω–∏–º.</p>
<p>–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∑–∞–ø—É—Å—Ç–∏—Ç—å —ç—Ç–æ—Ç –∫–æ–¥; –≤—ã –¥–æ–ª–∂–Ω—ã —É–≤–∏–¥–µ—Ç—å —Å–ª–µ–¥—É—é—â–∏–π –≤—ã–≤–æ–¥:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
—É—Å–ª–æ–≤–∏–µ –æ–∫–∞–∑–∞–ª–æ—Å—å –∏—Å—Ç–∏–Ω–Ω–æ
</code></pre>
<p>–ò–∑–º–µ–Ω–∏–º –∑–Ω–∞—á–µ–Ω–∏–µ <code>number</code> –Ω–∞ –∑–Ω–∞—á–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ —Å–¥–µ–ª–∞–µ—Ç —É—Å–ª–æ–≤–∏–µ –ª–æ–∂–Ω—ã–º:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    let number = 7;
<span class="boring">
</span><span class="boring">    if number &lt; 5 {
</span><span class="boring">        println!("—É—Å–ª–æ–≤–∏–µ –æ–∫–∞–∑–∞–ª–æ—Å—å –∏—Å—Ç–∏–Ω–Ω–æ");
</span><span class="boring">    } else {
</span><span class="boring">        println!("—É—Å–ª–æ–≤–∏–µ –æ–∫–∞–∑–∞–ª–æ—Å—å –ª–æ–∂–Ω–æ");
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>–°–Ω–æ–≤–∞ –∑–∞–ø—É—Å—Ç–∏—Ç–µ –ø—Ä–æ–≥—Ä–∞–º–º—É –∏ –≤–∑–≥–ª—è–Ω–∏—Ç–µ –Ω–∞ –≤—ã–≤–æ–¥:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
—É—Å–ª–æ–≤–∏–µ –æ–∫–∞–∑–∞–ª–æ—Å—å –ª–æ–∂–Ω—ã–º
</code></pre>
<p>–°—Ç–æ–∏—Ç —Ç–∞–∫–∂–µ –æ—Ç–º–µ—Ç–∏—Ç—å, —á—Ç–æ —É—Å–ª–æ–≤–∏–µ –≤—Å–µ–≥–¥–∞ <em>–¥–æ–ª–∂–Ω–æ</em> –∏–º–µ—Ç—å —Ç–∏–ø <code>bool</code>, –∏–Ω–∞—á–µ –º—ã –ø–æ–ª—É—á–∏–º –æ—à–∏–±–∫—É –∫–æ–º–ø–∏–ª—è—Ü–∏–∏. –ù–∞–ø—Ä–∏–º–µ—Ä, –ø–æ–ø—Ä–æ–±—É–µ–º –∑–∞–ø—É—Å—Ç–∏—Ç—å —Å–ª–µ–¥—É—é—â–∏–π –∫–æ–¥:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let number = 3;

    if number {
        println!("number –±—ã–ª–æ —Ç—Ä–æ–π–∫–æ–π");
    }
}</code></pre>
<p>–£—Å–ª–æ–≤–∏–µ –ø—Ä–∏ <code>if</code> –≤—ã—á–∏—Å–ª–∏–ª–æ—Å—å –≤ –∑–Ω–∞—á–µ–Ω–∏–µ <code>3</code>, –∏ Rust –±—Ä–æ—Å–∏–ª –æ—à–∏–±–∫—É:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: mismatched types
 --&gt; src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected `bool`, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` (bin "branches") due to 1 previous error
</code></pre>
<p>–û—à–∏–±–∫–∞ —Å–≤–∏–¥–µ—Ç–µ–ª—å—Å—Ç–≤—É–µ—Ç –æ —Ç–æ–º, —á—Ç–æ Rust –æ–∏–∂–¥–∞–ª —É–≤–∏–¥–µ—Ç—å –∑–¥–µ—Å—å <code>bool</code>, –Ω–æ –ø–æ–ª—É—á–∏–ª —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ. –í –æ—Ç–ª–∏—á–∏–µ –æ—Ç —Ç–∞–∫–∏—Ö —è–∑—ã–∫–æ–≤ –∫–∞–∫ Ruby –∏ JavaScript, –≤ Rust –Ω–µ—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∏—Ä–æ–≤–∞—Ç—å –Ω–µ –ª–æ–≥–∏—á–µ—Å–∫–∏–µ —Ç–∏–ø—ã –∫–∞–∫ –ª–æ–≥–∏—á–µ—Å–∫–∏–µ. –í—ã –≤—Å–µ–≥–¥–∞ –¥–æ–ª–∂–Ω—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å <code>if</code> —É—Å–ª–æ–≤–∏–µ, —è–≤–ª—è—é—â–µ–µ—Å—è –≤—ã—Ä–∞–∂–µ–Ω–∏–µ–º, –∫–æ—Ç–æ—Ä–æ–µ –≤—ã—á–∏—Å–ª—è–µ—Ç—Å—è –≤ –ª–æ–≥–∏—á–µ—Å–∫–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ. –ï—Å–ª–∏ –≤—ã —Ö–æ—Ç–∏—Ç–µ –∑–∞–ø—É—Å—Ç–∏—Ç—å –±–ª–æ–∫ –∫–æ–¥–∞ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ <code>number</code> –Ω–µ —Ä–∞–≤–Ω–æ <code>0</code>, –Ω—É–∂–Ω–æ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–∏—Ç—å –≤—ã—Ä–∞–∂–µ–Ω–∏—é <code>if</code> –≤–æ—Ç —Ç–∞–∫–æ–µ —É—Å–ª–æ–≤–∏–µ:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let number = 3;

    if number != 0 {
        println!("number –æ–∫–∞–∑–∞–ª–æ—Å—å –Ω–µ —Ä–∞–≤–Ω–æ –Ω—É–ª—é");
    }
}</code></pre></pre>
<p>–ó–∞–ø—É—Å—Ç–∏–≤ —ç—Ç–æ—Ç –∫–æ–¥, –≤—ã —É–≤–∏–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç <code>number –æ–∫–∞–∑–∞–ª–æ—Å—å –Ω–µ —Ä–∞–≤–Ω–æ –Ω—É–ª—é</code>.</p>
<h4 id="–û–±—Ä–∞–±–æ—Ç–∫–∞-–Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö-—É—Å–ª–æ–≤–∏–π-—Å-–ø–æ–º–æ—â—å—é-else-if"><a class="header" href="#–û–±—Ä–∞–±–æ—Ç–∫–∞-–Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö-—É—Å–ª–æ–≤–∏–π-—Å-–ø–æ–º–æ—â—å—é-else-if">–û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —É—Å–ª–æ–≤–∏–π —Å –ø–æ–º–æ—â—å—é <code>else if</code></a></h4>
<p>–í—ã –º–æ–∂–µ—Ç–µ –ø—Ä–æ–≤–µ—Ä—è—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —É—Å–ª–æ–≤–∏–π, –æ–±—ä–µ–¥–∏–Ω–∏–≤ <code>if</code> –∏ <code>else</code> –≤ –æ–¥–Ω–æ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ <code>else if</code>. –ù–∞–ø—Ä–∏–º–µ—Ä:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number –¥–µ–ª–∏—Ç—Å—è –Ω–∞ 4");
    } else if number % 3 == 0 {
        println!("number –¥–µ–ª–∏—Ç—Å—è –Ω–∞ 3");
    } else if number % 2 == 0 {
        println!("number –¥–µ–ª–∏—Ç—Å—è –Ω–∞ 2");
    } else {
        println!("number –Ω–µ –¥–µ–ª–∏—Ç—Å—è –Ω–∏ –Ω–∞ 4, –Ω–∏ –Ω–∞ 3, –Ω–∏ –Ω–∞ 2");
    }
}</code></pre></pre>
<p>–≠—Ç–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∞ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ –º–æ–∂–µ—Ç –∑–∞–≤–µ—Ä—à–∏—Ç—å—Å—è —á–µ—Ç—ã—Ä—å–º—è —Ä–∞–∑–Ω—ã–º–∏ –ø—É—Ç—è–º–∏. –ó–∞–ø—É—Å—Ç–∏–≤ –µ—ë, –≤—ã —É–≤–∏–¥–∏—Ç–µ —ç—Ç–æ—Ç –≤—ã–≤–æ–¥:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
number –¥–µ–ª–∏—Ç—Å—è 3
</code></pre>
<p>–í —ç—Ç–æ–π –ø—Ä–æ–≥—Ä–∞–º–º–µ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –ø–æ–æ—á–µ—Ä—ë–¥–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞–∂–¥–æ–≥–æ –≤—ã—Ä–∞–∂–µ–Ω–∏—è <code>if</code>. –ö–∞–∫ —Ç–æ–ª—å–∫–æ –ø—Ä–æ–≥—Ä–∞–º–º–∞ –≤—Å—Ç—Ä–µ—Ç–∏—Ç —É—Å–ª–æ–≤–∏–µ, –≤—ã—á–∏—Å–ª—è—é—â–µ–µ—Å—è –≤ <code>true</code>, –∏—Å–ø–æ–ª–Ω–∏—Ç—Å—è —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π –±–ª–æ–∫ –∫–æ–¥–∞. –û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ —Ö–æ—Ç—è 6 –¥–µ–ª–∏—Ç—Å—è –Ω–∞ 2, –º—ã –Ω–µ –≤–∏–¥–∏–º –Ω–∏ <code>number –¥–µ–ª–∏—Ç—Å—è –Ω–∞ 2</code> (—Å–æ–æ–±—â–µ–Ω–∏–µ –ø—Ä–µ–¥–ø–æ—Å–ª–µ–¥–Ω–µ–π –≤–µ—Ç–≤–∏), –Ω–∏ <code>number –Ω–µ –¥–µ–ª–∏—Ç—Å—è –Ω–∏ –Ω–∞ 4, –Ω–∏ –Ω–∞ 3, –Ω–∏ –Ω–∞ 2</code> (—Å–æ–æ–±—â–µ–Ω–∏–µ –≤–µ—Ç–≤–∏ <code>else</code>). –ü—Ä–∏—á–∏–Ω–∞ –≤ —Ç–æ–º, —á—Ç–æ –Ω–∞ –ø–µ—Ä–≤–æ–º –∂–µ –∏—Å—Ç–∏–Ω–Ω–æ–º —É—Å–ª–æ–≤–∏–∏ –ø—Ä–æ–≤–µ—Ä–∫–∞ –∏ –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç—Å—è ‚Äî –∏–¥—É—â–∏–µ –¥–∞–ª–µ–µ —É—Å–ª–æ–≤–∏—è –Ω–µ –ø—Ä–æ–≤–µ—Ä—è—é—Ç—Å—è.</p>
<p>–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –±–æ–ª—å—à–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –≤—ã—Ä–∞–∂–µ–Ω–∏–π <code>else if</code> ‚Äî –≤–µ—Ä–Ω—ã–π —Å–ø–æ—Å–æ–± —Å–¥–µ–ª–∞—Ç—å —Å–≤–æ–π –∫–æ–¥ –∑–∞–ø—É—Ç–∞–Ω–Ω—ã–º –∏ –Ω–µ–ø–æ–Ω—è—Ç–Ω—ã–º. –ï—Å–ª–∏ –≤—ã –∏—Å–ø–æ–ª—å–∑—É–µ—Ç–µ –±–æ–ª—å—à–µ –æ–¥–Ω–æ–≥–æ —Ç–∞–∫–æ–≥–æ –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞, –≤–æ–∑–º–æ–∂–Ω–æ, –≤–∞—à–µ–π –ø—Ä–æ–≥—Ä–∞–º–º–µ –Ω—É–∂–µ–Ω —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥. –ì–ª–∞–≤–∞ 6 —Ä–∞—Å—Å–∫–∞–∂–µ—Ç –≤–∞–º –æ–± –æ–ø–µ—Ä–∞—Ç–æ—Ä–µ –≤–µ—Ç–≤–ª–µ–Ω–∏—è <code>match</code>, –∫–æ—Ç–æ—Ä—ã–π –æ—Ç–ª–∏—á–Ω–æ –ø–æ–¥–æ–π–¥—ë—Ç –¥–ª—è –ø–æ–¥–æ–±–Ω—ã—Ö —Å–ª—É—á–∞–µ–≤.</p>
<h4 id="–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ-if-–≤-–∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏-let"><a class="header" href="#–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ-if-–≤-–∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏-let">–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ <code>if</code> –≤ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ <code>let</code></a></h4>
<p>–ü–æ—Å–∫–æ–ª—å–∫—É <code>if</code> ‚Äî —ç—Ç–æ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ, –º—ã –º–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –µ–≥–æ –≤ –ø—Ä–∞–≤–æ–π —á–∞—Å—Ç–∏ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ <code>let</code>, —á—Ç–æ–±—ã —É—Å–ª–æ–≤–∏–µ–º —É–ø—Ä–∞–≤–ª—è—Ç—å —Ç–µ–º, —á—Ç–æ –ø—Ä–∏—Å–≤–∞–∏–≤–∞–µ—Ç—Å—è –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π. –ü–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –Ω–∞ –õ–∏—Å—Ç–∏–Ω–≥ 3-2.</p>
<Listing number="3-2" file-name="src/main.rs" caption="Assigning the result of an `if` expression to a variable">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("–ó–Ω–∞—á–µ–Ω–∏–µ number: {number}");
}</code></pre></pre>
</Listing>
<p>–ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è <code>number</code> —Å–≤—è–∑—ã–≤–∞–µ—Ç—Å—è —Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º, –≤ –∫–æ—Ç–æ—Ä–æ–µ –≤—ã—á–∏—Å–ª–∏—Ç—Å—è –≤—ã—Ä–∞–∂–µ–Ω–∏–µ <code>if</code>. –ó–∞–ø—É—Å—Ç–∏—Ç–µ —ç—Ç–æ—Ç –∫–æ–¥ –∏ –ø–æ—Å–º–æ—Ç—Ä–∏—Ç–µ, —á—Ç–æ –≤—ã–π–¥–µ—Ç:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/branches`
–ó–Ω–∞—á–µ–Ω–∏–µ number: 5
</code></pre>
<p>–ü–æ–º–Ω–∏—Ç–µ, —á—Ç–æ 1) –±–ª–æ–∫–∏ –∫–æ–¥–∞ –≤—ã—á–∏—Å–ª—è—é—Ç—Å—è –≤ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –∏—Ö –≤—ã—Ä–∞–∂–µ–Ω–∏—è –∏ 2) —á–∏—Å–ª–∞ —Å–∞–º–∏ –ø–æ —Å–µ–±–µ —Ç–æ–∂–µ —è–≤–ª—è—é—Ç—Å—è –≤—ã—Ä–∞–∂–µ–Ω–∏—è–º–∏. –í –Ω–∞—à–µ–º —Å–ª—É—á–∞–µ, –∑–Ω–∞—á–µ–Ω–∏–µ –≤—Å–µ–≥–æ –≤—ã—Ä–∞–∂–µ–Ω–∏—è <code>if</code> –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Ç–æ–≥–æ, –∫–∞–∫–æ–π –∏—Å–ø–æ–ª–Ω–∏—Ç—Å—è –±–ª–æ–∫ –∫–æ–¥–∞. –ò–∑ —ç—Ç–æ–≥–æ —Å–ª–µ–¥—É–µ—Ç, —á—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ –∫–∞–∂–¥–æ–≥–æ –±–ª–æ–∫–∞ –∫–æ–¥–∞ –¥–æ–ª–∂–Ω–æ –∏–º–µ—Ç—å –æ–¥–∏–Ω –∏ —Ç–æ—Ç –∂–µ —Ç–∏–ø. –í –õ–∏—Å—Ç–∏–Ω–≥–µ 3-2 –≤—Å—ë –∏–º–µ–µ–Ω–Ω–æ —Ç–∞–∫: –æ–±–µ –≤–µ—Ç–≤–∏ <code>if</code> –∏ –≤–µ—Ç–≤—å <code>else</code> –≤—ã—á–∏—Å–ª—è—é—Ç—Å—è –≤ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ —Ç–∏–ø–∞ <code>i32</code>. –ï—Å–ª–∏ –≤–µ—Ç–≤–∏ –±—É–¥—É—Ç –≤—ã—á–∏—Å–ª—è—Ç—å—Å—è –≤ –∑–Ω–∞—á–µ–Ω–∏—è —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ (–∫–∞–∫ –ø–æ–∫–∞–∑–∞–Ω–æ –≤ –ø—Ä–∏–º–µ—Ä–µ –Ω–∏–∂–µ), –≤—ã –ø–æ–ª—É—á–∏—Ç–µ –æ—à–∏–±–∫—É:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let condition = true;

    let number = if condition { 5 } else { "—à–µ—Å—Ç—å" };

    println!("–ó–Ω–∞—á–µ–Ω–∏–µ number: {number}");
}</code></pre>
<p>–ï—Å–ª–∏ –ø–æ–ø—ã—Ç–∞—Ç—å—Å—è —Å–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞—Ç—å —ç—Ç–æ—Ç –∫–æ–¥, –º—ã –ø–æ–ª—É—á–∏–º –æ—à–∏–±–∫—É. –ó–Ω–∞—á–µ–Ω–∏—è –≤–µ—Ç–≤–µ–π <code>if</code> –∏ <code>else</code> –∏–º–µ—é—Ç —Ä–∞–∑–Ω—ã–µ —Ç–∏–ø—ã, –∏ Rust –∫–∞–∫ —Ä–∞–∑ —É–∫–∞–∑—ã–≤–∞–µ—Ç, –≥–¥–µ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –æ—à–∏–±–∫–∞:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: `if` and `else` have incompatible types
 --&gt; src/main.rs:4:44
  |
4 |     let number = if condition { 5 } else { "—à–µ—Å—Ç—å" };
  |                                 -          ^^^^^^^ expected integer, found `&amp;str`
  |                                 |
  |                                 expected because of this

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` (bin "branches") due to 1 previous error
</code></pre>
<p>–í—ã—Ä–∞–∂–µ–Ω–∏–µ –≤ –±–ª–æ–∫–µ <code>if</code> –≤—ã—á–∏—Å–ª—è–µ—Ç—Å—è –≤ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ, –∞ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ –±–ª–æ–∫–µ <code>else</code> ‚Äî –≤ —Å—Ç—Ä–æ–∫—É. –¢–∞–∫–æ–µ –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º–æ, –ø–æ—Å–∫–æ–ª—å–∫—É —Ç–∏–ø—ã –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –ø–æ—Å—Ç–æ—è–Ω–Ω—ã –∏ –∏–∑–≤–µ—Å—Ç–Ω—ã —É–∂–µ –Ω–∞ —ç—Ç–∞–ø–µ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏. –ö–æ–º–ø–∏–ª—è—Ç–æ—Ä –¥–æ–ª–∂–µ–Ω –∑–Ω–∞—Ç—å —Ç–∏–ø <code>number</code>, —á—Ç–æ–±—ã –∏–º–µ—Ç—å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –ø—Ä–æ–≤–µ—Ä–∏—Ç—å, –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –ª–∏ –º—ã –ø—Ä–∏–º–µ–Ω—è–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é <code>number</code> –¥–∞–ª—å—à–µ –≤ –ø—Ä–æ–≥—Ä–∞–º–º–µ. –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –Ω–µ–æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ—Å—Ç–∏ —Ç–∏–ø–æ–≤ —Å–¥–µ–ª–∞–ª–∞ –±—ã –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä Rust –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω—ã–º, –ª–∏—à–∏–ª–∞ –±—ã –Ω–∞—Å –º–Ω–æ–≥–∏—Ö –≥–∞—Ä–∞–Ω—Ç–∏–π —Ñ–æ—Ä–º–∞–ª—å–Ω–æ–π –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç–∏ –∫–æ–¥–∞, –∏ –ø–æ–∑–≤–æ–ª–∏–ª–∞ –±—ã –ø–∏—Å–∞—Ç—å –∫—Ä–∞–π–Ω–µ –∑–∞–ø—É—Ç–∞–Ω–Ω—ã–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã ‚Äî –¥–∞–∂–µ –∫–æ–≥–¥–∞ –º—ã —Ç–æ–≥–æ –Ω–µ —Ö–æ—Ç–∏–º.</p>
<h3 id="–ü–æ–≤—Ç–æ—Ä–Ω–æ–µ-–∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ-–∫–æ–¥–∞-—Å-–ø–æ–º–æ—â—å—é-—Ü–∏–∫–ª–æ–≤"><a class="header" href="#–ü–æ–≤—Ç–æ—Ä–Ω–æ–µ-–∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ-–∫–æ–¥–∞-—Å-–ø–æ–º–æ—â—å—é-—Ü–∏–∫–ª–æ–≤">–ü–æ–≤—Ç–æ—Ä–Ω–æ–µ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ –∫–æ–¥–∞ —Å –ø–æ–º–æ—â—å—é —Ü–∏–∫–ª–æ–≤</a></h3>
<p>–ß–∞—Å—Ç–æ –Ω—É–∂–Ω–æ –∏—Å–ø–æ–ª–Ω–∏—Ç—å –Ω–µ–∫–æ—Ç–æ—Ä—ã–π –æ–±—ä—ë–º –∫–æ–¥–∞ –±–æ–ª—å—à–µ, —á–µ–º –µ–¥–∏–Ω–æ–∂–¥—ã. –î–ª—è —ç—Ç–æ–≥–æ –≤ Rust —Å—É—â–µ—Å—Ç–≤—É—é—Ç –Ω–µ—Å–∫–æ–ª—å–∫–æ –≤–∏–¥–æ–≤ <em>—Ü–∏–∫–ª–æ–≤</em>, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–∑–≤–æ–ª—è—é—Ç –∏—Å–ø–æ–ª–Ω–∏—Ç—å –±–ª–æ–∫ –∫–æ–¥–∞ –∏ –∑–∞—Ç–µ–º –≤–µ—Ä–Ω—É—Ç—å—Å—è –∫ –µ–≥–æ –Ω–∞—á–∞–ª—É. –ß—Ç–æ–±—ã –æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —Ü–∏–∫–ª—ã, —Å–æ–∑–¥–∞–π—Ç–µ –Ω–æ–≤—ã–π –ø—Ä–æ–µ–∫—Ç –∏ –Ω–∞–∑–æ–≤–∏—Ç–µ –µ–≥–æ <em>loops</em>.</p>
<p>–í Rust –µ—Å—Ç—å —Ç—Ä–∏ –≤–∏–¥–∞ —Ü–∏–∫–ª–æ–≤: <code>loop</code>, <code>while</code> –∏ <code>for</code>. –ü–æ–ø—Ä–æ–±—É–µ–º –∫–∞–∂–¥—ã–π –∏–∑ –Ω–∏—Ö.</p>
<h4 id="–ü–æ–≤—Ç–æ—Ä–µ–Ω–∏–µ-–∫–æ–¥–∞-—Å-–ø–æ–º–æ—â—å—é-loop"><a class="header" href="#–ü–æ–≤—Ç–æ—Ä–µ–Ω–∏–µ-–∫–æ–¥–∞-—Å-–ø–æ–º–æ—â—å—é-loop">–ü–æ–≤—Ç–æ—Ä–µ–Ω–∏–µ –∫–æ–¥–∞ —Å –ø–æ–º–æ—â—å—é <code>loop</code></a></h4>
<p>–ö–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ <code>loop</code> –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ —Å–ª–µ–¥—É—é—â–∏–π –∑–∞ –Ω–∏–º –±–ª–æ–∫ –∫–æ–¥–∞ –Ω–∞–¥–æ –∏—Å–ø–æ–ª–Ω—è—Ç—å –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ, —Ä–∞–∑ –∑–∞ —Ä–∞–∑–æ–º ‚Äî –¥–æ —Ç–µ—Ö –ø–æ—Ä, –ø–æ–∫–∞ –≤—ã —è–≤–Ω–æ –Ω–µ –ø—Ä–∏–∫–∞–∂–µ—Ç–µ —Ü–∏–∫–ª—É –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å—Å—è.</p>
<p>–ó–∞–º–µ–Ω–∏—Ç–µ –∫–æ–¥ –≤ —Ñ–∞–π–ª–µ <em>src/main.rs</em> –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ <em>loops</em> –Ω–∞ –∫–æ–¥ –∏–∑ –ø—Ä–∏–º–µ—Ä–∞ –Ω–∏–∂–µ:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!("–∏ –µ—â—ë —Ä–∞–∑,");
    }
}</code></pre>
<p>–ó–∞–ø—É—Å—Ç–∏–≤ —ç—Ç—É –ø—Ä–æ–≥—Ä–∞–º–º—É, –º—ã —É–≤–∏–¥–∏–º —Å—Ç—Ä–æ–∫—É <code>–∏ –µ—â—ë —Ä–∞–∑,</code>, –æ–¥–Ω—É –∑–∞ –¥—Ä—É–≥–æ–π, –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ. –ú—ã –º–æ–∂–µ–º –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —ç—Ç–æ, –≤—Ä—É—á–Ω—É—é –ø—Ä–µ—Ä–≤–∞–≤ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã. –ë–æ–ª—å—à–∏–Ω—Å—Ç–≤–æ –∫–æ–Ω—Å–æ–ª–µ–π –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç —Å–æ—á–µ—Ç–∞–Ω–∏–µ –∫–ª–∞–≤–∏—à <kbd>Ctrl</kbd>-<kbd>C</kbd>, –∫–æ—Ç–æ—Ä–æ–µ –ø—Ä–µ—Ä—ã–≤–∞–µ—Ç —Ä–∞–±–æ—Ç—É –ø—Ä–æ–≥—Ä–∞–º–º—ã. –ü–æ–ø—Ä–æ–±—É–µ–º –∑–∞–ø—É—Å—Ç–∏—Ç—å –Ω–∞—à –ø—Ä–∏–º–µ—Ä –∏ –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –µ–≥–æ:</p>
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-32-loop
cargo run
CTRL-C
-->
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.08s
     Running `target/debug/loops`
–∏ –µ—â—ë —Ä–∞–∑,
–∏ –µ—â—ë —Ä–∞–∑,
–∏ –µ—â—ë —Ä–∞–∑,
–∏ –µ—â—ë —Ä–∞–∑,
^C–∏ –µ—â—ë —Ä–∞–∑,
</code></pre>
<p>–°–∏–º–≤–æ–ª <code>^C</code> –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –≤—ã –Ω–∞–∂–∞–ª–∏ <kbd>Ctrl</kbd>-<kbd>C</kbd>. –í–æ–∑–º–æ–∂–Ω–æ, –≤—ã –Ω–µ —É–≤–∏–¥–∏—Ç–µ —Å—Ç—Ä–æ—á–∫—É <code>–∏ –µ—â—ë —Ä–∞–∑,</code> –ø–æ—Å–ª–µ <code>^C</code> ‚Äî –≤—Å—ë –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Ç–æ–≥–æ, –≤ –∫–∞–∫–æ–π –º–æ–º–µ–Ω—Ç –ø—Ä–æ–≥—Ä–∞–º–º–∞ –≤–æ—Å–ø—Ä–∏–º–µ—Ç —Å–∏–≥–Ω–∞–ª –æ—Å—Ç–∞–Ω–æ–≤–∫–∏.</p>
<p>–ï—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ, –≤ Rust –µ—Å—Ç—å —Å–ø–æ—Å–æ–± –ø—Ä–æ–≥—Ä–∞–º–º–Ω–æ –≤—ã–π—Ç–∏ –∏–∑ —Ü–∏–∫–ª–∞. –ï—Å–ª–∏ –≤—ã –Ω–∞–ø–∏—à–µ—Ç–µ –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ <code>break</code> –≤–Ω—É—Ç—Ä–∏ —Ü–∏–∫–ª–∞, —Ç–æ –∫–æ–≥–¥–∞ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ –¥–æ –Ω–µ–≥–æ –¥–æ–π–¥—ë—Ç, —Ü–∏–∫–ª –∑–∞–≤–µ—Ä—à–∏—Ç—Å—è. –ö —Å–ª–æ–≤—É, –º—ã —É–∂–µ –µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏: –≤—Å–ø–æ–º–Ω–∏—Ç–µ, –∫–∞–∫ –º—ã —Ä–µ–∞–ª–∏–∑–æ–≤–∞–ª–∏ <a href="ch02-00-guessing-game-tutorial.html#%D0%97%D0%B0%D0%B2%D0%B5%D1%80%D1%88%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B8%D0%B3%D1%80%D1%8B-%D0%BF%D0%BE%D1%81%D0%BB%D0%B5-%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D1%8C%D0%BD%D0%BE%D0%B9-%D0%B4%D0%BE%D0%B3%D0%B0%D0%B4%D0%BA%D0%B8">"–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –∏–≥—Ä—ã –ø–æ—Å–ª–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –¥–æ–≥–∞–¥–∫–∏"</a><!-- ignore --> –≤ –Ω–∞—à–µ–π –∏–≥—Ä–µ –≤ —É–≥–∞–¥–∞–π–∫—É –∏–∑ –ì–ª–∞–≤—ã 2.</p>
<p>–ú—ã —Ç–∞–∫–∂–µ —Ç–æ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ <code>continue</code> ‚Äî –æ–Ω–æ —É–∫–∞–∑—ã–≤–∞–µ—Ç —Ü–∏–∫–ª—É –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ –æ—Å—Ç–∞–≤—à–µ–≥–æ—Å—è –∫–æ–¥–∞ –∏ —Å—Ä–∞–∑—É –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å —Å –Ω–æ–≤–æ–π –∏—Ç–µ—Ä–∞—Ü–∏–∏ —Ü–∏–∫–ª–∞.</p>
<h4 id="–í—ã—á–∏—Å–ª–µ–Ω–∏–µ-—Ü–∏–∫–ª–æ–≤-–≤-–∑–Ω–∞—á–µ–Ω–∏—è"><a class="header" href="#–í—ã—á–∏—Å–ª–µ–Ω–∏–µ-—Ü–∏–∫–ª–æ–≤-–≤-–∑–Ω–∞—á–µ–Ω–∏—è">–í—ã—á–∏—Å–ª–µ–Ω–∏–µ —Ü–∏–∫–ª–æ–≤ –≤ –∑–Ω–∞—á–µ–Ω–∏—è</a></h4>
<p>–û–¥–Ω–∏–º –∏–∑ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–π —Ü–∏–∫–ª–∞ <code>loop</code> —è–≤–ª—è–µ—Ç—Å—è –ø–æ–≤—Ç–æ—Ä–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞ –∏—Å–ø–æ–ª–Ω–∏—Ç—å –æ–ø–µ—Ä–∞—Ü–∏—é, –∫–æ—Ç–æ—Ä–∞—è –º–æ–∂–µ—Ç –Ω–µ —É–¥–∞—Å—Ç—å—Å—è ‚Äî –¥–æ —Ç–µ—Ö –ø–æ—Ä, –ø–æ–∫–∞ –Ω–µ –±—É–¥–µ—Ç –¥–æ—Å—Ç–∏–≥–Ω—É—Ç —É—Å–ø–µ—Ö. (–ù–∞–ø—Ä–∏–º–µ—Ä, –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–µ —Ç–æ, –∑–∞–∫–æ–Ω—á–∏–ª –ª–∏ –∏—Å–ø–æ–ª–Ω—è—Ç—å—Å—è –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–π –ø–æ—Ç–æ–∫.) –í–∞–º —Ç–∞–∫–∂–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω—É–∂–Ω–æ –≤–µ—Ä–Ω—É—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç —ç—Ç–æ–π –æ–ø–µ—Ä–∞—Ü–∏–∏ –∏–∑ —Ü–∏–∫–ª–∞, —á—Ç–æ–±—ã –¥–∞–ª—å—à–µ –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –µ–≥–æ. –≠—Ç–æ –º–æ–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å, –¥–æ–±–∞–≤–∏–≤ –ø–æ—Å–ª–µ –≤—ã—Ä–∞–∂–µ–Ω–∏—è <code>break</code> —Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –≤—ã —Ö–æ—Ç–∏—Ç–µ –≤–µ—Ä–Ω—É—Ç—å –∏–∑ —Ü–∏–∫–ª–∞. –ü–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –ø—Ä–∏–º–µ—Ä:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("result —Ä–∞–≤–Ω–∞ {result}");
}</code></pre></pre>
<p>–ú—ã –æ–±—ä—è–≤–∏–ª–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é <code>counter</code> –ø–µ—Ä–µ–¥ —Ü–∏–∫–ª–æ–º –∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–ª–∏ –µ—ë –∑–Ω–∞—á–µ–Ω–∏–µ–º <code>0</code>. –ó–∞—Ç–µ–º, –º—ã –æ–±—ä—è–≤–∏–ª–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é <code>result</code>, –≤ –∫–æ—Ç–æ—Ä–æ–π –±—É–¥–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å—Å—è –∑–Ω–∞—á–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –≤–µ—Ä–Ω—ë—Ç —Ü–∏–∫–ª. –ù–∞ –∫–∞–∂–¥–æ–π –∏—Ç–µ—Ä–∞—Ü–∏–∏ —Ü–∏–∫–ª–∞ –º—ã –ø—Ä–∏–±–∞–≤–ª—è–µ–º <code>1</code> –∫ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π <code>counter</code>, –∞ –ø–æ—Ç–æ–º –ø—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Ä–∞–≤–Ω–∞ –ª–∏ <code>counter</code> –∑–Ω–∞—á–µ–Ω–∏—é <code>10</code>. –ö–æ–≥–¥–∞ —ç—Ç–æ —É—Å–ª–æ–≤–∏–µ –æ–∫–∞–∂–µ—Ç—Å—è –≤–µ—Ä–Ω—ã–º, –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ <code>break</code> –ø—Ä–µ—Ä–≤—ë—Ç –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ —Ü–∏–∫–ª–∞ –∏ –≤–µ—Ä–Ω—ë—Ç –∏–∑ –Ω–µ–≥–æ –∑–Ω–∞—á–µ–Ω–∏–µ <code>counter * 2</code>. –ú—ã —Ç–∞–∫–∂–µ –ø–æ—Å—Ç–∞–≤–∏–ª–∏ —Ç–æ—á–∫—É —Å –∑–∞–ø—è—Ç–æ–π –≤ —Å–∞–º–æ–º –∫–æ–Ω—Ü–µ, —á—Ç–æ–±—ã –∑–∞–∫–æ–Ω—á–∏—Ç—å –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é, —Å–≤—è–∑—ã–≤–∞—é—â—É—é <code>result</code> —Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º, –≤ –∫–æ—Ç–æ—Ä–æ–µ –≤—ã—á–∏—Å–ª—è–µ—Ç—Å—è —Ü–∏–∫–ª. –ù–∞–∫–æ–Ω–µ—Ü, –º—ã –ø–µ—á–∞—Ç–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ <code>result</code> ‚Äî –≤ –Ω–∞—à–µ–º —Å–ª—É—á–∞–µ –æ–Ω–æ –æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è —Ä–∞–≤–Ω—ã–º <code>20</code>.</p>
<p>–í—ã —Ç–∞–∫–∂–µ –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤ —Ü–∏–∫–ª–µ –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ <code>return</code>. –í –æ—Ç–ª–∏—á–∏–µ –æ—Ç <code>break</code> (–∫–æ—Ç–æ—Ä–æ–µ –∑–∞–≤–µ—Ä—à–∏—Ç –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ —Ç–æ–ª—å–∫–æ —Å–≤–æ–µ–≥–æ <em>—Ü–∏–∫–ª–∞</em>), <code>return</code> –∑–∞–≤–µ—Ä—à–∏—Ç –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ —Å—Ä–∞–∑—É –≤—Å–µ–π <em>—Ñ—É–Ω–∫—Ü–∏–∏</em>.</p>
<h4 id="–£–∫–∞–∑–∞–Ω–∏–µ-–Ω–∞-–∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π-—Ü–∏–∫–ª-—Å-–ø–æ–º–æ—â—å—é-–º–µ—Ç–æ–∫-—Ü–∏–∫–ª–æ–≤"><a class="header" href="#–£–∫–∞–∑–∞–Ω–∏–µ-–Ω–∞-–∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π-—Ü–∏–∫–ª-—Å-–ø–æ–º–æ—â—å—é-–º–µ—Ç–æ–∫-—Ü–∏–∫–ª–æ–≤">–£–∫–∞–∑–∞–Ω–∏–µ –Ω–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —Ü–∏–∫–ª —Å –ø–æ–º–æ—â—å—é –º–µ—Ç–æ–∫ —Ü–∏–∫–ª–æ–≤</a></h4>
<p>–ï—Å–ª–∏ –≤—ã —Ä–∞–±–æ—Ç–∞–µ—Ç–µ –≤–æ –≤–ª–æ–∂–µ–Ω–Ω—ã—Ö —Ü–∏–∫–ª–∞—Ö, <code>break</code> –∏ <code>continue</code> –±—É–¥—É—Ç –æ—Ç–Ω–æ—Å–∏—Ç—å—Å—è —Ç–æ–ª—å–∫–æ –∫ —Ç–æ–º—É —Ü–∏–∫–ª—É, –≤ –∫–æ—Ç–æ—Ä—ã—Ö –æ–Ω–∏ –Ω–∞–ø–∏—Å–∞–Ω—ã. –ü—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –≤—ã –º–æ–∂–µ—Ç–µ —É—Ç–æ—á–Ω–∏—Ç—å, —Å –∫–∞–∫–∏–º –∏–∑ –≤–ª–æ–∂–µ–Ω–Ω—ã—Ö —Ü–∏–∫–ª–æ–≤ –æ–Ω–∏ –¥–æ–ª–∂–Ω—ã —Ä–∞–±–æ—Ç–∞—Ç—å, –Ω–∞–ø–∏—Å–∞–≤ <em>–º–µ—Ç–∫—É —Ü–∏–∫–ª–∞</em> –ø–æ—Å–ª–µ <code>break</code> –∏–ª–∏ <code>continue</code>. –ú–µ—Ç–∫–∏ —Ü–∏–∫–ª–æ–≤ –∑–∞–ø–∏—Å—ã–≤–∞—é—Ç—Å—è –ø–µ—Ä–µ–¥ –Ω–∞—á–∞–ª–æ–º —Ü–∏–∫–ª–∞ –∏ –Ω–∞—á–∏–Ω–∞—é—Ç—Å—è —Å –∞–ø–æ—Å—Ç—Ä–æ—Ñ–∞. –í–æ—Ç –ø—Ä–∏–º–µ—Ä —Å –æ–¥–Ω–∏–º –≤–ª–æ–∂–µ–Ω–Ω—ã–º —Ü–∏–∫–ª–æ–º:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {count}");
        let mut remaining = 10;

        loop {
            println!("remaining = {remaining}");
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("–û–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ count = {count}");
}</code></pre></pre>
<p>–í–Ω–µ—à–Ω–∏–π —Ü–∏–∫–ª –æ–±–æ–∑–Ω–∞—á–µ–Ω –º–µ—Ç–∫–æ–π <code>'counting_up</code>; –æ–Ω –±—É–¥–µ—Ç –∑–∞–ø—É—â–µ–Ω –æ—Ç 0 –¥–æ 2. –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π —Ü–∏–∫–ª –Ω–∏–∫–∞–∫ –Ω–µ –ø–æ–º–µ—á–µ–Ω; –æ–Ω –±—É–¥–µ—Ç –æ—Ç—Å—á–∏—Ç—ã–≤–∞—Ç—å –æ—Ç 10 –¥–æ 9. –ü–µ—Ä–≤—ã–π <code>break</code> –Ω–µ –∏–º–µ–µ—Ç –º–µ—Ç–∫–∏, —Ç–∞–∫ —á—Ç–æ –æ–Ω –ø—Ä–µ—Ä—ã–≤–∞–µ—Ç –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ <em>—Å–≤–æ–µ–≥–æ</em> —Ü–∏–∫–ª–∞ ‚Äî –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–≥–æ. –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è <code>break 'counting_up;</code> –∑–∞–≤–µ—Ä—à–∏—Ç –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ –≤–Ω–µ—à–Ω–µ–≥–æ —Ü–∏–∫–ª–∞. –≠—Ç–æ—Ç –∫–æ–¥ –Ω–∞–ø–µ—á–∞—Ç–∞–µ—Ç:</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running `target/debug/loops`
count = 0
remaining = 10
remaining = 9
count = 1
remaining = 10
remaining = 9
count = 2
remaining = 10
–û–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ count = 2
</code></pre>
<h4 id="–£—Å–ª–æ–≤–Ω—ã–µ-—Ü–∏–∫–ª—ã-—Å-while"><a class="header" href="#–£—Å–ª–æ–≤–Ω—ã–µ-—Ü–∏–∫–ª—ã-—Å-while">–£—Å–ª–æ–≤–Ω—ã–µ —Ü–∏–∫–ª—ã —Å <code>while</code></a></h4>
<p>–ß–∞—Å—Ç–æ –±—ã–≤–∞–µ—Ç –Ω—É–∂–Ω–æ –∏—Å–ø–æ–ª–Ω—è—Ç—å –Ω–µ–∫–æ—Ç–æ—Ä—ã–π –∫–æ–¥, –ø–æ–∫–∞ –∏—Å—Ç–∏–Ω–Ω–æ –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ —É—Å–ª–æ–≤–∏–µ; –∫–æ–≥–¥–∞ –∂–µ —É—Å–ª–æ–≤–∏–µ –ø–µ—Ä–µ—Å—Ç–∞—ë—Ç –±—ã—Ç—å –∏—Å—Ç–∏–Ω–Ω—ã–º, –ø—Ä–æ–≥—Ä–∞–º–º–∞ –ø—Ä–µ—Ä—ã–≤–∞–µ—Ç –ø–æ–≤—Ç–æ—Ä —Ü–∏–∫–ª–∞. –û–ø–∏—Å–∞–Ω–Ω—ã–π –º–µ—Ö–∞–Ω–∏–∑–º –≤–ø–æ–ª–Ω–µ –º–æ–∂–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Å –ø–æ–º–æ—â—å—é <code>loop</code>, <code>if</code>, <code>else</code> –∏ <code>break</code>; –º–æ–∂–µ—Ç–µ –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —ç—Ç–æ –≤ –∫–∞—á–µ—Å—Ç–≤–µ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏. –û–¥–Ω–∞–∫–æ, –≤ –º–Ω–æ–≥–∏—Ö —è–∑—ã–∫–∞—Ö –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è –ø–æ–¥–æ–±–Ω–æ–≥–æ —Ä–æ–¥–∞ —Ü–∏–∫–ª —É–∂–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω, –∏ Rust ‚Äî –Ω–µ –∏—Å–∫–ª—é—á–µ–Ω–∏–µ. –í –Ω—ë–º —Ç–∞–∫–æ–π —Ü–∏–∫–ª –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è <code>while</code>. –ü—Ä–æ–≥—Ä–∞–º–º–∞ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 3-3 –∏—Å–ø–æ–ª—å–∑—É–µ—Ç <code>while</code> –¥–ª—è –æ—Ç—Å—á—ë—Ç–∞ —Ç—Ä—ë—Ö –∏, –≤ –∫–æ–Ω—Ü–µ, –ø–µ—á–∞—Ç–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ, –ø–æ—Å–ª–µ —á–µ–≥–æ –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è.</p>
<Listing number="3-3" file-name="src/main.rs" caption="Using a `while` loop to run code while a condition holds true">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{number}!");

        number -= 1;
    }

    println!("–ü–û–ï–•–ê–õ–ò!!!");
}</code></pre></pre>
</Listing>
<p>–≠—Ç–∞ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏—è —Å–µ—Ä—å—ë–∑–Ω–æ –æ–±–ª–µ–≥—á–∞–µ—Ç —Å–æ–∑–¥–∞–Ω–∏–µ —Ü–∏–∫–ª–æ–≤ —Å —É—Å–ª–æ–≤–∏–µ–º –æ—Å—Ç–∞–Ω–æ–≤–∫–∏: –∫–æ–¥ –ø–æ–ª—É—á–∞–µ—Ç—Å—è –ø—Ä–æ—â–µ –∏ —á–∏—â–µ. –ü–æ–∫–∞ —É—Å–ª–æ–≤–∏–µ –≤—ã—á–∏—Å–ª—è–µ—Ç—Å—è –≤ <code>true</code>, –∫–æ–¥ –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è; –∏–Ω–∞—á–µ, —Ü–∏–∫–ª –ø—Ä–µ—Ä—ã–≤–∞–µ—Ç—Å—è.</p>
<h4 id="–ü–µ—Ä–µ–±–æ—Ä-—ç–ª–µ–º–µ–Ω—Ç–æ–≤-–∫–æ–ª–ª–µ–∫—Ü–∏–∏-—Å-for"><a class="header" href="#–ü–µ—Ä–µ–±–æ—Ä-—ç–ª–µ–º–µ–Ω—Ç–æ–≤-–∫–æ–ª–ª–µ–∫—Ü–∏–∏-—Å-for">–ü–µ—Ä–µ–±–æ—Ä —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∫–æ–ª–ª–µ–∫—Ü–∏–∏ —Å <code>for</code></a></h4>
<p>–í—ã —Ç–∞–∫–∂–µ –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏—é <code>while</code>, —á—Ç–æ–±—ã –ø—Ä–æ–π—Ç–∏—Å—å –ø–æ —ç–ª–µ–º–µ–Ω—Ç–∞–º –∫–æ–ª–ª–µ–∫—Ü–∏–π (–Ω–∞–ø—Ä–∏–º–µ—Ä, –º–∞—Å—Å–∏–≤–∞). –ù–∞–ø—Ä–∏–º–µ—Ä, —Ü–∏–∫–ª –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 3-4 –Ω–∞–ø–µ—á–∞—Ç–∞–µ—Ç –∫–∞–∂–¥—ã–π —ç–ª–µ–º–µ–Ω—Ç –º–∞—Å—Å–∏–≤–∞ <code>a</code>.</p>
<Listing number="3-4" file-name="src/main.rs" caption="Looping through each element of a collection using a `while` loop">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!("—ç–ª–µ–º–µ–Ω—Ç: {}", a[index]);

        index += 1;
    }
}</code></pre></pre>
</Listing>
<p>–≠—Ç–æ –∫–æ–¥ –ø–æ–æ—á–µ—Ä—ë–¥–Ω–æ –ø—Ä–æ—Ö–æ–¥–∏—Ç—Å—è –ø–æ –∫–∞–∂–¥–æ–º—É —ç–ª–µ–º–µ–Ω—Ç—É –º–∞—Å—Å–∏–≤–∞. –û–Ω –Ω–∞—á–∏–Ω–∞–µ—Ç —Å —ç–ª–µ–º–µ–Ω—Ç–∞ –ø–æ –∏–Ω–¥–µ–∫—Å—É <code>0</code>, –∏ –∑–∞—Ç–µ–º –ø–µ—Ä–µ–±–∏—Ä–∞–µ—Ç –∏–Ω–¥–µ–∫—Å—ã –¥–æ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ (—Ç–æ –µ—Å—Ç—å, –¥–æ —Ç–µ—Ö –ø–æ—Ä, –ø–æ–∫–∞ <code>index &lt; 5</code> –Ω–µ –æ–∫–∞–∂–µ—Ç—Å—è <code>false</code>). –ó–∞–ø—É—Å—Ç–∏–≤ —ç—Ç–æ—Ç –∫–æ–¥, –≤—ã —É–≤–∏–¥–∏—Ç–µ —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞:</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.32s
     Running `target/debug/loops`
—ç–ª–µ–º–µ–Ω—Ç: 10
—ç–ª–µ–º–µ–Ω—Ç: 20
—ç–ª–µ–º–µ–Ω—Ç: 30
—ç–ª–µ–º–µ–Ω—Ç: 40
—ç–ª–µ–º–µ–Ω—Ç: 50
</code></pre>
<p>–í—Å–µ –ø—è—Ç—å —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞ –ø–æ—è–≤–∏–ª–∏—Å—å –Ω–∞ —ç–∫—Ä–∞–Ω–µ, –∫–∞–∫ –∏ –æ–∂–∏–¥–∞–ª–æ—Å—å. –•–æ—Ç—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è <code>index</code> –∏ –¥–æ—Å—Ç–∏–≥–∞–µ—Ç –≤ –∫–∞–∫–æ–π-—Ç–æ –º–æ–º–µ–Ω—Ç –∑–Ω–∞—á–µ–Ω–∏—è <code>5</code>, —Ü–∏–∫–ª –ø—Ä–æ–≤–µ—Ä–∏—Ç —É—Å–ª–æ–≤–∏–µ –Ω–∞ –∏—Å—Ç–∏–Ω–Ω–æ—Å—Ç—å –∏ –ø–æ—Ç–æ–º—É –∑–∞–≤–µ—Ä—à–∏—Ç—Å—è —Ä–∞–Ω—å—à–µ, —á–µ–º –ø—Ä–æ–∏–∑–æ–π–¥—ë—Ç –ø–æ–ø—ã—Ç–∫–∞ –ø–æ–ª—É—á–∏—Ç—å —à–µ—Å—Ç–æ–π —ç–ª–µ–º–µ–Ω—Ç –º–∞—Å—Å–∏–≤–∞.</p>
<p>–û–¥–Ω–∞–∫–æ —Ç–∞–∫–æ–π –ø–æ–¥—Ö–æ–¥ –ª–µ–≥–∫–æ –º–æ–∂–µ—Ç –ø—Ä–∏–≤–µ—Å—Ç–∏ –∫ –æ—à–∏–±–∫–µ: –º–æ–∂–Ω–æ –ª–µ–≥–∫–æ –ø–æ–ª—É—á–∏—Ç—å –ø–∞–Ω–∏–∫—É –∏–∑-–∑–∞ –ø–æ–ø—ã—Ç–∫–∏ –ø–æ–ª—É—á–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ –º–∞—Å—Å–∏–≤–∞. –ù–∞–ø—Ä–∏–º–µ—Ä, –µ—Å–ª–∏ –≤—ã –æ—Å—Ç–∞–≤–∏—Ç–µ –≤ –º–∞—Å—Å–∏–≤–µ <code>a</code> –ª–∏—à—å —á–µ—Ç—ã—Ä–µ —ç–ª–µ–º–µ–Ω—Ç–∞, –∞ –æ–±–Ω–æ–≤–∏—Ç—å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —É—Å–ª–æ–≤–Ω–æ–≥–æ —Ü–∏–∫–ª–∞ –¥–æ <code>while index &lt; 4</code>, –ø—Ä–æ–≥—Ä–∞–º–º–∞ –≤—ã–∑–æ–≤–µ—Ç –ø–∞–Ω–∏–∫—É. –ê –µ—â—ë —ç—Ç–æ –æ—á–µ–Ω—å –º–µ–¥–ª–µ–Ω–Ω–æ: –æ–±—Ä–∞—â–µ–Ω–∏–µ –∫ —ç–ª–µ–º–µ–Ω—Ç–∞–º –º–∞—Å—Å–∏–≤–∞ —Å –ø–æ–º–æ—â—å—é –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –≤—ã–Ω—É–∂–¥–∞–µ—Ç –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –¥–æ–±–∞–≤–∏—Ç—å —Ç–æ—Ä–º–æ–∑—è—â–∏–µ –∫–æ–¥ –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–∞ –≤—ã—Ö–æ–¥ –∑–∞ –ø—Ä–µ–¥–µ–ª—ã –º–∞—Å—Å–∏–≤–∞ ‚Äî –∏ —Ç–∞–∫–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω—É–∂–Ω–æ –±—É–¥–µ—Ç –ø—Ä–æ–≤–æ–¥–∏—Ç—å –Ω–∞ –∫–∞–∂–¥–æ–π –∏—Ç–µ—Ä–∞—Ü–∏–∏; –≤—Å—ë —ç—Ç–æ —Å–æ–≤–µ—Ä—à–µ–Ω–Ω–æ —Ç–æ—á–Ω–æ —è–≤–ª—è–µ—Ç—Å—è –∏–∑–ª–∏—à–µ—Å—Ç–≤–æ–º.</p>
<p>–ë–æ–ª–µ–µ –ª–∞–∫–æ–Ω—á–∏–Ω—ã–º —Å–ø–æ—Å–æ–±–æ–º –ø–µ—Ä–µ–±—Ä–∞—Ç—å —ç–ª–µ–º–µ–Ω—Ç—ã –∫–æ–ª–ª–µ–∫—Ü–∏–∏ —è–≤–ª—è–µ—Ç—Å—è —Ü–∏–∫–ª <code>for</code>. –ü—Ä–∏–º–µ—Ä —Ü–∏–∫–ª–∞ <code>for</code> –ø—Ä–∏–≤–µ–¥—ë–Ω –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 3-5.</p>
<Listing number="3-5" file-name="src/main.rs" caption="Looping through each element of a collection using a `for` loop">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("—ç–ª–µ–º–µ–Ω—Ç: {element}");
    }
}</code></pre></pre>
</Listing>
<p>–ó–∞–ø—É—Å—Ç–∏–≤ —ç—Ç–æ—Ç –∫–æ–¥, –º—ã —É–≤–∏–¥–∏–º —Ç–æ—Ç –∂–µ –≤—ã–≤–æ–¥, —á—Ç–æ –∏ –≤ —Å–ª—É—á–∞–µ –õ–∏—Å—Ç–∏–Ω–≥–∞ 3-4. –ù–æ –∫—É–¥–∞ –±–æ–ª–µ–µ –≤–∞–∂–Ω–æ —Ç–æ, —á—Ç–æ –º—ã –ø–æ–≤—ã—Å–∏–ª–∏ –Ω–∞–¥—ë–∂–Ω–æ—Å—Ç—å –Ω–∞—à–µ–≥–æ –∫–æ–¥–∞, –∏–∑–±–∞–≤–∏–≤ –µ–≥–æ –æ—Ç –≤–æ–∑–º–æ–∂–Ω—ã—Ö –æ—à–∏–±–æ–∫, —Å–≤—è–∑–∞–Ω–Ω—ã—Ö –∫–∞–∫ —Å –ø–æ–ø—ã—Ç–∫–∞–º–∏ –ø–æ–ª—É—á–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ –º–∞—Å—Å–∏–≤–∞, —Ç–∞–∫ –∏ —Å –ø—Ä–µ–∂–¥–µ–≤—Ä–µ–º–µ–Ω–Ω–æ–π –æ—Å—Ç–∞–Ω–æ–≤–∫–æ–π –ø–µ—Ä–µ–±–æ—Ä–∞.</p>
<p>–° —Ü–∏–∫–ª–æ–º <code>for</code> –≤–∞—à –∫–æ–¥ —Å–∞–º–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω–æ –ø–æ–¥—Å—Ç—Ä–æ–∏—Ç—Å—è –ø–æ–¥ –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ –∫–æ–ª–ª–µ–∫—Ü–∏–∏, –∏ –≤–∞–º –Ω–µ –ø–æ–Ω–∞–¥–æ–±–∏—Ç—Å—è —Å–ª–µ–¥–∏—Ç—å –∑–∞ –¥–≤—É–º—è —É—á–∞—Å—Ç–∫–∞–º–∏ –∫–æ–¥–∞, –∫–∞–∫ —ç—Ç–æ –ø—Ä–∏—Ö–æ–¥–∏–ª–æ—Å—å –±—ã –¥–µ–ª–∞—Ç—å –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 3-4."</p>
<p>–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –∏ –ø—Ä–æ—Å—Ç–æ—Ç–∞ —Ü–∏–∫–ª–æ–≤ <code>for</code> –¥–µ–ª–∞—é—Ç –µ–≥–æ –Ω–∞–∏–±–æ–ª–µ–µ —á–∞—Å—Ç–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–º —Ü–∏–∫–ª–æ–º –≤ Rust. –î–∞–∂–µ –≤ —Å–ª—É—á–∞—è—Ö, –∫–æ–≥–¥–∞ –≤—ã —Ö–æ—Ç–∏—Ç–µ –∑–∞–ø—É—Å—Ç–∏—Ç—å –Ω–µ–∫–æ—Ç–æ—Ä—ã–π –∫–æ–¥ –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω–æ–µ —Ç–æ—á–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–∞–∑ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –∫–∞–∫ –≤ —Ü–∏–∫–ª–µ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 3-3), –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–æ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç–æ–≤ –Ω–∞ Rust –ø—Ä–∏–º–µ–Ω—è—Ç –¥–ª—è —ç—Ç–æ–≥–æ —Ü–∏–∫–ª <code>for</code>. –ï—Å–ª–∏ –æ–Ω–∫—Ä–µ—Ç–Ω–µ–µ, –æ–Ω–∏ –≤–æ—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è <code>Range</code> ‚Äî —Å—Ç—Ä—É–∫—Ç—É—Ä–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏, –∫–æ—Ç–æ—Ä–∞—è –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –≤—Å–µ—Ö —á–∏—Å–µ–ª –º–µ–∂–¥—É –¥–≤—É–º—è –≥—Ä–∞–Ω–∏—Ü–∞–º–∏ (–≤–∫–ª—é—á–∞—è –Ω–∏–∂–Ω—é—é –≥—Ä–∞–Ω–∏—Ü—É, –Ω–æ –Ω–µ –≤–∫–ª—é—á–∞—è –≤–µ—Ä—Ö–Ω—é—é).</p>
<p>–í–æ—Ç –∫–∞–∫ –±—É–¥–µ—Ç –≤—ã–≥–ª—è–¥–∏—Ç—å –æ–±—Ä–∞—Ç–Ω—ã–π –æ—Ç—Å—á—ë—Ç —Å –ø–æ–º–æ—â—å—é —Ü–∏–∫–ª–∞ <code>for</code> –∏ –º–µ—Ç–æ–¥–∞ <code>rev</code>, –ø–µ—Ä–µ–≤–æ—Ä–∞—á–∏–≤–∞—é—â–µ–≥–æ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º—É—é –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    for number in (1..4).rev() {
        println!("{number}!");
    }
    println!("–ü–û–ï–•–ê–õ–ò!!!");
}</code></pre></pre>
<p>–≠—Ç–æ—Ç –∫–æ–¥ —á—É—Ç—å –ø—Ä–∏—è—Ç–Ω–µ–µ; –Ω–µ —Ç–∞–∫ –ª–∏?</p>
<h2 id="–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-2"><a class="header" href="#–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-2">–ü–æ–¥–≤–µ–¥—ë–º –∏—Ç–æ–≥–∏</a></h2>
<p>–í—ã –ø—Ä–æ–¥–µ–ª–∞–ª–∏ –±–æ–ª—å—à—É—é —Ä–∞–±–æ—Ç—É! –≠—Ç–∞ –≥–ª–∞–≤–∞ –±—ã–ª–∞ –≤–Ω—É—à–∏—Ç–µ–ª—å–Ω–æ–π: –≤—ã —É–∑–Ω–∞–ª–∏ –æ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö, –Ω–µ–¥–µ–ª–∏–º—ã—Ö –∏ —Å–æ—Å—Ç–∞–≤–Ω—ã—Ö —Ç–∏–ø–∞—Ö, —Ñ—É–Ω–∫—Ü–∏—è—Ö, –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è—Ö, —É—Å–ª–æ–≤–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞—Ö –≤–µ—Ç–≤–ª–µ–Ω–∏—è –∏ –æ —Ü–∏–∫–ª–∞—Ö! –ß—Ç–æ–±—ã –æ—Ç—Ä–∞–±–æ—Ç–∞—Ç—å –∏–∑—É—á–µ–Ω–Ω–æ–µ, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –Ω–∞–ø–∏—Å–∞—Ç—å —Å–ª–µ–¥—É—é—â–∏–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã:</p>
<ul>
<li>–ö–æ–Ω–≤–µ—Ä—Ç–µ—Ä —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä –∏–∑ –≥—Ä–∞–¥—É—Å–æ–≤ –§–∞—Ä–µ–Ω–≥–µ–π—Ç–∞ –≤ –¶–µ–ª—å—Å–∏—è (–∏ –Ω–∞–æ–±–æ—Ä–æ—Ç).</li>
<li>–§—É–Ω–∫—Ü–∏—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ _n_–æ–≥–æ —á–∏—Å–ª–∞ –§–∏–±–æ–Ω–∞—á—á–∏.</li>
<li>–ü—Ä–æ–≥—Ä–∞–º–º–∞, –ø–µ—á–∞—Ç–∞—é—â–∞—è —Ç–µ–∫—Å—Ç —Ä–æ–∂–¥–µ—Å—Ç–≤–µ–Ω—Å–∫–æ–π –∞–Ω–≥–ª–∏–π—Å–∫–æ–π –Ω–∞—Ä–æ–¥–Ω–æ–π –ø–µ—Å–Ω–∏ <a href="https://en.wikipedia.org/wiki/The_Twelve_Days_of_Christmas_(song)#Lyrics">"The Twelve Days of Christmas"</a>.</li>
</ul>
<p>–í —Å–ª–µ–¥—É—é—â–µ–π –≥–ª–∞–≤–µ –º—ã –æ–±—Å—É–¥–∏–º –≤–ª–∞–¥–µ–Ω–∏–µ ‚Äî –∫–æ–Ω—Ü–µ–ø—Ü–∏—é Rust, –∫–æ—Ç–æ—Ä–æ–π –æ–±—ã—á–Ω–æ <em>–Ω–µ—Ç</em> –≤ –¥—Ä—É–≥–∏—Ö —è–∑—ã–∫–∞—Ö –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="–ü–æ–Ω–∏–º–∞–Ω–∏–µ-–≤–ª–∞–¥–µ–Ω–∏—è"><a class="header" href="#–ü–æ–Ω–∏–º–∞–Ω–∏–µ-–≤–ª–∞–¥–µ–Ω–∏—è">–ü–æ–Ω–∏–º–∞–Ω–∏–µ –≤–ª–∞–¥–µ–Ω–∏—è</a></h1>
<p>–í–ª–∞–¥–µ–Ω–∏–µ ‚Äî —ç—Ç–æ —Å–∞–º–∞—è —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω–∞—è –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç—å Rust. –û–Ω–∞ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏ –≤–ª–∏—è–µ—Ç –Ω–∞ –≤–µ—Å—å —è–∑—ã–∫. –ò–º–µ–Ω–Ω–æ –æ–Ω–æ –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –≥–∞—Ä–∞–Ω—Ç–∏–∏ Rust –ø–æ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –ø–∞–º—è—Ç–∏ –±–µ–∑ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –ø—Ä–∏–≤–ª–µ–∫–∞—Ç—å —Å–±–æ—Ä—â–∏–∫ –º—É—Å–æ—Ä–∞. –í —ç—Ç–æ–π –≥–ª–∞–≤–µ –º—ã —Ü–µ–ª–∏–∫–æ–º –æ–±—Å—É–¥–∏–º –≤–ª–∞–¥–µ–Ω–∏–µ –∏ –∫–æ—Å–Ω—ë–º—Å—è —Å–≤—è–∑–∞–Ω–Ω—ã—Ö —Å –Ω–∏–º —Ç–µ–º: –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–µ, —Å—Ä–µ–∑—ã –∏ —Ç–æ, –∫–∞–∫ –≤ Rust —É—Å—Ç—Ä–æ–µ–Ω–æ —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –≤ –ø–∞–º—è—Ç–∏.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–ß—Ç–æ-—Ç–∞–∫–æ–µ-–≤–ª–∞–¥–µ–Ω–∏–µ"><a class="header" href="#–ß—Ç–æ-—Ç–∞–∫–æ–µ-–≤–ª–∞–¥–µ–Ω–∏–µ">–ß—Ç–æ —Ç–∞–∫–æ–µ –≤–ª–∞–¥–µ–Ω–∏–µ?</a></h2>
<p><em>–í–ª–∞–¥–µ–Ω–∏–µ</em> ‚Äî —ç—Ç–æ –Ω–∞–±–æ—Ä –ø—Ä–∞–≤–∏–ª, —Ä–µ–≥—É–ª–∏—Ä—É—é—â–∏—Ö —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–∞–º—è—Ç—å—é –≤ Rust. –í—Å–µ–º –ø—Ä–æ–≥—Ä–∞–º–º–∞–º –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –∏–º–µ—Ç—å —Å–ø–æ—Å–æ–± –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–æ–≤–∞—Ç—å —Å –ø–∞–º—è—Ç—å—é, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ–º–æ–π –∫–æ–º–ø—å—é—Ç–µ—Ä–æ–º. –ù–µ–∫–æ—Ç–æ—Ä—ã–µ —è–∑—ã–∫–∏ –∏–º–µ—é—Ç —Å–±–æ—Ä—â–∏–∫ –º—É—Å–æ—Ä–∞ ‚Äî –æ–Ω –≤—Ä–µ–º—è –æ—Ç –≤—Ä–µ–º–µ–Ω–∏ —Å–æ–±–∏—Ä–∞–µ—Ç –Ω–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—É—é –ø–∞–º—è—Ç—å –∏ –≤—ã—Å–≤–æ–±–æ–∂–¥–∞–µ—Ç –µ—ë. –í –¥—Ä—É–≥–∏—Ö —è–∑—ã–∫–∞—Ö –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç –¥–æ–ª–∂–µ–Ω —è–≤–Ω–æ –∏ —Å–∞–º–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω–æ –≤—ã–¥–µ–ª—è—Ç—å –∏ –æ—Å–≤–æ–±–æ–∂–¥–∞—Ç—å –ø–∞–º—è—Ç—å. Rust –Ω–∞—à—ë–ª —Ç—Ä–µ—Ç–∏–π –ø—É—Ç—å: –ø–∞–º—è—Ç—å —É–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è –ø–æ –ø—Ä–∞–≤–∏–ª–∞–º —Å–∏—Å—Ç–µ–º—ã –≤–ª–∞–¥–µ–Ω–∏—è, –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ –∫–æ—Ç–æ—Ä—ã—Ö –ø—Ä–æ–≤–µ—Ä—è–µ—Ç—Å—è –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–æ–º. –ï—Å–ª–∏ –∫–∞–∫–∏–µ-–ª–∏–±–æ –ø—Ä–∞–≤–∏–ª–∞ –Ω–∞—Ä—É—à–µ–Ω—ã, –ø—Ä–æ–≥—Ä–∞–º–º–∞ –Ω–µ —Å–∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è. –ö—Å—Ç–∞—Ç–∏: –ø–æ—Å–∫–æ–ª—å–∫—É –ø—Ä–∞–≤–∏–ª–∞ –≤–ª–∞–¥–µ–Ω–∏—è –ø—Ä–æ–≤–µ—Ä—è—é—Ç—Å—è –∏–º–µ–Ω–Ω–æ –Ω–∞ —ç—Ç–∞–ø–µ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏, –æ–Ω–∏ –Ω–µ —Å–¥–µ–ª–∞—é—Ç –≤–∞—à –∫–æ–¥ –º–µ–¥–ª–µ–Ω–Ω–µ–µ.</p>
<p>–ü–æ—Å–∫–æ–ª—å–∫—É –∏–¥–µ—è –≤–ª–∞–¥–µ–Ω–∏—è –Ω–µ–∑–Ω–∞–∫–æ–º–∞ –±–æ–ª—å—à–∏–Ω—Å—Ç–≤—É –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç–æ–≤, –Ω—É–∂–Ω–æ –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –≤—Ä–µ–º—è, —á—Ç–æ–±—ã –≤—ã—Ä–∞–±–æ—Ç–∞–ª—Å—è –Ω–∞–≤—ã–∫. –•–æ—Ä–æ—à–∞—è –Ω–æ–≤–æ—Å—Ç—å: —á–µ–º –±–æ–ª—å—à–µ –æ–ø—ã—Ç–∞ –≤—ã –±—É–¥–µ—Ç–µ –ø—Ä–∏–æ–±—Ä–µ—Ç–∞—Ç—å —Å Rust –∏ –ø—Ä–∞–≤–∏–ª–∞–º–∏ —Å–∏—Å—Ç–µ–º—ã –≤–ª–∞–¥–µ–Ω–∏—è, —Ç–µ–º –ª–µ–≥—á–µ –≤–∞–º –±—É–¥–µ—Ç —Ä–∞–∑—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –±–µ–∑–æ–ø–∞—Å–Ω—ã–π –∏ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–π –∫–æ–¥. –í—ã—à–µ –Ω–æ—Å!</p>
<p>–ö–æ–≥–¥–∞ –≤—ã –ø–æ–π–º—ë—Ç–µ –≤–ª–∞–¥–µ–Ω–∏–µ, –≤—ã –ø–æ–ª—É—á–∏—Ç–µ —É—Å—Ç–æ–π—á–∏–≤—ã–π —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç –¥–ª—è –ø–æ–Ω–∏–º–∞–Ω–∏—è –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–µ–π, –∫–æ—Ç–æ—Ä—ã–µ –¥–µ–ª–∞—é—Ç Rust —É–Ω–∏–∫–∞–ª—å–Ω—ã–º —è–∑—ã–∫–æ–º. –í —ç—Ç–æ–π –≥–ª–∞–≤–µ –≤—ã –∏–∑—É—á–∏—Ç–µ –≤–ª–∞–¥–µ–Ω–∏–µ, –ø–æ—Ä–∞–±–æ—Ç–∞–≤ –Ω–∞–¥ –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ –ø—Ä–∏–º–µ—Ä–∞–º–∏ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –æ–¥–Ω–æ–π –∏–∑ —Å–∞–º—ã—Ö —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—ë–Ω–Ω—ã—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä –¥–∞–Ω–Ω—ã—Ö ‚Äî —Å—Ç—Ä–æ–∫.</p>
<blockquote>
<h3 id="–°—Ç–µ–∫-–∏-–∫—É—á–∞"><a class="header" href="#–°—Ç–µ–∫-–∏-–∫—É—á–∞">–°—Ç–µ–∫ –∏ –∫—É—á–∞</a></h3>
<p>–ú–Ω–æ–≥–∏–µ —è–∑—ã–∫–∏ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è –Ω–µ —Ç—Ä–µ–±—É—é—Ç –æ—Ç –≤–∞—Å –∑–∞–¥—É–º—ã–≤–∞—Ç—å—Å—è –æ —Å—Ç–µ–∫–µ –∏–ª–∏ –∫—É—á–µ. –ù–æ –≤ —Å–∏—Å—Ç–µ–º–Ω—ã—Ö —è–∑—ã–∫–∞—Ö –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è (–≤—Ä–æ–¥–µ Rust), –≤–∞–∂–Ω–æ –∑–Ω–∞—Ç—å —Ä–∞–∑–Ω–∏—Ü—É –º–µ–∂–¥—É —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ–º –¥–∞–Ω–Ω—ã—Ö –Ω–∞ —Å—Ç–µ–∫–µ –∏–ª–∏ –Ω–∞ –∫—É—á–µ, –∑–Ω–∞—Ç—å –æ —Ç–æ–º –∫–∞–∫ –≤–µ–¥—ë—Ç —Å–µ–±—è –ø—Ä–∏ —ç—Ç–æ–º —è–∑—ã–∫ –∏ –∫–∞–∫–∏–µ –ø–æ—Å–ª–µ–¥—Å—Ç–≤–∏—è –ø–æ–≤–ª–µ—á—ë—Ç –≤–∞—à –≤—ã–±–æ—Ä. –ß–∞—Å—Ç–∏—á–Ω–æ, –≤–ª–∞–¥–µ–Ω–∏–µ –±—É–¥–µ—Ç —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–æ –≤ –æ—Ç–Ω–æ—à–µ–Ω–∏–∏ —Å—Ç–µ–∫–∞, –∞ –ø–æ–¥ –∫–æ–Ω–µ—Ü –≥–ª–∞–≤—ã –º—ã –∫–æ—Å–Ω—ë–º—Å—è –∏ –∫—É—á–∏; –∞ –ø–æ–∫–∞, –¥–ª—è –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏, –∫—Ä–∞—Ç–∫–æ —Ä–∞—Å—Å–∫–∞–∂–µ–º –æ —Å—Ç–µ–∫–µ –∏ –∫—É—á–µ.</p>
<p>–ò —Å—Ç–µ–∫, –∏ –∫—É—á–∞ ‚Äî —ç—Ç–æ —É—á–∞—Å—Ç–∫–∏ –ø–∞–º—è—Ç–∏, –¥–æ—Å—Ç—É–ø–Ω—ã–µ –≤–∞—à–µ–π –ø—Ä–æ–≥—Ä–∞–º–º–µ –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è, –æ–¥–Ω–∞–∫–æ —É—Å—Ç—Ä–æ–µ–Ω—ã –æ–Ω–∏ –ø–æ-—Ä–∞–∑–Ω–æ–º—É. –°—Ç–µ–∫ —Ö—Ä–∞–Ω–∏—Ç –∑–Ω–∞—á–µ–Ω–∏—è –≤ –ø–æ—Ä—è–¥–∫–µ –∏—Ö –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∏ —É–¥–∞–ª—è–µ—Ç –∏—Ö –≤ –æ–±—Ä–∞—Ç–Ω–æ–º. –≠—Ç–æ –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è –ø—Ä–∏–Ω—Ü–∏–ø–æ–º <em>"–ø–µ—Ä–≤—ã–º –≤–æ—à—ë–ª ‚Äî –ø–æ—Å–ª–µ–¥–Ω–∏–º –≤—ã—à–µ–ª"</em>. –î—É–º–∞–π—Ç–µ –æ —Å—Ç–µ–∫–µ –∫–∞–∫ –æ —Å—Ç–æ–ø–∫–µ —Ç–∞—Ä–µ–ª–æ–∫: –µ—Å–ª–∏ –≤—ã –¥–æ–±–∞–≤–ª—è–µ—Ç–µ –±–æ–ª—å—à–µ —Ç–∞—Ä–µ–ª–æ–∫, –≤—ã —Å—Ç–∞–≤–∏—Ç–µ –∏—Ö –Ω–∞–≤–µ—Ä—Ö; –∫–æ–≥–¥–∞ –≤–∞–º –Ω—É–∂–Ω–æ –≤–∑—è—Ç—å —Ç–∞—Ä–µ–ª–∫—É, –≤—ã –±–µ—Ä—ë—Ç–µ –µ—ë —Å–≤–µ—Ä—Ö—É. –î–æ–±–∞–≤–∏—Ç—å –∏–ª–∏ —É–±—Ä–∞—Ç—å —Ç–∞—Ä–µ–ª–∫—É —Å–Ω–∏–∑—É –∏–ª–∏ –∏–∑ —Å–µ—Ä–µ–¥–∏–Ω—ã –Ω–µ –≤—ã–π–¥–µ—Ç! –ü–æ–º–µ—â–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –≤ —Å—Ç–µ–∫ –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è <em>push</em>, –∞ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ ‚Äî <em>pop</em>. –í—Å—ë, —á—Ç–æ —Ö—Ä–∞–Ω–∏—Ç—Å—è –Ω–∞ —Å—Ç–µ–∫–µ, –¥–æ–ª–∂–Ω–æ –∏–º–µ—Ç—å –ø–æ—Å—Ç–æ—è–Ω–Ω—ã–π –∏ –∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ä–∞–∑–º–µ—Ä. –ï—Å–ª–∏ –∂–µ –¥–ª—è –≤–∞—à–∏—Ö –¥–∞–Ω–Ω—ã—Ö –Ω–µ–ª—å–∑—è —É–∑–Ω–∞—Ç—å –¥–ª–∏–Ω—É –¥–æ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏, –∏–ª–∏ –µ—Å–ª–∏ –∏—Ö —Ä–∞–∑–º–µ—Ä –º–æ–∂–µ—Ç –ø–æ–º–µ–Ω—è—Ç—å—Å—è, —Å–ª–µ–¥—É–µ—Ç –≤–æ—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –∫—É—á–µ–π.</p>
<p>–ö—É—á–∞ –º–µ–Ω–µ–µ –æ—Ä–≥–∞–Ω–∏–∑–æ–≤–∞–Ω–∞: –∫–æ–≥–¥–∞ –≤—ã –ø–æ–º–µ—â–∞–µ—Ç–µ –¥–∞–Ω–Ω—ã–µ –≤ –∫—É—á—É, –≤—ã –ø–æ–ª—É—á–∞–µ—Ç–µ –Ω–µ–º–Ω–æ–≥–æ –º–µ—Å—Ç–∞ –≤ –Ω–µ–π –∏ —Ç—É–¥–∞ —Ä–∞–∑–º–µ—â–∞–µ—Ç–µ —Å–≤–æ–∏ –¥–∞–Ω–Ω—ã–µ. –†–∞—Å–ø—Ä–µ–¥–µ–ª–∏—Ç–µ–ª—å –ø–∞–º—è—Ç–∏ (—Å–∏–Ω–æ–Ω–∏–º: "–∞–ª–ª–æ–∫–∞—Ç–æ—Ä") –∏—â–µ—Ç –≤ –ø–∞–º—è—Ç–∏ —Å–≤–æ–±–æ–¥–Ω–æ–µ –º–µ—Å—Ç–æ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞, –ø–æ–º–µ—á–∞–µ—Ç –µ–≥–æ –∫–∞–∫ –∑–∞–¥–µ–π—Å—Ç–≤–æ–≤–∞–Ω–Ω–æ–µ –≤–∞—à–µ–π –ø—Ä–æ–≥—Ä–∞–º–º–æ–π, –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤–∞–º <em>—É–∫–∞–∑–∞—Ç–µ–ª—å</em> –Ω–∞ —ç—Ç–æ—Ç —É—á–∞—Å—Ç–æ–∫ –ø–∞–º—è—Ç–∏. –≠—Ç–æ—Ç –ø—Ä–æ—Ü–µ—Å—Å –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è <em>–∞–ª–ª–æ–∫–∞—Ü–∏–µ–π –ø–∞–º—è—Ç–∏ –≤ –∫—É—á–µ</em> –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ <em>–∞–ª–ª–æ–∫–∞—Ü–∏–µ–π</em> (–ø—Ä–∏–º–µ—á–∞–Ω–∏–µ: —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –≤ —Å—Ç–µ–∫–µ –Ω–µ —Å—á–∏—Ç–∞–µ—Ç—Å—è –∞–ª–ª–æ–∫–∞—Ü–∏–µ–π). –ü–æ—Å–∫–æ–ª—å–∫—É —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –∫—É—á—É –∏–º–µ–µ—Ç –∏–∑–≤–µ—Å—Ç–Ω—ã–π –∏ –ø–æ—Å—Ç–æ—è–Ω–Ω—ã–π —Ä–∞–∑–º–µ—Ä, –≤—ã –º–æ–∂–µ—Ç–µ —Ö—Ä–∞–Ω–∏—Ç—å –µ–≥–æ –Ω–∞ —Å—Ç–µ–∫–µ; –Ω–æ –µ—Å–ª–∏ –≤–∞–º –ø–æ—Ç—Ä–µ–±—É—é—Ç—Å—è –Ω–µ–ø–æ—Å—Ä–µ–¥—Å—Ç–≤–µ–Ω–Ω–æ –¥–∞–Ω–Ω—ã–µ, –≤–∞–º –Ω—É–∂–Ω–æ –±—É–¥–µ—Ç –æ–±—Ä–∞—Ç–∏—Ç—å—Å—è –ø–æ —É–∫–∞–∑–∞—Ç–µ–ª—é. –î—É–º–∞–π—Ç–µ –æ–± —ç—Ç–æ–º –∫–∞–∫ –æ –ø–æ—Ä—è–¥–∫–µ —Ä–∞—Å—Å–∞–¥–∫–∏ –≤ —Ä–µ—Å—Ç–æ—Ä–∞–Ω–µ: –∫–æ–≥–¥–∞ –≤—ã –≤—Ö–æ–¥–∏—Ç–µ, –≤—ã —Å–æ–æ–±—â–∞–µ—Ç–µ –æ —Ç–æ–º, —Å–∫–æ–ª—å–∫–æ —á–µ–ª–æ–≤–µ–∫ –≤ –≤–∞—à–µ–π –≥—Ä—É–ø–ø–µ, –∏ –æ—Ñ–∏—Ü–∏–∞–Ω—Ç –∏—â–µ—Ç –¥–ª—è –≤–∞—Å —Å—Ç–æ–ª–∏–∫ –ø–æ–¥—Ö–æ–¥—è—â–µ–≥–æ —Ä–∞–∑–º–µ—Ä–∞; –µ—Å–ª–∏ –∂–µ –∫—Ç–æ-—Ç–æ –∏–∑ –≤–∞—à–µ–π –≥—Ä—É–ø–ø—ã –æ–ø–∞–∑–¥—ã–≤–∞–µ—Ç, –≤—ã —Å–æ–æ–±—â–∞–µ—Ç–µ –µ–º—É, –≥–¥–µ –≤–∞—Å —Ä–∞–∑–º–µ—Å—Ç–∏–ª–∏.</p>
<p>–†–∞–∑–º–µ—â–µ–Ω–∏–µ –Ω–∞ —Å—Ç–µ–∫–µ –±—ã—Å—Ç—Ä–µ–µ, —á–µ–º –∞–ª–ª–æ–∫–∞—Ü–∏—è –≤ –∫—É—á–µ, –ø–æ—Å–∫–æ–ª—å–∫—É –ø—Ä–∏ —Ä–∞–∑–º–µ—â–µ–Ω–∏–∏ –Ω–∞ —Å—Ç–µ–∫–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–∏—Ç–µ–ª—é –ø–∞–º—è—Ç–∏ –Ω–µ –ø—Ä–∏—Ö–æ–¥–∏—Ç—Å—è –∏—Å–∫–∞—Ç—å —Å–≤–æ–±–æ–¥–Ω–æ–µ –º–µ—Å—Ç–æ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞: —Ç–∞–∫–æ–≤–æ–µ –≤—Å–µ–≥–¥–∞ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –Ω–∞ –≤–µ—Ä—à–∏–Ω–µ —Å—Ç–µ–∫–∞. –°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ, —Ä–µ–∑–º–µ—â–µ–Ω–∏–µ –≤ –∫—É—á–µ —Ç—Ä–µ–±—É–µ—Ç –∫—É–¥–∞ –±–æ–ª—å—à–µ —Ä–∞–±–æ—Ç—ã, –ø–æ—Å–∫–æ–ª—å–∫—É —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–∏—Ç–µ–ª—å –ø–∞–º—è—Ç–∏ –¥–æ–ª–∂–µ–Ω —Å–Ω–∞—á–∞–ª–∞ –Ω–∞–π—Ç–∏ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –±–æ–ª—å—à–æ–π –∏ –Ω–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–π —É—á–∞—Å—Ç–æ–∫ –≤ –ø–∞–º—è—Ç–∏, –∞ –ø–æ—Ç–æ–º –ø–æ–¥–≥–æ—Ç–æ–≤–∏—Ç—å—Å—è –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –∑–∞–ø—Ä–æ—Å—É –Ω–∞ –≤—ã–¥–µ–ª–µ–Ω–∏–µ –ø–∞–º—è—Ç–∏.</p>
<p>–î–æ—Å—Ç—É–ø –∫ –¥–∞–Ω–Ω—ã–º –≤ –∫—É—á–µ –º–µ–¥–ª–µ–Ω–Ω–µ–µ, —á–µ–º –∫ –¥–∞–Ω–Ω—ã–º –Ω–∞ —Å—Ç–µ–∫–µ, –ø–æ—Å–∫–æ–ª—å–∫—É –≤–∞–º –Ω—É–∂–Ω–æ —Å–Ω–∞—á–∞–ª–∞ –æ—Ç—ã—Å–∫–∞—Ç—å –Ω—É–∂–Ω—ã–π —É—á–∞—Å—Ç–æ–∫ –ø–∞–º—è—Ç–∏ –ø–æ —É–∫–∞–∑–∞—Ç–µ–ª—é. –°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–µ –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä—ã —Ä–∞–±–æ—Ç–∞—é—Ç –±—ã—Å—Ç—Ä–µ–µ, –µ—Å–ª–∏ –Ω–µ –Ω–∞–≥—Ä—É–∂–∞—Ç—å –∏—Ö —á–∞—Å—Ç—ã–º–∏ –æ–±—Ä–∞—â–µ–Ω–∏—è–º–∏ –∫ –ø–∞–º—è—Ç–∏. –ü—Ä–æ–¥–æ–ª–∂–∞—è –∞–Ω–∞–ª–æ–≥–∏—é —Å —Ä–µ—Å—Ç–æ—Ä–∞–Ω–∞–º–∏: –ø–æ–¥—É–º–∞–π—Ç–µ –æ –ø—Ä–∏—ë–º–µ –æ—Ñ–∏—Ü–∏–∞–Ω—Ç–æ–º –∑–∞–∫–∞–∑–æ–≤ –ø–æ—Å–µ—Ç–∏—Ç–µ–ª–µ–π. –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–µ–µ –≤—Å–µ–≥–æ –±—É–¥–µ—Ç –≤–∑—è—Ç—å –≤—Å–µ –∑–∞–∫–∞–∑—ã —Å –æ–¥–Ω–æ–≥–æ —Å—Ç–æ–ª–∏–∫–∞ –ø–µ—Ä–µ–¥ —Ç–µ–º, –∫–∞–∫ –∏–¥—Ç–∏ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É. –ï—Å–ª–∏ –∂–µ –ø—ã—Ç–∞—Ç—å—Å—è –≤–∑—è—Ç—å –∑–∞–∫–∞–∑ —É —Å—Ç–æ–ª–∏–∫–∞ A, –ø–æ—Ç–æ–º —É —Å—Ç–æ–ª–∏–∫–∞ B, –ø–æ—Ç–æ–º —Å–Ω–æ–≤–∞ —É A, –∞ –ø–æ—Ç–æ–º –µ—â—ë —Ä–∞–∑ —É B... –≠—Ç–æ –±—É–¥–µ—Ç –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ –º–µ–¥–ª–µ–Ω–Ω–µ–µ. –¢–æ—á–Ω–æ —Ç–∞–∫ –∂–µ –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä—É –ª–µ–≥—á–µ –∏ –±—ã—Å—Ç—Ä–µ–µ –≤—ã–ø–æ–ª–Ω–∏—Ç—å —Å–≤–æ—é —Ä–∞–±–æ—Ç—É, –µ—Å–ª–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –¥–∞–Ω–Ω—ã–µ –±—É–¥—É—Ç –ª–µ–∂–∞—Ç—å —Ä—è–¥–æ–º (–∫–∞–∫ –Ω–∞ —Å—Ç–µ–∫–µ), –∞ –Ω–µ —Ä–∞–∑—Ä–æ–∑–Ω–µ–Ω–Ω–æ –ø–æ –≤—Å–µ–π –ø–∞–º—è—Ç–∏ (–∫–∞–∫ –≤ –∫—É—á–µ).</p>
<p>–ö–æ–≥–¥–∞ –≤–∞—à –∫–æ–¥ –≤—ã–∑—ã–≤–∞–µ—Ç —Ñ—É–Ω–∫—Ü–∏—é, –∑–Ω–∞—á–µ–Ω–∏—è, –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ (–≤–∫–ª—é—á–∞—è, –Ω–∞–ø—Ä–∏–º–µ—Ä, —É–∫–∞–∑–∞—Ç–µ–ª–∏ –Ω–∞ –¥–∞–Ω–Ω—ã–µ –≤ –∫—É—á–µ), –∏ –ª–æ–∫–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ —Ä–∞–∑–º–µ—â–∞—é—Ç—Å—è –Ω–∞ —Å—Ç–µ–∫–µ. –ö–æ–≥–¥–∞ —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è, –∑–Ω–∞—á–µ–Ω–∏—è –∏–∑–≤–ª–µ–∫–∞—é—Ç—Å—è –∏–∑ —Å—Ç–µ–∫–∞ –∏ –∏—Ö –ø–∞–º—è—Ç—å –æ—Å–≤–æ–±–æ–∂–¥–∞–µ—Ç—Å—è.</p>
<p>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ç–µ–º, –∫–∞–∫–∏–µ —É—á–∞—Å—Ç–∫–∏ –ø—Ä–æ–≥—Ä–∞–º–º—ã –∫–∞–∫—É—é –∏—Å–ø–æ–ª—å–∑—É—é—Ç –ø–∞–º—è—Ç—å –≤ –∫—É—á–µ; –º–∏–Ω–∏–º–∏–∑–∞—Ü–∏—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –≤ –∫—É—á–µ; –æ—á–∏—Å—Ç–∫–∞ –Ω–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã—Ö –¥–∞–Ω–Ω—ã—Ö ‚Äî —ç—Ç–æ –≤—Å—ë —Ä–∞–±–æ—Ç–∞ –º–µ—Ö–∞–Ω–∏–∑–º–∞ –≤–ª–∞–¥–µ–Ω–∏—è. –ö–∞–∫ —Ç–æ–ª—å–∫–æ –≤—ã –ø–æ–π–º—ë—Ç–µ –≤–ª–∞–¥–µ–Ω–∏–µ, –≤–∞–º  –Ω–µ –ø–æ–Ω–∞–¥–æ–±–∏—Ç—Å—è —Å–∞–º–æ–º—É –æ—Å–æ–±–µ–Ω–Ω–æ —á–∞—Å—Ç–æ –¥—É–º–∞—Ç—å –æ —Å—Ç–µ–∫–µ –∏ –∫—É—á–µ, –Ω–æ –∑–Ω–∞–Ω–∏–µ –æ —Ç–æ–º, —á—Ç–æ –æ—Å–Ω–æ–≤–Ω–∞—è –∑–∞–¥–∞—á–∞ –≤–ª–∞–¥–µ–Ω–∏—è ‚Äî —ç—Ç–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å—Ç–µ–∫–æ–º –∏ –∫—É—á–µ–π, –ø–æ–º–æ–∂–µ—Ç –≤–∞–º –ø–æ–Ω—è—Ç—å, –ø–æ—á–µ–º—É –≤–ª–∞–¥–µ–Ω–∏–µ —É—Å—Ç—Ä–æ–µ–Ω–æ –∏–º–µ–Ω–Ω–æ —Ç–∞–∫.</p>
</blockquote>
<h3 id="–ü—Ä–∞–≤–∏–ª–∞-–≤–ª–∞–¥–µ–Ω–∏—è"><a class="header" href="#–ü—Ä–∞–≤–∏–ª–∞-–≤–ª–∞–¥–µ–Ω–∏—è">–ü—Ä–∞–≤–∏–ª–∞ –≤–ª–∞–¥–µ–Ω–∏—è</a></h3>
<p>–î–ª—è –Ω–∞—á–∞–ª–∞, –¥–∞–≤–∞–π—Ç–µ –ø–æ—Å–º–æ—Ç—Ä–∏–º –Ω–∞ –ø—Ä–∞–≤–∏–ª–∞ –≤–ª–∞–¥–µ–Ω–∏—è. –î–µ—Ä–∂–∏—Ç–µ –∏—Ö –≤ –≥–æ–ª–æ–≤–µ –ø–æ –º–µ—Ä–µ —Ç–æ–≥–æ, –∫–∞–∫ –º—ã –±—É–¥–µ–º –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –∏–ª–ª—é—Å—Ç—Ä–∏—Ä—É—é—â–∏–µ –∏—Ö –ø—Ä–∏–º–µ—Ä—ã:</p>
<ul>
<li>–ö–∞–∂–¥–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –≤ Rust –∏–º–µ–µ—Ç <em>–≤–ª–∞–¥–µ–ª—å—Ü–∞</em>.</li>
<li>–í –æ–¥–∏–Ω –º–æ–º–µ–Ω—Ç —É –∑–Ω–∞—á–µ–Ω–∏—è –º–æ–∂–µ—Ç –±—ã—Ç—å —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω –≤–ª–∞–¥–µ–ª–µ—Ü.</li>
<li>–ö–æ–≥–¥–∞ –≤–ª–∞–¥–µ–ª–µ—Ü –ø–æ–∫–∏–¥–∞–µ—Ç —Å–≤–æ—é –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏, –∑–Ω–∞—á–µ–Ω–∏–µ –≤—ã—Å–≤–æ–±–æ–∂–¥–∞–µ—Ç—Å—è.</li>
</ul>
<h3 id="–û–±–ª–∞—Å—Ç—å-–≤–∏–¥–∏–º–æ—Å—Ç–∏-–ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π"><a class="header" href="#–û–±–ª–∞—Å—Ç—å-–≤–∏–¥–∏–º–æ—Å—Ç–∏-–ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π">–û–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π</a></h3>
<p>–¢–µ–ø–µ—Ä—å, –ø–æ—Å–∫–æ–ª—å–∫—É –º—ã –æ—Å–≤–æ–∏–ª–∏—Å—å —Å –±–∞–∑–æ–≤—ã–º —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–æ–º Rust, –º—ã –Ω–µ –±—É–¥–µ–º –ø–æ—Å—Ç–æ—è–Ω–Ω–æ –≤–∫–ª—é—á–∞—Ç—å –∫–æ–¥ –ø—Ä–∏–º–µ—Ä–æ–≤ –≤ <code>fn main() {</code>, —Ç–∞–∫ —á—Ç–æ –µ—Å–ª–∏ –≤—ã –∑–∞—Ö–æ—Ç–∏—Ç–µ –ø–æ–≤—Ç–æ—Ä–∏—Ç—å –ø—Ä–∏–º–µ—Ä—ã, –Ω–µ –∑–∞–±—É–¥—å—Ç–µ –ø–æ–º–µ—Å—Ç–∏—Ç—å –∏—Ö –≤ —Ñ—É–Ω–∫—Ü–∏—é <code>main</code>. –ú—ã –æ–ø—É—Å–∫–∞–µ–º —è–≤–Ω–æ–µ —É–ø–æ–º–∏–Ω–∞–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ <code>main</code>, —á—Ç–æ–±—ã —Å–æ—Å—Ä–µ–¥–æ—Ç–æ—á–∏—Ç—å—Å—è –Ω–∞ –¥–µ—Ç–∞–ª—è—Ö, –Ω–∞ –Ω—é–∞–Ω—Å–∞—Ö –∫–æ–¥–∞, –∞ –Ω–µ –Ω–∞ —É–∂–µ –∑–∞—É—á–µ–Ω–Ω—ã—Ö —à–∞–±–ª–æ–Ω–∞—Ö.</p>
<p>–í –∫–∞—á–µ—Å—Ç–≤–µ –ø–µ—Ä–≤–æ–≥–æ –ø—Ä–∏–º–µ—Ä–∞ –≤–ª–∞–¥–µ–Ω–∏—è, –º—ã –∏–∑—É—á–∏–º –≥—Ä–∞–Ω–∏—Ü—ã <em>–æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏</em> –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö. –û–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ ‚Äî —ç—Ç–æ —É—á–∞—Å—Ç–æ–∫ –ø—Ä–æ–≥—Ä–∞–º–º—ã, –≤ –∫–æ—Ç–æ—Ä–æ–º –¥–∞–Ω–Ω—ã–µ –µ—â—ë –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã. –í–æ—Ç –ø—Ä–∏–º–µ—Ä –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = "hello";
<span class="boring">}</span></code></pre></pre>
<p>–ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è <code>s</code> —Å–≤—è–∑–∞–Ω–∞ —Å –ª–∏—Ç–µ—Ä–∞–ª–æ–º —Å—Ç—Ä–æ–∫–∏, –∑–∞–ø–∏—Å–∞–Ω–Ω—ã–º –Ω–µ–ø–æ—Å—Ä–µ–¥—Å—Ç–≤–µ–Ω–Ω–æ –≤ –∫–æ–¥–µ –Ω–∞—à–µ–π –ø—Ä–æ–≥—Ä–∞–º–º—ã. –ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞ —Å —Ç–µ—Ö –ø–æ—Ä, –∫–∞–∫ –æ–Ω–∞ –æ–±—ä—è–≤–ª–µ–Ω–∞, –∏ –¥–æ –∫–æ–Ω—Ü–∞ –µ—ë <em>–æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏</em>. –õ–∏—Å—Ç–∏–Ω–≥ 4-1 —Å–æ–¥–µ—Ä–∂–∏—Ç –ø—Ä–æ–≥—Ä–∞–º–º—É —Å –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è–º–∏ –æ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –≤ —Ä–∞–∑–Ω—ã–µ –º–æ–º–µ–Ω—Ç—ã.</p>
<Listing number="4-1" caption="A variable and the scope in which it is valid">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    {                      // s –ø–æ–∫–∞ –Ω–µ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞, —Ç–∞–∫ –∫–∞–∫ –Ω–µ –æ–±—ä—è–≤–ª–µ–Ω–∞
        let s = "hello";   // –æ—Ç—Å—é–¥–∞ –∏ –¥–∞–ª–µ–µ s –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞

        // –∑–¥–µ—Å—å –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å s
    }                      // –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∑–∞–∫–æ–Ω—á–∏–ª–∞—Å—å, s –±–æ–ª—å—à–µ –Ω–µ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>–í –æ–±—â–µ–º, –∑–¥–µ—Å—å –µ—Å—Ç—å –¥–≤–∞ –≤–∞–∂–Ω—ã—Ö –º–æ–º–µ–Ω—Ç–∞:</p>
<ul>
<li>–ö–æ–≥–¥–∞ <code>s</code> <em>–æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è</em> –≤ –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏, –æ–Ω–∞ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞.</li>
<li>–û–Ω–∞ –æ—Å—Ç–∞—ë—Ç—Å—è –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ–π, –ø–æ–∫–∞ –Ω–µ <em>–ø–æ–∫–∏–Ω–µ—Ç</em> –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏.</li>
</ul>
<p>–ü–æ–∫–∞ —á—Ç–æ –æ—Ç–Ω–æ—à–µ–Ω–∏—è –º–µ–∂–¥—É –æ–±–ª–∞—Å—Ç—è–º–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∏ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –≤ —Ü–µ–ª–æ–º —Ç–∞–∫–∏–µ –∂–µ, –∫–∞–∫ –∏ –≤ –¥—Ä—É–≥–∏—Ö —è–∑—ã–∫–∞—Ö –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è. –¢–µ–ø–µ—Ä—å, –Ω–∞ —ç—Ç–æ–º —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–µ, –º—ã —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º —Ç–∏–ø <code>String</code>.</p>
<h3 id="–¢–∏–ø-string"><a class="header" href="#–¢–∏–ø-string">–¢–∏–ø <code>String</code></a></h3>
<p>–ß—Ç–æ–±—ã –ø—Ä–æ–∏–ª–ª—é—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–∞–≤–∏–ª–∞ –≤–ª–∞–¥–µ–Ω–∏—è, –Ω–∞–º –Ω—É–∂–µ–Ω —Ç–∏–ø –¥–∞–Ω–Ω—ã—Ö –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω—ã–π, —á–µ–º —Ç–µ, —á—Ç–æ –º—ã —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–ª–∏ –≤ —Ä–∞–∑–¥–µ–ª–µ <a href="ch03-02-data-types.html#%D0%A2%D0%B8%D0%BF%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85">"–¢–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö"</a><!-- ignore --> –ì–ª–∞–≤—ã 3. –¢–∞–º –º—ã —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞–ª–∏ —Ç–∞–∫–∏–µ —Ç–∏–ø—ã, –∫–æ—Ç–æ—Ä—ã–µ –∏–º–µ—é—Ç —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ä–∞–∑–º–µ—Ä; —Ö—Ä–∞–Ω—è—Ç—Å—è –Ω–∞ —Å—Ç–µ–∫–µ –∏ –≤—ã—Å–≤–æ–±–æ–∂–¥–∞—é—Ç—Å—è —Å –∫–æ–Ω—Ü–æ–º –∏—Ö –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏; –º–æ–≥—É—Ç –±—ã—Ç—å –±—ã—Å—Ç—Ä–æ –∏ –ø—Ä–æ—Å—Ç–æ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω—ã, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –æ—Ç–¥–µ–ª—å–Ω–æ –∂–∏–≤—É—â—É—é –∫–æ–ø–∏—é –¥–∞–Ω–Ω—ã—Ö, –∫–æ—Ç–æ—Ä—É—é –º–æ–∂–Ω–æ –∑–∞—Ç–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤ –¥—Ä—É–≥–æ–π –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏. –ù–æ –Ω–∞ —ç—Ç–æ—Ç —Ä–∞–∑ –Ω–∞–º –Ω—É–∂–Ω—ã –¥–∞–Ω–Ω—ã–µ, –∫–æ—Ç–æ—Ä—ã–µ –ø—Ä–∏–¥—ë—Ç—Å—è —Ö—Ä–∞–Ω–∏—Ç—å –≤ –∫—É—á–µ ‚Äî —á—Ç–æ–±—ã —É–∑–Ω–∞—Ç—å, –∫–∞–∫ Rust –≤—ã—è—Å–Ω—è–µ—Ç –º–æ–º–µ–Ω—Ç –¥–ª—è –≤—ã—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏—è —ç—Ç–∏—Ö –¥–∞–Ω–Ω—ã—Ö. –¢–∏–ø <code>String</code> –Ω–∞–º –æ—Ç–ª–∏—á–Ω–æ –ø–æ–¥–æ–π–¥—ë—Ç.</p>
<p>–ú—ã —Å–∫–æ–Ω—Ü–µ–Ω—Ç—Ä–∏—Ä—É–µ–º—Å—è –Ω–∞ —Ç–µ—Ö —á–∞—Å—Ç—è—Ö String, –∫–æ—Ç–æ—Ä—ã–µ —Å–≤—è–∑–∞–Ω—ã —Å –≤–ª–∞–¥–µ–Ω–∏–µ–º. –≠—Ç–∏ –∞—Å–ø–µ–∫—Ç—ã —Ç–∞–∫–∂–µ –ø—Ä–∏–º–µ–Ω–∏–º—ã –∫ –¥—Ä—É–≥–∏–º —Å–ª–æ–∂–Ω—ã–º —Ç–∏–ø–∞–º –¥–∞–Ω–Ω—ã—Ö, –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –æ—Ç —Ç–æ–≥–æ, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω—ã –æ–Ω–∏ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–æ–π –∏–ª–∏ —Å–æ–∑–¥–∞–Ω—ã –≤–∞–º–∏. –ë–æ–ª–µ–µ –ø–æ–¥—Ä–æ–±–Ω–æ –º—ã –æ–±—Å—É–¥–∏–º <code>String</code> –≤ <a href="ch08-02-strings.html">–ì–ª–∞–≤–µ 8</a><!-- ignore -->.</p>
<p>–ú—ã —É–∂–µ –≤–∏–¥–µ–ª–∏ —Å—Ç—Ä–æ–∫–æ–≤—ã–µ –ª–∏—Ç–µ—Ä–∞–ª—ã, –≥–¥–µ —Å—Ç—Ä–æ–∫–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —è–≤–Ω–æ –≤–ø–∏—Å–∞–Ω–æ –≤ –Ω–∞—à—É –ø—Ä–æ–≥—Ä–∞–º–º—É. –°—Ç—Ä–æ–∫–æ–≤—ã–µ –ª–∏—Ç–µ—Ä–∞–ª—ã —É–¥–æ–±–Ω—ã, –Ω–æ –æ–Ω–∏ –ø–æ–¥—Ö–æ–¥—è—Ç –Ω–µ –¥–ª—è –∫–∞–∂–¥–æ–π —Å–∏—Ç—É–∞—Ü–∏–∏, –≥–¥–µ –º—ã –º–æ–∂–µ–º —Ö–æ—Ç–µ—Ç—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–µ–∫—Å—Ç. –û–¥–Ω–∞ –∏–∑ –ø—Ä–∏—á–∏–Ω –∑–∞–∫–ª—é—á–∞–µ—Ç—Å—è –≤ —Ç–æ–º, —á—Ç–æ –æ–Ω–∏ –Ω–µ–∏–∑–º–µ–Ω—è–µ–º—ã. –ö—Ä–æ–º–µ —Ç–æ–≥–æ, –Ω–µ –≤—Å–µ–≥–¥–∞ —Å—Ç—Ä–æ–∫–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –∏–∑–≤–µ—Å—Ç–Ω–æ —É–∂–µ –≤–æ –≤—Ä–µ–º—è –Ω–∞–ø–∏—Å–∞–Ω–∏—è –∫–æ–¥–∞: —á—Ç–æ, –µ—Å–ª–∏ –º—ã –∑–∞—Ö–æ—Ç–∏–º –ø—Ä–∏–Ω—è—Ç—å –∏ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π –≤–≤–æ–¥? –î–ª—è —Ç–∞–∫–∏—Ö —Å–∏—Ç—É–∞—Ü–∏–π –≤ Rust –µ—Å—Ç—å –µ—â—ë –æ–¥–∏–Ω —Å—Ç—Ä–æ–∫–æ–≤—ã–π —Ç–∏–ø ‚Äî <code>String</code>. –≠—Ç–æ—Ç —Ç–∏–ø —É–ø—Ä–∞–≤–ª—è–µ—Ç –¥–∞–Ω–Ω—ã–º–∏, –≤—ã–¥–µ–ª–µ–Ω–Ω—ã–º–∏ –≤ –∫—É—á–µ, –∏ –ø–æ—ç—Ç–æ–º—É –º–æ–∂–µ—Ç —Ö—Ä–∞–Ω–∏—Ç—å –æ–±—ä—ë–º —Ç–µ–∫—Å—Ç–∞, –∫–æ—Ç–æ—Ä—ã–π –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –Ω–µ–∏–∑–≤–µ—Å—Ç–µ–Ω. –í—ã –º–æ–∂–µ—Ç–µ —Å–æ–∑–¥–∞—Ç—å <code>String</code> –∏–∑ —Å—Ç—Ä–æ–∫–æ–≤–æ–≥–æ –ª–∏—Ç–µ—Ä–∞–ª–∞, –∏—Å–ø–æ–ª—å–∑—É—è —Ñ—É–Ω–∫—Ü–∏—é <code>from</code>; –≤–æ—Ç —Ç–∞–∫:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");
<span class="boring">}</span></code></pre></pre>
<p>–û–ø–µ—Ä–∞—Ç–æ—Ä "–¥–≤–æ–π–Ω–æ–µ –¥–≤–æ–µ—Ç–æ—á–∏–µ" (<code>::</code>) –ø–æ–∑–≤–æ–ª—è–µ—Ç –æ–±—Ä–∞—â–∞—Ç—å—Å—è –∫ –¥–∞–Ω–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ <code>from</code> –∫–∞–∫ –∫ —Ñ—É–Ω–∫—Ü–∏–∏ –Ω–∞–¥ —Ç–∏–ø–æ–º <code>String</code>. –û–Ω –ø–æ–∑–≤–æ–ª—è–µ—Ç –æ—Ç–∫–∞–∑–∞—Ç—å—Å—è –æ—Ç —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã—Ö —Å–∞–º–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω—ã—Ö –∏–º—ë–Ω, –≤—Ä–æ–¥–µ <code>string_from</code>. –ú—ã –æ–±—Å—É–¥–∏–º —ç—Ç–æ—Ç —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –±–æ–ª–µ–µ –ø–æ–¥—Ä–æ–±–Ω–æ –≤ —Ä–∞–∑–¥–µ–ª–µ <a href="ch05-03-method-syntax.html#%D0%A1%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%81-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B0">"–°–∏–Ω—Ç–∞–∫—Å–∏—Å –º–µ—Ç–æ–¥–∞"</a><!-- ignore --> –ì–ª–∞–≤—ã 5, –∞ —Ç–∞–∫–∂–µ –≤ —Ö–æ–¥–µ –æ–±—Å—É–∂–¥–µ–Ω–∏—è –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤ –∏–º—ë–Ω –∏ –º–æ–¥—É–ª–µ–π –≤ —Ä–∞–∑–¥–µ–ª–µ <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">"–ü—É—Ç–∏ –¥–ª—è —Å—Å—ã–ª–∫–∏ –Ω–∞ —ç–ª–µ–º–µ–Ω—Ç –≤ –¥–µ—Ä–µ–≤–µ –º–æ–¥—É–ª–µ–π"</a><!-- ignore --> –ì–ª–∞–≤—ã 7.</p>
<p>–ü–æ–¥–æ–±–Ω–æ–≥–æ —Ä–æ–¥–∞ —Å—Ç—Ä–æ–∫–∏ <em>–º–æ–≥—É—Ç</em> –±—ã—Ç—å –∏–∑–º–µ–Ω–µ–Ω—ã</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    s.push_str(", world!"); // push_str() –ø—Ä–∏–ø–∏—Å—ã–≤–∞–µ—Ç –ª–∏—Ç–µ—Ä–∞–ª –∫ String

    println!("{s}"); // –ë—É–¥–µ—Ç –Ω–∞–ø–µ—á–∞—Ç–∞–Ω–æ `hello, world!`
<span class="boring">}</span></code></pre></pre>
<p>–í —á–µ–º –∂–µ —Ä–∞–∑–Ω–∏—Ü–∞? –ü–æ—á–µ–º—É —Å—Ç—Ä–æ–∫—É <code>String</code> –º–æ–∂–Ω–æ –∏–∑–º–µ–Ω–∏—Ç—å, –∞ –ª–∏—Ç–µ—Ä–∞–ª—ã ‚Äî –Ω–µ–ª—å–∑—è? –†–∞–∑–Ω–∏—Ü–∞ –∑–∞–∫–ª—é—á–∞–µ—Ç—Å—è –≤ —Ç–æ–º, –∫–∞–∫ —ç—Ç–∏ –¥–≤–∞ —Ç–∏–ø–∞ —Ä–∞–±–æ—Ç–∞—é—Ç —Å –ø–∞–º—è—Ç—å—é.</p>
<h3 id="–ü–∞–º—è—Ç—å-–∏-–µ—ë-–≤—ã–¥–µ–ª–µ–Ω–∏–µ"><a class="header" href="#–ü–∞–º—è—Ç—å-–∏-–µ—ë-–≤—ã–¥–µ–ª–µ–Ω–∏–µ">–ü–∞–º—è—Ç—å –∏ –µ—ë –≤—ã–¥–µ–ª–µ–Ω–∏–µ</a></h3>
<p>–í —Å–ª—É—á–∞–µ –ª–∏—Ç–µ—Ä–∞–ª–∞ —Å—Ç—Ä–æ–∫–∏, –º—ã –∑–Ω–∞–µ–º –µ–≥–æ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏, —Ç–∞–∫ —á—Ç–æ –æ–Ω–æ –±—É–¥–µ—Ç —è–≤–Ω–æ –ø—Ä–æ–ø–∏—Å–∞–Ω–æ –≤ –∏—Ç–æ–≥–æ–≤–æ–º –∏—Å–ø–æ–ª–Ω—è–µ–º–æ–º —Ñ–∞–π–ª–µ. –ü—Ä–∏—á–∏–Ω–∞ —Ç–æ–≥–æ, —á—Ç–æ —Å—Ç—Ä–æ–∫–æ–≤—ã–µ –ª–∏—Ç–µ—Ä–∞–ª—ã –±–æ–ª–µ–µ –±—ã—Å—Ç—Ä—ã–µ –∏ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–µ, —Å–æ—Å—Ç–æ–∏—Ç –≤ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –∏—Ö –∏–∑–º–µ–Ω—è—Ç—å. –ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –≤ –∏—Å–ø–æ–ª–Ω—è–µ–º–æ–º —Ñ–∞–π–ª–µ –Ω–µ–ª—å–∑—è –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∫—É—Å–æ–∫ –ø–∞–º—è—Ç–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–≥–æ –∏ –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–≥–æ –ø—Ä–∏ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ —Ä–∞–∑–º–µ—Ä–∞, –∫–æ—Ç–æ—Ä—ã–π –∫ —Ç–æ–º—É –∂–µ –º–æ–∂–µ—Ç –µ—â—ë –∏ –º–µ–Ω—è—Ç—å—Å—è –≤–æ –≤—Ä–µ–º—è –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è –ø—Ä–æ–≥—Ä–∞–º–º—ã.</p>
<p>–ß—Ç–æ–±—ã —Å–¥–µ–ª–∞—Ç—å –≤–æ–∑–º–æ–∂–Ω—ã–º –∏–∑–º–µ–Ω—è–µ–º—ã–π, –Ω–∞—Ä–∞—â–∏–≤–∞–µ–º—ã–π —Ç–µ–∫—Å—Ç —Ç–∏–ø–∞ <code>String</code>, –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –≤—ã–¥–µ–ª—è—Ç—å –ø–∞–º—è—Ç—å –≤ –∫—É—á–µ –¥–ª—è –≤—Å–µ–≥–æ –µ–≥–æ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ, –æ–±—ä—ë–º –∫–æ—Ç–æ—Ä–æ–≥–æ –Ω–µ–∏–∑–≤–µ—Å—Ç–µ–Ω –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏. –≠—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ:</p>
<ul>
<li>–ü–∞–º—è—Ç—å –¥–æ–ª–∂–Ω–∞ –∑–∞–ø—Ä–∞—à–∏–≤–∞—Ç—å—Å—è —É —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–∏—Ç–µ–ª—è –ø–∞–º—è—Ç–∏ –≤–æ –≤—Ä–µ–º—è –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è –ø—Ä–æ–≥—Ä–∞–º–º—ã.</li>
<li>–ù–µ–æ–±—Ö–æ–¥–∏–º —Å–ø–æ—Å–æ–± –≤–µ—Ä–Ω—É—Ç—å —ç—Ç—É –ø–∞–º—è—Ç—å —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–∏—Ç–µ–ª—é, –∫–æ–≥–¥–∞ –º—ã –∑–∞–∫–æ–Ω—á–∏–ª–∏ —Ä–∞–±–æ—Ç—É —Å –Ω–∞—à–µ–π <code>String</code>.</li>
</ul>
<p>–ü–µ—Ä–≤–æ–µ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –Ω–∞–º–∏: –∫–æ–≥–¥–∞ –º—ã –≤—ã–∑—ã–≤–∞–µ–º <code>String::from</code>, –µ–≥–æ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º—É—é –ø–∞–º—è—Ç—å. –¢–∞–∫–æ–µ –¥–æ–≤–æ–ª—å–Ω–æ –∑–Ω–∞–∫–æ–º–æ –º–Ω–æ–≥–∏–º —è–∑—ã–∫–∞–º –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è.</p>
<p>–û–¥–Ω–∞–∫–æ –≤—Ç–æ—Ä–æ–π –ø—É–Ω–∫—Ç –∫—É–¥–∞ –∏–Ω—Ç–µ—Ä–µ—Å–Ω–µ–µ. –í —è–∑—ã–∫–∞—Ö —Å–æ <em>—Å–±–æ—Ä—â–∏–∫–æ–º –º—É—Å–æ—Ä–∞ (GC)</em> –ø–∞–º—è—Ç—å, –∫–æ—Ç–æ—Ä–∞—è –±–æ–ª—å—à–µ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è, –∏–º –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç—Å—è –∏ –æ—á–∏—â–∞–µ—Ç—Å—è ‚Äî –Ω–∞–º –Ω–µ –Ω—É–∂–Ω–æ –æ–± —ç—Ç–æ–º –¥—É–º–∞—Ç—å. –í –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–µ —è–∑—ã–∫–æ–≤ –±–µ–∑ —Å–±–æ—Ä—â–∏–∫–∞ –º—É—Å–æ—Ä–∞ –º—ã –æ–±—è–∑–∞–Ω—ã —Å–∞–º–∏ –æ–ø—Ä–µ–¥–µ–ª—è—Ç—å, –∫–æ–≥–¥–∞ –ø–∞–º—è—Ç—å –±–æ–ª—å—à–µ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è, –∏ –≤—ã–∑—ã–≤–∞—Ç—å –∫–æ–¥, —è–≤–Ω–æ –µ—ë –æ—Å–≤–æ–±–æ–∂–¥–∞—é—â–∏–π: —Ç–æ—á–Ω–æ —Ç–∞–∫ –∂–µ, –∫–∞–∫ –º—ã –¥–µ–ª–∞–ª–∏ —ç—Ç–æ –¥–ª—è –µ—ë –≤—ã–¥–µ–ª–µ–Ω–∏—è. –ü—Ä–∞–≤–∏–ª—å–Ω—ã–µ —Ä—É—á–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã –Ω–∞ –≤—ã–¥–µ–ª–µ–Ω–∏–µ –∏ –≤—ã—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏–µ –ø–∞–º—è—Ç–∏ –≤—Å–µ–≥–¥–∞ –±—ã–ª–∏ —Å–ª–æ–∂–Ω–æ–π –ø—Ä–æ–±–ª–µ–º–æ–π –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è. –ï—Å–ª–∏ –º—ã –∑–∞–±—É–¥–µ–º –æ—Å–≤–æ–±–æ–¥–∏—Ç—å –ø–∞–º—è—Ç—å, –æ–Ω–∞ –±—É–¥–µ—Ç –ø–æ—Ç–µ—Ä—è–Ω–∞ –∏ –±–µ–∑ –ø—Ä–æ–∫—É –∑–∞–±—å—ë—Ç —Å–æ–±–æ–π –º–µ—Å—Ç–æ. –ï—Å–ª–∏ –∂–µ –º—ã —Å–¥–µ–ª–∞–µ–º —ç—Ç–æ —Å–ª–∏—à–∫–æ–º —Ä–∞–Ω–æ, —É –Ω–∞—Å –±—É–¥–µ—Ç –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è. –°–¥–µ–ª–∞—Ç—å —ç—Ç–æ –¥–≤–∞–∂–¥—ã ‚Äî —Ç–æ–∂–µ –≤—ã–π–¥—É—Ç –ø—Ä–æ–±–ª–µ–º—ã. –ù–∞–º –Ω—É–∂–Ω–æ —Ä–æ–≤–Ω–æ –µ–¥–∏–Ω–æ–∂–¥—ã –≤—ã—Å–≤–æ–±–æ–¥–∏—Ç—å –ø–∞–º—è—Ç—å, –∫–æ—Ç–æ—Ä—É—é –º—ã –µ–¥–∏–Ω–æ–∂–¥—ã –≤—ã–¥–µ–ª–∏–ª–∏.</p>
<p>Rust –ø–æ—à—ë–ª –ø–æ —Å–≤–æ–µ–º—É: –ø–∞–º—è—Ç—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è —Å–∏—Å—Ç–µ–º–µ, –∫–∞–∫ —Ç–æ–ª—å–∫–æ –≤–ª–∞–¥–µ—é—â–∞—è –ø–∞–º—è—Ç—å—é –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –≤—ã—Ö–æ–¥–∏—Ç –∏–∑ –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏. –í–æ—Ç –≤–µ—Ä—Å–∏—è –ø—Ä–∏–º–µ—Ä–∞ —Å –æ–±–ª–∞—Å—Ç—å—é –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∏–∑ –õ–∏—Å—Ç–∏–Ω–≥–∞ 4-1, –≤ –∫–æ—Ç–æ—Ä–æ–º –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ç–∏–ø <code>String</code> –≤–º–µ—Å—Ç–æ —Å—Ç—Ä–æ–∫–æ–≤–æ–≥–æ –ª–∏—Ç–µ—Ä–∞–ª–∞:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    {
        let s = String::from("hello"); // –æ—Ç—Å—é–¥–∞ –∏ –¥–∞–ª–µ–µ s –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞

        // –∑–¥–µ—Å—å –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å s
    }                                  // –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∑–∞–∫–æ–Ω—á–∏–ª–∞—Å—å,
                                       // –∏ s –±–æ–ª—å—à–µ –Ω–µ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞
<span class="boring">}</span></code></pre></pre>
<p>–°—É—â–µ—Å—Ç–≤—É–µ—Ç –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç, –∫–æ–≥–¥–∞ –º—ã –º–æ–∂–µ–º –≤–µ—Ä–Ω—É—Ç—å –ø–∞–º—è—Ç—å, –Ω–µ–æ–±—Ö–æ–¥–∏–º—É—é –Ω–∞—à–µ–π <code>String</code>, –æ–±—Ä–∞—Ç–Ω–æ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–∏—Ç–µ–ª—é ‚Äî –∫–æ–≥–¥–∞ <code>s</code> –≤—ã—Ö–æ–¥–∏—Ç –∑–∞ –ø—Ä–µ–¥–µ–ª—ã –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏. –ö–æ–≥–¥–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –≤—ã—Ö–æ–¥–∏—Ç –∑–∞ –ø—Ä–µ–¥–µ–ª—ã –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏, Rust –≤—ã–∑—ã–≤–∞–µ—Ç –¥–ª—è –Ω–∞—Å —Å–ø–µ—Ü–∏–∞–ª—å–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é. –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop"><code>drop</code></a><!-- ignore -->, –∏ –∏–º–µ–Ω–Ω–æ –≤ –Ω–µ–π —Å–æ–∑–¥–∞—Ç–µ–ª—å —Ç–∏–ø–∞ <code>String</code> –º–æ–∂–µ—Ç —Ä–∞–∑–º–µ—Å—Ç–∏—Ç—å –∫–æ–¥ –¥–ª—è –≤–æ–∑–≤—Ä–∞—Ç–∞ –ø–∞–º—è—Ç–∏. Rust –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤—ã–∑—ã–≤–∞–µ—Ç <code>drop</code> –ø–æ—Å–ª–µ –∑–∞–∫—Ä—ã–≤–∞—é—â–µ–π —Ñ–∏–≥—É—Ä–Ω–æ–π —Å–∫–æ–±–∫–∏.</p>
<blockquote>
<p>–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: –í C++ —ç—Ç–æ—Ç —à–∞–±–ª–æ–Ω –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏—è —Ä–µ—Å—É—Ä—Å–æ–≤ –≤ –∫–æ–Ω—Ü–µ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏ –¥–∞–Ω–Ω—ã—Ö –∏–Ω–æ–≥–¥–∞ –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è <em>"–ü–æ–ª—É—á–µ–Ω–∏–µ —Ä–µ—Å—É—Ä—Å–∞ –µ—Å—Ç—å –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è"</em> (Resource Acquisition Is Initialization ‚Äî RAII). –§—É–Ω–∫—Ü–∏—è <code>drop</code> –≤ Rust –ø–æ–∫–∞–∂–µ—Ç—Å—è –≤–∞–º –∑–Ω–∞–∫–æ–º–æ–π, –µ—Å–ª–∏ –≤—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ —à–∞–±–ª–æ–Ω—ã RAII.</p>
</blockquote>
<p>–≠—Ç–æ—Ç —à–∞–±–ª–æ–Ω –æ–∫–∞–∑—ã–≤–∞–µ—Ç –≥–ª—É–±–æ–∫–æ–µ –≤–ª–∏—è–Ω–∏–µ –Ω–∞ —Å–ø–æ—Å–æ–± –Ω–∞–ø–∏—Å–∞–Ω–∏—è –∫–æ–¥–∞ –≤ Rust. –°–µ–π—á–∞—Å —ç—Ç–æ –≤—Å—ë –º–æ–∂–µ—Ç –∫–∞–∑–∞—Ç—å—Å—è –ø—Ä–æ—Å—Ç—ã–º, –Ω–æ –≤ –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω—ã—Ö —Å–ª—É—á–∞—è—Ö –ø–æ–≤–µ–¥–µ–Ω–∏–µ –∫–æ–¥–∞ –º–æ–∂–µ—Ç –æ–∫–∞–∑–∞—Ç—å—Å—è –Ω–µ–æ–∂–∏–¥–∞–Ω–Ω—ã–º: –Ω–∞–ø—Ä–∏–º–µ—Ä, –∫–æ–≥–¥–∞ —Ö–æ—á–µ—Ç—Å—è –∏–º–µ—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö, –∏—Å–ø–æ–ª—å–∑—É—é—â–∏—Ö –¥–∞–Ω–Ω—ã–µ, –≤—ã–¥–µ–ª–µ–Ω–Ω—ã–µ –≤ –∫—É—á–µ. –ò–∑—É—á–∏–º –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ç–∞–∫–∏—Ö —Å–∏—Ç—É–∞—Ü–∏–π.</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="ways-variables-and-data-interact-move"></a></p>
<h4 id="–í–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ-–ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö-–∏-–¥–∞–Ω–Ω—ã—Ö-—Å-–ø–æ–º–æ—â—å—é-–ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è"><a class="header" href="#–í–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ-–ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö-–∏-–¥–∞–Ω–Ω—ã—Ö-—Å-–ø–æ–º–æ—â—å—é-–ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è">–í–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –∏ –¥–∞–Ω–Ω—ã—Ö —Å –ø–æ–º–æ—â—å—é –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è</a></h4>
<p>–í Rust, –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –º–æ–≥—É—Ç –ø–æ-—Ä–∞–∑–Ω–æ–º—É –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–æ–≤–∞—Ç—å —Å –æ–¥–Ω–∏–º–∏ –∏ —Ç–µ–º–∏ –∂–µ –¥–∞–Ω–Ω—ã–º–∏. –î–∞–≤–∞–π—Ç–µ —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º –æ–¥–∏–Ω –ø—Ä–∏–º–µ—Ä —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ:</p>
<Listing number="4-2" caption="Assigning the integer value of variable `x` to `y`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>–ú—ã –º–æ–∂–µ–º –¥–æ–≥–∞–¥–∞—Ç—å—Å—è, —á—Ç–æ –¥–µ–ª–∞–µ—Ç —ç—Ç–æ—Ç –∫–æ–¥: "–ø—Ä–∏–≤—è–∂–∏ –∑–Ω–∞—á–µ–Ω–∏–µ <code>5</code> –∫ <code>x</code>; –∑–∞—Ç–µ–º —Å–¥–µ–ª–∞–π –∫–æ–ø–∏—é –∑–Ω–∞—á–µ–Ω–∏—è –≤ <code>x</code> –∏ –ø—Ä–∏–≤—è–∂–∏ –µ–≥–æ –∫ <code>y</code>". –¢–µ–ø–µ—Ä—å —É –Ω–∞—Å –µ—Å—Ç—å –¥–≤–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ: <code>x</code> –∏ <code>y</code>, –∏ –æ–±–µ —Ä–∞–≤–Ω—ã <code>5</code>. –ò–º–µ–Ω–Ω–æ —Ç–∞–∫ –≤—Å—ë –∏ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç, –ø–æ—Ç–æ–º—É —á—Ç–æ —Ü–µ–ª—ã–µ —á–∏—Å–ª–∞ ‚Äî —ç—Ç–æ –ø—Ä–æ—Å—Ç—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è —Å –∏–∑–≤–µ—Å—Ç–Ω—ã–º —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–º —Ä–∞–∑–º–µ—Ä–æ–º, —Ç–∞–∫ —á—Ç–æ —ç—Ç–∏ –¥–≤–∞ –∑–Ω–∞—á–µ–Ω–∏—è <code>5</code> –ø–æ–º–µ—â–∞—é—Ç—Å—è –≤ —Å—Ç–µ–∫.</p>
<p>–¢–µ–ø–µ—Ä—å –ø–æ—Å–º–æ—Ç—Ä–∏–º –Ω–∞ –≤–µ—Ä—Å–∏—é —Å —Ç–∏–ø–æ–º <code>String</code></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");
    let s2 = s1;
<span class="boring">}</span></code></pre></pre>
<p>–í—Å—ë –≤—ã–≥–ª—è–¥–∏—Ç –æ—á–µ–Ω—å –ø–æ—Ö–æ–∂–∏–º, –ø–æ—ç—Ç–æ–º—É –º—ã –º–æ–∂–µ–º –ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏—Ç—å, —á—Ç–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç —Ç–æ –∂–µ —Å–∞–º–æ–µ: –≤—Ç–æ—Ä–∞—è —Å—Ç—Ä–æ–∫–∞ —Å–¥–µ–ª–∞–µ—Ç –∫–æ–ø–∏—é –∑–Ω–∞—á–µ–Ω–∏—è <code>s1</code> –∏ –ø—Ä–∏–≤—è–∂–µ—Ç –µ–≥–æ –∫ <code>s2</code>. –ù–æ —ç—Ç–æ –Ω–µ —Å–æ–≤—Å–µ–º —Ç–∞–∫.</p>
<p>–í–∑–≥–ª—è–Ω–∏—Ç–µ –Ω–∞ –†–∏—Å—É–Ω–æ–∫ 4-1, —á—Ç–æ–±—ã –ø–æ–Ω—è—Ç—å, —á—Ç–æ —Å–æ <code>String</code> –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –ø–æ–¥ –∫–∞–ø–æ—Ç–æ–º. <code>String</code> —Å–æ—Å—Ç–æ–∏—Ç –∏–∑ —Ç—Ä—ë—Ö —á–∞—Å—Ç–µ–π (–ø–æ–∫–∞–∑–∞–Ω—ã —Å–ª–µ–≤–∞): —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –ø–∞–º—è—Ç—å, –≤ –∫–æ—Ç–æ—Ä–æ–π —Ö—Ä–∞–Ω–∏—Ç—Å—è —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Å—Ç—Ä–æ–∫–∏; –¥–ª–∏–Ω–∞; —ë–º–∫–æ—Å—Ç—å. –≠—Ç–∞ –≥—Ä—É–ø–ø–∞ –¥–∞–Ω–Ω—ã—Ö —Ö—Ä–∞–Ω–∏—Ç—Å—è –Ω–∞ —Å—Ç–µ–∫–µ. –°–ø—Ä–∞–≤–∞ ‚Äî –ø–∞–º—è—Ç—å –≤ –∫—É—á–µ, –∫–æ—Ç–æ—Ä–∞—è —Å–æ–¥–µ—Ä–∂–∏—Ç —Å–∞–º —Ç–µ–∫—Å—Ç.</p>
<p><img alt="–î–≤–µ —Ç–∞–±–ª–∏—Ü—ã: –ø–µ—Ä–≤–∞—è —Å–æ–¥–µ—Ä–∂–∏—Ç –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ s1–≤
—Å—Ç–µ–∫–µ, —Å–æ–¥–µ—Ä–∂–∞—â–µ–µ –µ—ë –¥–ª–∏–Ω—É (5), —ë–º–∫–æ—Å—Ç—å (5) –∏ —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –ø–µ—Ä–≤–æ–µ
–∑–Ω–∞—á–µ–Ω–∏–µ –≤–æ –≤—Ç–æ—Ä–æ–π —Ç–∞–±–ª–∏—Ü–µ. –í—Ç–æ—Ä–∞—è —Ç–∞–±–ª–∏—Ü–∞ —Å–æ–¥–µ—Ä–∂–∏—Ç –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ
—Å—Ç—Ä–æ–∫–∏ –≤ –∫—É—á–µ, –±–∞–π—Ç –∑–∞ –±–∞–π—Ç–æ–º." src="img/trpl04-01.svg" class="center"
style="width: 50%;" /></p>
<p><span class="caption">–†–∏—Å—É–Ω–æ–∫ 4-1: –ü—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –≤ –ø–∞–º—è—Ç–∏ –∑–Ω–∞—á–µ–Ω–∏—è —Ç–∏–ø–∞ <code>String</code>, —Å–æ–¥–µ—Ä–∂–∞—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ <code>"hello"</code> –∏ —Å–≤—è–∑–∞–Ω–Ω–æ–µ —Å <code>s1</code></span></p>
<p>–î–ª–∏–Ω–∞ ‚Äî —ç—Ç–æ –æ–±—ä—ë–º –ø–∞–º—è—Ç–∏ –≤ –±–∞–π—Ç–∞—Ö, –∫–æ—Ç–æ—Ä—ã–π –≤ –Ω–∞—Å—Ç–æ—è—â–µ–µ –≤—Ä–µ–º—è –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ <code>String</code>. –Å–º–∫–æ—Å—Ç—å ‚Äî —ç—Ç–æ –æ–±—â–∏–π –æ–±—ä—ë–º –ø–∞–º—è—Ç–∏ –≤ –±–∞–π—Ç–∞—Ö, –∫–æ—Ç–æ—Ä—ã–π <code>String</code> –ø–æ–ª—É—á–∏–ª –æ—Ç —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–∏—Ç–µ–ª—è. –†–∞–∑–Ω–∏—Ü–∞ –º–µ–∂–¥—É –¥–ª–∏–Ω–æ–π –∏ —ë–º–∫–æ—Å—Ç—å—é –∏–º–µ–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ, –Ω–æ –Ω–µ –≤ —ç—Ç–æ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ, –ø–æ—ç—Ç–æ–º—É –Ω–∞ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –º–æ–∂–Ω–æ –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å —ë–º–∫–æ—Å—Ç—å.</p>
<p>–ö–æ–≥–¥–∞ –º—ã –ø—Ä–∏—Å–≤–∞–∏–≤–∞–µ–º <code>s1</code> –∑–Ω–∞—á–µ–Ω–∏—é <code>s2</code>, –¥–∞–Ω–Ω—ã–µ <code>String</code> –∫–æ–ø–∏—Ä—É—é—Ç—Å—è: –ø–æ–¥ —ç—Ç–∏–º –∏–º–µ–µ—Ç—Å—è –≤ –≤–∏–¥—É, —á—Ç–æ –º—ã –∫–æ–ø–∏—Ä—É–µ–º —É–∫–∞–∑–∞—Ç–µ–ª—å, –¥–ª–∏–Ω—É –∏ —ë–º–∫–æ—Å—Ç—å, –∫–æ—Ç–æ—Ä—ã–µ –Ω–∞—Ö–æ–¥—è—Ç—Å—è –≤ —Å—Ç–µ–∫–µ. –ú—ã –Ω–µ –∫–æ–ø–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ –≤ –∫—É—á–µ, –Ω–∞ –∫–æ—Ç–æ—Ä—ã–µ —É–∫–∞–∑—ã–≤–∞–µ—Ç —É–∫–∞–∑–∞—Ç–µ–ª—å. –ò–Ω—ã–º–∏ —Å–ª–æ–≤–∞–º–∏, –≤–∏–¥ –¥–∞–Ω–Ω—ã—Ö –≤ –ø–∞–º—è—Ç–∏ –≤—ã–≥–ª—è–¥–∏—Ç —Ç–∞–∫, –∫–∞–∫ –ø–æ–∫–∞–∑–∞–Ω–æ –Ω–∞ –†–∏—Å—É–Ω–∫–µ 4-2.</p>
<p><img alt="–¢—Ä–∏ —Ç–∞–±–ª–∏—Ü—ã: —Ç–∞–±–ª–∏—Ü—ã s1 –∏ s2 –ø—Ä–µ–¥—Å—Ç–∞–ª—è—é—Ç —ç—Ç–∏ —Å—Ç—Ä–æ–∫–∏ –Ω–∞
—Å—Ç–µ–∫–µ, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ, –∏ –æ–±–µ —É–∫–∞–∑—ã–≤–∞—é—Ç –Ω–∞ –æ–¥–∏–Ω –∏ —Ç–æ—Ç –∂–µ —Ç–µ–∫—Å—Ç –≤ –∫—É—á–µ."
src="img/trpl04-02.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">–†–∏—Å—É–Ω–æ–∫ 4-2: –í–∏–¥ –ø–∞–º—è—Ç–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π <code>s2</code>, –∏–º–µ—é—â–µ–π –∫–æ–ø–∏—é —É–∫–∞–∑–∞—Ç–µ–ª—è, –¥–ª–∏–Ω—ã –∏ —ë–º–∫–æ—Å—Ç–∏ <code>s1</code></span></p>
<p>–í–∏–¥ –ø–∞–º—è—Ç–∏ <em>–Ω–µ</em> –±—É–¥–µ—Ç –ø–æ—Ö–æ–∂ –Ω–∞ –†–∏—Å—É–Ω–æ–∫ 4-3: —Ç–∞–∫ –≤—ã–≥–ª—è–¥–µ–ª–∞ –±—ã –ø–∞–º—è—Ç—å, –µ—Å–ª–∏ –±—ã –≤–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ Rust —Ç–∞–∫–∂–µ –∫–æ–ø–∏—Ä–æ–≤–∞–ª –¥–∞–Ω–Ω—ã–µ –∫—É—á–∏. –ï—Å–ª–∏ –±—ã Rust –¥–µ–ª–∞–ª —ç—Ç–æ, –æ–ø–µ—Ä–∞—Ü–∏—è <code>s2 = s1</code> –º–æ–≥–ª–∞ –±—ã –±—ã—Ç—å –æ—á–µ–Ω—å –¥–æ—Ä–æ–≥–æ–π —Å —Ç–æ—á–∫–∏ –∑—Ä–µ–Ω–∏—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è, –µ—Å–ª–∏ –±—ã –∫–æ–ø–∏—Ä—É–µ–º—ã–µ –¥–∞–Ω–Ω—ã–µ –≤ –∫—É—á–µ –±—ã–ª–∏ –±–æ–ª—å—à–∏–º–∏.</p>
<p><img alt="–ß–µ—Ç—ã—Ä–µ —Ç–∞–±–ª–∏—Ü—ã: –¥–≤–µ —Ç–∞–±–ª–∏—Ü—ã –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—Ç –¥–∞–Ω–Ω—ã–µ s1 –∏ s2 –Ω–∞ —Å—Ç–µ–∫–µ,
–∏ –∫–∞–∂–¥–∞—è —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—É—é –∫–æ–ø–∏—é —Ç–µ–∫—Å—Ç–∞ –≤ –∫—É—á–µ."
src="img/trpl04-03.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">–†–∏—Å—É–Ω–æ–∫ 4-3: –î—Ä—É–≥–æ–π –≤–∞—Ä–∏–∞–Ω—Ç —Ç–æ–≥–æ, —á—Ç–æ –º–æ–≥–ª–∞ –±—ã –¥–µ–ª–∞—Ç—å –æ–ø–µ—Ä–∞—Ü–∏—è<code>s2 = s1</code>, –µ—Å–ª–∏ –±—ã Rust —Ç–∞–∫–∂–µ –∫–æ–ø–∏—Ä–æ–≤–∞–ª –¥–∞–Ω–Ω—ã–µ –∫—É—á–∏</span></p>
<p>–†–∞–Ω–µ–µ –º—ã —Å–∫–∞–∑–∞–ª–∏, —á—Ç–æ –∫–æ–≥–¥–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –≤—ã—Ö–æ–¥–∏—Ç –∑–∞ –ø—Ä–µ–¥–µ–ª—ã –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏, Rust –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤—ã–∑—ã–≤–∞–µ—Ç —Ñ—É–Ω–∫—Ü–∏—é <code>drop</code> –∏ –æ—á–∏—â–∞–µ—Ç –ø–∞–º—è—Ç—å –¥–∞–Ω–Ω–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π, –≤—ã–¥–µ–ª–µ–Ω–Ω—É—é –≤ –∫—É—á–µ. –ù–æ –Ω–∞ –†–∏—Å—É–Ω–∫–µ 4-2 –æ–±–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è –¥–∞–Ω–Ω—ã—Ö —É–∫–∞–∑—ã–≤–∞—é—Ç –Ω–∞ –æ–¥–Ω–æ –∏ —Ç–æ –∂–µ –º–µ—Å—Ç–æ. –≠—Ç–æ –ø—Ä–æ–±–ª–µ–º–∞: –∫–æ–≥–¥–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ <code>s2</code> –∏ <code>s1</code> –±—É–¥—É—Ç –≤—ã—Ö–æ–¥–∏—Ç—å –∏–∑ –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏, –æ–Ω–∏ –æ–±–µ –±—É–¥—É—Ç –ø—ã—Ç–∞—Ç—å—Å—è –æ—Å–≤–æ–±–æ–¥–∏—Ç—å –æ–¥–Ω—É –∏ —Ç—É –∂–µ –ø–∞–º—è—Ç—å. –≠—Ç–æ –∏–∑–≤–µ—Å—Ç–Ω–æ –∫–∞–∫ –æ—à–∏–±–∫–∞ <em>–¥–≤–æ–π–Ω–æ–≥–æ –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏—è</em> ‚Äî  –æ–Ω–∞ —è–≤–ª—è–µ—Ç—Å—è –æ–¥–Ω–æ–π –∏–∑ –æ—à–∏–±–æ–∫ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –ø–∞–º—è—Ç–∏, —É–ø–æ–º–∏–Ω–∞–µ–º—ã—Ö —Ä–∞–Ω–µ–µ. –ü–æ–≤—Ç–æ—Ä–Ω–æ–µ —Å–≤–æ–±–æ–∂–¥–µ–Ω–∏–µ –ø–∞–º—è—Ç–∏ –º–æ–∂–µ—Ç –ø—Ä–∏–≤–µ—Å—Ç–∏ –∫ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω–∏—é –ø–∞–º—è—Ç–∏, —á—Ç–æ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ –º–æ–∂–µ—Ç –ø—Ä–∏–≤–µ—Å—Ç–∏ –∫ —É—è–∑–≤–∏–º–æ—Å—Ç—è–º.</p>
<p>–ß—Ç–æ–±—ã –æ–±–µ—Å–ø–µ—á–∏—Ç—å –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –ø–∞–º—è—Ç–∏, –ø–æ—Å–ª–µ —Å—Ç—Ä–æ–∫–∏ <code>let s2 = s1;</code> Rust —Å—á–∏—Ç–∞–µ—Ç <code>s1</code> –±–æ–ª–µ–µ –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–π. –°–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ, Rust –Ω–µ –Ω—É–∂–Ω–æ –Ω–∏—á–µ–≥–æ –æ—Å–≤–æ–±–æ–∂–¥–∞—Ç—å, –∫–æ–≥–¥–∞ <code>s1</code> –≤—ã—Ö–æ–¥–∏—Ç –∏–∑ –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏. –ü–æ—Å–º–æ—Ç—Ä–∏—Ç–µ, —á—Ç–æ –ø—Ä–æ–∏–∑–æ–π–¥—ë—Ç, –µ—Å–ª–∏ –≤—ã –ø–æ–ø—ã—Ç–∞–µ—Ç–µ—Å—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å <code>s1</code> –ø–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è <code>s2</code>:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");
    let s2 = s1;

    println!("{s1}, world!");
<span class="boring">}</span></code></pre>
<p>–í—ã –ø–æ–ª—É—á–∏—Ç–µ –æ—à–∏–±–∫—É –∫–∞–∫ —Ç—É, —á—Ç–æ –Ω–∏–∂–µ, –ø–æ—Å–∫–æ–ª—å–∫—É Rust –Ω–µ –ø–æ–∑–≤–æ–ª–∏—Ç –≤–∞–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—É—é —Å—Å—ã–ª–∫—É:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --&gt; src/main.rs:5:15
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |
5 |     println!("{s1}, world!");
  |               ^^^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider cloning the value if the performance cost is acceptable
  |
3 |     let s2 = s1.clone();
  |                ++++++++

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>–ï—Å–ª–∏ –≤—ã —Å–ª—ã—à–∞–ª–∏ –ø—Ä–æ —Ç–µ—Ä–º–∏–Ω—ã <em>–ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–Ω–æ–µ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ</em> –∏ <em>–≥–ª—É–±–æ–∫–æ–µ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ</em>, –µ—Å–ª–∏ —Ä–∞–±–æ—Ç–∞–ª–∏ —Å –¥—Ä—É–≥–∏–º–∏ —è–∑—ã–∫–∞–º–∏, –∫–æ–Ω—Ü–µ–ø—Ü–∏—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è —É–∫–∞–∑–∞—Ç–µ–ª—è, –¥–ª–∏–Ω—ã –∏ —ë–º–∫–æ—Å—Ç–∏ –±–µ–∑ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö, –≤–µ—Ä–æ—è—Ç–Ω–æ, –∑–≤—É—á–∏—Ç –∫–∞–∫ —Å–æ–∑–¥–∞–Ω–∏–µ –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–Ω–æ–π –∫–æ–ø–∏–∏. –ù–æ –ø–æ—Å–∫–æ–ª—å–∫—É Rust —Ç–∞–∫–∂–µ –¥–µ–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç –ø–µ—Ä–≤—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é, —ç—Ç–æ –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è –Ω–µ –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–Ω—ã–º –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ–º, –∞ <em>–ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ–º</em>. –í –ø—Ä–∏–º–µ—Ä–µ –≤—ã—à–µ –º—ã –±—ã —Å–∫–∞–∑–∞–ª–∏, —á—Ç–æ <code>s1</code> –±—ã–ª–∞ –ø–µ—Ä–µ–º–µ—â—ë–Ω –≤ <code>s2</code>. –í –∫–æ–Ω–µ—á–Ω–æ–º —Å—á—ë—Ç–µ, –∏—Å—Ç–∏–Ω–Ω–∞—è –∫–∞—Ä—Ç–∏–Ω–∞ –ø—Ä–æ–∏—Å—Ö–æ–¥—è—â–µ–≥–æ –ø–æ–∫–∞–∑–∞–Ω–∞ –Ω–∞ –†–∏—Å—É–Ω–∫–µ 4-4.</p>
<p><img alt="–¢—Ä–∏ —Ç–∞–±–ª–∏—Ü—ã: —Ç–∞–±–ª–∏—Ü—ã s1 –∏ s2 –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—Ç —ç—Ç–∏ —Å—Ç—Ä–æ–∫–∏ –Ω–∞
—Å—Ç–µ–∫–µ, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ, –∏ –æ–±–µ —É–∫–∞–∑—ã–≤–∞—é—Ç –Ω–∞ –æ–¥–∏–Ω –∏ —Ç–æ—Ç –∂–µ —Ç–µ–∫—Å—Ç –≤ –∫—É—á–µ.
–¢–∞–±–ª–∏—Ü–∞ s1 —Å–µ—Ä–∞—è, –ø–æ-—Å–∫–æ–ª—å–∫—É s1 –±–æ–ª—å—à–µ –Ω–µ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞; –ª–∏—à—å s2 –º–æ–∂–µ—Ç –±—ã—Ç—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∞ –¥–ª—è
–æ–±—Ä–∞—â–µ–Ω–∏—è –∫ –¥–∞–Ω–Ω—ã–º –≤ –∫—É—á–µ." src="img/trpl04-04.svg" class="center" style="width:
50%;" /></p>
<p><span class="caption">–†–∏—Å—É–Ω–æ–∫ 4-4: –í–∏–¥ –ø–∞–º—è—Ç–∏ –ø–æ—Å–ª–µ —Ç–æ–≥–æ, –∫–∞–∫ <code>s1</code> –±—ã–ª–∞ –¥–µ–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞</span></p>
<p>–≠—Ç–æ —Ä–µ—à–∞–µ—Ç –Ω–∞—à—É –ø—Ä–æ–±–ª–µ–º—É! –î–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ–π –æ—Å—Ç–∞—ë—Ç—Å—è —Ç–æ–ª—å–∫–æ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è <code>s2</code>. –ö–æ–≥–¥–∞ –æ–Ω–∞ –ø–æ–∫–∏–Ω–µ—Ç –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏, —Ç–æ –ª–∏—à—å –æ–Ω–∞ –æ–¥–Ω–∞ –±—É–¥–µ—Ç –æ—Å–≤–æ–±–æ–∂–¥–∞—Ç—å –ø–∞–º—è—Ç—å –≤ –∫—É—á–µ.</p>
<p>–≠—Ç–æ—Ç –ø–æ—Ä—è–¥–æ–∫ —Ä–∞–±–æ—Ç—ã —Å –ø–∞–º—è—Ç—å—é –¥–∞—ë—Ç –µ—â—ë –æ–¥–Ω–æ –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–æ: Rust –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –±—É–¥–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ–∑–¥–∞–≤–∞—Ç—å "–≥–ª—É–±–æ–∫–∏–µ" –∫–æ–ø–∏–∏ –≤–∞—à–∏—Ö –¥–∞–Ω–Ω—ã—Ö. –°–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ, –ª—é–±–æ–µ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ, —Å–≤—è–∑–∞–Ω–Ω–æ–µ –∏ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ–º, –º–æ–∂–Ω–æ —Å—á–∏—Ç–∞—Ç—å –Ω–µ–¥–æ—Ä–æ–≥–∏–º —Å —Ç–æ—á–∫–∏ –∑—Ä–µ–Ω–∏—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏.</p>
<h4 id="–û–±–ª–∞—Å—Ç—å-–≤–∏–¥–∏–º–æ—Å—Ç–∏-–∏-–ø—Ä–∏—Å–≤–æ–µ–Ω–∏–µ"><a class="header" href="#–û–±–ª–∞—Å—Ç—å-–≤–∏–¥–∏–º–æ—Å—Ç–∏-–∏-–ø—Ä–∏—Å–≤–æ–µ–Ω–∏–µ">–û–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∏ –ø—Ä–∏—Å–≤–æ–µ–Ω–∏–µ</a></h4>
<p>The inverse of this is true for the relationship between scoping, ownership, and memory being freed via the <code>drop</code> function as well. When you assign a completely new value to an existing variable, Rust will call <code>drop</code> and free the original value‚Äôs memory immediately. Consider this code, for example:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");
    s = String::from("ahoy");

    println!("{s}, world!");
<span class="boring">}</span></code></pre></pre>
<p>–°–Ω–∞—á–∞–ª–∞ –º—ã –æ–±—ä—è–≤–ª—è–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é <code>s</code> –∏ —Å–≤—è–∑—ã–≤–∞–µ–º –µ—ë —Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º <code>"hello"</code> —Ç–∏–ø–∞ <code>String</code>. –ó–∞—Ç–µ–º –º—ã –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é —Å—Ç—Ä–æ–∫—É —Ç–∏–ø–∞ <code>String</code> —Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º <code>"ahoy"</code> –∏ –ø—Ä–∏—Å–≤–∞–∏–≤–∞–µ–º –µ—ë –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π <code>s</code>. –ü–æ—Å–ª–µ —ç—Ç–æ–≥–æ –Ω–∏—á—Ç–æ –±–æ–ª—å—à–µ –Ω–µ —Å—Å—ã–ª–∞–µ—Ç—Å—è –Ω–∞ –∏–∑–Ω–∞—á–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –≤ –∫—É—á–µ.</p>
<p><img alt="–û–¥–Ω–∞ —Ç–∞–±–ª–∏—Ü–∞, s, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç –¥–∞–Ω–Ω—ã–µ —Å—Ç—Ä–æ–∫–∏ –Ω–∞ —Å—Ç–µ–∫–µ, —É–∫–∞–∑—ã–≤–∞—é—â–∏–µ –Ω–∞
–≤—Ç–æ—Ä—É—é —á–∞—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö —Å—Ç—Ä–æ–∫–∏ (‚Äúahoy‚Äù) –≤ –∫—É—á–µ, –≤–º–µ—Å—Ç–µ —Å –∏–∑–Ω–∞—á–∞–ª—å–Ω—ã–º —Ç–µ–∫—Å—Ç–æ–º
—Å—Ç—Ä–æ–∫–∏ (‚Äúhello‚Äù) –≤—ã–∫—Ä–∞—à–µ–Ω–Ω—ã–º–∏ –≤ —Å–µ—Ä—ã–π, –ø–æ—Å–∫–æ–ª—å–∫—É –æ–Ω –±–æ–ª—å—à–µ –Ω–∏–∫–æ–º—É –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω."
src="img/trpl04-05.svg"
class="center"
style="width: 50%;"
/></p>
<p><span class="caption">–†–∏—Å—É–Ω–æ–∫ 4-5: –í–∏–¥ –ø–∞–º—è—Ç–∏ –ø–æ—Å–ª–µ —Ç–æ–≥–æ, –∫–∞–∫ –Ω–∞—á–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –±—ã–ª–æ –ø–æ–ª–Ω–æ—Å—Ç—å—é –∑–∞–º–µ–Ω–µ–Ω–æ, –≤—ã—Ç–µ—Å–Ω–µ–Ω–æ –Ω–æ–≤—ã–º.</span></p>
<p>–û—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–∞—è —Å—Ç—Ä–æ–∫–∞, –≤ —Å–≤—è–∑–∏ —Å —ç—Ç–∏–º, –≤ —ç—Ç–æ—Ç –∂–µ –º–æ–º–µ–Ω—Ç –ø–æ–∫–∏–Ω—É–ª–∞ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏. Rust –≤—ã–∑–æ–≤–µ—Ç –Ω–∞ –Ω–µ–π —Ñ—É–Ω–∫—Ü–∏—é <code>drop</code> –∏ –≤—ã—Å–≤–æ–±–æ–¥–∏—Ç –µ—ë –ø–∞–º—è—Ç—å. –ö–æ–≥–¥–∞ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ –¥–æ–π–¥—ë—Ç –¥–æ —Å—Ç—Ä–æ—á–∫–∏ –ø–µ—á–∞—Ç–∏, –±—É–¥–µ—Ç –≤—ã–≤–µ–¥–µ–Ω–æ <code>"ahoy, world!"</code>.</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="ways-variables-and-data-interact-clone"></a></p>
<h4 id="–í–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ-–ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö-–∏-–¥–∞–Ω–Ω—ã—Ö-—Å-–ø–æ–º–æ—â—å—é-–∫–ª–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è"><a class="header" href="#–í–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ-–ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö-–∏-–¥–∞–Ω–Ω—ã—Ö-—Å-–ø–æ–º–æ—â—å—é-–∫–ª–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è">–í–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –∏ –¥–∞–Ω–Ω—ã—Ö —Å –ø–æ–º–æ—â—å—é –∫–ª–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è</a></h4>
<p>–ï—Å–ª–∏ –º—ã –≤—Å—ë –∂–µ <em>—Ö–æ—Ç–∏–º</em> –≥–ª—É–±–æ–∫–æ —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –¥–∞–Ω–Ω—ã–µ <code>String</code> –≤ –∫—É—á–µ, –∞ –Ω–µ —Ç–æ–ª—å–∫–æ —Å—Ç–µ–∫–∞, –º—ã –º–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —á–∞—Å—Ç–æ —Ä–µ–∞–ª–∏–∑—É–µ–º—ã–π –º–µ—Ç–æ–¥, –Ω–∞–∑—ã–≤–∞–µ–º—ã–π <code>clone</code>. –ú—ã –æ–±—Å—É–¥–∏–º —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –º–µ—Ç–æ–¥–∞ –≤ –ì–ª–∞–≤–µ 5, –Ω–æ –ø–æ—Å–∫–æ–ª—å–∫—É –º–µ—Ç–æ–¥—ã —è–≤–ª—è—é—Ç—Å—è –æ–±—â–µ–π —á–µ—Ä—Ç–æ–π –º–Ω–æ–≥–∏—Ö —è–∑—ã–∫–æ–≤ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è, –≤—ã, –≤–µ—Ä–æ—è—Ç–Ω–æ, —É–∂–µ –∑–Ω–∞–∫–æ–º—ã —Å –Ω–∏–º–∏.</p>
<p>–í–æ—Ç –ø—Ä–∏–º–µ—Ä —Ä–∞–±–æ—Ç—ã –º–µ—Ç–æ–¥–∞ <code>clone</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {s1}, s2 = {s2}");
<span class="boring">}</span></code></pre></pre>
<p>–≠—Ç–æ –æ—Ç–ª–∏—á–Ω–æ —Ä–∞–±–æ—Ç–∞–µ—Ç –∏, –æ—á–µ–≤–∏–¥–Ω–æ, –ø—Ä–∏–≤–æ–¥–∏—Ç –∫ –ø–æ–≤–µ–¥–µ–Ω–∏—é, –ø–æ–∫–∞–∑–∞–Ω–Ω–æ–º—É –Ω–∞ –†–∏—Å—É–Ω–∫–µ 4-3, –≥–¥–µ –¥–∞–Ω–Ω—ã–µ –∫—É—á–∏ <em>–±—ã–ª–∏</em> —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω—ã.</p>
<p>–ï—Å–ª–∏ –≤—ã –≤–∏–¥–∏—Ç–µ –≤—ã–∑–æ–≤ <code>clone</code>, –≤—ã —Å—Ä–∞–∑—É –º–æ–∂–µ—Ç–µ –ø–æ–Ω—è—Ç—å, —á—Ç–æ –∏—Å–ø–æ–ª–Ω—è–µ–º—ã–π –∑–¥–µ—Å—å –Ω–µ–∫–æ—Ç–æ—Ä—ã–π –∫–æ–¥ –Ω–∞–≤–µ—Ä–Ω—è–∫–∞ –±—É–¥–µ—Ç –∑–∞—Ç—Ä–∞—Ç–Ω—ã–º. –í —Ç–æ –∂–µ –≤—Ä–µ–º—è, –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ <code>clone</code> —è–≤–ª—è–µ—Ç—Å—è –º–∞—Ä–∫–µ—Ä–æ–º —Ç–æ–≥–æ, —á—Ç–æ —Ç—É—Ç –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç —á—Ç–æ-—Ç–æ –Ω–µ–æ–±—ã—á–Ω–æ–µ.</p>
<h4 id="–î–∞–Ω–Ω—ã–µ-—Ä–∞–∑–º–µ—â–∞—é—â–∏–µ—Å—è-—Ç–æ–ª—å–∫–æ-–Ω–∞-—Å—Ç–µ–∫–µ-–≤—Å–µ–≥–¥–∞-–∫–æ–ø–∏—Ä—É—é—Ç—Å—è"><a class="header" href="#–î–∞–Ω–Ω—ã–µ-—Ä–∞–∑–º–µ—â–∞—é—â–∏–µ—Å—è-—Ç–æ–ª—å–∫–æ-–Ω–∞-—Å—Ç–µ–∫–µ-–≤—Å–µ–≥–¥–∞-–∫–æ–ø–∏—Ä—É—é—Ç—Å—è">–î–∞–Ω–Ω—ã–µ, —Ä–∞–∑–º–µ—â–∞—é—â–∏–µ—Å—è —Ç–æ–ª—å–∫–æ –Ω–∞ —Å—Ç–µ–∫–µ, –≤—Å–µ–≥–¥–∞ –∫–æ–ø–∏—Ä—É—é—Ç—Å—è</a></h4>
<p>–≠—Ç–æ –µ—â—ë –æ–¥–Ω–∞ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç—å, –æ –∫–æ—Ç–æ—Ä–æ–π –º—ã —Ä–∞–Ω–µ–µ –Ω–µ –≥–æ–≤–æ—Ä–∏–ª–∏. –≠—Ç–æ—Ç –∫–æ–¥, —á–∞—Å—Ç—å –∫–æ—Ç–æ—Ä–æ–≥–æ –º—ã —Ä–∞–Ω–µ–µ –ø–æ–∫–∞–∑–∞–ª–∏ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 4-2, –ø–æ–ª–Ω–æ—Å—Ç—å—é –∫–æ—Ä—Ä–µ–∫—Ç–µ–Ω:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;

    println!("x = {x}, y = {y}");
<span class="boring">}</span></code></pre></pre>
<p>–ù–æ –≤ —Ç–æ –∂–µ –≤—Ä–µ–º—è —ç—Ç–æ—Ç –∫–æ–¥, –∫–∞–∂–µ—Ç—Å—è, –ø—Ä–æ—Ç–∏–≤–æ—Ä–µ—á–∏—Ç —Ç–æ–º—É, —á—Ç–æ –º—ã —Ç–æ–ª—å–∫–æ —á—Ç–æ —É–∑–Ω–∞–ª–∏: –º—ã –Ω–µ –≤—ã–∑—ã–≤–∞–µ–º <code>clone</code>, –Ω–æ <code>x</code> –æ—Å—Ç–∞—ë—Ç—Å—è –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞ –∏ –µ—ë –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–µ –ø–µ—Ä–µ–º–µ—â–∞–µ—Ç—Å—è –≤ <code>y</code>.</p>
<p>–ü—Ä–∏—á–∏–Ω–∞ –≤ —Ç–æ–º, —á—Ç–æ —Ç–∞–∫–∏–µ —Ç–∏–ø—ã, –∫–∞–∫ —Ü–µ–ª—ã–µ —á–∏—Å–ª–∞, —Ä–∞–∑–º–µ—Ä –∫–æ—Ç–æ—Ä—ã—Ö –∏–∑–≤–µ—Å—Ç–µ–Ω –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏, –ø–æ–ª–Ω–æ—Å—Ç—å—é —Ö—Ä–∞–Ω—è—Ç—Å—è –Ω–∞ —Å—Ç–µ–∫–µ, –ø–æ—ç—Ç–æ–º—É –∫–æ–ø–∏–∏ —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π —Å–æ–∑–¥–∞—é—Ç—Å—è –±—ã—Å—Ç—Ä–æ. –≠—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –Ω–µ—Ç –ø—Ä–∏—á–∏–Ω, –ø–æ –∫–æ—Ç–æ—Ä—ã–º –º—ã —Ö–æ—Ç–µ–ª–∏ –±—ã –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—Ç–∏—Ç—å –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å <code>x</code> –ø–æ—Å–ª–µ —Ç–æ–≥–æ, –∫–∞–∫ —Å–æ–∑–¥–∞–¥–∏–º –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é <code>y</code>. –ò–Ω—ã–º–∏ —Å–ª–æ–≤–∞–º–∏, –¥–ª—è —Ç–∞–∫–∏—Ö —Ç–∏–ø–æ–≤ –Ω–µ—Ç —Ä–∞–∑–Ω–∏—Ü—ã –º–µ–∂–¥—É –≥–ª—É–±–æ–∫–∏–º –∏ –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–Ω—ã–º –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ–º, –ø–æ—ç—Ç–æ–º—É –≤—ã–∑–æ–≤ <code>clone</code> –Ω–∏—á–µ–º –Ω–µ –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è –æ—Ç –æ–±—ã—á–Ω–æ–≥–æ –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–Ω–æ–≥–æ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è, –∏ –º—ã –º–æ–∂–µ–º –µ–≥–æ –æ–ø—É—Å—Ç–∏—Ç—å.</p>
<p>–í Rust –µ—Å—Ç—å —Å–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –∞–Ω–Ω–æ—Ç–∞—Ü–∏—è, –Ω–∞–∑—ã–≤–∞–µ–º–∞—è —Ç—Ä–µ–π—Ç–æ–º <code>Copy</code>, –∫–æ—Ç–æ—Ä—É—é –º—ã –º–æ–∂–µ–º –ø—Ä–∏–ø–∏—Å—ã–≤–∞—Ç—å —Ç–∏–ø–∞–º, —Ö—Ä–∞–Ω—è—â–∏–º—Å—è –Ω–∞ —Å—Ç–µ–∫–µ: –∫–∞–∫ —ç—Ç–æ —Å–¥–µ–ª–∞–Ω–æ –¥–ª—è —Ü–µ–ª—ã—Ö —á–∏—Å–µ–ª (–ø–æ–¥—Ä–æ–±–Ω–µ–µ –æ —Ç—Ä–µ–π—Ç–∞—Ö –º—ã –ø–æ–≥–æ–≤–æ—Ä–∏–º –≤ <a href="ch10-02-traits.html">–ì–ª–∞–≤–µ 10</a><!-- ignore -->). –ï—Å–ª–∏ —Ç–∏–ø —Ä–µ–∞–ª–∏–∑—É–µ—Ç —Ç—Ä–µ–π—Ç <code>Copy</code>, –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ, –∫ –Ω–µ–º—É –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∞—â–∏–µ, –Ω–µ –ø–µ—Ä–µ–º–µ—â–∞—é—Ç—Å—è –ø—Ä–∏ –ø—Ä–∏—Å–≤–∞–∏–≤–∞–Ω–∏–∏, –∞ –ø—Ä–æ—Å—Ç–æ –∫–æ–ø–∏—Ä—É—é—Ç—Å—è, —á—Ç–æ –æ—Å—Ç–∞–≤–ª—è–µ—Ç –∏—Ö –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–º–∏ –ø–æ—Å–ª–µ –ø—Ä–∏—Å–≤–æ–µ–Ω–∏—è –¥—Ä—É–≥–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π.</p>
<p>Rust –Ω–µ –ø–æ–∑–≤–æ–ª–∏—Ç –Ω–∞–º –∞–Ω–Ω–æ—Ç–∏—Ä–æ–≤–∞—Ç—å —Ç–∏–ø —Å –ø–æ–º–æ—â—å—é <code>Copy</code>, –µ—Å–ª–∏ —Ç–∏–ø –∏–ª–∏ –ª—é–±–∞—è –∏–∑ –µ–≥–æ —á–∞—Å—Ç–µ–π —Ä–µ–∞–ª–∏–∑—É–µ—Ç —Ç—Ä–µ–π—Ç <code>Drop</code>. –ï—Å–ª–∏ –¥–ª—è —Ç–∏–ø–∞ –Ω—É–∂–Ω–æ, —á—Ç–æ–±—ã –ø—Ä–æ–∏–∑–æ—à–ª–æ —á—Ç–æ-—Ç–æ –æ—Å–æ–±–µ–Ω–Ω–æ–µ, –∫–æ–≥–¥–∞ –∑–Ω–∞—á–µ–Ω–∏–µ –≤—ã—Ö–æ–¥–∏—Ç –∑–∞ –ø—Ä–µ–¥–µ–ª—ã –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏, –∏ –º—ã –¥–æ–±–∞–≤–ª—è–µ–º –∞–Ω–Ω–æ—Ç–∞—Ü–∏—é <code>Copy</code> –∫ —ç—Ç–æ–º—É —Ç–∏–ø—É, –º—ã –ø–æ–ª—É—á–∏–º –æ—à–∏–±–∫—É –∫–æ–º–ø–∏–ª—è—Ü–∏–∏. –ß—Ç–æ–±—ã —É–∑–Ω–∞—Ç—å, –∫–∞–∫ –¥–æ–±–∞–≤–∏—Ç—å –∞–Ω–Ω–æ—Ç–∞—Ü–∏—é <code>Copy</code> –∫ –≤–∞—à–µ–º—É —Ç–∏–ø—É –¥–ª—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ —Ç—Ä–µ–π—Ç–∞, –ø–æ—Å–º–æ—Ç—Ä–∏—Ç–µ —Ä–∞–∑–¥–µ–ª <a href="appendix-03-derivable-traits.html">"–í—ã–≤–æ–¥–∏–º—ã–µ —Ç—Ä–µ–π—Ç—ã"</a><!-- ignore --> –≤ –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ C.</p>
<p>–ö–∞–∫–∏–µ –∂–µ —Ç–∏–ø—ã —Ä–µ–∞–ª–∏–∑—É—é—Ç —Ç—Ä–µ–π—Ç Copy? –ß—Ç–æ–±—ã —É–¥–æ—Å—Ç–æ–≤–µ—Ä–∏—Ç—å—Å—è, –º–æ–∂–Ω–æ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é –∏–Ω—Ç–µ—Ä–µ—Å—É—é—â–µ–≥–æ —Ç–∏–ø–∞, –Ω–æ –∫–∞–∫ –ø—Ä–∞–≤–∏–ª–æ –ª—é–±–∞—è –≥—Ä—É–ø–ø–∞ –ø—Ä–æ—Å—Ç—ã—Ö –æ—Ç–¥–µ–ª—å–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π –º–æ–∂–µ—Ç –±—ã—Ç—å —Ä–µ–∞–ª–∏–∑–æ–≤—ã–≤–∞—Ç—å <code>Copy</code>, –∏ –Ω–∏–∫–∞–∫–∏–µ —Ç–∏–ø—ã, –∫–æ—Ç–æ—Ä—ã–µ —Ç—Ä–µ–±—É—é—Ç –≤—ã–¥–µ–ª–µ–Ω–∏—è –ø–∞–º—è—Ç–∏ –≤ –∫—É—á–µ –∏–ª–∏ —è–≤–ª—è—é—Ç—Å—è –Ω–µ–∫–æ—Ç–æ—Ä–æ–π —Ñ–æ—Ä–º–æ–π —Ä–µ—Å—É—Ä—Å–æ–≤, –Ω–µ —Ä–µ–∞–ª–∏–∑—É—é—Ç —Ç—Ä–µ–π—Ç–∞ <code>Copy</code>. –í–æ—Ç –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ —Ç–∏–ø—ã, –∫–æ—Ç–æ—Ä—ã–µ —Ä–µ–∞–ª–∏–∑—É—é—Ç <code>Copy</code>:</p>
<ul>
<li>–í—Å–µ —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã–µ —Ç–∏–ø—ã, —Ç–∞–∫–∏–µ –∫–∞–∫ <code>u32</code>.</li>
<li>–õ–æ–≥–∏—á–µ—Å–∫–∏–π —Ç–∏–ø –¥–∞–Ω–Ω—ã—Ö <code>bool</code>, –≤–æ–∑–º–æ–∂–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –∫–æ—Ç–æ—Ä–æ–≥–æ ‚Äî <code>true</code> –∏ <code>false</code>.</li>
<li>–í—Å–µ —Ç–∏–ø—ã —á–∏—Å–µ–ª —Å –ø–ª–∞–≤–∞—é—â–µ–π —Ç–æ—á–∫–æ–π, —Ç–∞–∫–∏–µ –∫–∞–∫ <code>f64</code>.</li>
<li>–°–∏–º–≤–æ–ª—å–Ω—ã–π —Ç–∏–ø <code>char</code>.</li>
<li>–ö–æ—Ä—Ç–µ–∂–∏; –Ω–æ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ–Ω–∏ —Å–æ—Å—Ç–æ—è—Ç —Ç–æ–ª—å–∫–æ –∏–∑ —Ç–∏–ø–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ —Ç–∞–∫–∂–µ —Ä–µ–∞–ª–∏–∑—É—é—Ç <code>Copy</code>. –ù–∞–ø—Ä–∏–º–µ—Ä, <code>(i32, i32)</code> —Ä–µ–∞–ª–∏–∑—É–µ—Ç <code>Copy</code>, –Ω–æ –∫–æ—Ä—Ç–µ–∂ <code>(i32, String)</code> ‚Äî –Ω–µ—Ç.</li>
</ul>
<h3 id="–í–ª–∞–¥–µ–Ω–∏–µ-–∏-—Ñ—É–Ω–∫—Ü–∏–∏"><a class="header" href="#–í–ª–∞–¥–µ–Ω–∏–µ-–∏-—Ñ—É–Ω–∫—Ü–∏–∏">–í–ª–∞–¥–µ–Ω–∏–µ –∏ —Ñ—É–Ω–∫—Ü–∏–∏</a></h3>
<p>–ú–µ—Ö–∞–Ω–∏–∑–º –ø–µ—Ä–µ–¥–∞—á–∏ —Ñ—É–Ω–∫—Ü–∏–∏ –∑–Ω–∞—á–µ–Ω–∏—è —Å—Ö–æ–∂ —Å —Ç–µ–º, —á—Ç–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –ø—Ä–∏ –ø—Ä–∏—Å–≤–æ–µ–Ω–∏–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –∑–Ω–∞—á–µ–Ω–∏—è. –ü–µ—Ä–µ–¥–∞—á–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –≤ —Ñ—É–Ω–∫—Ü–∏—é –ø—Ä–∏–≤–µ–¥—ë—Ç –∫ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—é –∏–ª–∏ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—é —Ä–æ–≤–Ω–æ —Ç–∞–∫ –∂–µ, –∫–∞–∫ –ø—Ä–∏ –ø—Ä–∏—Å–≤–∞–∏–≤–∞–Ω–∏–∏. –í –õ–∏—Å—Ç–∏–Ω–≥–µ 4-3 –µ—Å—Ç—å –ø—Ä–∏–º–µ—Ä —Å –Ω–µ–∫–æ—Ç–æ—Ä—ã–º–∏ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è–º–∏, –ø–æ—è—Å–Ω—è—é—â–∏–º–∏, –≥–¥–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –≤—Ö–æ–¥—è—Ç –≤ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∏ –≥–¥–µ –≤—ã—Ö–æ–¥—è—Ç –∏–∑ –Ω–µ—ë.</p>
<Listing number="4-3" file-name="src/main.rs" caption="Functions with ownership and scope annotated">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let s = String::from("hello");  // s –≤—Ö–æ–¥–∏—Ç –≤ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏

    takes_ownership(s);             // –∑–Ω–∞—á–µ–Ω–∏–µ s –ø–µ—Ä–µ–º–µ—â–∞–µ—Ç—Å—è –≤ —Ñ—É–Ω–∫—Ü–∏—é...
                                    // ... –∞ –ø–æ—Ç–æ–º—É –æ–Ω–æ –∑–¥–µ—Å—å –±–æ–ª—å—à–µ –Ω–µ –¥–æ—Å—Ç—É–ø–Ω–æ

    let x = 5;                      // x –≤—Ö–æ–¥–∏—Ç –≤ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏

    makes_copy(x);                  // –ø–æ—Å–∫–æ–ª—å–∫—É i32 —Ä–µ–∞–ª–∏–∑—É–µ—Ç —Ç—Ä–µ–π—Ç Copy,
                                    // x –ù–ï –ø–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—Å—è –≤ —Ñ—É–Ω–∫—Ü–∏—é,
    println!("{}", x);              // —Ç–∞–∫ —á—Ç–æ –¥–∞–ª–µ–µ –≤—Å—ë –µ—â—ë –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å x

} // –ó–¥–µ—Å—å x –ø–æ–∫–∏–¥–∞–µ—Ç –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏, –≤—Å–ª–µ–¥ –∑–∞ –Ω–µ–π ‚Äî –∏ s. –ù–æ –ø–æ—Å–∫–æ–ª—å–∫—É –∑–Ω–∞—á–µ–Ω–∏–µ s —Ä–∞–Ω–µ–µ –±—ã–ª–æ –ø–µ—Ä–µ–º–µ—â–µ–Ω–æ, –Ω–∏—á–µ–≥–æ
  // –∫—Ä–∏—Ç–∏—á–µ—Å–∫–æ–≥–æ –Ω–µ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç.

fn takes_ownership(some_string: String) { // some_string –≤—Ö–æ–¥–∏—Ç –≤ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏
    println!("{some_string}");
} // –ó–¥–µ—Å—å some_string –ø–æ–∫–∏–¥–∞–µ—Ç –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∏ –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è `drop`. –í—ã–¥–µ–ª–µ–Ω–Ω–∞—è –µ–π
  // –ø–∞–º—è—Ç—å –≤—ã—Å–≤–æ–±–æ–∂–¥–∞–µ—Ç—Å—è.

fn makes_copy(some_integer: i32) { // some_integer –≤—Ö–æ–¥–∏—Ç –≤ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏
    println!("{some_integer}");
} "// –ó–¥–µ—Å—å some_integer –ø–æ–∫–∏–¥–∞–µ—Ç –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏. –ù–∏—á–µ–≥–æ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–æ–≥–æ –Ω–µ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç.</code></pre></pre>
</Listing>
<p>–ï—Å–ª–∏ –ø–æ–ø—ã—Ç–∞—Ç—å—Å—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å <code>s</code> –ø–æ—Å–ª–µ –≤—ã–∑–æ–≤–∞ <code>takes_ownership</code>, Rust –≤—ã–±—Ä–æ—Å–∏—Ç –æ—à–∏–±–∫—É –∫–æ–º–ø–∏–ª—è—Ü–∏–∏. –¢–∞–∫–∏–µ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∑–∞—â–∏—â–∞—é—Ç –Ω–∞—Å –æ—Ç –æ–ø–µ—á–∞—Ç–æ–∫. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –≤ <code>main</code> –¥–æ–±–∞–≤–∏—Ç—å –∫–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ <code>s</code> –∏ <code>x</code>, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å, –≥–¥–µ –∏—Ö —Ä–∞–∑—Ä–µ—à–µ–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏ –≥–¥–µ –ø—Ä–∞–≤–∏–ª–∞ –≤–ª–∞–¥–µ–Ω–∏—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞—é—Ç –∏—Ö –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ.</p>
<h3 id="–í–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ-–∑–Ω–∞—á–µ–Ω–∏–π-–∏-–æ–±–ª–∞—Å—Ç—å-–≤–∏–¥–∏–º–æ—Å—Ç–∏"><a class="header" href="#–í–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ-–∑–Ω–∞—á–µ–Ω–∏–π-–∏-–æ–±–ª–∞—Å—Ç—å-–≤–∏–¥–∏–º–æ—Å—Ç–∏">–í–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏–π –∏ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏</a></h3>
<p>–í–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏–π —Ç–∞–∫–∂–µ –º–æ–∂–µ—Ç —Å–æ–ø—Ä–æ–≤–æ–∂–¥–∞—Ç—å—Å—è –ø–µ—Ä–µ–¥–∞—á–µ–π –≤–ª–∞–¥–µ–Ω–∏—è. –í –õ–∏—Å—Ç–∏–Ω–≥–µ 4-4 –ø–æ–∫–∞–∑–∞–Ω –ø—Ä–∏–º–µ—Ä —Ñ—É–Ω–∫—Ü–∏–∏, –≤–æ–∑–≤—Ä–∞—â–∞—é—â–µ–π –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ, —Å –ø–æ–¥–æ–±–Ω—ã–º–∏ –∂–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è–º–∏, –∫–∞–∫ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 4-3.</p>
<Listing number="4-4" file-name="src/main.rs" caption="Transferring ownership of return values">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let s1 = gives_ownership();        // gives_ownership –ø–µ—Ä–µ–º–µ—â–∞–µ—Ç —Å–≤–æ—ë –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
                                       // –≤ s1

    let s2 = String::from("hello");    // s2 –≤—Ö–æ–¥–∏—Ç –≤ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏

    let s3 = takes_and_gives_back(s2); // s2 –ø–µ—Ä–µ–º–µ—â–∞–µ—Ç—Å—è –≤
                                       // takes_and_gives_back, –∫–æ—Ç–æ—Ä–∞—è —Ç–∞–∫–∂–µ
                                       // –ø–µ—Ä–µ–º–µ—â–∞–µ—Ç –≤ s3 —Å–≤–æ—ë –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
} // –ó–¥–µ—Å—å s3 –ø–æ–∫–∏–¥–∞–µ—Ç –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∏ –µ—ë –ø–∞–º—è—Ç—å –≤—ã—Å–≤–æ–±–æ–∂–¥–∞–µ—Ç—Å—è. s2 –ø–µ—Ä–µ–º–µ—â–µ–Ω–∞: –Ω–∏—á–µ–≥–æ
  // –Ω–µ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç. s1 –ø–æ–∫–∏–¥–∞–µ—Ç –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∏ –µ—ë –ø–∞–º—è—Ç—å –≤—ã—Å–≤–æ–±–æ–∂–¥–∞–µ—Ç—Å—è.

fn gives_ownership() -&gt; String {       // gives_ownership –ø–µ—Ä–µ–º–µ—â–∞–µ—Ç —Å–≤–æ—ë
                                       // –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –≤ —Ç–æ,
                                       // —á—Ç–æ –≤—ã–∑–≤–∞–ª–æ –µ—ë

    let some_string = String::from("—Ç–≤–æ—ë"); // some_string –≤—Ö–æ–¥–∏—Ç –≤ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏

    some_string                        // some_string –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è –∏–∑ —Ñ—É–Ω–∫—Ü–∏–∏ –∏ 
                                       // –ø–µ—Ä–µ–º–µ—â–∞–µ—Ç—Å—è –≤ —Ç–æ, —á—Ç–æ –≤—ã–∑–≤–∞–ª–æ
                                       // —Ñ—É–Ω–∫—Ü–∏—é
}

–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –ø—Ä–∏–Ω–∏–º–∞–µ—Ç String –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç String.fn takes_and_gives_back(a_string: String) -&gt; String {
    // a_string –≤—Ö–æ–¥–∏—Ç –≤ –æ–±–ª–∞—Å—Ç—å
    // –≤–∏–¥–∏–º–æ—Å—Ç–∏

    a_string  // a_string –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è –∏–∑ —Ñ—É–Ω–∫—Ü–∏–∏ –ø–µ—Ä–µ–º–µ—â–∞–µ—Ç—Å—è –≤ —Ç–æ, —á—Ç–æ –≤—ã–∑–≤–∞–ª–æ —Ñ—É–Ω–∫—Ü–∏—é
}</code></pre></pre>
</Listing>
<p>–í–ª–∞–¥–µ–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –∫–∞–∂–¥—ã–π —Ä–∞–∑ —Å–ª–µ–¥—É–µ—Ç –æ–¥–Ω–æ–º—É –∏ —Ç–æ–º—É –∂–µ —à–∞–±–ª–æ–Ω—É: –ø—Ä–∏—Å–≤–∞–∏–≤–∞–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è –¥—Ä—É–≥–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –ø–µ—Ä–µ–º–µ—â–∞–µ—Ç —ç—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ –≤ –Ω–æ–≤—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é. –ö–æ–≥–¥–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è, —Å–æ–¥–µ—Ä–∂–∞—â–∞—è –¥–∞–Ω–Ω—ã–µ –≤ –∫—É—á–µ, –≤—ã—Ö–æ–¥–∏—Ç –∏–∑ –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏, —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –≤ –∫—É—á–µ –±—É–¥–µ—Ç –æ—á–∏—â–µ–Ω–æ —Ñ—É–Ω–∫—Ü–∏–µ–π <code>drop</code>, –µ—Å–ª–∏ —Ç–æ–ª—å–∫–æ –¥–∞–Ω–Ω—ã–µ –Ω–µ –±—ã–ª–∏ –ø–µ—Ä–µ–º–µ—â–µ–Ω—ã –≤–æ –≤–ª–∞–¥–µ–Ω–∏–µ –¥—Ä—É–≥–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π.</p>
<p>–•–æ—Ç—è –≤—Å—ë –∏—Å–ø—Ä–∞–≤–Ω–æ —Ä–∞–±–æ—Ç–∞–µ—Ç, –ø–æ–ª—É—á–∞—Ç—å –≤–ª–∞–¥–µ–Ω–∏–µ, –∞ –∑–∞—Ç–µ–º –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å –µ–≥–æ –∏–∑ –∫–∞–∂–¥–æ–π —Ñ—É–Ω–∫—Ü–∏–µ–π –¥–æ–≤–æ–ª—å–Ω–æ —É—Ç–æ–º–∏—Ç–µ–ª—å–Ω–æ. –ß—Ç–æ, –µ—Å–ª–∏ –º—ã —Ö–æ—Ç–∏–º, —á—Ç–æ–±—ã —Ñ—É–Ω–∫—Ü–∏—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∞ –∑–Ω–∞—á–µ–Ω–∏–µ, –Ω–æ –Ω–µ —Å—Ç–∞–Ω–æ–≤–∏–ª–∞—Å—å –≤–ª–∞–¥–µ–ª—å—Ü–µ–º? –û—á–µ–Ω—å —Ä–∞–∑–¥—Ä–∞–∂–∞–µ—Ç, —á—Ç–æ –≤—Å—ë, —á—Ç–æ –º—ã –ø–µ—Ä–µ–¥–∞—ë–º, —Ç–∞–∫–∂–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –ø–µ—Ä–µ–¥–∞–Ω–æ –æ–±—Ä–∞—Ç–Ω–æ, –µ—Å–ª–∏ –º—ã —Ö–æ—Ç–∏–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç—Ç–æ —Å–Ω–æ–≤–∞ (–ø–æ–º–∏–º–æ –ª—é–±—ã—Ö –≤—ã—á–∏—Å–ª–µ–Ω–Ω—ã—Ö –≤ —Ç–µ–ª–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö, –∫–æ—Ç–æ—Ä—ã–µ –º—ã —Ç–∞–∫–∂–µ –º–æ–∂–µ–º —Ö–æ—Ç–µ—Ç—å –≤–µ—Ä–Ω—É—Ç—å).</p>
<p>Rust –ø–æ–∑–≤–æ–ª—è–µ—Ç –Ω–∞–º –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å –∏–∑ —Ñ—É–Ω–∫—Ü–∏–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ –∑–Ω–∞—á–µ–Ω–∏–π, –∏—Å–ø–æ–ª—å–∑—É—è –∫–æ—Ä—Ç–µ–∂, –∫–∞–∫ –ø–æ–∫–∞–∑–∞–Ω–æ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 4-5.</p>
<Listing number="4-5" file-name="src/main.rs" caption="Returning ownership of parameters">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("–î–ª–∏–Ω–∞ '{s2}' —Ä–∞–≤–Ω–∞ {len}.");
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len() –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –¥–ª–∏–Ω—É String

    (s, length)
}</code></pre></pre>
</Listing>
<p>–ù–æ —ç—Ç–æ —Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ—Å–ª–æ–≤–Ω–æ –∏ –∏–∑–ª–∏—à–Ω–µ –¥–ª—è –º–µ—Ç–æ–¥–∏–∫–∏, –∫–æ—Ç–æ—Ä–∞—è –ø—Ä–µ—Ç–µ–Ω–¥—É–µ—Ç –Ω–∞ —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ—Å—Ç—å –∏ –≤—Å–µ–ø—Ä–∏–º–µ–Ω–∏–º–æ—Å—Ç—å. –ö —Å—á–∞—Å—Ç—å—é, –≤ Rust –µ—Å—Ç—å —Å–ø–æ—Å–æ–± –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –±–µ–∑ –ø–µ—Ä–µ–¥–∞—á–∏ –≤–ª–∞–¥–µ–Ω–∏—è ‚Äî <em>—Å—Å—ã–ª–∫–∏</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–°—Å—ã–ª–∫–∏-–∏-–∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–µ"><a class="header" href="#–°—Å—ã–ª–∫–∏-–∏-–∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–µ">–°—Å—ã–ª–∫–∏ –∏ –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–µ</a></h2>
<p>–ü—Ä–æ–±–ª–µ–º–∞ —Å —Ä–µ—à–µ–Ω–∏–µ–º –∏–∑ –õ–∏—Å—Ç–∏–Ω–≥–∞ 4-5 –∑–∞–∫–ª—é—á–∞–µ—Ç—Å—è –≤ —Ç–æ–º, —á—Ç–æ –º—ã –¥–æ–ª–∂–Ω—ã –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å <code>String</code> –æ–±—Ä–∞—Ç–Ω–æ –∏–∑ –≤—ã–∑–≤–∞–Ω–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏, —á—Ç–æ–±—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å <code>String</code> –ø–æ—Å–ª–µ –≤—ã–∑–æ–≤–∞ <code>calculate_length</code>, –ø–æ—Ç–æ–º—É —á—Ç–æ <code>String</code> –ø–µ—Ä–µ–º–µ—â–∞–µ—Ç—Å—è –≤ <code>calculate_length</code>. –í–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ –º—ã –º–æ–∂–µ–º –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ <code>String</code> –ø–æ —Å—Å—ã–ª–∫–µ. –°—Å—ã–ª–∫–∞ –ø–æ—Ö–æ–∂–∞ –Ω–∞ —É–∫–∞–∑–∞—Ç–µ–ª—å –≤ —Ç–æ–º —Å–º—ã—Å–ª–µ, —á—Ç–æ –æ–Ω–∞ —è–≤–ª—è–µ—Ç—Å—è –∞–¥—Ä–µ—Å–æ–º, –ø–æ –∫–æ—Ç–æ—Ä–æ–º—É –º—ã –º–æ–∂–µ–º –ø—Ä–æ—Å–ª–µ–¥–æ–≤–∞—Ç—å, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –¥–∞–Ω–Ω—ã–º, —Ö—Ä–∞–Ω—è—â–∏–º—Å—è –ø–æ —ç—Ç–æ–º—É –∞–¥—Ä–µ—Å—É; —ç—Ç–∏ –¥–∞–Ω–Ω—ã–µ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∞—Ç –∫–∞–∫–æ–π-—Ç–æ –¥—Ä—É–≥–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π. –í –æ—Ç–ª–∏—á–∏–µ –æ—Ç —É–∫–∞–∑–∞—Ç–µ–ª—è, —Å—Å—ã–ª–∫–∞ –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç, —á—Ç–æ –¥–∞–Ω–Ω—ã–µ, –∫ –∫–æ—Ç–æ—Ä—ã–º –ø–æ –Ω–µ–π –º–æ–∂–Ω–æ –æ–±—Ä–∞—Ç–∏—Ç—å—Å—è, –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã –≤—Å—ë –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ —Å—Å—ã–ª–∫–∏.</p>
<p>–í–æ—Ç –∫–∞–∫ –≤—ã –º–æ–≥–ª–∏ –±—ã –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ñ—É–Ω–∫—Ü–∏—é <code>calculate_length</code>, –ø—Ä–∏–Ω–∏–º–∞—é—â—É—é –∫–∞–∫ –ø–∞—Ä–∞–º–µ—Ç—Ä —Å—Å—ã–ª–∫—É, –∞ –Ω–µ –ø—Ä—è–º–æ –ø–æ–ª—É—á–∞—é—â—É—é –≤–ª–∞–¥–µ–Ω–∏–µ –Ω–∞–¥ –∑–Ω–∞—á–µ–Ω–∏–µ–º:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&amp;s1);

    println!("–î–ª–∏–Ω–∞ '{s1}' —Ä–∞–≤–Ω–∞ {len}.");
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}</code></pre></pre>
</Listing>
<p>–í–æ-–ø–µ—Ä–≤—ã—Ö, –º—ã —Ç–µ–ø–µ—Ä—å –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –Ω–µ –∫–æ—Ä—Ç–µ–∂, –∞ —Ç–æ–ª—å–∫–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ–µ –Ω–∞–º –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª–∏–Ω—ã. –í–æ-–≤—Ç–æ—Ä—ã—Ö, –æ–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ –º—ã –ø–µ—Ä–µ–¥–∞—ë–º <code>&amp;s1</code> –≤ <code>calculate_length</code> –∏ –≤ –µ—ë —Å–∏–≥–Ω–∞—Ç—É—Ä–µ –∏—Å–ø–æ–ª—å–∑—É–µ–º <code>&amp;String</code>, –∞ –Ω–µ <code>String</code>. –ò–º–µ–Ω–∞ —Å –∞–º–ø–µ—Ä—Å–∞–Ω–¥–∞–º–∏ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—Ç —Å–æ–±–æ–π <em>—Å—Å—ã–ª–∫–∏</em> ‚Äî –æ–Ω–∏ –ø–æ–∑–≤–æ–ª—è—é—Ç –≤–∞–º —Å—Å—ã–ª–∞—Ç—å—Å—è –Ω–∞ –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ, –Ω–µ –ø—Ä–∏–Ω–∏–º–∞—è –≤–ª–∞–¥–µ–Ω–∏–µ –Ω–∞–¥ –Ω–∏–º–∏. –†–∏—Å—É–Ω–æ–∫ 4-5 –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç, –∫–∞–∫ —ç—Ç–æ —Å–ª–µ–¥—É–µ—Ç –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—Ç—å.</p>
<p><img alt="–¢—Ä–∏ —Ç–∞–±–ª–∏—Ü—ã: —Ç–∞–±–ª–∏—Ü–∞ s —Å–æ–¥–µ—Ä–∂–∏—Ç —Ç–æ–ª—å–∫–æ —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ —Ç–∞–±–ª–∏—Ü—É
s1. –¢–∞–±–ª–∏—Ü–∞ s1 —Å–æ–¥–µ—Ä–∂–∏—Ç –¥–∞–Ω–Ω—ã–µ –Ω–∞ —Å—Ç–µ–∫–µ —Å—Ç—Ä–æ–∫–∏ s1 –∏ —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞
—Ç–µ–∫—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –≤ –∫—É—á–µ." src="img/trpl04-06.svg" class="center" /></p>
<p><span class="caption">–†–∏—Å—É–Ω–æ–∫ 4-6: –°—Ö–µ–º–∞ —Å—Ç—Ä–æ–µ–Ω–∏—è <code>&amp;String s</code>, —É–∫–∞–∑—ã–≤–∞—é—â–µ–π –Ω–∞ <code>String s1</code></span></p>
<blockquote>
<p>–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: –ü—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω–æ—Å—Ç—å—é –≤–∑—è—Ç–∏—è —Å—Å—ã–ª–∫–∏ —Å –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–º <code>&amp;</code> —è–≤–ª—è–µ—Ç—Å—è <em>—Ä–∞–∑—ã–º–µ–Ω–æ–≤–∞–Ω–∏–µ</em>, –≤—ã–ø–æ–ª–Ω—è–µ–º–æ–µ —Å –ø–æ–º–æ—â—å—é –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ —Ä–∞–∑—ã–º–µ–Ω–æ–≤–∞–Ω–∏—è <code>*</code>. –ú—ã —É–≤–∏–¥–∏–º –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ —Ä–∞–∑—ã–º–µ–Ω–æ–≤–∞–Ω–∏—è –≤ –ì–ª–∞–≤–µ 8 –∏ –æ–±—Å—É–¥–∏–º –¥–µ—Ç–∞–ª–∏ —ç—Ç–æ–≥–æ –ø—Ä–æ—Ü–µ—Å—Å–∞ –≤ –ì–ª–∞–≤–µ 15.</p>
</blockquote>
<p>–î–∞–≤–∞–π—Ç–µ –ø–æ–¥—Ä–æ–±–Ω–µ–µ —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º, –∫–∞–∫ –Ω–∞–º –≤—ã–∑–≤–∞—Ç—å –Ω–∞—à—É —Ñ—É–Ω–∫—Ü–∏—é:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");

    let len = calculate_length(&amp;s1);
<span class="boring">
</span><span class="boring">    println!("–î–ª–∏–Ω–∞ '{s1}' —Ä–∞–≤–Ω–∞ {len}.");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn calculate_length(s: &amp;String) -&gt; usize {
</span><span class="boring">    s.len()
</span><span class="boring">}</span></code></pre></pre>
<p><code>&amp;s1</code> —Å–æ–∑–¥–∞—ë—Ç —Å—Å—ã–ª–∫—É, –∫–æ—Ç–æ—Ä–∞—è —Å—Å—ã–ª–∞–µ—Ç—Å—è –Ω–∞ –∑–Ω–∞—á–µ–Ω–∏–µ <code>s1</code>, –Ω–æ –Ω–µ –≤–ª–∞–¥–µ–µ—Ç –∏–º. –ü–æ—Å–∫–æ–ª—å–∫—É –æ–Ω–∞ –Ω–µ –≤–ª–∞–¥–µ–µ—Ç –∏–º, –∑–Ω–∞—á–µ–Ω–∏–µ, –Ω–∞ –∫–æ—Ç–æ—Ä–æ–µ –æ–Ω–∞ —É–∫–∞–∑—ã–≤–∞–µ—Ç, –Ω–µ –±—É–¥–µ—Ç —É–¥–∞–ª–µ–Ω–æ, –∫–æ–≥–¥–∞ —Å—Å—ã–ª–∫–∞ –±—É–¥–µ—Ç —É–¥–∞–ª–µ–Ω–∞.</p>
<p>–ê–Ω–∞–ª–æ–≥–∏—á–Ω–æ, –≤ —Å–∏–≥–Ω–∞—Ç—É—Ä–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è <code>&amp;</code> –¥–ª—è —É–∫–∞–∑–∞–Ω–∏—è –Ω–∞ —Ç–æ, —á—Ç–æ —Ç–∏–ø –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ <code>s</code> —è–≤–ª—è–µ—Ç—Å—è —Å—Å—ã–ª–∫–æ–π.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    let s1 = String::from("hello");
</span><span class="boring">
</span><span class="boring">    let len = calculate_length(&amp;s1);
</span><span class="boring">
</span><span class="boring">    println!("–î–ª–∏–Ω–∞ '{s1}' —Ä–∞–≤–Ω–∞ {len}.");
</span><span class="boring">}
</span><span class="boring">
</span>fn calculate_length(s: &amp;String) -&gt; usize { // s ‚Äî —Å—Å—ã–ª–∫–∞ –Ω–∞ String
    s.len()
} // –ó–¥–µ—Å—å s –≤—Ö–æ–¥–∏—Ç –≤ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏. –ù–æ –ø–æ—Å–∫–æ–ª—å–∫—É s –Ω–µ –≤–ª–∞–¥–µ–µ—Ç —Ç–µ–º, –Ω–∞ —á—Ç–æ
  // —Å—Å—ã–ª–∞–µ—Ç—Å—è, –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–µ —É–¥–∞–ª—è–µ—Ç—Å—è.</code></pre></pre>
<p>–û–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ <code>s</code> —Ç–∞–∫–∞—è –∂–µ, –∫–∞–∫ –∏ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ –ª—é–±–æ–≥–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ —Ñ—É–Ω–∫—Ü–∏–∏, –Ω–æ –∑–Ω–∞—á–µ–Ω–∏–µ, –Ω–∞ –∫–æ—Ç–æ—Ä–æ–µ —É–∫–∞–∑—ã–≤–∞–µ—Ç —Å—Å—ã–ª–∫–∞, –Ω–µ —É–¥–∞–ª—è–µ—Ç—Å—è, –∫–æ–≥–¥–∞ <code>s</code> –ø–µ—Ä–µ—Å—Ç–∞—ë—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è, –ø–æ—Ç–æ–º—É —á—Ç–æ <code>s</code> –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –µ–≥–æ –≤–ª–∞–¥–µ–ª—å—Ü–µ–º. –ï—Å–ª–∏ —Ñ—É–Ω–∫—Ü–∏—è –ø—Ä–∏–Ω–∏–º–∞–µ—Ç —Å—Å—ã–ª–∫–∏ (–∞ –Ω–µ —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è) –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤, –Ω–∞–º –Ω–µ –Ω—É–∂–Ω–æ –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è, —á—Ç–æ–±—ã –æ–±—Ä–∞—Ç–Ω–æ –ø–æ–ª—É—á–∏—Ç—å –Ω–∞–¥ –Ω–∏–º–∏ –≤–ª–∞–¥–µ–Ω–∏–µ, –ø–æ—Ç–æ–º—É —á—Ç–æ –º—ã –∏ –Ω–µ –ø–µ—Ä–µ–¥–∞—ë–º –≤–ª–∞–¥–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏.</p>
<p>–ú—ã –Ω–∞–∑—ã–≤–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å —Å–æ–∑–¥–∞–Ω–∏—è —Å—Å—ã–ª–∫–∏ <em>–∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–µ–º</em>. –ö–∞–∫ –∏ –≤ —Ä–µ–∞–ª—å–Ω–æ–π –∂–∏–∑–Ω–∏, –µ—Å–ª–∏ —á–µ–ª–æ–≤–µ–∫ —á–µ–º-—Ç–æ –≤–ª–∞–¥–µ–µ—Ç, –≤—ã –º–æ–∂–µ—Ç–µ —ç—Ç–æ —É –Ω–µ–≥–æ –ø–æ–∑–∞–∏–º—Å—Ç–≤–æ–≤–∞—Ç—å. –ö–æ–≥–¥–∞ –≤—ã –∑–∞–∫–æ–Ω—á–∏—Ç–µ, –≤—ã –¥–æ–ª–∂–Ω—ã –≤–µ—Ä–Ω—É—Ç—å –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–Ω–æ–µ –∑–∞–∫–æ–Ω–Ω–æ–º—É –≤–ª–∞–¥–µ–ª—å—Ü—É: –≤—ã –Ω–µ —Å—Ç–∞–Ω–æ–≤–∏—Ç–µ—Å—å –≤–ª–∞–¥–µ–ª—å—Ü–µ–º.</p>
<p>–ê —á—Ç–æ –ø—Ä–æ–∏–∑–æ–π–¥—ë—Ç, –µ—Å–ª–∏ –ø–æ–ø—ã—Ç–∞—Ç—å—Å—è –∏–∑–º–µ–Ω–∏—Ç—å –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ? –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∑–∞–ø—É—Å—Ç–∏—Ç—å –∫–æ–¥ –∏–∑ –õ–∏—Å—Ç–∏–Ω–≥–∞ 4-6: –Ω–∏—á–µ–≥–æ –Ω–µ –≤—ã–π–¥–µ—Ç!</p>
<Listing number="4-6" file-name="src/main.rs" caption="Attempting to modify a borrowed value">
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let s = String::from("hello");

    change(&amp;s);
}

fn change(some_string: &amp;String) {
    some_string.push_str(", world");
}</code></pre>
</Listing>
<p>–í–æ—Ç –æ—à–∏–±–∫–∞:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference
 --&gt; src/main.rs:8:5
  |
8 |     some_string.push_str(", world");
  |     ^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable
  |
help: consider changing this to be a mutable reference
  |
7 | fn change(some_string: &amp;mut String) {
  |                         +++

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>–ö–∞–∫ –∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ, —Å—Å—ã–ª–∫–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –Ω–µ–∏–∑–º–µ–Ω—è–µ–º—ã. –ú—ã –Ω–µ –º–æ–∂–µ–º –ø–æ–º–µ–Ω—è—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —Å—Å—ã–ª–∫–µ.</p>
<h3 id="–ò–∑–º–µ–Ω—è–µ–º—ã–µ-—Å—Å—ã–ª–∫–∏"><a class="header" href="#–ò–∑–º–µ–Ω—è–µ–º—ã–µ-—Å—Å—ã–ª–∫–∏">–ò–∑–º–µ–Ω—è–µ–º—ã–µ —Å—Å—ã–ª–∫–∏</a></h3>
<p>–ú—ã –º–æ–∂–µ–º –∏—Å–ø—Ä–∞–≤–∏—Ç—å –∫–æ–¥ –∏–∑ –õ–∏—Å—Ç–∏–Ω–≥–∞ 4-6, —á—Ç–æ–±—ã –ø–æ–∑–≤–æ–ª–∏—Ç—å —Å–µ–±–µ –∏–∑–º–µ–Ω—è—Ç—å –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: –≤–Ω–µ—Å—è –Ω–µ–±–æ–ª—å—à–∏–µ –ø—Ä–∞–≤–∫–∏, –º—ã –º–æ–∂–µ–º –ø–æ–ª—É—á–∏—Ç—å <em>–∏–∑–º–µ–Ω—è–µ–º—É—é —Å—Å—ã–ª–∫—É</em>:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut s = String::from("hello");

    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(", world");
}</code></pre></pre>
</Listing>
<p>–í–æ-–ø–µ—Ä–≤—ã—Ö, –º—ã –º–µ–Ω—è–µ–º –æ–±—ä—è–≤–ª–µ–Ω–∏–µ <code>s</code>, —á—Ç–æ–±—ã —Å–¥–µ–ª–∞—Ç—å –µ—ë <code>mut</code>. –ó–∞—Ç–µ–º –º—ã —Å–æ–∑–¥–∞—ë–º –∏–∑–º–µ–Ω—è–µ–º—É—é —Å—Å—ã–ª–∫—É —Å –ø–æ–º–æ—â—å—é <code>&amp;mut s</code> –∏ –ø–µ—Ä–µ–¥–∞—ë–º –µ—ë —Ñ—É–Ω–∫—Ü–∏–∏ <code>change</code>. –í–æ-–≤—Ç–æ—Ä—ã—Ö, –º—ã —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ –æ–±–Ω–æ–≤–ª—è–µ–º —Å–∏–≥–Ω–∞—Ç—É—Ä—É —Ñ—É–Ω–∫—Ü–∏–∏, —á—Ç–æ–±—ã –º–æ—á—å –ø—Ä–∏–Ω—è—Ç—å –∏–∑–º–µ–Ω—è–µ–º—É—é —Å—Å—ã–ª–∫—É: <code>some_string: &amp;mut String</code>. –≠—Ç–æ –¥–∞—ë—Ç –ø–æ–Ω–∏–º–∞—Ç—å, —á—Ç–æ <code>change</code> –º–æ–∂–µ—Ç –∏–∑–º–µ–Ω—è—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –∑–∞–∏–º—Å—Ç–≤—É–µ—Ç.</p>
<p>–ò–∑–º–µ–Ω—è–µ–º—ã–µ —Å—Å—ã–ª–∫–∏ –∏–º–µ—é—Ç –æ–¥–Ω–æ –±–æ–ª—å—à–æ–µ –æ–≥—Ä–∞–Ω–∏—á–∏—Ç–µ–ª—å–Ω–æ–µ –ø—Ä–∞–≤–∏–ª–æ: –µ—Å–ª–∏ —É –≤–∞—Å –µ—Å—Ç—å –∏–∑–º–µ–Ω—è–µ–º–∞—è —Å—Å—ã–ª–∫–∞ –Ω–∞ –∑–Ω–∞—á–µ–Ω–∏–µ, —É –≤–∞—Å –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –¥—Ä—É–≥–∏—Ö —Å—Å—ã–ª–æ–∫ –Ω–∞ —ç—Ç–æ –∂–µ –∑–Ω–∞—á–µ–Ω–∏–µ. –ö–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –ø—ã—Ç–∞–µ—Ç—Å—è —Å–æ–∑–¥–∞—Ç—å –¥–≤–µ –∏–∑–º–µ–Ω—è–µ–º—ã–µ —Å—Å—ã–ª–∫–∏ –Ω–∞ <code>s</code>, –Ω–µ —Å–∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è:</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    println!("{}, {}", r1, r2);
<span class="boring">}</span></code></pre>
</Listing>
<p>–í–æ—Ç –æ—à–∏–±–∫–∞:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; src/main.rs:5:14
  |
4 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 |
7 |     println!("{}, {}", r1, r2);
  |                        -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>–≠—Ç–∞ –æ—à–∏–±–∫–∞ –≥–æ–≤–æ—Ä–∏—Ç –æ —Ç–æ–º, —á—Ç–æ –∫–æ–¥ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–µ–Ω, –ø–æ—Ç–æ–º—É —á—Ç–æ –º—ã –Ω–µ –º–æ–∂–µ–º –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –∏–º–µ—Ç—å –¥–≤–µ —Å—Å—ã–ª–∫–∏ –Ω–∞ <code>s</code> —Å –ø—Ä–∞–≤–æ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è. –ü–µ—Ä–≤–æ–µ –∏–∑–º–µ–Ω—è–µ–º–æ–µ –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ <code>r1</code> –∏ –¥–æ–ª–∂–Ω–æ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞—Ç—å –¥–æ —Ç–µ—Ö –ø–æ—Ä, –ø–æ–∫–∞ –æ–Ω–æ –Ω–µ –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ –≤ <code>println!</code>, –Ω–æ –º–µ–∂–¥—É —Å–æ–∑–¥–∞–Ω–∏–µ–º —ç—Ç–æ–π –∏–∑–º–µ–Ω—è–µ–º–æ–π —Å—Å—ã–ª–∫–∏ –∏ –µ—ë –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –º—ã –ø–æ–ø—ã—Ç–∞–ª–∏—Å—å —Å–æ–∑–¥–∞—Ç—å –¥—Ä—É–≥—É—é –∏–∑–º–µ–Ω—è–µ–º—É—é —Å—Å—ã–ª–∫—É, –∫–æ—Ç–æ—Ä–∞—è –∑–∞–∏–º—Å—Ç–≤—É–µ—Ç —Ç–µ –∂–µ –¥–∞–Ω–Ω—ã–µ, —á—Ç–æ –∏ <code>r1</code>, –∏ –∑–∞–ø–∏—Å–∞—Ç—å –µ—ë –≤ <code>r2</code>.</p>
<p>The restriction preventing multiple mutable references to the same data at the same time allows for mutation but in a very controlled fashion. It‚Äôs something that new Rustaceans struggle with because most languages let you mutate whenever you‚Äôd like. The benefit of having this restriction is that Rust can prevent data races at compile time. A <em>data race</em> is similar to a race condition and happens when these three behaviors occur:</p>
<ul>
<li>–î–≤–∞ –∏–ª–∏ –±–æ–ª—å—à–µ —É–∫–∞–∑–∞—Ç–µ–ª–µ–π –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –∏–º–µ—é—Ç –¥–æ—Å—Ç—É–ø –∫ –æ–¥–Ω–æ–π –∏ —Ç–æ–π –∂–µ –ø–∞–º—è—Ç–∏.</li>
<li>–•–æ—Ç—è –±—ã –æ–¥–∏–Ω –∏–∑ —É–∫–∞–∑–∞—Ç–µ–ª–µ–π –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –∑–∞–ø–∏—Å–∏ –≤ –ø–∞–º—è—Ç—å.</li>
<li>–ù–µ—Ç –º–µ—Ö–∞–Ω–∏–∑–º–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –∏—Ö –¥–æ—Å—Ç—É–ø–∞ –∫ –ø–∞–º—è—Ç–∏.</li>
</ul>
<p>–ì–æ–Ω–∫–∏ –¥–∞–Ω–Ω—ã—Ö –≤—ã–∑—ã–≤–∞—é—Ç –Ω–µ–æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ, –∏ –∏—Ö –º–æ–∂–µ—Ç –±—ã—Ç—å —Å–ª–æ–∂–Ω–æ –¥–∏–∞–≥–Ω–æ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –∏ –∏—Å–ø—Ä–∞–≤–∏—Ç—å, –∫–æ–≥–¥–∞ –≤—ã –ø—ã—Ç–∞–µ—Ç–µ—Å—å –æ—Ç—Å–ª–µ–¥–∏—Ç—å –∏—Ö –≤–æ –≤—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã –ø—Ä–æ–≥—Ä–∞–º–º—ã. Rust –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç —Ç–∞–∫—É—é –ø—Ä–æ–±–ª–µ–º—É, –æ—Ç–∫–∞–∑—ã–≤–∞—è—Å—å –∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞—Ç—å –∫–æ–¥ —Å –≥–æ–Ω–∫–∞–º–∏ –¥–∞–Ω–Ω—ã—Ö.</p>
<p>–ö–∞–∫ –∏ –≤—Å–µ–≥–¥–∞, –º—ã –º–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ñ–∏–≥—É—Ä–Ω—ã–µ —Å–∫–æ–±–∫–∏ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –Ω–æ–≤–æ–π –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏, –ø–æ–∑–≤–æ–ª—è—é—â–µ–π –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –∏–∑–º–µ–Ω—è–µ–º—ã—Ö —Å—Å—ã–ª–æ–∫, –Ω–æ –Ω–µ <em>–æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ</em>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    {
        let r1 = &amp;mut s;
    } // –∑–¥–µ—Å—å r1 –ø–æ–∫–∏–¥–∞–µ—Ç –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏, —Ç–∞–∫ —á—Ç–æ –º—ã –º–æ–∂–µ–º –±–µ–∑ –ø—Ä–æ–±–ª–µ–º —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é —Å—Å—ã–ª–∫—É.

    let r2 = &amp;mut s;
<span class="boring">}</span></code></pre></pre>
<p>–í Rust –¥–µ–π—Å—Ç–≤—É–µ—Ç –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ–µ –ø—Ä–∞–≤–∏–ª–æ –¥–ª—è —Å–ª—É—á–∞–µ–≤ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –∏–∑–º–µ–Ω—è–µ–º—ã—Ö –∏ –Ω–µ–∏–∑–º–µ–Ω—è–µ–º—ã—Ö —Å—Å—ã–ª–æ–∫. –≠—Ç–æ—Ç –∫–æ–¥ –Ω–µ —Å–∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    let r1 = &amp;s; // –≤—Å—ë —Ö–æ—Ä–æ—à–æ
    let r2 = &amp;s; // –≤—Å—ë —Ö–æ—Ä–æ—à–æ
    let r3 = &amp;mut s; // –í–°–Å –ü–õ–û–•–û

    println!("{}, {} –∏ {}", r1, r2, r3);
<span class="boring">}</span></code></pre>
<p>–í–æ—Ç –æ—à–∏–±–∫–∞:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:14
  |
4 |     let r1 = &amp;s; // –≤—Å—ë —Ö–æ—Ä–æ—à–æ
  |              -- immutable borrow occurs here
5 |     let r2 = &amp;s; // –≤—Å—ë —Ö–æ—Ä–æ—à–æ
6 |     let r3 = &amp;mut s; // –í–°–Å –ü–õ–û–•–û
  |              ^^^^^^ mutable borrow occurs here
7 |
8 |     println!("{}, {} –∏ {}", r1, r2, r3);
  |                                -- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>–î–∞. –ú—ã, <em>–≤ —Ç–æ–º —á–∏—Å–ª–µ</em>, –Ω–µ –º–æ–∂–µ–º –∏–º–µ—Ç—å –∏–∑–º–µ–Ω—è–µ–º—É—é —Å—Å—ã–ª–∫—É, –ø–æ–∫–∞ —É –Ω–∞—Å –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞ –Ω–µ–∏–∑–º–µ–Ω—è–µ–º–∞—è —Å—Å—ã–ª–∫–∞ –Ω–∞ —Ç–æ –∂–µ –∑–Ω–∞—á–µ–Ω–∏–µ.</p>
<p>–î–µ–ª–æ –≤ —Ç–æ–º, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –Ω–µ–∏–∑–º–µ–Ω—è–µ–º–æ–π —Å—Å—ã–ª–∫–∏ –Ω–µ –æ–∂–∏–¥–∞—é—Ç, —á—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ –≤–Ω–µ–∑–∞–ø–Ω–æ –∏–∑–º–µ–Ω–∏—Ç—Å—è —É –Ω–∏—Ö –ø–æ–¥ –Ω–æ—Å–æ–º! –û–¥–Ω–∞–∫–æ, –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –Ω–µ–∏–∑–º–µ–Ω—è–µ–º—ã–µ —Å—Å—ã–ª–∫–∏ —Ä–∞–∑—Ä–µ—à–µ–Ω—ã: –Ω–∏–∫—Ç–æ, –∫—Ç–æ –ø—Ä–æ—Å—Ç–æ —á–∏—Ç–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ, –Ω–µ –º–æ–∂–µ—Ç –ø–æ–≤–ª–∏—è—Ç—å –Ω–∞ —á—Ç–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –∫–µ–º-–ª–∏–±–æ –µ—â—ë.</p>
<p>–û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ —Å—Å—ã–ª–∫–∏ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å —Ç–æ–≥–æ –º–µ—Å—Ç–∞, –≥–¥–µ –æ–Ω–∞ —Å–æ–∑–¥–∞—ë—Ç—Å—è, –∏ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è –¥–æ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —ç—Ç–æ–π —Å—Å—ã–ª–∫–∏. –ù–∞–ø—Ä–∏–º–µ—Ä, —ç—Ç–æ—Ç –∫–æ–¥ –±—É–¥–µ—Ç –∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞—Ç—å—Å—è, –ø–æ—Ç–æ–º—É —á—Ç–æ –ø–æ—Å–ª–µ –º–∞–∫—Ä–æ—Å–∞ <code>println!</code> –Ω–µ–∏–∑–º–µ–Ω—è–µ–º—ã–µ —Å—Å—ã–ª–∫–∏ –±–æ–ª—å—à–µ –Ω–µ –±—É–¥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è, –∏ —É –Ω–∞—Å –Ω–µ –±—É–¥–µ—Ç –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã—Ö –∏–∑–º–µ–Ω—è–µ–º—ã—Ö –∏ –Ω–µ–∏–∑–º–µ–Ω—è–µ–º—ã—Ö —Å—Å—ã–ª–æ–∫:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    let r1 = &amp;s; // –≤—Å—ë —Ö–æ—Ä–æ—à–æ
    let r2 = &amp;s; // –≤—Å—ë —Ö–æ—Ä–æ—à–æ
    println!("{r1} –∏ {r2}");
    // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ r1 –∏ r2 –¥–∞–ª–µ–µ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è.

    let r3 = &amp;mut s; // –≤—Å—ë —Ö–æ—Ä–æ—à–æ
    println!("{r3}");
<span class="boring">}</span></code></pre></pre>
<p>–û–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏ –Ω–µ–∏–∑–º–µ–Ω—è–µ–º—ã—Ö —Å—Å—ã–ª–æ–∫ <code>r1</code> –∏ <code>r2</code> –∑–∞–∫–∞–Ω—á–∏–≤–∞—é—Ç—Å—è –ø–æ—Å–ª–µ <code>println!</code>, —Ç–æ –µ—Å—Ç—å –¥–æ —Å–æ–∑–¥–∞–Ω–∏—è –∏–∑–º–µ–Ω—è–µ–º–æ–π —Å—Å—ã–ª–∫–∏ <code>r3</code>. –≠—Ç–∏ –æ–±–ª–∞—Å—Ç–∏ –Ω–µ –ø–µ—Ä–µ—Å–µ–∫–∞—é—Ç—Å—è, –ø–æ—ç—Ç–æ–º—É —ç—Ç–æ—Ç –∫–æ–¥ –¥–æ–ø—É—Å—Ç–∏–º: –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –º–æ–∂–µ—Ç —Å–∫–∞–∑–∞—Ç—å, —á—Ç–æ —Å—Å—ã–ª–∫–∞ –±–æ–ª—å—à–µ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤ —Ç–æ—á–∫–µ –ø–µ—Ä–µ–¥ –∫–æ–Ω—Ü–æ–º –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏.</p>
<p>–ù–µ—Å–º–æ—Ç—Ä—è –Ω–∞ —Ç–æ, —á—Ç–æ –æ—à–∏–±–∫–∏ –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏—è –∏–Ω–æ–≥–¥–∞ –º–æ–≥—É—Ç –≤–æ–≥–Ω–∞—Ç—å –≤–æ —Ñ—Ä—É—Å—Ç—Ä–∞—Ü–∏—é, –ø–æ–º–Ω–∏—Ç–µ, —á—Ç–æ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä Rust –∑–∞—Ä–∞–Ω–µ–µ (–≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏, –∞ –Ω–µ –≤–æ –≤—Ä–µ–º—è –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è) –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—É—é –æ—à–∏–±–∫—É –∏ —Ç–æ—á–Ω–æ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç, –≤ —á—ë–º –ø—Ä–æ–±–ª–µ–º–∞. –≠—Ç–∏ –ø—Ä–∞–≤–∏–ª–∞ –∏ –∏—Ö –ø—Ä–æ–≤–µ—Ä–∫–∏ –æ—Å–≤–æ–±–æ–∂–¥–∞—é—Ç –≤–∞—Å –æ—Ç –º—É—á–∏—Ç–µ–ª—å–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞ –ø—Ä–∏—á–∏–Ω —Ç–æ–≥–æ, –≤ –∫–∞–∫–æ–π –º–æ–º–µ–Ω—Ç –∏ –ø–æ—á–µ–º—É –º–µ–Ω—è—é—Ç—Å—è –Ω—É–∂–Ω—ã–µ –≤–∞–º –¥–∞–Ω–Ω—ã–µ.</p>
<h3 id="–í–∏—Å—è—á–∏–µ-—Å—Å—ã–ª–∫–∏"><a class="header" href="#–í–∏—Å—è—á–∏–µ-—Å—Å—ã–ª–∫–∏">–í–∏—Å—è—á–∏–µ —Å—Å—ã–ª–∫–∏</a></h3>
<p>–í —è–∑—ã–∫–∞—Ö —Å —É–∫–∞–∑–∞—Ç–µ–ª—è–º–∏ –≤–µ—Å—å–º–∞ –ª–µ–≥–∫–æ –æ—à–∏–±–æ—á–Ω–æ —Å–æ–∑–¥–∞—Ç—å "–≤–∏—Å—è—á—É—é" —Å—Å—ã–ª–∫—É ‚Äî —Å—Å—ã–ª–∫—É, —É–∫–∞–∑—ã–≤–∞—é—â—É—é –Ω–∞ —É—á–∞—Å—Ç–æ–∫ –ø–∞–º—è—Ç–∏, –∫–æ—Ç–æ—Ä—ã–π –±—ã–ª –æ—Å–≤–æ–±–æ–∂–¥—ë–Ω. –ö–æ–º–ø–∏–ª—è—Ç–æ—Ä Rust –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç, —á—Ç–æ —Å—Å—ã–ª–∫–∏ –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –±—É–¥—É—Ç –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–º–∏: –µ—Å–ª–∏ —É –≤–∞—Å –µ—Å—Ç—å —Å—Å—ã–ª–∫–∞ –Ω–∞ –∫–∞–∫–∏–µ-—Ç–æ –¥–∞–Ω–Ω—ã–µ, –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –æ–±–µ—Å–ø–µ—á–∏—Ç, —á—Ç–æ —ç—Ç–∏ –¥–∞–Ω–Ω—ã–µ –Ω–µ –ø–æ–∫–∏–Ω—É—Ç –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏ –ø—Ä–µ–∂–¥–µ, —á–µ–º –∏–∑ –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∏—Å—á–µ–∑–Ω–µ—Ç —Å—Å—ã–ª–∫–∞.</p>
<p>–î–∞–≤–∞–π—Ç–µ –ø–æ–ø—Ä–æ–±—É–µ–º —Å–æ–∑–¥–∞—Ç—å –≤–∏—Å—è—á—É—é —Å—Å—ã–ª–∫—É, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å, –∫–∞–∫ Rust –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç –∏—Ö –ø–æ—è–≤–ª–µ–Ω–∏–µ ‚Äî —Å—Ä–∞–∑—É –Ω–∞ —ç—Ç–∞–ø–µ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏:</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from("hello");

    &amp;s
}</code></pre>
</Listing>
<p>–í–æ—Ç –æ—à–∏–±–∫–∞:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:5:16
  |
5 | fn dangle() -&gt; &amp;String {
  |                ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime, but this is uncommon unless you're returning a borrowed value from a `const` or a `static`
  |
5 | fn dangle() -&gt; &amp;'static String {
  |                 +++++++
help: instead, you are more likely to want to return an owned value
  |
5 - fn dangle() -&gt; &amp;String {
5 + fn dangle() -&gt; String {
  |

error[E0515]: cannot return reference to local variable `s`
 --&gt; src/main.rs:8:5
  |
8 |     &amp;s
  |     ^^ returns a reference to data owned by the current function

Some errors have detailed explanations: E0106, E0515.
For more information about an error, try `rustc --explain E0106`.
error: could not compile `ownership` (bin "ownership") due to 2 previous errors
</code></pre>
<p>–≠—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ –æ—Ç–Ω–æ—Å–∏—Ç—Å—è –∫ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏ —è–∑—ã–∫–∞, –∫–æ—Ç–æ—Ä—É—é –º—ã –µ—â—ë –Ω–µ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–ª–∏: "–≤—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏". –ú—ã –ø–æ–¥—Ä–æ–±–Ω–æ –æ–±—Å—É–¥–∏–º –≤—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏ –≤ –ì–ª–∞–≤–µ 10. –ù–æ –¥–∞–∂–µ –µ—Å–ª–∏ –Ω–µ –æ–±—Ä–∞—â–∞—Ç—å –≤–Ω–∏–º–∞–Ω–∏–µ –Ω–∞ —Å—Ç—Ä–æ–∫–∏ –æ–± –æ—à–∏–±–∫–∞—Ö –æ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏, –≤—Å—ë —Ä–∞–≤–Ω–æ –º–æ–∂–Ω–æ –∑–∞–º–µ—Ç–∏—Ç—å —Å–∞–º—É—é –≥–ª–∞–≤–Ω—É—é –æ—à–∏–±–∫—É:</p>
<pre><code class="language-text">this function's return type contains a borrowed value, but there is no value
for it to be borrowed from
</code></pre>
<p>–î–∞–≤–∞–π—Ç–µ –ø–æ–¥—Ä–æ–±–Ω–µ–µ —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º, —á—Ç–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –Ω–∞ –∫–∞–∂–¥–æ–º —ç—Ç–∞–ø–µ –Ω–∞—à–µ–≥–æ –ø—Ä–∏–º–µ—Ä–∞:</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let reference_to_nothing = dangle();
</span><span class="boring">}
</span><span class="boring">
</span>fn dangle() -&gt; &amp;String { // dangle –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Å—ã–ª–∫—É –Ω–∞ String

    let s = String::from("hello"); // –≤ s –∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Ç–∏–ø–∞ String

    &amp;s // –º—ã –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Å—Å—ã–ª–∫—É s –Ω–∞ –∑–Ω–∞—á–µ–Ω–∏–µ —Ç–∏–ø–∞ String
} // –ó–¥–µ—Å—å s –ø–æ–∫–∏–¥–∞–µ—Ç –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏, –∏ –µ—ë –ø–∞–º—è—Ç—å –≤—ã—Å–≤–æ–±–æ–∂–¥–∞–µ—Ç—Å—è
  // –ë–µ–¥–∞!</code></pre>
</Listing>
<p>–ü–æ—Å–∫–æ–ª—å–∫—É <code>s</code> —Å–æ–∑–¥–∞—ë—Ç—Å—è –≤–Ω—É—Ç—Ä–∏ <code>dangle</code>, —Ç–æ –∫–æ–≥–¥–∞ —Ç–µ–ª–æ <code>dangle</code> –∑–∞–∫–æ–Ω—á–∏—Ç—Å—è, <code>s</code> –±—É–¥–µ—Ç –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∞. –ù–æ –º—ã –ø–æ–ø—ã—Ç–∞–ª–∏—Å—å –≤–µ—Ä–Ω—É—Ç—å —Å—Å—ã–ª–∫—É –Ω–∞ –Ω–µ—ë. –≠—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ —ç—Ç–∞ —Å—Å—ã–ª–∫–∞ –±—É–¥–µ—Ç —É–∫–∞–∑—ã–≤–∞—Ç—å –Ω–∞ –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—É—é String. –≠—Ç–æ, –æ—á–µ–≤–∏–¥–Ω–æ, –ø—Ä–æ–±–ª–µ–º–∞! –û–¥–Ω–∞–∫–æ Rust –Ω–∞—Å –æ—Ç –Ω–µ—ë –∑–∞—â–∏—â–∞–µ—Ç.</p>
<p>–†–µ—à–µ–Ω–∏–µ–º –±—É–¥–µ—Ç –≤–µ—Ä–Ω—É—Ç—å –Ω–µ–ø–æ—Å—Ä–µ–¥—Å—Ç–≤–µ–Ω–Ω–æ —Å–∞–º–æ –∑–Ω–∞—á–µ–Ω–∏–µ <code>String</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    let string = no_dangle();
</span><span class="boring">}
</span><span class="boring">
</span>fn no_dangle() -&gt; String {
    let s = String::from("hello");

    s
}</code></pre></pre>
<p>–≠—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç –±–µ–∑ –∏–∑—ä—è–Ω–æ–≤. –í–ª–∞–¥–µ–Ω–∏–µ –ø–µ—Ä–µ–º–µ—â–∞–µ—Ç—Å—è, –∏ –Ω–∏—á–µ–≥–æ –Ω–µ –≤—ã—Å–≤–æ–±–æ–∂–¥–∞–µ—Ç—Å—è.</p>
<h3 id="–ü—Ä–∞–≤–∏–ª–∞-—Ä–∞–±–æ—Ç—ã-—Å—Å—ã–ª–æ–∫"><a class="header" href="#–ü—Ä–∞–≤–∏–ª–∞-—Ä–∞–±–æ—Ç—ã-—Å—Å—ã–ª–æ–∫">–ü—Ä–∞–≤–∏–ª–∞ —Ä–∞–±–æ—Ç—ã —Å—Å—ã–ª–æ–∫</a></h3>
<p>–î–∞–≤–∞–π—Ç–µ –ø–æ–≤—Ç–æ—Ä–∏–º –≤—Å–µ, —á—Ç–æ –º—ã —É–∑–Ω–∞–ª–∏ –æ —Å—Å—ã–ª–∫–∞—Ö:</p>
<ul>
<li>–í –ª—é–±–æ–π –º–æ–º–µ–Ω—Ç –≤—Ä–µ–º–µ–Ω–∏ –≤—ã –º–æ–∂–µ—Ç–µ –∏–º–µ—Ç—å <em>–ª–∏–±–æ</em> –∞) –æ–¥–Ω—É –∏–∑–º–µ–Ω—è–µ–º—É—é —Å—Å—ã–ª–∫—É, <em>–ª–∏–±–æ</em> –±) –Ω–µ–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ –º–Ω–æ–≥–æ –Ω–µ–∏–∑–º–µ–Ω—è–µ–º—ã—Ö —Å—Å—ã–ª–æ–∫.</li>
<li>–ó–Ω–∞—á–µ–Ω–∏–µ –¥–æ–ª–∂–Ω–æ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞—Ç—å –¥–æ–ª—å—à–µ, —á–µ–º –ª—é–±–∞—è —Å—Å—ã–ª–∫–∞, –∫–æ—Ç–æ—Ä–∞—è –Ω–∞ –Ω–µ–≥–æ —É–∫–∞–∑—ã–≤–∞–µ—Ç.</li>
</ul>
<p>–í —Å–ª–µ–¥—É—é—â–µ–º —Ä–∞–∑–¥–µ–ª–µ –º—ã —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º –¥—Ä—É–≥–æ–π —Ç–∏–ø —Å—Å—ã–ª–æ–∫ ‚Äî —Å—Ä–µ–∑—ã.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–°—Ä–µ–∑—ã"><a class="header" href="#–°—Ä–µ–∑—ã">–°—Ä–µ–∑—ã</a></h2>
<p><em>–°—Ä–µ–∑</em> –ø–æ–∑–≤–æ–ª—è–µ—Ç –∏–∑–±–∏—Ä–∞—Ç–µ–ª—å–Ω–æ —Å—Å—ã–ª–∞—Ç—å—Å—è –Ω–∞ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤ <a href="ch08-00-common-collections.html">–∫–æ–ª–ª–µ–∫—Ü–∏–∏</a>. –°—Ä–µ–∑ —è–≤–ª—è–µ—Ç—Å—è —Å–≤–æ–µ–≥–æ —Ä–æ–¥–∞ —Å—Å—ã–ª–∫–æ–π, –ø–æ—ç—Ç–æ–º—É –æ–Ω –Ω–µ –≤–ª–∞–¥–µ–µ—Ç –∑–Ω–∞—á–µ–Ω–∏—è–º–∏.</p>
<p>–í–æ—Ç –Ω–µ–±–æ–ª—å—à–∞—è –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç—Å–∫–∞—è –∑–∞–¥–∞—á–∫–∞: –Ω–∞–ø–∏—à–∏—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é, –∫–æ—Ç–æ—Ä–∞—è –ø—Ä–∏–Ω–∏–º–∞–µ—Ç —Å—Ç—Ä–æ–∫—É —Å–ª–æ–≤, —Ä–∞–∑–¥–µ–ª—ë–Ω–Ω—ã—Ö –ø—Ä–æ–±–µ–ª–∞–º–∏, –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–µ—Ä–≤–æ–µ —Å–ª–æ–≤–æ –≤ —ç—Ç–æ–π —Å—Ç—Ä–æ–∫–µ. –ï—Å–ª–∏ —Ñ—É–Ω–∫—Ü–∏—è –Ω–µ –Ω–∞—Ö–æ–¥–∏—Ç –ø—Ä–æ–±–µ–ª–∞ –≤ —Å—Ç—Ä–æ–∫–µ, —Ç–æ –≤—Å—è —Å—Ç—Ä–æ–∫–∞ —Å–æ—Å—Ç–æ–∏—Ç –∏–∑ –æ–¥–Ω–æ–≥–æ —Å–ª–æ–≤–∞, –∞ –ø–æ—Ç–æ–º—É –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∞ –≤—Å—è —Å—Ç—Ä–æ–∫–∞ —Ü–µ–ª–∏–∫–æ–º.</p>
<p>–î–∞–≤–∞–π—Ç–µ –ø–æ—Å–º–æ—Ç—Ä–∏–º, –∫–∞–∫ –±—ã –º—ã –Ω–∞–ø–∏—Å–∞–ª–∏ —Å–∏–≥–Ω–∞—Ç—É—Ä—É —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –±–µ–∑ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Å—Ä–µ–∑–æ–≤, —á—Ç–æ–±—ã –ø–æ–Ω—è—Ç—å –∏—Ö —Å–º—ã—Å–ª:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; ?</code></pre>
<p>The <code>first_word</code> function has a <code>&amp;String</code> as a parameter. We don‚Äôt need ownership, so this is fine. (In idiomatic Rust, functions do not take ownership of their arguments unless they need to, and the reasons for that will become clear as we keep going!) But what should we return? We don‚Äôt really have a way to talk about part of a string. However, we could return the index of the end of the word, indicated by a space. Let‚Äôs try that, as shown in Listing 4-7.</p>
<Listing number="4-7" file-name="src/main.rs" caption="The `first_word` function that returns a byte index value into the `String` parameter">
<pre><pre class="playground"><code class="language-rust edition2021">fn first_word(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p>Because we need to go through the <code>String</code> element by element and check whether a value is a space, we‚Äôll convert our <code>String</code> to an array of bytes using the <code>as_bytes</code> method.</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span>    let bytes = s.as_bytes();
<span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>–î–∞–ª–µ–µ, –º—ã —Å–æ–∑–¥–∞—ë–º –∏—Ç–µ—Ä–∞—Ç–æ—Ä –ø–æ –º–∞—Å—Å–∏–≤—É –±–∞–π—Ç–æ–≤ –∏—Å–ø–æ–ª—å–∑—É—è –º–µ—Ç–æ–¥ <code>iter</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span>    for (i, &amp;item) in bytes.iter().enumerate() {
<span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>–ú—ã –æ–±—Å—É–¥–∏–º –∏—Ç–µ—Ä–∞—Ç–æ—Ä—ã –±–æ–ª–µ–µ –ø–æ–¥—Ä–æ–±–Ω–æ –≤ <a href="ch13-02-iterators.html">–ì–ª–∞–≤–µ 13</a><!-- ignore -->. –ù–∞ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –∑–Ω–∞–π—Ç–µ, —á—Ç–æ <code>iter</code> ‚Äî —ç—Ç–æ –º–µ—Ç–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–∞–∂–¥—ã–π —ç–ª–µ–º–µ–Ω—Ç –≤ –∫–æ–ª–ª–µ–∫—Ü–∏–∏, –∞ <code>enumerate</code> –æ–±–æ—Ä–∞—á–∏–≤–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç <code>iter</code> –∏ –≤–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–∞–∂–¥–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∫–∞–∫ —ç–ª–µ–º–µ–Ω—Ç –∫–æ—Ä—Ç–µ–∂–∞. –ü–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç –∫–æ—Ä—Ç–µ–∂–∞, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—ã–π –∏–∑ <code>enumerate</code>, —è–≤–ª—è–µ—Ç—Å—è –∏–Ω–¥–µ–∫—Å–æ–º, –∞ –≤—Ç–æ—Ä–æ–π —ç–ª–µ–º–µ–Ω—Ç ‚Äî —Å—Å—ã–ª–∫–æ–π –Ω–∞ —Å–∞–º–æ –∑–Ω–∞—á–µ–Ω–∏–µ. –≠—Ç–æ –Ω–µ–º–Ω–æ–≥–æ —É–¥–æ–±–Ω–µ–µ, —á–µ–º –≤—ã—á–∏—Å–ª—è—Ç—å –∏–Ω–¥–µ–∫—Å —Å–∞–º–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω–æ.</p>
<p>–ü–æ—Å–∫–æ–ª—å–∫—É –º–µ—Ç–æ–¥ <code>enumerate</code> –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–æ—Ä—Ç–µ–∂, –º—ã –º–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —à–∞–±–ª–æ–Ω—ã –¥–ª—è –¥–µ–∫–æ–Ω—Å—Ç—Ä—É–∏—Ä–æ–≤–∞–Ω–∏—è —ç—Ç–æ–≥–æ –∫–æ—Ä—Ç–µ–∂–∞. –ú—ã –ø–æ–¥—Ä–æ–±–Ω–µ–µ –æ–±—Å—É–¥–∏–º —à–∞–±–ª–æ–Ω—ã –≤ <a href="ch06-02-match.html#%D0%A1%D0%B2%D1%8F%D0%B7%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%BE-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F%D0%BC%D0%B8-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%BE%D0%B2">–ì–ª–∞–≤–µ 6</a><!-- ignore -->.–í —Ü–∏–∫–ª–µ <code>for</code> –º—ã —É–∫–∞–∑—ã–≤–∞–µ–º —à–∞–±–ª–æ–Ω, —Å–æ—Å—Ç–æ—è—â–∏–π –∏–∑ <code>i</code> –¥–ª—è –∏–Ω–¥–µ–∫—Å–∞ –≤ –∫–æ—Ä—Ç–µ–∂–µ –∏ <code>&amp;item</code> –¥–ª—è –æ—Ç–¥–µ–ª—å–Ω–æ–≥–æ –±–∞–π—Ç–∞ –≤ –∫–æ—Ä—Ç–µ–∂–µ. –ü–æ—Å–∫–æ–ª—å–∫—É –º—ã –∏–∑ <code>.iter().enumerate()</code> –ø–æ–ª—É—á–∞–µ–º –ª–∏—à—å —Å—Å—ã–ª–∫—É –Ω–∞ —ç–ª–µ–º–µ–Ω—Ç, –º—ã –≤ —à–∞–±–ª–æ–Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ–º <code>&amp;</code>.</p>
<p>–í–Ω—É—Ç—Ä–∏ —Ü–∏–∫–ª–∞ <code>for</code> –º—ã –∏—â–µ–º –±–∞–π—Ç, —è–≤–ª—è—é—â–∏–π—Å—è –ø—Ä–æ–±–µ–ª–æ—Å, –∏—Å–ø–æ–ª—å–∑—É—è —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –±–∞–π—Ç–æ–≤–æ–≥–æ –ª–∏—Ç–µ—Ä–∞–ª–∞. –ï—Å–ª–∏ –º—ã –Ω–∞—Ö–æ–¥–∏–º –ø—Ä–æ–±–µ–ª, –º—ã –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –µ–≥–æ –ø–æ–∑–∏—Ü–∏—é. –í –ø—Ä–æ—Ç–∏–≤–Ω–æ–º —Å–ª—É—á–∞–µ, –º—ã –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –¥–ª–∏–Ω—É —Å—Ç—Ä–æ–∫–∏ —Å –ø–æ–º–æ—â—å—é <code>s.len()</code>.</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span>        if item == b' ' {
            return i;
        }
    }

    s.len()
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>–¢–µ–ø–µ—Ä—å —É –Ω–∞—Å –µ—Å—Ç—å —Å–ø–æ—Å–æ–± —É–∑–Ω–∞—Ç—å –∏–Ω–¥–µ–∫—Å –±–∞–π—Ç–∞, —É–∫–∞–∑—ã–≤–∞—é—â–µ–≥–æ –Ω–∞ –∫–æ–Ω–µ—Ü –ø–µ—Ä–≤–æ–≥–æ —Å–ª–æ–≤–∞ –≤ —Å—Ç—Ä–æ–∫–µ; –Ω–æ –µ—Å—Ç—å –ø—Ä–æ–±–ª–µ–º–∞. –ú—ã –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ª–∏—à—å <code>usize</code>, –Ω–æ —ç—Ç–æ —á–∏—Å–ª–æ –∏–º–µ–µ—Ç —Å–º—ã—Å–ª —Ç–æ–ª—å–∫–æ –≤ —Å–≤—èÃÅ–∑–∏ —Å–æ <code>&amp;String</code>. –î—Ä—É–≥–∏–º–∏ —Å–ª–æ–≤–∞–º–∏, –ø–æ—Å–∫–æ–ª—å–∫—É —ç—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ –æ—Ç–¥–µ–ª–µ–Ω–æ –æ—Ç <code>String</code>, —Ç–æ –Ω–µ—Ç –≥–∞—Ä–∞–Ω—Ç–∏–∏, —á—Ç–æ –æ–Ω–æ –±—É–¥–µ—Ç –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–º –≤ –±—É–¥—É—â–µ–º. –†–∞—Å—Å–º–æ—Ç—Ä–∏–º –ø—Ä–æ–≥—Ä–∞–º–º—É –∏–∑ –õ–∏—Å—Ç–∏–Ω–≥–∞ 4-8, –∫–æ—Ç–æ—Ä–∞—è –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —Ñ—É–Ω–∫—Ü–∏—é <code>first_word</code> –∏–∑ –õ–∏—Å—Ç–∏–Ω–≥–∞ 4-7.</p>
<Listing number="4-8" file-name="src/main.rs" caption="Storing the result from calling the `first_word` function and then changing the `String` contents">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&amp;s); // word –±—É–¥–µ—Ç —Å–≤—è–∑–∞–Ω–æ —Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º 5

    s.clear(); // –∑–¥–µ—Å—å String –æ—á–∏—â–∞–µ—Ç—Å—è –∏ —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è —Ä–∞–≤–Ω—ã–º ""

    // `word` –∑–¥–µ—Å—å –≤—Å—ë –µ—â—ë –∏–º–µ–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ `5` –Ω–æ `s` —Ç–µ–ø–µ—Ä—å –ø—É—Å—Ç–∞, –∞ –∑–Ω–∞—á–µ–Ω–∏–µ
    // `5` –Ω–µ –∏–º–µ–µ—Ç —Å –Ω–µ–π –Ω–∏–∫–∞–∫–æ–≥–æ —Å–º—ã—Å–ª–∞, —Ç–∞–∫ —á—Ç–æ `word` —Ç–µ–ø–µ—Ä—å
    // –ø–æ–ª–Ω–æ—Å—Ç—å—é –±–µ—Å—Å–º—ã—Å–ª–µ–Ω–Ω–∞!
}</code></pre></pre>
</Listing>
<p>–î–∞–Ω–Ω–∞—è –ø—Ä–æ–≥—Ä–∞–º–º–∞ –∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è –±–µ–∑ –æ—à–∏–±–æ–∫ –∏ –±—É–¥–µ—Ç —É—Å–ø–µ—à–Ω–æ —Ä–∞–±–æ—Ç–∞—Ç—å –¥–∞–∂–µ –ø–æ—Å–ª–µ —Ç–æ–≥–æ –∫–∞–∫ –º—ã –≤–æ—Å–ø–æ–ª—å–∑—É–µ–º—Å—è –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π <code>word</code> –ø–æ—Å–ª–µ –≤—ã–∑–æ–≤–∞ <code>s.clear()</code>. –ü–æ—Å–∫–æ–ª—å–∫—É –∑–Ω–∞—á–µ–Ω–∏–µ <code>word</code> —Å–æ–≤—Å–µ–º –Ω–µ —Å–≤—è–∑–∞–Ω–æ —Å –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π <code>s</code>, —Ç–æ <code>word</code> —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç —Å–≤–æ—ë –∑–Ω–∞—á–µ–Ω–∏–µ <code>5</code>. –ú—ã –±—ã –º–æ–≥–ª–∏ –≤–æ—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –∑–Ω–∞—á–µ–Ω–∏–µ–º <code>5</code>, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –ø–µ—Ä–≤–æ–µ —Å–ª–æ–≤–æ –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π <code>s</code>, –Ω–æ —ç—Ç–æ –ø—Ä–∏–≤–µ–¥—ë—Ç –∫ –æ—à–∏–±–∫–µ, –ø–æ—Ç–æ–º—É —á—Ç–æ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ <code>s</code> –∏–∑–º–µ–Ω–∏–ª–æ—Å—å —Å —Ç–æ–≥–æ –º–æ–º–µ–Ω—Ç–∞, –∫–∞–∫ –º—ã —Å–æ—Ö—Ä–∞–Ω—è–ª–∏ <code>5</code> –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π <code>word</code> (<code>s</code> —Å—Ç–∞–ª–∞ –ø—É—Å—Ç–æ–π —Å—Ç—Ä–æ–∫–æ–π –ø–æ—Å–ª–µ –≤—ã–∑–æ–≤–∞ <code>s.clear()</code>).</p>
<p>–ù–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç—å –±–µ—Å–ø–æ–∫–æ–∏—Ç—å—Å—è –æ —Ç–æ–º, —á—Ç–æ –∏–Ω–¥–µ–∫—Å –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π <code>word</code> –Ω–µ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ—Ç—Å—è —Å —Å–æ–¥–µ—Ä–∂–∏–º—ã–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–º <code>s</code> ‚Äî —ç—Ç–æ —É—Ç–æ–º–∏—Ç–µ–ª—å–Ω–æ –∏ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ –æ–ø–∞—Å–Ω–æ! –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —ç—Ç–∏–º–∏ –∏–Ω–¥–µ–∫—Å–∞–º–∏ —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –µ—â—ë –±–æ–ª–µ–µ —Ö—Ä—É–ø–∫–∏–º –≤ —Ñ—É–Ω–∫—Ü–∏—è—Ö –≤—Ä–æ–¥–µ <code>second_word</code>. –ï—ë —Å–∏–≥–Ω–∞—Ç—É—Ä–∞ –º–æ–≥–ª–∞ –±—ã –≤—ã–≥–ª—è–¥–µ—Ç—å —Ç–∞–∫:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; (usize, usize) {</code></pre>
<p>–¢–µ–ø–µ—Ä—å –º—ã –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º –∫–∞–∫ –Ω–∞—á–∞–ª—å–Ω—ã–π, —Ç–∞–∫ –∏ –∫–æ–Ω–µ—á–Ω—ã–π –∏–Ω–¥–µ–∫—Å. –¢–µ–ø–µ—Ä—å —É –Ω–∞—Å –µ—Å—Ç—å –µ—â—ë –±–æ–ª—å—à–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏, –≤—ã—á–∏—Å–ª–∏—Ç–µ–ª—å–Ω–æ —Å–≤—è–∑–∞–Ω–Ω–æ–π —Å –Ω–µ–∫–æ—Ç–æ—Ä—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏, –Ω–æ —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∏ –Ω–∏–∫–∞–∫ –Ω–µ —Ä–µ–∞–≥–∏—Ä—É—é—â–∏–º–∏ –Ω–∞ –∏—Ö –∏–∑–º–µ–Ω–µ–Ω–∏–µ. –£ –Ω–∞—Å –µ—Å—Ç—å —Ç—Ä–∏ –æ—Ç–¥–µ–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ, –∏ –≤—Å–µ –∏—Ö –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –¥–µ—Ä–∂–∞—Ç—å –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–º–∏.</p>
<p>–ö —Å—á–∞—Å—Ç—å—é, –≤ Rust –µ—Å—Ç—å —Ä–µ—à–µ–Ω–∏–µ –¥–∞–Ω–Ω–æ–π –ø—Ä–æ–±–ª–µ–º—ã: —Å—Ç—Ä–æ–∫–æ–≤—ã–µ —Å—Ä–µ–∑—ã.</p>
<h3 id="–°—Ç—Ä–æ–∫–æ–≤—ã–µ-—Å—Ä–µ–∑—ã"><a class="header" href="#–°—Ç—Ä–æ–∫–æ–≤—ã–µ-—Å—Ä–µ–∑—ã">–°—Ç—Ä–æ–∫–æ–≤—ã–µ —Å—Ä–µ–∑—ã</a></h3>
<p>–°—Ç—Ä–æ–∫–æ–≤—ã–π —Å—Ä–µ–∑ ‚Äî —ç—Ç–æ —Å—Å—ã–ª–∫–∞ –Ω–∞ —á–∞—Å—Ç—å —Å—Ç—Ä–æ–∫–∏ <code>String</code>. –û–Ω –≤—ã–≥–ª—è–¥–∏—Ç –≤–æ—Ç —Ç–∞–∫:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s = String::from("hello world");

    let hello = &amp;s[0..5];
    let world = &amp;s[6..11];
<span class="boring">}</span></code></pre></pre>
<p>–í–º–µ—Å—Ç–æ —Ç–æ–≥–æ, —á—Ç–æ–±—ã —Å—Å—ã–ª–∞—Ç—å—Å—è –Ω–∞ –≤—Å—é <code>String</code>, <code>hello</code> —Å—Å—ã–ª–∞–µ—Ç—Å—è –ª–∏—à—å –Ω–∞ —á–∞—Å—Ç—å <code>String</code>, –æ–ø—Ä–µ–¥–µ–ª—è–µ–º—É—é –ø—Ä–∏–ø–∏—Å–∞–Ω–Ω—ã–º —Å–ø—Ä–∞–≤–∞ –ø—Ä–æ–º–µ–∂—É—Ç–∫–æ–º <code>[0..5]</code>. –°—Ä–µ–∑—ã —Å–æ–∑–¥–∞—é—Ç—Å—è —É–∫–∞–∑–∞–Ω–∏–µ–º –¥–∏–∞–ø–∞–∑–æ–Ω–∞ –≤ –∫–≤–∞–¥—Ä–∞—Ç–Ω—ã—Ö —Å–∫–æ–±–∫–∞—Ö: <code>[starting_index..ending_index]</code>, –≥–¥–µ <em><code>starting_index</code></em> ‚Äî —ç—Ç–æ –ø–µ—Ä–≤–∞—è –ø–æ–∑–∏—Ü–∏—è –≤ —Å—Ä–µ–∑–µ, –∞ <em><code>ending_index</code></em> ‚Äî —ç—Ç–æ –Ω–∞ –µ–¥–∏–Ω–∏—Ü—É –±–æ–ª—å—à–µ, —á–µ–º –ø–æ—Å–ª–µ–¥–Ω—è—è –ø–æ–∑–∏—Ü–∏—è –≤ —Å—Ä–µ–∑–µ. –í–Ω—É—Ç—Ä–∏ —Å–µ–±—è —Å—Ä–µ–∑ —Ö—Ä–∞–Ω–∏—Ç –Ω–∞—á–∞–ª—å–Ω—É—é –ø–æ–∑–∏—Ü–∏—é –∏ –¥–ª–∏–Ω—É —Å—Ä–µ–∑–∞, —á—Ç–æ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç <em><code>ending_index</code></em> –º–∏–Ω—É—Å <em><code>starting_index</code></em>. –ò—Ç–∞–∫, –≤ —Å—Ç—Ä–æ—á–∫–µ <code>let world = &amp;s[6..11];</code>, <code>world</code> –±—É–¥–µ—Ç —Å—Ä–µ–∑–æ–º, —Å–æ–¥–µ—Ä–∂–∞—â–∏–º —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –±–∞–π—Ç —Å—Ç—Ä–æ–∫–∏ <code>s</code> –ø–æ –∏–Ω–¥–µ–∫—Å—É <code>6</code>, –∏ –∑–Ω–∞—á–µ–Ω–∏–µ <code>5</code> –¥–ª–∏–Ω—ã —Å—Ä–µ–∑–∞.</p>
<p>–†–∏—Å—É–Ω–æ–∫ 4-7 –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç —ç—Ç–æ.</p>
<p><img alt="–¢—Ä–∏ —Ç–∞–±–ª–∏—Ü—ã: —Ç–∞–±–ª–∏—Ü–∞, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—â–∞—è –¥–∞–Ω–Ω—ã–µ s –Ω–∞ —Å—Ç–µ–∫–µ, –∫–æ—Ç–æ—Ä–∞—è —É–∫–∞–∑—ã–≤–∞–µ—Ç
–Ω–∞ –±–∞–π—Ç –ø–æ –∏–Ω–¥–µ–∫—Å—É 0 –≤ —Ç–∞–±–ª–∏—Ü–µ —Å —Ç–µ–∫—Å—Ç–æ–º &quot;hello world&quot; –≤
–∫—É—á–µ. –¢—Ä–µ—Ç—å—è —Ç–∞–±–ª–∏—Ü–∞ –ø—Ä–µ–¥-—Å—Ç–∞–≤–ª—è–µ—Ç –¥–∞–Ω–Ω—ã–µ —Å—Ä–µ–∑–∞ world –Ω–∞ —Å—Ç–µ–∫–µ, –∫–æ—Ç–æ—Ä—ã–µ
–≤–∫–ª—é—á–∞—é—Ç –≤ —Å–µ–±—è –µ–≥–æ –¥–ª–∏–Ω—É 5 –∏ —É–∫–∞–∑–∞–Ω–∏–µ –Ω–∞ –±–∞–π—Ç –ø–æ –∏–Ω–¥–µ–∫—Å—É 6 –≤ —Ç–∞–±–ª–∏—Ü–µ –¥–∞–Ω–Ω—ã—Ö –≤ –∫—É—á–µ."
src="img/trpl04-07.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">–†–∏—Å—É–Ω–æ–∫ 4-7: –°—Ç—Ä–æ–∫–æ–≤—ã–π —Å—Ä–µ–∑ —Å—Å—ã–ª–∞–µ—Ç—Å—è –Ω–∞ —á–∞—Å—Ç—å <code>String</code></span></p>
<p>–°–∏–Ω—Ç–∞–∫—Å–∏—Å <code>..</code> –ø–æ–∑–≤–æ–ª—è–µ—Ç –≤–∞–º –æ–ø—É—Å—Ç–∏—Ç—å –ø–µ—Ä–≤–æ–µ —á–∏—Å–ª–æ, –µ—Å–ª–∏ –≤—ã —Ö–æ—Ç–∏—Ç–µ –≤–∑—è—Ç—å –ø—Ä–æ–º–µ–∂—É—Ç–æ–∫, –Ω–∞—á–∏–Ω–∞—è —Å –∏–Ω–¥–µ–∫—Å–∞ <code>0</code>. –î—Ä—É–≥–∏–º–∏ —Å–ª–æ–≤–∞–º–∏, —ç—Ç–∏ –¥–≤–µ –∑–∞–ø–∏—Å–∏ —Ä–∞–≤–Ω—ã:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
<span class="boring">}</span></code></pre></pre>
<p>–¢–∞–∫–∏–º –∂–µ –æ–±—Ä–∞–∑–æ–º, –µ—Å–ª–∏ –≤–∞—à —Å—Ä–µ–∑ –≤–∫–ª—é—á–∞–µ—Ç –ø–æ—Å–ª–µ–¥–Ω–∏–π –±–∞–π—Ç <code>String</code>, –≤—ã –º–æ–∂–µ—Ç–µ –æ–ø—É—Å—Ç–∏—Ç—å –≤—Ç–æ—Ä–æ–µ —á–∏—Å–ª–æ. –≠—Ç–∏ –¥–≤–µ –∑–∞–ø–∏—Å–∏ —Ç–æ–∂–µ —Ä–∞–≤–Ω—ã:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");

let len = s.len();

let slice = &amp;s[3..len];
let slice = &amp;s[3..];
<span class="boring">}</span></code></pre></pre>
<p>–í—ã —Ç–∞–∫–∂–µ –º–æ–∂–µ—Ç–µ –æ–ø—É—Å—Ç–∏—Ç—å –æ–±–∞ —á–∏—Å–ª–∞, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å —Å—Ä–µ–∑ –∏–∑ –≤—Å–µ–π —Å—Ç—Ä–æ–∫–∏. –≠—Ç–∏ –¥–≤–µ –∑–∞–ø–∏—Å–∏ —Ç–æ–∂–µ –±—É–¥—É—Ç —Ä–∞–≤–Ω—ã –º–µ–∂–¥—É —Å–æ–±–æ–π:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");

let len = s.len();

let slice = &amp;s[0..len];
let slice = &amp;s[..];
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: –ò–Ω–¥–µ–∫—Å—ã –¥–∏–∞–ø–∞–∑–æ–Ω–∞ —Å—Ä–µ–∑–∞ —Å—Ç—Ä–æ–∫–∏ –¥–æ–ª–∂–Ω—ã —Å–æ–±–ª—é–¥–∞—Ç—å –±–∞–π—Ç–æ–≤–æ–µ —á–ª–µ–Ω–µ–Ω–∏–µ —Å–∏–º–≤–æ–ª–æ–≤ –≤ –∫–æ–¥–∏—Ä–æ–≤–∫–µ UTF-8. –ï—Å–ª–∏ –≤—ã –ø–æ–ø—ã—Ç–∞–µ—Ç–µ—Å—å —Å–æ–∑–¥–∞—Ç—å —Å—Ä–µ–∑ —Å—Ç—Ä–æ–∫–∏, –≤ –∫–æ—Ç–æ—Ä–æ–º –Ω–∞—á–∞–ª–æ –∏–ª–∏ –∫–æ–Ω–µ—Ü –±—É–¥–µ—Ç —É–∫–∞–∑—ã–≤–∞—Ç—å –Ω–∞ –∫—É—Å–æ–∫ —Å–∏–º–≤–æ–ª–∞, –ø—Ä–æ–≥—Ä–∞–º–º–∞ –∑–∞–≤–µ—Ä—à–∏—Ç—Å—è —Å –æ—à–∏–±–∫–æ–π. –í —Ü–µ–ª—è—Ö –æ–±—ä—è—Å–Ω–µ–Ω–∏—è —Ä–∞–±–æ—Ç—ã —Å—Ä–µ–∑–æ–≤ —Å—Ç—Ä–æ–∫ –º—ã –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º, —á—Ç–æ –≤ —ç—Ç–æ–º —Ä–∞–∑–¥–µ–ª–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –∫–æ–¥–∏—Ä–æ–≤–∫–∞ ASCII; –±–æ–ª–µ–µ –ø–æ–¥—Ä–æ–±–Ω–æ–µ –æ–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–∞ –≤ UTF-8 –æ–±—Å—É–∂–¥–∞–µ—Ç—Å—è –≤ —Ä–∞–∑–¥–µ–ª–µ –ì–ª–∞–≤—ã 8 <a href="ch08-02-strings.html#%D0%A5%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D1%82%D0%B5%D0%BA%D1%81%D1%82%D0%B0-%D0%B2-%D0%BA%D0%BE%D0%B4%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B5-utf-8-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-%D1%81%D1%82%D1%80%D0%BE%D0%BA">"–•—Ä–∞–Ω–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ –≤ –∫–æ–¥–∏—Ä–æ–≤–∫–µ UTF-8 —Å –ø–æ–º–æ—â—å—é —Å—Ç—Ä–æ–∫"</a><!-- ignore -->.</p>
</blockquote>
<p>–î–∞–≤–∞–π—Ç–µ –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ–ª—É—á–µ–Ω–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏ –ø–µ—Ä–µ–ø–∏—à–µ–º <code>first_word</code> —Ç–∞–∫, —á—Ç–æ–±—ã –æ–Ω–∞ –≤–æ–∑–≤—Ä–∞—â–∞–ª–∞ —Å—Ä–µ–∑. –¢–∏–ø "—Å—Ä–µ–∑ —Å—Ç—Ä–æ–∫–∏" –æ–±–æ–∑–Ω–∞—á–∞–µ—Ç—Å—è –∫–∞–∫ <code>&amp;str</code>:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021">fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p>–ú—ã –ø–æ–ª—É—á–∞–µ–º –∏–Ω–¥–µ–∫—Å –∫–æ–Ω—Ü–∞ —Å–ª–æ–≤–∞ —Ç–∞–∫ –∂–µ, –∫–∞–∫ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 4-7, –∏—â–∞ –ø–µ—Ä–≤–æ–µ –≤—Ö–æ–∂–¥–µ–Ω–∏–µ –ø—Ä–æ–±–µ–ª–∞. –ö–æ–≥–¥–∞ –º—ã –Ω–∞—Ö–æ–¥–∏–º –ø—Ä–æ–±–µ–ª, –º—ã –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Å—Ä–µ–∑ —Å—Ç—Ä–æ–∫–∏, –∏—Å–ø–æ–ª—å–∑—É—è <code>0</code> –∏ –∏–Ω–¥–µ–∫—Å –ø—Ä–æ–±–µ–ª–∞ –≤ –∫–∞—á–µ—Å—Ç–≤–µ –Ω–∞—á–∞–ª—å–Ω–æ–≥–æ –∏ –∫–æ–Ω–µ—á–Ω–æ–≥–æ –∏–Ω–¥–µ–∫—Å–æ–≤.</p>
<p>–¢–µ–ø–µ—Ä—å, –∫–æ–≥–¥–∞ –º—ã –≤—ã–∑—ã–≤–∞–µ–º <code>first_word</code>, –º—ã –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ, –ø—Ä–∏–≤—è–∑–∞–Ω–Ω–æ–µ –∫ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º—ã–º –¥–∞–Ω–Ω—ã–º. –ó–Ω–∞—á–µ–Ω–∏–µ —Å–æ—Å—Ç–æ–∏—Ç –∏–∑ —Å—Å—ã–ª–∫–∏ –Ω–∞ –ø–µ—Ä–≤—ã–π —Å–∏–º–≤–æ–ª —Å—Ç—Ä–æ–∫–∏, —Å –∫–æ—Ç–æ—Ä–æ–≥–æ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å—Ä–µ–∑, –∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤ —Å—Ä–µ–∑–µ.</p>
<p>–ê–Ω–∞–ª–æ–≥–∏—á–Ω—ã–º –æ–±—Ä–∞–∑–æ–º –º–æ–∂–Ω–æ –ø–µ—Ä–µ–ø–∏—Å–∞—Ç—å –∏ —Ñ—É–Ω–∫—Ü–º—é <code>second_word</code>:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; &amp;str {</code></pre>
<p>–¢–µ–ø–µ—Ä—å —É –Ω–∞—Å –µ—Å—Ç—å –ø—Ä–æ—Å—Ç–æ–π API, –∫–æ—Ç–æ—Ä—ã–π –≥–æ—Ä–∞–∑–¥–æ —Å–ª–æ–∂–Ω–µ–µ –∏—Å–ø–æ—Ä—Ç–∏—Ç—å, –ø–æ—Å–∫–æ–ª—å–∫—É —á—Ç–æ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç, —á—Ç–æ —Å—Å—ã–ª–∫–∏ –Ω–∞ <code>String</code> –æ—Å—Ç–∞–Ω—É—Ç—Å—è –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–º–∏. –ü–æ–º–Ω–∏—Ç–µ –æ—à–∏–±–∫—É –≤ –ø—Ä–æ–≥—Ä–∞–º–º–µ –õ–∏—Å—Ç–∏–Ω–≥–∞ 4-8, –∫–æ–≥–¥–∞ –º—ã –ø–æ–ª—É—á–∏–ª–∏ –∏–Ω–¥–µ–∫—Å –∫–æ–Ω—Ü–∞ –ø–µ—Ä–≤–æ–≥–æ —Å–ª–æ–≤–∞, –Ω–æ –∑–∞—Ç–µ–º –æ—á–∏—Å—Ç–∏–ª–∏ —Å—Ç—Ä–æ–∫—É, —Ç–∞–∫ —á—Ç–æ –Ω–∞—à –∏–Ω–¥–µ–∫—Å —Å—Ç–∞–ª –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–º? –≠—Ç–æ—Ç –∫–æ–¥ –±—ã–ª –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–º –ª–æ–≥–∏—á–µ—Å–∫–∏, –Ω–æ –Ω–µ —Ñ–æ—Ä–º–∞–ª—å–Ω–æ. –ï–≥–æ –ø—Ä–æ–±–ª–µ–º—ã –º–æ–≥–ª–∏ –ø—Ä–æ—è–≤–∏—Ç—å—Å—è –ø–æ–∑–∂–µ, –µ—Å–ª–∏ –±—ã –º—ã –ø–æ–ø—ã—Ç–∞–ª–∏—Å—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏–Ω–¥–µ–∫—Å –ø–µ—Ä–≤–æ–≥–æ —Å–ª–æ–≤–∞ —Å –ø—É—Å—Ç–æ–π —Å—Ç—Ä–æ–∫–æ–π. –°—Ä–µ–∑—ã –¥–µ–ª–∞—é—Ç —ç—Ç—É –æ—à–∏–±–∫—É –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ–π –∏ —Å–æ–æ–±—â–∞—é—Ç –Ω–∞–º –æ –ø—Ä–æ–±–ª–µ–º–µ —Å –Ω–∞—à–∏–º –∫–æ–¥–æ–º –≥–æ—Ä–∞–∑–¥–æ —Ä–∞–Ω—å—à–µ. –ù–∞–ø—Ä–∏–º–µ—Ä, –∫–æ–¥ –Ω–∏–∂–µ –Ω–µ —Å–∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è:</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn first_word(s: &amp;String) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&amp;s);

    s.clear(); // –æ—à–∏–±–∫–∞!

    println!("–ø–µ—Ä–≤–æ–µ —Å–ª–æ–≤–æ: {word}");
}</code></pre>
</Listing>
<p>–í–æ—Ç –æ—à–∏–±–∫–∞ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:18:5
   |
16 |     let word = first_word(&amp;s);
   |                           -- immutable borrow occurs here
17 |
18 |     s.clear(); // –æ—à–∏–±–∫–∞!
   |     ^^^^^^^^^ mutable borrow occurs here
19 |
20 |     println!("–ø–µ—Ä–≤–æ–µ —Å–ª–æ–≤–æ: {word}");
   |                                  ------ immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>–ù–∞–ø–æ–º–Ω–∏–º –∏–∑ –ø—Ä–∞–≤–∏–ª –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏—è, —á—Ç–æ –µ—Å–ª–∏ —É –Ω–∞—Å –µ—Å—Ç—å –Ω–µ–∏–∑–º–µ–Ω—è–µ–º–∞—è —Å—Å—ã–ª–∫–∞ –Ω–∞ —á—Ç–æ-—Ç–æ, –º—ã –Ω–µ –º–æ–∂–µ–º —Ç–∞–∫–∂–µ –≤–∑—è—Ç—å –∏–∑–º–µ–Ω—è–µ–º—É—é —Å—Å—ã–ª–∫—É. –ü–æ—Å–∫–æ–ª—å–∫—É –º–µ—Ç–æ–¥—É <code>clear</code> –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –æ—á–∏—Å—Ç–∏—Ç—å <code>String</code>, –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –ø–æ–ª—É—á–∏—Ç—å –∏–∑–º–µ–Ω—è–µ–º—É—é —Å—Å—ã–ª–∫—É –Ω–∞ –Ω–µ—ë. –ú–∞–∫—Ä–æ—Å <code>println!</code> (–ø–æ—Å–ª–µ –≤—ã–∑–æ–≤–∞ <code>clear</code>) –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —Å—Å—ã–ª–∫—É, —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—É—é –≤ <code>word</code>, –∞ –ø–æ—Ç–æ–º—É –Ω–µ–∏–∑–º–µ–Ω—è–µ–º–∞—è —Å—Å—ã–ª–∫–∞ –≤ —ç—Ç–æ—Ç –º–æ–º–µ–Ω—Ç –≤—Å—ë –µ—â—ë –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ–π. Rust –∑–∞–ø—Ä–µ—â–∞–µ—Ç –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–µ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –∏–∑–º–µ–Ω—è–µ–º–æ–π —Å—Å—ã–ª–∫–∏ –≤ <code>clear</code> –∏ –Ω–µ–∏–∑–º–µ–Ω—è–µ–º–æ–π —Å—Å—ã–ª–∫–∏ –≤ <code>word</code>, –∏ –∫–æ–º–ø–∏–ª—è—Ü–∏—è –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è –æ—à–∏–±–∫–æ–π. Rust –Ω–µ —Ç–æ–ª—å–∫–æ —É–ø—Ä–æ—Å—Ç–∏–ª –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –Ω–∞—à–µ–≥–æ API, –Ω–æ –∏ —É—Å—Ç—Ä–∞–Ω–∏–ª —Ü–µ–ª—ã–π –∫–ª–∞—Å—Å –æ—à–∏–±–æ–∫ —Å—Ä–∞–∑—É –Ω–∞ —ç—Ç–∞–ø–µ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏!</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="string-literals-are-slices"></a></p>
<h4 id="–°—Ç—Ä–æ–∫–æ–≤—ã–µ-–ª–∏—Ç–µ—Ä–∞–ª—ã-–∫–∞–∫-—Å—Ä–µ–∑—ã"><a class="header" href="#–°—Ç—Ä–æ–∫–æ–≤—ã–µ-–ª–∏—Ç–µ—Ä–∞–ª—ã-–∫–∞–∫-—Å—Ä–µ–∑—ã">–°—Ç—Ä–æ–∫–æ–≤—ã–µ –ª–∏—Ç–µ—Ä–∞–ª—ã –∫–∞–∫ —Å—Ä–µ–∑—ã</a></h4>
<p>–ù–∞–ø–æ–º–Ω–∏–º: –º—ã –∫–æ–≥–¥–∞-—Ç–æ –≥–æ–≤–æ—Ä–∏–ª–∏ –æ —Å—Ç—Ä–æ–∫–æ–≤—ã—Ö –ª–∏—Ç–µ—Ä–∞–ª–∞—Ö, –∑–∞–ø–∏—Å–∞–Ω–Ω—ã—Ö –Ω–∞–ø—Ä—è–º—É—é –≤ —Ñ–∞–π–ª–∞—Ö. –¢–µ–ø–µ—Ä—å, –∫–æ–≥–¥–∞ –º—ã –∑–Ω–∞–µ–º —á–µ–º —è–≤–ª—è—é—Ç—Å—è —Å—Ä–µ–∑—ã, –º—ã –º–æ–∂–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω–æ –ø–æ–Ω—è—Ç—å, —á—Ç–æ —Ç–∞–∫–æ–µ —Å—Ç—Ä–æ–∫–æ–≤—ã–µ –ª–∏—Ç–µ—Ä–∞–ª—ã:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = "Hello, world!";
<span class="boring">}</span></code></pre></pre>
<p>–¢–∏–ø –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π <code>s</code> ‚Äî —ç—Ç–æ <code>&amp;str</code>, —Ç–æ –µ—Å—Ç—å —Å—Ä–µ–∑, —É–∫–∞–∑—ã–≤–∞—é—â–∏–π –Ω–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—É—é —Ç–æ—á–∫—É –±–∏–Ω–∞—Ä–Ω–æ–≥–æ —Ñ–∞–π–ª–∞. –í–æ—Ç –ø–æ—á–µ–º—É —Å—Ç—Ä–æ–∫–æ–≤—ã–µ –ª–∏—Ç–µ—Ä–∞–ª—ã –Ω–µ–∏–∑–º–µ–Ω—è–µ–º—ã; –ø–æ—á–µ–º—É <code>&amp;str</code> ‚Äî —Å—Å—ã–ª–∫–∞ –∏–º–µ–Ω–Ω–æ –Ω–µ–∏–∑–º–µ–Ω—è–µ–º–∞—è.</p>
<h4 id="–°—Ç—Ä–æ–∫–æ–≤—ã–µ-—Å—Ä–µ–∑—ã-–∫–∞–∫-–ø–∞—Ä–∞–º–µ—Ç—Ä—ã"><a class="header" href="#–°—Ç—Ä–æ–∫–æ–≤—ã–µ-—Å—Ä–µ–∑—ã-–∫–∞–∫-–ø–∞—Ä–∞–º–µ—Ç—Ä—ã">–°—Ç—Ä–æ–∫–æ–≤—ã–µ —Å—Ä–µ–∑—ã –∫–∞–∫ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã</a></h4>
<p>–ó–Ω–∞—è, —á—Ç–æ –º—ã –º–æ–∂–µ–º –±—Ä–∞—Ç—å —Å—Ä–µ–∑—ã –ª–∏—Ç–µ—Ä–∞–ª–æ–≤ –∏ –∑–Ω–∞—á–µ–Ω–∏–π —Ç–∏–ø–∞ <code>String</code>, –º—ã –º–æ–∂–µ–º –ø—Ä–∏–π—Ç–∏ –∫ –µ—â—ë –æ–¥–Ω–æ–º—É —É–ª—É—á—à–µ–Ω–∏—é <code>first_word</code>. –í–æ—Ç –µ—ë —Å–∏–≥–Ω–∞—Ç—É—Ä–∞:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; &amp;str {</code></pre>
<p>–ë–æ–ª–µ–µ –æ–ø—ã—Ç–Ω—ã–π –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç –Ω–∞ Rust –≤–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ –Ω–∞–ø–∏—Å–∞–ª –±—ã —Å–∏–≥–Ω–∞—Ç—É—Ä—É, –ø–æ–∫–∞–∑–∞–Ω–Ω—É—é –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 4-9, –ø–æ—Ç–æ–º—É —á—Ç–æ —ç—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç –Ω–∞–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –æ–¥–Ω—É –∏ —Ç—É –∂–µ —Ñ—É–Ω–∫—Ü–∏—é –∫–∞–∫ –¥–ª—è –∑–Ω–∞—á–µ–Ω–∏–π <code>&amp;String</code>, —Ç–∞–∫ –∏ –¥–ª—è –∑–Ω–∞—á–µ–Ω–∏–π <code>&amp;str</code>.</p>
<Listing number="4-9" caption="Improving the `first_word` function by using a string slice for the type of the `s` parameter">
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
<span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from("hello world");
</span><span class="boring">
</span><span class="boring">    // `first_word` —Ä–∞–±–æ—Ç–∞–µ—Ç –Ω–∞ –ª—é–±—ã—Ö —Å—Ä–µ–∑–∞—Ö –∑–Ω–∞—á–µ–Ω–∏–π —Ç–∏–ø–∞ `String`: –ø–æ–ª–Ω—ã—Ö –∏–ª–∏ —á–∞—Å—Ç–∏—á–Ω—ã—Ö
</span><span class="boring">    let word = first_word(&amp;my_string[0..6]);
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">    // `first_word` —Ç–∞–∫–∂–µ —Ä–∞–±–æ—Ç–∞–µ—Ç –Ω–∞ —Å—Å—ã–ª–∫–∞—Ö –Ω–∞ –∑–Ω–∞—á–µ–Ω–∏—è —Ç–∏–ø–∞ `String`:
</span><span class="boring">    // —Ç–∞–∫–∏–µ —Å—Å—ã–ª–∫–∏ —Ä–∞–≤–Ω—ã —Å—Ä–µ–∑–∞–º –∏–∑ –≤—Å–µ–π `String` —Ü–µ–ª–∏–∫–æ–º.
</span><span class="boring">    let word = first_word(&amp;my_string);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = "hello world";
</span><span class="boring">
</span><span class="boring">    // `first_word` —Ä–∞–±–æ—Ç–∞–µ—Ç –Ω–∞ –ª—é–±—ã—Ö —Å—Ä–µ–∑–∞—Ö –ª–∏—Ç–µ—Ä–∞–ª–æ–≤ —Å—Ç—Ä–æ–∫: –ø–æ–ª–Ω—ã—Ö –∏–ª–∏
</span><span class="boring">    // —á–∞—Å—Ç–∏—á–Ω—ã—Ö.
</span><span class="boring">    let word = first_word(&amp;my_string_literal[0..6]);
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // –ü–æ—Å–∫–æ–ª—å–∫—É —Å—Ç—Ä–æ–∫–æ–≤—ã–µ –ª–∏—Ç–µ—Ä–∞–ª—ã *—ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–Ω—ã* —Å—Ä–µ–∑–∞–º —Å—Ç—Ä–æ–∫,
</span><span class="boring">    // —ç—Ç–æ —Ç–æ–∂–µ —Å—Ä–∞–±–æ—Ç–∞–µ—Ç, –±–µ–∑ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –±—Ä–∞—Ç—å —Å—Ä–µ–∑!
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}</span></code></pre>
</Listing>
<p>–ï—Å–ª–∏ —É –Ω–∞—Å –µ—Å—Ç—å —Å—Ä–µ–∑ —Å—Ç—Ä–æ–∫–∏, –º—ã –º–æ–∂–µ–º –ø–µ—Ä–µ–¥–∞—Ç—å –µ–≥–æ –Ω–∞–ø—Ä—è–º—É—é. –ï—Å–ª–∏ —É –Ω–∞—Å –µ—Å—Ç—å <code>String</code>, –º—ã –º–æ–∂–µ–º –ø–µ—Ä–µ–¥–∞—Ç—å —á–∞—Å—Ç—å <code>String</code> –∏–ª–∏ —Å—Å—ã–ª–∫—É –Ω–∞ <code>String</code>. –≠—Ç–∞ –≥–∏–±–∫–æ—Å—Ç—å —Ä–∞–±–æ—Ç–∞–µ—Ç –∑–∞ —Å—á—ë—Ç —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏ <em>–ø—Ä–∏–≤–µ–¥–µ–Ω–∏—è —Å—Å—ã–ª–æ–∫ –ø—Ä–∏ —Ä–∞–∑—ã–º–µ–Ω–æ–≤—ã–≤–∞–Ω–∏–∏</em>, —á—Ç–æ –º—ã —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º –≤ —Ä–∞–∑–¥–µ–ª–µ <a href="ch15-02-deref.html#%D0%9D%D0%B5%D1%8F%D0%B2%D0%BD%D0%BE%D0%B5-%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%B8-%D1%80%D0%B0%D0%B7%D1%8B%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B8-%D1%81-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F%D0%BC%D0%B8-%D0%B8-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B0%D0%BC%D0%B8">"–ù–µ—è–≤–Ω–æ–µ –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–µ –ø—Ä–∏ —Ä–∞–∑—ã–º–µ–Ω–æ–≤–∞–Ω–∏–∏ —Å —Ñ—É–Ω–∫—Ü–∏—è–º–∏ –∏ –º–µ—Ç–æ–¥–∞–º–∏"</a><!--ignore--> –ì–ª–∞–≤—ã 15.</p>
<p>–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ –Ω–∞ —Å—Ä–µ–∑–µ —Å—Ç—Ä–æ–∫–∏, –∞ –Ω–µ –Ω–∞ —Å—Å—ã–ª–∫–µ –Ω–∞ <code>String</code>, –¥–µ–ª–∞–µ—Ç –Ω–∞—à API –±–æ–ª–µ–µ –æ–±—â–∏–º –∏ —à–∏—Ä–µ –ø—Ä–∏–º–µ–Ω–∏–º—ã–º –±–µ–∑ –ø–æ—Ç–µ—Ä–∏ –∫–∞–∫–æ–π-–ª–∏–±–æ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn first_word(s: &amp;str) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let my_string = String::from("hello world");

    // `first_word` —Ä–∞–±–æ—Ç–∞–µ—Ç –Ω–∞ –ª—é–±—ã—Ö —Å—Ä–µ–∑–∞—Ö –∑–Ω–∞—á–µ–Ω–∏–π —Ç–∏–ø–∞ `String`: –ø–æ–ª–Ω—ã—Ö –∏–ª–∏ —á–∞—Å—Ç–∏—á–Ω—ã—Ö
    let word = first_word(&amp;my_string[0..6]);
    let word = first_word(&amp;my_string[..]);
    // `first_word` —Ç–∞–∫–∂–µ —Ä–∞–±–æ—Ç–∞–µ—Ç –Ω–∞ —Å—Å—ã–ª–∫–∞—Ö –Ω–∞ –∑–Ω–∞—á–µ–Ω–∏—è —Ç–∏–ø–∞ `String`:
    // —Ç–∞–∫–∏–µ —Å—Å—ã–ª–∫–∏ —Ä–∞–≤–Ω—ã —Å—Ä–µ–∑–∞–º –∏–∑ –≤—Å–µ–π `String` —Ü–µ–ª–∏–∫–æ–º.
    let word = first_word(&amp;my_string);

    let my_string_literal = "hello world";

    // `first_word` —Ä–∞–±–æ—Ç–∞–µ—Ç –Ω–∞ –ª—é–±—ã—Ö —Å—Ä–µ–∑–∞—Ö –ª–∏—Ç–µ—Ä–∞–ª–æ–≤ —Å—Ç—Ä–æ–∫: –ø–æ–ª–Ω—ã—Ö –∏–ª–∏
    // —á–∞—Å—Ç–∏—á–Ω—ã—Ö.
    let word = first_word(&amp;my_string_literal[0..6]);
    let word = first_word(&amp;my_string_literal[..]);

    // –ü–æ—Å–∫–æ–ª—å–∫—É –ª–∏—Ç–µ—Ä–∞–ª—ã —Å—Ç—Ä–æ–∫ *—ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–Ω—ã* —Å—Ä–µ–∑–∞–º —Å—Ç—Ä–æ–∫,
    // —ç—Ç–æ —Ç–æ–∂–µ —Å—Ä–∞–±–æ—Ç–∞–µ—Ç, –±–µ–∑ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –±—Ä–∞—Ç—å —Å—Ä–µ–∑!
    let word = first_word(my_string_literal);
}</code></pre></pre>
</Listing>
<h3 id="–î—Ä—É–≥–∏–µ-—Å—Ä–µ–∑—ã"><a class="header" href="#–î—Ä—É–≥–∏–µ-—Å—Ä–µ–∑—ã">–î—Ä—É–≥–∏–µ —Å—Ä–µ–∑—ã</a></h3>
<p>–°—Ä–µ–∑—ã —Å—Ç—Ä–æ–∫, –∫–∞–∫ –≤—ã –º–æ–∂–µ—Ç–µ –ø–æ–Ω—è—Ç—å, —Ä–∞–±–æ—Ç–∞—é—Ç –∏–º–µ–Ω–Ω–æ —Å–æ —Å—Ç—Ä–æ–∫–∞–º–∏. –ù–æ –µ—Å—Ç—å –∏ –±–æ–ª–µ–µ –æ–±—â–∏–π —Ç–∏–ø —Å—Ä–µ–∑–∞. –†–∞—Å—Å–º–æ—Ç—Ä–∏–º –≤–æ—Ç —ç—Ç–æ—Ç –º–∞—Å—Å–∏–≤:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
<span class="boring">}</span></code></pre></pre>
<p>–¢–æ—á–Ω–æ —Ç–∞–∫ –∂–µ, –∫–∞–∫ –º—ã –º–æ–∂–µ–º –∑–∞—Ö–æ—Ç–µ—Ç—å —Å–æ—Å–ª–∞—Ç—å—Å—è –Ω–∞ —á–∞—Å—Ç—å —Å—Ç—Ä–æ–∫–∏, –º—ã –º–æ–∂–µ–º –∑–∞—Ö–æ—Ç–µ—Ç—å —Å–æ—Å–ª–∞—Ç—å—Å—è –Ω–∞ —á–∞—Å—Ç—å –º–∞—Å—Å–∏–≤–∞. –ú—ã –º–æ–∂–µ–º —Å–¥–µ–ª–∞—Ç—å —ç—Ç–æ —Ç–∞–∫:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];

assert_eq!(slice, &amp;[2, 3]);
<span class="boring">}</span></code></pre></pre>
<p>–≠—Ç–æ—Ç —Å—Ä–µ–∑ –∏–º–µ–µ—Ç —Ç–∏–ø <code>&amp;[i32]</code>. –û–Ω —Ä–∞–±–æ—Ç–∞–µ—Ç —Ç–∞–∫ –∂–µ, –∫–∞–∫ –∏ —Å—Ä–µ–∑—ã —Å—Ç—Ä–æ–∫: —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç —Å—Å—ã–ª–∫—É –Ω–∞ –ø–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç –∏ –µ–≥–æ –¥–ª–∏–Ω—É. –í–∞–º –ø–æ–Ω–∞–¥–æ–±–∏—Ç—Å—è —ç—Ç–æ—Ç –≤–∏–¥ —Å—Ä–µ–∑–∞ –¥–ª—è –≤—Å–µ—Ö –≤–∏–¥–æ–≤ –¥—Ä—É–≥–∏—Ö –∫–æ–ª–ª–µ–∫—Ü–∏–π. –ú—ã –ø–æ–¥—Ä–æ–±–Ω–æ –æ–±—Å—É–¥–∏–º —Ä–∞–∑–ª–∏—á–Ω—ã–µ –∫–æ–ª–ª–µ–∫—Ü–∏–∏, –∫–æ–≥–¥–∞ –±—É–¥–µ–º –≥–æ–≤–æ—Ä–∏—Ç—å –æ –≤–µ–∫—Ç–æ—Ä–∞—Ö –≤ –ì–ª–∞–≤–µ 8.</p>
<h2 id="–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-3"><a class="header" href="#–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-3">–ü–æ–¥–≤–µ–¥—ë–º –∏—Ç–æ–≥–∏</a></h2>
<p>–ö–æ–Ω—Ü–µ–ø—Ü–∏–∏ –≤–ª–∞–¥–µ–Ω–∏—è, –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏—è –∏ —Å—Ä–µ–∑–æ–≤ –æ–±–µ—Å–ø–µ—á–∏–≤–∞—é—Ç –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –ø–∞–º—è—Ç–∏ –≤ –ø—Ä–æ–≥—Ä–∞–º–º–∞—Ö –Ω–∞ Rust –±–µ–∑ –∏—Ö –∑–∞–º–µ–¥–ª–µ–Ω–∏—è ‚Äî –≤—Å–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—Ä–æ–∏—Å—Ö–æ–¥—è—Ç –Ω–∞ —ç—Ç–∞–ø–µ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏. –Ø–∑—ã–∫ Rust –¥–∞—ë—Ç –≤–∞–º –∫–æ–Ω—Ç—Ä–æ–ª—å –Ω–∞–¥ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –ø–∞–º—è—Ç–∏ —Ç–∞–∫ –∂–µ, –∫–∞–∫ –∏ –¥—Ä—É–≥–∏–µ —è–∑—ã–∫–∏ —Å–∏—Å—Ç–µ–º–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è, –Ω–æ —Ç–æ, —á—Ç–æ –≤–ª–∞–¥–µ–ª–µ—Ü –¥–∞–Ω–Ω—ã—Ö –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ—á–∏—â–∞–µ—Ç —ç—Ç–∏ –¥–∞–Ω–Ω—ã–µ, –∫–æ–≥–¥–∞ –≤—ã—Ö–æ–¥–∏—Ç –∏–∑ –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏, –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –≤–∞–º –Ω–µ –Ω—É–∂–Ω–æ –ø–∏—Å–∞—Ç—å –∏ –æ—Ç–ª–∞–∂–∏–≤–∞—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –∫–æ–¥, —á—Ç–æ–±—ã –¥–µ–ª–∞—Ç—å —ç—Ç–æ –≤—Ä—É—á–Ω—É—é.</p>
<p>–í–ª–∞–¥–µ–Ω–∏–µ –≤–ª–∏—è–µ—Ç –Ω–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–æ –¥—Ä—É–≥–∏—Ö –∞—Å–ø–µ–∫—Ç–æ–≤ Rust. –ú—ã –±—É–¥–µ–º –≥–æ–≤–æ—Ä–∏—Ç—å –æ–± —ç—Ç–∏—Ö –∫–æ–Ω—Ü–µ–ø—Ü–∏—è—Ö –Ω–∞ –ø—Ä–æ—Ç—è–∂–µ–Ω–∏–∏ –æ—Å—Ç–∞–≤—à–∏—Ö—Å—è —á–∞—Å—Ç–µ–π –∫–Ω–∏–≥–∏. –î–∞–≤–∞–π—Ç–µ –ø–µ—Ä–µ–π–¥—ë–º –∫ –ì–ª–∞–≤–µ 5 –∏ —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫—É –¥–∞–Ω–Ω—ã—Ö –≤ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ-—Å—Ç—Ä—É–∫—Ç—É—Ä-–¥–ª—è-–æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏-–¥–∞–Ω–Ω—ã—Ö"><a class="header" href="#–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ-—Å—Ç—Ä—É–∫—Ç—É—Ä-–¥–ª—è-–æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏-–¥–∞–Ω–Ω—ã—Ö">–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä –¥–ª—è –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö</a></h1>
<p><em>–°—Ç—Ä—É–∫—Ç—É—Ä–∞</em> ‚Äî —ç—Ç–æ —Ç–∏–ø –¥–∞–Ω–Ω—ã—Ö, –ø–æ–∑–≤–æ–ª—è—é—â–∏–π —É–ø–∞–∫–æ–≤–∞—Ç—å –≤–º–µ—Å—Ç–µ –Ω–µ—Å–∫–æ–ª—å–∫–æ –ª–æ–≥–∏—á–µ—Å–∫–∏ —Å–≤—è–∑–∞–Ω–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π –∏ –Ω–∞–∑–≤–∞—Ç—å –∏—Ö –æ–¥–Ω–∏–º –∏–º–µ–Ω–µ–º. –ï—Å–ª–∏ –≤—ã –∑–Ω–∞–∫–æ–º—ã —Å –æ–±—ä–µ–∫—Ç–Ω–æ-–æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ —è–∑—ã–∫–∞–º–∏, <em>—Å—Ç—Ä—É–∫—Ç—É—Ä–∞</em> –Ω–∞–ø–æ–º–Ω–∏—Ç –≤–∞–º —Å–æ–≤–æ–∫—É–ø–Ω–æ—Å—Ç—å –ø–æ–ª–µ–π –æ–±—ä–µ–∫—Ç–∞. –í —ç—Ç–æ–π –≥–ª–∞–≤–µ –º—ã —Å—Ä–∞–≤–Ω–∏–º –∏ —Å–æ–ø–æ—Å—Ç–∞–≤–∏–º –∫–æ—Ä—Ç–µ–∂–∏ —Å–æ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞–º–∏, –æ–ø–∏—Ä–∞—è—Å—å –Ω–∞ —Ç–æ, —á—Ç–æ –≤—ã —É–∂–µ –∑–Ω–∞–µ—Ç–µ, –∏ –ø—Ä–æ–¥–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä—É–µ–º —Å–∏—Ç—É–∞—Ü–∏–∏, –∫–æ–≥–¥–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã —è–≤–ª—è—é—Ç—Å—è –ª—É—á—à–∏–º —Å–ø–æ—Å–æ–±–æ–º –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∏ –¥–∞–Ω–Ω—ã—Ö.</p>
<p>–ú—ã –ø—Ä–æ–¥–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä—É–µ–º, –∫–∞–∫ –æ–ø—Ä–µ–¥–µ–ª—è—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –∏ —Å–æ–∑–¥–∞–≤–∞—Ç—å –∏—Ö —ç–∫–∑–µ–º–ø–ª—è—Ä—ã. –ú—ã –æ–±—Å—É–¥–∏–º, –∫–∞–∫ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∞—Å—Å–æ—Ü–∏–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∏ –º–µ—Ç–æ–¥—ã ‚Äî —Ñ—É–Ω–∫—Ü–∏–∏, –æ–ø—Ä–µ–¥–µ–ª—è—é—â–∏–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ, —Å–≤–æ–π—Å—Ç–≤–µ–Ω–Ω–æ–µ –¥–∞–Ω–Ω–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä–µ –∏ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞–º –¥–∞–Ω–Ω–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã. –°—Ç—Ä—É–∫—Ç—É—Ä—ã –∏ –æ–±—Å—É–∂–¥–∞–µ–º—ã–µ –≤ –ì–ª–∞–≤–µ 6 –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è —è–≤–ª—è—é—Ç—Å—è —Å—Ç—Ä–æ–∏—Ç–µ–ª—å–Ω—ã–º–∏ –±–ª–æ–∫–∞–º–∏ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –Ω–æ–≤—ã—Ö —Ç–∏–ø–æ–≤ –≤ –ø—Ä–µ–¥–º–µ—Ç–Ω–æ–π –æ–±–ª–∞—Å—Ç–∏ –≤–∞—à–µ–π –ø—Ä–æ–≥—Ä–∞–º–º—ã. –û–Ω–∏ –¥–∞—é—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –≤ –ø–æ–ª–Ω–æ–π –º–µ—Ä–µ –≤–æ—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞–º–∏ Rust –ø–æ –ø—Ä–æ–≤–µ—Ä–∫–µ —Ç–∏–ø–æ–≤ –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ-–∏-—Å–æ–∑–¥–∞–Ω–∏–µ-—ç–∫–∑–µ–º–ø–ª—è—Ä–æ–≤-—Å—Ç—Ä—É–∫—Ç—É—Ä"><a class="header" href="#–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ-–∏-—Å–æ–∑–¥–∞–Ω–∏–µ-—ç–∫–∑–µ–º–ø–ª—è—Ä–æ–≤-—Å—Ç—Ä—É–∫—Ç—É—Ä">–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∏ —Å–æ–∑–¥–∞–Ω–∏–µ —ç–∫–∑–µ–º–ø–ª—è—Ä–æ–≤ —Å—Ç—Ä—É–∫—Ç—É—Ä</a></h2>
<p>–°—Ç—Ä—É–∫—Ç—É—Ä—ã –ø–æ—Ö–æ–∂–∏ –Ω–∞ <a href="ch03-02-data-types.html#%D0%A2%D0%B8%D0%BF-%D0%BA%D0%BE%D1%80%D1%82%D0%B5%D0%B6%D0%B0">–∫–æ—Ä—Ç–µ–∂–∏</a><!-- ignore -->, —Ç–∞–∫ –∫–∞–∫ –æ–±–∞ –ø–æ–∑–≤–æ–ª—è—é—Ç —Ö—Ä–∞–Ω–∏—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–≤—è–∑–∞–Ω–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π. –ö–∞–∫ –∏ —É –∫–æ—Ä—Ç–µ–∂–µ–π, —á–∞—Å—Ç–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä –º–æ–≥—É—Ç –±—ã—Ç—å —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤. –í –æ—Ç–ª–∏—á–∏–µ –æ—Ç –∫–æ—Ä—Ç–µ–∂–µ–π, –≤ —Å—Ç—Ä—É–∫—Ç—É—Ä–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –∏–º–µ–Ω–æ–≤–∞—Ç—å –∫–∞–∂–¥—É—é —á–∞—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ø–æ–Ω–∏–º–∞–Ω–∏—è —Å–º—ã—Å–ª–∞ –∑–Ω–∞—á–µ–Ω–∏–π. –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —ç—Ç–∏—Ö –∏–º—ë–Ω –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –±–æ–ª—å—à—É—é –≥–∏–±–∫–æ—Å—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä –ø–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏—é —Å –∫–æ—Ä—Ç–µ–∂–∞–º–∏: –Ω–µ –Ω—É–∂–Ω–æ –ø–æ–ª–∞–≥–∞—Ç—å—Å—è –Ω–∞ –ø–æ—Ä—è–¥–æ–∫ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —É–∫–∞–∑–∞–Ω–∏—è –∑–Ω–∞—á–µ–Ω–∏–π —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ –∏–ª–∏ –¥–æ—Å—Ç—É–ø–∞ –∫ –Ω–∏–º.</p>
<p>–ß—Ç–æ–±—ã –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, –º—ã –≤–≤–æ–¥–∏–º –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ <code>struct</code> –∏ –Ω–∞–∑–≤–∞–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã. –ù–∞–∑–≤–∞–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –æ–ø–∏—Å—ã–≤–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ —á–∞—Å—Ç–µ–π –¥–∞–Ω–Ω—ã—Ö, —Å–≥—Ä—É–ø–ø–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –≤–º–µ—Å—Ç–µ. –î–∞–ª–µ–µ, –≤ —Ñ–∏–≥—É—Ä–Ω—ã—Ö —Å–∫–æ–±–∫–∞—Ö –¥–ª—è –∫–∞–∂–¥–æ–≥–æ <em>–ø–æ–ª—è</em> –ø–æ–æ—á–µ—Ä—ë–¥–Ω–æ –æ–ø—Ä–µ–¥–µ–ª—è—é—Ç—Å—è –∏–º—è –∏ —Ç–∏–ø. –õ–∏—Å—Ç–∏–Ω–≥ 5-1 –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä—É, –∫–æ—Ç–æ—Ä–∞—è —Ö—Ä–∞–Ω–∏—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± —É—á—ë—Ç–Ω–æ–π –∑–∞–ø–∏—Å–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:</p>
<Listing number="5-1" file-name="src/main.rs" caption="A `User` struct definition">
<pre><pre class="playground"><code class="language-rust edition2021">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p>–ü–æ—Å–ª–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –º–æ–∂–Ω–æ —Å–æ–∑–¥–∞–≤–∞—Ç—å –µ—ë <em>—ç–∫–∑–µ–º–ø–ª—è—Ä</em>, –Ω–∞–∑–Ω–∞—á–∞—è –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Å —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–º —Ç–∏–ø–æ–º –¥–∞–Ω–Ω—ã—Ö –∫–∞–∂–¥–æ–º—É –ø–æ–ª—é. –ß—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å —ç–∫–∑–µ–º–ø–ª—è—Ä —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, –º—ã —É–∫–∞–∑—ã–≤–∞–µ–º –∏–º—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, –∞ –∑–∞—Ç–µ–º –¥–æ–±–∞–≤–ª—è–µ–º —Ñ–∏–≥—É—Ä–Ω—ã–µ —Å–∫–æ–±–∫–∏ –∏ –≤–∫–ª—é—á–∞–µ–º –≤ –Ω–∏—Ö –ø–∞—Ä—ã <em>–∫–ª—é—á: –∑–Ω–∞—á–µ–Ω–∏–µ</em>, –≥–¥–µ –∫–ª—é—á–∞–º–∏ —è–≤–ª—è—é—Ç—Å—è –∏–º–µ–Ω–∞ –ø–æ–ª–µ–π, –∞ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏ —è–≤–ª—è—é—Ç—Å—è –¥–∞–Ω–Ω—ã–µ, –∫–æ—Ç–æ—Ä—ã–µ –º—ã —Ö–æ—Ç–∏–º —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤ –ø–æ–ª—è—Ö. –ù–µ—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ —á—ë—Ç–∫–æ —Å–ª–µ–¥–æ–≤–∞—Ç—å –ø–æ—Ä—è–¥–∫—É –æ–±—ä—è–≤–ª–µ–Ω–∏—è –ø–æ–ª–µ–π –≤ –æ–ø–∏—Å–∞–Ω–∏–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã (–Ω–æ —ç—Ç–æ –≤—Å—ë-—Ç–∞–∫–∏ –∂–µ–ª–∞—Ç–µ–ª—å–Ω–æ –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞ —á—Ç–µ–Ω–∏—è). –î—Ä—É–≥–∏–º–∏ —Å–ª–æ–≤–∞–º–∏, –æ–±—ä—è–≤–ª–µ–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã ‚Äî —ç—Ç–æ –Ω–µ—á—Ç–æ –≤—Ä–æ–¥–µ —Å—Ö–µ–º—ã –Ω–∞—à–µ–π –≥—Ä—É–ø–ø—ã –¥–∞–Ω–Ω—ã—Ö, –≤ —Ç–æ –≤—Ä–µ–º—è –∫–∞–∫ —ç–∫–∑–µ–º–ø–ª—è—Ä —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —ç—Ç—É —Å—Ö–µ–º—É, –∑–∞–ø–æ–ª–Ω—è—è –µ—ë –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏. –ù–∞–ø—Ä–∏–º–µ—Ä, –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –º–æ–∂–Ω–æ –æ–±—ä—è–≤–∏—Ç—å —Ç–∞–∫, –∫–∞–∫ –ø–æ–∫–∞–∑–∞–Ω–æ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 5-2:</p>
<Listing number="5-2" file-name="src/main.rs" caption="Creating an instance of the `User` struct">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };
}</code></pre></pre>
</Listing>
<p>–ß—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, –º—ã –æ–±—Ä–∞—â–∞–µ–º—Å—è –∫ –Ω–µ–º—É –ø–æ –∏–º–µ–Ω–∏ –ø–æ–ª—è —á–µ—Ä–µ–∑ —Ç–æ—á–∫—É. –ù–∞–ø—Ä–∏–º–µ—Ä, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –∞–¥—Ä–µ—Å—É —ç–ª–µ–∫—Ç—Ä–æ–Ω–Ω–æ–π –ø–æ—á—Ç—ã —ç—Ç–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –º—ã –ø–∏—à–µ–º <code>user1.email</code>. –ï—Å–ª–∏ —ç–∫–∑–µ–º–ø–ª—è—Ä —è–≤–ª—è–µ—Ç—Å—è –∏–∑–º–µ–Ω—è–µ–º—ã–º, –º—ã –º–æ–∂–µ–º –ø–æ–º–µ–Ω—è—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ, –∏—Å–ø–æ–ª—å–∑—É—è —Ç–æ—á–µ—á–Ω—É—é –Ω–æ—Ç–∞—Ü–∏—é –∏ –ø—Ä–∏—Å–≤–æ–µ–Ω–∏–µ –∫ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º—É –ø–æ–ª—é. –í –õ–∏—Å—Ç–∏–Ω–≥–µ 5-3 –ø–æ–∫–∞–∑–∞–Ω–æ, –∫–∞–∫ –∏–∑–º–µ–Ω–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –≤ –ø–æ–ª–µ <code>email</code> –∏–∑–º–µ–Ω—è–µ–º–æ–≥–æ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ <code>User</code>.</p>
<Listing number="5-3" file-name="src/main.rs" caption="Changing the value in the `email` field of a `User` instance">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };

    user1.email = String::from("anotheremail@example.com");
}</code></pre></pre>
</Listing>
<p>–°—Ç–æ–∏—Ç –æ—Ç–º–µ—Ç–∏—Ç—å, —á—Ç–æ –≤–µ—Å—å —ç–∫–∑–µ–º–ø–ª—è—Ä —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –∏–∑–º–µ–Ω—è–µ–º—ã–º; Rust –Ω–µ –ø–æ–∑–≤–æ–ª—è–µ—Ç –ø–æ–º–µ—á–∞—Ç—å –∏–∑–º–µ–Ω—è–µ–º—ã–º–∏ –æ—Ç–¥–µ–ª—å–Ω—ã–µ –ø–æ–ª—è. –ö–∞–∫ –∏ –¥–ª—è –ª—é–±–æ–≥–æ –¥—Ä—É–≥–æ–≥–æ –≤—ã—Ä–∞–∂–µ–Ω–∏—è, –º—ã –º–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤—ã—Ä–∞–∂–µ–Ω–∏–µ —Å–æ–∑–¥–∞–Ω–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –≤—ã—Ä–∞–∂–µ–Ω–∏—è —Ç–µ–ª–∞ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ç–æ–≥–æ, —á—Ç–æ–±—ã –Ω–µ—è–≤–Ω–æ –≤–µ—Ä–Ω—É—Ç—å –Ω–æ–≤—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä —Å—Ç—Ä—É–∫—Ç—É—Ä—ã.</p>
<p>–í –õ–∏—Å—Ç–∏–Ω–≥–µ 5-4 –ø–æ–∫–∞–∑–∞–Ω–æ, –∫–∞–∫ —Ñ—É–Ω–∫—Ü–∏—è <code>build_user</code> –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —ç–∫–∑–µ–º–ø–ª—è—Ä <code>User</code> —Å —É–∫–∞–∑–∞–Ω–Ω—ã–º–∏ –∞–¥—Ä–µ—Å–æ–º –∏ –∏–º–µ–Ω–µ–º. –ü–æ–ª–µ <code>active</code> –ø–æ–ª—É—á–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ <code>true</code>, –∞ –ø–æ–ª–µ <code>sign_in_count</code> –ø–æ–ª—É—á–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ <code>1</code>.</p>
<Listing number="5-4" file-name="src/main.rs" caption="A `build_user` function that takes an email and username and returns a `User` instance">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        username: username,
        email: email,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from("someone@example.com"),
</span><span class="boring">        String::from("someusername123"),
</span><span class="boring">    );
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>–í —Ç–æ–º, —á—Ç–æ–±—ã –Ω–∞–∑–≤–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Ñ—É–Ω–∫—Ü–∏–∏ —Ç–µ–º–∏ –∂–µ –∏–º–µ–Ω–∞–º–∏, —á—Ç–æ –∏ –ø–æ–ª—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, –±—ã–ª —Å–º—ã—Å–ª, –Ω–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç—å –ø–æ–≤—Ç–æ—Ä—è—Ç—å <code>email</code> –∏ <code>username</code> –¥–ª—è –Ω–∞–∑–≤–∞–Ω–∏–π –ø–æ–ª–µ–π –∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –Ω–µ—Å–∫–æ–ª—å–∫–æ —É—Ç–æ–º–∏—Ç–µ–ª—å–Ω–∞. –ï—Å–ª–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –∏–º–µ–µ—Ç –º–Ω–æ–≥–æ –ø–æ–ª–µ–π, –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏–µ –∫–∞–∂–¥–æ–≥–æ –∏–º–µ–Ω–∏ —Å—Ç–∞–Ω–µ—Ç –µ—â—ë –±–æ–ª–µ–µ —Ä–∞–∑–¥—Ä–∞–∂–∞—é—â–∏–º. –ö —Å—á–∞—Å—Ç—å—é, –µ—Å—Ç—å —É–¥–æ–±–Ω–æ–µ —Å–æ–∫—Ä–∞—â–µ–Ω–∏–µ!</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="using-the-field-init-shorthand-when-variables-and-fields-have-the-same-name"></a></p>
<h3 id="–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ-—Å–æ–∫—Ä–∞—â—ë–Ω–Ω–æ–π-–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏-–ø–æ–ª—è"><a class="header" href="#–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ-—Å–æ–∫—Ä–∞—â—ë–Ω–Ω–æ–π-–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏-–ø–æ–ª—è">–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Å–æ–∫—Ä–∞—â—ë–Ω–Ω–æ–π –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –ø–æ–ª—è</a></h3>
<p>–¢–∞–∫ –∫–∞–∫ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 5-4 –∏–º–µ–Ω–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏ –∏ –ø–æ–ª–µ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –æ–¥–Ω–∏ –∏ —Ç–µ –∂–µ, –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å–∏–Ω—Ç–∞–∫—Å–∏—Å —Å–æ–∫—Ä–∞—â—ë–Ω–Ω–æ–π –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –ø–æ–ª—è, —á—Ç–æ–±—ã –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å <code>build_user</code> —Ç–∞–∫, —á—Ç–æ–±—ã –æ–Ω –Ω–µ —Å–æ–¥–µ—Ä–∂–∞–ª –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏–π <code>username</code> –∏ <code>email</code>. –ü–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –Ω–∞ –õ–∏—Å—Ç–∏–Ω–≥ 5-5.</p>
<Listing number="5-5" file-name="src/main.rs" caption="A `build_user` function that uses field init shorthand because the `username` and `email` parameters have the same name as struct fields">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        username,
        email,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from("someone@example.com"),
</span><span class="boring">        String::from("someusername123"),
</span><span class="boring">    );
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>–ó–¥–µ—Å—å –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç —Å–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã <code>User</code>, –∫–æ—Ç–æ—Ä–∞—è –∏–º–µ–µ—Ç –ø–æ–ª–µ —Å –∏–º–µ–Ω–µ–º <code>email</code>. –ú—ã —Ö–æ—Ç–∏–º —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–æ–ª–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã <code>email</code> –∑–Ω–∞—á–µ–Ω–∏–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ <code>email</code> —Ñ—É–Ω–∫—Ü–∏–∏ <code>build_user</code>. –¢–∞–∫ –∫–∞–∫ –ø–æ–ª–µ <code>email</code> –∏ –ø–∞—Ä–∞–º–µ—Ç—Ä —Ñ—É–Ω–∫—Ü–∏–∏ <code>email</code> –∏–º–µ—é—Ç –æ–¥–∏–Ω–∞–∫–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ, –º–æ–∂–Ω–æ –ø–∏—Å–∞—Ç—å –ø—Ä–æ—Å—Ç–æ <code>email</code> –≤–º–µ—Å—Ç–æ <code>email: email</code>.</p>
<h3 id="–°–æ–∑–¥–∞–Ω–∏–µ-—ç–∫–∑–µ–º–ø–ª—è—Ä–∞-—Å—Ç—Ä—É–∫—Ç—É—Ä—ã-–∏–∑-—ç–∫–∑–µ–º–ø–ª—è—Ä–∞-–¥—Ä—É–≥–æ–π-—Å—Ç—Ä—É–∫—Ç—É—Ä—ã-—Å-–ø–æ–º–æ—â—å—é-—Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞-–æ–±–Ω–æ–≤–ª–µ–Ω–∏—è-—Å—Ç—Ä—É–∫—Ç—É—Ä—ã"><a class="header" href="#–°–æ–∑–¥–∞–Ω–∏–µ-—ç–∫–∑–µ–º–ø–ª—è—Ä–∞-—Å—Ç—Ä—É–∫—Ç—É—Ä—ã-–∏–∑-—ç–∫–∑–µ–º–ø–ª—è—Ä–∞-–¥—Ä—É–≥–æ–π-—Å—Ç—Ä—É–∫—Ç—É—Ä—ã-—Å-–ø–æ–º–æ—â—å—é-—Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞-–æ–±–Ω–æ–≤–ª–µ–Ω–∏—è-—Å—Ç—Ä—É–∫—Ç—É—Ä—ã">–°–æ–∑–¥–∞–Ω–∏–µ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –∏–∑ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ –¥—Ä—É–≥–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã —Å –ø–æ–º–æ—â—å—é —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã</a></h3>
<p>–ß–∞—Å—Ç–æ –±—ã–≤–∞–µ—Ç –Ω—É–∂–Ω–æ —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, –∫–æ—Ç–æ—Ä—ã–π –≤–∫–ª—é—á–∞–µ—Ç –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–æ –∑–Ω–∞—á–µ–Ω–∏–π –∏–∑ –¥—Ä—É–≥–æ–≥–æ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞, –Ω–æ –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –∏–∑ –Ω–∏—Ö –∏–∑–º–µ–Ω—è–µ—Ç. –≠—Ç–æ –º–æ–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å —Å –ø–æ–º–æ—â—å—é <em>—Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã</em>.</p>
<p>–í –õ–∏—Å—Ç–∏–Ω–≥–µ 5-6 –ø–æ–∫–∞–∑–∞–Ω–æ, –∫–∞–∫ –≤ <code>user2</code> –∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è –Ω–æ–≤—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä <code>User</code> –±–µ–∑ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è. –ú—ã –∑–∞–¥–∞—ë–º –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è <code>email</code>, –Ω–æ –≤ –æ—Å—Ç–∞–ª—å–Ω–æ–º –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ –∂–µ –∑–Ω–∞—á–µ–Ω–∏—è –∏–∑ <code>user1</code>, –∫–æ—Ç–æ—Ä—É—é –º—ã —Å–æ–∑–¥–∞–ª–∏ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 5-2.</p>
<Listing number="5-6" file-name="src/main.rs" caption="Creating a new `User` instance using all but one of the values from `user1`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from("someone@example.com"),
</span><span class="boring">        username: String::from("someusername123"),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span>
    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from("another@example.com"),
        sign_in_count: user1.sign_in_count,
    };
}</code></pre></pre>
</Listing>
<p>–ò—Å–ø–æ–ª—å–∑—É—è —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, –º–æ–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å —Ç–æ—Ç –∂–µ —ç—Ñ—Ñ–µ–∫—Ç, –∏—Å–ø–æ–ª—å–∑—É—è –º–µ–Ω—å—à–µ –∫–æ–¥–∞, –∫–∞–∫ –ø–æ–∫–∞–∑–∞–Ω–æ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 5-7. –ó–∞–ø–∏—Å—å <code>..</code> —É–∫–∞–∑—ã–≤–∞–µ—Ç, —á—Ç–æ –æ—Å—Ç–∞–≤—à–∏–µ—Å—è –ø–æ–ª—è –Ω–∞–ø—Ä—è–º—É—é –Ω–µ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—é—Ç—Å—è, –Ω–æ –¥–æ–ª–∂–Ω—ã –∏–º–µ—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è –∏–∑ —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞.</p>
<Listing number="5-7" file-name="src/main.rs" caption="Using struct update syntax to set a new `email` value for a `User` instance but to use the rest of the values from `user1`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from("someone@example.com"),
</span><span class="boring">        username: String::from("someusername123"),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span>
    let user2 = User {
        email: String::from("another@example.com"),
        ..user1
    };
}</code></pre></pre>
</Listing>
<p>–ö–æ–¥ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 5-7 —Ç–æ–∂–µ —Å–æ–∑–¥–∞—ë—Ç —ç–∫–∑–µ–º–ø–ª—è—Ä <code>user2</code>, –∫–æ—Ç–æ—Ä—ã–π –∏–º–µ–µ—Ç –¥—Ä—É–≥–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ <code>email</code>, –Ω–æ –Ω–µ –º–µ–Ω—è–µ—Ç –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ–ª–µ–π <code>username</code>, <code>active</code> –∏ <code>sign_in_count</code> –∏–∑ <code>user1</code>. –ö–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏—è <code>..user1</code> –¥–æ–ª–∂–Ω–∞ —Å—Ç–æ—è—Ç—å –ø–æ—Å–ª–µ–¥–Ω–µ–π; –æ–Ω–∞ —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ –ø–æ–ª—É—á–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏–π –≤—Å–µ—Ö –æ—Å—Ç–∞–≤—à–∏—Ö—Å—è –ø–æ–ª–µ–π –∏–∑ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏—Ö –ø–æ–ª–µ–π –≤ <code>user1</code>, –Ω–æ –ø–µ—Ä–µ–¥ —ç—Ç–∏–º –º—ã –º–æ–∂–µ–º —É–∫–∞–∑–∞—Ç—å —Å–≤–æ–∏ –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è –ª—é–±—ã—Ö –ø–æ–ª–µ–π –≤ –ª—é–±–æ–º –ø–æ—Ä—è–¥–∫–µ, –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –æ—Ç –ø–æ—Ä—è–¥–∫–∞ –ø–æ–ª–µ–π –≤ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã.</p>
<p>–°—Ç–æ–∏—Ç –æ—Ç–º–µ—Ç–∏—Ç—å, —á—Ç–æ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –æ–ø–µ—Ä–∞—Ç–æ—Ä <code>=</code> –∫–∞–∫ –æ–ø–µ—Ä–∞—Ç–æ—Ä –ø—Ä–∏—Å–≤–∞–∏–≤–∞–Ω–∏—è, –ø–æ—Ç–æ–º—É —á—Ç–æ –æ–Ω –ø–µ—Ä–µ–º–µ—â–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ, –∫–∞–∫ –º—ã –≤–∏–¥–µ–ª–∏ –≤ —Ä–∞–∑–¥–µ–ª–µ <a href="ch04-01-what-is-ownership.html#%D0%92%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D0%B5-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85-%D0%B8-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D1%89%D0%B5%D0%BD%D0%B8%D1%8F">"–í–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –∏ –¥–∞–Ω–Ω—ã—Ö —Å –ø–æ–º–æ—â—å—é –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è"</a><!-- ignore -->. –í –ø—Ä–∏–º–µ—Ä–µ –≤—ã—à–µ –º—ã –±–æ–ª—å—à–µ –Ω–µ –º–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å <code>user1</code> –ø–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è  <code>user2</code>, –ø–æ—Ç–æ–º—É —á—Ç–æ <code>String</code> –≤ –ø–æ–ª–µ <code>username</code> –∏–∑ <code>user1</code> –±—ã–ª–æ –ø–µ—Ä–µ–º–µ—â–µ–Ω–æ –≤ <code>user2</code>. –ï—Å–ª–∏ –±—ã –º—ã –∑–∞–¥–∞–ª–∏ <code>user2</code> –Ω–æ–≤—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è <code>String</code> –¥–ª—è <code>email</code> –∏ <code>username</code>, –∏, —Ç–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ —Ç–æ–ª—å–∫–æ –∑–Ω–∞—á–µ–Ω–∏—è <code>active</code> –∏ <code>sign_in_count</code> –∏–∑ <code>user1</code>, —Ç–æ <code>user1</code> –≤—Å—ë –µ—â—ë –±—ã–ª–∞ –±—ã –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ–π –ø–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è <code>user2</code>. –û–±–∞ —Ç–∏–ø–∞ <code>active</code> –∏ <code>sign_in_count</code> —Ä–µ–∞–ª–∏–∑—É—é—Ç —Ç—Ä–µ–π—Ç <code>Copy</code>, –ø–æ—ç—Ç–æ–º—É –æ–Ω–∏ –≤–µ–¥—É—Ç —Å–µ–±—è —Ç–∞–∫, –∫–∞–∫ –º—ã –æ–±—Å—É–∂–¥–∞–ª–∏ –≤ —Ä–∞–∑–¥–µ–ª–µ <a href="ch04-01-what-is-ownership.html#%D0%94%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5-%D1%80%D0%B0%D0%B7%D0%BC%D0%B5%D1%89%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%D1%81%D1%8F-%D1%82%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE-%D0%BD%D0%B0-%D1%81%D1%82%D0%B5%D0%BA%D0%B5-%D0%B2%D1%81%D0%B5%D0%B3%D0%B4%D0%B0-%D0%BA%D0%BE%D0%BF%D0%B8%D1%80%D1%83%D1%8E%D1%82%D1%81%D1%8F">"–î–∞–Ω–Ω—ã–µ, —Ä–∞–∑–º–µ—â–∞—é—â–∏–µ—Å—è —Ç–æ–ª—å–∫–æ –Ω–∞ —Å—Ç–µ–∫–µ, –≤—Å–µ–≥–¥–∞ –∫–æ–ø–∏—Ä—É—é—Ç—Å—è"</a><!-- ignore -->. –û–¥–Ω–∞–∫–æ, –≤ –Ω–∞—à–µ–º –ø—Ä–∏–º–µ—Ä–µ –º—ã –≤—Å—ë –µ—â—ë –º–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∑–∞–ø–∏—Å—å <code>user1.email</code>, –ø–æ—Å–∫–æ–ª—å–∫—É –∑–Ω–∞—á–µ–Ω–∏–µ —ç—Ç–æ–≥–æ –ø–æ–ª—è <em>–Ω–µ –±—ã–ª–æ</em> –ø–µ—Ä–µ–º–µ—â–µ–Ω–æ.</p>
<h3 id="–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ-–∫–æ—Ä—Ç–µ–∂–Ω—ã—Ö-—Å—Ç—Ä—É–∫—Ç—É—Ä-–±–µ–∑-–∏–º—ë–Ω-–¥–ª—è-—Å–æ–∑–¥–∞–Ω–∏—è-—Ä–∞–∑–Ω—ã—Ö-—Ç–∏–ø–æ–≤"><a class="header" href="#–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ-–∫–æ—Ä—Ç–µ–∂–Ω—ã—Ö-—Å—Ç—Ä—É–∫—Ç—É—Ä-–±–µ–∑-–∏–º—ë–Ω-–¥–ª—è-—Å–æ–∑–¥–∞–Ω–∏—è-—Ä–∞–∑–Ω—ã—Ö-—Ç–∏–ø–æ–≤">–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∫–æ—Ä—Ç–µ–∂–Ω—ã—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä –±–µ–∑ –∏–º—ë–Ω –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤</a></h3>
<p>Rust —Ç–∞–∫–∂–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä, –ø–æ—Ö–æ–∂–∏—Ö –Ω–∞ –∫–æ—Ä—Ç–µ–∂–∏, –∫–æ—Ç–æ—Ä—ã–µ –Ω–∞–∑—ã–≤–∞—é—Ç—Å—è <em>–∫–æ—Ä—Ç–µ–∂–Ω—ã–º–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞–º–∏</em>. –ö–æ—Ä—Ç–µ–∂–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –Ω–µ—Å—É—Ç —Å —Å–æ–±–æ–π –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π —Å–º—ã—Å–ª, –æ–ø—Ä–µ–¥–µ–ª—è–µ–º—ã–π –∏–º–µ–Ω–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, –Ω–æ –ø—Ä–∏ —ç—Ç–æ–º –æ–Ω–∏ –Ω–µ –∏–º–µ—é—Ç –∏–º—ë–Ω –¥–ª—è —Å–≤–æ–∏—Ö –ø–æ–ª–µ–π. –°–∫–æ—Ä–µ–µ, –æ–Ω–∏ –ø—Ä–æ—Å—Ç–æ —Ö—Ä–∞–Ω—è—Ç —Ç–∏–ø—ã –ø–æ–ª–µ–π. –ö–æ—Ä—Ç–µ–∂–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –ø–æ–ª–µ–∑–Ω—ã, –∫–æ–≥–¥–∞ –≤—ã —Ö–æ—Ç–∏—Ç–µ –¥–∞—Ç—å –∏–º—è –≤—Å–µ–º—É –∫–æ—Ä—Ç–µ–∂—É –∏ —Å–¥–µ–ª–∞—Ç—å –∫–æ—Ä—Ç–µ–∂ –æ—Ç–ª–∏—á–Ω—ã–º –æ—Ç –¥—Ä—É–≥–∏—Ö –∫–æ—Ä—Ç–µ–∂–µ–π, –∏ –∫–æ–≥–¥–∞ –∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –∫–∞–∂–¥–æ–≥–æ –ø–æ–ª—è, –∫–∞–∫ –≤ –æ–±—ã—á–Ω–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä–µ, –±—ã–ª–æ –±—ã –º–Ω–æ–≥–æ—Å–ª–æ–≤–Ω—ã–º –∏–ª–∏ –∏–∑–±—ã—Ç–æ—á–Ω—ã–º.</p>
<p>–ß—Ç–æ–±—ã –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∫–æ—Ä—Ç–µ–∂–Ω—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É, –Ω–∞—á–Ω–∏—Ç–µ —Å –∫–ª—é—á–µ–≤–æ–≥–æ —Å–ª–æ–≤–∞ <code>struct</code> –∏ –∏–º–µ–Ω–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, –∞ —Å–ª–µ–¥–æ–º –ø—Ä–∏–ø–∏—à–∏—Ç–µ —Ç–∏–ø –∫–æ—Ä—Ç–µ–∂–∞. –ù–∞–ø—Ä–∏–º–µ—Ä, –≤–æ—Ç –∫–∞–∫ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –¥–≤–µ –∫–æ—Ä—Ç–µ–∂–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã —Å –∏–º–µ–Ω–∞–º–∏ <code>Color</code> –∏ <code>Point</code>:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021">struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}</code></pre></pre>
</Listing>
<p>–û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ –∑–Ω–∞—á–µ–Ω–∏—è <code>black</code> –∏ <code>origin</code> ‚Äî —ç—Ç–æ –∑–Ω–∞—á–µ–Ω–∏—è —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤, –ø–æ—Ç–æ–º—É —á—Ç–æ –æ–Ω–∏ —è–≤–ª—è—é—Ç—Å—è —ç–∫–∑–µ–º–ø–ª—è—Ä–∞–º–∏ —Ä–∞–∑–Ω—ã—Ö –∫–æ—Ä—Ç–µ–∂–Ω—ã—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä. –ö–∞–∂–¥–∞—è –æ–ø—Ä–µ–¥–µ–ª—è–µ–º–∞—è –≤–∞–º–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –∏–º–µ–µ—Ç —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–π —Ç–∏–ø, –¥–∞–∂–µ –µ—Å–ª–∏ –ø–æ–ª—è –≤–Ω—É—Ç—Ä–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, –≤–æ–∑–º–æ–∂–Ω–æ, –∏–º–µ—é—Ç –≤—Å–µ –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ —Ç–∏–ø—ã. –ù–∞–ø—Ä–∏–º–µ—Ä, —Ñ—É–Ω–∫—Ü–∏—è —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–º —Ç–∏–ø–∞ <code>Color</code> –Ω–µ –º–æ–∂–µ—Ç –ø—Ä–∏–Ω–∏–º–∞—Ç—å <code>Point</code> –≤ –∫–∞—á–µ—Å—Ç–≤–µ –∞—Ä–≥—É–º–µ–Ω—Ç–∞, –ø—É—Å—Ç—å –¥–∞–∂–µ –æ–±–∞ —Ç–∏–ø–∞ —Å–æ—Å—Ç–æ—è—Ç –∏–∑ —Ç—Ä—ë—Ö –∑–Ω–∞—á–µ–Ω–∏–π <code>i32</code>. –í –æ—Å—Ç–∞–ª—å–Ω–æ–º —ç–∫–∑–µ–º–ø–ª—è—Ä—ã –∫–æ—Ä—Ç–µ–∂–Ω—ã—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä –ø–æ—Ö–æ–∂–∏ –Ω–∞ –∫–æ—Ä—Ç–µ–∂–∏ –≤ —Ç–æ–º —Å–º—ã—Å–ª–µ, —á—Ç–æ –≤—ã –º–æ–∂–µ—Ç–µ –¥–µ—Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞—Ç—å –∏—Ö –Ω–∞ –æ—Ç–¥–µ–ª—å–Ω—ã–µ —á–∞—Å—Ç–∏ –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ –æ—Ç–¥–µ–ª—å–Ω–æ–º—É –∑–Ω–∞—á–µ–Ω–∏—é –æ–ø–µ—Ä–∞—Ç–æ—Ä <code>.</code>, –∑–∞ –∫–æ—Ç–æ—Ä–æ–π —Å–ª–µ–¥—É–µ—Ç –∏–Ω–¥–µ–∫—Å.</p>
<h3 id="unit-–ø–æ–¥–æ–±–Ω—ã–µ-—Å—Ç—Ä—É–∫—Ç—É—Ä—ã"><a class="header" href="#unit-–ø–æ–¥–æ–±–Ω—ã–µ-—Å—Ç—Ä—É–∫—Ç—É—Ä—ã">Unit-–ø–æ–¥–æ–±–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã</a></h3>
<p>–¢–∞–∫–∂–µ –º–æ–∂–Ω–æ –æ–ø—Ä–µ–¥–µ–ª—è—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, –Ω–µ –∏–º–µ—é—â–∏–µ –ø–æ–ª–µ–π! –û–Ω–∏ –Ω–∞–∑—ã–≤–∞—é—Ç—Å—è <em>unit-–ø–æ–¥–æ–±–Ω—ã–º–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞–º–∏</em>, –ø–æ—Å–∫–æ–ª—å–∫—É –≤–µ–¥—É—Ç —Å–µ–±—è –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ <code>()</code>, unit, –æ –∫–æ—Ç–æ—Ä–æ–º –º—ã –≥–æ–≤–æ—Ä–∏–ª–∏ –≤ —Ä–∞–∑–¥–µ–ª–µ ["–¢–∏–ø –∫–æ—Ä—Ç–µ–∂–∞"] (ch03-02-data-types.html#–¢–∏–ø-–∫–æ—Ä—Ç–µ–∂–∞)<!-- ignore -->. Unit-–ø–æ–¥–æ–±–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –º–æ–≥—É—Ç –±—ã—Ç—å –ø–æ–ª–µ–∑–Ω—ã, –∫–æ–≥–¥–∞ —Ç—Ä–µ–±—É–µ—Ç—Å—è —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Ç—Ä–µ–π—Ç –¥–ª—è –Ω–µ–∫–æ—Ç–æ—Ä–æ–≥–æ —Ç–∏–ø–∞, –Ω–æ —É –≤–∞—Å –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö, –∫–æ—Ç–æ—Ä—ã–µ –Ω—É–∂–Ω–æ –±—ã–ª–æ –±—ã —Ö—Ä–∞–Ω–∏—Ç—å –≤ —Å–∞–º–æ–º —Ç–∏–ø–µ. –ú—ã –æ–±—Å—É–¥–∏–º —Ç—Ä–µ–π—Ç—ã –≤ –ì–ª–∞–≤–µ 10. –í–æ—Ç –ø—Ä–∏–º–µ—Ä –æ–±—ä—è–≤–ª–µ–Ω–∏—è –∏ —Å–æ–∑–¥–∞–Ω–∏—è —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ unit-—Å—Ç—Ä—É–∫—Ç—É—Ä—ã —Å –∏–º–µ–Ω–µ–º <code>AlwaysEqual</code>:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021">struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}</code></pre></pre>
</Listing>
<p>–ß—Ç–æ–±—ã –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å <code>AlwaysEqual</code>, –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ <code>struct</code>, –∂–µ–ª–∞–µ–º–æ–µ –∏–º—è, –∞ –∑–∞—Ç–µ–º —Ç–æ—á–∫—É —Å –∑–∞–ø—è—Ç–æ–π. –ù–µ –Ω—É–∂–Ω—ã –Ω–∏ —Ñ–∏–≥—É—Ä–Ω—ã–µ, –Ω–∏ –∫—Ä—É–≥–ª—ã–µ —Å–∫–æ–±–∫–∏! –ó–∞—Ç–µ–º –º—ã —Å–æ–∑–¥–∞—ë–º —ç–∫–∑–µ–º–ø–ª—è—Ä <code>AlwaysEqual</code> –∏ –ø—Ä–∏—Å–≤–∞–∏–≤–∞–µ–º –µ–≥–æ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π <code>subject</code>, –∏—Å–ø–æ–ª—å–∑—É—è –∏–º—è, –∫–æ—Ç–æ—Ä–æ–µ –º—ã –æ–ø—Ä–µ–¥–µ–ª–∏–ª–∏, –±–µ–∑ (–∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—é) —Ñ–∏–≥—É—Ä–Ω—ã—Ö –∏ –∫—Ä—É–≥–ª—ã—Ö —Å–∫–æ–±–æ–∫. –ü—Ä–µ–¥—Å—Ç–∞–≤–∏–º, —á—Ç–æ –≤ –¥–∞–ª—å–Ω–µ–π—à–µ–º –º—ã —Ä–µ–∞–ª–∏–∑—É–µ–º –ø–æ–≤–µ–¥–µ–Ω–∏–µ –¥–ª—è —ç—Ç–æ–≥–æ —Ç–∏–ø–∞ —Ç–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, —á—Ç–æ –∫–∞–∂–¥—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä <code>AlwaysEqual</code> –≤—Å–µ–≥–¥–∞ –±—É–¥–µ—Ç —Ä–∞–≤–µ–Ω –∫–∞–∂–¥–æ–º—É —ç–∫–∑–µ–º–ø–ª—è—Ä—É –ª—é–±–æ–≥–æ –¥—Ä—É–≥–æ–≥–æ —Ç–∏–ø–∞, –≤–æ–∑–º–æ–∂–Ω–æ, —Å —Ü–µ–ª—å—é –ø–æ–ª—É—á–µ–Ω–∏—è –æ–∂–∏–¥–∞–µ–º–æ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è. –î–ª—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ —Ç–∞–∫–æ–≥–æ –ø–æ–≤–µ–¥–µ–Ω–∏—è –Ω–∞–º –Ω–µ –Ω—É–∂–Ω—ã –Ω–∏–∫–∞–∫–∏–µ –¥–∞–Ω–Ω—ã–µ! –í –ì–ª–∞–≤–µ 10 –≤—ã —É–≤–∏–¥–∏—Ç–µ, –∫–∞–∫ –æ–ø—Ä–µ–¥–µ–ª—è—Ç—å —Ç—Ä–µ–π—Ç—ã –∏ —Ä–µ–∞–ª–∏–∑–æ–≤—ã–≤–∞—Ç—å –∏—Ö –¥–ª—è –ª—é–±—ã—Ö —Ç–∏–ø–æ–≤, –≤–∫–ª—é—á–∞—è unit-–ø–æ–¥–æ–±–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã.</p>
<blockquote>
<h3 id="–í–ª–∞–¥–µ–Ω–∏–µ-–¥–∞–Ω–Ω—ã–º–∏-—Å—Ç—Ä—É–∫—Ç—É—Ä—ã"><a class="header" href="#–í–ª–∞–¥–µ–Ω–∏–µ-–¥–∞–Ω–Ω—ã–º–∏-—Å—Ç—Ä—É–∫—Ç—É—Ä—ã">–í–ª–∞–¥–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã–º–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã</a></h3>
<p>–í –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã <code>User</code> –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 5-1 –º—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ "–≤–ª–∞–¥–µ–µ–º—ã–π" —Ç–∏–ø <code>String</code>, –∞ –Ω–µ —Ç–∏–ø <code>&amp;str</code> —Å—Ä–µ–∑–∞ —Å—Ç—Ä–æ–∫–∏. –≠—Ç–æ –æ—Å–æ–∑–Ω–∞–Ω–Ω—ã–π –≤—ã–±–æ—Ä, –ø–æ—Å–∫–æ–ª—å–∫—É –º—ã —Ö–æ—Ç–∏–º, —á—Ç–æ–±—ã –∫–∞–∂–¥—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä —ç—Ç–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –≤–ª–∞–¥–µ–ª –≤—Å–µ–º–∏ —Å–≤–æ–∏–º–∏ –¥–∞–Ω–Ω—ã–º–∏ –∏ —á—Ç–æ–±—ã —ç—Ç–∏ –¥–∞–Ω–Ω—ã–µ –±—ã–ª–∏ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã –¥–æ —Ç–µ—Ö –ø–æ—Ä, –ø–æ–∫–∞ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞ –≤—Å—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞.</p>
<p>–°—Ç—Ä—É–∫—Ç—É—Ä—ã —Ç–∞–∫–∂–µ –º–æ–≥—É—Ç —Ö—Ä–∞–Ω–∏—Ç—å —Å—Å—ã–ª–∫–∏, –Ω–æ –¥–ª—è —ç—Ç–æ–≥–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å <em>–≤—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏</em> ‚Äî –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç—å Rust, –∫–æ—Ç–æ—Ä—É—é –º—ã –æ–±—Å—É–¥–∏–º –≤ –ì–ª–∞–≤–µ 10. –í—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏ –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É—é—Ç, —á—Ç–æ –¥–∞–Ω–Ω—ã–µ, –Ω–∞ –∫–æ—Ç–æ—Ä—ã–µ —Å—Å—ã–ª–∞—é—Ç—Å—è –ø–æ–ª—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, –±—É–¥—É—Ç –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã –ø–æ –∫—Ä–∞–π–Ω–µ–π –º–µ—Ä–µ –ø–æ–∫–∞ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä–∞. –ü–æ–ø—ã—Ç–∞–µ–º—Å—è —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å—Å—ã–ª–∫—É –≤ —Å—Ç—Ä—É–∫—Ç—É—Ä–µ –±–µ–∑ —É–∫–∞–∑–∞–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏, –∫–∞–∫ –≤ —Å–ª–µ–¥—É—é—â–µ–º –ø—Ä–∏–º–µ—Ä–µ; —ç—Ç–æ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–µ—Ç:</p>
<Listing file-name="src/main.rs">
<!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><code class="language-rust ignore does_not_compile">struct User {
    active: bool,
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        active: true,
        username: "someusername123",
        email: "someone@example.com",
        sign_in_count: 1,
    };
}</code></pre>
</Listing>
<p>–ö–æ–º–ø–∏–ª—è—Ç–æ—Ä –±—É–¥–µ—Ç –∂–∞–ª–æ–≤–∞—Ç—å—Å—è –Ω–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç—å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏ —Å—Å—ã–ª–æ–∫:</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:3:15
  |
3 |     username: &amp;str,
  |               ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     active: bool,
3 ~     username: &amp;'a str,
  |

error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:4:12
  |
4 |     email: &amp;str,
  |            ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     active: bool,
3 |     username: &amp;str,
4 ~     email: &amp;'a str,
  |

For more information about this error, try `rustc --explain E0106`.
error: could not compile `structs` (bin "structs") due to 2 previous errors
</code></pre>
<p>–í –ì–ª–∞–≤–µ 10 –º—ã –æ–±—Å—É–¥–∏–º, –∫–∞–∫ –∏—Å–ø—Ä–∞–≤–ª—è—Ç—å —ç—Ç–∏ –æ—à–∏–±–∫–∏, —á—Ç–æ–±—ã –∏–º–µ—Ç—å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å —Ö—Ä–∞–Ω–∏—Ç—å —Å—Å—ã–ª–∫–∏ –≤ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞—Ö, –∞ –¥–æ —Ç–µ—Ö –ø–æ—Ä –º—ã –±—É–¥–µ–º –æ–±—Ö–æ–¥–∏—Ç—å –ø–æ–¥–æ–±–Ω—ã–µ –æ—à–∏–±–∫–∏, –∏—Å–ø–æ–ª—å–∑—É—è –≤–ª–∞–¥–µ–µ–º—ã–µ —Ç–∏–ø—ã –≤—Ä–æ–¥–µ <code>String</code> –≤–º–µ—Å—Ç–æ —Å—Å—ã–ª–æ–∫ –≤—Ä–æ–¥–µ <code>&amp;str</code>.</p>
</blockquote>
<!-- manual-regeneration
for the error above
after running update-rustc.sh:
pbcopy < listings/ch05-using-structs-to-structure-related-data/no-listing-02-reference-in-struct/output.txt
paste above
add `> ` before every line -->
<div style="break-before: page; page-break-before: always;"></div><h2 id="–ü—Ä–∏–º–µ—Ä-–ø—Ä–æ–≥—Ä–∞–º–º—ã-–∏—Å–ø–æ–ª—å–∑—É—é—â–µ–π-—Å—Ç—Ä—É–∫—Ç—É—Ä—ã"><a class="header" href="#–ü—Ä–∏–º–µ—Ä-–ø—Ä–æ–≥—Ä–∞–º–º—ã-–∏—Å–ø–æ–ª—å–∑—É—é—â–µ–π-—Å—Ç—Ä—É–∫—Ç—É—Ä—ã">–ü—Ä–∏–º–µ—Ä –ø—Ä–æ–≥—Ä–∞–º–º—ã, –∏—Å–ø–æ–ª—å–∑—É—é—â–µ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã</a></h2>
<p>–ß—Ç–æ–±—ã –ø–æ–Ω—è—Ç—å, –∫–æ–≥–¥–∞ –Ω–∞–º –º–æ–≥—É—Ç –ø–æ–Ω–∞–¥–æ–±–∏—Ç—å—Å—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, –¥–∞–≤–∞–π—Ç–µ –Ω–∞–ø–∏—à–µ–º –ø—Ä–æ–≥—Ä–∞–º–º—É, –∫–æ—Ç–æ—Ä–∞—è –≤—ã—á–∏—Å–ª—è–µ—Ç –ø–ª–æ—â–∞–¥—å –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∞. –ú—ã –Ω–∞—á–Ω—ë–º —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –æ–¥–∏–Ω–æ—á–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö, –∞ –∑–∞—Ç–µ–º –±—É–¥–µ–º —É–ª—É—á—à–∞—Ç—å –ø—Ä–æ–≥—Ä–∞–º–º—É –¥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä.</p>
<p>–î–∞–≤–∞–π—Ç–µ —Å–æ–∑–¥–∞–¥–∏–º –Ω–æ–≤—ã–π –ø—Ä–æ–µ–∫—Ç –ø—Ä–æ–≥—Ä–∞–º–º—ã –ø—Ä–∏ –ø–æ–º–æ—â–∏ Cargo –∏ –Ω–∞–∑–æ–≤—ë–º –µ–≥–æ <em>rectangles</em>. –ù–∞—à–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∞ –±—É–¥–µ—Ç –ø–æ–ª—É—á–∞—Ç—å –Ω–∞ –≤—Ö–æ–¥ –¥–ª–∏–Ω—É –∏ —à–∏—Ä–∏–Ω—É –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∞ –≤ –ø–∏–∫—Å–µ–ª—è—Ö –∏ –∑–∞—Ç–µ–º —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞—Ç—å –ø–ª–æ—â–∞–¥—å –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∞. –õ–∏—Å—Ç–∏–Ω–≥ 5-8 –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –æ–¥–∏–Ω –∏–∑ –∫–æ—Ä–æ—Ç–∫–∏—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –∫–æ–¥–∞, –∫–æ—Ç–æ—Ä—ã–π –ø–æ–∑–≤–æ–ª–∏—Ç –Ω–∞–º —Å–¥–µ–ª–∞—Ç—å –∏–º–µ–Ω–Ω–æ —Ç–æ, —á—Ç–æ –Ω–∞–¥–æ.</p>
<Listing number="5-8" file-name="src/main.rs" caption="Calculating the area of a rectangle specified by separate width and height variables">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let width1 = 30;
    let height1 = 50;

    println!(
        "–ü–ª–æ—â–∞–¥—å –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∞ —Ä–∞–≤–Ω–∞ {} –∫–≤–∞–¥—Ä–∞—Ç–Ω—ã—Ö –ø–∏–∫—Å–µ–ª–µ–π.",
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -&gt; u32 {
    width * height
}</code></pre></pre>
</Listing>
<p>–¢–µ–ø–µ—Ä—å –∑–∞–ø—É—Å—Ç–∏–º –ø—Ä–æ–≥—Ä–∞–º–º—É, –∏—Å–ø–æ–ª—å–∑—É—è <code>cargo run</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/rectangles`
–ü–ª–æ—â–∞–¥—å –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∞ —Ä–∞–≤–Ω–∞ 1500 –∫–≤–∞–¥—Ä–∞—Ç–Ω—ã—Ö –ø–∏–∫—Å–µ–ª–µ–π.
</code></pre>
<p>–≠—Ç–æ—Ç –∫–æ–¥ —É—Å–ø–µ—à–Ω–æ –≤—ã—á–∏—Å–ª—è–µ—Ç –ø–ª–æ—â–∞–¥—å –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∞, –≤—ã–∑—ã–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—é <code>area</code> —Å –∫–∞–∂–¥—ã–º –∏–∑–º–µ—Ä–µ–Ω–∏–µ–º, –Ω–æ –º—ã –º–æ–∂–µ–º —É–ª—É—á—à–∏—Ç—å –µ–≥–æ —è—Å–Ω–æ—Å—Ç—å –∏ —á–∏—Ç–∞–±–µ–ª—å–Ω–æ—Å—Ç—å.</p>
<p>–ü—Ä–æ–±–ª–µ–º–∞ –¥–∞–Ω–Ω–æ–≥–æ –º–µ—Ç–æ–¥–∞ –æ—á–µ–≤–∏–¥–Ω–∞, –µ—Å–ª–∏ –≤–∑–≥–ª—è–Ω—É—Ç—å –Ω–∞ —Å–∏–≥–Ω–∞—Ç—É—Ä—É <code>area</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    let width1 = 30;
</span><span class="boring">    let height1 = 50;
</span><span class="boring">
</span><span class="boring">    println!(
</span><span class="boring">        "–ü–ª–æ—â–∞–¥—å –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∞ —Ä–∞–≤–Ω–∞ {} –∫–≤–∞–¥—Ä–∞—Ç–Ω—ã—Ö –ø–∏–∫—Å–µ–ª–µ–π.",
</span><span class="boring">        area(width1, height1)
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span>fn area(width: u32, height: u32) -&gt; u32 {
<span class="boring">    width * height
</span><span class="boring">}</span></code></pre>
<p>–§—É–Ω–∫—Ü–∏—è <code>area</code> –¥–æ–ª–∂–Ω–∞ –≤—ã—á–∏—Å–ª—è—Ç—å –ø–ª–æ—â–∞–¥—å –æ–¥–Ω–æ–≥–æ –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∞, –Ω–æ —Ñ—É–Ω–∫—Ü–∏—è, –∫–æ—Ç–æ—Ä—É—é –º—ã –Ω–∞–ø–∏—Å–∞–ª–∏, –∏–º–µ–µ—Ç –¥–≤–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞, –∏ –Ω–∏–≥–¥–µ –≤ –Ω–∞—à–µ–π –ø—Ä–æ–≥—Ä–∞–º–º–µ –Ω–µ —è—Å–Ω–æ, —á—Ç–æ —ç—Ç–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤–∑–∞–∏–º–æ—Å–≤—è–∑–∞–Ω—ã. –ë—ã–ª–æ –±—ã –±–æ–ª–µ–µ —á–∏—Ç–∞–±–µ–ª—å–Ω—ã–º –∏ –æ—Ä–≥–∞–Ω–∏–∑–æ–≤–∞–Ω–Ω—ã–º —Å–≥—Ä—É–ø–ø–∏—Ä–æ–≤–∞—Ç—å —à–∏—Ä–∏–Ω—É –∏ –≤—ã—Å–æ—Ç—É –≤–º–µ—Å—Ç–µ. –í —Ä–∞–∑–¥–µ–ª–µ <a href="ch03-02-data-types.html#%D0%A2%D0%B8%D0%BF-%D0%BA%D0%BE%D1%80%D1%82%D0%B5%D0%B6%D0%B0">"–ö–æ—Ä—Ç–µ–∂–∏"</a><!-- ignore --> –ì–ª–∞–≤—ã 3 –º—ã —É–∂–µ –æ–±—Å—É–∂–¥–∞–ª–∏ –æ–¥–∏–Ω –∏–∑ —Å–ø–æ—Å–æ–±–æ–≤ —Å–¥–µ–ª–∞—Ç—å —ç—Ç–æ ‚Äî –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–æ—Ä—Ç–µ–∂–∏.</p>
<h3 id="–†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥-–≤–Ω–µ–¥—Ä–µ–Ω–∏–µ–º-–∫–æ—Ä—Ç–µ–∂–µ–π"><a class="header" href="#–†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥-–≤–Ω–µ–¥—Ä–µ–Ω–∏–µ–º-–∫–æ—Ä—Ç–µ–∂–µ–π">–†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ –≤–Ω–µ–¥—Ä–µ–Ω–∏–µ–º –∫–æ—Ä—Ç–µ–∂–µ–π</a></h3>
<p>–õ–∏—Å—Ç–∏–Ω–≥ 5-9 ‚Äî —ç—Ç–æ –¥—Ä—É–≥–∞—è –≤–µ—Ä—Å–∏—è –ø—Ä–æ–≥—Ä–∞–º–º—ã, –∏—Å–ø–æ–ª—å–∑—É—é—â–∞—è –∫–æ—Ä—Ç–µ–∂–∏.</p>
<Listing number="5-9" file-name="src/main.rs" caption="Specifying the width and height of the rectangle with a tuple">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let rect1 = (30, 50);

    println!(
        "–ü–ª–æ—â–∞–¥—å –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∞ —Ä–∞–≤–Ω–∞ {} –∫–≤–∞–¥—Ä–∞—Ç–Ω—ã—Ö –ø–∏–∫—Å–µ–ª–µ–π.",
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -&gt; u32 {
    dimensions.0 * dimensions.1
}</code></pre></pre>
</Listing>
<p>–° –æ–¥–Ω–æ–π —Å—Ç–æ—Ä–æ–Ω—ã, —ç—Ç–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∞ –ª—É—á—à–µ. –ö–æ—Ä—Ç–µ–∂–∏ –ø–æ–∑–≤–æ–ª—è—é—Ç –¥–æ–±–∞–≤–∏—Ç—å –Ω–µ–º–Ω–æ–≥–æ –æ—Ä–≥–∞–Ω–∏–∑–æ–≤–∞–Ω–Ω–æ—Å—Ç–∏, –∏ —Ç–µ–ø–µ—Ä—å –º—ã –ø–µ—Ä–µ–¥–∞—ë–º —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω –∞—Ä–≥—É–º–µ–Ω—Ç. –ù–æ —Å –¥—Ä—É–≥–æ–π —Å—Ç–æ—Ä–æ–Ω—ã, —ç—Ç–∞ –≤–µ—Ä—Å–∏—è –≤—Å—ë –µ—â—ë –Ω–µ –≤–ø–æ–ª–Ω–µ –ø–æ–Ω—è—Ç–Ω–∞: –∑–Ω–∞—á–µ–Ω–∏—è –≤ –∫–æ—Ä—Ç–µ–∂–∞—Ö –Ω–µ –∏–º–µ–Ω–æ–≤–∞–Ω—ã, –ø–æ—ç—Ç–æ–º—É –Ω–∞–º –ø—Ä–∏—Ö–æ–¥–∏—Ç—Å—è –æ–±—Ä–∞—â–∞—Ç—å—Å—è –∫ –Ω–∏–º –ø–æ –∏–Ω–¥–µ–∫—Å–∞–º, —á—Ç–æ –¥–µ–ª–∞–µ—Ç –Ω–∞—à–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ –º–µ–Ω–µ–µ –ø–æ–Ω—è—Ç–Ω—ã–º.</p>
<p>–ï—Å–ª–∏ –º—ã –ø–µ—Ä–µ–ø—É—Ç–∞–µ–º –º–µ—Å—Ç–∞–º–∏ —à–∏—Ä–∏–Ω—É —Å –≤—ã—Å–æ—Ç–æ–π –ø—Ä–∏ —Ä–∞—Å—á—ë—Ç–µ –ø–ª–æ—â–∞–¥–∏, —Ç–æ –Ω–∏—á–µ–≥–æ —Å—Ç—Ä–∞—à–Ω–æ–≥–æ –Ω–µ –ø—Ä–æ–∏–∑–æ–π–¥—ë—Ç. –ù–æ –µ—Å–ª–∏ –º—ã –∑–∞—Ö–æ—Ç–∏–º –Ω–∞—Ä–∏—Å–æ–≤–∞—Ç—å –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ –Ω–∞ —ç–∫—Ä–∞–Ω–µ, —Ç–æ —ç—Ç–æ —É–∂–µ –±—É–¥–µ—Ç –≤–∞–∂–Ω–æ! –ú—ã –¥–æ–ª–∂–Ω—ã –ø–æ–º–Ω–∏—Ç—å, —á—Ç–æ —à–∏—Ä–∏–Ω–∞ <code>width</code> –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ –∫–æ—Ä—Ç–µ–∂–µ –ø–æ –∏–Ω–¥–µ–∫—Å—É <code>0</code>, –∞ –≤—ã—Å–æ—Ç–∞ <code>height</code> ‚Äî –ø–æ –∏–Ω–¥–µ–∫—Å—É <code>1</code>. –ï—Å–ª–∏ –∫—Ç–æ-—Ç–æ –¥—Ä—É–≥–æ–π —Ä–∞–±–æ—Ç–∞–ª –±—ã —Å –Ω–∞—à–∏–º –∫–æ–¥–æ–º, –µ–º—É –±—ã –ø—Ä–∏—à–ª–æ—Å—å —Ä–∞–∑–±–∏—Ä–∞—Ç—å—Å—è –≤ —ç—Ç–æ–º –∏ —Ç–∞–∫–∂–µ –ø–æ–º–Ω–∏—Ç—å –ø—Ä–æ –æ—á–µ—Ä—ë–¥–Ω–æ—Å—Ç—å. –ü–æ—Å–∫–æ–ª—å–∫—É –Ω–∞—à–µ —Ä–µ—à–µ–Ω–∏–µ –≤—Å—ë –µ—â—ë –Ω–µ –ø–µ—Ä–µ–¥–∞—ë—Ç —Å–º—ã—Å–ª–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π, –æ—á–µ–Ω—å –ª–µ–≥–∫–æ —Å–æ–≤–µ—Ä—à–∏—Ç—å –æ—à–∏–±–∫—É.</p>
<h3 id="–†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥-–≤–Ω–µ–¥—Ä–µ–Ω–∏–µ–º-—Å—Ç—Ä—É–∫—Ç—É—Ä"><a class="header" href="#–†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥-–≤–Ω–µ–¥—Ä–µ–Ω–∏–µ–º-—Å—Ç—Ä—É–∫—Ç—É—Ä">–†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ –≤–Ω–µ–¥—Ä–µ–Ω–∏–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä</a></h3>
<p>–°—Ç—Ä—É–∫—Ç—É—Ä—ã –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è, —á—Ç–æ–±—ã –¥–æ–±–∞–≤–ª—è—Ç—å —Å–º—ã—Å–ª –¥–∞–Ω–Ω—ã–º –ø—Ä–∏ –ø–æ–º–æ—â–∏ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è –∏–º –æ—Å–º—ã—Å–ª–µ–Ω–Ω—ã—Ö –∏–º—ë–Ω. –ú—ã –º–æ–∂–µ–º –ø–µ—Ä–µ–¥–µ–ª–∞—Ç—å –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–π –∫–æ—Ä—Ç–µ–∂ –≤ —Å—Ç—Ä—É–∫—Ç—É—Ä—É —Å –µ–¥–∏–Ω—ã–º –∏–º–µ–Ω–µ–º –¥–ª—è —Å—É—â–Ω–æ—Å—Ç–∏ –∏ —á–∞—Å—Ç–Ω—ã–º–∏ –Ω–∞–∑–≤–∞–Ω–∏—è–º–∏ –µ—ë —á–∞—Å—Ç–µ–π, –∫–∞–∫ –ø–æ–∫–∞–∑–∞–Ω–æ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 5-10.</p>
<Listing number="5-10" file-name="src/main.rs" caption="Defining a `Rectangle` struct">
<pre><pre class="playground"><code class="language-rust edition2021">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "–ü–ª–æ—â–∞–¥—å –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∞ —Ä–∞–≤–Ω–∞ {} –∫–≤–∞–¥—Ä–∞—Ç–Ω—ã—Ö –ø–∏–∫—Å–µ–ª–µ–π.",
        area(&amp;rect1)
    );
}

fn area(rectangle: &amp;Rectangle) -&gt; u32 {
    rectangle.width * rectangle.height
}</code></pre></pre>
</Listing>
<p>–ó–¥–µ—Å—å –º—ã –æ–ø—Ä–µ–¥–µ–ª–∏–ª–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—É –∏ –¥–∞–ª–∏ –µ–π –∏–º—è <code>Rectangle</code>. –í–Ω—É—Ç—Ä–∏ —Ñ–∏–≥—É—Ä–Ω—ã—Ö —Å–∫–æ–±–æ–∫ –æ–ø—Ä–µ–¥–µ–ª–∏–ª–∏ –ø–æ–ª—è <code>width</code> –∏ <code>height</code>, –æ–±–∞ ‚Äî —Ç–∏–ø–∞ <code>u32</code>. –ó–∞—Ç–µ–º –≤ <code>main</code> —Å–æ–∑–¥–∞–ª–∏ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä <code>Rectangle</code> —Å —à–∏—Ä–∏–Ω–æ–π –≤ <code>30</code> –∏ –≤—ã—Å–æ—Ç–æ–π –≤ <code>50</code>.</p>
<p>–ù–∞—à–∞ —Ñ—É–Ω–∫—Ü–∏—è area —Ç–µ–ø–µ—Ä—å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ —Å –æ–¥–Ω–∏–º –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–º <code>rectangle</code>, –∏–º–µ—é—â–∏–º —Ç–∏–ø –Ω–µ–∏–∑–º–µ–Ω—è–µ–º–æ–π —Å—Å—ã–ª–∫–∏ –Ω–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä—É <code>Rectangle</code>. –ö–∞–∫ —É–ø–æ–º–∏–Ω–∞–ª–æ—Å—å –≤ –ì–ª–∞–≤–µ 4, —Å–ª–µ–¥—É–µ—Ç –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É, –∞ –Ω–µ –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å –≤–ª–∞–¥–µ–Ω–∏–µ –Ω–∞ –Ω–µ—ë. –¢–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, —Ñ—É–Ω–∫—Ü–∏—è <code>main</code> –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç –≤–ª–∞–¥–µ—Ç—å <code>rect1</code> –∏ –º–æ–∂–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –µ—ë –¥–∞–ª—å—à–µ, –¥–ª—è —á–µ–≥–æ –º—ã –∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º <code>&amp;</code> –≤ —Å–∏–≥–Ω–∞—Ç—É—Ä–µ –∏ –≤ –≤—ã–∑–æ–≤–µ —Ñ—É–Ω–∫—Ü–∏–∏.</p>
<p>–§—É–Ω–∫—Ü–∏—è <code>area</code> –ø–æ–ª—É—á–∞–µ—Ç –¥–æ—Å—Ç—É–ø –∫ –ø–æ–ª—è–º <code>width</code> –∏ <code>height</code> —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ <code>Rectangle</code> (–æ–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ –¥–æ—Å—Ç—É–ø –∫ –ø–æ–ª—è–º –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–Ω–æ–≥–æ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –Ω–µ –ø—Ä–∏–≤–æ–¥–∏—Ç –∫ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—é –∑–Ω–∞—á–µ–Ω–∏–π –ø–æ–ª–µ–π, –ø–æ—ç—Ç–æ–º—É –≤—ã —á–∞—Å—Ç–æ –±—É–¥–µ—Ç–µ –≤–∏–¥–µ—Ç—å –∏–º–µ–Ω–Ω–æ –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä). –ù–∞—à–∞ —Å–∏–≥–Ω–∞—Ç—É—Ä–∞ —Ñ—É–Ω–∫—Ü–∏–∏ <code>area</code> —Ç–µ–ø–µ—Ä—å –≥–æ–≤–æ—Ä–∏—Ç –∏–º–µ–Ω–Ω–æ —Ç–æ, —á—Ç–æ –º—ã –∏–º–µ–µ–º –≤ –≤–∏–¥—É: –≤—ã—á–∏—Å–ª–∏—Ç—å –ø–ª–æ—â–∞–¥—å –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∞ <code>Rectangle</code>, –∏—Å–ø–æ–ª—å–∑—É—è –µ–≥–æ –≤—ã—Å–æ—Ç—É <code>width</code> –∏ –≤—ã—Å–æ—Ç—É <code>height</code>. –≠—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ —à–∏—Ä–∏–Ω–∞ –∏ –≤—ã—Å–æ—Ç–∞ —Ç–µ–ø–µ—Ä—å —Å–≤—è–∑–∞–Ω—ã –¥—Ä—É–≥ —Å –¥—Ä—É–≥–æ–º; —á—Ç–æ –æ–Ω–∏ –∏–º–µ—é—Ç –æ–ø–∏—Å–∞—Ç–µ–ª—å–Ω—ã–µ –∏–º–µ–Ω–∞, –∞ –Ω–µ –ø—Ä–∏–≤—è–∑–∞–Ω—ã –∫ –∏–Ω–¥–µ–∫—Å–∞–º <code>0</code> –∏ <code>1</code>. –¢–æ—Ä–∂–µ—Å—Ç–≤–æ —è—Å–Ω–æ—Å—Ç–∏!</p>
<h3 id="–î–æ–±–∞–≤–ª–µ–Ω–∏–µ-–ø–æ–ª–µ–∑–Ω–æ–π-—Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏-—Å-–ø–æ–º–æ—â—å—é-–≤—ã–≤–æ–¥–∏–º—ã—Ö-—Ç—Ä–µ–π—Ç–æ–≤"><a class="header" href="#–î–æ–±–∞–≤–ª–µ–Ω–∏–µ-–ø–æ–ª–µ–∑–Ω–æ–π-—Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏-—Å-–ø–æ–º–æ—â—å—é-–≤—ã–≤–æ–¥–∏–º—ã—Ö-—Ç—Ä–µ–π—Ç–æ–≤">–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª–µ–∑–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏ —Å –ø–æ–º–æ—â—å—é –≤—ã–≤–æ–¥–∏–º—ã—Ö —Ç—Ä–µ–π—Ç–æ–≤</a></h3>
<p>–ë—ã–ª–æ –±—ã –ø–æ–ª–µ–∑–Ω–æ –∏–º–µ—Ç—å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –ø–µ—á–∞—Ç–∞—Ç—å —ç–∫–∑–µ–º–ø–ª—è—Ä <code>Rectangle</code> –≤–æ –≤—Ä–µ–º—è –æ—Ç–ª–∞–¥–∫–∏ –ø—Ä–æ–≥—Ä–∞–º–º—ã –∏ –≤–∏–¥–µ—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è –≤—Å–µ—Ö –ø–æ–ª–µ–π. –õ–∏—Å—Ç–∏–Ω–≥ 5-11 –∏—Å–ø–æ–ª—å–∑—É–µ—Ç <a href="https://doc.rust-lang.org/std/macro.println.html">–º–∞–∫—Ä–æ—Å <code>println!</code></a><!-- ignore -->, –∫–æ—Ç–æ—Ä—ã–π –º—ã —É–∂–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ –≤ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö –≥–ª–∞–≤–∞—Ö. –¢–µ–º –Ω–µ –º–µ–Ω–µ–µ, –∫–æ–¥ –Ω–∏–∂–µ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–µ—Ç.</p>
<Listing number="5-11" file-name="src/main.rs" caption="Attempting to print a `Rectangle` instance">
<pre><code class="language-rust ignore does_not_compile">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1: {}", rect1);
}</code></pre>
</Listing>
<p>–ü—Ä–∏ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ —ç—Ç–æ–≥–æ –∫–æ–¥–∞ –º—ã –ø–æ–ª—É—á–∞–µ–º –æ—à–∏–±–∫—É. –ì–ª–∞–≤–Ω–æ–µ –≤ –Ω–µ–π –≤–æ—Ç —á—Ç–æ:</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
</code></pre>
<p>–ú–∞–∫—Ä–æ—Å <code>println!</code> —É–º–µ–µ—Ç –≤—ã–ø–æ–ª–Ω—è—Ç—å –º–Ω–æ–∂–µ—Å—Ç–≤–æ –≤–∏–¥–æ–≤ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è, –∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é —Ñ–∏–≥—É—Ä–Ω—ã–µ —Å–∫–æ–±–∫–∏ –≤ <code>println!</code> –æ–∑–Ω–∞—á–∞—é—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è, –æ–ø—Ä–µ–¥–µ–ª—è–µ–º–æ–≥–æ —Ç—Ä–µ–π—Ç–æ–º <code>Display</code>. –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ –Ω–µ–º—É —Å–æ–∑–¥–∞—ë—Ç —Ä–µ–ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é –∑–Ω–∞—á–µ–Ω–∏—è, –ø—Ä–µ–¥–Ω–∞–∑–Ω–∞—á–µ–Ω—É—é –¥–ª—è –Ω–µ–ø–æ—Å—Ä–µ–¥—Å—Ç–≤–µ–Ω–Ω–æ –∫–æ–Ω–µ—á–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è. –ë–∞–∑–æ–≤—ã–µ —Ç–∏–ø—ã, –∏–∑—É—á–µ–Ω–Ω—ã–µ —Ä–∞–Ω–µ–µ, –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é —Ä–µ–∞–ª–∏–∑—É—é—Ç —Ç—Ä–µ–π—Ç <code>Display</code>, –ø–æ—Ç–æ–º—É —á—Ç–æ –µ—Å—Ç—å —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Å–ø–æ—Å–æ–± –æ—Ç–æ–±—Ä–∞–∑–∏—Ç—å —á–∏—Å–ª–æ <code>1</code> –∏–ª–∏ –ª—é–±–æ–π –¥—Ä—É–≥–æ–π –ø—Ä–∏–º–∏—Ç–∏–≤–Ω—ã–π —Ç–∏–ø. –ù–æ –¥–ª—è —Å—Ç—Ä—É–∫—Ç—É—Ä —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ <code>println!</code> –º–µ–Ω–µ–µ –æ—á–µ–≤–∏–¥–Ω–æ, –ø–æ—Ç–æ–º—É —á—Ç–æ –µ—Å—Ç—å –≥–æ—Ä–∞–∑–¥–æ –±–æ–ª—å—à–µ —Å–ø–æ—Å–æ–±–æ–≤ –æ—Ç–æ–±—Ä–∞–∑–∏—Ç—å –µ—ë –≤ –∫–æ–Ω—Å–æ–ª–∏: —Å –∑–∞–ø—è—Ç—ã–º–∏ –∏–ª–∏ –±–µ–∑; —Å —Ñ–∏–≥—É—Ä–Ω—ã–º–∏ —Å–∫–æ–±–∫–∞–º–∏ –∏–ª–∏ –±–µ–∑; –≤—Å–µ –ª–∏ –ø–æ–ª—è –∏–ª–∏ —Ç–æ–ª—å–∫–æ –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ? –ò–∑-–∑–∞ —ç—Ç–æ–π –Ω–µ–æ–¥–Ω–æ–∑–Ω–∞—á–Ω–æ—Å—Ç–∏ Rust –Ω–µ –ø—ã—Ç–∞–µ—Ç—Å—è —É–≥–∞–¥–∞—Ç—å, —á—Ç–æ –Ω–∞–º –Ω—É–∂–Ω–æ, –∞ —Ç–∞–∫ –∫–∞–∫ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –Ω–µ –∏–º–µ—é—Ç —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ <code>Display</code> –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, –∫–æ–¥ –Ω–µ –∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è: –ø—Ä–æ–≥—Ä–∞–º–º–∞ –Ω–µ –∑–Ω–∞–µ—Ç, —á—Ç–æ –ø–æ–¥—Å—Ç–∞–≤–∏—Ç—å –Ω–∞ –º–µ—Å—Ç–æ <code>{}</code> –≤ <code>println!</code>.</p>
<p>–ü—Ä–æ–¥–æ–ª–∂–∏–≤ —á—Ç–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ –æ—à–∏–±–∫–∏, –º—ã –Ω–∞–π–¥—ë–º –ø–æ–ª–µ–∑–Ω—ã–π —Å–æ–≤–µ—Ç:</p>
<pre><code class="language-text">   = help: the trait `std::fmt::Display` is not implemented for `Rectangle`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
</code></pre>
<p>–î–∞–≤–∞–π—Ç–µ –ø–æ–ø—Ä–æ–±—É–µ–º –µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å! –í—ã–∑–æ–≤ –º–∞–∫—Ä–æ—Å–∞ <code>println!</code> —Ç–µ–ø–µ—Ä—å –±—É–¥–µ—Ç –≤—ã–≥–ª—è–¥–µ—Ç—å —Ç–∞–∫ <code>println!("rect1: {rect1:?}");</code>. –í–≤–æ–¥ —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞ <code>:?</code> –≤–Ω—É—Ç—Ä–∏ —Ñ–∏–≥—É—Ä–Ω—ã—Ö —Å–∫–æ–±–æ–∫ –≥–æ–≤–æ—Ä–∏—Ç –º–∞–∫—Ä–æ—Å—É <code>println!</code>, —á—Ç–æ –º—ã —Ö–æ—Ç–∏–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –¥—Ä—É–≥–æ–π —Ñ–æ—Ä–º–∞—Ç –≤—ã–≤–æ–¥–∞, –∏–∑–≤–µ—Å—Ç–Ω—ã–π –∫–∞–∫ <code>Debug</code>. –¢—Ä–µ–π—Ç <code>Debug</code> –ø–æ–∑–≤–æ–ª—è–µ—Ç –ø–µ—á–∞—Ç–∞—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É —Å–ø–æ—Å–æ–±–æ–º, —É–¥–æ–±–Ω—ã–º –∏–º–µ–Ω–Ω–æ –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤, —á—Ç–æ–±—ã –≤–∏–¥–µ—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –≤–æ –≤—Ä–µ–º—è –æ—Ç–ª–∞–¥–∫–∏ –∫–æ–¥–∞.</p>
<p>–°–∫–æ–º–ø–∏–ª–∏—Ä—É–µ–º –∫–æ–¥ —Å —ç—Ç–∏–º–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è–º–∏. –£–ø—Å! –ú—ã –≤—Å—ë –µ—â—ë –ø–æ–ª—É—á–∞–µ–º –æ—à–∏–±–∫—É:</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `Debug`
</code></pre>
<p>–ù–æ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä —Å–Ω–æ–≤–∞ –¥–∞—ë—Ç –Ω–∞–º –ø–æ–ª–µ–∑–Ω–æ–µ –∑–∞–º–µ—á–∞–Ω–∏–µ:</p>
<pre><code class="language-text">   = help: the trait `Debug` is not implemented for `Rectangle`
   = note: add `#[derive(Debug)]` to `Rectangle` or manually `impl Debug for Rectangle`
</code></pre>
<p>Rust <em>–∏–º–µ–µ—Ç</em> —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å –¥–ª—è –ø–µ—á–∞—Ç–∏ –æ—Ç–ª–∞–¥–æ—á–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏, –Ω–æ –º—ã –¥–æ–ª–∂–Ω—ã —è–≤–Ω–æ –≤–∫–ª—é—á–∏—Ç—å —ç—Ç—É —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å –¥–ª—è –Ω–∞—à–µ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, —á—Ç–æ–±—ã —Å–¥–µ–ª–∞—Ç—å –µ—ë –¥–æ—Å—Ç—É–ø–Ω–æ–π. –î–ª—è —ç—Ç–æ–≥–æ –¥–æ–±–∞–≤–∏–º –≤–Ω–µ—à–Ω–∏–π –∞—Ç—Ä–∏–±—É—Ç <code>#[derive(Debug)]</code> —Å—Ä–∞–∑—É –ø–µ—Ä–µ–¥ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, –∫–∞–∫ –ø–æ–∫–∞–∑–∞–Ω–æ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 5-12.</p>
<Listing number="5-12" file-name="src/main.rs" caption="Adding the attribute to derive the `Debug` trait and printing the `Rectangle` instance using debug formatting">
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1: {rect1:?}");
}</code></pre></pre>
</Listing>
<p>–¢–µ–ø–µ—Ä—å –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã –º—ã –Ω–µ –ø–æ–ª—É—á–∏–º –æ—à–∏–±–æ–∫ –∏ —É–≤–∏–¥–∏–º —Å–ª–µ–¥—É—é—â–∏–π –≤—ã–≤–æ–¥:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1: Rectangle { width: 30, height: 50 }
</code></pre>
<p>–û—Ç–ª–∏—á–Ω–æ! –≠—Ç–æ –Ω–µ —Å–∞–º—ã–π –∫—Ä–∞—Å–∏–≤—ã–π –≤—ã–≤–æ–¥, –Ω–æ –æ–Ω –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏—è –≤—Å–µ—Ö –ø–æ–ª–µ–π —ç–∫–∑–µ–º–ø–ª—è—Ä–∞, —á—Ç–æ –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ –±—É–¥–µ—Ç –ø–æ–ª–µ–∑–Ω–æ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏. –ï—Å–ª–∏ –º—ã –∏–º–µ–µ–º –¥–µ–ª–æ —Å –±–æ–ª–µ–µ –∫—Ä—É–ø–Ω—ã–º–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞–º–∏, —Ç–æ –ø–æ–ª–µ–∑–Ω–æ –∏–º–µ—Ç—å –±–æ–ª–µ–µ –ø—Ä–æ—Å—Ç–æ–π –¥–ª—è —á—Ç–µ–Ω–∏—è –≤—ã–≤–æ–¥, –¥–æ—Å—Ç—É–ø–Ω—ã–π —Å –ø–æ–º–æ—â—å—é –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ <code>{:#?}</code> –≤ —Å—Ç—Ä–æ–∫–µ –º–∞–∫—Ä–æ—Å–∞ <code>println!</code>. –í —ç—Ç–æ–º –ø—Ä–∏–º–µ—Ä–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –º–µ—Ç–∫–∏ <code>{:#?}</code> —Å–¥–µ–ª–∞–µ—Ç –≤—ã–≤–æ–¥ –≤–æ—Ç —Ç–∞–∫–∏–º:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1: Rectangle {
    width: 30,
    height: 50,
}
</code></pre>
<p>–î—Ä—É–≥–æ–π —Å–ø–æ—Å–æ–± —Ä–∞—Å–ø–µ—á–∞—Ç–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –≤ —Ñ–æ—Ä–º–∞—Ç–µ <code>Debug</code> ‚Äî –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å <a href="https://doc.rust-lang.org/std/macro.dbg.html">–º–∞–∫—Ä–æ—Å <code>dbg!</code></a><!-- ignore -->, –∫–æ—Ç–æ—Ä—ã–π –ø–µ—á–∞—Ç–∞–µ—Ç –Ω–∞–∑–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞ –∏ –Ω–æ–º–µ—Ä —Å—Ç—Ä–æ–∫–∏, –≥–¥–µ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –≤—ã–∑–æ–≤ –º–∞–∫—Ä–æ—Å–∞ <code>dbg!</code>, –ø–ª—é—Å –ø–µ—Ä–µ–¥–∞–Ω–Ω–æ–µ –≤ –Ω–µ–≥–æ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ —Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º, –≤ –∫–æ—Ç–æ—Ä–æ–µ —Ç–æ –≤—ã—á–∏—Å–ª—è–µ—Ç—Å—è. –ú–∞–∫—Ä–æ—Å <code>dbg!</code> –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –≤–ª–∞–¥–µ–Ω–∏–µ –Ω–∞–¥ –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã–º –≤ –Ω–µ–≥–æ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ–º (–≤ –æ—Ç–ª–∏—á–∏–µ –æ—Ç –º–∞–∫—Ä–æ—Å–∞ <code>println!</code>, –∏—Å–ø–æ–ª—å–∑—É—é—â–µ–≥–æ —Å—Å—ã–ª–∫–∏), –Ω–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç –ø–µ—Ä–µ–¥–∞–Ω–Ω–æ–≥–æ –≤—ã—Ä–∞–∂–µ–Ω–∏—è.</p>
<blockquote>
<p>–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: –ü—Ä–∏ –≤—ã–∑–æ–≤–µ –º–∞–∫—Ä–æ—Å–∞ <code>dbg!</code> –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –ø–µ—á–∞—Ç—å –≤ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –ø–æ—Ç–æ–∫ –æ—à–∏–±–æ–∫ (<code>stderr</code>), –≤ –æ—Ç–ª–∏—á–∏–µ –æ—Ç <code>println!</code>, –∫–æ—Ç–æ—Ä—ã–π –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –ø–æ—Ç–æ–∫ –≤—ã–≤–æ–¥–∞ –≤ –∫–æ–Ω—Å–æ–ª—å (<code>stdout</code>). –ü–æ–¥—Ä–æ–±–Ω–µ–µ –æ <code>stderr</code> –∏ <code>stdout</code> –º—ã –ø–æ–≥–æ–≤–æ—Ä–∏–º –≤ <a href="ch12-06-writing-to-stderr-instead-of-stdout.html">—Ä–∞–∑–¥–µ–ª–µ "–í—ã–≤–æ–¥ —Å–æ–æ–±—â–µ–Ω–∏–π –æ–± –æ—à–∏–±–∫–∞—Ö –≤ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –ø–æ—Ç–æ–∫ –æ—à–∏–±–æ–∫" –ì–ª–∞–≤—ã 12</a><!-- ignore -->.</p>
</blockquote>
<p>–í–æ—Ç –ø—Ä–∏–º–µ—Ä, –∫–æ–≥–¥–∞ –Ω–∞—Å –∏–Ω—Ç–µ—Ä–µ—Å—É–µ—Ç 1) –∑–Ω–∞—á–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –±—É–¥–µ—Ç –ø—Ä–∏–ø–∏—Å–∞–Ω–æ –ø–æ–ª—é <code>width</code>, –∏ 2) –∑–Ω–∞—á–µ–Ω–∏–µ –≤—Å–µ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –≤ <code>rect1</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale),
        height: 50,
    };

    dbg!(&amp;rect1);
}</code></pre></pre>
<p>–ú—ã –º–æ–∂–µ–º –æ–±–µ—Ä–Ω—É—Ç—å –≤—ã—Ä–∞–∂–µ–Ω–∏–µ <code>30 * scale</code> –º–∞–∫—Ä–æ—Å–æ–º <code>dbg!</code>, –ø–æ—Ç–æ–º—É —á—Ç–æ <code>dbg!</code> –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤–ª–∞–¥–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏–µ–º –≤—ã—Ä–∞–∂–µ–Ω–∏—è. –ü–æ–ª–µ <code>width</code> –ø–æ–ª—É—á–∏—Ç —Ç–æ –∂–µ –∑–Ω–∞—á–µ–Ω–∏–µ, –∫–∞–∫ –µ—Å–ª–∏ –±—ã —É –Ω–∞—Å –Ω–µ –±—ã–ª–æ –≤—ã–∑–æ–≤–∞ <code>dbg!</code>. –î–∞–ª–µ–µ, –º—ã –Ω–µ —Ö–æ—Ç–∏–º, —á—Ç–æ–±—ã –º–∞–∫—Ä–æ—Å <code>dbg!</code> —Å—Ç–∞–Ω–æ–≤–∏–ª—Å—è –≤–ª–∞–¥–µ–ª—å—Ü–µ–º <code>rect1</code>, –ø–æ—ç—Ç–æ–º—É –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ <code>rect1</code> –≤ —Å–ª–µ–¥—É—é—â–µ–º –≤—ã–∑–æ–≤–µ. –í–æ—Ç –∫–∞–∫ –≤—ã–≥–ª—è–¥–∏—Ç –≤—ã–≤–æ–¥ —ç—Ç–æ–≥–æ –ø—Ä–∏–º–µ—Ä–∞:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/rectangles`
[src/main.rs:10:16] 30 * scale = 60
[src/main.rs:14:5] &amp;rect1 = Rectangle {
    width: 60,
    height: 50,
}
</code></pre>
<p>–ú—ã –º–æ–∂–µ–º —É–≤–∏–¥–µ—Ç—å, —á—Ç–æ –ø–µ—Ä–≤—ã–π –æ—Ç–ª–∞–¥–æ—á–Ω—ã–π –≤—ã–≤–æ–¥ –ø–æ—Å—Ç—É–ø–∏–ª –∏–∑ —Å—Ç—Ä–æ–∫–∏ 10 —Ñ–∞–π–ª–∞ <em>src/main.rs</em>: —Ç–∞–º, –≥–¥–µ –º—ã –æ—Ç–ª–∞–∂–∏–≤–∞–µ–º –≤—ã—Ä–∞–∂–µ–Ω–∏–µ <code>30 * scale</code>, —Ä–µ–∑—É–ª—å—Ç–∏—Ä—É—é—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∫–æ—Ç–æ—Ä–æ–≥–æ —Ä–∞–≤–Ω–æ <code>60</code> (—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ <code>Debug</code>, —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–µ –¥–ª—è —Ü–µ–ª—ã—Ö —á–∏—Å–µ–ª, –ø—Ä–æ—Å—Ç–æ –ø–µ—á–∞—Ç–∞–µ—Ç —á–∏—Å–ª–æ). –í—ã–∑–æ–≤ <code>dbg!</code> –≤ —Å—Ç—Ä–æ–∫–µ 14 —Ñ–∞–π–ª–∞ <em>src/main.rs</em> –≤—ã–≤–æ–¥–∏—Ç –∑–Ω–∞—á–µ–Ω–∏–µ <code>&amp;rect1</code>, –∫–æ—Ç–æ—Ä–æ–µ —è–≤–ª—è–µ—Ç—Å—è —Å—Ç—Ä—É–∫—Ç—É—Ä–æ–π <code>Rectangle</code>. –í —ç—Ç–æ–º –≤—ã–≤–æ–¥–µ –æ–∫–∞–∑–∞–ª–æ—Å—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ —Ä–∞–∑–≤—ë—Ä–Ω—É—Ç–æ–µ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ <code>Debug</code> —Ç–∏–ø–∞ <code>Rectangle</code>. –ú–∞–∫—Ä–æ—Å <code>dbg!</code> –º–æ–∂–µ—Ç –æ–∫–∞–∑–∞—Ç—å—Å—è –æ—á–µ–Ω—å –Ω—É–∂–Ω—ã–º, –∫–æ–≥–¥–∞ –≤—ã –ø—ã—Ç–∞–µ—Ç–µ—Å—å –ø–æ–Ω—è—Ç—å, —á—Ç–æ —Ç–≤–æ—Ä–∏—Ç –≤–∞—à –∫–æ–¥!</p>
<p>–í –¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –∫ <code>Debug</code>, Rust –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç –µ—â—ë —Ä—è–¥ —Ç—Ä–µ–π—Ç–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –º—ã –º–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤ –∞—Ç—Ä–∏–±—É—Ç–µ <code>derive</code> –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –ø–æ–ª–µ–∑–Ω–æ–≥–æ –ø–æ–≤–µ–¥–µ–Ω–∏—è –∫ –Ω–∞—à–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–º —Ç–∏–ø–∞–º. –≠—Ç–∏ —Ç—Ä–µ–π—Ç—ã –∏ –∏—Ö –ø–æ–≤–µ–¥–µ–Ω–∏–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω—ã –≤ <a href="appendix-03-derivable-traits.html">–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ C</a><!-- ignore -->. –í –ì–ª–∞–≤–µ 10 –º—ã —Ä–∞—Å—Å–∫–∞–∂–µ–º, –∫–∞–∫ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —ç—Ç–∏ —Ç—Ä–µ–π—Ç—ã —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–º –ø–æ–≤–µ–¥–µ–Ω–∏–µ–º, –∞ —Ç–∞–∫–∂–µ –∫–∞–∫ —Å–æ–∑–¥–∞–≤–∞—Ç—å —Å–≤–æ–∏ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ —Ç—Ä–µ–π—Ç—ã. –ö—Ä–æ–º–µ —Ç–æ–≥–æ, –µ—Å—Ç—å –º–Ω–æ–≥–æ –¥—Ä—É–≥–∏—Ö –∞—Ç—Ä–∏–±—É—Ç–æ–≤ –ø–æ–º–∏–º–æ <code>derive</code>. –î–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏, –æ–∑–Ω–∞–∫–æ–º—å—Ç–µ—Å—å —Å <a href="https://rust-lang-translations.org/reference/attributes.html">—Ä–∞–∑–¥–µ–ª–æ–º "–ê—Ç—Ä–∏–±—É—Ç—ã" –°–ø—Ä–∞–≤–æ—á–Ω–∏–∫–∞ Rust</a>.</p>
<p>–§—É–Ω–∫—Ü–∏—è <code>area</code> —è–≤–ª—è–µ—Ç—Å—è –¥–æ–≤–æ–ª—å–Ω–æ —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω–æ–π: –æ–Ω–∞ —Å—á–∏—Ç–∞–µ—Ç —Ç–æ–ª—å–∫–æ –ø–ª–æ—â–∞–¥—å –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–æ–≤. –ë—ã–ª–æ –±—ã –ø–æ–ª–µ–∑–Ω–æ –ø—Ä–∏–≤—è–∑–∞—Ç—å –¥–∞–Ω–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ –∫–∞–∫ –º–æ–∂–Ω–æ –±–ª–∏–∂–µ –∫ —Å—Ç—Ä—É–∫—Ç—É—Ä–µ <code>Rectangle</code>, –ø–æ—Ç–æ–º—É —á—Ç–æ –Ω–∞—à —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–π –∫–æ–¥ –Ω–µ –±—É–¥–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å —Å –ª—é–±—ã–º –¥—Ä—É–≥–∏–º —Ç–∏–ø–æ–º. –î–∞–≤–∞–π—Ç–µ —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º, –∫–∞–∫ –º–æ–∂–Ω–æ —É–ª—É—á—à–∏—Ç—å –Ω–∞—à –∫–æ–¥, –ø—Ä–µ–≤—Ä–∞—Ç–∏–≤ —Ñ—É–Ω–∫—Ü–∏—é <code>area</code> –≤ <em>–º–µ—Ç–æ–¥</em> <code>area</code>, –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã–π –¥–ª—è —Ç–∏–ø–∞ <code>Rectangle</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–°–∏–Ω—Ç–∞–∫—Å–∏—Å-–º–µ—Ç–æ–¥–∞"><a class="header" href="#–°–∏–Ω—Ç–∞–∫—Å–∏—Å-–º–µ—Ç–æ–¥–∞">–°–∏–Ω—Ç–∞–∫—Å–∏—Å –º–µ—Ç–æ–¥–∞</a></h2>
<p><em>–ú–µ—Ç–æ–¥—ã</em> –ø–æ—Ö–æ–∂–∏ –Ω–∞ —Ñ—É–Ω–∫—Ü–∏–∏: –º—ã –æ–±—ä—è–≤–ª—è–µ–º –∏—Ö —Å –ø–æ–º–æ—â—å—é –∫–ª—é—á–µ–≤–æ–≥–æ —Å–ª–æ–≤–∞ <code>fn</code> –∏ –∏–º–µ–Ω–∏; –æ–Ω–∏ –º–æ–≥—É—Ç –∏–º–µ—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ; –æ–Ω–∏ —Å–æ–¥–µ—Ä–∂–∞—Ç –∫–æ–¥, –∑–∞–ø—É—Å–∫–∞—é—â–∏–π—Å—è –ø—Ä–∏ –≤—ã–∑–æ–≤–µ –º–µ—Ç–æ–¥–∞. –í –æ—Ç–ª–∏—á–∏–µ –æ—Ç —Ñ—É–Ω–∫—Ü–∏–π, –º–µ—Ç–æ–¥—ã –æ–ø—Ä–µ–¥–µ–ª—è—é—Ç—Å—è –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã (–∏–ª–∏ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –∏–ª–∏ —Ç—Ä–µ–π—Ç-–æ–±—ä–µ–∫—Ç–∞, –∫–æ—Ç–æ—Ä—ã–µ –º—ã —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º –≤ <a href="ch06-00-enums.html">–ì–ª–∞–≤–µ 6</a><!-- ignore --> –∏ <a href="ch18-02-trait-objects.html">–ì–ª–∞–≤–µ 17</a><!-- ignore --> —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ), –∞ –∏—Ö –ø–µ—Ä–≤—ã–º –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–º –≤—Å–µ–≥–¥–∞ —è–≤–ª—è–µ—Ç—Å—è <code>self</code>, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—â–∏–π —Å–æ–±–æ–π —ç–∫–∑–µ–º–ø–ª—è—Ä —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, –Ω–∞ –∫–æ—Ç–æ—Ä–æ–π –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è —ç—Ç–æ—Ç –º–µ—Ç–æ–¥.</p>
<h3 id="–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ-–º–µ—Ç–æ–¥–æ–≤"><a class="header" href="#–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ-–º–µ—Ç–æ–¥–æ–≤">–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –º–µ—Ç–æ–¥–æ–≤</a></h3>
<p>–î–∞–≤–∞–π—Ç–µ –∏–∑–º–µ–Ω–∏–º —Ñ—É–Ω–∫—Ü–∏—é <code>area</code>, –∏–º–µ—é—â—É—é –ø–∞—Ä–∞–º–µ—Ç—Ä —Ç–∏–ø–∞ <code>&amp;Rectangle</code>, –∏ —Å–¥–µ–ª–∞–µ–º –∏–∑ –Ω–µ—ë –º–µ—Ç–æ–¥ <code>area</code>, –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã–π –¥–ª—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã <code>Rectangle</code>. –ü–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –Ω–∞ –õ–∏—Å—Ç–∏–Ω–≥ 5-13:</p>
<Listing number="5-13" file-name="src/main.rs" caption="Defining an `area` method on the `Rectangle` struct">
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "–ü–ª–æ—â–∞–¥—å –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∞ —Ä–∞–≤–Ω–∞ {} –∫–≤–∞–¥—Ä–∞—Ç–Ω—ã—Ö –ø–∏–∫—Å–µ–ª–µ–π.",
        rect1.area()
    );
}</code></pre></pre>
</Listing>
<p>–ß—Ç–æ–±—ã –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ñ—É–Ω–∫—Ü–∏—é –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ <code>Rectangle</code>, –º—ã —Å–æ–∑–¥–∞—ë–º –±–ª–æ–∫ <code>impl</code> (—Å–æ–∫—Ä. –æ—Ç implementation) –¥–ª—è <code>Rectangle</code>. –í—Å—ë, —á—Ç–æ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ <code>impl</code>, –±—É–¥–µ—Ç —Å–≤—è–∑–∞–Ω–æ —Å —Ç–∏–ø–æ–º <code>Rectangle</code>. –ó–∞—Ç–µ–º –º—ã –ø–µ—Ä–µ–º–µ—â–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é <code>area</code> –≤–Ω—É—Ç—Ä—å —Ñ–∏–≥—É—Ä–Ω—ã—Ö —Å–∫–æ–±–æ–∫ <code>impl</code> –∏ –º–µ–Ω—è–µ–º –ø–µ—Ä–≤—ã–π (–∏, –≤ –¥–∞–Ω–Ω–æ–º —Å–ª—É—á–∞–µ, –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π) –ø–∞—Ä–∞–º–µ—Ç—Ä –Ω–∞ <code>self</code> ‚Äî –≤ —Å–∏–≥–Ω–∞—Ç—É—Ä–µ –∏ –≤ —Ç–µ–ª–µ. –í <code>main</code>, –≥–¥–µ –º—ã –≤—ã–∑—ã–≤–∞–ª–∏ —Ñ—É–Ω–∫—Ü–∏—é <code>area</code> –∏ –ø–µ—Ä–µ–¥–∞–≤–∞–ª–∏ <code>rect1</code> –≤ –∫–∞—á–µ—Å—Ç–≤–µ –∞—Ä–≥—É–º–µ–Ω—Ç–∞, –º—ã —Ç–µ–ø–µ—Ä—å –º–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å <em>—Å–∏–Ω—Ç–∞–∫—Å–∏—Å –º–µ—Ç–æ–¥–∞</em> –¥–ª—è –≤—ã–∑–æ–≤–∞ –º–µ—Ç–æ–¥–∞ <code>area</code> –Ω–∞—à–µ–≥–æ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ <code>Rectangle</code>. –ú–µ—Ç–æ–¥ –∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è –ø–æ—Å–ª–µ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞: –º—ã –¥–æ–±–∞–≤–ª—è–µ–º —Ç–æ—á–∫—É, –∑–∞ –∫–æ—Ç–æ—Ä–æ–π —Å–ª–µ–¥—É–µ—Ç –∏–º—è –º–µ—Ç–æ–¥–∞, –∞ –ø–æ—Ç–æ–º –≤ –∫—Ä—É–≥–ª—ã—Ö —Å–∫–æ–±–∫–∞—Ö –ø–µ—Ä–µ—á–∏—Å–ª—è–µ–º –æ—Å—Ç–∞–ª—å–Ω—ã–µ –∞—Ä–≥—É–º–µ–Ω—Ç—ã, –µ—Å–ª–∏ —Ç–∞–∫–æ–≤—ã–µ —Ç—Ä–µ–±—É—é—Ç—Å—è.</p>
<p>–í —Å–∏–≥–Ω–∞—Ç—É—Ä–µ <code>area</code> –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º <code>&amp;self</code> –≤–º–µ—Å—Ç–æ <code>rectangle: &amp;Rectangle</code>. <code>&amp;self</code> –Ω–∞ —Å–∞–º–æ–º –¥–µ–ª–µ —è–≤–ª—è–µ—Ç—Å—è —Å–æ–∫—Ä–∞—â–µ–Ω–∏–µ–º –æ—Ç <code>self: &amp;Self</code>. –í–Ω—É—Ç—Ä–∏ –±–ª–æ–∫–∞ <code>impl</code> —Ç–∏–ø <code>Self</code> —è–≤–ª—è–µ—Ç—Å—è –ø—Å–µ–≤–¥–æ–Ω–∏–º–æ–º —Ç–∏–ø–∞, –¥–ª—è –∫–æ—Ç–æ—Ä–æ–≥–æ —Ä–µ–∞–ª–∏–∑–æ–≤—ã–≤–∞–µ—Ç—Å—è –±–ª–æ–∫ <code>impl</code>. –ú–µ—Ç–æ–¥—ã –æ–±—è–∑–∞–Ω—ã –∏–º–µ—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä —Å –∏–º–µ–Ω–µ–º <code>self</code> —Ç–∏–ø–∞ <code>Self</code>, –ø–æ—ç—Ç–æ–º—É Rust –ø–æ–∑–≤–æ–ª—è–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–µ–±–æ–ª—å—à–æ–µ —Å–æ–∫—Ä–∞—â–µ–Ω–∏–µ –≤ –≤–∏–¥–µ –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ —Å–ª–æ–≤–∞ <code>self</code> –Ω–∞ –º–µ—Å—Ç–µ –ø–µ—Ä–≤–æ–≥–æ –∞—Ä–≥—É–º–µ–Ω—Ç–∞. –û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ –Ω–∞–º –ø–æ-–ø—Ä–µ–∂–Ω–µ–º—É –Ω—É–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å <code>&amp;</code> –ø–µ—Ä–µ–¥ —Å–æ–∫—Ä–∞—â–µ–Ω–∏–µ–º <code>self</code>, —á—Ç–æ–±—ã —É–∫–∞–∑–∞—Ç—å –Ω–∞ —Ç–æ, —á—Ç–æ —ç—Ç–æ—Ç –º–µ—Ç–æ–¥ –∑–∞–∏–º—Å—Ç–≤—É–µ—Ç —ç–∫–∑–µ–º–ø–ª—è—Ä <code>Self</code>: —Ç–æ—á–Ω–æ —Ç–∞–∫ –∂–µ, –∫–∞–∫ –º—ã –¥–µ–ª–∞–ª–∏ —ç—Ç–æ –≤ <code>rectangle: &amp;Rectangle</code>. –ö–∞–∫ –∏ —Å –ª—é–±—ã–º–∏ –¥—Ä—É–≥–∏–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏, –º–µ—Ç–æ–¥—ã –º–æ–≥—É—Ç –∫–∞–∫ –±—Ä–∞—Ç—å <code>self</code> –≤–æ –≤–ª–∞–¥–µ–Ω–∏–µ, —Ç–∞–∫ –∏ –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞—Ç—å <code>self</code>: –Ω–µ–∏–∑–º–µ–Ω—è–µ–º–æ –∏–ª–∏ (–∫–∞–∫ –º—ã –ø–æ—Å—Ç—É–ø–∏–ª–∏ –≤ –¥–∞–Ω–Ω–æ–º —Å–ª—É—á–∞–µ) –∏–∑–º–µ–Ω—è–µ–º–æ.</p>
<p>–ú—ã –≤—ã–±—Ä–∞–ª–∏ <code>&amp;self</code> –∑–¥–µ—Å—å –ø–æ —Ç–æ–π –∂–µ –ø—Ä–∏—á–∏–Ω–µ, –ø–æ –∫–æ—Ç–æ—Ä–æ–π –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ <code>&amp;Rectangle</code> –≤ –≤–µ—Ä—Å–∏–∏ —Å —Ñ—É–Ω–∫—Ü–∏–µ–π: –º—ã –Ω–µ —Ö–æ—Ç–∏–º –±—Ä–∞—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É –≤–æ –≤–ª–∞–¥–µ–Ω–∏–µ, –º—ã –ø—Ä–æ—Å—Ç–æ —Ö–æ—Ç–∏–º –ø—Ä–æ—á–∏—Ç–∞—Ç—å –¥–∞–Ω–Ω—ã–µ –≤ —Å—Ç—Ä—É–∫—Ç—É—Ä–µ, –∞ –Ω–µ –ø–∏—Å–∞—Ç—å –≤ –Ω–µ—ë. –ï—Å–ª–∏ –±—ã –º—ã —Ö–æ—Ç–µ–ª–∏ –∏–∑–º–µ–Ω–∏—Ç—å —ç–∫–∑–µ–º–ø–ª—è—Ä, –Ω–∞ –∫–æ—Ç–æ—Ä–æ–º –º—ã –≤—ã–∑—ã–≤–∞–ª–∏ –º–µ—Ç–æ–¥, —Ç–æ –º—ã –±—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ <code>&amp;mut self</code> –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–µ—Ä–≤–æ–≥–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞. –ú–µ—Ç–æ–¥—ã, –∫–æ—Ç–æ—Ä—ã–µ –±–µ—Ä—É—Ç —ç–∫–∑–µ–º–ø–ª—è—Ä—ã –≤–æ –≤–ª–∞–¥–µ–Ω–∏–µ (–∏—Å–ø–æ–ª—å–∑—É—è –ø—Ä–æ—Å—Ç–æ <code>self</code> –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–µ—Ä–≤–æ–≥–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞), —è–≤–ª—è—é—Ç—Å—è —Ä–µ–¥–∫–∏–º–∏; —ç—Ç–∞ —Ç–µ—Ö–Ω–∏–∫–∞ –æ–±—ã—á–Ω–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è, –∫–æ–≥–¥–∞ –º–µ—Ç–æ–¥ –ø—Ä–µ–≤—Ä–∞—â–∞–µ—Ç <code>self</code> –≤–æ —á—Ç–æ-–ª–∏–±–æ –¥—Ä—É–≥–æ–µ –∏ –ø—Ä–∏ —ç—Ç–æ–º –≤—ã —Ö–æ—Ç–∏—Ç–µ –∑–∞–ø—Ä–µ—Ç–∏—Ç—å –≤—ã–∑—ã–≤–∞—é—â–µ–π —Å—Ç–æ—Ä–æ–Ω–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏—Å—Ö–æ–¥–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä –ø–æ—Å–ª–µ –ø—Ä–µ–≤—Ä–∞—â–µ–Ω–∏—è.</p>
<p>–û—Å–Ω–æ–≤–Ω–∞—è –ø—Ä–∏—á–∏–Ω–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –º–µ—Ç–æ–¥–æ–≤, –∞ –Ω–µ —Ñ—É–Ω–∫—Ü–∏–π (–Ω–µ —Å—á–∏—Ç–∞—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –Ω–µ—è–≤–Ω–æ –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å —ç–∫–∑–µ–º–ø–ª—è—Ä –≤ —Ñ—É–Ω–∫—Ü–∏—é), –∑–∞–∫–ª—é—á–∞–µ—Ç—Å—è –≤ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ –∫–æ–¥–∞. –ú—ã –º–æ–∂–µ–º –ø–æ–º–µ—Å—Ç–∏—Ç—å –≤—Å—ë, —á—Ç–æ –º—ã –º–æ–∂–µ–º —Å–¥–µ–ª–∞—Ç—å —Å —ç–∫–∑–µ–º–ø–ª—è—Ä–æ–º —Ç–∏–ø–∞, –≤ –æ–¥–∏–Ω <code>impl</code>, –≤–º–µ—Å—Ç–æ —Ç–æ–≥–æ, —á—Ç–æ–±—ã –∑–∞—Å—Ç–∞–≤–ª—è—Ç—å –±—É–¥—É—â–∏—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –Ω–∞—à–µ–≥–æ –∫–æ–¥–∞ –∏—Å–∫–∞—Ç—å –¥–æ—Å—Ç—É–ø–Ω—ã–π —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª <code>Rectangle</code> –≤ —Ä–∞–∑–Ω—ã—Ö –º–µ—Å—Ç–∞—Ö –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ–º–æ–π –Ω–∞–º–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏.</p>
<p>–û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ –º—ã –º–æ–∂–µ–º –¥–∞—Ç—å –º–µ—Ç–æ–¥—É —Ç–æ –∂–µ –∏–º—è, —á—Ç–æ –∏ –æ–¥–Ω–æ–º—É –∏–∑ –ø–æ–ª–µ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã. –ù–∞–ø—Ä–∏–º–µ—Ä, –¥–ª—è <code>Rectangle</code> –º—ã –º–æ–∂–µ–º –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –º–µ—Ç–æ–¥ <code>width</code>:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn width(&amp;self) -&gt; bool {
        self.width &gt; 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() {
        println!("–î–ª–∏–Ω–∞ –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∞ –Ω–µ–Ω—É–ª–µ–≤–∞—è –∏ —Ä–∞–≤–Ω–∞ {}", rect1.width);
    }
}</code></pre></pre>
</Listing>
<p>–ó–¥–µ—Å—å –º—ã –æ–ø—Ä–µ–¥–µ–ª–∏–ª–∏, —á—Ç–æ –º–µ—Ç–æ–¥ <code>width</code> –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ <code>true</code>, –µ—Å–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ –≤ –ø–æ–ª–µ <code>width</code> —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ –±–æ–ª—å—à–µ <code>0</code>, –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ <code>false</code>, –µ—Å–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ —Ä–∞–≤–Ω–æ <code>0</code>: –º—ã –º–æ–∂–µ–º —Å–æ–∑–¥–∞–≤–∞—Ç—å –º–µ—Ç–æ–¥—ã —Å —Ç–µ–º–∏ –∂–µ –∏–º–µ–Ω–∞–º–∏, —á—Ç–æ –∏ –ø–æ–ª—è, –∏ –¥–∞–∂–µ –∑–∞—Ç–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ª—é–±—ã–µ –ø–æ–ª—è –≤ —Ç–µ–ª–µ –º–µ—Ç–æ–¥–æ–≤. –í <code>main</code>, –∫–æ–≥–¥–∞ –º—ã —Å—Ç–∞–≤–∏–º –ø–æ—Å–ª–µ <code>rect1.width</code> –∫—Ä—É–≥–ª—ã–µ —Å–∫–æ–±–∫–∏, Rust –ø–æ–Ω–∏–º–∞–µ—Ç, —á—Ç–æ –º—ã –∏–º–µ–µ–º –≤ –≤–∏–¥—É –º–µ—Ç–æ–¥ <code>width</code>. –ï—Å–ª–∏ –∂–µ –º—ã –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫—Ä—É–≥–ª—ã–µ —Å–∫–æ–±–∫–∏, Rust –ø–æ–Ω–∏–º–∞–µ—Ç, —á—Ç–æ –º—ã –∏–º–µ–µ–º –≤ –≤–∏–¥—É –ø–æ–ª–µ <code>width</code>.</p>
<p>–ß–∞—Å—Ç–æ, –Ω–æ –Ω–µ –≤—Å–µ–≥–¥–∞, –∫–æ–≥–¥–∞ –º—ã —Å–æ–∑–¥–∞—ë–º –º–µ—Ç–æ–¥—ã —Å —Ç–µ–º –∂–µ –∏–º–µ–Ω–µ–º, —á—Ç–æ –∏ —É –ø–æ–ª—è, –º—ã —Ö–æ—Ç–∏–º, —á—Ç–æ–±—ã –æ–Ω —Ç–æ–ª—å–∫–æ –≤–æ–∑–≤—Ä–∞—â–∞–ª –∑–Ω–∞—á–µ–Ω–∏–µ –æ–¥–Ω–æ–∏–º—ë–Ω–Ω–æ–≥–æ –ø–æ–ª—è –∏ –±–æ–ª—å—à–µ –Ω–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞–ª. –ü–æ–¥–æ–±–Ω—ã–µ –º–µ—Ç–æ–¥—ã –Ω–∞–∑—ã–≤–∞—é—Ç—Å—è <em>–≥–µ—Ç—Ç–µ—Ä–∞–º–∏</em>, –∏ Rust –∏—Ö –Ω–µ —Ä–µ–∞–ª–∏–∑—É–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –¥–ª—è –ø–æ–ª–µ–π —Å—Ç—Ä—É–∫—Ç—É—Ä, –∫–∞–∫ —ç—Ç–æ –¥–µ–ª–∞—é—Ç –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –¥—Ä—É–≥–∏–µ —è–∑—ã–∫–∏. –ì–µ—Ç—Ç–µ—Ä—ã –ø–æ–ª–µ–∑–Ω—ã —Ç–µ–º, —á—Ç–æ –≤—ã –º–æ–∂–µ—Ç–µ —Å–¥–µ–ª–∞—Ç—å –ø–æ–ª–µ –ø—Ä–∏–≤–∞—Ç–Ω—ã–º, –∞ –º–µ—Ç–æ–¥ ‚Äî –ø—É–±–ª–∏—á–Ω—ã–º, –∏, —Ç–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, –≤–∫–ª—é—á–∏—Ç—å –≤ API —ç—Ç–æ–≥–æ —Ç–∏–ø–∞ –¥–æ—Å—Ç—É–ø –∫ —ç—Ç–æ–º—É –ø–æ–ª—é –ª–∏—à—å –¥–ª—è —á—Ç–µ–Ω–∏—è. –ú—ã –æ–±—Å—É–¥–∏–º, —á—Ç–æ —Ç–∞–∫–æ–µ –ø—É–±–ª–∏—á–Ω–æ—Å—Ç—å –∏ –ø—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç—å, –∏ –∫–∞–∫ –æ–±–æ–∑–Ω–∞—á–∏—Ç—å –ø–æ–ª–µ –∏–ª–∏ –º–µ—Ç–æ–¥ –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø—É–±–ª–∏—á–Ω–æ–≥–æ –∏–ª–∏ –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ, –≤ <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#%D0%A0%D0%B0%D1%81%D0%BA%D1%80%D1%8B%D1%82%D0%B8%D0%B5-%D0%BF%D1%83%D1%82%D0%B5%D0%B9-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D0%BE%D0%B3%D0%BE-%D1%81%D0%BB%D0%BE%D0%B2%D0%B0-pub">–ì–ª–∞–≤–µ 7</a><!-- ignore -->.</p>
<blockquote>
<h3 id="–ï—Å—Ç—å-–ª–∏-—Ç—É—Ç-–æ–ø–µ—Ä–∞—Ç–æ—Ä--"><a class="header" href="#–ï—Å—Ç—å-–ª–∏-—Ç—É—Ç-–æ–ø–µ—Ä–∞—Ç–æ—Ä--">–ï—Å—Ç—å –ª–∏ —Ç—É—Ç –æ–ø–µ—Ä–∞—Ç–æ—Ä <code>-&gt;</code>?</a></h3>
<p>–í C –∏ C++ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –¥–≤–∞ —Ä–∞–∑–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ –¥–ª—è –≤—ã–∑–æ–≤–∞ –º–µ—Ç–æ–¥–æ–≤: <code>.</code> –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è, –µ—Å–ª–∏ –º–µ—Ç–æ–¥ –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –Ω–µ–ø–æ—Å—Ä–µ–¥—Å—Ç–≤–µ–Ω–Ω–æ —É —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã; <code>-&gt;</code> –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è, –µ—Å–ª–∏ –º–µ—Ç–æ–¥ –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –Ω–∞ —É–∫–∞–∑–∞—Ç–µ–ª–µ –Ω–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä—É, –∏ –ø–æ—Ç–æ–º—É –∫–æ—Ç–æ—Ä—É—é –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —Ä–∞–∑—ã–º–µ–Ω–æ–≤–∞—Ç—å –ø–µ—Ä–µ–¥ –≤—ã–∑–æ–≤–æ–º –º–µ—Ç–æ–¥–∞. –î—Ä—É–≥–∏–º–∏ —Å–ª–æ–≤–∞–º–∏, –µ—Å–ª–∏ <code>object</code> ‚Äî —ç—Ç–æ —É–∫–∞–∑–∞—Ç–µ–ª—å, —Ç–æ –≤—ã–∑–æ–≤—ã –º–µ—Ç–æ–¥–∞ <code>object-&gt;something()</code> –∏ <code>(*object).something()</code> —è–≤–ª—è—é—Ç—Å—è, –ø–æ —Å—É—Ç–∏, –æ–¥–Ω–∏–º –∏ —Ç–µ–º –∂–µ.</p>
<p>Rust –Ω–µ –∏–º–µ–µ—Ç —ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–∞ –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ <code>-&gt;</code>. –í–º–µ—Å—Ç–æ –Ω–µ–≥–æ –≤ Rust –µ—Å—Ç—å –º–µ—Ö–∞–Ω–∏–∑–º <em>–∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –≤–∑—è—Ç–∏—è —Å—Å—ã–ª–æ–∫ –∏ –∏—Ö —Ä–∞–∑—ã–º–µ–Ω–æ–≤–∞–Ω–∏—è</em>. –í—ã–∑–æ–≤ –º–µ—Ç–æ–¥–æ–≤ —è–≤–ª—è–µ—Ç—Å—è –æ–¥–Ω–∏–º –∏–∑ –Ω–µ–º–Ω–æ–≥–∏—Ö –º–µ—Å—Ç –≤ Rust, –≤ –∫–æ—Ç–æ—Ä–æ–º –µ—Å—Ç—å —Ç–∞–∫–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ.</p>
<p>–í–æ—Ç –∫–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç: –∫–æ–≥–¥–∞ –≤—ã –≤—ã–∑—ã–≤–∞–µ—Ç–µ –º–µ—Ç–æ–¥ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–µ–π <code>object.something()</code>, Rust –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –¥–æ–±–∞–≤–ª—è–µ—Ç <code>&amp;</code>, <code>&amp;mut</code> –∏–ª–∏ <code>*</code>, —Ç–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, —á—Ç–æ–±—ã <code>object</code> —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–æ–≤–∞–ª —Å–∏–≥–Ω–∞—Ç—É—Ä–µ –º–µ—Ç–æ–¥–∞. –ó–∞–ø–∏—Å–∏ –Ω–∏–∂–µ —Ä–∞–≤–Ω—ã –¥—Ä—É–≥ –¥—Ä—É–≥—É:</p>
<!-- CAN'T EXTRACT SEE BUG https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug,Copy,Clone)]
</span><span class="boring">struct Point {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Point {
</span><span class="boring">   fn distance(&amp;self, other: &amp;Point) -&gt; f64 {
</span><span class="boring">       let x_squared = f64::powi(other.x - self.x, 2);
</span><span class="boring">       let y_squared = f64::powi(other.y - self.y, 2);
</span><span class="boring">
</span><span class="boring">       f64::sqrt(x_squared + y_squared)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">let p1 = Point { x: 0.0, y: 0.0 };
</span><span class="boring">let p2 = Point { x: 5.0, y: 6.5 };
</span>p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
<span class="boring">}</span></code></pre></pre>
<p>–ü–µ—Ä–≤—ã–π –ø—Ä–∏–º–µ—Ä –≤—ã–≥–ª—è–¥–∏—Ç –Ω–∞–º–Ω–æ–≥–æ –ø–æ–Ω—è—Ç–Ω–µ–µ. –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –≤–∑—è—Ç–∏–µ —Å—Å—ã–ª–∫–∏ —Ä–∞–±–æ—Ç–∞–µ—Ç –ø–æ—Ç–æ–º—É, —á—Ç–æ –º–µ—Ç–æ–¥—É –∏–∑–≤–µ—Å—Ç–Ω–æ, –Ω–∞ —á—ë–º –æ–Ω –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è ‚Äî –Ω–∞ <code>self</code>. –£—á–∏—Ç—ã–≤–∞—è –≤—ã–∑—ã–≤–∞—é—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏—è –∏ –∏–º—è –º–µ—Ç–æ–¥–∞, Rust –º–æ–∂–µ—Ç —Ç–æ—á–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å, —á—Ç–æ –≤ –¥–∞–Ω–Ω–æ–º —Å–ª—É—á–∞–µ –¥–µ–ª–∞–µ—Ç –∫–æ–¥: —á–∏—Ç–∞–µ—Ç –ª–∏ –º–µ—Ç–æ–¥ (<code>&amp;self</code>), –¥–µ–ª–∞–µ—Ç –ª–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–µ (<code>&amp;mut self</code>) –∏–ª–∏ –ø–æ–≥–ª–æ—â–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ (<code>self</code>). –¢–æ—Ç —Ñ–∞–∫—Ç, —á—Ç–æ Rust –º–æ–∂–µ—Ç –Ω–µ—è–≤–Ω–æ –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞—Ç—å –≤—ã–∑—ã–≤–∞—é—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ, –≤ –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ–π —Å—Ç–µ–ø–µ–Ω–∏ —Å–ø–æ—Å–æ–±—Å—Ç–≤—É–µ—Ç —Ç–æ–º—É, —á—Ç–æ–±—ã –¥–µ–ª–∞—Ç—å –≤–ª–∞–¥–µ–Ω–∏–µ —ç—Ä–≥–æ–Ω–æ–º–∏—á–Ω—ã–º –∏ –ø—Ä–∞–∫—Ç–∏—á–Ω—ã–º.</p>
</blockquote>
<h3 id="–ú–µ—Ç–æ–¥—ã-—Å-–Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏-–ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏"><a class="header" href="#–ú–µ—Ç–æ–¥—ã-—Å-–Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏-–ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏">–ú–µ—Ç–æ–¥—ã —Å –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏</a></h3>
<p>–î–∞–≤–∞–π—Ç–µ –ø–æ–ø—Ä–∞–∫—Ç–∏–∫—É–µ–º—Å—è –≤ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ –º–µ—Ç–æ–¥–æ–≤, —Ä–µ–∞–ª–∏–∑–æ–≤–∞–≤ –≤—Ç–æ—Ä–æ–π –º–µ—Ç–æ–¥ –Ω–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–µ <code>Rectangle</code>. –ù–∞ —ç—Ç–æ—Ç —Ä–∞–∑ –º—ã —Ö–æ—Ç–∏–º, —á—Ç–æ–±—ã —ç–∫–∑–µ–º–ø–ª—è—Ä <code>Rectangle</code> –±—Ä–∞–ª –¥—Ä—É–≥–æ–π —ç–∫–∑–µ–º–ø–ª—è—Ä <code>Rectangle</code> –∏ –≤–æ–∑–≤—Ä–∞—â–∞–ª <code>true</code>, –µ—Å–ª–∏ –≤—Ç–æ—Ä–æ–π <code>Rectangle</code> –º–æ–∂–µ—Ç –ø–æ–ª–Ω–æ—Å—Ç—å—é –ø–æ–º–µ—Å—Ç–∏—Ç—å—Å—è –≤–Ω—É—Ç—Ä–∏ <code>self</code> (—Ç–æ –µ—Å—Ç—å, –ø–µ—Ä–≤–æ–≥–æ <code>Rectangle</code>); –≤ –ø—Ä–æ—Ç–∏–≤–Ω–æ–º —Å–ª—É—á–∞–µ –æ–Ω –¥–æ–ª–∂–µ–Ω –≤–µ—Ä–Ω—É—Ç—å <code>false</code>. –° —Ç–∞–∫–∏–º –º–µ—Ç–æ–¥–æ–º –º—ã –º–æ–≥–ª–∏ –±—ã –Ω–∞–ø–∏—Å–∞—Ç—å –ø—Ä–æ–≥—Ä–∞–º–º—É –∫–∞–∫ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 5-14:</p>
<Listing number="5-14" file-name="src/main.rs" caption="Using the as-yet-unwritten `can_hold` method">
<pre><code class="language-rust ignore">fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!("–í–º–µ—Å—Ç–∏—Ç—Å—è –ª–∏ rect2 –≤ rect1? {}", rect1.can_hold(&amp;rect2));
    println!("–í–º–µ—Å—Ç–∏—Ç—Å—è –ª–∏ rect3 –≤ rect1? {}", rect1.can_hold(&amp;rect3));
}</code></pre>
</Listing>
<p>–û–∂–∏–¥–∞–µ–º—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –±—É–¥–µ—Ç –≤—ã–≥–ª—è–¥–µ—Ç—å —Ç–∞–∫, –∫–∞–∫ –Ω–∏–∂–µ: 1) –æ–±–∞ –∏–∑–º–µ—Ä–µ–Ω–∏—è —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ <code>rect2</code> –º–µ–Ω—å—à–µ, —á–µ–º –∏–∑–º–µ—Ä–µ–Ω–∏—è —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ <code>rect1</code>, –∏ 2) <code>rect3</code> —à–∏—Ä–µ, —á–µ–º <code>rect1</code>.</p>
<pre><code class="language-text">Can rect1 hold rect2? true
Can rect1 hold rect3? false
</code></pre>
<p>–ú—ã –∑–Ω–∞–µ–º, —á—Ç–æ —Ö–æ—Ç–∏–º –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∏–º–µ–Ω–Ω–æ –º–µ—Ç–æ–¥, –ø–æ—ç—Ç–æ–º—É –æ–Ω –±—É–¥–µ—Ç –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ –±–ª–æ–∫–µ <code>impl Rectangle</code>. –ò–º—è –º–µ—Ç–æ–¥–∞ –±—É–¥–µ—Ç <code>can_hold</code>, –∏ –æ–Ω–æ –±—É–¥–µ—Ç –ø—Ä–∏–Ω–∏–º–∞—Ç—å –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –Ω–µ–∏–∑–º–µ–Ω—è–µ–º–æ–µ –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –Ω–∞ –¥—Ä—É–≥–æ–π <code>Rectangle</code>. –ú—ã –º–æ–∂–µ–º —Å–∫–∞–∑–∞—Ç—å, –∫–∞–∫–æ–π –±—É–¥–µ—Ç —Ç–∏–ø –ø–∞—Ä–∞–º–µ—Ç—Ä–∞, –ø–æ—Å–º–æ—Ç—Ä–µ–≤ –Ω–∞ –∫–æ–¥ –≤—ã–∑–æ–≤–∞ –º–µ—Ç–æ–¥–∞: <code>rect1.can_hold(&amp;rect2)</code> –ø–µ—Ä–µ–¥–∞—ë—Ç –≤ –º–µ—Ç–æ–¥ <code>&amp;rect2</code>, —á—Ç–æ —è–≤–ª—è–µ—Ç—Å—è –Ω–µ–∏–∑–º–µ–Ω—è–µ–º—ã–º –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ <code>rect2</code> —Ç–∏–ø–∞ <code>Rectangle</code>. –í —ç—Ç–æ–º –µ—Å—Ç—å —Å–º—ã—Å–ª, –ø–æ—Ç–æ–º—É —á—Ç–æ –Ω–∞–º –Ω—É–∂–Ω–æ –ª–∏—à—å —á–∏—Ç–∞—Ç—å <code>rect2</code> (–∞ –Ω–µ –ø–∏—Å–∞—Ç—å, —á—Ç–æ –æ–∑–Ω–∞—á–∞–ª–æ –±—ã, —á—Ç–æ –Ω—É–∂–Ω–æ –∏–∑–º–µ–Ω—è–µ–º–æ–µ –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–µ), –∏ –º—ã —Ö–æ—Ç–∏–º, —á—Ç–æ–±—ã <code>main</code> —Å–æ—Ö—Ä–∞–Ω–∏–ª–∞ –≤–ª–∞–¥–µ–Ω–∏–µ —ç–∫–∑–µ–º–ø–ª—è—Ä–æ–º <code>rect2</code>, —á—Ç–æ–±—ã –º—ã –º–æ–≥–ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –µ–≥–æ —Å–Ω–æ–≤–∞ –ø–æ—Å–ª–µ –≤—ã–∑–æ–≤–∞ –º–µ—Ç–æ–¥–∞ <code>can_hold</code>. –í–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ <code>can_hold</code> –∏–º–µ–µ—Ç –ª–æ–≥–∏—á–µ—Å–∫–∏–π —Ç–∏–ø, –∞ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è—é—Ç—Å—è –ª–∏ —à–∏—Ä–∏–Ω–∞ –∏ –≤—ã—Å–æ—Ç–∞ <code>self</code> –±–æ–ª—å—à–µ, —á–µ–º, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ, —à–∏—Ä–∏–Ω–∞ –∏ –≤—ã—Å–æ—Ç–∞ –¥—Ä—É–≥–æ–≥–æ <code>Rectangle</code>. –í –õ–∏—Å—Ç–∏–Ω–≥–µ 5-15 –ø—Ä–∏–≤–µ–¥–µ–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –º–µ—Ç–æ–¥–∞ <code>can_hold</code>, –¥–æ–±–∞–≤–ª–µ–Ω–Ω–æ–≥–æ –≤ –±–ª–æ–∫ <code>impl</code> –∏–∑ –õ–∏—Å—Ç–∏–Ω–≥–∞ 5-13.</p>
<Listing number="5-15" file-name="src/main.rs" caption="Implementing the `can_hold` method on `Rectangle` that takes another `Rectangle` instance as a parameter">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("–í–º–µ—Å—Ç–∏—Ç—Å—è –ª–∏ rect2 –≤ rect1? {}", rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!("–í–º–µ—Å—Ç–∏—Ç—Å—è –ª–∏ rect3 –≤ rect1? {}", rect1.can_hold(&amp;rect3));
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>–ï—Å–ª–∏ –º—ã –∑–∞–ø—É—Å—Ç–∏–º –∫–æ–¥ —Å —Ñ—É–Ω–∫—Ü–∏–µ–π <code>main</code> –∏–∑ –õ–∏—Å—Ç–∏–Ω–≥–∞ 5-14, –º—ã –ø–æ–ª—É—á–∏–º –∂–µ–ª–∞–µ–º—ã–π –≤—ã–≤–æ–¥. –ú–µ—Ç–æ–¥—ã –º–æ–≥—É—Ç –ø—Ä–∏–Ω–∏–º–∞—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤: –º—ã –¥–æ–±–∞–≤–ª—è–µ–º –∏—Ö –≤ —Å–∏–≥–Ω–∞—Ç—É—Ä—É –ø–æ—Å–ª–µ –ø–µ—Ä–≤–æ–≥–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ <code>self</code>. –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –º–µ—Ç–æ–¥–æ–≤ —Ä–∞–±–æ—Ç–∞—é—Ç —Ç–æ—á–Ω–æ —Ç–∞–∫ –∂–µ, –∫–∞–∫ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Ñ—É–Ω–∫—Ü–∏–∏.</p>
<h3 id="–ê—Å—Å–æ—Ü–∏–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ-—Ñ—É–Ω–∫—Ü–∏–∏"><a class="header" href="#–ê—Å—Å–æ—Ü–∏–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ-—Ñ—É–Ω–∫—Ü–∏–∏">–ê—Å—Å–æ—Ü–∏–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏</a></h3>
<p>–í—Å–µ —Ñ—É–Ω–∫—Ü–∏–∏, –æ–ø—Ä–µ–¥–µ–ª—è–µ–º—ã–µ –≤ –±–ª–æ–∫–µ <code>impl</code>, –Ω–∞–∑—ã–≤–∞—é—Ç—Å—è <em>–∞—Å—Å–æ—Ü–∏–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ —Ñ—É–Ω–∫—Ü–∏—è–º–∏</em>, –ø–æ—Ç–æ–º—É —á—Ç–æ –æ–Ω–∏ –∞—Å—Å–æ—Ü–∏–∏—Ä–æ–≤–∞–Ω—ã —Å —Ç–∏–ø–æ–º, —É–∫–∞–∑–∞–Ω–Ω—ã–º –ø–æ—Å–ª–µ –∫–ª—é—á–µ–≤–æ–≥–æ —Å–ª–æ–≤–∞ <code>impl</code>. –ú—ã –º–æ–∂–µ–º –æ–ø—Ä–µ–¥–µ–ª—è—Ç—å –∏ —Ç–∞–∫–∏–µ –∞—Å—Å–æ—Ü–∏–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç <code>self</code> –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–µ—Ä–≤–æ–≥–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ (–∏, —Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ, –Ω–µ —è–≤–ª—è—é—Ç—Å—è –º–µ—Ç–æ–¥–∞–º–∏), –ø–æ—Å–∫–æ–ª—å–∫—É –∏–º –Ω–µ –Ω—É–∂–µ–Ω —ç–∫–∑–µ–º–ø–ª—è—Ä —Ç–∏–ø–∞ –¥–ª—è —Ä–∞–±–æ—Ç—ã. –ú—ã —É–∂–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ –æ–¥–Ω—É —Ç–∞–∫—É—é —Ñ—É–Ω–∫—Ü–∏—é: —Ñ—É–Ω–∫—Ü–∏—é <code>String::from</code>, –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—É—é –¥–ª—è —Ç–∏–ø–∞ <code>String</code>.</p>
<p>–ê—Å—Å–æ—Ü–∏–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ —á–∞—Å—Ç–æ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –¥–ª—è –Ω–∞–ø–∏—Å–∞–Ω–∏—è –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–æ–≤, ‚Äî —Ñ—É–Ω–∫—Ü–∏–π, –≤–æ–∑–≤—Ä–∞—â–∞—é—â–∏—Ö –Ω–æ–≤—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä —Å—Ç—Ä—É–∫—Ç—É—Ä—ã. –ò—Ö —á–∞—Å—Ç–æ –Ω–∞–∑—ã–≤–∞—é—Ç —Å–ª–æ–≤–æ–º <code>new</code>, –Ω–æ <code>new</code> –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –∫–∞–∫–∏–º-—Ç–æ –∑–∞—Ä–µ–∑–µ—Ä–≤–∏—Ä–æ–≤–∞–Ω–Ω—ã–º –∏–º–µ–Ω–µ–º –∏ –Ω–µ –≤—Å—Ç—Ä–æ–µ–Ω–æ –≤ —è–∑—ã–∫. –ù–∞–ø—Ä–∏–º–µ—Ä, –º—ã –º–æ–∂–µ–º –Ω–∞–ø–∏—Å–∞—Ç—å –∞—Å—Å–æ—Ü–∏–∏—Ä–æ–≤–∞–Ω–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é —Å –∏–º–µ–Ω–µ–º <code>square</code>, –∫–æ—Ç–æ—Ä–∞—è –±—É–¥–µ—Ç –∏–º–µ—Ç—å –æ–¥–∏–Ω –ø–∞—Ä–∞–º–µ—Ç—Ä —Ä–∞–∑–º–µ—Ä–∞ –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –µ–≥–æ –∏ –∫–∞–∫ —à–∏—Ä–∏–Ω—É, –∏ –∫–∞–∫ –≤—ã—Å–æ—Ç—É. –≠—Ç–æ —É–ø—Ä–æ—Å—Ç–∏—Ç —Å–æ–∑–¥–∞–Ω–∏–µ –∫–≤–∞–¥—Ä–∞—Ç–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–∏–ø–∞ <code>Rectangle</code> ‚Äî –Ω–µ –ø–æ–Ω–∞–¥–æ–±–∏—Ç—Å—è —É–∫–∞–∑—ã–≤–∞—Ç—å —à–∏—Ä–∏–Ω—É –∏ –≤—ã—Å–æ—Ç—É –¥–≤–∞–∂–¥—ã:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn square(size: u32) -&gt; Self {
        Self {
            width: size,
            height: size,
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let sq = Rectangle::square(3);
</span><span class="boring">}</span></code></pre></pre>
<p>–ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ <code>Self</code> (–≤ —Å–∏–≥–Ω–∞—Ç—É—Ä–µ –∏ –≤ —Ç–µ–ª–µ —Ñ—É–Ω–∫—Ü–∏–∏) —è–≤–ª—è—é—Ç—Å—è –ø—Å–µ–≤–¥–æ–Ω–∏–º–∞–º–∏ –¥–ª—è —Ç–∏–ø–∞, —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ –ø–æ—Å–ª–µ –∫–ª—é—á–µ–≤–æ–≥–æ —Å–ª–æ–≤–∞ <code>impl</code>, –∫–æ—Ç–æ—Ä—ã–º –≤ –¥–∞–Ω–Ω–æ–º —Å–ª—É—á–∞–µ —è–≤–ª—è–µ—Ç—Å—è <code>Rectangle</code>.</p>
<p>–ß—Ç–æ–±—ã –≤—ã–∑—ã–≤–∞—Ç—å –∞—Å—Å–æ—Ü–∏–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏, –ø–∏—à–µ—Ç—Å—è –æ–ø–µ—Ä–∞—Ç–æ—Ä <code>::</code> –∏ –∏–º—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –ø–æ—Å–ª–µ –Ω–µ–≥–æ; –Ω–∞–ø—Ä–∏–º–µ—Ä, <code>let sq = Rectangle::square(3);</code>. –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ –∏–º—ë–Ω —Å—Ç—Ä—É–∫—Ç—É—Ä—ã. –°–∏–Ω—Ç–∞–∫—Å–∏—Å <code>::</code> –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∫–∞–∫ –¥–ª—è –∞—Å—Å–æ—Ü–∏–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π, —Ç–∞–∫ –∏ –¥–ª—è –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤ –∏–º—ë–Ω, –æ–±—Ä–∞–∑—É–µ–º—ã—Ö –º–æ–¥—É–ª—è–º–∏. –ú—ã –æ–±—Å—É–¥–∏–º –º–æ–¥—É–ª–∏ –≤ <a href="ch07-02-defining-modules-to-control-scope-and-privacy.html">–ì–ª–∞–≤–µ 7</a><!-- ignore -->.</p>
<h3 id="–ù–µ—Å–∫–æ–ª—å–∫–æ-–±–ª–æ–∫–æ–≤-impl"><a class="header" href="#–ù–µ—Å–∫–æ–ª—å–∫–æ-–±–ª–æ–∫–æ–≤-impl">–ù–µ—Å–∫–æ–ª—å–∫–æ –±–ª–æ–∫–æ–≤ <code>impl</code></a></h3>
<p>–õ—é–±–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –º–æ–∂–µ—Ç –∏–º–µ—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ <code>impl</code>. –ù–∞–ø—Ä–∏–º–µ—Ä, –∫–æ–¥ –õ–∏—Å—Ç–∏–Ω–≥–∞ 5-15 —ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–µ–Ω –∫–æ–¥—É –õ–∏—Å—Ç–∏–Ω–≥–∞ 5-16, –æ–ø—Ä–µ–¥–µ–ª—è—é—â–µ–º—É –∫–∞–∂–¥—ã–π –º–µ—Ç–æ–¥ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –±–ª–æ–∫–µ <code>impl</code>.</p>
<Listing number="5-16" caption="Rewriting Listing 5-15 using multiple `impl` blocks">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("–í–º–µ—Å—Ç–∏—Ç—Å—è –ª–∏ rect2 –≤ rect1? {}", rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!("–í–º–µ—Å—Ç–∏—Ç—Å—è –ª–∏ rect3 –≤ rect1? {}", rect1.can_hold(&amp;rect3));
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>–í –¥–∞–Ω–Ω–æ–º —Å–ª—É—á–∞–µ, –Ω–µ—Ç –ø—Ä–∏—á–∏–Ω —Ä–∞–∑–±–∏–≤–∞—Ç—å –º–µ—Ç–æ–¥—ã –Ω–∞ –Ω–µ—Å–∫–æ–ª—å–∫–æ –±–ª–æ–∫–æ–≤ <code>impl</code>, –æ–¥–Ω–∞–∫–æ —ç—Ç–æ –≤—Å—ë-—Ç–∞–∫–∏ —Ä–µ–∞–ª–∏–∑—É–µ–º–æ. –ú—ã —É–≤–∏–¥–∏–º —Å–ª—É—á–∞–π, –∫–æ–≥–¥–∞ –Ω–µ—Å–∫–æ–ª—å–∫–æ <code>impl</code> –º–æ–≥—É—Ç –æ–∫–∞–∑–∞—Ç—å—Å—è –ø–æ–ª–µ–∑–Ω—ã–º–∏, –≤ –ì–ª–∞–≤–µ 10, —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞—é—â–µ–π –æ–±–æ–±—â—ë–Ω–Ω—ã–µ —Ç–∏–ø—ã –∏ —Ç—Ä–µ–π—Ç—ã.</p>
<h2 id="–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-4"><a class="header" href="#–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-4">–ü–æ–¥–≤–µ–¥—ë–º –∏—Ç–æ–≥–∏</a></h2>
<p>–°—Ç—Ä—É–∫—Ç—É—Ä—ã –ø–æ–∑–≤–æ–ª—è—é—Ç –≤–∞–º —Å–æ–∑–¥–∞–≤–∞—Ç—å —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ —Ç–∏–ø—ã, –∫–æ—Ç–æ—Ä—ã–µ –∏–º–µ—é—Ç —Å–º—ã—Å–ª –≤ –≤–∞—à–µ–π –ø—Ä–µ–¥–º–µ—Ç–Ω–æ–π –æ–±–ª–∞—Å—Ç–∏. –ò—Å–ø–æ–ª—å–∑—É—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, –≤—ã –º–æ–∂–µ—Ç–µ —Ö—Ä–∞–Ω–∏—Ç—å –≤–º–µ—Å—Ç–µ –∏ –∏–º–µ–Ω–æ–≤–∞—Ç—å —Å–≤—è–∑–∞–Ω–Ω—ã–µ –¥—Ä—É–≥ —Å –¥—Ä—É–≥–æ–º —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ã –¥–∞–Ω–Ω—ã—Ö, —á—Ç–æ–±—ã –¥–µ–ª–∞—Ç—å –≤–∞—à –∫–æ–¥ —á–∏—â–µ. –í –±–ª–æ–∫–∞—Ö <code>impl</code> –≤—ã –º–æ–∂–µ—Ç–µ –æ–ø—Ä–µ–¥–µ–ª—è—Ç—å 1) —Ñ—É–Ω–∫—Ü–∏–∏, –∞—Å—Å–æ—Ü–∏–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å –≤–∞—à–∏–º —Ç–∏–ø–æ–º, –∏ 2) –º–µ—Ç–æ–¥—ã ‚Äî —Å–≤–æ–µ–≥–æ —Ä–æ–¥–∞ –∞—Å—Å–æ—Ü–∏–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏, –ø–æ–≤–µ–¥–µ–Ω–∏–µ –∫–æ—Ç–æ—Ä—ã—Ö –∑–∞–≤–∏—Å–∏—Ç –≤ —Ç–æ–º —á–∏—Å–ª–µ –æ—Ç —ç–∫–∑–µ–º–ø–ª—è—Ä–æ–≤, –Ω–∞ –∫–æ—Ç–æ—Ä—ã—Ö –≤—ã –∏—Ö –≤—ã–∑—ã–≤–∞–µ—Ç–µ.</p>
<p>–ù–æ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã ‚Äî –Ω–µ –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π —Å–ø–æ—Å–æ–± —Å–æ–∑–¥–∞–≤–∞—Ç—å —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ —Ç–∏–ø—ã. –î–∞–≤–∞–π—Ç–µ –ø–æ—Å–º–æ—Ç—Ä–∏–º –Ω–∞ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è ‚Äî –µ—â—ë –æ–¥–∏–Ω –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –≤ –≤–∞—à–µ–º –∞—Ä—Å–µ–Ω–∞–ª–µ.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="–ü–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è-–∏-—Å–æ—Å–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ-—Å-—à–∞–±–ª–æ–Ω–æ–º"><a class="header" href="#–ü–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è-–∏-—Å–æ—Å–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ-—Å-—à–∞–±–ª–æ–Ω–æ–º">–ü–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –∏ —Å–æ—Å–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ —Å —à–∞–±–ª–æ–Ω–æ–º</a></h1>
<p>–í —ç—Ç–æ–π –≥–ª–∞–≤–µ –º—ã —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º <em>–ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è</em>. –ü–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –ø–æ–∑–≤–æ–ª—è—é—Ç –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ç–∏–ø –ø—É—Ç—ë–º –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –µ–≥–æ –≤–æ–∑–º–æ–∂–Ω—ã—Ö <em>–≤–∞—Ä–∏–∞–Ω—Ç–æ–≤</em>. –°–Ω–∞—á–∞–ª–∞ –º—ã –æ–ø—Ä–µ–¥–µ–ª–∏–º –∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ, —á—Ç–æ–±—ã –ø–æ–∫–∞–∑–∞—Ç—å, –∫–∞–∫ –æ–Ω–æ –º–æ–∂–µ—Ç –æ–±—ä–µ–¥–∏–Ω—è—Ç—å —Å–º—ã—Å–ª –∏ –¥–∞–Ω–Ω—ã–µ. –î–∞–ª–µ–µ –º—ã —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º –æ—Å–æ–±–µ–Ω–Ω–æ –ø–æ–ª–µ–∑–Ω–æ–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ –ø–æ–¥ –Ω–∞–∑–≤–∞–Ω–∏–µ–º <code>Option</code>, –∫–æ—Ç–æ—Ä–æ–µ –≤—ã—Ä–∞–∂–∞–µ—Ç, —á—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ª–∏–±–æ —á–µ–º-—Ç–æ, –ª–∏–±–æ –Ω–∏—á–µ–º. –ó–∞—Ç–µ–º –º—ã —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º, –∫–∞–∫ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ —Å –æ–±—Ä–∞–∑—Ü–æ–º –≤ –≤—ã—Ä–∞–∂–µ–Ω–∏–∏ <code>match</code> –ø–æ–∑–≤–æ–ª—è–µ—Ç –ª–µ–≥–∫–æ –∑–∞–ø—É—Å–∫–∞—Ç—å —Ä–∞–∑–Ω—ã–π –∫–æ–¥ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è. –ù–∞–∫–æ–Ω–µ—Ü, –º—ã —É–∑–Ω–∞–µ–º, –Ω–∞—Å–∫–æ–ª—å–∫–æ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏—è <code>if let</code> —É–¥–æ–±–Ω–∞ –∏ –ª–∞–∫–æ–Ω–∏—á–Ω–∞ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π –≤ –≤–∞—à–µ–º –∫–æ–¥–µ.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ-–ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è"><a class="header" href="#–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ-–ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è">–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è</a></h2>
<p>–¢–∞–º, –≥–¥–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞—é—Ç –≤–∞–º –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∞—Ç—å —Å–≤—è–∑–∞–Ω–Ω—ã–µ –ø–æ–ª—è –∏ –¥–∞–Ω–Ω—ã–µ (–Ω–∞–ø—Ä–∏–º–µ—Ä, <code>Rectangle</code> —Å –µ–≥–æ <code>width</code> –∏ <code>height</code>), –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –¥–∞—é—Ç –≤–∞–º —Å–ø–æ—Å–æ–± —Å–∫–∞–∑–∞—Ç—å, —á—Ç–æ –¥–∞–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —è–≤–ª—è–µ—Ç—Å—è –ª–∏—à—å –æ–¥–Ω–∏–º –∏–∑ –≤–æ–∑–º–æ–∂–Ω—ã—Ö –Ω–∞–±–æ—Ä–æ–≤ –∑–Ω–∞—á–µ–Ω–∏–π. –ù–∞–ø—Ä–∏–º–µ—Ä, –º—ã –º–æ–∂–µ–º –∑–∞—Ö–æ—Ç–µ—Ç—å —Å–∫–∞–∑–∞—Ç—å, —á—Ç–æ <code>Rectangle</code> ‚Äî —ç—Ç–æ –æ–¥–Ω–∞ –∏–∑ –º–Ω–æ–∂–µ—Å—Ç–≤–∞ –≤–æ–∑–º–æ–∂–Ω—ã—Ö —Ñ–∏–≥—É—Ä, –≤ –∫–æ—Ç–æ—Ä—É—é —Ç–∞–∫–∂–µ –≤—Ö–æ–¥—è—Ç <code>Circle</code> –∏ <code>Triangle</code>. Rust –ø–æ–∑–≤–æ–ª—è–µ—Ç –Ω–∞–º –∑–∞–ø–∏—Å–∞—Ç—å —ç—Ç—É –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç—å –≤ –≤–∏–¥–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è.</p>
<p>–î–∞–≤–∞–π—Ç–µ —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º —Å–∏—Ç—É–∞—Ü–∏—é, –∫–æ—Ç–æ—Ä—É—é –º—ã –º–æ–≥–ª–∏ –±—ã –∑–∞—Ö–æ—Ç–µ—Ç—å –æ—Ç—Ä–∞–∑–∏—Ç—å –≤ –∫–æ–¥–µ, –∏ –ø–æ–π–º—ë–º, –ø–æ—á–µ–º—É –≤ —ç—Ç–æ–º —Å–ª—É—á–∞–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –ø–æ–ª–µ–∑–Ω—ã –∏ –±–æ–ª–µ–µ —É–º–µ—Å—Ç–Ω—ã, —á–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—ã. –î–æ–ø—É—Å—Ç–∏–º, –Ω–∞–º –Ω—É–∂–Ω–æ —Ä–∞–±–æ—Ç–∞—Ç—å —Å IP-–∞–¥—Ä–µ—Å–∞–º–∏. –í –Ω–∞—Å—Ç–æ—è—â–µ–µ –≤—Ä–µ–º—è –¥–ª—è –æ–±–æ–∑–Ω–∞—á–µ–Ω–∏—è IP-–∞–¥—Ä–µ—Å–æ–≤ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –¥–≤–∞ –æ—Å–Ω–æ–≤–Ω—ã—Ö —Å—Ç–∞–Ω–¥–∞—Ä—Ç–∞: —á–µ—Ç–≤—ë—Ä—Ç–∞—è –∏ —à–µ—Å—Ç–∞—è –≤–µ—Ä—Å–∏–∏. –ü–æ—Å–∫–æ–ª—å–∫—É —ç—Ç–æ –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ –≤–æ–∑–º–æ–∂–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã IP-–∞–¥—Ä–µ—Å–æ–≤, —Å –∫–æ—Ç–æ—Ä—ã–º–∏ –º–æ–∂–µ—Ç —Å—Ç–æ–ª–∫–Ω—É—Ç—å—Å—è –Ω–∞—à–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∞, –º—ã –º–æ–∂–µ–º <em>–ø–µ—Ä–µ—á–∏—Å–ª–∏—Ç—å</em> –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã: –æ—Ç—Å—é–¥–∞ –∏ —Ç–µ—Ä–º–∏–Ω "–ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ".</p>
<p>–õ—é–±–æ–π IP-–∞–¥—Ä–µ—Å –º–æ–∂–µ—Ç –±—ã—Ç—å –ª–∏–±–æ —á–µ—Ç–≤—ë—Ä—Ç–æ–π, –ª–∏–±–æ —à–µ—Å—Ç–æ–π –≤–µ—Ä—Å–∏–∏, –Ω–æ –Ω–µ –æ–±–µ–∏–º–∏ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ. –≠—Ç–∞ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç—å IP-–∞–¥—Ä–µ—Å–æ–≤ –¥–µ–ª–∞–µ—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä—É –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –ø–æ–ª–Ω–æ—Å—Ç—å—é –Ω–∞–º –ø–æ–¥—Ö–æ–¥—è—â–µ–π, –ø–æ—Å–∫–æ–ª—å–∫—É –∑–Ω–∞—á–µ–Ω–∏–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –º–æ–∂–µ—Ç –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—Ç—å —Å–æ–±–æ–π —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω –∏–∑ –µ–≥–æ –≤–æ–∑–º–æ–∂–Ω—ã—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤. –ê–¥—Ä–µ—Å–∞ –∫–∞–∫ —á–µ—Ç–≤—ë—Ä—Ç–æ–π, —Ç–∞–∫ –∏ —à–µ—Å—Ç–æ–π –≤–µ—Ä—Å–∏–∏ –ø–æ —Å–≤–æ–µ–π —Å—É—Ç–∏ –≤—Å–µ —Ä–∞–≤–Ω–æ —è–≤–ª—è—é—Ç—Å—è IP-–∞–¥—Ä–µ—Å–∞–º–∏, –ø–æ—ç—Ç–æ–º—É –∏—Ö —Å–ª–µ–¥—É–µ—Ç —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞—Ç—å –∫–∞–∫ –æ–¥–∏–Ω –∏ —Ç–æ—Ç –∂–µ —Ç–∏–ø, –∫–æ–≥–¥–∞ –≤ –∫–æ–¥–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç—Å—è –∑–∞–¥–∞—á–∏, –æ—Ç–Ω–æ—Å—è—â–∏–µ—Å—è –∫ –ª—é–±–æ–º—É —Ç–∏–ø—É IP-–∞–¥—Ä–µ—Å–æ–≤.</p>
<p>–ú–æ–∂–Ω–æ –≤—ã—Ä–∞–∑–∏—Ç—å —ç—Ç—É –∫–æ–Ω—Ü–µ–ø—Ü–∏—é –≤ –∫–æ–¥–µ, –æ–ø—Ä–µ–¥–µ–ª–∏–≤ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ <code>IpAddrKind</code> –∏ –ø–µ—Ä–µ—á–∏—Å–ª–∏–≤ –≤–æ–∑–º–æ–∂–Ω—ã–µ –≤–∏–¥—ã IP-–∞–¥—Ä–µ—Å–æ–≤: <code>V4</code> –∏ <code>V6</code>. –í–æ—Ç –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –Ω–∞—à–µ–≥–æ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è:</p>
<pre><pre class="playground"><code class="language-rust edition2021">enum IpAddrKind {
    V4,
    V6,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p><code>IpAddrKind</code> —Ç–µ–ø–µ—Ä—å —è–≤–ª—è–µ—Ç—Å—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–º —Ç–∏–ø–æ–º –¥–∞–Ω–Ω—ã—Ö, –∫–æ—Ç–æ—Ä—ã–π –º—ã –º–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤ –ª—é–±–æ–º –¥—Ä—É–≥–æ–º –º–µ—Å—Ç–µ –Ω–∞—à–µ–≥–æ –∫–æ–¥–∞.</p>
<h3 id="–ó–Ω–∞—á–µ–Ω–∏—è-–ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π"><a class="header" href="#–ó–Ω–∞—á–µ–Ω–∏—è-–ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π">–ó–Ω–∞—á–µ–Ω–∏—è –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π</a></h3>
<p>–≠–∫–∑–µ–º–ø–ª—è—Ä—ã –∫–∞–∂–¥–æ–≥–æ –≤–∞—Ä–∏–∞–Ω—Ç–∞ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è <code>IpAddrKind</code> –º–æ–∂–Ω–æ —Å–æ–∑–¥–∞—Ç—å —Å–ª–µ–¥—É—é—â–∏–º –æ–±—Ä–∞–∑–æ–º:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
<span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p>–û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ –≤–∞—Ä–∏–∞–Ω—Ç—ã –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –Ω–∞—Ö–æ–¥—è—Ç—Å—è –≤ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ –∏–º—ë–Ω –≤–º–µ—Å—Ç–µ —Å –µ–≥–æ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–æ–º, –∞ –¥–ª—è –∏—Ö –æ–±–æ—Å–æ–±–ª–µ–Ω–∏—è –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º –¥–≤–æ–π–Ω–æ–µ –¥–≤–æ–µ—Ç–æ—á–∏–µ. –≠—Ç–æ —É–¥–æ–±–Ω–æ —Ç–µ–º, —á—Ç–æ —Ç–µ–ø–µ—Ä—å –æ–±–∞ –∑–Ω–∞—á–µ–Ω–∏—è <code>IpAddrKind::V4</code> –∏ <code>IpAddrKind::V6</code> –æ—Ç–Ω–æ—Å—è—Ç—Å—è –∫ –æ–¥–Ω–æ–º—É —Ç–∏–ø—É: <code>IpAddrKind</code>. –ó–∞—Ç–µ–º –º—ã –º–æ–∂–µ–º, –Ω–∞–ø—Ä–∏–º–µ—Ä, –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ñ—É–Ω–∫—Ü–∏—é, –∫–æ—Ç–æ—Ä–∞—è –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –ª—é–±–æ–π –∏–∑ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ <code>IpAddrKind</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span>fn route(ip_kind: IpAddrKind) {}</code></pre></pre>
<p>–ú–æ–∂–Ω–æ –≤—ã–∑–≤–∞—Ç—å —ç—Ç—É —Ñ—É–Ω–∫—Ü–∏—é —Å –ª—é–±—ã–º –∏–∑ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span>    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p>–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π –∏–º–µ–µ—Ç –µ—â—ë –±–æ–ª—å—à–µ –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤. –ï—Å–ª–∏ –ø–æ—Ä–∞–∑–º—ã—Å–ª–∏—Ç—å –æ –Ω–∞—à–µ–º —Ç–∏–ø–µ IP-–∞–¥—Ä–µ—Å–∞, —Ç–æ –≤—ã—è—Å–Ω–∏—Ç—Å—è, —á—Ç–æ –Ω–∞ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç —É –Ω–∞—Å –Ω–µ—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ —Ö—Ä–∞–Ω–∏—Ç—å —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ <em>—Å–∞–º</em> IP-–∞–¥—Ä–µ—Å; –º—ã –ø–æ–∫–∞ –º–æ–∂–µ–º –∑–Ω–∞—Ç—å –ª–∏—à—å –µ–≥–æ —Ç–∏–ø. –£—á–∏—Ç—ã–≤–∞—è, —á—Ç–æ –Ω–µ–¥–∞–≤–Ω–æ (–≤ –ì–ª–∞–≤–µ 5) –≤—ã —É–∑–Ω–∞–ª–∏ –æ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞—Ö, —É –≤–∞—Å –º–æ–∂–µ—Ç –≤–æ–∑–Ω–∏–∫–Ω—É—Ç—å —Å–æ–±–ª–∞–∑–Ω —Ä–µ—à–∏—Ç—å —ç—Ç—É –ø—Ä–æ–±–ª–µ–º—É —Å –ø–æ–º–æ—â—å—é —Å—Ç—Ä—É–∫—Ç—É—Ä, –∫–∞–∫ –ø–æ–∫–∞–∑–∞–Ω–æ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 6-1.</p>
<Listing number="6-1" caption="Storing the data and `IpAddrKind` variant of an IP address using a `struct`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    enum IpAddrKind {
        V4,
        V6,
    }

    struct IpAddr {
        kind: IpAddrKind,
        address: String,
    }

    let home = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from("127.0.0.1"),
    };

    let loopback = IpAddr {
        kind: IpAddrKind::V6,
        address: String::from("::1"),
    };
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>–ó–¥–µ—Å—å –º—ã –æ–ø—Ä–µ–¥–µ–ª–∏–ª–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—É <code>IpAddr</code>, —É –∫–æ—Ç–æ—Ä–æ–π –µ—Å—Ç—å –¥–≤–∞ –ø–æ–ª—è: <code>kind</code> —Ç–∏–ø–∞ <code>IpAddrKind</code> (–ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –º—ã –æ–ø—Ä–µ–¥–µ–ª–∏–ª–∏ —Ä–∞–Ω–µ–µ) –∏ <code>address</code> —Ç–∏–ø–∞ <code>String</code>. –£ –Ω–∞—Å –µ—Å—Ç—å –¥–≤–∞ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ —ç—Ç–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã. –ü–µ—Ä–≤—ã–π ‚Äî <code>home</code>, –∫–æ—Ç–æ—Ä—ã–π –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç –∞–¥—Ä–µ—Å —Ç–∏–ø–∞ <code>IpAddrKind::V4</code> (–≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–∏ —Å–æ —Å–≤–æ–∏–º –∑–Ω–∞—á–µ–Ω–∏–µ–º <code>kind</code>) —Å —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–º –∞–¥—Ä–µ—Å–æ–º <code>127.0.0.1</code>. –í—Ç–æ—Ä–æ–π —ç–∫–∑–µ–º–ø–ª—è—Ä ‚Äî <code>loopback</code>. –ï–≥–æ <code>kind</code> –∏–º–µ–µ—Ç –¥—Ä—É–≥–æ–π –≤–∞—Ä–∏–∞–Ω—Ç <code>IpAddrKind</code> ‚Äî <code>V6</code>, –∏ —Å –Ω–∏–º –∞—Å—Å–æ—Ü–∏–∏—Ä–æ–≤–∞–Ω –∞–¥—Ä–µ—Å <code>::1</code>. –ú—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—É –¥–ª—è –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è –∑–Ω–∞—á–µ–Ω–∏–π <code>kind</code> –∏ <code>address</code> –≤–º–µ—Å—Ç–µ; —Ç–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, —Ç–∏–ø –∞–¥—Ä–µ—Å–∞ —Ç–µ–ø–µ—Ä—å –∞—Å—Å–æ—Ü–∏–∏—Ä–æ–≤–∞–Ω —Å –Ω–µ–ø–æ—Å—Ä–µ–¥—Å—Ç–≤–µ–Ω–Ω–æ —Å–∞–º–∏–º –∞–¥—Ä–µ—Å–æ–º.</p>
<p>–û–¥–Ω–∞–∫–æ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ —Ç–∞–∫–æ–≥–æ –∂–µ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è —Å–æ—Ä—Ç–∞ —Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º –º–æ–∂–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –ª–∞–∫–æ–Ω–∏—á–Ω–µ–µ —Å –ø–æ–º–æ—â—å—é –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è: –≤–º–µ—Å—Ç–æ —Ç–æ–≥–æ, —á—Ç–æ–±—ã –ø–æ–º–µ—â–∞—Ç—å –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ –≤ —Å—Ç—Ä—É–∫—Ç—É—Ä—É, –º—ã –º–æ–∂–µ–º –ø–æ–º–µ—Å—Ç–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –Ω–µ–ø–æ—Å—Ä–µ–¥—Å—Ç–≤–µ–Ω–Ω–æ –≤ –ª—é–±–æ–π –∏–∑ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è. –ù–∞—à–µ –Ω–æ–≤–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è <code>IpAddr</code> –≥–ª–∞—Å–∏—Ç, —á—Ç–æ –æ–±–∞ –≤–∞—Ä–∏–∞–Ω—Ç–∞ <code>V4</code> –∏ <code>V6</code> –±—É–¥—É—Ç –∏–º–µ—Ç—å —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è <code>String</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(String),
        V6(String),
    }

    let home = IpAddr::V4(String::from("127.0.0.1"));

    let loopback = IpAddr::V6(String::from("::1"));
<span class="boring">}</span></code></pre></pre>
<p>–ú—ã –ø—Ä–∏–∫—Ä–µ–ø–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –∫ –∫–∞–∂–¥–æ–º—É –≤–∞—Ä–∏–∞–Ω—Ç—É –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –Ω–∞–ø—Ä—è–º—É—é, –ø–æ—ç—Ç–æ–º—É –Ω–µ—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –≤ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä–µ. –ó–¥–µ—Å—å —Ç–∞–∫–∂–µ –ª–µ–≥—á–µ —É–≤–∏–¥–µ—Ç—å –µ—â—ë –æ–¥–Ω—É –¥–µ—Ç–∞–ª—å —Ç–æ–≥–æ, –∫–∞–∫ —Ä–∞–±–æ—Ç–∞—é—Ç –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è: –∏–º—è –∫–∞–∂–¥–æ–≥–æ –≤–∞—Ä–∏–∞–Ω—Ç–∞ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è, –∫–æ—Ç–æ—Ä—ã–π –º—ã –æ–ø—Ä–µ–¥–µ–ª—è–µ–º, —Ç–∞–∫–∂–µ —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è —Ñ—É–Ω–∫—Ü–∏–µ–π, –∫–æ—Ç–æ—Ä–∞—è —Å–æ–∑–¥–∞—ë—Ç —ç–∫–∑–µ–º–ø–ª—è—Ä –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è. –¢–æ –µ—Å—Ç—å, <code>IpAddr::V4()</code> ‚Äî —ç—Ç–æ –≤—ã–∑–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏, –∫–æ—Ç–æ—Ä—ã–π –ø—Ä–∏–Ω–∏–º–∞–µ—Ç <code>String</code> –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —ç–∫–∑–µ–º–ø–ª—è—Ä —Ç–∏–ø–∞ <code>IpAddr</code>. –≠—Ç—É —Ñ—É–Ω–∫—Ü–∏—é-–∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –º—ã –ø–æ–ª—É—á–∞–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏, –∫–æ–≥–¥–∞ –æ–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ.</p>
<p>–ï—â—ë –æ–¥–Ω–æ –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –≤–º–µ—Å—Ç–æ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –∑–∞–∫–ª—é—á–∞–µ—Ç—Å—è –≤ —Ç–æ–º, —á—Ç–æ –∫–∞–∂–¥—ã–π –≤–∞—Ä–∏–∞–Ω—Ç –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –º–æ–∂–µ—Ç –∏–º–µ—Ç—å —Ä–∞–∑–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–≤—è–∑–∞–Ω–Ω—ã—Ö —Å –Ω–∏–º –¥–∞–Ω–Ω—ã—Ö, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã—Ö –≤ —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–∞—Ö. IP-–∞–¥—Ä–µ—Å–∞ 4–æ–π –≤–µ—Ä—Å–∏–∏ –≤—Å–µ–≥–¥–∞ –±—É–¥–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å —á–µ—Ç—ã—Ä–µ —Ü–∏—Ñ—Ä–æ–≤—ã—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞, –∫–æ—Ç–æ—Ä—ã–µ –±—É–¥—É—Ç –∏–º–µ—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è –º–µ–∂–¥—É 0 –∏ 255. –°—Ç—Ä—É–∫—Ç—É—Ä—ã –Ω–µ —Å–º–æ–≥–ª–∏ –±—ã –Ω–∞–º –ø–æ–º–æ—á—å, –µ—Å–ª–∏ –±—ã –º—ã —Ö–æ—Ç–µ–ª–∏ —Ö—Ä–∞–Ω–∏—Ç—å –∞–¥—Ä–µ—Å–∞ —Ç–∏–ø–∞ <code>V4</code> –∫–∞–∫ —á–µ—Ç—ã—Ä–µ –∑–Ω–∞—á–µ–Ω–∏—è —Ç–∏–ø–∞ <code>u8</code>, –∞ –∞–¥—Ä–µ—Å–∞ —Ç–∏–ø–∞ <code>V6</code> ‚Äî –∫–∞–∫ –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Ç–∏–ø–∞ <code>String</code>. –ü–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –∂–µ –ª–µ–≥–∫–æ —Ä–µ—à–∞—é—Ç —ç—Ç—É –∑–∞–¥–∞—á—É:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from("::1"));
<span class="boring">}</span></code></pre></pre>
<p>–ú—ã –ø–æ–∫–∞–∑–∞–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Å–ø–æ—Å–æ–±–æ–≤ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è IP-–∞–¥—Ä–µ—Å–æ–≤ —á–µ—Ç–≤—ë—Ä—Ç–æ–π –∏ —à–µ—Å—Ç–æ–π –≤–µ—Ä—Å–∏–π. –û–¥–Ω–∞–∫–æ, –∫–∞–∫ –æ–∫–∞–∑–∞–ª–æ—Å—å, –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç—å —Ö—Ä–∞–Ω–∏—Ç—å IP-–∞–¥—Ä–µ—Å–∞ –∏ —É–∫–∞–∑—ã–≤–∞—Ç—å –∏—Ö —Ç–∏–ø –Ω–∞—Å—Ç–æ–ª—å–∫–æ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–∞, —á—Ç–æ <a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">–≤ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–µ —É–∂–µ –µ—Å—Ç—å –≥–æ—Ç–æ–≤–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ!</a><!-- ignore --> –í –Ω—ë–º –µ—Å—Ç—å —Ç–æ—á–Ω–æ —Ç–∞–∫–æ–µ –∂–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ —Å –≤–∞—Ä–∏–∞–Ω—Ç–∞–º–∏, –∫–æ—Ç–æ—Ä–æ–µ –æ–ø—Ä–µ–¥–µ–ª–∏–ª–∏ –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ –º—ã, –Ω–æ –æ–Ω–∞ –ø–æ–º–µ—â–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –æ–± –∞–¥—Ä–µ—Å–µ –≤–Ω—É—Ç—Ä—å —ç—Ç–∏—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –≤ –≤–∏–¥–µ –¥–≤—É—Ö —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä, –∫–æ—Ç–æ—Ä—ã–µ –∏–º–µ—é—Ç —Ä–∞–∑–ª–∏—á–Ω—ã–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∏–∑ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ipv4Addr {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
}

struct Ipv6Addr {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
<span class="boring">}</span></code></pre></pre>
<p>–ù–∞ —ç—Ç–æ–º –ø—Ä–∏–º–µ—Ä–µ –≤–∏–¥–Ω–æ, —á—Ç–æ –º—ã –º–æ–∂–µ–º –¥–æ–±–∞–≤–ª—è—Ç—å –ª—é–±—ã–µ —Ç–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö –≤ –≤–∞—Ä–∏–∞–Ω—Ç—ã –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è: —Å—Ç—Ä–æ–∫—É, —á–∏—Å–ª–æ, —Å—Ç—Ä—É–∫—Ç—É—Ä—É –∏ —Ç–∞–∫ –¥–∞–ª–µ–µ. –í—ã –º–æ–∂–µ—Ç–µ –≤–∫–ª—é—á–∞—Ç—å –≤ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ –¥–∞–∂–µ –¥—Ä—É–≥–∏–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è! –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ —Ç–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö —á–∞—Å—Ç–æ –Ω–µ —Ç–∞–∫ —Å–ª–æ–∂–Ω—ã, –∫–∞–∫ —Ç–æ, —á—Ç–æ –∏–∑ –Ω–∏—Ö –º–æ–∂–Ω–æ —Å–æ—Å—Ç–∞–≤–∏—Ç—å.</p>
<p>–û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ —Ö–æ—Ç—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è <code>IpAddr</code> –µ—Å—Ç—å –≤ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–µ, –º—ã —Å–º–æ–≥–ª–∏ –æ–±—ä—è–≤–ª—è—Ç—å –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å–≤–æ—é —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—É—é —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é —Å –∞–Ω–∞–ª–æ–≥–∏—á–Ω—ã–º –Ω–∞–∑–≤–∞–Ω–∏–µ–º –±–µ–∑ –∫–∞–∫–∏—Ö-–ª–∏–±–æ –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤, –ø–æ—Ç–æ–º—É —á—Ç–æ –º—ã –Ω–µ –¥–æ–±–∞–≤–∏–ª–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∏–∑ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –≤ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ –Ω–∞—à–µ–π –ø—Ä–æ–≥—Ä–∞–º–º—ã. –ü–æ–¥—Ä–æ–±–Ω–µ–µ –æ–± —ç—Ç–æ–º –ø–æ–≥–æ–≤–æ—Ä–∏–º –≤ –ì–ª–∞–≤–µ 7.</p>
<p>–†–∞—Å—Å–º–æ—Ç—Ä–∏–º (–≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 6-2) –¥—Ä—É–≥–æ–π –ø—Ä–∏–º–µ—Ä –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è: –≤ —ç—Ç–æ–º –ø—Ä–∏–º–µ—Ä–µ –∫–∞–∂–¥—ã–π –≤–∞—Ä–∏–∞–Ω—Ç –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –∏–º–µ–µ—Ç –≤–Ω—É—Ç—Ä–∏ —Å–≤–æ–π –æ—Å–æ–±—ã–π —Ç–∏–ø –¥–∞–Ω–Ω—ã—Ö.</p>
<Listing number="6-2" caption="A `Message` enum whose variants each store different amounts and types of values">
<pre><pre class="playground"><code class="language-rust edition2021">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p>–≠—Ç–æ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ –∏–º–µ–µ—Ç 4 –≤–∞—Ä–∏–∞–Ω—Ç–∞:</p>
<ul>
<li><code>Quit</code> ‚Äî –≤–∞—Ä–∏–∞–Ω—Ç –±–µ–∑ –∫–∞–∫–∏—Ö-–ª–∏–±–æ —Å–≤—è–∑–∞–Ω–Ω—ã—Ö —Å –Ω–∏–º –∑–Ω–∞—á–µ–Ω–∏–π.</li>
<li><code>Move</code> ‚Äî –≤–∞—Ä–∏–∞–Ω—Ç —Å –∏–º–µ–Ω–æ–≤–∞–Ω–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏, –∫–∞–∫ —É —Å—Ç—Ä—É–∫—Ç—É—Ä—ã.</li>
<li><code>Write</code> ‚Äî –≤–∞—Ä–∏–∞–Ω—Ç, –∏–º–µ—é—â–∏–π –ª–∏—à—å <code>String</code>.</li>
<li><code>ChangeColor</code> ‚Äî –≤–∞—Ä–∏–∞–Ω—Ç, –∏–º–µ—é—â–∏–π —Ç—Ä–∏ —á–∏—Å–ª–∞ <code>i32</code>.</li>
</ul>
<p>–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è —Å –≤–∞—Ä–∏–∞–Ω—Ç–∞–º–∏ (—Ç–∞–∫–∏–º–∏, –∫–∞–∫ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 6-2) –ø–æ—Ö–æ–∂–µ –Ω–∞ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏–π —Ä–∞–∑–Ω—ã—Ö –≤–æ–∑–º–æ–∂–Ω—ã—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä, –∑–∞ –∏—Å–∫–ª—é—á–µ–Ω–∏–µ–º —Ç–æ–≥–æ, —á—Ç–æ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ <code>struct</code> –∏ –≤—Å–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã —Å–≥—Ä—É–ø–ø–∏—Ä–æ–≤–∞–Ω—ã –≤–Ω—É—Ç—Ä–∏ —Ç–∏–ø–∞ <code>Message</code>. –°–ª–µ–¥—É—é—â–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –º–æ–≥—É—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ç–µ –∂–µ –¥–∞–Ω–Ω—ã–µ, —á—Ç–æ –∏ –ø—Ä–µ–¥—ã–¥—É—â–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π:</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct QuitMessage; // unit-–ø–æ–¥–æ–±–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // –∫–æ—Ä—Ç–µ–∂–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞
struct ChangeColorMessage(i32, i32, i32); // –∫–æ—Ä—Ç–µ–∂–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>–ù–æ –µ—Å–ª–∏ –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ä–∞–∑–ª–∏—á–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, –∫–∞–∂–¥–∞—è –∏–∑ –∫–æ—Ç–æ—Ä—ã—Ö –∏–º–µ–µ—Ç —Å–≤–æ–∏ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ —Ç–∏–ø—ã, –º—ã –Ω–µ –º–æ–∂–µ–º –ª–µ–≥–∫–æ –æ–ø—Ä–µ–¥–µ–ª—è—Ç—å —Ñ—É–Ω–∫—Ü–∏–∏, –∫–æ—Ç–æ—Ä—ã–µ –ø—Ä–∏–Ω–∏–º–∞—é—Ç –ª—é–±—ã–µ —Ç–∏–ø—ã —Å–æ–æ–±—â–µ–Ω–∏–π, –∫–∞–∫ —ç—Ç–æ –º–æ–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å —Å –ø–æ–º–æ—â—å—é –µ–¥–∏–Ω–æ–≥–æ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è —Ç–∏–ø–∞ <code>Message</code>, –æ–±—ä—è–≤–ª–µ–Ω–Ω–æ–≥–æ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 6-2.</p>
<p>–ï—Å—Ç—å –µ—â—ë –æ–¥–Ω–æ —Å—Ö–æ–¥—Å—Ç–≤–æ –º–µ–∂–¥—É –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è–º–∏ –∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞–º–∏: —Ç–∞–∫ –∂–µ, –∫–∞–∫ –º—ã –º–æ–∂–µ–º –æ–ø—Ä–µ–¥–µ–ª—è—Ç—å –º–µ—Ç–æ–¥—ã —Å—Ç—Ä—É–∫—Ç—É—Ä —Å –ø–æ–º–æ—â—å—é –±–ª–æ–∫–∞ <code>impl</code>, –º—ã –º–æ–∂–µ–º –æ–ø—Ä–µ–¥–µ–ª—è—Ç—å –º–µ—Ç–æ–¥—ã –∏ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è. –í–æ—Ç –ø—Ä–∏–º–µ—Ä –º–µ—Ç–æ–¥–∞ —Å –∏–º–µ–Ω–µ–º <code>call</code>, –∫–æ—Ç–æ—Ä—ã–π –º—ã –º–æ–≥–ª–∏ –±—ã –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –Ω–∞ –Ω–∞—à–µ–º –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–∏ <code>Message</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    enum Message {
</span><span class="boring">        Quit,
</span><span class="boring">        Move { x: i32, y: i32 },
</span><span class="boring">        Write(String),
</span><span class="boring">        ChangeColor(i32, i32, i32),
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Message {
        fn call(&amp;self) {
            // –∑–¥–µ—Å—å ‚Äî —Ç–µ–ª–æ –º–µ—Ç–æ–¥–∞
        }
    }

    let m = Message::Write(String::from("hello"));
    m.call();
<span class="boring">}</span></code></pre></pre>
<p>–í —Ç–µ–ª–µ –º–µ—Ç–æ–¥–∞ –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è <code>self</code> –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è, –Ω–∞ –∫–æ—Ç–æ—Ä–æ–º –º—ã –≤—ã–∑–≤–∞–ª–∏ —ç—Ç–æ—Ç –º–µ—Ç–æ–¥. –í —ç—Ç–æ–º –ø—Ä–∏–º–µ—Ä–µ –º—ã —Å–æ–∑–¥–∞–ª–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é <code>m</code>, —Å–æ–¥–µ—Ä–∂–∞—â—É—é –∑–Ω–∞—á–µ–Ω–∏–µ <code>Message::Write(String::from("hello"))</code>, –∏ –∏–º–µ–Ω–Ω–æ —ç—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ –±—É–¥–µ—Ç –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—Ç—å <code>self</code> –≤ —Ç–µ–ª–µ –º–µ—Ç–æ–¥–∞ <code>call</code> –ø—Ä–∏ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–∏ —Å—Ç—Ä–æ—á–∫–∏ <code>m.call()</code>.</p>
<p>–¢–µ–ø–µ—Ä—å –ø–æ—Å–º–æ—Ç—Ä–∏–º –Ω–∞ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ –∏–∑ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏, –∫–æ—Ç–æ—Ä–æ–µ —è–≤–ª—è–µ—Ç—Å—è –æ—á–µ–Ω—å —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—ë–Ω–Ω—ã–º –∏ –ø–æ–ª–µ–∑–Ω—ã–º: <code>Option</code>.</p>
<h3 id="–ü–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ-option-–∏-–µ–≥–æ-–ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞-–ø–µ—Ä–µ–¥-–∑–Ω–∞—á–µ–Ω–∏—è–º–∏-null"><a class="header" href="#–ü–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ-option-–∏-–µ–≥–æ-–ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞-–ø–µ—Ä–µ–¥-–∑–Ω–∞—á–µ–Ω–∏—è–º–∏-null">–ü–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ <code>Option</code> –∏ –µ–≥–æ –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ –ø–µ—Ä–µ–¥ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏ Null</a></h3>
<p>–í —ç—Ç–æ–º —Ä–∞–∑–¥–µ–ª–µ —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞–µ—Ç—Å—è –ø—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è <code>Option</code> ‚Äî –µ—â—ë –æ–¥–Ω–æ–≥–æ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è, –∫–æ—Ç–æ—Ä–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ –≤ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–µ. –¢–∏–ø <code>Option</code> —Ä–µ–∞–ª–∏–∑—É–µ—Ç –æ—á–µ–Ω—å —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—ë–Ω–Ω—ã–π —Å–ª—É—á–∞–π, –≤ –∫–æ—Ç–æ—Ä–æ–º –∑–Ω–∞—á–µ–Ω–∏–µ –º–æ–∂–µ—Ç –±—ã—Ç—å —á–µ–º-—Ç–æ, –∞ –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–∏—á–µ–º.</p>
<p>–ù–∞–ø—Ä–∏–º–µ—Ä, –µ—Å–ª–∏ –≤—ã –∑–∞–ø—Ä–æ—Å–∏—Ç–µ –ø–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç –∏–∑ –Ω–µ–ø—É—Å—Ç–æ–≥–æ —Å–ø–∏—Å–∫–∞, –≤—ã –ø–æ–ª—É—á–∏—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ. –ï—Å–ª–∏ –≤—ã –∑–∞–ø—Ä–æ—Å–∏—Ç–µ –ø–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç –ø—É—Å—Ç–æ–≥–æ —Å–ø–∏—Å–∫–∞, –≤—ã –ø–æ–ª—É—á–∏—Ç–µ –Ω–∏—á–µ–≥–æ. –í—ã—Ä–∞–∂–µ–Ω–∏–µ —ç—Ç–æ–π –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏ –≤ —Ç–µ—Ä–º–∏–Ω–∞—Ö —Å–∏—Å—Ç–µ–º—ã —Ç–∏–ø–æ–≤ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –º–æ–∂–µ—Ç –ø—Ä–æ–≤–µ—Ä–∏—Ç—å, –æ–±—Ä–∞–±–æ—Ç–∞–ª–∏ –ª–∏ –≤—ã –≤—Å–µ —Å–ª—É—á–∞–∏, –∫–æ—Ç–æ—Ä—ã–µ –¥–æ–ª–∂–Ω—ã –±—ã–ª–∏ –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å; —ç—Ç–∞ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å –º–æ–∂–µ—Ç –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—Ç–∏—Ç—å –æ—à–∏–±–∫–∏, –∫–æ—Ç–æ—Ä—ã–µ —á—Ä–µ–∑–≤—ã—á–∞–π–Ω–æ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω—ã –≤ –¥—Ä—É–≥–∏—Ö —è–∑—ã–∫–∞—Ö –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è.</p>
<p>–î–∏–∑–∞–π–Ω —è–∑—ã–∫–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è —á–∞—Å—Ç–æ —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞–µ—Ç—Å—è —Å —Ç–æ—á–∫–∏ –∑—Ä–µ–Ω–∏—è —Ç–æ–≥–æ, –∫–∞–∫–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ –≤—ã –≤–∫–ª—é—á–∞–µ—Ç–µ –≤ –Ω–µ–≥–æ, –Ω–æ —Ç–∞–∫–∂–µ –≤–∞–∂–Ω–æ —Ç–æ, –∫–∞–∫–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ –≤—ã –≤ –Ω–µ–≥–æ –Ω–µ –≤–∫–ª—é—á–∞–µ—Ç–µ. –ù–∞–ø—Ä–∏–º–µ—Ä, –≤ Rust –Ω–µ—Ç –ø–æ–Ω—è—Ç–∏—è "null", –æ–¥–Ω–∞–∫–æ –æ–Ω–æ –µ—Å—Ç—å –≤–æ –º–Ω–æ–≥–∏—Ö –¥—Ä—É–≥–∏—Ö —è–∑—ã–∫–∞—Ö. <em>Null</em> ‚Äî —ç—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –∑–Ω–∞—á–µ–Ω–∏—è –Ω–µ—Ç. –í —è–∑—ã–∫–∞—Ö —Å null –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –≤—Å–µ–≥–¥–∞ –º–æ–≥—É—Ç –Ω–∞—Ö–æ–¥–∏—Ç—å—Å—è –≤ –æ–¥–Ω–æ–º –∏–∑ –¥–≤—É—Ö —Å–æ—Å—Ç–æ—è–Ω–∏–π: null –∏–ª–∏ –Ω–µ-null.</p>
<p>–í —Å–≤–æ–µ–π –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏ 2009 –≥–æ–¥–∞ "Null References: The Billion Dollar Mistake" –¢–æ–Ω–∏ –•–æ–∞—Ä, –∞–≤—Ç–æ—Ä –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏ null, —Å–∫–∞–∑–∞–ª —Å–ª–µ–¥—É—é—â–µ–µ:</p>
<blockquote>
<p>–Ø –Ω–∞–∑—ã–≤–∞—é —ç—Ç–æ —Å–≤–æ–µ–π –æ—à–∏–±–∫–æ–π –Ω–∞ –º–∏–ª–ª–∏–∞—Ä–¥ –¥–æ–ª–ª–∞—Ä–æ–≤. –í —Ç–æ –≤—Ä–µ–º—è —è —Ä–∞–∑—Ä–∞–±–∞—Ç—ã–≤–∞–ª –ø–µ—Ä–≤—É—é –∫–æ–º–ø–ª–µ–∫—Å–Ω—É—é —Å–∏—Å—Ç–µ–º—É —Ç–∏–ø–æ–≤ –¥–ª—è —Å—Å—ã–ª–æ–∫ –≤ –æ–±—ä–µ–∫—Ç–Ω–æ-–æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–º —è–∑—ã–∫–µ. –ú–æ—è —Ü–µ–ª—å —Å–æ—Å—Ç–æ—è–ª–∞ –≤ —Ç–æ–º, —á—Ç–æ–±—ã –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å, —á—Ç–æ –ª—é–±–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Å—Å—ã–ª–æ–∫ –±—É–¥–µ—Ç –∞–±—Å–æ–ª—é—Ç–Ω–æ –±–µ–∑–æ–ø–∞—Å–Ω—ã–º, —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –ø—Ä–æ–≤–µ—Ä–∫–æ–π –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–æ–º. –ù–æ —è –Ω–µ —Å–º–æ–≥ —É—Å—Ç–æ—è—Ç—å –ø–µ—Ä–µ–¥ —Å–æ–±–ª–∞–∑–Ω–æ–º –≤–Ω–µ–¥—Ä–∏—Ç—å –≤ —è–∑—ã–∫ –ø—É—Å—Ç—É—é —Å—Å—ã–ª–∫—É ‚Äî –ø—Ä–æ—Å—Ç–æ –ø–æ—Ç–æ–º—É, —á—Ç–æ —ç—Ç–æ –±—ã–ª–æ —Ç–∞–∫ –ª–µ–≥–∫–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å. –≠—Ç–æ –ø—Ä–∏–≤–µ–ª–æ –∫ –±–µ—Å—á–∏—Å–ª–µ–Ω–Ω—ã–º –æ—à–∏–±–∫–∞–º, —É—è–∑–≤–∏–º–æ—Å—Ç—è–º –∏ —Å–∏—Å—Ç–µ–º–Ω—ã–º —Å–±–æ—è–º, –∫–æ—Ç–æ—Ä—ã–µ, –≤–µ—Ä–æ—è—Ç–Ω–æ, –ø—Ä–∏—á–∏–Ω–∏–ª–∏ –±–æ–ª—å –∏ —É—â–µ—Ä–± –Ω–∞ –º–∏–ª–ª–∏–∞—Ä–¥ –¥–æ–ª–ª–∞—Ä–æ–≤ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Å–æ—Ä–æ–∫ –ª–µ—Ç.</p>
</blockquote>
<p>–ü—Ä–æ–±–ª–µ–º–∞ —Å null –∑–∞–∫–ª—é—á–∞–µ—Ç—Å—è –≤ —Ç–æ–º, —á—Ç–æ –µ—Å–ª–∏ –≤—ã –ø–æ–ø—ã—Ç–∞–µ—Ç–µ—Å—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å null –≤ –∫–∞—á–µ—Å—Ç–≤–µ –Ω–µ-null –∑–Ω–∞—á–µ–Ω–∏—è, –≤—ã –ø–æ–ª—É—á–∏—Ç–µ –æ—à–∏–±–∫—É –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–≥–æ —Ä–æ–¥–∞. –ü–æ—Å–∫–æ–ª—å–∫—É —ç—Ç–∞ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å (–±—ã—Ç—å null –∏–ª–∏ –Ω–µ-null) —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–∞ –ø–æ–≤—Å–µ–º–µ—Å—Ç–Ω–æ, —Å–¥–µ–ª–∞—Ç—å —Ç–∞–∫—É—é –æ—à–∏–±–∫—É –æ—á–µ–Ω—å –ø—Ä–æ—Å—Ç–æ.</p>
<p>–¢–µ–º –Ω–µ –º–µ–Ω–µ–µ, –∫–æ–Ω—Ü–µ–ø—Ü–∏—è, –∫–æ—Ç–æ—Ä—É—é null –ø—ã—Ç–∞–µ—Ç—Å—è –≤—ã—Ä–∞–∑–∏—Ç—å, —è–≤–ª—è–µ—Ç—Å—è –ø–æ–ª–µ–∑–Ω–æ–π: null ‚Äî —ç—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –≤ –Ω–∞—Å—Ç–æ—è—â–µ–µ –≤—Ä–µ–º—è –ø–æ –∫–∞–∫–æ–π-—Ç–æ –ø—Ä–∏—á–∏–Ω–µ –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –∏–ª–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç.</p>
<p>–ü—Ä–æ–±–ª–µ–º–∞ –Ω–∞ —Å–∞–º–æ–º –¥–µ–ª–µ –Ω–µ –≤ –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏, –∞ –≤ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏. –í Rust –Ω–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–π null, –Ω–æ –µ—Å—Ç—å –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –º–æ–∂–µ—Ç –≤—ã—Ä–∞–∑–∏—Ç—å –∫–æ–Ω—Ü–µ–ø—Ü–∏—é –ø—Ä–∏—Å—É—Ç—Å—Ç–≤–∏—è –∏–ª–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è –∑–Ω–∞—á–µ–Ω–∏—è. –≠—Ç–æ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ <code>Option&lt;T&gt;</code>, –∏ –æ–Ω–æ <a href="https://doc.rust-lang.org/std/option/enum.Option.html">–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–æ–π</a><!-- ignore --> —Å–ª–µ–¥—É—é—â–∏–º –æ–±—Ä–∞–∑–æ–º:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    None,
    Some(T),
}
<span class="boring">}</span></code></pre></pre>
<p>–ü–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ <code>Option&lt;T&gt;</code> –Ω–∞—Å—Ç–æ–ª—å–∫–æ –ø–æ–ª–µ–∑–Ω–æ, —á—Ç–æ –æ–Ω–æ –¥–∞–∂–µ –≤–∫–ª—é—á–µ–Ω–æ –≤ prelude; –≤–∞–º –Ω–µ –Ω—É–∂–Ω–æ —Å–∞–º–æ–º—É –≤–≤–æ–¥–∏—Ç—å –µ–≥–æ –≤ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏. –ï–≥–æ –≤–∞—Ä–∏–∞–Ω—Ç—ã —Ç–∞–∫–∂–µ –≤–∫–ª—é—á–µ–Ω—ã –≤ prelude: –≤—ã –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å <code>Some</code> –∏ <code>None</code> –Ω–∞–ø—Ä—è–º—É—é, –±–µ–∑ –ø—Ä–µ—Ñ–∏–∫—Å–∞ <code>Option::</code>. –ü—Ä–∏ –≤—Å—ë–º –ø—Ä–∏ —ç—Ç–æ–º, <code>Option&lt;T&gt;</code> —è–≤–ª—è–µ—Ç—Å—è —Å–∞–º—ã–º –æ–±—ã—á–Ω—ã–º –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ–º, –∞ <code>Some(T)</code> –∏ <code>None</code> —è–≤–ª—è—é—Ç—Å—è –≤—Å–µ–≥–æ –ª–∏—à—å –≤–∞—Ä–∏–∞–Ω—Ç–∞–º–∏ —Ç–∏–ø–∞ <code>Option&lt;T&gt;</code>.</p>
<p>–ó–∞–ø–∏—Å—å <code>&lt;T&gt;</code> ‚Äî —ç—Ç–æ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç—å Rust, –æ –∫–æ—Ç–æ—Ä–æ–π –º—ã –µ—â—ë –Ω–µ –≥–æ–≤–æ—Ä–∏–ª–∏. –≠—Ç–æ –ø–∞—Ä–∞–º–µ—Ç—Ä –æ–±–æ–±—â—ë–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞, –∏ –º—ã —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º –µ–≥–æ –±–æ–ª–µ–µ –ø–æ–¥—Ä–æ–±–Ω–æ –≤ –ì–ª–∞–≤–µ 10. –ù–∞ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –≤—Å—ë, —á—Ç–æ –≤–∞–º –Ω—É–∂–Ω–æ –∑–Ω–∞—Ç—å, —ç—Ç–æ —Ç–æ, —á—Ç–æ <code>&lt;T&gt;</code> –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –≤–∞—Ä–∏–∞–Ω—Ç <code>Some</code> –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è <code>Option</code> –º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å –æ–¥–∏–Ω —Ñ—Ä–∞–≥–º–µ–Ω—Ç –¥–∞–Ω–Ω—ã—Ö –ª—é–±–æ–≥–æ —Ç–∏–ø–∞, –∏ —á—Ç–æ –∫–∞–∂–¥—ã–π –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —Ç–∏–ø, –∫–æ—Ç–æ—Ä—ã–π –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤–º–µ—Å—Ç–æ <code>T</code>, –¥–µ–ª–∞–µ—Ç –æ–±–æ–±—â—ë–Ω–Ω—ã–π <code>Option&lt;T&gt;</code> –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã–º —Ç–∏–ø–æ–º. –í–æ—Ç –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø—Ä–∏–º–µ—Ä–æ–≤ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è <code>Option</code> –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —á–∏—Å–ª–æ–≤–æ–≥–æ –∏ —Å–∏–º–≤–æ–ª—å–Ω–æ–≥–æ —Ç–∏–ø–æ–≤:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let some_number = Some(5);
    let some_char = Some('e');

    let absent_number: Option&lt;i32&gt; = None;
<span class="boring">}</span></code></pre></pre>
<p>–¢–∏–ø <code>some_number</code> ‚Äî <code>Option&lt;i32&gt;</code>. –¢–∏–ø <code>some_char</code> ‚Äî <code>Option&lt;char&gt;</code>, –∏ —ç—Ç–æ –¥—Ä—É–≥–æ–π —Ç–∏–ø. Rust –º–æ–∂–µ—Ç —Å–∞–º –≤—ã–≤–µ—Å—Ç–∏ —ç—Ç–∏ —Ç–∏–ø—ã, –ø–æ—Ç–æ–º—É —á—Ç–æ –º—ã —É–∫–∞–∑–∞–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ –≤–Ω—É—Ç—Ä–∏ –≤–∞—Ä–∏–∞–Ω—Ç–∞ <code>Some</code>. –î–ª—è <code>absent_number</code> Rust —Ç—Ä–µ–±—É–µ—Ç, —á—Ç–æ–±—ã –º—ã –≤—Å—ë –∂–µ –∞–Ω–Ω–æ—Ç–∏—Ä–æ–≤–∞–ª–∏ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —Ç–∏–ø –¥–ª—è <code>Option</code>: –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –Ω–µ –º–æ–∂–µ—Ç –≤—ã–≤–µ—Å—Ç–∏ —Ç–∏–ø, –∫–æ—Ç–æ—Ä—ã–π –±—É–¥–µ—Ç –≤ <code>Some</code>, –≥–ª—è–¥—è —Ç–æ–ª—å–∫–æ –Ω–∞ –∑–Ω–∞—á–µ–Ω–∏–µ <code>None</code>. –ó–¥–µ—Å—å –º—ã —Å–æ–æ–±—â–∞–µ–º Rust, —á—Ç–æ <code>absent_number</code> –¥–æ–ª–∂–µ–Ω –∏–º–µ—Ç—å —Ç–∏–ø <code>Option&lt;i32&gt;</code>.</p>
<p>–ö–æ–≥–¥–∞ –º—ã –∏–º–µ–µ–º <code>Some</code>, –º—ã –∑–Ω–∞–µ–º, —á—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∏ —Å–æ–¥–µ—Ä–∂–∏—Ç—Å—è –≤–Ω—É—Ç—Ä–∏ <code>Some</code>. –ö–æ–≥–¥–∞ –º—ã –∏–º–µ–µ–º <code>None</code>, —ç—Ç–æ (–≤ –Ω–µ–∫–æ—Ç–æ—Ä–æ–º —Å–º—ã—Å–ª–µ) –æ–∑–Ω–∞—á–∞–µ—Ç —Ç–æ –∂–µ —Å–∞–º–æ–µ, —á—Ç–æ –∏ null: —É –Ω–∞—Å –Ω–µ—Ç –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è. –¢–∞–∫ –ø–æ—á–µ–º—É <code>Option&lt;T&gt;</code> –ª—É—á—à–µ, —á–µ–º <code>null</code>?</p>
<p>–í–∫—Ä–∞—Ç—Ü–µ, –ø–æ—Å–∫–æ–ª—å–∫—É <code>Option&lt;T&gt;</code> –∏ <code>T</code> (–≥–¥–µ <code>T</code> –º–æ–∂–µ—Ç –±—ã—Ç—å –ª—é–±—ã–º —Ç–∏–ø–æ–º) –æ—Ç–Ω–æ—Å—è—Ç—Å—è –∫ —Ä–∞–∑–Ω—ã–º —Ç–∏–ø–∞–º, –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –Ω–µ –ø–æ–∑–≤–æ–ª–∏—Ç –Ω–∞–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ <code>Option&lt;T&gt;</code> –¥–∞–∂–µ –µ—Å–ª–∏ –±—ã –æ–Ω–æ –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ –±—ã–ª–æ –¥–æ–ø—É—Å—Ç–∏–º—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º. –ù–∞–ø—Ä–∏–º–µ—Ä, —ç—Ç–æ—Ç –∫–æ–¥ –Ω–µ –±—É–¥–µ—Ç –∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞—Ç—å—Å—è, –ø–æ—Ç–æ–º—É —á—Ç–æ –æ–Ω –ø—ã—Ç–∞–µ—Ç—Å—è –¥–æ–±–∞–≤–∏—Ç—å <code>i8</code> –∫ –∑–Ω–∞—á–µ–Ω–∏—é —Ç–∏–ø–∞ <code>Option&lt;i8&gt;</code>:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let x: i8 = 5;
    let y: Option&lt;i8&gt; = Some(5);

    let sum = x + y;
<span class="boring">}</span></code></pre>
<p>–ï—Å–ª–∏ –º—ã –∑–∞–ø—É—Å—Ç–∏–º —ç—Ç–æ—Ç –∫–æ–¥, —Ç–æ –ø–æ–ª—É—á–∏–º —Ç–∞–∫–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ:</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option&lt;i8&gt;` to `i8`
 --&gt; src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option&lt;i8&gt;`
  |
  = help: the trait `Add&lt;Option&lt;i8&gt;&gt;` is not implemented for `i8`
  = help: the following other types implement trait `Add&lt;Rhs&gt;`:
            `&amp;'a i8` implements `Add&lt;i8&gt;`
            `&amp;i8` implements `Add&lt;&amp;i8&gt;`
            `i8` implements `Add&lt;&amp;i8&gt;`
            `i8` implements `Add`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums` (bin "enums") due to 1 previous error
</code></pre>
<p>–û–Ω–æ –±–æ–ª—å—à–æ–µ! –§–∞–∫—Ç–∏—á–µ—Å–∫–∏, —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ Rust –Ω–µ –ø–æ–Ω–∏–º–∞–µ—Ç, –∫–∞–∫ —Å–ª–æ–∂–∏—Ç—å <code>i8</code> –∏ <code>Option&lt;i8&gt;</code>, –ø–æ—Ç–æ–º—É —á—Ç–æ —ç—Ç–æ —Ä–∞–∑–Ω—ã–µ —Ç–∏–ø—ã. –ö–æ–≥–¥–∞ —É –Ω–∞—Å –µ—Å—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ —Ç–∏–ø–∞ –≤—Ä–æ–¥–µ <code>i8</code>, –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç, —á—Ç–æ –æ–Ω–æ –≤—Å–µ–≥–¥–∞ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ. –ú—ã –º–æ–∂–µ–º —É–≤–µ—Ä–µ–Ω–Ω–æ –ø—Ä–æ–¥–æ–ª–∂–∞—Ç—å —Ä–∞–±–æ—Ç—É, –Ω–µ –ø—Ä–æ–≤–µ—Ä—è—è –µ–≥–æ –Ω–∞ null –ø–µ—Ä–µ–¥ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º. –õ–∏—à—å –∫–æ–≥–¥–∞ –º—ã –∏–º–µ–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ —Ç–∏–ø–∞ <code>Option&lt;i8&gt;</code> (–∏–ª–∏ –ª—é–±–æ–≥–æ –¥—Ä—É–≥–æ–≥–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Ç–∏–ø–æ–≤–æ–≥–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞), —É –Ω–∞—Å –µ—Å—Ç—å –ø–æ–≤–æ–¥ –±–µ—Å–ø–æ–∫–æ–∏—Ç—å—Å—è –æ —Ç–æ–º, —á—Ç–æ –º—ã –º–æ–∂–µ–º –∏ –Ω–µ –∏–º–µ—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è; –æ–¥–Ω–∞–∫–æ, –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –æ–±–µ—Å–ø–µ—á–∏—Ç –ø—Ä–æ–≤–µ—Ä–∫—É –Ω–∞–º–∏ –æ–±–æ–∏—Ö —Å–ª—É—á–∞–µ–≤ –ø–µ—Ä–µ–¥ —Ç–µ–º, –∫–∞–∫ –¥–∞–≤–∞—Ç—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å (–≤–æ–∑–º–æ–∂–Ω–æ–µ) –∑–Ω–∞—á–µ–Ω–∏–µ.</p>
<p>–î—Ä—É–≥–∏–º–∏ —Å–ª–æ–≤–∞–º–∏, –≤—ã –¥–æ–ª–∂–Ω—ã –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å <code>Option&lt;T&gt;</code> –≤ <code>T</code>, –ø—Ä–µ–∂–¥–µ —á–µ–º –≤—ã —Å–º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª–Ω—è—Ç—å –æ–ø–µ—Ä–∞—Ü–∏–∏ —Å —ç—Ç–∏–º <code>T</code>. –ö–∞–∫ –ø—Ä–∞–≤–∏–ª–æ, —ç—Ç–æ –ø–æ–º–æ–≥–∞–µ—Ç –≤—ã—è–≤–∏—Ç—å –æ–¥–Ω—É –∏–∑ –Ω–∞–∏–±–æ–ª–µ–µ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—ë–Ω–Ω—ã—Ö –ø—Ä–æ–±–ª–µ–º —Å null: –¥–µ–π—Å—Ç–≤–∏—è —Å —á–µ–º-—Ç–æ –≤ –ø—Ä–µ–¥–ø–æ–ª–æ–∂–µ–Ω–∏–∏, —á—Ç–æ —ç—Ç–æ —á—Ç–æ-—Ç–æ –Ω–µ —Ä–∞–≤–Ω–æ null, –∫–æ–≥–¥–∞ –æ–Ω–æ –Ω–∞ —Å–∞–º–æ–º –¥–µ–ª–µ —Ä–∞–≤–Ω–æ null.</p>
<p>–£—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ —Ä–∏—Å–∫–∞ –æ—à–∏–±–æ—á–Ω–æ–≥–æ –ø—Ä–µ–¥–ø–æ–ª–æ–∂–µ–Ω–∏—è –∫–∞—Å–∞—Ç–µ–ª—å–Ω–æ –Ω–µ-null –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ–º–æ–≥–∞–µ—Ç –≤–∞–º –±—ã—Ç—å –±–æ–ª–µ–µ —É–≤–µ—Ä–µ–Ω–Ω—ã–º –≤ —Å–≤–æ—ë–º –∫–æ–¥–µ. –ß—Ç–æ–±—ã –∏–º–µ—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –º–æ–∂–µ—Ç –±—ã—Ç—å null, –≤—ã –¥–æ–ª–∂–Ω—ã —è–≤–Ω–æ –æ–ø–∏—Å–∞—Ç—å —Ç–∏–ø —ç—Ç–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è —Å –ø–æ–º–æ—â—å—é <code>Option&lt;T&gt;</code>. –ó–∞—Ç–µ–º, –∫–æ–≥–¥–∞ –≤—ã –∏—Å–ø–æ–ª—å–∑—É–µ—Ç–µ —ç—Ç–æ –Ω–µ–æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ, –≤—ã –æ–±—è–∑–∞–Ω—ã —è–≤–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å —Å–ª—É—á–∞–π, –∫–æ–≥–¥–∞ –∑–Ω–∞—á–µ–Ω–∏–µ ‚Äî null. –í–µ–∑–¥–µ, –≥–¥–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–º–µ–µ—Ç —Ç–∏–ø, –æ—Ç–ª–∏—á–Ω—ã–π –æ—Ç <code>Option&lt;T&gt;</code>, –≤—ã <em>–º–æ–∂–µ—Ç–µ</em> —Å–º–µ–ª–æ —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞—Ç—å –Ω–∞ —Ç–æ, —á—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–µ —Ä–∞–≤–Ω–æ null. –≠—Ç–æ ‚Äî –ø—Ä–æ–¥—É–º–∞–Ω–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã Rust, –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞—é—â–µ–µ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ null –∏ —É–≤–µ–ª–∏—á–∏–≤–∞—é—â–µ–µ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –∫–æ–¥–∞ –Ω–∞ —ç—Ç–æ–º —è–∑—ã–∫–µ.</p>
<p>–ò—Ç–∞–∫, –∫–∞–∫ –∂–µ –ø–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ <code>T</code> –∏–∑ –≤–∞—Ä–∏–∞–Ω—Ç–∞ <code>Some</code>, –µ—Å–ª–∏ —É –≤–∞—Å –Ω–∞ —Ä—É–∫–∞—Ö –µ—Å—Ç—å —Ç–æ–ª—å–∫–æ –∑–Ω–∞—á–µ–Ω–∏–µ <code>Option&lt;T&gt;</code>? –ü–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ <code>Option&lt;T&gt;</code> –∏–º–µ–µ—Ç –±–æ–ª—å—à–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–µ—Ç–æ–¥–æ–≤, –ø–æ–ª–µ–∑–Ω—ã—Ö –≤ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Å–∏—Ç—É–∞—Ü–∏—è—Ö; –≤—ã –º–æ–∂–µ—Ç–µ –æ–∑–Ω–∞–∫–æ–º–∏—Ç—å—Å—è —Å –Ω–∏–º–∏ –≤ <a href="https://doc.rust-lang.org/std/option/enum.Option.html">–µ–≥–æ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏</a><!-- ignore -->. –ó–Ω–∞–∫–æ–º—Å—Ç–≤–æ —Å –º–µ—Ç–æ–¥–∞–º–∏ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è <code>Option&lt;T&gt;</code> –≤ –≤–∞—à–µ–º –ø—É—Ç–µ—à–µ—Å—Ç–≤–∏–∏ —Å Rust –±—É–¥–µ—Ç —á—Ä–µ–∑–≤—ã—á–∞–π–Ω–æ –ø–æ–ª–µ–∑–Ω—ã–º.</p>
<p>–í –æ–±—â–µ–º —Å–ª—É—á–∞–µ, —á—Ç–æ–±—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ <code>Option&lt;T&gt;</code>, –Ω—É–∂–µ–Ω –∫–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –±—É–¥–µ—Ç –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –≤—Å–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã —ç—Ç–æ–≥–æ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è. –ï—Å–ª–∏ —É –≤–∞—Å –µ—Å—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ <code>Some(T)</code>, –≤–∞–º –Ω—É–∂–µ–Ω –æ–¥–∏–Ω –∫–æ–¥ –¥–ª—è –µ–≥–æ –æ–±—Ä–∞–±–æ—Ç–∫–∏, –∏ —ç—Ç–æ–º—É –∫–æ–¥—É –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å —Ä–∞–∑—Ä–µ—à–µ–Ω–æ —Ä–∞–±–æ—Ç–∞—Ç—å —Å —ç—Ç–∏–º –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–º <code>T</code>. –ï—Å–ª–∏ –∂–µ —É –≤–∞—Å –µ—Å—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ <code>None</code>, —Ç–æ –≤–∞–º –∑–∞—Ö–æ—á–µ—Ç—Å—è –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –µ–≥–æ –∏–Ω–∞—á–µ, –ø—Ä–∏ —ç—Ç–æ–º —É —ç—Ç–æ–≥–æ –∫–æ–¥–∞ –Ω–µ –±—É–¥–µ—Ç –Ω–∏–∫–∞–∫–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è <code>T</code> –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏. –í—ã—Ä–∞–∂–µ–Ω–∏–µ <code>match</code> ‚Äî —ç—Ç–æ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–æ—Ç–æ–∫–æ–º –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è –ø—Ä–æ–≥—Ä–∞–º–º—ã, –∫–æ—Ç–æ—Ä–∞—è –¥–µ–ª–∞–µ—Ç —Å –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è–º–∏ –∏–º–µ–Ω–Ω–æ –≤—Å—ë, —á—Ç–æ –º—ã —Ç–æ–ª—å–∫–æ —á—Ç–æ —Å–∫–∞–∑–∞–ª–∏: –æ–Ω–∞ –∑–∞–ø—É—Å–∫–∞–µ—Ç —Ä–∞–∑–Ω—ã–π –∫–æ–¥ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–æ–≥–æ, –∫–∞–∫–æ–π –≤–∞—Ä–∏–∞–Ω—Ç –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –µ–π –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω, –∏ —ç—Ç–æ—Ç –∫–æ–¥ –º–æ–∂–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –¥–∞–Ω–Ω—ã–µ, –Ω–∞—Ö–æ–¥—è—â–∏–µ—Å—è –≤–Ω—É—Ç—Ä–∏ –≤–∞—Ä–∏–∞–Ω—Ç–∞, –æ—Ç–≤–µ—á–∞—é—â–µ–≥–æ —à–∞–±–ª–æ–Ω—É.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- Old heading. Do not remove or links may break. -->
<p><a id="the-match-control-flow-operator"></a></p>
<h2 id="–ö–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏—è-match"><a class="header" href="#–ö–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏—è-match">–ö–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏—è <code>match</code></a></h2>
<p>–í Rust –µ—Å—Ç—å —á—Ä–µ–∑–≤—ã—á–∞–π–Ω–æ –º–æ—â–Ω–∞—è –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–æ—Ç–æ–∫–æ–º, –∏–º–µ–Ω—É–µ–º–∞—è <code>match</code> ‚Äî –æ–Ω–∞ –ø–æ–∑–≤–æ–ª—è–µ—Ç —Å—Ä–∞–≤–Ω–∏–≤–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ —Å —Ä–∞–∑–ª–∏—á–Ω—ã–º–∏ —à–∞–±–ª–æ–Ω–∞–º–∏ –∏ –∏—Å–ø–æ–ª–Ω—è—Ç—å –∫–æ–¥ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–æ–≥–æ, –∫–∞–∫–æ–π –∏–∑ —à–∞–±–ª–æ–Ω–æ–≤ —Å–æ–≤–ø–∞–ª. –®–∞–±–ª–æ–Ω—ã –º–æ–≥—É—Ç —Å–æ—Å—Ç–æ—è—Ç—å –∏–∑ –ª–∏—Ç–µ—Ä–∞–ª–æ–≤, –∏–º—ë–Ω –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö, –Ω–µ–æ–ø—Ä–æ–≤–µ—Ä–∂–∏–º—ã—Ö —à–∞–±–ª–æ–Ω–æ–≤ –∏ –º–Ω–æ–≥–æ–≥–æ –¥—Ä—É–≥–æ–≥–æ; –≤ <a href="ch19-00-patterns.html">–ì–ª–∞–≤–µ 19</a><!-- ignore --> —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞—é—Ç—Å—è –≤—Å–µ —Ä–∞–∑–ª–∏—á–Ω—ã–µ –≤–∏–¥—ã —à–∞–±–ª–æ–Ω–æ–≤ –∏ —Ç–æ, —á—Ç–æ –æ–Ω–∏ –¥–µ–ª–∞—é—Ç. –°–∏–ª–∞ <code>match</code> –∑–∞–∫–ª—é—á–∞–µ—Ç—Å—è –≤ –≤—ã—Ä–∞–∑–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ —à–∞–±–ª–æ–Ω–æ–≤ –∏ –≤ —Ç–æ–º, —á—Ç–æ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä —Å–ø–æ—Å–æ–±–µ–Ω –ø—Ä–æ–≤–µ—Ä–∏—Ç—å, —á—Ç–æ –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ —Å–ª—É—á–∞–∏ –æ–±—Ä–∞–±–æ—Ç–∞–Ω—ã.</p>
<p>–î—É–º–∞–π—Ç–µ –æ –≤—ã—Ä–∞–∂–µ–Ω–∏–∏ <code>match</code> –∫–∞–∫ –æ –º–∞—à–∏–Ω–µ –¥–ª—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏ –º–æ–Ω–µ—Ç: –º–æ–Ω–µ—Ç—ã —Å–∫–æ–ª—å–∑—è—Ç –ø–æ –¥–æ—Ä–æ–∂–∫–µ —Å —Ä–∞–∑–ª–∏—á–Ω—ã–º–∏ –ø–æ —Ä–∞–∑–º–µ—Ä—É –æ—Ç–≤–µ—Ä—Å—Ç–∏—è–º–∏, –∏ –∫–∞–∂–¥–∞—è –º–æ–Ω–µ—Ç–∞ –ø–∞–¥–∞–µ—Ç –≤ –ø–µ—Ä–≤–æ–µ –æ—Ç–≤–µ—Ä—Å—Ç–∏–µ, –≤ –∫–æ—Ç–æ—Ä–æ–µ –æ–Ω–∞ –ø–æ–º–µ—â–∞–µ—Ç—Å—è. –¢–∞–∫–∏–º –∂–µ –æ–±—Ä–∞–∑–æ–º –∑–Ω–∞—á–µ–Ω–∏—è –ø—Ä–æ—Ö–æ–¥—è—Ç —á–µ—Ä–µ–∑ –∫–∞–∂–¥—ã–π —à–∞–±–ª–æ–Ω –≤ <code>match</code>, –∏ –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –∂–µ –ø–æ–¥—Ö–æ–¥—è—â–µ–º —à–∞–±–ª–æ–Ω–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ–ø–∞–¥–∞–µ—Ç –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π –±–ª–æ–∫ –∫–æ–¥–∞, –∫–æ—Ç–æ—Ä—ã–π –∏ –±—É–¥–µ—Ç –∏—Å–ø–æ–ª–Ω—è—Ç—å—Å—è.</p>
<p>–ö—Å—Ç–∞—Ç–∏, –≥–æ–≤–æ—Ä—è –æ –º–æ–Ω–µ—Ç–∞—Ö! –î–∞–≤–∞–π—Ç–µ –∏—Å–ø–æ–ª—å–∑—É–µ–º –∏—Ö, —á—Ç–æ–±—ã –ø–æ–∫–∞–∑–∞—Ç—å —Ä–∞–±–æ—Ç—É <code>match</code>. –î–ª—è —ç—Ç–æ–≥–æ –º—ã –Ω–∞–ø–∏—à–µ–º —Ñ—É–Ω–∫—Ü–∏—é, –∫–æ—Ç–æ—Ä–∞—è –±—É–¥–µ—Ç –ø–æ–ª—É—á–∞—Ç—å –Ω–∞ –≤—Ö–æ–¥ –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—É—é –º–æ–Ω–µ—Ç—É –°–®–ê –∏, –ø–æ–¥–æ–±–Ω–æ —Å—á—ë—Ç–Ω–æ–π –º–∞—à–∏–Ω–µ, –æ–ø—Ä–µ–¥–µ–ª—è—Ç—å, –∫–∞–∫–∞—è —ç—Ç–æ –º–æ–Ω–µ—Ç–∞, –∏ –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å –µ—ë —Å—Ç–æ–∏–º–æ—Å—Ç—å –≤ —Ü–µ–Ω—Ç–∞—Ö. –°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π –∫–æ–¥ –ø—Ä–∏–≤–µ–¥—ë–Ω –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 6-3.</p>
<Listing number="6-3" caption="An enum and a `match` expression that has the variants of the enum as its patterns">
<pre><pre class="playground"><code class="language-rust edition2021">enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p>–ü–æ—Å—Ç—Ä–æ—á–Ω–æ —Ä–∞–∑–±–µ—Ä—ë–º <code>match</code> –≤ —Ñ—É–Ω–∫—Ü–∏–∏ <code>value_in_cents</code>. –°–Ω–∞—á–∞–ª–∞ –ø–∏—à–µ—Ç—Å—è –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ <code>match</code>, –∑–∞—Ç–µ–º —Å–ª–µ–¥—É–µ—Ç –≤—ã—Ä–∞–∂–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –≤ –¥–∞–Ω–Ω–æ–º —Å–ª—É—á–∞–µ —è–≤–ª—è–µ—Ç—Å—è –∑–Ω–∞—á–µ–Ω–∏–µ–º <code>coin</code>. –≠—Ç–æ –≤—ã–≥–ª—è–¥–∏—Ç –æ—á–µ–Ω—å –ø–æ—Ö–æ–∂–∏–º –Ω–∞ —É—Å–ª–æ–≤–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ –ø—Ä–∏ <code>if</code>, –Ω–æ –µ—Å—Ç—å –≤–∞–∂–Ω–æ–µ –æ—Ç–ª–∏—á–∏–µ: –≤ <code>if</code> –≤—ã—Ä–∞–∂–µ–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å –ª–æ–≥–∏—á–µ—Å–∫–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ, –∞ –∑–¥–µ—Å—å —ç—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å –ª—é–±–æ–π —Ç–∏–ø. –¢–∏–ø <code>coin</code> –≤ —ç—Ç–æ–º –ø—Ä–∏–º–µ—Ä–µ ‚Äî –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ —Ç–∏–ø–∞ <code>Coin</code>, –æ–±—ä—è–≤–ª–µ–Ω–Ω–æ–µ –≤ –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–æ–∫–µ.</p>
<p>–î–∞–ª–µ–µ –∏–¥—É—Ç –≤–µ—Ç–≤–∏ <code>match</code>. –í–µ—Ç–≤–∏ —Å–æ—Å—Ç–æ—è—Ç –∏–∑ –¥–≤—É—Ö —á–∞—Å—Ç–µ–π: —à–∞–±–ª–æ–Ω –∏ –Ω–µ–∫–æ—Ç–æ—Ä—ã–π –∫–æ–¥. –ó–¥–µ—Å—å –ø–µ—Ä–≤–∞—è –≤–µ—Ç–≤—å –∏–º–µ–µ—Ç —à–∞–±–ª–æ–Ω, –∫–æ—Ç–æ—Ä—ã–π —è–≤–ª—è–µ—Ç—Å—è –∑–Ω–∞—á–µ–Ω–∏–µ–º <code>Coin::Penny</code>, –∑–∞—Ç–µ–º –∏–¥—ë—Ç –æ–ø–µ—Ä–∞—Ç–æ—Ä <code>=&gt;</code>, –∫–æ—Ç–æ—Ä—ã–π —Ä–∞–∑–¥–µ–ª—è–µ—Ç —à–∞–±–ª–æ–Ω –∏ –∏—Å–ø–æ–ª–Ω—è–µ–º—ã–π –∫–æ–¥. –ö–æ–¥ –≤ —ç—Ç–æ–º —Å–ª—É—á–∞–µ ‚Äî —ç—Ç–æ –ø—Ä–æ—Å—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ <code>1</code>. –ö–∞–∂–¥–∞—è –≤–µ—Ç–≤—å –æ—Ç–¥–µ–ª—è–µ—Ç—Å—è –æ—Ç –ø–æ—Å–ª–µ–¥—É—é—â–µ–π –ø—Ä–∏ –ø–æ–º–æ—â–∏ –∑–∞–ø—è—Ç–æ–π.</p>
<p>–ö–æ–≥–¥–∞ –∏—Å–ø–æ–ª–Ω—è–µ—Ç—Å—è –≤—ã—Ä–∞–∂–µ–Ω–∏–µ <code>match</code>, –æ–Ω–æ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ —Å—Ä–∞–≤–Ω–∏–≤–∞–µ—Ç –ø–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Å —à–∞–±–ª–æ–Ω–æ–º –∫–∞–∂–¥–æ–π –≤–µ—Ç–≤–∏. –ï—Å–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ –æ—Ç–≤–µ—á–∞–µ—Ç —à–∞–±–ª–æ–Ω—É, —Ç–æ –∫–æ–¥, —Å–≤—è–∑–∞–Ω–Ω—ã–π —Å —ç—Ç–∏–º —à–∞–±–ª–æ–Ω–æ–º, –∏—Å–ø–æ–ª–Ω—è–µ—Ç—Å—è. –ï—Å–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç —ç—Ç–æ–º—É —à–∞–±–ª–æ–Ω—É, —Ç–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –ø–æ–ø—ã—Ç–∫–∞ —Å–æ–ø–æ—Å—Ç–∞–≤–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ —Å–æ —Å–ª–µ–¥—É—é—â–∏–º —à–∞–±–ª–æ–Ω–æ–º: –ø–æ –∞–Ω–∞–ª–æ–≥–∏–∏ —Å –∞–≤—Ç–æ–º–∞—Ç–æ–º –ø–æ —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–µ –º–æ–Ω–µ—Ç. –£ –Ω–∞—Å –º–æ–∂–µ—Ç –±—ã—Ç—å —Å—Ç–æ–ª—å–∫–æ –≤–µ—Ç–≤–µ–π, —Å–∫–æ–ª—å–∫–æ –Ω—É–∂–Ω–æ: –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 6-3 –Ω–∞—à <code>match</code> —Å–æ—Å—Ç–æ–∏—Ç –∏–∑ —á–µ—Ç—ã—Ä—ë—Ö –≤–µ—Ç–≤–µ–π.</p>
<p>–ö–æ–¥, —Å–≤—è–∑–∞–Ω–Ω—ã–π —Å –∫–∞–∂–¥–æ–π –≤–µ—Ç–≤—å—é, —è–≤–ª—è–µ—Ç—Å—è –≤—ã—Ä–∞–∂–µ–Ω–∏–µ–º, –∞ —Ä–µ–∑—É–ª—å—Ç–∏—Ä—É—é—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –≤—ã—Ä–∞–∂–µ–Ω–∏—è –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–º –æ—Ç–≤–µ—Ç–≤–ª–µ–Ω–∏–∏ ‚Äî —ç—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è –∏–∑ –≤—Å–µ–≥–æ –≤—ã—Ä–∞–∂–µ–Ω–∏—è <code>match</code>.</p>
<p>–û–±—ã—á–Ω–æ —Ñ–∏–≥—É—Ä–Ω—ã–µ —Å–∫–æ–±–∫–∏ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è, –µ—Å–ª–∏ –∫–æ–¥ —Å–æ–≤–ø–∞–¥–∞—é—â–µ–π –≤–µ—Ç–≤–∏ –Ω–µ–≤–µ–ª–∏–∫ (–∫–∞–∫ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 6-3, –≥–¥–µ –∫–∞–∂–¥–∞—è –≤–µ—Ç–≤—å –ø—Ä–æ—Å—Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ). –ï—Å–ª–∏ –≤—ã —Ö–æ—Ç–∏—Ç–µ –≤—ã–ø–æ–ª–Ω–∏—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å—Ç—Ä–æ–∫ –∫–æ–¥–∞ –≤ –æ–¥–Ω–æ–π –≤–µ—Ç–≤–∏, –≤—ã –¥–æ–ª–∂–Ω—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ñ–∏–≥—É—Ä–Ω—ã–µ —Å–∫–æ–±–∫–∏; –∑–∞–ø—è—Ç–∞—è –ø–æ—Å–ª–µ —ç—Ç–æ–π –≤–µ—Ç–≤–∏ –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–∞. –ù–∞–ø—Ä–∏–º–µ—Ä, —Å–ª–µ–¥—É—é—â–∏–π –∫–æ–¥ –ø–µ—á–∞—Ç–∞–µ—Ç "–°—á–∞—Å—Ç–ª–∏–≤—ã–π –ø–µ–Ω–Ω–∏!" –∫–∞–∂–¥—ã–π —Ä–∞–∑, –∫–æ–≥–¥–∞ –º–µ—Ç–æ–¥ –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è —Å <code>Coin::Penny</code>, –Ω–æ –ø—Ä–∏ —ç—Ç–æ–º –æ–Ω –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–æ—Å–ª–µ–¥–Ω–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –±–ª–æ–∫–∞ ‚Äî <code>1</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter,
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; {
            println!("–°—á–∞—Å—Ç–ª–∏–≤—ã–π –ø–µ–Ω–Ω–∏!");
            1
        }
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<h3 id="–°–≤—è–∑—ã–≤–∞–Ω–∏–µ-—Å–æ-–∑–Ω–∞—á–µ–Ω–∏—è–º–∏-—Å-–ø–æ–º–æ—â—å—é-—à–∞–±–ª–æ–Ω–æ–≤"><a class="header" href="#–°–≤—è–∑—ã–≤–∞–Ω–∏–µ-—Å–æ-–∑–Ω–∞—á–µ–Ω–∏—è–º–∏-—Å-–ø–æ–º–æ—â—å—é-—à–∞–±–ª–æ–Ω–æ–≤">–°–≤—è–∑—ã–≤–∞–Ω–∏–µ —Å–æ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏ —Å –ø–æ–º–æ—â—å—é —à–∞–±–ª–æ–Ω–æ–≤</a></h3>
<p>–£ –≤–µ—Ç–≤–µ–π –≤—ã—Ä–∞–∂–µ–Ω–∏—è <code>match</code> –µ—Å—Ç—å –µ—â—ë –æ–¥–Ω–∞ –ø–æ–ª–µ–∑–Ω–∞—è –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç—å: –æ–Ω–∏ –º–æ–≥—É—Ç –ø—Ä–∏–≤—è–∑—ã–≤–∞—Ç—å—Å—è –∫ —á–∞—Å—Ç—è–º —Ç–µ—Ö –∑–Ω–∞—á–µ–Ω–∏–π, –∫–æ—Ç–æ—Ä—ã–µ —Å–æ–≤–ø–∞–ª–∏ —Å —à–∞–±–ª–æ–Ω–æ–º. –ë–ª–∞–≥–æ–¥–∞—Ä—è —ç—Ç–æ–º—É –≤–æ–∑–º–æ–∂–Ω–æ –∏–∑–≤–ª–µ–∫–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è –∏–∑ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è.</p>
<p>–í –∫–∞—á–µ—Å—Ç–≤–µ –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏, –¥–∞–≤–∞–π—Ç–µ –∏–∑–º–µ–Ω–∏–º –æ–¥–∏–Ω –∏–∑ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è —Ç–∞–∫, —á—Ç–æ–±—ã –æ–Ω —Ö—Ä–∞–Ω–∏–ª –≤ —Å–µ–±–µ –¥–∞–Ω–Ω—ã–µ. –° 1999 –ø–æ 2008, –°–æ–µ–¥–∏–Ω—ë–Ω–Ω—ã–µ –®—Ç–∞—Ç—ã —á–µ–∫–∞–Ω–∏–ª–∏ –æ—Å–æ–±–µ–Ω–Ω—ã–µ —á–µ—Ç–≤–µ—Ä—Ç–∞–∫–∏: —Å —É–Ω–∏–∫–∞–ª—å–Ω—ã–º–∏ –¥–∏–∑–∞–π–Ω–∞–º–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∏–∑ 50 —à—Ç–∞—Ç–æ–≤. –ù–∏ –æ–¥–Ω–∞ –¥—Ä—É–≥–∞—è –º–æ–Ω–µ—Ç–∞ –Ω–µ –ø–æ–ª—É—á–∏–ª–∞ –¥–∏–∑–∞–π–Ω–∞, –æ—Å–æ–±–µ–Ω–Ω–æ–≥–æ –¥–ª—è –æ—Ç–¥–µ–ª—å–Ω—ã—Ö —à—Ç–∞—Ç–æ–≤, —Ç–æ–ª—å–∫–æ —á–µ—Ç–≤–µ—Ä—Ç—å –¥–æ–ª–ª–∞—Ä–∞ –∏–º–µ–ª–∞ —ç—Ç—É –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç—å. –ú—ã –º–æ–∂–µ–º –¥–æ–±–∞–≤–∏—Ç—å —ç—Ç—É –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –≤ –Ω–∞—à <code>enum</code> –ø—É—Ç—ë–º –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤–∞—Ä–∏–∞–Ω—Ç–∞ <code>Quarter</code> –∏ –≤–∫–ª—é—á–µ–Ω–∏—è –≤ –Ω–µ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è <code>UsState</code>, –∫–∞–∫ —Å–¥–µ–ª–∞–Ω–æ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 6-4.</p>
<Listing number="6-4" caption="A `Coin` enum in which the `Quarter` variant also holds a `UsState` value">
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)] // –Ω—É–∂–Ω–æ, —á—Ç–æ–±—ã –º—ã –º–æ–≥–ª–∏ –ª–µ–≥–∫–æ –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —à—Ç–∞—Ç
enum UsState {
    Alabama,
    Alaska,
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p>–ü—Ä–µ–¥—Å—Ç–∞–≤—å—Ç–µ, —á—Ç–æ –≤–∞—à –¥—Ä—É–≥ –ø—ã—Ç–∞–µ—Ç—Å—è —Å–æ–±—Ä–∞—Ç—å —á–µ—Ç–≤–µ—Ä—Ç–∞–∫–∏ –≤—Å–µ—Ö 50 —à—Ç–∞—Ç–æ–≤. –°–æ—Ä—Ç–∏—Ä—É—è –º–æ–Ω–µ—Ç—ã –ø–æ —Ç–∏–ø—É, –º—ã —Ç–∞–∫–∂–µ –±—É–¥–µ–º —Å–æ–æ–±—â–∞—Ç—å –Ω–∞–∑–≤–∞–Ω–∏–µ —à—Ç–∞—Ç–∞, –∫ –∫–æ—Ç–æ—Ä–æ–º—É –æ—Ç–Ω–æ—Å–∏—Ç—Å—è –∫–∞–∂–¥—ã–π —á–µ—Ç–≤–µ—Ä—Ç–∞–∫, —á—Ç–æ–±—ã, –µ—Å–ª–∏ —É –Ω–∞—à–µ–≥–æ –¥—Ä—É–≥–∞ –Ω–µ—Ç —Ç–∞–∫–æ–π –º–æ–Ω–µ—Ç—ã, –æ–Ω –º–æ–≥ –¥–æ–±–∞–≤–∏—Ç—å –µ—ë –≤ —Å–≤–æ—é –∫–æ–ª–ª–µ–∫—Ü–∏—é.</p>
<p>–í –≤—ã—Ä–∞–∂–µ–Ω–∏–∏ <code>match</code> –º—ã –¥–æ–±–∞–≤–ª—è–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é —Å –∏–º–µ–Ω–µ–º <code>state</code> –≤ —à–∞–±–ª–æ–Ω, –∫–æ—Ç–æ—Ä—ã–π —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –∑–Ω–∞—á–µ–Ω–∏—è–º –≤–∞—Ä–∏–∞–Ω—Ç–∞ <code>Coin::Quarter</code>. –ö–æ–≥–¥–∞ <code>Coin::Quarter</code> —Å–æ–ø–æ—Å—Ç–∞–≤–∏—Ç—Å—è —Å —à–∞–±–ª–æ–Ω–æ–º, –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è <code>state</code> —Å—Ç–∞–Ω–µ—Ç —Å–≤—è–∑–∞–Ω–∞ —Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º —à—Ç–∞—Ç–∞ —ç—Ç–æ–≥–æ —á–µ—Ç–≤–µ—Ä—Ç–∞–∫–∞. –ó–∞—Ç–µ–º –º—ã —Å–º–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å <code>state</code> –≤ –∫–æ–¥–µ —ç—Ç–æ–π –≤–µ—Ç–∫–∏; –≤–æ—Ç —Ç–∞–∫:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!("–ß–µ—Ç–≤–µ—Ä—Ç–∞–∫ –∏–∑ —à—Ç–∞—Ç–∞ {state:?}!");
            25
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    value_in_cents(Coin::Quarter(UsState::Alaska));
</span><span class="boring">}</span></code></pre></pre>
<p>–ï—Å–ª–∏ –º—ã —Å–¥–µ–ª–∞–µ–º –≤—ã–∑–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏ <code>value_in_cents(Coin::Quarter(UsState::Alaska))</code>, —Ç–æ <code>coin</code> –±—É–¥–µ—Ç –∏–º–µ—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ <code>Coin::Quarter(UsState::Alaska)</code>. –ö–æ–≥–¥–∞ –º—ã –±—É–¥–µ–º —Å—Ä–∞–≤–Ω–∏–≤–∞—Ç—å —ç—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ —Å —à–∞–±–ª–æ–Ω–∞–º–∏ –∫–∞–∂–¥–æ–π –∏–∑ –≤–µ—Ç–≤–µ–π, –Ω–∏ –æ–¥–Ω–æ–º—É –∏–∑ –Ω–∏—Ö –æ–Ω–æ –Ω–µ –±—É–¥–µ—Ç –æ—Ç–≤–µ—á–∞—Ç—å, –ø–æ–∫–∞ –º—ã –Ω–µ –¥–æ—Å—Ç–∏–≥–Ω–µ–º <code>Coin::Quarter(state)</code>. –í —ç—Ç–æ—Ç –º–æ–º–µ–Ω—Ç <code>state</code> —Å–≤—è–∂–µ—Ç—Å—è —Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º <code>UsState::Alaska</code>. –ó–∞—Ç–µ–º –º—ã —Å–º–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç—Ç—É –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –≤ –≤—ã—Ä–∞–∂–µ–Ω–∏–∏ <code>println!</code>, –ø–æ–ª—É—á–∏–≤ —Ç–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç–∞ <code>Quarter</code> –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è <code>Coin</code>.</p>
<h3 id="–°–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ-—Å-–≤–∞—Ä–∏–∞–Ω—Ç–∞–º–∏-optiont"><a class="header" href="#–°–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ-—Å-–≤–∞—Ä–∏–∞–Ω—Ç–∞–º–∏-optiont">–°–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ —Å –≤–∞—Ä–∏–∞–Ω—Ç–∞–º–∏ <code>Option&lt;T&gt;</code></a></h3>
<p>–í –ø—Ä–µ–¥—ã–¥—É—â–µ–º —Ä–∞–∑–¥–µ–ª–µ –º—ã —Ö–æ—Ç–µ–ª–∏ –ø–æ–ª—É—á–∏—Ç—å –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ <code>T</code> –¥–ª—è —Å–ª—É—á–∞—è <code>Some</code> –ø—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ <code>Option&lt;T&gt;</code>. –ú—ã –º–æ–∂–µ–º –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å —Ç–∏–ø <code>Option&lt;T&gt;</code>, –∏—Å–ø–æ–ª—å–∑—É—è <code>match</code>, –∫–∞–∫ —É–∂–µ –¥–µ–ª–∞–ª–∏ —Å –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ–º <code>Coin</code>! –í–º–µ—Å—Ç–æ —Å—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏—è –º–æ–Ω–µ—Ç –º—ã –±—É–¥–µ–º —Å—Ä–∞–≤–Ω–∏–≤–∞—Ç—å –≤–∞—Ä–∏–∞–Ω—Ç—ã <code>Option&lt;T&gt;</code>, –Ω–æ –º–µ—Ö–∞–Ω–∏–∑–º —Ä–∞–±–æ—Ç—ã –≤—ã—Ä–∞–∂–µ–Ω–∏—è <code>match</code> –æ—Å—Ç–∞–Ω–µ—Ç—Å—è –ø—Ä–µ–∂–Ω–∏–º.</p>
<p>–î–æ–ø—É—Å—Ç–∏–º, –º—ã —Ö–æ—Ç–∏–º –Ω–∞–ø–∏—Å–∞—Ç—å —Ñ—É–Ω–∫—Ü–∏—é, –∫–æ—Ç–æ—Ä–∞—è –ø—Ä–∏–Ω–∏–º–∞–µ—Ç <code>Option&lt;i32&gt;</code> –∏, –µ—Å–ª–∏ –µ—Å—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –≤–Ω—É—Ç—Ä–∏, –¥–æ–±–∞–≤–ª—è–µ—Ç <code>1</code> –∫ —ç—Ç–æ–º—É –∑–Ω–∞—á–µ–Ω–∏—é. –ï—Å–ª–∏ –∂–µ –∑–Ω–∞—á–µ–Ω–∏—è –Ω–µ—Ç, —Ç–æ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ–ª–∂–Ω–∞ –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ <code>None</code> –∏ –Ω–µ –ø—ã—Ç–∞—Ç—å—Å—è –≤—ã–ø–æ–ª–Ω–∏—Ç—å –∫–∞–∫–∏–µ-–ª–∏–±–æ –æ–ø–µ—Ä–∞—Ü–∏–∏.</p>
<p>–¢–∞–∫—É—é —Ñ—É–Ω–∫—Ü–∏—é –Ω–∞–ø–∏—Å–∞—Ç—å –¥–æ–≤–æ–ª—å–Ω–æ –ª–µ–≥–∫–æ: –≤—Å—ë –±–ª–∞–≥–æ–¥–∞—Ä—è –≤—ã—Ä–∞–∂–µ–Ω–∏—é <code>match</code>. –ö–æ–¥ –±—É–¥–µ—Ç –≤—ã–≥–ª—è–¥–µ—Ç—å –∫–∞–∫ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 6-5.</p>
<Listing number="6-5" caption="A function that uses a `match` expression on an `Option<i32>`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            None =&gt; None,
            Some(i) =&gt; Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>Let‚Äôs examine the first execution of <code>plus_one</code> in more detail. When we call <code>plus_one(five)</code>, the variable <code>x</code> in the body of <code>plus_one</code> will have the value <code>Some(5)</code>. We then compare that against each match arm:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p>–ó–Ω–∞—á–µ–Ω–∏–µ <code>Some(5)</code> –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —à–∞–±–ª–æ–Ω—É <code>None</code>, –ø–æ—ç—Ç–æ–º—É –º—ã —Å—Ä–∞–≤–Ω–∏–≤–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ —Å–æ —Å–ª–µ–¥—É—é—â–∏–º —à–∞–±–ª–æ–Ω–æ–º:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span><span class="boring">            None =&gt; None,
</span>            Some(i) =&gt; Some(i + 1),
<span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p>–û—Ç–≤–µ—á–∞–µ—Ç –ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ <code>Some(5)</code> —à–∞–±–ª–æ–Ω—É <code>Some(i)</code>? –î–∞, –∫–æ–Ω–µ—á–Ω–æ! –æ–Ω–∏ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω—ã –æ–¥–∏–Ω–∞–∫–æ–≤—ã–º–∏ –≤–∞—Ä–∏–∞–Ω—Ç–∞–º–∏ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è. –†–∞–∑ —Ç–∞–∫, –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è <code>i</code> –ø—Ä–∏–≤—è–∑—ã–≤–∞–µ—Ç—Å—è –∫ –∑–Ω–∞—á–µ–Ω–∏—é, —Å–æ–¥–µ—Ä–∂–∞—â–µ–º—É—Å—è –≤–Ω—É—Ç—Ä–∏ <code>Some</code>, —Ç–æ –µ—Å—Ç—å <code>i</code> –ø–æ–ª—É—á–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ <code>5</code>. –ó–∞—Ç–µ–º –∏—Å–ø–æ–ª–Ω—è–µ—Ç—Å—è –∫–æ–¥, —Å–≤—è–∑–∞–Ω–Ω—ã–π —Å –¥–∞–Ω–Ω–æ–π –≤–µ—Ç–≤—å—é: –º—ã –¥–æ–±–∞–≤–ª—è–µ–º <code>1</code> –∫ –∑–Ω–∞—á–µ–Ω–∏—é <code>i</code> –∏ —Å–æ–∑–¥–∞—ë–º –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ <code>Some</code> —Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º <code>6</code> –≤–Ω—É—Ç—Ä–∏.</p>
<p>–¢–µ–ø–µ—Ä—å –¥–∞–≤–∞–π—Ç–µ —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º –≤—Ç–æ—Ä–æ–π –≤—ã–∑–æ–≤ <code>plus_one</code> –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 6-5 (–≥–¥–µ <code>x</code> —è–≤–ª—è–µ—Ç—Å—è <code>None</code>). –ú—ã –≤—Ö–æ–¥–∏–º –≤ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ <code>match</code> –∏ —Å—Ä–∞–≤–Ω–∏–≤–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ —Å —à–∞–±–ª–æ–Ω–æ–º –ø–µ—Ä–≤–æ–π –≤–µ—Ç–≤–∏:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p>–û–Ω–æ —Å–æ–≤–ø–∞–¥–∞–µ—Ç! –î–∞–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–∏—á–µ–≥–æ –≤ —Å–µ–±–µ –Ω–µ —Ö—Ä–∞–Ω–∏—Ç, —Ç–∞–∫ —á—Ç–æ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ –ø—Ä–æ—Å—Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ <code>None</code>, –Ω–∞—Ö–æ–¥—è—â–µ–µ—Å—è —Å–ø—Ä–∞–≤–∞ –æ—Ç <code>=&gt;</code>. –ü–æ—Å–∫–æ–ª—å–∫—É —à–∞–±–ª–æ–Ω –ø–µ—Ä–≤–æ–π –≤–µ—Ç–≤–∏ —Å–æ–≤–ø–∞–ª, —Å—Ä–∞–≤–Ω–µ–Ω–∏–π —Å –æ—Å—Ç–∞–≤—à–∏–º–∏—Å—è —à–∞–±–ª–æ–Ω–∞–º–∏ –Ω–µ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç.</p>
<p>–ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ <code>match</code> –∏ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π –ø–æ–ª–µ–∑–Ω–æ –≤–æ –º–Ω–æ–≥–∏—Ö —Å–∏—Ç—É–∞—Ü–∏—è—Ö. –í—ã —á–∞—Å—Ç–æ –±—É–¥–µ—Ç–µ –≤–∏–¥–µ—Ç—å –ø–æ–¥–æ–±–Ω—É—é –∫–æ–º–±–∏–Ω–∞—Ü–∏—é –≤ –∫–æ–¥–µ –Ω–∞ Rust: –ø–µ—Ä–µ–±–æ—Ä –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–µ–π <code>match</code>, —Å–≤—è–∑—ã–≤–∞–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –∫ –¥–∞–Ω–Ω—ã–º –≤–Ω—É—Ç—Ä–∏ –∑–Ω–∞—á–µ–Ω–∏—è, –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ –∫–æ–¥ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∏–∑–≤–ª–µ—á—ë–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö. –°–Ω–∞—á–∞–ª–∞ —ç—Ç–æ –º–æ–∂–µ—Ç –ø–æ–∫–∞–∑–∞—Ç—å—Å—è –Ω–µ–º–Ω–æ–≥–æ —Å–ª–æ–∂–Ω—ã–º, –Ω–æ –∫–∞–∫ —Ç–æ–ª—å–∫–æ –≤—ã –ø—Ä–∏–≤—ã–∫–Ω–µ—Ç–µ, —Ç–æ –∑–∞—Ö–æ—Ç–∏—Ç–µ, —á—Ç–æ–±—ã —Ç–∞–∫–∞—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –±—ã–ª–∞ –±—ã –≤–æ –≤—Å–µ—Ö —è–∑—ã–∫–∞—Ö. <code>match</code> –Ω–∏–∫–æ–≥–æ –Ω–µ –æ—Å—Ç–∞–≤–ª—è–µ—Ç —Ä–∞–≤–Ω–æ–¥—É—à–Ω—ã–º.</p>
<h3 id="–í–µ—Ç–≤–∏-match-–æ—Ö–≤–∞—Ç—ã–≤–∞—é—Ç-–≤—Å–µ-–≤–æ–∑–º–æ–∂–Ω—ã–µ-—Å–ª—É—á–∞–∏"><a class="header" href="#–í–µ—Ç–≤–∏-match-–æ—Ö–≤–∞—Ç—ã–≤–∞—é—Ç-–≤—Å–µ-–≤–æ–∑–º–æ–∂–Ω—ã–µ-—Å–ª—É—á–∞–∏">–í–µ—Ç–≤–∏ <code>match</code> –æ—Ö–≤–∞—Ç—ã–≤–∞—é—Ç –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ —Å–ª—É—á–∞–∏</a></h3>
<p>–ï—Å—Ç—å –µ—â—ë –æ–¥–Ω–∞ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç—å <code>match</code>, –∫–æ—Ç–æ—Ä—É—é –º—ã –¥–æ–ª–∂–Ω—ã –æ–±—Å—É–¥–∏—Ç—å: —à–∞–±–ª–æ–Ω—ã –¥–æ–ª–∂–Ω—ã –ø–æ–∫—Ä—ã–≤–∞—Ç—å –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ —Å–ª—É—á–∞–∏. –†–∞—Å—Å–º–æ—Ç—Ä–∏–º —Å–ª–µ–¥—É—é—â—É—é –≤–µ—Ä—Å–∏—é –Ω–∞—à–µ–π —Ñ—É–Ω–∫—Ü–∏–∏ <code>plus_one</code>, —Å–æ–¥–µ—Ä–∂–∞—â—É—é –æ—à–∏–±–∫—É –∏ –ø–æ—Ç–æ–º—É –Ω–µ –∫–æ–º–ø–∏–ª–∏—Ä—É—é—â—É—é—Å—è:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            Some(i) =&gt; Some(i + 1),
        }
    }
<span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p>–ú—ã –Ω–µ –æ–±—Ä–∞–±–æ—Ç–∞–ª–∏ –≤–∞—Ä–∏–∞–Ω—Ç None, –∞ –Ω–µ—É—á—ë—Ç –≤–æ–∑–º–æ–∂–Ω—ã—Ö —Å–ª—É—á–∞–µ–≤ ‚Äî –ø—Ä—è–º–æ–π –ø—É—Ç—å –∫ –±–∞–≥–∞–º. –ö —Å—á–∞—Å—Ç—å—é, Rust —É–º–µ–µ—Ç –ª–æ–≤–∏—Ç—å —Ç–∞–∫–∏–µ –ø—Ä–æ–º–∞—Ö–∏. –ï—Å–ª–∏ –º—ã –ø–æ–ø—ã—Ç–∞–µ–º—Å—è —Å–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞—Ç—å —Ç–∞–∫–æ–π –∫–æ–¥, –º—ã –ø–æ–ª—É—á–∏–º –æ—à–∏–±–∫—É –∫–æ–º–ø–∏–ª—è—Ü–∏–∏:</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
   --&gt; src/main.rs:3:15
    |
3   |         match x {
    |               ^ pattern `None` not covered
    |
note: `Option&lt;i32&gt;` defined here
   --&gt; file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/core/src/option.rs:571:1
    |
571 | pub enum Option&lt;T&gt; {
    | ^^^^^^^^^^^^^^^^^^
...
575 |     None,
    |     ---- not covered
    = note: the matched value is of type `Option&lt;i32&gt;`
help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown
    |
4   ~             Some(i) =&gt; Some(i + 1),
5   ~             None =&gt; todo!(),
    |

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums` (bin "enums") due to 1 previous error
</code></pre>
<p>Rust –∑–Ω–∞–µ—Ç, —á—Ç–æ –º—ã –Ω–µ –æ–ø–∏—Å–∞–ª–∏ –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ —Å–ª—É—á–∞–∏, –∏ –¥–∞–∂–µ –∑–Ω–∞–µ—Ç, –∫–∞–∫–æ–π –∏–º–µ–Ω–Ω–æ –∏–∑ —à–∞–±–ª–æ–Ω–æ–≤ –º—ã —É–ø—É—Å—Ç–∏–ª–∏! –°–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è –≤ Rust —è–≤–ª—è—é—Ç—Å—è <em>–∏—Å—á–µ—Ä–ø—ã–≤–∞—é—â–∏–º–∏</em>: –º—ã –æ–±—è–∑–∞–Ω—ã –ø–æ–∫—Ä—ã—Ç—å –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã, —á—Ç–æ–±—ã –∫–æ–¥ –±—ã–ª –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–º. –û—Å–æ–±–µ–Ω–Ω–æ ‚Äî –≤ —Å–ª—É—á–∞–µ <code>Option&lt;T&gt;</code>, –∫–æ–≥–¥–∞ Rust –Ω–µ –¥–∞—ë—Ç –Ω–∞–º –∑–∞–±—ã—Ç—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å —è–≤–Ω—ã–º –æ–±—Ä–∞–∑–æ–º –∑–Ω–∞—á–µ–Ω–∏–µ <code>None</code>, —Ç–µ–º —Å–∞–º—ã–º –∑–∞—â–∏—â–∞—è –Ω–∞—Å –æ—Ç –ª–æ–∂–Ω–æ–≥–æ –ø—Ä–µ–¥–ø–æ–ª–æ–∂–µ–Ω–∏—è –æ –Ω–∞–ª–∏—á–∏–∏ –Ω–µ-null –∑–Ω–∞—á–µ–Ω–∏—è, –∏ –æ–±–µ—Ä–µ–≥–∞—è –Ω–∞—Å –æ—Ç –æ–ø–∞—Å–Ω–æ—Å—Ç–∏ —Å–æ–≤–µ—Ä—à–∏—Ç—å –æ—à–∏–±–∫—É –Ω–∞ –º–∏–ª–ª–∏–∞—Ä–¥ –¥–æ–ª–ª–∞—Ä–æ–≤, –æ –∫–æ—Ç–æ—Ä–æ–π –≥–æ–≤–æ—Ä–∏–ª–æ—Å—å —Ä–∞–Ω–µ–µ.</p>
<h3 id="–£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–µ-—à–∞–±–ª–æ–Ω—ã-–∏-–∑–∞–ø–æ–ª–Ω–∏—Ç–µ–ª—å-_"><a class="header" href="#–£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–µ-—à–∞–±–ª–æ–Ω—ã-–∏-–∑–∞–ø–æ–ª–Ω–∏—Ç–µ–ª—å-_">–£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–µ —à–∞–±–ª–æ–Ω—ã –∏ –∑–∞–ø–æ–ª–Ω–∏—Ç–µ–ª—å <code>_</code></a></h3>
<p>–ò—Å–ø–æ–ª—å–∑—É—è –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è, –º—ã —Ç–∞–∫–∂–µ –º–æ–∂–µ–º –≤—ã–ø–æ–ª–Ω—è—Ç—å —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è –¥–ª—è –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π, –∞ –¥–ª—è –≤—Å–µ—Ö –æ—Å—Ç–∞–ª—å–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π –≤—ã–ø–æ–ª–Ω—è—Ç—å –æ–¥–Ω–æ –æ–±—â–µ–µ –¥–µ–π—Å—Ç–≤–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é. –ü—Ä–µ–¥—Å—Ç–∞–≤—å—Ç–µ, —á—Ç–æ –º—ã —Ä–µ–∞–ª–∏–∑—É–µ–º –∏–≥—Ä—É, –≤ –∫–æ—Ç–æ—Ä–æ–π –ø—Ä–∏ –≤—ã–ø–∞–¥–µ–Ω–∏–∏ 3 –∏–≥—Ä–æ–∫ –Ω–µ –¥–≤–∏–≥–∞–µ—Ç—Å—è, –∞ –ø–æ–ª—É—á–∞–µ—Ç –Ω–æ–≤—É—é –º–æ–¥–Ω—É—é —à–ª—è–ø—É. –ï—Å–ª–∏ –≤—ã–ø–∞–¥–∞–µ—Ç 7, –∏–≥—Ä–æ–∫ —Ç–µ—Ä—è–µ—Ç —à–ª—è–ø—É. –ü—Ä–∏ –≤—Å–µ—Ö –æ—Å—Ç–∞–ª—å–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏—è—Ö –≤–∞—à –∏–≥—Ä–æ–∫ –ø–µ—Ä–µ–º–µ—â–∞–µ—Ç—Å—è –Ω–∞ —Å—Ç–æ–ª—å–∫–æ-—Ç–æ –º–µ—Å—Ç –Ω–∞ –∏–≥—Ä–æ–≤–æ–º –ø–æ–ª–µ. –ù–∏–∂–µ –¥–∞–Ω –ø—Ä–∏–º–µ—Ä <code>match</code>, —Ä–µ–∞–ª–∏–∑—É—é—â–µ–≥–æ –æ–ø–∏—Å–∞–Ω–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ. –†–µ–∑—É–ª—å—Ç–∞—Ç –±—Ä–æ—Å–∫–∞ –∫–æ—Å—Ç–µ–π –∂—ë—Å—Ç–∫–æ –ø—Ä–æ–ø–∏—Å–∞–Ω –≤ –ø—Ä–æ–≥—Ä–∞–º–º–µ (–∞ –Ω–µ —è–≤–ª—è–µ—Ç—Å—è —Å–ª—É—á–∞–π–Ω—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º), –∞ —Ç–∞–∫–∂–µ –≤—Å—è –ª–æ–≥–∏–∫–∞ —Ñ—É–Ω–∫—Ü–∏–π –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è–º–∏ –±–µ–∑ —Ç–µ–ª, –ø–æ—Å–∫–æ–ª—å–∫—É –∏—Ö —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –Ω–µ –≤—Ö–æ–¥–∏—Ç –≤ —Ä–∞–º–∫–∏ –¥–∞–Ω–Ω–æ–≥–æ –ø—Ä–∏–º–µ—Ä–∞.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        other =&gt; move_player(other),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn move_player(num_spaces: u8) {}
<span class="boring">}</span></code></pre></pre>
<p>–î–ª—è –ø–µ—Ä–≤—ã—Ö –¥–≤—É—Ö –≤–µ—Ç–≤–µ–π —à–∞–±–ª–æ–Ω–∞–º–∏ —è–≤–ª—è—é—Ç—Å—è –ª–∏—Ç–µ—Ä–∞–ª—ã <code>3</code> –∏ <code>7</code>. –î–ª—è –ø–æ—Å–ª–µ–¥–Ω–µ–π –≤–µ—Ç–≤–∏, –∫–æ—Ç–æ—Ä–∞—è –æ—Ö–≤–∞—Ç—ã–≤–∞–µ—Ç –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è, —à–∞–±–ª–æ–Ω–æ–º —è–≤–ª—è–µ—Ç—Å—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è, –∫–æ—Ç–æ—Ä—É—é –º—ã —Ä–µ—à–∏–ª–∏ –Ω–∞–∑–≤–∞—Ç—å <code>other</code>. –ö–æ–¥, –≤—ã–ø–æ–ª–Ω—è–µ–º—ã–π –¥–ª—è –≤–µ—Ç–∫–∏ <code>other</code>, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —ç—Ç—É –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é, –ø–µ—Ä–µ–¥–∞–≤–∞—è –µ—ë –≤ —Ñ—É–Ω–∫—Ü–∏—é <code>move_player</code>.</p>
<p>–≠—Ç–æ—Ç –∫–æ–¥ –∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è, –¥–∞–∂–µ —Ö–æ—Ç—è –º—ã –Ω–µ –ø–µ—Ä–µ—á–∏—Å–ª–∏–ª–∏ –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ —Å–ª—É—á–∞–∏: –≤—Å—ë –ø–æ—Ç–æ–º—É —á—Ç–æ –ø–æ—Å–ª–µ–¥–Ω–∏–π —à–∞–±–ª–æ–Ω –±—É–¥–µ—Ç —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–æ–≤–∞—Ç—å –≤—Å–µ–º –∑–Ω–∞—á–µ–Ω–∏—è–º, –Ω–µ —É–∫–∞–∑–∞–Ω–Ω—ã–º –≤ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º —Å–ø–∏—Å–∫–µ. –≠—Ç–æ—Ç —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π —à–∞–±–ª–æ–Ω —É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä—è–µ—Ç —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—é, —á—Ç–æ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –∏—Å—á–µ—Ä–ø—ã–≤–∞—é—â–∏–º. –û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ –º—ã –¥–æ–ª–∂–Ω—ã –ø–æ–º–µ—Å—Ç–∏—Ç—å –≤–µ—Ç–≤—å —Å —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–º —à–∞–±–ª–æ–Ω–æ–º –ø–æ—Å–ª–µ–¥–Ω–µ–π, –ø–æ—Ç–æ–º—É —á—Ç–æ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ —Å —à–∞–±–ª–æ–Ω–∞–º–∏ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –ø–æ –ø–æ—Ä—è–¥–∫—É. Rust –ø—Ä–µ–¥—É–ø—Ä–µ–¥–∏—Ç –Ω–∞—Å, –µ—Å–ª–∏ –º—ã –¥–æ–±–∞–≤–∏–º –≤–µ—Ç–≤–∏ –ø–æ—Å–ª–µ —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ–≥–æ —à–∞–±–ª–æ–Ω–∞: –¥–æ —ç—Ç–∏—Ö –≤–µ—Ç–≤–µ–π –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –¥–æ–π–¥—ë—Ç, –∞ –º—ã —è–≤–Ω–æ –Ω–µ –¥–ª—è —ç—Ç–æ–≥–æ –∏—Ö –ø–∏—à–µ–º!</p>
<p>–í Rust —Ç–∞–∫–∂–µ –µ—Å—Ç—å —à–∞–±–ª–æ–Ω, –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å, –∫–æ–≥–¥–∞ –Ω–∞–º –Ω–µ –Ω—É–∂–Ω–æ –∑–Ω–∞—á–µ–Ω–∏–µ, —Å –∫–æ—Ç–æ—Ä—ã–º —Å–≤—è–∑—ã–≤–∞–µ—Ç—Å—è —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π —à–∞–±–ª–æ–Ω: <code>_</code>. –û–Ω —è–≤–ª—è–µ—Ç—Å—è —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–º —à–∞–±–ª–æ–Ω–æ–º, –∫–æ—Ç–æ—Ä—ã–π —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –ª—é–±–æ–º—É –∑–Ω–∞—á–µ–Ω–∏—é –∏ –Ω–µ –ø—Ä–∏–≤—è–∑—ã–≤–∞–µ—Ç—Å—è –∫ –Ω–µ–º—É. –ï–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≥–æ–≤–æ—Ä–∏—Ç Rust, —á—Ç–æ –º—ã –Ω–µ —Å–æ–±–∏—Ä–∞–µ–º—Å—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ, –ø–æ—ç—Ç–æ–º—É Rust –Ω–µ –±—É–¥–µ—Ç –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–∞—Ç—å –Ω–∞—Å –æ –Ω–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π.</p>
<p>–î–∞–≤–∞–π—Ç–µ –∏–∑–º–µ–Ω–∏–º –ø—Ä–∞–≤–∏–ª–∞ –∏–≥—Ä—ã —Ç–∞–∫: –µ—Å–ª–∏ –≤—ã–ø–∞–¥–∞–µ—Ç —á—Ç–æ-—Ç–æ, –∫—Ä–æ–º–µ 3 –∏–ª–∏ 7, –Ω—É–∂–Ω–æ –ø–µ—Ä–µ–±—Ä–æ—Å–∏—Ç—å –∫–æ—Å—Ç—å. –ù–∞–º –Ω–µ –Ω—É–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –≤ –ø–æ—Å–ª–µ–¥–Ω–µ–º —Å–ª—É—á–∞–µ, –ø–æ—ç—Ç–æ–º—É –º—ã –º–æ–∂–µ–º –∏–∑–º–µ–Ω–∏—Ç—å –Ω–∞—à –∫–æ–¥, —á—Ç–æ–±—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å <code>_</code> –≤–º–µ—Å—Ç–æ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π —Å –∏–º–µ–Ω–µ–º <code>other</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        _ =&gt; reroll(),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn reroll() {}
<span class="boring">}</span></code></pre></pre>
<p>–≠—Ç–æ—Ç –ø—Ä–∏–º–µ—Ä —Ç–∞–∫–∂–µ —É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä—è–µ—Ç —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—é –∏—Å—á–µ—Ä–ø—ã–≤–∞—é—â–µ–π –ø–æ–ª–Ω–æ—Ç—ã, –ø–æ—Å–∫–æ–ª—å–∫—É –º—ã —è–≤–Ω–æ –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –≤ –ø–æ—Å–ª–µ–¥–Ω–µ–π –≤–µ—Ç–≤–∏: –ø–æ–¥—Ö–æ–¥—è—â–∏–π —à–∞–±–ª–æ–Ω –Ω–∞–π–¥—ë—Ç—Å—è –¥–ª—è –≤—Å–µ—Ö.</p>
<p>–ò–∑–º–µ–Ω–∏–º –ø—Ä–∞–≤–∏–ª–∞ –∏–≥—Ä—ã –µ—â—ë —Ä–∞–∑, —á—Ç–æ–±—ã –≤ –≤–∞—à —Ö–æ–¥ –Ω–∏—á–µ–≥–æ –Ω–µ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏–ª–æ, –µ—Å–ª–∏ –≤—ã –≤—ã–±—Ä–∞—Å—ã–≤–∞–µ—Ç–µ —á—Ç–æ-–ª–∏–±–æ –∫—Ä–æ–º–µ 3 –∏–ª–∏ 7. –ú—ã –º–æ–∂–µ–º —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —ç—Ç–æ, –∏—Å–ø–æ–ª—å–∑—É—è unit (—Ç–∏–ø –ø—É—Å—Ç–æ–≥–æ –∫–æ—Ä—Ç–µ–∂–∞, –∫–æ—Ç–æ—Ä—ã–π –º—ã —É–ø–æ–º–∏–Ω–∞–ª–∏ –≤ —Ä–∞–∑–¥–µ–ª–µ <a href="ch03-02-data-types.html#%D0%A2%D0%B8%D0%BF-%D0%BA%D0%BE%D1%80%D1%82%D0%B5%D0%B6%D0%B0">"–¢–∏–ø –∫–æ—Ä—Ç–µ–∂–∞"</a><!-- ignore -->) –Ω–∞ –º–µ—Å—Ç–µ –∫–æ–¥–∞, –∫–æ—Ç–æ—Ä—ã–π —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –≤–µ—Ç–≤–∏ <code>_</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        _ =&gt; (),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
<span class="boring">}</span></code></pre></pre>
<p>–ó–¥–µ—Å—å –º—ã —è–≤–Ω–æ –≥–æ–≤–æ—Ä–∏–º Rust, —á—Ç–æ –Ω–µ —Å–æ–±–∏—Ä–∞–µ–º—Å—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–∏–∫–∞–∫–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –æ–∫–∞–∑–∞–ª–æ—Å—å –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–º —à–∞–±–ª–æ–Ω–∞–º –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö –≤–µ—Ç–≤–µ–π, –∏ –ø—Ä–∏ —ç—Ç–æ–º –Ω–µ —Ö–æ—Ç–∏–º –∑–∞–ø—É—Å–∫–∞—Ç—å –Ω–∏–∫–∞–∫–æ–π –ø—Ä–æ—á–∏–π –∫–æ–¥.</p>
<p>–ü–æ–¥—Ä–æ–±–Ω–µ–µ –æ —à–∞–±–ª–æ–Ω–∞—Ö –∏ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–∏ –º—ã –ø–æ–≥–æ–≤–æ—Ä–∏–º –≤ <a href="ch19-00-patterns.html">–ì–ª–∞–≤–µ 19</a><!-- ignore -->. –ü–æ–∫–∞ –∂–µ –º—ã –ø–µ—Ä–µ–π–¥—ë–º –∫ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ <code>if let</code>, –∫–æ—Ç–æ—Ä–∞—è –º–æ–∂–µ—Ç –±—ã—Ç—å –ø–æ–ª–µ–∑–Ω–∞ –≤ —Å–∏—Ç—É–∞—Ü–∏—è—Ö, –∫–æ–≥–¥–∞ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ <code>match</code> —Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ—Å–ª–æ–≤–Ω–æ.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–õ–∞–∫–æ–Ω–∏—á–Ω–æ–µ-—É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ-–ø–æ—Ç–æ–∫–æ–º-—Å-if-let-–∏-let-else"><a class="header" href="#–õ–∞–∫–æ–Ω–∏—á–Ω–æ–µ-—É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ-–ø–æ—Ç–æ–∫–æ–º-—Å-if-let-–∏-let-else">–õ–∞–∫–æ–Ω–∏—á–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ—Ç–æ–∫–æ–º —Å <code>if let</code> –∏ <code>let else</code></a></h2>
<p>–°–∏–Ω—Ç–∞–∫—Å–∏—Å <code>if let</code> –ø–æ–∑–≤–æ–ª—è–µ—Ç —Å–∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞—Ç—å <code>if</code> –∏ <code>let</code> –≤ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏—é, –º–µ–Ω–µ–µ –º–Ω–æ–≥–æ—Å–ª–æ–≤–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—â—É—é –∑–Ω–∞—á–µ–Ω–∏—è, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ —Ç–æ–ª—å–∫–æ –æ–¥–Ω–æ–º—É —à–∞–±–ª–æ–Ω—É, –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –∏–≥–Ω–æ—Ä–∏—Ä—É—è –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã. –†–∞—Å—Å–º–æ—Ç—Ä–∏–º –ø—Ä–æ–≥—Ä–∞–º–º—É –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 6-6, –∫–æ—Ç–æ—Ä–∞—è –ø—Ä–æ–≤–æ–¥–∏—Ç —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è <code>Option&lt;u8&gt;</code> –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π <code>config_max</code>, –Ω–æ –∫–æ—Ç–æ—Ä–∞—è —Å–æ–±–∏—Ä–∞–µ—Ç—Å—è –≤—ã–ø–æ–ª–Ω—è—Ç—å –∫–æ–¥ —Ç–æ–ª—å–∫–æ –≤ —Ç–æ–º —Å–ª—É—á–∞–µ, –µ—Å–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ —è–≤–ª—è–µ—Ç—Å—è <code>Some</code>.</p>
<Listing number="6-6" caption="A `match` that only cares about executing code when the value is `Some`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let config_max = Some(3u8);
    match config_max {
        Some(max) =&gt; println!("–ú–∞–∫—Å–∏–º—É–º –≤—ã—Å—Ç–∞–≤–ª–µ–Ω –Ω–∞ {max}"),
        _ =&gt; (),
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>–ï—Å–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ —Ä–∞–≤–Ω–æ <code>Some</code>, –º—ã —Ä–∞—Å–ø–µ—á–∞—Ç—ã–≤–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ –≤ –≤–∞—Ä–∏–∞–Ω—Ç–µ <code>Some</code>, –ø—Ä–∏–≤—è–∑—ã–≤–∞—è –µ–≥–æ –∑–Ω–∞—á–µ–Ω–∏–µ –∫ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π <code>max</code> –≤ —à–∞–±–ª–æ–Ω–µ. –ú—ã –Ω–∏—á–µ–≥–æ –Ω–µ —Ö–æ—Ç–∏–º –¥–µ–ª–∞—Ç—å —Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º <code>None</code>. –ß—Ç–æ–±—ã —É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä–∏—Ç—å –≤—ã—Ä–∞–∂–µ–Ω–∏–µ <code>match</code>, –º—ã –¥–æ–ª–∂–Ω—ã –¥–æ–±–∞–≤–∏—Ç—å <code>_ =&gt; ()</code> –ø–æ—Å–ª–µ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–µ—Ä–≤–æ–π –∏ –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ–π –≤–µ—Ç–≤–∏. –û–¥–Ω–∞–∫–æ —Å—Ä–∞–∑—É –≤–æ–∑–Ω–∏–∫–∞–µ—Ç —á—É–≤—Å—Ç–≤–æ, —á—Ç–æ –¥–ª—è —ç—Ç–æ–π –∑–∞–¥–∞—á–∏ —Ö–æ—Ä–æ—à–æ –±—ã –∏–º–µ—Ç—å –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –ø–æ–ø—Ä–æ—â–µ –∏ –ø–æ–∫–æ—Ä–æ—á–µ.</p>
<p>–°–æ–±—Å—Ç–≤–µ–Ω–Ω–æ, –º—ã –º–æ–≥–ª–∏ –±—ã –Ω–∞–ø–∏—Å–∞—Ç—å –≤—Å—ë –±–æ–ª–µ–µ –∫—Ä–∞—Ç–∫–æ, –≤–æ—Å–ø–æ–ª—å–∑–æ–≤–∞–≤—à–∏—Å—å <code>if let</code>. –°–ª–µ–¥—É—é—â–∏–π –∫–æ–¥ –≤–µ–¥—ë—Ç —Å–µ–±—è —Ç–∞–∫ –∂–µ, –∫–∞–∫ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ <code>match</code> –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 6-6:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let config_max = Some(3u8);
    if let Some(max) = config_max {
        println!("–ú–∞–∫—Å–∏–º—É–º –≤—ã—Å—Ç–∞–≤–ª–µ–Ω –Ω–∞ {max}");
    }
<span class="boring">}</span></code></pre></pre>
<p>–°–∏–Ω—Ç–∞–∫—Å–∏—Å <code>if let</code> –ø—Ä–∏–Ω–∏–º–∞–µ—Ç —à–∞–±–ª–æ–Ω –∏ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ, —Ä–∞–∑–¥–µ–ª—ë–Ω–Ω—ã–µ –∑–Ω–∞–∫–æ–º —Ä–∞–≤–µ–Ω—Å—Ç–≤–∞. –û–Ω —Ä–∞–±–æ—Ç–∞–µ—Ç —Ç–∞–∫ –∂–µ, –∫–∞–∫ <code>match</code>, –∫–æ—Ç–æ—Ä–æ–º—É –Ω–∞ –≤—Ö–æ–¥ –ø–æ–¥–∞—é—Ç –≤—ã—Ä–∞–∂–µ–Ω–∏–µ, –æ—Ç–≤–µ—á–∞—é—â–µ–µ —à–∞–±–ª–æ–Ω—É –ø–µ—Ä–≤–æ–π –≤–µ—Ç–≤–∏. –í –¥–∞–Ω–Ω–æ–º —Å–ª—É—á–∞–µ —à–∞–±–ª–æ–Ω–æ–º —è–≤–ª—è–µ—Ç—Å—è <code>Some(max)</code>, –≥–¥–µ <code>max</code> –ø—Ä–∏–≤—è–∑—ã–≤–∞–µ—Ç—Å—è –∫ –∑–Ω–∞—á–µ–Ω–∏—é –≤–Ω—É—Ç—Ä–∏ <code>Some</code>. –ü–æ—Å–ª–µ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è, –º—ã –º–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å <code>max</code> –≤ —Ç–µ–ª–µ –±–ª–æ–∫–∞ <code>if let</code> —Ç–∞–∫ –∂–µ, –∫–∞–∫ –º—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ <code>max</code> –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–π –≤–µ—Ç–∫–µ <code>match</code>. –ö–æ–¥ –≤ –±–ª–æ–∫–µ <code>if let</code> –Ω–µ –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è, –µ—Å–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç —à–∞–±–ª–æ–Ω—É.</p>
<p>–ò—Å–ø–æ–ª—å–∑—É—è <code>if let</code>, –º—ã –ø–µ—á–∞—Ç–∞–µ–º –º–µ–Ω—å—à–µ, –¥–µ–ª–∞–µ–º –º–µ–Ω—å—à–µ –æ—Ç—Å—Ç—É–ø–æ–≤ –∏ –ø–æ–ª—É—á–∞–µ–º –º–µ–Ω—å—à–µ –ø–æ–≤—Ç–æ—Ä—è—é—â–µ–≥–æ—Å—è –∫–æ–¥–∞. –¢–µ–º –Ω–µ –º–µ–Ω–µ–µ, –º—ã —Ç–µ—Ä—è–µ–º –ø–æ–ª–Ω—É—é –ø—Ä–æ–≤–µ—Ä–∫—É –≤—Å–µ—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ–º—É—é –≤—ã—Ä–∞–∂–µ–Ω–∏–µ–º <code>match</code>. –í—ã–±–æ—Ä –º–µ–∂–¥—É <code>match</code> –∏ <code>if let</code> –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Ç–æ–≥–æ, —á—Ç–æ –≤—ã –¥–µ–ª–∞–µ—Ç–µ –≤ –≤–∞—à–µ–º –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º —Å–ª—É—á–∞–µ –∏ —É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä—è–µ—Ç –ª–∏ –≤–∞—Å –ø–æ—Ç–µ—Ä—è –ø–æ–ª–Ω–æ—Ç—ã —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è —Ä–∞–¥–∏ –ª–∞–∫–æ–Ω–∏—á–Ω–æ—Å—Ç–∏.</p>
<p>–î—Ä—É–≥–∏–º–∏ —Å–ª–æ–≤–∞–º–∏, –≤—ã –º–æ–∂–µ—Ç–µ –¥—É–º–∞—Ç—å –æ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ <code>if let</code> –∫–∞–∫ –æ —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–æ–º —Å–∞—Ö–∞—Ä–µ –¥–ª—è <code>match</code>, –≤—ã–ø–æ–ª–Ω—è—é—â–µ–º –∫–æ–¥, –µ—Å–ª–∏ –≤—Ö–æ–¥–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –±—É–¥–µ—Ç –æ—Ç–≤–µ—á–∞—Ç—å –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ–º—É —à–∞–±–ª–æ–Ω—É, –∏ –ø—Ä–æ–∏–≥–Ω–æ—Ä–∏—Ä—É–µ—Ç –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è.</p>
<p>–ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–ª—è—Ç—å <code>else</code> –∫ <code>if let</code>. –ë–ª–æ–∫ –∫–æ–¥–∞, –∫–æ—Ç–æ—Ä—ã–π –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤–Ω—É—Ç—Ä–∏ <code>else</code>, –∞–Ω–∞–ª–æ–≥–∏—á–µ–Ω –ø–æ —Å–º—ã—Å–ª—É –±–ª–æ–∫—É –∫–æ–¥–∞ –≤–µ—Ç–≤–∏ –≤—ã—Ä–∞–∂–µ–Ω–∏—è <code>match</code> (–µ—Å–ª–∏ –æ–Ω–æ —ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–Ω–æ —Å–±–æ—Ä–Ω–æ–π –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ <code>if let</code> –∏ <code>else</code>), —Å–≤—è–∑–∞–Ω–Ω–æ–π —Å —à–∞–±–ª–æ–Ω–æ–º <code>_</code>. –í—Å–ø–æ–º–Ω–∏–º –æ–±—ä—è–≤–ª–µ–Ω–∏–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è <code>Coin</code> –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 6-4, –≥–¥–µ –≤–∞—Ä–∏–∞–Ω—Ç <code>Quarter</code> —Ç–∞–∫–∂–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –≤–Ω—É—Ç—Ä–∏ —Å–µ–±—è –∑–Ω–∞—á–µ–Ω–∏–µ —à—Ç–∞—Ç–∞ —Ç–∏–ø–∞ <code>UsState</code>. –ï—Å–ª–∏ –±—ã –º—ã —Ö–æ—Ç–µ–ª–∏ –ø–æ—Å—á–∏—Ç–∞—Ç—å –≤—Å–µ –º–æ–Ω–µ—Ç—ã, –Ω–µ —è–≤–ª—è—é—â–∏–µ—Å—è —á–µ—Ç–≤–µ—Ä—Ç–∞–∫–∞–º–∏, –∞ –¥–ª—è —á–µ—Ç–≤–µ—Ä—Ç–∞–∫–æ–≤ –ª–∏—à—å –ø–µ—á–∞—Ç–∞—Ç—å –Ω–∞–∑–≤–∞–Ω–∏–µ —à—Ç–∞—Ç–∞, —Ç–æ —Å –ø–æ–º–æ—â—å—é –≤—ã—Ä–∞–∂–µ–Ω–∏—è <code>match</code> –º—ã –º–æ–≥–ª–∏ –±—ã —Å–¥–µ–ª–∞—Ç—å —ç—Ç–æ —Ç–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let coin = Coin::Penny;
</span>    let mut count = 0;
    match coin {
        Coin::Quarter(state) =&gt; println!("–ß–µ—Ç–≤–µ—Ä—Ç–∞–∫ –∏–∑ —à—Ç–∞—Ç–∞ {state:?}!"),
        _ =&gt; count += 1,
    }
<span class="boring">}</span></code></pre></pre>
<p>–ò–ª–∏ –º—ã –º–æ–≥–ª–∏ –±—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤—ã—Ä–∞–∂–µ–Ω–∏–µ <code>if let</code> –∏ <code>else</code>; –≤–æ—Ç —Ç–∞–∫:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let coin = Coin::Penny;
</span>    let mut count = 0;
    if let Coin::Quarter(state) = coin {
        println!("–ß–µ—Ç–≤–µ—Ä—Ç–∞–∫ –∏–∑ —à—Ç–∞—Ç–∞ {state:?}!");
    } else {
        count += 1;
    }
<span class="boring">}</span></code></pre></pre>
<h2 id="–ö—Ä–∞—Å–∏–≤—ã–π-–≤—ã—Ö–æ–¥-–ø—Ä–∏-–æ—à–∏–±–∫–æ–æ–ø–∞—Å–Ω—ã—Ö-–∑–Ω–∞—á–µ–Ω–∏—è—Ö-—Å-–ø–æ–º–æ—â—å—é-let-else"><a class="header" href="#–ö—Ä–∞—Å–∏–≤—ã–π-–≤—ã—Ö–æ–¥-–ø—Ä–∏-–æ—à–∏–±–∫–æ–æ–ø–∞—Å–Ω—ã—Ö-–∑–Ω–∞—á–µ–Ω–∏—è—Ö-—Å-–ø–æ–º–æ—â—å—é-let-else">–ö—Ä–∞—Å–∏–≤—ã–π –≤—ã—Ö–æ–¥ –ø—Ä–∏ –æ—à–∏–±–∫–æ–æ–ø–∞—Å–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏—è—Ö —Å –ø–æ–º–æ—â—å—é <code>let else</code></a></h2>
<p>–û–¥–Ω–∞ –∏–∑ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—ë–Ω–Ω—ã—Ö –∑–∞–¥–∞—á –∑–∞–∫–ª—é—á–∞–µ—Ç—Å—è –≤ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –≤—ã—á–∏—Å–ª–µ–Ω–∏–π (–ø—Ä–∏ –Ω–∞–ª–∏—á–∏–∏ –∑–Ω–∞—á–µ–Ω–∏—è) –∏ –≤–æ–∑–≤—Ä–∞—Ç–µ –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é (–≤ –ø—Ä–æ—Ç–∏–≤–Ω–æ–º —Å–ª—É—á–∞–µ). –ü—Ä–æ–¥–æ–ª–∂–∞—è –Ω–∞—à –ø—Ä–∏–º–µ—Ä —Å –º–æ–Ω–µ—Ç–∞–º–∏ —Å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º <code>UsState</code>: –µ—Å–ª–∏ –±—ã –º—ã —Ö–æ—Ç–µ–ª–∏ —Å–∫–∞–∑–∞—Ç—å —á—Ç–æ-—Ç–æ –∑–∞–±–∞–≤–Ω–æ–µ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–æ–≥–æ, –Ω–∞—Å–∫–æ–ª—å–∫–æ —Å—Ç–∞—Ä —à—Ç–∞—Ç –Ω–∞ –º–æ–Ω–µ—Ç–µ, –º—ã –º–æ–≥–ª–∏ –±—ã –Ω–∞–ø–∏—Å–∞—Ç—å –º–µ—Ç–æ–¥ –¥–ª—è —Ç–∏–ø–∞ <code>UsState</code>, –∫–æ—Ç–æ—Ä—ã–π –æ—Å—É—â–µ—Å—Ç–≤–ª—è–µ—Ç –ø—Ä–æ–≤–µ—Ä–∫—É –≤–æ–∑—Ä–∞—Å—Ç–∞ —à—Ç–∞—Ç–∞; –Ω–∞–ø—Ä–∏–º–µ—Ä, —Ç–∞–∫:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)] // –Ω—É–∂–Ω–æ, —á—Ç–æ–±—ã –º—ã –º–æ–≥–ª–∏ –ª–µ–≥–∫–æ –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —à—Ç–∞—Ç
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
</span><span class="boring">}
</span><span class="boring">
</span>impl UsState {
    fn existed_in(&amp;self, year: u16) -&gt; bool {
        match self {
            UsState::Alabama =&gt; year &gt;= 1819,
            UsState::Alaska =&gt; year &gt;= 1959,
            // -- –∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω --
        }
    }
}
<span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn describe_state_quarter(coin: Coin) -&gt; Option&lt;String&gt; {
</span><span class="boring">    if let Coin::Quarter(state) = coin {
</span><span class="boring">        if state.existed_in(1900) {
</span><span class="boring">            Some(format!("–®—Ç–∞—Ç {state:?} –¥–æ–≤–æ–ª—å–Ω–æ —Å—Ç–∞—Ä–æ–≤–∞—Ç –¥–ª—è –ê–º–µ—Ä–∏–∫–∏!"))
</span><span class="boring">        } else {
</span><span class="boring">            Some(format!("–®—Ç–∞—Ç {state:?} –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –º–æ–ª–æ–¥–æ–π."))
</span><span class="boring">        }
</span><span class="boring">    } else {
</span><span class="boring">        None
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    if let Some(desc) = describe_state_quarter(Coin::Quarter(UsState::Alaska)) {
</span><span class="boring">        println!("{desc}");
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<p>–ó–∞—Ç–µ–º –º—ã –º–æ–≥–ª–∏ –±—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å <code>if let</code>, —á—Ç–æ–±—ã –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å –æ—Å–æ–±–µ–Ω–Ω—ã–π –≤—ã–≤–æ–¥, –µ—Å–ª–∏ —Å—Ç–∞–ª–∫–∏–≤–∞–µ–º—Å—è —Å —á–µ—Ç–≤–µ—Ä—Ç–∞–∫–æ–º. –î–ª—è —ç—Ç–æ–≥–æ –Ω–∞–º —Ç–∞–∫–∂–µ –ø–æ–Ω–∞–¥–æ–±–∏—Ç—Å—è –≤–≤–µ—Å—Ç–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é <code>state</code>, –∫–æ—Ç–æ—Ä–∞—è –±—É–¥–µ—Ç —Å–≤—è–∑—ã–≤–∞—Ç—å—Å—è —Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º —à—Ç–∞—Ç–∞. –í–∑–≥–ª—è–Ω–∏—Ç–µ –Ω–∞ –õ–∏—Å—Ç–∏–Ω–≥ 6-7:</p>
<Listing number="6-7" caption="Using" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)] // –Ω—É–∂–Ω–æ, —á—Ç–æ–±—ã –º—ã –º–æ–≥–ª–∏ –ª–µ–≥–∫–æ –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —à—Ç–∞—Ç
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl UsState {
</span><span class="boring">    fn existed_in(&amp;self, year: u16) -&gt; bool {
</span><span class="boring">        match self {
</span><span class="boring">            UsState::Alabama =&gt; year &gt;= 1819,
</span><span class="boring">            UsState::Alaska =&gt; year &gt;= 1959,
</span><span class="boring">            // -- –∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω --
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn describe_state_quarter(coin: Coin) -&gt; Option&lt;String&gt; {
    if let Coin::Quarter(state) = coin {
        if state.existed_in(1900) {
            Some(format!("–®—Ç–∞—Ç {state:?} –¥–æ–≤–æ–ª—å–Ω–æ —Å—Ç–∞—Ä–æ–≤–∞—Ç –¥–ª—è –ê–º–µ—Ä–∏–∫–∏!"))
        } else {
            Some(format!("–®—Ç–∞—Ç {state:?} –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –º–æ–ª–æ–¥–æ–π."))
        }
    } else {
        None
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    if let Some(desc) = describe_state_quarter(Coin::Quarter(UsState::Alaska)) {
</span><span class="boring">        println!("{desc}");
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>–≠—Ç–æ–≥–æ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–ª—è –∂–µ–ª–∞–µ–º–æ–≥–æ –Ω–∞–º–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞. –û–¥–Ω–∞–∫–æ –Ω–∞–º –ø—Ä–∏—à–ª–æ—Å—å –ø–æ–º–µ—Å—Ç–∏—Ç—å –≤—Å—é —Ä–∞–±–æ—Ç—É –∫–æ–¥–∞ –≤ —Ç–µ–ª–æ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ <code>if let</code>. –ï—Å–ª–∏ —Ä–∞–±–æ—Ç–∞, –∫–æ—Ç–æ—Ä—É—é –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –≤—ã–ø–æ–ª–Ω–∏—Ç—å, –æ–∫–∞–∂–µ—Ç—Å—è –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω–æ–π, –º–æ–∂–µ—Ç –±—ã—Ç—å —Ç—Ä—É–¥–Ω–æ —Ä–∞—Å–ø—É—Ç–∞—Ç—å, –∫ —á–µ–º—É –∏–º–µ–Ω–Ω–æ –æ—Ç–Ω–æ—Å—è—Ç—Å—è –≤–ª–æ–∂–µ–Ω–Ω—ã–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä—ã <code>if</code> –∏ <code>else</code>. –ú—ã –º–æ–≥–ª–∏ –±—ã —Ä–µ—à–∏—Ç—å –Ω–∞—à—É –∑–∞–¥–∞—á—É –∏ –∏–Ω–∞—á–µ: –≤–æ—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è —Ç–µ–º —Ñ–∞–∫—Ç–æ–º, —á—Ç–æ –≤—ã—Ä–∞–∂–µ–Ω–∏—è –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç –∑–Ω–∞—á–µ–Ω–∏—è, —á—Ç–æ–±—ã –≤–µ—Ä–Ω—É—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π <code>state</code> –∏–∑ <code>if let</code> (–ª–∏–±–æ —Å—Ä–∞–∑—É, –Ω–µ –¥–æ–∂–∏–¥–∞—è—Å—å, –≤–µ—Ä–Ω—É—Ç—å –≤ –±–ª–æ–∫–µ <code>else</code> –∑–Ω–∞—á–µ–Ω–∏–µ <code>None</code>, –µ—Å–ª–∏ –º—ã –ø–æ–ª—É—á–∏–ª–∏ –Ω–µ —á–µ—Ç–≤–µ—Ä—Ç–∞–∫). –≠—Ç–æ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ –ø—Ä–∏–≤–µ–¥–µ–Ω–æ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 6-8. (–í—ã –º–æ–≥–ª–∏ –±—ã –Ω–∞–ø–∏—Å–∞—Ç—å –≤—Å—ë –∏ —á–µ—Ä–µ–∑ <code>match</code>, –∫–æ–Ω–µ—á–Ω–æ –∂–µ!)</p>
<Listing number="6-8" caption="Using `if let` to produce a value or return early." file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)] // –Ω—É–∂–Ω–æ, —á—Ç–æ–±—ã –º—ã –º–æ–≥–ª–∏ –ª–µ–≥–∫–æ –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —à—Ç–∞—Ç
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl UsState {
</span><span class="boring">    fn existed_in(&amp;self, year: u16) -&gt; bool {
</span><span class="boring">        match self {
</span><span class="boring">            UsState::Alabama =&gt; year &gt;= 1819,
</span><span class="boring">            UsState::Alaska =&gt; year &gt;= 1959,
</span><span class="boring">            // -- –∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω --
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn describe_state_quarter(coin: Coin) -&gt; Option&lt;String&gt; {
    let state = if let Coin::Quarter(state) = coin {
        state
    } else {
        return None;
    };

    if state.existed_in(1900) {
        Some(format!("–®—Ç–∞—Ç {state:?} –¥–æ–≤–æ–ª—å–Ω–æ —Å—Ç–∞—Ä–æ–≤–∞—Ç –¥–ª—è –ê–º–µ—Ä–∏–∫–∏!"))
    } else {
        Some(format!("–®—Ç–∞—Ç {state:?} –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –º–æ–ª–æ–¥–æ–π."))
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    if let Some(desc) = describe_state_quarter(Coin::Quarter(UsState::Alaska)) {
</span><span class="boring">        println!("{desc}");
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>–û–¥–Ω–∞–∫–æ –∏ —ç—Ç–æ —Ä–µ—à–µ–Ω–∏–µ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ä–∞–∑–¥—Ä–∞–∂–∞–µ—Ç, –ø–æ—Å–∫–æ–ª—å–∫—É –∫–∞–∂–¥–∞—è –≤–µ—Ç–≤—å <code>if let</code> –≤–µ–¥—ë—Ç —Å–µ–±—è —Å–æ–≤–µ—Ä—à–µ–Ω–Ω–æ –ø–æ-—Å–≤–æ–µ–º—É! –û–¥–Ω–∞ –≤–µ—Ç–≤—å –ª–∏—à—å –≤—ã—á–∏—Å–ª—è–µ—Ç—Å—è –≤ –∑–Ω–∞—á–µ–Ω–∏–µ, –∞ –¥—Ä—É–≥–∞—è –ø—Ä–µ—Ä—ã–≤–∞–µ—Ç –≤—Å—é —Ñ—É–Ω–∫—Ü–∏—é –∏ —Å—Ä–∞–∑—É –∏–∑ –Ω–µ—ë —á—Ç–æ-—Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç.</p>
<p>–î–ª—è —É–ø—Ä–æ—â–µ–Ω–∏—è –ø–æ–¥–æ–±–Ω—ã—Ö –≤—ã—Ä–∞–∂–µ–Ω–∏–π –≤ Rust –µ—Å—Ç—å <code>let</code>-<code>else</code>. –ö–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ <code>let</code>-<code>else</code> –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è—é—Ç—Å—è —à–∞–±–ª–æ–Ω —Å–ª–µ–≤–∞ –∏ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ —Å–ø—Ä–∞–≤–∞ (—á—Ç–æ –æ—á–µ–Ω—å –ø–æ—Ö–æ–∂–µ –Ω–∞ <code>if let</code> ‚Äî –Ω–æ —É <code>let</code>-<code>else</code> –Ω–µ—Ç –≤–µ—Ç–≤–∏ <code>if</code>, –ª–∏—à—å <code>else</code>). –ï—Å–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ —Å–æ–ø–æ—Å—Ç–∞–≤–∏—Ç—Å—è, —Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ —à–∞–±–ª–æ–Ω–∞ —Å–≤—è–∂–µ—Ç—Å—è —Å –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –∏–∑ –≤–Ω–µ—à–Ω–µ–π –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏. –ï—Å–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–µ —Å–æ–ø–æ—Å—Ç–∞–≤–∏—Ç—Å—è, –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ –ø–µ—Ä–µ–π–¥—ë—Ç –≤ –≤–µ—Ç–≤—å <code>else</code>, –∫–æ—Ç–æ—Ä–∞—è –¥–æ–ª–∂–Ω–∞ –≤–µ—Ä–Ω—É—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ —Ñ—É–Ω–∫—Ü–∏–∏.</p>
<p>–í –õ–∏—Å—Ç–∏–Ω–≥–µ 6-9 –≤—ã –º–æ–∂–µ—Ç–µ —É–≤–∏–¥–µ—Ç—å, –∫–∞–∫ –≤—ã–≥–ª—è–¥–∏—Ç –õ–∏—Å—Ç–∏–Ω–≥ 6-8 —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º <code>let</code>-<code>else</code> –≤–º–µ—Å—Ç–æ <code>if let</code>. –û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ —Ç–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, –º—ã –≤—ã–Ω–æ—Å–∏–º –≤—Å—é –æ–±—Ä–∞–±–æ—Ç–∫—É –æ—Å–æ–±—ã—Ö —Å–ª—É—á–∞–µ–≤ –≤ –Ω–∞—á–∞–ª–æ —Ñ—É–Ω–∫—Ü–∏–∏, –∞ –≤–µ—Å—å –µ—ë –ø–æ—Å–ª–µ–¥—É—é—â–∏–π –æ—Å—Ç–∞—Ç–æ–∫ —Å–ø–æ–∫–æ–π–Ω–æ –±—É–¥–µ—Ç –¥–µ–ª–∞—Ç—å —Å–∞–º—É—é –≤–∞–∂–Ω—É—é —Ä–∞–±–æ—Ç—É, –±–µ–∑ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –æ—Ç–≤–ª–µ–∫–∞—Ç—å—Å—è –Ω–∞ —á—Ç–æ-–ª–∏–±–æ –µ—â—ë. –° <code>if let</code> –Ω–∞—à –ø–æ—Ç–æ–∫ –ø—Ä–∏—à–ª–æ—Å—å –¥–µ–ª–∏—Ç—å –Ω–∞ –¥–≤–µ –≤–µ—Ç–≤–∏, –∏ —Ç–æ–ª—å–∫–æ –æ–¥–Ω–∞ –∏–∑ –Ω–∏—Ö –≤—ã–ø–æ–ª–Ω—è–ª–∞ –Ω–∞—Å—Ç–æ—è—â—É—é —Ä–∞–±–æ—Ç—É.</p>
<Listing number="6-9" caption="Using `let`-`else` to clarify the flow through the function." file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)] // –Ω—É–∂–Ω–æ, —á—Ç–æ–±—ã –º—ã –º–æ–≥–ª–∏ –ª–µ–≥–∫–æ –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —à—Ç–∞—Ç
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl UsState {
</span><span class="boring">    fn existed_in(&amp;self, year: u16) -&gt; bool {
</span><span class="boring">        match self {
</span><span class="boring">            UsState::Alabama =&gt; year &gt;= 1819,
</span><span class="boring">            UsState::Alaska =&gt; year &gt;= 1959,
</span><span class="boring">            // -- –∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω --
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn describe_state_quarter(coin: Coin) -&gt; Option&lt;String&gt; {
    let Coin::Quarter(state) = coin else {
        return None;
    };

    if state.existed_in(1900) {
        Some(format!("–®—Ç–∞—Ç {state:?} –¥–æ–≤–æ–ª—å–Ω–æ —Å—Ç–∞—Ä–æ–≤–∞—Ç –¥–ª—è –ê–º–µ—Ä–∏–∫–∏!"))
    } else {
        Some(format!("–®—Ç–∞—Ç {state:?} –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –º–æ–ª–æ–¥–æ–π."))
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    if let Some(desc) = describe_state_quarter(Coin::Quarter(UsState::Alaska)) {
</span><span class="boring">        println!("{desc}");
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>–ï—Å–ª–∏ —É –≤–∞—Å –≤–æ–∑–Ω–∏–∫–ª–∞ —Å–∏—Ç—É–∞—Ü–∏—è, –≤ –∫–æ—Ç–æ—Ä–æ–π –ª–æ–≥–∏–∫–∞ –≤–∞—à–µ–π –ø—Ä–æ–≥—Ä–∞–º–º—ã —Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ—Å–ª–æ–≤–Ω–∞, –µ—Å–ª–∏ –≤—ã—Ä–∞–∂–∞—Ç—å –µ—ë —á–µ—Ä–µ–∑ <code>match</code>, –ø–æ–º–Ω–∏—Ç–µ –æ —Ç–æ–º, —á—Ç–æ –≤ –≤–∞—à–µ–º –∞—Ä—Å–µ–Ω–∞–ª–µ –µ—Å—Ç—å –µ—â—ë <code>if let</code> –∏ <code>let else</code>.</p>
<h2 id="–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-5"><a class="header" href="#–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-5">–ü–æ–¥–≤–µ–¥—ë–º –∏—Ç–æ–≥–∏</a></h2>
<p>–ú—ã —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–ª–∏, –∫–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö —Ç–∏–ø–æ–≤, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—â–∏–π –ø–µ—Ä–µ—á–µ–Ω—å –≤–æ–∑–º–æ–∂–Ω—ã—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤. –ú—ã –ø–æ–∫–∞–∑–∞–ª–∏, –∫–∞–∫ —Ç–∏–ø —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ <code>Option&lt;T&gt;</code> –ø–æ–º–æ–≥–∞–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å–∏—Å—Ç–µ–º—É —Ç–∏–ø–æ–≤ –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –æ—à–∏–±–æ–∫. –ï—Å–ª–∏ –≤–∞—Ä–∏–∞–Ω—Ç—ã –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –∏–º–µ—é—Ç –¥–∞–Ω–Ω—ã–µ –≤–Ω—É—Ç—Ä–∏ –Ω–∏—Ö, –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å <code>match</code> –∏–ª–∏ <code>if let</code> (—Å–º–æ—Ç—Ä—è, —Å–∫–æ–ª—å–∫–æ —Å–ª—É—á–∞–µ–≤ –≤–∞–º –Ω—É–∂–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å), —á—Ç–æ–±—ã –∏–∑–≤–ª–µ—á—å –∏—Ö –∏ –≤–æ—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –∏–º–∏.</p>
<p>–¢–µ–ø–µ—Ä—å –≤–∞—à–∏ –ø—Ä–æ–≥—Ä–∞–º–º—ã –Ω–∞ Rust –º–æ–≥—É—Ç –≤—ã—Ä–∞–∂–∞—Ç—å –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏ –≤–∞—à–µ–π –ø—Ä–µ–¥–º–µ—Ç–Ω–æ–π –æ–±–ª–∞—Å—Ç–∏, –∏—Å–ø–æ–ª—å–∑—É—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –∏ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è. –°–æ–∑–¥–∞–Ω–∏–µ –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö —Ç–∏–ø–æ–≤ –≤ –≤–∞—à–µ–º API –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç —Ç–∏–ø–æ–±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å: –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –ø–æ–∑–∞–±–æ—Ç–∏—Ç—Å—è –æ —Ç–æ–º, —á—Ç–æ–±—ã —Ñ—É–Ω–∫—Ü–∏–∏ –ø–æ–ª—É—á–∞–ª–∏ –∑–Ω–∞—á–µ–Ω–∏—è —Ç–æ–ª—å–∫–æ —Ç–æ–≥–æ —Ç–∏–ø–∞, –∫–æ—Ç–æ—Ä—ã–π –æ–Ω–∏ –æ–∂–∏–¥–∞—é—Ç.</p>
<p>–¢–µ–ø–µ—Ä—å –ø—Ä–∏—à–ª–∞ –ø–æ–∫–∞ –ø–æ–≥–æ–≤–æ—Ä–∏—Ç—å –æ –º–æ–¥—É–ª—è—Ö –≤ Rust. –û–Ω–∏ –Ω—É–∂–Ω—ã, —á—Ç–æ–±—ã –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º –≤–∞—à–µ–≥–æ –∫–æ–¥–∞ —Ö–æ—Ä–æ—à–æ –æ—Ä–≥–∞–Ω–∏–∑–æ–≤–∞–Ω–Ω—ã–π API, –∫–æ—Ç–æ—Ä—ã–π –ø—Ä–æ—Å—Ç –≤ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ –∏ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç —Ç–æ–ª—å–∫–æ —Ç–æ, —á—Ç–æ –Ω—É–∂–Ω–æ.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="–£–ø–∞—Ä–≤–ª–µ–Ω–∏–µ-—Ä–∞–∑—Ä–∞—Å—Ç–∞—é—â–∏–º–∏—Å—è-–ø—Ä–æ–µ–∫—Ç–∞–º–∏-—Å-–ø–æ–º–æ—â—å—é-–ø–∞–∫–µ—Ç–æ–≤-–∫—Ä–µ–π—Ç–æ–≤-–∏-–º–æ–¥—É–ª–µ–π"><a class="header" href="#–£–ø–∞—Ä–≤–ª–µ–Ω–∏–µ-—Ä–∞–∑—Ä–∞—Å—Ç–∞—é—â–∏–º–∏—Å—è-–ø—Ä–æ–µ–∫—Ç–∞–º–∏-—Å-–ø–æ–º–æ—â—å—é-–ø–∞–∫–µ—Ç–æ–≤-–∫—Ä–µ–π—Ç–æ–≤-–∏-–º–æ–¥—É–ª–µ–π">–£–ø–∞—Ä–≤–ª–µ–Ω–∏–µ —Ä–∞–∑—Ä–∞—Å—Ç–∞—é—â–∏–º–∏—Å—è –ø—Ä–æ–µ–∫—Ç–∞–º–∏ —Å –ø–æ–º–æ—â—å—é –ø–∞–∫–µ—Ç–æ–≤, –∫—Ä–µ–π—Ç–æ–≤ –∏ –º–æ–¥—É–ª–µ–π</a></h1>
<p>–ü–æ –º–µ—Ä–µ —Ä–æ—Å—Ç–∞ –∫–æ–¥–æ–≤–æ–π –±–∞–∑—ã –≤–∞—à–∏—Ö –ø—Ä–æ–≥—Ä–∞–º–º, –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è –∫–æ–¥–∞ –±—É–¥–µ—Ç –ø–æ–ª—É—á–∞—Ç—å –≤—Å—ë –±–æ–ª—å—à—É—é –≤–∞–∂–Ω–æ—Å—Ç—å. –ì—Ä—É–ø–ø–∏—Ä—É—è —Å–≤—è–∑–∞–Ω–Ω–æ–µ –∏ —Ä–∞–∑–¥–µ–ª—è—è –∫–æ–¥ –ø–æ —Ä–æ–¥—É –¥–µ—è—Ç–µ–ª—å–Ω–æ—Å—Ç–∏, –≤—ã –¥–µ–ª–∞–µ—Ç–µ –±–æ–ª–µ–µ –ø–æ–Ω—è—Ç–Ω—ã–º, –≥–¥–µ –∏—Å–∫–∞—Ç—å –∫–æ–¥, —Ä–µ–∞–ª–∏–∑—É—é—â–∏–π –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—É—é –∑–∞–¥–∞—á—É, –∏ –≥–¥–µ –Ω—É–∂–Ω–æ –≤–Ω–æ—Å–∏—Ç—å –ø—Ä–∞–≤–∫–∏, –∏–∑–º–µ–Ω—è—é—â–∏–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ.</p>
<p>–ü—Ä–æ–≥—Ä–∞–º–º—ã, –∫–æ—Ç–æ—Ä—ã–µ –º—ã –ø–∏—Å–∞–ª–∏ –¥–æ —Å–∏—Ö –ø–æ—Ä, —Ä–∞—Å–ø–æ–ª–∞–≥–∞–ª–∏—Å—å –≤ –æ–¥–Ω–æ–º —Ñ–∞–π–ª–µ –æ–¥–Ω–æ–≥–æ –º–æ–¥—É–ª—è. –ü–æ –º–µ—Ä–µ —Ä–æ—Å—Ç–∞ –ø—Ä–æ–µ–∫—Ç–∞, –º—ã –º–æ–∂–µ–º –æ—Ä–≥–∞–Ω–∏–∑–æ–≤—ã–≤–∞—Ç—å –∫–æ–¥ –∏–Ω–∞—á–µ, —Ä–∞–∑–¥–µ–ª—è—è –µ–≥–æ –Ω–∞ –Ω–µ—Å–∫–æ–ª—å–∫–æ –º–æ–¥—É–ª–µ–π –∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ñ–∞–π–ª–æ–≤. –ü–∞–∫–µ—Ç –º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –±–∏–Ω–∞—Ä–Ω—ã—Ö –∫—Ä–µ–π—Ç–æ–≤ –∏ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ) –æ–¥–∏–Ω –±–∏–±–ª–∏–æ—Ç–µ—á–Ω—ã–π –∫—Ä–µ–π—Ç. –ü–æ –º–µ—Ä–µ —Ä–æ—Å—Ç–∞ –ø–∞–∫–µ—Ç–∞, –≤—ã –º–æ–∂–µ—Ç–µ –≤—ã–Ω–æ—Å–∏—Ç—å —á–∞—Å—Ç–∏ –ø—Ä–æ–≥—Ä–∞–º–º—ã –≤ –æ—Ç–¥–µ–ª—å–Ω—ã–µ –∫—Ä–µ–π—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –∑–∞—Ç–µ–º —Å—Ç–∞–Ω—É—Ç –≤–Ω–µ—à–Ω–∏–º–∏ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—è–º–∏ –¥–ª—è –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –∫–æ–¥–∞ –Ω–∞—à–µ–π –ø—Ä–æ–≥—Ä–∞–º–º—ã. –≠—Ç–∞ –≥–ª–∞–≤–∞ –æ—Ö–≤–∞—Ç—ã–≤–∞–µ—Ç –≤—Å–µ —ç—Ç–∏ —Ç–µ—Ö–Ω–∏–∫–∏. –î–ª—è –æ—á–µ–Ω—å –∫—Ä—É–ø–Ω—ã—Ö –ø—Ä–æ–µ–∫—Ç–æ–≤, —Å–æ—Å—Ç–æ—è—â–∏—Ö –∏–∑ –Ω–∞–±–æ—Ä–∞ –≤–∑–∞–∏–º–æ—Å–≤—è–∑–∞–Ω–Ω—ã—Ö –ø–∞–∫–µ—Ç–æ–≤, —Ä–∞–∑–≤–∏–≤–∞—é—â–∏—Ö—Å—è –≤–º–µ—Å—Ç–µ, Cargo –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç <em>—Ä–∞–±–æ—á–∏–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞</em>; –º—ã —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º –∏—Ö –≤ —Ä–∞–∑–¥–µ–ª–µ <a href="ch14-03-cargo-workspaces.html">"–†–∞–±–æ—á–∏–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞ Cargo"</a><!-- ignore -->  –ì–ª–∞–≤—ã 14.</p>
<p>–ú—ã —Ç–∞–∫–∂–µ –æ–±—Å—É–¥–∏–º —Å–æ–∫—Ä—ã—Ç–∏–µ –ø–æ–¥—Ä–æ–±–Ω–æ—Å—Ç–µ–π, –∫–æ—Ç–æ—Ä–∞—è –ø–æ–∑–≤–æ–ª—è–µ—Ç –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–æ–¥ –Ω–∞ –±–æ–ª–µ–µ –≤—ã—Å–æ–∫–æ–º —É—Ä–æ–≤–Ω–µ: –µ–¥–∏–Ω–æ–∂–¥—ã —Ä–µ–∞–ª–∏–∑–æ–≤–∞–≤ –∫–∞–∫—É—é-—Ç–æ –æ–ø–µ—Ä–∞—Ü–∏—é, –¥—Ä—É–≥–æ–π –∫–æ–¥ –º–æ–∂–µ—Ç –≤—ã–∑—ã–≤–∞—Ç—å —ç—Ç–æ—Ç –∫–æ–¥ —á–µ—Ä–µ–∑ –ø—É–±–ª–∏—á–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å, –Ω–µ –≤–¥–∞–≤–∞—è—Å—å –≤ –¥–µ—Ç–∞–ª–∏ —Ä–∞–±–æ—Ç—ã. –¢–æ, –∫–∞–∫ –≤—ã –ø–∏—à–µ—Ç–µ –∫–æ–¥, –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç, –∫–∞–∫–∏–µ —á–∞—Å—Ç–∏ –¥–æ—Å—Ç—É–ø–Ω—ã –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –¥—Ä—É–≥–∏–º –∫–æ–¥–æ–º, –∞ –∫–∞–∫–∏–µ —á–∞—Å—Ç–∏ —è–≤–ª—è—é—Ç—Å—è –∑–∞–∫—Ä—ã—Ç—ã–º–∏ –¥–µ—Ç–∞–ª—è–º–∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏, –ø—Ä–∞–≤–æ –∏–∑–º–µ–Ω–µ–Ω–∏—è –∫–æ—Ç–æ—Ä—ã—Ö –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç –ª–∏—à—å –≤–∞–º. –≠—Ç–æ ‚Äî –µ—â—ë –æ–¥–∏–Ω —Å–ø–æ—Å–æ–± –æ–≥—Ä–∞–Ω–∏—á–∏—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–µ—Ç–∞–ª–µ–π, –∫–æ—Ç–æ—Ä—ã–µ –≤—ã –¥–æ–ª–∂–Ω—ã –¥–µ—Ä–∂–∞—Ç—å –≤ –≥–æ–ª–æ–≤–µ.</p>
<p>–ë–ª–∏–∑–∫–æ–µ –∫ –Ω–∞—à–µ–π —Ç–µ–∫—É—â–µ–π —Ç–µ–º–µ –ø–æ–Ω—è—Ç–∏–µ ‚Äî —ç—Ç–æ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏: –≤–ª–æ–∂–µ–Ω–Ω—ã–π –±–ª–æ–∫, –≤ –∫–æ—Ç–æ—Ä–æ–º –Ω–∞–ø–∏—Å–∞–Ω –∫–æ–¥, –∏–º–µ—é—â–∏–π –Ω–∞–±–æ—Ä –∏–º—ë–Ω, –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã—Ö —Ç–æ–ª—å–∫–æ –≤ —ç—Ç–æ–π –æ–±–ª–∞—Å—Ç–∏. –ü—Ä–∏ —á—Ç–µ–Ω–∏–∏, —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ –∏ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –∫–æ–¥–∞, –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç–∞–º –∏ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞–º –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –∑–Ω–∞—Ç—å, –æ—Ç–Ω–æ—Å–∏—Ç—Å—è –ª–∏ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–µ –∏–º—è –≤ –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–º –º–µ—Å—Ç–µ –∫ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π, —Ñ—É–Ω–∫—Ü–∏–∏, —Å—Ç—Ä—É–∫—Ç—É—Ä–µ, –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—é, –º–æ–¥—É–ª—é, –∫–æ–Ω—Å—Ç–∞–Ω—Ç–µ –∏–ª–∏ –¥—Ä—É–≥–æ–º—É —ç–ª–µ–º–µ–Ω—Ç—É –∏ —á—Ç–æ –æ–Ω —Å–æ–±–æ–π –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç. –ú–æ–∂–Ω–æ —Å–æ–∑–¥–∞–≤–∞—Ç—å –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∏ –æ–ø—Ä–µ–¥–µ–ª—è—Ç—å —Ç–æ, –∫–∞–∫–∏–µ –∏–º–µ–Ω–∞ –æ–Ω–∏ —Å–æ–¥–µ—Ä–∂–∞—Ç –∏ –Ω–µ —Å–æ–¥–µ—Ä–∂–∞—Ç. –ù–µ–ª—å–∑—è –∏–º–µ—Ç—å –¥–≤–∞ —ç–ª–µ–º–µ–Ω—Ç–∞ —Å —Ç–µ–º –∂–µ –∏–º–µ–Ω–µ–º –≤ –æ–¥–Ω–æ–π –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏; –¥–ª—è —Ä–µ—à–µ–Ω–∏—è –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤ –∏–º—ë–Ω –µ—Å—Ç—å –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã.</p>
<p>Rust –∏–º–µ–µ—Ç —Ä—è–¥ –º–µ—Ö–∞–Ω–∏–∑–º–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–∑–≤–æ–ª—è—é—Ç —É–ø—Ä–∞–≤–ª—è—Ç—å –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–µ–π –∫–æ–¥–∞, –≤ —Ç–æ–º —á–∏—Å–ª–µ —É–ø—Ä–∞–≤–ª—è—Ç—å —Ç–µ–º, –∫–∞–∫–∏–µ –¥–µ—Ç–∞–ª–∏ –¥–æ—Å—Ç—É–ø–Ω—ã —Å–Ω–∞—Ä—É–∂–∏, –∫–∞–∫–∏–µ –¥–µ—Ç–∞–ª–∏ —Å–∫—Ä—ã—Ç—ã, –∏ –∫–∞–∫–∏–µ –∏–º–µ–Ω–∞ –µ—Å—Ç—å –≤ –∫–∞–∂–¥–æ–π –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏ –≤ –≤–∞—à–µ–π –ø—Ä–æ–≥—Ä–∞–º–º–µ. –≠—Ç–∏ –º–µ—Ö–∞–Ω–∏–∑–º—ã, –∏–Ω–æ–≥–¥–∞ –æ–±–æ–±—â—ë–Ω–Ω–æ –Ω–∞–∑—ã–≤–∞–µ–º—ã–µ <em>—Å–∏—Å—Ç–µ–º–æ–π –º–æ–¥—É–ª–µ–π</em>, –≤–∫–ª—é—á–∞—é—Ç –≤ —Å–µ–±—è:</p>
<ul>
<li><strong>–ü–∞–∫–µ—Ç—ã</strong> ‚Äî –º–µ—Ö–∞–Ω–∏–∑–º Cargo, –ø–æ–∑–≤–æ–ª—è—é—â–∏–π —Å–æ–±–∏—Ä–∞—Ç—å, —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –∏ –¥–µ–ª–∏—Ç—å—Å—è –∫—Ä–µ–π—Ç–∞–º–∏</li>
<li><strong>–ö—Ä–µ–π—Ç—ã</strong> ‚Äî –¥–µ—Ä–µ–≤–æ –º–æ–¥—É–ª–µ–π, –∫–æ—Ç–æ—Ä–æ–µ —Å–æ–∑–¥–∞—ë—Ç –±–∏–±–ª–∏–æ—Ç–µ–∫—É –∏–ª–∏ –∏—Å–ø–æ–ª–Ω—è–µ–º—ã–π —Ñ–∞–π–ª</li>
<li><strong>–ú–æ–¥—É–ª–∏</strong> –∏ <strong><code>use</code></strong> ‚Äî –ø–æ–∑–≤–æ–ª—è—é—Ç –∫–æ–Ω—Ç—Ä–æ–ª–∏—Ä–æ–≤–∞—Ç—å –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—é —á–∞—Å—Ç–µ–π –∫–æ–¥–∞, –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∏ —Å–∫—Ä—ã—Ç–∏–µ –ø—É—Ç–µ–π</li>
<li><strong>–ü—É—Ç–∏</strong>: —Å–ø–æ—Å–æ–± –∏–º–µ–Ω–æ–≤–∞–Ω–∏—è —ç–ª–µ–º–µ–Ω—Ç–∞, —Ç–∞–∫–æ–≥–æ –∫–∞–∫ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞, —Ñ—É–Ω–∫—Ü–∏—è –∏–ª–∏ –º–æ–¥—É–ª—å</li>
</ul>
<p>–í —ç—Ç–æ–π –≥–ª–∞–≤–µ –º—ã —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º –≤—Å—ë –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–Ω–æ–µ, –æ–±—Å—É–¥–∏–º –∏—Ö –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ –∏ –æ–±—ä—è—Å–Ω–∏–º, –∫–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏—Ö –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –æ–±–ª–∞—Å—Ç—è–º–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏. –ö –∫–æ–Ω—Ü—É —É –≤–∞—Å –¥–æ–ª–∂–Ω–æ –ø–æ—è–≤–∏—Ç—å—Å—è —Å–æ–ª–∏–¥–Ω–æ–µ –ø–æ–Ω–∏–º–∞–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã –º–æ–¥—É–ª–µ–π –∏ —É–º–µ–Ω–∏–µ —Ä–∞–±–æ—Ç–∞—Ç—å —Å –æ–±–ª–∞—Å—Ç—è–º–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏ –Ω–∞ —É—Ä–æ–≤–Ω–µ –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª–∞! <em>(–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫–∞: –º–∞—Ç–µ—Ä–∏–∞–ª —ç—Ç–æ–π –≥–ª–∞–≤—ã –º–æ–∂–µ—Ç —Å–ª–æ–º–∞—Ç—å –≤–∞–º –º–æ–∑–≥. –ù–∞—Å—Ç–æ—è—Ç–µ–ª—å–Ω–æ —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è —Å–∞–º–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω—ã–π –ø–æ–∏—Å–∫ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤. Hang in there!)</em></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–ü–∞–∫–µ—Ç—ã-–∏-–∫—Ä–µ–π—Ç—ã"><a class="header" href="#–ü–∞–∫–µ—Ç—ã-–∏-–∫—Ä–µ–π—Ç—ã">–ü–∞–∫–µ—Ç—ã –∏ –∫—Ä–µ–π—Ç—ã</a></h2>
<p>–ü–µ—Ä–≤—ã–º–∏ —á–∞—Å—Ç—è–º–∏ —Å–∏—Å—Ç–µ–º—ã –º–æ–¥—É–ª–µ–π, –∫–æ—Ç–æ—Ä—ã–µ –º—ã —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º, –±—É–¥—É—Ç –ø–∞–∫–µ—Ç—ã –∏ –∫—Ä–µ–π—Ç—ã.</p>
<p><em>–ö—Ä–µ–π—Ç</em> ‚Äî —ç—Ç–æ –Ω–∞–∏–º–µ–Ω—å—à–∏–π –æ–±—ä–µ–º –∫–æ–¥–∞, –∫–æ—Ç–æ—Ä—ã–π –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä Rust —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞–µ—Ç –∑–∞ —Ä–∞–∑. –î–∞–∂–µ –µ—Å–ª–∏ –≤—ã –∑–∞–ø—É—Å—Ç–∏—Ç–µ <code>rustc</code> –≤–º–µ—Å—Ç–æ <code>cargo</code> –∏ –ø–µ—Ä–µ–¥–∞–¥–∏—Ç–µ –æ–¥–∏–Ω —Ñ–∞–π–ª —Å –∏—Å—Ö–æ–¥–Ω—ã–º –∫–æ–¥–æ–º (–∫–∞–∫ –º—ã —É–∂–µ –¥–µ–ª–∞–ª–∏ –≤ —Ä–∞–∑–¥–µ–ª–µ "–ù–∞–ø–∏—Å–∞–Ω–∏–µ –∏ –∑–∞–ø—É—Å–∫ –ø—Ä–æ–≥—Ä–∞–º–º—ã –Ω–∞ Rust" –ì–ª–∞–≤—ã 1), –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –ø–æ—Å—á–∏—Ç–∞–µ—Ç —ç—Ç–æ—Ç —Ñ–∞–π–ª –∫—Ä–µ–π—Ç–æ–º. –ö—Ä–µ–π—Ç—ã –º–æ–≥—É—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å –º–æ–¥—É–ª–∏, –∏ –º–æ–¥—É–ª–∏ –º–æ–≥—É—Ç –±—ã—Ç—å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω—ã –≤ –¥—Ä—É–≥–∏—Ö —Ñ–∞–π–ª–∞—Ö, –∫–æ—Ç–æ—Ä—ã–µ –∫–æ–º–ø–∏–ª–∏—Ä—É—é—Ç—Å—è –≤–º–µ—Å—Ç–µ —Å –∫—Ä–µ–π—Ç–æ–º, –∫–∞–∫ –º—ã —É–≤–∏–¥–∏–º –≤ —Å–ª–µ–¥—É—é—â–∏—Ö —Ä–∞–∑–¥–µ–ª–∞—Ö.</p>
<p>–ö—Ä–µ–π—Ç –º–æ–∂–µ—Ç –∏–º–µ—Ç—å –æ–¥–∏–Ω –∏–∑ –¥–≤—É—Ö –≤–∏–¥–æ–≤: –±–∏–Ω–∞—Ä–Ω—ã–π –∫—Ä–µ–π—Ç –∏–ª–∏ –±–∏–±–ª–∏–æ—Ç–µ—á–Ω—ã–π –∫—Ä–µ–π—Ç. <em>–ë–∏–Ω–∞—Ä–Ω—ã–µ –∫—Ä–µ–π—Ç—ã</em> ‚Äî —ç—Ç–æ –ø—Ä–æ–≥—Ä–∞–º–º—ã, –∫–æ—Ç–æ—Ä—ã–µ –≤—ã –º–æ–∂–µ—Ç–µ —Å–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞—Ç—å –≤ –∏—Å–ø–æ–ª–Ω—è–µ–º—ã–µ —Ñ–∞–π–ª—ã, –∫–æ—Ç–æ—Ä—ã–µ –≤—ã –º–æ–∂–µ—Ç–µ –∑–∞–ø—É—Å–∫–∞—Ç—å: –Ω–∞–ø—Ä–∏–º–µ—Ä –ø—Ä–æ–≥—Ä–∞–º–º–∞ –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏ –∏–ª–∏ —Å–µ—Ä–≤–µ—Ä. –£ –∫–∞–∂–¥–æ–≥–æ –±–∏–Ω–∞—Ä–Ω–æ–≥–æ –∫—Ä–µ–π—Ç–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —Ñ—É–Ω–∫—Ü–∏—è —Å –∏–º–µ–Ω–µ–º <code>main</code>, –∫–æ—Ç–æ—Ä–∞—è –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç, —á—Ç–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –∏—Å–ø–æ–ª–Ω—è–µ–º–æ–≥–æ —Ñ–∞–π–ª–∞. –í—Å–µ –∫—Ä–µ–π—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –º—ã —Å–æ–∑–¥–∞–≤–∞–ª–∏ –¥–æ —Å–∏—Ö –ø–æ—Ä, –±—ã–ª–∏ –±–∏–Ω–∞—Ä–Ω—ã–º–∏ –∫—Ä–µ–π—Ç–∞–º–∏.</p>
<p><em>Library crates</em> don‚Äôt have a <code>main</code> function, and they don‚Äôt compile to an executable. Instead, they define functionality intended to be shared with multiple projects. For example, the <code>rand</code> crate we used in <a href="ch02-00-guessing-game-tutorial.html#generating-a-random-number">Chapter 2</a><!-- ignore --> provides functionality that generates random numbers. Most of the time when Rustaceans say ‚Äúcrate‚Äù, they mean library crate, and they use ‚Äúcrate‚Äù interchangeably with the general programming concept of a ‚Äúlibrary‚Äù.</p>
<p><em>–ö–æ—Ä–µ–Ω—å –∫—Ä–µ–π—Ç–∞</em> ‚Äî —ç—Ç–æ –∏—Å—Ö–æ–¥–Ω—ã–π —Ñ–∞–π–ª, –∏–∑ –∫–æ—Ç–æ—Ä–æ–≥–æ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä Rust –Ω–∞—á–∏–Ω–∞–µ—Ç —Å–æ–±–∏—Ä–∞—Ç—å –∫–æ—Ä–Ω–µ–≤–æ–π –º–æ–¥—É–ª—å –≤–∞—à–µ–≥–æ –∫—Ä–µ–π—Ç–∞ (–º—ã –ø–æ–¥—Ä–æ–±–Ω–æ –æ–±—ä—è—Å–Ω–∏–º –º–æ–¥—É–ª–∏ –≤ —Ä–∞–∑–¥–µ–ª–µ <a href="ch07-02-defining-modules-to-control-scope-and-privacy.html">"–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –º–æ–¥—É–ª–µ–π –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –æ–±–ª–∞—Å—Ç—å—é –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∏ –ø—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç—å—é"</a><!-- ignore -->).</p>
<p><em>–ü–∞–∫–µ—Ç</em> ‚Äî —ç—Ç–æ –Ω–∞–±–æ—Ä –∏–∑ –æ–¥–Ω–æ–≥–æ –∏–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –∫—Ä–µ–π—Ç–æ–≤, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è—é—â–∏–π –Ω–∞–±–æ—Ä —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏. –ü–∞–∫–µ—Ç —Å–æ–¥–µ—Ä–∂–∏—Ç —Ñ–∞–π–ª <em>Cargo.toml</em>, –≤ –∫–æ—Ç–æ—Ä–æ–º –æ–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è, –∫–∞–∫ —Å–æ–±–∏—Ä–∞—Ç—å —ç—Ç–∏ –∫—Ä–µ–π—Ç—ã. –ù–∞ —Å–∞–º–æ–º –¥–µ–ª–µ, Cargo ‚Äî —ç—Ç–æ –ø–∞–∫–µ—Ç, —Å–æ–¥–µ—Ä–∂–∞—â–∏–π –±–∏–Ω–∞—Ä–Ω—ã–π –∫—Ä–µ–π—Ç –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞ –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏, –∫–æ—Ç–æ—Ä—ã–π –≤—ã –∏—Å–ø–æ–ª—å–∑—É–µ—Ç–µ –¥–ª—è —Å–±–æ—Ä–∫–∏ —Å–≤–æ–µ–≥–æ –∫–æ–¥–∞. –ü–∞–∫–µ—Ç Cargo —Ç–∞–∫–∂–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –±–∏–±–ª–∏–æ—Ç–µ—á–Ω—ã–π –∫—Ä–µ–π—Ç, –æ—Ç –∫–æ—Ç–æ—Ä–æ–≥–æ –∑–∞–≤–∏—Å–∏—Ç –±–∏–Ω–∞—Ä–Ω—ã–π –∫—Ä–µ–π—Ç. –î—Ä—É–≥–∏–µ –ø—Ä–æ–µ–∫—Ç—ã —Ç–æ–∂–µ –º–æ–≥—É—Ç –∑–∞–≤–∏—Å–µ—Ç—å –æ—Ç –±–∏–±–ª–∏–æ—Ç–µ—á–Ω–æ–≥–æ –∫—Ä–µ–π—Ç–∞ Cargo, —á—Ç–æ–±—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç—É –∂–µ –ª–æ–≥–∏–∫—É, —á—Ç–æ –∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏ Cargo. –ü–∞–∫–µ—Ç –º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Å–∫–æ–ª—å–∫–æ —É–≥–æ–¥–Ω–æ –±–∏–Ω–∞—Ä–Ω—ã—Ö –∫—Ä–µ–π—Ç–æ–≤, –Ω–æ –Ω–µ –±–æ–ª–µ–µ –æ–¥–Ω–æ–≥–æ –±–∏–±–ª–∏–æ—Ç–µ—á–Ω–æ–≥–æ –∫—Ä–µ–π—Ç–∞. –ü–∞–∫–µ—Ç –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω –∫—Ä–µ–π—Ç: –±–∏–±–ª–∏–æ—Ç–µ—á–Ω—ã–π –∏–ª–∏ –±–∏–Ω–∞—Ä–Ω—ã–π.</p>
<p>–î–∞–≤–∞–π—Ç–µ –ø—Ä–æ–π–¥—ë–º—Å—è –ø–æ —Ç–æ–º—É, —á—Ç–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç, –∫–æ–≥–¥–∞ –º—ã —Å–æ–∑–¥–∞—ë–º –ø–∞–∫–µ—Ç. –°–Ω–∞—á–∞–ª–∞ –≤–≤–µ–¥—ë–º –∫–æ–º–∞–Ω–¥—É <code>cargo new my-project</code>:</p>
<pre><code class="language-console">$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
</code></pre>
<p>–ü–æ—Å–ª–µ —Ç–æ–≥–æ, –∫–∞–∫ –º—ã –≤—ã–ø–æ–ª–Ω–∏–ª–∏ <code>cargo new my-project</code>, –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º <code>ls</code>, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å, —á—Ç–æ —Å–æ–∑–¥–∞–ª Cargo. –í –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –ø—Ä–æ–µ–∫—Ç–∞ –µ—Å—Ç—å —Ñ–∞–π–ª <em>Cargo.toml</em>, –æ–ø—Ä–µ–¥–µ–ª—è—é—â–∏–π –Ω–∞—à –ø–∞–∫–µ—Ç. –¢–∞–∫–∂–µ –µ—Å—Ç—å –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è <em>src</em>, —Å–æ–¥–µ—Ä–∂–∞—â–∞—è <em>main.rs</em>. –û—Ç–∫—Ä–æ–π—Ç–µ <em>Cargo.toml</em> –≤ —Ç–µ–∫—Å—Ç–æ–≤–æ–º —Ä–µ–¥–∞–∫—Ç–æ—Ä–µ –∏ –æ–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ –≤ –Ω—ë–º –Ω–µ—Ç —É–ø–æ–º–∏–Ω–∞–Ω–∏–π –æ–± <em>src/main.rs</em>. Cargo —Å–ª–µ–¥—É–µ—Ç —Å–æ–≥–ª–∞—à–µ–Ω–∏—é –æ —Ç–æ–º, —á—Ç–æ <em>src/main.rs</em> ‚Äî —ç—Ç–æ –∫–æ—Ä–µ–Ω—å –±–∏–Ω–∞—Ä–Ω–æ–≥–æ –∫—Ä–µ–π—Ç–∞ —Å —Ç–µ–º –∂–µ –∏–º–µ–Ω–µ–º, —á—Ç–æ –∏ —É –ø–∞–∫–µ—Ç–∞. –ê–Ω–∞–ª–æ–≥–∏—á–Ω–æ, Cargo –∑–Ω–∞–µ—Ç, —á—Ç–æ –µ—Å–ª–∏ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –ø–∞–∫–µ—Ç–∞ —Å–æ–¥–µ—Ä–∂–∏—Ç <em>src/lib.rs</em>, —Ç–æ –ø–∞–∫–µ—Ç —Å–æ–¥–µ—Ä–∂–∏—Ç –±–∏–±–ª–∏–æ—Ç–µ—á–Ω—ã–π –∫—Ä–µ–π—Ç —Å —Ç–µ–º –∂–µ –∏–º–µ–Ω–µ–º, —á—Ç–æ –∏ –ø–∞–∫–µ—Ç, –∞ <em>src/lib.rs</em> —è–≤–ª—è–µ—Ç—Å—è –∫–æ—Ä–Ω–µ–≤—ã–º –º–æ–¥—É–ª–µ–º —ç—Ç–æ–≥–æ –∫—Ä–µ–π—Ç–∞. Cargo –ø–µ—Ä–µ–¥–∞—ë—Ç —Ñ–∞–π–ª—ã –∫–æ—Ä–Ω—è –∫—Ä–µ–π—Ç–∞ –≤ <code>rustc</code> –¥–ª—è —Å–±–æ—Ä–∫–∏ –±–∏–±–ª–∏–æ—Ç–µ—á–Ω–æ–≥–æ –∏–ª–∏ –±–∏–Ω–∞—Ä–Ω–æ–≥–æ –∫—Ä–µ–π—Ç–∞.</p>
<p>–ó–¥–µ—Å—å —É –Ω–∞—Å –µ—Å—Ç—å –ø–∞–∫–µ—Ç, –∫–æ—Ç–æ—Ä—ã–π —Å–æ–¥–µ—Ä–∂–∏—Ç —Ç–æ–ª—å–∫–æ <em>src/main.rs</em>, —á—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –æ–Ω —Å–æ–¥–µ—Ä–∂–∏—Ç —Ç–æ–ª—å–∫–æ –±–∏–Ω–∞—Ä–Ω—ã–π –∫—Ä–µ–π—Ç —Å –∏–º–µ–Ω–µ–º <code>my-project</code>. –ï—Å–ª–∏ –ø–∞–∫–µ—Ç —Å–æ–¥–µ—Ä–∂–∏—Ç –∏ <em>src/main.rs</em>, –∏ <em>src/lib.rs</em>, –æ–Ω –∏–º–µ–µ—Ç –¥–≤–∞ –∫—Ä–µ–π—Ç–∞: –±–∏–Ω–∞—Ä–Ω—ã–π –∏ –±–∏–±–ª–∏–æ—Ç–µ—á–Ω—ã–π, –æ–±–∞ —Å —Ç–µ–º –∂–µ –∏–º–µ–Ω–µ–º, —á—Ç–æ –∏ –ø–∞–∫–µ—Ç. –ü–∞–∫–µ—Ç –±—É–¥–µ—Ç –∏–º–µ—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –±–∏–Ω–∞—Ä–Ω—ã—Ö –∫—Ä–µ–π—Ç–æ–≤, –µ—Å–ª–∏ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ <em>src/bin</em> —Ä–∞–∑–º–µ—Å—Ç–∏—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ñ–∞–π–ª–æ–≤: –∫–∞–∂–¥—ã–π —Ñ–∞–π–ª –±—É–¥–µ—Ç –æ—Ç–¥–µ–ª—å–Ω—ã–º –±–∏–Ω–∞—Ä–Ω—ã–º –∫—Ä–µ–π—Ç–æ–º.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ-–º–æ–¥—É–ª–µ–π-–¥–ª—è-—É–ø—Ä–∞–≤–ª–µ–Ω–∏—è-–æ–±–ª–∞—Å—Ç—å—é-–≤–∏–¥–∏–º–æ—Å—Ç–∏-–∏-–ø—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç—å—é"><a class="header" href="#–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ-–º–æ–¥—É–ª–µ–π-–¥–ª—è-—É–ø—Ä–∞–≤–ª–µ–Ω–∏—è-–æ–±–ª–∞—Å—Ç—å—é-–≤–∏–¥–∏–º–æ—Å—Ç–∏-–∏-–ø—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç—å—é">–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –º–æ–¥—É–ª–µ–π –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –æ–±–ª–∞—Å—Ç—å—é –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∏ –ø—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç—å—é</a></h2>
<p>–í —ç—Ç–æ–º —Ä–∞–∑–¥–µ–ª–µ –º—ã –ø–æ–≥–æ–≤–æ—Ä–∏–º –æ –º–æ–¥—É–ª—è—Ö –∏ –¥—Ä—É–≥–∏—Ö —á–∞—Å—Ç—è—Ö —Å–∏—Å—Ç–µ–º—ã –º–æ–¥—É–ª–µ–π, –∞ –∏–º–µ–Ω–Ω–æ: –æ <em>–ø—É—Ç—è—Ö</em>, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–∑–≤–æ–ª—è—é—Ç –∏–º–µ–Ω–æ–≤–∞—Ç—å —ç–ª–µ–º–µ–Ω—Ç—ã; –æ –∫–ª—é—á–µ–≤–æ–º —Å–ª–æ–≤–µ <code>use</code>, –∫–æ—Ç–æ—Ä–æ–µ –ø–æ–¥–∫–ª—é—á–∞–µ—Ç –ø—É—Ç—å –∫ –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏; –æ –∫–ª—é—á–µ–≤–æ–º —Å–ª–æ–≤–µ <code>pub</code>, –∫–æ—Ç–æ—Ä–æ–µ –¥–µ–ª–∞–µ—Ç —ç–ª–µ–º–µ–Ω—Ç—ã –æ–±—â–µ–¥–æ—Å—Ç—É–ø–Ω—ã–º–∏. –ú—ã —Ç–∞–∫–∂–µ –æ–±—Å—É–¥–∏–º –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ <code>as</code>, –≤–Ω–µ—à–Ω–∏–µ –ø–∞–∫–µ—Ç—ã –∏ –æ–ø–µ—Ä–∞—Ç–æ—Ä <code>*</code>.</p>
<h3 id="–®–ø–∞—Ä–≥–∞–ª–∫–∞-–ø–æ-–º–æ–¥—É–ª—è–º"><a class="header" href="#–®–ø–∞—Ä–≥–∞–ª–∫–∞-–ø–æ-–º–æ–¥—É–ª—è–º">–®–ø–∞—Ä–≥–∞–ª–∫–∞ –ø–æ –º–æ–¥—É–ª—è–º</a></h3>
<p>–ü–µ—Ä–µ–¥ —Ç–µ–º –∫–∞–∫ –≤–¥–∞–≤–∞—Ç—å—Å—è –≤ –¥–µ—Ç–∞–ª–∏ —Ä–∞–±–æ—Ç—ã —Å –º–æ–¥—É–ª—è–º–∏ –∏ –ø—É—Ç—è–º–∏, –º—ã –¥–∞–¥–∏–º –∫—Ä–∞—Ç–∫–∏–π –æ–±–∑–æ—Ä —Ç–æ–≥–æ, –∫–∞–∫ –º–æ–¥—É–ª–∏, –ø—É—Ç–∏ –∏ –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ <code>use</code> –∏ <code>pub</code> —Ä–∞–±–æ—Ç–∞—é—Ç –≤ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–µ, –∏ –∫–∞–∫ –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–æ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ –æ—Ä–≥–∞–Ω–∏–∑—É—é—Ç —Å–≤–æ–π –∫–æ–¥. –í —ç—Ç–æ–π –≥–ª–∞–≤–µ –º—ã —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º –≤—Å—ë —ç—Ç–æ –Ω–∞ –ø—Ä–∏–º–µ—Ä–∞—Ö, –∞ –ø–æ–∫–∞ —á—Ç–æ —É –Ω–∞—Å –µ—Å—Ç—å —É–¥–æ–±–Ω—ã–π –º–æ–º–µ–Ω—Ç, —á—Ç–æ–±—ã –¥–∞—Ç—å –≤—ã–∂–∏–º–∫—É –æ —Ç–æ–º, –∫–∞–∫ —Ä–∞–±–æ—Ç–∞—é—Ç –∫—Ä–µ–π—Ç—ã.</p>
<ul>
<li><strong>–°—Ç–∞—Ä—Ç —Å –∫–æ—Ä–Ω—è –∫—Ä–µ–π—Ç–∞</strong>. –í –Ω–∞—á–∞–ª–µ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –∫—Ä–µ–π—Ç–∞, –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –∏—â–µ—Ç –≤ –∫–æ—Ä–Ω–µ –∫—Ä–µ–π—Ç–∞ (–æ–±—ã—á–Ω–æ —ç—Ç–æ <em>src/lib.rs</em> –¥–ª—è –±–∏–±–ª–∏–æ—Ç–µ—á–Ω–æ–≥–æ –∫—Ä–µ–π—Ç–∞ –∏–ª–∏ <em>src/main.rs</em> –¥–ª—è –±–∏–Ω–∞—Ä–Ω–æ–≥–æ –∫—Ä–µ–π—Ç–∞) –∫–æ–¥ –¥–ª—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏.</li>
<li><strong>–û–±—ä—è–≤–ª–µ–Ω–∏–µ –º–æ–¥—É–ª–µ–π</strong>. –í —Ñ–∞–π–ª–µ –∫–æ—Ä–Ω—è –∫—Ä–µ–π—Ç–∞ –≤—ã –º–æ–∂–µ—Ç–µ –æ–±—ä—è–≤–ª—è—Ç—å –Ω–æ–≤—ã–µ –º–æ–¥—É–ª–∏. –°–∫–∞–∂–µ–º, –≤—ã –æ–±—ä—è–≤–ª—è–µ—Ç–µ –º–æ–¥—É–ª—å "garden" —Å –ø–æ–º–æ—â—å—é <code>mod garden;</code>. –ö–æ–º–ø–∏–ª—è—Ç–æ—Ä –±—É–¥–µ—Ç –∏—Å–∫–∞—Ç—å –∫–æ–¥ –º–æ–¥—É–ª—è –≤ —Å–ª–µ–¥—É—é—â–∏—Ö –º–µ—Å—Ç–∞—Ö:
<ul>
<li>–í —ç—Ç–æ–º –∂–µ —Ñ–∞–π–ª–µ –º–µ–∂–¥—É —Ñ–∏–≥—É—Ä–Ω—ã—Ö —Å–∫–æ–±–æ–∫, –∫–æ—Ç–æ—Ä—ã–µ –∑–∞–º–µ–Ω—è—é—Ç —Ç–æ—á–∫—É —Å –∑–∞–ø—è—Ç–æ–π –ø–æ—Å–ª–µ <code>mod garden</code></li>
<li>–í —Ñ–∞–π–ª–µ <em>src/garden.rs</em></li>
<li>–í —Ñ–∞–π–ª–µ <em>src/garden/mod.rs</em></li>
</ul>
</li>
<li><strong>–û–±—ä—è–≤–ª–µ–Ω–∏–µ –ø–æ–¥–º–æ–¥—É–ª–µ–π</strong>. –í –ª—é–±–æ–º —Ñ–∞–π–ª–µ, –∫—Ä–æ–º–µ –∫–æ—Ä–Ω—è –∫—Ä–µ–π—Ç–∞, –≤—ã –º–æ–∂–µ—Ç–µ –æ–±—ä—è–≤–ª—è—Ç—å –ø–æ–¥–º–æ–¥—É–ª–∏. –ö –ø—Ä–∏–º–µ—Ä—É, –≤—ã –º–æ–∂–µ—Ç–µ –æ–±—ä—è–≤–∏—Ç—å <code>mod vegetables;</code> –≤ <em>src/garden.rs</em>. –ö–æ–º–ø–∏–ª—è—Ç–æ—Ä –±—É–¥–µ—Ç –∏—Å–∫–∞—Ç—å –∫–æ–¥ –ø–æ–¥–º–æ–¥—É–ª—è –≤ –∫–∞—Ç–∞–ª–æ–≥–µ —Å –∏–º–µ–Ω–µ–º —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–æ–≥–æ –º–æ–¥—É–ª—è –≤ —Å–ª–µ–¥—É—é—â–∏—Ö –º–µ—Å—Ç–∞—Ö:
<ul>
<li>–í —ç—Ç–æ–º –∂–µ —Ñ–∞–π–ª–µ, —Å—Ä–∞–∑—É –ø–æ—Å–ª–µ <code>mod vegetables</code> –∏ –º–µ–∂–¥—É —Ñ–∏–≥—É—Ä–Ω—ã—Ö —Å–∫–æ–±–æ–∫, –∫–æ—Ç–æ—Ä—ã–µ –∑–∞–º–µ–Ω—è—é—Ç —Ç–æ—á–∫—É —Å –∑–∞–ø—è—Ç–æ–π</li>
<li>–í —Ñ–∞–π–ª–µ <em>src/garden/vegetables.rs</em></li>
<li>–í —Ñ–∞–π–ª–µ <em>src/garden/vegetables/mod.rs</em></li>
</ul>
</li>
<li><strong>–ü—É—Ç–∏ –∫ –∫–æ–¥—É –≤ –º–æ–¥—É–ª—è—Ö</strong>. –ü–æ—Å–ª–µ —Ç–æ–≥–æ, –∫–∞–∫ –º–æ–¥—É–ª—å —Å—Ç–∞–Ω–µ—Ç —á–∞—Å—Ç—å—é –≤–∞—à–µ–≥–æ –∫—Ä–µ–π—Ç–∞, –∏ –µ—Å–ª–∏ –¥–æ–ø—É—Å–∫–∞—é—Ç –ø—Ä–∞–≤–∏–ª–∞ –ø—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç–∏, –≤—ã –º–æ–∂–µ—Ç–µ —Å—Å—ã–ª–∞—Ç—å—Å—è –Ω–∞ –∫–æ–¥ –≤ —ç—Ç–æ–º –º–æ–¥—É–ª–µ –∏–∑ –ª—é–±–æ–≥–æ –º–µ—Å—Ç–∞ –≤–∞—à–µ–≥–æ –∫—Ä–µ–π—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É—è –ø—É—Ç—å –∫ –∫–æ–¥—É. –ù–∞–ø—Ä–∏–º–µ—Ä, —Ç–∏–ø <code>Asparagus</code> –≤ –ø–æ–¥–º–æ–¥—É–ª–µ <code>vegetables</code> –º–æ–¥—É–ª—è <code>garden</code> –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–µ–Ω –ø–æ –ø—É—Ç–∏ <code>crate::garden::vegetables::Asparagus</code>.</li>
<li><strong>–ó–∞–∫—Ä—ã—Ç–æ—Å—Ç—å –∏ –æ—Ç–∫—Ä—ã—Ç–æ—Å—Ç—å</strong>. –ö–æ–¥ –≤ –º–æ–¥—É–ª–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é —Å–∫—Ä—ã—Ç –æ—Ç –µ–≥–æ —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–∏—Ö –º–æ–¥—É–ª–µ–π. –ß—Ç–æ–±—ã —Å–¥–µ–ª–∞—Ç—å –º–æ–¥—É–ª—å –æ–±—â–µ–¥–æ—Å—Ç—É–ø–Ω—ã–º, –æ–±—ä—è–≤–∏—Ç–µ –µ–≥–æ –∫–∞–∫ <code>pub mod</code> –≤–º–µ—Å—Ç–æ <code>mod</code>. –ß—Ç–æ–±—ã —Å–¥–µ–ª–∞—Ç—å —ç–ª–µ–º–µ–Ω—Ç—ã –æ–±—â–µ–¥–æ—Å—Ç—É–ø–Ω–æ–≥–æ –º–æ–¥—É–ª—è —Ç–æ–∂–µ –æ–±—â–µ–¥–æ—Å—Ç—É–ø–Ω—ã–º–∏, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ <code>pub</code> –ø–µ—Ä–µ–¥ –∏—Ö –æ–±—ä—è–≤–ª–µ–Ω–∏–µ–º.</li>
<li><strong>–ö–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ <code>use</code></strong>. –í–Ω—É—Ç—Ä–∏ –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∫–ª—é—á–µ–≤–æ–≥–æ —Å–ª–æ–≤–∞ <code>use</code> —Å–æ–∑–¥–∞—ë—Ç –ø—Å–µ–≤–¥–æ–Ω–∏–º—ã –¥–ª—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤, —á—Ç–æ–±—ã —Å–æ–∫—Ä–∞—Ç–∏—Ç—å –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏–µ –¥–ª–∏–Ω–Ω—ã—Ö –ø—É—Ç–µ–π. –í –ª—é–±–æ–π –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏, –∏–∑ –∫–æ—Ç–æ—Ä–æ–π –º–æ–∂–Ω–æ –æ–±—Ä–∞—Ç–∏—Ç—å—Å—è –∫ <code>crate::garden::vegetables::Asparagus</code>, –≤—ã –º–æ–∂–µ—Ç–µ —Å–æ–∑–¥–∞—Ç—å –ø—Å–µ–≤–¥–æ–Ω–∏–º <code>use crate::garden::vegetables::Asparagus;</code> –∏ –ø–æ—Å–ª–µ —ç—Ç–æ–≥–æ –≤–∞–º –Ω—É–∂–Ω–æ –ø—Ä–æ—Å—Ç–æ –ø–∏—Å–∞—Ç—å <code>Asparagus</code>, —á—Ç–æ–±—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç—Ç–æ—Ç —Ç–∏–ø –≤ —ç—Ç–æ–π –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏.</li>
</ul>
<p>–ú—ã —Å–æ–∑–¥–∞–ª–∏ –±–∏–Ω–∞—Ä–Ω—ã–π –∫—Ä–µ–π—Ç <code>backyard</code>, –∫–æ—Ç–æ—Ä—ã–π –∏–ª–ª—é—Å—Ç—Ä–∏—Ä—É–µ—Ç —ç—Ç–∏ –ø—Ä–∞–≤–∏–ª–∞. –î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –∫—Ä–µ–π—Ç–∞, —Ç–∞–∫–∂–µ –Ω–∞–∑–≤–∞–Ω–Ω–∞—è –∫–∞–∫ <code>backyard</code>, —Å–æ–¥–µ—Ä–∂–∏—Ç —Å–ª–µ–¥—É—é—â–∏–µ —Ñ–∞–π–ª—ã –∏ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏:</p>
<pre><code class="language-text">backyard
‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ Cargo.toml
‚îî‚îÄ‚îÄ src
    ‚îú‚îÄ‚îÄ garden
    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ vegetables.rs
    ‚îú‚îÄ‚îÄ garden.rs
    ‚îî‚îÄ‚îÄ main.rs
</code></pre>
<p>–§–∞–π–ª –∫–æ—Ä–Ω–µ–≤–æ–≥–æ –º–æ–¥—É–ª—è –∫—Ä–µ–π—Ç–∞ (–≤ –Ω–∞—à–µ–º —Å–ª—É—á–∞–µ) ‚Äî <em>src/main.rs</em>. –í–æ—Ç, —á—Ç–æ –æ–Ω —Å–æ–¥–µ—Ä–∂–∏—Ç:</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust noplayground ignore">use crate::garden::vegetables::Asparagus;

pub mod garden;

fn main() {
    let plant = Asparagus {};
    println!("–ó–¥–µ—Å—å —Ä–∞—Å—Ç—ë—Ç {plant:?}!");
}</code></pre>
</Listing>
<p>–°—Ç—Ä–æ–∫–∞ <code>pub mod garden;</code> –≥–æ–≤–æ—Ä–∏—Ç –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä—É –ø–æ–¥–∫–ª—é—á–∏—Ç—å –∫–æ–¥, –∏–º–µ—é—â–∏–π—Å—è –≤ <em>src/garden.rs</em>. –í–æ—Ç –ø–æ–¥–∫–ª—é—á–∞–µ–º—ã–π –∫–æ–¥:</p>
<Listing file-name="src/garden.rs">
<pre><code class="language-rust noplayground ignore">pub mod vegetables;</code></pre>
</Listing>
<p>–ê –∑–¥–µ—Å—å <code>pub mod vegetables;</code> —É–∫–∞–∑—ã–≤–∞–µ—Ç, —á—Ç–æ –∫–æ–¥ –≤ <code>src/garden/vegetables.rs</code> —Ç–æ–∂–µ –ø–æ–¥–∫–ª—é—á—ë–Ω. –í–æ—Ç –ø–æ–¥–∫–ª—é—á–∞–µ–º—ã–π –∫–æ–¥:</p>
<pre><code class="language-rust noplayground ignore">#[derive(Debug)]
pub struct Asparagus {}</code></pre>
<p>–¢–µ–ø–µ—Ä—å –¥–∞–≤–∞–π—Ç–µ —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º –¥–µ—Ç–∞–ª–∏ —ç—Ç–∏—Ö –ø—Ä–∞–≤–∏–ª –∏ –ø–æ–∫–∞–∂–µ–º –∏—Ö –≤ –¥–µ–π—Å—Ç–≤–∏–∏!</p>
<h3 id="–ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞-—Ä–æ–¥—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ-–∫–æ–¥–∞-–≤-–º–æ–¥—É–ª–∏"><a class="header" href="#–ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞-—Ä–æ–¥—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ-–∫–æ–¥–∞-–≤-–º–æ–¥—É–ª–∏">–ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ —Ä–æ–¥—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –∫–æ–¥–∞ –≤ –º–æ–¥—É–ª–∏</a></h3>
<p><em>–ú–æ–¥—É–ª–∏</em> –ø–æ–∑–≤–æ–ª—è—é—Ç —É–ø–æ—Ä—è–¥–æ—á–∏–≤–∞—Ç—å –∫–æ–¥ –≤–Ω—É—Ç—Ä–∏ –∫—Ä–µ–π—Ç–∞ –¥–ª—è —É–¥–æ–±–æ—á–∏—Ç–∞–µ–º–æ—Å—Ç–∏ –∏ –ª—ë–≥–∫–æ–≥–æ –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è. –ú–æ–¥—É–ª–∏ —Ç–∞–∫–∂–µ –ø–æ–∑–≤–æ–ª—è—é—Ç –Ω–∞–º —É–ø—Ä–∞–≤–ª—è—Ç—å <em>–ø—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç—å—é</em> —ç–ª–µ–º–µ–Ω—Ç–æ–≤, –ø–æ—Å–∫–æ–ª—å–∫—É –∫–æ–¥ –≤–Ω—É—Ç—Ä–∏ –º–æ–¥—É–ª—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é —è–≤–ª—è–µ—Ç—Å—è –∑–∞–∫—Ä—ã—Ç—ã–º. –ü—Ä–∏–≤–∞—Ç–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã ‚Äî —ç—Ç–æ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –¥–µ—Ç–∞–ª–∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏, –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã–µ –¥–ª—è –≤–Ω–µ—à–Ω–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è. –ú—ã –º–æ–∂–µ–º —Å–¥–µ–ª–∞—Ç—å –º–æ–¥—É–ª–∏ –∏ —ç–ª–µ–º–µ–Ω—Ç—ã –≤–Ω—É—Ç—Ä–∏ –Ω–∏—Ö –æ–±—â–µ–¥–æ—Å—Ç—É–ø–Ω—ã–º–∏, —á—Ç–æ –ø–æ–∑–≤–æ–ª–∏—Ç –≤–Ω–µ—à–Ω–µ–º—É –∫–æ–¥—É –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏—Ö –∏ –∑–∞–≤–∏—Å–µ—Ç—å –æ—Ç –Ω–∏—Ö.</p>
<p>–í –∫–∞—á–µ—Å—Ç–≤–µ –ø—Ä–∏–º–µ—Ä–∞, –¥–∞–≤–∞–π—Ç–µ –Ω–∞–ø–∏—à–µ–º –±–∏–±–ª–∏–æ—Ç–µ—á–Ω—ã–π –∫—Ä–µ–π—Ç –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è—é—â–∏–π —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å —Ä–µ—Å—Ç–æ—Ä–∞–Ω–∞. –ú—ã –æ–ø—Ä–µ–¥–µ–ª–∏–º —Å–∏–≥–Ω–∞—Ç—É—Ä—ã —Ñ—É–Ω–∫—Ü–∏–π, –Ω–æ –æ—Å—Ç–∞–≤–∏–º –∏—Ö —Ç–µ–ª–∞ –ø—É—Å—Ç—ã–º–∏, —á—Ç–æ–±—ã —Å–æ—Å—Ä–µ–¥–æ—Ç–æ—á–∏—Ç—å—Å—è –Ω–∞ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ –∫–æ–¥–∞, –≤–º–µ—Å—Ç–æ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ —Å–∞–º–æ–≥–æ —Ä–µ—Å—Ç–æ—Ä–∞–Ω–∞.</p>
<p>–í —Ä–µ—Å—Ç–æ—Ä–∞–Ω–Ω–æ–π –∏–Ω–¥—É—Å—Ç—Ä–∏–∏ –æ–¥–Ω–∏ —á–∞—Å—Ç–∏ —Ä–µ—Å—Ç–æ—Ä–∞–Ω–∞ –Ω–∞–∑—ã–≤–∞—é—Ç—Å—è <em>front of house</em>, –∞ –¥—Ä—É–≥–∏–µ ‚Äî <em>back of house</em>. Front of house ‚Äî —ç—Ç–æ —Ç–∞–º, –≥–¥–µ –Ω–∞—Ö–æ–¥—è—Ç—Å—è –∫–ª–∏–µ–Ω—Ç—ã; –∑–¥–µ—Å—å —Ä–∞–∑–º–µ—â–∞—é—Ç—Å—è –º–µ—Å—Ç–∞ –∫–ª–∏–µ–Ω—Ç–æ–≤, –æ—Ñ–∏—Ü–∏–∞–Ω—Ç—ã –ø—Ä–∏–Ω–∏–º–∞—é—Ç –∑–∞–∫–∞–∑—ã –∏ –æ–ø–ª–∞—Ç—ã, –∞ –±–∞—Ä–º–µ–Ω—ã –¥–µ–ª–∞—é—Ç –Ω–∞–ø–∏—Ç–∫–∏. Back of house ‚Äî —Ç–∞–º, —ç—Ç–æ –≥–¥–µ –ø–æ–≤–∞—Ä–∞ —Ä–∞–±–æ—Ç–∞—é—Ç –Ω–∞ –∫—É—Ö–Ω–µ, —Ä–∞–±–æ—Ç–∞—é—Ç –ø–æ—Å—É–¥–æ–º–æ–µ—á–Ω—ã–µ –º–∞—à–∏–Ω—ã, –∞ –º–µ–Ω–µ–¥–∂–µ—Ä—ã –∑–∞–Ω–∏–º–∞—é—Ç—Å—è —Ö–æ–∑—è–π—Å—Ç–≤–µ–Ω–Ω–æ–π –¥–µ—è—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é.</p>
<p>–ß—Ç–æ–±—ã —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞—Ç—å –∫—Ä–µ–π—Ç –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ —Ä–µ—Å—Ç–æ—Ä–∞–Ω–Ω–æ–π –º–æ–¥–µ–ª–∏, –º–æ–∂–Ω–æ –æ—Ä–≥–∞–Ω–∏–∑–æ–≤–∞—Ç—å —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ –µ–≥–æ —Ñ—É–Ω–∫—Ü–∏–π –≤–æ –≤–ª–æ–∂–µ–Ω–Ω—ã—Ö –º–æ–¥—É–ª—è—Ö. –°–æ–∑–¥–∞–¥–∏–º –Ω–æ–≤—É—é –±–∏–±–ª–∏–æ—Ç–µ–∫—É —Å –∏–º–µ–Ω–µ–º <code>restaurant</code> –≤—ã–ø–æ–ª–Ω–∏–≤ –∫–æ–º–∞–Ω–¥—É <code>cargo new restaurant --lib</code>. –ó–∞—Ç–µ–º –≤—Å—Ç–∞–≤–∏–º –∫–æ–¥ –∏–∑ –õ–∏—Å—Ç–∏–Ω–≥–∞ 7-1 –≤ <em>src/lib.rs</em> –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –º–æ–¥—É–ª–µ–π –∏ —Å–∏–≥–Ω–∞—Ç—É—Ä —Ñ—É–Ω–∫—Ü–∏–π. –≠—Ç–æ front of house:</p>
<Listing number="7-1" file-name="src/lib.rs" caption="A `front_of_house` module containing other modules that then contain functions">
<pre><code class="language-rust noplayground">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}</code></pre>
</Listing>
<p>–ú—ã –æ–ø—Ä–µ–¥–µ–ª—è–µ–º –º–æ–¥—É–ª—å –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–æ–º <code>mod</code>, –∑–∞—Ç–µ–º –ø–∏—à–µ–º –Ω–∞–∑–≤–∞–Ω–∏–µ –º–æ–¥—É–ª—è (–≤ –¥–∞–Ω–Ω–æ–º —Å–ª—É—á–∞–µ ‚Äî <code>front_of_house</code>) –∏ —Ä–∞–∑–º–µ—â–∞–µ–º —Ñ–∏–≥—É—Ä–Ω—ã–µ —Å–∫–æ–±–∫–∏ –≤–æ–∫—Ä—É–≥ —Ç–µ–ª–∞ –º–æ–¥—É–ª—è. –í–Ω—É—Ç—Ä–∏ –º–æ–¥—É–ª–µ–π –º–æ–∂–Ω–æ –∏–º–µ—Ç—å –¥—Ä—É–≥–∏–µ –º–æ–¥—É–ª–∏, –∫–∞–∫ –º—ã —ç—Ç–æ —Å–¥–µ–ª–∞–ª–∏ —Å –º–æ–¥—É–ª—è–º–∏ <code>hosting</code> –∏ <code>serving</code>. –ú–æ–¥—É–ª–∏ —Ç–∞–∫–∂–µ –º–æ–≥—É—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –¥—Ä—É–≥–∏—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤, —Ç–∞–∫–∏—Ö –∫–∞–∫ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è, –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã, —Ç—Ä–µ–π—Ç—ã –∏–ª–∏ (–∫–∞–∫ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 7-1) —Ñ—É–Ω–∫—Ü–∏–∏.</p>
<p>–ò—Å–ø–æ–ª—å–∑—É—è –º–æ–¥—É–ª–∏, –º—ã –º–æ–∂–µ–º –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∞—Ç—å —Ä–æ–¥—Å—Ç–≤–µ–Ω–Ω—ã–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –≤–º–µ—Å—Ç–µ –∏ –ø–æ—è—Å–Ω—è—Ç—å, –≤ —á—ë–º –æ–Ω–∏ —è–≤–ª—è—é—Ç—Å—è —Ä–æ–¥—Å—Ç–≤–µ–Ω–Ω—ã–º–∏. –ü—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç–∞–º –±—É–¥–µ—Ç –ª–µ–≥—á–µ –Ω–∞–π—Ç–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º—É—é —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å –≤ —Å–≥—Ä—É–ø–ø–∏—Ä–æ–≤–∞–Ω–Ω–æ–º –∫–æ–¥–µ, –≤–º–µ—Å—Ç–æ —Ç–æ–≥–æ —á—Ç–æ–±—ã –∏—Å–∫–∞—Ç—å –µ—ë –≤ –æ–¥–Ω–æ–º –æ–±—â–µ–º —Å–ø–∏—Å–∫–µ. –ü—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç—ã, –¥–æ–±–∞–≤–ª—è—é—â–∏–µ –Ω–æ–≤—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –≤ —ç—Ç–æ—Ç –∫–æ–¥, –±—É–¥—É—Ç –∑–Ω–∞—Ç—å, –≥–¥–µ —Ä–∞–∑–º–µ—Å—Ç–∏—Ç—å –∫–æ–¥ –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∞–Ω–∏—è –ø–æ—Ä—è–¥–∫–∞ –≤ –ø—Ä–æ–≥—Ä–∞–º–º–µ.</p>
<p>Earlier, we mentioned that <em>src/main.rs</em> and <em>src/lib.rs</em> are called crate roots. The reason for their name is that the contents of either of these two files form a module named <code>crate</code> at the root of the crate‚Äôs module structure, known as the <em>module tree</em>.</p>
<p>–í –õ–∏—Å—Ç–∏–Ω–≥–µ 7-2 –ø–æ–∫–∞–∑–∞–Ω–æ –¥–µ—Ä–µ–≤–æ –º–æ–¥—É–ª–µ–π –¥–ª—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –º–æ–¥—É–ª–µ–π, –ø—Ä–∏–≤–µ–¥—ë–Ω–Ω–æ–π –≤ –∫–æ–¥–µ –õ–∏—Å—Ç–∏–Ω–≥–∞ 7-1.</p>
<Listing number="7-2" caption="The module tree for the code in Listing 7-1">
<pre><code class="language-text">crate
 ‚îî‚îÄ‚îÄ front_of_house
     ‚îú‚îÄ‚îÄ hosting
     ‚îÇ   ‚îú‚îÄ‚îÄ add_to_waitlist
     ‚îÇ   ‚îî‚îÄ‚îÄ seat_at_table
     ‚îî‚îÄ‚îÄ serving
         ‚îú‚îÄ‚îÄ take_order
         ‚îú‚îÄ‚îÄ serve_order
         ‚îî‚îÄ‚îÄ take_payment
</code></pre>
</Listing>
<p>–≠—Ç–æ –¥–µ—Ä–µ–≤–æ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç, –∫–∞–∫ –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –∏–∑ –º–æ–¥—É–ª–µ–π –≤–∫–ª–∞–¥—ã–≤–∞—é—Ç—Å—è –¥—Ä—É–≥ –≤ –¥—Ä—É–≥–∞; –Ω–∞–ø—Ä–∏–º–µ—Ä, <code>hosting</code> –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤–Ω—É—Ç—Ä–∏ <code>front_of_house</code>. –î–µ—Ä–µ–≤–æ —Ç–∞–∫–∂–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç, —á—Ç–æ –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –º–æ–¥—É–ª–∏ —è–≤–ª—è—é—Ç—Å—è "–±—Ä–∞—Ç—å—è–º–∏", —Ç–æ –µ—Å—Ç—å –æ–Ω–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω—ã –≤ –æ–¥–Ω–æ–º –º–æ–¥—É–ª–µ; <code>hosting</code> –∏ <code>serving</code> ‚Äî —ç—Ç–æ "–±—Ä–∞—Ç—å—è", –∫–æ—Ç–æ—Ä—ã–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω—ã –≤–Ω—É—Ç—Ä–∏ <code>front_of_house</code>. –ï—Å–ª–∏ –º–æ–¥—É–ª—å A —Å–æ–¥–µ—Ä–∂–∏—Ç—Å—è –≤–Ω—É—Ç—Ä–∏ –º–æ–¥—É–ª—è B, –º—ã –≥–æ–≤–æ—Ä–∏–º, —á—Ç–æ –º–æ–¥—É–ª—å A —è–≤–ª—è–µ—Ç—Å—è <em>–ø–æ—Ç–æ–º–∫–æ–º</em> –º–æ–¥—É–ª—è B, –∞ –º–æ–¥—É–ª—å B —è–≤–ª—è–µ—Ç—Å—è <em>—Ä–æ–¥–∏—Ç–µ–ª–µ–º</em> –º–æ–¥—É–ª—è A. –û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ —Ä–æ–¥–∏—Ç–µ–ª–µ–º –≤—Å–µ–≥–æ –¥–µ—Ä–µ–≤–∞ –º–æ–¥—É–ª–µ–π —è–≤–ª—è–µ—Ç—Å—è –Ω–µ—è–≤–Ω—ã–π –º–æ–¥—É–ª—å —Å –∏–º–µ–Ω–µ–º <code>crate</code>.</p>
<p>–î–µ—Ä–µ–≤–æ –º–æ–¥—É–ª–µ–π –º–æ–∂–µ—Ç –Ω–∞–ø–æ–º–Ω–∏—Ç—å –≤–∞–º –¥–µ—Ä–µ–≤–æ —Ñ–∞–π–ª–æ–≤–æ–π —Å–∏—Å—Ç–µ–º—ã –Ω–∞ –∫–æ–º–ø—å—é—Ç–µ—Ä–µ; —ç—Ç–æ –æ—á–µ–Ω—å —É–¥–∞—á–Ω–æ–µ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ! –ü–æ –∞–Ω–∞–ª–æ–≥–∏–∏ —Å —Ñ–∞–π–ª–æ–≤–æ–π —Å–∏—Å—Ç–µ–º–æ–π, –º–æ–¥—É–ª–∏ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –¥–ª—è –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ –∫–æ–¥–∞. –ò —Ç–∞–∫ –∂–µ, –∫–∞–∫ –Ω–∞–º –Ω–∞–¥–æ –∏—Å–∫–∞—Ç—å —Ñ–∞–π–ª—ã –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è—Ö, –Ω–∞–º —Ç—Ä–µ–±—É–µ—Ç—Å—è —Å–ø–æ—Å–æ–± –ø–æ–∏—Å–∫–∞ –Ω—É–∂–Ω—ã—Ö –º–æ–¥—É–ª–µ–π.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–ü—É—Ç–∏-–¥–ª—è-—Å—Å—ã–ª–∫–∏-–Ω–∞-—ç–ª–µ–º–µ–Ω—Ç-–≤-–¥–µ—Ä–µ–≤–µ-–º–æ–¥—É–ª–µ–π"><a class="header" href="#–ü—É—Ç–∏-–¥–ª—è-—Å—Å—ã–ª–∫–∏-–Ω–∞-—ç–ª–µ–º–µ–Ω—Ç-–≤-–¥–µ—Ä–µ–≤–µ-–º–æ–¥—É–ª–µ–π">–ü—É—Ç–∏ –¥–ª—è —Å—Å—ã–ª–∫–∏ –Ω–∞ —ç–ª–µ–º–µ–Ω—Ç –≤ –¥–µ—Ä–µ–≤–µ –º–æ–¥—É–ª–µ–π</a></h2>
<p>–ß—Ç–æ–±—ã –ø–æ–∫–∞–∑–∞—Ç—å Rust, –≥–¥–µ –∏—Å–∫–∞—Ç—å —ç–ª–µ–º–µ–Ω—Ç –≤ –¥–µ—Ä–µ–≤–µ –º–æ–¥—É–ª–µ–π, –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—É—Ç—å: —Ç–∞–∫ –∂–µ, –∫–∞–∫ –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—É—Ç—å –ø—Ä–∏ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ –ø–æ —Ñ–∞–π–ª–æ–≤–æ–π —Å–∏—Å—Ç–µ–º–µ. –ß—Ç–æ–±—ã –≤—ã–∑–≤–∞—Ç—å —Ñ—É–Ω–∫—Ü–∏—é, –Ω–∞–º –Ω—É–∂–Ω–æ –∑–Ω–∞—Ç—å –µ—ë –ø—É—Ç—å.</p>
<p>–ü—É—Ç–∏ –±—ã–≤–∞—é—Ç –¥–≤—É—Ö –≤–∏–¥–æ–≤:</p>
<ul>
<li><em>–ê–±—Å–æ–ª—é—Ç–Ω—ã–π –ø—É—Ç—å</em> ‚Äî —ç—Ç–æ –ø–æ–ª–Ω—ã–π –ø—É—Ç—å, –Ω–∞—á–∏–Ω–∞—é—â–∏–π—Å—è –æ—Ç –∫–æ—Ä–Ω—è –∫—Ä–µ–π—Ç–∞; –¥–ª—è –∫–æ–¥–∞ –∏–∑ –≤–Ω–µ—à–Ω–µ–≥–æ –∫—Ä–µ–π—Ç–∞ –∞–±—Å–æ–ª—é—Ç–Ω—ã–π –ø—É—Ç—å –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å –∏–º–µ–Ω–∏ –∫—Ä–µ–π—Ç–∞, –∞ –¥–ª—è –∫–æ–¥–∞ –∏–∑ —Ç–µ–∫—É—â–µ–≥–æ –∫—Ä–µ–π—Ç–∞ –æ–Ω –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å–æ —Å–ª–æ–≤–∞ <code>crate</code>.</li>
<li><em>–û—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø—É—Ç—å</em> ‚Äî —ç—Ç–æ –ø—É—Ç—å, –Ω–∞—á–∏–Ω–∞—é—â–∏–π—Å—è —Å —Ç–µ–∫—É—â–µ–≥–æ –º–æ–¥—É–ª—è –∏ –∏—Å–ø–æ–ª—å–∑—É—é—â–∏–π –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ <code>self</code> –∏ <code>super</code> –∏–ª–∏ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –≤ —Ç–µ–∫—É—â–µ–º –º–æ–¥—É–ª–µ.</li>
</ul>
<p>–ö–∞–∫ –∞–±—Å–æ–ª—é—Ç–Ω—ã–µ, —Ç–∞–∫ –∏ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–µ –ø—É—Ç–∏ —Å–æ—Å—Ç–æ—è—Ç –∏–∑ –æ–¥–Ω–æ–≥–æ –∏–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–æ–≤, —Ä–∞–∑–¥–µ–ª—è–µ–º—ã—Ö –¥–≤–æ–π–Ω—ã–º–∏ –¥–≤–æ–µ—Ç–æ—á–∏—è–º–∏ (<code>::</code>).</p>
<p>–í–µ—Ä–Ω—ë–º—Å—è –∫ –õ–∏—Å—Ç–∏–Ω–≥—É 7-1. –°–∫–∞–∂–µ–º, –º—ã —Ö–æ—Ç–∏–º –≤—ã–∑–≤–∞—Ç—å —Ñ—É–Ω–∫—Ü–∏—é <code>add_to_waitlist</code>. –≠—Ç–æ —Ç–æ –∂–µ —Å–∞–º–æ–µ, —á—Ç–æ —Å–ø—Ä–æ—Å–∏—Ç—å: –∫–∞–∫–æ–π –ø—É—Ç—å –¥–æ —Ñ—É–Ω–∫—Ü–∏–∏ <code>add_to_waitlist</code>? –í –õ–∏—Å—Ç–∏–Ω–≥–µ 7-3 –º—ã –Ω–µ–º–Ω–æ–≥–æ —É–ø—Ä–æ—Å—Ç–∏–ª–∏ –∫–æ–¥ –õ–∏—Å—Ç–∏–Ω–≥–∞ 7-1, —É–¥–∞–ª–∏–≤ –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –º–æ–¥—É–ª–∏ –∏ —Ñ—É–Ω–∫—Ü–∏–∏.</p>
<p>–ú—ã –ø–æ–∫–∞–∂–µ–º –¥–≤–∞ —Å–ø–æ—Å–æ–±–∞ –≤—ã–∑–æ–≤–∞ —Ñ—É–Ω–∫—Ü–∏–∏ <code>add_to_waitlist</code> –∏–∑ –Ω–æ–≤–æ–π —Ñ—É–Ω–∫—Ü–∏–∏  <code>eat_at_restaurant</code>, –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–π –≤ –∫–æ—Ä–Ω–µ –∫—Ä–µ–π—Ç–∞. –≠—Ç–∏ –ø—É—Ç–∏ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ, –Ω–æ –æ—Å—Ç–∞—ë—Ç—Å—è –µ—â—ë –æ–¥–Ω–∞ –ø—Ä–æ–±–ª–µ–º–∞, –∫–æ—Ç–æ—Ä–∞—è –Ω–µ –ø–æ–∑–≤–æ–ª–∏—Ç —ç—Ç–æ–º—É –ø—Ä–∏–º–µ—Ä—É —Å–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞—Ç—å—Å—è –∫–∞–∫ –µ—Å—Ç—å. –ú—ã —Å–∫–æ—Ä–æ –æ–±—ä—è—Å–Ω–∏–º, –∫–∞–∫–∞—è –∏–º–µ–Ω–Ω–æ.</p>
<p>–§—É–Ω–∫—Ü–∏—è <code>eat_at_restaurant</code> —è–≤–ª—è–µ—Ç—Å—è —á–∞—Å—Ç—å—é –æ–±—â–µ–¥–æ—Å—Ç—É–ø–Ω–æ–≥–æ API –Ω–∞—à–µ–≥–æ –±–∏–±–ª–∏–æ—Ç–µ—á–Ω–æ–≥–æ –∫—Ä–µ–π—Ç–∞, –ø–æ—ç—Ç–æ–º—É –º—ã –ø–æ–º–µ—á–∞–µ–º –µ—ë –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–æ–º <code>pub</code>. –í —Ä–∞–∑–¥–µ–ª–µ <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#%D0%A0%D0%B0%D1%81%D0%BA%D1%80%D1%8B%D1%82%D0%B8%D0%B5-%D0%BF%D1%83%D1%82%D0%B5%D0%B9-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D0%BE%D0%B3%D0%BE-%D1%81%D0%BB%D0%BE%D0%B2%D0%B0-pub">"–†–∞—Å–∫—Ä—ã—Ç–∏–µ –ø—É—Ç–µ–π —Å –ø–æ–º–æ—â—å—é –∫–ª—é—á–µ–≤–æ–≥–æ —Å–ª–æ–≤–∞ <code>pub</code>"</a><!-- ignore --> –º—ã —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º <code>pub</code> –±–æ–ª–µ–µ –ø–æ–¥—Ä–æ–±–Ω–æ.</p>
<Listing number="7-3" file-name="src/lib.rs" caption="Calling the `add_to_waitlist` function using absolute and relative paths">
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // –ê–±—Å–æ–ª—é—Ç–Ω—ã–π –ø—É—Ç—å
    crate::front_of_house::hosting::add_to_waitlist();

    // –û—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø—É—Ç—å
    front_of_house::hosting::add_to_waitlist();
}</code></pre>
</Listing>
<p>–í –ø–µ—Ä–≤–æ–º –≤—ã–∑–æ–≤–µ —Ñ—É–Ω–∫—Ü–∏–∏ <code>add_to_waitlist</code> –∏–∑ <code>eat_at_restaurant</code> –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º –∞–±—Å–æ–ª—é—Ç–Ω—ã–π –ø—É—Ç—å. –§—É–Ω–∫—Ü–∏—è <code>add_to_waitlist</code> –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ –≤ —Ç–æ–º –∂–µ –∫—Ä–µ–π—Ç–µ, —á—Ç–æ –∏ <code>eat_at_restaurant</code>, –∏ —ç—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –º—ã –º–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ <code>crate</code> –≤ –Ω–∞—á–∞–ª–µ –∞–±—Å–æ–ª—é—Ç–Ω–æ–≥–æ –ø—É—Ç–∏. –ó–∞—Ç–µ–º –º—ã –ø–æ–¥–∫–ª—é—á–∞–µ–º –∫–∞–∂–¥—ã–π –∏–∑ –ø–æ—Å–ª–µ–¥—É—é—â–∏—Ö –¥–æ—á–µ—Ä–Ω–∏—Ö –º–æ–¥—É–ª–µ–π, –ø–æ–∫–∞ –Ω–µ —Å–æ—Å—Ç–∞–≤–∏–º –ø—É—Ç—å –¥–æ <code>add_to_waitlist</code>. –í—ã –º–æ–∂–µ—Ç–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–∏—Ç—å —Å–µ–±–µ —Ñ–∞–π–ª–æ–≤—É—é —Å–∏—Å—Ç–µ–º—É —Å —Ç–∞–∫–æ–π –∂–µ —Å—Ç—Ä—É–∫—Ç—É—Ä–æ–π: –º—ã —É–∫–∞–∑—ã–≤–∞–µ–º –ø—É—Ç—å <code>/front_of_house/hosting/add_to_waitlist</code> –¥–ª—è –∑–∞–ø—É—Å–∫–∞ –ø—Ä–æ–≥—Ä–∞–º–º—ã <code>add_to_waitlist</code>; –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∏–º–µ–Ω–∏ <code>crate</code> –≤ –∫–∞—á–µ—Å—Ç–≤–µ –∫–æ—Ä–Ω—è –∫—Ä–µ–π—Ç–∞ –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é <code>/</code> –¥–ª—è —É–∫–∞–∑–∞–Ω–∏—è –∫–æ—Ä–Ω—è —Ñ–∞–π–ª–æ–≤–æ–π —Å–∏—Å—Ç–µ–º—ã –≤ –≤–∞—à–µ–π –æ–±–æ–ª–æ—á–∫–µ (shell).</p>
<p>–í–æ –≤—Ç–æ—Ä–æ–º –≤—ã–∑–æ–≤–µ <code>add_to_waitlist</code> –∏–∑ <code>eat_at_restaurant</code> –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø—É—Ç—å. –ü—É—Ç—å –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å –∏–º–µ–Ω–∏ –º–æ–¥—É–ª—è <code>front_of_house</code>, –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–≥–æ –Ω–∞ —Ç–æ–º –∂–µ —É—Ä–æ–≤–Ω–µ –¥–µ—Ä–µ–≤–∞ –º–æ–¥—É–ª–µ–π, —á—Ç–æ –∏ <code>eat_at_restaurant</code>. –ê–Ω–∞–ª–æ–≥–æ–º –ø—É—Ç–∏ –≤ —Ñ–∞–π–ª–æ–≤–æ–π —Å–∏—Å—Ç–µ–º–µ –±—ã–ª–æ –±—ã <code>front_of_house/hosting/add_to_waitlist</code>. –ù–∞—á–∞–ª–æ –ø—É—Ç–∏ —Å –∏–º–µ–Ω–∏ –º–æ–¥—É–ª—è –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –ø—É—Ç—å —è–≤–ª—è–µ—Ç—Å—è –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–º.</p>
<p>–í—ã–±–æ—Ä, –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –∏–ª–∏ –∞–±—Å–æ–ª—é—Ç–Ω—ã–π –ø—É—Ç—å, —è–≤–ª—è–µ—Ç—Å—è —Ä–µ—à–µ–Ω–∏–µ–º, –∫–æ—Ç–æ—Ä–æ–µ –≤—ã –ø—Ä–∏–º–µ—Ç–µ –Ω–∞ –æ—Å–Ω–æ–≤–∞–Ω–∏–∏ –≤–∞—à–µ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞. –†–µ—à–µ–Ω–∏–µ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Ç–æ–≥–æ, —Å –∫–∞–∫–æ–π –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å—é –≤—ã –ø–µ—Ä–µ–º–µ—Å—Ç–∏—Ç–µ –æ–±—ä—è–≤–ª–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–∞ –æ—Ç–¥–µ–ª—å–Ω–æ –æ—Ç –∏–ª–∏ –≤–º–µ—Å—Ç–µ —Å –∫–æ–¥–æ–º, –∏—Å–ø–æ–ª—å–∑—É—é—â–∏–º —ç—Ç–æ—Ç —ç–ª–µ–º–µ–Ω—Ç. –ù–∞–ø—Ä–∏–º–µ—Ä, –≤ —Å–ª—É—á–∞–µ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è –º–æ–¥—É–ª—è <code>front_of_house</code> –∏ –µ–≥–æ —Ñ—É–Ω–∫—Ü–∏–∏ <code>eat_at_restaurant</code> –≤ –¥—Ä—É–≥–æ–π –º–æ–¥—É–ª—å —Å –∏–º–µ–Ω–µ–º <code>customer_experience</code>, –±—É–¥–µ—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –æ–±–Ω–æ–≤–∏—Ç—å –∞–±—Å–æ–ª—é—Ç–Ω—ã–π –ø—É—Ç—å –¥–æ <code>add_to_waitlist</code>, –Ω–æ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø—É—Ç—å –≤—Å—ë —Ä–∞–≤–Ω–æ –±—É–¥–µ—Ç –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω. –û–¥–Ω–∞–∫–æ, –µ—Å–ª–∏ –º—ã –ø–µ—Ä–µ–º–µ—Å—Ç–∏–º –æ—Ç–¥–µ–ª—å–Ω–æ —Ñ—É–Ω–∫—Ü–∏—é <code>eat_at_restaurant</code> –≤ –º–æ–¥—É–ª—å —Å –∏–º–µ–Ω–µ–º <code>dining</code>, —Ç–æ –∞–±—Å–æ–ª—é—Ç–Ω—ã–π –ø—É—Ç—å –≤—ã–∑–æ–≤–∞ <code>add_to_waitlist</code> –æ—Å—Ç–∞–Ω–µ—Ç—Å—è –ø—Ä–µ–∂–Ω–∏–º, –∞ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø—É—Ç—å –Ω—É–∂–Ω–æ –±—É–¥–µ—Ç –æ–±–Ω–æ–≤–∏—Ç—å. –ú—ã –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ–º —É–∫–∞–∑—ã–≤–∞—Ç—å –∞–±—Å–æ–ª—é—Ç–Ω—ã–µ –ø—É—Ç–∏, –ø–æ—Ç–æ–º—É —á—Ç–æ —ç—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç –ø—Ä–æ—â–µ –ø–µ—Ä–µ–º–µ—â–∞—Ç—å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –∫–æ–¥–∞ –∏ –≤—ã–∑–æ–≤—ã —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –¥—Ä—É–≥ –æ—Ç –¥—Ä—É–≥–∞.</p>
<p>–î–∞–≤–∞–π—Ç–µ –ø–æ–ø—Ä–æ–±—É–µ–º —Å–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞—Ç—å –∫–æ–¥ –∏–∑ –õ–∏—Å—Ç–∏–Ω–≥–∞ 7-3 –∏ –≤—ã—è—Å–Ω–∏—Ç—å, –ø–æ—á–µ–º—É –æ–Ω –≤—Å—ë –µ—â—ë –Ω–µ –∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è. –û—à–∏–±–∫–∞, –∫–æ—Ç–æ—Ä—É—é –º—ã –ø–æ–ª—É—á–∞–µ–º, –ø–æ–∫–∞–∑–∞–Ω–∞ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 7-4.</p>
<Listing number="7-4" caption="Compiler errors from building the code in Listing 7-3">
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `hosting` is private
 --&gt; src/lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^  --------------- function `add_to_waitlist` is not publicly re-exported
  |                            |
  |                            private module
  |
note: the module `hosting` is defined here
 --&gt; src/lib.rs:2:5
  |
2 |     mod hosting {
  |     ^^^^^^^^^^^

error[E0603]: module `hosting` is private
  --&gt; src/lib.rs:12:21
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^  --------------- function `add_to_waitlist` is not publicly re-exported
   |                     |
   |                     private module
   |
note: the module `hosting` is defined here
  --&gt; src/lib.rs:2:5
   |
2  |     mod hosting {
   |     ^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` (lib) due to 2 previous errors
</code></pre>
</Listing>
<p>–°–æ–æ–±—â–µ–Ω–∏—è –æ–± –æ—à–∏–±–∫–∞—Ö –≥–æ–≤–æ—Ä—è—Ç –æ —Ç–æ–º, —á—Ç–æ –º–æ–¥—É–ª—å <code>hosting</code> —è–≤–ª—è–µ—Ç—Å—è –ø—Ä–∏–≤–∞—Ç–Ω—ã–º. –î—Ä—É–≥–∏–º–∏ —Å–ª–æ–≤–∞–º–∏, —É –Ω–∞—Å –µ—Å—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ –ø—É—Ç–∏ –∫ –º–æ–¥—É–ª—é <code>hosting</code> –∏ —Ñ—É–Ω–∫—Ü–∏–∏ <code>add_to_waitlist</code>, –Ω–æ Rust –Ω–µ –ø–æ–∑–≤–æ–ª—è–µ—Ç –Ω–∞–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏—Ö, –ø–æ—Ç–æ–º—É —á—Ç–æ —É –Ω–µ–≥–æ –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ –ø—Ä–∏–≤–∞—Ç–Ω—ã–º –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è–º. –í Rust –≤—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã (—Ñ—É–Ω–∫—Ü–∏–∏, –º–µ—Ç–æ–¥—ã, —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è, –º–æ–¥—É–ª–∏ –∏ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã) –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é —è–≤–ª—è—é—Ç—Å—è –∑–∞–∫—Ä—ã—Ç—ã–º–∏ –¥–ª—è —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–∏—Ö –º–æ–¥—É–ª–µ–π. –ï—Å–ª–∏ –≤—ã —Ö–æ—Ç–∏—Ç–µ —Å–¥–µ–ª–∞—Ç—å —ç–ª–µ–º–µ–Ω—Ç (–Ω–∞–ø—Ä–∏–º–µ—Ä, —Ñ—É–Ω–∫—Ü–∏—é –∏–ª–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—É) –ø—Ä–∏–≤–∞—Ç–Ω—ã–º, –≤—ã –ø–æ–º–µ—â–∞–µ—Ç–µ –µ–≥–æ –≤ –º–æ–¥—É–ª—å.</p>
<p>–≠–ª–µ–º–µ–Ω—Ç—ã –≤ —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–æ–º –º–æ–¥—É–ª–µ –Ω–µ –º–æ–≥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø—Ä–∏–≤–∞—Ç–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤–Ω—É—Ç—Ä–∏ –¥–æ—á–µ—Ä–Ω–∏—Ö –º–æ–¥—É–ª–µ–π, –Ω–æ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ –¥–æ—á–µ—Ä–Ω–∏—Ö –º–æ–¥—É–ª—è—Ö –º–æ–≥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç–ª–µ–º–µ–Ω—Ç—ã —Å–≤–æ–∏—Ö –º–æ–¥—É–ª–µ–π-–ø—Ä–µ–¥–∫–æ–≤. –≠—Ç–æ —Å–≤—è–∑–∞–Ω–æ —Å —Ç–µ–º, —á—Ç–æ –¥–æ—á–µ—Ä–Ω–∏–µ –º–æ–¥—É–ª–∏ –æ–±–æ—Ä–∞—á–∏–≤–∞—é—Ç –∏ —Å–∫—Ä—ã–≤–∞—é—Ç –¥–µ—Ç–∞–ª–∏ —Å–≤–æ–µ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏, –Ω–æ –¥–æ—á–µ—Ä–Ω–∏–µ –º–æ–¥—É–ª–∏ –º–æ–≥—É—Ç –≤–∏–¥–µ—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç, –≤ –∫–æ—Ç–æ—Ä–æ–º –æ–Ω–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω—ã. –ü—Ä–æ–¥–æ–ª–∂–∞—è –Ω–∞—à—É –º–µ—Ç–∞—Ñ–æ—Ä—É, –ø–æ–¥—É–º–∞–π—Ç–µ –æ –ø—Ä–∞–≤–∏–ª–∞—Ö –ø—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç–∏ –∫–∞–∫ –æ –∑–∞–¥–Ω–µ–π —á–∞—Å—Ç–∏ —Ä–µ—Å—Ç–æ—Ä–∞–Ω–∞: —Ç–æ, —á—Ç–æ —Ç–∞–º –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç, —Å–∫—Ä—ã—Ç–æ –æ—Ç –∫–ª–∏–µ–Ω—Ç–æ–≤ —Ä–µ—Å—Ç–æ—Ä–∞–Ω–∞, –Ω–æ –æ—Ñ–∏—Å-–º–µ–Ω–µ–¥–∂–µ—Ä—ã –º–æ–≥—É—Ç –≤–∏–¥–µ—Ç—å –∏ –¥–µ–ª–∞—Ç—å –≤—Å—ë –≤ —Ä–µ—Å—Ç–æ—Ä–∞–Ω–µ, –∫–æ—Ç–æ—Ä—ã–º –æ–Ω–∏ —É–ø—Ä–∞–≤–ª—è—é—Ç.</p>
<p>–í Rust —Ä–µ—à–∏–ª–∏, —á—Ç–æ —Å–∏—Å—Ç–µ–º–∞ –º–æ–¥—É–ª–µ–π –¥–æ–ª–∂–Ω–∞ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞—Ç—å —Ç–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, —á—Ç–æ–±—ã –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é —Å–∫—Ä—ã–≤–∞—Ç—å –¥–µ—Ç–∞–ª–∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏. –¢–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, –≤—ã –∑–Ω–∞–µ—Ç–µ, –∫–∞–∫–∏–µ —á–∞—Å—Ç–∏ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–≥–æ –∫–æ–¥–∞ –≤—ã –º–æ–∂–µ—Ç–µ –º–µ–Ω—è—Ç—å, –Ω–µ –Ω–∞—Ä—É—à–∞—è —Ä–∞–±–æ—Ç—ã –≤–Ω–µ—à–Ω–µ–≥–æ –∫–æ–¥–∞. –¢–µ–º –Ω–µ –º–µ–Ω–µ–µ, Rust –¥–∞—ë—Ç –Ω–∞–º –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –æ—Ç–∫—Ä—ã–≤–∞—Ç—å –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ —á–∞—Å—Ç–∏ –∫–æ–¥–∞ –¥–æ—á–µ—Ä–Ω–∏—Ö –º–æ–¥—É–ª–µ–π –¥–ª—è –≤–Ω–µ—à–Ω–∏—Ö –º–æ–¥—É–ª–µ–π-–ø—Ä–µ–¥–∫–æ–≤, –∏—Å–ø–æ–ª—å–∑—É—è –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ <code>pub</code>, —á—Ç–æ–±—ã –¥–µ–ª–∞—Ç—å —ç–ª–µ–º–µ–Ω—Ç –æ–±—â–µ–¥–æ—Å—Ç—É–ø–Ω—ã–º.</p>
<h3 id="–†–∞—Å–∫—Ä—ã—Ç–∏–µ-–ø—É—Ç–µ–π-—Å-–ø–æ–º–æ—â—å—é-–∫–ª—é—á–µ–≤–æ–≥–æ-—Å–ª–æ–≤–∞-pub"><a class="header" href="#–†–∞—Å–∫—Ä—ã—Ç–∏–µ-–ø—É—Ç–µ–π-—Å-–ø–æ–º–æ—â—å—é-–∫–ª—é—á–µ–≤–æ–≥–æ-—Å–ª–æ–≤–∞-pub">–†–∞—Å–∫—Ä—ã—Ç–∏–µ –ø—É—Ç–µ–π —Å –ø–æ–º–æ—â—å—é –∫–ª—é—á–µ–≤–æ–≥–æ —Å–ª–æ–≤–∞ <code>pub</code></a></h3>
<p>–î–∞–≤–∞–π—Ç–µ –≤–µ—Ä–Ω—ë–º—Å—è –∫ –æ—à–∏–±–∫–µ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 7-4, –∫–æ—Ç–æ—Ä–∞—è –≥–æ–≤–æ—Ä–∏—Ç, —á—Ç–æ –º–æ–¥—É–ª—å <code>hosting</code> —è–≤–ª—è–µ—Ç—Å—è –ø—Ä–∏–≤–∞—Ç–Ω—ã–º. –ú—ã —Ö–æ—Ç–∏–º, —á—Ç–æ–±—ã —Ñ—É–Ω–∫—Ü–∏—è <code>eat_at_restaurant</code> –∏–∑ —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–æ–≥–æ –º–æ–¥—É–ª—è –∏–º–µ–ª–∞ –¥–æ—Å—Ç—É–ø –∫ —Ñ—É–Ω–∫—Ü–∏–∏ <code>add_to_waitlist</code> –≤ –¥–æ—á–µ—Ä–Ω–µ–º –º–æ–¥—É–ª–µ, –ø–æ—ç—Ç–æ–º—É –º—ã –ø–æ–º–µ—á–∞–µ–º –º–æ–¥—É–ª—å <code>hosting</code> –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–æ–º <code>pub</code>, –∫–∞–∫ –ø–æ–∫–∞–∑–∞–Ω–æ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 7-5.</p>
<Listing number="7-5" file-name="src/lib.rs" caption="Declaring the `hosting` module as `pub` to use it from `eat_at_restaurant`">
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

// -- –∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω --
<span class="boring">pub fn eat_at_restaurant() {
</span><span class="boring">    // –ê–±—Å–æ–ª—é—Ç–Ω—ã–π –ø—É—Ç—å
</span><span class="boring">    crate::front_of_house::hosting::add_to_waitlist();
</span><span class="boring">
</span><span class="boring">    // –û—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø—É—Ç—å
</span><span class="boring">    front_of_house::hosting::add_to_waitlist();
</span><span class="boring">}</span></code></pre>
</Listing>
<p>–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –∫–æ–¥ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 7-5 –≤—Å—ë –µ—â—ë –ø—Ä–∏–≤–æ–¥–∏—Ç –∫ –æ—à–∏–±–∫–µ, –ø–æ–∫–∞–∑–∞–Ω–Ω–æ–π –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 7-6.</p>
<Listing number="7-6" caption="Compiler errors from building the code in Listing 7-5">
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: function `add_to_waitlist` is private
 --&gt; src/lib.rs:9:37
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                                     ^^^^^^^^^^^^^^^ private function
  |
note: the function `add_to_waitlist` is defined here
 --&gt; src/lib.rs:3:9
  |
3 |         fn add_to_waitlist() {}
  |         ^^^^^^^^^^^^^^^^^^^^

error[E0603]: function `add_to_waitlist` is private
  --&gt; src/lib.rs:12:30
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                              ^^^^^^^^^^^^^^^ private function
   |
note: the function `add_to_waitlist` is defined here
  --&gt; src/lib.rs:3:9
   |
3  |         fn add_to_waitlist() {}
   |         ^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` (lib) due to 2 previous errors
</code></pre>
</Listing>
<p>–ß—Ç–æ –ø—Ä–æ–∏–∑–æ—à–ª–æ? –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∫–ª—é—á–µ–≤–æ–≥–æ —Å–ª–æ–≤–∞ <code>pub</code> –ø–µ—Ä–µ–¥ <code>mod hosting</code> —Å–¥–µ–ª–∞–ª–æ –º–æ–¥—É–ª—å –æ–±—â–µ–¥–æ—Å—Ç—É–ø–Ω—ã–º. –ü–æ—Å–ª–µ —ç—Ç–æ–≥–æ –∏–∑–º–µ–Ω–µ–Ω–∏—è, –µ—Å–ª–∏ –º—ã –º–æ–∂–µ–º –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –º–æ–¥—É–ª—é <code>front_of_house</code>, —Ç–æ –º—ã –º–æ–∂–µ–º –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –º–æ–¥—É–ª—é <code>hosting</code>. –ù–æ <em>—Å–æ–¥–µ—Ä–∂–∏–º–æ–µ</em> –º–æ–¥—É–ª—è <code>hosting</code> –≤—Å—ë –µ—â—ë —è–≤–ª—è–µ—Ç—Å—è –ø—Ä–∏–≤–∞—Ç–Ω—ã–º: –ø—Ä–µ–≤—Ä–∞—â–µ–Ω–∏–µ –º–æ–¥—É–ª—è –≤ –æ–±—â–µ–¥–æ—Å—Ç—É–ø–Ω—ã–π –º–æ–¥—É–ª—å –Ω–µ –¥–µ–ª–∞–µ—Ç –µ–≥–æ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –æ–±—â–µ–¥–æ—Å—Ç—É–ø–Ω—ã–º. –ö–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ <code>pub</code> –ø–æ–∑–≤–æ–ª—è–µ—Ç –≤–Ω–µ—à–Ω–µ–º—É –∫–æ–¥—É –≤ –º–æ–¥—É–ª—è—Ö-–ø—Ä–µ–¥–∫–∞—Ö –æ–±—Ä–∞—â–∞—Ç—å—Å—è —Ç–æ–ª—å–∫–æ –∫ –º–æ–¥—É–ª—é, –±–µ–∑ –¥–æ—Å—Ç—É–ø–∞ –∫–æ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–º—É –∫–æ–¥—É. –ü–æ—Å–∫–æ–ª—å–∫—É –º–æ–¥—É–ª–∏ —è–≤–ª—è—é—Ç—Å—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞–º–∏, –º—ã –º–∞–ª–æ —á—Ç–æ –º–æ–∂–µ–º —Å–¥–µ–ª–∞—Ç—å, –ø—Ä–æ—Å—Ç–æ —Å–¥–µ–ª–∞–≤ –º–æ–¥—É–ª—å –æ–±—â–µ–¥–æ—Å—Ç—É–ø–Ω—ã–º; –Ω–∞–º –Ω—É–∂–Ω–æ –ø–æ–π—Ç–∏ –¥–∞–ª—å—à–µ –∏ —Å–¥–µ–ª–∞—Ç—å –æ–¥–∏–Ω –∏–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤ –º–æ–¥—É–ª–µ –æ–±—â–µ–¥–æ—Å—Ç—É–ø–Ω—ã–º–∏.</p>
<p>–û—à–∏–±–∫–∏ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 7-6 –≥–æ–≤–æ—Ä—è—Ç, —á—Ç–æ —Ñ—É–Ω–∫—Ü–∏—è <code>add_to_waitlist</code> —è–≤–ª—è–µ—Ç—Å—è –ø—Ä–∏–≤–∞—Ç–Ω–æ–π. –ü—Ä–∞–≤–∏–ª–∞ –ø—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç–∏ –ø—Ä–∏–º–µ–Ω—è—é—Ç—Å—è –∫ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞–º, –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è–º, —Ñ—É–Ω–∫—Ü–∏—è–º –∏ –º–µ—Ç–æ–¥–∞–º, —Ç–∞–∫–∂–µ –∫–∞–∫ –∏ –∫ –º–æ–¥—É–ª—è–º.</p>
<p>–î–∞–≤–∞–π—Ç–µ —Å–¥–µ–ª–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é <code>add_to_waitlist</code> —Ç–∞–∫–∂–µ –æ–±—â–µ–¥–æ—Å—Ç—É–ø–Ω–æ–π, –¥–æ–±–∞–≤–∏–≤ –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ <code>pub</code> –ø–µ—Ä–µ–¥ –µ—ë –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ–º, –∫–∞–∫ –ø–æ–∫–∞–∑–∞–Ω–æ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 7-7.</p>
<Listing number="7-7" file-name="src/lib.rs" caption="Adding the `pub` keyword to `mod hosting` and `fn add_to_waitlist` lets us call the function from `eat_at_restaurant`">
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

// -- –∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω --
<span class="boring">pub fn eat_at_restaurant() {
</span><span class="boring">    // –ê–±—Å–æ–ª—é—Ç–Ω—ã–π –ø—É—Ç—å
</span><span class="boring">    crate::front_of_house::hosting::add_to_waitlist();
</span><span class="boring">
</span><span class="boring">    // –û—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø—É—Ç—å
</span><span class="boring">    front_of_house::hosting::add_to_waitlist();
</span><span class="boring">}</span></code></pre>
</Listing>
<p>–ö–æ–¥ –Ω–∞–∫–æ–Ω–µ—Ü-—Ç–æ –∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è! –ß—Ç–æ–±—ã –ø–æ–Ω—è—Ç—å, –ø–æ—á–µ–º—É –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –∫–ª—é—á–µ–≤–æ–≥–æ —Å–ª–æ–≤–∞ <code>pub</code> –ø–æ–∑–≤–æ–ª—è–µ—Ç –Ω–∞–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç—Ç–∏ –ø—É—Ç–∏ –¥–ª—è <code>add_to_waitlist</code> –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–∏ —Å –ø—Ä–∞–≤–∏–ª–∞–º–∏ –ø—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç–∏, –¥–∞–≤–∞–π—Ç–µ —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º –∞–±—Å–æ–ª—é—Ç–Ω—ã–π –∏ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø—É—Ç–∏.</p>
<p>–í —Å–ª—É—á–∞–µ –∞–±—Å–æ–ª—é—Ç–Ω–æ–≥–æ –ø—É—Ç–∏, –º—ã –Ω–∞—á–∏–Ω–∞–µ–º —Å <code>crate</code>, –∫–æ—Ä–Ω—è –¥–µ—Ä–µ–≤–∞ –º–æ–¥—É–ª–µ–π –Ω–∞—à–µ–≥–æ –∫—Ä–µ–π—Ç–∞. –ú–æ–¥—É–ª—å <code>front_of_house</code> –æ–ø—Ä–µ–¥–µ–ª—ë–Ω –≤ –∫–æ—Ä–Ω–µ –∫—Ä–µ–π—Ç–∞. –•–æ—Ç—è <code>front_of_house</code> –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –æ–±—â–µ–¥–æ—Å—Ç—É–ø–Ω—ã–º, –Ω–æ –ø–æ—Å–∫–æ–ª—å–∫—É —Ñ—É–Ω–∫—Ü–∏—è <code>eat_at_restaurant</code> –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ –≤ —Ç–æ–º –∂–µ –º–æ–¥—É–ª–µ, —á—Ç–æ –∏ <code>front_of_house</code> (—Ç–æ –µ—Å—Ç—å, <code>eat_at_restaurant</code> –∏ <code>front_of_house</code> —è–≤–ª—è—é—Ç—Å—è –ø–æ—Ç–æ–º–∫–∞–º–∏ –æ–¥–Ω–æ–≥–æ —Ä–æ–¥–∏—Ç–µ–ª—è), –º—ã –º–æ–∂–µ–º —Å—Å—ã–ª–∞—Ç—å—Å—è –Ω–∞ <code>front_of_house</code> –∏–∑ <code>eat_at_restaurant</code>. –î–∞–ª–µ–µ –∏–¥—ë—Ç –º–æ–¥—É–ª—å <code>hosting</code>, –ø–æ–º–µ—á–µ–Ω–Ω—ã–π –∫–∞–∫ <code>pub</code>. –ú—ã –º–æ–∂–µ–º –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–æ–º—É –º–æ–¥—É–ª—é –º–æ–¥—É–ª—è <code>hosting</code>, –ø–æ—ç—Ç–æ–º—É –º—ã –º–æ–∂–µ–º –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∏ –∫ <code>hosting</code>. –ù–∞–∫–æ–Ω–µ—Ü, —Ñ—É–Ω–∫—Ü–∏—è <code>add_to_waitlist</code> –ø–æ–º–µ—á–µ–Ω–∞ –∫–∞–∫ <code>pub</code>, –∏ —Ç–∞–∫ –∫–∞–∫ –º—ã –º–æ–∂–µ–º –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –µ—ë —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–æ–º—É –º–æ–¥—É–ª—é, —Ç–æ –≤—ã–∑–æ–≤ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ —Ä–∞–∑—Ä–µ—à—ë–Ω!</p>
<p>–í —Å–ª—É—á–∞–µ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ–≥–æ –ø—É—Ç–∏, –ª–æ–≥–∏–∫–∞ —Ç–∞–∫–∞—è –∂–µ, –∫–∞–∫ –¥–ª—è –∞–±—Å–æ–ª—é—Ç–Ω–æ–≥–æ –ø—É—Ç–∏, –∑–∞ –∏—Å–∫–ª—é—á–µ–Ω–∏–µ–º –ø–µ—Ä–≤–æ–≥–æ —à–∞–≥–∞: –≤–º–µ—Å—Ç–æ —Ç–æ–≥–æ, —á—Ç–æ–±—ã –Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å –∫–æ—Ä–Ω—è –∫—Ä–µ–π—Ç–∞, –ø—É—Ç—å –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å <code>front_of_house</code>. –ú–æ–¥—É–ª—å <code>front_of_house</code> –æ–ø—Ä–µ–¥–µ–ª—ë–Ω –≤ —Ç–æ–º –∂–µ –º–æ–¥—É–ª–µ, —á—Ç–æ –∏ <code>eat_at_restaurant</code>, –ø–æ—ç—Ç–æ–º—É –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø—É—Ç—å, –Ω–∞—á–∏–Ω–∞—é—â–∏–π—Å—è —Å –º–æ–¥—É–ª—è, –≤ –∫–æ—Ç–æ—Ä–æ–º –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ <code>eat_at_restaurant</code>, —Ç–æ–∂–µ —Ä–∞–±–æ—Ç–∞–µ—Ç. –¢–æ–≥–¥–∞ –ø–æ –ø—Ä–∏—á–∏–Ω–µ —Ç–æ–≥–æ, —á—Ç–æ <code>hosting</code> –∏ <code>add_to_waitlist</code> –ø–æ–º–µ—á–µ–Ω—ã –∫–∞–∫ <code>pub</code>, –æ—Å—Ç–∞–ª—å–Ω–∞—è —á–∞—Å—Ç—å –ø—É—Ç–∏ —Ä–∞–±–æ—Ç–∞–µ—Ç –∏ –≤—ã–∑–æ–≤ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ —Ä–∞–∑—Ä–µ—à—ë–Ω!</p>
<p>–ï—Å–ª–∏ –≤—ã –ø–ª–∞–Ω–∏—Ä—É–µ—Ç–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–∏—Ç—å –æ–±—â–∏–π –¥–æ—Å—Ç—É–ø –∫ —Å–≤–æ–µ–º—É –±–∏–±–ª–∏–æ—Ç–µ—á–Ω–æ–º—É –∫—Ä–µ–π—Ç—É, —á—Ç–æ–±—ã –¥—Ä—É–≥–∏–µ –ø—Ä–æ–µ–∫—Ç—ã –º–æ–≥–ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤–∞—à –∫–æ–¥, –ø–æ–º–Ω–∏—Ç–µ: –≤–∞—à –æ–±—â–µ–¥–æ—Å—Ç—É–ø–Ω—ã–π API ‚Äî —ç—Ç–æ –≤–∞—à –∫–æ–Ω—Ç—Ä–∞–∫—Ç —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏ –≤–∞—à–µ–≥–æ –∫—Ä–µ–π—Ç–∞, –æ–ø—Ä–µ–¥–µ–ª—è—é—â–∏–π, –∫–∞–∫ –æ–Ω–∏ –º–æ–≥—É—Ç –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–æ–≤–∞—Ç—å —Å –≤–∞—à–∏–º –∫–æ–¥–æ–º. –ï—Å—Ç—å –º–Ω–æ–≥–æ —Å–æ–æ–±—Ä–∞–∂–µ–Ω–∏–π –ø–æ –ø–æ–≤–æ–¥—É —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏—è–º–∏ –≤ –≤–∞—à–µ–º –æ–±—â–µ–¥–æ—Å—Ç—É–ø–Ω–æ–º API, —á—Ç–æ–±—ã —Å–¥–µ–ª–∞—Ç—å –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å –æ—Ç –≤–∞—à–µ–≥–æ –∫—Ä–µ–π—Ç–∞ –Ω–µ–æ–±—Ä–µ–º–µ–Ω–∏—Ç–µ–ª—å–Ω–æ–π. –≠—Ç–∏ —Å–æ–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤—ã—Ö–æ–¥—è—Ç –∑–∞ —Ä–∞–º–∫–∏ —ç—Ç–æ–π –∫–Ω–∏–≥–∏; –µ—Å–ª–∏ –≤–∞–º –∏–Ω—Ç–µ—Ä–µ—Å–Ω–∞ —ç—Ç–∞ —Ç–µ–º–∞, –æ–∑–Ω–∞–∫–æ–º—å—Ç–µ—Å—å —Å <a href="https://rust-lang.github.io/api-guidelines/">The Rust API Guidelines</a>.</p>
<blockquote>
<h4 id="–õ—É—á—à–∏–µ-–ø—Ä–∞–∫—Ç–∏–∫–∏-–¥–ª—è-–ø–∞–∫–µ—Ç–æ–≤-—Å-–±–∏–Ω–∞—Ä–Ω—ã–º-–∏-–±–∏–±–ª–∏–æ—Ç–µ—á–Ω—ã–º-–∫—Ä–µ–π—Ç–∞–º–∏"><a class="header" href="#–õ—É—á—à–∏–µ-–ø—Ä–∞–∫—Ç–∏–∫–∏-–¥–ª—è-–ø–∞–∫–µ—Ç–æ–≤-—Å-–±–∏–Ω–∞—Ä–Ω—ã–º-–∏-–±–∏–±–ª–∏–æ—Ç–µ—á–Ω—ã–º-–∫—Ä–µ–π—Ç–∞–º–∏">–õ—É—á—à–∏–µ –ø—Ä–∞–∫—Ç–∏–∫–∏ –¥–ª—è –ø–∞–∫–µ—Ç–æ–≤ —Å –±–∏–Ω–∞—Ä–Ω—ã–º –∏ –±–∏–±–ª–∏–æ—Ç–µ—á–Ω—ã–º –∫—Ä–µ–π—Ç–∞–º–∏</a></h4>
<p>–ú—ã —É–ø–æ–º–∏–Ω–∞–ª–∏, —á—Ç–æ –ø–∞–∫–µ—Ç –º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å –∫–∞–∫ –∫–æ—Ä–Ω–µ–≤–æ–π –º–æ–¥—É–ª—å –±–∏–Ω–∞—Ä–Ω–æ–≥–æ –∫—Ä–µ–π—Ç–∞ <em>src/main.rs</em>, —Ç–∞–∫ –∏ –∫–æ—Ä–Ω–µ–≤–æ–π –º–æ–¥—É–ª—å –±–∏–±–ª–∏–æ—Ç–µ—á–Ω–æ–≥–æ –∫—Ä–µ–π—Ç–∞ <em>src/lib.rs</em>, –∏ –æ–±–∞ –∫—Ä–µ–π—Ç–∞ –±—É–¥—É—Ç –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –∏–º–µ—Ç—å –∏–º—è –ø–∞–∫–µ—Ç–∞. –ö–∞–∫ –ø—Ä–∞–≤–∏–ª–æ, –ø–∞–∫–µ—Ç—ã —Å —Ç–∞–∫–∏–º —à–∞–±–ª–æ–Ω–æ–º, —Å–æ–¥–µ—Ä–∂–∞—â–∏–º –∫–∞–∫ –±–∏–±–ª–∏–æ—Ç–µ—á–Ω—ã–π, —Ç–∞–∫ –∏ –±–∏–Ω–∞—Ä–Ω—ã–π –∫—Ä–µ–π—Ç, –±—É–¥—É—Ç –∏–º–µ—Ç—å –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∫–æ–¥–∞ –≤ –±–∏–Ω–∞—Ä–Ω–æ–º –∫—Ä–µ–π—Ç–µ, —á—Ç–æ–±—ã –∑–∞–ø—É—Å—Ç–∏—Ç—å –∏—Å–ø–æ–ª–Ω—è–µ–º—ã–π —Ñ–∞–π–ª, –∫–æ—Ç–æ—Ä—ã–π –≤—ã–∑—ã–≤–∞–µ—Ç –∫–æ–¥ –∏–∑ –±–∏–±–ª–∏–æ—Ç–µ—á–Ω–æ–≥–æ –∫—Ä–µ–π—Ç–∞. –≠—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç –¥—Ä—É–≥–∏–º –ø—Ä–æ–µ–∫—Ç–∞–º –∏–∑–≤–ª–µ—á—å –≤—ã–≥–æ–¥—É –∏–∑ –±–æ–ª—å—à–µ–π —á–∞—Å—Ç–∏ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ–º–æ–π –ø–∞–∫–µ—Ç–æ–º, –ø–æ—Å–∫–æ–ª—å–∫—É –∫–æ–¥ –±–∏–±–ª–∏–æ—Ç–µ—á–Ω–æ–≥–æ –∫—Ä–µ–π—Ç–∞ –º–æ–≥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏ –¥—Ä—É–≥–∏–µ.</p>
<p>–î–µ—Ä–µ–≤–æ –º–æ–¥—É–ª–µ–π –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ –≤ <em>src/lib.rs</em>. –ü–æ—Å–ª–µ —ç—Ç–æ–≥–æ, –ª—é–±—ã–µ –æ–±—â–µ–¥–æ—Å—Ç—É–ø–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤ –±–∏–Ω–∞—Ä–Ω–æ–º –∫—Ä–µ–π—Ç–µ, –Ω–∞—á–∞–≤ –ø—É—Ç–∏ —Å –∏–º–µ–Ω–∏ –ø–∞–∫–µ—Ç–∞. –ë–∏–Ω–∞—Ä–Ω—ã–π –∫—Ä–µ–π—Ç —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º –±–∏–±–ª–∏–æ—Ç–µ—á–Ω–æ–≥–æ –∫—Ä–µ–π—Ç–∞ —Ç–æ—á–Ω–æ —Ç–∞–∫ –∂–µ, –∫–∞–∫ –ø–æ–ª–Ω–æ—Å—Ç—å—é –≤–Ω–µ—à–Ω–∏–π –∫—Ä–µ–π—Ç –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –±–∏–±–ª–∏–æ—Ç–µ—á–Ω—ã–π –∫—Ä–µ–π—Ç: –æ–Ω –º–æ–∂–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ –æ–±—â–µ–¥–æ—Å—Ç—É–ø–Ω—ã–π API. –≠—Ç–æ –ø–æ–º–æ–∂–µ—Ç –≤–∞–º —Ä–∞–∑—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å —Ö–æ—Ä–æ—à–∏–π API, —Ç–∞–∫ –∫–∞–∫ –≤—ã –Ω–µ —Ç–æ–ª—å–∫–æ –∞–≤—Ç–æ—Ä, –Ω–æ –∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å!</p>
<p>–í <a href="ch12-00-an-io-project.html">–ì–ª–∞–≤–µ 12</a><!-- ignore --> –º—ã –ø–æ–∫–∞–∂–µ–º —ç—Ç—É –ø—Ä–∞–∫—Ç–∏–∫—É –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ –∫–æ–¥–∞ –Ω–∞ –ø—Ä–∏–º–µ—Ä–µ –∫–æ–Ω—Å–æ–ª—å–Ω–æ–π –ø—Ä–æ–≥—Ä–∞–º–º—ã, –∫–æ—Ç–æ—Ä–∞—è –±—É–¥–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å –∫–∞–∫ –±–∏–Ω–∞—Ä–Ω—ã–π, —Ç–∞–∫ –∏ –±–∏–±–ª–∏–æ—Ç–µ—á–Ω—ã–π –∫—Ä–µ–π—Ç—ã.</p>
</blockquote>
<h3 id="–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ-–æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã—Ö-–ø—É—Ç–µ–π-—Å-–ø–æ–º–æ—â—å—é-super"><a class="header" href="#–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ-–æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã—Ö-–ø—É—Ç–µ–π-—Å-–ø–æ–º–æ—â—å—é-super">–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã—Ö –ø—É—Ç–µ–π —Å –ø–æ–º–æ—â—å—é <code>super</code></a></h3>
<p>–¢–∞–∫–∂–µ –º–æ–∂–Ω–æ –ø–æ—Å—Ç—Ä–æ–∏—Ç—å –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–µ –ø—É—Ç–∏, –∫–æ—Ç–æ—Ä—ã–µ –Ω–∞—á–∏–Ω–∞—é—Ç—Å—è –≤ —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–æ–º (–∞ –Ω–µ —Ç–µ–∫—É—â–µ–º) –º–æ–¥—É–ª–µ, –∏—Å–ø–æ–ª—å–∑—É—è –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ <code>super</code> –≤ –Ω–∞—á–∞–ª–µ –ø—É—Ç–∏. –≠—Ç–æ –ø–æ—Ö–æ–∂–µ –Ω–∞ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å <code>..</code> –ø—É—Ç–∏ —Ñ–∞–π–ª–æ–≤–æ–π —Å–∏—Å—Ç–µ–º—ã. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ <code>super</code> –ø–æ–∑–≤–æ–ª—è–µ—Ç –Ω–∞–º —Å–æ—Å–ª–∞—Ç—å—Å—è –Ω–∞ —ç–ª–µ–º–µ–Ω—Ç, –∫–æ—Ç–æ—Ä—ã–π, –∫–∞–∫ –º—ã –∑–Ω–∞–µ–º, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–æ–º –º–æ–¥—É–ª–µ, —á—Ç–æ –º–æ–∂–µ—Ç —É–ø—Ä–æ—Å—Ç–∏—Ç—å –ø–µ—Ä–µ—É–ø–æ—Ä—è–¥–æ—á–µ–Ω–∏–µ –¥–µ—Ä–µ–≤–∞ –º–æ–¥—É–ª–µ–π, —á–µ–º –∫–æ–≥–¥–∞ –º–æ–¥—É–ª—å —Ç–µ—Å–Ω–æ —Å–≤—è–∑–∞–Ω —Å —Ä–æ–¥–∏—Ç–µ–ª–µ–º, –Ω–æ —Ä–æ–¥–∏—Ç–µ–ª—å –º–æ–∂–µ—Ç –∫–æ–≥–¥–∞-–Ω–∏–±—É–¥—å –±—ã—Ç—å –ø–µ—Ä–µ–º–µ—â—ë–Ω –≤ –¥—Ä—É–≥–æ–µ –º–µ—Å—Ç–æ –≤ –¥–µ—Ä–µ–≤–µ –º–æ–¥—É–ª–µ–π.</p>
<p>–†–∞—Å—Å–º–æ—Ç—Ä–∏–º –∫–æ–¥ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 7-8, –≥–¥–µ –º–æ–¥–µ–ª–∏—Ä—É–µ—Ç—Å—è —Å–∏—Ç—É–∞—Ü–∏—è, –≤ –∫–æ—Ç–æ—Ä–æ–π –ø–æ–≤–∞—Ä –∏—Å–ø—Ä–∞–≤–ª—è–µ—Ç –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –∑–∞–∫–∞–∑ –∏ –ª–∏—á–Ω–æ –ø—Ä–∏–Ω–æ—Å–∏—Ç –µ–≥–æ –∫–ª–∏–µ–Ω—Ç—É. –§—É–Ω–∫—Ü–∏—è <code>fix_incorrect_order</code> –≤—ã–∑—ã–≤–∞–µ—Ç —Ñ—É–Ω–∫—Ü–∏—é <code>deliver_order</code>, –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—É—é –≤ —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–æ–º –º–æ–¥—É–ª–µ, —É–∫–∞–∑—ã–≤–∞—è –ø—É—Ç—å –∫ <code>deliver_order</code>, –Ω–∞—á–∏–Ω–∞—é—â–∏–π—Å—è —Å <code>super</code>:</p>
<Listing number="7-8" file-name="src/lib.rs" caption="Calling a function using a relative path starting with `super`">
<pre><code class="language-rust noplayground test_harness">fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order();
    }

    fn cook_order() {}
}</code></pre>
</Listing>
<p>–§—É–Ω–∫—Ü–∏—è <code>fix_incorrect_order</code> –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ –º–æ–¥—É–ª–µ <code>back_of_house</code>, –ø–æ—ç—Ç–æ–º—É –º—ã –º–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å <code>super</code> –¥–ª—è –ø–µ—Ä–µ—Ö–æ–¥–∞ –∫ —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–æ–º—É –º–æ–¥—É–ª—é –º–æ–¥—É–ª—è <code>back_of_house</code>, –∫–æ—Ç–æ—Ä—ã–π –≤ —ç—Ç–æ–º —Å–ª—É—á–∞–µ —è–≤–ª—è–µ—Ç—Å—è <code>crate</code> (—Ç–æ –µ—Å—Ç—å, –∫–æ—Ä–Ω–µ–º). –í —ç—Ç–æ–º –º–æ–¥—É–ª–µ –º—ã –∏—â–µ–º <code>deliver_order</code> –∏ –Ω–∞—Ö–æ–¥–∏–º –µ–≥–æ. –£—Å–ø–µ—Ö! –ú—ã –¥—É–º–∞–µ–º, —á—Ç–æ –º–æ–¥—É–ª—å <code>back_of_house</code> –∏ —Ñ—É–Ω–∫—Ü–∏—è <code>deliver_order</code>, —Å–∫–æ—Ä–µ–µ –≤—Å–µ–≥–æ, –æ—Å—Ç–∞–Ω—É—Ç—Å—è –≤ —Ç–µ—Ö –∂–µ —Ä–æ–¥—Å—Ç–≤–µ–Ω–Ω—ã—Ö –æ—Ç–Ω–æ—à–µ–Ω–∏—è—Ö –¥—Ä—É–≥ —Å –¥—Ä—É–≥–æ–º, –∏ –¥–æ–ª–∂–Ω—ã –±—É–¥—É—Ç –±—ã—Ç—å –ø–µ—Ä–µ–º–µ—â–µ–Ω—ã –≤–º–µ—Å—Ç–µ, –µ—Å–ª–∏ –º—ã —Ä–µ—à–∏–º —Ä–µ–æ—Ä–≥–∞–Ω–∏–∑–æ–≤–∞—Ç—å –¥–µ—Ä–µ–≤–æ –º–æ–¥—É–ª–µ–π –∫—Ä–µ–π—Ç–∞. –ü–æ—ç—Ç–æ–º—É –º—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ <code>super</code>, —á—Ç–æ–±—ã –≤ –±—É–¥—É—â–µ–º —É –Ω–∞—Å –±—ã–ª–æ –º–µ–Ω—å—à–µ –º–µ—Å—Ç –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫–æ–¥–∞, –µ—Å–ª–∏ —ç—Ç–æ—Ç –∫–æ–¥ –±—É–¥–µ—Ç –ø–µ—Ä–µ–º–µ—â—ë–Ω –≤ –¥—Ä—É–≥–æ–π –º–æ–¥—É–ª—å.</p>
<h3 id="–£–∫–∞–∑–∞–Ω–∏–µ-–æ–±—â–µ–¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏-—Å—Ç—Ä—É–∫—Ç—É—Ä-–∏-–ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π"><a class="header" href="#–£–∫–∞–∑–∞–Ω–∏–µ-–æ–±—â–µ–¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏-—Å—Ç—Ä—É–∫—Ç—É—Ä-–∏-–ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π">–£–∫–∞–∑–∞–Ω–∏–µ –æ–±—â–µ–¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä –∏ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π</a></h3>
<p>–ú—ã —Ç–∞–∫–∂–µ –º–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å <code>pub</code> –¥–ª—è –æ–±–æ–∑–Ω–∞—á–µ–Ω–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä –∏ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π –∫–∞–∫ –æ–±—â–µ–¥–æ—Å—Ç—É–ø–Ω—ã—Ö, –Ω–æ –µ—Å—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –¥–µ—Ç–∞–ª–µ–π –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è <code>pub</code> —Å–æ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞–º–∏ –∏ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è–º–∏. –ï—Å–ª–∏ –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º <code>pub</code> –ø–µ—Ä–µ–¥ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, –º—ã –¥–µ–ª–∞–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É –æ–±—â–µ–¥–æ—Å—Ç—É–ø–Ω–æ–π, –Ω–æ –ø–æ–ª—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –ø–æ-–ø—Ä–µ–∂–Ω–µ–º—É –æ—Å—Ç–∞—é—Ç—Å—è –ø—Ä–∏–≤–∞—Ç–Ω—ã–º–∏. –ú—ã –º–æ–∂–µ–º —Å–¥–µ–ª–∞—Ç—å –∫–∞–∂–¥–æ–µ –ø–æ–ª–µ –æ–±—â–µ–¥–æ—Å—Ç—É–ø–Ω—ã–º –∏–ª–∏ –Ω–µ—Ç –≤ –∫–∞–∂–¥–æ–º –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º —Å–ª—É—á–∞–µ. –í –õ–∏—Å—Ç–∏–Ω–≥–µ 7-9 –º—ã –æ–ø—Ä–µ–¥–µ–ª–∏–ª–∏ –æ–±—â–µ–¥–æ—Å—Ç—É–ø–Ω—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É <code>back_of_house::Breakfast</code> —Å –æ–±—â–µ–¥–æ—Å—Ç—É–ø–Ω—ã–º –ø–æ–ª–µ–º <code>toast</code> –∏ —Å –ø—Ä–∏–≤–∞—Ç–Ω—ã–º –ø–æ–ª–µ–º <code>seasonal_fruit</code>. –≠—Ç–æ –º–æ–¥–µ–ª–∏—Ä—É–µ—Ç —Å–ª—É—á–∞–π –≤ —Ä–µ—Å—Ç–æ—Ä–∞–Ω–µ, –∫–æ–≥–¥–∞ –∫–ª–∏–µ–Ω—Ç –º–æ–∂–µ—Ç –≤—ã–±—Ä–∞—Ç—å —Ç–∏–ø —Ö–ª–µ–±–∞, –∫–æ—Ç–æ—Ä—ã–π –ø–æ–¥–∞—ë—Ç—Å—è —Å –µ–¥–æ–π, –∞ —à–µ—Ñ-–ø–æ–≤–∞—Ä —Ä–µ—à–∞–µ—Ç –∫–∞–∫–∏–µ —Ñ—Ä—É–∫—Ç—ã —Å–æ–ø—Ä–æ–≤–æ–∂–¥–∞—é—Ç –µ–¥—É, –∏—Å—Ö–æ–¥—è –∏–∑ —Ç–æ–≥–æ, —á—Ç–æ —Å–µ–∑–æ–Ω–Ω–æ –∏ —á—Ç–æ –µ—Å—Ç—å –≤ –Ω–∞–ª–∏—á–∏–∏. –î–æ—Å—Ç—É–ø–Ω—ã–µ —Ñ—Ä—É–∫—Ç—ã –±—ã—Å—Ç—Ä–æ –º–µ–Ω—è—é—Ç—Å—è, –ø–æ—ç—Ç–æ–º—É –∫–ª–∏–µ–Ω—Ç—ã –Ω–µ –º–æ–≥—É—Ç –≤—ã–±–∏—Ä–∞—Ç—å —Ñ—Ä—É–∫—Ç—ã –∏–ª–∏ –¥–∞–∂–µ —É–≤–∏–¥–µ—Ç—å, –∫–∞–∫–∏–µ —Ñ—Ä—É–∫—Ç—ã –æ–Ω–∏ –ø–æ–ª—É—á–∞—Ç.</p>
<Listing number="7-9" file-name="src/lib.rs" caption="A struct with some public fields and some private fields">
<pre><code class="language-rust noplayground">mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &amp;str) -&gt; Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("–ø–µ—Ä—Å–∏–∫–∏"),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // –ó–∞–∫–∞–∑—ã–≤–∞–µ–º –ª–µ—Ç–æ–º –∑–∞–≤—Ç—Ä–∞–∫ —Å —Ä–∂–∞–Ω—ã–º —Ö–ª–µ–±–æ–º.
    let mut meal = back_of_house::Breakfast::summer("—Ä–∂–∞–Ω–æ–π");
    // –ü–µ—Ä–µ–¥—É–º–∞–ª–∏ –Ω–∞—Å—á—ë—Ç —Ö–ª–µ–±–∞, –∫–æ—Ç–æ—Ä—ã–π –º—ã —Ö–æ—Ç–∏–º.
    meal.toast = String::from("–ø—à–µ–Ω–∏—á–Ω—ã–π");
    println!("–Ø —Ö–æ—á—É {} —Ç–æ—Å—Ç, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞.", meal.toast);

    // –°–ª–µ–¥—É—é—â–∞—è —Å—Ç—Ä–æ—á–∫–∞, –µ—Å–ª–∏ –º—ã —Ä–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–µ–º –µ—ë, –Ω–µ —Å–∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è:
    // –Ω–∞–º –Ω–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–æ –∑–Ω–∞—Ç—å –∏–ª–∏ –∏–∑–º–µ–Ω—è—Ç—å —Å–µ–∑–æ–Ω–Ω—ã–π —Ñ—Ä—É–∫—Ç, –∫–æ—Ç–æ—Ä—ã–π –Ω–∞–º –ø–æ–¥–∞–¥—É—Ç.
    // meal.seasonal_fruit = String::from("—á–µ—Ä–Ω–∏–∫–∞");
}</code></pre>
</Listing>
<p>–ü–æ—Å–∫–æ–ª—å–∫—É –ø–æ–ª–µ <code>toast</code> –≤ —Å—Ç—Ä—É–∫—Ç—É—Ä–µ <code>back_of_house::Breakfast</code> —è–≤–ª—è–µ—Ç—Å—è –æ—Ç–∫—Ä—ã—Ç—ã–º, —Ç–æ –≤ —Ñ—É–Ω–∫—Ü–∏–∏ <code>eat_at_restaurant</code> –º–æ–∂–Ω–æ –ø–∏—Å–∞—Ç—å –∏ —á–∏—Ç–∞—Ç—å –ø–æ–ª–µ <code>toast</code>, –∏—Å–ø–æ–ª—å–∑—É—è –æ–±—Ä–∞—â–µ–Ω–∏–µ —á–µ—Ä–µ–∑ —Ç–æ—á–∫—É. –û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ –º—ã –Ω–µ –º–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–æ–ª–µ <code>seasonal_fruit</code> –≤ <code>eat_at_restaurant</code>, –ø–æ—Ç–æ–º—É —á—Ç–æ <code>seasonal_fruit</code> —è–≤–ª—è–µ—Ç—Å—è –ø—Ä–∏–≤–∞—Ç–Ω—ã–º. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Ä–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å –ø–æ—Å–ª–µ–¥–Ω—é—é —Å—Ç—Ä–æ—á–∫—É, –ø—ã—Ç–∞—é—â—É—é—Å—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ–ª—è <code>seasonal_fruit</code>, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å, –∫–∞–∫—É—é –æ—à–∏–±–∫—É –≤—ã –ø–æ–ª—É—á–∏—Ç–µ!</p>
<p>–¢–∞–∫–∂–µ –æ–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ –ø–æ—Å–∫–æ–ª—å–∫—É <code>back_of_house::Breakfast</code> –∏–º–µ–µ—Ç –ø—Ä–∏–≤–∞—Ç–Ω–æ–µ –ø–æ–ª–µ, —Ç–æ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–æ–ª–∂–Ω–∞ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–∏—Ç—å –ø—É–±–ª–∏—á–Ω—É—é –∞—Å—Å–æ—Ü–∏–∏—Ä–æ–≤–∞–Ω–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é, –∫–æ—Ç–æ—Ä–∞—è —Å–æ–∑–¥–∞—ë—Ç —ç–∫–∑–µ–º–ø–ª—è—Ä <code>Breakfast</code> (–º—ã –Ω–∞–∑–≤–∞–ª–∏ –µ—ë <code>summer</code>). –ï—Å–ª–∏ –±—ã <code>Breakfast</code> –Ω–µ –∏–º–µ–ª —Ç–∞–∫–æ–π —Ñ—É–Ω–∫—Ü–∏–∏, –º—ã –±—ã –Ω–µ –º–æ–≥–ª–∏ —Å–æ–∑–¥–∞—Ç—å —ç–∫–∑–µ–º–ø–ª—è—Ä <code>Breakfast</code> –≤–Ω—É—Ç—Ä–∏ <code>eat_at_restaurant</code>, –ø–æ—Ç–æ–º—É —á—Ç–æ –º—ã –Ω–µ —Å–º–æ–≥–ª–∏ –±—ã —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ –ø–æ–ª—è <code>seasonal_fruit</code> –≤ —Ñ—É–Ω–∫—Ü–∏–∏ <code>eat_at_restaurant</code>.</p>
<p>–í –æ—Ç–ª–∏—á–∏–µ –æ—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, –µ—Å–ª–∏ –º—ã —Å–¥–µ–ª–∞–µ–º –æ–±—â–µ–¥–æ—Å—Ç—É–ø–Ω—ã–º –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ, —Ç–æ –≤—Å–µ –µ–≥–æ –≤–∞—Ä–∏–∞–Ω—Ç—ã –±—É–¥—É—Ç –æ–±—â–µ–¥–æ—Å—Ç—É–ø–Ω—ã–º–∏. –ù—É–∂–Ω–æ —Ç–æ–ª—å–∫–æ —É–∫–∞–∑–∞—Ç—å <code>pub</code> –ø–µ—Ä–µ–¥ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–æ–º <code>enum</code>, –∫–∞–∫ –ø–æ–∫–∞–∑–∞–Ω–æ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 7-10.</p>
<Listing number="7-10" file-name="src/lib.rs" caption="Designating an enum as public makes all its variants public.">
<pre><code class="language-rust noplayground">mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}</code></pre>
</Listing>
<p>–ü–æ—Å–∫–æ–ª—å–∫—É –º—ã —Å–¥–µ–ª–∞–ª–∏ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ <code>Appetizer</code> –æ–±—â–µ–¥–æ—Å—Ç—É–ø–Ω—ã–º, –º—ã –º–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤–∞—Ä–∏–∞–Ω—Ç—ã <code>Soup</code> –∏ <code>Salad</code> –≤ —Ñ—É–Ω–∫—Ü–∏–∏ <code>eat_at_restaurant</code>.</p>
<p>–ü–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –Ω–µ –æ—á–µ–Ω—å –ø–æ–ª–µ–∑–Ω—ã, –µ—Å–ª–∏ –∏—Ö –≤–∞—Ä–∏–∞–Ω—Ç—ã –Ω–µ —è–≤–ª—è—é—Ç—Å—è –æ–±—â–µ–¥–æ—Å—Ç—É–ø–Ω—ã–º–∏: –∞–Ω–Ω–æ—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Å–µ—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –∫–∞–∫ <code>pub</code> –±—ã–ª–æ –±—ã —Ä–∞–∑–¥—Ä–∞–∂–∞—é—â–µ –Ω—É–¥–Ω—ã–º. –ü–æ —ç—Ç–æ–π –ø—Ä–∏—á–∏–Ω–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é —è–≤–ª—è—é—Ç—Å—è –æ–±—â–µ–¥–æ—Å—Ç—É–ø–Ω—ã–º–∏. –°—Ç—Ä—É–∫—Ç—É—Ä—ã —á–∞—Å—Ç–æ –ø–æ–ª–µ–∑–Ω—ã, –µ—Å–ª–∏ –∏—Ö –ø–æ–ª—è –Ω–µ —è–≤–ª—è—é—Ç—Å—è –æ–±—â–µ–¥–æ—Å—Ç—É–ø–Ω—ã–º–∏, –ø–æ—ç—Ç–æ–º—É –ø–æ–ª—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã —Å–ª–µ–¥—É—é—Ç –æ–±—â–µ–º—É –ø—Ä–∞–≤–∏–ª—É, —Å–æ–≥–ª–∞—Å–Ω–æ –∫–æ—Ç–æ—Ä–æ–º—É, –≤—Å—ë –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é —è–≤–ª—è–µ—Ç—Å—è –ø—Ä–∏–≤–∞—Ç–Ω—ã–º, –µ—Å–ª–∏ –Ω–µ —É–∫–∞–∑–∞–Ω–æ <code>pub</code>.</p>
<p>–ï—Å—Ç—å –µ—â—ë –æ–¥–Ω–∞ —Å–∏—Ç—É–∞—Ü–∏—è —Å <code>pub</code>, –∫–æ—Ç–æ—Ä—É—é –º—ã –Ω–µ –æ—Å–≤–µ—â–∞–ª–∏, –∏ —ç—Ç–æ –ø–æ—Å–ª–µ–¥–Ω—è—è –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç—å —Å–∏—Å—Ç–µ–º—ã –º–æ–¥—É–ª–µ–π: –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ <code>use</code>. –ú—ã —Å–Ω–∞—á–∞–ª–∞ –æ–ø–∏—à–µ–º <code>use</code> —Å–∞–º–æ –ø–æ —Å–µ–±–µ, –∞ –∑–∞—Ç–µ–º –ø–æ–∫–∞–∂–µ–º, –∫–∞–∫ —Å–æ—á–µ—Ç–∞—Ç—å <code>pub</code> –∏ <code>use</code> –≤–º–µ—Å—Ç–µ.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–î–æ–±–∞–≤–ª–µ–Ω–∏–µ-–ø—É—Ç–µ–π-–≤-–æ–±–ª–∞—Å—Ç—å-–≤–∏–¥–∏–º–æ—Å—Ç–∏-–∫–ª—é—á–µ–≤—ã–º-—Å–ª–æ–≤–æ–º-use"><a class="header" href="#–î–æ–±–∞–≤–ª–µ–Ω–∏–µ-–ø—É—Ç–µ–π-–≤-–æ–±–ª–∞—Å—Ç—å-–≤–∏–¥–∏–º–æ—Å—Ç–∏-–∫–ª—é—á–µ–≤—ã–º-—Å–ª–æ–≤–æ–º-use">–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –ø—É—Ç–µ–π –≤ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–æ–º <code>use</code></a></h2>
<p>–ù–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç—å –∑–∞–ø–∏—Å—ã–≤–∞—Ç—å –ø—É—Ç–∏ –∫ —Ñ—É–Ω–∫—Ü–∏—è–º –≤—ã–∑–æ–≤–∞ –º–æ–∂–µ—Ç –ø–æ–∫–∞–∑–∞—Ç—å—Å—è –Ω–µ—É–¥–æ–±–Ω–æ–π –∏ –º–Ω–æ–≥–æ—Å–ª–æ–≤–Ω–æ–π. –í –õ–∏—Å—Ç–∏–Ω–≥–µ 7-7 –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –æ—Ç —Ç–æ–≥–æ, –≤—ã–±–∏—Ä–∞–ª–∏ –ª–∏ –º—ã –∞–±—Å–æ–ª—é—Ç–Ω—ã–π –∏–ª–∏ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø—É—Ç—å –∫ —Ñ—É–Ω–∫—Ü–∏–∏ <code>add_to_waitlist</code>, –∫–∞–∂–¥—ã–π —Ä–∞–∑, –∫–æ–≥–¥–∞ –º—ã —Ö–æ—Ç–µ–ª–∏ –≤—ã–∑–≤–∞—Ç—å <code>add_to_waitlist</code>, –Ω–∞–º –ø—Ä–∏—Ö–æ–¥–∏–ª–æ—Å—å —Ç–∞–∫–∂–µ —É–∫–∞–∑—ã–≤–∞—Ç—å <code>front_of_house</code> –∏ <code>hosting</code>. –ö —Å—á–∞—Å—Ç—å—é, –µ—Å—Ç—å —Å–ø–æ—Å–æ–± —É–ø—Ä–æ—Å—Ç–∏—Ç—å —ç—Ç–æ—Ç –ø—Ä–æ—Ü–µ—Å—Å: –º—ã –º–æ–∂–µ–º –æ–¥–∏–Ω —Ä–∞–∑ —Å–æ–∑–¥–∞—Ç—å –ø—Å–µ–≤–¥–æ–Ω–∏–º –Ω–∞ –ø—É—Ç—å –ø—Ä–∏ –ø–æ–º–æ—â–∏ –∫–ª—é—á–µ–≤–æ–≥–æ —Å–ª–æ–≤–∞ <code>use</code>, –∞ –∑–∞—Ç–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –±–æ–ª–µ–µ –∫–æ—Ä–æ—Ç–∫–æ–µ –∏–º—è –≤–µ–∑–¥–µ –≤ –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏.</p>
<p>–í –õ–∏—Å—Ç–∏–Ω–≥–µ 7-11 –º—ã –ø–æ–¥–∫–ª—é—á–∏–ª–∏ –º–æ–¥—É–ª—å <code>crate::front_of_house::hosting</code> –≤ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ —Ñ—É–Ω–∫—Ü–∏–∏ <code>eat_at_restaurant</code>, –ø–æ—ç—Ç–æ–º—É –Ω–∞–º –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Ç–æ–ª—å–∫–æ —É–∫–∞–∑–∞—Ç—å <code>hosting::add_to_waitlist</code> –¥–ª—è –≤—ã–∑–æ–≤–∞ —Ñ—É–Ω–∫—Ü–∏–∏ <code>add_to_waitlist</code> –≤–Ω—É—Ç—Ä–∏ <code>eat_at_restaurant</code>.</p>
<Listing number="7-11" file-name="src/lib.rs" caption="Bringing a module into scope with `use`">
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}</code></pre>
</Listing>
<p>–î–æ–±–∞–≤–ª–µ–Ω–∏–µ <code>use</code> –∏ –ø—É—Ç–∏ –≤ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ —Å–æ–∑–¥–∞–Ω–∏—é —Å–∏–º–≤–æ–ª–∏—á–µ—Å–∫–æ–π —Å—Å—ã–ª–∫–∏ –≤ —Ñ–∞–π–ª–æ–≤–æ–π —Å–∏—Å—Ç–µ–º–µ. –° –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ–º <code>use crate::front_of_house::hosting</code> –≤ –∫–æ—Ä–Ω–µ–≤–æ–π –º–æ–¥—É–ª—å –∫—Ä–µ–π—Ç–∞, <code>hosting</code> —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –¥–æ–ø—É—Å—Ç–∏–º—ã–º –∏–º–µ–Ω–µ–º –≤ —ç—Ç–æ–π –æ–±–ª–∞—Å—Ç–∏, –∫–∞–∫ –µ—Å–ª–∏ –±—ã –º–æ–¥—É–ª—å <code>hosting</code> –±—ã–ª –æ–ø—Ä–µ–¥–µ–ª—ë–Ω –≤ –∫–æ—Ä–Ω–µ –∫—Ä–µ–π—Ç–∞. –ü—É—Ç–∏, –ø–æ–¥–∫–ª—é—á—ë–Ω–Ω—ã–µ –≤ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ —Å –ø–æ–º–æ—â—å—é <code>use</code>, —Ç–∞–∫–∂–µ –ø—Ä–æ–≤–µ—Ä—è—é—Ç—Å—è –Ω–∞ –ø—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç—å, –∫–∞–∫ –∏ –ª—é–±—ã–µ –¥—Ä—É–≥–∏–µ –ø—É—Ç–∏.</p>
<p>–û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ <code>use</code> —Å–æ–∑–¥–∞—ë—Ç –ø—Å–µ–≤–¥–æ–Ω–∏–º —Ç–æ–ª—å–∫–æ –¥–ª—è —Ç–æ–π –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –æ–±–ª–∞—Å—Ç–∏, –≤ –∫–æ—Ç–æ—Ä–æ–π —ç—Ç–æ –æ–±—ä—è–≤–ª–µ–Ω–∏–µ <code>use</code> –∏ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è. –í –õ–∏—Å—Ç–∏–Ω–≥–µ 7-12 —Ñ—É–Ω–∫—Ü–∏—è <code>eat_at_restaurant</code> –ø–µ—Ä–µ–º–µ—â–∞–µ—Ç—Å—è –≤ –Ω–æ–≤—ã–π –¥–æ—á–µ—Ä–Ω–∏–π –º–æ–¥—É–ª—å —Å –∏–º–µ–Ω–µ–º <code>customer</code>, –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∫–æ—Ç–æ—Ä–æ–≥–æ –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è –æ—Ç –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ <code>use</code>, –ø–æ—ç—Ç–æ–º—É —Ç–µ–ª–æ —Ñ—É–Ω–∫—Ü–∏–∏ –Ω–µ –±—É–¥–µ—Ç –∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞—Ç—å—Å—è.</p>
<Listing number="7-12" file-name="src/lib.rs" caption="A `use` statement only applies in the scope it‚Äôs in.">
<pre><code class="language-rust noplayground test_harness does_not_compile ignore">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

mod customer {
    pub fn eat_at_restaurant() {
        hosting::add_to_waitlist();
    }
}</code></pre>
</Listing>
<p>–û—à–∏–±–∫–∞ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç, —á—Ç–æ –¥–∞–Ω–Ω—ã–π –ø—Å–µ–≤–¥–æ–Ω–∏–º –Ω–µ –º–æ–∂–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –≤ –º–æ–¥—É–ª–µ <code>customer</code>:</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0433]: failed to resolve: use of undeclared crate or module `hosting`
  --&gt; src/lib.rs:11:9
   |
11 |         hosting::add_to_waitlist();
   |         ^^^^^^^ use of undeclared crate or module `hosting`
   |
help: consider importing this module through its public re-export
   |
10 +     use crate::hosting;
   |

warning: unused import: `crate::front_of_house::hosting`
 --&gt; src/lib.rs:7:5
  |
7 | use crate::front_of_house::hosting;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

For more information about this error, try `rustc --explain E0433`.
warning: `restaurant` (lib) generated 1 warning
error: could not compile `restaurant` (lib) due to 1 previous error; 1 warning emitted
</code></pre>
<p>–û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ –µ—Å—Ç—å —Ç–∞–∫–∂–µ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –æ —Ç–æ–º, —á—Ç–æ <code>use</code> –Ω–µ —Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤ —Å–≤–æ–µ–π –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏! –ß—Ç–æ–±—ã —Ä–µ—à–∏—Ç—å —ç—Ç—É –ø—Ä–æ–±–ª–µ–º—É, –º–æ–∂–Ω–æ –ø–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å <code>use</code> –≤ –º–æ–¥—É–ª—å <code>customer</code>, –∏–ª–∏ –∂–µ –º–æ–∂–Ω–æ —Å–æ—Å–ª–∞—Ç—å—Å—è –Ω–∞ –ø—Å–µ–≤–¥–æ–Ω–∏–º –≤ —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–æ–º –º–æ–¥—É–ª–µ —Å –ø–æ–º–æ—â—å—é <code>super::hosting</code> –≤ –¥–æ—á–µ—Ä–Ω–µ–º –º–æ–¥—É–ª–µ <code>customer</code>.</p>
<h3 id="–°–æ–∑–¥–∞–Ω–∏–µ-–∏–¥–∏–æ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö-–ø—É—Ç–µ–π-—Å-use"><a class="header" href="#–°–æ–∑–¥–∞–Ω–∏–µ-–∏–¥–∏–æ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö-–ø—É—Ç–µ–π-—Å-use">–°–æ–∑–¥–∞–Ω–∏–µ –∏–¥–∏–æ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö –ø—É—Ç–µ–π —Å <code>use</code></a></h3>
<p>–í –õ–∏—Å—Ç–∏–Ω–≥–µ 7-11 –≤—ã –º–æ–≥–ª–∏ –∑–∞–¥–∞—Ç—å—Å—è –≤–æ–ø—Ä–æ—Å–æ–º, –ø–æ—á–µ–º—É –º—ã —É–∫–∞–∑–∞–ª–∏ <code>use crate::front_of_house::hosting</code>, –∞ –∑–∞—Ç–µ–º –≤—ã–∑–≤–∞–ª–∏ <code>hosting::add_to_waitlist</code> –≤–Ω—É—Ç—Ä–∏ <code>eat_at_restaurant</code> –≤–º–µ—Å—Ç–æ —É–∫–∞–∑–∞–Ω–∏—è –≤ <code>use</code> –ø–æ–ª–Ω–æ–≥–æ –ø—É—Ç–∏ –ø—Ä—è–º–æ –¥–æ —Ñ—É–Ω–∫—Ü–∏–∏ <code>add_to_waitlist</code> –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–æ–≥–æ –∂–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞, —á—Ç–æ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 7-13.</p>
<Listing number="7-13" file-name="src/lib.rs" caption="Bringing the `add_to_waitlist` function into scope with `use`, which is unidiomatic">
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
}</code></pre>
</Listing>
<p>–•–æ—Ç—è –õ–∏—Å—Ç–∏–Ω–≥–∏ 7-11 –∏ 7-13 –≤—ã–ø–æ–ª–Ω—è—é—Ç –æ–¥–Ω—É –∏ —Ç—É –∂–µ –∑–∞–¥–∞—á—É, –õ–∏—Å—Ç–∏–Ω–≥ 7-11 —è–≤–ª—è–µ—Ç—Å—è –∏–¥–∏–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º —Å–ø–æ—Å–æ–±–æ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è —Ñ—É–Ω–∫—Ü–∏–∏ –≤ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ —Å –ø–æ–º–æ—â—å—é <code>use</code>. –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–æ–≥–æ –º–æ–¥—É–ª—è —Ñ—É–Ω–∫—Ü–∏–∏ –≤ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ –ø—Ä–∏ –ø–æ–º–æ—â–∏ <code>use</code> –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –º—ã –¥–æ–ª–∂–Ω—ã —É–∫–∞–∑—ã–≤–∞—Ç—å —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–∏–π –º–æ–¥—É–ª—å –ø—Ä–∏ –≤—ã–∑–æ–≤–µ —Ñ—É–Ω–∫—Ü–∏–∏. –£–∫–∞–∑–∞–Ω–∏–µ —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–æ–≥–æ –º–æ–¥—É–ª—è –ø—Ä–∏ –≤—ã–∑–æ–≤–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–∞—ë—Ç –ø–æ–Ω—è—Ç—å, —á—Ç–æ —Ñ—É–Ω–∫—Ü–∏—è –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ –ª–æ–∫–∞–ª—å–Ω–æ, –Ω–æ –≤ —Ç–æ –∂–µ –≤—Ä–µ–º—è —Å–≤–æ–¥—è –∫ –º–∏–Ω–∏–º—É–º—É –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏–µ –ø–æ–ª–Ω–æ–≥–æ –ø—É—Ç–∏. –í –∫–æ–¥–µ –õ–∏—Å—Ç–∏–Ω–≥–∞ 7-13 –Ω–µ —è—Å–Ω–æ, –≥–¥–µ –∏–º–µ–Ω–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ <code>add_to_waitlist</code>.</p>
<p>–° –¥—Ä—É–≥–æ–π —Å—Ç–æ—Ä–æ–Ω—ã, –ø—Ä–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä, –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π –∏ –¥—Ä—É–≥–∏—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º <code>use</code>, –∏–¥–∏–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º –±—É–¥–µ—Ç —É–∫–∞–∑—ã–≤–∞—Ç—å –ø–æ–ª–Ω—ã–π –ø—É—Ç—å. –õ–∏—Å—Ç–∏–Ω–≥ 7-14 –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –∏–¥–∏–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π —Å–ø–æ—Å–æ–± –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ <code>HashMap</code> –≤ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ –±–∏–Ω–∞—Ä–Ω–æ–≥–æ –∫—Ä–µ–π—Ç–∞.</p>
<Listing number="7-14" file-name="src/main.rs" caption="Bringing `HashMap` into scope in an idiomatic way">
<pre><pre class="playground"><code class="language-rust edition2021">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}</code></pre></pre>
</Listing>
<p>–ó–∞ —ç—Ç–æ–π –∏–¥–∏–æ–º–æ–π –Ω–µ—Ç –≤–µ—Å–∫–æ–π –ø—Ä–∏—á–∏–Ω—ã: —ç—Ç–æ –ø—Ä–æ—Å—Ç–æ —Å–æ–≥–ª–∞—à–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –ø–æ—è–≤–∏–ª–æ—Å—å —Å–∞–º–æ —Å–æ–±–æ–π. –õ—é–¥–∏ –ø—Ä–∏–≤—ã–∫–ª–∏ —á–∏—Ç–∞—Ç—å –∏ –ø–∏—Å–∞—Ç—å –∫–æ–¥ –Ω–∞ Rust —Ç–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º.</p>
<p>–ò—Å–∫–ª—é—á–µ–Ω–∏–µ–º –∏–∑ —ç—Ç–æ–π –∏–¥–∏–æ–º—ã —è–≤–ª—è–µ—Ç—Å—è —Å–ª—É—á–∞–π, –∫–æ–≥–¥–∞ –º—ã –ø–æ–¥–∫–ª—é—á–∞–µ–º –¥–≤–∞ —ç–ª–µ–º–µ–Ω—Ç–∞ —Å –æ–¥–∏–Ω–∞–∫–æ–≤—ã–º–∏ –∏–º–µ–Ω–∞–º–∏ –≤ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∏—Å–ø–æ–ª—å–∑—É—è –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é <code>use</code> ‚Äî Rust –ø—Ä–æ—Å—Ç–æ –Ω–µ –ø–æ–∑–≤–æ–ª—è–µ—Ç —ç—Ç–æ–≥–æ —Å–¥–µ–ª–∞—Ç—å. –õ–∏—Å—Ç–∏–Ω–≥ 7-15 –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç, –∫–∞–∫ –ø–æ–¥–∫–ª—é—á–∏—Ç—å –≤ –æ–±–ª–∞—Å—Ç—å –¥–µ–π—Å—Ç–≤–∏—è –¥–≤–∞ —Ç–∏–ø–∞ —Å –æ–¥–∏–Ω–∞–∫–æ–≤—ã–º–∏ –∏–º–µ–Ω–∞–º–∏ <code>Result</code>, –Ω–æ –∏–∑ —Ä–∞–∑–Ω—ã—Ö —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–∏—Ö –º–æ–¥—É–ª–µ–π, –∏ –∫–∞–∫ –Ω–∞ –Ω–∏—Ö —Å—Å—ã–ª–∞—Ç—å—Å—è.</p>
<Listing number="7-15" file-name="src/lib.rs" caption="Bringing two types with the same name into the same scope requires using their parent modules.">
<pre><code class="language-rust noplayground">use std::fmt;
use std::io;

fn function1() -&gt; fmt::Result {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; io::Result&lt;()&gt; {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">    Ok(())
</span>}</code></pre>
</Listing>
<p>–ö–∞–∫ –≤–∏–¥–∏—Ç–µ, –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∏–º–µ–Ω–∏ —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–∏—Ö –º–æ–¥—É–ª–µ–π –ø–æ–∑–≤–æ–ª—è–µ—Ç —Ä–∞–∑–ª–∏—á–∞—Ç—å –¥–≤–∞ —Ç–∏–ø–∞ <code>Result</code>. –ï—Å–ª–∏ –±—ã –≤–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ –º—ã —É–∫–∞–∑–∞–ª–∏ <code>use std::fmt::Result</code> –∏ <code>use std::io::Result</code>, –º—ã –±—ã –∏–º–µ–ª–∏ –¥–≤–∞ —Ç–∏–ø–∞ <code>Result</code> –≤ –æ–¥–Ω–æ–π –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏, –∏ Rust –Ω–µ —Å–º–æ–≥ –±—ã –ø–æ–Ω—è—Ç—å –∫–∞–∫–æ–π –∏–∑ –¥–≤—É—Ö <code>Result</code> –º—ã –∏–º–µ–ª–∏ –≤ –≤–∏–¥—É, –∫–æ–≥–¥–∞ –Ω–∞—à—ë–ª –±—ã –∏—Ö —É–ø–æ—Ç—Ä–µ–±–ª–µ–Ω–∏–µ –≤ –∫–æ–¥–µ.</p>
<h3 id="–ü—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ-–Ω–æ–≤—ã—Ö-–∏–º—ë–Ω-—Å-–ø–æ–º–æ—â—å—é-–∫–ª—é—á–µ–≤–æ–≥–æ-—Å–ª–æ–≤–∞-as"><a class="header" href="#–ü—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ-–Ω–æ–≤—ã—Ö-–∏–º—ë–Ω-—Å-–ø–æ–º–æ—â—å—é-–∫–ª—é—á–µ–≤–æ–≥–æ-—Å–ª–æ–≤–∞-as">–ü—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤—ã—Ö –∏–º—ë–Ω —Å –ø–æ–º–æ—â—å—é –∫–ª—é—á–µ–≤–æ–≥–æ —Å–ª–æ–≤–∞ <code>as</code></a></h3>
<p>–ï—Å—Ç—å –¥—Ä—É–≥–æ–µ —Ä–µ—à–µ–Ω–∏–µ –ø—Ä–æ–±–ª–µ–º—ã –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Å–ª–æ–≤–æ–º <code>use</code> –¥–≤—É—Ö —Ç–∏–ø–æ–≤ —Å –æ–¥–∏–Ω–∞–∫–æ–≤—ã–º–∏ –∏–º–µ–Ω–∞–º–∏ –≤ –æ–¥–Ω—É –∏ —Ç—É –∂–µ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏: –ø–æ—Å–ª–µ –ø—É—Ç–∏ –º–æ–∂–Ω–æ —É–∫–∞–∑–∞—Ç—å <code>as</code> –∏ –Ω–æ–≤–æ–µ –ª–æ–∫–∞–ª—å–Ω–æ–µ –∏–º—è (–∏–ª–∏ <em>–ø—Å–µ–≤–¥–æ–Ω–∏–º</em>) –¥–ª—è —Ç–∏–ø–∞. –õ–∏—Å—Ç–∏–Ω–≥ 7-16 –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç, –∫–∞–∫ –ø–æ-–¥—Ä—É–≥–æ–º—É –Ω–∞–ø–∏—Å–∞—Ç—å –∫–æ–¥ –∏–∑ –õ–∏—Å—Ç–∏–Ω–≥–∞ 7-15, –ø—É—Ç—ë–º –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏—è –æ–¥–Ω–æ–≥–æ –∏–∑ –¥–≤—É—Ö —Ç–∏–ø–æ–≤ <code>Result</code> —Å–ª–æ–≤–æ–º <code>as</code>.</p>
<Listing number="7-16" file-name="src/lib.rs" caption="Renaming a type when it‚Äôs brought into scope with the `as` keyword">
<pre><code class="language-rust noplayground">use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -&gt; Result {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; IoResult&lt;()&gt; {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">    Ok(())
</span>}</code></pre>
</Listing>
<p>–í–æ –≤—Ç–æ—Ä–æ–π –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ <code>use</code> –º—ã –≤—ã–±—Ä–∞–ª–∏ –Ω–æ–≤–æ–µ –∏–º—è <code>IoResult</code> –¥–ª—è —Ç–∏–ø–∞ <code>std::io::Result</code>, –∫–æ—Ç–æ—Ä–æ–µ —Ç–µ–ø–µ—Ä—å –Ω–µ –±—É–¥–µ—Ç –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤–∞—Ç—å —Å —Ç–∏–ø–æ–º <code>Result</code> –∏–∑ <code>std::fmt</code>, –∫–æ—Ç–æ—Ä—ã–π —Ç–∞–∫–∂–µ –ø–æ–¥–∫–ª—é—á—ë–Ω –≤ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏. –û–±–∞ –õ–∏—Å—Ç–∏–Ω–≥–∞ 7-15 –∏ 7-16 —Å—á–∏—Ç–∞—é—Ç—Å—è –∏–¥–∏–æ–º–∞—Ç–∏—á–Ω—ã–º–∏, —Ç–∞–∫ —á—Ç–æ –≤—ã–±–æ—Ä –∑–∞ –≤–∞–º–∏!</p>
<h3 id="–†–µ—ç–∫—Å–ø–æ—Ä—Ç-–∏–º—ë–Ω-—Å-pub-use"><a class="header" href="#–†–µ—ç–∫—Å–ø–æ—Ä—Ç-–∏–º—ë–Ω-—Å-pub-use">–†–µ—ç–∫—Å–ø–æ—Ä—Ç –∏–º—ë–Ω —Å <code>pub use</code></a></h3>
<p>–ö–æ–≥–¥–∞ –º—ã –ø–æ–¥–∫–ª—é—á–∞–µ–º –∏–º—è –≤ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏, –∏—Å–ø–æ–ª—å–∑—É—è –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ <code>use</code>, —Ç–æ –∏–º—è, –¥–æ—Å—Ç—É–ø–Ω–æ–µ –≤ –Ω–æ–≤–æ–π –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏, —è–≤–ª—è–µ—Ç—Å—è –ø—Ä–∏–≤–∞—Ç–Ω—ã–º. –ß—Ç–æ–±—ã –ø–æ–∑–≤–æ–ª–∏—Ç—å –∫–æ–¥—É, –∫–æ—Ç–æ—Ä—ã–π –≤—ã–∑—ã–≤–∞–µ—Ç –Ω–∞—à –∫–æ–¥, —Å—Å—ã–ª–∞—Ç—å—Å—è –Ω–∞ —ç—Ç–æ –∏–º—è, –∫–∞–∫ –µ—Å–ª–∏ –±—ã –æ–Ω–æ –±—ã–ª–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ –≤ –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏ –¥–∞–Ω–Ω–æ–≥–æ –∫–æ–¥–∞, –º–æ–∂–Ω–æ –æ–±—ä–µ–¥–∏–Ω–∏—Ç—å <code>pub</code> –∏ <code>use</code>. –≠—Ç–æ—Ç –º–µ—Ç–æ–¥ –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è <em>—Ä–µ—ç–∫—Å–ø–æ—Ä—Ç–æ–º</em>, –ø–æ—Ç–æ–º—É —á—Ç–æ –º—ã –ø–æ–¥–∫–ª—é—á–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç –≤ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏, –Ω–æ —Ç–∞–∫–∂–µ –¥–µ–ª–∞–µ–º —ç—Ç–æ—Ç —ç–ª–µ–º–µ–Ω—Ç –¥–æ—Å—Ç—É–ø–Ω—ã–º –¥–ª—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –≤ –¥—Ä—É–≥–∏—Ö –æ–±–ª–∞—Å—Ç—è—Ö –≤–∏–¥–∏–º–æ—Å—Ç–∏.</p>
<p>–õ–∏—Å—Ç–∏–Ω–≥ 7-17 –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –∫–æ–¥ –∏–∑ –õ–∏—Å—Ç–∏–Ω–≥–∞ 7-11, –≥–¥–µ <code>use</code> –≤ –∫–æ—Ä–Ω–µ–≤–æ–º –º–æ–¥—É–ª–µ –∑–∞–º–µ–Ω–µ–Ω–æ –Ω–∞ <code>pub use</code>.</p>
<Listing number="7-17" file-name="src/lib.rs" caption="Making a name available for any code to use from a new scope with `pub use`">
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}</code></pre>
</Listing>
<p>–î–æ —ç—Ç–æ–≥–æ –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤–Ω–µ—à–Ω–∏–π –∫–æ–¥ –¥–æ–ª–∂–µ–Ω –±—ã–ª –≤—ã–∑—ã–≤–∞—Ç—å —Ñ—É–Ω–∫—Ü–∏—é <code>add_to_waitlist</code>, –∏—Å–ø–æ–ª—å–∑—É—è –ø—É—Ç—å <code>restaurant::front_of_house::hosting::add_to_waitlist()</code>. –¢–µ–ø–µ—Ä—å, –ø–æ—Å–∫–æ–ª—å–∫—É —ç—Ç–æ –æ–±—ä—è–≤–ª–µ–Ω–∏–µ <code>pub use</code> —Ä–µ—ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–ª–æ –º–æ–¥—É–ª—å <code>hosting</code> –∏–∑ –∫–æ—Ä–Ω–µ–≤–æ–≥–æ –º–æ–¥—É–ª—è, –≤–Ω–µ—à–Ω–∏–π –∫–æ–¥ —Ç–µ–ø–µ—Ä—å –º–æ–∂–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤–º–µ—Å—Ç–æ –Ω–µ–≥–æ –ø—É—Ç—å <code>restaurant::hosting::add_to_waitlist()</code>.</p>
<p>–†–µ—ç–∫—Å–ø–æ—Ä—Ç –ø–æ–ª–µ–∑–µ–Ω, –∫–æ–≥–¥–∞ –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –≤–∞—à–µ–≥–æ –∫–æ–¥–∞ –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è –æ—Ç —Ç–æ–≥–æ, –∫–∞–∫ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç—ã, –≤—ã–∑—ã–≤–∞—é—â–∏–µ –≤–∞—à –∫–æ–¥, –¥—É–º–∞—é—Ç –æ –ø—Ä–µ–¥–º–µ—Ç–Ω–æ–π –æ–±–ª–∞—Å—Ç–∏. –ù–∞–ø—Ä–∏–º–µ—Ä, –ø–æ –∞–Ω–∞–ª–æ–≥–∏–∏ —Å —Ä–µ—Å—Ç–æ—Ä–∞–Ω–æ–º –ª—é–¥–∏, —É–ø—Ä–∞–≤–ª—è—é—â–∏–µ –∏–º, –¥—É–º–∞—é—Ç –æ "front of house" –∏ "back of house". –ù–æ –∫–ª–∏–µ–Ω—Ç—ã, –ø–æ—Å–µ—â–∞—é—â–∏–µ —Ä–µ—Å—Ç–æ—Ä–∞–Ω, –≤–µ—Ä–æ—è—Ç–Ω–æ, –Ω–µ –±—É–¥—É—Ç –¥—É–º–∞—Ç—å –æ —á–∞—Å—Ç—è—Ö —Ä–µ—Å—Ç–æ—Ä–∞–Ω–∞ –≤ —Ç–∞–∫–∏—Ö —Ç–µ—Ä–º–∏–Ω–∞—Ö. –ò—Å–ø–æ–ª—å–∑—É—è <code>pub use</code>, –º—ã –º–æ–∂–µ–º –Ω–∞–ø–∏—Å–∞—Ç—å –Ω–∞—à –∫–æ–¥ —Å –æ–¥–Ω–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä–æ–π, –Ω–æ —Å–¥–µ–ª–∞—Ç—å –æ–±—â–µ–¥–æ—Å—Ç—É–ø–Ω–æ–π –¥—Ä—É–≥—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É. –ë–ª–∞–≥–æ–¥–∞—Ä—è —ç—Ç–æ–º—É –Ω–∞—à–∞ –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ —Ö–æ—Ä–æ—à–æ –æ—Ä–≥–∞–Ω–∏–∑–æ–≤–∞–Ω–∞ –∏ –¥–ª—è –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç–æ–≤, —Ä–∞–±–æ—Ç–∞—é—â–∏—Ö –Ω–∞–¥ –±–∏–±–ª–∏–æ—Ç–µ–∫–æ–π, –∏ –¥–ª—è –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç–æ–≤, –≤—ã–∑—ã–≤–∞—é—â–∏—Ö –±–∏–±–ª–∏–æ—Ç–µ–∫—É. –ú—ã —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º –µ—â—ë –æ–¥–∏–Ω –ø—Ä–∏–º–µ—Ä <code>pub use</code> –∏ –µ–≥–æ –≤–ª–∏—è–Ω–∏–µ –Ω–∞ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é –≤–∞—à–µ–≥–æ –∫—Ä–µ–π—Ç–∞ –≤ —Ä–∞–∑–¥–µ–ª–µ <a href="ch14-02-publishing-to-crates-io.html#%D0%AD%D0%BA%D1%81%D0%BF%D0%BE%D1%80%D1%82-%D1%83%D0%B4%D0%BE%D0%B1%D0%BD%D0%BE%D0%B3%D0%BE-%D0%BE%D0%B1%D1%89%D0%B5%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%BD%D0%BE%D0%B3%D0%BE-API-%D1%81-pub-use">"–≠–∫—Å–ø–æ—Ä—Ç —É–¥–æ–±–Ω–æ–≥–æ –æ–±—â–µ–¥–æ—Å—Ç—É–ø–Ω–æ–≥–æ API —Å <code>pub use</code>"</a><!-- ignore --> –ì–ª–∞–≤—ã 14.</p>
<h3 id="–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ-–≤–Ω–µ—à–Ω–∏—Ö-–ø–∞–∫–µ—Ç–æ–≤"><a class="header" href="#–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ-–≤–Ω–µ—à–Ω–∏—Ö-–ø–∞–∫–µ—Ç–æ–≤">–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≤–Ω–µ—à–Ω–∏—Ö –ø–∞–∫–µ—Ç–æ–≤</a></h3>
<p>–í –ì–ª–∞–≤–µ 2 –º—ã –∑–∞–ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–ª–∏ –∏–≥—Ä—É –≤ —É–≥–∞–¥–∞–π–∫—É, –≥–¥–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª—Å—è –≤–Ω–µ—à–Ω–∏–π –ø–∞–∫–µ—Ç —Å –∏–º–µ–Ω–µ–º <code>rand</code> –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å–ª—É—á–∞–π–Ω–æ–≥–æ —á–∏—Å–ª–∞. –ß—Ç–æ–±—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å <code>rand</code> –≤ –Ω–∞—à–µ–º –ø—Ä–æ–µ–∫—Ç–µ, –º—ã –¥–æ–±–∞–≤–∏–ª–∏ —ç—Ç—É —Å—Ç—Ä–æ–∫—É –≤ <em>Cargo.toml</em>.</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch02-00-guessing-game-tutorial.md
* ch14-03-cargo-workspaces.md
-->
<Listing file-name="Cargo.toml">
<pre><code class="language-toml">rand = "0.8.5"
</code></pre>
</Listing>
<p>–î–æ–±–∞–≤–ª–µ–Ω–∏–µ rand –≤ –∫–∞—á–µ—Å—Ç–≤–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –≤ <em>Cargo.toml</em> —É–∫–∞–∑—ã–≤–∞–µ—Ç Cargo –∑–∞–≥—Ä—É–∑–∏—Ç—å –ø–∞–∫–µ—Ç <code>rand</code> –∏ –≤—Å–µ –µ–≥–æ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ —Å <a href="https://crates.io/">crates.io</a> –∏ —Å–¥–µ–ª–∞—Ç—å <code>rand</code> –¥–æ—Å—Ç—É–ø–Ω—ã–º –¥–ª—è –Ω–∞—à–µ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞.</p>
<p>–ó–∞—Ç–µ–º, —á—Ç–æ–±—ã –ø–æ–¥–∫–ª—é—á–∏—Ç—å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è <code>rand</code> –≤ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ –Ω–∞—à–µ–≥–æ –ø–∞–∫–µ—Ç–∞, –º—ã –¥–æ–±–∞–≤–∏–ª–∏ —Å—Ç—Ä–æ–∫—É <code>use</code>, –Ω–∞—á–∏–Ω–∞—é—â—É—é—Å—è —Å –Ω–∞–∑–≤–∞–Ω–∏—è –ø–∞–∫–µ—Ç–∞ <code>rand</code> –∏ —Å–ø–∏—Å–∫–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –º—ã —Ö–æ—Ç–∏–º –ø–æ–¥–∫–ª—é—á–∏—Ç—å –≤ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏. –ù–∞–ø–æ–º–Ω–∏–º, —á—Ç–æ –≤ —Ä–∞–∑–¥–µ–ª–µ <a href="ch02-00-guessing-game-tutorial.html#%D0%93%D0%B5%D0%BD%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8F-%D1%81%D0%B5%D0%BA%D1%80%D0%B5%D1%82%D0%BD%D0%BE%D0%B3%D0%BE-%D1%87%D0%B8%D1%81%D0%BB%D0%B0">"–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–µ–∫—Ä–µ—Ç–Ω–æ–≥–æ —á–∏—Å–ª–∞"</a><!-- ignore -->–ì–ª–∞–≤—ã 2 –º—ã –ø–æ–¥–∫–ª—é—á–∏–ª–∏ —Ç—Ä–µ–π—Ç <code>Rng</code> –≤ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∏ –≤—ã–∑–≤–∞–ª–∏ —Ñ—É–Ω–∫—Ü–∏—é <code>rand::thread_rng</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span>use rand::Rng;

fn main() {
<span class="boring">    println!("–£–≥–∞–¥–∞–π—Ç–µ —á–∏—Å–ª–æ!");
</span><span class="boring">
</span>    let secret_number = rand::thread_rng().gen_range(1..=100);
<span class="boring">
</span><span class="boring">    println!("–ó–∞–≥–∞–¥–∞–Ω–Ω–æ–µ —á–∏—Å–ª–æ: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("–í–≤–µ–¥–∏—Ç–µ —Å–≤–æ—é –¥–æ–≥–∞–¥–∫—É.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–µ—Å—Ç—å –≤–≤–æ–¥.");
</span><span class="boring">
</span><span class="boring">    println!("–í—ã –ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏–ª–∏: {guess}");
</span>}</code></pre>
<p>–£—á–∞—Å—Ç–Ω–∏–∫–∏ –°–æ–æ–±—â–µ—Å—Ç–≤–∞ Rust —Å–æ–∑–¥–∞–ª–∏ –º–Ω–æ–∂–µ—Å—Ç–≤–æ –ø–∞–∫–µ—Ç–æ–≤, –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –Ω–∞ <a href="https://crates.io/">crates.io</a>, –∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –ª—é–±–æ–≥–æ –∏–∑ –Ω–∏—Ö –≤ –≤–∞—à –ø–∞–∫–µ—Ç –≤–∫–ª—é—á–∞–µ—Ç –≤ —Å–µ–±—è –æ–¥–Ω–∏ –∏ —Ç–µ –∂–µ —à–∞–≥–∏: –Ω—É–∂–Ω–æ –ø–µ—Ä–µ—á–∏—Å–ª–∏—Ç—å –∏—Ö –≤ —Ñ–∞–π–ª–µ <em>Cargo.toml</em> –≤–∞—à–µ–≥–æ –ø–∞–∫–µ—Ç–∞ –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å <code>use</code> –¥–ª—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤–Ω–µ—à–Ω–∏—Ö –ø–∞–∫–µ—Ç–æ–≤ –≤ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏.</p>
<p>–û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ <code>std</code> —Ç–∞–∫–∂–µ —è–≤–ª—è–µ—Ç—Å—è –∫—Ä–µ–π—Ç–æ–º, –≤–Ω–µ—à–Ω–∏–º –ø–æ –æ—Ç–Ω–æ—à–µ–Ω–∏—é –∫ –Ω–∞—à–µ–º—É –ø–∞–∫–µ—Ç—É. –ü–æ—Å–∫–æ–ª—å–∫—É —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ –ø–æ—Å—Ç–∞–≤–ª—è–µ—Ç—Å—è —Å —è–∑—ã–∫–æ–º Rust, –Ω–∞–º –Ω–µ –Ω—É–∂–Ω–æ –∏–∑–º–µ–Ω—è—Ç—å <em>Cargo.toml</em> –¥–ª—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è <code>std</code>. –ù–æ –Ω–∞–º –Ω—É–∂–Ω–æ —Å—Å—ã–ª–∞—Ç—å—Å—è –Ω–∞ –Ω–µ—ë –ø—Ä–∏ –ø–æ–º–æ—â–∏ <code>use</code>, —á—Ç–æ–±—ã –¥–æ–±–∞–≤–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç—ã –æ—Ç—Ç—É–¥–∞ –≤ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ –Ω–∞—à–µ–≥–æ –ø–∞–∫–µ—Ç–∞. –ù–∞–ø—Ä–∏–º–µ—Ä, —Å <code>HashMap</code> –º—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ –±—ã —ç—Ç—É —Å—Ç—Ä–æ–∫—É:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
<span class="boring">}</span></code></pre></pre>
<p>–≠—Ç–æ –∞–±—Å–æ–ª—é—Ç–Ω—ã–π –ø—É—Ç—å, –Ω–∞—á–∏–Ω–∞—é—â–∏–π—Å—è —Å <code>std</code>, –∏–º–µ–Ω–∏ –∫—Ä–µ–π—Ç–∞ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏.</p>
<h3 id="–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ-–ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è-–ø—É—Ç–µ–π-–¥–ª—è-—Å–æ–∫—Ä–∞—â–µ–Ω–∏—è-—Å—Ç—Ä–æ—á–µ–∫-use"><a class="header" href="#–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ-–ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è-–ø—É—Ç–µ–π-–¥–ª—è-—Å–æ–∫—Ä–∞—â–µ–Ω–∏—è-—Å—Ç—Ä–æ—á–µ–∫-use">–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –ø—É—Ç–µ–π –¥–ª—è —Å–æ–∫—Ä–∞—â–µ–Ω–∏—è —Å—Ç—Ä–æ—á–µ–∫ <code>use</code></a></h3>
<p>–ï—Å–ª–∏ –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤, –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã—Ö –≤ –æ–¥–Ω–æ–º –∫—Ä–µ–π—Ç–µ –∏–ª–∏ –≤ —Ç–æ–º –∂–µ –º–æ–¥—É–ª–µ, —Ç–æ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ –∫–∞–∂–¥–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–π —Å—Ç—Ä–æ–∫–µ –º–æ–∂–µ—Ç –∑–∞–Ω–∏–º–∞—Ç—å –º–Ω–æ–≥–æ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–≥–æ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞ –≤ —Ñ–∞–π–ª–µ. –ù–∞–ø—Ä–∏–º–µ—Ä, —ç—Ç–∏ –¥–≤–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ <code>use</code> –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –≤ –Ω–∞—à–µ–π –∏–≥—Ä–µ –≤ —É–≥–∞–¥–∞–π–∫—É (–õ–∏—Å—Ç–∏–Ω–≥ 2-4) –¥–ª—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∏–∑ <code>std</code> –≤ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏:</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
use std::cmp::Ordering;
use std::io;
// --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("–£–≥–∞–¥–∞–π—Ç–µ —á–∏—Å–ª–æ!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("–ó–∞–≥–∞–¥–∞–Ω–Ω–æ–µ —á–∏—Å–ª–æ: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("–í–≤–µ–¥–∏—Ç–µ —Å–≤–æ—é –¥–æ–≥–∞–¥–∫—É.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–µ—Å—Ç—å –≤–≤–æ–¥.");
</span><span class="boring">
</span><span class="boring">    println!("–í—ã –ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏–ª–∏: {guess}");
</span><span class="boring">
</span><span class="boring">    match guess.cmp(&amp;secret_number) {
</span><span class="boring">        Ordering::Less =&gt; println!("–°–ª–∏—à–∫–æ–º –º–∞–ª–µ–Ω—å–∫–æ–µ!"),
</span><span class="boring">        Ordering::Greater =&gt; println!("–°–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–µ!"),
</span><span class="boring">        Ordering::Equal =&gt; println!("–í—ã –ø–æ–±–µ–¥–∏–ª–∏!"),
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>–í–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ, –º—ã –º–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ –ø—É—Ç–µ–π, —á—Ç–æ–±—ã –¥–æ–±–∞–≤–∏—Ç—å —ç—Ç–∏ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ –æ–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–æ–π. –≠—Ç–æ –¥–µ–ª–∞–µ—Ç—Å—è, –∫–∞–∫ –ø–æ–∫–∞–∑–∞–Ω–æ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 7-18: —É–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è –æ–±—â–∞—è —á–∞—Å—Ç—å –ø—É—Ç–∏, –∑–∞ –∫–æ—Ç–æ—Ä–æ–π —Å–ª–µ–¥—É—é—Ç –¥–≤–∞ –¥–≤–æ–µ—Ç–æ—á–∏—è, –∞ –∑–∞—Ç–µ–º —Ñ–∏–≥—É—Ä–Ω—ã–µ —Å–∫–æ–±–∫–∏ –≤–æ–∫—Ä—É–≥ —Å–ø–∏—Å–∫–∞ —Ç–µ—Ö —á–∞—Å—Ç–µ–π –ø—É—Ç–∏, –∫–æ—Ç–æ—Ä—ã–µ –æ—Ç–ª–∏—á–∞—é—Ç—Å—è.</p>
<Listing number="7-18" file-name="src/main.rs" caption="Specifying a nested path to bring multiple items with the same prefix into scope">
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
use std::{cmp::Ordering, io};
// --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("–£–≥–∞–¥–∞–π—Ç–µ —á–∏—Å–ª–æ!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("–ó–∞–≥–∞–¥–∞–Ω–Ω–æ–µ —á–∏—Å–ª–æ: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("–í–≤–µ–¥–∏—Ç–µ —Å–≤–æ—é –¥–æ–≥–∞–¥–∫—É.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–µ—Å—Ç—å –≤–≤–æ–¥.");
</span><span class="boring">
</span><span class="boring">    let guess: u32 = guess.trim().parse().expect("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ!");
</span><span class="boring">
</span><span class="boring">    println!("–í—ã –ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏–ª–∏: {guess}");
</span><span class="boring">
</span><span class="boring">    match guess.cmp(&amp;secret_number) {
</span><span class="boring">        Ordering::Less =&gt; println!("–°–ª–∏—à–∫–æ–º –º–∞–ª–µ–Ω—å–∫–æ–µ!"),
</span><span class="boring">        Ordering::Greater =&gt; println!("–°–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–µ!"),
</span><span class="boring">        Ordering::Equal =&gt; println!("–í—ã –ø–æ–±–µ–¥–∏–ª–∏!"),
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>–í –±–æ–ª—å—à–∏—Ö –ø—Ä–æ–≥—Ä–∞–º–º–∞—Ö, –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –º–Ω–æ–∂–µ—Å—Ç–≤–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∏–∑ –æ–¥–Ω–æ–≥–æ –ø–∞–∫–µ—Ç–∞ –∏–ª–∏ –º–æ–¥—É–ª—è —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –ø—É—Ç–µ–π –º–æ–∂–µ—Ç –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ —Å–æ–∫—Ä–∞—Ç–∏—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö –æ—Ç–¥–µ–ª—å–Ω—ã—Ö –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–π <code>use</code>!</p>
<p>–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ –ø—É—Ç–µ–π –º–æ–∂–Ω–æ –Ω–∞ –ª—é–±–æ–º —É—Ä–æ–≤–Ω–µ, —á—Ç–æ –ø–æ–ª–µ–∑–Ω–æ –ø—Ä–∏ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–∏ –¥–≤—É—Ö –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–π <code>use</code>, –∫–æ—Ç–æ—Ä—ã–µ –∏–º–µ—é—Ç –æ–±—â—É—é —á–∞—Å—Ç—å –ø—É—Ç–∏. –ù–∞–ø—Ä–∏–º–µ—Ä, –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 7-19 –ø–æ–∫–∞–∑–∞–Ω—ã –¥–≤–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ <code>use</code>: –æ–¥–Ω–∞ –≤ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ –ø–æ–¥–∫–ª—é—á–∞–µ—Ç <code>std::io</code>, –∞ –¥—Ä—É–≥–∞—è ‚Äî <code>std::io::Write</code>.</p>
<Listing number="7-19" file-name="src/lib.rs" caption="Two `use` statements where one is a subpath of the other">
<pre><code class="language-rust noplayground">use std::io;
use std::io::Write;</code></pre>
</Listing>
<p>–û–±—â–µ–π —á–∞—Å—Ç—å—é —ç—Ç–∏—Ö –¥–≤—É—Ö –ø—É—Ç–µ–π —è–≤–ª—è–µ—Ç—Å—è <code>std::io</code>, –∏ —ç—Ç–æ –ø–æ–ª–Ω—ã–π –ø–µ—Ä–≤—ã–π –ø—É—Ç—å. –ß—Ç–æ–±—ã –æ–±—ä–µ–¥–∏–Ω–∏—Ç—å —ç—Ç–∏ –¥–≤–∞ –ø—É—Ç–∏ –≤ –æ–¥–Ω–æ–π –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ <code>use</code>, –º—ã –º–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ <code>self</code> –≤ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–∏ –ø—É—Ç–µ–π, –∫–∞–∫ –ø–æ–∫–∞–∑–∞–Ω–æ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 7-20.</p>
<Listing number="7-20" file-name="src/lib.rs" caption="Combining the paths in Listing 7-19 into one `use` statement">
<pre><code class="language-rust noplayground">use std::io::{self, Write};</code></pre>
</Listing>
<p>–≠—Ç–∞ —Å—Ç—Ä–æ–∫–∞ –ø–æ–¥–∫–ª—é—á–∞–µ—Ç <code>std::io</code> –∏ <code>std::io::Write</code> –≤ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏.</p>
<h3 id="–û–ø–µ—Ä–∞—Ç–æ—Ä-"><a class="header" href="#–û–ø–µ—Ä–∞—Ç–æ—Ä-">–û–ø–µ—Ä–∞—Ç–æ—Ä <code>*</code></a></h3>
<p>If we want to bring <em>all</em> public items defined in a path into scope, we can specify that path followed by the <code>*</code> glob operator:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::*;
<span class="boring">}</span></code></pre></pre>
<p>–≠—Ç–∞ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è <code>use</code> –ø–æ–¥–∫–ª—é—á–∞–µ—Ç –≤—Å–µ –æ—Ç–∫—Ä—ã—Ç—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã –∏–∑ –º–æ–¥—É–ª—è <code>std::collections</code> –≤ —Ç–µ–∫—É—â—É—é –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏. –ë—É–¥—å—Ç–µ –æ—Å—Ç–æ—Ä–æ–∂–Ω—ã –ø—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ <code>*</code>! –û–Ω –º–æ–∂–µ—Ç —É—Å–ª–æ–∂–Ω–∏—Ç—å –ø–æ–Ω–∏–º–∞–Ω–∏–µ, –∫–∞–∫–∏–µ –∏–º–µ–Ω–∞ –Ω–∞—Ö–æ–¥—è—Ç—Å—è –≤ –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∏ –≥–¥–µ –±—ã–ª–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω—ã –∏–º–µ–Ω–∞, –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–µ –≤ –≤–∞—à–µ–π –ø—Ä–æ–≥—Ä–∞–º–º–µ.</p>
<p>–û–ø–µ—Ä–∞—Ç–æ—Ä <code>*</code> —á–∞—Å—Ç–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ø—Ä–∏ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏ –¥–ª—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –≤—Å–µ–≥–æ, —á—Ç–æ –µ—Å—Ç—å –≤ –º–æ–¥—É–ª–µ <code>tests</code>; –º—ã –ø–æ–≥–æ–≤–æ—Ä–∏–º –æ–± —ç—Ç–æ–º –≤ —Ä–∞–∑–¥–µ–ª–µ <a href="ch11-01-writing-tests.html#%D0%9A%D0%B0%D0%BA-%D0%BF%D0%B8%D1%81%D0%B0%D1%82%D1%8C-%D1%82%D0%B5%D1%81%D1%82%D1%8B">"–ö–∞–∫ –ø–∏—Å–∞—Ç—å —Ç–µ—Å—Ç—ã"</a><!-- ignore --> –ì–ª–∞–≤—ã 11. –û–ø–µ—Ä–∞—Ç–æ—Ä <code>*</code> —Ç–∞–∫–∂–µ –∏–Ω–æ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∫–∞–∫ —á–∞—Å—Ç—å —à–∞–±–ª–æ–Ω–∞ prelude: –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ <a href="https://doc.rust-lang.org/std/prelude/index.html#other-preludes">–¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏</a><!-- ignore --> –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–†–∞–∑–º–µ—â–µ–Ω–∏–µ-–º–æ–¥—É–ª–µ–π-–≤-—Ä–∞–∑–Ω—ã—Ö-—Ñ–∞–π–ª–∞—Ö"><a class="header" href="#–†–∞–∑–º–µ—â–µ–Ω–∏–µ-–º–æ–¥—É–ª–µ–π-–≤-—Ä–∞–∑–Ω—ã—Ö-—Ñ–∞–π–ª–∞—Ö">–†–∞–∑–º–µ—â–µ–Ω–∏–µ –º–æ–¥—É–ª–µ–π –≤ —Ä–∞–∑–Ω—ã—Ö —Ñ–∞–π–ª–∞—Ö</a></h2>
<p>–î–æ —Å–∏—Ö –ø–æ—Ä –≤—Å–µ –ø—Ä–∏–º–µ—Ä—ã –≤ —ç—Ç–æ–π –≥–ª–∞–≤–µ –æ–ø—Ä–µ–¥–µ–ª—è–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ –º–æ–¥—É–ª–µ–π –≤ –æ–¥–Ω–æ–º —Ñ–∞–π–ª–µ. –ö–æ–≥–¥–∞ –º–æ–¥—É–ª–∏ —Å—Ç–∞–Ω–æ–≤—è—Ç—Å—è –±–æ–ª—å—à–∏–º–∏, –≤—ã –º–æ–∂–µ—Ç–µ –∑–∞—Ö–æ—Ç–µ—Ç—å –ø–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å –∏—Ö –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –≤ –æ—Ç–¥–µ–ª—å–Ω—ã–µ —Ñ–∞–π–ª—ã, —á—Ç–æ–±—ã —É–ø—Ä–æ—Å—Ç–∏—Ç—å –Ω–∞–≤–∏–≥–∞—Ü–∏—é –ø–æ –∫–æ–¥—É.</p>
<p>–î–ª—è –Ω–∞—á–∞–ª–∞, –¥–∞–≤–∞–π—Ç–µ —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º –∫–æ–¥ –õ–∏—Å—Ç–∏–Ω–≥–∞ 7-17, –≤ –∫–æ—Ç–æ—Ä–æ–º –±—ã–ª–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ –º–æ–¥—É–ª–µ–π —Ä–µ—Å—Ç–æ—Ä–∞–Ω–∞. –ú—ã –±—É–¥–µ–º –∏–∑–≤–ª–µ–∫–∞—Ç—å –º–æ–¥—É–ª–∏ –≤ —Ñ–∞–π–ª—ã –≤–º–µ—Å—Ç–æ —Ç–æ–≥–æ, —á—Ç–æ–±—ã –æ–ø—Ä–µ–¥–µ–ª—è—Ç—å –≤—Å–µ –º–æ–¥—É–ª–∏ –≤ —Ñ–∞–π–ª–µ –∫–æ—Ä–Ω—è –∫—Ä–µ–π—Ç–∞. –í –Ω–∞—à–µ–º —Å–ª—É—á–∞–µ, –∫–æ—Ä–µ–Ω—å –∫—Ä–µ–π—Ç–∞ ‚Äî —ç—Ç–æ <em>src/lib.rs</em>, –Ω–æ —ç—Ç–æ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ —Ç–∞–∫–∂–µ —Ä–∞–±–æ—Ç–∞–µ—Ç –∏ —Å –±–∏–Ω–∞—Ä–Ω—ã–º–∏ –∫—Ä–µ–π—Ç–∞–º–∏, —É –∫–æ—Ç–æ—Ä—ã—Ö –∫–æ—Ä–Ω–µ–º –∫—Ä–µ–π—Ç–∞ –±—É–¥–µ—Ç <em>src/main.rs</em>.</p>
<p>–°–Ω–∞—á–∞–ª–∞, –º—ã –∏–∑–≤–ª–µ—á—ë–º –º–æ–¥—É–ª—å <code>front_of_house</code> –≤ —Å–≤–æ–π —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–π —Ñ–∞–π–ª. –£–¥–∞–ª–∏—Ç–µ –∫–æ–¥ –≤–Ω—É—Ç—Ä–∏ —Ñ–∏–≥—É—Ä–Ω—ã—Ö —Å–∫–æ–±–æ–∫ –¥–ª—è –º–æ–¥—É–ª—è <code>front_of_house</code>, –æ—Å—Ç–∞–≤–∏–≤ —Ç–æ–ª—å–∫–æ –æ–±—ä—è–≤–ª–µ–Ω–∏–µ <code>mod front_of_house;</code>, —Ç–∞–∫ —á—Ç–æ —Ç–µ–ø–µ—Ä—å <em>src/lib.rs</em> —Å–æ–¥–µ—Ä–∂–∏—Ç –∫–æ–¥, –ø–æ–∫–∞–∑–∞–Ω–Ω—ã–π –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 7-21. –û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ —ç—Ç–æ—Ç –≤–∞—Ä–∏–∞–Ω—Ç –Ω–µ —Å–∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è, –ø–æ–∫–∞ –º—ã –Ω–µ —Å–æ–∑–¥–∞–¥–∏–º —Ñ–∞–π–ª <em>src/front_of_house.rs</em> —Å –∫–æ–¥–æ–º –∏–∑ –õ–∏—Å—Ç–∏–Ω–≥–∞ 7-22.</p>
<Listing number="7-21" file-name="src/lib.rs" caption="Declaring the `front_of_house` module whose body will be in *src/front_of_house.rs*">
<pre><code class="language-rust ignore does_not_compile">mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}</code></pre>
</Listing>
<p>–ó–∞—Ç–µ–º –ø–æ–º–µ—Å—Ç–∏–º –∫–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –±—ã–ª –≤ —Ñ–∏–≥—É—Ä–Ω—ã—Ö —Å–∫–æ–±–∫–∞—Ö, –≤ –Ω–æ–≤—ã–π —Ñ–∞–π–ª —Å –∏–º–µ–Ω–µ–º <em>src/front_of_house.rs</em>, –∫–∞–∫ –ø–æ–∫–∞–∑–∞–Ω–æ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 7-22. –ö–æ–º–ø–∏–ª—è—Ç–æ—Ä –∑–Ω–∞–µ—Ç, —á—Ç–æ –Ω—É–∂–Ω–æ –∏—Å–∫–∞—Ç—å –≤ —ç—Ç–æ–º —Ñ–∞–π–ª–µ, –ø–æ—Ç–æ–º—É —á—Ç–æ –æ–Ω –Ω–∞—Ç–∫–Ω—É–ª—Å—è –≤ –∫–æ—Ä–Ω–µ–≤–æ–º –º–æ–¥—É–ª–µ –∫—Ä–µ–π—Ç–∞ –Ω–∞ –æ–±—ä—è–≤–ª–µ–Ω–∏–µ –º–æ–¥—É–ª—è —Å –∏–º–µ–Ω–µ–º <code>front_of_house</code>.</p>
<Listing number="7-22" file-name="src/front_of_house.rs" caption="Definitions inside the `front_of_house` module in *src/front_of_house.rs*">
<pre><code class="language-rust ignore">pub mod hosting {
    pub fn add_to_waitlist() {}
}</code></pre>
</Listing>
<p>–û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ –≤–∞–º –Ω—É–∂–Ω–æ —Ç–æ–ª—å–∫–æ <em>–æ–¥–∏–Ω</em> —Ä–∞–∑ –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª —Å –ø–æ–º–æ—â—å—é –æ–±—ä—è–≤–ª–µ–Ω–∏—è <code>mod</code> –≤ –≤–∞—à–µ–º –¥–µ—Ä–µ–≤–µ –º–æ–¥—É–ª–µ–π. –ö–∞–∫ —Ç–æ–ª—å–∫–æ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä —É–∑–Ω–∞–µ—Ç, —á—Ç–æ —Ñ–∞–π–ª —è–≤–ª—è–µ—Ç—Å—è —á–∞—Å—Ç—å—é –ø—Ä–æ–µ–∫—Ç–∞ (–∏ —É–∑–Ω–∞–µ—Ç, –≥–¥–µ –≤ –¥–µ—Ä–µ–≤–µ –º–æ–¥—É–ª–µ–π –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –∫–æ–¥ –∏–∑-–∑–∞ —Ç–æ–≥–æ, –∫—É–¥–∞ –≤—ã –ø–æ–º–µ—Å—Ç–∏–ª–∏ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é <code>mod</code>), –¥—Ä—É–≥–∏–µ —Ñ–∞–π–ª—ã –≤ –≤–∞—à–µ–º –ø—Ä–æ–µ–∫—Ç–µ –¥–æ–ª–∂–Ω—ã —Å—Å—ã–ª–∞—Ç—å—Å—è –Ω–∞ –∫–æ–¥ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞, –∏—Å–ø–æ–ª—å–∑—É—è –ø—É—Ç—å –∫ –º–µ—Å—Ç—É, –≥–¥–µ –æ–Ω –±—ã–ª –æ–±—ä—è–≤–ª–µ–Ω, –∫–∞–∫ –æ–ø–∏—Å–∞–Ω–æ –≤ —Ä–∞–∑–¥–µ–ª–µ <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">"–ü—É—Ç–∏ –¥–ª—è —Å—Å—ã–ª–∫–∏ –Ω–∞ —ç–ª–µ–º–µ–Ω—Ç –≤ –¥–µ—Ä–µ–≤–µ –º–æ–¥—É–ª–µ–π"</a><!-- ignore -->. –î—Ä—É–≥–∏–º–∏ —Å–ª–æ–≤–∞–º–∏, <code>mod</code> ‚Äî —ç—Ç–æ –Ω–µ –æ–ø–µ—Ä–∞—Ü–∏—è "–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è", –∫–æ—Ç–æ—Ä—É—é –≤—ã –º–æ–≥–ª–∏ –≤–∏–¥–µ—Ç—å –≤ –¥—Ä—É–≥–∏—Ö —è–∑—ã–∫–∞—Ö –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è.</p>
<p>–î–∞–ª–µ–µ –º—ã –∏–∑–≤–ª–µ—á—ë–º –º–æ–¥—É–ª—å <code>hosting</code> –≤ –µ–≥–æ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–π —Ñ–∞–π–ª. –ü—Ä–æ—Ü–µ—Å—Å –Ω–µ–º–Ω–æ–≥–æ –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è, –ø–æ—Ç–æ–º—É —á—Ç–æ <code>hosting</code> —è–≤–ª—è–µ—Ç—Å—è –¥–æ—á–µ—Ä–Ω–∏–º –º–æ–¥—É–ª–µ–º –¥–ª—è <code>front_of_house</code>, –∞ –Ω–µ –∫–æ—Ä–Ω—è –∫—Ä–µ–π—Ç–∞. –ú—ã –ø–æ–º–µ—Å—Ç–∏–º —Ñ–∞–π–ª –¥–ª—è <code>hosting</code> –≤ –Ω–æ–≤—ã–π –∫–∞—Ç–∞–ª–æ–≥, –∫–æ—Ç–æ—Ä—ã–π –±—É–¥–µ—Ç –Ω–∞–∑–≤–∞–Ω –ø–æ –∏–º–µ–Ω–∏ –µ–≥–æ –ø—Ä–µ–¥–∫–∞ –≤ –¥–µ—Ä–µ–≤–µ –º–æ–¥—É–ª–µ–π (–≤ –¥–∞–Ω–Ω–æ–º —Å–ª—É—á–∞–µ ‚Äî <em>src/front_of_house/</em>).</p>
<p>–ß—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –ø–µ—Ä–µ–Ω–æ—Å <code>hosting</code>, –º—ã –ø–æ–º–µ–Ω—è–µ–º <em>src/front_of_house.rs</em> —Ç–∞–∫, —á—Ç–æ–±—ã –æ–Ω —Å–æ–¥–µ—Ä–∂–∞–ª —Ç–æ–ª—å–∫–æ –æ–±—ä—è–≤–ª–µ–Ω–∏–µ –º–æ–¥—É–ª—è <code>hosting</code>:</p>
<Listing file-name="src/front_of_house.rs">
<pre><code class="language-rust ignore">pub mod hosting;</code></pre>
</Listing>
<p>–ó–∞—Ç–µ–º –º—ã —Å–æ–∑–¥–∞—ë–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é <em>src/front_of_house</em> –∏ —Ñ–∞–π–ª <em>hosting.rs</em>, –≤ –∫–æ—Ç–æ—Ä–æ–º –±—É–¥—É—Ç –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è, –Ω–∞–ø–∏—Å–∞–Ω–Ω—ã–µ –≤ –º–æ–¥—É–ª–µ <code>hosting</code>:</p>
<Listing file-name="src/front_of_house/hosting.rs">
<pre><code class="language-rust ignore">pub fn add_to_waitlist() {}</code></pre>
</Listing>
<p>–ï—Å–ª–∏ –≤–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ –º—ã –ø–æ–º–µ—Å—Ç–∏–º <em>hosting.rs</em> –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é <em>src</em>, –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –±—É–¥–µ—Ç –¥—É–º–∞—Ç—å, —á—Ç–æ –∫–æ–¥ –≤ <em>hosting.rs</em> —ç—Ç–æ –º–æ–¥—É–ª—å <code>hosting</code>, –æ–±—ä—è–≤–ª–µ–Ω–Ω—ã–π –≤ –∫–æ—Ä–Ω–µ –∫—Ä–µ–π—Ç–∞, –∞ –Ω–µ –æ–±—ä—è–≤–ª–µ–Ω–Ω—ã–π –∫–∞–∫ –¥–æ—á–µ—Ä–Ω–∏–π –º–æ–¥—É–ª—å <code>front_of_house</code>. –ü—Ä–∞–≤–∏–ª–∞ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ç–æ–≥–æ, –∫–∞–∫–∏–µ —Ñ–∞–π–ª—ã —Å–æ–¥–µ—Ä–∂–∞—Ç –∫–æ–¥ –∫–∞–∫–∏—Ö –º–æ–¥—É–ª–µ–π, –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞—é—Ç, —á—Ç–æ –∫–∞—Ç–∞–ª–æ–≥–∏ –∏ —Ñ–∞–π–ª—ã —Ç–æ—á–Ω–æ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—Ç –¥–µ—Ä–µ–≤—É –º–æ–¥—É–ª–µ–π.</p>
<blockquote>
<h3 id="–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ-–ø—É—Ç–∏-–∫-—Ñ–∞–π–ª–∞–º"><a class="header" href="#–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ-–ø—É—Ç–∏-–∫-—Ñ–∞–π–ª–∞–º">–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –ø—É—Ç–∏ –∫ —Ñ–∞–π–ª–∞–º</a></h3>
<p>–î–æ —Å–∏—Ö –ø–æ—Ä –º—ã —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞–ª–∏ –Ω–∞–∏–±–æ–ª–µ–µ –∏–¥–∏–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –ø—É—Ç–∏ –∫ —Ñ–∞–π–ª–∞–º, –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–µ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–æ–º Rust, –Ω–æ Rust —Ç–∞–∫–∂–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∏ —Å—Ç–∞—Ä—ã–π —Å—Ç–∏–ª—å –ø—É—Ç–∏ –∫ —Ñ–∞–π–ª—É. –î–ª—è –º–æ–¥—É–ª—è —Å –∏–º–µ–Ω–µ–º <code>front_of_house</code>, –æ–±—ä—è–≤–ª–µ–Ω–Ω–æ–≥–æ –≤ –∫–æ—Ä–Ω–µ –∫—Ä–µ–π—Ç–∞, –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –±—É–¥–µ—Ç –∏—Å–∫–∞—Ç—å –∫–æ–¥ –º–æ–¥—É–ª—è –≤:</p>
<ul>
<li><em>src/front_of_house.rs</em> (—Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π —Å—Ç–∏–ª—å; –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª—Å—è –Ω–∞–º–∏ –¥–æ —Å–∏—Ö –ø–æ—Ä)</li>
<li><em>src/front_of_house/mod.rs</em> (—Å—Ç–∞—Ä—ã–π —Å—Ç–∏–ª—å; –≤—Å—ë –µ—â—ë –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è)</li>
</ul>
<p>–î–ª—è –º–æ–¥—É–ª—è —Å –∏–º–µ–Ω–µ–º <code>hosting</code>, –∫–æ—Ç–æ—Ä—ã–π —è–≤–ª—è–µ—Ç—Å—è –ø–æ–¥–º–æ–¥—É–ª–µ–º <code>front_of_house</code>, –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –±—É–¥–µ—Ç –∏—Å–∫–∞—Ç—å –∫–æ–¥ –º–æ–¥—É–ª—è –≤:</p>
<ul>
<li><em>src/front_of_house/hosting.rs</em> (—Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π —Å—Ç–∏–ª—å; –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª—Å—è –Ω–∞–º–∏ –¥–æ —Å–∏—Ö –ø–æ—Ä)</li>
<li><em>src/front_of_house/hosting/mod.rs</em> (—Å—Ç–∞—Ä—ã–π —Å—Ç–∏–ª—å; –≤—Å—ë –µ—â—ë –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è)</li>
</ul>
<p>–ï—Å–ª–∏ –≤—ã –∏—Å–ø–æ–ª—å–∑—É–µ—Ç–µ –æ–±–∞ —Å—Ç–∏–ª—è –¥–ª—è –æ–¥–Ω–æ–≥–æ –∏ —Ç–æ–≥–æ –∂–µ –º–æ–¥—É–ª—è, –≤—ã –ø–æ–ª—É—á–∏—Ç–µ –æ—à–∏–±–∫—É –∫–æ–º–ø–∏–ª—è—Ü–∏–∏. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Å–æ—á–µ—Ç–∞–Ω–∏—è –æ–±–æ–∏—Ö —Å—Ç–∏–ª–µ–π –¥–ª—è —Ä–∞–∑–Ω—ã—Ö –º–æ–¥—É–ª–µ–π –≤ –æ–¥–Ω–æ–º –ø—Ä–æ–µ–∫—Ç–µ –¥–æ–ø—É—Å—Ç–∏–º–æ, –Ω–æ —ç—Ç–æ –º–æ–∂–µ—Ç —Å–±–∏–≤–∞—Ç—å —Å —Ç–æ–ª–∫—É –ª—é–¥–µ–π, –ø–µ—Ä–µ–º–µ—â–∞—é—â–∏—Ö—Å—è –ø–æ –≤–∞—à–µ–º—É –ø—Ä–æ–µ–∫—Ç—É.</p>
<p>–û—Å–Ω–æ–≤–Ω—ã–º –Ω–µ–¥–æ—Å—Ç–∞—Ç–∫–æ–º —Å—Ç–∏–ª—è, –≤ –∫–æ—Ç–æ—Ä–æ–º –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è —Ñ–∞–π–ª—ã —Å –∏–º–µ–Ω–∞–º–∏ <em>mod.rs</em>, —è–≤–ª—è–µ—Ç—Å—è —Ç–æ, —á—Ç–æ –≤ –≤–∞—à–µ–º –ø—Ä–æ–µ–∫—Ç–µ –º–æ–∂–µ—Ç –æ–∫–∞–∑–∞—Ç—å—Å—è –º–Ω–æ–≥–æ —Ñ–∞–π–ª–æ–≤ —Å –∏–º–µ–Ω–∞–º–∏ <em>mod.rs</em>, —á—Ç–æ –º–æ–∂–µ—Ç –ø—Ä–∏–≤–µ—Å—Ç–∏ –∫ –ø—É—Ç–∞–Ω–∏—Ü–µ, –µ—Å–ª–∏ –≤—ã –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –æ—Ç–∫—Ä–æ–µ—Ç–µ –∏—Ö –≤ —Ä–µ–¥–∞–∫—Ç–æ—Ä–µ.</p>
</blockquote>
<p>–ú—ã –ø–µ—Ä–µ–Ω–µ—Å–ª–∏ –∫–æ–¥ –∫–∞–∂–¥–æ–≥–æ –º–æ–¥—É–ª—è –≤ –æ—Ç–¥–µ–ª—å–Ω—ã–π —Ñ–∞–π–ª, –∞ –¥–µ—Ä–µ–≤–æ –º–æ–¥—É–ª–µ–π –æ—Å—Ç–∞–ª–æ—Å—å –ø—Ä–µ–∂–Ω–∏–º. –í—ã–∑–æ–≤—ã —Ñ—É–Ω–∫—Ü–∏–π –≤ <code>eat_at_restaurant</code> –±—É–¥—É—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –±–µ–∑ –∫–∞–∫–∏—Ö-–ª–∏–±–æ –∏–∑–º–µ–Ω–µ–Ω–∏–π, –Ω–µ—Å–º–æ—Ç—Ä—è –Ω–∞ —Ç–æ, —á—Ç–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –Ω–∞—Ö–æ–¥—è—Ç—Å—è –≤ —Ä–∞–∑–Ω—ã—Ö —Ñ–∞–π–ª–∞—Ö. –≠—Ç–æ—Ç –º–µ—Ç–æ–¥ –ø–æ–∑–≤–æ–ª—è–µ—Ç –ø–µ—Ä–µ–º–µ—â–∞—Ç—å –º–æ–¥—É–ª–∏ –≤ –Ω–æ–≤—ã–µ —Ñ–∞–π–ª—ã –ø–æ –º–µ—Ä–µ –∏—Ö —Ä–∞–∑—Ä–∞—Å—Ç–∞–Ω–∏—è.</p>
<p>–û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è <code>pub use crate::front_of_house::hosting</code> –≤ <em>src/lib.rs</em> —Ç–∞–∫–∂–µ –Ω–µ –∏–∑–º–µ–Ω–∏–ª–∞—Å—å, –∏ <code>use</code> –Ω–µ –≤–ª–∏—è–µ—Ç –Ω–∞ —Ç–æ, –∫–∞–∫–∏–µ —Ñ–∞–π–ª—ã –∫–æ–º–ø–∏–ª–∏—Ä—É—é—Ç—Å—è –∫–∞–∫ —á–∞—Å—Ç—å –∫—Ä–µ–π—Ç–∞. –ö–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ <code>mod</code> –æ–±—ä—è–≤–ª—è–µ—Ç –º–æ–¥—É–ª–∏, –∏ Rust –∏—â–µ—Ç –∫–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –≤—Ö–æ–¥–∏—Ç –≤ —ç—Ç–æ—Ç –º–æ–¥—É–ª—å, –≤ —Ñ–∞–π–ª–µ —Å —Ç–µ–º –∂–µ –∏–º–µ–Ω–µ–º, —á—Ç–æ –∏ —É –º–æ–¥—É–ª—è.</p>
<h2 id="–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-6"><a class="header" href="#–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-6">–ü–æ–¥–≤–µ–¥—ë–º –∏—Ç–æ–≥–∏</a></h2>
<p>Rust –ø–æ–∑–≤–æ–ª—è–µ—Ç —Ä–∞–∑–±–∏–≤–∞—Ç—å –ø–∞–∫–µ—Ç –Ω–∞ –Ω–µ—Å–∫–æ–ª—å–∫–æ –∫—Ä–µ–π—Ç–æ–≤, –∞ –∫—Ä–µ–π—Ç ‚Äî –Ω–∞ –º–æ–¥—É–ª–∏, —Ç–∞–∫ —á—Ç–æ –≤—ã –º–æ–∂–µ—Ç–µ —Å—Å—ã–ª–∞—Ç—å—Å—è –Ω–∞ —ç–ª–µ–º–µ–Ω—Ç—ã, –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã–µ –≤ –æ–¥–Ω–æ–º –º–æ–¥—É–ª–µ, –∏–∑ –¥—Ä—É–≥–æ–≥–æ –º–æ–¥—É–ª—è. –≠—Ç–æ –º–æ–∂–Ω–æ –¥–µ–ª–∞—Ç—å –ø—Ä–∏ –ø–æ–º–æ—â–∏ —É–∫–∞–∑–∞–Ω–∏—è –∞–±—Å–æ–ª—é—Ç–Ω—ã—Ö –∏–ª–∏ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã—Ö –ø—É—Ç–µ–π. –≠—Ç–∏ –ø—É—Ç–∏ –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –≤ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–µ–π <code>use</code>, –ø–æ—ç—Ç–æ–º—É –≤—ã –º–æ–∂–µ—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –±–æ–ª–µ–µ –∫–æ—Ä–æ—Ç–∫–∏–º–∏ –ø—É—Ç—è–º–∏ –¥–ª—è –º–Ω–æ–≥–æ–∫—Ä–∞—Ç–Ω–æ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤ —ç—Ç–æ–π –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏. –ö–æ–¥ –º–æ–¥—É–ª—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é —è–≤–ª—è–µ—Ç—Å—è –ø—Ä–∏–≤–∞—Ç–Ω—ã–º,  –Ω–æ –º–æ–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –æ–±—â–µ–¥–æ—Å—Ç—É–ø–Ω—ã–º–∏, –¥–æ–±–∞–≤–∏–≤ –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ <code>pub</code>.</p>
<p>–í —Å–ª–µ–¥—É—é—â–µ–π –≥–ª–∞–≤–µ –º—ã —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –∫–æ–ª–ª–µ–∫—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö –∏–∑ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏, –∫–æ—Ç–æ—Ä—ã–µ –≤—ã –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤ —Å–≤–æ—ë–º (—Ö–æ—Ä–æ—à–æ —Ç–µ–ø–µ—Ä—å –æ—Ä–≥–∞–Ω–∏–∑–æ–≤–∞–Ω–Ω–æ–º) –∫–æ–¥–µ.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ-–∫–æ–ª–ª–µ–∫—Ü–∏–∏-–¥–∞–Ω–Ω—ã—Ö"><a class="header" href="#–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ-–∫–æ–ª–ª–µ–∫—Ü–∏–∏-–¥–∞–Ω–Ω—ã—Ö">–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –∫–æ–ª–ª–µ–∫—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö</a></h1>
<p>–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ Rust —Å–æ–¥–µ—Ä–∂–∏—Ç –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–æ–ª–µ–∑–Ω—ã—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä –¥–∞–Ω–Ω—ã—Ö, –∫–æ—Ç–æ—Ä—ã–µ –Ω–∞–∑—ã–≤–∞—é—Ç—Å—è <em>–∫–æ–ª–ª–µ–∫—Ü–∏—è–º–∏</em>. –ë–æ–ª—å—à–∞—è —á–∞—Å—Ç—å –¥—Ä—É–≥–∏—Ö —Ç–∏–ø–æ–≤ –¥–∞–Ω–Ω—ã—Ö –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—Ç —Å–æ–±–æ–π —Ö—Ä–∞–Ω–µ–Ω–∏–µ –æ–¥–Ω–æ–≥–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è, –Ω–æ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç—å—é –∫–æ–ª–ª–µ–∫—Ü–∏–π —è–≤–ª—è–µ—Ç—Å—è —Ö—Ä–∞–Ω–µ–Ω–∏–µ –º–Ω–æ–∂–µ—Å—Ç–≤–∞ –æ–¥–Ω–æ—Ç–∏–ø–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π. –í –æ—Ç–ª–∏—á–∏–µ –æ—Ç –º–∞—Å—Å–∏–≤–∞ –∏–ª–∏ –∫–æ—Ä—Ç–µ–∂–∞, –¥–∞–Ω–Ω—ã–µ –∫–æ–ª–ª–µ–∫—Ü–∏–π —Ö—Ä–∞–Ω—è—Ç—Å—è –≤ –∫—É—á–µ, –∞ —ç—Ç–æ –∑–Ω–∞—á–∏—Ç, —á—Ç–æ —Ä–∞–∑–º–µ—Ä –∫–æ–ª–ª–µ–∫—Ü–∏–∏ –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–µ–∏–∑–≤–µ—Å—Ç–µ–Ω –≤ –º–æ–º–µ–Ω—Ç –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –ø—Ä–æ–≥—Ä–∞–º–º—ã. –ù–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –∫–æ–ª–ª–µ–∫—Ü–∏–π –º–æ–∂–Ω–æ –º–µ–Ω—è—Ç—å –≤–æ –≤—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã –ø—Ä–æ–≥—Ä–∞–º–º—ã. –ö–∞–∂–¥—ã–π –≤–∏–¥ –∫–æ–ª–ª–µ–∫—Ü–∏–π –∏–º–µ–µ—Ç —Å–≤–æ–∏ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –∏ –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è –ø–æ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏, —Ç–∞–∫ —á—Ç–æ –≤—ã–±–æ—Ä –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –∫–æ–ª–ª–µ–∫—Ü–∏–∏ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Å–∏—Ç—É–∞—Ü–∏–∏ –∏ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –Ω–∞–≤—ã–∫–∞ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞, –≤—ã—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º–æ–≥–æ —Å–æ –≤—Ä–µ–º–µ–Ω–µ–º. –í —ç—Ç–æ–π –≥–ª–∞–≤–µ –±—É–¥–µ—Ç —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–æ —Ç—Ä–∏ —Ç–∏–ø–∞ –∫–æ–ª–ª–µ–∫—Ü–∏–π:</p>
<ul>
<li><em>–í–µ–∫—Ç–æ—Ä</em> ‚Äî –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã–π, –ø–µ—Ä–º–µ–Ω–Ω–æ–π –¥–ª–∏–Ω—ã —Å–ø–∏—Å–æ–∫ –∑–Ω–∞—á–µ–Ω–∏–π.</li>
<li><em>–°—Ç—Ä–æ–∫–∞</em> ‚Äî –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Å–∏–º–≤–æ–ª–æ–≤. –ú—ã —Ä–∞–Ω–µ–µ —É–∂–µ –≥–æ–≤–æ—Ä–∏–ª–∏ –æ —Ç–∏–ø–µ <code>String</code>, –Ω–æ –≤ —ç—Ç–æ–π –≥–ª–∞–≤–µ –º—ã –æ–±—Å—É–¥–∏–º —Å—Ç—Ä–æ–∫–∏ –ø–æ–¥—Ä–æ–±–Ω–µ–µ.</li>
<li><em>–•–µ—à-—Ç–∞–±–ª–∏—Ü–∞</em> ‚Äî –Ω–∞–±–æ—Ä –ø–∞—Ä –∫–ª—é—á-–∑–Ω–∞—á–µ–Ω–∏–µ. –Ø–≤–ª—è–µ—Ç—Å—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–µ–π –±–æ–ª–µ–µ –æ–±—â–µ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö, –∏–∑–≤–µ—Å—Ç–Ω–æ–π –∫–∞–∫ <em>–∞—Å—Å–æ—Ü–∏–∞—Ç–∏–≤–Ω—ã–π –º–∞—Å—Å–∏–≤</em>.</li>
</ul>
<p>–î–ª—è —Ç–æ–≥–æ, —á—Ç–æ–±—ã —É–∑–Ω–∞—Ç—å –æ –¥—Ä—É–≥–∏—Ö –≤–∏–¥–∞—Ö –∫–æ–ª–ª–µ–∫—Ü–∏–π, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ–º—ã—Ö —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–æ–π, –ø–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –≤ [–¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é] (https://doc.rust-lang.org/std/collections/index.html).</p>
<p>–ú—ã –æ–±—Å—É–¥–∏–º, –∫–∞–∫ —Å–æ–∑–¥–∞–≤–∞—Ç—å –∏ –æ–±–Ω–æ–≤–ª—è—Ç—å –≤–µ–∫—Ç–æ—Ä—ã, —Å—Ç—Ä–æ–∫–∏ –∏ —Ö–µ—à-—Ç–∞–±–ª–∏—Ü—ã, –∞ —Ç–∞–∫–∂–µ –æ–±—ä—è—Å–Ω–∏–º, —á—Ç–æ –¥–µ–ª–∞–µ—Ç –æ—Å–æ–±–µ–Ω–Ω–æ–π –∫–∞–∂–¥—É—é –∏–∑ —ç—Ç–∏—Ö –∫–æ–ª–ª–µ–∫—Ü–∏–π.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–•—Ä–∞–Ω–µ–Ω–∏–µ-—Å–ø–∏—Å–∫–∞-–∑–Ω–∞—á–µ–Ω–∏–π-—Å-–ø–æ–º–æ—â—å—é-–≤–µ–∫—Ç–æ—Ä–æ–≤"><a class="header" href="#–•—Ä–∞–Ω–µ–Ω–∏–µ-—Å–ø–∏—Å–∫–∞-–∑–Ω–∞—á–µ–Ω–∏–π-—Å-–ø–æ–º–æ—â—å—é-–≤–µ–∫—Ç–æ—Ä–æ–≤">–•—Ä–∞–Ω–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –∑–Ω–∞—á–µ–Ω–∏–π —Å –ø–æ–º–æ—â—å—é –≤–µ–∫—Ç–æ—Ä–æ–≤</a></h2>
<p>–ü–µ—Ä–≤—ã–º —Ç–∏–ø–æ–º –∫–æ–ª–ª–µ–∫—Ü–∏–∏, –∫–æ—Ç–æ—Ä—ã–π –º—ã —Ä–∞–∑–±–µ—Ä—ë–º, –±—É–¥–µ—Ç <code>Vec&lt;T&gt;</code>, —Ç–∞–∫–∂–µ –∏–∑–≤–µ—Å—Ç–Ω—ã–π –∫–∞–∫ <em>–≤–µ–∫—Ç–æ—Ä</em>. –í–µ–∫—Ç–æ—Ä—ã –ø–æ–∑–≤–æ–ª—è—é—Ç —Ö—Ä–∞–Ω–∏—Ç—å –±–æ–ª–µ–µ –æ–¥–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è –≤ –µ–¥–∏–Ω–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä–µ –¥–∞–Ω–Ω—ã—Ö, —Ä–∞–∑–º–µ—â–∞—é—â–µ–π —ç–ª–µ–º–µ–Ω—Ç—ã –≤ –ø–∞–º—è—Ç–∏ –æ–¥–∏–Ω –∑–∞ –¥—Ä—É–≥–∏–º. –í–µ–∫—Ç–æ—Ä—ã –º–æ–≥—É—Ç —Ö—Ä–∞–Ω–∏—Ç—å –¥–∞–Ω–Ω—ã–µ —Ç–æ–ª—å–∫–æ –æ–¥–Ω–æ–≥–æ —Ç–∏–ø–∞. –ò—Ö —É–¥–æ–±–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å, –∫–æ–≥–¥–∞ –Ω—É–∂–Ω–æ —Ö—Ä–∞–Ω–∏—Ç—å —Å–ø–∏—Å–æ–∫ —ç–ª–µ–º–µ–Ω—Ç–æ–≤: –Ω–∞–ø—Ä–∏–º–µ—Ä, —Å–ø–∏—Å–æ–∫ —Å—Ç—Ä–æ–∫ —Ç–µ–∫—Å—Ç–∞ —Ñ–∞–π–ª–∞, –∏–ª–∏ —Å–ø–∏—Å–æ–∫ —Ü–µ–Ω —Ç–æ–≤–∞—Ä–æ–≤ –≤ –∫–æ—Ä–∑–∏–Ω–µ –ø–æ–∫—É–ø–æ–∫.</p>
<h3 id="–°–æ–∑–¥–∞–Ω–∏–µ-–Ω–æ–≤–æ–≥–æ-–≤–µ–∫—Ç–æ—Ä–∞"><a class="header" href="#–°–æ–∑–¥–∞–Ω–∏–µ-–Ω–æ–≤–æ–≥–æ-–≤–µ–∫—Ç–æ—Ä–∞">–°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞</a></h3>
<p>–ß—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –ø—É—Å—Ç–æ–π –≤–µ–∫—Ç–æ—Ä, –º—ã –≤—ã–∑—ã–≤–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é <code>Vec::new</code>, –∫–∞–∫ –ø–æ–∫–∞–∑–∞–Ω–æ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 8-1.</p>
<Listing number="8-1" caption="Creating a new, empty vector to hold values of type `i32`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let v: Vec&lt;i32&gt; = Vec::new();
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>–û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ –∑–¥–µ—Å—å –º—ã –¥–æ–±–∞–≤–∏–ª–∏ –∞–Ω–Ω–æ—Ç–∞—Ü–∏—é —Ç–∏–ø–∞. –ü–æ—Å–∫–æ–ª—å–∫—É –º—ã –Ω–µ –ø–æ–º–µ—â–∞–µ–º –Ω–∏–∫–∞–∫–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π –≤ —ç—Ç–æ—Ç –≤–µ–∫—Ç–æ—Ä, Rust –Ω–µ –∑–Ω–∞–µ—Ç, —ç–ª–µ–º–µ–Ω—Ç—ã –∫–∞–∫–æ–≥–æ —Ç–∏–ø–∞ –º—ã —Å–æ–±–∏—Ä–∞–µ–º—Å—è —Ö—Ä–∞–Ω–∏—Ç—å. –≠—Ç–æ –≤–∞–∂–Ω—ã–π –º–æ–º–µ–Ω—Ç. –í–µ–∫—Ç–æ—Ä—ã —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω—ã —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –æ–±–æ–±—â—ë–Ω–Ω—ã—Ö —Ç–∏–ø–æ–≤; –º—ã —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º, –∫–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –æ–±–æ–±—â—ë–Ω–Ω—ã–µ —Ç–∏–ø—ã —Å –≤–∞—à–∏–º–∏ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–º–∏ —Ç–∏–ø–∞–º–∏, –≤ –ì–ª–∞–≤–µ 10. –ê –ø–æ–∫–∞ –∑–Ω–∞–π—Ç–µ, —á—Ç–æ —Ç–∏–ø <code>Vec&lt;T&gt;</code>, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ–º—ã–π —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–æ–π, –º–æ–∂–µ—Ç —Ö—Ä–∞–Ω–∏—Ç—å –ª—é–±–æ–π —Ç–∏–ø. –ö–æ–≥–¥–∞ –º—ã —Å–æ–∑–¥–∞—ë–º –Ω–æ–≤—ã–π –≤–µ–∫—Ç–æ—Ä –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Ç–∏–ø–∞, –º—ã –º–æ–∂–µ–º —É–∫–∞–∑–∞—Ç—å —ç—Ç–æ—Ç —Ç–∏–ø –≤ —É–≥–ª–æ–≤—ã—Ö —Å–∫–æ–±–∫–∞—Ö. –í –õ–∏—Å—Ç–∏–Ω–≥–µ 8-1 –º—ã —Å–æ–æ–±—â–∏–ª–∏ Rust, —á—Ç–æ <code>Vec&lt;T&gt;</code> –≤ <code>v</code> –±—É–¥–µ—Ç —Ö—Ä–∞–Ω–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç—ã —Ç–∏–ø–∞ <code>i32</code>.</p>
<p>–ß–∞—â–µ –≤—Å–µ–≥–æ –≤—ã –±—É–¥–µ—Ç–µ —Å–æ–∑–¥–∞–≤–∞—Ç—å <code>Vec&lt;T&gt;</code> —Å –Ω–∞—á–∞–ª—å–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏, –∏ Rust –º–æ–∂–µ—Ç –æ–ø—Ä–µ–¥–µ–ª—è—Ç—å —Ç–∏–ø —Å–æ—Ö—Ä–∞–Ω—è–µ–º—ã—Ö –≤–∞–º–∏ –∑–Ω–∞—á–µ–Ω–∏–π, –Ω–æ –∏–Ω–æ–≥–¥–∞ –≤–∞–º –≤—Å—ë –∂–µ –ø—Ä–∏–¥—ë—Ç—Å—è —É–∫–∞–∑—ã–≤–∞—Ç—å –∞–Ω–Ω–æ—Ç–∞—Ü–∏—é —Ç–∏–ø–∞. –î–ª—è —É–¥–æ–±—Å—Ç–≤–∞, Rust –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç –º–∞–∫—Ä–æ—Å <code>vec!</code>, –∫–æ—Ç–æ—Ä—ã–π —Å–æ–∑–¥–∞—Å—Ç –Ω–æ–≤—ã–π –≤–µ–∫—Ç–æ—Ä, —Å–æ–¥–µ—Ä–∂–∞—â–∏–π –∑–∞–¥–∞–Ω–Ω—ã–µ –≤–∞–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è. –í –õ–∏—Å—Ç–∏–Ω–≥–µ 8-2 —Å–æ–∑–¥–∞—ë—Ç—Å—è –Ω–æ–≤—ã–π <code>Vec&lt;i32&gt;</code>, –∫–æ—Ç–æ—Ä—ã–π –±—É–¥–µ—Ç —Ö—Ä–∞–Ω–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è <code>1</code>, <code>2</code> –∏ <code>3</code>. –ß–∏—Å–ª–æ–≤—ã–º —Ç–∏–ø–æ–º —è–≤–ª—è–µ—Ç—Å—è <code>i32</code>, –ø–æ—Ç–æ–º—É —á—Ç–æ —ç—Ç–æ —Ç–∏–ø –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –¥–ª—è —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π, –æ —á—ë–º —É–ø–æ–º–∏–Ω–∞–ª–æ—Å—å –≤ —Ä–∞–∑–¥–µ–ª–µ <a href="ch03-02-data-types.html#%D0%A2%D0%B8%D0%BF%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85">"–¢–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö"</a><!-- ignore --> –ì–ª–∞–≤—ã 3.</p>
<Listing number="8-2" caption="Creating a new vector containing values">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>–ü–æ—Å–∫–æ–ª—å–∫—É –º—ã —É–∫–∞–∑–∞–ª–∏ –Ω–∞—á–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è —Ç–∏–ø–∞ <code>i32</code>, Rust –º–æ–∂–µ—Ç —Å–¥–µ–ª–∞—Ç—å –≤—ã–≤–æ–¥, —á—Ç–æ —Ç–∏–ø –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π <code>v</code> ‚Äî —ç—Ç–æ <code>Vec&lt;i32&gt;</code>, –∏ –∞–Ω–Ω–æ—Ç–∞—Ü–∏—è —Ç–∏–ø–∞ –∑–¥–µ—Å—å –Ω–µ –Ω—É–∂–Ω–∞. –î–∞–ª–µ–µ –º—ã –ø–æ—Å–º–æ—Ç—Ä–∏–º, –∫–∞–∫ –∏–∑–º–µ–Ω—è—Ç—å –≤–µ–∫—Ç–æ—Ä.</p>
<h3 id="–ò–∑–º–µ–Ω–µ–Ω–∏–µ-—Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ-–≤–µ–∫—Ç–æ—Ä–∞"><a class="header" href="#–ò–∑–º–µ–Ω–µ–Ω–∏–µ-—Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ-–≤–µ–∫—Ç–æ—Ä–∞">–ò–∑–º–µ–Ω–µ–Ω–∏–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞</a></h3>
<p>–ß—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å –≤–µ–∫—Ç–æ—Ä –∏ –∑–∞—Ç–µ–º –¥–æ–±–∞–≤–∏—Ç—å –∫ –Ω–µ–º—É —ç–ª–µ–º–µ–Ω—Ç—ã, –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –º–µ—Ç–æ–¥ <code>push</code>, –∫–∞–∫ –ø–æ–∫–∞–∑–∞–Ω–æ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 8-3.</p>
<Listing number="8-3" caption="Using the `push` method to add values to a vector">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut v = Vec::new();

    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>–ö–∞–∫ –∏ —Å –ª—é–±–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π, –µ—Å–ª–∏ –º—ã —Ö–æ—Ç–∏–º –∏–∑–º–µ–Ω–∏—Ç—å –µ—ë –∑–Ω–∞—á–µ–Ω–∏–µ, –Ω–∞–º –Ω—É–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å –µ—ë –∏–∑–º–µ–Ω—è–µ–º–æ–π —Å –ø–æ–º–æ—â—å—é –∫–ª—é—á–µ–≤–æ–≥–æ —Å–ª–æ–≤–∞ <code>mut</code>, —á—Ç–æ –æ–±—Å—É–∂–¥–∞–ª–æ—Å—å –≤ –ì–ª–∞–≤–µ 3. –í—Å–µ —á–∏—Å–ª–∞, –∫–æ—Ç–æ—Ä—ã–µ –º—ã –ø–æ–º–µ—â–∞–µ–º –≤ –≤–µ–∫—Ç–æ—Ä, –∏–º–µ—é—Ç —Ç–∏–ø <code>i32</code>, –∞ –ø–æ—Ç–æ–º—É Rust —Å –ª—ë–≥–∫–æ—Å—Ç—å—é –≤—ã–≤–æ–¥–∏—Ç —Ç–∏–ø –≤–µ–∫—Ç–æ—Ä–∞ –∏ –Ω–µ –æ–±—è–∑—ã–≤–∞–µ—Ç –Ω–∞—Å –∑–¥–µ—Å—å —É–∫–∞–∑—ã–≤–∞—Ç—å –∞–Ω–Ω–æ—Ç–∞—Ü–∏—é <code>Vec&lt;i32&gt;</code>.</p>
<h3 id="–ß—Ç–µ–Ω–∏–µ-–¥–∞–Ω–Ω—ã—Ö-–≤–µ–∫—Ç–æ—Ä–∞"><a class="header" href="#–ß—Ç–µ–Ω–∏–µ-–¥–∞–Ω–Ω—ã—Ö-–≤–µ–∫—Ç–æ—Ä–∞">–ß—Ç–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –≤–µ–∫—Ç–æ—Ä–∞</a></h3>
<p>–ï—Å—Ç—å –¥–≤–∞ —Å–ø–æ—Å–æ–±–∞ —Å–æ—Å–ª–∞—Ç—å—Å—è –Ω–∞ –∑–Ω–∞—á–µ–Ω–∏–µ, —Ö—Ä–∞–Ω—è—â–µ–µ—Å—è –≤ –≤–µ–∫—Ç–æ—Ä–µ: —Å –ø–æ–º–æ—â—å—é –∏–Ω–¥–µ–∫—Å–∞ –∏–ª–∏ –º–µ—Ç–æ–¥–∞ <code>get</code>. –í —Å–ª–µ–¥—É—é—â–∏—Ö –ø—Ä–∏–º–µ—Ä–∞—Ö –¥–ª—è –±–æ–ª—å—à–µ–π —è—Å–Ω–æ—Å—Ç–∏ –º—ã —É–∫–∞–∑–∞–ª–∏ —Ç–∏–ø—ã –∑–Ω–∞—á–µ–Ω–∏–π, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—ã—Ö —ç—Ç–∏–º–∏ —Ñ—É–Ω–∫—Ü–∏—è–º–∏.</p>
<p>–í –õ–∏—Å—Ç–∏–Ω–≥–µ 8-4 –ø–æ–∫–∞–∑–∞–Ω—ã –æ–±–∞ –º–µ—Ç–æ–¥–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –∑–Ω–∞—á–µ–Ω–∏—é –≤ –≤–µ–∫—Ç–æ—Ä–µ: –∫–∞–∫ —Å –ø–æ–º–æ—â—å—é —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞ –∏–Ω–¥–µ–∫—Å–∞—Ü–∏–∏, —Ç–∞–∫ –∏ —Å –ø–æ–º–æ—â—å—é –º–µ—Ç–æ–¥–∞ <code>get</code>.</p>
<Listing number="8-4" caption="Using indexing syntax and using the `get` method to access an item in a vector">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3, 4, 5];

    let third: &amp;i32 = &amp;v[2];
    println!("–¢—Ä–µ—Ç–∏–π —ç–ª–µ–º–µ–Ω—Ç: {third}");

    let third: Option&lt;&amp;i32&gt; = v.get(2);
    match third {
        Some(third) =&gt; println!("–¢—Ä–µ—Ç–∏–π —ç–ª–µ–º–µ–Ω—Ç: {third}"),
        None =&gt; println!("–¢—Ä–µ—Ç—å–µ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç—Å—è."),
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>–û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ –Ω–∞ –ø–∞—Ä—É –¥–µ—Ç–∞–ª–µ–π. –ú—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ –∏–Ω–¥–µ–∫—Å–∞ <code>2</code> –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ç—Ä–µ—Ç—å–µ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞, —Ç–∞–∫ –∫–∞–∫ –≤–µ–∫—Ç–æ—Ä—ã –∏–Ω–¥–µ–∫—Å–∏—Ä—É—é—Ç—Å—è —Å –Ω—É–ª—è. –£–∫–∞–∑—ã–≤–∞—è <code>&amp;</code>–∏ <code>[]</code>, –º—ã –ø–æ–ª—É—á–∞–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ —ç–ª–µ–º–µ–Ω—Ç –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –∏–Ω–¥–µ–∫—Å—É. –ö–æ–≥–¥–∞ –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º –º–µ—Ç–æ–¥ <code>get</code>, –º—ã –ø–æ–ª—É—á–∞–µ–º —Ç–∏–ø <code>Option&lt;&amp;T&gt;</code>, –∫–æ—Ç–æ—Ä—ã–π –º—ã –º–æ–∂–µ–º –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –≤ <code>match</code>.</p>
<p>Rust –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç —ç—Ç–∏ –¥–≤–∞ —Å–ø–æ—Å–æ–±–∞ —Å—Å—ã–ª–∫–∏ –Ω–∞ —ç–ª–µ–º–µ–Ω—Ç, —á—Ç–æ–±—ã –≤—ã –º–æ–≥–ª–∏ –≤—ã–±–∏—Ä–∞—Ç—å –ø–æ–≤–µ–¥–µ–Ω–∏–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –∏–Ω–¥–µ–∫—Å–∞ –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ –¥–∏–∞–ø–∞–∑–æ–Ω–∞ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤. –í –∫–∞—á–µ—Å—Ç–≤–µ –ø—Ä–∏–º–µ—Ä–∞, –¥–∞–≤–∞–π—Ç–µ –ø–æ—Å–º–æ—Ç—Ä–∏–º, –∫–∞–∫ –ø–æ–≤–µ–¥—É—Ç —Å–µ–±—è –æ–±–∞ —Å–ø–æ—Å–æ–±–∞, –µ—Å–ª–∏ –º—ã –±—É–¥–µ–º –ø—ã—Ç–∞—Ç—å—Å—è –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ —ç–ª–µ–º–µ–Ω—Ç—É —Å –∏–Ω–¥–µ–∫—Å–æ–º 100 –∏–∑ –≤–µ–∫—Ç–æ—Ä–∞ –∏–∑ –ø—è—Ç–∏ —ç–ª–µ–º–µ–Ω—Ç–æ–≤:</p>
<Listing number="8-5" caption="Attempting to access the element at index 100 in a vector containing five elements">
<pre><pre class="playground"><code class="language-rust should_panic panics edition2021"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3, 4, 5];

    let does_not_exist = &amp;v[100];
    let does_not_exist = v.get(100);
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>–ï—Å–ª–∏ –º—ã –∑–∞–ø—É—Å—Ç–∏–º —ç—Ç–æ—Ç –∫–æ–¥, –ø–µ—Ä–≤–∞—è —Å—Ç—Ä–æ–∫–∞ (—Å –æ–±—Ä–∞—â–µ–Ω–∏–µ–º —á–µ—Ä–µ–∑ <code>[]</code>) –≤—ã–∑–æ–≤–µ—Ç –ø–∞–Ω–∏–∫—É –ø—Ä–æ–≥—Ä–∞–º–º—ã, –ø–æ—Ç–æ–º—É —á—Ç–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –ø–æ–ø—ã—Ç–∫–∞ –ø–æ–ª—É—á–∏—Ç—å —Å—Å—ã–ª–∫—É –Ω–∞ –Ω–µ—Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π —ç–ª–µ–º–µ–Ω—Ç. –¢–∞–∫–æ–π –ø–æ–¥—Ö–æ–¥ –ª—É—á—à–µ –≤—Å–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å, –∫–æ–≥–¥–∞ –≤—ã —Ö–æ—Ç–∏—Ç–µ, —á—Ç–æ–±—ã –≤–∞—à–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∞ –∞–≤–∞—Ä–∏–π–Ω–æ –∑–∞–≤–µ—Ä—à–∏–ª–∞ —Ä–∞–±–æ—Ç—É –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ –¥–æ—Å—Ç—É–ø–∞ –∫ —ç–ª–µ–º–µ–Ω—Ç—É –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ –≤–µ–∫—Ç–æ—Ä–∞.</p>
<p>–ö–æ–≥–¥–∞ –º–µ—Ç–æ–¥—É <code>get</code> –ø–µ—Ä–µ–¥–∞—ë—Ç—Å—è –∏–Ω–¥–µ–∫—Å, –∫–æ—Ç–æ—Ä—ã–π –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ –≤–µ–∫—Ç–æ—Ä–∞, –æ–Ω –±–µ–∑ –ø–∞–Ω–∏–∫–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç <code>None</code>. –¢–∞–∫–æ–π –ø–æ–¥—Ö–æ–¥ –ø—Ä–∏–≥–æ–¥–∏—Ç—Å—è –≤ —Ç–æ–º —Å–ª—É—á–∞–µ, –µ—Å–ª–∏ —Å—á–∏—Ç–∞–µ—Ç—Å—è –Ω–æ—Ä–º–∞–ª—å–Ω—ã–º, —á—Ç–æ –≤—Ä–µ–º—è –æ—Ç –≤—Ä–µ–º–µ–Ω–∏ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –ø–æ–ø—ã—Ç–∫–∞ –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ —ç–ª–µ–º–µ–Ω—Ç—É –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ –¥–∏–∞–ø–∞–∑–æ–Ω–∞ –≤–µ–∫—Ç–æ—Ä–∞. –¢–æ–≥–¥–∞ –≤–∞—à –∫–æ–¥ –¥–æ–ª–∂–µ–Ω –±—É–¥–µ—Ç –∏–º–µ—Ç—å –ª–æ–≥–∏–∫—É –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –Ω–∞–ª–∏—á–∏—è <code>Some(&amp;element)</code> –∏–ª–∏ <code>None</code>, –∫–∞–∫ –æ–±—Å—É–∂–¥–∞–ª–æ—Å—å –≤ –ì–ª–∞–≤–µ 6. –ù–∞–ø—Ä–∏–º–µ—Ä, –∏–Ω–¥–µ–∫—Å –º–æ–∂–µ—Ç –∏—Å—Ö–æ–¥–∏—Ç—å –æ—Ç —á–µ–ª–æ–≤–µ–∫–∞, –≤–≤–æ–¥—è—â–µ–≥–æ —á–∏—Å–ª–æ. –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å–ª—É—á–∞–π–Ω–æ –≤–≤–µ–¥—ë—Ç —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–µ —á–∏—Å–ª–æ, —Ç–æ –ø—Ä–æ–≥—Ä–∞–º–º–∞ –ø–æ–ª—É—á–∏—Ç –∑–Ω–∞—á–µ–Ω–∏–µ <code>None</code> –∏ —É –≤–∞—Å –±—É–¥–µ—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å —Å–æ–æ–±—â–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é, —Å–∫–æ–ª—å–∫–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ —Ç–µ–∫—É—â–µ–º –≤–µ–∫—Ç–æ—Ä–µ, –∏ –¥–∞—Ç—å –µ–º—É –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –≤–≤–µ—Å—Ç–∏ –¥–æ–ø—É—Å—Ç–∏–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ. –¢–∞–∫–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ –±—ã–ª–æ –±—ã –±–æ–ª–µ–µ –¥—Ä—É–∂–µ–ª—é–±–Ω—ã–º, —á–µ–º –≤–Ω–µ–∑–∞–ø–Ω—ã–π —Å–±–æ–π –ø—Ä–æ–≥—Ä–∞–º–º—ã –∏–∑-–∑–∞ –æ–ø–µ—á–∞—Ç–∫–∏!</p>
<p>–ï—Å–ª–∏ —É –ø—Ä–æ–≥—Ä–∞–º–º—ã –µ—Å—Ç—å –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞—è —Å—Å—ã–ª–∫–∞, –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–π –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç —Å–æ–±–ª—é–¥–µ–Ω–∏–µ –ø—Ä–∞–≤–∏–ª –≤–ª–∞–¥–µ–Ω–∏—è –∏ –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏—è (–æ–ø–∏—Å–∞–Ω–Ω—ã–µ –≤ –ì–ª–∞–≤–µ 4), —á—Ç–æ–±—ã –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å, —á—Ç–æ —ç—Ç–∞ —Å—Å—ã–ª–∫–∞ –∏ –ª—é–±—ã–µ –¥—Ä—É–≥–∏–µ —Å—Å—ã–ª–∫–∏ –Ω–∞ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –≤–µ–∫—Ç–æ—Ä–∞ –æ—Å—Ç–∞—é—Ç—Å—è –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–º–∏. –í—Å–ø–æ–º–Ω–∏—Ç–µ –ø—Ä–∞–≤–∏–ª–æ, –∫–æ—Ç–æ—Ä–æ–µ –≥–ª–∞—Å–∏—Ç, —á—Ç–æ —É –≤–∞—Å –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –∏–∑–º–µ–Ω—è–µ–º—ã—Ö –∏ –Ω–µ–∏–∑–º–µ–Ω—è–µ–º—ã—Ö —Å—Å—ã–ª–æ–∫ –≤ –æ–¥–Ω–æ–π –∏ —Ç–æ–π –∂–µ –æ–±–ª–∞—Å—Ç–∏. –ò–º–µ–Ω–Ω–æ –µ–≥–æ –Ω–∞—Ä—É—à–∞–µ—Ç –∫–æ–¥ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 8-6, –≥–¥–µ –º—ã –ø—ã—Ç–∞–µ–º—Å—è —Ö—Ä–∞–Ω–∏—Ç—å –Ω–µ–∏–∑–º–µ–Ω—è–µ–º—É—é —Å—Å—ã–ª–∫—É –Ω–∞ –ø–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç –≤–µ–∫—Ç–æ—Ä–∞ –∏ –∑–∞—Ç–µ–º –ø—ã—Ç–∞–µ–º—Å—è –¥–æ–±–∞–≤–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç –≤ –∫–æ–Ω–µ—Ü –≤–µ–∫—Ç–æ—Ä–∞. –≠—Ç–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∞ –Ω–µ –±—É–¥–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å, –µ—Å–ª–∏ –º—ã —Ç–∞–∫–∂–µ –ø–æ–ø—ã—Ç–∞–µ–º—Å—è –æ–±—Ä–∞—Ç–∏—Ç—å—Å—è –∫ —ç—Ç–æ–º—É —ç–ª–µ–º–µ–Ω—Ç—É –ø–æ–∑–∂–µ –≤ —Ñ—É–Ω–∫—Ü–∏–∏.</p>
<Listing number="8-6" caption="Attempting to add an element to a vector while holding a reference to an item">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5];

    let first = &amp;v[0];

    v.push(6);

    println!("–ü–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç: {first}");
<span class="boring">}</span></code></pre>
</Listing>
<p>–ö–æ–º–ø–∏–ª—è—Ü–∏—è —ç—Ç–æ–≥–æ –∫–æ–¥–∞ –ø—Ä–∏–≤–µ–¥—ë—Ç –∫ –æ—à–∏–±–∫–µ:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:5
  |
4 |     let first = &amp;v[0];
  |                  - immutable borrow occurs here
5 |
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 |
8 |     println!("–ü–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç: {first}");
  |                                     ------- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `collections` (bin "collections") due to 1 previous error
</code></pre>
<p>–ö–æ–¥ –≤ –ª–∏—Å—Ç–∏–Ω–≥–µ 8-6 –º–æ–∂–µ—Ç –≤—ã–≥–ª—è–¥–µ—Ç—å —Ç–∞–∫, –∫–∞–∫ –±—É–¥—Ç–æ –æ–Ω –¥–æ–ª–∂–µ–Ω —Ä–∞–±–æ—Ç–∞—Ç—å: –≤ –∫–æ–Ω—Ü–µ –∫–æ–Ω—Ü–æ–≤, –∫–∞–∫ —Å—Å—ã–ª–∫–µ –Ω–∞ –ø–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç –º–æ–≥—É—Ç –ø–æ–º–µ—à–∞—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ –∫–æ–Ω—Ü–µ –≤–µ–∫—Ç–æ—Ä–∞? –≠—Ç–∞ –æ—à–∏–±–∫–∞ –≤–æ–∑–Ω–∏–∫–∞–µ—Ç –∏–∑-–∑–∞ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏ —Ç–æ–≥–æ, –∫–∞–∫ –≤–µ–∫—Ç–æ—Ä—ã —Ä–∞–±–æ—Ç–∞—é—Ç: –ø–æ—Å–∫–æ–ª—å–∫—É –≤–µ–∫—Ç–æ—Ä—ã —Ä–∞–∑–º–µ—â–∞—é—Ç –∑–Ω–∞—á–µ–Ω–∏—è –≤ –ø–∞–º—è—Ç–∏ –¥—Ä—É–≥ –∑–∞ –¥—Ä—É–≥–æ–º, –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –≤ –∫–æ–Ω–µ—Ü –≤–µ–∫—Ç–æ—Ä–∞ –º–æ–∂–µ—Ç –ø–æ—Ç—Ä–µ–±–æ–≤–∞—Ç—å –≤—ã–¥–µ–ª–µ–Ω–∏—è –Ω–æ–≤–æ–π –ø–∞–º—è—Ç–∏ –∏ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è —Å—Ç–∞—Ä—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤ –Ω–æ–≤–æ–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ, –µ—Å–ª–∏ –Ω–µ—Ç –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ–≥–æ –º–µ—Å—Ç–∞, —á—Ç–æ–±—ã —Ä–∞–∑–º–µ—Å—Ç–∏—Ç—å –≤—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –¥—Ä—É–≥ –∑–∞ –¥—Ä—É–≥–æ–º —Ç–∞–º, –≥–¥–µ –≤ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç —Ö—Ä–∞–Ω–∏—Ç—Å—è –≤–µ–∫—Ç–æ—Ä. –í —ç—Ç–æ–º —Å–ª—É—á–∞–µ —Å—Å—ã–ª–∫–∞ –Ω–∞ –ø–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç –æ–∫–∞–∂–µ—Ç—Å—è —É–∫–∞–∑—ã–≤–∞—é—â–µ–π –Ω–∞ –≤—ã—Å–≤–æ–±–æ–∂–¥—ë–Ω–Ω—É—é –ø–∞–º—è—Ç—å. –ü—Ä–∞–≤–∏–ª–∞ –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞—é—Ç –ø–æ–ø–∞–¥–∞–Ω–∏–µ –ø—Ä–æ–≥—Ä–∞–º–º –≤ —Ç–∞–∫—É—é —Å–∏—Ç—É–∞—Ü–∏—é.</p>
<blockquote>
<p>–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Å–≤–µ–¥–µ–Ω–∏—è –æ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ —Ç–∏–ø–∞ <code>Vec&lt;T&gt;</code> –º–æ–∂–Ω–æ –Ω–∞–π—Ç–∏ –≤ –ø–æ—Å–æ–±–∏–∏ <a href="https://rust-lang-translations.org/nomicon/vec/vec.html">"The Rustonomicon"</a>.</p>
</blockquote>
<h3 id="–ò—Ç–µ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ-–ø–æ-—Å–æ–¥–µ—Ä–∂–∏–º–æ–º—É-–≤–µ–∫—Ç–æ—Ä–∞"><a class="header" href="#–ò—Ç–µ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ-–ø–æ-—Å–æ–¥–µ—Ä–∂–∏–º–æ–º—É-–≤–µ–∫—Ç–æ—Ä–∞">–ò—Ç–µ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ —Å–æ–¥–µ—Ä–∂–∏–º–æ–º—É –≤–µ–∫—Ç–æ—Ä–∞</a></h3>
<p>–ß—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –∫–∞–∂–¥–æ–º—É –∑–Ω–∞—á–µ–Ω–∏—é –≤ –≤–µ–∫—Ç–æ—Ä–µ, –º—ã –º–æ–∂–µ–º –ø—Ä–æ–∏—Ç–µ—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è –ø–æ –≤—Å–µ–º —ç–ª–µ–º–µ–Ω—Ç–∞–º, –≤–º–µ—Å—Ç–æ —Ç–æ–≥–æ, —á—Ç–æ–±—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏–Ω–¥–µ–∫—Å—ã –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ –æ–¥–Ω–æ–º—É —ç–ª–µ–º–µ–Ω—Ç—É –∑–∞ —Ä–∞–∑. –í –õ–∏—Å—Ç–∏–Ω–≥–µ 8-7 –ø–æ–∫–∞–∑–∞–Ω–æ, –∫–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ü–∏–∫–ª <code>for</code> –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –Ω–µ–∏–∑–º–µ–Ω—è–µ–º—ã—Ö —Å—Å—ã–ª–æ–∫ –Ω–∞ –∫–∞–∂–¥—ã–π —ç–ª–µ–º–µ–Ω—Ç –≤ –≤–µ–∫—Ç–æ—Ä–µ –∑–Ω–∞—á–µ–Ω–∏–π —Ç–∏–ø–∞ <code>i32</code> –∏ –∏—Ö –≤—ã–≤–æ–¥–∞.</p>
<Listing number="8-7" caption="Printing each element in a vector by iterating over the elements using a `for` loop">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let v = vec![100, 32, 57];
    for i in &amp;v {
        println!("{i}");
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>–ú—ã —Ç–∞–∫–∂–µ –º–æ–∂–µ–º –∏—Ç–µ—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è –ø–æ –∏–∑–º–µ–Ω—è–µ–º—ã–º —Å—Å—ã–ª–∫–∞–º –Ω–∞ –∫–∞–∂–¥—ã–π —ç–ª–µ–º–µ–Ω—Ç –∏–∑–º–µ–Ω—è–µ–º–æ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞, —á—Ç–æ–±—ã –≤–Ω–µ—Å—Ç–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤–æ –≤—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã. –¶–∏–∫–ª <code>for</code> –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 8-8 –¥–æ–±–∞–≤–∏—Ç <code>50</code> –∫ –∫–∞–∂–¥–æ–º—É —ç–ª–µ–º–µ–Ω—Ç—É.</p>
<Listing number="8-8" caption="Iterating over mutable references to elements in a vector">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut v = vec![100, 32, 57];
    for i in &amp;mut v {
        *i += 50;
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>–ß—Ç–æ–±—ã –∏–∑–º–µ–Ω–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ, –Ω–∞ –∫–æ—Ç–æ—Ä–æ–µ —Å—Å—ã–ª–∞–µ—Ç—Å—è –∏–∑–º–µ–Ω—è–µ–º–∞—è —Å—Å—ã–ª–∫–∞, –º—ã –¥–æ–ª–∂–Ω—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –æ–ø–µ—Ä–∞—Ç–æ—Ä —Ä–∞–∑—ã–º–µ–Ω–æ–≤–∞–Ω–∏—è —Å—Å—ã–ª–∫–∏ <code>*</code> –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ —Å—Å—ã–ª–∫–µ –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π <code>i</code>, –ø—Ä–µ–∂–¥–µ —á–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –æ–ø–µ—Ä–∞—Ç–æ—Ä <code>+=</code>. –ú—ã –ø–æ–≥–æ–≤–æ—Ä–∏–º –ø–æ–¥—Ä–æ–±–Ω–µ–µ –æ–± –æ–ø–µ—Ä–∞—Ç–æ—Ä–µ —Ä–∞–∑—ã–º–µ–Ω–æ–≤–∞–Ω–∏—è –≤ —Ä–∞–∑–¥–µ–ª–µ <a href="ch15-02-deref.html#%D0%9F%D0%BE%D0%BB%D1%83%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BF%D0%BE-%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D1%8E">"–ü–æ–ª—É—á–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–∫–∞–∑–∞—Ç–µ–ª—é"</a><!-- ignore --> –ì–ª–∞–≤—ã 15.</p>
<p>–ò—Ç–µ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ –≤–µ–∫—Ç–æ—Ä—É, –±—É–¥—å —Ç–æ –Ω–µ–∏–∑–º–µ–Ω—è–µ–º–æ–º—É –∏–ª–∏ –∏–∑–º–µ–Ω—è–µ–º–æ–º—É, –±–µ–∑–æ–ø–∞—Å–Ω–æ –∏–∑-–∑–∞ –ø—Ä–∞–≤–∏–ª –ø—Ä–æ–≤–µ—Ä–∫–∏ –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–π. –ï—Å–ª–∏ –±—ã –º—ã –ø–æ–ø—ã—Ç–∞–ª–∏—Å—å –≤—Å—Ç–∞–≤–∏—Ç—å –∏–ª–∏ —É–¥–∞–ª–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç—ã (–≤/–∏–∑ –≤–µ–∫—Ç–æ—Ä–∞) –≤ —Ç–µ–ª–∞—Ö —Ü–∏–∫–ª–∞ <code>for</code> –≤ –õ–∏—Å—Ç–∏–Ω–≥–∞—Ö 8-7 –∏ 8-8, –º—ã –±—ã –ø–æ–ª—É—á–∏–ª–∏ –æ—à–∏–±–∫—É –∫–æ–º–ø–∏–ª—è—Ü–∏–∏, –ø–æ–¥–æ–±–Ω—É—é —Ç–æ–π, –∫–æ—Ç–æ—Ä—É—é –º—ã –ø–æ–ª—É—á–∏–ª–∏ —Å –∫–æ–¥–æ–º –õ–∏—Å—Ç–∏–Ω–≥–∞ 8-6. –°—Å—ã–ª–∫–∞ –Ω–∞ –≤–µ–∫—Ç–æ—Ä, –ø–µ—Ä–µ–±–∏—Ä–∞–µ–º—ã–π —Ü–∏–∫–ª–æ–º <code>for</code>, –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω—É—é –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏—é –≤—Å–µ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞.</p>
<h3 id="–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ-–ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π-–¥–ª—è-—Ö—Ä–∞–Ω–µ–Ω–∏—è-–º–Ω–æ–∂–µ—Å—Ç–≤–∞-—Ä–∞–∑–Ω—ã—Ö-—Ç–∏–ø–æ–≤"><a class="header" href="#–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ-–ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π-–¥–ª—è-—Ö—Ä–∞–Ω–µ–Ω–∏—è-–º–Ω–æ–∂–µ—Å—Ç–≤–∞-—Ä–∞–∑–Ω—ã—Ö-—Ç–∏–ø–æ–≤">–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –º–Ω–æ–∂–µ—Å—Ç–≤–∞ —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤</a></h3>
<p>–í–µ–∫—Ç–æ—Ä—ã –º–æ–≥—É—Ç —Ö—Ä–∞–Ω–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω–∞–∫–æ–≤–æ–≥–æ —Ç–∏–ø–∞. –≠—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–µ—É–¥–æ–±–Ω–æ; –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ –º–æ–≥—É—Ç –±—ã—Ç—å —Å–∏—Ç—É–∞—Ü–∏–∏, –∫–æ–≥–¥–∞ –Ω–∞–¥–æ —Ö—Ä–∞–Ω–∏—Ç—å —Å–ø–∏—Å–æ–∫ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤. –ö —Å—á–∞—Å—Ç—å—é, –≤–∞—Ä–∏–∞–Ω—Ç—ã –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∞—Ç –∫ –æ–¥–Ω—É –∏ —Ç–æ–º—É –∂–µ —Ç–∏–ø—É –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è, –ø–æ—ç—Ç–æ–º—É, –µ—Å–ª–∏ –Ω–∞–º –Ω—É–∂–µ–Ω –æ–¥–∏–Ω —Ç–∏–ø –¥–ª—è –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤, –º—ã –¥–ª—è —ç—Ç–æ–≥–æ –º–æ–∂–µ–º –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ!</p>
<p>–ù–∞–ø—Ä–∏–º–µ—Ä, –º—ã —Ö–æ—Ç–∏–º –ø–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è –∏–∑ —Å—Ç—Ä–æ–∫–∏ –≤ —ç–ª–µ–∫—Ç—Ä–æ–Ω–Ω–æ–π —Ç–∞–±–ª–∏—Ü–µ, –≥–¥–µ –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ —Å—Ç–æ–ª–±—Ü—ã —Å—Ç—Ä–æ–∫–∏ —Å–æ–¥–µ—Ä–∂–∞—Ç —Ü–µ–ª—ã–µ —á–∏—Å–ª–∞, –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ ‚Äî —á–∏—Å–ª–∞ —Å –ø–ª–∞–≤–∞—é—â–µ–π —Ç–æ—á–∫–æ–π, –∞ –¥—Ä—É–≥–∏–µ ‚Äî —Å—Ç—Ä–æ–∫–∏ —Ç–µ–∫—Å—Ç–∞. –ú–æ–∂–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ, –≤–∞—Ä–∏–∞–Ω—Ç—ã –∫–æ—Ç–æ—Ä–æ–≥–æ –±—É–¥—É—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ä–∞–∑–Ω—ã–µ —Ç–∏–ø—ã –∑–Ω–∞—á–µ–Ω–∏–π, –∏ —Ç–æ–≥–¥–∞ –≤—Å–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –±—É–¥—É—Ç —Å—á–∏—Ç–∞—Ç—å—Å—è –æ–¥–Ω–∏–º –∏ —Ç–µ–º –∂–µ —Ç–∏–ø–æ–º ‚Äî —Ç–∏–ø–æ–º —Å–∞–º–æ–≥–æ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è. –ó–∞—Ç–µ–º –º—ã –º–æ–∂–µ–º —Å–æ–∑–¥–∞—Ç—å –≤–µ–∫—Ç–æ—Ä –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –∑–Ω–∞—á–µ–Ω–∏–π —ç—Ç–æ–≥–æ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –∏, –ø–æ —Å—É—Ç–∏, –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Ç–∏–ø–æ–≤. –û–ø–∏—Å–∞–Ω–Ω–æ–µ –ø–æ–∫–∞–∑–∞–Ω–æ –õ–∏—Å—Ç–∏–Ω–≥–µ 8-9.</p>
<Listing number="8-9" caption="Defining an `enum` to store values of different types in one vector">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from("—Å–∏–Ω–∏–π")),
        SpreadsheetCell::Float(10.12),
    ];
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>Rust –¥–æ–ª–∂–µ–Ω –∑–Ω–∞—Ç—å –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏, –∫–∞–∫–∏–µ —Ç–∏–ø—ã –±—É–¥—É—Ç –≤ –≤–µ–∫—Ç–æ—Ä–µ, —á—Ç–æ–±—ã —Ç–æ—á–Ω–æ –∑–Ω–∞—Ç—å —Å–∫–æ–ª—å–∫–æ, –ø–∞–º—è—Ç–∏ –≤ –∫—É—á–µ –ø–æ—Ç—Ä–µ–±—É–µ—Ç—Å—è –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∫–∞–∂–¥–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞. –ú—ã —Ç–∞–∫–∂–µ –¥–æ–ª–∂–Ω—ã —á—ë—Ç–∫–æ —É–∫–∞–∑–∞—Ç—å, –∫–∞–∫–∏–µ —Ç–∏–ø—ã —Ä–∞–∑—Ä–µ—à–µ–Ω—ã –≤ —ç—Ç–æ–º –≤–µ–∫—Ç–æ—Ä–µ. –ï—Å–ª–∏ –±—ã Rust –ø–æ–∑–≤–æ–ª—è–ª –≤–µ–∫—Ç–æ—Ä—É —Å–æ–¥–µ—Ä–∂–∞—Ç—å –ª—é–±–æ–π —Ç–∏–ø, —Ç–æ –±—ã–ª –±—ã —à–∞–Ω—Å, —á—Ç–æ –æ–¥–∏–Ω –∏–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ç–∏–ø–æ–≤ –≤—ã–∑–æ–≤—É—Ç –æ—à–∏–±–∫–∏ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –æ–ø–µ—Ä–∞—Ü–∏–π –Ω–∞–¥ —ç–ª–µ–º–µ–Ω—Ç–∞–º–∏ –≤–µ–∫—Ç–æ—Ä–∞. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –≤–º–µ—Å—Ç–µ —Å –≤—ã—Ä–∞–∂–µ–Ω–∏–µ–º <code>match</code> –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ Rust –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç, —á—Ç–æ –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ —Å–ª—É—á–∞–∏ –±—É–¥—É—Ç –æ–±—Ä–∞–±–æ—Ç–∞–Ω—ã, –∫–∞–∫ –æ–±—Å—É–∂–¥–∞–ª–æ—Å—å –≤ –ì–ª–∞–≤–µ 6.</p>
<p>–ï—Å–ª–∏ –≤—ã –Ω–µ –º–æ–∂–µ—Ç–µ —É–∫–∞–∑–∞—Ç—å –∏—Å—á–µ—Ä–ø—ã–≤–∞—é—â–∏–π –Ω–∞–±–æ—Ä —Ç–∏–ø–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –ø—Ä–æ–≥—Ä–∞–º–º–µ –Ω—É–∂–Ω–æ –±—É–¥–µ—Ç —Ö—Ä–∞–Ω–∏—Ç—å –≤ –≤–µ–∫—Ç–æ—Ä–µ, —Ç–æ —Ç–µ—Ö–Ω–∏–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–µ—Ç. –í–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ –≤—ã –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç—Ä–µ–π—Ç-–æ–±—ä–µ–∫—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –º—ã —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º –≤ –≥–ª–∞–≤–µ 17.</p>
<p>–¢–µ–ø–µ—Ä—å, –∫–æ–≥–¥–∞ –º—ã –æ–±—Å—É–¥–∏–ª–∏ –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –∏–∑ –Ω–∞–∏–±–æ–ª–µ–µ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—ë–Ω–Ω—ã—Ö —Å–ø–æ—Å–æ–±–æ–≤ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤–µ–∫—Ç–æ—Ä–æ–≤, –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –æ–∑–Ω–∞–∫–æ–º—å—Ç–µ—Å—å —Å <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">–¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–µ–π API</a><!-- ignore -->, —á—Ç–æ–±—ã —É–∑–Ω–∞—Ç—å –æ –º–Ω–æ–∂–µ—Å—Ç–≤–µ –ø–æ–ª–µ–∑–Ω—ã—Ö –º–µ—Ç–æ–¥–æ–≤, –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã—Ö –¥–ª—è <code>Vec&lt;T&gt;</code> —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–æ–π. –ù–∞–ø—Ä–∏–º–µ—Ä, –≤ –¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –∫ –º–µ—Ç–æ–¥—É <code>push</code>, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –º–µ—Ç–æ–¥ <code>pop</code>, –∫–æ—Ç–æ—Ä—ã–π —É–¥–∞–ª—è–µ—Ç –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–æ—Å–ª–µ–¥–Ω–∏–π —ç–ª–µ–º–µ–Ω—Ç.</p>
<h3 id="–í—ã—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏–µ-–≤–µ–∫—Ç–æ—Ä–∞-–≤—ã—Å–≤–æ–±–æ–∂–¥–∞–µ—Ç-–µ–≥–æ-—ç–ª–µ–º–µ–Ω—Ç—ã"><a class="header" href="#–í—ã—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏–µ-–≤–µ–∫—Ç–æ—Ä–∞-–≤—ã—Å–≤–æ–±–æ–∂–¥–∞–µ—Ç-–µ–≥–æ-—ç–ª–µ–º–µ–Ω—Ç—ã">–í—ã—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏–µ –≤–µ–∫—Ç–æ—Ä–∞ –≤—ã—Å–≤–æ–±–æ–∂–¥–∞–µ—Ç –µ–≥–æ —ç–ª–µ–º–µ–Ω—Ç—ã</a></h3>
<p>–ü–æ–¥–æ–±–Ω–æ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞–º, –≤–µ–∫—Ç–æ—Ä –≤—ã—Å–≤–æ–±–æ–∂–¥–∞–µ—Ç —Å–≤–æ—é –ø–∞–º—è—Ç—å, –∫–æ–≥–¥–∞ –≤—ã—Ö–æ–¥–∏—Ç –∏–∑ –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏, –∫–∞–∫ –ø–æ–∫–∞–∑–∞–Ω–æ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 8-10.</p>
<Listing number="8-10" caption="Showing where the vector and its elements are dropped">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    {
        let v = vec![1, 2, 3, 4];

        // –∫–∞–∫–∞—è-–Ω–∏–±—É–¥—å —Ä–∞–±–æ—Ç–∞ —Å v
    } // &lt;- –∑–¥–µ—Å—å v –ø–æ–∫–∏–¥–∞–µ—Ç –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∏ –≤—ã—Å–≤–æ–±–æ–∂–¥–∞–µ—Ç—Å—è
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>–ö–æ–≥–¥–∞ –≤–µ–∫—Ç–æ—Ä –≤—ã—Å–≤–æ–±–æ–∂–¥–∞–µ—Ç—Å—è, –≤—Å—ë –µ–≥–æ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ç–∞–∫–∂–µ –≤—ã—Å–≤–æ–±–æ–∂–¥–∞–µ—Ç—Å—è, —Ç–æ –µ—Å—Ç—å –≤—Å–µ —á–∏—Å–ª–∞, —Ö—Ä–∞–Ω–∏–≤—à–∏–µ—Å—è –≤ –≤–µ–∫—Ç–æ—Ä–µ –∏–∑ –ø—Ä–∏–º–µ—Ä–∞ –≤—ã—à–µ, —É–¥–∞–ª—è—é—Ç—Å—è. –ê–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–π –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç, —á—Ç–æ –ª—é–±—ã–µ —Å—Å—ã–ª–∫–∏ –Ω–∞ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –≤–µ–∫—Ç–æ—Ä–∞ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è —Ç–æ–ª—å–∫–æ —Ç–æ–≥–¥–∞, –∫–æ–≥–¥–∞ —Å–∞–º –≤–µ–∫—Ç–æ—Ä –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω.</p>
<p>–ü–µ—Ä–µ–π–¥—ë–º –∫ —Å–ª–µ–¥—É—é—â–µ–π –∫–æ–ª–ª–µ–∫—Ü–∏–∏: <code>String</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–•—Ä–∞–Ω–µ–Ω–∏–µ-—Ç–µ–∫—Å—Ç–∞-–≤-–∫–æ–¥–∏—Ä–æ–≤–∫–µ-utf-8-—Å-–ø–æ–º–æ—â—å—é-—Å—Ç—Ä–æ–∫"><a class="header" href="#–•—Ä–∞–Ω–µ–Ω–∏–µ-—Ç–µ–∫—Å—Ç–∞-–≤-–∫–æ–¥–∏—Ä–æ–≤–∫–µ-utf-8-—Å-–ø–æ–º–æ—â—å—é-—Å—Ç—Ä–æ–∫">–•—Ä–∞–Ω–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ –≤ –∫–æ–¥–∏—Ä–æ–≤–∫–µ UTF-8 —Å –ø–æ–º–æ—â—å—é —Å—Ç—Ä–æ–∫</a></h2>
<p>–ú—ã —É–∂–µ –≥–æ–≤–æ—Ä–∏–ª–∏ –æ —Å—Ç—Ä–æ–∫–∞—Ö –≤ –ì–ª–∞–≤–µ 4, –Ω–æ –ø—Ä–∏—à–ª–æ –≤—Ä–µ–º—è —Ä–∞—Å—Å–º–æ—Ç—Ä–µ—Ç—å –∏—Ö –±–æ–ª–µ–µ –ø–æ–¥—Ä–æ–±–Ω–æ. –ù–æ–≤–∏—á–∫–∏ –≤ Rust –æ–±—ã—á–Ω–æ –∑–∞—Å—Ç—Ä–µ–≤–∞—é—Ç –Ω–∞ —Å—Ç—Ä–æ–∫–∞—Ö –∏–∑-–∑–∞ —Ç—Ä—ë—Ö –ø—Ä–∏—á–∏–Ω: 1) –ø—Ä–∏—Å—Ç—Ä–∞—Å—Ç–∏–µ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞ Rust –∫ –≤—ã—è–≤–ª–µ–Ω–∏—é –≤–æ–∑–º–æ–∂–Ω—ã—Ö –æ—à–∏–±–æ–∫, 2) —Å—Ç—Ä–æ–∫–∏ —Å–ª–æ–∂–Ω–µ–µ, —á–µ–º (–∫–∞–∫ –º–Ω–æ–≥–∏–º –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç–∞–º –∫–∞–∂–µ—Ç—Å—è) –º–æ–≥–ª–∏ –±—ã –±—ã—Ç—å, –∏ 3) UTF-8. –≠—Ç–∏ —Ñ–∞–∫—Ç–æ—Ä—ã –æ–±—ä–µ–¥–∏–Ω—è—é—Ç—Å—è —Ç–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, —á—Ç–æ —Ç–µ–∫—É—â–∞—è —Ç–µ–º–∞ –º–æ–∂–µ—Ç –ø–æ–∫–∞–∑–∞—Ç—å—Å—è —Å–ª–æ–∂–Ω–æ–π, –µ—Å–ª–∏ –≤—ã –ø—Ä–∏—à–ª–∏ –∏–∑ –¥—Ä—É–≥–∏—Ö —è–∑—ã–∫–æ–≤ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è.</p>
<p>–ú—ã –≥–æ–≤–æ—Ä–∏–º –æ —Å—Ç—Ä–æ–∫–∞—Ö –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ –∫–æ–ª–ª–µ–∫—Ü–∏–π, –ø–æ—Ç–æ–º—É —á—Ç–æ —Å—Ç—Ä–æ–∫–∏ –≤ Rust ‚Äî —ç—Ç–æ —Å–ø–∏—Å–æ–∫ –±–∞–π—Ç–æ–≤ –ø–ª—é—Å –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –º–µ—Ç–æ–¥—ã –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –Ω–∏–º–∏ –∫–∞–∫ —Å —Ç–µ–∫—Å—Ç–æ–º. –í —ç—Ç–æ–º —Ä–∞–∑–¥–µ–ª–µ –º—ã –ø–æ–≥–æ–≤–æ—Ä–∏–º –æ–± –æ–ø–µ—Ä–∞—Ü–∏—è—Ö –Ω–∞–¥ <code>String</code>, —Ç–∞–∫–∏–º–∏ –∫–∞–∫ —Å–æ–∑–¥–∞–Ω–∏–µ, –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏ —á—Ç–µ–Ω–∏–µ. –ú—ã —Ç–∞–∫–∂–µ –æ–±—Å—É–¥–∏–º, —á–µ–º <code>String</code> –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è –æ—Ç –¥—Ä—É–≥–∏—Ö –∫–æ–ª–ª–µ–∫—Ü–∏–π, –∞ –∏–º–µ–Ω–Ω–æ, –∫–∞–∫ –æ–±—Ä–∞—â–µ–Ω–∏–µ –∫ <code>String</code> –ø–æ –∏–Ω–¥–µ–∫—Å—É –æ—Å–ª–æ–∂–Ω—è–µ—Ç—Å—è —Ä–∞–∑–ª–∏—á–∏—è–º–∏ –º–µ–∂–¥—É —Ç–µ–º, –∫–∞–∫ –ª—é–¥–∏ –∏ –∫–æ–º–ø—å—é—Ç–µ—Ä—ã –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∏—Ä—É—é—Ç –¥–∞–Ω–Ω—ã–µ –≤ <code>String</code>.</p>
<h3 id="–ß—Ç–æ-—Ç–∞–∫–æ–µ-—Å—Ç—Ä–æ–∫–∞"><a class="header" href="#–ß—Ç–æ-—Ç–∞–∫–æ–µ-—Å—Ç—Ä–æ–∫–∞">–ß—Ç–æ —Ç–∞–∫–æ–µ —Å—Ç—Ä–æ–∫–∞?</a></h3>
<p>–°–Ω–∞—á–∞–ª–∞ –º—ã –æ–ø—Ä–µ–¥–µ–ª–∏–º –∑–Ω–∞—á–µ–Ω–∏–µ —Ç–µ—Ä–º–∏–Ω–∞ <em>—Å—Ç—Ä–æ–∫–∞</em>. –í —è–¥—Ä–µ —è–∑—ã–∫–∞ Rust –µ—Å—Ç—å –ª–∏—à—å –æ–¥–∏–Ω —Å—Ç—Ä–æ–∫–æ–≤—ã–π —Ç–∏–ø ‚Äî —Å—Ä–µ–∑ —Å—Ç—Ä–æ–∫–∏ <code>str</code>, –æ–±—ã—á–Ω–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–π –≤ –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–Ω–æ–º –≤–∏–¥–µ –∫–∞–∫ <code>&amp;str</code>. –í –ì–ª–∞–≤–µ 4 –º—ã –≥–æ–≤–æ—Ä–∏–ª–∏ –æ <em>—Å—Ä–µ–∑–∞—Ö —Å—Ç—Ä–æ–∫</em>, –∫–æ—Ç–æ—Ä—ã–µ —è–≤–ª—è—é—Ç—Å—è —Å—Å—ã–ª–∫–∞–º–∏ –Ω–∞ –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ —Å—Ç—Ä–æ–∫–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –≤ –∫–æ–¥–∏—Ä–æ–≤–∫–µ UTF-8. –ù–∞–ø—Ä–∏–º–µ—Ä, —Å—Ç—Ä–æ–∫–æ–≤—ã–µ –ª–∏—Ç–µ—Ä–∞–ª—ã —Ö—Ä–∞–Ω—è—Ç—Å—è –≤ –¥–≤–æ–∏—á–Ω–æ–º —Ñ–∞–π–ª–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã –∏ –ø–æ—Ç–æ–º—É —è–≤–ª—è—é—Ç—Å—è —Å—Ä–µ–∑–∞–º–∏ —Å—Ç—Ä–æ–∫.</p>
<p>–¢–∏–ø <code>String</code>, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ–º—ã–π —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–æ–π Rust, –Ω–µ –≤—Å—Ç—Ä–æ–µ–Ω –≤ —è–¥—Ä–æ —è–∑—ã–∫–∞. –û–Ω —è–≤–ª—è–µ—Ç—Å—è —Ä–∞—Å—à–∏—Ä—è–µ–º—ã–º, –∏–∑–º–µ–Ω—è–µ–º—ã–º, –≤–ª–∞–¥–µ—é—â–∏–º —Å—Ç—Ä–æ–∫–æ–≤—ã–º —Ç–∏–ø–æ–º —Ç–µ–∫—Å—Ç–∞ –≤ –∫–æ–¥–∏—Ä–æ–≤–∫–µ UTF-8. –ö–æ–≥–¥–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç—ã –Ω–∞ Rust –≥–æ–≤–æ—Ä—è—Ç –æ "—Å—Ç—Ä–æ–∫–∞—Ö", —Ç–æ –æ–Ω–∏ –æ–±—ã—á–Ω–æ –∏–º–µ—é—Ç –≤ –≤–∏–¥—É –∫–∞–∫ —Ç–∏–ø <code>String</code>, —Ç–∞–∫ –∏ —Å—Ç—Ä–æ–∫–æ–≤—ã–µ —Å—Ä–µ–∑—ã <code>&amp;str</code>, –∞ –Ω–µ –∫–∞–∫–æ–π-–ª–∏–±–æ –æ–¥–∏–Ω –∏–∑ –Ω–∏—Ö. –•–æ—Ç—è —ç—Ç–æ—Ç —Ä–∞–∑–¥–µ–ª –≤ –æ—Å–Ω–æ–≤–Ω–æ–º –ø–æ—Å–≤—è—â—ë–Ω <code>String</code>, –æ–±–∞ —Ç–∏–ø–∞ –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –≤ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–µ Rust. –û–±–∞ ‚Äî –∏ <code>String</code>, –∏ —Å—Ç—Ä–æ–∫–æ–≤—ã–µ —Å—Ä–µ–∑—ã ‚Äî —Ä–∞–±–æ—Ç–∞—é—Ç –ø–æ –∫–æ–¥–∏—Ä–æ–≤–∫–µ UTF-8.</p>
<h3 id="–°–æ–∑–¥–∞–Ω–∏–µ-–Ω–æ–≤—ã—Ö-—Å—Ç—Ä–æ–∫"><a class="header" href="#–°–æ–∑–¥–∞–Ω–∏–µ-–Ω–æ–≤—ã—Ö-—Å—Ç—Ä–æ–∫">–°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤—ã—Ö —Å—Ç—Ä–æ–∫</a></h3>
<p>–ú–Ω–æ–≥–∏–µ –∏–∑ —Ç–µ—Ö –æ–ø–µ—Ä–∞—Ü–∏–π, –∫–æ—Ç–æ—Ä—ã–µ –¥–æ—Å—Ç—É–ø–Ω—ã <code>Vec&lt;T&gt;</code>, –¥–æ—Å—Ç—É–ø–Ω—ã —Ç–∞–∫–∂–µ –∏ –¥–ª—è <code>String</code>, –ø–æ—Ç–æ–º—É —á—Ç–æ <code>String</code> —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∏ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω –∫–∞–∫ –æ–±—ë—Ä—Ç–∫–∞ –≤–æ–∫—Ä—É–≥ –≤–µ–∫—Ç–æ—Ä–∞ –±–∞–π—Ç–æ–≤ —Å –Ω–µ–∫–æ—Ç–æ—Ä—ã–º–∏ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–º–∏ –≥–∞—Ä–∞–Ω—Ç–∏—è–º–∏, –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è–º–∏ –∏ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—è–º–∏. –ü—Ä–∏–º–µ—Ä–æ–º —Ñ—É–Ω–∫—Ü–∏–∏, —Ä–∞–±–æ—Ç–∞ –∫–æ—Ç–æ—Ä–æ–π –æ–¥–∏–Ω–∞–∫–æ–≤–∞ —á—Ç–æ –¥–ª—è <code>Vec&lt;T&gt;</code>, —á—Ç–æ –¥–ª—è <code>String</code>, —è–≤–ª—è–µ—Ç—Å—è —Ñ—É–Ω–∫—Ü–∏—è <code>new</code>, —Å–æ–∑–¥–∞—é—â–∞—è –Ω–æ–≤—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä —Ç–∏–ø–∞. –ü–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –Ω–∞ –õ–∏—Å—Ç–∏–Ω–≥ 8-11.</p>
<Listing number="8-11" caption="Creating a new, empty `String`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::new();
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>–≠—Ç–∞ —Å—Ç—Ä–æ–∫–∞ —Å–æ–∑–¥–∞—ë—Ç –Ω–æ–≤—É—é –ø—É—Å—Ç—É—é —Å—Ç—Ä–æ–∫—É <code>s</code>, –≤ –∫–æ—Ç–æ—Ä—É—é –º—ã –º–æ–∂–µ–º –∑–∞—Ç–µ–º –∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–∞–Ω–Ω—ã–µ. –ß–∞—Å—Ç–æ —É –Ω–∞—Å –µ—Å—Ç—å –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –Ω–∞—á–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ, –∫–æ—Ç–æ—Ä—ã–µ –º—ã —Ö–æ—Ç–∏–º –Ω–∞–∑–Ω–∞—á–∏—Ç—å —Å—Ç—Ä–æ–∫–µ. –î–ª—è —ç—Ç–æ–≥–æ –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º –º–µ—Ç–æ–¥ <code>to_string</code> –¥–æ—Å—Ç—É–ø–Ω—ã–π –¥–ª—è –ª—é–±–æ–≥–æ —Ç–∏–ø–∞, –∫–æ—Ç–æ—Ä—ã–π —Ä–µ–∞–ª–∏–∑—É–µ—Ç —Ç—Ä–µ–π—Ç <code>Display</code>, –∫–∞–∫ —É —Å—Ç—Ä–æ–∫–æ–≤—ã—Ö –ª–∏—Ç–µ—Ä–∞–ª–æ–≤. –õ–∏—Å—Ç–∏–Ω–≥ 8-12 –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç —ç—Ç–∏ –¥–≤–∞ —Å–ø–æ—Å–æ–±–∞.</p>
<Listing number="8-12" caption="Using the `to_string` method to create a `String` from a string literal">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let data = "–∏—Å—Ö–æ–¥–Ω—ã–π —Ç–µ–∫—Å—Ç";

    let s = data.to_string();

    // –≠—Ç–æ—Ç –º–µ—Ç–æ–¥ —Ç–∞–∫–∂–µ –º–æ–∂–Ω–æ –≤—ã–∑–≤–∞—Ç—å –Ω–∞–ø—Ä—è–º—É—é –Ω–∞ –ª–∏—Ç–µ—Ä–∞–ª–µ:
    let s = "–∏—Å—Ö–æ–¥–Ω—ã–π —Ç–µ–∫—Å—Ç".to_string();
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>–≠—Ç–æ—Ç –∫–æ–¥ —Å–æ–∑–¥–∞—ë—Ç —Å—Ç—Ä–æ–∫—É —Å —Ç–µ–∫—Å—Ç–æ–º <code>–∏—Å—Ö–æ–¥–Ω—ã–π —Ç–µ–∫—Å—Ç</code>.</p>
<p>–ú—ã —Ç–∞–∫–∂–µ –º–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ñ—É–Ω–∫—Ü–∏—é <code>String::from</code> –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è <code>String</code> –∏–∑ —Å—Ç—Ä–æ–∫–æ–≤–æ–≥–æ –ª–∏—Ç–µ—Ä–∞–ª–∞. –ö–æ–¥ –õ–∏—Å—Ç–∏–Ω–≥–∞ 8-13 —è–≤–ª—è–µ—Ç—Å—è —ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–Ω—ã–º –∫–æ–¥—É –∏–∑ –õ–∏—Å—Ç–∏–Ω–≥–∞ 8-12, –∏—Å–ø–æ–ª—å–∑—É—é—â–µ–º—É —Ñ—É–Ω–∫—Ü–∏—é <code>to_string</code>:</p>
<Listing number="8-13" caption="Using the `String::from` function to create a `String` from a string literal">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s = String::from("–∏—Å—Ö–æ–¥–Ω—ã–π —Ç–µ–∫—Å—Ç");
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>–ü–æ—Å–∫–æ–ª—å–∫—É —Å—Ç—Ä–æ–∫–∏ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –¥–ª—è –æ—á–µ–Ω—å –º–Ω–æ–≥–∏—Ö –≤–µ—â–µ–π, –¥–ª—è –Ω–∏—Ö –µ—Å—Ç—å –º–Ω–æ–≥–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤, —Ä–µ—à–∞—é—â–∏—Ö –æ–¥–Ω—É –∏ —Ç—É –∂–µ –∑–∞–¥–∞—á—É. –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –∏–∑ –Ω–∏—Ö –º–æ–≥—É—Ç –ø–æ–∫–∞–∑–∞—Ç—å—Å—è –∏–∑–±—ã—Ç–æ—á–Ω—ã–º–∏, –Ω–æ —É –≤—Å–µ—Ö –Ω–∏—Ö –µ—Å—Ç—å —Å–≤–æ–π —Å–º—ã—Å–ª! –í –¥–∞–Ω–Ω–æ–º —Å–ª—É—á–∞–µ, <code>String::from</code> –∏ <code>to_string</code> –¥–µ–ª–∞—é—Ç –æ–¥–Ω–æ –∏ —Ç–æ–∂–µ, –ø–æ—ç—Ç–æ–º—É –≤—ã–±–æ—Ä –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Ç–æ–≥–æ, –∫–∞–∫–æ–π –∏–∑ –Ω–∏—Ö –±—É–¥–µ—Ç –∫–æ—Ä–æ—á–µ –∏ –ø–æ–Ω—è—Ç–Ω–µ–µ.</p>
<p>–ü–æ–º–Ω–∏—Ç–µ, —á—Ç–æ —Å—Ç—Ä–æ–∫–∏ —Ö—Ä–∞–Ω—è—Ç—Å—è –≤ –∫–æ–¥–∏—Ä–æ–≤–∫–µ UTF-8, –ø–æ—ç—Ç–æ–º—É –≤ –Ω–∏—Ö –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ª—é–±–æ–π –ø—Ä–∞–≤–∏–ª—å–Ω–æ –∑–∞–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç, –∫–∞–∫ –ø–æ–∫–∞–∑–∞–Ω–æ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 8-14.</p>
<Listing number="8-14" caption="Storing greetings in different languages in strings">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let hello = String::from("ÿßŸÑÿ≥ŸÑÿßŸÖ ÿπŸÑŸäŸÉŸÖ");
    let hello = String::from("Dobr√Ω den");
    let hello = String::from("Hello");
    let hello = String::from("◊©◊ú◊ï◊ù");
    let hello = String::from("‡§®‡§Æ‡§∏‡•ç‡§§‡•á");
    let hello = String::from("„Åì„Çì„Å´„Å°„ÅØ");
    let hello = String::from("ÏïàÎÖïÌïòÏÑ∏Ïöî");
    let hello = String::from("‰Ω†Â•Ω");
    let hello = String::from("Ol√°");
    let hello = String::from("–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ");
    let hello = String::from("Hola");
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>–í—Å—ë —ç—Ç–æ ‚Äî –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è —Ç–∏–ø–∞ <code>String</code>.</p>
<h3 id="–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ-—Ç–µ–∫—Å—Ç–∞"><a class="header" href="#–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ-—Ç–µ–∫—Å—Ç–∞">–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞</a></h3>
<p>–°—Ç—Ä–æ–∫–∞ <code>String</code> –º–æ–∂–µ—Ç —É–≤–µ–ª–∏—á–∏–≤–∞—Ç—å—Å—è –≤ —Ä–∞–∑–º–µ—Ä–µ, –∞ –µ—ë —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –º–æ–∂–µ—Ç –º–µ–Ω—è—Ç—å—Å—è, –∫–∞–∫ –∏ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ <code>Vec&lt;T&gt;</code> –ø—Ä–∏ –≤—Å—Ç–∞–≤–∫–µ –≤ –Ω–µ–≥–æ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö. –ö—Ä–æ–º–µ —Ç–æ–≥–æ, –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –æ–ø–µ—Ä–∞—Ç–æ—Ä <code>+</code> –∏–ª–∏ –º–∞–∫—Ä–æ—Å <code>format!</code> –¥–ª—è –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö <code>String</code> –≤ –æ–¥–Ω—É.</p>
<h4 id="–ü—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ-–∫-—Å—Ç—Ä–æ–∫–µ-—Å-–ø–æ–º–æ—â—å—é-push_str-–∏-push"><a class="header" href="#–ü—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ-–∫-—Å—Ç—Ä–æ–∫–µ-—Å-–ø–æ–º–æ—â—å—é-push_str-–∏-push">–ü—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∫ —Å—Ç—Ä–æ–∫–µ —Å –ø–æ–º–æ—â—å—é <code>push_str</code> –∏ <code>push</code></a></h4>
<p>–ú—ã –º–æ–∂–µ–º –Ω–∞—Ä–∞—Å—Ç–∏—Ç—å <code>String</code>, –∏—Å–ø–æ–ª—å–∑—É—è –º–µ—Ç–æ–¥ <code>push_str</code> –∫–æ—Ç–æ—Ä—ã–π –¥–æ–±–∞–≤–∏—Ç –≤ –∏—Å—Ö–æ–¥–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–æ–≤—ã–π —Å—Ç—Ä–æ–∫–æ–≤—ã–π —Å—Ä–µ–∑, –∫–∞–∫ –ø–æ–∫–∞–∑–∞–Ω–æ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 8-15.</p>
<Listing number="8-15" caption="Appending a string slice to a `String` using the `push_str` method">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::from("foo");
    s.push_str("bar");
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>–ü–æ—Å–ª–µ —ç—Ç–∏—Ö –¥–≤—É—Ö —Å—Ç—Ä–æ–∫ –∫–æ–¥–∞ <code>s</code> –±—É–¥–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å <code>foobar</code>. –ú–µ—Ç–æ–¥ <code>push_str</code> –ø—Ä–∏–Ω–∏–º–∞–µ—Ç —Å—Ç—Ä–æ–∫–æ–≤—ã–π —Å—Ä–µ–∑, –ø–æ—Ç–æ–º—É —á—Ç–æ –º—ã –Ω–µ –≤—Å–µ–≥–¥–∞ —Ö–æ—Ç–∏–º –≤–ª–∞–¥–µ—Ç—å –≤—Ö–æ–¥–Ω—ã–º –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–º. –ù–∞–ø—Ä–∏–º–µ—Ä, –∫–æ–¥ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 8-16 –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å–ª—É—á–∞–π, –∫–æ–≥–¥–∞ –±—É–¥–µ—Ç –Ω–µ–∂–µ–ª–∞—Ç–µ–ª—å–Ω–æ –ø–æ–≤–µ–¥–µ–Ω–∏–µ, –ø—Ä–∏ –∫–æ—Ç–æ—Ä–æ–º –º—ã –Ω–µ —Å–º–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å <code>s2</code> –ø–æ—Å–ª–µ –µ—ë –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∫ —Å–æ–¥–µ—Ä–∂–∏–º–æ–º—É <code>s1</code>.</p>
<Listing number="8-16" caption="Using a string slice after appending its contents to a `String`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s1 = String::from("foo");
    let s2 = "bar";
    s1.push_str(s2);
    println!("s2: {s2}");
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>–ï—Å–ª–∏ –±—ã –º–µ—Ç–æ–¥ <code>push_str</code> —Å—Ç–∞–ª –≤–ª–∞–¥–µ–ª—å—Ü–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π <code>s2</code>, –º—ã –Ω–µ —Å–º–æ–≥–ª–∏ –±—ã –Ω–∞–ø–µ—á–∞—Ç–∞—Ç—å –µ–≥–æ –∑–Ω–∞—á–µ–Ω–∏–µ –≤ –ø–æ—Å–ª–µ–¥–Ω–µ–π —Å—Ç—Ä–æ–∫–µ. –û–¥–Ω–∞–∫–æ —ç—Ç–æ—Ç –∫–æ–¥ —Ä–∞–±–æ—Ç–∞–µ—Ç —Ç–∞–∫, –∫–∞–∫ –º—ã –æ–∂–∏–¥–∞–ª–∏!</p>
<p>–ú–µ—Ç–æ–¥ <code>push</code> –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –æ–¥–∏–Ω —Å–∏–º–≤–æ–ª –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –∏ –¥–æ–±–∞–≤–ª—è–µ—Ç –µ–≥–æ –∫ <code>String</code>. –í –õ–∏—Å—Ç–∏–Ω–≥–µ 8-17 –ø–æ–∫–∞–∑–∞–Ω –∫–æ–¥, –¥–æ–±–∞–≤–ª—è—é—â–∏–π –±—É–∫–≤—É <em>e</em> –∫ <code>String</code>, –∏—Å–ø–æ–ª—å–∑—É—è –º–µ—Ç–æ–¥ <code>push</code>.</p>
<Listing number="8-17" caption="Adding one character to a `String` value using `push`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::from("not");
    s.push('e');
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>–í —Ä–µ–∑—É–ª—å—Ç–∞—Ç–µ <code>s</code> –±—É–¥–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å <code>note</code>.</p>
<h4 id="–û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ-—Å—Ç—Ä–æ–∫-—Å-–ø–æ–º–æ—â—å—é-–æ–ø–µ—Ä–∞—Ç–æ—Ä–∞--–∏–ª–∏-–º–∞–∫—Ä–æ—Å–∞-format"><a class="header" href="#–û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ-—Å—Ç—Ä–æ–∫-—Å-–ø–æ–º–æ—â—å—é-–æ–ø–µ—Ä–∞—Ç–æ—Ä–∞--–∏–ª–∏-–º–∞–∫—Ä–æ—Å–∞-format">–û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ —Å—Ç—Ä–æ–∫ —Å –ø–æ–º–æ—â—å—é –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ <code>+</code> –∏–ª–∏ –º–∞–∫—Ä–æ—Å–∞ <code>format!</code></a></h4>
<p>–ß–∞—Å—Ç–æ —Ö–æ—á–µ—Ç—Å—è –æ–±—ä–µ–¥–∏–Ω–∏—Ç—å –¥–≤–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ —Å—Ç—Ä–æ–∫–∏. –û–¥–∏–Ω –∏–∑ –≤–æ–∑–º–æ–∂–Ω—ã—Ö —Å–ø–æ—Å–æ–±–æ–≤ ‚Äî —ç—Ç–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –æ–ø–µ—Ä–∞—Ç–æ—Ä <code>+</code>, –∫–∞–∫ –ø–æ–∫–∞–∑–∞–Ω–æ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 8-18.</p>
<Listing number="8-18" caption="Using the `+` operator to combine two `String` values into a new `String` value">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    let s3 = s1 + &amp;s2; // –æ–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ s1 –∑–¥–µ—Å—å –±—ã–ª–∞ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∞ –≤ –º–µ—Ç–æ–¥
                       // –∏ –¥–∞–ª–µ–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∞
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>–°—Ç—Ä–æ–∫–∞ <code>s3</code> –±—É–¥–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å <code>Hello, world!</code>. –ü—Ä–∏—á–∏–Ω–∞ —Ç–æ–≥–æ, —á—Ç–æ <code>s1</code> –ø–æ—Å–ª–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –±–æ–ª—å—à–µ –Ω–µ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞, –∏ –ø—Ä–∏—á–∏–Ω–∞, –ø–æ –∫–æ—Ç–æ—Ä–æ–π –º—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ —Å—Å—ã–ª–∫—É –Ω–∞ <code>s2</code>, –∏–º–µ—é—Ç –æ—Ç–Ω–æ—à–µ–Ω–∏–µ –∫ —Å–∏–≥–Ω–∞—Ç—É—Ä–µ –º–µ—Ç–æ–¥–∞, –≤—ã–∑—ã–≤–∞–µ–º–æ–≥–æ –ø—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ <code>+</code>. –û–ø–µ—Ä–∞—Ç–æ—Ä <code>+</code> –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –º–µ—Ç–æ–¥ <code>add</code>, —á—å—è —Å–∏–≥–Ω–∞—Ç—É—Ä–∞ –≤—ã–≥–ª—è–¥–∏—Ç –ø—Ä–∏–º–µ—Ä–Ω–æ —Ç–∞–∫:</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {</code></pre>
<p>–í —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–µ –≤—ã —É–≤–∏–¥–∏—Ç–µ –º–µ—Ç–æ–¥ <code>add</code> –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã–º —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –æ–±–æ–±—â—ë–Ω–Ω—ã—Ö –∏ —Å–≤—è–∑–∞–Ω–Ω—ã—Ö —Ç–∏–ø–æ–≤. –ó–¥–µ—Å—å –º—ã –ø—Ä–∏–≤–µ–ª–∏ –≤–∞–º —Å–∏–≥–Ω–∞—Ç—É—Ä—É, –ø–æ–¥—Å—Ç–∞–≤–∏–≤ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ —Ç–∏–ø—ã, –∑–∞–º–µ–Ω—è—é—â–∏–µ –æ–±–æ–±—â—ë–Ω–Ω—ã–π; —ç—Ç–æ –∏ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç, –∫–æ–≥–¥–∞ –¥–∞–Ω–Ω—ã–π –º–µ—Ç–æ–¥ –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è —Å–æ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏ <code>String</code>. –ú—ã –æ–±—Å—É–¥–∏–º –æ–±–æ–±—â—ë–Ω–Ω—ã–µ —Ç–∏–ø—ã –≤ –ì–ª–∞–≤–µ 10. –≠—Ç–∞ —Å–∏–≥–Ω–∞—Ç—É—Ä–∞ –¥–∞—ë—Ç –Ω–∞–º –∫–ª—é—á –∫ –ø–æ–Ω–∏–º–∞–Ω–∏—é –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–µ–π –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ <code>+</code>.</p>
<p>–í–æ-–ø–µ—Ä–≤—ã—Ö, –ø–µ—Ä–µ–¥ <code>s2</code> –º—ã –≤–∏–¥–∏–º <code>&amp;</code>, —á—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –º—ã —Å–∫–ª–∞–¥—ã–≤–∞–µ–º <em>—Å—Å—ã–ª–∫—É</em> –Ω–∞ –≤—Ç–æ—Ä—É—é —Å—Ç—Ä–æ–∫—É —Å –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–æ–∫–æ–π. –≠—Ç–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –∏–∑-–∑–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ <code>s</code> –≤ —Ñ—É–Ω–∫—Ü–∏–∏ <code>add</code>: –º—ã –º–æ–∂–µ–º –¥–æ–±–∞–≤–∏—Ç—å —Ç–æ–ª—å–∫–æ <code>&amp;str</code> –∫ <code>String</code>; –º—ã –Ω–µ –º–æ–∂–µ–º —Å–ª–æ–∂–∏—Ç—å –¥–≤–∞ –∑–Ω–∞—á–µ–Ω–∏—è <code>String</code>. –ù–æ –ø–æ–¥–æ–∂–¥–∏—Ç–µ: —Ç–∏–ø <code>&amp;s2</code> ‚Äî —ç—Ç–æ <code>&amp;String</code>, –∞ –Ω–µ <code>&amp;str</code>, –∫–æ—Ç–æ—Ä—ã–π –º—ã –æ–ø—Ä–µ–¥–µ–ª–∏–ª–∏ –≤–æ –≤—Ç–æ—Ä–æ–º –ø–∞—Ä–∞–º–µ—Ç—Ä–µ <code>add</code>. –¢–∞–∫ –ø–æ—á–µ–º—É –∫–æ–¥ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 8-18 –∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è?</p>
<p>–ü—Ä–∏—á–∏–Ω–∞, –ø–æ –∫–æ—Ç–æ—Ä–æ–π –º—ã –º–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å <code>&amp;s2</code> –≤ –≤—ã–∑–æ–≤–µ <code>add</code> –∑–∞–∫–ª—é—á–∞–µ—Ç—Å—è –≤ —Ç–æ–º, —á—Ç–æ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –º–æ–∂–µ—Ç <em>–ø—Ä–∏–≤–µ—Å—Ç–∏</em> –∞—Ä–≥—É–º–µ–Ω—Ç —Ç–∏–ø–∞ <code>&amp;String</code> –∫ —Ç–∏–ø—É <code>&amp;str</code>. –ö–æ–≥–¥–∞ –º—ã –≤—ã–∑—ã–≤–∞–µ–º –º–µ—Ç–æ–¥ <code>add</code>, Rust –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–µ —Å—Å—ã–ª–æ–∫ –ø—Ä–∏ —Ä–∞–∑—ã–º–µ–Ω–æ–≤—ã–≤–∞–Ω–∏–∏, –∫–æ—Ç–æ—Ä–æ–µ –ø—Ä–µ–≤—Ä–∞—â–∞–µ—Ç <code>&amp;s2</code> –≤ <code>&amp;s2[..]</code>. –ú—ã –ø–æ–¥—Ä–æ–±–Ω–æ –æ–±—Å—É–¥–∏–º –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–µ —Å—Å—ã–ª–æ–∫ –ø—Ä–∏ —Ä–∞–∑—ã–º–µ–Ω–æ–≤—ã–≤–∞–Ω–∏–∏ –≤ –ì–ª–∞–≤–µ 15. –¢–∞–∫ –∫–∞–∫ <code>add</code> –Ω–µ –∑–∞–±–∏—Ä–∞–µ—Ç –≤–æ –≤–ª–∞–¥–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä <code>s</code>, <code>s2</code> –ø–æ –ø—Ä–µ–∂–Ω–µ–º—É –±—É–¥–µ—Ç –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ–π <code>String</code> –ø–æ—Å–ª–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –∫–æ–Ω–∫–∞—Ç–µ–Ω–∞—Ü–∏–∏.</p>
<p>–í–æ-–≤—Ç–æ—Ä—ã—Ö, –∫–∞–∫ –º–æ–∂–Ω–æ –≤–∏–¥–µ—Ç—å –≤ —Å–∏–≥–Ω–∞—Ç—É—Ä–µ, <code>add</code> –∑–∞–±–∏—Ä–∞–µ—Ç <code>self</code> –≤–æ –≤–ª–∞–¥–µ–Ω–∏–µ, –ø–æ—Ç–æ–º—É —á—Ç–æ <code>self</code> –≤ —Å–∏–≥–Ω–∞—Ç—É—Ä–µ —É–∫–∞–∑–∞–Ω <em>–±–µ–∑</em> <code>&amp;</code>. –≠—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ <code>s1</code> –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 8-18 –±—É–¥–µ—Ç –ø–µ—Ä–µ–º–µ—â—ë–Ω –≤ –≤—ã–∑–æ–≤ <code>add</code> –∏ –±–æ–ª—å—à–µ –Ω–µ –±—É–¥–µ—Ç –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω –ø–æ—Å–ª–µ —ç—Ç–æ–≥–æ –≤—ã–∑–æ–≤–∞. –ù–µ —Å–º–æ—Ç—Ä—è –Ω–∞ —Ç–æ, —á—Ç–æ –∫–æ–¥ <code>let s3 = s1 + &amp;s2;</code> –≤—ã–≥–ª—è–¥–∏—Ç —Ç–∞–∫, –∫–∞–∫ –±—É–¥—Ç–æ –æ–Ω —Å–∫–æ–ø–∏—Ä—É–µ—Ç –æ–±–µ —Å—Ç—Ä–æ–∫–∏ –∏ —Å–æ–∑–¥–∞—Å—Ç –Ω–æ–≤—É—é, —ç—Ç–∞ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∏ –∑–∞–±–∏—Ä–∞–µ—Ç –≤–æ –≤–ª–∞–¥–µ–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é <code>s1</code>, –ø—Ä–∏—Å–æ–µ–¥–∏–Ω—è–µ—Ç –∫ –Ω–µ–π –∫–æ–ø–∏—é —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ <code>s2</code>, –∞ –∑–∞—Ç–µ–º –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤–ª–∞–¥–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–º. –î—Ä—É–≥–∏–º–∏ —Å–ª–æ–≤–∞–º–∏, —ç—Ç–æ –≤—ã–≥–ª—è–¥–∏—Ç, –∫–∞–∫ –±—É–¥—Ç–æ –∫–æ–¥ —Å–æ–∑–¥–∞—ë—Ç –º–Ω–æ–∂–µ—Å—Ç–≤–æ –∫–æ–ø–∏–π, –Ω–æ —ç—Ç–æ –Ω–µ —Ç–∞–∫; –¥–∞–Ω–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –±–æ–ª–µ–µ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–∞, —á–µ–º –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ.</p>
<p>–ï—Å–ª–∏ –Ω—É–∂–Ω–æ –æ–±—ä–µ–¥–∏–Ω–∏—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å—Ç—Ä–æ–∫, –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ <code>+</code> –ø—Ä–∏–≤–æ–¥–∏—Ç –∫ –≥—Ä–æ–º–æ–∑–¥–∫–∏–º –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏—è–º:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = s1 + "-" + &amp;s2 + "-" + &amp;s3;
<span class="boring">}</span></code></pre></pre>
<p>–ó–¥–µ—Å—å –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è <code>s</code> –±—É–¥–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å <code>tic-tac-toe</code>. –° –º–Ω–æ–∂–µ—Å—Ç–≤–æ–º —Å–∏–º–≤–æ–ª–æ–≤ <code>+</code> –∏ <code>"</code> —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è —Ç—Ä—É–¥–Ω–æ –ø–æ–Ω—è—Ç—å, —á—Ç–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç. –î–ª—è –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω–æ–≥–æ –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–∏—è —Å—Ç—Ä–æ–∫ –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –º–∞–∫—Ä–æ—Å <code>format!</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = format!("{s1}-{s2}-{s3}");
<span class="boring">}</span></code></pre></pre>
<p>–≠—Ç–æ—Ç –∫–æ–¥ —Ç–∞–∫ –∂–µ —Å–≤—è–∑—ã–≤–∞–µ—Ç –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é <code>s</code> —Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º <code>tic-tac-toe</code>. –ú–∞–∫—Ä–æ—Å <code>format!</code> —Ä–∞–±–æ—Ç–∞–µ—Ç —Ç–µ–º –∂–µ –æ–±—Ä–∞–∑–æ–º, —á—Ç–æ –∏ –º–∞–∫—Ä–æ—Å <code>println!</code>, –Ω–æ –≤–º–µ—Å—Ç–æ –≤—ã–≤–æ–¥–∞ –Ω–∞ —ç–∫—Ä–∞–Ω –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∏—Ä—É—é—â—É—é <code>String</code>. –í–µ—Ä—Å–∏—è –∫–æ–¥–∞ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º <code>format!</code> –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ –ª–µ–≥—á–µ —á–∏—Ç–∞–µ—Ç—Å—è: –∫—Ä–æ–º–µ —Ç–æ–≥–æ, –∫–æ–¥, —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–∞–∫—Ä–æ—Å–æ–º <code>format!</code>, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —Å—Å—ã–ª–∫–∏, –∞ –∑–Ω–∞—á–∏—Ç –Ω–µ –∑–∞–±–∏—Ä–∞–µ—Ç –≤–æ –≤–ª–∞–¥–µ–Ω–∏–µ –Ω–∏ –æ–¥–Ω—É –∏–∑ –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã—Ö —Å—Ç—Ä–æ–∫.</p>
<h3 id="–û–±—Ä–∞—â–µ–Ω–∏–µ-–∫-—Å—Ç—Ä–æ–∫–µ-–ø–æ-–∏–Ω–¥–µ–∫—Å—É"><a class="header" href="#–û–±—Ä–∞—â–µ–Ω–∏–µ-–∫-—Å—Ç—Ä–æ–∫–µ-–ø–æ-–∏–Ω–¥–µ–∫—Å—É">–û–±—Ä–∞—â–µ–Ω–∏–µ –∫ —Å—Ç—Ä–æ–∫–µ –ø–æ –∏–Ω–¥–µ–∫—Å—É</a></h3>
<p>–î–æ—Å—Ç—É–ø –∫ –æ—Ç–¥–µ–ª—å–Ω—ã–º —Å–∏–º–≤–æ–ª–∞–º –≤ —Å—Ç—Ä–æ–∫–µ —Å –ø–æ–º–æ—â—å—é –≤–∑—è—Ç–∏—è —Å—Å—ã–ª–∫–∏ –Ω–∞ –Ω–∏—Ö –ø–æ –∏–Ω–¥–µ–∫—Å—É —è–≤–ª—è–µ—Ç—Å—è –¥–æ–ø—É—Å—Ç–∏–º–æ–π –∏ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—ë–Ω–Ω–æ–π –æ–ø–µ—Ä–∞—Ü–∏–µ–π –≤–æ –º–Ω–æ–≥–∏—Ö –¥—Ä—É–≥–∏—Ö —è–∑—ã–∫–∞—Ö –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è. –¢–µ–º –Ω–µ –º–µ–Ω–µ–µ, –µ—Å–ª–∏ –≤—ã –ø–æ–ø—ã—Ç–∞–µ—Ç–µ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ —á–∞—Å—Ç—è–º <code>String</code>, –∏—Å–ø–æ–ª—å–∑—É—è —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –∏–Ω–¥–µ–∫—Å–∞—Ü–∏–∏, —Ç–æ –ø–æ–ª—É—á–∏—Ç–µ –æ—à–∏–±–∫—É. –†–∞—Å—Å–º–æ—Ç—Ä–∏–º –Ω–µ–≤–µ—Ä–Ω—ã–π –∫–æ–¥ –õ–∏—Å—Ç–∏–Ω–≥–∞ 8-19.</p>
<Listing number="8-19" caption="Attempting to use indexing syntax with a String">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");
    let h = s1[0];
<span class="boring">}</span></code></pre>
</Listing>
<p>–≠—Ç–æ—Ç –∫–æ–¥ –ø—Ä–∏–≤–µ–¥—ë—Ç –∫ —Å–ª–µ–¥—É—é—â–µ–π –æ—à–∏–±–∫–µ:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `str` cannot be indexed by `{integer}`
 --&gt; src/main.rs:3:16
  |
3 |     let h = s1[0];
  |                ^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex&lt;str&gt;` is not implemented for `{integer}`, which is required by `String: Index&lt;_&gt;`
  = note: you can use `.chars().nth()` or `.bytes().nth()`
          for more information, see chapter 8 in The Book: &lt;https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings&gt;
  = help: the trait `SliceIndex&lt;[_]&gt;` is implemented for `usize`
  = help: for that trait implementation, expected `[_]`, found `str`
  = note: required for `String` to implement `Index&lt;{integer}&gt;`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections` (bin "collections") due to 1 previous error
</code></pre>
<p>–û—à–∏–±–∫–∞ –∏ –ø—Ä–∏–º–µ—á–∞–Ω–∏–µ –≥–æ–≤–æ—Ä—è—Ç, —á—Ç–æ –≤ Rust —Å—Ç—Ä–æ–∫–∏ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç –∏–Ω–¥–µ–∫—Å–∞—Ü–∏—é. –ù–æ –ø–æ—á–µ–º—É —Ç–∞–∫? –ß—Ç–æ–±—ã –æ—Ç–≤–µ—Ç–∏—Ç—å –Ω–∞ —ç—Ç–æ—Ç –≤–æ–ø—Ä–æ—Å, –Ω—É–∂–Ω–æ –æ–±—Å—É–¥–∏—Ç—å —Ç–æ, –∫–∞–∫ Rust —Ö—Ä–∞–Ω–∏—Ç —Å—Ç—Ä–æ–∫–∏ –≤ –ø–∞–º—è—Ç–∏.</p>
<h4 id="–í–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ-—É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ"><a class="header" href="#–í–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ-—É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ">–í–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ</a></h4>
<p>–¢–∏–ø <code>String</code> —è–≤–ª—è–µ—Ç—Å—è –æ–±–æ–ª–æ—á–∫–æ–π –Ω–∞–¥ —Ç–∏–ø–æ–º <code>Vec&lt;u8&gt;</code>. –î–∞–≤–∞–π—Ç–µ –ø–æ—Å–º–æ—Ç—Ä–∏–º –Ω–∞ –Ω–µ—Å–∫–æ–ª—å–∫–æ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–º –æ–±—Ä–∞–∑–æ–º –∑–∞–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Å—Ç—Ä–æ–∫ –≤ UTF-8 –∏–∑ –ø—Ä–∏–º–µ—Ä–∞ –õ–∏—Å—Ç–∏–Ω–≥–∞ 8-14. –ù–∞—á–Ω—ë–º —Å —ç—Ç–æ–π:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from("ÿßŸÑÿ≥ŸÑÿßŸÖ ÿπŸÑŸäŸÉŸÖ");
</span><span class="boring">    let hello = String::from("Dobr√Ω den");
</span><span class="boring">    let hello = String::from("Hello");
</span><span class="boring">    let hello = String::from("◊©◊ú◊ï◊ù");
</span><span class="boring">    let hello = String::from("‡§®‡§Æ‡§∏‡•ç‡§§‡•á");
</span><span class="boring">    let hello = String::from("„Åì„Çì„Å´„Å°„ÅØ");
</span><span class="boring">    let hello = String::from("ÏïàÎÖïÌïòÏÑ∏Ïöî");
</span><span class="boring">    let hello = String::from("‰Ω†Â•Ω");
</span><span class="boring">    let hello = String::from("Ol√°");
</span><span class="boring">    let hello = String::from("–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ");
</span>    let hello = String::from("Hola");
<span class="boring">}</span></code></pre></pre>
<p>–í —ç—Ç–æ–º —Å–ª—É—á–∞–µ <code>len</code> –±—É–¥–µ—Ç <code>4</code>, —á—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –≤–µ–∫—Ç–æ—Ä —Ö—Ä–∞–Ω–∏—Ç —Å—Ç—Ä–æ–∫—É <code>"Hola"</code> –¥–ª–∏–Ω–æ–π 4 –±–∞–π—Ç–∞. –ö–∞–∂–¥–∞—è –∏–∑ —ç—Ç–∏—Ö –±—É–∫–≤ –∑–∞–Ω–∏–º–∞–µ—Ç –æ–¥–∏–Ω –±–∞–π—Ç –ø—Ä–∏ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–∏ –≤ UTF-8. –ù–æ –∫–∞–∫ –Ω–∞—Å—á—ë—Ç —Å–ª–µ–¥—É—é—â–µ–π —Å—Ç—Ä–æ–∫–∏?</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from("ÿßŸÑÿ≥ŸÑÿßŸÖ ÿπŸÑŸäŸÉŸÖ");
</span><span class="boring">    let hello = String::from("Dobr√Ω den");
</span><span class="boring">    let hello = String::from("Hello");
</span><span class="boring">    let hello = String::from("◊©◊ú◊ï◊ù");
</span><span class="boring">    let hello = String::from("‡§®‡§Æ‡§∏‡•ç‡§§‡•á");
</span><span class="boring">    let hello = String::from("„Åì„Çì„Å´„Å°„ÅØ");
</span><span class="boring">    let hello = String::from("ÏïàÎÖïÌïòÏÑ∏Ïöî");
</span><span class="boring">    let hello = String::from("‰Ω†Â•Ω");
</span><span class="boring">    let hello = String::from("Ol√°");
</span>    let hello = String::from("–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ");
<span class="boring">    let hello = String::from("Hola");
</span><span class="boring">}</span></code></pre></pre>
<p>–û—Ç–≤–µ—á–∞—è –Ω–∞ –≤–æ–ø—Ä–æ—Å, –∫–∞–∫–æ–≤–∞ –¥–ª–∏–Ω–∞ —Å—Ç—Ä–æ–∫–∏, –≤—ã –º–æ–∂–µ—Ç–µ –æ—Ç–≤–µ—Ç–∏—Ç—å 12. –û–¥–Ω–∞–∫–æ –æ—Ç–≤–µ—Ç Rust ‚Äî 24, —á—Ç–æ —Ä–∞–≤–Ω–æ —á–∏—Å–ª—É –±–∞–π—Ç–æ–≤, –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö –¥–ª—è –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è "–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ" –≤ UTF-8. –¢–∞–∫ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –ø–æ—Ç–æ–º—É, —á—Ç–æ –∫–∞–∂–¥—ã–π —Å–∏–º–≤–æ–ª Unicode –≤ —ç—Ç–æ–π —Å—Ç—Ä–æ–∫–µ –∑–∞–Ω–∏–º–∞–µ—Ç 2 –±–∞–π—Ç–∞ –ø–∞–º—è—Ç–∏. –°–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ, –æ–±—Ä–∞—â–µ–Ω–∏–µ –ø–æ –∏–Ω–¥–µ–∫—Å—É –∫ –æ—Ç–¥–µ–ª—å–Ω—ã–º –±–∞–π—Ç–∞–º —Å—Ç—Ä–æ–∫–∏ –Ω–µ –≤—Å–µ–≥–¥–∞ –±—ã —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–æ–≤–∞–ª–æ –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω–æ–º—É —Å–∏–º–≤–æ–ª—É Unicode. –î–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º —ç—Ç–æ—Ç (–Ω–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π) –∫–æ–¥ Rust:</p>
<pre><code class="language-rust ignore does_not_compile">let hello = "–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ";
let answer = &amp;hello[0];</code></pre>
<p>–í—ã —É–∂–µ –∑–Ω–∞–µ—Ç–µ, —á—Ç–æ <code>answer</code> –Ω–µ –±—É–¥–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å <code>–ó</code> ‚Äî –ø–µ—Ä–≤—É—é –±—É–∫–≤—É —Å—Ç—Ä–æ–∫–∏, –Ω–æ –Ω–µ –ø–µ—Ä–≤—ã–π –±–∞–π—Ç. –ü—Ä–∏ –∫–æ–¥–∏—Ä–æ–≤–∫–µ –≤ UTF-8, –ø–µ—Ä–≤—ã–π –±–∞–π—Ç –±—É–∫–≤—ã <code>–ó</code> —Ä–∞–≤–µ–Ω <code>208</code>, –∞ –≤—Ç–æ—Ä–æ–π ‚Äî <code>151</code>, –ø–æ—ç—Ç–æ–º—É –∑–Ω–∞—á–µ–Ω–∏–µ –≤ <code>answer</code> –Ω–∞ —Å–∞–º–æ–º –¥–µ–ª–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å <code>208</code>, –Ω–æ —Å–∞–º–æ –ø–æ —Å–µ–±–µ <code>208</code> –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–º —Å–∏–º–≤–æ–ª–æ–º. –ß–∏—Å–ª–æ <code>208</code> ‚Äî —ç—Ç–æ, —Å–∫–æ—Ä–µ–µ –≤—Å–µ–≥–æ, –Ω–µ —Ç–æ, —á—Ç–æ —Ö–æ—Ç–µ–ª –±—ã –ø–æ–ª—É—á–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: –≤–µ–¥—å –æ–Ω –æ–∂–∏–¥–∞–µ—Ç –ø–µ—Ä–≤—É—é –±—É–∫–≤—É —ç—Ç–æ–π —Å—Ç—Ä–æ–∫–∏; —Ç–µ–º –Ω–µ –º–µ–Ω–µ–µ, –∏–º–µ–Ω–Ω–æ —ç—Ç–æ —è–≤–ª—è–µ—Ç—Å—è –ª—É—á—à–∏–º, —á—Ç–æ Rust –º–æ–≥ –±—ã –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è—Ç—å –ø–æ –∏–Ω–¥–µ–∫—Å—É 0. –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –æ–±—ã—á–Ω–æ –Ω–µ —Ö–æ—Ç—è—Ç –ø–æ–ª—É—á–∞—Ç—å —Å—ã—Ä—ã–µ –±–∞–π—Ç—ã, –¥–∞–∂–µ –µ—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞ —Å–æ–¥–µ—Ä–∂–∏—Ç —Ç–æ–ª—å–∫–æ –ª–∞—Ç–∏–Ω—Å–∫–∏–µ –±—É–∫–≤—ã: –µ—Å–ª–∏ –±—ã <code>&amp;"hi"[0]</code> –±—ã–ª–æ –¥–æ–ø—É—Å—Ç–∏–º—ã–º –∫–æ–¥–æ–º, –∫–æ—Ç–æ—Ä—ã–π –≤–æ–∑–≤—Ä–∞—â–∞–ª –±–∞–π—Ç–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ, –æ–Ω –≤–æ–∑–≤—Ä–∞—â–∞–ª –±—ã <code>104</code>, –∞ –Ω–µ <code>h</code>.</p>
<p>–¢–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, —á—Ç–æ–±—ã –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—Ç–∏—Ç—å –≤–æ–∑–≤—Ä–∞—Ç –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è, –≤—ã–∑—ã–≤–∞—é—â–µ–≥–æ –æ—à–∏–±–∫–∏, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ –º–æ–≥—É—Ç –±—ã—Ç—å —Å—Ä–∞–∑—É –æ–±–Ω–∞—Ä—É–∂–µ–Ω—ã, Rust –ø—Ä–æ—Å—Ç–æ –Ω–µ –∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç —Ç–∞–∫–æ–π –∫–æ–¥ –∏ –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç –Ω–µ–¥–æ–ø–æ–Ω–∏–º–∞–Ω–∏–µ –Ω–∞ —Ä–∞–Ω–Ω–∏—Ö —ç—Ç–∞–ø–∞—Ö –ø—Ä–æ—Ü–µ—Å—Å–∞ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏.</p>
<h4 id="–ë–∞–π—Ç—ã-—Å–∏–º–≤–æ–ª—ã-unicode-–∏-–∫–ª–∞—Å—Ç–µ—Ä—ã-–≥—Ä–∞—Ñ–µ–º"><a class="header" href="#–ë–∞–π—Ç—ã-—Å–∏–º–≤–æ–ª—ã-unicode-–∏-–∫–ª–∞—Å—Ç–µ—Ä—ã-–≥—Ä–∞—Ñ–µ–º">–ë–∞–π—Ç—ã, —Å–∏–º–≤–æ–ª—ã Unicode –∏ –∫–ª–∞—Å—Ç–µ—Ä—ã –≥—Ä–∞—Ñ–µ–º</a></h4>
<p>Another point about UTF-8 is that there are actually three relevant ways to look at strings from Rust‚Äôs perspective: as bytes, scalar values, and grapheme clusters (the closest thing to what we would call <em>letters</em>).</p>
<p>–ï—Å–ª–∏ –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –Ω–∞ —Å–ª–æ–≤–æ "‡§®‡§Æ‡§∏‡•ç‡§§‡•á" —è–∑—ã–∫–∞ —Ö–∏–Ω–¥–∏, –Ω–∞–ø–∏—Å–∞–Ω–Ω–æ–µ –ø–∏—Å—å–º–æ–º –¥–µ–≤–∞–Ω–∞–≥–∞—Ä–∏, —Ç–æ –æ–Ω–æ —Ö—Ä–∞–Ω–∏—Ç—Å—è –∫–∞–∫ –≤–µ–∫—Ç–æ—Ä –∑–Ω–∞—á–µ–Ω–∏–π <code>u8</code>, –∫–æ—Ç–æ—Ä—ã–π –≤—ã–≥–ª—è–¥–∏—Ç —Å–ª–µ–¥—É—é—â–∏–º –æ–±—Ä–∞–∑–æ–º:</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>–≠—Ç–∏ 18 –±–∞–π—Ç —è–≤–ª—è—é—Ç—Å—è –∏–º–µ–Ω–Ω–æ —Ç–µ–º, –∫–∞–∫ –∫–æ–º–ø—å—é—Ç–µ—Ä—ã –≤ –∫–æ–Ω–µ—á–Ω–æ–º –∏—Ç–æ–≥–µ —Å–æ—Ö—Ä–∞–Ω—è—Ç –≤ –ø–∞–º—è—Ç–∏ —ç—Ç—É —Å—Ç—Ä–æ–∫—É. –ï—Å–ª–∏ –º—ã –ø–æ—Å–º–æ—Ç—Ä–∏–º –Ω–∞ —ç—Ç–æ —Å–ª–æ–≤–æ –∫–∞–∫ –Ω–∞ —Å–∏–º–≤–æ–ª—ã Unicode (–∫–æ—Ç–æ—Ä—ã–º–∏ –∏ —è–≤–ª—è–µ—Ç—Å—è —Ç–∏–ø <code>char</code>), —Ç–æ –±–∞–π—Ç—ã –ø—Ä–µ–¥—Å—Ç–∞–Ω—É—Ç –ø–µ—Ä–µ–¥ –Ω–∞–º–∏ –≤ —Ç–∞–∫–æ–º –≤–∏–¥–µ:</p>
<pre><code class="language-text">['‡§®', '‡§Æ', '‡§∏', '‡•ç', '‡§§', '‡•á']
</code></pre>
<p>–ó–¥–µ—Å—å –µ—Å—Ç—å —à–µ—Å—Ç—å –∑–Ω–∞—á–µ–Ω–∏–π <code>char</code>, –Ω–æ —á–µ—Ç–≤—ë—Ä—Ç—ã–π –∏ —à–µ—Å—Ç–æ–π —è–≤–ª—è—é—Ç—Å—è –Ω–µ –±—É–∫–≤–∞–º–∏: –æ–Ω–∏ ‚Äî —ç—Ç–æ –¥–∏–∞–∫—Ä–∏—Ç–∏–∫–∞, —Ç–æ –µ—Å—Ç—å —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–∫–∏, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ –∏–º–µ—é—Ç —Å–º—ã—Å–ª–∞ —Å–∞–º–∏ –ø–æ —Å–µ–±–µ. –ù–∞–∫–æ–Ω–µ—Ü, –µ—Å–ª–∏ –º—ã –ø–æ—Å–º–æ—Ç—Ä–∏–º –Ω–∞ –±–∞–π—Ç—ã –∫–∞–∫ –Ω–∞ –∫–ª–∞—Å—Ç–µ—Ä—ã –≥—Ä–∞—Ñ–µ–º, —Ç–æ –ø–æ–ª—É—á–∏–º —Ç–æ, —á—Ç–æ —á–µ–ª–æ–≤–µ–∫ –Ω–∞–∑–≤–∞–ª –±—ã —Å–ª–æ–≤–æ–º –Ω–∞ —Ö–∏–Ω–¥–∏, —Å–æ—Å—Ç–æ—è—â–∏–º –∏–∑ —á–µ—Ç—ã—Ä—ë—Ö –≥—Ä–∞—Ñ–µ–º:</p>
<pre><code class="language-text">["‡§®", "‡§Æ", "‡§∏‡•ç", "‡§§‡•á"]
</code></pre>
<p>Rust –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç —Ä–∞–∑–ª–∏—á–Ω—ã–µ —Å–ø–æ—Å–æ–±—ã –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏–∏ –Ω–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã—Ö (—Ö—Ä–∞–Ω–∏–º—ã—Ö –≤ —É–¥–æ–±–Ω–æ–º –∫–æ–º–ø—å—é—Ç–µ—Ä—É –≤–∏–¥–µ) —Å—Ç—Ä–æ–∫–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö, —Ç–∞–∫, —á—Ç–æ–±—ã –∫–∞–∂–¥–æ–π –ø—Ä–æ–≥—Ä–∞–º–º–µ –º–æ–∂–Ω–æ –±—ã–ª–æ –≤—ã–±—Ä–∞—Ç—å –Ω–µ–æ–±—Ö–æ–¥–∏–º—É—é –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—é, –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –æ—Ç —Ç–æ–≥–æ, –Ω–∞ –∫–∞–∫–æ–º —á–µ–ª–æ–≤–µ—á–µ—Å–∫–æ–º —è–∑—ã–∫–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω—ã —ç—Ç–∏ –¥–∞–Ω–Ω—ã–µ.</p>
<p>–ü–æ—Å–ª–µ–¥–Ω—è—è –ø—Ä–∏—á–∏–Ω–∞, –ø–æ –∫–æ—Ç–æ—Ä–æ–π Rust –Ω–µ –ø–æ–∑–≤–æ–ª—è–µ—Ç –Ω–∞–º –æ–±—Ä–∞—â–∞—Ç—å—Å—è –∫ <code>String</code> –ø–æ –∏–Ω–¥–µ–∫—Å—É –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–∏–º–≤–æ–ª–æ–≤, —è–≤–ª—è–µ—Ç—Å—è —Ç–æ, —á—Ç–æ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç—ã –æ–∂–∏–¥–∞—é—Ç, —á—Ç–æ –æ–ø–µ—Ä–∞—Ü–∏–∏ –∏–Ω–¥–µ–∫—Å–∏—Ä–æ–≤–∞–Ω–∏—è –≤—Å–µ–≥–¥–∞ –∏–º–µ—é—Ç –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–µ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è ‚Äî <em>O(1)</em>. –ù–æ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å —Ç–∞–∫—É—é –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –¥–ª—è <code>String</code>, –ø–æ—Ç–æ–º—É —á—Ç–æ Rust –ø–æ–Ω–∞–¥–æ–±–∏–ª–æ—Å—å –±—ã –ø—Ä–æ—Ö–æ–¥–∏—Ç—å—Å—è –ø–æ —Å–æ–¥–µ—Ä–∂–∏–º–æ–º—É –æ—Ç –Ω–∞—á–∞–ª–∞ –¥–æ –∏–Ω–¥–µ–∫—Å–∞, —á—Ç–æ–±—ã –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å, —Å–∫–æ–ª—å–∫–æ –±—ã–ª–æ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤.</p>
<h3 id="–í–∑—è—Ç–∏–µ-—Å—Ä–µ–∑–æ–≤-—Å—Ç—Ä–æ–∫"><a class="header" href="#–í–∑—è—Ç–∏–µ-—Å—Ä–µ–∑–æ–≤-—Å—Ç—Ä–æ–∫">–í–∑—è—Ç–∏–µ —Å—Ä–µ–∑–æ–≤ —Å—Ç—Ä–æ–∫</a></h3>
<p>–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∏–Ω–¥–µ–∫—Å–æ–≤ —Å–æ —Å—Ç—Ä–æ–∫–∞–º–∏ —á–∞—Å—Ç–æ —è–≤–ª—è–µ—Ç—Å—è –ø–ª–æ—Ö–æ–π –∏–¥–µ–µ–π, –ø–æ—Ç–æ–º—É —á—Ç–æ –Ω–µ —è—Å–Ω–æ, –∫–∞–∫–∏–º –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—ã–π —Ç–∏–ø —Ç–∞–∫–æ–π –æ–ø–µ—Ä–∞—Ü–∏–∏: –±–∞–π—Ç–æ–º, —Å–∏–º–≤–æ–ª–æ–º, –∫–ª–∞—Å—Ç–µ—Ä–æ–º –≥—Ä–∞—Ñ–µ–º –∏–ª–∏ —Å—Ä–µ–∑–æ–º —Å—Ç—Ä–æ–∫–∏. –ü–æ—ç—Ç–æ–º—É Rust –ø—Ä–æ—Å–∏—Ç –≤–∞—Å –±—ã—Ç—å –±–æ–ª–µ–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º, –µ—Å–ª–∏ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ —Ç—Ä–µ–±—É–µ—Ç—Å—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏–Ω–¥–µ–∫—Å—ã –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Å—Ä–µ–∑–æ–≤ —Å—Ç—Ä–æ–∫.</p>
<p>–í–º–µ—Å—Ç–æ –∏–Ω–¥–µ–∫—Å–∞—Ü–∏–∏ —Å –ø–æ–º–æ—â—å—é —É–∫–∞–∑–∞–Ω–∏—è –∏–Ω–¥–µ–∫—Å–∞ –≤ <code>[]</code>, –≤—ã –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤ <code>[]</code> –æ–ø–µ—Ä–∞—Ç–æ—Ä –¥–∏–∞–ø–∞–∑–æ–Ω–∞, —á—Ç–æ–±—ã —Å–æ–∑–¥–∞–≤–∞—Ç—å —Å—Ä–µ–∑ —Å—Ç—Ä–æ–∫–∏:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = "–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ";

let s = &amp;hello[0..4];
<span class="boring">}</span></code></pre></pre>
<p>–ó–¥–µ—Å—å –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è <code>s</code> –±—É–¥–µ—Ç –∏–º–µ—Ç—å —Ç–∏–ø <code>&amp;str</code> –∏ —Å–æ–¥–µ—Ä–∂–∞–∏—Ç –ø–µ—Ä–≤—ã–µ —á–µ—Ç—ã—Ä–µ –±–∞–π—Ç–∞ —Å—Ç—Ä–æ–∫–∏. –†–∞–Ω–µ–µ –º—ã —É–ø–æ–º–∏–Ω–∞–ª–∏, —á—Ç–æ –∫–∞–∂–¥—ã–π –∏–∑ —ç—Ç–∏—Ö —Å–∏–º–≤–æ–ª–æ–≤ –∑–∞–Ω–∏–º–∞–ª –ø–æ –¥–≤–∞ –±–∞–π—Ç–∞, —á—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ <code>s</code> –±—É–¥–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å <code>–ó–¥</code>.</p>
<p>–ß—Ç–æ –±—ã –ø—Ä–æ–∏–∑–æ—à–ª–æ, –µ—Å–ª–∏ –±—ã –º—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ <code>&amp;hello[0..1]</code>? –û—Ç–≤–µ—Ç: Rust –±—ã –∑–∞–ø–∞–Ω–∏–∫–æ–≤–∞–ª –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Ç–æ—á–Ω–æ —Ç–∞–∫ –∂–µ, –∫–∞–∫ –µ—Å–ª–∏ –±—ã –æ–±—Ä–∞—â–∞–ª–∏—Å—å –∫ –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ–º—É –∏–Ω–¥–µ–∫—Å—É –≤ –≤–µ–∫—Ç–æ—Ä–µ:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/collections`
thread 'main' panicked at src/main.rs:4:19:
byte index 1 is not a char boundary; it is inside '–ó' (bytes 0..2) of `–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ`
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>–í—ã –¥–æ–ª–∂–Ω—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –¥–∏–∞–ø–∞–∑–æ–Ω—ã –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Å—Ä–µ–∑–æ–≤ —Å—Ç—Ä–æ–∫ —Å –æ—Å—Ç–æ—Ä–æ–∂–Ω–æ—Å—Ç—å—é, –ø–æ—Ç–æ–º—É —á—Ç–æ —ç—Ç–æ –º–æ–∂–µ—Ç –ø—Ä–∏–≤–µ—Å—Ç–∏ –∫ —Å–±–æ—é –≤–∞—à–µ–π –ø—Ä–æ–≥—Ä–∞–º–º—ã.</p>
<h3 id="–ú–µ—Ç–æ–¥—ã-–¥–ª—è-–ø–µ—Ä–µ–±–æ—Ä–∞-—Å—Ç—Ä–æ–∫"><a class="header" href="#–ú–µ—Ç–æ–¥—ã-–¥–ª—è-–ø–µ—Ä–µ–±–æ—Ä–∞-—Å—Ç—Ä–æ–∫">–ú–µ—Ç–æ–¥—ã –¥–ª—è –ø–µ—Ä–µ–±–æ—Ä–∞ —Å—Ç—Ä–æ–∫</a></h3>
<p>–õ—É—á—à–∏–π —Å–ø–æ—Å–æ–± —Ä–∞–±–æ—Ç–∞—Ç—å —Å —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞–º–∏ —Å—Ç—Ä–æ–∫ ‚Äî —á—ë—Ç–∫–æ —É–∫–∞–∑–∞—Ç—å, –Ω—É–∂–Ω—ã –ª–∏ –≤–∞–º —Å–∏–º–≤–æ–ª—ã –∏–ª–∏ –±–∞–π—Ç—ã. –î–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–∏–º–≤–æ–ª–æ–≤ Unicode –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –º–µ—Ç–æ–¥ <code>chars</code>. –í—ã–∑–æ–≤ <code>chars</code> –Ω–∞ "–ó–¥" –≤—ã–¥–µ–ª–∏—Ç –∏ –≤–µ—Ä–Ω—ë—Ç –¥–≤–∞ –∑–Ω–∞—á–µ–Ω–∏—è —Ç–∏–ø–∞ <code>char</code>, –∏ –≤—ã –º–æ–∂–µ—Ç–µ –ø—Ä–æ–∏—Ç–µ—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è –ø–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ –∫–∞–∂–¥–æ–º—É —ç–ª–µ–º–µ–Ω—Ç—É:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for c in "–ó–¥".chars() {
    println!("{c}");
}
<span class="boring">}</span></code></pre></pre>
<p>–ö–æ–¥ –Ω–∞–ø–µ—á–∞—Ç–∞–µ—Ç —Å–ª–µ–¥—É—é—â–µ–µ:</p>
<pre><code class="language-text">–ó
–¥
</code></pre>
<p>–ï—Å–ª–∏ –∂–µ –≤–∞–º –Ω—É–∂–Ω—ã —Å—ã—Ä—ã–µ –±–∞–π—Ç—ã, –≤–∞–º –Ω—É–∂–µ–Ω –º–µ—Ç–æ–¥ <code>bytes</code>. –û–Ω –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –Ω–µ–ø–æ—Å—Ä–µ–¥—Å—Ç–≤–µ–Ω–Ω–æ –±–∞–π—Ç—ã, –∏ —ç—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø–æ–ª–µ–∑–Ω–æ –≤ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –∑–∞–¥–∞—á–∞—Ö:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for b in "–ó–¥".bytes() {
    println!("{b}");
}
<span class="boring">}</span></code></pre></pre>
<p>–≠—Ç–æ—Ç –∫–æ–¥ –≤—ã–≤–µ–¥–µ—Ç —á–µ—Ç—ã—Ä–µ –±–∞–π—Ç–∞, —Å–æ—Å—Ç–∞–≤–ª—è—é—â–∏—Ö —ç—Ç—É —Å—Ç—Ä–æ–∫—É:</p>
<pre><code class="language-text">208
151
208
180
</code></pre>
<p>–ù–æ –¥–µ–ª–∞—è —Ç–∞–∫, –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –ø–æ–º–Ω–∏—Ç–µ, —á—Ç–æ —Å–∏–º–≤–æ–ª—ã Unicode –º–æ–≥—É—Ç —Å–æ—Å—Ç–æ—è—Ç—å –±–æ–ª–µ–µ —á–µ–º –∏–∑ –æ–¥–Ω–æ–≥–æ –±–∞–π—Ç–∞.</p>
<p>–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –∫–ª–∞—Å—Ç–µ—Ä–æ–≤ –≥—Ä–∞—Ñ–µ–º –∏–∑ —Å—Ç—Ä–æ–∫, –∫–∞–∫ –≤ —Å–ª—É—á–∞–µ —Å –ø–∏—Å—å–º–æ–º –¥–µ–≤–∞–Ω–∞–≥–∞—Ä–∏, —è–≤–ª—è–µ—Ç—Å—è —Å–ª–æ–∂–Ω—ã–º, –ø–æ—ç—Ç–æ–º—É —ç—Ç–∞ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å –Ω–µ –ø—Ä–µ–¥—É—Å–º–æ—Ç—Ä–µ–Ω–∞ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–æ–π. –ù–∞ <a href="https://crates.io/">crates.io</a><!-- ignore --> –º–æ–∂–Ω–æ –Ω–∞–π—Ç–∏ –∫—Ä–µ–π—Ç—ã —Å –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–º–∏ –≤–∞–º –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞–º–∏.</p>
<h3 id="–°—Ç—Ä–æ–∫–∏-–Ω–µ-—Ç–∞–∫-–ø—Ä–æ—Å—Ç—ã"><a class="header" href="#–°—Ç—Ä–æ–∫–∏-–Ω–µ-—Ç–∞–∫-–ø—Ä–æ—Å—Ç—ã">–°—Ç—Ä–æ–∫–∏ –Ω–µ —Ç–∞–∫ –ø—Ä–æ—Å—Ç—ã</a></h3>
<p>–ü–æ–¥–≤–æ–¥—è –∏—Ç–æ–≥, —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è —è—Å–Ω–æ, —á—Ç–æ —Å—Ç—Ä–æ–∫–∏ —Å–ª–æ–∂–Ω—ã. –†–∞–∑–ª–∏—á–Ω—ã–µ —è–∑—ã–∫–∏ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è —Ä–µ–∞–ª–∏–∑—É—é—Ç —Å—Ç—Ä–æ–∫–∏ –ø–æ-—Å–≤–æ–µ–º—É, –∏ –≤—Å–µ ‚Äî –ø–æ-—Å–≤–æ–µ–º—É —Å–ª–æ–∂–Ω–æ. –í Rust —Ä–µ—à–∏–ª–∏ —Å–¥–µ–ª–∞—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É –¥–∞–Ω–Ω—ã—Ö <code>String</code> –ø–æ–≤–µ–¥–µ–Ω–∏–µ–º –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –¥–ª—è –≤—Å–µ—Ö –ø—Ä–æ–≥—Ä–∞–º–º Rust, —á—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç—ã –¥–æ–ª–∂–Ω—ã –∑–∞—Ä–∞–Ω–µ–µ –ø—Ä–æ–¥—É–º–∞—Ç—å –æ–±—Ä–∞–±–æ—Ç–∫—É —Ç–µ–∫—Å—Ç–∞ –≤ –∫–æ–¥–∏—Ä–æ–≤–∫–µ UTF-8. –≠—Ç–æ—Ç –∫–æ–º–ø—Ä–æ–º–∏—Å—Å —Ä–∞—Å–∫—Ä—ã–≤–∞–µ—Ç –±–æ–ª—å—à—É—é —Å–ª–æ–∂–Ω–æ—Å—Ç—å —Å—Ç—Ä–æ–∫, —á–µ–º –≤ –¥—Ä—É–≥–∏—Ö —è–∑—ã–∫–∞—Ö –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è, –Ω–æ —ç—Ç–æ –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç –æ—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –æ—à–∏–±–∫–∏, —Å–≤—è–∑–∞–Ω–Ω—ã–µ —Å –Ω–µ-ASCII —Å–∏–º–≤–æ–ª–∞–º–∏, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç –ø–æ—è–≤–∏—Ç—å—Å—è –ø–æ–∑–∂–µ –≤ —Ö–æ–¥–µ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏.</p>
<p>–•–æ—Ä–æ—à–∞—è –Ω–æ–≤–æ—Å—Ç—å —Å–æ—Å—Ç–æ–∏—Ç –≤ —Ç–æ–º, —á—Ç–æ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ –ø—Ä–µ–¥–ª–∞–≥–∞–µ—Ç –º–Ω–æ–∂–µ—Å—Ç–≤–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ –¥–ª—è —Ç–∏–ø–æ–≤ <code>String</code> –∏ <code>&amp;str</code>, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç –ø–æ–º–æ—á—å –ø—Ä–∞–≤–∏–ª—å–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å —ç—Ç–∏ —Å–ª–æ–∂–Ω—ã–µ —Å–∏—Ç—É–∞—Ü–∏–∏. –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –æ–∑–Ω–∞–∫–æ–º—å—Ç–µ—Å—å —Å –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–µ–π, —á—Ç–æ–±—ã —É–∑–Ω–∞—Ç—å –æ —Ç–∞–∫–∏—Ö –ø–æ–ª–µ–∑–Ω—ã—Ö –º–µ—Ç–æ–¥–∞—Ö, –∫–∞–∫ <code>contains</code> (–¥–ª—è –ø–æ–∏—Å–∫–∞ –≤ —Å—Ç—Ä–æ–∫–µ) –∏ <code>replace</code> (–¥–ª—è –∑–∞–º–µ–Ω—ã —á–∞—Å—Ç–µ–π —Å—Ç—Ä–æ–∫–∏ –¥—Ä—É–≥–æ–π —Å—Ç—Ä–æ–∫–æ–π).</p>
<p>–î–∞–≤–∞–π—Ç–µ –ø–µ—Ä–µ–∫–ª—é—á–∏–º—Å—è –Ω–∞ —á—Ç–æ-—Ç–æ –Ω–µ–º–Ω–æ–≥–æ –º–µ–Ω–µ–µ —Å–ª–æ–∂–Ω–æ–µ: —Ö–µ—à-—Ç–∞–±–ª–∏—Ü—ã!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–•—Ä–∞–Ω–µ–Ω–∏–µ-–ø–∞—Ä-–∫–ª—é—á-–∑–Ω–∞—á–µ–Ω–∏–µ-—Å-–ø–æ–º–æ—â—å—é-—Ö–µ—à-—Ç–∞–±–ª–∏—Ü"><a class="header" href="#–•—Ä–∞–Ω–µ–Ω–∏–µ-–ø–∞—Ä-–∫–ª—é—á-–∑–Ω–∞—á–µ–Ω–∏–µ-—Å-–ø–æ–º–æ—â—å—é-—Ö–µ—à-—Ç–∞–±–ª–∏—Ü">–•—Ä–∞–Ω–µ–Ω–∏–µ –ø–∞—Ä –∫–ª—é—á-–∑–Ω–∞—á–µ–Ω–∏–µ —Å –ø–æ–º–æ—â—å—é —Ö–µ—à-—Ç–∞–±–ª–∏—Ü</a></h2>
<p>–ü–æ—Å–ª–µ–¥–Ω–µ–π –∫–æ–ª–ª–µ–∫—Ü–∏–µ–π, –∫–æ—Ç–æ—Ä—É—é –º—ã —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º, –±—É–¥–µ—Ç —Ö–µ—à-—Ç–∞–±–ª–∏—Ü–∞. –¢–∏–ø <code>HashMap&lt;K, V&gt;</code> —Ö—Ä–∞–Ω–∏—Ç –∫–ª—é—á–∏ —Ç–∏–ø–∞ <code>K</code> –∫–æ –∑–Ω–∞—á–µ–Ω–∏—è–º —Ç–∏–ø–∞ <code>V</code>, –∏—Å–ø–æ–ª—å–∑—É—è <em>—Ñ—É–Ω–∫—Ü–∏—é —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è</em>. –í–æ –º–Ω–æ–∂–µ—Å—Ç–≤–µ —è–∑—ã–∫–æ–≤ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è –µ—Å—Ç—å –¥–∞–Ω–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞, –Ω–æ —á–∞—Å—Ç–æ –æ–Ω–∞ –ø–æ-—Ä–∞–∑–Ω–æ–º—É –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è: hash_, <em>map</em>, <em>object</em>, <em>—Å–ª–æ–≤–∞—Ä—å</em> –∏–ª–∏ <em>–∞—Å—Å–æ—Ü–∏–∞—Ç–∏–≤–Ω—ã–π –º–∞—Å—Å–∏–≤</em>.</p>
<p>–•–µ—à-—Ç–∞–±–ª–∏—Ü—ã –ø–æ–ª–µ–∑–Ω—ã, –∫–æ–≥–¥–∞ –Ω—É–∂–Ω–æ –∏—Å–∫–∞—Ç—å –¥–∞–Ω–Ω—ã–µ, –∏—Å–ø–æ–ª—å–∑—É—è –Ω–µ –∏–Ω–¥–µ–∫—Å (–∫–∞–∫ –≤ —Å–ª—É—á–∞–µ —Å –≤–µ–∫—Ç–æ—Ä–∞–º–∏), –∞ –∫–ª—é—á, –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–µ—Ç –±—ã—Ç—å –ª—é–±–æ–≥–æ —Ç–∏–ø–∞. –ù–∞–ø—Ä–∏–º–µ—Ä, –≤ –∏–≥—Ä–µ –≤—ã –º–æ–∂–µ—Ç–µ —Å–æ—Ö—Ä–∞–Ω—è—Ç—å —Å—á—ë—Ç –∫–∞–∂–¥–æ–π –∫–æ–º–∞–Ω–¥—ã –≤ —Ö–µ—à-—Ç–∞–±–ª–∏—Ü–µ, –≤ –∫–æ—Ç–æ—Ä–æ–π –∫–∞–∂–¥—ã–π –∫–ª—é—á ‚Äî —ç—Ç–æ –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–æ–º–∞–Ω–¥—ã, –∞ –∑–Ω–∞—á–µ–Ω–∏–µ ‚Äî –µ—ë —Å—á—ë—Ç. –ò–º–µ—è –∏–º—è –∫–æ–º–∞–Ω–¥—ã, –≤—ã –º–æ–∂–µ—Ç–µ –ø–æ–ª—É—á–∏—Ç—å –µ—ë —Å—á—ë—Ç –∏–∑ —Ö–µ—à-—Ç–∞–±–ª–∏—Ü—ã.</p>
<p>–í —ç—Ç–æ–º —Ä–∞–∑–¥–µ–ª–µ –º—ã —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º –ª–∏—à—å –æ—Å–Ω–æ–≤–Ω–æ–π API —Ö–µ—à-—Ç–∞–±–ª–∏—Ü, –Ω–æ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ —Å–æ–¥–µ—Ä–∂–∏—Ç –µ—â—ë –æ—á–µ–Ω—å –º–Ω–æ–≥–æ –ø–æ–ª–µ–∑–Ω–æ–≥–æ –¥–ª—è <code>HashMap&lt;K, V&gt;</code>. –ö–∞–∫ –∏ –ø—Ä–µ–∂–¥–µ, —Å–æ–≤–µ—Ç—É–µ–º –æ–±—Ä–∞—â–∞—Ç—å—Å—è –∫ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏.</p>
<h3 id="–°–æ–∑–¥–∞–Ω–∏–µ-—Ö–µ—à-—Ç–∞–±–ª–∏—Ü—ã"><a class="header" href="#–°–æ–∑–¥–∞–Ω–∏–µ-—Ö–µ—à-—Ç–∞–±–ª–∏—Ü—ã">–°–æ–∑–¥–∞–Ω–∏–µ —Ö–µ—à-—Ç–∞–±–ª–∏—Ü—ã</a></h3>
<p>One way to create an empty hash map is to use <code>new</code> and to add elements with <code>insert</code>. In Listing 8-20, we‚Äôre keeping track of the scores of two teams whose names are <em>Blue</em> and <em>Yellow</em>. The Blue team starts with 10 points, and the Yellow team starts with 50.</p>
<Listing number="8-20" caption="Creating a new hash map and inserting some keys and values">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("–°–∏–Ω—è—è"), 10);
    scores.insert(String::from("–ñ—ë–ª—Ç–∞—è"), 50);
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>–û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ —Å–Ω–∞—á–∞–ª–∞ –Ω—É–∂–Ω–æ –ø–æ–¥–∫–ª—é—á–∏—Ç—å <code>HashMap</code> –∏–∑ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ —Å –ø–æ–º–æ—â—å—é <code>use</code>. –ò–∑ —Ç—Ä—ë—Ö –∫–æ–ª–ª–µ–∫—Ü–∏–π –¥–∞–Ω–Ω–∞—è —è–≤–ª—è–µ—Ç—Å—è –Ω–∞–∏–º–µ–Ω–µ–µ –∏—Å–ø–æ–ª—å–∑—É–µ–º–æ–π, –ø–æ—ç—Ç–æ–º—É –æ–Ω–∞ –Ω–µ –≤—Ö–æ–¥–∏—Ç –≤ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª, –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –ø–æ–¥–∫–ª—é—á–∞–µ–º—ã–π –∫ –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏ (–∫–æ—Ä–æ—Ç–∫–æ –≥–æ–≤–æ—Ä—è, –≤ prelude). –•–µ—à-—Ç–∞–±–ª–∏—Ü—ã —Ç–∞–∫–∂–µ —Å–ª–∞–±–µ–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–æ–π; –Ω–∞–ø—Ä–∏–º–µ—Ä, –Ω–µ—Ç –≤—Å—Ç—Ä–æ–µ–Ω–Ω–æ–≥–æ –º–∞–∫—Ä–æ—Å–∞ –¥–ª—è –∏—Ö –∫–æ–Ω—Å—Ç—Ä—É–∏—Ä–æ–≤–∞–Ω–∏—è.</p>
<p>–ü–æ–¥–æ–±–Ω–æ –≤–µ–∫—Ç–æ—Ä–∞–º, —Ö–µ—à-—Ç–∞–±–ª–∏—Ü—ã —Ö—Ä–∞–Ω—è—Ç —Å–≤–æ–∏ –¥–∞–Ω–Ω—ã–µ –≤ –∫—É—á–µ. –ó–¥–µ—Å—å —Ç–∏–ø <code>HashMap</code> –∏–º–µ–µ—Ç –≤ –∫–∞—á–µ—Å—Ç–≤–µ —Ç–∏–ø–∞ –∫–ª—é—á–µ–π <code>String</code>, –∞ –≤ –∫–∞—á–µ—Å—Ç–≤–µ —Ç–∏–ø–∞ –∑–Ω–∞—á–µ–Ω–∏–π ‚Äî <code>i32</code>. –ö–∞–∫ –∏ –≤–µ–∫—Ç–æ—Ä—ã, <code>HashMap</code> –æ–¥–Ω–æ—Ä–æ–¥–Ω—ã: –≤—Å–µ –∫–ª—é—á–∏ –¥–æ–ª–∂–Ω—ã –∏–º–µ—Ç—å –æ–¥–∏–Ω–∞–∫–æ–≤—ã–π —Ç–∏–ø, –∏ –≤—Å–µ –∑–Ω–∞—á–µ–Ω–∏—è —Ç–æ–∂–µ –¥–æ–ª–∂–Ω—ã –∏–º–µ—Ç—å –æ–¥–∏–Ω–∞–∫–æ–≤—ã–π —Ç–∏–ø.</p>
<h3 id="–ü–æ–ª—É—á–µ–Ω–∏–µ-–¥–∞–Ω–Ω—ã—Ö-–∏–∑-—Ö–µ—à-—Ç–∞–±–ª–∏—Ü—ã"><a class="header" href="#–ü–æ–ª—É—á–µ–Ω–∏–µ-–¥–∞–Ω–Ω—ã—Ö-–∏–∑-—Ö–µ—à-—Ç–∞–±–ª–∏—Ü—ã">–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –∏–∑ —Ö–µ—à-—Ç–∞–±–ª–∏—Ü—ã</a></h3>
<p>–ú—ã –º–æ–∂–µ–º –ø–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ —Ö–µ—à-—Ç–∞–±–ª–∏—Ü—ã, –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–≤ –º–µ—Ç–æ–¥ <code>get</code> –∏ –ø–µ—Ä–µ–¥–∞–≤ –µ–º—É –∫–ª—é—á, –∫–∞–∫ –ø–æ–∫–∞–∑–∞–Ω–æ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 8-21.</p>
<Listing number="8-21" caption="Accessing the score for the Blue team stored in the hash map">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("–°–∏–Ω—è—è"), 10);
    scores.insert(String::from("–ñ—ë–ª—Ç–∞—è"), 50);

    let team_name = String::from("–°–∏–Ω—è—è");
    let score = scores.get(&amp;team_name).copied().unwrap_or(0);
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>–ó–¥–µ—Å—å –≤ <code>score</code> –±—É–¥–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—á–∫–æ–≤ —Å–∏–Ω–µ–π –∫–æ–º–∞–Ω–¥—ã ‚Äî <code>10</code>. –ú–µ—Ç–æ–¥ <code>get</code> –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç <code>Option&lt;&amp;V&gt;</code>; –µ—Å–ª–∏ –¥–ª—è –∫–∞–∫–æ–≥–æ-—Ç–æ –∫–ª—é—á–∞ –≤ —Ö–µ—à-—Ç–∞–±–ª–∏—Ü–µ –Ω–µ—Ç –∑–Ω–∞—á–µ–Ω–∏—è, <code>get</code> –≤–µ—Ä–Ω—ë—Ç <code>None</code>. –ò–∑-–∑–∞ —Ç–∞–∫–æ–≥–æ –ø–æ–¥—Ö–æ–¥–∞ –ø—Ä–æ–≥—Ä–∞–º–º–µ —Å–ª–µ–¥—É–µ—Ç –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å <code>Option</code>, –≤—ã–∑—ã–≤–∞—è <code>copied</code> –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è <code>Option&lt;i32&gt;</code> –≤–º–µ—Å—Ç–æ <code>Option&lt;&amp;i32&gt;</code>, –∑–∞—Ç–µ–º <code>unwrap_or</code> –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ <code>score</code> –≤ –Ω–æ–ª—å, –µ—Å–ª–∏ <code>scores</code> –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –¥–∞–Ω–Ω—ã—Ö –ø–æ —ç—Ç–æ–º—É –∫–ª—é—á—É.</p>
<p>–ú—ã –º–æ–∂–µ–º –ø–µ—Ä–µ–±–∏—Ä–∞—Ç—å –∫–∞–∂–¥—É—é –ø–∞—Ä—É –∫–ª—é—á-–∑–Ω–∞—á–µ–Ω–∏–µ –≤ —Ö–µ—à-—Ç–∞–±–ª–∏—Ü–µ —Ç–∞–∫–∏–º –∂–µ –æ–±—Ä–∞–∑–æ–º, –∫–∞–∫ –º—ã –¥–µ–ª–∞–ª–∏ —Å –≤–µ–∫—Ç–æ—Ä–∞–º–∏, –≤–æ—Å–ø–æ–ª—å–∑–æ–≤–∞–≤—à–∏—Å—å —Ü–∏–∫–ª–æ–º <code>for</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("–°–∏–Ω—è—è"), 10);
    scores.insert(String::from("–ñ—ë–ª—Ç–∞—è"), 50);

    for (key, value) in &amp;scores {
        println!("{key}: {value}");
    }
<span class="boring">}</span></code></pre></pre>
<p>–≠—Ç–æ—Ç –∫–æ–¥ –±—É–¥–µ—Ç –≤—ã–≤–µ–¥–µ—Ç –∫–∞–∂–¥—É—é –ø–∞—Ä—É –≤ –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ:</p>
<pre><code class="language-text">Yellow: 50
Blue: 10
</code></pre>
<h3 id="–•–µ—à-—Ç–∞–±–ª–∏—Ü—ã-–∏-–≤–ª–∞–¥–µ–Ω–∏–µ"><a class="header" href="#–•–µ—à-—Ç–∞–±–ª–∏—Ü—ã-–∏-–≤–ª–∞–¥–µ–Ω–∏–µ">–•–µ—à-—Ç–∞–±–ª–∏—Ü—ã –∏ –≤–ª–∞–¥–µ–Ω–∏–µ</a></h3>
<p>–î–ª—è —Ç–∏–ø–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ —Ä–µ–∞–ª–∏–∑—É—é—Ç —Ç—Ä–µ–π—Ç <code>Copy</code> (–Ω–∞–ø—Ä–∏–º–µ—Ä, <code>i32</code>), –∑–Ω–∞—á–µ–Ω–∏—è –∫–æ–ø–∏—Ä—É—é—Ç—Å—è –≤ —Ö–µ—à-—Ç–∞–±–ª–∏—Ü—É. –î–ª—è –≤–ª–∞–¥–µ–µ–º—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π, —Ç–∞–∫–∏—Ö –∫–∞–∫ <code>String</code>, –∑–Ω–∞—á–µ–Ω–∏—è –±—É–¥—É—Ç –ø–µ—Ä–µ–º–µ—â–µ–Ω—ã –≤ —Ö–µ—à-—Ç–∞–±–ª–∏—Ü—É –∏ –æ–Ω–∞ —Å—Ç–∞–Ω–µ—Ç –≤–ª–∞–¥–µ–ª—å—Ü–µ–º —ç—Ç–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π, —á—Ç–æ –ø–æ–∫–∞–∑–∞–Ω–æ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 8-22.</p>
<Listing number="8-22" caption="Showing that keys and values are owned by the hash map once they‚Äôre inserted">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let field_name = String::from("–õ—é–±–∏–º–∞—è –∫–æ–º–∞–Ω–¥–∞:");
    let field_value = String::from("–°–∏–Ω—è—è");

    let mut map = HashMap::new();
    map.insert(field_name, field_value);
    // field_name –∏ field_value –æ—Ç—Å—é–¥–∞ –∏ –¥–∞–ª–µ–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã. –ù–æ –≤—ã –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å
    // –∏—Ö –∏ –ø–æ—Å–º–æ—Ç—Ä–∏—Ç–µ, —á—Ç–æ –∑–∞ –æ—à–∏–±–∫—É –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –ø–æ–ª—É—á–∏—Ç–µ!
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>–ú—ã –Ω–µ –º–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ <code>field_name</code> –∏ <code>field_value</code> –ø–æ—Å–ª–µ —Ç–æ–≥–æ, –∫–∞–∫ –∏—Ö –∑–Ω–∞—á–µ–Ω–∏—è –±—ã–ª–∏ –ø–µ—Ä–µ–º–µ—â–µ–Ω—ã –≤ —Ö–µ—à-—Ç–∞–±–ª–∏—Ü—É –≤—ã–∑–æ–≤–æ–º –º–µ—Ç–æ–¥–∞ <code>insert</code>.</p>
<p>–ï—Å–ª–∏ –º—ã –≤—Å—Ç–∞–≤–∏–º –≤ —Ö–µ—à-—Ç–∞–±–ª–∏—Ü—É —Å—Å—ã–ª–∫–∏ –Ω–∞ –∑–Ω–∞—á–µ–Ω–∏—è, —Ç–æ –∑–Ω–∞—á–µ–Ω–∏—è –Ω–µ –±—É–¥—É—Ç –ø–µ—Ä–µ–º–µ—â–µ–Ω—ã –≤ —Ö–µ—à-—Ç–∞–±–ª–∏—Ü—É. –ó–Ω–∞—á–µ–Ω–∏—è, –Ω–∞ –∫–æ—Ç–æ—Ä—ã–µ —É–∫–∞–∑—ã–≤–∞—é—Ç —Å—Å—ã–ª–∫–∏, –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–º–∏ –∫–∞–∫ –º–∏–Ω–∏–º—É–º –ø–æ–∫–∞ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞ —Ö–µ—à-—Ç–∞–±–ª–∏—Ü–∞. –ú—ã –ø–æ–≥–æ–≤–æ—Ä–∏–º –ø–æ–¥—Ä–æ–±–Ω–µ–µ –æ–± —ç—Ç–∏—Ö –≤–æ–ø—Ä–æ—Å–∞—Ö –≤ —Ä–∞–∑–¥–µ–ª–µ <a href="ch10-03-lifetime-syntax.html#%D0%92%D0%B0%D0%BB%D0%B8%D0%B4%D0%B0%D1%86%D0%B8%D1%8F-%D1%81%D1%81%D1%8B%D0%BB%D0%BE%D0%BA-%D0%BF%D0%BE-%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%B8-%D0%B6%D0%B8%D0%B7%D0%BD%D0%B8">"–í–∞–ª–∏–¥–∞—Ü–∏—è —Å—Å—ã–ª–æ–∫ –ø–æ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏"</a><!-- ignore --> –ì–ª–∞–≤—ã 10.</p>
<h3 id="–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ-–¥–∞–Ω–Ω—ã—Ö-–≤-—Ö–µ—à-—Ç–∞–±–ª–∏—Ü–µ"><a class="header" href="#–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ-–¥–∞–Ω–Ω—ã—Ö-–≤-—Ö–µ—à-—Ç–∞–±–ª–∏—Ü–µ">–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –≤ —Ö–µ—à-—Ç–∞–±–ª–∏—Ü–µ</a></h3>
<p>–•–æ—Ç—è –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–ª—é—á–µ–π –∏ –∑–Ω–∞—á–µ–Ω–∏–π –≤ —Ö–µ—à-—Ç–∞–±–ª–∏—Ü–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –∏–∑–º–µ–Ω–µ–Ω–æ, –∫–∞–∂–¥—ã–π –∫–ª—é—á –≤ –æ–¥–∏–Ω –º–æ–º–µ–Ω—Ç –º–æ–∂–µ—Ç –∏–º–µ—Ç—å —Ç–æ–ª—å–∫–æ –æ–¥–Ω–æ –∑–Ω–∞—á–µ–Ω–∏–µ (–æ–±—Ä–∞—Ç–Ω–æ–µ —É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –Ω–µ–≤–µ—Ä–Ω–æ: –∫–æ–º–∞–Ω–¥—ã "–°–∏–Ω—è—è" –∏ "–ñ—ë–ª—Ç–∞—è" –º–æ–≥—É—Ç —Ö—Ä–∞–Ω–∏—Ç—å –≤ —Ö–µ—à-—Ç–∞–±–ª–∏—Ü–µ <code>scores</code> –æ–¥–∏–Ω–∞–∫–æ–≤–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—á–∫–æ–≤: –Ω–∞–ø—Ä–∏–º–µ—Ä, <code>10</code>).</p>
<p>–ï—Å–ª–∏ –≤—ã —Ö–æ—Ç–∏—Ç–µ –∏–∑–º–µ–Ω–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –≤ —Ö–µ—à-—Ç–∞–±–ª–∏—Ü–µ, –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —Ä–µ—à–∏—Ç—å, –∫–∞–∫ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å —Å–ª—É—á–∞–π, –∫–æ–≥–¥–∞ –∫–ª—é—á —É–∂–µ –∏–º–µ–µ—Ç —Å–≤—è–∑–∞–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ. –ú–æ–∂–Ω–æ –∑–∞–º–µ–Ω–∏—Ç—å —Å—Ç–∞—Ä–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–æ–≤—ã–º, –ø–æ–ª–Ω–æ—Å—Ç—å—é –ø—Ä–æ–∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–≤ —Å—Ç–∞—Ä–æ–µ. –ú–æ–∂–Ω–æ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å—Ç–∞—Ä–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∏ –ø—Ä–æ–∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å –Ω–æ–≤–æ–µ, –µ—Å–ª–∏ —Ç–æ–ª—å–∫–æ –≤ —Ö–µ—à-—Ç–∞–±–ª–∏—Ü–µ –µ—â—ë –Ω–µ –±—ã–ª–æ —ç—Ç–æ–≥–æ –∫–ª—é—á–∞. –ò–ª–∏ –º–æ–∂–Ω–æ –±—ã–ª–æ –±—ã –≤—ã—á–∏—Å–ª–∏—Ç—å –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å—Ç–∞—Ä–æ–≥–æ –∏ –Ω–æ–≤–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏–π —Ç—Ä–µ—Ç—å–µ. –î–∞–≤–∞–π—Ç–µ –ø–æ—Å–º–æ—Ç—Ä–∏–º, –∫–∞–∫ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –∫–∞–∂–¥—ã–π –∏–∑ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤!</p>
<h4 id="–ü–µ—Ä–µ–∑–∞–ø–∏—Å—å-–∑–Ω–∞—á–µ–Ω–∏—è"><a class="header" href="#–ü–µ—Ä–µ–∑–∞–ø–∏—Å—å-–∑–Ω–∞—á–µ–Ω–∏—è">–ü–µ—Ä–µ–∑–∞–ø–∏—Å—å –∑–Ω–∞—á–µ–Ω–∏—è</a></h4>
<p>–ï—Å–ª–∏ –º—ã –≤—Å—Ç–∞–≤–∏–º –∫–ª—é—á –∏ –∑–Ω–∞—á–µ–Ω–∏–µ –≤ —Ö–µ—à-—Ç–∞–±–ª–∏—Ü—É, –∞ –∑–∞—Ç–µ–º –≤—Å—Ç–∞–≤–∏–º —Ç–∞–∫–æ–π –∂–µ –∫–ª—é—á —Å –Ω–æ–≤—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º, —Ç–æ —Å—Ç–∞—Ä–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ, —Å–≤—è–∑–∞–Ω–Ω–æ–µ —Å —ç—Ç–∏–º –∫–ª—é—á–æ–º, –±—É–¥–µ—Ç –∑–∞–º–µ–Ω–µ–Ω–æ –Ω–∞ –Ω–æ–≤–æ–µ. –î–∞–∂–µ –Ω–µ—Å–º–æ—Ç—Ä—è –Ω–∞ —Ç–æ, —á—Ç–æ –∫–æ–¥ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 8-23 –≤—ã–∑—ã–≤–∞–µ—Ç <code>insert</code> –¥–≤–∞–∂–¥—ã, —Ö–µ—à-—Ç–∞–±–ª–∏—Ü–∞ –±—É–¥–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ç–æ–ª—å–∫–æ –æ–¥–Ω—É –ø–∞—Ä—É –∫–ª—é—á-–∑–Ω–∞—á–µ–Ω–∏–µ, –ø–æ—Ç–æ–º—É —á—Ç–æ –º—ã –≤—Å—Ç–∞–≤–ª—è–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è –æ–¥–Ω–æ–≥–æ –∏ —Ç–æ–≥–æ –∂–µ –∫–ª—é—á–∞ ‚Äî –∫–ª—é—á–∞ —Å–∏–Ω–µ–π –∫–æ–º–∞–Ω–¥—ã.</p>
<Listing number="8-23" caption="Replacing a value stored with a particular key">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("–°–∏–Ω—è—è"), 10);
    scores.insert(String::from("–°–∏–Ω—è—è"), 25);

    println!("{scores:?}");
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>–ö–æ–¥ –Ω–∞–ø–µ—á–∞—Ç–∞–µ—Ç <code>{"–°–∏–Ω—è—è": 25}</code>. –ù–∞—á–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ <code>10</code> –±—ã–ª–æ –ø–µ—Ä–µ–∑–∞–ø–∏—Å–∞–Ω–æ.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="only-inserting-a-value-if-the-key-has-no-value"></a></p>
<h4 id="–í—Å—Ç–∞–≤–∫–∞-–∑–Ω–∞—á–µ–Ω–∏—è-—Ç–æ–ª—å–∫–æ-–≤-—Ç–æ–º-—Å–ª—É—á–∞–µ-–µ—Å–ª–∏-–∫–ª—é—á-–≤–≤–æ–¥–∏—Ç—Å—è-–≤–ø–µ—Ä–≤—ã–µ"><a class="header" href="#–í—Å—Ç–∞–≤–∫–∞-–∑–Ω–∞—á–µ–Ω–∏—è-—Ç–æ–ª—å–∫–æ-–≤-—Ç–æ–º-—Å–ª—É—á–∞–µ-–µ—Å–ª–∏-–∫–ª—é—á-–≤–≤–æ–¥–∏—Ç—Å—è-–≤–ø–µ—Ä–≤—ã–µ">–í—Å—Ç–∞–≤–∫–∞ –∑–Ω–∞—á–µ–Ω–∏—è —Ç–æ–ª—å–∫–æ –≤ —Ç–æ–º —Å–ª—É—á–∞–µ, –µ—Å–ª–∏ –∫–ª—é—á –≤–≤–æ–¥–∏—Ç—Å—è –≤–ø–µ—Ä–≤—ã–µ</a></h4>
<p>–û–±—ã—á–Ω–æ –ø—Ä–æ–≤–µ—Ä—è—é—Ç, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –∫–ª—é—á –≤ —Ö–µ—à-—Ç–∞–±–ª–∏—Ü–µ, –ø—Ä–∏–ø–∏—Å–∞–Ω–æ –ª–∏ –µ–º—É –∫–∞–∫–æ–µ-–ª–∏–±–æ –∑–Ω–∞—á–µ–Ω–∏–µ, –∞ –∑–∞—Ç–µ–º –ø—Ä–µ–¥–ø—Ä–∏–Ω–∏–º–∞—é—Ç—Å—è —Å–ª–µ–¥—É—é—â–∏–µ –¥–µ–π—Å—Ç–≤–∏—è: –µ—Å–ª–∏ –∫–ª—é—á –≤ —Ö–µ—à-—Ç–∞–±–ª–∏—Ü–µ –µ—Å—Ç—å, —Ç–æ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –æ—Å—Ç–∞–≤–∞—Ç—å—Å—è —Ç–∞–∫–∏–º, –∫–∞–∫–æ–µ –æ–Ω–æ –µ—Å—Ç—å. –ï—Å–ª–∏ –∂–µ –∫–ª—é—á –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç, —Ç–æ –≤—Å—Ç–∞–≤–ª—è—é—Ç –µ–≥–æ –∏ –µ–≥–æ –∑–Ω–∞—á–µ–Ω–∏–µ.</p>
<p>–•–µ—à-—Ç–∞–±–ª–∏—Ü—ã –∏–º–µ—é—Ç –¥–ª—è —ç—Ç–æ–≥–æ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ <code>entry</code>, –∫–æ—Ç–æ—Ä—ã–π –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –∫–ª—é—á, –Ω–∞–ª–∏—á–∏–µ –∫–æ—Ç–æ—Ä–æ–≥–æ –Ω—É–∂–Ω–æ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å. –í–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –º–µ—Ç–æ–¥–∞ <code>entry</code> ‚Äî —ç—Ç–æ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ <code>Entry</code>, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—â–µ–≥–æ –∑–Ω–∞—á–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –º–æ–∂–µ—Ç –∫–∞–∫ –ø—Ä–∏—Å—É—Ç—Å—Ç–≤–æ–≤–∞—Ç—å, —Ç–∞–∫ –∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–æ–≤–∞—Ç—å. –î–æ–ø—É—Å—Ç–∏–º, –º—ã —Ö–æ—Ç–∏–º –ø—Ä–æ–≤–µ—Ä–∏—Ç—å, –∏–º–µ–µ—Ç—Å—è –ª–∏ –∫–ª—é—á –∏ —Å–≤—è–∑–∞–Ω–Ω–æ–µ —Å –Ω–∏–º –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –∂—ë–ª—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã. –ï—Å–ª–∏ —Ö–µ—à-—Ç–∞–±–ª–∏—Ü–∞ –Ω–µ –∏–º–µ–µ—Ç –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è —Ç–∞–∫–æ–≥–æ –∫–ª—é—á–∞, —Ç–æ –º—ã —Ö–æ—Ç–∏–º –≤—Å—Ç–∞–≤–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ <code>50</code>. –¢–æ –∂–µ —Å–∞–º–æ–µ –º—ã —Ö–æ—Ç–∏–º –ø—Ä–æ–¥–µ–ª–∞—Ç—å –∏ –¥–ª—è —Å–∏–Ω–µ–π –∫–æ–º–∞–Ω–¥—ã. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ <code>entry</code> –ø–æ–∫–∞–∑–∞–Ω–æ –≤ –∫–æ–¥–µ –õ–∏—Å—Ç–∏–Ω–≥–∞ 8-24.</p>
<Listing number="8-24" caption="Using the `entry` method to only insert if the key does not already have a value">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();
    scores.insert(String::from("–°–∏–Ω—è—è"), 10);

    scores.entry(String::from("–ñ—ë–ª—Ç–∞—è")).or_insert(50);
    scores.entry(String::from("–°–∏–Ω—è—è")).or_insert(50);

    println!("{scores:?}");
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>–ú–µ—Ç–æ–¥ <code>or_insert</code> –æ–ø—Ä–µ–¥–µ–ª—ë–Ω –≤ <code>Entry</code> —Ç–∞–∫, —á—Ç–æ–±—ã –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å –∏–∑–º–µ–Ω—è–µ–º—É—é —Å—Å—ã–ª–∫—É –Ω–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∫–ª—é—á–∞ –≤–Ω—É—Ç—Ä–∏ –≤–∞—Ä–∏–∞–Ω—Ç–∞ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è <code>Entry</code>, –∫–æ–≥–¥–∞ —ç—Ç–æ—Ç –∫–ª—é—á —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –∞ –µ—Å–ª–∏ –µ–≥–æ –Ω–µ—Ç, —Ç–æ –≤—Å—Ç–∞–≤–ª—è—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä –≤ –∫–∞—á–µ—Å—Ç–≤–µ –Ω–æ–≤–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è —ç—Ç–æ–≥–æ –∫–ª—é—á–∞ –∏ –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å –∏–∑–º–µ–Ω—è–µ–º—É—é —Å—Å—ã–ª–∫—É –Ω–∞ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ. –≠—Ç–∞ —Ç–µ—Ö–Ω–∏–∫–∞ –Ω–∞–º–Ω–æ–≥–æ —á–∏—â–µ, —á–µ–º —Å–∞–º–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω–æ–µ –Ω–∞–ø–∏—Å–∞–Ω–∏–µ –ª–æ–≥–∏–∫–∏ –∏, –∫—Ä–æ–º–µ —Ç–æ–≥–æ, –æ–Ω–∞ –±–æ–ª–µ–µ –±–µ–∑–æ–ø–∞—Å–Ω–∞ –∏ —Å–æ–≥–ª–∞—Å—É–µ—Ç—Å—è —Å –ø—Ä–∞–≤–∏–ª–∞–º–∏ –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏—è.</p>
<p>–ü—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –∫–æ–¥–∞ –õ–∏—Å—Ç–∏–Ω–≥–∞ 8-24 –±—É–¥–µ—Ç –Ω–∞–ø–µ—á–∞—Ç–∞–Ω–æ <code>{"–ñ—ë–ª—Ç–∞—è": 50, "–°–∏–Ω—è—è": 10}</code>. –ü–µ—Ä–≤—ã–π –≤—ã–∑–æ–≤ –º–µ—Ç–æ–¥–∞ <code>entry</code> –≤—Å—Ç–∞–≤–∏—Ç –∫–ª—é—á —Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º <code>50</code> –¥–ª—è –∂—ë–ª—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã, –ø–æ—Ç–æ–º—É —á—Ç–æ –¥–ª—è –∂—ë–ª—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã –µ—â—ë –Ω–µ –∏–º–µ–µ—Ç—Å—è –∑–Ω–∞—á–µ–Ω–∏—è –≤ —Ö–µ—à-—Ç–∞–±–ª–∏—Ü–µ. –í—Ç–æ—Ä–æ–π –≤—ã–∑–æ–≤ <code>entry</code> –Ω–µ –∏–∑–º–µ–Ω–∏—Ç —Ö–µ—à-—Ç–∞–±–ª–∏—Ü—É, –ø–æ—Ç–æ–º—É —á—Ç–æ –¥–ª—è –∫–ª—é—á–∞ —Å–∏–Ω–µ–π –∫–æ–º–∞–Ω–¥—ã —É–∂–µ –∏–º–µ–µ—Ç—Å—è –∑–Ω–∞—á–µ–Ω–∏–µ <code>10</code>.</p>
<h4 id="–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ-–∑–Ω–∞—á–µ–Ω–∏—è-–Ω–∞-–æ—Å–Ω–æ–≤–µ-—Å—Ç–∞—Ä–æ–≥–æ-–∑–Ω–∞—á–µ–Ω–∏—è"><a class="header" href="#–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ-–∑–Ω–∞—á–µ–Ω–∏—è-–Ω–∞-–æ—Å–Ω–æ–≤–µ-—Å—Ç–∞—Ä–æ–≥–æ-–∑–Ω–∞—á–µ–Ω–∏—è">–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å—Ç–∞—Ä–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è</a></h4>
<p>–î—Ä—É–≥–∏–º —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—ë–Ω–Ω—ã–º –≤–∞—Ä–∏–∞–Ω—Ç–æ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Ö–µ—à-—Ç–∞–±–ª–∏—Ü —è–≤–ª—è–µ—Ç—Å—è –ø–æ–∏—Å–∫ –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ –∫–ª—é—á—É, –∞ –∑–∞—Ç–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —ç—Ç–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å—Ç–∞—Ä–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è. –ù–∞–ø—Ä–∏–º–µ—Ä, –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 8-25 –ø–æ–∫–∞–∑–∞–Ω –∫–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –ø–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ—Ç, —Å–∫–æ–ª—å–∫–æ —Ä–∞–∑ –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–µ —Å–ª–æ–≤–æ –≤—Å—Ç—Ä–µ—á–∞–µ—Ç—Å—è –≤ –Ω–µ–∫–æ—Ç–æ—Ä–æ–º —Ç–µ–∫—Å—Ç–µ. –ú—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ö–µ—à-—Ç–∞–±–ª–∏—Ü—É —Å–æ —Å–ª–æ–≤–∞–º–∏ –≤ –∫–∞—á–µ—Å—Ç–≤–µ –∫–ª—é—á–µ–π –∏ —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π —Å–ª–æ–≤—É —Å—á—ë—Ç—á–∏–∫, —á—Ç–æ–±—ã –æ—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å, —Å–∫–æ–ª—å–∫–æ —Ä–∞–∑ –º—ã –≤—Å—Ç—Ä–µ—Ç–∏–ª–∏ —ç—Ç–æ —Å–ª–æ–≤–æ. –ï—Å–ª–∏ –º—ã –≤–ø–µ—Ä–≤—ã–µ –≤—Å—Ç—Ä–µ—Ç–∏–ª–∏ —Å–ª–æ–≤–æ, —Ç–æ —Å–Ω–∞—á–∞–ª–∞ –≤—Å—Ç–∞–≤–ª—è–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ <code>0</code>.</p>
<Listing number="8-25" caption="Counting occurrences of words using a hash map that stores words and counts">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let text = "hello world wonderful world";

    let mut map = HashMap::new();

    for word in text.split_whitespace() {
        let count = map.entry(word).or_insert(0);
        *count += 1;
    }

    println!("{map:?}");
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>–≠—Ç–æ—Ç –∫–æ–¥ –Ω–∞–ø–µ—á–∞—Ç–∞–µ—Ç <code>{"world": 2, "hello": 1, "wonderful": 1}</code>. –ï—Å–ª–∏ –≤—ã —É–≤–∏–¥–∏—Ç–µ, —á—Ç–æ –ø–∞—Ä—ã –∫–ª—é—á-–∑–Ω–∞—á–µ–Ω–∏–µ –ø–µ—á–∞—Ç–∞—é—Ç—Å—è –≤ –¥—Ä—É–≥–æ–º –ø–æ—Ä—è–¥–∫–µ, —Ç–æ –≤—Å–ø–æ–º–Ω–∏—Ç–µ, —á—Ç–æ –≤ —Ä–∞–∑–¥–µ–ª–µ <a href="ch08-03-hash-maps.html#%D0%9F%D0%BE%D0%BB%D1%83%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%B8%D0%B7-%D1%85%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%8B">"–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –∏–∑ —Ö–µ—à-—Ç–∞–±–ª–∏—Ü—ã"</a><!-- ignore --> –º—ã –ø–∏—Å–∞–ª–∏, —á—Ç–æ –∏—Ç–µ—Ä–∞—Ü–∏—è –ø–æ —Ö–µ—à-—Ç–∞–±–ª–∏—Ü–µ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –≤ –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ.</p>
<p>–ú–µ—Ç–æ–¥ <code>split_whitespace</code>, –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã–π –Ω–∞ <code>text</code>, –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∏—Ç–µ—Ä–∞—Ç–æ—Ä –ø–æ –ø–æ–¥—Å—Ä–µ–∑–∞–º —Å—Ç—Ä–æ–∫–∏, —Ä–∞–∑–¥–µ–ª—ë–Ω–Ω—ã–º –ø—Ä–æ–±–µ–ª–∞–º–∏. –ú–µ—Ç–æ–¥ <code>or_insert</code> –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∏–∑–º–µ–Ω—è–µ–º—É—é —Å—Å—ã–ª–∫—É (<code>&amp;mut V</code>) –Ω–∞ –∑–Ω–∞—á–µ–Ω–∏–µ –∫–ª—é—á–∞. –ú—ã —Å–æ—Ö—Ä–∞–Ω—è–µ–º –∏–∑–º–µ–Ω—è–µ–º—É—é —Å—Å—ã–ª–∫—É –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π <code>count</code>, –ø–æ—ç—Ç–æ–º—É —á—Ç–æ–±—ã –ø—Ä–∏—Å–≤–æ–∏—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –∑–Ω–∞—á–µ–Ω–∏–µ, –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —Ä–∞–∑—ã–º–µ–Ω–æ–≤–∞—Ç—å <code>count</code> —Å –ø–æ–º–æ—â—å—é –∑–≤—ë–∑–¥–æ—á–∫–∏ (<code>*</code>). –ò–∑–º–µ–Ω—è–µ–º–∞—è —Å—Å—ã–ª–∫–∞ —É–¥–∞–ª—è–µ—Ç—Å—è —Å—Ä–∞–∑—É –∂–µ –ø–æ—Å–ª–µ –≤—ã—Ö–æ–¥–∞ –∏–∑ –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏ —Ü–∏–∫–ª–∞ <code>for</code>, –ø–æ—ç—Ç–æ–º—É –≤—Å–µ —ç—Ç–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è –±–µ–∑–æ–ø–∞—Å–Ω—ã –∏ —Å–æ–≥–ª–∞—Å—É—é—Ç—Å—è —Å –ø—Ä–∞–≤–∏–ª–∞–º–∏ –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏—è.</p>
<h3 id="–§—É–Ω–∫—Ü–∏–∏-—Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è"><a class="header" href="#–§—É–Ω–∫—Ü–∏–∏-—Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è">–§—É–Ω–∫—Ü–∏–∏ —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è</a></h3>
<p>–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é <code>HashMap</code> –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —Ñ—É–Ω–∫—Ü–∏—é —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è <em>SipHash</em>, –∫–æ—Ç–æ—Ä–∞—è –º–æ–∂–µ—Ç –ø—Ä–æ—Ç–∏–≤–æ—Å—Ç–æ—è—Ç—å –∞—Ç–∞–∫–∞–º –∫–ª–∞—Å—Å–∞ Denial of Service (DoS) —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º —Ö–µ—à-—Ç–∞–±–ª–∏—Ü<sup class="footnote-reference"><a href="#siphash">1</a></sup><!-- ignore -->. –≠—Ç–æ –Ω–µ —Å–∞–º—ã–π –±—ã—Å—Ç—Ä—ã–π –∏–∑ –≤–æ–∑–º–æ–∂–Ω—ã—Ö –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è, –Ω–æ –≤ –¥–∞–Ω–Ω–æ–º —Å–ª—É—á–∞–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∏–¥—ë—Ç –Ω–∞ –∫–æ–º–ø—Ä–æ–º–∏—Å—Å —Å –æ–±–µ—Å–ø–µ—á–µ–Ω–∏–µ–º –ª—É—á—à–µ–π –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏. –ï—Å–ª–∏ –ø–æ—Å–ª–µ –ø—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏—è –≤–∞—à–µ–≥–æ –∫–æ–¥–∞ –æ–∫–∞–∂–µ—Ç—Å—è, —á—Ç–æ —Ö–µ—à-—Ñ—É–Ω–∫—Ü–∏—è, –∏—Å–ø–æ–ª—å–∑—É–µ–º–∞—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, –æ—á–µ–Ω—å –º–µ–¥–ª–µ–Ω–Ω–∞—è, –≤—ã –º–æ–∂–µ—Ç–µ –∑–∞–º–µ–Ω–∏—Ç—å –µ—ë –∏—Å–ø–æ–ª—å–∑—É—è –¥—Ä—É–≥–æ–π —Ö–µ—à–µ—Ä. <em>–•–µ—à–µ—Ä</em> ‚Äî —ç—Ç–æ —Ç–∏–ø, —Ä–µ–∞–ª–∏–∑—É—é—â–∏–π —Ç—Ä–µ–π—Ç <code>BuildHasher</code>. –ü–æ–¥—Ä–æ–±–Ω–µ–µ –æ —Ç—Ä–µ–π—Ç–∞—Ö –º—ã –ø–æ–≥–æ–≤–æ—Ä–∏–º –≤ <a href="ch10-02-traits.html">–ì–ª–∞–≤–µ 10</a><!-- ignore -->. –í–∞–º —Å–æ–≤—Å–µ–º –Ω–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤—ã–≤–∞—Ç—å —Å–≤–æ—é —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è; –Ω–∞ <a href="https://crates.io/">crates.io</a><!-- ignore --> –µ—Å—Ç—å –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –±–∏–±–ª–∏–æ—Ç–µ–∫, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è—é—â–∏—Ö —Ä–∞–∑–Ω—ã–µ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ —Ö–µ—à–µ—Ä–æ–≤ —Å –º–Ω–æ–∂–µ—Å—Ç–≤–æ–º –æ–±—â–∏—Ö –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è.</p>
<div class="footnote-definition" id="siphash"><sup class="footnote-definition-label">1</sup>
<p><a href="https://en.wikipedia.org/wiki/SipHash">https://en.wikipedia.org/wiki/SipHash</a></p>
</div>
<h2 id="–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-7"><a class="header" href="#–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-7">–ü–æ–¥–≤–µ–¥—ë–º –∏—Ç–æ–≥–∏</a></h2>
<p>–í–µ–∫—Ç–æ—Ä—ã, —Å—Ç—Ä–æ–∫–∏ –∏ —Ö–µ—à-—Ç–∞–±–ª–∏—Ü—ã –ø—Ä–µ–¥–æ—Å—Ç–∞–≤—è—Ç –±–æ–ª—å—à–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª–∞ –¥–ª—è –ø—Ä–æ–≥—Ä–∞–º–º, –∫–æ–≥–¥–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —Å–æ—Ö—Ä–∞–Ω—è—Ç—å, –∏–∑–≤–ª–µ–∫–∞—Ç—å –∏ –º–æ–¥–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞—Ç—å –¥–∞–Ω–Ω—ã–µ. –¢–µ–ø–µ—Ä—å –≤—ã –≥–æ—Ç–æ–≤—ã —Ä–µ—à–∏—Ç—å —Å–ª–µ–¥—É—é—â–∏–µ —É—á–µ–±–Ω—ã–µ –∑–∞–¥–∞–Ω–∏—è:</p>
<ol>
<li>–î–∞–Ω —Å–ø–∏—Å–æ–∫ —Ü–µ–ª—ã—Ö —á–∏—Å–µ–ª. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–≤ –≤–µ–∫—Ç–æ—Ä, –Ω–∞–ø–∏—à–∏—Ç–µ —Ñ—É–Ω–∫—Ü–∏–∏ –ø–æ–ª—É—á–µ–Ω–∏—è –º–µ–¥–∏–∞–Ω—ã (–∑–Ω–∞—á–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–∞ –∏–∑ —Å–µ—Ä–µ–¥–∏–Ω—ã —Å–ø–∏—Å–∫–∞ –ø–æ—Å–ª–µ –µ–≥–æ —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏) –∏ –º–æ–¥—ã (–Ω–∞–∏–±–æ–ª–µ–µ —á–∞—Å—Ç–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ; –ø–æ–¥—Å–∫–∞–∑–∫–∞: –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ö–µ—à-—Ç–∞–±–ª–∏—Ü—ã) —Å–ø–∏—Å–∫–∞ —á–∏—Å–µ–ª.</li>
<li>–ü–µ—Ä–µ–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç —Å –∞–Ω–≥–ª–∏–π—Å–∫–æ–≥–æ –Ω–∞ –ø–æ—Ä–æ—Å—è—á—å—é –ª–∞—Ç—ã–Ω—å. –ü–µ—Ä–≤–∞—è —Å–æ–≥–ª–∞—Å–Ω–∞—è –∫–∞–∂–¥–æ–≥–æ —Å–ª–æ–≤–∞ –ø–µ—Ä–µ–º–µ—â–∞–µ—Ç—Å—è –≤ –∫–æ–Ω–µ—Ü –∏ –∫ –Ω–µ–π –¥–æ–±–∞–≤–ª—è–µ—Ç—Å—è –æ–∫–æ–Ω—á–∞–Ω–∏–µ <em>ay</em> (–ø—Ä–∏–º–µ—Ä: <em>first</em> —Å—Ç–∞–Ω–µ—Ç <em>irst-fay</em>). –ö —Å–ª–æ–≤—É, –Ω–∞—á–∏–Ω–∞—é—â–µ–º—É—Å—è –Ω–∞ –≥–ª–∞—Å–Ω—É—é, –≤ –∫–æ–Ω–µ—Ü –¥–æ–±–∞–≤–ª—è–µ—Ç—Å—è <em>hay</em> (–ø—Ä–∏–º–µ—Ä: <em>apple</em> —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è <em>apple-hay</em>). –ü–æ–º–Ω–∏—Ç–µ –æ –¥–µ—Ç–∞–ª—è—Ö —Ä–∞–±–æ—Ç—ã —Å –∫–æ–¥–∏—Ä–æ–≤–∫–æ–π UTF-8!</li>
<li>–ò—Å–ø–æ–ª—å–∑—É—è —Ö–µ—à-—Ç–∞–±–ª–∏—Ü—É –∏ –≤–µ–∫—Ç–æ—Ä—ã, —Å–æ–∑–¥–∞–π—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å, –ø–æ–∑–≤–æ–ª—è—é—â–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –ø—Ä–∏–ø–∏—Å—ã–≤–∞—Ç—å —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤ –ø–æ –∏—Ö –∏–º–µ–Ω–∞–º –∫ –æ—Ç–¥–µ–ª–∞–º –∫–æ–º–ø–∞–Ω–∏–∏. –ù–∞–ø—Ä–∏–º–µ—Ä, <code>Add Sally to Engineering</code> –∏–ª–∏ <code>Add Amir to Sales</code>. –ó–∞—Ç–µ–º –ø–æ–∑–≤–æ–ª—å—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –ª—é–¥–µ–π –∏–∑ –æ—Ç–¥–µ–ª–∞ –∏–ª–∏ –≤—Å–µ—Ö –ª—é–¥–µ–π –≤ –∫–æ–º–ø–∞–Ω–∏–∏, –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ –æ—Ç–¥–µ–ª–∞–º –≤ –∞–ª—Ñ–∞–≤–∏—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ.</li>
</ol>
<p>–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è API —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ —Å–æ–¥–µ—Ä–∂–∏—Ç –æ–ø–∏—Å–∞–Ω–∏—è –º–µ—Ç–æ–¥–æ–≤ –≤–µ–∫—Ç–æ—Ä–æ–≤, —Å—Ç—Ä–æ–∫ –∏ —Ö–µ—à-—Ç–∞–±–ª–∏—Ü. –†–µ–∫–æ–º–µ–Ω–¥—É–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –µ–π –ø—Ä–∏ —Ä–µ—à–µ–Ω–∏–∏ —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–π!</p>
<p>–ü–æ—Ç–∏—Ö–æ–Ω—å–∫—É –º—ã –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω—ã–º –ø—Ä–æ–≥—Ä–∞–º–º–∞–º, –≤ –∫–æ—Ç–æ—Ä—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–∏ –º–æ–≥—É—Ç –ø–æ—Ç–µ—Ä–ø–µ—Ç—å –Ω–µ—É–¥–∞—á—É. –ù–∞—Å—Ç—É–ø–∏–ª –∏–¥–µ–∞–ª—å–Ω—ã–π –º–æ–º–µ–Ω—Ç –¥–ª—è –æ–±—Å—É–∂–¥–µ–Ω–∏—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="–û–±—Ä–∞–±–æ—Ç–∫–∞-–æ—à–∏–±–æ–∫"><a class="header" href="#–û–±—Ä–∞–±–æ—Ç–∫–∞-–æ—à–∏–±–æ–∫">–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫</a></h1>
<p>–í–æ–∑–Ω–∏–∫–Ω–æ–≤–µ–Ω–∏–µ –æ—à–∏–±–æ–∫ –≤ —Ö–æ–¥–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –ø—Ä–æ–≥—Ä–∞–º–º ‚Äî —ç—Ç–æ —Å—É—Ä–æ–≤–∞—è —Ä–µ–∞–ª—å–Ω–æ—Å—Ç—å –∂–∏–∑–Ω–∏. –í Rust –µ—Å—Ç—å —Ä—è–¥ —Ñ—É–Ω–∫—Ü–∏–π –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–∏—Ç—É–∞—Ü–∏–π, –∫–æ–≥–¥–∞ —á—Ç–æ-—Ç–æ –∏–¥—ë—Ç –Ω–µ —Ç–∞–∫. –í–æ –º–Ω–æ–≥–∏—Ö —Å–ª—É—á–∞—è—Ö Rust —Ç—Ä–µ–±—É–µ—Ç, —á—Ç–æ–±—ã –≤—ã –ø—Ä–∏–∑–Ω–∞–ª–∏ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –æ—à–∏–±–∫–∏ –∏ –ø—Ä–µ–¥–ø—Ä–∏–Ω—è–ª–∏ –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –¥–µ–π—Å—Ç–≤–∏—è, –ø—Ä–µ–∂–¥–µ —á–µ–º –≤–∞—à –∫–æ–¥ –±—É–¥–µ—Ç —Å–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞–Ω. –≠—Ç–æ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏–µ –¥–µ–ª–∞–µ—Ç –≤–∞—à—É –ø—Ä–æ–≥—Ä–∞–º–º—É –±–æ–ª–µ–µ –Ω–∞–¥—ë–∂–Ω–æ–π, –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É—è, —á—Ç–æ –≤—ã –æ–±–Ω–∞—Ä—É–∂–∏—Ç–µ –æ—à–∏–±–∫–∏ –∏ –æ–±—Ä–∞–±–æ—Ç–∞–µ—Ç–µ –∏—Ö –Ω–∞–¥–ª–µ–∂–∞—â–∏–º –æ–±—Ä–∞–∑–æ–º, –ø—Ä–µ–∂–¥–µ —á–µ–º –¥–∞–¥–∏—Ç–µ –∫–æ–¥ –∫–æ–Ω–µ—á–Ω—ã–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º!</p>
<p>–í Rust –æ—à–∏–±–∫–∏ —Ñ–æ—Ä–º–∏—Ä—É—é—Ç –¥–≤–µ –æ—Å–Ω–æ–≤–Ω—ã–µ –≥—Ä—É–ø–ø—ã: <em>–∏—Å–ø—Ä–∞–≤–∏–º—ã–µ</em> –∏ <em>–Ω–µ–∏—Å–ø—Ä–∞–≤–∏–º—ã–µ</em>. –í —Å–ª—É—á–∞–µ –∏—Å–ø—Ä–∞–≤–∏–º–æ–π –æ—à–∏–±–∫–∏, —Ç–∞–∫–æ–π –∫–∞–∫ <em>file not found</em>, –º—ã, —Å–∫–æ—Ä–µ–µ –≤—Å–µ–≥–æ, –ø—Ä–æ—Å—Ç–æ —Ö–æ—Ç–∏–º —Å–æ–æ–±—â–∏—Ç—å –æ –ø—Ä–æ–±–ª–µ–º–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –∏ –ø–æ–≤—Ç–æ—Ä–∏—Ç—å –æ–ø–µ—Ä–∞—Ü–∏—é. –ù–µ–∏—Å–ø—Ä–∞–≤–∏–º—ã–µ –æ—à–∏–±–∫–∏ –≤—Å–µ–≥–¥–∞ —è–≤–ª—è—é—Ç—Å—è —Å–∏–º–ø—Ç–æ–º–∞–º–∏ –¥–µ—Ñ–µ–∫—Ç–æ–≤ –ø—Ä–æ–≥—Ä–∞–º–º—ã: –Ω–∞–ø—Ä–∏–º–µ—Ä, –ø–æ–ø—ã—Ç–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ —ç–ª–µ–º–µ–Ω—Ç—É –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ –≥—Ä–∞–Ω–∏—Ü –º–∞—Å—Å–∏–≤–∞, –∫–æ—Ç–æ—Ä–∞—è –≤—ã–Ω—É–∂–¥–∞–µ—Ç –Ω–∞—Å –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø—Ä–æ–≥—Ä–∞–º–º—É.</p>
<p>–ë–æ–ª—å—à–∏–Ω—Å—Ç–≤–æ —è–∑—ã–∫–æ–≤ –Ω–µ —Ä–∞–∑–ª–∏—á–∞—é—Ç —ç—Ç–∏ –¥–≤–∞ –≤–∏–¥–∞ –æ—à–∏–±–æ–∫ –∏ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç –∏—Ö –æ–¥–∏–Ω–∞–∫–æ–≤–æ, –∏—Å–ø–æ–ª—å–∑—É—è —Ç–∞–∫–∏–µ –º–µ—Ö–∞–Ω–∏–∑–º—ã, –∫–∞–∫ –∏—Å–∫–ª—é—á–µ–Ω–∏—è. –í Rust –Ω–µ—Ç –∏—Å–∫–ª—é—á–µ–Ω–∏–π. –í –∫–∞—á–µ—Å—Ç–≤–µ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤—ã –≤ –Ω—ë–º –µ—Å—Ç—å —Ç–∏–ø <code>Result&lt;T, E&gt;</code> (–¥–ª—è –∏—Å–ø—Ä–∞–≤–∏–º—ã—Ö –æ—à–∏–±–æ–∫) –∏ –º–∞–∫—Ä–æ—Å <code>panic!</code>, –∫–æ—Ç–æ—Ä—ã–π –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ, –∫–æ–≥–¥–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∞ –≤—Å—Ç—Ä–µ—á–∞–µ—Ç –Ω–µ–∏—Å–ø—Ä–∞–≤–∏–º—É—é –æ—à–∏–±–∫—É. –°–Ω–∞—á–∞–ª–∞ —Ä–µ—á—å –ø–æ–π–¥—ë—Ç –ø—Ä–æ –≤—ã–∑–æ–≤ –º–∞–∫—Ä–æ—Å–∞ <code>panic!</code>, –∞ –ø–æ—Ç–æ–º ‚Äî –æ –≤–æ–∑–≤—Ä–∞—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–π <code>Result&lt;T, E&gt;</code>. –ö—Ä–æ–º–µ —Ç–æ–≥–æ, –º—ã —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º, —á—Ç–æ –Ω—É–∂–Ω–æ —É—á–∏—Ç—ã–≤–∞—Ç—å –ø—Ä–∏ –ø—Ä–∏–Ω—è—Ç–∏–∏ —Ä–µ—à–µ–Ω–∏—è –æ —Ç–æ–º, —Å–ª–µ–¥—É–µ—Ç –ª–∏ –ø–æ–ø—ã—Ç–∞—Ç—å—Å—è –∏—Å–ø—Ä–∞–≤–∏—Ç—å –æ—à–∏–±–∫—É –∏–ª–∏ –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–ù–µ–∏—Å–ø—Ä–∞–≤–∏–º—ã–µ-–æ—à–∏–±–∫–∏-—Å-panic"><a class="header" href="#–ù–µ–∏—Å–ø—Ä–∞–≤–∏–º—ã–µ-–æ—à–∏–±–∫–∏-—Å-panic">–ù–µ–∏—Å–ø—Ä–∞–≤–∏–º—ã–µ –æ—à–∏–±–∫–∏ —Å <code>panic!</code></a></h2>
<p>–ò–Ω–æ–≥–¥–∞ –≤ –∫–æ–¥–µ –≤–æ–∑–Ω–∏–∫–∞—é—Ç –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –æ—à–∏–±–∫–∏, –∏ –æ—Ç —ç—Ç–æ–≥–æ –Ω–∏–∫—É–¥–∞ –Ω–µ –¥–µ—Ç—å—Å—è. –î–ª—è —ç—Ç–∏—Ö —Å–ª—É—á–∞–µ–≤ —É Rust –µ—Å—Ç—å –º–∞–∫—Ä–æ—Å <code>panic!</code>. –ù–∞ –ø—Ä–∞–∫—Ç–∏–∫–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –¥–≤–∞ —Å–ø–æ—Å–æ–±–∞ –≤—ã–∑–≤–∞—Ç—å –ø–∞–Ω–∏–∫—É: –ø—É—Ç—ë–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –¥–µ–π—Å—Ç–≤–∏—è, –∫–æ—Ç–æ—Ä–æ–µ –≤—ã–∑—ã–≤–∞–µ—Ç –ø–∞–Ω–∏–∫—É (–Ω–∞–ø—Ä–∏–º–µ—Ä, –æ–±—Ä–∞—â–µ–Ω–∏–µ –∫ –º–∞—Å—Å–∏–≤—É –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ –µ–≥–æ —Ä–∞–∑–º–µ—Ä–∞) –∏–ª–∏ –ø—É—Ç—ë–º —è–≤–Ω–æ–≥–æ –≤—ã–∑–æ–≤–∞ –º–∞–∫—Ä–æ—Å–∞ <code>panic!</code>. –í –æ–±–æ–∏—Ö —Å–ª—É—á–∞—è—Ö –º—ã –≤—ã–∑—ã–≤–∞–µ–º –ø–∞–Ω–∏–∫—É –≤ –Ω–∞—à–µ–π –ø—Ä–æ–≥—Ä–∞–º–º–µ. –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é, –ø–∞–Ω–∏–∫–∞ –≤—ã–≤–æ–¥–∏—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ, —Ä–∞—Å–∫—Ä—É—á–∏–≤–∞–µ—Ç –∏ –æ—á–∏—â–∞–µ—Ç —Å—Ç–µ–∫ –≤—ã–∑–æ–≤–æ–≤ –∏ –∑–∞–≤–µ—Ä—à–∞–µ—Ç —Ä–∞–±–æ—Ç—É. –° –ø–æ–º–æ—â—å—é –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –æ–∫—Ä—É–∂–µ–Ω–∏—è –≤—ã —Ç–∞–∫–∂–µ –º–æ–∂–µ—Ç–µ –∑–∞—Å—Ç–∞–≤–∏—Ç—å Rust –æ—Ç–æ–±—Ä–∞–∂–∞—Ç—å —Å—Ç–µ–∫ –≤—ã–∑–æ–≤–æ–≤ –ø—Ä–∏ –≤–æ–∑–Ω–∏–∫–Ω–æ–≤–µ–Ω–∏–∏ –ø–∞–Ω–∏–∫–∏, —á—Ç–æ–±—ã –±—ã–ª–æ –ª–µ–≥—á–µ –æ—Ç—Å–ª–µ–¥–∏—Ç—å –∏—Å—Ç–æ—á–Ω–∏–∫ –ø–∞–Ω–∏–∫–∏.</p>
<blockquote>
<h3 id="–†–∞—Å–∫—Ä—É—Ç–∏—Ç—å-—Å—Ç–µ–∫-–∏–ª–∏-–ø—Ä–µ—Ä–≤–∞—Ç—å-–∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ-–ø—Ä–æ–≥—Ä–∞–º–º—ã"><a class="header" href="#–†–∞—Å–∫—Ä—É—Ç–∏—Ç—å-—Å—Ç–µ–∫-–∏–ª–∏-–ø—Ä–µ—Ä–≤–∞—Ç—å-–∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ-–ø—Ä–æ–≥—Ä–∞–º–º—ã">–†–∞—Å–∫—Ä—É—Ç–∏—Ç—å —Å—Ç–µ–∫ –∏–ª–∏ –ø—Ä–µ—Ä–≤–∞—Ç—å –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã?</a></h3>
<p>–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é, –∫–æ–≥–¥–∞ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –ø–∞–Ω–∏–∫–∞, –ø—Ä–æ–≥—Ä–∞–º–º–∞ –Ω–∞—á–∏–Ω–∞–µ—Ç –ø—Ä–æ—Ü–µ—Å—Å <em>—Ä–∞—Å–∫—Ä—É—Ç–∫–∏ —Å—Ç–µ–∫–∞</em>, –æ–∑–Ω–∞—á–∞—é—â–∏–π –ø—Ä–æ—Ö–æ–¥ –æ–±—Ä–∞—Ç–Ω–æ –ø–æ —Å—Ç–µ–∫—É –≤—ã–∑–æ–≤–æ–≤ –∏ –æ—á–∏—Å—Ç–∫—É –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∫–∞–∂–¥–æ–π –æ–±–Ω–∞—Ä—É–∂–µ–Ω–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏. –¢–µ–º –Ω–µ –º–µ–Ω–µ–µ, —ç—Ç–æ—Ç –æ–±—Ä–∞—Ç–Ω—ã–π –ø—Ä–æ—Ö–æ–¥ –ø–æ —Å—Ç–µ–∫—É –∏ –æ—á–∏—Å—Ç–∫–∞ —Ç—Ä–µ–±—É—é—Ç –º–Ω–æ–≥–æ —Ä–∞–±–æ—Ç—ã. Rust –≤ –∫–∞—á–µ—Å—Ç–≤–µ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤—ã –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç –≤–∞–º –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ–≥–æ <em>–ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è</em>, –∫–æ—Ç–æ—Ä–æ–µ –∑–∞–≤–µ—Ä—à–∞–µ—Ç —Ä–∞–±–æ—Ç—É –ø—Ä–æ–≥—Ä–∞–º–º—ã –±–µ–∑ –æ—á–∏—Å—Ç–∫–∏.</p>
<p>–ü–∞–º—è—Ç—å, –∫–æ—Ç–æ—Ä—É—é –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∞, –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ—á–∏—â–µ–Ω–∞ –æ–ø–µ—Ä–∞—Ü–∏–æ–Ω–Ω–æ–π —Å–∏—Å—Ç–µ–º–æ–π. –ï—Å–ª–∏ –≤ –≤–∞—à–µ–º –ø—Ä–æ–µ–∫—Ç–µ –Ω—É–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å –∏—Å–ø–æ–ª–Ω—è–µ–º—ã–π —Ñ–∞–π–ª –º–∞–ª–µ–Ω—å–∫–∏–º –Ω–∞—Å—Ç–æ–ª—å–∫–æ, –Ω–∞—Å–∫–æ–ª—å–∫–æ —ç—Ç–æ –≤–æ–∑–º–æ–∂–Ω–æ, –≤—ã –º–æ–∂–µ—Ç–µ –ø—Ä—è–º–æ —É–∫–∞–∑–∞—Ç—å –ø—Ä–æ–≥—Ä–∞–º–º–µ –ø—Ä–µ—Ä—ã–≤–∞—Ç—å –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ –≤ —Å–ª—É—á–∞–µ –ø–∞–Ω–∏–∫–∏, –¥–æ–±–∞–≤–∏–≤ <code>panic = 'abort'</code> –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ —Ä–∞–∑–¥–µ–ª—ã <code>[profile]</code> –≤–∞—à–µ–≥–æ —Ñ–∞–π–ª–∞ <em>Cargo.toml</em>. –ù–∞–ø—Ä–∏–º–µ—Ä, –µ—Å–ª–∏ –≤—ã —Ö–æ—Ç–∏—Ç–µ –ø—Ä–µ—Ä—ã–≤–∞—Ç—å –ø–∞–Ω–∏–∫—É –≤ —Ä–µ–ª–∏–∑–Ω–æ–º —Ä–µ–∂–∏–º–µ, –¥–æ–±–∞–≤—å—Ç–µ —ç—Ç–æ:</p>
<pre><code class="language-toml">[profile.release]
panic = 'abort'
</code></pre>
</blockquote>
<p>–î–∞–≤–∞–π—Ç–µ –ø–æ–ø—Ä–æ–±—É–µ–º –≤—ã–∑–≤–∞—Ç—å <code>panic!</code> –≤ –ø—Ä–æ—Å—Ç–æ–π –ø—Ä–æ–≥—Ä–∞–º–º–µ:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust should_panic panics edition2021">fn main() {
    panic!("–∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞");
}</code></pre></pre>
</Listing>
<p>–ü—Ä–∏ –∑–∞–ø—É—Å–∫–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã –≤—ã —É–≤–∏–¥–∏—Ç–µ –ø–æ–¥–æ–±–Ω—ã–π –≤—ã–≤–æ–¥:</p>
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.25s
     Running `target/debug/panic`
thread 'main' panicked at src/main.rs:2:5:
–∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –º–∞–∫—Ä–æ—Å–∞ <code>panic!</code> –≤—ã–∑—ã–≤–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–Ω–æ–µ –≤ –¥–≤—É—Ö –ø–æ—Å–ª–µ–¥–Ω–∏—Ö —Å—Ç—Ä–æ—á–∫–∞—Ö –≤—ã—à–µ. –ü–µ—Ä–≤–∞—è —Å—Ç—Ä–æ—á–∫–∞ —Å–æ–¥–µ—Ä–∂–∏—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–∞–Ω–∏–∫–∏ –∏ –º–µ—Å—Ç–æ –≤ –∏—Å—Ö–æ–¥–Ω–æ–º –∫–æ–¥–µ, –≥–¥–µ –≤–æ–∑–Ω–∏–∫–ª–∞ –ø–∞–Ω–∏–∫–∞: –∑–∞–ø–∏—Å—å <em>src/main.rs:2:5</em> —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ –≤—Ç–æ—Ä–æ–π —Å—Ç—Ä–æ—á–∫–∏ –ø—è—Ç—ã–π —Å–∏–º–≤–æ–ª –≤–Ω—É—Ç—Ä–∏ —Ñ–∞–π–ª–∞ <em>src/main.rs</em>.</p>
<p>–í –Ω–∞—à–µ–º —Å–ª—É—á–∞–µ, —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ –Ω–∞—à —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–π –∫–æ–¥, –∏ –µ—Å–ª–∏ –º—ã –ø–µ—Ä–µ–π–¥—ë–º –∫ —ç—Ç–æ–π —Å—Ç—Ä–æ–∫–µ, –º—ã —É–≤–∏–¥–∏–º –≤—ã–∑–æ–≤ –º–∞–∫—Ä–æ—Å–∞ <code>panic!</code>. –í –¥—Ä—É–≥–∏—Ö —Å–ª—É—á–∞—è—Ö –≤—ã–∑–æ–≤ <code>panic!</code> –º–æ–≥ –±—ã –ø—Ä–æ–∏–∑–æ–π—Ç–∏ –≤ —Å—Ç–æ—Ä–æ–Ω–Ω–µ–º –∫–æ–¥–µ, –≤—ã–∑—ã–≤–∞–µ–º–æ–º –Ω–∞—à–∏–º, –∏ —Ç–æ–≥–¥–∞ –∏–º—è —Ñ–∞–π–ª–∞ –∏ –Ω–æ–º–µ—Ä —Å—Ç—Ä–æ–∫–∏ —É–∫–∞–∑—ã–≤–∞–ª–∏ –±—ã –∏–º–µ–Ω–Ω–æ —Ç—É–¥–∞, –≥–¥–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –º–∞–∫—Ä–æ—Å <code>panic!</code>, –∞ –Ω–µ –Ω–∞ —Ç–æ—Ç –∫–æ–¥, –≤—ã–∑–æ–≤ –∫–æ—Ç–æ—Ä–æ–≥–æ –ø—Ä–∏–≤—ë–ª –∫ –≤—ã–∑–æ–≤—É <code>panic!</code>.</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="using-a-panic-backtrace"></a></p>
<p>–ú—ã –º–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ä–∞–∑–≤—ë—Ä—Ç–∫—É –≤—ã–∑–æ–≤–æ–≤ —Ñ—É–Ω–∫—Ü–∏–π, –ø—Ä–∏–≤–æ–¥—è—â–∏—Ö –∫ –≤—ã–∑–æ–≤—É <code>panic!</code>, —á—Ç–æ–±—ã –≤—ã—è—Å–Ω–∏—Ç—å, –∫–∞–∫–∞—è —á–∞—Å—Ç—å –Ω–∞—à–µ–≥–æ –∫–æ–¥–∞ –≤—ã–∑—ã–≤–∞–µ—Ç –ø—Ä–æ–±–ª–µ–º—É. –ß—Ç–æ–±—ã –ø–æ–Ω—è—Ç—å, –∫–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ä–∞–∑–≤—ë—Ä—Ç–∫—É –≤—ã–∑–æ–≤–∞ <code>panic!</code>, –¥–∞–≤–∞–π—Ç–µ —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º –¥—Ä—É–≥–æ–π –ø—Ä–∏–º–µ—Ä –∏ –ø–æ—Å–º–æ—Ç—Ä–∏–º, –∫–∞–∫–æ–≤–æ —ç—Ç–æ, –∫–æ–≥–¥–∞ <code>panic!</code> –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –Ω–µ –Ω–∞–ø—Ä—è–º—É—é —á–µ—Ä–µ–∑ –≤—ã–∑–æ–≤ –º–∞–∫—Ä–æ—Å–∞, –∞ –≤ –±–∏–±–ª–∏–æ—Ç–µ—á–Ω–æ–º –∫–æ–¥–µ, —Å–æ–¥–µ—Ä–∂–∞—â–µ–º –±–∞–≥. –í –õ–∏—Å—Ç–∏–Ω–≥–µ 9-1 –ø—Ä–∏–≤–µ–¥–µ–Ω –Ω–µ–∫–æ—Ç–æ—Ä—ã–π –∫–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –ø—ã—Ç–∞–µ—Ç—Å—è –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø —ç–ª–µ–º–µ–Ω—Ç—É –≤–µ–∫—Ç–æ—Ä–∞ –ø–æ –∏–Ω–¥–µ–∫—Å—É, –ª–µ–∂–∞—â–µ–º—É –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ –≤–µ–∫—Ç–æ—Ä–∞.</p>
<Listing number="9-1" file-name="src/main.rs" caption="Attempting to access an element beyond the end of a vector, which will cause a call to `panic!`">
<pre><pre class="playground"><code class="language-rust should_panic panics edition2021">fn main() {
    let v = vec![1, 2, 3];

    v[99];
}</code></pre></pre>
</Listing>
<p>–ó–¥–µ—Å—å –º—ã –ø—ã—Ç–∞–µ–º—Å—è –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ 100–º—É —ç–ª–µ–º–µ–Ω—Ç—É –≤–µ–∫—Ç–æ—Ä–∞ (–∫–æ—Ç–æ—Ä—ã–π –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ø–æ –∏–Ω–¥–µ–∫—Å—É 99, –ø–æ—Ç–æ–º—É —á—Ç–æ –∏–Ω–¥–µ–∫—Å–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å –Ω—É–ª—è), –Ω–æ –≤–µ–∫—Ç–æ—Ä –∏–º–µ–µ—Ç —Ç–æ–ª—å–∫–æ 3 —ç–ª–µ–º–µ–Ω—Ç–∞. –í —ç—Ç–æ–π —Å–∏—Ç—É–∞—Ü–∏–∏, Rust –±—É–¥–µ—Ç –≤—ã–∑—ã–≤–∞—Ç—å –ø–∞–Ω–∏–∫—É. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ <code>[]</code> –¥–æ–ª–∂–Ω–æ –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å —ç–ª–µ–º–µ–Ω—Ç, –Ω–æ –µ—Å–ª–∏ –≤—ã –ø–µ—Ä–µ–¥–∞–¥–∏—Ç–µ –Ω–µ–≤–µ—Ä–Ω—ã–π –∏–Ω–¥–µ–∫—Å, Rust –Ω–µ —Å–º–æ–∂–µ—Ç –Ω–∞–π—Ç–∏ –Ω–∏—á–µ–≥–æ, —á—Ç–æ –º–æ–∂–Ω–æ –±—ã–ª–æ –±—ã –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –≤–µ—Ä–Ω—É—Ç—å.</p>
<p>–í —è–∑—ã–∫–µ C, –ø–æ–ø—ã—Ç–∫–∞ –ø—Ä–æ—á–µ—Å—Ç—å –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ –∫–æ–Ω—Ü–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö (–≤ –Ω–∞—à–µ–º —Å–ª—É—á–∞–µ, –≤–µ–∫—Ç–æ—Ä–∞) –ø—Ä–∏–≤–µ–¥—ë—Ç –∫ <em>–Ω–µ–æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–º—É –ø–æ–≤–µ–¥–µ–Ω–∏—é</em>. –ê –∏–º–µ–Ω–Ω–æ, –≤—ã –≤—Å—ë-—Ç–∞–∫–∏ –ø–æ–ª—É—á–∏—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ —Ç–æ–º –º–µ—Å—Ç–µ –ø–∞–º—è—Ç–∏ –∫–æ–º–ø—å—é—Ç–µ—Ä–∞, –∫–æ—Ç–æ—Ä–æ–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–æ–≤–∞–ª–æ –±—ã —ç—Ç–æ–º—É —ç–ª–µ–º–µ–Ω—Ç—É –≤ —Å—Ç—Ä—É–∫—Ç—É—Ä–µ –¥–∞–Ω–Ω—ã—Ö ‚Äî –¥–∞–∂–µ –Ω–µ—Å–º–æ—Ç—Ä—è –Ω–∞ —Ç–æ, —á—Ç–æ —ç—Ç–æ –º–µ—Å—Ç–æ –∫ –Ω–µ–π –æ—Ç–Ω–æ—Å–∏—Ç—å—Å—è –Ω–∏–∫–∞–∫ –Ω–µ –±—É–¥–µ—Ç. –≠—Ç–æ –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è <em>—á—Ç–µ–Ω–∏–µ–º –∑–∞ –≥—Ä–∞–Ω–∏—Ü–∞–º–∏ –±—É—Ñ–µ—Ä–∞</em> (<em>buffer overread</em>) ‚Äî —É—è–∑–≤–∏–º–æ—Å—Ç—å—é –≤ –≤–∏–¥–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ —á—Ç–µ–Ω–∏—è –∑–ª–æ—É–º—ã—à–ª–µ–Ω–Ω–∏–∫–æ–º –¥–∞–Ω–Ω—ã—Ö, –∫ –∫–æ—Ç–æ—Ä—ã–º —É –Ω–µ–≥–æ –Ω–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –¥–æ—Å—Ç—É–ø–∞, –≤—ã–∑–≤–∞–Ω–Ω–æ–π –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å—é —á–∏—Ç–∞—Ç—å –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω—ã–µ –æ–±–ª–∞—Å—Ç–∏ –ø–∞–º—è—Ç–∏ —Å –ø–æ–º–æ—â—å—é –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã—Ö –∏–Ω–¥–µ–∫—Å–æ–≤.</p>
<p>–ß—Ç–æ–±—ã –∑–∞—â–∏—â–∞—Ç—å –≤–∞—à—É –ø—Ä–æ–≥—Ä–∞–º–º—É –æ—Ç —Ç–∞–∫–æ–≥–æ —Ä–æ–¥–∞ —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ –ø—Ä–æ—á–∏—Ç–∞—Ç—å —ç–ª–µ–º–µ–Ω—Ç –ø–æ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–º—É –∏–Ω–¥–µ–∫—Å—É, Rust –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ –∏ –æ—Ç–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è –ø—Ä–æ–¥–æ–ª–∂–∞—Ç—å —Ä–∞–±–æ—Ç—É –ø—Ä–æ–≥—Ä–∞–º–º—ã. –ü–æ—Å–º–æ—Ç—Ä–∏–º, –∫–∞–∫ —ç—Ç–æ –≤—ã–≥–ª—è–¥–∏—Ç:</p>
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/panic`
thread 'main' panicked at src/main.rs:4:6:
index out of bounds: the len is 3 but the index is 99
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>–≠—Ç–∞ –æ—à–∏–±–∫–∞ —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ —Å—Ç—Ä–æ–∫—É 4 –Ω–∞—à–µ–≥–æ <em>main.rs</em>, –≥–¥–µ –º—ã –ø—ã—Ç–∞–µ–º—Å—è –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –ø–æ –∏–Ω–¥–µ–∫—Å—É <code>99</code> –∫ —ç–ª–µ–º–µ–Ω—Ç—É –≤–µ–∫—Ç–æ—Ä–∞ <code>v</code>.</p>
<p>–°—Ç—Ä–æ–∫–∞ <code>note:</code> —Å–æ–æ–±—â–∞–µ—Ç –Ω–∞–º, —á—Ç–æ –º—ã –º–æ–∂–µ–º —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é —Å—Ä–µ–¥—ã <code>RUST_BACKTRACE</code>, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∞—Ç—å —Ä–∞–∑–≤—ë—Ä—Ç–∫—É –≤—ã–∑–æ–≤–æ–≤, –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∫–æ—Ç–æ—Ä—ã—Ö –ø—Ä–∏–≤–µ–ª–∞ –∫ –æ—à–∏–±–∫–µ. <em>–†–∞–∑–≤—ë—Ä—Ç–∫–∞ –≤—ã–∑–æ–≤–æ–≤</em> (<em>backtrace</em>) ‚Äî —ç—Ç–æ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã–π —Å–ø–∏—Å–æ–∫ –≤–ª–æ–∂–µ–Ω–Ω—ã—Ö –≤—ã–∑–æ–≤–æ–≤. –†–∞–∑–≤—ë—Ä—Ç–∫–∞ –≤—ã–∑–æ–≤–æ–≤ –≤ Rust —Ä–∞–±–æ—Ç–∞–µ—Ç —Ç–∞–∫ –∂–µ, –∫–∞–∫ –∏ –≤ –¥—Ä—É–≥–∏—Ö —è–∑—ã–∫–∞—Ö: –µ—ë –Ω—É–∂–Ω–æ —á–∏—Ç–∞—Ç—å –æ—Ç –Ω–∞—á–∞–ª–∞ –∏ –¥–æ —Ç–æ–≥–æ –º–æ–º–µ–Ω—Ç–∞, –∫–æ–≥–¥–∞ —É–ø–æ–º–∏–Ω–∞–µ—Ç—Å—è –≤–∞—à –∫–æ–¥. –ò–º–µ–Ω–Ω–æ –æ—Ç—Å—é–¥–∞ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è –≤–∞—à–∞ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞. –°—Ç—Ä–æ–∫–∏ –≤—ã—à–µ ‚Äî  —ç—Ç–æ —É–∫–∞–∑–∞–Ω–∏—è –Ω–∞ –∫–æ–¥, –≤—ã–∑—ã–≤–∞–µ–º—ã–π —Å—Ç—Ä–æ—á–∫–æ–π, –≥–¥–µ –Ω–∞—á–∞–ª–∏—Å—å –ø—Ä–æ–±–ª–µ–º—ã; —Å—Ç—Ä–æ–∫–∏ –Ω–∏–∂–µ ‚Äî —ç—Ç–æ —É–∫–∞–∑–∞–Ω–∏—è –Ω–∞ –∫–æ–¥, –≤—ã–∑—ã–≤–∞—é—â–∏–π –≤–∞—à –ø—Ä–æ–±–ª–µ–º–Ω—ã–π –∫–æ–¥. –≠—Ç–∏ —Å—Ç—Ä–æ–∫–∏ –≤—ã—à–µ –∏ –Ω–∏–∂–µ –º–æ–≥—É—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å –∫–æ–¥ —è–¥—Ä–∞ Rust, –∫–æ–¥ –∏–∑ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –∏–ª–∏ –∏–∑ –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã—Ö –≤–∞–º–∏ –∫—Ä–µ–π—Ç–æ–≤. –î–∞–≤–∞–π—Ç–µ –ø–æ–ø—Ä–æ–±—É–µ–º –≤—ã–ø–æ–ª–Ω–∏—Ç—å —Ä–∞–∑–≤—ë—Ä—Ç–∫—É –≤—ã–∑–æ–≤–æ–≤, —É—Å—Ç–∞–Ω–æ–≤–∏–≤ –¥–ª—è –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –æ–∫—Ä—É–∂–µ–Ω–∏—è <code>RUST_BACKTRACE</code> –ª—é–±–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ, –∫—Ä–æ–º–µ <code>0</code>. –í –õ–∏—Å—Ç–∏–Ω–≥–µ 9-2 –ø–æ–∫–∞–∑–∞–Ω —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π –ø—Ä–∏–º–µ—Ä.</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/listing-09-01
RUST_BACKTRACE=1 cargo run
copy the backtrace output below
check the backtrace number mentioned in the text below the listing
-->
<Listing number="9-2" caption="The backtrace generated by a call to `panic!` displayed when the environment variable `RUST_BACKTRACE` is set">
<pre><code class="language-console">$ RUST_BACKTRACE=1 cargo run
thread 'main' panicked at src/main.rs:4:6:
index out of bounds: the len is 3 but the index is 99
stack backtrace:
   0: rust_begin_unwind
             at /rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14/library/std/src/panicking.rs:662:5
   1: core::panicking::panic_fmt
             at /rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14/library/core/src/panicking.rs:74:14
   2: core::panicking::panic_bounds_check
             at /rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14/library/core/src/panicking.rs:276:5
   3: &lt;usize as core::slice::index::SliceIndex&lt;[T]&gt;&gt;::index
             at /rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14/library/core/src/slice/index.rs:302:10
   4: core::slice::index::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index
             at /rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14/library/core/src/slice/index.rs:16:9
   5: &lt;alloc::vec::Vec&lt;T,A&gt; as core::ops::index::Index&lt;I&gt;&gt;::index
             at /rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14/library/alloc/src/vec/mod.rs:2920:9
   6: panic::main
             at ./src/main.rs:4:6
   7: core::ops::function::FnOnce::call_once
             at /rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14/library/core/src/ops/function.rs:250:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre>
</Listing>
<p>–°–∫–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç–∞! –í—ã–≤–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –≤—ã —É–≤–∏–¥–∏—Ç–µ, –º–æ–∂–µ—Ç –æ—Ç–ª–∏—á–∞—Ç—å—Å—è –æ—Ç –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–Ω–æ–≥–æ –≤—ã—à–µ, –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –≤–∞—à–µ–π –æ–ø–µ—Ä–∞—Ü–∏–æ–Ω–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã –∏ –≤–µ—Ä—Å–∏–∏ Rust. –î–ª—è —Ç–æ–≥–æ, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å —Ä–∞–∑–≤—ë—Ä—Ç–∫—É –≤—ã–∑–æ–≤–æ–≤ —Å —ç—Ç–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π, –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤–∫–ª—é—á–µ–Ω—ã –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –æ—Ç–ª–∞–¥–∫–∏. –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –æ—Ç–ª–∞–¥–∫–∏ –≤–∫–ª—é—á–µ–Ω—ã –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –ø—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ <code>cargo build</code> –∏–ª–∏ <code>cargo run</code>, –µ—Å–ª–∏ –≤—ã –Ω–µ —É–∫–∞–∑—ã–≤–∞–µ—Ç–µ —Ñ–ª–∞–≥ <code>--release</code>.</p>
<p>–í —Ä–∞–∑–≤—ë—Ä—Ç–∫–µ –≤—ã–∑–æ–≤–æ–≤ –∏–∑ –õ–∏—Å—Ç–∏–Ω–≥–∞ 9-2, —Å—Ç—Ä–æ–∫–∞ <code>6: ...</code> —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ —Å—Ç—Ä–æ—á–∫—É –≤ –Ω–∞—à–µ–º –ø—Ä–æ–µ–∫—Ç–µ, –∫–æ—Ç–æ—Ä–∞—è –∏ –≤—ã–∑—ã–≤–∞–ª–∞ –ø—Ä–æ–±–ª–µ–º—É: —Å—Ç—Ä–æ—á–∫–∞ 4 —Ñ–∞–π–ª–∞ <em>src/main.rs</em>. –ï—Å–ª–∏ –º—ã –Ω–µ —Ö–æ—Ç–∏–º, —á—Ç–æ–±—ã –Ω–∞—à–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∞ –ø–∞–Ω–∏–∫–æ–≤–∞–ª–∞, –º—ã –¥–æ–ª–∂–Ω—ã –Ω–∞—á–∞—Ç—å –∞–Ω–∞–ª–∏–∑ —Å –º–µ—Å—Ç–∞, –Ω–∞ –∫–æ—Ç–æ—Ä–æ–µ —É–∫–∞–∑—ã–≤–∞–µ—Ç –ø–µ—Ä–≤–∞—è —Å—Ç—Ä–æ–∫–∞ —Å —É–ø–æ–º–∏–Ω–∞–Ω–∏–µ–º –Ω–∞—à–µ–≥–æ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞. –í –õ–∏—Å—Ç–∏–Ω–≥–µ 9-1, –≥–¥–µ –º—ã –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ —Ä–∞–∑–≤—ë—Ä—Ç–∫–∏ –≤—ã–∑–æ–≤–æ–≤ —Å–æ–∑–Ω–∞—Ç–µ–ª—å–Ω–æ –Ω–∞–ø–∏—Å–∞–ª–∏ –∫–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –ø–∞–Ω–∏–∫—É–µ—Ç, —Å–ø–æ—Å–æ–± –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–∞–Ω–∏–∫–∏ —Å–æ—Å—Ç–æ–∏—Ç –≤ —Ç–æ–º, —á—Ç–æ–±—ã –Ω–µ –∑–∞–ø—Ä–∞—à–∏–≤–∞—Ç—å —ç–ª–µ–º–µ–Ω—Ç –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ –¥–∏–∞–ø–∞–∑–æ–Ω–∞ –∑–Ω–∞—á–µ–Ω–∏–π –∏–Ω–¥–µ–∫—Å–æ–≤ –≤–µ–∫—Ç–æ—Ä–∞. –ö–æ–≥–¥–∞ –≤—ã –≤—Å—Ç—Ä–µ—Ç–∏—Ç–µ—Å—å —Å –ø–∞–Ω–∏–∫–æ–π –≤ —Å–≤–æ–∏—Ö –±—É–¥—É—â–∏—Ö –ø—Ä–æ–≥—Ä–∞–º–º–∞—Ö, –≤–∞–º –Ω—É–∂–Ω–æ –±—É–¥–µ—Ç –≤—ã—è—Å–Ω–∏—Ç—å, —á—Ç–æ –Ω–∞–¥ —á–µ–º –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ –¥–µ–ª–∞–µ—Ç –∫–æ–¥, –∏ —á—Ç–æ –æ–Ω –¥–æ–ª–∂–µ–Ω –¥–µ–ª–∞—Ç—å –ø–æ –∑–∞–¥—É–º–∫–µ.</p>
<p>–ú—ã –≤–µ—Ä–Ω—ë–º—Å—è –∫ –æ–±—Å—É–∂–¥–µ–Ω–∏—é –º–∞–∫—Ä–æ—Å–∞ <code>panic!</code> –∏ —Ç–æ–≥–æ, –∫–æ–≥–¥–∞ –Ω–∞–º —Å–ª–µ–¥—É–µ—Ç –∏ –Ω–µ —Å–ª–µ–¥—É–µ—Ç –µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫, –≤ —Ä–∞–∑–¥–µ–ª–µ <a href="ch09-03-to-panic-or-not-to-panic.html#%D0%9A%D0%BE%D0%B3%D0%B4%D0%B0-%D1%81%D0%BB%D0%B5%D0%B4%D1%83%D0%B5%D1%82-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-panic">"–ö–æ–≥–¥–∞ —Å–ª–µ–¥—É–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å <code>panic!</code>?"</a><!-- ignore --> —ç—Ç–æ–π –≥–ª–∞–≤—ã. –î–∞–ª–µ–µ –º—ã —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º, –∫–∞–∫ –º–æ–∂–Ω–æ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã –ø–æ—Å–ª–µ –æ—à–∏–±–∫–∏, –≤–æ—Å–ø–æ–ª—å–∑–æ–≤–∞–≤—à–∏—Å—å —Ç–∏–ø–æ–º <code>Result</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–ò—Å–ø—Ä–∞–≤–∏–º—ã–µ-–æ—à–∏–±–∫–∏-—Å-result"><a class="header" href="#–ò—Å–ø—Ä–∞–≤–∏–º—ã–µ-–æ—à–∏–±–∫–∏-—Å-result">–ò—Å–ø—Ä–∞–≤–∏–º—ã–µ –æ—à–∏–±–∫–∏ —Å <code>Result</code></a></h2>
<p>–ú–Ω–æ–≥–∏–µ –æ—à–∏–±–∫–∏ –Ω–µ —è–≤–ª—è—é—Ç—Å—è –Ω–∞—Å—Ç–æ–ª—å–∫–æ –∫—Ä–∏—Ç–∏—á–Ω—ã–º–∏, —á—Ç–æ–±—ã –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—Ç—å –≤—Å—é –ø—Ä–æ–≥—Ä–∞–º–º—É. –ò–Ω–æ–≥–¥–∞, –∫–æ–≥–¥–∞ –≤ —Ñ—É–Ω–∫—Ü–∏–∏ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç —Å–±–æ–π, –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –ø—Ä–æ—Å—Ç–æ –ø—Ä–∞–≤–∏–ª—å–Ω–æ –µ–≥–æ –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∏—Ä–æ–≤–∞—Ç—å –∏ –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å. –ö –ø—Ä–∏–º–µ—Ä—É, –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ –æ—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª –º–æ–∂–µ—Ç –ø—Ä–æ–∏–∑–æ–π—Ç–∏ –æ—à–∏–±–∫–∞ –∏–∑-–∑–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è —Ñ–∞–π–ª–∞. –í —ç—Ç–æ–º —Å–ª—É—á–∞–µ –≤—ã, –≤–æ–∑–º–æ–∂–Ω–æ, –∑–∞—Ö–æ—Ç–∏—Ç–µ —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π —Ñ–∞–π–ª, –∞ –Ω–µ –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—Ç—å –≤—Å—é –ø—Ä–æ–≥—Ä–∞–º–º—É.</p>
<p>–í—Å–ø–æ–º–Ω–∏—Ç–µ –ø—Ä–æ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ <code>Result</code> –∏ –µ–≥–æ –≤–∞—Ä–∏–∞–Ω—Ç—ã <code>Ok</code> –∏ <code>Err</code>, –∫–æ—Ç–æ—Ä—ã–º–∏ –º—ã –ø–æ–ª—å–∑–æ–≤–∞–ª–∏—Å—å –≤ —Ä–∞–∑–¥–µ–ª–µ <a href="ch02-00-guessing-game-tutorial.html#%D0%9E%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0-%D0%B2%D0%BE%D0%B7%D0%BC%D0%BE%D0%B6%D0%BD%D1%8B%D1%85-%D0%BE%D1%88%D0%B8%D0%B1%D0%BE%D0%BA-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-result">"–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–æ–∑–º–æ–∂–Ω—ã—Ö –æ—à–∏–±–æ–∫ —Å –ø–æ–º–æ—â—å—é <code>Result</code>"</a><!-- ignore --> –ì–ª–∞–≤—ã 2. –ï–≥–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –≤—ã–≥–ª—è–¥–∏—Ç —Ç–∞–∫:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p><code>T</code> –∏ <code>E</code> ‚Äî —ç—Ç–æ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –æ–±–æ–±—â—ë–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞; –º—ã –æ–±—Å—É–¥–∏–º –æ–±–æ–±—â—ë–Ω–Ω—ã–µ —Ç–∏–ø—ã –±–æ–ª–µ–µ –ø–æ–¥—Ä–æ–±–Ω–æ –≤ –ì–ª–∞–≤–µ 10. –í—Å—ë, —á—Ç–æ –≤–∞–º –Ω—É–∂–Ω–æ –∑–Ω–∞—Ç—å –ø—Ä—è–º–æ —Å–µ–π—á–∞—Å ‚Äî —ç—Ç–æ —Ç–æ, —á—Ç–æ <code>T</code> –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Ç–∏–ø –∑–Ω–∞—á–µ–Ω–∏—è, –∫–æ—Ç–æ—Ä–æ–µ –±—É–¥–µ—Ç –≤–æ–∑–≤—Ä–∞—â–µ–Ω–æ –≤–Ω—É—Ç—Ä–∏ –≤–∞—Ä–∏–∞–Ω—Ç–∞ <code>Ok</code> –≤ —Å–ª—É—á–∞–µ —É—Å–ø–µ—Ö–∞, –∞ <code>E</code> ‚Äî —Ç–∏–ø –æ—à–∏–±–∫–∏, –∫–æ—Ç–æ—Ä–∞—è –±—É–¥–µ—Ç –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∞ –≤–Ω—É—Ç—Ä–∏ –≤–∞—Ä–∏–∞–Ω—Ç–∞ <code>Err</code> –≤ —Å–ª—É—á–∞–µ —Å–±–æ—è. –ë–ª–∞–≥–æ–¥–∞—Ä—è –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º –æ–±–æ–±—â—ë–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞ –≤ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–∏ <code>Result</code>, –º—ã –º–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –µ–≥–æ –≤ —Ç–µ—Ö —Å–ª—É—á–∞—è—Ö, –∫–æ–≥–¥–∞ —Ç–∏–ø—ã –∑–Ω–∞—á–µ–Ω–∏—è –≤ —Å–ª—É—á–∞–µ —É—Å–ø–µ—à–Ω–æ–≥–æ –∏ –Ω–µ—É–¥–∞—á–Ω–æ–≥–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Ä–∞–∑–ª–∏—á–Ω—ã.</p>
<p>–î–∞–≤–∞–π—Ç–µ –≤—ã–∑–æ–≤–µ–º —Ñ—É–Ω–∫—Ü–∏—é, –∫–æ—Ç–æ—Ä–∞—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ <code>Result</code>, –ø–æ—Ç–æ–º—É —á—Ç–æ –º–æ–∂–µ—Ç –ø–æ—Ç–µ—Ä–ø–µ—Ç—å –Ω–µ—É–¥–∞—á—É. –í –õ–∏—Å—Ç–∏–Ω–≥–µ 9-3 –º—ã –ø—ã—Ç–∞–µ–º—Å—è –æ—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª.</p>
<Listing number="9-3" file-name="src/main.rs" caption="Opening a file">
<pre><pre class="playground"><code class="language-rust edition2021">use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");
}</code></pre></pre>
</Listing>
<p>–í–æ–∑–≤—Ä–∞—â–∞–µ–º—ã–π —Ç–∏–ø <code>File::open</code> ‚Äî <code>Result&lt;T, E&gt;</code>. –ü–∞—Ä–∞–º–µ—Ç—Ä –æ–±–æ–±—â—ë–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞ <code>T</code> –∑–∞–º–µ–Ω—è–µ—Ç—Å—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–µ–π <code>File::open</code> –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º —Ç–∏–ø–æ–º <code>std::fs::File</code>, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—â–∏–º –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä —Ñ–∞–π–ª–∞. –ü–∞—Ä–∞–º–µ—Ç—Ä <code>E</code>, –æ–±–æ–∑–Ω–∞—á–∞—é—â–∏–π –∑–Ω–∞—á–µ–Ω–∏–µ –æ—à–∏–±–∫–∏, –∑–∞–º–µ–Ω—è–µ—Ç—Å—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º —Ç–∏–ø–æ–º <code>std::io::Error</code>. –ò—Ç–æ–≥–æ, —Ç–∞–∫–æ–π —Ç–∏–ø –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –≤—ã–∑–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏ <code>File::open</code> –º–æ–∂–µ—Ç —É–¥–∞—Ç—å—Å—è –∏–ª–∏ –Ω–µ —É–¥–∞—Ç—å—Å—è. –í —Å–ª—É—á–∞–µ —É—Å–ø–µ—Ö–∞, –º—ã –ø–æ–ª—É—á–∏–º –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä —Ñ–∞–π–ª–∞, –ø—Ä–∏ –ø–æ–º–æ—â–∏ –∫–æ—Ç–æ—Ä–æ–≥–æ –º—ã —Å–º–æ–∂–µ–º –ø–∏—Å–∞—Ç—å –≤ —Ñ–∞–π–ª –∏–ª–∏ —á–∏—Ç–∞—Ç—å –∏–∑ –Ω–µ–≥–æ. –í —Å–ª—É—á–∞–µ –Ω–µ—É–¥–∞—á–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –µ—Å–ª–∏ —Ñ–∞–π–ª –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∏–ª–∏ —É –Ω–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ –Ω–µ–º—É), —Ñ—É–Ω–∫—Ü–∏—è <code>File::open</code> —Å–æ–æ–±—â–∏—Ç –Ω–∞–º, —á—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫. –ü–æ–ª—É—á–∞–µ–º—ã–µ –Ω–∞–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è –æ—Ç–ª–∏—á–Ω–æ –ø–æ–¥—Ö–æ–¥—è—Ç –¥–ª—è –∏—Ö –æ–±—ë—Ä—Ç–∫–∏ –≤ –≤–∞—Ä–∏–∞–Ω—Ç—ã –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è <code>Result</code>.</p>
<p>–í —Å–ª—É—á–∞–µ —É—Å–ø–µ—Ö–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è <code>File::open</code>, –∑–Ω–∞—á–µ–Ω–∏–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π <code>greeting_file_result</code> –±—É–¥–µ—Ç —ç–∫–∑–µ–º–ø–ª—è—Ä <code>Ok</code>, —Å–æ–¥–µ—Ä–∂–∞—â–∏–π –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä —Ñ–∞–π–ª–∞. –í —Å–ª—É—á–∞–µ –Ω–µ—É–¥–∞—á–∏, –∑–Ω–∞—á–µ–Ω–∏–µ –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π <code>greeting_file_result</code> –±—É–¥–µ—Ç —ç–∫–∑–µ–º–ø–ª—è—Ä–æ–º <code>Err</code>, —Å–æ–¥–µ—Ä–∂–∞—â–∏–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–æ–º, –∫–∞–∫–∞—è –∏–º–µ–Ω–Ω–æ –æ—à–∏–±–∫–∞ –ø—Ä–æ–∏–∑–æ—à–ª–∞.</p>
<p>–ù–µ–æ–±—Ö–æ–¥–∏–º–æ –¥–æ–ø–∏—Å–∞—Ç—å –≤ –∫–æ–¥ –õ–∏—Å—Ç–∏–Ω–≥–∞ 9-3 –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —Ä–∞–∑–Ω—ã—Ö –¥–µ–π—Å—Ç–≤–∏–π –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∑–Ω–∞—á–µ–Ω–∏—è, –∫–æ—Ç–æ—Ä–æ–µ –≤–µ—Ä–Ω—ë—Ç –≤—ã–∑–æ–≤ <code>File::open</code>. –õ–∏—Å—Ç–∏–Ω–≥ 9-4 –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –æ–¥–∏–Ω –∏–∑ —Å–ø–æ—Å–æ–±–æ–≤ –æ–±—Ä–∞–±–æ—Ç–∫–∏ <code>Result</code> ‚Äî –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≤—ã—Ä–∞–∂–µ–Ω–∏—è <code>match</code> (–∫–æ—Ç–æ—Ä–æ–µ –±—ã–ª–æ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–æ –≤ –ì–ª–∞–≤–µ 6).</p>
<Listing number="9-4" file-name="src/main.rs" caption="Using a `match` expression to handle the `Result` variants that might be returned">
<pre><pre class="playground"><code class="language-rust should_panic edition2021">use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; panic!("–ü—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏ —Ñ–∞–π–ª–∞ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: {error:?}"),
    };
}</code></pre></pre>
</Listing>
<p>–û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ –∫–∞–∫ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ <code>Option</code>, —Ç–∞–∫ –∏ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ <code>Result</code> –∏ –µ–≥–æ –≤–∞—Ä–∏–∞–Ω—Ç—ã –ø–æ–¥–∫–ª—é—á–∞—é—Ç—Å—è –≤ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, –ø–æ—ç—Ç–æ–º—É –Ω–µ –Ω—É–∂–Ω–æ —É–∫–∞–∑—ã–≤–∞—Ç—å <code>Result::</code> –ø–µ—Ä–µ–¥ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ <code>Ok</code> –∏ <code>Err</code> –≤ –≤–µ—Ç–∫–∞—Ö –≤—ã—Ä–∞–∂–µ–Ω–∏—è <code>match</code>.</p>
<p>–ï—Å–ª–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–º –±—É–¥–µ—Ç <code>Ok</code>, —ç—Ç–æ—Ç –∫–æ–¥ –≤–µ—Ä–Ω—ë—Ç –∑–Ω–∞—á–µ–Ω–∏–µ <code>file</code> –∏–∑ –≤–∞—Ä–∏–∞–Ω—Ç–∞ <code>Ok</code>, –∞ –º—ã –∑–∞—Ç–µ–º –ø—Ä–∏—Å–≤–æ–∏–º –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π <code>greeting_file</code> –ø–æ–ª—É—á–µ–Ω–Ω—ã–π –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä —Ñ–∞–π–ª–∞. –ü–æ—Å–ª–µ <code>match</code> –º—ã —Å–º–æ–∂–µ–º –µ–≥–æ –¥–ª—è —á—Ç–µ–Ω–∏—è –∏–ª–∏ –∑–∞–ø–∏—Å–∏.</p>
<p>–î—Ä—É–≥–∞—è –≤–µ—Ç–≤—å <code>match</code> –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Å–ª—É—á–∞–π, –∫–æ–≥–¥–∞ –º—ã –ø–æ–ª—É—á–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ <code>Err</code> –ø–æ—Å–ª–µ –≤—ã–∑–æ–≤–∞ <code>File::open</code>. –í —ç—Ç–æ–º –ø—Ä–∏–º–µ—Ä–µ –º—ã —Ä–µ—à–∏–ª–∏ –≤—ã–∑–≤–∞—Ç—å –º–∞–∫—Ä–æ—Å <code>panic!</code>. –ï—Å–ª–∏ –≤ –Ω–∞—à–µ–π —Ç–µ–∫—É—â–µ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –Ω–µ—Ç —Ñ–∞–π–ª–∞ —Å –∏–º–µ–Ω–µ–º <em>hello.txt</em>, –Ω–æ –º—ã –≤—Å—ë –∂–µ –≤—ã–ø–æ–ª–Ω–∏–º —ç—Ç–æ—Ç –∫–æ–¥, —Ç–æ –º—ã —É–≤–∏–¥–∏–º —Å–ª–µ–¥—É—é—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç –º–∞–∫—Ä–æ—Å–∞ <code>panic!</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/error-handling`
thread 'main' panicked at src/main.rs:8:23:
–ü—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏ —Ñ–∞–π–ª–∞ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: Os { code: 2, kind: NotFound, message: "No such file or directory" }
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>–ö–∞–∫ –æ–±—ã—á–Ω–æ, –¥–∞–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Ç–æ—á–Ω–æ –≥–æ–≤–æ—Ä–∏—Ç, —á—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫.</p>
<h3 id="–û–±—Ä–∞–±–æ—Ç–∫–∞-–ø–µ—Ä–µ—á–Ω—è-–æ—à–∏–±–æ–∫"><a class="header" href="#–û–±—Ä–∞–±–æ—Ç–∫–∞-–ø–µ—Ä–µ—á–Ω—è-–æ—à–∏–±–æ–∫">–û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–µ—Ä–µ—á–Ω—è –æ—à–∏–±–æ–∫</a></h3>
<p>–ö–æ–¥ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 9-4 –±—É–¥–µ—Ç –≤—ã–∑—ã–≤–∞—Ç—å <code>panic!</code> –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –ø—Ä–∏—á–∏–Ω—ã –Ω–µ—É–¥–∞—á–∏ –ø—Ä–∏ –≤—ã–∑–æ–≤–µ <code>File::open</code>. –û–¥–Ω–∞–∫–æ –º—ã —Ö–æ—Ç–∏–º –ø—Ä–µ–¥–ø—Ä–∏–Ω–∏–º–∞—Ç—å —Ä–∞–∑–ª–∏—á–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è –¥–ª—è —Ä–∞–∑–Ω—ã—Ö –ø—Ä–∏—á–∏–Ω —Å–±–æ—è. –î–æ–ø—É—Å—Ç–∏–º, –º—ã —Ö–æ—Ç–∏–º, —á—Ç–æ–±—ã –µ—Å–ª–∏ –æ—Ç–∫—Ä—ã—Ç–∏–µ <code>File::open</code> –Ω–µ —É–¥–∞–ª–æ—Å—å –∏–∑-–∑–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è —Ñ–∞–π–ª–∞, —Ç–æ —Ñ–∞–π–ª —Å–æ–∑–¥–∞–≤–∞–ª—Å—è –∏ –≤–æ–∑–≤—Ä–∞—â–∞–ª—Å—è –µ–≥–æ –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä. –ï—Å–ª–∏ –∂–µ –≤—ã–∑–æ–≤ <code>File::open</code> –Ω–µ —É–¥–∞–ª—Å—è –ø–æ –ª—é–±–æ–π –¥—Ä—É–≥–æ–π –ø—Ä–∏—á–∏–Ω–µ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –ø–æ—Ç–æ–º—É —á—Ç–æ —É –Ω–∞—Å –Ω–µ –±—ã–ª–æ –ø—Ä–∞–≤ –Ω–∞ –æ—Ç–∫—Ä—ã—Ç–∏–µ —Ñ–∞–π–ª–∞), —Ç–æ –º—ã –≤—Å—ë —Ç–∞–∫ –∂–µ —Ö–æ—Ç–∏–º –≤—ã–∑—ã–≤–∞—Ç—å <code>panic!</code> –∫–∞–∫ —É –Ω–∞—Å —Å–¥–µ–ª–∞–Ω–æ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 9-4. –î–ª—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–Ω–æ–≥–æ –º—ã –¥–æ–±–∞–≤–∏–º –≤–ª–æ–∂–µ–Ω–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ <code>match</code>, –∫–∞–∫ –ø–æ–∫–∞–∑–∞–Ω–æ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 9-5.</p>
<Listing number="9-5" file-name="src/main.rs" caption="Handling different kinds of errors in different ways">
<!-- ignore this test because otherwise it creates hello.txt which causes other
tests to fail lol -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; match error.kind() {
            ErrorKind::NotFound =&gt; match File::create("hello.txt") {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!("–ü—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —Ñ–∞–π–ª–∞ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: {e:?}"),
            },
            other_error =&gt; {
                panic!("–ü—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏ —Ñ–∞–π–ª–∞ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: {other_error:?}");
            }
        },
    };
}</code></pre>
</Listing>
<p>–¢–∏–ø–æ–º –∑–Ω–∞—á–µ–Ω–∏—è –æ—à–∏–±–∫–∏, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–≥–æ —Ñ—É–Ω–∫—Ü–∏–µ–π <code>File::open</code> –≤ –≤–∞—Ä–∏–∞–Ω—Ç–µ <code>Err</code>, —è–≤–ª—è–µ—Ç—Å—è <code>io::Error</code> ‚Äî —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –∏–∑ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏. –î–∞–Ω–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –∏–º–µ–µ—Ç –º–µ—Ç–æ–¥ <code>kind</code>, –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–Ω–æ –≤—ã–∑–≤–∞—Ç—å –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∑–Ω–∞—á–µ–Ω–∏—è <code>io::ErrorKind</code>. –ü–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ <code>io::ErrorKind</code> –∏–º–µ–µ—Ç –≤–∞—Ä–∏–∞–Ω—Ç—ã, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—â–∏–µ —Ä–∞–∑–ª–∏—á–Ω—ã–µ —Ç–∏–ø—ã –æ—à–∏–±–æ–∫, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç –ø–æ—è–≤–∏—Ç—å—Å—è –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –æ–ø–µ—Ä–∞—Ü–∏–π –≤–≤–æ–¥–∞-–≤—ã–≤–æ–¥–∞. –í–∞—Ä–∏–∞–Ω—Ç, –∫–æ—Ç–æ—Ä—ã–π –º—ã —Ö–æ—Ç–∏–º —Å–µ–π—á–∞—Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å ‚Äî <code>ErrorKind::NotFound</code>. –û–Ω —Å–æ–æ–±—â–∞–µ—Ç –æ —Ç–æ–º, —á—Ç–æ —Ñ–∞–π–ª, –∫–æ—Ç–æ—Ä—ã–π –º—ã –ø—ã—Ç–∞–µ–º—Å—è –æ—Ç–∫—Ä—ã—Ç—å, –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç. –í–æ –≤—Ç–æ—Ä–æ–π —Å—Ç—Ä–æ—á–∫–µ –Ω–∞—à–µ–π –ø—Ä–æ–≥—Ä–∞–º–º—ã –º—ã –ø–µ—Ä–µ–¥–∞—ë–º <code>greeting_file_result</code> –≤ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ <code>match</code>; –µ—Å–ª–∏ –ø—Ä–æ–∏–∑–æ–π–¥—ë—Ç –æ—à–∏–±–∫–∞, –º—ã –≤—ã–∑–æ–≤–µ–º –Ω–∞ –Ω–µ–π –º–µ—Ç–æ–¥ <code>kind()</code> –∏ –ø–µ—Ä–µ–¥–∞–¥–∏–º –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –≤–æ –≤–ª–æ–∂–µ–Ω–Ω—ã–π <code>match</code>.</p>
<p>–í–æ –≤–ª–æ–∂–µ–Ω–Ω–æ–º <code>match</code> –º—ã —Ö–æ—Ç–∏–º –ø—Ä–æ–≤–µ—Ä–∏—Ç—å, –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–µ —Ñ—É–Ω–∫—Ü–∏–µ–π <code>error.kind()</code>, –≤–∞—Ä–∏–∞–Ω—Ç–æ–º <code>NotFound</code> –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è <code>ErrorKind</code>. –ï—Å–ª–∏ –æ–Ω–æ —è–≤–ª—è–µ—Ç—Å—è, —Ç–æ –º—ã –ø—ã—Ç–∞–µ–º—Å—è —Å–æ–∑–¥–∞—Ç—å —Ñ–∞–π–ª —Å –ø–æ–º–æ—â—å—é <code>File::create</code>. –û–¥–Ω–∞–∫–æ, –ø–æ—Å–∫–æ–ª—å–∫—É <code>File::create</code> —Ç–æ–∂–µ –º–æ–∂–µ—Ç –∑–∞–≤–µ—Ä—à–∏—Ç—å—Å—è —Å –æ—à–∏–±–∫–æ–π, –Ω–∞–º –Ω—É–∂–Ω–∞ –≤—Ç–æ—Ä–∞—è –≤–µ—Ç–≤—å –≤–æ –≤–ª–æ–∂–µ–Ω–Ω–æ–º <code>match</code>. –ï—Å–ª–∏ —Ñ–∞–π–ª –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å —Å–æ–∑–¥–∞–Ω, –≤—ã–≤–æ–¥–∏—Ç—Å—è –∏–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ. –í—Ç–æ—Ä—É—é –≤–µ—Ç–≤—å –≤–Ω–µ—à–Ω–µ–≥–æ <code>match</code> –º—ã –Ω–µ –º–µ–Ω—è–µ–º. –ò—Ç–æ–≥–æ, –ø—Ä–æ–≥—Ä–∞–º–º–∞ –ø–∞–Ω–∏–∫—É–µ—Ç –ø—Ä–∏ –ª—é–±–æ–π –æ—à–∏–±–∫–µ, –∫—Ä–æ–º–µ –æ—à–∏–±–∫–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è —Ñ–∞–π–ª–∞.</p>
<blockquote>
<h4 id="–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤—ã-–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é-match-—Å-resultt-e"><a class="header" href="#–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤—ã-–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é-match-—Å-resultt-e">–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é <code>match</code> —Å <code>Result&lt;T, E&gt;</code></a></h4>
<p>–ö–∞–∫ –º–Ω–æ–≥–æ <code>match</code>! –í—ã—Ä–∞–∂–µ–Ω–∏–µ <code>match</code> —è–≤–ª—è–µ—Ç—Å—è –æ—á–µ–Ω—å –ø–æ–ª–µ–∑–Ω—ã–º, –Ω–æ –≤ —Ç–æ –∂–µ –≤—Ä–µ–º—è –¥–æ–≤–æ–ª—å–Ω–æ –ø—Ä–∏–º–∏—Ç–∏–≤–Ω—ã–º. –í –ì–ª–∞–≤–µ 13 –≤—ã —É–∑–Ω–∞–µ—Ç–µ –æ –∑–∞–º—ã–∫–∞–Ω–∏—è—Ö, –∫–æ—Ç–æ—Ä—ã–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è —Å–æ –º–Ω–æ–≥–∏–º–∏ –º–µ—Ç–æ–¥–∞–º–∏ —Ç–∏–ø–∞ <code>Result&lt;T, E&gt;</code>. –≠—Ç–∏ –º–µ—Ç–æ–¥—ã –∫—É–¥–∞ –ª–∞–∫–æ–Ω–∏—á–Ω–µ–µ, —á–µ–º –ø—Ä—è–º–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∑–Ω–∞—á–µ–Ω–∏–π <code>Result&lt;T, E&gt;</code> —á–µ—Ä–µ–∑ <code>match</code>.</p>
<p>–ù–∞–ø—Ä–∏–º–µ—Ä, –ø—Ä–æ–≥—Ä–∞–º–º—É –∏–∑ –õ–∏—Å—Ç–∏–Ω–≥–∞ 9-5 –º–æ–∂–Ω–æ –≤–æ—Ç —Ç–∞–∫ –ø–µ—Ä–µ–ø–∏—Å–∞—Ç—å —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –∑–∞–º—ã–∫–∞–Ω–∏–π –∏ –º–µ—Ç–æ–¥–∞ <code>unwrap_or_else</code>:</p>
<!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("–ü—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —Ñ–∞–π–ª–∞ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: {error:?}");
            })
        } else {
            panic!("–ü—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏ —Ñ–∞–π–ª–∞ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: {error:?}");
        }
    });
}</code></pre>
<p>–•–æ—Ç—è –¥–∞–Ω–Ω—ã–π –∫–æ–¥ –∏–º–µ–µ—Ç —Ç–∞–∫–æ–µ –∂–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ, –∫–∞–∫ –∏ –∫–æ–¥ –õ–∏—Å—Ç–∏–Ω–≥–∞ 9-5, –æ–Ω –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –Ω–∏ –æ–¥–Ω–æ–≥–æ –≤—ã—Ä–∞–∂–µ–Ω–∏—è <code>match</code> –∏, –ø–ª—é—Å–æ–º, –ª–µ–≥—á–µ —á–∏—Ç–∞–µ—Ç—Å—è. –†–µ–∫–æ–º–µ–Ω–¥—É–µ–º –≤–∞–º –≤–µ—Ä–Ω—É—Ç—å—Å—è –∫ —ç—Ç–æ–º—É –ø—Ä–∏–º–µ—Ä—É –ø–æ—Å–ª–µ —Ç–æ–≥–æ, –∫–∞–∫ –ø—Ä–æ—á–∏—Ç–∞–µ—Ç–µ –ì–ª–∞–≤—É 13 –∏ –∑–∞–≥–ª—è–Ω–µ—Ç–µ –≤ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é –º–µ—Ç–æ–¥–∞ <code>unwrap_or_else</code>. –° —ç—Ç–∏–º–∏ –º–µ—Ç–æ–¥–∞–º–∏ –≤—ã —Å–º–æ–∂–µ—Ç–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –æ—à–∏–±–∫–∏ –±–µ–∑ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –ø–∏—Å–∞—Ç—å –º–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤—ã–µ –≤—ã—Ä–∞–∂–µ–Ω–∏—è <code>match</code>.</p>
</blockquote>
<h4 id="–ü—Ä–æ—Å—Ç–∞—è-–ø–∞–Ω–∏–∫–∞-–ø—Ä–∏-–æ—à–∏–±–∫–µ-–º–µ—Ç–æ–¥—ã-unwrap-–∏-expect"><a class="header" href="#–ü—Ä–æ—Å—Ç–∞—è-–ø–∞–Ω–∏–∫–∞-–ø—Ä–∏-–æ—à–∏–±–∫–µ-–º–µ—Ç–æ–¥—ã-unwrap-–∏-expect">–ü—Ä–æ—Å—Ç–∞—è –ø–∞–Ω–∏–∫–∞ –ø—Ä–∏ –æ—à–∏–±–∫–µ: –º–µ—Ç–æ–¥—ã <code>unwrap</code> –∏ <code>expect</code></a></h4>
<p>–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ <code>match</code> —Ä–∞–±–æ—Ç–∞–µ—Ç –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Ö–æ—Ä–æ—à–æ, –Ω–æ –æ–Ω–æ –º–æ–∂–µ—Ç –±—ã—Ç—å –¥–æ–≤–æ–ª—å–Ω–æ –º–Ω–æ–≥–æ—Å–ª–æ–≤–Ω—ã–º –∏ –Ω–µ –≤—Å–µ–≥–¥–∞ —Ö–æ—Ä–æ—à–æ –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å —Å–º—ã—Å–ª. –¢–∏–ø <code>Result&lt;T, E&gt;</code> –∏–º–µ–µ—Ç –º–Ω–æ–∂–µ—Å—Ç–≤–æ –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã—Ö –º–µ—Ç–æ–¥–æ–≤ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Ä–∞–∑–ª–∏—á–Ω—ã—Ö, –±–æ–ª–µ–µ —Å–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫–∏—Ö –∑–∞–¥–∞—á. –ú–µ—Ç–æ–¥ <code>unwrap</code> ‚Äî —ç—Ç–æ –º–µ—Ç–æ–¥, —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π —Ç–∞–∫ –∂–µ, –∫–∞–∫ –∏ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ <code>match</code>, –∫–æ—Ç–æ—Ä–æ–µ –º—ã –Ω–∞–ø–∏—Å–∞–ª–∏ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 9-4. –ï—Å–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ <code>Result</code> —è–≤–ª—è–µ—Ç—Å—è –≤–∞—Ä–∏–∞–Ω—Ç–æ–º <code>Ok</code>, <code>unwrap</code> –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ –≤–Ω—É—Ç—Ä–∏ <code>Ok</code>. –ï—Å–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ <code>Result</code> ‚Äî –≤–∞—Ä–∏–∞–Ω—Ç <code>Err</code>, —Ç–æ <code>unwrap</code> –≤—ã–∑–æ–≤–µ—Ç –º–∞–∫—Ä–æ—Å <code>panic!</code>. –í–æ—Ç –ø—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è <code>unwrap</code>:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust should_panic edition2021">use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap();
}</code></pre></pre>
</Listing>
<p>–ï—Å–ª–∏ –º—ã –∑–∞–ø—É—Å—Ç–∏–º —ç—Ç–æ—Ç –∫–æ–¥ –ø—Ä–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–∏ —Ñ–∞–π–ª–∞ <em>hello.txt</em>, —Ç–æ —É–≤–∏–¥–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ –∏–∑ –≤—ã–∑–æ–≤–∞ <code>panic!</code> –º–µ—Ç–æ–¥–æ–º <code>unwrap</code>:</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-04-unwrap
cargo run
copy and paste relevant text
-->
<pre><code class="language-text">thread 'main' panicked at src/main.rs:4:49:
called `Result::unwrap()` on an `Err` value: Os { code: 2, kind: NotFound, message: "No such file or directory" }
</code></pre>
<p>–î—Ä—É–≥–æ–π –º–µ—Ç–æ–¥, –ø–æ—Ö–æ–∂–∏–π –Ω–∞ <code>unwrap</code> ‚Äî —ç—Ç–æ <code>expect</code>, –ø–æ–∑–≤–æ–ª—è—é—â–∏–π —É–∫–∞–∑–∞—Ç—å —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ –¥–ª—è –º–∞–∫—Ä–æ—Å–∞ <code>panic!</code>. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ <code>expect</code> –≤–º–µ—Å—Ç–æ <code>unwrap</code> —Å –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ–º —Ö–æ—Ä–æ—à–µ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è –æ–± –æ—à–∏–±–∫–µ –≤—ã—Ä–∞–∂–∞–µ—Ç –≤–∞—à–µ –Ω–∞–º–µ—Ä–µ–Ω–∏–µ –∏ –¥–µ–ª–∞–µ—Ç –±–æ–ª–µ–µ –ø—Ä–æ—Å—Ç—ã–º –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∞ –ø–∞–Ω–∏–∫–∏. –í–æ—Ç –ø—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è <code>expect</code>:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust should_panic edition2021">use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")
        .expect("hello.txt –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –¥–æ—Å—Ç—É–ø–µ–Ω —ç—Ç–æ–º—É –ø—Ä–æ–µ–∫—Ç—É");
}</code></pre></pre>
</Listing>
<p>–ú–µ—Ç–æ–¥ <code>expect</code> –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ç–∞–∫ –∂–µ, –∫–∞–∫ <code>unwrap</code>: –ª–∏–±–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä —Ñ–∞–π–ª–∞, –ª–∏–±–æ –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –º–∞–∫—Ä–æ—Å <code>panic!</code>. –ù–∞—à–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ, –ø–µ—Ä–µ–¥–∞–Ω–Ω–æ–µ <code>expect</code>, –±—É–¥–µ—Ç –ø–µ—Ä–µ–¥–∞–Ω–æ –≤ <code>panic!</code> –∏ –∑–∞–º–µ–Ω–∏—Ç —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑—É–µ–º–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ. –í–æ—Ç –∫–∞–∫ —ç—Ç–æ –≤—ã–≥–ª—è–¥–∏—Ç:</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-05-expect
cargo run
copy and paste relevant text
-->
<pre><code class="language-text">thread 'main' panicked at src/main.rs:5:10:
hello.txt –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –¥–æ—Å—Ç—É–ø–µ–Ω —ç—Ç–æ–º—É –ø—Ä–æ–µ–∫—Ç—É: Os { code: 2, kind: NotFound, message: "No such file or directory" }
</code></pre>
<p>–í —Ä–µ–∞–ª—å–Ω—ã—Ö –ø—Ä–æ–≥—Ä–∞–º–º–∞—Ö —á–∞—Å—Ç–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è <code>expect</code> –≤–º–µ—Å—Ç–æ <code>unwrap</code>, –∞ —Ç–∞–∫–∂–µ –¥–æ–±–∞–≤–ª—è–µ—Ç—Å—è –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –æ —Ç–æ–º, –ø–æ—á–µ–º—É –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ—Ç—Å—è, —á—Ç–æ –æ—à–∏–±–∫–∏ –Ω–µ –ø—Ä–æ–∏–∑–æ–π–¥—ë—Ç. –î–∞–∂–µ –µ—Å–ª–∏ –ø—Ä–µ–¥–ø–æ–ª–æ–∂–µ–Ω–∏–µ –æ–∫–∞–∂–µ—Ç—Å—è –Ω–µ–≤–µ—Ä–Ω—ã–º, —É –≤–∞—Å –±—É–¥–µ—Ç –±–æ–ª—å—à–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏.</p>
<h3 id="–ü—Ä–æ–±—Ä–æ—Å-–æ—à–∏–±–æ–∫"><a class="header" href="#–ü—Ä–æ–±—Ä–æ—Å-–æ—à–∏–±–æ–∫">–ü—Ä–æ–±—Ä–æ—Å –æ—à–∏–±–æ–∫</a></h3>
<p>–ï—Å–ª–∏ –≤—ã –ø–∏—à–µ—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é, —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ—Ç–æ—Ä–æ–π –≤—ã–∑—ã–≤–∞–µ—Ç —á—Ç–æ-—Ç–æ, —á—Ç–æ –º–æ–∂–µ—Ç –∑–∞–≤–µ—Ä—à–∏—Ç—å—Å—è –æ—à–∏–±–∫–æ–π, —Ç–æ –≤–º–µ—Å—Ç–æ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–∫–∏ –≤ —ç—Ç–æ–π –∂–µ —Ñ—É–Ω–∫—Ü–∏–∏ –≤—ã –º–æ–∂–µ—Ç–µ –≤–µ—Ä–Ω—É—Ç—å –≤ –≤—ã–∑—ã–≤–∞—é—â–∏–π –∫–æ–¥ –æ—à–∏–±–∫—É —Ü–µ–ª–∏–∫–æ–º, —á—Ç–æ–±—ã —É–∂–µ –æ–Ω –º–æ–≥ —Ä–µ—à–∏—Ç—å, —á—Ç–æ —Å –Ω–µ–π –¥–µ–ª–∞—Ç—å. –¢–∞–∫–æ–π –ø—Ä–∏—ë–º –∏–∑–≤–µ—Å—Ç–µ–Ω –∫–∞–∫ <em>–ø—Ä–æ–±—Ä–æ—Å –æ—à–∏–±–∫–∏</em>. –ë–ª–∞–≥–æ–¥–∞—Ä—è –Ω–µ–º—É –º—ã –¥–∞—ë–º –±–æ–ª—å—à–µ –∫–æ–Ω—Ç—Ä–æ–ª—è –≤—ã–∑—ã–≤–∞—é—â–µ–º—É –∫–æ–¥—É, –∫–æ—Ç–æ—Ä–æ–º—É –º–æ–∂–µ—Ç –±—ã—Ç—å —è—Å–Ω–µ–µ, –∫–∞–∫ —Å–ª–µ–¥—É–µ—Ç –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –æ—à–∏–±–∫—É.</p>
<p>–ù–∞–ø—Ä–∏–º–µ—Ä, –∫–æ–¥ –õ–∏—Å—Ç–∏–Ω–≥–∞ 9-6 —Å–æ–¥–µ—Ä–∂–∏—Ç —Ñ—É–Ω–∫—Ü–∏—é, —á–∏—Ç–∞—é—â—É—é –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ —Ñ–∞–π–ª–∞. –ï—Å–ª–∏ —Ñ–∞–π–ª –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∏–ª–∏ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—Ä–æ—á—Ç—ë–Ω, —Ç–æ —Ñ—É–Ω–∫—Ü–∏—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ—à–∏–±–∫—É –≤ –∫–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –≤—ã–∑–≤–∞–ª –¥–∞–Ω–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é.</p>
<Listing number="9-6" file-name="src/main.rs" caption="A function that returns errors to the calling code using `match`">
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let username_file_result = File::open("hello.txt");

    let mut username_file = match username_file_result {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&amp;mut username) {
        Ok(_) =&gt; Ok(username),
        Err(e) =&gt; Err(e),
    }
}
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–∞–ø–∏—Å–∞–Ω–∞ –≥–æ—Ä–∞–∑–¥–æ –±–æ–ª–µ–µ –∫–æ—Ä–æ—Ç–∫–∏–º —Å–ø–æ—Å–æ–±–æ–º, –Ω–æ –º—ã –Ω–∞—á–Ω—ë–º —Å —Ç–æ–≥–æ, —á—Ç–æ –º–Ω–æ–≥–æ–µ —Å–¥–µ–ª–∞–µ–º –≤—Ä—É—á–Ω—É—é, —á—Ç–æ–±—ã –¥–∞—Ç—å –≤–∞–º –ø–æ–Ω–∏–º–∞–Ω–∏–µ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫; –≤ –∫–æ–Ω—Ü–µ –ø–æ–∫–∞–∂–µ–º –±–æ–ª–µ–µ –∫–æ—Ä–æ—Ç–∫–∏–π —Å–ø–æ—Å–æ–±. –î–∞–≤–∞–π—Ç–µ —Å–Ω–∞—á–∞–ª–∞ —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º —Ç–∏–ø –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è: <code>Result&lt;String, io::Error&gt;</code>. –¢–æ –µ—Å—Ç—å, –Ω–∞—à–∞ —Ñ—É–Ω–∫—Ü–∏—è –±—É–¥–µ—Ç –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å —Ç–∏–ø <code>Result&lt;T, E&gt;</code> –≥–¥–µ –ø–∞—Ä–∞–º–µ—Ç—Ä –æ–±–æ–±—â—ë–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞ <code>T</code> –±—ã–ª –∑–∞–º–µ–Ω—ë–Ω –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º —Ç–∏–ø–æ–º <code>String</code>, –∞ <code>E</code> ‚Äî —Ç–∏–ø–æ–º <code>io::Error</code>.</p>
<p>–ï—Å–ª–∏ —ç—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –≤—ã–ø–æ–ª–Ω–∏—Ç—Å—è –±–µ–∑ –ø—Ä–æ–±–ª–µ–º, —Ç–æ –∫–æ–¥, –≤—ã–∑—ã–≤–∞—é—â–∏–π —ç—Ç—É —Ñ—É–Ω–∫—Ü–∏—é, –ø–æ–ª—É—á–∏—Ç –∑–Ω–∞—á–µ–Ω–∏–µ <code>Ok</code>, —Å–æ–¥–µ—Ä–∂–∞—â–µ–µ <code>String</code> ‚Äî –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –ø—Ä–æ—á–∏—Ç–∞–Ω–Ω–æ–µ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–µ–π –∏–∑ —Ñ–∞–π–ª–∞. –ï—Å–ª–∏ —Ñ—É–Ω–∫—Ü–∏—è —Å—Ç–æ–ª–∫–Ω—ë—Ç—Å—è —Å –∫–∞–∫–∏–º–∏-–ª–∏–±–æ –ø—Ä–æ–±–ª–µ–º–∞–º–∏, –≤—ã–∑—ã–≤–∞—é—â–∏–π –∫–æ–¥ –ø–æ–ª—É—á–∏—Ç –∑–Ω–∞—á–µ–Ω–∏–µ <code>Err</code>, —Å–æ–¥–µ—Ä–∂–∞—â–µ–µ —ç–∫–∑–µ–º–ø–ª—è—Ä <code>io::Error</code>, –∫–æ—Ç–æ—Ä—ã–π —Å–æ–¥–µ—Ä–∂–∏—Ç –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–æ–º, –∫–∞–∫–∏–µ –ø—Ä–æ–±–ª–µ–º—ã –≤–æ–∑–Ω–∏–∫–ª–∏. –ú—ã –≤—ã–±—Ä–∞–ª–∏ <code>io::Error</code> –≤ –∫–∞—á–µ—Å—Ç–≤–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–≥–æ —Ç–∏–ø–∞ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏, –ø–æ—Å–∫–æ–ª—å–∫—É –æ–Ω ‚Äî —Ç–∏–ø –∑–Ω–∞—á–µ–Ω–∏—è –æ—à–∏–±–∫–∏, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–≥–æ –∏–∑ –æ–±–µ–∏—Ö –æ–ø–µ—Ä–∞—Ü–∏–π, –∫–æ—Ç–æ—Ä—ã–µ –º—ã –≤—ã–∑—ã–≤–∞–µ–º –≤ —Ç–µ–ª–µ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –∏ –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç –∑–∞–≤–µ—Ä—à–∏—Ç—å—Å—è –Ω–µ—É–¥–∞—á–µ–π: —Ñ—É–Ω–∫—Ü–∏–∏ <code>File::open</code> –∏ –º–µ—Ç–æ–¥–∞ <code>read_to_string</code>.</p>
<p>–¢–µ–ª–æ —Ñ—É–Ω–∫—Ü–∏–∏ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å –≤—ã–∑–æ–≤–∞ <code>File::open</code>. –ó–∞—Ç–µ–º –º—ã –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ <code>Result</code> —Å –ø–æ–º–æ—â—å—é <code>match</code>, –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ <code>match</code> –∏–∑ –î–∏—Å—Ç–∏–Ω–≥–∞ 9-4. –ï—Å–ª–∏ <code>File::open</code> –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è —É—Å–ø–µ—à–Ω–æ, —Ç–æ –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä —Ñ–∞–π–ª–∞ –≤ <code>file</code> (–ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π —à–∞–±–ª–æ–Ω–∞) —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –∑–Ω–∞—á–µ–Ω–∏–µ–º –≤ –∏–∑–º–µ–Ω—è–µ–º–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π <code>username_file</code>, –∏ —Ñ—É–Ω–∫—Ü–∏—è –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç —Å–≤–æ—é —Ä–∞–±–æ—Ç—É. –í —Å–ª—É—á–∞–µ –Ω–µ—É–¥–∞—á–∏, –≤–º–µ—Å—Ç–æ –≤—ã–∑–æ–≤–∞ <code>panic!</code> –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ <code>return</code> –¥–ª—è –¥–æ—Å—Ä–æ—á–Ω–æ–≥–æ –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∏—è –∑–Ω–∞—á–µ–Ω–∏—è –æ—à–∏–±–∫–∏ –∏–∑ <code>File::open</code> (–∫–æ—Ç–æ—Ä–æ–µ –±—ã–ª–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ –≤ <code>e</code> ‚Äî –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π —à–∞–±–ª–æ–Ω–∞) –æ–±—Ä–∞—Ç–Ω–æ –≤ –≤—ã–∑—ã–≤–∞—é—â–∏–π –∫–æ–¥ –∫–∞–∫ –∑–Ω–∞—á–µ–Ω–∏–µ –æ—à–∏–±–∫–∏ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏.</p>
<p>–¢–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, –µ—Å–ª–∏ —É –Ω–∞—Å –µ—Å—Ç—å —Ñ–∞–π–ª–æ–≤—ã–π –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä –≤ <code>username_file</code>, —Ñ—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞—ë—Ç –Ω–æ–≤—É—é <code>String</code> –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π <code>username</code> –∏ –≤—ã–∑—ã–≤–∞–µ—Ç –º–µ—Ç–æ–¥ <code>read_to_string</code> –Ω–∞ —Ñ–∞–π–ª–æ–≤–æ–º –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä–µ (–∫–æ—Ç–æ—Ä—ã–π –≤ <code>username_file</code>), —á—Ç–æ–±—ã –∑–∞–ø–∏—Å–∞—Ç—å —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ñ–∞–π–ª–∞ –≤ <code>username</code>. –ú–µ—Ç–æ–¥ <code>read_to_string</code> —Ç–∞–∫–∂–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç <code>Result</code>, –ø–æ—Ç–æ–º—É —á—Ç–æ –æ–Ω –º–æ–∂–µ—Ç –ø–æ—Ç–µ—Ä–ø–µ—Ç—å –Ω–µ—É–¥–∞—á—É, –¥–∞–∂–µ –µ—Å–ª–∏ <code>File::open</code> –∑–∞–≤–µ—Ä—à–∏–ª—Å—è —É—Å–ø–µ—à–Ω–æ. –ü–æ—ç—Ç–æ–º—É –Ω–∞–º –Ω—É–∂–µ–Ω –µ—â—ë –æ–¥–∏–Ω <code>match</code> –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —ç—Ç–æ–≥–æ <code>Result</code>. –ï—Å–ª–∏ <code>read_to_string</code> –∑–∞–≤–µ—Ä—à–∏—Ç—Å—è —É—Å–ø–µ—à–Ω–æ, —Ç–æ –Ω–∞—à–∞ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –≤—ã–ø–æ–ª–Ω–∏–ª–∞ —Å–≤–æ—é —Ä–∞–±–æ—Ç—É, –∞ –ø–æ—Ç–æ–º—É –º—ã –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∏–∑ –Ω–µ—ë –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ —Ñ–∞–π–ª–∞ (–∫–æ—Ç–æ—Ä–æ–µ —Ç–µ–ø–µ—Ä—å –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ <code>username</code>), –æ–±–µ—Ä–Ω—É–≤ –µ–≥–æ –≤ <code>Ok</code>. –ï—Å–ª–∏ –∂–µ <code>read_to_string</code> –ø–æ—Ç–µ—Ä–ø–∏—Ç –Ω–µ—É–¥–∞—á—É, –º—ã –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ –æ—à–∏–±–∫–∏ —Ç–∞–∫–∏–º –∂–µ –æ–±—Ä–∞–∑–æ–º, –∫–∞–∫ –º—ã –≤–æ–∑–≤—Ä–∞—â–∞–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ –æ—à–∏–±–∫–∏ –≤ <code>match</code>, –∫–æ—Ç–æ—Ä—ã–π –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–ª –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ <code>File::open</code>. –û–¥–Ω–∞–∫–æ –Ω–∞–º –Ω–µ –Ω—É–∂–Ω–æ —è–≤–Ω–æ —É–∫–∞–∑—ã–≤–∞—Ç—å <code>return</code>, –ø–æ—Ç–æ–º—É —á—Ç–æ –≤—Å—ë —ç—Ç–æ ‚Äî –ø–æ—Å–ª–µ–¥–Ω–µ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ –≤ —Ñ—É–Ω–∫—Ü–∏–∏.</p>
<p>–ü–æ—Å–ª–µ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è —Ñ—É–Ω–∫—Ü–∏–∏ –∫–æ–¥, –≤—ã–∑—ã–≤–∞—é—â–∏–π –µ–π, –±—É–¥–µ—Ç –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –ø–æ–ª—É—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: –ª–∏–±–æ <code>Ok</code>, —Å–æ–¥–µ—Ä–∂–∞—â–µ–µ –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –ª–∏–±–æ —Ä–∞–∑–ª–∏—á–Ω—ã–µ <code>Err</code>, —Å–æ–¥–µ—Ä–∂–∞—â–∏–µ –æ—à–∏–±–∫–∏ —Ç–∏–ø–∞ <code>io::Error</code>. –í—ã–∑—ã–≤–∞—é—â–∏–π –∫–æ–¥ –¥–æ–ª–∂–µ–Ω –±—É–¥–µ—Ç —Ä–µ—à–∏—Ç—å, —á—Ç–æ –¥–µ–ª–∞—Ç—å —Å —ç—Ç–∏–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏. –ï—Å–ª–∏ –≤—ã–∑—ã–≤–∞—é—â–∏–π –∫–æ–¥ –ø–æ–ª—É—á–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ <code>Err</code>, –æ–Ω –º–æ–∂–µ—Ç –≤—ã–∑–≤–∞—Ç—å <code>panic!</code> –∏ –∑–∞–≤–µ—Ä—à–∏—Ç—å —Ä–∞–±–æ—Ç—É –ø—Ä–æ–≥—Ä–∞–º–º—ã; –º–æ–∂–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é; –º–æ–∂–µ—Ç –Ω–∞–π—Ç–∏ –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –Ω–∞–ø—Ä–∏–º–µ—Ä, –Ω–µ –≤ —Ñ–∞–π–ª–µ. –£ –Ω–∞—Å –Ω–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ç–æ–º, —á—Ç–æ –Ω–∞ —Å–∞–º–æ–º –¥–µ–ª–µ –ø—ã—Ç–∞–µ—Ç—Å—è —Å–¥–µ–ª–∞—Ç—å –≤—ã–∑—ã–≤–∞—é—â–∏–π –∫–æ–¥, –ø–æ—ç—Ç–æ–º—É –º—ã –ø—Ä–æ–±—Ä–∞—Å—ã–≤–∞–µ–º –≤—Å—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± —É—Å–ø–µ—Ö–µ –∏–ª–∏ –æ—à–∏–±–∫–∞—Ö "–≤—ã—à–µ", —á—Ç–æ–±—ã –æ–Ω–∞ –º–æ–≥–ª–∞ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å—Å—è —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–º –æ–±—Ä–∞–∑–æ–º.</p>
<p>–≠—Ç–∞ —Å—Ö–µ–º–∞ –ø—Ä–æ–±—Ä–æ—Å–∞ –æ—à–∏–±–æ–∫ —Å—Ç–æ–ª—å —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–∞, —á—Ç–æ –≤ Rust –±—ã–ª –¥–æ–±–∞–≤–ª–µ–Ω –æ–ø–µ—Ä–∞—Ç–æ—Ä –≤–æ–ø—Ä–æ—Å–∏—Ç–µ–ª—å–Ω–æ–≥–æ –∑–Ω–∞–∫–∞ <code>?</code>, —É–ø—Ä–æ—â–∞—é—â–∏–π –ø—Ä–æ–¥–µ–ª–∞–Ω–Ω—É—é –Ω–∞–º–∏ —Ä–∞–±–æ—Ç—É.</p>
<h4 id="–ü—Ä–æ—Å—Ç–æ–π-–ø—Ä–æ–±—Ä–æ—Å-–æ—à–∏–±–∫–∏-–æ–ø–µ—Ä–∞—Ç–æ—Ä-"><a class="header" href="#–ü—Ä–æ—Å—Ç–æ–π-–ø—Ä–æ–±—Ä–æ—Å-–æ—à–∏–±–∫–∏-–æ–ø–µ—Ä–∞—Ç–æ—Ä-">–ü—Ä–æ—Å—Ç–æ–π –ø—Ä–æ–±—Ä–æ—Å –æ—à–∏–±–∫–∏: –æ–ø–µ—Ä–∞—Ç–æ—Ä <code>?</code></a></h4>
<p>–í –õ–∏—Å—Ç–∏–Ω–≥–µ 9-7 –ø–æ–∫–∞–∑–∞–Ω–∞ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è <code>read_username_from_file</code>, –∫–æ—Ç–æ—Ä–∞—è –∏–º–µ–µ—Ç —Ç—É –∂–µ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å, —á—Ç–æ –∏ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 9-6, –Ω–æ –≤ —ç—Ç–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –æ–ø–µ—Ä–∞—Ç–æ—Ä <code>?</code>.</p>
<Listing number="9-7" file-name="src/main.rs" caption="A function that returns errors to the calling code using the `?` operator">
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username_file = File::open("hello.txt")?;
    let mut username = String::new();
    username_file.read_to_string(&amp;mut username)?;
    Ok(username)
}
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>–û–ø–µ—Ä–∞—Ç–æ—Ä <code>?</code>, —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–Ω—ã–π –ø–æ—Å–ª–µ <code>Result</code>, —Ä–∞–±–æ—Ç–∞–µ—Ç –ø–æ—á—Ç–∏ —Ç–∞–∫ –∂–µ, –∫–∞–∫ –∏ —Ç–µ –≤—ã—Ä–∞–∂–µ–Ω–∏—è <code>match</code>, –∫–æ—Ç–æ—Ä—ã–µ –º—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–Ω–∞—á–µ–Ω–∏–π <code>Result</code> –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 9-6. –ï—Å–ª–∏ –≤ –∫–∞—á–µ—Å—Ç–≤–µ –∑–Ω–∞—á–µ–Ω–∏—è <code>Result</code> –±—É–¥–µ—Ç <code>Ok</code>, —Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ –≤–Ω—É—Ç—Ä–∏ <code>Ok</code> –±—É–¥–µ—Ç –≤–æ–∑–≤—Ä–∞—â–µ–Ω–æ –∏–∑ —ç—Ç–æ–≥–æ –≤—ã—Ä–∞–∂–µ–Ω–∏—è, –∏ –ø—Ä–æ–≥—Ä–∞–º–º–∞ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç —Ä–∞–±–æ—Ç—É. –ï—Å–ª–∏ –∂–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Å–æ–±–æ–π <code>Err</code>, —Ç–æ <code>Err</code> –±—É–¥–µ—Ç –≤–æ–∑–≤—Ä–∞—â–µ–Ω–æ –∏–∑ –≤—Å–µ–π —Ñ—É–Ω–∫—Ü–∏–∏, –∫–∞–∫ –µ—Å–ª–∏ –±—ã –º—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ <code>return</code>, —Ç–∞–∫ —á—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ –æ—à–∏–±–∫–∏ –±—É–¥–µ—Ç –ø–µ—Ä–µ–¥–∞–Ω–æ –≤ –≤—ã–∑—ã–≤–∞—é—â–∏–π –∫–æ–¥.</p>
<p>–°—É—â–µ—Å—Ç–≤—É–µ—Ç —Ä–∞–∑–Ω–∏—Ü–∞ –º–µ–∂–¥—É —Ç–µ–º, —á—Ç–æ –¥–µ–ª–∞–µ—Ç –≤—ã—Ä–∞–∂–µ–Ω–∏–µ <code>match</code> –∏–∑ –õ–∏—Å—Ç–∏–Ω–≥–∞ 9-6 –∏ —Ç–µ–º, —á—Ç–æ –¥–µ–ª–∞–µ—Ç –æ–ø–µ—Ä–∞—Ç–æ—Ä <code>?</code>: –∑–Ω–∞—á–µ–Ω–∏—è –æ—à–∏–±–æ–∫, –¥–ª—è –∫–æ—Ç–æ—Ä—ã—Ö –≤—ã–∑–≤–∞–Ω –æ–ø–µ—Ä–∞—Ç–æ—Ä <code>?</code>, –ø—Ä–æ—Ö–æ–¥—è—Ç —á–µ—Ä–µ–∑ —Ñ—É–Ω–∫—Ü–∏—é <code>from</code>, –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—É—é –≤ —Ç—Ä–µ–π—Ç–µ <code>From</code> —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏, –∫–æ—Ç–æ—Ä–∞—è –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –∑–Ω–∞—á–µ–Ω–∏–π –∏–∑ –æ–¥–Ω–æ–≥–æ —Ç–∏–ø–∞ –≤ –¥—Ä—É–≥–æ–π. –ö–æ–≥–¥–∞ –æ–ø–µ—Ä–∞—Ç–æ—Ä <code>?</code> –≤—ã–∑—ã–≤–∞–µ—Ç —Ñ—É–Ω–∫—Ü–∏—é <code>from</code>, –ø–æ–ª—É—á–µ–Ω–Ω—ã–π —Ç–∏–ø –æ—à–∏–±–∫–∏ –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç—Å—è –≤ —Ç–∏–ø –æ—à–∏–±–∫–∏, –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã–π –≤ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–º —Ç–∏–ø–µ —Ç–µ–∫—É—â–µ–π —Ñ—É–Ω–∫—Ü–∏–∏. –≠—Ç–æ –ø–æ–ª–µ–∑–Ω–æ, –∫–æ–≥–¥–∞ —Ñ—É–Ω–∫—Ü–∏—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ç–∏–ø –æ—à–∏–±–∫–∏, –¥–ª—è –æ–ø–∏—Å–∞–Ω–∏—è –≤—Å–µ—Ö –≤–æ–∑–º–æ–∂–Ω—ã—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ —Å–±–æ–µ–≤, –¥–∞–∂–µ –µ—Å–ª–∏ –µ—ë –æ—Ç–¥–µ–ª—å–Ω—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –º–æ–≥—É—Ç –≤—ã—Ö–æ–¥–∏—Ç—å –∏–∑ —Å—Ç—Ä–æ—è –ø–æ —Ä–∞–∑–Ω—ã–º –ø—Ä–∏—á–∏–Ω–∞–º.</p>
<p>–ù–∞–ø—Ä–∏–º–µ—Ä, –º—ã –º–æ–≥–ª–∏ –±—ã –∏–∑–º–µ–Ω–∏—Ç—å —Ñ—É–Ω–∫—Ü–∏—é <code>read_username_from_file</code> –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 9-7 —Ç–∞–∫, —á—Ç–æ–±—ã –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π —Ç–∏–ø –æ—à–∏–±–∫–∏ –ø–æ–¥ –∏–º–µ–Ω–µ–º <code>OurError</code>. –ï—Å–ª–∏ –º—ã –æ–ø—Ä–µ–¥–µ–ª–∏–º <code>impl From&lt;io::Error&gt; for OurError</code> (—á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å —Å–æ–∑–¥–∞–≤–∞—Ç—å —ç–∫–∑–µ–º–ø–ª—è—Ä—ã <code>OurError</code> –∏–∑ <code>io::Error</code>), —Ç–æ –æ–ø–µ—Ä–∞—Ç–æ—Ä <code>?</code>, –≤—ã–∑—ã–≤–∞–µ–º—ã–π –≤ —Ç–µ–ª–µ <code>read_username_from_file</code>, –≤—ã–∑–æ–≤–µ—Ç <code>from</code> –∏ –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Ç–∏–ø—ã –æ—à–∏–±–æ–∫ –±–µ–∑ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–≥–æ –∫–æ–¥–∞ –≤ —Ñ—É–Ω–∫—Ü–∏—é.</p>
<p>–û–±—Ä–∞—â–∞—è—Å—å –∫ –õ–∏—Å—Ç–∏–Ω–≥—É 9-7 –∫–∞–∫ –∫ –ø—Ä–∏–º–µ—Ä—É, –æ–ø–µ—Ä–∞—Ç–æ—Ä <code>?</code> –≤ –∫–æ–Ω—Ü–µ –≤—ã–∑–æ–≤–∞ <code>File::open</code> –≤–µ—Ä–Ω—ë—Ç –∑–Ω–∞—á–µ–Ω–∏–µ –≤–Ω—É—Ç—Ä–∏ <code>Ok</code> –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é <code>username_file</code>. –ï—Å–ª–∏ –ø—Ä–æ–∏–∑–æ–π–¥—ë—Ç –æ—à–∏–±–∫–∞, –æ–ø–µ—Ä–∞—Ç–æ—Ä <code>?</code> –≤—ã–ø–æ–ª–Ω–∏—Ç –ø—Ä–µ–∂–¥–µ–≤—Ä–µ–º–µ–Ω–Ω—ã–π –≤–æ–∑–≤—Ä–∞—Ç –∑–Ω–∞—á–µ–Ω–∏—è <code>Err</code> –≤—ã–∑—ã–≤–∞—é—â–µ–º—É –∫–æ–¥—É. –¢–æ –∂–µ —Å–∞–º–æ–µ –æ—Ç–Ω–æ—Å–∏—Ç—Å—è –∫ –æ–ø–µ—Ä–∞—Ç–æ—Ä—É <code>?</code> –≤ –∫–æ–Ω—Ü–µ –≤—ã–∑–æ–≤–∞ <code>read_to_string</code>.</p>
<p>–û–ø–µ—Ä–∞—Ç–æ—Ä <code>?</code> –ø–æ–∑–≤–æ–ª–∏–ª –∏–∑–±–∞–≤–∏—Ç—å—Å—è –æ—Ç –±–æ–ª—å—à–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —à–∞–±–ª–æ–Ω–Ω–æ–≥–æ –∫–æ–¥–∞ –∏ —É–ø—Ä–æ—Å—Ç–∏—Ç—å —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏. –ú—ã –º–æ–≥–ª–∏ –±—ã –¥–∞–∂–µ –µ—â—ë –±–æ–ª—å—à–µ —Å–æ–∫—Ä–∞—Ç–∏—Ç—å —ç—Ç–æ—Ç –∫–æ–¥, –µ—Å–ª–∏ –±—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ —Ü–µ–ø–æ—á–∫—É –≤—ã–∑–æ–≤–æ–≤ –º–µ—Ç–æ–¥–æ–≤ —Å—Ä–∞–∑—É –ø–æ—Å–ª–µ <code>?</code>, –∫–∞–∫ –ø–æ–∫–∞–∑–∞–Ω–æ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 9-8.</p>
<Listing number="9-8" file-name="src/main.rs" caption="Chaining method calls after the `?` operator">
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username = String::new();

    File::open("hello.txt")?.read_to_string(&amp;mut username)?;

    Ok(username)
}
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>–ú—ã –ø–µ—Ä–µ–Ω–µ—Å–ª–∏ —Å–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–π <code>String</code> –≤ <code>username</code> –≤ –Ω–∞—á–∞–ª–æ —Ñ—É–Ω–∫—Ü–∏–∏; —ç—Ç–∞ —á–∞—Å—Ç—å –Ω–µ –∏–∑–º–µ–Ω–∏–ª–∞—Å—å. –í–º–µ—Å—Ç–æ —Å–æ–∑–¥–∞–Ω–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π <code>username_file</code>, –º—ã –≤—ã–∑–≤–∞–ª–∏ <code>read_to_string</code> –Ω–µ–ø–æ—Å—Ä–µ–¥—Å—Ç–≤–µ–Ω–Ω–æ –Ω–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–µ <code>File::open("hello.txt")?</code>. –£ –Ω–∞—Å –ø–æ-–ø—Ä–µ–∂–Ω–µ–º—É –µ—Å—Ç—å <code>?</code> –≤ –∫–æ–Ω—Ü–µ –≤—ã–∑–æ–≤–∞ <code>read_to_string</code>, –∏ –º—ã –ø–æ-–ø—Ä–µ–∂–Ω–µ–º—É –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ <code>Ok</code>, —Å–æ–¥–µ—Ä–∂–∞—â–µ–µ <code>username</code>, –∫–æ–≥–¥–∞ –∏ <code>File::open</code> –∏ <code>read_to_string</code> –∑–∞–≤–µ—Ä—à–∞—é—Ç—Å—è —É—Å–ø–µ—à–Ω–æ, –∞ –Ω–µ –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç –æ—à–∏–±–∫–∏. –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å —Å–Ω–æ–≤–∞ —Ç–∞–∫–∞—è –∂–µ, –∫–∞–∫ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 9-6 –∏ –õ–∏—Å—Ç–∏–Ω–≥–µ 9-7; —ç—Ç–æ –ø—Ä–æ—Å—Ç–æ –¥—Ä—É–≥–æ–π, –±–æ–ª–µ–µ —ç—Ä–≥–æ–Ω–æ–º–∏—á–Ω—ã–π —Å–ø–æ—Å–æ–± –µ—ë –Ω–∞–ø–∏—Å–∞–Ω–∏—è.</p>
<p>–õ–∏—Å—Ç–∏–Ω–≥ 9-9 –¥–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä—É–µ—Ç –µ—â—ë –±–æ–ª–µ–µ –∫–æ—Ä–æ—Ç–∫–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –Ω–∞—à–µ–π —Ñ—É–Ω–∫—Ü–∏–∏ —Å –ø–æ–º–æ—â—å—é <code>fs::read_to_string</code>.</p>
<Listing number="9-9" file-name="src/main.rs" caption="Using `fs::read_to_string` instead of opening and then reading the file">
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::io;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    fs::read_to_string("hello.txt")
}
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>–ß—Ç–µ–Ω–∏–µ —Ñ–∞–π–ª–∞ –≤ —Å—Ç—Ä–æ–∫—É ‚Äî –¥–æ–≤–æ–ª—å–Ω–æ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—ë–Ω–Ω–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è, —Ç–∞–∫ —á—Ç–æ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç —É–¥–æ–±–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é <code>fs::read_to_string</code>, –∫–æ—Ç–æ—Ä–∞—è –æ—Ç–∫—Ä—ã–≤–∞–µ—Ç —Ñ–∞–π–ª, —Å–æ–∑–¥–∞—ë—Ç –Ω–æ–≤—É—é <code>String</code>, —á–∏—Ç–∞–µ—Ç —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ñ–∞–π–ª–∞, —Ä–∞–∑–º–µ—â–∞–µ—Ç –µ–≥–æ –≤ <code>String</code> –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –µ—ë. –ö–æ–Ω–µ—á–Ω–æ, –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ <code>fs::read_to_string</code> –Ω–µ –¥–∞—ë—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –æ–±—ä—è—Å–Ω–∏—Ç—å –æ–±—Ä–∞–±–æ—Ç–∫—É –≤—Å–µ—Ö –æ—à–∏–±–æ–∫, –ø–æ—ç—Ç–æ–º—É –º—ã —Å–Ω–∞—á–∞–ª–∞ –∏–∑—É—á–∏–ª–∏ –¥–ª–∏–Ω–Ω—ã–π —Å–ø–æ—Å–æ–±.</p>
<h4 id="–ì–¥–µ-–º–æ–∂–Ω–æ-–∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å-–æ–ø–µ—Ä–∞—Ç–æ—Ä-"><a class="header" href="#–ì–¥–µ-–º–æ–∂–Ω–æ-–∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å-–æ–ø–µ—Ä–∞—Ç–æ—Ä-">–ì–¥–µ –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –æ–ø–µ—Ä–∞—Ç–æ—Ä <code>?</code></a></h4>
<p>–û–ø–µ—Ä–∞—Ç–æ—Ä <code>?</code> –º–æ–∂–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è —Ç–æ–ª—å–∫–æ –≤ —Ñ—É–Ω–∫—Ü–∏—è—Ö, —Ç–∏–ø –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è –∫–æ—Ç–æ—Ä—ã—Ö —Å–æ–≤–º–µ—Å—Ç–∏–º —Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º, –¥–ª—è –∫–æ—Ç–æ—Ä–æ–≥–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è <code>?</code>. –≠—Ç–æ –ø–æ—Ç–æ–º—É —á—Ç–æ –æ–ø–µ—Ä–∞—Ç–æ—Ä <code>?</code> –æ–ø—Ä–µ–¥–µ–ª—ë–Ω —Ç–∞–∫, —á—Ç–æ–±—ã –≤—ã–ø–æ–ª–Ω—è—Ç—å –ø—Ä–µ–∂–¥–µ–≤—Ä–µ–º–µ–Ω–Ω—ã–π –≤–æ–∑–≤—Ä–∞—Ç –∑–Ω–∞—á–µ–Ω–∏—è –∏–∑ —Ñ—É–Ω–∫—Ü–∏–∏ —Ç–∞–∫–∏–º –∂–µ –æ–±—Ä–∞–∑–æ–º, –∫–∞–∫ –∏ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ <code>match</code>, –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–µ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 9-6. –í –õ–∏—Å—Ç–∏–Ω–≥–µ 9-6 <code>match</code> –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–æ –∑–Ω–∞—á–µ–Ω–∏–µ <code>Result</code>, –∞ –≤–µ—Ç–≤—å —Å –ø—Ä–µ–∂–¥–µ–≤—Ä–µ–º–µ–Ω–Ω—ã–º –≤–æ–∑–≤—Ä–∞—Ç–æ–º –∑–Ω–∞—á–µ–Ω–∏—è –≤–µ—Ä–Ω—É–ª–∞ –∑–Ω–∞—á–µ–Ω–∏–µ <code>Err(e)</code>. –¢–∏–ø –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è —Ñ—É–Ω–∫—Ü–∏–∏ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å <code>Result</code>, —á—Ç–æ–±—ã –æ–Ω –±—ã–ª —Å–æ–≤–º–µ—Å—Ç–∏–º —Å —ç—Ç–∏–º <code>return</code>.</p>
<p>–î–∞–≤–∞–π—Ç–µ –ø–æ—Å–º–æ—Ç—Ä–∏–º –Ω–∞ –æ—à–∏–±–∫—É, –∫–æ—Ç–æ—Ä—É—é –º—ã –ø–æ–ª—É—á–∏–º, –µ—Å–ª–∏ –≤–æ—Å–ø–æ–ª—å–∑—É–µ–º—Å—è –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–º <code>?</code> –≤ —Ñ—É–Ω–∫—Ü–∏–∏ <code>main</code> —Å —Ç–∏–ø–æ–º –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è, –Ω–µ—Å–æ–≤–º–µ—Å—Ç–∏–º—ã–º —Å —Ç–∏–ø–æ–º –∑–Ω–∞—á–µ–Ω–∏—è, –¥–ª—è –∫–æ—Ç–æ—Ä–æ–≥–æ –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º <code>?</code>. –í–∑–≥–ª—è–Ω–∏—Ç–µ –Ω–∞ –õ–∏—Å—Ç–∏–Ω–≥ 9-10:</p>
<Listing number="9-10" file-name="src/main.rs" caption="Attempting to use the `?` in the `main` function that returns `()` won‚Äôt compile.">
<pre><code class="language-rust ignore does_not_compile">use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")?;
}</code></pre>
</Listing>
<p>–≠—Ç–æ—Ç –∫–æ–¥ –æ—Ç–∫—Ä—ã–≤–∞–µ—Ç —Ñ–∞–π–ª, —á—Ç–æ –º–æ–∂–µ—Ç –Ω–µ —É–¥–∞—Å—Ç—å—Å—è. –û–ø–µ—Ä–∞—Ç–æ—Ä <code>?</code> –≤—ã–≤–æ–¥–∏—Ç –¥–ª—è —Å–µ–±—è —Ç–∏–ø <code>Result</code>, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—ã–π <code>File::open</code>, –Ω–æ —Ñ—É–Ω–∫—Ü–∏—è <code>main</code> –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–∏–ø <code>()</code>, –∞ –Ω–µ <code>Result</code>. –ï—Å–ª–∏ –º—ã —Å–∫–æ–º–ø–∏–ª–∏—Ä—É–µ–º —ç—Ç–æ—Ç –∫–æ–¥, –º—ã –ø–æ–ª—É—á–∏–º —Å–ª–µ–¥—É—é—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ:</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
 --&gt; src/main.rs:4:48
  |
3 | fn main() {
  | --------- this function should return `Result` or `Option` to accept `?`
4 |     let greeting_file = File::open("hello.txt")?;
  |                                                ^ cannot use the `?` operator in a function that returns `()`
  |
  = help: the trait `FromResidual&lt;Result&lt;Infallible, std::io::Error&gt;&gt;` is not implemented for `()`
help: consider adding return type
  |
3 ~ fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
4 |     let greeting_file = File::open("hello.txt")?;
5 +     Ok(())
  |

For more information about this error, try `rustc --explain E0277`.
error: could not compile `error-handling` (bin "error-handling") due to 1 previous error
</code></pre>
<p>–≠—Ç–∞ –æ—à–∏–±–∫–∞ —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ —Ç–æ, —á—Ç–æ –æ–ø–µ—Ä–∞—Ç–æ—Ä <code>?</code> —Ä–∞–∑—Ä–µ—à–µ–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ –≤ —Ñ—É–Ω–∫—Ü–∏–∏, –∫–æ—Ç–æ—Ä–∞—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç <code>Result</code>, <code>Option</code> –∏–ª–∏ –¥—Ä—É–≥–æ–π —Ç–∏–ø, —Ä–µ–∞–ª–∏–∑—É—é—â–∏–π <code>FromResidual</code>.</p>
<p>–î–ª—è –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è –æ—à–∏–±–∫–∏ –µ—Å—Ç—å –¥–≤–∞ –≤–∞—Ä–∏–∞–Ω—Ç–∞. –û–¥–∏–Ω ‚Äî –∏–∑–º–µ–Ω–∏—Ç—å –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—ã–π —Ç–∏–ø –≤–∞—à–µ–π —Ñ—É–Ω–∫—Ü–∏–∏ —Ç–∞–∫, —á—Ç–æ–±—ã –æ–Ω –±—ã–ª —Å–æ–≤–º–µ—Å—Ç–∏–º —Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º, –¥–ª—è –∫–æ—Ç–æ—Ä–æ–≥–æ –≤—ã –∏—Å–ø–æ–ª—å–∑—É–µ—Ç–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä <code>?</code>, –µ—Å–ª–∏ –Ω–∏—á—Ç–æ —ç—Ç–æ–º—É –Ω–µ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤—É–µ—Ç. –î—Ä—É–≥–æ–π ‚Äî –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å <code>match</code> –∏–ª–∏ –æ–¥–∏–Ω –∏–∑ –º–µ—Ç–æ–¥–æ–≤ <code>Result&lt;T, E&gt;</code> –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ <code>Result&lt;T, E&gt;</code> –ª—é–±—ã–º –ø–æ–¥—Ö–æ–¥—è—â–∏–º —Å–ø–æ—Å–æ–±–æ–º.</p>
<p>–í —Å–æ–æ–±—â–µ–Ω–∏–∏ –æ–± –æ—à–∏–±–∫–µ —Ç–∞–∫–∂–µ —É–ø–æ–º–∏–Ω–∞–ª–æ—Å—å, —á—Ç–æ <code>?</code> –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏ –Ω–∞ –∑–Ω–∞—á–µ–Ω–∏—è—Ö <code>Option&lt;T&gt;</code>. –ö–∞–∫ –∏ –ø—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ <code>?</code> –Ω–∞ <code>Result</code>, –≤—ã –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å <code>?</code> –Ω–∞ <code>Option</code> —Ç–æ–ª—å–∫–æ –≤ —Ñ—É–Ω–∫—Ü–∏–∏, –∫–æ—Ç–æ—Ä–∞—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç <code>Option</code>. –ü–æ–≤–µ–¥–µ–Ω–∏–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ <code>?</code> –ø—Ä–∏ –≤—ã–∑–æ–≤–µ <code>Option&lt;T&gt;</code> –ø–æ—Ö–æ–∂–µ –Ω–∞ –µ–≥–æ –ø–æ–≤–µ–¥–µ–Ω–∏–µ –ø—Ä–∏ –≤—ã–∑–æ–≤–µ <code>Result&lt;T, E&gt;</code>: –µ—Å–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ —Ä–∞–≤–Ω–æ <code>None</code>, —Ç–æ <code>None</code> –±—É–¥–µ—Ç —Å—Ä–∞–∑—É –∂–µ –±—É–¥–µ—Ç –≤–æ–∑–≤—Ä–∞—â–µ–Ω–æ –∏–∑ —Ñ—É–Ω–∫—Ü–∏–∏. –ï—Å–ª–∏ –∂–µ –∑–Ω–∞—á–µ–Ω–∏–µ ‚Äî <code>Some</code>, —Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ –≤–Ω—É—Ç—Ä–∏ <code>Some</code> –±—É–¥–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∏—Ä—É—é—â–∏–º –∑–Ω–∞—á–µ–Ω–∏–µ–º –≤—ã—Ä–∞–∂–µ–Ω–∏—è, –∏ —Ñ—É–Ω–∫—Ü–∏—è –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç –∏—Å–ø–æ–ª–Ω—è—Ç—å—Å—è. –í –õ–∏—Å—Ç–∏–Ω–≥–µ 9-11 –ø—Ä–∏–≤–µ–¥—ë–Ω –ø—Ä–∏–º–µ—Ä —Ñ—É–Ω–∫—Ü–∏–∏, –∫–æ—Ç–æ—Ä–∞—è –Ω–∞—Ö–æ–¥–∏—Ç –ø–æ—Å–ª–µ–¥–Ω–∏–π —Å–∏–º–≤–æ–ª –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–æ–∫–∏ –∑–∞–¥–∞–Ω–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞.</p>
<Listing number="9-11" caption="Using the `?` operator on an `Option<T>` value">
<pre><pre class="playground"><code class="language-rust edition2021">fn last_char_of_first_line(text: &amp;str) -&gt; Option&lt;char&gt; {
    text.lines().next()?.chars().last()
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(
</span><span class="boring">        last_char_of_first_line("–ü—Ä–∏–≤–µ—Ç!\n–ö–∞–∫ —Ç—ã?"),
</span><span class="boring">        Some('!')
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    assert_eq!(last_char_of_first_line(""), None);
</span><span class="boring">    assert_eq!(last_char_of_first_line("\n—Å–æ–π–¥—ë—Ç"), None);
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç <code>Option&lt;char&gt;</code>, –ø–æ—Ç–æ–º—É —á—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å, —á—Ç–æ —Å—Ç—Ä–æ–∫–∞ –±—É–¥–µ—Ç –Ω–µ –ø—É—Å—Ç–æ–π –∏ —Å–∏–º–≤–æ–ª –±—É–¥–µ—Ç –Ω–∞–π–¥–µ–Ω, –∞ –º–æ–∂–µ—Ç –±—ã—Ç—å, —á—Ç–æ –µ–≥–æ –∏ –Ω–µ –±—É–¥–µ—Ç. –≠—Ç–æ—Ç –∫–æ–¥ –ø—Ä–∏–Ω–∏–º–∞–µ—Ç —Å—Ç—Ä–æ–∫–æ–≤—ã–π —Å—Ä–µ–∑ <code>text</code> –∏ –≤—ã–∑—ã–≤–∞–µ—Ç –Ω–∞ –Ω—ë–º –º–µ—Ç–æ–¥ <code>lines</code>, –∫–æ—Ç–æ—Ä—ã–π –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∏—Ç–µ—Ä–∞—Ç–æ—Ä –≤—Å–µ—Ö —Å—Ç—Ä–æ—á–µ–∫ –≤ —Å—Ç—Ä–æ–∫–µ. –ü–æ—Å–∫–æ–ª—å–∫—É —ç—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è —Ö–æ—á–µ—Ç –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–µ—Ä–≤—É—é —Å—Ç—Ä–æ–∫—É, –æ–Ω–∞ –≤—ã–∑—ã–≤–∞–µ—Ç <code>next</code> —É –∏—Ç–µ—Ä–∞—Ç–æ—Ä–∞, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –ø–µ—Ä–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –æ—Ç –∏—Ç–µ—Ä–∞—Ç–æ—Ä–∞. –ï—Å–ª–∏ <code>text</code> —è–≤–ª—è–µ—Ç—Å—è –ø—É—Å—Ç–æ–π —Å—Ç—Ä–æ–∫–æ–π, —ç—Ç–æ—Ç –≤—ã–∑–æ–≤ <code>next</code> –≤–µ—Ä–Ω—ë—Ç <code>None</code>, –∏ –≤ —ç—Ç–æ–º —Å–ª—É—á–∞–µ –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º <code>?</code> —á—Ç–æ–±—ã –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∏ –≤–µ—Ä–Ω—É—Ç—å <code>None</code> –∏–∑ <code>last_char_of_first_line</code>. –ï—Å–ª–∏ <code>text</code> –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –ø—É—Å—Ç–æ–π —Å—Ç—Ä–æ–∫–æ–π, <code>next</code> –≤–µ—Ä–Ω—ë—Ç –∑–Ω–∞—á–µ–Ω–∏–µ <code>Some</code>, —Å–æ–¥–µ—Ä–∂–∞—â–µ–µ —Å—Ç—Ä–æ–∫–æ–≤—ã–π —Å—Ä–µ–∑ –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–æ–∫–∏ –≤ <code>text</code>.</p>
<p>–°–∏–º–≤–æ–ª <code>?</code> –∏–∑–≤–ª–µ–∫–∞–µ—Ç —Å—Ç—Ä–æ–∫–æ–≤—ã–π —Å—Ä–µ–∑, –∏ –º—ã –º–æ–∂–µ–º –≤—ã–∑–≤–∞—Ç—å –Ω–∞ –Ω—ë–º –º–µ—Ç–æ–¥ <code>chars</code>, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –∏—Ç–µ—Ä–∞—Ç–æ—Ä —Å–∏–º–≤–æ–ª–æ–≤. –ù–∞—Å –∏–Ω—Ç–µ—Ä–µ—Å—É–µ—Ç –ø–æ—Å–ª–µ–¥–Ω–∏–π —Å–∏–º–≤–æ–ª –≤ –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–æ–∫–µ, –ø–æ—ç—Ç–æ–º—É –º—ã –≤—ã–∑—ã–≤–∞–µ–º <code>last</code>, —á—Ç–æ–±—ã –≤–µ—Ä–Ω—É—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–π —ç–ª–µ–º–µ–Ω—Ç –≤ –∏—Ç–µ—Ä–∞—Ç–æ—Ä–µ. –í–µ—Ä–Ω—ë—Ç—Å—è <code>Option</code>, –ø–æ—Ç–æ–º—É —á—Ç–æ –≤–æ–∑–º–æ–∂–Ω–æ, —á—Ç–æ –ø–µ—Ä–≤–∞—è —Å—Ç—Ä–æ–∫–∞ –ø—É—Å—Ç–∞: <code>–Ω–∞–ø—Ä–∏–º–µ—Ä</code>, –µ—Å–ª–∏ <code>text</code> –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å –ø—É—Å—Ç–æ–π —Å—Ç—Ä–æ–∫–∏, –Ω–æ –∏–º–µ–µ—Ç —Å–∏–º–≤–æ–ª—ã –≤ –¥—Ä—É–≥–∏—Ö —Å—Ç—Ä–æ–∫–∞—Ö, –∫–∞–∫ –≤ <code>"\n—Å–æ–π–¥—ë—Ç"</code>. –û–¥–Ω–∞–∫–æ, –µ—Å–ª–∏ –≤ –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–æ–∫–µ –µ—Å—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–π —Å–∏–º–≤–æ–ª, –æ–Ω –±—É–¥–µ—Ç –≤–æ–∑–≤—Ä–∞—â—ë–Ω –≤ –≤–∞—Ä–∏–∞–Ω—Ç–µ <code>Some</code>. –û–ø–µ—Ä–∞—Ç–æ—Ä <code>?</code> –≤ —Å–µ—Ä–µ–¥–∏–Ω–µ –¥–∞—ë—Ç –Ω–∞–º –ª–∞–∫–æ–Ω–∏—á–Ω—ã–π —Å–ø–æ—Å–æ–± –≤—ã—Ä–∞–∑–∏—Ç—å —ç—Ç—É –ª–æ–≥–∏–∫—É, –ø–æ–∑–≤–æ–ª—è—è —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Ñ—É–Ω–∫—Ü–∏—é –≤ –æ–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–µ. –ï—Å–ª–∏ –±—ã –º—ã –Ω–µ –º–æ–≥–ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –æ–ø–µ—Ä–∞—Ç–æ—Ä <code>?</code> –≤ <code>Option</code>, –Ω–∞–º –ø—Ä–∏—à–ª–æ—Å—å –±—ã —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —ç—Ç—É –ª–æ–≥–∏–∫—É, –∏—Å–ø–æ–ª—å–∑—É—è –±–æ–ª—å—à–µ –≤—ã–∑–æ–≤–æ–≤ –º–µ—Ç–æ–¥–æ–≤ –∏–ª–∏ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ <code>match</code>.</p>
<p>–û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ: –≤—ã –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –æ–ø–µ—Ä–∞—Ç–æ—Ä <code>?</code> –Ω–∞ <code>Result</code> –≤ —Ñ—É–Ω–∫—Ü–∏–∏, –∫–æ—Ç–æ—Ä–∞—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç <code>Result</code>; –≤—ã –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –æ–ø–µ—Ä–∞—Ç–æ—Ä <code>?</code> –Ω–∞ <code>Option</code> –≤ —Ñ—É–Ω–∫—Ü–∏–∏, –∫–æ—Ç–æ—Ä–∞—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç <code>Option</code>; –Ω–æ –≤—ã –Ω–µ –º–æ–∂–µ—Ç–µ –ø—ã—Ç–∞—Ç—å—Å—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –æ–¥–∏–Ω –≤–º–µ—Å—Ç–æ –¥—Ä—É–≥–æ–≥–æ. –û–ø–µ—Ä–∞—Ç–æ—Ä <code>?</code> –Ω–µ –±—É–¥–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤—ã–≤–∞—Ç—å <code>Result</code> –≤ <code>Option</code> –∏–ª–∏ –Ω–∞–æ–±–æ—Ä–æ—Ç; –≤ —ç—Ç–∏—Ö —Å–ª—É—á–∞—è—Ö –≤—ã –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–∞–∫–∏–µ –º–µ—Ç–æ–¥—ã, –∫–∞–∫ –º–µ—Ç–æ–¥ <code>ok</code> –¥–ª—è <code>Result</code> –∏–ª–∏ –º–µ—Ç–æ–¥ <code>ok_or</code> –¥–ª—è <code>Option</code>, —á—Ç–æ–±—ã –≤—ã–ø–æ–ª–Ω—è—Ç—å –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —è–≤–Ω–æ.</p>
<p>–î–æ —Å–∏—Ö –ø–æ—Ä –≤—Å–µ —Ñ—É–Ω–∫—Ü–∏–∏ <code>main</code>, –∫–æ—Ç–æ—Ä—ã–µ –º—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏, –≤–æ–∑–≤—Ä–∞—â–∞–ª–∏ <code>()</code>. –§—É–Ω–∫—Ü–∏—è <code>main</code> ‚Äî –æ—Å–æ–±–µ–Ω–Ω–∞—è, –ø–æ—Ç–æ–º—É —á—Ç–æ —ç—Ç–æ —Ç–æ—á–∫–∞ –≤—Ö–æ–¥–∞ –∏ –≤—ã—Ö–æ–¥–∞ –∏—Å–ø–æ–ª–Ω—è–µ–º—ã—Ö –ø—Ä–æ–≥—Ä–∞–º–º, –∏ —Å—É—â–µ—Å—Ç–≤—É—é—Ç –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –Ω–∞ —Ç–∏–ø –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è, –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –¥–ª—è —Ç–æ–≥–æ, —á—Ç–æ –ø—Ä–æ–≥—Ä–∞–º–º—ã –≤–µ–ª–∏ —Å–µ–±—è —Ç–∞–∫, –∫–∞–∫ –æ–∂–∏–¥–∞–µ—Ç—Å—è.</p>
<p>–ö —Å—á–∞—Å—Ç—å—é, <code>main</code> –µ—â—ë –º–æ–∂–µ—Ç –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å <code>Result&lt;(), E&gt;</code>. –í –õ–∏—Å—Ç–∏–Ω–≥–µ 9-12 –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∫–æ–¥ –∏–∑ –õ–∏—Å—Ç–∏–Ω–≥–∞ 9-10, –Ω–æ –º—ã –∏–∑–º–µ–Ω–∏–ª–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—ã–π —Ç–∏–ø <code>main</code> –Ω–∞ <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code> –∏ –¥–æ–±–∞–≤–∏–ª–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ <code>Ok(())</code> –≤ –∫–æ–Ω–µ—Ü. –¢–µ–ø–µ—Ä—å —ç—Ç–æ—Ç –∫–æ–¥ –∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è.</p>
<Listing number="9-12" file-name="src/main.rs" caption="Changing `main` to return `Result<(), E>` allows the use of the `?` operator on `Result` values.">
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs::File;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let greeting_file = File::open("hello.txt")?;

    Ok(())
}</code></pre>
</Listing>
<p>–¢–∏–ø <code>Box&lt;dyn Error&gt;</code> ‚Äî —ç—Ç–æ <em>—Ç—Ä–µ–π—Ç-–æ–±—ä–µ–∫—Ç</em>, –æ –∫–æ—Ç–æ—Ä—ã—Ö –º—ã –ø–æ–≥–æ–≤–æ—Ä–∏–º –≤ —Ä–∞–∑–¥–µ–ª–µ <a href="ch18-02-trait-objects.html#%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%82%D1%80%D0%B5%D0%B9%D1%82-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2-%D0%BF%D0%BE%D0%B7%D0%B2%D0%BE%D0%BB%D1%8F%D1%8E%D1%89%D0%B8%D1%85-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D1%80%D0%B0%D0%B7%D0%BD%D1%8B%D1%85-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2">"–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Ç—Ä–µ–π—Ç-–æ–±—ä–µ–∫—Ç–æ–≤, –ø–æ–∑–≤–æ–ª—è—é—â–∏—Ö –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤"</a><!-- ignore --> –ì–ª–∞–≤—ã 18. –ü–æ–∫–∞ —á—Ç–æ –≤—ã –º–æ–∂–µ—Ç–µ —Å—á–∏—Ç–∞—Ç—å, —á—Ç–æ <code>Box&lt;dyn Error&gt;</code> –æ–∑–Ω–∞—á–∞–µ—Ç "–ª—é–±–æ–π –≤–∏–¥ –æ—à–∏–±–∫–∏". –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ <code>?</code> –¥–ª—è –∑–Ω–∞—á–µ–Ω–∏—è <code>Result</code> –≤ —Ñ—É–Ω–∫—Ü–∏–∏ <code>main</code> —Å —Ç–∏–ø–æ–º –æ—à–∏–±–∫–∏ <code>Box&lt;dyn Error&gt;</code> –¥–æ–ø—É—Å—Ç–∏–º–æ, —Ç–∞–∫ –∫–∞–∫ –ø–æ–∑–≤–æ–ª—è–µ—Ç –≤–µ—Ä–Ω—É—Ç—å –ª—é–±–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ <code>Err</code> —Ä–∞–Ω—å—à–µ –≤—Ä–µ–º–µ–Ω–∏. –î–∞–∂–µ –µ—Å–ª–∏ —Ç–µ–ª–æ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ <code>main</code> –±—É–¥–µ—Ç –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å —Ç–æ–ª—å–∫–æ –æ—à–∏–±–∫–∏ —Ç–∏–ø–∞ <code>std::io::Error</code>, —É–∫–∞–∑–∞–≤ <code>Box&lt;dyn Error&gt;</code>, —ç—Ç–∞ —Å–∏–≥–Ω–∞—Ç—É—Ä–∞ –æ—Å—Ç–∞–Ω–µ—Ç—Å—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–π, –¥–∞–∂–µ –µ—Å–ª–∏ –≤ —Ç–µ–ª–æ <code>main</code> –±—É–¥–µ—Ç –¥–æ–±–∞–≤–ª–µ–Ω –∫–æ–¥, –≤–æ–∑–≤—Ä–∞—â–∞—é—â–∏–π –¥—Ä—É–≥–∏–µ –æ—à–∏–±–∫–∏.</p>
<p>–ï—Å–ª–∏ —Ñ—É–Ω–∫—Ü–∏—è <code>main</code> –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç <code>Result&lt;(), E&gt;</code>, —Ç–æ –ø—Ä–æ–≥—Ä–∞–º–º–∞ –∑–∞–≤–µ—Ä—à–∏—Ç—Å—è —Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º <code>0</code>, –µ—Å–ª–∏ <code>main</code> –≤–µ—Ä–Ω—ë—Ç <code>Ok(())</code>, –Ω–æ –∑–∞–≤–µ—Ä—à–∏—Ç—Å—è —Å –Ω–µ–Ω—É–ª–µ–≤—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º, –µ—Å–ª–∏ <code>main</code> –≤–µ—Ä–Ω—ë—Ç –∑–Ω–∞—á–µ–Ω–∏–µ <code>Err</code>. –ü—Ä–æ–≥—Ä–∞–º–º—ã, –Ω–∞–ø–∏—Å–∞–Ω–Ω—ã–µ –Ω–∞ C, –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç —Ü–µ–ª—ã–µ —á–∏—Å–ª–∞: —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à—ë–Ω–Ω—ã–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ <code>0</code>, –∞ –ø—Ä–æ–≥—Ä–∞–º–º—ã —Å –æ—à–∏–±–∫–æ–π –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ, –æ—Ç–ª–∏—á–Ω–æ–µ –æ—Ç <code>0</code>. Rust —Ç–∞–∫–∂–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ü–µ–ª—ã–µ —á–∏—Å–ª–∞ –∏–∑ –ø—Ä–æ–≥—Ä–∞–º–º, —á—Ç–æ–±—ã –±—ã—Ç—å —Å–æ–≤–º–µ—Å—Ç–∏–º—ã–º —Å —ç—Ç–∏–º —Å–æ–≥–ª–∞—à–µ–Ω–∏–µ–º.</p>
<p>–§—É–Ω–∫—Ü–∏—è <code>main</code> –º–æ–∂–µ—Ç –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å –ª—é–±—ã–µ —Ç–∏–ø—ã, —Ä–µ–∞–ª–∏–∑—É—é—â–∏–µ <a href="https://doc.rust-lang.org/std/process/trait.Termination.html">—Ç—Ä–µ–π—Ç <code>std::process::Termination</code></a><!-- ignore -->, –∫–æ—Ç–æ—Ä—ã–π —Å–æ–¥–µ—Ä–∂–∏—Ç —Ñ—É–Ω–∫—Ü–∏—é <code>report</code>, –≤–æ–∑–≤—Ä–∞—â–∞—é—â—É—é <code>ExitCode</code>. –û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –∑–∞ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ —Ç—Ä–µ–π—Ç–∞ <code>Termination</code> –¥–ª—è –≤–∞—à–∏—Ö —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã—Ö —Ç–∏–ø–æ–≤.</p>
<p>–¢–µ–ø–µ—Ä—å, –∫–æ–≥–¥–∞ –º—ã –æ–±—Å—É–¥–∏–ª–∏ –¥–µ—Ç–∞–ª–∏ –≤—ã–∑–æ–≤–∞ <code>panic!</code> –∏ –≤–æ–∑–≤—Ä–∞—Ç–∞ <code>Result</code>, –¥–∞–≤–∞–π—Ç–µ –≤–µ—Ä–Ω—ë–º—Å—è –∫ —Ç–æ–º—É, –∫–∞–∫ —Ä–µ—à–∏—Ç—å, –∫–∞–∫–æ–π –∏–∑ —Å–ª—É—á–∞–µ–≤ –ø–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è –∫–∞–∫–æ–π —Å–∏—Ç—É–∞—Ü–∏–∏.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–ö–æ–≥–¥–∞-—Å–ª–µ–¥—É–µ—Ç-–∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å-panic"><a class="header" href="#–ö–æ–≥–¥–∞-—Å–ª–µ–¥—É–µ—Ç-–∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å-panic">–ö–æ–≥–¥–∞ —Å–ª–µ–¥—É–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å <code>panic!</code>?</a></h2>
<p>–ò—Ç–∞–∫, –∫–∞–∫ –ø—Ä–∏–Ω—è—Ç—å —Ä–µ—à–µ–Ω–∏–µ –æ —Ç–æ–º, –∫–æ–≥–¥–∞ —Å–ª–µ–¥—É–µ—Ç –≤—ã–∑—ã–≤–∞—Ç—å <code>panic!</code>, –∞ –∫–æ–≥–¥–∞ –≤–µ—Ä–Ω—É—Ç—å <code>Result</code>? –ü–æ—Å–ª–µ –ø–∞–Ω–∏–∫–∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ —É–∂–µ –Ω–µ–ª—å–∑—è. –ú–æ–∂–Ω–æ –±—ã–ª–æ –±—ã –≤—ã–∑—ã–≤–∞—Ç—å <code>panic!</code> –¥–ª—è –ª—é–±–æ–π –æ—à–∏–±–æ—á–Ω–æ–π —Å–∏—Ç—É–∞—Ü–∏–∏, –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –æ—Ç —Ç–æ–≥–æ, –∏–º–µ–µ—Ç—Å—è –ª–∏ —Å–ø–æ—Å–æ–± –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å —Å–ª—É—á–∏–≤—à—É—é—Å—è –ø—Ä–æ–±–ª–µ–º—É, –Ω–æ —Ç–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º –≤—ã –æ—Ç–±–∏—Ä–∞–µ—Ç–µ —É –≤—ã–∑—ã–≤–∞—é—â–µ–≥–æ –∫–æ–¥–∞ –ø—Ä–∞–≤–æ –æ–ø—Ä–µ–¥–µ–ª—è—Ç—å, –∫—Ä–∏—Ç–∏—á–Ω–∞ –ª–∏ —Å–∏—Ç—É–∞—Ü–∏—è –∏–ª–∏ –Ω–µ—Ç. –ï—Å–ª–∏ –∂–µ –≤—ã –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ <code>Result</code>, –≤—ã –æ—Ç–¥–∞—ë—Ç–µ –ø—Ä–∏–Ω—è—Ç–∏–µ —Ä–µ—à–µ–Ω–∏—è –≤—ã–∑—ã–≤–∞—é—â–µ–º—É –∫–æ–¥—É. –í—ã–∑—ã–≤–∞—é—â–∏–π –∫–æ–¥ –º–æ–∂–µ—Ç –ø–æ–ø—ã—Ç–∞—Ç—å—Å—è —É—Å—Ç—Ä–∞–Ω–∏—Ç—å –æ—à–∏–±–∫—É —Å–ø–æ—Å–æ–±–æ–º, –∫–æ—Ç–æ—Ä—ã–π –ø–æ–¥—Ö–æ–¥–∏—Ç –≤ –¥–∞–Ω–Ω–æ–π —Å–∏—Ç—É–∞—Ü–∏–∏, –∏–ª–∏ –∂–µ –æ–Ω –º–æ–∂–µ—Ç —Ä–µ—à–∏—Ç—å, —á—Ç–æ –æ—à–∏–±–∫–∞ –≤ <code>Err</code> –Ω–µ–∏—Å–ø—Ä–∞–≤–∏–º–∞, –∏ –≤—ã–∑–æ–≤–µ—Ç <code>panic!</code>, –ø—Ä–µ–≤—Ä–∞—Ç–∏–≤ –≤–∞—à—É –∏—Å–ø—Ä–∞–≤–∏–º—É—é –æ—à–∏–±–∫—É –≤ –Ω–µ–∏—Å–ø—Ä–∞–≤–∏–º—É—é. –°–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ, –∏–∑ —Ñ—É–Ω–∫—Ü–∏–∏, –≤—ã–∑–æ–≤ –∫–æ—Ç–æ—Ä–æ–π –º–æ–∂–µ—Ç –∑–∞–≤–µ—Ä—à–∏—Ç—å—Å—è –Ω–µ—É–¥–∞—á–µ–π, –ª—É—á—à–µ –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å <code>Result</code>.</p>
<p>–ï—Å–ª–∏ –≤—ã –ø–∏—à–µ—Ç–µ –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ç–∏–≤–Ω—ã–µ –ø—Ä–∏–º–µ—Ä—ã, –ø—Ä–æ—Ç–æ—Ç–∏–ø—ã –∏–ª–∏ —Ç–µ—Å—Ç—ã, –±–æ–ª–µ–µ —É–º–µ—Å—Ç–Ω–æ –±—É–¥–µ—Ç –ø–∏—Å–∞—Ç—å –∫–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –ø–∞–Ω–∏–∫—É–µ—Ç –≤–º–µ—Å—Ç–æ —Ç–æ–≥–æ, —á—Ç–æ–±—ã –ø—ã—Ç–∞—Ç—å—Å—è –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å <code>Result</code>. –î–∞–≤–∞–π—Ç–µ —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º –ø—Ä–∏—á–∏–Ω—ã —ç—Ç–æ–≥–æ –≤—ã–±–æ—Ä–∞, –∞ –∑–∞—Ç–µ–º –º—ã –æ–±—Å—É–¥–∏–º —Å–∏—Ç—É–∞—Ü–∏–∏, –≤ –∫–æ—Ç–æ—Ä—ã—Ö –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –Ω–µ –º–æ–∂–µ—Ç –¥–æ–∫–∞–∑–∞—Ç—å, —á—Ç–æ –æ—à–∏–±–∫–∞ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–∞, –Ω–æ –≤—ã, –∫–∞–∫ —á–µ–ª–æ–≤–µ–∫, –º–æ–∂–µ—Ç–µ —ç—Ç–æ —Å–¥–µ–ª–∞—Ç—å. –ì–ª–∞–≤–∞ –±—É–¥–µ—Ç –∑–∞–∫–∞–Ω—á–∏–≤–∞—Ç—å—Å—è –Ω–µ–∫–æ—Ç–æ—Ä—ã–º–∏ –æ–±—â–∏–º–∏ –ø—Ä–∏–Ω—Ü–∏–ø–∞–º–∏ —Ç–æ–≥–æ, –∫–∞–∫ —Ä–µ—à–∏—Ç—å, —Å—Ç–æ–∏—Ç –ª–∏ –ø–∞–Ω–∏–∫–æ–≤–∞—Ç—å –≤ –±–∏–±–ª–∏–æ—Ç–µ—á–Ω–æ–º –∫–æ–¥–µ.</p>
<h3 id="–ü—Ä–∏–º–µ—Ä—ã-–ø—Ä–æ—Ç–æ—Ç–∏–ø—ã-–∏-—Ç–µ—Å—Ç—ã"><a class="header" href="#–ü—Ä–∏–º–µ—Ä—ã-–ø—Ä–æ—Ç–æ—Ç–∏–ø—ã-–∏-—Ç–µ—Å—Ç—ã">–ü—Ä–∏–º–µ—Ä—ã, –ø—Ä–æ—Ç–æ—Ç–∏–ø—ã –∏ —Ç–µ—Å—Ç—ã</a></h3>
<p>–ö–æ–≥–¥–∞ –≤—ã –ø–∏—à–µ—Ç–µ –ø—Ä–∏–º–µ—Ä, –∏–ª–ª—é—Å—Ç—Ä–∏—Ä—É—é—â–∏–π –Ω–µ–∫–æ—Ç–æ—Ä—É—é –∫–æ–Ω—Ü–µ–ø—Ü–∏—é, –Ω–∞–ª–∏—á–∏–µ —Ö–æ—Ä–æ—à–µ–≥–æ –∫–æ–¥–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫ –º–æ–∂–µ—Ç —Å–¥–µ–ª–∞—Ç—å –ø—Ä–∏–º–µ—Ä –º–µ–Ω–µ–µ –ø–æ–Ω—è—Ç–Ω—ã–º. –ü–æ–Ω—è—Ç–Ω–æ, —á—Ç–æ –≤ –ø—Ä–∏–º–µ—Ä–∞—Ö –≤—ã–∑–æ–≤ –º–µ—Ç–æ–¥–∞ <code>unwrap</code>, –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–µ—Ç –ø—Ä–∏–≤–µ—Å—Ç–∏ –∫ –ø–∞–Ω–∏–∫–µ, —è–≤–ª—è–µ—Ç—Å—è –ª–∏—à—å –æ–±–æ–∑–Ω–∞—á–µ–Ω–∏–µ–º —Å–ø–æ—Å–æ–±–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫ –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏, –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–µ—Ç –æ—Ç–ª–∏—á–∞—Ç—å—Å—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–æ–≥–æ, —á—Ç–æ –¥–µ–ª–∞–µ—Ç –æ—Å—Ç–∞–ª—å–Ω–∞—è —á–∞—Å—Ç—å –∫–æ–¥–∞.</p>
<p>–¢–æ—á–Ω–æ —Ç–∞–∫ –∂–µ –º–µ—Ç–æ–¥—ã <code>unwrap</code> –∏ <code>expect</code> —è–≤–ª—è—é—Ç—Å—è –æ—á–µ–Ω—å —É–¥–æ–±–Ω—ã–º–∏ –ø—Ä–∏ –Ω–∞–ø–∏—Å–∞–Ω–∏–∏ –ø—Ä–æ—Ç–æ—Ç–∏–ø–æ–≤, —Ç–æ –µ—Å—Ç—å –ø—Ä–µ–∂–¥–µ —Ç–æ–≥–æ, –∫–∞–∫ –≤—ã –±—É–¥–µ—Ç–µ –≥–æ—Ç–æ–≤—ã —Ä–µ—à–∏—Ç—å, –∫–∞–∫ –∏–º–µ–Ω–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –æ—à–∏–±–∫–∏. –û–Ω–∏ —á—ë—Ç–∫–æ –æ–±–æ–∑–Ω–∞—á–∞—é—Ç —Ç–µ –º–µ—Å—Ç–∞, –≤ –∫–æ—Ç–æ—Ä—ã—Ö –≤–∞–º –Ω—É–∂–Ω–æ –±—É–¥–µ—Ç —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É –æ—à–∏–±–æ–∫, –∫–æ–≥–¥–∞ –¥–ª—è —Ç–æ–≥–æ –ø—Ä–∏–¥—ë—Ç –≤—Ä–µ–º—è.</p>
<p>–ï—Å–ª–∏ –≤ —Ç–µ—Å—Ç–µ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç —Å–±–æ–π –ø—Ä–∏ –≤—ã–∑–æ–≤–µ –º–µ—Ç–æ–¥–∞, —Ç–æ –≤—ã –±—ã —Ö–æ—Ç–µ–ª–∏, —á—Ç–æ–±—ã –≤–µ—Å—å —Ç–µ—Å—Ç –Ω–µ –ø—Ä–æ—à—ë–ª, –¥–∞–∂–µ –µ—Å–ª–∏ —ç—Ç–æ—Ç –º–µ—Ç–æ–¥ –Ω–µ —è–≤–ª—è–µ—Ç—Å—è —Ç–µ—Å—Ç–∏—Ä—É–µ–º–æ–π —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å—é. –ü–æ—Å–∫–æ–ª—å–∫—É –≤—ã–∑–æ–≤ <code>panic!</code> ‚Äî —ç—Ç–æ —Å–ø–æ—Å–æ–±, –∫–æ—Ç–æ—Ä—ã–º —Ç–µ—Å—Ç –ø–æ–º–µ—á–∞–µ—Ç—Å—è –∫–∞–∫ –ø—Ä–æ–≤–∞–ª–∏–≤—à–∏–π—Å—è, –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ <code>unwrap</code> –∏–ª–∏ <code>expect</code> ‚Äî –∏–º–µ–Ω–Ω–æ —Ç–æ, —á—Ç–æ –Ω—É–∂–Ω–æ.</p>
<h3 id="–°–ª—É—á–∞–∏-–∫–æ–≥–¥–∞-–≤—ã-–∑–Ω–∞–µ—Ç–µ-–±–æ–ª—å—à–µ-—á–µ–º-–∫–æ–º–ø–∏–ª—è—Ç–æ—Ä"><a class="header" href="#–°–ª—É—á–∞–∏-–∫–æ–≥–¥–∞-–≤—ã-–∑–Ω–∞–µ—Ç–µ-–±–æ–ª—å—à–µ-—á–µ–º-–∫–æ–º–ø–∏–ª—è—Ç–æ—Ä">–°–ª—É—á–∞–∏, –∫–æ–≥–¥–∞ –≤—ã –∑–Ω–∞–µ—Ç–µ –±–æ–ª—å—à–µ, —á–µ–º –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä</a></h3>
<p>–¢–∞–∫–∂–µ –±—ã–ª–æ –±—ã —Ü–µ–ª–µ—Å–æ–æ–±—Ä–∞–∑–Ω–æ –≤—ã–∑—ã–≤–∞—Ç—å <code>unwrap</code> –∏–ª–∏ <code>expect</code>, –∫–æ–≥–¥–∞ —É –≤–∞—Å –µ—Å—Ç—å –∫–∞–∫–∞—è-—Ç–æ –¥—Ä—É–≥–∞—è –ª–æ–≥–∏–∫–∞, –∫–æ—Ç–æ—Ä–∞—è –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç, —á—Ç–æ <code>Result</code> –±—É–¥–µ—Ç –∏–º–µ—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ <code>Ok</code>, –Ω–æ –≤–∞—à—É –ª–æ–≥–∏–∫—É –Ω–µ –ø–æ–Ω–∏–º–∞–µ—Ç –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä. –£ –≤–∞—Å –ø–æ-–ø—Ä–µ–∂–Ω–µ–º—É –±—É–¥–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ <code>Result</code>, –∫–æ—Ç–æ—Ä–æ–µ –Ω—É–∂–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å: –ª—é–±–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è, –∫–æ—Ç–æ—Ä—É—é –≤—ã –≤—ã–∑—ã–≤–∞–µ—Ç–µ, –≤—Å–µ –µ—â—ë –∏–º–µ–µ—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –Ω–µ—É–¥–∞—á–∏ –≤ —Ü–µ–ª–æ–º, —Ö–æ—Ç—è —ç—Ç–æ –ª–æ–≥–∏—á–µ—Å–∫–∏ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ –≤ –≤–∞—à–µ–π –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π —Å–∏—Ç—É–∞—Ü–∏–∏. –ï—Å–ª–∏, –ø—Ä–æ–≤–µ—Ä—è—è –∫–æ–¥ –≤—Ä—É—á–Ω—É—é, –≤—ã –º–æ–∂–µ—Ç–µ —É–±–µ–¥–∏—Ç—å—Å—è, —á—Ç–æ –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –≤–æ–∑–Ω–∏–∫–Ω–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ <code>Err</code>, —Ç–æ –≤–ø–æ–ª–Ω–µ –¥–æ–ø—É—Å—Ç–∏–º–æ –≤—ã–∑—ã–≤–∞—Ç—å <code>unwrap</code>, –∞ –µ—â—ë –ª—É—á—à–µ –∑–∞–¥–æ–∫—É–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å –≤ —Ç–µ–∫—Å—Ç–µ <code>expect</code> –ø—Ä–∏—á–∏–Ω—É, –ø–æ –∫–æ—Ç–æ—Ä–æ–π, –ø–æ –≤–∞—à–µ–º—É –º–Ω–µ–Ω–∏—é, –≤–∞—Ä–∏–∞–Ω—Ç <code>Err</code> –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –≤–æ–∑–Ω–∏–∫–Ω–µ—Ç. –ù–∞–ø—Ä–∏–º–µ—Ä, –≤–æ—Ç —Ç–∞–∫:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    use std::net::IpAddr;

    let home: IpAddr = "127.0.0.1"
        .parse()
        .expect("Hardcoded IP address should be valid");
<span class="boring">}</span></code></pre></pre>
<p>–ú—ã —Å–æ–∑–¥–∞—ë–º —ç–∫–∑–µ–º–ø–ª—è—Ä <code>IpAddr</code>, –∏–∑–≤–ª–µ–∫–∞—è –∑–Ω–∞—á–µ–Ω–∏–µ –∞–¥—Ä–µ—Å–∞ –∏–∑ –ª–∏—Ç–µ—Ä–∞–ª–∞ —Å—Ç—Ä–æ–∫–∏. –ú–æ–∂–Ω–æ —É–≤–∏–¥–µ—Ç—å, —á—Ç–æ <code>127.0.0.1</code> —è–≤–ª—è–µ—Ç—Å—è –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–º IP-–∞–¥—Ä–µ—Å–æ–º, –ø–æ—ç—Ç–æ–º—É –∑–¥–µ—Å—å –¥–æ–ø—É—Å—Ç–∏–º–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ <code>expect</code>. –û–¥–Ω–∞–∫–æ –Ω–∞–ª–∏—á–∏–µ –ª–∏—Ç–µ—Ä–∞–ª–∞ –Ω–µ –º–µ–Ω—è–µ—Ç —Ç–∏–ø –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è –º–µ—Ç–æ–¥–∞ <code>parse</code>: –º—ã –≤—Å—ë –µ—â—ë –ø–æ–ª—É—á–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ <code>Result</code>, –∏ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –≤—Å—ë —Ç–∞–∫–∂–µ –∑–∞—Å—Ç–∞–≤–ª—è–µ—Ç –Ω–∞—Å –æ–±—Ä–∞—â–∞—Ç—å—Å—è —Å <code>Result</code> —Ç–∞–∫, –±—É–¥—Ç–æ –≤–æ–∑–º–æ–∂–µ–Ω –≤–∞—Ä–∏–∞–Ω—Ç <code>Err</code>: –ø–æ—Ç–æ–º—É —á—Ç–æ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —É–º—ë–Ω, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å, —á—Ç–æ —ç—Ç–∞ —Å—Ç—Ä–æ–∫–∞, –±–µ–∑ —Å–æ–º–Ω–µ–Ω–∏–π, –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π IP-–∞–¥—Ä–µ—Å. –ï—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞ IP-–∞–¥—Ä–µ—Å–∞ –ø—Ä–∏—à–ª–∞ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, —Ç–æ –º—ã –Ω–∏—á–µ–≥–æ –Ω–µ –∑–Ω–∞–µ–º –∑–∞—Ä–∞–Ω–µ–µ –æ –µ—ë –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç–∏, –∏, —Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ, –º–æ–∂–µ–º —Å –Ω–µ–π –ø–æ–ª—É—á–∏—Ç—å –æ—à–∏–±–∫—É. –í —Ç–∞–∫–æ–º —Å–ª—É—á–∞–µ –º—ã –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ —Ö–æ—Ç–µ–ª–∏ –±—ã –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å <code>Result</code> –±–æ–ª–µ–µ –Ω–∞–¥—ë–∂–Ω—ã–º —Å–ø–æ—Å–æ–±–æ–º. –£–ø–æ–º–∏–Ω–∞–Ω–∏–µ –ø—Ä–µ–¥–ø–æ–ª–æ–∂–µ–Ω–∏—è –æ —Ç–æ–º, —á—Ç–æ —Ç–µ–∫—É—â–∏–π –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–π IP-–∞–¥—Ä–µ—Å –æ–¥–Ω–æ–∑–Ω–∞—á–Ω–æ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π ‚Äî —ç—Ç–æ –º–µ—Ç–∫–∞, —É–∫–∞–∑—ã–≤–∞—é—â–∞—è –Ω–∞–º –Ω–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç—å –∏–∑–º–µ–Ω–∏—Ç—å <code>expect</code> –¥–ª—è –ª—É—á—à–µ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫, –µ—Å–ª–∏ –≤ –±—É–¥—É—â–µ–º –Ω–∞–º –ø–æ—Ç—Ä–µ–±—É–µ—Ç—Å—è –≤–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ –ø–æ–ª—É—á–∏—Ç—å IP-–∞–¥—Ä–µ—Å –∏–∑ –∫–∞–∫–æ–≥–æ-–ª–∏–±–æ –¥—Ä—É–≥–æ–≥–æ –∏—Å—Ç–æ—á–Ω–∏–∫–∞.</p>
<h3 id="–†—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ-–ø–æ-–æ–±—Ä–∞–±–æ—Ç–∫–µ-–æ—à–∏–±–æ–∫"><a class="header" href="#–†—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ-–ø–æ-–æ–±—Ä–∞–±–æ—Ç–∫–µ-–æ—à–∏–±–æ–∫">–†—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ –ø–æ –æ–±—Ä–∞–±–æ—Ç–∫–µ –æ—à–∏–±–æ–∫</a></h3>
<p>–ñ–µ–ª–∞—Ç–µ–ª—å–Ω–æ, —á—Ç–æ–±—ã –∫–æ–¥ –ø–∞–Ω–∏–∫–æ–≤–∞–ª, –µ—Å–ª–∏ –æ–Ω –º–æ–∂–µ—Ç –æ–∫–∞–∑–∞—Ç—å—Å—è –≤ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–∏. <em>–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ</em> ‚Äî —ç—Ç–æ —Å–æ—Å—Ç–æ—è–Ω–∏–µ, –∫–æ–≥–¥–∞ –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –¥–æ–ø—É—â–µ–Ω–∏–µ, –≥–∞—Ä–∞–Ω—Ç–∏—è, –∫–æ–Ω—Ç—Ä–∞–∫—Ç –∏–ª–∏ –∏–Ω–≤–∞—Ä–∏–∞–Ω—Ç –±—ã–ª–∏ –Ω–∞—Ä—É—à–µ–Ω—ã. –ù–∞–ø—Ä–∏–º–µ—Ä, –∫–æ–≥–¥–∞ –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–µ, –ø—Ä–æ—Ç–∏–≤–æ—Ä–µ—á–∏–≤—ã–µ –∏–ª–∏ –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –ø–µ—Ä–µ–¥–∞—é—Ç—Å—è –≤ –≤–∞—à –∫–æ–¥, –ø–ª—é—Å —á—Ç–æ-–Ω–∏–±—É–¥—å –µ—â—ë –∏–∑ —ç—Ç–æ–≥–æ —Å–ø–∏—Å–∫–∞:</p>
<ul>
<li>–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –Ω–µ–æ–∂–∏–¥–∞–Ω–Ω–æ (–Ω–µ —Å–ª–µ–¥—É–µ—Ç –ø—É—Ç–∞—Ç—å —Å "—Ä–µ–¥–∫–∏–º–∏ —Å–ª—É—á–∞—è–º–∏" ‚Äî –Ω–∞–ø—Ä–∏–º–µ—Ä, –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤–≤—ë–ª –¥–∞–Ω–Ω—ã–µ –≤ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ, —ç—Ç–æ –Ω–µ –±—É–¥–µ—Ç –Ω–µ–æ–∂–∏–¥–∞–Ω–Ω–æ—Å—Ç—å—é; —Ç–∞–∫–æ–µ —Å–ª–µ–¥—É–µ—Ç –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å).</li>
<li>–í–µ—Å—å —Å–ª–µ–¥—É—é—â–∏–π –∫–æ–¥ –Ω–µ –ø—Ä–æ–≤–æ–¥–∏—Ç –ø—Ä–æ–≤–µ—Ä–æ–∫ –Ω–∞ –¥–∞–Ω–Ω–æ–µ (–ø–ª–æ—Ö–æ–µ) —Å–æ—Å—Ç–æ—è–Ω–∏–µ, —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞—è, —á—Ç–æ –æ–Ω–æ –Ω–µ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç.</li>
<li>–ù–µ—Ç —Ö–æ—Ä–æ—à–µ–≥–æ —Å–ø–æ—Å–æ–±–∞ –∑–∞–∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å –¥–∞–Ω–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –≤ —Ç–∏–ø–∞—Ö, –∫–æ—Ç–æ—Ä—ã–µ –≤—ã –∏—Å–ø–æ–ª—å–∑—É–µ—Ç–µ. –ú—ã —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º –ø—Ä–∏–º–µ—Ä —Ç–æ–≥–æ, —á—Ç–æ –º—ã –∏–º–µ–µ–º –≤ –≤–∏–¥—É, –≤ —Ä–∞–∑–¥–µ–ª–µ <a href="ch18-03-oo-design-patterns.html#%D0%9A%D0%BE%D0%B4%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B2-%D1%82%D0%B8%D0%BF%D0%B0%D1%85-%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B9-%D0%B8-%D0%BF%D0%BE%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F">"–ö–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤ —Ç–∏–ø–∞—Ö —Å–æ—Å—Ç–æ—è–Ω–∏–π –∏ –ø–æ–≤–µ–¥–µ–Ω–∏—è"</a><!-- ignore --> –ì–ª–∞–≤—ã 18.</li>
</ul>
<p>–ï—Å–ª–∏ –∫—Ç–æ-—Ç–æ –≤—ã–∑—ã–≤–∞–µ—Ç –≤–∞—à –∫–æ–¥ –∏ –ø–µ—Ä–µ–¥–∞—ë—Ç –∑–Ω–∞—á–µ–Ω–∏—è, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ –∏–º–µ—é—Ç —Å–º—ã—Å–ª–∞, –ª—É—á—à–µ –≤—Å–µ–≥–æ –≤–µ—Ä–Ω—É—Ç—å –æ—à–∏–±–∫—É, –µ—Å–ª–∏ –≤—ã –º–æ–∂–µ—Ç–µ: –¥–ª—è —Ç–æ–≥–æ, —á—Ç–æ–±—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –º–æ–≥ —Ä–µ—à–∏—Ç—å, —á—Ç–æ –æ–Ω —Ö–æ—á–µ—Ç –¥–µ–ª–∞—Ç—å –≤ —ç—Ç–æ–º —Å–ª—É—á–∞–µ. –û–¥–Ω–∞–∫–æ –≤ —Ç–µ—Ö —Å–ª—É—á–∞—è—Ö, –∫–æ–≥–¥–∞ –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è –ø—Ä–æ–≥—Ä–∞–º–º—ã –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–µ–±–µ–∑–æ–ø–∞—Å–Ω—ã–º –∏–ª–∏ –≤—Ä–µ–¥–Ω—ã–º, –ª—É—á—à–∏–º –≤—ã–±–æ—Ä–æ–º –±—É–¥–µ—Ç –≤—ã–∑–æ–≤ <code>panic!</code> –∏ –æ–ø–æ–≤–µ—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –∏—Å–ø–æ–ª—å–∑—É—é—â–µ–≥–æ –≤–∞—à—É –±–∏–±–ª–∏–æ—Ç–µ–∫—É, –æ–± –æ—à–∏–±–∫–µ –≤ –µ–≥–æ –∫–æ–¥–µ, —á—Ç–æ–±—ã –æ–Ω –º–æ–≥ –∏—Å–ø—Ä–∞–≤–∏—Ç—å –µ—ë. –ê–Ω–∞–ª–æ–≥–∏—á–Ω–æ, <code>panic!</code> –ø–æ–¥—Ö–æ–¥–∏—Ç, –µ—Å–ª–∏ –≤—ã –≤—ã–∑—ã–≤–∞–µ—Ç–µ –≤–Ω–µ—à–Ω–∏–π, –Ω–µ–ø–æ–¥–∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã–π –≤–∞–º –∫–æ–¥, –∏ –æ–Ω –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –≤—ã –Ω–µ –º–æ–∂–µ—Ç–µ –∏—Å–ø—Ä–∞–≤–∏—Ç—å.</p>
<p>–û–¥–Ω–∞–∫–æ, –∫–æ–≥–¥–∞ —Å–±–æ–π –æ–∂–¥–∏–∞–µ–º, –ª—É—á—à–µ –≤–µ—Ä–Ω—É—Ç—å <code>Result</code>, —á–µ–º –≤—ã–ø–æ–ª–Ω–∏—Ç—å –≤—ã–∑–æ–≤ <code>panic!</code>. –í –∫–∞—á–µ—Å—Ç–≤–µ –ø—Ä–∏–º–µ—Ä–∞ –º–æ–∂–Ω–æ –ø—Ä–∏–≤–µ—Å—Ç–∏ —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä, –∫–æ—Ç–æ—Ä–æ–º—É –ø–µ—Ä–µ–¥–∞–ª–∏ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ —Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ, –∏–ª–∏ HTTP-–∑–∞–ø—Ä–æ—Å, –≤–æ–∑–≤—Ä–∞—â–∞—é—â–∏–π —Å—Ç–∞—Ç—É—Å, —É–∫–∞–∑—ã–≤–∞—é—â–∏–π –Ω–∞ —Ç–æ, —á—Ç–æ –≤—ã –¥–æ—Å—Ç–∏–≥–ª–∏ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –Ω–∞ —á–∞—Å—Ç–æ—Ç—É –∑–∞–ø—Ä–æ—Å–æ–≤. –í —ç—Ç–∏—Ö —Å–ª—É—á–∞—è—Ö –≤–æ–∑–≤—Ä–∞—Ç <code>Result</code> –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –æ—à–∏–±–∫–∞ —è–≤–ª—è–µ—Ç—Å—è –æ–∂–∏–¥–∞–µ–º–æ–π –∏ –≤—ã–∑—ã–≤–∞—é—â–∏–π –∫–æ–¥ –¥–æ–ª–∂–µ–Ω —Ä–µ—à–∏—Ç—å, –∫–∞–∫ –µ—ë –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å.</p>
<p>–ï—Å–ª–∏ –≤–∞—à –∫–æ–¥ –≤—ã–ø–æ–ª–Ω—è–µ—Ç –æ–ø–µ—Ä–∞—Ü–∏—é, –∫–æ—Ç–æ—Ä–∞—è –º–æ–∂–µ—Ç –ø–æ–¥–≤–µ—Ä–≥–Ω—É—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Ä–∏—Å–∫—É (–µ—Å–ª–∏ –æ–Ω–∞ –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π), –≤–∞—à –∫–æ–¥ –¥–æ–ª–∂–µ–Ω —Å–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –¥–æ–ø—É—Å—Ç–∏–º–æ—Å—Ç—å –∑–Ω–∞—á–µ–Ω–∏–π –∏ –ø–∞–Ω–∏–∫–æ–≤–∞—Ç—å, –µ—Å–ª–∏ –∑–Ω–∞—á–µ–Ω–∏—è –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º—ã. –¢–∞–∫ —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –¥–µ–ª–∞—Ç—å –≤ –æ—Å–Ω–æ–≤–Ω–æ–º –∏–∑ —Å–æ–æ–±—Ä–∞–∂–µ–Ω–∏–π –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏: –ø–æ–ø—ã—Ç–∫–∞ –æ–ø–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏ –º–æ–∂–µ—Ç –ø—Ä–∏–≤–µ—Å—Ç–∏ –∫ —É—è–∑–≤–∏–º–æ—Å—Ç—è–º. –≠—Ç–æ –æ—Å–Ω–æ–≤–Ω–∞—è –ø—Ä–∏—á–∏–Ω–∞, –ø–æ –∫–æ—Ç–æ—Ä–æ–π —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ –±—É–¥–µ—Ç –≤—ã–∑—ã–≤–∞—Ç—å <code>panic!</code>, –µ—Å–ª–∏ –ø—ã—Ç–∞—Ç—å—Å—è –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –ø–∞–º—è—Ç–∏ –≤–Ω–µ –≥—Ä–∞–Ω–∏—Ü —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö: –¥–æ—Å—Ç—É–ø –∫ –ø–∞–º—è—Ç–∏, –Ω–µ –æ—Ç–Ω–æ—Å—è—â–µ–π—Å—è –∫ —Ç–µ–∫—É—â–µ–π —Å—Ç—Ä—É–∫—Ç—É—Ä–µ –¥–∞–Ω–Ω—ã—Ö, —è–≤–ª—è–µ—Ç—Å—è –∏–∑–≤–µ—Å—Ç–Ω–æ–π –ø—Ä–æ–±–ª–µ–º–æ–π –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏. –§—É–Ω–∫—Ü–∏–∏ —á–∞—Å—Ç–æ –∏–º–µ—é—Ç –∫–æ–Ω—Ç—Ä–∞–∫—Ç—ã: –∏—Ö –ø–æ–≤–µ–¥–µ–Ω–∏–µ –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç—Å—è, —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –≤—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –æ—Ç–≤–µ—á–∞—é—Ç –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã–º —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º. –ü–∞–Ω–∏–∫–∞ –ø—Ä–∏ –Ω–∞—Ä—É—à–µ–Ω–∏–∏ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞ –∏–º–µ–µ—Ç —Å–º—ã—Å–ª, –ø–æ—Ç–æ–º—É —á—Ç–æ —ç—Ç–æ –≤—Å–µ–≥–¥–∞ —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ –¥–µ—Ñ–µ–∫—Ç —Å–æ —Å—Ç–æ—Ä–æ–Ω—ã –≤—ã–∑—ã–≤–∞—é—â–µ–≥–æ –∫–æ–¥–∞, –∏ —ç—Ç–æ –Ω–µ —Ç–∞ –æ—à–∏–±–∫–∞, –æ–±—Ä–∞–±–æ—Ç–∫—É –∫–æ—Ç–æ—Ä–æ–π –≤—ã —Ö–æ—Ç–µ–ª–∏ –±—ã –æ—Ç–¥–∞—Ç—å –≤—ã–∑—ã–≤–∞—é—â–µ–º—É –∫–æ–¥—É. –í —ç—Ç–æ–º —Å–ª—É—á–∞–µ –Ω–µ—Ç —Ä–∞–∑—É–º–Ω–æ–≥–æ —Å–ø–æ—Å–æ–±–∞ –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –≤—ã–∑—ã–≤–∞—é—â–µ–≥–æ –∫–æ–¥–∞: <em>–ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç—ã</em>, –≤—ã–∑—ã–≤–∞—é—â–∏–µ –≤–∞—à –∫–æ–¥, –¥–æ–ª–∂–Ω—ã –∏—Å–ø—Ä–∞–≤–∏—Ç—å —Å–≤–æ–π. –ö–æ–Ω—Ç—Ä–∞–∫—Ç—ã –¥–ª—è —Ñ—É–Ω–∫—Ü–∏–∏ (–æ—Å–æ–±–µ–Ω–Ω–æ –∫–æ–≥–¥–∞ –∏—Ö –Ω–∞—Ä—É—à–µ–Ω–∏–µ –≤—ã–∑—ã–≤–∞–µ—Ç –ø–∞–Ω–∏–∫—É) —Å–ª–µ–¥—É–µ—Ç –æ–ø–∏—Å—ã–≤–∞—Ç—å –≤ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ API —Ñ—É–Ω–∫—Ü–∏–∏.</p>
<p>–¢–µ–º –Ω–µ –º–µ–Ω–µ–µ, –Ω–∞–ª–∏—á–∏–µ –º–Ω–æ–∂–µ—Å—Ç–≤–∞ –ø—Ä–æ–≤–µ—Ä–æ–∫ –æ—à–∏–±–æ–∫ –≤–æ –≤—Å–µ—Ö –≤–∞—à–∏—Ö —Ñ—É–Ω–∫—Ü–∏—è—Ö –±—ã–ª–æ –±—ã –º–Ω–æ–≥–æ—Å–ª–æ–≤–Ω—ã–º –∏ —Ä–∞–∑–¥—Ä–∞–∂–∏—Ç–µ–ª—å–Ω—ã–º. –ö —Å—á–∞—Å—Ç—å—é, –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å–∏—Å—Ç–µ–º—É —Ç–∏–ø–æ–≤ Rust –∏ –µ—ë –ø—Ä–æ–≤–µ—Ä–∫—É –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–æ–º, —á—Ç–æ–±—ã –æ–Ω–∞ —Å–¥–µ–ª–∞–ª–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–æ –ø—Ä–æ–≤–µ—Ä–æ–∫ –≤–º–µ—Å—Ç–æ –≤–∞—Å. –ï—Å–ª–∏ –≤–∞—à–∞ —Ñ—É–Ω–∫—Ü–∏—è –∏–º–µ–µ—Ç –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã–π —Ç–∏–ø –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞, –≤—ã –º–æ–∂–µ—Ç–µ —Ä–∞–±–æ—Ç–∞—Ç—å –Ω–µ–ø–æ—Å—Ä–µ–¥—Å—Ç–≤–µ–Ω–Ω–æ –Ω–∞–¥ –ª–æ–≥–∏–∫–æ–π –ø—Ä–æ–≥—Ä–∞–º–º—ã, –∑–Ω–∞—è, —á—Ç–æ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä —É–∂–µ –æ–±–µ—Å–ø–µ—á–∏–ª –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ. –ù–∞–ø—Ä–∏–º–µ—Ä, –µ—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –æ–±—ã—á–Ω—ã–π —Ç–∏–ø, –∞ –Ω–µ —Ç–∏–ø <code>Option</code>, —Ç–æ –≤–∞—à–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∞ –æ–∂–∏–¥–∞–µ—Ç –Ω–∞–ª–∏—á–∏–µ <em>—á–µ–≥–æ-—Ç–æ</em>, –∞ –Ω–µ <em>–Ω–∏—á–µ–≥–æ</em>. –í–∞—à –∫–æ–¥ –Ω–µ –¥–æ–ª–∂–µ–Ω –±—É–¥–µ—Ç –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –æ–±–∞ –≤–∞—Ä–∏–∞–Ω—Ç–∞ <code>Some</code> –∏ <code>None</code>: –æ–Ω –±—É–¥–µ—Ç –∏–º–µ—Ç—å —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω –≤–∞—Ä–∏–∞–Ω—Ç –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è. –ö–æ–¥, –ø—ã—Ç–∞—é—â–∏–π—Å—è –Ω–∏—á–µ–≥–æ –Ω–µ –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å –≤ —Ñ—É–Ω–∫—Ü–∏—é, –Ω–µ –±—É–¥–µ—Ç –¥–∞–∂–µ –∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞—Ç—å—Å—è, –ø–æ—ç—Ç–æ–º—É –≤–∞—à–∞ —Ñ—É–Ω–∫—Ü–∏—è –Ω–µ –¥–æ–ª–∂–Ω–∞ –ø—Ä–æ–≤–µ—Ä—è—Ç—å —Ç–∞–∫–æ–π —Å–ª—É—á–∞–π –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è. –î—Ä—É–≥–æ–π –ø—Ä–∏–º–µ—Ä ‚Äî —ç—Ç–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –±–µ–∑–∑–Ω–∞–∫–æ–≤–æ–≥–æ —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞, —Ç–∞–∫–æ–≥–æ –∫–∞–∫ <code>u32</code>, –∫–æ—Ç–æ—Ä—ã–π –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç, —á—Ç–æ –ø–∞—Ä–∞–º–µ—Ç—Ä –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –±—É–¥–µ—Ç –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–º.</p>
<h3 id="creating-custom-types-for-validation"><a class="header" href="#creating-custom-types-for-validation">Creating Custom Types for Validation</a></h3>
<p>–î–∞–≤–∞–π—Ç–µ —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º –∏–¥–µ—é –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Å–∏—Å—Ç–µ–º—ã —Ç–∏–ø–æ–≤ Rust –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –ø—Ä–æ–≤–µ—Ä—è—Ç—å –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è. –í—Å–ø–æ–º–Ω–∏–º –∏–≥—Ä—É –≤ —É–≥–∞–¥–∞–π–∫—É –∏–∑ –ì–ª–∞–≤—ã 2, –≤ –∫–æ—Ç–æ—Ä–æ–π –Ω–∞—à –∫–æ–¥ –ø—Ä–æ—Å–∏–ª –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —É–≥–∞–¥–∞—Ç—å —á–∏—Å–ª–æ –æ—Ç 1 –¥–æ 100. –ú—ã –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –ø—Ä–æ–≤–µ—Ä—è–ª–∏, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ –¥–æ–≥–∞–¥–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –º–µ–∂–¥—É —ç—Ç–∏–º–∏ —á–∏—Å–ª–∞–º–∏, –ø—Ä–µ–∂–¥–µ —á–µ–º —Å–≤–µ—Ä—è—Ç—å –µ–≥–æ —Å –Ω–∞—à–∏–º –∑–∞–≥–∞–¥–∞–Ω–Ω—ã–º —á–∏—Å–ª–æ–º; –º—ã —Ç–æ–ª—å–∫–æ —É–¥–æ—Å—Ç–æ–≤–µ—Ä—è–ª–∏—Å—å, —á—Ç–æ –¥–æ–≥–∞–¥–∫–∞ –±—ã–ª–∞ –±–æ–ª—å—à–µ –Ω—É–ª—è. –í —ç—Ç–æ–º —Å–ª—É—á–∞–µ –º—ã –Ω–∏—á–µ–≥–æ –Ω–µ –ø–æ—Ç–µ—Ä—è–ª–∏: –Ω–∞—à–∏ —Å–æ–æ–±—â–µ–Ω–∏—è "–°–ª–∏—à–∫–æ–º –º–∞–ª–µ–Ω—å–∫–æ–µ!" –∏ "–°–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–µ!" –≤—Å—ë —Ä–∞–≤–Ω–æ –±—ã–ª–∏ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º–∏. –ù–æ –±—ã–ª–æ –±—ã –ª—É—á—à–µ –ø–æ–¥—Ç–∞–ª–∫–∏–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∫ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º –¥–æ–≥–∞–¥–∫–∞–º –∏ –∏–º–µ—Ç—å —Ä–∞–∑–ª–∏—á–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ –¥–ª—è —Å–ª—É—á–∞–µ–≤, –∫–æ–≥–¥–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø—Ä–µ–¥–ª–∞–≥–∞–µ—Ç —á–∏—Å–ª–æ –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ –¥–∏–∞–ø–∞–∑–æ–Ω–∞, –∏ –∫–æ–≥–¥–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤–≤–æ–¥–∏—Ç, –Ω–∞–ø—Ä–∏–º–µ—Ä, –±—É–∫–≤—ã –≤–º–µ—Å—Ç–æ —Ü–∏—Ñ—Ä.</p>
<p>–û–¥–∏–Ω –∏–∑ —Å–ø–æ—Å–æ–±–æ–≤ –¥–æ–±–∏—Ç—å—Å—è —ç—Ç–æ–≥–æ ‚Äî –ø—ã—Ç–∞—Ç—å—Å—è —Ä–∞–∑–æ–±—Ä–∞—Ç—å –≤–≤–µ–¥—ë–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∫–∞–∫ <code>i32</code>, –∞ –Ω–µ –∫–∞–∫ <code>u32</code>, —á—Ç–æ–±—ã —Ä–∞–∑—Ä–µ—à–∏—Ç—å –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–µ —á–∏—Å–ª–∞, –∞ –∑–∞—Ç–µ–º –¥–æ–±–∞–≤–∏—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É –Ω–∞ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–Ω–æ—Å—Ç—å —á–∏—Å–ª–∞ –¥–∏–∞–ø–∞–∑–æ–Ω—É; –Ω–∞–ø—Ä–∏–º–µ—Ä, —Ç–∞–∫:</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("–£–≥–∞–¥–∞–π—Ç–µ —á–∏—Å–ª–æ!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    loop {
        // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--

<span class="boring">        println!("–í–≤–µ–¥–∏—Ç–µ —Å–≤–æ—é –¥–æ–≥–∞–¥–∫—É.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–µ—Å—Ç—å –≤–≤–æ–¥.");
</span><span class="boring">
</span>        let guess: i32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        if guess &lt; 1 || guess &gt; 100 {
            println!("–ó–∞–≥–∞–¥–∞–Ω–Ω–æ–µ —á–∏—Å–ª–æ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –æ—Ç 1 –¥–æ 100.");
            continue;
        }

        match guess.cmp(&amp;secret_number) {
            // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">            Ordering::Less =&gt; println!("–°–ª–∏—à–∫–æ–º –º–∞–ª–µ–Ω—å–∫–æ–µ!"),
</span><span class="boring">            Ordering::Greater =&gt; println!("–°–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–µ!"),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!("–í—ã –ø–æ–±–µ–¥–∏–ª–∏!");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span>    }
<span class="boring">}</span></code></pre>
</Listing>
<p>–í—ã—Ä–∞–∂–µ–Ω–∏–µ <code>if</code> –ø—Ä–æ–≤–µ—Ä—è–µ—Ç, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ –Ω–∞—à–µ –∑–Ω–∞—á–µ–Ω–∏–µ –≤–Ω–µ –¥–∏–∞–ø–∞–∑–æ–Ω–∞, —Å–æ–æ–±—â–∞–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –æ –ø—Ä–æ–±–ª–µ–º–µ –∏ –≤—ã–∑—ã–≤–∞–µ—Ç <code>continue</code>, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å —Å–ª–µ–¥—É—é—â—É—é –∏—Ç–µ—Ä–∞—Ü–∏—é —Ü–∏–∫–ª–∞ –∏ –ø–æ–ø—Ä–æ—Å–∏—Ç—å –≤–≤–µ—Å—Ç–∏ –¥—Ä—É–≥–æ–µ —á–∏—Å–ª–æ. –ü–æ—Å–ª–µ –≤—ã—Ä–∞–∂–µ–Ω–∏—è <code>if</code> –º—ã –º–æ–∂–µ–º –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è <code>guess</code> —Å –∑–∞–≥–∞–¥–∞–Ω–Ω—ã–º —á–∏—Å–ª–æ–º, –∑–Ω–∞—è, —á—Ç–æ <code>guess</code> –ª–µ–∂–∏—Ç –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ –æ—Ç 1 –¥–æ 100.</p>
<p>–û–¥–Ω–∞–∫–æ —ç—Ç–æ –Ω–µ –∏–¥–µ–∞–ª—å–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ: –µ—Å–ª–∏ –±—ã –±—ã–ª–æ —á—Ä–µ–∑–≤—ã—á–∞–π–Ω–æ –≤–∞–∂–Ω–æ, —á—Ç–æ–±—ã –ø—Ä–æ–≥—Ä–∞–º–º–∞ —Ä–∞–±–æ—Ç–∞–ª–∞ —Ç–æ–ª—å–∫–æ —Å–æ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏ –æ—Ç 1 –¥–æ 100, –∏ –µ—Å–ª–∏ –±—ã —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–ª–æ –º–Ω–æ–≥–æ —Ñ—É–Ω–∫—Ü–∏–π, —Ç—Ä–µ–±—É—é—â–∏—Ö —ç—Ç–æ–≥–æ, —Ç–æ —Ç–∞–∫–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –≤ –∫–∞–∂–¥–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –±—ã–ª–∞ –±—ã —É—Ç–æ–º–∏—Ç–µ–ª—å–Ω–æ–π (–∏ –º–æ–≥–ª–∞ –±—ã –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ –ø–æ–≤–ª–∏—è—Ç—å –Ω–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å).</p>
<p>–í–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ –º–æ–∂–Ω–æ —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π —Ç–∏–ø –∏ –ø–æ–º–µ—Å—Ç–∏—Ç—å –ø—Ä–æ–≤–µ—Ä–∫–∏ –≤ —Ñ—É–Ω–∫—Ü–∏—é —Å–æ–∑–¥–∞–Ω–∏—è —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ —ç—Ç–æ–≥–æ —Ç–∏–ø–∞, –Ω–µ –ø–æ–≤—Ç–æ—Ä—è—è –∏—Ö –ø–æ–≤—Å—é–¥—É. –¢–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, —Ñ—É–Ω–∫—Ü–∏–∏ –º–æ–≥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–æ–≤—ã–π —Ç–∏–ø –≤ —Å–≤–æ–∏—Ö —Å–∏–≥–Ω–∞—Ç—É—Ä–∞—Ö –∏ –±—ã—Ç—å —É–≤–µ—Ä–µ–Ω–Ω—ã–º–∏ –≤ –∑–Ω–∞—á–µ–Ω–∏—è—Ö, –∫–æ—Ç–æ—Ä—ã–µ –∏–º –ø–µ—Ä–µ–¥–∞—é—Ç. –õ–∏—Å—Ç–∏–Ω–≥ 9-13 –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –æ–¥–∏–Ω –∏–∑ —Å–ø–æ—Å–æ–±–æ–≤, –∫–∞–∫ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ç–∏–ø <code>Guess</code>, —á—Ç–æ–±—ã —ç–∫–∑–µ–º–ø–ª—è—Ä <code>Guess</code> —Å–æ–∑–¥–∞–≤–∞–ª—Å—è —Ç–æ–ª—å–∫–æ –ø—Ä–∏ —É—Å–ª–æ–≤–∏–∏, —á—Ç–æ —Ñ—É–Ω–∫—Ü–∏—è <code>new</code> –ø–æ–ª—É—á–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ –æ—Ç 1 –¥–æ 100.</p>
<Listing number="9-13" caption="A `Guess` type that will only continue with values between 1 and 100">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!("–î–æ–≥–∞–¥–∫–∞ {value} –Ω–µ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç –ø—Ä–µ–¥–µ–ª—É –æ—Ç 1 –¥–æ 100.");
        }

        Guess { value }
    }

    pub fn value(&amp;self) -&gt; i32 {
        self.value
    }
}
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>–°–Ω–∞—á–∞–ª–∞ –º—ã –æ–ø—Ä–µ–¥–µ–ª—è–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É —Å –∏–º–µ–Ω–µ–º <code>Guess</code>, –∫–æ—Ç–æ—Ä–∞—è –∏–º–µ–µ—Ç –ø–æ–ª–µ —Å –∏–º–µ–Ω–µ–º <code>value</code> —Ç–∏–ø–∞ <code>i32</code>, –≤ –∫–æ—Ç–æ—Ä–æ–º –±—É–¥–µ—Ç —Ö—Ä–∞–Ω–∏—Ç—å—Å—è –¥–æ–≥–∞–¥–∫–∞.</p>
<p>–ó–∞—Ç–µ–º –º—ã —Ä–µ–∞–ª–∏–∑—É–µ–º –∞—Å—Å–æ—Ü–∏–∏—Ä–æ–≤–∞–Ω–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é <code>new</code>, —Å–æ–∑–¥–∞—é—â—É—é —ç–∫–∑–µ–º–ø–ª—è—Ä—ã –∑–Ω–∞—á–µ–Ω–∏–π —Ç–∏–ø–∞ <code>Guess</code>. –§—É–Ω–∫—Ü–∏—è <code>new</code> –∏–º–µ–µ—Ç –æ–¥–∏–Ω –ø–∞—Ä–∞–º–µ—Ç—Ä <code>value</code> —Ç–∏–ø–∞ <code>i32</code> –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç <code>Guess</code>. –ö–æ–¥ –≤ —Ç–µ–ª–µ —Ñ—É–Ω–∫—Ü–∏–∏ <code>new</code> –ø—Ä–æ–≤–µ—Ä—è–µ—Ç, —á—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ <code>value</code> –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –º–µ–∂–¥—É 1 –∏ 100. –ï—Å–ª–∏ <code>value</code> –Ω–µ –ø—Ä–æ—Ö–æ–¥–∏—Ç —ç—Ç—É –ø—Ä–æ–≤–µ—Ä–∫—É, –º—ã –≤—ã–∑—ã–≤–∞–µ–º <code>panic!</code>, –∫–æ—Ç–æ—Ä–∞—è –æ–ø–æ–≤–µ—Å—Ç–∏—Ç –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç–∞, –Ω–∞–ø–∏—Å–∞–≤—à–µ–≥–æ –≤—ã–∑—ã–≤–∞—é—â–∏–π –∫–æ–¥, —á—Ç–æ –≤ –µ–≥–æ –∫–æ–¥–µ –µ—Å—Ç—å –æ—à–∏–±–∫–∞, –∫–æ—Ç–æ—Ä—É—é –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –∏—Å–ø—Ä–∞–≤–∏—Ç—å, –ø–æ—Å–∫–æ–ª—å–∫—É –ø–æ–ø—ã—Ç–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è <code>Guess</code> —Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º <code>value</code> –≤–Ω–µ –∑–∞–¥–∞–Ω–Ω–æ–≥–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞ –Ω–∞—Ä—É—à–∞–µ—Ç –∫–æ–Ω—Ç—Ä–∞–∫—Ç, –Ω–∞ –∫–æ—Ç–æ—Ä—ã–π –ø–æ–ª–∞–≥–∞–µ—Ç—Å—è <code>Guess::new</code>. –£—Å–ª–æ–≤–∏—è, –≤ –∫–æ—Ç–æ—Ä—ã—Ö <code>Guess::new</code> –ø–∞–Ω–∏–∫—É–µ—Ç, –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –æ–ø–∏—Å–∞–Ω—ã –≤ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ API; –º—ã —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º –¥–æ–∫—É–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –≤—ã–∑–æ–≤–∞ <code>panic!</code> –Ω–∞ –ø—Ä–∏–º–µ—Ä–µ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ API, –∫–æ—Ç–æ—Ä—É—é –≤—ã —Å–æ–∑–¥–∞–¥–∏—Ç–µ –≤ –ì–ª–∞–≤–µ 14. –ï—Å–ª–∏ <code>value</code> –ø—Ä–æ—Ö–æ–¥–∏—Ç –ø—Ä–æ–≤–µ—Ä–∫—É, –º—ã —Å–æ–∑–¥–∞—ë–º –Ω–æ–≤—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä <code>Guess</code>, —É –∫–æ—Ç–æ—Ä–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ–ª—è <code>value</code> —Ä–∞–≤–Ω–æ –∑–Ω–∞—á–µ–Ω–∏—é –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ <code>value</code>, –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º <code>Guess</code>.</p>
<p>–ó–∞—Ç–µ–º –º—ã —Ä–µ–∞–ª–∏–∑—É–µ–º –º–µ—Ç–æ–¥ —Å –Ω–∞–∑–≤–∞–Ω–∏–µ–º <code>value</code>, –∫–æ—Ç–æ—Ä—ã–π —Ç–æ–ª—å–∫–æ –∑–∞–∏–º—Å—Ç–≤—É–µ—Ç <code>self</code> –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ —Ç–∏–ø–∞ <code>i32</code>. –≠—Ç–æ—Ç –º–µ—Ç–æ–¥ –∏–Ω–æ–≥–¥–∞ –Ω–∞–∑—ã–≤–∞—é—Ç <em>–≥–µ—Ç—Ç–µ—Ä–æ–º</em> (–∞–Ω–≥–ª. <em>getter</em>), –ø–æ—Ç–æ–º—É —á—Ç–æ –µ–≥–æ —Ü–µ–ª—å —Å–æ—Å—Ç–æ–∏—Ç –≤ —Ç–æ–º, —á—Ç–æ–±—ã –∏–∑–≤–ª–µ—á—å –¥–∞–Ω–Ω—ã–µ –∏–∑ –ø–æ–ª–µ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –∏ –≤–µ—Ä–Ω—É—Ç—å –∏—Ö. –≠—Ç–æ—Ç –ø—É–±–ª–∏—á–Ω—ã–π –º–µ—Ç–æ–¥ —è–≤–ª—è–µ—Ç—Å—è –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–º, –ø–æ—Å–∫–æ–ª—å–∫—É –ø–æ–ª–µ <code>value</code> —Å—Ç—Ä—É–∫—Ç—É—Ä—ã <code>Guess</code> —è–≤–ª—è–µ—Ç—Å—è –ø—Ä–∏–≤–∞—Ç–Ω—ã–º. –í–∞–∂–Ω–æ, —á—Ç–æ–±—ã –ø–æ–ª–µ <code>value</code> –±—ã–ª–æ –ø—Ä–∏–≤–∞—Ç–Ω—ã–º, –¥–ª—è —Ç–æ–≥–æ —á—Ç–æ–±—ã –∫–æ–¥, –∏—Å–ø–æ–ª—å–∑—É—é—â–∏–π —Å—Ç—Ä—É–∫—Ç—É—Ä—É <code>Guess</code>, –Ω–µ –º–æ–≥ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—Ç—å <code>value</code> –Ω–∞–ø—Ä—è–º—É—é: –∫–æ–¥ —Å–Ω–∞—Ä—É–∂–∏ –º–æ–¥—É–ª—è <em>–¥–æ–ª–∂–µ–Ω</em> –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ñ—É–Ω–∫—Ü–∏—é <code>Guess::new</code> –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ <code>Guess</code>, —Ç–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É—è, —á—Ç–æ —É <code>Guess</code> –Ω–µ—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –ø–æ–ª—É—á–∏—Ç—å <code>value</code>, –Ω–µ –ø—Ä–æ–≤–µ—Ä–µ–Ω–Ω–æ–µ —É—Å–ª–æ–≤–∏—è–º–∏ –≤ —Ñ—É–Ω–∫—Ü–∏–∏ <code>Guess::new</code>.</p>
<p>–§—É–Ω–∫—Ü–∏—è, –∫–æ—Ç–æ—Ä–∞—è –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –∏–ª–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–æ–ª—å–∫–æ —á–∏—Å–ª–∞ –æ—Ç 1 –¥–æ 100, –º–æ–∂–µ—Ç –æ–±—ä—è–≤–∏—Ç—å –≤ —Å–≤–æ–µ–π —Å–∏–≥–Ω–∞—Ç—É—Ä–µ, —á—Ç–æ –æ–Ω–∞ –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –∏–ª–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç <code>Guess</code>, –∞ –Ω–µ <code>i32</code>. –¢–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, –Ω–µ –±—É–¥–µ—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –¥–µ–ª–∞—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –≤ —Ç–µ–ª–µ —Ç–∞–∫–æ–π —Ñ—É–Ω–∫—Ü–∏–∏.</p>
<h2 id="–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-8"><a class="header" href="#–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-8">–ü–æ–¥–≤–µ–¥—ë–º –∏—Ç–æ–≥–∏</a></h2>
<p>–§—É–Ω–∫—Ü–∏–∏ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫ –≤ Rust –ø—Ä–∏–∑–≤–∞–Ω—ã –ø–æ–º–æ—á—å –Ω–∞–ø–∏—Å–∞–Ω–∏—é –±–æ–ª–µ–µ –Ω–∞–¥—ë–∂–Ω–æ–≥–æ –∫–æ–¥–∞. –ú–∞–∫—Ä–æ—Å <code>panic!</code> —Å–∏–≥–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç, —á—Ç–æ –≤–∞—à–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∞ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏, –∫–æ—Ç–æ—Ä–æ–µ –æ–Ω–∞ –Ω–µ –º–æ–∂–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å, –∏ –ø–æ–∑–≤–æ–ª—è–µ—Ç —Å–∫–∞–∑–∞—Ç—å –ø—Ä–æ–≥—Ä–∞–º–º–µ, —á—Ç–æ–±—ã —Ç–∞ –ø—Ä–µ–∫—Ä–∞—Ç–∏–ª–∞ —Å–≤–æ—ë –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ, –≤–º–µ—Å—Ç–æ –ø–æ–ø—ã—Ç–∫–∏ –ø—Ä–æ–¥–æ–ª–∂–∞—Ç—å –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ —Å –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–º–∏ –∏–ª–∏ –Ω–µ–≤–µ—Ä–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏. –ü–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ <code>Result</code> –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —Å–∏—Å—Ç–µ–º—É —Ç–∏–ø–æ–≤ Rust, —á—Ç–æ–±—ã —Å–æ–æ–±—â–∞—Ç—å, —á—Ç–æ –æ–ø–µ—Ä–∞—Ü–∏–∏ –º–æ–≥—É—Ç –∑–∞–≤–µ—Ä—à–∏—Ç—å—Å—è –Ω–µ—É–¥–∞—á–µ–π, –∏ —á—Ç–æ–±—ã –≤–∞—à –∫–æ–¥ –º–æ–≥ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ. –ú–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å <code>Result</code>, —á—Ç–æ–±—ã —Å–æ–æ–±—â–∞—Ç—å –≤—ã–∑—ã–≤–∞—é—â–µ–º—É –∫–æ–¥—É, —á—Ç–æ –æ–Ω –¥–æ–ª–∂–µ–Ω –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–π —É—Å–ø–µ—Ö –∏–ª–∏ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—É—é –Ω–µ—É–¥–∞—á—É. –ü—Ä–∞–≤–∏–ª—å–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ <code>panic!</code> –∏ <code>Result</code> —Å–¥–µ–ª–∞–µ—Ç –≤–∞—à –∫–æ–¥ –±–æ–ª–µ–µ –Ω–∞–¥—ë–∂–Ω—ã–º –ø–µ—Ä–µ–¥ –ª–∏—Ü–æ–º –Ω–µ–∏–∑–±–µ–∂–Ω—ã—Ö –ø—Ä–æ–±–ª–µ–º.</p>
<p>–¢–µ–ø–µ—Ä—å, –∫–æ–≥–¥–∞ –≤—ã —É–≤–∏–¥–µ–ª–∏ –ø–æ–ª–µ–∑–Ω—ã–µ —Å–ø–æ—Å–æ–±—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –æ–±–æ–±—â—ë–Ω–Ω—ã—Ö —Ç–∏–ø–æ–≤ <code>Option</code> –∏ <code>Result</code>, –º—ã –ø–æ–≥–æ–≤–æ—Ä–∏–º –æ —Ç–æ–º, –∫–∞–∫ –≤–æ–æ–±—â–µ —Ä–∞–±–æ—Ç–∞—é—Ç –æ–±–æ–±—â—ë–Ω–Ω—ã–µ —Ç–∏–ø—ã –∏ –∫–∞–∫ –≤—ã –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏—Ö –≤ —Å–≤–æ—ë–º –∫–æ–¥–µ.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="–û–±–æ–±—â—ë–Ω–Ω—ã–µ-—Ç–∏–ø—ã-—Ç—Ä–µ–π—Ç—ã-–∏-–≤—Ä–µ–º–µ–Ω–∞-–∂–∏–∑–Ω–∏"><a class="header" href="#–û–±–æ–±—â—ë–Ω–Ω—ã–µ-—Ç–∏–ø—ã-—Ç—Ä–µ–π—Ç—ã-–∏-–≤—Ä–µ–º–µ–Ω–∞-–∂–∏–∑–Ω–∏">–û–±–æ–±—â—ë–Ω–Ω—ã–µ —Ç–∏–ø—ã, —Ç—Ä–µ–π—Ç—ã –∏ –≤—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏</a></h1>
<p>–ö–∞–∂–¥—ã–π —è–∑—ã–∫ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è –∏–º–µ–µ—Ç –≤ —Å–≤–æ—ë–º –∞—Ä—Å–µ–Ω–∞–ª–µ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–µ —Å—Ä–µ–¥—Å—Ç–≤–∞ –±–æ—Ä—å–±—ã —Å –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ–º –∫–æ–¥–∞. –í Rust –æ–¥–Ω–∏–º –∏–∑ —Ç–∞–∫–∏—Ö –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ —è–≤–ª—è—é—Ç—Å—è <em>–æ–±–æ–±—â–µ–Ω–∏—è</em> ‚Äî –∞–±—Å—Ç—Ä–∞–∫—Ç–Ω—ã–µ –∑–∞–º–µ—Å—Ç–∏—Ç–µ–ª–∏, –Ω–∞ –º–µ—Å—Ç–æ –∫–æ—Ç–æ—Ä—ã—Ö –≤–æ–∑–º–æ–∂–Ω–æ –ø–æ—Å—Ç–∞–≤–∏—Ç—å –∫–∞–∫–æ–π-–ª–∏–±–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —Ç–∏–ø –∏–ª–∏ –¥—Ä—É–≥–æ–µ —Å–≤–æ–π—Å—Ç–≤–æ. –ö–æ–≥–¥–∞ –º—ã –ø–∏—à–µ–º –∫–æ–¥, –º—ã –º–æ–∂–µ–º –≤—ã—Ä–∞–∑–∏—Ç—å –ø–æ–≤–µ–¥–µ–Ω–∏–µ –æ–±–æ–±—â–µ–Ω–∏–π –∏–ª–∏ –∏—Ö —Å–≤—è–∑—å —Å –¥—Ä—É–≥–∏–º–∏ –æ–±–æ–±—â–µ–Ω–∏—è–º–∏, –Ω–µ –∑–Ω–∞—è, —á—Ç–æ –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ –Ω–∞ –∏—Ö –º–µ—Å—Ç–µ –ø—Ä–∏ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –∏ –∑–∞–ø—É—Å–∫–µ –∫–æ–¥–∞.</p>
<p>–§—É–Ω–∫—Ü–∏–∏ –º–æ–≥—É—Ç –ø—Ä–∏–Ω–∏–º–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –Ω–µ–∫–æ—Ç–æ—Ä–æ–≥–æ –æ–±–æ–±—â—ë–Ω–Ω–æ–≥–æ, –∞ –Ω–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Ç–∏–ø–∞ (–≤—Ä–æ–¥–µ <code>i32</code> –∏–ª–∏ <code>String</code>), –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ —Ç–æ–º—É, —á—Ç–æ —Ñ—É–Ω–∫—Ü–∏—è –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Å –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–º–∏ –∑–∞—Ä–∞–Ω–µ–µ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏, —á—Ç–æ–±—ã –≤—ã–ø–æ–ª–Ω—è—Ç—å –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ –¥–µ–π—Å—Ç–≤–∏—è –Ω–∞–¥ —Ä–∞–∑–ª–∏—á–Ω—ã–º–∏ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏. –ù–∞ —Å–∞–º–æ–º –¥–µ–ª–µ, –º—ã —É–∂–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ –æ–±–æ–±—â—ë–Ω–Ω—ã–µ —Ç–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö –≤ –ì–ª–∞–≤–µ 6 (<code>Option&lt;T&gt;</code>), –≤ –ì–ª–∞–≤–µ 8 (<code>Vec&lt;T&gt;</code> –∏ <code>HashMap&lt;K, V&gt;</code>) –∏ –≤ –ì–ª–∞–≤–µ 9 (<code>Result&lt;T, E&gt;</code>). –í —ç—Ç–æ–π –≥–ª–∞–≤–µ –≤—ã —É–∑–Ω–∞–µ—Ç–µ, –∫–∞–∫ –æ–ø—Ä–µ–¥–µ–ª—è—Ç—å —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ –æ–±–æ–±—â—ë–Ω–Ω—ã–µ —Ç–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö, —Ñ—É–Ω–∫—Ü–∏–∏ –∏ –º–µ—Ç–æ–¥—ã.</p>
<p>–ü–µ—Ä–≤—ã–º –¥–µ–ª–æ–º, –º—ã —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º –∫–∞–∫ –¥–ª—è —É–º–µ–Ω—å—à–µ–Ω–∏—è –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è –∏–∑–≤–ª–µ—á—å –∏–∑ –∫–æ–¥–∞ –Ω–µ–∫–æ—Ç–æ—Ä—É—é –æ–±—â—É—é —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å. –î–∞–ª–µ–µ, –º—ã –±—É–¥–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–æ—Ç –∂–µ –º–µ—Ö–∞–Ω–∏–∑–º –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –æ–±–æ–±—â—ë–Ω–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –∏–∑ –¥–≤—É—Ö —Ñ—É–Ω–∫—Ü–∏–π, –∫–æ—Ç–æ—Ä—ã–µ –æ—Ç–ª–∏—á–∞—é—Ç—Å—è —Ç–æ–ª—å–∫–æ —Ç–∏–ø–∞–º–∏ –∏—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤. –ú—ã —Ç–∞–∫–∂–µ –æ–±—ä—è—Å–Ω–∏–º, –∫–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –æ–±–æ–±—â—ë–Ω–Ω—ã–µ —Ç–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä –∏ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π.</p>
<p>–ü–æ—Å–ª–µ —ç—Ç–æ–≥–æ –º—ã –∏–∑—É—á–∏–º, –∫–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç—Ä–µ–π—Ç—ã –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –ø–æ–≤–µ–¥–µ–Ω–∏—è –≤ –æ–±–æ–±—â—ë–Ω–Ω–æ–º –≤–∏–¥–µ. –ú–æ–∂–Ω–æ –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞—Ç—å —Ç—Ä–µ–π—Ç—ã —Å –æ–±–æ–±—â—ë–Ω–Ω—ã–º–∏ —Ç–∏–ø–∞–º–∏, —á—Ç–æ–±—ã –æ–±–æ–±—â—ë–Ω–Ω—ã–π —Ç–∏–ø –º–æ–≥ –ø—Ä–∏–Ω–∏–º–∞—Ç—å —Ç–æ–ª—å–∫–æ —Ç–∞–∫–∏–µ —Ç–∏–ø—ã, –∫–æ—Ç–æ—Ä—ã–µ –∏–º–µ—é—Ç –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ, –∞ –Ω–µ –≤—Å–µ –ø–æ–¥—Ä—è–¥.</p>
<p>–í –∫–æ–Ω—Ü–µ –º—ã –æ–±—Å—É–¥–∏–º <em>–≤—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏</em> ‚Äî —Ä–∞–∑–Ω–æ–≤–∏–¥–Ω–æ—Å—Ç—å –æ–±–æ–±—â–µ–Ω–∏—è, –∫–æ—Ç–æ—Ä–∞—è –¥–∞—ë—Ç –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä—É –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–æ–º, –∫–∞–∫ —Å—Å—ã–ª–∫–∏ –æ—Ç–Ω–æ—Å—è—Ç—Å—è –¥—Ä—É–≥ –∫ –¥—Ä—É–≥—É. –í—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏ –ø–æ–∑–≤–æ–ª—è—é—Ç –Ω–∞–º —É–∫–∞–∑–∞—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏—è—Ö, –∫–æ—Ç–æ—Ä–∞—è –ø–æ–∑–≤–æ–ª–∏—Ç –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä—É —É–¥–æ—Å—Ç–æ–≤–µ—Ä–∏—Ç—å—Å—è –≤ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã—Ö —Å—Å—ã–ª–æ–∫ –≤ —Ç–µ—Ö —Å–∏—Ç—É–∞—Ü–∏—è—Ö, –∫–æ–≥–¥–∞ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –Ω–µ –º–æ–∂–µ—Ç —Å–¥–µ–ª–∞—Ç—å —ç—Ç–æ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.</p>
<h2 id="–ò–∑–±–∞–≤–ª–µ–Ω–∏–µ-–æ—Ç-–¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è-–∫–æ–¥–∞-—Å-–ø–æ–º–æ—â—å—é-–≤—ã–¥–µ–ª–µ–Ω–∏—è-–æ–±—â–µ–π-—Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏"><a class="header" href="#–ò–∑–±–∞–≤–ª–µ–Ω–∏–µ-–æ—Ç-–¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è-–∫–æ–¥–∞-—Å-–ø–æ–º–æ—â—å—é-–≤—ã–¥–µ–ª–µ–Ω–∏—è-–æ–±—â–µ–π-—Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏">–ò–∑–±–∞–≤–ª–µ–Ω–∏–µ –æ—Ç –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è –∫–æ–¥–∞ —Å –ø–æ–º–æ—â—å—é –≤—ã–¥–µ–ª–µ–Ω–∏—è –æ–±—â–µ–π —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏</a></h2>
<p>–û–±–æ–±—â–µ–Ω–∏—è –ø–æ–∑–≤–æ–ª—è—é—Ç –Ω–∞–º –∑–∞–º–µ–Ω—è—Ç—å –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã–µ —Ç–∏–ø—ã –∑–∞–ø–æ–ª–Ω–∏—Ç–µ–ª—è–º–∏, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—â–∏–º–∏ –º–Ω–æ–∂–µ—Å—Ç–≤–æ —Ç–∏–ø–æ–≤, —á—Ç–æ–±—ã —É—Å—Ç—Ä–∞–Ω—è—Ç—å –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–¥–∞. –ü—Ä–µ–∂–¥–µ —á–µ–º —É–≥–ª—É–±–∏—Ç—å—Å—è –≤ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –æ–±–æ–±—â–µ–Ω–∏–π, –¥–∞–≤–∞–π—Ç–µ —Å–Ω–∞—á–∞–ª–∞ —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º, –∫–∞–∫ —É—Å—Ç—Ä–∞–Ω–∏—Ç—å –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –±–µ–∑ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –æ–±–æ–±—â—ë–Ω–Ω—ã—Ö —Ç–∏–ø–æ–≤, –∞ –ª–∏—à—å –∏–∑–≤–ª–µ–∫–∞—è —Ñ—É–Ω–∫—Ü–∏—é, –∫–æ—Ç–æ—Ä–∞—è –∑–∞–º–µ–Ω—è–µ—Ç –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –∑–∞–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–º, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—â–∏–º –Ω–µ—Å–∫–æ–ª—å–∫–æ –∑–Ω–∞—á–µ–Ω–∏–π. –ó–∞—Ç–µ–º –º—ã –ø—Ä–∏–º–µ–Ω–∏–º —Ç—É –∂–µ —Ç–µ—Ö–Ω–∏–∫—É –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –æ–±–æ–±—â—ë–Ω–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏. –ò–∑—É—á–∏–≤, –∫–∞–∫ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞—Ç—å –ø–æ–≤—Ç–æ—Ä—è—é—â–∏–π—Å—è –∫–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –≤—ã –º–æ–∂–µ—Ç–µ –∏–∑–≤–ª–µ—á—å –≤ —Ñ—É–Ω–∫—Ü–∏—é, –≤—ã –Ω–∞—á–Ω—ë—Ç–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞—Ç—å –ø–æ–≤—Ç–æ—Ä—è—é—â–∏–π—Å—è –∫–æ–¥, –≤ –∫–æ—Ç–æ—Ä–æ–º –º–æ–≥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –æ–±–æ–±—â–µ–Ω–∏—è.</p>
<p>–ù–∞—á–Ω—ë–º —Å –∫–æ—Ä–æ—Ç–∫–æ–π –ø—Ä–æ–≥—Ä–∞–º–º—ã –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 10-1, –∫–æ—Ç–æ—Ä–∞—è –Ω–∞—Ö–æ–¥–∏—Ç –Ω–∞–∏–±–æ–ª—å—à–µ–µ —á–∏—Å–ª–æ –≤ —Å–ø–∏—Å–∫–µ.</p>
<Listing number="10-1" file-name="src/main.rs" caption="Finding the largest number in a list of numbers">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = &amp;number_list[0];

    for number in &amp;number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!("–ù–∞–∏–±–æ–ª—å—à–µ–µ —á–∏—Å–ª–æ: {largest}");
<span class="boring">    assert_eq!(*largest, 100);
</span>}</code></pre></pre>
</Listing>
<p>–ú—ã —Ö—Ä–∞–Ω–∏–º —Å–ø–∏—Å–æ–∫ —Ü–µ–ª—ã—Ö —á–∏—Å–µ–ª –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π <code>number_list</code> –∏ –ø–æ–º–µ—â–∞–µ–º –ø–µ—Ä–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ —Å–ø–∏—Å–∫–∞ –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é <code>largest</code>. –î–∞–ª–µ–µ, –ø–µ—Ä–µ–±–∏—Ä–∞–µ–º –≤—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã —Å–ø–∏—Å–∫–∞, –∏, –µ—Å–ª–∏ —Ç–µ–∫—É—â–∏–π —ç–ª–µ–º–µ–Ω—Ç –±–æ–ª—å—à–µ —á–∏—Å–ª–∞, —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω–æ–≥–æ –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π <code>largest</code>, –∑–∞–º–µ–Ω—è–µ–º –∏–º –∑–Ω–∞—á–µ–Ω–∏–µ –≤ —ç—Ç–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π. –ï—Å–ª–∏ —Ç–µ–∫—É—â–∏–π —ç–ª–µ–º–µ–Ω—Ç –º–µ–Ω—å—à–µ –∏–ª–∏ —Ä–∞–≤–µ–Ω –Ω–∞–∏–±–æ–ª—å—à–µ–º—É, –Ω–∞–π–¥–µ–Ω–Ω–æ–º—É —Ä–∞–Ω–µ–µ, –∑–Ω–∞—á–µ–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –æ—Å—Ç–∞–≤–ª—è–º –ø—Ä–µ–∂–Ω–∏–º –∏ –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–º—É —ç–ª–µ–º–µ–Ω—Ç—É —Å–ø–∏—Å–∫–∞. –ü–æ—Å–ª–µ –ø–µ—Ä–µ–±–æ—Ä–∞ –≤—Å–µ—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —Å–ø–∏—Å–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è <code>largest</code> –¥–æ–ª–∂–Ω–∞ —Å–æ–¥–µ—Ä–∂–∞—Ç—å –Ω–∞–∏–±–æ–ª—å—à–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –≤ –Ω–∞—à–µ–º —Å–ª—É—á–∞–µ –±—É–¥–µ—Ç —Ä–∞–≤–Ω–æ 100.</p>
<p>–¢–µ–ø–µ—Ä—å –ø–µ—Ä–µ–¥ –Ω–∞–º–∏ —Å—Ç–æ–∏—Ç –∑–∞–¥–∞—á–∞ –Ω–∞–π—Ç–∏ –Ω–∞–∏–±–æ–ª—å—à–µ–µ —á–∏—Å–ª–æ –≤ –¥–≤—É—Ö —Ä–∞–∑–Ω—ã—Ö —Å–ø–∏—Å–∫–∞—Ö. –î–ª—è —ç—Ç–æ–≥–æ –º—ã –º–æ–∂–µ–º –¥—É–±–ª–∏—Ä–æ–≤–∞—Ç—å –∫–æ–¥ –∏–∑ –õ–∏—Å—Ç–∏–Ω–≥–∞ 10-1 –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç—É –∂–µ –ª–æ–≥–∏–∫—É –≤ –¥–≤—É—Ö —Ä–∞–∑–Ω—ã—Ö –º–µ—Å—Ç–∞—Ö –ø—Ä–æ–≥—Ä–∞–º–º—ã, –∫–∞–∫ –ø–æ–∫–∞–∑–∞–Ω–æ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 10-2.</p>
<Listing number="10-2" file-name="src/main.rs" caption="Code to find the largest number in *two* lists of numbers">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = &amp;number_list[0];

    for number in &amp;number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!("–ù–∞–∏–±–æ–ª—å—à–µ–µ —á–∏—Å–ª–æ: {largest}");

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = &amp;number_list[0];

    for number in &amp;number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!("–ù–∞–∏–±–æ–ª—å—à–µ–µ —á–∏—Å–ª–æ: {largest}");
}</code></pre></pre>
</Listing>
<p>–ù–µ—Å–º–æ—Ç—Ä—è –Ω–∞ —Ç–æ, —á—Ç–æ –∫–æ–¥ –ø—Ä–æ–≥—Ä–∞–º–º—ã —Ä–∞–±–æ—Ç–∞–µ—Ç, –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–¥–∞ —É—Ç–æ–º–∏—Ç–µ–ª—å–Ω–æ –∏ –ø–æ–¥–≤–µ—Ä–∂–µ–Ω–æ –æ–ø–µ—á–∞—Ç–∫–∞–º. –ö—Ä–æ–º–µ —Ç–æ–≥–æ, –ø—Ä–∏ –≤–Ω–µ—Å–µ–Ω–∏–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–π –º—ã –¥–æ–ª–∂–Ω—ã –Ω–µ –∑–∞–±—ã—Ç—å –æ–±–Ω–æ–≤–∏—Ç—å –∫–∞–∂–¥–æ–µ –º–µ—Å—Ç–æ, –≥–¥–µ –∫–æ–¥ –¥—É–±–ª–∏—Ä—É–µ—Ç—Å—è.</p>
<p>–î–ª—è —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏—è –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è –º—ã –º–æ–∂–µ–º —Å–æ–∑–¥–∞—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—É—é –∞–±—Å—Ç—Ä–∞–∫—Ü–∏—é —Å –ø–æ–º–æ—â—å—é —Ñ—É–Ω–∫—Ü–∏–∏, –∫–æ—Ç–æ—Ä–∞—è —Å–º–æ–∂–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å —Å –ª—é–±—ã–º —Å–ø–∏—Å–∫–æ–º —Ü–µ–ª—ã—Ö —á–∏—Å–µ–ª, –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã–º –µ–π –≤ –∫–∞—á–µ—Å—Ç–≤–µ –≤—Ö–æ–¥–Ω–æ–≥–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞, –∏ –Ω–∞—Ö–æ–¥–∏—Ç—å –¥–ª—è —ç—Ç–æ–≥–æ —Å–ø–∏—Å–∫–∞ –Ω–∞–∏–±–æ–ª—å—à–µ–µ —á–∏—Å–ª–æ. –î–∞–Ω–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ –¥–µ–ª–∞–µ—Ç –∫–æ–¥ –±–æ–ª–µ–µ —è—Å–Ω—ã–º –∏ –ø–æ–∑–≤–æ–ª—è–µ—Ç –∞–±—Å—Ç—Ä–∞–∫—Ç–Ω—ã–º –æ–±—Ä–∞–∑–æ–º —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –∞–ª–≥–æ—Ä–∏—Ç–º –ø–æ–∏—Å–∫–∞ –Ω–∞–∏–±–æ–ª—å—à–µ–≥–æ —á–∏—Å–ª–∞ –≤ —Å–ø–∏—Å–∫–µ.</p>
<p>–í –õ–∏—Å—Ç–∏–Ω–≥–µ 10-3 –º—ã –∏–∑–≤–ª–µ–∫–∞–µ–º –∫–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –Ω–∞—Ö–æ–¥–∏—Ç –Ω–∞–∏–±–æ–ª—å—à–µ–µ —á–∏—Å–ª–æ, –≤ —Ñ—É–Ω–∫—Ü–∏—é <code>largest</code>. –ó–∞—Ç–µ–º –º—ã –≤—ã–∑—ã–≤–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é, —á—Ç–æ–±—ã –Ω–∞–π—Ç–∏ –Ω–∞–∏–±–æ–ª—å—à–µ–µ —á–∏—Å–ª–æ –≤ –¥–≤—É—Ö —Å–ø–∏—Å–∫–∞—Ö –∏–∑ –õ–∏—Å—Ç–∏–Ω–≥–∞ 10-2. –ú—ã —Ç–∞–∫–∂–µ –º–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç—Ç—É —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –ª—é–±–æ–≥–æ –¥—Ä—É–≥–æ–≥–æ —Å–ø–∏—Å–∫–∞ –∑–Ω–∞—á–µ–Ω–∏–π <code>i32</code>, –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–µ—Ç –≤—Å—Ç—Ä–µ—Ç–∏—Ç—å—Å—è –ø–æ–∑–∂–µ.</p>
<Listing number="10-3" file-name="src/main.rs" caption="Abstracted code to find the largest number in two lists">
<pre><pre class="playground"><code class="language-rust edition2021">fn largest(list: &amp;[i32]) -&gt; &amp;i32 {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!("–ù–∞–∏–±–æ–ª—å—à–µ–µ —á–∏—Å–ª–æ: {result}");
<span class="boring">    assert_eq!(*result, 100);
</span>
    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&amp;number_list);
    println!("–ù–∞–∏–±–æ–ª—å—à–µ–µ —á–∏—Å–ª–æ: {result}");
<span class="boring">    assert_eq!(*result, 6000);
</span>}</code></pre></pre>
</Listing>
<p>–§—É–Ω–∫—Ü–∏—è <code>largest</code> –∏–º–µ–µ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä —Å –∏–º–µ–Ω–µ–º <code>list</code>, –∫–æ—Ç–æ—Ä—ã–π –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç –ª—é–±–æ–π —Å—Ä–µ–∑ –∑–Ω–∞—á–µ–Ω–∏–π —Ç–∏–ø–∞ <code>i32</code>, –∫–æ—Ç–æ—Ä—ã–µ –º—ã –º–æ–∂–µ–º –ø–µ—Ä–µ–¥–∞—Ç—å –≤ –Ω–µ—ë. –í —Ä–µ–∑—É–ª—å—Ç–∞—Ç–µ –≤—ã–∑–æ–≤–∞ —Ñ—É–Ω–∫—Ü–∏–∏, –∫–æ–¥ –∏—Å–ø–æ–ª–Ω–∏—Ç—Å—è —Å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º–∏, –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã–º–∏ –≤ –Ω–µ—ë –∑–Ω–∞—á–µ–Ω–∏—è–º–∏.</p>
<p>–û–±–æ–±—â–∞—è, –≤–æ—Ç —à–∞–≥–∏, –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ –Ω–∞–º–∏ –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è –õ–∏—Å—Ç–∏–Ω–≥–∞ 10-2 –¥–æ –õ–∏—Å—Ç–∏–Ω–≥–∞ 10-3:</p>
<ol>
<li>–û–ø—Ä–µ–¥–µ–ª–∏—Ç—å –ø–æ–≤—Ç–æ—Ä—è—é—â–∏–π—Å—è –∫–æ–¥.</li>
<li>–ò–∑–≤–ª–µ—á—å –ø–æ–≤—Ç–æ—Ä—è—é—â–∏–π—Å—è –∫–æ–¥ –∏ –ø–æ–º–µ—Å—Ç–∏—Ç—å –µ–≥–æ –≤ —Ç–µ–ª–æ —Ñ—É–Ω–∫—Ü–∏–∏, –æ–ø—Ä–µ–¥–µ–ª–∏–≤ –≤—Ö–æ–¥–Ω—ã–µ –∏ –≤—ã—Ö–æ–¥–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è —ç—Ç–æ–≥–æ –∫–æ–¥–∞ –≤ —Å–∏–≥–Ω–∞—Ç—É—Ä–µ —Ñ—É–Ω–∫—Ü–∏–∏.</li>
<li>–ó–∞–º–µ–Ω–∏—Ç—å –¥–≤–∞ —É—á–∞—Å—Ç–∫–∞ –ø–æ–≤—Ç–æ—Ä—è—é—â–µ–≥–æ—Å—è –∫–æ–¥–∞ –≤—ã–∑–æ–≤–æ–º –æ–¥–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏.</li>
</ol>
<p>–î–∞–ª–µ–µ –º—ã –ø—Ä–∏–º–µ–Ω–∏–º —ç—Ç–∏ –∂–µ —à–∞–≥–∏, —á—Ç–æ–±—ã –∏–∑–±–∞–≤–ª—è—Ç—å—Å—è –æ—Ç –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è –∫–æ–¥–∞ —Å –ø–æ–º–æ—â—å—é –æ–±–æ–±—â–µ–Ω–∏–π. –û–±–æ–±—â–µ–Ω–∏—è –ø–æ–∑–≤–æ–ª—è—é—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –Ω–∞–¥ –∞–±—Å—Ç—Ä–∞–∫—Ç–Ω—ã–º–∏ —Ç–∏–ø–∞–º–∏ —Ç–∞–∫–∏–º –∂–µ –æ–±—Ä–∞–∑–æ–º, –∫–∞–∫–∏–º —Ç–µ–ª–æ —Ñ—É–Ω–∫—Ü–∏–∏ –ø–æ–∑–≤–æ–ª—è–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –Ω–∞–¥ –∞–±—Å—Ç—Ä–∞–∫—Ç–Ω—ã–º —Å–ø–∏—Å–∫–æ–º <code>list</code> –≤–º–µ—Å—Ç–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π.</p>
<p>–ù–∞–ø—Ä–∏–º–µ—Ä, —É –Ω–∞—Å –µ—Å—Ç—å –¥–≤–µ —Ñ—É–Ω–∫—Ü–∏–∏: –æ–¥–Ω–∞ –∏—â–µ—Ç –Ω–∞–∏–±–æ–ª—å—à–∏–π —ç–ª–µ–º–µ–Ω—Ç –≤–Ω—É—Ç—Ä–∏ —Å—Ä–µ–∑–∞ –∑–Ω–∞—á–µ–Ω–∏–π —Ç–∏–ø–∞ <code>i32</code>, –∞ –¥—Ä—É–≥–∞—è ‚Äî –≤–Ω—É—Ç—Ä–∏ —Å—Ä–µ–∑–∞ –∑–Ω–∞—á–µ–Ω–∏–π —Ç–∏–ø–∞ <code>char</code>. –ö–∞–∫ –∏–∑–±–∞–≤–∏—Ç—å—Å—è –æ—Ç —Ç–∞–∫–æ–≥–æ –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è? –î–∞–≤–∞–π—Ç–µ –≤—ã—è—Å–Ω—è—Ç—å!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–û–±–æ–±—â—ë–Ω–Ω—ã–µ-—Ç–∏–ø—ã-–¥–∞–Ω–Ω—ã—Ö"><a class="header" href="#–û–±–æ–±—â—ë–Ω–Ω—ã–µ-—Ç–∏–ø—ã-–¥–∞–Ω–Ω—ã—Ö">–û–±–æ–±—â—ë–Ω–Ω—ã–µ —Ç–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö</a></h2>
<p>–ú—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ–±–æ–±—â–µ–Ω–∏—è –≤, –Ω–∞–ø—Ä–∏–º–µ—Ä, —Å–∏–≥–Ω–∞—Ç—É—Ä–∞—Ö —Ñ—É–Ω–∫—Ü–∏–π –∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞—Ö, –∫–æ—Ç–æ—Ä—ã–µ –∑–∞—Ç–µ–º –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å —Ä–∞–∑–ª–∏—á–Ω—ã–º–∏ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º–∏ —Ç–∏–ø–∞–º–∏ –¥–∞–Ω–Ω—ã—Ö. –°–Ω–∞—á–∞–ª–∞ –º—ã –ø–æ—Å–º–æ—Ç—Ä–∏–º, –∫–∞–∫ –æ–±—ä—è–≤–ª—è—Ç—å —Ñ—É–Ω–∫—Ü–∏–∏, —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –∏ –º–µ—Ç–æ–¥—ã, –∏—Å–ø–æ–ª—å–∑—É—è –æ–±–æ–±—â–µ–Ω–∏—è. –ó–∞—Ç–µ–º –º—ã –æ–±—Å—É–¥–∏–º, –∫–∞–∫ –æ–±–æ–±—â–µ–Ω–∏—è –≤–ª–∏—è—é—Ç –Ω–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∫–æ–¥–∞.</p>
<h3 id="–í-–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è—Ö-—Ñ—É–Ω–∫—Ü–∏–π"><a class="header" href="#–í-–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è—Ö-—Ñ—É–Ω–∫—Ü–∏–π">–í –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è—Ö —Ñ—É–Ω–∫—Ü–∏–π</a></h3>
<p>–ö–æ–≥–¥–∞ –º—ã –æ–±—ä—è–≤–ª—è–µ–º —Ñ—É–Ω–∫—Ü–∏—é —Å –æ–±–æ–±—â—ë–Ω–Ω—ã–º–∏ —Ç–∏–ø–∞–º–∏, –º—ã —Ä–∞–∑–º–µ—â–∞–µ–º –æ–±–æ–±—â—ë–Ω–Ω—ã–µ —Ç–∏–ø—ã –≤ —Å–∏–≥–Ω–∞—Ç—É—Ä–µ —Ñ—É–Ω–∫—Ü–∏–∏ —Ç–∞–º, –≥–¥–µ –º—ã –æ–±—ã—á–Ω–æ —É–∫–∞–∑—ã–≤–∞–µ–º —Ç–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è. –ò—Å–ø–æ–ª—å–∑—É—è –æ–±–æ–±—â—ë–Ω–Ω—ã–µ —Ç–∏–ø—ã, –º—ã –¥–µ–ª–∞–µ–º –∫–æ–¥ –±–æ–ª–µ–µ –≥–∏–±–∫–∏–º –∏ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ–º –±–æ–ª—å—à—É—é —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å –ø—Ä–∏ –≤—ã–∑–æ–≤–µ –Ω–∞—à–µ–π —Ñ—É–Ω–∫—Ü–∏–∏, –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞—è –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–¥–∞.</p>
<p>–†–∞—Å—Å–º–æ—Ç—Ä–∏–º –ø—Ä–∏–º–µ—Ä —Å –Ω–∞—à–µ–π —Ñ—É–Ω–∫—Ü–∏–µ–π <code>largest</code>. –õ–∏—Å—Ç–∏–Ω–≥ 10-4 –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –¥–≤–µ —Ñ—É–Ω–∫—Ü–∏–∏, –∫–∞–∂–¥–∞—è –∏–∑ –∫–æ—Ç–æ—Ä—ã—Ö –Ω–∞—Ö–æ–¥–∏—Ç —Å–∞–º–æ–µ –±–æ–ª—å—à–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –≤ —Å—Ä–µ–∑–µ —Å–≤–æ–µ–≥–æ —Ç–∏–ø–∞. –ü–æ–∑–∂–µ –º—ã –æ–±—ä–µ–¥–∏–Ω–∏–º –∏—Ö –≤ –æ–¥–Ω—É —Ñ—É–Ω–∫—Ü–∏—é, –∏—Å–ø–æ–ª—å–∑—É—é—â—É—é –æ–±–æ–±—â—ë–Ω–Ω—ã–µ —Ç–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö.</p>
<Listing number="10-4" file-name="src/main.rs" caption="Two functions that differ only in their names and in the types in their signatures">
<pre><pre class="playground"><code class="language-rust edition2021">fn largest_i32(list: &amp;[i32]) -&gt; &amp;i32 {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &amp;[char]) -&gt; &amp;char {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&amp;number_list);
    println!("–ù–∞–∏–±–æ–ª—å—à–µ–µ —á–∏—Å–ª–æ: {result}");
<span class="boring">    assert_eq!(*result, 100);
</span>
    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&amp;char_list);
    println!("–ù–∞–∏–±–æ–ª—å—à–∏–π —Å–∏–º–≤–æ–ª: {result}");
<span class="boring">    assert_eq!(*result, 'y');
</span>}</code></pre></pre>
</Listing>
<p>–§—É–Ω–∫—Ü–∏—è <code>largest_i32</code> —É–∂–µ –≤—Å—Ç—Ä–µ—á–∞–ª–∞—Å—å –Ω–∞–º: –º—ã –∏–∑–≤–ª–µ–∫–ª–∏ –µ—ë –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 10-3, –∫–æ–≥–¥–∞ –±–æ—Ä–æ–ª–∏—Å—å —Å –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ–º –∫–æ–¥–∞; –æ–Ω–∞ –Ω–∞—Ö–æ–¥–∏—Ç –Ω–∞–∏–±–æ–ª—å—à–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Ç–∏–ø–∞ <code>i32</code> –≤ —Å—Ä–µ–∑–µ. –§—É–Ω–∫—Ü–∏—è <code>largest_char</code> –Ω–∞—Ö–æ–¥–∏—Ç —Å–∞–º–æ–µ –±–æ–ª—å—à–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Ç–∏–ø–∞ <code>char</code> –≤ —Å—Ä–µ–∑–µ. –¢–µ–ª–æ —É —ç—Ç–∏—Ö —Ñ—É–Ω–∫—Ü–∏–π –æ–¥–∏–Ω–∞–∫–æ–≤–æ–µ, –ø–æ—ç—Ç–æ–º—É –¥–∞–≤–∞–π—Ç–µ –∏–∑–±–∞–≤–∏–º—Å—è –æ—Ç –¥—É–±–ª–∏—Ä—É–µ–º–æ–≥–æ –∫–æ–¥–∞, –∏—Å–ø–æ–ª—å–∑—É—è –ø–∞—Ä–∞–º–µ—Ç—Ä –æ–±–æ–±—â—ë–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞ –≤ –æ–¥–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏.</p>
<p>–î–ª—è –ø–∞—Ä–∞–º–µ—Ç—Ä–∏–∑–∞—Ü–∏–∏ —Ç–∏–ø–æ–≤ –¥–∞–Ω–Ω—ã—Ö –≤ –Ω–æ–≤–æ–π –æ–±—ä—è–≤–ª—è–µ–º–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –Ω–∞–º –Ω—É–∂–Ω–æ –¥–∞—Ç—å –∏–º—è –æ–±–æ–±—â—ë–Ω–Ω–æ–º—É —Ç–∏–ø—É ‚Äî —Ç–∞–∫ –∂–µ, –∫–∞–∫ –º—ã —ç—Ç–æ –¥–µ–ª–∞–µ–º –¥–ª—è –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ —Ñ—É–Ω–∫—Ü–∏–π. –ú–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ª—é–±–æ–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –¥–ª—è –∏–º–µ–Ω–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ —Ç–∏–ø–∞, –Ω–æ –º—ã –±—É–¥–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å <code>T</code>, –ø–æ—Ç–æ–º—É —á—Ç–æ –ø–æ —Å–æ–≥–ª–∞—à–µ–Ω–∏—é –∏–º–µ–Ω–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ —Ç–∏–ø–æ–≤ –≤ Rust –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –∫–æ—Ä–æ—Ç–∫–∏–º–∏ (–æ–±—ã—á–Ω–æ –¥–ª–∏–Ω–æ–π –≤ –æ–¥–∏–Ω —Å–∏–º–≤–æ–ª), –∞ –∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ —Ç–∏–ø–æ–≤ –≤ Rust –¥–µ–ª–∞–µ—Ç—Å—è –≤ –Ω–æ—Ç–∞—Ü–∏–∏ <code>UpperCamelCase</code>. –°–æ–∫—Ä–∞—â–µ–Ω–∏–µ —Å–ª–æ–≤–∞ <em>type</em> –¥–æ –æ–¥–Ω–æ–π –±—É–∫–≤—ã <code>T</code> —è–≤–ª—è–µ—Ç—Å—è —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–º –≤—ã–±–æ—Ä–æ–º –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç–æ–≤.</p>
<p>–ö–æ–≥–¥–∞ –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä –≤ —Ç–µ–ª–µ —Ñ—É–Ω–∫—Ü–∏–∏, –º—ã –¥–æ–ª–∂–Ω—ã –æ–±—ä—è–≤–∏—Ç—å –∏–º—è –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –≤ —Å–∏–≥–Ω–∞—Ç—É—Ä–µ, —á—Ç–æ–±—ã –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –∑–Ω–∞–ª, —á—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç —ç—Ç–æ –∏–º—è. –ê–Ω–∞–ª–æ–≥–∏—á–Ω–æ, –∫–æ–≥–¥–∞ –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º –∏–º—è —Ç–∏–ø–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –≤ —Å–∏–≥–Ω–∞—Ç—É—Ä–µ —Ñ—É–Ω–∫—Ü–∏–∏, –º—ã –¥–æ–ª–∂–Ω—ã –æ–±—ä—è–≤–∏—Ç—å —ç—Ç–æ –∏–º—è —Ä–∞–Ω—å—à–µ, —á–µ–º –º—ã –µ–≥–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º. –ß—Ç–æ–±—ã –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –æ–±–æ–±—â—ë–Ω–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é <code>largest</code>, –ø–æ–º–µ—Å—Ç–∏–º –æ–±—ä—è–≤–ª–µ–Ω–∏–µ –∏–º—ë–Ω –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –≤ —É–≥–ª–æ–≤—ã–µ —Å–∫–æ–±–∫–∏ <code>&lt;&gt;</code> –º–µ–∂–¥—É –∏–º–µ–Ω–µ–º —Ñ—É–Ω–∫—Ü–∏–∏ –∏ —Å–ø–∏—Å–∫–æ–º –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤, –∫–∞–∫ –∑–¥–µ—Å—å:</p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {</code></pre>
<p>–û–±—ä—è–≤–ª–µ–Ω–∏–µ —á–∏—Ç–∞–µ—Ç—Å—è —Ç–∞–∫: —Ñ—É–Ω–∫—Ü–∏—è <code>largest</code> —è–≤–ª—è–µ—Ç—Å—è –æ–±–æ–±—â—ë–Ω–Ω–æ–π –ø–æ —Ç–∏–ø—É <code>T</code>. –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –∏–º–µ–µ—Ç –æ–¥–∏–Ω –ø–∞—Ä–∞–º–µ—Ç—Ä —Å –∏–º–µ–Ω–µ–º <code>list</code>, –∫–æ—Ç–æ—Ä—ã–π —è–≤–ª—è–µ—Ç—Å—è —Å—Ä–µ–∑–æ–º –∑–Ω–∞—á–µ–Ω–∏–π —Ç–∏–ø–∞ <code>T</code>. –§—É–Ω–∫—Ü–∏—è <code>largest</code> –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Å—ã–ª–∫—É –Ω–∞ –∑–Ω–∞—á–µ–Ω–∏–µ —ç—Ç–æ–≥–æ –∂–µ —Ç–∏–ø–∞ <code>T</code>.</p>
<p>–õ–∏—Å—Ç–∏–Ω–≥ 10-5 –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ <code>largest</code> —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –æ–±–æ–±—â—ë–Ω–Ω—ã—Ö —Ç–∏–ø–æ–≤ –¥–∞–Ω–Ω—ã—Ö –≤ –µ—ë —Å–∏–≥–Ω–∞—Ç—É—Ä–µ. –õ–∏—Å—Ç–∏–Ω–≥ —Ç–∞–∫–∂–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç, –∫–∞–∫ –º—ã –º–æ–∂–µ–º –≤—ã–∑–≤–∞—Ç—å —Ñ—É–Ω–∫—Ü–∏—é —Å–æ —Å—Ä–µ–∑–æ–º –¥–∞–Ω–Ω—ã—Ö —Ç–∏–ø–∞ <code>i32</code> –∏–ª–∏ <code>char</code>. –î–∞–Ω–Ω—ã–π –∫–æ–¥ –ø–æ–∫–∞ –Ω–µ –±—É–¥–µ—Ç –∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞—Ç—å—Å—è, –Ω–æ –º—ã –∏—Å–ø—Ä–∞–≤–∏–º —ç—Ç–æ –∫ –∫–æ–Ω—Ü—É —Ä–∞–∑–¥–µ–ª–∞.</p>
<Listing number="10-5" file-name="src/main.rs" caption="The `largest` function using generic type parameters; this doesn‚Äôt compile yet">
<pre><code class="language-rust ignore does_not_compile">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!("–ù–∞–∏–±–æ–ª—å—à–µ–µ —á–∏—Å–ª–æ: {result}");

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!("–ù–∞–∏–±–æ–ª—å—à–∏–π —Å–∏–º–≤–æ–ª: {result}");
}</code></pre>
</Listing>
<p>–ï—Å–ª–∏ –º—ã —Å–∫–æ–º–ø–∏–ª–∏—Ä—É–µ–º –ø—Ä–æ–≥—Ä–∞–º–º—É –≤ –µ—ë —Ç–µ–∫—É—â–µ–º –≤–∏–¥–µ, –º—ã –ø–æ–ª—É—á–∏–º —Å–ª–µ–¥—É—é—â—É—é –æ—à–∏–±–∫—É:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `&amp;T`
 --&gt; src/main.rs:5:17
  |
5 |         if item &gt; largest {
  |            ---- ^ ------- &amp;T
  |            |
  |            &amp;T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; &amp;T {
  |             ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>–í –ø–æ–¥—Å–∫–∞–∑–∫–µ —É–ø–æ–º–∏–Ω–∞–µ—Ç—Å—è <em>—Ç—Ä–µ–π—Ç</em> <code>std::cmp::PartialOrd</code>. –ú—ã –ø–æ–≥–æ–≤–æ—Ä–∏–º –ø—Ä–æ —Ç—Ä–µ–π—Ç—ã –≤ —Å–ª–µ–¥—É—é—â–µ–º —Ä–∞–∑–¥–µ–ª–µ. –°–µ–π—á–∞—Å –æ—à–∏–±–∫–∞ –≤ —Ñ—É–Ω–∫—Ü–∏–∏ <code>largest</code> —É–∫–∞–∑—ã–≤–∞–µ—Ç, —á—Ç–æ —Ñ—É–Ω–∫—Ü–∏—è –Ω–µ –º–æ–∂–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –¥–ª—è –≤—Å–µ—Ö –≤–æ–∑–º–æ–∂–Ω—ã—Ö —Ç–∏–ø–æ–≤ <code>T</code>. –¢–∞–∫ –∫–∞–∫ –º—ã —Ö–æ—Ç–∏–º —Å—Ä–∞–≤–Ω–∏–≤–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è —Ç–∏–ø–∞ <code>T</code> –≤ —Ç–µ–ª–µ —Ñ—É–Ω–∫—Ü–∏–∏, –º—ã –º–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ —Ç–µ —Ç–∏–ø—ã, –¥–∞–Ω–Ω—ã–µ –∫–æ—Ç–æ—Ä—ã—Ö –º–æ–∂–Ω–æ —É–ø–æ—Ä—è–¥–æ—á–∏—Ç—å. –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è —Ä–µ–∞–ª–∏–∑—É–µ—Ç—Å—è —Ç—Ä–µ–π—Ç–æ–º <code>std::cmp::PartialOrd</code> —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏, –∫–æ—Ç–æ—Ä—ã–π –≤—ã –º–æ–∂–µ—Ç–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –¥–ª—è —Ç–∏–ø–æ–≤ (–±–æ–ª—å—à–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± —ç—Ç–æ–º —Ç—Ä–µ–π—Ç–µ –º–æ–∂–Ω–æ —É–∑–Ω–∞—Ç—å –≤ –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ C). –°–ª–µ–¥—É—è —Å–æ–≤–µ—Ç—É –≤ —Å–æ–æ–±—â–µ–Ω–∏–∏ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞, –æ–≥—Ä–∞–Ω–∏—á–∏–º —Ç–∏–ø <code>T</code> —Ç–µ–º–∏ –≤–∞—Ä–∏–∞–Ω—Ç–∞–º–∏, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç —Ç—Ä–µ–π—Ç <code>PartialOrd</code>, –∏ —Ç–µ–ø–µ—Ä—å –ø—Ä–∏–º–µ—Ä —É—Å–ø–µ—à–Ω–æ —Å–∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è, —Ç–∞–∫ –∫–∞–∫ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ —Ä–µ–∞–ª–∏–∑—É–µ—Ç <code>PartialOrd</code> –∫–∞–∫ –¥–ª—è <code>i32</code>, —Ç–∞–∫ –∏ –¥–ª—è <code>char</code>.</p>
<h3 id="–í-–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è—Ö-—Å—Ç—Ä—É–∫—Ç—É—Ä"><a class="header" href="#–í-–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è—Ö-—Å—Ç—Ä—É–∫—Ç—É—Ä">–í –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä</a></h3>
<p>–ú—ã —Ç–∞–∫–∂–µ –º–æ–∂–µ–º –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, –∏—Å–ø–æ–ª—å–∑—É—é—â–∏–µ –æ–±–æ–±—â—ë–Ω–Ω—ã–µ —Ç–∏–ø—ã –≤ –æ–¥–Ω–æ–º –∏–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Å–≤–æ–∏—Ö –ø–æ–ª—è—Ö, —Å –ø–æ–º–æ—â—å—é —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞ <code>&lt;&gt;</code>. –õ–∏—Å—Ç–∏–Ω–≥ 10-6 –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç, –∫–∞–∫ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É <code>Point&lt;T&gt;</code>, —á—Ç–æ–±—ã —Ö—Ä–∞–Ω–∏—Ç—å –ø–æ–ª—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç <code>x</code> –∏ <code>y</code> –ª—é–±–æ–≥–æ —Ç–∏–ø–∞ –¥–∞–Ω–Ω—ã—Ö.</p>
<Listing number="10-6" file-name="src/main.rs" caption="A `Point<T>` struct that holds `x` and `y` values of type `T`">
<pre><pre class="playground"><code class="language-rust edition2021">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}</code></pre></pre>
</Listing>
<p>–°–∏–Ω—Ç–∞–∫—Å–∏—Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –æ–±–æ–±—â—ë–Ω–Ω—ã—Ö —Ç–∏–ø–æ–≤ –≤ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –æ—á–µ–Ω—å –ø–æ—Ö–æ–∂ –Ω–∞ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –≤ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–∏ —Ñ—É–Ω–∫—Ü–∏–∏. –°–Ω–∞—á–∞–ª–∞ –º—ã –æ–±—ä—è–≤–ª—è–µ–º –∏–º–µ–Ω–∞ —Ç–∏–ø–æ–≤ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –≤–Ω—É—Ç—Ä–∏ —É–≥–ª–æ–≤—ã—Ö —Å–∫–æ–±–æ–∫ —Å—Ä–∞–∑—É –ø–æ—Å–ª–µ –Ω–∞–∑–≤–∞–Ω–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, –∞ –∑–∞—Ç–µ–º –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ–±–æ–±—â—ë–Ω–Ω—ã–µ —Ç–∏–ø—ã –≤ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –≤ —Ç–µ—Ö –º–µ—Å—Ç–∞—Ö, –≥–¥–µ —Ä–∞–Ω–µ–µ –º—ã —É–∫–∞–∑—ã–≤–∞–ª–∏ –±—ã –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ —Ç–∏–ø—ã.</p>
<p>–¢–∞–∫ –∫–∞–∫ –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω –æ–±–æ–±—â—ë–Ω–Ω—ã–π —Ç–∏–ø –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã <code>Point&lt;T&gt;</code>, —ç—Ç–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ <code>Point&lt;T&gt;</code> —è–≤–ª—è–µ—Ç—Å—è –æ–±–æ–±—â—ë–Ω–Ω–æ–π –ø–æ —Ç–∏–ø—É <code>T</code>, –∏ –æ–±–∞ –ø–æ–ª—è <code>x</code> –∏ <code>y</code> –∏–º–µ—é—Ç <em>–æ–¥–∏–Ω–∞–∫–æ–≤—ã–π</em> —Ç–∏–ø, –∫–∞–∫–∏–º –±—ã –æ–Ω –Ω–∏ —è–≤–ª—è–ª—Å—è. –ï—Å–ª–∏ –º—ã —Å–æ–∑–¥–∞–¥–∏–º —ç–∫–∑–µ–º–ø–ª—è—Ä —Å—Ç—Ä—É–∫—Ç—É—Ä—ã <code>Point&lt;T&gt;</code> —Å–æ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏ —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤, –∫–∞–∫ –ø–æ–∫–∞–∑–∞–Ω–æ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 10-7, –Ω–∞—à –∫–æ–¥ –Ω–µ —Å–∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è.</p>
<Listing number="10-7" file-name="src/main.rs" caption="The fields `x` and `y` must be the same type because both have the same generic data type `T`.">
<pre><code class="language-rust ignore does_not_compile">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}</code></pre>
</Listing>
<p>–í —ç—Ç–æ–º –ø—Ä–∏–º–µ—Ä–µ, –∫–æ–≥–¥–∞ –º—ã –ø—Ä–∏—Å–≤–∞–∏–≤–∞–µ–º —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ <code>5</code> –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π <code>x</code>, –º—ã —Å–æ–æ–±—â–∞–µ–º –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä—É, —á—Ç–æ –æ–±–æ–±—â—ë–Ω–Ω—ã–π —Ç–∏–ø <code>T</code> –±—É–¥–µ—Ç —Ü–µ–ª—ã–º —á–∏—Å–ª–æ–º –¥–ª—è —ç—Ç–æ–≥–æ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ <code>Point&lt;T&gt;</code>. –ó–∞—Ç–µ–º, –∫–æ–≥–¥–∞ –º—ã —É–∫–∞–∑—ã–≤–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ <code>4.0</code> –¥–ª—è <code>y</code>, –∫–æ—Ç–æ—Ä—ã–π –ø–æ –Ω–∞—à–µ–º—É –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—é –¥–æ–ª–∂–µ–Ω –∏–º–µ—Ç—å —Ç–æ—Ç –∂–µ —Ç–∏–ø, —á—Ç–æ –∏ <code>x</code>, –º—ã –ø–æ–ª—É—á–∞–µ–º –æ—à–∏–±–∫—É –Ω–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è —Ç–∏–ø–æ–≤:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-point number

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>–ß—Ç–æ–±—ã –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É <code>Point</code>, –≥–¥–µ –æ–±–∞ –∑–Ω–∞—á–µ–Ω–∏—è <code>x</code> –∏ <code>y</code> —è–≤–ª—è—é—Ç—Å—è –æ–±–æ–±—â—ë–Ω–Ω—ã–º–∏, –Ω–æ —Ä–∞–∑–ª–∏—á–Ω—ã–º–∏ —Ç–∏–ø–∞–º–∏, –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –æ–±–æ–±—â—ë–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞. –ù–∞–ø—Ä–∏–º–µ—Ä, –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 10-8 –º—ã –∏–∑–º–µ–Ω–∏–ª–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ <code>Point</code> —Ç–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, —á—Ç–æ–±—ã –æ–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–æ –æ–±–æ–±—â—ë–Ω–Ω—ã–µ —Ç–∏–ø—ã <code>T</code> –∏ <code>U</code>, –≥–¥–µ <code>x</code> –∏–º–µ–µ—Ç —Ç–∏–ø <code>T</code>, –∞ <code>y</code> ‚Äî —Ç–∏–ø <code>U</code>.</p>
<Listing number="10-8" file-name="src/main.rs" caption="A `Point<T, U>` generic over two types so that `x` and `y` can be values of different types">
<pre><pre class="playground"><code class="language-rust edition2021">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}</code></pre></pre>
</Listing>
<p>–¢–µ–ø–µ—Ä—å —Ä–∞–∑—Ä–µ—à–µ–Ω—ã –≤—Å–µ –ø–æ–∫–∞–∑–∞–Ω–Ω—ã–µ —ç–∫–∑–µ–º–ø–ª—è—Ä—ã —Ç–∏–ø–∞ <code>Point</code>! –í –æ–±—ä—è–≤–ª–µ–Ω–∏–∏ –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å–∫–æ–ª—å —É–≥–æ–¥–Ω–æ –º–Ω–æ–≥–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –æ–±–æ–±—â—ë–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞, –Ω–æ –µ—Å–ª–∏ –¥–µ–ª–∞—Ç—å —ç—Ç–æ –≤ –±–æ–ª—å—à–æ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–µ, –∫–æ–¥ –±—É–¥–µ—Ç —Ç—è–∂–µ–ª–æ —á–∏—Ç–∞—Ç—å. –ï—Å–ª–∏ –≤ –≤–∞—à–µ–º –∫–æ–¥–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è –º–Ω–æ–≥–æ –æ–±–æ–±—â—ë–Ω–Ω—ã—Ö —Ç–∏–ø–æ–≤, –≤–æ–∑–º–æ–∂–Ω–æ, —Å—Ç–æ–∏—Ç —Ä–∞–∑–±–∏—Ç—å –µ–≥–æ –Ω–∞ –±–æ–ª–µ–µ –º–µ–ª–∫–∏–µ —á–∞—Å—Ç–∏.</p>
<h3 id="–í-–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è—Ö-–ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π"><a class="header" href="#–í-–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è—Ö-–ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π">–í –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è—Ö –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π</a></h3>
<p>–ö–∞–∫ –∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è —Ç–∞–∫–∂–µ –º–æ–≥—É—Ç —Ö—Ä–∞–Ω–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –æ–±–æ–±—â—ë–Ω–Ω—ã—Ö —Ç–∏–ø–æ–≤ –≤ —Å–≤–æ–∏—Ö –≤–∞—Ä–∏–∞–Ω—Ç–∞—Ö. –î–∞–≤–∞–π—Ç–µ –µ—â—ë —Ä–∞–∑ –ø–æ—Å–º–æ—Ç—Ä–∏–º –Ω–∞ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ <code>Option&lt;T&gt;</code>, –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–æ–π, –∫–æ—Ç–æ—Ä–æ–µ –º—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ –≤ –ì–ª–∞–≤–µ 6:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}</span></code></pre></pre>
<p>–°–µ–π—á–∞—Å —ç—Ç–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –≤–∞–º —è—Å–Ω—ã–º. –ö–∞–∫ –≤–∏–¥–∏—Ç–µ, –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ <code>Option&lt;T&gt;</code> –æ–±–æ–±—â–µ–Ω–æ –ø–æ —Ç–∏–ø—É <code>T</code> –∏ –∏–º–µ–µ—Ç –¥–≤–∞ –≤–∞—Ä–∏–∞–Ω—Ç–∞: –≤–∞—Ä–∏–∞–Ω—Ç <code>Some</code>, –∫–æ—Ç–æ—Ä—ã–π —Å–æ–¥–µ—Ä–∂–∏—Ç –æ–¥–Ω–æ –∑–Ω–∞—á–µ–Ω–∏–µ —Ç–∏–ø–∞ <code>T</code>, –∏ –≤–∞—Ä–∏–∞–Ω—Ç <code>None</code>, –∫–æ—Ç–æ—Ä—ã–π –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –Ω–∏–∫–∞–∫–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è. –ò—Å–ø–æ–ª—å–∑—É—è –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ <code>Option&lt;T&gt;</code>, –º–æ–∂–Ω–æ –≤—ã—Ä–∞–∑–∏—Ç—å –∞–±—Å—Ç—Ä–∞–∫—Ç–Ω—É—é –∫–æ–Ω—Ü–µ–ø—Ü–∏—é –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è ‚Äî –∏ —Ç–∞–∫ –∫–∞–∫ <code>Option&lt;T&gt;</code> —è–≤–ª—è–µ—Ç—Å—è –æ–±–æ–±—â—ë–Ω–Ω—ã–º, –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç—Ç—É –∞–±—Å—Ç—Ä–∞–∫—Ü–∏—é –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –æ—Ç —Ç–æ–≥–æ, –∫–∞–∫–∏–º –±—É–¥–µ—Ç —Ç–∏–ø –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è.</p>
<p>–ü–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è —Ç–æ–∂–µ –º–æ–≥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –æ–±–æ–±—â—ë–Ω–Ω—ã—Ö —Ç–∏–ø–æ–≤. –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ–ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è <code>Result</code>, –∫–æ—Ç–æ—Ä–æ–µ –º—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ –≤ –ì–ª–∞–≤–µ 9 ‚Äî —Ö–æ—Ä–æ—à–∏–π –ø—Ä–∏–º–µ—Ä:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p>–ü–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ <code>Result</code> –æ–±–æ–±—â–µ–Ω–æ –ø–æ –¥–≤—É–º —Ç–∏–ø–∞–º ‚Äî <code>T</code> –∏ <code>E</code> ‚Äî –∏ –∏–º–µ–µ—Ç –¥–≤–∞ –≤–∞—Ä–∏–∞–Ω—Ç–∞: <code>Ok</code>, –∫–æ—Ç–æ—Ä—ã–π —Å–æ–¥–µ—Ä–∂–∏—Ç –∑–Ω–∞—á–µ–Ω–∏–µ —Ç–∏–ø–∞ <code>T</code>, –∏ <code>Err</code>, —Å–æ–¥–µ—Ä–∂–∞—â–∏–π –∑–Ω–∞—á–µ–Ω–∏–µ —Ç–∏–ø–∞ <code>E</code>. –° —Ç–∞–∫–∏–º –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ–º —É–¥–æ–±–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ <code>Result</code> –≤–µ–∑–¥–µ, –≥–¥–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –º–æ–≥—É—Ç –±—ã—Ç—å –≤—ã–ø–æ–ª–Ω–µ–Ω—ã —É—Å–ø–µ—à–Ω–æ (–≤–æ–∑–≤—Ä–∞—â–∞—è –∑–Ω–∞—á–µ–Ω–∏–µ —Ç–∏–ø–∞ <code>T</code>) –∏–ª–∏ –Ω–µ—É—Å–ø–µ—à–Ω–æ (–≤–æ–∑–≤—Ä–∞—â–∞—è –æ—à–∏–±–∫—É —Ç–∏–ø–∞ <code>E</code>). –≠—Ç–æ —Ç–æ, —á—Ç–æ –º—ã –¥–µ–ª–∞–ª–∏ –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏ —Ñ–∞–π–ª–∞ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 9-3, –≥–¥–µ <code>T</code> –∑–∞–º–µ–Ω—è–ª–æ—Å—å —Ç–∏–ø–æ–º <code>std::fs::File</code>, –µ—Å–ª–∏ —Ñ–∞–π–ª –±—ã–ª –æ—Ç–∫—Ä—ã—Ç —É—Å–ø–µ—à–Ω–æ, –∏ <code>E</code> –∑–∞–º–µ–Ω—è–ª–æ—Å—å —Ç–∏–ø–æ–º <code>std::io::Error</code>, –µ—Å–ª–∏ –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏ —Ñ–∞–π–ª–∞ –≤–æ–∑–Ω–∏–∫–∞–ª–∏ –∫–∞–∫–∏–µ-–ª–∏–±–æ –ø—Ä–æ–±–ª–µ–º—ã.</p>
<p>–ï—Å–ª–∏ –≤—ã –≤—Å—Ç—Ä–µ—á–∞–µ—Ç–µ –≤ –∫–æ–¥–µ —Å–∏—Ç—É–∞—Ü–∏–∏, –∫–æ–≥–¥–∞ –Ω–µ—Å–∫–æ–ª—å–∫–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–π —Å—Ç—Ä—É–∫—Ç—É—Ä –∏–ª–∏ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π –æ—Ç–ª–∏—á–∞—é—Ç—Å—è —Ç–æ–ª—å–∫–æ —Ç–∏–ø–∞–º–∏ —Å–æ–¥–µ—Ä–∂–∞—â–∏—Ö—Å—è –≤ –Ω–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π, –≤—ã –º–æ–∂–µ—Ç–µ —É—Å—Ç—Ä–∞–Ω–∏—Ç—å –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ, –∏—Å–ø–æ–ª—å–∑—É—è –æ–±–æ–±—â—ë–Ω–Ω—ã–µ —Ç–∏–ø—ã.</p>
<h3 id="–í-–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–∏-–º–µ—Ç–æ–¥–æ–≤"><a class="header" href="#–í-–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–∏-–º–µ—Ç–æ–¥–æ–≤">–í –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–∏ –º–µ—Ç–æ–¥–æ–≤</a></h3>
<p>–ú—ã –º–æ–∂–µ–º —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –º–µ—Ç–æ–¥—ã –¥–ª—è —Å—Ç—Ä—É–∫—Ç—É—Ä –∏ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π (–∫–∞–∫ –º—ã —Å–¥–µ–ª–∞–ª–∏ –≤ –ì–ª–∞–≤–µ 5) –∏ –≤ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è—Ö —ç—Ç–∏—Ö –º–µ—Ç–æ–¥–æ–≤ —Ç–æ–∂–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –æ–±–æ–±—â—ë–Ω–Ω—ã–µ —Ç–∏–ø—ã. –í –õ–∏—Å—Ç–∏–Ω–≥–µ 10-9 –ø–æ–∫–∞–∑–∞–Ω–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ <code>Point&lt;T&gt;</code>, –∫–æ—Ç–æ—Ä—É—é –º—ã –æ–ø—Ä–µ–¥–µ–ª–∏–ª–∏ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 10-6, —Å —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–º –¥–ª—è –Ω–µ—ë –º–µ—Ç–æ–¥–æ–º <code>x</code>.</p>
<Listing number="10-9" file-name="src/main.rs" caption="Implementing a method named `x` on the `Point<T>` struct that will return a reference to the `x` field of type `T`">
<pre><pre class="playground"><code class="language-rust edition2021">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}</code></pre></pre>
</Listing>
<p>–ó–¥–µ—Å—å –º—ã –æ–ø—Ä–µ–¥–µ–ª–∏–ª–∏ –º–µ—Ç–æ–¥ <code>x</code> –Ω–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–µ <code>Point&lt;T&gt;</code>, –∫–æ—Ç–æ—Ä—ã–π –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Å—ã–ª–∫—É –Ω–∞ –¥–∞–Ω–Ω—ã–µ –≤ –ø–æ–ª–µ <code>x</code>.</p>
<p>–û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ –º—ã –¥–æ–ª–∂–Ω—ã –æ–±—ä—è–≤–∏—Ç—å <code>T</code> —Å—Ä–∞–∑—É –ø–æ—Å–ª–µ <code>impl</code>, —á—Ç–æ–±—ã –º—ã –º–æ–≥–ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å <code>T</code> –¥–ª—è —É–∫–∞–∑–∞–Ω–∏—è –Ω–∞ —Ç–æ, —á—Ç–æ –º—ã —Ä–µ–∞–ª–∏–∑—É–µ–º –º–µ—Ç–æ–¥—ã –¥–ª—è —Ç–∏–ø–∞ <code>Point&lt;T&gt;</code>. –û–±—ä—è–≤–∏–≤ <code>T</code> —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–º —Ç–∏–ø–æ–º —Å—Ä–∞–∑—É –ø–æ—Å–ª–µ <code>impl</code>, Rust –º–æ–∂–µ—Ç –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å, —á—Ç–æ —Ç–∏–ø –≤ —É–≥–ª–æ–≤—ã—Ö —Å–∫–æ–±–∫–∞—Ö –≤ Point —è–≤–ª—è–µ—Ç—Å—è –æ–±–æ–±—â—ë–Ω–Ω—ã–º, –∞ –Ω–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º —Ç–∏–ø–æ–º. –ú—ã –º–æ–≥–ª–∏ –±—ã –≤—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥–æ–µ –∏–º—è –¥–ª—è —ç—Ç–æ–≥–æ –æ–±–æ–±—â—ë–Ω–Ω–æ–≥–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞, –æ—Ç–ª–∏—á–Ω–æ–µ –æ—Ç –∏–º–µ–Ω–∏, –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω–æ–≥–æ –≤ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, –Ω–æ –æ–±—ã—á–Ω–æ –∏—Å–ø–æ–ª—å–∑—É—é—Ç –æ–¥–Ω–æ –∏ —Ç–æ –∂–µ –∏–º—è. –ú–µ—Ç–æ–¥—ã, –Ω–∞–ø–∏—Å–∞–Ω–Ω—ã–µ –≤–Ω—É—Ç—Ä–∏ —Ä–∞–∑–¥–µ–ª–∞ <code>impl</code>, –∫–æ—Ç–æ—Ä—ã–π –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –æ–±–æ–±—â—ë–Ω–Ω—ã–π —Ç–∏–ø, –±—É–¥—É—Ç –æ–ø—Ä–µ–¥–µ–ª–µ–Ω—ã –¥–ª—è –ª—é–±–æ–≥–æ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ —Ç–∏–ø–∞, –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –æ—Ç —Ç–æ–≥–æ, –∫–∞–∫–æ–π –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —Ç–∏–ø –≤ –∫–æ–Ω–µ—á–Ω–æ–º –∏—Ç–æ–≥–µ –±—É–¥–µ—Ç –ø–æ–¥—Å—Ç–∞–≤–ª–µ–Ω –≤–º–µ—Å—Ç–æ –æ–±–æ–±—â—ë–Ω–Ω–æ–≥–æ.</p>
<p>–ú—ã –º–æ–∂–µ–º —Ç–∞–∫–∂–µ —É–∫–∞–∑–∞—Ç—å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –Ω–∞ —Ç–æ, –∫–∞–∫–∏–µ –æ–±–æ–±—â—ë–Ω–Ω—ã–µ —Ç–∏–ø—ã —Ä–∞–∑—Ä–µ—à–µ–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø—Ä–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–∏ –º–µ—Ç–æ–¥–æ–≤. –ù–∞–ø—Ä–∏–º–µ—Ä, –º—ã –º–æ–≥–ª–∏ –±—ã —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –º–µ—Ç–æ–¥—ã —Ç–æ–ª—å–∫–æ –¥–ª—è —ç–∫–∑–µ–º–ø–ª—è—Ä–æ–≤ —Ç–∏–ø–∞ <code>Point&lt;f32&gt;</code>, –∞ –Ω–µ –¥–ª—è —ç–∫–∑–µ–º–ø–ª—è—Ä–æ–≤ <code>Point&lt;T&gt;</code>, –≤ –∫–æ—Ç–æ—Ä—ã—Ö –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω—ã–π –æ–±–æ–±—â—ë–Ω–Ω—ã–π —Ç–∏–ø. –í –õ–∏—Å—Ç–∏–Ω–≥–µ 10-10 –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —Ç–∏–ø <code>f32</code>, –¥–ª—è —á–µ–≥–æ –Ω–∞–º –Ω–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è —É–∫–∞–∑—ã–≤–∞—Ç—å –Ω–∏–∫–∞–∫–∏–µ —Ç–∏–ø—ã —Ç–∏–ø—ã –ø–æ—Å–ª–µ <code>impl</code>.</p>
<Listing number="10-10" file-name="src/main.rs" caption="An `impl` block that only applies to a struct with a particular concrete type for the generic type parameter `T`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct Point&lt;T&gt; {
</span><span class="boring">    x: T,
</span><span class="boring">    y: T,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Point&lt;T&gt; {
</span><span class="boring">    fn x(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.x
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 5, y: 10 };
</span><span class="boring">
</span><span class="boring">    println!("p.x = {}", p.x());
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>–≠—Ç–æ—Ç –∫–æ–¥ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ —Ç–∏–ø <code>Point&lt;f32&gt;</code> –±—É–¥–µ—Ç –∏–º–µ—Ç—å –º–µ—Ç–æ–¥ <code>distance_from_origin</code>, –∞ –¥—Ä—É–≥–∏–µ —ç–∫–∑–µ–º–ø–ª—è—Ä—ã <code>Point&lt;T&gt;</code> (–≥–¥–µ <code>T</code> ‚Äî —Ç–∏–ø, –æ—Ç–ª–∏—á–Ω—ã–π –æ—Ç <code>f32</code>) –Ω–µ –±—É–¥—É—Ç –∏–º–µ—Ç—å —ç—Ç–æ–≥–æ –º–µ—Ç–æ–¥–∞. –ú–µ—Ç–æ–¥ –≤—ã—á–∏—Å–ª—è–µ—Ç, –Ω–∞—Å–∫–æ–ª—å–∫–æ –¥–∞–ª–µ–∫–æ –Ω–∞—à–∞ —Ç–æ—á–∫–∞ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –æ—Ç —Ç–æ—á–∫–∏ —Å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º–∏ <code>(0.0, 0.0)</code>, –∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏, –¥–æ—Å—Ç—É–ø–Ω—ã–µ —Ç–æ–ª—å–∫–æ –¥–ª—è —Ç–∏–ø–æ–≤ —Å –ø–ª–∞–≤–∞—é—â–µ–π —Ç–æ—á–∫–æ–π.</p>
<p>–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –æ–±–æ–±—â—ë–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞, –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–µ –≤ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, –Ω–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ —Å–æ–≤–ø–∞–¥–∞—é—Ç —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏, –∫–æ—Ç–æ—Ä—ã–µ –≤—ã –∏—Å–ø–æ–ª—å–∑—É–µ—Ç–µ –≤ —Å–∏–≥–Ω–∞—Ç—É—Ä–∞—Ö –º–µ—Ç–æ–¥–æ–≤ —ç—Ç–æ–π –∂–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã. –í–∑–≥–ª—è–Ω–∏—Ç–µ –Ω–∞ –õ–∏—Å—Ç–∏–Ω–≥ 10-11; –≤ –Ω—ë–º –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –æ–±–æ–±—â—ë–Ω–Ω—ã–µ —Ç–∏–ø—ã <code>X1</code> –∏ <code>Y1</code> –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã <code>Point</code> –∏ —Ç–∏–ø—ã <code>X2</code> –∏ <code>Y2</code> –¥–ª—è —Å–∏–≥–Ω–∞—Ç—É—Ä—ã –º–µ—Ç–æ–¥–∞ <code>mixup</code>. –ú–µ—Ç–æ–¥ —Å–æ–∑–¥–∞—ë—Ç –Ω–æ–≤—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä —Å—Ç—Ä—É–∫—Ç—É—Ä—ã <code>Point</code>, –≥–¥–µ –∑–Ω–∞—á–µ–Ω–∏–µ <code>x</code> –±–µ—Ä—ë—Ç—Å—è –∏–∑ <code>self</code> (–∏–º–µ—é—â–µ–π —Ç–∏–ø <code>X1</code>), –∞ –∑–Ω–∞—á–µ–Ω–∏–µ <code>y</code> ‚Äî –∏–∑ –ø–µ—Ä–µ–¥–∞–Ω–Ω–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã <code>Point</code> (–∏–º–µ—é—â–µ–π —Ç–∏–ø <code>Y2</code>).</p>
<Listing number="10-11" file-name="src/main.rs" caption="A method that uses generic types different from its struct‚Äôs definition">
<pre><pre class="playground"><code class="language-rust edition2021">struct Point&lt;X1, Y1&gt; {
    x: X1,
    y: Y1,
}

impl&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; {
    fn mixup&lt;X2, Y2&gt;(self, other: Point&lt;X2, Y2&gt;) -&gt; Point&lt;X1, Y2&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c' };

    let p3 = p1.mixup(p2);

    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}</code></pre></pre>
</Listing>
<p>–í —Ñ—É–Ω–∫—Ü–∏–∏ main –º—ã —Å–æ–∑–¥–∞–ª–∏ <code>Point</code>, –∫–æ—Ç–æ—Ä—ã–π –∏–º–µ–µ—Ç —Ç–∏–ø <code>x</code> —Ç–∏–ø–∞ <code>i32</code> (—Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º <code>5</code>) –∏ <code>y</code> —Ç–∏–ø–∞ <code>f64</code> (—Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º <code>10.4</code>). –ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è <code>p2</code> —è–≤–ª—è–µ—Ç—Å—è —Å—Ç—Ä—É–∫—Ç—É—Ä–æ–π <code>Point</code>, –∫–æ—Ç–æ—Ä–∞—è –∏–º–µ–µ—Ç —Å—Ç—Ä–æ–∫–æ–≤—ã–π —Å—Ä–µ–∑ <code>x</code> (—Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º <code>"Hello"</code>) –∏ —Å–∏–º–≤–æ–ª <code>y</code> —Ç–∏–ø–∞ <code>char</code> (—Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º <code>c</code>). –í—ã–∑–æ–≤ <code>mixup</code> –Ω–∞ <code>p1</code> —Å –∞—Ä–≥—É–º–µ–Ω—Ç–æ–º <code>p2</code> —Å–æ–∑–¥–∞—Å—Ç —ç–∫–∑–µ–º–ø–ª—è—Ä —Å—Ç—Ä—É–∫—Ç—É—Ä—ã <code>p3</code>, –∫–æ—Ç–æ—Ä—ã–π –±—É–¥–µ—Ç –∏–º–µ—Ç—å <code>x</code> —Ç–∏–ø–∞ <code>i32</code> (–ø–æ—Ç–æ–º—É —á—Ç–æ <code>x</code> –≤–∑—è—Ç –∏–∑ <code>p1</code>) –∏ <code>y</code> —Ç–∏–ø–∞ <code>char</code> (–ø–æ—Ç–æ–º—É —á—Ç–æ <code>y</code> –≤–∑—è—Ç –∏–∑ <code>p2</code>). –í—ã–∑–æ–≤ –º–∞–∫—Ä–æ—Å–∞ <code>println!</code> –≤—ã–≤–µ–¥–µ—Ç <code>p3.x = 5, p3.y = c</code>.</p>
<p>–¶–µ–ª—å —ç—Ç–æ–≥–æ –ø—Ä–∏–º–µ—Ä–∞ ‚Äî –ø—Ä–æ–¥–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å —Å–∏—Ç—É–∞—Ü–∏—é, –≤ –∫–æ—Ç–æ—Ä–æ–π –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –æ–±–æ–±—â—ë–Ω–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –æ–±—ä—è–≤–ª–µ–Ω—ã —Å –ø–æ–º–æ—â—å—é <code>impl</code>, –∞ –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –æ–±—ä—è–≤–ª–µ–Ω—ã —Å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ–º –º–µ—Ç–æ–¥–∞. –ó–¥–µ—Å—å –æ–±–æ–±—â—ë–Ω–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã <code>X1</code> –∏ <code>Y1</code> –æ–±—ä—è–≤–ª—è—é—Ç—Å—è –ø–æ—Å–ª–µ <code>impl</code>, –ø–æ—Ç–æ–º—É —á—Ç–æ –æ–Ω–∏ –æ—Ç–Ω–æ—Å—è—Ç—Å—è –∫ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—é —Å—Ç—Ä—É–∫—Ç—É—Ä—ã. –û–±–æ–±—â—ë–Ω–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã <code>X2</code> –∏ <code>Y2</code> –æ–±—ä—è–≤–ª—è—é—Ç—Å—è –ø–æ—Å–ª–µ <code>fn mixup</code>, —Ç–∞–∫ –∫–∞–∫ –æ–Ω–∏ –æ—Ç–Ω–æ—Å—è—Ç—Å—è —Ç–æ–ª—å–∫–æ –∫ –º–µ—Ç–æ–¥—É.</p>
<h3 id="–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å-–∫–æ–¥–∞-–∏—Å–ø–æ–ª—å–∑—É—é—â–µ–≥–æ-–æ–±–æ–±—â—ë–Ω–Ω—ã–µ-—Ç–∏–ø—ã"><a class="header" href="#–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å-–∫–æ–¥–∞-–∏—Å–ø–æ–ª—å–∑—É—é—â–µ–≥–æ-–æ–±–æ–±—â—ë–Ω–Ω—ã–µ-—Ç–∏–ø—ã">–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∫–æ–¥–∞, –∏—Å–ø–æ–ª—å–∑—É—é—â–µ–≥–æ –æ–±–æ–±—â—ë–Ω–Ω—ã–µ —Ç–∏–ø—ã</a></h3>
<p>–í—ã –º–æ–≥–ª–∏ –∑–∞–¥–∞—Ç—å—Å—è –≤–æ–ø—Ä–æ—Å–æ–º –æ —Ç–æ–º, –Ω–µ –≤–æ–∑–Ω–∏–∫–∞—é—Ç –ª–∏ –∫–∞–∫–∏–µ-–Ω–∏–±—É–¥—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –∏–∑–¥–µ—Ä–∂–∫–∏ –ø—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –æ–±–æ–±—â—ë–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞. –•–æ—Ä–æ—à–∞—è –Ω–æ–≤–æ—Å—Ç—å –≤ —Ç–æ–º, —á—Ç–æ –ø—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ –æ–±–æ–±—â—ë–Ω–Ω—ã—Ö —Ç–∏–ø–æ–≤ –≤–∞—à–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç –Ω–∏—á—É—Ç—å –Ω–∏ –º–µ–¥–ª–µ–Ω–Ω–µ–µ, —á–µ–º –µ—Å–ª–∏ –±—ã –æ–Ω–∞ —Ä–∞–±–æ—Ç–∞–ª–∞ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã—Ö —Ç–∏–ø–æ–≤.</p>
<p>–í Rust —ç—Ç–æ –¥–æ—Å—Ç–∏–≥–∞–µ—Ç—Å—è –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –ø—Ä–∏ –ø–æ–º–æ—â–∏ –º–æ–Ω–æ–º–æ—Ä—Ñ–∏–∑–∞—Ü–∏–∏ –∫–æ–¥–∞, –∏—Å–ø–æ–ª—å–∑—É—é—â–µ–≥–æ –æ–±–æ–±—â—ë–Ω–Ω—ã–µ —Ç–∏–ø—ã. <em>–ú–æ–Ω–æ–º–æ—Ä—Ñ–∏–∑–∞—Ü–∏—è</em> ‚Äî —ç—Ç–æ –ø—Ä–æ—Ü–µ—Å—Å –ø—Ä–µ–≤—Ä–∞—â–µ–Ω–∏—è –æ–±–æ–±—â—ë–Ω–Ω–æ–≥–æ –∫–æ–¥–∞ –≤ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –∫–æ–¥ –ø—É—Ç—ë–º –ø–æ–¥—Å—Ç–∞–Ω–æ–≤–∫–∏ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã—Ö —Ç–∏–ø–æ–≤, –∏—Å–ø–æ–ª—å–∑—É—é—â–∏—Ö—Å—è –ø—Ä–∏ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏. –í —ç—Ç–æ–º –ø—Ä–æ—Ü–µ—Å—Å–µ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –≤—ã–ø–æ–ª–Ω—è–µ—Ç —à–∞–≥–∏, –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω—ã–µ —Ç–µ–º, –∫–æ—Ç–æ—Ä—ã–µ –º—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –æ–±–æ–±—â—ë–Ω–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 10-5: –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –ø—Ä–æ—Å–º–∞—Ç—Ä–∏–≤–∞–µ—Ç –≤—Å–µ –º–µ—Å—Ç–∞, –≥–¥–µ –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –æ–±–æ–±—â—ë–Ω–Ω—ã–π –∫–æ–¥, –∏ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∫–æ–¥ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã—Ö —Ç–∏–ø–æ–≤, —Å –∫–æ—Ç–æ—Ä—ã–º–∏ –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –æ–±–æ–±—â—ë–Ω–Ω—ã–π –∫–æ–¥.</p>
<p>–î–∞–≤–∞–π—Ç–µ –ø–æ—Å–º–æ—Ç—Ä–∏–º, –∫–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç, –Ω–∞ –ø—Ä–∏–º–µ—Ä–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –æ–±–æ–±—â—ë–Ω–Ω–æ–≥–æ <code>Option&lt;T&gt;</code> –∏–∑ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let integer = Some(5);
let float = Some(5.0);
<span class="boring">}</span></code></pre></pre>
<p>–ö–æ–≥–¥–∞ Rust –∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç —ç—Ç–æ—Ç –∫–æ–¥, –æ–Ω –≤—ã–ø–æ–ª–Ω—è–µ—Ç –º–æ–Ω–æ–º–æ—Ä—Ñ–∏–∑–∞—Ü–∏—é. –í–æ –≤—Ä–µ–º—è —ç—Ç–æ–≥–æ –ø—Ä–æ—Ü–µ—Å—Å–∞ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä —Å–º–æ—Ç—Ä–∏—Ç –Ω–∞ –∑–Ω–∞—á–µ–Ω–∏—è, –∫–æ—Ç–æ—Ä—ã–µ –±—ã–ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω—ã –≤ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞—Ö <code>Option&lt;T&gt;</code>, –∏ –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç –¥–≤–∞ –≤–∏–¥–∞ <code>Option&lt;T&gt;</code>: –æ–¥–∏–Ω –¥–ª—è —Ç–∏–ø–∞ <code>i32</code>, –¥—Ä—É–≥–æ–π ‚Äî –¥–ª—è <code>f64</code>. –¢–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, –æ–Ω —Ä–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–µ—Ç –æ–±–æ–±—â—ë–Ω–Ω–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ <code>Option&lt;T&gt;</code> –≤ –¥–≤–∞ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è, —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–ª—è <code>i32</code> –∏ <code>f64</code>, —Ç–µ–º —Å–∞–º—ã–º –∑–∞–º–µ–Ω—è—è –æ–±–æ–±—â—ë–Ω–Ω–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º–∏.</p>
<p>–ú–æ–Ω–æ–º–æ—Ä—Ñ–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è –∫–æ–¥–∞ –≤—ã–≥–ª—è–¥–∏—Ç –ø—Ä–∏–º–µ—Ä–Ω–æ —Ç–∞–∫ (–∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –∏–º–µ–Ω–∞, –æ—Ç–ª–∏—á–Ω—ã–µ –æ—Ç —Ç–µ—Ö, –∫–æ—Ç–æ—Ä—ã–µ –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º –∑–¥–µ—Å—å –¥–ª—è –∏–ª–ª—é—Å—Ç—Ä–∞—Ü–∏–∏):</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}</code></pre></pre>
</Listing>
<p>–û–±–æ–±—â—ë–Ω–Ω—ã–π <code>Option&lt;T&gt;</code> –∑–∞–º–µ–Ω—è–µ—Ç—Å—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è–º–∏, —Å–æ–∑–¥–∞–Ω–Ω—ã–º–∏ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–æ–º. –ü–æ—Å–∫–æ–ª—å–∫—É Rust –∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç –æ–±–æ–±—â—ë–Ω–Ω—ã–π –∫–æ–¥ –≤ –∫–æ–¥, –æ–ø—Ä–µ–¥–µ–ª—è—é—â–∏–π —Ç–∏–ø –≤ –∫–∞–∂–¥–æ–º —ç–∫–∑–µ–º–ø–ª—è—Ä–µ, –º—ã –Ω–µ –ø–ª–∞—Ç–∏–º –∑–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –æ–±–æ–±—â—ë–Ω–Ω—ã—Ö —Ç–∏–ø–æ–≤ –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è. –ö–æ–≥–¥–∞ –∫–æ–¥ –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è, –æ–Ω —Ä–∞–±–æ—Ç–∞–µ—Ç —Ç–æ—á–Ω–æ —Ç–∞–∫ –∂–µ, –∫–∞–∫ –µ—Å–ª–∏ –±—ã –º—ã –ø—Ä–æ–¥—É–±–ª–∏—Ä–æ–≤–∞–ª–∏ –∫–∞–∂–¥–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –≤—Ä—É—á–Ω—É—é. –ü—Ä–æ—Ü–µ—Å—Å –º–æ–Ω–æ–º–æ—Ä—Ñ–∏–∑–∞—Ü–∏–∏ –¥–µ–ª–∞–µ—Ç –æ–±–æ–±—â—ë–Ω–Ω—ã–µ —Ç–∏–ø—ã Rust —á—Ä–µ–∑–≤—ã—á–∞–π–Ω–æ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–º–∏ –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–¢—Ä–µ–π—Ç—ã-–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ-—Å—Ö–æ–∂–µ–≥–æ-–ø–æ–≤–µ–¥–µ–Ω–∏—è"><a class="header" href="#–¢—Ä–µ–π—Ç—ã-–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ-—Å—Ö–æ–∂–µ–≥–æ-–ø–æ–≤–µ–¥–µ–Ω–∏—è">–¢—Ä–µ–π—Ç—ã: –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Å—Ö–æ–∂–µ–≥–æ –ø–æ–≤–µ–¥–µ–Ω–∏—è</a></h2>
<p><em>–¢—Ä–µ–π—Ç</em> –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å, –∫–æ—Ç–æ—Ä–æ–π –æ–±–ª–∞–¥–∞–µ—Ç –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —Ç–∏–ø –∏ –∫–æ—Ç–æ—Ä–∞—è –º–æ–∂–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è —Å –¥—Ä—É–≥–∏–º–∏ —Ç–∏–ø–∞–º–∏. –ú—ã –º–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç—Ä–µ–π—Ç—ã –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –æ–±—â–µ–≥–æ –ø–æ–≤–µ–¥–µ–Ω–∏—è –∞–±—Å—Ç—Ä–∞–∫—Ç–Ω—ã–º –æ–±—Ä–∞–∑–æ–º. –ú—ã –º–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å <em>–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ —Ç—Ä–µ–π—Ç–∞–º</em>, —á—Ç–æ–±—ã —É–∫–∞–∑–∞—Ç—å, —á—Ç–æ –æ–±–æ–±—â—ë–Ω–Ω—ã–π —Ç–∏–ø –º–æ–∂–µ—Ç –±—ã—Ç—å –∑–∞–º–µ–Ω—ë–Ω –Ω–∞ –ª—é–±–æ–π —Ç–∏–ø —Å –Ω–µ–∫–æ—Ç–æ—Ä—ã–º –∏–∑–≤–µ—Å—Ç–Ω—ã–º –ø–æ–≤–µ–¥–µ–Ω–∏–µ–º.</p>
<blockquote>
<p>–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: –¢—Ä–µ–π—Ç—ã —Å—Ö–æ–∂–∏ —Å —Ç–∞–∫–∏–º –º–µ—Ö–∞–Ω–∏–∑–º–æ–º –∫–∞–∫ <em>–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã</em>, –Ω–æ –≤—Å—ë –∂–µ –æ–Ω–∏ —Ä–∞–∑–ª–∏—á–∞—é—Ç—Å—è.</p>
</blockquote>
<h3 id="–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ-—Ç—Ä–µ–π—Ç–∞"><a class="header" href="#–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ-—Ç—Ä–µ–π—Ç–∞">–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç—Ä–µ–π—Ç–∞</a></h3>
<p>–ü–æ–≤–µ–¥–µ–Ω–∏–µ —Ç–∏–ø–∞ –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è —Ç–µ–º–∏ –º–µ—Ç–æ–¥–∞–º–∏, –∫–æ—Ç–æ—Ä—ã–µ –º—ã –º–æ–∂–µ–º –≤—ã–∑–≤–∞—Ç—å –Ω–∞ –¥–∞–Ω–Ω–æ–º —Ç–∏–ø–µ. –†–∞–∑–ª–∏—á–Ω—ã–µ —Ç–∏–ø—ã —Ä–∞–∑–¥–µ–ª—è—é—Ç –æ–¥–∏–Ω–∞–∫–æ–≤–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ, –µ—Å–ª–∏ –º—ã –º–æ–∂–µ–º –≤—ã–∑–≤–∞—Ç—å –æ–¥–Ω–∏ –∏ —Ç–µ –∂–µ –º–µ—Ç–æ–¥—ã —É —ç—Ç–∏—Ö —Ç–∏–ø–æ–≤. –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç—Ä–µ–π—Ç–æ–≤ ‚Äî —ç—Ç–æ —Å–ø–æ—Å–æ–± —Å–≥—Ä—É–ø–ø–∏—Ä–æ–≤–∞—Ç—å —Å–∏–≥–Ω–∞—Ç—É—Ä—ã –º–µ—Ç–æ–¥–æ–≤ –≤–º–µ—Å—Ç–µ –¥–ª—è —Ç–æ–≥–æ, —á—Ç–æ–±—ã –æ–ø–∏—Å–∞—Ç—å –æ–±—â–µ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ, –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ–µ –¥–ª—è –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–π —Ü–µ–ª–∏.</p>
<p>–ù–∞–ø—Ä–∏–º–µ—Ä, –ø—É—Å—Ç—å –µ—Å—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å—Ç—Ä—É–∫—Ç—É—Ä, –∫–æ—Ç–æ—Ä—ã–µ –∏–º–µ—é—Ç —Ä–∞–∑–ª–∏—á–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—É –∏ –æ–±—ä—ë–º —Ç–µ–∫—Å—Ç–∞: —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ <code>NewsArticle</code>, –∫–æ—Ç–æ—Ä–∞—è —Å–æ–¥–µ—Ä–∂–∏—Ç –Ω–æ–≤–æ—Å—Ç—å, –Ω–∞–ø–µ—á–∞—Ç–∞–Ω–Ω—É—é –≤ –∫–∞–∫–æ–º-—Ç–æ –º–µ—Å—Ç–µ –º–∏—Ä–∞, –∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ <code>Tweet</code>, –∫–æ—Ç–æ—Ä–∞—è —Å–æ–¥–µ—Ä–∂–∏—Ç 280 —Å–∏–º–≤–æ–ª–æ–≤ —Ç–µ–∫—Å—Ç–∞ —Ç–≤–∏—Ç–∞ –ø–ª—é—Å –º–µ—Ç–∞-–¥–∞–Ω–Ω—ã–µ, –æ–±–æ–∑–Ω–∞—á–∞—é—â–∏–µ, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ç–≤–∏—Ç –Ω–æ–≤—ã–º –∏–ª–∏ –æ—Ç–≤–µ—Ç–æ–º –Ω–∞ –¥—Ä—É–≥–æ–π —Ç–≤–∏—Ç.</p>
<p>–ú—ã —Ö–æ—Ç–∏–º —Å–æ–∑–¥–∞—Ç—å –±–∏–±–ª–∏–æ—Ç–µ—á–Ω—ã–π –∫—Ä–µ–π—Ç –Ω–æ–≤–æ—Å—Ç–Ω–æ–≥–æ –∞–≥—Ä–µ–≥–∞—Ç–æ—Ä–∞ <code>aggregator</code>, –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–µ—Ç –æ—Ç–æ–±—Ä–∞–∂–∞—Ç—å —Å–≤–æ–¥–∫—É –¥–∞–Ω–Ω—ã—Ö, —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã—Ö –≤ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä <code>NewsArticle</code> –∏–ª–∏ <code>Tweet</code>. –ß—Ç–æ–±—ã —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —ç—Ç–æ, –Ω–∞–º –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –∏–º–µ—Ç—å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –ø–æ–ª—É—á–∏—Ç—å —Å–≤–æ–¥–∫—É –Ω–∞ –æ—Å–Ω–æ–≤–µ –¥–∞–Ω–Ω—ã—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, –∏ –º—ã –º–æ–∂–µ–º –∑–∞–ø—Ä–æ—Å–∏—Ç—å —ç—Ç—É —Å–≤–æ–¥–∫—É, –≤—ã–∑–≤–∞–≤ –º–µ—Ç–æ–¥ <code>summarize</code>. –õ–∏—Å—Ç–∏–Ω–≥ 10-12 –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç—Ä–µ–π—Ç–∞ <code>Summary</code>, –≤—ã—Ä–∞–∂–∞—é—â–µ–≥–æ —ç—Ç–æ –ø–æ–≤–µ–¥–µ–Ω–∏–µ.</p>
<Listing number="10-12" file-name="src/lib.rs" caption="A `Summary` trait that consists of the behavior provided by a `summarize` method">
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}</code></pre>
</Listing>
<p>–ó–¥–µ—Å—å –º—ã –æ–±—ä—è–≤–ª—è–µ–º —Ç—Ä–µ–π—Ç —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –∫–ª—é—á–µ–≤–æ–≥–æ —Å–ª–æ–≤–∞ <code>trait</code>, –∞ –∑–∞—Ç–µ–º —É–∫–∞–∑—ã–≤–∞–µ–º –µ–≥–æ –Ω–∞–∑–≤–∞–Ω–∏–µ (–≤ –Ω–∞—à–µ–º —Å–ª—É—á–∞–µ ‚Äî <code>Summary</code>). –¢–∞–∫–∂–µ –º—ã –æ–±—ä—è–≤–ª—è–µ–º —Ç—Ä–µ–π—Ç –∫–∞–∫ <code>pub</code>, —á—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç –∫—Ä–µ–π—Ç–∞–º, –∑–∞–≤–∏—Å—è—â–∏–º –æ—Ç –Ω–∞—à–µ–≥–æ –∫—Ä–µ–π—Ç–∞, –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–∞—à —Ç—Ä–µ–π—Ç, –ø—Ä–∏–º–µ—Ä—ã —á–µ–≥–æ –º—ã —É–≤–∏–¥–∏–º –¥–∞–ª–µ–µ. –í–Ω—É—Ç—Ä–∏ —Ñ–∏–≥—É—Ä–Ω—ã—Ö —Å–∫–æ–±–æ–∫ –æ–±—ä—è–≤–ª—è—é—Ç—Å—è —Å–∏–≥–Ω–∞—Ç—É—Ä—ã –º–µ—Ç–æ–¥–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –æ–ø–∏—Å—ã–≤–∞—é—Ç –ø–æ–≤–µ–¥–µ–Ω–∏–µ —Ç–∏–ø–æ–≤, —Ä–µ–∞–ª–∏–∑—É—é—â–∏—Ö –¥–∞–Ω–Ω—ã–π —Ç—Ä–µ–π—Ç; –≤ –¥–∞–Ω–Ω–æ–º —Å–ª—É—á–∞–µ, –ø–æ–≤–µ–¥–µ–Ω–∏–µ –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –æ–¥–Ω–æ–π —Å–∏–≥–Ω–∞—Ç—É—Ä–æ–π –º–µ—Ç–æ–¥–∞ <code>fn summarize(&amp;self) -&gt; String</code>.</p>
<p>–ü–æ—Å–ª–µ —Å–∏–≥–Ω–∞—Ç—É—Ä—ã –º–µ—Ç–æ–¥–∞, –≤–º–µ—Å—Ç–æ –µ–≥–æ —Ç–µ–ª–∞ –º—ã –ø–∏—à–µ–º —Ç–æ—á–∫—É —Å –∑–∞–ø—è—Ç–æ–π. –ö–∞–∂–¥—ã–π —Ç–∏–ø,  —Ä–µ–∞–ª–∏–∑—É—é—â–∏–π –¥–∞–Ω–Ω—ã–π —Ç—Ä–µ–π—Ç, –¥–æ–ª–∂–µ–Ω –±—É–¥–µ—Ç –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–∏—Ç—å —Å–≤–æ—é —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—É—é —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é –¥–∞–Ω–Ω–æ–≥–æ –º–µ—Ç–æ–¥–∞. –ö–æ–º–ø–∏–ª—è—Ç–æ—Ä –æ–±–µ—Å–ø–µ—á–∏—Ç, —á—Ç–æ –ª—é–±–æ–π —Ç–∏–ø, —Ä–µ–∞–ª–∏–∑—É—é—â–∏–π —Ç—Ä–µ–π—Ç <code>Summary</code>, –±—É–¥–µ—Ç —Ç–∞–∫–∂–µ –∏–º–µ—Ç—å –∏ –º–µ—Ç–æ–¥ <code>summarize</code>, –æ–±—ä—è–≤–ª–µ–Ω–Ω—ã–π —Å —Ç–æ—á–Ω–æ —Ç–∞–∫–æ–π –∂–µ —Å–∏–≥–Ω–∞—Ç—É—Ä–æ–π.</p>
<p>–¢—Ä–µ–π—Ç –º–æ–∂–µ—Ç –æ–ø—Ä–µ–¥–µ–ª—è—Ç—å —Å–∏–≥–Ω–∞—Ç—É—Ä—ã –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –º–µ—Ç–æ–¥–æ–≤: —Å–∏–≥–Ω–∞—Ç—É—Ä—ã –º–µ—Ç–æ–¥–æ–≤ –ø–µ—Ä–µ—á–∏—Å–ª—è—é—Ç—Å—è –ø–æ –æ–¥–Ω–æ–π –Ω–∞ –∫–∞–∂–¥–æ–π —Å—Ç—Ä–æ–∫–µ –∏ –¥–æ–ª–∂–Ω—ã –∑–∞–∫–∞—á–∏–≤–∞—Ç—å—Å—è —Ç–æ—á–∫–æ–π —Å –∑–∞–ø—è—Ç–æ–π.</p>
<h3 id="–†–µ–∞–ª–∏–∑–∞—Ü–∏—è-—Ç—Ä–µ–π—Ç–∞-–¥–ª—è-—Ç–∏–ø–∞"><a class="header" href="#–†–µ–∞–ª–∏–∑–∞—Ü–∏—è-—Ç—Ä–µ–π—Ç–∞-–¥–ª—è-—Ç–∏–ø–∞">–†–µ–∞–ª–∏–∑–∞—Ü–∏—è —Ç—Ä–µ–π—Ç–∞ –¥–ª—è —Ç–∏–ø–∞</a></h3>
<p>–¢–µ–ø–µ—Ä—å, –ø–æ—Å–ª–µ —Ç–æ–≥–æ –∫–∞–∫ –º—ã –æ–ø—Ä–µ–¥–µ–ª–∏–ª–∏ –∂–µ–ª–∞–µ–º–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ, –∏—Å–ø–æ–ª—å–∑—É—è —Ç—Ä–µ–π—Ç <code>Summary</code>, –º–æ–∂–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤—ã–≤–∞—Ç—å –µ–≥–æ —É —Ç–∏–ø–æ–≤ –Ω–∞—à–µ–≥–æ –Ω–æ–≤–æ—Å—Ç–Ω–æ–≥–æ –∞–≥—Ä–µ–≥–∞—Ç–æ—Ä–∞. –õ–∏—Å—Ç–∏–Ω–≥ 10-13 –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é —Ç—Ä–µ–π—Ç–∞ <code>Summary</code> –¥–ª—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã <code>NewsArticle</code>, –∫–æ—Ç–æ—Ä–∞—è –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Å–≤–æ–¥–∫–∏ –≤ –º–µ—Ç–æ–¥–µ <code>summarize</code> –∑–∞–≥–æ–ª–æ–≤–æ–∫, –∞–≤—Ç–æ—Ä–∞ –∏ –º–µ—Å—Ç–æ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏ —Å—Ç–∞—Ç—å–∏. –î–ª—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã <code>Tweet</code> –º—ã –æ–ø—Ä–µ–¥–µ–ª—è–µ–º —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é <code>summarize</code>, –∏—Å–ø–æ–ª—å–∑—É—è –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ —Å–ª–µ–¥—É—é—â–∏–π –∑–∞ –Ω–∏–º –ø–æ–ª–Ω—ã–π —Ç–µ–∫—Å—Ç —Ç–≤–∏—Ç–∞, –ø–æ–ª–∞–≥–∞—è, —á—Ç–æ —Å–æ–¥–µ—Ä–∂–∞–Ω–∏–µ —Ç–≤–∏—Ç–∞ —É–∂–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–æ 280 —Å–∏–º–≤–æ–ª–∞–º–∏.</p>
<Listing number="10-13" file-name="src/lib.rs" caption="Implementing the `Summary` trait on the `NewsArticle` and `Tweet` types">
<pre><code class="language-rust noplayground"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!("{} ({} –∏–∑ {})", self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!("{}: {}", self.username, self.content)
    }
}</code></pre>
</Listing>
<p>–†–µ–∞–ª–∏–∑–∞—Ü–∏—è —Ç—Ä–µ–π—Ç–∞ –¥–ª—è —Ç–∏–ø–∞ –∞–Ω–∞–ª–æ–≥–∏—á–Ω–∞ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –æ–±—ã—á–Ω—ã—Ö –º–µ—Ç–æ–¥–æ–≤. –†–∞–∑–Ω–∏—Ü–∞ –≤ —Ç–æ–º, —á—Ç–æ –ø–æ—Å–ª–µ <code>impl</code> –º—ã —É–∫–∞–∑—ã–≤–∞–µ–º –∏–º—è —Ç—Ä–µ–π—Ç–∞, –∫–æ—Ç–æ—Ä—ã–π –º—ã —Ö–æ—Ç–∏–º —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å, –∑–∞—Ç–µ–º –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ <code>for</code>, –∞ –∑–∞—Ç–µ–º —É–∫–∞–∑—ã–≤–∞–µ–º –∏–º—è —Ç–∏–ø–∞, –¥–ª—è –∫–æ—Ç–æ—Ä–æ–≥–æ –º—ã —Ö–æ—Ç–∏–º —Å–¥–µ–ª–∞—Ç—å —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é —Ç—Ä–µ–π—Ç–∞. –í–Ω—É—Ç—Ä–∏ –±–ª–æ–∫–∞ <code>impl</code> –º—ã –ø–æ–º–µ—â–∞–µ–º —Å–∏–≥–Ω–∞—Ç—É—Ä—É –º–µ—Ç–æ–¥–∞, –æ–±—ä—è–≤–ª–µ–Ω–Ω—É—é –≤ —Ç—Ä–µ–π—Ç–µ. –í–º–µ—Å—Ç–æ —Ç–æ—á–∫–∏ —Å –∑–∞–ø—è—Ç–æ–π –≤ –∫–æ–Ω—Ü–µ, –ø–æ—Å–ª–µ –∫–∞–∂–¥–æ–π —Å–∏–≥–Ω–∞—Ç—É—Ä—ã –ø–∏—à—É—Ç—Å—è —Ñ–∏–≥—É—Ä–Ω—ã–µ —Å–∫–æ–±–∫–∏, –∏ —Ç–µ–ª–æ –º–µ—Ç–æ–¥–∞ –∑–∞–ø–æ–ª–Ω—è–µ—Ç—Å—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º –∫–æ–¥–æ–º, —Ä–µ–∞–ª–∏–∑—É—é—â–∏–º –ø–æ–≤–µ–¥–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –º—ã —Ö–æ—Ç–∏–º –ø–æ–ª—É—á–∏—Ç—å –æ—Ç –º–µ—Ç–æ–¥–æ–≤ —Ç—Ä–µ–π—Ç–∞ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Ç–∏–ø–∞.</p>
<p>–¢–µ–ø–µ—Ä—å, –∫–æ–≥–¥–∞ –Ω–∞—à –±–∏–±–ª–∏–æ—Ç–µ—á–Ω—ã–π –∫—Ä–µ–π—Ç —Ä–µ–∞–ª–∏–∑–æ–≤—ã–≤–∞–µ—Ç —Ç—Ä–µ–π—Ç <code>Summary</code> –¥–ª—è <code>NewsArticle</code> –∏ <code>Tweet</code>, –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç—ã, –∏—Å–ø–æ–ª—å–∑—É—é—â–∏–µ –Ω–∞—à –∫—Ä–µ–π—Ç, –º–æ–≥—É—Ç –≤—ã–∑—ã–≤–∞—Ç—å –º–µ—Ç–æ–¥—ã —Ç—Ä–µ–π—Ç–∞ —É —ç–∫–∑–µ–º–ø–ª—è—Ä–æ–≤ —Ç–∏–ø–æ–≤ <code>NewsArticle</code> –∏ <code>Tweet</code> —Ç–æ—á–Ω–æ —Ç–∞–∫ –∂–µ, –∫–∞–∫ –µ—Å–ª–∏ –±—ã —ç—Ç–æ –±—ã–ª–∏ –æ–±—ã—á–Ω—ã–µ –º–µ—Ç–æ–¥—ã. –ï–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ–µ –æ—Ç–ª–∏—á–∏–µ —Å–æ—Å—Ç–æ–∏—Ç –≤ —Ç–æ–º, —á—Ç–æ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç –¥–æ–ª–∂–µ–Ω –≤–≤–µ—Å—Ç–∏ —Ç—Ä–µ–π—Ç –≤ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ —Ç–æ—á–Ω–æ —Ç–∞–∫ –∂–µ, –∫–∞–∫ –∏ —Ç–∏–ø—ã. –í–æ—Ç –ø—Ä–∏–º–µ—Ä —Ç–æ–≥–æ –∫–∞–∫ –±–∏–Ω–∞—Ä–Ω—ã–π –∫—Ä–µ–π—Ç –º–æ–∂–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–∞—à –Ω–æ–≤–æ—Å—Ç–Ω–æ–π –∞–≥—Ä–µ–≥–∞—Ç–æ—Ä:</p>
<pre><code class="language-rust ignore">use aggregator::{Summary, Tweet};

fn main() {
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "–∫–æ–Ω–µ—á–Ω–æ, –≤—ã —É–∂–µ –Ω–∞–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞–µ—Ç–µ, –Ω–∞—Ä–æ–¥, ...",
        ),
        reply: false,
        retweet: false,
    };

    println!("1 –Ω–æ–≤—ã–π —Ç–≤–∏—Ç: {}", tweet.summarize());
}</code></pre>
<p>–î–∞–Ω–Ω—ã–π –∫–æ–¥ –Ω–∞–ø–µ—á–∞—Ç–∞–µ—Ç: <code>1 –Ω–æ–≤—ã–π —Ç–≤–∏—Ç: horse_ebooks: –∫–æ–Ω–µ—á–Ω–æ, –≤—ã —É–∂–µ –Ω–∞–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞–µ—Ç–µ, –Ω–∞—Ä–æ–¥, ...</code>.</p>
<p>–î—Ä—É–≥–∏–µ –∫—Ä–µ–π—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –∑–∞–≤–∏—Å—è—Ç –æ—Ç <code>aggregator</code>, —Ç–∞–∫–∂–µ –º–æ–≥—É—Ç –≤–∫–ª—é—á–∞—Ç—å —Ç—Ä–µ–π—Ç <code>Summary</code> –≤ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ –¥–ª—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ <code>Summary</code> –¥–ª—è —Å–≤–æ–∏—Ö —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã—Ö —Ç–∏–ø–æ–≤. –û–¥–Ω–æ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ, –Ω–∞ –∫–æ—Ç–æ—Ä–æ–µ —Å–ª–µ–¥—É–µ—Ç –æ–±—Ä–∞—Ç–∏—Ç—å –≤–Ω–∏–º–∞–Ω–∏–µ, –∑–∞–∫–ª—é—á–∞–µ—Ç—Å—è –≤ —Ç–æ–º, —á—Ç–æ –º—ã –º–æ–∂–µ–º —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Ç—Ä–µ–π—Ç –¥–ª—è —Ç–∏–ø–∞ —Ç–æ–ª—å–∫–æ –≤ —Ç–æ–º —Å–ª—É—á–∞–µ, –µ—Å–ª–∏ —Ö–æ—Ç—è –±—ã –∏–ª–∏ —Ç—Ä–µ–π—Ç, –∏–ª–∏ —Ç–∏–ø –æ–ø—Ä–µ–¥–µ–ª—è—é—Ç—Å—è <em>–Ω–∞—à–∏–º</em> –∫—Ä–µ–π—Ç–æ–º. –ù–∞–ø—Ä–∏–º–µ—Ä, –º—ã –º–æ–∂–µ–º —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –±–∏–±–ª–∏–æ—Ç–µ—á–Ω—ã–π —Ç—Ä–µ–π—Ç <code>Display</code> –Ω–∞ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ–º —Ç–∏–ø–µ <code>Tweet</code> –∫–∞–∫ —á–∞—Å—Ç—å —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏ –Ω–∞—à–µ–≥–æ –∫—Ä–µ–π—Ç–∞ <code>aggregator</code>, –ø–æ—Ç–æ–º—É —á—Ç–æ —Ç–∏–ø <code>Tweet</code> —è–≤–ª—è–µ—Ç—Å—è –ª–æ–∫–∞–ª—å–Ω—ã–º –¥–ª—è –∫—Ä–µ–π—Ç–∞ <code>aggregator</code>. –¢–∞–∫–∂–µ –º—ã –º–æ–∂–µ–º —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å <code>Summary</code> –¥–ª—è <code>Vec&lt;T&gt;</code> –≤ –Ω–∞—à–µ–º –∫—Ä–µ–π—Ç–µ <code>aggregator</code>, –ø–æ—Ç–æ–º—É —á—Ç–æ —Ç—Ä–µ–π—Ç <code>Summary</code> —è–≤–ª—è–µ—Ç—Å—è –ª–æ–∫–∞–ª—å–Ω—ã–º –¥–ª—è –Ω–∞—à–µ–≥–æ –∫—Ä–µ–π—Ç–∞ <code>aggregator</code>.</p>
<p>–ù–æ –º—ã –Ω–µ –º–æ–∂–µ–º —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —á—É–∂–∏–µ —Ç—Ä–µ–π—Ç—ã –¥–ª—è —á—É–∂–∏—Ö —Ç–∏–ø–æ–≤. –ù–∞–ø—Ä–∏–º–µ—Ä, –º—ã –Ω–µ –º–æ–∂–µ–º —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Ç—Ä–µ–π—Ç <code>Display</code> –¥–ª—è <code>Vec&lt;T&gt;</code> –≤–Ω—É—Ç—Ä–∏ –Ω–∞—à–µ–≥–æ –∫—Ä–µ–π—Ç–∞ <code>aggregator</code>, –ø–æ—Ç–æ–º—É —á—Ç–æ –∏ <code>Display</code>, –∏ <code>Vec&lt;T&gt;</code> –æ–±–∞ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω—ã –≤ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–µ, –∞ –Ω–µ –≤ –Ω–∞—à–µ–º –∫—Ä–µ–π—Ç–µ <code>aggregator</code>. –≠—Ç–æ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —è–≤–ª—è–µ—Ç—Å—è —á–∞—Å—Ç—å—é —Å–≤–æ–π—Å—Ç–≤–∞, –Ω–∞–∑—ã–≤–∞–µ–º–æ–≥–æ <em>–ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é</em> (–∞–Ω–≥–ª. <em>coherence</em>), –∞ —Ç–æ—á–Ω–µ–µ ‚Äî <em>–ø—Ä–∞–≤–∏–ª–∞ —Å–∏—Ä–æ—Ç—ã</em> (–∞–Ω–≥–ª. <em>orphan rule</em>), –∫–æ—Ç–æ—Ä–æ–µ –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è —Ç–∞–∫ –ø–æ—Ç–æ–º—É, —á—Ç–æ –Ω–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–∏–π —Ç–∏–ø. –≠—Ç–æ –ø—Ä–∞–≤–∏–ª–æ –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç, —á—Ç–æ –∫–æ–¥ –¥—Ä—É–≥–∏—Ö –ª—é–¥–µ–π –Ω–µ –º–æ–∂–µ—Ç —Å–ª–æ–º–∞—Ç—å –≤–∞—à –∫–æ–¥, –∏ –Ω–∞–æ–±–æ—Ä–æ—Ç. –ë–µ–∑ —ç—Ç–æ–≥–æ –ø—Ä–∞–≤–∏–ª–∞ –¥–≤–∞ –∫—Ä–µ–π—Ç–∞ –º–æ–≥–ª–∏ –±—ã —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –æ–¥–∏–Ω —Ç—Ä–µ–π—Ç –¥–ª—è –æ–¥–Ω–æ–≥–æ —Ç–∏–ø–∞, –∏ Rust –Ω–µ —Å–º–æ–≥ –±—ã –ø–æ–Ω—è—Ç—å, –∫–∞–∫–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–µ–π –Ω—É–∂–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è.</p>
<h3 id="–†–µ–∞–ª–∏–∑–∞—Ü–∏—è-–ø–æ–≤–µ–¥–µ–Ω–∏—è-–ø–æ-—É–º–æ–ª—á–∞–Ω–∏—é"><a class="header" href="#–†–µ–∞–ª–∏–∑–∞—Ü–∏—è-–ø–æ–≤–µ–¥–µ–Ω–∏—è-–ø–æ-—É–º–æ–ª—á–∞–Ω–∏—é">–†–µ–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ–≤–µ–¥–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é</a></h3>
<p>–ò–Ω–æ–≥–¥–∞ –±—ã–≤–∞–µ—Ç –ø–æ–ª–µ–∑–Ω–æ –∑–∞–¥–∞—Ç—å –ø–æ–≤–µ–¥–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –¥–ª—è –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –∏–ª–∏ –≤—Å–µ—Ö –º–µ—Ç–æ–¥–æ–≤ —Ç—Ä–µ–π—Ç–∞ –≤–º–µ—Å—Ç–æ —Ç–æ–≥–æ, —á—Ç–æ–±—ã —Ç—Ä–µ–±–æ–≤–∞—Ç—å —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –≤—Å–µ—Ö –º–µ—Ç–æ–¥–æ–≤ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ç–∏–ø–∞. –¢–∞–∫–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –º–æ–∂–Ω–æ –±—É–¥–µ—Ç (—É–∂–µ –Ω–µ–ø–æ—Å—Ä–µ–¥—Å—Ç–≤–µ–Ω–Ω–æ –ø—Ä–∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ —Ç—Ä–µ–π—Ç–∞) –∫–∞–∫ –æ—Å—Ç–∞–≤–∏—Ç—å, —Ç–∞–∫ –∏ –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å.</p>
<p>–í –õ–∏—Å—Ç–∏–Ω–≥–µ 10-14 –ø–æ–∫–∞–∑–∞–Ω–æ, –º—ã –æ–ø—Ä–µ–¥–µ–ª—è–µ–º —Å–≤–æ–¥–∫—É –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –¥–ª—è –º–µ—Ç–æ–¥–∞ <code>summarize</code> —Ç—Ä–µ–π—Ç–∞ <code>Summary</code>, –≤–º–µ—Å—Ç–æ —Ç–æ–≥–æ, —á—Ç–æ–±—ã –æ–ø—Ä–µ–¥–µ–ª—è—Ç—å –ª–∏—à—å —Å–∏–≥–Ω–∞—Ç—É—Ä—É –º–µ—Ç–æ–¥–∞, –∫–∞–∫ –º—ã –¥–µ–ª–∞–ª–∏ —Ä–∞–Ω–µ–µ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 10-12.</p>
<Listing number="10-14" file-name="src/lib.rs" caption="Defining a `Summary` trait with a default implementation of the `summarize` method">
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        String::from("(–ß–∏—Ç–∞—Ç—å –¥–∞–ª–µ–µ...)")
    }
}
<span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>–î–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —Å–≤–æ–¥–∫–∏ —ç–∫–∑–µ–º–ø–ª—è—Ä–æ–≤ <code>NewsArticle</code>, –º—ã —É–∫–∞–∑—ã–≤–∞–µ–º –ø—É—Å—Ç–æ–π –±–ª–æ–∫ –ø—Ä–∏ <code>impl Summary for NewsArticle {}</code>.</p>
<p>–•–æ—Ç—è –º—ã –±–æ–ª—å—à–µ –Ω–µ –æ–ø—Ä–µ–¥–µ–ª—è–µ–º –º–µ—Ç–æ–¥ <code>summarize</code> –Ω–µ–ø–æ—Å—Ä–µ–¥—Å—Ç–≤–µ–Ω–Ω–æ –Ω–∞ <code>NewsArticle</code>, –º—ã –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–∏–ª–∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –∏ —É–∫–∞–∑–∞–ª–∏, —á—Ç–æ <code>NewsArticle</code> —Ä–µ–∞–ª–∏–∑—É–µ—Ç —Ç—Ä–µ–π—Ç <code>Summary</code>. –í —Ä–µ–∑—É–ª—å—Ç–∞—Ç–µ –º—ã –≤—Å—ë –µ—â—ë –º–æ–∂–µ–º –≤—ã–∑–≤–∞—Ç—å –º–µ—Ç–æ–¥ <code>summarize</code> —É —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ <code>NewsArticle</code>; –Ω–∞–ø—Ä–∏–º–µ—Ä, –≤–æ—Ç —Ç–∞–∫:</p>
<pre><code class="language-rust ignore"><span class="boring">use aggregator::{self, NewsArticle, Summary};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let article = NewsArticle {
        headline: String::from("¬´–ü–∏—Ç—Ç—Å–±—É—Ä–≥ –ü–∏–Ω–≥–≤–∏–Ω–∑¬ª –≤—ã–∏–≥—Ä–∞–ª–∏ –ö—É–±–æ–∫ –°—Ç—ç–Ω–ª–∏!"),
        location: String::from("–ü–∏—Ç—Ç—Å–±—É—Ä–≥, —à—Ç–∞—Ç –ü–µ–Ω—Å–∏–ª—å–≤–∞–Ω–∏—è, –°–®–ê"),
        author: String::from("–ü–∏–Ω–≥–≤–∏–Ω –ê–π—Å–±—É—Ä–≥"),
        content: String::from(
            "¬´–ü–∏—Ç—Ç—Å–±—É—Ä–≥ –ü–∏–Ω–≥–≤–∏–Ω–∑¬ª –≤–Ω–æ–≤—å –æ–∫–∞–∑–∞–ª–∞—Å—å –ª—É—á—à–µ–π \
             —Ö–æ–∫–∫–µ–π–Ω–æ–π –∫–æ–º–∞–Ω–¥–æ–π –≤ –ù–•–õ.",
        ),
    };

    println!("–ù–æ–≤–æ—Å—Ç–∏! {}", article.summarize());
<span class="boring">}</span></code></pre>
<p>–≠—Ç–æ—Ç –∫–æ–¥ –ø–µ—á–∞—Ç–∞–µ—Ç <code>–ù–æ–≤–æ—Å—Ç–∏! (–ß–∏—Ç–∞—Ç—å –¥–∞–ª–µ–µ...)</code>.</p>
<p>–°–æ–∑–¥–∞–Ω–∏–µ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –Ω–µ —Ç—Ä–µ–±—É–µ—Ç –æ—Ç –Ω–∞—Å –∏–∑–º–µ–Ω–µ–Ω–∏–π —á–µ–≥–æ-–ª–∏–±–æ –≤ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ <code>Summary</code> –¥–ª—è <code>Tweet</code> –∏–∑ –õ–∏—Å—Ç–∏–Ω–≥–∞ 10-13. –ü—Ä–∏—á–∏–Ω–∞ –∑–∞–∫–ª—é—á–∞–µ—Ç—Å—è –≤ —Ç–æ–º, —á—Ç–æ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –¥–ª—è –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é —è–≤–ª—è–µ—Ç—Å—è —Ç–∞–∫–∏–º –∂–µ, –∫–∞–∫ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –¥–ª—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –º–µ—Ç–æ–¥–∞ —Ç—Ä–µ–π—Ç–∞, –∫–æ—Ç–æ—Ä—ã–π –Ω–µ –∏–º–µ–µ—Ç —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é.</p>
<p>–†–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –º–æ–≥—É—Ç –≤—ã–∑—ã–≤–∞—Ç—å –¥—Ä—É–≥–∏–µ –º–µ—Ç–æ–¥—ã –≤ —Ç–æ–º –∂–µ —Ç—Ä–µ–π—Ç–µ, –¥–∞–∂–µ –µ—Å–ª–∏ —ç—Ç–∏ –¥—Ä—É–≥–∏–µ –º–µ—Ç–æ–¥—ã –Ω–µ –∏–º–µ—é—Ç —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é. –¢–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, —Ç—Ä–µ–π—Ç –º–æ–∂–µ—Ç –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–∏—Ç—å –º–Ω–æ–≥–æ –ø–æ–ª–µ–∑–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏, –∞ –æ—Ç —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ —Ç—Ä–µ–±—É–µ—Ç —É–∫–∞–∑—ã–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ –Ω–µ–±–æ–ª—å—à—É—é –µ–≥–æ —á–∞—Å—Ç—å. –ù–∞–ø—Ä–∏–º–µ—Ä, –º—ã –º–æ–≥–ª–∏ –±—ã –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ç—Ä–µ–π—Ç <code>Summary</code>, –∏–º–µ—é—â–∏–π –º–µ—Ç–æ–¥ <code>summarize_author</code> –±–µ–∑ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, –∞ –∑–∞—Ç–µ–º –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –º–µ—Ç–æ–¥ <code>summarize</code> –∫–æ—Ç–æ—Ä—ã–π –∏–º–µ–µ—Ç —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, –≤—ã–∑—ã–≤–∞—é—â—É—é –º–µ—Ç–æ–¥ <code>summarize_author</code>:</p>
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        format!("(–ß–∏—Ç–∞—Ç—å –¥–∞–ª–µ–µ, –æ—Ç {}...)", self.summarize_author())
    }
}
<span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String {
</span><span class="boring">        format!("@{}", self.username)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>–ß—Ç–æ–±—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–∞–∫—É—é –≤–µ—Ä—Å–∏—é —Ç—Ä–µ–π—Ç–∞ <code>Summary</code>, –ø—Ä–∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ —Ç—Ä–µ–π—Ç–∞ –¥–ª—è —Ç–∏–ø–∞ –Ω—É–∂–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ç–æ–ª—å–∫–æ –º–µ—Ç–æ–¥ <code>summarize_author</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String;
</span><span class="boring">
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("(–ß–∏—Ç–∞—Ç—å –¥–∞–ª–µ–µ, –æ—Ç {}...)", self.summarize_author())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Summary for Tweet {
    fn summarize_author(&amp;self) -&gt; String {
        format!("@{}", self.username)
    }
}</code></pre>
<p>–ü–æ—Å–ª–µ —Ç–æ–≥–æ, –∫–∞–∫ –º—ã –æ–ø—Ä–µ–¥–µ–ª–∏–º <code>summarize_author</code>, –º–æ–∂–Ω–æ –≤—ã–∑–≤–∞—Ç—å <code>summarize</code> –¥–ª—è —ç–∫–∑–µ–º–ø–ª—è—Ä–æ–≤ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã <code>Tweet</code>, –∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –º–µ—Ç–æ–¥–∞ <code>summarize</code> –±—É–¥–µ—Ç –≤—ã–∑—ã–≤–∞—Ç—å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ <code>summarize_author</code>, –∫–æ—Ç–æ—Ä–æ–µ –º—ã —É–∂–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–∏–ª–∏. –¢–∞–∫ –∫–∞–∫ –º—ã —Ä–µ–∞–ª–∏–∑–æ–≤–∞–ª–∏ –º–µ—Ç–æ–¥ <code>summarize_author</code> —Ç—Ä–µ–π—Ç–∞ <code>Summary</code>, —Ç–æ —Ç—Ä–µ–π—Ç –¥–∞—ë—Ç –Ω–∞–º –ø–æ–≤–µ–¥–µ–Ω–∏–µ –º–µ—Ç–æ–¥–∞ <code>summarize</code> –±–µ–∑ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –ø–∏—Å–∞—Ç—å –µ—â—ë –∫–∞–∫–æ–π-–ª–∏–±–æ –∫–æ–¥. –í–æ—Ç –∫–∞–∫ —ç—Ç–æ –≤—ã–≥–ª—è–¥–∏—Ç:</p>
<pre><code class="language-rust ignore"><span class="boring">use aggregator::{self, Summary, Tweet};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "–∫–æ–Ω–µ—á–Ω–æ, –≤—ã —É–∂–µ –Ω–∞–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞–µ—Ç–µ, –Ω–∞—Ä–æ–¥, ...",
        ),
        reply: false,
        retweet: false,
    };

    println!("1 –Ω–æ–≤—ã–π —Ç–≤–∏—Ç: {}", tweet.summarize());
<span class="boring">}</span></code></pre>
<p>–≠—Ç–æ—Ç –∫–æ–¥ –ø–µ—á–∞—Ç–∞–µ—Ç <code>1 –Ω–æ–≤—ã–π —Ç–≤–∏—Ç: (–ß–∏—Ç–∞—Ç—å –¥–∞–ª–µ–µ, –æ—Ç @horse_ebooks...)</code></p>
<p>–û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ –≤—ã–∑–≤–∞—Ç—å —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –∏–∑ –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ —Ç–æ–≥–æ –∂–µ –º–µ—Ç–æ–¥–∞.</p>
<h3 id="–¢—Ä–µ–π—Ç—ã-–∫–∞–∫-–ø–∞—Ä–∞–º–µ—Ç—Ä—ã"><a class="header" href="#–¢—Ä–µ–π—Ç—ã-–∫–∞–∫-–ø–∞—Ä–∞–º–µ—Ç—Ä—ã">–¢—Ä–µ–π—Ç—ã –∫–∞–∫ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã</a></h3>
<p>–¢–µ–ø–µ—Ä—å, –∫–æ–≥–¥–∞ –≤—ã –∑–Ω–∞–µ—Ç–µ, –∫–∞–∫ –æ–ø—Ä–µ–¥–µ–ª—è—Ç—å –∏ —Ä–µ–∞–ª–∏–∑–æ–≤—ã–≤–∞—Ç—å —Ç—Ä–µ–π—Ç—ã, –º—ã –º–æ–∂–µ–º –∏–∑—É—á–∏—Ç—å, –∫–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç—Ä–µ–π—Ç—ã, —á—Ç–æ–±—ã –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ñ—É–Ω–∫—Ü–∏–∏, –∫–æ—Ç–æ—Ä—ã–µ –ø—Ä–∏–Ω–∏–º–∞—é—Ç –º–Ω–æ–≥–æ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Ç–∏–ø–æ–≤. –ú—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç—Ä–µ–π—Ç <code>Summary</code> (—Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π –¥–ª—è —Ç–∏–ø–æ–≤ <code>NewsArticle</code> –∏ <code>Tweet</code>) –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 10-13, —á—Ç–æ–±—ã –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ñ—É–Ω–∫—Ü–∏—é <code>notify</code>, –∫–æ—Ç–æ—Ä–∞—è –≤—ã–∑—ã–≤–∞–µ—Ç –º–µ—Ç–æ–¥ <code>summarize</code> –¥–ª—è –µ–≥–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ <code>item</code> –Ω–µ–∫–æ—Ç–æ—Ä–æ–≥–æ —Ç–∏–ø–∞, —Ä–µ–∞–ª–∏–∑—É—é—â–µ–≥–æ —Ç—Ä–µ–π—Ç <code>Summary</code>. –î–ª—è —ç—Ç–æ–≥–æ –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å–∏–Ω—Ç–∞–∫—Å–∏—Å <code>impl Trait</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{} ({} –∏–∑ {})", self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn notify(item: &amp;impl Summary) {
    println!("–°—Ä–æ—á–Ω—ã–µ –Ω–æ–≤–æ—Å—Ç–∏! {}", item.summarize());
}</code></pre>
<p>–í–º–µ—Å—Ç–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Ç–∏–ø–∞ —É –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ <code>item</code> —É–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ <code>impl</code> –∏ –∏–º—è —Ç—Ä–µ–π—Ç–∞. –≠—Ç–æ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä –º–æ–∂–µ—Ç –ø—Ä–∏–Ω–∏–º–∞—Ç—å –ª—é–±–æ–π —Ç–∏–ø, –∫–æ—Ç–æ—Ä—ã–π —Ä–µ–∞–ª–∏–∑—É–µ—Ç —É–∫–∞–∑–∞–Ω–Ω—ã–π —Ç—Ä–µ–π—Ç. –í —Ç–µ–ª–µ <code>notify</code> –º—ã –º–æ–∂–µ–º –≤—ã–∑—ã–≤–∞—Ç—å –ª—é–±—ã–µ –º–µ—Ç–æ–¥—ã —É —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ <code>item</code>, –∫–æ—Ç–æ—Ä—ã–µ –ø—Ä–∏—Ö–æ–¥—è—Ç —Å —Ç—Ä–µ–π—Ç–æ–º <code>Summary</code>, —Ç–∞–∫–∏–µ –∫–∞–∫ –º–µ—Ç–æ–¥ <code>summarize</code>. –ú—ã –º–æ–∂–µ–º –≤—ã–∑–≤–∞—Ç—å <code>notify</code> –∏ –ø–µ—Ä–µ–¥–∞—Ç—å –≤ –Ω–µ–≥–æ –ª—é–±–æ–π —ç–∫–∑–µ–º–ø–ª—è—Ä <code>NewsArticle</code> –∏–ª–∏ <code>Tweet</code>. –ö–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –≤—ã–∑—ã–≤–∞–µ—Ç –¥–∞–Ω–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é —Å –ª—é–±—ã–º –¥—Ä—É–≥–∏–º —Ç–∏–ø–æ–º, —Ç–∞–∫–∏–º –∫–∞–∫ <code>String</code> –∏–ª–∏ <code>i32</code>, –Ω–µ –±—É–¥–µ—Ç –∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞—Ç—å—Å—è, –ø–æ—Ç–æ–º—É —á—Ç–æ —ç—Ç–∏ —Ç–∏–ø—ã –Ω–µ —Ä–µ–∞–ª–∏–∑—É—é—Ç —Ç—Ä–µ–π—Ç <code>Summary</code>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="fixing-the-largest-function-with-trait-bounds"></a></p>
<h4 id="–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ-–ø–æ-—Ç—Ä–µ–π—Ç–∞–º"><a class="header" href="#–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ-–ø–æ-—Ç—Ä–µ–π—Ç–∞–º">–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ —Ç—Ä–µ–π—Ç–∞–º</a></h4>
<p>–°–∏–Ω—Ç–∞–∫—Å–∏—Å <code>impl Trait</code> —Ä–∞–±–æ—Ç–∞–µ—Ç –¥–ª—è –ø—Ä–æ—Å—Ç—ã—Ö —Å–ª—É—á–∞–µ–≤, –Ω–æ –Ω–∞ —Å–∞–º–æ–º –¥–µ–ª–µ —è–≤–ª—è–µ—Ç—Å—è  —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∏–º —Å–∞—Ö–∞—Ä–æ–º –¥–ª—è –±–æ–ª–µ–µ –¥–ª–∏–Ω–Ω–æ–π –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ ‚Äî <em>–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –ø–æ —Ç—Ä–µ–π—Ç–∞–º</em>:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item: &amp;T) {
    println!("–°—Ä–æ—á–Ω—ã–µ –Ω–æ–≤–æ—Å—Ç–∏! {}", item.summarize());
}</code></pre>
<p>–≠—Ç–∞ –±–æ–ª–µ–µ –¥–ª–∏–Ω–Ω–∞—è —Ñ–æ—Ä–º–∞ —ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–Ω–∞ –ø—Ä–µ–¥—ã–¥—É—â–µ–º—É –ø—Ä–∏–º–µ—Ä—É, –Ω–æ –æ–Ω–∞ –±–æ–ª–µ–µ –º–Ω–æ–≥–æ—Å–ª–æ–≤–Ω–∞. –ú—ã –ø–æ–º–µ—â–∞–µ–º –æ–±—ä—è–≤–ª–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –æ–±–æ–±—â—ë–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞ —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ–º –ø–æ —Ç—Ä–µ–π—Ç—É –ø–æ—Å–ª–µ –¥–≤–æ–µ—Ç–æ—á–∏—è –≤–Ω—É—Ç—Ä–∏ —É–≥–ª–æ–≤—ã—Ö —Å–∫–æ–±–æ–∫.</p>
<p>–°–∏–Ω—Ç–∞–∫—Å–∏—Å <code>impl Trait</code> —É–¥–æ–±–µ–Ω, –æ–Ω –±–æ–ª–µ–µ –∫–æ—Ä–æ—Ç–∫–æ –≤—ã—Ä–∞–∂–∞–µ—Ç –Ω—É–∂–Ω–æ–µ –≤ –ø—Ä–æ—Å—Ç—ã—Ö —Å–ª—É—á–∞—Ö, –≤ —Ç–æ –≤—Ä–µ–º—è –∫–∞–∫ –±–æ–ª–µ–µ –ø–æ–ª–Ω—ã–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ–º –ø–æ —Ç—Ä–µ–π—Ç–∞–º –º–æ–∂–µ—Ç –≤—ã—Ä–∞–∑–∏—Ç—å –±–æ–ª—å—à—É—é —Å–ª–æ–∂–Ω–æ—Å—Ç—å –ø—Ä–æ—á–∏—Ö —Å–ª—É—á–∞–µ–≤. –ù–∞–ø—Ä–∏–º–µ—Ä, —É –Ω–∞—Å –º–æ–∂–µ—Ç –±—ã—Ç—å –¥–≤–∞ –∞—Ä–≥—É–º–µ–Ω—Ç–∞, –∫–æ—Ç–æ—Ä—ã–µ —Ä–µ–∞–ª–∏–∑—É—é—Ç —Ç—Ä–µ–π—Ç <code>Summary</code>. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –¥–ª—è —ç—Ç–æ–≥–æ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞ <code>impl Trait</code> –≤—ã–≥–ª—è–¥–∏—Ç —Ç–∞–∫:</p>
<pre><code class="language-rust ignore">pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {</code></pre>
<p>–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å <code>impl Trait</code> —É–¥–æ–±–Ω–µ–µ, –µ—Å–ª–∏ –º—ã —Ö–æ—Ç–∏–º —Ä–∞–∑—Ä–µ—à–∏—Ç—å —Ñ—É–Ω–∫—Ü–∏–∏ –∏–º–µ—Ç—å —Ä–∞–∑–Ω—ã–µ —Ç–∏–ø—ã –¥–ª—è <code>item1</code> –∏ <code>item2</code> (–Ω–æ –æ–±–∞ —Ç–∏–ø–∞ –¥–æ–ª–∂–Ω—ã —Ä–µ–∞–ª–∏–∑–æ–≤—ã–≤–∞—Ç—å <code>Summary</code>). –ï—Å–ª–∏ –∂–µ –º—ã —Ö–æ—Ç–∏–º –∑–∞—Å—Ç–∞–≤–∏—Ç—å –æ–±–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –∏–º–µ—Ç—å –æ–¥–∏–Ω –∏ —Ç–æ—Ç –∂–µ —Ç–∏–ø, —Ç–æ –Ω–∞–º —Å–ª–µ–¥—É–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤–æ—Ç —Ç–∞–∫–æ–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ —Ç—Ä–µ–π—Ç—É:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {</code></pre>
<p>–û–±–æ–±—â—ë–Ω–Ω—ã–π —Ç–∏–ø <code>T</code> —É–∫–∞–∑–∞–Ω –¥–ª—è —Ç–∏–ø–æ–≤ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ <code>item1</code> –∏ <code>item2</code> –∏ –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ—Ç —Ñ—É–Ω–∫—Ü–∏—é —Ç–∞–∫, —á—Ç–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è —Ç–∏–ø–æ–≤ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ <code>item1</code> –∏ <code>item2</code> –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –æ–¥–∏–Ω–∞–∫–æ–≤—ã–º–∏.</p>
<h4 id="–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ-–ø–æ-–Ω–µ—Å–∫–æ–ª—å–∫–∏–º-—Ç—Ä–µ–π—Ç–∞–º-—Å-–ø–æ–º–æ—â—å—é-–æ–ø–µ—Ä–∞—Ç–æ—Ä–∞-"><a class="header" href="#–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ-–ø–æ-–Ω–µ—Å–∫–æ–ª—å–∫–∏–º-—Ç—Ä–µ–π—Ç–∞–º-—Å-–ø–æ–º–æ—â—å—é-–æ–ø–µ—Ä–∞—Ç–æ—Ä–∞-">–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ –Ω–µ—Å–∫–æ–ª—å–∫–∏–º —Ç—Ä–µ–π—Ç–∞–º —Å –ø–æ–º–æ—â—å—é –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ <code>+</code></a></h4>
<p>–ú—ã —Ç–∞–∫–∂–µ –º–æ–∂–µ–º —É–∫–∞–∑–∞—Ç—å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ –±–æ–ª–µ–µ —á–µ–º –æ–¥–Ω–æ–º—É —Ç—Ä–µ–π—Ç—É. –î–æ–ø—É—Å—Ç–∏–º, –º—ã —Ö–æ—Ç–∏–º, —á—Ç–æ–±—ã —Ñ—É–Ω–∫—Ü–∏—è <code>notify</code> –º–æ–≥–ª–∞ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Å–≤–µ–æ–≥–æ –∞—Ä–≥—É–º–µ–Ω—Ç–∞ –∏ –≤—ã–≤–æ–¥–∏—Ç—å –Ω–∞ —ç–∫—Ä–∞–Ω —Ü–µ–ª–∏–∫–æ–º, –∏ –ø–æ–ª—É—á–∞—Ç—å –µ–≥–æ —Å–≤–æ–¥–∫—É —Å –ø–æ–º–æ—â—å—é –º–µ—Ç–æ–¥–∞ <code>summarize</code>. –î–ª—è —ç—Ç–æ–≥–æ –º—ã —É–∫–∞–∑—ã–≤–∞–µ–º, —á—Ç–æ –ø–∞—Ä–∞–º–µ—Ç—Ä <code>item</code> —Ñ—É–Ω–∫—Ü–∏–∏ <code>notify</code> –¥–æ–ª–∂–µ–Ω —Ä–µ–∞–ª–∏–∑–æ–≤—ã–≤–∞—Ç—å –¥–≤–∞ —Ç—Ä–µ–π—Ç–∞: <code>Display</code> –∏ <code>Summary</code>. –≠—Ç–æ –¥–µ–ª–∞–µ—Ç—Å—è —Å –ø–æ–º–æ—â—å—é –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ <code>+</code>:</p>
<pre><code class="language-rust ignore">pub fn notify(item: &amp;(impl Summary + Display)) {</code></pre>
<p>–û–ø–µ—Ä–∞—Ç–æ—Ä <code>+</code> —Ç–∞–∫–∂–µ –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏ –¥–ª—è –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –æ–±–æ–±—â—ë–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞ –ø–æ –µ–≥–æ —Ç—Ä–µ–π—Ç–∞–º:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {</code></pre>
<p>–ü–æ—Å–∫–æ–ª—å–∫—É –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ –¥–≤—É–º —Ç—Ä–µ–π—Ç–∞–º –ø—Ä–µ–¥–ø–∏—Å—ã–≤–∞–µ—Ç –∞—Ä–≥—É–º–µ–Ω—Ç—É —Ä–µ–∞–ª–∏–∑–æ–≤—ã–≤–∞—Ç—å –æ–±–∞ —Ç—Ä–µ–π—Ç–∞, —Ç–µ–ª–æ —Ñ—É–Ω–∫—Ü–∏–∏ <code>notify</code> –º–æ–∂–µ—Ç –∏ –≤—ã–∑—ã–≤–∞—Ç—å <code>summarize</code>, –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å <code>{}</code> –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è <code>item</code> –≤ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–º –≤—ã–≤–æ–¥–µ.</p>
<h4 id="–í—ã–Ω–æ—Å-–∑–∞-where-–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π-–ø–æ-—Ç—Ä–µ–π—Ç–∞–º"><a class="header" href="#–í—ã–Ω–æ—Å-–∑–∞-where-–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π-–ø–æ-—Ç—Ä–µ–π—Ç–∞–º">–í—ã–Ω–æ—Å –∑–∞ <code>where</code> –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π –ø–æ —Ç—Ä–µ–π—Ç–∞–º</a></h4>
<p>–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π –ø–æ —Ç—Ä–µ–π—Ç–∞–º –∏–º–µ–µ—Ç —Å–≤–æ–∏ –Ω–µ–¥–æ—Å—Ç–∞—Ç–∫–∏. –ö–∞–∂–¥—ã–π –æ–±–æ–±—â—ë–Ω–Ω—ã–π —Ç–∏–ø –∏–º–µ–µ—Ç —Å–≤–æ–∏ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –ø–æ —Ç—Ä–µ–π—Ç–∞–º, –ø–æ—ç—Ç–æ–º—É —Ñ—É–Ω–∫—Ü–∏–∏ —Å –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ –æ–±–æ–±—â—ë–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞ –º–æ–≥—É—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å –æ—á–µ–Ω—å –º–Ω–æ–≥–æ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è—Ö –º–µ–∂–¥—É –Ω–∞–∑–≤–∞–Ω–∏–µ–º —Ñ—É–Ω–∫—Ü–∏–∏ –∏ —Å–ø–∏—Å–∫–æ–º –µ—ë –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤, —á—Ç–æ –∑–∞—Ç—Ä—É–¥–Ω—è–µ—Ç —á—Ç–µ–Ω–∏–µ –µ—ë —Å–∏–≥–Ω–∞—Ç—É—Ä—ã. –ü–æ —ç—Ç–æ–π –ø—Ä–∏—á–∏–Ω–µ –≤ Rust –µ—Å—Ç—å –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π –ø–æ —Ç—Ä–µ–π—Ç–∞–º: —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ –∏—Ö –∑–∞ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–æ–º <code>where</code> –ø–æ—Å–ª–µ —Å–∏–≥–Ω–∞—Ç—É—Ä—ã —Ñ—É–Ω–∫—Ü–∏–∏. –ü–æ—ç—Ç–æ–º—É –≤–º–µ—Å—Ç–æ —Ç–æ–≥–æ, —á—Ç–æ–±—ã –ø–∏—Å–∞—Ç—å —Ç–∞–∫:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {</code></pre>
<p>–º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å <code>where</code>, –≤–æ—Ç —Ç–∞–∫:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
where
    T: Display + Clone,
    U: Clone + Debug,
{
<span class="boring">    unimplemented!()
</span><span class="boring">}</span></code></pre>
<p>–°–∏–≥–Ω–∞—Ç—É—Ä–∞ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –º–µ–Ω–µ–µ –∑–∞–≥—Ä–æ–º–æ–∂–¥–µ–Ω–∞: –Ω–∞–∑–≤–∞–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏, —Å–ø–∏—Å–æ–∫ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤, –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—ã–π —Ç–∏–ø –Ω–∞—Ö–æ–¥—è—Ç—Å—è —Ä—è–¥–æ–º, –∞ —Å–∏–≥–Ω–∞—Ç—É—Ä–∞ –Ω–µ –∑–∞–≥—Ä–æ–º–æ–∂–¥–µ–Ω–∞ –æ–≥–æ–≤–æ—Ä–∫–∞–º–∏ –ø—Ä–æ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –ø–æ —Ç—Ä–µ–π—Ç–∞–º.</p>
<h3 id="–í–æ–∑–≤—Ä–∞—Ç-–∑–Ω–∞—á–µ–Ω–∏–π-—Ç–∏–ø–∞-—Ä–µ–∞–ª–∏–∑—É—é—â–µ–≥–æ-–æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã–µ-—Ç—Ä–µ–π—Ç—ã"><a class="header" href="#–í–æ–∑–≤—Ä–∞—Ç-–∑–Ω–∞—á–µ–Ω–∏–π-—Ç–∏–ø–∞-—Ä–µ–∞–ª–∏–∑—É—é—â–µ–≥–æ-–æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã–µ-—Ç—Ä–µ–π—Ç—ã">–í–æ–∑–≤—Ä–∞—Ç –∑–Ω–∞—á–µ–Ω–∏–π —Ç–∏–ø–∞, —Ä–µ–∞–ª–∏–∑—É—é—â–µ–≥–æ –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã–µ —Ç—Ä–µ–π—Ç—ã</a></h3>
<p>–¢–∞–∫–∂–µ –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∑–∞–ø–∏—Å—å <code>impl Trait</code> –≤–º–µ—Å—Ç–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Ç–∏–ø–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è –≤ —Å–∏–≥–Ω–∞—Ç—É—Ä–µ —Ñ—É–Ω–∫—Ü–∏–∏, —á—Ç–æ–±—ã –≤–µ—Ä–Ω—É—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–µ–∫–æ—Ç–æ—Ä–æ–≥–æ —Ç–∏–ø–∞, —Ä–µ–∞–ª–∏–∑—É—é—â–µ–≥–æ —Ç—Ä–µ–π—Ç:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{} ({} –∏–∑ {})", self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable() -&gt; impl Summary {
    Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "–∫–æ–Ω–µ—á–Ω–æ, –≤—ã —É–∂–µ –Ω–∞–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞–µ—Ç–µ, –Ω–∞—Ä–æ–¥, ...",
        ),
        reply: false,
        retweet: false,
    }
}</code></pre>
<p>–ò—Å–ø–æ–ª—å–∑—É—è <code>impl Summary</code> –¥–ª—è —Ç–∏–ø–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è, –º—ã —É–∫–∞–∑—ã–≤–∞–µ–º, —á—Ç–æ —Ñ—É–Ω–∫—Ü–∏—è <code>returns_summarizable</code> –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –Ω–µ–∫–æ—Ç–æ—Ä—ã–π —Ç–∏–ø, –∫–æ—Ç–æ—Ä—ã–π —Ä–µ–∞–ª–∏–∑—É–µ—Ç —Ç—Ä–µ–π—Ç <code>Summary</code>, –Ω–µ –æ–±–æ–∑–Ω–∞—á–∞—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —Ç–∏–ø. –í —ç—Ç–æ–º —Å–ª—É—á–∞–µ <code>returns_summarizable</code> –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç <code>Tweet</code>, –Ω–æ –∫–æ–¥, –≤—ã–∑—ã–≤–∞—é—â–∏–π —ç—Ç—É —Ñ—É–Ω–∫—Ü–∏—é, —ç—Ç–æ–≥–æ –Ω–µ –∑–Ω–∞–µ—Ç.</p>
<p>–í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å —Ç–∏–ø, –∫–æ—Ç–æ—Ä—ã–π –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ —Ä–µ–∞–ª–∏–∑—É–µ–º—ã–º –∏–º —Ç—Ä–µ–π—Ç–æ–º, –æ—Å–æ–±–µ–Ω–Ω–æ –ø–æ–ª–µ–∑–Ω–∞ –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ –∑–∞–º—ã–∫–∞–Ω–∏–π –∏ –∏—Ç–µ—Ä–∞—Ç–æ—Ä–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –º—ã —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º –≤ –ì–ª–∞–≤–µ 13. –ó–∞–º—ã–∫–∞–Ω–∏—è –∏ –∏—Ç–µ—Ä–∞—Ç–æ—Ä—ã —Å–æ–∑–¥–∞—é—Ç —Ç–∏–ø—ã, –∫–æ—Ç–æ—Ä—ã–µ –∑–Ω–∞–µ—Ç —Ç–æ–ª—å–∫–æ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä, –∏–ª–∏ –∂–µ —Ç–∏–ø—ã, –∫–æ—Ç–æ—Ä—ã–µ –æ—á–µ–Ω—å –¥–æ–ª–≥–æ —É–∫–∞–∑—ã–≤–∞—Ç—å. –ó–∞–ø–∏—Å—å <code>impl Trait</code> –ø–æ–∑–≤–æ–ª—è–µ—Ç –∫—Ä–∞—Ç–∫–æ —É–∫–∞–∑–∞—Ç—å, —á—Ç–æ —Ñ—É–Ω–∫—Ü–∏—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –Ω–µ–∫–æ—Ç–æ—Ä—ã–π —Ç–∏–ø, –∫–æ—Ç–æ—Ä—ã–π —Ä–µ–∞–ª–∏–∑—É–µ—Ç —Ç—Ä–µ–π—Ç <code>Iterator</code> –±–µ–∑ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –ø–∏—Å–∞—Ç—å –æ—á–µ–Ω—å –¥–ª–∏–Ω–Ω—ã–π —Ç–∏–ø.</p>
<p>–û–¥–Ω–∞–∫–æ, <code>impl Trait</code> –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å, —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Ñ—É–Ω–∫—Ü–∏—è –≤—Å–µ–≥–¥–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ –æ–¥–Ω–æ–≥–æ —Ç–∏–ø–∞. –ù–∞–ø—Ä–∏–º–µ—Ä, –¥–∞–Ω–Ω—ã–π –∫–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ –∏–ª–∏ —Ç–∏–ø–∞ <code>NewsArticle</code>, –∏–ª–∏ —Ç–∏–ø–∞ <code>Tweet</code>, –Ω–æ –≤ –∫–∞—á–µ—Å—Ç–≤–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–≥–æ —Ç–∏–ø–∞ –æ–±—ä—è–≤–ª—è–µ—Ç <code>impl Summary</code>, –Ω–µ –±—É–¥–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{} ({} –∏–∑ {})", self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable(switch: bool) -&gt; impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                "¬´–ü–∏—Ç—Ç—Å–±—É—Ä–≥ –ü–∏–Ω–≥–≤–∏–Ω–∑¬ª –≤—ã–∏–≥—Ä–∞–ª–∏ –ö—É–±–æ–∫ –°—Ç—ç–Ω–ª–∏!",
            ),
            location: String::from("–ü–∏—Ç—Ç—Å–±—É—Ä–≥, —à—Ç–∞—Ç –ü–µ–Ω—Å–∏–ª—å–≤–∞–Ω–∏—è, –°–®–ê"),
            author: String::from("–ü–∏–Ω–≥–≤–∏–Ω –ê–π—Å–±—É—Ä–≥"),
            content: String::from(
                "¬´–ü–∏—Ç—Ç—Å–±—É—Ä–≥ –ü–∏–Ω–≥–≤–∏–Ω–∑¬ª –≤–Ω–æ–≤—å –æ–∫–∞–∑–∞–ª–∞—Å—å –ª—É—á—à–µ–π \
                 —Ö–æ–∫–∫–µ–π–Ω–æ–π –∫–æ–º–∞–Ω–¥–æ–π –≤ –ù–•–õ.",
            ),
        }
    } else {
        Tweet {
            username: String::from("horse_ebooks"),
            content: String::from(
                "–∫–æ–Ω–µ—á–Ω–æ, –≤—ã —É–∂–µ –Ω–∞–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞–µ—Ç–µ, –Ω–∞—Ä–æ–¥, ...",
            ),
            reply: false,
            retweet: false,
        }
    }
}</code></pre>
<p>–ù–µ–æ–¥–Ω–æ–∑–Ω–∞—á–Ω–æ—Å—Ç—å –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–≥–æ —Ç–∏–ø–∞ –Ω–µ –¥–æ–ø—É—Å—Ç–∏–º–∞ –∏–∑-–∑–∞ —Ç–æ–≥–æ, –∫–∞–∫ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å <code>impl Trait</code> —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω –≤ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–µ. –ú—ã —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º, –∫–∞–∫ (–≤—Å—ë –∂–µ) –Ω–∞–ø–∏—Å–∞—Ç—å —Ñ—É–Ω–∫—Ü–∏—é —Å –ø–æ–¥–æ–±–Ω—ã–º –ø–æ–≤–µ–¥–µ–Ω–∏–µ–º –≤ —Ä–∞–∑–¥–µ–ª–µ <a href="ch18-02-trait-objects.html#%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%82%D1%80%D0%B5%D0%B9%D1%82-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2-%D0%BF%D0%BE%D0%B7%D0%B2%D0%BE%D0%BB%D1%8F%D1%8E%D1%89%D0%B8%D1%85-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D1%80%D0%B0%D0%B7%D0%BD%D1%8B%D1%85-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2">"–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Ç—Ä–µ–π—Ç-–æ–±—ä–µ–∫—Ç–æ–≤, –ø–æ–∑–≤–æ–ª—è—é—â–∏—Ö –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤"</a><!-- ignore --> –ì–ª–∞–≤—ã 18.</p>
<h3 id="–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ-–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π-–ø–æ-—Ç—Ä–µ–π—Ç—É-–¥–ª—è-–∏–∑–±–∏—Ä–∞—Ç–µ–ª—å–Ω–æ–π-—Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏-–º–µ—Ç–æ–¥–æ–≤"><a class="header" href="#–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ-–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π-–ø–æ-—Ç—Ä–µ–π—Ç—É-–¥–ª—è-–∏–∑–±–∏—Ä–∞—Ç–µ–ª—å–Ω–æ–π-—Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏-–º–µ—Ç–æ–¥–æ–≤">–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π –ø–æ —Ç—Ä–µ–π—Ç—É –¥–ª—è –∏–∑–±–∏—Ä–∞—Ç–µ–ª—å–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –º–µ—Ç–æ–¥–æ–≤</a></h3>
<p>–û–≥—Ä–∞–Ω–∏—á–∏–≤ –ø–æ —Ç—Ä–µ–π—Ç—É –æ–±–æ–±—â—ë–Ω–Ω—ã–π —Ç–∏–ø –ø—Ä–∏ –±–ª–æ–∫–µ <code>impl</code>, –º—ã –º–æ–∂–µ–º –∏–∑–±–∏—Ä–∞—Ç–µ–ª—å–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –º–µ—Ç–æ–¥—ã –¥–ª—è —Ç–µ—Ö —Ç–∏–ø–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ —Ä–µ–∞–ª–∏–∑—É—é—Ç —É–∫–∞–∑–∞–Ω–Ω—ã–µ —Ç—Ä–µ–π—Ç—ã. –ù–∞–ø—Ä–∏–º–µ—Ä, —Ç–∏–ø <code>Pair&lt;T&gt;</code> –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 10-15 –≤—Å–µ–≥–¥–∞ —Ä–µ–∞–ª–∏–∑—É–µ—Ç —Ñ—É–Ω–∫—Ü–∏—é <code>new</code>, –≤–æ–∑–≤—Ä–∞—â–∞—é—â—É—é –Ω–æ–≤—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä <code>Pair&lt;T&gt;</code> (–Ω–∞–ø–æ–º–Ω–∏–º –∏–∑ —Ä–∞–∑–¥–µ–ª–∞ <a href="ch05-03-method-syntax.html#%D0%9E%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%BE%D0%B2">"–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –º–µ—Ç–æ–¥–æ–≤"</a><!-- ignore --> –ì–ª–∞–≤—ã 5, —á—Ç–æ <code>Self</code> ‚Äî —ç—Ç–æ –ø—Å–µ–≤–¥–æ–Ω–∏–º —Ç–∏–ø–∞ –ø—Ä–∏ –±–ª–æ–∫–µ <code>impl</code>; –≤ –Ω–∞—à–µ–º —Å–ª—É—á–∞–µ —ç—Ç–∏–º —Ç–∏–ø–æ–º —è–≤–ª—è–µ—Ç—Å—è <code>Pair&lt;T&gt;</code>). –ù–æ –≤ —Å–ª–µ–¥—É—é—â–µ–º –±–ª–æ–∫–µ <code>impl Pair&lt;T&gt;</code> —Ä–µ–∞–ª–∏–∑—É–µ—Ç –º–µ—Ç–æ–¥ <code>cmp_display</code> —Ç–æ–ª—å–∫–æ –≤ —Ç–æ–º —Å–ª—É—á–∞–µ, –µ—Å–ª–∏ –µ–≥–æ —Ç–∏–ø <code>T</code> —Ä–µ–∞–ª–∏–∑—É–µ—Ç —Ç—Ä–µ–π—Ç <code>PartialOrd</code> (–∫–æ—Ç–æ—Ä—ã–π –ø–æ–∑–≤–æ–ª—è–µ—Ç —Å—Ä–∞–≤–Ω–∏–≤–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è), –∏ —Ç—Ä–µ–π—Ç <code>Display</code> (–∫–æ—Ç–æ—Ä—ã–π –ø–æ–∑–≤–æ–ª—è–µ—Ç –ø–µ—á–∞—Ç–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è).</p>
<Listing number="10-15" file-name="src/lib.rs" caption="Conditionally implementing methods on a generic type depending on trait bounds">
<pre><code class="language-rust noplayground">use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self { x, y }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!("–°–ª–µ–≤–∞ ({}) ‚Äî –Ω–∞–∏–±–æ–ª—å—à–µ–µ", self.x);
        } else {
            println!("–°–ø—Ä–∞–≤–∞ ({}) ‚Äî –Ω–∞–∏–±–æ–ª—å—à–µ–µ", self.y);
        }
    }
}</code></pre>
</Listing>
<p>–ú—ã —Ç–∞–∫–∂–µ –º–æ–∂–µ–º –∏–∑–±–∏—Ä–∞—Ç–µ–ª—å–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Ç—Ä–µ–π—Ç –¥–ª—è –≤—Å–µ—Ö —Ç–∏–ø–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ —Ä–µ–∞–ª–∏–∑—É—é—Ç –¥—Ä—É–≥–æ–π —Ç—Ä–µ–π—Ç. –†–µ–∞–ª–∏–∑–∞—Ü–∏—è —Ç—Ä–µ–π—Ç–∞ –¥–ª—è –≤—Å–µ—Ö —Ç–∏–ø–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ —É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä—è—é—Ç –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è–º –ø–æ —Ç—Ä–µ–π—Ç–∞–º, –Ω–∞–∑—ã–≤–∞—é—Ç—Å—è <em>—Å–ø–ª–æ—à–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–µ–π</em>, –∏ –æ–Ω–∞ —à–∏—Ä–æ–∫–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–µ Rust. –ù–∞–ø—Ä–∏–º–µ—Ä, —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ —Ä–µ–∞–ª–∏–∑—É–µ—Ç —Ç—Ä–µ–π—Ç <code>ToString</code> –¥–ª—è –≤—Å–µ—Ö —Ç–∏–ø–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ —Ä–µ–∞–ª–∏–∑—É—é—Ç —Ç—Ä–µ–π—Ç <code>Display</code>. –ë–ª–æ–∫ <code>impl</code>, –¥–µ–ª–∞—é—â–∏–π —ç—Ç–æ, –≤—ã–≥–ª—è–¥–∏—Ç –ø—Ä–∏–º–µ—Ä–Ω–æ —Ç–∞–∫:</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
}</code></pre>
<p>–ë–ª–∞–≥–æ–¥–∞—Ä—è —Ç–∞–∫–æ–π —Å–ø–ª–æ—à–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –º–æ–∂–Ω–æ –≤—ã–∑–≤–∞—Ç—å –º–µ—Ç–æ–¥ <code>to_string</code>, –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã–π —Ç—Ä–µ–π—Ç–æ–º <code>ToString</code>, –¥–ª—è –ª—é–±–æ–≥–æ —Ç–∏–ø–∞, –∫–æ—Ç–æ—Ä—ã–π —Ä–µ–∞–ª–∏–∑—É–µ—Ç —Ç—Ä–µ–π—Ç <code>Display</code>. –ù–∞–ø—Ä–∏–º–µ—Ä, –º—ã –º–æ–∂–µ–º –ø—Ä–µ–≤—Ä–∞—Ç–∏—Ç—å —Ü–µ–ª—ã–µ —á–∏—Å–ª–∞ –≤ –∏—Ö —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è <code>String</code>, –ø–æ—Ç–æ–º—É —á—Ç–æ —Ü–µ–ª—ã–µ —á–∏—Å–ª–∞ —Ä–µ–∞–ª–∏–∑—É—é—Ç —Ç—Ä–µ–π—Ç <code>Display</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = 3.to_string();
<span class="boring">}</span></code></pre></pre>
<p>–í –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ –∫ —Ç—Ä–µ–π—Ç–∞–º, –∏—Ö —Å–ø–ª–æ—à–Ω—ã–µ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –º–æ–∂–Ω–æ —É–≤–∏–¥–µ—Ç—å –≤ —Ä–∞–∑–¥–µ–ª–µ "Implementors".</p>
<p>–¢—Ä–µ–π—Ç—ã –∏ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –ø–æ —Ç—Ä–µ–π—Ç–∞–º –ø–æ–∑–≤–æ–ª—è—é—Ç –Ω–∞–º –ø–∏—Å–∞—Ç—å –±–æ–ª–µ–µ –∞–±—Å—Ç—Ä–∞–∫—Ç–Ω—ã–π –∫–æ–¥ —Å –ø–æ–º–æ—â—å—é –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –æ–±–æ–±—â—ë–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞, –∞ —Ç–∞–∫–∂–µ –ø–æ–∑–≤–æ–ª—è—é—Ç —É–∫–∞–∑–∞—Ç—å –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä—É, —á—Ç–æ –º—ã —Ö–æ—Ç–∏–º, —á—Ç–æ–±—ã —É –æ–±–æ–±—â—ë–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞ –±—ã–ª–æ –æ–ø—Ä–µ–¥—ë–ª–µ–Ω–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ. –ó–∞—Ç–µ–º –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –º–æ–∂–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è—Ö –ø–æ —Ç—Ä–µ–π—Ç–∞–º, —á—Ç–æ–±—ã –ø—Ä–æ–≤–µ—Ä–∏—Ç—å, —á—Ç–æ –≤—Å–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ —Ç–∏–ø—ã, –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–µ –≤ –Ω–∞—à–µ–º –∫–æ–¥–µ, —Ä–µ–∞–ª–∏–∑—É—é—Ç –Ω—É–∂–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ. –í —è–∑—ã–∫–∞—Ö —Å –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–π —Ç–∏–ø–∏–∑–∞—Ü–∏–µ–π –º—ã –ø–æ–ª—É—á–∏–ª–∏ –±—ã –æ—à–∏–±–∫—É –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è, –µ—Å–ª–∏ –±—ã –≤—ã–∑–≤–∞–ª–∏ –º–µ—Ç–æ–¥ –¥–ª—è —Ç–∏–ø–∞, –≤ –∫–æ—Ç–æ—Ä–æ–º —ç—Ç–æ—Ç –º–µ—Ç–æ–¥ –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω. –ù–æ Rust –ø–µ—Ä–µ–Ω–æ—Å–∏—Ç —ç—Ç–∏ –æ—à–∏–±–∫–∏ –Ω–∞ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏, –∞ –ø–æ—Ç–æ–º—É –æ–Ω –æ–±—è–∑—ã–≤–∞–µ—Ç –Ω–∞—Å —É—Å—Ç—Ä–∞–Ω—è—Ç—å –ø—Ä–æ–±–ª–µ–º—ã –µ—â—ë –¥–æ —Ç–æ–≥–æ, –∫–∞–∫ –∫–æ–¥ –±—É–¥–µ—Ç –∑–∞–ø—É—â–µ–Ω. –ö—Ä–æ–º–µ —Ç–æ–≥–æ, –Ω–∞–º –Ω–µ –Ω—É–∂–Ω–æ –ø–∏—Å–∞—Ç—å –∫–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –ø–æ–≤–µ–¥–µ–Ω–∏–µ –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è, –ø–æ—Ç–æ–º—É —á—Ç–æ –º—ã —É–∂–µ –ø—Ä–æ–≤–µ—Ä–∏–ª–∏ –µ–≥–æ –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏. –≠—Ç–æ –ø–æ–≤—ã—à–∞–µ—Ç –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –±–µ–∑ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –æ—Ç–∫–∞–∑—ã–≤–∞—Ç—å—Å—è –æ—Ç –≥–∏–±–∫–æ—Å—Ç–∏ –æ–±–æ–±—â—ë–Ω–Ω—ã—Ö —Ç–∏–ø–æ–≤, —Ñ—É–Ω–∫—Ü–∏–π –∏ –º–µ—Ç–æ–¥–æ–≤.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–í–∞–ª–∏–¥–∞—Ü–∏—è-—Å—Å—ã–ª–æ–∫-–ø–æ-–≤—Ä–µ–º–µ–Ω–∏-–∂–∏–∑–Ω–∏"><a class="header" href="#–í–∞–ª–∏–¥–∞—Ü–∏—è-—Å—Å—ã–ª–æ–∫-–ø–æ-–≤—Ä–µ–º–µ–Ω–∏-–∂–∏–∑–Ω–∏">–í–∞–ª–∏–¥–∞—Ü–∏—è —Å—Å—ã–ª–æ–∫ –ø–æ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏</a></h2>
<p>–í—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏ ‚Äî —ç—Ç–æ –µ—â—ë –æ–¥–∏–Ω –≤–∏–¥ –æ–±–æ–±—â–µ–Ω–∏–π, —Å –∫–æ—Ç–æ—Ä—ã–º–∏ –º—ã —É–∂–µ –≤—Å—Ç—Ä–µ—á–∞–ª–∏—Å—å. –ï—Å–ª–∏ —Ä–∞–Ω—å—à–µ –º—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ –æ–±–æ–±—â–µ–Ω–∏—è, —á—Ç–æ–±—ã —É–±–µ–¥–∏—Ç—å—Å—è, —á—Ç–æ —Ç–∏–ø –æ–±–ª–∞–¥–∞–µ—Ç –Ω—É–∂–Ω—ã–º –Ω–∞–º –ø–æ–≤–µ–¥–µ–Ω–∏–µ–º, —Ç–æ —Ç–µ–ø–µ—Ä—å –º—ã –±—É–¥–µ–º –∏—Ö –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å, —á—Ç–æ–±—ã —É–±–µ–¥–∏—Ç—å—Å—è, —á—Ç–æ —Å—Å—ã–ª–∫–∏ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã —Å—Ç–æ–ª—å–∫–æ, —Å–∫–æ–ª—å–∫–æ —Ç—Ä–µ–±—É–µ—Ç—Å—è.</p>
<p>–í —Ä–∞–∑–¥–µ–ª–µ ["–°—Å—ã–ª–∫–∏ –∏ –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–µ"](ch04-02-references-and-borrowing.html #–°—Å—ã–ª–∫–∏-–∏-–∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–µ)<!-- ignore --> –ì–ª–∞–≤—ã 4 –º—ã –∫–æ–µ –æ —á—ë–º —É–º–æ–ª—á–∞–ª–∏: —É –∫–∞–∂–¥–æ–π —Å—Å—ã–ª–∫–∏ –≤ Rust –µ—Å—Ç—å —Å–≤–æ—ë <em>–≤—Ä–µ–º—è –∂–∏–∑–Ω–∏</em> ‚Äî –ø—Ä–æ–º–µ–∂—É—Ç–æ–∫ –ø—Ä–æ–≥—Ä–∞–º–º—ã, –≤ –∫–æ—Ç–æ—Ä–æ–º –¥–∞–Ω–Ω–∞—è —Å—Å—ã–ª–∫–∞ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞. –í –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–µ —Å–ª—É—á–∞–µ–≤ –≤—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏ –≤—ã–≤–æ–¥—è—Ç—Å—è –Ω–µ—è–≤–Ω–æ ‚Äî —Ç–∞–∫ –∂–µ, –∫–∞–∫ –∏ —Ç–∏–ø—ã. –¢–æ—á–Ω–æ —Ç–∞–∫ –∂–µ –º—ã –¥–æ–ª–∂–Ω—ã —è–≤–Ω–æ –æ–±—ä—è–≤–ª—è—Ç—å –≤—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏ —Ç–µ—Ö —Å—Å—ã–ª–æ–∫, –∫–æ—Ç–æ—Ä—ã–µ –∫–æ–º–ø–ª—è—Ç–æ—Ä –Ω–µ –º–æ–∂–µ—Ç —Å–∞–º–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω–æ –æ–¥–Ω–æ–∑–Ω–∞—á–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å. Rust —Ç—Ä–µ–±—É–µ—Ç –æ—Ç –Ω–∞—Å –æ–±—ä—è–≤–ª—è—Ç—å –≤–∑–∞–∏–º–æ—Å–≤—è–∑–∏ –ø–æ—Å—Ä–µ–¥—Å—Ç–≤–æ–º –æ–±–æ–±—â—ë–Ω–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏, —á—Ç–æ–±—ã —É–±–µ–¥–∏—Ç—å—Å—è –≤ —Ç–æ–º, —á—Ç–æ –≤–æ –≤—Ä–µ–º—è –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è –≤—Å–µ –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–µ —Å—Å—ã–ª–∫–∏ –±—É–¥—É—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–º–∏.</p>
<p>–ê–Ω–Ω–æ—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏ ‚Äî —ç—Ç–æ –∫–æ–Ω—Ü–µ–ø—Ü–∏—è, –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∞—è –≤ –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–µ –¥—Ä—É–≥–∏—Ö —è–∑—ã–∫–æ–≤ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è, —Ç–∞–∫ —á—Ç–æ –æ–Ω–∞ –º–æ–∂–µ—Ç –ø–æ–∫–∞–∑–∞—Ç—å—Å—è –Ω–µ—è—Å–Ω–æ–π. –•–æ—Ç—è –≤ —ç—Ç–æ–π –≥–ª–∞–≤–µ –º—ã –Ω–µ –±—É–¥–µ–º —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞—Ç—å –≤—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏ –≤–æ –≤—Å–µ—Ö –¥–µ—Ç–∞–ª—è—Ö, —Ç–µ–º –Ω–µ –º–µ–Ω–µ–µ, –º—ã –æ–±—Å—É–¥–∏–º –æ—Å–Ω–æ–≤–Ω—ã–µ —Å–∏—Ç—É–∞—Ü–∏–∏, –≤ –∫–æ—Ç–æ—Ä—ã—Ö –≤—ã –º–æ–∂–µ—Ç–µ —Å—Ç–æ–ª–∫–Ω—É—Ç—å—Å—è —Å —Ä—É—á–Ω—ã–º —É–∫–∞–∑–∞–Ω–∏–µ–º –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏, —á—Ç–æ –ø–æ–∑–≤–æ–ª–∏—Ç –≤–∞–º –ø–æ–ª—É—á—à–µ –æ–∑–Ω–∞–∫–æ–º–∏—Ç—å—Å—è —Å —ç—Ç–æ–π –∫–æ–Ω—Ü–µ–ø—Ü–∏–µ–π.</p>
<h3 id="–ó–∞—â–∏—Ç–∞-–æ—Ç-–≤–∏—Å—è—á–∏—Ö-—Å—Å—ã–ª–æ–∫-—Å-–ø–æ–º–æ—â—å—é-–≤—Ä–µ–º—ë–Ω-–∂–∏–∑–Ω–∏"><a class="header" href="#–ó–∞—â–∏—Ç–∞-–æ—Ç-–≤–∏—Å—è—á–∏—Ö-—Å—Å—ã–ª–æ–∫-—Å-–ø–æ–º–æ—â—å—é-–≤—Ä–µ–º—ë–Ω-–∂–∏–∑–Ω–∏">–ó–∞—â–∏—Ç–∞ –æ—Ç –≤–∏—Å—è—á–∏—Ö —Å—Å—ã–ª–æ–∫ —Å –ø–æ–º–æ—â—å—é –≤—Ä–µ–º—ë–Ω –∂–∏–∑–Ω–∏</a></h3>
<p>–û—Å–Ω–æ–≤–Ω–æ–µ –ø—Ä–µ–¥–Ω–∞–∑–Ω–∞—á–µ–Ω–∏–µ –≤—Ä–µ–º—ë–Ω –∂–∏–∑–Ω–∏ ‚Äî –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞—Ç—å –ø–æ—è–≤–ª–µ–Ω–∏–µ —Ç–∞–∫ –Ω–∞–∑—ã–≤–∞–µ–º—ã—Ö <em>–≤–∏—Å—è—á–∏—Ö —Å—Å—ã–ª–æ–∫</em> ‚Äî —Å—Å—ã–ª–æ–∫, —É–∫–∞–∑—ã–≤–∞—é—â–∏—Ö –Ω–µ –Ω–∞ —Ç–µ –¥–∞–Ω–Ω—ã–µ, –Ω–∞ –∫–æ—Ç–æ—Ä—ã–µ –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–ª–æ—Å—å —É–∫–∞–∑—ã–≤–∞—Ç—å. –†–∞—Å—Å–º–æ—Ç—Ä–∏–º –ø—Ä–æ–≥—Ä–∞–º–º—É –∏–∑ –õ–∏—Å—Ç–∏–Ω–≥–∞ 10-16, –∏–º–µ—é—â—É—é –≤–Ω–µ—à–Ω—é—é –∏ –≤–Ω—É—Ç—Ä–µ–Ω–Ω—é—é –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏.</p>
<Listing number="10-16" caption="An attempt to use a reference whose value has gone out of scope">
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let r;

    {
        let x = 5;
        r = &amp;x;
    }

    println!("r: {r}");
}</code></pre>
</Listing>
<blockquote>
<p>–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: –ü—Ä–∏–º–µ—Ä—ã –≤ –õ–∏—Å—Ç–∏–Ω–≥–∞—Ö 10-16, 10-17 –∏ 10-23 –æ–±—ä—è–≤–ª—è—é—Ç –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –±–µ–∑ —É–∫–∞–∑–∞–Ω–∏—è –∏—Ö –Ω–∞—á–∞–ª—å–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è, –ø–æ—ç—Ç–æ–º—É –∏–º—è –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –≤–æ –≤–Ω–µ—à–Ω–µ–π –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏. –ù–∞ –ø–µ—Ä–≤—ã–π –≤–∑–≥–ª—è–¥ –º–æ–∂–µ—Ç –ø–æ–∫–∞–∑–∞—Ç—å—Å—è, —á—Ç–æ —ç—Ç–æ –ø—Ä–æ—Ç–∏–≤–æ—Ä–µ—á–∏—Ç –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—é –≤ Rust –∑–Ω–∞—á–µ–Ω–∏–π null. –û–¥–Ω–∞–∫–æ, –µ—Å–ª–∏ –º—ã –ø–æ–ø—ã—Ç–∞–µ–º—Å—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é, –ø—Ä–µ–∂–¥–µ —á–µ–º –ø—Ä–∏—Å–≤–æ–∏—Ç—å –µ–π –∑–Ω–∞—á–µ–Ω–∏–µ, –º—ã –ø–æ–ª—É—á–∏–º –æ—à–∏–±–∫—É –∫–æ–º–ø–∏–ª—è—Ü–∏–∏, –∫–æ—Ç–æ—Ä–∞—è –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç, —á—Ç–æ Rust –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –Ω–µ —Ä–∞–∑—Ä–µ—à–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏—è null.</p>
</blockquote>
<p>–í–Ω–µ—à–Ω—è—è –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ –æ–±—ä—è–≤–ª—è–µ—Ç –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é <code>r</code> –±–µ–∑ –Ω–∞—á–∞–ª—å–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è, –∞ –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ–±–ª–∞—Å—Ç—å –æ–±—ä—è–≤–ª—è–µ—Ç –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é <code>x</code> —Å –Ω–∞—á–∞–ª—å–Ω—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º <code>5</code>. –í–æ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–π –æ–±–ª–∞—Å—Ç–∏ –º—ã –ø—ã—Ç–∞–µ–º—Å—è —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ <code>r</code> –∫–∞–∫ —Å—Å—ã–ª–∫—É –Ω–∞ <code>x</code>. –ó–∞—Ç–µ–º –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∑–∞–∫–∞–Ω—á–∏–≤–∞–µ—Ç—Å—è, –∏ –º—ã –ø—ã—Ç–∞–µ–º—Å—è –Ω–∞–ø–µ—á–∞—Ç–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ <code>r</code>. –≠—Ç–æ—Ç –∫–æ–¥ –Ω–µ –±—É–¥–µ—Ç —Å–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞–Ω, –ø–æ—Ç–æ–º—É —á—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ, –Ω–∞ –∫–æ—Ç–æ—Ä–æ–µ —Å—Å—ã–ª–∞–µ—Ç—Å—è <code>r</code>, –∏—Å—á–µ–∑–∞–µ—Ç –∏–∑ –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏ —Ä–∞–Ω—å—à–µ, —á–µ–º –º—ã –ø—ã—Ç–∞–µ–º—Å—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –µ–≥–æ. –í–æ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
 --&gt; src/main.rs:6:13
  |
5 |         let x = 5;
  |             - binding `x` declared here
6 |         r = &amp;x;
  |             ^^ borrowed value does not live long enough
7 |     }
  |     - `x` dropped here while still borrowed
8 |
9 |     println!("r: {r}");
  |                  --- borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>–û—à–∏–±–∫–∞ —Å–æ–æ–±—â–∞–µ—Ç, —á—Ç–æ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è <code>x</code> "–∂–∏–≤—ë—Ç –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–æ–ª–≥–æ". –ü—Ä–∏—á–∏–Ω–∞ –≤ —Ç–æ–º, —á—Ç–æ <code>x</code> –≤—ã–π–¥–µ—Ç –∏–∑ –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏, –∫–æ–≥–¥–∞ —ç—Ç–∞ –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ–±–ª–∞—Å—Ç—å –∑–∞–∫–æ–Ω—á–∏—Ç—Å—è –≤ —Å—Ç—Ä–æ–∫–µ 7. –ù–æ <code>r</code> –≤—Å—ë –µ—â—ë –æ—Å—Ç–∞–Ω–µ—Ç—Å—è –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ–π –≤–æ –≤–Ω–µ—à–Ω–µ–π –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏; –ø–æ—Å–∫–æ–ª—å–∫—É –µ—ë –æ—Ö–≤–∞—Ç –±–æ–ª—å—à–µ, –º—ã –≥–æ–≤–æ—Ä–∏–º, —á—Ç–æ –æ–Ω–∞ "–∂–∏–≤—ë—Ç –¥–æ–ª—å—à–µ". –ï—Å–ª–∏ –±—ã Rust –ø–æ–∑–≤–æ–ª–∏–ª —Ç–∞–∫–æ–º—É –∫–æ–¥—É —Ä–∞–±–æ—Ç–∞—Ç—å, —Ç–æ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è <code>r</code> —Å–º–æ–≥–ª–∞ –±—ã —Å—Å—ã–ª–∞—Ç—å—Å—è –Ω–∞ –ø–∞–º—è—Ç—å, –∫–æ—Ç–æ—Ä–∞—è —É–∂–µ –±—ã–ª–∞ –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∞ (–≤ —Ç–æ—Ç –º–æ–º–µ–Ω—Ç, –∫–æ–≥–¥–∞ <code>x</code> –≤—ã—à–ª–∞ –∏–∑ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–π –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏), –∏ –≤—Å—ë, —á—Ç–æ –º—ã –ø–æ–ø—ã—Ç–∞–ª–∏—Å—å –±—ã —Å–¥–µ–ª–∞—Ç—å —Å <code>r</code>, —Ä–∞–±–æ—Ç–∞–ª–æ –±—ã –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ. –ö–∞–∫ –∂–µ Rust –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç, —á—Ç–æ —ç—Ç–æ—Ç –∫–æ–¥ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–µ–Ω? –û–Ω –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –¥–ª—è —ç—Ç–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–π.</p>
<h3 id="–ê–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä-–∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–π"><a class="header" href="#–ê–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä-–∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–π">–ê–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–π</a></h3>
<p>–ö–æ–º–ø–∏–ª—è—Ç–æ—Ä Rust –≤–∫–ª—é—á–∞–µ—Ç –≤ —Å–µ–±—è <em>–∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–π</em>, –∫–æ—Ç–æ—Ä—ã–π —Å—Ä–∞–≤–Ω–∏–≤–∞–µ—Ç –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏ –¥–ª—è —Ç–æ–≥–æ, —á—Ç–æ–±—ã –ø—Ä–æ–≤–µ—Ä–∏—Ç—å, —è–≤–ª—è—é—Ç—Å—è –ª–∏ –≤—Å–µ –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏—è –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–º–∏. –í –õ–∏—Å—Ç–∏–Ω–≥–µ 10-17 –ø–æ–∫–∞–∑–∞–Ω —Ç–æ—Ç –∂–µ –∫–æ–¥, —á—Ç–æ –∏ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 10-16, –Ω–æ —Å –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è–º–∏, –ø–æ–∫–∞–∑—ã–≤–∞—é—â–∏–º–∏ –≤—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö.</p>
<Listing number="10-17" caption="Annotations of the lifetimes of `r` and `x`, named `'a` and `'b`, respectively">
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let r;                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ 'a
                          //          ‚îÇ
    {                     //          ‚îÇ
        let x = 5;        // ‚îÅ‚î≥‚îÅ‚îÅ 'b  ‚îÇ
        r = &amp;x;           //  ‚îÉ       ‚îÇ
    }                     // ‚îÅ‚îõ       ‚îÇ
                          //          ‚îÇ
    println!("r: {r}");   //          ‚îÇ
}                         // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</code></pre>
</Listing>
<p>–í—Ä–µ–º—è –∂–∏–∑–Ω–∏ <code>r</code> –∑–¥–µ—Å—å —É–∫–∞–∑–∞–Ω–æ –∫–∞–∫ <code>'a</code>, –∞ <code>x</code> ‚Äî –∫–∞–∫ <code>'b</code>. –ö–∞–∫ –≤–∏–¥–∏—Ç–µ, –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ <code>'b</code> –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–≥–æ –±–ª–æ–∫–∞ –≥–æ—Ä–∞–∑–¥–æ –º–µ–Ω—å—à–µ, —á–µ–º –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ <code>'a</code> –≤–Ω–µ—à–Ω–µ–≥–æ –±–ª–æ–∫–∞. –í–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ Rust —Å—Ä–∞–≤–Ω–∏–≤–∞–µ—Ç –ø—Ä–æ–¥–æ–ª–∂–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –¥–≤—É—Ö –≤—Ä–µ–º—ë–Ω –∂–∏–∑–Ω–∏ –∏ –≤–∏–¥–∏—Ç, —á—Ç–æ <code>r</code> –∏–º–µ–µ—Ç –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ <code>'a</code>, –Ω–æ —Å—Å—ã–ª–∞–µ—Ç—Å—è –Ω–∞ –ø–∞–º—è—Ç—å —Å–æ –≤—Ä–µ–º–µ–Ω–µ–º –∂–∏–∑–Ω–∏ <code>'b</code>. –ü—Ä–æ–≥—Ä–∞–º–º–∞ –æ—Ç–±—Ä–∞–∫–æ–≤—ã–≤–∞–µ—Ç—Å—è, –ø–æ—Ç–æ–º—É —á—Ç–æ <code>'b</code> –∫–æ—Ä–æ—á–µ, —á–µ–º <code>'a</code>: –æ–±—ä–µ–∫—Ç —Å—Å—ã–ª–∫–∏ –Ω–µ –∂–∏–≤—ë—Ç —Ç–∞–∫ –∂–µ –¥–æ–ª–≥–æ, –∫–∞–∫ —Å–∞–º–∞ —Å—Å—ã–ª–∫–∞.</p>
<p>–õ–∏—Å—Ç–∏–Ω–≥ 10-18 —Å–æ–¥–µ—Ä–∂–∏—Ç –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –∫–æ–¥ –±–µ–∑ –≤–∏—Å—è—á–µ–π —Å—Å—ã–ª–∫–∏, –∏ –æ–Ω –∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è –±–µ–∑ –æ—à–∏–±–æ–∫.</p>
<Listing number="10-18" caption="A valid reference because the data has a longer lifetime than the reference">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = 5;            // ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ 'b
                          //           ‚îÉ
    let r = &amp;x;           // ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ 'a  ‚îÉ
                          //   ‚îÇ       ‚îÉ
    println!("r: {r}");   //   ‚îÇ       ‚îÉ
                          // ‚îÄ‚îÄ‚îò       ‚îÉ
}                         // ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îõ</code></pre></pre>
</Listing>
<p>–ó–¥–µ—Å—å –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è <code>x</code> –∏–º–µ–µ—Ç –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ <code>'b</code>, –∫–æ—Ç–æ—Ä–æ–µ –±–æ–ª—å—à–µ, —á–µ–º –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ <code>'a</code>. –≠—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è <code>r</code> –º–æ–∂–µ—Ç —Å—Å—ã–ª–∞—Ç—å—Å—è –Ω–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é <code>x</code>, –ø–æ—Ç–æ–º—É —á—Ç–æ Rust –∑–Ω–∞–µ—Ç, —á—Ç–æ —Å—Å—ã–ª–∫–∞ –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π <code>r</code> –±—É–¥–µ—Ç –≤—Å–µ–≥–¥–∞ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ–π –¥–æ —Ç–µ—Ö –ø–æ—Ä, –ø–æ–∫–∞ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è <code>x</code>.</p>
<p>–ü–æ—Å–ª–µ —Ç–æ–≥–æ, –∫–∞–∫ –º—ã –Ω–∞ –ø—Ä–∏–º–µ—Ä–∞—Ö —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–ª–∏ –≤—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏ —Å—Å—ã–ª–æ–∫ –∏ –æ–±—Å—É–¥–∏–ª–∏, –∫–∞–∫ Rust –∏—Ö –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç, –¥–∞–≤–∞–π—Ç–µ –ø–æ–≥–æ–≤–æ—Ä–∏–º –æ–± –æ–±–æ–±—â—ë–Ω–Ω—ã—Ö –≤—Ä–µ–º–µ–Ω–∞—Ö –∂–∏–∑–Ω–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π —Ñ—É–Ω–∫—Ü–∏–π.</p>
<h3 id="–û–±–æ–±—â—ë–Ω–Ω—ã–µ-–≤—Ä–µ–º–µ–Ω–∞-–∂–∏–∑–Ω–∏-–≤-—Ñ—É–Ω–∫—Ü–∏—è—Ö"><a class="header" href="#–û–±–æ–±—â—ë–Ω–Ω—ã–µ-–≤—Ä–µ–º–µ–Ω–∞-–∂–∏–∑–Ω–∏-–≤-—Ñ—É–Ω–∫—Ü–∏—è—Ö">–û–±–æ–±—â—ë–Ω–Ω—ã–µ –≤—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏ –≤ —Ñ—É–Ω–∫—Ü–∏—è—Ö</a></h3>
<p>We‚Äôll write a function that returns the longer of two string slices. This function will take two string slices and return a single string slice. After we‚Äôve implemented the <code>longest</code> function, the code in Listing 10-19 should print <code>The longest string is abcd</code>.</p>
<Listing number="10-19" file-name="src/main.rs" caption="A `main` function that calls the `longest` function to find the longer of two string slices">
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("–°–∞–º–∞—è –¥–ª–∏–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞: {result}");
}</code></pre>
</Listing>
<p>–û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ –º—ã —Ö–æ—Ç–∏–º, —á—Ç–æ–±—ã —Ñ—É–Ω–∫—Ü–∏—è –ø—Ä–∏–Ω–∏–º–∞–ª–∞ —Å—Ç—Ä–æ–∫–æ–≤—ã–µ —Å—Ä–µ–∑—ã (–∫–æ—Ç–æ—Ä—ã–µ —è–≤–ª—è—é—Ç—Å—è —Å—Å—ã–ª–∫–∞–º–∏), –∞ –Ω–µ —Å–∞–º–∏ —Å—Ç—Ä–æ–∫–∏, –ø–æ—Ç–æ–º—É —á—Ç–æ –º—ã –Ω–µ —Ö–æ—Ç–∏–º, —á—Ç–æ–±—ã —Ñ—É–Ω–∫—Ü–∏—è <code>longest</code> –∑–∞–±–∏—Ä–∞–ª–∞ –≤–æ –≤–ª–∞–¥–µ–Ω–∏–µ —Å–≤–æ–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã. –û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ —Ä–∞–∑–¥–µ–ª—É <a href="ch04-03-slices.html#%D0%A1%D1%82%D1%80%D0%BE%D0%BA%D0%BE%D0%B2%D1%8B%D0%B5-%D1%81%D1%80%D0%B5%D0%B7%D1%8B-%D0%BA%D0%B0%D0%BA-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D1%8B">"–°—Ç—Ä–æ–∫–æ–≤—ã–µ —Å—Ä–µ–∑—ã –∫–∞–∫ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã"</a><!-- ignore --> –ì–ª–∞–≤—ã 4, —á—Ç–æ–±—ã –≤—Å–ø–æ–º–Ω–∏—Ç—å, –ø–æ—á–µ–º—É –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Ñ—É–Ω–∫—Ü–∏–∏ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 10-19 –∏–º–µ—é—Ç –∏–º–µ–Ω–Ω–æ —Ç–∞–∫–æ–π —Ç–∏–ø.</p>
<p>–ï—Å–ª–∏ –º—ã –ø–æ–ø—Ä–æ–±—É–µ–º —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Ñ—É–Ω–∫—Ü–∏—é <code>longest</code> —Ç–∞–∫, –∫–∞–∫ —ç—Ç–æ –ø–æ–∫–∞–∑–∞–Ω–æ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 10-20, —Ç–æ –ø—Ä–æ–≥—Ä–∞–º–º–∞ –Ω–µ —Å–∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è:</p>
<Listing number="10-20" file-name="src/main.rs" caption="An implementation of the `longest` function that returns the longer of two string slices but does not yet compile">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("–°–∞–º–∞—è –¥–ª–∏–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞: {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}</code></pre>
</Listing>
<p>–í–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ –º—ã –ø–æ–ª—É—á–∏–º —Å–ª–µ–¥—É—é—â—É—é –æ—à–∏–±–∫—É, –≥–æ–≤–æ—Ä—è—â—É—é –æ –≤—Ä–µ–º–µ–Ω–∞—Ö –∂–∏–∑–Ω–∏:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:9:33
  |
9 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
  |               ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
  |
9 | fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
  |           ++++     ++          ++          ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>–¢–µ–∫—Å—Ç –æ—à–∏–±–∫–∏ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç, —á—Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–º—É —Ç–∏–ø—É –Ω—É–∂–µ–Ω –æ–±–æ–±—â—ë–Ω–Ω—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏, –ø–æ—Ç–æ–º—É —á—Ç–æ Rust –Ω–µ –º–æ–∂–µ—Ç –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å, –Ω–∞ —á—Ç–æ —É–∫–∞–∑—ã–≤–∞–µ—Ç –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–∞—è —Å—Å—ã–ª–∫–∞ ‚Äî –Ω–∞ <code>x</code> –∏–ª–∏ –Ω–∞ <code>y</code>. –ù–∞ —Å–∞–º–æ–º –¥–µ–ª–µ, –º—ã —Ç–æ–∂–µ –Ω–µ –∑–Ω–∞–µ–º! ‚Äî –±–ª–æ–∫ <code>if</code> –≤ —Ç–µ–ª–µ —Ñ—É–Ω–∫—Ü–∏–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Å—ã–ª–∫—É –Ω–∞ <code>x</code>, –∞ –±–ª–æ–∫ <code>else</code> ‚Äî –Ω–∞ <code>y</code>.</p>
<p>–ö–æ–≥–¥–∞ –º—ã –æ–ø—Ä–µ–¥–µ–ª—è–µ–º —ç—Ç—É —Ñ—É–Ω–∫—Ü–∏—é, –º—ã –Ω–µ –∑–Ω–∞–µ–º –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π, –∫–æ—Ç–æ—Ä—ã–µ –±—É–¥—É—Ç –ø–µ—Ä–µ–¥–∞–Ω—ã –≤ —ç—Ç—É —Ñ—É–Ω–∫—Ü–∏—é, –ø–æ—ç—Ç–æ–º—É –º—ã –Ω–µ –∑–Ω–∞–µ–º, –∫–∞–∫–∞—è –∏–∑ –≤–µ—Ç–≤–µ–π (<code>if</code> –∏–ª–∏ <code>else</code>) –±—É–¥–µ—Ç –∏—Å–ø–æ–ª–Ω–µ–Ω–∞. –ú—ã —Ç–∞–∫–∂–µ –Ω–µ –∑–Ω–∞–µ–º –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã—Ö —Å—Ä–æ–∫–æ–≤ –∂–∏–∑–Ω–∏ —Å—Å—ã–ª–æ–∫, –∫–æ—Ç–æ—Ä—ã–µ –±—É–¥—É—Ç –ø–µ—Ä–µ–¥–∞–Ω—ã, –ø–æ—ç—Ç–æ–º—É –º—ã –Ω–µ –º–æ–∂–µ–º –ø—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏, –∫–∞–∫ –º—ã —ç—Ç–æ –¥–µ–ª–∞–ª–∏ –≤ –õ–∏—Å—Ç–∏–Ω–≥–∞—Ö 10-17 –∏ 10-18, —á—Ç–æ–±—ã –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å, –≤—Å–µ–≥–¥–∞ –ª–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–∞—è —Å—Å—ã–ª–∫–∞ –±—É–¥–µ—Ç –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ–π. –ê–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–π —Ç–æ–∂–µ –±–µ—Å—Å–∏–ª–µ–Ω, –ø–æ—Å–∫–æ–ª—å–∫—É –æ–Ω –Ω–µ –∑–Ω–∞–µ—Ç, –∫–∞–∫ –≤—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏ <code>x</code> –∏ <code>y</code> —Å–æ–æ—Ç–Ω–æ—Å—è—Ç—Å—è —Å –≤—Ä–µ–º–µ–Ω–µ–º –∂–∏–∑–Ω–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è. –ß—Ç–æ–±—ã –∏—Å–ø—Ä–∞–≤–∏—Ç—å —ç—Ç—É –æ—à–∏–±–∫—É, –º—ã –¥–æ–±–∞–≤–∏–º –æ–±–æ–±—â—ë–Ω–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏, –∫–æ—Ç–æ—Ä—ã–µ —É–∫–∞–∑—ã–≤–∞—é—Ç –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä—É –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–π —Ç–æ, –∫–∞–∫ —Å—Å—ã–ª–∫–∏ –æ—Ç–Ω–æ—Å—è—Ç—Å—è –¥—Ä—É–≥ –∫ –¥—Ä—É–≥—É.</p>
<h3 id="–ê–Ω–Ω–æ—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ-–≤—Ä–µ–º–µ–Ω–∏-–∂–∏–∑–Ω–∏"><a class="header" href="#–ê–Ω–Ω–æ—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ-–≤—Ä–µ–º–µ–Ω–∏-–∂–∏–∑–Ω–∏">–ê–Ω–Ω–æ—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏</a></h3>
<p>–ê–Ω–Ω–æ—Ç–∞—Ü–∏–∏ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏ –Ω–µ –º–µ–Ω—è—é—Ç –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ —Å—Å—ã–ª–æ–∫. –û–Ω–∏ —Å–∫–æ—Ä–µ–µ –æ–ø–∏—Å—ã–≤–∞—é—Ç, –∫–∞–∫ —Å–æ–æ—Ç–Ω–æ—Å—è—Ç—Å—è –º–µ–∂–¥—É —Å–æ–±–æ–π –≤—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Å—Å—ã–ª–æ–∫, –Ω–µ –≤–ª–∏—è—è –Ω–∞ —Å–∞–º–æ –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏. –¢–æ—á–Ω–æ —Ç–∞–∫ –∂–µ, –∫–∞–∫ —Ñ—É–Ω–∫—Ü–∏–∏ –º–æ–≥—É—Ç –ø—Ä–∏–Ω–∏–º–∞—Ç—å –ª—é–±–æ–π —Ç–∏–ø, –∫–æ–≥–¥–∞ –≤ —Å–∏–≥–Ω–∞—Ç—É—Ä–µ —É–∫–∞–∑–∞–Ω –ø–∞—Ä–∞–º–µ—Ç—Ä –æ–±–æ–±—â—ë–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞, —Ñ—É–Ω–∫—Ü–∏–∏ –º–æ–≥—É—Ç –ø—Ä–∏–Ω–∏–º–∞—Ç—å —Å—Å—ã–ª–∫–∏ —Å –ª—é–±—ã–º –≤—Ä–µ–º–µ–Ω–µ–º –∂–∏–∑–Ω–∏, —É–∫–∞–∑–∞–Ω–Ω—ã–º —Å –ø–æ–º–æ—â—å—é –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –æ–±–æ–±—â—ë–Ω–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏.</p>
<p>–ê–Ω–Ω–æ—Ç–∞—Ü–∏–∏ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏ –∏–º–µ—é—Ç –Ω–µ–º–Ω–æ–≥–æ –Ω–µ–æ–±—ã—á–Ω—ã–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å: –∏–º–µ–Ω–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏ –¥–æ–ª–∂–Ω—ã –Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å –∞–ø–æ—Å—Ç—Ä–æ—Ñ–∞ (<code>'</code>), –ø–∏—à—É—Ç—Å—è –º–∞–ª–µ–Ω—å–∫–∏–º–∏ –±—É–∫–≤–∞–º–∏, –∏ –æ–±—ã—á–Ω–æ –æ—á–µ–Ω—å –∫–æ—Ä–æ—Ç–∫–∏–µ, –∫–∞–∫ –∏ –∏–º–µ–Ω–∞ –æ–±–æ–±—â—ë–Ω–Ω—ã—Ö —Ç–∏–ø–æ–≤. –ë–æ–ª—å—à–∏–Ω—Å—Ç–≤–æ –ª—é–¥–µ–π –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –∏–º—è <code>'a</code> –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–µ—Ä–≤–æ–π –∞–Ω–Ω–æ—Ç–∞—Ü–∏–∏ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏. –ê–Ω–Ω–æ—Ç–∞—Ü–∏–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏ —Å–ª–µ–¥—É—é—Ç –ø–æ—Å–ª–µ —Å–∏–º–≤–æ–ª–∞ <code>&amp;</code> –∏ –æ—Ç–¥–µ–ª—è—é—Ç—Å—è –ø—Ä–æ–±–µ–ª–æ–º –æ—Ç —Ç–∏–ø–∞ –∑–Ω–∞—á–µ–Ω–∏—è —Å—Å—ã–ª–∫–∏.</p>
<p>–ü—Ä–∏–≤–µ–¥—ë–º –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø—Ä–∏–º–µ—Ä–æ–≤: —É –Ω–∞—Å –µ—Å—Ç—å —Å—Å—ã–ª–∫–∞ –Ω–∞ <code>i32</code> –±–µ–∑ —É–∫–∞–∑–∞–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏, —Å—Å—ã–ª–∫–∞ –Ω–∞ <code>i32</code> —Å –≤—Ä–µ–º–µ–Ω–µ–º –∂–∏–∑–Ω–∏ <code>'a</code> –∏ –∏–∑–º–µ–Ω—è–µ–º–∞—è —Å—Å—ã–ª–∫–∞ –Ω–∞ <code>i32</code>, –∫–æ—Ç–æ—Ä–∞—è —Ç–∞–∫–∂–µ –∏–º–µ–µ—Ç –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ <code>'a</code>.</p>
<pre><code class="language-rust ignore">&amp;i32        // —Å—Å—ã–ª–∫–∞
&amp;'a i32     // —Å—Å—ã–ª–∫–∞ —Å —è–≤–Ω–æ —É–∫–∞–∑–∞–Ω–Ω—ã–º –≤—Ä–µ–º–µ–Ω–µ–º –∂–∏–∑–Ω–∏
&amp;'a mut i32 // –∏–∑–º–µ–Ω—è–µ–º–∞—è —Å—Å—ã–ª–∫–∞ —Å —è–≤–Ω–æ —É–∫–∞–∑–∞–Ω–Ω—ã–º –≤—Ä–µ–º–µ–Ω–µ–º –∂–∏–∑–Ω–∏</code></pre>
<p>–û–¥–Ω–∞ –ª–∏—à—å –∞–Ω–Ω–æ—Ç–∞—Ü–∏—è –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏ —Å–∞–º–∞ –ø–æ —Å–µ–±–µ –Ω–µ –∏–º–µ–µ—Ç –±–æ–ª—å—à–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è, –ø–æ—Å–∫–æ–ª—å–∫—É –∞–Ω–Ω–æ—Ç–∞—Ü–∏–∏ –ø—Ä–µ–¥–Ω–∞–∑–Ω–∞—á–µ–Ω—ã –¥–ª—è —Ç–æ–≥–æ, —á—Ç–æ–±—ã –∏–Ω—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å Rust –æ —Ç–æ–º, –∫–∞–∫ —Å–æ–æ—Ç–Ω–æ—Å—è—Ç—Å—è –º–µ–∂–¥—É —Å–æ–±–æ–π –≤—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Å—Å—ã–ª–æ–∫. –î–∞–≤–∞–π—Ç–µ —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º, –∫–∞–∫ –∞–Ω–Ω–æ—Ç–∞—Ü–∏–∏ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏ —Å–æ–æ—Ç–Ω–æ—Å—è—Ç—Å—è –¥—Ä—É–≥ —Å –¥—Ä—É–≥–æ–º –≤ —Ñ—É–Ω–∫—Ü–∏–∏ <code>longest</code>.</p>
<h3 id="–ê–Ω–Ω–æ—Ç–∞—Ü–∏–∏-–≤—Ä–µ–º–µ–Ω–∏-–∂–∏–∑–Ω–∏-–≤-—Å–∏–≥–Ω–∞—Ç—É—Ä–∞—Ö-—Ñ—É–Ω–∫—Ü–∏–π"><a class="header" href="#–ê–Ω–Ω–æ—Ç–∞—Ü–∏–∏-–≤—Ä–µ–º–µ–Ω–∏-–∂–∏–∑–Ω–∏-–≤-—Å–∏–≥–Ω–∞—Ç—É—Ä–∞—Ö-—Ñ—É–Ω–∫—Ü–∏–π">–ê–Ω–Ω–æ—Ç–∞—Ü–∏–∏ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏ –≤ —Å–∏–≥–Ω–∞—Ç—É—Ä–∞—Ö —Ñ—É–Ω–∫—Ü–∏–π</a></h3>
<p>–ß—Ç–æ–±—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∞–Ω–Ω–æ—Ç–∞—Ü–∏–∏ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏ –≤ —Å–∏–≥–Ω–∞—Ç—É—Ä–∞—Ö —Ñ—É–Ω–∫—Ü–∏–π, –Ω–∞–º –Ω—É–∂–Ω–æ –æ–±—ä—è–≤–∏—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –æ–±–æ–±—â—ë–Ω–Ω–æ–≥–æ <em>–≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏</em> –≤–Ω—É—Ç—Ä–∏ —É–≥–ª–æ–≤—ã—Ö —Å–∫–æ–±–æ–∫ –º–µ–∂–¥—É –∏–º–µ–Ω–µ–º —Ñ—É–Ω–∫—Ü–∏–∏ –∏ —Å–ø–∏—Å–∫–æ–º –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤, –∫–∞–∫ –º—ã —ç—Ç–æ –¥–µ–ª–∞–ª–∏ —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ –æ–±–æ–±—â—ë–Ω–Ω–æ–≥–æ <em>—Ç–∏–ø–∞</em>.</p>
<p>–ú—ã —Ö–æ—Ç–∏–º, —á—Ç–æ–±—ã —Å–∏–≥–Ω–∞—Ç—É—Ä–∞ –æ—Ç—Ä–∞–∂–∞–ª–∞ —Å–ª–µ–¥—É—é—â–µ–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ: –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–∞—è —Å—Å—ã–ª–∫–∞ –±—É–¥–µ—Ç –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞ –¥–æ —Ç–µ—Ö –ø–æ—Ä, –ø–æ–∫–∞ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã –æ–±–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞. –≠—Ç–æ –∏ –µ—Å—Ç—å —Å–≤—è–∑—å –º–µ–∂–¥—É –≤—Ä–µ–º–µ–Ω–∞–º–∏ –∂–∏–∑–Ω–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è. –ú—ã –Ω–∞–∑–æ–≤—ë–º —ç—Ç–æ –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ <code>'a</code>, –∞ –∑–∞—Ç–µ–º –ø—Ä–∏–ø–∏—à–µ–º –µ–≥–æ –∫–∞–∂–¥–æ–π —Å—Å—ã–ª–∫–µ, –∫–∞–∫ –ø–æ–∫–∞–∑–∞–Ω–æ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 10-21.</p>
<Listing number="10-21" file-name="src/main.rs" caption="The `longest` function definition specifying that all the references in the signature must have the same lifetime `'a`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("–°–∞–º–∞—è –¥–ª–∏–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞: {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}</code></pre></pre>
</Listing>
<p>–¢–µ–ø–µ—Ä—å –Ω–∞—à–∞ —Ñ—É–Ω–∫—Ü–∏—è –±—É–¥–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å, –∞ –∫–æ–¥ –∏–∑ –õ–∏—Å—Ç–∏–Ω–≥–∞ 10-19 ‚Äî —Å–∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è.</p>
<p>–°–∏–≥–Ω–∞—Ç—É—Ä–∞ —Ñ—É–Ω–∫—Ü–∏–∏ —Ç–µ–ø–µ—Ä—å —Å–æ–æ–±—â–∞–µ—Ç Rust, —á—Ç–æ –¥–ª—è –Ω–µ–∫–æ—Ç–æ—Ä–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏ <code>'a</code> —Ñ—É–Ω–∫—Ü–∏—è –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –¥–≤–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞, –æ–±–∞ –∏–∑ –∫–æ—Ç–æ—Ä—ã—Ö —è–≤–ª—è—é—Ç—Å—è —Å—Ç—Ä–æ–∫–æ–≤—ã–º–∏ —Å—Ä–µ–∑–∞–º–∏, –∏–º–µ—é—â–∏–º–∏ –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ –Ω–µ –º–µ–Ω—å—à–µ–µ, —á–µ–º <code>'a</code>. –°–∏–≥–Ω–∞—Ç—É—Ä–∞ —Ñ—É–Ω–∫—Ü–∏–∏ —Ç–∞–∫–∂–µ —Å–æ–æ–±—â–∞–µ—Ç Rust, —á—Ç–æ –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ —Å—Ç—Ä–æ–∫–æ–≤–æ–≥–æ —Å—Ä–µ–∑–∞, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–≥–æ —Ñ—É–Ω–∫—Ü–∏–µ–π, –±—É–¥–µ—Ç –Ω–µ –º–µ–Ω—å—à–µ, —á–µ–º <code>'a</code>. –ù–∞ –ø—Ä–∞–∫—Ç–∏–∫–µ —ç—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ —Å—Å—ã–ª–∫–∏, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–π —Ñ—É–Ω–∫—Ü–∏–µ–π <code>longest</code>, —Ä–∞–≤–Ω–æ –º–µ–Ω—å—à–µ–º—É –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏ –∏–∑ –≤—Ä–µ–º—ë–Ω –∂–∏–∑–Ω–µ–π —Å—Å—ã–ª–æ–∫, –ø–µ—Ä–µ–¥–∞–≤–∞–µ–º—ã—Ö –≤ –Ω–µ—ë. –ú—ã —Ö–æ—Ç–∏–º, —á—Ç–æ–±—ã Rust –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª –∏–º–µ–Ω–Ω–æ —Ç–∞–∫–∏–µ –æ—Ç–Ω–æ—à–µ–Ω–∏—è –≤—Ä–µ–º—ë–Ω –∂–∏–∑–Ω–∏ –ø—Ä–∏ –∞–Ω–∞–ª–∏–∑–µ —ç—Ç–æ–≥–æ –∫–æ–¥–∞.</p>
<p>–ü–æ–º–Ω–∏—Ç–µ, —á—Ç–æ –∫–æ–≥–¥–∞ –º—ã —É–∫–∞–∑—ã–≤–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏ –≤ —ç—Ç–æ–π —Å–∏–≥–Ω–∞—Ç—É—Ä–µ —Ñ—É–Ω–∫—Ü–∏–∏, –º—ã –Ω–µ –º–µ–Ω—è–µ–º –≤—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏ –∫–∞–∫–∏—Ö-–ª–∏–±–æ –ø–µ—Ä–µ–¥–∞–≤–∞–µ–º—ã—Ö –∏–ª–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π. –°–∫–æ—Ä–µ–µ, –º—ã —É–∫–∞–∑—ã–≤–∞–µ–º, —á—Ç–æ –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–π –¥–æ–ª–∂–µ–Ω –æ—Ç–∫–ª–æ–Ω—è—Ç—å –ª—é–±—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—Ç —ç—Ç–∏–º –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è–º. –û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ —Å–∞–º–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ <code>longest</code> –Ω–µ –Ω—É–∂–Ω–æ —Ç–æ—á–Ω–æ –∑–Ω–∞—Ç—å, –∫–∞–∫ –¥–æ–ª–≥–æ –±—É–¥—É—Ç –∂–∏—Ç—å <code>x</code> –∏ <code>y</code>, –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Ç–æ–≥–æ, —á—Ç–æ –Ω–µ–∫–æ—Ç–æ—Ä–∞—è –æ–±–ª–∞—Å—Ç—å –º–æ–∂–µ—Ç –±—ã—Ç—å –∑–∞–º–µ–Ω–µ–Ω–∞ –Ω–∞ <code>'a</code>, –∫–æ—Ç–æ—Ä–∞—è –±—É–¥–µ—Ç —É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä—è—Ç—å —ç—Ç–æ–π —Å–∏–≥–Ω–∞—Ç—É—Ä–µ.</p>
<p>–ü—Ä–∏ –∞–Ω–Ω–æ—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏ –≤ —Ñ—É–Ω–∫—Ü–∏—è—Ö, –∞–Ω–Ω–æ—Ç–∞—Ü–∏–∏ –ø–æ–º–µ—â–∞—é—Ç—Å—è –≤ —Å–∏–≥–Ω–∞—Ç—É—Ä—É —Ñ—É–Ω–∫—Ü–∏–∏, –∞ –Ω–µ –≤ —Ç–µ–ª–æ —Ñ—É–Ω–∫—Ü–∏–∏. –ê–Ω–Ω–æ—Ç–∞—Ü–∏–∏ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏ —Å—Ç–∞–Ω–æ–≤—è—Ç—Å—è —á–∞—Å—Ç—å—é –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞ —Ñ—É–Ω–∫—Ü–∏–∏, —Ç–∞–∫ –∂–µ –∫–∞–∫ –∏ —Ç–∏–ø—ã –≤ —Å–∏–≥–Ω–∞—Ç—É—Ä–µ. –ù–∞–ª–∏—á–∏–µ –≤ —Å–∏–≥–Ω–∞—Ç—É—Ä–∞—Ö —Ñ—É–Ω–∫—Ü–∏–π –∞–Ω–Ω–æ—Ç–∞—Ü–∏–π –≤—Ä–µ–º—ë–Ω –∂–∏–∑–Ω–∏ —É–ø—Ä–æ—â–∞–µ—Ç —Ä–∞–±–æ—Ç—É –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä—É. –ï—Å–ª–∏ –≤–æ–∑–Ω–∏–∫–Ω–µ—Ç –ø—Ä–æ–±–ª–µ–º–∞ —Å –∞–Ω–Ω–æ—Ç–∞—Ü–∏—è–º–∏ —Ñ—É–Ω–∫—Ü–∏–∏ –∏–ª–∏ —Ç–µ–º, –∫–∞–∫ –æ–Ω–∞ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è, –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä —Å–º–æ–∂–µ—Ç –±–æ–ª–µ–µ —Ç–æ—á–Ω–æ –∏ —É–∫–∞–∑–∞—Ç—å –Ω–∞ –ø—Ä–æ–±–ª–µ–º—ã –Ω–∞—à–µ–≥–æ –∫–æ–¥–∞ –∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è. –ï—Å–ª–∏ –±—ã –≤–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä Rust –ø—ã—Ç–∞–ª—Å—è —Å–∞–º–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω–æ –≤—ã–≤–æ–¥–∏—Ç—å, –∫–∞–∫–∏–µ –≤—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏ –º—ã –ø–æ–¥—Ä–∞–∑—É–º–µ–≤–∞–µ–º, —Ç–æ —ç—Ç–æ –ø—Ä–∏–≤–µ–ª–æ –±—ã –∫ —Ç–æ–º—É, —á—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏—è –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞ —Å—Ç–∞–ª–∏ –±—ã –∫—É–¥–∞ –±–æ–ª–µ–µ –∑–∞–ø—É—Ç–∞–Ω–Ω—ã–º–∏, –∏ —É–∫–∞–∑—ã–≤–∞–ª–∏ –±—ã –Ω–∞ –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ –±–æ–ª–µ–µ –æ—Ç–¥–∞–ª—ë–Ω–Ω—ã–µ —É—á–∞—Å—Ç–∫–∏ –∫–æ–¥–∞.</p>
<p>–ö–æ–≥–¥–∞ –º—ã –ø–µ—Ä–µ–¥–∞—ë–º <code>longest</code> –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ —Å—Å—ã–ª–∫–∏, –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–µ –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏, –∫–æ—Ç–æ—Ä–æ–µ –ø–æ–¥—Å—Ç–∞–≤–ª—è–µ—Ç—Å—è –≤–º–µ—Å—Ç–æ <code>'a</code>, —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è —á–∞—Å—Ç—å—é –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏ <code>x</code>, –∫–æ—Ç–æ—Ä–∞—è –ø–µ—Ä–µ–∫—Ä—ã–≤–∞–µ—Ç—Å—è —Å –æ–±–ª–∞—Å—Ç—å—é –≤–∏–¥–∏–º–æ—Å—Ç–∏ <code>y</code>. –î—Ä—É–≥–∏–º–∏ —Å–ª–æ–≤–∞–º–∏, –æ–±—â–µ–µ –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ <code>'a</code> –ø–æ–ª—É—á–∏—Ç –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–µ –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏, —Ä–∞–≤–Ω–æ–µ –º–µ–Ω—å—à–µ–º—É –∏–∑ –≤—Ä–µ–º—ë–Ω –∂–∏–∑–Ω–∏ <code>x</code> –∏ <code>y</code>. –ü–æ—Å–∫–æ–ª—å–∫—É –º—ã —É–∫–∞–∑–∞–ª–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–π —Å—Å—ã–ª–∫–µ —Ç–æ—Ç –∂–µ –ø–∞—Ä–∞–º–µ—Ç—Ä –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏ (<code>'a</code>), –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–π —Å—Å—ã–ª–∫–∏ –±—É–¥–µ—Ç –Ω–µ –º–µ–Ω—å—à–∏–º, —á–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∏–∑ –≤—Ä–µ–º—ë–Ω –∂–∏–∑–Ω–∏ <code>x</code> –∏ <code>y</code>.</p>
<p>–î–∞–≤–∞–π—Ç–µ –ø–æ—Å–º–æ—Ç—Ä–∏–º, –∫–∞–∫ –∞–Ω–Ω–æ—Ç–∞—Ü–∏–∏ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏ –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞—é—Ç —Ñ—É–Ω–∫—Ü–∏—é <code>longest</code> –ø—É—Ç—ë–º –ø–µ—Ä–µ–¥–∞—á–∏ –≤ –Ω–µ—ë —Å—Å—ã–ª–æ–∫, –∫–æ—Ç–æ—Ä—ã–µ –∏–º–µ—é—Ç —Ä–∞–∑–Ω—ã–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ –≤—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏. –ü–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –Ω–∞ –õ–∏—Å—Ç–∏–Ω–≥ 10-22:</p>
<Listing number="10-22" file-name="src/main.rs" caption="Using the `longest` function with references to `String` values that have different concrete lifetimes">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let string1 = String::from("–¥–ª–∏–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞ —Ç–∞–∫–∞—è –¥–ª–∏–Ω–Ω–∞—è");

    {
        let string2 = String::from("xyz");
        let result = longest(string1.as_str(), string2.as_str());
        println!("–°–∞–º–∞—è –¥–ª–∏–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞: {result}");
    }
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>–í —ç—Ç–æ–º –ø—Ä–∏–º–µ—Ä–µ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è <code>string1</code> –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞ –¥–æ –∫–æ–Ω—Ü–∞ –≤–Ω–µ—à–Ω–µ–π –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏ <code>string2</code> –¥–µ–π—Å—Ç–≤—É–µ—Ç –¥–æ –∫–æ–Ω—Ü–∞ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–π –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏, –∞ <code>result</code> —Å—Å—ã–ª–∞–µ—Ç—Å—è –Ω–∞ —á—Ç–æ-—Ç–æ, —á—Ç–æ —è–≤–ª—è–µ—Ç—Å—è –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–º –¥–æ –∫–æ–Ω—Ü–∞ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–π –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏. –ó–∞–ø—É—Å—Ç–∏—Ç–µ —ç—Ç–æ—Ç –∫–æ–¥, –∏ –≤—ã —É–≤–∏–¥–∏—Ç–µ —á—Ç–æ –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–π —Ä–∞–∑—Ä–µ—à–∞–µ—Ç —Ç–∞–∫–æ–π –∫–æ–¥; –æ–Ω —Å–∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è –∏ –Ω–∞–ø–µ—á–∞—Ç–∞–µ—Ç <code>–°–∞–º–∞—è –¥–ª–∏–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞: –¥–ª–∏–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞ —Ç–∞–∫–∞—è –¥–ª–∏–Ω–Ω–∞—è</code>.</p>
<p>–¢–µ–ø–µ—Ä—å –¥–∞–≤–∞–π—Ç–µ —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º –ø—Ä–∏–º–µ—Ä, –∫–æ—Ç–æ—Ä—ã–π –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç, —á—Ç–æ –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ —Å—Å—ã–ª–∫–∏ –≤ <code>result</code> –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –º–µ–Ω—å—à–∏–º –≤—Ä–µ–º–µ–Ω–µ–º –∂–∏–∑–Ω–∏ –æ–¥–Ω–æ–≥–æ –∏–∑ –¥–≤—É—Ö –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤. –ú—ã –ø–µ—Ä–µ–º–µ—Å—Ç–∏–º –æ–±—ä—è–≤–ª–µ–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π <code>result</code> –∑–∞ –ø—Ä–µ–¥–µ–ª—ã –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–π –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏, –Ω–æ –æ—Å—Ç–∞–≤–∏–º –ø—Ä–∏—Å–≤–æ–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π <code>result</code> –≤ –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏ <code>string2</code>. –ó–∞—Ç–µ–º –º—ã –ø–µ—Ä–µ–º–µ—Å—Ç–∏–º <code>println!</code>, –∫–æ—Ç–æ—Ä—ã–π –∏—Å–ø–æ–ª—å–∑—É–µ—Ç <code>result</code>, –∑–∞ –ø—Ä–µ–¥–µ–ª—ã –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–π –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏ ‚Äî –ø–æ—Å–ª–µ —Ç–æ–≥–æ –∫–∞–∫ –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∑–∞–∫–æ–Ω—á–∏–ª–∞—Å—å. –ö–æ–¥ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 10-23 –Ω–µ —Å–∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è.</p>
<Listing number="10-23" file-name="src/main.rs" caption="Attempting to use `result` after `string2` has gone out of scope">
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let string1 = String::from("–¥–ª–∏–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞ —Ç–∞–∫–∞—è –¥–ª–∏–Ω–Ω–∞—è");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("–°–∞–º–∞—è –¥–ª–∏–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞: {result}");
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>–ü—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ —Å–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞—Ç—å —ç—Ç–æ—Ç –∫–æ–¥, –º—ã –ø–æ–ª—É—á–∏–º —Ç–∞–∫—É—é –æ—à–∏–±–∫—É:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `string2` does not live long enough
 --&gt; src/main.rs:6:44
  |
5 |         let string2 = String::from("xyz");
  |             ------- binding `string2` declared here
6 |         result = longest(string1.as_str(), string2.as_str());
  |                                            ^^^^^^^ borrowed value does not live long enough
7 |     }
  |     - `string2` dropped here while still borrowed
8 |     println!("The longest string is {result}");
  |                                     -------- borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>–≠—Ç–∞ –æ—à–∏–±–∫–∞ –≥–æ–≤–æ—Ä–∏—Ç –æ —Ç–æ–º, —á—Ç–æ –µ—Å–ª–∏ –º—ã —Ö–æ—Ç–∏–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å <code>result</code> –≤ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ <code>println!</code>, –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è <code>string2</code> –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ–π –¥–æ –∫–æ–Ω—Ü–∞ –≤–Ω–µ—à–Ω–µ–π –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏. Rust –∑–Ω–∞–µ—Ç –æ–± —ç—Ç–æ–º, –ø–æ—Ç–æ–º—É —á—Ç–æ –º—ã –∞–Ω–Ω–æ—Ç–∏—Ä–æ–≤–∞–ª–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Ñ—É–Ω–∫—Ü–∏–∏ –∏ –µ—ë –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –æ–¥–∏–Ω–∞–∫–æ–≤—ã–º –≤—Ä–µ–º–µ–Ω–µ–º –∂–∏–∑–Ω–∏ <code>'a</code>.</p>
<p>–ë—É–¥—É—á–∏ –ª—é–¥—å–º–∏, –º—ã –º–æ–∂–µ–º –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –Ω–∞ —ç—Ç–æ—Ç –∫–æ–¥ –∏ —É–≤–∏–¥–µ—Ç—å, —á—Ç–æ <code>string1</code> –¥–ª–∏–Ω–Ω–µ–µ, —á–µ–º <code>string2</code> –∏, —Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ, <code>result</code> –±—É–¥–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Å—Å—ã–ª–∫—É –Ω–∞ <code>string1</code>. –ü–æ—Å–∫–æ–ª—å–∫—É <code>string1</code> –µ—â—ë –Ω–µ –≤—ã—à–ª–∞ –∏–∑ –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏, —Å—Å—ã–ª–∫–∞ –Ω–∞ <code>string1</code> –±—É–¥–µ—Ç –≤—Å—ë –µ—â—ë –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ–π –≤ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ <code>println!</code>. –û–¥–Ω–∞–∫–æ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –Ω–µ –≤–∏–¥–∏—Ç, —á—Ç–æ —Å—Å—ã–ª–∫–∞ –≤ —ç—Ç–æ–º —Å–ª—É—á–∞–µ –≤–∞–ª–∏–¥–Ω–∞. –ú—ã —Å–∫–∞–∑–∞–ª–∏ Rust, —á—Ç–æ –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ —Å—Å—ã–ª–∫–∏, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–π –∏–∑ —Ñ—É–Ω–∫—Ü–∏–∏ <code>longest</code>, —Ä–∞–≤–Ω—è–µ—Ç—Å—è –º–µ–Ω—å—à–µ–º—É –∏–∑ –≤—Ä–µ–º—ë–Ω –∂–∏–∑–Ω–∏ –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã—Ö –≤ –Ω–µ—ë —Å—Å—ã–ª–æ–∫. –¢–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–π –∑–∞–ø—Ä–µ—â–∞–µ—Ç –∫–æ–¥ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 10-23, –∫–∞–∫ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ –∏–º–µ—é—â–∏–π –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—É—é —Å—Å—ã–ª–∫—É.</p>
<p>–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø—Ä–æ–≤–µ—Å—Ç–∏ –±–æ–ª—å—à–µ —ç–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç–æ–≤ —Å —Ä–∞–∑–ª–∏—á–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏ –∏ –≤—Ä–µ–º–µ–Ω–∞–º–∏ –∂–∏–∑–Ω–∏ —Å—Å—ã–ª–æ–∫, –ø–µ—Ä–µ–¥–∞–≤–∞–µ–º—ã–º–∏ –≤ —Ñ—É–Ω–∫—Ü–∏—é <code>longest</code>, –∞ —Ç–∞–∫–∂–µ —Å —Ç–µ–º, –∫–∞–∫ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ü–µ—Ä–µ–¥ –∫–æ–º–ø–∏–ª—è—Ü–∏–µ–π –¥–µ–ª–∞–π—Ç–µ –ø—Ä–µ–¥–ø–æ–ª–æ–∂–µ–Ω–∏—è –æ —Ç–æ–º, –ø—Ä–æ–π–¥—ë—Ç –ª–∏ –≤–∞—à –∫–æ–¥ –∞–Ω–∞–ª–∏–∑ –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–π, –∞ –∑–∞—Ç–µ–º –ø—Ä–æ–≤–µ—Ä—è–π—Ç–µ, –Ω–∞—Å–∫–æ–ª—å–∫–æ –≤—ã –±—ã–ª–∏ –ø—Ä–∞–≤—ã.</p>
<h3 id="–ú—ã—à–ª–µ–Ω–∏–µ-–≤-—Ç–µ—Ä–º–∏–Ω–∞—Ö-–≤—Ä–µ–º—ë–Ω-–∂–∏–∑–Ω–∏"><a class="header" href="#–ú—ã—à–ª–µ–Ω–∏–µ-–≤-—Ç–µ—Ä–º–∏–Ω–∞—Ö-–≤—Ä–µ–º—ë–Ω-–∂–∏–∑–Ω–∏">–ú—ã—à–ª–µ–Ω–∏–µ –≤ —Ç–µ—Ä–º–∏–Ω–∞—Ö –≤—Ä–µ–º—ë–Ω –∂–∏–∑–Ω–∏</a></h3>
<p>–í –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–æ–≥–æ, —á—Ç–æ –¥–µ–ª–∞–µ—Ç –≤–∞—à–∞ —Ñ—É–Ω–∫—Ü–∏—è, —Å–ª–µ–¥—É–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ä–∞–∑–Ω—ã–µ —Å–ø–æ—Å–æ–±—ã —É–∫–∞–∑–∞–Ω–∏—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏. –ù–∞–ø—Ä–∏–º–µ—Ä, –µ—Å–ª–∏ –º—ã –∏–∑–º–µ–Ω–∏–º —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é —Ñ—É–Ω–∫—Ü–∏–∏ <code>longest</code> —Ç–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, —á—Ç–æ–±—ã –æ–Ω–∞ –≤—Å–µ–≥–¥–∞ –≤–æ–∑–≤—Ä–∞—â–∞–ª–∞ —Å–≤–æ–π –ø–µ—Ä–≤—ã–π –∞—Ä–≥—É–º–µ–Ω—Ç –≤–º–µ—Å—Ç–æ —Å–∞–º–æ–≥–æ –¥–ª–∏–Ω–Ω–æ–≥–æ —Å—Ä–µ–∑–∞ —Å—Ç—Ä–æ–∫–∏, —Ç–æ –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ –¥–ª—è –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ <code>y</code> –º–æ–∂–Ω–æ —Å–æ–≤—Å–µ–º –Ω–µ —É–∫–∞–∑—ã–≤–∞—Ç—å. –≠—Ç–æ—Ç –∫–æ–¥ —Å–∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "efghijklmnopqrstuvwxyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("–°–∞–º–∞—è –¥–ª–∏–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞: {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}</code></pre></pre>
</Listing>
<p>–ú—ã —É–∫–∞–∑–∞–ª–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏ <code>'a</code> –¥–ª—è –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ <code>x</code> –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è, –Ω–æ –Ω–µ –¥–ª—è –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ <code>y</code>, –ø–æ—Å–∫–æ–ª—å–∫—É –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ <code>y</code> –Ω–∏–∫–∞–∫ –Ω–µ —Å–æ–æ—Ç–Ω–æ—Å–∏—Ç—Å—è —Å –≤—Ä–µ–º–µ–Ω–µ–º –∂–∏–∑–Ω–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ <code>x</code> –∏–ª–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è.</p>
<p>–ü—Ä–∏ –≤–æ–∑–≤—Ä–∞—Ç–µ —Å—Å—ã–ª–∫–∏ –∏–∑ —Ñ—É–Ω–∫—Ü–∏–∏, –ø–∞—Ä–∞–º–µ—Ç—Ä –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏ –¥–ª—è –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–≥–æ —Ç–∏–ø–∞ –¥–æ–ª–∂–µ–Ω —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–æ–≤–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—É –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏ –æ–¥–Ω–æ–≥–æ –∏–∑ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤. –ï—Å–ª–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–∞—è —Å—Å—ã–ª–∫–∞ <em>–Ω–µ</em> —Å—Å—ã–ª–∞–µ—Ç—Å—è –Ω–∞ –æ–¥–∏–Ω –∏–∑ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤, –æ–Ω–∞ –¥–æ–ª–∂–Ω–∞ —Å—Å—ã–ª–∞—Ç—å—Å—è –Ω–∞ –∑–Ω–∞—á–µ–Ω–∏–µ, —Å–æ–∑–¥–∞–Ω–Ω–æ–µ –≤–Ω—É—Ç—Ä–∏ —Ñ—É–Ω–∫—Ü–∏–∏. –û–¥–Ω–∞–∫–æ, —ç—Ç–æ –ø—Ä–∏–≤–µ–¥—ë—Ç –∫ –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ–π —Å—Å—ã–ª–∫–µ, –ø–æ—Å–∫–æ–ª—å–∫—É –∑–Ω–∞—á–µ–Ω–∏–µ, –Ω–∞ –∫–æ—Ç–æ—Ä–æ–µ –æ–Ω–∞ —Å—Å—ã–ª–∞–µ—Ç—Å—è, –≤—ã–π–¥–µ—Ç –∏–∑ –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏ –≤ –∫–æ–Ω—Ü–µ —Ñ—É–Ω–∫—Ü–∏–∏. –ü–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –Ω–∞ –≤–æ—Ç —ç—Ç—É –ø–æ–ø—ã—Ç–∫—É —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ —Ñ—É–Ω–∫—Ü–∏–∏ <code>longest</code>, –∫–æ—Ç–æ—Ä–∞—è –Ω–µ —Å–∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è:</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("–°–∞–º–∞—è –¥–ª–∏–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞: {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    let result = String::from("–æ—á–µ–Ω—å –¥–ª–∏–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞");
    result.as_str()
}</code></pre>
</Listing>
<p>–ó–¥–µ—Å—å, –Ω–µ—Å–º–æ—Ç—Ä—è –Ω–∞ —Ç–æ, —á—Ç–æ –º—ã —É–∫–∞–∑–∞–ª–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏ <code>'a</code> –¥–ª—è –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–≥–æ —Ç–∏–ø–∞, —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –Ω–µ –±—É–¥–µ—Ç –ø—Ä–æ–ø—É—â–µ–Ω–∞ –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä–æ–º, –ø–æ—Ç–æ–º—É —á—Ç–æ –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è –Ω–∏–∫–∞–∫ –Ω–µ —Å–≤—è–∑–∞–Ω–æ —Å –≤—Ä–µ–º–µ–Ω–µ–º –∂–∏–∑–Ω–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤. –ú—ã –ø–æ–ª—É—á–∏–º —Ç–∞–∫–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0515]: cannot return value referencing local variable `result`
  --&gt; src/main.rs:11:5
   |
11 |     result.as_str()
   |     ------^^^^^^^^^
   |     |
   |     returns a value referencing data owned by the current function
   |     `result` is borrowed here

For more information about this error, try `rustc --explain E0515`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>–ü—Ä–æ–±–ª–µ–º–∞ –∑–∞–∫–ª—é—á–∞–µ—Ç—Å—è –≤ —Ç–æ–º, —á—Ç–æ <code>result</code> –≤—ã—Ö–æ–¥–∏—Ç –∑–∞ –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∏ –æ—á–∏—â–∞–µ—Ç—Å—è –≤ –∫–æ–Ω—Ü–µ —Ñ—É–Ω–∫—Ü–∏–∏ <code>longest</code>. –ú—ã —Ç–∞–∫–∂–µ –ø—ã—Ç–∞–µ–º—Å—è –≤–µ—Ä–Ω—É—Ç—å —Å—Å—ã–ª–∫—É –Ω–∞ <code>result</code> –∏–∑ —Ñ—É–Ω–∫—Ü–∏–∏. –ú—ã –Ω–µ –º–æ–∂–µ–º —É–∫–∞–∑–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥–ª–∏ –±—ã –∏–∑–º–µ–Ω–∏—Ç—å –≤–∏—Å—è—á—É—é —Å—Å—ã–ª–∫—É, –∞ Rust –Ω–µ –ø–æ–∑–≤–æ–ª–∏—Ç –Ω–∞–º —Å–æ–∑–¥–∞—Ç—å –≤–∏—Å—è—á—É—é —Å—Å—ã–ª–∫—É. –í —ç—Ç–æ–º —Å–ª—É—á–∞–µ –ª—É—á—à–∏–º —Ä–µ—à–µ–Ω–∏–µ–º –±—É–¥–µ—Ç –≤–µ—Ä–Ω—É—Ç—å –≤–ª–∞–¥–µ–µ–º—ã–π —Ç–∏–ø –¥–∞–Ω–Ω—ã—Ö, –∞ –Ω–µ —Å—Å—ã–ª–∫—É: –≤ —ç—Ç–æ–º —Å–ª—É—á–∞–µ –≤—ã–∑—ã–≤–∞—é—â–∞—è —Ñ—É–Ω–∫—Ü–∏—è –±—É–¥–µ—Ç –Ω–µ—Å—Ç–∏ –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç—å –∑–∞ –æ—á–∏—Å—Ç–∫—É –ø–æ–ª—É—á–µ–Ω–Ω–æ–≥–æ –µ—é –∑–Ω–∞—á–µ–Ω–∏—è.</p>
<p>–í –∫–æ–Ω–µ—á–Ω–æ–º –∏—Ç–æ–≥–µ, —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –≤—Ä–µ–º—ë–Ω –∂–∏–∑–Ω–∏ —Ä–µ–∞–ª–∏–∑—É–µ—Ç —Å–≤—è–∑—ã–≤–∞–Ω–∏–µ –≤—Ä–µ–º—ë–Ω –∂–∏–∑–Ω–∏ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π —Ñ—É–Ω–∫—Ü–∏–π. –û–ø–∏—Å—ã–≤–∞—è –≤—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏, –º—ã –¥–∞—ë–º Rust –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏, —á—Ç–æ–±—ã —Ä–∞–∑—Ä–µ—à–∏—Ç—å –±–µ–∑–æ–ø–∞—Å–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ —Å –ø–∞–º—è—Ç—å—é –∏ –∑–∞–ø—Ä–µ—Ç–∏—Ç—å –æ–ø–µ—Ä–∞—Ü–∏–∏, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥–ª–∏ –±—ã —Å–æ–∑–¥–∞—Ç—å –≤–∏—Å—è—á–∏–µ —Å—Å—ã–ª–∫–∏ –∏–ª–∏ –∏–Ω—ã–º —Å–ø–æ—Å–æ–±–æ–º –Ω–∞—Ä—É—à–∏—Ç—å –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –ø–∞–º—è—Ç–∏.</p>
<h3 id="–ê–Ω–Ω–æ—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ-–≤—Ä–µ–º—ë–Ω-–∂–∏–∑–Ω–∏-–≤-–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è—Ö-—Å—Ç—Ä—É–∫—Ç—É—Ä"><a class="header" href="#–ê–Ω–Ω–æ—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ-–≤—Ä–µ–º—ë–Ω-–∂–∏–∑–Ω–∏-–≤-–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è—Ö-—Å—Ç—Ä—É–∫—Ç—É—Ä">–ê–Ω–Ω–æ—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Ä–µ–º—ë–Ω –∂–∏–∑–Ω–∏ –≤ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä</a></h3>
<p>–î–æ —Å–∏—Ö –ø–æ—Ä –º—ã –æ–±—ä—è–≤–ª—è–ª–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, –∫–æ—Ç–æ—Ä—ã–µ –≤—Å–µ–≥–¥–∞ —Å–æ–¥–µ—Ä–∂–∞–ª–∏ –≤–ª–∞–¥–µ–µ–º—ã–µ —Ç–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö. –°—Ç—Ä—É–∫—Ç—É—Ä—ã –º–æ–≥—É—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å –∏ —Å—Å—ã–ª–∫–∏, –Ω–æ –ø—Ä–∏ —ç—Ç–æ–º –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –¥–æ–±–∞–≤–ª—è—Ç—å –∞–Ω–Ω–æ—Ç–∞—Ü–∏–∏ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏ –¥–ª—è –∫–∞–∂–¥–æ–π —Å—Å—ã–ª–∫–∏ –≤ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã. –ü–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –Ω–∞ –õ–∏—Å—Ç–∏–Ω–≥ 10-24, –æ–ø–∏—Å—ã–≤–∞—é—â–∏–π —Å—Ç—Ä—É–∫—Ç—É—Ä—É <code>ImportantExcerpt</code>, —Å–æ–¥–µ—Ä–∂–∞—â—É—é —Å—Ä–µ–∑ —Å—Ç—Ä–æ–∫–∏:</p>
<Listing number="10-24" file-name="src/main.rs" caption="A struct that holds a reference, requiring a lifetime annotation">
<pre><pre class="playground"><code class="language-rust edition2021">struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    let novel = String::from("–ó–æ–≤–∏—Ç–µ –º–µ–Ω—è –ò–∑–º–∞–∏–ª. –ù–µ—Å–∫–æ–ª—å–∫–æ –ª–µ—Ç —Ç–æ–º—É –Ω–∞–∑–∞–¥...");
    let first_sentence = novel.split('.').next().unwrap();
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}</code></pre></pre>
</Listing>
<p>–£ —ç—Ç–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –∏–º–µ–µ—Ç—Å—è –æ–¥–Ω–æ –ø–æ–ª–µ <code>part</code>, —Ö—Ä–∞–Ω—è—â–µ–µ —Å—Ç—Ä–æ–∫–æ–≤—ã–π —Å—Ä–µ–∑, –∫–æ—Ç–æ—Ä—ã–π —Å–∞–º –ø–æ —Å–µ–±–µ —è–≤–ª—è–µ—Ç—Å—è —Å—Å—ã–ª–∫–æ–π. –ö–∞–∫ –∏ –≤ —Å–ª—É—á–∞–µ —Å –æ–±–æ–±—â—ë–Ω–Ω—ã–º–∏ —Ç–∏–ø–∞–º–∏ –¥–∞–Ω–Ω—ã—Ö, –º—ã –æ–±—ä—è–≤–ª—è–µ–º –∏–º—è –æ–±–æ–±—â—ë–Ω–Ω–æ–≥–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏ –≤–Ω—É—Ç—Ä–∏ —É–≥–ª–æ–≤—ã—Ö —Å–∫–æ–±–æ–∫ –ø–æ—Å–ª–µ –∏–º–µ–Ω–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, —á—Ç–æ–±—ã –∏–º–µ—Ç—å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –µ–≥–æ –≤–Ω—É—Ç—Ä–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã. –î–∞–Ω–Ω–∞—è –∞–Ω–Ω–æ—Ç–∞—Ü–∏—è –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ —ç–∫–∑–µ–º–ø–ª—è—Ä <code>ImportantExcerpt</code> –Ω–µ –º–æ–∂–µ—Ç –ø–µ—Ä–µ–∂–∏—Ç—å —Å—Å—ã–ª–∫—É, –∫–æ—Ç–æ—Ä—É—é –æ–Ω —Å–æ–¥–µ—Ä–∂–∏—Ç –≤ —Å–≤–æ—ë–º –ø–æ–ª–µ <code>part</code>.</p>
<p>–§—É–Ω–∫—Ü–∏—è <code>main</code> —Å–æ–∑–¥–∞—ë—Ç —ç–∫–∑–µ–º–ø–ª—è—Ä —Å—Ç—Ä—É–∫—Ç—É—Ä—ã <code>ImportantExcerpt</code>, –∫–æ—Ç–æ—Ä—ã–π —Å–æ–¥–µ—Ä–∂–∏—Ç —Å—Å—ã–ª–∫—É –Ω–∞ –ø–µ—Ä–≤–æ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ —Å—Ç—Ä–æ–∫–∏ <code>String</code>, –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∞—â–µ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π <code>novel</code>. –î–∞–Ω–Ω—ã–µ –≤ <code>novel</code> —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–ª–∏ –¥–æ —Å–æ–∑–¥–∞–Ω–∏—è —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ <code>ImportantExcerpt</code>. –ö—Ä–æ–º–µ —Ç–æ–≥–æ, <code>novel</code> –Ω–µ –º–æ–∂–µ—Ç –≤—ã–π—Ç–∏ –∏–∑ –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏ –¥–æ —Ç–µ—Ö –ø–æ—Ä, –ø–æ–∫–∞ –Ω–µ –≤—ã–π–¥–µ—Ç <code>ImportantExcerpt</code>, –ø–æ—ç—Ç–æ–º—É —Å—Å—ã–ª–∫–∞ –≤–Ω—É—Ç—Ä–∏ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ <code>ImportantExcerpt</code> –≤—Å–µ–≥–¥–∞ –æ—Å—Ç–∞—ë—Ç—Å—è –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ–π.</p>
<h3 id="–ù–µ—è–≤–Ω—ã–π-–≤—ã–≤–æ–¥-–≤—Ä–µ–º–µ–Ω–∏-–∂–∏–∑–Ω–∏"><a class="header" href="#–ù–µ—è–≤–Ω—ã–π-–≤—ã–≤–æ–¥-–≤—Ä–µ–º–µ–Ω–∏-–∂–∏–∑–Ω–∏">–ù–µ—è–≤–Ω—ã–π –≤—ã–≤–æ–¥ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏</a></h3>
<p>–í—ã —É–∑–Ω–∞–ª–∏, —á—Ç–æ —É –∫–∞–∂–¥–æ–π —Å—Å—ã–ª–∫–∏ –µ—Å—Ç—å –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ –∏ —á—Ç–æ –Ω—É–∂–Ω–æ —É–∫–∞–∑—ã–≤–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏ –¥–ª—è —Ñ—É–Ω–∫—Ü–∏–π –∏–ª–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä, –∫–æ—Ç–æ—Ä—ã–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç —Å—Å—ã–ª–∫–∏. –û–¥–Ω–∞–∫–æ –≤ –ì–ª–∞–≤–µ 4 —É –Ω–∞—Å –±—ã–ª–∞ —Ñ—É–Ω–∫—Ü–∏—è –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 4-9, –∫–æ—Ç–æ—Ä–∞—è –∑–∞—Ç–µ–º –±—ã–ª–∞ —Å–Ω–æ–≤–∞ –ø–æ–∫–∞–∑–∞–Ω–∞ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 10-25: –æ–Ω–∞ –∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞–ª–∞—Å—å –±–µ–∑ –∞–Ω–Ω–æ—Ç–∞—Ü–∏–π –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏.</p>
<Listing number="10-25" file-name="src/lib.rs" caption="A function we defined in Listing 4-9 that compiled without lifetime annotations, even though the parameter and return type are references">
<pre><pre class="playground"><code class="language-rust edition2021">fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from("hello world");
</span><span class="boring">
</span><span class="boring">    // first_word –ø—Ä–∏–Ω–∏–º–∞–µ—Ç —Å—Ä–µ–∑—ã –∑–Ω–∞—á–µ–Ω–∏–π —Ç–∏–ø–∞ `String`
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = "hello world";
</span><span class="boring">
</span><span class="boring">    // first_word –ø—Ä–∏–Ω–∏–º–∞–µ—Ç —Å—Ä–µ–∑—ã —Å—Ç—Ä–æ–∫–æ–≤—ã—Ö –ª–∏—Ç–µ—Ä–∞–ª–æ–≤
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // –ü–æ—Å–∫–æ–ª—å–∫—É —Å—Ç—Ä–æ–∫–æ–≤—ã–µ –ª–∏—Ç–µ—Ä–∞–ª—ã *—ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–Ω—ã* —Å—Ä–µ–∑–∞–º —Å—Ç—Ä–æ–∫,
</span><span class="boring">    // —ç—Ç–æ —Ç–æ–∂–µ —Å—Ä–∞–±–æ—Ç–∞–µ—Ç, –±–µ–∑ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –±—Ä–∞—Ç—å —Å—Ä–µ–∑!
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>–ü—Ä–∏—á–∏–Ω–∞, –ø–æ –∫–æ—Ç–æ—Ä–æ–π —ç—Ç–æ—Ç –∫–æ–¥ –∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è ‚Äî –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∞—è. –í —Ä–∞–Ω–Ω–∏—Ö (–¥–æ 1.0) –≤–µ—Ä—Å–∏—è—Ö Rust —ç—Ç–æ—Ç –∫–æ–¥ –Ω–µ —Å–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞–ª—Å—è –±—ã, –ø–æ—Å–∫–æ–ª—å–∫—É –∫–∞–∂–¥–æ–π —Å—Å—ã–ª–∫–µ –Ω—É–∂–Ω–æ –±—ã–ª–æ —è–≤–Ω–æ –Ω–∞–∑–Ω–∞—á–∞—Ç—å –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏. –í —Ç–µ –≤—Ä–µ–º–µ–Ω–∞, —Å–∏–≥–Ω–∞—Ç—É—Ä–∞ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –±—ã–ª–∞ –±—ã –Ω–∞–ø–∏—Å–∞–Ω–∞ –ø—Ä–∏–º–µ—Ä–Ω–æ —Ç–∞–∫:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {</code></pre>
<p>–ü–æ—Å–ª–µ –Ω–∞–ø–∏—Å–∞–Ω–∏—è –±–æ–ª—å—à–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∫–æ–¥–∞ –Ω–∞ Rust —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∏ —è–∑—ã–∫–∞ –æ–±–Ω–∞—Ä—É–∂–∏–ª–∏, —á—Ç–æ –≤ –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã—Ö —Å–∏—Ç—É–∞—Ü–∏—è—Ö –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç—ã –æ–ø–∏—Å—ã–≤–∞—é—Ç –æ–¥–Ω–∏ –∏ —Ç–µ –∂–µ –∞–Ω–Ω–æ—Ç–∞—Ü–∏–∏ –≤—Ä–µ–º—ë–Ω –∂–∏–∑–Ω–∏ —Å–Ω–æ–≤–∞ –∏ —Å–Ω–æ–≤–∞. –≠—Ç–∏ —Å–∏—Ç—É–∞—Ü–∏–∏ –±—ã–ª–∏ –ø—Ä–µ–¥—Å–∫–∞–∑—É–µ–º—ã –∏ —Å–ª–µ–¥–æ–≤–∞–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–∏–º –æ–¥–Ω–æ–∑–Ω–∞—á–Ω—ã–º —à–∞–±–ª–æ–Ω–∞–º. –ö–æ–º–∞–Ω–¥–∞ Rust —Ä–µ—à–∏–ª–∞ –∑–∞–ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞—Ç—å —ç—Ç–∏ —à–∞–±–ª–æ–Ω—ã –≤ –∫–æ–¥ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞ Rust, —á—Ç–æ–±—ã –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–π –º–æ–≥ –≤—ã–≤–æ–¥–∏—Ç—å –≤—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏ –≤ —Ç–∞–∫–∏—Ö —Å–∏—Ç—É–∞—Ü–∏—è—Ö –±–µ–∑ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ —è–≤–Ω–æ–≥–æ —É–∫–∞–∑–∞–Ω–∏—è –∞–Ω–Ω–æ—Ç–∞—Ü–∏–π –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç–∞–º–∏.</p>
<p>–ú—ã —É–ø–æ–º–∏–Ω–∞–µ–º —ç—Ç–æ—Ç —Ñ—Ä–∞–≥–º–µ–Ω—Ç –∏—Å—Ç–æ—Ä–∏–∏ Rust, –ø–æ—Ç–æ–º—É —á—Ç–æ –≤–æ–∑–º–æ–∂–Ω–æ, —á—Ç–æ –≤ –±—É–¥—É—â–µ–º –ø–æ—è–≤–∏—Ç—Å—è –±–æ–ª—å—à–µ —à–∞–±–ª–æ–Ω–æ–≤ –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –≤—ã–≤–µ–¥–µ–Ω–∏—è –≤—Ä–µ–º—ë–Ω –∂–∏–∑–Ω–∏, –∫–æ—Ç–æ—Ä—ã–µ –±—É–¥—É—Ç –¥–æ–±–∞–≤–ª–µ–Ω—ã –≤ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä. –¢–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, –≤ –±—É–¥—É—â–µ–º –º–æ–∂–µ—Ç –ø–æ–Ω–∞–¥–æ–±–∏—Ç—Å—è –µ—â—ë –º–µ–Ω—å—à–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∞–Ω–Ω–æ—Ç–∞—Ü–∏–π.</p>
<p>–®–∞–±–ª–æ–Ω—ã, –∑–∞–ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –≤ –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä–µ —Å—Å—ã–ª–æ–∫ —è–∑—ã–∫–∞ Rust, –Ω–∞–∑—ã–≤–∞—é—Ç—Å—è –ø—Ä–∞–≤–∏–ª–∞–º–∏ <em>–Ω–µ—è–≤–Ω–æ–≥–æ –≤—ã–≤–æ–¥–∞ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏</em>. –≠—Ç–æ –Ω–µ –ø—Ä–∞–≤–∏–ª–∞, –∫–æ—Ç–æ—Ä—ã–º –¥–æ–ª–∂–Ω—ã —Å–ª–µ–¥–æ–≤–∞—Ç—å –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç—ã, –∞ —Ç–æ–ª—å–∫–æ –Ω–∞–±–æ—Ä —á–∞—Å—Ç–Ω—ã—Ö —Å–ª—É—á–∞–µ–≤, –∫–æ—Ç–æ—Ä—ã–µ —Ä–∞—Å—Å–º–æ—Ç—Ä–∏—Ç –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä, –∏, –µ—Å–ª–∏ –≤–∞—à –∫–æ–¥ –ø–æ–ø–∞–¥–∞–µ—Ç –≤ —ç—Ç–∏ —Å–ª—É—á–∞–∏, –≤–∞–º –Ω–µ –Ω—É–∂–Ω–æ –±—É–¥–µ—Ç —É–∫–∞–∑—ã–≤–∞—Ç—å –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ —è–≤–Ω–æ.</p>
<p>–ü—Ä–∞–≤–∏–ª–∞ –≤—ã–≤–æ–¥–∞ —Ä–∞–±–æ—Ç–∞—é—Ç –¥–∞–ª–µ–∫–æ –Ω–µ –≤–µ–∑–¥–µ –∏ –Ω–µ –≤—Å–µ–≥–¥–∞. –ï—Å–ª–∏ –ø–æ—Å–ª–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –ø—Ä–∞–≤–∏–ª –≤—ã–≤–æ–¥–∞ –≤—Å—ë –µ—â—ë –æ—Å—Ç–∞–µ—Ç—Å—è –Ω–µ–æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ—Å—Ç—å –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏ —Å—Å—ã–ª–æ–∫, –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –Ω–µ –±—É–¥–µ—Ç –¥–æ–≥–∞–¥—ã–≤–∞—Ç—å—Å—è, –∫–∞–∫–∏–º–∏ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏ –æ—Å—Ç–∞–≤—à–∏—Ö—Å—è —Å—Å—ã–ª–æ–∫. –í —ç—Ç–æ–º —Å–ª—É—á–∞–µ, –≤–º–µ—Å—Ç–æ —É–≥–∞–¥—ã–≤–∞–Ω–∏—è –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –≤—ã–¥–∞—Å—Ç –æ—à–∏–±–∫—É, –∫–æ—Ç–æ—Ä—É—é –≤—ã –º–æ–∂–µ—Ç–µ —É—Å—Ç—Ä–∞–Ω–∏—Ç—å, –¥–æ–±–∞–≤–∏–≤ –∞–Ω–Ω–æ—Ç–∞—Ü–∏–∏ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏.</p>
<p>–í—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏ –∏–ª–∏ –º–µ—Ç–æ–¥–∞ –Ω–∞–∑—ã–≤–∞—é—Ç—Å—è <em>–≤—Ä–µ–º–µ–Ω–∞–º–∏ –∂–∏–∑–Ω–∏ –≤–≤–æ–¥–∞</em>, –∞ –≤—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π ‚Äî <em>–≤—Ä–µ–º–µ–Ω–∞–º–∏ –∂–∏–∑–Ω–∏ –≤—ã–≤–æ–¥–∞</em>.</p>
<p>–ö–æ–º–ø–∏–ª—è—Ç–æ—Ä –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —Ç—Ä–∏ –ø—Ä–∞–≤–∏–ª–∞, —á—Ç–æ–±—ã –≤—ã—è—Å–Ω—è—Ç—å –≤—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏ —Å—Å—ã–ª–æ–∫ –ø—Ä–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–∏ —è–≤–Ω—ã—Ö –∞–Ω–Ω–æ—Ç–∞—Ü–∏–π. –ü–µ—Ä–≤–æ–µ –ø—Ä–∞–≤–∏–ª–æ –æ—Ç–Ω–æ—Å–∏—Ç—Å—è –∫–æ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏ –≤–≤–æ–¥–∞, –≤—Ç–æ—Ä–æ–µ –∏ —Ç—Ä–µ—Ç—å–µ –ø—Ä–∞–≤–∏–ª–∞ –ø—Ä–∏–º–µ–Ω—è—é—Ç—Å—è –∫–æ –≤—Ä–µ–º–µ–Ω–∞–º –∂–∏–∑–Ω–∏ –≤—ã–≤–æ–¥–∞. –ï—Å–ª–∏ –ø—Ä–æ–≤–µ—Ä–∏–ª –≤—Å–µ —Ç—Ä–∏ –ø—Ä–∞–≤–∏–ª–∞, –Ω–æ –≤—Å—ë –µ—â—ë –µ—Å—Ç—å —Å—Å—ã–ª–∫–∏, –¥–ª—è –∫–æ—Ç–æ—Ä—ã—Ö –æ–Ω –Ω–µ –º–æ–∂–µ—Ç –æ–¥–Ω–æ–∑–Ω–∞—á–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏, –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –≤—ã–¥–∞—Å—Ç –æ—à–∏–±–∫—É. –≠—Ç–∏ –ø—Ä–∞–≤–∏–ª–∞ –ø—Ä–∏–º–µ–Ω—è—é—Ç—Å—è –∫ –æ–±—ä—è–≤–ª–µ–Ω–∏—è–º <code>fn</code> –∏ –±–ª–æ–∫–∞–º <code>impl</code>.</p>
<p>–ü–µ—Ä–≤–æ–µ –ø—Ä–∞–≤–∏–ª–æ –≥–æ–≤–æ—Ä–∏—Ç, —á—Ç–æ –∫–∞–∂–¥—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä, —è–≤–ª—è—é—â–∏–π—Å—è —Å—Å—ã–ª–∫–æ–π, –ø–æ–ª—É—á–∞–µ—Ç —Å–≤–æ–π —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏. –î—Ä—É–≥–∏–º–∏ —Å–ª–æ–≤–∞–º–∏, —Ñ—É–Ω–∫—Ü–∏—è —Å –æ–¥–Ω–∏–º –∞—Ä–≥—É–º–µ–Ω—Ç–æ–º –ø–æ–ª—É—á–∏—Ç –æ–¥–∏–Ω –ø–∞—Ä–∞–º–µ—Ç—Ä –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏: <code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>; —Ñ—É–Ω–∫—Ü–∏—è —Å –¥–≤—É–º—è –∞—Ä–≥—É–º–µ–Ω—Ç–∞–º–∏ –ø–æ–ª—É—á–∏—Ç –¥–≤–∞ –æ—Ç–¥–µ–ª—å–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏: <code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>; –∏ —Ç–∞–∫ –¥–∞–ª–µ–µ.</p>
<p>–í—Ç–æ—Ä–æ–µ –ø—Ä–∞–≤–∏–ª–æ –≥–æ–≤–æ—Ä–∏—Ç, —á—Ç–æ –µ—Å–ª–∏ –µ—Å—Ç—å —Ä–æ–≤–Ω–æ –æ–¥–∏–Ω –ø–∞—Ä–∞–º–µ—Ç—Ä –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏ –≤–≤–æ–¥–∞, —Ç–æ –µ–≥–æ –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ –Ω–∞–∑–Ω–∞—á–∞–µ—Ç—Å—è –≤—Å–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏ –≤—ã–≤–æ–¥–∞: <code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>.</p>
<p>–¢—Ä–µ—Ç—å–µ –ø—Ä–∞–≤–∏–ª–æ –≥–æ–≤–æ—Ä–∏—Ç, —á—Ç–æ –µ—Å–ª–∏ –µ—Å—Ç—å –º–Ω–æ–∂–µ—Å—Ç–≤–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏ –≤–≤–æ–¥–∞, –Ω–æ –æ–¥–∏–Ω –∏–∑ –Ω–∏—Ö —è–≤–ª—è–µ—Ç—Å—è <code>&amp;self</code> –∏–ª–∏ <code>&amp;mut self</code>, —Ç–∞–∫ –∫–∞–∫ —ç—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è —è–≤–ª—è–µ—Ç—Å—è –º–µ—Ç–æ–¥–æ–º, —Ç–æ –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ <code>self</code> –Ω–∞–∑–Ω–∞—á–∞–µ—Ç—Å—è –≤—Ä–µ–º–µ–Ω–µ–º –∂–∏–∑–Ω–∏ –≤—Å–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏ –≤—ã–≤–æ–¥–∞. –≠—Ç–æ —Ç—Ä–µ—Ç—å–µ –ø—Ä–∞–≤–∏–ª–æ –¥–µ–ª–∞–µ—Ç –º–µ—Ç–æ–¥—ã –Ω–∞–º–Ω–æ–≥–æ –ø—Ä–∏—è—Ç–Ω–µ–µ –¥–ª—è —á—Ç–µ–Ω–∏—è –∏ –∑–∞–ø–∏—Å–∏, –ø–æ—Ç–æ–º—É —á—Ç–æ —Ç—Ä–µ–±—É–µ—Ç—Å—è –º–µ–Ω—å—à–µ —Å–∏–º–≤–æ–ª–æ–≤.</p>
<p>–ü—Ä–µ–¥—Å—Ç–∞–≤–∏–º, —á—Ç–æ –º—ã ‚Äî –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä. –ü—Ä–∏–º–µ–Ω–∏–º —ç—Ç–∏ –ø—Ä–∞–≤–∏–ª–∞, —á—Ç–æ–±—ã –≤—ã–≤–µ—Å—Ç–∏ –≤—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏ —Å—Å—ã–ª–æ–∫ –≤ —Å–∏–≥–Ω–∞—Ç—É—Ä–µ —Ñ—É–Ω–∫—Ü–∏–∏ <code>first_word</code> –∏–∑ –õ–∏—Å—Ç–∏–Ω–≥–∞ 10-25. –°–∏–≥–Ω–∞—Ç—É—Ä–∞ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è –±–µ–∑ –æ–±—ä—è–≤–ª–µ–Ω–∏—è –≤—Ä–µ–º—ë–Ω –∂–∏–∑–Ω–∏ —Å—Å—ã–ª–æ–∫:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {</code></pre>
<p>–¢–µ–ø–µ—Ä—å –º—ã –ø—Ä–∏–º–µ–Ω–∏–º –ø–µ—Ä–≤–æ–µ –ø—Ä–∞–≤–∏–ª–æ, —É—Ç–≤–µ—Ä–∂–¥–∞—é—â–µ–µ, —á—Ç–æ –∫–∞–∂–¥—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä —Ñ—É–Ω–∫—Ü–∏–∏ –ø–æ–ª—É—á–∞–µ—Ç —Å–≤–æ—ë —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ–µ –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏. –ö–∞–∫ –æ–±—ã—á–Ω–æ, –Ω–∞–∑–æ–≤—ë–º –µ–≥–æ <code>'a</code>, –∏ —Ç–µ–ø–µ—Ä—å —Å–∏–≥–Ω–∞—Ç—É—Ä–∞ –≤—ã–≥–ª—è–¥–∏—Ç —Ç–∞–∫:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {</code></pre>
<p>–î–∞–ª–µ–µ –ø—Ä–∏–º–µ–Ω—è–µ–º –≤—Ç–æ—Ä–æ–µ –ø—Ä–∞–≤–∏–ª–æ, –ø–æ—Å–∫–æ–ª—å–∫—É –≤ —Ñ—É–Ω–∫—Ü–∏–∏ —É–∫–∞–∑–∞–Ω —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω –≤—Ö–æ–¥–Ω–æ–π –ø–∞—Ä–∞–º–µ—Ç—Ä –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏. –í—Ç–æ—Ä–æ–µ –ø—Ä–∞–≤–∏–ª–æ –≥–ª–∞—Å–∏—Ç, —á—Ç–æ –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –≤—Ö–æ–¥–Ω–æ–≥–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –Ω–∞–∑–Ω–∞—á–∞–µ—Ç—Å—è –≤—ã—Ö–æ–¥–Ω—ã–º –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º, –ø–æ—ç—Ç–æ–º—É —Å–∏–≥–Ω–∞—Ç—É—Ä–∞ —Ç–µ–ø–µ—Ä—å —è–≤–ª—è–µ—Ç—Å—è —Ç–∞–∫–æ–π:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {</code></pre>
<p>–¢–µ–ø–µ—Ä—å –≤—Å–µ —Å—Å—ã–ª–∫–∏ –≤ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –∏–º–µ—é—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏ –∏ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –º–æ–∂–µ—Ç –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å —Å–≤–æ–π –∞–Ω–∞–ª–∏–∑ –±–µ–∑ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –ø—Ä–æ—Å–∏—Ç—å —É –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç–∞ —É–∫–∞–∑–∞—Ç—å –∞–Ω–Ω–æ—Ç–∞—Ü–∏–∏ –≤—Ä–µ–º—ë–Ω –∂–∏–∑–Ω–∏ –≤ —Å–∏–≥–Ω–∞—Ç—É—Ä–µ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏.</p>
<p>–î–∞–≤–∞–π—Ç–µ —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º –µ—â—ë –æ–¥–∏–Ω –ø—Ä–∏–º–µ—Ä: –Ω–∞ —ç—Ç–æ—Ç —Ä–∞–∑, —Ñ—É–Ω–∫—Ü–∏—é <code>longest</code>, –≤ –∫–æ—Ç–æ—Ä–æ–π –Ω–µ –±—ã–ª–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏, –∫–æ–≥–¥–∞ –º—ã –Ω–∞—á–∞–ª–∏ —Å –Ω–µ–π —Ä–∞–±–æ—Ç–∞—Ç—å –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 10-20:</p>
<pre><code class="language-rust ignore">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {</code></pre>
<p>–ü—Ä–∏–º–µ–Ω–∏–º –ø–µ—Ä–≤–æ–µ –ø—Ä–∞–≤–∏–ª–æ: –∫–∞–∂–¥–æ–º—É –ø–∞—Ä–∞–º–µ—Ç—Ä—É –Ω–∞–∑–Ω–∞—á–∞–µ—Ç—Å—è —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ–µ –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏. –ù–∞ —ç—Ç–æ—Ç —Ä–∞–∑ —É —Ñ—É–Ω–∫—Ü–∏–∏ –µ—Å—Ç—å –¥–≤–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞, –ø–æ—ç—Ç–æ–º—É –µ—Å—Ç—å –¥–≤–∞ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏:</p>
<pre><code class="language-rust ignore">fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {</code></pre>
<p>–ú–æ–∂–Ω–æ –∑–∞–º–µ—Ç–∏—Ç—å, —á—Ç–æ –≤—Ç–æ—Ä–æ–µ –ø—Ä–∞–≤–∏–ª–æ –∑–¥–µ—Å—å –Ω–µ–ø—Ä–∏–º–µ–Ω–∏–º–æ, —Ç–∞–∫ –∫–∞–∫ –≤ —Å–∏–≥–Ω–∞—Ç—É—Ä–µ —É–∫–∞–∑–∞–Ω–æ –±–æ–ª—å—à–µ –æ–¥–Ω–æ–≥–æ –≤—Ö–æ–¥–Ω–æ–≥–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏. –¢—Ä–µ—Ç—å–µ –ø—Ä–∞–≤–∏–ª–æ —Ç–∞–∫–∂–µ –Ω–µ–ø—Ä–∏–º–µ–Ω–∏–º–æ, —Ç–∞–∫ –∫–∞–∫ <code>longest</code> ‚Äî —Ñ—É–Ω–∫—Ü–∏—è, –∞ –Ω–µ –º–µ—Ç–æ–¥, –∞ –∑–Ω–∞—á–∏—Ç, –≤ –Ω–µ–π –Ω–µ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ <code>self</code>. –ò—Ç–∞–∫, –º—ã –ø—Ä–æ—à–ª–∏ –≤—Å–µ —Ç—Ä–∏ –ø—Ä–∞–≤–∏–ª–∞, –Ω–æ —Ç–∞–∫ –∏ –Ω–µ —Å–º–æ–≥–ª–∏ –≤—ã—á–∏—Å–ª–∏—Ç—å –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ –≤—ã—Ö–æ–¥–Ω–æ–≥–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞. –ü–æ—ç—Ç–æ–º—É –º—ã –∏ –ø–æ–ª—É—á–∏–ª–∏ –æ—à–∏–±–∫—É –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ —Å–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞—Ç—å –∫–æ–¥ –õ–∏—Å—Ç–∏–Ω–≥–∞ 10-20: –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä —Ä–∞–±–æ—Ç–∞–ª –ø–æ –ø—Ä–∞–≤–∏–ª–∞–º –Ω–µ—è–≤–Ω–æ–≥–æ –≤—ã–≤–æ–¥–∞ –≤—Ä–µ–º—ë–Ω –∂–∏–∑–Ω–∏, –Ω–æ –Ω–µ –º–æ–≥ –≤—ã—è—Å–Ω–∏—Ç—å –≤—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏ –≤—Å–µ—Ö —Å—Å—ã–ª–æ–∫ –≤ —Å–∏–≥–Ω–∞—Ç—É—Ä–µ.</p>
<p>–¢–∞–∫ –∫–∞–∫ —Ç—Ä–µ—Ç—å–µ –ø—Ä–∞–≤–∏–ª–æ –ø—Ä–∏–º–µ–Ω—è–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –∫ –º–µ—Ç–æ–¥–∞–º, –¥–∞–ª–µ–µ –º—ã —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º –≤—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏ –≤ –∏—Ö –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ, —á—Ç–æ–±—ã –ø–æ–Ω—è—Ç—å, –ø–æ—á–µ–º—É –Ω–∞–º —á–∞—Å—Ç–æ –Ω–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è –∞–Ω–Ω–æ—Ç–∏—Ä–æ–≤–∞—Ç—å –≤—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏ –≤ —Å–∏–≥–Ω–∞—Ç—É—Ä–∞—Ö –º–µ—Ç–æ–¥–æ–≤.</p>
<h3 id="–ê–Ω–Ω–æ—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ-–≤—Ä–µ–º—ë–Ω-–∂–∏–∑–Ω–∏-–≤-–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–∏-–º–µ—Ç–æ–¥–æ–≤"><a class="header" href="#–ê–Ω–Ω–æ—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ-–≤—Ä–µ–º—ë–Ω-–∂–∏–∑–Ω–∏-–≤-–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–∏-–º–µ—Ç–æ–¥–æ–≤">–ê–Ω–Ω–æ—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Ä–µ–º—ë–Ω –∂–∏–∑–Ω–∏ –≤ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–∏ –º–µ—Ç–æ–¥–æ–≤</a></h3>
<p>–ö–æ–≥–¥–∞ –º—ã —Ä–µ–∞–ª–∏–∑—É–µ–º –º–µ—Ç–æ–¥—ã –¥–ª—è —Å—Ç—Ä—É–∫—Ç—É—Ä —Å –≤—Ä–µ–º–µ–Ω–∞–º–∏ –∂–∏–∑–Ω–∏, –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ—Ç –∂–µ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å, –∫–æ—Ç–æ—Ä—ã–π –ø—Ä–∏–º–µ–Ω—è–ª—Å—è –¥–ª—è –æ–±–æ–±—â—ë–Ω–Ω—ã—Ö —Ç–∏–ø–æ–≤ –¥–∞–Ω–Ω—ã—Ö, –∫–∞–∫ –±—ã–ª–æ –ø–æ–∫–∞–∑–∞–Ω–æ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 10-11. –ú–µ—Å—Ç–æ, –≥–¥–µ –º—ã –æ–±—ä—è–≤–ª—è–µ–º –∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º –≤—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏, –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Ç–æ–≥–æ, —Å —á–µ–º –æ–Ω–∏ —Å–≤—è–∑–∞–Ω—ã ‚Äî —Å –ø–æ–ª—è–º–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –∏–ª–∏ —Å –∞—Ä–≥—É–º–µ–Ω—Ç–∞–º–∏ –º–µ—Ç–æ–¥–æ–≤ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏.</p>
<p>–ò–º–µ–Ω–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏ –¥–ª—è –ø–æ–ª–µ–π —Å—Ç—Ä—É–∫—Ç—É—Ä –≤—Å–µ–≥–¥–∞ –æ–ø–∏—Å—ã–≤–∞—é—Ç—Å—è –ø–æ—Å–ª–µ –∫–ª—é—á–µ–≤–æ–≥–æ —Å–ª–æ–≤–∞ <code>impl</code> –∏ –∑–∞—Ç–µ–º –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –ø–æ—Å–ª–µ –∏–º–µ–Ω–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, –ø–æ—Å–∫–æ–ª—å–∫—É —ç—Ç–∏ –≤—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏ —è–≤–ª—è—é—Ç—Å—è —á–∞—Å—Ç—å—é —Ç–∏–ø–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã.</p>
<p>–í —Å–∏–≥–Ω–∞—Ç—É—Ä–∞—Ö –º–µ—Ç–æ–¥–æ–≤ –≤–Ω—É—Ç—Ä–∏ –±–ª–æ–∫–∞ <code>impl</code> —Å—Å—ã–ª–∫–∏ –º–æ–≥—É—Ç –±—ã—Ç—å –ø—Ä–∏–≤—è–∑–∞–Ω—ã –∫–æ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏ —Å—Å—ã–ª–æ–∫ –≤ –ø–æ–ª—è—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, –ª–∏–±–æ –º–æ–≥—É—Ç –±—ã—Ç—å –Ω–µ–∑–∞–≤–∏—Å–∏–º—ã–º–∏. –í–¥–æ–±–∞–≤–æ–∫, –ø—Ä–∞–≤–∏–ª–∞ –Ω–µ—è–≤–Ω–æ–≥–æ –≤—ã–≤–æ–¥–∞ –≤—Ä–µ–º—ë–Ω –∂–∏–∑–Ω–∏ —á–∞—Å—Ç–æ –¥–µ–ª–∞—é—Ç —Ç–∞–∫, —á—Ç–æ –∞–Ω–Ω–æ—Ç–∞—Ü–∏–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –≤—Ä–µ–º—ë–Ω –∂–∏–∑–Ω–∏ —è–≤–ª—è—é—Ç—Å—è –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–º–∏ –≤ —Å–∏–≥–Ω–∞—Ç—É—Ä–∞—Ö –º–µ—Ç–æ–¥–æ–≤. –†–∞—Å—Å–º–æ—Ç—Ä–∏–º –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø—Ä–∏–º–µ—Ä–æ–≤, –∏—Å–ø–æ–ª—å–∑—É—é—â–∏—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä—É —Å –Ω–∞–∑–≤–∞–Ω–∏–µ–º <code>ImportantExcerpt</code>, –∫–æ—Ç–æ—Ä—É—é –º—ã –æ–ø—Ä–µ–¥–µ–ª–∏–ª–∏ –≤ –õ–∏—Å—Ç–∏–Ω–≥–µ 10-24.</p>
<p>–°–Ω–∞—á–∞–ª–∞, –æ–ø—Ä–µ–¥–µ–ª–∏–º –º–µ—Ç–æ–¥–æ–º <code>level</code>, —á—å–∏–º –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–º –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–º —è–≤–ª—è–µ—Ç—Å—è —Å—Å—ã–ª–∫–∞ –Ω–∞ <code>self</code>, –∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º ‚Äî <code>i32</code> (—Ç–æ –µ—Å—Ç—å –Ω–µ —Å—Å—ã–ª–∫–∞ –Ω–∞ —á—Ç–æ –±—ã —Ç–æ –Ω–∏ –±—ã–ª–æ):</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}
<span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
</span><span class="boring">        println!("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ: {announcement}");
</span><span class="boring">        self.part
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from("–ó–æ–≤–∏—Ç–µ –º–µ–Ω—è –ò–∑–º–∞–∏–ª. –ù–µ—Å–∫–æ–ª—å–∫–æ –ª–µ—Ç —Ç–æ–º—É –Ω–∞–∑–∞–¥...");
</span><span class="boring">    let first_sentence = novel.split('.').next().unwrap();
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}</span></code></pre></pre>
<p>–û–±—ä—è–≤–ª–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏ –ø–æ—Å–ª–µ <code>impl</code> –∏ –µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø–æ—Å–ª–µ –∏–º–µ–Ω–∏ —Ç–∏–ø–∞ —è–≤–ª—è–µ—Ç—Å—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–º, –Ω–æ –Ω–∞–º –Ω–µ –Ω—É–∂–Ω–æ –∞–Ω–Ω–æ—Ç–∏—Ä–æ–≤–∞—Ç—å –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ —Å—Å—ã–ª–∫–∏ –Ω–∞ <code>self</code>, –±–ª–∞–≥–æ–¥–∞—Ä—è –ø–µ—Ä–≤–æ–º—É –ø—Ä–∞–≤–∏–ª—É –Ω–µ—è–≤–Ω–æ–≥–æ –≤—ã–≤–æ–¥–∞ –≤—Ä–µ–º—ë–Ω –∂–∏–∑–Ω–∏.</p>
<p>–í–æ—Ç –ø—Ä–∏–º–µ—Ä, –≥–¥–µ –ø—Ä–∏–º–µ–Ω—è–µ—Ç—Å—è —Ç—Ä–µ—Ç—å–µ –ø—Ä–∞–≤–∏–ª–æ –Ω–µ—è–≤–Ω–æ–≥–æ –≤—ã–≤–æ–¥–∞ –≤—Ä–µ–º—ë–Ω –∂–∏–∑–Ω–∏:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn level(&amp;self) -&gt; i32 {
</span><span class="boring">        3
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        println!("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ: {announcement}");
        self.part
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from("–ó–æ–≤–∏—Ç–µ –º–µ–Ω—è –ò–∑–º–∞–∏–ª. –ù–µ—Å–∫–æ–ª—å–∫–æ –ª–µ—Ç —Ç–æ–º—É –Ω–∞–∑–∞–¥...");
</span><span class="boring">    let first_sentence = novel.split('.').next().unwrap();
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}</span></code></pre></pre>
<p>–í —ç—Ç–æ–º –º–µ—Ç–æ–¥–µ –∏–º–µ–µ—Ç—Å—è –¥–≤–∞ –≤—Ö–æ–¥–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–∞, –ø–æ—ç—Ç–æ–º—É Rust –ø—Ä–∏–º–µ–Ω–∏—Ç –ø–µ—Ä–≤–æ–µ –ø—Ä–∞–≤–∏–ª–æ –∏ –Ω–∞–∑–Ω–∞—á–∏—Ç –æ–±–æ–∏–º –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º <code>&amp;self</code> –∏ <code>announcement</code> —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ –≤—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏. –î–∞–ª–µ–µ, –ø–æ—Å–∫–æ–ª—å–∫—É –æ–¥–∏–Ω –∏–∑ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ —è–≤–ª—è–µ—Ç—Å—è <code>&amp;self</code>, —Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ–ª—É—á–∞–µ—Ç –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ –ø–µ—Ä–µ–º–µ–Ω–æ–π <code>&amp;self</code>. –ì–æ—Ç–æ–≤–æ ‚Äî –≤—Å–µ –≤—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏ —Ç–µ–ø–µ—Ä—å –≤—ã–≤–µ–¥–µ–Ω—ã.</p>
<h3 id="–í—Ä–µ–º—è-–∂–∏–∑–Ω–∏-static"><a class="header" href="#–í—Ä–µ–º—è-–∂–∏–∑–Ω–∏-static">–í—Ä–µ–º—è –∂–∏–∑–Ω–∏ <code>'static</code></a></h3>
<p>–û–¥–Ω–æ –æ—Å–æ–±–µ–Ω–Ω–æ–µ –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏, –∫–æ—Ç–æ—Ä–æ–µ –º—ã –¥–æ–ª–∂–Ω—ã –æ–±—Å—É–¥–∏—Ç—å ‚Äî —ç—Ç–æ <code>'static</code>. –û–Ω–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –¥–∞–Ω–Ω–∞—è —Å—Å—ã–ª–∫–∞ <em>–º–æ–∂–µ—Ç</em> –∂–∏—Ç—å –≤—Å—é –ø—Ä–æ–¥–æ–ª–∂–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Ä–∞–±–æ—Ç—ã –ø—Ä–æ–≥—Ä–∞–º–º—ã. –í—Å–µ —Å—Ç—Ä–æ–∫–æ–≤—ã–µ –ª–∏—Ç–µ—Ä–∞–ª—ã –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –∏–º–µ—é—Ç –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ <code>'static</code>, –Ω–æ –º—ã –º–æ–∂–µ–º —É–∫–∞–∑–∞—Ç—å –µ–≥–æ –∏ —è–≤–Ω–æ:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;'static str = "–Ø –±—É–¥—É –∑–¥–µ—Å—å –≤—Å—ë –≤—Ä–µ–º—è.";
<span class="boring">}</span></code></pre></pre>
<p>–°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ —ç—Ç–æ–π —Å—Ç—Ä–æ–∫–∏ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è –≤–Ω—É—Ç—Ä–∏ –±–∏–Ω–∞—Ä–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ –ø—Ä–æ–≥—Ä–∞–º–º—ã –∏ –≤—Å–µ–≥–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–æ –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è. –°–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ, –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ –≤—Å–µ—Ö —Å—Ç—Ä–æ–∫–æ–≤—ã—Ö –ª–∏—Ç–µ—Ä–∞–ª–æ–≤ ‚Äî <code>'static</code>.</p>
<p>–°–æ–æ–±—â–µ–Ω–∏—è –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞ –æ–± –æ—à–∏–±–∫–∞—Ö –º–æ–≥—É—Ç –ø—Ä–µ–¥–ª–∞–≥–∞—Ç—å –≤–∞–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤ –∫–∞—á–µ—Å—Ç–≤–µ —Ä–µ—à–µ–Ω–∏—è –ø—Ä–æ–±–ª–µ–º –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ <code>'static</code>. –ù–æ –ø—Ä–µ–∂–¥–µ —á–µ–º —É–∫–∞–∑—ã–≤–∞—Ç—å <code>'static</code> –∫–∞–∫ –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ –¥–ª—è —Å—Å—ã–ª–∫–∏, –ø–æ–¥—É–º–∞–π—Ç–µ, –Ω–∞ —Å–∞–º–æ–º –ª–∏ –¥–µ–ª–µ –¥–∞–Ω–Ω–∞—è —Å—Å—ã–ª–∫–∞ –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–∞ –≤–æ –≤—Å—ë –≤—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã –ø—Ä–æ–≥—Ä–∞–º–º—ã. –í –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–µ —Å–ª—É—á–∞–µ–≤, —Å–æ–æ–±—â–µ–Ω–∏—è –æ–± –æ—à–∏–±–∫–∞—Ö, –ø—Ä–µ–¥–ª–∞–≥–∞—é—â–∏–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ <code>'static</code>, –ø–æ—è–≤–ª—è—é—Ç—Å—è –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–∞—Ö —Å–æ–∑–¥–∞–Ω–∏—è –≤–∏—Å—è—á–∏—Ö —Å—Å—ã–ª–æ–∫ –∏–ª–∏ –Ω–µ—Å–æ–≤–ø–∞–¥–µ–Ω–∏—è –∏–º–µ—é—â–∏—Ö—Å—è –≤—Ä–µ–º—ë–Ω –∂–∏–∑–Ω–∏. –í —Ç–∞–∫–∏—Ö —Å–ª—É—á–∞—è—Ö, —Ä–µ—à–µ–Ω–∏–µ –∑–∞–∫–ª—é—á–∞–µ—Ç—Å—è –≤ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ —Ç–∞–∫–∏—Ö –ø—Ä–æ–±–ª–µ–º, –∞ –Ω–µ –≤ —É–∫–∞–∑–∞–Ω–∏–∏ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏ <code>'static</code>.</p>
<h2 id="–ü–∞—Ä–∞–º–µ—Ç—Ä—ã-–æ–±–æ–±—â—ë–Ω–Ω—ã—Ö-—Ç–∏–ø–æ–≤-–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è-–ø–æ-—Ç—Ä–µ–π—Ç–∞–º-–∏-–≤—Ä–µ–º–µ–Ω–∞-–∂–∏–∑–Ω–∏--–≤—Å–µ-–≤–º–µ—Å—Ç–µ"><a class="header" href="#–ü–∞—Ä–∞–º–µ—Ç—Ä—ã-–æ–±–æ–±—â—ë–Ω–Ω—ã—Ö-—Ç–∏–ø–æ–≤-–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è-–ø–æ-—Ç—Ä–µ–π—Ç–∞–º-–∏-–≤—Ä–µ–º–µ–Ω–∞-–∂–∏–∑–Ω–∏--–≤—Å–µ-–≤–º–µ—Å—Ç–µ">–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –æ–±–æ–±—â—ë–Ω–Ω—ã—Ö —Ç–∏–ø–æ–≤, –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –ø–æ —Ç—Ä–µ–π—Ç–∞–º –∏ –≤—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏ ‚Äî –≤—Å–µ –≤–º–µ—Å—Ç–µ</a></h2>
<p>–î–∞–≤–∞–π—Ç–µ –∫—Ä–∞—Ç–∫–æ —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –∑–∞–¥–∞–Ω–∏—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –æ–±–æ–±—â—ë–Ω–Ω—ã—Ö —Ç–∏–ø–æ–≤, –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π –ø–æ —Ç—Ä–µ–π—Ç–∞–º –∏ –≤—Ä–µ–º—ë–Ω –∂–∏–∑–Ω–∏ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –≤ –æ–¥–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏!</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest_with_an_announcement(
</span><span class="boring">        string1.as_str(),
</span><span class="boring">        string2,
</span><span class="boring">        "–°–µ–≥–æ–¥–Ω—è –∫—Ç–æ-—Ç–æ ‚Äî –∏–º–µ–Ω–∏–Ω–Ω–∏–∫!",
</span><span class="boring">    );
</span><span class="boring">    println!("–°–∞–º–∞—è –¥–ª–∏–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞: {result}");
</span><span class="boring">}
</span><span class="boring">
</span>use std::fmt::Display;

fn longest_with_an_announcement&lt;'a, T&gt;(
    x: &amp;'a str,
    y: &amp;'a str,
    ann: T,
) -&gt; &amp;'a str
where
    T: Display,
{
    println!("–í–Ω–∏–º–∞–Ω–∏–µ! {ann}");
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}</code></pre></pre>
<p>–≠—Ç–æ ‚Äî —Ñ—É–Ω–∫—Ü–∏—è <code>longest</code> –∏–∑ –õ–∏—Å—Ç–∏–Ω–≥–∞ 10-21, –∫–æ—Ç–æ—Ä–∞—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –Ω–∞–∏–±–æ–ª—å—à–∏–π –∏–∑ –¥–≤—É—Ö —Å—Ç—Ä–æ–∫–æ–≤—ã—Ö —Å—Ä–µ–∑–æ–≤. –ù–æ —Ç–µ–ø–µ—Ä—å —É –Ω–µ—ë –µ—Å—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä —Å –∏–º–µ–Ω–µ–º <code>ann</code> –æ–±–æ–±—â—ë–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞ <code>T</code>, –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω –ª—é–±—ã–º —Ç–∏–ø–æ–º, —Ä–µ–∞–ª–∏–∑—É—é—â–∏–º —Ç—Ä–µ–π—Ç <code>Display</code>, –∫–∞–∫ —É–∫–∞–∑–∞–Ω–æ –∑–∞ <code>where</code>. –≠—Ç–æ—Ç –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä –±—É–¥–µ—Ç –ø–µ—á–∞—Ç–∞—Ç—å—Å—è —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º <code>{}</code>,  b –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ —Ç—Ä–µ–π—Ç—É <code>Display</code>. –ü–æ—Å–∫–æ–ª—å–∫—É –≤—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏ —è–≤–ª—è—é—Ç—Å—è –æ–±–æ–±—â–µ–Ω–∏—è–º–∏, —Ç–æ –æ–±—ä—è–≤–ª–µ–Ω–∏—è –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏ <code>'a</code> –∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –æ–±–æ–±—â—ë–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞ <code>T</code> –ø–æ–º–µ—â–∞—é—Ç—Å—è –≤ –æ–¥–∏–Ω —Å–ø–∏—Å–æ–∫ –≤–Ω—É—Ç—Ä–∏ —É–≥–ª–æ–≤—ã—Ö —Å–∫–æ–±–æ–∫ –ø–æ—Å–ª–µ –∏–º–µ–Ω–∏ —Ñ—É–Ω–∫—Ü–∏–∏.</p>
<h2 id="–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-9"><a class="header" href="#–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-9">–ü–æ–¥–≤–µ–¥—ë–º –∏—Ç–æ–≥–∏</a></h2>
<p>–í —ç—Ç–æ–π –≥–ª–∞–≤–µ –º—ã —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–ª–∏ –º–Ω–æ–≥–æ –≤—Å–µ–≥–æ! –¢–µ–ø–µ—Ä—å –≤—ã –∑–Ω–∞–∫–æ–º—ã —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ –æ–±–æ–±—â—ë–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞, —Å —Ç—Ä–µ–π—Ç–∞–º–∏ –∏ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è–º–∏ –ø–æ —Ç—Ä–µ–π—Ç–∞–º, —Å –æ–±–æ–±—â—ë–Ω–Ω—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏. –û—Ç–Ω—ã–Ω–µ –≤—ã —Å–ø–æ—Å–æ–±–Ω—ã –ø–∏—Å–∞—Ç—å –∫–æ–¥ –±–µ–∑ –∏–∑–±—ã—Ç–æ—á–Ω–æ—Å—Ç–µ–π, –∫–æ—Ç–æ—Ä—ã–π –±—É–¥–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –≤–æ –º–Ω–æ–∂–µ—Å—Ç–≤–µ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Å–∏—Ç—É–∞—Ü–∏–π. –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –æ–±–æ–±—â—ë–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞ –ø–æ–∑–≤–æ–ª—è—é—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–æ–¥ –¥–ª—è —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Ç–∏–ø–æ–≤ –¥–∞–Ω–Ω—ã—Ö. –¢—Ä–µ–π—Ç—ã –∏ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –ø–æ —Ç—Ä–µ–π—Ç–∞–º –ø–æ–º–æ–≥–∞—é—Ç —É–±–µ–¥–∏—Ç—å—Å—è, —á—Ç–æ, —Ö–æ—Ç—è —Ç–∏–ø—ã –∏ –æ–±–æ–±—â—ë–Ω–Ω—ã–µ, –æ–Ω–∏ –±—É–¥—É—Ç –≤–µ—Å—Ç–∏ —Å–µ–±—è, –∫–∞–∫ —ç—Ç–æ–≥–æ —Ç—Ä–µ–±—É–µ—Ç –≤–∞—à –∫–æ–¥. –í—ã –∏–∑—É—á–∏–ª–∏, –∫–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∞–Ω–Ω–æ—Ç–∞—Ü–∏–∏ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏ —á—Ç–æ–±—ã —É–±–µ–¥–∏—Ç—å—Å—è, —á—Ç–æ –≤–∞—à –Ω–æ–≤—ã–π –≥–∏–±–∫–∏–π –∫–æ–¥ –Ω–µ –±—É–¥–µ—Ç –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –Ω–∏–∫–∞–∫–∏—Ö –≤–∏—Å—è—á–∏—Ö —Å—Å—ã–ª–æ–∫. –ò –≤–µ—Å—å —ç—Ç–æ—Ç –∞–Ω–∞–ª–∏–∑ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –≤ –º–æ–º–µ–Ω—Ç –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –∏ –Ω–µ –≤–ª–∏—è–µ—Ç –Ω–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –ø—Ä–æ–≥—Ä–∞–º–º—ã –≤–æ –≤—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã!</p>
<p>–í–µ—Ä—å—Ç–µ –∏–ª–∏ –Ω–µ—Ç, –Ω–æ –≤ —Ä–∞–º–∫–∞—Ö —ç—Ç–æ–π —Ç–µ–º—ã –≤—Å—ë –µ—â—ë –µ—Å—Ç—å —á–µ–º—É –ø–æ—É—á–∏—Ç—å—Å—è: –≤ –ì–ª–∞–≤–µ 18 –æ–±—Å—É–∂–¥–∞—é—Ç—Å—è —Ç—Ä–µ–π—Ç-–æ–±—ä–µ–∫—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ —è–≤–ª—è—é—Ç—Å—è –µ—â—ë –æ–¥–Ω–∏–º —Å–ø–æ—Å–æ–±–æ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Ç—Ä–µ–π—Ç–æ–≤. –°—É—â–µ—Å—Ç–≤—É—é—Ç —Ç–∞–∫–∂–µ –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω—ã–µ —Å—Ü–µ–Ω–∞—Ä–∏–∏ –∞–Ω–Ω–æ—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏, –∫–æ—Ç–æ—Ä—ã–µ –≤–∞–º –ø–æ–Ω–∞–¥–æ–±—è—Ç—Å—è —Ç–æ–ª—å–∫–æ –≤ –æ—á–µ–Ω—å —Å–ª–æ–∂–Ω—ã—Ö —Å–ª—É—á–∞—è—Ö; –¥–ª—è —ç—Ç–æ–≥–æ –≤–∞–º —Å–ª–µ–¥—É–µ—Ç –ø—Ä–æ—á–∏—Ç–∞—Ç—å <a href="https://rust-lang-translations.org/reference/index.html">–°–ø—Ä–∞–≤–æ—á–Ω–∏–∫ Rust</a>. –î–∞–ª–µ–µ –≤—ã —É–∑–Ω–∞–µ—Ç–µ, –∫–∞–∫ –ø–∏—Å–∞—Ç—å —Ç–µ—Å—Ç—ã –Ω–∞ Rust, —á—Ç–æ–±—ã –±—ã—Ç—å —É–≤–µ—Ä–µ–Ω–Ω—ã–º, —á—Ç–æ –≤–∞—à –∫–æ–¥ —Ä–∞–±–æ—Ç–∞–µ—Ç —Ç–∞–∫, –∫–∞–∫ –∑–∞–¥—É–º–∞–Ω–æ.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ-—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ"><a class="header" href="#–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ-—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ">–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ</a></h1>
<p>–í —Å–≤–æ—ë–º —ç—Å—Å–µ 1972 –≥–æ–¥–∞ ¬´–°–º–∏—Ä–µ–Ω–Ω—ã–π –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç¬ª (¬´The Humble Programmer¬ª) –≠–¥—Å–≥–µ—Ä –í–∏–±–µ –î–µ–π–∫—Å—Ç—Ä–∞ —Å–∫–∞–∑–∞–ª, —á—Ç–æ "—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã –º–æ–∂–µ—Ç –±—ã—Ç—å –æ—á–µ–Ω—å —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–º —Å–ø–æ—Å–æ–±–æ–º –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ –Ω–∞–ª–∏—á–∏—è –æ—à–∏–±–æ–∫, –Ω–æ –æ–Ω–æ –±–µ–∑–Ω–∞–¥—ë–∂–Ω–æ –Ω–µ–∞–¥–µ–∫–≤–∞—Ç–Ω–æ –¥–ª—è –¥–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–∞ –∏—Ö –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è". –≠—Ç–æ –Ω–µ –∑–Ω–∞—á–∏—Ç, —á—Ç–æ –º—ã –Ω–µ –¥–æ–ª–∂–Ω—ã –ø—ã—Ç–∞—Ç—å—Å—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å —Å—Ç–æ–ª—å–∫–æ, —Å–∫–æ–ª—å–∫–æ –º—ã –º–æ–∂–µ–º!</p>
<p>Correctness in our programs is the extent to which our code does what we intend it to do. Rust is designed with a high degree of concern about the correctness of programs, but correctness is complex and not easy to prove. Rust‚Äôs type system shoulders a huge part of this burden, but the type system cannot catch everything. As such, Rust includes support for writing automated software tests.</p>
<p>Say we write a function <code>add_two</code> that adds 2 to whatever number is passed to it. This function‚Äôs signature accepts an integer as a parameter and returns an integer as a result. When we implement and compile that function, Rust does all the type checking and borrow checking that you‚Äôve learned so far to ensure that, for instance, we aren‚Äôt passing a <code>String</code> value or an invalid reference to this function. But Rust <em>can‚Äôt</em> check that this function will do precisely what we intend, which is return the parameter plus 2 rather than, say, the parameter plus 10 or the parameter minus 50! That‚Äôs where tests come in.</p>
<p>We can write tests that assert, for example, that when we pass <code>3</code> to the <code>add_two</code> function, the returned value is <code>5</code>. We can run these tests whenever we make changes to our code to make sure any existing correct behavior has not changed.</p>
<p>Testing is a complex skill: although we can‚Äôt cover in one chapter every detail about how to write good tests, in this chapter we will discuss the mechanics of Rust‚Äôs testing facilities. We‚Äôll talk about the annotations and macros available to you when writing your tests, the default behavior and options provided for running your tests, and how to organize tests into unit tests and integration tests.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–ö–∞–∫-–ø–∏—Å–∞—Ç—å-—Ç–µ—Å—Ç—ã"><a class="header" href="#–ö–∞–∫-–ø–∏—Å–∞—Ç—å-—Ç–µ—Å—Ç—ã">–ö–∞–∫ –ø–∏—Å–∞—Ç—å —Ç–µ—Å—Ç—ã</a></h2>
<p>Tests are Rust functions that verify that the non-test code is functioning in the expected manner. The bodies of test functions typically perform these three actions:</p>
<ul>
<li>Set up any needed data or state.</li>
<li>Run the code you want to test.</li>
<li>Assert that the results are what you expect.</li>
</ul>
<p>Let‚Äôs look at the features Rust provides specifically for writing tests that take these actions, which include the <code>test</code> attribute, a few macros, and the <code>should_panic</code> attribute.</p>
<h3 id="the-anatomy-of-a-test-function"><a class="header" href="#the-anatomy-of-a-test-function">The Anatomy of a Test Function</a></h3>
<p>At its simplest, a test in Rust is a function that‚Äôs annotated with the <code>test</code> attribute. Attributes are metadata about pieces of Rust code; one example is the <code>derive</code> attribute we used with structs in Chapter 5. To change a function into a test function, add <code>#[test]</code> on the line before <code>fn</code>. When you run your tests with the <code>cargo test</code> command, Rust builds a test runner binary that runs the annotated functions and reports on whether each test function passes or fails.</p>
<p>Whenever we make a new library project with Cargo, a test module with a test function in it is automatically generated for us. This module gives you a template for writing your tests so you don‚Äôt have to look up the exact structure and syntax every time you start a new project. You can add as many additional test functions and as many test modules as you want!</p>
<p>We‚Äôll explore some aspects of how tests work by experimenting with the template test before we actually test any code. Then we‚Äôll write some real-world tests that call some code that we‚Äôve written and assert that its behavior is correct.</p>
<p>Let‚Äôs create a new library project called <code>adder</code> that will add two numbers:</p>
<pre><code class="language-console">$ cargo new adder --lib
     Created library `adder` project
$ cd adder
</code></pre>
<p>The contents of the <em>src/lib.rs</em> file in your <code>adder</code> library should look like Listing 11-1.</p>
<Listing number="11-1" file-name="src/lib.rs" caption="The code generated automatically by `cargo new`">
<!-- manual-regeneration
cd listings/ch11-writing-automated-tests
rm -rf listing-11-01
cargo new listing-11-01 --lib --name adder
cd listing-11-01
echo "$ cargo test" > output.txt
RUSTFLAGS="-A unused_variables -A dead_code" RUST_TEST_THREADS=1 cargo test >> output.txt 2>&1
git diff output.txt # commit any relevant changes; discard irrelevant ones
cd ../../..
-->
<pre><code class="language-rust noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
</Listing>
<p>The file starts with an example <code>add</code> function, so that we have something to test.</p>
<p>For now, let‚Äôs focus solely on the <code>it_works</code> function. Note the <code>#[test]</code> annotation: this attribute indicates this is a test function, so the test runner knows to treat this function as a test. We might also have non-test functions in the <code>tests</code> module to help set up common scenarios or perform common operations, so we always need to indicate which functions are tests.</p>
<p>The example function body uses the <code>assert_eq!</code> macro to assert that <code>result</code>, which contains the result of calling <code>add</code> with 2 and 2, equals 4. This assertion serves as an example of the format for a typical test. Let‚Äôs run it to see that this test passes.</p>
<p>The <code>cargo test</code> command runs all tests in our project, as shown in Listing 11-2.</p>
<Listing number="11-2" caption="The output from running the automatically generated test">
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.57s
     Running unittests src/lib.rs (file:///projects/adder/target/debug/deps/adder-7acb243c25ffd9dc)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
</Listing>
<p>Cargo compiled and ran the test. We see the line <code>running 1 test</code>. The next line shows the name of the generated test function, called <code>tests::it_works</code>, and that the result of running that test is <code>ok</code>. The overall summary <code>test result: ok.</code> means that all the tests passed, and the portion that reads <code>1 passed; 0 failed</code> totals the number of tests that passed or failed.</p>
<p>It‚Äôs possible to mark a test as ignored so it doesn‚Äôt run in a particular instance; we‚Äôll cover that in the <a href="ch11-02-running-tests.html#ignoring-some-tests-unless-specifically-requested">‚ÄúIgnoring Some Tests Unless Specifically Requested‚Äù</a><!-- ignore --> section later in this chapter. Because we haven‚Äôt done that here, the summary shows <code>0 ignored</code>. We can also pass an argument to the <code>cargo test</code> command to run only tests whose name matches a string; this is called <em>filtering</em> and we‚Äôll cover that in the <a href="ch11-02-running-tests.html#running-a-subset-of-tests-by-name">‚ÄúRunning a Subset of Tests by Name‚Äù</a><!-- ignore --> section. Here we haven‚Äôt filtered the tests being run, so the end of the summary shows <code>0 filtered out</code>.</p>
<p>The <code>0 measured</code> statistic is for benchmark tests that measure performance. Benchmark tests are, as of this writing, only available in nightly Rust. See <a href="../unstable-book/library-features/test.html">the documentation about benchmark tests</a> to learn more.</p>
<p>The next part of the test output starting at <code>Doc-tests adder</code> is for the results of any documentation tests. We don‚Äôt have any documentation tests yet, but Rust can compile any code examples that appear in our API documentation. This feature helps keep your docs and your code in sync! We‚Äôll discuss how to write documentation tests in the <a href="ch14-02-publishing-to-crates-io.html#documentation-comments-as-tests">‚ÄúDocumentation Comments as Tests‚Äù</a><!-- ignore --> section of Chapter 14. For now, we‚Äôll ignore the <code>Doc-tests</code> output.</p>
<p>Let‚Äôs start to customize the test to our own needs. First, change the name of the <code>it_works</code> function to a different name, such as <code>exploration</code>, like so:</p>
<p><span class="filename">–§–∞–π–ª: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn exploration() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<p>Then run <code>cargo test</code> again. The output now shows <code>exploration</code> instead of <code>it_works</code>:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.59s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Now we‚Äôll add another test, but this time we‚Äôll make a test that fails! Tests fail when something in the test function panics. Each test is run in a new thread, and when the main thread sees that a test thread has died, the test is marked as failed. In Chapter 9, we talked about how the simplest way to panic is to call the <code>panic!</code> macro. Enter the new test as a function named <code>another</code>, so your <em>src/lib.rs</em> file looks like Listing 11-3.</p>
<Listing number="11-3" file-name="src/lib.rs" caption="Adding a second test that will fail because we call the `panic!` macro">
<pre><code class="language-rust panics noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn exploration() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }

    #[test]
    fn another() {
        panic!("Make this test fail");
    }
}</code></pre>
</Listing>
<p>Run the tests again using <code>cargo test</code>. The output should look like Listing 11-4, which shows that our <code>exploration</code> test passed and <code>another</code> failed.</p>
<Listing number="11-4" caption="Test results when one test passes and one test fails">
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.72s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::another ... FAILED
test tests::exploration ... ok

failures:

---- tests::another stdout ----
thread 'tests::another' panicked at src/lib.rs:17:9:
Make this test fail
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
</Listing>
<!-- manual-regeneration
rg panicked listings/ch11-writing-automated-tests/listing-11-03/output.txt
check the line number of the panic matches the line number in the following paragraph
 -->
<p>Instead of <code>ok</code>, the line <code>test tests::another</code> shows <code>FAILED</code>. Two new sections appear between the individual results and the summary: the first displays the detailed reason for each test failure. In this case, we get the details that <code>another</code> failed because it <code>panicked at 'Make this test fail'</code> on line 17 in the <em>src/lib.rs</em> file. The next section lists just the names of all the failing tests, which is useful when there are lots of tests and lots of detailed failing test output. We can use the name of a failing test to run just that test to more easily debug it; we‚Äôll talk more about ways to run tests in the <a href="ch11-02-running-tests.html#controlling-how-tests-are-run">‚ÄúControlling How Tests Are Run‚Äù</a><!-- ignore
--> section.</p>
<p>The summary line displays at the end: overall, our test result is <code>FAILED</code>. We had one test pass and one test fail.</p>
<p>Now that you‚Äôve seen what the test results look like in different scenarios, let‚Äôs look at some macros other than <code>panic!</code> that are useful in tests.</p>
<h3 id="checking-results-with-the-assert-macro"><a class="header" href="#checking-results-with-the-assert-macro">Checking Results with the <code>assert!</code> Macro</a></h3>
<p>The <code>assert!</code> macro, provided by the standard library, is useful when you want to ensure that some condition in a test evaluates to <code>true</code>. We give the <code>assert!</code> macro an argument that evaluates to a Boolean. If the value is <code>true</code>, nothing happens and the test passes. If the value is <code>false</code>, the <code>assert!</code> macro calls <code>panic!</code> to cause the test to fail. Using the <code>assert!</code> macro helps us check that our code is functioning in the way we intend.</p>
<p>In Chapter 5, Listing 5-15, we used a <code>Rectangle</code> struct and a <code>can_hold</code> method, which are repeated here in Listing 11-5. Let‚Äôs put this code in the <em>src/lib.rs</em> file, then write some tests for it using the <code>assert!</code> macro.</p>
<Listing number="11-5" file-name="src/lib.rs" caption="The `Rectangle` struct and its `can_hold` method from Chapter 5">
<pre><code class="language-rust noplayground">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}</code></pre>
</Listing>
<p>The <code>can_hold</code> method returns a Boolean, which means it‚Äôs a perfect use case for the <code>assert!</code> macro. In Listing 11-6, we write a test that exercises the <code>can_hold</code> method by creating a <code>Rectangle</code> instance that has a width of 8 and a height of 7 and asserting that it can hold another <code>Rectangle</code> instance that has a width of 5 and a height of 1.</p>
<Listing number="11-6" file-name="src/lib.rs" caption="A test for `can_hold` that checks whether a larger rectangle can indeed hold a smaller rectangle">
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(larger.can_hold(&amp;smaller));
    }
}</code></pre>
</Listing>
<p>Note the <code>use super::*;</code> line inside the <code>tests</code> module. The <code>tests</code> module is a regular module that follows the usual visibility rules we covered in Chapter 7 in the <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">‚ÄúPaths for Referring to an Item in the Module Tree‚Äù</a><!-- ignore --> section. Because the <code>tests</code> module is an inner module, we need to bring the code under test in the outer module into the scope of the inner module. We use a glob here, so anything we define in the outer module is available to this <code>tests</code> module.</p>
<p>We‚Äôve named our test <code>larger_can_hold_smaller</code>, and we‚Äôve created the two <code>Rectangle</code> instances that we need. Then we called the <code>assert!</code> macro and passed it the result of calling <code>larger.can_hold(&amp;smaller)</code>. This expression is supposed to return <code>true</code>, so our test should pass. Let‚Äôs find out!</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>It does pass! Let‚Äôs add another test, this time asserting that a smaller rectangle cannot hold a larger rectangle:</p>
<p><span class="filename">–§–∞–π–ª: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span>    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(!smaller.can_hold(&amp;larger));
    }
}</code></pre>
<p>Because the correct result of the <code>can_hold</code> function in this case is <code>false</code>, we need to negate that result before we pass it to the <code>assert!</code> macro. As a result, our test will pass if <code>can_hold</code> returns <code>false</code>:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... ok
test tests::smaller_cannot_hold_larger ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Two tests that pass! Now let‚Äôs see what happens to our test results when we introduce a bug in our code. We‚Äôll change the implementation of the <code>can_hold</code> method by replacing the greater-than sign with a less-than sign when it compares the widths:</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>// --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &lt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn larger_can_hold_smaller() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn smaller_cannot_hold_larger() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(!smaller.can_hold(&amp;larger));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Running the tests now produces the following:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... FAILED
test tests::smaller_cannot_hold_larger ... ok

failures:

---- tests::larger_can_hold_smaller stdout ----
thread 'tests::larger_can_hold_smaller' panicked at src/lib.rs:28:9:
assertion failed: larger.can_hold(&amp;smaller)
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Our tests caught the bug! Because <code>larger.width</code> is <code>8</code> and <code>smaller.width</code> is <code>5</code>, the comparison of the widths in <code>can_hold</code> now returns <code>false</code>: 8 is not less than 5.</p>
<h3 id="testing-equality-with-the-assert_eq-and-assert_ne-macros"><a class="header" href="#testing-equality-with-the-assert_eq-and-assert_ne-macros">Testing Equality with the <code>assert_eq!</code> and <code>assert_ne!</code> Macros</a></h3>
<p>A common way to verify functionality is to test for equality between the result of the code under test and the value you expect the code to return. You could do this by using the <code>assert!</code> macro and passing it an expression using the <code>==</code> operator. However, this is such a common test that the standard library provides a pair of macros‚Äî<code>assert_eq!</code> and <code>assert_ne!</code>‚Äîto perform this test more conveniently. These macros compare two arguments for equality or inequality, respectively. They‚Äôll also print the two values if the assertion fails, which makes it easier to see <em>why</em> the test failed; conversely, the <code>assert!</code> macro only indicates that it got a <code>false</code> value for the <code>==</code> expression, without printing the values that led to the <code>false</code> value.</p>
<p>In Listing 11-7, we write a function named <code>add_two</code> that adds <code>2</code> to its parameter, then we test this function using the <code>assert_eq!</code> macro.</p>
<Listing number="11-7" file-name="src/lib.rs" caption="Testing the function `add_two` using the `assert_eq!` macro">
<pre><code class="language-rust noplayground">pub fn add_two(a: usize) -&gt; usize {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        let result = add_two(2);
        assert_eq!(result, 4);
    }
}</code></pre>
</Listing>
<p>Let‚Äôs check that it passes!</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>We create a variable named <code>result</code> that holds the result of calling <code>add_two(2)</code>. Then we pass <code>result</code> and <code>4</code> as the arguments to <code>assert_eq!</code>. The output line for this test is <code>test tests::it_adds_two ... ok</code>, and the <code>ok</code> text indicates that our test passed!</p>
<p>Let‚Äôs introduce a bug into our code to see what <code>assert_eq!</code> looks like when it fails. Change the implementation of the <code>add_two</code> function to instead add <code>3</code>:</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn add_two(a: usize) -&gt; usize {
    a + 3
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_adds_two() {
</span><span class="boring">        let result = add_two(2);
</span><span class="boring">        assert_eq!(result, 4);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Run the tests again:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----
thread 'tests::it_adds_two' panicked at src/lib.rs:12:9:
assertion `left == right` failed
  left: 5
 right: 4
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Our test caught the bug! The <code>it_adds_two</code> test failed, and the message tells us that the assertion that failed was <code>assertion `left == right` failed</code> and what the <code>left</code> and <code>right</code> values are. This message helps us start debugging: the <code>left</code> argument, where we had the result of calling <code>add_two(2)</code>, was <code>5</code> but the <code>right</code> argument was <code>4</code>. You can imagine that this would be especially helpful when we have a lot of tests going on.</p>
<p>Note that in some languages and test frameworks, the parameters to equality assertion functions are called <code>expected</code> and <code>actual</code>, and the order in which we specify the arguments matters. However, in Rust, they‚Äôre called <code>left</code> and <code>right</code>, and the order in which we specify the value we expect and the value the code produces doesn‚Äôt matter. We could write the assertion in this test as <code>assert_eq!(4, result)</code>, which would result in the same failure message that that displays <code>assertion failed: `(left == right)`</code>.</p>
<p>The <code>assert_ne!</code> macro will pass if the two values we give it are not equal and fail if they‚Äôre equal. This macro is most useful for cases when we‚Äôre not sure what a value <em>will</em> be, but we know what the value definitely <em>shouldn‚Äôt</em> be. For example, if we‚Äôre testing a function that is guaranteed to change its input in some way, but the way in which the input is changed depends on the day of the week that we run our tests, the best thing to assert might be that the output of the function is not equal to the input.</p>
<p>Under the surface, the <code>assert_eq!</code> and <code>assert_ne!</code> macros use the operators <code>==</code> and <code>!=</code>, respectively. When the assertions fail, these macros print their arguments using debug formatting, which means the values being compared must implement the <code>PartialEq</code> and <code>Debug</code> traits. All primitive types and most of the standard library types implement these traits. For structs and enums that you define yourself, you‚Äôll need to implement <code>PartialEq</code> to assert equality of those types. You‚Äôll also need to implement <code>Debug</code> to print the values when the assertion fails. Because both traits are derivable traits, as mentioned in Listing 5-12 in Chapter 5, this is usually as straightforward as adding the <code>#[derive(PartialEq, Debug)]</code> annotation to your struct or enum definition. See Appendix C, <a href="appendix-03-derivable-traits.html">‚ÄúDerivable Traits,‚Äù</a><!-- ignore --> for more details about these and other derivable traits.</p>
<h3 id="adding-custom-failure-messages"><a class="header" href="#adding-custom-failure-messages">Adding Custom Failure Messages</a></h3>
<p>You can also add a custom message to be printed with the failure message as optional arguments to the <code>assert!</code>, <code>assert_eq!</code>, and <code>assert_ne!</code> macros. Any arguments specified after the required arguments are passed along to the <code>format!</code> macro (discussed in <a href="ch08-02-strings.html#concatenation-with-the--operator-or-the-format-macro">‚ÄúConcatenation with the <code>+</code> Operator or the <code>format!</code> Macro‚Äù</a><!--
ignore --> in Chapter 8), so you can pass a format string that contains <code>{}</code> placeholders and values to go in those placeholders. Custom messages are useful for documenting what an assertion means; when a test fails, you‚Äôll have a better idea of what the problem is with the code.</p>
<p>For example, let‚Äôs say we have a function that greets people by name and we want to test that the name we pass into the function appears in the output:</p>
<p><span class="filename">–§–∞–π–ª: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    format!("Hello {name}!")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting("Carol");
        assert!(result.contains("Carol"));
    }
}</code></pre>
<p>The requirements for this program haven‚Äôt been agreed upon yet, and we‚Äôre pretty sure the <code>Hello</code> text at the beginning of the greeting will change. We decided we don‚Äôt want to have to update the test when the requirements change, so instead of checking for exact equality to the value returned from the <code>greeting</code> function, we‚Äôll just assert that the output contains the text of the input parameter.</p>
<p>Now let‚Äôs introduce a bug into this code by changing <code>greeting</code> to exclude <code>name</code> to see what the default test failure looks like:</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    String::from("Hello!")
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greeting_contains_name() {
</span><span class="boring">        let result = greeting("Carol");
</span><span class="boring">        assert!(result.contains("Carol"));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Running this test produces the following:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:
assertion failed: result.contains("Carol")
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>This result just indicates that the assertion failed and which line the assertion is on. A more useful failure message would print the value from the <code>greeting</code> function. Let‚Äôs add a custom failure message composed of a format string with a placeholder filled in with the actual value we got from the <code>greeting</code> function:</p>
<pre><code class="language-rust ignore"><span class="boring">pub fn greeting(name: &amp;str) -&gt; String {
</span><span class="boring">    String::from("Hello!")
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn greeting_contains_name() {
        let result = greeting("Carol");
        assert!(
            result.contains("Carol"),
            "Greeting did not contain name, value was `{result}`"
        );
    }
<span class="boring">}</span></code></pre>
<p>Now when we run the test, we‚Äôll get a more informative error message:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.93s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:
Greeting did not contain name, value was `Hello!`
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>We can see the value we actually got in the test output, which would help us debug what happened instead of what we were expecting to happen.</p>
<h3 id="checking-for-panics-with-should_panic"><a class="header" href="#checking-for-panics-with-should_panic">Checking for Panics with <code>should_panic</code></a></h3>
<p>In addition to checking return values, it‚Äôs important to check that our code handles error conditions as we expect. For example, consider the <code>Guess</code> type that we created in Chapter 9, Listing 9-13. Other code that uses <code>Guess</code> depends on the guarantee that <code>Guess</code> instances will contain only values between 1 and 100. We can write a test that ensures that attempting to create a <code>Guess</code> instance with a value outside that range panics.</p>
<p>We do this by adding the attribute <code>should_panic</code> to our test function. The test passes if the code inside the function panics; the test fails if the code inside the function doesn‚Äôt panic.</p>
<p>Listing 11-8 shows a test that checks that the error conditions of <code>Guess::new</code> happen when we expect them to.</p>
<Listing number="11-8" file-name="src/lib.rs" caption="Testing that a condition will cause a `panic!`">
<pre><code class="language-rust noplayground">pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!("–î–æ–≥–∞–¥–∫–∞ {value} –Ω–µ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç –ø—Ä–µ–¥–µ–ª—É –æ—Ç 1 –¥–æ 100.");
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}</code></pre>
</Listing>
<p>We place the <code>#[should_panic]</code> attribute after the <code>#[test]</code> attribute and before the test function it applies to. Let‚Äôs look at the result when this test passes:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests guessing_game

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Looks good! Now let‚Äôs introduce a bug in our code by removing the condition that the <code>new</code> function will panic if the value is greater than 100:</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!("–î–æ–≥–∞–¥–∫–∞ {value} –Ω–µ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç –ø—Ä–µ–¥–µ–ª—É –æ—Ç 1 –¥–æ 100.");
        }

        Guess { value }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>When we run the test in Listing 11-8, it will fail:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
note: test did not panic as expected

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>We don‚Äôt get a very helpful message in this case, but when we look at the test function, we see that it‚Äôs annotated with <code>#[should_panic]</code>. The failure we got means that the code in the test function did not cause a panic.</p>
<p>Tests that use <code>should_panic</code> can be imprecise. A <code>should_panic</code> test would pass even if the test panics for a different reason from the one we were expecting. To make <code>should_panic</code> tests more precise, we can add an optional <code>expected</code> parameter to the <code>should_panic</code> attribute. The test harness will make sure that the failure message contains the provided text. For example, consider the modified code for <code>Guess</code> in Listing 11-9 where the <code>new</code> function panics with different messages depending on whether the value is too small or too large.</p>
<Listing number="11-9" file-name="src/lib.rs" caption="Testing for a `panic!` with a panic message containing a specified substring">
<pre><code class="language-rust noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(
                "Guess value must be greater than or equal to 1, got {value}."
            );
        } else if value &gt; 100 {
            panic!(
                "Guess value must be less than or equal to 100, got {value}."
            );
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = "less than or equal to 100")]
    fn greater_than_100() {
        Guess::new(200);
    }
}</code></pre>
</Listing>
<p>This test will pass because the value we put in the <code>should_panic</code> attribute‚Äôs <code>expected</code> parameter is a substring of the message that the <code>Guess::new</code> function panics with. We could have specified the entire panic message that we expect, which in this case would be <code>Guess value must be less than or equal to 100, got 200</code>. What you choose to specify depends on how much of the panic message is unique or dynamic and how precise you want your test to be. In this case, a substring of the panic message is enough to ensure that the code in the test function executes the <code>else if value &gt; 100</code> case.</p>
<p>To see what happens when a <code>should_panic</code> test with an <code>expected</code> message fails, let‚Äôs again introduce a bug into our code by swapping the bodies of the <code>if value &lt; 1</code> and the <code>else if value &gt; 100</code> blocks:</p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Guess {
</span><span class="boring">    pub fn new(value: i32) -&gt; Guess {
</span>        if value &lt; 1 {
            panic!(
                "Guess value must be less than or equal to 100, got {value}."
            );
        } else if value &gt; 100 {
            panic!(
                "Guess value must be greater than or equal to 1, got {value}."
            );
        }
<span class="boring">
</span><span class="boring">        Guess { value }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic(expected = "less than or equal to 100")]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>This time when we run the <code>should_panic</code> test, it will fail:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
thread 'tests::greater_than_100' panicked at src/lib.rs:12:13:
Guess value must be greater than or equal to 1, got 200.
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
note: panic did not contain expected string
      panic message: `"Guess value must be greater than or equal to 1, got 200."`,
 expected substring: `"less than or equal to 100"`

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>The failure message indicates that this test did indeed panic as we expected, but the panic message did not include the expected string <code>less than or equal to 100</code>. The panic message that we did get in this case was <code>Guess value must be greater than or equal to 1, got 200.</code> Now we can start figuring out where our bug is!</p>
<h3 id="using-resultt-e-in-tests"><a class="header" href="#using-resultt-e-in-tests">Using <code>Result&lt;T, E&gt;</code> in Tests</a></h3>
<p>Our tests so far all panic when they fail. We can also write tests that use <code>Result&lt;T, E&gt;</code>! Here‚Äôs the test from Listing 11-1, rewritten to use <code>Result&lt;T, E&gt;</code> and return an <code>Err</code> instead of panicking:</p>
<pre><code class="language-rust noplayground"><span class="boring">pub fn add(left: u64, right: u64) -&gt; u64 {
</span><span class="boring">    left + right
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn it_works() -&gt; Result&lt;(), String&gt; {
        let result = add(2, 2);

        if result == 4 {
            Ok(())
        } else {
            Err(String::from("two plus two does not equal four"))
        }
    }
<span class="boring">}</span></code></pre>
<p>The <code>it_works</code> function now has the <code>Result&lt;(), String&gt;</code> return type. In the body of the function, rather than calling the <code>assert_eq!</code> macro, we return <code>Ok(())</code> when the test passes and an <code>Err</code> with a <code>String</code> inside when the test fails.</p>
<p>Writing tests so they return a <code>Result&lt;T, E&gt;</code> enables you to use the question mark operator in the body of tests, which can be a convenient way to write tests that should fail if any operation within them returns an <code>Err</code> variant.</p>
<p>You can‚Äôt use the <code>#[should_panic]</code> annotation on tests that use <code>Result&lt;T, E&gt;</code>. To assert that an operation returns an <code>Err</code> variant, <em>don‚Äôt</em> use the question mark operator on the <code>Result&lt;T, E&gt;</code> value. Instead, use <code>assert!(value.is_err())</code>.</p>
<p>Now that you know several ways to write tests, let‚Äôs look at what is happening when we run our tests and explore the different options we can use with <code>cargo test</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ-–∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ–º-—Ç–µ—Å—Ç–æ–≤"><a class="header" href="#–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ-–∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ–º-—Ç–µ—Å—Ç–æ–≤">–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ–º —Ç–µ—Å—Ç–æ–≤</a></h2>
<p>Just as <code>cargo run</code> compiles your code and then runs the resultant binary, <code>cargo test</code> compiles your code in test mode and runs the resultant test binary. The default behavior of the binary produced by <code>cargo test</code> is to run all the tests in parallel and capture output generated during test runs, preventing the output from being displayed and making it easier to read the output related to the test results. You can, however, specify command line options to change this default behavior.</p>
<p>Some command line options go to <code>cargo test</code>, and some go to the resultant test binary. To separate these two types of arguments, you list the arguments that go to <code>cargo test</code> followed by the separator <code>--</code> and then the ones that go to the test binary. Running <code>cargo test --help</code> displays the options you can use with <code>cargo test</code>, and running <code>cargo test -- --help</code> displays the options you can use after the separator. Those options are also documented in <a href="https://doc.rust-lang.org/rustc/tests/index.html">the ‚ÄúTests‚Äù section</a> of the <a href="https://doc.rust-lang.org/rustc/index.html">the rustc book</a>.</p>
<h3 id="running-tests-in-parallel-or-consecutively"><a class="header" href="#running-tests-in-parallel-or-consecutively">Running Tests in Parallel or Consecutively</a></h3>
<p>When you run multiple tests, by default they run in parallel using threads, meaning they finish running faster and you get feedback quicker. Because the tests are running at the same time, you must make sure your tests don‚Äôt depend on each other or on any shared state, including a shared environment, such as the current working directory or environment variables.</p>
<p>For example, say each of your tests runs some code that creates a file on disk named <em>test-output.txt</em> and writes some data to that file. Then each test reads the data in that file and asserts that the file contains a particular value, which is different in each test. Because the tests run at the same time, one test might overwrite the file in the time between another test writing and reading the file. The second test will then fail, not because the code is incorrect but because the tests have interfered with each other while running in parallel. One solution is to make sure each test writes to a different file; another solution is to run the tests one at a time.</p>
<p>If you don‚Äôt want to run the tests in parallel or if you want more fine-grained control over the number of threads used, you can send the <code>--test-threads</code> flag and the number of threads you want to use to the test binary. Take a look at the following example:</p>
<pre><code class="language-console">$ cargo test -- --test-threads=1
</code></pre>
<p>We set the number of test threads to <code>1</code>, telling the program not to use any parallelism. Running the tests using one thread will take longer than running them in parallel, but the tests won‚Äôt interfere with each other if they share state.</p>
<h3 id="showing-function-output"><a class="header" href="#showing-function-output">Showing Function Output</a></h3>
<p>By default, if a test passes, Rust‚Äôs test library captures anything printed to standard output. For example, if we call <code>println!</code> in a test and the test passes, we won‚Äôt see the <code>println!</code> output in the terminal; we‚Äôll see only the line that indicates the test passed. If a test fails, we‚Äôll see whatever was printed to standard output with the rest of the failure message.</p>
<p>As an example, Listing 11-10 has a silly function that prints the value of its parameter and returns 10, as well as a test that passes and a test that fails.</p>
<Listing number="11-10" file-name="src/lib.rs" caption="Tests for a function that calls `println!`">
<pre><code class="language-rust panics noplayground">fn prints_and_returns_10(a: i32) -&gt; i32 {
    println!("I got the value {a}");
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn this_test_will_pass() {
        let value = prints_and_returns_10(4);
        assert_eq!(value, 10);
    }

    #[test]
    fn this_test_will_fail() {
        let value = prints_and_returns_10(8);
        assert_eq!(value, 5);
    }
}</code></pre>
</Listing>
<p>When we run these tests with <code>cargo test</code>, we‚Äôll see the following output:</p>
<pre><code class="language-console">$ cargo test
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

failures:

---- tests::this_test_will_fail stdout ----
I got the value 8
thread 'tests::this_test_will_fail' panicked at src/lib.rs:19:9:
assertion `left == right` failed
  left: 10
 right: 5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Note that nowhere in this output do we see <code>I got the value 4</code>, which is printed when the test that passes runs. That output has been captured. The output from the test that failed, <code>I got the value 8</code>, appears in the section of the test summary output, which also shows the cause of the test failure.</p>
<p>If we want to see printed values for passing tests as well, we can tell Rust to also show the output of successful tests with <code>--show-output</code>:</p>
<pre><code class="language-console">$ cargo test -- --show-output
</code></pre>
<p>When we run the tests in Listing 11-10 again with the <code>--show-output</code> flag, we see the following output:</p>
<pre><code class="language-console">$ cargo test -- --show-output
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

successes:

---- tests::this_test_will_pass stdout ----
I got the value 4


successes:
    tests::this_test_will_pass

failures:

---- tests::this_test_will_fail stdout ----
I got the value 8
thread 'tests::this_test_will_fail' panicked at src/lib.rs:19:9:
assertion `left == right` failed
  left: 10
 right: 5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<h3 id="running-a-subset-of-tests-by-name"><a class="header" href="#running-a-subset-of-tests-by-name">Running a Subset of Tests by Name</a></h3>
<p>Sometimes, running a full test suite can take a long time. If you‚Äôre working on code in a particular area, you might want to run only the tests pertaining to that code. You can choose which tests to run by passing <code>cargo test</code> the name or names of the test(s) you want to run as an argument.</p>
<p>To demonstrate how to run a subset of tests, we‚Äôll first create three tests for our <code>add_two</code> function, as shown in Listing 11-11, and choose which ones to run.</p>
<Listing number="11-11" file-name="src/lib.rs" caption="Three tests with three different names">
<pre><code class="language-rust noplayground">pub fn add_two(a: usize) -&gt; usize {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        let result = add_two(2);
        assert_eq!(result, 4);
    }

    #[test]
    fn add_three_and_two() {
        let result = add_two(3);
        assert_eq!(result, 5);
    }

    #[test]
    fn one_hundred() {
        let result = add_two(100);
        assert_eq!(result, 102);
    }
}</code></pre>
</Listing>
<p>If we run the tests without passing any arguments, as we saw earlier, all the tests will run in parallel:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 3 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok
test tests::one_hundred ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<h4 id="running-single-tests"><a class="header" href="#running-single-tests">Running Single Tests</a></h4>
<p>We can pass the name of any test function to <code>cargo test</code> to run only that test:</p>
<pre><code class="language-console">$ cargo test one_hundred
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.69s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::one_hundred ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out; finished in 0.00s

</code></pre>
<p>Only the test with the name <code>one_hundred</code> ran; the other two tests didn‚Äôt match that name. The test output lets us know we had more tests that didn‚Äôt run by displaying <code>2 filtered out</code> at the end.</p>
<p>We can‚Äôt specify the names of multiple tests in this way; only the first value given to <code>cargo test</code> will be used. But there is a way to run multiple tests.</p>
<h4 id="filtering-to-run-multiple-tests"><a class="header" href="#filtering-to-run-multiple-tests">Filtering to Run Multiple Tests</a></h4>
<p>We can specify part of a test name, and any test whose name matches that value will be run. For example, because two of our tests‚Äô names contain <code>add</code>, we can run those two by running <code>cargo test add</code>:</p>
<pre><code class="language-console">$ cargo test add
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

</code></pre>
<p>This command ran all tests with <code>add</code> in the name and filtered out the test named <code>one_hundred</code>. Also note that the module in which a test appears becomes part of the test‚Äôs name, so we can run all the tests in a module by filtering on the module‚Äôs name.</p>
<h3 id="ignoring-some-tests-unless-specifically-requested"><a class="header" href="#ignoring-some-tests-unless-specifically-requested">Ignoring Some Tests Unless Specifically Requested</a></h3>
<p>Sometimes a few specific tests can be very time-consuming to execute, so you might want to exclude them during most runs of <code>cargo test</code>. Rather than listing as arguments all tests you do want to run, you can instead annotate the time-consuming tests using the <code>ignore</code> attribute to exclude them, as shown here:</p>
<p><span class="filename">–§–∞–π–ª: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub fn add(left: u64, right: u64) -&gt; u64 {
</span><span class="boring">    left + right
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }

    #[test]
    #[ignore]
    fn expensive_test() {
        // code that takes an hour to run
    }
}</code></pre>
<p>After <code>#[test]</code>, we add the <code>#[ignore]</code> line to the test we want to exclude. Now when we run our tests, <code>it_works</code> runs, but <code>expensive_test</code> doesn‚Äôt:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::expensive_test ... ignored
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>The <code>expensive_test</code> function is listed as <code>ignored</code>. If we want to run only the ignored tests, we can use <code>cargo test -- --ignored</code>:</p>
<pre><code class="language-console">$ cargo test -- --ignored
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>By controlling which tests run, you can make sure your <code>cargo test</code> results will be returned quickly. When you‚Äôre at a point where it makes sense to check the results of the <code>ignored</code> tests and you have time to wait for the results, you can run <code>cargo test -- --ignored</code> instead. If you want to run all tests whether they‚Äôre ignored or not, you can run <code>cargo test -- --include-ignored</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–û—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è-—Ç–µ—Å—Ç–æ–≤"><a class="header" href="#–û—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è-—Ç–µ—Å—Ç–æ–≤">–û—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è —Ç–µ—Å—Ç–æ–≤</a></h2>
<p>As mentioned at the start of the chapter, testing is a complex discipline, and different people use different terminology and organization. The Rust community thinks about tests in terms of two main categories: unit tests and integration tests. <em>Unit tests</em> are small and more focused, testing one module in isolation at a time, and can test private interfaces. <em>Integration tests</em> are entirely external to your library and use your code in the same way any other external code would, using only the public interface and potentially exercising multiple modules per test.</p>
<p>Writing both kinds of tests is important to ensure that the pieces of your library are doing what you expect them to, separately and together.</p>
<h3 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h3>
<p>The purpose of unit tests is to test each unit of code in isolation from the rest of the code to quickly pinpoint where code is and isn‚Äôt working as expected. You‚Äôll put unit tests in the <em>src</em> directory in each file with the code that they‚Äôre testing. The convention is to create a module named <code>tests</code> in each file to contain the test functions and to annotate the module with <code>cfg(test)</code>.</p>
<h4 id="the-tests-module-and-cfgtest"><a class="header" href="#the-tests-module-and-cfgtest">The Tests Module and <code>#[cfg(test)]</code></a></h4>
<p>The <code>#[cfg(test)]</code> annotation on the <code>tests</code> module tells Rust to compile and run the test code only when you run <code>cargo test</code>, not when you run <code>cargo build</code>. This saves compile time when you only want to build the library and saves space in the resultant compiled artifact because the tests are not included. You‚Äôll see that because integration tests go in a different directory, they don‚Äôt need the <code>#[cfg(test)]</code> annotation. However, because unit tests go in the same files as the code, you‚Äôll use <code>#[cfg(test)]</code> to specify that they shouldn‚Äôt be included in the compiled result.</p>
<p>Recall that when we generated the new <code>adder</code> project in the first section of this chapter, Cargo generated this code for us:</p>
<p><span class="filename">–§–∞–π–ª: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<p>On the automatically generated <code>tests</code> module, the attribute <code>cfg</code> stands for <em>configuration</em> and tells Rust that the following item should only be included given a certain configuration option. In this case, the configuration option is <code>test</code>, which is provided by Rust for compiling and running tests. By using the <code>cfg</code> attribute, Cargo compiles our test code only if we actively run the tests with <code>cargo test</code>. This includes any helper functions that might be within this module, in addition to the functions annotated with <code>#[test]</code>.</p>
<h4 id="testing-private-functions"><a class="header" href="#testing-private-functions">Testing Private Functions</a></h4>
<p>There‚Äôs debate within the testing community about whether or not private functions should be tested directly, and other languages make it difficult or impossible to test private functions. Regardless of which testing ideology you adhere to, Rust‚Äôs privacy rules do allow you to test private functions. Consider the code in Listing 11-12 with the private function <code>internal_adder</code>.</p>
<Listing number="11-12" file-name="src/lib.rs" caption="Testing a private function">
<pre><code class="language-rust noplayground">pub fn add_two(a: usize) -&gt; usize {
    internal_adder(a, 2)
}

fn internal_adder(left: usize, right: usize) -&gt; usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        let result = internal_adder(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
</Listing>
<p>Note that the <code>internal_adder</code> function is not marked as <code>pub</code>. Tests are just Rust code, and the <code>tests</code> module is just another module. As we discussed in <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">‚ÄúPaths for Referring to an Item in the Module Tree‚Äù</a><!-- ignore -->, items in child modules can use the items in their ancestor modules. In this test, we bring all of the <code>tests</code> module‚Äôs parent‚Äôs items into scope with <code>use super::*</code>, and then the test can call <code>internal_adder</code>. If you don‚Äôt think private functions should be tested, there‚Äôs nothing in Rust that will compel you to do so.</p>
<h3 id="integration-tests"><a class="header" href="#integration-tests">Integration Tests</a></h3>
<p>In Rust, integration tests are entirely external to your library. They use your library in the same way any other code would, which means they can only call functions that are part of your library‚Äôs public API. Their purpose is to test whether many parts of your library work together correctly. Units of code that work correctly on their own could have problems when integrated, so test coverage of the integrated code is important as well. To create integration tests, you first need a <em>tests</em> directory.</p>
<h4 id="the-tests-directory"><a class="header" href="#the-tests-directory">The <em>tests</em> Directory</a></h4>
<p>We create a <em>tests</em> directory at the top level of our project directory, next to <em>src</em>. Cargo knows to look for integration test files in this directory. We can then make as many test files as we want, and Cargo will compile each of the files as an individual crate.</p>
<p>Let‚Äôs create an integration test. With the code in Listing 11-12 still in the <em>src/lib.rs</em> file, make a <em>tests</em> directory, and create a new file named <em>tests/integration_test.rs</em>. Your directory structure should look like this:</p>
<pre><code class="language-text">adder
‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ src
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ lib.rs
‚îî‚îÄ‚îÄ tests
    ‚îî‚îÄ‚îÄ integration_test.rs
</code></pre>
<p>Enter the code in Listing 11-13 into the <em>tests/integration_test.rs</em> file.</p>
<Listing number="11-13" file-name="tests/integration_test.rs" caption="An integration test of a function in the `adder` crate">
<pre><code class="language-rust ignore">use adder::add_two;

#[test]
fn it_adds_two() {
    let result = add_two(2);
    assert_eq!(result, 4);
}</code></pre>
</Listing>
<p>Each file in the <em>tests</em> directory is a separate crate, so we need to bring our library into each test crate‚Äôs scope. For that reason we add <code>use adder::add_two;</code> at the top of the code, which we didn‚Äôt need in the unit tests.</p>
<p>We don‚Äôt need to annotate any code in <em>tests/integration_test.rs</em> with <code>#[cfg(test)]</code>. Cargo treats the <em>tests</em> directory specially and compiles files in this directory only when we run <code>cargo test</code>. Run <code>cargo test</code> now:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.31s
     Running unittests src/lib.rs (target/debug/deps/adder-1082c4b063a8fbe6)

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-1082c4b063a8fbe6)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>The three sections of output include the unit tests, the integration test, and the doc tests. Note that if any test in a section fails, the following sections will not be run. For example, if a unit test fails, there won‚Äôt be any output for integration and doc tests because those tests will only be run if all unit tests are passing.</p>
<p>The first section for the unit tests is the same as we‚Äôve been seeing: one line for each unit test (one named <code>internal</code> that we added in Listing 11-12) and then a summary line for the unit tests.</p>
<p>The integration tests section starts with the line <code>Running tests/integration_test.rs</code>. Next, there is a line for each test function in that integration test and a summary line for the results of the integration test just before the <code>Doc-tests adder</code> section starts.</p>
<p>Each integration test file has its own section, so if we add more files in the <em>tests</em> directory, there will be more integration test sections.</p>
<p>We can still run a particular integration test function by specifying the test function‚Äôs name as an argument to <code>cargo test</code>. To run all the tests in a particular integration test file, use the <code>--test</code> argument of <code>cargo test</code> followed by the name of the file:</p>
<pre><code class="language-console">$ cargo test --test integration_test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.64s
     Running tests/integration_test.rs (target/debug/deps/integration_test-82e7799c1bc62298)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>This command runs only the tests in the <em>tests/integration_test.rs</em> file.</p>
<h4 id="submodules-in-integration-tests"><a class="header" href="#submodules-in-integration-tests">Submodules in Integration Tests</a></h4>
<p>As you add more integration tests, you might want to make more files in the <em>tests</em> directory to help organize them; for example, you can group the test functions by the functionality they‚Äôre testing. As mentioned earlier, each file in the <em>tests</em> directory is compiled as its own separate crate, which is useful for creating separate scopes to more closely imitate the way end users will be using your crate. However, this means files in the <em>tests</em> directory don‚Äôt share the same behavior as files in <em>src</em> do, as you learned in Chapter 7 regarding how to separate code into modules and files.</p>
<p>The different behavior of <em>tests</em> directory files is most noticeable when you have a set of helper functions to use in multiple integration test files and you try to follow the steps in the <a href="ch07-05-separating-modules-into-different-files.html">‚ÄúSeparating Modules into Different Files‚Äù</a><!-- ignore --> section of Chapter 7 to extract them into a common module. For example, if we create <em>tests/common.rs</em> and place a function named <code>setup</code> in it, we can add some code to <code>setup</code> that we want to call from multiple test functions in multiple test files:</p>
<p><span class="filename">–§–∞–π–ª: tests/common.rs</span></p>
<pre><code class="language-rust noplayground">pub fn setup() {
    // setup code specific to your library's tests would go here
}</code></pre>
<p>When we run the tests again, we‚Äôll see a new section in the test output for the <em>common.rs</em> file, even though this file doesn‚Äôt contain any test functions nor did we call the <code>setup</code> function from anywhere:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.89s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/common.rs (target/debug/deps/common-92948b65e88960b4)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-92948b65e88960b4)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Having <code>common</code> appear in the test results with <code>running 0 tests</code> displayed for it is not what we wanted. We just wanted to share some code with the other integration test files. To avoid having <code>common</code> appear in the test output, instead of creating <em>tests/common.rs</em>, we‚Äôll create <em>tests/common/mod.rs</em>. The project directory now looks like this:</p>
<pre><code class="language-text">‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ src
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ lib.rs
‚îî‚îÄ‚îÄ tests
    ‚îú‚îÄ‚îÄ common
    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ mod.rs
    ‚îî‚îÄ‚îÄ integration_test.rs
</code></pre>
<p>This is the older naming convention that Rust also understands that we mentioned in <a href="ch07-05-separating-modules-into-different-files.html#alternate-file-paths">‚ÄúAlternate File Paths‚Äù</a><!-- ignore --> in Chapter 7. Naming the file this way tells Rust not to treat the <code>common</code> module as an integration test file. When we move the <code>setup</code> function code into <em>tests/common/mod.rs</em> and delete the <em>tests/common.rs</em> file, the section in the test output will no longer appear. Files in subdirectories of the <em>tests</em> directory don‚Äôt get compiled as separate crates or have sections in the test output.</p>
<p>After we‚Äôve created <em>tests/common/mod.rs</em>, we can use it from any of the integration test files as a module. Here‚Äôs an example of calling the <code>setup</code> function from the <code>it_adds_two</code> test in <em>tests/integration_test.rs</em>:</p>
<p><span class="filename">–§–∞–π–ª: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">use adder::add_two;

mod common;

#[test]
fn it_adds_two() {
    common::setup();

    let result = add_two(2);
    assert_eq!(result, 4);
}</code></pre>
<p>Note that the <code>mod common;</code> declaration is the same as the module declaration we demonstrated in Listing 7-21. Then, in the test function, we can call the <code>common::setup()</code> function.</p>
<h4 id="integration-tests-for-binary-crates"><a class="header" href="#integration-tests-for-binary-crates">Integration Tests for Binary Crates</a></h4>
<p>If our project is a binary crate that only contains a <em>src/main.rs</em> file and doesn‚Äôt have a <em>src/lib.rs</em> file, we can‚Äôt create integration tests in the <em>tests</em> directory and bring functions defined in the <em>src/main.rs</em> file into scope with a <code>use</code> statement. Only library crates expose functions that other crates can use; binary crates are meant to be run on their own.</p>
<p>This is one of the reasons Rust projects that provide a binary have a straightforward <em>src/main.rs</em> file that calls logic that lives in the <em>src/lib.rs</em> file. Using that structure, integration tests <em>can</em> test the library crate with <code>use</code> to make the important functionality available. If the important functionality works, the small amount of code in the <em>src/main.rs</em> file will work as well, and that small amount of code doesn‚Äôt need to be tested.</p>
<h2 id="–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-10"><a class="header" href="#–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-10">–ü–æ–¥–≤–µ–¥—ë–º –∏—Ç–æ–≥–∏</a></h2>
<p>Rust‚Äôs testing features provide a way to specify how code should function to ensure it continues to work as you expect, even as you make changes. Unit tests exercise different parts of a library separately and can test private implementation details. Integration tests check that many parts of the library work together correctly, and they use the library‚Äôs public API to test the code in the same way external code will use it. Even though Rust‚Äôs type system and ownership rules help prevent some kinds of bugs, tests are still important to reduce logic bugs having to do with how your code is expected to behave.</p>
<p>Let‚Äôs combine the knowledge you learned in this chapter and in previous chapters to work on a project!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="–ü—Ä–æ–µ–∫—Ç-—Å-–≤–≤–æ–¥–æ–º-–≤—ã–≤–æ–¥–æ–º-—Ä–∞–∑—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ-–∫–æ–º–∞–Ω–¥–Ω–æ–π-—Å—Ç—Ä–æ–∫–∏"><a class="header" href="#–ü—Ä–æ–µ–∫—Ç-—Å-–≤–≤–æ–¥–æ–º-–≤—ã–≤–æ–¥–æ–º-—Ä–∞–∑—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ-–∫–æ–º–∞–Ω–¥–Ω–æ–π-—Å—Ç—Ä–æ–∫–∏">–ü—Ä–æ–µ–∫—Ç —Å –≤–≤–æ–¥–æ–º-–≤—ã–≤–æ–¥–æ–º: —Ä–∞–∑—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏</a></h1>
<p>This chapter is a recap of the many skills you‚Äôve learned so far and an exploration of a few more standard library features. We‚Äôll build a command line tool that interacts with file and command line input/output to practice some of the Rust concepts you now have under your belt.</p>
<p>Rust‚Äôs speed, safety, single binary output, and cross-platform support make it an ideal language for creating command line tools, so for our project, we‚Äôll make our own version of the classic command line search tool <code>grep</code> (<strong>g</strong>lobally search a <strong>r</strong>egular <strong>e</strong>xpression and <strong>p</strong>rint). In the simplest use case, <code>grep</code> searches a specified file for a specified string. To do so, <code>grep</code> takes as its arguments a file path and a string. Then it reads the file, finds lines in that file that contain the string argument, and prints those lines.</p>
<p>Along the way, we‚Äôll show how to make our command line tool use the terminal features that many other command line tools use. We‚Äôll read the value of an environment variable to allow the user to configure the behavior of our tool. We‚Äôll also print error messages to the standard error console stream (<code>stderr</code>) instead of standard output (<code>stdout</code>) so that, for example, the user can redirect successful output to a file while still seeing error messages onscreen.</p>
<p>One Rust community member, Andrew Gallant, has already created a fully featured, very fast version of <code>grep</code>, called <code>ripgrep</code>. By comparison, our version will be fairly simple, but this chapter will give you some of the background knowledge you need to understand a real-world project such as <code>ripgrep</code>.</p>
<p>Our <code>grep</code> project will combine a number of concepts you‚Äôve learned so far:</p>
<ul>
<li>Organizing code (<a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">Chapter 7</a><!-- ignore -->)</li>
<li>Using vectors and strings (<a href="ch08-00-common-collections.html">Chapter 8</a><!-- ignore -->)</li>
<li>Handling errors (<a href="ch09-00-error-handling.html">Chapter 9</a><!-- ignore -->)</li>
<li>Using traits and lifetimes where appropriate (<a href="ch10-00-generics.html">Chapter 10</a><!-- ignore -->)</li>
<li>Writing tests (<a href="ch11-00-testing.html">Chapter 11</a><!-- ignore -->)</li>
</ul>
<p>We‚Äôll also briefly introduce closures, iterators, and trait objects, which <a href="ch13-00-functional-features.html">Chapter 13</a><!-- ignore --> and <a href="ch18-00-oop.html">Chapter 18</a><!-- ignore --> will cover in detail.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–û–±—Ä–∞–±–æ—Ç–∫–∞-–∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤-–∫–æ–º–∞–Ω–¥–Ω–æ–π-—Å—Ç—Ä–æ–∫–∏"><a class="header" href="#–û–±—Ä–∞–±–æ—Ç–∫–∞-–∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤-–∫–æ–º–∞–Ω–¥–Ω–æ–π-—Å—Ç—Ä–æ–∫–∏">–û–±—Ä–∞–±–æ—Ç–∫–∞ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏</a></h2>
<p>Let‚Äôs create a new project with, as always, <code>cargo new</code>. We‚Äôll call our project <code>minigrep</code> to distinguish it from the <code>grep</code> tool that you might already have on your system.</p>
<pre><code class="language-console">$ cargo new minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
</code></pre>
<p>The first task is to make <code>minigrep</code> accept its two command line arguments: the file path and a string to search for. That is, we want to be able to run our program with <code>cargo run</code>, two hyphens to indicate the following arguments are for our program rather than for <code>cargo</code>, a string to search for, and a path to a file to search in, like so:</p>
<pre><code class="language-console">$ cargo run -- searchstring example-filename.txt
</code></pre>
<p>Right now, the program generated by <code>cargo new</code> cannot process arguments we give it. Some existing libraries on <a href="https://crates.io/">crates.io</a> can help with writing a program that accepts command line arguments, but because you‚Äôre just learning this concept, let‚Äôs implement this capability ourselves.</p>
<h3 id="reading-the-argument-values"><a class="header" href="#reading-the-argument-values">Reading the Argument Values</a></h3>
<p>To enable <code>minigrep</code> to read the values of command line arguments we pass to it, we‚Äôll need the <code>std::env::args</code> function provided in Rust‚Äôs standard library. This function returns an iterator of the command line arguments passed to <code>minigrep</code>. We‚Äôll cover iterators fully in <a href="ch13-00-functional-features.html">Chapter 13</a><!-- ignore
-->. For now, you only need to know two details about iterators: iterators produce a series of values, and we can call the <code>collect</code> method on an iterator to turn it into a collection, such as a vector, that contains all the elements the iterator produces.</p>
<p>The code in Listing 12-1 allows your <code>minigrep</code> program to read any command line arguments passed to it, and then collect the values into a vector.</p>
<Listing number="12-1" file-name="src/main.rs" caption="Collecting the command line arguments into a vector and printing them">
<pre><pre class="playground"><code class="language-rust edition2021">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    dbg!(args);
}</code></pre></pre>
</Listing>
<p>First we bring the <code>std::env</code> module into scope with a <code>use</code> statement so we can use its <code>args</code> function. Notice that the <code>std::env::args</code> function is nested in two levels of modules. As we discussed in <a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#creating-idiomatic-use-paths">Chapter 7</a><!-- ignore -->, in cases where the desired function is nested in more than one module, we‚Äôve chosen to bring the parent module into scope rather than the function. By doing so, we can easily use other functions from <code>std::env</code>. It‚Äôs also less ambiguous than adding <code>use std::env::args</code> and then calling the function with just <code>args</code>, because <code>args</code> might easily be mistaken for a function that‚Äôs defined in the current module.</p>
<blockquote>
<h3 id="the-args-function-and-invalid-unicode"><a class="header" href="#the-args-function-and-invalid-unicode">The <code>args</code> Function and Invalid Unicode</a></h3>
<p>Note that <code>std::env::args</code> will panic if any argument contains invalid Unicode. If your program needs to accept arguments containing invalid Unicode, use <code>std::env::args_os</code> instead. That function returns an iterator that produces <code>OsString</code> values instead of <code>String</code> values. We‚Äôve chosen to use <code>std::env::args</code> here for simplicity because <code>OsString</code> values differ per platform and are more complex to work with than <code>String</code> values.</p>
</blockquote>
<p>On the first line of <code>main</code>, we call <code>env::args</code>, and we immediately use <code>collect</code> to turn the iterator into a vector containing all the values produced by the iterator. We can use the <code>collect</code> function to create many kinds of collections, so we explicitly annotate the type of <code>args</code> to specify that we want a vector of strings. Although you very rarely need to annotate types in Rust, <code>collect</code> is one function you do often need to annotate because Rust isn‚Äôt able to infer the kind of collection you want.</p>
<p>Finally, we print the vector using the debug macro. Let‚Äôs try running the code first with no arguments and then with two arguments:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/minigrep`
[src/main.rs:5:5] args = [
    "target/debug/minigrep",
]
</code></pre>
<pre><code class="language-console">$ cargo run -- needle haystack
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.57s
     Running `target/debug/minigrep needle haystack`
[src/main.rs:5:5] args = [
    "target/debug/minigrep",
    "needle",
    "haystack",
]
</code></pre>
<p>Notice that the first value in the vector is <code>"target/debug/minigrep"</code>, which is the name of our binary. This matches the behavior of the arguments list in C, letting programs use the name by which they were invoked in their execution. It‚Äôs often convenient to have access to the program name in case you want to print it in messages or change the behavior of the program based on what command line alias was used to invoke the program. But for the purposes of this chapter, we‚Äôll ignore it and save only the two arguments we need.</p>
<h3 id="saving-the-argument-values-in-variables"><a class="header" href="#saving-the-argument-values-in-variables">Saving the Argument Values in Variables</a></h3>
<p>The program is currently able to access the values specified as command line arguments. Now we need to save the values of the two arguments in variables so we can use the values throughout the rest of the program. We do that in Listing 12-2.</p>
<Listing number="12-2" file-name="src/main.rs" caption="Creating variables to hold the query argument and file path argument">
<pre><code class="language-rust should_panic noplayground">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let query = &amp;args[1];
    let file_path = &amp;args[2];

    println!("Searching for {query}");
    println!("In file {file_path}");
}</code></pre>
</Listing>
<p>As we saw when we printed the vector, the program‚Äôs name takes up the first value in the vector at <code>args[0]</code>, so we‚Äôre starting arguments at index 1. The first argument <code>minigrep</code> takes is the string we‚Äôre searching for, so we put a reference to the first argument in the variable <code>query</code>. The second argument will be the file path, so we put a reference to the second argument in the variable <code>file_path</code>.</p>
<p>We temporarily print the values of these variables to prove that the code is working as we intend. Let‚Äôs run this program again with the arguments <code>test</code> and <code>sample.txt</code>:</p>
<pre><code class="language-console">$ cargo run -- test sample.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep test sample.txt`
Searching for test
In file sample.txt
</code></pre>
<p>Great, the program is working! The values of the arguments we need are being saved into the right variables. Later we‚Äôll add some error handling to deal with certain potential erroneous situations, such as when the user provides no arguments; for now, we‚Äôll ignore that situation and work on adding file-reading capabilities instead.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–ß—Ç–µ–Ω–∏–µ-—Ñ–∞–π–ª–∞"><a class="header" href="#–ß—Ç–µ–Ω–∏–µ-—Ñ–∞–π–ª–∞">–ß—Ç–µ–Ω–∏–µ —Ñ–∞–π–ª–∞</a></h2>
<p>Now we‚Äôll add functionality to read the file specified in the <code>file_path</code> argument. First we need a sample file to test it with: we‚Äôll use a file with a small amount of text over multiple lines with some repeated words. Listing 12-3 has an Emily Dickinson poem that will work well! Create a file called <em>poem.txt</em> at the root level of your project, and enter the poem ‚ÄúI‚Äôm Nobody! Who are you?‚Äù</p>
<Listing number="12-3" file-name="poem.txt" caption="A poem by Emily Dickinson makes a good test case.">
<pre><code class="language-text">I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
</Listing>
<p>With the text in place, edit <em>src/main.rs</em> and add code to read the file, as shown in Listing 12-4.</p>
<Listing number="12-4" file-name="src/main.rs" caption="Reading the contents of the file specified by the second argument">
<pre><code class="language-rust should_panic noplayground">use std::env;
use std::fs;

fn main() {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let query = &amp;args[1];
</span><span class="boring">    let file_path = &amp;args[2];
</span><span class="boring">
</span><span class="boring">    println!("Searching for {query}");
</span>    println!("In file {file_path}");

    let contents = fs::read_to_string(file_path)
        .expect("Should have been able to read the file");

    println!("With text:\n{contents}");
}</code></pre>
</Listing>
<p>First we bring in a relevant part of the standard library with a <code>use</code> statement: we need <code>std::fs</code> to handle files.</p>
<p>In <code>main</code>, the new statement <code>fs::read_to_string</code> takes the <code>file_path</code>, opens that file, and returns a value of type <code>std::io::Result&lt;String&gt;</code> that contains the file‚Äôs contents.</p>
<p>After that, we again add a temporary <code>println!</code> statement that prints the value of <code>contents</code> after the file is read, so we can check that the program is working so far.</p>
<p>Let‚Äôs run this code with any string as the first command line argument (because we haven‚Äôt implemented the searching part yet) and the <em>poem.txt</em> file as the second argument:</p>
<pre><code class="language-console">$ cargo run -- the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

</code></pre>
<p>Great! The code read and then printed the contents of the file. But the code has a few flaws. At the moment, the <code>main</code> function has multiple responsibilities: generally, functions are clearer and easier to maintain if each function is responsible for only one idea. The other problem is that we‚Äôre not handling errors as well as we could. The program is still small, so these flaws aren‚Äôt a big problem, but as the program grows, it will be harder to fix them cleanly. It‚Äôs a good practice to begin refactoring early on when developing a program because it‚Äôs much easier to refactor smaller amounts of code. We‚Äôll do that next.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥-—Ä–∞–∑–≤–∏—Ç–∏–µ-–º–æ–¥—É–ª—å–Ω–æ—Å—Ç–∏-–∏-–æ–±—Ä–∞–±–æ—Ç–∫–∏-–æ—à–∏–±–æ–∫"><a class="header" href="#–†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥-—Ä–∞–∑–≤–∏—Ç–∏–µ-–º–æ–¥—É–ª—å–Ω–æ—Å—Ç–∏-–∏-–æ–±—Ä–∞–±–æ—Ç–∫–∏-–æ—à–∏–±–æ–∫">–†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥: —Ä–∞–∑–≤–∏—Ç–∏–µ –º–æ–¥—É–ª—å–Ω–æ—Å—Ç–∏ –∏ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫</a></h2>
<p>To improve our program, we‚Äôll fix four problems that have to do with the program‚Äôs structure and how it‚Äôs handling potential errors. First, our <code>main</code> function now performs two tasks: it parses arguments and reads files. As our program grows, the number of separate tasks the <code>main</code> function handles will increase. As a function gains responsibilities, it becomes more difficult to reason about, harder to test, and harder to change without breaking one of its parts. It‚Äôs best to separate functionality so each function is responsible for one task.</p>
<p>This issue also ties into the second problem: although <code>query</code> and <code>file_path</code> are configuration variables to our program, variables like <code>contents</code> are used to perform the program‚Äôs logic. The longer <code>main</code> becomes, the more variables we‚Äôll need to bring into scope; the more variables we have in scope, the harder it will be to keep track of the purpose of each. It‚Äôs best to group the configuration variables into one structure to make their purpose clear.</p>
<p>The third problem is that we‚Äôve used <code>expect</code> to print an error message when reading the file fails, but the error message just prints <code>Should have been able to read the file</code>. Reading a file can fail in a number of ways: for example, the file could be missing, or we might not have permission to open it. Right now, regardless of the situation, we‚Äôd print the same error message for everything, which wouldn‚Äôt give the user any information!</p>
<p>Fourth, we use <code>expect</code> to handle an error, and if the user runs our program without specifying enough arguments, they‚Äôll get an <code>index out of bounds</code> error from Rust that doesn‚Äôt clearly explain the problem. It would be best if all the error-handling code were in one place so future maintainers had only one place to consult the code if the error-handling logic needed to change. Having all the error-handling code in one place will also ensure that we‚Äôre printing messages that will be meaningful to our end users.</p>
<p>Let‚Äôs address these four problems by refactoring our project.</p>
<h3 id="separation-of-concerns-for-binary-projects"><a class="header" href="#separation-of-concerns-for-binary-projects">Separation of Concerns for Binary Projects</a></h3>
<p>The organizational problem of allocating responsibility for multiple tasks to the <code>main</code> function is common to many binary projects. As a result, the Rust community has developed guidelines for splitting the separate concerns of a binary program when <code>main</code> starts getting large. This process has the following steps:</p>
<ul>
<li>Split your program into a <em>main.rs</em> file and a <em>lib.rs</em> file and move your program‚Äôs logic to <em>lib.rs</em>.</li>
<li>As long as your command line parsing logic is small, it can remain in <em>main.rs</em>.</li>
<li>When the command line parsing logic starts getting complicated, extract it from <em>main.rs</em> and move it to <em>lib.rs</em>.</li>
</ul>
<p>The responsibilities that remain in the <code>main</code> function after this process should be limited to the following:</p>
<ul>
<li>Calling the command line parsing logic with the argument values</li>
<li>Setting up any other configuration</li>
<li>Calling a <code>run</code> function in <em>lib.rs</em></li>
<li>Handling the error if <code>run</code> returns an error</li>
</ul>
<p>This pattern is about separating concerns: <em>main.rs</em> handles running the program and <em>lib.rs</em> handles all the logic of the task at hand. Because you can‚Äôt test the <code>main</code> function directly, this structure lets you test all of your program‚Äôs logic by moving it into functions in <em>lib.rs</em>. The code that remains in <em>main.rs</em> will be small enough to verify its correctness by reading it. Let‚Äôs rework our program by following this process.</p>
<h4 id="extracting-the-argument-parser"><a class="header" href="#extracting-the-argument-parser">Extracting the Argument Parser</a></h4>
<p>We‚Äôll extract the functionality for parsing arguments into a function that <code>main</code> will call to prepare for moving the command line parsing logic to <em>src/lib.rs</em>. Listing 12-5 shows the new start of <code>main</code> that calls a new function <code>parse_config</code>, which we‚Äôll define in <em>src/main.rs</em> for the moment.</p>
<Listing number="12-5" file-name="src/main.rs" caption="Extracting a `parse_config` function from `main`">
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (query, file_path) = parse_config(&amp;args);

    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">
</span><span class="boring">    println!("Searching for {query}");
</span><span class="boring">    println!("In file {file_path}");
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span>}

fn parse_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let query = &amp;args[1];
    let file_path = &amp;args[2];

    (query, file_path)
}</code></pre>
</Listing>
<p>We‚Äôre still collecting the command line arguments into a vector, but instead of assigning the argument value at index 1 to the variable <code>query</code> and the argument value at index 2 to the variable <code>file_path</code> within the <code>main</code> function, we pass the whole vector to the <code>parse_config</code> function. The <code>parse_config</code> function then holds the logic that determines which argument goes in which variable and passes the values back to <code>main</code>. We still create the <code>query</code> and <code>file_path</code> variables in <code>main</code>, but <code>main</code> no longer has the responsibility of determining how the command line arguments and variables correspond.</p>
<p>This rework may seem like overkill for our small program, but we‚Äôre refactoring in small, incremental steps. After making this change, run the program again to verify that the argument parsing still works. It‚Äôs good to check your progress often, to help identify the cause of problems when they occur.</p>
<h4 id="grouping-configuration-values"><a class="header" href="#grouping-configuration-values">Grouping Configuration Values</a></h4>
<p>We can take another small step to improve the <code>parse_config</code> function further. At the moment, we‚Äôre returning a tuple, but then we immediately break that tuple into individual parts again. This is a sign that perhaps we don‚Äôt have the right abstraction yet.</p>
<p>Another indicator that shows there‚Äôs room for improvement is the <code>config</code> part of <code>parse_config</code>, which implies that the two values we return are related and are both part of one configuration value. We‚Äôre not currently conveying this meaning in the structure of the data other than by grouping the two values into a tuple; we‚Äôll instead put the two values into one struct and give each of the struct fields a meaningful name. Doing so will make it easier for future maintainers of this code to understand how the different values relate to each other and what their purpose is.</p>
<p>Listing 12-6 shows the improvements to the <code>parse_config</code> function.</p>
<Listing number="12-6" file-name="src/main.rs" caption="Refactoring `parse_config` to return an instance of a `Config` struct">
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = parse_config(&amp;args);

    println!("Searching for {}", config.query);
    println!("In file {}", config.file_path);

    let contents = fs::read_to_string(config.file_path)
        .expect("Should have been able to read the file");

    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span>}

struct Config {
    query: String,
    file_path: String,
}

fn parse_config(args: &amp;[String]) -&gt; Config {
    let query = args[1].clone();
    let file_path = args[2].clone();

    Config { query, file_path }
}</code></pre>
</Listing>
<p>We‚Äôve added a struct named <code>Config</code> defined to have fields named <code>query</code> and <code>file_path</code>. The signature of <code>parse_config</code> now indicates that it returns a <code>Config</code> value. In the body of <code>parse_config</code>, where we used to return string slices that reference <code>String</code> values in <code>args</code>, we now define <code>Config</code> to contain owned <code>String</code> values. The <code>args</code> variable in <code>main</code> is the owner of the argument values and is only letting the <code>parse_config</code> function borrow them, which means we‚Äôd violate Rust‚Äôs borrowing rules if <code>Config</code> tried to take ownership of the values in <code>args</code>.</p>
<p>There are a number of ways we could manage the <code>String</code> data; the easiest, though somewhat inefficient, route is to call the <code>clone</code> method on the values. This will make a full copy of the data for the <code>Config</code> instance to own, which takes more time and memory than storing a reference to the string data. However, cloning the data also makes our code very straightforward because we don‚Äôt have to manage the lifetimes of the references; in this circumstance, giving up a little performance to gain simplicity is a worthwhile trade-off.</p>
<blockquote>
<h3 id="the-trade-offs-of-using-clone"><a class="header" href="#the-trade-offs-of-using-clone">The Trade-Offs of Using <code>clone</code></a></h3>
<p>There‚Äôs a tendency among many Rustaceans to avoid using <code>clone</code> to fix ownership problems because of its runtime cost. In <a href="ch13-00-functional-features.html">Chapter 13</a><!-- ignore -->, you‚Äôll learn how to use more efficient methods in this type of situation. But for now, it‚Äôs okay to copy a few strings to continue making progress because you‚Äôll make these copies only once and your file path and query string are very small. It‚Äôs better to have a working program that‚Äôs a bit inefficient than to try to hyperoptimize code on your first pass. As you become more experienced with Rust, it‚Äôll be easier to start with the most efficient solution, but for now, it‚Äôs perfectly acceptable to call <code>clone</code>.</p>
</blockquote>
<p>We‚Äôve updated <code>main</code> so it places the instance of <code>Config</code> returned by <code>parse_config</code> into a variable named <code>config</code>, and we updated the code that previously used the separate <code>query</code> and <code>file_path</code> variables so it now uses the fields on the <code>Config</code> struct instead.</p>
<p>Now our code more clearly conveys that <code>query</code> and <code>file_path</code> are related and that their purpose is to configure how the program will work. Any code that uses these values knows to find them in the <code>config</code> instance in the fields named for their purpose.</p>
<h4 id="creating-a-constructor-for-config"><a class="header" href="#creating-a-constructor-for-config">Creating a Constructor for <code>Config</code></a></h4>
<p>So far, we‚Äôve extracted the logic responsible for parsing the command line arguments from <code>main</code> and placed it in the <code>parse_config</code> function. Doing so helped us see that the <code>query</code> and <code>file_path</code> values were related, and that relationship should be conveyed in our code. We then added a <code>Config</code> struct to name the related purpose of <code>query</code> and <code>file_path</code> and to be able to return the values‚Äô names as struct field names from the <code>parse_config</code> function.</p>
<p>So now that the purpose of the <code>parse_config</code> function is to create a <code>Config</code> instance, we can change <code>parse_config</code> from a plain function to a function named <code>new</code> that is associated with the <code>Config</code> struct. Making this change will make the code more idiomatic. We can create instances of types in the standard library, such as <code>String</code>, by calling <code>String::new</code>. Similarly, by changing <code>parse_config</code> into a <code>new</code> function associated with <code>Config</code>, we‚Äôll be able to create instances of <code>Config</code> by calling <code>Config::new</code>. Listing 12-7 shows the changes we need to make.</p>
<Listing number="12-7" file-name="src/main.rs" caption="Changing `parse_config` into `Config::new`">
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);
<span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span>
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
}

// --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--

<span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let query = args[1].clone();
        let file_path = args[2].clone();

        Config { query, file_path }
    }
}</code></pre>
</Listing>
<p>We‚Äôve updated <code>main</code> where we were calling <code>parse_config</code> to instead call <code>Config::new</code>. We‚Äôve changed the name of <code>parse_config</code> to <code>new</code> and moved it within an <code>impl</code> block, which associates the <code>new</code> function with <code>Config</code>. Try compiling this code again to make sure it works.</p>
<h3 id="fixing-the-error-handling"><a class="header" href="#fixing-the-error-handling">Fixing the Error Handling</a></h3>
<p>Now we‚Äôll work on fixing our error handling. Recall that attempting to access the values in the <code>args</code> vector at index 1 or index 2 will cause the program to panic if the vector contains fewer than three items. Try running the program without any arguments; it will look like this:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at src/main.rs:27:21:
index out of bounds: the len is 1 but the index is 1
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>The line <code>index out of bounds: the len is 1 but the index is 1</code> is an error message intended for programmers. It won‚Äôt help our end users understand what they should do instead. Let‚Äôs fix that now.</p>
<h4 id="improving-the-error-message"><a class="header" href="#improving-the-error-message">Improving the Error Message</a></h4>
<p>In Listing 12-8, we add a check in the <code>new</code> function that will verify that the slice is long enough before accessing index 1 and index 2. If the slice isn‚Äôt long enough, the program panics and displays a better error message.</p>
<Listing number="12-8" file-name="src/main.rs" caption="Adding a check for the number of arguments">
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span>    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
    fn new(args: &amp;[String]) -&gt; Config {
        if args.len() &lt; 3 {
            panic!("not enough arguments");
        }
        // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Config { query, file_path }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>This code is similar to <a href="ch09-03-to-panic-or-not-to-panic.html#creating-custom-types-for-validation">the <code>Guess::new</code> function we wrote in Listing 9-13</a><!-- ignore -->, where we called <code>panic!</code> when the <code>value</code> argument was out of the range of valid values. Instead of checking for a range of values here, we‚Äôre checking that the length of <code>args</code> is at least <code>3</code> and the rest of the function can operate under the assumption that this condition has been met. If <code>args</code> has fewer than three items, this condition will be <code>true</code>, and we call the <code>panic!</code> macro to end the program immediately.</p>
<p>With these extra few lines of code in <code>new</code>, let‚Äôs run the program without any arguments again to see what the error looks like now:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at src/main.rs:26:13:
not enough arguments
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>This output is better: we now have a reasonable error message. However, we also have extraneous information we don‚Äôt want to give to our users. Perhaps the technique we used in Listing 9-13 isn‚Äôt the best one to use here: a call to <code>panic!</code> is more appropriate for a programming problem than a usage problem, <a href="ch09-03-to-panic-or-not-to-panic.html#guidelines-for-error-handling">as discussed in Chapter 9</a><!-- ignore -->. Instead, we‚Äôll use the other technique you learned about in Chapter 9‚Äî<a href="ch09-02-recoverable-errors-with-result.html">returning a <code>Result</code></a><!-- ignore --> that indicates either success or an error.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="returning-a-result-from-new-instead-of-calling-panic"></a></p>
<h4 id="returning-a-result-instead-of-calling-panic"><a class="header" href="#returning-a-result-instead-of-calling-panic">Returning a <code>Result</code> Instead of Calling <code>panic!</code></a></h4>
<p>We can instead return a <code>Result</code> value that will contain a <code>Config</code> instance in the successful case and will describe the problem in the error case. We‚Äôre also going to change the function name from <code>new</code> to <code>build</code> because many programmers expect <code>new</code> functions to never fail. When <code>Config::build</code> is communicating to <code>main</code>, we can use the <code>Result</code> type to signal there was a problem. Then we can change <code>main</code> to convert an <code>Err</code> variant into a more practical error for our users without the surrounding text about <code>thread 'main'</code> and <code>RUST_BACKTRACE</code> that a call to <code>panic!</code> causes.</p>
<p>Listing 12-9 shows the changes we need to make to the return value of the function we‚Äôre now calling <code>Config::build</code> and the body of the function needed to return a <code>Result</code>. Note that this won‚Äôt compile until we update <code>main</code> as well, which we‚Äôll do in the next listing.</p>
<Listing number="12-9" file-name="src/main.rs" caption="Returning a `Result` from `Config::build`">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        Ok(Config { query, file_path })
    }
}</code></pre>
</Listing>
<p>Our <code>build</code> function returns a <code>Result</code> with a <code>Config</code> instance in the success case and a string literal in the error case. Our error values will always be string literals that have the <code>'static</code> lifetime.</p>
<p>We‚Äôve made two changes in the body of the function: instead of calling <code>panic!</code> when the user doesn‚Äôt pass enough arguments, we now return an <code>Err</code> value, and we‚Äôve wrapped the <code>Config</code> return value in an <code>Ok</code>. These changes make the function conform to its new type signature.</p>
<p>Returning an <code>Err</code> value from <code>Config::build</code> allows the <code>main</code> function to handle the <code>Result</code> value returned from the <code>build</code> function and exit the process more cleanly in the error case.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="calling-confignew-and-handling-errors"></a></p>
<h4 id="calling-configbuild-and-handling-errors"><a class="header" href="#calling-configbuild-and-handling-errors">Calling <code>Config::build</code> and Handling Errors</a></h4>
<p>To handle the error case and print a user-friendly message, we need to update <code>main</code> to handle the <code>Result</code> being returned by <code>Config::build</code>, as shown in Listing 12-10. We‚Äôll also take the responsibility of exiting the command line tool with a nonzero error code away from <code>panic!</code> and instead implement it by hand. A nonzero exit status is a convention to signal to the process that called our program that the program exited with an error state.</p>
<Listing number="12-10" file-name="src/main.rs" caption="Exiting with an error code if building a `Config` fails">
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span>use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        println!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("Should have been able to read the file");
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>In this listing, we‚Äôve used a method we haven‚Äôt covered in detail yet: <code>unwrap_or_else</code>, which is defined on <code>Result&lt;T, E&gt;</code> by the standard library. Using <code>unwrap_or_else</code> allows us to define some custom, non-<code>panic!</code> error handling. If the <code>Result</code> is an <code>Ok</code> value, this method‚Äôs behavior is similar to <code>unwrap</code>: it returns the inner value that <code>Ok</code> is wrapping. However, if the value is an <code>Err</code> value, this method calls the code in the <em>closure</em>, which is an anonymous function we define and pass as an argument to <code>unwrap_or_else</code>. We‚Äôll cover closures in more detail in <a href="ch13-00-functional-features.html">Chapter 13</a><!-- ignore -->. For now, you just need to know that <code>unwrap_or_else</code> will pass the inner value of the <code>Err</code>, which in this case is the static string <code>"not enough arguments"</code> that we added in Listing 12-9, to our closure in the argument <code>err</code> that appears between the vertical pipes. The code in the closure can then use the <code>err</code> value when it runs.</p>
<p>We‚Äôve added a new <code>use</code> line to bring <code>process</code> from the standard library into scope. The code in the closure that will be run in the error case is only two lines: we print the <code>err</code> value and then call <code>process::exit</code>. The <code>process::exit</code> function will stop the program immediately and return the number that was passed as the exit status code. This is similar to the <code>panic!</code>-based handling we used in Listing 12-8, but we no longer get all the extra output. Let‚Äôs try it:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/minigrep`
Problem parsing arguments: not enough arguments
</code></pre>
<p>Great! This output is much friendlier for our users.</p>
<h3 id="extracting-logic-from-main"><a class="header" href="#extracting-logic-from-main">Extracting Logic from <code>main</code></a></h3>
<p>Now that we‚Äôve finished refactoring the configuration parsing, let‚Äôs turn to the program‚Äôs logic. As we stated in <a href="ch12-03-improving-error-handling-and-modularity.html#separation-of-concerns-for-binary-projects">‚ÄúSeparation of Concerns for Binary Projects‚Äù</a><!-- ignore -->, we‚Äôll extract a function named <code>run</code> that will hold all the logic currently in the <code>main</code> function that isn‚Äôt involved with setting up configuration or handling errors. When we‚Äôre done, <code>main</code> will be concise and easy to verify by inspection, and we‚Äôll be able to write tests for all the other logic.</p>
<p>Listing 12-11 shows the extracted <code>run</code> function. For now, we‚Äôre just making the small, incremental improvement of extracting the function. We‚Äôre still defining the function in <em>src/main.rs</em>.</p>
<Listing number="12-11" file-name="src/main.rs" caption="Extracting a `run` function containing the rest of the program logic">
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!("Searching for {}", config.query);
    println!("In file {}", config.file_path);

    run(config);
}

fn run(config: Config) {
    let contents = fs::read_to_string(config.file_path)
        .expect("Should have been able to read the file");

    println!("With text:\n{contents}");
}

// --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>The <code>run</code> function now contains all the remaining logic from <code>main</code>, starting from reading the file. The <code>run</code> function takes the <code>Config</code> instance as an argument.</p>
<h4 id="returning-errors-from-the-run-function"><a class="header" href="#returning-errors-from-the-run-function">Returning Errors from the <code>run</code> Function</a></h4>
<p>With the remaining program logic separated into the <code>run</code> function, we can improve the error handling, as we did with <code>Config::build</code> in Listing 12-9. Instead of allowing the program to panic by calling <code>expect</code>, the <code>run</code> function will return a <code>Result&lt;T, E&gt;</code> when something goes wrong. This will let us further consolidate the logic around handling errors into <code>main</code> in a user-friendly way. Listing 12-12 shows the changes we need to make to the signature and body of <code>run</code>.</p>
<Listing number="12-12" file-name="src/main.rs" caption="Changing the `run` function to return `Result`">
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span>use std::error::Error;

// --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--

<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    run(config);
</span><span class="boring">}
</span><span class="boring">
</span>fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    println!("With text:\n{contents}");

    Ok(())
}
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>We‚Äôve made three significant changes here. First, we changed the return type of the <code>run</code> function to <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>. This function previously returned the unit type, <code>()</code>, and we keep that as the value returned in the <code>Ok</code> case.</p>
<p>For the error type, we used the <em>trait object</em> <code>Box&lt;dyn Error&gt;</code> (and we‚Äôve brought <code>std::error::Error</code> into scope with a <code>use</code> statement at the top). We‚Äôll cover trait objects in <a href="ch18-00-oop.html">Chapter 18</a><!-- ignore -->. For now, just know that <code>Box&lt;dyn Error&gt;</code> means the function will return a type that implements the <code>Error</code> trait, but we don‚Äôt have to specify what particular type the return value will be. This gives us flexibility to return error values that may be of different types in different error cases. The <code>dyn</code> keyword is short for <em>dynamic</em>.</p>
<p>Second, we‚Äôve removed the call to <code>expect</code> in favor of the <code>?</code> operator, as we talked about in <a href="ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator">Chapter 9</a><!-- ignore -->. Rather than <code>panic!</code> on an error, <code>?</code> will return the error value from the current function for the caller to handle.</p>
<p>Third, the <code>run</code> function now returns an <code>Ok</code> value in the success case. We‚Äôve declared the <code>run</code> function‚Äôs success type as <code>()</code> in the signature, which means we need to wrap the unit type value in the <code>Ok</code> value. This <code>Ok(())</code> syntax might look a bit strange at first, but using <code>()</code> like this is the idiomatic way to indicate that we‚Äôre calling <code>run</code> for its side effects only; it doesn‚Äôt return a value we need.</p>
<p>When you run this code, it will compile but will display a warning:</p>
<pre><code class="language-console">$ cargo run -- the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
warning: unused `Result` that must be used
  --&gt; src/main.rs:19:5
   |
19 |     run(config);
   |     ^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
19 |     let _ = run(config);
   |     +++++++

warning: `minigrep` (bin "minigrep") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.71s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

</code></pre>
<p>Rust tells us that our code ignored the <code>Result</code> value and the <code>Result</code> value might indicate that an error occurred. But we‚Äôre not checking to see whether or not there was an error, and the compiler reminds us that we probably meant to have some error-handling code here! Let‚Äôs rectify that problem now.</p>
<h4 id="handling-errors-returned-from-run-in-main"><a class="header" href="#handling-errors-returned-from-run-in-main">Handling Errors Returned from <code>run</code> in <code>main</code></a></h4>
<p>We‚Äôll check for errors and handle them using a technique similar to one we used with <code>Config::build</code> in Listing 12-10, but with a slight difference:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!("Searching for {}", config.query);
    println!("In file {}", config.file_path);

    if let Err(e) = run(config) {
        println!("Application error: {e}");
        process::exit(1);
    }
}
<span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>We use <code>if let</code> rather than <code>unwrap_or_else</code> to check whether <code>run</code> returns an <code>Err</code> value and to call <code>process::exit(1)</code> if it does. The <code>run</code> function doesn‚Äôt return a value that we want to <code>unwrap</code> in the same way that <code>Config::build</code> returns the <code>Config</code> instance. Because <code>run</code> returns <code>()</code> in the success case, we only care about detecting an error, so we don‚Äôt need <code>unwrap_or_else</code> to return the unwrapped value, which would only be <code>()</code>.</p>
<p>The bodies of the <code>if let</code> and the <code>unwrap_or_else</code> functions are the same in both cases: we print the error and exit.</p>
<h3 id="splitting-code-into-a-library-crate"><a class="header" href="#splitting-code-into-a-library-crate">Splitting Code into a Library Crate</a></h3>
<p>Our <code>minigrep</code> project is looking good so far! Now we‚Äôll split the <em>src/main.rs</em> file and put some code into the <em>src/lib.rs</em> file. That way, we can test the code and have a <em>src/main.rs</em> file with fewer responsibilities.</p>
<p>Let‚Äôs move all the code that isn‚Äôt in the <code>main</code> function from <em>src/main.rs</em> to <em>src/lib.rs</em>:</p>
<ul>
<li>The <code>run</code> function definition</li>
<li>The relevant <code>use</code> statements</li>
<li>The definition of <code>Config</code></li>
<li>The <code>Config::build</code> function definition</li>
</ul>
<p>The contents of <em>src/lib.rs</em> should have the signatures shown in Listing 12-13 (we‚Äôve omitted the bodies of the functions for brevity). Note that this won‚Äôt compile until we modify <em>src/main.rs</em> in Listing 12-14.</p>
<Listing number="12-13" file-name="src/lib.rs" caption="Moving `Config` and `run` into *src/lib.rs*">
<pre><code class="language-rust ignore does_not_compile">use std::error::Error;
use std::fs;

pub struct Config {
    pub query: String,
    pub file_path: String,
}

impl Config {
    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span>    }
}

pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    println!("With text:\n{contents}");
</span><span class="boring">
</span><span class="boring">    Ok(())
</span>}</code></pre>
</Listing>
<p>We‚Äôve made liberal use of the <code>pub</code> keyword: on <code>Config</code>, on its fields and its <code>build</code> method, and on the <code>run</code> function. We now have a library crate that has a public API we can test!</p>
<p>Now we need to bring the code we moved to <em>src/lib.rs</em> into the scope of the binary crate in <em>src/main.rs</em>, as shown in Listing 12-14.</p>
<Listing number="12-14" file-name="src/main.rs" caption="Using the `minigrep` library crate in *src/main.rs*">
<pre><code class="language-rust ignore">use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("Problem parsing arguments: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span>    if let Err(e) = minigrep::run(config) {
        // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">        println!("Application error: {e}");
</span><span class="boring">        process::exit(1);
</span>    }
}</code></pre>
</Listing>
<p>We add a <code>use minigrep::Config</code> line to bring the <code>Config</code> type from the library crate into the binary crate‚Äôs scope, and we prefix the <code>run</code> function with our crate name. Now all the functionality should be connected and should work. Run the program with <code>cargo run</code> and make sure everything works correctly.</p>
<p>Whew! That was a lot of work, but we‚Äôve set ourselves up for success in the future. Now it‚Äôs much easier to handle errors, and we‚Äôve made the code more modular. Almost all of our work will be done in <em>src/lib.rs</em> from here on out.</p>
<p>Let‚Äôs take advantage of this newfound modularity by doing something that would have been difficult with the old code but is easy with the new code: we‚Äôll write some tests!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="developing-the-librarys-functionality-with-test-driven-development"><a class="header" href="#developing-the-librarys-functionality-with-test-driven-development">Developing the Library‚Äôs Functionality with Test-Driven Development</a></h2>
<p>Now that we‚Äôve extracted the logic into <em>src/lib.rs</em> and left the argument collecting and error handling in <em>src/main.rs</em>, it‚Äôs much easier to write tests for the core functionality of our code. We can call functions directly with various arguments and check return values without having to call our binary from the command line.</p>
<p>In this section, we‚Äôll add the searching logic to the <code>minigrep</code> program using the test-driven development (TDD) process with the following steps:</p>
<ol>
<li>Write a test that fails and run it to make sure it fails for the reason you expect.</li>
<li>Write or modify just enough code to make the new test pass.</li>
<li>Refactor the code you just added or changed and make sure the tests continue to pass.</li>
<li>Repeat from step 1!</li>
</ol>
<p>Though it‚Äôs just one of many ways to write software, TDD can help drive code design. Writing the test before you write the code that makes the test pass helps to maintain high test coverage throughout the process.</p>
<p>We‚Äôll test-drive the implementation of the functionality that will actually do the searching for the query string in the file contents and produce a list of lines that match the query. We‚Äôll add this functionality in a function called <code>search</code>.</p>
<h3 id="writing-a-failing-test"><a class="header" href="#writing-a-failing-test">Writing a Failing Test</a></h3>
<p>Because we don‚Äôt need them anymore, let‚Äôs remove the <code>println!</code> statements from <em>src/lib.rs</em> and <em>src/main.rs</em> that we used to check the program‚Äôs behavior. Then, in <em>src/lib.rs</em>, we‚Äôll add a <code>tests</code> module with a test function, as we did in <a href="ch11-01-writing-tests.html#the-anatomy-of-a-test-function">Chapter 11</a><!-- ignore -->. The test function specifies the behavior we want the <code>search</code> function to have: it will take a query and the text to search, and it will return only the lines from the text that contain the query. Listing 12-15 shows this test, which won‚Äôt compile yet.</p>
<Listing number="12-15" file-name="src/lib.rs" caption="Creating a failing test for the `search` function we wish we had">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_result() {
        let query = "duct";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.";

        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
    }
}</code></pre>
</Listing>
<p>This test searches for the string <code>"duct"</code>. The text we‚Äôre searching is three lines, only one of which contains <code>"duct"</code> (note that the backslash after the opening double quote tells Rust not to put a newline character at the beginning of the contents of this string literal). We assert that the value returned from the <code>search</code> function contains only the line we expect.</p>
<p>We aren‚Äôt yet able to run this test and watch it fail because the test doesn‚Äôt even compile: the <code>search</code> function doesn‚Äôt exist yet! In accordance with TDD principles, we‚Äôll add just enough code to get the test to compile and run by adding a definition of the <code>search</code> function that always returns an empty vector, as shown in Listing 12-16. Then the test should compile and fail because an empty vector doesn‚Äôt match a vector containing the line <code>"safe, fast, productive."</code></p>
<Listing number="12-16" file-name="src/lib.rs" caption="Defining just enough of the `search` function so our test will compile">
<pre><code class="language-rust noplayground"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    vec![]
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>Notice that we need to define an explicit lifetime <code>'a</code> in the signature of <code>search</code> and use that lifetime with the <code>contents</code> argument and the return value. Recall in <a href="ch10-03-lifetime-syntax.html">Chapter 10</a><!-- ignore --> that the lifetime parameters specify which argument lifetime is connected to the lifetime of the return value. In this case, we indicate that the returned vector should contain string slices that reference slices of the argument <code>contents</code> (rather than the argument <code>query</code>).</p>
<p>In other words, we tell Rust that the data returned by the <code>search</code> function will live as long as the data passed into the <code>search</code> function in the <code>contents</code> argument. This is important! The data referenced <em>by</em> a slice needs to be valid for the reference to be valid; if the compiler assumes we‚Äôre making string slices of <code>query</code> rather than <code>contents</code>, it will do its safety checking incorrectly.</p>
<p>If we forget the lifetime annotations and try to compile this function, we‚Äôll get this error:</p>
<pre><code class="language-console">$ cargo build
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
error[E0106]: missing lifetime specifier
  --&gt; src/lib.rs:28:51
   |
28 | pub fn search(query: &amp;str, contents: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
   |                      ----            ----         ^ expected named lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `query` or `contents`
help: consider introducing a named lifetime parameter
   |
28 | pub fn search&lt;'a&gt;(query: &amp;'a str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
   |              ++++         ++                 ++              ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `minigrep` (lib) due to 1 previous error
</code></pre>
<p>Rust can‚Äôt possibly know which of the two arguments we need, so we need to tell it explicitly. Because <code>contents</code> is the argument that contains all of our text and we want to return the parts of that text that match, we know <code>contents</code> is the argument that should be connected to the return value using the lifetime syntax.</p>
<p>Other programming languages don‚Äôt require you to connect arguments to return values in the signature, but this practice will get easier over time. You might want to compare this example with the examples in the <a href="ch10-03-lifetime-syntax.html#validating-references-with-lifetimes">‚ÄúValidating References with Lifetimes‚Äù</a><!-- ignore --> section in Chapter 10.</p>
<p>Now let‚Äôs run the test:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.97s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::one_result ... FAILED

failures:

---- tests::one_result stdout ----
thread 'tests::one_result' panicked at src/lib.rs:44:9:
assertion `left == right` failed
  left: ["safe, fast, productive."]
 right: []
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::one_result

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Great, the test fails, exactly as we expected. Let‚Äôs get the test to pass!</p>
<h3 id="writing-code-to-pass-the-test"><a class="header" href="#writing-code-to-pass-the-test">Writing Code to Pass the Test</a></h3>
<p>Currently, our test is failing because we always return an empty vector. To fix that and implement <code>search</code>, our program needs to follow these steps:</p>
<ol>
<li>Iterate through each line of the contents.</li>
<li>Check whether the line contains our query string.</li>
<li>If it does, add it to the list of values we‚Äôre returning.</li>
<li>If it doesn‚Äôt, do nothing.</li>
<li>Return the list of results that match.</li>
</ol>
<p>Let‚Äôs work through each step, starting with iterating through lines.</p>
<h4 id="iterating-through-lines-with-the-lines-method"><a class="header" href="#iterating-through-lines-with-the-lines-method">Iterating Through Lines with the <code>lines</code> Method</a></h4>
<p>Rust has a helpful method to handle line-by-line iteration of strings, conveniently named <code>lines</code>, that works as shown in Listing 12-17. Note that this won‚Äôt compile yet.</p>
<Listing number="12-17" file-name="src/lib.rs" caption="Iterating through each line in `contents`">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        // do something with line
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>The <code>lines</code> method returns an iterator. We‚Äôll talk about iterators in depth in <a href="ch13-02-iterators.html">Chapter 13</a><!-- ignore -->, but recall that you saw this way of using an iterator in <a href="ch03-05-control-flow.html#looping-through-a-collection-with-for">Listing 3-5</a><!-- ignore -->, where we used a <code>for</code> loop with an iterator to run some code on each item in a collection.</p>
<h4 id="searching-each-line-for-the-query"><a class="header" href="#searching-each-line-for-the-query">Searching Each Line for the Query</a></h4>
<p>Next, we‚Äôll check whether the current line contains our query string. Fortunately, strings have a helpful method named <code>contains</code> that does this for us! Add a call to the <code>contains</code> method in the <code>search</code> function, as shown in Listing 12-18. Note that this still won‚Äôt compile yet.</p>
<Listing number="12-18" file-name="src/lib.rs" caption="Adding functionality to see whether the line contains the string in `query`">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        if line.contains(query) {
            // do something with line
        }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>At the moment, we‚Äôre building up functionality. To get the code to compile, we need to return a value from the body as we indicated we would in the function signature.</p>
<h4 id="storing-matching-lines"><a class="header" href="#storing-matching-lines">Storing Matching Lines</a></h4>
<p>To finish this function, we need a way to store the matching lines that we want to return. For that, we can make a mutable vector before the <code>for</code> loop and call the <code>push</code> method to store a <code>line</code> in the vector. After the <code>for</code> loop, we return the vector, as shown in Listing 12-19.</p>
<Listing number="12-19" file-name="src/lib.rs" caption="Storing the lines that match so we can return them">
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>Now the <code>search</code> function should return only the lines that contain <code>query</code>, and our test should pass. Let‚Äôs run the test:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.22s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::one_result ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Our test passed, so we know it works!</p>
<p>At this point, we could consider opportunities for refactoring the implementation of the search function while keeping the tests passing to maintain the same functionality. The code in the search function isn‚Äôt too bad, but it doesn‚Äôt take advantage of some useful features of iterators. We‚Äôll return to this example in <a href="ch13-02-iterators.html">Chapter 13</a><!-- ignore -->, where we‚Äôll explore iterators in detail, and look at how to improve it.</p>
<h4 id="using-the-search-function-in-the-run-function"><a class="header" href="#using-the-search-function-in-the-run-function">Using the <code>search</code> Function in the <code>run</code> Function</a></h4>
<p>Now that the <code>search</code> function is working and tested, we need to call <code>search</code> from our <code>run</code> function. We need to pass the <code>config.query</code> value and the <code>contents</code> that <code>run</code> reads from the file to the <code>search</code> function. Then <code>run</code> will print each line returned from <code>search</code>:</p>
<p><span class="filename">–§–∞–π–ª: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    for line in search(&amp;config.query, &amp;contents) {
        println!("{line}");
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>We‚Äôre still using a <code>for</code> loop to return each line from <code>search</code> and print it.</p>
<p>Now the entire program should work! Let‚Äôs try it out, first with a word that should return exactly one line from the Emily Dickinson poem: <em>frog</em>.</p>
<pre><code class="language-console">$ cargo run -- frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.38s
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
</code></pre>
<p>Cool! Now let‚Äôs try a word that will match multiple lines, like <em>body</em>:</p>
<pre><code class="language-console">$ cargo run -- body poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep body poem.txt`
I'm nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>And finally, let‚Äôs make sure that we don‚Äôt get any lines when we search for a word that isn‚Äôt anywhere in the poem, such as <em>monomorphization</em>:</p>
<pre><code class="language-console">$ cargo run -- monomorphization poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep monomorphization poem.txt`
</code></pre>
<p>Excellent! We‚Äôve built our own mini version of a classic tool and learned a lot about how to structure applications. We‚Äôve also learned a bit about file input and output, lifetimes, testing, and command line parsing.</p>
<p>To round out this project, we‚Äôll briefly demonstrate how to work with environment variables and how to print to standard error, both of which are useful when you‚Äôre writing command line programs.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–†–∞–±–æ—Ç–∞-—Å-–ø–µ—Ä–µ–º–µ–Ω–Ω—ã–º–∏-–æ–∫—Ä—É–∂–µ–Ω–∏—è"><a class="header" href="#–†–∞–±–æ—Ç–∞-—Å-–ø–µ—Ä–µ–º–µ–Ω–Ω—ã–º–∏-–æ–∫—Ä—É–∂–µ–Ω–∏—è">–†–∞–±–æ—Ç–∞ —Å –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–º–∏ –æ–∫—Ä—É–∂–µ–Ω–∏—è</a></h2>
<p>We‚Äôll improve <code>minigrep</code> by adding an extra feature: an option for case-insensitive searching that the user can turn on via an environment variable. We could make this feature a command line option and require that users enter it each time they want it to apply, but by instead making it an environment variable, we allow our users to set the environment variable once and have all their searches be case insensitive in that terminal session.</p>
<h3 id="writing-a-failing-test-for-the-case-insensitive-search-function"><a class="header" href="#writing-a-failing-test-for-the-case-insensitive-search-function">Writing a Failing Test for the Case-Insensitive <code>search</code> Function</a></h3>
<p>We first add a new <code>search_case_insensitive</code> function that will be called when the environment variable has a value. We‚Äôll continue to follow the TDD process, so the first step is again to write a failing test. We‚Äôll add a new test for the new <code>search_case_insensitive</code> function and rename our old test from <code>one_result</code> to <code>case_sensitive</code> to clarify the differences between the two tests, as shown in Listing 12-20.</p>
<Listing number="12-20" file-name="src/lib.rs" caption="Adding a new failing test for the case-insensitive function we‚Äôre about to add">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    for line in search(&amp;config.query, &amp;contents) {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn case_sensitive() {
        let query = "duct";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.
Duct tape.";

        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
    }

    #[test]
    fn case_insensitive() {
        let query = "rUsT";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.
Trust me.";

        assert_eq!(
            vec!["Rust:", "Trust me."],
            search_case_insensitive(query, contents)
        );
    }
}</code></pre>
</Listing>
<p>Note that we‚Äôve edited the old test‚Äôs <code>contents</code> too. We‚Äôve added a new line with the text <code>"Duct tape."</code> using a capital <em>D</em> that shouldn‚Äôt match the query <code>"duct"</code> when we‚Äôre searching in a case-sensitive manner. Changing the old test in this way helps ensure that we don‚Äôt accidentally break the case-sensitive search functionality that we‚Äôve already implemented. This test should pass now and should continue to pass as we work on the case-insensitive search.</p>
<p>The new test for the case-<em>insensitive</em> search uses <code>"rUsT"</code> as its query. In the <code>search_case_insensitive</code> function we‚Äôre about to add, the query <code>"rUsT"</code> should match the line containing <code>"Rust:"</code> with a capital <em>R</em> and match the line <code>"Trust me."</code> even though both have different casing from the query. This is our failing test, and it will fail to compile because we haven‚Äôt yet defined the <code>search_case_insensitive</code> function. Feel free to add a skeleton implementation that always returns an empty vector, similar to the way we did for the <code>search</code> function in Listing 12-16 to see the test compile and fail.</p>
<h3 id="implementing-the-search_case_insensitive-function"><a class="header" href="#implementing-the-search_case_insensitive-function">Implementing the <code>search_case_insensitive</code> Function</a></h3>
<p>The <code>search_case_insensitive</code> function, shown in Listing 12-21, will be almost the same as the <code>search</code> function. The only difference is that we‚Äôll lowercase the <code>query</code> and each <code>line</code> so that whatever the case of the input arguments, they‚Äôll be the same case when we check whether the line contains the query.</p>
<Listing number="12-21" file-name="src/lib.rs" caption="Defining the `search_case_insensitive` function to lowercase the query and the line before comparing them">
<pre><code class="language-rust noplayground"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    for line in search(&amp;config.query, &amp;contents) {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search_case_insensitive&lt;'a&gt;(
    query: &amp;str,
    contents: &amp;'a str,
) -&gt; Vec&lt;&amp;'a str&gt; {
    let query = query.to_lowercase();
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.to_lowercase().contains(&amp;query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>First we lowercase the <code>query</code> string and store it in a new variable with the same name, shadowing the original. Calling <code>to_lowercase</code> on the query is necessary so that no matter whether the user‚Äôs query is <code>"rust"</code>, <code>"RUST"</code>, <code>"Rust"</code>, or <code>"rUsT"</code>, we‚Äôll treat the query as if it were <code>"rust"</code> and be insensitive to the case. While <code>to_lowercase</code> will handle basic Unicode, it won‚Äôt be 100% accurate. If we were writing a real application, we‚Äôd want to do a bit more work here, but this section is about environment variables, not Unicode, so we‚Äôll leave it at that here.</p>
<p>Note that <code>query</code> is now a <code>String</code> rather than a string slice because calling <code>to_lowercase</code> creates new data rather than referencing existing data. Say the query is <code>"rUsT"</code>, as an example: that string slice doesn‚Äôt contain a lowercase <code>u</code> or <code>t</code> for us to use, so we have to allocate a new <code>String</code> containing <code>"rust"</code>. When we pass <code>query</code> as an argument to the <code>contains</code> method now, we need to add an ampersand because the signature of <code>contains</code> is defined to take a string slice.</p>
<p>Next, we add a call to <code>to_lowercase</code> on each <code>line</code> to lowercase all characters. Now that we‚Äôve converted <code>line</code> and <code>query</code> to lowercase, we‚Äôll find matches no matter what the case of the query is.</p>
<p>Let‚Äôs see if this implementation passes the tests:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.33s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 2 tests
test tests::case_insensitive ... ok
test tests::case_sensitive ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Great! They passed. Now, let‚Äôs call the new <code>search_case_insensitive</code> function from the <code>run</code> function. First we‚Äôll add a configuration option to the <code>Config</code> struct to switch between case-sensitive and case-insensitive search. Adding this field will cause compiler errors because we aren‚Äôt initializing this field anywhere yet:</p>
<p><span class="filename">–§–∞–π–ª: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>pub struct Config {
    pub query: String,
    pub file_path: String,
    pub ignore_case: bool,
}
<span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>We added the <code>ignore_case</code> field that holds a Boolean. Next, we need the <code>run</code> function to check the <code>ignore_case</code> field‚Äôs value and use that to decide whether to call the <code>search</code> function or the <code>search_case_insensitive</code> function, as shown in Listing 12-22. This still won‚Äôt compile yet.</p>
<Listing number="12-22" file-name="src/lib.rs" caption="Calling either `search` or `search_case_insensitive` based on the value in `config.ignore_case`">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    let results = if config.ignore_case {
        search_case_insensitive(&amp;config.query, &amp;contents)
    } else {
        search(&amp;config.query, &amp;contents)
    };

    for line in results {
        println!("{line}");
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>Finally, we need to check for the environment variable. The functions for working with environment variables are in the <code>env</code> module in the standard library, so we bring that module into scope at the top of <em>src/lib.rs</em>. Then we‚Äôll use the <code>var</code> function from the <code>env</code> module to check to see if any value has been set for an environment variable named <code>IGNORE_CASE</code>, as shown in Listing 12-23.</p>
<Listing number="12-23" file-name="src/lib.rs" caption="Checking for any value in an environment variable named `IGNORE_CASE`">
<pre><code class="language-rust noplayground">use std::env;
// --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--

<span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        let ignore_case = env::var("IGNORE_CASE").is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>Here, we create a new variable, <code>ignore_case</code>. To set its value, we call the <code>env::var</code> function and pass it the name of the <code>IGNORE_CASE</code> environment variable. The <code>env::var</code> function returns a <code>Result</code> that will be the successful <code>Ok</code> variant that contains the value of the environment variable if the environment variable is set to any value. It will return the <code>Err</code> variant if the environment variable is not set.</p>
<p>We‚Äôre using the <code>is_ok</code> method on the <code>Result</code> to check whether the environment variable is set, which means the program should do a case-insensitive search. If the <code>IGNORE_CASE</code> environment variable isn‚Äôt set to anything, <code>is_ok</code> will return <code>false</code> and the program will perform a case-sensitive search. We don‚Äôt care about the <em>value</em> of the environment variable, just whether it‚Äôs set or unset, so we‚Äôre checking <code>is_ok</code> rather than using <code>unwrap</code>, <code>expect</code>, or any of the other methods we‚Äôve seen on <code>Result</code>.</p>
<p>We pass the value in the <code>ignore_case</code> variable to the <code>Config</code> instance so the <code>run</code> function can read that value and decide whether to call <code>search_case_insensitive</code> or <code>search</code>, as we implemented in Listing 12-22.</p>
<p>Let‚Äôs give it a try! First we‚Äôll run our program without the environment variable set and with the query <code>to</code>, which should match any line that contains the word <em>to</em> in all lowercase:</p>
<pre><code class="language-console">$ cargo run -- to poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Looks like that still works! Now let‚Äôs run the program with <code>IGNORE_CASE</code> set to <code>1</code> but with the same query <em>to</em>:</p>
<pre><code class="language-console">$ IGNORE_CASE=1 cargo run -- to poem.txt
</code></pre>
<p>If you‚Äôre using PowerShell, you will need to set the environment variable and run the program as separate commands:</p>
<pre><code class="language-console">PS&gt; $Env:IGNORE_CASE=1; cargo run -- to poem.txt
</code></pre>
<p>This will make <code>IGNORE_CASE</code> persist for the remainder of your shell session. It can be unset with the <code>Remove-Item</code> cmdlet:</p>
<pre><code class="language-console">PS&gt; Remove-Item Env:IGNORE_CASE
</code></pre>
<p>We should get lines that contain <em>to</em> that might have uppercase letters:</p>
<!-- manual-regeneration
cd listings/ch12-an-io-project/listing-12-23
IGNORE_CASE=1 cargo run -- to poem.txt
can't extract because of the environment variable
-->
<pre><code class="language-console">Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>Excellent, we also got lines containing <em>To</em>! Our <code>minigrep</code> program can now do case-insensitive searching controlled by an environment variable. Now you know how to manage options set using either command line arguments or environment variables.</p>
<p>Some programs allow arguments <em>and</em> environment variables for the same configuration. In those cases, the programs decide that one or the other takes precedence. For another exercise on your own, try controlling case sensitivity through either a command line argument or an environment variable. Decide whether the command line argument or the environment variable should take precedence if the program is run with one set to case sensitive and one set to ignore case.</p>
<p>The <code>std::env</code> module contains many more useful features for dealing with environment variables: check out its documentation to see what is available.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–í—ã–≤–æ–¥-—Å–æ–æ–±—â–µ–Ω–∏–π-–æ–±-–æ—à–∏–±–∫–∞—Ö-–≤-—Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π-–ø–æ—Ç–æ–∫-–æ—à–∏–±–æ–∫"><a class="header" href="#–í—ã–≤–æ–¥-—Å–æ–æ–±—â–µ–Ω–∏–π-–æ–±-–æ—à–∏–±–∫–∞—Ö-–≤-—Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π-–ø–æ—Ç–æ–∫-–æ—à–∏–±–æ–∫">–í—ã–≤–æ–¥ —Å–æ–æ–±—â–µ–Ω–∏–π –æ–± –æ—à–∏–±–∫–∞—Ö –≤ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –ø–æ—Ç–æ–∫ –æ—à–∏–±–æ–∫</a></h2>
<p>At the moment, we‚Äôre writing all of our output to the terminal using the <code>println!</code> macro. In most terminals, there are two kinds of output: <em>standard output</em> (<code>stdout</code>) for general information and <em>standard error</em> (<code>stderr</code>) for error messages. This distinction enables users to choose to direct the successful output of a program to a file but still print error messages to the screen.</p>
<p>The <code>println!</code> macro is only capable of printing to standard output, so we have to use something else to print to standard error.</p>
<h3 id="checking-where-errors-are-written"><a class="header" href="#checking-where-errors-are-written">Checking Where Errors Are Written</a></h3>
<p>First let‚Äôs observe how the content printed by <code>minigrep</code> is currently being written to standard output, including any error messages we want to write to standard error instead. We‚Äôll do that by redirecting the standard output stream to a file while intentionally causing an error. We won‚Äôt redirect the standard error stream, so any content sent to standard error will continue to display on the screen.</p>
<p>Command line programs are expected to send error messages to the standard error stream so we can still see error messages on the screen even if we redirect the standard output stream to a file. Our program is not currently well behaved: we‚Äôre about to see that it saves the error message output to a file instead!</p>
<p>To demonstrate this behavior, we‚Äôll run the program with <code>&gt;</code> and the file path, <em>output.txt</em>, that we want to redirect the standard output stream to. We won‚Äôt pass any arguments, which should cause an error:</p>
<pre><code class="language-console">$ cargo run &gt; output.txt
</code></pre>
<p>The <code>&gt;</code> syntax tells the shell to write the contents of standard output to <em>output.txt</em> instead of the screen. We didn‚Äôt see the error message we were expecting printed to the screen, so that means it must have ended up in the file. This is what <em>output.txt</em> contains:</p>
<pre><code class="language-text">Problem parsing arguments: not enough arguments
</code></pre>
<p>Yup, our error message is being printed to standard output. It‚Äôs much more useful for error messages like this to be printed to standard error so only data from a successful run ends up in the file. We‚Äôll change that.</p>
<h3 id="printing-errors-to-standard-error"><a class="header" href="#printing-errors-to-standard-error">Printing Errors to Standard Error</a></h3>
<p>We‚Äôll use the code in Listing 12-24 to change how error messages are printed. Because of the refactoring we did earlier in this chapter, all the code that prints error messages is in one function, <code>main</code>. The standard library provides the <code>eprintln!</code> macro that prints to the standard error stream, so let‚Äôs change the two places we were calling <code>println!</code> to print errors to use <code>eprintln!</code> instead.</p>
<Listing number="12-24" file-name="src/main.rs" caption="Writing error messages to standard error instead of standard output using `eprintln!`">
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!("Application error: {e}");
        process::exit(1);
    }
}</code></pre>
</Listing>
<p>Let‚Äôs now run the program again in the same way, without any arguments and redirecting standard output with <code>&gt;</code>:</p>
<pre><code class="language-console">$ cargo run &gt; output.txt
Problem parsing arguments: not enough arguments
</code></pre>
<p>Now we see the error onscreen and <em>output.txt</em> contains nothing, which is the behavior we expect of command line programs.</p>
<p>Let‚Äôs run the program again with arguments that don‚Äôt cause an error but still redirect standard output to a file, like so:</p>
<pre><code class="language-console">$ cargo run -- to poem.txt &gt; output.txt
</code></pre>
<p>We won‚Äôt see any output to the terminal, and <em>output.txt</em> will contain our results:</p>
<p><span class="filename">–§–∞–π–ª: output.txt</span></p>
<pre><code class="language-text">Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>This demonstrates that we‚Äôre now using standard output for successful output and standard error for error output as appropriate.</p>
<h2 id="–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-11"><a class="header" href="#–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-11">–ü–æ–¥–≤–µ–¥—ë–º –∏—Ç–æ–≥–∏</a></h2>
<p>This chapter recapped some of the major concepts you‚Äôve learned so far and covered how to perform common I/O operations in Rust. By using command line arguments, files, environment variables, and the <code>eprintln!</code> macro for printing errors, you‚Äôre now prepared to write command line applications. Combined with the concepts in previous chapters, your code will be well organized, store data effectively in the appropriate data structures, handle errors nicely, and be well tested.</p>
<p>Next, we‚Äôll explore some Rust features that were influenced by functional languages: closures and iterators.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="–§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ-–æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏-–∏—Ç–µ—Ä–∞—Ç–æ—Ä—ã-–∏-–∑–∞–º—ã–∫–∞–Ω–∏—è"><a class="header" href="#–§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ-–æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏-–∏—Ç–µ—Ä–∞—Ç–æ—Ä—ã-–∏-–∑–∞–º—ã–∫–∞–Ω–∏—è">–§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏: –∏—Ç–µ—Ä–∞—Ç–æ—Ä—ã –∏ –∑–∞–º—ã–∫–∞–Ω–∏—è</a></h1>
<p>Rust‚Äôs design has taken inspiration from many existing languages and techniques, and one significant influence is <em>functional programming</em>. Programming in a functional style often includes using functions as values by passing them in arguments, returning them from other functions, assigning them to variables for later execution, and so forth.</p>
<p>In this chapter, we won‚Äôt debate the issue of what functional programming is or isn‚Äôt but will instead discuss some features of Rust that are similar to features in many languages often referred to as functional.</p>
<p>More specifically, we‚Äôll cover:</p>
<ul>
<li><em>Closures</em>, a function-like construct you can store in a variable</li>
<li><em>Iterators</em>, a way of processing a series of elements</li>
<li>How to use closures and iterators to improve the I/O project in Chapter 12</li>
<li>The performance of closures and iterators (Spoiler alert: they‚Äôre faster than you might think!)</li>
</ul>
<p>We‚Äôve already covered some other Rust features, such as pattern matching and enums, that are also influenced by the functional style. Because mastering closures and iterators is an important part of writing idiomatic, fast Rust code, we‚Äôll devote this entire chapter to them.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- Old heading. Do not remove or links may break. -->
<p><a id="closures-anonymous-functions-that-can-capture-their-environment"></a></p>
<h2 id="–ó–∞–º—ã–∫–∞–Ω–∏—è-–∞–Ω–æ–Ω–∏–º–Ω—ã–µ-—Ñ—É–Ω–∫—Ü–∏–∏-–∑–∞—Ö–≤–∞—Ç—ã–≤–∞—é—â–∏–µ-—Å–≤–æ—ë-–æ–∫—Ä—É–∂–µ–Ω–∏–µ"><a class="header" href="#–ó–∞–º—ã–∫–∞–Ω–∏—è-–∞–Ω–æ–Ω–∏–º–Ω—ã–µ-—Ñ—É–Ω–∫—Ü–∏–∏-–∑–∞—Ö–≤–∞—Ç—ã–≤–∞—é—â–∏–µ-—Å–≤–æ—ë-–æ–∫—Ä—É–∂–µ–Ω–∏–µ">–ó–∞–º—ã–∫–∞–Ω–∏—è: –∞–Ω–æ–Ω–∏–º–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏, –∑–∞—Ö–≤–∞—Ç—ã–≤–∞—é—â–∏–µ —Å–≤–æ—ë –æ–∫—Ä—É–∂–µ–Ω–∏–µ</a></h2>
<p>Rust‚Äôs closures are anonymous functions you can save in a variable or pass as arguments to other functions. You can create the closure in one place and then call the closure elsewhere to evaluate it in a different context. Unlike functions, closures can capture values from the scope in which they‚Äôre defined. We‚Äôll demonstrate how these closure features allow for code reuse and behavior customization.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="creating-an-abstraction-of-behavior-with-closures"></a> <a id="refactoring-using-functions"></a> <a id="refactoring-with-closures-to-store-code"></a></p>
<h3 id="capturing-the-environment-with-closures"><a class="header" href="#capturing-the-environment-with-closures">Capturing the Environment with Closures</a></h3>
<p>We‚Äôll first examine how we can use closures to capture values from the environment they‚Äôre defined in for later use. Here‚Äôs the scenario: Every so often, our t-shirt company gives away an exclusive, limited-edition shirt to someone on our mailing list as a promotion. People on the mailing list can optionally add their favorite color to their profile. If the person chosen for a free shirt has their favorite color set, they get that color shirt. If the person hasn‚Äôt specified a favorite color, they get whatever color the company currently has the most of.</p>
<p>There are many ways to implement this. For this example, we‚Äôre going to use an enum called <code>ShirtColor</code> that has the variants <code>Red</code> and <code>Blue</code> (limiting the number of colors available for simplicity). We represent the company‚Äôs inventory with an <code>Inventory</code> struct that has a field named <code>shirts</code> that contains a <code>Vec&lt;ShirtColor&gt;</code> representing the shirt colors currently in stock. The method <code>giveaway</code> defined on <code>Inventory</code> gets the optional shirt color preference of the free shirt winner, and returns the shirt color the person will get. This setup is shown in Listing 13-1:</p>
<Listing number="13-1" file-name="src/main.rs" caption="Shirt company giveaway situation">
<pre><code class="language-rust noplayground">#[derive(Debug, PartialEq, Copy, Clone)]
enum ShirtColor {
    Red,
    Blue,
}

struct Inventory {
    shirts: Vec&lt;ShirtColor&gt;,
}

impl Inventory {
    fn giveaway(&amp;self, user_preference: Option&lt;ShirtColor&gt;) -&gt; ShirtColor {
        user_preference.unwrap_or_else(|| self.most_stocked())
    }

    fn most_stocked(&amp;self) -&gt; ShirtColor {
        let mut num_red = 0;
        let mut num_blue = 0;

        for color in &amp;self.shirts {
            match color {
                ShirtColor::Red =&gt; num_red += 1,
                ShirtColor::Blue =&gt; num_blue += 1,
            }
        }
        if num_red &gt; num_blue {
            ShirtColor::Red
        } else {
            ShirtColor::Blue
        }
    }
}

fn main() {
    let store = Inventory {
        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],
    };

    let user_pref1 = Some(ShirtColor::Red);
    let giveaway1 = store.giveaway(user_pref1);
    println!(
        "The user with preference {:?} gets {:?}",
        user_pref1, giveaway1
    );

    let user_pref2 = None;
    let giveaway2 = store.giveaway(user_pref2);
    println!(
        "The user with preference {:?} gets {:?}",
        user_pref2, giveaway2
    );
}</code></pre>
</Listing>
<p>The <code>store</code> defined in <code>main</code> has two blue shirts and one red shirt remaining to distribute for this limited-edition promotion. We call the <code>giveaway</code> method for a user with a preference for a red shirt and a user without any preference.</p>
<p>Again, this code could be implemented in many ways, and here, to focus on closures, we‚Äôve stuck to concepts you‚Äôve already learned except for the body of the <code>giveaway</code> method that uses a closure. In the <code>giveaway</code> method, we get the user preference as a parameter of type <code>Option&lt;ShirtColor&gt;</code> and call the <code>unwrap_or_else</code> method on <code>user_preference</code>. The <a href="../std/option/enum.Option.html#method.unwrap_or_else"><code>unwrap_or_else</code> method on <code>Option&lt;T&gt;</code></a><!-- ignore --> is defined by the standard library. It takes one argument: a closure without any arguments that returns a value <code>T</code> (the same type stored in the <code>Some</code> variant of the <code>Option&lt;T&gt;</code>, in this case <code>ShirtColor</code>). If the <code>Option&lt;T&gt;</code> is the <code>Some</code> variant, <code>unwrap_or_else</code> returns the value from within the <code>Some</code>. If the <code>Option&lt;T&gt;</code> is the <code>None</code> variant, <code>unwrap_or_else</code> calls the closure and returns the value returned by the closure.</p>
<p>We specify the closure expression <code>|| self.most_stocked()</code> as the argument to <code>unwrap_or_else</code>. This is a closure that takes no parameters itself (if the closure had parameters, they would appear between the two vertical bars). The body of the closure calls <code>self.most_stocked()</code>. We‚Äôre defining the closure here, and the implementation of <code>unwrap_or_else</code> will evaluate the closure later if the result is needed.</p>
<p>Running this code prints:</p>
<pre><code class="language-console">$ cargo run
   Compiling shirt-company v0.1.0 (file:///projects/shirt-company)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/shirt-company`
The user with preference Some(Red) gets Red
The user with preference None gets Blue
</code></pre>
<p>One interesting aspect here is that we‚Äôve passed a closure that calls <code>self.most_stocked()</code> on the current <code>Inventory</code> instance. The standard library didn‚Äôt need to know anything about the <code>Inventory</code> or <code>ShirtColor</code> types we defined, or the logic we want to use in this scenario. The closure captures an immutable reference to the <code>self</code> <code>Inventory</code> instance and passes it with the code we specify to the <code>unwrap_or_else</code> method. Functions, on the other hand, are not able to capture their environment in this way.</p>
<h3 id="closure-type-inference-and-annotation"><a class="header" href="#closure-type-inference-and-annotation">Closure Type Inference and Annotation</a></h3>
<p>There are more differences between functions and closures. Closures don‚Äôt usually require you to annotate the types of the parameters or the return value like <code>fn</code> functions do. Type annotations are required on functions because the types are part of an explicit interface exposed to your users. Defining this interface rigidly is important for ensuring that everyone agrees on what types of values a function uses and returns. Closures, on the other hand, aren‚Äôt used in an exposed interface like this: they‚Äôre stored in variables and used without naming them and exposing them to users of our library.</p>
<p>Closures are typically short and relevant only within a narrow context rather than in any arbitrary scenario. Within these limited contexts, the compiler can infer the types of the parameters and the return type, similar to how it‚Äôs able to infer the types of most variables (there are rare cases where the compiler needs closure type annotations too).</p>
<p>As with variables, we can add type annotations if we want to increase explicitness and clarity at the cost of being more verbose than is strictly necessary. Annotating the types for a closure would look like the definition shown in Listing 13-2. In this example, we‚Äôre defining a closure and storing it in a variable rather than defining the closure in the spot we pass it as an argument as we did in Listing 13-1.</p>
<Listing number="13-2" file-name="src/main.rs" caption="Adding optional type annotations of the parameter and return value types in the closure">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {
</span>    let expensive_closure = |num: u32| -&gt; u32 {
        println!("calculating slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    };
<span class="boring">
</span><span class="boring">    if intensity &lt; 25 {
</span><span class="boring">        println!("Today, do {} pushups!", expensive_closure(intensity));
</span><span class="boring">        println!("Next, do {} situps!", expensive_closure(intensity));
</span><span class="boring">    } else {
</span><span class="boring">        if random_number == 3 {
</span><span class="boring">            println!("Take a break today! Remember to stay hydrated!");
</span><span class="boring">        } else {
</span><span class="boring">            println!(
</span><span class="boring">                "Today, run for {} minutes!",
</span><span class="boring">                expensive_closure(intensity)
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let simulated_user_specified_value = 10;
</span><span class="boring">    let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">    generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>With type annotations added, the syntax of closures looks more similar to the syntax of functions. Here we define a function that adds 1 to its parameter and a closure that has the same behavior, for comparison. We‚Äôve added some spaces to line up the relevant parts. This illustrates how closure syntax is similar to function syntax except for the use of pipes and the amount of syntax that is optional:</p>
<pre><code class="language-rust ignore">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;</code></pre>
<p>The first line shows a function definition, and the second line shows a fully annotated closure definition. In the third line, we remove the type annotations from the closure definition. In the fourth line, we remove the brackets, which are optional because the closure body has only one expression. These are all valid definitions that will produce the same behavior when they‚Äôre called. The <code>add_one_v3</code> and <code>add_one_v4</code> lines require the closures to be evaluated to be able to compile because the types will be inferred from their usage. This is similar to <code>let v = Vec::new();</code> needing either type annotations or values of some type to be inserted into the <code>Vec</code> for Rust to be able to infer the type.</p>
<p>For closure definitions, the compiler will infer one concrete type for each of their parameters and for their return value. For instance, Listing 13-3 shows the definition of a short closure that just returns the value it receives as a parameter. This closure isn‚Äôt very useful except for the purposes of this example. Note that we haven‚Äôt added any type annotations to the definition. Because there are no type annotations, we can call the closure with any type, which we‚Äôve done here with <code>String</code> the first time. If we then try to call <code>example_closure</code> with an integer, we‚Äôll get an error.</p>
<Listing number="13-3" file-name="src/main.rs" caption="Attempting to call a closure whose types are inferred with two different types">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let example_closure = |x| x;

    let s = example_closure(String::from("hello"));
    let n = example_closure(5);
<span class="boring">}</span></code></pre>
</Listing>
<p>The compiler gives us this error:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
error[E0308]: mismatched types
 --&gt; src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |             --------------- ^- help: try using a conversion method: `.to_string()`
  |             |               |
  |             |               expected `String`, found integer
  |             arguments to this function are incorrect
  |
note: expected because the closure was earlier called with an argument of type `String`
 --&gt; src/main.rs:4:29
  |
4 |     let s = example_closure(String::from("hello"));
  |             --------------- ^^^^^^^^^^^^^^^^^^^^^ expected because this argument is of type `String`
  |             |
  |             in this closure call
note: closure parameter defined here
 --&gt; src/main.rs:2:28
  |
2 |     let example_closure = |x| x;
  |                            ^

For more information about this error, try `rustc --explain E0308`.
error: could not compile `closure-example` (bin "closure-example") due to 1 previous error
</code></pre>
<p>The first time we call <code>example_closure</code> with the <code>String</code> value, the compiler infers the type of <code>x</code> and the return type of the closure to be <code>String</code>. Those types are then locked into the closure in <code>example_closure</code>, and we get a type error when we next try to use a different type with the same closure.</p>
<h3 id="capturing-references-or-moving-ownership"><a class="header" href="#capturing-references-or-moving-ownership">Capturing References or Moving Ownership</a></h3>
<p>Closures can capture values from their environment in three ways, which directly map to the three ways a function can take a parameter: borrowing immutably, borrowing mutably, and taking ownership. The closure will decide which of these to use based on what the body of the function does with the captured values.</p>
<p>In Listing 13-4, we define a closure that captures an immutable reference to the vector named <code>list</code> because it only needs an immutable reference to print the value:</p>
<Listing number="13-4" file-name="src/main.rs" caption="Defining and calling a closure that captures an immutable reference">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let list = vec![1, 2, 3];
    println!("Before defining closure: {list:?}");

    let only_borrows = || println!("From closure: {list:?}");

    println!("Before calling closure: {list:?}");
    only_borrows();
    println!("After calling closure: {list:?}");
}</code></pre></pre>
</Listing>
<p>This example also illustrates that a variable can bind to a closure definition, and we can later call the closure by using the variable name and parentheses as if the variable name were a function name.</p>
<p>Because we can have multiple immutable references to <code>list</code> at the same time, <code>list</code> is still accessible from the code before the closure definition, after the closure definition but before the closure is called, and after the closure is called. This code compiles, runs, and prints:</p>
<pre><code class="language-console">$ cargo run
     Locking 1 package to latest compatible version
      Adding closure-example v0.1.0 (/Users/chris/dev/rust-lang/book/tmp/listings/ch13-functional-features/listing-13-04)
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Before defining closure: [1, 2, 3]
Before calling closure: [1, 2, 3]
From closure: [1, 2, 3]
After calling closure: [1, 2, 3]
</code></pre>
<p>Next, in Listing 13-5, we change the closure body so that it adds an element to the <code>list</code> vector. The closure now captures a mutable reference:</p>
<Listing number="13-5" file-name="src/main.rs" caption="Defining and calling a closure that captures a mutable reference">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut list = vec![1, 2, 3];
    println!("Before defining closure: {list:?}");

    let mut borrows_mutably = || list.push(7);

    borrows_mutably();
    println!("After calling closure: {list:?}");
}</code></pre></pre>
</Listing>
<p>This code compiles, runs, and prints:</p>
<pre><code class="language-console">$ cargo run
     Locking 1 package to latest compatible version
      Adding closure-example v0.1.0 (/Users/chris/dev/rust-lang/book/tmp/listings/ch13-functional-features/listing-13-05)
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Before defining closure: [1, 2, 3]
After calling closure: [1, 2, 3, 7]
</code></pre>
<p>Note that there‚Äôs no longer a <code>println!</code> between the definition and the call of the <code>borrows_mutably</code> closure: when <code>borrows_mutably</code> is defined, it captures a mutable reference to <code>list</code>. We don‚Äôt use the closure again after the closure is called, so the mutable borrow ends. Between the closure definition and the closure call, an immutable borrow to print isn‚Äôt allowed because no other borrows are allowed when there‚Äôs a mutable borrow. Try adding a <code>println!</code> there to see what error message you get!</p>
<p>If you want to force the closure to take ownership of the values it uses in the environment even though the body of the closure doesn‚Äôt strictly need ownership, you can use the <code>move</code> keyword before the parameter list.</p>
<p>This technique is mostly useful when passing a closure to a new thread to move the data so that it‚Äôs owned by the new thread. We‚Äôll discuss threads and why you would want to use them in detail in Chapter 16 when we talk about concurrency, but for now, let‚Äôs briefly explore spawning a new thread using a closure that needs the <code>move</code> keyword. Listing 13-6 shows Listing 13-4 modified to print the vector in a new thread rather than in the main thread:</p>
<Listing number="13-6" file-name="src/main.rs" caption="Using `move` to force the closure for the thread to take ownership of `list`">
<pre><pre class="playground"><code class="language-rust edition2021">use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    println!("Before defining closure: {list:?}");

    thread::spawn(move || println!("From thread: {list:?}"))
        .join()
        .unwrap();
}</code></pre></pre>
</Listing>
<p>We spawn a new thread, giving the thread a closure to run as an argument. The closure body prints out the list. In Listing 13-4, the closure only captured <code>list</code> using an immutable reference because that's the least amount of access to <code>list</code> needed to print it. In this example, even though the closure body still only needs an immutable reference, we need to specify that <code>list</code> should be moved into the closure by putting the <code>move</code> keyword at the beginning of the closure definition. The new thread might finish before the rest of the main thread finishes, or the main thread might finish first. If the main thread maintained ownership of <code>list</code> but ended before the new thread did and dropped <code>list</code>, the immutable reference in the thread would be invalid. Therefore, the compiler requires that <code>list</code> be moved into the closure given to the new thread so the reference will be valid. Try removing the <code>move</code> keyword or using <code>list</code> in the main thread after the closure is defined to see what compiler errors you get!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="storing-closures-using-generic-parameters-and-the-fn-traits"></a> <a id="limitations-of-the-cacher-implementation"></a> <a id="moving-captured-values-out-of-the-closure-and-the-fn-traits"></a></p>
<h3 id="moving-captured-values-out-of-closures-and-the-fn-traits"><a class="header" href="#moving-captured-values-out-of-closures-and-the-fn-traits">Moving Captured Values Out of Closures and the <code>Fn</code> Traits</a></h3>
<p>Once a closure has captured a reference or captured ownership of a value from the environment where the closure is defined (thus affecting what, if anything, is moved <em>into</em> the closure), the code in the body of the closure defines what happens to the references or values when the closure is evaluated later (thus affecting what, if anything, is moved <em>out of</em> the closure). A closure body can do any of the following: move a captured value out of the closure, mutate the captured value, neither move nor mutate the value, or capture nothing from the environment to begin with.</p>
<p>The way a closure captures and handles values from the environment affects which traits the closure implements, and traits are how functions and structs can specify what kinds of closures they can use. Closures will automatically implement one, two, or all three of these <code>Fn</code> traits, in an additive fashion, depending on how the closure‚Äôs body handles the values:</p>
<ol>
<li><code>FnOnce</code> applies to closures that can be called once. All closures implement at least this trait, because all closures can be called. A closure that moves captured values out of its body will only implement <code>FnOnce</code> and none of the other <code>Fn</code> traits, because it can only be called once.</li>
<li><code>FnMut</code> applies to closures that don‚Äôt move captured values out of their body, but that might mutate the captured values. These closures can be called more than once.</li>
<li><code>Fn</code> applies to closures that don‚Äôt move captured values out of their body and that don‚Äôt mutate captured values, as well as closures that capture nothing from their environment. These closures can be called more than once without mutating their environment, which is important in cases such as calling a closure multiple times concurrently.</li>
</ol>
<p>Let‚Äôs look at the definition of the <code>unwrap_or_else</code> method on <code>Option&lt;T&gt;</code> that we used in Listing 13-1:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap_or_else&lt;F&gt;(self, f: F) -&gt; T
    where
        F: FnOnce() -&gt; T
    {
        match self {
            Some(x) =&gt; x,
            None =&gt; f(),
        }
    }
}</code></pre>
<p>Recall that <code>T</code> is the generic type representing the type of the value in the <code>Some</code> variant of an <code>Option</code>. That type <code>T</code> is also the return type of the <code>unwrap_or_else</code> function: code that calls <code>unwrap_or_else</code> on an <code>Option&lt;String&gt;</code>, for example, will get a <code>String</code>.</p>
<p>Next, notice that the <code>unwrap_or_else</code> function has the additional generic type parameter <code>F</code>. The <code>F</code> type is the type of the parameter named <code>f</code>, which is the closure we provide when calling <code>unwrap_or_else</code>.</p>
<p>The trait bound specified on the generic type <code>F</code> is <code>FnOnce() -&gt; T</code>, which means <code>F</code> must be able to be called once, take no arguments, and return a <code>T</code>. Using <code>FnOnce</code> in the trait bound expresses the constraint that <code>unwrap_or_else</code> is only going to call <code>f</code> at most one time. In the body of <code>unwrap_or_else</code>, we can see that if the <code>Option</code> is <code>Some</code>, <code>f</code> won‚Äôt be called. If the <code>Option</code> is <code>None</code>, <code>f</code> will be called once. Because all closures implement <code>FnOnce</code>, <code>unwrap_or_else</code> accepts all three kinds of closures and is as flexible as it can be.</p>
<blockquote>
<p>Note: If what we want to do doesn‚Äôt require capturing a value from the environment, we can use the name of a function rather than a closure. For example, we could call <code>unwrap_or_else(Vec::new)</code> on a <code>Option&lt;Vec&lt;T&gt;&gt;</code> value to get a new, empty vector if the value is <code>None</code>. The compiler automatically implements whichever of the <code>Fn</code> traits is applicable for a function definition.</p>
</blockquote>
<p>Now let‚Äôs look at the standard library method <code>sort_by_key</code> defined on slices, to see how that differs from <code>unwrap_or_else</code> and why <code>sort_by_key</code> uses <code>FnMut</code> instead of <code>FnOnce</code> for the trait bound. The closure gets one argument in the form of a reference to the current item in the slice being considered, and returns a value of type <code>K</code> that can be ordered. This function is useful when you want to sort a slice by a particular attribute of each item. In Listing 13-7, we have a list of <code>Rectangle</code> instances and we use <code>sort_by_key</code> to order them by their <code>width</code> attribute from low to high:</p>
<Listing number="13-7" file-name="src/main.rs" caption="Using `sort_by_key` to order rectangles by width">
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    list.sort_by_key(|r| r.width);
    println!("{list:#?}");
}</code></pre></pre>
</Listing>
<p>This code prints:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.41s
     Running `target/debug/rectangles`
[
    Rectangle {
        width: 3,
        height: 5,
    },
    Rectangle {
        width: 7,
        height: 12,
    },
    Rectangle {
        width: 10,
        height: 1,
    },
]
</code></pre>
<p>The reason <code>sort_by_key</code> is defined to take an <code>FnMut</code> closure is that it calls the closure multiple times: once for each item in the slice. The closure <code>|r| r.width</code> doesn‚Äôt capture, mutate, or move out anything from its environment, so it meets the trait bound requirements.</p>
<p>In contrast, Listing 13-8 shows an example of a closure that implements just the <code>FnOnce</code> trait, because it moves a value out of the environment. The compiler won‚Äôt let us use this closure with <code>sort_by_key</code>:</p>
<Listing number="13-8" file-name="src/main.rs" caption="Attempting to use an `FnOnce` closure with `sort_by_key`">
<pre><code class="language-rust ignore does_not_compile">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut sort_operations = vec![];
    let value = String::from("closure called");

    list.sort_by_key(|r| {
        sort_operations.push(value);
        r.width
    });
    println!("{list:#?}");
}</code></pre>
</Listing>
<p>This is a contrived, convoluted way (that doesn‚Äôt work) to try and count the number of times <code>sort_by_key</code> calls the closure when sorting <code>list</code>. This code attempts to do this counting by pushing <code>value</code>‚Äîa <code>String</code> from the closure‚Äôs environment‚Äîinto the <code>sort_operations</code> vector. The closure captures <code>value</code> then moves <code>value</code> out of the closure by transferring ownership of <code>value</code> to the <code>sort_operations</code> vector. This closure can be called once; trying to call it a second time wouldn‚Äôt work because <code>value</code> would no longer be in the environment to be pushed into <code>sort_operations</code> again! Therefore, this closure only implements <code>FnOnce</code>. When we try to compile this code, we get this error that <code>value</code> can‚Äôt be moved out of the closure because the closure must implement <code>FnMut</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
error[E0507]: cannot move out of `value`, a captured variable in an `FnMut` closure
  --&gt; src/main.rs:18:30
   |
15 |     let value = String::from("closure called");
   |         ----- captured outer variable
16 |
17 |     list.sort_by_key(|r| {
   |                      --- captured by this `FnMut` closure
18 |         sort_operations.push(value);
   |                              ^^^^^ move occurs because `value` has type `String`, which does not implement the `Copy` trait
   |
help: consider cloning the value if the performance cost is acceptable
   |
18 |         sort_operations.push(value.clone());
   |                                   ++++++++

For more information about this error, try `rustc --explain E0507`.
error: could not compile `rectangles` (bin "rectangles") due to 1 previous error
</code></pre>
<p>The error points to the line in the closure body that moves <code>value</code> out of the environment. To fix this, we need to change the closure body so that it doesn‚Äôt move values out of the environment. To count the number of times the closure is called, keeping a counter in the environment and incrementing its value in the closure body is a more straightforward way to calculate that. The closure in Listing 13-9 works with <code>sort_by_key</code> because it is only capturing a mutable reference to the <code>num_sort_operations</code> counter and can therefore be called more than once:</p>
<Listing number="13-9" file-name="src/main.rs" caption="Using an `FnMut` closure with `sort_by_key` is allowed">
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut num_sort_operations = 0;
    list.sort_by_key(|r| {
        num_sort_operations += 1;
        r.width
    });
    println!("{list:#?}, sorted in {num_sort_operations} operations");
}</code></pre></pre>
</Listing>
<p>The <code>Fn</code> traits are important when defining or using functions or types that make use of closures. In the next section, we‚Äôll discuss iterators. Many iterator methods take closure arguments, so keep these closure details in mind as we continue!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–û–±—Ä–∞–±–æ—Ç–∫–∞-–ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–µ–π-—ç–ª–µ–º–µ–Ω—Ç–æ–≤-—Å-–ø–æ–º–æ—â—å—é-–∏—Ç–µ—Ä–∞—Ç–æ—Ä–æ–≤"><a class="header" href="#–û–±—Ä–∞–±–æ—Ç–∫–∞-–ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–µ–π-—ç–ª–µ–º–µ–Ω—Ç–æ–≤-—Å-–ø–æ–º–æ—â—å—é-–∏—Ç–µ—Ä–∞—Ç–æ—Ä–æ–≤">–û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–µ–π —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —Å –ø–æ–º–æ—â—å—é –∏—Ç–µ—Ä–∞—Ç–æ—Ä–æ–≤</a></h2>
<p>The iterator pattern allows you to perform some task on a sequence of items in turn. An iterator is responsible for the logic of iterating over each item and determining when the sequence has finished. When you use iterators, you don‚Äôt have to reimplement that logic yourself.</p>
<p>In Rust, iterators are <em>lazy</em>, meaning they have no effect until you call methods that consume the iterator to use it up. For example, the code in Listing 13-10 creates an iterator over the items in the vector <code>v1</code> by calling the <code>iter</code> method defined on <code>Vec&lt;T&gt;</code>. This code by itself doesn‚Äôt do anything useful.</p>
<Listing number="13-10" file-name="src/main.rs" caption="Creating an iterator">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>The iterator is stored in the <code>v1_iter</code> variable. Once we‚Äôve created an iterator, we can use it in a variety of ways. In Listing 3-5 in Chapter 3, we iterated over an array using a <code>for</code> loop to execute some code on each of its items. Under the hood this implicitly created and then consumed an iterator, but we glossed over how exactly that works until now.</p>
<p>In the example in Listing 13-11, we separate the creation of the iterator from the use of the iterator in the <code>for</code> loop. When the <code>for</code> loop is called using the iterator in <code>v1_iter</code>, each element in the iterator is used in one iteration of the loop, which prints out each value.</p>
<Listing number="13-11" file-name="src/main.rs" caption="Using an iterator in a `for` loop">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    for val in v1_iter {
        println!("Got: {val}");
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>In languages that don‚Äôt have iterators provided by their standard libraries, you would likely write this same functionality by starting a variable at index 0, using that variable to index into the vector to get a value, and incrementing the variable value in a loop until it reached the total number of items in the vector.</p>
<p>Iterators handle all that logic for you, cutting down on repetitive code you could potentially mess up. Iterators give you more flexibility to use the same logic with many different kinds of sequences, not just data structures you can index into, like vectors. Let‚Äôs examine how iterators do that.</p>
<h3 id="the-iterator-trait-and-the-next-method"><a class="header" href="#the-iterator-trait-and-the-next-method">The <code>Iterator</code> Trait and the <code>next</code> Method</a></h3>
<p>All iterators implement a trait named <code>Iterator</code> that is defined in the standard library. The definition of the trait looks like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // methods with default implementations elided
}
<span class="boring">}</span></code></pre></pre>
<p>Notice this definition uses some new syntax: <code>type Item</code> and <code>Self::Item</code>, which are defining an <em>associated type</em> with this trait. We‚Äôll talk about associated types in depth in Chapter 20. For now, all you need to know is that this code says implementing the <code>Iterator</code> trait requires that you also define an <code>Item</code> type, and this <code>Item</code> type is used in the return type of the <code>next</code> method. In other words, the <code>Item</code> type will be the type returned from the iterator.</p>
<p>The <code>Iterator</code> trait only requires implementors to define one method: the <code>next</code> method, which returns one item of the iterator at a time wrapped in <code>Some</code> and, when iteration is over, returns <code>None</code>.</p>
<p>We can call the <code>next</code> method on iterators directly; Listing 13-12 demonstrates what values are returned from repeated calls to <code>next</code> on the iterator created from the vector.</p>
<Listing number="13-12" file-name="src/lib.rs" caption="Calling the `next` method on an iterator">
<pre><code class="language-rust noplayground"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn iterator_demonstration() {
        let v1 = vec![1, 2, 3];

        let mut v1_iter = v1.iter();

        assert_eq!(v1_iter.next(), Some(&amp;1));
        assert_eq!(v1_iter.next(), Some(&amp;2));
        assert_eq!(v1_iter.next(), Some(&amp;3));
        assert_eq!(v1_iter.next(), None);
    }
<span class="boring">}</span></code></pre>
</Listing>
<p>Note that we needed to make <code>v1_iter</code> mutable: calling the <code>next</code> method on an iterator changes internal state that the iterator uses to keep track of where it is in the sequence. In other words, this code <em>consumes</em>, or uses up, the iterator. Each call to <code>next</code> eats up an item from the iterator. We didn‚Äôt need to make <code>v1_iter</code> mutable when we used a <code>for</code> loop because the loop took ownership of <code>v1_iter</code> and made it mutable behind the scenes.</p>
<p>Also note that the values we get from the calls to <code>next</code> are immutable references to the values in the vector. The <code>iter</code> method produces an iterator over immutable references. If we want to create an iterator that takes ownership of <code>v1</code> and returns owned values, we can call <code>into_iter</code> instead of <code>iter</code>. Similarly, if we want to iterate over mutable references, we can call <code>iter_mut</code> instead of <code>iter</code>.</p>
<h3 id="methods-that-consume-the-iterator"><a class="header" href="#methods-that-consume-the-iterator">Methods that Consume the Iterator</a></h3>
<p>The <code>Iterator</code> trait has a number of different methods with default implementations provided by the standard library; you can find out about these methods by looking in the standard library API documentation for the <code>Iterator</code> trait. Some of these methods call the <code>next</code> method in their definition, which is why you‚Äôre required to implement the <code>next</code> method when implementing the <code>Iterator</code> trait.</p>
<p>Methods that call <code>next</code> are called <em>consuming adapters</em>, because calling them uses up the iterator. One example is the <code>sum</code> method, which takes ownership of the iterator and iterates through the items by repeatedly calling <code>next</code>, thus consuming the iterator. As it iterates through, it adds each item to a running total and returns the total when iteration is complete. Listing 13-13 has a test illustrating a use of the <code>sum</code> method:</p>
<Listing number="13-13" file-name="src/lib.rs" caption="Calling the `sum` method to get the total of all items in the iterator">
<pre><code class="language-rust noplayground"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn iterator_sum() {
        let v1 = vec![1, 2, 3];

        let v1_iter = v1.iter();

        let total: i32 = v1_iter.sum();

        assert_eq!(total, 6);
    }
<span class="boring">}</span></code></pre>
</Listing>
<p>We aren‚Äôt allowed to use <code>v1_iter</code> after the call to <code>sum</code> because <code>sum</code> takes ownership of the iterator we call it on.</p>
<h3 id="methods-that-produce-other-iterators"><a class="header" href="#methods-that-produce-other-iterators">Methods that Produce Other Iterators</a></h3>
<p><em>Iterator adapters</em> are methods defined on the <code>Iterator</code> trait that don‚Äôt consume the iterator. Instead, they produce different iterators by changing some aspect of the original iterator.</p>
<p>Listing 13-14 shows an example of calling the iterator adapter method <code>map</code>, which takes a closure to call on each item as the items are iterated through. The <code>map</code> method returns a new iterator that produces the modified items. The closure here creates a new iterator in which each item from the vector will be incremented by 1:</p>
<Listing number="13-14" file-name="src/main.rs" caption="Calling the iterator adapter `map` to create a new iterator">
<pre><pre class="playground"><code class="language-rust not_desired_behavior edition2021"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    v1.iter().map(|x| x + 1);
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>However, this code produces a warning:</p>
<pre><code class="language-console">$ cargo run
   Compiling iterators v0.1.0 (file:///projects/iterators)
warning: unused `Map` that must be used
 --&gt; src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: iterators are lazy and do nothing unless consumed
  = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
  |
4 |     let _ = v1.iter().map(|x| x + 1);
  |     +++++++

warning: `iterators` (bin "iterators") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.47s
     Running `target/debug/iterators`
</code></pre>
<p>The code in Listing 13-14 doesn‚Äôt do anything; the closure we‚Äôve specified never gets called. The warning reminds us why: iterator adapters are lazy, and we need to consume the iterator here.</p>
<p>To fix this warning and consume the iterator, we‚Äôll use the <code>collect</code> method, which we used in Chapter 12 with <code>env::args</code> in Listing 12-1. This method consumes the iterator and collects the resulting values into a collection data type.</p>
<p>In Listing 13-15, we collect the results of iterating over the iterator that‚Äôs returned from the call to <code>map</code> into a vector. This vector will end up containing each item from the original vector incremented by 1.</p>
<Listing number="13-15" file-name="src/main.rs" caption="Calling the `map` method to create a new iterator and then calling the `collect` method to consume the new iterator and create a vector">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>Because <code>map</code> takes a closure, we can specify any operation we want to perform on each item. This is a great example of how closures let you customize some behavior while reusing the iteration behavior that the <code>Iterator</code> trait provides.</p>
<p>You can chain multiple calls to iterator adapters to perform complex actions in a readable way. But because all iterators are lazy, you have to call one of the consuming adapter methods to get results from calls to iterator adapters.</p>
<h3 id="using-closures-that-capture-their-environment"><a class="header" href="#using-closures-that-capture-their-environment">Using Closures that Capture Their Environment</a></h3>
<p>Many iterator adapters take closures as arguments, and commonly the closures we‚Äôll specify as arguments to iterator adapters will be closures that capture their environment.</p>
<p>For this example, we‚Äôll use the <code>filter</code> method that takes a closure. The closure gets an item from the iterator and returns a <code>bool</code>. If the closure returns <code>true</code>, the value will be included in the iteration produced by <code>filter</code>. If the closure returns <code>false</code>, the value won‚Äôt be included.</p>
<p>In Listing 13-16, we use <code>filter</code> with a closure that captures the <code>shoe_size</code> variable from its environment to iterate over a collection of <code>Shoe</code> struct instances. It will return only shoes that are the specified size.</p>
<Listing number="13-16" file-name="src/lib.rs" caption="Using the `filter` method with a closure that captures `shoe_size`">
<pre><code class="language-rust noplayground">#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn filters_by_size() {
        let shoes = vec![
            Shoe {
                size: 10,
                style: String::from("sneaker"),
            },
            Shoe {
                size: 13,
                style: String::from("sandal"),
            },
            Shoe {
                size: 10,
                style: String::from("boot"),
            },
        ];

        let in_my_size = shoes_in_size(shoes, 10);

        assert_eq!(
            in_my_size,
            vec![
                Shoe {
                    size: 10,
                    style: String::from("sneaker")
                },
                Shoe {
                    size: 10,
                    style: String::from("boot")
                },
            ]
        );
    }
}</code></pre>
</Listing>
<p>The <code>shoes_in_size</code> function takes ownership of a vector of shoes and a shoe size as parameters. It returns a vector containing only shoes of the specified size.</p>
<p>In the body of <code>shoes_in_size</code>, we call <code>into_iter</code> to create an iterator that takes ownership of the vector. Then we call <code>filter</code> to adapt that iterator into a new iterator that only contains elements for which the closure returns <code>true</code>.</p>
<p>The closure captures the <code>shoe_size</code> parameter from the environment and compares the value with each shoe‚Äôs size, keeping only shoes of the size specified. Finally, calling <code>collect</code> gathers the values returned by the adapted iterator into a vector that‚Äôs returned by the function.</p>
<p>The test shows that when we call <code>shoes_in_size</code>, we get back only shoes that have the same size as the value we specified.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–£–ª—É—á—à–∞–µ–º-–Ω–∞—à-–ø—Ä–æ–µ–∫—Ç-—Å-–≤–≤–æ–¥–æ–º-–≤—ã–≤–æ–¥–æ–º"><a class="header" href="#–£–ª—É—á—à–∞–µ–º-–Ω–∞—à-–ø—Ä–æ–µ–∫—Ç-—Å-–≤–≤–æ–¥–æ–º-–≤—ã–≤–æ–¥–æ–º">–£–ª—É—á—à–∞–µ–º –Ω–∞—à –ø—Ä–æ–µ–∫—Ç —Å –≤–≤–æ–¥–æ–º-–≤—ã–≤–æ–¥–æ–º</a></h2>
<p>With this new knowledge about iterators, we can improve the I/O project in Chapter 12 by using iterators to make places in the code clearer and more concise. Let‚Äôs look at how iterators can improve our implementation of the <code>Config::build</code> function and the <code>search</code> function.</p>
<h3 id="removing-a-clone-using-an-iterator"><a class="header" href="#removing-a-clone-using-an-iterator">Removing a <code>clone</code> Using an Iterator</a></h3>
<p>In Listing 12-6, we added code that took a slice of <code>String</code> values and created an instance of the <code>Config</code> struct by indexing into the slice and cloning the values, allowing the <code>Config</code> struct to own those values. In Listing 13-17, we‚Äôve reproduced the implementation of the <code>Config::build</code> function as it was in Listing 12-23:</p>
<Listing number="13-17" file-name="src/lib.rs" caption="Reproduction of the `Config::build` function from Listing 12-23">
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        let ignore_case = env::var("IGNORE_CASE").is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>At the time, we said not to worry about the inefficient <code>clone</code> calls because we would remove them in the future. Well, that time is now!</p>
<p>We needed <code>clone</code> here because we have a slice with <code>String</code> elements in the parameter <code>args</code>, but the <code>build</code> function doesn‚Äôt own <code>args</code>. To return ownership of a <code>Config</code> instance, we had to clone the values from the <code>query</code> and <code>file_path</code> fields of <code>Config</code> so the <code>Config</code> instance can own its values.</p>
<p>With our new knowledge about iterators, we can change the <code>build</code> function to take ownership of an iterator as its argument instead of borrowing a slice. We‚Äôll use the iterator functionality instead of the code that checks the length of the slice and indexes into specific locations. This will clarify what the <code>Config::build</code> function is doing because the iterator will access the values.</p>
<p>Once <code>Config::build</code> takes ownership of the iterator and stops using indexing operations that borrow, we can move the <code>String</code> values from the iterator into <code>Config</code> rather than calling <code>clone</code> and making a new allocation.</p>
<h4 id="using-the-returned-iterator-directly"><a class="header" href="#using-the-returned-iterator-directly">Using the Returned Iterator Directly</a></h4>
<p>Open your I/O project‚Äôs <em>src/main.rs</em> file, which should look like this:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">
</span><span class="boring">    if let Err(e) = minigrep::run(config) {
</span><span class="boring">        eprintln!("Application error: {e}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}</code></pre>
<p>We‚Äôll first change the start of the <code>main</code> function that we had in Listing 12-24 to the code in Listing 13-18, which this time uses an iterator. This won‚Äôt compile until we update <code>Config::build</code> as well.</p>
<Listing number="13-18" file-name="src/main.rs" caption="Passing the return value of `env::args` to `Config::build`">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let config = Config::build(env::args()).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">
</span><span class="boring">    if let Err(e) = minigrep::run(config) {
</span><span class="boring">        eprintln!("Application error: {e}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}</code></pre>
</Listing>
<p>The <code>env::args</code> function returns an iterator! Rather than collecting the iterator values into a vector and then passing a slice to <code>Config::build</code>, now we‚Äôre passing ownership of the iterator returned from <code>env::args</code> to <code>Config::build</code> directly.</p>
<p>Next, we need to update the definition of <code>Config::build</code>. In your I/O project‚Äôs <em>src/lib.rs</em> file, let‚Äôs change the signature of <code>Config::build</code> to look like Listing 13-19. This still won‚Äôt compile because we need to update the function body.</p>
<Listing number="13-19" file-name="src/lib.rs" caption="Updating the signature of `Config::build` to expect an iterator">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(
        mut args: impl Iterator&lt;Item = String&gt;,
    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        let ignore_case = env::var("IGNORE_CASE").is_ok();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            query,
</span><span class="boring">            file_path,
</span><span class="boring">            ignore_case,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>The standard library documentation for the <code>env::args</code> function shows that the type of the iterator it returns is <code>std::env::Args</code>, and that type implements the <code>Iterator</code> trait and returns <code>String</code> values.</p>
<p>We‚Äôve updated the signature of the <code>Config::build</code> function so the parameter <code>args</code> has a generic type with the trait bounds <code>impl Iterator&lt;Item = String&gt;</code> instead of <code>&amp;[String]</code>. This usage of the <code>impl Trait</code> syntax we discussed in the <a href="ch10-02-traits.html#traits-as-parameters">‚ÄúTraits as Parameters‚Äù</a><!-- ignore --> section of Chapter 10 means that <code>args</code> can be any type that implements the <code>Iterator</code> trait and returns <code>String</code> items.</p>
<p>Because we‚Äôre taking ownership of <code>args</code> and we‚Äôll be mutating <code>args</code> by iterating over it, we can add the <code>mut</code> keyword into the specification of the <code>args</code> parameter to make it mutable.</p>
<h4 id="using-iterator-trait-methods-instead-of-indexing"><a class="header" href="#using-iterator-trait-methods-instead-of-indexing">Using <code>Iterator</code> Trait Methods Instead of Indexing</a></h4>
<p>Next, we‚Äôll fix the body of <code>Config::build</code>. Because <code>args</code> implements the <code>Iterator</code> trait, we know we can call the <code>next</code> method on it! Listing 13-20 updates the code from Listing 12-23 to use the <code>next</code> method:</p>
<Listing number="13-20" file-name="src/lib.rs" caption="Changing the body of `Config::build` to use iterator methods">
<pre><code class="language-rust noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(
        mut args: impl Iterator&lt;Item = String&gt;,
    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
        args.next();

        let query = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err("Didn't get a query string"),
        };

        let file_path = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err("Didn't get a file path"),
        };

        let ignore_case = env::var("IGNORE_CASE").is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>Remember that the first value in the return value of <code>env::args</code> is the name of the program. We want to ignore that and get to the next value, so first we call <code>next</code> and do nothing with the return value. Second, we call <code>next</code> to get the value we want to put in the <code>query</code> field of <code>Config</code>. If <code>next</code> returns a <code>Some</code>, we use a <code>match</code> to extract the value. If it returns <code>None</code>, it means not enough arguments were given and we return early with an <code>Err</code> value. We do the same thing for the <code>file_path</code> value.</p>
<h3 id="making-code-clearer-with-iterator-adapters"><a class="header" href="#making-code-clearer-with-iterator-adapters">Making Code Clearer with Iterator Adapters</a></h3>
<p>We can also take advantage of iterators in the <code>search</code> function in our I/O project, which is reproduced here in Listing 13-21 as it was in Listing 12-19:</p>
<Listing number="13-21" file-name="src/lib.rs" caption="The implementation of the `search` function from Listing 12-19">
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("not enough arguments");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>We can write this code in a more concise way using iterator adapter methods. Doing so also lets us avoid having a mutable intermediate <code>results</code> vector. The functional programming style prefers to minimize the amount of mutable state to make code clearer. Removing the mutable state might enable a future enhancement to make searching happen in parallel, because we wouldn‚Äôt have to manage concurrent access to the <code>results</code> vector. Listing 13-22 shows this change:</p>
<Listing number="13-22" file-name="src/lib.rs" caption="Using iterator adapter methods in the implementation of the `search` function">
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(
</span><span class="boring">        mut args: impl Iterator&lt;Item = String&gt;,
</span><span class="boring">    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        args.next();
</span><span class="boring">
</span><span class="boring">        let query = match args.next() {
</span><span class="boring">            Some(arg) =&gt; arg,
</span><span class="boring">            None =&gt; return Err("Didn't get a query string"),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let file_path = match args.next() {
</span><span class="boring">            Some(arg) =&gt; arg,
</span><span class="boring">            None =&gt; return Err("Didn't get a file path"),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let ignore_case = env::var("IGNORE_CASE").is_ok();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            query,
</span><span class="boring">            file_path,
</span><span class="boring">            ignore_case,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    contents
        .lines()
        .filter(|line| line.contains(query))
        .collect()
}
<span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>Recall that the purpose of the <code>search</code> function is to return all lines in <code>contents</code> that contain the <code>query</code>. Similar to the <code>filter</code> example in Listing 13-16, this code uses the <code>filter</code> adapter to keep only the lines that <code>line.contains(query)</code> returns <code>true</code> for. We then collect the matching lines into another vector with <code>collect</code>. Much simpler! Feel free to make the same change to use iterator methods in the <code>search_case_insensitive</code> function as well.</p>
<h3 id="choosing-between-loops-or-iterators"><a class="header" href="#choosing-between-loops-or-iterators">Choosing Between Loops or Iterators</a></h3>
<p>The next logical question is which style you should choose in your own code and why: the original implementation in Listing 13-21 or the version using iterators in Listing 13-22. Most Rust programmers prefer to use the iterator style. It‚Äôs a bit tougher to get the hang of at first, but once you get a feel for the various iterator adapters and what they do, iterators can be easier to understand. Instead of fiddling with the various bits of looping and building new vectors, the code focuses on the high-level objective of the loop. This abstracts away some of the commonplace code so it‚Äôs easier to see the concepts that are unique to this code, such as the filtering condition each element in the iterator must pass.</p>
<p>But are the two implementations truly equivalent? The intuitive assumption might be that the more low-level loop will be faster. Let‚Äôs talk about performance.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–°—Ä–∞–≤–Ω–µ–Ω–∏–µ-–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏-—Ü–∏–∫–ª–æ–≤-–∏-–∏—Ç–µ—Ä–∞—Ç–æ—Ä–æ–≤"><a class="header" href="#–°—Ä–∞–≤–Ω–µ–Ω–∏–µ-–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏-—Ü–∏–∫–ª–æ–≤-–∏-–∏—Ç–µ—Ä–∞—Ç–æ—Ä–æ–≤">–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ —Ü–∏–∫–ª–æ–≤ –∏ –∏—Ç–µ—Ä–∞—Ç–æ—Ä–æ–≤</a></h2>
<p>To determine whether to use loops or iterators, you need to know which implementation is faster: the version of the <code>search</code> function with an explicit <code>for</code> loop or the version with iterators.</p>
<p>We ran a benchmark by loading the entire contents of <em>The Adventures of Sherlock Holmes</em> by Sir Arthur Conan Doyle into a <code>String</code> and looking for the word <em>the</em> in the contents. Here are the results of the benchmark on the version of <code>search</code> using the <code>for</code> loop and the version using iterators:</p>
<pre><code class="language-text">test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
</code></pre>
<p>The two implementations have similar performance! We won‚Äôt explain the benchmark code here, because the point is not to prove that the two versions are equivalent but to get a general sense of how these two implementations compare performance-wise.</p>
<p>For a more comprehensive benchmark, you should check using various texts of various sizes as the <code>contents</code>, different words and words of different lengths as the <code>query</code>, and all kinds of other variations. The point is this: iterators, although a high-level abstraction, get compiled down to roughly the same code as if you‚Äôd written the lower-level code yourself. Iterators are one of Rust‚Äôs <em>zero-cost abstractions</em>, by which we mean using the abstraction imposes no additional runtime overhead. This is analogous to how Bjarne Stroustrup, the original designer and implementor of C++, defines <em>zero-overhead</em> in ‚ÄúFoundations of C++‚Äù (2012):</p>
<blockquote>
<p>In general, C++ implementations obey the zero-overhead principle: What you don‚Äôt use, you don‚Äôt pay for. And further: What you do use, you couldn‚Äôt hand code any better.</p>
</blockquote>
<p>As another example, the following code is taken from an audio decoder. The decoding algorithm uses the linear prediction mathematical operation to estimate future values based on a linear function of the previous samples. This code uses an iterator chain to do some math on three variables in scope: a <code>buffer</code> slice of data, an array of 12 <code>coefficients</code>, and an amount by which to shift data in <code>qlp_shift</code>. We‚Äôve declared the variables within this example but not given them any values; although this code doesn‚Äôt have much meaning outside of its context, it‚Äôs still a concise, real-world example of how Rust translates high-level ideas to low-level code.</p>
<pre><code class="language-rust ignore">let buffer: &amp;mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
                                 .zip(&amp;buffer[i - 12..i])
                                 .map(|(&amp;c, &amp;s)| c * s as i64)
                                 .sum::&lt;i64&gt;() &gt;&gt; qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}</code></pre>
<p>To calculate the value of <code>prediction</code>, this code iterates through each of the 12 values in <code>coefficients</code> and uses the <code>zip</code> method to pair the coefficient values with the previous 12 values in <code>buffer</code>. Then, for each pair, we multiply the values together, sum all the results, and shift the bits in the sum <code>qlp_shift</code> bits to the right.</p>
<p>Calculations in applications like audio decoders often prioritize performance most highly. Here, we‚Äôre creating an iterator, using two adapters, and then consuming the value. What assembly code would this Rust code compile to? Well, as of this writing, it compiles down to the same assembly you‚Äôd write by hand. There‚Äôs no loop at all corresponding to the iteration over the values in <code>coefficients</code>: Rust knows that there are 12 iterations, so it ‚Äúunrolls‚Äù the loop. <em>Unrolling</em> is an optimization that removes the overhead of the loop controlling code and instead generates repetitive code for each iteration of the loop.</p>
<p>All of the coefficients get stored in registers, which means accessing the values is very fast. There are no bounds checks on the array access at runtime. All these optimizations that Rust is able to apply make the resulting code extremely efficient. Now that you know this, you can use iterators and closures without fear! They make code seem like it‚Äôs higher level but don‚Äôt impose a runtime performance penalty for doing so.</p>
<h2 id="–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-12"><a class="header" href="#–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-12">–ü–æ–¥–≤–µ–¥—ë–º –∏—Ç–æ–≥–∏</a></h2>
<p>Closures and iterators are Rust features inspired by functional programming language ideas. They contribute to Rust‚Äôs capability to clearly express high-level ideas at low-level performance. The implementations of closures and iterators are such that runtime performance is not affected. This is part of Rust‚Äôs goal to strive to provide zero-cost abstractions.</p>
<p>Now that we‚Äôve improved the expressiveness of our I/O project, let‚Äôs look at some more features of <code>cargo</code> that will help us share the project with the world.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="more-about-cargo-and-cratesio"><a class="header" href="#more-about-cargo-and-cratesio">More About Cargo and Crates.io</a></h1>
<p>So far we‚Äôve used only the most basic features of Cargo to build, run, and test our code, but it can do a lot more. In this chapter, we‚Äôll discuss some of its other, more advanced features to show you how to do the following:</p>
<ul>
<li>Customize your build through release profiles</li>
<li>Publish libraries on <a href="https://crates.io/">crates.io</a><!-- ignore --></li>
<li>Organize large projects with workspaces</li>
<li>Install binaries from <a href="https://crates.io/">crates.io</a><!-- ignore --></li>
<li>Extend Cargo using custom commands</li>
</ul>
<p>Cargo can do even more than the functionality we cover in this chapter, so for a full explanation of all its features, see <a href="https://doc.rust-lang.org/cargo/">its documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–ù–∞—Å—Ç—Ä–æ–π–∫–∞-—Å–±–æ—Ä–æ–∫-—Å-–ø–æ–º–æ—â—å—é-—Ä–µ–ª–∏–∑–Ω—ã—Ö-–ø—Ä–æ—Ñ–∏–ª–µ–π"><a class="header" href="#–ù–∞—Å—Ç—Ä–æ–π–∫–∞-—Å–±–æ—Ä–æ–∫-—Å-–ø–æ–º–æ—â—å—é-—Ä–µ–ª–∏–∑–Ω—ã—Ö-–ø—Ä–æ—Ñ–∏–ª–µ–π">–ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Å–±–æ—Ä–æ–∫ —Å –ø–æ–º–æ—â—å—é —Ä–µ–ª–∏–∑–Ω—ã—Ö –ø—Ä–æ—Ñ–∏–ª–µ–π</a></h2>
<p>In Rust, <em>release profiles</em> are predefined and customizable profiles with different configurations that allow a programmer to have more control over various options for compiling code. Each profile is configured independently of the others.</p>
<p>Cargo has two main profiles: the <code>dev</code> profile Cargo uses when you run <code>cargo build</code> and the <code>release</code> profile Cargo uses when you run <code>cargo build --release</code>. The <code>dev</code> profile is defined with good defaults for development, and the <code>release</code> profile has good defaults for release builds.</p>
<p>These profile names might be familiar from the output of your builds:</p>
<!-- manual-regeneration
anywhere, run:
cargo build
cargo build --release
and ensure output below is accurate
-->
<pre><code class="language-console">$ cargo build
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.00s
$ cargo build --release
    Finished `release` profile [optimized] target(s) in 0.32s
</code></pre>
<p>The <code>dev</code> and <code>release</code> are these different profiles used by the compiler.</p>
<p>Cargo has default settings for each of the profiles that apply when you haven't explicitly added any <code>[profile.*]</code> sections in the project‚Äôs <em>Cargo.toml</em> file. By adding <code>[profile.*]</code> sections for any profile you want to customize, you override any subset of the default settings. For example, here are the default values for the <code>opt-level</code> setting for the <code>dev</code> and <code>release</code> profiles:</p>
<p><span class="filename">–§–∞–π–ª: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
</code></pre>
<p>The <code>opt-level</code> setting controls the number of optimizations Rust will apply to your code, with a range of 0 to 3. Applying more optimizations extends compiling time, so if you‚Äôre in development and compiling your code often, you‚Äôll want fewer optimizations to compile faster even if the resulting code runs slower. The default <code>opt-level</code> for <code>dev</code> is therefore <code>0</code>. When you‚Äôre ready to release your code, it‚Äôs best to spend more time compiling. You‚Äôll only compile in release mode once, but you‚Äôll run the compiled program many times, so release mode trades longer compile time for code that runs faster. That is why the default <code>opt-level</code> for the <code>release</code> profile is <code>3</code>.</p>
<p>You can override a default setting by adding a different value for it in <em>Cargo.toml</em>. For example, if we want to use optimization level 1 in the development profile, we can add these two lines to our project‚Äôs <em>Cargo.toml</em> file:</p>
<p><span class="filename">–§–∞–π–ª: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 1
</code></pre>
<p>This code overrides the default setting of <code>0</code>. Now when we run <code>cargo build</code>, Cargo will use the defaults for the <code>dev</code> profile plus our customization to <code>opt-level</code>. Because we set <code>opt-level</code> to <code>1</code>, Cargo will apply more optimizations than the default, but not as many as in a release build.</p>
<p>For the full list of configuration options and defaults for each profile, see <a href="https://doc.rust-lang.org/cargo/reference/profiles.html">Cargo‚Äôs documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–ü—É–±–ª–∏–∫–∞—Ü–∏—è-–∫—Ä–µ–π—Ç–∞-–Ω–∞-cratesio"><a class="header" href="#–ü—É–±–ª–∏–∫–∞—Ü–∏—è-–∫—Ä–µ–π—Ç–∞-–Ω–∞-cratesio">–ü—É–±–ª–∏–∫–∞—Ü–∏—è –∫—Ä–µ–π—Ç–∞ –Ω–∞ Crates.io</a></h2>
<p>We‚Äôve used packages from <a href="https://crates.io/">crates.io</a><!-- ignore --> as dependencies of our project, but you can also share your code with other people by publishing your own packages. The crate registry at <a href="https://crates.io/">crates.io</a><!-- ignore --> distributes the source code of your packages, so it primarily hosts code that is open source.</p>
<p>Rust and Cargo have features that make your published package easier for people to find and use. We‚Äôll talk about some of these features next and then explain how to publish a package.</p>
<h3 id="making-useful-documentation-comments"><a class="header" href="#making-useful-documentation-comments">Making Useful Documentation Comments</a></h3>
<p>Accurately documenting your packages will help other users know how and when to use them, so it‚Äôs worth investing the time to write documentation. In Chapter 3, we discussed how to comment Rust code using two slashes, <code>//</code>. Rust also has a particular kind of comment for documentation, known conveniently as a <em>documentation comment</em>, that will generate HTML documentation. The HTML displays the contents of documentation comments for public API items intended for programmers interested in knowing how to <em>use</em> your crate as opposed to how your crate is <em>implemented</em>.</p>
<p>Documentation comments use three slashes, <code>///</code>, instead of two and support Markdown notation for formatting the text. Place documentation comments just before the item they‚Äôre documenting. Listing 14-1 shows documentation comments for an <code>add_one</code> function in a crate named <code>my_crate</code>.</p>
<Listing number="14-1" file-name="src/lib.rs" caption="A documentation comment for a function">
<pre><code class="language-rust ignore">/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}</code></pre>
</Listing>
<p>Here, we give a description of what the <code>add_one</code> function does, start a section with the heading <code>Examples</code>, and then provide code that demonstrates how to use the <code>add_one</code> function. We can generate the HTML documentation from this documentation comment by running <code>cargo doc</code>. This command runs the <code>rustdoc</code> tool distributed with Rust and puts the generated HTML documentation in the <em>target/doc</em> directory.</p>
<p>For convenience, running <code>cargo doc --open</code> will build the HTML for your current crate‚Äôs documentation (as well as the documentation for all of your crate‚Äôs dependencies) and open the result in a web browser. Navigate to the <code>add_one</code> function and you‚Äôll see how the text in the documentation comments is rendered, as shown in Figure 14-1:</p>
<img alt="Rendered HTML documentation for the `add_one` function of `my_crate`" src="img/trpl14-01.png" class="center" />
<p><span class="caption">Figure 14-1: HTML documentation for the <code>add_one</code> function</span></p>
<h4 id="commonly-used-sections"><a class="header" href="#commonly-used-sections">Commonly Used Sections</a></h4>
<p>We used the <code># Examples</code> Markdown heading in Listing 14-1 to create a section in the HTML with the title ‚ÄúExamples.‚Äù Here are some other sections that crate authors commonly use in their documentation:</p>
<ul>
<li><strong>Panics</strong>: The scenarios in which the function being documented could panic. Callers of the function who don‚Äôt want their programs to panic should make sure they don‚Äôt call the function in these situations.</li>
<li><strong>Errors</strong>: If the function returns a <code>Result</code>, describing the kinds of errors that might occur and what conditions might cause those errors to be returned can be helpful to callers so they can write code to handle the different kinds of errors in different ways.</li>
<li><strong>Safety</strong>: If the function is <code>unsafe</code> to call (we discuss unsafety in Chapter 20), there should be a section explaining why the function is unsafe and covering the invariants that the function expects callers to uphold.</li>
</ul>
<p>Most documentation comments don‚Äôt need all of these sections, but this is a good checklist to remind you of the aspects of your code users will be interested in knowing about.</p>
<h4 id="documentation-comments-as-tests"><a class="header" href="#documentation-comments-as-tests">Documentation Comments as Tests</a></h4>
<p>Adding example code blocks in your documentation comments can help demonstrate how to use your library, and doing so has an additional bonus: running <code>cargo test</code> will run the code examples in your documentation as tests! Nothing is better than documentation with examples. But nothing is worse than examples that don‚Äôt work because the code has changed since the documentation was written. If we run <code>cargo test</code> with the documentation for the <code>add_one</code> function from Listing 14-1, we will see a section in the test results like this:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-01/
cargo test
copy just the doc-tests section below
-->
<pre><code class="language-text">   Doc-tests my_crate

running 1 test
test src/lib.rs - add_one (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.27s
</code></pre>
<p>Now if we change either the function or the example so the <code>assert_eq!</code> in the example panics and run <code>cargo test</code> again, we‚Äôll see that the doc tests catch that the example and the code are out of sync with each other!</p>
<h4 id="commenting-contained-items"><a class="header" href="#commenting-contained-items">Commenting Contained Items</a></h4>
<p>The style of doc comment <code>//!</code> adds documentation to the item that contains the comments rather than to the items following the comments. We typically use these doc comments inside the crate root file (<em>src/lib.rs</em> by convention) or inside a module to document the crate or the module as a whole.</p>
<p>For example, to add documentation that describes the purpose of the <code>my_crate</code> crate that contains the <code>add_one</code> function, we add documentation comments that start with <code>//!</code> to the beginning of the <em>src/lib.rs</em> file, as shown in Listing 14-2:</p>
<Listing number="14-2" file-name="src/lib.rs" caption="Documentation for the `my_crate` crate as a whole">
<pre><code class="language-rust ignore">//! # My Crate
//!
//! `my_crate` is a collection of utilities to make performing certain
//! calculations more convenient.

/// Adds one to the number given.
// --snip--
<span class="boring">///
</span><span class="boring">/// # Examples
</span><span class="boring">///
</span><span class="boring">/// ```
</span><span class="boring">/// let arg = 5;
</span><span class="boring">/// let answer = my_crate::add_one(arg);
</span><span class="boring">///
</span><span class="boring">/// assert_eq!(6, answer);
</span><span class="boring">/// ```
</span><span class="boring">pub fn add_one(x: i32) -&gt; i32 {
</span><span class="boring">    x + 1
</span><span class="boring">}</span></code></pre>
</Listing>
<p>Notice there isn‚Äôt any code after the last line that begins with <code>//!</code>. Because we started the comments with <code>//!</code> instead of <code>///</code>, we‚Äôre documenting the item that contains this comment rather than an item that follows this comment. In this case, that item is the <em>src/lib.rs</em> file, which is the crate root. These comments describe the entire crate.</p>
<p>When we run <code>cargo doc --open</code>, these comments will display on the front page of the documentation for <code>my_crate</code> above the list of public items in the crate, as shown in Figure 14-2:</p>
<img alt="Rendered HTML documentation with a comment for the crate as a whole" src="img/trpl14-02.png" class="center" />
<p><span class="caption">Figure 14-2: Rendered documentation for <code>my_crate</code>, including the comment describing the crate as a whole</span></p>
<p>Documentation comments within items are useful for describing crates and modules especially. Use them to explain the overall purpose of the container to help your users understand the crate‚Äôs organization.</p>
<h3 id="–≠–∫—Å–ø–æ—Ä—Ç-—É–¥–æ–±–Ω–æ–≥–æ-–æ–±—â–µ–¥–æ—Å—Ç—É–ø–Ω–æ–≥–æ-api-—Å-pub-use"><a class="header" href="#–≠–∫—Å–ø–æ—Ä—Ç-—É–¥–æ–±–Ω–æ–≥–æ-–æ–±—â–µ–¥–æ—Å—Ç—É–ø–Ω–æ–≥–æ-api-—Å-pub-use">–≠–∫—Å–ø–æ—Ä—Ç —É–¥–æ–±–Ω–æ–≥–æ –æ–±—â–µ–¥–æ—Å—Ç—É–ø–Ω–æ–≥–æ API —Å <code>pub use</code></a></h3>
<p>The structure of your public API is a major consideration when publishing a crate. People who use your crate are less familiar with the structure than you are and might have difficulty finding the pieces they want to use if your crate has a large module hierarchy.</p>
<p>In Chapter 7, we covered how to make items public using the <code>pub</code> keyword, and bring items into a scope with the <code>use</code> keyword. However, the structure that makes sense to you while you‚Äôre developing a crate might not be very convenient for your users. You might want to organize your structs in a hierarchy containing multiple levels, but then people who want to use a type you‚Äôve defined deep in the hierarchy might have trouble finding out that type exists. They might also be annoyed at having to enter <code>use</code> <code>my_crate::some_module::another_module::UsefulType;</code> rather than <code>use</code> <code>my_crate::UsefulType;</code>.</p>
<p>The good news is that if the structure <em>isn‚Äôt</em> convenient for others to use from another library, you don‚Äôt have to rearrange your internal organization: instead, you can re-export items to make a public structure that‚Äôs different from your private structure by using <code>pub use</code>. Re-exporting takes a public item in one location and makes it public in another location, as if it were defined in the other location instead.</p>
<p>For example, say we made a library named <code>art</code> for modeling artistic concepts. Within this library are two modules: a <code>kinds</code> module containing two enums named <code>PrimaryColor</code> and <code>SecondaryColor</code> and a <code>utils</code> module containing a function named <code>mix</code>, as shown in Listing 14-3:</p>
<Listing number="14-3" file-name="src/lib.rs" caption="An `art` library with items organized into `kinds` and `utils` modules">
<pre><code class="language-rust noplayground test_harness">//! # Art
//!
//! A library for modeling artistic concepts.

pub mod kinds {
    /// The primary colors according to the RYB color model.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// The secondary colors according to the RYB color model.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use crate::kinds::*;

    /// Combines two primary colors in equal amounts to create
    /// a secondary color.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
        // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">        unimplemented!();
</span>    }
}</code></pre>
</Listing>
<p>Figure 14-3 shows what the front page of the documentation for this crate generated by <code>cargo doc</code> would look like:</p>
<img alt="Rendered documentation for the `art` crate that lists the `kinds` and `utils` modules" src="img/trpl14-03.png" class="center" />
<p><span class="caption">Figure 14-3: Front page of the documentation for <code>art</code> that lists the <code>kinds</code> and <code>utils</code> modules</span></p>
<p>Note that the <code>PrimaryColor</code> and <code>SecondaryColor</code> types aren‚Äôt listed on the front page, nor is the <code>mix</code> function. We have to click <code>kinds</code> and <code>utils</code> to see them.</p>
<p>Another crate that depends on this library would need <code>use</code> statements that bring the items from <code>art</code> into scope, specifying the module structure that‚Äôs currently defined. Listing 14-4 shows an example of a crate that uses the <code>PrimaryColor</code> and <code>mix</code> items from the <code>art</code> crate:</p>
<Listing number="14-4" file-name="src/main.rs" caption="A crate using the `art` crate‚Äôs items with its internal structure exported">
<pre><code class="language-rust ignore">use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}</code></pre>
</Listing>
<p>The author of the code in Listing 14-4, which uses the <code>art</code> crate, had to figure out that <code>PrimaryColor</code> is in the <code>kinds</code> module and <code>mix</code> is in the <code>utils</code> module. The module structure of the <code>art</code> crate is more relevant to developers working on the <code>art</code> crate than to those using it. The internal structure doesn‚Äôt contain any useful information for someone trying to understand how to use the <code>art</code> crate, but rather causes confusion because developers who use it have to figure out where to look, and must specify the module names in the <code>use</code> statements.</p>
<p>To remove the internal organization from the public API, we can modify the <code>art</code> crate code in Listing 14-3 to add <code>pub use</code> statements to re-export the items at the top level, as shown in Listing 14-5:</p>
<Listing number="14-5" file-name="src/lib.rs" caption="Adding `pub use` statements to re-export items">
<pre><code class="language-rust ignore">//! # Art
//!
//! A library for modeling artistic concepts.

pub use self::kinds::PrimaryColor;
pub use self::kinds::SecondaryColor;
pub use self::utils::mix;

pub mod kinds {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">    /// The primary colors according to the RYB color model.
</span><span class="boring">    pub enum PrimaryColor {
</span><span class="boring">        Red,
</span><span class="boring">        Yellow,
</span><span class="boring">        Blue,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// The secondary colors according to the RYB color model.
</span><span class="boring">    pub enum SecondaryColor {
</span><span class="boring">        Orange,
</span><span class="boring">        Green,
</span><span class="boring">        Purple,
</span><span class="boring">    }
</span>}

pub mod utils {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">    use crate::kinds::*;
</span><span class="boring">
</span><span class="boring">    /// Combines two primary colors in equal amounts to create
</span><span class="boring">    /// a secondary color.
</span><span class="boring">    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
</span><span class="boring">        SecondaryColor::Orange
</span><span class="boring">    }
</span>}</code></pre>
</Listing>
<p>The API documentation that <code>cargo doc</code> generates for this crate will now list and link re-exports on the front page, as shown in Figure 14-4, making the <code>PrimaryColor</code> and <code>SecondaryColor</code> types and the <code>mix</code> function easier to find.</p>
<img alt="Rendered documentation for the `art` crate with the re-exports on the front page" src="img/trpl14-04.png" class="center" />
<p><span class="caption">Figure 14-4: The front page of the documentation for <code>art</code> that lists the re-exports</span></p>
<p>The <code>art</code> crate users can still see and use the internal structure from Listing 14-3 as demonstrated in Listing 14-4, or they can use the more convenient structure in Listing 14-5, as shown in Listing 14-6:</p>
<Listing number="14-6" file-name="src/main.rs" caption="A program using the re-exported items from the `art` crate">
<pre><code class="language-rust ignore">use art::mix;
use art::PrimaryColor;

fn main() {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">    let red = PrimaryColor::Red;
</span><span class="boring">    let yellow = PrimaryColor::Yellow;
</span><span class="boring">    mix(red, yellow);
</span>}</code></pre>
</Listing>
<p>In cases where there are many nested modules, re-exporting the types at the top level with <code>pub use</code> can make a significant difference in the experience of people who use the crate. Another common use of <code>pub use</code> is to re-export definitions of a dependency in the current crate to make that crate's definitions part of your crate‚Äôs public API.</p>
<p>Creating a useful public API structure is more of an art than a science, and you can iterate to find the API that works best for your users. Choosing <code>pub use</code> gives you flexibility in how you structure your crate internally and decouples that internal structure from what you present to your users. Look at some of the code of crates you‚Äôve installed to see if their internal structure differs from their public API.</p>
<h3 id="setting-up-a-cratesio-account"><a class="header" href="#setting-up-a-cratesio-account">Setting Up a Crates.io Account</a></h3>
<p>Before you can publish any crates, you need to create an account on <a href="https://crates.io/">crates.io</a><!-- ignore --> and get an API token. To do so, visit the home page at <a href="https://crates.io/">crates.io</a><!-- ignore --> and log in via a GitHub account. (The GitHub account is currently a requirement, but the site might support other ways of creating an account in the future.) Once you‚Äôre logged in, visit your account settings at <a href="https://crates.io/me/">https://crates.io/me/</a><!-- ignore --> and retrieve your API key. Then run the <code>cargo login</code> command and paste your API key when prompted, like this:</p>
<pre><code class="language-console">$ cargo login
abcdefghijklmnopqrstuvwxyz012345
</code></pre>
<p>This command will inform Cargo of your API token and store it locally in <em>~/.cargo/credentials</em>. Note that this token is a <em>secret</em>: do not share it with anyone else. If you do share it with anyone for any reason, you should revoke it and generate a new token on <a href="https://crates.io/">crates.io</a><!-- ignore
-->.</p>
<h3 id="adding-metadata-to-a-new-crate"><a class="header" href="#adding-metadata-to-a-new-crate">Adding Metadata to a New Crate</a></h3>
<p>Let‚Äôs say you have a crate you want to publish. Before publishing, you‚Äôll need to add some metadata in the <code>[package]</code> section of the crate‚Äôs <em>Cargo.toml</em> file.</p>
<p>Your crate will need a unique name. While you‚Äôre working on a crate locally, you can name a crate whatever you‚Äôd like. However, crate names on <a href="https://crates.io/">crates.io</a><!-- ignore --> are allocated on a first-come, first-served basis. Once a crate name is taken, no one else can publish a crate with that name. Before attempting to publish a crate, search for the name you want to use. If the name has been used, you will need to find another name and edit the <code>name</code> field in the <em>Cargo.toml</em> file under the <code>[package]</code> section to use the new name for publishing, like so:</p>
<p><span class="filename">–§–∞–π–ª: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
</code></pre>
<p>Even if you‚Äôve chosen a unique name, when you run <code>cargo publish</code> to publish the crate at this point, you‚Äôll get a warning and then an error:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-01/
cargo publish
copy just the relevant lines below
-->
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
warning: manifest has no description, license, license-file, documentation, homepage or repository.
See https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata for more info.
--snip--
error: failed to publish to registry at https://crates.io

Caused by:
  the remote server responded with an error (status 400 Bad Request): missing or empty metadata fields: description, license. Please see https://doc.rust-lang.org/cargo/reference/manifest.html for more information on configuring these field
</code></pre>
<p>This errors because you‚Äôre missing some crucial information: a description and license are required so people will know what your crate does and under what terms they can use it. In <em>Cargo.toml</em>, add a description that's just a sentence or two, because it will appear with your crate in search results. For the <code>license</code> field, you need to give a <em>license identifier value</em>. The <a href="http://spdx.org/licenses/">Linux Foundation‚Äôs Software Package Data Exchange (SPDX)</a> lists the identifiers you can use for this value. For example, to specify that you‚Äôve licensed your crate using the MIT License, add the <code>MIT</code> identifier:</p>
<p><span class="filename">–§–∞–π–ª: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
license = "MIT"
</code></pre>
<p>If you want to use a license that doesn‚Äôt appear in the SPDX, you need to place the text of that license in a file, include the file in your project, and then use <code>license-file</code> to specify the name of that file instead of using the <code>license</code> key.</p>
<p>Guidance on which license is appropriate for your project is beyond the scope of this book. Many people in the Rust community license their projects in the same way as Rust by using a dual license of <code>MIT OR Apache-2.0</code>. This practice demonstrates that you can also specify multiple license identifiers separated by <code>OR</code> to have multiple licenses for your project.</p>
<p>With a unique name, the version, your description, and a license added, the <em>Cargo.toml</em> file for a project that is ready to publish might look like this:</p>
<p><span class="filename">–§–∞–π–ª: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
version = "0.1.0"
edition = "2021"
description = "A fun game where you guess what number the computer has chosen."
license = "MIT OR Apache-2.0"

[dependencies]
</code></pre>
<p><a href="https://doc.rust-lang.org/cargo/">Cargo‚Äôs documentation</a> describes other metadata you can specify to ensure others can discover and use your crate more easily.</p>
<h3 id="publishing-to-cratesio"><a class="header" href="#publishing-to-cratesio">Publishing to Crates.io</a></h3>
<p>Now that you‚Äôve created an account, saved your API token, chosen a name for your crate, and specified the required metadata, you‚Äôre ready to publish! Publishing a crate uploads a specific version to <a href="https://crates.io/">crates.io</a><!-- ignore --> for others to use.</p>
<p>Be careful, because a publish is <em>permanent</em>. The version can never be overwritten, and the code cannot be deleted. One major goal of <a href="https://crates.io/">crates.io</a><!-- ignore --> is to act as a permanent archive of code so that builds of all projects that depend on crates from <a href="https://crates.io/">crates.io</a><!-- ignore --> will continue to work. Allowing version deletions would make fulfilling that goal impossible. However, there is no limit to the number of crate versions you can publish.</p>
<p>Run the <code>cargo publish</code> command again. It should succeed now:</p>
<!-- manual-regeneration
go to some valid crate, publish a new version
cargo publish
copy just the relevant lines below
-->
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
   Packaging guessing_game v0.1.0 (file:///projects/guessing_game)
   Verifying guessing_game v0.1.0 (file:///projects/guessing_game)
   Compiling guessing_game v0.1.0
(file:///projects/guessing_game/target/package/guessing_game-0.1.0)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.19s
   Uploading guessing_game v0.1.0 (file:///projects/guessing_game)
</code></pre>
<p>Congratulations! You‚Äôve now shared your code with the Rust community, and anyone can easily add your crate as a dependency of their project.</p>
<h3 id="publishing-a-new-version-of-an-existing-crate"><a class="header" href="#publishing-a-new-version-of-an-existing-crate">Publishing a New Version of an Existing Crate</a></h3>
<p>When you‚Äôve made changes to your crate and are ready to release a new version, you change the <code>version</code> value specified in your <em>Cargo.toml</em> file and republish. Use the <a href="http://semver.org/">Semantic Versioning rules</a> to decide what an appropriate next version number is based on the kinds of changes you‚Äôve made. Then run <code>cargo publish</code> to upload the new version.</p>
<!-- Old link, do not remove -->
<p><a id="removing-versions-from-cratesio-with-cargo-yank"></a></p>
<h3 id="deprecating-versions-from-cratesio-with-cargo-yank"><a class="header" href="#deprecating-versions-from-cratesio-with-cargo-yank">Deprecating Versions from Crates.io with <code>cargo yank</code></a></h3>
<p>Although you can‚Äôt remove previous versions of a crate, you can prevent any future projects from adding them as a new dependency. This is useful when a crate version is broken for one reason or another. In such situations, Cargo supports <em>yanking</em> a crate version.</p>
<p>Yanking a version prevents new projects from depending on that version while allowing all existing projects that depend on it to continue. Essentially, a yank means that all projects with a <em>Cargo.lock</em> will not break, and any future <em>Cargo.lock</em> files generated will not use the yanked version.</p>
<p>To yank a version of a crate, in the directory of the crate that you‚Äôve previously published, run <code>cargo yank</code> and specify which version you want to yank. For example, if we've published a crate named <code>guessing_game</code> version 1.0.1 and we want to yank it, in the project directory for <code>guessing_game</code> we'd run:</p>
<!-- manual-regeneration:
cargo yank carol-test --version 2.1.0
cargo yank carol-test --version 2.1.0 --undo
-->
<pre><code class="language-console">$ cargo yank --vers 1.0.1
    Updating crates.io index
        Yank guessing_game@1.0.1
</code></pre>
<p>By adding <code>--undo</code> to the command, you can also undo a yank and allow projects to start depending on a version again:</p>
<pre><code class="language-console">$ cargo yank --vers 1.0.1 --undo
    Updating crates.io index
      Unyank guessing_game@1.0.1
</code></pre>
<p>A yank <em>does not</em> delete any code. It cannot, for example, delete accidentally uploaded secrets. If that happens, you must reset those secrets immediately.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–†–∞–±–æ—á–∏–µ-–ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞-cargo"><a class="header" href="#–†–∞–±–æ—á–∏–µ-–ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞-cargo">–†–∞–±–æ—á–∏–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞ Cargo</a></h2>
<p>In Chapter 12, we built a package that included a binary crate and a library crate. As your project develops, you might find that the library crate continues to get bigger and you want to split your package further into multiple library crates. Cargo offers a feature called <em>workspaces</em> that can help manage multiple related packages that are developed in tandem.</p>
<h3 id="creating-a-workspace"><a class="header" href="#creating-a-workspace">Creating a Workspace</a></h3>
<p>A <em>workspace</em> is a set of packages that share the same <em>Cargo.lock</em> and output directory. Let‚Äôs make a project using a workspace‚Äîwe‚Äôll use trivial code so we can concentrate on the structure of the workspace. There are multiple ways to structure a workspace, so we'll just show one common way. We‚Äôll have a workspace containing a binary and two libraries. The binary, which will provide the main functionality, will depend on the two libraries. One library will provide an <code>add_one</code> function, and a second library an <code>add_two</code> function. These three crates will be part of the same workspace. We‚Äôll start by creating a new directory for the workspace:</p>
<pre><code class="language-console">$ mkdir add
$ cd add
</code></pre>
<p>Next, in the <em>add</em> directory, we create the <em>Cargo.toml</em> file that will configure the entire workspace. This file won‚Äôt have a <code>[package]</code> section. Instead, it will start with a <code>[workspace]</code> section that will allow us to add members to the workspace. We also make a point to use the latest and greatest version of Cargo‚Äôs resolver algorithm in our workspace by setting the <code>resolver</code> to <code>"2"</code>.</p>
<p><span class="filename">–§–∞–π–ª: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]
resolver = "2"
</code></pre>
<p>Next, we‚Äôll create the <code>adder</code> binary crate by running <code>cargo new</code> within the <em>add</em> directory:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-01-adder-crate/add
rm -rf adder
cargo new adder
copy output below
-->
<pre><code class="language-console">$ cargo new adder
    Creating binary (application) `adder` package
      Adding `adder` as member of workspace at `file:///projects/add`
</code></pre>
<p>Running <code>cargo new</code> inside a workspace also automatically adds the newly created package to the <code>members</code> key in the <code>[workspace]</code> definition in the workspace <code>Cargo.toml</code>, like this:</p>
<pre><code class="language-toml">[workspace]
resolver = "2"
members = ["adder"]
</code></pre>
<p>At this point, we can build the workspace by running <code>cargo build</code>. The files in your <em>add</em> directory should look like this:</p>
<pre><code class="language-text">‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ adder
‚îÇ   ‚îú‚îÄ‚îÄ Cargo.toml
‚îÇ   ‚îî‚îÄ‚îÄ src
‚îÇ       ‚îî‚îÄ‚îÄ main.rs
‚îî‚îÄ‚îÄ target
</code></pre>
<p>The workspace has one <em>target</em> directory at the top level that the compiled artifacts will be placed into; the <code>adder</code> package doesn‚Äôt have its own <em>target</em> directory. Even if we were to run <code>cargo build</code> from inside the <em>adder</em> directory, the compiled artifacts would still end up in <em>add/target</em> rather than <em>add/adder/target</em>. Cargo structures the <em>target</em> directory in a workspace like this because the crates in a workspace are meant to depend on each other. If each crate had its own <em>target</em> directory, each crate would have to recompile each of the other crates in the workspace to place the artifacts in its own <em>target</em> directory. By sharing one <em>target</em> directory, the crates can avoid unnecessary rebuilding.</p>
<h3 id="creating-the-second-package-in-the-workspace"><a class="header" href="#creating-the-second-package-in-the-workspace">Creating the Second Package in the Workspace</a></h3>
<p>Next, let‚Äôs create another member package in the workspace and call it <code>add_one</code>. Change the top-level <em>Cargo.toml</em> to specify the <em>add_one</em> path in the <code>members</code> list:</p>
<p><span class="filename">–§–∞–π–ª: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]
resolver = "2"
members = ["adder", "add_one"]
</code></pre>
<p>Then generate a new library crate named <code>add_one</code>:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-02-add-one/add
rm -rf add_one
cargo new add_one --lib
copy output below
-->
<pre><code class="language-console">$ cargo new add_one --lib
    Creating library `add_one` package
      Adding `add_one` as member of workspace at `file:///projects/add`
</code></pre>
<p>Your <em>add</em> directory should now have these directories and files:</p>
<pre><code class="language-text">‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ add_one
‚îÇ   ‚îú‚îÄ‚îÄ Cargo.toml
‚îÇ   ‚îî‚îÄ‚îÄ src
‚îÇ       ‚îî‚îÄ‚îÄ lib.rs
‚îú‚îÄ‚îÄ adder
‚îÇ   ‚îú‚îÄ‚îÄ Cargo.toml
‚îÇ   ‚îî‚îÄ‚îÄ src
‚îÇ       ‚îî‚îÄ‚îÄ main.rs
‚îî‚îÄ‚îÄ target
</code></pre>
<p>In the <em>add_one/src/lib.rs</em> file, let‚Äôs add an <code>add_one</code> function:</p>
<p><span class="filename">–§–∞–π–ª: add_one/src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}</code></pre>
<p>Now we can have the <code>adder</code> package with our binary depend on the <code>add_one</code> package that has our library. First, we‚Äôll need to add a path dependency on <code>add_one</code> to <em>adder/Cargo.toml</em>.</p>
<p><span class="filename">–§–∞–π–ª: adder/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
add_one = { path = "../add_one" }
</code></pre>
<p>Cargo doesn‚Äôt assume that crates in a workspace will depend on each other, so we need to be explicit about the dependency relationships.</p>
<p>Next, let‚Äôs use the <code>add_one</code> function (from the <code>add_one</code> crate) in the <code>adder</code> crate. Open the <em>adder/src/main.rs</em> file and change the <code>main</code> function to call the <code>add_one</code> function, as in Listing 14-7.</p>
<Listing number="14-7" file-name="adder/src/main.rs" caption="Using the `add_one` library crate in the `adder` crate">
<pre><code class="language-rust ignore">fn main() {
    let num = 10;
    println!("Hello, world! {num} plus one is {}!", add_one::add_one(num));
}</code></pre>
</Listing>
<p>Let‚Äôs build the workspace by running <code>cargo build</code> in the top-level <em>add</em> directory!</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-07/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo build
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.22s
</code></pre>
<p>To run the binary crate from the <em>add</em> directory, we can specify which package in the workspace we want to run by using the <code>-p</code> argument and the package name with <code>cargo run</code>:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-07/add
cargo run -p adder
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo run -p adder
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.00s
     Running `target/debug/adder`
Hello, world! 10 plus one is 11!
</code></pre>
<p>This runs the code in <em>adder/src/main.rs</em>, which depends on the <code>add_one</code> crate.</p>
<h4 id="depending-on-an-external-package-in-a-workspace"><a class="header" href="#depending-on-an-external-package-in-a-workspace">Depending on an External Package in a Workspace</a></h4>
<p>Notice that the workspace has only one <em>Cargo.lock</em> file at the top level, rather than having a <em>Cargo.lock</em> in each crate‚Äôs directory. This ensures that all crates are using the same version of all dependencies. If we add the <code>rand</code> package to the <em>adder/Cargo.toml</em> and <em>add_one/Cargo.toml</em> files, Cargo will resolve both of those to one version of <code>rand</code> and record that in the one <em>Cargo.lock</em>. Making all crates in the workspace use the same dependencies means the crates will always be compatible with each other. Let‚Äôs add the <code>rand</code> crate to the <code>[dependencies]</code> section in the <em>add_one/Cargo.toml</em> file so we can use the <code>rand</code> crate in the <code>add_one</code> crate:</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch02-00-guessing-game-tutorial.md
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
-->
<p><span class="filename">–§–∞–π–ª: add_one/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = "0.8.5"
</code></pre>
<p>We can now add <code>use rand;</code> to the <em>add_one/src/lib.rs</em> file, and building the whole workspace by running <code>cargo build</code> in the <em>add</em> directory will bring in and compile the <code>rand</code> crate. We will get one warning because we aren‚Äôt referring to the <code>rand</code> we brought into scope:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-03-workspace-with-external-dependency/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.5
   --snip--
   Compiling rand v0.8.5
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
warning: unused import: `rand`
 --&gt; add_one/src/lib.rs:1:5
  |
1 | use rand;
  |     ^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: `add_one` (lib) generated 1 warning (run `cargo fix --lib -p add_one` to apply 1 suggestion)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.95s
</code></pre>
<p>The top-level <em>Cargo.lock</em> now contains information about the dependency of <code>add_one</code> on <code>rand</code>. However, even though <code>rand</code> is used somewhere in the workspace, we can‚Äôt use it in other crates in the workspace unless we add <code>rand</code> to their <em>Cargo.toml</em> files as well. For example, if we add <code>use rand;</code> to the <em>adder/src/main.rs</em> file for the <code>adder</code> package, we‚Äôll get an error:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-03-use-rand/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo build
  --snip--
   Compiling adder v0.1.0 (file:///projects/add/adder)
error[E0432]: unresolved import `rand`
 --&gt; adder/src/main.rs:2:5
  |
2 | use rand;
  |     ^^^^ no external crate `rand`
</code></pre>
<p>To fix this, edit the <em>Cargo.toml</em> file for the <code>adder</code> package and indicate that <code>rand</code> is a dependency for it as well. Building the <code>adder</code> package will add <code>rand</code> to the list of dependencies for <code>adder</code> in <em>Cargo.lock</em>, but no additional copies of <code>rand</code> will be downloaded. Cargo will ensure that every crate in every package in the workspace using the <code>rand</code> package will be using the same version as long as they specify compatible versions of <code>rand</code>, saving us space and ensuring that the crates in the workspace will be compatible with each other.</p>
<p>If crates in the workspace specify incompatible versions of the same dependency, Cargo will resolve each of them, but will still try to resolve as few versions as possible.</p>
<h4 id="adding-a-test-to-a-workspace"><a class="header" href="#adding-a-test-to-a-workspace">Adding a Test to a Workspace</a></h4>
<p>For another enhancement, let‚Äôs add a test of the <code>add_one::add_one</code> function within the <code>add_one</code> crate:</p>
<p><span class="filename">–§–∞–π–ª: add_one/src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(3, add_one(2));
    }
}</code></pre>
<p>Now run <code>cargo test</code> in the top-level <em>add</em> directory. Running <code>cargo test</code> in a workspace structured like this one will run the tests for all the crates in the workspace:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-04-workspace-with-tests/add
cargo test
copy output below; the output updating script doesn't handle subdirectories in
paths properly
-->
<pre><code class="language-console">$ cargo test
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.20s
     Running unittests src/lib.rs (target/debug/deps/add_one-f0253159197f7841)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/adder-49979ff40686fa8e)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests add_one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>The first section of the output shows that the <code>it_works</code> test in the <code>add_one</code> crate passed. The next section shows that zero tests were found in the <code>adder</code> crate, and then the last section shows zero documentation tests were found in the <code>add_one</code> crate.</p>
<p>We can also run tests for one particular crate in a workspace from the top-level directory by using the <code>-p</code> flag and specifying the name of the crate we want to test:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-04-workspace-with-tests/add
cargo test -p add_one
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo test -p add_one
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.00s
     Running unittests src/lib.rs (target/debug/deps/add_one-b3235fea9a156f74)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests add_one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>This output shows <code>cargo test</code> only ran the tests for the <code>add_one</code> crate and didn‚Äôt run the <code>adder</code> crate tests.</p>
<p>If you publish the crates in the workspace to <a href="https://crates.io/">crates.io</a>, each crate in the workspace will need to be published separately. Like <code>cargo test</code>, we can publish a particular crate in our workspace by using the <code>-p</code> flag and specifying the name of the crate we want to publish.</p>
<p>For additional practice, add an <code>add_two</code> crate to this workspace in a similar way as the <code>add_one</code> crate!</p>
<p>As your project grows, consider using a workspace: it‚Äôs easier to understand smaller, individual components than one big blob of code. Furthermore, keeping the crates in a workspace can make coordination between crates easier if they are often changed at the same time.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- Old link, do not remove -->
<p><a id="installing-binaries-from-cratesio-with-cargo-install"></a></p>
<h2 id="installing-binaries-with-cargo-install"><a class="header" href="#installing-binaries-with-cargo-install">Installing Binaries with <code>cargo install</code></a></h2>
<p>The <code>cargo install</code> command allows you to install and use binary crates locally. This isn‚Äôt intended to replace system packages; it‚Äôs meant to be a convenient way for Rust developers to install tools that others have shared on <a href="https://crates.io/">crates.io</a><!-- ignore -->. Note that you can only install packages that have binary targets. A <em>binary target</em> is the runnable program that is created if the crate has a <em>src/main.rs</em> file or another file specified as a binary, as opposed to a library target that isn‚Äôt runnable on its own but is suitable for including within other programs. Usually, crates have information in the <em>README</em> file about whether a crate is a library, has a binary target, or both.</p>
<p>All binaries installed with <code>cargo install</code> are stored in the installation root‚Äôs <em>bin</em> folder. If you installed Rust using <em>rustup.rs</em> and don‚Äôt have any custom configurations, this directory will be <em>$HOME/.cargo/bin</em>. Ensure that directory is in your <code>$PATH</code>to be able to run programs you‚Äôve installed with<code>cargo install</code>.</p>
<p>For example, in Chapter 12 we mentioned that there‚Äôs a Rust implementation of the <code>grep</code> tool called <code>ripgrep</code> for searching files. To install <code>ripgrep</code>, we can run the following:</p>
<!-- manual-regeneration
cargo install something you don't have, copy relevant output below
-->
<pre><code class="language-console">$ cargo install ripgrep
    Updating crates.io index
  Downloaded ripgrep v13.0.0
  Downloaded 1 crate (243.3 KB) in 0.88s
  Installing ripgrep v13.0.0
--snip--
   Compiling ripgrep v13.0.0
    Finished `release` profile [optimized + debuginfo] target(s) in 10.64s
  Installing ~/.cargo/bin/rg
   Installed package `ripgrep v13.0.0` (executable `rg`)
</code></pre>
<p>The second-to-last line of the output shows the location and the name of the installed binary, which in the case of <code>ripgrep</code> is <code>rg</code>. As long as the installation directory is in your <code>$PATH</code>, as mentioned previously, you can then run <code>rg --help</code> and start using a faster, rustier tool for searching files!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–†–∞—Å—à–∏—Ä–µ–Ω–∏–µ-cargo-–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–º–∏-–∫–æ–º–∞–Ω–¥–∞–º–∏"><a class="header" href="#–†–∞—Å—à–∏—Ä–µ–Ω–∏–µ-cargo-–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–º–∏-–∫–æ–º–∞–Ω–¥–∞–º–∏">–†–∞—Å—à–∏—Ä–µ–Ω–∏–µ Cargo –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–º–∏ –∫–æ–º–∞–Ω–¥–∞–º–∏</a></h2>
<p>Cargo is designed so you can extend it with new subcommands without having to modify Cargo. If a binary in your <code>$PATH</code> is named <code>cargo-something</code>, you can run it as if it was a Cargo subcommand by running <code>cargo something</code>. Custom commands like this are also listed when you run <code>cargo --list</code>. Being able to use <code>cargo install</code> to install extensions and then run them just like the built-in Cargo tools is a super convenient benefit of Cargo‚Äôs design!</p>
<h2 id="–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-13"><a class="header" href="#–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-13">–ü–æ–¥–≤–µ–¥—ë–º –∏—Ç–æ–≥–∏</a></h2>
<p>Sharing code with Cargo and <a href="https://crates.io/">crates.io</a><!-- ignore --> is part of what makes the Rust ecosystem useful for many different tasks. Rust‚Äôs standard library is small and stable, but crates are easy to share, use, and improve on a timeline different from that of the language. Don‚Äôt be shy about sharing code that‚Äôs useful to you on <a href="https://crates.io/">crates.io</a><!-- ignore
-->; it‚Äôs likely that it will be useful to someone else as well!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="–£–º–Ω—ã–µ-—É–∫–∞–∑–∞—Ç–µ–ª–∏"><a class="header" href="#–£–º–Ω—ã–µ-—É–∫–∞–∑–∞—Ç–µ–ª–∏">–£–º–Ω—ã–µ —É–∫–∞–∑–∞—Ç–µ–ª–∏</a></h1>
<p>A <em>pointer</em> is a general concept for a variable that contains an address in memory. This address refers to, or ‚Äúpoints at,‚Äù some other data. The most common kind of pointer in Rust is a reference, which you learned about in Chapter 4. References are indicated by the <code>&amp;</code> symbol and borrow the value they point to. They don‚Äôt have any special capabilities other than referring to data, and have no overhead.</p>
<p><em>Smart pointers</em>, on the other hand, are data structures that act like a pointer but also have additional metadata and capabilities. The concept of smart pointers isn‚Äôt unique to Rust: smart pointers originated in C++ and exist in other languages as well. Rust has a variety of smart pointers defined in the standard library that provide functionality beyond that provided by references. To explore the general concept, we‚Äôll look at a couple of different examples of smart pointers, including a <em>reference counting</em> smart pointer type. This pointer enables you to allow data to have multiple owners by keeping track of the number of owners and, when no owners remain, cleaning up the data.</p>
<p>Rust, with its concept of ownership and borrowing, has an additional difference between references and smart pointers: while references only borrow data, in many cases, smart pointers <em>own</em> the data they point to.</p>
<p>Though we didn‚Äôt call them as such at the time, we‚Äôve already encountered a few smart pointers in this book, including <code>String</code> and <code>Vec&lt;T&gt;</code> in Chapter 8. Both these types count as smart pointers because they own some memory and allow you to manipulate it. They also have metadata and extra capabilities or guarantees. <code>String</code>, for example, stores its capacity as metadata and has the extra ability to ensure its data will always be valid UTF-8.</p>
<p>Smart pointers are usually implemented using structs. Unlike an ordinary struct, smart pointers implement the <code>Deref</code> and <code>Drop</code> traits. The <code>Deref</code> trait allows an instance of the smart pointer struct to behave like a reference so you can write your code to work with either references or smart pointers. The <code>Drop</code> trait allows you to customize the code that‚Äôs run when an instance of the smart pointer goes out of scope. In this chapter, we‚Äôll discuss both of these traits and demonstrate why they‚Äôre important to smart pointers.</p>
<p>Given that the smart pointer pattern is a general design pattern used frequently in Rust, this chapter won‚Äôt cover every existing smart pointer. Many libraries have their own smart pointers, and you can even write your own. We‚Äôll cover the most common smart pointers in the standard library:</p>
<ul>
<li><code>Box&lt;T&gt;</code> for allocating values on the heap</li>
<li><code>Rc&lt;T&gt;</code>, a reference counting type that enables multiple ownership</li>
<li><code>Ref&lt;T&gt;</code> and <code>RefMut&lt;T&gt;</code>, accessed through <code>RefCell&lt;T&gt;</code>, a type that enforces the borrowing rules at runtime instead of compile time</li>
</ul>
<p>In addition, we‚Äôll cover the <em>interior mutability</em> pattern where an immutable type exposes an API for mutating an interior value. We‚Äôll also discuss <em>reference cycles</em>: how they can leak memory and how to prevent them.</p>
<p>Let‚Äôs dive in!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ-boxt-–¥–ª—è-—Ä–∞–±–æ—Ç—ã-—Å-–¥–∞–Ω–Ω—ã–º–∏-–≤-–∫—É—á–µ"><a class="header" href="#–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ-boxt-–¥–ª—è-—Ä–∞–±–æ—Ç—ã-—Å-–¥–∞–Ω–Ω—ã–º–∏-–≤-–∫—É—á–µ">–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ <code>Box&lt;T&gt;</code> –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –¥–∞–Ω–Ω—ã–º–∏ –≤ –∫—É—á–µ</a></h2>
<p>The most straightforward smart pointer is a <em>box</em>, whose type is written <code>Box&lt;T&gt;</code>. Boxes allow you to store data on the heap rather than the stack. What remains on the stack is the pointer to the heap data. Refer to Chapter 4 to review the difference between the stack and the heap.</p>
<p>Boxes don‚Äôt have performance overhead, other than storing their data on the heap instead of on the stack. But they don‚Äôt have many extra capabilities either. You‚Äôll use them most often in these situations:</p>
<ul>
<li>When you have a type whose size can‚Äôt be known at compile time and you want to use a value of that type in a context that requires an exact size</li>
<li>When you have a large amount of data and you want to transfer ownership but ensure the data won‚Äôt be copied when you do so</li>
<li>When you want to own a value and you care only that it‚Äôs a type that implements a particular trait rather than being of a specific type</li>
</ul>
<p>We‚Äôll demonstrate the first situation in the <a href="ch15-01-box.html#enabling-recursive-types-with-boxes">‚ÄúEnabling Recursive Types with Boxes‚Äù</a><!-- ignore --> section. In the second case, transferring ownership of a large amount of data can take a long time because the data is copied around on the stack. To improve performance in this situation, we can store the large amount of data on the heap in a box. Then, only the small amount of pointer data is copied around on the stack, while the data it references stays in one place on the heap. The third case is known as a <em>trait object</em>, and Chapter 18 devotes an entire section, <a href="ch18-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">‚ÄúUsing Trait Objects That Allow for Values of Different Types,‚Äù</a><!--
ignore --> just to that topic. So what you learn here you‚Äôll apply again in Chapter 18!</p>
<h3 id="using-a-boxt-to-store-data-on-the-heap"><a class="header" href="#using-a-boxt-to-store-data-on-the-heap">Using a <code>Box&lt;T&gt;</code> to Store Data on the Heap</a></h3>
<p>Before we discuss the heap storage use case for <code>Box&lt;T&gt;</code>, we‚Äôll cover the syntax and how to interact with values stored within a <code>Box&lt;T&gt;</code>.</p>
<p>Listing 15-1 shows how to use a box to store an <code>i32</code> value on the heap:</p>
<Listing number="15-1" file-name="src/main.rs" caption="Storing an `i32` value on the heap using a box">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let b = Box::new(5);
    println!("b = {b}");
}</code></pre></pre>
</Listing>
<p>We define the variable <code>b</code> to have the value of a <code>Box</code> that points to the value <code>5</code>, which is allocated on the heap. This program will print <code>b = 5</code>; in this case, we can access the data in the box similarly to how we would if this data were on the stack. Just like any owned value, when a box goes out of scope, as <code>b</code> does at the end of <code>main</code>, it will be deallocated. The deallocation happens both for the box (stored on the stack) and the data it points to (stored on the heap).</p>
<p>Putting a single value on the heap isn‚Äôt very useful, so you won‚Äôt use boxes by themselves in this way very often. Having values like a single <code>i32</code> on the stack, where they‚Äôre stored by default, is more appropriate in the majority of situations. Let‚Äôs look at a case where boxes allow us to define types that we wouldn‚Äôt be allowed to if we didn‚Äôt have boxes.</p>
<h3 id="enabling-recursive-types-with-boxes"><a class="header" href="#enabling-recursive-types-with-boxes">Enabling Recursive Types with Boxes</a></h3>
<p>A value of <em>recursive type</em> can have another value of the same type as part of itself. Recursive types pose an issue because, at compile time, Rust needs to know how much space a type takes up. However, the nesting of values of recursive types could theoretically continue infinitely, so Rust can‚Äôt know how much space the value needs. Because boxes have a known size, we can enable recursive types by inserting a box in the recursive type definition.</p>
<p>As an example of a recursive type, let‚Äôs explore the <em>cons list</em>. This is a data type commonly found in functional programming languages. The cons list type we‚Äôll define is straightforward except for the recursion; therefore, the concepts in the example we‚Äôll work with will be useful any time you get into more complex situations involving recursive types.</p>
<h4 id="more-information-about-the-cons-list"><a class="header" href="#more-information-about-the-cons-list">More Information About the Cons List</a></h4>
<p>A <em>cons list</em> is a data structure that comes from the Lisp programming language and its dialects and is made up of nested pairs, and is the Lisp version of a linked list. Its name comes from the <code>cons</code> function (short for ‚Äúconstruct function‚Äù) in Lisp that constructs a new pair from its two arguments. By calling <code>cons</code> on a pair consisting of a value and another pair, we can construct cons lists made up of recursive pairs.</p>
<p>For example, here‚Äôs a pseudocode representation of a cons list containing the list 1, 2, 3 with each pair in parentheses:</p>
<pre><code class="language-text">(1, (2, (3, Nil)))
</code></pre>
<p>Each item in a cons list contains two elements: the value of the current item and the next item. The last item in the list contains only a value called <code>Nil</code> without a next item. A cons list is produced by recursively calling the <code>cons</code> function. The canonical name to denote the base case of the recursion is <code>Nil</code>. Note that this is not the same as the ‚Äúnull‚Äù or ‚Äúnil‚Äù concept discussed in Chapter 6, which is an invalid or absent value.</p>
<p>The cons list isn‚Äôt a commonly used data structure in Rust. Most of the time when you have a list of items in Rust, <code>Vec&lt;T&gt;</code> is a better choice to use. Other, more complex recursive data types <em>are</em> useful in various situations, but by starting with the cons list in this chapter, we can explore how boxes let us define a recursive data type without much distraction.</p>
<p>Listing 15-2 contains an enum definition for a cons list. Note that this code won‚Äôt compile yet because the <code>List</code> type doesn‚Äôt have a known size, which we‚Äôll demonstrate.</p>
<Listing number="15-2" file-name="src/main.rs" caption="The first attempt at defining an enum to represent a cons list data structure of `i32` values">
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, List),
    Nil,
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
</Listing>
<blockquote>
<p>Note: We‚Äôre implementing a cons list that holds only <code>i32</code> values for the purposes of this example. We could have implemented it using generics, as we discussed in Chapter 10, to define a cons list type that could store values of any type.</p>
</blockquote>
<p>Using the <code>List</code> type to store the list <code>1, 2, 3</code> would look like the code in Listing 15-3:</p>
<Listing number="15-3" file-name="src/main.rs" caption="Using the `List` enum to store the list `1, 2, 3`">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, List),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span>use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}</code></pre>
</Listing>
<p>The first <code>Cons</code> value holds <code>1</code> and another <code>List</code> value. This <code>List</code> value is another <code>Cons</code> value that holds <code>2</code> and another <code>List</code> value. This <code>List</code> value is one more <code>Cons</code> value that holds <code>3</code> and a <code>List</code> value, which is finally <code>Nil</code>, the non-recursive variant that signals the end of the list.</p>
<p>If we try to compile the code in Listing 15-3, we get the error shown in Listing 15-4:</p>
<Listing number="15-4" file-name="output.txt" caption="The error we get when attempting to define a recursive enum">
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0072]: recursive type `List` has infinite size
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
2 |     Cons(i32, List),
  |               ---- recursive without indirection
  |
help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to break the cycle
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +

error[E0391]: cycle detected when computing when `List` needs drop
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
  |
  = note: ...which immediately requires computing when `List` needs drop again
  = note: cycle used when computing whether `List` needs drop
  = note: see https://rustc-dev-guide.rust-lang.org/overview.html#queries and https://rustc-dev-guide.rust-lang.org/query.html for more information

Some errors have detailed explanations: E0072, E0391.
For more information about an error, try `rustc --explain E0072`.
error: could not compile `cons-list` (bin "cons-list") due to 2 previous errors
</code></pre>
</Listing>
<p>The error shows this type ‚Äúhas infinite size.‚Äù The reason is that we‚Äôve defined <code>List</code> with a variant that is recursive: it holds another value of itself directly. As a result, Rust can‚Äôt figure out how much space it needs to store a <code>List</code> value. Let‚Äôs break down why we get this error. First, we‚Äôll look at how Rust decides how much space it needs to store a value of a non-recursive type.</p>
<h4 id="computing-the-size-of-a-non-recursive-type"><a class="header" href="#computing-the-size-of-a-non-recursive-type">Computing the Size of a Non-Recursive Type</a></h4>
<p>Recall the <code>Message</code> enum we defined in Listing 6-2 when we discussed enum definitions in Chapter 6:</p>
<pre><pre class="playground"><code class="language-rust edition2021">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>To determine how much space to allocate for a <code>Message</code> value, Rust goes through each of the variants to see which variant needs the most space. Rust sees that <code>Message::Quit</code> doesn‚Äôt need any space, <code>Message::Move</code> needs enough space to store two <code>i32</code> values, and so forth. Because only one variant will be used, the most space a <code>Message</code> value will need is the space it would take to store the largest of its variants.</p>
<p>Contrast this with what happens when Rust tries to determine how much space a recursive type like the <code>List</code> enum in Listing 15-2 needs. The compiler starts by looking at the <code>Cons</code> variant, which holds a value of type <code>i32</code> and a value of type <code>List</code>. Therefore, <code>Cons</code> needs an amount of space equal to the size of an <code>i32</code> plus the size of a <code>List</code>. To figure out how much memory the <code>List</code> type needs, the compiler looks at the variants, starting with the <code>Cons</code> variant. The <code>Cons</code> variant holds a value of type <code>i32</code> and a value of type <code>List</code>, and this process continues infinitely, as shown in Figure 15-1.</p>
<img alt="An infinite Cons list" src="img/trpl15-01.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figure 15-1: An infinite <code>List</code> consisting of infinite <code>Cons</code> variants</span></p>
<h4 id="using-boxt-to-get-a-recursive-type-with-a-known-size"><a class="header" href="#using-boxt-to-get-a-recursive-type-with-a-known-size">Using <code>Box&lt;T&gt;</code> to Get a Recursive Type with a Known Size</a></h4>
<p>Because Rust can‚Äôt figure out how much space to allocate for recursively defined types, the compiler gives an error with this helpful suggestion:</p>
<!-- manual-regeneration
after doing automatic regeneration, look at listings/ch15-smart-pointers/listing-15-03/output.txt and copy the relevant line
-->
<pre><code class="language-text">help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to break the cycle
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +
</code></pre>
<p>In this suggestion, ‚Äúindirection‚Äù means that instead of storing a value directly, we should change the data structure to store the value indirectly by storing a pointer to the value instead.</p>
<p>Because a <code>Box&lt;T&gt;</code> is a pointer, Rust always knows how much space a <code>Box&lt;T&gt;</code> needs: a pointer‚Äôs size doesn‚Äôt change based on the amount of data it‚Äôs pointing to. This means we can put a <code>Box&lt;T&gt;</code> inside the <code>Cons</code> variant instead of another <code>List</code> value directly. The <code>Box&lt;T&gt;</code> will point to the next <code>List</code> value that will be on the heap rather than inside the <code>Cons</code> variant. Conceptually, we still have a list, created with lists holding other lists, but this implementation is now more like placing the items next to one another rather than inside one another.</p>
<p>We can change the definition of the <code>List</code> enum in Listing 15-2 and the usage of the <code>List</code> in Listing 15-3 to the code in Listing 15-5, which will compile:</p>
<Listing number="15-5" file-name="src/main.rs" caption="Definition of `List` that uses `Box<T>` in order to have a known size">
<pre><pre class="playground"><code class="language-rust edition2021">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}</code></pre></pre>
</Listing>
<p>The <code>Cons</code> variant needs the size of an <code>i32</code> plus the space to store the box‚Äôs pointer data. The <code>Nil</code> variant stores no values, so it needs less space than the <code>Cons</code> variant. We now know that any <code>List</code> value will take up the size of an <code>i32</code> plus the size of a box‚Äôs pointer data. By using a box, we‚Äôve broken the infinite, recursive chain, so the compiler can figure out the size it needs to store a <code>List</code> value. Figure 15-2 shows what the <code>Cons</code> variant looks like now.</p>
<img alt="A finite Cons list" src="img/trpl15-02.svg" class="center" />
<p><span class="caption">Figure 15-2: A <code>List</code> that is not infinitely sized because <code>Cons</code> holds a <code>Box</code></span></p>
<p>Boxes provide only the indirection and heap allocation; they don‚Äôt have any other special capabilities, like those we‚Äôll see with the other smart pointer types. They also don‚Äôt have the performance overhead that these special capabilities incur, so they can be useful in cases like the cons list where the indirection is the only feature we need. We‚Äôll look at more use cases for boxes in Chapter 18, too.</p>
<p>The <code>Box&lt;T&gt;</code> type is a smart pointer because it implements the <code>Deref</code> trait, which allows <code>Box&lt;T&gt;</code> values to be treated like references. When a <code>Box&lt;T&gt;</code> value goes out of scope, the heap data that the box is pointing to is cleaned up as well because of the <code>Drop</code> trait implementation. These two traits will be even more important to the functionality provided by the other smart pointer types we‚Äôll discuss in the rest of this chapter. Let‚Äôs explore these two traits in more detail.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ-—É–º–Ω—ã—Ö-—É–∫–∞–∑–∞—Ç–µ–ª–µ–π-–≤-–∫–∞—á–µ—Å—Ç–≤–µ-–æ–±—ã—á–Ω—ã—Ö-—Å—Å—ã–ª–æ–∫-—Å-–ø–æ–º–æ—â—å—é-—Ç—Ä–µ–π—Ç–∞-deref"><a class="header" href="#–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ-—É–º–Ω—ã—Ö-—É–∫–∞–∑–∞—Ç–µ–ª–µ–π-–≤-–∫–∞—á–µ—Å—Ç–≤–µ-–æ–±—ã—á–Ω—ã—Ö-—Å—Å—ã–ª–æ–∫-—Å-–ø–æ–º–æ—â—å—é-—Ç—Ä–µ–π—Ç–∞-deref">–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —É–º–Ω—ã—Ö —É–∫–∞–∑–∞—Ç–µ–ª–µ–π –≤ –∫–∞—á–µ—Å—Ç–≤–µ –æ–±—ã—á–Ω—ã—Ö —Å—Å—ã–ª–æ–∫ —Å –ø–æ–º–æ—â—å—é —Ç—Ä–µ–π—Ç–∞ <code>Deref</code></a></h2>
<p>Implementing the <code>Deref</code> trait allows you to customize the behavior of the <em>dereference operator</em> <code>*</code> (not to be confused with the multiplication or glob operator). By implementing <code>Deref</code> in such a way that a smart pointer can be treated like a regular reference, you can write code that operates on references and use that code with smart pointers too.</p>
<p>Let‚Äôs first look at how the dereference operator works with regular references. Then we‚Äôll try to define a custom type that behaves like <code>Box&lt;T&gt;</code>, and see why the dereference operator doesn‚Äôt work like a reference on our newly defined type. We‚Äôll explore how implementing the <code>Deref</code> trait makes it possible for smart pointers to work in ways similar to references. Then we‚Äôll look at Rust‚Äôs <em>deref coercion</em> feature and how it lets us work with either references or smart pointers.</p>
<blockquote>
<p>Note: There‚Äôs one big difference between the <code>MyBox&lt;T&gt;</code> type we‚Äôre about to build and the real <code>Box&lt;T&gt;</code>: our version will not store its data on the heap. We are focusing this example on <code>Deref</code>, so where the data is actually stored is less important than the pointer-like behavior.</p>
</blockquote>
<!-- Old link, do not remove -->
<p><a id="following-the-pointer-to-the-value-with-the-dereference-operator"></a></p>
<h3 id="–ü–æ–ª—É—á–µ–Ω–∏–µ-–∑–Ω–∞—á–µ–Ω–∏—è-–ø–æ-—É–∫–∞–∑–∞—Ç–µ–ª—é"><a class="header" href="#–ü–æ–ª—É—á–µ–Ω–∏–µ-–∑–Ω–∞—á–µ–Ω–∏—è-–ø–æ-—É–∫–∞–∑–∞—Ç–µ–ª—é">–ü–æ–ª—É—á–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–∫–∞–∑–∞—Ç–µ–ª—é</a></h3>
<p>A regular reference is a type of pointer, and one way to think of a pointer is as an arrow to a value stored somewhere else. In Listing 15-6, we create a reference to an <code>i32</code> value and then use the dereference operator to follow the reference to the value:</p>
<Listing number="15-6" file-name="src/main.rs" caption="Using the dereference operator to follow a reference to an `i32` value">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre></pre>
</Listing>
<p>The variable <code>x</code> holds an <code>i32</code> value <code>5</code>. We set <code>y</code> equal to a reference to <code>x</code>. We can assert that <code>x</code> is equal to <code>5</code>. However, if we want to make an assertion about the value in <code>y</code>, we have to use <code>*y</code> to follow the reference to the value it‚Äôs pointing to (hence <em>dereference</em>) so the compiler can compare the actual value. Once we dereference <code>y</code>, we have access to the integer value <code>y</code> is pointing to that we can compare with <code>5</code>.</p>
<p>If we tried to write <code>assert_eq!(5, y);</code> instead, we would get this compilation error:</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0277]: can't compare `{integer}` with `&amp;{integer}`
 --&gt; src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^ no implementation for `{integer} == &amp;{integer}`
  |
  = help: the trait `PartialEq&lt;&amp;{integer}&gt;` is not implemented for `{integer}`
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider dereferencing here
 --&gt; file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/core/src/macros/mod.rs:46:35
  |
46|                 if !(*left_val == **right_val) {
  |                                   +

For more information about this error, try `rustc --explain E0277`.
error: could not compile `deref-example` (bin "deref-example") due to 1 previous error
</code></pre>
<p>Comparing a number and a reference to a number isn‚Äôt allowed because they‚Äôre different types. We must use the dereference operator to follow the reference to the value it‚Äôs pointing to.</p>
<h3 id="using-boxt-like-a-reference"><a class="header" href="#using-boxt-like-a-reference">Using <code>Box&lt;T&gt;</code> Like a Reference</a></h3>
<p>We can rewrite the code in Listing 15-6 to use a <code>Box&lt;T&gt;</code> instead of a reference; the dereference operator used on the <code>Box&lt;T&gt;</code> in Listing 15-7 functions in the same way as the dereference operator used on the reference in Listing 15-6:</p>
<Listing number="15-7" file-name="src/main.rs" caption="Using the dereference operator on a `Box<i32>`">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre></pre>
</Listing>
<p>The main difference between Listing 15-7 and Listing 15-6 is that here we set <code>y</code> to be an instance of a <code>Box&lt;T&gt;</code> pointing to a copied value of <code>x</code> rather than a reference pointing to the value of <code>x</code>. In the last assertion, we can use the dereference operator to follow the pointer of the <code>Box&lt;T&gt;</code> in the same way that we did when <code>y</code> was a reference. Next, we‚Äôll explore what is special about <code>Box&lt;T&gt;</code> that enables us to use the dereference operator by defining our own type.</p>
<h3 id="defining-our-own-smart-pointer"><a class="header" href="#defining-our-own-smart-pointer">Defining Our Own Smart Pointer</a></h3>
<p>Let‚Äôs build a smart pointer similar to the <code>Box&lt;T&gt;</code> type provided by the standard library to experience how smart pointers behave differently from references by default. Then we‚Äôll look at how to add the ability to use the dereference operator.</p>
<p>The <code>Box&lt;T&gt;</code> type is ultimately defined as a tuple struct with one element, so Listing 15-8 defines a <code>MyBox&lt;T&gt;</code> type in the same way. We‚Äôll also define a <code>new</code> function to match the <code>new</code> function defined on <code>Box&lt;T&gt;</code>.</p>
<Listing number="15-8" file-name="src/main.rs" caption="Defining a `MyBox<T>` type">
<pre><pre class="playground"><code class="language-rust edition2021">struct MyBox&lt;T&gt;(T);

impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox(x)
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p>We define a struct named <code>MyBox</code> and declare a generic parameter <code>T</code>, because we want our type to hold values of any type. The <code>MyBox</code> type is a tuple struct with one element of type <code>T</code>. The <code>MyBox::new</code> function takes one parameter of type <code>T</code> and returns a <code>MyBox</code> instance that holds the value passed in.</p>
<p>Let‚Äôs try adding the <code>main</code> function in Listing 15-7 to Listing 15-8 and changing it to use the <code>MyBox&lt;T&gt;</code> type we‚Äôve defined instead of <code>Box&lt;T&gt;</code>. The code in Listing 15-9 won‚Äôt compile because Rust doesn‚Äôt know how to dereference <code>MyBox</code>.</p>
<Listing number="15-9" file-name="src/main.rs" caption="Attempting to use `MyBox<T>` in the same way we used references and `Box<T>`">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre>
</Listing>
<p>Here‚Äôs the resulting compilation error:</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0614]: type `MyBox&lt;{integer}&gt;` cannot be dereferenced
  --&gt; src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^

For more information about this error, try `rustc --explain E0614`.
error: could not compile `deref-example` (bin "deref-example") due to 1 previous error
</code></pre>
<p>Our <code>MyBox&lt;T&gt;</code> type can‚Äôt be dereferenced because we haven‚Äôt implemented that ability on our type. To enable dereferencing with the <code>*</code> operator, we implement the <code>Deref</code> trait.</p>
<!-- Old link, do not remove -->
<p><a id="treating-a-type-like-a-reference-by-implementing-the-deref-trait"></a></p>
<h3 id="implementing-the-deref-trait"><a class="header" href="#implementing-the-deref-trait">Implementing the <code>Deref</code> Trait</a></h3>
<p>As discussed in <a href="ch10-02-traits.html#implementing-a-trait-on-a-type">‚ÄúImplementing a Trait on a Type‚Äù</a><!-- ignore --> in Chapter 10, to implement a trait, we need to provide implementations for the trait‚Äôs required methods. The <code>Deref</code> trait, provided by the standard library, requires us to implement one method named <code>deref</code> that borrows <code>self</code> and returns a reference to the inner data. Listing 15-10 contains an implementation of <code>Deref</code> to add to the definition of <code>MyBox&lt;T&gt;</code>:</p>
<Listing number="15-10" file-name="src/main.rs" caption="Implementing `Deref` on `MyBox<T>`">
<pre><pre class="playground"><code class="language-rust edition2021">use std::ops::Deref;

impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}
<span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let x = 5;
</span><span class="boring">    let y = MyBox::new(x);
</span><span class="boring">
</span><span class="boring">    assert_eq!(5, x);
</span><span class="boring">    assert_eq!(5, *y);
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>The <code>type Target = T;</code> syntax defines an associated type for the <code>Deref</code> trait to use. Associated types are a slightly different way of declaring a generic parameter, but you don‚Äôt need to worry about them for now; we‚Äôll cover them in more detail in Chapter 20.</p>
<p>We fill in the body of the <code>deref</code> method with <code>&amp;self.0</code> so <code>deref</code> returns a reference to the value we want to access with the <code>*</code> operator; recall from the <a href="ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types">‚ÄúUsing Tuple Structs without Named Fields to Create Different Types‚Äù</a><!-- ignore --> section of Chapter 5 that <code>.0</code> accesses the first value in a tuple struct. The <code>main</code> function in Listing 15-9 that calls <code>*</code> on the <code>MyBox&lt;T&gt;</code> value now compiles, and the assertions pass!</p>
<p>Without the <code>Deref</code> trait, the compiler can only dereference <code>&amp;</code> references. The <code>deref</code> method gives the compiler the ability to take a value of any type that implements <code>Deref</code> and call the <code>deref</code> method to get an <code>&amp;</code> reference that it knows how to dereference.</p>
<p>When we entered <code>*y</code> in Listing 15-9, behind the scenes Rust actually ran this code:</p>
<pre><code class="language-rust ignore">*(y.deref())</code></pre>
<p>Rust substitutes the <code>*</code> operator with a call to the <code>deref</code> method and then a plain dereference so we don‚Äôt have to think about whether or not we need to call the <code>deref</code> method. This Rust feature lets us write code that functions identically whether we have a regular reference or a type that implements <code>Deref</code>.</p>
<p>The reason the <code>deref</code> method returns a reference to a value, and that the plain dereference outside the parentheses in <code>*(y.deref())</code> is still necessary, is to do with the ownership system. If the <code>deref</code> method returned the value directly instead of a reference to the value, the value would be moved out of <code>self</code>. We don‚Äôt want to take ownership of the inner value inside <code>MyBox&lt;T&gt;</code> in this case or in most cases where we use the dereference operator.</p>
<p>Note that the <code>*</code> operator is replaced with a call to the <code>deref</code> method and then a call to the <code>*</code> operator just once, each time we use a <code>*</code> in our code. Because the substitution of the <code>*</code> operator does not recurse infinitely, we end up with data of type <code>i32</code>, which matches the <code>5</code> in <code>assert_eq!</code> in Listing 15-9.</p>
<h3 id="–ù–µ—è–≤–Ω–æ–µ-–ø—Ä–∏–≤–µ–¥–µ–Ω–∏–µ-–ø—Ä–∏-—Ä–∞–∑—ã–º–µ–Ω–æ–≤–∞–Ω–∏–∏-—Å-—Ñ—É–Ω–∫—Ü–∏—è–º–∏-–∏-–º–µ—Ç–æ–¥–∞–º–∏"><a class="header" href="#–ù–µ—è–≤–Ω–æ–µ-–ø—Ä–∏–≤–µ–¥–µ–Ω–∏–µ-–ø—Ä–∏-—Ä–∞–∑—ã–º–µ–Ω–æ–≤–∞–Ω–∏–∏-—Å-—Ñ—É–Ω–∫—Ü–∏—è–º–∏-–∏-–º–µ—Ç–æ–¥–∞–º–∏">–ù–µ—è–≤–Ω–æ–µ –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–µ –ø—Ä–∏ —Ä–∞–∑—ã–º–µ–Ω–æ–≤–∞–Ω–∏–∏ —Å —Ñ—É–Ω–∫—Ü–∏—è–º–∏ –∏ –º–µ—Ç–æ–¥–∞–º–∏</a></h3>
<p><em>Deref coercion</em> converts a reference to a type that implements the <code>Deref</code> trait into a reference to another type. For example, deref coercion can convert <code>&amp;String</code> to <code>&amp;str</code> because <code>String</code> implements the <code>Deref</code> trait such that it returns <code>&amp;str</code>. Deref coercion is a convenience Rust performs on arguments to functions and methods, and works only on types that implement the <code>Deref</code> trait. It happens automatically when we pass a reference to a particular type‚Äôs value as an argument to a function or method that doesn‚Äôt match the parameter type in the function or method definition. A sequence of calls to the <code>deref</code> method converts the type we provided into the type the parameter needs.</p>
<p>Deref coercion was added to Rust so that programmers writing function and method calls don‚Äôt need to add as many explicit references and dereferences with <code>&amp;</code> and <code>*</code>. The deref coercion feature also lets us write more code that can work for either references or smart pointers.</p>
<p>To see deref coercion in action, let‚Äôs use the <code>MyBox&lt;T&gt;</code> type we defined in Listing 15-8 as well as the implementation of <code>Deref</code> that we added in Listing 15-10. Listing 15-11 shows the definition of a function that has a string slice parameter:</p>
<Listing number="15-11" file-name="src/main.rs" caption="A `hello` function that has the parameter `name` of type `&str`">
<pre><pre class="playground"><code class="language-rust edition2021">fn hello(name: &amp;str) {
    println!("Hello, {name}!");
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p>We can call the <code>hello</code> function with a string slice as an argument, such as <code>hello("Rust");</code> for example. Deref coercion makes it possible to call <code>hello</code> with a reference to a value of type <code>MyBox&lt;String&gt;</code>, as shown in Listing 15-12:</p>
<Listing number="15-12" file-name="src/main.rs" caption="Calling `hello` with a reference to a `MyBox<String>` value, which works because of deref coercion">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!("Hello, {name}!");
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&amp;m);
}</code></pre></pre>
</Listing>
<p>Here we‚Äôre calling the <code>hello</code> function with the argument <code>&amp;m</code>, which is a reference to a <code>MyBox&lt;String&gt;</code> value. Because we implemented the <code>Deref</code> trait on <code>MyBox&lt;T&gt;</code> in Listing 15-10, Rust can turn <code>&amp;MyBox&lt;String&gt;</code> into <code>&amp;String</code> by calling <code>deref</code>. The standard library provides an implementation of <code>Deref</code> on <code>String</code> that returns a string slice, and this is in the API documentation for <code>Deref</code>. Rust calls <code>deref</code> again to turn the <code>&amp;String</code> into <code>&amp;str</code>, which matches the <code>hello</code> function‚Äôs definition.</p>
<p>If Rust didn‚Äôt implement deref coercion, we would have to write the code in Listing 15-13 instead of the code in Listing 15-12 to call <code>hello</code> with a value of type <code>&amp;MyBox&lt;String&gt;</code>.</p>
<Listing number="15-13" file-name="src/main.rs" caption="The code we would have to write if Rust didn‚Äôt have deref coercion">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!("Hello, {name}!");
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&amp;(*m)[..]);
}</code></pre></pre>
</Listing>
<p>The <code>(*m)</code> dereferences the <code>MyBox&lt;String&gt;</code> into a <code>String</code>. Then the <code>&amp;</code> and <code>[..]</code> take a string slice of the <code>String</code> that is equal to the whole string to match the signature of <code>hello</code>. This code without deref coercions is harder to read, write, and understand with all of these symbols involved. Deref coercion allows Rust to handle these conversions for us automatically.</p>
<p>When the <code>Deref</code> trait is defined for the types involved, Rust will analyze the types and use <code>Deref::deref</code> as many times as necessary to get a reference to match the parameter‚Äôs type. The number of times that <code>Deref::deref</code> needs to be inserted is resolved at compile time, so there is no runtime penalty for taking advantage of deref coercion!</p>
<h3 id="how-deref-coercion-interacts-with-mutability"><a class="header" href="#how-deref-coercion-interacts-with-mutability">How Deref Coercion Interacts with Mutability</a></h3>
<p>Similar to how you use the <code>Deref</code> trait to override the <code>*</code> operator on immutable references, you can use the <code>DerefMut</code> trait to override the <code>*</code> operator on mutable references.</p>
<p>Rust does deref coercion when it finds types and trait implementations in three cases:</p>
<ol>
<li>From <code>&amp;T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code></li>
<li>From <code>&amp;mut T</code> to <code>&amp;mut U</code> when <code>T: DerefMut&lt;Target=U&gt;</code></li>
<li>From <code>&amp;mut T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code></li>
</ol>
<p>The first two cases are the same as each other except that the second implements mutability. The first case states that if you have a <code>&amp;T</code>, and <code>T</code> implements <code>Deref</code> to some type <code>U</code>, you can get a <code>&amp;U</code> transparently. The second case states that the same deref coercion happens for mutable references.</p>
<p>The third case is trickier: Rust will also coerce a mutable reference to an immutable one. But the reverse is <em>not</em> possible: immutable references will never coerce to mutable references. Because of the borrowing rules, if you have a mutable reference, that mutable reference must be the only reference to that data (otherwise, the program wouldn‚Äôt compile). Converting one mutable reference to one immutable reference will never break the borrowing rules. Converting an immutable reference to a mutable reference would require that the initial immutable reference is the only immutable reference to that data, but the borrowing rules don‚Äôt guarantee that. Therefore, Rust can‚Äôt make the assumption that converting an immutable reference to a mutable reference is possible.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–ò—Å–ø–æ–ª–Ω–µ–Ω–∏–µ-–∫–æ–¥–∞-–ø—Ä–∏-–æ—á–∏—Å—Ç–∫–µ-—Å-–ø–æ–º–æ—â—å—é-—Ç—Ä–µ–π—Ç–∞-drop"><a class="header" href="#–ò—Å–ø–æ–ª–Ω–µ–Ω–∏–µ-–∫–æ–¥–∞-–ø—Ä–∏-–æ—á–∏—Å—Ç–∫–µ-—Å-–ø–æ–º–æ—â—å—é-—Ç—Ä–µ–π—Ç–∞-drop">–ò—Å–ø–æ–ª–Ω–µ–Ω–∏–µ –∫–æ–¥–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ —Å –ø–æ–º–æ—â—å—é —Ç—Ä–µ–π—Ç–∞ <code>Drop</code></a></h2>
<p>The second trait important to the smart pointer pattern is <code>Drop</code>, which lets you customize what happens when a value is about to go out of scope. You can provide an implementation for the <code>Drop</code> trait on any type, and that code can be used to release resources like files or network connections.</p>
<p>We‚Äôre introducing <code>Drop</code> in the context of smart pointers because the functionality of the <code>Drop</code> trait is almost always used when implementing a smart pointer. For example, when a <code>Box&lt;T&gt;</code> is dropped, it will deallocate the space on the heap that the box points to.</p>
<p>In some languages, for some types, the programmer must call code to free memory or resources every time they finish using an instance of those types. Examples include file handles, sockets, or locks. If they forget, the system might become overloaded and crash. In Rust, you can specify that a particular bit of code be run whenever a value goes out of scope, and the compiler will insert this code automatically. As a result, you don‚Äôt need to be careful about placing cleanup code everywhere in a program that an instance of a particular type is finished with‚Äîyou still won‚Äôt leak resources!</p>
<p>You specify the code to run when a value goes out of scope by implementing the <code>Drop</code> trait. The <code>Drop</code> trait requires you to implement one method named <code>drop</code> that takes a mutable reference to <code>self</code>. To see when Rust calls <code>drop</code>, let‚Äôs implement <code>drop</code> with <code>println!</code> statements for now.</p>
<p>Listing 15-14 shows a <code>CustomSmartPointer</code> struct whose only custom functionality is that it will print <code>Dropping CustomSmartPointer!</code> when the instance goes out of scope, to show when Rust runs the <code>drop</code> function.</p>
<Listing number="15-14" file-name="src/main.rs" caption="A `CustomSmartPointer` struct that implements the `Drop` trait where we would put our cleanup code">
<pre><pre class="playground"><code class="language-rust edition2021">struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from("my stuff"),
    };
    let d = CustomSmartPointer {
        data: String::from("other stuff"),
    };
    println!("CustomSmartPointers created.");
}</code></pre></pre>
</Listing>
<p>The <code>Drop</code> trait is included in the prelude, so we don‚Äôt need to bring it into scope. We implement the <code>Drop</code> trait on <code>CustomSmartPointer</code> and provide an implementation for the <code>drop</code> method that calls <code>println!</code>. The body of the <code>drop</code> function is where you would place any logic that you wanted to run when an instance of your type goes out of scope. We‚Äôre printing some text here to demonstrate visually when Rust will call <code>drop</code>.</p>
<p>In <code>main</code>, we create two instances of <code>CustomSmartPointer</code> and then print <code>CustomSmartPointers created</code>. At the end of <code>main</code>, our instances of <code>CustomSmartPointer</code> will go out of scope, and Rust will call the code we put in the <code>drop</code> method, printing our final message. Note that we didn‚Äôt need to call the <code>drop</code> method explicitly.</p>
<p>When we run this program, we‚Äôll see the following output:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.60s
     Running `target/debug/drop-example`
CustomSmartPointers created.
Dropping CustomSmartPointer with data `other stuff`!
Dropping CustomSmartPointer with data `my stuff`!
</code></pre>
<p>Rust automatically called <code>drop</code> for us when our instances went out of scope, calling the code we specified. Variables are dropped in the reverse order of their creation, so <code>d</code> was dropped before <code>c</code>. This example‚Äôs purpose is to give you a visual guide to how the <code>drop</code> method works; usually you would specify the cleanup code that your type needs to run rather than a print message.</p>
<h3 id="dropping-a-value-early-with-stdmemdrop"><a class="header" href="#dropping-a-value-early-with-stdmemdrop">Dropping a Value Early with <code>std::mem::drop</code></a></h3>
<p>Unfortunately, it‚Äôs not straightforward to disable the automatic <code>drop</code> functionality. Disabling <code>drop</code> isn‚Äôt usually necessary; the whole point of the <code>Drop</code> trait is that it‚Äôs taken care of automatically. Occasionally, however, you might want to clean up a value early. One example is when using smart pointers that manage locks: you might want to force the <code>drop</code> method that releases the lock so that other code in the same scope can acquire the lock. Rust doesn‚Äôt let you call the <code>Drop</code> trait‚Äôs <code>drop</code> method manually; instead you have to call the <code>std::mem::drop</code> function provided by the standard library if you want to force a value to be dropped before the end of its scope.</p>
<p>If we try to call the <code>Drop</code> trait‚Äôs <code>drop</code> method manually by modifying the <code>main</code> function from Listing 15-14, as shown in Listing 15-15, we‚Äôll get a compiler error:</p>
<Listing number="15-15" file-name="src/main.rs" caption="Attempting to call the `drop` method from the `Drop` trait manually to clean up early">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">struct CustomSmartPointer {
</span><span class="boring">    data: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for CustomSmartPointer {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = CustomSmartPointer {
        data: String::from("some data"),
    };
    println!("CustomSmartPointer created.");
    c.drop();
    println!("CustomSmartPointer dropped before the end of main.");
}</code></pre>
</Listing>
<p>When we try to compile this code, we‚Äôll get this error:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
error[E0040]: explicit use of destructor method
  --&gt; src/main.rs:16:7
   |
16 |     c.drop();
   |       ^^^^ explicit destructor calls not allowed
   |
help: consider using `drop` function
   |
16 |     drop(c);
   |     +++++ ~

For more information about this error, try `rustc --explain E0040`.
error: could not compile `drop-example` (bin "drop-example") due to 1 previous error
</code></pre>
<p>This error message states that we‚Äôre not allowed to explicitly call <code>drop</code>. The error message uses the term <em>destructor</em>, which is the general programming term for a function that cleans up an instance. A destructor is analogous to a <em>constructor</em>, which creates an instance. The <code>drop</code> function in Rust is one particular destructor.</p>
<p>Rust doesn‚Äôt let us call <code>drop</code> explicitly because Rust would still automatically call <code>drop</code> on the value at the end of <code>main</code>. This would cause a <em>double free</em> error because Rust would be trying to clean up the same value twice.</p>
<p>We can‚Äôt disable the automatic insertion of <code>drop</code> when a value goes out of scope, and we can‚Äôt call the <code>drop</code> method explicitly. So, if we need to force a value to be cleaned up early, we use the <code>std::mem::drop</code> function.</p>
<p>The <code>std::mem::drop</code> function is different from the <code>drop</code> method in the <code>Drop</code> trait. We call it by passing as an argument the value we want to force drop. The function is in the prelude, so we can modify <code>main</code> in Listing 15-15 to call the <code>drop</code> function, as shown in Listing 15-16:</p>
<Listing number="15-16" file-name="src/main.rs" caption="Calling `std::mem::drop` to explicitly drop a value before it goes out of scope">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct CustomSmartPointer {
</span><span class="boring">    data: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for CustomSmartPointer {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = CustomSmartPointer {
        data: String::from("some data"),
    };
    println!("CustomSmartPointer created.");
    drop(c);
    println!("CustomSmartPointer dropped before the end of main.");
}</code></pre></pre>
</Listing>
<p>Running this code will print the following:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/drop-example`
CustomSmartPointer created.
Dropping CustomSmartPointer with data `some data`!
CustomSmartPointer dropped before the end of main.
</code></pre>
<p>The text <code>Dropping CustomSmartPointer with data `some data`!</code> is printed between the <code>CustomSmartPointer created.</code> and <code>CustomSmartPointer dropped before the end of main.</code> text, showing that the <code>drop</code> method code is called to drop <code>c</code> at that point.</p>
<p>You can use code specified in a <code>Drop</code> trait implementation in many ways to make cleanup convenient and safe: for instance, you could use it to create your own memory allocator! With the <code>Drop</code> trait and Rust‚Äôs ownership system, you don‚Äôt have to remember to clean up because Rust does it automatically.</p>
<p>You also don‚Äôt have to worry about problems resulting from accidentally cleaning up values still in use: the ownership system that makes sure references are always valid also ensures that <code>drop</code> gets called only once when the value is no longer being used.</p>
<p>Now that we‚Äôve examined <code>Box&lt;T&gt;</code> and some of the characteristics of smart pointers, let‚Äôs look at a few other smart pointers defined in the standard library.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="rct--—É–º–Ω—ã–π-—É–∫–∞–∑–∞—Ç–µ–ª—å-—Å-–ø–æ–¥—Å—á—ë—Ç–æ–º-—Å—Å—ã–ª–æ–∫"><a class="header" href="#rct--—É–º–Ω—ã–π-—É–∫–∞–∑–∞—Ç–µ–ª—å-—Å-–ø–æ–¥—Å—á—ë—Ç–æ–º-—Å—Å—ã–ª–æ–∫"><code>Rc&lt;T&gt;</code> ‚Äî —É–º–Ω—ã–π —É–∫–∞–∑–∞—Ç–µ–ª—å —Å –ø–æ–¥—Å—á—ë—Ç–æ–º —Å—Å—ã–ª–æ–∫</a></h2>
<p>In the majority of cases, ownership is clear: you know exactly which variable owns a given value. However, there are cases when a single value might have multiple owners. For example, in graph data structures, multiple edges might point to the same node, and that node is conceptually owned by all of the edges that point to it. A node shouldn‚Äôt be cleaned up unless it doesn‚Äôt have any edges pointing to it and so has no owners.</p>
<p>You have to enable multiple ownership explicitly by using the Rust type <code>Rc&lt;T&gt;</code>, which is an abbreviation for <em>reference counting</em>. The <code>Rc&lt;T&gt;</code> type keeps track of the number of references to a value to determine whether or not the value is still in use. If there are zero references to a value, the value can be cleaned up without any references becoming invalid.</p>
<p>Imagine <code>Rc&lt;T&gt;</code> as a TV in a family room. When one person enters to watch TV, they turn it on. Others can come into the room and watch the TV. When the last person leaves the room, they turn off the TV because it‚Äôs no longer being used. If someone turns off the TV while others are still watching it, there would be uproar from the remaining TV watchers!</p>
<p>We use the <code>Rc&lt;T&gt;</code> type when we want to allocate some data on the heap for multiple parts of our program to read and we can‚Äôt determine at compile time which part will finish using the data last. If we knew which part would finish last, we could just make that part the data‚Äôs owner, and the normal ownership rules enforced at compile time would take effect.</p>
<p>Note that <code>Rc&lt;T&gt;</code> is only for use in single-threaded scenarios. When we discuss concurrency in Chapter 16, we‚Äôll cover how to do reference counting in multithreaded programs.</p>
<h3 id="using-rct-to-share-data"><a class="header" href="#using-rct-to-share-data">Using <code>Rc&lt;T&gt;</code> to Share Data</a></h3>
<p>Let‚Äôs return to our cons list example in Listing 15-5. Recall that we defined it using <code>Box&lt;T&gt;</code>. This time, we‚Äôll create two lists that both share ownership of a third list. Conceptually, this looks similar to Figure 15-3:</p>
<img alt="Two lists that share ownership of a third list" src="img/trpl15-03.svg" class="center" />
<p><span class="caption">Figure 15-3: Two lists, <code>b</code> and <code>c</code>, sharing ownership of a third list, <code>a</code></span></p>
<p>We‚Äôll create list <code>a</code> that contains 5 and then 10. Then we‚Äôll make two more lists: <code>b</code> that starts with 3 and <code>c</code> that starts with 4. Both <code>b</code> and <code>c</code> lists will then continue on to the first <code>a</code> list containing 5 and 10. In other words, both lists will share the first list containing 5 and 10.</p>
<p>Trying to implement this scenario using our definition of <code>List</code> with <code>Box&lt;T&gt;</code> won‚Äôt work, as shown in Listing 15-17:</p>
<Listing number="15-17" file-name="src/main.rs" caption="Demonstrating we‚Äôre not allowed to have two lists using `Box<T>` that try to share ownership of a third list">
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}</code></pre>
</Listing>
<p>When we compile this code, we get this error:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0382]: use of moved value: `a`
  --&gt; src/main.rs:11:30
   |
9  |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
   |         - move occurs because `a` has type `List`, which does not implement the `Copy` trait
10 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
11 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `cons-list` (bin "cons-list") due to 1 previous error
</code></pre>
<p>The <code>Cons</code> variants own the data they hold, so when we create the <code>b</code> list, <code>a</code> is moved into <code>b</code> and <code>b</code> owns <code>a</code>. Then, when we try to use <code>a</code> again when creating <code>c</code>, we‚Äôre not allowed to because <code>a</code> has been moved.</p>
<p>We could change the definition of <code>Cons</code> to hold references instead, but then we would have to specify lifetime parameters. By specifying lifetime parameters, we would be specifying that every element in the list will live at least as long as the entire list. This is the case for the elements and lists in Listing 15-17, but not in every scenario.</p>
<p>Instead, we‚Äôll change our definition of <code>List</code> to use <code>Rc&lt;T&gt;</code> in place of <code>Box&lt;T&gt;</code>, as shown in Listing 15-18. Each <code>Cons</code> variant will now hold a value and an <code>Rc&lt;T&gt;</code> pointing to a <code>List</code>. When we create <code>b</code>, instead of taking ownership of <code>a</code>, we‚Äôll clone the <code>Rc&lt;List&gt;</code> that <code>a</code> is holding, thereby increasing the number of references from one to two and letting <code>a</code> and <code>b</code> share ownership of the data in that <code>Rc&lt;List&gt;</code>. We‚Äôll also clone <code>a</code> when creating <code>c</code>, increasing the number of references from two to three. Every time we call <code>Rc::clone</code>, the reference count to the data within the <code>Rc&lt;List&gt;</code> will increase, and the data won‚Äôt be cleaned up unless there are zero references to it.</p>
<Listing number="15-18" file-name="src/main.rs" caption="A definition of `List` that uses `Rc<T>`">
<pre><pre class="playground"><code class="language-rust edition2021">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));
    let c = Cons(4, Rc::clone(&amp;a));
}</code></pre></pre>
</Listing>
<p>We need to add a <code>use</code> statement to bring <code>Rc&lt;T&gt;</code> into scope because it‚Äôs not in the prelude. In <code>main</code>, we create the list holding 5 and 10 and store it in a new <code>Rc&lt;List&gt;</code> in <code>a</code>. Then when we create <code>b</code> and <code>c</code>, we call the <code>Rc::clone</code> function and pass a reference to the <code>Rc&lt;List&gt;</code> in <code>a</code> as an argument.</p>
<p>We could have called <code>a.clone()</code> rather than <code>Rc::clone(&amp;a)</code>, but Rust‚Äôs convention is to use <code>Rc::clone</code> in this case. The implementation of <code>Rc::clone</code> doesn‚Äôt make a deep copy of all the data like most types‚Äô implementations of <code>clone</code> do. The call to <code>Rc::clone</code> only increments the reference count, which doesn‚Äôt take much time. Deep copies of data can take a lot of time. By using <code>Rc::clone</code> for reference counting, we can visually distinguish between the deep-copy kinds of clones and the kinds of clones that increase the reference count. When looking for performance problems in the code, we only need to consider the deep-copy clones and can disregard calls to <code>Rc::clone</code>.</p>
<h3 id="cloning-an-rct-increases-the-reference-count"><a class="header" href="#cloning-an-rct-increases-the-reference-count">Cloning an <code>Rc&lt;T&gt;</code> Increases the Reference Count</a></h3>
<p>Let‚Äôs change our working example in Listing 15-18 so we can see the reference counts changing as we create and drop references to the <code>Rc&lt;List&gt;</code> in <code>a</code>.</p>
<p>In Listing 15-19, we‚Äôll change <code>main</code> so it has an inner scope around list <code>c</code>; then we can see how the reference count changes when <code>c</code> goes out of scope.</p>
<Listing number="15-19" file-name="src/main.rs" caption="Printing the reference count">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, Rc&lt;List&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("count after creating a = {}", Rc::strong_count(&amp;a));
    let b = Cons(3, Rc::clone(&amp;a));
    println!("count after creating b = {}", Rc::strong_count(&amp;a));
    {
        let c = Cons(4, Rc::clone(&amp;a));
        println!("count after creating c = {}", Rc::strong_count(&amp;a));
    }
    println!("count after c goes out of scope = {}", Rc::strong_count(&amp;a));
}</code></pre></pre>
</Listing>
<p>At each point in the program where the reference count changes, we print the reference count, which we get by calling the <code>Rc::strong_count</code> function. This function is named <code>strong_count</code> rather than <code>count</code> because the <code>Rc&lt;T&gt;</code> type also has a <code>weak_count</code>; we‚Äôll see what <code>weak_count</code> is used for in <a href="ch15-06-reference-cycles.html#preventing-reference-cycles-turning-an-rct-into-a-weakt">‚ÄúPreventing Reference Cycles: Turning an <code>Rc&lt;T&gt;</code> into a <code>Weak&lt;T&gt;</code>‚Äù</a><!-- ignore -->.</p>
<p>This code prints the following:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.45s
     Running `target/debug/cons-list`
count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
</code></pre>
<p>We can see that the <code>Rc&lt;List&gt;</code> in <code>a</code> has an initial reference count of 1; then each time we call <code>clone</code>, the count goes up by 1. When <code>c</code> goes out of scope, the count goes down by 1. We don‚Äôt have to call a function to decrease the reference count like we have to call <code>Rc::clone</code> to increase the reference count: the implementation of the <code>Drop</code> trait decreases the reference count automatically when an <code>Rc&lt;T&gt;</code> value goes out of scope.</p>
<p>What we can‚Äôt see in this example is that when <code>b</code> and then <code>a</code> go out of scope at the end of <code>main</code>, the count is then 0, and the <code>Rc&lt;List&gt;</code> is cleaned up completely. Using <code>Rc&lt;T&gt;</code> allows a single value to have multiple owners, and the count ensures that the value remains valid as long as any of the owners still exist.</p>
<p>Via immutable references, <code>Rc&lt;T&gt;</code> allows you to share data between multiple parts of your program for reading only. If <code>Rc&lt;T&gt;</code> allowed you to have multiple mutable references too, you might violate one of the borrowing rules discussed in Chapter 4: multiple mutable borrows to the same place can cause data races and inconsistencies. But being able to mutate data is very useful! In the next section, we‚Äôll discuss the interior mutability pattern and the <code>RefCell&lt;T&gt;</code> type that you can use in conjunction with an <code>Rc&lt;T&gt;</code> to work with this immutability restriction.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="refcellt-–∏-—à–∞–±–ª–æ–Ω-–≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–π-–∏–∑–º–µ–Ω—è–µ–º–æ—Å—Ç–∏"><a class="header" href="#refcellt-–∏-—à–∞–±–ª–æ–Ω-–≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–π-–∏–∑–º–µ–Ω—è–µ–º–æ—Å—Ç–∏"><code>RefCell&lt;T&gt;</code> –∏ —à–∞–±–ª–æ–Ω –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–π –∏–∑–º–µ–Ω—è–µ–º–æ—Å—Ç–∏</a></h2>
<p><em>Interior mutability</em> is a design pattern in Rust that allows you to mutate data even when there are immutable references to that data; normally, this action is disallowed by the borrowing rules. To mutate data, the pattern uses <code>unsafe</code> code inside a data structure to bend Rust‚Äôs usual rules that govern mutation and borrowing. Unsafe code indicates to the compiler that we‚Äôre checking the rules manually instead of relying on the compiler to check them for us; we will discuss unsafe code more in Chapter 20.</p>
<p>We can use types that use the interior mutability pattern only when we can ensure that the borrowing rules will be followed at runtime, even though the compiler can‚Äôt guarantee that. The <code>unsafe</code> code involved is then wrapped in a safe API, and the outer type is still immutable.</p>
<p>Let‚Äôs explore this concept by looking at the <code>RefCell&lt;T&gt;</code> type that follows the interior mutability pattern.</p>
<h3 id="enforcing-borrowing-rules-at-runtime-with-refcellt"><a class="header" href="#enforcing-borrowing-rules-at-runtime-with-refcellt">Enforcing Borrowing Rules at Runtime with <code>RefCell&lt;T&gt;</code></a></h3>
<p>Unlike <code>Rc&lt;T&gt;</code>, the <code>RefCell&lt;T&gt;</code> type represents single ownership over the data it holds. So, what makes <code>RefCell&lt;T&gt;</code> different from a type like <code>Box&lt;T&gt;</code>? Recall the borrowing rules you learned in Chapter 4:</p>
<ul>
<li>At any given time, you can have <em>either</em> (but not both) one mutable reference or any number of immutable references.</li>
<li>–ó–Ω–∞—á–µ–Ω–∏–µ –¥–æ–ª–∂–Ω–æ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞—Ç—å –¥–æ–ª—å—à–µ, —á–µ–º –ª—é–±–∞—è —Å—Å—ã–ª–∫–∞, –∫–æ—Ç–æ—Ä–∞—è –Ω–∞ –Ω–µ–≥–æ —É–∫–∞–∑—ã–≤–∞–µ—Ç.</li>
</ul>
<p>With references and <code>Box&lt;T&gt;</code>, the borrowing rules‚Äô invariants are enforced at compile time. With <code>RefCell&lt;T&gt;</code>, these invariants are enforced <em>at runtime</em>. With references, if you break these rules, you‚Äôll get a compiler error. With <code>RefCell&lt;T&gt;</code>, if you break these rules, your program will panic and exit.</p>
<p>The advantages of checking the borrowing rules at compile time are that errors will be caught sooner in the development process, and there is no impact on runtime performance because all the analysis is completed beforehand. For those reasons, checking the borrowing rules at compile time is the best choice in the majority of cases, which is why this is Rust‚Äôs default.</p>
<p>The advantage of checking the borrowing rules at runtime instead is that certain memory-safe scenarios are then allowed, where they would‚Äôve been disallowed by the compile-time checks. Static analysis, like the Rust compiler, is inherently conservative. Some properties of code are impossible to detect by analyzing the code: the most famous example is the Halting Problem, which is beyond the scope of this book but is an interesting topic to research.</p>
<p>Because some analysis is impossible, if the Rust compiler can‚Äôt be sure the code complies with the ownership rules, it might reject a correct program; in this way, it‚Äôs conservative. If Rust accepted an incorrect program, users wouldn‚Äôt be able to trust in the guarantees Rust makes. However, if Rust rejects a correct program, the programmer will be inconvenienced, but nothing catastrophic can occur. The <code>RefCell&lt;T&gt;</code> type is useful when you‚Äôre sure your code follows the borrowing rules but the compiler is unable to understand and guarantee that.</p>
<p>Similar to <code>Rc&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code> is only for use in single-threaded scenarios and will give you a compile-time error if you try using it in a multithreaded context. We‚Äôll talk about how to get the functionality of <code>RefCell&lt;T&gt;</code> in a multithreaded program in Chapter 16.</p>
<p>Here is a recap of the reasons to choose <code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code>, or <code>RefCell&lt;T&gt;</code>:</p>
<ul>
<li><code>Rc&lt;T&gt;</code> enables multiple owners of the same data; <code>Box&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code> have single owners.</li>
<li><code>Box&lt;T&gt;</code> allows immutable or mutable borrows checked at compile time; <code>Rc&lt;T&gt;</code> allows only immutable borrows checked at compile time; <code>RefCell&lt;T&gt;</code> allows immutable or mutable borrows checked at runtime.</li>
<li>Because <code>RefCell&lt;T&gt;</code> allows mutable borrows checked at runtime, you can mutate the value inside the <code>RefCell&lt;T&gt;</code> even when the <code>RefCell&lt;T&gt;</code> is immutable.</li>
</ul>
<p>Mutating the value inside an immutable value is the <em>interior mutability</em> pattern. Let‚Äôs look at a situation in which interior mutability is useful and examine how it‚Äôs possible.</p>
<h3 id="interior-mutability-a-mutable-borrow-to-an-immutable-value"><a class="header" href="#interior-mutability-a-mutable-borrow-to-an-immutable-value">Interior Mutability: A Mutable Borrow to an Immutable Value</a></h3>
<p>A consequence of the borrowing rules is that when you have an immutable value, you can‚Äôt borrow it mutably. For example, this code won‚Äôt compile:</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    let y = &amp;mut x;
}</code></pre>
<p>If you tried to compile this code, you‚Äôd get the following error:</p>
<pre><code class="language-console">$ cargo run
   Compiling borrowing v0.1.0 (file:///projects/borrowing)
error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
 --&gt; src/main.rs:3:13
  |
3 |     let y = &amp;mut x;
  |             ^^^^^^ cannot borrow as mutable
  |
help: consider changing this to be mutable
  |
2 |     let mut x = 5;
  |         +++

For more information about this error, try `rustc --explain E0596`.
error: could not compile `borrowing` (bin "borrowing") due to 1 previous error
</code></pre>
<p>However, there are situations in which it would be useful for a value to mutate itself in its methods but appear immutable to other code. Code outside the value‚Äôs methods would not be able to mutate the value. Using <code>RefCell&lt;T&gt;</code> is one way to get the ability to have interior mutability, but <code>RefCell&lt;T&gt;</code> doesn‚Äôt get around the borrowing rules completely: the borrow checker in the compiler allows this interior mutability, and the borrowing rules are checked at runtime instead. If you violate the rules, you‚Äôll get a <code>panic!</code> instead of a compiler error.</p>
<p>Let‚Äôs work through a practical example where we can use <code>RefCell&lt;T&gt;</code> to mutate an immutable value and see why that is useful.</p>
<h4 id="a-use-case-for-interior-mutability-mock-objects"><a class="header" href="#a-use-case-for-interior-mutability-mock-objects">A Use Case for Interior Mutability: Mock Objects</a></h4>
<p>Sometimes during testing a programmer will use a type in place of another type, in order to observe particular behavior and assert it‚Äôs implemented correctly. This placeholder type is called a <em>test double</em>. Think of it in the sense of a ‚Äústunt double‚Äù in filmmaking, where a person steps in and substitutes for an actor to do a particular tricky scene. Test doubles stand in for other types when we‚Äôre running tests. <em>Mock objects</em> are specific types of test doubles that record what happens during a test so you can assert that the correct actions took place.</p>
<p>Rust doesn‚Äôt have objects in the same sense as other languages have objects, and Rust doesn‚Äôt have mock object functionality built into the standard library as some other languages do. However, you can definitely create a struct that will serve the same purposes as a mock object.</p>
<p>Here‚Äôs the scenario we‚Äôll test: we‚Äôll create a library that tracks a value against a maximum value and sends messages based on how close to the maximum value the current value is. This library could be used to keep track of a user‚Äôs quota for the number of API calls they‚Äôre allowed to make, for example.</p>
<p>Our library will only provide the functionality of tracking how close to the maximum a value is and what the messages should be at what times. Applications that use our library will be expected to provide the mechanism for sending the messages: the application could put a message in the application, send an email, send a text message, or something else. The library doesn‚Äôt need to know that detail. All it needs is something that implements a trait we‚Äôll provide called <code>Messenger</code>. Listing 15-20 shows the library code:</p>
<Listing number="15-20" file-name="src/lib.rs" caption="A library to keep track of how close a value is to a maximum value and warn when the value is at certain levels">
<pre><code class="language-rust noplayground">pub trait Messenger {
    fn send(&amp;self, msg: &amp;str);
}

pub struct LimitTracker&lt;'a, T: Messenger&gt; {
    messenger: &amp;'a T,
    value: usize,
    max: usize,
}

impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
where
    T: Messenger,
{
    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&amp;mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max &gt;= 1.0 {
            self.messenger.send("Error: You are over your quota!");
        } else if percentage_of_max &gt;= 0.9 {
            self.messenger
                .send("Urgent warning: You've used up over 90% of your quota!");
        } else if percentage_of_max &gt;= 0.75 {
            self.messenger
                .send("Warning: You've used up over 75% of your quota!");
        }
    }
}</code></pre>
</Listing>
<p>One important part of this code is that the <code>Messenger</code> trait has one method called <code>send</code> that takes an immutable reference to <code>self</code> and the text of the message. This trait is the interface our mock object needs to implement so that the mock can be used in the same way a real object is. The other important part is that we want to test the behavior of the <code>set_value</code> method on the <code>LimitTracker</code>. We can change what we pass in for the <code>value</code> parameter, but <code>set_value</code> doesn‚Äôt return anything for us to make assertions on. We want to be able to say that if we create a <code>LimitTracker</code> with something that implements the <code>Messenger</code> trait and a particular value for <code>max</code>, when we pass different numbers for <code>value</code>, the messenger is told to send the appropriate messages.</p>
<p>We need a mock object that, instead of sending an email or text message when we call <code>send</code>, will only keep track of the messages it‚Äôs told to send. We can create a new instance of the mock object, create a <code>LimitTracker</code> that uses the mock object, call the <code>set_value</code> method on <code>LimitTracker</code>, and then check that the mock object has the messages we expect. Listing 15-21 shows an attempt to implement a mock object to do just that, but the borrow checker won‚Äôt allow it:</p>
<Listing number="15-21" file-name="src/lib.rs" caption="An attempt to implement a `MockMessenger` that isn‚Äôt allowed by the borrow checker">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("Error: You are over your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Urgent warning: You've used up over 90% of your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Warning: You've used up over 75% of your quota!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec&lt;String&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: vec![],
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}</code></pre>
</Listing>
<p>This test code defines a <code>MockMessenger</code> struct that has a <code>sent_messages</code> field with a <code>Vec</code> of <code>String</code> values to keep track of the messages it‚Äôs told to send. We also define an associated function <code>new</code> to make it convenient to create new <code>MockMessenger</code> values that start with an empty list of messages. We then implement the <code>Messenger</code> trait for <code>MockMessenger</code> so we can give a <code>MockMessenger</code> to a <code>LimitTracker</code>. In the definition of the <code>send</code> method, we take the message passed in as a parameter and store it in the <code>MockMessenger</code> list of <code>sent_messages</code>.</p>
<p>In the test, we‚Äôre testing what happens when the <code>LimitTracker</code> is told to set <code>value</code> to something that is more than 75 percent of the <code>max</code> value. First, we create a new <code>MockMessenger</code>, which will start with an empty list of messages. Then we create a new <code>LimitTracker</code> and give it a reference to the new <code>MockMessenger</code> and a <code>max</code> value of 100. We call the <code>set_value</code> method on the <code>LimitTracker</code> with a value of 80, which is more than 75 percent of 100. Then we assert that the list of messages that the <code>MockMessenger</code> is keeping track of should now have one message in it.</p>
<p>However, there‚Äôs one problem with this test, as shown here:</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
error[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a `&amp;` reference
  --&gt; src/lib.rs:58:13
   |
58 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable
   |
help: consider changing this to be a mutable reference in the `impl` method and the `trait` definition
   |
2  ~     fn send(&amp;mut self, msg: &amp;str);
3  | }
...
56 |     impl Messenger for MockMessenger {
57 ~         fn send(&amp;mut self, message: &amp;str) {
   |

For more information about this error, try `rustc --explain E0596`.
error: could not compile `limit-tracker` (lib test) due to 1 previous error
</code></pre>
<p>We can‚Äôt modify the <code>MockMessenger</code> to keep track of the messages, because the <code>send</code> method takes an immutable reference to <code>self</code>. We also can‚Äôt take the suggestion from the error text to use <code>&amp;mut self</code> in both the <code>impl</code> method and the <code>trait</code> definition. We do not want to change the <code>Messenger</code> trait solely for the sake of testing. Instead, we need to find a way to make our test code work correctly with our existing design.</p>
<p>This is a situation in which interior mutability can help! We‚Äôll store the <code>sent_messages</code> within a <code>RefCell&lt;T&gt;</code>, and then the <code>send</code> method will be able to modify <code>sent_messages</code> to store the messages we‚Äôve seen. Listing 15-22 shows what that looks like:</p>
<Listing number="15-22" file-name="src/lib.rs" caption="Using `RefCell<T>` to mutate an inner value while the outer value is considered immutable">
<pre><code class="language-rust noplayground"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("Error: You are over your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Urgent warning: You've used up over 90% of your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Warning: You've used up over 75% of your quota!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: RefCell::new(vec![]),
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span>
        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}</code></pre>
</Listing>
<p>The <code>sent_messages</code> field is now of type <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> instead of <code>Vec&lt;String&gt;</code>. In the <code>new</code> function, we create a new <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> instance around the empty vector.</p>
<p>For the implementation of the <code>send</code> method, the first parameter is still an immutable borrow of <code>self</code>, which matches the trait definition. We call <code>borrow_mut</code> on the <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> in <code>self.sent_messages</code> to get a mutable reference to the value inside the <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>, which is the vector. Then we can call <code>push</code> on the mutable reference to the vector to keep track of the messages sent during the test.</p>
<p>The last change we have to make is in the assertion: to see how many items are in the inner vector, we call <code>borrow</code> on the <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> to get an immutable reference to the vector.</p>
<p>Now that you‚Äôve seen how to use <code>RefCell&lt;T&gt;</code>, let‚Äôs dig into how it works!</p>
<h4 id="keeping-track-of-borrows-at-runtime-with-refcellt"><a class="header" href="#keeping-track-of-borrows-at-runtime-with-refcellt">Keeping Track of Borrows at Runtime with <code>RefCell&lt;T&gt;</code></a></h4>
<p>When creating immutable and mutable references, we use the <code>&amp;</code> and <code>&amp;mut</code> syntax, respectively. With <code>RefCell&lt;T&gt;</code>, we use the <code>borrow</code> and <code>borrow_mut</code> methods, which are part of the safe API that belongs to <code>RefCell&lt;T&gt;</code>. The <code>borrow</code> method returns the smart pointer type <code>Ref&lt;T&gt;</code>, and <code>borrow_mut</code> returns the smart pointer type <code>RefMut&lt;T&gt;</code>. Both types implement <code>Deref</code>, so we can treat them like regular references.</p>
<p>The <code>RefCell&lt;T&gt;</code> keeps track of how many <code>Ref&lt;T&gt;</code> and <code>RefMut&lt;T&gt;</code> smart pointers are currently active. Every time we call <code>borrow</code>, the <code>RefCell&lt;T&gt;</code> increases its count of how many immutable borrows are active. When a <code>Ref&lt;T&gt;</code> value goes out of scope, the count of immutable borrows goes down by one. Just like the compile-time borrowing rules, <code>RefCell&lt;T&gt;</code> lets us have many immutable borrows or one mutable borrow at any point in time.</p>
<p>If we try to violate these rules, rather than getting a compiler error as we would with references, the implementation of <code>RefCell&lt;T&gt;</code> will panic at runtime. Listing 15-23 shows a modification of the implementation of <code>send</code> in Listing 15-22. We‚Äôre deliberately trying to create two mutable borrows active for the same scope to illustrate that <code>RefCell&lt;T&gt;</code> prevents us from doing this at runtime.</p>
<Listing number="15-23" file-name="src/lib.rs" caption="Creating two mutable references in the same scope to see that `RefCell<T>` will panic">
<pre><code class="language-rust ignore panics"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("Error: You are over your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Urgent warning: You've used up over 90% of your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Warning: You've used up over 75% of your quota!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">    struct MockMessenger {
</span><span class="boring">        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl MockMessenger {
</span><span class="boring">        fn new() -&gt; MockMessenger {
</span><span class="boring">            MockMessenger {
</span><span class="boring">                sent_messages: RefCell::new(vec![]),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            let mut one_borrow = self.sent_messages.borrow_mut();
            let mut two_borrow = self.sent_messages.borrow_mut();

            one_borrow.push(String::from(message));
            two_borrow.push(String::from(message));
        }
    }
<span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_sends_an_over_75_percent_warning_message() {
</span><span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span><span class="boring">
</span><span class="boring">        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>We create a variable <code>one_borrow</code> for the <code>RefMut&lt;T&gt;</code> smart pointer returned from <code>borrow_mut</code>. Then we create another mutable borrow in the same way in the variable <code>two_borrow</code>. This makes two mutable references in the same scope, which isn‚Äôt allowed. When we run the tests for our library, the code in Listing 15-23 will compile without any errors, but the test will fail:</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/limit_tracker-e599811fa246dbde)

running 1 test
test tests::it_sends_an_over_75_percent_warning_message ... FAILED

failures:

---- tests::it_sends_an_over_75_percent_warning_message stdout ----
thread 'tests::it_sends_an_over_75_percent_warning_message' panicked at src/lib.rs:60:53:
already borrowed: BorrowMutError
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_sends_an_over_75_percent_warning_message

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Notice that the code panicked with the message <code>already borrowed: BorrowMutError</code>. This is how <code>RefCell&lt;T&gt;</code> handles violations of the borrowing rules at runtime.</p>
<p>Choosing to catch borrowing errors at runtime rather than compile time, as we‚Äôve done here, means you‚Äôd potentially be finding mistakes in your code later in the development process: possibly not until your code was deployed to production. Also, your code would incur a small runtime performance penalty as a result of keeping track of the borrows at runtime rather than compile time. However, using <code>RefCell&lt;T&gt;</code> makes it possible to write a mock object that can modify itself to keep track of the messages it has seen while you‚Äôre using it in a context where only immutable values are allowed. You can use <code>RefCell&lt;T&gt;</code> despite its trade-offs to get more functionality than regular references provide.</p>
<h3 id="having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt"><a class="header" href="#having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt">Having Multiple Owners of Mutable Data by Combining <code>Rc&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code></a></h3>
<p>A common way to use <code>RefCell&lt;T&gt;</code> is in combination with <code>Rc&lt;T&gt;</code>. Recall that <code>Rc&lt;T&gt;</code> lets you have multiple owners of some data, but it only gives immutable access to that data. If you have an <code>Rc&lt;T&gt;</code> that holds a <code>RefCell&lt;T&gt;</code>, you can get a value that can have multiple owners <em>and</em> that you can mutate!</p>
<p>For example, recall the cons list example in Listing 15-18 where we used <code>Rc&lt;T&gt;</code> to allow multiple lists to share ownership of another list. Because <code>Rc&lt;T&gt;</code> holds only immutable values, we can‚Äôt change any of the values in the list once we‚Äôve created them. Let‚Äôs add in <code>RefCell&lt;T&gt;</code> to gain the ability to change the values in the lists. Listing 15-24 shows that by using a <code>RefCell&lt;T&gt;</code> in the <code>Cons</code> definition, we can modify the value stored in all the lists:</p>
<Listing number="15-24" file-name="src/main.rs" caption="Using `Rc<RefCell<i32>>` to create a `List` that we can mutate">
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a));

    *value.borrow_mut() += 10;

    println!("a after = {a:?}");
    println!("b after = {b:?}");
    println!("c after = {c:?}");
}</code></pre></pre>
</Listing>
<p>We create a value that is an instance of <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> and store it in a variable named <code>value</code> so we can access it directly later. Then we create a <code>List</code> in <code>a</code> with a <code>Cons</code> variant that holds <code>value</code>. We need to clone <code>value</code> so both <code>a</code> and <code>value</code> have ownership of the inner <code>5</code> value rather than transferring ownership from <code>value</code> to <code>a</code> or having <code>a</code> borrow from <code>value</code>.</p>
<p>We wrap the list <code>a</code> in an <code>Rc&lt;T&gt;</code> so that when we create lists <code>b</code> and <code>c</code>, they can both refer to <code>a</code>, which is what we did in Listing 15-18.</p>
<p>After we‚Äôve created the lists in <code>a</code>, <code>b</code>, and <code>c</code>, we want to add 10 to the value in <code>value</code>. We do this by calling <code>borrow_mut</code> on <code>value</code>, which uses the automatic dereferencing feature we discussed in Chapter 5 (see <a href="ch05-03-method-syntax.html#wheres-the---operator">‚ÄúWhere‚Äôs the <code>-&gt;</code> Operator?‚Äù</a><!-- ignore -->) to dereference the <code>Rc&lt;T&gt;</code> to the inner <code>RefCell&lt;T&gt;</code> value. The <code>borrow_mut</code> method returns a <code>RefMut&lt;T&gt;</code> smart pointer, and we use the dereference operator on it and change the inner value.</p>
<p>When we print <code>a</code>, <code>b</code>, and <code>c</code>, we can see that they all have the modified value of 15 rather than 5:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.63s
     Running `target/debug/cons-list`
a after = Cons(RefCell { value: 15 }, Nil)
b after = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))
c after = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<p>This technique is pretty neat! By using <code>RefCell&lt;T&gt;</code>, we have an outwardly immutable <code>List</code> value. But we can use the methods on <code>RefCell&lt;T&gt;</code> that provide access to its interior mutability so we can modify our data when we need to. The runtime checks of the borrowing rules protect us from data races, and it‚Äôs sometimes worth trading a bit of speed for this flexibility in our data structures. Note that <code>RefCell&lt;T&gt;</code> does not work for multithreaded code! <code>Mutex&lt;T&gt;</code> is the thread-safe version of <code>RefCell&lt;T&gt;</code> and we‚Äôll discuss <code>Mutex&lt;T&gt;</code> in Chapter 16.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–ó–∞—Ü–∏–∫–ª–∏–≤–∞–Ω–∏–µ-—Å—Å—ã–ª–æ–∫-–º–æ–∂–µ—Ç-–≤—ã–∑—ã–≤–∞—Ç—å-—É—Ç–µ—á–∫–∏-–ø–∞–º—è—Ç–∏"><a class="header" href="#–ó–∞—Ü–∏–∫–ª–∏–≤–∞–Ω–∏–µ-—Å—Å—ã–ª–æ–∫-–º–æ–∂–µ—Ç-–≤—ã–∑—ã–≤–∞—Ç—å-—É—Ç–µ—á–∫–∏-–ø–∞–º—è—Ç–∏">–ó–∞—Ü–∏–∫–ª–∏–≤–∞–Ω–∏–µ —Å—Å—ã–ª–æ–∫ –º–æ–∂–µ—Ç –≤—ã–∑—ã–≤–∞—Ç—å —É—Ç–µ—á–∫–∏ –ø–∞–º—è—Ç–∏</a></h2>
<p>Rust‚Äôs memory safety guarantees make it difficult, but not impossible, to accidentally create memory that is never cleaned up (known as a <em>memory leak</em>). Preventing memory leaks entirely is not one of Rust‚Äôs guarantees, meaning memory leaks are memory safe in Rust. We can see that Rust allows memory leaks by using <code>Rc&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code>: it‚Äôs possible to create references where items refer to each other in a cycle. This creates memory leaks because the reference count of each item in the cycle will never reach 0, and the values will never be dropped.</p>
<h3 id="creating-a-reference-cycle"><a class="header" href="#creating-a-reference-cycle">Creating a Reference Cycle</a></h3>
<p>Let‚Äôs look at how a reference cycle might happen and how to prevent it, starting with the definition of the <code>List</code> enum and a <code>tail</code> method in Listing 15-25:</p>
<Listing number="15-25" file-name="src/main.rs" caption="A cons list definition that holds a `RefCell<T>` so we can modify what a `Cons` variant is referring to">
<pre><pre class="playground"><code class="language-rust edition2021">use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match self {
            Cons(_, item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}

fn main() {}</code></pre></pre>
</Listing>
<p>We‚Äôre using another variation of the <code>List</code> definition from Listing 15-5. The second element in the <code>Cons</code> variant is now <code>RefCell&lt;Rc&lt;List&gt;&gt;</code>, meaning that instead of having the ability to modify the <code>i32</code> value as we did in Listing 15-24, we want to modify the <code>List</code> value a <code>Cons</code> variant is pointing to. We‚Äôre also adding a <code>tail</code> method to make it convenient for us to access the second item if we have a <code>Cons</code> variant.</p>
<p>In Listing 15-26, we‚Äôre adding a <code>main</code> function that uses the definitions in Listing 15-25. This code creates a list in <code>a</code> and a list in <code>b</code> that points to the list in <code>a</code>. Then it modifies the list in <code>a</code> to point to <code>b</code>, creating a reference cycle. There are <code>println!</code> statements along the way to show what the reference counts are at various points in this process.</p>
<Listing number="15-26" file-name="src/main.rs" caption="Creating a reference cycle of two `List` values pointing to each other">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum List {
</span><span class="boring">    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
</span><span class="boring">        match self {
</span><span class="boring">            Cons(_, item) =&gt; Some(item),
</span><span class="boring">            Nil =&gt; None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!("a initial rc count = {}", Rc::strong_count(&amp;a));
    println!("a next item = {:?}", a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));

    println!("a rc count after b creation = {}", Rc::strong_count(&amp;a));
    println!("b initial rc count = {}", Rc::strong_count(&amp;b));
    println!("b next item = {:?}", b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&amp;b);
    }

    println!("b rc count after changing a = {}", Rc::strong_count(&amp;b));
    println!("a rc count after changing a = {}", Rc::strong_count(&amp;a));

    // Uncomment the next line to see that we have a cycle;
    // it will overflow the stack.
    // println!("a next item = {:?}", a.tail());
}</code></pre></pre>
</Listing>
<p>We create an <code>Rc&lt;List&gt;</code> instance holding a <code>List</code> value in the variable <code>a</code> with an initial list of <code>5, Nil</code>. We then create an <code>Rc&lt;List&gt;</code> instance holding another <code>List</code> value in the variable <code>b</code> that contains the value 10 and points to the list in <code>a</code>.</p>
<p>We modify <code>a</code> so it points to <code>b</code> instead of <code>Nil</code>, creating a cycle. We do that by using the <code>tail</code> method to get a reference to the <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> in <code>a</code>, which we put in the variable <code>link</code>. Then we use the <code>borrow_mut</code> method on the <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> to change the value inside from an <code>Rc&lt;List&gt;</code> that holds a <code>Nil</code> value to the <code>Rc&lt;List&gt;</code> in <code>b</code>.</p>
<p>When we run this code, keeping the last <code>println!</code> commented out for the moment, we‚Äôll get this output:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.53s
     Running `target/debug/cons-list`
a initial rc count = 1
a next item = Some(RefCell { value: Nil })
a rc count after b creation = 2
b initial rc count = 1
b next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
b rc count after changing a = 2
a rc count after changing a = 2
</code></pre>
<p>The reference count of the <code>Rc&lt;List&gt;</code> instances in both <code>a</code> and <code>b</code> are 2 after we change the list in <code>a</code> to point to <code>b</code>. At the end of <code>main</code>, Rust drops the variable <code>b</code>, which decreases the reference count of the <code>b</code> <code>Rc&lt;List&gt;</code> instance from 2 to 1. The memory that <code>Rc&lt;List&gt;</code> has on the heap won‚Äôt be dropped at this point, because its reference count is 1, not 0. Then Rust drops <code>a</code>, which decreases the reference count of the <code>a</code> <code>Rc&lt;List&gt;</code> instance from 2 to 1 as well. This instance‚Äôs memory can‚Äôt be dropped either, because the other <code>Rc&lt;List&gt;</code> instance still refers to it. The memory allocated to the list will remain uncollected forever. To visualize this reference cycle, we‚Äôve created the diagram in Figure 15-4.</p>
<img alt="Reference cycle of lists" src="img/trpl15-04.svg" class="center" />
<p><span class="caption">Figure 15-4: A reference cycle of lists <code>a</code> and <code>b</code> pointing to each other</span></p>
<p>If you uncomment the last <code>println!</code> and run the program, Rust will try to print this cycle with <code>a</code> pointing to <code>b</code> pointing to <code>a</code>, and so forth, until it overflows the stack.</p>
<p>Compared to a real-world program, the consequences of creating a reference cycle in this example aren‚Äôt very dire: right after we create the reference cycle, the program ends. However, if a more complex program allocated lots of memory in a cycle and held onto it for a long time, the program would use more memory than it needed and might overwhelm the system, causing it to run out of available memory.</p>
<p>Creating reference cycles is not easily done, but it‚Äôs not impossible either. If you have <code>RefCell&lt;T&gt;</code> values that contain <code>Rc&lt;T&gt;</code> values or similar nested combinations of types with interior mutability and reference counting, you must ensure that you don‚Äôt create cycles; you can‚Äôt rely on Rust to catch them. Creating a reference cycle would be a logic bug in your program that you should use automated tests, code reviews, and other software development practices to minimize.</p>
<p>Another solution for avoiding reference cycles is reorganizing your data structures so that some references express ownership and some references don‚Äôt. As a result, you can have cycles made up of some ownership relationships and some non-ownership relationships, and only the ownership relationships affect whether or not a value can be dropped. In Listing 15-25, we always want <code>Cons</code> variants to own their list, so reorganizing the data structure isn‚Äôt possible. Let‚Äôs look at an example using graphs made up of parent nodes and child nodes to see when non-ownership relationships are an appropriate way to prevent reference cycles.</p>
<h3 id="preventing-reference-cycles-turning-an-rct-into-a-weakt"><a class="header" href="#preventing-reference-cycles-turning-an-rct-into-a-weakt">Preventing Reference Cycles: Turning an <code>Rc&lt;T&gt;</code> into a <code>Weak&lt;T&gt;</code></a></h3>
<p>So far, we‚Äôve demonstrated that calling <code>Rc::clone</code> increases the <code>strong_count</code> of an <code>Rc&lt;T&gt;</code> instance, and an <code>Rc&lt;T&gt;</code> instance is only cleaned up if its <code>strong_count</code> is 0. You can also create a <em>weak reference</em> to the value within an <code>Rc&lt;T&gt;</code> instance by calling <code>Rc::downgrade</code> and passing a reference to the <code>Rc&lt;T&gt;</code>. <em>Strong references</em> are how you can share ownership of an <code>Rc&lt;T&gt;</code> instance. <em>Weak references</em> don‚Äôt express an ownership relationship, and their count doesn‚Äôt affect when an <code>Rc&lt;T&gt;</code> instance is cleaned up. They won‚Äôt cause a reference cycle because any cycle involving some weak references will be broken once the strong reference count of values involved is 0.</p>
<p>When you call <code>Rc::downgrade</code>, you get a smart pointer of type <code>Weak&lt;T&gt;</code>. Instead of increasing the <code>strong_count</code> in the <code>Rc&lt;T&gt;</code> instance by 1, calling <code>Rc::downgrade</code> increases the <code>weak_count</code> by 1. The <code>Rc&lt;T&gt;</code> type uses <code>weak_count</code> to keep track of how many <code>Weak&lt;T&gt;</code> references exist, similar to <code>strong_count</code>. The difference is the <code>weak_count</code> doesn‚Äôt need to be 0 for the <code>Rc&lt;T&gt;</code> instance to be cleaned up.</p>
<p>Because the value that <code>Weak&lt;T&gt;</code> references might have been dropped, to do anything with the value that a <code>Weak&lt;T&gt;</code> is pointing to, you must make sure the value still exists. Do this by calling the <code>upgrade</code> method on a <code>Weak&lt;T&gt;</code> instance, which will return an <code>Option&lt;Rc&lt;T&gt;&gt;</code>. You‚Äôll get a result of <code>Some</code> if the <code>Rc&lt;T&gt;</code> value has not been dropped yet and a result of <code>None</code> if the <code>Rc&lt;T&gt;</code> value has been dropped. Because <code>upgrade</code> returns an <code>Option&lt;Rc&lt;T&gt;&gt;</code>, Rust will ensure that the <code>Some</code> case and the <code>None</code> case are handled, and there won‚Äôt be an invalid pointer.</p>
<p>As an example, rather than using a list whose items know only about the next item, we‚Äôll create a tree whose items know about their children items <em>and</em> their parent items.</p>
<h4 id="creating-a-tree-data-structure-a-node-with-child-nodes"><a class="header" href="#creating-a-tree-data-structure-a-node-with-child-nodes">Creating a Tree Data Structure: a <code>Node</code> with Child Nodes</a></h4>
<p>To start, we‚Äôll build a tree with nodes that know about their child nodes. We‚Äôll create a struct named <code>Node</code> that holds its own <code>i32</code> value as well as references to its children <code>Node</code> values:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<p>We want a <code>Node</code> to own its children, and we want to share that ownership with variables so we can access each <code>Node</code> in the tree directly. To do this, we define the <code>Vec&lt;T&gt;</code> items to be values of type <code>Rc&lt;Node&gt;</code>. We also want to modify which nodes are children of another node, so we have a <code>RefCell&lt;T&gt;</code> in <code>children</code> around the <code>Vec&lt;Rc&lt;Node&gt;&gt;</code>.</p>
<p>Next, we‚Äôll use our struct definition and create one <code>Node</code> instance named <code>leaf</code> with the value 3 and no children, and another instance named <code>branch</code> with the value 5 and <code>leaf</code> as one of its children, as shown in Listing 15-27:</p>
<Listing number="15-27" file-name="src/main.rs" caption="Creating a `leaf` node with no children and a `branch` node with `leaf` as one of its children">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });
}</code></pre></pre>
</Listing>
<p>We clone the <code>Rc&lt;Node&gt;</code> in <code>leaf</code> and store that in <code>branch</code>, meaning the <code>Node</code> in <code>leaf</code> now has two owners: <code>leaf</code> and <code>branch</code>. We can get from <code>branch</code> to <code>leaf</code> through <code>branch.children</code>, but there‚Äôs no way to get from <code>leaf</code> to <code>branch</code>. The reason is that <code>leaf</code> has no reference to <code>branch</code> and doesn‚Äôt know they‚Äôre related. We want <code>leaf</code> to know that <code>branch</code> is its parent. We‚Äôll do that next.</p>
<h4 id="adding-a-reference-from-a-child-to-its-parent"><a class="header" href="#adding-a-reference-from-a-child-to-its-parent">Adding a Reference from a Child to Its Parent</a></h4>
<p>To make the child node aware of its parent, we need to add a <code>parent</code> field to our <code>Node</code> struct definition. The trouble is in deciding what the type of <code>parent</code> should be. We know it can‚Äôt contain an <code>Rc&lt;T&gt;</code>, because that would create a reference cycle with <code>leaf.parent</code> pointing to <code>branch</code> and <code>branch.children</code> pointing to <code>leaf</code>, which would cause their <code>strong_count</code> values to never be 0.</p>
<p>Thinking about the relationships another way, a parent node should own its children: if a parent node is dropped, its child nodes should be dropped as well. However, a child should not own its parent: if we drop a child node, the parent should still exist. This is a case for weak references!</p>
<p>So instead of <code>Rc&lt;T&gt;</code>, we‚Äôll make the type of <code>parent</code> use <code>Weak&lt;T&gt;</code>, specifically a <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code>. Now our <code>Node</code> struct definition looks like this:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);
</span><span class="boring">
</span><span class="boring">    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
</span><span class="boring">}</span></code></pre></pre>
<p>A node will be able to refer to its parent node but doesn‚Äôt own its parent. In Listing 15-28, we update <code>main</code> to use this new definition so the <code>leaf</code> node will have a way to refer to its parent, <code>branch</code>:</p>
<Listing number="15-28" file-name="src/main.rs" caption="A `leaf` node with a weak reference to its parent node `branch`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
}</code></pre></pre>
</Listing>
<p>Creating the <code>leaf</code> node looks similar to Listing 15-27 with the exception of the <code>parent</code> field: <code>leaf</code> starts out without a parent, so we create a new, empty <code>Weak&lt;Node&gt;</code> reference instance.</p>
<p>At this point, when we try to get a reference to the parent of <code>leaf</code> by using the <code>upgrade</code> method, we get a <code>None</code> value. We see this in the output from the first <code>println!</code> statement:</p>
<pre><code class="language-text">leaf parent = None
</code></pre>
<p>When we create the <code>branch</code> node, it will also have a new <code>Weak&lt;Node&gt;</code> reference in the <code>parent</code> field, because <code>branch</code> doesn‚Äôt have a parent node. We still have <code>leaf</code> as one of the children of <code>branch</code>. Once we have the <code>Node</code> instance in <code>branch</code>, we can modify <code>leaf</code> to give it a <code>Weak&lt;Node&gt;</code> reference to its parent. We use the <code>borrow_mut</code> method on the <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code> in the <code>parent</code> field of <code>leaf</code>, and then we use the <code>Rc::downgrade</code> function to create a <code>Weak&lt;Node&gt;</code> reference to <code>branch</code> from the <code>Rc&lt;Node&gt;</code> in <code>branch</code>.</p>
<p>When we print the parent of <code>leaf</code> again, this time we‚Äôll get a <code>Some</code> variant holding <code>branch</code>: now <code>leaf</code> can access its parent! When we print <code>leaf</code>, we also avoid the cycle that eventually ended in a stack overflow like we had in Listing 15-26; the <code>Weak&lt;Node&gt;</code> references are printed as <code>(Weak)</code>:</p>
<pre><code class="language-text">leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
</code></pre>
<p>The lack of infinite output indicates that this code didn‚Äôt create a reference cycle. We can also tell this by looking at the values we get from calling <code>Rc::strong_count</code> and <code>Rc::weak_count</code>.</p>
<h4 id="visualizing-changes-to-strong_count-and-weak_count"><a class="header" href="#visualizing-changes-to-strong_count-and-weak_count">Visualizing Changes to <code>strong_count</code> and <code>weak_count</code></a></h4>
<p>Let‚Äôs look at how the <code>strong_count</code> and <code>weak_count</code> values of the <code>Rc&lt;Node&gt;</code> instances change by creating a new inner scope and moving the creation of <code>branch</code> into that scope. By doing so, we can see what happens when <code>branch</code> is created and then dropped when it goes out of scope. The modifications are shown in Listing 15-29:</p>
<Listing number="15-29" file-name="src/main.rs" caption="Creating `branch` in an inner scope and examining strong and weak reference counts">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

        println!(
            "branch strong = {}, weak = {}",
            Rc::strong_count(&amp;branch),
            Rc::weak_count(&amp;branch),
        );

        println!(
            "leaf strong = {}, weak = {}",
            Rc::strong_count(&amp;leaf),
            Rc::weak_count(&amp;leaf),
        );
    }

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );
}</code></pre></pre>
</Listing>
<p>After <code>leaf</code> is created, its <code>Rc&lt;Node&gt;</code> has a strong count of 1 and a weak count of 0. In the inner scope, we create <code>branch</code> and associate it with <code>leaf</code>, at which point, when we print the counts, the <code>Rc&lt;Node&gt;</code> in <code>branch</code> will have a strong count of 1 and a weak count of 1 (for <code>leaf.parent</code> pointing to <code>branch</code> with a <code>Weak&lt;Node&gt;</code>). When we print the counts in <code>leaf</code>, we‚Äôll see it will have a strong count of 2, because <code>branch</code> now has a clone of the <code>Rc&lt;Node&gt;</code> of <code>leaf</code> stored in <code>branch.children</code>, but will still have a weak count of 0.</p>
<p>When the inner scope ends, <code>branch</code> goes out of scope and the strong count of the <code>Rc&lt;Node&gt;</code> decreases to 0, so its <code>Node</code> is dropped. The weak count of 1 from <code>leaf.parent</code> has no bearing on whether or not <code>Node</code> is dropped, so we don‚Äôt get any memory leaks!</p>
<p>If we try to access the parent of <code>leaf</code> after the end of the scope, we‚Äôll get <code>None</code> again. At the end of the program, the <code>Rc&lt;Node&gt;</code> in <code>leaf</code> has a strong count of 1 and a weak count of 0, because the variable <code>leaf</code> is now the only reference to the <code>Rc&lt;Node&gt;</code> again.</p>
<p>All of the logic that manages the counts and value dropping is built into <code>Rc&lt;T&gt;</code> and <code>Weak&lt;T&gt;</code> and their implementations of the <code>Drop</code> trait. By specifying that the relationship from a child to its parent should be a <code>Weak&lt;T&gt;</code> reference in the definition of <code>Node</code>, you‚Äôre able to have parent nodes point to child nodes and vice versa without creating a reference cycle and memory leaks.</p>
<h2 id="–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-14"><a class="header" href="#–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-14">–ü–æ–¥–≤–µ–¥—ë–º –∏—Ç–æ–≥–∏</a></h2>
<p>This chapter covered how to use smart pointers to make different guarantees and trade-offs from those Rust makes by default with regular references. The <code>Box&lt;T&gt;</code> type has a known size and points to data allocated on the heap. The <code>Rc&lt;T&gt;</code> type keeps track of the number of references to data on the heap so that data can have multiple owners. The <code>RefCell&lt;T&gt;</code> type with its interior mutability gives us a type that we can use when we need an immutable type but need to change an inner value of that type; it also enforces the borrowing rules at runtime instead of at compile time.</p>
<p>Also discussed were the <code>Deref</code> and <code>Drop</code> traits, which enable a lot of the functionality of smart pointers. We explored reference cycles that can cause memory leaks and how to prevent them using <code>Weak&lt;T&gt;</code>.</p>
<p>If this chapter has piqued your interest and you want to implement your own smart pointers, check out <a href="../nomicon/index.html">‚ÄúThe Rustonomicon‚Äù</a> for more useful information.</p>
<p>Next, we‚Äôll talk about concurrency in Rust. You‚Äôll even learn about a few new smart pointers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="–ë–µ–∑–±–æ—è–∑–Ω–µ–Ω–Ω—ã–π-–ø–∞—Ä–∞–ª–ª–µ–ª–∏–∑–º"><a class="header" href="#–ë–µ–∑–±–æ—è–∑–Ω–µ–Ω–Ω—ã–π-–ø–∞—Ä–∞–ª–ª–µ–ª–∏–∑–º">–ë–µ–∑–±–æ—è–∑–Ω–µ–Ω–Ω—ã–π –ø–∞—Ä–∞–ª–ª–µ–ª–∏–∑–º</a></h1>
<p>Handling concurrent programming safely and efficiently is another of Rust‚Äôs major goals. <em>Concurrent programming</em>, in which different parts of a program execute independently, and <em>parallel programming</em>, in which different parts of a program execute at the same time, are becoming increasingly important as more computers take advantage of their multiple processors. Historically, programming in these contexts has been difficult and error prone. Rust hopes to change that.</p>
<p>Initially, the Rust team thought that ensuring memory safety and preventing concurrency problems were two separate challenges to be solved with different methods. Over time, the team discovered that the ownership and type systems are a powerful set of tools to help manage memory safety <em>and</em> concurrency problems! By leveraging ownership and type checking, many concurrency errors are compile-time errors in Rust rather than runtime errors. Therefore, rather than making you spend lots of time trying to reproduce the exact circumstances under which a runtime concurrency bug occurs, incorrect code will refuse to compile and present an error explaining the problem. As a result, you can fix your code while you‚Äôre working on it rather than potentially after it has been shipped to production. We‚Äôve nicknamed this aspect of Rust <em>fearless</em> <em>concurrency</em>. Fearless concurrency allows you to write code that is free of subtle bugs and is easy to refactor without introducing new bugs.</p>
<blockquote>
<p>Note: For simplicity‚Äôs sake, we‚Äôll refer to many of the problems as <em>concurrent</em> rather than being more precise by saying <em>concurrent and/or parallel</em>. If this book were about concurrency and/or parallelism, we‚Äôd be more specific. For this chapter, please mentally substitute <em>concurrent and/or parallel</em> whenever we use <em>concurrent</em>.</p>
</blockquote>
<p>Many languages are dogmatic about the solutions they offer for handling concurrent problems. For example, Erlang has elegant functionality for message-passing concurrency but has only obscure ways to share state between threads. Supporting only a subset of possible solutions is a reasonable strategy for higher-level languages, because a higher-level language promises benefits from giving up some control to gain abstractions. However, lower-level languages are expected to provide the solution with the best performance in any given situation and have fewer abstractions over the hardware. Therefore, Rust offers a variety of tools for modeling problems in whatever way is appropriate for your situation and requirements.</p>
<p>Here are the topics we‚Äôll cover in this chapter:</p>
<ul>
<li>How to create threads to run multiple pieces of code at the same time</li>
<li><em>Message-passing</em> concurrency, where channels send messages between threads</li>
<li><em>Shared-state</em> concurrency, where multiple threads have access to some piece of data</li>
<li>The <code>Sync</code> and <code>Send</code> traits, which extend Rust‚Äôs concurrency guarantees to user-defined types as well as types provided by the standard library</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ-–ø–æ—Ç–æ–∫–æ–≤-–¥–ª—è-–æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ-–∑–∞–ø—É—Å–∫–∞-–∫–æ–¥–∞"><a class="header" href="#–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ-–ø–æ—Ç–æ–∫–æ–≤-–¥–ª—è-–æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ-–∑–∞–ø—É—Å–∫–∞-–∫–æ–¥–∞">–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø–æ—Ç–æ–∫–æ–≤ –¥–ª—è –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ –∑–∞–ø—É—Å–∫–∞ –∫–æ–¥–∞</a></h2>
<p>In most current operating systems, an executed program‚Äôs code is run in a <em>process</em>, and the operating system will manage multiple processes at once. Within a program, you can also have independent parts that run simultaneously. The features that run these independent parts are called <em>threads</em>. For example, a web server could have multiple threads so that it can respond to more than one request at the same time.</p>
<p>Splitting the computation in your program into multiple threads to run multiple tasks at the same time can improve performance, but it also adds complexity. Because threads can run simultaneously, there‚Äôs no inherent guarantee about the order in which parts of your code on different threads will run. This can lead to problems, such as:</p>
<ul>
<li>Race conditions, in which threads are accessing data or resources in an inconsistent order</li>
<li>Deadlocks, in which two threads are waiting for each other, preventing both threads from continuing</li>
<li>Bugs that happen only in certain situations and are hard to reproduce and fix reliably</li>
</ul>
<p>Rust attempts to mitigate the negative effects of using threads, but programming in a multithreaded context still takes careful thought and requires a code structure that is different from that in programs running in a single thread.</p>
<p>Programming languages implement threads in a few different ways, and many operating systems provide an API the language can call for creating new threads. The Rust standard library uses a <em>1:1</em> model of thread implementation, whereby a program uses one operating system thread per one language thread. There are crates that implement other models of threading that make different tradeoffs to the 1:1 model. (Rust‚Äôs async system, which we will see in the next chapter, provides another approach to concurrency as well.)</p>
<h3 id="creating-a-new-thread-with-spawn"><a class="header" href="#creating-a-new-thread-with-spawn">Creating a New Thread with <code>spawn</code></a></h3>
<p>To create a new thread, we call the <code>thread::spawn</code> function and pass it a closure (we talked about closures in Chapter 13) containing the code we want to run in the new thread. The example in Listing 16-1 prints some text from a main thread and other text from a new thread:</p>
<Listing number="16-1" file-name="src/main.rs" caption="Creating a new thread to print one thing while the main thread prints something else">
<pre><pre class="playground"><code class="language-rust edition2021">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {i} from the spawned thread!");
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {i} from the main thread!");
        thread::sleep(Duration::from_millis(1));
    }
}</code></pre></pre>
</Listing>
<p>Note that when the main thread of a Rust program completes, all spawned threads are shut down, whether or not they have finished running. The output from this program might be a little different every time, but it will look similar to the following:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the main thread!
hi number 1 from the spawned thread!
hi number 2 from the main thread!
hi number 2 from the spawned thread!
hi number 3 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the main thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
</code></pre>
<p>The calls to <code>thread::sleep</code> force a thread to stop its execution for a short duration, allowing a different thread to run. The threads will probably take turns, but that isn‚Äôt guaranteed: it depends on how your operating system schedules the threads. In this run, the main thread printed first, even though the print statement from the spawned thread appears first in the code. And even though we told the spawned thread to print until <code>i</code> is <code>9</code>, it only got to <code>5</code> before the main thread shut down.</p>
<p>If you run this code and only see output from the main thread, or don‚Äôt see any overlap, try increasing the numbers in the ranges to create more opportunities for the operating system to switch between the threads.</p>
<h3 id="waiting-for-all-threads-to-finish-using-join-handles"><a class="header" href="#waiting-for-all-threads-to-finish-using-join-handles">Waiting for All Threads to Finish Using <code>join</code> Handles</a></h3>
<p>The code in Listing 16-1 not only stops the spawned thread prematurely most of the time due to the main thread ending, but because there is no guarantee on the order in which threads run, we also can‚Äôt guarantee that the spawned thread will get to run at all!</p>
<p>We can fix the problem of the spawned thread not running or ending prematurely by saving the return value of <code>thread::spawn</code> in a variable. The return type of <code>thread::spawn</code> is <code>JoinHandle</code>. A <code>JoinHandle</code> is an owned value that, when we call the <code>join</code> method on it, will wait for its thread to finish. Listing 16-2 shows how to use the <code>JoinHandle</code> of the thread we created in Listing 16-1 and how to call <code>join</code> to make sure the spawned thread finishes before <code>main</code> exits:</p>
<Listing number="16-2" file-name="src/main.rs" caption="Saving a `JoinHandle` from `thread::spawn` to guarantee the thread is run to completion">
<pre><pre class="playground"><code class="language-rust edition2021">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {i} from the spawned thread!");
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {i} from the main thread!");
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}</code></pre></pre>
</Listing>
<p>Calling <code>join</code> on the handle blocks the thread currently running until the thread represented by the handle terminates. <em>Blocking</em> a thread means that thread is prevented from performing work or exiting. Because we‚Äôve put the call to <code>join</code> after the main thread‚Äôs <code>for</code> loop, running Listing 16-2 should produce output similar to this:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 1 from the spawned thread!
hi number 3 from the main thread!
hi number 2 from the spawned thread!
hi number 4 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
</code></pre>
<p>The two threads continue alternating, but the main thread waits because of the call to <code>handle.join()</code> and does not end until the spawned thread is finished.</p>
<p>But let‚Äôs see what happens when we instead move <code>handle.join()</code> before the <code>for</code> loop in <code>main</code>, like this:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {i} from the spawned thread!");
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!("hi number {i} from the main thread!");
        thread::sleep(Duration::from_millis(1));
    }
}</code></pre></pre>
</Listing>
<p>The main thread will wait for the spawned thread to finish and then run its <code>for</code> loop, so the output won‚Äôt be interleaved anymore, as shown here:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the spawned thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 3 from the main thread!
hi number 4 from the main thread!
</code></pre>
<p>Small details, such as where <code>join</code> is called, can affect whether or not your threads run at the same time.</p>
<h3 id="using-move-closures-with-threads"><a class="header" href="#using-move-closures-with-threads">Using <code>move</code> Closures with Threads</a></h3>
<p>We'll often use the <code>move</code> keyword with closures passed to <code>thread::spawn</code> because the closure will then take ownership of the values it uses from the environment, thus transferring ownership of those values from one thread to another. In <a href="ch13-01-closures.html#capturing-references-or-moving-ownership">‚ÄúCapturing References or Moving Ownership‚Äù</a><!-- ignore --> in Chapter 13, we discussed <code>move</code> in the context of closures. Now, we‚Äôll concentrate more on the interaction between <code>move</code> and <code>thread::spawn</code>.</p>
<p>Notice in Listing 16-1 that the closure we pass to <code>thread::spawn</code> takes no arguments: we‚Äôre not using any data from the main thread in the spawned thread‚Äôs code. To use data from the main thread in the spawned thread, the spawned thread‚Äôs closure must capture the values it needs. Listing 16-3 shows an attempt to create a vector in the main thread and use it in the spawned thread. However, this won‚Äôt yet work, as you‚Äôll see in a moment.</p>
<Listing number="16-3" file-name="src/main.rs" caption="Attempting to use a vector created by the main thread in another thread">
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("Here's a vector: {v:?}");
    });

    handle.join().unwrap();
}</code></pre>
</Listing>
<p>The closure uses <code>v</code>, so it will capture <code>v</code> and make it part of the closure‚Äôs environment. Because <code>thread::spawn</code> runs this closure in a new thread, we should be able to access <code>v</code> inside that new thread. But when we compile this example, we get the following error:</p>
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function
 --&gt; src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!("Here's a vector: {v:?}");
  |                                     - `v` is borrowed here
  |
note: function requires argument type to outlive `'static`
 --&gt; src/main.rs:6:18
  |
6 |       let handle = thread::spawn(|| {
  |  __________________^
7 | |         println!("Here's a vector: {v:?}");
8 | |     });
  | |______^
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++

For more information about this error, try `rustc --explain E0373`.
error: could not compile `threads` (bin "threads") due to 1 previous error
</code></pre>
<p>Rust <em>infers</em> how to capture <code>v</code>, and because <code>println!</code> only needs a reference to <code>v</code>, the closure tries to borrow <code>v</code>. However, there‚Äôs a problem: Rust can‚Äôt tell how long the spawned thread will run, so it doesn‚Äôt know if the reference to <code>v</code> will always be valid.</p>
<p>Listing 16-4 provides a scenario that‚Äôs more likely to have a reference to <code>v</code> that won‚Äôt be valid:</p>
<Listing number="16-4" file-name="src/main.rs" caption="A thread with a closure that attempts to capture a reference to `v` from a main thread that drops `v`">
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("Here's a vector: {v:?}");
    });

    drop(v); // oh no!

    handle.join().unwrap();
}</code></pre>
</Listing>
<p>If Rust allowed us to run this code, there‚Äôs a possibility the spawned thread would be immediately put in the background without running at all. The spawned thread has a reference to <code>v</code> inside, but the main thread immediately drops <code>v</code>, using the <code>drop</code> function we discussed in Chapter 15. Then, when the spawned thread starts to execute, <code>v</code> is no longer valid, so a reference to it is also invalid. Oh no!</p>
<p>To fix the compiler error in Listing 16-3, we can use the error message‚Äôs advice:</p>
<!-- manual-regeneration
after automatic regeneration, look at listings/ch16-fearless-concurrency/listing-16-03/output.txt and copy the relevant part
-->
<pre><code class="language-text">help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++
</code></pre>
<p>By adding the <code>move</code> keyword before the closure, we force the closure to take ownership of the values it‚Äôs using rather than allowing Rust to infer that it should borrow the values. The modification to Listing 16-3 shown in Listing 16-5 will compile and run as we intend:</p>
<Listing number="16-5" file-name="src/main.rs" caption="Using the `move` keyword to force a closure to take ownership of the values it uses">
<pre><pre class="playground"><code class="language-rust edition2021">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!("Here's a vector: {v:?}");
    });

    handle.join().unwrap();
}</code></pre></pre>
</Listing>
<p>We might be tempted to try the same thing to fix the code in Listing 16-4 where the main thread called <code>drop</code> by using a <code>move</code> closure. However, this fix will not work because what Listing 16-4 is trying to do is disallowed for a different reason. If we added <code>move</code> to the closure, we would move <code>v</code> into the closure‚Äôs environment, and we could no longer call <code>drop</code> on it in the main thread. We would get this compiler error instead:</p>
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0382]: use of moved value: `v`
  --&gt; src/main.rs:10:10
   |
4  |     let v = vec![1, 2, 3];
   |         - move occurs because `v` has type `Vec&lt;i32&gt;`, which does not implement the `Copy` trait
5  |
6  |     let handle = thread::spawn(move || {
   |                                ------- value moved into closure here
7  |         println!("Here's a vector: {v:?}");
   |                                     - variable moved due to use in closure
...
10 |     drop(v); // oh no!
   |          ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `threads` (bin "threads") due to 1 previous error
</code></pre>
<p>Rust‚Äôs ownership rules have saved us again! We got an error from the code in Listing 16-3 because Rust was being conservative and only borrowing <code>v</code> for the thread, which meant the main thread could theoretically invalidate the spawned thread‚Äôs reference. By telling Rust to move ownership of <code>v</code> to the spawned thread, we‚Äôre guaranteeing to Rust that the main thread won‚Äôt use <code>v</code> anymore. If we change Listing 16-4 in the same way, we‚Äôre then violating the ownership rules when we try to use <code>v</code> in the main thread. The <code>move</code> keyword overrides Rust‚Äôs conservative default of borrowing; it doesn‚Äôt let us violate the ownership rules.</p>
<p>With a basic understanding of threads and the thread API, let‚Äôs look at what we can <em>do</em> with threads.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ-–æ–±–º–µ–Ω–∞-—Å–æ–æ–±—â–µ–Ω–∏—è–º–∏-–¥–ª—è-–æ–±–º–µ–Ω–∞-–¥–∞–Ω–Ω—ã–º–∏-–º–µ–∂–¥—É-–ø–æ—Ç–æ–∫–∞–º–∏"><a class="header" href="#–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ-–æ–±–º–µ–Ω–∞-—Å–æ–æ–±—â–µ–Ω–∏—è–º–∏-–¥–ª—è-–æ–±–º–µ–Ω–∞-–¥–∞–Ω–Ω—ã–º–∏-–º–µ–∂–¥—É-–ø–æ—Ç–æ–∫–∞–º–∏">–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –æ–±–º–µ–Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏—è–º–∏ –¥–ª—è –æ–±–º–µ–Ω–∞ –¥–∞–Ω–Ω—ã–º–∏ –º–µ–∂–¥—É –ø–æ—Ç–æ–∫–∞–º–∏</a></h2>
<p>One increasingly popular approach to ensuring safe concurrency is <em>message passing</em>, where threads or actors communicate by sending each other messages containing data. Here‚Äôs the idea in a slogan from <a href="https://golang.org/doc/effective_go.html#concurrency">the Go language documentation</a>: ‚ÄúDo not communicate by sharing memory; instead, share memory by communicating.‚Äù</p>
<p>To accomplish message-sending concurrency, Rust's standard library provides an implementation of channels. A <em>channel</em> is a general programming concept by which data is sent from one thread to another.</p>
<p>You can imagine a channel in programming as being like a directional channel of water, such as a stream or a river. If you put something like a rubber duck into a river, it will travel downstream to the end of the waterway.</p>
<p>A channel has two halves: a transmitter and a receiver. The transmitter half is the upstream location where you put rubber ducks into the river, and the receiver half is where the rubber duck ends up downstream. One part of your code calls methods on the transmitter with the data you want to send, and another part checks the receiving end for arriving messages. A channel is said to be <em>closed</em> if either the transmitter or receiver half is dropped.</p>
<p>Here, we‚Äôll work up to a program that has one thread to generate values and send them down a channel, and another thread that will receive the values and print them out. We‚Äôll be sending simple values between threads using a channel to illustrate the feature. Once you‚Äôre familiar with the technique, you could use channels for any threads that need to communicate between each other, such as a chat system or a system where many threads perform parts of a calculation and send the parts to one thread that aggregates the results.</p>
<p>First, in Listing 16-6, we‚Äôll create a channel but not do anything with it. Note that this won‚Äôt compile yet because Rust can‚Äôt tell what type of values we want to send over the channel.</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
}</code></pre>
<p><span class="caption">Listing 16-6: Creating a channel and assigning the two halves to <code>tx</code> and <code>rx</code></span></p>
<p>We create a new channel using the <code>mpsc::channel</code> function; <code>mpsc</code> stands for <em>multiple producer, single consumer</em>. In short, the way Rust‚Äôs standard library implements channels means a channel can have multiple <em>sending</em> ends that produce values but only one <em>receiving</em> end that consumes those values. Imagine multiple streams flowing together into one big river: everything sent down any of the streams will end up in one river at the end. We‚Äôll start with a single producer for now, but we‚Äôll add multiple producers when we get this example working.</p>
<p>The <code>mpsc::channel</code> function returns a tuple, the first element of which is the sending end‚Äîthe transmitter‚Äîand the second element is the receiving end‚Äîthe receiver. The abbreviations <code>tx</code> and <code>rx</code> are traditionally used in many fields for <em>transmitter</em> and <em>receiver</em> respectively, so we name our variables as such to indicate each end. We‚Äôre using a <code>let</code> statement with a pattern that destructures the tuples; we‚Äôll discuss the use of patterns in <code>let</code> statements and destructuring in Chapter 19. For now, know that using a <code>let</code> statement this way is a convenient approach to extract the pieces of the tuple returned by <code>mpsc::channel</code>.</p>
<p>Let‚Äôs move the transmitting end into a spawned thread and have it send one string so that the spawned thread is communicating with the main thread, as shown in Listing 16-7. This is like putting a rubber duck in the river upstream or sending a chat message from one thread to another.</p>
<Listing number="16-7" file-name="src/main.rs" caption="Moving `tx` to a spawned thread and sending ‚Äúhi‚Äù">
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });
}</code></pre></pre>
</Listing>
<p>Again, we‚Äôre using <code>thread::spawn</code> to create a new thread and then using <code>move</code> to move <code>tx</code> into the closure so that the spawned thread owns <code>tx</code>. The spawned thread needs to own the transmitter to be able to send messages through the channel.</p>
<p>The transmitter has a <code>send</code> method that takes the value we want to send. The <code>send</code> method returns a <code>Result&lt;T, E&gt;</code> type, so if the receiver has already been dropped and there‚Äôs nowhere to send a value, the send operation will return an error. In this example, we‚Äôre calling <code>unwrap</code> to panic in case of an error. But in a real application, we would handle it properly: return to Chapter 9 to review strategies for proper error handling.</p>
<p>In Listing 16-8, we‚Äôll get the value from the receiver in the main thread. This is like retrieving the rubber duck from the water at the end of the river or receiving a chat message.</p>
<Listing number="16-8" file-name="src/main.rs" caption="Receiving the value ‚Äúhi‚Äù in the main thread and printing it">
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("Got: {received}");
}</code></pre></pre>
</Listing>
<p>The receiver has two useful methods: <code>recv</code> and <code>try_recv</code>. We‚Äôre using <code>recv</code>, short for <em>receive</em>, which will block the main thread‚Äôs execution and wait until a value is sent down the channel. Once a value is sent, <code>recv</code> will return it in a <code>Result&lt;T, E&gt;</code>. When the transmitter closes, <code>recv</code> will return an error to signal that no more values will be coming.</p>
<p>The <code>try_recv</code> method doesn‚Äôt block, but will instead return a <code>Result&lt;T, E&gt;</code> immediately: an <code>Ok</code> value holding a message if one is available and an <code>Err</code> value if there aren‚Äôt any messages this time. Using <code>try_recv</code> is useful if this thread has other work to do while waiting for messages: we could write a loop that calls <code>try_recv</code> every so often, handles a message if one is available, and otherwise does other work for a little while until checking again.</p>
<p>We‚Äôve used <code>recv</code> in this example for simplicity; we don‚Äôt have any other work for the main thread to do other than wait for messages, so blocking the main thread is appropriate.</p>
<p>When we run the code in Listing 16-8, we‚Äôll see the value printed from the main thread:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Got: hi
</code></pre>
<p>Perfect!</p>
<h3 id="channels-and-ownership-transference"><a class="header" href="#channels-and-ownership-transference">Channels and Ownership Transference</a></h3>
<p>The ownership rules play a vital role in message sending because they help you write safe, concurrent code. Preventing errors in concurrent programming is the advantage of thinking about ownership throughout your Rust programs. Let‚Äôs do an experiment to show how channels and ownership work together to prevent problems: we‚Äôll try to use a <code>val</code> value in the spawned thread <em>after</em> we‚Äôve sent it down the channel. Try compiling the code in Listing 16-9 to see why this code isn‚Äôt allowed:</p>
<Listing number="16-9" file-name="src/main.rs" caption="Attempting to use `val` after we‚Äôve sent it down the channel">
<pre><code class="language-rust ignore does_not_compile">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
        println!("val is {val}");
    });

    let received = rx.recv().unwrap();
    println!("Got: {received}");
}</code></pre>
</Listing>
<p>Here, we try to print <code>val</code> after we‚Äôve sent it down the channel via <code>tx.send</code>. Allowing this would be a bad idea: once the value has been sent to another thread, that thread could modify or drop it before we try to use the value again. Potentially, the other thread‚Äôs modifications could cause errors or unexpected results due to inconsistent or nonexistent data. However, Rust gives us an error if we try to compile the code in Listing 16-9:</p>
<pre><code class="language-console">$ cargo run
   Compiling message-passing v0.1.0 (file:///projects/message-passing)
error[E0382]: borrow of moved value: `val`
  --&gt; src/main.rs:10:26
   |
8  |         let val = String::from("hi");
   |             --- move occurs because `val` has type `String`, which does not implement the `Copy` trait
9  |         tx.send(val).unwrap();
   |                 --- value moved here
10 |         println!("val is {val}");
   |                          ^^^^^ value borrowed here after move
   |
   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0382`.
error: could not compile `message-passing` (bin "message-passing") due to 1 previous error
</code></pre>
<p>Our concurrency mistake has caused a compile time error. The <code>send</code> function takes ownership of its parameter, and when the value is moved, the receiver takes ownership of it. This stops us from accidentally using the value again after sending it; the ownership system checks that everything is okay.</p>
<h3 id="sending-multiple-values-and-seeing-the-receiver-waiting"><a class="header" href="#sending-multiple-values-and-seeing-the-receiver-waiting">Sending Multiple Values and Seeing the Receiver Waiting</a></h3>
<p>The code in Listing 16-8 compiled and ran, but it didn‚Äôt clearly show us that two separate threads were talking to each other over the channel. In Listing 16-10 we‚Äôve made some modifications that will prove the code in Listing 16-8 is running concurrently: the spawned thread will now send multiple messages and pause for a second between each message.</p>
<Listing number="16-10" file-name="src/main.rs" caption="Sending multiple messages and pausing between each">
<pre><code class="language-rust noplayground">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Got: {received}");
    }
}</code></pre>
</Listing>
<p>This time, the spawned thread has a vector of strings that we want to send to the main thread. We iterate over them, sending each individually, and pause between each by calling the <code>thread::sleep</code> function with a <code>Duration</code> value of 1 second.</p>
<p>In the main thread, we‚Äôre not calling the <code>recv</code> function explicitly anymore: instead, we‚Äôre treating <code>rx</code> as an iterator. For each value received, we‚Äôre printing it. When the channel is closed, iteration will end.</p>
<p>When running the code in Listing 16-10, you should see the following output with a 1-second pause in between each line:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Got: hi
Got: from
Got: the
Got: thread
</code></pre>
<p>Because we don‚Äôt have any code that pauses or delays in the <code>for</code> loop in the main thread, we can tell that the main thread is waiting to receive values from the spawned thread.</p>
<h3 id="creating-multiple-producers-by-cloning-the-transmitter"><a class="header" href="#creating-multiple-producers-by-cloning-the-transmitter">Creating Multiple Producers by Cloning the Transmitter</a></h3>
<p>Earlier we mentioned that <code>mpsc</code> was an acronym for <em>multiple producer, single consumer</em>. Let‚Äôs put <code>mpsc</code> to use and expand the code in Listing 16-10 to create multiple threads that all send values to the same receiver. We can do so by cloning the transmitter, as shown in Listing 16-11:</p>
<Listing number="16-11" file-name="src/main.rs" caption="Sending multiple messages from multiple producers">
<pre><code class="language-rust noplayground"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--

    let (tx, rx) = mpsc::channel();

    let tx1 = tx.clone();
    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx1.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from("more"),
            String::from("messages"),
            String::from("for"),
            String::from("you"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Got: {received}");
    }

    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">}</span></code></pre>
</Listing>
<p>This time, before we create the first spawned thread, we call <code>clone</code> on the transmitter. This will give us a new transmitter we can pass to the first spawned thread. We pass the original transmitter to a second spawned thread. This gives us two threads, each sending different messages to the one receiver.</p>
<p>When you run the code, your output should look something like this:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Got: hi
Got: more
Got: from
Got: messages
Got: for
Got: the
Got: thread
Got: you
</code></pre>
<p>You might see the values in another order, depending on your system. This is what makes concurrency interesting as well as difficult. If you experiment with <code>thread::sleep</code>, giving it various values in the different threads, each run will be more nondeterministic and create different output each time.</p>
<p>Now that we‚Äôve looked at how channels work, let‚Äôs look at a different method of concurrency.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–ü–∞—Ä–∞–ª–ª–µ–ª–∏–∑–º-—Å-–æ–±—â–∏–º-—Å–æ—Å—Ç–æ—è–Ω–∏–µ–º"><a class="header" href="#–ü–∞—Ä–∞–ª–ª–µ–ª–∏–∑–º-—Å-–æ–±—â–∏–º-—Å–æ—Å—Ç–æ—è–Ω–∏–µ–º">–ü–∞—Ä–∞–ª–ª–µ–ª–∏–∑–º —Å –æ–±—â–∏–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ–º</a></h2>
<p>Message passing is a fine way of handling concurrency, but it‚Äôs not the only one. Another method would be for multiple threads to access the same shared data. Consider this part of the slogan from the Go language documentation again: ‚Äúdo not communicate by sharing memory.‚Äù</p>
<p>What would communicating by sharing memory look like? In addition, why would message-passing enthusiasts caution not to use memory sharing?</p>
<p>In a way, channels in any programming language are similar to single ownership, because once you transfer a value down a channel, you should no longer use that value. Shared memory concurrency is like multiple ownership: multiple threads can access the same memory location at the same time. As you saw in Chapter 15, where smart pointers made multiple ownership possible, multiple ownership can add complexity because these different owners need managing. Rust‚Äôs type system and ownership rules greatly assist in getting this management correct. For an example, let‚Äôs look at mutexes, one of the more common concurrency primitives for shared memory.</p>
<h3 id="using-mutexes-to-allow-access-to-data-from-one-thread-at-a-time"><a class="header" href="#using-mutexes-to-allow-access-to-data-from-one-thread-at-a-time">Using Mutexes to Allow Access to Data from One Thread at a Time</a></h3>
<p><em>Mutex</em> is an abbreviation for <em>mutual exclusion</em>, as in, a mutex allows only one thread to access some data at any given time. To access the data in a mutex, a thread must first signal that it wants access by asking to acquire the mutex‚Äôs <em>lock</em>. The lock is a data structure that is part of the mutex that keeps track of who currently has exclusive access to the data. Therefore, the mutex is described as <em>guarding</em> the data it holds via the locking system.</p>
<p>Mutexes have a reputation for being difficult to use because you have to remember two rules:</p>
<ol>
<li>You must attempt to acquire the lock before using the data.</li>
<li>When you‚Äôre done with the data that the mutex guards, you must unlock the data so other threads can acquire the lock.</li>
</ol>
<p>For a real-world metaphor for a mutex, imagine a panel discussion at a conference with only one microphone. Before a panelist can speak, they have to ask or signal that they want to use the microphone. When they get the microphone, they can talk for as long as they want to and then hand the microphone to the next panelist who requests to speak. If a panelist forgets to hand the microphone off when they‚Äôre finished with it, no one else is able to speak. If management of the shared microphone goes wrong, the panel won‚Äôt work as planned!</p>
<p>Management of mutexes can be incredibly tricky to get right, which is why so many people are enthusiastic about channels. However, thanks to Rust‚Äôs type system and ownership rules, you can‚Äôt get locking and unlocking wrong.</p>
<h4 id="the-api-of-mutext"><a class="header" href="#the-api-of-mutext">The API of <code>Mutex&lt;T&gt;</code></a></h4>
<p>As an example of how to use a mutex, let‚Äôs start by using a mutex in a single-threaded context, as shown in Listing 16-12:</p>
<Listing number="16-12" file-name="src/main.rs" caption="Exploring the API of `Mutex<T>` in a single-threaded context for simplicity">
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!("m = {m:?}");
}</code></pre></pre>
</Listing>
<p>As with many types, we create a <code>Mutex&lt;T&gt;</code> using the associated function <code>new</code>. To access the data inside the mutex, we use the <code>lock</code> method to acquire the lock. This call will block the current thread so it can‚Äôt do any work until it‚Äôs our turn to have the lock.</p>
<p>The call to <code>lock</code> would fail if another thread holding the lock panicked. In that case, no one would ever be able to get the lock, so we‚Äôve chosen to <code>unwrap</code> and have this thread panic if we‚Äôre in that situation.</p>
<p>After we‚Äôve acquired the lock, we can treat the return value, named <code>num</code> in this case, as a mutable reference to the data inside. The type system ensures that we acquire a lock before using the value in <code>m</code>. The type of <code>m</code> is <code>Mutex&lt;i32&gt;</code>, not <code>i32</code>, so we <em>must</em> call <code>lock</code> to be able to use the <code>i32</code> value. We can‚Äôt forget; the type system won‚Äôt let us access the inner <code>i32</code> otherwise.</p>
<p>As you might suspect, <code>Mutex&lt;T&gt;</code> is a smart pointer. More accurately, the call to <code>lock</code> <em>returns</em> a smart pointer called <code>MutexGuard</code>, wrapped in a <code>LockResult</code> that we handled with the call to <code>unwrap</code>. The <code>MutexGuard</code> smart pointer implements <code>Deref</code> to point at our inner data; the smart pointer also has a <code>Drop</code> implementation that releases the lock automatically when a <code>MutexGuard</code> goes out of scope, which happens at the end of the inner scope. As a result, we don‚Äôt risk forgetting to release the lock and blocking the mutex from being used by other threads, because the lock release happens automatically.</p>
<p>After dropping the lock, we can print the mutex value and see that we were able to change the inner <code>i32</code> to 6.</p>
<h4 id="sharing-a-mutext-between-multiple-threads"><a class="header" href="#sharing-a-mutext-between-multiple-threads">Sharing a <code>Mutex&lt;T&gt;</code> Between Multiple Threads</a></h4>
<p>Now, let‚Äôs try to share a value between multiple threads using <code>Mutex&lt;T&gt;</code>. We‚Äôll spin up 10 threads and have them each increment a counter value by 1, so the counter goes from 0 to 10. The next example in Listing 16-13 will have a compiler error, and we‚Äôll use that error to learn more about using <code>Mutex&lt;T&gt;</code> and how Rust helps us use it correctly.</p>
<Listing number="16-13" file-name="src/main.rs" caption="Ten threads each increment a counter guarded by a `Mutex<T>`">
<pre><code class="language-rust ignore does_not_compile">use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}</code></pre>
</Listing>
<p>We create a <code>counter</code> variable to hold an <code>i32</code> inside a <code>Mutex&lt;T&gt;</code>, as we did in Listing 16-12. Next, we create 10 threads by iterating over a range of numbers. We use <code>thread::spawn</code> and give all the threads the same closure: one that moves the counter into the thread, acquires a lock on the <code>Mutex&lt;T&gt;</code> by calling the <code>lock</code> method, and then adds 1 to the value in the mutex. When a thread finishes running its closure, <code>num</code> will go out of scope and release the lock so another thread can acquire it.</p>
<p>In the main thread, we collect all the join handles. Then, as we did in Listing 16-2, we call <code>join</code> on each handle to make sure all the threads finish. At that point, the main thread will acquire the lock and print the result of this program.</p>
<p>We hinted that this example wouldn‚Äôt compile. Now let‚Äôs find out why!</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0382]: borrow of moved value: `counter`
  --&gt; src/main.rs:21:29
   |
5  |     let counter = Mutex::new(0);
   |         ------- move occurs because `counter` has type `Mutex&lt;i32&gt;`, which does not implement the `Copy` trait
...
8  |     for _ in 0..10 {
   |     -------------- inside of this loop
9  |         let handle = thread::spawn(move || {
   |                                    ------- value moved into closure here, in previous iteration of loop
...
21 |     println!("Result: {}", *counter.lock().unwrap());
   |                             ^^^^^^^ value borrowed here after move
   |
help: consider moving the expression out of the loop so it is only moved once
   |
8  ~     let mut value = counter.lock();
9  ~     for _ in 0..10 {
10 |         let handle = thread::spawn(move || {
11 ~             let mut num = value.unwrap();
   |

For more information about this error, try `rustc --explain E0382`.
error: could not compile `shared-state` (bin "shared-state") due to 1 previous error
</code></pre>
<p>The error message states that the <code>counter</code> value was moved in the previous iteration of the loop. Rust is telling us that we can‚Äôt move the ownership of <code>counter</code> into multiple threads. Let‚Äôs fix the compiler error with a multiple-ownership method we discussed in Chapter 15.</p>
<h4 id="multiple-ownership-with-multiple-threads"><a class="header" href="#multiple-ownership-with-multiple-threads">Multiple Ownership with Multiple Threads</a></h4>
<p>In Chapter 15, we gave a value multiple owners by using the smart pointer <code>Rc&lt;T&gt;</code> to create a reference counted value. Let‚Äôs do the same here and see what happens. We‚Äôll wrap the <code>Mutex&lt;T&gt;</code> in <code>Rc&lt;T&gt;</code> in Listing 16-14 and clone the <code>Rc&lt;T&gt;</code> before moving ownership to the thread.</p>
<Listing number="16-14" file-name="src/main.rs" caption="Attempting to use `Rc<T>` to allow multiple threads to own the `Mutex<T>`">
<pre><code class="language-rust ignore does_not_compile">use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}</code></pre>
</Listing>
<p>Once again, we compile and get‚Ä¶ different errors! The compiler is teaching us a lot.</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0277]: `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
   --&gt; src/main.rs:11:36
    |
11  |           let handle = thread::spawn(move || {
    |                        ------------- ^------
    |                        |             |
    |  ______________________|_____________within this `{closure@src/main.rs:11:36: 11:43}`
    | |                      |
    | |                      required by a bound introduced by this call
12  | |             let mut num = counter.lock().unwrap();
13  | |
14  | |             *num += 1;
15  | |         });
    | |_________^ `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
    |
    = help: within `{closure@src/main.rs:11:36: 11:43}`, the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;`, which is required by `{closure@src/main.rs:11:36: 11:43}: Send`
note: required because it's used within this closure
   --&gt; src/main.rs:11:36
    |
11  |         let handle = thread::spawn(move || {
    |                                    ^^^^^^^
note: required by a bound in `spawn`
   --&gt; file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/std/src/thread/mod.rs:675:8
    |
672 | pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    |        ----- required by a bound in this function
...
675 |     F: Send + 'static,
    |        ^^^^ required by this bound in `spawn`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `shared-state` (bin "shared-state") due to 1 previous error
</code></pre>
<p>Wow, that error message is very wordy! Here‚Äôs the important part to focus on: <code>`Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</code>. The compiler is also telling us the reason why: <code>the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;`</code>. We‚Äôll talk about <code>Send</code> in the next section: it‚Äôs one of the traits that ensures the types we use with threads are meant for use in concurrent situations.</p>
<p>Unfortunately, <code>Rc&lt;T&gt;</code> is not safe to share across threads. When <code>Rc&lt;T&gt;</code> manages the reference count, it adds to the count for each call to <code>clone</code> and subtracts from the count when each clone is dropped. But it doesn‚Äôt use any concurrency primitives to make sure that changes to the count can‚Äôt be interrupted by another thread. This could lead to wrong counts‚Äîsubtle bugs that could in turn lead to memory leaks or a value being dropped before we‚Äôre done with it. What we need is a type that is exactly like <code>Rc&lt;T&gt;</code> but one that makes changes to the reference count in a thread-safe way.</p>
<h4 id="atomic-reference-counting-with-arct"><a class="header" href="#atomic-reference-counting-with-arct">Atomic Reference Counting with <code>Arc&lt;T&gt;</code></a></h4>
<p>Fortunately, <code>Arc&lt;T&gt;</code> <em>is</em> a type like <code>Rc&lt;T&gt;</code> that is safe to use in concurrent situations. The <em>a</em> stands for <em>atomic</em>, meaning it‚Äôs an <em>atomically reference-counted</em> type. Atomics are an additional kind of concurrency primitive that we won‚Äôt cover in detail here: see the standard library documentation for <a href="../std/sync/atomic/index.html"><code>std::sync::atomic</code></a><!-- ignore --> for more details. At this point, you just need to know that atomics work like primitive types but are safe to share across threads.</p>
<p>You might then wonder why all primitive types aren‚Äôt atomic and why standard library types aren‚Äôt implemented to use <code>Arc&lt;T&gt;</code> by default. The reason is that thread safety comes with a performance penalty that you only want to pay when you really need to. If you‚Äôre just performing operations on values within a single thread, your code can run faster if it doesn‚Äôt have to enforce the guarantees atomics provide.</p>
<p>Let‚Äôs return to our example: <code>Arc&lt;T&gt;</code> and <code>Rc&lt;T&gt;</code> have the same API, so we fix our program by changing the <code>use</code> line, the call to <code>new</code>, and the call to <code>clone</code>. The code in Listing 16-15 will finally compile and run:</p>
<Listing number="16-15" file-name="src/main.rs" caption="Using an `Arc<T>` to wrap the `Mutex<T>` to be able to share ownership across multiple threads">
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}</code></pre></pre>
</Listing>
<p>–ö–æ–¥ –Ω–∞–ø–µ—á–∞—Ç–∞–µ—Ç —Å–ª–µ–¥—É—é—â–µ–µ:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Result: 10
</code></pre>
<p>We did it! We counted from 0 to 10, which may not seem very impressive, but it did teach us a lot about <code>Mutex&lt;T&gt;</code> and thread safety. You could also use this program‚Äôs structure to do more complicated operations than just incrementing a counter. Using this strategy, you can divide a calculation into independent parts, split those parts across threads, and then use a <code>Mutex&lt;T&gt;</code> to have each thread update the final result with its part.</p>
<p>Note that if you are doing simple numerical operations, there are types simpler than <code>Mutex&lt;T&gt;</code> types provided by the <a href="../std/sync/atomic/index.html"><code>std::sync::atomic</code> module of the standard library</a><!-- ignore -->. These types provide safe, concurrent, atomic access to primitive types. We chose to use <code>Mutex&lt;T&gt;</code> with a primitive type for this example so we could concentrate on how <code>Mutex&lt;T&gt;</code> works.</p>
<h3 id="similarities-between-refcelltrct-and-mutextarct"><a class="header" href="#similarities-between-refcelltrct-and-mutextarct">Similarities Between <code>RefCell&lt;T&gt;</code>/<code>Rc&lt;T&gt;</code> and <code>Mutex&lt;T&gt;</code>/<code>Arc&lt;T&gt;</code></a></h3>
<p>You might have noticed that <code>counter</code> is immutable, but we could get a mutable reference to the value inside it; this means <code>Mutex&lt;T&gt;</code> provides interior mutability, as the <code>Cell</code> family does. In the same way we used <code>RefCell&lt;T&gt;</code> in Chapter 15 to allow us to mutate contents inside an <code>Rc&lt;T&gt;</code>, we use <code>Mutex&lt;T&gt;</code> to mutate contents inside an <code>Arc&lt;T&gt;</code>.</p>
<p>Another detail to note is that Rust can‚Äôt protect you from all kinds of logic errors when you use <code>Mutex&lt;T&gt;</code>. Recall from Chapter 15 that using <code>Rc&lt;T&gt;</code> came with the risk of creating reference cycles, where two <code>Rc&lt;T&gt;</code> values refer to each other, causing memory leaks. Similarly, <code>Mutex&lt;T&gt;</code> comes with the risk of creating <em>deadlocks</em>. These occur when an operation needs to lock two resources and two threads have each acquired one of the locks, causing them to wait for each other forever. If you‚Äôre interested in deadlocks, try creating a Rust program that has a deadlock; then research deadlock mitigation strategies for mutexes in any language and have a go at implementing them in Rust. The standard library API documentation for <code>Mutex&lt;T&gt;</code> and <code>MutexGuard</code> offers useful information.</p>
<p>We‚Äôll round out this chapter by talking about the <code>Send</code> and <code>Sync</code> traits and how we can use them with custom types.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–†–∞—Å—à–∏—Ä—è–µ–º—ã–π-–ø–∞—Ä–∞–ª–ª–µ–ª–∏–∑–º-—Å-—Ç—Ä–µ–π—Ç–∞–º–∏-sync-–∏-send"><a class="header" href="#–†–∞—Å—à–∏—Ä—è–µ–º—ã–π-–ø–∞—Ä–∞–ª–ª–µ–ª–∏–∑–º-—Å-—Ç—Ä–µ–π—Ç–∞–º–∏-sync-–∏-send">–†–∞—Å—à–∏—Ä—è–µ–º—ã–π –ø–∞—Ä–∞–ª–ª–µ–ª–∏–∑–º —Å —Ç—Ä–µ–π—Ç–∞–º–∏ <code>Sync</code> –∏ <code>Send</code></a></h2>
<p>Interestingly, the Rust language has <em>very</em> few concurrency features. Almost every concurrency feature we‚Äôve talked about so far in this chapter has been part of the standard library, not the language. Your options for handling concurrency are not limited to the language or the standard library; you can write your own concurrency features or use those written by others.</p>
<p>However, two concurrency concepts are embedded in the language: the <code>std::marker</code> traits <code>Sync</code> and <code>Send</code>.</p>
<h3 id="allowing-transference-of-ownership-between-threads-with-send"><a class="header" href="#allowing-transference-of-ownership-between-threads-with-send">Allowing Transference of Ownership Between Threads with <code>Send</code></a></h3>
<p>The <code>Send</code> marker trait indicates that ownership of values of the type implementing <code>Send</code> can be transferred between threads. Almost every Rust type is <code>Send</code>, but there are some exceptions, including <code>Rc&lt;T&gt;</code>: this cannot be <code>Send</code> because if you cloned an <code>Rc&lt;T&gt;</code> value and tried to transfer ownership of the clone to another thread, both threads might update the reference count at the same time. For this reason, <code>Rc&lt;T&gt;</code> is implemented for use in single-threaded situations where you don‚Äôt want to pay the thread-safe performance penalty.</p>
<p>Therefore, Rust‚Äôs type system and trait bounds ensure that you can never accidentally send an <code>Rc&lt;T&gt;</code> value across threads unsafely. When we tried to do this in Listing 16-14, we got the error <code>the trait Send is not implemented for Rc&lt;Mutex&lt;i32&gt;&gt;</code>. When we switched to <code>Arc&lt;T&gt;</code>, which is <code>Send</code>, the code compiled.</p>
<p>Any type composed entirely of <code>Send</code> types is automatically marked as <code>Send</code> as well. Almost all primitive types are <code>Send</code>, aside from raw pointers, which we‚Äôll discuss in Chapter 20.</p>
<h3 id="allowing-access-from-multiple-threads-with-sync"><a class="header" href="#allowing-access-from-multiple-threads-with-sync">Allowing Access from Multiple Threads with <code>Sync</code></a></h3>
<p>The <code>Sync</code> marker trait indicates that it is safe for the type implementing <code>Sync</code> to be referenced from multiple threads. In other words, any type <code>T</code> is <code>Sync</code> if <code>&amp;T</code> (an immutable reference to <code>T</code>) is <code>Send</code>, meaning the reference can be sent safely to another thread. Similar to <code>Send</code>, primitive types are <code>Sync</code>, and types composed entirely of types that are <code>Sync</code> are also <code>Sync</code>.</p>
<p>The smart pointer <code>Rc&lt;T&gt;</code> is also not <code>Sync</code> for the same reasons that it‚Äôs not <code>Send</code>. The <code>RefCell&lt;T&gt;</code> type (which we talked about in Chapter 15) and the family of related <code>Cell&lt;T&gt;</code> types are not <code>Sync</code>. The implementation of borrow checking that <code>RefCell&lt;T&gt;</code> does at runtime is not thread-safe. The smart pointer <code>Mutex&lt;T&gt;</code> is <code>Sync</code> and can be used to share access with multiple threads as you saw in <a href="ch16-03-shared-state.html#sharing-a-mutext-between-multiple-threads">‚ÄúSharing a <code>Mutex&lt;T&gt;</code> Between Multiple Threads‚Äù</a><!-- ignore -->.</p>
<h3 id="implementing-send-and-sync-manually-is-unsafe"><a class="header" href="#implementing-send-and-sync-manually-is-unsafe">Implementing <code>Send</code> and <code>Sync</code> Manually Is Unsafe</a></h3>
<p>Because types that are made up of <code>Send</code> and <code>Sync</code> traits are automatically also <code>Send</code> and <code>Sync</code>, we don‚Äôt have to implement those traits manually. As marker traits, they don‚Äôt even have any methods to implement. They‚Äôre just useful for enforcing invariants related to concurrency.</p>
<p>Manually implementing these traits involves implementing unsafe Rust code. We‚Äôll talk about using unsafe Rust code in Chapter 20; for now, the important information is that building new concurrent types not made up of <code>Send</code> and <code>Sync</code> parts requires careful thought to uphold the safety guarantees. <a href="../nomicon/index.html">‚ÄúThe Rustonomicon‚Äù</a> has more information about these guarantees and how to uphold them.</p>
<h2 id="–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-15"><a class="header" href="#–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-15">–ü–æ–¥–≤–µ–¥—ë–º –∏—Ç–æ–≥–∏</a></h2>
<p>This isn‚Äôt the last you‚Äôll see of concurrency in this book: the whole next chapter focuses on async programming, and the project in Chapter 21 will use the concepts in this chapter in a more realistic situation than the smaller examples discussed here.</p>
<p>As mentioned earlier, because very little of how Rust handles concurrency is part of the language, many concurrency solutions are implemented as crates. These evolve more quickly than the standard library, so be sure to search online for the current, state-of-the-art crates to use in multithreaded situations.</p>
<p>The Rust standard library provides channels for message passing and smart pointer types, such as <code>Mutex&lt;T&gt;</code> and <code>Arc&lt;T&gt;</code>, that are safe to use in concurrent contexts. The type system and the borrow checker ensure that the code using these solutions won‚Äôt end up with data races or invalid references. Once you get your code to compile, you can rest assured that it will happily run on multiple threads without the kinds of hard-to-track-down bugs common in other languages. Concurrent programming is no longer a concept to be afraid of: go forth and make your programs concurrent, fearlessly!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fundamentals-of-asynchronous-programming-async-await-futures-and-streams"><a class="header" href="#fundamentals-of-asynchronous-programming-async-await-futures-and-streams">Fundamentals of Asynchronous Programming: Async, Await, Futures, and Streams</a></h1>
<p>Many operations we ask the computer to do can take a while to finish. It would be nice if we could do something else while we are waiting for those long-running processes to complete. Modern computers offer two techniques for working on more than one operation at a time: parallelism and concurrency. Once we start writing programs that involve parallel or concurrent operations, though, we quickly encounter new challenges inherent to <em>asynchronous programming</em>, where operations may not finish sequentially in the order they were started. This chapter builds on Chapter 16‚Äôs use of threads for parallelism and concurrency by introducing an alternative approach to asynchronous programming: Rust‚Äôs Futures, Streams, the <code>async</code> and <code>await</code> syntax that supports them, and the tools for managing and coordinating between asynchronous operations.</p>
<p>Let‚Äôs consider an example. Say you‚Äôre exporting a video you‚Äôve created of a family celebration, an operation that could take anywhere from minutes to hours. The video export will use as much CPU and GPU power as it can. If you had only one CPU core and your operating system didn‚Äôt pause that export until it completed‚Äîthat is, if it executed the export <em>synchronously</em>‚Äîyou couldn‚Äôt do anything else on your computer while that task was running. That would be a pretty frustrating experience. Fortunately, your computer‚Äôs operating system can, and does, invisibly interrupt the export often enough to let you get other work done simultaneously.</p>
<p>Now say you‚Äôre downloading a video shared by someone else, which can also take a while but does not take up as much CPU time. In this case, the CPU has to wait for data to arrive from the network. While you can start reading the data once it starts to arrive, it might take some time for all of it to show up. Even once the data is all present, if the video is quite large, it could take at least a second or two to load it all. That might not sound like much, but it‚Äôs a very long time for a modern processor, which can perform billions of operations every second. Again, your operating system will invisibly interrupt your program to allow the CPU to perform other work while waiting for the network call to finish.</p>
<p>The video export is an example of a <em>CPU-bound</em> or <em>compute-bound</em> operation. It‚Äôs limited by the computer‚Äôs potential data processing speed within the CPU or GPU, and how much of that speed it can dedicate to the operation. The video download is an example of an <em>IO-bound</em> operation, because it‚Äôs limited by the speed of the computer‚Äôs <em>input and output</em>; it can only go as fast as the data can be sent across the network.</p>
<p>In both of these examples, the operating system‚Äôs invisible interrupts provide a form of concurrency. That concurrency happens only at the level of the entire program, though: the operating system interrupts one program to let other programs get work done. In many cases, because we understand our programs at a much more granular level than the operating system does, we can spot opportunities for concurrency that the operating system can‚Äôt see.</p>
<p>For example, if we‚Äôre building a tool to manage file downloads, we should be able to write our program so that starting one download won‚Äôt lock up the UI, and users should be able to start multiple downloads at the same time. Many operating system APIs for interacting with the network are <em>blocking</em>, though; that is, they block the program‚Äôs progress until the data they‚Äôre processing is completely ready.</p>
<blockquote>
<p>Note: This is how <em>most</em> function calls work, if you think about it. However, the term <em>blocking</em> is usually reserved for function calls that interact with files, the network, or other resources on the computer, because those are the cases where an individual program would benefit from the operation being <em>non</em>-blocking.</p>
</blockquote>
<p>We could avoid blocking our main thread by spawning a dedicated thread to download each file. However, the overhead of those threads would eventually become a problem. It would be preferable if the call didn‚Äôt block in the first place. It would also be better if we could write in the same direct style we use in blocking code, similar to this:</p>
<pre><code class="language-rust ignore does_not_compile">let data = fetch_data_from(url).await;
println!("{data}");</code></pre>
<p>That is exactly what Rust‚Äôs <em>async</em> (short for <em>asynchronous</em>) abstraction gives us. In this chapter, you‚Äôll learn all about async as we cover the following topics:</p>
<ul>
<li>How to use Rust‚Äôs <code>async</code> and <code>await</code> syntax</li>
<li>How to use the async model to solve some of the same challenges we looked at in Chapter 16</li>
<li>How multithreading and async provide complementary solutions, that you can combine in many cases</li>
</ul>
<p>Before we see how async works in practice, though, we need to take a short detour to discuss the differences between parallelism and concurrency.</p>
<h3 id="parallelism-and-concurrency"><a class="header" href="#parallelism-and-concurrency">Parallelism and Concurrency</a></h3>
<p>We‚Äôve treated parallelism and concurrency as mostly interchangeable so far. Now we need to distinguish between them more precisely, because the differences will show up as we start working.</p>
<p>Consider the different ways a team could split up work on a software project. You could assign a single member multiple tasks, assign each member one task, or use a mix of the two approaches.</p>
<p>When an individual works on several different tasks before any of them is complete, this is <em>concurrency</em>. Maybe you have two different projects checked out on your computer, and when you get bored or stuck on one project, you switch to the other. You‚Äôre just one person, so you can‚Äôt make progress on both tasks at the exact same time, but you can multi-task, making progress on one at a time by switching between them (see Figure 17-1).</p>
<figure>
<img src="img/trpl17-01.svg" class="center" alt="A diagram with boxes labeled Task A and Task B, with diamonds in them representing subtasks. There are arrows pointing from A1 to B1, B1 to A2, A2 to B2, B2 to A3, A3 to A4, and A4 to B3. The arrows between the subtasks cross the boxes between Task A and Task B." />
<figcaption>Figure 17-1: A concurrent workflow, switching between Task A and Task B</figcaption>
</figure>
<p>When the team splits up a group of tasks by having each member take one task and work on it alone, this is <em>parallelism</em>. Each person on the team can make progress at the exact same time (see Figure 17-2).</p>
<figure>
<img src="img/trpl17-02.svg" class="center" alt="A diagram with boxes labeled Task A and Task B, with diamonds in them representing subtasks. There are arrows pointing from A1 to A2, A2 to A3, A3 to A4, B1 to B2, and B2 to B3. No arrows cross between the boxes for Task A and Task B." />
<figcaption>Figure 17-2: A parallel workflow, where work happens on Task A and Task B independently</figcaption>
</figure>
<p>In both of these workflows, you might have to coordinate between different tasks. Maybe you <em>thought</em> the task assigned to one person was totally independent from everyone else‚Äôs work, but it actually requires another person on the team to finish their task first. Some of the work could be done in parallel, but some of it was actually <em>serial</em>: it could only happen in a series, one task after the other, as in Figure 17-3.</p>
<figure>
<img src="img/trpl17-03.svg" class="center" alt="A diagram with boxes labeled Task A and Task B, with diamonds in them representing subtasks. There are arrows pointing from A1 to A2, A2 to a pair of thick vertical lines like a ‚Äúpause‚Äù symbol, from that symbol to A3, B1 to B2, B2 to B3, which is below that symbol, B3 to A3, and B3 to B4." />
<figcaption>Figure 17-3: A partially parallel workflow, where work happens on Task A and Task B independently until Task A3 is blocked on the results of Task B3.</figcaption>
</figure>
<p>Likewise, you might realize that one of your own tasks depends on another of your tasks. Now your concurrent work has also become serial.</p>
<p>Parallelism and concurrency can intersect with each other, too. If you learn that a colleague is stuck until you finish one of your tasks, you‚Äôll probably focus all your efforts on that task to ‚Äúunblock‚Äù your colleague. You and your coworker are no longer able to work in parallel, and you‚Äôre also no longer able to work concurrently on your own tasks.</p>
<p>The same basic dynamics come into play with software and hardware. On a machine with a single CPU core, the CPU can perform only one operation at a time, but it can still work concurrently. Using tools such as threads, processes, and async, the computer can pause one activity and switch to others before eventually cycling back to that first activity again. On a machine with multiple CPU cores, it can also do work in parallel. One core can be performing one task while another core performs a completely unrelated one, and those operations actually happen at the same time.</p>
<p>When working with async in Rust, we‚Äôre always dealing with concurrency. Depending on the hardware, the operating system, and the async runtime we are using (more on async runtimes shortly), that concurrency may also use parallelism under the hood.</p>
<p>Now, let‚Äôs dive into how async programming in Rust actually works.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="futures-and-the-async-syntax"><a class="header" href="#futures-and-the-async-syntax">Futures and the Async Syntax</a></h2>
<p>The key elements of asynchronous programming in Rust are <em>futures</em> and Rust‚Äôs <code>async</code> and <code>await</code> keywords.</p>
<p>A <em>future</em> is a value that may not be ready now but will become ready at some point in the future. (This same concept shows up in many languages, sometimes under other names such as <em>task</em> or <em>promise</em>.) Rust provides a <code>Future</code> trait as a building block so that different async operations can be implemented with different data structures but with a common interface. In Rust, futures are types that implement the <code>Future</code> trait. Each future holds its own information about the progress that has been made and what "ready" means.</p>
<p>You can apply the <code>async</code> keyword to blocks and functions to specify that they can be interrupted and resumed. Within an async block or async function, you can use the <code>await</code> keyword to <em>await a future</em> (that is, wait for it to become ready). Any point where you await a future within an async block or function is a potential spot for that async block or function to pause and resume. The process of checking with a future to see if its value is available yet is called <em>polling</em>.</p>
<p>Some other languages, such as C# and JavaScript, also use <code>async</code> and <code>await</code> keywords for async programming. If you‚Äôre familiar with those languages, you may notice some significant differences in how Rust does things, including how it handles the syntax. That‚Äôs for good reason, as we‚Äôll see!</p>
<p>When writing async Rust, we use the <code>async</code> and <code>await</code> keywords most of the time. Rust compiles them into equivalent code using the <code>Future</code> trait, much as it compiles <code>for</code> loops into equivalent code using the <code>Iterator</code> trait. Because Rust provides the <code>Future</code> trait, though, you can also implement it for your own data types when you need to. Many of the functions we‚Äôll see throughout this chapter return types with their own implementations of <code>Future</code>. We‚Äôll return to the definition of the trait at the end of the chapter and dig into more of how it works, but this is enough detail to keep us moving forward.</p>
<p>This may all feel a bit abstract, so let‚Äôs write our first async program: a little web scraper. We‚Äôll pass in two URLs from the command line, fetch both of them concurrently, and return the result of whichever one finishes first. This example will have a fair bit of new syntax, but don‚Äôt worry‚Äîwe‚Äôll explain everything you need to know as we go.</p>
<h2 id="our-first-async-program"><a class="header" href="#our-first-async-program">Our First Async Program</a></h2>
<p>To keep the focus of this chapter on learning async rather than juggling parts of the ecosystem, we‚Äôve created the <code>trpl</code> crate (<code>trpl</code> is short for ‚ÄúThe Rust Programming Language‚Äù). It re-exports all the types, traits, and functions you‚Äôll need, primarily from the <a href="https://crates.io/crates/futures"><code>futures</code></a><!-- ignore --> and <a href="https://tokio.rs"><code>tokio</code></a><!-- ignore --> crates. The <code>futures</code> crate is an official home for Rust experimentation for async code, and it‚Äôs actually where the <code>Future</code> trait was originally designed. Tokio is the most widely used async runtime in Rust today, especially for web applications. There are other great runtimes out there, and they may be more suitable for your purposes. We use the <code>tokio</code> crate under the hood for <code>trpl</code> because it‚Äôs well tested and widely used.</p>
<p>In some cases, <code>trpl</code> also renames or wraps the original APIs to keep you focused on the details relevant to this chapter. If you want to understand what the crate does, we encourage you to check out <a href="https://github.com/rust-lang/book/tree/main/packages/trpl">its source code</a><!-- ignore -->. You‚Äôll be able to see what crate each re-export comes from, and we‚Äôve left extensive comments explaining what the crate does.</p>
<p>Create a new binary project named <code>hello-async</code> and add the <code>trpl</code> crate as a dependency:</p>
<pre><code class="language-console">$ cargo new hello-async
$ cd hello-async
$ cargo add trpl
</code></pre>
<p>Now we can use the various pieces provided by <code>trpl</code> to write our first async program. We‚Äôll build a little command line tool that fetches two web pages, pulls the <code>&lt;title&gt;</code> element from each, and prints out the title of whichever page finishes that whole process first.</p>
<h3 id="defining-the-page_title-function"><a class="header" href="#defining-the-page_title-function">Defining the page_title Function</a></h3>
<p>Let‚Äôs start by writing a function that takes one page URL as a parameter, makes a request to it, and returns the text of the title element (see Listing 17-1).</p>
<Listing number="17-1" file-name="src/main.rs" caption="Defining an async function to get the title element from an HTML page">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // TODO: we'll add this next!
</span><span class="boring">}
</span><span class="boring">
</span>use trpl::Html;

async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
    let response = trpl::get(url).await;
    let response_text = response.text().await;
    Html::parse(&amp;response_text)
        .select_first("title")
        .map(|title_element| title_element.inner_html())
}</code></pre></pre>
</Listing>
<p>First, we define a function named <code>page_title</code> and mark it with the <code>async</code> keyword. Then we use the <code>trpl::get</code> function to fetch whatever URL is passed in and add the <code>await</code> keyword to await the response. To get the text of the response, we call its <code>text</code> method, and once again await it with the <code>await</code> keyword. Both of these steps are asynchronous. For the <code>get</code> function, we have to wait for the server to send back the first part of its response, which will include HTTP headers, cookies, and so on, and can be delivered separately from the response body. Especially if the body is very large, it can take some time for it all to arrive. Because we have to wait for the <em>entirety</em> of the response to arrive, the <code>text</code> method is also async.</p>
<p>We have to explicitly await both of these futures, because futures in Rust are <em>lazy</em>: they don‚Äôt do anything until you ask them to with the <code>await</code> keyword. (In fact, Rust will show a compiler warning if you don‚Äôt use a future.) This might remind you of Chapter 13‚Äôs discussion of iterators in the section <a href="ch13-02-iterators.html">Processing a Series of Items With Iterators</a><!-- ignore -->. Iterators do nothing unless you call their <code>next</code> method‚Äîwhether directly or by using <code>for</code> loops or methods such as <code>map</code> that use <code>next</code> under the hood. Likewise, futures do nothing unless you explicitly ask them to. This laziness allows Rust to avoid running async code until it‚Äôs actually needed.</p>
<blockquote>
<p>Note: This is different from the behavior we saw in the previous chapter when using <code>thread::spawn</code> in <a href="ch16-01-threads.html#creating-a-new-thread-with-spawn">Creating a New Thread with spawn</a><!--ignore-->, where the closure we passed to another thread started running immediately. It‚Äôs also different from how many other languages approach async. But it‚Äôs important for Rust, and we‚Äôll see why later.</p>
</blockquote>
<p>Once we have <code>response_text</code>, we can parse it into an instance of the <code>Html</code> type using <code>Html::parse</code>. Instead of a raw string, we now have a data type we can use to work with the HTML as a richer data structure. In particular, we can use the <code>select_first</code> method to find the first instance of a given CSS selector. By passing the string <code>"title"</code>, we‚Äôll get the first <code>&lt;title&gt;</code> element in the document, if there is one. Because there may not be any matching element, <code>select_first</code> returns an <code>Option&lt;ElementRef&gt;</code>. Finally, we use the <code>Option::map</code> method, which lets us work with the item in the <code>Option</code> if it‚Äôs present, and do nothing if it isn‚Äôt. (We could also use a <code>match</code> expression here, but <code>map</code> is more idiomatic.) In the body of the function we supply to <code>map</code>, we call <code>inner_html</code> on the <code>title_element</code> to get its content, which is a <code>String</code>. When all is said and done, we have an <code>Option&lt;String&gt;</code>.</p>
<p>Notice that Rust‚Äôs <code>await</code> keyword goes <em>after</em> the expression you‚Äôre awaiting, not before it. That is, it‚Äôs a <em>postfix</em> keyword. This may differ from what you‚Äôre used to if you‚Äôve used <code>async</code> in other languages, but in Rust it makes chains of methods much nicer to work with. As a result, we can change the body of <code>page_url_for</code> to chain the <code>trpl::get</code> and <code>text</code> function calls together with <code>await</code> between them, as shown in Listing 17-2.</p>
<Listing number="17-2" file-name="src/main.rs" caption="Chaining with the `await` keyword">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use trpl::Html;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // TODO: we'll add this next!
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
</span>    let response_text = trpl::get(url).await.text().await;
<span class="boring">    Html::parse(&amp;response_text)
</span><span class="boring">        .select_first("title")
</span><span class="boring">        .map(|title_element| title_element.inner_html())
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>With that, we have successfully written our first async function! Before we add some code in <code>main</code> to call it, let‚Äôs talk a little more about what we‚Äôve written and what it means.</p>
<p>When Rust sees a block marked with the <code>async</code> keyword, it compiles it into a unique, anonymous data type that implements the <code>Future</code> trait. When Rust sees a function marked with <code>async</code>, it compiles it into a non-async function whose body is an async block. An async function‚Äôs return type is the type of the anonymous data type the compiler creates for that async block.</p>
<p>Thus, writing <code>async fn</code> is equivalent to writing a function that returns a <em>future</em> of the return type. To the compiler, a function definition such as the <code>async fn page_title</code> in Listing 17-1 is equivalent to a non-async function defined like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate trpl; // required for mdbook test
</span>use std::future::Future;
use trpl::Html;

fn page_title(url: &amp;str) -&gt; impl Future&lt;Output = Option&lt;String&gt;&gt; + '_ {
    async move {
        let text = trpl::get(url).await.text().await;
        Html::parse(&amp;text)
            .select_first("title")
            .map(|title| title.inner_html())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Let‚Äôs walk through each part of the transformed version:</p>
<ul>
<li>It uses the <code>impl Trait</code> syntax we discussed back in Chapter 10 in the <a href="ch10-02-traits.html#traits-as-parameters">‚ÄúTraits as Parameters‚Äù</a><!-- ignore --> section.</li>
<li>The returned trait is a <code>Future</code> with an associated type of <code>Output</code>. Notice that the <code>Output</code> type is <code>Option&lt;String&gt;</code>, which is the same as the original return type from the <code>async fn</code> version of <code>page_title</code>.</li>
<li>All of the code called in the body of the original function is wrapped in an <code>async move</code> block. Remember that blocks are expressions. This whole block is the expression returned from the function.</li>
<li>This async block produces a value with the type <code>Option&lt;String&gt;</code>, as just described. That value matches the <code>Output</code> type in the return type. This is just like other blocks you have seen.</li>
<li>The new function body is an <code>async move</code> block because of how it uses the <code>url</code> parameter. (We‚Äôll talk much more about <code>async</code> versus <code>async move</code> later in the chapter.)</li>
<li>The new version of the function has a kind of lifetime we haven‚Äôt seen before in the output type: <code>'_</code>. Because the function returns a future that refers to a reference‚Äîin this case, the reference from the <code>url</code> parameter‚Äîwe need to tell Rust that we want that reference to be included. We don‚Äôt have to name the lifetime here, because Rust is smart enough to know there‚Äôs only one reference that could be involved, but we <em>do</em> have to be explicit that the resulting future is bound by that lifetime.</li>
</ul>
<p>Now we can call <code>page_title</code> in <code>main</code>.</p>
<h2 id="determining-a-single-pages-title"><a class="header" href="#determining-a-single-pages-title">Determining a Single Page‚Äôs Title</a></h2>
<p>To start, we‚Äôll just get the title for a single page. In Listing 17-3, we follow the same pattern we used in Chapter 12 to get command line arguments in the <a href="ch12-01-accepting-command-line-arguments.html">Accepting Command Line Arguments</a><!-- ignore --> section. Then we pass the first URL <code>page_title</code> and await the result. Because the value produced by the future is an <code>Option&lt;String&gt;</code>, we use a <code>match</code> expression to print different messages to account for whether the page had a <code>&lt;title&gt;</code>.</p>
<Listing number="17-3" file-name="src/main.rs" caption="Calling the `page_title` function from `main` with a user-supplied argument">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use trpl::Html;
</span><span class="boring">
</span>async fn main() {
    let args: Vec&lt;String&gt; = std::env::args().collect();
    let url = &amp;args[1];
    match page_title(url).await {
        Some(title) =&gt; println!("The title for {url} was {title}"),
        None =&gt; println!("{url} had no title"),
    }
}
<span class="boring">
</span><span class="boring">async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
</span><span class="boring">    let response_text = trpl::get(url).await.text().await;
</span><span class="boring">    Html::parse(&amp;response_text)
</span><span class="boring">        .select_first("title")
</span><span class="boring">        .map(|title_element| title_element.inner_html())
</span><span class="boring">}</span></code></pre>
</Listing>
<p>Unfortunately, this code doesn‚Äôt compile. The only place we can use the <code>await</code> keyword is in async functions or blocks, and Rust won‚Äôt let us mark the special <code>main</code> function as <code>async</code>.</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-03
cargo build
copy just the compiler error
-->
<pre><code class="language-text">error[E0752]: `main` function is not allowed to be `async`
 --&gt; src/main.rs:6:1
  |
6 | async fn main() {
  | ^^^^^^^^^^^^^^^ `main` function is not allowed to be `async`
</code></pre>
<p>The reason <code>main</code> can‚Äôt be marked <code>async</code> is that async code needs a <em>runtime</em>: a Rust crate that manages the details of executing asynchronous code. A program‚Äôs <code>main</code> function can <em>initialize</em> a runtime, but it‚Äôs not a runtime <em>itself</em>. (We‚Äôll see more about why this is the case in a bit.) Every Rust program that executes async code has at least one place where it sets up a runtime and executes the futures.</p>
<p>Most languages that support async bundle a runtime, but Rust does not. Instead, there are many different async runtimes available, each of which makes different tradeoffs suitable to the use case it targets. For example, a high-throughput web server with many CPU cores and a large amount of RAM has very different needs than a microcontroller with a single core, a small amount of RAM, and no heap allocation ability. The crates that provide those runtimes also often supply async versions of common functionality such as file or network I/O.</p>
<p>Here, and throughout the rest of this chapter, we‚Äôll use the <code>run</code> function from the <code>trpl</code> crate, which takes a future as an argument and runs it to completion. Behind the scenes, calling <code>run</code> sets up a runtime that‚Äôs used to run the future passed in. Once the future completes, <code>run</code> returns whatever value the future produced.</p>
<p>We could pass the future returned by <code>page_title</code> directly to <code>run</code>, and once it completed, we could match on the resulting <code>Option&lt;String&gt;</code>, as we tried to do in Listing 17-3. However, for most of the examples in the chapter (and most async code in the real world), we‚Äôll be doing more than just one async function call, so instead we‚Äôll pass an <code>async</code> block and explicitly await the result of the <code>page_title</code> call, as in Listing 17-4.</p>
<Listing number="17-4" caption="Awaiting an async block with `trpl::run`" file-name="src/main.rs">
<!-- should_panic,noplayground because mdbook test does not pass args -->
<pre><code class="language-rust should_panic noplayground"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use trpl::Html;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = std::env::args().collect();

    trpl::run(async {
        let url = &amp;args[1];
        match page_title(url).await {
            Some(title) =&gt; println!("The title for {url} was {title}"),
            None =&gt; println!("{url} had no title"),
        }
    })
}
<span class="boring">
</span><span class="boring">async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
</span><span class="boring">    let response_text = trpl::get(url).await.text().await;
</span><span class="boring">    Html::parse(&amp;response_text)
</span><span class="boring">        .select_first("title")
</span><span class="boring">        .map(|title_element| title_element.inner_html())
</span><span class="boring">}</span></code></pre>
</Listing>
<p>When we run this code, we get the behavior we expected initially:</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-04
cargo build # skip all the build noise
cargo run https://www.rust-lang.org
# copy the output here
-->
<pre><code class="language-console">$ cargo run -- https://www.rust-lang.org
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.05s
     Running `target/debug/async_await 'https://www.rust-lang.org'`
The title for https://www.rust-lang.org was
            Rust Programming Language
</code></pre>
<p>Phew‚Äîwe finally have some working async code! But before we add the code to race the two sites against each other, let‚Äôs briefly turn our attention back to how futures work.</p>
<p>Each <em>await point</em>‚Äîthat is, every place where the code uses the <code>await</code> keyword‚Äîrepresents a place where control is handed back to the runtime. To make that work, Rust needs to keep track of the state involved in the async block so that the runtime can kick off some other work and then come back when it‚Äôs ready to try advancing the first one again. This is an invisible state machine, as if you‚Äôd written an enum like this to save the current state at each await point:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>enum PageTitleFuture&lt;'a&gt; {
    Initial { url: &amp;'a str },
    GetAwaitPoint { url: &amp;'a str },
    TextAwaitPoint { response: trpl::Response },
}
<span class="boring">}</span></code></pre></pre>
<p>Writing the code to transition between each state by hand would be tedious and error-prone, however, especially when you need to add more functionality and more states to the code later. Fortunately, the Rust compiler creates and manages the state machine data structures for async code automatically. The normal borrowing and ownership rules around data structures all still apply, and happily, the compiler also handles checking those for us and provides useful error messages. We‚Äôll work through a few of those later in the chapter.</p>
<p>Ultimately, something has to execute this state machine, and that something is a runtime. (This is why you may come across references to <em>executors</em> when looking into runtimes: an executor is the part of a runtime responsible for executing the async code.)</p>
<p>Now you can see why the compiler stopped us from making <code>main</code> itself an async function back in Listing 17-3. If <code>main</code> were an async function, something else would need to manage the state machine for whatever future <code>main</code> returned, but <code>main</code> is the starting point for the program! Instead, we called the <code>trpl::run</code> function in <code>main</code> to set up a runtime and run the future returned by the <code>async</code> block until it returns <code>Ready</code>.</p>
<blockquote>
<p>Note: Some runtimes provide macros so you <em>can</em> write an async <code>main</code> function. Those macros rewrite <code>async fn main() { ... }</code> to be a normal <code>fn main</code>, which does the same thing we did by hand in Listing 17-5: call a function that runs a future to completion the way <code>trpl::run</code> does.</p>
</blockquote>
<p>Now let‚Äôs put these pieces together and see how we can write concurrent code.</p>
<h3 id="racing-our-two-urls-against-each-other"><a class="header" href="#racing-our-two-urls-against-each-other">Racing Our Two URLs Against Each Other</a></h3>
<p>In Listing 17-5, we call <code>page_title</code> with two different URLs passed in from the command line and race them.</p>
<Listing number="17-5" caption="" file-name="src/main.rs">
<!-- should_panic,noplayground because mdbook does not pass args -->
<pre><code class="language-rust should_panic noplayground"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use trpl::{Either, Html};

fn main() {
    let args: Vec&lt;String&gt; = std::env::args().collect();

    trpl::run(async {
        let title_fut_1 = page_title(&amp;args[1]);
        let title_fut_2 = page_title(&amp;args[2]);

        let (url, maybe_title) =
            match trpl::race(title_fut_1, title_fut_2).await {
                Either::Left(left) =&gt; left,
                Either::Right(right) =&gt; right,
            };

        println!("{url} returned first");
        match maybe_title {
            Some(title) =&gt; println!("Its page title is: '{title}'"),
            None =&gt; println!("Its title could not be parsed."),
        }
    })
}

async fn page_title(url: &amp;str) -&gt; (&amp;str, Option&lt;String&gt;) {
    let text = trpl::get(url).await.text().await;
    let title = Html::parse(&amp;text)
        .select_first("title")
        .map(|title| title.inner_html());
    (url, title)
}</code></pre>
</Listing>
<p>We begin by calling <code>page_title</code> for each of the user-supplied URLs. We save the resulting futures as <code>title_fut_1</code> and <code>title_fut_2</code>. Remember, these don‚Äôt do anything yet, because futures are lazy and we haven‚Äôt yet awaited them. Then we pass the futures to <code>trpl::race</code>, which returns a value to indicate which of the futures passed to it finishes first.</p>
<blockquote>
<p>Note: Under the hood, <code>race</code> is built on a more general function, <code>select</code>, which you will encounter more often in real-world Rust code. A <code>select</code> function can do a lot of things that the <code>trpl::race</code> function can‚Äôt, but it also has some additional complexity that we can skip over for now.</p>
</blockquote>
<p>Either future can legitimately ‚Äúwin,‚Äù so it doesn‚Äôt make sense to return a <code>Result</code>. Instead, <code>race</code> returns a type we haven‚Äôt seen before, <code>trpl::Either</code>. The <code>Either</code> type is somewhat similar to a <code>Result</code> in that it has two cases. Unlike <code>Result</code>, though, there is no notion of success or failure baked into <code>Either</code>. Instead, it uses <code>Left</code> and <code>Right</code> to indicate ‚Äúone or the other‚Äù:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Either&lt;A, B&gt; {
    Left(A),
    Right(B),
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>race</code> function returns <code>Left</code> with that future‚Äôs output if the first argument wins, and <code>Right</code> with the second future argument‚Äôs output if <em>that</em> one wins. This matches the order the arguments appear in when calling the function: the first argument is to the left of the second argument.</p>
<p>We also update <code>page_title</code> to return the same URL passed in. That way, if the page that returns first does not have a <code>&lt;title&gt;</code> we can resolve, we can still print a meaningful message. With that information available, we wrap up by updating our <code>println!</code> output to indicate both which URL finished first and what, if any, the <code>&lt;title&gt;</code> is for the web page at that URL.</p>
<p>You have built a small working web scraper now! Pick a couple URLs and run the command line tool. You may discover that some sites are consistently faster than others, while in other cases the faster site varies from run to run. More importantly, you‚Äôve learned the basics of working with futures, so now we can dig deeper into what we can do with async.</p>
<!-- TODO: map source link version to version of Rust? -->
<div style="break-before: page; page-break-before: always;"></div><h2 id="applying-concurrency-with-async"><a class="header" href="#applying-concurrency-with-async">Applying Concurrency with Async</a></h2>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="concurrency-with-async"></a></p>
<p>In this section, we‚Äôll apply async to some of the same concurrency challenges we tackled with threads in chapter 16. Because we already talked about a lot of the key ideas there, in this section we‚Äôll focus on what‚Äôs different between threads and futures.</p>
<p>In many cases, the APIs for working with concurrency using async are very similar to those for using threads. In other cases, they end up being quite different. Even when the APIs <em>look</em> similar between threads and async, they often have different behavior‚Äîand they nearly always have different performance characteristics.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="counting"></a></p>
<h3 id="creating-a-new-task-with-spawn_task"><a class="header" href="#creating-a-new-task-with-spawn_task">Creating a New Task with <code>spawn_task</code></a></h3>
<p>The first operation we tackled in <a href="ch16-01-threads.html#creating-a-new-thread-with-spawn">Creating a New Thread with Spawn</a><!-- ignore --> was counting up on two separate threads. Let‚Äôs do the same using async. The <code>trpl</code> crate supplies a <code>spawn_task</code> function that looks very similar to the <code>thread::spawn</code> API, and a <code>sleep</code> function that is an async version of the <code>thread::sleep</code> API. We can use these together to implement the counting example, as shown in Listing 17-6.</p>
<Listing number="17-6" caption="Creating a new task to print one thing while the main task prints something else" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use std::time::Duration;

fn main() {
    trpl::run(async {
        trpl::spawn_task(async {
            for i in 1..10 {
                println!("hi number {i} from the first task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        });

        for i in 1..5 {
            println!("hi number {i} from the second task!");
            trpl::sleep(Duration::from_millis(500)).await;
        }
    });
}</code></pre></pre>
</Listing>
<p>As our starting point, we set up our <code>main</code> function with <code>trpl::run</code> so that our top-level function can be async.</p>
<blockquote>
<p>Note: From this point forward in the chapter, every example will include this exact same wrapping code with <code>trpl::run</code> in <code>main</code>, so we‚Äôll often skip it just as we do with <code>main</code>. Don‚Äôt forget to include it in your code!</p>
</blockquote>
<p>Then we write two loops within that block, each containing a <code>trpl::sleep</code> call, which waits for half a second (500 milliseconds) before sending the next message. We put one loop in the body of a <code>trpl::spawn_task</code> and the other in a top-level <code>for</code> loop. We also add an <code>await</code> after the <code>sleep</code> calls.</p>
<p>This code behaves similarly to the thread-based implementation‚Äîincluding the fact that you may see the messages appear in a different order in your own terminal when you run it:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the second task!
hi number 1 from the first task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
</code></pre>
<p>This version stops as soon as the <code>for</code> loop in the body of the main async block finishes, because the task spawned by <code>spawn_task</code> is shut down when the <code>main</code> function ends. If you want it to run all the way to the task‚Äôs completion, you will need to use a join handle to wait for the first task to complete. With threads, we used the <code>join</code> method to ‚Äúblock‚Äù until the thread was done running. In Listing 17-7, we can use <code>await</code> to do the same thing, because the task handle itself is a future. Its <code>Output</code> type is a <code>Result</code>, so we also unwrap it after awaiting it.</p>
<Listing number="17-7" caption="Using `await` with a join handle to run a task to completion" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let handle = trpl::spawn_task(async {
            for i in 1..10 {
                println!("hi number {i} from the first task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        });

        for i in 1..5 {
            println!("hi number {i} from the second task!");
            trpl::sleep(Duration::from_millis(500)).await;
        }

        handle.await.unwrap();
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>This updated version runs until <em>both</em> loops finish.</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the second task!
hi number 1 from the first task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
hi number 6 from the first task!
hi number 7 from the first task!
hi number 8 from the first task!
hi number 9 from the first task!
</code></pre>
<p>So far, it looks like async and threads give us the same basic outcomes, just with different syntax: using <code>await</code> instead of calling <code>join</code> on the join handle, and awaiting the <code>sleep</code> calls.</p>
<p>The bigger difference is that we didn‚Äôt need to spawn another operating system thread to do this. In fact, we don‚Äôt even need to spawn a task here. Because async blocks compile to anonymous futures, we can put each loop in an async block and have the runtime run them both to completion using the <code>trpl::join</code> function.</p>
<p>In the section <a href="ch16-01-threads.html#waiting-for-all-threads-to-finish-using-join-handles">Waiting for All Threads to Finishing Using <code>join</code> Handles</a><!-- ignore -->, we showed how to use the <code>join</code> method on the <code>JoinHandle</code> type returned when you call <code>std::thread::spawn</code>. The <code>trpl::join</code> function is similar, but for futures. When you give it two futures, it produces a single new future whose output is a tuple containing the output of each future you passed in once they <em>both</em> complete. Thus, in Listing 17-8, we use <code>trpl::join</code> to wait for both <code>fut1</code> and <code>fut2</code> to finish. We do <em>not</em> await <code>fut1</code> and <code>fut2</code> but instead the new future produced by <code>trpl::join</code>. We ignore the output, because it‚Äôs just a tuple containing two unit values.</p>
<Listing number="17-8" caption="Using `trpl::join` to await two anonymous futures" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let fut1 = async {
            for i in 1..10 {
                println!("hi number {i} from the first task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let fut2 = async {
            for i in 1..5 {
                println!("hi number {i} from the second task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        trpl::join(fut1, fut2).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>When we run this, we see both futures run to completion:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the first task!
hi number 1 from the second task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
hi number 6 from the first task!
hi number 7 from the first task!
hi number 8 from the first task!
hi number 9 from the first task!
</code></pre>
<p>Now, you‚Äôll see the exact same order every time, which is very different from what we saw with threads. That is because the <code>trpl::join</code> function is <em>fair</em>, meaning it checks each future equally often, alternating between them, and never lets one race ahead if the other is ready. With threads, the operating system decides which thread to check and how long to let it run. With async Rust, the runtime decides which task to check. (In practice, the details get complicated because an async runtime might use operating system threads under the hood as part of how it manages concurrency, so guaranteeing fairness can be more work for a runtime‚Äîbut it‚Äôs still possible!) Runtimes don‚Äôt have to guarantee fairness for any given operation, and they often offer different APIs to let you choose whether or not you want fairness.</p>
<p>Try some of these variations on awaiting the futures and see what they do:</p>
<ul>
<li>Remove the async block from around either or both of the loops.</li>
<li>Await each async block immediately after defining it.</li>
<li>Wrap only the first loop in an async block, and await the resulting future after the body of second loop.</li>
</ul>
<p>For an extra challenge, see if you can figure out what the output will be in each case <em>before</em> running the code!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="message-passing"></a></p>
<h3 id="counting-up-on-two-tasks-using-message-passing"><a class="header" href="#counting-up-on-two-tasks-using-message-passing">Counting Up on Two Tasks Using Message Passing</a></h3>
<p>Sharing data between futures will also be familiar: we‚Äôll use message passing again, but this time with async versions of the types and functions. We‚Äôll take a slightly different path than we did in <a href="ch16-02-message-passing.html">Using Message Passing to Transfer Data Between Threads</a><!-- ignore --> to illustrate some of the key differences between thread-based and futures-based concurrency. In Listing 17-9, we‚Äôll begin with just a single async block‚Äî<em>not</em> spawning a separate task as we spawned a separate thread.</p>
<Listing number="17-9" caption="Creating an async channel and assigning the two halves to `tx` and `rx`" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let val = String::from("hi");
        tx.send(val).unwrap();

        let received = rx.recv().await.unwrap();
        println!("Got: {received}");
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>Here, we use <code>trpl::channel</code>, an async version of the multiple-producer, single-consumer channel API we used with threads back in Chapter 16. The async version of the API is only a little different from the thread-based version: it uses a mutable rather than an immutable receiver <code>rx</code>, and its <code>recv</code> method produces a future we need to await rather than producing the value directly. Now we can send messages from the sender to the receiver. Notice that we don‚Äôt have to spawn a separate thread or even a task; we merely need to await the <code>rx.recv</code> call.</p>
<p>The synchronous <code>Receiver::recv</code> method in <code>std::mpsc::channel</code> blocks until it receives a message. The <code>trpl::Receiver::recv</code> method does not, because it is async. Instead of blocking, it hands control back to the runtime until either a message is received or the send side of the channel closes. By contrast, we don‚Äôt await the <code>send</code> call, because it doesn‚Äôt block. It doesn‚Äôt need to, because the channel we‚Äôre sending it into is unbounded.</p>
<blockquote>
<p>Note: Because all of this async code runs in an async block in a <code>trpl::run</code> call, everything within it can avoid blocking. However, the code <em>outside</em> it will block on the <code>run</code> function returning. That‚Äôs the whole point of the <code>trpl::run</code> function: it lets you <em>choose</em> where to block on some set of async code, and thus where to transition between sync and async code. In most async runtimes, <code>run</code> is actually named <code>block_on</code> for exactly this reason.</p>
</blockquote>
<p>Notice two things about this example. First, the message will arrive right away. Second, although we use a future here, there‚Äôs no concurrency yet. Everything in the listing happens in sequence, just as it would if there were no futures involved.</p>
<p>Let‚Äôs address the first part by sending a series of messages and sleeping in between them, as shown in Listing 17-10.</p>
<!-- We cannot test this one because it never stops! -->
<Listing number="17-10" caption="Sending and receiving multiple messages over the async channel and sleeping with an `await` between each message" file-name="src/main.rs">
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("future"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            trpl::sleep(Duration::from_millis(500)).await;
        }

        while let Some(value) = rx.recv().await {
            println!("received '{value}'");
        }
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
</Listing>
<p>In addition to sending the messages, we need to receive them. In this case, because we know how many messages are coming in, we could do that manually by calling <code>rx.recv().await</code> four times. In the real world, though, we‚Äôll generally be waiting on some <em>unknown</em> number of messages, so we need to keep waiting until we determine that there are no more messages.</p>
<p>In Listing 16-10, we used a <code>for</code> loop to process all the items received from a synchronous channel. Rust doesn‚Äôt yet have a way to write a <code>for</code> loop over an <em>asynchronous</em> series of items, however, so we need to use a loop we haven‚Äôt seen before: the <code>while let</code> conditional loop. This is the loop version of the <code>if let</code> construct we saw back in the section <a href="ch06-03-if-let.html">Concise Control Flow with <code>if let</code> and <code>let else</code></a><!-- ignore -->. The loop will continue executing as long as the pattern it specifies continues to match the value.</p>
<p>The <code>rx.recv</code> call produces a future, which we await. The runtime will pause the future until it is ready. Once a message arrives, the future will resolve to <code>Some(message)</code> as many times as a message arrives. When the channel closes, regardless of whether <em>any</em> messages have arrived, the future will instead resolve to <code>None</code> to indicate that there are no more values and thus we should stop polling‚Äîthat is, stop awaiting.</p>
<p>The <code>while let</code> loop pulls all of this together. If the result of calling <code>rx.recv().await</code> is <code>Some(message)</code>, we get access to the message and we can use it in the loop body, just as we could with <code>if let</code>. If the result is <code>None</code>, the loop ends. Every time the loop completes, it hits the await point again, so the runtime pauses it again until another message arrives.</p>
<p>The code now successfully sends and receives all of the messages. Unfortunately, there are still a couple of problems. For one thing, the messages do not arrive at half-second intervals. They arrive all at once, 2 (2,000 milliseconds) after we start the program. For another, this program also never exits! Instead, it waits forever for new messages. You will need to shut it down using <span
class="keystroke">ctrl-c</span>.</p>
<p>Let‚Äôs start by examining why the messages come in all at once after the full delay, rather than coming in with delays between each one. Within a given async block, the order in which <code>await</code> keywords appear in the code is also the order in which they‚Äôre executed when the program runs.</p>
<p>There‚Äôs only one async block in Listing 17-10, so everything in it runs linearly. There‚Äôs still no concurrency. All the <code>tx.send</code> calls happen, interspersed with all of the <code>trpl::sleep</code> calls and their associated await points. Only then does the <code>while let</code> loop get to go through any of the <code>await</code> points on the <code>recv</code> calls.</p>
<p>To get the behavior we want, where the sleep delay happens between each message, we need to put the <code>tx</code> and <code>rx</code> operations in their own async blocks, as shown in Listing 17-11. Then the runtime can execute each of them separately using <code>trpl::join</code>, just as in the counting example. Once again, we await the result of calling <code>trpl::join</code>, not the individual futures. If we awaited the individual futures in sequence, we would just end up back in a sequential flow‚Äîexactly what we‚Äôre trying <em>not</em> to do.</p>
<!-- We cannot test this one because it never stops! -->
<Listing number="17-11" caption="Separating `send` and `recv` into their own `async` blocks and awaiting the futures for those blocks" file-name="src/main.rs">
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span>        let tx_fut = async {
            let vals = vec![
                String::from("hi"),
                String::from("from"),
                String::from("the"),
                String::from("future"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("received '{value}'");
            }
        };

        trpl::join(tx_fut, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
</Listing>
<p>With the updated code in Listing 17-11, the messages get printed at 500-millisecond intervals, rather than all in a rush after 2 seconds.</p>
<p>The program still never exits, though, because of the way <code>while let</code> loop interacts with <code>trpl::join</code>:</p>
<ul>
<li>The future returned from <code>trpl::join</code> completes only once <em>both</em> futures passed to it have completed.</li>
<li>The <code>tx</code> future completes once it finishes sleeping after sending the last message in <code>vals</code>.</li>
<li>The <code>rx</code> future won‚Äôt complete until the <code>while let</code> loop ends.</li>
<li>The <code>while let</code> loop won‚Äôt end until awaiting <code>rx.recv</code> produces <code>None</code>.</li>
<li>Awaiting <code>rx.recv</code> will return <code>None</code> only once the other end of the channel is closed.</li>
<li>The channel will close only if we call <code>rx.close</code> or when the sender side, <code>tx</code>, is dropped.</li>
<li>We don‚Äôt call <code>rx.close</code> anywhere, and <code>tx</code> won‚Äôt be dropped until the outermost async block passed to <code>trpl::run</code> ends.</li>
<li>The block can‚Äôt end because it is blocked on <code>trpl::join</code> completing, which takes us back to the top of this list.</li>
</ul>
<p>We could manually close <code>rx</code> by calling <code>rx.close</code> somewhere, but that doesn‚Äôt make much sense. Stopping after handling some arbitrary number of messages would make the program shut down, but we could miss messages. We need some other way to make sure that <code>tx</code> gets dropped <em>before</em> the end of the function.</p>
<p>Right now, the async block where we send the messages only borrows <code>tx</code> because sending a message doesn‚Äôt require ownership, but if we could move <code>tx</code> into that async block, it would be dropped once that block ends. In the Chapter 13 section <a href="ch13-01-closures.html#capturing-references-or-moving-ownership">Capturing References or Moving Ownership</a><!-- ignore -->, you learned how to use the <code>move</code> keyword with closures, and, as discussed in the Chapter 16 section <a href="ch16-01-threads.html#using-move-closures-with-threads">Using <code>move</code> Closures with Threads</a><!-- ignore
-->, we often need to move data into closures when working with threads. The same basic dynamics apply to async blocks, so the <code>move</code> keyword works with async blocks just as it does with closures.</p>
<p>In Listing 17-12, we change the block used to send messages from <code>async</code> to <code>async move</code>. When we run <em>this</em> version of the code, it shuts down gracefully after the last message is sent and received.</p>
<Listing number="17-12" caption="A  revision of the code from Listing 17-11 that correctly shuts down when complete" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let tx_fut = async move {
            let vals = vec![
                String::from("hi"),
                String::from("from"),
                String::from("the"),
                String::from("future"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("received '{value}'");
            }
        };

        trpl::join(tx_fut, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>This async channel is also a multiple-producer channel, so we can call <code>clone</code> on <code>tx</code> if we want to send messages from multiple futures, as shown in Listing 17-13.</p>
<Listing number="17-13" caption="Using multiple producers with async blocks" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let tx1 = tx.clone();
        let tx1_fut = async move {
            let vals = vec![
                String::from("hi"),
                String::from("from"),
                String::from("the"),
                String::from("future"),
            ];

            for val in vals {
                tx1.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("received '{value}'");
            }
        };

        let tx_fut = async move {
            let vals = vec![
                String::from("more"),
                String::from("messages"),
                String::from("for"),
                String::from("you"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(1500)).await;
            }
        };

        trpl::join3(tx1_fut, tx_fut, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>First, we clone <code>tx</code>, creating <code>tx1</code> outside the first async block. We move <code>tx1</code> into that block just as we did before with <code>tx</code>. Then, later, we move the original <code>tx</code> into a <em>new</em> async block, where we send more messages on a slightly slower delay. We happen to put this new async block after the async block for receiving messages, but it could go before it just as well. The key is the order in which the futures are awaited, not in which they‚Äôre created.</p>
<p>Both of the async blocks for sending messages need to be <code>async move</code> blocks so that both <code>tx</code> and <code>tx1</code> get dropped when those blocks finish. Otherwise, we‚Äôll end up back in the same infinite loop we started out in. Finally, we switch from <code>trpl::join</code> to <code>trpl::join3</code> to handle the additional future.</p>
<p>Now we see all the messages from both sending futures, and because the sending futures use slightly different delays after sending, the messages are also received at those different intervals.</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">received 'hi'
received 'more'
received 'from'
received 'the'
received 'messages'
received 'future'
received 'for'
received 'you'
</code></pre>
<p>This is a good start, but it limits us to just a handful of futures: two with <code>join</code>, or three with <code>join3</code>. Let‚Äôs see how we might work with more futures.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="working-with-any-number-of-futures"><a class="header" href="#working-with-any-number-of-futures">Working with Any Number of Futures</a></h2>
<p>When we switched from using two futures to three in the previous section, we also had to switch from using <code>join</code> to using <code>join3</code>. It would be annoying to have to call a different function every time we changed the number of futures we wanted to join. Happily, we have a macro form of <code>join</code> to which we can pass an arbitrary number of arguments. It also handles awaiting the futures itself. Thus, we could rewrite the code from Listing 17-13 to use <code>join!</code> instead of <code>join3</code>, as in Listing 17-14.</p>
<Listing number="17-14" caption="Using `join!` to wait for multiple futures" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        trpl::join!(tx1_fut, tx_fut, rx_fut);
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>This is definitely an improvement over swapping between <code>join</code> and <code>join3</code> and <code>join4</code> and so on! However, even this macro form only works when we know the number of futures ahead of time. In real-world Rust, though, pushing futures into a collection and then waiting on some or all the futures of them to complete is a common pattern.</p>
<p>To check all the futures in some collection, we‚Äôll need to iterate over and join on <em>all</em> of them. The <code>trpl::join_all</code> function accepts any type that implements the <code>Iterator</code> trait, which you learned about back in <a href="ch13-02-iterators.html#the-iterator-trait-and-the-next-method">The Iterator Trait and the <code>next</code> Method</a><!-- ignore --> Chapter 13, so it seems like just the ticket. Let‚Äôs try putting our futures in a vector and replacing <code>join!</code> with <code>join_all</code> as show in Listing 17-15.</p>
<Listing  number="17-15" caption="Storing anonymous futures in a vector and calling `join_all`">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        let futures = vec![tx1_fut, rx_fut, tx_fut];

        trpl::join_all(futures).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
</Listing>
<p>Unfortunately, this code doesn‚Äôt compile. Instead, we get this error:</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-15/
cargo build
copy just the compiler error
-->
<pre><code class="language-text">error[E0308]: mismatched types
  --&gt; src/main.rs:45:37
   |
10 |         let tx1_fut = async move {
   |                       ---------- the expected `async` block
...
24 |         let rx_fut = async {
   |                      ----- the found `async` block
...
45 |         let futures = vec![tx1_fut, rx_fut, tx_fut];
   |                                     ^^^^^^ expected `async` block, found a 
different `async` block
   |
   = note: expected `async` block `{async block@src/main.rs:10:23: 10:33}`
              found `async` block `{async block@src/main.rs:24:22: 24:27}`
   = note: no two async blocks, even if identical, have the same type
   = help: consider pinning your async block and casting it to a trait object
</code></pre>
<p>This might be surprising. After all, none of the async blocks returns anything, so each one produces a <code>Future&lt;Output = ()&gt;</code>. Remember that <code>Future</code> is a trait, though, and that the compiler creates a unique enum for each async block. You can‚Äôt put two different hand-written structs in a <code>Vec</code>, and the same rule applies to the different enums generated by the compiler.</p>
<p>To make this work, we need to use <em>trait objects</em>, just as we did in <a href="ch12-03-improving-error-handling-and-modularity.html">‚ÄúReturning Errors from the run function‚Äù</a><!-- ignore --> in Chapter 12. (We‚Äôll cover trait objects in detail in Chapter 18.) Using trait objects lets us treat each of the anonymous futures produced by these types as the same type, because all of them implement the <code>Future</code> trait.</p>
<blockquote>
<p>Note: In the Chapter 8 section <a href="ch12-03-improving-error-handling-and-modularity.html#returning-errors-from-the-run-function">Using an Enum to Store Multiple Values</a><!-- ignore -->, we discussed another way to include multiple types in a <code>Vec</code>: using an enum to represent each type that can appear in the vector. We can‚Äôt do that here, though. For one thing, we have no way to name the different types, because they are anonymous. For another, the reason we reached for a vector and <code>join_all</code> in the first place was to be able to work with a dynamic collection of futures where we only care that they have the same output type.</p>
</blockquote>
<p>We start by wrapping each future in the <code>vec!</code> in a <code>Box::new</code>, as shown in Listing 17-16.</p>
<Listing number="17-16" caption="Using `Box::new` to align the types of the futures in a `Vec`" file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        let futures =
            vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];

        trpl::join_all(futures).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
</Listing>
<p>Unfortunately, this code still doesn‚Äôt compile. In fact, we get the same basic error we got before for both the second and third <code>Box::new</code> calls, as well as new errors referring to the <code>Unpin</code> trait. We‚Äôll come back to the <code>Unpin</code> errors in a moment. First, let‚Äôs fix the type errors on the <code>Box::new</code> calls by explicitly annotating the type of the <code>futures</code> variable (see Listing 17-17).</p>
<Listing number="17-17" caption="Fixing the rest of the type mismatch errors by using an explicit type declaration" file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{future::Future, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        let futures: Vec&lt;Box&lt;dyn Future&lt;Output = ()&gt;&gt;&gt; =
            vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];
<span class="boring">
</span><span class="boring">        trpl::join_all(futures).await;
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre>
</Listing>
<p>This type declaration is a little involved, so let‚Äôs walk through it:</p>
<ol>
<li>The innermost type is the future itself. We note explicitly that the output of the future is the unit type <code>()</code> by writing <code>Future&lt;Output = ()&gt;</code>.</li>
<li>Then we annotate the trait with <code>dyn</code> to mark it as dynamic.</li>
<li>The entire trait reference is wrapped in a <code>Box</code>.</li>
<li>Finally, we state explicitly that <code>futures</code> is a <code>Vec</code> containing these items.</li>
</ol>
<p>That already made a big difference. Now when we run the compiler, we get only the errors mentioning <code>Unpin</code>. Although there are three of them, their contents are very similar.</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-16
cargo build
# copy *only* the errors
# fix the paths
-->
<pre><code class="language-text">error[E0308]: mismatched types
   --&gt; src/main.rs:46:46
    |
10  |         let tx1_fut = async move {
    |                       ---------- the expected `async` block
...
24  |         let rx_fut = async {
    |                      ----- the found `async` block
...
46  |             vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];
    |                                     -------- ^^^^^^ expected `async` block, found a different `async` block
    |                                     |
    |                                     arguments to this function are incorrect
    |
    = note: expected `async` block `{async block@src/main.rs:10:23: 10:33}`
               found `async` block `{async block@src/main.rs:24:22: 24:27}`
    = note: no two async blocks, even if identical, have the same type
    = help: consider pinning your async block and casting it to a trait object
note: associated function defined here
   --&gt; file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/alloc/src/boxed.rs:255:12
    |
255 |     pub fn new(x: T) -&gt; Self {
    |            ^^^

error[E0308]: mismatched types
   --&gt; src/main.rs:46:64
    |
10  |         let tx1_fut = async move {
    |                       ---------- the expected `async` block
...
30  |         let tx_fut = async move {
    |                      ---------- the found `async` block
...
46  |             vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];
    |                                                       -------- ^^^^^^ expected `async` block, found a different `async` block
    |                                                       |
    |                                                       arguments to this function are incorrect
    |
    = note: expected `async` block `{async block@src/main.rs:10:23: 10:33}`
               found `async` block `{async block@src/main.rs:30:22: 30:32}`
    = note: no two async blocks, even if identical, have the same type
    = help: consider pinning your async block and casting it to a trait object
note: associated function defined here
   --&gt; file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/alloc/src/boxed.rs:255:12
    |
255 |     pub fn new(x: T) -&gt; Self {
    |            ^^^

error[E0277]: `{async block@src/main.rs:10:23: 10:33}` cannot be unpinned
   --&gt; src/main.rs:48:24
    |
48  |         trpl::join_all(futures).await;
    |         -------------- ^^^^^^^ the trait `Unpin` is not implemented for `{async block@src/main.rs:10:23: 10:33}`, which is required by `Box&lt;{async block@src/main.rs:10:23: 10:33}&gt;: Future`
    |         |
    |         required by a bound introduced by this call
    |
    = note: consider using the `pin!` macro
            consider using `Box::pin` if you need to access the pinned value outside of the current scope
    = note: required for `Box&lt;{async block@src/main.rs:10:23: 10:33}&gt;` to implement `Future`
note: required by a bound in `join_all`
   --&gt; file:///home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/futures-util-0.3.30/src/future/join_all.rs:105:14
    |
102 | pub fn join_all&lt;I&gt;(iter: I) -&gt; JoinAll&lt;I::Item&gt;
    |        -------- required by a bound in this function
...
105 |     I::Item: Future,
    |              ^^^^^^ required by this bound in `join_all`

error[E0277]: `{async block@src/main.rs:10:23: 10:33}` cannot be unpinned
  --&gt; src/main.rs:48:9
   |
48 |         trpl::join_all(futures).await;
   |         ^^^^^^^^^^^^^^^^^^^^^^^ the trait `Unpin` is not implemented for `{async block@src/main.rs:10:23: 10:33}`, which is required by `Box&lt;{async block@src/main.rs:10:23: 10:33}&gt;: Future`
   |
   = note: consider using the `pin!` macro
           consider using `Box::pin` if you need to access the pinned value outside of the current scope
   = note: required for `Box&lt;{async block@src/main.rs:10:23: 10:33}&gt;` to implement `Future`
note: required by a bound in `futures_util::future::join_all::JoinAll`
  --&gt; file:///home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/futures-util-0.3.30/src/future/join_all.rs:29:8
   |
27 | pub struct JoinAll&lt;F&gt;
   |            ------- required by a bound in this struct
28 | where
29 |     F: Future,
   |        ^^^^^^ required by this bound in `JoinAll`

error[E0277]: `{async block@src/main.rs:10:23: 10:33}` cannot be unpinned
  --&gt; src/main.rs:48:33
   |
48 |         trpl::join_all(futures).await;
   |                                 ^^^^^ the trait `Unpin` is not implemented for `{async block@src/main.rs:10:23: 10:33}`, which is required by `Box&lt;{async block@src/main.rs:10:23: 10:33}&gt;: Future`
   |
   = note: consider using the `pin!` macro
           consider using `Box::pin` if you need to access the pinned value outside of the current scope
   = note: required for `Box&lt;{async block@src/main.rs:10:23: 10:33}&gt;` to implement `Future`
note: required by a bound in `futures_util::future::join_all::JoinAll`
  --&gt; file:///home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/futures-util-0.3.30/src/future/join_all.rs:29:8
   |
27 | pub struct JoinAll&lt;F&gt;
   |            ------- required by a bound in this struct
28 | where
29 |     F: Future,
   |        ^^^^^^ required by this bound in `JoinAll`
</code></pre>
<p>That is a <em>lot</em> to digest, so let‚Äôs pull it apart. The first part of the message tell us that the first async block (<code>src/main.rs:8:23: 20:10</code>) does not implement the <code>Unpin</code> trait and suggests using <code>pin!</code> or <code>Box::pin</code> to resolve it. Later in the chapter, we‚Äôll dig into a few more details about <code>Pin</code> and <code>Unpin</code>. For the moment, though, we can just follow the compiler‚Äôs advice to get unstuck. In Listing 17-18, we start by updating the type annotation for <code>futures</code>, with a <code>Pin</code> wrapping each <code>Box</code>. Second, we use <code>Box::pin</code> to pin the futures themselves.</p>
<Listing number="17-18" caption="Using `Pin` and `Box::pin` to make the `Vec` type check" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{
</span><span class="boring">    future::Future,
</span><span class="boring">    pin::{pin, Pin},
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = pin!(async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        let rx_fut = pin!(async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        let tx_fut = pin!(async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        });
</span><span class="boring">
</span>        let futures: Vec&lt;Pin&lt;Box&lt;dyn Future&lt;Output = ()&gt;&gt;&gt;&gt; =
            vec![Box::pin(tx1_fut), Box::pin(rx_fut), Box::pin(tx_fut)];
<span class="boring">
</span><span class="boring">        trpl::join_all(futures).await;
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>If we compile and run this, we finally get the output we hoped for:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">received 'hi'
received 'more'
received 'from'
received 'messages'
received 'the'
received 'for'
received 'future'
received 'you'
</code></pre>
<p>Phew!</p>
<p>There‚Äôs a bit more to explore here. For one thing, using <code>Pin&lt;Box&lt;T&gt;&gt;</code> adds a small amount of overhead from putting these futures on the heap with <code>Box</code>‚Äîand we‚Äôre only doing that to get the types to line up. We don‚Äôt actually <em>need</em> the heap allocation, after all: these futures are local to this particular function. As noted before, <code>Pin</code> is itself a wrapper type, so we can get the benefit of having a single type in the <code>Vec</code>‚Äîthe original reason we reached for <code>Box</code>‚Äîwithout doing a heap allocation. We can use <code>Pin</code> directly with each future, using the <code>std::pin::pin</code> macro.</p>
<p>However, we must still be explicit about the type of the pinned reference; otherwise, Rust will still not know to interpret these as dynamic trait objects, which is what we need them to be in the <code>Vec</code>. We therefore <code>pin!</code> each future when we define it, and define <code>futures</code> as a <code>Vec</code> containing pinned mutable references to the dynamic future type, as in Listing 17-19.</p>
<Listing number="17-19" caption="Using `Pin` directly with the `pin!` macro to avoid unnecessary heap allocations" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{
</span><span class="boring">    future::Future,
</span><span class="boring">    pin::{pin, Pin},
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span>        let tx1_fut = pin!(async move {
            // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span>        });

        let rx_fut = pin!(async {
            // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span>        });

        let tx_fut = pin!(async move {
            // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span>        });

        let futures: Vec&lt;Pin&lt;&amp;mut dyn Future&lt;Output = ()&gt;&gt;&gt; =
            vec![tx1_fut, rx_fut, tx_fut];
<span class="boring">
</span><span class="boring">        trpl::join_all(futures).await;
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>We got this far by ignoring the fact that we might have different <code>Output</code> types. For example, in Listing 17-20, the anonymous future for <code>a</code> implements <code>Future&lt;Output = u32&gt;</code>, the anonymous future for <code>b</code> implements <code>Future&lt;Output = &amp;str&gt;</code>, and the anonymous future for <code>c</code> implements <code>Future&lt;Output = bool&gt;</code>.</p>
<Listing number="17-20" caption="Three futures with distinct types" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let a = async { 1u32 };
        let b = async { "Hello!" };
        let c = async { true };

        let (a_result, b_result, c_result) = trpl::join!(a, b, c);
        println!("{a_result}, {b_result}, {c_result}");
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>We can use <code>trpl::join!</code> to await them, because it allows us to pass in multiple future types and produces a tuple of those types. We <em>cannot</em> use <code>trpl::join_all</code>, because it requires all of the futures passed in to have the same type. Remember, that error is what got us started on this adventure with <code>Pin</code>!</p>
<p>This is a fundamental tradeoff: we can either deal with a dynamic number of futures with <code>join_all</code>, as long as they all have the same type, or we can deal with a set number of futures with the <code>join</code> functions or the <code>join!</code> macro, even if they have different types. This is the same scenario we‚Äôd face when working with any other types in Rust. Futures are not special, even though we have some nice syntax for working with them, and that‚Äôs a good thing.</p>
<h3 id="racing-futures"><a class="header" href="#racing-futures">Racing Futures</a></h3>
<p>When we ‚Äújoin‚Äù futures with the <code>join</code> family of functions and macros, we require <em>all</em> of them to finish before we move on. Sometimes, though, we only need <em>some</em> future from a set to finish before we move on‚Äîkind of similar to racing one future against another.</p>
<p>In Listing 17-21, we once again use <code>trpl::race</code> to run two futures, <code>slow</code> and <code>fast</code>, against each other.</p>
<Listing number="17-21" caption="Using `race` to get the result of whichever future finishes first" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let slow = async {
            println!("'slow' started.");
            trpl::sleep(Duration::from_millis(100)).await;
            println!("'slow' finished.");
        };

        let fast = async {
            println!("'fast' started.");
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'fast' finished.");
        };

        trpl::race(slow, fast).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>Each future prints a message when it starts running, pauses for some amount of time by calling and awaiting <code>sleep</code>, and then prints another message when it finishes. Then we pass both <code>slow</code> and <code>fast</code> to <code>trpl::race</code> and wait for one of them to finish. (The outcome here isn‚Äôt too surprising: <code>fast</code> wins.) Unlike when we used <code>race</code> back in <a href="ch17-01-futures-and-syntax.html#our-first-async-program">‚ÄúOur First Async Program‚Äù</a><!--
ignore -->, we just ignore the <code>Either</code> instance it returns here, because all of the interesting behavior happens in the body of the async blocks.</p>
<p>Notice that if you flip the order of the arguments to <code>race</code>, the order of the ‚Äústarted‚Äù messages changes, even though the <code>fast</code> future always completes first. That‚Äôs because the implementation of this particular <code>race</code> function is not fair. It always runs the futures passed in as arguments in the order in which they‚Äôre passed. Other implementations <em>are</em> fair and will randomly choose which future to poll first. Regardless of whether the implementation of race we‚Äôre using is fair, though, <em>one</em> of the futures will run up to the first <code>await</code> in its body before another task can start.</p>
<p>Recall from <a href="ch17-01-futures-and-syntax.html#our-first-async-program">Our First Async Program</a><!-- ignore --> that at each await point, Rust gives a runtime a chance to pause the task and switch to another one if the future being awaited isn‚Äôt ready. The inverse is also true: Rust <em>only</em> pauses async blocks and hands control back to a runtime at an await point. Everything between await points is synchronous.</p>
<p>That means if you do a bunch of work in an async block without an await point, that future will block any other futures from making progress. You may sometimes hear this referred to as one future <em>starving</em> other futures. In some cases, that may not be a big deal. However, if you are doing some kind of expensive setup or long-running work, or if you have a future that will keep doing some particular task indefinitely, you‚Äôll need to think about when and where to hand control back to the runtime.</p>
<p>By the same token, if you have long-running blocking operations, async can be a useful tool for providing ways for different parts of the program to relate to each other.</p>
<p>But <em>how</em> would you hand control back to the runtime in those cases?</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="yielding"></a></p>
<h3 id="yielding-control-to-the-runtime"><a class="header" href="#yielding-control-to-the-runtime">Yielding Control to the Runtime</a></h3>
<p>Let‚Äôs simulate a long-running operation. Listing 17-22 introduces a <code>slow</code> function.</p>
<Listing number="17-22" caption="Using `thread::sleep` to simulate slow operations" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        // We will call `slow` here later
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span>fn slow(name: &amp;str, ms: u64) {
    thread::sleep(Duration::from_millis(ms));
    println!("'{name}' ran for {ms}ms");
}</code></pre></pre>
</Listing>
<p>This code uses <code>std::thread::sleep</code> instead of <code>trpl::sleep</code> so that calling <code>slow</code> will block the current thread for some number of milliseconds. We can use <code>slow</code> to stand in for real-world operations that are both long-running and blocking.</p>
<p>In Listing 17-23, we use <code>slow</code> to emulate doing this kind of CPU-bound work in a pair of futures.</p>
<Listing number="17-23" caption="Using `thread::sleep` to simulate slow operations" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let a = async {
            println!("'a' started.");
            slow("a", 30);
            slow("a", 10);
            slow("a", 20);
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'a' finished.");
        };

        let b = async {
            println!("'b' started.");
            slow("b", 75);
            slow("b", 10);
            slow("b", 15);
            slow("b", 350);
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'b' finished.");
        };

        trpl::race(a, b).await;
<span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn slow(name: &amp;str, ms: u64) {
</span><span class="boring">    thread::sleep(Duration::from_millis(ms));
</span><span class="boring">    println!("'{name}' ran for {ms}ms");
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>To begin, each future only hands control back to the runtime <em>after</em> carrying out a bunch of slow operations. If you run this code, you will see this output:</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-23/
cargo run
copy just the output
-->
<pre><code class="language-text">'a' started.
'a' ran for 30ms
'a' ran for 10ms
'a' ran for 20ms
'b' started.
'b' ran for 75ms
'b' ran for 10ms
'b' ran for 15ms
'b' ran for 350ms
'a' finished.
</code></pre>
<p>As with our earlier example, <code>race</code> still finishes as soon as <code>a</code> is done. There‚Äôs no interleaving between the two futures, though. The <code>a</code> future does all of its work until the <code>trpl::sleep</code> call is awaited, then the <code>b</code> future does all of its work until its own <code>trpl::sleep</code> call is awaited, and finally the <code>a</code> future completes. To allow both futures to make progress between their slow tasks, we need await points so we can hand control back to the runtime. That means we need something we can await!</p>
<p>We can already see this kind of handoff happening in Listing 17-23: if we removed the <code>trpl::sleep</code> at the end of the <code>a</code> future, it would complete without the <code>b</code> future running <em>at all</em>. Let‚Äôs try using the <code>sleep</code> function as a starting point for letting operations switch off making progress, as shown in Listing 17-24.</p>
<Listing number="17-24" caption="Using `sleep` to let operations switch off making progress" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let one_ms = Duration::from_millis(1);

        let a = async {
            println!("'a' started.");
            slow("a", 30);
            trpl::sleep(one_ms).await;
            slow("a", 10);
            trpl::sleep(one_ms).await;
            slow("a", 20);
            trpl::sleep(one_ms).await;
            println!("'a' finished.");
        };

        let b = async {
            println!("'b' started.");
            slow("b", 75);
            trpl::sleep(one_ms).await;
            slow("b", 10);
            trpl::sleep(one_ms).await;
            slow("b", 15);
            trpl::sleep(one_ms).await;
            slow("b", 35);
            trpl::sleep(one_ms).await;
            println!("'b' finished.");
        };
<span class="boring">
</span><span class="boring">        trpl::race(a, b).await;
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn slow(name: &amp;str, ms: u64) {
</span><span class="boring">    thread::sleep(Duration::from_millis(ms));
</span><span class="boring">    println!("'{name}' ran for {ms}ms");
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>In Listing 17-24, we add <code>trpl::sleep</code> calls with await points between each call to <code>slow</code>. Now the two futures‚Äô work is interleaved:</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-24
cargo run
copy just the output
-->
<pre><code class="language-text">'a' started.
'a' ran for 30ms
'b' started.
'b' ran for 75ms
'a' ran for 10ms
'b' ran for 10ms
'a' ran for 20ms
'b' ran for 15ms
'a' finished.
</code></pre>
<p>The <code>a</code> future still runs for a bit before handing off control to <code>b</code>, because it calls <code>slow</code> before ever calling <code>trpl::sleep</code>, but after that the futures swap back and forth each time one of them hits an await point. In this case, we have done that after every call to <code>slow</code>, but we could break up the work in whatever way makes the most sense to us.</p>
<p>We don‚Äôt really want to <em>sleep</em> here, though: we want to make progress as fast as we can. We just need to hand back control to the runtime. We can do that directly, using the <code>yield_now</code> function. In Listing 17-25, we replace all those <code>sleep</code> calls with <code>yield_now</code>.</p>
<Listing number="17-25" caption="Using `yield_now` to let operations switch off making progress" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let a = async {
            println!("'a' started.");
            slow("a", 30);
            trpl::yield_now().await;
            slow("a", 10);
            trpl::yield_now().await;
            slow("a", 20);
            trpl::yield_now().await;
            println!("'a' finished.");
        };

        let b = async {
            println!("'b' started.");
            slow("b", 75);
            trpl::yield_now().await;
            slow("b", 10);
            trpl::yield_now().await;
            slow("b", 15);
            trpl::yield_now().await;
            slow("b", 35);
            trpl::yield_now().await;
            println!("'b' finished.");
        };
<span class="boring">
</span><span class="boring">        trpl::race(a, b).await;
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn slow(name: &amp;str, ms: u64) {
</span><span class="boring">    thread::sleep(Duration::from_millis(ms));
</span><span class="boring">    println!("'{name}' ran for {ms}ms");
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>This code is both clearer about the actual intent and can be significantly faster than using <code>sleep</code>, because timers such as the one used by <code>sleep</code> often have limits on how granular they can be. The version of <code>sleep</code> we are using, for example, will always sleep for at least a millisecond, even if we pass it a <code>Duration</code> of one nanosecond. Again, modern computers are <em>fast</em>: they can do a lot in one millisecond!</p>
<p>You can see this for yourself by setting up a little benchmark, such as the one in Listing 17-26. (This isn‚Äôt an especially rigorous way to do performance testing, but it suffices to show the difference here.)</p>
<Listing number="17-26" caption="Comparing the performance of `sleep` and `yield_now`" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::{Duration, Instant};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let one_ns = Duration::from_nanos(1);
        let start = Instant::now();
        async {
            for _ in 1..1000 {
                trpl::sleep(one_ns).await;
            }
        }
        .await;
        let time = Instant::now() - start;
        println!(
            "'sleep' version finished after {} seconds.",
            time.as_secs_f32()
        );

        let start = Instant::now();
        async {
            for _ in 1..1000 {
                trpl::yield_now().await;
            }
        }
        .await;
        let time = Instant::now() - start;
        println!(
            "'yield' version finished after {} seconds.",
            time.as_secs_f32()
        );
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>Here, we skip all the status printing, pass a one-nanosecond <code>Duration</code> to <code>trpl::sleep</code>, and let each future run by itself, with no switching between the futures. Then we run for 1,000 iterations and see how long the future using <code>trpl::sleep</code> takes compared to the future using <code>trpl::yield_now</code>.</p>
<p>The version with <code>yield_now</code> is <em>way</em> faster!</p>
<p>This means that async can be useful even for compute-bound tasks, depending on what else your program is doing, because it provides a useful tool for structuring the relationships between different parts of the program. This is a form of <em>cooperative multitasking</em>, where each future has the power to determine when it hands over control via await points. Each future therefore also has the responsibility to avoid blocking for too long. In some Rust-based embedded operating systems, this is the <em>only</em> kind of multitasking!</p>
<p>In real-world code, you won‚Äôt usually be alternating function calls with await points on every single line, of course. While yielding control in this way is relatively inexpensive, it‚Äôs not free. In many cases, trying to break up a compute-bound task might make it significantly slower, so sometimes it‚Äôs better for <em>overall</em> performance to let an operation block briefly. Always measure to see what your code‚Äôs actual performance bottlenecks are. The underlying dynamic is important to keep in mind, though, if you <em>are</em> seeing a lot of work happening in serial that you expected to happen concurrently!</p>
<h3 id="building-our-own-async-abstractions"><a class="header" href="#building-our-own-async-abstractions">Building Our Own Async Abstractions</a></h3>
<p>We can also compose futures together to create new patterns. For example, we can build a <code>timeout</code> function with async building blocks we already have. When we‚Äôre done, the result will be another building block we could use to create still more async abstractions.</p>
<p>Listing 17-27 shows how we would expect this <code>timeout</code> to work with a slow future.</p>
<Listing number="17-27" caption="Using our imagined `timeout` to run a slow operation with a time limit" file-name="src/main.rs">
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let slow = async {
            trpl::sleep(Duration::from_millis(100)).await;
            "I finished!"
        };

        match timeout(slow, Duration::from_millis(10)).await {
            Ok(message) =&gt; println!("Succeeded with '{message}'"),
            Err(duration) =&gt; {
                println!("Failed after {} seconds", duration.as_secs())
            }
        }
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
</Listing>
<p>Let‚Äôs implement this! To begin, let‚Äôs think about the API for <code>timeout</code>:</p>
<ul>
<li>It needs to be an async function itself so we can await it.</li>
<li>Its first parameter should be a future to run. We can make it generic to allow it to work with any future.</li>
<li>Its second parameter will be the maximum time to wait. If we use a <code>Duration</code>, that will make it easy to pass along to <code>trpl::sleep</code>.</li>
<li>It should return a <code>Result</code>. If the future completes successfully, the <code>Result</code> will be <code>Ok</code> with the value produced by the future. If the timeout elapses first, the <code>Result</code> will be <code>Err</code> with the duration that the timeout waited for.</li>
</ul>
<p>Listing 17-28 shows this declaration.</p>
<!-- This is not tested because it intentionally does not compile. -->
<Listing number="17-28" caption="Defining the signature of `timeout`" file-name="src/main.rs">
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{future::Future, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let slow = async {
</span><span class="boring">            trpl::sleep(Duration::from_secs(5)).await;
</span><span class="boring">            "Finally finished"
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        match timeout(slow, Duration::from_millis(10)).await {
</span><span class="boring">            Ok(message) =&gt; println!("Succeeded with '{message}'"),
</span><span class="boring">            Err(duration) =&gt; {
</span><span class="boring">                println!("Failed after {} seconds", duration.as_secs())
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span>async fn timeout&lt;F: Future&gt;(
    future_to_try: F,
    max_time: Duration,
) -&gt; Result&lt;F::Output, Duration&gt; {
    // Here is where our implementation will go!
}</code></pre>
</Listing>
<p>That satisfies our goals for the types. Now let‚Äôs think about the <em>behavior</em> we need: we want to race the future passed in against the duration. We can use <code>trpl::sleep</code> to make a timer future from the duration, and use <code>trpl::race</code> to run that timer with the future the caller passes in.</p>
<p>We also know that <code>race</code> is not fair, polling arguments in the order in which they are passed. Thus, we pass <code>future_to_try</code> to <code>race</code> first so it gets a chance to complete even if <code>max_time</code> is a very short duration. If <code>future_to_try</code> finishes first, <code>race</code> will return <code>Left</code> with the output from <code>future_to_try</code>. If <code>timer</code> finishes first, <code>race</code> will return <code>Right</code> with the timer‚Äôs output of <code>()</code>.</p>
<p>In Listing 17-29, we match on the result of awaiting <code>trpl::race</code>.</p>
<Listing number="17-29" caption="Defining `timeout` with `race` and `sleep`" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{future::Future, time::Duration};
</span><span class="boring">
</span>use trpl::Either;

// --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--

fn main() {
    trpl::run(async {
        let slow = async {
            trpl::sleep(Duration::from_secs(5)).await;
            "Finally finished"
        };

        match timeout(slow, Duration::from_secs(2)).await {
            Ok(message) =&gt; println!("Succeeded with '{message}'"),
            Err(duration) =&gt; {
                println!("Failed after {} seconds", duration.as_secs())
            }
        }
    });
}

async fn timeout&lt;F: Future&gt;(
    future_to_try: F,
    max_time: Duration,
) -&gt; Result&lt;F::Output, Duration&gt; {
    match trpl::race(future_to_try, trpl::sleep(max_time)).await {
        Either::Left(output) =&gt; Ok(output),
        Either::Right(_) =&gt; Err(max_time),
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>If the <code>future_to_try</code> succeeds and we get a <code>Left(output)</code>, we return <code>Ok(output)</code>. If the sleep timer elapses instead and we get a <code>Right(())</code>, we ignore the <code>()</code> with <code>_</code> and return <code>Err(max_time)</code> instead.</p>
<p>With that, we have a working <code>timeout</code> built out of two other async helpers. If we run our code, it will print the failure mode after the timeout:</p>
<pre><code class="language-text">Failed after 2 seconds
</code></pre>
<p>Because futures compose with other futures, you can build really powerful tools using smaller async building blocks. For example, you can use this same approach to combine timeouts with retries, and in turn use those with operations such as network calls (one of the examples from the beginning of the chapter).</p>
<p>In practice, you‚Äôll usually work directly with <code>async</code> and <code>await</code>, and secondarily with functions and macros such as <code>join</code>, <code>join_all</code>, <code>race</code>, and so on. You‚Äôll only need to reach for <code>pin</code> now and again to use futures with those APIs.</p>
<p>We‚Äôve now seen a number of ways to work with multiple futures at the same time. Up next, we‚Äôll look at how we can work with multiple futures in a sequence over time with <em>streams</em>. Here are a couple more things you might want to consider first, though:</p>
<ul>
<li>
<p>We used a <code>Vec</code> with <code>join_all</code> to wait for all of the futures in some group to finish. How could you use a <code>Vec</code> to process a group of futures in sequence instead? What are the tradeoffs of doing that?</p>
</li>
<li>
<p>Take a look at the <code>futures::stream::FuturesUnordered</code> type from the <code>futures</code> crate. How would using it be different from using a <code>Vec</code>? (Don‚Äôt worry about the fact that it‚Äôs from the <code>stream</code> part of the crate; it works just fine with any collection of futures.)</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="streams-futures-in-sequence"><a class="header" href="#streams-futures-in-sequence">Streams: Futures in Sequence</a></h2>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="streams"></a></p>
<p>So far in this chapter, we‚Äôve mostly stuck to individual futures. The one big exception was the async channel we used. Recall how we used the receiver for our async channel earlier in this chapter in the <a href="ch17-02-concurrency-with-async.html#message-passing">‚ÄúMessage Passing‚Äù</a><!-- ignore --> section. The async <code>recv</code> method produces a sequence of items over time. This is an instance of a much more general pattern known as a <em>stream</em>.</p>
<p>We saw a sequence of items back in Chapter 13, when we looked at the <code>Iterator</code> trait in <a href="ch13-02-iterators.html#the-iterator-trait-and-the-next-method">The Iterator Trait and the <code>next</code> Method</a><!-- ignore
--> section, but there are two differences between iterators and the async channel receiver. The first difference is time: iterators are synchronous, while the channel receiver is asynchronous. The second is the API. When working directly with <code>Iterator</code>, we call its synchronous <code>next</code> method. With the <code>trpl::Receiver</code> stream in particular, we called an asynchronous <code>recv</code> method instead. Otherwise, these APIs feel very similar, and that similarity isn‚Äôt a coincidence. A stream is like an asynchronous form of iteration. Whereas the <code>trpl::Receiver</code> specifically waits to receive messages, though, the general-purpose stream API is much broader: it provides the next item the way <code>Iterator</code> does, but asynchronously.</p>
<p>The similarity between iterators and streams in Rust means we can actually create a stream from any iterator. As with an iterator, we can work with a stream by calling its <code>next</code> method and then awaiting the output, as in Listing 17-30.</p>
<Listing number="17-30" caption="Creating a stream from an iterator and printing its values" file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        let iter = values.iter().map(|n| n * 2);
        let mut stream = trpl::stream_from_iter(iter);

        while let Some(value) = stream.next().await {
            println!("The value was: {value}");
        }
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
</Listing>
<p>We start with an array of numbers, which we convert to an iterator and then call <code>map</code> on to double all the values. Then we convert the iterator into a stream using the <code>trpl::stream_from_iter</code> function. Next, we loop over the items in the stream as they arrive with the <code>while let</code> loop.</p>
<p>Unfortunately, when we try to run the code, it doesn‚Äôt compile, but instead it reports that there‚Äôs no <code>next</code> method available:</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-30
cargo build
copy only the error output
-->
<pre><code class="language-console">error[E0599]: no method named `next` found for struct `Iter` in the current scope
  --&gt; src/main.rs:10:40
   |
10 |         while let Some(value) = stream.next().await {
   |                                        ^^^^
   |
   = note: the full type name has been written to 'file:///projects/async_await/target/debug/deps/async_await-9de943556a6001b8.long-type-1281356139287206597.txt'
   = note: consider using `--verbose` to print the full type name to the console
   = help: items from traits can only be used if the trait is in scope
help: the following traits which provide `next` are implemented but not in scope; perhaps you want to import one of them
   |
1  + use crate::trpl::StreamExt;
   |
1  + use futures_util::stream::stream::StreamExt;
   |
1  + use std::iter::Iterator;
   |
1  + use std::str::pattern::Searcher;
   |
help: there is a method `try_next` with a similar name
   |
10 |         while let Some(value) = stream.try_next().await {
   |                                        ~~~~~~~~
</code></pre>
<p>As this output explains, the reason for the compiler error is that we need the right trait in scope to be able to use the <code>next</code> method. Given our discussion so far, you might reasonably expect that trait to be <code>Stream</code>, but it‚Äôs actually <code>StreamExt</code>. Short for <em>extension</em>, <code>Ext</code> is a common pattern in the Rust community for extending one trait with another.</p>
<p>We‚Äôll explain the <code>Stream</code> and <code>StreamExt</code> traits in a bit more detail at the end of the chapter, but for now all you need to know is that the <code>Stream</code> trait defines a low-level interface that effectively combines the <code>Iterator</code> and <code>Future</code> traits. <code>StreamExt</code> supplies a higher-level set of APIs on top of <code>Stream</code>, including the <code>next</code> method as well as other utility methods similar to those provided by the <code>Iterator</code> trait. <code>Stream</code> and <code>StreamExt</code> are not yet part of Rust‚Äôs standard library, but most ecosystem crates use the same definition.</p>
<p>The fix to the compiler error is to add a <code>use</code> statement for <code>trpl::StreamExt</code>, as in Listing 17-31.</p>
<Listing number="17-31" caption="Successfully using an iterator as the basis for a stream" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use trpl::StreamExt;

fn main() {
    trpl::run(async {
        let values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        let iter = values.iter().map(|n| n * 2);
        let mut stream = trpl::stream_from_iter(iter);

        while let Some(value) = stream.next().await {
            println!("The value was: {value}");
        }
    });
}</code></pre></pre>
</Listing>
<p>With all those pieces put together, this code works the way we want! What‚Äôs more, now that we have <code>StreamExt</code> in scope, we can use all of its utility methods, just as with iterators. For example, in Listing 17-32, we use the <code>filter</code> method to filter out everything but multiples of three and five.</p>
<Listing number="17-32" caption="Filtering a stream with the `StreamExt::filter` method" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use trpl::StreamExt;

fn main() {
    trpl::run(async {
        let values = 1..101;
        let iter = values.map(|n| n * 2);
        let stream = trpl::stream_from_iter(iter);

        let mut filtered =
            stream.filter(|value| value % 3 == 0 || value % 5 == 0);

        while let Some(value) = filtered.next().await {
            println!("The value was: {value}");
        }
    });
}</code></pre></pre>
</Listing>
<p>Of course, this isn‚Äôt very interesting, since we could do the same with normal iterators and without any async at all. Let‚Äôs look at what we can do that <em>is</em> unique to streams.</p>
<h3 id="composing-streams"><a class="header" href="#composing-streams">Composing Streams</a></h3>
<p>Many concepts are naturally represented as streams: items becoming available in a queue, chunks of data being pulled incrementally from the filesystem when the full data set is too large for the computer‚Äôs memory, or data arriving over the network over time. Because streams are futures, we can use them with any other kind of future and combine them in interesting ways. For example, we can batch up events to avoid triggering too many network calls, set timeouts on sequences of long-running operations, or throttle user interface events to avoid doing needless work.</p>
<p>Let‚Äôs start by building a little stream of messages as a stand-in for a stream of data we might see from a WebSocket or another real-time communication protocol, as shown in Listing 17-33.</p>
<Listing number="17-33" caption="Using the `rx` receiver as a `ReceiverStream`" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use trpl::{ReceiverStream, Stream, StreamExt};

fn main() {
    trpl::run(async {
        let mut messages = get_messages();

        while let Some(message) = messages.next().await {
            println!("{message}");
        }
    });
}

fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
    let (tx, rx) = trpl::channel();

    let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
    for message in messages {
        tx.send(format!("Message: '{message}'")).unwrap();
    }

    ReceiverStream::new(rx)
}</code></pre></pre>
</Listing>
<p>First, we create a function called <code>get_messages</code> that returns <code>impl Stream&lt;Item = String&gt;</code>. For its implementation, we create an async channel, loop over the first 10 letters of the English alphabet, and send them across the channel.</p>
<p>We also use a new type: <code>ReceiverStream</code>, which converts the <code>rx</code> receiver from the <code>trpl::channel</code> into a <code>Stream</code> with a <code>next</code> method. Back in <code>main</code>, we use a <code>while let</code> loop to print all the messages from the stream.</p>
<p>When we run this code, we get exactly the results we would expect:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Message: 'a'
Message: 'b'
Message: 'c'
Message: 'd'
Message: 'e'
Message: 'f'
Message: 'g'
Message: 'h'
Message: 'i'
Message: 'j'
</code></pre>
<p>Again, we could do this with the regular <code>Receiver</code> API or even the regular <code>Iterator</code> API, though, so let‚Äôs add a feature that requires streams: adding a timeout that applies to every item in the stream, and a delay on the items we emit, as shown in Listing 17-34.</p>
<Listing number="17-34" caption="Using the `StreamExt::timeout` method to set a time limit on the items in a stream" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use std::{pin::pin, time::Duration};
use trpl::{ReceiverStream, Stream, StreamExt};

fn main() {
    trpl::run(async {
        let mut messages =
            pin!(get_messages().timeout(Duration::from_millis(200)));

        while let Some(result) = messages.next().await {
            match result {
                Ok(message) =&gt; println!("{message}"),
                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
            }
        }
    })
}
<span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">    for message in messages {
</span><span class="boring">        tx.send(format!("Message: '{message}'")).unwrap();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>We start by adding a timeout to the stream with the <code>timeout</code> method, which comes from the <code>StreamExt</code> trait. Then we update the body of the <code>while let</code> loop, because the stream now returns a <code>Result</code>. The <code>Ok</code> variant indicates a message arrived in time; the <code>Err</code> variant indicates that the timeout elapsed before any message arrived. We <code>match</code> on that result and either print the message when we receive it successfully or print a notice about the timeout. Finally, notice that we pin the messages after applying the timeout to them, because the timeout helper produces a stream that needs to be pinned to be polled.</p>
<p>However, because there are no delays between messages, this timeout does not change the behavior of the program. Let‚Äôs add a variable delay to the messages we send, as shown in Listing 17-35.</p>
<Listing number="17-35" caption="Sending messages through `tx` with an async delay without making `get_messages` an async function" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let mut messages =
</span><span class="boring">            pin!(get_messages().timeout(Duration::from_millis(200)));
</span><span class="boring">
</span><span class="boring">        while let Some(result) = messages.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span>fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
    let (tx, rx) = trpl::channel();

    trpl::spawn_task(async move {
        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
        for (index, message) in messages.into_iter().enumerate() {
            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
            trpl::sleep(Duration::from_millis(time_to_sleep)).await;

            tx.send(format!("Message: '{message}'")).unwrap();
        }
    });

    ReceiverStream::new(rx)
}</code></pre></pre>
</Listing>
<p>In <code>get_messages</code>, we use the <code>enumerate</code> iterator method with the <code>messages</code> array so that we can get the index of each item we‚Äôre sending along with the item itself. Then we apply a 100-millisecond delay to even-index items and a 300-millisecond delay to odd-index items to simulate the different delays we might see from a stream of messages in the real world. Because our timeout is for 200 milliseconds, this should affect half of the messages.</p>
<p>To sleep between messages in the <code>get_messages</code> function without blocking, we need to use async. However, we can‚Äôt make <code>get_messages</code> itself into an async function, because then we‚Äôd return a <code>Future&lt;Output = Stream&lt;Item = String&gt;&gt;</code> instead of a <code>Stream&lt;Item = String&gt;&gt;</code>. The caller would have to await <code>get_messages</code> itself to get access to the stream. But remember: everything in a given future happens linearly; concurrency happens <em>between</em> futures. Awaiting <code>get_messages</code> would require it to send all the messages, including the sleep delay between each message, before returning the receiver stream. As a result, the timeout would be useless. There would be no delays in the stream itself; they would all happen before the stream was even available.</p>
<p>Instead, we leave <code>get_messages</code> as a regular function that returns a stream, and we spawn a task to handle the async <code>sleep</code> calls.</p>
<blockquote>
<p>Note: Calling <code>spawn_task</code> in this way works because we already set up our runtime; had we not, it would cause a panic. Other implementations choose different tradeoffs: they might spawn a new runtime and avoid the panic but end up with a bit of extra overhead, or they may simply not provide a standalone way to spawn tasks without reference to a runtime. Make sure you know what tradeoff your runtime has chosen and write your code accordingly!</p>
</blockquote>
<p>Now our code has a much more interesting result. Between every other pair of messages, a <code>Problem: Elapsed(())</code> error.</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-35
cargo run
copy only the program output, *not* the compiler output
-->
<pre><code class="language-text">Message: 'a'
Problem: Elapsed(())
Message: 'b'
Message: 'c'
Problem: Elapsed(())
Message: 'd'
Message: 'e'
Problem: Elapsed(())
Message: 'f'
Message: 'g'
Problem: Elapsed(())
Message: 'h'
Message: 'i'
Problem: Elapsed(())
Message: 'j'
</code></pre>
<p>The timeout doesn‚Äôt prevent the messages from arriving in the end. We still get all of the original messages, because our channel is <em>unbounded</em>: it can hold as many messages as we can fit in memory. If the message doesn‚Äôt arrive before the timeout, our stream handler will account for that, but when it polls the stream again, the message may now have arrived.</p>
<p>You can get different behavior if needed by using other kinds of channels or other kinds of streams more generally. Let‚Äôs see one of those in practice by combining a stream of time intervals with this stream of messages.</p>
<h3 id="merging-streams"><a class="header" href="#merging-streams">Merging Streams</a></h3>
<p>First, let‚Äôs create another stream, which will emit an item every millisecond if we let it run directly. For simplicity, we can use the <code>sleep</code> function to send a message on a delay and combine it with the same approach we used in <code>get_messages</code> of creating a stream from a channel. The difference is that this time, we‚Äôre going to send back the count of intervals that have elapsed, so the return type will be <code>impl Stream&lt;Item = u32&gt;</code>, and we can call the function <code>get_intervals</code> (see Listing 17-36).</p>
<Listing number="17-36" caption="Creating a stream with a counter that will be emitted once every millisecond" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let mut messages =
</span><span class="boring">            pin!(get_messages().timeout(Duration::from_millis(200)));
</span><span class="boring">
</span><span class="boring">        while let Some(result) = messages.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">        for (index, message) in messages.into_iter().enumerate() {
</span><span class="boring">            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
</span><span class="boring">            trpl::sleep(Duration::from_millis(time_to_sleep)).await;
</span><span class="boring">
</span><span class="boring">            tx.send(format!("Message: '{message}'")).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}
</span><span class="boring">
</span>fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
    let (tx, rx) = trpl::channel();

    trpl::spawn_task(async move {
        let mut count = 0;
        loop {
            trpl::sleep(Duration::from_millis(1)).await;
            count += 1;
            tx.send(count).unwrap();
        }
    });

    ReceiverStream::new(rx)
}</code></pre></pre>
</Listing>
<p>We start by defining a <code>count</code> in the task. (We could define it outside the task, too, but it‚Äôs clearer to limit the scope of any given variable.) Then we create an infinite loop. Each iteration of the loop asynchronously sleeps for one millisecond, increments the count, and then sends it over the channel. Because this is all wrapped in the task created by <code>spawn_task</code>, all of it‚Äîincluding the infinite loop‚Äîwill get cleaned up along with the runtime.</p>
<p>This kind of infinite loop, which ends only when the whole runtime gets torn down, is fairly common in async Rust: many programs need to keep running indefinitely. With async, this doesn‚Äôt block anything else, as long as there is at least one await point in each iteration through the loop.</p>
<p>Now, back in our main function‚Äôs async block, we can attempt to merge the <code>messages</code> and <code>intervals</code> streams, as shown in Listing 17-37.</p>
<Listing number="17-37" caption="Attempting to merge the `messages` and `intervals` streams" file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let messages = get_messages().timeout(Duration::from_millis(200));
        let intervals = get_intervals();
        let merged = messages.merge(intervals);
<span class="boring">
</span><span class="boring">        while let Some(result) = merged.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">        for (index, message) in messages.into_iter().enumerate() {
</span><span class="boring">            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
</span><span class="boring">            trpl::sleep(Duration::from_millis(time_to_sleep)).await;
</span><span class="boring">
</span><span class="boring">            tx.send(format!("Message: '{message}'")).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let mut count = 0;
</span><span class="boring">        loop {
</span><span class="boring">            trpl::sleep(Duration::from_millis(1)).await;
</span><span class="boring">            count += 1;
</span><span class="boring">            tx.send(count).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}</span></code></pre>
</Listing>
<p>We start by calling <code>get_intervals</code>. Then we merge the <code>messages</code> and <code>intervals</code> streams with the <code>merge</code> method, which combines multiple streams into one stream that produces items from any of the source streams as soon as the items are available, without imposing any particular ordering. Finally, we loop over that combined stream instead of over <code>messages</code>.</p>
<p>At this point, neither <code>messages</code> nor <code>intervals</code> needs to be pinned or mutable, because both will be combined into the single <code>merged</code> stream. However, this call to <code>merge</code> doesn‚Äôt compile! (Neither does the <code>next</code> call in the <code>while let</code> loop, but we‚Äôll come back to that.) This is because the two streams have different types. The <code>messages</code> stream has the type <code>Timeout&lt;impl Stream&lt;Item = String&gt;&gt;</code>, where <code>Timeout</code> is the type that implements <code>Stream</code> for a <code>timeout</code> call. The <code>intervals</code> stream has the type <code>impl Stream&lt;Item = u32&gt;</code>. To merge these two streams, we need to transform one of them to match the other. We‚Äôll rework the intervals stream, because messages is already in the basic format we want and has to handle timeout errors (see Listing 17-38).</p>
<!-- We cannot directly test this one, because it never stops. -->
<Listing number="17-38" caption="Aligning the type of the the `intervals` stream with the type of the `messages` stream" file-name="src/main.rs">
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let messages = get_messages().timeout(Duration::from_millis(200));
        let intervals = get_intervals()
            .map(|count| format!("Interval: {count}"))
            .timeout(Duration::from_secs(10));
        let merged = messages.merge(intervals);
        let mut stream = pin!(merged);
<span class="boring">
</span><span class="boring">        while let Some(result) = stream.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">        for (index, message) in messages.into_iter().enumerate() {
</span><span class="boring">            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
</span><span class="boring">            trpl::sleep(Duration::from_millis(time_to_sleep)).await;
</span><span class="boring">
</span><span class="boring">            tx.send(format!("Message: '{message}'")).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let mut count = 0;
</span><span class="boring">        loop {
</span><span class="boring">            trpl::sleep(Duration::from_millis(1)).await;
</span><span class="boring">            count += 1;
</span><span class="boring">            tx.send(count).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}</span></code></pre>
</Listing>
<p>First, we can use the <code>map</code> helper method to transform the <code>intervals</code> into a string. Second, we need to match the <code>Timeout</code> from <code>messages</code>. Because we don‚Äôt actually <em>want</em> a timeout for <code>intervals</code>, though, we can just create a timeout which is longer than the other durations we are using. Here, we create a 10-second timeout with <code>Duration::from_secs(10)</code>. Finally, we need to make <code>stream</code> mutable, so that the <code>while let</code> loop‚Äôs <code>next</code> calls can iterate through the stream, and pin it so that it‚Äôs safe to do so. That gets us <em>almost</em> to where we need to be. Everything type checks. If you run this, though, there will be two problems. First, it will never stop! You‚Äôll need to stop it with <span class="keystroke">ctrl-c</span>. Second, the messages from the English alphabet will be buried in the midst of all the interval counter messages:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the tasks running differently rather than
changes in the compiler -->
<pre><code class="language-text">--snip--
Interval: 38
Interval: 39
Interval: 40
Message: 'a'
Interval: 41
Interval: 42
Interval: 43
--snip--
</code></pre>
<p>Listing 17-39 shows one way to solve these last two problems.</p>
<Listing number="17-39" caption="Using `throttle` and `take` to manage the merged streams" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let messages = get_messages().timeout(Duration::from_millis(200));
        let intervals = get_intervals()
            .map(|count| format!("Interval: {count}"))
            .throttle(Duration::from_millis(100))
            .timeout(Duration::from_secs(10));
        let merged = messages.merge(intervals).take(20);
        let mut stream = pin!(merged);
<span class="boring">
</span><span class="boring">        while let Some(result) = stream.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">        for (index, message) in messages.into_iter().enumerate() {
</span><span class="boring">            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
</span><span class="boring">            trpl::sleep(Duration::from_millis(time_to_sleep)).await;
</span><span class="boring">
</span><span class="boring">            tx.send(format!("Message: '{message}'")).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let mut count = 0;
</span><span class="boring">        loop {
</span><span class="boring">            trpl::sleep(Duration::from_millis(1)).await;
</span><span class="boring">            count += 1;
</span><span class="boring">            tx.send(count).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>First, we use the <code>throttle</code> method on the <code>intervals</code> stream so that it doesn‚Äôt overwhelm the <code>messages</code> stream. <em>Throttling</em> is a way of limiting the rate at which a function will be called‚Äîor, in this case, how often the stream will be polled. Once every 100 milliseconds should do, because that‚Äôs roughly how often our messages arrive.</p>
<p>To limit the number of items we will accept from a stream, we apply the <code>take</code> method to the <code>merged</code> stream, because we want to limit the final output, not just one stream or the other.</p>
<p>Now when we run the program, it stops after pulling 20 items from the stream, and the intervals don‚Äôt overwhelm the messages. We also don‚Äôt get <code>Interval: 100</code> or <code>Interval: 200</code> or so on, but instead get <code>Interval: 1</code>, <code>Interval: 2</code>, and so on‚Äîeven though we have a source stream that <em>can</em> produce an event every millisecond. That‚Äôs because the <code>throttle</code> call produces a new stream that wraps the original stream so that the original stream gets polled only at the throttle rate, not its own ‚Äúnative‚Äù rate. We don‚Äôt have a bunch of unhandled interval messages we‚Äôre choosing to ignore. Instead, we never produce those interval messages in the first place! This is the inherent ‚Äúlaziness‚Äù of Rust‚Äôs futures at work again, allowing us to choose our performance characteristics.</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-39
cargo run
copy and paste only the program output
-->
<pre><code class="language-text">Interval: 1
Message: 'a'
Interval: 2
Interval: 3
Problem: Elapsed(())
Interval: 4
Message: 'b'
Interval: 5
Message: 'c'
Interval: 6
Interval: 7
Problem: Elapsed(())
Interval: 8
Message: 'd'
Interval: 9
Message: 'e'
Interval: 10
Interval: 11
Problem: Elapsed(())
Interval: 12
</code></pre>
<p>There‚Äôs one last thing we need to handle: errors! With both of these channel-based streams, the <code>send</code> calls could fail when the other side of the channel closes‚Äîand that‚Äôs just a matter of how the runtime executes the futures that make up the stream. Up until now, we‚Äôve ignored this possibility by calling <code>unwrap</code>, but in a well-behaved app, we should explicitly handle the error, at minimum by ending the loop so we don‚Äôt try to send any more messages. Listing 17-40 shows a simple error strategy: print the issue and then <code>break</code> from the loops.</p>
<Listing number="17-40" caption="Handling errors and shutting down the loops">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let messages = get_messages().timeout(Duration::from_millis(200));
</span><span class="boring">        let intervals = get_intervals()
</span><span class="boring">            .map(|count| format!("Interval #{count}"))
</span><span class="boring">            .throttle(Duration::from_millis(500))
</span><span class="boring">            .timeout(Duration::from_secs(10));
</span><span class="boring">        let merged = messages.merge(intervals).take(20);
</span><span class="boring">        let mut stream = pin!(merged);
</span><span class="boring">
</span><span class="boring">        while let Some(result) = stream.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(item) =&gt; println!("{item}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span>fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
    let (tx, rx) = trpl::channel();

    trpl::spawn_task(async move {
        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];

        for (index, message) in messages.into_iter().enumerate() {
            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
            trpl::sleep(Duration::from_millis(time_to_sleep)).await;

            if let Err(send_error) = tx.send(format!("Message: '{message}'")) {
                eprintln!("Cannot send message '{message}': {send_error}");
                break;
            }
        }
    });

    ReceiverStream::new(rx)
}

fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
    let (tx, rx) = trpl::channel();

    trpl::spawn_task(async move {
        let mut count = 0;
        loop {
            trpl::sleep(Duration::from_millis(1)).await;
            count += 1;

            if let Err(send_error) = tx.send(count) {
                eprintln!("Could not send interval {count}: {send_error}");
                break;
            };
        }
    });

    ReceiverStream::new(rx)
}</code></pre></pre>
</Listing>
<p>As usual, the correct way to handle a message send error will vary; just make sure you have a strategy.</p>
<p>Now that we‚Äôve seen a bunch of async in practice, let‚Äôs take a step back and dig into a few of the details of how <code>Future</code>, <code>Stream</code>, and the other key traits Rust uses to make async work.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="a-closer-look-at-the-traits-for-async"><a class="header" href="#a-closer-look-at-the-traits-for-async">A Closer Look at the Traits for Async</a></h2>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="digging-into-the-traits-for-async"></a></p>
<p>Throughout the chapter, we‚Äôve used the <code>Future</code>, <code>Pin</code>, <code>Unpin</code>, <code>Stream</code>, and <code>StreamExt</code> traits in various ways. So far, though, we‚Äôve avoided getting too far into the details of how they work or how they fit together, which is fine most of the time for your day-to-day Rust work. Sometimes, though, you‚Äôll encounter situations where you‚Äôll need to understand a few more of these details. In this section, we‚Äôll dig in just enough to help in those scenarios, still leaving the <em>really</em> deep dive for other documentation.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="future"></a></p>
<h3 id="the-future-trait"><a class="header" href="#the-future-trait">The <code>Future</code> Trait</a></h3>
<p>Let‚Äôs start by taking a closer look at how the <code>Future</code> trait works. Here‚Äôs how Rust defines it:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::pin::Pin;
use std::task::{Context, Poll};

pub trait Future {
    type Output;

    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>That trait definition includes a bunch of new types and also some syntax we haven‚Äôt seen before, so let‚Äôs walk through the definition piece by piece.</p>
<p>First, <code>Future</code>‚Äôs associated type <code>Output</code> says what the future resolves to. This is analogous to the <code>Item</code> associated type for the <code>Iterator</code> trait. Second, <code>Future</code> also has the <code>poll</code> method, which takes a special <code>Pin</code> reference for its <code>self</code> parameter and a mutable reference to a <code>Context</code> type, and returns a <code>Poll&lt;Self::Output&gt;</code>. We‚Äôll talk more about <code>Pin</code> and <code>Context</code> in a moment. For now, let‚Äôs focus on what the method returns, the <code>Poll</code> type:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Poll&lt;T&gt; {
    Ready(T),
    Pending,
}
<span class="boring">}</span></code></pre></pre>
<p>This <code>Poll</code> type is similar to an <code>Option</code>. It has one variant that has a value, <code>Ready(T)</code>, and one which does not, <code>Pending</code>. <code>Poll</code> means something quite different from <code>Option</code>, though! The <code>Pending</code> variant indicates that the future still has work to do, so the caller will need to check again later. The <code>Ready</code> variant indicates that the future has finished its work and the <code>T</code> value is available.</p>
<blockquote>
<p>Note: With most futures, the caller should not call <code>poll</code> again after the future has returned <code>Ready</code>. Many futures will panic if polled again after becoming ready. Futures that are safe to poll again will say so explicitly in their documentation. This is similar to how <code>Iterator::next</code> behaves.</p>
</blockquote>
<p>When you see code that uses <code>await</code>, Rust compiles it under the hood to code that calls <code>poll</code>. If you look back at Listing 17-4, where we printed out the page title for a single URL once it resolved, Rust compiles it into something kind of (although not exactly) like this:</p>
<pre><code class="language-rust ignore">match page_title(url).poll() {
    Ready(page_title) =&gt; match page_title {
        Some(title) =&gt; println!("The title for {url} was {title}"),
        None =&gt; println!("{url} had no title"),
    }
    Pending =&gt; {
        // But what goes here?
    }
}</code></pre>
<p>What should we do when the future is still <code>Pending</code>? We need some way to try again, and again, and again, until the future is finally ready. In other words, we need a loop:</p>
<pre><code class="language-rust ignore">let mut page_title_fut = page_title(url);
loop {
    match page_title_fut.poll() {
        Ready(value) =&gt; match page_title {
            Some(title) =&gt; println!("The title for {url} was {title}"),
            None =&gt; println!("{url} had no title"),
        }
        Pending =&gt; {
            // continue
        }
    }
}</code></pre>
<p>If Rust compiled it to exactly that code, though, every <code>await</code> would be blocking‚Äîexactly the opposite of what we were going for! Instead, Rust makes sure that the loop can hand off control to something that can pause work on this future to work on other futures and then check this one again later. As we‚Äôve seen, that something is an async runtime, and this scheduling and coordination work is one of its main jobs.</p>
<p>Earlier in the chapter, we described waiting on <code>rx.recv</code>. The <code>recv</code> call returns a future, and awaiting the future polls it. We noted that a runtime will pause the future until it‚Äôs ready with either <code>Some(message)</code> or <code>None</code> when the channel closes. With our deeper understanding of the <code>Future</code> trait, and specifically <code>Future::poll</code>, we can see how that works. The runtime knows the future isn‚Äôt ready when it returns <code>Poll::Pending</code>. Conversely, the runtime knows the future <em>is</em> ready and advances it when <code>poll</code> returns <code>Poll::Ready(Some(message))</code> or <code>Poll::Ready(None)</code>.</p>
<p>The exact details of how a runtime does that are beyond the scope of this book, but the key is to see the basic mechanics of futures: a runtime <em>polls</em> each future it is responsible for, putting the future back to sleep when it is not yet ready.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="pinning-and-the-pin-and-unpin-traits"></a></p>
<h3 id="the-pin-and-unpin-traits"><a class="header" href="#the-pin-and-unpin-traits">The <code>Pin</code> and <code>Unpin</code> Traits</a></h3>
<p>When we introduced the idea of pinning in Listing 17-16, we ran into a very gnarly error message. Here is the relevant part of it again:</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-16
cargo build
copy *only* the final `error` block from the errors
-->
<pre><code class="language-text">error[E0277]: `{async block@src/main.rs:10:23: 10:33}` cannot be unpinned
  --&gt; src/main.rs:48:33
   |
48 |         trpl::join_all(futures).await;
   |                                 ^^^^^ the trait `Unpin` is not implemented for `{async block@src/main.rs:10:23: 10:33}`, which is required by `Box&lt;{async block@src/main.rs:10:23: 10:33}&gt;: Future`
   |
   = note: consider using the `pin!` macro
           consider using `Box::pin` if you need to access the pinned value outside of the current scope
   = note: required for `Box&lt;{async block@src/main.rs:10:23: 10:33}&gt;` to implement `Future`
note: required by a bound in `futures_util::future::join_all::JoinAll`
  --&gt; file:///home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/futures-util-0.3.30/src/future/join_all.rs:29:8
   |
27 | pub struct JoinAll&lt;F&gt;
   |            ------- required by a bound in this struct
28 | where
29 |     F: Future,
   |        ^^^^^^ required by this bound in `JoinAll`
</code></pre>
<p>This error message tells us not only that we need to pin the values but also why pinning is required. The <code>trpl::join_all</code> function returns a struct called <code>JoinAll</code>. That struct is generic over a type <code>F</code>, which is constrained to implement the <code>Future</code> trait. Directly awaiting a future with <code>await</code> pins the future implicitly. That‚Äôs why we don‚Äôt need to use <code>pin!</code> everywhere we want to await futures.</p>
<p>However, we‚Äôre not directly awaiting a future here. Instead, we construct a new future, <code>JoinAll</code>, by passing a collection of futures to the <code>join_all</code> function. The signature for <code>join_all</code> requires that the types of the items in the collection all implement the <code>Future</code> trait, and <code>Box&lt;T&gt;</code> implements <code>Future</code> only if the <code>T</code> it wraps is a future that implements the <code>Unpin</code> trait.</p>
<p>That‚Äôs a lot to absorb! To really understand it, let‚Äôs dive a little further into how the <code>Future</code> trait actually works, in particular around <em>pinning</em>.</p>
<p>Look again at the definition of the <code>Future</code> trait:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::pin::Pin;
use std::task::{Context, Poll};

pub trait Future {
    type Output;

    // Required method
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>cx</code> parameter and its <code>Context</code> type are the key to how a runtime actually knows when to check any given future while still being lazy. Again, the details of how that works are beyond the scope of this chapter, and you generally only need to think about this when writing a custom <code>Future</code> implementation. We‚Äôll focus instead on the type for <code>self</code>, as this is the first time we‚Äôve seen a method where <code>self</code> has a type annotation. A type annotation for <code>self</code> works like type annotations for other function parameters, but with two key differences:</p>
<ul>
<li>
<p>It tells Rust what type <code>self</code> must be for the method to be called.</p>
</li>
<li>
<p>It can‚Äôt be just any type. It‚Äôs restricted to the type on which the method is implemented, a reference or smart pointer to that type, or a <code>Pin</code> wrapping a reference to that type.</p>
</li>
</ul>
<p>We‚Äôll see more on this syntax in <a href="ch18-00-oop.html">Chapter 18</a><!-- ignore -->. For now, it‚Äôs enough to know that if we want to poll a future to check whether it is <code>Pending</code> or <code>Ready(Output)</code>, we need a <code>Pin</code>-wrapped mutable reference to the type.</p>
<p><code>Pin</code> is a wrapper for pointer-like types such as <code>&amp;</code>, <code>&amp;mut</code>, <code>Box</code>, and <code>Rc</code>. (Technically, <code>Pin</code> works with types that implement the <code>Deref</code> or <code>DerefMut</code> traits, but this is effectively equivalent to working only with pointers.) <code>Pin</code> is not a pointer itself and doesn‚Äôt have any behavior of its own like <code>Rc</code> and <code>Arc</code> do with reference counting; it‚Äôs purely a tool the compiler can use to enforce constraints on pointer usage.</p>
<p>Recalling that <code>await</code> is implemented in terms of calls to <code>poll</code> starts to explain the error message we saw earlier, but that was in terms of <code>Unpin</code>, not <code>Pin</code>. So how exactly does <code>Pin</code> relate to <code>Unpin</code>, and why does <code>Future</code> need <code>self</code> to be in a <code>Pin</code> type to call <code>poll</code>?</p>
<p>Remember from earlier in this chapter a series of await points in a future get compiled into a state machine, and the compiler makes sure that state machine follows all of Rust‚Äôs normal rules around safety, including borrowing and ownership. To make that work, Rust looks at what data is needed between one await point and either the next await point or the end of the async block. It then creates a corresponding variant in the compiled state machine. Each variant gets the access it needs to the data that will be used in that section of the source code, whether by taking ownership of that data or by getting a mutable or immutable reference to it.</p>
<p>So far, so good: if we get anything wrong about the ownership or references in a given async block, the borrow checker will tell us. When we want to move around the future that corresponds to that block‚Äîlike moving it into a <code>Vec</code> to pass to <code>join_all</code>‚Äîthings get trickier.</p>
<p>When we move a future‚Äîwhether by pushing it into a data structure to use as an iterator with <code>join_all</code> or by returning it from a function‚Äîthat actually means moving the state machine Rust creates for us. And unlike most other types in Rust, the futures Rust creates for async blocks can end up with references to themselves in the fields of any given variant, as shown in the simplified illustration in Figure 17-4.</p>
<figure>
<img alt="A single-column, three-row table representing a future, fut1, which has data values 0 and 1 in the first two rows and an arrow pointing from the third row back to the second row, representing an internal reference within the future." src="img/trpl17-04.svg" class="center" />
<figcaption>Figure 17-4: A self-referential data type.</figcaption>
</figure>
<p>By default, though, any object that has a reference to itself is unsafe to move, because references always point to the actual memory address of whatever they refer to (see Figure 17-5). If you move the data structure itself, those internal references will be left pointing to the old location. However, that memory location is now invalid. For one thing, its value will not be updated when you make changes to the data structure. For another‚Äîmore important‚Äîthing, the computer is now free to reuse that memory for other purposes! You could end up reading completely unrelated data later.</p>
<figure>
<img alt="Two tables, depicting two futures, fut1 and fut2, each of which has one column and three rows, representing the result of having moved a future out of fut1 into fut2. The first, fut1, is grayed out, with a question mark in each index, representing unknown memory. The second, fut2, has 0 and 1 in the first and second rows and an arrow pointing from its third row back to the second row of fut1, representing a pointer that is referencing the old location in memory of the future before it was moved." src="img/trpl17-05.svg" class="center" />
<figcaption>Figure 17-5: The unsafe result of moving a self-referential data type</figcaption>
</figure>
<p>Theoretically, the Rust compiler could try to update every reference to an object whenever it gets moved, but that could add a lot of performance overhead, especially if a whole web of references needs updating. If we could instead make sure the data structure in question <em>doesn‚Äôt move in memory</em>, we wouldn‚Äôt have to update any references. This is exactly what Rust‚Äôs borrow checker requires: in safe code, it prevents you from moving any item with an active reference to it.</p>
<p><code>Pin</code> builds on that to give us the exact guarantee we need. When we <em>pin</em> a value by wrapping a pointer to that value in <code>Pin</code>, it can no longer move. Thus, if you have <code>Pin&lt;Box&lt;SomeType&gt;&gt;</code>, you actually pin the <code>SomeType</code> value, <em>not</em> the <code>Box</code> pointer. Figure 17-6 illustrates this process.</p>
<figure>
<img alt="Three boxes laid out side by side. The first is labeled ‚ÄúPin‚Äù, the second ‚Äúb1‚Äù, and the third ‚Äúpinned‚Äù. Within ‚Äúpinned‚Äù is a table labeled ‚Äúfut‚Äù, with a single column; it represents a future with cells for each part of the data structure. Its first cell has the value ‚Äú0‚Äù, its second cell has an arrow coming out of it and pointing to the fourth and final cell, which has the value ‚Äú1‚Äù in it, and the third cell has dashed lines and an ellipsis to indicate there may be other parts to the data structure. All together, the ‚Äúfut‚Äù table represents a future which is self-referential. An arrow leaves the box labeled ‚ÄúPin‚Äù, goes through the box labeled ‚Äúb1‚Äù and has terminates inside the ‚Äúpinned‚Äù box at the ‚Äúfut‚Äù table." src="img/trpl17-06.svg" class="center" />
<figcaption>Figure 17-6: Pinning a `Box` that points to a self-referential future type.</figcaption>
</figure>
<p>In fact, the <code>Box</code> pointer can still move around freely. Remember: we care about making sure the data ultimately being referenced stays in place. If a pointer moves around, <em>but the data it points to is in the same place</em>, as in Figure 17-7, there‚Äôs no potential problem. As an independent exercise, look at the docs for the types as well as the <code>std::pin</code> module and try to work out how you‚Äôd do this with a <code>Pin</code> wrapping a <code>Box</code>.) The key is that the self-referential type itself cannot move, because it is still pinned.</p>
<figure>
<img alt="Four boxes laid out in three rough columns, identical to the previous diagram with a change to the second column. Now there are two boxes in the second column, labeled ‚Äúb1‚Äù and ‚Äúb2‚Äù, ‚Äúb1‚Äù is grayed out, and the arrow from ‚ÄúPin‚Äù goes through ‚Äúb2‚Äù instead of ‚Äúb1‚Äù, indicating that the pointer has moved from ‚Äúb1‚Äù to ‚Äúb2‚Äù, but the data in ‚Äúpinned‚Äù has not moved." src="img/trpl17-07.svg" class="center" />
<figcaption>Figure 17-7: Moving a `Box` which points to a self-referential future type.</figcaption>
</figure>
<p>However, most types are perfectly safe to move around, even if they happen to be behind a <code>Pin</code> pointer. We only need to think about pinning when items have internal references. Primitive values such as numbers and Booleans are safe since they obviously don‚Äôt have any internal references, so they‚Äôre obviously safe. Neither do most types you normally work with in Rust. You can move around a <code>Vec</code>, for example, without worrying. Given only what we have seen so far, if you have a <code>Pin&lt;Vec&lt;String&gt;&gt;</code>, you‚Äôd have to do everything via the safe but restrictive APIs provided by <code>Pin</code>, even though a <code>Vec&lt;String&gt;</code> is always safe to move if there are no other references to it. We need a way to tell the compiler that it‚Äôs fine to move items around in cases like this‚Äîand there‚Äôs where <code>Unpin</code> comes into play.</p>
<p><code>Unpin</code> is a marker trait, similar to the <code>Send</code> and <code>Sync</code> traits we saw in Chapter 16, and thus has no functionality of its own. Marker traits exist only to tell the compiler it‚Äôs safe to use the type implementing a given trait in a particular context. <code>Unpin</code> informs the compiler that a given type does <em>not</em> need to uphold any guarantees about whether the value in question can be safely moved.</p>
<!--
  The inline `<code>` in the next block is to allow the inline `<em>` inside it,
  matching what NoStarch does style-wise, and emphasizing within the text here
  that it is something distinct from a normal type.
-->
<p>Just as with <code>Send</code> and <code>Sync</code>, the compiler implements <code>Unpin</code> automatically for all types where it can prove it is safe. A special case, again similar to <code>Send</code> and <code>Sync</code>, is where <code>Unpin</code> is <em>not</em> implemented for a type. The notation for this is <code>impl !Unpin for <em>SomeType</em></code>, where <code><em>SomeType</em></code> is the name of a type that <em>does</em> need to uphold those guarantees to be safe whenever a pointer to that type is used in a <code>Pin</code>.</p>
<p>In other words, there are two things to keep in mind about the relationship between <code>Pin</code> and <code>Unpin</code>. First, <code>Unpin</code> is the ‚Äúnormal‚Äù case, and <code>!Unpin</code> is the special case. Second, whether a type implements <code>Unpin</code> or <code>!Unpin</code> <em>only</em> matters when you‚Äôre using a pinned pointer to that type like <code>Pin&lt;&amp;mut <em>SomeType</em>&gt;</code>.</p>
<p>To make that concrete, think about a <code>String</code>: it has a length and the Unicode characters that make it up. We can wrap a <code>String</code> in <code>Pin</code>, as seen in Figure 17-8. However, <code>String</code> automatically implements <code>Unpin</code>, as do most other types in Rust.</p>
<figure>
<img alt="Concurrent work flow" src="img/trpl17-08.svg" class="center" />
<figcaption>Figure 17-8: Pinning a `String`; the dotted line indicates that the `String` implements the `Unpin` trait, and thus is not pinned.</figcaption>
</figure>
<p>As a result, we can do things that would be illegal if <code>String</code> implemented <code>!Unpin</code> instead, such as replacing one string with another at the exact same location in memory as in Figure 17-9. This doesn‚Äôt violate the <code>Pin</code> contract, because <code>String</code> has no internal references that make it unsafe to move around! That is precisely why it implements <code>Unpin</code> rather than <code>!Unpin</code>.</p>
<figure>
<img alt="Concurrent work flow" src="img/trpl17-09.svg" class="center" />
<figcaption>Figure 17-9: Replacing the `String` with an entirely different `String` in memory.</figcaption>
</figure>
<p>Now we know enough to understand the errors reported for that <code>join_all</code> call from back in Listing 17-17. We originally tried to move the futures produced by async blocks into a <code>Vec&lt;Box&lt;dyn Future&lt;Output = ()&gt;&gt;&gt;</code>, but as we‚Äôve seen, those futures may have internal references, so they don‚Äôt implement <code>Unpin</code>. They need to be pinned, and then we can pass the <code>Pin</code> type into the <code>Vec</code>, confident that the underlying data in the futures will <em>not</em> be moved.</p>
<p><code>Pin</code> and <code>Unpin</code> are mostly important for building lower-level libraries, or when you‚Äôre building a runtime itself, rather than for day-to-day Rust code. When you see these traits in error messages, though, now you‚Äôll have a better idea of how to fix your code!</p>
<blockquote>
<p>Note: This combination of <code>Pin</code> and <code>Unpin</code> makes it possible to safely implement a whole class of complex types in Rust that would otherwise prove challenging because they‚Äôre self-referential. Types that require <code>Pin</code> show up most commonly in async Rust today, but every once in a while, you might see them in other contexts, too.</p>
<p>The specifics of how <code>Pin</code> and <code>Unpin</code> work, and the rules they‚Äôre required to uphold, are covered extensively in the API documentation for <code>std::pin</code>, so if you‚Äôre interested in learning more, that‚Äôs a great place to start.</p>
<p>If you want to understand how things work under the hood in even more detail, see Chapters <a href="https://rust-lang.github.io/async-book/02_execution/01_chapter.html">2</a> and <a href="https://rust-lang.github.io/async-book/04_pinning/01_chapter.html">4</a> of <a href="https://rust-lang.github.io/async-book/"><em>Asynchronous Programming in Rust</em></a>.</p>
</blockquote>
<h3 id="the-stream-trait"><a class="header" href="#the-stream-trait">The <code>Stream</code> Trait</a></h3>
<p>Now that you have a deeper grasp on the <code>Future</code>, <code>Pin</code>, and <code>Unpin</code> traits, we can turn our attention to the <code>Stream</code> trait. As you learned earlier in the chapter, streams are similar to asynchronous iterators. Unlike <code>Iterator</code> and <code>Future</code>, however, <code>Stream</code> has no definition in the standard library as of this writing, but there <em>is</em> a very common definition from the <code>futures</code> crate used throughout the ecosystem.</p>
<p>Let‚Äôs review the definitions of the <code>Iterator</code> and <code>Future</code> traits before looking at how a <code>Stream</code> trait might merge them together. From <code>Iterator</code>, we have the idea of a sequence: its <code>next</code> method provides an <code>Option&lt;Self::Item&gt;</code>. From <code>Future</code>, we have the idea of readiness over time: its <code>poll</code> method provides a <code>Poll&lt;Self::Output&gt;</code>. To represent a sequence of items that become ready over time, we define a <code>Stream</code> trait that puts those features together:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::pin::Pin;
use std::task::{Context, Poll};

trait Stream {
    type Item;

    fn poll_next(
        self: Pin&lt;&amp;mut Self&gt;,
        cx: &amp;mut Context&lt;'_&gt;
    ) -&gt; Poll&lt;Option&lt;Self::Item&gt;&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>Stream</code> trait defines an associated type called <code>Item</code> for the type of the items produced by the stream. This is similar to <code>Iterator</code>, where there may be zero to many items, and unlike <code>Future</code>, where there is always a single <code>Output</code>, even if it‚Äôs the unit type <code>()</code>.</p>
<p><code>Stream</code> also defines a method to get those items. We call it <code>poll_next</code>, to make it clear that it polls in the same way <code>Future::poll</code> does and produces a sequence of items in the same way <code>Iterator::next</code> does. Its return type combines <code>Poll</code> with <code>Option</code>. The outer type is <code>Poll</code>, because it has to be checked for readiness, just as a future does. The inner type is <code>Option</code>, because it needs to signal whether there are more messages, just as an iterator does.</p>
<p>Something very similar to this definition will likely end up as part of Rust‚Äôs standard library. In the meantime, it‚Äôs part of the toolkit of most runtimes, so you can rely on it, and everything we cover next should generally apply!</p>
<p>In the example we saw in the section on streaming, though, we didn‚Äôt use <code>poll_next</code> <em>or</em> <code>Stream</code>, but instead used <code>next</code> and <code>StreamExt</code>. We <em>could</em> work directly in terms of the <code>poll_next</code> API by hand-writing our own <code>Stream</code> state machines, of course, just as we <em>could</em> work with futures directly via their <code>poll</code> method. Using <code>await</code> is much nicer, though, and the <code>StreamExt</code> trait supplies the <code>next</code> method so we can do just that:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::pin::Pin;
</span><span class="boring">use std::task::{Context, Poll};
</span><span class="boring">
</span><span class="boring">trait Stream {
</span><span class="boring">    type Item;
</span><span class="boring">    fn poll_next(
</span><span class="boring">        self: Pin&lt;&amp;mut Self&gt;,
</span><span class="boring">        cx: &amp;mut Context&lt;'_&gt;,
</span><span class="boring">    ) -&gt; Poll&lt;Option&lt;Self::Item&gt;&gt;;
</span><span class="boring">}
</span><span class="boring">
</span>trait StreamExt: Stream {
    async fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;
    where
        Self: Unpin;

    // other methods...
}
<span class="boring">}</span></code></pre></pre>
<!--
TODO: update this if/when tokio/etc. update their MSRV and switch to using async functions
in traits, since the lack thereof is the reason they do not yet have this.
-->
<blockquote>
<p>Note: The actual definition we used earlier in the chapter looks slightly different than this, because it supports versions of Rust that did not yet support using async functions in traits. As a result, it looks like this:</p>
<pre><code class="language-rust ignore">fn next(&amp;mut self) -&gt; Next&lt;'_, Self&gt; where Self: Unpin;</code></pre>
<p>That <code>Next</code> type is a <code>struct</code> that implements <code>Future</code> and allows us to name the lifetime of the reference to <code>self</code> with <code>Next&lt;'_, Self&gt;</code>, so that <code>await</code> can work with this method.</p>
</blockquote>
<p>The <code>StreamExt</code> trait is also the home of all the interesting methods available to use with streams. <code>StreamExt</code> is automatically implemented for every type that implements <code>Stream</code>, but these traits are defined separately to enable the community to iterate on convenience APIs without affecting the foundational trait.</p>
<p>In the version of <code>StreamExt</code> used in the <code>trpl</code> crate, the trait not only defines the <code>next</code> method but also supplies a default implementation of <code>next</code> that correctly handles the details of calling <code>Stream::poll_next</code>. This means that even when you need to write your own streaming data type, you <em>only</em> have to implement <code>Stream</code>, and then anyone who uses your data type can use <code>StreamExt</code> and its methods with it automatically.</p>
<p>That‚Äôs all we‚Äôre going to cover for the lower-level details on these traits. To wrap up, let‚Äôs consider how futures (including streams), tasks, and threads all fit together!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="putting-it-all-together-futures-tasks-and-threads"><a class="header" href="#putting-it-all-together-futures-tasks-and-threads">Putting It All Together: Futures, Tasks, and Threads</a></h2>
<p>As we saw in <a href="http://localhost:3000/ch16-00-concurrency.html">Chapter 16</a><!-- ignore -->, threads provide one approach to concurrency. We‚Äôve seen another approach in this chapter: using async with futures and streams. If you‚Äòre wondering when to choose method over the other, the answer is: it depends! And in many cases, the choice isn‚Äôt threads <em>or</em> async but rather threads <em>and</em> async.</p>
<p>Many operating systems have supplied threading-based concurrency models for decades now, and many programming languages support them as a result. However, these models are not without their tradeoffs. On many operating systems, they use a fair bit of memory for each thread, and they come with some overhead for starting up and shutting down. Threads are also only an option when your operating system and hardware support them. Unlike mainstream desktop and mobile computers, some embedded systems don‚Äôt have an OS at all, so they also don‚Äôt have threads.</p>
<p>The async model provides a different‚Äîand ultimately complementary‚Äîset of tradeoffs. In the async model, concurrent operations don‚Äôt require their own threads. Instead, they can run on tasks, as when we used <code>trpl::spawn_task</code> to kick off work from a synchronous function in the streams section. A task is similar to a thread, but instead of being managed by the operating system, it‚Äôs managed by library-level code: the runtime.</p>
<p>In the previous section, we saw that we could build a stream by using an async channel and spawning an async task we could call from synchronous code. We can do the exact same thing with a thread. In Listing 17-40, we used <code>trpl::spawn_task</code> and <code>trpl::sleep</code>. In Listing 17-41, we replace those with the <code>thread::spawn</code> and <code>thread::sleep</code> APIs from the standard library in the <code>get_intervals</code> function.</p>
<Listing number="17-41" caption="Using the `std::thread` APIs instead of the async `trpl` APIs for the `get_intervals` function" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, thread, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let messages = get_messages().timeout(Duration::from_millis(200));
</span><span class="boring">        let intervals = get_intervals()
</span><span class="boring">            .map(|count| format!("Interval #{count}"))
</span><span class="boring">            .throttle(Duration::from_millis(500))
</span><span class="boring">            .timeout(Duration::from_secs(10));
</span><span class="boring">        let merged = messages.merge(intervals).take(20);
</span><span class="boring">        let mut stream = pin!(merged);
</span><span class="boring">
</span><span class="boring">        while let Some(result) = stream.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(item) =&gt; println!("{item}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">
</span><span class="boring">        for (index, message) in messages.into_iter().enumerate() {
</span><span class="boring">            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
</span><span class="boring">            trpl::sleep(Duration::from_millis(time_to_sleep)).await;
</span><span class="boring">
</span><span class="boring">            if let Err(send_error) = tx.send(format!("Message: '{message}'")) {
</span><span class="boring">                eprintln!("Cannot send message '{message}': {send_error}");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}
</span><span class="boring">
</span>fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
    let (tx, rx) = trpl::channel();

    // This is *not* `trpl::spawn` but `std::thread::spawn`!
    thread::spawn(move || {
        let mut count = 0;
        loop {
            // Likewise, this is *not* `trpl::sleep` but `std::thread::sleep`!
            thread::sleep(Duration::from_millis(1));
            count += 1;

            if let Err(send_error) = tx.send(count) {
                eprintln!("Could not send interval {count}: {send_error}");
                break;
            };
        }
    });

    ReceiverStream::new(rx)
}</code></pre></pre>
</Listing>
<p>If you run this code, the output is identical to that of Listing 17-40. And notice how little changes here from the perspective of the calling code. What‚Äôs more, even though one of our functions spawned an async task on the runtime and the other spawned an OS thread, the resulting streams were unaffected by the differences.</p>
<p>Despite their similarities, these two approaches behave very differently, although we might have a hard time measuring it in this very simple example. We could spawn millions of async tasks on any modern personal computer. If we tried to do that with threads, we would literally run out of memory!</p>
<p>However, there‚Äôs a reason these APIs are so similar. Threads act as a boundary for sets of synchronous operations; concurrency is possible <em>between</em> threads. Tasks act as a boundary for sets of <em>asynchronous</em> operations; concurrency is possible both <em>between</em> and <em>within</em> tasks, because a task can switch between futures in its body. Finally, futures are Rust‚Äôs most granular unit of concurrency, and each future may represent a tree of other futures. The runtime‚Äîspecifically, its executor‚Äîmanages tasks, and tasks manage futures. In that regard, tasks are similar to lightweight, runtime-managed threads with added capabilities that come from being managed by a runtime instead of by the operating system.</p>
<p>This doesn‚Äôt mean that async tasks are always better than threads (or vice versa). Concurrency with threads is in some ways a simpler programming model than concurrency with <code>async</code>. That can be a strength or a weakness. Threads are somewhat ‚Äúfire and forget‚Äù; they have no native equivalent to a future, so they simply run to completion without being interrupted except by the operating system itself. That is, they have no built-in support for <em>intratask concurrency</em> the way futures do. Threads in Rust also have no mechanisms for cancellation‚Äîa subject we haven‚Äôt covered explicitly in this chapter but was implied by the fact that whenever we ended a future, its state got cleaned up correctly.</p>
<p>These limitations also make threads harder to compose than futures. It‚Äôs much more difficult, for example, to use threads to build helpers such as the <code>timeout</code> and <code>throttle</code> methods we built earlier in this chapter. The fact that futures are richer data structures means they can be composed together more naturally, as we have seen.</p>
<p>Tasks, then, give us <em>additional</em> control over futures, allowing us to choose where and how to group them. And it turns out that threads and tasks often work very well together, because tasks can (at least in some runtimes) be moved around between threads. In fact, under the hood, the runtime we‚Äôve been using‚Äîincluding the <code>spawn_blocking</code> and <code>spawn_task</code> functions‚Äîis multithreaded by default! Many runtimes use an approach called <em>work stealing</em> to transparently move tasks around between threads, based on how the threads are currently being utilized, to improve the system‚Äôs overall performance. That approach actually requires threads <em>and</em> tasks, and therefore futures.</p>
<p>When thinking about which method to use when, consider these rules of thumb:</p>
<ul>
<li>If the work is <em>very parallelizable</em>, such as processing a bunch of data where each part can be processed separately, threads are a better choice.</li>
<li>If the work is <em>very concurrent</em>, such as handling messages from a bunch of different sources that may come in at different intervals or different rates, async is a better choice.</li>
</ul>
<p>And if you need both parallelism and concurrency, you don‚Äôt have to choose between threads and async. You can use them together freely, letting each one play the part it‚Äôs best at. For example, Listing 17-42 shows a fairly common example of this kind of mix in real-world Rust code.</p>
<Listing number="17-42" caption="Sending messages with blocking code in a thread and awaiting the messages in an async block" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // for mdbook test
</span><span class="boring">
</span>use std::{thread, time::Duration};

fn main() {
    let (tx, mut rx) = trpl::channel();

    thread::spawn(move || {
        for i in 1..11 {
            tx.send(i).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    trpl::run(async {
        while let Some(message) = rx.recv().await {
            println!("{message}");
        }
    });
}</code></pre></pre>
</Listing>
<p>We begin by creating an async channel, then spawn a thread that takes ownership of the sender side of the channel. Within the thread, we send the numbers 1 through 10, sleeping for a second between each. Finally, we run a future created with an async block passed to <code>trpl::run</code> just as we have throughout the chapter. In that future, we await those messages, just as in the other message-passing examples we have seen.</p>
<p>To return to the scenario we opened the chapter with, imagine running a set of video encoding tasks using a dedicated thread (because video encoding is compute-bound) but notifying the UI that those operations are done with an async channel. There are countless examples of these kinds of combinations in real-world use cases.</p>
<h2 id="–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-16"><a class="header" href="#–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-16">–ü–æ–¥–≤–µ–¥—ë–º –∏—Ç–æ–≥–∏</a></h2>
<p>This isn‚Äôt the last you‚Äôll see of concurrency in this book. The project in <a href="ch21-00-final-project-a-web-server.html">Chapter 21</a> will apply these concepts in a more realistic situation than the simpler examples discussed here and compare problem-solving with threading versus tasks more directly.</p>
<p>No matter which of these approaches you choose, Rust gives you the tools you need to write safe, fast, concurrent code‚Äîwhether for a high-throughput web server or an embedded operating system.</p>
<p>Next, we‚Äôll talk about idiomatic ways to model problems and structure solutions as your Rust programs get bigger. In addition, we‚Äôll discuss how Rust‚Äôs idioms relate to those you might be familiar with from object-oriented programming.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="object-oriented-programming-features-of-rust"><a class="header" href="#object-oriented-programming-features-of-rust">Object-Oriented Programming Features of Rust</a></h1>
<p>Object-oriented programming (OOP) is a way of modeling programs. Objects as a programmatic concept were introduced in the programming language Simula in the 1960s. Those objects influenced Alan Kay‚Äôs programming architecture in which objects pass messages to each other. To describe this architecture, he coined the term <em>object-oriented programming</em> in 1967. Many competing definitions describe what OOP is, and by some of these definitions Rust is object-oriented, but by others it is not. In this chapter, we‚Äôll explore certain characteristics that are commonly considered object-oriented and how those characteristics translate to idiomatic Rust. We‚Äôll then show you how to implement an object-oriented design pattern in Rust and discuss the trade-offs of doing so versus implementing a solution using some of Rust‚Äôs strengths instead.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∞-–æ–±—ä–µ–∫—Ç–Ω–æ-–æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö-—è–∑—ã–∫–æ–≤"><a class="header" href="#–•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∞-–æ–±—ä–µ–∫—Ç–Ω–æ-–æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö-—è–∑—ã–∫–æ–≤">–•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∞ –æ–±—ä–µ–∫—Ç–Ω–æ-–æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —è–∑—ã–∫–æ–≤</a></h2>
<p>There is no consensus in the programming community about what features a language must have to be considered object-oriented. Rust is influenced by many programming paradigms, including OOP; for example, we explored the features that came from functional programming in Chapter 13. Arguably, OOP languages share certain common characteristics, namely objects, encapsulation, and inheritance. Let‚Äôs look at what each of those characteristics means and whether Rust supports it.</p>
<h3 id="objects-contain-data-and-behavior"><a class="header" href="#objects-contain-data-and-behavior">Objects Contain Data and Behavior</a></h3>
<p>The book <em>Design Patterns: Elements of Reusable Object-Oriented Software</em> by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (Addison-Wesley Professional, 1994), colloquially referred to as <em>The Gang of Four</em> book, is a catalog of object-oriented design patterns. It defines OOP this way:</p>
<blockquote>
<p>Object-oriented programs are made up of objects. An <strong>object</strong> packages both data and the procedures that operate on that data. The procedures are typically called <strong>methods</strong> or <strong>operations</strong>.</p>
</blockquote>
<p>Using this definition, Rust is object-oriented: structs and enums have data, and <code>impl</code> blocks provide methods on structs and enums. Even though structs and enums with methods aren‚Äôt <em>called</em> objects, they provide the same functionality, according to the Gang of Four‚Äôs definition of objects.</p>
<h3 id="encapsulation-that-hides-implementation-details"><a class="header" href="#encapsulation-that-hides-implementation-details">Encapsulation that Hides Implementation Details</a></h3>
<p>Another aspect commonly associated with OOP is the idea of <em>encapsulation</em>, which means that the implementation details of an object aren‚Äôt accessible to code using that object. Therefore, the only way to interact with an object is through its public API; code using the object shouldn‚Äôt be able to reach into the object‚Äôs internals and change data or behavior directly. This enables the programmer to change and refactor an object‚Äôs internals without needing to change the code that uses the object.</p>
<p>We discussed how to control encapsulation in Chapter 7: we can use the <code>pub</code> keyword to decide which modules, types, functions, and methods in our code should be public, and by default everything else is private. For example, we can define a struct <code>AveragedCollection</code> that has a field containing a vector of <code>i32</code> values. The struct can also have a field that contains the average of the values in the vector, meaning the average doesn‚Äôt have to be computed on demand whenever anyone needs it. In other words, <code>AveragedCollection</code> will cache the calculated average for us. Listing 18-1 has the definition of the <code>AveragedCollection</code> struct:</p>
<Listing number="18-1" file-name="src/lib.rs" caption="An `AveragedCollection` struct that maintains a list of integers and the average of the items in the collection">
<pre><code class="language-rust noplayground">pub struct AveragedCollection {
    list: Vec&lt;i32&gt;,
    average: f64,
}</code></pre>
</Listing>
<p>The struct is marked <code>pub</code> so that other code can use it, but the fields within the struct remain private. This is important in this case because we want to ensure that whenever a value is added or removed from the list, the average is also updated. We do this by implementing <code>add</code>, <code>remove</code>, and <code>average</code> methods on the struct, as shown in Listing 18-2:</p>
<Listing number="18-2" file-name="src/lib.rs" caption="Implementations of the public methods `add`, `remove`, and `average` on `AveragedCollection`">
<pre><code class="language-rust noplayground"><span class="boring">pub struct AveragedCollection {
</span><span class="boring">    list: Vec&lt;i32&gt;,
</span><span class="boring">    average: f64,
</span><span class="boring">}
</span><span class="boring">
</span>impl AveragedCollection {
    pub fn add(&amp;mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let result = self.list.pop();
        match result {
            Some(value) =&gt; {
                self.update_average();
                Some(value)
            }
            None =&gt; None,
        }
    }

    pub fn average(&amp;self) -&gt; f64 {
        self.average
    }

    fn update_average(&amp;mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}</code></pre>
</Listing>
<p>The public methods <code>add</code>, <code>remove</code>, and <code>average</code> are the only ways to access or modify data in an instance of <code>AveragedCollection</code>. When an item is added to <code>list</code> using the <code>add</code> method or removed using the <code>remove</code> method, the implementations of each call the private <code>update_average</code> method that handles updating the <code>average</code> field as well.</p>
<p>We leave the <code>list</code> and <code>average</code> fields private so there is no way for external code to add or remove items to or from the <code>list</code> field directly; otherwise, the <code>average</code> field might become out of sync when the <code>list</code> changes. The <code>average</code> method returns the value in the <code>average</code> field, allowing external code to read the <code>average</code> but not modify it.</p>
<p>Because we‚Äôve encapsulated the implementation details of the struct <code>AveragedCollection</code>, we can easily change aspects, such as the data structure, in the future. For instance, we could use a <code>HashSet&lt;i32&gt;</code> instead of a <code>Vec&lt;i32&gt;</code> for the <code>list</code> field. As long as the signatures of the <code>add</code>, <code>remove</code>, and <code>average</code> public methods stay the same, code using <code>AveragedCollection</code> wouldn‚Äôt need to change in order to compile. If we made <code>list</code> public instead, this wouldn‚Äôt necessarily be the case: <code>HashSet&lt;i32&gt;</code> and <code>Vec&lt;i32&gt;</code> have different methods for adding and removing items, so the external code would likely have to change if it were modifying <code>list</code> directly.</p>
<p>If encapsulation is a required aspect for a language to be considered object-oriented, then Rust meets that requirement. The option to use <code>pub</code> or not for different parts of code enables encapsulation of implementation details.</p>
<h3 id="inheritance-as-a-type-system-and-as-code-sharing"><a class="header" href="#inheritance-as-a-type-system-and-as-code-sharing">Inheritance as a Type System and as Code Sharing</a></h3>
<p><em>Inheritance</em> is a mechanism whereby an object can inherit elements from another object‚Äôs definition, thus gaining the parent object‚Äôs data and behavior without you having to define them again.</p>
<p>If a language must have inheritance to be an object-oriented language, then Rust is not one. There is no way to define a struct that inherits the parent struct‚Äôs fields and method implementations without using a macro.</p>
<p>However, if you‚Äôre used to having inheritance in your programming toolbox, you can use other solutions in Rust, depending on your reason for reaching for inheritance in the first place.</p>
<p>You would choose inheritance for two main reasons. One is for reuse of code: you can implement particular behavior for one type, and inheritance enables you to reuse that implementation for a different type. You can do this in a limited way in Rust code using default trait method implementations, which you saw in Listing 10-14 when we added a default implementation of the <code>summarize</code> method on the <code>Summary</code> trait. Any type implementing the <code>Summary</code> trait would have the <code>summarize</code> method available on it without any further code. This is similar to a parent class having an implementation of a method and an inheriting child class also having the implementation of the method. We can also override the default implementation of the <code>summarize</code> method when we implement the <code>Summary</code> trait, which is similar to a child class overriding the implementation of a method inherited from a parent class.</p>
<p>The other reason to use inheritance relates to the type system: to enable a child type to be used in the same places as the parent type. This is also called <em>polymorphism</em>, which means that you can substitute multiple objects for each other at runtime if they share certain characteristics.</p>
<blockquote>
<h3 id="polymorphism"><a class="header" href="#polymorphism">Polymorphism</a></h3>
<p>To many people, polymorphism is synonymous with inheritance. But it‚Äôs actually a more general concept that refers to code that can work with data of multiple types. For inheritance, those types are generally subclasses.</p>
<p>Rust instead uses generics to abstract over different possible types and trait bounds to impose constraints on what those types must provide. This is sometimes called <em>bounded parametric polymorphism</em>.</p>
</blockquote>
<p>Inheritance has recently fallen out of favor as a programming design solution in many programming languages because it‚Äôs often at risk of sharing more code than necessary. Subclasses shouldn‚Äôt always share all characteristics of their parent class but will do so with inheritance. This can make a program‚Äôs design less flexible. It also introduces the possibility of calling methods on subclasses that don‚Äôt make sense or that cause errors because the methods don‚Äôt apply to the subclass. In addition, some languages will only allow <em>single inheritance</em> (meaning a subclass can only inherit from one class), further restricting the flexibility of a program‚Äôs design.</p>
<p>For these reasons, Rust takes the different approach of using trait objects instead of inheritance. Let‚Äôs look at how trait objects enable polymorphism in Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ-—Ç—Ä–µ–π—Ç-–æ–±—ä–µ–∫—Ç–æ–≤-–ø–æ–∑–≤–æ–ª—è—é—â–∏—Ö-–∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å-–∑–Ω–∞—á–µ–Ω–∏—è-—Ä–∞–∑–Ω—ã—Ö-—Ç–∏–ø–æ–≤"><a class="header" href="#–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ-—Ç—Ä–µ–π—Ç-–æ–±—ä–µ–∫—Ç–æ–≤-–ø–æ–∑–≤–æ–ª—è—é—â–∏—Ö-–∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å-–∑–Ω–∞—á–µ–Ω–∏—è-—Ä–∞–∑–Ω—ã—Ö-—Ç–∏–ø–æ–≤">–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Ç—Ä–µ–π—Ç-–æ–±—ä–µ–∫—Ç–æ–≤, –ø–æ–∑–≤–æ–ª—è—é—â–∏—Ö –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤</a></h2>
<p>In Chapter 8, we mentioned that one limitation of vectors is that they can store elements of only one type. We created a workaround in Listing 8-9 where we defined a <code>SpreadsheetCell</code> enum that had variants to hold integers, floats, and text. This meant we could store different types of data in each cell and still have a vector that represented a row of cells. This is a perfectly good solution when our interchangeable items are a fixed set of types that we know when our code is compiled.</p>
<p>However, sometimes we want our library user to be able to extend the set of types that are valid in a particular situation. To show how we might achieve this, we‚Äôll create an example graphical user interface (GUI) tool that iterates through a list of items, calling a <code>draw</code> method on each one to draw it to the screen‚Äîa common technique for GUI tools. We‚Äôll create a library crate called <code>gui</code> that contains the structure of a GUI library. This crate might include some types for people to use, such as <code>Button</code> or <code>TextField</code>. In addition, <code>gui</code> users will want to create their own types that can be drawn: for instance, one programmer might add an <code>Image</code> and another might add a <code>SelectBox</code>.</p>
<p>We won‚Äôt implement a fully fledged GUI library for this example but will show how the pieces would fit together. At the time of writing the library, we can‚Äôt know and define all the types other programmers might want to create. But we do know that <code>gui</code> needs to keep track of many values of different types, and it needs to call a <code>draw</code> method on each of these differently typed values. It doesn‚Äôt need to know exactly what will happen when we call the <code>draw</code> method, just that the value will have that method available for us to call.</p>
<p>To do this in a language with inheritance, we might define a class named <code>Component</code> that has a method named <code>draw</code> on it. The other classes, such as <code>Button</code>, <code>Image</code>, and <code>SelectBox</code>, would inherit from <code>Component</code> and thus inherit the <code>draw</code> method. They could each override the <code>draw</code> method to define their custom behavior, but the framework could treat all of the types as if they were <code>Component</code> instances and call <code>draw</code> on them. But because Rust doesn‚Äôt have inheritance, we need another way to structure the <code>gui</code> library to allow users to extend it with new types.</p>
<h3 id="defining-a-trait-for-common-behavior"><a class="header" href="#defining-a-trait-for-common-behavior">Defining a Trait for Common Behavior</a></h3>
<p>To implement the behavior we want <code>gui</code> to have, we‚Äôll define a trait named <code>Draw</code> that will have one method named <code>draw</code>. Then we can define a vector that takes a trait object. A <em>trait object</em> points to both an instance of a type implementing our specified trait and a table used to look up trait methods on that type at runtime. We create a trait object by specifying some sort of pointer, such as an <code>&amp;</code> reference or a <code>Box&lt;T&gt;</code> smart pointer, then the <code>dyn</code> keyword, and then specifying the relevant trait. (We‚Äôll talk about the reason trait objects must use a pointer in <a href="ch20-03-advanced-types.html#dynamically-sized-types-and-the-sized-trait">‚ÄúDynamically Sized Types and the <code>Sized</code> Trait‚Äù</a><!-- ignore --> in Chapter 20.) We can use trait objects in place of a generic or concrete type. Wherever we use a trait object, Rust‚Äôs type system will ensure at compile time that any value used in that context will implement the trait object‚Äôs trait. Consequently, we don‚Äôt need to know all the possible types at compile time.</p>
<p>We‚Äôve mentioned that, in Rust, we refrain from calling structs and enums ‚Äúobjects‚Äù to distinguish them from other languages‚Äô objects. In a struct or enum, the data in the struct fields and the behavior in <code>impl</code> blocks are separated, whereas in other languages, the data and behavior combined into one concept is often labeled an object. However, trait objects <em>are</em> more like objects in other languages in the sense that they combine data and behavior. But trait objects differ from traditional objects in that we can‚Äôt add data to a trait object. Trait objects aren‚Äôt as generally useful as objects in other languages: their specific purpose is to allow abstraction across common behavior.</p>
<p>Listing 18-3 shows how to define a trait named <code>Draw</code> with one method named <code>draw</code>:</p>
<Listing number="18-3" file-name="src/lib.rs" caption="Definition of the `Draw` trait">
<pre><code class="language-rust noplayground">pub trait Draw {
    fn draw(&amp;self);
}</code></pre>
</Listing>
<p>This syntax should look familiar from our discussions on how to define traits in Chapter 10. Next comes some new syntax: Listing 18-4 defines a struct named <code>Screen</code> that holds a vector named <code>components</code>. This vector is of type <code>Box&lt;dyn Draw&gt;</code>, which is a trait object; it‚Äôs a stand-in for any type inside a <code>Box</code> that implements the <code>Draw</code> trait.</p>
<Listing number="18-4" file-name="src/lib.rs" caption="Definition of the `Screen` struct with a `components` field holding a vector of trait objects that implement the `Draw` trait">
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen {
    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
}</code></pre>
</Listing>
<p>On the <code>Screen</code> struct, we‚Äôll define a method named <code>run</code> that will call the <code>draw</code> method on each of its <code>components</code>, as shown in Listing 18-5:</p>
<Listing number="18-5" file-name="src/lib.rs" caption="A `run` method on `Screen` that calls the `draw` method on each component">
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Screen {
</span><span class="boring">    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Screen {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}</code></pre>
</Listing>
<p>This works differently from defining a struct that uses a generic type parameter with trait bounds. A generic type parameter can be substituted with only one concrete type at a time, whereas trait objects allow for multiple concrete types to fill in for the trait object at runtime. For example, we could have defined the <code>Screen</code> struct using a generic type and a trait bound as in Listing 18-6:</p>
<Listing number="18-6" file-name="src/lib.rs" caption="An alternate implementation of the `Screen` struct and its `run` method using generics and trait bounds">
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen&lt;T: Draw&gt; {
    pub components: Vec&lt;T&gt;,
}

impl&lt;T&gt; Screen&lt;T&gt;
where
    T: Draw,
{
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}</code></pre>
</Listing>
<p>This restricts us to a <code>Screen</code> instance that has a list of components all of type <code>Button</code> or all of type <code>TextField</code>. If you‚Äôll only ever have homogeneous collections, using generics and trait bounds is preferable because the definitions will be monomorphized at compile time to use the concrete types.</p>
<p>On the other hand, with the method using trait objects, one <code>Screen</code> instance can hold a <code>Vec&lt;T&gt;</code> that contains a <code>Box&lt;Button&gt;</code> as well as a <code>Box&lt;TextField&gt;</code>. Let‚Äôs look at how this works, and then we‚Äôll talk about the runtime performance implications.</p>
<h3 id="implementing-the-trait"><a class="header" href="#implementing-the-trait">Implementing the Trait</a></h3>
<p>Now we‚Äôll add some types that implement the <code>Draw</code> trait. We‚Äôll provide the <code>Button</code> type. Again, actually implementing a GUI library is beyond the scope of this book, so the <code>draw</code> method won‚Äôt have any useful implementation in its body. To imagine what the implementation might look like, a <code>Button</code> struct might have fields for <code>width</code>, <code>height</code>, and <code>label</code>, as shown in Listing 18-7:</p>
<Listing number="18-7" file-name="src/lib.rs" caption="A `Button` struct that implements the `Draw` trait">
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Screen {
</span><span class="boring">    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Screen {
</span><span class="boring">    pub fn run(&amp;self) {
</span><span class="boring">        for component in self.components.iter() {
</span><span class="boring">            component.draw();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&amp;self) {
        // code to actually draw a button
    }
}</code></pre>
</Listing>
<p>The <code>width</code>, <code>height</code>, and <code>label</code> fields on <code>Button</code> will differ from the fields on other components; for example, a <code>TextField</code> type might have those same fields plus a <code>placeholder</code> field. Each of the types we want to draw on the screen will implement the <code>Draw</code> trait but will use different code in the <code>draw</code> method to define how to draw that particular type, as <code>Button</code> has here (without the actual GUI code, as mentioned). The <code>Button</code> type, for instance, might have an additional <code>impl</code> block containing methods related to what happens when a user clicks the button. These kinds of methods won‚Äôt apply to types like <code>TextField</code>.</p>
<p>If someone using our library decides to implement a <code>SelectBox</code> struct that has <code>width</code>, <code>height</code>, and <code>options</code> fields, they implement the <code>Draw</code> trait on the <code>SelectBox</code> type as well, as shown in Listing 18-8:</p>
<Listing number="18-8" file-name="src/main.rs" caption="Another crate using `gui` and implementing the `Draw` trait on a `SelectBox` struct">
<pre><code class="language-rust ignore">use gui::Draw;

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec&lt;String&gt;,
}

impl Draw for SelectBox {
    fn draw(&amp;self) {
        // code to actually draw a select box
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
</Listing>
<p>Our library‚Äôs user can now write their <code>main</code> function to create a <code>Screen</code> instance. To the <code>Screen</code> instance, they can add a <code>SelectBox</code> and a <code>Button</code> by putting each in a <code>Box&lt;T&gt;</code> to become a trait object. They can then call the <code>run</code> method on the <code>Screen</code> instance, which will call <code>draw</code> on each of the components. Listing 18-9 shows this implementation:</p>
<Listing number="18-9" file-name="src/main.rs" caption="Using trait objects to store values of different types that implement the same trait">
<pre><code class="language-rust ignore"><span class="boring">use gui::Draw;
</span><span class="boring">
</span><span class="boring">struct SelectBox {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">    options: Vec&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Draw for SelectBox {
</span><span class="boring">    fn draw(&amp;self) {
</span><span class="boring">        // code to actually draw a select box
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>use gui::{Button, Screen};

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from("Yes"),
                    String::from("Maybe"),
                    String::from("No"),
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from("OK"),
            }),
        ],
    };

    screen.run();
}</code></pre>
</Listing>
<p>When we wrote the library, we didn‚Äôt know that someone might add the <code>SelectBox</code> type, but our <code>Screen</code> implementation was able to operate on the new type and draw it because <code>SelectBox</code> implements the <code>Draw</code> trait, which means it implements the <code>draw</code> method.</p>
<p>This concept‚Äîof being concerned only with the messages a value responds to rather than the value‚Äôs concrete type‚Äîis similar to the concept of <em>duck typing</em> in dynamically typed languages: if it walks like a duck and quacks like a duck, then it must be a duck! In the implementation of <code>run</code> on <code>Screen</code> in Listing 18-5, <code>run</code> doesn‚Äôt need to know what the concrete type of each component is. It doesn‚Äôt check whether a component is an instance of a <code>Button</code> or a <code>SelectBox</code>, it just calls the <code>draw</code> method on the component. By specifying <code>Box&lt;dyn Draw&gt;</code> as the type of the values in the <code>components</code> vector, we‚Äôve defined <code>Screen</code> to need values that we can call the <code>draw</code> method on.</p>
<p>The advantage of using trait objects and Rust‚Äôs type system to write code similar to code using duck typing is that we never have to check whether a value implements a particular method at runtime or worry about getting errors if a value doesn‚Äôt implement a method but we call it anyway. Rust won‚Äôt compile our code if the values don‚Äôt implement the traits that the trait objects need.</p>
<p>For example, Listing 18-10 shows what happens if we try to create a <code>Screen</code> with a <code>String</code> as a component:</p>
<Listing number="18-10" file-name="src/main.rs" caption="Attempting to use a type that doesn‚Äôt implement the trait object‚Äôs trait">
<pre><code class="language-rust ignore does_not_compile">use gui::Screen;

fn main() {
    let screen = Screen {
        components: vec![Box::new(String::from("Hi"))],
    };

    screen.run();
}</code></pre>
</Listing>
<p>We‚Äôll get this error because <code>String</code> doesn‚Äôt implement the <code>Draw</code> trait:</p>
<pre><code class="language-console">$ cargo run
   Compiling gui v0.1.0 (file:///projects/gui)
error[E0277]: the trait bound `String: Draw` is not satisfied
 --&gt; src/main.rs:5:26
  |
5 |         components: vec![Box::new(String::from("Hi"))],
  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Draw` is not implemented for `String`
  |
  = help: the trait `Draw` is implemented for `Button`
  = note: required for the cast from `Box&lt;String&gt;` to `Box&lt;dyn Draw&gt;`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `gui` (bin "gui") due to 1 previous error
</code></pre>
<p>This error lets us know that either we‚Äôre passing something to <code>Screen</code> we didn‚Äôt mean to pass and so should pass a different type or we should implement <code>Draw</code> on <code>String</code> so that <code>Screen</code> is able to call <code>draw</code> on it.</p>
<h3 id="trait-objects-perform-dynamic-dispatch"><a class="header" href="#trait-objects-perform-dynamic-dispatch">Trait Objects Perform Dynamic Dispatch</a></h3>
<p>Recall in <a href="ch10-01-syntax.html#performance-of-code-using-generics">‚ÄúPerformance of Code Using Generics‚Äù</a><!-- ignore --> in Chapter 10 our discussion on the monomorphization process performed on generics by the compiler: the compiler generates nongeneric implementations of functions and methods for each concrete type that we use in place of a generic type parameter. The code that results from monomorphization is doing <em>static dispatch</em>, which is when the compiler knows what method you‚Äôre calling at compile time. This is opposed to <em>dynamic dispatch</em>, which is when the compiler can‚Äôt tell at compile time which method you‚Äôre calling. In dynamic dispatch cases, the compiler emits code that at runtime will figure out which method to call.</p>
<p>When we use trait objects, Rust must use dynamic dispatch. The compiler doesn‚Äôt know all the types that might be used with the code that‚Äôs using trait objects, so it doesn‚Äôt know which method implemented on which type to call. Instead, at runtime, Rust uses the pointers inside the trait object to know which method to call. This lookup incurs a runtime cost that doesn‚Äôt occur with static dispatch. Dynamic dispatch also prevents the compiler from choosing to inline a method‚Äôs code, which in turn prevents some optimizations, and Rust has some rules about where you can and cannot use dynamic dispatch, called <a href="https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility"><em>dyn compatibility</em></a>. However, we did get extra flexibility in the code that we wrote in Listing 18-5 and were able to support in Listing 18-9, so it‚Äôs a trade-off to consider.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="implementing-an-object-oriented-design-pattern"><a class="header" href="#implementing-an-object-oriented-design-pattern">Implementing an Object-Oriented Design Pattern</a></h2>
<p>The <em>state pattern</em> is an object-oriented design pattern. The crux of the pattern is that we define a set of states a value can have internally. The states are represented by a set of <em>state objects</em>, and the value‚Äôs behavior changes based on its state. We‚Äôre going to work through an example of a blog post struct that has a field to hold its state, which will be a state object from the set "draft", "review", or "published".</p>
<p>The state objects share functionality: in Rust, of course, we use structs and traits rather than objects and inheritance. Each state object is responsible for its own behavior and for governing when it should change into another state. The value that holds a state object knows nothing about the different behavior of the states or when to transition between states.</p>
<p>The advantage of using the state pattern is that, when the business requirements of the program change, we won‚Äôt need to change the code of the value holding the state or the code that uses the value. We‚Äôll only need to update the code inside one of the state objects to change its rules or perhaps add more state objects.</p>
<p>First, we‚Äôre going to implement the state pattern in a more traditional object-oriented way, then we‚Äôll use an approach that‚Äôs a bit more natural in Rust. Let‚Äôs dig in to incrementally implementing a blog post workflow using the state pattern.</p>
<p>The final functionality will look like this:</p>
<ol>
<li>A blog post starts as an empty draft.</li>
<li>When the draft is done, a review of the post is requested.</li>
<li>When the post is approved, it gets published.</li>
<li>Only published blog posts return content to print, so unapproved posts can‚Äôt accidentally be published.</li>
</ol>
<p>Any other changes attempted on a post should have no effect. For example, if we try to approve a draft blog post before we‚Äôve requested a review, the post should remain an unpublished draft.</p>
<p>Listing 18-11 shows this workflow in code form: this is an example usage of the API we‚Äôll implement in a library crate named <code>blog</code>. This won‚Äôt compile yet because we haven‚Äôt implemented the <code>blog</code> crate.</p>
<Listing number="18-11" file-name="src/main.rs" caption="Code that demonstrates the desired behavior we want our `blog` crate to have">
<pre><code class="language-rust ignore does_not_compile">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");
    assert_eq!("", post.content());

    post.request_review();
    assert_eq!("", post.content());

    post.approve();
    assert_eq!("I ate a salad for lunch today", post.content());
}</code></pre>
</Listing>
<p>We want to allow the user to create a new draft blog post with <code>Post::new</code>. We want to allow text to be added to the blog post. If we try to get the post‚Äôs content immediately, before approval, we shouldn‚Äôt get any text because the post is still a draft. We‚Äôve added <code>assert_eq!</code> in the code for demonstration purposes. An excellent unit test for this would be to assert that a draft blog post returns an empty string from the <code>content</code> method, but we‚Äôre not going to write tests for this example.</p>
<p>Next, we want to enable a request for a review of the post, and we want <code>content</code> to return an empty string while waiting for the review. When the post receives approval, it should get published, meaning the text of the post will be returned when <code>content</code> is called.</p>
<p>Notice that the only type we‚Äôre interacting with from the crate is the <code>Post</code> type. This type will use the state pattern and will hold a value that will be one of three state objects representing the various states a post can be in‚Äîdraft, waiting for review, or published. Changing from one state to another will be managed internally within the <code>Post</code> type. The states change in response to the methods called by our library‚Äôs users on the <code>Post</code> instance, but they don‚Äôt have to manage the state changes directly. Also, users can‚Äôt make a mistake with the states, like publishing a post before it‚Äôs reviewed.</p>
<h3 id="defining-post-and-creating-a-new-instance-in-the-draft-state"><a class="header" href="#defining-post-and-creating-a-new-instance-in-the-draft-state">Defining <code>Post</code> and Creating a New Instance in the Draft State</a></h3>
<p>Let‚Äôs get started on the implementation of the library! We know we need a public <code>Post</code> struct that holds some content, so we‚Äôll start with the definition of the struct and an associated public <code>new</code> function to create an instance of <code>Post</code>, as shown in Listing 18-12. We‚Äôll also make a private <code>State</code> trait that will define the behavior that all state objects for a <code>Post</code> must have.</p>
<p>Then <code>Post</code> will hold a trait object of <code>Box&lt;dyn State&gt;</code> inside an <code>Option&lt;T&gt;</code> in a private field named <code>state</code> to hold the state object. You‚Äôll see why the <code>Option&lt;T&gt;</code> is necessary in a bit.</p>
<Listing number="18-12" file-name="src/lib.rs" caption="Definition of a `Post` struct and a `new` function that creates a new `Post` instance, a `State` trait, and a `Draft` struct">
<pre><code class="language-rust noplayground">pub struct Post {
    state: Option&lt;Box&lt;dyn State&gt;&gt;,
    content: String,
}

impl Post {
    pub fn new() -&gt; Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}</code></pre>
</Listing>
<p>The <code>State</code> trait defines the behavior shared by different post states. The state objects are <code>Draft</code>, <code>PendingReview</code>, and <code>Published</code>, and they will all implement the <code>State</code> trait. For now, the trait doesn‚Äôt have any methods, and we‚Äôll start by defining just the <code>Draft</code> state because that is the state we want a post to start in.</p>
<p>When we create a new <code>Post</code>, we set its <code>state</code> field to a <code>Some</code> value that holds a <code>Box</code>. This <code>Box</code> points to a new instance of the <code>Draft</code> struct. This ensures whenever we create a new instance of <code>Post</code>, it will start out as a draft. Because the <code>state</code> field of <code>Post</code> is private, there is no way to create a <code>Post</code> in any other state! In the <code>Post::new</code> function, we set the <code>content</code> field to a new, empty <code>String</code>.</p>
<h3 id="storing-the-text-of-the-post-content"><a class="header" href="#storing-the-text-of-the-post-content">Storing the Text of the Post Content</a></h3>
<p>We saw in Listing 18-11 that we want to be able to call a method named <code>add_text</code> and pass it a <code>&amp;str</code> that is then added as the text content of the blog post. We implement this as a method, rather than exposing the <code>content</code> field as <code>pub</code>, so that later we can implement a method that will control how the <code>content</code> field‚Äôs data is read. The <code>add_text</code> method is pretty straightforward, so let‚Äôs add the implementation in Listing 18-13 to the <code>impl Post</code> block:</p>
<Listing number="18-13" file-name="src/lib.rs" caption="Implementing the `add_text` method to add text to a post‚Äôs `content`">
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}</span></code></pre>
</Listing>
<p>The <code>add_text</code> method takes a mutable reference to <code>self</code>, because we‚Äôre changing the <code>Post</code> instance that we‚Äôre calling <code>add_text</code> on. We then call <code>push_str</code> on the <code>String</code> in <code>content</code> and pass the <code>text</code> argument to add to the saved <code>content</code>. This behavior doesn‚Äôt depend on the state the post is in, so it‚Äôs not part of the state pattern. The <code>add_text</code> method doesn‚Äôt interact with the <code>state</code> field at all, but it is part of the behavior we want to support.</p>
<h3 id="ensuring-the-content-of-a-draft-post-is-empty"><a class="header" href="#ensuring-the-content-of-a-draft-post-is-empty">Ensuring the Content of a Draft Post Is Empty</a></h3>
<p>Even after we‚Äôve called <code>add_text</code> and added some content to our post, we still want the <code>content</code> method to return an empty string slice because the post is still in the draft state, as shown on line 7 of Listing 18-11. For now, let‚Äôs implement the <code>content</code> method with the simplest thing that will fulfill this requirement: always returning an empty string slice. We‚Äôll change this later once we implement the ability to change a post‚Äôs state so it can be published. So far, posts can only be in the draft state, so the post content should always be empty. Listing 18-14 shows this placeholder implementation:</p>
<Listing number="18-14" file-name="src/lib.rs" caption="Adding a placeholder implementation for the `content` method on `Post` that always returns an empty string slice">
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        ""
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}</span></code></pre>
</Listing>
<p>With this added <code>content</code> method, everything in Listing 18-11 up to line 7 works as intended.</p>
<h3 id="requesting-a-review-of-the-post-changes-its-state"><a class="header" href="#requesting-a-review-of-the-post-changes-its-state">Requesting a Review of the Post Changes Its State</a></h3>
<p>Next, we need to add functionality to request a review of a post, which should change its state from <code>Draft</code> to <code>PendingReview</code>. Listing 18-15 shows this code:</p>
<Listing number="18-15" file-name="src/lib.rs" caption="Implementing `request_review` methods on `Post` and the `State` trait">
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        ""
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}</code></pre>
</Listing>
<p>We give <code>Post</code> a public method named <code>request_review</code> that will take a mutable reference to <code>self</code>. Then we call an internal <code>request_review</code> method on the current state of <code>Post</code>, and this second <code>request_review</code> method consumes the current state and returns a new state.</p>
<p>We add the <code>request_review</code> method to the <code>State</code> trait; all types that implement the trait will now need to implement the <code>request_review</code> method. Note that rather than having <code>self</code>, <code>&amp;self</code>, or <code>&amp;mut self</code> as the first parameter of the method, we have <code>self: Box&lt;Self&gt;</code>. This syntax means the method is only valid when called on a <code>Box</code> holding the type. This syntax takes ownership of <code>Box&lt;Self&gt;</code>, invalidating the old state so the state value of the <code>Post</code> can transform into a new state.</p>
<p>To consume the old state, the <code>request_review</code> method needs to take ownership of the state value. This is where the <code>Option</code> in the <code>state</code> field of <code>Post</code> comes in: we call the <code>take</code> method to take the <code>Some</code> value out of the <code>state</code> field and leave a <code>None</code> in its place, because Rust doesn‚Äôt let us have unpopulated fields in structs. This lets us move the <code>state</code> value out of <code>Post</code> rather than borrowing it. Then we‚Äôll set the post‚Äôs <code>state</code> value to the result of this operation.</p>
<p>We need to set <code>state</code> to <code>None</code> temporarily rather than setting it directly with code like <code>self.state = self.state.request_review();</code> to get ownership of the <code>state</code> value. This ensures <code>Post</code> can‚Äôt use the old <code>state</code> value after we‚Äôve transformed it into a new state.</p>
<p>The <code>request_review</code> method on <code>Draft</code> returns a new, boxed instance of a new <code>PendingReview</code> struct, which represents the state when a post is waiting for a review. The <code>PendingReview</code> struct also implements the <code>request_review</code> method but doesn‚Äôt do any transformations. Rather, it returns itself, because when we request a review on a post already in the <code>PendingReview</code> state, it should stay in the <code>PendingReview</code> state.</p>
<p>Now we can start seeing the advantages of the state pattern: the <code>request_review</code> method on <code>Post</code> is the same no matter its <code>state</code> value. Each state is responsible for its own rules.</p>
<p>We‚Äôll leave the <code>content</code> method on <code>Post</code> as is, returning an empty string slice. We can now have a <code>Post</code> in the <code>PendingReview</code> state as well as in the <code>Draft</code> state, but we want the same behavior in the <code>PendingReview</code> state. Listing 18-11 now works up to line 10!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="adding-the-approve-method-that-changes-the-behavior-of-content"></a></p>
<h3 id="adding-approve-to-change-the-behavior-of-content"><a class="header" href="#adding-approve-to-change-the-behavior-of-content">Adding <code>approve</code> to Change the Behavior of <code>content</code></a></h3>
<p>The <code>approve</code> method will be similar to the <code>request_review</code> method: it will set <code>state</code> to the value that the current state says it should have when that state is approved, as shown in Listing 18-16:</p>
<Listing number="18-16" file-name="src/lib.rs" caption="Implementing the `approve` method on `Post` and the `State` trait">
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        ""
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn approve(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }

    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}</code></pre>
</Listing>
<p>We add the <code>approve</code> method to the <code>State</code> trait and add a new struct that implements <code>State</code>, the <code>Published</code> state.</p>
<p>Similar to the way <code>request_review</code> on <code>PendingReview</code> works, if we call the <code>approve</code> method on a <code>Draft</code>, it will have no effect because <code>approve</code> will return <code>self</code>. When we call <code>approve</code> on <code>PendingReview</code>, it returns a new, boxed instance of the <code>Published</code> struct. The <code>Published</code> struct implements the <code>State</code> trait, and for both the <code>request_review</code> method and the <code>approve</code> method, it returns itself, because the post should stay in the <code>Published</code> state in those cases.</p>
<p>Now we need to update the <code>content</code> method on <code>Post</code>. We want the value returned from <code>content</code> to depend on the current state of the <code>Post</code>, so we‚Äôre going to have the <code>Post</code> delegate to a <code>content</code> method defined on its <code>state</code>, as shown in Listing 18-17:</p>
<Listing number="18-17" file-name="src/lib.rs" caption="Updating the `content` method on `Post` to delegate to a `content` method on `State`">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        self.state.as_ref().unwrap().content(self)
    }
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">trait State {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Published {}
</span><span class="boring">
</span><span class="boring">impl State for Published {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>Because the goal is to keep all these rules inside the structs that implement <code>State</code>, we call a <code>content</code> method on the value in <code>state</code> and pass the post instance (that is, <code>self</code>) as an argument. Then we return the value that‚Äôs returned from using the <code>content</code> method on the <code>state</code> value.</p>
<p>We call the <code>as_ref</code> method on the <code>Option</code> because we want a reference to the value inside the <code>Option</code> rather than ownership of the value. Because <code>state</code> is an <code>Option&lt;Box&lt;dyn State&gt;&gt;</code>, when we call <code>as_ref</code>, an <code>Option&lt;&amp;Box&lt;dyn State&gt;&gt;</code> is returned. If we didn‚Äôt call <code>as_ref</code>, we would get an error because we can‚Äôt move <code>state</code> out of the borrowed <code>&amp;self</code> of the function parameter.</p>
<p>We then call the <code>unwrap</code> method, which we know will never panic, because we know the methods on <code>Post</code> ensure that <code>state</code> will always contain a <code>Some</code> value when those methods are done. This is one of the cases we talked about in the <a href="ch09-03-to-panic-or-not-to-panic.html#cases-in-which-you-have-more-information-than-the-compiler">‚ÄúCases In Which You Have More Information Than the Compiler‚Äù</a><!-- ignore --> section of Chapter 9 when we know that a <code>None</code> value is never possible, even though the compiler isn‚Äôt able to understand that.</p>
<p>At this point, when we call <code>content</code> on the <code>&amp;Box&lt;dyn State&gt;</code>, deref coercion will take effect on the <code>&amp;</code> and the <code>Box</code> so the <code>content</code> method will ultimately be called on the type that implements the <code>State</code> trait. That means we need to add <code>content</code> to the <code>State</code> trait definition, and that is where we‚Äôll put the logic for what content to return depending on which state we have, as shown in Listing 18-18:</p>
<Listing number="18-18" file-name="src/lib.rs" caption="Adding the `content` method to the `State` trait">
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        self.state.as_ref().unwrap().content(self)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>trait State {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        ""
    }
}

// --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Published {}

impl State for Published {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &amp;post.content
    }
}</code></pre>
</Listing>
<p>We add a default implementation for the <code>content</code> method that returns an empty string slice. That means we don‚Äôt need to implement <code>content</code> on the <code>Draft</code> and <code>PendingReview</code> structs. The <code>Published</code> struct will override the <code>content</code> method and return the value in <code>post.content</code>.</p>
<p>Note that we need lifetime annotations on this method, as we discussed in Chapter 10. We‚Äôre taking a reference to a <code>post</code> as an argument and returning a reference to part of that <code>post</code>, so the lifetime of the returned reference is related to the lifetime of the <code>post</code> argument.</p>
<p>And we‚Äôre done‚Äîall of Listing 18-11 now works! We‚Äôve implemented the state pattern with the rules of the blog post workflow. The logic related to the rules lives in the state objects rather than being scattered throughout <code>Post</code>.</p>
<blockquote>
<h4 id="why-not-an-enum"><a class="header" href="#why-not-an-enum">Why Not An Enum?</a></h4>
<p>You may have been wondering why we didn‚Äôt use an <code>enum</code> with the different possible post states as variants. That‚Äôs certainly a possible solution, try it and compare the end results to see which you prefer! One disadvantage of using an enum is every place that checks the value of the enum will need a <code>match</code> expression or similar to handle every possible variant. This could get more repetitive than this trait object solution.</p>
</blockquote>
<h3 id="trade-offs-of-the-state-pattern"><a class="header" href="#trade-offs-of-the-state-pattern">Trade-offs of the State Pattern</a></h3>
<p>We‚Äôve shown that Rust is capable of implementing the object-oriented state pattern to encapsulate the different kinds of behavior a post should have in each state. The methods on <code>Post</code> know nothing about the various behaviors. The way we organized the code, we have to look in only one place to know the different ways a published post can behave: the implementation of the <code>State</code> trait on the <code>Published</code> struct.</p>
<p>If we were to create an alternative implementation that didn‚Äôt use the state pattern, we might instead use <code>match</code> expressions in the methods on <code>Post</code> or even in the <code>main</code> code that checks the state of the post and changes behavior in those places. That would mean we would have to look in several places to understand all the implications of a post being in the published state! This would only increase the more states we added: each of those <code>match</code> expressions would need another arm.</p>
<p>With the state pattern, the <code>Post</code> methods and the places we use <code>Post</code> don‚Äôt need <code>match</code> expressions, and to add a new state, we would only need to add a new struct and implement the trait methods on that one struct.</p>
<p>The implementation using the state pattern is easy to extend to add more functionality. To see the simplicity of maintaining code that uses the state pattern, try a few of these suggestions:</p>
<ul>
<li>Add a <code>reject</code> method that changes the post‚Äôs state from <code>PendingReview</code> back to <code>Draft</code>.</li>
<li>Require two calls to <code>approve</code> before the state can be changed to <code>Published</code>.</li>
<li>Allow users to add text content only when a post is in the <code>Draft</code> state. Hint: have the state object responsible for what might change about the content but not responsible for modifying the <code>Post</code>.</li>
</ul>
<p>One downside of the state pattern is that, because the states implement the transitions between states, some of the states are coupled to each other. If we add another state between <code>PendingReview</code> and <code>Published</code>, such as <code>Scheduled</code>, we would have to change the code in <code>PendingReview</code> to transition to <code>Scheduled</code> instead. It would be less work if <code>PendingReview</code> didn‚Äôt need to change with the addition of a new state, but that would mean switching to another design pattern.</p>
<p>Another downside is that we‚Äôve duplicated some logic. To eliminate some of the duplication, we might try to make default implementations for the <code>request_review</code> and <code>approve</code> methods on the <code>State</code> trait that return <code>self</code>; however, this would not be dyn compatible, because the trait doesn‚Äôt know what the concrete <code>self</code> will be exactly. We want to be able to use <code>State</code> as a trait object, so we need its methods to be dyn compatible.</p>
<p>Other duplication includes the similar implementations of the <code>request_review</code> and <code>approve</code> methods on <code>Post</code>. Both methods delegate to the implementation of the same method on the value in the <code>state</code> field of <code>Option</code> and set the new value of the <code>state</code> field to the result. If we had a lot of methods on <code>Post</code> that followed this pattern, we might consider defining a macro to eliminate the repetition (see the <a href="ch20-05-macros.html#macros">‚ÄúMacros‚Äù</a><!-- ignore --> section in Chapter 20).</p>
<p>By implementing the state pattern exactly as it‚Äôs defined for object-oriented languages, we‚Äôre not taking as full advantage of Rust‚Äôs strengths as we could. Let‚Äôs look at some changes we can make to the <code>blog</code> crate that can make invalid states and transitions into compile time errors.</p>
<h4 id="–ö–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ-–≤-—Ç–∏–ø–∞—Ö-—Å–æ—Å—Ç–æ—è–Ω–∏–π-–∏-–ø–æ–≤–µ–¥–µ–Ω–∏—è"><a class="header" href="#–ö–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ-–≤-—Ç–∏–ø–∞—Ö-—Å–æ—Å—Ç–æ—è–Ω–∏–π-–∏-–ø–æ–≤–µ–¥–µ–Ω–∏—è">–ö–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤ —Ç–∏–ø–∞—Ö —Å–æ—Å—Ç–æ—è–Ω–∏–π –∏ –ø–æ–≤–µ–¥–µ–Ω–∏—è</a></h4>
<p>We‚Äôll show you how to rethink the state pattern to get a different set of trade-offs. Rather than encapsulating the states and transitions completely so outside code has no knowledge of them, we‚Äôll encode the states into different types. Consequently, Rust‚Äôs type checking system will prevent attempts to use draft posts where only published posts are allowed by issuing a compiler error.</p>
<p>Let‚Äôs consider the first part of <code>main</code> in Listing 18-11:</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore"><span class="boring">use blog::Post;
</span><span class="boring">
</span>fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");
    assert_eq!("", post.content());
<span class="boring">
</span><span class="boring">    post.request_review();
</span><span class="boring">    assert_eq!("", post.content());
</span><span class="boring">
</span><span class="boring">    post.approve();
</span><span class="boring">    assert_eq!("I ate a salad for lunch today", post.content());
</span>}</code></pre>
</Listing>
<p>We still enable the creation of new posts in the draft state using <code>Post::new</code> and the ability to add text to the post‚Äôs content. But instead of having a <code>content</code> method on a draft post that returns an empty string, we‚Äôll make it so draft posts don‚Äôt have the <code>content</code> method at all. That way, if we try to get a draft post‚Äôs content, we‚Äôll get a compiler error telling us the method doesn‚Äôt exist. As a result, it will be impossible for us to accidentally display draft post content in production, because that code won‚Äôt even compile. Listing 18-19 shows the definition of a <code>Post</code> struct and a <code>DraftPost</code> struct, as well as methods on each:</p>
<Listing number="18-19" file-name="src/lib.rs" caption="A `Post` with a `content` method and `DraftPost` without a `content` method">
<pre><code class="language-rust noplayground">pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -&gt; DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&amp;self) -&gt; &amp;str {
        &amp;self.content
    }
}

impl DraftPost {
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}</code></pre>
</Listing>
<p>Both the <code>Post</code> and <code>DraftPost</code> structs have a private <code>content</code> field that stores the blog post text. The structs no longer have the <code>state</code> field because we‚Äôre moving the encoding of the state to the types of the structs. The <code>Post</code> struct will represent a published post, and it has a <code>content</code> method that returns the <code>content</code>.</p>
<p>We still have a <code>Post::new</code> function, but instead of returning an instance of <code>Post</code>, it returns an instance of <code>DraftPost</code>. Because <code>content</code> is private and there aren‚Äôt any functions that return <code>Post</code>, it‚Äôs not possible to create an instance of <code>Post</code> right now.</p>
<p>The <code>DraftPost</code> struct has an <code>add_text</code> method, so we can add text to <code>content</code> as before, but note that <code>DraftPost</code> does not have a <code>content</code> method defined! So now the program ensures all posts start as draft posts, and draft posts don‚Äôt have their content available for display. Any attempt to get around these constraints will result in a compiler error.</p>
<h4 id="implementing-transitions-as-transformations-into-different-types"><a class="header" href="#implementing-transitions-as-transformations-into-different-types">Implementing Transitions as Transformations into Different Types</a></h4>
<p>So how do we get a published post? We want to enforce the rule that a draft post has to be reviewed and approved before it can be published. A post in the pending review state should still not display any content. Let‚Äôs implement these constraints by adding another struct, <code>PendingReviewPost</code>, defining the <code>request_review</code> method on <code>DraftPost</code> to return a <code>PendingReviewPost</code>, and defining an <code>approve</code> method on <code>PendingReviewPost</code> to return a <code>Post</code>, as shown in Listing 18-20:</p>
<Listing number="18-20" file-name="src/lib.rs" caption="A `PendingReviewPost` that gets created by calling `request_review` on `DraftPost` and an `approve` method that turns a `PendingReviewPost` into a published `Post`">
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct DraftPost {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; DraftPost {
</span><span class="boring">        DraftPost {
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.content
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl DraftPost {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(self) -&gt; PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -&gt; Post {
        Post {
            content: self.content,
        }
    }
}</code></pre>
</Listing>
<p>The <code>request_review</code> and <code>approve</code> methods take ownership of <code>self</code>, thus consuming the <code>DraftPost</code> and <code>PendingReviewPost</code> instances and transforming them into a <code>PendingReviewPost</code> and a published <code>Post</code>, respectively. This way, we won‚Äôt have any lingering <code>DraftPost</code> instances after we‚Äôve called <code>request_review</code> on them, and so forth. The <code>PendingReviewPost</code> struct doesn‚Äôt have a <code>content</code> method defined on it, so attempting to read its content results in a compiler error, as with <code>DraftPost</code>. Because the only way to get a published <code>Post</code> instance that does have a <code>content</code> method defined is to call the <code>approve</code> method on a <code>PendingReviewPost</code>, and the only way to get a <code>PendingReviewPost</code> is to call the <code>request_review</code> method on a <code>DraftPost</code>, we‚Äôve now encoded the blog post workflow into the type system.</p>
<p>But we also have to make some small changes to <code>main</code>. The <code>request_review</code> and <code>approve</code> methods return new instances rather than modifying the struct they‚Äôre called on, so we need to add more <code>let post =</code> shadowing assignments to save the returned instances. We also can‚Äôt have the assertions about the draft and pending review posts‚Äô contents be empty strings, nor do we need them: we can‚Äôt compile code that tries to use the content of posts in those states any longer. The updated code in <code>main</code> is shown in Listing 18-21:</p>
<Listing number="18-21" file-name="src/main.rs" caption="Modifications to `main` to use the new implementation of the blog post workflow">
<pre><code class="language-rust ignore">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");

    let post = post.request_review();

    let post = post.approve();

    assert_eq!("I ate a salad for lunch today", post.content());
}</code></pre>
</Listing>
<p>The changes we needed to make to <code>main</code> to reassign <code>post</code> mean that this implementation doesn‚Äôt quite follow the object-oriented state pattern anymore: the transformations between the states are no longer encapsulated entirely within the <code>Post</code> implementation. However, our gain is that invalid states are now impossible because of the type system and the type checking that happens at compile time! This ensures that certain bugs, such as display of the content of an unpublished post, will be discovered before they make it to production.</p>
<p>Try the tasks suggested at the start of this section on the <code>blog</code> crate as it is after Listing 18-21 to see what you think about the design of this version of the code. Note that some of the tasks might be completed already in this design.</p>
<p>We‚Äôve seen that even though Rust is capable of implementing object-oriented design patterns, other patterns, such as encoding state into the type system, are also available in Rust. These patterns have different trade-offs. Although you might be very familiar with object-oriented patterns, rethinking the problem to take advantage of Rust‚Äôs features can provide benefits, such as preventing some bugs at compile time. Object-oriented patterns won‚Äôt always be the best solution in Rust due to certain features, like ownership, that object-oriented languages don‚Äôt have.</p>
<h2 id="–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-17"><a class="header" href="#–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-17">–ü–æ–¥–≤–µ–¥—ë–º –∏—Ç–æ–≥–∏</a></h2>
<p>No matter whether or not you think Rust is an object-oriented language after reading this chapter, you now know that you can use trait objects to get some object-oriented features in Rust. Dynamic dispatch can give your code some flexibility in exchange for a bit of runtime performance. You can use this flexibility to implement object-oriented patterns that can help your code‚Äôs maintainability. Rust also has other features, like ownership, that object-oriented languages don‚Äôt have. An object-oriented pattern won‚Äôt always be the best way to take advantage of Rust‚Äôs strengths, but is an available option.</p>
<p>Next, we‚Äôll look at patterns, which are another of Rust‚Äôs features that enable lots of flexibility. We‚Äôve looked at them briefly throughout the book but haven‚Äôt seen their full capability yet. Let‚Äôs go!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="–®–∞–±–ª–æ–Ω—ã-–∏-—Å–æ—Å–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ-—Å-—à–∞–±–ª–æ–Ω–æ–º"><a class="header" href="#–®–∞–±–ª–æ–Ω—ã-–∏-—Å–æ—Å–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ-—Å-—à–∞–±–ª–æ–Ω–æ–º">–®–∞–±–ª–æ–Ω—ã –∏ —Å–æ—Å–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ —Å —à–∞–±–ª–æ–Ω–æ–º</a></h1>
<p><em>Patterns</em> are a special syntax in Rust for matching against the structure of types, both complex and simple. Using patterns in conjunction with <code>match</code> expressions and other constructs gives you more control over a program‚Äôs control flow. A pattern consists of some combination of the following:</p>
<ul>
<li>Literals</li>
<li>Destructured arrays, enums, structs, or tuples</li>
<li>Variables</li>
<li>Wildcards</li>
<li>Placeholders</li>
</ul>
<p>Some example patterns include <code>x</code>, <code>(a, 3)</code>, and <code>Some(Color::Red)</code>. In the contexts in which patterns are valid, these components describe the shape of data. Our program then matches values against the patterns to determine whether it has the correct shape of data to continue running a particular piece of code.</p>
<p>To use a pattern, we compare it to some value. If the pattern matches the value, we use the value parts in our code. Recall the <code>match</code> expressions in Chapter 6 that used patterns, such as the coin-sorting machine example. If the value fits the shape of the pattern, we can use the named pieces. If it doesn‚Äôt, the code associated with the pattern won‚Äôt run.</p>
<p>This chapter is a reference on all things related to patterns. We‚Äôll cover the valid places to use patterns, the difference between refutable and irrefutable patterns, and the different kinds of pattern syntax that you might see. By the end of the chapter, you‚Äôll know how to use patterns to express many concepts in a clear way.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–ì–¥–µ-–ø—Ä–∏–º–µ–Ω–∏–º–æ-—Å–æ—Å–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ-—Å-—à–∞–±–ª–æ–Ω–æ–º"><a class="header" href="#–ì–¥–µ-–ø—Ä–∏–º–µ–Ω–∏–º–æ-—Å–æ—Å–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ-—Å-—à–∞–±–ª–æ–Ω–æ–º">–ì–¥–µ –ø—Ä–∏–º–µ–Ω–∏–º–æ —Å–æ—Å–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ —Å —à–∞–±–ª–æ–Ω–æ–º</a></h2>
<p>Patterns pop up in a number of places in Rust, and you‚Äôve been using them a lot without realizing it! This section discusses all the places where patterns are valid.</p>
<h3 id="match-arms"><a class="header" href="#match-arms"><code>match</code> Arms</a></h3>
<p>As discussed in Chapter 6, we use patterns in the arms of <code>match</code> expressions. Formally, <code>match</code> expressions are defined as the keyword <code>match</code>, a value to match on, and one or more match arms that consist of a pattern and an expression to run if the value matches that arm‚Äôs pattern, like this:</p>
<pre><code class="language-text">match VALUE {
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
}
</code></pre>
<p>For example, here's the <code>match</code> expression from Listing 6-5 that matches on an <code>Option&lt;i32&gt;</code> value in the variable <code>x</code>:</p>
<pre><code class="language-rust ignore">match x {
    None =&gt; None,
    Some(i) =&gt; Some(i + 1),
}</code></pre>
<p>The patterns in this <code>match</code> expression are the <code>None</code> and <code>Some(i)</code> on the left of each arrow.</p>
<p>One requirement for <code>match</code> expressions is that they need to be <em>exhaustive</em> in the sense that all possibilities for the value in the <code>match</code> expression must be accounted for. One way to ensure you‚Äôve covered every possibility is to have a catch-all pattern for the last arm: for example, a variable name matching any value can never fail and thus covers every remaining case.</p>
<p>The particular pattern <code>_</code> will match anything, but it never binds to a variable, so it‚Äôs often used in the last match arm. The <code>_</code> pattern can be useful when you want to ignore any value not specified, for example. We‚Äôll cover the <code>_</code> pattern in more detail in the <a href="ch19-03-pattern-syntax.html#ignoring-values-in-a-pattern">‚ÄúIgnoring Values in a Pattern‚Äù</a><!-- ignore --> section later in this chapter.</p>
<h3 id="conditional-if-let-expressions"><a class="header" href="#conditional-if-let-expressions">Conditional <code>if let</code> Expressions</a></h3>
<p>In Chapter 6 we discussed how to use <code>if let</code> expressions mainly as a shorter way to write the equivalent of a <code>match</code> that only matches one case. Optionally, <code>if let</code> can have a corresponding <code>else</code> containing code to run if the pattern in the <code>if let</code> doesn‚Äôt match.</p>
<p>Listing 19-1 shows that it‚Äôs also possible to mix and match <code>if let</code>, <code>else if</code>, and <code>else if let</code> expressions. Doing so gives us more flexibility than a <code>match</code> expression in which we can express only one value to compare with the patterns. Also, Rust doesn't require that the conditions in a series of <code>if let</code>, <code>else if</code>, <code>else if let</code> arms relate to each other.</p>
<p>The code in Listing 19-1 determines what color to make your background based on a series of checks for several conditions. For this example, we‚Äôve created variables with hardcoded values that a real program might receive from user input.</p>
<Listing number="19-1" file-name="src/main.rs" caption="Mixing `if let`, `else if`, `else if let`, and `else`">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let favorite_color: Option&lt;&amp;str&gt; = None;
    let is_tuesday = false;
    let age: Result&lt;u8, _&gt; = "34".parse();

    if let Some(color) = favorite_color {
        println!("Using your favorite color, {color}, as the background");
    } else if is_tuesday {
        println!("Tuesday is green day!");
    } else if let Ok(age) = age {
        if age &gt; 30 {
            println!("Using purple as the background color");
        } else {
            println!("Using orange as the background color");
        }
    } else {
        println!("Using blue as the background color");
    }
}</code></pre></pre>
</Listing>
<p>If the user specifies a favorite color, that color is used as the background. If no favorite color is specified and today is Tuesday, the background color is green. Otherwise, if the user specifies their age as a string and we can parse it as a number successfully, the color is either purple or orange depending on the value of the number. If none of these conditions apply, the background color is blue.</p>
<p>This conditional structure lets us support complex requirements. With the hardcoded values we have here, this example will print <code>Using purple as the background color</code>.</p>
<p>You can see that <code>if let</code> can also introduce new variables which shadow existing variables in the same way that <code>match</code> arms can: the line <code>if let Ok(age) = age</code> introduces a new <code>age</code> variable that contains the value inside the <code>Ok</code> variant, shadowing the existing <code>age</code> variable. This means we need to place the <code>if age &gt; 30</code> condition within that block: we can‚Äôt combine these two conditions into <code>if let Ok(age) = age &amp;&amp; age &gt; 30</code>. The new <code>age</code> we want to compare to 30 isn‚Äôt valid until the new scope starts with the curly bracket.</p>
<p>The downside of using <code>if let</code> expressions is that the compiler doesn‚Äôt check for exhaustiveness, whereas with <code>match</code> expressions it does. If we omitted the last <code>else</code> block and therefore missed handling some cases, the compiler would not alert us to the possible logic bug.</p>
<h3 id="while-let-conditional-loops"><a class="header" href="#while-let-conditional-loops"><code>while let</code> Conditional Loops</a></h3>
<p>Similar in construction to <code>if let</code>, the <code>while let</code> conditional loop allows a <code>while</code> loop to run for as long as a pattern continues to match. We first saw a <code>while let</code> loop in Chapter 17, where we used it to keep looping as long as a stream produced new values. Similarly, in Listing 19-2 we show a <code>while let</code> loop that waits on messages sent between threads, but in this case checking a <code>Result</code> instead of an <code>Option</code>.</p>
<Listing number="19-2" caption="Using a `while let` loop to print values for as long as `rx.recv()` returns `Ok`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let (tx, rx) = std::sync::mpsc::channel();
    std::thread::spawn(move || {
        for val in [1, 2, 3] {
            tx.send(val).unwrap();
        }
    });

    while let Ok(value) = rx.recv() {
        println!("{value}");
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>This example prints 1, 2, and 3. When we saw <code>recv</code> back in Chapter 16, we unwrapped the error directly, or interacted with it as an iterator using a <code>for</code> loop. As Listing 19-2 shows, though, we can also use <code>while let</code>, because the <code>recv</code> method returns <code>Ok</code> as long as the sender is producing messages, and then produces an <code>Err</code> once the sender side disconnects.</p>
<h3 id="for-loops"><a class="header" href="#for-loops"><code>for</code> Loops</a></h3>
<p>In a <code>for</code> loop, the value that directly follows the keyword <code>for</code> is a pattern. For example, in <code>for x in y</code> the <code>x</code> is the pattern. Listing 19-3 demonstrates how to use a pattern in a <code>for</code> loop to destructure, or break apart, a tuple as part of the <code>for</code> loop.</p>
<Listing number="19-3" caption="Using a pattern in a `for` loop to destructure a tuple">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let v = vec!['a', 'b', 'c'];

    for (index, value) in v.iter().enumerate() {
        println!("{value} is at index {index}");
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>The code in Listing 19-3 will print the following:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.52s
     Running `target/debug/patterns`
a is at index 0
b is at index 1
c is at index 2
</code></pre>
<p>We adapt an iterator using the <code>enumerate</code> method so it produces a value and the index for that value, placed into a tuple. The first value produced is the tuple <code>(0, 'a')</code>. When this value is matched to the pattern <code>(index, value)</code>, <code>index</code> will be <code>0</code> and <code>value</code> will be <code>'a'</code>, printing the first line of the output.</p>
<h3 id="let-statements"><a class="header" href="#let-statements"><code>let</code> Statements</a></h3>
<p>Prior to this chapter, we had only explicitly discussed using patterns with <code>match</code> and <code>if let</code>, but in fact, we‚Äôve used patterns in other places as well, including in <code>let</code> statements. For example, consider this straightforward variable assignment with <code>let</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}</span></code></pre></pre>
<p>Every time you've used a <code>let</code> statement like this you've been using patterns, although you might not have realized it! More formally, a <code>let</code> statement looks like this:</p>
<pre><code class="language-text">let PATTERN = EXPRESSION;
</code></pre>
<p>In statements like <code>let x = 5;</code> with a variable name in the <code>PATTERN</code> slot, the variable name is just a particularly simple form of a pattern. Rust compares the expression against the pattern and assigns any names it finds. So in the <code>let x = 5;</code> example, <code>x</code> is a pattern that means ‚Äúbind what matches here to the variable <code>x</code>.‚Äù Because the name <code>x</code> is the whole pattern, this pattern effectively means ‚Äúbind everything to the variable <code>x</code>, whatever the value is.‚Äù</p>
<p>To see the pattern matching aspect of <code>let</code> more clearly, consider Listing 19-4, which uses a pattern with <code>let</code> to destructure a tuple.</p>
<Listing number="19-4" caption="Using a pattern to destructure a tuple and create three variables at once">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let (x, y, z) = (1, 2, 3);
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>Here, we match a tuple against a pattern. Rust compares the value <code>(1, 2, 3)</code> to the pattern <code>(x, y, z)</code> and sees that the value matches the pattern, so Rust binds <code>1</code> to <code>x</code>, <code>2</code> to <code>y</code>, and <code>3</code> to <code>z</code>. You can think of this tuple pattern as nesting three individual variable patterns inside it.</p>
<p>If the number of elements in the pattern doesn‚Äôt match the number of elements in the tuple, the overall type won‚Äôt match and we‚Äôll get a compiler error. For example, Listing 19-5 shows an attempt to destructure a tuple with three elements into two variables, which won‚Äôt work.</p>
<Listing number="19-5" caption="Incorrectly constructing a pattern whose variables don‚Äôt match the number of elements in the tuple">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let (x, y) = (1, 2, 3);
<span class="boring">}</span></code></pre>
</Listing>
<p>Attempting to compile this code results in this type error:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0308]: mismatched types
 --&gt; src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^   --------- this expression has type `({integer}, {integer}, {integer})`
  |         |
  |         expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected tuple `({integer}, {integer}, {integer})`
             found tuple `(_, _)`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `patterns` (bin "patterns") due to 1 previous error
</code></pre>
<p>To fix the error, we could ignore one or more of the values in the tuple using <code>_</code> or <code>..</code>, as you‚Äôll see in the <a href="ch19-03-pattern-syntax.html#ignoring-values-in-a-pattern">‚ÄúIgnoring Values in a Pattern‚Äù</a><!-- ignore --> section. If the problem is that we have too many variables in the pattern, the solution is to make the types match by removing variables so the number of variables equals the number of elements in the tuple.</p>
<h3 id="function-parameters"><a class="header" href="#function-parameters">Function Parameters</a></h3>
<p>Function parameters can also be patterns. The code in Listing 19-6, which declares a function named <code>foo</code> that takes one parameter named <code>x</code> of type <code>i32</code>, should by now look familiar.</p>
<Listing number="19-6" caption="A function signature uses patterns in the parameters">
<pre><pre class="playground"><code class="language-rust edition2021">fn foo(x: i32) {
    // code goes here
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p>The <code>x</code> part is a pattern! As we did with <code>let</code>, we could match a tuple in a function‚Äôs arguments to the pattern. Listing 19-7 splits the values in a tuple as we pass it to a function.</p>
<Listing number="19-7" file-name="src/main.rs" caption="A function with parameters that destructure a tuple">
<pre><pre class="playground"><code class="language-rust edition2021">fn print_coordinates(&amp;(x, y): &amp;(i32, i32)) {
    println!("Current location: ({x}, {y})");
}

fn main() {
    let point = (3, 5);
    print_coordinates(&amp;point);
}</code></pre></pre>
</Listing>
<p>This code prints <code>Current location: (3, 5)</code>. The values <code>&amp;(3, 5)</code> match the pattern <code>&amp;(x, y)</code>, so <code>x</code> is the value <code>3</code> and <code>y</code> is the value <code>5</code>.</p>
<p>We can also use patterns in closure parameter lists in the same way as in function parameter lists, because closures are similar to functions, as discussed in Chapter 13.</p>
<p>At this point, you‚Äôve seen several ways of using patterns, but patterns don‚Äôt work the same in every place we can use them. In some places, the patterns must be irrefutable; in other circumstances, they can be refutable. We‚Äôll discuss these two concepts next.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–û–ø—Ä–æ–≤–µ—Ä–∂–∏–º–æ—Å—Ç—å-–º–æ–∂–µ—Ç-–ª–∏-—à–∞–±–ª–æ–Ω-–Ω–µ-—Å–æ–ø–æ—Å—Ç–∞–≤–∏—Ç—å—Å—è"><a class="header" href="#–û–ø—Ä–æ–≤–µ—Ä–∂–∏–º–æ—Å—Ç—å-–º–æ–∂–µ—Ç-–ª–∏-—à–∞–±–ª–æ–Ω-–Ω–µ-—Å–æ–ø–æ—Å—Ç–∞–≤–∏—Ç—å—Å—è">–û–ø—Ä–æ–≤–µ—Ä–∂–∏–º–æ—Å—Ç—å: –º–æ–∂–µ—Ç –ª–∏ —à–∞–±–ª–æ–Ω –Ω–µ —Å–æ–ø–æ—Å—Ç–∞–≤–∏—Ç—å—Å—è</a></h2>
<p>Patterns come in two forms: refutable and irrefutable. Patterns that will match for any possible value passed are <em>irrefutable</em>. An example would be <code>x</code> in the statement <code>let x = 5;</code> because <code>x</code> matches anything and therefore cannot fail to match. Patterns that can fail to match for some possible value are <em>refutable</em>. An example would be <code>Some(x)</code> in the expression <code>if let Some(x) = a_value</code> because if the value in the <code>a_value</code> variable is <code>None</code> rather than <code>Some</code>, the <code>Some(x)</code> pattern will not match.</p>
<p>Function parameters, <code>let</code> statements, and <code>for</code> loops can only accept irrefutable patterns, because the program cannot do anything meaningful when values don‚Äôt match. The <code>if let</code> and <code>while let</code> expressions and the <code>let</code>-<code>else</code> statement accept refutable and irrefutable patterns, but the compiler warns against irrefutable patterns because by definition they‚Äôre intended to handle possible failure: the functionality of a conditional is in its ability to perform differently depending on success or failure.</p>
<p>In general, you shouldn‚Äôt have to worry about the distinction between refutable and irrefutable patterns; however, you do need to be familiar with the concept of refutability so you can respond when you see it in an error message. In those cases, you‚Äôll need to change either the pattern or the construct you‚Äôre using the pattern with, depending on the intended behavior of the code.</p>
<p>Let‚Äôs look at an example of what happens when we try to use a refutable pattern where Rust requires an irrefutable pattern and vice versa. Listing 19-8 shows a <code>let</code> statement, but for the pattern we‚Äôve specified <code>Some(x)</code>, a refutable pattern. As you might expect, this code will not compile.</p>
<Listing number="19-8" caption="Attempting to use a refutable pattern with `let`">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let some_option_value: Option&lt;i32&gt; = None;
</span>    let Some(x) = some_option_value;
<span class="boring">}</span></code></pre>
</Listing>
<p>If <code>some_option_value</code> was a <code>None</code> value, it would fail to match the pattern <code>Some(x)</code>, meaning the pattern is refutable. However, the <code>let</code> statement can only accept an irrefutable pattern because there is nothing valid the code can do with a <code>None</code> value. At compile time, Rust will complain that we‚Äôve tried to use a refutable pattern where an irrefutable pattern is required:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0005]: refutable pattern in local binding
 --&gt; src/main.rs:3:9
  |
3 |     let Some(x) = some_option_value;
  |         ^^^^^^^ pattern `None` not covered
  |
  = note: `let` bindings require an "irrefutable pattern", like a `struct` or an `enum` with only one variant
  = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html
  = note: the matched value is of type `Option&lt;i32&gt;`
help: you might want to use `let else` to handle the variant that isn't matched
  |
3 |     let Some(x) = some_option_value else { todo!() };
  |                                     ++++++++++++++++

For more information about this error, try `rustc --explain E0005`.
error: could not compile `patterns` (bin "patterns") due to 1 previous error
</code></pre>
<p>Because we didn‚Äôt cover (and couldn‚Äôt cover!) every valid value with the pattern <code>Some(x)</code>, Rust rightfully produces a compiler error.</p>
<p>If we have a refutable pattern where an irrefutable pattern is needed, we can fix it by changing the code that uses the pattern: instead of using <code>let</code>, we can use <code>if let</code>. Then if the pattern doesn‚Äôt match, the code will just skip the code in the curly brackets, giving it a way to continue validly. Listing 19-9 shows how to fix the code in Listing 19-8.</p>
<Listing number="19-9" caption="Using `if let` and a block with refutable patterns instead of `let`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    let some_option_value: Option&lt;i32&gt; = None;
</span>    if let Some(x) = some_option_value {
        println!("{x}");
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>We‚Äôve given the code an out! This code is perfectly valid now. However, if we give <code>if let</code> an irrefutable pattern (a pattern that will always match), such as <code>x</code>, as shown in Listing 19-10, the compiler will give a warning.</p>
<Listing number="19-10" caption="Attempting to use an irrefutable pattern with `if let`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    if let x = 5 {
        println!("{x}");
    };
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>Rust complains that it doesn‚Äôt make sense to use <code>if let</code> with an irrefutable pattern:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
warning: irrefutable `if let` pattern
 --&gt; src/main.rs:2:8
  |
2 |     if let x = 5 {
  |        ^^^^^^^^^
  |
  = note: this pattern will always match, so the `if let` is useless
  = help: consider replacing the `if let` with a `let`
  = note: `#[warn(irrefutable_let_patterns)]` on by default

warning: `patterns` (bin "patterns") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.39s
     Running `target/debug/patterns`
5
</code></pre>
<p>For this reason, match arms must use refutable patterns, except for the last arm, which should match any remaining values with an irrefutable pattern. Rust allows us to use an irrefutable pattern in a <code>match</code> with only one arm, but this syntax isn‚Äôt particularly useful and could be replaced with a simpler <code>let</code> statement.</p>
<p>Now that you know where to use patterns and the difference between refutable and irrefutable patterns, let‚Äôs cover all the syntax we can use to create patterns.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–°–∏–Ω—Ç–∞–∫—Å–∏—Å-—à–∞–±–ª–æ–Ω–æ–≤"><a class="header" href="#–°–∏–Ω—Ç–∞–∫—Å–∏—Å-—à–∞–±–ª–æ–Ω–æ–≤">–°–∏–Ω—Ç–∞–∫—Å–∏—Å —à–∞–±–ª–æ–Ω–æ–≤</a></h2>
<p>In this section, we gather all the syntax valid in patterns and discuss why and when you might want to use each one.</p>
<h3 id="matching-literals"><a class="header" href="#matching-literals">Matching Literals</a></h3>
<p>As you saw in Chapter 6, you can match patterns against literals directly. The following code gives some examples:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 =&gt; println!("one"),
        2 =&gt; println!("two"),
        3 =&gt; println!("three"),
        _ =&gt; println!("anything"),
    }
<span class="boring">}</span></code></pre></pre>
<p>This code prints <code>one</code> because the value in <code>x</code> is 1. This syntax is useful when you want your code to take an action if it gets a particular concrete value.</p>
<h3 id="matching-named-variables"><a class="header" href="#matching-named-variables">Matching Named Variables</a></h3>
<p>Named variables are irrefutable patterns that match any value, and we‚Äôve used them many times in the book. However, there is a complication when you use named variables in <code>match</code>, <code>if let</code>, or <code>while let</code> expressions. Because each of these kinds of expression starts a new scope, variables declared as part of a pattern inside the expression will shadow those with the same name outside, as is the case with all variables. In Listing 19-11, we declare a variable named <code>x</code> with the value <code>Some(5)</code> and a variable <code>y</code> with the value <code>10</code>. We then create a <code>match</code> expression on the value <code>x</code>. Look at the patterns in the match arms and <code>println!</code> at the end, and try to figure out what the code will print before running this code or reading further.</p>
<Listing number="19-11" file-name="src/main.rs" caption="A `match` expression with an arm that introduces a new variable which shadows an existing variable `y`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!("Got 50"),
        Some(y) =&gt; println!("Matched, y = {y}"),
        _ =&gt; println!("Default case, x = {x:?}"),
    }

    println!("at the end: x = {x:?}, y = {y}");
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>Let‚Äôs walk through what happens when the <code>match</code> expression runs. The pattern in the first match arm doesn‚Äôt match the defined value of <code>x</code>, so the code continues.</p>
<p>The pattern in the second match arm introduces a new variable named <code>y</code> that will match any value inside a <code>Some</code> value. Because we‚Äôre in a new scope inside the <code>match</code> expression, this is a new <code>y</code> variable, not the <code>y</code> we declared at the beginning with the value 10. This new <code>y</code> binding will match any value inside a <code>Some</code>, which is what we have in <code>x</code>. Therefore, this new <code>y</code> binds to the inner value of the <code>Some</code> in <code>x</code>. That value is <code>5</code>, so the expression for that arm executes and prints <code>Matched, y = 5</code>.</p>
<p>If <code>x</code> had been a <code>None</code> value instead of <code>Some(5)</code>, the patterns in the first two arms wouldn‚Äôt have matched, so the value would have matched to the underscore. We didn‚Äôt introduce the <code>x</code> variable in the pattern of the underscore arm, so the <code>x</code> in the expression is still the outer <code>x</code> that hasn‚Äôt been shadowed. In this hypothetical case, the <code>match</code> would print <code>Default case, x = None</code>.</p>
<p>When the <code>match</code> expression is done, its scope ends, and so does the scope of the inner <code>y</code>. The last <code>println!</code> produces <code>at the end: x = Some(5), y = 10</code>.</p>
<p>To create a <code>match</code> expression that compares the values of the outer <code>x</code> and <code>y</code>, rather than introducing a new variable which shadows the existing <code>y</code> variable, we would need to use a match guard conditional instead. We‚Äôll talk about match guards later in the <a href="ch19-03-pattern-syntax.html#extra-conditionals-with-match-guards">‚ÄúExtra Conditionals with Match Guards‚Äù</a><!-- ignore --> section.</p>
<h3 id="multiple-patterns"><a class="header" href="#multiple-patterns">Multiple Patterns</a></h3>
<p>You can match multiple patterns using the <code>|</code> syntax, which is the pattern <em>or</em> operator. For example, in the following code we match the value of <code>x</code> against the match arms, the first of which has an <em>or</em> option, meaning if the value of <code>x</code> matches either of the values in that arm, that arm‚Äôs code will run:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 | 2 =&gt; println!("one or two"),
        3 =&gt; println!("three"),
        _ =&gt; println!("anything"),
    }
<span class="boring">}</span></code></pre></pre>
<p>This code prints <code>one or two</code>.</p>
<h3 id="matching-ranges-of-values-with-"><a class="header" href="#matching-ranges-of-values-with-">Matching Ranges of Values with <code>..=</code></a></h3>
<p>The <code>..=</code> syntax allows us to match to an inclusive range of values. In the following code, when a pattern matches any of the values within the given range, that arm will execute:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 5;

    match x {
        1..=5 =&gt; println!("one through five"),
        _ =&gt; println!("something else"),
    }
<span class="boring">}</span></code></pre></pre>
<p>If <code>x</code> is 1, 2, 3, 4, or 5, the first arm will match. This syntax is more convenient for multiple match values than using the <code>|</code> operator to express the same idea; if we were to use <code>|</code> we would have to specify <code>1 | 2 | 3 | 4 | 5</code>. Specifying a range is much shorter, especially if we want to match, say, any number between 1 and 1,000!</p>
<p>The compiler checks that the range isn‚Äôt empty at compile time, and because the only types for which Rust can tell if a range is empty or not are <code>char</code> and numeric values, ranges are only allowed with numeric or <code>char</code> values.</p>
<p>Here is an example using ranges of <code>char</code> values:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 'c';

    match x {
        'a'..='j' =&gt; println!("early ASCII letter"),
        'k'..='z' =&gt; println!("late ASCII letter"),
        _ =&gt; println!("something else"),
    }
<span class="boring">}</span></code></pre></pre>
<p>Rust can tell that <code>'c'</code> is within the first pattern‚Äôs range and prints <code>early ASCII letter</code>.</p>
<h3 id="destructuring-to-break-apart-values"><a class="header" href="#destructuring-to-break-apart-values">Destructuring to Break Apart Values</a></h3>
<p>We can also use patterns to destructure structs, enums, and tuples to use different parts of these values. Let‚Äôs walk through each value.</p>
<h4 id="destructuring-structs"><a class="header" href="#destructuring-structs">Destructuring Structs</a></h4>
<p>Listing 19-12 shows a <code>Point</code> struct with two fields, <code>x</code> and <code>y</code>, that we can break apart using a pattern with a <code>let</code> statement.</p>
<Listing number="19-12" file-name="src/main.rs" caption="Destructuring a struct‚Äôs fields into separate variables">
<pre><pre class="playground"><code class="language-rust edition2021">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}</code></pre></pre>
</Listing>
<p>This code creates the variables <code>a</code> and <code>b</code> that match the values of the <code>x</code> and <code>y</code> fields of the <code>p</code> struct. This example shows that the names of the variables in the pattern don‚Äôt have to match the field names of the struct. However, it‚Äôs common to match the variable names to the field names to make it easier to remember which variables came from which fields. Because of this common usage, and because writing <code>let Point { x: x, y: y } = p;</code> contains a lot of duplication, Rust has a shorthand for patterns that match struct fields: you only need to list the name of the struct field, and the variables created from the pattern will have the same names. Listing 19-13 behaves in the same way as the code in Listing 19-12, but the variables created in the <code>let</code> pattern are <code>x</code> and <code>y</code> instead of <code>a</code> and <code>b</code>.</p>
<Listing number="19-13" file-name="src/main.rs" caption="Destructuring struct fields using struct field shorthand">
<pre><pre class="playground"><code class="language-rust edition2021">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}</code></pre></pre>
</Listing>
<p>This code creates the variables <code>x</code> and <code>y</code> that match the <code>x</code> and <code>y</code> fields of the <code>p</code> variable. The outcome is that the variables <code>x</code> and <code>y</code> contain the values from the <code>p</code> struct.</p>
<p>We can also destructure with literal values as part of the struct pattern rather than creating variables for all the fields. Doing so allows us to test some of the fields for particular values while creating variables to destructure the other fields.</p>
<p>In Listing 19-14, we have a <code>match</code> expression that separates <code>Point</code> values into three cases: points that lie directly on the <code>x</code> axis (which is true when <code>y = 0</code>), on the <code>y</code> axis (<code>x = 0</code>), or neither.</p>
<Listing number="19-14" file-name="src/main.rs" caption="Destructuring and matching literal values in one pattern">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!("On the x axis at {x}"),
        Point { x: 0, y } =&gt; println!("On the y axis at {y}"),
        Point { x, y } =&gt; {
            println!("On neither axis: ({x}, {y})");
        }
    }
}</code></pre></pre>
</Listing>
<p>The first arm will match any point that lies on the <code>x</code> axis by specifying that the <code>y</code> field matches if its value matches the literal <code>0</code>. The pattern still creates an <code>x</code> variable that we can use in the code for this arm.</p>
<p>Similarly, the second arm matches any point on the <code>y</code> axis by specifying that the <code>x</code> field matches if its value is <code>0</code> and creates a variable <code>y</code> for the value of the <code>y</code> field. The third arm doesn‚Äôt specify any literals, so it matches any other <code>Point</code> and creates variables for both the <code>x</code> and <code>y</code> fields.</p>
<p>In this example, the value <code>p</code> matches the second arm by virtue of <code>x</code> containing a 0, so this code will print <code>On the y axis at 7</code>.</p>
<p>Remember that a <code>match</code> expression stops checking arms once it has found the first matching pattern, so even though <code>Point { x: 0, y: 0}</code> is on the <code>x</code> axis and the <code>y</code> axis, this code would only print <code>On the x axis at 0</code>.</p>
<h4 id="destructuring-enums"><a class="header" href="#destructuring-enums">Destructuring Enums</a></h4>
<p>We've destructured enums in this book (for example, Listing 6-5 in Chapter 6), but haven‚Äôt yet explicitly discussed that the pattern to destructure an enum corresponds to the way the data stored within the enum is defined. As an example, in Listing 19-15 we use the <code>Message</code> enum from Listing 6-2 and write a <code>match</code> with patterns that will destructure each inner value.</p>
<Listing number="19-15" file-name="src/main.rs" caption="Destructuring enum variants that hold different kinds of values">
<pre><pre class="playground"><code class="language-rust edition2021">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            println!("The Quit variant has no data to destructure.");
        }
        Message::Move { x, y } =&gt; {
            println!("Move in the x direction {x} and in the y direction {y}");
        }
        Message::Write(text) =&gt; {
            println!("Text message: {text}");
        }
        Message::ChangeColor(r, g, b) =&gt; {
            println!("Change the color to red {r}, green {g}, and blue {b}");
        }
    }
}</code></pre></pre>
</Listing>
<p>This code will print <code>Change the color to red 0, green 160, and blue 255</code>. Try changing the value of <code>msg</code> to see the code from the other arms run.</p>
<p>For enum variants without any data, like <code>Message::Quit</code>, we can‚Äôt destructure the value any further. We can only match on the literal <code>Message::Quit</code> value, and no variables are in that pattern.</p>
<p>For struct-like enum variants, such as <code>Message::Move</code>, we can use a pattern similar to the pattern we specify to match structs. After the variant name, we place curly brackets and then list the fields with variables so we break apart the pieces to use in the code for this arm. Here we use the shorthand form as we did in Listing 19-13.</p>
<p>For tuple-like enum variants, like <code>Message::Write</code> that holds a tuple with one element and <code>Message::ChangeColor</code> that holds a tuple with three elements, the pattern is similar to the pattern we specify to match tuples. The number of variables in the pattern must match the number of elements in the variant we‚Äôre matching.</p>
<h4 id="destructuring-nested-structs-and-enums"><a class="header" href="#destructuring-nested-structs-and-enums">Destructuring Nested Structs and Enums</a></h4>
<p>So far, our examples have all been matching structs or enums one level deep, but matching can work on nested items too! For example, we can refactor the code in Listing 19-15 to support RGB and HSV colors in the <code>ChangeColor</code> message, as shown in Listing 19-16.</p>
<Listing number="19-16" caption="Matching on nested enums">
<pre><pre class="playground"><code class="language-rust edition2021">enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; {
            println!("Change color to red {r}, green {g}, and blue {b}");
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; {
            println!("Change color to hue {h}, saturation {s}, value {v}");
        }
        _ =&gt; (),
    }
}</code></pre></pre>
</Listing>
<p>The pattern of the first arm in the <code>match</code> expression matches a <code>Message::ChangeColor</code> enum variant that contains a <code>Color::Rgb</code> variant; then the pattern binds to the three inner <code>i32</code> values. The pattern of the second arm also matches a <code>Message::ChangeColor</code> enum variant, but the inner enum matches <code>Color::Hsv</code> instead. We can specify these complex conditions in one <code>match</code> expression, even though two enums are involved.</p>
<h4 id="destructuring-structs-and-tuples"><a class="header" href="#destructuring-structs-and-tuples">Destructuring Structs and Tuples</a></h4>
<p>We can mix, match, and nest destructuring patterns in even more complex ways. The following example shows a complicated destructure where we nest structs and tuples inside a tuple and destructure all the primitive values out:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    struct Point {
</span><span class="boring">        x: i32,
</span><span class="boring">        y: i32,
</span><span class="boring">    }
</span><span class="boring">
</span>    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
<span class="boring">}</span></code></pre></pre>
<p>This code lets us break complex types into their component parts so we can use the values we‚Äôre interested in separately.</p>
<p>Destructuring with patterns is a convenient way to use pieces of values, such as the value from each field in a struct, separately from each other.</p>
<h3 id="ignoring-values-in-a-pattern"><a class="header" href="#ignoring-values-in-a-pattern">Ignoring Values in a Pattern</a></h3>
<p>You‚Äôve seen that it‚Äôs sometimes useful to ignore values in a pattern, such as in the last arm of a <code>match</code>, to get a catch-all that doesn‚Äôt actually do anything but does account for all remaining possible values. There are a few ways to ignore entire values or parts of values in a pattern: using the <code>_</code> pattern (which you‚Äôve seen), using the <code>_</code> pattern within another pattern, using a name that starts with an underscore, or using <code>..</code> to ignore remaining parts of a value. Let‚Äôs explore how and why to use each of these patterns.</p>
<h4 id="ignoring-an-entire-value-with-_"><a class="header" href="#ignoring-an-entire-value-with-_">Ignoring an Entire Value with <code>_</code></a></h4>
<p>We‚Äôve used the underscore as a wildcard pattern that will match any value but not bind to the value. This is especially useful as the last arm in a <code>match</code> expression, but we can also use it in any pattern, including function parameters, as shown in Listing 19-17.</p>
<Listing number="19-17" file-name="src/main.rs" caption="Using `_` in a function signature">
<pre><pre class="playground"><code class="language-rust edition2021">fn foo(_: i32, y: i32) {
    println!("This code only uses the y parameter: {y}");
}

fn main() {
    foo(3, 4);
}</code></pre></pre>
</Listing>
<p>This code will completely ignore the value <code>3</code> passed as the first argument, and will print <code>This code only uses the y parameter: 4</code>.</p>
<p>In most cases when you no longer need a particular function parameter, you would change the signature so it doesn‚Äôt include the unused parameter. Ignoring a function parameter can be especially useful in cases when, for example, you're implementing a trait when you need a certain type signature but the function body in your implementation doesn‚Äôt need one of the parameters. You then avoid getting a compiler warning about unused function parameters, as you would if you used a name instead.</p>
<h4 id="ignoring-parts-of-a-value-with-a-nested-_"><a class="header" href="#ignoring-parts-of-a-value-with-a-nested-_">Ignoring Parts of a Value with a Nested <code>_</code></a></h4>
<p>We can also use <code>_</code> inside another pattern to ignore just part of a value, for example, when we want to test for only part of a value but have no use for the other parts in the corresponding code we want to run. Listing 19-18 shows code responsible for managing a setting‚Äôs value. The business requirements are that the user should not be allowed to overwrite an existing customization of a setting but can unset the setting and give it a value if it is currently unset.</p>
<Listing number="19-18" caption=" Using an underscore within patterns that match `Some` variants when we don‚Äôt need to use the value inside the `Some`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut setting_value = Some(5);
    let new_setting_value = Some(10);

    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) =&gt; {
            println!("Can't overwrite an existing customized value");
        }
        _ =&gt; {
            setting_value = new_setting_value;
        }
    }

    println!("setting is {setting_value:?}");
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>This code will print <code>Can't overwrite an existing customized value</code> and then <code>setting is Some(5)</code>. In the first match arm, we don‚Äôt need to match on or use the values inside either <code>Some</code> variant, but we do need to test for the case when <code>setting_value</code> and <code>new_setting_value</code> are the <code>Some</code> variant. In that case, we print the reason for not changing <code>setting_value</code>, and it doesn‚Äôt get changed.</p>
<p>In all other cases (if either <code>setting_value</code> or <code>new_setting_value</code> are <code>None</code>) expressed by the <code>_</code> pattern in the second arm, we want to allow <code>new_setting_value</code> to become <code>setting_value</code>.</p>
<p>We can also use underscores in multiple places within one pattern to ignore particular values. Listing 19-19 shows an example of ignoring the second and fourth values in a tuple of five items.</p>
<Listing number="19-19" caption="Ignoring multiple parts of a tuple">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) =&gt; {
            println!("Some numbers: {first}, {third}, {fifth}")
        }
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>This code will print <code>Some numbers: 2, 8, 32</code>, and the values 4 and 16 will be ignored.</p>
<h4 id="ignoring-an-unused-variable-by-starting-its-name-with-_"><a class="header" href="#ignoring-an-unused-variable-by-starting-its-name-with-_">Ignoring an Unused Variable by Starting Its Name with <code>_</code></a></h4>
<p>If you create a variable but don‚Äôt use it anywhere, Rust will usually issue a warning because an unused variable could be a bug. However, sometimes it‚Äôs useful to be able to create a variable you won‚Äôt use yet, such as when you‚Äôre prototyping or just starting a project. In this situation, you can tell Rust not to warn you about the unused variable by starting the name of the variable with an underscore. In Listing 19-20, we create two unused variables, but when we compile this code, we should only get a warning about one of them.</p>
<Listing number="19-20" file-name="src/main.rs" caption="Starting a variable name with an underscore to avoid getting unused variable warnings">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let _x = 5;
    let y = 10;
}</code></pre></pre>
</Listing>
<p>Here we get a warning about not using the variable <code>y</code>, but we don‚Äôt get a warning about not using <code>_x</code>.</p>
<p>Note that there is a subtle difference between using only <code>_</code> and using a name that starts with an underscore. The syntax <code>_x</code> still binds the value to the variable, whereas <code>_</code> doesn‚Äôt bind at all. To show a case where this distinction matters, Listing 19-21 will provide us with an error.</p>
<Listing number="19-21" caption="An unused variable starting with an underscore still binds the value, which might take ownership of the value">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s = Some(String::from("Hello!"));

    if let Some(_s) = s {
        println!("found a string");
    }

    println!("{s:?}");
<span class="boring">}</span></code></pre>
</Listing>
<p>We‚Äôll receive an error because the <code>s</code> value will still be moved into <code>_s</code>, which prevents us from using <code>s</code> again. However, using the underscore by itself doesn‚Äôt ever bind to the value. Listing 19-22 will compile without any errors because <code>s</code> doesn‚Äôt get moved into <code>_</code>.</p>
<Listing number="19-22" caption="Using an underscore does not bind the value">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s = Some(String::from("Hello!"));

    if let Some(_) = s {
        println!("found a string");
    }

    println!("{s:?}");
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>This code works just fine because we never bind <code>s</code> to anything; it isn‚Äôt moved.</p>
<h4 id="ignoring-remaining-parts-of-a-value-with-"><a class="header" href="#ignoring-remaining-parts-of-a-value-with-">Ignoring Remaining Parts of a Value with <code>..</code></a></h4>
<p>With values that have many parts, we can use the <code>..</code> syntax to use specific parts and ignore the rest, avoiding the need to list underscores for each ignored value. The <code>..</code> pattern ignores any parts of a value that we haven‚Äôt explicitly matched in the rest of the pattern. In Listing 19-23, we have a <code>Point</code> struct that holds a coordinate in three-dimensional space. In the <code>match</code> expression, we want to operate only on the <code>x</code> coordinate and ignore the values in the <code>y</code> and <code>z</code> fields.</p>
<Listing number="19-23" caption="Ignoring all fields of a `Point` except for `x` by using `..`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } =&gt; println!("x is {x}"),
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>We list the <code>x</code> value and then just include the <code>..</code> pattern. This is quicker than having to list <code>y: _</code> and <code>z: _</code>, particularly when we‚Äôre working with structs that have lots of fields in situations where only one or two fields are relevant.</p>
<p>The syntax <code>..</code> will expand to as many values as it needs to be. Listing 19-24 shows how to use <code>..</code> with a tuple.</p>
<Listing number="19-24" file-name="src/main.rs" caption="Matching only the first and last values in a tuple and ignoring all other values">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!("Some numbers: {first}, {last}");
        }
    }
}</code></pre></pre>
</Listing>
<p>In this code, the first and last value are matched with <code>first</code> and <code>last</code>. The <code>..</code> will match and ignore everything in the middle.</p>
<p>However, using <code>..</code> must be unambiguous. If it is unclear which values are intended for matching and which should be ignored, Rust will give us an error. Listing 19-25 shows an example of using <code>..</code> ambiguously, so it will not compile.</p>
<Listing number="19-25" file-name="src/main.rs" caption="An attempt to use `..` in an ambiguous way">
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!("Some numbers: {second}")
        },
    }
}</code></pre>
</Listing>
<p>When we compile this example, we get this error:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error: `..` can only be used once per tuple pattern
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here

error: could not compile `patterns` (bin "patterns") due to 1 previous error
</code></pre>
<p>It‚Äôs impossible for Rust to determine how many values in the tuple to ignore before matching a value with <code>second</code> and then how many further values to ignore thereafter. This code could mean that we want to ignore <code>2</code>, bind <code>second</code> to <code>4</code>, and then ignore <code>8</code>, <code>16</code>, and <code>32</code>; or that we want to ignore <code>2</code> and <code>4</code>, bind <code>second</code> to <code>8</code>, and then ignore <code>16</code> and <code>32</code>; and so forth. The variable name <code>second</code> doesn‚Äôt mean anything special to Rust, so we get a compiler error because using <code>..</code> in two places like this is ambiguous.</p>
<h3 id="extra-conditionals-with-match-guards"><a class="header" href="#extra-conditionals-with-match-guards">Extra Conditionals with Match Guards</a></h3>
<p>A <em>match guard</em> is an additional <code>if</code> condition, specified after the pattern in a <code>match</code> arm, that must also match for that arm to be chosen. Match guards are useful for expressing more complex ideas than a pattern alone allows. They are only available in <code>match</code> expressions, not in <code>if let</code> or <code>while let</code> expressions.</p>
<p>The condition can use variables created in the pattern. Listing 19-26 shows a <code>match</code> where the first arm has the pattern <code>Some(x)</code> and also has a match guard of <code>if x % 2 == 0</code> (which will be true if the number is even).</p>
<Listing number="19-26" caption="Adding a match guard to a pattern">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let num = Some(4);

    match num {
        Some(x) if x % 2 == 0 =&gt; println!("The number {x} is even"),
        Some(x) =&gt; println!("The number {x} is odd"),
        None =&gt; (),
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>This example will print <code>The number 4 is even</code>. When <code>num</code> is compared to the pattern in the first arm, it matches, because <code>Some(4)</code> matches <code>Some(x)</code>. Then the match guard checks whether the remainder of dividing <code>x</code> by 2 is equal to 0, and because it is, the first arm is selected.</p>
<p>If <code>num</code> had been <code>Some(5)</code> instead, the match guard in the first arm would have been false because the remainder of 5 divided by 2 is 1, which is not equal to 0. Rust would then go to the second arm, which would match because the second arm doesn‚Äôt have a match guard and therefore matches any <code>Some</code> variant.</p>
<p>There is no way to express the <code>if x % 2 == 0</code> condition within a pattern, so the match guard gives us the ability to express this logic. The downside of this additional expressiveness is that the compiler doesn't try to check for exhaustiveness when match guard expressions are involved.</p>
<p>In Listing 19-11, we mentioned that we could use match guards to solve our pattern-shadowing problem. Recall that we created a new variable inside the pattern in the <code>match</code> expression instead of using the variable outside the <code>match</code>. That new variable meant we couldn‚Äôt test against the value of the outer variable. Listing 19-27 shows how we can use a match guard to fix this problem.</p>
<Listing number="19-27" file-name="src/main.rs" caption="Using a match guard to test for equality with an outer variable">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!("Got 50"),
        Some(n) if n == y =&gt; println!("Matched, n = {n}"),
        _ =&gt; println!("Default case, x = {x:?}"),
    }

    println!("at the end: x = {x:?}, y = {y}");
}</code></pre></pre>
</Listing>
<p>This code will now print <code>Default case, x = Some(5)</code>. The pattern in the second match arm doesn‚Äôt introduce a new variable <code>y</code> that would shadow the outer <code>y</code>, meaning we can use the outer <code>y</code> in the match guard. Instead of specifying the pattern as <code>Some(y)</code>, which would have shadowed the outer <code>y</code>, we specify <code>Some(n)</code>. This creates a new variable <code>n</code> that doesn‚Äôt shadow anything because there is no <code>n</code> variable outside the <code>match</code>.</p>
<p>The match guard <code>if n == y</code> is not a pattern and therefore doesn‚Äôt introduce new variables. This <code>y</code> <em>is</em> the outer <code>y</code> rather than a new <code>y</code> shadowing it, and we can look for a value that has the same value as the outer <code>y</code> by comparing <code>n</code> to <code>y</code>.</p>
<p>You can also use the <em>or</em> operator <code>|</code> in a match guard to specify multiple patterns; the match guard condition will apply to all the patterns. Listing 19-28 shows the precedence when combining a pattern that uses <code>|</code> with a match guard. The important part of this example is that the <code>if y</code> match guard applies to <code>4</code>, <code>5</code>, <em>and</em> <code>6</code>, even though it might look like <code>if y</code> only applies to <code>6</code>.</p>
<Listing number="19-28" caption="Combining multiple patterns with a match guard">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 4;
    let y = false;

    match x {
        4 | 5 | 6 if y =&gt; println!("yes"),
        _ =&gt; println!("no"),
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>The match condition states that the arm only matches if the value of <code>x</code> is equal to <code>4</code>, <code>5</code>, or <code>6</code> <em>and</em> if <code>y</code> is <code>true</code>. When this code runs, the pattern of the first arm matches because <code>x</code> is <code>4</code>, but the match guard <code>if y</code> is false, so the first arm is not chosen. The code moves on to the second arm, which does match, and this program prints <code>no</code>. The reason is that the <code>if</code> condition applies to the whole pattern <code>4 | 5 | 6</code>, not only to the last value <code>6</code>. In other words, the precedence of a match guard in relation to a pattern behaves like this:</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<p>rather than this:</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<p>After running the code, the precedence behavior is evident: if the match guard were applied only to the final value in the list of values specified using the <code>|</code> operator, the arm would have matched and the program would have printed <code>yes</code>.</p>
<h3 id="-bindings"><a class="header" href="#-bindings"><code>@</code> Bindings</a></h3>
<p>The <em>at</em> operator <code>@</code> lets us create a variable that holds a value at the same time as we‚Äôre testing that value for a pattern match. In Listing 19-29, we want to test that a <code>Message::Hello</code> <code>id</code> field is within the range <code>3..=7</code>. We also want to bind the value to the variable <code>id_variable</code> so we can use it in the code associated with the arm. We could name this variable <code>id</code>, the same as the field, but for this example we‚Äôll use a different name.</p>
<Listing number="19-29" caption="Using `@` to bind to a value in a pattern while also testing it">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } =&gt; println!("Found an id in range: {id_variable}"),
        Message::Hello { id: 10..=12 } =&gt; {
            println!("Found an id in another range")
        }
        Message::Hello { id } =&gt; println!("Found some other id: {id}"),
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>This example will print <code>Found an id in range: 5</code>. By specifying <code>id_variable @</code> before the range <code>3..=7</code>, we‚Äôre capturing whatever value matched the range while also testing that the value matched the range pattern.</p>
<p>In the second arm, where we only have a range specified in the pattern, the code associated with the arm doesn‚Äôt have a variable that contains the actual value of the <code>id</code> field. The <code>id</code> field‚Äôs value could have been 10, 11, or 12, but the code that goes with that pattern doesn‚Äôt know which it is. The pattern code isn‚Äôt able to use the value from the <code>id</code> field, because we haven‚Äôt saved the <code>id</code> value in a variable.</p>
<p>In the last arm, where we‚Äôve specified a variable without a range, we do have the value available to use in the arm‚Äôs code in a variable named <code>id</code>. The reason is that we‚Äôve used the struct field shorthand syntax. But we haven‚Äôt applied any test to the value in the <code>id</code> field in this arm, as we did with the first two arms: any value would match this pattern.</p>
<p>Using <code>@</code> lets us test a value and save it in a variable within one pattern.</p>
<h2 id="–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-18"><a class="header" href="#–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-18">–ü–æ–¥–≤–µ–¥—ë–º –∏—Ç–æ–≥–∏</a></h2>
<p>Rust‚Äôs patterns are very useful in distinguishing between different kinds of data. When used in <code>match</code> expressions, Rust ensures your patterns cover every possible value, or your program won‚Äôt compile. Patterns in <code>let</code> statements and function parameters make those constructs more useful, enabling the destructuring of values into smaller parts and assigning those parts to variables. We can create simple or complex patterns to suit our needs.</p>
<p>Next, for the penultimate chapter of the book, we‚Äôll look at some advanced aspects of a variety of Rust‚Äôs features.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="–ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ-–≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏"><a class="header" href="#–ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ-–≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏">–ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏</a></h1>
<p>By now, you‚Äôve learned the most commonly used parts of the Rust programming language. Before we do one more project in Chapter 21, we‚Äôll look at a few aspects of the language you might run into every once in a while, but may not use every day. You can use this chapter as a reference for when you encounter any unknowns. The features covered here are useful in very specific situations. Although you might not reach for them often, we want to make sure you have a grasp of all the features Rust has to offer.</p>
<p>In this chapter, we‚Äôll cover:</p>
<ul>
<li>Unsafe Rust: how to opt out of some of Rust‚Äôs guarantees and take responsibility for manually upholding those guarantees</li>
<li>Advanced traits: associated types, default type parameters, fully qualified syntax, supertraits, and the newtype pattern in relation to traits</li>
<li>Advanced types: more about the newtype pattern, type aliases, the never type, and dynamically sized types</li>
<li>Advanced functions and closures: function pointers and returning closures</li>
<li>Macros: ways to define code that defines more code at compile time</li>
</ul>
<p>It‚Äôs a panoply of Rust features with something for everyone! Let‚Äôs dive in!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–ù–µ–±–µ–∑–æ–ø–∞—Å–Ω—ã–π-rust"><a class="header" href="#–ù–µ–±–µ–∑–æ–ø–∞—Å–Ω—ã–π-rust">–ù–µ–±–µ–∑–æ–ø–∞—Å–Ω—ã–π Rust</a></h2>
<p>All the code we‚Äôve discussed so far has had Rust‚Äôs memory safety guarantees enforced at compile time. However, Rust has a second language hidden inside it that doesn‚Äôt enforce these memory safety guarantees: it‚Äôs called <em>unsafe Rust</em> and works just like regular Rust, but gives us extra superpowers.</p>
<p>Unsafe Rust exists because, by nature, static analysis is conservative. When the compiler tries to determine whether or not code upholds the guarantees, it‚Äôs better for it to reject some valid programs than to accept some invalid programs. Although the code <em>might</em> be okay, if the Rust compiler doesn‚Äôt have enough information to be confident, it will reject the code. In these cases, you can use unsafe code to tell the compiler, ‚ÄúTrust me, I know what I‚Äôm doing.‚Äù Be warned, however, that you use unsafe Rust at your own risk: if you use unsafe code incorrectly, problems can occur due to memory unsafety, such as null pointer dereferencing.</p>
<p>Another reason Rust has an unsafe alter ego is that the underlying computer hardware is inherently unsafe. If Rust didn‚Äôt let you do unsafe operations, you couldn‚Äôt do certain tasks. Rust needs to allow you to do low-level systems programming, such as directly interacting with the operating system or even writing your own operating system. Working with low-level systems programming is one of the goals of the language. Let‚Äôs explore what we can do with unsafe Rust and how to do it.</p>
<h3 id="unsafe-superpowers"><a class="header" href="#unsafe-superpowers">Unsafe Superpowers</a></h3>
<p>To switch to unsafe Rust, use the <code>unsafe</code> keyword and then start a new block that holds the unsafe code. You can take five actions in unsafe Rust that you can‚Äôt in safe Rust, which we call <em>unsafe superpowers</em>. Those superpowers include the ability to:</p>
<ul>
<li>Dereference a raw pointer</li>
<li>Call an unsafe function or method</li>
<li>Access or modify a mutable static variable</li>
<li>Implement an unsafe trait</li>
<li>Access fields of a <code>union</code></li>
</ul>
<p>It‚Äôs important to understand that <code>unsafe</code> doesn‚Äôt turn off the borrow checker or disable any other of Rust‚Äôs safety checks: if you use a reference in unsafe code, it will still be checked. The <code>unsafe</code> keyword only gives you access to these five features that are then not checked by the compiler for memory safety. You‚Äôll still get some degree of safety inside of an unsafe block.</p>
<p>In addition, <code>unsafe</code> does not mean the code inside the block is necessarily dangerous or that it will definitely have memory safety problems: the intent is that as the programmer, you‚Äôll ensure the code inside an <code>unsafe</code> block will access memory in a valid way.</p>
<p>People are fallible, and mistakes will happen, but by requiring these five unsafe operations to be inside blocks annotated with <code>unsafe</code> you‚Äôll know that any errors related to memory safety must be within an <code>unsafe</code> block. Keep <code>unsafe</code> blocks small; you‚Äôll be thankful later when you investigate memory bugs.</p>
<p>To isolate unsafe code as much as possible, it‚Äôs best to enclose unsafe code within a safe abstraction and provide a safe API, which we‚Äôll discuss later in the chapter when we examine unsafe functions and methods. Parts of the standard library are implemented as safe abstractions over unsafe code that has been audited. Wrapping unsafe code in a safe abstraction prevents uses of <code>unsafe</code> from leaking out into all the places that you or your users might want to use the functionality implemented with <code>unsafe</code> code, because using a safe abstraction is safe.</p>
<p>Let‚Äôs look at each of the five unsafe superpowers in turn. We‚Äôll also look at some abstractions that provide a safe interface to unsafe code.</p>
<h3 id="dereferencing-a-raw-pointer"><a class="header" href="#dereferencing-a-raw-pointer">Dereferencing a Raw Pointer</a></h3>
<p>In Chapter 4, in <a href="ch04-02-references-and-borrowing.html#dangling-references">‚ÄúDangling References‚Äù</a><!-- ignore -->, we mentioned that the compiler ensures references are always valid. Unsafe Rust has two new types called <em>raw pointers</em> that are similar to references. As with references, raw pointers can be immutable or mutable and are written as <code>*const T</code> and <code>*mut T</code>, respectively. The asterisk isn‚Äôt the dereference operator; it‚Äôs part of the type name. In the context of raw pointers, <em>immutable</em> means that the pointer can‚Äôt be directly assigned to after being dereferenced.</p>
<p>Different from references and smart pointers, raw pointers:</p>
<ul>
<li>Are allowed to ignore the borrowing rules by having both immutable and mutable pointers or multiple mutable pointers to the same location</li>
<li>Aren‚Äôt guaranteed to point to valid memory</li>
<li>Are allowed to be null</li>
<li>Don‚Äôt implement any automatic cleanup</li>
</ul>
<p>By opting out of having Rust enforce these guarantees, you can give up guaranteed safety in exchange for greater performance or the ability to interface with another language or hardware where Rust‚Äôs guarantees don‚Äôt apply.</p>
<p>Listing 20-1 shows how to create an immutable and a mutable raw pointer.</p>
<Listing number="20-1" caption="Creating raw pointers with the raw borrow operators">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;raw const num;
    let r2 = &amp;raw mut num;
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>Notice that we don‚Äôt include the <code>unsafe</code> keyword in this code. We can create raw pointers in safe code; we just can‚Äôt dereference raw pointers outside an unsafe block, as you‚Äôll see in a bit.</p>
<p>We‚Äôve created raw pointers by using the raw borrow operators: <code>&amp;raw const num</code> creates a <code>*const i32</code> immutable raw pointer, and <code>&amp;raw mut num</code> creates a <code>*mut i32</code> mutable raw pointer. Because we created them directly from a local variable, we know these particular raw pointers are valid, but we can‚Äôt make that assumption about just any raw pointer.</p>
<p>To demonstrate this, next we‚Äôll create a raw pointer whose validity we can‚Äôt be so certain of, using <code>as</code> to cast a value instead of using the raw reference operators. Listing 20-2 shows how to create a raw pointer to an arbitrary location in memory. Trying to use arbitrary memory is undefined: there might be data at that address or there might not, the compiler might optimize the code so there is no memory access, or the program might error with a segmentation fault. Usually, there is no good reason to write code like this, especially in cases where you can use a raw borrow operator instead, but it is possible.</p>
<Listing number="20-2" caption="Creating a raw pointer to an arbitrary memory address">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let address = 0x012345usize;
    let r = address as *const i32;
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>Recall that we can create raw pointers in safe code, but we can‚Äôt <em>dereference</em> raw pointers and read the data being pointed to. In Listing 20-3, we use the dereference operator <code>*</code> on a raw pointer that requires an <code>unsafe</code> block.</p>
<Listing number="20-3" caption="Dereferencing raw pointers within an `unsafe` block">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;raw const num;
    let r2 = &amp;raw mut num;

    unsafe {
        println!("r1 is: {}", *r1);
        println!("r2 is: {}", *r2);
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>Creating a pointer does no harm; it‚Äôs only when we try to access the value that it points at that we might end up dealing with an invalid value.</p>
<p>Note also that in Listing 20-1 and 20-3, we created <code>*const i32</code> and <code>*mut i32</code> raw pointers that both pointed to the same memory location, where <code>num</code> is stored. If we instead tried to create an immutable and a mutable reference to <code>num</code>, the code would not have compiled because Rust‚Äôs ownership rules don‚Äôt allow a mutable reference at the same time as any immutable references. With raw pointers, we can create a mutable pointer and an immutable pointer to the same location and change data through the mutable pointer, potentially creating a data race. Be careful!</p>
<p>With all of these dangers, why would you ever use raw pointers? One major use case is when interfacing with C code, as you‚Äôll see in the next section, <a href="ch20-01-unsafe-rust.html#calling-an-unsafe-function-or-method">‚ÄúCalling an Unsafe Function or Method.‚Äù</a><!-- ignore --> Another case is when building up safe abstractions that the borrow checker doesn‚Äôt understand. We‚Äôll introduce unsafe functions and then look at an example of a safe abstraction that uses unsafe code.</p>
<h3 id="calling-an-unsafe-function-or-method"><a class="header" href="#calling-an-unsafe-function-or-method">Calling an Unsafe Function or Method</a></h3>
<p>The second type of operation you can perform in an unsafe block is calling unsafe functions. Unsafe functions and methods look exactly like regular functions and methods, but they have an extra <code>unsafe</code> before the rest of the definition. The <code>unsafe</code> keyword in this context indicates the function has requirements we need to uphold when we call this function, because Rust can‚Äôt guarantee we‚Äôve met these requirements. By calling an unsafe function within an <code>unsafe</code> block, we‚Äôre saying that we‚Äôve read this function‚Äôs documentation and take responsibility for upholding the function‚Äôs contracts.</p>
<p>Here is an unsafe function named <code>dangerous</code> that doesn‚Äôt do anything in its body:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    unsafe fn dangerous() {}

    unsafe {
        dangerous();
    }
<span class="boring">}</span></code></pre></pre>
<p>We must call the <code>dangerous</code> function within a separate <code>unsafe</code> block. If we try to call <code>dangerous</code> without the <code>unsafe</code> block, we‚Äôll get an error:</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0133]: call to unsafe function `dangerous` is unsafe and requires unsafe function or block
 --&gt; src/main.rs:4:5
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
  |
  = note: consult the function's documentation for information on how to avoid undefined behavior

For more information about this error, try `rustc --explain E0133`.
error: could not compile `unsafe-example` (bin "unsafe-example") due to 1 previous error
</code></pre>
<p>With the <code>unsafe</code> block, we‚Äôre asserting to Rust that we‚Äôve read the function‚Äôs documentation, we understand how to use it properly, and we‚Äôve verified that we‚Äôre fulfilling the contract of the function.</p>
<p>To perform unsafe operations in the body of an unsafe function, you still need to use an <code>unsafe</code> block just as within a regular function, and the compiler will warn you if you forget. This helps to keep <code>unsafe</code> blocks as small as possible, as unsafe operations may not be needed across the whole function body.</p>
<h4 id="creating-a-safe-abstraction-over-unsafe-code"><a class="header" href="#creating-a-safe-abstraction-over-unsafe-code">Creating a Safe Abstraction over Unsafe Code</a></h4>
<p>Just because a function contains unsafe code doesn‚Äôt mean we need to mark the entire function as unsafe. In fact, wrapping unsafe code in a safe function is a common abstraction. As an example, let‚Äôs study the <code>split_at_mut</code> function from the standard library, which requires some unsafe code. We‚Äôll explore how we might implement it. This safe method is defined on mutable slices: it takes one slice and makes it two by splitting the slice at the index given as an argument. Listing 20-4 shows how to use <code>split_at_mut</code>.</p>
<Listing number="20-4" caption="Using the safe `split_at_mut` function">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5, 6];

    let r = &amp;mut v[..];

    let (a, b) = r.split_at_mut(3);

    assert_eq!(a, &amp;mut [1, 2, 3]);
    assert_eq!(b, &amp;mut [4, 5, 6]);
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>We can‚Äôt implement this function using only safe Rust. An attempt might look something like Listing 20-5, which won‚Äôt compile. For simplicity, we‚Äôll implement <code>split_at_mut</code> as a function rather than a method and only for slices of <code>i32</code> values rather than for a generic type <code>T</code>.</p>
<Listing number="20-5" caption="An attempted implementation of `split_at_mut` using only safe Rust">
<pre><code class="language-rust ignore does_not_compile">fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();

    assert!(mid &lt;= len);

    (&amp;mut values[..mid], &amp;mut values[mid..])
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}</span></code></pre>
</Listing>
<p>This function first gets the total length of the slice. Then it asserts that the index given as a parameter is within the slice by checking whether it‚Äôs less than or equal to the length. The assertion means that if we pass an index that is greater than the length to split the slice at, the function will panic before it attempts to use that index.</p>
<p>Then we return two mutable slices in a tuple: one from the start of the original slice to the <code>mid</code> index and another from <code>mid</code> to the end of the slice.</p>
<p>When we try to compile the code in Listing 20-5, we‚Äôll get an error.</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0499]: cannot borrow `*values` as mutable more than once at a time
 --&gt; src/main.rs:6:31
  |
1 | fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
  |                         - let's call the lifetime of this reference `'1`
...
6 |     (&amp;mut values[..mid], &amp;mut values[mid..])
  |     --------------------------^^^^^^--------
  |     |     |                   |
  |     |     |                   second mutable borrow occurs here
  |     |     first mutable borrow occurs here
  |     returning this value requires that `*values` is borrowed for `'1`
  |
  = help: use `.split_at_mut(position)` to obtain two mutable non-overlapping sub-slices

For more information about this error, try `rustc --explain E0499`.
error: could not compile `unsafe-example` (bin "unsafe-example") due to 1 previous error
</code></pre>
<p>Rust‚Äôs borrow checker can‚Äôt understand that we‚Äôre borrowing different parts of the slice; it only knows that we‚Äôre borrowing from the same slice twice. Borrowing different parts of a slice is fundamentally okay because the two slices aren‚Äôt overlapping, but Rust isn‚Äôt smart enough to know this. When we know code is okay, but Rust doesn‚Äôt, it‚Äôs time to reach for unsafe code.</p>
<p>Listing 20-6 shows how to use an <code>unsafe</code> block, a raw pointer, and some calls to unsafe functions to make the implementation of <code>split_at_mut</code> work.</p>
<Listing number="20-6" caption="Using unsafe code in the implementation of the `split_at_mut` function">
<pre><pre class="playground"><code class="language-rust edition2021">use std::slice;

fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();
    let ptr = values.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>Recall from <a href="ch04-03-slices.html#the-slice-type">‚ÄúThe Slice Type‚Äù</a><!-- ignore --> in Chapter 4 that slices are a pointer to some data and the length of the slice. We use the <code>len</code> method to get the length of a slice and the <code>as_mut_ptr</code> method to access the raw pointer of a slice. In this case, because we have a mutable slice to <code>i32</code> values, <code>as_mut_ptr</code> returns a raw pointer with the type <code>*mut i32</code>, which we‚Äôve stored in the variable <code>ptr</code>.</p>
<p>We keep the assertion that the <code>mid</code> index is within the slice. Then we get to the unsafe code: the <code>slice::from_raw_parts_mut</code> function takes a raw pointer and a length, and it creates a slice. We use this function to create a slice that starts from <code>ptr</code> and is <code>mid</code> items long. Then we call the <code>add</code> method on <code>ptr</code> with <code>mid</code> as an argument to get a raw pointer that starts at <code>mid</code>, and we create a slice using that pointer and the remaining number of items after <code>mid</code> as the length.</p>
<p>The function <code>slice::from_raw_parts_mut</code> is unsafe because it takes a raw pointer and must trust that this pointer is valid. The <code>add</code> method on raw pointers is also unsafe, because it must trust that the offset location is also a valid pointer. Therefore, we had to put an <code>unsafe</code> block around our calls to <code>slice::from_raw_parts_mut</code> and <code>add</code> so we could call them. By looking at the code and by adding the assertion that <code>mid</code> must be less than or equal to <code>len</code>, we can tell that all the raw pointers used within the <code>unsafe</code> block will be valid pointers to data within the slice. This is an acceptable and appropriate use of <code>unsafe</code>.</p>
<p>Note that we don‚Äôt need to mark the resulting <code>split_at_mut</code> function as <code>unsafe</code>, and we can call this function from safe Rust. We‚Äôve created a safe abstraction to the unsafe code with an implementation of the function that uses <code>unsafe</code> code in a safe way, because it creates only valid pointers from the data this function has access to.</p>
<p>In contrast, the use of <code>slice::from_raw_parts_mut</code> in Listing 20-7 would likely crash when the slice is used. This code takes an arbitrary memory location and creates a slice 10,000 items long.</p>
<Listing number="20-7" caption="Creating a slice from an arbitrary memory location">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    use std::slice;

    let address = 0x01234usize;
    let r = address as *mut i32;

    let values: &amp;[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>We don‚Äôt own the memory at this arbitrary location, and there is no guarantee that the slice this code creates contains valid <code>i32</code> values. Attempting to use <code>values</code> as though it‚Äôs a valid slice results in undefined behavior.</p>
<h4 id="using-extern-functions-to-call-external-code"><a class="header" href="#using-extern-functions-to-call-external-code">Using <code>extern</code> Functions to Call External Code</a></h4>
<p>Sometimes, your Rust code might need to interact with code written in another language. For this, Rust has the keyword <code>extern</code> that facilitates the creation and use of a <em>Foreign Function Interface (FFI)</em>. An FFI is a way for a programming language to define functions and enable a different (foreign) programming language to call those functions.</p>
<p>Listing 20-8 demonstrates how to set up an integration with the <code>abs</code> function from the C standard library. Functions declared within <code>extern</code> blocks are usually unsafe to call from Rust code, so they must also be marked <code>unsafe</code>. The reason is that other languages don‚Äôt enforce Rust‚Äôs rules and guarantees, and Rust can‚Äôt check them, so responsibility falls on the programmer to ensure safety.</p>
<Listing number="20-8" file-name="src/main.rs" caption="Declaring and calling an `extern` function defined in another language">
<pre><pre class="playground"><code class="language-rust edition2021">unsafe extern "C" {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!("Absolute value of -3 according to C: {}", abs(-3));
    }
}</code></pre></pre>
</Listing>
<p>Within the <code>unsafe extern "C"</code> block, we list the names and signatures of external functions from another language we want to call. The <code>"C"</code> part defines which <em>application binary interface (ABI)</em> the external function uses: the ABI defines how to call the function at the assembly level. The <code>"C"</code> ABI is the most common and follows the C programming language‚Äôs ABI.</p>
<p>This particular function does not have any memory safety considerations, though. In fact, we know that any call to <code>abs</code> will always be safe for any <code>i32</code>, so we can use the <code>safe</code> keyword to say that this specific function is safe to call even though it is in an <code>unsafe extern</code> block. Once we make that change, calling it no longer requires an <code>unsafe</code> block, as shown in Listing 20-9.</p>
<Listing number="20-9" file-name="src/main.rs" caption="Explicitly marking a function as `safe` within an `unsafe extern` block and calling it safely">
<pre><pre class="playground"><code class="language-rust edition2021">unsafe extern "C" {
    safe fn abs(input: i32) -&gt; i32;
}

fn main() {
    println!("Absolute value of -3 according to C: {}", abs(-3));
}</code></pre></pre>
</Listing>
<p>Marking a function as <code>safe</code> does not inherently make it safe! Instead, it is like a promise you are making to Rust that it <em>is</em> safe. It is still your responsibility to make sure that promise is kept!</p>
<blockquote>
<h4 id="calling-rust-functions-from-other-languages"><a class="header" href="#calling-rust-functions-from-other-languages">Calling Rust Functions from Other Languages</a></h4>
<p>We can also use <code>extern</code> to create an interface that allows other languages to call Rust functions. Instead of creating a whole <code>extern</code> block, we add the <code>extern</code> keyword and specify the ABI to use just before the <code>fn</code> keyword for the relevant function. We also need to add a <code>#[unsafe(no_mangle)]</code> annotation to tell the Rust compiler not to mangle the name of this function. <em>Mangling</em> is when a compiler changes the name we‚Äôve given a function to a different name that contains more information for other parts of the compilation process to consume but is less human readable. Every programming language compiler mangles names slightly differently, so for a Rust function to be nameable by other languages, we must disable the Rust compiler‚Äôs name mangling. This is unsafe because there might be name collisions across libraries without the built-in mangling, so it is our responsibility to make sure the name we have exported is safe to export without mangling.</p>
<p>In the following example, we make the <code>call_from_c</code> function accessible from C code, after it‚Äôs compiled to a shared library and linked from C:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[unsafe(no_mangle)]
pub extern "C" fn call_from_c() {
    println!("Just called a Rust function from C!");
}
<span class="boring">}</span></code></pre></pre>
<p>This usage of <code>extern</code> does not require <code>unsafe</code>.</p>
</blockquote>
<h3 id="accessing-or-modifying-a-mutable-static-variable"><a class="header" href="#accessing-or-modifying-a-mutable-static-variable">Accessing or Modifying a Mutable Static Variable</a></h3>
<p>In this book, we‚Äôve not yet talked about <em>global variables</em>, which Rust does support but can be problematic with Rust‚Äôs ownership rules. If two threads are accessing the same mutable global variable, it can cause a data race.</p>
<p>In Rust, global variables are called <em>static</em> variables. Listing 20-10 shows an example declaration and use of a static variable with a string slice as a value.</p>
<Listing number="20-10" file-name="src/main.rs" caption="Defining and using an immutable static variable">
<pre><pre class="playground"><code class="language-rust edition2021">static HELLO_WORLD: &amp;str = "Hello, world!";

fn main() {
    println!("name is: {HELLO_WORLD}");
}</code></pre></pre>
</Listing>
<p>Static variables are similar to constants, which we discussed in <a href="ch03-01-variables-and-mutability.html#constants">‚ÄúConstants‚Äù</a><!-- ignore --> in Chapter 3. The names of static variables are in <code>SCREAMING_SNAKE_CASE</code> by convention. Static variables can only store references with the <code>'static</code> lifetime, which means the Rust compiler can figure out the lifetime and we aren‚Äôt required to annotate it explicitly. Accessing an immutable static variable is safe.</p>
<p>A subtle difference between constants and immutable static variables is that values in a static variable have a fixed address in memory. Using the value will always access the same data. Constants, on the other hand, are allowed to duplicate their data whenever they‚Äôre used. Another difference is that static variables can be mutable. Accessing and modifying mutable static variables is <em>unsafe</em>. Listing 20-11 shows how to declare, access, and modify a mutable static variable named <code>COUNTER</code>.</p>
<Listing number="20-11" file-name="src/main.rs" caption="Reading from or writing to a mutable static variable is unsafe">
<pre><pre class="playground"><code class="language-rust edition2021">static mut COUNTER: u32 = 0;

/// SAFETY: Calling this from more than a single thread at a time is undefined
/// behavior, so you *must* guarantee you only call it from a single thread at
/// a time.
unsafe fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    unsafe {
        // SAFETY: This is only called from a single thread in `main`.
        add_to_count(3);
        println!("COUNTER: {}", *(&amp;raw const COUNTER));
    }
}</code></pre></pre>
</Listing>
<p>As with regular variables, we specify mutability using the <code>mut</code> keyword. Any code that reads or writes from <code>COUNTER</code> must be within an <code>unsafe</code> block. The code in Listing 20-11 compiles and prints <code>COUNTER: 3</code> as we would expect because it‚Äôs single threaded. Having multiple threads access <code>COUNTER</code> would likely result in data races, so it is undefined behavior. Therefore, we need to mark the entire function as <code>unsafe</code>, and document the safety limitation, so anyone calling the function knows what they are and are not allowed to do safely.</p>
<p>Whenever we write an unsafe function, it is idiomatic to write a comment starting with <code>SAFETY</code> and explaining what the caller needs to do to call the function safely. Likewise, whenever we perform an unsafe operation, it is idiomatic to write a comment starting with <code>SAFETY</code> to explain how the safety rules are upheld.</p>
<p>Additionally, the compiler will not allow you to create references to a mutable static variable. You can only access it via a raw pointer, created with one of the raw borrow operators. That includes in cases where the reference is created invisibly, as when it is used in the <code>println!</code> in this code listing. The requirement that references to static mutable variables can only be created via raw pointers helps make the safety requirements for using them more obvious.</p>
<p>With mutable data that is globally accessible, it‚Äôs difficult to ensure there are no data races, which is why Rust considers mutable static variables to be unsafe. Where possible, it‚Äôs preferable to use the concurrency techniques and thread-safe smart pointers we discussed in Chapter 16 so the compiler checks that data accessed from different threads is done safely.</p>
<h3 id="implementing-an-unsafe-trait"><a class="header" href="#implementing-an-unsafe-trait">Implementing an Unsafe Trait</a></h3>
<p>We can use <code>unsafe</code> to implement an unsafe trait. A trait is unsafe when at least one of its methods has some invariant that the compiler can‚Äôt verify. We declare that a trait is <code>unsafe</code> by adding the <code>unsafe</code> keyword before <code>trait</code> and marking the implementation of the trait as <code>unsafe</code> too, as shown in Listing 20-12.</p>
<Listing number="20-12" caption="Defining and implementing an unsafe trait">
<pre><pre class="playground"><code class="language-rust edition2021">unsafe trait Foo {
    // methods go here
}

unsafe impl Foo for i32 {
    // method implementations go here
}

fn main() {}</code></pre></pre>
</Listing>
<p>By using <code>unsafe impl</code>, we‚Äôre promising that we‚Äôll uphold the invariants that the compiler can‚Äôt verify.</p>
<p>As an example, recall the <code>Sync</code> and <code>Send</code> marker traits we discussed in <a href="ch16-04-extensible-concurrency-sync-and-send.html#extensible-concurrency-with-the-sync-and-send-traits">‚ÄúExtensible Concurrency with the <code>Sync</code> and <code>Send</code> Traits‚Äù</a><!-- ignore --> in Chapter 16: the compiler implements these traits automatically if our types are composed entirely of <code>Send</code> and <code>Sync</code> types. If we implement a type that contains a type that is not <code>Send</code> or <code>Sync</code>, such as raw pointers, and we want to mark that type as <code>Send</code> or <code>Sync</code>, we must use <code>unsafe</code>. Rust can‚Äôt verify that our type upholds the guarantees that it can be safely sent across threads or accessed from multiple threads; therefore, we need to do those checks manually and indicate as such with <code>unsafe</code>.</p>
<h3 id="accessing-fields-of-a-union"><a class="header" href="#accessing-fields-of-a-union">Accessing Fields of a Union</a></h3>
<p>The final action that works only with <code>unsafe</code> is accessing fields of a <em>union</em>. A <code>union</code> is similar to a <code>struct</code>, but only one declared field is used in a particular instance at one time. Unions are primarily used to interface with unions in C code. Accessing union fields is unsafe because Rust can‚Äôt guarantee the type of the data currently being stored in the union instance. You can learn more about unions in <a href="../reference/items/unions.html">the Rust Reference</a>.</p>
<h3 id="using-miri-to-check-unsafe-code"><a class="header" href="#using-miri-to-check-unsafe-code">Using Miri to check unsafe code</a></h3>
<p>When writing unsafe code, you might want to check that what you have written actually is safe and correct. One of the best ways to do that is to use <a href="https://github.com/rust-lang/miri">Miri</a>, an official Rust tool for detecting undefined behavior. Whereas the borrow checker is a <em>static</em> tool which works at compile time, Miri is a <em>dynamic</em> tool which works at runtime. It checks your code by running your program, or its test suite, and detecting when you violate the rules it understands about how Rust should work.</p>
<p>Using Miri requires a nightly build of Rust (which we talk about more in <a href="appendix-07-nightly-rust.html">Appendix G: How Rust is Made and ‚ÄúNightly Rust‚Äù</a>). You can install both a nightly version of Rust and the Miri tool by typing <code>rustup +nightly component add miri</code>. This does not change what version of Rust your project uses; it only adds the tool to your system so you can use it when you want to. You can run Miri on a project by typing <code>cargo +nightly miri run</code> or <code>cargo +nightly miri test</code>.</p>
<p>For an example of how helpful this can be, consider what happens when we run it against Listing 20-11:</p>
<pre><code class="language-console">$ cargo +nightly miri run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.01s
     Running `/Users/chris/.rustup/toolchains/nightly-aarch64-apple-darwin/bin/cargo-miri runner target/miri/aarch64-apple-darwin/debug/unsafe-example`
warning: creating a shared reference to mutable static is discouraged
  --&gt; src/main.rs:14:33
   |
14 |         println!("COUNTER: {}", COUNTER);
   |                                 ^^^^^^^ shared reference to mutable static
   |
   = note: for more information, see &lt;https://doc.rust-lang.org/nightly/edition-guide/rust-2024/static-mut-references.html&gt;
   = note: shared references to mutable statics are dangerous; it's undefined behavior if the static is mutated or if a mutable reference is created for it while the shared reference lives
   = note: `#[warn(static_mut_refs)]` on by default

COUNTER: 3
</code></pre>
<p>It helpfully and correctly notices that we have shared references to mutable data, and warns about it. In this case, it does not tell us how to fix the problem, but it means that we know there is a possible issue and can think about how to make sure it is safe. In other cases, it can actually tell us that some code is <em>sure</em> to be wrong and make recommendations about how to fix it.</p>
<p>Miri doesn‚Äôt catch <em>everything</em> you might get wrong when writing unsafe code. For one thing, since it is a dynamic check, it only catches problems with code that actually gets run. That means you will need to use it in conjunction with good testing techniques to increase your confidence about the unsafe code you have written. For another thing, it does not cover every possible way your code can be unsound. If Miri <em>does</em> catch a problem, you know there‚Äôs a bug, but just because Miri <em>doesn‚Äôt</em> catch a bug doesn‚Äôt mean there isn‚Äôt a problem. Miri can catch a lot, though. Try running it on the other examples of unsafe code in this chapter and see what it says!</p>
<h3 id="when-to-use-unsafe-code"><a class="header" href="#when-to-use-unsafe-code">When to Use Unsafe Code</a></h3>
<p>Using <code>unsafe</code> to take one of the five actions (superpowers) just discussed isn‚Äôt wrong or even frowned upon. But it is trickier to get <code>unsafe</code> code correct because the compiler can‚Äôt help uphold memory safety. When you have a reason to use <code>unsafe</code> code, you can do so, and having the explicit <code>unsafe</code> annotation makes it easier to track down the source of problems when they occur. Whenever you write unsafe code, you can use Miri to help you be more confident that the code you have written upholds Rust‚Äôs rules.</p>
<p>For a much deeper exploration of how to work effectively with unsafe Rust, read Rust‚Äôs official guide to the subject, the <a href="https://doc.rust-lang.org/nomicon/">Rustonomicon</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ-—Ç—Ä–µ–π—Ç—ã"><a class="header" href="#–ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ-—Ç—Ä–µ–π—Ç—ã">–ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ —Ç—Ä–µ–π—Ç—ã</a></h2>
<p>We first covered traits in <a href="ch10-02-traits.html#traits-defining-shared-behavior">‚ÄúTraits: Defining Shared Behavior‚Äù</a><!-- ignore --> in Chapter 10, but we didn‚Äôt discuss the more advanced details. Now that you know more about Rust, we can get into the nitty-gritty.</p>
<h3 id="specifying-placeholder-types-in-trait-definitions-with-associated-types"><a class="header" href="#specifying-placeholder-types-in-trait-definitions-with-associated-types">Specifying Placeholder Types in Trait Definitions with Associated Types</a></h3>
<p><em>Associated types</em> connect a type placeholder with a trait such that the trait method definitions can use these placeholder types in their signatures. The implementor of a trait will specify the concrete type to be used instead of the placeholder type for the particular implementation. That way, we can define a trait that uses some types without needing to know exactly what those types are until the trait is implemented.</p>
<p>We‚Äôve described most of the advanced features in this chapter as being rarely needed. Associated types are somewhere in the middle: they‚Äôre used more rarely than features explained in the rest of the book but more commonly than many of the other features discussed in this chapter.</p>
<p>One example of a trait with an associated type is the <code>Iterator</code> trait that the standard library provides. The associated type is named <code>Item</code> and stands in for the type of the values the type implementing the <code>Iterator</code> trait is iterating over. The definition of the <code>Iterator</code> trait is as shown in Listing 20-13.</p>
<Listing number="20-13" caption="The definition of the `Iterator` trait that has an associated type `Item`">
<pre><code class="language-rust noplayground">pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}</code></pre>
</Listing>
<p>The type <code>Item</code> is a placeholder, and the <code>next</code> method‚Äôs definition shows that it will return values of type <code>Option&lt;Self::Item&gt;</code>. Implementors of the <code>Iterator</code> trait will specify the concrete type for <code>Item</code>, and the <code>next</code> method will return an <code>Option</code> containing a value of that concrete type.</p>
<p>Associated types might seem like a similar concept to generics, in that the latter allow us to define a function without specifying what types it can handle. To examine the difference between the two concepts, we‚Äôll look at an implementation of the <code>Iterator</code> trait on a type named <code>Counter</code> that specifies the <code>Item</code> type is <code>u32</code>:</p>
<Listing file-name="src/lib.rs">
<pre><code class="language-rust ignore"><span class="boring">struct Counter {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Counter {
</span><span class="boring">    fn new() -&gt; Counter {
</span><span class="boring">        Counter { count: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">        if self.count &lt; 5 {
</span><span class="boring">            self.count += 1;
</span><span class="boring">            Some(self.count)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>This syntax seems comparable to that of generics. So why not just define the <code>Iterator</code> trait with generics, as shown in Listing 20-14?</p>
<Listing number="20-14" caption="A hypothetical definition of the `Iterator` trait using generics">
<pre><code class="language-rust noplayground">pub trait Iterator&lt;T&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;
}</code></pre>
</Listing>
<p>The difference is that when using generics, as in Listing 20-14, we must annotate the types in each implementation; because we can also implement <code>Iterator&lt;String&gt; for Counter</code> or any other type, we could have multiple implementations of <code>Iterator</code> for <code>Counter</code>. In other words, when a trait has a generic parameter, it can be implemented for a type multiple times, changing the concrete types of the generic type parameters each time. When we use the <code>next</code> method on <code>Counter</code>, we would have to provide type annotations to indicate which implementation of <code>Iterator</code> we want to use.</p>
<p>With associated types, we don‚Äôt need to annotate types because we can‚Äôt implement a trait on a type multiple times. In Listing 20-13 with the definition that uses associated types, we can only choose what the type of <code>Item</code> will be once, because there can only be one <code>impl Iterator for Counter</code>. We don‚Äôt have to specify that we want an iterator of <code>u32</code> values everywhere that we call <code>next</code> on <code>Counter</code>.</p>
<p>Associated types also become part of the trait‚Äôs contract: implementors of the trait must provide a type to stand in for the associated type placeholder. Associated types often have a name that describes how the type will be used, and documenting the associated type in the API documentation is good practice.</p>
<h3 id="default-generic-type-parameters-and-operator-overloading"><a class="header" href="#default-generic-type-parameters-and-operator-overloading">Default Generic Type Parameters and Operator Overloading</a></h3>
<p>When we use generic type parameters, we can specify a default concrete type for the generic type. This eliminates the need for implementors of the trait to specify a concrete type if the default type works. You specify a default type when declaring a generic type with the <code>&lt;PlaceholderType=ConcreteType&gt;</code> syntax.</p>
<p>A great example of a situation where this technique is useful is with <em>operator overloading</em>, in which you customize the behavior of an operator (such as <code>+</code>) in particular situations.</p>
<p>Rust doesn‚Äôt allow you to create your own operators or overload arbitrary operators. But you can overload the operations and corresponding traits listed in <code>std::ops</code> by implementing the traits associated with the operator. For example, in Listing 20-15 we overload the <code>+</code> operator to add two <code>Point</code> instances together. We do this by implementing the <code>Add</code> trait on a <code>Point</code> struct:</p>
<Listing number="20-15" file-name="src/main.rs" caption="Implementing the `Add` trait to overload the `+` operator for `Point` instances">
<pre><pre class="playground"><code class="language-rust edition2021">use std::ops::Add;

#[derive(Debug, Copy, Clone, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(
        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
        Point { x: 3, y: 3 }
    );
}</code></pre></pre>
</Listing>
<p>The <code>add</code> method adds the <code>x</code> values of two <code>Point</code> instances and the <code>y</code> values of two <code>Point</code> instances to create a new <code>Point</code>. The <code>Add</code> trait has an associated type named <code>Output</code> that determines the type returned from the <code>add</code> method.</p>
<p>The default generic type in this code is within the <code>Add</code> trait. Here is its definition:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Add&lt;Rhs=Self&gt; {
    type Output;

    fn add(self, rhs: Rhs) -&gt; Self::Output;
}
<span class="boring">}</span></code></pre></pre>
<p>This code should look generally familiar: a trait with one method and an associated type. The new part is <code>Rhs=Self</code>: this syntax is called <em>default type parameters</em>. The <code>Rhs</code> generic type parameter (short for ‚Äúright hand side‚Äù) defines the type of the <code>rhs</code> parameter in the <code>add</code> method. If we don‚Äôt specify a concrete type for <code>Rhs</code> when we implement the <code>Add</code> trait, the type of <code>Rhs</code> will default to <code>Self</code>, which will be the type we‚Äôre implementing <code>Add</code> on.</p>
<p>When we implemented <code>Add</code> for <code>Point</code>, we used the default for <code>Rhs</code> because we wanted to add two <code>Point</code> instances. Let‚Äôs look at an example of implementing the <code>Add</code> trait where we want to customize the <code>Rhs</code> type rather than using the default.</p>
<p>We have two structs, <code>Millimeters</code> and <code>Meters</code>, holding values in different units. This thin wrapping of an existing type in another struct is known as the <em>newtype pattern</em>, which we describe in more detail in the <a href="ch20-02-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types">‚ÄúUsing the Newtype Pattern to Implement External Traits on External Types‚Äù</a><!-- ignore
--> section. We want to add values in millimeters to values in meters and have the implementation of <code>Add</code> do the conversion correctly. We can implement <code>Add</code> for <code>Millimeters</code> with <code>Meters</code> as the <code>Rhs</code>, as shown in Listing 20-16.</p>
<Listing number="20-16" file-name="src/lib.rs" caption="Implementing the `Add` trait on `Millimeters` to add `Millimeters` to `Meters`">
<pre><code class="language-rust noplayground">use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add&lt;Meters&gt; for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -&gt; Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}</code></pre>
</Listing>
<p>To add <code>Millimeters</code> and <code>Meters</code>, we specify <code>impl Add&lt;Meters&gt;</code> to set the value of the <code>Rhs</code> type parameter instead of using the default of <code>Self</code>.</p>
<p>You‚Äôll use default type parameters in two main ways:</p>
<ol>
<li>To extend a type without breaking existing code</li>
<li>To allow customization in specific cases most users won‚Äôt need</li>
</ol>
<p>The standard library‚Äôs <code>Add</code> trait is an example of the second purpose: usually, you‚Äôll add two like types, but the <code>Add</code> trait provides the ability to customize beyond that. Using a default type parameter in the <code>Add</code> trait definition means you don‚Äôt have to specify the extra parameter most of the time. In other words, a bit of implementation boilerplate isn‚Äôt needed, making it easier to use the trait.</p>
<p>The first purpose is similar to the second but in reverse: if you want to add a type parameter to an existing trait, you can give it a default to allow extension of the functionality of the trait without breaking the existing implementation code.</p>
<h3 id="fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name"><a class="header" href="#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name">Fully Qualified Syntax for Disambiguation: Calling Methods with the Same Name</a></h3>
<p>Nothing in Rust prevents a trait from having a method with the same name as another trait‚Äôs method, nor does Rust prevent you from implementing both traits on one type. It‚Äôs also possible to implement a method directly on the type with the same name as methods from traits.</p>
<p>When calling methods with the same name, you‚Äôll need to tell Rust which one you want to use. Consider the code in Listing 20-17 where we‚Äôve defined two traits, <code>Pilot</code> and <code>Wizard</code>, that both have a method called <code>fly</code>. We then implement both traits on a type <code>Human</code> that already has a method named <code>fly</code> implemented on it. Each <code>fly</code> method does something different.</p>
<Listing number="20-17" file-name="src/main.rs" caption="Two traits are defined to have a ` method and are implemented on the `Human` type, and a `fly` method is implemented on `Human` directly">
<pre><pre class="playground"><code class="language-rust edition2021">trait Pilot {
    fn fly(&amp;self);
}

trait Wizard {
    fn fly(&amp;self);
}

struct Human;

impl Pilot for Human {
    fn fly(&amp;self) {
        println!("This is your captain speaking.");
    }
}

impl Wizard for Human {
    fn fly(&amp;self) {
        println!("Up!");
    }
}

impl Human {
    fn fly(&amp;self) {
        println!("*waving arms furiously*");
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p>When we call <code>fly</code> on an instance of <code>Human</code>, the compiler defaults to calling the method that is directly implemented on the type, as shown in Listing 20-18.</p>
<Listing number="20-18" file-name="src/main.rs" caption="Calling `fly` on an instance of `Human`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("This is your captain speaking.");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("Up!");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("*waving arms furiously*");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    person.fly();
}</code></pre></pre>
</Listing>
<p>Running this code will print <code>*waving arms furiously*</code>, showing that Rust called the <code>fly</code> method implemented on <code>Human</code> directly.</p>
<p>To call the <code>fly</code> methods from either the <code>Pilot</code> trait or the <code>Wizard</code> trait, we need to use more explicit syntax to specify which <code>fly</code> method we mean. Listing 20-19 demonstrates this syntax.</p>
<Listing number="20-19" file-name="src/main.rs" caption="Specifying which trait‚Äôs `fly` method we want to call">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("This is your captain speaking.");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("Up!");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("*waving arms furiously*");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    Pilot::fly(&amp;person);
    Wizard::fly(&amp;person);
    person.fly();
}</code></pre></pre>
</Listing>
<p>Specifying the trait name before the method name clarifies to Rust which implementation of <code>fly</code> we want to call. We could also write <code>Human::fly(&amp;person)</code>, which is equivalent to the <code>person.fly()</code> that we used in Listing 20-19, but this is a bit longer to write if we don‚Äôt need to disambiguate.</p>
<p>Running this code prints the following:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.46s
     Running `target/debug/traits-example`
This is your captain speaking.
Up!
*waving arms furiously*
</code></pre>
<p>Because the <code>fly</code> method takes a <code>self</code> parameter, if we had two <em>types</em> that both implement one <em>trait</em>, Rust could figure out which implementation of a trait to use based on the type of <code>self</code>.</p>
<p>However, associated functions that are not methods don‚Äôt have a <code>self</code> parameter. When there are multiple types or traits that define non-method functions with the same function name, Rust doesn't always know which type you mean unless you use <em>fully qualified syntax</em>. For example, in Listing 20-20 we create a trait for an animal shelter that wants to name all baby dogs <em>Spot</em>. We make an <code>Animal</code> trait with an associated non-method function <code>baby_name</code>. The <code>Animal</code> trait is implemented for the struct <code>Dog</code>, on which we also provide an associated non-method function <code>baby_name</code> directly.</p>
<Listing number="20-20" file-name="src/main.rs" caption="A trait with an associated function and a type with an associated function of the same name that also implements the trait">
<pre><pre class="playground"><code class="language-rust edition2021">trait Animal {
    fn baby_name() -&gt; String;
}

struct Dog;

impl Dog {
    fn baby_name() -&gt; String {
        String::from("Spot")
    }
}

impl Animal for Dog {
    fn baby_name() -&gt; String {
        String::from("puppy")
    }
}

fn main() {
    println!("A baby dog is called a {}", Dog::baby_name());
}</code></pre></pre>
</Listing>
<p>We implement the code for naming all puppies Spot in the <code>baby_name</code> associated function that is defined on <code>Dog</code>. The <code>Dog</code> type also implements the trait <code>Animal</code>, which describes characteristics that all animals have. Baby dogs are called puppies, and that is expressed in the implementation of the <code>Animal</code> trait on <code>Dog</code> in the <code>baby_name</code> function associated with the <code>Animal</code> trait.</p>
<p>In <code>main</code>, we call the <code>Dog::baby_name</code> function, which calls the associated function defined on <code>Dog</code> directly. This code prints the following:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.54s
     Running `target/debug/traits-example`
A baby dog is called a Spot
</code></pre>
<p>This output isn‚Äôt what we wanted. We want to call the <code>baby_name</code> function that is part of the <code>Animal</code> trait that we implemented on <code>Dog</code> so the code prints <code>A baby dog is called a puppy</code>. The technique of specifying the trait name that we used in Listing 20-19 doesn‚Äôt help here; if we change <code>main</code> to the code in Listing 20-21, we‚Äôll get a compilation error.</p>
<Listing number="20-21" file-name="src/main.rs" caption="Attempting to call the `baby_name` function from the `Animal` trait, but Rust doesn‚Äôt know which implementation to use">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("Spot")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("puppy")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!("A baby dog is called a {}", Animal::baby_name());
}</code></pre>
</Listing>
<p>Because <code>Animal::baby_name</code> doesn‚Äôt have a <code>self</code> parameter, and there could be other types that implement the <code>Animal</code> trait, Rust can‚Äôt figure out which implementation of <code>Animal::baby_name</code> we want. We‚Äôll get this compiler error:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0790]: cannot call associated function on trait without specifying the corresponding `impl` type
  --&gt; src/main.rs:20:43
   |
2  |     fn baby_name() -&gt; String;
   |     ------------------------- `Animal::baby_name` defined here
...
20 |     println!("A baby dog is called a {}", Animal::baby_name());
   |                                           ^^^^^^^^^^^^^^^^^^^ cannot call associated function of trait
   |
help: use the fully-qualified path to the only available implementation
   |
20 |     println!("A baby dog is called a {}", &lt;Dog as Animal&gt;::baby_name());
   |                                           +++++++       +

For more information about this error, try `rustc --explain E0790`.
error: could not compile `traits-example` (bin "traits-example") due to 1 previous error
</code></pre>
<p>To disambiguate and tell Rust that we want to use the implementation of <code>Animal</code> for <code>Dog</code> as opposed to the implementation of <code>Animal</code> for some other type, we need to use fully qualified syntax. Listing 20-22 demonstrates how to use fully qualified syntax.</p>
<Listing number="20-22" file-name="src/main.rs" caption="Using fully qualified syntax to specify that we want to call the `baby_name` function from the `Animal` trait as implemented on `Dog`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("Spot")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("puppy")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!("A baby dog is called a {}", &lt;Dog as Animal&gt;::baby_name());
}</code></pre></pre>
</Listing>
<p>We‚Äôre providing Rust with a type annotation within the angle brackets, which indicates we want to call the <code>baby_name</code> method from the <code>Animal</code> trait as implemented on <code>Dog</code> by saying that we want to treat the <code>Dog</code> type as an <code>Animal</code> for this function call. This code will now print what we want:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/traits-example`
A baby dog is called a puppy
</code></pre>
<p>In general, fully qualified syntax is defined as follows:</p>
<pre><code class="language-rust ignore">&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);</code></pre>
<p>For associated functions that aren‚Äôt methods, there would not be a <code>receiver</code>: there would only be the list of other arguments. You could use fully qualified syntax everywhere that you call functions or methods. However, you‚Äôre allowed to omit any part of this syntax that Rust can figure out from other information in the program. You only need to use this more verbose syntax in cases where there are multiple implementations that use the same name and Rust needs help to identify which implementation you want to call.</p>
<h3 id="using-supertraits-to-require-one-traits-functionality-within-another-trait"><a class="header" href="#using-supertraits-to-require-one-traits-functionality-within-another-trait">Using Supertraits to Require One Trait‚Äôs Functionality Within Another Trait</a></h3>
<p>Sometimes, you might write a trait definition that depends on another trait: for a type to implement the first trait, you want to require that type to also implement the second trait. You would do this so that your trait definition can make use of the associated items of the second trait. The trait your trait definition is relying on is called a <em>supertrait</em> of your trait.</p>
<p>For example, let‚Äôs say we want to make an <code>OutlinePrint</code> trait with an <code>outline_print</code> method that will print a given value formatted so that it's framed in asterisks. That is, given a <code>Point</code> struct that implements the standard library trait <code>Display</code> to result in <code>(x, y)</code>, when we call <code>outline_print</code> on a <code>Point</code> instance that has <code>1</code> for <code>x</code> and <code>3</code> for <code>y</code>, it should print the following:</p>
<pre><code class="language-text">**********
*        *
* (1, 3) *
*        *
**********
</code></pre>
<p>In the implementation of the <code>outline_print</code> method, we want to use the <code>Display</code> trait‚Äôs functionality. Therefore, we need to specify that the <code>OutlinePrint</code> trait will work only for types that also implement <code>Display</code> and provide the functionality that <code>OutlinePrint</code> needs. We can do that in the trait definition by specifying <code>OutlinePrint: Display</code>. This technique is similar to adding a trait bound to the trait. Listing 20-23 shows an implementation of the <code>OutlinePrint</code> trait.</p>
<Listing number="20-23" file-name="src/main.rs" caption="Implementing the `OutlinePrint` trait that requires the functionality from `Display`">
<pre><pre class="playground"><code class="language-rust edition2021">use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&amp;self) {
        let output = self.to_string();
        let len = output.len();
        println!("{}", "*".repeat(len + 4));
        println!("*{}*", " ".repeat(len + 2));
        println!("* {output} *");
        println!("*{}*", " ".repeat(len + 2));
        println!("{}", "*".repeat(len + 4));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p>Because we‚Äôve specified that <code>OutlinePrint</code> requires the <code>Display</code> trait, we can use the <code>to_string</code> function that is automatically implemented for any type that implements <code>Display</code>. If we tried to use <code>to_string</code> without adding a colon and specifying the <code>Display</code> trait after the trait name, we‚Äôd get an error saying that no method named <code>to_string</code> was found for the type <code>&amp;Self</code> in the current scope.</p>
<p>Let‚Äôs see what happens when we try to implement <code>OutlinePrint</code> on a type that doesn‚Äôt implement <code>Display</code>, such as the <code>Point</code> struct:</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("* {output} *");
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}</span></code></pre>
</Listing>
<p>We get an error saying that <code>Display</code> is required but not implemented:</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --&gt; src/main.rs:20:23
   |
20 | impl OutlinePrint for Point {}
   |                       ^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
note: required by a bound in `OutlinePrint`
  --&gt; src/main.rs:3:21
   |
3  | trait OutlinePrint: fmt::Display {
   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint`

error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --&gt; src/main.rs:24:7
   |
24 |     p.outline_print();
   |       ^^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
note: required by a bound in `OutlinePrint::outline_print`
  --&gt; src/main.rs:3:21
   |
3  | trait OutlinePrint: fmt::Display {
   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint::outline_print`
4  |     fn outline_print(&amp;self) {
   |        ------------- required by a bound in this associated function

For more information about this error, try `rustc --explain E0277`.
error: could not compile `traits-example` (bin "traits-example") due to 2 previous errors
</code></pre>
<p>To fix this, we implement <code>Display</code> on <code>Point</code> and satisfy the constraint that <code>OutlinePrint</code> requires, like so:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("* {output} *");
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl OutlinePrint for Point {}
</span><span class="boring">
</span>use std::fmt;

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>Then implementing the <code>OutlinePrint</code> trait on <code>Point</code> will compile successfully, and we can call <code>outline_print</code> on a <code>Point</code> instance to display it within an outline of asterisks.</p>
<h3 id="using-the-newtype-pattern-to-implement-external-traits-on-external-types"><a class="header" href="#using-the-newtype-pattern-to-implement-external-traits-on-external-types">Using the Newtype Pattern to Implement External Traits on External Types</a></h3>
<p>In <a href="ch10-02-traits.html#implementing-a-trait-on-a-type">‚ÄúImplementing a Trait on a Type‚Äù</a><!-- ignore
--> in Chapter 10, we mentioned the orphan rule that states we‚Äôre only allowed to implement a trait on a type if either the trait or the type are local to our crate. It‚Äôs possible to get around this restriction using the <em>newtype pattern</em>, which involves creating a new type in a tuple struct. (We covered tuple structs in <a href="ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types">‚ÄúUsing Tuple Structs without Named Fields to Create Different Types‚Äù</a><!-- ignore --> in Chapter 5.) The tuple struct will have one field and be a thin wrapper around the type we want to implement a trait for. Then the wrapper type is local to our crate, and we can implement the trait on the wrapper. <em>Newtype</em> is a term that originates from the Haskell programming language. There is no runtime performance penalty for using this pattern, and the wrapper type is elided at compile time.</p>
<p>As an example, let‚Äôs say we want to implement <code>Display</code> on <code>Vec&lt;T&gt;</code>, which the orphan rule prevents us from doing directly because the <code>Display</code> trait and the <code>Vec&lt;T&gt;</code> type are defined outside our crate. We can make a <code>Wrapper</code> struct that holds an instance of <code>Vec&lt;T&gt;</code>; then we can implement <code>Display</code> on <code>Wrapper</code> and use the <code>Vec&lt;T&gt;</code> value, as shown in Listing 20-24.</p>
<Listing number="20-24" file-name="src/main.rs" caption="Creating a `Wrapper` type around `Vec<String>` to implement `Display`">
<pre><pre class="playground"><code class="language-rust edition2021">use std::fmt;

struct Wrapper(Vec&lt;String&gt;);

impl fmt::Display for Wrapper {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}

fn main() {
    let w = Wrapper(vec![String::from("hello"), String::from("world")]);
    println!("w = {w}");
}</code></pre></pre>
</Listing>
<p>The implementation of <code>Display</code> uses <code>self.0</code> to access the inner <code>Vec&lt;T&gt;</code>, because <code>Wrapper</code> is a tuple struct and <code>Vec&lt;T&gt;</code> is the item at index 0 in the tuple. Then we can use the functionality of the <code>Display</code> trait on <code>Wrapper</code>.</p>
<p>The downside of using this technique is that <code>Wrapper</code> is a new type, so it doesn‚Äôt have the methods of the value it‚Äôs holding. We would have to implement all the methods of <code>Vec&lt;T&gt;</code> directly on <code>Wrapper</code> such that the methods delegate to <code>self.0</code>, which would allow us to treat <code>Wrapper</code> exactly like a <code>Vec&lt;T&gt;</code>. If we wanted the new type to have every method the inner type has, implementing the <code>Deref</code> trait (discussed in <a href="ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait">‚ÄúTreating Smart Pointers Like Regular References with the <code>Deref</code> Trait‚Äù</a><!-- ignore --> in Chapter 15) on the <code>Wrapper</code> to return the inner type would be a solution. If we don‚Äôt want the <code>Wrapper</code> type to have all the methods of the inner type‚Äîfor example, to restrict the <code>Wrapper</code> type‚Äôs behavior‚Äîwe would have to implement just the methods we do want manually.</p>
<p>This newtype pattern is also useful even when traits are not involved. Let‚Äôs switch focus and look at some advanced ways to interact with Rust‚Äôs type system.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ-—Ç–∏–ø—ã"><a class="header" href="#–ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ-—Ç–∏–ø—ã">–ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ —Ç–∏–ø—ã</a></h2>
<p>The Rust type system has some features that we‚Äôve so far mentioned but haven‚Äôt yet discussed. We‚Äôll start by discussing newtypes in general as we examine why newtypes are useful as types. Then we‚Äôll move on to type aliases, a feature similar to newtypes but with slightly different semantics. We‚Äôll also discuss the <code>!</code> type and dynamically sized types.</p>
<h3 id="using-the-newtype-pattern-for-type-safety-and-abstraction"><a class="header" href="#using-the-newtype-pattern-for-type-safety-and-abstraction">Using the Newtype Pattern for Type Safety and Abstraction</a></h3>
<p>This section assumes you‚Äôve read the earlier section <a href="ch20-02-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types">‚ÄúUsing the Newtype Pattern to Implement External Traits on External Types.‚Äù</a><!--
ignore --> The newtype pattern is also useful for tasks beyond those we‚Äôve discussed so far, including statically enforcing that values are never confused and indicating the units of a value. You saw an example of using newtypes to indicate units in Listing 20-16: recall that the <code>Millimeters</code> and <code>Meters</code> structs wrapped <code>u32</code> values in a newtype. If we wrote a function with a parameter of type <code>Millimeters</code>, we couldn‚Äôt compile a program that accidentally tried to call that function with a value of type <code>Meters</code> or a plain <code>u32</code>.</p>
<p>We can also use the newtype pattern to abstract away some implementation details of a type: the new type can expose a public API that is different from the API of the private inner type.</p>
<p>Newtypes can also hide internal implementation. For example, we could provide a <code>People</code> type to wrap a <code>HashMap&lt;i32, String&gt;</code> that stores a person‚Äôs ID associated with their name. Code using <code>People</code> would only interact with the public API we provide, such as a method to add a name string to the <code>People</code> collection; that code wouldn‚Äôt need to know that we assign an <code>i32</code> ID to names internally. The newtype pattern is a lightweight way to achieve encapsulation to hide implementation details, which we discussed in <a href="ch18-01-what-is-oo.html#encapsulation-that-hides-implementation-details">‚ÄúEncapsulation that Hides Implementation Details‚Äù</a><!--
ignore --> in Chapter 18.</p>
<h3 id="creating-type-synonyms-with-type-aliases"><a class="header" href="#creating-type-synonyms-with-type-aliases">Creating Type Synonyms with Type Aliases</a></h3>
<p>Rust provides the ability to declare a <em>type alias</em> to give an existing type another name. For this we use the <code>type</code> keyword. For example, we can create the alias <code>Kilometers</code> to <code>i32</code> like so:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    type Kilometers = i32;
<span class="boring">
</span><span class="boring">    let x: i32 = 5;
</span><span class="boring">    let y: Kilometers = 5;
</span><span class="boring">
</span><span class="boring">    println!("x + y = {}", x + y);
</span><span class="boring">}</span></code></pre></pre>
<p>Now, the alias <code>Kilometers</code> is a <em>synonym</em> for <code>i32</code>; unlike the <code>Millimeters</code> and <code>Meters</code> types we created in Listing 20-16, <code>Kilometers</code> is not a separate, new type. Values that have the type <code>Kilometers</code> will be treated the same as values of type <code>i32</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    type Kilometers = i32;

    let x: i32 = 5;
    let y: Kilometers = 5;

    println!("x + y = {}", x + y);
<span class="boring">}</span></code></pre></pre>
<p>Because <code>Kilometers</code> and <code>i32</code> are the same type, we can add values of both types and we can pass <code>Kilometers</code> values to functions that take <code>i32</code> parameters. However, using this method, we don‚Äôt get the type checking benefits that we get from the newtype pattern discussed earlier. In other words, if we mix up <code>Kilometers</code> and <code>i32</code> values somewhere, the compiler will not give us an error.</p>
<p>The main use case for type synonyms is to reduce repetition. For example, we might have a lengthy type like this:</p>
<pre><code class="language-rust ignore">Box&lt;dyn Fn() + Send + 'static&gt;</code></pre>
<p>Writing this lengthy type in function signatures and as type annotations all over the code can be tiresome and error prone. Imagine having a project full of code like that in Listing 20-25.</p>
<Listing number="20-25" caption="Using a long type in many places">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let f: Box&lt;dyn Fn() + Send + 'static&gt; = Box::new(|| println!("hi"));

    fn takes_long_type(f: Box&lt;dyn Fn() + Send + 'static&gt;) {
        // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
    }

    fn returns_long_type() -&gt; Box&lt;dyn Fn() + Send + 'static&gt; {
        // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>A type alias makes this code more manageable by reducing the repetition. In Listing 20-26, we‚Äôve introduced an alias named <code>Thunk</code> for the verbose type and can replace all uses of the type with the shorter alias <code>Thunk</code>.</p>
<Listing number="20-26" caption="Introducing a type alias, `Thunk`, to reduce repetition">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    type Thunk = Box&lt;dyn Fn() + Send + 'static&gt;;

    let f: Thunk = Box::new(|| println!("hi"));

    fn takes_long_type(f: Thunk) {
        // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
    }

    fn returns_long_type() -&gt; Thunk {
        // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>This code is much easier to read and write! Choosing a meaningful name for a type alias can help communicate your intent as well (<em>thunk</em> is a word for code to be evaluated at a later time, so it‚Äôs an appropriate name for a closure that gets stored).</p>
<p>Type aliases are also commonly used with the <code>Result&lt;T, E&gt;</code> type for reducing repetition. Consider the <code>std::io</code> module in the standard library. I/O operations often return a <code>Result&lt;T, E&gt;</code> to handle situations when operations fail to work. This library has a <code>std::io::Error</code> struct that represents all possible I/O errors. Many of the functions in <code>std::io</code> will be returning <code>Result&lt;T, E&gt;</code> where the <code>E</code> is <code>std::io::Error</code>, such as these functions in the <code>Write</code> trait:</p>
<pre><code class="language-rust noplayground">use std::fmt;
use std::io::Error;

pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;
}</code></pre>
<p>The <code>Result&lt;..., Error&gt;</code> is repeated a lot. As such, <code>std::io</code> has this type alias declaration:</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span>type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
<span class="boring">
</span><span class="boring">pub trait Write {
</span><span class="boring">    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
</span><span class="boring">    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;
</span><span class="boring">
</span><span class="boring">    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
</span><span class="boring">    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
</span><span class="boring">}</span></code></pre>
<p>Because this declaration is in the <code>std::io</code> module, we can use the fully qualified alias <code>std::io::Result&lt;T&gt;</code>; that is, a <code>Result&lt;T, E&gt;</code> with the <code>E</code> filled in as <code>std::io::Error</code>. The <code>Write</code> trait function signatures end up looking like this:</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
</span><span class="boring">
</span>pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
}</code></pre>
<p>The type alias helps in two ways: it makes code easier to write <em>and</em> it gives us a consistent interface across all of <code>std::io</code>. Because it‚Äôs an alias, it‚Äôs just another <code>Result&lt;T, E&gt;</code>, which means we can use any methods that work on <code>Result&lt;T, E&gt;</code> with it, as well as special syntax like the <code>?</code> operator.</p>
<h3 id="the-never-type-that-never-returns"><a class="header" href="#the-never-type-that-never-returns">The Never Type that Never Returns</a></h3>
<p>Rust has a special type named <code>!</code> that‚Äôs known in type theory lingo as the <em>empty type</em> because it has no values. We prefer to call it the <em>never type</em> because it stands in the place of the return type when a function will never return. Here is an example:</p>
<pre><code class="language-rust noplayground">fn bar() -&gt; ! {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">    panic!();
</span>}</code></pre>
<p>This code is read as ‚Äúthe function <code>bar</code> returns never.‚Äù Functions that return never are called <em>diverging functions</em>. We can‚Äôt create values of the type <code>!</code> so <code>bar</code> can never possibly return.</p>
<p>But what use is a type you can never create values for? Recall the code from Listing 2-5, part of the number guessing game; we‚Äôve reproduced a bit of it here in Listing 20-27.</p>
<Listing number="20-27" caption="A `match` with an arm that ends in `continue`">
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("–£–≥–∞–¥–∞–π—Ç–µ —á–∏—Å–ª–æ!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("–ó–∞–≥–∞–¥–∞–Ω–Ω–æ–µ —á–∏—Å–ª–æ: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!("–í–≤–µ–¥–∏—Ç–µ —Å–≤–æ—é –¥–æ–≥–∞–¥–∫—É.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–µ—Å—Ç—å –≤–≤–æ–¥.");
</span><span class="boring">
</span>        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };
<span class="boring">
</span><span class="boring">        println!("–í—ã –ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏–ª–∏: {guess}");
</span><span class="boring">
</span><span class="boring">        // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
</span><span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!("–°–ª–∏—à–∫–æ–º –º–∞–ª–µ–Ω—å–∫–æ–µ!"),
</span><span class="boring">            Ordering::Greater =&gt; println!("–°–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–µ!"),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!("–í—ã –ø–æ–±–µ–¥–∏–ª–∏!");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>At the time, we skipped over some details in this code. In <a href="ch06-02-match.html#the-match-control-flow-operator">‚ÄúThe <code>match</code> Control Flow Operator‚Äù</a><!-- ignore --> in Chapter 6, we discussed that <code>match</code> arms must all return the same type. So, for example, the following code doesn‚Äôt work:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let guess = "3";
</span>    let guess = match guess.trim().parse() {
        Ok(_) =&gt; 5,
        Err(_) =&gt; "hello",
    };
<span class="boring">}</span></code></pre>
<p>The type of <code>guess</code> in this code would have to be an integer <em>and</em> a string, and Rust requires that <code>guess</code> have only one type. So what does <code>continue</code> return? How were we allowed to return a <code>u32</code> from one arm and have another arm that ends with <code>continue</code> in Listing 20-27?</p>
<p>As you might have guessed, <code>continue</code> has a <code>!</code> value. That is, when Rust computes the type of <code>guess</code>, it looks at both match arms, the former with a value of <code>u32</code> and the latter with a <code>!</code> value. Because <code>!</code> can never have a value, Rust decides that the type of <code>guess</code> is <code>u32</code>.</p>
<p>The formal way of describing this behavior is that expressions of type <code>!</code> can be coerced into any other type. We‚Äôre allowed to end this <code>match</code> arm with <code>continue</code> because <code>continue</code> doesn‚Äôt return a value; instead, it moves control back to the top of the loop, so in the <code>Err</code> case, we never assign a value to <code>guess</code>.</p>
<p>The never type is useful with the <code>panic!</code> macro as well. Recall the <code>unwrap</code> function that we call on <code>Option&lt;T&gt;</code> values to produce a value or panic with this definition:</p>
<pre><code class="language-rust ignore"><span class="boring">enum Option&lt;T&gt; {
</span><span class="boring">    Some(T),
</span><span class="boring">    None,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::Option::*;
</span><span class="boring">
</span>impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!("called `Option::unwrap()` on a `None` value"),
        }
    }
}</code></pre>
<p>In this code, the same thing happens as in the <code>match</code> in Listing 20-27: Rust sees that <code>val</code> has the type <code>T</code> and <code>panic!</code> has the type <code>!</code>, so the result of the overall <code>match</code> expression is <code>T</code>. This code works because <code>panic!</code> doesn‚Äôt produce a value; it ends the program. In the <code>None</code> case, we won‚Äôt be returning a value from <code>unwrap</code>, so this code is valid.</p>
<p>One final expression that has the type <code>!</code> is a <code>loop</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    print!("forever ");

    loop {
        print!("and ever ");
    }
<span class="boring">}</span></code></pre>
<p>Here, the loop never ends, so <code>!</code> is the value of the expression. However, this wouldn‚Äôt be true if we included a <code>break</code>, because the loop would terminate when it got to the <code>break</code>.</p>
<h3 id="dynamically-sized-types-and-the-sized-trait"><a class="header" href="#dynamically-sized-types-and-the-sized-trait">Dynamically Sized Types and the <code>Sized</code> Trait</a></h3>
<p>Rust needs to know certain details about its types, such as how much space to allocate for a value of a particular type. This leaves one corner of its type system a little confusing at first: the concept of <em>dynamically sized types</em>. Sometimes referred to as <em>DSTs</em> or <em>unsized types</em>, these types let us write code using values whose size we can know only at runtime.</p>
<p>Let‚Äôs dig into the details of a dynamically sized type called <code>str</code>, which we‚Äôve been using throughout the book. That‚Äôs right, not <code>&amp;str</code>, but <code>str</code> on its own, is a DST. We can‚Äôt know how long the string is until runtime, meaning we can‚Äôt create a variable of type <code>str</code>, nor can we take an argument of type <code>str</code>. Consider the following code, which does not work:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1: str = "Hello there!";
    let s2: str = "How's it going?";
<span class="boring">}</span></code></pre>
<p>Rust needs to know how much memory to allocate for any value of a particular type, and all values of a type must use the same amount of memory. If Rust allowed us to write this code, these two <code>str</code> values would need to take up the same amount of space. But they have different lengths: <code>s1</code> needs 12 bytes of storage and <code>s2</code> needs 15. This is why it‚Äôs not possible to create a variable holding a dynamically sized type.</p>
<p>So what do we do? In this case, you already know the answer: we make the types of <code>s1</code> and <code>s2</code> a <code>&amp;str</code> rather than a <code>str</code>. Recall from <a href="ch04-03-slices.html#string-slices">‚ÄúString Slices‚Äù</a><!-- ignore --> in Chapter 4 that the slice data structure just stores the starting position and the length of the slice. So although a <code>&amp;T</code> is a single value that stores the memory address of where the <code>T</code> is located, a <code>&amp;str</code> is <em>two</em> values: the address of the <code>str</code> and its length. As such, we can know the size of a <code>&amp;str</code> value at compile time: it‚Äôs twice the length of a <code>usize</code>. That is, we always know the size of a <code>&amp;str</code>, no matter how long the string it refers to is. In general, this is the way in which dynamically sized types are used in Rust: they have an extra bit of metadata that stores the size of the dynamic information. The golden rule of dynamically sized types is that we must always put values of dynamically sized types behind a pointer of some kind.</p>
<p>We can combine <code>str</code> with all kinds of pointers: for example, <code>Box&lt;str&gt;</code> or <code>Rc&lt;str&gt;</code>. In fact, you‚Äôve seen this before but with a different dynamically sized type: traits. Every trait is a dynamically sized type we can refer to by using the name of the trait. In <a href="ch18-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">‚ÄúUsing Trait Objects That Allow for Values of Different Types‚Äù</a><!-- ignore
--> in Chapter 18, we mentioned that to use traits as trait objects, we must put them behind a pointer, such as <code>&amp;dyn Trait</code> or <code>Box&lt;dyn Trait&gt;</code> (<code>Rc&lt;dyn Trait&gt;</code> would work too).</p>
<p>To work with DSTs, Rust provides the <code>Sized</code> trait to determine whether or not a type‚Äôs size is known at compile time. This trait is automatically implemented for everything whose size is known at compile time. In addition, Rust implicitly adds a bound on <code>Sized</code> to every generic function. That is, a generic function definition like this:</p>
<pre><code class="language-rust ignore">fn generic&lt;T&gt;(t: T) {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
}</code></pre>
<p>is actually treated as though we had written this:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: Sized&gt;(t: T) {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
}</code></pre>
<p>By default, generic functions will work only on types that have a known size at compile time. However, you can use the following special syntax to relax this restriction:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: ?Sized&gt;(t: &amp;T) {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
}</code></pre>
<p>A trait bound on <code>?Sized</code> means ‚Äú<code>T</code> may or may not be <code>Sized</code>‚Äù and this notation overrides the default that generic types must have a known size at compile time. The <code>?Trait</code> syntax with this meaning is only available for <code>Sized</code>, not any other traits.</p>
<p>Also note that we switched the type of the <code>t</code> parameter from <code>T</code> to <code>&amp;T</code>. Because the type might not be <code>Sized</code>, we need to use it behind some kind of pointer. In this case, we‚Äôve chosen a reference.</p>
<p>Next, we‚Äôll talk about functions and closures!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ-—Ñ—É–Ω–∫—Ü–∏–∏-–∏-–∑–∞–º—ã–∫–∞–Ω–∏—è"><a class="header" href="#–ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ-—Ñ—É–Ω–∫—Ü–∏–∏-–∏-–∑–∞–º—ã–∫–∞–Ω–∏—è">–ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∏ –∑–∞–º—ã–∫–∞–Ω–∏—è</a></h2>
<p>This section explores some advanced features related to functions and closures, including function pointers and returning closures.</p>
<h3 id="function-pointers"><a class="header" href="#function-pointers">Function Pointers</a></h3>
<p>We‚Äôve talked about how to pass closures to functions; you can also pass regular functions to functions! This technique is useful when you want to pass a function you‚Äôve already defined rather than defining a new closure. Functions coerce to the type <code>fn</code> (with a lowercase f), not to be confused with the <code>Fn</code> closure trait. The <code>fn</code> type is called a <em>function pointer</em>. Passing functions with function pointers will allow you to use functions as arguments to other functions.</p>
<p>The syntax for specifying that a parameter is a function pointer is similar to that of closures, as shown in Listing 20-28, where we‚Äôve defined a function <code>add_one</code> that adds one to its parameter. The function <code>do_twice</code> takes two parameters: a function pointer to any function that takes an <code>i32</code> parameter and returns an <code>i32</code>, and one <code>i32</code> value. The <code>do_twice</code> function calls the function <code>f</code> twice, passing it the <code>arg</code> value, then adds the two function call results together. The <code>main</code> function calls <code>do_twice</code> with the arguments <code>add_one</code> and <code>5</code>.</p>
<Listing number="20-28" file-name="src/main.rs" caption="Using the `fn` type to accept a function pointer as an argument">
<pre><pre class="playground"><code class="language-rust edition2021">fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!("The answer is: {answer}");
}</code></pre></pre>
</Listing>
<p>This code prints <code>The answer is: 12</code>. We specify that the parameter <code>f</code> in <code>do_twice</code> is an <code>fn</code> that takes one parameter of type <code>i32</code> and returns an <code>i32</code>. We can then call <code>f</code> in the body of <code>do_twice</code>. In <code>main</code>, we can pass the function name <code>add_one</code> as the first argument to <code>do_twice</code>.</p>
<p>Unlike closures, <code>fn</code> is a type rather than a trait, so we specify <code>fn</code> as the parameter type directly rather than declaring a generic type parameter with one of the <code>Fn</code> traits as a trait bound.</p>
<p>Function pointers implement all three of the closure traits (<code>Fn</code>, <code>FnMut</code>, and <code>FnOnce</code>), meaning you can always pass a function pointer as an argument for a function that expects a closure. It‚Äôs best to write functions using a generic type and one of the closure traits so your functions can accept either functions or closures.</p>
<p>That said, one example of where you would want to only accept <code>fn</code> and not closures is when interfacing with external code that doesn‚Äôt have closures: C functions can accept functions as arguments, but C doesn‚Äôt have closures.</p>
<p>As an example of where you could use either a closure defined inline or a named function, let‚Äôs look at a use of the <code>map</code> method provided by the <code>Iterator</code> trait in the standard library. To use the <code>map</code> function to turn a vector of numbers into a vector of strings, we could use a closure, like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(|i| i.to_string()).collect();
<span class="boring">}</span></code></pre></pre>
<p>Or we could name a function as the argument to <code>map</code> instead of the closure, like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(ToString::to_string).collect();
<span class="boring">}</span></code></pre></pre>
<p>Note that we must use the fully qualified syntax that we talked about in <a href="ch20-02-advanced-traits.html#advanced-traits">‚ÄúAdvanced Traits‚Äù</a><!-- ignore --> because there are multiple functions available named <code>to_string</code>. Here, we‚Äôre using the <code>to_string</code> function defined in the <code>ToString</code> trait, which the standard library has implemented for any type that implements <code>Display</code>.</p>
<p>Recall from <a href="ch06-01-defining-an-enum.html#enum-values">‚ÄúEnum values‚Äù</a><!-- ignore --> in Chapter 6 that the name of each enum variant that we define also becomes an initializer function. We can use these initializer functions as function pointers that implement the closure traits, which means we can specify the initializer functions as arguments for methods that take closures, like so:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    enum Status {
        Value(u32),
        Stop,
    }

    let list_of_statuses: Vec&lt;Status&gt; = (0u32..20).map(Status::Value).collect();
<span class="boring">}</span></code></pre></pre>
<p>Here we create <code>Status::Value</code> instances using each <code>u32</code> value in the range that <code>map</code> is called on by using the initializer function of <code>Status::Value</code>. Some people prefer this style, and some people prefer to use closures. They compile to the same code, so use whichever style is clearer to you.</p>
<h3 id="returning-closures"><a class="header" href="#returning-closures">Returning Closures</a></h3>
<p>Closures are represented by traits, which means you can‚Äôt return closures directly. In most cases where you might want to return a trait, you can instead use the concrete type that implements the trait as the return value of the function. However, you can‚Äôt do that with closures because they don‚Äôt have a concrete type that is returnable; you‚Äôre not allowed to use the function pointer <code>fn</code> as a return type, for example.</p>
<p>Instead, you will normally use the <code>impl Trait</code> syntax we learned about in Chapter 10. You can return any function type, using <code>Fn</code>, <code>FnOnce</code> and <code>FnMut</code>. For example, this code will work just fine:</p>
<pre><code class="language-rust ignore does_not_compile">fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {
    |x| x + 1
}</code></pre>
<p>However, as we noted in the <a href="ch13-01-closures.html#closure-type-inference-and-annotation">‚ÄúClosure Type Inference and Annotation‚Äù</a><!-- ignore --> section in Chapter 13, each closure is also its own distinct type. If you need to work with multiple functions that have the same signature but different implementations, you will need to use a trait object for them:</p>
<pre><code class="language-rust noplayground">fn main() {
    let handlers = vec![returns_closure(), returns_initialized_closure(123)];
    for handler in handlers {
        let output = handler(5);
        println!("{output}");
    }
}

fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}

fn returns_initialized_closure(init: i32) -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(move |x| x + init)
}</code></pre>
<p>This code will compile just fine‚Äîbut it wouldn‚Äôt if we had tried to stick with <code>impl Fn(i32) -&gt; i32</code>. For more about trait objects, refer to the section <a href="ch18-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">‚ÄúUsing Trait Objects That Allow for Values of Different Types‚Äù</a><!-- ignore
--> in Chapter 18.</p>
<p>Next, let‚Äôs look at macros!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–ú–∞–∫—Ä–æ—Å—ã"><a class="header" href="#–ú–∞–∫—Ä–æ—Å—ã">–ú–∞–∫—Ä–æ—Å—ã</a></h2>
<p>We‚Äôve used macros like <code>println!</code> throughout this book, but we haven‚Äôt fully explored what a macro is and how it works. The term <em>macro</em> refers to a family of features in Rust: <em>declarative</em> macros with <code>macro_rules!</code> and three kinds of <em>procedural</em> macros:</p>
<ul>
<li>Custom <code>#[derive]</code> macros that specify code added with the <code>derive</code> attribute used on structs and enums</li>
<li>Attribute-like macros that define custom attributes usable on any item</li>
<li>Function-like macros that look like function calls but operate on the tokens specified as their argument</li>
</ul>
<p>We‚Äôll talk about each of these in turn, but first, let‚Äôs look at why we even need macros when we already have functions.</p>
<h3 id="the-difference-between-macros-and-functions"><a class="header" href="#the-difference-between-macros-and-functions">The Difference Between Macros and Functions</a></h3>
<p>Fundamentally, macros are a way of writing code that writes other code, which is known as <em>metaprogramming</em>. In Appendix C, we discuss the <code>derive</code> attribute, which generates an implementation of various traits for you. We‚Äôve also used the <code>println!</code> and <code>vec!</code> macros throughout the book. All of these macros <em>expand</em> to produce more code than the code you‚Äôve written manually.</p>
<p>Metaprogramming is useful for reducing the amount of code you have to write and maintain, which is also one of the roles of functions. However, macros have some additional powers that functions don‚Äôt.</p>
<p>A function signature must declare the number and type of parameters the function has. Macros, on the other hand, can take a variable number of parameters: we can call <code>println!("hello")</code> with one argument or <code>println!("hello {}", name)</code> with two arguments. Also, macros are expanded before the compiler interprets the meaning of the code, so a macro can, for example, implement a trait on a given type. A function can‚Äôt, because it gets called at runtime and a trait needs to be implemented at compile time.</p>
<p>The downside to implementing a macro instead of a function is that macro definitions are more complex than function definitions because you‚Äôre writing Rust code that writes Rust code. Due to this indirection, macro definitions are generally more difficult to read, understand, and maintain than function definitions.</p>
<p>Another important difference between macros and functions is that you must define macros or bring them into scope <em>before</em> you call them in a file, as opposed to functions you can define anywhere and call anywhere.</p>
<h3 id="declarative-macros-with-macro_rules-for-general-metaprogramming"><a class="header" href="#declarative-macros-with-macro_rules-for-general-metaprogramming">Declarative Macros with <code>macro_rules!</code> for General Metaprogramming</a></h3>
<p>The most widely used form of macros in Rust is the <em>declarative macro</em>. These are also sometimes referred to as ‚Äúmacros by example,‚Äù ‚Äú<code>macro_rules!</code> macros,‚Äù or just plain ‚Äúmacros.‚Äù At their core, declarative macros allow you to write something similar to a Rust <code>match</code> expression. As discussed in Chapter 6, <code>match</code> expressions are control structures that take an expression, compare the resulting value of the expression to patterns, and then run the code associated with the matching pattern. Macros also compare a value to patterns that are associated with particular code: in this situation, the value is the literal Rust source code passed to the macro; the patterns are compared with the structure of that source code; and the code associated with each pattern, when matched, replaces the code passed to the macro. This all happens during compilation.</p>
<p>To define a macro, you use the <code>macro_rules!</code> construct. Let‚Äôs explore how to use <code>macro_rules!</code> by looking at how the <code>vec!</code> macro is defined. Chapter 8 covered how we can use the <code>vec!</code> macro to create a new vector with particular values. For example, the following macro creates a new vector containing three integers:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;u32&gt; = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<p>We could also use the <code>vec!</code> macro to make a vector of two integers or a vector of five string slices. We wouldn‚Äôt be able to use a function to do the same because we wouldn‚Äôt know the number or type of values up front.</p>
<p>Listing 20-29 shows a slightly simplified definition of the <code>vec!</code> macro.</p>
<Listing number="20-29" file-name="src/lib.rs" caption="A simplified version of the `vec!` macro definition">
<pre><code class="language-rust noplayground">#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}</code></pre>
</Listing>
<blockquote>
<p>Note: The actual definition of the <code>vec!</code> macro in the standard library includes code to preallocate the correct amount of memory up front. That code is an optimization that we don‚Äôt include here to make the example simpler.</p>
</blockquote>
<p>The <code>#[macro_export]</code> annotation indicates that this macro should be made available whenever the crate in which the macro is defined is brought into scope. Without this annotation, the macro can‚Äôt be brought into scope.</p>
<p>We then start the macro definition with <code>macro_rules!</code> and the name of the macro we‚Äôre defining <em>without</em> the exclamation mark. The name, in this case <code>vec</code>, is followed by curly brackets denoting the body of the macro definition.</p>
<p>The structure in the <code>vec!</code> body is similar to the structure of a <code>match</code> expression. Here we have one arm with the pattern <code>( $( $x:expr ),* )</code>, followed by <code>=&gt;</code> and the block of code associated with this pattern. If the pattern matches, the associated block of code will be emitted. Given that this is the only pattern in this macro, there is only one valid way to match; any other pattern will result in an error. More complex macros will have more than one arm.</p>
<p>Valid pattern syntax in macro definitions is different than the pattern syntax covered in Chapter 19 because macro patterns are matched against Rust code structure rather than values. Let‚Äôs walk through what the pattern pieces in Listing 20-29 mean; for the full macro pattern syntax, see the <a href="../reference/macros-by-example.html">Rust Reference</a>.</p>
<p>First, we use a set of parentheses to encompass the whole pattern. We use a dollar sign (<code>$</code>) to declare a variable in the macro system that will contain the Rust code matching the pattern. The dollar sign makes it clear this is a macro variable as opposed to a regular Rust variable. Next comes a set of parentheses that captures values that match the pattern within the parentheses for use in the replacement code. Within <code>$()</code> is <code>$x:expr</code>, which matches any Rust expression and gives the expression the name <code>$x</code>.</p>
<p>The comma following <code>$()</code> indicates that a literal comma separator character must appear between each instance of the code that matches the code within <code>$()</code>. The <code>*</code> specifies that the pattern matches zero or more of whatever precedes the <code>*</code>.</p>
<p>When we call this macro with <code>vec![1, 2, 3];</code>, the <code>$x</code> pattern matches three times with the three expressions <code>1</code>, <code>2</code>, and <code>3</code>.</p>
<p>Now let‚Äôs look at the pattern in the body of the code associated with this arm: <code>temp_vec.push()</code> within <code>$()*</code> is generated for each part that matches <code>$()</code> in the pattern zero or more times depending on how many times the pattern matches. The <code>$x</code> is replaced with each expression matched. When we call this macro with <code>vec![1, 2, 3];</code>, the code generated that replaces this macro call will be the following:</p>
<pre><code class="language-rust ignore">{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}</code></pre>
<p>We‚Äôve defined a macro that can take any number of arguments of any type and can generate code to create a vector containing the specified elements.</p>
<p>To learn more about how to write macros, consult the online documentation or other resources, such as <a href="https://veykril.github.io/tlborm/">‚ÄúThe Little Book of Rust Macros‚Äù</a> started by Daniel Keep and continued by Lukas Wirth.</p>
<h3 id="procedural-macros-for-generating-code-from-attributes"><a class="header" href="#procedural-macros-for-generating-code-from-attributes">Procedural Macros for Generating Code from Attributes</a></h3>
<p>The second form of macros is the <em>procedural macro</em>, which acts more like a function (and is a type of procedure). Procedural macros accept some code as an input, operate on that code, and produce some code as an output rather than matching against patterns and replacing the code with other code as declarative macros do. The three kinds of procedural macros are custom derive, attribute-like, and function-like, and all work in a similar fashion.</p>
<p>When creating procedural macros, the definitions must reside in their own crate with a special crate type. This is for complex technical reasons that we hope to eliminate in the future. In Listing 20-30, we show how to define a procedural macro, where <code>some_attribute</code> is a placeholder for using a specific macro variety.</p>
<Listing number="20-30" file-name="src/lib.rs" caption="An example of defining a procedural macro">
<pre><code class="language-rust ignore">use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -&gt; TokenStream {
}</code></pre>
</Listing>
<p>The function that defines a procedural macro takes a <code>TokenStream</code> as an input and produces a <code>TokenStream</code> as an output. The <code>TokenStream</code> type is defined by the <code>proc_macro</code> crate that is included with Rust and represents a sequence of tokens. This is the core of the macro: the source code that the macro is operating on makes up the input <code>TokenStream</code>, and the code the macro produces is the output <code>TokenStream</code>. The function also has an attribute attached to it that specifies which kind of procedural macro we‚Äôre creating. We can have multiple kinds of procedural macros in the same crate.</p>
<p>Let‚Äôs look at the different kinds of procedural macros. We‚Äôll start with a custom derive macro and then explain the small dissimilarities that make the other forms different.</p>
<h3 id="how-to-write-a-custom-derive-macro"><a class="header" href="#how-to-write-a-custom-derive-macro">How to Write a Custom <code>derive</code> Macro</a></h3>
<p>Let‚Äôs create a crate named <code>hello_macro</code> that defines a trait named <code>HelloMacro</code> with one associated function named <code>hello_macro</code>. Rather than making our users implement the <code>HelloMacro</code> trait for each of their types, we‚Äôll provide a procedural macro so users can annotate their type with <code>#[derive(HelloMacro)]</code> to get a default implementation of the <code>hello_macro</code> function. The default implementation will print <code>Hello, Macro! My name is TypeName!</code> where <code>TypeName</code> is the name of the type on which this trait has been defined. In other words, we‚Äôll write a crate that enables another programmer to write code like Listing 20-31 using our crate.</p>
<Listing number="20-31" file-name="src/main.rs" caption="The code a user of our crate will be able to write when using our procedural macro">
<pre><code class="language-rust ignore does_not_compile">use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}</code></pre>
</Listing>
<p>This code will print <code>Hello, Macro! My name is Pancakes!</code> when we‚Äôre done. The first step is to make a new library crate, like this:</p>
<pre><code class="language-console">$ cargo new hello_macro --lib
</code></pre>
<p>Next, we‚Äôll define the <code>HelloMacro</code> trait and its associated function:</p>
<Listing file-name="src/lib.rs">
<pre><code class="language-rust noplayground">pub trait HelloMacro {
    fn hello_macro();
}</code></pre>
</Listing>
<p>We have a trait and its function. At this point, our crate user could implement the trait to achieve the desired functionality, like so:</p>
<pre><code class="language-rust ignore">use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!("Hello, Macro! My name is Pancakes!");
    }
}

fn main() {
    Pancakes::hello_macro();
}</code></pre>
<p>However, they would need to write the implementation block for each type they wanted to use with <code>hello_macro</code>; we want to spare them from having to do this work.</p>
<p>Additionally, we can‚Äôt yet provide the <code>hello_macro</code> function with default implementation that will print the name of the type the trait is implemented on: Rust doesn‚Äôt have reflection capabilities, so it can‚Äôt look up the type‚Äôs name at runtime. We need a macro to generate code at compile time.</p>
<p>The next step is to define the procedural macro. At the time of this writing, procedural macros need to be in their own crate. Eventually, this restriction might be lifted. The convention for structuring crates and macro crates is as follows: for a crate named <code>foo</code>, a custom derive procedural macro crate is called <code>foo_derive</code>. Let‚Äôs start a new crate called <code>hello_macro_derive</code> inside our <code>hello_macro</code> project:</p>
<pre><code class="language-console">$ cargo new hello_macro_derive --lib
</code></pre>
<p>Our two crates are tightly related, so we create the procedural macro crate within the directory of our <code>hello_macro</code> crate. If we change the trait definition in <code>hello_macro</code>, we‚Äôll have to change the implementation of the procedural macro in <code>hello_macro_derive</code> as well. The two crates will need to be published separately, and programmers using these crates will need to add both as dependencies and bring them both into scope. We could instead have the <code>hello_macro</code> crate use <code>hello_macro_derive</code> as a dependency and re-export the procedural macro code. However, the way we‚Äôve structured the project makes it possible for programmers to use <code>hello_macro</code> even if they don‚Äôt want the <code>derive</code> functionality.</p>
<p>We need to declare the <code>hello_macro_derive</code> crate as a procedural macro crate. We‚Äôll also need functionality from the <code>syn</code> and <code>quote</code> crates, as you‚Äôll see in a moment, so we need to add them as dependencies. Add the following to the <em>Cargo.toml</em> file for <code>hello_macro_derive</code>:</p>
<Listing file-name="hello_macro_derive/Cargo.toml">
<pre><code class="language-toml">[lib]
proc-macro = true

[dependencies]
syn = "2.0"
quote = "1.0"
</code></pre>
</Listing>
<p>To start defining the procedural macro, place the code in Listing 20-32 into your <em>src/lib.rs</em> file for the <code>hello_macro_derive</code> crate. Note that this code won‚Äôt compile until we add a definition for the <code>impl_hello_macro</code> function.</p>
<Listing number="20-32" file-name="hello_macro_derive/src/lib.rs" caption="Code that most procedural macro crates will require in order to process Rust code">
<pre><code class="language-rust ignore does_not_compile">use proc_macro::TokenStream;
use quote::quote;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
    // Construct a representation of Rust code as a syntax tree
    // that we can manipulate.
    let ast = syn::parse(input).unwrap();

    // Build the trait implementation.
    impl_hello_macro(&amp;ast)
}</code></pre>
</Listing>
<p>Notice that we‚Äôve split the code into the <code>hello_macro_derive</code> function, which is responsible for parsing the <code>TokenStream</code>, and the <code>impl_hello_macro</code> function, which is responsible for transforming the syntax tree: this makes writing a procedural macro more convenient. The code in the outer function (<code>hello_macro_derive</code> in this case) will be the same for almost every procedural macro crate you see or create. The code you specify in the body of the inner function (<code>impl_hello_macro</code> in this case) will be different depending on your procedural macro‚Äôs purpose.</p>
<p>We‚Äôve introduced three new crates: <code>proc_macro</code>, <a href="https://crates.io/crates/syn"><code>syn</code></a>, and <a href="https://crates.io/crates/quote"><code>quote</code></a>. The <code>proc_macro</code> crate comes with Rust, so we didn‚Äôt need to add that to the dependencies in <em>Cargo.toml</em>. The <code>proc_macro</code> crate is the compiler‚Äôs API that allows us to read and manipulate Rust code from our code.</p>
<p>The <code>syn</code> crate parses Rust code from a string into a data structure that we can perform operations on. The <code>quote</code> crate turns <code>syn</code> data structures back into Rust code. These crates make it much simpler to parse any sort of Rust code we might want to handle: writing a full parser for Rust code is no simple task.</p>
<p>The <code>hello_macro_derive</code> function will be called when a user of our library specifies <code>#[derive(HelloMacro)]</code> on a type. This is possible because we‚Äôve annotated the <code>hello_macro_derive</code> function here with <code>proc_macro_derive</code> and specified the name <code>HelloMacro</code>, which matches our trait name; this is the convention most procedural macros follow.</p>
<p>The <code>hello_macro_derive</code> function first converts the <code>input</code> from a <code>TokenStream</code> to a data structure that we can then interpret and perform operations on. This is where <code>syn</code> comes into play. The <code>parse</code> function in <code>syn</code> takes a <code>TokenStream</code> and returns a <code>DeriveInput</code> struct representing the parsed Rust code. Listing 20-33 shows the relevant parts of the <code>DeriveInput</code> struct we get from parsing the <code>struct Pancakes;</code> string:</p>
<Listing number="20-33" caption="The `DeriveInput` instance we get when parsing the code that has the macro‚Äôs attribute in Listing 20-31">
<pre><code class="language-rust ignore">DeriveInput {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--

    ident: Ident {
        ident: "Pancakes",
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}</code></pre>
</Listing>
<p>The fields of this struct show that the Rust code we‚Äôve parsed is a unit struct with the <code>ident</code> (identifier, meaning the name) of <code>Pancakes</code>. There are more fields on this struct for describing all sorts of Rust code; check the <a href="https://docs.rs/syn/2.0/syn/struct.DeriveInput.html"><code>syn</code> documentation for <code>DeriveInput</code></a> for more information.</p>
<p>Soon we‚Äôll define the <code>impl_hello_macro</code> function, which is where we‚Äôll build the new Rust code we want to include. But before we do, note that the output for our derive macro is also a <code>TokenStream</code>. The returned <code>TokenStream</code> is added to the code that our crate users write, so when they compile their crate, they‚Äôll get the extra functionality that we provide in the modified <code>TokenStream</code>.</p>
<p>You might have noticed that we‚Äôre calling <code>unwrap</code> to cause the <code>hello_macro_derive</code> function to panic if the call to the <code>syn::parse</code> function fails here. It‚Äôs necessary for our procedural macro to panic on errors because <code>proc_macro_derive</code> functions must return <code>TokenStream</code> rather than <code>Result</code> to conform to the procedural macro API. We‚Äôve simplified this example by using <code>unwrap</code>; in production code, you should provide more specific error messages about what went wrong by using <code>panic!</code> or <code>expect</code>.</p>
<p>Now that we have the code to turn the annotated Rust code from a <code>TokenStream</code> into a <code>DeriveInput</code> instance, let‚Äôs generate the code that implements the <code>HelloMacro</code> trait on the annotated type, as shown in Listing 20-34.</p>
<Listing number="20-34" file-name="hello_macro_derive/src/lib.rs" caption="Implementing the `HelloMacro` trait using the parsed Rust code">
<pre><code class="language-rust ignore"><span class="boring">use proc_macro::TokenStream;
</span><span class="boring">use quote::quote;
</span><span class="boring">
</span><span class="boring">#[proc_macro_derive(HelloMacro)]
</span><span class="boring">pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
</span><span class="boring">    // Construct a representation of Rust code as a syntax tree
</span><span class="boring">    // that we can manipulate
</span><span class="boring">    let ast = syn::parse(input).unwrap();
</span><span class="boring">
</span><span class="boring">    // Build the trait implementation
</span><span class="boring">    impl_hello_macro(&amp;ast)
</span><span class="boring">}
</span><span class="boring">
</span>fn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; TokenStream {
    let name = &amp;ast.ident;
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Hello, Macro! My name is {}!", stringify!(#name));
            }
        }
    };
    gen.into()
}</code></pre>
</Listing>
<p>We get an <code>Ident</code> struct instance containing the name (identifier) of the annotated type using <code>ast.ident</code>. The struct in Listing 20-33 shows that when we run the <code>impl_hello_macro</code> function on the code in Listing 20-31, the <code>ident</code> we get will have the <code>ident</code> field with a value of <code>"Pancakes"</code>. Thus, the <code>name</code> variable in Listing 20-34 will contain an <code>Ident</code> struct instance that, when printed, will be the string <code>"Pancakes"</code>, the name of the struct in Listing 20-31.</p>
<p>The <code>quote!</code> macro lets us define the Rust code that we want to return. The compiler expects something different to the direct result of the <code>quote!</code> macro‚Äôs execution, so we need to convert it to a <code>TokenStream</code>. We do this by calling the <code>into</code> method, which consumes this intermediate representation and returns a value of the required <code>TokenStream</code> type.</p>
<p>The <code>quote!</code> macro also provides some very cool templating mechanics: we can enter <code>#name</code>, and <code>quote!</code> will replace it with the value in the variable <code>name</code>. You can even do some repetition similar to the way regular macros work. Check out <a href="https://docs.rs/quote">the <code>quote</code> crate‚Äôs docs</a> for a thorough introduction.</p>
<p>We want our procedural macro to generate an implementation of our <code>HelloMacro</code> trait for the type the user annotated, which we can get by using <code>#name</code>. The trait implementation has the one function <code>hello_macro</code>, whose body contains the functionality we want to provide: printing <code>Hello, Macro! My name is</code> and then the name of the annotated type.</p>
<p>The <code>stringify!</code> macro used here is built into Rust. It takes a Rust expression, such as <code>1 + 2</code>, and at compile time turns the expression into a string literal, such as <code>"1 + 2"</code>. This is different than <code>format!</code> or <code>println!</code>, macros which evaluate the expression and then turn the result into a <code>String</code>. There is a possibility that the <code>#name</code> input might be an expression to print literally, so we use <code>stringify!</code>. Using <code>stringify!</code> also saves an allocation by converting <code>#name</code> to a string literal at compile time.</p>
<p>At this point, <code>cargo build</code> should complete successfully in both <code>hello_macro</code> and <code>hello_macro_derive</code>. Let‚Äôs hook up these crates to the code in Listing 20-31 to see the procedural macro in action! Create a new binary project in your <em>projects</em> directory using <code>cargo new pancakes</code>. We need to add <code>hello_macro</code> and <code>hello_macro_derive</code> as dependencies in the <code>pancakes</code> crate‚Äôs <em>Cargo.toml</em>. If you‚Äôre publishing your versions of <code>hello_macro</code> and <code>hello_macro_derive</code> to <a href="https://crates.io/">crates.io</a>, they would be regular dependencies; if not, you can specify them as <code>path</code> dependencies as follows:</p>
<pre><code class="language-toml">hello_macro = { path = "../hello_macro" }
hello_macro_derive = { path = "../hello_macro/hello_macro_derive" }
</code></pre>
<p>Put the code in Listing 20-31 into <em>src/main.rs</em>, and run <code>cargo run</code>: it should print <code>Hello, Macro! My name is Pancakes!</code> The implementation of the <code>HelloMacro</code> trait from the procedural macro was included without the <code>pancakes</code> crate needing to implement it; the <code>#[derive(HelloMacro)]</code> added the trait implementation.</p>
<p>Next, let‚Äôs explore how the other kinds of procedural macros differ from custom derive macros.</p>
<h3 id="attribute-like-macros"><a class="header" href="#attribute-like-macros">Attribute-Like macros</a></h3>
<p>Attribute-like macros are similar to custom derive macros, but instead of generating code for the <code>derive</code> attribute, they allow you to create new attributes. They‚Äôre also more flexible: <code>derive</code> only works for structs and enums; attributes can be applied to other items as well, such as functions. Here‚Äôs an example of using an attribute-like macro: say you have an attribute named <code>route</code> that annotates functions when using a web application framework:</p>
<pre><code class="language-rust ignore">#[route(GET, "/")]
fn index() {</code></pre>
<p>This <code>#[route]</code> attribute would be defined by the framework as a procedural macro. The signature of the macro definition function would look like this:</p>
<pre><code class="language-rust ignore">#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -&gt; TokenStream {</code></pre>
<p>Here, we have two parameters of type <code>TokenStream</code>. The first is for the contents of the attribute: the <code>GET, "/"</code> part. The second is the body of the item the attribute is attached to: in this case, <code>fn index() {}</code> and the rest of the function‚Äôs body.</p>
<p>Other than that, attribute-like macros work the same way as custom derive macros: you create a crate with the <code>proc-macro</code> crate type and implement a function that generates the code you want!</p>
<h3 id="function-like-macros"><a class="header" href="#function-like-macros">Function-Like macros</a></h3>
<p>Function-like macros define macros that look like function calls. Similarly to <code>macro_rules!</code> macros, they‚Äôre more flexible than functions; for example, they can take an unknown number of arguments. However, <code>macro_rules!</code> macros can only be defined using the match-like syntax we discussed in <a href="ch20-05-macros.html#declarative-macros-with-macro_rules-for-general-metaprogramming">‚ÄúDeclarative Macros with <code>macro_rules!</code> for General Metaprogramming‚Äù</a><!-- ignore --> earlier. Function-like macros take a <code>TokenStream</code> parameter and their definition manipulates that <code>TokenStream</code> using Rust code as the other two types of procedural macros do. An example of a function-like macro is an <code>sql!</code> macro that might be called like so:</p>
<pre><code class="language-rust ignore">let sql = sql!(SELECT * FROM posts WHERE id=1);</code></pre>
<p>This macro would parse the SQL statement inside it and check that it‚Äôs syntactically correct, which is much more complex processing than a <code>macro_rules!</code> macro can do. The <code>sql!</code> macro would be defined like this:</p>
<pre><code class="language-rust ignore">#[proc_macro]
pub fn sql(input: TokenStream) -&gt; TokenStream {</code></pre>
<p>This definition is similar to the custom derive macro‚Äôs signature: we receive the tokens that are inside the parentheses and return the code we wanted to generate.</p>
<h2 id="–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-19"><a class="header" href="#–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-19">–ü–æ–¥–≤–µ–¥—ë–º –∏—Ç–æ–≥–∏</a></h2>
<p>Whew! Now you have some Rust features in your toolbox that you likely won‚Äôt use often, but you‚Äôll know they‚Äôre available in very particular circumstances. We‚Äôve introduced several complex topics so that when you encounter them in error message suggestions or in other peoples‚Äô code, you‚Äôll be able to recognize these concepts and syntax. Use this chapter as a reference to guide you to solutions.</p>
<p>Next, we‚Äôll put everything we‚Äôve discussed throughout the book into practice and do one more project!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="–ò—Ç–æ–≥–æ–≤—ã–π-–ø—Ä–æ–µ–∫—Ç-—Å–æ–∑–¥–∞–Ω–∏–µ-–º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω–æ–≥–æ-–≤–µ–±-—Å–µ—Ä–≤–µ—Ä–∞"><a class="header" href="#–ò—Ç–æ–≥–æ–≤—ã–π-–ø—Ä–æ–µ–∫—Ç-—Å–æ–∑–¥–∞–Ω–∏–µ-–º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω–æ–≥–æ-–≤–µ–±-—Å–µ—Ä–≤–µ—Ä–∞">–ò—Ç–æ–≥–æ–≤—ã–π –ø—Ä–æ–µ–∫—Ç: —Å–æ–∑–¥–∞–Ω–∏–µ –º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω–æ–≥–æ –≤–µ–±-—Å–µ—Ä–≤–µ—Ä–∞</a></h1>
<p>It‚Äôs been a long journey, but we‚Äôve reached the end of the book. In this chapter, we‚Äôll build one more project together to demonstrate some of the concepts we covered in the final chapters, as well as recap some earlier lessons.</p>
<p>For our final project, we‚Äôll make a web server that says ‚Äúhello‚Äù and looks like Figure 21-1 in a web browser.</p>
<p><img src="img/trpl21-01.png" alt="hello from rust" /></p>
<p><span class="caption">Figure 21-1: Our final shared project</span></p>
<p>Here is our plan for building the web server:</p>
<ol>
<li>Learn a bit about TCP and HTTP.</li>
<li>Listen for TCP connections on a socket.</li>
<li>Parse a small number of HTTP requests.</li>
<li>Create a proper HTTP response.</li>
<li>Improve the throughput of our server with a thread pool.</li>
</ol>
<p>Before we get started, we should mention two details: First, the method we‚Äôll use won‚Äôt be the best way to build a web server with Rust. Community members have published a number of production-ready crates available on <a href="https://crates.io/">crates.io</a> that provide more complete web server and thread pool implementations than we‚Äôll build. However, our intention in this chapter is to help you learn, not to take the easy route. Because Rust is a systems programming language, we can choose the level of abstraction we want to work with and can go to a lower level than is possible or practical in other languages.</p>
<p>Second, we will not be using async and await here. Building a thread pool is a big enough challenge on its own, without adding in building an async runtime! However, we will note how async and await might be applicable to some of the same problems we will see in this chapter. Ultimately, as we noted back in Chapter 17, many async runtimes use thread pools for managing their work.</p>
<p>We‚Äôll therefore write the basic HTTP server and thread pool manually so you can learn the general ideas and techniques behind the crates you might use in the future.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–°–æ–∑–¥–∞–Ω–∏–µ-–æ–¥–Ω–æ–ø–æ—Ç–æ—á–Ω–æ–≥–æ-–≤–µ–±-—Å–µ—Ä–≤–µ—Ä–∞"><a class="header" href="#–°–æ–∑–¥–∞–Ω–∏–µ-–æ–¥–Ω–æ–ø–æ—Ç–æ—á–Ω–æ–≥–æ-–≤–µ–±-—Å–µ—Ä–≤–µ—Ä–∞">–°–æ–∑–¥–∞–Ω–∏–µ –æ–¥–Ω–æ–ø–æ—Ç–æ—á–Ω–æ–≥–æ –≤–µ–±-—Å–µ—Ä–≤–µ—Ä–∞</a></h2>
<p>We‚Äôll start by getting a single-threaded web server working. Before we begin, let‚Äôs look at a quick overview of the protocols involved in building web servers. The details of these protocols are beyond the scope of this book, but a brief overview will give you the information you need.</p>
<p>The two main protocols involved in web servers are <em>Hypertext Transfer Protocol</em> <em>(HTTP)</em> and <em>Transmission Control Protocol</em> <em>(TCP)</em>. Both protocols are <em>request-response</em> protocols, meaning a <em>client</em> initiates requests and a <em>server</em> listens to the requests and provides a response to the client. The contents of those requests and responses are defined by the protocols.</p>
<p>TCP is the lower-level protocol that describes the details of how information gets from one server to another but doesn‚Äôt specify what that information is. HTTP builds on top of TCP by defining the contents of the requests and responses. It‚Äôs technically possible to use HTTP with other protocols, but in the vast majority of cases, HTTP sends its data over TCP. We‚Äôll work with the raw bytes of TCP and HTTP requests and responses.</p>
<h3 id="listening-to-the-tcp-connection"><a class="header" href="#listening-to-the-tcp-connection">Listening to the TCP Connection</a></h3>
<p>Our web server needs to listen to a TCP connection, so that‚Äôs the first part we‚Äôll work on. The standard library offers a <code>std::net</code> module that lets us do this. Let‚Äôs make a new project in the usual fashion:</p>
<pre><code class="language-console">$ cargo new hello
     Created binary (application) `hello` project
$ cd hello
</code></pre>
<p>Now enter the code in Listing 21-1 in <em>src/main.rs</em> to start. This code will listen at the local address <code>127.0.0.1:7878</code> for incoming TCP streams. When it gets an incoming stream, it will print <code>Connection established!</code>.</p>
<Listing number="21-1" file-name="src/main.rs" caption="Listening for incoming streams and printing a message when we receive a stream">
<pre><pre class="playground"><code class="language-rust no_run edition2021">use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        println!("Connection established!");
    }
}</code></pre></pre>
</Listing>
<p>Using <code>TcpListener</code>, we can listen for TCP connections at the address <code>127.0.0.1:7878</code>. In the address, the section before the colon is an IP address representing your computer (this is the same on every computer and doesn‚Äôt represent the authors‚Äô computer specifically), and <code>7878</code> is the port. We‚Äôve chosen this port for two reasons: HTTP isn‚Äôt normally accepted on this port so our server is unlikely to conflict with any other web server you might have running on your machine, and 7878 is <em>rust</em> typed on a telephone.</p>
<p>The <code>bind</code> function in this scenario works like the <code>new</code> function in that it will return a new <code>TcpListener</code> instance. The function is called <code>bind</code> because, in networking, connecting to a port to listen to is known as ‚Äúbinding to a port.‚Äù</p>
<p>The <code>bind</code> function returns a <code>Result&lt;T, E&gt;</code>, which indicates that it‚Äôs possible for binding to fail. For example, connecting to port 80 requires administrator privileges (non-administrators can listen only on ports higher than 1023), so if we tried to connect to port 80 without being an administrator, binding wouldn‚Äôt work. Binding also wouldn‚Äôt work, for example, if we ran two instances of our program and so had two programs listening to the same port. Because we‚Äôre writing a basic server just for learning purposes, we won‚Äôt worry about handling these kinds of errors; instead, we use <code>unwrap</code> to stop the program if errors happen.</p>
<p>The <code>incoming</code> method on <code>TcpListener</code> returns an iterator that gives us a sequence of streams (more specifically, streams of type <code>TcpStream</code>). A single <em>stream</em> represents an open connection between the client and the server. A <em>connection</em> is the name for the full request and response process in which a client connects to the server, the server generates a response, and the server closes the connection. As such, we will read from the <code>TcpStream</code> to see what the client sent and then write our response to the stream to send data back to the client. Overall, this <code>for</code> loop will process each connection in turn and produce a series of streams for us to handle.</p>
<p>For now, our handling of the stream consists of calling <code>unwrap</code> to terminate our program if the stream has any errors; if there aren‚Äôt any errors, the program prints a message. We‚Äôll add more functionality for the success case in the next listing. The reason we might receive errors from the <code>incoming</code> method when a client connects to the server is that we‚Äôre not actually iterating over connections. Instead, we‚Äôre iterating over <em>connection attempts</em>. The connection might not be successful for a number of reasons, many of them operating system specific. For example, many operating systems have a limit to the number of simultaneous open connections they can support; new connection attempts beyond that number will produce an error until some of the open connections are closed.</p>
<p>Let‚Äôs try running this code! Invoke <code>cargo run</code> in the terminal and then load <em>127.0.0.1:7878</em> in a web browser. The browser should show an error message like ‚ÄúConnection reset‚Äù because the server isn‚Äôt currently sending back any data. But when you look at your terminal, you should see several messages that were printed when the browser connected to the server!</p>
<pre><code class="language-text">     Running `target/debug/hello`
Connection established!
Connection established!
Connection established!
</code></pre>
<p>Sometimes you‚Äôll see multiple messages printed for one browser request; the reason might be that the browser is making a request for the page as well as a request for other resources, like the <em>favicon.ico</em> icon that appears in the browser tab.</p>
<p>It could also be that the browser is trying to connect to the server multiple times because the server isn‚Äôt responding with any data. When <code>stream</code> goes out of scope and is dropped at the end of the loop, the connection is closed as part of the <code>drop</code> implementation. Browsers sometimes deal with closed connections by retrying, because the problem might be temporary. The important factor is that we‚Äôve successfully gotten a handle to a TCP connection!</p>
<p>Remember to stop the program by pressing <kbd>ctrl</kbd>-<kbd>c</kbd> when you‚Äôre done running a particular version of the code. Then restart the program by invoking the <code>cargo run</code> command after you‚Äôve made each set of code changes to make sure you‚Äôre running the newest code.</p>
<h3 id="reading-the-request"><a class="header" href="#reading-the-request">Reading the Request</a></h3>
<p>Let‚Äôs implement the functionality to read the request from the browser! To separate the concerns of first getting a connection and then taking some action with the connection, we‚Äôll start a new function for processing connections. In this new <code>handle_connection</code> function, we‚Äôll read data from the TCP stream and print it so we can see the data being sent from the browser. Change the code to look like Listing 21-2.</p>
<Listing number="21-2" file-name="src/main.rs" caption="Reading from the `TcpStream` and printing the data">
<pre><pre class="playground"><code class="language-rust no_run edition2021">use std::{
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
};

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    println!("Request: {http_request:#?}");
}</code></pre></pre>
</Listing>
<p>We bring <code>std::io::prelude</code> and <code>std::io::BufReader</code> into scope to get access to traits and types that let us read from and write to the stream. In the <code>for</code> loop in the <code>main</code> function, instead of printing a message that says we made a connection, we now call the new <code>handle_connection</code> function and pass the <code>stream</code> to it.</p>
<p>In the <code>handle_connection</code> function, we create a new <code>BufReader</code> instance that wraps a reference to the <code>stream</code>. The <code>BufReader</code> adds buffering by managing calls to the <code>std::io::Read</code> trait methods for us.</p>
<p>We create a variable named <code>http_request</code> to collect the lines of the request the browser sends to our server. We indicate that we want to collect these lines in a vector by adding the <code>Vec&lt;_&gt;</code> type annotation.</p>
<p><code>BufReader</code> implements the <code>std::io::BufRead</code> trait, which provides the <code>lines</code> method. The <code>lines</code> method returns an iterator of <code>Result&lt;String, std::io::Error&gt;</code> by splitting the stream of data whenever it sees a newline byte. To get each <code>String</code>, we map and <code>unwrap</code> each <code>Result</code>. The <code>Result</code> might be an error if the data isn‚Äôt valid UTF-8 or if there was a problem reading from the stream. Again, a production program should handle these errors more gracefully, but we‚Äôre choosing to stop the program in the error case for simplicity.</p>
<p>The browser signals the end of an HTTP request by sending two newline characters in a row, so to get one request from the stream, we take lines until we get a line that is the empty string. Once we‚Äôve collected the lines into the vector, we‚Äôre printing them out using pretty debug formatting so we can take a look at the instructions the web browser is sending to our server.</p>
<p>Let‚Äôs try this code! Start the program and make a request in a web browser again. Note that we‚Äôll still get an error page in the browser, but our program‚Äôs output in the terminal will now look similar to this:</p>
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/hello`
Request: [
    "GET / HTTP/1.1",
    "Host: 127.0.0.1:7878",
    "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:99.0) Gecko/20100101 Firefox/99.0",
    "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
    "Accept-Language: en-US,en;q=0.5",
    "Accept-Encoding: gzip, deflate, br",
    "DNT: 1",
    "Connection: keep-alive",
    "Upgrade-Insecure-Requests: 1",
    "Sec-Fetch-Dest: document",
    "Sec-Fetch-Mode: navigate",
    "Sec-Fetch-Site: none",
    "Sec-Fetch-User: ?1",
    "Cache-Control: max-age=0",
]
</code></pre>
<p>Depending on your browser, you might get slightly different output. Now that we‚Äôre printing the request data, we can see why we get multiple connections from one browser request by looking at the path after <code>GET</code> in the first line of the request. If the repeated connections are all requesting <em>/</em>, we know the browser is trying to fetch <em>/</em> repeatedly because it‚Äôs not getting a response from our program.</p>
<p>Let‚Äôs break down this request data to understand what the browser is asking of our program.</p>
<h3 id="a-closer-look-at-an-http-request"><a class="header" href="#a-closer-look-at-an-http-request">A Closer Look at an HTTP Request</a></h3>
<p>HTTP is a text-based protocol, and a request takes this format:</p>
<pre><code class="language-text">Method Request-URI HTTP-Version CRLF
headers CRLF
message-body
</code></pre>
<p>The first line is the <em>request line</em> that holds information about what the client is requesting. The first part of the request line indicates the <em>method</em> being used, such as <code>GET</code> or <code>POST</code>, which describes how the client is making this request. Our client used a <code>GET</code> request, which means it is asking for information.</p>
<p>The next part of the request line is <em>/</em>, which indicates the <em>uniform resource identifier</em> <em>(URI)</em> the client is requesting: a URI is almost, but not quite, the same as a <em>uniform resource locator</em> <em>(URL)</em>. The difference between URIs and URLs isn‚Äôt important for our purposes in this chapter, but the HTTP spec uses the term URI, so we can just mentally substitute <em>URL</em> for <em>URI</em> here.</p>
<p>The last part is the HTTP version the client uses, and then the request line ends in a CRLF sequence. (CRLF stands for <em>carriage return</em> and <em>line feed</em>, which are terms from the typewriter days!) The CRLF sequence can also be written as <code>\r\n</code>, where <code>\r</code> is a carriage return and <code>\n</code> is a line feed. The <em>CRLF sequence</em> separates the request line from the rest of the request data. Note that when the CRLF is printed, we see a new line start rather than <code>\r\n</code>.</p>
<p>Looking at the request line data we received from running our program so far, we see that <code>GET</code> is the method, <em>/</em> is the request URI, and <code>HTTP/1.1</code> is the version.</p>
<p>After the request line, the remaining lines starting from <code>Host:</code> onward are headers. <code>GET</code> requests have no body.</p>
<p>Try making a request from a different browser or asking for a different address, such as <em>127.0.0.1:7878/test</em>, to see how the request data changes.</p>
<p>Now that we know what the browser is asking for, let‚Äôs send back some data!</p>
<h3 id="writing-a-response"><a class="header" href="#writing-a-response">Writing a Response</a></h3>
<p>We‚Äôre going to implement sending data in response to a client request. Responses have the following format:</p>
<pre><code class="language-text">HTTP-Version Status-Code Reason-Phrase CRLF
headers CRLF
message-body
</code></pre>
<p>The first line is a <em>status line</em> that contains the HTTP version used in the response, a numeric status code that summarizes the result of the request, and a reason phrase that provides a text description of the status code. After the CRLF sequence are any headers, another CRLF sequence, and the body of the response.</p>
<p>Here is an example response that uses HTTP version 1.1, and has a status code of 200, an OK reason phrase, no headers, and no body:</p>
<pre><code class="language-text">HTTP/1.1 200 OK\r\n\r\n
</code></pre>
<p>The status code 200 is the standard success response. The text is a tiny successful HTTP response. Let‚Äôs write this to the stream as our response to a successful request! From the <code>handle_connection</code> function, remove the <code>println!</code> that was printing the request data and replace it with the code in Listing 21-3.</p>
<Listing number="21-3" file-name="src/main.rs" caption="Writing a tiny successful HTTP response to the stream">
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">use std::{
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let response = "HTTP/1.1 200 OK\r\n\r\n";

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
</Listing>
<p>The first new line defines the <code>response</code> variable that holds the success message‚Äôs data. Then we call <code>as_bytes</code> on our <code>response</code> to convert the string data to bytes. The <code>write_all</code> method on <code>stream</code> takes a <code>&amp;[u8]</code> and sends those bytes directly down the connection. Because the <code>write_all</code> operation could fail, we use <code>unwrap</code> on any error result as before. Again, in a real application you would add error handling here.</p>
<p>With these changes, let‚Äôs run our code and make a request. We‚Äôre no longer printing any data to the terminal, so we won‚Äôt see any output other than the output from Cargo. When you load <em>127.0.0.1:7878</em> in a web browser, you should get a blank page instead of an error. You‚Äôve just handcoded receiving an HTTP request and sending a response!</p>
<h3 id="returning-real-html"><a class="header" href="#returning-real-html">Returning Real HTML</a></h3>
<p>Let‚Äôs implement the functionality for returning more than a blank page. Create the new file <em>hello.html</em> in the root of your project directory, not in the <em>src</em> directory. You can input any HTML you want; Listing 21-4 shows one possibility.</p>
<Listing number="21-4" file-name="hello.html" caption="A sample HTML file to return in a response">
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello!&lt;/h1&gt;
    &lt;p&gt;Hi from Rust&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
</Listing>
<p>This is a minimal HTML5 document with a heading and some text. To return this from the server when a request is received, we‚Äôll modify <code>handle_connection</code> as shown in Listing 21-5 to read the HTML file, add it to the response as a body, and send it.</p>
<Listing number="21-5" file-name="src/main.rs" caption="Sending the contents of *hello.html* as the body of the response">
<pre><pre class="playground"><code class="language-rust no_run edition2021">use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
};
// --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--

<span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let status_line = "HTTP/1.1 200 OK";
    let contents = fs::read_to_string("hello.html").unwrap();
    let length = contents.len();

    let response =
        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
</Listing>
<p>We‚Äôve added <code>fs</code> to the <code>use</code> statement to bring the standard library‚Äôs filesystem module into scope. The code for reading the contents of a file to a string should look familiar; we used it when we read the contents of a file for our I/O project in Listing 12-4.</p>
<p>Next, we use <code>format!</code> to add the file‚Äôs contents as the body of the success response. To ensure a valid HTTP response, we add the <code>Content-Length</code> header which is set to the size of our response body, in this case the size of <code>hello.html</code>.</p>
<p>Run this code with <code>cargo run</code> and load <em>127.0.0.1:7878</em> in your browser; you should see your HTML rendered!</p>
<p>Currently, we‚Äôre ignoring the request data in <code>http_request</code> and just sending back the contents of the HTML file unconditionally. That means if you try requesting <em>127.0.0.1:7878/something-else</em> in your browser, you‚Äôll still get back this same HTML response. At the moment, our server is very limited and does not do what most web servers do. We want to customize our responses depending on the request and only send back the HTML file for a well-formed request to <em>/</em>.</p>
<h3 id="validating-the-request-and-selectively-responding"><a class="header" href="#validating-the-request-and-selectively-responding">Validating the Request and Selectively Responding</a></h3>
<p>Right now, our web server will return the HTML in the file no matter what the client requested. Let‚Äôs add functionality to check that the browser is requesting <em>/</em> before returning the HTML file and return an error if the browser requests anything else. For this we need to modify <code>handle_connection</code>, as shown in Listing 21-6. This new code checks the content of the request received against what we know a request for <em>/</em> looks like and adds <code>if</code> and <code>else</code> blocks to treat requests differently.</p>
<Listing number="21-6" file-name="src/main.rs" caption="Handling requests to */* differently from other requests">
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>// --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;stream);
    let request_line = buf_reader.lines().next().unwrap().unwrap();

    if request_line == "GET / HTTP/1.1" {
        let status_line = "HTTP/1.1 200 OK";
        let contents = fs::read_to_string("hello.html").unwrap();
        let length = contents.len();

        let response = format!(
            "{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}"
        );

        stream.write_all(response.as_bytes()).unwrap();
    } else {
        // some other request
    }
}</code></pre></pre>
</Listing>
<p>We‚Äôre only going to be looking at the first line of the HTTP request, so rather than reading the entire request into a vector, we‚Äôre calling <code>next</code> to get the first item from the iterator. The first <code>unwrap</code> takes care of the <code>Option</code> and stops the program if the iterator has no items. The second <code>unwrap</code> handles the <code>Result</code> and has the same effect as the <code>unwrap</code> that was in the <code>map</code> added in Listing 21-2.</p>
<p>Next, we check the <code>request_line</code> to see if it equals the request line of a GET request to the <em>/</em> path. If it does, the <code>if</code> block returns the contents of our HTML file.</p>
<p>If the <code>request_line</code> does <em>not</em> equal the GET request to the <em>/</em> path, it means we‚Äôve received some other request. We‚Äôll add code to the <code>else</code> block in a moment to respond to all other requests.</p>
<p>Run this code now and request <em>127.0.0.1:7878</em>; you should get the HTML in <em>hello.html</em>. If you make any other request, such as <em>127.0.0.1:7878/something-else</em>, you‚Äôll get a connection error like those you saw when running the code in Listing 21-1 and Listing 21-2.</p>
<p>Now let‚Äôs add the code in Listing 21-7 to the <code>else</code> block to return a response with the status code 404, which signals that the content for the request was not found. We‚Äôll also return some HTML for a page to render in the browser indicating the response to the end user.</p>
<Listing number="21-7" file-name="src/main.rs" caption="Responding with status code 404 and an error page if anything other than */* was requested">
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    if request_line == "GET / HTTP/1.1" {
</span><span class="boring">        let status_line = "HTTP/1.1 200 OK";
</span><span class="boring">        let contents = fs::read_to_string("hello.html").unwrap();
</span><span class="boring">        let length = contents.len();
</span><span class="boring">
</span><span class="boring">        let response = format!(
</span><span class="boring">            "{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}"
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        stream.write_all(response.as_bytes()).unwrap();
</span>    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
    } else {
        let status_line = "HTTP/1.1 404 NOT FOUND";
        let contents = fs::read_to_string("404.html").unwrap();
        let length = contents.len();

        let response = format!(
            "{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}"
        );

        stream.write_all(response.as_bytes()).unwrap();
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>Here, our response has a status line with status code 404 and the reason phrase <code>NOT FOUND</code>. The body of the response will be the HTML in the file <em>404.html</em>. You‚Äôll need to create a <em>404.html</em> file next to <em>hello.html</em> for the error page; again feel free to use any HTML you want or use the example HTML in Listing 21-8.</p>
<Listing number="21-8" file-name="404.html" caption="Sample content for the page to send back with any 404 response">
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Oops!&lt;/h1&gt;
    &lt;p&gt;Sorry, I don't know what you're asking for.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
</Listing>
<p>With these changes, run your server again. Requesting <em>127.0.0.1:7878</em> should return the contents of <em>hello.html</em>, and any other request, like <em>127.0.0.1:7878/foo</em>, should return the error HTML from <em>404.html</em>.</p>
<h3 id="a-touch-of-refactoring"><a class="header" href="#a-touch-of-refactoring">A Touch of Refactoring</a></h3>
<p>At the moment, the <code>if</code> and <code>else</code> blocks have a lot of repetition: they‚Äôre both reading files and writing the contents of the files to the stream. The only differences are the status line and the filename. Let‚Äôs make the code more concise by pulling out those differences into separate <code>if</code> and <code>else</code> lines that will assign the values of the status line and the filename to variables; we can then use those variables unconditionally in the code to read the file and write the response. Listing 21-9 shows the resultant code after replacing the large <code>if</code> and <code>else</code> blocks.</p>
<Listing number="21-9" file-name="src/main.rs" caption="Refactoring the `if` and `else` blocks to contain only the code that differs between the two cases">
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>// --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--

fn handle_connection(mut stream: TcpStream) {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span>
    let (status_line, filename) = if request_line == "GET / HTTP/1.1" {
        ("HTTP/1.1 200 OK", "hello.html")
    } else {
        ("HTTP/1.1 404 NOT FOUND", "404.html")
    };

    let contents = fs::read_to_string(filename).unwrap();
    let length = contents.len();

    let response =
        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
</Listing>
<p>Now the <code>if</code> and <code>else</code> blocks only return the appropriate values for the status line and filename in a tuple; we then use destructuring to assign these two values to <code>status_line</code> and <code>filename</code> using a pattern in the <code>let</code> statement, as discussed in Chapter 19.</p>
<p>The previously duplicated code is now outside the <code>if</code> and <code>else</code> blocks and uses the <code>status_line</code> and <code>filename</code> variables. This makes it easier to see the difference between the two cases, and it means we have only one place to update the code if we want to change how the file reading and response writing work. The behavior of the code in Listing 21-9 will be the same as that in Listing 21-7.</p>
<p>Awesome! We now have a simple web server in approximately 40 lines of Rust code that responds to one request with a page of content and responds to all other requests with a 404 response.</p>
<p>Currently, our server runs in a single thread, meaning it can only serve one request at a time. Let‚Äôs examine how that can be a problem by simulating some slow requests. Then we‚Äôll fix it so our server can handle multiple requests at once.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–ü—Ä–µ–≤—Ä–∞—â–µ–Ω–∏–µ-–Ω–∞—à–µ–≥–æ-–æ–¥–Ω–æ–ø–æ—Ç–æ—á–Ω–æ–≥–æ-—Å–µ—Ä–≤–µ—Ä–∞-–≤-–º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω—ã–π"><a class="header" href="#–ü—Ä–µ–≤—Ä–∞—â–µ–Ω–∏–µ-–Ω–∞—à–µ–≥–æ-–æ–¥–Ω–æ–ø–æ—Ç–æ—á–Ω–æ–≥–æ-—Å–µ—Ä–≤–µ—Ä–∞-–≤-–º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω—ã–π">–ü—Ä–µ–≤—Ä–∞—â–µ–Ω–∏–µ –Ω–∞—à–µ–≥–æ –æ–¥–Ω–æ–ø–æ—Ç–æ—á–Ω–æ–≥–æ —Å–µ—Ä–≤–µ—Ä–∞ –≤ –º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω—ã–π</a></h2>
<p>Right now, the server will process each request in turn, meaning it won‚Äôt process a second connection until the first is finished processing. If the server received more and more requests, this serial execution would be less and less optimal. If the server receives a request that takes a long time to process, subsequent requests will have to wait until the long request is finished, even if the new requests can be processed quickly. We‚Äôll need to fix this, but first we‚Äôll look at the problem in action.</p>
<h3 id="simulating-a-slow-request-in-the-current-server-implementation"><a class="header" href="#simulating-a-slow-request-in-the-current-server-implementation">Simulating a Slow Request in the Current Server Implementation</a></h3>
<p>We‚Äôll look at how a slow-processing request can affect other requests made to our current server implementation. Listing 21-10 implements handling a request to <em>/sleep</em> with a simulated slow response that will cause the server to sleep for five seconds before responding.</p>
<Listing number="21-10" file-name="src/main.rs" caption="Simulating a slow request by sleeping for 5 seconds">
<pre><pre class="playground"><code class="language-rust no_run edition2021">use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
    thread,
    time::Duration,
};
// --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn handle_connection(mut stream: TcpStream) {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--

<span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span>    let (status_line, filename) = match &amp;request_line[..] {
        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
        "GET /sleep HTTP/1.1" =&gt; {
            thread::sleep(Duration::from_secs(5));
            ("HTTP/1.1 200 OK", "hello.html")
        }
        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
    };

    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span>}</code></pre></pre>
</Listing>
<p>We switched from <code>if</code> to <code>match</code> now that we have three cases. We need to explicitly match on a slice of <code>request_line</code> to pattern match against the string literal values; <code>match</code> doesn‚Äôt do automatic referencing and dereferencing, like the equality method does.</p>
<p>The first arm is the same as the <code>if</code> block from Listing 21-9. The second arm matches a request to <em>/sleep</em>. When that request is received, the server will sleep for five seconds before rendering the successful HTML page. The third arm is the same as the <code>else</code> block from Listing 21-9.</p>
<p>You can see how primitive our server is: real libraries would handle the recognition of multiple requests in a much less verbose way!</p>
<p>Start the server using <code>cargo run</code>. Then open two browser windows: one for <em>http://127.0.0.1:7878/</em> and the other for <em>http://127.0.0.1:7878/sleep</em>. If you enter the <em>/</em> URI a few times, as before, you‚Äôll see it respond quickly. But if you enter <em>/sleep</em> and then load <em>/</em>, you‚Äôll see that <em>/</em> waits until <code>sleep</code> has slept for its full five seconds before loading.</p>
<p>There are multiple techniques we could use to avoid requests backing up behind a slow request, including using async as we did Chapter 17; the one we‚Äôll implement is a thread pool.</p>
<h3 id="improving-throughput-with-a-thread-pool"><a class="header" href="#improving-throughput-with-a-thread-pool">Improving Throughput with a Thread Pool</a></h3>
<p>A <em>thread pool</em> is a group of spawned threads that are waiting and ready to handle a task. When the program receives a new task, it assigns one of the threads in the pool to the task, and that thread will process the task. The remaining threads in the pool are available to handle any other tasks that come in while the first thread is processing. When the first thread is done processing its task, it‚Äôs returned to the pool of idle threads, ready to handle a new task. A thread pool allows you to process connections concurrently, increasing the throughput of your server.</p>
<p>We‚Äôll limit the number of threads in the pool to a small number to protect us from DoS attacks; if we had our program create a new thread for each request as it came in, someone making 10 million requests to our server could create havoc by using up all our server‚Äôs resources and grinding the processing of requests to a halt.</p>
<p>Rather than spawning unlimited threads, then, we‚Äôll have a fixed number of threads waiting in the pool. Requests that come in are sent to the pool for processing. The pool will maintain a queue of incoming requests. Each of the threads in the pool will pop off a request from this queue, handle the request, and then ask the queue for another request. With this design, we can process up to <em><code>N</code></em> requests concurrently, where <em><code>N</code></em> is the number of threads. If each thread is responding to a long-running request, subsequent requests can still back up in the queue, but we‚Äôve increased the number of long-running requests we can handle before reaching that point.</p>
<p>This technique is just one of many ways to improve the throughput of a web server. Other options you might explore are the fork/join model, the single-threaded async I/O model, and the multi-threaded async I/O model. If you‚Äôre interested in this topic, you can read more about other solutions and try to implement them; with a low-level language like Rust, all of these options are possible.</p>
<p>Before we begin implementing a thread pool, let‚Äôs talk about what using the pool should look like. When you‚Äôre trying to design code, writing the client interface first can help guide your design. Write the API of the code so it‚Äôs structured in the way you want to call it; then implement the functionality within that structure rather than implementing the functionality and then designing the public API.</p>
<p>Similar to how we used test-driven development in the project in Chapter 12, we‚Äôll use compiler-driven development here. We‚Äôll write the code that calls the functions we want, and then we‚Äôll look at errors from the compiler to determine what we should change next to get the code to work. Before we do that, however, we‚Äôll explore the technique we‚Äôre not going to use as a starting point.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="code-structure-if-we-could-spawn-a-thread-for-each-request"></a></p>
<h4 id="spawning-a-thread-for-each-request"><a class="header" href="#spawning-a-thread-for-each-request">Spawning a Thread for Each Request</a></h4>
<p>First, let‚Äôs explore how our code might look if it did create a new thread for every connection. As mentioned earlier, this isn‚Äôt our final plan due to the problems with potentially spawning an unlimited number of threads, but it is a starting point to get a working multithreaded server first. Then we‚Äôll add the thread pool as an improvement, and contrasting the two solutions will be easier. Listing 21-11 shows the changes to make to <code>main</code> to spawn a new thread to handle each stream within the <code>for</code> loop.</p>
<Listing number="21-11" file-name="src/main.rs" caption="Spawning a new thread for each stream">
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
</span><span class="boring">        "GET /sleep HTTP/1.1" =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            ("HTTP/1.1 200 OK", "hello.html")
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>As you learned in Chapter 16, <code>thread::spawn</code> will create a new thread and then run the code in the closure in the new thread. If you run this code and load <em>/sleep</em> in your browser, then <em>/</em> in two more browser tabs, you‚Äôll indeed see that the requests to <em>/</em> don‚Äôt have to wait for <em>/sleep</em> to finish. However, as we mentioned, this will eventually overwhelm the system because you‚Äôd be making new threads without any limit.</p>
<p>You may also recall from Chapter 17 that this is exactly the kind of situation where async and await really shine! Keep that in mind as we build the thread pool and think about how things would look different or the same with async.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="creating-a-similar-interface-for-a-finite-number-of-threads"></a></p>
<h4 id="creating-a-finite-number-of-threads"><a class="header" href="#creating-a-finite-number-of-threads">Creating a Finite Number of Threads</a></h4>
<p>We want our thread pool to work in a similar, familiar way so that switching from threads to a thread pool doesn‚Äôt require large changes to the code that uses our API. Listing 21-12 shows the hypothetical interface for a <code>ThreadPool</code> struct we want to use instead of <code>thread::spawn</code>.</p>
<Listing number="21-12" file-name="src/main.rs" caption="Our ideal `ThreadPool` interface">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
</span><span class="boring">        "GET /sleep HTTP/1.1" =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            ("HTTP/1.1 200 OK", "hello.html")
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre>
</Listing>
<p>We use <code>ThreadPool::new</code> to create a new thread pool with a configurable number of threads, in this case four. Then, in the <code>for</code> loop, <code>pool.execute</code> has a similar interface as <code>thread::spawn</code> in that it takes a closure the pool should run for each stream. We need to implement <code>pool.execute</code> so it takes the closure and gives it to a thread in the pool to run. This code won‚Äôt yet compile, but we‚Äôll try so the compiler can guide us in how to fix it.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="building-the-threadpool-struct-using-compiler-driven-development"></a></p>
<h4 id="building-threadpool-using-compiler-driven-development"><a class="header" href="#building-threadpool-using-compiler-driven-development">Building <code>ThreadPool</code> Using Compiler Driven Development</a></h4>
<p>Make the changes in Listing 21-12 to <em>src/main.rs</em>, and then let‚Äôs use the compiler errors from <code>cargo check</code> to drive our development. Here is the first error we get:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0433]: failed to resolve: use of undeclared type `ThreadPool`
  --&gt; src/main.rs:11:16
   |
11 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^ use of undeclared type `ThreadPool`

For more information about this error, try `rustc --explain E0433`.
error: could not compile `hello` (bin "hello") due to 1 previous error
</code></pre>
<p>Great! This error tells us we need a <code>ThreadPool</code> type or module, so we‚Äôll build one now. Our <code>ThreadPool</code> implementation will be independent of the kind of work our web server is doing. So let‚Äôs switch the <code>hello</code> crate from a binary crate to a library crate to hold our <code>ThreadPool</code> implementation. After we change to a library crate, we could also use the separate thread pool library for any work we want to do using a thread pool, not just for serving web requests.</p>
<p>Create a <em>src/lib.rs</em> file that contains the following, which is the simplest definition of a <code>ThreadPool</code> struct that we can have for now:</p>
<Listing file-name="src/lib.rs">
<pre><code class="language-rust noplayground">pub struct ThreadPool;</code></pre>
</Listing>
<p>Then edit <em>main.rs</em> file to bring <code>ThreadPool</code> into scope from the library crate by adding the following code to the top of <em>src/main.rs</em>:</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore">use hello::ThreadPool;
<span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">    let pool = ThreadPool::new(4);
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        pool.execute(|| {
</span><span class="boring">            handle_connection(stream);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
</span><span class="boring">        "GET /sleep HTTP/1.1" =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            ("HTTP/1.1 200 OK", "hello.html")
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre>
</Listing>
<p>This code still won‚Äôt work, but let‚Äôs check it again to get the next error that we need to address:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no function or associated item named `new` found for struct `ThreadPool` in the current scope
  --&gt; src/main.rs:12:28
   |
12 |     let pool = ThreadPool::new(4);
   |                            ^^^ function or associated item not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` (bin "hello") due to 1 previous error
</code></pre>
<p>This error indicates that next we need to create an associated function named <code>new</code> for <code>ThreadPool</code>. We also know that <code>new</code> needs to have one parameter that can accept <code>4</code> as an argument and should return a <code>ThreadPool</code> instance. Let‚Äôs implement the simplest <code>new</code> function that will have those characteristics:</p>
<Listing file-name="src/lib.rs">
<pre><code class="language-rust noplayground">pub struct ThreadPool;

impl ThreadPool {
    pub fn new(size: usize) -&gt; ThreadPool {
        ThreadPool
    }
}</code></pre>
</Listing>
<p>We chose <code>usize</code> as the type of the <code>size</code> parameter because we know that a negative number of threads doesn‚Äôt make any sense. We also know we‚Äôll use this <code>4</code> as the number of elements in a collection of threads, which is what the <code>usize</code> type is for, as discussed in <a href="ch03-02-data-types.html#integer-types">‚ÄúInteger Types‚Äù</a><!-- ignore
--> in Chapter 3.</p>
<p>Let‚Äôs check the code again:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `execute` found for struct `ThreadPool` in the current scope
  --&gt; src/main.rs:17:14
   |
17 |         pool.execute(|| {
   |         -----^^^^^^^ method not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` (bin "hello") due to 1 previous error
</code></pre>
<p>Now the error occurs because we don‚Äôt have an <code>execute</code> method on <code>ThreadPool</code>. Recall from <a href="ch21-02-multithreaded.html#creating-a-finite-number-of-threads">‚ÄúCreating a Finite Number of Threads‚Äù</a><!-- ignore --> that we decided our thread pool should have an interface similar to <code>thread::spawn</code>. In addition, we‚Äôll implement the <code>execute</code> function so it takes the closure it‚Äôs given and gives it to an idle thread in the pool to run.</p>
<p>We‚Äôll define the <code>execute</code> method on <code>ThreadPool</code> to take a closure as a parameter. Recall from <a href="ch13-01-closures.html#moving-captured-values-out-of-the-closure-and-the-fn-traits">‚ÄúMoving Captured Values Out of the Closure and the <code>Fn</code> Traits‚Äù</a><!-- ignore --> in Chapter 13 that we can take closures as parameters with three different traits: <code>Fn</code>, <code>FnMut</code>, and <code>FnOnce</code>. We need to decide which kind of closure to use here. We know we‚Äôll end up doing something similar to the standard library <code>thread::spawn</code> implementation, so we can look at what bounds the signature of <code>thread::spawn</code> has on its parameter. The documentation shows us the following:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static,</code></pre>
<p>The <code>F</code> type parameter is the one we‚Äôre concerned with here; the <code>T</code> type parameter is related to the return value, and we‚Äôre not concerned with that. We can see that <code>spawn</code> uses <code>FnOnce</code> as the trait bound on <code>F</code>. This is probably what we want as well, because we‚Äôll eventually pass the argument we get in <code>execute</code> to <code>spawn</code>. We can be further confident that <code>FnOnce</code> is the trait we want to use because the thread for running a request will only execute that request‚Äôs closure one time, which matches the <code>Once</code> in <code>FnOnce</code>.</p>
<p>The <code>F</code> type parameter also has the trait bound <code>Send</code> and the lifetime bound <code>'static</code>, which are useful in our situation: we need <code>Send</code> to transfer the closure from one thread to another and <code>'static</code> because we don‚Äôt know how long the thread will take to execute. Let‚Äôs create an <code>execute</code> method on <code>ThreadPool</code> that will take a generic parameter of type <code>F</code> with these bounds:</p>
<Listing file-name="src/lib.rs">
<pre><code class="language-rust noplayground"><span class="boring">pub struct ThreadPool;
</span><span class="boring">
</span>impl ThreadPool {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        ThreadPool
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
    }
}</code></pre>
</Listing>
<p>We still use the <code>()</code> after <code>FnOnce</code> because this <code>FnOnce</code> represents a closure that takes no parameters and returns the unit type <code>()</code>. Just like function definitions, the return type can be omitted from the signature, but even if we have no parameters, we still need the parentheses.</p>
<p>Again, this is the simplest implementation of the <code>execute</code> method: it does nothing, but we‚Äôre only trying to make our code compile. Let‚Äôs check it again:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.24s
</code></pre>
<p>It compiles! But note that if you try <code>cargo run</code> and make a request in the browser, you‚Äôll see the errors in the browser that we saw at the beginning of the chapter. Our library isn‚Äôt actually calling the closure passed to <code>execute</code> yet!</p>
<blockquote>
<p>Note: A saying you might hear about languages with strict compilers, such as Haskell and Rust, is ‚Äúif the code compiles, it works.‚Äù But this saying is not universally true. Our project compiles, but it does absolutely nothing! If we were building a real, complete project, this would be a good time to start writing unit tests to check that the code compiles <em>and</em> has the behavior we want.</p>
</blockquote>
<p>Consider: what would be different here if we were going to execute a <em>future</em> instead of a closure?</p>
<h4 id="validating-the-number-of-threads-in-new"><a class="header" href="#validating-the-number-of-threads-in-new">Validating the Number of Threads in <code>new</code></a></h4>
<p>We aren‚Äôt doing anything with the parameters to <code>new</code> and <code>execute</code>. Let‚Äôs implement the bodies of these functions with the behavior we want. To start, let‚Äôs think about <code>new</code>. Earlier we chose an unsigned type for the <code>size</code> parameter because a pool with a negative number of threads makes no sense. However, a pool with zero threads also makes no sense, yet zero is a perfectly valid <code>usize</code>. We‚Äôll add code to check that <code>size</code> is greater than zero before we return a <code>ThreadPool</code> instance and have the program panic if it receives a zero by using the <code>assert!</code> macro, as shown in Listing 21-13.</p>
<Listing number="21-13" file-name="src/lib.rs" caption="Implementing `ThreadPool::new` to panic if `size` is zero">
<pre><code class="language-rust noplayground"><span class="boring">pub struct ThreadPool;
</span><span class="boring">
</span>impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        ThreadPool
    }

    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}</code></pre>
</Listing>
<p>We‚Äôve also added some documentation for our <code>ThreadPool</code> with doc comments. Note that we followed good documentation practices by adding a section that calls out the situations in which our function can panic, as discussed in Chapter 14. Try running <code>cargo doc --open</code> and clicking the <code>ThreadPool</code> struct to see what the generated docs for <code>new</code> look like!</p>
<p>Instead of adding the <code>assert!</code> macro as we‚Äôve done here, we could change <code>new</code> into <code>build</code> and return a <code>Result</code> like we did with <code>Config::build</code> in the I/O project in Listing 12-9. But we‚Äôve decided in this case that trying to create a thread pool without any threads should be an unrecoverable error. If you‚Äôre feeling ambitious, try to write a function named <code>build</code> with the following signature to compare with the <code>new</code> function:</p>
<pre><code class="language-rust ignore">pub fn build(size: usize) -&gt; Result&lt;ThreadPool, PoolCreationError&gt; {</code></pre>
<h4 id="creating-space-to-store-the-threads"><a class="header" href="#creating-space-to-store-the-threads">Creating Space to Store the Threads</a></h4>
<p>Now that we have a way to know we have a valid number of threads to store in the pool, we can create those threads and store them in the <code>ThreadPool</code> struct before returning the struct. But how do we ‚Äústore‚Äù a thread? Let‚Äôs take another look at the <code>thread::spawn</code> signature:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static,</code></pre>
<p>The <code>spawn</code> function returns a <code>JoinHandle&lt;T&gt;</code>, where <code>T</code> is the type that the closure returns. Let‚Äôs try using <code>JoinHandle</code> too and see what happens. In our case, the closures we‚Äôre passing to the thread pool will handle the connection and not return anything, so <code>T</code> will be the unit type <code>()</code>.</p>
<p>The code in Listing 21-14 will compile but doesn‚Äôt create any threads yet. We‚Äôve changed the definition of <code>ThreadPool</code> to hold a vector of <code>thread::JoinHandle&lt;()&gt;</code> instances, initialized the vector with a capacity of <code>size</code>, set up a <code>for</code> loop that will run some code to create the threads, and returned a <code>ThreadPool</code> instance containing them.</p>
<Listing number="21-14" file-name="src/lib.rs" caption="Creating a vector for `ThreadPool` to hold the threads">
<pre><code class="language-rust ignore not_desired_behavior">use std::thread;

pub struct ThreadPool {
    threads: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl ThreadPool {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut threads = Vec::with_capacity(size);

        for _ in 0..size {
            // create some threads and store them in the vector
        }

        ThreadPool { threads }
    }
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}</code></pre>
</Listing>
<p>We‚Äôve brought <code>std::thread</code> into scope in the library crate because we‚Äôre using <code>thread::JoinHandle</code> as the type of the items in the vector in <code>ThreadPool</code>.</p>
<p>Once a valid size is received, our <code>ThreadPool</code> creates a new vector that can hold <code>size</code> items. The <code>with_capacity</code> function performs the same task as <code>Vec::new</code> but with an important difference: it pre-allocates space in the vector. Because we know we need to store <code>size</code> elements in the vector, doing this allocation up front is slightly more efficient than using <code>Vec::new</code>, which resizes itself as elements are inserted.</p>
<p>When you run <code>cargo check</code> again, it should succeed.</p>
<h4 id="a-worker-struct-responsible-for-sending-code-from-the-threadpool-to-a-thread"><a class="header" href="#a-worker-struct-responsible-for-sending-code-from-the-threadpool-to-a-thread">A <code>Worker</code> Struct Responsible for Sending Code from the <code>ThreadPool</code> to a Thread</a></h4>
<p>We left a comment in the <code>for</code> loop in Listing 21-14 regarding the creation of threads. Here, we‚Äôll look at how we actually create threads. The standard library provides <code>thread::spawn</code> as a way to create threads, and <code>thread::spawn</code> expects to get some code the thread should run as soon as the thread is created. However, in our case, we want to create the threads and have them <em>wait</em> for code that we‚Äôll send later. The standard library‚Äôs implementation of threads doesn‚Äôt include any way to do that; we have to implement it manually.</p>
<p>We‚Äôll implement this behavior by introducing a new data structure between the <code>ThreadPool</code> and the threads that will manage this new behavior. We‚Äôll call this data structure <em>Worker</em>, which is a common term in pooling implementations. The <code>Worker</code> picks up code that needs to be run and runs the code in the Worker‚Äôs thread.</p>
<p>Think of people working in the kitchen at a restaurant: the workers wait until orders come in from customers, and then they‚Äôre responsible for taking those orders and fulfilling them.</p>
<p>Instead of storing a vector of <code>JoinHandle&lt;()&gt;</code> instances in the thread pool, we‚Äôll store instances of the <code>Worker</code> struct. Each <code>Worker</code> will store a single <code>JoinHandle&lt;()&gt;</code> instance. Then we‚Äôll implement a method on <code>Worker</code> that will take a closure of code to run and send it to the already running thread for execution. We‚Äôll also give each <code>Worker</code> an <code>id</code> so we can distinguish between the different instances of <code>Worker</code> in the pool when logging or debugging.</p>
<p>Here is the new process that will happen when we create a <code>ThreadPool</code>. We‚Äôll implement the code that sends the closure to the thread after we have <code>Worker</code> set up in this way:</p>
<ol>
<li>Define a <code>Worker</code> struct that holds an <code>id</code> and a <code>JoinHandle&lt;()&gt;</code>.</li>
<li>Change <code>ThreadPool</code> to hold a vector of <code>Worker</code> instances.</li>
<li>Define a <code>Worker::new</code> function that takes an <code>id</code> number and returns a <code>Worker</code> instance that holds the <code>id</code> and a thread spawned with an empty closure.</li>
<li>In <code>ThreadPool::new</code>, use the <code>for</code> loop counter to generate an <code>id</code>, create a new <code>Worker</code> with that <code>id</code>, and store the worker in the vector.</li>
</ol>
<p>If you‚Äôre up for a challenge, try implementing these changes on your own before looking at the code in Listing 21-15.</p>
<p>Ready? Here is Listing 21-15 with one way to make the preceding modifications.</p>
<Listing number="21-15" file-name="src/lib.rs" caption="Modifying `ThreadPool` to hold `Worker` instances instead of holding threads directly">
<pre><code class="language-rust noplayground">use std::thread;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
}

impl ThreadPool {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers }
    }
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

struct Worker {
    id: usize,
    thread: thread::JoinHandle&lt;()&gt;,
}

impl Worker {
    fn new(id: usize) -&gt; Worker {
        let thread = thread::spawn(|| {});

        Worker { id, thread }
    }
}</code></pre>
</Listing>
<p>We‚Äôve changed the name of the field on <code>ThreadPool</code> from <code>threads</code> to <code>workers</code> because it‚Äôs now holding <code>Worker</code> instances instead of <code>JoinHandle&lt;()&gt;</code> instances. We use the counter in the <code>for</code> loop as an argument to <code>Worker::new</code>, and we store each new <code>Worker</code> in the vector named <code>workers</code>.</p>
<p>External code (like our server in <em>src/main.rs</em>) doesn‚Äôt need to know the implementation details regarding using a <code>Worker</code> struct within <code>ThreadPool</code>, so we make the <code>Worker</code> struct and its <code>new</code> function private. The <code>Worker::new</code> function uses the <code>id</code> we give it and stores a <code>JoinHandle&lt;()&gt;</code> instance that is created by spawning a new thread using an empty closure.</p>
<blockquote>
<p>Note: If the operating system can‚Äôt create a thread because there aren‚Äôt enough system resources, <code>thread::spawn</code> will panic. That will cause our whole server to panic, even though the creation of some threads might succeed. For simplicity‚Äôs sake, this behavior is fine, but in a production thread pool implementation, you‚Äôd likely want to use <a href="../std/thread/struct.Builder.html"><code>std::thread::Builder</code></a><!-- ignore --> and its <a href="../std/thread/struct.Builder.html#method.spawn"><code>spawn</code></a><!-- ignore --> method that returns <code>Result</code> instead.</p>
</blockquote>
<p>This code will compile and will store the number of <code>Worker</code> instances we specified as an argument to <code>ThreadPool::new</code>. But we‚Äôre <em>still</em> not processing the closure that we get in <code>execute</code>. Let‚Äôs look at how to do that next.</p>
<h4 id="sending-requests-to-threads-via-channels"><a class="header" href="#sending-requests-to-threads-via-channels">Sending Requests to Threads via Channels</a></h4>
<p>The next problem we‚Äôll tackle is that the closures given to <code>thread::spawn</code> do absolutely nothing. Currently, we get the closure we want to execute in the <code>execute</code> method. But we need to give <code>thread::spawn</code> a closure to run when we create each <code>Worker</code> during the creation of the <code>ThreadPool</code>.</p>
<p>We want the <code>Worker</code> structs that we just created to fetch the code to run from a queue held in the <code>ThreadPool</code> and send that code to its thread to run.</p>
<p>The channels we learned about in Chapter 16‚Äîa simple way to communicate between two threads‚Äîwould be perfect for this use case. We‚Äôll use a channel to function as the queue of jobs, and <code>execute</code> will send a job from the <code>ThreadPool</code> to the <code>Worker</code> instances, which will send the job to its thread. Here is the plan:</p>
<ol>
<li>The <code>ThreadPool</code> will create a channel and hold on to the sender.</li>
<li>Each <code>Worker</code> will hold on to the receiver.</li>
<li>We‚Äôll create a new <code>Job</code> struct that will hold the closures we want to send down the channel.</li>
<li>The <code>execute</code> method will send the job it wants to execute through the sender.</li>
<li>In its thread, the <code>Worker</code> will loop over its receiver and execute the closures of any jobs it receives.</li>
</ol>
<p>Let‚Äôs start by creating a channel in <code>ThreadPool::new</code> and holding the sender in the <code>ThreadPool</code> instance, as shown in Listing 21-16. The <code>Job</code> struct doesn‚Äôt hold anything for now but will be the type of item we‚Äôre sending down the channel.</p>
<Listing number="21-16" file-name="src/lib.rs" caption="Modifying `ThreadPool` to store the sender of a channel that transmits `Job` instances">
<pre><code class="language-rust noplayground">use std::{sync::mpsc, thread};

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Job&gt;,
}

struct Job;

impl ThreadPool {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers, sender }
    }
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(|| {});
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>In <code>ThreadPool::new</code>, we create our new channel and have the pool hold the sender. This will successfully compile.</p>
<p>Let‚Äôs try passing a receiver of the channel into each <code>Worker</code> as the thread pool creates the channel. We know we want to use the receiver in the thread that the <code>Worker</code> instances spawn, so we‚Äôll reference the <code>receiver</code> parameter in the closure. The code in Listing 21-17 won‚Äôt quite compile yet.</p>
<Listing number="21-17" file-name="src/lib.rs" caption="Passing the receiver to each `Worker`">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{sync::mpsc, thread};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Job;
</span><span class="boring">
</span>impl ThreadPool {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver));
        }

        ThreadPool { workers, sender }
    }
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--

<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
        let thread = thread::spawn(|| {
            receiver;
        });

        Worker { id, thread }
    }
}</code></pre>
</Listing>
<p>We‚Äôve made some small and straightforward changes: we pass the receiver into <code>Worker::new</code>, and then we use it inside the closure.</p>
<p>When we try to check this code, we get this error:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0382]: use of moved value: `receiver`
  --&gt; src/lib.rs:26:42
   |
21 |         let (sender, receiver) = mpsc::channel();
   |                      -------- move occurs because `receiver` has type `std::sync::mpsc::Receiver&lt;Job&gt;`, which does not implement the `Copy` trait
...
25 |         for id in 0..size {
   |         ----------------- inside of this loop
26 |             workers.push(Worker::new(id, receiver));
   |                                          ^^^^^^^^ value moved here, in previous iteration of loop
   |
note: consider changing this parameter type in method `new` to borrow instead if owning the value isn't necessary
  --&gt; src/lib.rs:47:33
   |
47 |     fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
   |        --- in this method       ^^^^^^^^^^^^^^^^^^^ this parameter takes ownership of the value
help: consider moving the expression out of the loop so it is only moved once
   |
25 ~         let mut value = Worker::new(id, receiver);
26 ~         for id in 0..size {
27 ~             workers.push(value);
   |

For more information about this error, try `rustc --explain E0382`.
error: could not compile `hello` (lib) due to 1 previous error
</code></pre>
<p>The code is trying to pass <code>receiver</code> to multiple <code>Worker</code> instances. This won‚Äôt work, as you‚Äôll recall from Chapter 16: the channel implementation that Rust provides is multiple <em>producer</em>, single <em>consumer</em>. This means we can‚Äôt just clone the consuming end of the channel to fix this code. We also don‚Äôt want to send a message multiple times to multiple consumers; we want one list of messages with multiple <code>Worker</code> instances such that each message gets processed once.</p>
<p>Additionally, taking a job off the channel queue involves mutating the <code>receiver</code>, so the threads need a safe way to share and modify <code>receiver</code>; otherwise, we might get race conditions (as covered in Chapter 16).</p>
<p>Recall the thread-safe smart pointers discussed in Chapter 16: to share ownership across multiple threads and allow the threads to mutate the value, we need to use <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>. The <code>Arc</code> type will let multiple <code>Worker</code> instances own the receiver, and <code>Mutex</code> will ensure that only one <code>Worker</code> gets a job from the receiver at a time. Listing 21-18 shows the changes we need to make.</p>
<Listing number="21-18" file-name="src/lib.rs" caption="Sharing the receiver among the `Worker` instances using `Arc` and `Mutex`">
<pre><code class="language-rust noplayground">use std::{
    sync::{mpsc, Arc, Mutex},
    thread,
};
// --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--

<span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Job;
</span><span class="boring">
</span>impl ThreadPool {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool { workers, sender }
    }

    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--

<span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">        let thread = thread::spawn(|| {
</span><span class="boring">            receiver;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span>    }
}</code></pre>
</Listing>
<p>In <code>ThreadPool::new</code>, we put the receiver in an <code>Arc</code> and a <code>Mutex</code>. For each new <code>Worker</code>, we clone the <code>Arc</code> to bump the reference count so the <code>Worker</code> instances can share ownership of the receiver.</p>
<p>With these changes, the code compiles! We‚Äôre getting there!</p>
<h4 id="implementing-the-execute-method"><a class="header" href="#implementing-the-execute-method">Implementing the <code>execute</code> Method</a></h4>
<p>Let‚Äôs finally implement the <code>execute</code> method on <code>ThreadPool</code>. We‚Äôll also change <code>Job</code> from a struct to a type alias for a trait object that holds the type of closure that <code>execute</code> receives. As discussed in <a href="ch20-03-advanced-types.html#creating-type-synonyms-with-type-aliases">‚ÄúCreating Type Synonyms with Type Aliases‚Äù</a><!-- ignore --> in Chapter 20, type aliases allow us to make long types shorter for ease of use. Look at Listing 21-19.</p>
<Listing number="21-19" file-name="src/lib.rs" caption="Creating a `Job` type alias for a `Box` that holds each closure and then sending the job down the channel">
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span>
    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(job).unwrap();
    }
}

// --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(|| {
</span><span class="boring">            receiver;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>After creating a new <code>Job</code> instance using the closure we get in <code>execute</code>, we send that job down the sending end of the channel. We‚Äôre calling <code>unwrap</code> on <code>send</code> for the case that sending fails. This might happen if, for example, we stop all our threads from executing, meaning the receiving end has stopped receiving new messages. At the moment, we can‚Äôt stop our threads from executing: our threads continue executing as long as the pool exists. The reason we use <code>unwrap</code> is that we know the failure case won‚Äôt happen, but the compiler doesn‚Äôt know that.</p>
<p>But we‚Äôre not quite done yet! In the <code>Worker</code>, our closure being passed to <code>thread::spawn</code> still only <em>references</em> the receiving end of the channel. Instead, we need the closure to loop forever, asking the receiving end of the channel for a job and running the job when it gets one. Let‚Äôs make the change shown in Listing 21-20 to <code>Worker::new</code>.</p>
<Listing number="21-20" file-name="src/lib.rs" caption="Receiving and executing the jobs in the `Worker` instance‚Äôs thread">
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let job = receiver.lock().unwrap().recv().unwrap();

            println!("Worker {id} got a job; executing.");

            job();
        });

        Worker { id, thread }
    }
}</code></pre>
</Listing>
<p>Here, we first call <code>lock</code> on the <code>receiver</code> to acquire the mutex, and then we call <code>unwrap</code> to panic on any errors. Acquiring a lock might fail if the mutex is in a <em>poisoned</em> state, which can happen if some other thread panicked while holding the lock rather than releasing the lock. In this situation, calling <code>unwrap</code> to have this thread panic is the correct action to take. Feel free to change this <code>unwrap</code> to an <code>expect</code> with an error message that is meaningful to you.</p>
<p>If we get the lock on the mutex, we call <code>recv</code> to receive a <code>Job</code> from the channel. A final <code>unwrap</code> moves past any errors here as well, which might occur if the thread holding the sender has shut down, similar to how the <code>send</code> method returns <code>Err</code> if the receiver shuts down.</p>
<p>The call to <code>recv</code> blocks, so if there is no job yet, the current thread will wait until a job becomes available. The <code>Mutex&lt;T&gt;</code> ensures that only one <code>Worker</code> thread at a time is trying to request a job.</p>
<p>Our thread pool is now in a working state! Give it a <code>cargo run</code> and make some requests:</p>
<!-- manual-regeneration
cd listings/ch21-web-server/listing-21-20
cargo run
make some requests to 127.0.0.1:7878
Can't automate because the output depends on making requests
-->
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
warning: field `workers` is never read
 --&gt; src/lib.rs:7:5
  |
6 | pub struct ThreadPool {
  |            ---------- field in this struct
7 |     workers: Vec&lt;Worker&gt;,
  |     ^^^^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: fields `id` and `thread` are never read
  --&gt; src/lib.rs:48:5
   |
47 | struct Worker {
   |        ------ fields in this struct
48 |     id: usize,
   |     ^^
49 |     thread: thread::JoinHandle&lt;()&gt;,
   |     ^^^^^^

warning: `hello` (lib) generated 2 warnings
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 4.91s
     Running `target/debug/hello`
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
</code></pre>
<p>Success! We now have a thread pool that executes connections asynchronously. There are never more than four threads created, so our system won‚Äôt get overloaded if the server receives a lot of requests. If we make a request to <em>/sleep</em>, the server will be able to serve other requests by having another thread run them.</p>
<blockquote>
<p>Note: If you open <em>/sleep</em> in multiple browser windows simultaneously, they might load one at a time in five-second intervals. Some web browsers execute multiple instances of the same request sequentially for caching reasons. This limitation is not caused by our web server.</p>
</blockquote>
<p>This is a good time to pause and consider how the code in Listings 21-18, 21-19, and 21-20 would be different if we were using futures instead of a closure for the work to be done. What types would change? How would the method signatures be different, if at all? What parts of the code would stay the same?</p>
<p>After learning about the <code>while let</code> loop in Chapters 17 and 18, you might be wondering why we didn‚Äôt write the worker thread code as shown in Listing 21-21.</p>
<Listing number="21-21" file-name="src/lib.rs" caption="An alternative implementation of `Worker::new` using `while let`">
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span>// --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            while let Ok(job) = receiver.lock().unwrap().recv() {
                println!("Worker {id} got a job; executing.");

                job();
            }
        });

        Worker { id, thread }
    }
}</code></pre>
</Listing>
<p>This code compiles and runs but doesn‚Äôt result in the desired threading behavior: a slow request will still cause other requests to wait to be processed. The reason is somewhat subtle: the <code>Mutex</code> struct has no public <code>unlock</code> method because the ownership of the lock is based on the lifetime of the <code>MutexGuard&lt;T&gt;</code> within the <code>LockResult&lt;MutexGuard&lt;T&gt;&gt;</code> that the <code>lock</code> method returns. At compile time, the borrow checker can then enforce the rule that a resource guarded by a <code>Mutex</code> cannot be accessed unless we hold the lock. However, this implementation can also result in the lock being held longer than intended if we aren‚Äôt mindful of the lifetime of the <code>MutexGuard&lt;T&gt;</code>.</p>
<p>The code in Listing 21-20 that uses <code>let job = receiver.lock().unwrap().recv().unwrap();</code> works because with <code>let</code>, any temporary values used in the expression on the right hand side of the equal sign are immediately dropped when the <code>let</code> statement ends. However, <code>while let</code> (and <code>if let</code> and <code>match</code>) does not drop temporary values until the end of the associated block. In Listing 21-21, the lock remains held for the duration of the call to <code>job()</code>, meaning other <code>Worker</code> instances cannot receive jobs.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="–ë–ª–∞–≥–æ–ø–æ–ª—É—á–Ω–æ–µ-–∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ-—Ä–∞–±–æ—Ç—ã"><a class="header" href="#–ë–ª–∞–≥–æ–ø–æ–ª—É—á–Ω–æ–µ-–∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ-—Ä–∞–±–æ—Ç—ã">–ë–ª–∞–≥–æ–ø–æ–ª—É—á–Ω–æ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã</a></h2>
<p>The code in Listing 21-20 is responding to requests asynchronously through the use of a thread pool, as we intended. We get some warnings about the <code>workers</code>, <code>id</code>, and <code>thread</code> fields that we‚Äôre not using in a direct way that reminds us we‚Äôre not cleaning up anything. When we use the less elegant <kbd>ctrl</kbd>-<kbd>c</kbd> method to halt the main thread, all other threads are stopped immediately as well, even if they‚Äôre in the middle of serving a request.</p>
<p>Next, then, we‚Äôll implement the <code>Drop</code> trait to call <code>join</code> on each of the threads in the pool so they can finish the requests they‚Äôre working on before closing. Then we‚Äôll implement a way to tell the threads they should stop accepting new requests and shut down. To see this code in action, we‚Äôll modify our server to accept only two requests before gracefully shutting down its thread pool.</p>
<p>One thing to notice as we go: none of this affects the parts of the code that handle executing the closures, so everything here would be just the same if we were using a thread pool for an async runtime.</p>
<h3 id="implementing-the-drop-trait-on-threadpool"><a class="header" href="#implementing-the-drop-trait-on-threadpool">Implementing the <code>Drop</code> Trait on <code>ThreadPool</code></a></h3>
<p>Let‚Äôs start with implementing <code>Drop</code> on our thread pool. When the pool is dropped, our threads should all join to make sure they finish their work. Listing 21-22 shows a first attempt at a <code>Drop</code> implementation; this code won‚Äôt quite work yet.</p>
<Listing number="21-22" file-name="src/lib.rs" caption="Joining each thread when the thread pool goes out of scope">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!("Shutting down worker {}", worker.id);

            worker.thread.join().unwrap();
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!("Worker {id} got a job; executing.");
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>First, we loop through each of the thread pool <code>workers</code>. We use <code>&amp;mut</code> for this because <code>self</code> is a mutable reference, and we also need to be able to mutate <code>worker</code>. For each worker, we print a message saying that this particular <code>Worker</code> instance is shutting down, and then we call <code>join</code> on that <code>Worker</code> instance‚Äôs thread. If the call to <code>join</code> fails, we use <code>unwrap</code> to make Rust panic and go into an ungraceful shutdown.</p>
<p>Here is the error we get when we compile this code:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0507]: cannot move out of `worker.thread` which is behind a mutable reference
    --&gt; src/lib.rs:52:13
     |
52   |             worker.thread.join().unwrap();
     |             ^^^^^^^^^^^^^ ------ `worker.thread` moved due to this method call
     |             |
     |             move occurs because `worker.thread` has type `JoinHandle&lt;()&gt;`, which does not implement the `Copy` trait
     |
note: `JoinHandle::&lt;T&gt;::join` takes ownership of the receiver `self`, which moves `worker.thread`
    --&gt; file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/std/src/thread/mod.rs:1763:17
     |
1763 |     pub fn join(self) -&gt; Result&lt;T&gt; {
     |                 ^^^^

For more information about this error, try `rustc --explain E0507`.
error: could not compile `hello` (lib) due to 1 previous error
</code></pre>
<p>The error tells us we can‚Äôt call <code>join</code> because we only have a mutable borrow of each <code>worker</code> and <code>join</code> takes ownership of its argument. To solve this issue, we need to move the thread out of the <code>Worker</code> instance that owns <code>thread</code> so <code>join</code> can consume the thread. One way to do this is by taking the same approach we did in Listing 18-15. If <code>Worker</code> held an <code>Option&lt;thread::JoinHandle&lt;()&gt;&gt;</code>, we could call the <code>take</code> method on the <code>Option</code> to move the value out of the <code>Some</code> variant and leave a <code>None</code> variant in its place. In other words, a <code>Worker</code> that is running would have a <code>Some</code> variant in <code>thread</code>, and when we wanted to clean up a <code>Worker</code>, we‚Äôd replace <code>Some</code> with <code>None</code> so the <code>Worker</code> wouldn‚Äôt have a thread to run.</p>
<p>However, the <em>only</em> time this would come up would be when dropping the <code>Worker</code>. In exchange, we‚Äôd have to deal with an <code>Option&lt;thread::JoinHandle&lt;()&gt;&gt;</code> anywhere we accessed <code>worker.thread</code>. Idiomatic Rust uses <code>Option</code> quite a bit, but when you find yourself wrapping something you know will always be present in <code>Option</code> as a workaround like this, it‚Äôs a good idea to look for alternative approaches. They can make your code cleaner and less error-prone.</p>
<p>In this case, a better alternative exists: the <code>Vec::drain</code> method. It accepts a range parameter to specify which items to remove from the <code>Vec</code>, and returns an iterator of those items. Passing the <code>..</code> range syntax will remove <em>every</em> value from the <code>Vec</code>.</p>
<p>So we need to update the <code>ThreadPool</code> <code>drop</code> implementation like this:</p>
<Listing file-name="src/lib.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in self.workers.drain(..) {
            println!("Shutting down worker {}", worker.id);

            worker.thread.join().unwrap();
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!("Worker {id} got a job; executing.");
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>This resolves the compiler error and does not require any other changes to our code.</p>
<h3 id="signaling-to-the-threads-to-stop-listening-for-jobs"><a class="header" href="#signaling-to-the-threads-to-stop-listening-for-jobs">Signaling to the Threads to Stop Listening for Jobs</a></h3>
<p>With all the changes we‚Äôve made, our code compiles without any warnings. However, the bad news is that this code doesn‚Äôt function the way we want it to yet. The key is the logic in the closures run by the threads of the <code>Worker</code> instances: at the moment, we call <code>join</code>, but that won‚Äôt shut down the threads because they <code>loop</code> forever looking for jobs. If we try to drop our <code>ThreadPool</code> with our current implementation of <code>drop</code>, the main thread will block forever, waiting for the first thread to finish.</p>
<p>To fix this problem, we‚Äôll need a change in the <code>ThreadPool</code> <code>drop</code> implementation and then a change in the <code>Worker</code> loop.</p>
<p>First we‚Äôll change the <code>ThreadPool</code> <code>drop</code> implementation to explicitly drop the <code>sender</code> before waiting for the threads to finish. Listing 21-23 shows the changes to <code>ThreadPool</code> to explicitly drop <code>sender</code>. Unlike with the thread, here we <em>do</em> need to use an <code>Option</code> to be able to move <code>sender</code> out of <code>ThreadPool</code> with <code>Option::take</code>.</p>
<Listing number="21-23" file-name="src/lib.rs" caption="Explicitly drop `sender` before joining the `Worker` threads">
<pre><code class="language-rust noplayground not_desired_behavior"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span>pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,
}
// --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--
<span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span>impl ThreadPool {
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        // --–∫–æ–¥ —Å–æ–∫—Ä–∞—â—ë–Ω--

<span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span>        ThreadPool {
            workers,
            sender: Some(sender),
        }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.as_ref().unwrap().send(job).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        drop(self.sender.take());

        for worker in self.workers.drain(..) {
            println!("Shutting down worker {}", worker.id);

            worker.thread.join().unwrap();
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!("Worker {id} got a job; executing.");
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>Dropping <code>sender</code> closes the channel, which indicates no more messages will be sent. When that happens, all the calls to <code>recv</code> that the <code>Worker</code> instances do in the infinite loop will return an error. In Listing 21-24, we change the <code>Worker</code> loop to gracefully exit the loop in that case, which means the threads will finish when the <code>ThreadPool</code> <code>drop</code> implementation calls <code>join</code> on them.</p>
<Listing number="21-24" file-name="src/lib.rs" caption="Explicitly breaking out of the loop when `recv` returns an error">
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool {
</span><span class="boring">            workers,
</span><span class="boring">            sender: Some(sender),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.as_ref().unwrap().send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for ThreadPool {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        drop(self.sender.take());
</span><span class="boring">
</span><span class="boring">        for worker in self.workers.drain(..) {
</span><span class="boring">            println!("Shutting down worker {}", worker.id);
</span><span class="boring">
</span><span class="boring">            worker.thread.join().unwrap();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv();

            match message {
                Ok(job) =&gt; {
                    println!("Worker {id} got a job; executing.");

                    job();
                }
                Err(_) =&gt; {
                    println!("Worker {id} disconnected; shutting down.");
                    break;
                }
            }
        });

        Worker { id, thread }
    }
}</code></pre>
</Listing>
<p>To see this code in action, let‚Äôs modify <code>main</code> to accept only two requests before gracefully shutting down the server, as shown in Listing 21-25.</p>
<Listing number="21-25" file-name="src/main.rs" caption="Shutting down the server after serving two requests by exiting the loop">
<pre><code class="language-rust ignore"><span class="boring">use hello::ThreadPool;
</span><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!("Shutting down.");
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
</span><span class="boring">        "GET /sleep HTTP/1.1" =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            ("HTTP/1.1 200 OK", "hello.html")
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre>
</Listing>
<p>You wouldn‚Äôt want a real-world web server to shut down after serving only two requests. This code just demonstrates that the graceful shutdown and cleanup is in working order.</p>
<p>The <code>take</code> method is defined in the <code>Iterator</code> trait and limits the iteration to the first two items at most. The <code>ThreadPool</code> will go out of scope at the end of <code>main</code>, and the <code>drop</code> implementation will run.</p>
<p>Start the server with <code>cargo run</code>, and make three requests. The third request should error, and in your terminal you should see output similar to this:</p>
<!-- manual-regeneration
cd listings/ch21-web-server/listing-21-25
cargo run
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
third request will error because server will have shut down
copy output below
Can't automate because the output depends on making requests
-->
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.41s
     Running `target/debug/hello`
Worker 0 got a job; executing.
Shutting down.
Shutting down worker 0
Worker 3 got a job; executing.
Worker 1 disconnected; shutting down.
Worker 2 disconnected; shutting down.
Worker 3 disconnected; shutting down.
Worker 0 disconnected; shutting down.
Shutting down worker 1
Shutting down worker 2
Shutting down worker 3
</code></pre>
<p>You might see a different ordering of <code>Worker</code> IDs and messages printed. We can see how this code works from the messages: <code>Worker</code> instances 0 and 3 got the first two requests. The server stopped accepting connections after the second connection, and the <code>Drop</code> implementation on <code>ThreadPool</code> starts executing before <code>Worker</code> 3 even starts its job. Dropping the <code>sender</code> disconnects all the <code>Worker</code> instances and tells them to shut down. The <code>Worker</code> instances each print a message when they disconnect, and then the thread pool calls <code>join</code> to wait for each <code>Worker</code> thread to finish.</p>
<p>Notice one interesting aspect of this particular execution: the <code>ThreadPool</code> dropped the <code>sender</code>, and before any <code>Worker</code> received an error, we tried to join <code>Worker</code> 0. <code>Worker</code> 0 had not yet gotten an error from <code>recv</code>, so the main thread blocked waiting for <code>Worker</code> 0 to finish. In the meantime, <code>Worker</code> 3 received a job and then all threads received an error. When <code>Worker</code> 0 finished, the main thread waited for the rest of the <code>Worker</code> instances to finish. At that point, they had all exited their loops and stopped.</p>
<p>Congrats! We‚Äôve now completed our project; we have a basic web server that uses a thread pool to respond asynchronously. We‚Äôre able to perform a graceful shutdown of the server, which cleans up all the threads in the pool.</p>
<p>Here‚Äôs the full code for reference:</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore">use hello::ThreadPool;
use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
    thread,
    time::Duration,
};

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!("Shutting down.");
}

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;stream);
    let request_line = buf_reader.lines().next().unwrap().unwrap();

    let (status_line, filename) = match &amp;request_line[..] {
        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
        "GET /sleep HTTP/1.1" =&gt; {
            thread::sleep(Duration::from_secs(5));
            ("HTTP/1.1 200 OK", "hello.html")
        }
        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
    };

    let contents = fs::read_to_string(filename).unwrap();
    let length = contents.len();

    let response =
        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre>
</Listing>
<Listing file-name="src/lib.rs">
<pre><code class="language-rust noplayground">use std::{
    sync::{mpsc, Arc, Mutex},
    thread,
};

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,
}

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool {
            workers,
            sender: Some(sender),
        }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.as_ref().unwrap().send(job).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        drop(self.sender.take());

        for worker in &amp;mut self.workers {
            println!("Shutting down worker {}", worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}

struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv();

            match message {
                Ok(job) =&gt; {
                    println!("Worker {id} got a job; executing.");

                    job();
                }
                Err(_) =&gt; {
                    println!("Worker {id} disconnected; shutting down.");
                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}</code></pre>
</Listing>
<p>We could do more here! If you want to continue enhancing this project, here are some ideas:</p>
<ul>
<li>Add more documentation to <code>ThreadPool</code> and its public methods.</li>
<li>Add tests of the library‚Äôs functionality.</li>
<li>Change calls to <code>unwrap</code> to more robust error handling.</li>
<li>Use <code>ThreadPool</code> to perform some task other than serving web requests.</li>
<li>Find a thread pool crate on <a href="https://crates.io/">crates.io</a> and implement a similar web server using the crate instead. Then compare its API and robustness to the thread pool we implemented.</li>
</ul>
<h2 id="–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-20"><a class="header" href="#–ü–æ–¥–≤–µ–¥—ë–º-–∏—Ç–æ–≥–∏-20">–ü–æ–¥–≤–µ–¥—ë–º –∏—Ç–æ–≥–∏</a></h2>
<p>Well done! You‚Äôve made it to the end of the book! We want to thank you for joining us on this tour of Rust. You‚Äôre now ready to implement your own Rust projects and help with other people‚Äôs projects. Keep in mind that there is a welcoming community of other Rustaceans who would love to help you with any challenges you encounter on your Rust journey.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="–ü—Ä–∏–ª–æ–∂–µ–Ω–∏—è"><a class="header" href="#–ü—Ä–∏–ª–æ–∂–µ–Ω–∏—è">–ü—Ä–∏–ª–æ–∂–µ–Ω–∏—è</a></h1>
<p>The following sections contain reference material you may find useful in your Rust journey.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="appendix-a-keywords"><a class="header" href="#appendix-a-keywords">Appendix A: Keywords</a></h2>
<p>The following list contains keywords that are reserved for current or future use by the Rust language. As such, they cannot be used as identifiers (except as raw identifiers as we‚Äôll discuss in the ‚Äú<a href="appendix-01-keywords.html#raw-identifiers">Raw Identifiers</a><!-- ignore -->‚Äù section). Identifiers are names of functions, variables, parameters, struct fields, modules, crates, constants, macros, static values, attributes, types, traits, or lifetimes.</p>
<h3 id="keywords-currently-in-use"><a class="header" href="#keywords-currently-in-use">Keywords Currently in Use</a></h3>
<p>The following is a list of keywords currently in use, with their functionality described.</p>
<ul>
<li><code>as</code> - perform primitive casting, disambiguate the specific trait containing an item, or rename items in <code>use</code> statements</li>
<li><code>async</code> - return a <code>Future</code> instead of blocking the current thread</li>
<li><code>await</code> - suspend execution until the result of a <code>Future</code> is ready</li>
<li><code>break</code> - exit a loop immediately</li>
<li><code>const</code> - define constant items or constant raw pointers</li>
<li><code>continue</code> - continue to the next loop iteration</li>
<li><code>crate</code> - in a module path, refers to the crate root</li>
<li><code>dyn</code> - dynamic dispatch to a trait object</li>
<li><code>else</code> - fallback for <code>if</code> and <code>if let</code> control flow constructs</li>
<li><code>enum</code> - define an enumeration</li>
<li><code>extern</code> - link an external function or variable</li>
<li><code>false</code> - Boolean false literal</li>
<li><code>fn</code> - define a function or the function pointer type</li>
<li><code>for</code> - loop over items from an iterator, implement a trait, or specify a higher-ranked lifetime</li>
<li><code>if</code> - branch based on the result of a conditional expression</li>
<li><code>impl</code> - implement inherent or trait functionality</li>
<li><code>in</code> - part of <code>for</code> loop syntax</li>
<li><code>let</code> - bind a variable</li>
<li><code>loop</code> - loop unconditionally</li>
<li><code>match</code> - match a value to patterns</li>
<li><code>mod</code> - define a module</li>
<li><code>move</code> - make a closure take ownership of all its captures</li>
<li><code>mut</code> - denote mutability in references, raw pointers, or pattern bindings</li>
<li><code>pub</code> - denote public visibility in struct fields, <code>impl</code> blocks, or modules</li>
<li><code>ref</code> - bind by reference</li>
<li><code>return</code> - return from function</li>
<li><code>Self</code> - a type alias for the type we are defining or implementing</li>
<li><code>self</code> - method subject or current module</li>
<li><code>static</code> - global variable or lifetime lasting the entire program execution</li>
<li><code>struct</code> - define a structure</li>
<li><code>super</code> - parent module of the current module</li>
<li><code>trait</code> - define a trait</li>
<li><code>true</code> - Boolean true literal</li>
<li><code>type</code> - define a type alias or associated type</li>
<li><code>union</code> - define a <a href="../reference/items/unions.html">union</a><!-- ignore -->; is only a keyword when used in a union declaration</li>
<li><code>unsafe</code> - denote unsafe code, functions, traits, or implementations</li>
<li><code>use</code> - bring symbols into scope; specify precise captures for generic and lifetime bounds</li>
<li><code>where</code> - denote clauses that constrain a type</li>
<li><code>while</code> - loop conditionally based on the result of an expression</li>
</ul>
<h3 id="keywords-reserved-for-future-use"><a class="header" href="#keywords-reserved-for-future-use">Keywords Reserved for Future Use</a></h3>
<p>The following keywords do not yet have any functionality but are reserved by Rust for potential future use.</p>
<ul>
<li><code>abstract</code></li>
<li><code>become</code></li>
<li><code>box</code></li>
<li><code>do</code></li>
<li><code>final</code></li>
<li><code>gen</code></li>
<li><code>macro</code></li>
<li><code>override</code></li>
<li><code>priv</code></li>
<li><code>try</code></li>
<li><code>typeof</code></li>
<li><code>unsized</code></li>
<li><code>virtual</code></li>
<li><code>yield</code></li>
</ul>
<h3 id="raw-identifiers"><a class="header" href="#raw-identifiers">Raw Identifiers</a></h3>
<p><em>Raw identifiers</em> are the syntax that lets you use keywords where they wouldn‚Äôt normally be allowed. You use a raw identifier by prefixing a keyword with <code>r#</code>.</p>
<p>For example, <code>match</code> is a keyword. If you try to compile the following function that uses <code>match</code> as its name:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}</code></pre>
<p>you‚Äôll get this error:</p>
<pre><code class="language-text">error: expected identifier, found keyword `match`
 --&gt; src/main.rs:4:4
  |
4 | fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
  |    ^^^^^ expected identifier, found keyword
</code></pre>
<p>The error shows that you can‚Äôt use the keyword <code>match</code> as the function identifier. To use <code>match</code> as a function name, you need to use the raw identifier syntax, like this:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn r#match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match("foo", "foobar"));
}</code></pre></pre>
<p>This code will compile without any errors. Note the <code>r#</code> prefix on the function name in its definition as well as where the function is called in <code>main</code>.</p>
<p>Raw identifiers allow you to use any word you choose as an identifier, even if that word happens to be a reserved keyword. This gives us more freedom to choose identifier names, as well as lets us integrate with programs written in a language where these words aren‚Äôt keywords. In addition, raw identifiers allow you to use libraries written in a different Rust edition than your crate uses. For example, <code>try</code> isn‚Äôt a keyword in the 2015 edition but is in the 2018, 2021, and 2024 editions. If you depend on a library that‚Äôs written using the 2015 edition and has a <code>try</code> function, you‚Äôll need to use the raw identifier syntax, <code>r#try</code> in this case, to call that function from your 2018 edition code. See <a href="appendix-05-editions.html">Appendix E</a><!-- ignore --> for more information on editions.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="appendix-b-operators-and-symbols"><a class="header" href="#appendix-b-operators-and-symbols">Appendix B: Operators and Symbols</a></h2>
<p>This appendix contains a glossary of Rust‚Äôs syntax, including operators and other symbols that appear by themselves or in the context of paths, generics, trait bounds, macros, attributes, comments, tuples, and brackets.</p>
<h3 id="operators"><a class="header" href="#operators">Operators</a></h3>
<p>Table B-1 contains the operators in Rust, an example of how the operator would appear in context, a short explanation, and whether that operator is overloadable. If an operator is overloadable, the relevant trait to use to overload that operator is listed.</p>
<p><span class="caption">Table B-1: Operators</span></p>
<div class="table-wrapper"><table><thead><tr><th>Operator</th><th>–ü—Ä–∏–º–µ—Ä</th><th>Explanation</th><th>Overloadable?</th></tr></thead><tbody>
<tr><td><code>!</code></td><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>Macro expansion</td><td></td></tr>
<tr><td><code>!</code></td><td><code>!expr</code></td><td>Bitwise or logical complement</td><td><code>Not</code></td></tr>
<tr><td><code>!=</code></td><td><code>expr != expr</code></td><td>Nonequality comparison</td><td><code>PartialEq</code></td></tr>
<tr><td><code>%</code></td><td><code>expr % expr</code></td><td>Arithmetic remainder</td><td><code>Rem</code></td></tr>
<tr><td><code>%=</code></td><td><code>var %= expr</code></td><td>Arithmetic remainder and assignment</td><td><code>RemAssign</code></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;expr</code>, <code>&amp;mut expr</code></td><td>Borrow</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;type</code>, <code>&amp;mut type</code>, <code>&amp;'a type</code>, <code>&amp;'a mut type</code></td><td>Borrowed pointer type</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>expr &amp; expr</code></td><td>Bitwise AND</td><td><code>BitAnd</code></td></tr>
<tr><td><code>&amp;=</code></td><td><code>var &amp;= expr</code></td><td>Bitwise AND and assignment</td><td><code>BitAndAssign</code></td></tr>
<tr><td><code>&amp;&amp;</code></td><td><code>expr &amp;&amp; expr</code></td><td>Short-circuiting logical AND</td><td></td></tr>
<tr><td><code>*</code></td><td><code>expr * expr</code></td><td>Arithmetic multiplication</td><td><code>Mul</code></td></tr>
<tr><td><code>*=</code></td><td><code>var *= expr</code></td><td>Arithmetic multiplication and assignment</td><td><code>MulAssign</code></td></tr>
<tr><td><code>*</code></td><td><code>*expr</code></td><td>Dereference</td><td><code>Deref</code></td></tr>
<tr><td><code>*</code></td><td><code>*const type</code>, <code>*mut type</code></td><td>Raw pointer</td><td></td></tr>
<tr><td><code>+</code></td><td><code>trait + trait</code>, <code>'a + trait</code></td><td>Compound type constraint</td><td></td></tr>
<tr><td><code>+</code></td><td><code>expr + expr</code></td><td>Arithmetic addition</td><td><code>Add</code></td></tr>
<tr><td><code>+=</code></td><td><code>var += expr</code></td><td>Arithmetic addition and assignment</td><td><code>AddAssign</code></td></tr>
<tr><td><code>,</code></td><td><code>expr, expr</code></td><td>Argument and element separator</td><td></td></tr>
<tr><td><code>-</code></td><td><code>- expr</code></td><td>Arithmetic negation</td><td><code>Neg</code></td></tr>
<tr><td><code>-</code></td><td><code>expr - expr</code></td><td>Arithmetic subtraction</td><td><code>Sub</code></td></tr>
<tr><td><code>-=</code></td><td><code>var -= expr</code></td><td>Arithmetic subtraction and assignment</td><td><code>SubAssign</code></td></tr>
<tr><td><code>-&gt;</code></td><td><code>fn(...) -&gt; type</code>, <code>|...| -&gt; type</code></td><td>Function and closure return type</td><td></td></tr>
<tr><td><code>.</code></td><td><code>expr.ident</code></td><td>Member access</td><td></td></tr>
<tr><td><code>..</code></td><td><code>..</code>, <code>expr..</code>, <code>..expr</code>, <code>expr..expr</code></td><td>Right-exclusive range literal</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>..=</code></td><td><code>..=expr</code>, <code>expr..=expr</code></td><td>Right-inclusive range literal</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>..</code></td><td><code>..expr</code></td><td>Struct literal update syntax</td><td></td></tr>
<tr><td><code>..</code></td><td><code>variant(x, ..)</code>, <code>struct_type { x, .. }</code></td><td>‚ÄúAnd the rest‚Äù pattern binding</td><td></td></tr>
<tr><td><code>...</code></td><td><code>expr...expr</code></td><td>(Deprecated, use <code>..=</code> instead) In a pattern: inclusive range pattern</td><td></td></tr>
<tr><td><code>/</code></td><td><code>expr / expr</code></td><td>Arithmetic division</td><td><code>Div</code></td></tr>
<tr><td><code>/=</code></td><td><code>var /= expr</code></td><td>Arithmetic division and assignment</td><td><code>DivAssign</code></td></tr>
<tr><td><code>:</code></td><td><code>pat: type</code>, <code>ident: type</code></td><td>Constraints</td><td></td></tr>
<tr><td><code>:</code></td><td><code>ident: expr</code></td><td>Struct field initializer</td><td></td></tr>
<tr><td><code>:</code></td><td><code>'a: loop {...}</code></td><td>Loop label</td><td></td></tr>
<tr><td><code>;</code></td><td><code>expr;</code></td><td>Statement and item terminator</td><td></td></tr>
<tr><td><code>;</code></td><td><code>[...; len]</code></td><td>Part of fixed-size array syntax</td><td></td></tr>
<tr><td><code>&lt;&lt;</code></td><td><code>expr &lt;&lt; expr</code></td><td>Left-shift</td><td><code>Shl</code></td></tr>
<tr><td><code>&lt;&lt;=</code></td><td><code>var &lt;&lt;= expr</code></td><td>Left-shift and assignment</td><td><code>ShlAssign</code></td></tr>
<tr><td><code>&lt;</code></td><td><code>expr &lt; expr</code></td><td>Less than comparison</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&lt;=</code></td><td><code>expr &lt;= expr</code></td><td>Less than or equal to comparison</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>=</code></td><td><code>var = expr</code>, <code>ident = type</code></td><td>Assignment/equivalence</td><td></td></tr>
<tr><td><code>==</code></td><td><code>expr == expr</code></td><td>Equality comparison</td><td><code>PartialEq</code></td></tr>
<tr><td><code>=&gt;</code></td><td><code>pat =&gt; expr</code></td><td>Part of match arm syntax</td><td></td></tr>
<tr><td><code>&gt;</code></td><td><code>expr &gt; expr</code></td><td>Greater than comparison</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;=</code></td><td><code>expr &gt;= expr</code></td><td>Greater than or equal to comparison</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;&gt;</code></td><td><code>expr &gt;&gt; expr</code></td><td>Right-shift</td><td><code>Shr</code></td></tr>
<tr><td><code>&gt;&gt;=</code></td><td><code>var &gt;&gt;= expr</code></td><td>Right-shift and assignment</td><td><code>ShrAssign</code></td></tr>
<tr><td><code>@</code></td><td><code>ident @ pat</code></td><td>Pattern binding</td><td></td></tr>
<tr><td><code>^</code></td><td><code>expr ^ expr</code></td><td>Bitwise exclusive OR</td><td><code>BitXor</code></td></tr>
<tr><td><code>^=</code></td><td><code>var ^= expr</code></td><td>Bitwise exclusive OR and assignment</td><td><code>BitXorAssign</code></td></tr>
<tr><td><code>|</code></td><td><code>pat | pat</code></td><td>Pattern alternatives</td><td></td></tr>
<tr><td><code>|</code></td><td><code>expr | expr</code></td><td>Bitwise OR</td><td><code>BitOr</code></td></tr>
<tr><td><code>|=</code></td><td><code>var |= expr</code></td><td>Bitwise OR and assignment</td><td><code>BitOrAssign</code></td></tr>
<tr><td><code>||</code></td><td><code>expr || expr</code></td><td>Short-circuiting logical OR</td><td></td></tr>
<tr><td><code>?</code></td><td><code>expr?</code></td><td>Error propagation</td><td></td></tr>
</tbody></table>
</div>
<h3 id="non-operator-symbols"><a class="header" href="#non-operator-symbols">Non-operator Symbols</a></h3>
<p>The following list contains all symbols that don‚Äôt function as operators; that is, they don‚Äôt behave like a function or method call.</p>
<p>Table B-2 shows symbols that appear on their own and are valid in a variety of locations.</p>
<p><span class="caption">Table B-2: Stand-Alone Syntax</span></p>
<div class="table-wrapper"><table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>'ident</code></td><td>Named lifetime or loop label</td></tr>
<tr><td><code>...u8</code>, <code>...i32</code>, <code>...f64</code>, <code>...usize</code>, etc.</td><td>Numeric literal of specific type</td></tr>
<tr><td><code>"..."</code></td><td>String literal</td></tr>
<tr><td><code>r"..."</code>, <code>r#"..."#</code>, <code>r##"..."##</code>, etc.</td><td>Raw string literal, escape characters not processed</td></tr>
<tr><td><code>b"..."</code></td><td>Byte string literal; constructs an array of bytes instead of a string</td></tr>
<tr><td><code>br"..."</code>, <code>br#"..."#</code>, <code>br##"..."##</code>, etc.</td><td>Raw byte string literal, combination of raw and byte string literal</td></tr>
<tr><td><code>'...'</code></td><td>Character literal</td></tr>
<tr><td><code>b'...'</code></td><td>ASCII byte literal</td></tr>
<tr><td><code>|...| expr</code></td><td>Closure</td></tr>
<tr><td><code>!</code></td><td>Always empty bottom type for diverging functions</td></tr>
<tr><td><code>_</code></td><td>‚ÄúIgnored‚Äù pattern binding; also used to make integer literals readable</td></tr>
</tbody></table>
</div>
<p>Table B-3 shows symbols that appear in the context of a path through the module hierarchy to an item.</p>
<p><span class="caption">Table B-3: Path-Related Syntax</span></p>
<div class="table-wrapper"><table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>ident::ident</code></td><td>Namespace path</td></tr>
<tr><td><code>::path</code></td><td>Path relative to the extern prelude, where all other crates are rooted (i.e., an explicitly absolute path including crate name)</td></tr>
<tr><td><code>self::path</code></td><td>Path relative to the current module (i.e., an explicitly relative path).</td></tr>
<tr><td><code>super::path</code></td><td>Path relative to the parent of the current module</td></tr>
<tr><td><code>type::ident</code>, <code>&lt;type as trait&gt;::ident</code></td><td>Associated constants, functions, and types</td></tr>
<tr><td><code>&lt;type&gt;::...</code></td><td>Associated item for a type that cannot be directly named (e.g., <code>&lt;&amp;T&gt;::...</code>, <code>&lt;[T]&gt;::...</code>, etc.)</td></tr>
<tr><td><code>trait::method(...)</code></td><td>Disambiguating a method call by naming the trait that defines it</td></tr>
<tr><td><code>type::method(...)</code></td><td>Disambiguating a method call by naming the type for which it‚Äôs defined</td></tr>
<tr><td><code>&lt;type as trait&gt;::method(...)</code></td><td>Disambiguating a method call by naming the trait and type</td></tr>
</tbody></table>
</div>
<p>Table B-4 shows symbols that appear in the context of using generic type parameters.</p>
<p><span class="caption">Table B-4: Generics</span></p>
<div class="table-wrapper"><table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>path&lt;...&gt;</code></td><td>Specifies parameters to generic type in a type (e.g., <code>Vec&lt;u8&gt;</code>)</td></tr>
<tr><td><code>path::&lt;...&gt;</code>, <code>method::&lt;...&gt;</code></td><td>Specifies parameters to generic type, function, or method in an expression; often referred to as turbofish (e.g., <code>"42".parse::&lt;i32&gt;()</code>)</td></tr>
<tr><td><code>fn ident&lt;...&gt; ...</code></td><td>Define generic function</td></tr>
<tr><td><code>struct ident&lt;...&gt; ...</code></td><td>Define generic structure</td></tr>
<tr><td><code>enum ident&lt;...&gt; ...</code></td><td>Define generic enumeration</td></tr>
<tr><td><code>impl&lt;...&gt; ...</code></td><td>Define generic implementation</td></tr>
<tr><td><code>for&lt;...&gt; type</code></td><td>Higher-ranked lifetime bounds</td></tr>
<tr><td><code>type&lt;ident=type&gt;</code></td><td>A generic type where one or more associated types have specific assignments (e.g., <code>Iterator&lt;Item=T&gt;</code>)</td></tr>
</tbody></table>
</div>
<p>Table B-5 shows symbols that appear in the context of constraining generic type parameters with trait bounds.</p>
<p><span class="caption">Table B-5: Trait Bound Constraints</span></p>
<div class="table-wrapper"><table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>T: U</code></td><td>Generic parameter <code>T</code> constrained to types that implement <code>U</code></td></tr>
<tr><td><code>T: 'a</code></td><td>Generic type <code>T</code> must outlive lifetime <code>'a</code> (meaning the type cannot transitively contain any references with lifetimes shorter than <code>'a</code>)</td></tr>
<tr><td><code>T: 'static</code></td><td>Generic type <code>T</code> contains no borrowed references other than <code>'static</code> ones</td></tr>
<tr><td><code>'b: 'a</code></td><td>Generic lifetime <code>'b</code> must outlive lifetime <code>'a</code></td></tr>
<tr><td><code>T: ?Sized</code></td><td>Allow generic type parameter to be a dynamically sized type</td></tr>
<tr><td><code>'a + trait</code>, <code>trait + trait</code></td><td>Compound type constraint</td></tr>
</tbody></table>
</div>
<p>Table B-6 shows symbols that appear in the context of calling or defining macros and specifying attributes on an item.</p>
<p><span class="caption">Table B-6: Macros and Attributes</span></p>
<div class="table-wrapper"><table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>#[meta]</code></td><td>Outer attribute</td></tr>
<tr><td><code>#![meta]</code></td><td>Inner attribute</td></tr>
<tr><td><code>$ident</code></td><td>Macro substitution</td></tr>
<tr><td><code>$ident:kind</code></td><td>Macro capture</td></tr>
<tr><td><code>$(‚Ä¶)‚Ä¶</code></td><td>Macro repetition</td></tr>
<tr><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>Macro invocation</td></tr>
</tbody></table>
</div>
<p>Table B-7 shows symbols that create comments.</p>
<p><span class="caption">Table B-7: Comments</span></p>
<div class="table-wrapper"><table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>//</code></td><td>Line comment</td></tr>
<tr><td><code>//!</code></td><td>Inner line doc comment</td></tr>
<tr><td><code>///</code></td><td>Outer line doc comment</td></tr>
<tr><td><code>/*...*/</code></td><td>Block comment</td></tr>
<tr><td><code>/*!...*/</code></td><td>Inner block doc comment</td></tr>
<tr><td><code>/**...*/</code></td><td>Outer block doc comment</td></tr>
</tbody></table>
</div>
<p>Table B-8 shows symbols that appear in the context of using tuples.</p>
<p><span class="caption">Table B-8: Tuples</span></p>
<div class="table-wrapper"><table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>()</code></td><td>Empty tuple (aka unit), both literal and type</td></tr>
<tr><td><code>(expr)</code></td><td>Parenthesized expression</td></tr>
<tr><td><code>(expr,)</code></td><td>Single-element tuple expression</td></tr>
<tr><td><code>(type,)</code></td><td>Single-element tuple type</td></tr>
<tr><td><code>(expr, ...)</code></td><td>Tuple expression</td></tr>
<tr><td><code>(type, ...)</code></td><td>Tuple type</td></tr>
<tr><td><code>expr(expr, ...)</code></td><td>Function call expression; also used to initialize tuple <code>struct</code>s and tuple <code>enum</code> variants</td></tr>
<tr><td><code>expr.0</code>, <code>expr.1</code>, etc.</td><td>Tuple indexing</td></tr>
</tbody></table>
</div>
<p>Table B-9 shows the contexts in which curly braces are used.</p>
<p><span class="caption">Table B-9: Curly Brackets</span></p>
<div class="table-wrapper"><table><thead><tr><th>Context</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>{...}</code></td><td>Block expression</td></tr>
<tr><td><code>Type {...}</code></td><td><code>struct</code> literal</td></tr>
</tbody></table>
</div>
<p>Table B-10 shows the contexts in which square brackets are used.</p>
<p><span class="caption">Table B-10: Square Brackets</span></p>
<div class="table-wrapper"><table><thead><tr><th>Context</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>[...]</code></td><td>Array literal</td></tr>
<tr><td><code>[expr; len]</code></td><td>Array literal containing <code>len</code> copies of <code>expr</code></td></tr>
<tr><td><code>[type; len]</code></td><td>Array type containing <code>len</code> instances of <code>type</code></td></tr>
<tr><td><code>expr[expr]</code></td><td>Collection indexing. Overloadable (<code>Index</code>, <code>IndexMut</code>)</td></tr>
<tr><td><code>expr[..]</code>, <code>expr[a..]</code>, <code>expr[..b]</code>, <code>expr[a..b]</code></td><td>Collection indexing pretending to be collection slicing, using <code>Range</code>, <code>RangeFrom</code>, <code>RangeTo</code>, or <code>RangeFull</code> as the ‚Äúindex‚Äù</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="appendix-c-derivable-traits"><a class="header" href="#appendix-c-derivable-traits">Appendix C: Derivable Traits</a></h2>
<p>In various places in the book, we‚Äôve discussed the <code>derive</code> attribute, which you can apply to a struct or enum definition. The <code>derive</code> attribute generates code that will implement a trait with its own default implementation on the type you‚Äôve annotated with the <code>derive</code> syntax.</p>
<p>In this appendix, we provide a reference of all the traits in the standard library that you can use with <code>derive</code>. Each section covers:</p>
<ul>
<li>What operators and methods deriving this trait will enable</li>
<li>What the implementation of the trait provided by <code>derive</code> does</li>
<li>What implementing the trait signifies about the type</li>
<li>The conditions in which you‚Äôre allowed or not allowed to implement the trait</li>
<li>Examples of operations that require the trait</li>
</ul>
<p>If you want different behavior from that provided by the <code>derive</code> attribute, consult the <a href="../std/index.html">standard library documentation</a><!-- ignore --> for each trait for details of how to manually implement them.</p>
<p>These traits listed here are the only ones defined by the standard library that can be implemented on your types using <code>derive</code>. Other traits defined in the standard library don‚Äôt have sensible default behavior, so it‚Äôs up to you to implement them in the way that makes sense for what you‚Äôre trying to accomplish.</p>
<p>An example of a trait that can‚Äôt be derived is <code>Display</code>, which handles formatting for end users. You should always consider the appropriate way to display a type to an end user. What parts of the type should an end user be allowed to see? What parts would they find relevant? What format of the data would be most relevant to them? The Rust compiler doesn‚Äôt have this insight, so it can‚Äôt provide appropriate default behavior for you.</p>
<p>The list of derivable traits provided in this appendix is not comprehensive: libraries can implement <code>derive</code> for their own traits, making the list of traits you can use <code>derive</code> with truly open-ended. Implementing <code>derive</code> involves using a procedural macro, which is covered in the <a href="ch20-05-macros.html#macros">‚ÄúMacros‚Äù</a><!-- ignore --> section of Chapter 20.</p>
<h3 id="debug-for-programmer-output"><a class="header" href="#debug-for-programmer-output"><code>Debug</code> for Programmer Output</a></h3>
<p>The <code>Debug</code> trait enables debug formatting in format strings, which you indicate by adding <code>:?</code> within <code>{}</code> placeholders.</p>
<p>The <code>Debug</code> trait allows you to print instances of a type for debugging purposes, so you and other programmers using your type can inspect an instance at a particular point in a program‚Äôs execution.</p>
<p>The <code>Debug</code> trait is required, for example, in using the <code>assert_eq!</code> macro. This macro prints the values of instances given as arguments if the equality assertion fails so programmers can see why the two instances weren‚Äôt equal.</p>
<h3 id="partialeq-and-eq-for-equality-comparisons"><a class="header" href="#partialeq-and-eq-for-equality-comparisons"><code>PartialEq</code> and <code>Eq</code> for Equality Comparisons</a></h3>
<p>The <code>PartialEq</code> trait allows you to compare instances of a type to check for equality and enables use of the <code>==</code> and <code>!=</code> operators.</p>
<p>Deriving <code>PartialEq</code> implements the <code>eq</code> method. When <code>PartialEq</code> is derived on structs, two instances are equal only if <em>all</em> fields are equal, and the instances are not equal if any fields are not equal. When derived on enums, each variant is equal to itself and not equal to the other variants.</p>
<p>The <code>PartialEq</code> trait is required, for example, with the use of the <code>assert_eq!</code> macro, which needs to be able to compare two instances of a type for equality.</p>
<p>The <code>Eq</code> trait has no methods. Its purpose is to signal that for every value of the annotated type, the value is equal to itself. The <code>Eq</code> trait can only be applied to types that also implement <code>PartialEq</code>, although not all types that implement <code>PartialEq</code> can implement <code>Eq</code>. One example of this is floating point number types: the implementation of floating point numbers states that two instances of the not-a-number (<code>NaN</code>) value are not equal to each other.</p>
<p>An example of when <code>Eq</code> is required is for keys in a <code>HashMap&lt;K, V&gt;</code> so the <code>HashMap&lt;K, V&gt;</code> can tell whether two keys are the same.</p>
<h3 id="partialord-and-ord-for-ordering-comparisons"><a class="header" href="#partialord-and-ord-for-ordering-comparisons"><code>PartialOrd</code> and <code>Ord</code> for Ordering Comparisons</a></h3>
<p>The <code>PartialOrd</code> trait allows you to compare instances of a type for sorting purposes. A type that implements <code>PartialOrd</code> can be used with the <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code> operators. You can only apply the <code>PartialOrd</code> trait to types that also implement <code>PartialEq</code>.</p>
<p>Deriving <code>PartialOrd</code> implements the <code>partial_cmp</code> method, which returns an <code>Option&lt;Ordering&gt;</code> that will be <code>None</code> when the values given don‚Äôt produce an ordering. An example of a value that doesn‚Äôt produce an ordering, even though most values of that type can be compared, is the <code>NaN</code> floating point value. Calling <code>partial_cmp</code> with any floating point number and the <code>NaN</code> floating point value will return <code>None</code>.</p>
<p>When derived on structs, <code>PartialOrd</code> compares two instances by comparing the value in each field in the order in which the fields appear in the struct definition. When derived on enums, variants of the enum declared earlier in the enum definition are considered less than the variants listed later.</p>
<p>The <code>PartialOrd</code> trait is required, for example, for the <code>gen_range</code> method from the <code>rand</code> crate that generates a random value in the range specified by a range expression.</p>
<p>The <code>Ord</code> trait allows you to know that for any two values of the annotated type, a valid ordering will exist. The <code>Ord</code> trait implements the <code>cmp</code> method, which returns an <code>Ordering</code> rather than an <code>Option&lt;Ordering&gt;</code> because a valid ordering will always be possible. You can only apply the <code>Ord</code> trait to types that also implement <code>PartialOrd</code> and <code>Eq</code> (and <code>Eq</code> requires <code>PartialEq</code>). When derived on structs and enums, <code>cmp</code> behaves the same way as the derived implementation for <code>partial_cmp</code> does with <code>PartialOrd</code>.</p>
<p>An example of when <code>Ord</code> is required is when storing values in a <code>BTreeSet&lt;T&gt;</code>, a data structure that stores data based on the sort order of the values.</p>
<h3 id="clone-and-copy-for-duplicating-values"><a class="header" href="#clone-and-copy-for-duplicating-values"><code>Clone</code> and <code>Copy</code> for Duplicating Values</a></h3>
<p>The <code>Clone</code> trait allows you to explicitly create a deep copy of a value, and the duplication process might involve running arbitrary code and copying heap data. See <a href="ch04-01-what-is-ownership.html#variables-and-data-interacting-with-clone">Variables and Data Interacting with Clone‚Äù</a><!-- ignore --> in Chapter 4 for more information on <code>Clone</code>.</p>
<p>Deriving <code>Clone</code> implements the <code>clone</code> method, which when implemented for the whole type, calls <code>clone</code> on each of the parts of the type. This means all the fields or values in the type must also implement <code>Clone</code> to derive <code>Clone</code>.</p>
<p>An example of when <code>Clone</code> is required is when calling the <code>to_vec</code> method on a slice. The slice doesn‚Äôt own the type instances it contains, but the vector returned from <code>to_vec</code> will need to own its instances, so <code>to_vec</code> calls <code>clone</code> on each item. Thus, the type stored in the slice must implement <code>Clone</code>.</p>
<p>The <code>Copy</code> trait allows you to duplicate a value by only copying bits stored on the stack; no arbitrary code is necessary. See <a href="ch04-01-what-is-ownership.html#stack-only-data-copy">‚ÄúStack-Only Data: Copy‚Äù</a><!-- ignore --> in Chapter 4 for more information on <code>Copy</code>.</p>
<p>The <code>Copy</code> trait doesn‚Äôt define any methods to prevent programmers from overloading those methods and violating the assumption that no arbitrary code is being run. That way, all programmers can assume that copying a value will be very fast.</p>
<p>You can derive <code>Copy</code> on any type whose parts all implement <code>Copy</code>. A type that implements <code>Copy</code> must also implement <code>Clone</code>, because a type that implements <code>Copy</code> has a trivial implementation of <code>Clone</code> that performs the same task as <code>Copy</code>.</p>
<p>The <code>Copy</code> trait is rarely required; types that implement <code>Copy</code> have optimizations available, meaning you don‚Äôt have to call <code>clone</code>, which makes the code more concise.</p>
<p>Everything possible with <code>Copy</code> you can also accomplish with <code>Clone</code>, but the code might be slower or have to use <code>clone</code> in places.</p>
<h3 id="hash-for-mapping-a-value-to-a-value-of-fixed-size"><a class="header" href="#hash-for-mapping-a-value-to-a-value-of-fixed-size"><code>Hash</code> for Mapping a Value to a Value of Fixed Size</a></h3>
<p>The <code>Hash</code> trait allows you to take an instance of a type of arbitrary size and map that instance to a value of fixed size using a hash function. Deriving <code>Hash</code> implements the <code>hash</code> method. The derived implementation of the <code>hash</code> method combines the result of calling <code>hash</code> on each of the parts of the type, meaning all fields or values must also implement <code>Hash</code> to derive <code>Hash</code>.</p>
<p>An example of when <code>Hash</code> is required is in storing keys in a <code>HashMap&lt;K, V&gt;</code> to store data efficiently.</p>
<h3 id="default-for-default-values"><a class="header" href="#default-for-default-values"><code>Default</code> for Default Values</a></h3>
<p>The <code>Default</code> trait allows you to create a default value for a type. Deriving <code>Default</code> implements the <code>default</code> function. The derived implementation of the <code>default</code> function calls the <code>default</code> function on each part of the type, meaning all fields or values in the type must also implement <code>Default</code> to derive <code>Default</code>.</p>
<p>The <code>Default::default</code> function is commonly used in combination with the struct update syntax discussed in <a href="ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax">‚ÄúCreating Instances From Other Instances With Struct Update Syntax‚Äù</a><!--
ignore --> in Chapter 5. You can customize a few fields of a struct and then set and use a default value for the rest of the fields by using <code>..Default::default()</code>.</p>
<p>The <code>Default</code> trait is required when you use the method <code>unwrap_or_default</code> on <code>Option&lt;T&gt;</code> instances, for example. If the <code>Option&lt;T&gt;</code> is <code>None</code>, the method <code>unwrap_or_default</code> will return the result of <code>Default::default</code> for the type <code>T</code> stored in the <code>Option&lt;T&gt;</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="appendix-d---useful-development-tools"><a class="header" href="#appendix-d---useful-development-tools">Appendix D - Useful Development Tools</a></h2>
<p>In this appendix, we talk about some useful development tools that the Rust project provides. We‚Äôll look at automatic formatting, quick ways to apply warning fixes, a linter, and integrating with IDEs.</p>
<h3 id="automatic-formatting-with-rustfmt"><a class="header" href="#automatic-formatting-with-rustfmt">Automatic Formatting with <code>rustfmt</code></a></h3>
<p>The <code>rustfmt</code> tool reformats your code according to the community code style. Many collaborative projects use <code>rustfmt</code> to prevent arguments about which style to use when writing Rust: everyone formats their code using the tool.</p>
<p>To install <code>rustfmt</code>, enter the following:</p>
<pre><code class="language-console">$ rustup component add rustfmt
</code></pre>
<p>This command gives you <code>rustfmt</code> and <code>cargo-fmt</code>, similar to how Rust gives you both <code>rustc</code> and <code>cargo</code>. To format any Cargo project, enter the following:</p>
<pre><code class="language-console">$ cargo fmt
</code></pre>
<p>Running this command reformats all the Rust code in the current crate. This should only change the code style, not the code semantics. For more information on <code>rustfmt</code>, see <a href="https://github.com/rust-lang/rustfmt">its documentation</a>.</p>
<h3 id="fix-your-code-with-rustfix"><a class="header" href="#fix-your-code-with-rustfix">Fix Your Code with <code>rustfix</code></a></h3>
<p>The rustfix tool is included with Rust installations and can automatically fix compiler warnings that have a clear way to correct the problem that‚Äôs likely what you want. It‚Äôs likely you‚Äôve seen compiler warnings before. For example, consider this code:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut x = 42;
    println!("{x}");
}</code></pre></pre>
<p>Here, we‚Äôre defining variable <code>x</code> as mutable, but we never actually mutate it. Rust warns us about that:</p>
<pre><code class="language-console">$ cargo build
   Compiling myprogram v0.1.0 (file:///projects/myprogram)
warning: variable does not need to be mutable
 --&gt; src/main.rs:2:9
  |
2 |     let mut x = 0;
  |         ----^
  |         |
  |         help: remove this `mut`
  |
  = note: `#[warn(unused_mut)]` on by default
</code></pre>
<p>The warning suggests that we remove the <code>mut</code> keyword. We can automatically apply that suggestion using the <code>rustfix</code> tool by running the command <code>cargo fix</code>:</p>
<pre><code class="language-console">$ cargo fix
    Checking myprogram v0.1.0 (file:///projects/myprogram)
      Fixing src/main.rs (1 fix)
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>When we look at <em>src/main.rs</em> again, we‚Äôll see that <code>cargo fix</code> has changed the code:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = 42;
    println!("{x}");
}</code></pre></pre>
<p>The <code>x</code> variable is now immutable, and the warning no longer appears.</p>
<p>You can also use the <code>cargo fix</code> command to transition your code between different Rust editions. Editions are covered in <a href="appendix-05-editions.html">Appendix E</a>.</p>
<h3 id="more-lints-with-clippy"><a class="header" href="#more-lints-with-clippy">More Lints with Clippy</a></h3>
<p>The Clippy tool is a collection of lints to analyze your code so you can catch common mistakes and improve your Rust code.</p>
<p>To install Clippy, enter the following:</p>
<pre><code class="language-console">$ rustup component add clippy
</code></pre>
<p>To run Clippy‚Äôs lints on any Cargo project, enter the following:</p>
<pre><code class="language-console">$ cargo clippy
</code></pre>
<p>For example, say you write a program that uses an approximation of a mathematical constant, such as pi, as this program does:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = 3.1415;
    let r = 8.0;
    println!("the area of the circle is {}", x * r * r);
}</code></pre></pre>
<p>Running <code>cargo clippy</code> on this project results in this error:</p>
<pre><code class="language-text">error: approximate value of `f{32, 64}::consts::PI` found
 --&gt; src/main.rs:2:13
  |
2 |     let x = 3.1415;
  |             ^^^^^^
  |
  = note: `#[deny(clippy::approx_constant)]` on by default
  = help: consider using the constant directly
  = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#approx_constant
</code></pre>
<p>This error lets you know that Rust already has a more precise <code>PI</code> constant defined, and that your program would be more correct if you used the constant instead. You would then change your code to use the <code>PI</code> constant. The following code doesn‚Äôt result in any errors or warnings from Clippy:</p>
<p><span class="filename">–§–∞–π–ª: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = std::f64::consts::PI;
    let r = 8.0;
    println!("the area of the circle is {}", x * r * r);
}</code></pre></pre>
<p>For more information on Clippy, see <a href="https://github.com/rust-lang/rust-clippy">its documentation</a>.</p>
<h3 id="ide-integration-using-rust-analyzer"><a class="header" href="#ide-integration-using-rust-analyzer">IDE Integration Using <code>rust-analyzer</code></a></h3>
<p>To help IDE integration, the Rust community recommends using <a href="https://rust-analyzer.github.io"><code>rust-analyzer</code></a><!-- ignore -->. This tool is a set of compiler-centric utilities that speaks the <a href="http://langserver.org/">Language Server Protocol</a><!--
ignore -->, which is a specification for IDEs and programming languages to communicate with each other. Different clients can use <code>rust-analyzer</code>, such as <a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer">the Rust analyzer plug-in for Visual Studio Code</a>.</p>
<p>Visit the <code>rust-analyzer</code> project‚Äôs <a href="https://rust-analyzer.github.io">home page</a><!-- ignore --> for installation instructions, then install the language server support in your particular IDE. Your IDE will gain abilities such as autocompletion, jump to definition, and inline errors.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="appendix-e---editions"><a class="header" href="#appendix-e---editions">Appendix E - Editions</a></h2>
<p>In Chapter 1, you saw that <code>cargo new</code> adds a bit of metadata to your <em>Cargo.toml</em> file about an edition. This appendix talks about what that means!</p>
<p>The Rust language and compiler have a six-week release cycle, meaning users get a constant stream of new features. Other programming languages release larger changes less often; Rust releases smaller updates more frequently. After a while, all of these tiny changes add up. But from release to release, it can be difficult to look back and say, ‚ÄúWow, between Rust 1.10 and Rust 1.31, Rust has changed a lot!‚Äù</p>
<p>Every two or three years, the Rust team produces a new Rust <em>edition</em>. Each edition brings together the features that have landed into a clear package with fully updated documentation and tooling. New editions ship as part of the usual six-week release process.</p>
<p>Editions serve different purposes for different people:</p>
<ul>
<li>For active Rust users, a new edition brings together incremental changes into an easy-to-understand package.</li>
<li>For non-users, a new edition signals that some major advancements have landed, which might make Rust worth another look.</li>
<li>For those developing Rust, a new edition provides a rallying point for the project as a whole.</li>
</ul>
<p>At the time of this writing, four Rust editions are available: Rust 2015, Rust 2018, Rust 2021, and Rust 2024. This book is written using Rust 2024 edition idioms.</p>
<p>The <code>edition</code> key in <em>Cargo.toml</em> indicates which edition the compiler should use for your code. If the key doesn‚Äôt exist, Rust uses <code>2015</code> as the edition value for backward compatibility reasons.</p>
<p>Each project can opt in to an edition other than the default 2015 edition. Editions can contain incompatible changes, such as including a new keyword that conflicts with identifiers in code. However, unless you opt in to those changes, your code will continue to compile even as you upgrade the Rust compiler version you use.</p>
<p>All Rust compiler versions support any edition that existed prior to that compiler‚Äôs release, and they can link crates of any supported editions together. Edition changes only affect the way the compiler initially parses code. Therefore, if you‚Äôre using Rust 2015 and one of your dependencies uses Rust 2018, your project will compile and be able to use that dependency. The opposite situation, where your project uses Rust 2018 and a dependency uses Rust 2015, works as well.</p>
<p>To be clear: most features will be available on all editions. Developers using any Rust edition will continue to see improvements as new stable releases are made. However, in some cases, mainly when new keywords are added, some new features might only be available in later editions. You will need to switch editions if you want to take advantage of such features.</p>
<p>For more details, the <a href="https://doc.rust-lang.org/stable/edition-guide/"><em>Edition Guide</em></a> is a complete book about editions that enumerates the differences between editions and explains how to automatically upgrade your code to a new edition via <code>cargo fix</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="appendix-f-translations-of-the-book"><a class="header" href="#appendix-f-translations-of-the-book">Appendix F: Translations of the Book</a></h2>
<p>For resources in languages other than English. Most are still in progress; see <a href="https://github.com/rust-lang/book/issues?q=is%3Aopen+is%3Aissue+label%3ATranslations">the Translations label</a> to help or let us know about a new translation!</p>
<ul>
<li><a href="https://github.com/rust-br/rust-book-pt-br">Portugu√™s</a> (BR)</li>
<li><a href="https://github.com/nunojesus/rust-book-pt-pt">Portugu√™s</a> (PT)</li>
<li>ÁÆÄ‰Ωì‰∏≠Êñá: <a href="https://github.com/KaiserY/trpl-zh-cn">KaiserY/trpl-zh-cn</a>, <a href="https://github.com/gnu4cn/rust-lang-Zh_CN">gnu4cn/rust-lang-Zh_CN</a></li>
<li><a href="https://github.com/rust-tw/book-tw">Ê≠£È´î‰∏≠Êñá</a></li>
<li><a href="https://rust-lang-ua.github.io/rustbook_ukrainian">–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞</a></li>
<li><a href="https://github.com/thecodix/book">Espa√±ol</a>, <a href="https://github.com/ManRR/rust-book-es">alternate</a>, <a href="https://github.com/RustLangES/rust-book-es">Espa√±ol por RustLangES</a></li>
<li><a href="https://github.com/rust-lang-ru/book">–†—É—Å—Å–∫–∏–π</a></li>
<li><a href="https://github.com/rust-kr/doc.rust-kr.org">ÌïúÍµ≠Ïñ¥</a></li>
<li><a href="https://github.com/rust-lang-ja/book-ja">Êó•Êú¨Ë™û</a></li>
<li><a href="https://github.com/Jimskapt/rust-book-fr">Fran√ßais</a></li>
<li><a href="https://github.com/paytchoo/book-pl">Polski</a></li>
<li><a href="https://github.com/agentzero1/book">Cebuano</a></li>
<li><a href="https://github.com/josephace135/book">Tagalog</a></li>
<li><a href="https://github.com/psychoslave/Rust-libro">Esperanto</a></li>
<li><a href="https://github.com/TChatzigiannakis/rust-book-greek">ŒµŒªŒªŒ∑ŒΩŒπŒ∫ŒÆ</a></li>
<li><a href="https://github.com/sebras/book">Svenska</a></li>
<li><a href="https://github.com/RustFarsi/book">Farsi</a>, <a href="https://github.com/persian-rust/book">Persian (FA)</a></li>
<li><a href="https://github.com/rust-lang-de/rustbook-de">Deutsch</a></li>
<li><a href="https://github.com/venkatarun95/rust-book-hindi">‡§π‡§ø‡§Ç‡§¶‡•Ä</a></li>
<li><a href="https://github.com/rust-lang-th/book-th">‡πÑ‡∏ó‡∏¢</a></li>
<li><a href="https://github.com/DanKHansen/book-dk">Danske</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="appendix-g---how-rust-is-made-and-nightly-rust"><a class="header" href="#appendix-g---how-rust-is-made-and-nightly-rust">Appendix G - How Rust is Made and ‚ÄúNightly Rust‚Äù</a></h2>
<p>This appendix is about how Rust is made and how that affects you as a Rust developer.</p>
<h3 id="stability-without-stagnation"><a class="header" href="#stability-without-stagnation">Stability Without Stagnation</a></h3>
<p>As a language, Rust cares a <em>lot</em> about the stability of your code. We want Rust to be a rock-solid foundation you can build on, and if things were constantly changing, that would be impossible. At the same time, if we can‚Äôt experiment with new features, we may not find out important flaws until after their release, when we can no longer change things.</p>
<p>Our solution to this problem is what we call ‚Äústability without stagnation‚Äù, and our guiding principle is this: you should never have to fear upgrading to a new version of stable Rust. Each upgrade should be painless, but should also bring you new features, fewer bugs, and faster compile times.</p>
<h3 id="choo-choo-release-channels-and-riding-the-trains"><a class="header" href="#choo-choo-release-channels-and-riding-the-trains">Choo, Choo! Release Channels and Riding the Trains</a></h3>
<p>Rust development operates on a <em>train schedule</em>. That is, all development is done on the <code>master</code> branch of the Rust repository. Releases follow a software release train model, which has been used by Cisco IOS and other software projects. There are three <em>release channels</em> for Rust:</p>
<ul>
<li>Nightly</li>
<li>Beta</li>
<li>Stable</li>
</ul>
<p>Most Rust developers primarily use the stable channel, but those who want to try out experimental new features may use nightly or beta.</p>
<p>Here‚Äôs an example of how the development and release process works: let‚Äôs assume that the Rust team is working on the release of Rust 1.5. That release happened in December of 2015, but it will provide us with realistic version numbers. A new feature is added to Rust: a new commit lands on the <code>master</code> branch. Each night, a new nightly version of Rust is produced. Every day is a release day, and these releases are created by our release infrastructure automatically. So as time passes, our releases look like this, once a night:</p>
<pre><code class="language-text">nightly: * - - * - - *
</code></pre>
<p>Every six weeks, it‚Äôs time to prepare a new release! The <code>beta</code> branch of the Rust repository branches off from the <code>master</code> branch used by nightly. Now, there are two releases:</p>
<pre><code class="language-text">nightly: * - - * - - *
                     |
beta:                *
</code></pre>
<p>Most Rust users do not use beta releases actively, but test against beta in their CI system to help Rust discover possible regressions. In the meantime, there‚Äôs still a nightly release every night:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - *
                     |
beta:                *
</code></pre>
<p>Let‚Äôs say a regression is found. Good thing we had some time to test the beta release before the regression snuck into a stable release! The fix is applied to <code>master</code>, so that nightly is fixed, and then the fix is backported to the <code>beta</code> branch, and a new release of beta is produced:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - *
                     |
beta:                * - - - - - - - - *
</code></pre>
<p>Six weeks after the first beta was created, it‚Äôs time for a stable release! The <code>stable</code> branch is produced from the <code>beta</code> branch:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |
beta:                * - - - - - - - - *
                                       |
stable:                                *
</code></pre>
<p>Hooray! Rust 1.5 is done! However, we‚Äôve forgotten one thing: because the six weeks have gone by, we also need a new beta of the <em>next</em> version of Rust, 1.6. So after <code>stable</code> branches off of <code>beta</code>, the next version of <code>beta</code> branches off of <code>nightly</code> again:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |                         |
beta:                * - - - - - - - - *       *
                                       |
stable:                                *
</code></pre>
<p>This is called the ‚Äútrain model‚Äù because every six weeks, a release ‚Äúleaves the station‚Äù, but still has to take a journey through the beta channel before it arrives as a stable release.</p>
<p>Rust releases every six weeks, like clockwork. If you know the date of one Rust release, you can know the date of the next one: it‚Äôs six weeks later. A nice aspect of having releases scheduled every six weeks is that the next train is coming soon. If a feature happens to miss a particular release, there‚Äôs no need to worry: another one is happening in a short time! This helps reduce pressure to sneak possibly unpolished features in close to the release deadline.</p>
<p>Thanks to this process, you can always check out the next build of Rust and verify for yourself that it‚Äôs easy to upgrade to: if a beta release doesn‚Äôt work as expected, you can report it to the team and get it fixed before the next stable release happens! Breakage in a beta release is relatively rare, but <code>rustc</code> is still a piece of software, and bugs do exist.</p>
<h3 id="maintenance-time"><a class="header" href="#maintenance-time">Maintenance time</a></h3>
<p>The Rust project supports the most recent stable version. When a new stable version is released, the old version reaches its end of life (EOL). This means each version is supported for six weeks.</p>
<h3 id="unstable-features"><a class="header" href="#unstable-features">Unstable Features</a></h3>
<p>There‚Äôs one more catch with this release model: unstable features. Rust uses a technique called ‚Äúfeature flags‚Äù to determine what features are enabled in a given release. If a new feature is under active development, it lands on <code>master</code>, and therefore, in nightly, but behind a <em>feature flag</em>. If you, as a user, wish to try out the work-in-progress feature, you can, but you must be using a nightly release of Rust and annotate your source code with the appropriate flag to opt in.</p>
<p>If you‚Äôre using a beta or stable release of Rust, you can‚Äôt use any feature flags. This is the key that allows us to get practical use with new features before we declare them stable forever. Those who wish to opt into the bleeding edge can do so, and those who want a rock-solid experience can stick with stable and know that their code won‚Äôt break. Stability without stagnation.</p>
<p>This book only contains information about stable features, as in-progress features are still changing, and surely they‚Äôll be different between when this book was written and when they get enabled in stable builds. You can find documentation for nightly-only features online.</p>
<h3 id="rustup-and-the-role-of-rust-nightly"><a class="header" href="#rustup-and-the-role-of-rust-nightly">Rustup and the Role of Rust Nightly</a></h3>
<p>Rustup makes it easy to change between different release channels of Rust, on a global or per-project basis. By default, you‚Äôll have stable Rust installed. To install nightly, for example:</p>
<pre><code class="language-console">$ rustup toolchain install nightly
</code></pre>
<p>You can see all of the <em>toolchains</em> (releases of Rust and associated components) you have installed with <code>rustup</code> as well. Here‚Äôs an example on one of your authors‚Äô Windows computer:</p>
<pre><code class="language-powershell">&gt; rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
</code></pre>
<p>As you can see, the stable toolchain is the default. Most Rust users use stable most of the time. You might want to use stable most of the time, but use nightly on a specific project, because you care about a cutting-edge feature. To do so, you can use <code>rustup override</code> in that project‚Äôs directory to set the nightly toolchain as the one <code>rustup</code> should use when you‚Äôre in that directory:</p>
<pre><code class="language-console">$ cd ~/projects/needs-nightly
$ rustup override set nightly
</code></pre>
<p>Now, every time you call <code>rustc</code> or <code>cargo</code> inside of <em>~/projects/needs-nightly</em>, <code>rustup</code> will make sure that you are using nightly Rust, rather than your default of stable Rust. This comes in handy when you have a lot of Rust projects!</p>
<h3 id="the-rfc-process-and-teams"><a class="header" href="#the-rfc-process-and-teams">The RFC Process and Teams</a></h3>
<p>So how do you learn about these new features? Rust‚Äôs development model follows a <em>Request For Comments (RFC) process</em>. If you‚Äôd like an improvement in Rust, you can write up a proposal, called an RFC.</p>
<p>Anyone can write RFCs to improve Rust, and the proposals are reviewed and discussed by the Rust team, which is comprised of many topic subteams. There‚Äôs a full list of the teams <a href="https://www.rust-lang.org/governance">on Rust‚Äôs website</a>, which includes teams for each area of the project: language design, compiler implementation, infrastructure, documentation, and more. The appropriate team reads the proposal and the comments, writes some comments of their own, and eventually, there‚Äôs consensus to accept or reject the feature.</p>
<p>If the feature is accepted, an issue is opened on the Rust repository, and someone can implement it. The person who implements it very well may not be the person who proposed the feature in the first place! When the implementation is ready, it lands on the <code>master</code> branch behind a feature gate, as we discussed in the <a href="appendix-07-nightly-rust.html#unstable-features">‚ÄúUnstable Features‚Äù</a><!-- ignore --> section.</p>
<p>After some time, once Rust developers who use nightly releases have been able to try out the new feature, team members will discuss the feature, how it‚Äôs worked out on nightly, and decide if it should make it into stable Rust or not. If the decision is to move forward, the feature gate is removed, and the feature is now considered stable! It rides the trains into a new stable release of Rust.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
