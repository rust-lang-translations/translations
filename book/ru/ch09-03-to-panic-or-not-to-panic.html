<!DOCTYPE HTML>
<html lang="ru" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Когда следует использовать panic!? - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch09-03-to-panic-or-not-to-panic.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch09-03-to-panic-or-not-to-panic.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ru");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Когда-следует-использовать-panic"><a class="header" href="#Когда-следует-использовать-panic">Когда следует использовать <code>panic!</code>?</a></h2>
<p>So, how do you decide when you should call <code>panic!</code> and when you should return <code>Result</code>? When code panics, there’s no way to recover. You could call <code>panic!</code> for any error situation, whether there’s a possible way to recover or not, but then you’re making the decision that a situation is unrecoverable on behalf of the calling code. When you choose to return a <code>Result</code> value, you give the calling code options. The calling code could choose to attempt to recover in a way that’s appropriate for its situation, or it could decide that an <code>Err</code> value in this case is unrecoverable, so it can call <code>panic!</code> and turn your recoverable error into an unrecoverable one. Therefore, returning <code>Result</code> is a good default choice when you’re defining a function that might fail.</p>
<p>Если вы пишете демонстративные примеры, прототипы или тесты, более уместно будет писать код, который паникует вместо того, чтобы пытаться возвращать <code>Result</code>. Давайте рассмотрим причины этого выбора, а затем мы обсудим ситуации, в которых компилятор не может доказать, что ошибка невозможна, но вы, как человек, можете это сделать. Глава будет заканчиваться некоторыми общими принципами того, как решить, стоит ли паниковать в библиотечном коде.</p>
<h3 id="Примеры-прототипы-и-тесты"><a class="header" href="#Примеры-прототипы-и-тесты">Примеры, прототипы и тесты</a></h3>
<p>Когда вы пишете пример, иллюстрирующий некоторую концепцию, наличие хорошего кода обработки ошибок может сделать пример менее понятным. Понятно, что в примерах вызов метода <code>unwrap</code>, который может привести к панике, является лишь обозначением способа обработки ошибок в приложении, который может отличаться в зависимости от того, что делает остальная часть кода.</p>
<p>Similarly, the <code>unwrap</code> and <code>expect</code> methods are very handy when you’re prototyping and you’re not yet ready to decide how to handle errors. They leave clear markers in your code for when you’re ready to make your program more robust.</p>
<p>Если в тесте происходит сбой при вызове метода, то вы бы хотели, чтобы весь тест не прошёл, даже если этот метод не является тестируемой функциональностью. Поскольку вызов <code>panic!</code> — это способ, которым тест помечается как провалившийся, использование <code>unwrap</code> или <code>expect</code> — именно то, что нужно.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="cases-in-which-you-have-more-information-than-the-compiler"></a></p>
<h3 id="when-you-have-more-information-than-the-compiler"><a class="header" href="#when-you-have-more-information-than-the-compiler">When You Have More Information Than the Compiler</a></h3>
<p>It would also be appropriate to call <code>expect</code> when you have some other logic that ensures that the <code>Result</code> will have an <code>Ok</code> value, but the logic isn’t something the compiler understands. You’ll still have a <code>Result</code> value that you need to handle: Whatever operation you’re calling still has the possibility of failing in general, even though it’s logically impossible in your particular situation. If you can ensure by manually inspecting the code that you’ll never have an <code>Err</code> variant, it’s perfectly acceptable to call <code>expect</code> and document the reason you think you’ll never have an <code>Err</code> variant in the argument text. Here’s an example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    use std::net::IpAddr;

    let home: IpAddr = "127.0.0.1"
        .parse()
        .expect("Hardcoded IP address should be valid");
<span class="boring">}</span></code></pre></pre>
<p>We’re creating an <code>IpAddr</code> instance by parsing a hardcoded string. We can see that <code>127.0.0.1</code> is a valid IP address, so it’s acceptable to use <code>expect</code> here. However, having a hardcoded, valid string doesn’t change the return type of the <code>parse</code> method: We still get a <code>Result</code> value, and the compiler will still make us handle the <code>Result</code> as if the <code>Err</code> variant is a possibility because the compiler isn’t smart enough to see that this string is always a valid IP address. If the IP address string came from a user rather than being hardcoded into the program and therefore <em>did</em> have a possibility of failure, we’d definitely want to handle the <code>Result</code> in a more robust way instead. Mentioning the assumption that this IP address is hardcoded will prompt us to change <code>expect</code> to better error-handling code if, in the future, we need to get the IP address from some other source instead.</p>
<h3 id="Руководство-по-обработке-ошибок"><a class="header" href="#Руководство-по-обработке-ошибок">Руководство по обработке ошибок</a></h3>
<p>Желательно, чтобы код паниковал, если он может оказаться в некорректное состоянии. <em>Некорректное состояние</em> — это состояние, когда некоторое допущение, гарантия, контракт или инвариант были нарушены. Например, когда недопустимые, противоречивые или пропущенные значения передаются в ваш код, плюс что-нибудь ещё из этого списка:</p>
<ul>
<li>Некорректное состояние неожиданно (не следует путать с "редкими случаями" — например, если пользователь ввёл данные в некорректном формате, это не будет неожиданностью; такое следует обрабатывать).</li>
<li>Весь следующий код не проводит проверок на данное (плохое) состояние, рассчитывая, что оно не происходит.</li>
<li>Нет хорошего способа закодировать данную информацию в типах, которые вы используете. Мы рассмотрим пример того, что мы имеем в виду, в разделе <a href="ch18-03-oo-design-patterns.html#%D0%9A%D0%BE%D0%B4%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B2-%D1%82%D0%B8%D0%BF%D0%B0%D1%85-%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B9-%D0%B8-%D0%BF%D0%BE%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F">"Кодирование в типах состояний и поведения"</a><!-- ignore --> Главы 18.</li>
</ul>
<p>If someone calls your code and passes in values that don’t make sense, it’s best to return an error if you can so that the user of the library can decide what they want to do in that case. However, in cases where continuing could be insecure or harmful, the best choice might be to call <code>panic!</code> and alert the person using your library to the bug in their code so that they can fix it during development. Similarly, <code>panic!</code> is often appropriate if you’re calling external code that is out of your control and returns an invalid state that you have no way of fixing.</p>
<p>Однако, когда сбой ождиаем, лучше вернуть <code>Result</code>, чем выполнить вызов <code>panic!</code>. В качестве примера можно привести синтаксический анализатор, которому передали неправильно сформированные данные, или HTTP-запрос, возвращающий статус, указывающий на то, что вы достигли ограничения на частоту запросов. В этих случаях возврат <code>Result</code> означает, что ошибка является ожидаемой и вызывающий код должен решить, как её обрабатывать.</p>
<p>When your code performs an operation that could put a user at risk if it’s called using invalid values, your code should verify the values are valid first and panic if the values aren’t valid. This is mostly for safety reasons: Attempting to operate on invalid data can expose your code to vulnerabilities. This is the main reason the standard library will call <code>panic!</code> if you attempt an out-of-bounds memory access: Trying to access memory that doesn’t belong to the current data structure is a common security problem. Functions often have <em>contracts</em>: Their behavior is only guaranteed if the inputs meet particular requirements. Panicking when the contract is violated makes sense because a contract violation always indicates a caller-side bug, and it’s not a kind of error you want the calling code to have to explicitly handle. In fact, there’s no reasonable way for calling code to recover; the calling <em>programmers</em> need to fix the code. Contracts for a function, especially when a violation will cause a panic, should be explained in the API documentation for the function.</p>
<p>However, having lots of error checks in all of your functions would be verbose and annoying. Fortunately, you can use Rust’s type system (and thus the type checking done by the compiler) to do many of the checks for you. If your function has a particular type as a parameter, you can proceed with your code’s logic knowing that the compiler has already ensured that you have a valid value. For example, if you have a type rather than an <code>Option</code>, your program expects to have <em>something</em> rather than <em>nothing</em>. Your code then doesn’t have to handle two cases for the <code>Some</code> and <code>None</code> variants: It will only have one case for definitely having a value. Code trying to pass nothing to your function won’t even compile, so your function doesn’t have to check for that case at runtime. Another example is using an unsigned integer type such as <code>u32</code>, which ensures that the parameter is never negative.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="creating-custom-types-for-validation"></a></p>
<h3 id="custom-types-for-validation"><a class="header" href="#custom-types-for-validation">Custom Types for Validation</a></h3>
<p>Let’s take the idea of using Rust’s type system to ensure that we have a valid value one step further and look at creating a custom type for validation. Recall the guessing game in Chapter 2 in which our code asked the user to guess a number between 1 and 100. We never validated that the user’s guess was between those numbers before checking it against our secret number; we only validated that the guess was positive. In this case, the consequences were not very dire: Our output of “Too high” or “Too low” would still be correct. But it would be a useful enhancement to guide the user toward valid guesses and have different behavior when the user guesses a number that’s out of range versus when the user types, for example, letters instead.</p>
<p>Один из способов добиться этого — пытаться разобрать введённое значение как <code>i32</code>, а не как <code>u32</code>, чтобы разрешить отрицательные числа, а затем добавить проверку на принадлежность числа диапазону; например, так:</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Угадайте число!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    loop {
        // --код сокращён--

<span class="boring">        println!("Введите свою догадку.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("Не удалось прочесть ввод.");
</span><span class="boring">
</span>        let guess: i32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        if guess &lt; 1 || guess &gt; 100 {
            println!("Загаданное число находится в пределах от 1 до 100.");
            continue;
        }

        match guess.cmp(&amp;secret_number) {
            // --код сокращён--
<span class="boring">            Ordering::Less =&gt; println!("Слишком маленькое!"),
</span><span class="boring">            Ordering::Greater =&gt; println!("Слишком большое!"),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!("Вы победили!");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span>    }
<span class="boring">}</span></code></pre>
</Listing>
<p>Выражение <code>if</code> проверяет, находится ли наше значение вне диапазона, сообщает пользователю о проблеме и вызывает <code>continue</code>, чтобы начать следующую итерацию цикла и попросить ввести другое число. После выражения <code>if</code> мы можем продолжить сравнение значения <code>guess</code> с загаданным числом, зная, что <code>guess</code> лежит в диапазоне от 1 до 100.</p>
<p>However, this is not an ideal solution: If it were absolutely critical that the program only operated on values between 1 and 100, and it had many functions with this requirement, having a check like this in every function would be tedious (and might impact performance).</p>
<p>Instead, we can make a new type in a dedicated module and put the validations in a function to create an instance of the type rather than repeating the validations everywhere. That way, it’s safe for functions to use the new type in their signatures and confidently use the values they receive. Listing 9-13 shows one way to define a <code>Guess</code> type that will only create an instance of <code>Guess</code> if the <code>new</code> function receives a value between 1 and 100.</p>
<Listing number="9-13" caption="A `Guess` type that will only continue with values between 1 and 100" file-name="src/guessing_game.rs">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!("Догадка {value} не принадлежит пределу от 1 до 100.");
        }

        Guess { value }
    }

    pub fn value(&amp;self) -&gt; i32 {
        self.value
    }
}
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>Note that this code in <em>src/guessing_game.rs</em> depends on adding a module declaration <code>mod guessing_game;</code> in <em>src/lib.rs</em> that we haven’t shown here. Within this new module’s file, we define a struct named <code>Guess</code> that has a field named <code>value</code> that holds an <code>i32</code>. This is where the number will be stored.</p>
<p>Then, we implement an associated function named <code>new</code> on <code>Guess</code> that creates instances of <code>Guess</code> values. The <code>new</code> function is defined to have one parameter named <code>value</code> of type <code>i32</code> and to return a <code>Guess</code>. The code in the body of the <code>new</code> function tests <code>value</code> to make sure it’s between 1 and 100. If <code>value</code> doesn’t pass this test, we make a <code>panic!</code> call, which will alert the programmer who is writing the calling code that they have a bug they need to fix, because creating a <code>Guess</code> with a <code>value</code> outside this range would violate the contract that <code>Guess::new</code> is relying on. The conditions in which <code>Guess::new</code> might panic should be discussed in its public-facing API documentation; we’ll cover documentation conventions indicating the possibility of a <code>panic!</code> in the API documentation that you create in Chapter 14. If <code>value</code> does pass the test, we create a new <code>Guess</code> with its <code>value</code> field set to the <code>value</code> parameter and return the <code>Guess</code>.</p>
<p>Next, we implement a method named <code>value</code> that borrows <code>self</code>, doesn’t have any other parameters, and returns an <code>i32</code>. This kind of method is sometimes called a <em>getter</em> because its purpose is to get some data from its fields and return it. This public method is necessary because the <code>value</code> field of the <code>Guess</code> struct is private. It’s important that the <code>value</code> field be private so that code using the <code>Guess</code> struct is not allowed to set <code>value</code> directly: Code outside the <code>guessing_game</code> module <em>must</em> use the <code>Guess::new</code> function to create an instance of <code>Guess</code>, thereby ensuring that there’s no way for a <code>Guess</code> to have a <code>value</code> that hasn’t been checked by the conditions in the <code>Guess::new</code> function.</p>
<p>Функция, которая принимает или возвращает только числа от 1 до 100, может объявить в своей сигнатуре, что она принимает или возвращает <code>Guess</code>, а не <code>i32</code>. Таким образом, не будет необходимости делать дополнительные проверки в теле такой функции.</p>
<h2 id="Подведём-итоги"><a class="header" href="#Подведём-итоги">Подведём итоги</a></h2>
<p>Функции обработки ошибок в Rust призваны помочь написанию более надёжного кода. Макрос <code>panic!</code> сигнализирует, что ваша программа находится в состоянии, которое она не может обработать, и позволяет сказать программе, чтобы та прекратила своё исполнение, вместо попытки продолжать исполнение с некорректными или неверными значениями. Перечисление <code>Result</code> использует систему типов Rust, чтобы сообщать, что операции могут завершиться неудачей, и чтобы ваш код мог восстановить исполнение. Можно использовать <code>Result</code>, чтобы сообщать вызывающему коду, что он должен обрабатывать потенциальный успех или потенциальную неудачу. Правильное использование <code>panic!</code> и <code>Result</code> сделает ваш код более надёжным перед лицом неизбежных проблем.</p>
<p>Теперь, когда вы увидели полезные способы использования обобщённых типов <code>Option</code> и <code>Result</code>, мы поговорим о том, как вообще работают обобщённые типы и как вы можете использовать их в своём коде.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch09-02-recoverable-errors-with-result.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch10-00-generics.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch09-02-recoverable-errors-with-result.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch10-00-generics.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
