<!DOCTYPE HTML>
<html lang="ru" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Defining Shared Behavior with Traits - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch10-02-traits.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch10-02-traits.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ru");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Old headings. Do not remove or links may break. -->
<p><a id="traits-defining-shared-behavior"></a></p>
<h2 id="defining-shared-behavior-with-traits"><a class="header" href="#defining-shared-behavior-with-traits">Defining Shared Behavior with Traits</a></h2>
<p><em>Трейт</em> определяет функциональность, которой обладает конкретный тип и которая может использоваться с другими типами. Мы можем использовать трейты для определения общего поведения абстрактным образом. Мы можем использовать <em>ограничение по трейтам</em>, чтобы указать, что обобщённый тип может быть заменён на любой тип с некоторым известным поведением.</p>
<blockquote>
<p>Примечание: Трейты схожи с таким механизмом как <em>интерфейсы</em>, но всё же они различаются.</p>
</blockquote>
<h3 id="Определение-трейта"><a class="header" href="#Определение-трейта">Определение трейта</a></h3>
<p>Поведение типа определяется теми методами, которые мы можем вызвать на данном типе. Различные типы разделяют одинаковое поведение, если мы можем вызвать одни и те же методы у этих типов. Определение трейтов — это способ сгруппировать сигнатуры методов вместе для того, чтобы описать общее поведение, необходимое для достижения определённой цели.</p>
<p>For example, let’s say we have multiple structs that hold various kinds and amounts of text: a <code>NewsArticle</code> struct that holds a news story filed in a particular location and a <code>SocialPost</code> that can have, at most, 280 characters along with metadata that indicates whether it was a new post, a repost, or a reply to another post.</p>
<p>We want to make a media aggregator library crate named <code>aggregator</code> that can display summaries of data that might be stored in a <code>NewsArticle</code> or <code>SocialPost</code> instance. To do this, we need a summary from each type, and we’ll request that summary by calling a <code>summarize</code> method on an instance. Listing 10-12 shows the definition of a public <code>Summary</code> trait that expresses this behavior.</p>
<Listing number="10-12" file-name="src/lib.rs" caption="A `Summary` trait that consists of the behavior provided by a `summarize` method">
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}</code></pre>
</Listing>
<p>Здесь мы объявляем трейт с использованием ключевого слова <code>trait</code>, а затем указываем его название (в нашем случае — <code>Summary</code>). Также мы объявляем трейт как <code>pub</code>, что позволяет крейтам, зависящим от нашего крейта, использовать наш трейт, примеры чего мы увидим далее. Внутри фигурных скобок объявляются сигнатуры методов, которые описывают поведение типов, реализующих данный трейт; в данном случае, поведение определяется только одной сигнатурой метода <code>fn summarize(&amp;self) -&gt; String</code>.</p>
<p>После сигнатуры метода, вместо его тела мы пишем точку с запятой. Каждый тип,  реализующий данный трейт, должен будет предоставить свою собственную реализацию данного метода. Компилятор обеспечит, что любой тип, реализующий трейт <code>Summary</code>, будет также иметь и метод <code>summarize</code>, объявленный с точно такой же сигнатурой.</p>
<p>A trait can have multiple methods in its body: The method signatures are listed one per line, and each line ends in a semicolon.</p>
<h3 id="Реализация-трейта-для-типа"><a class="header" href="#Реализация-трейта-для-типа">Реализация трейта для типа</a></h3>
<p>Now that we’ve defined the desired signatures of the <code>Summary</code> trait’s methods, we can implement it on the types in our media aggregator. Listing 10-13 shows an implementation of the <code>Summary</code> trait on the <code>NewsArticle</code> struct that uses the headline, the author, and the location to create the return value of <code>summarize</code>. For the <code>SocialPost</code> struct, we define <code>summarize</code> as the username followed by the entire text of the post, assuming that the post content is already limited to 280 characters.</p>
<Listing number="10-13" file-name="src/lib.rs" caption="Implementing the `Summary` trait on the `NewsArticle` and `SocialPost` types">
<pre><code class="language-rust noplayground"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!("{} ({} из {})", self.headline, self.author, self.location)
    }
}

pub struct SocialPost {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub repost: bool,
}

impl Summary for SocialPost {
    fn summarize(&amp;self) -&gt; String {
        format!("{}: {}", self.username, self.content)
    }
}</code></pre>
</Listing>
<p>Реализация трейта для типа аналогична реализации обычных методов. Разница в том, что после <code>impl</code> мы указываем имя трейта, который мы хотим реализовать, затем используем ключевое слово <code>for</code>, а затем указываем имя типа, для которого мы хотим сделать реализацию трейта. Внутри блока <code>impl</code> мы помещаем сигнатуру метода, объявленную в трейте. Вместо точки с запятой в конце, после каждой сигнатуры пишутся фигурные скобки, и тело метода заполняется конкретным кодом, реализующим поведение, которое мы хотим получить от методов трейта для конкретного типа.</p>
<p>Now that the library has implemented the <code>Summary</code> trait on <code>NewsArticle</code> and <code>SocialPost</code>, users of the crate can call the trait methods on instances of <code>NewsArticle</code> and <code>SocialPost</code> in the same way we call regular methods. The only difference is that the user must bring the trait into scope as well as the types. Here’s an example of how a binary crate could use our <code>aggregator</code> library crate:</p>
<pre><code class="language-rust ignore">use aggregator::{SocialPost, Summary};

fn main() {
    let post = SocialPost {
        username: String::from("horse_ebooks"),
        content: String::from(
            "конечно, вы уже наверное знаете, народ, ...",
        ),
        reply: false,
        repost: false,
    };

    println!("1 new post: {}", post.summarize());
}</code></pre>
<p>This code prints <code>1 new post: horse_ebooks: of course, as you probably already know, people</code>.</p>
<p>Other crates that depend on the <code>aggregator</code> crate can also bring the <code>Summary</code> trait into scope to implement <code>Summary</code> on their own types. One restriction to note is that we can implement a trait on a type only if either the trait or the type, or both, are local to our crate. For example, we can implement standard library traits like <code>Display</code> on a custom type like <code>SocialPost</code> as part of our <code>aggregator</code> crate functionality because the type <code>SocialPost</code> is local to our <code>aggregator</code> crate. We can also implement <code>Summary</code> on <code>Vec&lt;T&gt;</code> in our <code>aggregator</code> crate because the trait <code>Summary</code> is local to our <code>aggregator</code> crate.</p>
<p>But we can’t implement external traits on external types. For example, we can’t implement the <code>Display</code> trait on <code>Vec&lt;T&gt;</code> within our <code>aggregator</code> crate, because <code>Display</code> and <code>Vec&lt;T&gt;</code> are both defined in the standard library and aren’t local to our <code>aggregator</code> crate. This restriction is part of a property called <em>coherence</em>, and more specifically the <em>orphan rule</em>, so named because the parent type is not present. This rule ensures that other people’s code can’t break your code and vice versa. Without the rule, two crates could implement the same trait for the same type, and Rust wouldn’t know which implementation to use.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="default-implementations"></a></p>
<h3 id="using-default-implementations"><a class="header" href="#using-default-implementations">Using Default Implementations</a></h3>
<p>Иногда бывает полезно задать поведение по умолчанию для некоторых или всех методов трейта вместо того, чтобы требовать реализации всех методов для каждого типа. Такое поведение по умолчанию можно будет (уже непосредственно при реализации трейта) как оставить, так и переопределить.</p>
<p>В Листинге 10-14 показано, мы определяем сводку по умолчанию для метода <code>summarize</code> трейта <code>Summary</code>, вместо того, чтобы определять лишь сигнатуру метода, как мы делали ранее в Листинге 10-12.</p>
<Listing number="10-14" file-name="src/lib.rs" caption="Defining a `Summary` trait with a default implementation of the `summarize` method">
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        String::from("(Читать далее...)")
    }
}
<span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {}
</span><span class="boring">
</span><span class="boring">pub struct SocialPost {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for SocialPost {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>Для использования реализации по умолчанию при создании сводки экземпляров <code>NewsArticle</code>, мы указываем пустой блок при <code>impl Summary for NewsArticle {}</code>.</p>
<p>Хотя мы больше не определяем метод <code>summarize</code> непосредственно на <code>NewsArticle</code>, мы предоставили реализацию по умолчанию и указали, что <code>NewsArticle</code> реализует трейт <code>Summary</code>. В результате мы всё ещё можем вызвать метод <code>summarize</code> у экземпляра <code>NewsArticle</code>; например, вот так:</p>
<pre><code class="language-rust ignore"><span class="boring">use aggregator::{self, NewsArticle, Summary};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let article = NewsArticle {
        headline: String::from("«Питтсбург Пингвинз» выиграли Кубок Стэнли!"),
        location: String::from("Питтсбург, штат Пенсильвания, США"),
        author: String::from("Пингвин Айсбург"),
        content: String::from(
            "«Питтсбург Пингвинз» вновь оказалась лучшей \
             хоккейной командой в НХЛ.",
        ),
    };

    println!("Новости! {}", article.summarize());
<span class="boring">}</span></code></pre>
<p>Этот код печатает <code>Новости! (Читать далее...)</code>.</p>
<p>Creating a default implementation doesn’t require us to change anything about the implementation of <code>Summary</code> on <code>SocialPost</code> in Listing 10-13. The reason is that the syntax for overriding a default implementation is the same as the syntax for implementing a trait method that doesn’t have a default implementation.</p>
<p>Реализации по умолчанию могут вызывать другие методы в том же трейте, даже если эти другие методы не имеют реализации по умолчанию. Таким образом, трейт может предоставить много полезной функциональности, а от разработчиков требует указывать только небольшую его часть. Например, мы могли бы определить трейт <code>Summary</code>, имеющий метод <code>summarize_author</code> без реализации по умолчанию, а затем определить метод <code>summarize</code> который имеет реализацию по умолчанию, вызывающую метод <code>summarize_author</code>:</p>
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        format!("(Читать далее, от {}...)", self.summarize_author())
    }
}
<span class="boring">
</span><span class="boring">pub struct SocialPost {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for SocialPost {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String {
</span><span class="boring">        format!("@{}", self.username)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Чтобы использовать такую версию трейта <code>Summary</code>, при реализации трейта для типа нужно определить только метод <code>summarize_author</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String;
</span><span class="boring">
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("(Читать далее, от {}...)", self.summarize_author())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct SocialPost {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Summary for SocialPost {
    fn summarize_author(&amp;self) -&gt; String {
        format!("@{}", self.username)
    }
}</code></pre>
<p>After we define <code>summarize_author</code>, we can call <code>summarize</code> on instances of the <code>SocialPost</code> struct, and the default implementation of <code>summarize</code> will call the definition of <code>summarize_author</code> that we’ve provided. Because we’ve implemented <code>summarize_author</code>, the <code>Summary</code> trait has given us the behavior of the <code>summarize</code> method without requiring us to write any more code. Here’s what that looks like:</p>
<pre><code class="language-rust ignore"><span class="boring">use aggregator::{self, SocialPost, Summary};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let post = SocialPost {
        username: String::from("horse_ebooks"),
        content: String::from(
            "конечно, вы уже наверное знаете, народ, ...",
        ),
        reply: false,
        repost: false,
    };

    println!("1 new post: {}", post.summarize());
<span class="boring">}</span></code></pre>
<p>This code prints <code>1 new post: (Read more from @horse_ebooks...)</code>.</p>
<p>Обратите внимание, что невозможно вызвать реализацию по умолчанию из переопределённой реализации того же метода.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="traits-as-parameters"></a></p>
<h3 id="using-traits-as-parameters"><a class="header" href="#using-traits-as-parameters">Using Traits as Parameters</a></h3>
<p>Now that you know how to define and implement traits, we can explore how to use traits to define functions that accept many different types. We’ll use the <code>Summary</code> trait we implemented on the <code>NewsArticle</code> and <code>SocialPost</code> types in Listing 10-13 to define a <code>notify</code> function that calls the <code>summarize</code> method on its <code>item</code> parameter, which is of some type that implements the <code>Summary</code> trait. To do this, we use the <code>impl Trait</code> syntax, like this:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{} ({} из {})", self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct SocialPost {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for SocialPost {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn notify(item: &amp;impl Summary) {
    println!("Срочные новости! {}", item.summarize());
}</code></pre>
<p>Instead of a concrete type for the <code>item</code> parameter, we specify the <code>impl</code> keyword and the trait name. This parameter accepts any type that implements the specified trait. In the body of <code>notify</code>, we can call any methods on <code>item</code> that come from the <code>Summary</code> trait, such as <code>summarize</code>. We can call <code>notify</code> and pass in any instance of <code>NewsArticle</code> or <code>SocialPost</code>. Code that calls the function with any other type, such as a <code>String</code> or an <code>i32</code>, won’t compile, because those types don’t implement <code>Summary</code>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="fixing-the-largest-function-with-trait-bounds"></a></p>
<h4 id="Ограничение-по-трейтам"><a class="header" href="#Ограничение-по-трейтам">Ограничение по трейтам</a></h4>
<p>Синтаксис <code>impl Trait</code> работает для простых случаев, но на самом деле является  синтаксическим сахаром для более длинной конструкции — <em>ограничения по трейтам</em>:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item: &amp;T) {
    println!("Срочные новости! {}", item.summarize());
}</code></pre>
<p>Эта более длинная форма эквивалентна предыдущему примеру, но она более многословна. Мы помещаем объявление параметра обобщённого типа с ограничением по трейту после двоеточия внутри угловых скобок.</p>
<p>Синтаксис <code>impl Trait</code> удобен, он более коротко выражает нужное в простых случах, в то время как более полный синтаксис с ограничением по трейтам может выразить большую сложность прочих случаев. Например, у нас может быть два аргумента, которые реализуют трейт <code>Summary</code>. Использование для этого синтаксиса <code>impl Trait</code> выглядит так:</p>
<pre><code class="language-rust ignore">pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {</code></pre>
<p>Использовать <code>impl Trait</code> удобнее, если мы хотим разрешить функции иметь разные типы для <code>item1</code> и <code>item2</code> (но оба типа должны реализовывать <code>Summary</code>). Если же мы хотим заставить оба параметра иметь один и тот же тип, то нам следует использовать вот такое ограничение по трейту:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {</code></pre>
<p>Обобщённый тип <code>T</code> указан для типов параметров <code>item1</code> и <code>item2</code> и ограничивает функцию так, что конкретные значения типов аргументов <code>item1</code> и <code>item2</code> должны быть одинаковыми.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="specifying-multiple-trait-bounds-with-the--syntax"></a></p>
<h4 id="multiple-trait-bounds-with-the--syntax"><a class="header" href="#multiple-trait-bounds-with-the--syntax">Multiple Trait Bounds with the <code>+</code> Syntax</a></h4>
<p>We can also specify more than one trait bound. Say we wanted <code>notify</code> to use display formatting as well as <code>summarize</code> on <code>item</code>: We specify in the <code>notify</code> definition that <code>item</code> must implement both <code>Display</code> and <code>Summary</code>. We can do so using the <code>+</code> syntax:</p>
<pre><code class="language-rust ignore">pub fn notify(item: &amp;(impl Summary + Display)) {</code></pre>
<p>Оператор <code>+</code> также можно использовать и для ограничения обобщённого типа по его трейтам:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {</code></pre>
<p>Поскольку ограничение по двум трейтам предписывает аргументу реализовывать оба трейта, тело функции <code>notify</code> может и вызывать <code>summarize</code>, и использовать <code>{}</code> для использования <code>item</code> в форматированном выводе.</p>
<h4 id="Вынос-за-where-ограничений-по-трейтам"><a class="header" href="#Вынос-за-where-ограничений-по-трейтам">Вынос за <code>where</code> ограничений по трейтам</a></h4>
<p>Использование слишком большого количества ограничений по трейтам имеет свои недостатки. Каждый обобщённый тип имеет свои ограничения по трейтам, поэтому функции с несколькими параметрами обобщённого типа могут содержать очень много информации об ограничениях между названием функции и списком её параметров, что затрудняет чтение её сигнатуры. По этой причине в Rust есть альтернативный синтаксис для определения ограничений по трейтам: размещение их за ключевым словом <code>where</code> после сигнатуры функции. Поэтому вместо того, чтобы писать так:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {</code></pre>
<p>можно использовать <code>where</code>, вот так:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
where
    T: Display + Clone,
    U: Clone + Debug,
{
<span class="boring">    unimplemented!()
</span><span class="boring">}</span></code></pre>
<p>This function’s signature is less cluttered: The function name, parameter list, and return type are close together, similar to a function without lots of trait bounds.</p>
<h3 id="Возврат-значений-типа-реализующего-определённые-трейты"><a class="header" href="#Возврат-значений-типа-реализующего-определённые-трейты">Возврат значений типа, реализующего определённые трейты</a></h3>
<p>Также можно использовать запись <code>impl Trait</code> вместо конкретного типа возвращаемого значения в сигнатуре функции, чтобы вернуть значение некоторого типа, реализующего трейт:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{} ({} из {})", self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct SocialPost {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for SocialPost {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable() -&gt; impl Summary {
    SocialPost {
        username: String::from("horse_ebooks"),
        content: String::from(
            "конечно, вы уже наверное знаете, народ, ...",
        ),
        reply: false,
        repost: false,
    }
}</code></pre>
<p>By using <code>impl Summary</code> for the return type, we specify that the <code>returns_summarizable</code> function returns some type that implements the <code>Summary</code> trait without naming the concrete type. In this case, <code>returns_summarizable</code> returns a <code>SocialPost</code>, but the code calling this function doesn’t need to know that.</p>
<p>Возможность возвращать тип, который определяется только реализуемым им трейтом, особенно полезна в контексте замыканий и итераторов, которые мы рассмотрим в Главе 13. Замыкания и итераторы создают типы, которые знает только компилятор, или же типы, которые очень долго указывать. Запись <code>impl Trait</code> позволяет кратко указать, что функция возвращает некоторый тип, который реализует трейт <code>Iterator</code> без необходимости писать очень длинный тип.</p>
<p>However, you can only use <code>impl Trait</code> if you’re returning a single type. For example, this code that returns either a <code>NewsArticle</code> or a <code>SocialPost</code> with the return type specified as <code>impl Summary</code> wouldn’t work:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{} ({} из {})", self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct SocialPost {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for SocialPost {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable(switch: bool) -&gt; impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                "«Питтсбург Пингвинз» выиграли Кубок Стэнли!",
            ),
            location: String::from("Питтсбург, штат Пенсильвания, США"),
            author: String::from("Пингвин Айсбург"),
            content: String::from(
                "«Питтсбург Пингвинз» вновь оказалась лучшей \
                 хоккейной командой в НХЛ.",
            ),
        }
    } else {
        SocialPost {
            username: String::from("horse_ebooks"),
            content: String::from(
                "конечно, вы уже наверное знаете, народ, ...",
            ),
            reply: false,
            repost: false,
        }
    }
}</code></pre>
<p>Returning either a <code>NewsArticle</code> or a <code>SocialPost</code> isn’t allowed due to restrictions around how the <code>impl Trait</code> syntax is implemented in the compiler. We’ll cover how to write a function with this behavior in the <a href="ch18-02-trait-objects.html#using-trait-objects-to-abstract-over-shared-behavior">“Using Trait Objects to Abstract over Shared Behavior”</a><!-- ignore --> section of Chapter 18.</p>
<h3 id="Использование-ограничений-по-трейту-для-избирательной-реализации-методов"><a class="header" href="#Использование-ограничений-по-трейту-для-избирательной-реализации-методов">Использование ограничений по трейту для избирательной реализации методов</a></h3>
<p>By using a trait bound with an <code>impl</code> block that uses generic type parameters, we can implement methods conditionally for types that implement the specified traits. For example, the type <code>Pair&lt;T&gt;</code> in Listing 10-15 always implements the <code>new</code> function to return a new instance of <code>Pair&lt;T&gt;</code> (recall from the <a href="ch05-03-method-syntax.html#method-syntax">“Method Syntax”</a><!-- ignore --> section of Chapter 5 that <code>Self</code> is a type alias for the type of the <code>impl</code> block, which in this case is <code>Pair&lt;T&gt;</code>). But in the next <code>impl</code> block, <code>Pair&lt;T&gt;</code> only implements the <code>cmp_display</code> method if its inner type <code>T</code> implements the <code>PartialOrd</code> trait that enables comparison <em>and</em> the <code>Display</code> trait that enables printing.</p>
<Listing number="10-15" file-name="src/lib.rs" caption="Conditionally implementing methods on a generic type depending on trait bounds">
<pre><code class="language-rust noplayground">use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self { x, y }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!("Слева ({}) — наибольшее", self.x);
        } else {
            println!("Справа ({}) — наибольшее", self.y);
        }
    }
}</code></pre>
</Listing>
<p>Мы также можем избирательно реализовать трейт для всех типов, которые реализуют другой трейт. Реализация трейта для всех типов, которые удовлетворяют ограничениям по трейтам, называются <em>сплошной реализацией</em>, и она широко используется в стандартной библиотеке Rust. Например, стандартная библиотека реализует трейт <code>ToString</code> для всех типов, которые реализуют трейт <code>Display</code>. Блок <code>impl</code>, делающий это, выглядит примерно так:</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --код сокращён--
}</code></pre>
<p>Благодаря такой сплошной реализации можно вызвать метод <code>to_string</code>, определённый трейтом <code>ToString</code>, для любого типа, который реализует трейт <code>Display</code>. Например, мы можем превратить целые числа в их соответствующие значения <code>String</code>, потому что целые числа реализуют трейт <code>Display</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = 3.to_string();
<span class="boring">}</span></code></pre></pre>
<p>В документации к трейтам, их сплошные реализации можно увидеть в разделе "Implementors".</p>
<p>Traits and trait bounds let us write code that uses generic type parameters to reduce duplication but also specify to the compiler that we want the generic type to have particular behavior. The compiler can then use the trait bound information to check that all the concrete types used with our code provide the correct behavior. In dynamically typed languages, we would get an error at runtime if we called a method on a type that didn’t define the method. But Rust moves these errors to compile time so that we’re forced to fix the problems before our code is even able to run. Additionally, we don’t have to write code that checks for behavior at runtime, because we’ve already checked at compile time. Doing so improves performance without having to give up the flexibility of generics.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch10-01-syntax.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch10-03-lifetime-syntax.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch10-01-syntax.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch10-03-lifetime-syntax.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
