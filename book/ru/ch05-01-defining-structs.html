<!DOCTYPE HTML>
<html lang="ru" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Определение и создание экземпляров структур - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch05-01-defining-structs.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch05-01-defining-structs.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ru");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Определение-и-создание-экземпляров-структур"><a class="header" href="#Определение-и-создание-экземпляров-структур">Определение и создание экземпляров структур</a></h2>
<p>Структуры похожи на <a href="ch03-02-data-types.html#%D0%A2%D0%B8%D0%BF-%D0%BA%D0%BE%D1%80%D1%82%D0%B5%D0%B6%D0%B0">кортежи</a><!-- ignore -->, так как оба позволяют хранить несколько связанных значений. Как и у кортежей, части структур могут быть разных типов. В отличие от кортежей, в структуре необходимо именовать каждую часть данных для понимания смысла значений. Добавление этих имён обеспечивает большую гибкость структур по сравнению с кортежами: не нужно полагаться на порядок данных для указания значений экземпляра или доступа к ним.</p>
<p>Чтобы определить структуры, мы вводим ключевое слово <code>struct</code> и название структуры. Название должно описывать значение частей данных, сгруппированных вместе. Далее, в фигурных скобках для каждого <em>поля</em> поочерёдно определяются имя и тип. Листинг 5-1 показывает структуру, которая хранит информацию об учётной записи пользователя:</p>
<Listing number="5-1" file-name="src/main.rs" caption="A `User` struct definition">
<pre><pre class="playground"><code class="language-rust edition2021">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p>После определения структуры можно создавать её <em>экземпляр</em>, назначая определённое значение с соответствующим типом данных каждому полю. Чтобы создать экземпляр структуры, мы указываем имя структуры, а затем добавляем фигурные скобки и включаем в них пары <em>ключ: значение</em>, где ключами являются имена полей, а значениями являются данные, которые мы хотим сохранить в полях. Нет необходимости чётко следовать порядку объявления полей в описании структуры (но это всё-таки желательно для удобства чтения). Другими словами, объявление структуры — это нечто вроде схемы нашей группы данных, в то время как экземпляр структуры использует эту схему, заполняя её определёнными данными. Например, пользователя можно объявить так, как показано в Листинге 5-2:</p>
<Listing number="5-2" file-name="src/main.rs" caption="Creating an instance of the `User` struct">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };
}</code></pre></pre>
</Listing>
<p>Чтобы получить конкретное значение из структуры, мы обращаемся к нему по имени поля через точку. Например, чтобы получить доступ к адресу электронной почты этого пользователя, мы пишем <code>user1.email</code>. Если экземпляр является изменяемым, мы можем поменять значение, используя точечную нотацию и присвоение к конкретному полю. В Листинге 5-3 показано, как изменить значение в поле <code>email</code> изменяемого экземпляра <code>User</code>.</p>
<Listing number="5-3" file-name="src/main.rs" caption="Changing the value in the `email` field of a `User` instance">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };

    user1.email = String::from("anotheremail@example.com");
}</code></pre></pre>
</Listing>
<p>Стоит отметить, что весь экземпляр структуры должен быть изменяемым; Rust не позволяет помечать изменяемыми отдельные поля. Как и для любого другого выражения, мы можем использовать выражение создания структуры в качестве последнего выражения тела функции для того, чтобы неявно вернуть новый экземпляр структуры.</p>
<p>В Листинге 5-4 показано, как функция <code>build_user</code> возвращает экземпляр <code>User</code> с указанными адресом и именем. Поле <code>active</code> получает значение <code>true</code>, а поле <code>sign_in_count</code> получает значение <code>1</code>.</p>
<Listing number="5-4" file-name="src/main.rs" caption="A `build_user` function that takes an email and username and returns a `User` instance">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        username: username,
        email: email,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from("someone@example.com"),
</span><span class="boring">        String::from("someusername123"),
</span><span class="boring">    );
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>В том, чтобы назвать параметры функции теми же именами, что и поля структуры, был смысл, но необходимость повторять <code>email</code> и <code>username</code> для названий полей и переменных несколько утомительна. Если структура имеет много полей, повторение каждого имени станет ещё более раздражающим. К счастью, есть удобное сокращение!</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="using-the-field-init-shorthand-when-variables-and-fields-have-the-same-name"></a></p>
<h3 id="Использование-сокращённой-инициализации-поля"><a class="header" href="#Использование-сокращённой-инициализации-поля">Использование сокращённой инициализации поля</a></h3>
<p>Так как в Листинге 5-4 имена параметров функции и полей структуры одни и те же, можно использовать синтаксис сокращённой инициализации поля, чтобы определить <code>build_user</code> так, чтобы он не содержал повторений <code>username</code> и <code>email</code>. Посмотрите на Листинг 5-5.</p>
<Listing number="5-5" file-name="src/main.rs" caption="A `build_user` function that uses field init shorthand because the `username` and `email` parameters have the same name as struct fields">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        username,
        email,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from("someone@example.com"),
</span><span class="boring">        String::from("someusername123"),
</span><span class="boring">    );
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>Здесь происходит создание нового экземпляра структуры <code>User</code>, которая имеет поле с именем <code>email</code>. Мы хотим установить поле структуры <code>email</code> значением параметра <code>email</code> функции <code>build_user</code>. Так как поле <code>email</code> и параметр функции <code>email</code> имеют одинаковое название, можно писать просто <code>email</code> вместо <code>email: email</code>.</p>
<h3 id="Создание-экземпляра-структуры-из-экземпляра-другой-структуры-с-помощью-синтаксиса-обновления-структуры"><a class="header" href="#Создание-экземпляра-структуры-из-экземпляра-другой-структуры-с-помощью-синтаксиса-обновления-структуры">Создание экземпляра структуры из экземпляра другой структуры с помощью синтаксиса обновления структуры</a></h3>
<p>Часто бывает нужно создать новый экземпляр структуры, который включает большинство значений из другого экземпляра, но некоторые из них изменяет. Это можно сделать с помощью <em>синтаксиса обновления структуры</em>.</p>
<p>В Листинге 5-6 показано, как в <code>user2</code> записывается новый экземпляр <code>User</code> без синтаксиса обновления. Мы задаём новое значение для <code>email</code>, но в остальном используем те же значения из <code>user1</code>, которую мы создали в Листинге 5-2.</p>
<Listing number="5-6" file-name="src/main.rs" caption="Creating a new `User` instance using all but one of the values from `user1`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // --код сокращён--
<span class="boring">
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from("someone@example.com"),
</span><span class="boring">        username: String::from("someusername123"),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span>
    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from("another@example.com"),
        sign_in_count: user1.sign_in_count,
    };
}</code></pre></pre>
</Listing>
<p>Используя синтаксис обновления структуры, можно получить тот же эффект, используя меньше кода, как показано в Листинге 5-7. Запись <code>..</code> указывает, что оставшиеся поля напрямую не устанавливаются, но должны иметь значения из указанного экземпляра.</p>
<Listing number="5-7" file-name="src/main.rs" caption="Using struct update syntax to set a new `email` value for a `User` instance but to use the rest of the values from `user1`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // --код сокращён--
<span class="boring">
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from("someone@example.com"),
</span><span class="boring">        username: String::from("someusername123"),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span>
    let user2 = User {
        email: String::from("another@example.com"),
        ..user1
    };
}</code></pre></pre>
</Listing>
<p>Код в Листинге 5-7 тоже создаёт экземпляр <code>user2</code>, который имеет другое значение <code>email</code>, но не меняет значения полей <code>username</code>, <code>active</code> и <code>sign_in_count</code> из <code>user1</code>. Конструкция <code>..user1</code> должна стоять последней; она указывает на получение значений всех оставшихся полей из соответствующих полей в <code>user1</code>, но перед этим мы можем указать свои значения для любых полей в любом порядке, независимо от порядка полей в определении структуры.</p>
<p>Стоит отметить, что синтаксис обновления структуры использует оператор <code>=</code> как оператор присваивания, потому что он перемещает данные, как мы видели в разделе <a href="ch04-01-what-is-ownership.html#%D0%92%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D0%B5-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85-%D0%B8-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D1%89%D0%B5%D0%BD%D0%B8%D1%8F">"Взаимодействие переменных и данных с помощью перемещения"</a><!-- ignore -->. В примере выше мы больше не можем использовать <code>user1</code> после создания  <code>user2</code>, потому что <code>String</code> в поле <code>username</code> из <code>user1</code> было перемещено в <code>user2</code>. Если бы мы задали <code>user2</code> новые значения <code>String</code> для <code>email</code> и <code>username</code>, и, таким образом, использовали только значения <code>active</code> и <code>sign_in_count</code> из <code>user1</code>, то <code>user1</code> всё ещё была бы действительной после создания <code>user2</code>. Оба типа <code>active</code> и <code>sign_in_count</code> реализуют трейт <code>Copy</code>, поэтому они ведут себя так, как мы обсуждали в разделе <a href="ch04-01-what-is-ownership.html#%D0%94%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5-%D1%80%D0%B0%D0%B7%D0%BC%D0%B5%D1%89%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%D1%81%D1%8F-%D1%82%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE-%D0%BD%D0%B0-%D1%81%D1%82%D0%B5%D0%BA%D0%B5-%D0%B2%D1%81%D0%B5%D0%B3%D0%B4%D0%B0-%D0%BA%D0%BE%D0%BF%D0%B8%D1%80%D1%83%D1%8E%D1%82%D1%81%D1%8F">"Данные, размещающиеся только на стеке, всегда копируются"</a><!-- ignore -->. Однако, в нашем примере мы всё ещё можем использовать запись <code>user1.email</code>, поскольку значение этого поля <em>не было</em> перемещено.</p>
<h3 id="Использование-кортежных-структур-без-имён-для-создания-разных-типов"><a class="header" href="#Использование-кортежных-структур-без-имён-для-создания-разных-типов">Использование кортежных структур без имён для создания разных типов</a></h3>
<p>Rust также поддерживает определение структур, похожих на кортежи, которые называются <em>кортежными структурами</em>. Кортежные структуры несут с собой дополнительный смысл, определяемый именем структуры, но при этом они не имеют имён для своих полей. Скорее, они просто хранят типы полей. Кортежные структуры полезны, когда вы хотите дать имя всему кортежу и сделать кортеж отличным от других кортежей, и когда именование каждого поля, как в обычной структуре, было бы многословным или избыточным.</p>
<p>Чтобы определить кортежную структуру, начните с ключевого слова <code>struct</code> и имени структуры, а следом припишите тип кортежа. Например, вот как определить и использовать две кортежные структуры с именами <code>Color</code> и <code>Point</code>:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021">struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}</code></pre></pre>
</Listing>
<p>Обратите внимание, что значения <code>black</code> и <code>origin</code> — это значения разных типов, потому что они являются экземплярами разных кортежных структур. Каждая определяемая вами структура имеет собственный тип, даже если поля внутри структуры, возможно, имеют все одинаковые типы. Например, функция с параметром типа <code>Color</code> не может принимать <code>Point</code> в качестве аргумента, пусть даже оба типа состоят из трёх значений <code>i32</code>. В остальном экземпляры кортежных структур похожи на кортежи в том смысле, что вы можете деструктурировать их на отдельные части и использовать для доступа к отдельному значению оператор <code>.</code>, за которой следует индекс.</p>
<h3 id="unit-подобные-структуры"><a class="header" href="#unit-подобные-структуры">Unit-подобные структуры</a></h3>
<p>Также можно определять структуры, не имеющие полей! Они называются <em>unit-подобными структурами</em>, поскольку ведут себя аналогично <code>()</code>, unit, о котором мы говорили в разделе ["Тип кортежа"] (ch03-02-data-types.html#Тип-кортежа)<!-- ignore -->. Unit-подобные структуры могут быть полезны, когда требуется реализовать трейт для некоторого типа, но у вас нет данных, которые нужно было бы хранить в самом типе. Мы обсудим трейты в Главе 10. Вот пример объявления и создания экземпляра unit-структуры с именем <code>AlwaysEqual</code>:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021">struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}</code></pre></pre>
</Listing>
<p>Чтобы определить <code>AlwaysEqual</code>, мы используем ключевое слово <code>struct</code>, желаемое имя, а затем точку с запятой. Не нужны ни фигурные, ни круглые скобки! Затем мы создаём экземпляр <code>AlwaysEqual</code> и присваиваем его переменной <code>subject</code>, используя имя, которое мы определили, без (аналогично определению) фигурных и круглых скобок. Представим, что в дальнейшем мы реализуем поведение для этого типа таким образом, что каждый экземпляр <code>AlwaysEqual</code> всегда будет равен каждому экземпляру любого другого типа, возможно, с целью получения ожидаемого результата для тестирования. Для реализации такого поведения нам не нужны никакие данные! В Главе 10 вы увидите, как определять трейты и реализовывать их для любых типов, включая unit-подобные структуры.</p>
<blockquote>
<h3 id="Владение-данными-структуры"><a class="header" href="#Владение-данными-структуры">Владение данными структуры</a></h3>
<p>В определении структуры <code>User</code> в Листинге 5-1 мы использовали "владеемый" тип <code>String</code>, а не тип <code>&amp;str</code> среза строки. Это осознанный выбор, поскольку мы хотим, чтобы каждый экземпляр этой структуры владел всеми своими данными и чтобы эти данные были действительны до тех пор, пока действительна вся структура.</p>
<p>Структуры также могут хранить ссылки, но для этого необходимо определить <em>времена жизни</em> — особенность Rust, которую мы обсудим в Главе 10. Времена жизни гарантируют, что данные, на которые ссылаются поля структуры, будут действительны по крайней мере пока существует структура. Попытаемся сохранить ссылку в структуре без указания времени жизни, как в следующем примере; это не сработает:</p>
<Listing file-name="src/main.rs">
<!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><code class="language-rust ignore does_not_compile">struct User {
    active: bool,
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        active: true,
        username: "someusername123",
        email: "someone@example.com",
        sign_in_count: 1,
    };
}</code></pre>
</Listing>
<p>Компилятор будет жаловаться на необходимость определения времени жизни ссылок:</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:3:15
  |
3 |     username: &amp;str,
  |               ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     active: bool,
3 ~     username: &amp;'a str,
  |

error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:4:12
  |
4 |     email: &amp;str,
  |            ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     active: bool,
3 |     username: &amp;str,
4 ~     email: &amp;'a str,
  |

For more information about this error, try `rustc --explain E0106`.
error: could not compile `structs` (bin "structs") due to 2 previous errors
</code></pre>
<p>В Главе 10 мы обсудим, как исправлять эти ошибки, чтобы иметь возможность хранить ссылки в структурах, а до тех пор мы будем обходить подобные ошибки, используя владеемые типы вроде <code>String</code> вместо ссылок вроде <code>&amp;str</code>.</p>
</blockquote>
<!-- manual-regeneration
for the error above
after running update-rustc.sh:
pbcopy < listings/ch05-using-structs-to-structure-related-data/no-listing-02-reference-in-struct/output.txt
paste above
add `> ` before every line -->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch05-00-structs.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch05-02-example-structs.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch05-00-structs.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch05-02-example-structs.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
