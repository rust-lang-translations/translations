<!DOCTYPE HTML>
<html lang="ru" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Программирование игры в угадайку - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch02-00-guessing-game-tutorial.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch02-00-guessing-game-tutorial.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ru");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="Программирование-игры-в-угадайку"><a class="header" href="#Программирование-игры-в-угадайку">Программирование игры в угадайку</a></h1>
<p>Окунёмся в мир Rust, вместе создав прикладной проект! Эта глава познакомит вас с несколькими наиболее важными концепциями Rust, показав, как их использовать в реальной программе. Вы узнаете о <code>let</code>, <code>match</code>, методах, ассоциированных функциях, внешних крейтах и многом другом! В дальнейших главах мы изучим всё перечисленное подробнее. В этой главе вы прикоснётесь только к самым основам.</p>
<p>Мы реализуем классическую задачку для новичка: игру в угадывание числа. Она будет работать следующим образом: программа загадает случайное целое число от 1 до 100; затем она запросит у пользователя ввод догадки в консоль. Программа сообщит, больше или меньше ли догадка, чем загаданное число. Если догадка окажется верной, игра выведет поздравительное сообщение и завершится.</p>
<h2 id="Создание-нового-проекта"><a class="header" href="#Создание-нового-проекта">Создание нового проекта</a></h2>
<p>Чтобы создать новый проект, перейдите в директорию <em>projects</em>, созданную вами в Главе 1, и воспользуйтесь Cargo, вот так:</p>
<pre><code class="language-console">$ cargo new guessing_game
$ cd guessing_game
</code></pre>
<p>Первая команда (<code>cargo new</code>) принимает имя проекта (<code>guessing_game</code>) в качестве первого аргумента. Вторая команда осуществляет переход в директорию проекта.</p>
<p>Посмотрим на сгенерированный файл <em>Cargo.toml</em>:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial
rm -rf no-listing-01-cargo-new
cargo new no-listing-01-cargo-new --name guessing_game
cd no-listing-01-cargo-new
cargo run > output.txt 2>&1
cd ../../..
-->
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
version = "0.1.0"
edition = "2021"

[dependencies]
</code></pre>
<p>Как вы увидели в Главе 1, <code>cargo new</code> начинает новый проект созданием программы "Hello, world!". Посмотрите в файл <em>src/main.rs</em>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    println!("Hello, world!");
}</code></pre></pre>
<p>Теперь скомпилируем и запустим эту программу одной командой — <code>cargo run</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.20s
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
<p>Команда <code>run</code> особенно полезна тогда, когда вы разрабатываете проект мелкими изменениями (именно так мы и будем делать нашу игру!), тестируя каждую итерацию перед тем, как идти дальше.</p>
<p>Снова откройте файл <em>src/main.rs</em>. Весь код нашего проекта вы будете писать именно в нём.</p>
<h2 id="Обработка-догадки"><a class="header" href="#Обработка-догадки">Обработка догадки</a></h2>
<p>Первая часть игры в угадайку будет просить от пользователя ввод, обрабатывать его, и проверять, имеет ли ввод ожидаемый вид. Для начала, позволим игроку ввести догадку. Поместите код из Листинга 2-1 в <em>src/main.rs</em>.</p>
<Listing number="2-1" file-name="src/main.rs" caption="Code that gets a guess from the user and prints it">
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!("Угадайте число!");

    println!("Введите свою догадку.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Не удалось прочесть ввод.");

    println!("Вы предположили: {}", guess);
}</code></pre>
</Listing>
<p>В этом коде много нового, так что давайте изучим его строчка за строчкой. Чтобы получить пользовательский ввод и затем (по возможности) напечатать его, нам нужно подключить библиотеку ввода-вывода <code>io</code> в область видимости. Библиотека <code>io</code> входит в стандартную библиотеку, также известную как <code>std</code>:</p>
<pre><code class="language-rust ignore">use std::io;
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Угадайте число!");
</span><span class="boring">
</span><span class="boring">    println!("Введите свою догадку.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Не удалось прочесть ввод.");
</span><span class="boring">
</span><span class="boring">    println!("Вы предположили: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>Rust по умолчанию подключает некоторые важные части стандартной библиотеки в каждую программу. Это подмножество называется <em>prelude</em>, и с его составом вы можете ознакомиться в <a href="https://doc.rust-lang.org/std/prelude/index.html">документации стандартной библиотеки</a>.</p>
<p>Если тип, который вы хотите использовать, не входит в prelude, вам нужно явно подключить этот тип к области видимости программы, используя инструкцию <code>use</code>. Библиотека <code>std::io</code> даст вам набор полезных возможностей, включая получение пользовательского ввода.</p>
<p>Как вы увидели в Главе 1, функция <code>main</code> — это точка входа в программу:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span>fn main() {
<span class="boring">    println!("Угадайте число!");
</span><span class="boring">
</span><span class="boring">    println!("Введите свою догадку.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Не удалось прочесть ввод.");
</span><span class="boring">
</span><span class="boring">    println!("Вы предположили: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>Новая функция объявляется ключевым словом <code>fn</code>. Пустые круглые скобки <code>()</code> обозначают, что эта функция не имеет параметов. Открывающая игурная скобка <code>{</code> определяет начало тела функции.</p>
<p>Как вы также узнали в Главе 1, <code>println!</code> — это макрос, печатающий строку на экран:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    println!("Угадайте число!");

    println!("Введите свою догадку.");
<span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Не удалось прочесть ввод.");
</span><span class="boring">
</span><span class="boring">    println!("Вы предположили: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>Этот код печатает фразы: сообщающую о сути игры и запрашивающую ввод от пользователя</p>
<h3 id="Хранение-значений-с-помощью-переменных"><a class="header" href="#Хранение-значений-с-помощью-переменных">Хранение значений с помощью переменных</a></h3>
<p>Далее! Создадим <em>переменную</em> для хранения пользовательского ввода, вот так:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Угадайте число!");
</span><span class="boring">
</span><span class="boring">    println!("Введите свою догадку.");
</span><span class="boring">
</span>    let mut guess = String::new();
<span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Не удалось прочесть ввод.");
</span><span class="boring">
</span><span class="boring">    println!("Вы предположили: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>Программа становится интереснее! В этой строчке, на самом деле, происходит очень многое. Мы используем инструкцию <code>let</code> для создания переменной. Вот ещё пример:</p>
<pre><code class="language-rust ignore">let apples = 5;</code></pre>
<p>Эта строка создаёт новую переменную под названием <code>apples</code> и связывает с ней значение 5. По умолчанию, переменные в Rust неизменяемы, то есть однажды связав их со значением, мы больше не сможем его изменить. Мы обсудим это подробнее в разделе <a href="ch03-01-variables-and-mutability.html#%D0%9F%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D0%B8-%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D1%8F%D0%B5%D0%BC%D0%BE%D1%81%D1%82%D1%8C">"Переменные и изменяемость"</a><!-- ignore --> Главы 3. Чтобы создать изменяемую переменную, мы добавим <code>mut</code> перед именем переменной:</p>
<pre><code class="language-rust ignore">let apples = 5; // неизменяема
let mut bananas = 5; // изменяема</code></pre>
<blockquote>
<p>Примечание: символы <code>//</code> обозначают начало комментария, продолжающегося до конца строки. Rust игнорирует весь текст в комментариях. Мы детальнее обсудим комментирование в <a href="ch03-04-comments.html">Главе 3</a><!-- ignore -->.</p>
</blockquote>
<p>Вернёмся к программе игры в угадайку. Теперь вы знаете, что <code>let mut guess</code> создаёт изменяемую переменную <code>guess</code>. Знак равенства (<code>=</code>) говорит о том, что мы хотим связать что бы то ни было с данной переменной. Значение, с которым связывается переменная <code>guess</code>, располагается справа от знака равенства; оно является результатом вызова функции <code>String::new</code> — функции, возвращающей новое значение типа <code>String</code>. [<code>String</code>](https://doc.rust-lang.org/std/string/struct. String.html)<!-- ignore --> — это тип строки, предоставляемый стандартной библиотекой. Он представляет собой строку текста переменной длины в кодировке UTF-8.</p>
<p>Символы "::" в части <code>::new</code> показывают, что <code>new</code> — функция, ассоциированная с типом <code>String</code>. <em>Ассоциированная функция</em> — это функция, реализованная на типе (в данном случае — на <code>String</code>). Функция <code>new</code> создаёт новую, пустую строку. Многие типы имеют ассоциированную функцию <code>new</code>, поскольку это стандартное, типичное имя для функции, создающей некое значение типа, которое можно назвать новым.</p>
<p>В совокупности, строчка <code>let mut guess = String::new();</code> создаёт изменяемую переменную, связанную с новым, пустым экземпляром типа <code>String</code>. Фух!</p>
<h3 id="Получение-пользовательского-ввода"><a class="header" href="#Получение-пользовательского-ввода">Получение пользовательского ввода</a></h3>
<p>Напомним, что мы подключили функциональность ввода-вывода из стандартной библиотеки, написав <code>use std::io;</code> в первой строчке программы. Теперь вызовем функцию <code>stdin</code> из модуля <code>io</code>, которая позволит нам получать пользовательский ввод:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Угадайте число!");
</span><span class="boring">
</span><span class="boring">    println!("Введите свою догадку.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span>    io::stdin()
        .read_line(&amp;mut guess)
<span class="boring">        .expect("Не удалось прочесть ввод.");
</span><span class="boring">
</span><span class="boring">    println!("Вы предположили: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>Если бы мы не испортировали библиотеку <code>io</code> с помощью <code>use std::io;</code> в начале программы, мы всё ещё могли бы использовать нужную нам функцию, вызвав её как <code>std::io::stdin</code>. Функция <code>stdin</code> возвращает экземпляр типа <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore -->, представляющего декодер стандартного потока ввода.</p>
<p>Далее, строчка <code>.read_line(&amp;mut guess)</code> вызывает метод <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a> <!--ignore --> декодера стандартного потока ввода, возвращающий ввод пользователя. Мы также передаём строчку <code>&amp;mut guess</code> в качестве аргумента методу <code>read_line</code>, тем самым сообщая, где мы хотим сохранить пользовательский ввод. Метод <code>read_line</code> берёт всё, что пользователь напечатал в стандартный поток ввода, и приписывает это к строке (не переписывая её содержимое), так что здесь мы передаём нашу строку в качестве аргумента. Передаваемая строка должна быть изменяемой, чтобы метод мог изменить содержимое строки.</p>
<p>Знак <code>&amp;</code> означает, что мы передаём методу не само значение, а <em>ссылку</em> на его область памяти. Это позволяет давать нескольким частям программы доступ к одной и той же информации, без необоходимости многократно копировать её. Ссылки — вещь многогранная, и одним из основных преимуществ Rust является безопасность и простота их использования. Касательно всего, что мы обсудили: на данный момент вам достаточно знать, что по умолчанию переменные и ссылки неизменяемы. Поэтому нам пришлось написать <code>&amp;mut guess</code> вместо <code>&amp;guess</code>, чтобы сделать получить возможность изменять нужную нам область памяти. (В Главе 4 ссылки будут рассмотрены подробнее.)</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="handling-potential-failure-with-the-result-type"></a></p>
<h3 id="Обработка-возможных-ошибок-с-помощью-result"><a class="header" href="#Обработка-возможных-ошибок-с-помощью-result">Обработка возможных ошибок с помощью <code>Result</code></a></h3>
<p>Мы ещё не закончили с той строчкой, той последовательностью методов. Теперь мы обсудим третью строчку, однако стоит отметить, что, логически, это всё одна строка кода. Вот строчка, о которой мы говорим:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Угадайте число!");
</span><span class="boring">
</span><span class="boring">    println!("Введите свою догадку.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span>        .expect("Не удалось прочесть ввод.");
<span class="boring">
</span><span class="boring">    println!("Вы предположили: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>Мы могли бы переписать всю строку кода вот так:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess).expect("Не удалось прочесть ввод.");</code></pre>
<p>Однако, одну длинную строчку читать было бы тяжело, так что мы её разделили, перенеся вызовы методов (<code>.method_name()</code>) на новые строчки и отбив их пробелами от края. Теперь обсудим, что именно делает эта строка.</p>
<p>Как ранее упоминалось, <code>read_line</code> помещает всё, что пользователь ввёл в стандартный поток вывода, в строку, получаемую как аргумент. Но он также возвращает значение типа <code>Result</code>. <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a><!--ignore --> — это <a href="ch06-00-enums.html"><em>перечисление</em></a><!-- ignore -->, то есть тип, который может быть представлен одним из возможных состояний. Мы называем каждое такое возможное состояние <em>вариантом.</em></p>
<p>В <a href="ch06-00-enums.html">Главе 6</a><!-- ignore --> мы в деталях обсудим перечисления. Пока вам достаточно знать, что тип <code>Result</code> — это тип, варианты которого хранят информацию для обработки ошибок.</p>
<p>Вариантами типа <code>Result</code> являются <code>Ok</code> и <code>Err</code>. Вариант <code>Ok</code> означает успешное исполнение операции и содержит в себе результат её исполнения. Вариант <code>Err</code> означает, что операцию не удалось исполнить, и содержит информацию об ошибке.</p>
<p>Для значений типа <code>Result</code> реализовано несколько методов. Например — метод <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.expect"><code>expect</code> method</a><!-- ignore -->. Если этот метод вызывается на <code>Err</code>, он вызовет сбой программы и выведет на экран сообщение, переданное ему как аргумент. (Если метод <code>read_line</code> возвращает <code>Err</code>, то скорее всего, произошла какая-то системная ошибка.) Если метод <code>expect</code> будет вызван на <code>Ok</code>, он вернёт значение, хранимое в <code>Ok</code> (в нашем случае: пользовательский ввод).</p>
<p>Если вы не вызовите <code>expect</code>, то программа скомпилируется, но вы получите предупреждение:</p>
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `Result` that must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
10 |     let _ = io::stdin().read_line(&amp;mut guess);
   |     +++++++

warning: `guessing_game` (bin "guessing_game") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>Rust предупреждает вас, что: 1) вы не используете значение типа <code>Result</code>, возвращаемое методом <code>read_line</code>, и 2) вы не обрабатываете возможную ошибку, с которой может завершиться вызов этого метода.</p>
<p>Правильный способ избавиться от таких предупреждений — это писать код с обработками ошибок. Однако, в нашем случае, мы хотим просто аварийно завершить нашу программу, если что-то пойдёт не так, поэтому использование <code>expect</code> допустимо. Больше об обработке ошибок вы узнаете в [Главе 9] (ch09-02-recoverable-errors-with-result.html)<!-- ignore -->.</p>
<h3 id="Печать-значений-переменных-с-помощью-меток-подстановки-println"><a class="header" href="#Печать-значений-переменных-с-помощью-меток-подстановки-println">Печать значений переменных с помощью меток подстановки <code>println!</code></a></h3>
<p>Не считая закрывающей фигурной скобки, нам пока что осталось обсудить лишь одну строчку:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Угадайте число!");
</span><span class="boring">
</span><span class="boring">    println!("Введите свою догадку.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Не удалось прочесть ввод.");
</span><span class="boring">
</span>    println!("Вы предположили: {}", guess);
<span class="boring">}</span></code></pre>
<p>Эта строчка печатает строку, содержащую пользовательский ввод. Пара фигурных скобок <code>{}</code> — это метка подстановки. Представьте, что <code>{}</code> — это клешни крабика, держащего между ними значение. Если вам нужно напечатать значение, содержащееся в переменной, вы можете заключить его сразу в фигурные скобки. Если же нужно напечатать значения каких-то выражений и вы не хотите записывать их в переменные, то вы можете через запятую перечислить выражения после текстовой строки — они будут подставлены в метки подстановки в том же порядке, в каком вы их перечислили. Вот так будет выглядеть вывод значения переменной и выражения одним вызовом <code>println!</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = 10;

println!("x = {x} и y + 2 = {}", y + 2);
<span class="boring">}</span></code></pre></pre>
<p>Этот код напечатает <code>x = 5 и y + 2 = 12</code>.</p>
<h3 id="Проверяем-первую-часть"><a class="header" href="#Проверяем-первую-часть">Проверяем первую часть</a></h3>
<p>Проверим первую часть игры в угадайку. Запустим её, используя <code>cargo run</code>:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-01/
cargo clean
cargo run
input 6 -->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Угадайте число!
Введите свою догадку.
6
Вы предположили: 6
</code></pre>
<p>Первая часть программы завершена и работает, как задумано: мы принимаем ввод с клавиатуры и затем печатаем его.</p>
<h2 id="Генерация-секретного-числа"><a class="header" href="#Генерация-секретного-числа">Генерация секретного числа</a></h2>
<p>Далее! Нам нужно сгенерировать секретное число, которое пользователь и будет пытаться угадать. Секретное число должно быть разным от игры к игре, чтобы в неё действительно можно было играть. Мы будем использовать случайное число от 1 до 100, так что игра не будет сильно сложной. Функционал работы со случайными числами всё ещё не входит в стандартную библиотеку Rust, однако Команда Rust предоставляет <a href="https://crates.io/crates/rand">крейт <code>rand</code></a>, реализующий всё нужное.</p>
<h3 id="Использование-крейтов-для-расширения-возможностей"><a class="header" href="#Использование-крейтов-для-расширения-возможностей">Использование крейтов для расширения возможностей</a></h3>
<p>Помните, что крейт — это набор исходных файлов кода на языке Rust. Проект, который мы сейчас делаем, — это <em>бинарный (binary) крейт</em>, то есть собираемый в исполняемую программу. Крейт <code>rand</code> — это <em>библиотечный (library) крейт</em>, то есть содержащий код, который встраивается в другие программы и сам по себе не запускается.</p>
<p>Управление внешними крейтами — это конёк Cargo. Чтобы получить возможность использовать крейт <code>rand</code>, нам нужно отредактировать файл <em>Cargo.toml</em>, чтобы включить этот крейт как зависимость. Откройте этот файл и добавьте строчки ниже в его конец (то есть под <code>[dependencies]</code> — заголовком раздела зависимостей). Убедитесь, что вы подключили версию <code>rand</code> ровно такую же, что и мы, иначе наши примеры могут не заработать у вас.</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
* ch14-03-cargo-workspaces.md
-->
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = "0.8.5"
</code></pre>
<p>К разделам в файле <em>Cargo.toml</em> относится всё, что находится между заголовком раздела и заголовком следующего раздела. В <code>[dependencies]</code> вы указываете, какие внешние крейты каких версий требует ваш проект. В данном случае, мы конкретизируем версию крейта <code>rand</code> с помощью спецификатора <code>0.8.5</code>. Cargo опирается на <a href="http://semver.org/lang/ru">Семантическое версионирование (Semantic Versioning, <em>SemVer</em>)</a><!-- ignore --> — систему записи версий программ. Спецификатор версии <code>0.8.5</code> на самом деле является сокращением для <code>^0.8.5</code>, означающего любую версию программы не более раннюю, чем 0.8.5, но не более новую, чем 0.9.0.</p>
<p>Cargo рассчитывает, что версии, входящие в данный промежуток, имеют API, совместимый с API крейта версии 0.8.5. Это позволяет подключать более новые версии крейта, и при этом даёт гарантию, что приведённые в этой главе примеры будут компилироваться. Любая версия от 0.9.0 и выше не обязательно будет иметь такой же API, как используемый в примерах далее.</p>
<p>Теперь, ничего не меняя в программе, давайте соберём проект, как показано в Листинге 2-2.</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
rm Cargo.lock
cargo clean
cargo build -->
<Listing number="2-2" caption="The output from running `cargo build` after adding the rand crate as a dependency">
<pre><code class="language-console">$ cargo build
    Updating crates.io index
     Locking 16 packages to latest compatible versions
      Adding wasi v0.11.0+wasi-snapshot-preview1 (latest: v0.13.3+wasi-0.2.2)
      Adding zerocopy v0.7.35 (latest: v0.8.9)
      Adding zerocopy-derive v0.7.35 (latest: v0.8.9)
  Downloaded syn v2.0.87
  Downloaded 1 crate (278.1 KB) in 0.16s
   Compiling proc-macro2 v1.0.89
   Compiling unicode-ident v1.0.13
   Compiling libc v0.2.161
   Compiling cfg-if v1.0.0
   Compiling byteorder v1.5.0
   Compiling getrandom v0.2.15
   Compiling rand_core v0.6.4
   Compiling quote v1.0.37
   Compiling syn v2.0.87
   Compiling zerocopy-derive v0.7.35
   Compiling zerocopy v0.7.35
   Compiling ppv-lite86 v0.2.20
   Compiling rand_chacha v0.3.1
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 3.69s
</code></pre>
</Listing>
<p>Если вы проделаете всё на своей машине, вы можете увидеть другие (но всё ещё обратно совместимые; спасибо SemVer!) версии крейтов и другие печатаемые строчки (в зависимости от вашей операционной системы), и они могут быть расположены в другом порядке.</p>
<p>Когда мы подключаем зависимость, Cargo собирает всё, что она сама требует, используя <em>реестр</em> (<em>registry</em>), представляющий собой копию данных с сайта <a href="https://crates.io/">Crates.io</a>. Crates.io — это часть экосистемы Rust, место для публикации проектов с открытым исходным кодом, доступных каждому.</p>
<p>После обновления реестра, Cargo проверяет раздел <code>[dependencies]</code> и скачивает все крейты, которые ещё не скачаны. В нашем случае, мы подключаем как зависимость лишь крейт <code>rand</code>, однако Cargo также загружает всё, что требуется уже самому крейту <code>rand</code>. После скачивания крейтов, Rust компилирует их, а затем компилирует и проект.</p>
<p>Если вы сразу же вновь запустите <code>cargo build</code>, ничего не изменив в проекте, вы не увидите ничего, кроме строки <code>Finished</code>. Cargo видит, что вы ничего не поменяли в файле <em>Cargo.toml</em>, и он помнит, что зависимости уже были скачаны и скомпилированы. Cargo также видит, что вы ничего не поменяли и в исходном коде, так что он совершенно ничего не перекомпилирует. Поскольку делать ему больше и нечего, он просто сообщает об успешной сборке.</p>
<p>Если вы откроете файл <em>src/main.rs</em> и внесёте какие-нибудь изменения, сохраните их и ещё раз запуситите сборку, вы увидите лишь две строчки вывода:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
touch src/main.rs
cargo build -->
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s
</code></pre>
<p>Эти строчки показывают, что Cargo пересобрал лишь ваш код, поскольку увидел небольшое изменение в файле <em>src/main.rs</em>. Ваши зависимости не поменялись, поэтому Cargo не стал их ещё раз загружать и компилировать.</p>
<h4 id="Обеспечение-воспроизводимости-сборок-с-помощью-файла-cargolock"><a class="header" href="#Обеспечение-воспроизводимости-сборок-с-помощью-файла-cargolock">Обеспечение воспроизводимости сборок с помощью файла <em>Cargo.lock</em></a></h4>
<p>В Cargo есть механизм, гарантирующий каждому (в том числе, и вам) пересобрать ваш проект с в точности одинаковыми зависимостями: Cargo будет использовать только те версии зависимостей, которые вы определили, пока не укажете обратное. Например, допустим, что на следующей неделе выходит версия 0.8.6 крейта <code>rand</code>, и эта версия содержит важные исправления ошибок, но также включает прекращение поддержки некоторой части API, которую использовали вы. Чтобы обработать такой случай, Rust создает файл <em>Cargo.lock</em> при первом запуске <code>cargo build</code>; мы тоже уже имеем такой файл в директории <em>guessing_game</em>.</p>
<p>Когда вы впервые собираете проект, Cargo выясняет всё о версиях зависимостей, которые удовлетворяют требованиям, и записывает информацию о них в файл <em>Cargo.lock</em>. Когда вы ещё раз соберёте проект, Cargo увидит, что файл <em>Cargo.lock</em> уже существует, и воспользуется указанными в нём версиями. Это автоматически делает ваш код воспроизводимым. Иными словами, ваш проект продолжит использовать версию 0.8.5 до тех пор, пока вы не обновитесь явно — и всё благодаря файлу <em>Cargo.lock</em>. Поскольку файл <em>Cargo.lock</em> важен для обеспечения воспроизводимости сборок, он часто включается в систему управления версиями вместе с остальным кодом вашего проекта.</p>
<h4 id="Обновление-крейта-до-новейшей-версии"><a class="header" href="#Обновление-крейта-до-новейшей-версии">Обновление крейта до новейшей версии</a></h4>
<p>Когда вы <em>захотите</em> обновить используемый крейт, вы можете воспользоваться комадой Cargo <code>update</code>. Она, игнорируя файл <em>Cargo.lock</em>, заново отыщет последние версии, подходящие вашим спецификациям в <em>Cargo.toml</em>. Cargo затем перепишет эти версии в файл <em>Cargo.lock</em>. В нашем случае, Cargo будет искать только те версии, что будут старше 0.8.5 и младше 0.9.0. Если <code>rand</code> получил две новые версии — 0.8.6 и 0.9.0, — то, запустив <code>cargo update</code>, вы увидите подобный вывод:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
cargo update
assuming there is a new 0.8.x version of rand; otherwise use another update
as a guide to creating the hypothetical output shown here -->
<pre><code class="language-console">$ cargo update
    Updating crates.io index
    Updating rand v0.8.5 -&gt; v0.8.6
</code></pre>
<p>Cargo игнорирует релиз 0.9.0. Если вы посмотрите в файл <em>Cargo.lock</em>, вы также увидите, что используемая теперь версия крейта <code>rand</code> — 0.8.6. Чтобыц использовать версию 0.9.0 (или любую другую версию 0.9.<em>x</em>), вам нужно обновить файл <em>Cargo.toml</em>, чтобы он выглядел вот так:</p>
<pre><code class="language-toml">[dependencies]
rand = "0.9.0"
</code></pre>
<p>В следующий раз, когда вы запустите <code>cargo build</code>, Cargo обновит реестр доступных крейтов и обновит вашу зависимость <code>rand</code> согласно определённой вами новой версии.</p>
<p>Мы оставим подробности о [Cargo](https://rust-lang-translations.org/ cargo/)<!-- ignore --> и [его экосистеме](https://rust-lang-translations.org/cargo/ reference/publishing.html)<!-- ignore --> до Главы 14. Cargo делает переиспользование вашего кода другими людьми (и наоборот) значительно более простым, так что у программистов на Rust есть отличная возможность писать небольшие проекты, собранные на основе нескольких пакетов.</p>
<h3 id="Генерация-случайного-числа"><a class="header" href="#Генерация-случайного-числа">Генерация случайного числа</a></h3>
<p>Применим <code>rand</code> для загадывания числа. Обновите файл <em>src/main.rs</em>, поместив в него код Листинга 2-3.</p>
<Listing number="2-3" file-name="src/main.rs" caption="Adding code to generate a random number">
<pre><code class="language-rust ignore">use std::io;
use rand::Rng;

fn main() {
    println!("Угадайте число!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    println!("Загаданное число: {secret_number}");

    println!("Введите свою догадку.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Не удалось прочесть ввод.");

    println!("Вы предположили: {guess}");
}</code></pre>
</Listing>
<p>Во-первых, мы добавили строчку <code>use rand::Rng;</code>. Трейт <code>Rng</code> определяет методы, реализуемые генератором случайных чисел, так что чтобы использовать эти методы, этот трейт должен быть в области видимости. Трейты будут рассмотрены в Главе 10.</p>
<p>Во-вторых, мы добавили две строчки в середине. В первой строчке мы вызываем функцию <code>rand::thread_rng</code>, возвращающую нам генератор случайных чисел (локальный для текущего потока исполнения и запущенный операционной системой). Затем мы вызываем метод <code>gen_range</code> генератора случайных чисел. Этот метод определён трейтом <code>Rng</code>, который мы добавили в область видимости инструкцией <code>use rand::Rng;</code>. Метод <code>gen_range</code> принимает в качестве аргумента выражение диапазона значений и возвращает случайное число из этого диапазона. Использованное выражение диапазона значений имеет вид <code>start..=end</code>; оно включает в себя как нижнюю, так и верхнюю границы. Выражение <code>1..=100</code> тем самым означает, что нам требуется случайное число от 1 до 100, включая и 1, и 100.</p>
<blockquote>
<p>Примечание: Вы почти наверняка не будете знать, какие трейты использовать и  какие методы и функции вызывать из крейта. В этом случае вам поможет документация крейта. С ней связана ещё одна приятная особенность Cargo: комманда <code>cargo doc --open</code> соберёт всю документацию, предоставляемую вашими крейтами-зависимостями, и откроет её автономную копию в браузере. Так, если вам интересная другая функциональность крейта <code>rand</code>, вы можете найти её в документации: выполните <code>cargo doc --open</code> и кликните по <code>rand</code> на левой панели.</p>
</blockquote>
<p>Вторая новая строчка печатает секретное число. Это полезно, когда мы разрабатываем программу, но мы удалим это поведение программы из финальной версии. Но очень-то и игрой будет программа, сообщающая ответ сразу при запуске!</p>
<p>Попробуйте запустить программу несколько раз:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-03/
cargo run
4
cargo run
5
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Угадайте число!
Загаданное число: 7
Введите свою догадку.
4
Вы предположили: 4

$ cargo run
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Угадайте число!
Загаданное число: 83
Введите свою догадку.
5
Вы предположили: 5
</code></pre>
<p>Вы должны увидеть разные случайные числа, и они должны быть в пределах от 1 до 100. Отличная работа!</p>
<h2 id="Сравнение-догадки-с-загаданным-числом"><a class="header" href="#Сравнение-догадки-с-загаданным-числом">Сравнение догадки с загаданным числом</a></h2>
<p>Теперь мы имеем пользовательский ввод и случайное число, а значит, мы можем их сравнить. Этот шаг показан в Листинге 2-4. Обратите внимание, что этот код не скомпилируется.</p>
<Listing number="2-4" file-name="src/main.rs" caption="Handling the possible return values of comparing two numbers">
<pre><code class="language-rust ignore does_not_compile">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --код сокращён--
<span class="boring">    println!("Угадайте число!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("Загаданное число: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Введите свою догадку.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Не удалось прочесть ввод.");
</span>
    println!("Вы предположили: {guess}");

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!("Слишком маленькое!"),
        Ordering::Greater =&gt; println!("Слишком большое!"),
        Ordering::Equal =&gt; println!("Вы победили!"),
    }
}</code></pre>
</Listing>
<p>Во-первых, вы добавили ещё одну инструкцию с <code>use</code>, подключив в область видимости тип из стандартной библиотеки под названием <code>std::cmp::Ordering</code>. Тип <code>Ordering</code> — это перечисление, вариантами которого являются <code>Less</code>, <code>Greater</code> и <code>Equal</code>. Они отвечают всем возможным результатам сравнения двух значений.</p>
<p>Затем, мы добавили пять новых строчек в конце, использующих тип <code>Ordering</code>. Метод <code>cmp</code> сравнивает два значения; он может быть вызван на всём, что может быть сравнимо. Он берёт ссылку на то, с чем вы хотите сравнить значение. В нашем случае он сравнивает <code>guess</code> с <code>secret_number</code>. Метод возвращает вариант перечисления <code>Ordering</code> (которое мы ранее подключили в область видимости инструкцией с <code>use</code>). Мы используем выражение <a href="ch06-02-match.html"><code>match</code></a><!-- ignore --> для того, чтобы выбрать что делать в зависимости от варианта <code>Ordering</code>, возвращённого вызовом метода <code>cmp</code> на <code>guess</code> и <code>secret_number</code>.</p>
<p>Выражение <code>match</code> состоит из <em>ветвей</em>. Каждая ветвь начинается с <em>шаблона</em>, с которым сопоставляется переданное в конструкцию <code>match</code>, и заканчивается кодом, который исполнится, если значение успешно сопоставится с шаблоном. Значение сравнивается с шаблонами в порядке их перечисления. Шаблоны и конструкция <code>match</code> — это очень мощные средства языка Rust: они дают вам возможность 1) учитывать различные развития событий и 2) делать это гарантированно. Эти особенности будут рассмотрены в Главе 6 и Главе 9, соответственно.</p>
<p>Рассмотрим наш вышеприведённый пример с выражением <code>match</code>. Предположим, что пользователь дал догадку 50, а загадано было число 38.</p>
<p>Если мы сравним 50 с 38, метод <code>cmp</code> вернёт <code>Ordering::Greater</code>, поскольку 50 больше 38. Выражение <code>match</code> берёт значение <code>Ordering::Greater</code> и начинает последовательно проверять каждый шаблон. Оно смотрит на первый шаблон — <code>Ordering::Less</code> — и видит, что значение <code>Ordering::Greater</code> не сопоставимо с ним, а потому код этой ветви игнорируется, и сравнение с шаблонами идёт дальше. Следующий шаблон — <code>Ordering::Greater</code>, и он <em>сопоставляется</em> с <code>Ordering::Greater</code>! Связанный с шаблоном код исполняется, и на экран печатается <code>Too big!</code>. Выражение <code>match</code> завершается после первого успешного сопоставления, и проверок с оставшимися шаблонами не происходит.</p>
<p>Однако, код Листина 2-4 всё ещё не будет компилироваться:</p>
<!--
The error numbers in this output should be that of the code **WITHOUT** the
anchor or snip comments
-->
<pre><code class="language-console">$ cargo build
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_core v0.6.2
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
   --&gt; src/main.rs:22:21
    |
22  |     match guess.cmp(&amp;secret_number) {
    |                 --- ^^^^^^^^^^^^^^ expected `&amp;String`, found `&amp;{integer}`
    |                 |
    |                 arguments to this method are incorrect
    |
    = note: expected reference `&amp;String`
               found reference `&amp;{integer}`
note: method defined here
   --&gt; file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/core/src/cmp.rs:838:8
    |
838 |     fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering;
    |        ^^^

For more information about this error, try `rustc --explain E0308`.
error: could not compile `guessing_game` (bin "guessing_game") due to 1 previous error
</code></pre>
<p>В сердце ошибки находится в <em>несоответствии типов</em>. Rust — язык с сильной статической типизацией. Однако, он также способен самостоятельно вывести тип. Когда мы пишем <code>let mut guess = String::new()</code>, Rust может вывести, что <code>guess</code> должна быть типа <code>String</code>, а потому с нас не требуется уточнять тип. <code>secret_number</code> же — это целочисленный тип. Типов Rust, которые могут представлять числа от 1 до 100, множество: <code>i32</code>, знаковое 32-битное число; <code>u32</code>, беззнаковое 32-битное число; <code>i64</code>, знаковое 64-битное число; и так далее. В случае равновозможности использования нескольких числовых типов, Rust выводит для числа тип <code>i32</code>. Это он и делает с <code>secret_number</code> — выводит <code>i32</code>, пока не появится дополнительная информация, которая заставила бы Rust вывести другой тип. Причиной же ошибки является невозможность в Rust сравнить значения строкового и числового типов.</p>
<p>В конечном счёте, мы хотим преобразовать строку <code>String</code>, получаемую программой из ввода, в числовой тип, который мы и сможем сравнить с секретным числом. Мы сделаем это, добавив одну строчку в тело функции <code>main</code> ...</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Угадайте число!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("Загаданное число: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Введите свою догадку.");
</span><span class="boring">
</span>    // --код сокращён--

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Не удалось прочесть ввод.");

    let guess: u32 = guess.trim().parse().expect("Пожалуйста, введите число!");

    println!("Вы предположили: {guess}");

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!("Слишком маленькое!"),
        Ordering::Greater =&gt; println!("Слишком большое!"),
        Ordering::Equal =&gt; println!("Вы победили!"),
    }
<span class="boring">}</span></code></pre>
<p>... вот эту строчку:</p>
<pre><code class="language-rust ignore">let guess: u32 = guess.trim().parse().expect("Пожалуйста, введите число!");</code></pre>
<p>Здесь мы создаём переменную <code>guess</code>. Но только... в программе же уже есть переменная <code>guess</code>, верно? Да, это так, в самом деле; но Rust позволяет переобъявлять переменные, присваивая им новые значения (и даже других типов). Это называется <em>затенением</em>; оно позволяет переиспользовать имя переменной вместо того, чтобы создавать несколько переменных одинакового смысла, но разных типов (например, <code>guess_str</code> и <code>guess</code>). Мы обсудим это детальнее в <a href="ch03-01-variables-and-mutability.html#%D0%97%D0%B0%D1%82%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5">Главе 3</a><!-- ignore -->, а пока просто знайте, что затенение часто полезно, когда вам нужно преобразовать значение из одного типа в другой.</p>
<p>Мы связываем эту новую переменную со значением выражения <code>guess.trim().parse()</code>. В нём, <code>guess</code> — это название уже ранее существующей переменной: нашей изначальной <code>guess</code>, содержащей ввод в виде строки. Метод <code>trim</code>, реализованный для экземпляров <code>String</code>, убирает начальные и конечные пробелы — нам нужно это сделать перед конвертацией строки в число типа <code>u32</code> (целое, беззнаковое, 32-битное). Пользователь должен нажать <kbd>Enter</kbd>, чтобы <code>read_line</code> исполнился и считал введённую информацию. Однако считанная строка будет включать в себя символ начала новой строки. Например, если пользователь напечатает <kbd>5</kbd> и потом нажмёт <kbd>Enter</kbd>, <code>guess</code> будет выглядеть вот так: <code>5\n</code>. <code>\n</code> — это обозначение для символа начала новой строки. (Стоит отметить, что на Windows нажатие <kbd>Enter</kbd> сопровождается возвратом каретки, и только потом символом начала новой строки, что всё вместе даёт <code>\r\n</code>.) Метод <code>trim</code> сможет убрать как <code>\n</code>, так и <code>\r\n</code>, и вернёт просто строку <code>5</code>.</p>
<p><a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse">Метод <code>parse</code> строк</a> <!-- ignore --> преобразует строку к другому типу. В нашем случае, мы используем его для приведения строки к числу. Нам нужно указать Rust, к какому конкретному числовому типу мы хотим привести наш ввод, и для этого мы явно указываем тип переменной: <code>let guess: u32</code>. Двоеточие (<code>:</code>) после <code>guess</code> используется для аннотирования типа переменной. В Rust есть встроенные числовые типы; использованный нами тип <code>u32</code> означает целое беззнаковое 32-битное число — хороший выбор для относительно небольших положительных чисел. Вы узнаете больше о других числовых типах в <a href="ch03-02-data-types.html#%D0%A6%D0%B5%D0%BB%D0%BE%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B">Главе 3</a><!-- ignore -->.</p>
<p>В добавок, аннотирование <code>guess</code> типом <code>u32</code> и сравнение с <code>secret_number</code> позволяют Rust вывести, что <code>secret_number</code> тоже должна иметь тип <code>u32</code>. Теперь мы наконец-то сравниваем значения одинаковых типов!</p>
<p>Метод <code>parse</code> может преобразовать в цифры только те символы строки, которые цифры же и обозначают, а потому он может легко вызвать ошибку. Например, строку <code>A👍%</code> никак нельзя будет преобразовать в число. Поэтому, поскольку преобразование может завершиться с ошибкой, метод <code>parse</code> возвращает тип <code>Result</code> — так же, как и метод <code>read_line</code> (что обсуждалось ранее в подразделе <a href="#%D0%9E%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0-%D0%B2%D0%BE%D0%B7%D0%BC%D0%BE%D0%B6%D0%BD%D1%8B%D1%85-%D0%BE%D1%88%D0%B8%D0%B1%D0%BE%D0%BA-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-result">"Обработка возможных ошибок с помощью <code>Result</code>"</a><!-- ignore -->). Вы обработаем <code>Result</code> так же, как и до этого: с помощью метода <code>expect</code>. Если <code>parse</code> не сможет создать из строки число, то он вернёт вариант <code>Err</code> типа <code>Result</code>, а <code>expect</code> вызовет сбой и напечатает сообщение, которое мы ему передали. Если <code>parse</code> сможет преобразовать строку в число и потому вернёт вариант <code>Ok</code> типа <code>Result</code>, <code>expect</code> вернёт число, упакованное в <code>Ok</code>.</p>
<p>Теперь запустим нашу программу:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/
touch src/main.rs
cargo run
  76
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.26s
     Running `target/debug/guessing_game`
Угадайте число!
Загаданное число: 58
Введите свою догадку.
  76
Вы предположили: 76
Слишком большое!
</code></pre>
<p>Отлично! Пусть программа и добавляет пару пробелов перед догадкой, программа всё-таки понимает, что пользователь предположил число 76. Запустите программу несколько раз, чтобы проверить разное поведение с разными введёнными числами: правильную догадку, слишком большую догадку и слишком маленькую.</p>
<p>Большая часть игры готова, но пользователь пока что может сделать дать одну догадку. Изменим это, добавив цикл!</p>
<h2 id="Возможность-дать-догадку-не-один-раз-с-помощью-циклов"><a class="header" href="#Возможность-дать-догадку-не-один-раз-с-помощью-циклов">Возможность дать догадку не один раз с помощью циклов</a></h2>
<p>Ключевое слово <code>loop</code> создаёт бесконечный цикл. Мы добавим цикл, чтобы дать пользователю больше попыток угадать число:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Угадайте число!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    // --код сокращён--

    println!("Загаданное число: {secret_number}");

    loop {
        println!("Введите свою догадку.");

        // --код сокращён--

<span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("Не удалось прочесть ввод.");
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect("Пожалуйста, введите число!");
</span><span class="boring">
</span><span class="boring">        println!("Вы предположили: {guess}");
</span><span class="boring">
</span>        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Слишком маленькое!"),
            Ordering::Greater =&gt; println!("Слишком большое!"),
            Ordering::Equal =&gt; println!("Вы победили!"),
        }
    }
}</code></pre>
<p>Как вы можете видеть, мы переместили весь код обработки догадки в цикл. Убедитесь, что отбили строчки от левого края ещё четырьмя пробелами каждую, и снова запустите программу. Программа теперь будет спрашивать догадку бесконечно, и это создало нам новую проблему: игра никогда не закончится!</p>
<p>Пользователь, конечно, всегда может прервать исполнение программы сочетанием клавиш <kbd>ctrl</kbd>-<kbd>c</kbd>. Есть и другая возможность остановить нашу программу-лудомана: как мы обсудили в подразделе <a href="#%D0%A1%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B4%D0%BE%D0%B3%D0%B0%D0%B4%D0%BA%D0%B8-%D1%81-%D0%B7%D0%B0%D0%B3%D0%B0%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D0%BC-%D1%87%D0%B8%D1%81%D0%BB%D0%BE%D0%BC">"Сравнение догадки с загаданным числом"</a>, когда говорили о <code>parse</code>, ввод не числа вызовет аварийную остановку программы. Пользователь может использовать этот эксплойт, чтобы выйти из игры:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-04-looping/
touch src/main.rs
cargo run
(too small guess)
(too big guess)
(correct guess)
quit
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.23s
     Running `target/debug/guessing_game`
Угадайте число!
Загаданное число: 59
Введите свою догадку.
45
Вы предположили: 45
Слишком маленькое!
Введите свою догадку.
60
Вы предположили: 60
Слишком большое!
Введите свою догадку.
59
Вы предположили: 59
Вы победили!
Введите свою догадку.
quit
thread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/main.rs:28:47
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Ввод слова <code>quit</code> остановит программу, но как вы можете заметить, это произойдёт при любом нечисловом вводе. Такое поведение программы, мягко говоря, неоптимально. Мы хотим, чтобы игра завершалась, когда догадка игрока оказывается правильной.</p>
<h3 id="Завершение-игры-после-правильной-догадки"><a class="header" href="#Завершение-игры-после-правильной-догадки">Завершение игры после правильной догадки</a></h3>
<p>Запрограммируем выход из игры, когда игрок побеждает. Для этого, используем инструкцию <code>break</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Угадайте число!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("Загаданное число: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!("Введите свою догадку.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("Не удалось прочесть ввод.");
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect("Пожалуйста, введите число!");
</span><span class="boring">
</span><span class="boring">        println!("Вы предположили: {guess}");
</span><span class="boring">
</span>        // --код сокращён--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Слишком маленькое!"),
            Ordering::Greater =&gt; println!("Слишком большое!"),
            Ordering::Equal =&gt; {
                println!("Вы победили!");
                break;
            }
        }
    }
}</code></pre>
<p>Строка <code>break</code> после <code>You win!</code> заставляет программу покинуть цикл, когда игрок делает правильную догадку. Выход из цикла также означает конец программы, поскольку цикл оказывается последней частью <code>main</code>.</p>
<h3 id="Обработка-неправильного-ввода"><a class="header" href="#Обработка-неправильного-ввода">Обработка неправильного ввода</a></h3>
<p>Чтобы сделать поведение программы ещё лучше, заменим преднамеренный вылет программы при нечисловом вводе на игнорирование такого ввода, дадим игроку возможность продолжить. Мы сделаем это, изменив строчку, где <code>guess</code> конвертируется из <code>String</code> в <code>u32</code>. Изменение показано в Листинге 2-5.</p>
<Listing number="2-5" file-name="src/main.rs" caption="Ignoring a non-number guess and asking for another guess instead of crashing the program">
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Угадайте число!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("Загаданное число: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!("Введите свою догадку.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span>        // --код сокращён--

        io::stdin()
            .read_line(&amp;mut guess)
            .expect("Не удалось прочесть ввод.");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!("Вы предположили: {guess}");

        // --код сокращён--
<span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!("Слишком маленькое!"),
</span><span class="boring">            Ordering::Greater =&gt; println!("Слишком большое!"),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!("Вы победили!");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>We switch from an <code>expect</code> call to a <code>match</code> expression to move from crashing on an error to handling the error. Remember that <code>parse</code> returns a <code>Result</code> type and <code>Result</code> is an enum that has the variants <code>Ok</code> and <code>Err</code>. We’re using a <code>match</code> expression here, as we did with the <code>Ordering</code> result of the <code>cmp</code> method.</p>
<p>Если <code>parse</code> может преобразовать строку в число, он вернёт значение <code>Ok</code>, содержащее результат преобразования — число. Этот <code>Ok</code> сопоставится с шаблоном первой ветви, и выражение <code>match</code> просто вернёт значение <code>num</code>, которое до этого создало <code>parse</code> и поместило в значение <code>Ok</code>. Это число будет сохранено в созданной нами переменной <code>guess</code>.</p>
<p>Если <code>parse</code> <em>не</em> сможет сделать из строки число, он вернёт значение <code>Err</code>, содержащее информацию об ошибке. Значение <code>Err</code> не сопоставится с шаблоном <code>Ok(num)</code> первой ветви <code>match</code>, но сопоставится с шаблоном <code>Err(_)</code> второй ветви. Нижнее подчёркивание <code>_</code> — это шаблон, соответствующий любому значению; в нашем примере мы используем его, чтобы сказать, что шаблон второй ветви должен сопоставиться с любым <code>Err</code>, какую бы информацию он с собой ни нёс. Так что в случае ошибки, программа исполнит инструкцию второй ветви — <code>continue</code>. Она сообщает программе, что необходимо сразу перейти на следующую итерацию цикла <code>loop</code> и запросить другую догадку. Теперь наша программа рационально игнорирует все ошибки, с которыми может завершиться <code>parse</code>!</p>
<p>Теперь вся программа должна работать нужным образом. Попробуем:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-05/
cargo run
(too small guess)
(too big guess)
foo
(correct guess)
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s
     Running `target/debug/guessing_game`
Угадайте число!
Загаданное число: 61
Введите свою догадку.
10
Вы предположили: 10
Слишком маленькое!
Введите свою догадку.
99
Вы предположили: 99
Слишком большое!
Введите свою догадку.
foo
Введите свою догадку.
61
Вы предположили: 61
Вы победили!
</code></pre>
<p>Замечательно! Нам нужно внести только ещё одну небольшую последнюю правку. Вспомним, что программа всё ещё печатает загаданное число. Это было полезно для тестирования, но для игры это бессмысленно. Удалим строчку с <code>println!</code>, которая печатает загаданное число. В Листинге 2-6 приведён окончательный код программы.</p>
<Listing number="2-6" file-name="src/main.rs" caption="Complete guessing game code">
<pre><code class="language-rust ignore">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!("Угадайте число!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    loop {
        println!("Введите свою догадку.");

        let mut guess = String::new();

        io::stdin()
            .read_line(&amp;mut guess)
            .expect("Не удалось прочесть ввод.");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!("Вы предположили: {guess}");

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Слишком маленькое!"),
            Ordering::Greater =&gt; println!("Слишком большое!"),
            Ordering::Equal =&gt; {
                println!("Вы победили!");
                break;
            }
        }
    }
}</code></pre>
</Listing>
<p>Игра готова. Хорошая работа, поздравляем!</p>
<h2 id="Подведём-итоги"><a class="header" href="#Подведём-итоги">Подведём итоги</a></h2>
<p>Этот прикладной проект познакомил вас со многими концепциями Rust: <code>let</code>, <code>match</code>, функциями, использованием внешних крейтов и многим другим. В нескольких следующих главах вы изучите эта концепции подробнее. Глава 3 расскажет об общих понятиях программирования, присущих и Rust, таких как переменные, типы данных и функциях, а также покажет, как их использовать. Глава 4 посвящена системе владения — особенности Rust, сильно выделяющей его среди других языков программирования. В Главе 5 обсуждаются структуры и синтаксис метода, а Глава 6 объясняет работу с перечислениями.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch01-03-hello-cargo.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch03-00-common-programming-concepts.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch01-03-hello-cargo.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch03-00-common-programming-concepts.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
