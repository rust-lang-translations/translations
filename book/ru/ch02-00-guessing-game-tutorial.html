<!DOCTYPE HTML>
<html lang="ru" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Программирование игры в угадайку - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch02-00-guessing-game-tutorial.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch02-00-guessing-game-tutorial.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ru");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="Программирование-игры-в-угадайку"><a class="header" href="#Программирование-игры-в-угадайку">Программирование игры в угадайку</a></h1>
<p>Окунёмся в мир Rust, вместе создав прикладной проект! Эта глава познакомит вас с несколькими наиболее важными концепциями Rust, показав, как их использовать в реальной программе. Вы узнаете о <code>let</code>, <code>match</code>, методах, ассоциированных функциях, внешних крейтах и многом другом! В дальнейших главах мы изучим всё перечисленное подробнее. В этой главе вы прикоснётесь только к самым основам.</p>
<p>We’ll implement a classic beginner programming problem: a guessing game. Here’s how it works: The program will generate a random integer between 1 and 100. It will then prompt the player to enter a guess. After a guess is entered, the program will indicate whether the guess is too low or too high. If the guess is correct, the game will print a congratulatory message and exit.</p>
<h2 id="Создание-нового-проекта"><a class="header" href="#Создание-нового-проекта">Создание нового проекта</a></h2>
<p>Чтобы создать новый проект, перейдите в директорию <em>projects</em>, созданную вами в Главе 1, и воспользуйтесь Cargo, вот так:</p>
<pre><code class="language-console">$ cargo new guessing_game
$ cd guessing_game
</code></pre>
<p>Первая команда (<code>cargo new</code>) принимает имя проекта (<code>guessing_game</code>) в качестве первого аргумента. Вторая команда осуществляет переход в директорию проекта.</p>
<p>Посмотрим на сгенерированный файл <em>Cargo.toml</em>:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial
rm -rf no-listing-01-cargo-new
cargo new no-listing-01-cargo-new --name guessing_game
cd no-listing-01-cargo-new
cargo run > output.txt 2>&1
cd ../../..
-->
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
version = "0.1.0"
edition = "2024"

[dependencies]
</code></pre>
<p>Как вы увидели в Главе 1, <code>cargo new</code> начинает новый проект созданием программы "Hello, world!". Посмотрите в файл <em>src/main.rs</em>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    println!("Hello, world!");
}</code></pre></pre>
<p>Теперь скомпилируем и запустим эту программу одной командой — <code>cargo run</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.08s
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
<p>Команда <code>run</code> особенно полезна тогда, когда вы разрабатываете проект мелкими изменениями (именно так мы и будем делать нашу игру!), тестируя каждую итерацию перед тем, как идти дальше.</p>
<p>Снова откройте файл <em>src/main.rs</em>. Весь код нашего проекта вы будете писать именно в нём.</p>
<h2 id="Обработка-догадки"><a class="header" href="#Обработка-догадки">Обработка догадки</a></h2>
<p>Первая часть игры в угадайку будет просить от пользователя ввод, обрабатывать его, и проверять, имеет ли ввод ожидаемый вид. Для начала, позволим игроку ввести догадку. Поместите код из Листинга 2-1 в <em>src/main.rs</em>.</p>
<Listing number="2-1" file-name="src/main.rs" caption="Code that gets a guess from the user and prints it">
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!("Угадайте число!");

    println!("Введите свою догадку.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Не удалось прочесть ввод.");

    println!("Вы предположили: {guess}");
}</code></pre>
</Listing>
<p>В этом коде много нового, так что давайте изучим его строчка за строчкой. Чтобы получить пользовательский ввод и затем (по возможности) напечатать его, нам нужно подключить библиотеку ввода-вывода <code>io</code> в область видимости. Библиотека <code>io</code> входит в стандартную библиотеку, также известную как <code>std</code>:</p>
<pre><code class="language-rust ignore">use std::io;
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Угадайте число!");
</span><span class="boring">
</span><span class="boring">    println!("Введите свою догадку.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Не удалось прочесть ввод.");
</span><span class="boring">
</span><span class="boring">    println!("Вы предположили: {guess}");
</span><span class="boring">}</span></code></pre>
<p>Rust по умолчанию подключает некоторые важные части стандартной библиотеки в каждую программу. Это подмножество называется <em>prelude</em>, и с его составом вы можете ознакомиться в <a href="https://doc.rust-lang.org/std/prelude/index.html">документации стандартной библиотеки</a>.</p>
<p>Если тип, который вы хотите использовать, не входит в prelude, вам нужно явно подключить этот тип к области видимости программы, используя инструкцию <code>use</code>. Библиотека <code>std::io</code> даст вам набор полезных возможностей, включая получение пользовательского ввода.</p>
<p>Как вы увидели в Главе 1, функция <code>main</code> — это точка входа в программу:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span>fn main() {
<span class="boring">    println!("Угадайте число!");
</span><span class="boring">
</span><span class="boring">    println!("Введите свою догадку.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Не удалось прочесть ввод.");
</span><span class="boring">
</span><span class="boring">    println!("Вы предположили: {guess}");
</span><span class="boring">}</span></code></pre>
<p>Новая функция объявляется ключевым словом <code>fn</code>. Пустые круглые скобки <code>()</code> обозначают, что эта функция не имеет параметов. Открывающая игурная скобка <code>{</code> определяет начало тела функции.</p>
<p>Как вы также узнали в Главе 1, <code>println!</code> — это макрос, печатающий строку на экран:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    println!("Угадайте число!");

    println!("Введите свою догадку.");
<span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Не удалось прочесть ввод.");
</span><span class="boring">
</span><span class="boring">    println!("Вы предположили: {guess}");
</span><span class="boring">}</span></code></pre>
<p>Этот код печатает фразы: сообщающую о сути игры и запрашивающую ввод от пользователя</p>
<h3 id="Хранение-значений-с-помощью-переменных"><a class="header" href="#Хранение-значений-с-помощью-переменных">Хранение значений с помощью переменных</a></h3>
<p>Далее! Создадим <em>переменную</em> для хранения пользовательского ввода, вот так:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Угадайте число!");
</span><span class="boring">
</span><span class="boring">    println!("Введите свою догадку.");
</span><span class="boring">
</span>    let mut guess = String::new();
<span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Не удалось прочесть ввод.");
</span><span class="boring">
</span><span class="boring">    println!("Вы предположили: {guess}");
</span><span class="boring">}</span></code></pre>
<p>Программа становится интереснее! В этой строчке, на самом деле, происходит очень многое. Мы используем инструкцию <code>let</code> для создания переменной. Вот ещё пример:</p>
<pre><code class="language-rust ignore">let apples = 5;</code></pre>
<p>This line creates a new variable named <code>apples</code> and binds it to the value <code>5</code>. In Rust, variables are immutable by default, meaning once we give the variable a value, the value won’t change. We’ll be discussing this concept in detail in the <a href="ch03-01-variables-and-mutability.html#variables-and-mutability">“Variables and Mutability”</a><!-- ignore --> section in Chapter 3. To make a variable mutable, we add <code>mut</code> before the variable name:</p>
<pre><code class="language-rust ignore">let apples = 5; // неизменяема
let mut bananas = 5; // изменяема</code></pre>
<blockquote>
<p>Примечание: символы <code>//</code> обозначают начало комментария, продолжающегося до конца строки. Rust игнорирует весь текст в комментариях. Мы детальнее обсудим комментирование в <a href="ch03-04-comments.html">Главе 3</a><!-- ignore -->.</p>
</blockquote>
<p>Вернёмся к программе игры в угадайку. Теперь вы знаете, что <code>let mut guess</code> создаёт изменяемую переменную <code>guess</code>. Знак равенства (<code>=</code>) говорит о том, что мы хотим связать что бы то ни было с данной переменной. Значение, с которым связывается переменная <code>guess</code>, располагается справа от знака равенства; оно является результатом вызова функции <code>String::new</code> — функции, возвращающей новое значение типа <code>String</code>. [<code>String</code>](https://doc.rust-lang.org/std/string/struct. String.html)<!-- ignore --> — это тип строки, предоставляемый стандартной библиотекой. Он представляет собой строку текста переменной длины в кодировке UTF-8.</p>
<p>Символы "::" в части <code>::new</code> показывают, что <code>new</code> — функция, ассоциированная с типом <code>String</code>. <em>Ассоциированная функция</em> — это функция, реализованная на типе (в данном случае — на <code>String</code>). Функция <code>new</code> создаёт новую, пустую строку. Многие типы имеют ассоциированную функцию <code>new</code>, поскольку это стандартное, типичное имя для функции, создающей некое значение типа, которое можно назвать новым.</p>
<p>В совокупности, строчка <code>let mut guess = String::new();</code> создаёт изменяемую переменную, связанную с новым, пустым экземпляром типа <code>String</code>. Фух!</p>
<h3 id="Получение-пользовательского-ввода"><a class="header" href="#Получение-пользовательского-ввода">Получение пользовательского ввода</a></h3>
<p>Напомним, что мы подключили функциональность ввода-вывода из стандартной библиотеки, написав <code>use std::io;</code> в первой строчке программы. Теперь вызовем функцию <code>stdin</code> из модуля <code>io</code>, которая позволит нам получать пользовательский ввод:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Угадайте число!");
</span><span class="boring">
</span><span class="boring">    println!("Введите свою догадку.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span>    io::stdin()
        .read_line(&amp;mut guess)
<span class="boring">        .expect("Не удалось прочесть ввод.");
</span><span class="boring">
</span><span class="boring">    println!("Вы предположили: {guess}");
</span><span class="boring">}</span></code></pre>
<p>If we hadn’t imported the <code>io</code> module with <code>use std::io;</code> at the beginning of the program, we could still use the function by writing this function call as <code>std::io::stdin</code>. The <code>stdin</code> function returns an instance of <a href="../std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore -->, which is a type that represents a handle to the standard input for your terminal.</p>
<p>Next, the line <code>.read_line(&amp;mut guess)</code> calls the <a href="../std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a><!--
ignore --> method on the standard input handle to get input from the user. We’re also passing <code>&amp;mut guess</code> as the argument to <code>read_line</code> to tell it what string to store the user input in. The full job of <code>read_line</code> is to take whatever the user types into standard input and append that into a string (without overwriting its contents), so we therefore pass that string as an argument. The string argument needs to be mutable so that the method can change the string’s content.</p>
<p>Знак <code>&amp;</code> означает, что мы передаём методу не само значение, а <em>ссылку</em> на его область памяти. Это позволяет давать нескольким частям программы доступ к одной и той же информации, без необоходимости многократно копировать её. Ссылки — вещь многогранная, и одним из основных преимуществ Rust является безопасность и простота их использования. Касательно всего, что мы обсудили: на данный момент вам достаточно знать, что по умолчанию переменные и ссылки неизменяемы. Поэтому нам пришлось написать <code>&amp;mut guess</code> вместо <code>&amp;guess</code>, чтобы сделать получить возможность изменять нужную нам область памяти. (В Главе 4 ссылки будут рассмотрены подробнее.)</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="handling-potential-failure-with-the-result-type"></a></p>
<h3 id="Обработка-возможных-ошибок-с-помощью-result"><a class="header" href="#Обработка-возможных-ошибок-с-помощью-result">Обработка возможных ошибок с помощью <code>Result</code></a></h3>
<p>Мы ещё не закончили с той строчкой, той последовательностью методов. Теперь мы обсудим третью строчку, однако стоит отметить, что, логически, это всё одна строка кода. Вот строчка, о которой мы говорим:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Угадайте число!");
</span><span class="boring">
</span><span class="boring">    println!("Введите свою догадку.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span>        .expect("Не удалось прочесть ввод.");
<span class="boring">
</span><span class="boring">    println!("Вы предположили: {guess}");
</span><span class="boring">}</span></code></pre>
<p>Мы могли бы переписать всю строку кода вот так:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess).expect("Не удалось прочесть ввод.");</code></pre>
<p>Однако, одну длинную строчку читать было бы тяжело, так что мы её разделили, перенеся вызовы методов (<code>.method_name()</code>) на новые строчки и отбив их пробелами от края. Теперь обсудим, что именно делает эта строка.</p>
<p>Как ранее упоминалось, <code>read_line</code> помещает всё, что пользователь ввёл в стандартный поток вывода, в строку, получаемую как аргумент. Но он также возвращает значение типа <code>Result</code>. <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a><!--ignore --> — это <a href="ch06-00-enums.html"><em>перечисление</em></a><!-- ignore -->, то есть тип, который может быть представлен одним из возможных состояний. Мы называем каждое такое возможное состояние <em>вариантом.</em></p>
<p>В <a href="ch06-00-enums.html">Главе 6</a><!-- ignore --> мы в деталях обсудим перечисления. Пока вам достаточно знать, что тип <code>Result</code> — это тип, варианты которого хранят информацию для обработки ошибок.</p>
<p>Вариантами типа <code>Result</code> являются <code>Ok</code> и <code>Err</code>. Вариант <code>Ok</code> означает успешное исполнение операции и содержит в себе результат её исполнения. Вариант <code>Err</code> означает, что операцию не удалось исполнить, и содержит информацию об ошибке.</p>
<p>Values of the <code>Result</code> type, like values of any type, have methods defined on them. An instance of <code>Result</code> has an <a href="../std/result/enum.Result.html#method.expect"><code>expect</code> method</a><!-- ignore --> that you can call. If this instance of <code>Result</code> is an <code>Err</code> value, <code>expect</code> will cause the program to crash and display the message that you passed as an argument to <code>expect</code>. If the <code>read_line</code> method returns an <code>Err</code>, it would likely be the result of an error coming from the underlying operating system. If this instance of <code>Result</code> is an <code>Ok</code> value, <code>expect</code> will take the return value that <code>Ok</code> is holding and return just that value to you so that you can use it. In this case, that value is the number of bytes in the user’s input.</p>
<p>Если вы не вызовите <code>expect</code>, то программа скомпилируется, но вы получите предупреждение:</p>
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `Result` that must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
10 |     let _ = io::stdin().read_line(&amp;mut guess);
   |     +++++++

warning: `guessing_game` (bin "guessing_game") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>Rust предупреждает вас, что: 1) вы не используете значение типа <code>Result</code>, возвращаемое методом <code>read_line</code>, и 2) вы не обрабатываете возможную ошибку, с которой может завершиться вызов этого метода.</p>
<p>Правильный способ избавиться от таких предупреждений — это писать код с обработками ошибок. Однако, в нашем случае, мы хотим просто аварийно завершить нашу программу, если что-то пойдёт не так, поэтому использование <code>expect</code> допустимо. Больше об обработке ошибок вы узнаете в [Главе 9] (ch09-02-recoverable-errors-with-result.html)<!-- ignore -->.</p>
<h3 id="Печать-значений-переменных-с-помощью-меток-подстановки-println"><a class="header" href="#Печать-значений-переменных-с-помощью-меток-подстановки-println">Печать значений переменных с помощью меток подстановки <code>println!</code></a></h3>
<p>Не считая закрывающей фигурной скобки, нам пока что осталось обсудить лишь одну строчку:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Угадайте число!");
</span><span class="boring">
</span><span class="boring">    println!("Введите свою догадку.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Не удалось прочесть ввод.");
</span><span class="boring">
</span>    println!("Вы предположили: {guess}");
<span class="boring">}</span></code></pre>
<p>This line prints the string that now contains the user’s input. The <code>{}</code> set of curly brackets is a placeholder: Think of <code>{}</code> as little crab pincers that hold a value in place. When printing the value of a variable, the variable name can go inside the curly brackets. When printing the result of evaluating an expression, place empty curly brackets in the format string, then follow the format string with a comma-separated list of expressions to print in each empty curly bracket placeholder in the same order. Printing a variable and the result of an expression in one call to <code>println!</code> would look like this:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = 10;

println!("x = {x} и y + 2 = {}", y + 2);
<span class="boring">}</span></code></pre></pre>
<p>Этот код напечатает <code>x = 5 и y + 2 = 12</code>.</p>
<h3 id="Проверяем-первую-часть"><a class="header" href="#Проверяем-первую-часть">Проверяем первую часть</a></h3>
<p>Проверим первую часть игры в угадайку. Запустим её, используя <code>cargo run</code>:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-01/
cargo clean
cargo run
input 6 -->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Угадайте число!
Введите свою догадку.
6
Вы предположили: 6
</code></pre>
<p>At this point, the first part of the game is done: We’re getting input from the keyboard and then printing it.</p>
<h2 id="Генерация-секретного-числа"><a class="header" href="#Генерация-секретного-числа">Генерация секретного числа</a></h2>
<p>Next, we need to generate a secret number that the user will try to guess. The secret number should be different every time so that the game is fun to play more than once. We’ll use a random number between 1 and 100 so that the game isn’t too difficult. Rust doesn’t yet include random number functionality in its standard library. However, the Rust team does provide a <a href="https://crates.io/crates/rand"><code>rand</code> crate</a> with said functionality.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="using-a-crate-to-get-more-functionality"></a></p>
<h3 id="increasing-functionality-with-a-crate"><a class="header" href="#increasing-functionality-with-a-crate">Increasing Functionality with a Crate</a></h3>
<p>Remember that a crate is a collection of Rust source code files. The project we’ve been building is a binary crate, which is an executable. The <code>rand</code> crate is a library crate, which contains code that is intended to be used in other programs and can’t be executed on its own.</p>
<p>Управление внешними крейтами — это конёк Cargo. Чтобы получить возможность использовать крейт <code>rand</code>, нам нужно отредактировать файл <em>Cargo.toml</em>, чтобы включить этот крейт как зависимость. Откройте этот файл и добавьте строчки ниже в его конец (то есть под <code>[dependencies]</code> — заголовком раздела зависимостей). Убедитесь, что вы подключили версию <code>rand</code> ровно такую же, что и мы, иначе наши примеры могут не заработать у вас.</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
* ch14-03-cargo-workspaces.md
-->
<p><span class="filename">Файл: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = "0.8.5"
</code></pre>
<p>In the <em>Cargo.toml</em> file, everything that follows a header is part of that section that continues until another section starts. In <code>[dependencies]</code>, you tell Cargo which external crates your project depends on and which versions of those crates you require. In this case, we specify the <code>rand</code> crate with the semantic version specifier <code>0.8.5</code>. Cargo understands <a href="http://semver.org">Semantic Versioning</a><!-- ignore --> (sometimes called <em>SemVer</em>), which is a standard for writing version numbers. The specifier <code>0.8.5</code> is actually shorthand for <code>^0.8.5</code>, which means any version that is at least 0.8.5 but below 0.9.0.</p>
<p>Cargo considers these versions to have public APIs compatible with version 0.8.5, and this specification ensures that you’ll get the latest patch release that will still compile with the code in this chapter. Any version 0.9.0 or greater is not guaranteed to have the same API as what the following examples use.</p>
<p>Теперь, ничего не меняя в программе, давайте соберём проект, как показано в Листинге 2-2.</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
rm Cargo.lock
cargo clean
cargo build -->
<Listing number="2-2" caption="The output from running `cargo build` after adding the `rand` crate as a dependency">
<pre><code class="language-console">$ cargo build
  Updating crates.io index
   Locking 15 packages to latest Rust 1.85.0 compatible versions
    Adding rand v0.8.5 (available: v0.9.0)
 Compiling proc-macro2 v1.0.93
 Compiling unicode-ident v1.0.17
 Compiling libc v0.2.170
 Compiling cfg-if v1.0.0
 Compiling byteorder v1.5.0
 Compiling getrandom v0.2.15
 Compiling rand_core v0.6.4
 Compiling quote v1.0.38
 Compiling syn v2.0.98
 Compiling zerocopy-derive v0.7.35
 Compiling zerocopy v0.7.35
 Compiling ppv-lite86 v0.2.20
 Compiling rand_chacha v0.3.1
 Compiling rand v0.8.5
 Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
  Finished `dev` profile [unoptimized + debuginfo] target(s) in 2.48s
</code></pre>
</Listing>
<p>Если вы проделаете всё на своей машине, вы можете увидеть другие (но всё ещё обратно совместимые; спасибо SemVer!) версии крейтов и другие печатаемые строчки (в зависимости от вашей операционной системы), и они могут быть расположены в другом порядке.</p>
<p>Когда мы подключаем зависимость, Cargo собирает всё, что она сама требует, используя <em>реестр</em> (<em>registry</em>), представляющий собой копию данных с сайта <a href="https://crates.io/">Crates.io</a>. Crates.io — это часть экосистемы Rust, место для публикации проектов с открытым исходным кодом, доступных каждому.</p>
<p>После обновления реестра, Cargo проверяет раздел <code>[dependencies]</code> и скачивает все крейты, которые ещё не скачаны. В нашем случае, мы подключаем как зависимость лишь крейт <code>rand</code>, однако Cargo также загружает всё, что требуется уже самому крейту <code>rand</code>. После скачивания крейтов, Rust компилирует их, а затем компилирует и проект.</p>
<p>Если вы сразу же вновь запустите <code>cargo build</code>, ничего не изменив в проекте, вы не увидите ничего, кроме строки <code>Finished</code>. Cargo видит, что вы ничего не поменяли в файле <em>Cargo.toml</em>, и он помнит, что зависимости уже были скачаны и скомпилированы. Cargo также видит, что вы ничего не поменяли и в исходном коде, так что он совершенно ничего не перекомпилирует. Поскольку делать ему больше и нечего, он просто сообщает об успешной сборке.</p>
<p>Если вы откроете файл <em>src/main.rs</em> и внесёте какие-нибудь изменения, сохраните их и ещё раз запуситите сборку, вы увидите лишь две строчки вывода:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
touch src/main.rs
cargo build -->
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s
</code></pre>
<p>Эти строчки показывают, что Cargo пересобрал лишь ваш код, поскольку увидел небольшое изменение в файле <em>src/main.rs</em>. Ваши зависимости не поменялись, поэтому Cargo не стал их ещё раз загружать и компилировать.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="ensuring-reproducible-builds-with-the-cargo-lock-file"></a></p>
<h4 id="ensuring-reproducible-builds"><a class="header" href="#ensuring-reproducible-builds">Ensuring Reproducible Builds</a></h4>
<p>Cargo has a mechanism that ensures that you can rebuild the same artifact every time you or anyone else builds your code: Cargo will use only the versions of the dependencies you specified until you indicate otherwise. For example, say that next week version 0.8.6 of the <code>rand</code> crate comes out, and that version contains an important bug fix, but it also contains a regression that will break your code. To handle this, Rust creates the <em>Cargo.lock</em> file the first time you run <code>cargo build</code>, so we now have this in the <em>guessing_game</em> directory.</p>
<p>Когда вы впервые собираете проект, Cargo выясняет всё о версиях зависимостей, которые удовлетворяют требованиям, и записывает информацию о них в файл <em>Cargo.lock</em>. Когда вы ещё раз соберёте проект, Cargo увидит, что файл <em>Cargo.lock</em> уже существует, и воспользуется указанными в нём версиями. Это автоматически делает ваш код воспроизводимым. Иными словами, ваш проект продолжит использовать версию 0.8.5 до тех пор, пока вы не обновитесь явно — и всё благодаря файлу <em>Cargo.lock</em>. Поскольку файл <em>Cargo.lock</em> важен для обеспечения воспроизводимости сборок, он часто включается в систему управления версиями вместе с остальным кодом вашего проекта.</p>
<h4 id="Обновление-крейта-до-новейшей-версии"><a class="header" href="#Обновление-крейта-до-новейшей-версии">Обновление крейта до новейшей версии</a></h4>
<p>When you <em>do</em> want to update a crate, Cargo provides the command <code>update</code>, which will ignore the <em>Cargo.lock</em> file and figure out all the latest versions that fit your specifications in <em>Cargo.toml</em>. Cargo will then write those versions to the <em>Cargo.lock</em> file. Otherwise, by default, Cargo will only look for versions greater than 0.8.5 and less than 0.9.0. If the <code>rand</code> crate has released the two new versions 0.8.6 and 0.999.0, you would see the following if you ran <code>cargo update</code>:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
cargo update
assuming there is a new 0.8.x version of rand; otherwise use another update
as a guide to creating the hypothetical output shown here -->
<pre><code class="language-console">$ cargo update
    Updating crates.io index
     Locking 1 package to latest Rust 1.85.0 compatible version
    Updating rand v0.8.5 -&gt; v0.8.6 (available: v0.999.0)
</code></pre>
<p>Cargo ignores the 0.999.0 release. At this point, you would also notice a change in your <em>Cargo.lock</em> file noting that the version of the <code>rand</code> crate you are now using is 0.8.6. To use <code>rand</code> version 0.999.0 or any version in the 0.999.<em>x</em> series, you’d have to update the <em>Cargo.toml</em> file to look like this instead (don’t actually make this change because the following examples assume you’re using <code>rand</code> 0.8):</p>
<pre><code class="language-toml">[dependencies]
rand = "0.999.0"
</code></pre>
<p>В следующий раз, когда вы запустите <code>cargo build</code>, Cargo обновит реестр доступных крейтов и обновит вашу зависимость <code>rand</code> согласно определённой вами новой версии.</p>
<p>Мы оставим подробности о [Cargo](https://rust-lang-translations.org/ cargo/)<!-- ignore --> и [его экосистеме](https://rust-lang-translations.org/cargo/ reference/publishing.html)<!-- ignore --> до Главы 14. Cargo делает переиспользование вашего кода другими людьми (и наоборот) значительно более простым, так что у программистов на Rust есть отличная возможность писать небольшие проекты, собранные на основе нескольких пакетов.</p>
<h3 id="Генерация-случайного-числа"><a class="header" href="#Генерация-случайного-числа">Генерация случайного числа</a></h3>
<p>Применим <code>rand</code> для загадывания числа. Обновите файл <em>src/main.rs</em>, поместив в него код Листинга 2-3.</p>
<Listing number="2-3" file-name="src/main.rs" caption="Adding code to generate a random number">
<pre><code class="language-rust ignore">use std::io;

use rand::Rng;

fn main() {
    println!("Угадайте число!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    println!("Загаданное число: {secret_number}");

    println!("Введите свою догадку.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Не удалось прочесть ввод.");

    println!("Вы предположили: {guess}");
}</code></pre>
</Listing>
<p>First, we add the line <code>use rand::Rng;</code>. The <code>Rng</code> trait defines methods that random number generators implement, and this trait must be in scope for us to use those methods. Chapter 10 will cover traits in detail.</p>
<p>Next, we’re adding two lines in the middle. In the first line, we call the <code>rand::thread_rng</code> function that gives us the particular random number generator we’re going to use: one that is local to the current thread of execution and is seeded by the operating system. Then, we call the <code>gen_range</code> method on the random number generator. This method is defined by the <code>Rng</code> trait that we brought into scope with the <code>use rand::Rng;</code> statement. The <code>gen_range</code> method takes a range expression as an argument and generates a random number in the range. The kind of range expression we’re using here takes the form <code>start..=end</code> and is inclusive on the lower and upper bounds, so we need to specify <code>1..=100</code> to request a number between 1 and 100.</p>
<blockquote>
<p>Примечание: Вы почти наверняка не будете знать, какие трейты использовать и  какие методы и функции вызывать из крейта. В этом случае вам поможет документация крейта. С ней связана ещё одна приятная особенность Cargo: комманда <code>cargo doc --open</code> соберёт всю документацию, предоставляемую вашими крейтами-зависимостями, и откроет её автономную копию в браузере. Так, если вам интересная другая функциональность крейта <code>rand</code>, вы можете найти её в документации: выполните <code>cargo doc --open</code> и кликните по <code>rand</code> на левой панели.</p>
</blockquote>
<p>Вторая новая строчка печатает секретное число. Это полезно, когда мы разрабатываем программу, но мы удалим это поведение программы из финальной версии. Но очень-то и игрой будет программа, сообщающая ответ сразу при запуске!</p>
<p>Попробуйте запустить программу несколько раз:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-03/
cargo run
4
cargo run
5
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Угадайте число!
Загаданное число: 7
Введите свою догадку.
4
Вы предположили: 4

$ cargo run
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Угадайте число!
Загаданное число: 83
Введите свою догадку.
5
Вы предположили: 5
</code></pre>
<p>Вы должны увидеть разные случайные числа, и они должны быть в пределах от 1 до 100. Отличная работа!</p>
<h2 id="Сравнение-догадки-с-загаданным-числом"><a class="header" href="#Сравнение-догадки-с-загаданным-числом">Сравнение догадки с загаданным числом</a></h2>
<p>Теперь мы имеем пользовательский ввод и случайное число, а значит, мы можем их сравнить. Этот шаг показан в Листинге 2-4. Обратите внимание, что этот код не скомпилируется.</p>
<Listing number="2-4" file-name="src/main.rs" caption="Handling the possible return values of comparing two numbers">
<pre><code class="language-rust ignore does_not_compile">use std::cmp::Ordering;
use std::io;

use rand::Rng;

fn main() {
    // --код сокращён--
<span class="boring">    println!("Угадайте число!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("Загаданное число: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Введите свою догадку.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Не удалось прочесть ввод.");
</span>
    println!("Вы предположили: {guess}");

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!("Слишком маленькое!"),
        Ordering::Greater =&gt; println!("Слишком большое!"),
        Ordering::Equal =&gt; println!("Вы победили!"),
    }
}</code></pre>
</Listing>
<p>First, we add another <code>use</code> statement, bringing a type called <code>std::cmp::Ordering</code> into scope from the standard library. The <code>Ordering</code> type is another enum and has the variants <code>Less</code>, <code>Greater</code>, and <code>Equal</code>. These are the three outcomes that are possible when you compare two values.</p>
<p>Then, we add five new lines at the bottom that use the <code>Ordering</code> type. The <code>cmp</code> method compares two values and can be called on anything that can be compared. It takes a reference to whatever you want to compare with: Here, it’s comparing <code>guess</code> to <code>secret_number</code>. Then, it returns a variant of the <code>Ordering</code> enum we brought into scope with the <code>use</code> statement. We use a <a href="ch06-02-match.html"><code>match</code></a><!-- ignore --> expression to decide what to do next based on which variant of <code>Ordering</code> was returned from the call to <code>cmp</code> with the values in <code>guess</code> and <code>secret_number</code>.</p>
<p>A <code>match</code> expression is made up of <em>arms</em>. An arm consists of a <em>pattern</em> to match against, and the code that should be run if the value given to <code>match</code> fits that arm’s pattern. Rust takes the value given to <code>match</code> and looks through each arm’s pattern in turn. Patterns and the <code>match</code> construct are powerful Rust features: They let you express a variety of situations your code might encounter, and they make sure you handle them all. These features will be covered in detail in Chapter 6 and Chapter 19, respectively.</p>
<p>Рассмотрим наш вышеприведённый пример с выражением <code>match</code>. Предположим, что пользователь дал догадку 50, а загадано было число 38.</p>
<p>Если мы сравним 50 с 38, метод <code>cmp</code> вернёт <code>Ordering::Greater</code>, поскольку 50 больше 38. Выражение <code>match</code> берёт значение <code>Ordering::Greater</code> и начинает последовательно проверять каждый шаблон. Оно смотрит на первый шаблон — <code>Ordering::Less</code> — и видит, что значение <code>Ordering::Greater</code> не сопоставимо с ним, а потому код этой ветви игнорируется, и сравнение с шаблонами идёт дальше. Следующий шаблон — <code>Ordering::Greater</code>, и он <em>сопоставляется</em> с <code>Ordering::Greater</code>! Связанный с шаблоном код исполняется, и на экран печатается <code>Too big!</code>. Выражение <code>match</code> завершается после первого успешного сопоставления, и проверок с оставшимися шаблонами не происходит.</p>
<p>Однако, код Листина 2-4 всё ещё не будет компилироваться:</p>
<!--
The error numbers in this output should be that of the code **WITHOUT** the
anchor or snip comments
-->
<pre><code class="language-console">$ cargo build
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_core v0.6.2
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  --&gt; src/main.rs:23:21
   |
23 |     match guess.cmp(&amp;secret_number) {
   |                 --- ^^^^^^^^^^^^^^ expected `&amp;String`, found `&amp;{integer}`
   |                 |
   |                 arguments to this method are incorrect
   |
   = note: expected reference `&amp;String`
              found reference `&amp;{integer}`
note: method defined here
  --&gt; /rustc/1159e78c4747b02ef996e55082b704c09b970588/library/core/src/cmp.rs:979:8

For more information about this error, try `rustc --explain E0308`.
error: could not compile `guessing_game` (bin "guessing_game") due to 1 previous error
</code></pre>
<p>В сердце ошибки находится в <em>несоответствии типов</em>. Rust — язык с сильной статической типизацией. Однако, он также способен самостоятельно вывести тип. Когда мы пишем <code>let mut guess = String::new()</code>, Rust может вывести, что <code>guess</code> должна быть типа <code>String</code>, а потому с нас не требуется уточнять тип. <code>secret_number</code> же — это целочисленный тип. Типов Rust, которые могут представлять числа от 1 до 100, множество: <code>i32</code>, знаковое 32-битное число; <code>u32</code>, беззнаковое 32-битное число; <code>i64</code>, знаковое 64-битное число; и так далее. В случае равновозможности использования нескольких числовых типов, Rust выводит для числа тип <code>i32</code>. Это он и делает с <code>secret_number</code> — выводит <code>i32</code>, пока не появится дополнительная информация, которая заставила бы Rust вывести другой тип. Причиной же ошибки является невозможность в Rust сравнить значения строкового и числового типов.</p>
<p>Ultimately, we want to convert the <code>String</code> the program reads as input into a number type so that we can compare it numerically to the secret number. We do so by adding this line to the <code>main</code> function body:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">use rand::Rng;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Угадайте число!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("Загаданное число: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Введите свою догадку.");
</span><span class="boring">
</span>    // --код сокращён--

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Не удалось прочесть ввод.");

    let guess: u32 = guess.trim().parse().expect("Пожалуйста, введите число!");

    println!("Вы предположили: {guess}");

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!("Слишком маленькое!"),
        Ordering::Greater =&gt; println!("Слишком большое!"),
        Ordering::Equal =&gt; println!("Вы победили!"),
    }
<span class="boring">}</span></code></pre>
<p>... вот эту строчку:</p>
<pre><code class="language-rust ignore">let guess: u32 = guess.trim().parse().expect("Пожалуйста, введите число!");</code></pre>
<p>Здесь мы создаём переменную <code>guess</code>. Но только... в программе же уже есть переменная <code>guess</code>, верно? Да, это так, в самом деле; но Rust позволяет переобъявлять переменные, присваивая им новые значения (и даже других типов). Это называется <em>затенением</em>; оно позволяет переиспользовать имя переменной вместо того, чтобы создавать несколько переменных одинакового смысла, но разных типов (например, <code>guess_str</code> и <code>guess</code>). Мы обсудим это детальнее в <a href="ch03-01-variables-and-mutability.html#%D0%97%D0%B0%D1%82%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5">Главе 3</a><!-- ignore -->, а пока просто знайте, что затенение часто полезно, когда вам нужно преобразовать значение из одного типа в другой.</p>
<p>Мы связываем эту новую переменную со значением выражения <code>guess.trim().parse()</code>. В нём, <code>guess</code> — это название уже ранее существующей переменной: нашей изначальной <code>guess</code>, содержащей ввод в виде строки. Метод <code>trim</code>, реализованный для экземпляров <code>String</code>, убирает начальные и конечные пробелы — нам нужно это сделать перед конвертацией строки в число типа <code>u32</code> (целое, беззнаковое, 32-битное). Пользователь должен нажать <kbd>Enter</kbd>, чтобы <code>read_line</code> исполнился и считал введённую информацию. Однако считанная строка будет включать в себя символ начала новой строки. Например, если пользователь напечатает <kbd>5</kbd> и потом нажмёт <kbd>Enter</kbd>, <code>guess</code> будет выглядеть вот так: <code>5\n</code>. <code>\n</code> — это обозначение для символа начала новой строки. (Стоит отметить, что на Windows нажатие <kbd>Enter</kbd> сопровождается возвратом каретки, и только потом символом начала новой строки, что всё вместе даёт <code>\r\n</code>.) Метод <code>trim</code> сможет убрать как <code>\n</code>, так и <code>\r\n</code>, и вернёт просто строку <code>5</code>.</p>
<p><a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse">Метод <code>parse</code> строк</a> <!-- ignore --> преобразует строку к другому типу. В нашем случае, мы используем его для приведения строки к числу. Нам нужно указать Rust, к какому конкретному числовому типу мы хотим привести наш ввод, и для этого мы явно указываем тип переменной: <code>let guess: u32</code>. Двоеточие (<code>:</code>) после <code>guess</code> используется для аннотирования типа переменной. В Rust есть встроенные числовые типы; использованный нами тип <code>u32</code> означает целое беззнаковое 32-битное число — хороший выбор для относительно небольших положительных чисел. Вы узнаете больше о других числовых типах в <a href="ch03-02-data-types.html#%D0%A6%D0%B5%D0%BB%D0%BE%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B">Главе 3</a><!-- ignore -->.</p>
<p>Additionally, the <code>u32</code> annotation in this example program and the comparison with <code>secret_number</code> means Rust will infer that <code>secret_number</code> should be a <code>u32</code> as well. So, now the comparison will be between two values of the same type!</p>
<p>The <code>parse</code> method will only work on characters that can logically be converted into numbers and so can easily cause errors. If, for example, the string contained <code>A👍%</code>, there would be no way to convert that to a number. Because it might fail, the <code>parse</code> method returns a <code>Result</code> type, much as the <code>read_line</code> method does (discussed earlier in <a href="#handling-potential-failure-with-result">“Handling Potential Failure with <code>Result</code>”</a><!-- ignore -->). We’ll treat this <code>Result</code> the same way by using the <code>expect</code> method again. If <code>parse</code> returns an <code>Err</code> <code>Result</code> variant because it couldn’t create a number from the string, the <code>expect</code> call will crash the game and print the message we give it. If <code>parse</code> can successfully convert the string to a number, it will return the <code>Ok</code> variant of <code>Result</code>, and <code>expect</code> will return the number that we want from the <code>Ok</code> value.</p>
<p>Теперь запустим нашу программу:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/
touch src/main.rs
cargo run
  76
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.26s
     Running `target/debug/guessing_game`
Угадайте число!
Загаданное число: 58
Введите свою догадку.
  76
Вы предположили: 76
Слишком большое!
</code></pre>
<p>Nice! Even though spaces were added before the guess, the program still figured out that the user guessed 76. Run the program a few times to verify the different behavior with different kinds of input: Guess the number correctly, guess a number that is too high, and guess a number that is too low.</p>
<p>Большая часть игры готова, но пользователь пока что может сделать дать одну догадку. Изменим это, добавив цикл!</p>
<h2 id="Возможность-дать-догадку-не-один-раз-с-помощью-циклов"><a class="header" href="#Возможность-дать-догадку-не-один-раз-с-помощью-циклов">Возможность дать догадку не один раз с помощью циклов</a></h2>
<p>Ключевое слово <code>loop</code> создаёт бесконечный цикл. Мы добавим цикл, чтобы дать пользователю больше попыток угадать число:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">use rand::Rng;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Угадайте число!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    // --код сокращён--

    println!("Загаданное число: {secret_number}");

    loop {
        println!("Введите свою догадку.");

        // --код сокращён--

<span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("Не удалось прочесть ввод.");
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect("Пожалуйста, введите число!");
</span><span class="boring">
</span><span class="boring">        println!("Вы предположили: {guess}");
</span><span class="boring">
</span>        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Слишком маленькое!"),
            Ordering::Greater =&gt; println!("Слишком большое!"),
            Ordering::Equal =&gt; println!("Вы победили!"),
        }
    }
}</code></pre>
<p>Как вы можете видеть, мы переместили весь код обработки догадки в цикл. Убедитесь, что отбили строчки от левого края ещё четырьмя пробелами каждую, и снова запустите программу. Программа теперь будет спрашивать догадку бесконечно, и это создало нам новую проблему: игра никогда не закончится!</p>
<p>The user could always interrupt the program by using the keyboard shortcut <kbd>ctrl</kbd>-<kbd>C</kbd>. But there’s another way to escape this insatiable monster, as mentioned in the <code>parse</code> discussion in <a href="#comparing-the-guess-to-the-secret-number">“Comparing the Guess to the Secret Number”</a><!-- ignore -->: If the user enters a non-number answer, the program will crash. We can take advantage of that to allow the user to quit, as shown here:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-04-looping/
touch src/main.rs
cargo run
(too small guess)
(too big guess)
(correct guess)
quit
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.23s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit

thread 'main' panicked at src/main.rs:28:47:
Please type a number!: ParseIntError { kind: InvalidDigit }
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Ввод слова <code>quit</code> остановит программу, но как вы можете заметить, это произойдёт при любом нечисловом вводе. Такое поведение программы, мягко говоря, неоптимально. Мы хотим, чтобы игра завершалась, когда догадка игрока оказывается правильной.</p>
<h3 id="Завершение-игры-после-правильной-догадки"><a class="header" href="#Завершение-игры-после-правильной-догадки">Завершение игры после правильной догадки</a></h3>
<p>Запрограммируем выход из игры, когда игрок побеждает. Для этого, используем инструкцию <code>break</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">use rand::Rng;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Угадайте число!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("Загаданное число: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!("Введите свою догадку.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("Не удалось прочесть ввод.");
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect("Пожалуйста, введите число!");
</span><span class="boring">
</span><span class="boring">        println!("Вы предположили: {guess}");
</span><span class="boring">
</span>        // --код сокращён--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Слишком маленькое!"),
            Ordering::Greater =&gt; println!("Слишком большое!"),
            Ordering::Equal =&gt; {
                println!("Вы победили!");
                break;
            }
        }
    }
}</code></pre>
<p>Строка <code>break</code> после <code>You win!</code> заставляет программу покинуть цикл, когда игрок делает правильную догадку. Выход из цикла также означает конец программы, поскольку цикл оказывается последней частью <code>main</code>.</p>
<h3 id="Обработка-неправильного-ввода"><a class="header" href="#Обработка-неправильного-ввода">Обработка неправильного ввода</a></h3>
<p>To further refine the game’s behavior, rather than crashing the program when the user inputs a non-number, let’s make the game ignore a non-number so that the user can continue guessing. We can do that by altering the line where <code>guess</code> is converted from a <code>String</code> to a <code>u32</code>, as shown in Listing 2-5.</p>
<Listing number="2-5" file-name="src/main.rs" caption="Ignoring a non-number guess and asking for another guess instead of crashing the program">
<pre><code class="language-rust ignore"><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">use rand::Rng;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Угадайте число!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("Загаданное число: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!("Введите свою догадку.");
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span>        // --код сокращён--

        io::stdin()
            .read_line(&amp;mut guess)
            .expect("Не удалось прочесть ввод.");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!("Вы предположили: {guess}");

        // --код сокращён--
<span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!("Слишком маленькое!"),
</span><span class="boring">            Ordering::Greater =&gt; println!("Слишком большое!"),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!("Вы победили!");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>We switch from an <code>expect</code> call to a <code>match</code> expression to move from crashing on an error to handling the error. Remember that <code>parse</code> returns a <code>Result</code> type and <code>Result</code> is an enum that has the variants <code>Ok</code> and <code>Err</code>. We’re using a <code>match</code> expression here, as we did with the <code>Ordering</code> result of the <code>cmp</code> method.</p>
<p>Если <code>parse</code> может преобразовать строку в число, он вернёт значение <code>Ok</code>, содержащее результат преобразования — число. Этот <code>Ok</code> сопоставится с шаблоном первой ветви, и выражение <code>match</code> просто вернёт значение <code>num</code>, которое до этого создало <code>parse</code> и поместило в значение <code>Ok</code>. Это число будет сохранено в созданной нами переменной <code>guess</code>.</p>
<p>If <code>parse</code> is <em>not</em> able to turn the string into a number, it will return an <code>Err</code> value that contains more information about the error. The <code>Err</code> value does not match the <code>Ok(num)</code> pattern in the first <code>match</code> arm, but it does match the <code>Err(_)</code> pattern in the second arm. The underscore, <code>_</code>, is a catch-all value; in this example, we’re saying we want to match all <code>Err</code> values, no matter what information they have inside them. So, the program will execute the second arm’s code, <code>continue</code>, which tells the program to go to the next iteration of the <code>loop</code> and ask for another guess. So, effectively, the program ignores all errors that <code>parse</code> might encounter!</p>
<p>Теперь вся программа должна работать нужным образом. Попробуем:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-05/
cargo run
(too small guess)
(too big guess)
foo
(correct guess)
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s
     Running `target/debug/guessing_game`
Угадайте число!
Загаданное число: 61
Введите свою догадку.
10
Вы предположили: 10
Слишком маленькое!
Введите свою догадку.
99
Вы предположили: 99
Слишком большое!
Введите свою догадку.
foo
Введите свою догадку.
61
Вы предположили: 61
Вы победили!
</code></pre>
<p>Замечательно! Нам нужно внести только ещё одну небольшую последнюю правку. Вспомним, что программа всё ещё печатает загаданное число. Это было полезно для тестирования, но для игры это бессмысленно. Удалим строчку с <code>println!</code>, которая печатает загаданное число. В Листинге 2-6 приведён окончательный код программы.</p>
<Listing number="2-6" file-name="src/main.rs" caption="Complete guessing game code">
<pre><code class="language-rust ignore">use std::cmp::Ordering;
use std::io;

use rand::Rng;

fn main() {
    println!("Угадайте число!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    loop {
        println!("Введите свою догадку.");

        let mut guess = String::new();

        io::stdin()
            .read_line(&amp;mut guess)
            .expect("Не удалось прочесть ввод.");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!("Вы предположили: {guess}");

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Слишком маленькое!"),
            Ordering::Greater =&gt; println!("Слишком большое!"),
            Ordering::Equal =&gt; {
                println!("Вы победили!");
                break;
            }
        }
    }
}</code></pre>
</Listing>
<p>Игра готова. Хорошая работа, поздравляем!</p>
<h2 id="Подведём-итоги"><a class="header" href="#Подведём-итоги">Подведём итоги</a></h2>
<p>Этот прикладной проект познакомил вас со многими концепциями Rust: <code>let</code>, <code>match</code>, функциями, использованием внешних крейтов и многим другим. В нескольких следующих главах вы изучите эта концепции подробнее. Глава 3 расскажет об общих понятиях программирования, присущих и Rust, таких как переменные, типы данных и функциях, а также покажет, как их использовать. Глава 4 посвящена системе владения — особенности Rust, сильно выделяющей его среди других языков программирования. В Главе 5 обсуждаются структуры и синтаксис метода, а Глава 6 объясняет работу с перечислениями.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch01-03-hello-cargo.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch03-00-common-programming-concepts.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch01-03-hello-cargo.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch03-00-common-programming-concepts.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
