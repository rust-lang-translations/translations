<!DOCTYPE HTML>
<html lang="ru" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Определение перечисления - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch06-01-defining-an-enum.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch06-01-defining-an-enum.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ru");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Определение-перечисления"><a class="header" href="#Определение-перечисления">Определение перечисления</a></h2>
<p>Там, где структуры дают вам возможность группировать связанные поля и данные (например, <code>Rectangle</code> с его <code>width</code> и <code>height</code>), перечисления дают вам способ сказать, что данное значение является лишь одним из возможных наборов значений. Например, мы можем захотеть сказать, что <code>Rectangle</code> — это одна из множества возможных фигур, в которую также входят <code>Circle</code> и <code>Triangle</code>. Rust позволяет нам записать эту множественность в виде перечисления.</p>
<p>Давайте рассмотрим ситуацию, которую мы могли бы захотеть отразить в коде, и поймём, почему в этом случае перечисления полезны и более уместны, чем структуры. Допустим, нам нужно работать с IP-адресами. В настоящее время для обозначения IP-адресов используются два основных стандарта: четвёртая и шестая версии. Поскольку это единственно возможные варианты IP-адресов, с которыми может столкнуться наша программа, мы можем <em>перечислить</em> все возможные варианты: отсюда и термин "перечисление".</p>
<p>Любой IP-адрес может быть либо четвёртой, либо шестой версии, но не обеими одновременно. Эта особенность IP-адресов делает структуру перечисления полностью нам подходящей, поскольку значение перечисления может представлять собой только один из его возможных вариантов. Адреса как четвёртой, так и шестой версии по своей сути все равно являются IP-адресами, поэтому их следует рассматривать как один и тот же тип, когда в коде обрабатываются задачи, относящиеся к любому типу IP-адресов.</p>
<p>Можно выразить эту концепцию в коде, определив перечисление <code>IpAddrKind</code> и перечислив возможные виды IP-адресов: <code>V4</code> и <code>V6</code>. Вот определение нашего перечисления:</p>
<pre><pre class="playground"><code class="language-rust edition2024">enum IpAddrKind {
    V4,
    V6,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p><code>IpAddrKind</code> теперь является пользовательским типом данных, который мы можем использовать в любом другом месте нашего кода.</p>
<h3 id="Значения-перечислений"><a class="header" href="#Значения-перечислений">Значения перечислений</a></h3>
<p>Экземпляры каждого варианта перечисления <code>IpAddrKind</code> можно создать следующим образом:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
<span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p>Обратите внимание, что варианты перечисления находятся в пространстве имён вместе с его идентификатором, а для их обособления мы используем двойное двоеточие. Это удобно тем, что теперь оба значения <code>IpAddrKind::V4</code> и <code>IpAddrKind::V6</code> относятся к одному типу: <code>IpAddrKind</code>. Затем мы можем, например, определить функцию, которая принимает любой из вариантов <code>IpAddrKind</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span>fn route(ip_kind: IpAddrKind) {}</code></pre></pre>
<p>Можно вызвать эту функцию с любым из вариантов:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span>    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p>Использование перечислений имеет ещё больше преимуществ. Если поразмыслить о нашем типе IP-адреса, то выяснится, что на данный момент у нас нет возможности хранить собственно <em>сам</em> IP-адрес; мы пока можем знать лишь его тип. Учитывая, что недавно (в Главе 5) вы узнали о структурах, у вас может возникнуть соблазн решить эту проблему с помощью структур, как показано в Листинге 6-1.</p>
<Listing number="6-1" caption="Storing the data and `IpAddrKind` variant of an IP address using a `struct`">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    enum IpAddrKind {
        V4,
        V6,
    }

    struct IpAddr {
        kind: IpAddrKind,
        address: String,
    }

    let home = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from("127.0.0.1"),
    };

    let loopback = IpAddr {
        kind: IpAddrKind::V6,
        address: String::from("::1"),
    };
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>Здесь мы определили структуру <code>IpAddr</code>, у которой есть два поля: <code>kind</code> типа <code>IpAddrKind</code> (перечисление, которое мы определили ранее) и <code>address</code> типа <code>String</code>. У нас есть два экземпляра этой структуры. Первый — <code>home</code>, который представляет адрес типа <code>IpAddrKind::V4</code> (в соответствии со своим значением <code>kind</code>) с соответствующим адресом <code>127.0.0.1</code>. Второй экземпляр — <code>loopback</code>. Его <code>kind</code> имеет другой вариант <code>IpAddrKind</code> — <code>V6</code>, и с ним ассоциирован адрес <code>::1</code>. Мы использовали структуру для объединения значений <code>kind</code> и <code>address</code> вместе; таким образом, тип адреса теперь ассоциирован с непосредственно самим адресом.</p>
<p>However, representing the same concept using just an enum is more concise: Rather than an enum inside a struct, we can put data directly into each enum variant. This new definition of the <code>IpAddr</code> enum says that both <code>V4</code> and <code>V6</code> variants will have associated <code>String</code> values:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(String),
        V6(String),
    }

    let home = IpAddr::V4(String::from("127.0.0.1"));

    let loopback = IpAddr::V6(String::from("::1"));
<span class="boring">}</span></code></pre></pre>
<p>We attach data to each variant of the enum directly, so there is no need for an extra struct. Here, it’s also easier to see another detail of how enums work: The name of each enum variant that we define also becomes a function that constructs an instance of the enum. That is, <code>IpAddr::V4()</code> is a function call that takes a <code>String</code> argument and returns an instance of the <code>IpAddr</code> type. We automatically get this constructor function defined as a result of defining the enum.</p>
<p>There’s another advantage to using an enum rather than a struct: Each variant can have different types and amounts of associated data. Version four IP addresses will always have four numeric components that will have values between 0 and 255. If we wanted to store <code>V4</code> addresses as four <code>u8</code> values but still express <code>V6</code> addresses as one <code>String</code> value, we wouldn’t be able to with a struct. Enums handle this case with ease:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from("::1"));
<span class="boring">}</span></code></pre></pre>
<p>We’ve shown several different ways to define data structures to store version four and version six IP addresses. However, as it turns out, wanting to store IP addresses and encode which kind they are is so common that <a href="../std/net/enum.IpAddr.html">the standard library has a definition we can use!</a><!-- ignore --> Let’s look at how the standard library defines <code>IpAddr</code>. It has the exact enum and variants that we’ve defined and used, but it embeds the address data inside the variants in the form of two different structs, which are defined differently for each variant:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ipv4Addr {
    // --код сокращён--
}

struct Ipv6Addr {
    // --код сокращён--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
<span class="boring">}</span></code></pre></pre>
<p>На этом примере видно, что мы можем добавлять любые типы данных в варианты перечисления: строку, число, структуру и так далее. Вы можете включать в перечисление даже другие перечисления! Стандартные типы данных часто не так сложны, как то, что из них можно составить.</p>
<p>Обратите внимание, что хотя определение перечисления <code>IpAddr</code> есть в стандартной библиотеке, мы смогли объявлять и использовать свою собственную реализацию с аналогичным названием без каких-либо конфликтов, потому что мы не добавили определение из стандартной библиотеки в область видимости нашей программы. Подробнее об этом поговорим в Главе 7.</p>
<p>Let’s look at another example of an enum in Listing 6-2: This one has a wide variety of types embedded in its variants.</p>
<Listing number="6-2" caption="A `Message` enum whose variants each store different amounts and types of values">
<pre><pre class="playground"><code class="language-rust edition2024">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p>Это перечисление имеет 4 варианта:</p>
<ul>
<li><code>Quit</code>: Has no data associated with it at all</li>
<li><code>Move</code>: Has named fields, like a struct does</li>
<li><code>Write</code>: Includes a single <code>String</code></li>
<li><code>ChangeColor</code>: Includes three <code>i32</code> values</li>
</ul>
<p>Определение перечисления с вариантами (такими, как в Листинге 6-2) похоже на определение значений разных возможных структур, за исключением того, что перечисление не использует ключевое слово <code>struct</code> и все варианты сгруппированы внутри типа <code>Message</code>. Следующие структуры могут содержать те же данные, что и предыдущие варианты перечислений:</p>
<pre><pre class="playground"><code class="language-rust edition2024">struct QuitMessage; // unit-подобная структура
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // кортежная структура
struct ChangeColorMessage(i32, i32, i32); // кортежная структура
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>Но если мы используем различные структуры, каждая из которых имеет свои собственные типы, мы не можем легко определять функции, которые принимают любые типы сообщений, как это можно сделать с помощью единого перечисления типа <code>Message</code>, объявленного в Листинге 6-2.</p>
<p>There is one more similarity between enums and structs: Just as we’re able to define methods on structs using <code>impl</code>, we’re also able to define methods on enums. Here’s a method named <code>call</code> that we could define on our <code>Message</code> enum:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    enum Message {
</span><span class="boring">        Quit,
</span><span class="boring">        Move { x: i32, y: i32 },
</span><span class="boring">        Write(String),
</span><span class="boring">        ChangeColor(i32, i32, i32),
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Message {
        fn call(&amp;self) {
            // здесь — тело метода
        }
    }

    let m = Message::Write(String::from("hello"));
    m.call();
<span class="boring">}</span></code></pre></pre>
<p>В теле метода будет использоваться <code>self</code> для получения того значения, на котором мы вызвали этот метод. В этом примере мы создали переменную <code>m</code>, содержащую значение <code>Message::Write(String::from("hello"))</code>, и именно это значение будет представлять <code>self</code> в теле метода <code>call</code> при исполнении строчки <code>m.call()</code>.</p>
<p>Теперь посмотрим на перечисление из стандартной библиотеки, которое является очень распространённым и полезным: <code>Option</code>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="the-option-enum-and-its-advantages-over-null-values"></a></p>
<h3 id="the-option-enum"><a class="header" href="#the-option-enum">The <code>Option</code> Enum</a></h3>
<p>This section explores a case study of <code>Option</code>, which is another enum defined by the standard library. The <code>Option</code> type encodes the very common scenario in which a value could be something, or it could be nothing.</p>
<p>Например, если вы запросите первый элемент из непустого списка, вы получите значение. Если вы запросите первый элемент пустого списка, вы получите ничего. Выражение этой концепции в терминах системы типов означает, что компилятор может проверить, обработали ли вы все случаи, которые должны были обработать; эта функциональность может предотвратить ошибки, которые чрезвычайно распространены в других языках программирования.</p>
<p>Дизайн языка программирования часто рассматривается с точки зрения того, какие функции вы включаете в него, но также важно то, какие функции вы в него не включаете. Например, в Rust нет понятия "null", однако оно есть во многих других языках. <em>Null</em> — это значение, которое означает, что значения нет. В языках с null переменные всегда могут находиться в одном из двух состояний: null или не-null.</p>
<p>In his 2009 presentation “Null References: The Billion Dollar Mistake,” Tony Hoare, the inventor of null, had this to say:</p>
<blockquote>
<p>Я называю это своей ошибкой на миллиард долларов. В то время я разрабатывал первую комплексную систему типов для ссылок в объектно-ориентированном языке. Моя цель состояла в том, чтобы гарантировать, что любое использование ссылок будет абсолютно безопасным, с автоматической проверкой компилятором. Но я не смог устоять перед соблазном внедрить в язык пустую ссылку — просто потому, что это было так легко реализовать. Это привело к бесчисленным ошибкам, уязвимостям и системным сбоям, которые, вероятно, причинили боль и ущерб на миллиард долларов за последние сорок лет.</p>
</blockquote>
<p>Проблема с null заключается в том, что если вы попытаетесь использовать null в качестве не-null значения, вы получите ошибку определённого рода. Поскольку эта возможность (быть null или не-null) распространена повсеместно, сделать такую ошибку очень просто.</p>
<p>However, the concept that null is trying to express is still a useful one: A null is a value that is currently invalid or absent for some reason.</p>
<p>Проблема на самом деле не в концепции, а в конкретной реализации. В Rust нет значений null, но есть перечисление, которое может выразить концепцию присутствия или отсутствия значения. Это перечисление <code>Option&lt;T&gt;</code>, и оно <a href="https://doc.rust-lang.org/std/option/enum.Option.html">определено стандартной библиотекой</a><!-- ignore --> следующим образом:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    None,
    Some(T),
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>Option&lt;T&gt;</code> enum is so useful that it’s even included in the prelude; you don’t need to bring it into scope explicitly. Its variants are also included in the prelude: You can use <code>Some</code> and <code>None</code> directly without the <code>Option::</code> prefix. The <code>Option&lt;T&gt;</code> enum is still just a regular enum, and <code>Some(T)</code> and <code>None</code> are still variants of type <code>Option&lt;T&gt;</code>.</p>
<p>Запись <code>&lt;T&gt;</code> — это особенность Rust, о которой мы ещё не говорили. Это параметр обобщённого типа, и мы рассмотрим его более подробно в Главе 10. На данный момент всё, что вам нужно знать, это то, что <code>&lt;T&gt;</code> означает, что вариант <code>Some</code> перечисления <code>Option</code> может содержать один фрагмент данных любого типа, и что каждый конкретный тип, который используется вместо <code>T</code>, делает обобщённый <code>Option&lt;T&gt;</code> определённым типом. Вот несколько примеров использования <code>Option</code> для хранения числового и символьного типов:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let some_number = Some(5);
    let some_char = Some('e');

    let absent_number: Option&lt;i32&gt; = None;
<span class="boring">}</span></code></pre></pre>
<p>The type of <code>some_number</code> is <code>Option&lt;i32&gt;</code>. The type of <code>some_char</code> is <code>Option&lt;char&gt;</code>, which is a different type. Rust can infer these types because we’ve specified a value inside the <code>Some</code> variant. For <code>absent_number</code>, Rust requires us to annotate the overall <code>Option</code> type: The compiler can’t infer the type that the corresponding <code>Some</code> variant will hold by looking only at a <code>None</code> value. Here, we tell Rust that we mean for <code>absent_number</code> to be of type <code>Option&lt;i32&gt;</code>.</p>
<p>When we have a <code>Some</code> value, we know that a value is present, and the value is held within the <code>Some</code>. When we have a <code>None</code> value, in some sense it means the same thing as null: We don’t have a valid value. So, why is having <code>Option&lt;T&gt;</code> any better than having null?</p>
<p>Вкратце, поскольку <code>Option&lt;T&gt;</code> и <code>T</code> (где <code>T</code> может быть любым типом) относятся к разным типам, компилятор не позволит нам использовать значение <code>Option&lt;T&gt;</code> даже если бы оно определённо было допустимым значением. Например, этот код не будет компилироваться, потому что он пытается добавить <code>i8</code> к значению типа <code>Option&lt;i8&gt;</code>:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let x: i8 = 5;
    let y: Option&lt;i8&gt; = Some(5);

    let sum = x + y;
<span class="boring">}</span></code></pre>
<p>Если мы запустим этот код, то получим такое сообщение об ошибке:</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option&lt;i8&gt;` to `i8`
 --&gt; src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option&lt;i8&gt;`
  |
  = help: the trait `Add&lt;Option&lt;i8&gt;&gt;` is not implemented for `i8`
  = help: the following other types implement trait `Add&lt;Rhs&gt;`:
            `&amp;i8` implements `Add&lt;i8&gt;`
            `&amp;i8` implements `Add`
            `i8` implements `Add&lt;&amp;i8&gt;`
            `i8` implements `Add`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums` (bin "enums") due to 1 previous error
</code></pre>
<p>Оно большое! Фактически, это сообщение об ошибке означает, что Rust не понимает, как сложить <code>i8</code> и <code>Option&lt;i8&gt;</code>, потому что это разные типы. Когда у нас есть значение типа вроде <code>i8</code>, компилятор гарантирует, что оно всегда действительно. Мы можем уверенно продолжать работу, не проверяя его на null перед использованием. Лишь когда мы имеем значение типа <code>Option&lt;i8&gt;</code> (или любого другого конкретного типового параметра), у нас есть повод беспокоиться о том, что мы можем и не иметь значения; однако, компилятор обеспечит проверку нами обоих случаев перед тем, как давать использовать (возможное) значение.</p>
<p>Другими словами, вы должны преобразовать <code>Option&lt;T&gt;</code> в <code>T</code>, прежде чем вы сможете исполнять операции с этим <code>T</code>. Как правило, это помогает выявить одну из наиболее распространённых проблем с null: действия с чем-то в предположении, что это что-то не равно null, когда оно на самом деле равно null.</p>
<p>Eliminating the risk of incorrectly assuming a not-null value helps you be more confident in your code. In order to have a value that can possibly be null, you must explicitly opt in by making the type of that value <code>Option&lt;T&gt;</code>. Then, when you use that value, you are required to explicitly handle the case when the value is null. Everywhere that a value has a type that isn’t an <code>Option&lt;T&gt;</code>, you <em>can</em> safely assume that the value isn’t null. This was a deliberate design decision for Rust to limit null’s pervasiveness and increase the safety of Rust code.</p>
<p>Итак, как же получить значение <code>T</code> из варианта <code>Some</code>, если у вас на руках есть только значение <code>Option&lt;T&gt;</code>? Перечисление <code>Option&lt;T&gt;</code> имеет большое количество методов, полезных в различных ситуациях; вы можете ознакомиться с ними в <a href="https://doc.rust-lang.org/std/option/enum.Option.html">его документации</a><!-- ignore -->. Знакомство с методами перечисления <code>Option&lt;T&gt;</code> в вашем путешествии с Rust будет чрезвычайно полезным.</p>
<p>In general, in order to use an <code>Option&lt;T&gt;</code> value, you want to have code that will handle each variant. You want some code that will run only when you have a <code>Some(T)</code> value, and this code is allowed to use the inner <code>T</code>. You want some other code to run only if you have a <code>None</code> value, and that code doesn’t have a <code>T</code> value available. The <code>match</code> expression is a control flow construct that does just this when used with enums: It will run different code depending on which variant of the enum it has, and that code can use the data inside the matching value.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch06-00-enums.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch06-02-match.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch06-00-enums.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch06-02-match.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
