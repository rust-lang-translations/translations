<!DOCTYPE HTML>
<html lang="ru" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Типы данных - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch03-02-data-types.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch03-02-data-types.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ru");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Типы-данных"><a class="header" href="#Типы-данных">Типы данных</a></h2>
<p>Каждое значение в Rust имеет определённый <em>тип данных</em>, сообщающий о том, что это за значение и как с ним работать. Мы посмотрим на две группы типов данных: неделимые и составные.</p>
<p>Не забывайте, что Rust — язык со <em>статической типизацией</em>. Это означает, что типы всех переменных должны быть известны уже на этапе компиляции. Компилятор обычно может самостоятельно вывести тип переменной, основываясь на её значении и том, как она используется. В тех случаях, когда компилятор не может вывести конкретный тип (например, как в том случае, когда мы преобразовывали <code>String</code> к численному типу данных методом <code>parse</code> в разделе <a href="ch02-00-guessing-game-tutorial.html#%D0%A1%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B4%D0%BE%D0%B3%D0%B0%D0%B4%D0%BA%D0%B8-%D1%81-%D0%B7%D0%B0%D0%B3%D0%B0%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D0%BC-%D1%87%D0%B8%D1%81%D0%BB%D0%BE%D0%BC">"Сравнение догадки с загаданным числом"</a><!-- ignore --> Главы 2), мы должны явно аннотировать тип; вот так:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let guess: u32 = "42".parse().expect("Не число!");
<span class="boring">}</span></code></pre></pre>
<p>Если мы не добавим аннотацию типа (<code>: u32</code>) в коде выше, Rust сообщит о соответствующей ошибке, означающей, что компилятору нужно больше информации для автоматического вывода типа:</p>
<pre><code class="language-console">$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0284]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Не число!");
  |         ^^^^^        ----- type must be known at this point
  |
  = note: cannot satisfy `&lt;_ as FromStr&gt;::Err == _`
help: consider giving `guess` an explicit type
  |
2 |     let guess: /* Type */ = "42".parse().expect("Не число!");
  |              ++++++++++++

For more information about this error, try `rustc --explain E0284`.
error: could not compile `no_type_annotations` (bin "no_type_annotations") due to 1 previous error
</code></pre>
<p>Для других типов данных аннотации будут соответственно отличаться.</p>
<h3 id="Неделимые-типы"><a class="header" href="#Неделимые-типы">Неделимые типы</a></h3>
<p><em>Неделимый</em> тип представляет одичночное значение. Rust имеет четыре базовых неделимых типа: целые числа, числа с плавающей точкой, логические значения, а также символы. Они могут вам показаться знакомыми по другим языкам программирования. Посмотрим, как они все работают в Rust.</p>
<h4 id="Целочисленные-типы"><a class="header" href="#Целочисленные-типы">Целочисленные типы</a></h4>
<p><em>Целое</em> число — это число без дробной части. Мы уже использовали один целочисленный тип: в Главе 2 нам понадобился тип <code>u32</code>. Это имя типа указывает на то, что он переменные этого типа представляют беззнаковое целое число (знаковое целое число начиналось бы не с <code>u</code>, а с <code>i</code>), занимающее 32 бита памяти. Таблица 3-1 показывает встроенные целочисленные типы Rust. Мы можем использовать любой из них для объявления переменной, хранящей целое число.</p>
<p><span class="caption">Таблица 3-1: Целочисленные типы в Rust</span></p>
<div class="table-wrapper"><table><thead><tr><th>Длина</th><th>Знаковые</th><th>Беззнаковые</th></tr></thead><tbody>
<tr><td>8-битные</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16-битные</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32-битные</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64-битные</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128-битные</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td>разрядности архитектуры</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
</div>
<p>На каждую длину в битах приходится два варианта: знаковое и беззнаковое целые. Термины <em>знаковое</em> и <em>беззнаковое</em> означают возможность для числа принимать отрицательные значения; другими словами, необходимо ли числу иметь определённый знак (это будут знаковые целые), или же оно однозначно будет положительным и потому может храниться без знака (это будут беззнаковые целые). Представьте, что записываете числа на бумаге: если вам важно знать знак, вы будете тратить место на запись знака "плюс" или "минус"; если же вы знаете, что точно работаете с положительными числами, вы не тратите место на знак. Знаковые целые хранятся в памяти с помощью <a href="https://ru.wikipedia.org/wiki/%D0%94%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4">дополнительного кода</a><!-- ignore -->.</p>
<p>Каждый знаковый тип может хранить значения от −(2<sup>n − 1</sup>) до 2<sup>n − 1</sup> − 1 включительно, где <em>n</em> — количество бит на данное число. Так, тип <code>i8</code> хранит значения от −(2<sup>7</sup>) до 2<sup>7</sup> − 1, что равно пределам от −128 до 127. Беззнаковые типы могут хранить числа от 0 до 2<sup>n</sup> − 1, так что тип <code>u8</code> может хранить значения от 0 до 2<sup>8</sup> − 1, что равно пределам от 0 до 255.</p>
<p>Кроме того, есть типы <code>isize</code> и <code>usize</code>, которые зависят от разрядности архитектуры компьютера, на котором вы запускаете программу; они находятся в конце нашей таблицы. Эти типы будут 64-битными, если вы работаете на машине с 64-битной архитектурой, и будут 32-битными, если вы работаете на машине с 32-битной архитектурой.</p>
<p>Вы можете записывать литералы целых чисел в любом формате из тех, что перечислены в Таблице 3-2. Стоит отметить, что тип литералов, которые могут быть отнесены к разным типам, может быть определён явно с помощью суффикса типа, например: <code>57u8</code>. В числовых литералах можно также использовать знак <code>_</code> как разделитель для удобства чтения: например, запись <code>1_000</code> будет эквивалентна записи <code>1000</code>.</p>
<p><span class="caption">Таблица 3-2: Целочисленные литералы в Rust</span></p>
<div class="table-wrapper"><table><thead><tr><th>Литералы</th><th>Пример</th></tr></thead><tbody>
<tr><td>Десятичный</td><td><code>98_222</code></td></tr>
<tr><td>Шестнадцатеричный</td><td><code>0xff</code></td></tr>
<tr><td>Восьмеричный</td><td><code>0o77</code></td></tr>
<tr><td>Двоичный</td><td><code>0b1111_0000</code></td></tr>
<tr><td>Байт (только тип <code>u8</code>)</td><td><code>b'A'</code></td></tr>
</tbody></table>
</div>
<p>Как понять, какой из целочисленных типов использовать? Если вы сомневаетесь, то прислушайтесь к Rust: выводимый по умолчанию тип <code>i32</code> будет достаточно хорош для многих ситуаций. Основное же применение типов <code>isize</code> и <code>usize</code> — обращение к элементам коллекции по индексу.</p>
<blockquote>
<h5 id="Целочисленное-переполнение"><a class="header" href="#Целочисленное-переполнение">Целочисленное переполнение</a></h5>
<p>Допустим, у вас есть переменная типа <code>u8</code>, которая может принимать значения от 0 до 255. Если вы попытаетесь приписать этой переменной значение за этими пределами (например, 270), произойдёт <em>целочисленное переполнение</em>, которое может привести к двум различным ситуациям. Если вы скомпилировали программу в режиме отладки, Rust включил в неё проверки на целочисленное переполнение, которые вызовут <em>панику</em>, если переполнение произойдёт. В Rust под термином <em>паника</em> понимается завершение программы с ошибкой. Больше о панике мы поговорим в разделе <a href="ch09-01-unrecoverable-errors-with-panic.html">"Неустранимые ошибки с panic!"</a><!-- ignore --> Главы 9.</p>
<p>Когда вы компилируете программу в релизном режиме (используя флаг <code>--release</code>), Rust <em>не</em> включает проверки на целочисленное переполнение и не вызывает паники в его случае. Вместо этого, Rust выполняет <em>обращение по модулю</em>. Кратко говоря, значения, превышающие максимальное значение типа, "оборачиваются" по модулю до числа, которое будет находиться в пределах типа. В случае типа <code>u8</code>, значение 256 станет 0, значение 257 станет 1, и так далее. Программа не вызовет панику, но в переменной будет сохранено не то значение, которое вы, скорее всего, ожидаете. Полагаться на обращение переполнения по модулю считается ошибкой.</p>
<p>Чтобы явно обработать возможность переполнения, вы можете использовать набор методов базовых числовых типов, предоставляемый стандартной библиотекой:</p>
<ul>
<li>Методы <code>wrapping_*</code> (например, <code>wrapping_add</code>) обратят переполнение по модулю — как в релизном режиме, так и в режиме отладки.</li>
<li>Методы <code>checked_*</code> вернут значение <code>None</code>, если произойдёт переполнение.</li>
<li>Методы <code>overflowing_*</code> вернут число и логическое значение, сообщающее о том, произошло ли переполнение.</li>
<li>Методы <code>saturating_*</code> вернут минимальное или максимальное значение типа (в зависимости от того, меньше ли переполнение, чем минимум типа, или переполнение больше, чем максимум).</li>
</ul>
</blockquote>
<h4 id="Типы-чисел-с-плавающей-точкой"><a class="header" href="#Типы-чисел-с-плавающей-точкой">Типы чисел с плавающей точкой</a></h4>
<p>Rust также имеет два базовых типа <em>чисел с плавающей точкой</em> — чисел с десятичной дробной частью. К этим типам относятся типы <code>f32</code> и <code>f64</code>, соответственно занимающие в памяти 32 и 64 бита. По умолчанию используется тип <code>f64</code>, поскольку на новых ЦП он сравним по быстродействию с <code>f32</code>, но при этом даёт большую точность. Все типы чисел с плавающей точкой — знаковые.</p>
<p>Вот пример использования чисел с плавающей точкой:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}</code></pre></pre>
<p>Числа с плавающей точкой реализованы в соответствии со стандартом IEEE-754.</p>
<h4 id="Операции-над-числами"><a class="header" href="#Операции-над-числами">Операции над числами</a></h4>
<p>Rust поддерживает базовые математические операции над числовыми типами: сложение, вычитание, умножение, деление и взятие остатка от деления. Целочисленное деление отбрасывает дробную часть. Код ниже содержит примеры использования операций над числами и инструкции <code>let</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    // сложение
    let sum = 5 + 10;

    // вычитание
    let difference = 95.5 - 4.3;

    // умножение
    let product = 4 * 30;

    // деление
    let quotient = 56.7 / 32.2;
    let truncated = -5 / 3; // будет равно -1

    // остаток от деления
    let remainder = 43 % 5;
}</code></pre></pre>
<p>В каждой строчке используется математический оператор и вычисляется результат, который привязывается к переменной. <a href="appendix-02-operators.html">Приложение B</a><!-- ignore --> содержит список всех операторов в Rust.</p>
<h4 id="Логический-тип"><a class="header" href="#Логический-тип">Логический тип</a></h4>
<p>Как и в других языках программирования, логический тип в Rust представлен двумя возможными значениями: <code>true</code> и <code>false</code>. Логический тип занимает один байт в памяти. Логический тип аннотируется словом <code>bool</code>; например:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let t = true;

    let f: bool = false; // с явной аннотацией типа
}</code></pre></pre>
<p>Основным местом, где используются логические значения, являются условные выражения, вроде выражения <code>if</code>. Мы расскажем о том, как раюотают выражения <code>if</code>, в разделе <a href="ch03-05-control-flow.html#%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BC">"Управление потоком"</a><!-- ignore -->.</p>
<h4 id="Тип-символа"><a class="header" href="#Тип-символа">Тип символа</a></h4>
<p>Тип <code>char</code> — это простейший тип, реализующий символ. Вот несколько примеров объявления значений типа <code>char</code>:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let c = 'z';
    let z: char = 'ℤ'; // с явной аннотацией типа
    let heart_eyed_cat = '😻';
}</code></pre></pre>
<p>Обратите внимание, что мы заключаем литерал <code>char</code> в одиночные кавычки, тогда как строки обрамляются двойными кавычками. Тип <code>char</code> занимает в памяти четыре байта и представляет собой символ Unicode, то есть он может представлять значительно больше символов, чем ASCII. Диакритические знаки, китайские иероглифы, японские кандзи, катакану и хирагану, корейский хангыль, эмодзи, пробелы нулевой ширины — всё это допустимые значения типа <code>char</code> в Rust. Символы Unicode принадлежат промежутку от <code>U+0000</code> до <code>U+D7FF</code> и от <code>U+E000</code> до <code>U+10FFFF</code> включительно. Однако, как такового, понятия "символ" в Unicode нет, так что ваше интуитивное представление о том, что такое "символ", может не соответствовать тому, чем может являться значение типа <code>char</code>. Мы обсудим это подробнее в разделе <a href="ch08-02-strings.html#%D0%A5%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D1%82%D0%B5%D0%BA%D1%81%D1%82%D0%B0-%D0%B2-%D0%BA%D0%BE%D0%B4%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B5-utf-8-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-%D1%81%D1%82%D1%80%D0%BE%D0%BA">"Хранение текста в кодировке UTF-8 с помощью строк"</a><!-- ignore --> Главы 8.</p>
<h3 id="Составные-типы"><a class="header" href="#Составные-типы">Составные типы</a></h3>
<p><em>Составные типы</em> собираются из нескольких других типов. Rust имеет два базовых составных типа: кортежи и массивы.</p>
<h4 id="Тип-кортежа"><a class="header" href="#Тип-кортежа">Тип кортежа</a></h4>
<p><em>Кортеж</em> — это наиболее общий способ группировки нескольких значений разных типов в один составной тип. Длина кортежей постоянна: вы не можете добавить значение в кортеж или убрать что-либо из него.</p>
<p>Кортеж записывается как заключённый в круглые скобки список значений, разделённых запятыми. Каждая элемент кортежа имеет собственный тип, и типы разных элементов могут не совпадать. В примере ниже мы создаём кортеж и (что необязательно) аннотируем переменную, с которой он будет связан:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}</code></pre></pre>
<p>Переменная <code>tup</code> связывается со всем кортежем целиком, поскольку кортеж — это единый составной тип. Чтобы разложить кортеж на его части, мы можем воспользоваться сопоставлением с шаблоном; вот так:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("Значение y: {y}");
}</code></pre></pre>
<p>Эта программа создаёт кортеж и связывает с ним переменную <code>tup</code>. Затем она использует <code>let</code> и применяет шаблон, чтобы извлечь из <code>tup</code> три отдельных переменных: <code>x</code>, <code>y</code> и <code>z</code>. Это называется <em>деструктуризацией</em>, поскольку разбивает единый кортеж на три части. Наконец, программа печатает значение <code>y</code>, то есть <code>6.4</code>.</p>
<p>Мы также можем получить прямой доступ к элементу кортежа, дописав после имени кортежа точку и индекс интересующего нас элемента; например:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}</code></pre></pre>
<p>Эта программа создаёт кортеж <code>x</code> и затем получает каждый его элемент, используя обращение по индексу. Как и в большинстве языков программирования, индексация начинается с нуля.</p>
<p>Кортеж без элементов — особенный, он называется <em>unit</em>. Значение этого типа записывается так же, как и сам тип: <code>()</code>. Unit представляет собой отсутствие значения или отсутствие возвращаемого значения. Выражения неявно возвращают unit, если не возвращают что-либо другое.</p>
<h4 id="Тип-массива"><a class="header" href="#Тип-массива">Тип массива</a></h4>
<p>Другой базовой коллекцией нескольких значений является <em>массив</em>. В противоположность кортежу, все элементы массива должны иметь одинаковый тип. В отличие от некоторых других языков программирования, массивы в Rust имеют постоянную длину.</p>
<p>Массив записывается как заключённый в квадратные скобки список значений, разделённых запятыми:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let a = [1, 2, 3, 4, 5];
}</code></pre></pre>
<p>Массивы нужны тогда, когда вам необходимо разместить некоторые данные на стеке (подобно типам, рассмотренным нами ранее), а не в куче (кучу и стек мы обсудим подробнее в <a href="ch04-01-what-is-ownership.html#%D0%A1%D1%82%D0%B5%D0%BA-%D0%B8-%D0%BA%D1%83%D1%87%D0%B0">Главе 4</a><!-- ignore -->), или когда вам нужно точно быть уверенным, что количество элементов строго постоянно. Более гибким типом, чем массив, является вектор. <em>Вектор</em> — это похожий на массив тип коллекции данных, предоставляемый стандартной библиотекой. Вектор <em>можно</em> сокращать или удлинять. Если вы сомневаетесь, что использовать: массив или вектор, возможно, вам нужен вектор. Векторы будут рассмотрены подробнее в <a href="ch08-01-vectors.html">Главе 8</a><!-- ignore -->.</p>
<p>Однако, массивы будут полезны в том случае, если вы точно знаете, что количество элементов никогда не изменится. Например, если в своей программе вы используете названия месяцев, вам, вероятно, понадобится именно массив, поскольку вы точно знаете, что он всегда будет содержать 12 элементов:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let months = ["Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль",
              "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь"];
<span class="boring">}</span></code></pre></pre>
<p>Тип массива записывается как разделённая точкой с запятой и заключённая в квадратные скобки пара из типа, к которому будет принадлежать каждый элемент, и количества элементов массива. Например:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];
<span class="boring">}</span></code></pre></pre>
<p><code>i32</code> — это тип каждого элемента массива. Стоящая после точки с запятой <code>5</code> означает, что массив содержит пять элементов.</p>
<p>Вы также можете инициализировать массив одинаковых значений. Для этого возьмите запись типа массива и вместо типа всех элементов запишите желаемый литерал; вот так:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [3; 5];
<span class="boring">}</span></code></pre></pre>
<p>Массив под названием <code>a</code> содержит <code>5</code> элементов, каждый из которых будет равен <code>3</code>. Эта запись эквивалентна <code>let a = [3, 3, 3, 3, 3];</code>, но, очевидно, запись выше куда проще и прозрачнее.</p>
<h5 id="Получение-элементов-массива"><a class="header" href="#Получение-элементов-массива">Получение элементов массива</a></h5>
<p>Массив — это единый участок памяти постоянного известного размера, размещаемый на стеке. Вы можете получить доступ к элементам массива, обращаясь к ним по индексу; вот так:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}</code></pre></pre>
<p>В этом примере, переменная <code>first</code> имеет значение <code>1</code>, поскольку это — значение массива по индексу <code>[0]</code>. Переменная <code>second</code> имеет значение <code>2</code>, полученное из массива по индексу <code>[1]</code>.</p>
<h5 id="Обращение-к-элементу-массива-за-его-пределами"><a class="header" href="#Обращение-к-элементу-массива-за-его-пределами">Обращение к элементу массива за его пределами</a></h5>
<p>Давайте посмотрим, что будет, если попытаться получить доступ к элементу, который находится за пределами массива. Допустим, вы пишете вот такой код, похожий на игру в угадайку из Главы 2, и запускаете его. Программа запросит у пользователя индекс для обращения к массиву:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore panics">use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!("Пожалуйста, введите индекс элемента массива.");

    let mut index = String::new();

    io::stdin()
        .read_line(&amp;mut index)
        .expect("Не удалось прочесть ввод.");

    let index: usize = index
        .trim()
        .parse()
        .expect("Введено не число");

    let element = a[index];

    println!("Значение элемента массива по индексу {index}: {element}");
}</code></pre>
<p>Этот код компилируется без проблем. Если вы запустите этот код с помощью <code>cargo run</code> и введёте <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code> или <code>4</code>, программа напечатает вывод с соответствующим индексу элементом массива. Если же вы введёте какое-нибудь выходящее за пределы массива число (например, <code>10</code>), вы увидите вывод вроде такого:</p>
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access
cargo run
10
-->
<pre><code class="language-console">thread 'main' panicked at src/main.rs:19:19:
index out of bounds: the len is 5 but the index is 10
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Программа вызвала ошибку <em>исполнения</em> в строчке, попытавшейся обратиться ко значению по недействительному индексу. Программа завершилась с сообщением об ошибке и не исполнила последнюю инструкцию <code>println!</code>. Когда вы пытаетесь получить доступ к элементу по индексу, Rust будет проверять, меньше ли введённый вами индекс, чем длина массива. Если индекс больше или равен длине массива, Rust вызовет панику. Эта проверка происходит именно во время исполнения программы (особенно в программах, подобных примеру выше), поскольку компилятор не может знать, какое значение введёт пользователь.</p>
<p>Это — наглядный пример принципов обеспечения безопасности памяти в Rust. Во многих низкоуровневых языках подобные проверки не проводятся, а потому обращение к элементам за пределами массива приводит к получению некорректных данных. Rust защищает вас от подобных ошибок, мгновенно останавливая программу вместо того, чтобы дать доступ к памяти и дать вам продолжить с ней работать. Глава 9 подробнее освещает обработку ошибок в Rust и способы написания более читаемого и безопасного кода — такого, который не запаникует и не позволит некорректно обращаться к памяти.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch03-01-variables-and-mutability.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch03-03-how-functions-work.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch03-01-variables-and-mutability.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch03-03-how-functions-work.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
