<!DOCTYPE HTML>
<html lang="ru" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Исправимые ошибки с Result - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch09-02-recoverable-errors-with-result.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch09-02-recoverable-errors-with-result.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ru");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Исправимые-ошибки-с-result"><a class="header" href="#Исправимые-ошибки-с-result">Исправимые ошибки с <code>Result</code></a></h2>
<p>Most errors aren’t serious enough to require the program to stop entirely. Sometimes when a function fails, it’s for a reason that you can easily interpret and respond to. For example, if you try to open a file and that operation fails because the file doesn’t exist, you might want to create the file instead of terminating the process.</p>
<p>Вспомните про перечисление <code>Result</code> и его варианты <code>Ok</code> и <code>Err</code>, которыми мы пользовались в разделе <a href="ch02-00-guessing-game-tutorial.html#%D0%9E%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0-%D0%B2%D0%BE%D0%B7%D0%BC%D0%BE%D0%B6%D0%BD%D1%8B%D1%85-%D0%BE%D1%88%D0%B8%D0%B1%D0%BE%D0%BA-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-result">"Обработка возможных ошибок с помощью <code>Result</code>"</a><!-- ignore --> Главы 2. Его определение выглядит так:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>T</code> and <code>E</code> are generic type parameters: We’ll discuss generics in more detail in Chapter 10. What you need to know right now is that <code>T</code> represents the type of the value that will be returned in a success case within the <code>Ok</code> variant, and <code>E</code> represents the type of the error that will be returned in a failure case within the <code>Err</code> variant. Because <code>Result</code> has these generic type parameters, we can use the <code>Result</code> type and the functions defined on it in many different situations where the success value and error value we want to return may differ.</p>
<p>Let’s call a function that returns a <code>Result</code> value because the function could fail. In Listing 9-3, we try to open a file.</p>
<Listing number="9-3" file-name="src/main.rs" caption="Opening a file">
<pre><pre class="playground"><code class="language-rust edition2024">use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");
}</code></pre></pre>
</Listing>
<p>The return type of <code>File::open</code> is a <code>Result&lt;T, E&gt;</code>. The generic parameter <code>T</code> has been filled in by the implementation of <code>File::open</code> with the type of the success value, <code>std::fs::File</code>, which is a file handle. The type of <code>E</code> used in the error value is <code>std::io::Error</code>. This return type means the call to <code>File::open</code> might succeed and return a file handle that we can read from or write to. The function call also might fail: For example, the file might not exist, or we might not have permission to access the file. The <code>File::open</code> function needs to have a way to tell us whether it succeeded or failed and at the same time give us either the file handle or error information. This information is exactly what the <code>Result</code> enum conveys.</p>
<p>В случае успеха выполнения <code>File::open</code>, значением переменной <code>greeting_file_result</code> будет экземпляр <code>Ok</code>, содержащий дескриптор файла. В случае неудачи, значение в переменной <code>greeting_file_result</code> будет экземпляром <code>Err</code>, содержащим дополнительную информацию о том, какая именно ошибка произошла.</p>
<p>Необходимо дописать в код Листинга 9-3 выполнение разных действий в зависимости от значения, которое вернёт вызов <code>File::open</code>. Листинг 9-4 показывает один из способов обработки <code>Result</code> — использование выражения <code>match</code> (которое было рассмотрено в Главе 6).</p>
<Listing number="9-4" file-name="src/main.rs" caption="Using a `match` expression to handle the `Result` variants that might be returned">
<pre><pre class="playground"><code class="language-rust should_panic edition2024">use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; panic!("При открытии файла произошла ошибка: {error:?}"),
    };
}</code></pre></pre>
</Listing>
<p>Обратите внимание, что как перечисление <code>Option</code>, так и перечисление <code>Result</code> и его варианты подключаются в область видимости по умолчанию, поэтому не нужно указывать <code>Result::</code> перед использованием вариантов <code>Ok</code> и <code>Err</code> в ветках выражения <code>match</code>.</p>
<p>Если результатом будет <code>Ok</code>, этот код вернёт значение <code>file</code> из варианта <code>Ok</code>, а мы затем присвоим переменной <code>greeting_file</code> полученный дескриптор файла. После <code>match</code> мы сможем его для чтения или записи.</p>
<p>Другая ветвь <code>match</code> обрабатывает случай, когда мы получаем значение <code>Err</code> после вызова <code>File::open</code>. В этом примере мы решили вызвать макрос <code>panic!</code>. Если в нашей текущей директории нет файла с именем <em>hello.txt</em>, но мы всё же выполним этот код, то мы увидим следующее сообщение от макроса <code>panic!</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/error-handling`

thread 'main' panicked at src/main.rs:8:23:
Problem opening the file: Os { code: 2, kind: NotFound, message: "No such file or directory" }
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Как обычно, данное сообщение точно говорит, что пошло не так.</p>
<h3 id="Обработка-перечня-ошибок"><a class="header" href="#Обработка-перечня-ошибок">Обработка перечня ошибок</a></h3>
<p>Код в Листинге 9-4 будет вызывать <code>panic!</code> независимо причины неудачи при вызове <code>File::open</code>. Однако мы хотим предпринимать различные действия для разных причин сбоя. Допустим, мы хотим, чтобы если открытие <code>File::open</code> не удалось из-за отсутствия файла, то файл создавался и возвращался его дескриптор. Если же вызов <code>File::open</code> не удался по любой другой причине (например, потому что у нас не было прав на открытие файла), то мы всё так же хотим вызывать <code>panic!</code> как у нас сделано в Листинге 9-4. Для реализации перечисленного мы добавим вложенное выражение <code>match</code>, как показано в Листинге 9-5.</p>
<Listing number="9-5" file-name="src/main.rs" caption="Handling different kinds of errors in different ways">
<!-- ignore this test because otherwise it creates hello.txt which causes other
tests to fail lol -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; match error.kind() {
            ErrorKind::NotFound =&gt; match File::create("hello.txt") {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!("При создании файла произошла ошибка: {e:?}"),
            },
            _ =&gt; {
                panic!("При открытии файла произошла ошибка: {error:?}");
            }
        },
    };
}</code></pre>
</Listing>
<p>The type of the value that <code>File::open</code> returns inside the <code>Err</code> variant is <code>io::Error</code>, which is a struct provided by the standard library. This struct has a method, <code>kind</code>, that we can call to get an <code>io::ErrorKind</code> value. The enum <code>io::ErrorKind</code> is provided by the standard library and has variants representing the different kinds of errors that might result from an <code>io</code> operation. The variant we want to use is <code>ErrorKind::NotFound</code>, which indicates the file we’re trying to open doesn’t exist yet. So, we match on <code>greeting_file_result</code>, but we also have an inner match on <code>error.kind()</code>.</p>
<p>Во вложенном <code>match</code> мы хотим проверить, не является ли значение, возвращаемое функцией <code>error.kind()</code>, вариантом <code>NotFound</code> перечисления <code>ErrorKind</code>. Если оно является, то мы пытаемся создать файл с помощью <code>File::create</code>. Однако, поскольку <code>File::create</code> тоже может завершиться с ошибкой, нам нужна вторая ветвь во вложенном <code>match</code>. Если файл не может быть создан, выводится иное сообщение об ошибке. Вторую ветвь внешнего <code>match</code> мы не меняем. Итого, программа паникует при любой ошибке, кроме ошибки отсутствия файла.</p>
<blockquote>
<h4 id="Альтернативы-использованию-match-с-resultt-e"><a class="header" href="#Альтернативы-использованию-match-с-resultt-e">Альтернативы использованию <code>match</code> с <code>Result&lt;T, E&gt;</code></a></h4>
<p>Как много <code>match</code>! Выражение <code>match</code> является очень полезным, но в то же время довольно примитивным. В Главе 13 вы узнаете о замыканиях, которые используются со многими методами типа <code>Result&lt;T, E&gt;</code>. Эти методы куда лаконичнее, чем прямая обработка значений <code>Result&lt;T, E&gt;</code> через <code>match</code>.</p>
<p>Например, программу из Листинга 9-5 можно вот так переписать с использованием замыканий и метода <code>unwrap_or_else</code>:</p>
<!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("При создании файла произошла ошибка: {error:?}");
            })
        } else {
            panic!("При открытии файла произошла ошибка: {error:?}");
        }
    });
}</code></pre>
<p>Although this code has the same behavior as Listing 9-5, it doesn’t contain any <code>match</code> expressions and is cleaner to read. Come back to this example after you’ve read Chapter 13 and look up the <code>unwrap_or_else</code> method in the standard library documentation. Many more of these methods can clean up huge, nested <code>match</code> expressions when you’re dealing with errors.</p>
</blockquote>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="shortcuts-for-panic-on-error-unwrap-and-expect"></a></p>
<h4 id="shortcuts-for-panic-on-error"><a class="header" href="#shortcuts-for-panic-on-error">Shortcuts for Panic on Error</a></h4>
<p>Использование <code>match</code> работает достаточно хорошо, но оно может быть довольно многословным и не всегда хорошо передавать смысл. Тип <code>Result&lt;T, E&gt;</code> имеет множество вспомогательных методов для выполнения различных, более специфических задач. Метод <code>unwrap</code> — это метод, реализованный так же, как и выражение <code>match</code>, которое мы написали в Листинге 9-4. Если значение <code>Result</code> является вариантом <code>Ok</code>, <code>unwrap</code> возвращает значение внутри <code>Ok</code>. Если значение <code>Result</code> — вариант <code>Err</code>, то <code>unwrap</code> вызовет макрос <code>panic!</code>. Вот пример использования <code>unwrap</code>:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust should_panic edition2024">use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap();
}</code></pre></pre>
</Listing>
<p>Если мы запустим этот код при отсутствии файла <em>hello.txt</em>, то увидим сообщение об ошибке из вызова <code>panic!</code> методом <code>unwrap</code>:</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-04-unwrap
cargo run
copy and paste relevant text
-->
<pre><code class="language-text">thread 'main' panicked at src/main.rs:4:49:
called `Result::unwrap()` on an `Err` value: Os { code: 2, kind: NotFound, message: "No such file or directory" }
</code></pre>
<p>Другой метод, похожий на <code>unwrap</code> — это <code>expect</code>, позволяющий указать собственное сообщение об ошибке для макроса <code>panic!</code>. Использование <code>expect</code> вместо <code>unwrap</code> с предоставлением хорошего сообщения об ошибке выражает ваше намерение и делает более простым отслеживание источника паники. Вот пример использования <code>expect</code>:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust should_panic edition2024">use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")
        .expect("hello.txt должен быть доступен этому проекту");
}</code></pre></pre>
</Listing>
<p>Метод <code>expect</code> используется так же, как <code>unwrap</code>: либо возвращается дескриптор файла, либо вызывается макрос <code>panic!</code>. Наше сообщение об ошибке, переданное <code>expect</code>, будет передано в <code>panic!</code> и заменит стандартное используемое сообщение. Вот как это выглядит:</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-05-expect
cargo run
copy and paste relevant text
-->
<pre><code class="language-text">thread 'main' panicked at src/main.rs:5:10:
hello.txt должен быть доступен этому проекту: Os { code: 2, kind: NotFound, message: "No such file or directory" }
</code></pre>
<p>В реальных программах часто используется <code>expect</code> вместо <code>unwrap</code>, а также добавляется комментарий о том, почему предполагается, что ошибки не произойдёт. Даже если предположение окажется неверным, у вас будет больше информации для отладки.</p>
<h3 id="Проброс-ошибок"><a class="header" href="#Проброс-ошибок">Проброс ошибок</a></h3>
<p>When a function’s implementation calls something that might fail, instead of handling the error within the function itself, you can return the error to the calling code so that it can decide what to do. This is known as <em>propagating</em> the error and gives more control to the calling code, where there might be more information or logic that dictates how the error should be handled than what you have available in the context of your code.</p>
<p>Например, код Листинга 9-6 содержит функцию, читающую имя пользователя из файла. Если файл не существует или не может быть прочтён, то функция возвращает ошибку в код, который вызвал данную функцию.</p>
<Listing number="9-6" file-name="src/main.rs" caption="A function that returns errors to the calling code using `match`">
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let username_file_result = File::open("hello.txt");

    let mut username_file = match username_file_result {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&amp;mut username) {
        Ok(_) =&gt; Ok(username),
        Err(e) =&gt; Err(e),
    }
}
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>Эта функция может быть написана гораздо более коротким способом, но мы начнём с того, что многое сделаем вручную, чтобы дать вам понимание обработки ошибок; в конце покажем более короткий способ. Давайте сначала рассмотрим тип возвращаемого значения: <code>Result&lt;String, io::Error&gt;</code>. То есть, наша функция будет возвращать тип <code>Result&lt;T, E&gt;</code> где параметр обобщённого типа <code>T</code> был заменён конкретным типом <code>String</code>, а <code>E</code> — типом <code>io::Error</code>.</p>
<p>Если эта функция выполнится без проблем, то код, вызывающий эту функцию, получит значение <code>Ok</code>, содержащее <code>String</code> — имя пользователя, прочитанное этой функцией из файла. Если функция столкнётся с какими-либо проблемами, вызывающий код получит значение <code>Err</code>, содержащее экземпляр <code>io::Error</code>, который содержит дополнительную информацию о том, какие проблемы возникли. Мы выбрали <code>io::Error</code> в качестве возвращаемого типа этой функции, поскольку он — тип значения ошибки, возвращаемого из обеих операций, которые мы вызываем в теле этой функции и которые могут завершиться неудачей: функции <code>File::open</code> и метода <code>read_to_string</code>.</p>
<p>The body of the function starts by calling the <code>File::open</code> function. Then, we handle the <code>Result</code> value with a <code>match</code> similar to the <code>match</code> in Listing 9-4. If <code>File::open</code> succeeds, the file handle in the pattern variable <code>file</code> becomes the value in the mutable variable <code>username_file</code> and the function continues. In the <code>Err</code> case, instead of calling <code>panic!</code>, we use the <code>return</code> keyword to return early out of the function entirely and pass the error value from <code>File::open</code>, now in the pattern variable <code>e</code>, back to the calling code as this function’s error value.</p>
<p>So, if we have a file handle in <code>username_file</code>, the function then creates a new <code>String</code> in variable <code>username</code> and calls the <code>read_to_string</code> method on the file handle in <code>username_file</code> to read the contents of the file into <code>username</code>. The <code>read_to_string</code> method also returns a <code>Result</code> because it might fail, even though <code>File::open</code> succeeded. So, we need another <code>match</code> to handle that <code>Result</code>: If <code>read_to_string</code> succeeds, then our function has succeeded, and we return the username from the file that’s now in <code>username</code> wrapped in an <code>Ok</code>. If <code>read_to_string</code> fails, we return the error value in the same way that we returned the error value in the <code>match</code> that handled the return value of <code>File::open</code>. However, we don’t need to explicitly say <code>return</code>, because this is the last expression in the function.</p>
<p>После исполнения функции код, вызывающий ей, будет обрабатывать полученное значение: либо <code>Ok</code>, содержащее имя пользователя, либо различные <code>Err</code>, содержащие ошибки типа <code>io::Error</code>. Вызывающий код должен будет решить, что делать с этими значениями. Если вызывающий код получает значение <code>Err</code>, он может вызвать <code>panic!</code> и завершить работу программы; может использовать имя пользователя по умолчанию; может найти имя пользователя, например, не в файле. У нас нет информации о том, что на самом деле пытается сделать вызывающий код, поэтому мы пробрасываем всю информацию об успехе или ошибках "выше", чтобы она могла обрабатываться соответствующим образом.</p>
<p>Эта схема проброса ошибок столь распространена, что в Rust был добавлен оператор вопросительного знака <code>?</code>, упрощающий проделанную нами работу.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="a-shortcut-for-propagating-errors-the--operator"></a></p>
<h4 id="the--operator-shortcut"><a class="header" href="#the--operator-shortcut">The <code>?</code> Operator Shortcut</a></h4>
<p>В Листинге 9-7 показана реализация <code>read_username_from_file</code>, которая имеет ту же функциональность, что и в Листинге 9-6, но в этой реализации используется оператор <code>?</code>.</p>
<Listing number="9-7" file-name="src/main.rs" caption="A function that returns errors to the calling code using the `?` operator">
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username_file = File::open("hello.txt")?;
    let mut username = String::new();
    username_file.read_to_string(&amp;mut username)?;
    Ok(username)
}
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>The <code>?</code> placed after a <code>Result</code> value is defined to work in almost the same way as the <code>match</code> expressions that we defined to handle the <code>Result</code> values in Listing 9-6. If the value of the <code>Result</code> is an <code>Ok</code>, the value inside the <code>Ok</code> will get returned from this expression, and the program will continue. If the value is an <code>Err</code>, the <code>Err</code> will be returned from the whole function as if we had used the <code>return</code> keyword so that the error value gets propagated to the calling code.</p>
<p>There is a difference between what the <code>match</code> expression from Listing 9-6 does and what the <code>?</code> operator does: Error values that have the <code>?</code> operator called on them go through the <code>from</code> function, defined in the <code>From</code> trait in the standard library, which is used to convert values from one type into another. When the <code>?</code> operator calls the <code>from</code> function, the error type received is converted into the error type defined in the return type of the current function. This is useful when a function returns one error type to represent all the ways a function might fail, even if parts might fail for many different reasons.</p>
<p>Например, мы могли бы изменить функцию <code>read_username_from_file</code> в Листинге 9-7 так, чтобы возвращать пользовательский тип ошибки под именем <code>OurError</code>. Если мы определим <code>impl From&lt;io::Error&gt; for OurError</code> (чтобы получить возможность создавать экземпляры <code>OurError</code> из <code>io::Error</code>), то оператор <code>?</code>, вызываемый в теле <code>read_username_from_file</code>, вызовет <code>from</code> и преобразует типы ошибок без необходимости добавления дополнительного кода в функцию.</p>
<p>Обращаясь к Листингу 9-7 как к примеру, оператор <code>?</code> в конце вызова <code>File::open</code> вернёт значение внутри <code>Ok</code> в переменную <code>username_file</code>. Если произойдёт ошибка, оператор <code>?</code> выполнит преждевременный возврат значения <code>Err</code> вызывающему коду. То же самое относится к оператору <code>?</code> в конце вызова <code>read_to_string</code>.</p>
<p>Оператор <code>?</code> позволил избавиться от большого количества шаблонного кода и упростить реализацию этой функции. Мы могли бы даже ещё больше сократить этот код, если бы использовали цепочку вызовов методов сразу после <code>?</code>, как показано в Листинге 9-8.</p>
<Listing number="9-8" file-name="src/main.rs" caption="Chaining method calls after the `?` operator">
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username = String::new();

    File::open("hello.txt")?.read_to_string(&amp;mut username)?;

    Ok(username)
}
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>Мы перенесли создание новой <code>String</code> в <code>username</code> в начало функции; эта часть не изменилась. Вместо создания переменной <code>username_file</code>, мы вызвали <code>read_to_string</code> непосредственно на результате <code>File::open("hello.txt")?</code>. У нас по-прежнему есть <code>?</code> в конце вызова <code>read_to_string</code>, и мы по-прежнему возвращаем значение <code>Ok</code>, содержащее <code>username</code>, когда и <code>File::open</code> и <code>read_to_string</code> завершаются успешно, а не возвращают ошибки. Функциональность снова такая же, как в Листинге 9-6 и Листинге 9-7; это просто другой, более эргономичный способ её написания.</p>
<p>Листинг 9-9 демонстрирует ещё более короткое определение нашей функции с помощью <code>fs::read_to_string</code>.</p>
<Listing number="9-9" file-name="src/main.rs" caption="Using `fs::read_to_string` instead of opening and then reading the file">
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::io;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    fs::read_to_string("hello.txt")
}
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>Чтение файла в строку — довольно распространённая операция, так что стандартная библиотека предоставляет удобную функцию <code>fs::read_to_string</code>, которая открывает файл, создаёт новую <code>String</code>, читает содержимое файла, размещает его в <code>String</code> и возвращает её. Конечно, использование функции <code>fs::read_to_string</code> не даёт возможности объяснить обработку всех ошибок, поэтому мы сначала изучили длинный способ.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="where-the--operator-can-be-used"></a></p>
<h4 id="where-to-use-the--operator"><a class="header" href="#where-to-use-the--operator">Where to Use the <code>?</code> Operator</a></h4>
<p>Оператор <code>?</code> может использоваться только в функциях, тип возвращаемого значения которых совместим со значением, для которого используется <code>?</code>. Это потому что оператор <code>?</code> определён так, чтобы выполнять преждевременный возврат значения из функции таким же образом, как и выражение <code>match</code>, определённое в Листинге 9-6. В Листинге 9-6 <code>match</code> использовало значение <code>Result</code>, а ветвь с преждевременным возвратом значения вернула значение <code>Err(e)</code>. Тип возвращаемого значения функции должен быть <code>Result</code>, чтобы он был совместим с этим <code>return</code>.</p>
<p>Давайте посмотрим на ошибку, которую мы получим, если воспользуемся оператором <code>?</code> в функции <code>main</code> с типом возвращаемого значения, несовместимым с типом значения, для которого мы используем <code>?</code>. Взгляните на Листинг 9-10:</p>
<Listing number="9-10" file-name="src/main.rs" caption="Attempting to use the `?` in the `main` function that returns `()` won’t compile.">
<pre><code class="language-rust ignore does_not_compile">use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")?;
}</code></pre>
</Listing>
<p>Этот код открывает файл, что может не удасться. Оператор <code>?</code> выводит для себя тип <code>Result</code>, возвращаемый <code>File::open</code>, но функция <code>main</code> возвращает тип <code>()</code>, а не <code>Result</code>. Если мы скомпилируем этот код, мы получим следующее сообщение об ошибке:</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
 --&gt; src/main.rs:4:48
  |
3 | fn main() {
  | --------- this function should return `Result` or `Option` to accept `?`
4 |     let greeting_file = File::open("hello.txt")?;
  |                                                ^ cannot use the `?` operator in a function that returns `()`
  |
help: consider adding return type
  |
3 ~ fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
4 |     let greeting_file = File::open("hello.txt")?;
5 +     Ok(())
  |

For more information about this error, try `rustc --explain E0277`.
error: could not compile `error-handling` (bin "error-handling") due to 1 previous error
</code></pre>
<p>Эта ошибка указывает на то, что оператор <code>?</code> разрешено использовать только в функции, которая возвращает <code>Result</code>, <code>Option</code> или другой тип, реализующий <code>FromResidual</code>.</p>
<p>Для исправления ошибки есть два варианта. Один — изменить возвращаемый тип вашей функции так, чтобы он был совместим со значением, для которого вы используете оператор <code>?</code>, если ничто этому не препятствует. Другой — использовать <code>match</code> или один из методов <code>Result&lt;T, E&gt;</code> для обработки <code>Result&lt;T, E&gt;</code> любым подходящим способом.</p>
<p>The error message also mentioned that <code>?</code> can be used with <code>Option&lt;T&gt;</code> values as well. As with using <code>?</code> on <code>Result</code>, you can only use <code>?</code> on <code>Option</code> in a function that returns an <code>Option</code>. The behavior of the <code>?</code> operator when called on an <code>Option&lt;T&gt;</code> is similar to its behavior when called on a <code>Result&lt;T, E&gt;</code>: If the value is <code>None</code>, the <code>None</code> will be returned early from the function at that point. If the value is <code>Some</code>, the value inside the <code>Some</code> is the resultant value of the expression, and the function continues. Listing 9-11 has an example of a function that finds the last character of the first line in the given text.</p>
<Listing number="9-11" caption="Using the `?` operator on an `Option<T>` value">
<pre><pre class="playground"><code class="language-rust edition2024">fn last_char_of_first_line(text: &amp;str) -&gt; Option&lt;char&gt; {
    text.lines().next()?.chars().last()
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(
</span><span class="boring">        last_char_of_first_line("Привет!\nКак ты?"),
</span><span class="boring">        Some('!')
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    assert_eq!(last_char_of_first_line(""), None);
</span><span class="boring">    assert_eq!(last_char_of_first_line("\nсойдёт"), None);
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>Эта функция возвращает <code>Option&lt;char&gt;</code>, потому что может быть, что строка будет не пустой и символ будет найден, а может быть, что его и не будет. Этот код принимает строковый срез <code>text</code> и вызывает на нём метод <code>lines</code>, который возвращает итератор всех строчек в строке. Поскольку эта функция хочет проверить первую строку, она вызывает <code>next</code> у итератора, чтобы получить первое значение от итератора. Если <code>text</code> является пустой строкой, этот вызов <code>next</code> вернёт <code>None</code>, и в этом случае мы используем <code>?</code> чтобы остановить и вернуть <code>None</code> из <code>last_char_of_first_line</code>. Если <code>text</code> не является пустой строкой, <code>next</code> вернёт значение <code>Some</code>, содержащее строковый срез первой строки в <code>text</code>.</p>
<p>Символ <code>?</code> извлекает строковый срез, и мы можем вызвать на нём метод <code>chars</code>, чтобы получить итератор символов. Нас интересует последний символ в первой строке, поэтому мы вызываем <code>last</code>, чтобы вернуть последний элемент в итераторе. Вернётся <code>Option</code>, потому что возможно, что первая строка пуста: <code>например</code>, если <code>text</code> начинается с пустой строки, но имеет символы в других строках, как в <code>"\nсойдёт"</code>. Однако, если в первой строке есть последний символ, он будет возвращён в варианте <code>Some</code>. Оператор <code>?</code> в середине даёт нам лаконичный способ выразить эту логику, позволяя реализовать функцию в одной строке. Если бы мы не могли использовать оператор <code>?</code> в <code>Option</code>, нам пришлось бы реализовать эту логику, используя больше вызовов методов или выражение <code>match</code>.</p>
<p>Обратите внимание: вы можете использовать оператор <code>?</code> на <code>Result</code> в функции, которая возвращает <code>Result</code>; вы можете использовать оператор <code>?</code> на <code>Option</code> в функции, которая возвращает <code>Option</code>; но вы не можете пытаться использовать один вместо другого. Оператор <code>?</code> не будет автоматически преобразовывать <code>Result</code> в <code>Option</code> или наоборот; в этих случаях вы можете использовать такие методы, как метод <code>ok</code> для <code>Result</code> или метод <code>ok_or</code> для <code>Option</code>, чтобы выполнять преобразование явно.</p>
<p>До сих пор все функции <code>main</code>, которые мы использовали, возвращали <code>()</code>. Функция <code>main</code> — особенная, потому что это точка входа и выхода исполняемых программ, и существуют ограничения на тип возвращаемого значения, необходимые для того, что программы вели себя так, как ожидается.</p>
<p>К счастью, <code>main</code> ещё может возвращать <code>Result&lt;(), E&gt;</code>. В Листинге 9-12 используется код из Листинга 9-10, но мы изменили возвращаемый тип <code>main</code> на <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code> и добавили возвращаемое значение <code>Ok(())</code> в конец. Теперь этот код компилируется.</p>
<Listing number="9-12" file-name="src/main.rs" caption="Changing `main` to return `Result<(), E>` allows the use of the `?` operator on `Result` values.">
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs::File;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let greeting_file = File::open("hello.txt")?;

    Ok(())
}</code></pre>
</Listing>
<p>The <code>Box&lt;dyn Error&gt;</code> type is a trait object, which we’ll talk about in <a href="ch18-02-trait-objects.html#using-trait-objects-to-abstract-over-shared-behavior">“Using Trait Objects to Abstract over Shared Behavior”</a><!-- ignore --> in Chapter 18. For now, you can read <code>Box&lt;dyn Error&gt;</code> to mean “any kind of error.” Using <code>?</code> on a <code>Result</code> value in a <code>main</code> function with the error type <code>Box&lt;dyn Error&gt;</code> is allowed because it allows any <code>Err</code> value to be returned early. Even though the body of this <code>main</code> function will only ever return errors of type <code>std::io::Error</code>, by specifying <code>Box&lt;dyn Error&gt;</code>, this signature will continue to be correct even if more code that returns other errors is added to the body of <code>main</code>.</p>
<p>When a <code>main</code> function returns a <code>Result&lt;(), E&gt;</code>, the executable will exit with a value of <code>0</code> if <code>main</code> returns <code>Ok(())</code> and will exit with a nonzero value if <code>main</code> returns an <code>Err</code> value. Executables written in C return integers when they exit: Programs that exit successfully return the integer <code>0</code>, and programs that error return some integer other than <code>0</code>. Rust also returns integers from executables to be compatible with this convention.</p>
<p>Функция <code>main</code> может возвращать любые типы, реализующие <a href="https://doc.rust-lang.org/std/process/trait.Termination.html">трейт <code>std::process::Termination</code></a><!-- ignore -->, который содержит функцию <code>report</code>, возвращающую <code>ExitCode</code>. Обратитесь к документации стандартной библиотеки за дополнительной информацией о реализации трейта <code>Termination</code> для ваших собственных типов.</p>
<p>Теперь, когда мы обсудили детали вызова <code>panic!</code> и возврата <code>Result</code>, давайте вернёмся к тому, как решить, какой из случаев подходит для какой ситуации.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch09-01-unrecoverable-errors-with-panic.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch09-03-to-panic-or-not-to-panic.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch09-01-unrecoverable-errors-with-panic.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch09-03-to-panic-or-not-to-panic.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
