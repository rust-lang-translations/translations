<!DOCTYPE HTML>
<html lang="ru" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Что такое владение? - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch04-01-what-is-ownership.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch04-01-what-is-ownership.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ru");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Что-такое-владение"><a class="header" href="#Что-такое-владение">Что такое владение?</a></h2>
<p><em>Владение</em> — это набор правил, регулирующих управление памятью в Rust. Всем программам необходимо иметь способ взаимодействовать с памятью, предоставляемой компьютером. Некоторые языки имеют сборщик мусора — он время от времени собирает неиспользуемую память и высвобождает её. В других языках программист должен явно и самостоятельно выделять и освобождать память. Rust нашёл третий путь: память управляется по правилам системы владения, исполнение которых проверяется компилятором. Если какие-либо правила нарушены, программа не скомпилируется. Кстати: поскольку правила владения проверяются именно на этапе компиляции, они не сделают ваш код медленнее.</p>
<p>Поскольку идея владения незнакома большинству программистов, нужно некоторое время, чтобы выработался навык. Хорошая новость: чем больше опыта вы будете приобретать с Rust и правилами системы владения, тем легче вам будет разрабатывать безопасный и эффективный код. Выше нос!</p>
<p>Когда вы поймёте владение, вы получите устойчивый фундамент для понимания особенностей, которые делают Rust уникальным языком. В этой главе вы изучите владение, поработав над несколькими примерами с использованием одной из самых распространённых структур данных — строк.</p>
<blockquote>
<h3 id="Стек-и-куча"><a class="header" href="#Стек-и-куча">Стек и куча</a></h3>
<p>Многие языки программирования не требуют от вас задумываться о стеке или куче. Но в системных языках программирования (вроде Rust), важно знать разницу между размещением данных на стеке или на куче, знать о том как ведёт себя при этом язык и какие последствия повлечёт ваш выбор. Частично, владение будет рассмотрено в отношении стека, а под конец главы мы коснёмся и кучи; а пока, для подготовки, кратко расскажем о стеке и куче.</p>
<p>И стек, и куча — это участки памяти, доступные вашей программе для использования, однако устроены они по-разному. Стек хранит значения в порядке их добавления и удаляет их в обратном. Это называется принципом <em>"первым вошёл — последним вышел"</em>. Думайте о стеке как о стопке тарелок: если вы добавляете больше тарелок, вы ставите их наверх; когда вам нужно взять тарелку, вы берёте её сверху. Добавить или убрать тарелку снизу или из середины не выйдет! Помещение данных в стек называется <em>push</em>, а извлечение — <em>pop</em>. Всё, что хранится на стеке, должно иметь постоянный и известный размер. Если же для ваших данных нельзя узнать длину до компиляции, или если их размер может поменяться, следует воспользоваться кучей.</p>
<p>Куча менее организована: когда вы помещаете данные в кучу, вы получаете немного места в ней и туда размещаете свои данные. Распределитель памяти (синоним: "аллокатор") ищет в памяти свободное место достаточного размера, помечает его как задействованное вашей программой, и возвращает вам <em>указатель</em> на этот участок памяти. Этот процесс называется <em>аллокацией памяти в куче</em> или просто <em>аллокацией</em> (примечание: размещение данных в стеке не считается аллокацией). Поскольку указатель на кучу имеет известный и постоянный размер, вы можете хранить его на стеке; но если вам потребуются непосредственно данные, вам нужно будет обратиться по указателю. Думайте об этом как о порядке рассадки в ресторане: когда вы входите, вы сообщаете о том, сколько человек в вашей группе, и официант ищет для вас столик подходящего размера; если же кто-то из вашей группы опаздывает, вы сообщаете ему, где вас разместили.</p>
<p>Размещение на стеке быстрее, чем аллокация в куче, поскольку при размещении на стеке распределителю памяти не приходится искать свободное место достаточного размера: таковое всегда находится на вершине стека. Соответственно, резмещение в куче требует куда больше работы, поскольку распределитель памяти должен сначала найти достаточно большой и неиспользуемый участок в памяти, а потом подготовиться к следующему запросу на выделение памяти.</p>
<p>Доступ к данным в куче медленнее, чем к данным на стеке, поскольку вам нужно сначала отыскать нужный участок памяти по указателю. Современные процессоры работают быстрее, если не нагружать их частыми обращениями к памяти. Продолжая аналогию с ресторанами: подумайте о приёме официантом заказов посетителей. Эффективнее всего будет взять все заказы с одного столика перед тем, как идти к следующему. Если же пытаться взять заказ у столика A, потом у столика B, потом снова у A, а потом ещё раз у B... Это будет значительно медленнее. Точно так же процессору легче и быстрее выполнить свою работу, если необходимые данные будут лежать рядом (как на стеке), а не разрозненно по всей памяти (как в куче).</p>
<p>Когда ваш код вызывает функцию, значения, переданные функции (включая, например, указатели на данные в куче), и локальные переменные функции размещаются на стеке. Когда функция завершается, значения извлекаются из стека и их память освобождается.</p>
<p>Управление тем, какие участки программы какую используют память в куче; минимизация копирования данных в куче; очистка неиспользуемых данных — это всё работа механизма владения. Как только вы поймёте владение, вам  не понадобится самому особенно часто думать о стеке и куче, но знание о том, что основная задача владения — это управление стеком и кучей, поможет вам понять, почему владение устроено именно так.</p>
</blockquote>
<h3 id="Правила-владения"><a class="header" href="#Правила-владения">Правила владения</a></h3>
<p>Для начала, давайте посмотрим на правила владения. Держите их в голове по мере того, как мы будем показывать иллюстрирующие их примеры:</p>
<ul>
<li>Каждое значение в Rust имеет <em>владельца</em>.</li>
<li>В один момент у значения может быть только один владелец.</li>
<li>Когда владелец покидает свою область видимости, значение высвобождается.</li>
</ul>
<h3 id="Область-видимости-переменной"><a class="header" href="#Область-видимости-переменной">Область видимости переменной</a></h3>
<p>Теперь, поскольку мы освоились с базовым синтаксисом Rust, мы не будем постоянно включать код примеров в <code>fn main() {</code>, так что если вы захотите повторить примеры, не забудьте поместить их в функцию <code>main</code>. Мы опускаем явное упоминание функции <code>main</code>, чтобы сосредоточиться на деталях, на нюансах кода, а не на уже заученных шаблонах.</p>
<p>В качестве первого примера владения, мы изучим границы <em>области видимости</em> некоторых переменных. Область видимости — это участок программы, в котором данные ещё действительны. Вот пример переменной:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = "hello";
<span class="boring">}</span></code></pre></pre>
<p>Переменная <code>s</code> связана с литералом строки, записанным непосредственно в коде нашей программы. Переменная действительна с тех пор, как она объявлена, и до конца её <em>области видимости</em>. Листинг 4-1 содержит программу с комментариями о действительности переменной в разные моменты.</p>
<Listing number="4-1" caption="A variable and the scope in which it is valid">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    {                      // s пока не действительна, так как не объявлена
        let s = "hello";   // отсюда и далее s действительна

        // здесь можно использовать s
    }                      // область видимости закончилась, s больше не действительна
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>В общем, здесь есть два важных момента:</p>
<ul>
<li>Когда <code>s</code> <em>оказывается</em> в области видимости, она действительна.</li>
<li>Она остаётся действительной, пока не <em>покинет</em> область видимости.</li>
</ul>
<p>Пока что отношения между областями видимости и действительностью переменных в целом такие же, как и в других языках программирования. Теперь, на этом фундаменте, мы рассмотрим тип <code>String</code>.</p>
<h3 id="Тип-string"><a class="header" href="#Тип-string">Тип <code>String</code></a></h3>
<p>Чтобы проиллюстрировать правила владения, нам нужен тип данных более сложный, чем те, что мы рассмотрели в разделе <a href="ch03-02-data-types.html#%D0%A2%D0%B8%D0%BF%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85">"Типы данных"</a><!-- ignore --> Главы 3. Там мы рассматривали такие типы, которые имеют фиксированный размер; хранятся на стеке и высвобождаются с концом их области видимости; могут быть быстро и просто скопированы, чтобы получить отдельно живущую копию данных, которую можно затем использовать в другой области видимости. Но на этот раз нам нужны данные, которые придётся хранить в куче — чтобы узнать, как Rust выясняет момент для высвобождения этих данных. Тип <code>String</code> нам отлично подойдёт.</p>
<p>Мы сконцентрируемся на тех частях String, которые связаны с владением. Эти аспекты также применимы к другим сложным типам данных, независимо от того, предоставлены они стандартной библиотекой или созданы вами. Более подробно мы обсудим <code>String</code> в <a href="ch08-02-strings.html">Главе 8</a><!-- ignore -->.</p>
<p>Мы уже видели строковые литералы, где строковое значение явно вписано в нашу программу. Строковые литералы удобны, но они подходят не для каждой ситуации, где мы можем хотеть использовать текст. Одна из причин заключается в том, что они неизменяемы. Кроме того, не всегда строковое значение может быть известно уже во время написания кода: что, если мы захотим принять и сохранить пользовательский ввод? Для таких ситуаций в Rust есть ещё один строковый тип — <code>String</code>. Этот тип управляет данными, выделенными в куче, и поэтому может хранить объём текста, который во время компиляции неизвестен. Вы можете создать <code>String</code> из строкового литерала, используя функцию <code>from</code>; вот так:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");
<span class="boring">}</span></code></pre></pre>
<p>Оператор "двойное двоеточие" (<code>::</code>) позволяет обращаться к данной функции <code>from</code> как к функции над типом <code>String</code>. Он позволяет отказаться от различных специфичных самостоятельных имён, вроде <code>string_from</code>. Мы обсудим этот синтаксис более подробно в разделе <a href="ch05-03-method-syntax.html#%D0%A1%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%81-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B0">"Синтаксис метода"</a><!-- ignore --> Главы 5, а также в ходе обсуждения пространств имён и модулей в разделе <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">"Пути для ссылки на элемент в дереве модулей"</a><!-- ignore --> Главы 7.</p>
<p>Подобного рода строки <em>могут</em> быть изменены</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    s.push_str(", world!"); // push_str() приписывает литерал к String

    println!("{s}"); // Будет напечатано `hello, world!`
<span class="boring">}</span></code></pre></pre>
<p>В чем же разница? Почему строку <code>String</code> можно изменить, а литералы — нельзя? Разница заключается в том, как эти два типа работают с памятью.</p>
<h3 id="Память-и-её-выделение"><a class="header" href="#Память-и-её-выделение">Память и её выделение</a></h3>
<p>В случае литерала строки, мы знаем его содержимое во время компиляции, так что оно будет явно прописано в итоговом исполняемом файле. Причина того, что строковые литералы более быстрые и эффективные, состоит в невозможности их изменять. К сожалению, в исполняемом файле нельзя определить кусок памяти переменного и неизвестного при компиляции размера, который к тому же может ещё и меняться во время исполнения программы.</p>
<p>Чтобы сделать возможным изменяемый, наращиваемый текст типа <code>String</code>, необходимо выделять память в куче для всего его содержимого, объём которого неизвестен во время компиляции. Это означает, что:</p>
<ul>
<li>Память должна запрашиваться у распределителя памяти во время исполнения программы.</li>
<li>Необходим способ вернуть эту память распределителю, когда мы закончили работу с нашей <code>String</code>.</li>
</ul>
<p>Первое выполняется нами: когда мы вызываем <code>String::from</code>, его реализация запрашивает необходимую память. Такое довольно знакомо многим языкам программирования.</p>
<p>Однако второй пункт куда интереснее. В языках со <em>сборщиком мусора (GC)</em> память, которая больше не используется, им отслеживается и очищается — нам не нужно об этом думать. В большинстве языков без сборщика мусора мы обязаны сами определять, когда память больше не используется, и вызывать код, явно её освобождающий: точно так же, как мы делали это для её выделения. Правильные ручные запросы на выделение и высвобождение памяти всегда были сложной проблемой программирования. Если мы забудем освободить память, она будет потеряна и без проку забьёт собой место. Если же мы сделаем это слишком рано, у нас будет недействительная переменная. Сделать это дважды — тоже выйдут проблемы. Нам нужно ровно единожды высвободить память, которую мы единожды выделили.</p>
<p>Rust пошёл по своему: память автоматически возвращается системе, как только владеющая памятью переменная выходит из области видимости. Вот версия примера с областью видимости из Листинга 4-1, в котором используется тип <code>String</code> вместо строкового литерала:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    {
        let s = String::from("hello"); // отсюда и далее s действительна

        // здесь можно использовать s
    }                                  // область видимости закончилась,
                                       // и s больше не действительна
<span class="boring">}</span></code></pre></pre>
<p>Существует естественный момент, когда мы можем вернуть память, необходимую нашей <code>String</code>, обратно распределителю — когда <code>s</code> выходит за пределы области видимости. Когда переменная выходит за пределы области видимости, Rust вызывает для нас специальную функцию. Эта функция называется <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop"><code>drop</code></a><!-- ignore -->, и именно в ней создатель типа <code>String</code> может разместить код для возврата памяти. Rust автоматически вызывает <code>drop</code> после закрывающей фигурной скобки.</p>
<blockquote>
<p>Примечание: В C++ этот шаблон освобождения ресурсов в конце времени жизни данных иногда называется <em>"Получение ресурса есть инициализация"</em> (Resource Acquisition Is Initialization — RAII). Функция <code>drop</code> в Rust покажется вам знакомой, если вы использовали шаблоны RAII.</p>
</blockquote>
<p>Этот шаблон оказывает глубокое влияние на способ написания кода в Rust. Сейчас это всё может казаться простым, но в более сложных случаях поведение кода может оказаться неожиданным: например, когда хочется иметь несколько переменных, использующих данные, выделенные в куче. Изучим несколько таких ситуаций.</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="ways-variables-and-data-interact-move"></a></p>
<h4 id="Взаимодействие-переменных-и-данных-с-помощью-перемещения"><a class="header" href="#Взаимодействие-переменных-и-данных-с-помощью-перемещения">Взаимодействие переменных и данных с помощью перемещения</a></h4>
<p>В Rust, несколько переменных могут по-разному взаимодействовать с одними и теми же данными. Давайте рассмотрим один пример с использованием целое число:</p>
<Listing number="4-2" caption="Assigning the integer value of variable `x` to `y`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>Мы можем догадаться, что делает этот код: "привяжи значение <code>5</code> к <code>x</code>; затем сделай копию значения в <code>x</code> и привяжи его к <code>y</code>". Теперь у нас есть две переменные: <code>x</code> и <code>y</code>, и обе равны <code>5</code>. Именно так всё и происходит, потому что целые числа — это простые значения с известным фиксированным размером, так что эти два значения <code>5</code> помещаются в стек.</p>
<p>Теперь посмотрим на версию с типом <code>String</code></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");
    let s2 = s1;
<span class="boring">}</span></code></pre></pre>
<p>Всё выглядит очень похожим, поэтому мы можем предположить, что происходит то же самое: вторая строка сделает копию значения <code>s1</code> и привяжет его к <code>s2</code>. Но это не совсем так.</p>
<p>Взгляните на Рисунок 4-1, чтобы понять, что со <code>String</code> происходит под капотом. <code>String</code> состоит из трёх частей (показаны слева): указатель на память, в которой хранится содержимое строки; длина; ёмкость. Эта группа данных хранится на стеке. Справа — память в куче, которая содержит сам текст.</p>
<p><img alt="Две таблицы: первая содержит представление s1в
стеке, содержащее её длину (5), ёмкость (5) и указатель на первое
значение во второй таблице. Вторая таблица содержит представление содержимого
строки в куче, байт за байтом." src="img/trpl04-01.svg" class="center"
style="width: 50%;" /></p>
<p><span class="caption">Рисунок 4-1: Представление в памяти значения типа <code>String</code>, содержащее значение <code>"hello"</code> и связанное с <code>s1</code></span></p>
<p>Длина — это объём памяти в байтах, который в настоящее время использует содержимое <code>String</code>. Ёмкость — это общий объём памяти в байтах, который <code>String</code> получил от распределителя. Разница между длиной и ёмкостью имеет значение, но не в этом контексте, поэтому на данный момент можно игнорировать ёмкость.</p>
<p>Когда мы присваиваем <code>s1</code> значению <code>s2</code>, данные <code>String</code> копируются: под этим имеется в виду, что мы копируем указатель, длину и ёмкость, которые находятся в стеке. Мы не копируем данные в куче, на которые указывает указатель. Иными словами, вид данных в памяти выглядит так, как показано на Рисунке 4-2.</p>
<p><img alt="Три таблицы: таблицы s1 и s2 предсталяют эти строки на
стеке, соответственно, и обе указывают на один и тот же текст в куче."
src="img/trpl04-02.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Рисунок 4-2: Вид памяти переменной <code>s2</code>, имеющей копию указателя, длины и ёмкости <code>s1</code></span></p>
<p>Вид памяти <em>не</em> будет похож на Рисунок 4-3: так выглядела бы память, если бы вместо этого Rust также копировал данные кучи. Если бы Rust делал это, операция <code>s2 = s1</code> могла бы быть очень дорогой с точки зрения производительности исполнения, если бы копируемые данные в куче были большими.</p>
<p><img alt="Четыре таблицы: две таблицы представляют данные s1 и s2 на стеке,
и каждая указывает на собственную копию текста в куче."
src="img/trpl04-03.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Рисунок 4-3: Другой вариант того, что могла бы делать операция<code>s2 = s1</code>, если бы Rust также копировал данные кучи</span></p>
<p>Ранее мы сказали, что когда переменная выходит за пределы области видимости, Rust автоматически вызывает функцию <code>drop</code> и очищает память данной переменной, выделенную в куче. Но на Рисунке 4-2 оба указателя данных указывают на одно и то же место. Это проблема: когда переменные <code>s2</code> и <code>s1</code> будут выходить из области видимости, они обе будут пытаться освободить одну и ту же память. Это известно как ошибка <em>двойного освобождения</em> —  она является одной из ошибок безопасности памяти, упоминаемых ранее. Повторное свобождение памяти может привести к повреждению памяти, что потенциально может привести к уязвимостям.</p>
<p>Чтобы обеспечить безопасность памяти, после строки <code>let s2 = s1;</code> Rust считает <code>s1</code> более не инициализированной. Следовательно, Rust не нужно ничего освобождать, когда <code>s1</code> выходит из области видимости. Посмотрите, что произойдёт, если вы попытаетесь использовать <code>s1</code> после создания <code>s2</code>:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");
    let s2 = s1;

    println!("{s1}, world!");
<span class="boring">}</span></code></pre>
<p>Вы получите ошибку как ту, что ниже, поскольку Rust не позволит вам использовать недействительную ссылку:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --&gt; src/main.rs:5:15
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |
5 |     println!("{s1}, world!");
  |               ^^^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider cloning the value if the performance cost is acceptable
  |
3 |     let s2 = s1.clone();
  |                ++++++++

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>Если вы слышали про термины <em>поверхностное копирование</em> и <em>глубокое копирование</em>, если работали с другими языками, концепция копирования указателя, длины и ёмкости без копирования данных, вероятно, звучит как создание поверхностной копии. Но поскольку Rust также деинициализирует первую переменную, это называется не поверхностным копированием, а <em>перемещением</em>. В примере выше мы бы сказали, что <code>s1</code> была перемещён в <code>s2</code>. В конечном счёте, истинная картина происходящего показана на Рисунке 4-4.</p>
<p><img alt="Три таблицы: таблицы s1 и s2 представляют эти строки на
стеке, соответственно, и обе указывают на один и тот же текст в куче.
Таблица s1 серая, по-скольку s1 больше не действительна; лишь s2 может быть использована для
обращения к данным в куче." src="img/trpl04-04.svg" class="center" style="width:
50%;" /></p>
<p><span class="caption">Рисунок 4-4: Вид памяти после того, как <code>s1</code> была деинициализирована</span></p>
<p>Это решает нашу проблему! Действительной остаётся только переменная <code>s2</code>. Когда она покинет область видимости, то лишь она одна будет освобождать память в куче.</p>
<p>Этот порядок работы с памятью даёт ещё одно преимущество: Rust никогда не будет автоматически создавать "глубокие" копии ваших данных. Следовательно, любое автоматическое копирование, связанное и перемещением, можно считать недорогим с точки зрения производительности.</p>
<h4 id="Область-видимости-и-присвоение"><a class="header" href="#Область-видимости-и-присвоение">Область видимости и присвоение</a></h4>
<p>The inverse of this is true for the relationship between scoping, ownership, and memory being freed via the <code>drop</code> function as well. When you assign a completely new value to an existing variable, Rust will call <code>drop</code> and free the original value’s memory immediately. Consider this code, for example:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");
    s = String::from("ahoy");

    println!("{s}, world!");
<span class="boring">}</span></code></pre></pre>
<p>Сначала мы объявляем переменную <code>s</code> и связываем её со значением <code>"hello"</code> типа <code>String</code>. Затем мы немедленно создаем новую строку типа <code>String</code> со значением <code>"ahoy"</code> и присваиваем её переменной <code>s</code>. После этого ничто больше не ссылается на изначальные данные в куче.</p>
<p><img alt="Одна таблица, s, представляет данные строки на стеке, указывающие на
вторую часть данных строки (“ahoy”) в куче, вместе с изначальным текстом
строки (“hello”) выкрашенными в серый, поскольку он больше никому не доступен."
src="img/trpl04-05.svg"
class="center"
style="width: 50%;"
/></p>
<p><span class="caption">Рисунок 4-5: Вид памяти после того, как начальное значение было полностью заменено, вытеснено новым.</span></p>
<p>Оригинальная строка, в связи с этим, в этот же момент покинула область видимости. Rust вызовет на ней функцию <code>drop</code> и высвободит её память. Когда исполнение дойдёт до строчки печати, будет выведено <code>"ahoy, world!"</code>.</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="ways-variables-and-data-interact-clone"></a></p>
<h4 id="Взаимодействие-переменных-и-данных-с-помощью-клонирования"><a class="header" href="#Взаимодействие-переменных-и-данных-с-помощью-клонирования">Взаимодействие переменных и данных с помощью клонирования</a></h4>
<p>Если мы всё же <em>хотим</em> глубоко скопировать данные <code>String</code> в куче, а не только стека, мы можем использовать часто реализуемый метод, называемый <code>clone</code>. Мы обсудим синтаксис метода в Главе 5, но поскольку методы являются общей чертой многих языков программирования, вы, вероятно, уже знакомы с ними.</p>
<p>Вот пример работы метода <code>clone</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {s1}, s2 = {s2}");
<span class="boring">}</span></code></pre></pre>
<p>Это отлично работает и, очевидно, приводит к поведению, показанному на Рисунке 4-3, где данные кучи <em>были</em> скопированы.</p>
<p>Если вы видите вызов <code>clone</code>, вы сразу можете понять, что исполняемый здесь некоторый код наверняка будет затратным. В то же время, использование <code>clone</code> является маркером того, что тут происходит что-то необычное.</p>
<h4 id="Данные-размещающиеся-только-на-стеке-всегда-копируются"><a class="header" href="#Данные-размещающиеся-только-на-стеке-всегда-копируются">Данные, размещающиеся только на стеке, всегда копируются</a></h4>
<p>Это ещё одна особенность, о которой мы ранее не говорили. Этот код, часть которого мы ранее показали в Листинге 4-2, полностью корректен:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;

    println!("x = {x}, y = {y}");
<span class="boring">}</span></code></pre></pre>
<p>Но в то же время этот код, кажется, противоречит тому, что мы только что узнали: мы не вызываем <code>clone</code>, но <code>x</code> остаётся действительна и её значение не перемещается в <code>y</code>.</p>
<p>Причина в том, что такие типы, как целые числа, размер которых известен во время компиляции, полностью хранятся на стеке, поэтому копии фактических значений создаются быстро. Это означает, что нет причин, по которым мы хотели бы предотвратить доступность <code>x</code> после того, как создадим переменную <code>y</code>. Иными словами, для таких типов нет разницы между глубоким и поверхностным копированием, поэтому вызов <code>clone</code> ничем не отличается от обычного поверхностного копирования, и мы можем его опустить.</p>
<p>В Rust есть специальная аннотация, называемая трейтом <code>Copy</code>, которую мы можем приписывать типам, хранящимся на стеке: как это сделано для целых чисел (подробнее о трейтах мы поговорим в <a href="ch10-02-traits.html">Главе 10</a><!-- ignore -->). Если тип реализует трейт <code>Copy</code>, переменные, к нему принадлежащие, не перемещаются при присваивании, а просто копируются, что оставляет их действительными после присвоения другой переменной.</p>
<p>Rust не позволит нам аннотировать тип с помощью <code>Copy</code>, если тип или любая из его частей реализует трейт <code>Drop</code>. Если для типа нужно, чтобы произошло что-то особенное, когда значение выходит за пределы области видимости, и мы добавляем аннотацию <code>Copy</code> к этому типу, мы получим ошибку компиляции. Чтобы узнать, как добавить аннотацию <code>Copy</code> к вашему типу для реализации трейта, посмотрите раздел <a href="appendix-03-derivable-traits.html">"Производные трейты"</a><!-- ignore --> в Приложении C.</p>
<p>Какие же типы реализуют трейт Copy? Чтобы удостовериться, можно проверить документацию интересующего типа, но как правило любая группа простых отдельных значений может быть реализовывать <code>Copy</code>, и никакие типы, которые требуют выделения памяти в куче или являются некоторой формой ресурсов, не реализуют трейта <code>Copy</code>. Вот некоторые типы, которые реализуют <code>Copy</code>:</p>
<ul>
<li>Все целочисленные типы, такие как <code>u32</code>.</li>
<li>Логический тип данных <code>bool</code>, возможные значения которого — <code>true</code> и <code>false</code>.</li>
<li>Все типы чисел с плавающей точкой, такие как <code>f64</code>.</li>
<li>Символьный тип <code>char</code>.</li>
<li>Кортежи; но только если они состоят только из типов, которые также реализуют <code>Copy</code>. Например, <code>(i32, i32)</code> реализует <code>Copy</code>, но кортеж <code>(i32, String)</code> — нет.</li>
</ul>
<h3 id="Владение-и-функции"><a class="header" href="#Владение-и-функции">Владение и функции</a></h3>
<p>Механизм передачи функции значения схож с тем, что происходит при присвоении переменной значения. Передача переменной в функцию приведёт к перемещению или копированию ровно так же, как при присваивании. В Листинге 4-3 есть пример с некоторыми комментариями, поясняющими, где переменные входят в область видимости и где выходят из неё.</p>
<Listing number="4-3" file-name="src/main.rs" caption="Functions with ownership and scope annotated">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let s = String::from("hello");  // s входит в область видимости

    takes_ownership(s);             // значение s перемещается в функцию...
                                    // ... а потому оно здесь больше не доступно

    let x = 5;                      // x входит в область видимости

    makes_copy(x);                  // поскольку i32 реализует трейт Copy,
                                    // x НЕ переместится в функцию,
    println!("{}", x);              // так что далее всё ещё можно использовать x

} // Здесь x покидает область видимости, вслед за ней — и s. Но поскольку значение s ранее было перемещено, ничего
  // критического не происходит.

fn takes_ownership(some_string: String) { // some_string входит в область видимости
    println!("{some_string}");
} // Здесь some_string покидает область видимости и вызывается `drop`. Выделенная ей
  // память высвобождается.

fn makes_copy(some_integer: i32) { // some_integer входит в область видимости
    println!("{some_integer}");
} "// Здесь some_integer покидает область видимости. Ничего критического не происходит.</code></pre></pre>
</Listing>
<p>Если попытаться использовать <code>s</code> после вызова <code>takes_ownership</code>, Rust выбросит ошибку компиляции. Такие статические проверки защищают нас от опечаток. Попробуйте в <code>main</code> добавить код, который использует переменные <code>s</code> и <code>x</code>, чтобы увидеть, где их разрешено использовать и где правила владения предотвращают их использование.</p>
<h3 id="Возвращение-значений-и-область-видимости"><a class="header" href="#Возвращение-значений-и-область-видимости">Возвращение значений и область видимости</a></h3>
<p>Возвращение значений также может сопровождаться передачей владения. В Листинге 4-4 показан пример функции, возвращающей некоторое значение, с подобными же комментариями, как в Листинге 4-3.</p>
<Listing number="4-4" file-name="src/main.rs" caption="Transferring ownership of return values">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let s1 = gives_ownership();        // gives_ownership перемещает своё возвращаемое значение
                                       // в s1

    let s2 = String::from("hello");    // s2 входит в область видимости

    let s3 = takes_and_gives_back(s2); // s2 перемещается в
                                       // takes_and_gives_back, которая также
                                       // перемещает в s3 своё возвращаемое значение
} // Здесь s3 покидает область видимости и её память высвобождается. s2 перемещена: ничего
  // не происходит. s1 покидает область видимости и её память высвобождается.

fn gives_ownership() -&gt; String {       // gives_ownership перемещает своё
                                       // возвращаемое значение в то,
                                       // что вызвало её

    let some_string = String::from("твоё"); // some_string входит в область видимости

    some_string                        // some_string возвращается из функции и 
                                       // перемещается в то, что вызвало
                                       // функцию
}

Эта функция принимает String и возвращает String.fn takes_and_gives_back(a_string: String) -&gt; String {
    // a_string входит в область
    // видимости

    a_string  // a_string возвращается из функции перемещается в то, что вызвало функцию
}</code></pre></pre>
</Listing>
<p>Владение переменной каждый раз следует одному и тому же шаблону: присваивание значения другой переменной перемещает это значение в новую переменную. Когда переменная, содержащая данные в куче, выходит из области видимости, содержимое в куче будет очищено функцией <code>drop</code>, если только данные не были перемещены во владение другой переменной.</p>
<p>Хотя всё исправно работает, получать владение, а затем возвращать его из каждой функцией довольно утомительно. Что, если мы хотим, чтобы функция использовала значение, но не становилась владельцем? Очень раздражает, что всё, что мы передаём, также должно быть передано обратно, если мы хотим использовать это снова (помимо любых вычисленных в теле функции данных, которые мы также можем хотеть вернуть).</p>
<p>Rust позволяет нам возвращать из функции несколько значений, используя кортеж, как показано в Листинге 4-5.</p>
<Listing number="4-5" file-name="src/main.rs" caption="Returning ownership of parameters">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("Длина '{s2}' равна {len}.");
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len() возвращает длину String

    (s, length)
}</code></pre></pre>
</Listing>
<p>Но это слишком многословно и излишне для методики, которая претендует на универсальность и всеприменимость. К счастью, в Rust есть способ использовать значение без передачи владения — <em>ссылки</em>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch04-00-understanding-ownership.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch04-02-references-and-borrowing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch04-00-understanding-ownership.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch04-02-references-and-borrowing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
