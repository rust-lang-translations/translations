<!DOCTYPE HTML>
<html lang="ru" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Что такое владение? - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch04-01-what-is-ownership.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch04-01-what-is-ownership.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ru");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Что-такое-владение"><a class="header" href="#Что-такое-владение">Что такое владение?</a></h2>
<p><em>Ownership</em> is a set of rules that govern how a Rust program manages memory. All programs have to manage the way they use a computer’s memory while running. Some languages have garbage collection that regularly looks for no-longer-used memory as the program runs; in other languages, the programmer must explicitly allocate and free the memory. Rust uses a third approach: Memory is managed through a system of ownership with a set of rules that the compiler checks. If any of the rules are violated, the program won’t compile. None of the features of ownership will slow down your program while it’s running.</p>
<p>Поскольку идея владения незнакома большинству программистов, нужно некоторое время, чтобы выработался навык. Хорошая новость: чем больше опыта вы будете приобретать с Rust и правилами системы владения, тем легче вам будет разрабатывать безопасный и эффективный код. Выше нос!</p>
<p>Когда вы поймёте владение, вы получите устойчивый фундамент для понимания особенностей, которые делают Rust уникальным языком. В этой главе вы изучите владение, поработав над несколькими примерами с использованием одной из самых распространённых структур данных — строк.</p>
<blockquote>
<h3 id="Стек-и-куча"><a class="header" href="#Стек-и-куча">Стек и куча</a></h3>
<p>Многие языки программирования не требуют от вас задумываться о стеке или куче. Но в системных языках программирования (вроде Rust), важно знать разницу между размещением данных на стеке или на куче, знать о том как ведёт себя при этом язык и какие последствия повлечёт ваш выбор. Частично, владение будет рассмотрено в отношении стека, а под конец главы мы коснёмся и кучи; а пока, для подготовки, кратко расскажем о стеке и куче.</p>
<p>Both the stack and the heap are parts of memory available to your code to use at runtime, but they are structured in different ways. The stack stores values in the order it gets them and removes the values in the opposite order. This is referred to as <em>last in, first out (LIFO)</em>. Think of a stack of plates: When you add more plates, you put them on top of the pile, and when you need a plate, you take one off the top. Adding or removing plates from the middle or bottom wouldn’t work as well! Adding data is called <em>pushing onto the stack</em>, and removing data is called <em>popping off the stack</em>. All data stored on the stack must have a known, fixed size. Data with an unknown size at compile time or a size that might change must be stored on the heap instead.</p>
<p>The heap is less organized: When you put data on the heap, you request a certain amount of space. The memory allocator finds an empty spot in the heap that is big enough, marks it as being in use, and returns a <em>pointer</em>, which is the address of that location. This process is called <em>allocating on the heap</em> and is sometimes abbreviated as just <em>allocating</em> (pushing values onto the stack is not considered allocating). Because the pointer to the heap is a known, fixed size, you can store the pointer on the stack, but when you want the actual data, you must follow the pointer. Think of being seated at a restaurant. When you enter, you state the number of people in your group, and the host finds an empty table that fits everyone and leads you there. If someone in your group comes late, they can ask where you’ve been seated to find you.</p>
<p>Размещение на стеке быстрее, чем аллокация в куче, поскольку при размещении на стеке распределителю памяти не приходится искать свободное место достаточного размера: таковое всегда находится на вершине стека. Соответственно, резмещение в куче требует куда больше работы, поскольку распределитель памяти должен сначала найти достаточно большой и неиспользуемый участок в памяти, а потом подготовиться к следующему запросу на выделение памяти.</p>
<p>Accessing data in the heap is generally slower than accessing data on the stack because you have to follow a pointer to get there. Contemporary processors are faster if they jump around less in memory. Continuing the analogy, consider a server at a restaurant taking orders from many tables. It’s most efficient to get all the orders at one table before moving on to the next table. Taking an order from table A, then an order from table B, then one from A again, and then one from B again would be a much slower process. By the same token, a processor can usually do its job better if it works on data that’s close to other data (as it is on the stack) rather than farther away (as it can be on the heap).</p>
<p>Когда ваш код вызывает функцию, значения, переданные функции (включая, например, указатели на данные в куче), и локальные переменные функции размещаются на стеке. Когда функция завершается, значения извлекаются из стека и их память освобождается.</p>
<p>Keeping track of what parts of code are using what data on the heap, minimizing the amount of duplicate data on the heap, and cleaning up unused data on the heap so that you don’t run out of space are all problems that ownership addresses. Once you understand ownership, you won’t need to think about the stack and the heap very often. But knowing that the main purpose of ownership is to manage heap data can help explain why it works the way it does.</p>
</blockquote>
<h3 id="Правила-владения"><a class="header" href="#Правила-владения">Правила владения</a></h3>
<p>Для начала, давайте посмотрим на правила владения. Держите их в голове по мере того, как мы будем показывать иллюстрирующие их примеры:</p>
<ul>
<li>Каждое значение в Rust имеет <em>владельца</em>.</li>
<li>В один момент у значения может быть только один владелец.</li>
<li>Когда владелец покидает свою область видимости, значение высвобождается.</li>
</ul>
<h3 id="Область-видимости-переменной"><a class="header" href="#Область-видимости-переменной">Область видимости переменной</a></h3>
<p>Now that we’re past basic Rust syntax, we won’t include all the <code>fn main() {</code> code in the examples, so if you’re following along, make sure to put the following examples inside a <code>main</code> function manually. As a result, our examples will be a bit more concise, letting us focus on the actual details rather than boilerplate code.</p>
<p>As a first example of ownership, we’ll look at the scope of some variables. A <em>scope</em> is the range within a program for which an item is valid. Take the following variable:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = "hello";
<span class="boring">}</span></code></pre></pre>
<p>The variable <code>s</code> refers to a string literal, where the value of the string is hardcoded into the text of our program. The variable is valid from the point at which it’s declared until the end of the current scope. Listing 4-1 shows a program with comments annotating where the variable <code>s</code> would be valid.</p>
<Listing number="4-1" caption="A variable and the scope in which it is valid">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    {                      // s is not valid here, since it's not yet declared
        let s = "hello";   // отсюда и далее s действительна

        // здесь можно использовать s
    }                      // область видимости закончилась, s больше не действительна
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>В общем, здесь есть два важных момента:</p>
<ul>
<li>Когда <code>s</code> <em>оказывается</em> в области видимости, она действительна.</li>
<li>Она остаётся действительной, пока не <em>покинет</em> область видимости.</li>
</ul>
<p>Пока что отношения между областями видимости и действительностью переменных в целом такие же, как и в других языках программирования. Теперь, на этом фундаменте, мы рассмотрим тип <code>String</code>.</p>
<h3 id="Тип-string"><a class="header" href="#Тип-string">Тип <code>String</code></a></h3>
<p>Чтобы проиллюстрировать правила владения, нам нужен тип данных более сложный, чем те, что мы рассмотрели в разделе <a href="ch03-02-data-types.html#%D0%A2%D0%B8%D0%BF%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85">"Типы данных"</a><!-- ignore --> Главы 3. Там мы рассматривали такие типы, которые имеют фиксированный размер; хранятся на стеке и высвобождаются с концом их области видимости; могут быть быстро и просто скопированы, чтобы получить отдельно живущую копию данных, которую можно затем использовать в другой области видимости. Но на этот раз нам нужны данные, которые придётся хранить в куче — чтобы узнать, как Rust выясняет момент для высвобождения этих данных. Тип <code>String</code> нам отлично подойдёт.</p>
<p>We’ll concentrate on the parts of <code>String</code> that relate to ownership. These aspects also apply to other complex data types, whether they are provided by the standard library or created by you. We’ll discuss non-ownership aspects of <code>String</code> in <a href="ch08-02-strings.html">Chapter 8</a><!-- ignore -->.</p>
<p>We’ve already seen string literals, where a string value is hardcoded into our program. String literals are convenient, but they aren’t suitable for every situation in which we may want to use text. One reason is that they’re immutable. Another is that not every string value can be known when we write our code: For example, what if we want to take user input and store it? It is for these situations that Rust has the <code>String</code> type. This type manages data allocated on the heap and as such is able to store an amount of text that is unknown to us at compile time. You can create a <code>String</code> from a string literal using the <code>from</code> function, like so:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");
<span class="boring">}</span></code></pre></pre>
<p>The double colon <code>::</code> operator allows us to namespace this particular <code>from</code> function under the <code>String</code> type rather than using some sort of name like <code>string_from</code>. We’ll discuss this syntax more in the <a href="ch05-03-method-syntax.html#methods">“Methods”</a><!--
ignore --> section of Chapter 5, and when we talk about namespacing with modules in <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“Paths for Referring to an Item in the Module Tree”</a><!-- ignore --> in Chapter 7.</p>
<p>Подобного рода строки <em>могут</em> быть изменены</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    s.push_str(", world!"); // push_str() приписывает литерал к String

    println!("{s}"); // this will print `hello, world!`
<span class="boring">}</span></code></pre></pre>
<p>В чем же разница? Почему строку <code>String</code> можно изменить, а литералы — нельзя? Разница заключается в том, как эти два типа работают с памятью.</p>
<h3 id="Память-и-её-выделение"><a class="header" href="#Память-и-её-выделение">Память и её выделение</a></h3>
<p>В случае литерала строки, мы знаем его содержимое во время компиляции, так что оно будет явно прописано в итоговом исполняемом файле. Причина того, что строковые литералы более быстрые и эффективные, состоит в невозможности их изменять. К сожалению, в исполняемом файле нельзя определить кусок памяти переменного и неизвестного при компиляции размера, который к тому же может ещё и меняться во время исполнения программы.</p>
<p>Чтобы сделать возможным изменяемый, наращиваемый текст типа <code>String</code>, необходимо выделять память в куче для всего его содержимого, объём которого неизвестен во время компиляции. Это означает, что:</p>
<ul>
<li>Память должна запрашиваться у распределителя памяти во время исполнения программы.</li>
<li>Необходим способ вернуть эту память распределителю, когда мы закончили работу с нашей <code>String</code>.</li>
</ul>
<p>That first part is done by us: When we call <code>String::from</code>, its implementation requests the memory it needs. This is pretty much universal in programming languages.</p>
<p>Однако второй пункт куда интереснее. В языках со <em>сборщиком мусора (GC)</em> память, которая больше не используется, им отслеживается и очищается — нам не нужно об этом думать. В большинстве языков без сборщика мусора мы обязаны сами определять, когда память больше не используется, и вызывать код, явно её освобождающий: точно так же, как мы делали это для её выделения. Правильные ручные запросы на выделение и высвобождение памяти всегда были сложной проблемой программирования. Если мы забудем освободить память, она будет потеряна и без проку забьёт собой место. Если же мы сделаем это слишком рано, у нас будет недействительная переменная. Сделать это дважды — тоже выйдут проблемы. Нам нужно ровно единожды высвободить память, которую мы единожды выделили.</p>
<p>Rust takes a different path: The memory is automatically returned once the variable that owns it goes out of scope. Here’s a version of our scope example from Listing 4-1 using a <code>String</code> instead of a string literal:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    {
        let s = String::from("hello"); // отсюда и далее s действительна

        // здесь можно использовать s
    }                                  // область видимости закончилась,
                                       // и s больше не действительна
<span class="boring">}</span></code></pre></pre>
<p>Существует естественный момент, когда мы можем вернуть память, необходимую нашей <code>String</code>, обратно распределителю — когда <code>s</code> выходит за пределы области видимости. Когда переменная выходит за пределы области видимости, Rust вызывает для нас специальную функцию. Эта функция называется <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop"><code>drop</code></a><!-- ignore -->, и именно в ней создатель типа <code>String</code> может разместить код для возврата памяти. Rust автоматически вызывает <code>drop</code> после закрывающей фигурной скобки.</p>
<blockquote>
<p>Примечание: В C++ этот шаблон освобождения ресурсов в конце времени жизни данных иногда называется <em>"Получение ресурса есть инициализация"</em> (Resource Acquisition Is Initialization — RAII). Функция <code>drop</code> в Rust покажется вам знакомой, если вы использовали шаблоны RAII.</p>
</blockquote>
<p>Этот шаблон оказывает глубокое влияние на способ написания кода в Rust. Сейчас это всё может казаться простым, но в более сложных случаях поведение кода может оказаться неожиданным: например, когда хочется иметь несколько переменных, использующих данные, выделенные в куче. Изучим несколько таких ситуаций.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="ways-variables-and-data-interact-move"></a></p>
<h4 id="Взаимодействие-переменных-и-данных-с-помощью-перемещения"><a class="header" href="#Взаимодействие-переменных-и-данных-с-помощью-перемещения">Взаимодействие переменных и данных с помощью перемещения</a></h4>
<p>Multiple variables can interact with the same data in different ways in Rust. Listing 4-2 shows an example using an integer.</p>
<Listing number="4-2" caption="Assigning the integer value of variable `x` to `y`">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>We can probably guess what this is doing: “Bind the value <code>5</code> to <code>x</code>; then, make a copy of the value in <code>x</code> and bind it to <code>y</code>.” We now have two variables, <code>x</code> and <code>y</code>, and both equal <code>5</code>. This is indeed what is happening, because integers are simple values with a known, fixed size, and these two <code>5</code> values are pushed onto the stack.</p>
<p>Теперь посмотрим на версию с типом <code>String</code></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");
    let s2 = s1;
<span class="boring">}</span></code></pre></pre>
<p>This looks very similar, so we might assume that the way it works would be the same: That is, the second line would make a copy of the value in <code>s1</code> and bind it to <code>s2</code>. But this isn’t quite what happens.</p>
<p>Взгляните на Рисунок 4-1, чтобы понять, что со <code>String</code> происходит под капотом. <code>String</code> состоит из трёх частей (показаны слева): указатель на память, в которой хранится содержимое строки; длина; ёмкость. Эта группа данных хранится на стеке. Справа — память в куче, которая содержит сам текст.</p>
<p><img alt="Две таблицы: первая содержит представление s1в
стеке, содержащее её длину (5), ёмкость (5) и указатель на первое
значение во второй таблице. Вторая таблица содержит представление содержимого
строки в куче, байт за байтом." src="img/trpl04-01.svg" class="center"
style="width: 50%;" /></p>
<p><span class="caption">Figure 4-1: The representation in memory of a <code>String</code> holding the value <code>"hello"</code> bound to <code>s1</code></span></p>
<p>Длина — это объём памяти в байтах, который в настоящее время использует содержимое <code>String</code>. Ёмкость — это общий объём памяти в байтах, который <code>String</code> получил от распределителя. Разница между длиной и ёмкостью имеет значение, но не в этом контексте, поэтому на данный момент можно игнорировать ёмкость.</p>
<p>Когда мы присваиваем <code>s1</code> значению <code>s2</code>, данные <code>String</code> копируются: под этим имеется в виду, что мы копируем указатель, длину и ёмкость, которые находятся в стеке. Мы не копируем данные в куче, на которые указывает указатель. Иными словами, вид данных в памяти выглядит так, как показано на Рисунке 4-2.</p>
<p><img alt="Три таблицы: таблицы s1 и s2 предсталяют эти строки на
стеке, соответственно, и обе указывают на один и тот же текст в куче."
src="img/trpl04-02.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figure 4-2: The representation in memory of the variable <code>s2</code> that has a copy of the pointer, length, and capacity of <code>s1</code></span></p>
<p>Вид памяти <em>не</em> будет похож на Рисунок 4-3: так выглядела бы память, если бы вместо этого Rust также копировал данные кучи. Если бы Rust делал это, операция <code>s2 = s1</code> могла бы быть очень дорогой с точки зрения производительности исполнения, если бы копируемые данные в куче были большими.</p>
<p><img alt="Четыре таблицы: две таблицы представляют данные s1 и s2 на стеке,
и каждая указывает на собственную копию текста в куче."
src="img/trpl04-03.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Рисунок 4-3: Другой вариант того, что могла бы делать операция<code>s2 = s1</code>, если бы Rust также копировал данные кучи</span></p>
<p>Earlier, we said that when a variable goes out of scope, Rust automatically calls the <code>drop</code> function and cleans up the heap memory for that variable. But Figure 4-2 shows both data pointers pointing to the same location. This is a problem: When <code>s2</code> and <code>s1</code> go out of scope, they will both try to free the same memory. This is known as a <em>double free</em> error and is one of the memory safety bugs we mentioned previously. Freeing memory twice can lead to memory corruption, which can potentially lead to security vulnerabilities.</p>
<p>Чтобы обеспечить безопасность памяти, после строки <code>let s2 = s1;</code> Rust считает <code>s1</code> более не инициализированной. Следовательно, Rust не нужно ничего освобождать, когда <code>s1</code> выходит из области видимости. Посмотрите, что произойдёт, если вы попытаетесь использовать <code>s1</code> после создания <code>s2</code>:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");
    let s2 = s1;

    println!("{s1}, world!");
<span class="boring">}</span></code></pre>
<p>Вы получите ошибку как ту, что ниже, поскольку Rust не позволит вам использовать недействительную ссылку:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --&gt; src/main.rs:5:16
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |
5 |     println!("{s1}, world!");
  |                ^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider cloning the value if the performance cost is acceptable
  |
3 |     let s2 = s1.clone();
  |                ++++++++

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>Если вы слышали про термины <em>поверхностное копирование</em> и <em>глубокое копирование</em>, если работали с другими языками, концепция копирования указателя, длины и ёмкости без копирования данных, вероятно, звучит как создание поверхностной копии. Но поскольку Rust также деинициализирует первую переменную, это называется не поверхностным копированием, а <em>перемещением</em>. В примере выше мы бы сказали, что <code>s1</code> была перемещён в <code>s2</code>. В конечном счёте, истинная картина происходящего показана на Рисунке 4-4.</p>
<p><img alt="Three tables: tables s1 and s2 representing those strings on the
stack, respectively, and both pointing to the same string data on the heap.
Table s1 is grayed out because s1 is no longer valid; only s2 can be used to
access the heap data." src="img/trpl04-04.svg" class="center" style="width:
50%;" /></p>
<p><span class="caption">Figure 4-4: The representation in memory after <code>s1</code> has been invalidated</span></p>
<p>Это решает нашу проблему! Действительной остаётся только переменная <code>s2</code>. Когда она покинет область видимости, то лишь она одна будет освобождать память в куче.</p>
<p>Этот порядок работы с памятью даёт ещё одно преимущество: Rust никогда не будет автоматически создавать "глубокие" копии ваших данных. Следовательно, любое автоматическое копирование, связанное и перемещением, можно считать недорогим с точки зрения производительности.</p>
<h4 id="Область-видимости-и-присвоение"><a class="header" href="#Область-видимости-и-присвоение">Область видимости и присвоение</a></h4>
<p>The inverse of this is true for the relationship between scoping, ownership, and memory being freed via the <code>drop</code> function as well. When you assign a completely new value to an existing variable, Rust will call <code>drop</code> and free the original value’s memory immediately. Consider this code, for example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");
    s = String::from("ahoy");

    println!("{s}, world!");
<span class="boring">}</span></code></pre></pre>
<p>We initially declare a variable <code>s</code> and bind it to a <code>String</code> with the value <code>"hello"</code>. Then, we immediately create a new <code>String</code> with the value <code>"ahoy"</code> and assign it to <code>s</code>. At this point, nothing is referring to the original value on the heap at all. Figure 4-5 illustrates the stack and heap data now:</p>
<p><img alt="One table representing the string value on the stack, pointing to
the second piece of string data (ahoy) on the heap, with the original string
data (hello) grayed out because it cannot be accessed anymore."
src="img/trpl04-05.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figure 4-5: The representation in memory after the initial value has been replaced in its entirety</span></p>
<p>Оригинальная строка, в связи с этим, в этот же момент покинула область видимости. Rust вызовет на ней функцию <code>drop</code> и высвободит её память. Когда исполнение дойдёт до строчки печати, будет выведено <code>"ahoy, world!"</code>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="ways-variables-and-data-interact-clone"></a></p>
<h4 id="Взаимодействие-переменных-и-данных-с-помощью-клонирования"><a class="header" href="#Взаимодействие-переменных-и-данных-с-помощью-клонирования">Взаимодействие переменных и данных с помощью клонирования</a></h4>
<p>Если мы всё же <em>хотим</em> глубоко скопировать данные <code>String</code> в куче, а не только стека, мы можем использовать часто реализуемый метод, называемый <code>clone</code>. Мы обсудим синтаксис метода в Главе 5, но поскольку методы являются общей чертой многих языков программирования, вы, вероятно, уже знакомы с ними.</p>
<p>Вот пример работы метода <code>clone</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {s1}, s2 = {s2}");
<span class="boring">}</span></code></pre></pre>
<p>Это отлично работает и, очевидно, приводит к поведению, показанному на Рисунке 4-3, где данные кучи <em>были</em> скопированы.</p>
<p>Если вы видите вызов <code>clone</code>, вы сразу можете понять, что исполняемый здесь некоторый код наверняка будет затратным. В то же время, использование <code>clone</code> является маркером того, что тут происходит что-то необычное.</p>
<h4 id="Данные-размещающиеся-только-на-стеке-всегда-копируются"><a class="header" href="#Данные-размещающиеся-только-на-стеке-всегда-копируются">Данные, размещающиеся только на стеке, всегда копируются</a></h4>
<p>Это ещё одна особенность, о которой мы ранее не говорили. Этот код, часть которого мы ранее показали в Листинге 4-2, полностью корректен:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;

    println!("x = {x}, y = {y}");
<span class="boring">}</span></code></pre></pre>
<p>But this code seems to contradict what we just learned: We don’t have a call to <code>clone</code>, but <code>x</code> is still valid and wasn’t moved into <code>y</code>.</p>
<p>Причина в том, что такие типы, как целые числа, размер которых известен во время компиляции, полностью хранятся на стеке, поэтому копии фактических значений создаются быстро. Это означает, что нет причин, по которым мы хотели бы предотвратить доступность <code>x</code> после того, как создадим переменную <code>y</code>. Иными словами, для таких типов нет разницы между глубоким и поверхностным копированием, поэтому вызов <code>clone</code> ничем не отличается от обычного поверхностного копирования, и мы можем его опустить.</p>
<p>В Rust есть специальная аннотация, называемая трейтом <code>Copy</code>, которую мы можем приписывать типам, хранящимся на стеке: как это сделано для целых чисел (подробнее о трейтах мы поговорим в <a href="ch10-02-traits.html">Главе 10</a><!-- ignore -->). Если тип реализует трейт <code>Copy</code>, переменные, к нему принадлежащие, не перемещаются при присваивании, а просто копируются, что оставляет их действительными после присвоения другой переменной.</p>
<p>Rust не позволит нам аннотировать тип с помощью <code>Copy</code>, если тип или любая из его частей реализует трейт <code>Drop</code>. Если для типа нужно, чтобы произошло что-то особенное, когда значение выходит за пределы области видимости, и мы добавляем аннотацию <code>Copy</code> к этому типу, мы получим ошибку компиляции. Чтобы узнать, как добавить аннотацию <code>Copy</code> к вашему типу для реализации трейта, посмотрите раздел <a href="appendix-03-derivable-traits.html">"Выводимые трейты"</a><!-- ignore --> в Приложении C.</p>
<p>Какие же типы реализуют трейт Copy? Чтобы удостовериться, можно проверить документацию интересующего типа, но как правило любая группа простых отдельных значений может быть реализовывать <code>Copy</code>, и никакие типы, которые требуют выделения памяти в куче или являются некоторой формой ресурсов, не реализуют трейта <code>Copy</code>. Вот некоторые типы, которые реализуют <code>Copy</code>:</p>
<ul>
<li>Все целочисленные типы, такие как <code>u32</code>.</li>
<li>Логический тип данных <code>bool</code>, возможные значения которого — <code>true</code> и <code>false</code>.</li>
<li>Все типы чисел с плавающей точкой, такие как <code>f64</code>.</li>
<li>Символьный тип <code>char</code>.</li>
<li>Кортежи; но только если они состоят только из типов, которые также реализуют <code>Copy</code>. Например, <code>(i32, i32)</code> реализует <code>Copy</code>, но кортеж <code>(i32, String)</code> — нет.</li>
</ul>
<h3 id="Владение-и-функции"><a class="header" href="#Владение-и-функции">Владение и функции</a></h3>
<p>Механизм передачи функции значения схож с тем, что происходит при присвоении переменной значения. Передача переменной в функцию приведёт к перемещению или копированию ровно так же, как при присваивании. В Листинге 4-3 есть пример с некоторыми комментариями, поясняющими, где переменные входят в область видимости и где выходят из неё.</p>
<Listing number="4-3" file-name="src/main.rs" caption="Functions with ownership and scope annotated">
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let s = String::from("hello");  // s входит в область видимости

    takes_ownership(s);             // значение s перемещается в функцию...
                                    // ... а потому оно здесь больше не доступно

    let x = 5;                      // x входит в область видимости

    makes_copy(x);                  // Because i32 implements the Copy trait,
                                    // x does NOT move into the function,
                                    // so it's okay to use x afterward.

} // Here, x goes out of scope, then s. However, because s's value was moved,
  // nothing special happens.

fn takes_ownership(some_string: String) { // some_string входит в область видимости
    println!("{some_string}");
} // Здесь some_string покидает область видимости и вызывается `drop`. Выделенная ей
  // память высвобождается.

fn makes_copy(some_integer: i32) { // some_integer входит в область видимости
    println!("{some_integer}");
} "// Здесь some_integer покидает область видимости. Ничего критического не происходит.</code></pre></pre>
</Listing>
<p>Если попытаться использовать <code>s</code> после вызова <code>takes_ownership</code>, Rust выбросит ошибку компиляции. Такие статические проверки защищают нас от опечаток. Попробуйте в <code>main</code> добавить код, который использует переменные <code>s</code> и <code>x</code>, чтобы увидеть, где их разрешено использовать и где правила владения предотвращают их использование.</p>
<h3 id="Возвращение-значений-и-область-видимости"><a class="header" href="#Возвращение-значений-и-область-видимости">Возвращение значений и область видимости</a></h3>
<p>Возвращение значений также может сопровождаться передачей владения. В Листинге 4-4 показан пример функции, возвращающей некоторое значение, с подобными же комментариями, как в Листинге 4-3.</p>
<Listing number="4-4" file-name="src/main.rs" caption="Transferring ownership of return values">
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let s1 = gives_ownership();        // gives_ownership перемещает своё возвращаемое значение
                                       // в s1

    let s2 = String::from("hello");    // s2 входит в область видимости

    let s3 = takes_and_gives_back(s2); // s2 перемещается в
                                       // takes_and_gives_back, которая также
                                       // перемещает в s3 своё возвращаемое значение
} // Здесь s3 покидает область видимости и её память высвобождается. s2 перемещена: ничего
  // не происходит. s1 покидает область видимости и её память высвобождается.

fn gives_ownership() -&gt; String {       // gives_ownership перемещает своё
                                       // возвращаемое значение в то,
                                       // что вызвало её

    let some_string = String::from("твоё"); // some_string входит в область видимости

    some_string                        // some_string возвращается из функции и 
                                       // перемещается в то, что вызвало
                                       // функцию
}

Эта функция принимает String и возвращает String.fn takes_and_gives_back(a_string: String) -&gt; String {
    // a_string входит в область
    // видимости

    a_string  // a_string возвращается из функции перемещается в то, что вызвало функцию
}</code></pre></pre>
</Listing>
<p>The ownership of a variable follows the same pattern every time: Assigning a value to another variable moves it. When a variable that includes data on the heap goes out of scope, the value will be cleaned up by <code>drop</code> unless ownership of the data has been moved to another variable.</p>
<p>Хотя всё исправно работает, получать владение, а затем возвращать его из каждой функцией довольно утомительно. Что, если мы хотим, чтобы функция использовала значение, но не становилась владельцем? Очень раздражает, что всё, что мы передаём, также должно быть передано обратно, если мы хотим использовать это снова (помимо любых вычисленных в теле функции данных, которые мы также можем хотеть вернуть).</p>
<p>Rust позволяет нам возвращать из функции несколько значений, используя кортеж, как показано в Листинге 4-5.</p>
<Listing number="4-5" file-name="src/main.rs" caption="Returning ownership of parameters">
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("Длина '{s2}' равна {len}.");
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len() возвращает длину String

    (s, length)
}</code></pre></pre>
</Listing>
<p>But this is too much ceremony and a lot of work for a concept that should be common. Luckily for us, Rust has a feature for using a value without transferring ownership: references.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch04-00-understanding-ownership.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch04-02-references-and-borrowing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch04-00-understanding-ownership.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch04-02-references-and-borrowing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
