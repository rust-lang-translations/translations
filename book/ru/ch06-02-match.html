<!DOCTYPE HTML>
<html lang="ru" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Конструкция match - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch06-02-match.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch06-02-match.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ru");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Old heading. Do not remove or links may break. -->
<p><a id="the-match-control-flow-operator"></a></p>
<h2 id="Конструкция-match"><a class="header" href="#Конструкция-match">Конструкция <code>match</code></a></h2>
<p>В Rust есть чрезвычайно мощная конструкция управления потоком, именуемая <code>match</code> — она позволяет сравнивать значение с различными шаблонами и исполнять код в зависимости от того, какой из шаблонов совпал. Шаблоны могут состоять из литералов, имён переменных, неопровержимых шаблонов и многого другого; в <a href="ch19-00-patterns.html">Главе 19</a><!-- ignore --> рассматриваются все различные виды шаблонов и то, что они делают. Сила <code>match</code> заключается в выразительности шаблонов и в том, что компилятор способен проверить, что все возможные случаи обработаны.</p>
<p>Думайте о выражении <code>match</code> как о машине для сортировки монет: монеты скользят по дорожке с различными по размеру отверстиями, и каждая монета падает в первое отверстие, в которое она помещается. Таким же образом значения проходят через каждый шаблон в <code>match</code>, и при первом же подходящем шаблоне значение попадает в соответствующий блок кода, который и будет исполняться.</p>
<p>Кстати, говоря о монетах! Давайте используем их, чтобы показать работу <code>match</code>. Для этого мы напишем функцию, которая будет получать на вход неизвестную монету США и, подобно счётной машине, определять, какая это монета, и возвращать её стоимость в центах. Соответствующий код приведён в Листинге 6-3.</p>
<Listing number="6-3" caption="An enum and a `match` expression that has the variants of the enum as its patterns">
<pre><pre class="playground"><code class="language-rust edition2021">enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p>Построчно разберём <code>match</code> в функции <code>value_in_cents</code>. Сначала пишется ключевое слово <code>match</code>, затем следует выражение, которое в данном случае является значением <code>coin</code>. Это выглядит очень похожим на условное выражение при <code>if</code>, но есть важное отличие: в <code>if</code> выражение должно возвращать логическое значение, а здесь это может быть любой тип. Тип <code>coin</code> в этом примере — перечисление типа <code>Coin</code>, объявленное в первой строке.</p>
<p>Далее идут ветви <code>match</code>. Ветви состоят из двух частей: шаблон и некоторый код. Здесь первая ветвь имеет шаблон, который является значением <code>Coin::Penny</code>, затем идёт оператор <code>=&gt;</code>, который разделяет шаблон и исполняемый код. Код в этом случае — это просто значение <code>1</code>. Каждая ветвь отделяется от последующей при помощи запятой.</p>
<p>Когда исполняется выражение <code>match</code>, оно последовательно сравнивает полученное значение с шаблоном каждой ветви. Если значение отвечает шаблону, то код, связанный с этим шаблоном, исполняется. Если значение не отвечает этому шаблону, то происходит попытка сопоставить значение со следующим шаблоном: по аналогии с автоматом по сортировке монет. У нас может быть столько ветвей, сколько нужно: в Листинге 6-3 наш <code>match</code> состоит из четырёх ветвей.</p>
<p>Код, связанный с каждой ветвью, является выражением, а результирующее значение выражения в соответствующем ответвлении — это значение, которое возвращается из всего выражения <code>match</code>.</p>
<p>Обычно фигурные скобки не используются, если код совпадающей ветви невелик (как в Листинге 6-3, где каждая ветвь просто возвращает значение). Если вы хотите выполнить несколько строк кода в одной ветви, вы должны использовать фигурные скобки; запятая после этой ветви необязательна. Например, следующий код печатает "Счастливый пенни!" каждый раз, когда метод вызывается с <code>Coin::Penny</code>, но при этом он возвращает последнее значение блока — <code>1</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter,
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; {
            println!("Счастливый пенни!");
            1
        }
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<h3 id="Связывание-со-значениями-с-помощью-шаблонов"><a class="header" href="#Связывание-со-значениями-с-помощью-шаблонов">Связывание со значениями с помощью шаблонов</a></h3>
<p>У ветвей выражения <code>match</code> есть ещё одна полезная особенность: они могут привязываться к частям тех значений, которые совпали с шаблоном. Благодаря этому возможно извлекать значения из вариантов перечисления.</p>
<p>В качестве демонстрации, давайте изменим один из вариантов перечисления так, чтобы он хранил в себе данные. С 1999 по 2008, Соединённые Штаты чеканили особенные четвертаки: с уникальными дизайнами для каждого из 50 штатов. Ни одна другая монета не получила дизайна, особенного для отдельных штатов, только четверть доллара имела эту особенность. Мы можем добавить эту информацию в наш <code>enum</code> путём изменения варианта <code>Quarter</code> и включения в него значения <code>UsState</code>, как сделано в Листинге 6-4.</p>
<Listing number="6-4" caption="A `Coin` enum in which the `Quarter` variant also holds a `UsState` value">
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)] // нужно, чтобы мы могли легко посмотреть конкретный штат
enum UsState {
    Alabama,
    Alaska,
    // --код сокращён--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p>Представьте, что ваш друг пытается собрать четвертаки всех 50 штатов. Сортируя монеты по типу, мы также будем сообщать название штата, к которому относится каждый четвертак, чтобы, если у нашего друга нет такой монеты, он мог добавить её в свою коллекцию.</p>
<p>В выражении <code>match</code> мы добавляем переменную с именем <code>state</code> в шаблон, который соответствует значениям варианта <code>Coin::Quarter</code>. Когда <code>Coin::Quarter</code> сопоставится с шаблоном, переменная <code>state</code> станет связана со значением штата этого четвертака. Затем мы сможем использовать <code>state</code> в коде этой ветки; вот так:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --код сокращён--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!("Четвертак из штата {state:?}!");
            25
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    value_in_cents(Coin::Quarter(UsState::Alaska));
</span><span class="boring">}</span></code></pre></pre>
<p>Если мы сделаем вызов функции <code>value_in_cents(Coin::Quarter(UsState::Alaska))</code>, то <code>coin</code> будет иметь значение <code>Coin::Quarter(UsState::Alaska)</code>. Когда мы будем сравнивать это значение с шаблонами каждой из ветвей, ни одному из них оно не будет отвечать, пока мы не достигнем <code>Coin::Quarter(state)</code>. В этот момент <code>state</code> свяжется со значением <code>UsState::Alaska</code>. Затем мы сможем использовать эту переменную в выражении <code>println!</code>, получив таким образом внутреннее значение варианта <code>Quarter</code> перечисления <code>Coin</code>.</p>
<h3 id="Сопоставление-с-вариантами-optiont"><a class="header" href="#Сопоставление-с-вариантами-optiont">Сопоставление с вариантами <code>Option&lt;T&gt;</code></a></h3>
<p>В предыдущем разделе мы хотели получить внутреннее значение <code>T</code> для случая <code>Some</code> при использовании <code>Option&lt;T&gt;</code>. Мы можем обработать тип <code>Option&lt;T&gt;</code>, используя <code>match</code>, как уже делали с перечислением <code>Coin</code>! Вместо сравнивания монет мы будем сравнивать варианты <code>Option&lt;T&gt;</code>, но механизм работы выражения <code>match</code> останется прежним.</p>
<p>Допустим, мы хотим написать функцию, которая принимает <code>Option&lt;i32&gt;</code> и, если есть значение внутри, добавляет <code>1</code> к этому значению. Если же значения нет, то функция должна возвращать значение <code>None</code> и не пытаться выполнить какие-либо операции.</p>
<p>Такую функцию написать довольно легко: всё благодаря выражению <code>match</code>. Код будет выглядеть как в Листинге 6-5.</p>
<Listing number="6-5" caption="A function that uses a `match` expression on an `Option<i32>`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            None =&gt; None,
            Some(i) =&gt; Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>Let’s examine the first execution of <code>plus_one</code> in more detail. When we call <code>plus_one(five)</code>, the variable <code>x</code> in the body of <code>plus_one</code> will have the value <code>Some(5)</code>. We then compare that against each match arm:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p>Значение <code>Some(5)</code> не соответствует шаблону <code>None</code>, поэтому мы сравниваем значение со следующим шаблоном:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span><span class="boring">            None =&gt; None,
</span>            Some(i) =&gt; Some(i + 1),
<span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p>Отвечает ли значение <code>Some(5)</code> шаблону <code>Some(i)</code>? Да, конечно! они представлены одинаковыми вариантами перечисления. Раз так, переменная <code>i</code> привязывается к значению, содержащемуся внутри <code>Some</code>, то есть <code>i</code> получает значение <code>5</code>. Затем исполняется код, связанный с данной ветвью: мы добавляем <code>1</code> к значению <code>i</code> и создаём новое значение <code>Some</code> со значением <code>6</code> внутри.</p>
<p>Теперь давайте рассмотрим второй вызов <code>plus_one</code> в Листинге 6-5 (где <code>x</code> является <code>None</code>). Мы входим в выражение <code>match</code> и сравниваем значение с шаблоном первой ветви:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p>Оно совпадает! Данное значение ничего в себе не хранит, так что выражение просто возвращает значение <code>None</code>, находящееся справа от <code>=&gt;</code>. Поскольку шаблон первой ветви совпал, сравнений с оставшимися шаблонами не происходит.</p>
<p>Комбинирование <code>match</code> и перечислений полезно во многих ситуациях. Вы часто будете видеть подобную комбинацию в коде на Rust: перебор вариантов перечисления конструкцией <code>match</code>, связывание переменной к данным внутри значения, исполнение код на основе извлечённых данных. Сначала это может показаться немного сложным, но как только вы привыкнете, то захотите, чтобы такая возможность была бы во всех языках. <code>match</code> никого не оставляет равнодушным.</p>
<h3 id="Ветви-match-охватывают-все-возможные-случаи"><a class="header" href="#Ветви-match-охватывают-все-возможные-случаи">Ветви <code>match</code> охватывают все возможные случаи</a></h3>
<p>Есть ещё одна особенность <code>match</code>, которую мы должны обсудить: шаблоны должны покрывать все возможные случаи. Рассмотрим следующую версию нашей функции <code>plus_one</code>, содержащую ошибку и потому не компилирующуюся:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            Some(i) =&gt; Some(i + 1),
        }
    }
<span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p>Мы не обработали вариант None, а неучёт возможных случаев — прямой путь к багам. К счастью, Rust умеет ловить такие промахи. Если мы попытаемся скомпилировать такой код, мы получим ошибку компиляции:</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
   --&gt; src/main.rs:3:15
    |
3   |         match x {
    |               ^ pattern `None` not covered
    |
note: `Option&lt;i32&gt;` defined here
   --&gt; file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/core/src/option.rs:571:1
    |
571 | pub enum Option&lt;T&gt; {
    | ^^^^^^^^^^^^^^^^^^
...
575 |     None,
    |     ---- not covered
    = note: the matched value is of type `Option&lt;i32&gt;`
help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown
    |
4   ~             Some(i) =&gt; Some(i + 1),
5   ~             None =&gt; todo!(),
    |

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums` (bin "enums") due to 1 previous error
</code></pre>
<p>Rust знает, что мы не описали все возможные случаи, и даже знает, какой именно из шаблонов мы упустили! Сопоставления в Rust являются <em>исчерпывающими</em>: мы обязаны покрыть все возможные варианты, чтобы код был корректным. Особенно — в случае <code>Option&lt;T&gt;</code>, когда Rust не даёт нам забыть обработать явным образом значение <code>None</code>, тем самым защищая нас от ложного предположения о наличии не-null значения, и оберегая нас от опасности совершить ошибку на миллиард долларов, о которой говорилось ранее.</p>
<h3 id="Универсальные-шаблоны-и-заполнитель-_"><a class="header" href="#Универсальные-шаблоны-и-заполнитель-_">Универсальные шаблоны и заполнитель <code>_</code></a></h3>
<p>Используя перечисления, мы также можем выполнять специальные действия для нескольких определённых значений, а для всех остальных значений выполнять одно общее действие по умолчанию. Представьте, что мы реализуем игру, в которой при выпадении 3 игрок не двигается, а получает новую модную шляпу. Если выпадает 7, игрок теряет шляпу. При всех остальных значениях ваш игрок перемещается на столько-то мест на игровом поле. Ниже дан пример <code>match</code>, реализующего описанное поведение. Результат броска костей жёстко прописан в программе (а не является случайным значением), а также вся логика функций представлена функциями без тел, поскольку их реализация не входит в рамки данного примера.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        other =&gt; move_player(other),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn move_player(num_spaces: u8) {}
<span class="boring">}</span></code></pre></pre>
<p>Для первых двух ветвей шаблонами являются литералы <code>3</code> и <code>7</code>. Для последней ветви, которая охватывает все остальные возможные значения, шаблоном является переменная, которую мы решили назвать <code>other</code>. Код, выполняемый для ветки <code>other</code>, использует эту переменную, передавая её в функцию <code>move_player</code>.</p>
<p>Этот код компилируется, даже хотя мы не перечислили все возможные случаи: всё потому что последний шаблон будет соответствовать всем значениям, не указанным в конкретном списке. Этот универсальный шаблон удовлетворяет требованию, что сопоставление должно быть исчерпывающим. Обратите внимание, что мы должны поместить ветвь с универсальным шаблоном последней, потому что сопоставление с шаблонами происходит по порядку. Rust предупредит нас, если мы добавим ветви после универсального шаблона: до этих ветвей исполнение никогда не дойдёт, а мы явно не для этого их пишем!</p>
<p>В Rust также есть шаблон, который можно использовать, когда нам не нужно значение, с которым связывается универсальный шаблон: <code>_</code>. Он является специальным шаблоном, который соответствует любому значению и не привязывается к нему. Его использование говорит Rust, что мы не собираемся использовать это значение, поэтому Rust не будет предупреждать нас о неиспользуемой переменной.</p>
<p>Давайте изменим правила игры так: если выпадает что-то, кроме 3 или 7, нужно перебросить кость. Нам не нужно использовать значение в последнем случае, поэтому мы можем изменить наш код, чтобы использовать <code>_</code> вместо переменной с именем <code>other</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        _ =&gt; reroll(),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn reroll() {}
<span class="boring">}</span></code></pre></pre>
<p>Этот пример также удовлетворяет требованию исчерпывающей полноты, поскольку мы явно игнорируем все остальные значения в последней ветви: подходящий шаблон найдётся для всех.</p>
<p>Изменим правила игры ещё раз, чтобы в ваш ход ничего не происходило, если вы выбрасываете что-либо кроме 3 или 7. Мы можем реализовать это, используя unit (тип пустого кортежа, который мы упоминали в разделе <a href="ch03-02-data-types.html#%D0%A2%D0%B8%D0%BF-%D0%BA%D0%BE%D1%80%D1%82%D0%B5%D0%B6%D0%B0">"Тип кортежа"</a><!-- ignore -->) на месте кода, который соответствует ветви <code>_</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        _ =&gt; (),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
<span class="boring">}</span></code></pre></pre>
<p>Здесь мы явно говорим Rust, что не собираемся использовать никакое значение, которое оказалось не соответствующим шаблонам предыдущих ветвей, и при этом не хотим запускать никакой прочий код.</p>
<p>Подробнее о шаблонах и сопоставлении мы поговорим в <a href="ch19-00-patterns.html">Главе 19</a><!-- ignore -->. Пока же мы перейдём к конструкции <code>if let</code>, которая может быть полезна в ситуациях, когда выражение <code>match</code> слишком многословно.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch06-01-defining-an-enum.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch06-03-if-let.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch06-01-defining-an-enum.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch06-03-if-let.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
