<!DOCTYPE HTML>
<html lang="ru" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Конструкция match - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch06-02-match.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch06-02-match.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ru");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Old headings. Do not remove or links may break. -->
<p><a id="the-match-control-flow-operator"></a></p>
<h2 id="Конструкция-match"><a class="header" href="#Конструкция-match">Конструкция <code>match</code></a></h2>
<p>В Rust есть чрезвычайно мощная конструкция управления потоком, именуемая <code>match</code> — она позволяет сравнивать значение с различными шаблонами и исполнять код в зависимости от того, какой из шаблонов совпал. Шаблоны могут состоять из литералов, имён переменных, неопровержимых шаблонов и многого другого; в <a href="ch19-00-patterns.html">Главе 19</a><!-- ignore --> рассматриваются все различные виды шаблонов и то, что они делают. Сила <code>match</code> заключается в выразительности шаблонов и в том, что компилятор способен проверить, что все возможные случаи обработаны.</p>
<p>Think of a <code>match</code> expression as being like a coin-sorting machine: Coins slide down a track with variously sized holes along it, and each coin falls through the first hole it encounters that it fits into. In the same way, values go through each pattern in a <code>match</code>, and at the first pattern the value “fits,” the value falls into the associated code block to be used during execution.</p>
<p>Кстати, говоря о монетах! Давайте используем их, чтобы показать работу <code>match</code>. Для этого мы напишем функцию, которая будет получать на вход неизвестную монету США и, подобно счётной машине, определять, какая это монета, и возвращать её стоимость в центах. Соответствующий код приведён в Листинге 6-3.</p>
<Listing number="6-3" caption="An enum and a `match` expression that has the variants of the enum as its patterns">
<pre><pre class="playground"><code class="language-rust edition2024">enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p>Let’s break down the <code>match</code> in the <code>value_in_cents</code> function. First, we list the <code>match</code> keyword followed by an expression, which in this case is the value <code>coin</code>. This seems very similar to a conditional expression used with <code>if</code>, but there’s a big difference: With <code>if</code>, the condition needs to evaluate to a Boolean value, but here it can be any type. The type of <code>coin</code> in this example is the <code>Coin</code> enum that we defined on the first line.</p>
<p>Далее идут ветви <code>match</code>. Ветви состоят из двух частей: шаблон и некоторый код. Здесь первая ветвь имеет шаблон, который является значением <code>Coin::Penny</code>, затем идёт оператор <code>=&gt;</code>, который разделяет шаблон и исполняемый код. Код в этом случае — это просто значение <code>1</code>. Каждая ветвь отделяется от последующей при помощи запятой.</p>
<p>When the <code>match</code> expression executes, it compares the resultant value against the pattern of each arm, in order. If a pattern matches the value, the code associated with that pattern is executed. If that pattern doesn’t match the value, execution continues to the next arm, much as in a coin-sorting machine. We can have as many arms as we need: In Listing 6-3, our <code>match</code> has four arms.</p>
<p>Код, связанный с каждой ветвью, является выражением, а результирующее значение выражения в соответствующем ответвлении — это значение, которое возвращается из всего выражения <code>match</code>.</p>
<p>We don’t typically use curly brackets if the match arm code is short, as it is in Listing 6-3 where each arm just returns a value. If you want to run multiple lines of code in a match arm, you must use curly brackets, and the comma following the arm is then optional. For example, the following code prints “Lucky penny!” every time the method is called with a <code>Coin::Penny</code>, but it still returns the last value of the block, <code>1</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter,
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; {
            println!("Счастливый пенни!");
            1
        }
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<h3 id="Связывание-со-значениями-с-помощью-шаблонов"><a class="header" href="#Связывание-со-значениями-с-помощью-шаблонов">Связывание со значениями с помощью шаблонов</a></h3>
<p>У ветвей выражения <code>match</code> есть ещё одна полезная особенность: они могут привязываться к частям тех значений, которые совпали с шаблоном. Благодаря этому возможно извлекать значения из вариантов перечисления.</p>
<p>В качестве демонстрации, давайте изменим один из вариантов перечисления так, чтобы он хранил в себе данные. С 1999 по 2008, Соединённые Штаты чеканили особенные четвертаки: с уникальными дизайнами для каждого из 50 штатов. Ни одна другая монета не получила дизайна, особенного для отдельных штатов, только четверть доллара имела эту особенность. Мы можем добавить эту информацию в наш <code>enum</code> путём изменения варианта <code>Quarter</code> и включения в него значения <code>UsState</code>, как сделано в Листинге 6-4.</p>
<Listing number="6-4" caption="A `Coin` enum in which the `Quarter` variant also holds a `UsState` value">
<pre><pre class="playground"><code class="language-rust edition2024">#[derive(Debug)] // нужно, чтобы мы могли легко посмотреть конкретный штат
enum UsState {
    Alabama,
    Alaska,
    // --код сокращён--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p>Представьте, что ваш друг пытается собрать четвертаки всех 50 штатов. Сортируя монеты по типу, мы также будем сообщать название штата, к которому относится каждый четвертак, чтобы, если у нашего друга нет такой монеты, он мог добавить её в свою коллекцию.</p>
<p>In the match expression for this code, we add a variable called <code>state</code> to the pattern that matches values of the variant <code>Coin::Quarter</code>. When a <code>Coin::Quarter</code> matches, the <code>state</code> variable will bind to the value of that quarter’s state. Then, we can use <code>state</code> in the code for that arm, like so:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --код сокращён--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!("Четвертак из штата {state:?}!");
            25
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    value_in_cents(Coin::Quarter(UsState::Alaska));
</span><span class="boring">}</span></code></pre></pre>
<p>Если мы сделаем вызов функции <code>value_in_cents(Coin::Quarter(UsState::Alaska))</code>, то <code>coin</code> будет иметь значение <code>Coin::Quarter(UsState::Alaska)</code>. Когда мы будем сравнивать это значение с шаблонами каждой из ветвей, ни одному из них оно не будет отвечать, пока мы не достигнем <code>Coin::Quarter(state)</code>. В этот момент <code>state</code> свяжется со значением <code>UsState::Alaska</code>. Затем мы сможем использовать эту переменную в выражении <code>println!</code>, получив таким образом внутреннее значение варианта <code>Quarter</code> перечисления <code>Coin</code>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="matching-with-optiont"></a></p>
<h3 id="the-optiont-match-pattern"><a class="header" href="#the-optiont-match-pattern">The <code>Option&lt;T&gt;</code> <code>match</code> Pattern</a></h3>
<p>В предыдущем разделе мы хотели получить внутреннее значение <code>T</code> для случая <code>Some</code> при использовании <code>Option&lt;T&gt;</code>. Мы можем обработать тип <code>Option&lt;T&gt;</code>, используя <code>match</code>, как уже делали с перечислением <code>Coin</code>! Вместо сравнивания монет мы будем сравнивать варианты <code>Option&lt;T&gt;</code>, но механизм работы выражения <code>match</code> останется прежним.</p>
<p>Допустим, мы хотим написать функцию, которая принимает <code>Option&lt;i32&gt;</code> и, если есть значение внутри, добавляет <code>1</code> к этому значению. Если же значения нет, то функция должна возвращать значение <code>None</code> и не пытаться выполнить какие-либо операции.</p>
<p>Такую функцию написать довольно легко: всё благодаря выражению <code>match</code>. Код будет выглядеть как в Листинге 6-5.</p>
<Listing number="6-5" caption="A function that uses a `match` expression on an `Option<i32>`">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            None =&gt; None,
            Some(i) =&gt; Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>Let’s examine the first execution of <code>plus_one</code> in more detail. When we call <code>plus_one(five)</code>, the variable <code>x</code> in the body of <code>plus_one</code> will have the value <code>Some(5)</code>. We then compare that against each match arm:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p>Значение <code>Some(5)</code> не соответствует шаблону <code>None</code>, поэтому мы сравниваем значение со следующим шаблоном:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span><span class="boring">            None =&gt; None,
</span>            Some(i) =&gt; Some(i + 1),
<span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p>Отвечает ли значение <code>Some(5)</code> шаблону <code>Some(i)</code>? Да, конечно! они представлены одинаковыми вариантами перечисления. Раз так, переменная <code>i</code> привязывается к значению, содержащемуся внутри <code>Some</code>, то есть <code>i</code> получает значение <code>5</code>. Затем исполняется код, связанный с данной ветвью: мы добавляем <code>1</code> к значению <code>i</code> и создаём новое значение <code>Some</code> со значением <code>6</code> внутри.</p>
<p>Теперь давайте рассмотрим второй вызов <code>plus_one</code> в Листинге 6-5 (где <code>x</code> является <code>None</code>). Мы входим в выражение <code>match</code> и сравниваем значение с шаблоном первой ветви:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p>Оно совпадает! Данное значение ничего в себе не хранит, так что выражение просто возвращает значение <code>None</code>, находящееся справа от <code>=&gt;</code>. Поскольку шаблон первой ветви совпал, сравнений с оставшимися шаблонами не происходит.</p>
<p>Комбинирование <code>match</code> и перечислений полезно во многих ситуациях. Вы часто будете видеть подобную комбинацию в коде на Rust: перебор вариантов перечисления конструкцией <code>match</code>, связывание переменной к данным внутри значения, исполнение код на основе извлечённых данных. Сначала это может показаться немного сложным, но как только вы привыкнете, то захотите, чтобы такая возможность была бы во всех языках. <code>match</code> никого не оставляет равнодушным.</p>
<h3 id="Ветви-match-охватывают-все-возможные-случаи"><a class="header" href="#Ветви-match-охватывают-все-возможные-случаи">Ветви <code>match</code> охватывают все возможные случаи</a></h3>
<p>There’s one other aspect of <code>match</code> we need to discuss: The arms’ patterns must cover all possibilities. Consider this version of our <code>plus_one</code> function, which has a bug and won’t compile:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            Some(i) =&gt; Some(i + 1),
        }
    }
<span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p>Мы не обработали вариант None, а неучёт возможных случаев — прямой путь к багам. К счастью, Rust умеет ловить такие промахи. Если мы попытаемся скомпилировать такой код, мы получим ошибку компиляции:</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
 --&gt; src/main.rs:3:15
  |
3 |         match x {
  |               ^ pattern `None` not covered
  |
note: `Option&lt;i32&gt;` defined here
 --&gt; /rustc/1159e78c4747b02ef996e55082b704c09b970588/library/core/src/option.rs:593:1
 ::: /rustc/1159e78c4747b02ef996e55082b704c09b970588/library/core/src/option.rs:597:5
  |
  = note: not covered
  = note: the matched value is of type `Option&lt;i32&gt;`
help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown
  |
4 ~             Some(i) =&gt; Some(i + 1),
5 ~             None =&gt; todo!(),
  |

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums` (bin "enums") due to 1 previous error
</code></pre>
<p>Rust knows that we didn’t cover every possible case and even knows which pattern we forgot! Matches in Rust are <em>exhaustive</em>: We must exhaust every last possibility in order for the code to be valid. Especially in the case of <code>Option&lt;T&gt;</code>, when Rust prevents us from forgetting to explicitly handle the <code>None</code> case, it protects us from assuming that we have a value when we might have null, thus making the billion-dollar mistake discussed earlier impossible.</p>
<h3 id="Универсальные-шаблоны-и-заполнитель-_"><a class="header" href="#Универсальные-шаблоны-и-заполнитель-_">Универсальные шаблоны и заполнитель <code>_</code></a></h3>
<p>Using enums, we can also take special actions for a few particular values, but for all other values take one default action. Imagine we’re implementing a game where, if you roll a 3 on a dice roll, your player doesn’t move but instead gets a fancy new hat. If you roll a 7, your player loses a fancy hat. For all other values, your player moves that number of spaces on the game board. Here’s a <code>match</code> that implements that logic, with the result of the dice roll hardcoded rather than a random value, and all other logic represented by functions without bodies because actually implementing them is out of scope for this example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        other =&gt; move_player(other),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn move_player(num_spaces: u8) {}
<span class="boring">}</span></code></pre></pre>
<p>Для первых двух ветвей шаблонами являются литералы <code>3</code> и <code>7</code>. Для последней ветви, которая охватывает все остальные возможные значения, шаблоном является переменная, которую мы решили назвать <code>other</code>. Код, выполняемый для ветки <code>other</code>, использует эту переменную, передавая её в функцию <code>move_player</code>.</p>
<p>This code compiles, even though we haven’t listed all the possible values a <code>u8</code> can have, because the last pattern will match all values not specifically listed. This catch-all pattern meets the requirement that <code>match</code> must be exhaustive. Note that we have to put the catch-all arm last because the patterns are evaluated in order. If we had put the catch-all arm earlier, the other arms would never run, so Rust will warn us if we add arms after a catch-all!</p>
<p>В Rust также есть шаблон, который можно использовать, когда нам не нужно значение, с которым связывается универсальный шаблон: <code>_</code>. Он является специальным шаблоном, который соответствует любому значению и не привязывается к нему. Его использование говорит Rust, что мы не собираемся использовать это значение, поэтому Rust не будет предупреждать нас о неиспользуемой переменной.</p>
<p>Let’s change the rules of the game: Now, if you roll anything other than a 3 or a 7, you must roll again. We no longer need to use the catch-all value, so we can change our code to use <code>_</code> instead of the variable named <code>other</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        _ =&gt; reroll(),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn reroll() {}
<span class="boring">}</span></code></pre></pre>
<p>Этот пример также удовлетворяет требованию исчерпывающей полноты, поскольку мы явно игнорируем все остальные значения в последней ветви: подходящий шаблон найдётся для всех.</p>
<p>Изменим правила игры ещё раз, чтобы в ваш ход ничего не происходило, если вы выбрасываете что-либо кроме 3 или 7. Мы можем реализовать это, используя unit (тип пустого кортежа, который мы упоминали в разделе <a href="ch03-02-data-types.html#%D0%A2%D0%B8%D0%BF-%D0%BA%D0%BE%D1%80%D1%82%D0%B5%D0%B6%D0%B0">"Тип кортежа"</a><!-- ignore -->) на месте кода, который соответствует ветви <code>_</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        _ =&gt; (),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
<span class="boring">}</span></code></pre></pre>
<p>Здесь мы явно говорим Rust, что не собираемся использовать никакое значение, которое оказалось не соответствующим шаблонам предыдущих ветвей, и при этом не хотим запускать никакой прочий код.</p>
<p>Подробнее о шаблонах и сопоставлении мы поговорим в <a href="ch19-00-patterns.html">Главе 19</a><!-- ignore -->. Пока же мы перейдём к конструкции <code>if let</code>, которая может быть полезна в ситуациях, когда выражение <code>match</code> слишком многословно.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch06-01-defining-an-enum.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch06-03-if-let.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch06-01-defining-an-enum.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch06-03-if-let.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
