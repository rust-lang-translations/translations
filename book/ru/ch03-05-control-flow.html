<!DOCTYPE HTML>
<html lang="ru" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Управление потоком - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch03-05-control-flow.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch03-05-control-flow.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ru");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Управление-потоком"><a class="header" href="#Управление-потоком">Управление потоком</a></h2>
<p>The ability to run some code depending on whether a condition is <code>true</code> and the ability to run some code repeatedly while a condition is <code>true</code> are basic building blocks in most programming languages. The most common constructs that let you control the flow of execution of Rust code are <code>if</code> expressions and loops.</p>
<h3 id="Выражения-if"><a class="header" href="#Выражения-if">Выражения <code>if</code></a></h3>
<p>Выражение <code>if</code> позволяет вам исполнять код в зависимости от истинности условий. Вы определяете условие исполнения, а потом используете <code>if</code>, чтобы указать программе: "Исполни этот код, если условие истинно; иначе — ничего не делай".</p>
<p>Создайте новый проект в своей директории <em>projects</em> и назовите его <em>branches</em>. В нём мы будем изучать выражение <code>if</code>. Заполните файл <em>src/main.rs</em> этим кодом:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let number = 3;

    if number &lt; 5 {
        println!("условие оказалось истинно");
    } else {
        println!("условие оказалось ложно");
    }
}</code></pre></pre>
<p>Все выражения <code>if</code> состоят с ключевого слова <code>if</code> и следующего за ним условия. В нашем случае, условие проверяет, меньше ли, чем 5, переменная <code>number</code>. В фигурных скобках, сразу после условия, мы размещаем код, который надо исполнить, если условие истинно. Блоки кода, связанные с условиями в выражениях <code>if</code>, иногда называются <em>ветвями</em> — аналогично ветвям в выражении <code>match</code>, которое мы обсуждали в разделе ["Сравнение догадки с загаданным числом"] (ch02-00-guessing-game-tutorial.html#Сравнение-догадки-с-загаданным-числом) <!-- ignore --> Главы 2.</p>
<p>Это не обязательно, но мы можем добавить выражение <code>else</code>, которое указывает на код, который нужно запустить в случае, если условие оказалось ложным. Если вы не напишете выражение <code>else</code>, а условие окажется ложным, программа просто пропустит блок кода при <code>if</code> и продолжит исполнять всё, что следует за ним.</p>
<p>Попробуйте запустить этот код; вы должны увидеть следующий вывод:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
условие оказалось истинно
</code></pre>
<p>Изменим значение <code>number</code> на значение, которое сделает условие ложным:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    let number = 7;
<span class="boring">
</span><span class="boring">    if number &lt; 5 {
</span><span class="boring">        println!("условие оказалось истинно");
</span><span class="boring">    } else {
</span><span class="boring">        println!("условие оказалось ложно");
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Снова запустите программу и взгляните на вывод:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
условие оказалось ложным
</code></pre>
<p>Стоит также отметить, что условие всегда <em>должно</em> иметь тип <code>bool</code>, иначе мы получим ошибку компиляции. Например, попробуем запустить следующий код:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let number = 3;

    if number {
        println!("number было тройкой");
    }
}</code></pre>
<p>Условие при <code>if</code> вычислилось в значение <code>3</code>, и Rust бросил ошибку:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: mismatched types
 --&gt; src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected `bool`, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` (bin "branches") due to 1 previous error
</code></pre>
<p>Ошибка свидетельствует о том, что Rust оиждал увидеть здесь <code>bool</code>, но получил целое число. В отличие от таких языков как Ruby и JavaScript, в Rust нет возможности интерпретировать не логические типы как логические. Вы всегда должны использовать с <code>if</code> условие, являющееся выражением, которое вычисляется в логическое значение. Если вы хотите запустить блок кода только если <code>number</code> не равно <code>0</code>, нужно предоставить выражению <code>if</code> вот такое условие:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let number = 3;

    if number != 0 {
        println!("number оказалось не равно нулю");
    }
}</code></pre></pre>
<p>Запустив этот код, вы увидите текст <code>number оказалось не равно нулю</code>.</p>
<h4 id="Обработка-нескольких-условий-с-помощью-else-if"><a class="header" href="#Обработка-нескольких-условий-с-помощью-else-if">Обработка нескольких условий с помощью <code>else if</code></a></h4>
<p>Вы можете проверять несколько условий, объединив <code>if</code> и <code>else</code> в одно выражение <code>else if</code>. Например:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number делится на 4");
    } else if number % 3 == 0 {
        println!("number делится на 3");
    } else if number % 2 == 0 {
        println!("number делится на 2");
    } else {
        println!("number не делится ни на 4, ни на 3, ни на 2");
    }
}</code></pre></pre>
<p>Эта программа потенциально может завершиться четырьмя разными путями. Запустив её, вы увидите этот вывод:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
number делится 3
</code></pre>
<p>В этой программе происходит поочерёдная проверка каждого выражения <code>if</code>. Как только программа встретит условие, вычисляющееся в <code>true</code>, исполнится соответствующий блок кода. Обратите внимание, что хотя 6 делится на 2, мы не видим ни <code>number делится на 2</code> (сообщение предпоследней ветви), ни <code>number не делится ни на 4, ни на 3, ни на 2</code> (сообщение ветви <code>else</code>). Причина в том, что на первом же истинном условии проверка и останавливается — идущие далее условия не проверяются.</p>
<p>Использование большого количества выражений <code>else if</code> — верный способ сделать свой код запутанным и непонятным. Если вы используете больше одного такого оператора, возможно, вашей программе нужен рефакторинг. Глава 6 расскажет вам об операторе ветвления <code>match</code>, который отлично подойдёт для подобных случаев.</p>
<h4 id="Использование-if-в-инструкции-let"><a class="header" href="#Использование-if-в-инструкции-let">Использование <code>if</code> в инструкции <code>let</code></a></h4>
<p>Поскольку <code>if</code> — это выражение, мы можем использовать его в правой части инструкции <code>let</code>, чтобы условием управлять тем, что присваивается переменной. Посмотрите на Листинг 3-2.</p>
<Listing number="3-2" file-name="src/main.rs" caption="Assigning the result of an `if` expression to a variable">
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("Значение number: {number}");
}</code></pre></pre>
</Listing>
<p>Переменная <code>number</code> связывается со значением, в которое вычислится выражение <code>if</code>. Запустите этот код и посмотрите, что выйдет:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/branches`
Значение number: 5
</code></pre>
<p>Помните, что 1) блоки кода вычисляются в значение последнего их выражения и 2) числа сами по себе тоже являются выражениями. В нашем случае, значение всего выражения <code>if</code> зависит от того, какой исполнится блок кода. Из этого следует, что значение каждого блока кода должно иметь один и тот же тип. В Листинге 3-2 всё имеенно так: обе ветви <code>if</code> и ветвь <code>else</code> вычисляются в целое число типа <code>i32</code>. Если ветви будут вычисляться в значения разных типов (как показано в примере ниже), вы получите ошибку:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let condition = true;

    let number = if condition { 5 } else { "шесть" };

    println!("Значение number: {number}");
}</code></pre>
<p>Если попытаться скомпилировать этот код, мы получим ошибку. Значения ветвей <code>if</code> и <code>else</code> имеют разные типы, и Rust как раз указывает, где находится ошибка:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: `if` and `else` have incompatible types
 --&gt; src/main.rs:4:44
  |
4 |     let number = if condition { 5 } else { "шесть" };
  |                                 -          ^^^^^^^ expected integer, found `&amp;str`
  |                                 |
  |                                 expected because of this

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` (bin "branches") due to 1 previous error
</code></pre>
<p>The expression in the <code>if</code> block evaluates to an integer, and the expression in the <code>else</code> block evaluates to a string. This won’t work, because variables must have a single type, and Rust needs to know definitively at compile time what type the <code>number</code> variable is. Knowing the type of <code>number</code> lets the compiler verify the type is valid everywhere we use <code>number</code>. Rust wouldn’t be able to do that if the type of <code>number</code> was only determined at runtime; the compiler would be more complex and would make fewer guarantees about the code if it had to keep track of multiple hypothetical types for any variable.</p>
<h3 id="Повторное-исполнение-кода-с-помощью-циклов"><a class="header" href="#Повторное-исполнение-кода-с-помощью-циклов">Повторное исполнение кода с помощью циклов</a></h3>
<p>Часто нужно исполнить некоторый объём кода больше, чем единожды. Для этого в Rust существуют несколько видов <em>циклов</em>, которые позволяют исполнить блок кода и затем вернуться к его началу. Чтобы опробовать циклы, создайте новый проект и назовите его <em>loops</em>.</p>
<p>В Rust есть три вида циклов: <code>loop</code>, <code>while</code> и <code>for</code>. Попробуем каждый из них.</p>
<h4 id="Повторение-кода-с-помощью-loop"><a class="header" href="#Повторение-кода-с-помощью-loop">Повторение кода с помощью <code>loop</code></a></h4>
<p>The <code>loop</code> keyword tells Rust to execute a block of code over and over again either forever or until you explicitly tell it to stop.</p>
<p>Замените код в файле <em>src/main.rs</em> в директории <em>loops</em> на код из примера ниже:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!("и ещё раз,");
    }
}</code></pre>
<p>When we run this program, we’ll see <code>again!</code> printed over and over continuously until we stop the program manually. Most terminals support the keyboard shortcut <kbd>ctrl</kbd>-<kbd>C</kbd> to interrupt a program that is stuck in a continual loop. Give it a try:</p>
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-32-loop
cargo run
CTRL-C
-->
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.08s
     Running `target/debug/loops`
и ещё раз,
и ещё раз,
и ещё раз,
и ещё раз,
^Cи ещё раз,
</code></pre>
<p>The symbol <code>^C</code> represents where you pressed <kbd>ctrl</kbd>-<kbd>C</kbd>.</p>
<p>You may or may not see the word <code>again!</code> printed after the <code>^C</code>, depending on where the code was in the loop when it received the interrupt signal.</p>
<p>Естественно, в Rust есть способ программно выйти из цикла. Если вы напишете ключевое слово <code>break</code> внутри цикла, то когда исполнение до него дойдёт, цикл завершится. К слову, мы уже его использовали: вспомните, как мы реализовали <a href="ch02-00-guessing-game-tutorial.html#%D0%97%D0%B0%D0%B2%D0%B5%D1%80%D1%88%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B8%D0%B3%D1%80%D1%8B-%D0%BF%D0%BE%D1%81%D0%BB%D0%B5-%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D1%8C%D0%BD%D0%BE%D0%B9-%D0%B4%D0%BE%D0%B3%D0%B0%D0%B4%D0%BA%D0%B8">"Завершение игры после правильной догадки"</a><!-- ignore --> в нашей игре в угадайку из Главы 2.</p>
<p>Мы также тогда использовали ключевое слово <code>continue</code> — оно указывает циклу пропустить исполнение оставшегося кода и сразу продолжить с новой итерации цикла.</p>
<h4 id="Вычисление-циклов-в-значения"><a class="header" href="#Вычисление-циклов-в-значения">Вычисление циклов в значения</a></h4>
<p>One of the uses of a <code>loop</code> is to retry an operation you know might fail, such as checking whether a thread has completed its job. You might also need to pass the result of that operation out of the loop to the rest of your code. To do this, you can add the value you want returned after the <code>break</code> expression you use to stop the loop; that value will be returned out of the loop so that you can use it, as shown here:</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("result равна {result}");
}</code></pre></pre>
<p>Before the loop, we declare a variable named <code>counter</code> and initialize it to <code>0</code>. Then, we declare a variable named <code>result</code> to hold the value returned from the loop. On every iteration of the loop, we add <code>1</code> to the <code>counter</code> variable, and then check whether the <code>counter</code> is equal to <code>10</code>. When it is, we use the <code>break</code> keyword with the value <code>counter * 2</code>. After the loop, we use a semicolon to end the statement that assigns the value to <code>result</code>. Finally, we print the value in <code>result</code>, which in this case is <code>20</code>.</p>
<p>Вы также можете использовать в цикле ключевое слово <code>return</code>. В отличие от <code>break</code> (которое завершит исполнение только своего <em>цикла</em>), <code>return</code> завершит исполнение сразу всей <em>функции</em>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="loop-labels-to-disambiguate-between-multiple-loops"></a></p>
<h4 id="disambiguating-with-loop-labels"><a class="header" href="#disambiguating-with-loop-labels">Disambiguating with Loop Labels</a></h4>
<p>Если вы работаете во вложенных циклах, <code>break</code> и <code>continue</code> будут относиться только к тому циклу, в которых они написаны. При необходимости вы можете уточнить, с каким из вложенных циклов они должны работать, написав <em>метку цикла</em> после <code>break</code> или <code>continue</code>. Метки циклов записываются перед началом цикла и начинаются с апострофа. Вот пример с одним вложенным циклом:</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {count}");
        let mut remaining = 10;

        loop {
            println!("remaining = {remaining}");
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("Окончательное значение count = {count}");
}</code></pre></pre>
<p>Внешний цикл обозначен меткой <code>'counting_up</code>; он будет запущен от 0 до 2. Внутренний цикл никак не помечен; он будет отсчитывать от 10 до 9. Первый <code>break</code> не имеет метки, так что он прерывает исполнение <em>своего</em> цикла — внутреннего. Инструкция <code>break 'counting_up;</code> завершит исполнение внешнего цикла. Этот код напечатает:</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running `target/debug/loops`
count = 0
remaining = 10
remaining = 9
count = 1
remaining = 10
remaining = 9
count = 2
remaining = 10
Окончательное значение count = 2
</code></pre>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="conditional-loops-with-while"></a></p>
<h4 id="streamlining-conditional-loops-with-while"><a class="header" href="#streamlining-conditional-loops-with-while">Streamlining Conditional Loops with while</a></h4>
<p>A program will often need to evaluate a condition within a loop. While the condition is <code>true</code>, the loop runs. When the condition ceases to be <code>true</code>, the program calls <code>break</code>, stopping the loop. It’s possible to implement behavior like this using a combination of <code>loop</code>, <code>if</code>, <code>else</code>, and <code>break</code>; you could try that now in a program, if you’d like. However, this pattern is so common that Rust has a built-in language construct for it, called a <code>while</code> loop. In Listing 3-3, we use <code>while</code> to loop the program three times, counting down each time, and then, after the loop, to print a message and exit.</p>
<Listing number="3-3" file-name="src/main.rs" caption="Using a `while` loop to run code while a condition evaluates to `true`">
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{number}!");

        number -= 1;
    }

    println!("ПОЕХАЛИ!!!");
}</code></pre></pre>
</Listing>
<p>Эта конструкция серьёзно облегчает создание циклов с условием остановки: код получается проще и чище. Пока условие вычисляется в <code>true</code>, код запускается; иначе, цикл прерывается.</p>
<h4 id="Перебор-элементов-коллекции-с-for"><a class="header" href="#Перебор-элементов-коллекции-с-for">Перебор элементов коллекции с <code>for</code></a></h4>
<p>You can choose to use the <code>while</code> construct to loop over the elements of a collection, such as an array. For example, the loop in Listing 3-4 prints each element in the array <code>a</code>.</p>
<Listing number="3-4" file-name="src/main.rs" caption="Looping through each element of a collection using a `while` loop">
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!("элемент: {}", a[index]);

        index += 1;
    }
}</code></pre></pre>
</Listing>
<p>Here, the code counts up through the elements in the array. It starts at index <code>0</code> and then loops until it reaches the final index in the array (that is, when <code>index &lt; 5</code> is no longer <code>true</code>). Running this code will print every element in the array:</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.32s
     Running `target/debug/loops`
элемент: 10
элемент: 20
элемент: 30
элемент: 40
элемент: 50
</code></pre>
<p>Все пять элементов массива появились на экране, как и ожидалось. Хотя переменная <code>index</code> и достигает в какой-то момент значения <code>5</code>, цикл проверит условие на истинность и потому завершится раньше, чем произойдёт попытка получить шестой элемент массива.</p>
<p>However, this approach is error-prone; we could cause the program to panic if the index value or test condition is incorrect. For example, if you changed the definition of the <code>a</code> array to have four elements but forgot to update the condition to <code>while index &lt; 4</code>, the code would panic. It’s also slow, because the compiler adds runtime code to perform the conditional check of whether the index is within the bounds of the array on every iteration through the loop.</p>
<p>Более лакончиным способом перебрать элементы коллекции является цикл <code>for</code>. Пример цикла <code>for</code> приведён в Листинге 3-5.</p>
<Listing number="3-5" file-name="src/main.rs" caption="Looping through each element of a collection using a `for` loop">
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("элемент: {element}");
    }
}</code></pre></pre>
</Listing>
<p>When we run this code, we’ll see the same output as in Listing 3-4. More importantly, we’ve now increased the safety of the code and eliminated the chance of bugs that might result from going beyond the end of the array or not going far enough and missing some items. Machine code generated from <code>for</code> loops can be more efficient as well because the index doesn’t need to be compared to the length of the array at every iteration.</p>
<p>С циклом <code>for</code> ваш код самостоятельно подстроится под изменения в коллекции, и вам не понадобится следить за двумя участками кода, как это приходилось бы делать в Листинге 3-4."</p>
<p>Безопасность и простота циклов <code>for</code> делают его наиболее часто используемым циклом в Rust. Даже в случаях, когда вы хотите запустить некоторый код произвольное точное количество раз (например, как в цикле в Листинге 3-3), большинство программистов на Rust применят для этого цикл <code>for</code>. Если онкретнее, они воспользуются <code>Range</code> — структуре стандартной библиотеки, которая генерирует последовательность всех чисел между двумя границами (включая нижнюю границу, но не включая верхнюю).</p>
<p>Вот как будет выглядить обратный отсчёт с помощью цикла <code>for</code> и метода <code>rev</code>, переворачивающего генерируемую последовательность:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    for number in (1..4).rev() {
        println!("{number}!");
    }
    println!("ПОЕХАЛИ!!!");
}</code></pre></pre>
<p>Этот код чуть приятнее; не так ли?</p>
<h2 id="Подведём-итоги"><a class="header" href="#Подведём-итоги">Подведём итоги</a></h2>
<p>You made it! This was a sizable chapter: You learned about variables, scalar and compound data types, functions, comments, <code>if</code> expressions, and loops! To practice with the concepts discussed in this chapter, try building programs to do the following:</p>
<ul>
<li>Конвертер температур из градусов Фаренгейта в Цельсия (и наоборот).</li>
<li>Функция генерации _n_ого числа Фибоначчи.</li>
<li>Программа, печатающая текст рождественской английской народной песни <a href="https://en.wikipedia.org/wiki/The_Twelve_Days_of_Christmas_(song)#Lyrics">"The Twelve Days of Christmas"</a>.</li>
</ul>
<p>В следующей главе мы обсудим владение — концепцию Rust, которой обычно <em>нет</em> в других языках программирования.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch03-04-comments.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch04-00-understanding-ownership.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch03-04-comments.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch04-00-understanding-ownership.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
