<!DOCTYPE HTML>
<html lang="ru" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Добавление путей в область видимости ключевым словом use - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ru");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Добавление-путей-в-область-видимости-ключевым-словом-use"><a class="header" href="#Добавление-путей-в-область-видимости-ключевым-словом-use">Добавление путей в область видимости ключевым словом <code>use</code></a></h2>
<p>Having to write out the paths to call functions can feel inconvenient and repetitive. In Listing 7-7, whether we chose the absolute or relative path to the <code>add_to_waitlist</code> function, every time we wanted to call <code>add_to_waitlist</code> we had to specify <code>front_of_house</code> and <code>hosting</code> too. Fortunately, there’s a way to simplify this process: We can create a shortcut to a path with the <code>use</code> keyword once and then use the shorter name everywhere else in the scope.</p>
<p>In Listing 7-11, we bring the <code>crate::front_of_house::hosting</code> module into the scope of the <code>eat_at_restaurant</code> function so that we only have to specify <code>hosting::add_to_waitlist</code> to call the <code>add_to_waitlist</code> function in <code>eat_at_restaurant</code>.</p>
<Listing number="7-11" file-name="src/lib.rs" caption="Bringing a module into scope with `use`">
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}</code></pre>
</Listing>
<p>Добавление <code>use</code> и пути в область видимости аналогично созданию символической ссылки в файловой системе. С добавлением <code>use crate::front_of_house::hosting</code> в корневой модуль крейта, <code>hosting</code> становится допустимым именем в этой области, как если бы модуль <code>hosting</code> был определён в корне крейта. Пути, подключённые в область видимости с помощью <code>use</code>, также проверяются на приватность, как и любые другие пути.</p>
<p>Обратите внимание, что <code>use</code> создаёт псевдоним только для той конкретной области, в которой это объявление <code>use</code> и находится. В Листинге 7-12 функция <code>eat_at_restaurant</code> перемещается в новый дочерний модуль с именем <code>customer</code>, область видимости которого отличается от области видимости инструкции <code>use</code>, поэтому тело функции не будет компилироваться.</p>
<Listing number="7-12" file-name="src/lib.rs" caption="A `use` statement only applies in the scope it’s in.">
<pre><code class="language-rust noplayground test_harness does_not_compile ignore">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

mod customer {
    pub fn eat_at_restaurant() {
        hosting::add_to_waitlist();
    }
}</code></pre>
</Listing>
<p>Ошибка компилятора показывает, что данный псевдоним не может использоваться в модуле <code>customer</code>:</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `hosting`
  --&gt; src/lib.rs:11:9
   |
11 |         hosting::add_to_waitlist();
   |         ^^^^^^^ use of unresolved module or unlinked crate `hosting`
   |
   = help: if you wanted to use a crate named `hosting`, use `cargo add hosting` to add it to your `Cargo.toml`
help: consider importing this module through its public re-export
   |
10 +     use crate::hosting;
   |

warning: unused import: `crate::front_of_house::hosting`
 --&gt; src/lib.rs:7:5
  |
7 | use crate::front_of_house::hosting;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

For more information about this error, try `rustc --explain E0433`.
warning: `restaurant` (lib) generated 1 warning
error: could not compile `restaurant` (lib) due to 1 previous error; 1 warning emitted
</code></pre>
<p>Обратите внимание, что есть также предупреждение о том, что <code>use</code> не спользуется в своей области видимости! Чтобы решить эту проблему, можно переместить <code>use</code> в модуль <code>customer</code>, или же можно сослаться на псевдоним в родительском модуле с помощью <code>super::hosting</code> в дочернем модуле <code>customer</code>.</p>
<h3 id="Создание-идиоматических-путей-с-use"><a class="header" href="#Создание-идиоматических-путей-с-use">Создание идиоматических путей с <code>use</code></a></h3>
<p>В Листинге 7-11 вы могли задаться вопросом, почему мы указали <code>use crate::front_of_house::hosting</code>, а затем вызвали <code>hosting::add_to_waitlist</code> внутри <code>eat_at_restaurant</code> вместо указания в <code>use</code> полного пути прямо до функции <code>add_to_waitlist</code> для получения того же результата, что в Листинге 7-13.</p>
<Listing number="7-13" file-name="src/lib.rs" caption="Bringing the `add_to_waitlist` function into scope with `use`, which is unidiomatic">
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
}</code></pre>
</Listing>
<p>Хотя Листинги 7-11 и 7-13 выполняют одну и ту же задачу, Листинг 7-11 является идиоматическим способом подключения функции в область видимости с помощью <code>use</code>. Подключение родительского модуля функции в область видимости при помощи <code>use</code> означает, что мы должны указывать родительский модуль при вызове функции. Указание родительского модуля при вызове функции даёт понять, что функция не определена локально, но в то же время сводя к минимуму повторение полного пути. В коде Листинга 7-13 не ясно, где именно определена <code>add_to_waitlist</code>.</p>
<p>С другой стороны, при подключении структур, перечислений и других элементов использованием <code>use</code>, идиоматически правильным будет указывать полный путь. Листинг 7-14 показывает идиоматический способ подключения структуры стандартной библиотеки <code>HashMap</code> в область видимости бинарного крейта.</p>
<Listing number="7-14" file-name="src/main.rs" caption="Bringing `HashMap` into scope in an idiomatic way">
<pre><pre class="playground"><code class="language-rust edition2024">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}</code></pre></pre>
</Listing>
<p>There’s no strong reason behind this idiom: It’s just the convention that has emerged, and folks have gotten used to reading and writing Rust code this way.</p>
<p>Исключением из этой идиомы является случай, когда мы подключаем два элемента с одинаковыми именами в область видимости используя инструкцию <code>use</code> — Rust просто не позволяет этого сделать. Листинг 7-15 показывает, как подключить в область действия два типа с одинаковыми именами <code>Result</code>, но из разных родительских модулей, и как на них ссылаться.</p>
<Listing number="7-15" file-name="src/lib.rs" caption="Bringing two types with the same name into the same scope requires using their parent modules.">
<pre><code class="language-rust noplayground">use std::fmt;
use std::io;

fn function1() -&gt; fmt::Result {
    // --код сокращён--
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; io::Result&lt;()&gt; {
    // --код сокращён--
<span class="boring">    Ok(())
</span>}</code></pre>
</Listing>
<p>Как видите, использование имени родительских модулей позволяет различать два типа <code>Result</code>. Если бы вместо этого мы указали <code>use std::fmt::Result</code> и <code>use std::io::Result</code>, мы бы имели два типа <code>Result</code> в одной области видимости, и Rust не смог бы понять какой из двух <code>Result</code> мы имели в виду, когда нашёл бы их употребление в коде.</p>
<h3 id="Предоставление-новых-имён-с-помощью-ключевого-слова-as"><a class="header" href="#Предоставление-новых-имён-с-помощью-ключевого-слова-as">Предоставление новых имён с помощью ключевого слова <code>as</code></a></h3>
<p>There’s another solution to the problem of bringing two types of the same name into the same scope with <code>use</code>: After the path, we can specify <code>as</code> and a new local name, or <em>alias</em>, for the type. Listing 7-16 shows another way to write the code in Listing 7-15 by renaming one of the two <code>Result</code> types using <code>as</code>.</p>
<Listing number="7-16" file-name="src/lib.rs" caption="Renaming a type when it’s brought into scope with the `as` keyword">
<pre><code class="language-rust noplayground">use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -&gt; Result {
    // --код сокращён--
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; IoResult&lt;()&gt; {
    // --код сокращён--
<span class="boring">    Ok(())
</span>}</code></pre>
</Listing>
<p>Во второй инструкции <code>use</code> мы выбрали новое имя <code>IoResult</code> для типа <code>std::io::Result</code>, которое теперь не будет конфликтовать с типом <code>Result</code> из <code>std::fmt</code>, который также подключён в область видимости. Оба Листинга 7-15 и 7-16 считаются идиоматичными, так что выбор за вами!</p>
<h3 id="Реэкспорт-имён-с-pub-use"><a class="header" href="#Реэкспорт-имён-с-pub-use">Реэкспорт имён с <code>pub use</code></a></h3>
<p>When we bring a name into scope with the <code>use</code> keyword, the name is private to the scope into which we imported it. To enable code outside that scope to refer to that name as if it had been defined in that scope, we can combine <code>pub</code> and <code>use</code>. This technique is called <em>re-exporting</em> because we’re bringing an item into scope but also making that item available for others to bring into their scope.</p>
<p>Листинг 7-17 показывает код из Листинга 7-11, где <code>use</code> в корневом модуле заменено на <code>pub use</code>.</p>
<Listing number="7-17" file-name="src/lib.rs" caption="Making a name available for any code to use from a new scope with `pub use`">
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}</code></pre>
</Listing>
<p>До этого изменения внешний код должен был вызывать функцию <code>add_to_waitlist</code>, используя путь <code>restaurant::front_of_house::hosting::add_to_waitlist()</code>. Теперь, поскольку это объявление <code>pub use</code> реэкспортировало модуль <code>hosting</code> из корневого модуля, внешний код теперь может использовать вместо него путь <code>restaurant::hosting::add_to_waitlist()</code>.</p>
<p>Re-exporting is useful when the internal structure of your code is different from how programmers calling your code would think about the domain. For example, in this restaurant metaphor, the people running the restaurant think about “front of house” and “back of house.” But customers visiting a restaurant probably won’t think about the parts of the restaurant in those terms. With <code>pub use</code>, we can write our code with one structure but expose a different structure. Doing so makes our library well organized for programmers working on the library and programmers calling the library. We’ll look at another example of <code>pub use</code> and how it affects your crate’s documentation in <a href="ch14-02-publishing-to-crates-io.html#exporting-a-convenient-public-api">“Exporting a Convenient Public API”</a><!-- ignore --> in Chapter 14.</p>
<h3 id="Использование-внешних-пакетов"><a class="header" href="#Использование-внешних-пакетов">Использование внешних пакетов</a></h3>
<p>В Главе 2 мы запрограммировали игру в угадайку, где использовался внешний пакет с именем <code>rand</code> для генерации случайного числа. Чтобы использовать <code>rand</code> в нашем проекте, мы добавили эту строку в <em>Cargo.toml</em>.</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch02-00-guessing-game-tutorial.md
* ch14-03-cargo-workspaces.md
-->
<Listing file-name="Cargo.toml">
<pre><code class="language-toml">rand = "0.8.5"
</code></pre>
</Listing>
<p>Добавление rand в качестве зависимости в <em>Cargo.toml</em> указывает Cargo загрузить пакет <code>rand</code> и все его зависимости с <a href="https://crates.io/">crates.io</a> и сделать <code>rand</code> доступным для нашего проекта.</p>
<p>Затем, чтобы подключить определения <code>rand</code> в область видимости нашего пакета, мы добавили строку <code>use</code>, начинающуюся с названия пакета <code>rand</code> и списка элементов, которые мы хотим подключить в область видимости. Напомним, что в разделе <a href="ch02-00-guessing-game-tutorial.html#%D0%93%D0%B5%D0%BD%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8F-%D1%81%D0%B5%D0%BA%D1%80%D0%B5%D1%82%D0%BD%D0%BE%D0%B3%D0%BE-%D1%87%D0%B8%D1%81%D0%BB%D0%B0">"Генерация секретного числа"</a><!-- ignore -->Главы 2 мы подключили трейт <code>Rng</code> в область видимости и вызвали функцию <code>rand::thread_rng</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span>use rand::Rng;

fn main() {
<span class="boring">    println!("Угадайте число!");
</span><span class="boring">
</span>    let secret_number = rand::thread_rng().gen_range(1..=100);
<span class="boring">
</span><span class="boring">    println!("Загаданное число: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Введите свою догадку.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Не удалось прочесть ввод.");
</span><span class="boring">
</span><span class="boring">    println!("Вы предположили: {guess}");
</span>}</code></pre>
<p>Участники Сообщества Rust создали множество пакетов, доступных на <a href="https://crates.io/">crates.io</a>, и добавление любого из них в ваш пакет включает в себя одни и те же шаги: нужно перечислить их в файле <em>Cargo.toml</em> вашего пакета и использовать <code>use</code> для подключения элементов внешних пакетов в область видимости.</p>
<p>Обратите внимание, что стандартная библиотека <code>std</code> также является крейтом, внешним по отношению к нашему пакету. Поскольку стандартная библиотека поставляется с языком Rust, нам не нужно изменять <em>Cargo.toml</em> для подключения <code>std</code>. Но нам нужно ссылаться на неё при помощи <code>use</code>, чтобы добавить элементы оттуда в область видимости нашего пакета. Например, с <code>HashMap</code> мы использовали бы эту строку:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
<span class="boring">}</span></code></pre></pre>
<p>Это абсолютный путь, начинающийся с <code>std</code>, имени крейта стандартной библиотеки.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="using-nested-paths-to-clean-up-large-use-lists"></a></p>
<h3 id="using-nested-paths-to-clean-up-use-lists"><a class="header" href="#using-nested-paths-to-clean-up-use-lists">Using Nested Paths to Clean Up <code>use</code> Lists</a></h3>
<p>Если мы используем несколько элементов, определённых в одном крейте или в том же модуле, то перечисление каждого элемента в отдельной строке может занимать много вертикального пространства в файле. Например, эти две инструкции <code>use</code> используются в нашей игре в угадайку (Листинг 2-4) для подключения элементов из <code>std</code> в область видимости:</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// --код сокращён--
use std::cmp::Ordering;
use std::io;
// --код сокращён--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Угадайте число!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("Загаданное число: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Введите свою догадку.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Не удалось прочесть ввод.");
</span><span class="boring">
</span><span class="boring">    println!("Вы предположили: {guess}");
</span><span class="boring">
</span><span class="boring">    match guess.cmp(&amp;secret_number) {
</span><span class="boring">        Ordering::Less =&gt; println!("Слишком маленькое!"),
</span><span class="boring">        Ordering::Greater =&gt; println!("Слишком большое!"),
</span><span class="boring">        Ordering::Equal =&gt; println!("Вы победили!"),
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>Вместо этого, мы можем использовать перечисление путей, чтобы добавить эти элементы в область видимости одной строкой. Это делается, как показано в Листинге 7-18: указывается общая часть пути, за которой следуют два двоеточия, а затем фигурные скобки вокруг списка тех частей пути, которые отличаются.</p>
<Listing number="7-18" file-name="src/main.rs" caption="Specifying a nested path to bring multiple items with the same prefix into scope">
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// --код сокращён--
use std::{cmp::Ordering, io};
// --код сокращён--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("Угадайте число!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("Загаданное число: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!("Введите свою догадку.");
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("Не удалось прочесть ввод.");
</span><span class="boring">
</span><span class="boring">    let guess: u32 = guess.trim().parse().expect("Пожалуйста, введите число!");
</span><span class="boring">
</span><span class="boring">    println!("Вы предположили: {guess}");
</span><span class="boring">
</span><span class="boring">    match guess.cmp(&amp;secret_number) {
</span><span class="boring">        Ordering::Less =&gt; println!("Слишком маленькое!"),
</span><span class="boring">        Ordering::Greater =&gt; println!("Слишком большое!"),
</span><span class="boring">        Ordering::Equal =&gt; println!("Вы победили!"),
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>В больших программах, подключение множества элементов из одного пакета или модуля с использованием перечисления путей может значительно сократить количество необходимых отдельных инструкций <code>use</code>!</p>
<p>Использовать перечисление путей можно на любом уровне, что полезно при объединении двух инструкций <code>use</code>, которые имеют общую часть пути. Например, в Листинге 7-19 показаны две инструкции <code>use</code>: одна в область видимости подключает <code>std::io</code>, а другая — <code>std::io::Write</code>.</p>
<Listing number="7-19" file-name="src/lib.rs" caption="Two `use` statements where one is a subpath of the other">
<pre><code class="language-rust noplayground">use std::io;
use std::io::Write;</code></pre>
</Listing>
<p>Общей частью этих двух путей является <code>std::io</code>, и это полный первый путь. Чтобы объединить эти два пути в одной инструкции <code>use</code>, мы можем использовать ключевое слово <code>self</code> в перечислении путей, как показано в Листинге 7-20.</p>
<Listing number="7-20" file-name="src/lib.rs" caption="Combining the paths in Listing 7-19 into one `use` statement">
<pre><code class="language-rust noplayground">use std::io::{self, Write};</code></pre>
</Listing>
<p>Эта строка подключает <code>std::io</code> и <code>std::io::Write</code> в область видимости.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="the-glob-operator"></a></p>
<h3 id="importing-items-with-the-glob-operator"><a class="header" href="#importing-items-with-the-glob-operator">Importing Items with the Glob Operator</a></h3>
<p>If we want to bring <em>all</em> public items defined in a path into scope, we can specify that path followed by the <code>*</code> glob operator:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::*;
<span class="boring">}</span></code></pre></pre>
<p>This <code>use</code> statement brings all public items defined in <code>std::collections</code> into the current scope. Be careful when using the glob operator! Glob can make it harder to tell what names are in scope and where a name used in your program was defined. Additionally, if the dependency changes its definitions, what you’ve imported changes as well, which may lead to compiler errors when you upgrade the dependency if the dependency adds a definition with the same name as a definition of yours in the same scope, for example.</p>
<p>The glob operator is often used when testing to bring everything under test into the <code>tests</code> module; we’ll talk about that in <a href="ch11-01-writing-tests.html#how-to-write-tests">“How to Write Tests”</a><!-- ignore --> in Chapter 11. The glob operator is also sometimes used as part of the prelude pattern: See <a href="../std/prelude/index.html#other-preludes">the standard library documentation</a><!-- ignore --> for more information on that pattern.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch07-05-separating-modules-into-different-files.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch07-05-separating-modules-into-different-files.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
