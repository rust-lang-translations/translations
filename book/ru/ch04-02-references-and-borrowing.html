<!DOCTYPE HTML>
<html lang="ru" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Ссылки и заимствование - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch04-02-references-and-borrowing.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch04-02-references-and-borrowing.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ru");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Ссылки-и-заимствование"><a class="header" href="#Ссылки-и-заимствование">Ссылки и заимствование</a></h2>
<p>Проблема с решением из Листинга 4-5 заключается в том, что мы должны возвращать <code>String</code> обратно из вызванной функции, чтобы использовать <code>String</code> после вызова <code>calculate_length</code>, потому что <code>String</code> перемещается в <code>calculate_length</code>. Вместо этого мы можем передавать значение <code>String</code> по ссылке. Ссылка похожа на указатель в том смысле, что она является адресом, по которому мы можем проследовать, чтобы получить доступ к данным, хранящимся по этому адресу; эти данные принадлежат какой-то другой переменной. В отличие от указателя, ссылка гарантирует, что данные, к которым по ней можно обратиться, действительны всё время жизни ссылки.</p>
<p>Вот как вы могли бы определить и использовать функцию <code>calculate_length</code>, принимающую как параметр ссылку, а не прямо получающую владение над значением:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&amp;s1);

    println!("Длина '{s1}' равна {len}.");
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}</code></pre></pre>
</Listing>
<p>Во-первых, мы теперь возвращаем не кортеж, а только необходимое нам значение длины. Во-вторых, обратите внимание, что мы передаём <code>&amp;s1</code> в <code>calculate_length</code> и в её сигнатуре используем <code>&amp;String</code>, а не <code>String</code>. Имена с амперсандами представляют собой <em>ссылки</em> — они позволяют вам ссылаться на некоторое значение, не принимая владение над ними. Рисунок 4-5 показывает, как это следует представлять.</p>
<p><img alt="Три таблицы: таблица s содержит только указатель на таблицу
s1. Таблица s1 содержит данные на стеке строки s1 и указывает на
текстовые данные в куче." src="img/trpl04-06.svg" class="center" /></p>
<p><span class="caption">Рисунок 4-6: Схема строения <code>&amp;String s</code>, указывающей на <code>String s1</code></span></p>
<blockquote>
<p>Примечание: Противоположностью взятия ссылки с оператором <code>&amp;</code> является <em>разыменование</em>, выполняемое с помощью оператора разыменования <code>*</code>. Мы увидим некоторые варианты использования оператора разыменования в Главе 8 и обсудим детали этого процесса в Главе 15.</p>
</blockquote>
<p>Давайте подробнее рассмотрим, как нам вызвать нашу функцию:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");

    let len = calculate_length(&amp;s1);
<span class="boring">
</span><span class="boring">    println!("Длина '{s1}' равна {len}.");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn calculate_length(s: &amp;String) -&gt; usize {
</span><span class="boring">    s.len()
</span><span class="boring">}</span></code></pre></pre>
<p><code>&amp;s1</code> создаёт ссылку, которая ссылается на значение <code>s1</code>, но не владеет им. Поскольку она не владеет им, значение, на которое она указывает, не будет удалено, когда ссылка будет удалена.</p>
<p>Аналогично, в сигнатуре функции используется <code>&amp;</code> для указания на то, что тип параметра <code>s</code> является ссылкой.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    let s1 = String::from("hello");
</span><span class="boring">
</span><span class="boring">    let len = calculate_length(&amp;s1);
</span><span class="boring">
</span><span class="boring">    println!("Длина '{s1}' равна {len}.");
</span><span class="boring">}
</span><span class="boring">
</span>fn calculate_length(s: &amp;String) -&gt; usize { // s — ссылка на String
    s.len()
} // Здесь s входит в область видимости. Но поскольку s не владеет тем, на что
  // ссылается, значение не удаляется.</code></pre></pre>
<p>Область видимости <code>s</code> такая же, как и область видимости любого параметра функции, но значение, на которое указывает ссылка, не удаляется, когда <code>s</code> перестаёт использоваться, потому что <code>s</code> не является его владельцем. Если функция принимает ссылки (а не фактические значения) в качестве параметров, нам не нужно возвращать значения, чтобы обратно получить над ними владение, потому что мы и не передаём владение функции.</p>
<p>Мы называем процесс создания ссылки <em>заимствованием</em>. Как и в реальной жизни, если человек чем-то владеет, вы можете это у него позаимствовать. Когда вы закончите, вы должны вернуть заимствованное законному владельцу: вы не становитесь владельцем.</p>
<p>А что произойдёт, если попытаться изменить заимствованные данные? Попробуйте запустить код из Листинга 4-6: ничего не выйдет!</p>
<Listing number="4-6" file-name="src/main.rs" caption="Attempting to modify a borrowed value">
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let s = String::from("hello");

    change(&amp;s);
}

fn change(some_string: &amp;String) {
    some_string.push_str(", world");
}</code></pre>
</Listing>
<p>Вот ошибка:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference
 --&gt; src/main.rs:8:5
  |
8 |     some_string.push_str(", world");
  |     ^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable
  |
help: consider changing this to be a mutable reference
  |
7 | fn change(some_string: &amp;mut String) {
  |                         +++

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>Как и переменные, ссылки по умолчанию неизменяемы. Мы не можем поменять значение по ссылке.</p>
<h3 id="Изменяемые-ссылки"><a class="header" href="#Изменяемые-ссылки">Изменяемые ссылки</a></h3>
<p>Мы можем исправить код из Листинга 4-6, чтобы позволить себе изменять заимствованное значение: внеся небольшие правки, мы можем получить <em>изменяемую ссылку</em>:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut s = String::from("hello");

    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(", world");
}</code></pre></pre>
</Listing>
<p>Во-первых, мы меняем объявление <code>s</code>, чтобы сделать её <code>mut</code>. Затем мы создаём изменяемую ссылку с помощью <code>&amp;mut s</code> и передаём её функции <code>change</code>. Во-вторых, мы соответственно обновляем сигнатуру функции, чтобы мочь принять изменяемую ссылку: <code>some_string: &amp;mut String</code>. Это даёт понимать, что <code>change</code> может изменять значение, которое заимствует.</p>
<p>Изменяемые ссылки имеют одно большое ограничительное правило: если у вас есть изменяемая ссылка на значение, у вас не может быть других ссылок на это же значение. Код, который пытается создать две изменяемые ссылки на <code>s</code>, не скомпилируется:</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    println!("{}, {}", r1, r2);
<span class="boring">}</span></code></pre>
</Listing>
<p>Вот ошибка:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; src/main.rs:5:14
  |
4 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 |
7 |     println!("{}, {}", r1, r2);
  |                        -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>Эта ошибка говорит о том, что код некорректен, потому что мы не можем одновременно иметь две ссылки на <code>s</code> с правом изменения. Первое изменяемое заимствование находится в <code>r1</code> и должно существовать до тех пор, пока оно не будет использовано в <code>println!</code>, но между созданием этой изменяемой ссылки и её использованием мы попытались создать другую изменяемую ссылку, которая заимствует те же данные, что и <code>r1</code>, и записать её в <code>r2</code>.</p>
<p>The restriction preventing multiple mutable references to the same data at the same time allows for mutation but in a very controlled fashion. It’s something that new Rustaceans struggle with because most languages let you mutate whenever you’d like. The benefit of having this restriction is that Rust can prevent data races at compile time. A <em>data race</em> is similar to a race condition and happens when these three behaviors occur:</p>
<ul>
<li>Два или больше указателей одновременно имеют доступ к одной и той же памяти.</li>
<li>Хотя бы один из указателей используется для записи в память.</li>
<li>Нет механизма синхронизации их доступа к памяти.</li>
</ul>
<p>Гонки данных вызывают неопределённое поведение, и их может быть сложно диагностировать и исправить, когда вы пытаетесь отследить их во время работы программы. Rust предотвращает такую проблему, отказываясь компилировать код с гонками данных.</p>
<p>Как и всегда, мы можем использовать фигурные скобки для создания новой области видимости, позволяющей использовать несколько изменяемых ссылок, но не <em>одновременно</em>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    {
        let r1 = &amp;mut s;
    } // здесь r1 покидает область видимости, так что мы можем без проблем создать новую ссылку.

    let r2 = &amp;mut s;
<span class="boring">}</span></code></pre></pre>
<p>В Rust действует аналогичное правило для случаев использования нескольких изменяемых и неизменяемых ссылок. Этот код не скомпилируется:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    let r1 = &amp;s; // всё хорошо
    let r2 = &amp;s; // всё хорошо
    let r3 = &amp;mut s; // ВСЁ ПЛОХО

    println!("{}, {} и {}", r1, r2, r3);
<span class="boring">}</span></code></pre>
<p>Вот ошибка:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:14
  |
4 |     let r1 = &amp;s; // всё хорошо
  |              -- immutable borrow occurs here
5 |     let r2 = &amp;s; // всё хорошо
6 |     let r3 = &amp;mut s; // ВСЁ ПЛОХО
  |              ^^^^^^ mutable borrow occurs here
7 |
8 |     println!("{}, {} и {}", r1, r2, r3);
  |                                -- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>Да. Мы, <em>в том числе</em>, не можем иметь изменяемую ссылку, пока у нас действительна неизменяемая ссылка на то же значение.</p>
<p>Дело в том, что пользователи неизменяемой ссылки не ожидают, что значение внезапно изменится у них под носом! Однако, множественные неизменяемые ссылки разрешены: никто, кто просто читает данные, не может повлиять на чтение данных кем-либо ещё.</p>
<p>Обратите внимание, что область видимости ссылки начинается с того места, где она создаётся, и продолжается до последнего использования этой ссылки. Например, этот код будет компилироваться, потому что после макроса <code>println!</code> неизменяемые ссылки больше не будут использоваться, и у нас не будет одновременно используемых изменяемых и неизменяемых ссылок:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    let r1 = &amp;s; // всё хорошо
    let r2 = &amp;s; // всё хорошо
    println!("{r1} и {r2}");
    // Переменные r1 и r2 далее не используются.

    let r3 = &amp;mut s; // всё хорошо
    println!("{r3}");
<span class="boring">}</span></code></pre></pre>
<p>Области видимости неизменяемых ссылок <code>r1</code> и <code>r2</code> заканчиваются после <code>println!</code>, то есть до создания изменяемой ссылки <code>r3</code>. Эти области не пересекаются, поэтому этот код допустим: компилятор может сказать, что ссылка больше не используется в точке перед концом области видимости.</p>
<p>Несмотря на то, что ошибки заимствования иногда могут вогнать во фрустрацию, помните, что компилятор Rust заранее (во время компиляции, а не во время исполнения) определяет потенциальную ошибку и точно показывает, в чём проблема. Эти правила и их проверки освобождают вас от мучительного поиска причин того, в какой момент и почему меняются нужные вам данные.</p>
<h3 id="Висячие-ссылки"><a class="header" href="#Висячие-ссылки">Висячие ссылки</a></h3>
<p>В языках с указателями весьма легко ошибочно создать "висячую" ссылку — ссылку, указывающую на участок памяти, который был освобождён. Компилятор Rust гарантирует, что ссылки никогда не будут недействительными: если у вас есть ссылка на какие-то данные, компилятор обеспечит, что эти данные не покинут области видимости прежде, чем из области видимости исчезнет ссылка.</p>
<p>Давайте попробуем создать висячую ссылку, чтобы увидеть, как Rust предотвращает их появление — сразу на этапе компиляции:</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from("hello");

    &amp;s
}</code></pre>
</Listing>
<p>Вот ошибка:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:5:16
  |
5 | fn dangle() -&gt; &amp;String {
  |                ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime, but this is uncommon unless you're returning a borrowed value from a `const` or a `static`
  |
5 | fn dangle() -&gt; &amp;'static String {
  |                 +++++++
help: instead, you are more likely to want to return an owned value
  |
5 - fn dangle() -&gt; &amp;String {
5 + fn dangle() -&gt; String {
  |

error[E0515]: cannot return reference to local variable `s`
 --&gt; src/main.rs:8:5
  |
8 |     &amp;s
  |     ^^ returns a reference to data owned by the current function

Some errors have detailed explanations: E0106, E0515.
For more information about an error, try `rustc --explain E0106`.
error: could not compile `ownership` (bin "ownership") due to 2 previous errors
</code></pre>
<p>Это сообщение об ошибке относится к особенности языка, которую мы ещё не рассмотрели: "времена жизни". Мы подробно обсудим времена жизни в Главе 10. Но даже если не обращать внимание на строки об ошибках о времени жизни, всё равно можно заметить самую главную ошибку:</p>
<pre><code class="language-text">this function's return type contains a borrowed value, but there is no value
for it to be borrowed from
</code></pre>
<p>Давайте подробнее рассмотрим, что происходит на каждом этапе нашего примера:</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let reference_to_nothing = dangle();
</span><span class="boring">}
</span><span class="boring">
</span>fn dangle() -&gt; &amp;String { // dangle возвращает ссылку на String

    let s = String::from("hello"); // в s записывается новое значение типа String

    &amp;s // мы возвращаем ссылку s на значение типа String
} // Здесь s покидает область видимости, и её память высвобождается
  // Беда!</code></pre>
</Listing>
<p>Поскольку <code>s</code> создаётся внутри <code>dangle</code>, то когда тело <code>dangle</code> закончится, <code>s</code> будет освобождена. Но мы попытались вернуть ссылку на неё. Это означает, что эта ссылка будет указывать на недействительную String. Это, очевидно, проблема! Однако Rust нас от неё защищает.</p>
<p>Решением будет вернуть непосредственно само значение <code>String</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    let string = no_dangle();
</span><span class="boring">}
</span><span class="boring">
</span>fn no_dangle() -&gt; String {
    let s = String::from("hello");

    s
}</code></pre></pre>
<p>Это работает без изъянов. Владение перемещается, и ничего не высвобождается.</p>
<h3 id="Правила-работы-ссылок"><a class="header" href="#Правила-работы-ссылок">Правила работы ссылок</a></h3>
<p>Давайте повторим все, что мы узнали о ссылках:</p>
<ul>
<li>В любой момент времени вы можете иметь <em>либо</em> а) одну изменяемую ссылку, <em>либо</em> б) неограниченно много неизменяемых ссылок.</li>
<li>Значение должно существовать дольше, чем любая ссылка, которая на него указывает.</li>
</ul>
<p>В следующем разделе мы рассмотрим другой тип ссылок — срезы.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch04-01-what-is-ownership.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch04-03-slices.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch04-01-what-is-ownership.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch04-03-slices.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
