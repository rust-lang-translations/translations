<!DOCTYPE HTML>
<html lang="ru" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Ссылки и заимствование - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch04-02-references-and-borrowing.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch04-02-references-and-borrowing.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ru");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Ссылки-и-заимствование"><a class="header" href="#Ссылки-и-заимствование">Ссылки и заимствование</a></h2>
<p>The issue with the tuple code in Listing 4-5 is that we have to return the <code>String</code> to the calling function so that we can still use the <code>String</code> after the call to <code>calculate_length</code>, because the <code>String</code> was moved into <code>calculate_length</code>. Instead, we can provide a reference to the <code>String</code> value. A reference is like a pointer in that it’s an address we can follow to access the data stored at that address; that data is owned by some other variable. Unlike a pointer, a reference is guaranteed to point to a valid value of a particular type for the life of that reference.</p>
<p>Вот как вы могли бы определить и использовать функцию <code>calculate_length</code>, принимающую как параметр ссылку, а не прямо получающую владение над значением:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&amp;s1);

    println!("Длина '{s1}' равна {len}.");
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}</code></pre></pre>
</Listing>
<p>First, notice that all the tuple code in the variable declaration and the function return value is gone. Second, note that we pass <code>&amp;s1</code> into <code>calculate_length</code> and, in its definition, we take <code>&amp;String</code> rather than <code>String</code>. These ampersands represent references, and they allow you to refer to some value without taking ownership of it. Figure 4-6 depicts this concept.</p>
<p><img alt="Три таблицы: таблица s содержит только указатель на таблицу
s1. Таблица s1 содержит данные на стеке строки s1 и указывает на
текстовые данные в куче." src="img/trpl04-06.svg" class="center" /></p>
<p><span class="caption">Figure 4-6: A diagram of <code>&amp;String</code> <code>s</code> pointing at <code>String</code> <code>s1</code></span></p>
<blockquote>
<p>Примечание: Противоположностью взятия ссылки с оператором <code>&amp;</code> является <em>разыменование</em>, выполняемое с помощью оператора разыменования <code>*</code>. Мы увидим некоторые варианты использования оператора разыменования в Главе 8 и обсудим детали этого процесса в Главе 15.</p>
</blockquote>
<p>Давайте подробнее рассмотрим, как нам вызвать нашу функцию:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");

    let len = calculate_length(&amp;s1);
<span class="boring">
</span><span class="boring">    println!("Длина '{s1}' равна {len}.");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn calculate_length(s: &amp;String) -&gt; usize {
</span><span class="boring">    s.len()
</span><span class="boring">}</span></code></pre></pre>
<p><code>&amp;s1</code> создаёт ссылку, которая ссылается на значение <code>s1</code>, но не владеет им. Поскольку она не владеет им, значение, на которое она указывает, не будет удалено, когда ссылка будет удалена.</p>
<p>Аналогично, в сигнатуре функции используется <code>&amp;</code> для указания на то, что тип параметра <code>s</code> является ссылкой.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    let s1 = String::from("hello");
</span><span class="boring">
</span><span class="boring">    let len = calculate_length(&amp;s1);
</span><span class="boring">
</span><span class="boring">    println!("Длина '{s1}' равна {len}.");
</span><span class="boring">}
</span><span class="boring">
</span>fn calculate_length(s: &amp;String) -&gt; usize { // s — ссылка на String
    s.len()
} // Here, s goes out of scope. But because s does not have ownership of what
  // it refers to, the String is not dropped.</code></pre></pre>
<p>Область видимости <code>s</code> такая же, как и область видимости любого параметра функции, но значение, на которое указывает ссылка, не удаляется, когда <code>s</code> перестаёт использоваться, потому что <code>s</code> не является его владельцем. Если функция принимает ссылки (а не фактические значения) в качестве параметров, нам не нужно возвращать значения, чтобы обратно получить над ними владение, потому что мы и не передаём владение функции.</p>
<p>Мы называем процесс создания ссылки <em>заимствованием</em>. Как и в реальной жизни, если человек чем-то владеет, вы можете это у него позаимствовать. Когда вы закончите, вы должны вернуть заимствованное законному владельцу: вы не становитесь владельцем.</p>
<p>So, what happens if we try to modify something we’re borrowing? Try the code in Listing 4-6. Spoiler alert: It doesn’t work!</p>
<Listing number="4-6" file-name="src/main.rs" caption="Attempting to modify a borrowed value">
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let s = String::from("hello");

    change(&amp;s);
}

fn change(some_string: &amp;String) {
    some_string.push_str(", world");
}</code></pre>
</Listing>
<p>Вот ошибка:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference
 --&gt; src/main.rs:8:5
  |
8 |     some_string.push_str(", world");
  |     ^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable
  |
help: consider changing this to be a mutable reference
  |
7 | fn change(some_string: &amp;mut String) {
  |                         +++

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>Как и переменные, ссылки по умолчанию неизменяемы. Мы не можем поменять значение по ссылке.</p>
<h3 id="Изменяемые-ссылки"><a class="header" href="#Изменяемые-ссылки">Изменяемые ссылки</a></h3>
<p>Мы можем исправить код из Листинга 4-6, чтобы позволить себе изменять заимствованное значение: внеся небольшие правки, мы можем получить <em>изменяемую ссылку</em>:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let mut s = String::from("hello");

    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(", world");
}</code></pre></pre>
</Listing>
<p>First, we change <code>s</code> to be <code>mut</code>. Then, we create a mutable reference with <code>&amp;mut s</code> where we call the <code>change</code> function and update the function signature to accept a mutable reference with <code>some_string: &amp;mut String</code>. This makes it very clear that the <code>change</code> function will mutate the value it borrows.</p>
<p>Mutable references have one big restriction: If you have a mutable reference to a value, you can have no other references to that value. This code that attempts to create two mutable references to <code>s</code> will fail:</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    println!("{r1}, {r2}");
<span class="boring">}</span></code></pre>
</Listing>
<p>Вот ошибка:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; src/main.rs:5:14
  |
4 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 |
7 |     println!("{r1}, {r2}");
  |                -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>Эта ошибка говорит о том, что код некорректен, потому что мы не можем одновременно иметь две ссылки на <code>s</code> с правом изменения. Первое изменяемое заимствование находится в <code>r1</code> и должно существовать до тех пор, пока оно не будет использовано в <code>println!</code>, но между созданием этой изменяемой ссылки и её использованием мы попытались создать другую изменяемую ссылку, которая заимствует те же данные, что и <code>r1</code>, и записать её в <code>r2</code>.</p>
<p>The restriction preventing multiple mutable references to the same data at the same time allows for mutation but in a very controlled fashion. It’s something that new Rustaceans struggle with because most languages let you mutate whenever you’d like. The benefit of having this restriction is that Rust can prevent data races at compile time. A <em>data race</em> is similar to a race condition and happens when these three behaviors occur:</p>
<ul>
<li>Два или больше указателей одновременно имеют доступ к одной и той же памяти.</li>
<li>Хотя бы один из указателей используется для записи в память.</li>
<li>Нет механизма синхронизации их доступа к памяти.</li>
</ul>
<p>Гонки данных вызывают неопределённое поведение, и их может быть сложно диагностировать и исправить, когда вы пытаетесь отследить их во время работы программы. Rust предотвращает такую проблему, отказываясь компилировать код с гонками данных.</p>
<p>Как и всегда, мы можем использовать фигурные скобки для создания новой области видимости, позволяющей использовать несколько изменяемых ссылок, но не <em>одновременно</em>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    {
        let r1 = &amp;mut s;
    } // здесь r1 покидает область видимости, так что мы можем без проблем создать новую ссылку.

    let r2 = &amp;mut s;
<span class="boring">}</span></code></pre></pre>
<p>В Rust действует аналогичное правило для случаев использования нескольких изменяемых и неизменяемых ссылок. Этот код не скомпилируется:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    let r1 = &amp;s; // всё хорошо
    let r2 = &amp;s; // всё хорошо
    let r3 = &amp;mut s; // ВСЁ ПЛОХО

    println!("{r1}, {r2}, and {r3}");
<span class="boring">}</span></code></pre>
<p>Вот ошибка:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:14
  |
4 |     let r1 = &amp;s; // no problem
  |              -- immutable borrow occurs here
5 |     let r2 = &amp;s; // no problem
6 |     let r3 = &amp;mut s; // BIG PROBLEM
  |              ^^^^^^ mutable borrow occurs here
7 |
8 |     println!("{r1}, {r2}, and {r3}");
  |                -- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>Да. Мы, <em>в том числе</em>, не можем иметь изменяемую ссылку, пока у нас действительна неизменяемая ссылка на то же значение.</p>
<p>Дело в том, что пользователи неизменяемой ссылки не ожидают, что значение внезапно изменится у них под носом! Однако, множественные неизменяемые ссылки разрешены: никто, кто просто читает данные, не может повлиять на чтение данных кем-либо ещё.</p>
<p>Обратите внимание, что область видимости ссылки начинается с того места, где она создаётся, и продолжается до последнего использования этой ссылки. Например, этот код будет компилироваться, потому что после макроса <code>println!</code> неизменяемые ссылки больше не будут использоваться, и у нас не будет одновременно используемых изменяемых и неизменяемых ссылок:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    let r1 = &amp;s; // всё хорошо
    let r2 = &amp;s; // всё хорошо
    println!("{r1} и {r2}");
    // Переменные r1 и r2 далее не используются.

    let r3 = &amp;mut s; // всё хорошо
    println!("{r3}");
<span class="boring">}</span></code></pre></pre>
<p>The scopes of the immutable references <code>r1</code> and <code>r2</code> end after the <code>println!</code> where they are last used, which is before the mutable reference <code>r3</code> is created. These scopes don’t overlap, so this code is allowed: The compiler can tell that the reference is no longer being used at a point before the end of the scope.</p>
<p>Even though borrowing errors may be frustrating at times, remember that it’s the Rust compiler pointing out a potential bug early (at compile time rather than at runtime) and showing you exactly where the problem is. Then, you don’t have to track down why your data isn’t what you thought it was.</p>
<h3 id="Висячие-ссылки"><a class="header" href="#Висячие-ссылки">Висячие ссылки</a></h3>
<p>In languages with pointers, it’s easy to erroneously create a <em>dangling pointer</em>—a pointer that references a location in memory that may have been given to someone else—by freeing some memory while preserving a pointer to that memory. In Rust, by contrast, the compiler guarantees that references will never be dangling references: If you have a reference to some data, the compiler will ensure that the data will not go out of scope before the reference to the data does.</p>
<p>Давайте попробуем создать висячую ссылку, чтобы увидеть, как Rust предотвращает их появление — сразу на этапе компиляции:</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from("hello");

    &amp;s
}</code></pre>
</Listing>
<p>Вот ошибка:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:5:16
  |
5 | fn dangle() -&gt; &amp;String {
  |                ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime, but this is uncommon unless you're returning a borrowed value from a `const` or a `static`
  |
5 | fn dangle() -&gt; &amp;'static String {
  |                 +++++++
help: instead, you are more likely to want to return an owned value
  |
5 - fn dangle() -&gt; &amp;String {
5 + fn dangle() -&gt; String {
  |

For more information about this error, try `rustc --explain E0106`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>Это сообщение об ошибке относится к особенности языка, которую мы ещё не рассмотрели: "времена жизни". Мы подробно обсудим времена жизни в Главе 10. Но даже если не обращать внимание на строки об ошибках о времени жизни, всё равно можно заметить самую главную ошибку:</p>
<pre><code class="language-text">this function's return type contains a borrowed value, but there is no value
for it to be borrowed from
</code></pre>
<p>Давайте подробнее рассмотрим, что происходит на каждом этапе нашего примера:</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let reference_to_nothing = dangle();
</span><span class="boring">}
</span><span class="boring">
</span>fn dangle() -&gt; &amp;String { // dangle возвращает ссылку на String

    let s = String::from("hello"); // в s записывается новое значение типа String

    &amp;s // мы возвращаем ссылку s на значение типа String
} // Here, s goes out of scope and is dropped, so its memory goes away.
  // Danger!</code></pre>
</Listing>
<p>Поскольку <code>s</code> создаётся внутри <code>dangle</code>, то когда тело <code>dangle</code> закончится, <code>s</code> будет освобождена. Но мы попытались вернуть ссылку на неё. Это означает, что эта ссылка будет указывать на недействительную String. Это, очевидно, проблема! Однако Rust нас от неё защищает.</p>
<p>Решением будет вернуть непосредственно само значение <code>String</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    let string = no_dangle();
</span><span class="boring">}
</span><span class="boring">
</span>fn no_dangle() -&gt; String {
    let s = String::from("hello");

    s
}</code></pre></pre>
<p>Это работает без изъянов. Владение перемещается, и ничего не высвобождается.</p>
<h3 id="Правила-работы-ссылок"><a class="header" href="#Правила-работы-ссылок">Правила работы ссылок</a></h3>
<p>Давайте повторим все, что мы узнали о ссылках:</p>
<ul>
<li>В любой момент времени вы можете иметь <em>либо</em> а) одну изменяемую ссылку, <em>либо</em> б) неограниченно много неизменяемых ссылок.</li>
<li>Значение должно существовать дольше, чем любая ссылка, которая на него указывает.</li>
</ul>
<p>В следующем разделе мы рассмотрим другой тип ссылок — срезы.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch04-01-what-is-ownership.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch04-03-slices.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch04-01-what-is-ownership.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch04-03-slices.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
