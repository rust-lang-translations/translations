<!DOCTYPE HTML>
<html lang="ru" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Хранение пар ключ-значение с помощью хеш-таблиц - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch08-03-hash-maps.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch08-03-hash-maps.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ru");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Хранение-пар-ключ-значение-с-помощью-хеш-таблиц"><a class="header" href="#Хранение-пар-ключ-значение-с-помощью-хеш-таблиц">Хранение пар ключ-значение с помощью хеш-таблиц</a></h2>
<p>Последней коллекцией, которую мы рассмотрим, будет хеш-таблица. Тип <code>HashMap&lt;K, V&gt;</code> хранит ключи типа <code>K</code> ко значениям типа <code>V</code>, используя <em>функцию хеширования</em>. Во множестве языков программирования есть данная структура, но часто она по-разному называется: hash_, <em>map</em>, <em>object</em>, <em>словарь</em> или <em>ассоциативный массив</em>.</p>
<p>Хеш-таблицы полезны, когда нужно искать данные, используя не индекс (как в случае с векторами), а ключ, который может быть любого типа. Например, в игре вы можете сохранять счёт каждой команды в хеш-таблице, в которой каждый ключ — это название команды, а значение — её счёт. Имея имя команды, вы можете получить её счёт из хеш-таблицы.</p>
<p>В этом разделе мы рассмотрим лишь основной API хеш-таблиц, но стандартная библиотека содержит ещё очень много полезного для <code>HashMap&lt;K, V&gt;</code>. Как и прежде, советуем обращаться к документации стандартной библиотеки для получения дополнительной информации.</p>
<h3 id="Создание-хеш-таблицы"><a class="header" href="#Создание-хеш-таблицы">Создание хеш-таблицы</a></h3>
<p>One way to create an empty hash map is to use <code>new</code> and to add elements with <code>insert</code>. In Listing 8-20, we’re keeping track of the scores of two teams whose names are <em>Blue</em> and <em>Yellow</em>. The Blue team starts with 10 points, and the Yellow team starts with 50.</p>
<Listing number="8-20" caption="Creating a new hash map and inserting some keys and values">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Синяя"), 10);
    scores.insert(String::from("Жёлтая"), 50);
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>Обратите внимание, что сначала нужно подключить <code>HashMap</code> из стандартной библиотеки с помощью <code>use</code>. Из трёх коллекций данная является наименее используемой, поэтому она не входит в функционал, по умолчанию подключаемый к области видимости (коротко говоря, в prelude). Хеш-таблицы также слабее поддерживаются стандартной библиотекой; например, нет встроенного макроса для их конструирования.</p>
<p>Подобно векторам, хеш-таблицы хранят свои данные в куче. Здесь тип <code>HashMap</code> имеет в качестве типа ключей <code>String</code>, а в качестве типа значений — <code>i32</code>. Как и векторы, <code>HashMap</code> однородны: все ключи должны иметь одинаковый тип, и все значения тоже должны иметь одинаковый тип.</p>
<h3 id="Получение-данных-из-хеш-таблицы"><a class="header" href="#Получение-данных-из-хеш-таблицы">Получение данных из хеш-таблицы</a></h3>
<p>Мы можем получить значение из хеш-таблицы, использовав метод <code>get</code> и передав ему ключ, как показано в Листинге 8-21.</p>
<Listing number="8-21" caption="Accessing the score for the Blue team stored in the hash map">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Синяя"), 10);
    scores.insert(String::from("Жёлтая"), 50);

    let team_name = String::from("Синяя");
    let score = scores.get(&amp;team_name).copied().unwrap_or(0);
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>Здесь в <code>score</code> будет количество очков синей команды — <code>10</code>. Метод <code>get</code> возвращает <code>Option&lt;&amp;V&gt;</code>; если для какого-то ключа в хеш-таблице нет значения, <code>get</code> вернёт <code>None</code>. Из-за такого подхода программе следует обрабатывать <code>Option</code>, вызывая <code>copied</code> для получения <code>Option&lt;i32&gt;</code> вместо <code>Option&lt;&amp;i32&gt;</code>, затем <code>unwrap_or</code> для установки <code>score</code> в ноль, если <code>scores</code> не содержит данных по этому ключу.</p>
<p>Мы можем перебирать каждую пару ключ-значение в хеш-таблице таким же образом, как мы делали с векторами, воспользовавшись циклом <code>for</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Синяя"), 10);
    scores.insert(String::from("Жёлтая"), 50);

    for (key, value) in &amp;scores {
        println!("{key}: {value}");
    }
<span class="boring">}</span></code></pre></pre>
<p>Этот код будет выведет каждую пару в произвольном порядке:</p>
<pre><code class="language-text">Yellow: 50
Blue: 10
</code></pre>
<h3 id="Хеш-таблицы-и-владение"><a class="header" href="#Хеш-таблицы-и-владение">Хеш-таблицы и владение</a></h3>
<p>Для типов, которые реализуют трейт <code>Copy</code> (например, <code>i32</code>), значения копируются в хеш-таблицу. Для владеемых значений, таких как <code>String</code>, значения будут перемещены в хеш-таблицу и она станет владельцем этих значений, что показано в Листинге 8-22.</p>
<Listing number="8-22" caption="Showing that keys and values are owned by the hash map once they’re inserted">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let field_name = String::from("Любимая команда:");
    let field_value = String::from("Синяя");

    let mut map = HashMap::new();
    map.insert(field_name, field_value);
    // field_name и field_value отсюда и далее недоступны. Но вы попробуйте использовать
    // их и посмотрите, что за ошибку компиляции получите!
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>Мы не можем использовать переменные <code>field_name</code> и <code>field_value</code> после того, как их значения были перемещены в хеш-таблицу вызовом метода <code>insert</code>.</p>
<p>Если мы вставим в хеш-таблицу ссылки на значения, то значения не будут перемещены в хеш-таблицу. Значения, на которые указывают ссылки, должны быть действительными как минимум пока действительна хеш-таблица. Мы поговорим подробнее об этих вопросах в разделе <a href="ch10-03-lifetime-syntax.html#%D0%92%D0%B0%D0%BB%D0%B8%D0%B4%D0%B0%D1%86%D0%B8%D1%8F-%D1%81%D1%81%D1%8B%D0%BB%D0%BE%D0%BA-%D0%BF%D0%BE-%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%B8-%D0%B6%D0%B8%D0%B7%D0%BD%D0%B8">"Валидация ссылок по времени жизни"</a><!-- ignore --> Главы 10.</p>
<h3 id="Обновление-данных-в-хеш-таблице"><a class="header" href="#Обновление-данных-в-хеш-таблице">Обновление данных в хеш-таблице</a></h3>
<p>Хотя количество ключей и значений в хеш-таблице может быть изменено, каждый ключ в один момент может иметь только одно значение (обратное утверждение неверно: команды "Синяя" и "Жёлтая" могут хранить в хеш-таблице <code>scores</code> одинаковое количество очков: например, <code>10</code>).</p>
<p>Если вы хотите изменить данные в хеш-таблице, необходимо решить, как обрабатывать случай, когда ключ уже имеет связанное значение. Можно заменить старое значение новым, полностью проигнорировав старое. Можно сохранить старое значение и проигнорировать новое, если только в хеш-таблице ещё не было этого ключа. Или можно было бы вычислить на основе старого и нового значений третье. Давайте посмотрим, как реализовать каждый из вариантов!</p>
<h4 id="Перезапись-значения"><a class="header" href="#Перезапись-значения">Перезапись значения</a></h4>
<p>Если мы вставим ключ и значение в хеш-таблицу, а затем вставим такой же ключ с новым значением, то старое значение, связанное с этим ключом, будет заменено на новое. Даже несмотря на то, что код в Листинге 8-23 вызывает <code>insert</code> дважды, хеш-таблица будет содержать только одну пару ключ-значение, потому что мы вставляем значения для одного и того же ключа — ключа синей команды.</p>
<Listing number="8-23" caption="Replacing a value stored with a particular key">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Синяя"), 10);
    scores.insert(String::from("Синяя"), 25);

    println!("{scores:?}");
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>Код напечатает <code>{"Синяя": 25}</code>. Начальное значение <code>10</code> было перезаписано.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="only-inserting-a-value-if-the-key-has-no-value"></a></p>
<h4 id="Вставка-значения-только-в-том-случае-если-ключ-вводится-впервые"><a class="header" href="#Вставка-значения-только-в-том-случае-если-ключ-вводится-впервые">Вставка значения только в том случае, если ключ вводится впервые</a></h4>
<p>Обычно проверяют, существует ли конкретный ключ в хеш-таблице, приписано ли ему какое-либо значение, а затем предпринимаются следующие действия: если ключ в хеш-таблице есть, то существующее значение должно оставаться таким, какое оно есть. Если же ключ отсутствует, то вставляют его и его значение.</p>
<p>Хеш-таблицы имеют для этого специальный метод <code>entry</code>, который принимает ключ, наличие которого нужно проверить. Возвращаемое значение метода <code>entry</code> — это перечисление <code>Entry</code>, представляющего значение, которое может как присутствовать, так и отсутствовать. Допустим, мы хотим проверить, имеется ли ключ и связанное с ним значение для жёлтой команды. Если хеш-таблица не имеет значения для такого ключа, то мы хотим вставить значение <code>50</code>. То же самое мы хотим проделать и для синей команды. Использование <code>entry</code> показано в коде Листинга 8-24.</p>
<Listing number="8-24" caption="Using the `entry` method to only insert if the key does not already have a value">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();
    scores.insert(String::from("Синяя"), 10);

    scores.entry(String::from("Жёлтая")).or_insert(50);
    scores.entry(String::from("Синяя")).or_insert(50);

    println!("{scores:?}");
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>Метод <code>or_insert</code> определён в <code>Entry</code> так, чтобы возвращать изменяемую ссылку на соответствующее значение ключа внутри варианта перечисления <code>Entry</code>, когда этот ключ существует, а если его нет, то вставлять параметр в качестве нового значения этого ключа и возвращать изменяемую ссылку на новое значение. Эта техника намного чище, чем самостоятельное написание логики и, кроме того, она более безопасна и согласуется с правилами заимствования.</p>
<p>При выполнении кода Листинга 8-24 будет напечатано <code>{"Жёлтая": 50, "Синяя": 10}</code>. Первый вызов метода <code>entry</code> вставит ключ со значением <code>50</code> для жёлтой команды, потому что для жёлтой команды ещё не имеется значения в хеш-таблице. Второй вызов <code>entry</code> не изменит хеш-таблицу, потому что для ключа синей команды уже имеется значение <code>10</code>.</p>
<h4 id="Обновление-значения-на-основе-старого-значения"><a class="header" href="#Обновление-значения-на-основе-старого-значения">Обновление значения на основе старого значения</a></h4>
<p>Другим распространённым вариантом использования хеш-таблиц является поиск значения по ключу, а затем обновление этого значения на основе старого значения. Например, в Листинге 8-25 показан код, который подсчитывает, сколько раз определённое слово встречается в некотором тексте. Мы используем хеш-таблицу со словами в качестве ключей и увеличиваем соответствующий слову счётчик, чтобы отслеживать, сколько раз мы встретили это слово. Если мы впервые встретили слово, то сначала вставляем значение <code>0</code>.</p>
<Listing number="8-25" caption="Counting occurrences of words using a hash map that stores words and counts">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let text = "hello world wonderful world";

    let mut map = HashMap::new();

    for word in text.split_whitespace() {
        let count = map.entry(word).or_insert(0);
        *count += 1;
    }

    println!("{map:?}");
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>Этот код напечатает <code>{"world": 2, "hello": 1, "wonderful": 1}</code>. Если вы увидите, что пары ключ-значение печатаются в другом порядке, то вспомните, что в разделе <a href="#%D0%9F%D0%BE%D0%BB%D1%83%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%B8%D0%B7-%D1%85%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%8B">"Получение данных из хеш-таблицы"</a><!-- ignore --> мы писали, что итерация по хеш-таблице происходит в произвольном порядке.</p>
<p>Метод <code>split_whitespace</code>, выполненный на <code>text</code>, возвращает итератор по подсрезам строки, разделённым пробелами. Метод <code>or_insert</code> возвращает изменяемую ссылку (<code>&amp;mut V</code>) на значение ключа. Мы сохраняем изменяемую ссылку в переменной <code>count</code>, поэтому чтобы присвоить переменной значение, необходимо разыменовать <code>count</code> с помощью звёздочки (<code>*</code>). Изменяемая ссылка удаляется сразу же после выхода из области видимости цикла <code>for</code>, поэтому все эти изменения безопасны и согласуются с правилами заимствования.</p>
<h3 id="Функции-хеширования"><a class="header" href="#Функции-хеширования">Функции хеширования</a></h3>
<p>По умолчанию <code>HashMap</code> использует функцию хеширования <em>SipHash</em>, которая может противостоять атакам класса Denial of Service (DoS) с использованием хеш-таблиц<sup class="footnote-reference"><a href="#siphash">1</a></sup><!-- ignore -->. Это не самый быстрый из возможных алгоритмов хеширования, но в данном случае производительность идёт на компромисс с обеспечением лучшей безопасности. Если после профилирования вашего кода окажется, что хеш-функция, используемая по умолчанию, очень медленная, вы можете заменить её используя другой хешер. <em>Хешер</em> — это тип, реализующий трейт <code>BuildHasher</code>. Подробнее о трейтах мы поговорим в <a href="ch10-02-traits.html">Главе 10</a><!-- ignore -->. Вам совсем не обязательно реализовывать свою собственную функцию хеширования; на <a href="https://crates.io/">crates.io</a><!-- ignore --> есть достаточное количество библиотек, предоставляющих разные реализации хешеров с множеством общих алгоритмов хеширования.</p>
<div class="footnote-definition" id="siphash"><sup class="footnote-definition-label">1</sup>
<p><a href="https://en.wikipedia.org/wiki/SipHash">https://en.wikipedia.org/wiki/SipHash</a></p>
</div>
<h2 id="Подведём-итоги"><a class="header" href="#Подведём-итоги">Подведём итоги</a></h2>
<p>Векторы, строки и хеш-таблицы предоставят большое количество функционала для программ, когда необходимо сохранять, извлекать и модифицировать данные. Теперь вы готовы решить следующие учебные задания:</p>
<ol>
<li>Дан список целых чисел. Использовав вектор, напишите функции получения медианы (значение элемента из середины списка после его сортировки) и моды (наиболее частое значение; подсказка: используйте хеш-таблицы) списка чисел.</li>
<li>Переведите текст с английского на поросячью латынь. Первая согласная каждого слова перемещается в конец и к ней добавляется окончание <em>ay</em> (пример: <em>first</em> станет <em>irst-fay</em>). К слову, начинающемуся на гласную, в конец добавляется <em>hay</em> (пример: <em>apple</em> становится <em>apple-hay</em>). Помните о деталях работы с кодировкой UTF-8!</li>
<li>Используя хеш-таблицу и векторы, создайте текстовый интерфейс, позволяющий пользователю приписывать сотрудников по их именам к отделам компании. Например, <code>Add Sally to Engineering</code> или <code>Add Amir to Sales</code>. Затем позвольте пользователю получить список всех людей из отдела или всех людей в компании, отсортированный по отделам в алфавитном порядке.</li>
</ol>
<p>Документация API стандартной библиотеки содержит описания методов векторов, строк и хеш-таблиц. Рекомендуем пользоваться ей при решении упражнений!</p>
<p>Потихоньку мы переходим к более сложным программам, в которых операции могут потерпеть неудачу. Наступил идеальный момент для обсуждения обработки ошибок.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch08-02-strings.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch09-00-error-handling.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch08-02-strings.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch09-00-error-handling.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
