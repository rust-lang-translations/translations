<!DOCTYPE HTML>
<html lang="ru" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Обобщённые типы данных - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch10-01-syntax.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch10-01-syntax.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ru");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Обобщённые-типы-данных"><a class="header" href="#Обобщённые-типы-данных">Обобщённые типы данных</a></h2>
<p>Мы используем обобщения в, например, сигнатурах функций и структурах, которые затем можно использовать с различными конкретными типами данных. Сначала мы посмотрим, как объявлять функции, структуры, перечисления и методы, используя обобщения. Затем мы обсудим, как обобщения влияют на производительность кода.</p>
<h3 id="В-определениях-функций"><a class="header" href="#В-определениях-функций">В определениях функций</a></h3>
<p>Когда мы объявляем функцию с обобщёнными типами, мы размещаем обобщённые типы в сигнатуре функции там, где мы обычно указываем типы данных параметров и возвращаемого значения. Используя обобщённые типы, мы делаем код более гибким и предоставляем большую функциональность при вызове нашей функции, предотвращая дублирование кода.</p>
<p>Рассмотрим пример с нашей функцией <code>largest</code>. Листинг 10-4 показывает две функции, каждая из которых находит самое большое значение в срезе своего типа. Позже мы объединим их в одну функцию, использующую обобщённые типы данных.</p>
<Listing number="10-4" file-name="src/main.rs" caption="Two functions that differ only in their names and in the types in their signatures">
<pre><pre class="playground"><code class="language-rust edition2021">fn largest_i32(list: &amp;[i32]) -&gt; &amp;i32 {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &amp;[char]) -&gt; &amp;char {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&amp;number_list);
    println!("Наибольшее число: {result}");
<span class="boring">    assert_eq!(*result, 100);
</span>
    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&amp;char_list);
    println!("Наибольший символ: {result}");
<span class="boring">    assert_eq!(*result, 'y');
</span>}</code></pre></pre>
</Listing>
<p>Функция <code>largest_i32</code> уже встречалась нам: мы извлекли её в Листинге 10-3, когда боролись с дублированием кода; она находит наибольшее значение типа <code>i32</code> в срезе. Функция <code>largest_char</code> находит самое большое значение типа <code>char</code> в срезе. Тело у этих функций одинаковое, поэтому давайте избавимся от дублируемого кода, используя параметр обобщённого типа в одной функции.</p>
<p>Для параметризации типов данных в новой объявляемой функции нам нужно дать имя обобщённому типу — так же, как мы это делаем для аргументов функций. Можно использовать любой идентификатор для имени параметра типа, но мы будем использовать <code>T</code>, потому что по соглашению имена параметров типов в Rust должны быть короткими (обычно длиной в один символ), а именование типов в Rust делается в нотации <code>UpperCamelCase</code>. Сокращение слова <em>type</em> до одной буквы <code>T</code> является стандартным выбором большинства программистов.</p>
<p>Когда мы используем параметр в теле функции, мы должны объявить имя параметра в сигнатуре, чтобы компилятор знал, что означает это имя. Аналогично, когда мы используем имя типа параметра в сигнатуре функции, мы должны объявить это имя раньше, чем мы его используем. Чтобы определить обобщённую функцию <code>largest</code>, поместим объявление имён параметров в угловые скобки <code>&lt;&gt;</code> между именем функции и списком параметров, как здесь:</p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {</code></pre>
<p>Объявление читается так: функция <code>largest</code> является обобщённой по типу <code>T</code>. Эта функция имеет один параметр с именем <code>list</code>, который является срезом значений типа <code>T</code>. Функция <code>largest</code> возвращает ссылку на значение этого же типа <code>T</code>.</p>
<p>Листинг 10-5 показывает определение функции <code>largest</code> с использованием обобщённых типов данных в её сигнатуре. Листинг также показывает, как мы можем вызвать функцию со срезом данных типа <code>i32</code> или <code>char</code>. Данный код пока не будет компилироваться, но мы исправим это к концу раздела.</p>
<Listing number="10-5" file-name="src/main.rs" caption="The `largest` function using generic type parameters; this doesn’t compile yet">
<pre><code class="language-rust ignore does_not_compile">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!("Наибольшее число: {result}");

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!("Наибольший символ: {result}");
}</code></pre>
</Listing>
<p>Если мы скомпилируем программу в её текущем виде, мы получим следующую ошибку:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `&amp;T`
 --&gt; src/main.rs:5:17
  |
5 |         if item &gt; largest {
  |            ---- ^ ------- &amp;T
  |            |
  |            &amp;T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; &amp;T {
  |             ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>В подсказке упоминается <em>трейт</em> <code>std::cmp::PartialOrd</code>. Мы поговорим про трейты в следующем разделе. Сейчас ошибка в функции <code>largest</code> указывает, что функция не может работать для всех возможных типов <code>T</code>. Так как мы хотим сравнивать значения типа <code>T</code> в теле функции, мы можем использовать только те типы, данные которых можно упорядочить. Реализация возможности сравнения реализуется трейтом <code>std::cmp::PartialOrd</code> стандартной библиотеки, который вы можете реализовать для типов (больше информации об этом трейте можно узнать в Приложении C). Следуя совету в сообщении компилятора, ограничим тип <code>T</code> теми вариантами, которые поддерживают трейт <code>PartialOrd</code>, и теперь пример успешно скомпилируется, так как стандартная библиотека реализует <code>PartialOrd</code> как для <code>i32</code>, так и для <code>char</code>.</p>
<h3 id="В-определениях-структур"><a class="header" href="#В-определениях-структур">В определениях структур</a></h3>
<p>Мы также можем определить структуры, использующие обобщённые типы в одном или нескольких своих полях, с помощью синтаксиса <code>&lt;&gt;</code>. Листинг 10-6 показывает, как определить структуру <code>Point&lt;T&gt;</code>, чтобы хранить поля координат <code>x</code> и <code>y</code> любого типа данных.</p>
<Listing number="10-6" file-name="src/main.rs" caption="A `Point<T>` struct that holds `x` and `y` values of type `T`">
<pre><pre class="playground"><code class="language-rust edition2021">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}</code></pre></pre>
</Listing>
<p>Синтаксис использования обобщённых типов в определении структуры очень похож на синтаксис в определении функции. Сначала мы объявляем имена типов параметров внутри угловых скобок сразу после названия структуры, а затем мы используем обобщённые типы в определении структуры в тех местах, где ранее мы указывали бы конкретные типы.</p>
<p>Так как мы используем только один обобщённый тип данных для определения структуры <code>Point&lt;T&gt;</code>, это определение означает, что структура <code>Point&lt;T&gt;</code> является обобщённой по типу <code>T</code>, и оба поля <code>x</code> и <code>y</code> имеют <em>одинаковый</em> тип, каким бы он ни являлся. Если мы создадим экземпляр структуры <code>Point&lt;T&gt;</code> со значениями разных типов, как показано в Листинге 10-7, наш код не скомпилируется.</p>
<Listing number="10-7" file-name="src/main.rs" caption="The fields `x` and `y` must be the same type because both have the same generic data type `T`.">
<pre><code class="language-rust ignore does_not_compile">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}</code></pre>
</Listing>
<p>В этом примере, когда мы присваиваем целочисленное значение <code>5</code> переменной <code>x</code>, мы сообщаем компилятору, что обобщённый тип <code>T</code> будет целым числом для этого экземпляра <code>Point&lt;T&gt;</code>. Затем, когда мы указываем значение <code>4.0</code> для <code>y</code>, который по нашему определению должен иметь тот же тип, что и <code>x</code>, мы получаем ошибку несоответствия типов:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-point number

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>Чтобы определить структуру <code>Point</code>, где оба значения <code>x</code> и <code>y</code> являются обобщёнными, но различными типами, можно использовать несколько параметров обобщённого типа. Например, в Листинге 10-8 мы изменили определение <code>Point</code> таким образом, чтобы оно использовало обобщённые типы <code>T</code> и <code>U</code>, где <code>x</code> имеет тип <code>T</code>, а <code>y</code> — тип <code>U</code>.</p>
<Listing number="10-8" file-name="src/main.rs" caption="A `Point<T, U>` generic over two types so that `x` and `y` can be values of different types">
<pre><pre class="playground"><code class="language-rust edition2021">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}</code></pre></pre>
</Listing>
<p>Теперь разрешены все показанные экземпляры типа <code>Point</code>! В объявлении можно использовать сколь угодно много параметров обобщённого типа, но если делать это в большом количестве, код будет тяжело читать. Если в вашем коде требуется много обобщённых типов, возможно, стоит разбить его на более мелкие части.</p>
<h3 id="В-определениях-перечислений"><a class="header" href="#В-определениях-перечислений">В определениях перечислений</a></h3>
<p>Как и структуры, перечисления также могут хранить данные обобщённых типов в своих вариантах. Давайте ещё раз посмотрим на перечисление <code>Option&lt;T&gt;</code>, определённое стандартной библиотекой, которое мы использовали в Главе 6:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}</span></code></pre></pre>
<p>Сейчас это определение должно быть вам ясным. Как видите, перечисление <code>Option&lt;T&gt;</code> обобщено по типу <code>T</code> и имеет два варианта: вариант <code>Some</code>, который содержит одно значение типа <code>T</code>, и вариант <code>None</code>, который не содержит никакого значения. Используя перечисление <code>Option&lt;T&gt;</code>, можно выразить абстрактную концепцию необязательного значения — и так как <code>Option&lt;T&gt;</code> является обобщённым, можно использовать эту абстракцию независимо от того, каким будет тип необязательного значения.</p>
<p>Перечисления тоже могут использовать несколько обобщённых типов. Определениеперечисления <code>Result</code>, которое мы использовали в Главе 9 — хороший пример:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p>Перечисление <code>Result</code> обобщено по двум типам — <code>T</code> и <code>E</code> — и имеет два варианта: <code>Ok</code>, который содержит значение типа <code>T</code>, и <code>Err</code>, содержащий значение типа <code>E</code>. С таким определением удобно использовать перечисление <code>Result</code> везде, где операции могут быть выполнены успешно (возвращая значение типа <code>T</code>) или неуспешно (возвращая ошибку типа <code>E</code>). Это то, что мы делали при открытии файла в Листинге 9-3, где <code>T</code> заменялось типом <code>std::fs::File</code>, если файл был открыт успешно, и <code>E</code> заменялось типом <code>std::io::Error</code>, если при открытии файла возникали какие-либо проблемы.</p>
<p>Если вы встречаете в коде ситуации, когда несколько определений структур или перечислений отличаются только типами содержащихся в них значений, вы можете устранить дублирование, используя обобщённые типы.</p>
<h3 id="В-определении-методов"><a class="header" href="#В-определении-методов">В определении методов</a></h3>
<p>Мы можем реализовать методы для структур и перечислений (как мы сделали в Главе 5) и в определениях этих методов тоже использовать обобщённые типы. В Листинге 10-9 показана структура <code>Point&lt;T&gt;</code>, которую мы определили в Листинге 10-6, с реализованным для неё методом <code>x</code>.</p>
<Listing number="10-9" file-name="src/main.rs" caption="Implementing a method named `x` on the `Point<T>` struct that will return a reference to the `x` field of type `T`">
<pre><pre class="playground"><code class="language-rust edition2021">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}</code></pre></pre>
</Listing>
<p>Здесь мы определили метод <code>x</code> на структуре <code>Point&lt;T&gt;</code>, который возвращает ссылку на данные в поле <code>x</code>.</p>
<p>Обратите внимание, что мы должны объявить <code>T</code> сразу после <code>impl</code>, чтобы мы могли использовать <code>T</code> для указания на то, что мы реализуем методы для типа <code>Point&lt;T&gt;</code>. Объявив <code>T</code> универсальным типом сразу после <code>impl</code>, Rust может определить, что тип в угловых скобках в Point является обобщённым, а не конкретным типом. Мы могли бы выбрать другое имя для этого обобщённого параметра, отличное от имени, использованного в определении структуры, но обычно используют одно и то же имя. Методы, написанные внутри раздела <code>impl</code>, который использует обобщённый тип, будут определены для любого экземпляра типа, независимо от того, какой конкретный тип в конечном итоге будет подставлен вместо обобщённого.</p>
<p>Мы можем также указать ограничения на то, какие обобщённые типы разрешено использовать при определении методов. Например, мы могли бы реализовать методы только для экземпляров типа <code>Point&lt;f32&gt;</code>, а не для экземпляров <code>Point&lt;T&gt;</code>, в которых используется произвольный обобщённый тип. В Листинге 10-10 мы используем конкретный тип <code>f32</code>, для чего нам не требуется указывать никакие типы типы после <code>impl</code>.</p>
<Listing number="10-10" file-name="src/main.rs" caption="An `impl` block that only applies to a struct with a particular concrete type for the generic type parameter `T`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct Point&lt;T&gt; {
</span><span class="boring">    x: T,
</span><span class="boring">    y: T,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Point&lt;T&gt; {
</span><span class="boring">    fn x(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.x
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 5, y: 10 };
</span><span class="boring">
</span><span class="boring">    println!("p.x = {}", p.x());
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>Этот код означает, что тип <code>Point&lt;f32&gt;</code> будет иметь метод <code>distance_from_origin</code>, а другие экземпляры <code>Point&lt;T&gt;</code> (где <code>T</code> — тип, отличный от <code>f32</code>) не будут иметь этого метода. Метод вычисляет, насколько далеко наша точка находится от точки с координатами <code>(0.0, 0.0)</code>, и использует математические операции, доступные только для типов с плавающей точкой.</p>
<p>Параметры обобщённого типа, используемые в определении структуры, не обязательно совпадают с параметрами, которые вы используете в сигнатурах методов этой же структуры. Взгляните на Листинг 10-11; в нём используются обобщённые типы <code>X1</code> и <code>Y1</code> для определения структуры <code>Point</code> и типы <code>X2</code> и <code>Y2</code> для сигнатуры метода <code>mixup</code>. Метод создаёт новый экземпляр структуры <code>Point</code>, где значение <code>x</code> берётся из <code>self</code> (имеющей тип <code>X1</code>), а значение <code>y</code> — из переданной структуры <code>Point</code> (имеющей тип <code>Y2</code>).</p>
<Listing number="10-11" file-name="src/main.rs" caption="A method that uses generic types different from its struct’s definition">
<pre><pre class="playground"><code class="language-rust edition2021">struct Point&lt;X1, Y1&gt; {
    x: X1,
    y: Y1,
}

impl&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; {
    fn mixup&lt;X2, Y2&gt;(self, other: Point&lt;X2, Y2&gt;) -&gt; Point&lt;X1, Y2&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c' };

    let p3 = p1.mixup(p2);

    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}</code></pre></pre>
</Listing>
<p>В функции main мы создали <code>Point</code>, который имеет тип <code>x</code> типа <code>i32</code> (со значением <code>5</code>) и <code>y</code> типа <code>f64</code> (со значением <code>10.4</code>). Переменная <code>p2</code> является структурой <code>Point</code>, которая имеет строковый срез <code>x</code> (со значением <code>"Hello"</code>) и символ <code>y</code> типа <code>char</code> (со значением <code>c</code>). Вызов <code>mixup</code> на <code>p1</code> с аргументом <code>p2</code> создаст экземпляр структуры <code>p3</code>, который будет иметь <code>x</code> типа <code>i32</code> (потому что <code>x</code> взят из <code>p1</code>) и <code>y</code> типа <code>char</code> (потому что <code>y</code> взят из <code>p2</code>). Вызов макроса <code>println!</code> выведет <code>p3.x = 5, p3.y = c</code>.</p>
<p>Цель этого примера — продемонстрировать ситуацию, в которой некоторые обобщённые параметры объявлены с помощью <code>impl</code>, а некоторые объявлены с определением метода. Здесь обобщённые параметры <code>X1</code> и <code>Y1</code> объявляются после <code>impl</code>, потому что они относятся к определению структуры. Обобщённые параметры <code>X2</code> и <code>Y2</code> объявляются после <code>fn mixup</code>, так как они относятся только к методу.</p>
<h3 id="Производительность-кода-использующего-обобщённые-типы"><a class="header" href="#Производительность-кода-использующего-обобщённые-типы">Производительность кода, использующего обобщённые типы</a></h3>
<p>Вы могли задаться вопросом о том, не возникают ли какие-нибудь дополнительные издержки при использовании параметров обобщённого типа. Хорошая новость в том, что при использовании обобщённых типов ваша программа работает ничуть ни медленнее, чем если бы она работала с использованием конкретных типов.</p>
<p>В Rust это достигается во время компиляции при помощи мономорфизации кода, использующего обобщённые типы. <em>Мономорфизация</em> — это процесс превращения обобщённого кода в конкретный код путём подстановки конкретных типов, использующихся при компиляции. В этом процессе компилятор выполняет шаги, противоположные тем, которые мы использовали для создания обобщённой функции в Листинге 10-5: компилятор просматривает все места, где вызывается обобщённый код, и генерирует код для конкретных типов, с которыми вызывается обобщённый код.</p>
<p>Давайте посмотрим, как это работает, на примере перечисления обобщённого <code>Option&lt;T&gt;</code> из стандартной библиотеки:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let integer = Some(5);
let float = Some(5.0);
<span class="boring">}</span></code></pre></pre>
<p>Когда Rust компилирует этот код, он выполняет мономорфизацию. Во время этого процесса компилятор смотрит на значения, которые были использованы в экземплярах <code>Option&lt;T&gt;</code>, и определяет два вида <code>Option&lt;T&gt;</code>: один для типа <code>i32</code>, другой — для <code>f64</code>. Таким образом, он разворачивает обобщённое определение <code>Option&lt;T&gt;</code> в два определения, специализированные для <code>i32</code> и <code>f64</code>, тем самым заменяя обобщённое определение конкретными.</p>
<p>Мономорфизированная версия кода выглядит примерно так (компилятор использует имена, отличные от тех, которые мы используем здесь для иллюстрации):</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}</code></pre></pre>
</Listing>
<p>Обобщённый <code>Option&lt;T&gt;</code> заменяется конкретными определениями, созданными компилятором. Поскольку Rust компилирует обобщённый код в код, определяющий тип в каждом экземпляре, мы не платим за использование обобщённых типов во время выполнения. Когда код запускается, он работает точно так же, как если бы мы продублировали каждое определение вручную. Процесс мономорфизации делает обобщённые типы Rust чрезвычайно эффективными во время выполнения.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch10-00-generics.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch10-02-traits.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch10-00-generics.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch10-02-traits.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
