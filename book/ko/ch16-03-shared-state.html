<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>공유 상태 동시성 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch16-03-shared-state.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch16-03-shared-state.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="공유-상태-동시성"><a class="header" href="#공유-상태-동시성">공유 상태 동시성</a></h2>
<p>메시지 전달은 동시성을 처리하는 좋은 방법이지만 유일한 방법은 아닙니다. 또 다른 방법은 여러 스레드가 동일한 공유 데이터에 접근하는 것입니다. Go 언어 문서의 슬로건 중 이 부분을 다시 생각해 보세요: “메모리를 공유하여 통신하지 마십시오.”</p>
<p>메모리 공유를 통한 통신은 어떤 모습일까요? 또한, 메시지 전달 애호가들이 메모리 공유를 사용하지 말라고 경고하는 이유는 무엇일까요?</p>
<p>In a way, channels in any programming language are similar to single ownership, because once you transfer a value down a channel, you should no longer use that value. Shared memory concurrency is like multiple ownership: multiple threads can access the same memory location at the same time. As you saw in Chapter 15, where smart pointers made multiple ownership possible, multiple ownership can add complexity because these different owners need managing. Rust’s type system and ownership rules greatly assist in getting this management correct. For an example, let’s look at mutexes, one of the more common concurrency primitives for shared memory.</p>
<h3 id="뮤텍스를-사용하여-한-번에-한-스레드만-데이터에-접근하도록-허용하기"><a class="header" href="#뮤텍스를-사용하여-한-번에-한-스레드만-데이터에-접근하도록-허용하기">뮤텍스를 사용하여 한 번에 한 스레드만 데이터에 접근하도록 허용하기</a></h3>
<p>_뮤텍스(Mutex)_는 _상호 배제(mutual exclusion)_의 약자로, 뮤텍스는 주어진 시간에 하나의 스레드만 일부 데이터에 접근하도록 허용합니다. 뮤텍스의 데이터에 접근하려면, 스레드는 먼저 뮤텍스의 _잠금(lock)_을 획득하도록 요청하여 접근 권한을 원한다는 신호를 보내야 합니다. 잠금은 현재 누가 데이터에 대한 독점적 접근 권한을 가지고 있는지 추적하는 뮤텍스의 일부인 데이터 구조입니다. 따라서 뮤텍스는 잠금 시스템을 통해 보유하고 있는 데이터를 _보호(guarding)_한다고 설명됩니다.</p>
<p>뮤텍스는 사용하기 어렵다는 평판이 있습니다. 두 가지 규칙을 기억해야 하기 때문입니다:</p>
<ol>
<li>데이터를 사용하기 전에 락 획득을 시도해야 합니다.</li>
<li>뮤텍스가 보호하는 데이터 사용을 마치면, 다른 스레드가 락을 획득할 수 있도록 데이터의 잠금을 해제해야 합니다.</li>
</ol>
<p>For a real-world metaphor for a mutex, imagine a panel discussion at a conference with only one microphone. Before a panelist can speak, they have to ask or signal that they want to use the microphone. When they get the microphone, they can talk for as long as they want to and then hand the microphone to the next panelist who requests to speak. If a panelist forgets to hand the microphone off when they’re finished with it, no one else is able to speak. If management of the shared microphone goes wrong, the panel won’t work as planned!</p>
<p>뮤텍스 관리는 올바르게 수행하기가 믿을 수 없을 정도로 까다로울 수 있으며, 이것이 많은 사람들이 채널에 열광하는 이유입니다. 하지만 러스트의 타입 시스템과 소유권 규칙 덕분에 락과 잠금 해제를 잘못할 수 없습니다.</p>
<h4 id="mutext의-api"><a class="header" href="#mutext의-api"><code>Mutex&lt;T&gt;</code>의 API</a></h4>
<p>뮤텍스 사용법의 예로, 목록 16-12와 같이 단일 스레드 컨텍스트에서 뮤텍스를 사용하는 것으로 시작해 봅시다:</p>
<Listing number="16-12" file-name="src/main.rs" caption="Exploring the API of `Mutex<T>` in a single-threaded context for simplicity">
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!("m = {m:?}");
}</code></pre></pre>
</Listing>
<p>많은 타입들과 마찬가지로, 연관 함수 <code>new</code>를 사용하여 <code>Mutex&lt;T&gt;</code>를 생성합니다. 뮤텍스 내부의 데이터에 접근하기 위해, <code>lock</code> 메서드를 사용하여 락을 얻습니다. 이 호출은 현재 스레드를 차단하여 우리가 락을 가질 차례가 될 때까지 아무런 작업도 수행할 수 없게 합니다.</p>
<p>락을 보유한 다른 스레드가 패닉 상태에 빠지면 <code>lock</code> 호출은 실패할 것입니다. 그런 경우, 아무도 락을 얻을 수 없으므로, 우리는 그러한 상황에서 <code>unwrap</code>을 선택하여 이 스레드를 패닉 상태로 만들었습니다.</p>
<p>락을 얻은 후에는 반환 값(이 경우 <code>num</code>)을 내부 데이터에 대한 가변 참조로 취급할 수 있습니다. 타입 시스템은 <code>m</code>의 값을 사용하기 전에 락을 얻도록 보장합니다. <code>m</code>의 타입은 <code>i32</code>가 아니라 <code>Mutex&lt;i32&gt;</code>이므로, <code>i32</code> 값을 사용하려면 <code>lock</code>을 <em>반드시</em> 호출해야 합니다. 우리는 잊어버릴 수 없습니다; 그렇지 않으면 타입 시스템이 내부 <code>i32</code>에 접근하는 것을 허용하지 않을 것입니다.</p>
<p>As you might suspect, <code>Mutex&lt;T&gt;</code> is a smart pointer. More accurately, the call to <code>lock</code> <em>returns</em> a smart pointer called <code>MutexGuard</code>, wrapped in a <code>LockResult</code> that we handled with the call to <code>unwrap</code>. The <code>MutexGuard</code> smart pointer implements <code>Deref</code> to point at our inner data; the smart pointer also has a <code>Drop</code> implementation that releases the lock automatically when a <code>MutexGuard</code> goes out of scope, which happens at the end of the inner scope. As a result, we don’t risk forgetting to release the lock and blocking the mutex from being used by other threads, because the lock release happens automatically.</p>
<p>락을 드롭한 후 뮤텍스 값을 출력하여 내부 i32를 6으로 변경할 수 있었음을 확인할 수 있습니다.</p>
<h4 id="여러-스레드-간에-mutext-공유하기"><a class="header" href="#여러-스레드-간에-mutext-공유하기">여러 스레드 간에 <code>Mutex&lt;T&gt;</code> 공유하기</a></h4>
<p>이제 Mutex<T>를 사용하여 여러 스레드 간에 값을 공유해 봅시다. 10개의 스레드를 생성하고 각각 카운터 값을 1씩 증가시켜 카운터가 0에서 10이 되도록 할 것입니다. 목록 16-13의 다음 예제는 컴파일러 오류를 발생시킬 것이며, 우리는 그 오류를 사용하여 Mutex<T> 사용법과 러스트가 이를 올바르게 사용하도록 돕는 방법에 대해 더 배울 것입니다.</p>
<Listing number="16-13" file-name="src/main.rs" caption="Ten threads each increment a counter guarded by a `Mutex<T>`">
<pre><code class="language-rust ignore does_not_compile">use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("결과: {}", *counter.lock().unwrap());
}</code></pre>
</Listing>
<p>We create a <code>counter</code> variable to hold an <code>i32</code> inside a <code>Mutex&lt;T&gt;</code>, as we did in Listing 16-12. Next, we create 10 threads by iterating over a range of numbers. We use <code>thread::spawn</code> and give all the threads the same closure: one that moves the counter into the thread, acquires a lock on the <code>Mutex&lt;T&gt;</code> by calling the <code>lock</code> method, and then adds 1 to the value in the mutex. When a thread finishes running its closure, <code>num</code> will go out of scope and release the lock so another thread can acquire it.</p>
<p>메인 스레드에서 우리는 모든 조인 핸들을 수집합니다. 그런 다음 목록 16-2에서 했던 것처럼, 각 핸들에 대해 <code>join</code>을 호출하여 모든 스레드가 종료되었는지 확인합니다. 그 시점에서 메인 스레드는 락을 얻고 이 프로그램의 결과를 출력할 것입니다.</p>
<p>우리는 이 예제가 컴파일되지 않을 것이라고 암시했습니다. 이제 그 이유를 알아봅시다!</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0382]: borrow of moved value: `counter`
  --&gt; src/main.rs:21:29
   |
5  |     let counter = Mutex::new(0);
   |         ------- `counter`는 `Copy` 트레이트를 구현하지 않는 `Mutex&lt;i32&gt;` 타입이므로 이동이 발생합니다
...
8  |     for _ in 0..10 {
   |     -------------- 이 루프 안에서
9  |         let handle = thread::spawn(move || {
   |                                    ------- 여기서 값이 클로저로 이동됨, 루프의 이전 반복에서
...
21 |     println!("Result: {}", *counter.lock().unwrap());
   |                             ^^^^^^^ 이동 후 여기서 값이 대여됨
   |
help: consider moving the expression out of the loop so it is only moved once
   |
8  ~     let mut value = counter.lock();
9  ~     for _ in 0..10 {
10 |         let handle = thread::spawn(move || {
11 ~             let mut num = value.unwrap();
   |

For more information about this error, try `rustc --explain E0382`.
error: could not compile `shared-state` (bin "shared-state") due to 1 previous error
</code></pre>
<p>에러 메시지는 <code>counter</code> 값이 루프의 이전 반복에서 이동되었다고 말합니다. 러스트는 <code>counter</code>의 소유권을 여러 스레드로 이동할 수 없다고 말하고 있습니다. 15장에서 논의했던 다중 소유권 방법으로 컴파일러 에러를 수정해 봅시다.</p>
<h4 id="다중-스레드와-다중-소유권"><a class="header" href="#다중-스레드와-다중-소유권">다중 스레드와 다중 소유권</a></h4>
<p>15장에서 우리는 스마트 포인터 <code>Rc&lt;T&gt;</code>를 사용하여 참조 카운팅 값을 생성함으로써 값에 여러 소유자를 부여했습니다. 여기서도 똑같이 하고 무슨 일이 일어나는지 봅시다. 목록 16-14에서는 <code>Mutex&lt;T&gt;</code>를 <code>Rc&lt;T&gt;</code>로 감싸고, 소유권을 스레드로 이동하기 전에 <code>Rc&lt;T&gt;</code>를 클론할 것입니다.</p>
<Listing number="16-14" file-name="src/main.rs" caption="Attempting to use `Rc<T>` to allow multiple threads to own the `Mutex<T>`">
<pre><code class="language-rust ignore does_not_compile">use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("결과: {}", *counter.lock().unwrap());
}</code></pre>
</Listing>
<p>다시 한번, 컴파일하면… 다른 오류들이 발생합니다! 컴파일러가 우리에게 많은 것을 가르쳐주고 있습니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0277]: `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
   --&gt; src/main.rs:11:36
    |
11  |           let handle = thread::spawn(move || {
    |                        ------------- ^------
    |                        |             |
    |  ______________________|_____________이 `{closure@src/main.rs:11:36: 11:43}` 안에서
    | |                      |
    | |                      이 호출에 의해 도입된 바운드에 의해 요구됨
12  | |             let mut num = counter.lock().unwrap();
13  | |
14  | |             *num += 1;
15  | |         });
    | |_________^ `Rc&lt;Mutex&lt;i32&gt;&gt;`는 스레드 간에 안전하게 보내질 수 없습니다
    |
    = help: within `{closure@src/main.rs:11:36: 11:43}`, the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;`, which is required by `{closure@src/main.rs:11:36: 11:43}: Send`
note: required because it's used within this closure
   --&gt; src/main.rs:11:36
    |
11  |         let handle = thread::spawn(move || {
    |                                    ^^^^^^^
note: required by a bound in `spawn`
   --&gt; file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/std/src/thread/mod.rs:675:8
    |
672 | pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    |        ----- 이 함수의 바운드에 의해 요구됨
...
675 |     F: Send + 'static,
    |        ^^^^ spawn의 이 바운드에 의해 요구됨

For more information about this error, try `rustc --explain E0277`.
error: could not compile `shared-state` (bin "shared-state") due to 1 previous error
</code></pre>
<p>와, 에러 메시지가 정말 장황하네요! 집중해야 할 중요한 부분은 여기 있습니다: <code>`Rc&lt;Mutex&lt;i32&gt;&gt;`는 스레드 간에 안전하게 보내질 수 없습니다</code>. 컴파일러는 또한 그 이유를 말해주고 있습니다: <code>`Rc&lt;Mutex&lt;i32&gt;&gt;`에 대해 `Send` 트레이트가 구현되지 않았습니다</code>. 다음 절에서 <code>Send</code>에 대해 이야기할 것입니다. 이것은 우리가 스레드와 함께 사용하는 타입이 동시성 상황에서 사용되도록 의도되었음을 보장하는 트레이트 중 하나입니다.</p>
<p>불행히도, <code>Rc&lt;T&gt;</code>는 스레드 간에 공유하기에 안전하지 않습니다. <code>Rc&lt;T&gt;</code>가 참조 카운트를 관리할 때, <code>clone</code> 호출마다 카운트를 더하고 각 클론이 드롭될 때 카운트를 뺍니다. 하지만 카운트 변경이 다른 스레드에 의해 중단되지 않도록 보장하기 위한 어떠한 동시성 기본 요소도 사용하지 않습니다. 이는 잘못된 카운트로 이어질 수 있으며, 이는 결과적으로 메모리 누수나 우리가 사용을 마치기 전에 값이 드롭되는 미묘한 버그로 이어질 수 있습니다. 우리에게 필요한 것은 <code>Rc&lt;T&gt;</code>와 똑같지만 스레드 안전한 방식으로 참조 카운트를 변경하는 타입입니다.</p>
<h4 id="arct를-이용한-원자적-참조-카운팅"><a class="header" href="#arct를-이용한-원자적-참조-카운팅"><code>Arc&lt;T&gt;</code>를 이용한 원자적 참조 카운팅</a></h4>
<p>다행히도 <code>Arc&lt;T&gt;</code>는 동시성 상황에서 사용하기에 안전한 <code>Rc&lt;T&gt;</code>와 같은 타입_입니다_. _a_는 <em>atomic</em>(원자적)을 의미하며, 이는 <em>원자적으로 참조 카운팅되는</em> 타입임을 의미합니다. 원자적 요소는 여기서 자세히 다루지 않을 추가적인 종류의 동시성 기본 요소입니다. 자세한 내용은 <a href="../std/sync/atomic/index.html"><code>std::sync::atomic</code></a><!-- ignore -->에 대한 표준 라이브러리 문서를 참조하세요. 지금은 원자적 요소가 기본 타입처럼 작동하지만 스레드 간에 공유하기에 안전하다는 것만 알면 됩니다.</p>
<p>그러면 왜 모든 기본 타입이 원자적이지 않은지, 그리고 왜 표준 라이브러리 타입들이 기본적으로 <code>Arc&lt;T&gt;</code>를 사용하도록 구현되지 않았는지 궁금할 수 있습니다. 그 이유는 스레드 안전성에는 정말 필요할 때만 지불하고 싶은 성능 비용이 따르기 때문입니다. 단일 스레드 내의 값에 대해서만 연산을 수행하는 경우, 원자적 요소가 제공하는 보장을 강제할 필요가 없다면 코드가 더 빠르게 실행될 수 있습니다.</p>
<p>예제로 돌아가 봅시다: <code>Arc&lt;T&gt;</code>와 <code>Rc&lt;T&gt;</code>는 동일한 API를 가지고 있으므로, <code>use</code> 라인, <code>new</code> 호출, 그리고 <code>clone</code> 호출을 변경하여 프로그램을 수정합니다. 목록 16-15의 코드는 마침내 컴파일되고 실행될 것입니다:</p>
<Listing number="16-15" file-name="src/main.rs" caption="Using an `Arc<T>` to wrap the `Mutex<T>` to be able to share ownership across multiple threads">
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("결과: {}", *counter.lock().unwrap());
}</code></pre></pre>
</Listing>
<p>이 코드는 다음을 출력합니다:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Result: 10
</code></pre>
<p>해냈습니다! 0에서 10까지 셌는데, 별로 인상적이지 않아 보일 수도 있지만, <code>Mutex&lt;T&gt;</code>와 스레드 안전성에 대해 많은 것을 가르쳐주었습니다. 카운터를 증가시키는 것보다 더 복잡한 연산을 수행하기 위해 이 프로그램의 구조를 사용할 수도 있습니다. 이 전략을 사용하여 계산을 독립적인 부분으로 나누고, 그 부분들을 스레드에 분산시킨 다음, <code>Mutex&lt;T&gt;</code>를 사용하여 각 스레드가 자신의 부분으로 최종 결과를 업데이트하게 할 수 있습니다.</p>
<p>단순한 숫자 연산을 수행하는 경우, <a href="../std/sync/atomic/index.html">표준 라이브러리의 <code>std::sync::atomic</code> 모듈</a><!-- ignore -->에서 제공하는 <code>Mutex&lt;T&gt;</code> 타입보다 더 간단한 타입들이 있다는 점에 유의하세요. 이 타입들은 기본 타입에 대한 안전하고, 동시적이며, 원자적인 접근을 제공합니다. 우리는 <code>Mutex&lt;T&gt;</code>가 어떻게 작동하는지에 집중하기 위해 이 예제에서 기본 타입과 함께 <code>Mutex&lt;T&gt;</code>를 사용하는 것을 선택했습니다.</p>
<h3 id="refcelltrct와-mutextarct-간의-유사점"><a class="header" href="#refcelltrct와-mutextarct-간의-유사점"><code>RefCell&lt;T&gt;</code>/<code>Rc&lt;T&gt;</code>와 <code>Mutex&lt;T&gt;</code>/<code>Arc&lt;T&gt;</code> 간의 유사점</a></h3>
<p>여러분이 <code>counter</code>가 불변이지만 내부의 값에 대한 가변 참조를 얻을 수 있다는 것을 눈치챘을 수도 있습니다. 이는 <code>Cell</code> 계열이 그러하듯 <code>Mutex&lt;T&gt;</code>가 내부 가변성을 제공한다는 것을 의미합니다. 15장에서 <code>Rc&lt;T&gt;</code> 내부의 내용을 변경할 수 있도록 <code>RefCell&lt;T&gt;</code>를 사용했던 것과 같은 방식으로, <code>Arc&lt;T&gt;</code> 내부의 내용을 변경하기 위해 <code>Mutex&lt;T&gt;</code>를 사용합니다.</p>
<p>주목해야 할 또 다른 세부 사항은 <code>Mutex&lt;T&gt;</code>를 사용할 때 러스트가 모든 종류의 로직 에러로부터 여러분을 보호할 수는 없다는 것입니다. 15장에서 <code>Rc&lt;T&gt;</code>를 사용하는 것이 두 <code>Rc&lt;T&gt;</code> 값이 서로를 참조하여 메모리 누수를 일으키는 참조 순환을 생성할 위험이 있었음을 상기해 보세요. 마찬가지로, <code>Mutex&lt;T&gt;</code>는 _데드락(deadlocks)_을 생성할 위험이 있습니다. 이는 어떤 작업이 두 리소스를 잠가야 하는데 두 스레드가 각각 락 중 하나를 얻어 서로를 영원히 기다리게 될 때 발생합니다. 데드락에 관심이 있다면 데드락이 있는 러스트 프로그램을 만들어 보세요; 그런 다음 어떤 언어로든 뮤텍스에 대한 데드락 완화 전략을 조사하고 러스트에서 구현해 보세요. <code>Mutex&lt;T&gt;</code>와 <code>MutexGuard</code>에 대한 표준 라이브러리 API 문서는 유용한 정보를 제공합니다.</p>
<p><code>Send</code>와 <code>Sync</code> 트레이트 및 이를 커스텀 타입과 함께 사용하는 방법에 대해 이야기하며 이 장을 마무리하겠습니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch16-02-message-passing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch16-04-extensible-concurrency-sync-and-send.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch16-02-message-passing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch16-04-extensible-concurrency-sync-and-send.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
