<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Async로 동시성 적용하기 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch17-02-concurrency-with-async.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch17-02-concurrency-with-async.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="async로-동시성-적용하기"><a class="header" href="#async로-동시성-적용하기">Async로 동시성 적용하기</a></h2>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="concurrency-with-async"></a></p>
<p>이 절에서는 16장에서 스레드로 다루었던 몇 가지 동시성 과제에 비동기를 적용해 볼 것입니다. 거기서 이미 많은 핵심 아이디어에 대해 이야기했으므로, 이 절에서는 스레드와 퓨처 간의 차이점에 초점을 맞출 것입니다.</p>
<p>많은 경우, 비동기를 사용하여 동시성을 다루는 API는 스레드를 사용하는 것과 매우 유사합니다. 다른 경우에는 꽤 다르게 되기도 합니다. 스레드와 비동기 간에 API가 비슷해 <em>보일</em> 때조차도, 종종 다른 동작을 하며 거의 항상 다른 성능 특성을 가집니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="counting"></a></p>
<h3 id="spawn_task로-새로운-태스크-생성하기"><a class="header" href="#spawn_task로-새로운-태스크-생성하기"><code>spawn_task</code>로 새로운 태스크 생성하기</a></h3>
<p><a href="ch16-01-threads.html#creating-a-new-thread-with-spawn">spawn으로 새로운 스레드 생성하기</a><!-- ignore -->에서 처음 다룬 작업은 두 개의 별도 스레드에서 숫자를 세는 것이었습니다. 비동기를 사용하여 동일한 작업을 수행해 봅시다. <code>trpl</code> 크레이트는 <code>thread::spawn</code> API와 매우 유사해 보이는 <code>spawn_task</code> 함수와 <code>thread::sleep</code> API의 비동기 버전인 <code>sleep</code> 함수를 제공합니다. 목록 17-6과 같이 이들을 함께 사용하여 카운팅 예제를 구현할 수 있습니다.</p>
<Listing number="17-6" caption="Creating a new task to print one thing while the main task prints something else" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span>use std::time::Duration;

fn main() {
    trpl::run(async {
        trpl::spawn_task(async {
            for i in 1..10 {
                println!("첫 번째 태스크에서 안녕하세요 숫자 {i}!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        });

        for i in 1..5 {
            println!("두 번째 태스크에서 안녕하세요 숫자 {i}!");
            trpl::sleep(Duration::from_millis(500)).await;
        }
    });
}</code></pre></pre>
</Listing>
<p>시작점으로, 최상위 함수가 비동기가 될 수 있도록 <code>trpl::run</code>으로 <code>main</code> 함수를 설정합니다.</p>
<blockquote>
<p>참고: 이 장의 이 시점부터 모든 예제는 <code>main</code>에 <code>trpl::run</code>이 있는 이와 똑같은 래핑 코드를 포함하므로, <code>main</code>에서처럼 종종 생략할 것입니다. 코드에 포함하는 것을 잊지 마세요!</p>
</blockquote>
<p>그런 다음 그 블록 내에 두 개의 루프를 작성하는데, 각 루프는 다음 메시지를 보내기 전에 0.5초(500 밀리초) 동안 기다리는 <code>trpl::sleep</code> 호출을 포함합니다. 루프 하나는 <code>trpl::spawn_task</code>의 본문에 넣고, 다른 하나는 최상위 <code>for</code> 루프에 넣습니다. 또한 <code>sleep</code> 호출 뒤에 <code>await</code>를 추가합니다.</p>
<p>이 코드는 스레드 기반 구현과 유사하게 동작합니다—실행할 때 터미널에서 메시지가 다른 순서로 나타날 수 있다는 점을 포함해서 말이죠:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the second task!
hi number 1 from the first task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
</code></pre>
<p>이 버전은 메인 비동기 블록 본문의 <code>for</code> 루프가 끝나자마자 중지됩니다. 왜냐하면 <code>main</code> 함수가 끝날 때 <code>spawn_task</code>에 의해 생성된 태스크가 종료되기 때문입니다. 태스크가 완료될 때까지 계속 실행되기를 원한다면, 첫 번째 태스크가 완료되기를 기다리기 위해 조인 핸들을 사용해야 합니다. 스레드에서는 <code>join</code> 메서드를 사용하여 스레드 실행이 끝날 때까지 "차단(block)"했습니다. 목록 17-7에서는 태스크 핸들 자체가 퓨처이기 때문에 <code>await</code>를 사용하여 동일한 작업을 수행할 수 있습니다. 그것의 <code>Output</code> 타입은 <code>Result</code>이므로, 기다린 후에 <code>unwrap</code>도 수행합니다.</p>
<Listing number="17-7" caption="Using `await` with a join handle to run a task to completion" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let handle = trpl::spawn_task(async {
            for i in 1..10 {
                println!("첫 번째 태스크에서 안녕하세요 숫자 {i}!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        });

        for i in 1..5 {
            println!("두 번째 태스크에서 안녕하세요 숫자 {i}!");
            trpl::sleep(Duration::from_millis(500)).await;
        }

        handle.await.unwrap();
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 업데이트된 버전은 <em>두</em> 루프가 모두 끝날 때까지 실행됩니다.</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the second task!
hi number 1 from the first task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
hi number 6 from the first task!
hi number 7 from the first task!
hi number 8 from the first task!
hi number 9 from the first task!
</code></pre>
<p>지금까지는 비동기와 스레드가 기본적으로 동일한 결과를 제공하는 것처럼 보입니다. 단지 문법이 다를 뿐입니다. 조인 핸들에서 <code>join</code>을 호출하는 대신 <code>await</code>를 사용하고, <code>sleep</code> 호출을 기다리는 점이 다릅니다.</p>
<p>The bigger difference is that we didn’t need to spawn another operating system thread to do this. In fact, we don’t even need to spawn a task here. Because async blocks compile to anonymous futures, we can put each loop in an async block and have the runtime run them both to completion using the <code>trpl::join</code> function.</p>
<p><a href="ch16-01-threads.html#waiting-for-all-threads-to-finish-using-join-handles"><code>join</code> 핸들을 사용하여 모든 스레드가 끝나기를 기다리기</a><!-- ignore --> 섹션에서, <code>std::thread::spawn</code>을 호출할 때 반환되는 <code>JoinHandle</code> 타입의 <code>join</code> 메서드를 사용하는 방법을 보여주었습니다. <code>trpl::join</code> 함수는 비슷하지만 퓨처를 위한 것입니다. 두 개의 퓨처를 제공하면, 두 퓨처가 <em>모두</em> 완료되었을 때 전달한 각 퓨처의 출력을 포함하는 튜플을 출력으로 하는 하나의 새로운 퓨처를 생성합니다. 따라서 목록 17-8에서는 <code>trpl::join</code>을 사용하여 <code>fut1</code>과 <code>fut2</code>가 모두 완료되기를 기다립니다. 우리는 <code>fut1</code>과 <code>fut2</code>를 <em>기다리지 않고(await)</em>, 대신 <code>trpl::join</code>에 의해 생성된 새로운 퓨처를 기다립니다. 출력은 두 개의 유닛 값을 포함하는 튜플일 뿐이므로 무시합니다.</p>
<Listing number="17-8" caption="Using `trpl::join` to await two anonymous futures" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let fut1 = async {
            for i in 1..10 {
                println!("첫 번째 태스크에서 안녕하세요 숫자 {i}!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let fut2 = async {
            for i in 1..5 {
                println!("두 번째 태스크에서 안녕하세요 숫자 {i}!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        trpl::join(fut1, fut2).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>이것을 실행하면 두 퓨처가 모두 완료될 때까지 실행되는 것을 볼 수 있습니다:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the first task!
hi number 1 from the second task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
hi number 6 from the first task!
hi number 7 from the first task!
hi number 8 from the first task!
hi number 9 from the first task!
</code></pre>
<p>이제 매번 정확히 같은 순서를 볼 수 있는데, 이는 스레드에서 보았던 것과는 매우 다릅니다. 그 이유는 <code>trpl::join</code> 함수가 _공정(fair)_하기 때문입니다. 즉, 각 퓨처를 동일한 빈도로 확인하고 번갈아 가며 확인하며, 다른 하나가 준비되었는데 하나가 앞서 나가도록 두지 않습니다. 스레드의 경우, 운영 체제가 어떤 스레드를 확인하고 얼마나 오랫동안 실행할지 결정합니다. 비동기 러스트에서는 런타임이 어떤 태스크를 확인할지 결정합니다. (실제로는 비동기 런타임이 동시성을 관리하는 방법의 일부로 내부적으로 운영 체제 스레드를 사용할 수 있기 때문에 세부 사항이 복잡해질 수 있으며, 런타임이 공정성을 보장하는 것은 더 많은 작업이 필요할 수 있습니다. 하지만 여전히 가능합니다!) 런타임은 주어진 작업에 대해 공정성을 보장할 필요가 없으며, 종종 공정성을 원하는지 여부를 선택할 수 있도록 다른 API를 제공합니다.</p>
<p>퓨처를 기다리는 몇 가지 변형을 시도해보고 어떻게 동작하는지 확인해 보세요:</p>
<ul>
<li>루프 중 하나 또는 둘 다에서 비동기 블록을 제거해 보세요.</li>
<li>각 비동기 블록을 정의한 직후에 기다려(await) 보세요.</li>
<li>첫 번째 루프만 비동기 블록으로 감싸고, 두 번째 루프의 본문 뒤에서 결과 퓨처를 기다려 보세요.</li>
</ul>
<p>추가적인 도전 과제로, 코드를 실행하기 <em>전에</em> 각 경우에 출력이 어떻게 될지 알아낼 수 있는지 확인해 보세요!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="message-passing"></a></p>
<h3 id="메시지-전달을-사용하여-두-태스크에서-숫자-세기"><a class="header" href="#메시지-전달을-사용하여-두-태스크에서-숫자-세기">메시지 전달을 사용하여 두 태스크에서 숫자 세기</a></h3>
<p>Sharing data between futures will also be familiar: we’ll use message passing again, but this time with async versions of the types and functions. We’ll take a slightly different path than we did in <a href="ch16-02-message-passing.html">Using Message Passing to Transfer Data Between Threads</a><!-- ignore --> to illustrate some of the key differences between thread-based and futures-based concurrency. In Listing 17-9, we’ll begin with just a single async block—<em>not</em> spawning a separate task as we spawned a separate thread.</p>
<Listing number="17-9" caption="Creating an async channel and assigning the two halves to `tx` and `rx`" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let val = String::from("안녕");
        tx.send(val).unwrap();

        let received = rx.recv().await.unwrap();
        println!("받음: {received}");
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>여기서 우리는 16장에서 스레드와 함께 사용했던 다중 생산자, 단일 소비자 채널 API의 비동기 버전인 <code>trpl::channel</code>을 사용합니다. API의 비동기 버전은 스레드 기반 버전과 조금 다를 뿐입니다: 불변 수신자 <code>rx</code> 대신 가변 수신자를 사용하며, <code>recv</code> 메서드는 값을 직접 생성하는 대신 우리가 기다려야 하는 퓨처를 생성합니다. 이제 우리는 송신자에서 수신자로 메시지를 보낼 수 있습니다. 별도의 스레드나 태스크를 생성할 필요가 없다는 점에 주목하세요; 우리는 단지 <code>rx.recv</code> 호출을 기다리기만 하면 됩니다.</p>
<p><code>std::mpsc::channel</code>의 동기 <code>Receiver::recv</code> 메서드는 메시지를 받을 때까지 차단합니다. <code>trpl::Receiver::recv</code> 메서드는 비동기이므로 그렇지 않습니다. 차단하는 대신, 메시지를 받거나 채널의 송신 측이 닫힐 때까지 제어를 런타임에 다시 넘깁니다. 반면, <code>send</code> 호출은 차단하지 않으므로 기다리지 않습니다. 우리가 보내는 채널이 제한이 없기 때문에(unbounded) 기다릴 필요가 없습니다.</p>
<blockquote>
<p>참고: 이 모든 비동기 코드는 <code>trpl::run</code> 호출 내의 비동기 블록에서 실행되므로, 그 안의 모든 것은 차단을 피할 수 있습니다. 하지만 그 <em>외부의</em> 코드는 <code>run</code> 함수가 반환될 때까지 차단됩니다. 이것이 <code>trpl::run</code> 함수의 핵심입니다. 이것은 일련의 비동기 코드에서 어디서 차단할지, 따라서 동기 코드와 비동기 코드 사이를 어디서 전환할지 _선택_할 수 있게 해줍니다. 대부분의 비동기 런타임에서 <code>run</code>은 정확히 이러한 이유로 실제로 <code>block_on</code>이라는 이름을 가집니다.</p>
</blockquote>
<p>이 예제에서 두 가지 점에 주목하세요. 첫째, 메시지가 즉시 도착할 것입니다. 둘째, 여기서 퓨처를 사용하지만 아직 동시성은 없습니다. 목록의 모든 것은 퓨처가 관련되지 않은 것처럼 순차적으로 발생합니다.</p>
<p>목록 17-10과 같이 일련의 메시지를 보내고 그 사이에 잠을 자게 함으로써 첫 번째 부분을 해결해 봅시다.</p>
<!-- We cannot test this one because it never stops! -->
<Listing number="17-10" caption="Sending and receiving multiple messages over the async channel and sleeping with an `await` between each message" file-name="src/main.rs">
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let vals = vec![
            String::from("안녕"),
            String::from("from"),
            String::from("the"),
            String::from("future"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            trpl::sleep(Duration::from_millis(500)).await;
        }

        while let Some(value) = rx.recv().await {
            println!("received '{value}'");
        }
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
</Listing>
<p>메시지를 보내는 것 외에도, 우리는 메시지를 받아야 합니다. 이 경우, 얼마나 많은 메시지가 들어올지 알고 있기 때문에 <code>rx.recv().await</code>를 네 번 호출하여 수동으로 수행할 수 있습니다. 하지만 실제 세계에서는 일반적으로 <em>알 수 없는</em> 수의 메시지를 기다리게 되므로, 더 이상 메시지가 없다고 판단할 때까지 계속 기다려야 합니다.</p>
<p>목록 16-10에서는 동기 채널에서 수신된 모든 항목을 처리하기 위해 <code>for</code> 루프를 사용했습니다. 하지만 러스트에는 아직 <em>비동기</em> 항목 시리즈에 대해 <code>for</code> 루프를 작성하는 방법이 없으므로, 이전에 본 적 없는 루프인 <code>while let</code> 조건부 루프를 사용해야 합니다. 이것은 <a href="ch06-03-if-let.html">if let과 let else를 사용한 간결한 제어 흐름</a><!-- ignore --> 섹션에서 보았던 <code>if let</code> 구조의 루프 버전입니다. 루프는 지정된 패턴이 값과 계속 일치하는 한 실행을 계속합니다.</p>
<p><code>rx.recv</code> 호출은 퓨처를 생성하며, 우리는 이를 기다립니다. 런타임은 준비될 때까지 퓨처를 일시 중지합니다. 메시지가 도착하면, 메시지가 도착하는 횟수만큼 퓨처는 <code>Some(message)</code>로 해결됩니다. 채널이 닫히면, 메시지가 도착했는지 여부에 관계없이 퓨처는 대신 <code>None</code>으로 해결되어 더 이상 값이 없음을 나타내며, 따라서 폴링을 중지(즉, 기다림을 중지)해야 합니다.</p>
<p><code>while let</code> 루프는 이 모든 것을 하나로 묶습니다. <code>rx.recv().await</code> 호출의 결과가 <code>Some(message)</code>이면, <code>if let</code>과 마찬가지로 메시지에 접근하여 루프 본문에서 사용할 수 있습니다. 결과가 <code>None</code>이면 루프가 종료됩니다. 루프가 완료될 때마다 다시 await 지점에 도달하므로, 런타임은 다른 메시지가 도착할 때까지 다시 일시 중지합니다.</p>
<p>이제 코드는 모든 메시지를 성공적으로 보내고 받습니다. 불행히도, 여전히 몇 가지 문제가 있습니다. 첫째, 메시지가 0.5초 간격으로 도착하지 않습니다. 프로그램을 시작한 지 2초(2,000 밀리초) 후에 한꺼번에 도착합니다. 둘째, 이 프로그램은 절대 종료되지 않습니다! 대신, 새로운 메시지를 영원히 기다립니다. <span
class="keystroke">ctrl-c</span>를 사용하여 종료해야 합니다.</p>
<p>왜 메시지가 각각의 지연 시간과 함께 도착하지 않고 전체 지연 후 한꺼번에 도착하는지 살펴보는 것부터 시작해 봅시다. 주어진 비동기 블록 내에서, 코드에 <code>await</code> 키워드가 나타나는 순서는 프로그램이 실행될 때 실행되는 순서와 같습니다.</p>
<p>목록 17-10에는 단 하나의 비동기 블록만 있으므로, 그 안의 모든 것은 선형적으로 실행됩니다. 여전히 동시성은 없습니다. 모든 <code>tx.send</code> 호출은 모든 <code>trpl::sleep</code> 호출 및 관련 await 지점과 섞여서 발생합니다. 그 후에야 <code>while let</code> 루프가 <code>recv</code> 호출의 <code>await</code> 지점을 통과할 수 있습니다.</p>
<p>각 메시지 사이에 수면 지연이 발생하는 원하는 동작을 얻으려면, 목록 17-11과 같이 <code>tx</code>와 <code>rx</code> 작업을 각자의 비동기 블록에 넣어야 합니다. 그러면 런타임은 카운팅 예제에서와 마찬가지로 <code>trpl::join</code>을 사용하여 각각을 별도로 실행할 수 있습니다. 다시 말하지만, 우리는 개별 퓨처가 아니라 <code>trpl::join</code> 호출의 결과를 기다립니다. 만약 우리가 개별 퓨처를 순차적으로 기다린다면, 결국 다시 순차적인 흐름으로 돌아가게 될 것입니다. 이는 우리가 <em>피하려고</em> 하는 바로 그 상황입니다.</p>
<!-- We cannot test this one because it never stops! -->
<Listing number="17-11" caption="Separating `send` and `recv` into their own `async` blocks and awaiting the futures for those blocks" file-name="src/main.rs">
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span>        let tx_fut = async {
            let vals = vec![
                String::from("안녕"),
                String::from("from"),
                String::from("the"),
                String::from("future"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("received '{value}'");
            }
        };

        trpl::join(tx_fut, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
</Listing>
<p>목록 17-11의 업데이트된 코드를 사용하면 메시지가 2초 후에 한꺼번에 출력되는 대신 500밀리초 간격으로 출력됩니다.</p>
<p>하지만 <code>while let</code> 루프가 <code>trpl::join</code>과 상호작용하는 방식 때문에 프로그램은 여전히 종료되지 않습니다:</p>
<ul>
<li><code>trpl::join</code>에서 반환된 퓨처는 전달된 <em>두</em> 퓨처가 모두 완료된 후에만 완료됩니다.</li>
<li><code>tx</code> 퓨처는 <code>vals</code>의 마지막 메시지를 보낸 후 수면을 마쳤을 때 완료됩니다.</li>
<li><code>rx</code> 퓨처는 <code>while let</code> 루프가 끝날 때까지 완료되지 않습니다.</li>
<li><code>while let</code> 루프는 <code>rx.recv</code>를 기다리는 과정(await)에서 <code>None</code>이 생성될 때까지 끝나지 않습니다.</li>
<li><code>rx.recv</code>를 기다리는 과정은 채널의 반대편 끝이 닫힌 후에야 <code>None</code>을 반환합니다.</li>
<li>채널은 우리가 <code>rx.close</code>를 호출하거나 송신 측인 <code>tx</code>가 드롭될 때만 닫힙니다.</li>
<li>우리는 어디에서도 <code>rx.close</code>를 호출하지 않으며, <code>tx</code>는 <code>trpl::run</code>에 전달된 가장 바깥쪽의 비동기 블록이 끝날 때까지 드롭되지 않습니다.</li>
<li>그 블록은 <code>trpl::join</code>이 완료될 때까지 차단되어 끝날 수 없으며, 이는 우리를 다시 이 목록의 처음으로 되돌려 보냅니다.</li>
</ul>
<p>어딘가에서 <code>rx.close</code>를 호출하여 수동으로 <code>rx</code>를 닫을 수도 있지만, 그것은 별로 말이 되지 않습니다. 임의의 개수의 메시지를 처리한 후 중지하면 프로그램은 종료되겠지만, 메시지를 놓칠 수 있습니다. 우리는 함수가 끝나기 <em>전에</em> <code>tx</code>가 드롭되도록 보장할 다른 방법이 필요합니다.</p>
<p>현재 메시지를 보내는 비동기 블록은 <code>tx</code>를 대여하기만 하는데, 메시지를 보내는 데 소유권이 필요하지 않기 때문입니다. 하지만 만약 우리가 <code>tx</code>를 그 비동기 블록으로 이동시킬 수 있다면, 해당 블록이 끝날 때 <code>tx</code>가 드롭될 것입니다. 13장의 <a href="ch13-01-closures.html#capturing-references-or-moving-ownership">참조 캡처하기 또는 소유권 이동하기</a><!-- ignore --> 섹션에서 클로저와 함께 <code>move</code> 키워드를 사용하는 방법을 배웠고, 16장의 <a href="ch16-01-threads.html#using-move-closures-with-threads">스레드와 함께 <code>move</code> 클로저 사용하기</a><!-- ignore
--> 섹션에서 논의했듯이, 스레드로 작업할 때 종종 데이터를 클로저로 이동시켜야 합니다. 비동기 블록에도 동일한 기본 역학이 적용되므로, <code>move</code> 키워드는 클로저에서와 마찬가지로 비동기 블록에서도 작동합니다.</p>
<p>목록 17-12에서 우리는 메시지를 보내는 데 사용되는 블록을 <code>async</code>에서 <code>async move</code>로 변경합니다. 코드의 <em>이</em> 버전을 실행하면 마지막 메시지가 전송되고 수신된 후 우아하게 종료됩니다.</p>
<Listing number="17-12" caption="A  revision of the code from Listing 17-11 that correctly shuts down when complete" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let tx_fut = async move {
            let vals = vec![
                String::from("안녕"),
                String::from("from"),
                String::from("the"),
                String::from("future"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("received '{value}'");
            }
        };

        trpl::join(tx_fut, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 비동기 채널은 다중 생산자 채널이기도 하므로, 목록 17-13과 같이 여러 퓨처에서 메시지를 보내고 싶다면 <code>tx</code>에 대해 <code>clone</code>을 호출할 수 있습니다.</p>
<Listing number="17-13" caption="Using multiple producers with async blocks" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let tx1 = tx.clone();
        let tx1_fut = async move {
            let vals = vec![
                String::from("안녕"),
                String::from("from"),
                String::from("the"),
                String::from("future"),
            ];

            for val in vals {
                tx1.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("received '{value}'");
            }
        };

        let tx_fut = async move {
            let vals = vec![
                String::from("more"),
                String::from("messages"),
                String::from("for"),
                String::from("you"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(1500)).await;
            }
        };

        trpl::join3(tx1_fut, tx_fut, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>먼저 <code>tx</code>를 클론하여 첫 번째 비동기 블록 외부에서 <code>tx1</code>을 생성합니다. 이전에 <code>tx</code>로 했던 것과 마찬가지로 <code>tx1</code>을 해당 블록으로 이동시킵니다. 그런 다음 나중에 원래의 <code>tx</code>를 <em>새로운</em> 비동기 블록으로 이동시키고, 거기서 약간 더 느린 지연 시간으로 더 많은 메시지를 보냅니다. 우리는 우연히 이 새로운 비동기 블록을 메시지 수신을 위한 비동기 블록 뒤에 두었지만, 그 앞에 두어도 상관없습니다. 핵심은 퓨처가 생성되는 순서가 아니라 기다려지는(await) 순서입니다.</p>
<p>메시지를 보내기 위한 두 비동기 블록은 모두 <code>async move</code> 블록이어야 하며, 그래야 해당 블록이 끝날 때 <code>tx</code>와 <code>tx1</code>이 모두 드롭됩니다. 그렇지 않으면 처음 시작했던 것과 동일한 무한 루프에 빠지게 될 것입니다. 마지막으로, 추가된 퓨처를 처리하기 위해 <code>trpl::join</code>에서 <code>trpl::join3</code>으로 전환합니다.</p>
<p>이제 양쪽 송신 퓨처의 모든 메시지를 볼 수 있으며, 송신 퓨처들이 전송 후 약간 다른 지연 시간을 사용하기 때문에 메시지들도 서로 다른 간격으로 수신됩니다.</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">received 'hi'
received 'more'
received 'from'
received 'the'
received 'messages'
received 'future'
received 'for'
received 'you'
</code></pre>
<p>이것은 좋은 시작이지만, <code>join</code>으로는 2개, <code>join3</code>으로는 3개와 같이 소수의 퓨처로만 제한됩니다. 더 많은 퓨처를 사용하는 방법을 알아봅시다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch17-01-futures-and-syntax.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch17-03-more-futures.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch17-01-futures-and-syntax.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch17-03-more-futures.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
