<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>스레드를 사용하여 코드를 동시에 실행하기 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch16-01-threads.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch16-01-threads.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="스레드를-사용하여-코드를-동시에-실행하기"><a class="header" href="#스레드를-사용하여-코드를-동시에-실행하기">스레드를 사용하여 코드를 동시에 실행하기</a></h2>
<p>대부분의 최신 운영 체제에서 실행된 프로그램의 코드는 <em>프로세스</em> 내에서 실행되며, 운영 체제는 한 번에 여러 프로세스를 관리합니다. 프로그램 내에서 동시에 실행되는 독립적인 부분을 가질 수도 있습니다. 이러한 독립적인 부분을 실행하는 기능을 _스레드_라고 합니다. 예를 들어, 웹 서버는 동시에 여러 요청에 응답할 수 있도록 여러 스레드를 가질 수 있습니다.</p>
<p>여러 작업을 동시에 실행하기 위해 프로그램의 계산을 여러 스레드로 나누면 성능이 향상될 수 있지만 복잡성도 추가됩니다. 스레드는 동시에 실행될 수 있기 때문에 다른 스레드에 있는 코드의 부분이 실행되는 순서에 대한 내재적인 보장이 없습니다. 이는 다음과 같은 문제로 이어질 수 있습니다:</p>
<ul>
<li>스레드가 일관되지 않은 순서로 데이터나 리소스에 접근하는 경쟁 상태</li>
<li>두 스레드가 서로를 기다리며 두 스레드 모두 계속 진행하지 못하게 하는 교착 상태</li>
<li>Bugs that only happen in certain situations and are hard to reproduce and fix reliably</li>
</ul>
<p>러스트는 스레드 사용의 부정적인 영향을 완화하려고 시도하지만, 멀티스레드 환경에서의 프로그래밍은 여전히 신중한 고려가 필요하며 단일 스레드에서 실행되는 프로그램과는 다른 코드 구조를 요구합니다.</p>
<p>Programming languages implement threads in a few different ways, and many operating systems provide an API the programming language can call for creating new threads. The Rust standard library uses a <em>1:1</em> model of thread implementation, whereby a program uses one operating system thread per one language thread. There are crates that implement other models of threading that make different trade-offs to the 1:1 model. (Rust’s async system, which we will see in the next chapter, provides another approach to concurrency as well.)</p>
<h3 id="spawn으로-새로운-스레드-생성하기"><a class="header" href="#spawn으로-새로운-스레드-생성하기"><code>spawn</code>으로 새로운 스레드 생성하기</a></h3>
<p>To create a new thread, we call the <code>thread::spawn</code> function and pass it a closure (we talked about closures in Chapter 13) containing the code we want to run in the new thread. The example in Listing 16-1 prints some text from a main thread and other text from a new thread.</p>
<Listing number="16-1" file-name="src/main.rs" caption="Creating a new thread to print one thing while the main thread prints something else">
<pre><pre class="playground"><code class="language-rust edition2024">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!("생성된 스레드에서 안녕하세요 숫자 {i}!");
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("메인 스레드에서 안녕하세요 숫자 {i}!");
        thread::sleep(Duration::from_millis(1));
    }
}</code></pre></pre>
</Listing>
<p>러스트 프로그램의 메인 스레드가 완료되면, 실행이 완료되었는지 여부와 상관없이 모든 생성된 스레드가 종료된다는 점에 유의하세요. 이 프로그램의 출력은 매번 조금씩 다를 수 있지만, 다음과 비슷하게 보일 것입니다:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the main thread!
hi number 1 from the spawned thread!
hi number 2 from the main thread!
hi number 2 from the spawned thread!
hi number 3 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the main thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
</code></pre>
<p>The calls to <code>thread::sleep</code> force a thread to stop its execution for a short duration, allowing a different thread to run. The threads will probably take turns, but that isn’t guaranteed: It depends on how your operating system schedules the threads. In this run, the main thread printed first, even though the print statement from the spawned thread appears first in the code. And even though we told the spawned thread to print until <code>i</code> is <code>9</code>, it only got to <code>5</code> before the main thread shut down.</p>
<p>이 코드를 실행했을 때 메인 스레드의 출력만 보이거나 겹치는 부분이 보이지 않는다면, 운영 체제가 스레드 간 전환을 할 수 있는 기회를 더 많이 만들 수 있도록 범위의 숫자를 늘려보세요.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="waiting-for-all-threads-to-finish-using-join-handles"></a></p>
<h3 id="waiting-for-all-threads-to-finish"><a class="header" href="#waiting-for-all-threads-to-finish">Waiting for All Threads to Finish</a></h3>
<p>목록 16-1의 코드는 메인 스레드가 종료되어 대부분의 경우 생성된 스레드를 조기에 중지할 뿐만 아니라, 스레드가 실행되는 순서에 대한 보장이 없기 때문에 생성된 스레드가 실행될 것이라는 보장도 할 수 없습니다!</p>
<p>We can fix the problem of the spawned thread not running or of it ending prematurely by saving the return value of <code>thread::spawn</code> in a variable. The return type of <code>thread::spawn</code> is <code>JoinHandle&lt;T&gt;</code>. A <code>JoinHandle&lt;T&gt;</code> is an owned value that, when we call the <code>join</code> method on it, will wait for its thread to finish. Listing 16-2 shows how to use the <code>JoinHandle&lt;T&gt;</code> of the thread we created in Listing 16-1 and how to call <code>join</code> to make sure the spawned thread finishes before <code>main</code> exits.</p>
<Listing number="16-2" file-name="src/main.rs" caption="Saving a `JoinHandle<T>` from `thread::spawn` to guarantee the thread is run to completion">
<pre><pre class="playground"><code class="language-rust edition2024">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("생성된 스레드에서 안녕하세요 숫자 {i}!");
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("메인 스레드에서 안녕하세요 숫자 {i}!");
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}</code></pre></pre>
</Listing>
<p>핸들에서 join을 호출하면 핸들이 나타내는 스레드가 종료될 때까지 현재 실행 중인 스레드를 차단합니다. 스레드를 _차단_한다는 것은 해당 스레드가 작업을 수행하거나 종료하지 못하도록 막는다는 것을 의미합니다. 메인 스레드의 for 루프 뒤에 join 호출을 넣었으므로, 목록 16-2를 실행하면 다음과 유사한 출력이 생성되어야 합니다:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 1 from the spawned thread!
hi number 3 from the main thread!
hi number 2 from the spawned thread!
hi number 4 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
</code></pre>
<p>두 스레드는 계속 번갈아 가며 실행되지만, 메인 스레드는 handle.join() 호출로 인해 기다리며 생성된 스레드가 완료될 때까지 종료되지 않습니다.</p>
<p>하지만 대신 handle.join()을 메인의 for 루프 앞으로 이동하면 어떤 일이 일어나는지 봅시다. 다음과 같이요:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2024">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("생성된 스레드에서 안녕하세요 숫자 {i}!");
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!("메인 스레드에서 안녕하세요 숫자 {i}!");
        thread::sleep(Duration::from_millis(1));
    }
}</code></pre></pre>
</Listing>
<p>메인 스레드는 생성된 스레드가 끝날 때까지 기다린 다음 for 루프를 실행하므로, 여기에 표시된 것처럼 출력은 더 이상 인터리브되지 않습니다:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the spawned thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 3 from the main thread!
hi number 4 from the main thread!
</code></pre>
<p>join이 호출되는 위치와 같은 작은 세부 사항이 스레드가 동시에 실행되는지 여부에 영향을 미칠 수 있습니다.</p>
<h3 id="스레드에-move-클로저-사용하기"><a class="header" href="#스레드에-move-클로저-사용하기">스레드에 <code>move</code> 클로저 사용하기</a></h3>
<p>We’ll often use the <code>move</code> keyword with closures passed to <code>thread::spawn</code> because the closure will then take ownership of the values it uses from the environment, thus transferring ownership of those values from one thread to another. In <a href="ch13-01-closures.html#capturing-references-or-moving-ownership">“Capturing References or Moving Ownership”</a><!-- ignore
--> in Chapter 13, we discussed <code>move</code> in the context of closures. Now we’ll concentrate more on the interaction between <code>move</code> and <code>thread::spawn</code>.</p>
<p>Notice in Listing 16-1 that the closure we pass to <code>thread::spawn</code> takes no arguments: We’re not using any data from the main thread in the spawned thread’s code. To use data from the main thread in the spawned thread, the spawned thread’s closure must capture the values it needs. Listing 16-3 shows an attempt to create a vector in the main thread and use it in the spawned thread. However, this won’t work yet, as you’ll see in a moment.</p>
<Listing number="16-3" file-name="src/main.rs" caption="Attempting to use a vector created by the main thread in another thread">
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("여기 벡터가 있습니다: {v:?}");
    });

    handle.join().unwrap();
}</code></pre>
</Listing>
<p>클로저가 v를 사용하므로 v를 캡처하여 클로저 환경의 일부로 만듭니다. thread::spawn은 이 클로저를 새로운 스레드에서 실행하므로, 우리는 그 새로운 스레드 내부에서 v에 접근할 수 있어야 합니다. 하지만 이 예제를 컴파일하면 다음과 같은 에러를 얻습니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function
 --&gt; src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ 대여된 값 `v`보다 더 오래 살 수 있습니다
7 |         println!("Here's a vector: {v:?}");
  |                                     - `v`는 여기서 대여됩니다
  |
note: function requires argument type to outlive `'static`
 --&gt; src/main.rs:6:18
  |
6 |       let handle = thread::spawn(|| {
  |  __________________^
7 | |         println!("Here's a vector: {v:?}");
8 | |     });
  | |______^
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++

For more information about this error, try `rustc --explain E0373`.
error: could not compile `threads` (bin "threads") due to 1 previous error
</code></pre>
<p>Rust <em>infers</em> how to capture <code>v</code>, and because <code>println!</code> only needs a reference to <code>v</code>, the closure tries to borrow <code>v</code>. However, there’s a problem: Rust can’t tell how long the spawned thread will run, so it doesn’t know whether the reference to <code>v</code> will always be valid.</p>
<p>Listing 16-4 provides a scenario that’s more likely to have a reference to <code>v</code> that won’t be valid.</p>
<Listing number="16-4" file-name="src/main.rs" caption="A thread with a closure that attempts to capture a reference to `v` from a main thread that drops `v`">
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("여기 벡터가 있습니다: {v:?}");
    });

    drop(v); // 안돼!

    handle.join().unwrap();
}</code></pre>
</Listing>
<p>If Rust allowed us to run this code, there’s a possibility that the spawned thread would be immediately put in the background without running at all. The spawned thread has a reference to <code>v</code> inside, but the main thread immediately drops <code>v</code>, using the <code>drop</code> function we discussed in Chapter 15. Then, when the spawned thread starts to execute, <code>v</code> is no longer valid, so a reference to it is also invalid. Oh no!</p>
<p>목록 16-3의 컴파일러 오류를 수정하기 위해 오류 메시지의 조언을 사용할 수 있습니다:</p>
<!-- manual-regeneration
after automatic regeneration, look at listings/ch16-fearless-concurrency/listing-16-03/output.txt and copy the relevant part
-->
<pre><code class="language-text">help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++
</code></pre>
<p>By adding the <code>move</code> keyword before the closure, we force the closure to take ownership of the values it’s using rather than allowing Rust to infer that it should borrow the values. The modification to Listing 16-3 shown in Listing 16-5 will compile and run as we intend.</p>
<Listing number="16-5" file-name="src/main.rs" caption="Using the `move` keyword to force a closure to take ownership of the values it uses">
<pre><pre class="playground"><code class="language-rust edition2024">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!("여기 벡터가 있습니다: {v:?}");
    });

    handle.join().unwrap();
}</code></pre></pre>
</Listing>
<p>move 클로저를 사용하여 메인 스레드가 drop을 호출한 목록 16-4의 코드를 수정하기 위해 같은 방법을 시도하고 싶을 수도 있습니다. 하지만 이 수정은 작동하지 않습니다. 목록 16-4가 하려는 작업은 다른 이유로 허용되지 않기 때문입니다. 클로저에 move를 추가하면 v를 클로저의 환경으로 이동시키게 되며, 더 이상 메인 스레드에서 drop을 호출할 수 없게 됩니다. 대신 다음과 같은 컴파일러 오류를 얻게 됩니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0382]: use of moved value: `v`
  --&gt; src/main.rs:10:10
   |
 4 |     let v = vec![1, 2, 3];
   |         - move occurs because `v` has type `Vec&lt;i32&gt;`, which does not implement the `Copy` trait
 5 |
 6 |     let handle = thread::spawn(move || {
   |                                ------- value moved into closure here
 7 |         println!("Here's a vector: {v:?}");
   |                                     - variable moved due to use in closure
...
10 |     drop(v); // oh no!
   |          ^ value used here after move
   |
help: consider cloning the value before moving it into the closure
   |
 6 ~     let value = v.clone();
 7 ~     let handle = thread::spawn(move || {
 8 ~         println!("Here's a vector: {value:?}");
   |

For more information about this error, try `rustc --explain E0382`.
error: could not compile `threads` (bin "threads") due to 1 previous error
</code></pre>
<p>러스트의 소유권 규칙이 우리를 다시 구했습니다! 목록 16-3의 코드에서 오류가 발생한 이유는 러스트가 보수적으로 스레드에 대해 v를 대여하기만 했기 때문이며, 이는 이론적으로 메인 스레드가 생성된 스레드의 참조를 무효화할 수 있음을 의미했습니다. 러스트에게 v의 소유권을 생성된 스레드로 이동하도록 지시함으로써, 우리는 러스트에게 메인 스레드가 더 이상 v를 사용하지 않을 것임을 보장합니다. 목록 16-4를 같은 방식으로 변경하면, 메인 스레드에서 v를 사용하려고 할 때 소유권 규칙을 위반하게 됩니다. move 키워드는 러스트의 보수적인 기본 대여를 재정의합니다. 그것은 우리가 소유권 규칙을 위반하도록 허용하지 않습니다.</p>
<p>Now that we’ve covered what threads are and the methods supplied by the thread API, let’s look at some situations in which we can use threads.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch16-00-concurrency.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch16-02-message-passing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch16-00-concurrency.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch16-02-message-passing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
