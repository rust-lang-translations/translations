<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>match 제어 흐름 구조 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch06-02-match.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch06-02-match.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Old headings. Do not remove or links may break. -->
<p><a id="the-match-control-flow-operator"></a></p>
<h2 id="match-제어-흐름-구조"><a class="header" href="#match-제어-흐름-구조"><code>match</code> 제어 흐름 구조</a></h2>
<p>러스트는 <code>match</code>라고 불리는 매우 강력한 제어 흐름 구문을 가지고 있는데, 이는 값을 일련의 패턴과 비교하여 어떤 패턴이 일치하느냐에 따라 코드를 실행할 수 있게 해줍니다. 패턴은 리터럴 값, 변수 이름, 와일드카드 및 기타 여러 가지로 구성될 수 있습니다. <a href="ch19-00-patterns.html">19장</a><!-- ignore -->에서는 모든 다양한 종류의 패턴과 그 역할을 다룹니다. <code>match</code>의 강력함은 패턴의 표현력과 모든 가능한 경우의 수가 처리되었음을 컴파일러가 확인한다는 사실에서 나옵니다.</p>
<p>Think of a <code>match</code> expression as being like a coin-sorting machine: Coins slide down a track with variously sized holes along it, and each coin falls through the first hole it encounters that it fits into. In the same way, values go through each pattern in a <code>match</code>, and at the first pattern the value “fits,” the value falls into the associated code block to be used during execution.</p>
<p>동전 이야기가 나왔으니, <code>match</code>를 사용하는 예제로 동전을 사용해 봅시다! 목록 6-3에 나타난 것처럼, 알 수 없는 미국 동전을 받아서 동전 분류기와 유사한 방식으로 그것이 어떤 동전인지 판별하고 그 가치를 센트 단위로 반환하는 함수를 작성할 수 있습니다.</p>
<Listing number="6-3" caption="An enum and a `match` expression that has the variants of the enum as its patterns">
<pre><pre class="playground"><code class="language-rust edition2024">enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p>Let’s break down the <code>match</code> in the <code>value_in_cents</code> function. First, we list the <code>match</code> keyword followed by an expression, which in this case is the value <code>coin</code>. This seems very similar to a conditional expression used with <code>if</code>, but there’s a big difference: With <code>if</code>, the condition needs to evaluate to a Boolean value, but here it can be any type. The type of <code>coin</code> in this example is the <code>Coin</code> enum that we defined on the first line.</p>
<p>다음은 <code>match</code> 암(arm)들입니다. 하나의 암은 패턴과 코드라는 두 부분으로 구성됩니다. 여기서 첫 번째 암은 <code>Coin::Penny</code>라는 값을 패턴으로 가지며, 그 뒤에 패턴과 실행할 코드를 구분하는 <code>=&gt;</code> 연산자가 옵니다. 이 경우 코드는 단지 <code>1</code>이라는 값입니다. 각 암은 다음 암과 쉼표로 구분됩니다.</p>
<p>When the <code>match</code> expression executes, it compares the resultant value against the pattern of each arm, in order. If a pattern matches the value, the code associated with that pattern is executed. If that pattern doesn’t match the value, execution continues to the next arm, much as in a coin-sorting machine. We can have as many arms as we need: In Listing 6-3, our <code>match</code> has four arms.</p>
<p>각 암과 연관된 코드는 표현식이며, 매칭된 암의 표현식 결과 값은 전체 <code>match</code> 표현식에 대해 반환되는 값이 됩니다.</p>
<p>We don’t typically use curly brackets if the match arm code is short, as it is in Listing 6-3 where each arm just returns a value. If you want to run multiple lines of code in a match arm, you must use curly brackets, and the comma following the arm is then optional. For example, the following code prints “Lucky penny!” every time the method is called with a <code>Coin::Penny</code>, but it still returns the last value of the block, <code>1</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter,
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; {
            println!("운 좋은 페니!");
            1
        }
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<h3 id="값에-바인딩하는-패턴"><a class="header" href="#값에-바인딩하는-패턴">값에 바인딩하는 패턴</a></h3>
<p>match 암의 또 다른 유용한 기능은 패턴과 일치하는 값의 일부에 바인딩할 수 있다는 점입니다. 이를 통해 열거형 variant에서 값을 추출할 수 있습니다.</p>
<p>예를 들어, 우리 열거형 variant 중 하나가 내부에 데이터를 가지도록 변경해 봅시다. 1999년부터 2008년까지 미국은 한쪽 면에 50개 주마다 다른 디자인을 넣은 쿼터(25센트 동전)를 주조했습니다. 다른 어떤 동전도 주마다 다른 디자인을 갖지 않았으므로, 쿼터만이 이 특별한 값을 가집니다. 우리는 <code>UsState</code> 값을 내부에 저장하도록 <code>Quarter</code> variant를 변경하여 이 정보를 <code>enum</code>에 추가할 수 있습니다. 목록 6-4에서 그 작업을 수행했습니다.</p>
<Listing number="6-4" caption="A `Coin` enum in which the `Quarter` variant also holds a `UsState` value">
<pre><pre class="playground"><code class="language-rust edition2024">#[derive(Debug)] // 잠시 후에 상태를 검사할 수 있도록
enum UsState {
    Alabama,
    Alaska,
    // --생략--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p>한 친구가 50개 주의 쿼터를 모두 모으려 한다고 상상해 봅시다. 우리가 동전들을 종류별로 분류하는 동안, 각 쿼터에 연관된 주의 이름을 불러주어 만약 친구가 없는 것이라면 수집품에 추가할 수 있게 해줄 것입니다.</p>
<p>In the match expression for this code, we add a variable called <code>state</code> to the pattern that matches values of the variant <code>Coin::Quarter</code>. When a <code>Coin::Quarter</code> matches, the <code>state</code> variable will bind to the value of that quarter’s state. Then, we can use <code>state</code> in the code for that arm, like so:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --생략--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!("{state:?} 주 동전!");
            25
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    value_in_cents(Coin::Quarter(UsState::Alaska));
</span><span class="boring">}</span></code></pre></pre>
<p><code>value_in_cents(Coin::Quarter(UsState::Alaska))</code>를 호출하면 <code>coin</code>은 <code>Coin::Quarter(UsState::Alaska)</code>가 됩니다. 이 값을 각 매치 암과 비교하면 <code>Coin::Quarter(state)</code>에 도달할 때까지 아무것도 일치하지 않습니다. 그 시점에서 <code>state</code>에 대한 바인딩은 <code>UsState::Alaska</code> 값이 됩니다. 그런 다음 <code>println!</code> 표현식에서 해당 바인딩을 사용하여 <code>Quarter</code>에 대한 <code>Coin</code> 열거형 variant에서 내부 상태 값을 가져올 수 있습니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="matching-with-optiont"></a></p>
<h3 id="the-optiont-match-pattern"><a class="header" href="#the-optiont-match-pattern">The <code>Option&lt;T&gt;</code> <code>match</code> Pattern</a></h3>
<p>이전 섹션에서 우리는 <code>Option&lt;T&gt;</code>를 사용할 때 <code>Some</code> 케이스에서 내부의 <code>T</code> 값을 가져오고 싶었습니다. 우리는 <code>Coin</code> 열거형에서 했던 것처럼 <code>match</code>를 사용하여 <code>Option&lt;T&gt;</code>를 처리할 수 있습니다! 동전을 비교하는 대신 <code>Option&lt;T&gt;</code>의 variant들을 비교하게 되지만, <code>match</code> 표현식이 작동하는 방식은 동일합니다.</p>
<p><code>Option&lt;i32&gt;</code>를 인수로 받아서, 내부에 값이 있으면 그 값에 1을 더하는 함수를 작성하고 싶다고 가정해 봅시다. 내부에 값이 없으면 함수는 <code>None</code> 값을 반환하고 어떤 연산도 시도하지 않아야 합니다.</p>
<p><code>match</code> 덕분에 이 함수는 작성하기 매우 쉬우며, 목록 6-5와 같은 모습이 될 것입니다.</p>
<Listing number="6-5" caption="A function that uses a `match` expression on an `Option<i32>`">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            None =&gt; None,
            Some(i) =&gt; Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
<span class="boring">}</span></code></pre></pre>
</Listing>
<p><code>plus_one</code>이 처음 실행되는 과정을 더 자세히 살펴봅시다. <code>plus_one(five)</code>를 호출하면, <code>plus_one</code> 본문의 변수 <code>x</code>는 <code>Some(5)</code> 값을 갖게 됩니다. 그런 다음 이를 각 match 암과 비교합니다.</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p><code>Some(5)</code> 값은 <code>None</code> 패턴과 일치하지 않으므로 다음 암으로 넘어갑니다.</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span><span class="boring">            None =&gt; None,
</span>            Some(i) =&gt; Some(i + 1),
<span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p><code>Some(5)</code>가 <code>Some(i)</code>와 일치하나요? 그렇습니다! 같은 variant입니다. <code>i</code>는 <code>Some</code>에 담긴 값에 바인딩되므로, <code>i</code>는 <code>5</code>라는 값을 갖게 됩니다. 그런 다음 match 암의 코드가 실행되어 <code>i</code> 값에 1을 더하고, 내부에 합계인 <code>6</code>을 담은 새로운 <code>Some</code> 값을 생성합니다.</p>
<p>이제 <code>x</code>가 <code>None</code>인 목록 6-5의 <code>plus_one</code> 두 번째 호출을 생각해 봅시다. <code>match</code>에 진입하여 첫 번째 암과 비교합니다.</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p>일치합니다! 더할 값이 없으므로 프로그램은 멈추고 <code>=&gt;</code> 오른쪽에 있는 <code>None</code> 값을 반환합니다. 첫 번째 암이 일치했으므로 다른 암은 비교하지 않습니다.</p>
<p><code>match</code>와 열거형을 결합하는 것은 많은 상황에서 유용합니다. 러스트 코드에서 이런 패턴을 많이 보게 될 것입니다: 열거형에 대해 <code>match</code>를 수행하고, 내부 데이터에 변수를 바인딩한 다음, 그에 따라 코드를 실행하는 것이죠. 처음에는 조금 까다롭지만, 일단 익숙해지면 모든 언어에 이 기능이 있었으면 좋겠다고 생각하게 될 것입니다. 이 기능은 사용자들에게 일관되게 사랑받는 기능입니다.</p>
<h3 id="매치는-완전해야-합니다"><a class="header" href="#매치는-완전해야-합니다">매치는 완전해야 합니다</a></h3>
<p>There’s one other aspect of <code>match</code> we need to discuss: The arms’ patterns must cover all possibilities. Consider this version of our <code>plus_one</code> function, which has a bug and won’t compile:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            Some(i) =&gt; Some(i + 1),
        }
    }
<span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p><code>None</code> 케이스를 처리하지 않았기 때문에 이 코드는 버그를 유발할 것입니다. 다행히 러스트는 이 버그를 잡아낼 줄 압니다. 이 코드를 컴파일하려고 시도하면 다음과 같은 오류를 보게 될 것입니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
 --&gt; src/main.rs:3:15
  |
3 |         match x {
  |               ^ pattern `None` not covered
  |
note: `Option&lt;i32&gt;` defined here
 --&gt; /rustc/1159e78c4747b02ef996e55082b704c09b970588/library/core/src/option.rs:593:1
 ::: /rustc/1159e78c4747b02ef996e55082b704c09b970588/library/core/src/option.rs:597:5
  |
  = note: not covered
  = note: the matched value is of type `Option&lt;i32&gt;`
help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown
  |
4 ~             Some(i) =&gt; Some(i + 1),
5 ~             None =&gt; todo!(),
  |

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums` (bin "enums") due to 1 previous error
</code></pre>
<p>Rust knows that we didn’t cover every possible case and even knows which pattern we forgot! Matches in Rust are <em>exhaustive</em>: We must exhaust every last possibility in order for the code to be valid. Especially in the case of <code>Option&lt;T&gt;</code>, when Rust prevents us from forgetting to explicitly handle the <code>None</code> case, it protects us from assuming that we have a value when we might have null, thus making the billion-dollar mistake discussed earlier impossible.</p>
<h3 id="모든-것을-포괄하는-패턴과-_-플레이스홀더"><a class="header" href="#모든-것을-포괄하는-패턴과-_-플레이스홀더">모든 것을 포괄하는 패턴과 <code>_</code> 플레이스홀더</a></h3>
<p>Using enums, we can also take special actions for a few particular values, but for all other values take one default action. Imagine we’re implementing a game where, if you roll a 3 on a dice roll, your player doesn’t move but instead gets a fancy new hat. If you roll a 7, your player loses a fancy hat. For all other values, your player moves that number of spaces on the game board. Here’s a <code>match</code> that implements that logic, with the result of the dice roll hardcoded rather than a random value, and all other logic represented by functions without bodies because actually implementing them is out of scope for this example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        other =&gt; move_player(other),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn move_player(num_spaces: u8) {}
<span class="boring">}</span></code></pre></pre>
<p>처음 두 암(arm)의 패턴은 리터럴 값 <code>3</code>과 <code>7</code>입니다. 다른 모든 가능한 값을 다루는 마지막 암의 패턴은 우리가 <code>other</code>라고 이름 붙인 변수입니다. <code>other</code> 암에 대해 실행되는 코드는 이 변수를 <code>move_player</code> 함수에 전달하여 사용합니다.</p>
<p>This code compiles, even though we haven’t listed all the possible values a <code>u8</code> can have, because the last pattern will match all values not specifically listed. This catch-all pattern meets the requirement that <code>match</code> must be exhaustive. Note that we have to put the catch-all arm last because the patterns are evaluated in order. If we had put the catch-all arm earlier, the other arms would never run, so Rust will warn us if we add arms after a catch-all!</p>
<p>러스트에는 포괄적 패턴을 원하지만 그 값을 _사용_하고 싶지는 않을 때 사용할 수 있는 패턴도 있습니다. <code>_</code>는 모든 값과 일치하지만 그 값에 바인딩되지는 않는 특별한 패턴입니다. 이는 러스트에게 우리가 그 값을 사용하지 않을 것임을 알려주며, 따라서 러스트는 사용되지 않는 변수에 대해 경고하지 않습니다.</p>
<p>Let’s change the rules of the game: Now, if you roll anything other than a 3 or a 7, you must roll again. We no longer need to use the catch-all value, so we can change our code to use <code>_</code> instead of the variable named <code>other</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        _ =&gt; reroll(),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn reroll() {}
<span class="boring">}</span></code></pre></pre>
<p>이 예제는 마지막 arm에서 다른 모든 값을 명시적으로 무시하므로 완전성 요구 사항도 충족합니다. 우리는 아무것도 잊지 않았습니다.</p>
<p>마지막으로, 게임 규칙을 한 번 더 변경하여 3이나 7이 아닌 다른 것을 굴리면 당신의 차례에 아무 일도 일어나지 않도록 할 것입니다. 이는 유닛 값( <a href="ch03-02-data-types.html#the-tuple-type">“튜플 타입”</a><!-- ignore --> 섹션에서 언급한 빈 튜플 타입)을 <code>_</code> arm과 함께 가는 코드로 사용하여 표현할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        _ =&gt; (),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
<span class="boring">}</span></code></pre></pre>
<p>여기서 우리는 러스트에게 이전 arm의 패턴과 일치하지 않는 다른 어떤 값도 사용하지 않을 것이며, 이 경우 어떤 코드도 실행하고 싶지 않다고 명시적으로 말하고 있습니다.</p>
<p><a href="ch19-00-patterns.html">19장</a><!-- ignore -->에서 패턴과 매칭에 대해 더 자세히 다룰 것입니다. 지금은 <code>match</code> 표현식이 다소 장황한 상황에서 유용할 수 있는 <code>if let</code> 구문으로 넘어가겠습니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch06-01-defining-an-enum.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch06-03-if-let.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch06-01-defining-an-enum.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch06-03-if-let.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
