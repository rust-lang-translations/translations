<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>match 제어 흐름 구조 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch06-02-match.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch06-02-match.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Old heading. Do not remove or links may break. -->
<p><a id="the-match-control-flow-operator"></a></p>
<h2 id="match-제어-흐름-구조"><a class="header" href="#match-제어-흐름-구조"><code>match</code> 제어 흐름 구조</a></h2>
<p>러스트는 <code>match</code>라고 불리는 매우 강력한 제어 흐름 구문을 가지고 있는데, 이는 값을 일련의 패턴과 비교하여 어떤 패턴이 일치하느냐에 따라 코드를 실행할 수 있게 해줍니다. 패턴은 리터럴 값, 변수 이름, 와일드카드 및 기타 여러 가지로 구성될 수 있습니다. <a href="ch19-00-patterns.html">19장</a><!-- ignore -->에서는 모든 다양한 종류의 패턴과 그 역할을 다룹니다. <code>match</code>의 강력함은 패턴의 표현력과 모든 가능한 경우의 수가 처리되었음을 컴파일러가 확인한다는 사실에서 나옵니다.</p>
<p><code>match</code> 표현식을 동전 분류기와 비슷하다고 생각해 보세요. 동전들은 다양한 크기의 구멍이 뚫린 트랙을 따라 미끄러져 내려가며, 각 동전은 자신에게 맞는 첫 번째 구멍으로 떨어집니다. 마찬가지로, 값은 <code>match</code> 내의 각 패턴을 통과하며, 값이 “맞는” 첫 번째 패턴에서 해당 값은 실행 중에 사용될 관련 코드 블록으로 떨어집니다.</p>
<p>동전 이야기가 나왔으니, <code>match</code>를 사용하는 예제로 동전을 사용해 봅시다! 목록 6-3에 나타난 것처럼, 알 수 없는 미국 동전을 받아서 동전 분류기와 유사한 방식으로 그것이 어떤 동전인지 판별하고 그 가치를 센트 단위로 반환하는 함수를 작성할 수 있습니다.</p>
<Listing number="6-3" caption="An enum and a `match` expression that has the variants of the enum as its patterns">
<pre><pre class="playground"><code class="language-rust edition2021">enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p><code>value_in_cents</code> 함수의 <code>match</code>를 분석해 봅시다. 먼저 <code>match</code> 키워드를 적고 그 뒤에 표현식을 적는데, 이 경우 <code>coin</code> 값입니다. 이는 <code>if</code>와 함께 사용되는 조건식과 매우 유사해 보이지만, 큰 차이점이 있습니다. <code>if</code>의 경우 조건이 불리언 값으로 평가되어야 하지만, 여기서는 어떤 타입이든 될 수 있습니다. 이 예제에서 <code>coin</code>의 타입은 첫 번째 줄에서 정의한 <code>Coin</code> 열거형입니다.</p>
<p>다음은 <code>match</code> 암(arm)들입니다. 하나의 암은 패턴과 코드라는 두 부분으로 구성됩니다. 여기서 첫 번째 암은 <code>Coin::Penny</code>라는 값을 패턴으로 가지며, 그 뒤에 패턴과 실행할 코드를 구분하는 <code>=&gt;</code> 연산자가 옵니다. 이 경우 코드는 단지 <code>1</code>이라는 값입니다. 각 암은 다음 암과 쉼표로 구분됩니다.</p>
<p><code>match</code> 표현식이 실행되면, 결과 값을 각 암의 패턴과 순서대로 비교합니다. 패턴이 값과 일치하면, 그 패턴과 연관된 코드가 실행됩니다. 패턴이 값과 일치하지 않으면, 동전 분류기와 마찬가지로 다음 암으로 실행이 계속됩니다. 필요한 만큼 많은 암을 가질 수 있습니다. 목록 6-3에서 우리의 <code>match</code>는 네 개의 암을 가집니다.</p>
<p>각 암과 연관된 코드는 표현식이며, 매칭된 암의 표현식 결과 값은 전체 <code>match</code> 표현식에 대해 반환되는 값이 됩니다.</p>
<p>목록 6-3에서처럼 각 암이 단지 값을 반환하는 정도로 코드가 짧다면 보통 중괄호를 사용하지 않습니다. 만약 match 암에서 여러 줄의 코드를 실행하고 싶다면 중괄호를 사용해야 하며, 이 경우 암 뒤의 쉼표는 생략 가능합니다. 예를 들어, 다음 코드는 <code>Coin::Penny</code>와 함께 메서드가 호출될 때마다 “운 좋은 페니!”를 출력하지만, 여전히 블록의 마지막 값인 <code>1</code>을 반환합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter,
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; {
            println!("운 좋은 페니!");
            1
        }
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<h3 id="값에-바인딩하는-패턴"><a class="header" href="#값에-바인딩하는-패턴">값에 바인딩하는 패턴</a></h3>
<p>match 암의 또 다른 유용한 기능은 패턴과 일치하는 값의 일부에 바인딩할 수 있다는 점입니다. 이를 통해 열거형 variant에서 값을 추출할 수 있습니다.</p>
<p>예를 들어, 우리 열거형 variant 중 하나가 내부에 데이터를 가지도록 변경해 봅시다. 1999년부터 2008년까지 미국은 한쪽 면에 50개 주마다 다른 디자인을 넣은 쿼터(25센트 동전)를 주조했습니다. 다른 어떤 동전도 주마다 다른 디자인을 갖지 않았으므로, 쿼터만이 이 특별한 값을 가집니다. 우리는 <code>UsState</code> 값을 내부에 저장하도록 <code>Quarter</code> variant를 변경하여 이 정보를 <code>enum</code>에 추가할 수 있습니다. 목록 6-4에서 그 작업을 수행했습니다.</p>
<Listing number="6-4" caption="A `Coin` enum in which the `Quarter` variant also holds a `UsState` value">
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)] // 잠시 후에 상태를 검사할 수 있도록
enum UsState {
    Alabama,
    Alaska,
    // --생략--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p>한 친구가 50개 주의 쿼터를 모두 모으려 한다고 상상해 봅시다. 우리가 동전들을 종류별로 분류하는 동안, 각 쿼터에 연관된 주의 이름을 불러주어 만약 친구가 없는 것이라면 수집품에 추가할 수 있게 해줄 것입니다.</p>
<p>이 코드의 match 표현식에서, <code>Coin::Quarter</code> variant의 값과 일치하는 패턴에 <code>state</code>라는 변수를 추가합니다. <code>Coin::Quarter</code>가 매칭되면, <code>state</code> 변수는 해당 쿼터의 주(state) 값에 바인딩됩니다. 그러면 다음과 같이 해당 암의 코드에서 <code>state</code>를 사용할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --생략--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!("{state:?} 주 동전!");
            25
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    value_in_cents(Coin::Quarter(UsState::Alaska));
</span><span class="boring">}</span></code></pre></pre>
<p><code>value_in_cents(Coin::Quarter(UsState::Alaska))</code>를 호출하면 <code>coin</code>은 <code>Coin::Quarter(UsState::Alaska)</code>가 됩니다. 이 값을 각 매치 암과 비교하면 <code>Coin::Quarter(state)</code>에 도달할 때까지 아무것도 일치하지 않습니다. 그 시점에서 <code>state</code>에 대한 바인딩은 <code>UsState::Alaska</code> 값이 됩니다. 그런 다음 <code>println!</code> 표현식에서 해당 바인딩을 사용하여 <code>Quarter</code>에 대한 <code>Coin</code> 열거형 variant에서 내부 상태 값을 가져올 수 있습니다.</p>
<h3 id="optiont로-매칭하기"><a class="header" href="#optiont로-매칭하기"><code>Option&lt;T&gt;</code>로 매칭하기</a></h3>
<p>이전 섹션에서 우리는 <code>Option&lt;T&gt;</code>를 사용할 때 <code>Some</code> 케이스에서 내부의 <code>T</code> 값을 가져오고 싶었습니다. 우리는 <code>Coin</code> 열거형에서 했던 것처럼 <code>match</code>를 사용하여 <code>Option&lt;T&gt;</code>를 처리할 수 있습니다! 동전을 비교하는 대신 <code>Option&lt;T&gt;</code>의 variant들을 비교하게 되지만, <code>match</code> 표현식이 작동하는 방식은 동일합니다.</p>
<p><code>Option&lt;i32&gt;</code>를 인수로 받아서, 내부에 값이 있으면 그 값에 1을 더하는 함수를 작성하고 싶다고 가정해 봅시다. 내부에 값이 없으면 함수는 <code>None</code> 값을 반환하고 어떤 연산도 시도하지 않아야 합니다.</p>
<p><code>match</code> 덕분에 이 함수는 작성하기 매우 쉬우며, 목록 6-5와 같은 모습이 될 것입니다.</p>
<Listing number="6-5" caption="A function that uses a `match` expression on an `Option<i32>`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            None =&gt; None,
            Some(i) =&gt; Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
<span class="boring">}</span></code></pre></pre>
</Listing>
<p><code>plus_one</code>이 처음 실행되는 과정을 더 자세히 살펴봅시다. <code>plus_one(five)</code>를 호출하면, <code>plus_one</code> 본문의 변수 <code>x</code>는 <code>Some(5)</code> 값을 갖게 됩니다. 그런 다음 이를 각 match 암과 비교합니다.</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p><code>Some(5)</code> 값은 <code>None</code> 패턴과 일치하지 않으므로 다음 암으로 넘어갑니다.</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span><span class="boring">            None =&gt; None,
</span>            Some(i) =&gt; Some(i + 1),
<span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p><code>Some(5)</code>가 <code>Some(i)</code>와 일치하나요? 그렇습니다! 같은 variant입니다. <code>i</code>는 <code>Some</code>에 담긴 값에 바인딩되므로, <code>i</code>는 <code>5</code>라는 값을 갖게 됩니다. 그런 다음 match 암의 코드가 실행되어 <code>i</code> 값에 1을 더하고, 내부에 합계인 <code>6</code>을 담은 새로운 <code>Some</code> 값을 생성합니다.</p>
<p>이제 <code>x</code>가 <code>None</code>인 목록 6-5의 <code>plus_one</code> 두 번째 호출을 생각해 봅시다. <code>match</code>에 진입하여 첫 번째 암과 비교합니다.</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p>일치합니다! 더할 값이 없으므로 프로그램은 멈추고 <code>=&gt;</code> 오른쪽에 있는 <code>None</code> 값을 반환합니다. 첫 번째 암이 일치했으므로 다른 암은 비교하지 않습니다.</p>
<p><code>match</code>와 열거형을 결합하는 것은 많은 상황에서 유용합니다. 러스트 코드에서 이런 패턴을 많이 보게 될 것입니다: 열거형에 대해 <code>match</code>를 수행하고, 내부 데이터에 변수를 바인딩한 다음, 그에 따라 코드를 실행하는 것이죠. 처음에는 조금 까다롭지만, 일단 익숙해지면 모든 언어에 이 기능이 있었으면 좋겠다고 생각하게 될 것입니다. 이 기능은 사용자들에게 일관되게 사랑받는 기능입니다.</p>
<h3 id="매치는-완전해야-합니다"><a class="header" href="#매치는-완전해야-합니다">매치는 완전해야 합니다</a></h3>
<p><code>match</code>에 대해 논의해야 할 또 다른 측면이 있습니다: 암의 패턴은 모든 가능성을 다루어야 한다는 점입니다. 버그가 있어 컴파일되지 않는 다음 버전의 <code>plus_one</code> 함수를 생각해 봅시다.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            Some(i) =&gt; Some(i + 1),
        }
    }
<span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p><code>None</code> 케이스를 처리하지 않았기 때문에 이 코드는 버그를 유발할 것입니다. 다행히 러스트는 이 버그를 잡아낼 줄 압니다. 이 코드를 컴파일하려고 시도하면 다음과 같은 오류를 보게 될 것입니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
   --&gt; src/main.rs:3:15
    |
3   |         match x {
    |               ^ pattern `None` not covered
    |
note: `Option&lt;i32&gt;` defined here
   --&gt; file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/core/src/option.rs:571:1
    |
571 | pub enum Option&lt;T&gt; {
    | ^^^^^^^^^^^^^^^^^^
...
575 |     None,
    |     ---- not covered
    = note: the matched value is of type `Option&lt;i32&gt;`
help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown
    |
4   ~             Some(i) =&gt; Some(i + 1),
5   ~             None =&gt; todo!(),
    |

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums` (bin "enums") due to 1 previous error
</code></pre>
<p>러스트는 우리가 모든 가능한 경우를 다루지 않았음을 알고 있으며, 심지어 우리가 어떤 패턴을 잊었는지도 알고 있습니다! 러스트의 매칭은 _철저(exhaustive)_해야 합니다. 코드가 유효하려면 마지막 가능성 하나까지 모두 소진해야 합니다. 특히 <code>Option&lt;T&gt;</code>의 경우, 러스트가 <code>None</code> 케이스를 명시적으로 처리하는 것을 잊지 않게 함으로써, 값이 null일 수도 있는데 값이 있다고 가정하는 것으로부터 우리를 보호합니다. 이로써 앞서 논의한 10억 달러짜리 실수를 불가능하게 만듭니다.</p>
<h3 id="모든-것을-포괄하는-패턴과-_-플레이스홀더"><a class="header" href="#모든-것을-포괄하는-패턴과-_-플레이스홀더">모든 것을 포괄하는 패턴과 <code>_</code> 플레이스홀더</a></h3>
<p>열거형을 사용하면 몇 가지 특정 값에 대해 특별한 조치를 취하고, 나머지 모든 값에 대해서는 하나의 기본 조치를 취할 수도 있습니다. 주사위를 굴려서 3이 나오면 플레이어는 이동하지 않고 대신 멋진 새 모자를 얻고, 7이 나오면 멋진 모자를 잃는 게임을 구현한다고 상상해 봅시다. 그 외의 모든 값에 대해서는 플레이어가 주사위 눈만큼 게임 판에서 이동합니다. 여기 그 로직을 구현한 <code>match</code>가 있습니다. 주사위 결과는 난수 대신 하드코딩되어 있고, 다른 모든 로직은 실제 구현이 이 예제의 범위를 벗어나기 때문에 본문이 없는 함수로 표현되었습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        other =&gt; move_player(other),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn move_player(num_spaces: u8) {}
<span class="boring">}</span></code></pre></pre>
<p>처음 두 암(arm)의 패턴은 리터럴 값 <code>3</code>과 <code>7</code>입니다. 다른 모든 가능한 값을 다루는 마지막 암의 패턴은 우리가 <code>other</code>라고 이름 붙인 변수입니다. <code>other</code> 암에 대해 실행되는 코드는 이 변수를 <code>move_player</code> 함수에 전달하여 사용합니다.</p>
<p><code>u8</code>이 가질 수 있는 모든 가능한 값을 나열하지 않았음에도 이 코드가 컴파일되는 이유는, 마지막 패턴이 명시적으로 나열되지 않은 모든 값과 일치하기 때문입니다. 이러한 포괄적(catch-all) 패턴은 <code>match</code>가 철저해야 한다는 요구 사항을 충족합니다. 패턴은 순서대로 평가되기 때문에 포괄적 암을 반드시 마지막에 두어야 함에 유의하세요. 포괄적 암을 앞에 두면 그 뒤의 암들은 절대 실행되지 않으므로, 러스트는 포괄적 암 뒤에 다른 암을 추가하면 경고를 보냅니다!</p>
<p>러스트에는 포괄적 패턴을 원하지만 그 값을 _사용_하고 싶지는 않을 때 사용할 수 있는 패턴도 있습니다. <code>_</code>는 모든 값과 일치하지만 그 값에 바인딩되지는 않는 특별한 패턴입니다. 이는 러스트에게 우리가 그 값을 사용하지 않을 것임을 알려주며, 따라서 러스트는 사용되지 않는 변수에 대해 경고하지 않습니다.</p>
<p>게임 규칙을 변경해 봅시다: 이제 3이나 7이 아닌 다른 것을 굴리면 다시 굴려야 합니다. 더 이상 catch-all 값을 사용할 필요가 없으므로, <code>other</code>라는 변수 대신 <code>_</code>를 사용하도록 코드를 변경할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        _ =&gt; reroll(),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn reroll() {}
<span class="boring">}</span></code></pre></pre>
<p>이 예제는 마지막 arm에서 다른 모든 값을 명시적으로 무시하므로 완전성 요구 사항도 충족합니다. 우리는 아무것도 잊지 않았습니다.</p>
<p>마지막으로, 게임 규칙을 한 번 더 변경하여 3이나 7이 아닌 다른 것을 굴리면 당신의 차례에 아무 일도 일어나지 않도록 할 것입니다. 이는 유닛 값( <a href="ch03-02-data-types.html#the-tuple-type">“튜플 타입”</a><!-- ignore --> 섹션에서 언급한 빈 튜플 타입)을 <code>_</code> arm과 함께 가는 코드로 사용하여 표현할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        _ =&gt; (),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
<span class="boring">}</span></code></pre></pre>
<p>여기서 우리는 러스트에게 이전 arm의 패턴과 일치하지 않는 다른 어떤 값도 사용하지 않을 것이며, 이 경우 어떤 코드도 실행하고 싶지 않다고 명시적으로 말하고 있습니다.</p>
<p><a href="ch19-00-patterns.html">19장</a><!-- ignore -->에서 패턴과 매칭에 대해 더 자세히 다룰 것입니다. 지금은 <code>match</code> 표현식이 다소 장황한 상황에서 유용할 수 있는 <code>if let</code> 구문으로 넘어가겠습니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch06-01-defining-an-enum.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch06-03-if-let.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch06-01-defining-an-enum.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch06-03-if-let.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
