<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>테스트 구성 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch11-03-test-organization.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch11-03-test-organization.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="테스트-구성"><a class="header" href="#테스트-구성">테스트 구성</a></h2>
<p>이 장의 시작 부분에서 언급했듯이, 테스트는 복잡한 분야이며 사람마다 사용하는 용어와 구성 방식이 다릅니다. 러스트 커뮤니티는 테스트를 크게 두 가지 범주로 나눕니다: 단위 테스트(unit tests)와 통합 테스트(integration tests)입니다. _단위 테스트_는 작고 집중적이며, 한 번에 하나의 모듈을 분리하여 테스트하고 비공개 인터페이스도 테스트할 수 있습니다. _통합 테스트_는 라이브러리 외부에서 완전히 독립되어 있으며, 다른 외부 코드가 사용하는 것과 동일한 방식으로 여러분의 코드를 사용합니다. 오직 공개 인터페이스만 사용하며 한 테스트당 여러 모듈을 테스트할 수도 있습니다.</p>
<p>라이브러리의 각 조각들이 따로따로 그리고 함께 의도한 대로 작동하는지 보장하기 위해서는 두 종류의 테스트를 모두 작성하는 것이 중요합니다.</p>
<h3 id="단위-테스트"><a class="header" href="#단위-테스트">단위 테스트</a></h3>
<p>단위 테스트의 목적은 나머지 코드와 분리된 각 코드 단위를 테스트하여, 코드가 예상대로 작동하는 부분과 그렇지 않은 부분을 신속하게 찾아내는 것입니다. 단위 테스트는 테스트할 코드가 있는 <em>src</em> 디렉토리의 각 파일에 넣습니다. 관례적으로 각 파일에 테스트 함수를 포함하는 <code>tests</code>라는 이름의 모듈을 만들고, 그 모듈에 <code>cfg(test)</code> 어노테이션을 답니다.</p>
<h4 id="the-tests-module-and-cfgtest"><a class="header" href="#the-tests-module-and-cfgtest">The <code>tests</code> Module and <code>#[cfg(test)]</code></a></h4>
<p><code>tests</code> 모듈에 붙은 <code>#[cfg(test)]</code> 어노테이션은 <code>cargo build</code>를 실행할 때가 아니라 <code>cargo test</code>를 실행할 때만 테스트 코드를 컴파일하고 실행하도록 러스트에게 지시합니다. 이는 라이브러리만 빌드하고 싶을 때 컴파일 시간을 절약해주고, 결과물인 컴파일된 아티팩트에 테스트가 포함되지 않으므로 용량도 절약해줍니다. 뒤에 보시겠지만 통합 테스트는 다른 디렉토리에 위치하기 때문에 <code>#[cfg(test)]</code> 어노테이션이 필요하지 않습니다. 하지만 단위 테스트는 코드와 같은 파일에 위치하므로, 컴파일 결과에 포함되지 않도록 <code>#[cfg(test)]</code>를 사용해야 합니다.</p>
<p>이 장의 첫 번째 섹션에서 새로운 <code>adder</code> 프로젝트를 생성했을 때, Cargo가 우리를 위해 생성해준 다음 코드를 기억해 보세요:</p>
<p><span class="filename">파일명: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<p>자동으로 생성된 <code>tests</code> 모듈에서 <code>cfg</code> 속성은 _설정(configuration)_을 의미하며, 특정 설정 옵션이 주어졌을 때만 이어지는 항목을 포함해야 한다고 러스트에게 알려줍니다. 이 경우 설정 옵션은 <code>test</code>인데, 이는 테스트를 컴파일하고 실행하기 위해 러스트에서 제공하는 옵션입니다. <code>cfg</code> 속성을 사용함으로써, Cargo는 우리가 <code>cargo test</code>를 통해 적극적으로 테스트를 실행할 때만 테스트 코드를 컴파일합니다. 여기에는 <code>#[test]</code> 어노테이션이 달린 함수들뿐만 아니라 이 모듈 내에 있을 수 있는 모든 헬퍼 함수들도 포함됩니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="testing-private-functions"></a></p>
<h4 id="private-function-tests"><a class="header" href="#private-function-tests">Private Function Tests</a></h4>
<p>테스트 커뮤니티 내에서는 비공개 함수를 직접 테스트해야 하는지에 대한 논쟁이 있으며, 다른 언어들은 비공개 함수를 테스트하기 어렵게 하거나 불가능하게 만들기도 합니다. 여러분이 어떤 테스트 철학을 지지하든 상관없이, 러스트의 가시성 규칙은 비공개 함수를 테스트할 수 있게 해줍니다. 비공개 함수 <code>internal_adder</code>가 포함된 목록 11-12의 코드를 살펴봅시다.</p>
<Listing number="11-12" file-name="src/lib.rs" caption="Testing a private function">
<pre><code class="language-rust noplayground">pub fn add_two(a: u64) -&gt; u64 {
    internal_adder(a, 2)
}

fn internal_adder(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        let result = internal_adder(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
</Listing>
<p>Note that the <code>internal_adder</code> function is not marked as <code>pub</code>. Tests are just Rust code, and the <code>tests</code> module is just another module. As we discussed in <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“Paths for Referring to an Item in the Module Tree”</a><!-- ignore -->, items in child modules can use the items in their ancestor modules. In this test, we bring all of the items belonging to the <code>tests</code> module’s parent into scope with <code>use super::*</code>, and then the test can call <code>internal_adder</code>. If you don’t think private functions should be tested, there’s nothing in Rust that will compel you to do so.</p>
<h3 id="통합-테스트"><a class="header" href="#통합-테스트">통합 테스트</a></h3>
<p>러스트에서 통합 테스트는 라이브러리 외부에서 완전히 독립적입니다. 다른 코드가 사용하는 것과 동일한 방식으로 여러분의 라이브러리를 사용하며, 이는 라이브러리의 공개 API에 속하는 함수들만 호출할 수 있음을 의미합니다. 통합 테스트의 목적은 라이브러리의 여러 부분이 함께 올바르게 작동하는지 테스트하는 것입니다. 개별적으로는 올바르게 작동하는 코드 단위들도 통합되었을 때는 문제가 발생할 수 있으므로, 통합된 코드에 대한 테스트 커버리지도 매우 중요합니다. 통합 테스트를 만들기 위해서는 먼저 <em>tests</em> 디렉토리가 필요합니다.</p>
<h4 id="tests-디렉토리"><a class="header" href="#tests-디렉토리"><em>tests</em> 디렉토리</a></h4>
<p>프로젝트 디렉토리의 최상위 수준에 _src_와 나란히 <em>tests</em> 디렉토리를 만듭니다. Cargo는 이 디렉토리에서 통합 테스트 파일들을 찾는 방법을 알고 있습니다. 우리는 원하는 만큼 테스트 파일을 만들 수 있으며, Cargo는 각 파일을 개별 크레이트로 컴파일할 것입니다.</p>
<p>통합 테스트를 만들어 봅시다. 목록 11-12의 코드가 여전히 <em>src/lib.rs</em> 파일에 있는 상태에서, <em>tests</em> 디렉토리를 만들고 _tests/integration_test.rs_라는 새 파일을 생성합니다. 디렉토리 구조는 다음과 같아야 합니다:</p>
<pre><code class="language-text">adder
├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    └── integration_test.rs
</code></pre>
<p>목록 11-13의 코드를 <em>tests/integration_test.rs</em> 파일에 입력하세요.</p>
<Listing number="11-13" file-name="tests/integration_test.rs" caption="An integration test of a function in the `adder` crate">
<pre><code class="language-rust ignore">use adder::add_two;

#[test]
fn it_adds_two() {
    let result = add_two(2);
    assert_eq!(result, 4);
}</code></pre>
</Listing>
<p>Each file in the <em>tests</em> directory is a separate crate, so we need to bring our library into each test crate’s scope. For that reason, we add <code>use adder::add_two;</code> at the top of the code, which we didn’t need in the unit tests.</p>
<p>_tests/integration_test.rs_의 어떤 코드에도 <code>#[cfg(test)]</code>를 달 필요가 없습니다. Cargo는 <em>tests</em> 디렉토리를 특별하게 취급하여, <code>cargo test</code>를 실행할 때만 이 디렉토리의 파일들을 컴파일합니다. 이제 <code>cargo test</code>를 실행해 봅시다:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.31s
     Running unittests src/lib.rs (target/debug/deps/adder-1082c4b063a8fbe6)

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-1082c4b063a8fbe6)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>The three sections of output include the unit tests, the integration test, and the doc tests. Note that if any test in a section fails, the following sections will not be run. For example, if a unit test fails, there won’t be any output for integration and doc tests, because those tests will only be run if all unit tests are passing.</p>
<p>단위 테스트를 위한 첫 번째 섹션은 우리가 보아온 것과 같습니다. 각 단위 테스트(목록 11-12에서 추가한 <code>internal</code>)에 대해 한 줄씩 출력되고 단위 테스트 요약 줄이 나타납니다.</p>
<p>통합 테스트 섹션은 <code>Running tests/integration_test.rs</code>라는 줄로 시작합니다. 다음으로 해당 통합 테스트의 각 테스트 함수에 대한 줄이 있고, <code>Doc-tests adder</code> 섹션이 시작되기 직전에 통합 테스트 결과에 대한 요약 줄이 나타납니다.</p>
<p>각 통합 테스트 파일은 자신만의 섹션을 가지므로, <em>tests</em> 디렉토리에 더 많은 파일을 추가하면 더 많은 통합 테스트 섹션이 생길 것입니다.</p>
<p>여전히 <code>cargo test</code>의 인수로 테스트 함수 이름을 지정하여 특정 통합 테스트 함수를 실행할 수 있습니다. 특정 통합 테스트 파일의 모든 테스트를 실행하려면 <code>cargo test</code>의 <code>--test</code> 인수 뒤에 파일 이름을 붙여 사용하세요:</p>
<pre><code class="language-console">$ cargo test --test integration_test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.64s
     Running tests/integration_test.rs (target/debug/deps/integration_test-82e7799c1bc62298)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>이 명령은 <em>tests/integration_test.rs</em> 파일에 있는 테스트들만 실행합니다.</p>
<h4 id="통합-테스트에서의-하위-모듈"><a class="header" href="#통합-테스트에서의-하위-모듈">통합 테스트에서의 하위 모듈</a></h4>
<p>통합 테스트가 늘어남에 따라 이들을 체계적으로 관리하기 위해 <em>tests</em> 디렉토리에 더 많은 파일을 만들고 싶을 수 있습니다. 예를 들어, 테스트하는 기능별로 테스트 함수들을 그룹화할 수 있습니다. 앞서 언급했듯이, <em>tests</em> 디렉토리의 각 파일은 별개의 크레이트로 컴파일되는데, 이는 최종 사용자가 여러분의 크레이트를 사용하는 방식과 더 가깝게 별도의 스코프를 만드는 데 유용합니다. 하지만 이는 <em>tests</em> 디렉토리의 파일들이 7장에서 배운 <em>src</em> 파일들과는 다르게 작동한다는 것을 의미합니다.</p>
<p>The different behavior of <em>tests</em> directory files is most noticeable when you have a set of helper functions to use in multiple integration test files, and you try to follow the steps in the <a href="ch07-05-separating-modules-into-different-files.html">“Separating Modules into Different Files”</a><!-- ignore --> section of Chapter 7 to extract them into a common module. For example, if we create <em>tests/common.rs</em> and place a function named <code>setup</code> in it, we can add some code to <code>setup</code> that we want to call from multiple test functions in multiple test files:</p>
<p><span class="filename">파일명: tests/common.rs</span></p>
<pre><code class="language-rust noplayground">pub fn setup() {
    // 여러분 라이브러리의 테스트와 관련된 설정 코드가 여기에 들어갑니다
}</code></pre>
<p>테스트를 다시 실행하면, <em>common.rs</em> 파일에 대한 새로운 섹션이 테스트 출력에 나타납니다. 이 파일에는 테스트 함수가 포함되어 있지 않고 어디에서도 <code>setup</code> 함수를 호출하지 않았음에도 불구하고 말이죠:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.89s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/common.rs (target/debug/deps/common-92948b65e88960b4)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-92948b65e88960b4)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>테스트 결과에 <code>common</code>이 나타나고 <code>running 0 tests</code>라고 표시되는 것은 우리가 원하던 바가 아닙니다. 우리는 단지 다른 통합 테스트 파일들과 코드를 공유하고 싶었을 뿐입니다. <code>common</code>이 테스트 출력에 나타나지 않게 하려면, _tests/common.rs_를 만드는 대신 _tests/common/mod.rs_를 만들어야 합니다. 이제 프로젝트 디렉토리는 다음과 같은 모습이 됩니다:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    ├── common
    │   └── mod.rs
    └── integration_test.rs
</code></pre>
<p>이는 7장의 <a href="ch07-05-separating-modules-into-different-files.html#alternate-file-paths">“대체 파일 경로”</a><!-- ignore -->에서 언급했던, 러스트가 이해하는 오래된 명명 관례입니다. 파일을 이런 식으로 명명하면 러스트는 <code>common</code> 모듈을 통합 테스트 파일로 취급하지 않습니다. <code>setup</code> 함수 코드를 _tests/common/mod.rs_로 옮기고 <em>tests/common.rs</em> 파일을 삭제하면, 테스트 출력에서 해당 섹션이 더 이상 나타나지 않습니다. <em>tests</em> 디렉토리의 하위 디렉토리에 있는 파일들은 별개의 크레이트로 컴파일되지 않으며 테스트 출력에 섹션을 가지지도 않습니다.</p>
<p>_tests/common/mod.rs_를 만든 후에는, 어떤 통합 테스트 파일에서든 이를 모듈로 사용할 수 있습니다. 다음은 _tests/integration_test.rs_의 <code>it_adds_two</code> 테스트에서 <code>setup</code> 함수를 호출하는 예입니다:</p>
<p><span class="filename">파일명: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">use adder::add_two;

mod common;

#[test]
fn it_adds_two() {
    common::setup();

    let result = add_two(2);
    assert_eq!(result, 4);
}</code></pre>
<p><code>mod common;</code> 선언은 목록 7-21에서 보여준 모듈 선언과 동일하다는 점에 주목하세요. 그런 다음 테스트 함수에서 <code>common::setup()</code> 함수를 호출할 수 있습니다.</p>
<h4 id="바이너리-크레이트를-위한-통합-테스트"><a class="header" href="#바이너리-크레이트를-위한-통합-테스트">바이너리 크레이트를 위한 통합 테스트</a></h4>
<p>만약 프로젝트가 <em>src/lib.rs</em> 파일 없이 <em>src/main.rs</em> 파일만 있는 바이너리 크레이트라면, <em>tests</em> 디렉토리에 통합 테스트를 만들고 <code>use</code> 문을 통해 _src/main.rs_에 정의된 함수를 가져올 수 없습니다. 오직 라이브러리 크레이트만이 다른 크레이트가 사용할 수 있는 함수를 노출하며, 바이너리 크레이트는 단독으로 실행되는 것을 목적으로 하기 때문입니다.</p>
<p>이것이 바이너리를 제공하는 러스트 프로젝트들이 _src/lib.rs_에 로직을 두고 _src/main.rs_는 이를 호출하는 구조를 갖는 이유 중 하나입니다. 이러한 구조를 사용하면 통합 테스트에서 <code>use</code>를 통해 라이브러리 크레이트의 중요한 기능을 테스트할 수 있습니다. 중요한 기능들이 잘 작동한다면 _src/main.rs_에 있는 소량의 코드도 잘 작동할 것이며, 그 소량의 코드는 따로 테스트할 필요가 없습니다.</p>
<h2 id="요약"><a class="header" href="#요약">요약</a></h2>
<p>Rust’s testing features provide a way to specify how code should function to ensure that it continues to work as you expect, even as you make changes. Unit tests exercise different parts of a library separately and can test private implementation details. Integration tests check that many parts of the library work together correctly, and they use the library’s public API to test the code in the same way external code will use it. Even though Rust’s type system and ownership rules help prevent some kinds of bugs, tests are still important to reduce logic bugs having to do with how your code is expected to behave.</p>
<p>이 장과 이전 장들에서 배운 지식을 결합하여 프로젝트를 진행해 봅시다!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch11-02-running-tests.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch12-00-an-io-project.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch11-02-running-tests.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch12-00-an-io-project.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
