<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>모듈성과 에러 처리 개선을 위한 리팩터링 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch12-03-improving-error-handling-and-modularity.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch12-03-improving-error-handling-and-modularity.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="모듈성과-에러-처리-개선을-위한-리팩터링"><a class="header" href="#모듈성과-에러-처리-개선을-위한-리팩터링">모듈성과 에러 처리 개선을 위한 리팩터링</a></h2>
<p>To improve our program, we’ll fix four problems that have to do with the program’s structure and how it’s handling potential errors. First, our <code>main</code> function now performs two tasks: It parses arguments and reads files. As our program grows, the number of separate tasks the <code>main</code> function handles will increase. As a function gains responsibilities, it becomes more difficult to reason about, harder to test, and harder to change without breaking one of its parts. It’s best to separate functionality so that each function is responsible for one task.</p>
<p>This issue also ties into the second problem: Although <code>query</code> and <code>file_path</code> are configuration variables to our program, variables like <code>contents</code> are used to perform the program’s logic. The longer <code>main</code> becomes, the more variables we’ll need to bring into scope; the more variables we have in scope, the harder it will be to keep track of the purpose of each. It’s best to group the configuration variables into one structure to make their purpose clear.</p>
<p>The third problem is that we’ve used <code>expect</code> to print an error message when reading the file fails, but the error message just prints <code>Should have been able to read the file</code>. Reading a file can fail in a number of ways: For example, the file could be missing, or we might not have permission to open it. Right now, regardless of the situation, we’d print the same error message for everything, which wouldn’t give the user any information!</p>
<p>Fourth, we use <code>expect</code> to handle an error, and if the user runs our program without specifying enough arguments, they’ll get an <code>index out of bounds</code> error from Rust that doesn’t clearly explain the problem. It would be best if all the error-handling code were in one place so that future maintainers had only one place to consult the code if the error-handling logic needed to change. Having all the error-handling code in one place will also ensure that we’re printing messages that will be meaningful to our end users.</p>
<p>프로젝트를 리팩터링하여 이 네 가지 문제를 해결해 봅시다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="separation-of-concerns-for-binary-projects"></a></p>
<h3 id="separating-concerns-in-binary-projects"><a class="header" href="#separating-concerns-in-binary-projects">Separating Concerns in Binary Projects</a></h3>
<p>The organizational problem of allocating responsibility for multiple tasks to the <code>main</code> function is common to many binary projects. As a result, many Rust programmers find it useful to split up the separate concerns of a binary program when the <code>main</code> function starts getting large. This process has the following steps:</p>
<ul>
<li>프로그램을 <em>main.rs</em> 파일과 <em>lib.rs</em> 파일로 나누고, 프로그램 로직을 _lib.rs_로 옮기세요.</li>
<li>As long as your command line parsing logic is small, it can remain in the <code>main</code> function.</li>
<li>When the command line parsing logic starts getting complicated, extract it from the <code>main</code> function into other functions or types.</li>
</ul>
<p>이 과정을 거친 후 <code>main</code> 함수에 남는 책임은 다음과 같이 제한되어야 합니다:</p>
<ul>
<li>인수 값들을 사용하여 명령줄 파싱 로직 호출하기</li>
<li>기타 다른 설정(configuration) 구성하기</li>
<li>_lib.rs_의 <code>run</code> 함수 호출하기</li>
<li><code>run</code> 함수가 에러를 반환할 때 에러 처리하기</li>
</ul>
<p>This pattern is about separating concerns: <em>main.rs</em> handles running the program and <em>lib.rs</em> handles all the logic of the task at hand. Because you can’t test the <code>main</code> function directly, this structure lets you test all of your program’s logic by moving it out of the <code>main</code> function. The code that remains in the <code>main</code> function will be small enough to verify its correctness by reading it. Let’s rework our program by following this process.</p>
<h4 id="인수-파서-추출하기"><a class="header" href="#인수-파서-추출하기">인수 파서 추출하기</a></h4>
<p>We’ll extract the functionality for parsing arguments into a function that <code>main</code> will call. Listing 12-5 shows the new start of the <code>main</code> function that calls a new function <code>parse_config</code>, which we’ll define in <em>src/main.rs</em>.</p>
<Listing number="12-5" file-name="src/main.rs" caption="Extracting a `parse_config` function from `main`">
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (query, file_path) = parse_config(&amp;args);

    // --생략--
<span class="boring">
</span><span class="boring">    println!("Searching for {query}");
</span><span class="boring">    println!("In file {file_path}");
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(file_path)
</span><span class="boring">        .expect("파일을 읽을 수 있어야 합니다");
</span><span class="boring">
</span><span class="boring">    println!("텍스트 내용:\n{contents}");
</span>}

fn parse_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let query = &amp;args[1];
    let file_path = &amp;args[2];

    (query, file_path)
}</code></pre>
</Listing>
<p>우리는 여전히 명령줄 인수를 벡터로 수집하지만, <code>main</code> 함수 내에서 인덱스 1의 값을 <code>query</code> 변수에, 인덱스 2의 값을 <code>file_path</code> 변수에 직접 할당하는 대신, 전체 벡터를 <code>parse_config</code> 함수에 전달합니다. 그러면 <code>parse_config</code> 함수가 어떤 인수가 어떤 변수에 들어갈지 결정하는 로직을 갖고, 그 값들을 다시 <code>main</code>으로 돌려줍니다. <code>main</code>에서 <code>query</code>와 <code>file_path</code> 변수를 여전히 생성하지만, 명령줄 인수와 변수가 어떻게 대응되는지 결정하는 책임은 더 이상 <code>main</code>에 있지 않습니다.</p>
<p>이러한 재작업이 우리 작은 프로그램에는 과해 보일 수 있지만, 우리는 작고 점진적인 단계로 리팩터링을 진행하고 있습니다. 이 변경을 마친 후 프로그램을 다시 실행하여 인수 파싱이 여전히 잘 작동하는지 확인하세요. 문제가 발생했을 때 그 원인을 찾기 쉽도록 진행 상황을 자주 확인하는 것이 좋습니다.</p>
<h4 id="설정-값-그룹화하기"><a class="header" href="#설정-값-그룹화하기">설정 값 그룹화하기</a></h4>
<p><code>parse_config</code> 함수를 더 개선하기 위해 또 다른 작은 단계를 밟을 수 있습니다. 현재 우리는 튜플을 반환하고 있지만, 그 즉시 튜플을 다시 개별 부분으로 쪼개고 있습니다. 이는 아마도 우리가 아직 적절한 추상화를 갖지 못했다는 신호일 수 있습니다.</p>
<p>개선의 여지가 있다는 또 다른 지표는 <code>parse_config</code> 이름의 <code>config</code> 부분입니다. 이는 우리가 반환하는 두 값이 서로 관련이 있으며, 둘 다 하나의 설정 값의 일부임을 암시합니다. 현재로서는 두 값을 튜플로 묶는 것 외에는 데이터 구조에서 이러한 의미를 전달하지 못하고 있습니다. 대신 두 값을 하나의 구조체에 넣고 각 필드에 의미 있는 이름을 부여하겠습니다. 이렇게 하면 미래의 유지보수자들이 각 값들이 서로 어떻게 연관되어 있는지, 그리고 그 목적이 무엇인지 더 쉽게 이해할 수 있을 것입니다.</p>
<p>목록 12-6은 <code>parse_config</code> 함수의 개선된 모습을 보여줍니다.</p>
<Listing number="12-6" file-name="src/main.rs" caption="Refactoring `parse_config` to return an instance of a `Config` struct">
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = parse_config(&amp;args);

    println!("Searching for {}", config.query);
    println!("In file {}", config.file_path);

    let contents = fs::read_to_string(config.file_path)
        .expect("파일을 읽을 수 있어야 합니다");

    // --생략--
<span class="boring">
</span><span class="boring">    println!("텍스트 내용:\n{contents}");
</span>}

struct Config {
    query: String,
    file_path: String,
}

fn parse_config(args: &amp;[String]) -&gt; Config {
    let query = args[1].clone();
    let file_path = args[2].clone();

    Config { query, file_path }
}</code></pre>
</Listing>
<p><code>query</code>와 <code>file_path</code>라는 필드를 가진 <code>Config</code>라는 구조체를 추가했습니다. 이제 <code>parse_config</code>의 시그니처는 <code>Config</code> 값을 반환한다고 명시합니다. <code>args</code> 내의 <code>String</code> 값을 참조하는 문자열 슬라이스를 반환하던 <code>parse_config</code> 본문에서, 이제는 소유권이 있는 <code>String</code> 값을 담도록 <code>Config</code>를 정의합니다. <code>main</code>에 있는 <code>args</code> 변수가 인수 값들의 소유자이며 <code>parse_config</code> 함수에게는 단지 빌려주기만 할 뿐이므로, 만약 <code>Config</code>가 <code>args</code>에 있는 값들의 소유권을 가져오려 한다면 러스트의 대여 규칙을 위반하게 됩니다.</p>
<p><code>String</code> 데이터를 관리하는 방법은 여러 가지가 있습니다. 가장 쉽지만 다소 비효율적인 방법은 값들에 <code>clone</code> 메서드를 호출하는 것입니다. 이는 <code>Config</code> 인스턴스가 소유할 데이터의 전체 복사본을 만들며, 문자열 데이터에 대한 참조를 저장하는 것보다 더 많은 시간과 메모리를 소요합니다. 하지만 데이터를 복제하면 참조의 라이프타임을 관리할 필요가 없으므로 코드가 매우 단순해집니다. 이러한 상황에서는 단순함을 얻기 위해 약간의 성능을 포기하는 것이 가치 있는 트레이드오프가 될 수 있습니다.</p>
<blockquote>
<h3 id="clone-사용의-트레이드오프"><a class="header" href="#clone-사용의-트레이드오프"><code>clone</code> 사용의 트레이드오프</a></h3>
<p>많은 러스트 사용자들 사이에는 런타임 비용 때문에 소유권 문제를 해결하기 위해 <code>clone</code>을 사용하는 것을 피하려는 경향이 있습니다. <a href="ch13-00-functional-features.html">13장</a><!-- ignore -->에서는 이런 상황에서 더 효율적인 방법을 사용하는 법을 배우게 될 것입니다. 하지만 지금은 계속 진행하기 위해 몇 개의 문자열을 복사해도 괜찮습니다. 이러한 복사는 단 한 번만 일어나며, 파일 경로와 검색어 문자열은 매우 작기 때문입니다. 첫 번째 시도에서 코드를 과도하게 최적화하려 하기보다는, 약간 비효율적이더라도 작동하는 프로그램을 만드는 것이 낫습니다. 러스트에 더 익숙해지면 처음부터 가장 효율적인 해결책으로 시작하는 것이 더 쉬워지겠지만, 지금은 <code>clone</code>을 호출하는 것이 완벽하게 수용 가능합니다.</p>
</blockquote>
<p>We’ve updated <code>main</code> so that it places the instance of <code>Config</code> returned by <code>parse_config</code> into a variable named <code>config</code>, and we updated the code that previously used the separate <code>query</code> and <code>file_path</code> variables so that it now uses the fields on the <code>Config</code> struct instead.</p>
<p>이제 우리 코드는 <code>query</code>와 <code>file_path</code>가 서로 연관되어 있으며, 그 목적이 프로그램의 동작 방식을 설정하는 것임을 더 명확하게 전달합니다. 이 값들을 사용하는 모든 코드는 <code>config</code> 인스턴스 내에서 그 목적에 맞게 이름 지어진 필드들을 통해 이 값들을 찾을 수 있습니다.</p>
<h4 id="config를-위한-생성자-만들기"><a class="header" href="#config를-위한-생성자-만들기"><code>Config</code>를 위한 생성자 만들기</a></h4>
<p>지금까지 우리는 명령줄 인수를 파싱하는 로직을 <code>main</code>에서 추출하여 <code>parse_config</code> 함수에 넣었습니다. 이 작업을 통해 <code>query</code>와 <code>file_path</code> 값이 서로 연관되어 있음을 확인했고, 코드에서도 그 관계를 표현해야 함을 알게 되었습니다. 그래서 <code>query</code>와 <code>file_path</code>의 연관된 목적을 나타내기 위해 <code>Config</code> 구조체를 추가했고, <code>parse_config</code> 함수에서 구조체 필드 이름을 통해 각 값의 이름을 반환할 수 있게 되었습니다.</p>
<p>So, now that the purpose of the <code>parse_config</code> function is to create a <code>Config</code> instance, we can change <code>parse_config</code> from a plain function to a function named <code>new</code> that is associated with the <code>Config</code> struct. Making this change will make the code more idiomatic. We can create instances of types in the standard library, such as <code>String</code>, by calling <code>String::new</code>. Similarly, by changing <code>parse_config</code> into a <code>new</code> function associated with <code>Config</code>, we’ll be able to create instances of <code>Config</code> by calling <code>Config::new</code>. Listing 12-7 shows the changes we need to make.</p>
<Listing number="12-7" file-name="src/main.rs" caption="Changing `parse_config` into `Config::new`">
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);
<span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("파일을 읽을 수 있어야 합니다");
</span><span class="boring">
</span><span class="boring">    println!("텍스트 내용:\n{contents}");
</span>
    // --생략--
}

// --생략--

<span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let query = args[1].clone();
        let file_path = args[2].clone();

        Config { query, file_path }
    }
}</code></pre>
</Listing>
<p><code>parse_config</code>를 호출하던 <code>main</code>의 코드를 <code>Config::new</code>를 호출하도록 수정했습니다. <code>parse_config</code>의 이름을 <code>new</code>로 바꾸고 <code>impl</code> 블록 안으로 옮겨서, <code>new</code> 함수를 <code>Config</code>와 연관시켰습니다. 코드가 잘 작동하는지 확인하기 위해 다시 컴파일해 보세요.</p>
<h3 id="에러-핸들링-수정하기"><a class="header" href="#에러-핸들링-수정하기">에러 핸들링 수정하기</a></h3>
<p>이제 에러 핸들링을 수정해 보겠습니다. <code>args</code> 벡터에 아이템이 세 개보다 적을 때 인덱스 1이나 2의 값에 접근하려 하면 프로그램이 패닉을 일으킨다는 점을 기억하세요. 인수 없이 프로그램을 실행해 보면 다음과 같을 것입니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`

thread 'main' panicked at src/main.rs:27:21:
index out of bounds: the len is 1 but the index is 1
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p><code>index out of bounds: the len is 1 but the index is 1</code>이라는 줄은 프로그래머를 위한 에러 메시지입니다. 우리 사용자들은 이 메시지를 보고 무엇을 해야 할지 알 수 없습니다. 이제 이를 수정해 봅시다.</p>
<h4 id="에러-메시지-개선하기"><a class="header" href="#에러-메시지-개선하기">에러 메시지 개선하기</a></h4>
<p>목록 12-8에서는 인덱스 1과 2에 접근하기 전에 슬라이스의 길이가 충분한지 확인하는 검사를 <code>new</code> 함수에 추가합니다. 슬라이스의 길이가 충분하지 않으면 프로그램이 패닉을 일으키고 더 나은 에러 메시지를 표시합니다.</p>
<Listing number="12-8" file-name="src/main.rs" caption="Adding a check for the number of arguments">
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("파일을 읽을 수 있어야 합니다");
</span><span class="boring">
</span><span class="boring">    println!("텍스트 내용:\n{contents}");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span>    // --생략--
    fn new(args: &amp;[String]) -&gt; Config {
        if args.len() &lt; 3 {
            panic!("인수가 부족합니다");
        }
        // --생략--
<span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Config { query, file_path }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>이 코드는 9장의 목록 9-13에서 작성했던 <a href="ch09-03-to-panic-or-not-to-panic.html#creating-custom-types-for-validation"><code>Guess::new</code> 함수</a><!-- ignore -->와 유사합니다. 거기서는 <code>value</code> 인수가 유효 범위를 벗어났을 때 <code>panic!</code>을 호출했었죠. 여기서는 값의 범위를 확인하는 대신 <code>args</code>의 길이가 최소한 <code>3</code>인지 확인하며, 이 조건이 충족되었다는 가정하에 함수의 나머지 부분이 작동하게 합니다. 만약 <code>args</code>의 아이템이 세 개보다 적다면 이 조건은 <code>true</code>가 되고, <code>panic!</code> 매크로를 호출하여 프로그램을 즉시 종료합니다.</p>
<p><code>new</code>에 이 몇 줄의 코드를 추가한 상태에서, 다시 인수 없이 프로그램을 실행하여 에러가 어떻게 보이는지 확인해 봅시다:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`

thread 'main' panicked at src/main.rs:26:13:
not enough arguments
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>This output is better: We now have a reasonable error message. However, we also have extraneous information we don’t want to give to our users. Perhaps the technique we used in Listing 9-13 isn’t the best one to use here: A call to <code>panic!</code> is more appropriate for a programming problem than a usage problem, <a href="ch09-03-to-panic-or-not-to-panic.html#guidelines-for-error-handling">as discussed in Chapter 9</a><!-- ignore -->. Instead, we’ll use the other technique you learned about in Chapter 9—<a href="ch09-02-recoverable-errors-with-result.html">returning a <code>Result</code></a><!-- ignore --> that indicates either success or an error.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="returning-a-result-from-new-instead-of-calling-panic"></a></p>
<h4 id="panic-호출-대신-result-반환하기"><a class="header" href="#panic-호출-대신-result-반환하기"><code>panic!</code> 호출 대신 <code>Result</code> 반환하기</a></h4>
<p>We can instead return a <code>Result</code> value that will contain a <code>Config</code> instance in the successful case and will describe the problem in the error case. We’re also going to change the function name from <code>new</code> to <code>build</code> because many programmers expect <code>new</code> functions to never fail. When <code>Config::build</code> is communicating to <code>main</code>, we can use the <code>Result</code> type to signal there was a problem. Then, we can change <code>main</code> to convert an <code>Err</code> variant into a more practical error for our users without the surrounding text about <code>thread 'main'</code> and <code>RUST_BACKTRACE</code> that a call to <code>panic!</code> causes.</p>
<p>목록 12-9는 현재 <code>Config::build</code>라고 부르는 함수의 반환 값과 <code>Result</code>를 반환하는 데 필요한 함수 본문의 변경 사항을 보여줍니다. <code>main</code>도 함께 업데이트해야 컴파일이 되며, 이는 다음 목록에서 다룰 것입니다.</p>
<Listing number="12-9" file-name="src/main.rs" caption="Returning a `Result` from `Config::build`">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("파일을 읽을 수 있어야 합니다");
</span><span class="boring">
</span><span class="boring">    println!("텍스트 내용:\n{contents}");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err("인수가 부족합니다");
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        Ok(Config { query, file_path })
    }
}</code></pre>
</Listing>
<p>우리 <code>build</code> 함수는 성공 시 <code>Config</code> 인스턴스를 담고 에러 시 문자열 리터럴을 담는 <code>Result</code>를 반환합니다. 에러 값은 항상 <code>'static</code> 라이프타임을 가진 문자열 리터럴이 될 것입니다.</p>
<p>We’ve made two changes in the body of the function: Instead of calling <code>panic!</code> when the user doesn’t pass enough arguments, we now return an <code>Err</code> value, and we’ve wrapped the <code>Config</code> return value in an <code>Ok</code>. These changes make the function conform to its new type signature.</p>
<p><code>Config::build</code>에서 <code>Err</code> 값을 반환하면, <code>main</code> 함수가 <code>build</code> 함수로부터 반환된 <code>Result</code> 값을 처리하고 에러 발생 시 프로세스를 더 깔끔하게 종료할 수 있게 됩니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="calling-confignew-and-handling-errors"></a></p>
<h4 id="configbuild-호출-및-에러-처리하기"><a class="header" href="#configbuild-호출-및-에러-처리하기"><code>Config::build</code> 호출 및 에러 처리하기</a></h4>
<p>에러 상황을 처리하고 사용자 친화적인 메시지를 출력하기 위해, 목록 12-10과 같이 <code>Config::build</code>가 반환하는 <code>Result</code>를 처리하도록 <code>main</code>을 업데이트해야 합니다. 또한 0이 아닌 에러 코드로 명령줄 도구를 종료하는 책임을 <code>panic!</code>으로부터 가져와 직접 구현할 것입니다. 0이 아닌 종료 상태 값은 우리 프로그램을 호출한 프로세스에게 프로그램이 에러 상태로 종료되었음을 알리는 관례입니다.</p>
<Listing number="12-10" file-name="src/main.rs" caption="Exiting with an error code if building a `Config` fails">
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span>use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        println!("인수 파싱 중 문제 발생: {err}");
        process::exit(1);
    });

    // --생략--
<span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("파일을 읽을 수 있어야 합니다");
</span><span class="boring">
</span><span class="boring">    println!("텍스트 내용:\n{contents}");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("인수가 부족합니다");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>In this listing, we’ve used a method we haven’t covered in detail yet: <code>unwrap_or_else</code>, which is defined on <code>Result&lt;T, E&gt;</code> by the standard library. Using <code>unwrap_or_else</code> allows us to define some custom, non-<code>panic!</code> error handling. If the <code>Result</code> is an <code>Ok</code> value, this method’s behavior is similar to <code>unwrap</code>: It returns the inner value that <code>Ok</code> is wrapping. However, if the value is an <code>Err</code> value, this method calls the code in the closure, which is an anonymous function we define and pass as an argument to <code>unwrap_or_else</code>. We’ll cover closures in more detail in <a href="ch13-00-functional-features.html">Chapter 13</a><!-- ignore -->. For now, you just need to know that <code>unwrap_or_else</code> will pass the inner value of the <code>Err</code>, which in this case is the static string <code>"not enough arguments"</code> that we added in Listing 12-9, to our closure in the argument <code>err</code> that appears between the vertical pipes. The code in the closure can then use the <code>err</code> value when it runs.</p>
<p>We’ve added a new <code>use</code> line to bring <code>process</code> from the standard library into scope. The code in the closure that will be run in the error case is only two lines: We print the <code>err</code> value and then call <code>process::exit</code>. The <code>process::exit</code> function will stop the program immediately and return the number that was passed as the exit status code. This is similar to the <code>panic!</code>-based handling we used in Listing 12-8, but we no longer get all the extra output. Let’s try it:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/minigrep`
Problem parsing arguments: not enough arguments
</code></pre>
<p>좋습니다! 이 출력은 우리 사용자들에게 훨씬 더 친절합니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="extracting-logic-from-the-main-function"></a></p>
<h3 id="main에서-로직-추출하기"><a class="header" href="#main에서-로직-추출하기"><code>main</code>에서 로직 추출하기</a></h3>
<p>Now that we’ve finished refactoring the configuration parsing, let’s turn to the program’s logic. As we stated in <a href="#separation-of-concerns-for-binary-projects">“Separating Concerns in Binary Projects”</a><!-- ignore -->, we’ll extract a function named <code>run</code> that will hold all the logic currently in the <code>main</code> function that isn’t involved with setting up configuration or handling errors. When we’re done, the <code>main</code> function will be concise and easy to verify by inspection, and we’ll be able to write tests for all the other logic.</p>
<p>Listing 12-11 shows the small, incremental improvement of extracting a <code>run</code> function.</p>
<Listing number="12-11" file-name="src/main.rs" caption="Extracting a `run` function containing the rest of the program logic">
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --생략--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("인수 파싱 중 문제 발생: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!("Searching for {}", config.query);
    println!("In file {}", config.file_path);

    run(config);
}

fn run(config: Config) {
    let contents = fs::read_to_string(config.file_path)
        .expect("파일을 읽을 수 있어야 합니다");

    println!("텍스트 내용:\n{contents}");
}

// --생략--
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("인수가 부족합니다");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p><code>run</code> 함수는 이제 파일을 읽는 것부터 시작하여 <code>main</code>에 남은 모든 로직을 포함합니다. <code>run</code> 함수는 <code>Config</code> 인스턴스를 인수로 받습니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="returning-errors-from-the-run-function"></a></p>
<h4 id="returning-errors-from-run"><a class="header" href="#returning-errors-from-run">Returning Errors from <code>run</code></a></h4>
<p>나머지 프로그램 로직이 <code>run</code> 함수로 분리되었으므로, 목록 12-9의 <code>Config::build</code>에서 했던 것처럼 에러 처리를 개선할 수 있습니다. <code>expect</code>를 호출하여 프로그램이 패닉을 일으키게 두는 대신, 문제가 발생했을 때 <code>run</code> 함수가 <code>Result&lt;T, E&gt;</code>를 반환하도록 하겠습니다. 이렇게 하면 에러 처리에 관한 로직을 사용자 친화적인 방식으로 <code>main</code>에 더 통합할 수 있습니다. 목록 12-12는 <code>run</code>의 시그니처와 본문에 필요한 변경 사항을 보여줍니다.</p>
<Listing number="12-12" file-name="src/main.rs" caption="Changing the `run` function to return `Result`">
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span>use std::error::Error;

// --생략--

<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("인수 파싱 중 문제 발생: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    run(config);
</span><span class="boring">}
</span><span class="boring">
</span>fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    println!("텍스트 내용:\n{contents}");

    Ok(())
}
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("인수가 부족합니다");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>여기서 세 가지 중요한 변경을 했습니다. 첫째, <code>run</code> 함수의 반환 타입을 <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>로 변경했습니다. 이 함수는 이전에 유닛 타입 <code>()</code>를 반환했으므로, <code>Ok</code> 케이스에서 반환되는 값으로 이를 유지합니다.</p>
<p>For the error type, we used the trait object <code>Box&lt;dyn Error&gt;</code> (and we brought <code>std::error::Error</code> into scope with a <code>use</code> statement at the top). We’ll cover trait objects in <a href="ch18-00-oop.html">Chapter 18</a><!-- ignore -->. For now, just know that <code>Box&lt;dyn Error&gt;</code> means the function will return a type that implements the <code>Error</code> trait, but we don’t have to specify what particular type the return value will be. This gives us flexibility to return error values that may be of different types in different error cases. The <code>dyn</code> keyword is short for <em>dynamic</em>.</p>
<p>두 번째로, <a href="ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator">9장</a><!-- ignore -->에서 이야기했듯이 <code>expect</code> 호출을 <code>?</code> 연산자로 대체했습니다. 오류 발생 시 <code>panic!</code>을 호출하는 대신, <code>?</code>는 현재 함수에서 오류 값을 반환하여 호출자가 처리하도록 합니다.</p>
<p>Third, the <code>run</code> function now returns an <code>Ok</code> value in the success case. We’ve declared the <code>run</code> function’s success type as <code>()</code> in the signature, which means we need to wrap the unit type value in the <code>Ok</code> value. This <code>Ok(())</code> syntax might look a bit strange at first. But using <code>()</code> like this is the idiomatic way to indicate that we’re calling <code>run</code> for its side effects only; it doesn’t return a value we need.</p>
<p>이 코드를 실행하면 컴파일은 되지만 경고가 표시될 것입니다:</p>
<pre><code class="language-console">$ cargo run -- the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
warning: unused `Result` that must be used
  --&gt; src/main.rs:19:5
   |
19 |     run(config);
   |     ^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
19 |     let _ = run(config);
   |     +++++++

warning: `minigrep` (bin "minigrep") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.71s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

</code></pre>
<p>러스트는 우리 코드가 <code>Result</code> 값을 무시했으며, 이 <code>Result</code> 값이 에러가 발생했음을 나타낼 수도 있다고 알려줍니다. 하지만 우리는 에러가 있었는지 확인하지 않고 있으며, 컴파일러는 여기에 에러 처리 코드가 필요할 것이라고 상기시켜 줍니다! 이제 이 문제를 해결해 봅시다.</p>
<h4 id="main에서-run이-반환한-에러-처리하기"><a class="header" href="#main에서-run이-반환한-에러-처리하기"><code>main</code>에서 <code>run</code>이 반환한 에러 처리하기</a></h4>
<p>목록 12-10에서 <code>Config::build</code>와 함께 사용했던 것과 유사하지만 약간의 차이가 있는 기술을 사용하여 에러를 확인하고 처리해 보겠습니다.</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --생략--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("인수 파싱 중 문제 발생: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!("Searching for {}", config.query);
    println!("In file {}", config.file_path);

    if let Err(e) = run(config) {
        println!("애플리케이션 에러: {e}");
        process::exit(1);
    }
}
<span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    println!("텍스트 내용:\n{contents}");
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("인수가 부족합니다");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><code>run</code>이 <code>Err</code> 값을 반환하는지 확인하고, 그럴 경우 <code>process::exit(1)</code>을 호출하기 위해 <code>unwrap_or_else</code> 대신 <code>if let</code>을 사용합니다. <code>run</code> 함수는 <code>Config::build</code>가 <code>Config</code> 인스턴스를 반환하는 것처럼 우리가 <code>unwrap</code>하고 싶은 값을 반환하지 않습니다. <code>run</code>은 성공 시 <code>()</code>를 반환하므로, 우리는 에러를 감지하는 것에만 관심이 있습니다. 따라서 단지 <code>()</code>일 뿐인 언랩된 값을 반환받기 위해 <code>unwrap_or_else</code>를 사용할 필요가 없습니다.</p>
<p>The bodies of the <code>if let</code> and the <code>unwrap_or_else</code> functions are the same in both cases: We print the error and exit.</p>
<h3 id="코드를-라이브러리-크레이트로-분리하기"><a class="header" href="#코드를-라이브러리-크레이트로-분리하기">코드를 라이브러리 크레이트로 분리하기</a></h3>
<p>우리 <code>minigrep</code> 프로젝트가 지금까지는 아주 좋아 보이네요! 이제 <em>src/main.rs</em> 파일을 분리하여 일부 코드를 <em>src/lib.rs</em> 파일에 넣겠습니다. 그렇게 하면 코드를 테스트할 수 있고, <em>src/main.rs</em> 파일의 책임을 줄일 수 있습니다.</p>
<p>Let’s define the code responsible for searching text in <em>src/lib.rs</em> rather than in <em>src/main.rs</em>, which will let us (or anyone else using our <code>minigrep</code> library) call the searching function from more contexts than our <code>minigrep</code> binary.</p>
<p>First, let’s define the <code>search</code> function signature in <em>src/lib.rs</em> as shown in Listing 12-13, with a body that calls the <code>unimplemented!</code> macro. We’ll explain the signature in more detail when we fill in the implementation.</p>
<Listing number="12-13" file-name="src/lib.rs" caption="Defining the `search` function in *src/lib.rs*">
<pre><code class="language-rust ignore does_not_compile">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    unimplemented!();
}</code></pre>
</Listing>
<p>We’ve used the <code>pub</code> keyword on the function definition to designate <code>search</code> as part of our library crate’s public API. We now have a library crate that we can use from our binary crate and that we can test!</p>
<p>Now we need to bring the code defined in <em>src/lib.rs</em> into the scope of the binary crate in <em>src/main.rs</em> and call it, as shown in Listing 12-14.</p>
<Listing number="12-14" file-name="src/main.rs" caption="Using the `minigrep` library crate’s `search` function in *src/main.rs*">
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>// --생략--
use minigrep::search;

fn main() {
    // --생략--
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("인수 파싱 중 문제 발생: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    if let Err(e) = run(config) {
</span><span class="boring">        println!("애플리케이션 에러: {e}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}

// --생략--

<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("인수가 부족합니다");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    for line in search(&amp;config.query, &amp;contents) {
        println!("{line}");
    }

    Ok(())
}</code></pre>
</Listing>
<p>We add a <code>use minigrep::search</code> line to bring the <code>search</code> function from the library crate into the binary crate’s scope. Then, in the <code>run</code> function, rather than printing out the contents of the file, we call the <code>search</code> function and pass the <code>config.query</code> value and <code>contents</code> as arguments. Then, <code>run</code> will use a <code>for</code> loop to print each line returned from <code>search</code> that matched the query. This is also a good time to remove the <code>println!</code> calls in the <code>main</code> function that displayed the query and the file path so that our program only prints the search results (if no errors occur).</p>
<p>Note that the search function will be collecting all the results into a vector it returns before any printing happens. This implementation could be slow to display results when searching large files, because results aren’t printed as they’re found; we’ll discuss a possible way to fix this using iterators in Chapter 13.</p>
<p>휴! 일이 꽤 많았지만, 앞으로의 성공을 위한 기반을 닦았습니다. 이제 에러 처리가 훨씬 쉬워졌고, 코드도 더 모듈화되었습니다. 앞으로는 거의 모든 작업을 _src/lib.rs_에서 하게 될 것입니다.</p>
<p>Let’s take advantage of this newfound modularity by doing something that would have been difficult with the old code but is easy with the new code: We’ll write some tests!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch12-02-reading-a-file.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch12-04-testing-the-librarys-functionality.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch12-02-reading-a-file.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch12-04-testing-the-librarys-functionality.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
