<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>제네릭 데이터 타입 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch10-01-syntax.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch10-01-syntax.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="제네릭-데이터-타입"><a class="header" href="#제네릭-데이터-타입">제네릭 데이터 타입</a></h2>
<p>우리는 함수 시그니처나 구조체와 같은 항목에 대한 정의를 생성하기 위해 제네릭을 사용하며, 이를 다양한 구체적인 데이터 타입과 함께 사용할 수 있습니다. 먼저 제네릭을 사용하여 함수, 구조체, 열거형 및 메서드를 정의하는 방법을 살펴보고, 그런 다음 제네릭이 코드 성능에 미치는 영향에 대해 논의할 것입니다.</p>
<h3 id="함수-정의에서"><a class="header" href="#함수-정의에서">함수 정의에서</a></h3>
<p>제네릭을 사용하는 함수를 정의할 때, 일반적으로 매개변수와 반환 값의 데이터 타입을 지정하는 함수 시그니처에 제네릭을 배치합니다. 이렇게 하면 코드가 더 유연해지고, 코드 중복을 방지하면서 함수 호출자에게 더 많은 기능을 제공합니다.</p>
<p>우리의 <code>largest</code> 함수를 계속해서 살펴보면, 목록 10-4는 슬라이스에서 가장 큰 값을 찾는 두 함수를 보여줍니다. 그런 다음 이 함수들을 제네릭을 사용하는 단일 함수로 결합할 것입니다.</p>
<Listing number="10-4" file-name="src/main.rs" caption="Two functions that differ only in their names and in the types in their signatures">
<pre><pre class="playground"><code class="language-rust edition2021">fn largest_i32(list: &amp;[i32]) -&gt; &amp;i32 {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &amp;[char]) -&gt; &amp;char {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&amp;number_list);
    println!("The largest number is {result}");
<span class="boring">    assert_eq!(*result, 100);
</span>
    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&amp;char_list);
    println!("The largest char is {result}");
<span class="boring">    assert_eq!(*result, 'y');
</span>}</code></pre></pre>
</Listing>
<p><code>largest_i32</code> 함수는 목록 10-3에서 추출한 것으로, 슬라이스에서 가장 큰 <code>i32</code>를 찾습니다. <code>largest_char</code> 함수는 슬라이스에서 가장 큰 <code>char</code>를 찾습니다. 함수 본문은 동일한 코드를 가지므로, 단일 함수에 제네릭 타입 매개변수를 도입하여 중복을 제거해 봅시다.</p>
<p>새로운 단일 함수에서 타입을 매개변수화하려면, 함수에 대한 값 매개변수와 마찬가지로 타입 매개변수의 이름을 지정해야 합니다. 어떤 식별자든 타입 매개변수 이름으로 사용할 수 있습니다. 하지만 러스트의 타입 매개변수 이름은 관례적으로 짧고 종종 한 글자이며, 러스트의 타입 명명 규칙은 CamelCase이기 때문에 <code>T</code>를 사용할 것입니다. _type_의 약자인 <code>T</code>는 대부분의 러스트 프로그래머가 기본적으로 선택하는 것입니다.</p>
<p>함수 본문에서 매개변수를 사용할 때, 컴파일러가 그 이름의 의미를 알 수 있도록 시그니처에 매개변수 이름을 선언해야 합니다. 마찬가지로, 함수 시그니처에서 타입 매개변수 이름을 사용할 때, 사용하기 전에 타입 매개변수 이름을 선언해야 합니다. 제네릭 <code>largest</code> 함수를 정의하려면, 함수 이름과 매개변수 목록 사이에 꺾쇠 괄호 <code>&lt;&gt;</code> 안에 타입 이름 선언을 다음과 같이 배치합니다:</p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {</code></pre>
<p>이 정의는 다음과 같이 해석됩니다. <code>largest</code> 함수는 어떤 타입 <code>T</code>에 대해 제네릭입니다. 이 함수는 <code>list</code>라는 하나의 매개변수를 가지며, 이는 <code>T</code> 타입 값의 슬라이스입니다. <code>largest</code> 함수는 동일한 <code>T</code> 타입 값에 대한 참조를 반환할 것입니다.</p>
<p>목록 10-5는 제네릭 데이터 타입을 시그니처에 사용하여 결합된 <code>largest</code> 함수 정의를 보여줍니다. 이 목록은 또한 <code>i32</code> 값 슬라이스 또는 <code>char</code> 값으로 함수를 호출하는 방법을 보여줍니다. 이 코드는 아직 컴파일되지 않지만, 이 장의 뒷부분에서 수정할 것입니다.</p>
<Listing number="10-5" file-name="src/main.rs" caption="The `largest` function using generic type parameters; this doesn’t compile yet">
<pre><code class="language-rust ignore does_not_compile">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!("The largest number is {result}");

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!("The largest char is {result}");
}</code></pre>
</Listing>
<p>이 코드를 지금 컴파일하면 다음과 같은 오류가 발생할 것입니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `&amp;T`
 --&gt; src/main.rs:5:17
  |
5 |         if item &gt; largest {
  |            ---- ^ ------- &amp;T
  |            |
  |            &amp;T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; &amp;T {
  |             ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>도움말 텍스트는 _트레이트_인 <code>std::cmp::PartialOrd</code>를 언급하며, 다음 섹션에서 트레이트에 대해 이야기할 것입니다. 지금은 이 오류가 <code>largest</code>의 본문이 <code>T</code>가 될 수 있는 모든 가능한 타입에 대해 작동하지 않을 것임을 나타낸다는 것을 알아두세요. 본문에서 <code>T</code> 타입의 값을 비교하기를 원하므로, 값이 정렬될 수 있는 타입만 사용할 수 있습니다. 비교를 가능하게 하기 위해 표준 라이브러리에는 타입에 구현할 수 있는 <code>std::cmp::PartialOrd</code> 트레이트가 있습니다 (이 트레이트에 대한 자세한 내용은 부록 C를 참조하세요). 도움말 텍스트의 제안을 따르면, <code>T</code>에 유효한 타입을 <code>PartialOrd</code>를 구현하는 타입으로만 제한하며, 표준 라이브러리가 <code>i32</code>와 <code>char</code> 모두에 <code>PartialOrd</code>를 구현하므로 이 예제는 컴파일될 것입니다.</p>
<h3 id="구조체-정의에서"><a class="header" href="#구조체-정의에서">구조체 정의에서</a></h3>
<p>또한 <code>&lt;&gt;</code> 구문을 사용하여 하나 이상의 필드에 제네릭 타입 매개변수를 사용하도록 구조체를 정의할 수 있습니다. 목록 10-6은 어떤 타입의 <code>x</code> 및 <code>y</code> 좌표 값을 저장하는 <code>Point&lt;T&gt;</code> 구조체를 정의합니다.</p>
<Listing number="10-6" file-name="src/main.rs" caption="A `Point<T>` struct that holds `x` and `y` values of type `T`">
<pre><pre class="playground"><code class="language-rust edition2021">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}</code></pre></pre>
</Listing>
<p>구조체 정의에서 제네릭을 사용하는 문법은 함수 정의에서 사용되는 문법과 유사합니다. 먼저 구조체 이름 바로 뒤의 꺾쇠 괄호 안에 타입 매개변수 이름을 선언합니다. 그런 다음 구체적인 데이터 타입을 지정했을 구조체 정의에서 제네릭 타입을 사용합니다.</p>
<p>우리가 <code>Point&lt;T&gt;</code>를 정의하기 위해 하나의 제네릭 타입만 사용했기 때문에, 이 정의는 <code>Point&lt;T&gt;</code> 구조체가 어떤 타입 <code>T</code>에 대해 제네릭이며, <code>x</code>와 <code>y</code> 필드 <em>모두</em> 그 동일한 타입이라는 것을 의미합니다. 그 타입이 무엇이든 말이죠. 만약 목록 10-7과 같이 다른 타입의 값을 가진 <code>Point&lt;T&gt;</code> 인스턴스를 생성하면, 우리 코드는 컴파일되지 않을 것입니다.</p>
<Listing number="10-7" file-name="src/main.rs" caption="The fields `x` and `y` must be the same type because both have the same generic data type `T`.">
<pre><code class="language-rust ignore does_not_compile">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}</code></pre>
</Listing>
<p>이 예제에서 <code>x</code>에 정수 값 <code>5</code>를 할당하면, 컴파일러는 <code>Point&lt;T&gt;</code>의 이 인스턴스에 대해 제네릭 타입 <code>T</code>가 정수임을 알게 됩니다. 그런 다음 <code>x</code>와 동일한 타입을 가지도록 정의한 <code>y</code>에 <code>4.0</code>을 지정하면 다음과 같은 타입 불일치 오류가 발생할 것입니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-point number

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p><code>x</code>와 <code>y</code>가 모두 제네릭이지만 다른 타입을 가질 수 있는 <code>Point</code> 구조체를 정의하려면, 여러 제네릭 타입 매개변수를 사용할 수 있습니다. 예를 들어, 목록 10-8에서는 <code>Point</code>의 정의를 <code>x</code>가 <code>T</code> 타입이고 <code>y</code>가 <code>U</code> 타입인 <code>T</code>와 <code>U</code> 타입에 대해 제네릭으로 변경합니다.</p>
<Listing number="10-8" file-name="src/main.rs" caption="A `Point<T, U>` generic over two types so that `x` and `y` can be values of different types">
<pre><pre class="playground"><code class="language-rust edition2021">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}</code></pre></pre>
</Listing>
<p>이제 표시된 <code>Point</code>의 모든 인스턴스가 허용됩니다! 정의에서 원하는 만큼 많은 제네릭 타입 매개변수를 사용할 수 있지만, 몇 개 이상을 사용하면 코드를 읽기 어려워집니다. 코드에 많은 제네릭 타입이 필요하다고 생각되면, 코드를 더 작은 조각으로 재구성해야 함을 나타낼 수 있습니다.</p>
<h3 id="열거형-정의에서"><a class="header" href="#열거형-정의에서">열거형 정의에서</a></h3>
<p>구조체에서 했던 것처럼, 열거형을 정의하여 variant에 제네릭 데이터 타입을 담을 수 있습니다. 6장에서 사용했던 표준 라이브러리가 제공하는 <code>Option&lt;T&gt;</code> 열거형을 다시 살펴보겠습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}</span></code></pre></pre>
<p>이제 이 정의가 여러분에게 더 이해가 될 것입니다. 보시다시피, <code>Option&lt;T&gt;</code> 열거형은 <code>T</code> 타입에 대해 제네릭이며, <code>T</code> 타입의 값 하나를 담는 <code>Some</code>과 아무 값도 담지 않는 <code>None</code>이라는 두 가지 variant를 가집니다. <code>Option&lt;T&gt;</code> 열거형을 사용함으로써 선택적 값이라는 추상적인 개념을 표현할 수 있으며, <code>Option&lt;T&gt;</code>가 제네릭이므로 선택적 값의 타입이 무엇이든 이 추상화를 사용할 수 있습니다.</p>
<p>열거형은 여러 제네릭 타입을 사용할 수도 있습니다. 9장에서 사용했던 <code>Result</code> 열거형의 정의가 한 예입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p><code>Result</code> 열거형은 <code>T</code>와 <code>E</code> 두 가지 타입에 대해 제네릭이며, <code>T</code> 타입의 값을 담는 <code>Ok</code>와 <code>E</code> 타입의 값을 담는 <code>Err</code> 두 가지 variant를 가집니다. 이 정의는 성공할 수도 있고 (<code>T</code> 타입의 값을 반환) 실패할 수도 있는 (<code>E</code> 타입의 오류를 반환) 작업이 있는 모든 곳에서 <code>Result</code> 열거형을 편리하게 사용할 수 있도록 합니다. 실제로 이것은 목록 9-3에서 파일을 열 때 사용했던 것으로, 파일이 성공적으로 열렸을 때 <code>T</code>는 <code>std::fs::File</code> 타입으로 채워졌고, 파일을 여는 데 문제가 있었을 때 <code>E</code>는 <code>std::io::Error</code> 타입으로 채워졌습니다.</p>
<p>코드에서 값의 타입만 다른 여러 구조체 또는 열거형 정의가 있는 상황을 인식하면, 대신 제네릭 타입을 사용하여 중복을 피할 수 있습니다.</p>
<h3 id="메서드-정의에서"><a class="header" href="#메서드-정의에서">메서드 정의에서</a></h3>
<p>구조체와 열거형에 메서드를 구현하고(5장에서 했던 것처럼) 정의에 제네릭 타입을 사용할 수도 있습니다. 목록 10-9는 목록 10-6에서 정의한 <code>Point&lt;T&gt;</code> 구조체에 <code>x</code>라는 메서드가 구현된 것을 보여줍니다.</p>
<Listing number="10-9" file-name="src/main.rs" caption="Implementing a method named `x` on the `Point<T>` struct that will return a reference to the `x` field of type `T`">
<pre><pre class="playground"><code class="language-rust edition2021">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}</code></pre></pre>
</Listing>
<p>여기서 우리는 <code>Point&lt;T&gt;</code>에 <code>x</code>라는 메서드를 정의했으며, 이 메서드는 필드 <code>x</code>의 데이터에 대한 참조를 반환합니다.</p>
<p><code>impl</code> 바로 뒤에 <code>T</code>를 선언해야 <code>T</code>를 사용하여 <code>Point&lt;T&gt;</code> 타입에 메서드를 구현하고 있음을 지정할 수 있다는 점에 유의하세요. <code>impl</code> 뒤에 <code>T</code>를 제네릭 타입으로 선언함으로써 러스트는 <code>Point</code>의 꺾쇠 괄호 안의 타입이 구체적인 타입이 아닌 제네릭 타입임을 식별할 수 있습니다. 구조체 정의에 선언된 제네릭 매개변수와 다른 이름을 이 제네릭 매개변수에 대해 선택할 수도 있었지만, 동일한 이름을 사용하는 것이 관례입니다. 제네릭 타입을 선언하는 <code>impl</code> 내부에 메서드를 작성하면, 해당 메서드는 어떤 구체적인 타입이 제네릭 타입을 대체하든 상관없이 해당 타입의 모든 인스턴스에 대해 정의될 것입니다.</p>
<p>타입에 메서드를 정의할 때 제네릭 타입에 대한 제약 조건을 지정할 수도 있습니다. 예를 들어, 어떤 제네릭 타입을 가진 <code>Point&lt;T&gt;</code> 인스턴스 대신 <code>Point&lt;f32&gt;</code> 인스턴스에만 메서드를 구현할 수 있습니다. 목록 10-10에서는 구체적인 타입 <code>f32</code>를 사용하며, 이는 <code>impl</code> 뒤에 어떤 타입도 선언하지 않음을 의미합니다.</p>
<Listing number="10-10" file-name="src/main.rs" caption="An `impl` block that only applies to a struct with a particular concrete type for the generic type parameter `T`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct Point&lt;T&gt; {
</span><span class="boring">    x: T,
</span><span class="boring">    y: T,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Point&lt;T&gt; {
</span><span class="boring">    fn x(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.x
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 5, y: 10 };
</span><span class="boring">
</span><span class="boring">    println!("p.x = {}", p.x());
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 코드는 <code>Point&lt;f32&gt;</code> 타입이 <code>distance_from_origin</code> 메서드를 가질 것임을 의미합니다. <code>T</code>가 <code>f32</code> 타입이 아닌 <code>Point&lt;T&gt;</code>의 다른 인스턴스에는 이 메서드가 정의되지 않습니다. 이 메서드는 우리 점이 좌표 (0.0, 0.0)의 점으로부터 얼마나 떨어져 있는지 측정하며, 부동 소수점 타입에만 사용 가능한 수학 연산을 사용합니다.</p>
<p>구조체 정의의 제네릭 타입 매개변수는 항상 동일한 구조체의 메서드 시그니처에서 사용하는 것과 같지 않습니다. 목록 10-11은 예제를 더 명확하게 하기 위해 <code>Point</code> 구조체에 <code>X1</code>과 <code>Y1</code> 제네릭 타입을 사용하고 <code>mixup</code> 메서드 시그니처에 <code>X2</code> <code>Y2</code>를 사용합니다. 이 메서드는 <code>self</code> <code>Point</code> (타입 <code>X1</code>)의 <code>x</code> 값과 전달된 <code>Point</code> (타입 <code>Y2</code>)의 <code>y</code> 값으로 새로운 <code>Point</code> 인스턴스를 생성합니다.</p>
<Listing number="10-11" file-name="src/main.rs" caption="A method that uses generic types different from its struct’s definition">
<pre><pre class="playground"><code class="language-rust edition2021">struct Point&lt;X1, Y1&gt; {
    x: X1,
    y: Y1,
}

impl&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; {
    fn mixup&lt;X2, Y2&gt;(self, other: Point&lt;X2, Y2&gt;) -&gt; Point&lt;X1, Y2&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c' };

    let p3 = p1.mixup(p2);

    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}</code></pre></pre>
</Listing>
<p><code>main</code>에서 우리는 <code>x</code>에 <code>i32</code> (값 <code>5</code>)를, <code>y</code>에 <code>f64</code> (값 <code>10.4</code>)를 가진 <code>Point</code>를 정의했습니다. <code>p2</code> 변수는 <code>x</code>에 문자열 슬라이스 (값 <code>"Hello"</code>)를, <code>y</code>에 <code>char</code> (값 <code>c</code>)를 가진 <code>Point</code> 구조체입니다. <code>p1</code>에 <code>p2</code> 인수를 사용하여 <code>mixup</code>을 호출하면 <code>p3</code>를 얻게 되는데, <code>x</code>는 <code>p1</code>에서 왔으므로 <code>p3</code>는 <code>x</code>에 <code>i32</code>를 가질 것입니다. <code>p3</code> 변수는 <code>y</code>에 <code>char</code>를 가질 것인데, <code>y</code>는 <code>p2</code>에서 왔기 때문입니다. <code>println!</code> 매크로 호출은 <code>p3.x = 5, p3.y = c</code>를 출력할 것입니다.</p>
<p>이 예제의 목적은 일부 제네릭 매개변수가 <code>impl</code>로 선언되고 일부는 메서드 정의로 선언되는 상황을 보여주는 것입니다. 여기서 제네릭 매개변수 <code>X1</code>과 <code>Y1</code>은 구조체 정의와 함께 사용되므로 <code>impl</code> 뒤에 선언됩니다. 제네릭 매개변수 <code>X2</code>와 <code>Y2</code>는 메서드에만 관련되므로 <code>fn mixup</code> 뒤에 선언됩니다.</p>
<h3 id="제네릭을-사용하는-코드의-성능"><a class="header" href="#제네릭을-사용하는-코드의-성능">제네릭을 사용하는 코드의 성능</a></h3>
<p>제네릭 타입 매개변수를 사용할 때 런타임 비용이 발생하는지 궁금할 수 있습니다. 좋은 소식은 제네릭 타입을 사용해도 구체적인 타입을 사용할 때보다 프로그램 실행 속도가 느려지지 않는다는 것입니다.</p>
<p>러스트는 컴파일 시 제네릭을 사용하는 코드의 단형성(monomorphization)을 수행하여 이를 달성합니다. _단형성_은 컴파일될 때 사용되는 구체적인 타입을 채워 제네릭 코드를 특정 코드로 변환하는 과정입니다. 이 과정에서 컴파일러는 목록 10-5에서 제네릭 함수를 생성하는 데 사용했던 단계와 반대되는 작업을 수행합니다. 컴파일러는 제네릭 코드가 호출되는 모든 위치를 살펴보고 제네릭 코드가 호출되는 구체적인 타입에 대한 코드를 생성합니다.</p>
<p>표준 라이브러리의 제네릭 <code>Option&lt;T&gt;</code> 열거형을 사용하여 이것이 어떻게 작동하는지 살펴보겠습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let integer = Some(5);
let float = Some(5.0);
<span class="boring">}</span></code></pre></pre>
<p>러스트가 이 코드를 컴파일할 때, 단형성(monomorphization)을 수행합니다. 이 과정에서 컴파일러는 <code>Option&lt;T&gt;</code> 인스턴스에서 사용된 값을 읽고 두 가지 종류의 <code>Option&lt;T&gt;</code>를 식별합니다. 하나는 <code>i32</code>이고 다른 하나는 <code>f64</code>입니다. 따라서 <code>Option&lt;T&gt;</code>의 제네릭 정의를 <code>i32</code>와 <code>f64</code>에 특화된 두 가지 정의로 확장하여 제네릭 정의를 특정 정의로 대체합니다.</p>
<p>단형성된 코드 버전은 다음(컴파일러는 여기에서 설명 목적으로 사용하는 이름과 다른 이름을 사용합니다)과 유사하게 보입니다:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}</code></pre></pre>
</Listing>
<p>제네릭 <code>Option&lt;T&gt;</code>는 컴파일러가 생성한 특정 정의로 대체됩니다. 러스트는 제네릭 코드를 각 인스턴스에서 타입을 지정하는 코드로 컴파일하기 때문에, 제네릭을 사용해도 런타임 비용이 발생하지 않습니다. 코드가 실행될 때, 각 정의를 수동으로 복제한 것과 동일하게 작동합니다. 단형성(monomorphization) 과정은 러스트의 제네릭을 런타임에 매우 효율적으로 만듭니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch10-00-generics.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch10-02-traits.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch10-00-generics.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch10-02-traits.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
