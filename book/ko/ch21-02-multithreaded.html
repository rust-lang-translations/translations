<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>단일 스레드 서버를 멀티스레드 서버로 바꾸기 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch21-02-multithreaded.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch21-02-multithreaded.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="단일-스레드-서버를-멀티스레드-서버로-바꾸기"><a class="header" href="#단일-스레드-서버를-멀티스레드-서버로-바꾸기">단일 스레드 서버를 멀티스레드 서버로 바꾸기</a></h2>
<p>현재 서버는 각 요청을 차례대로 처리합니다. 즉, 첫 번째 연결 처리가 끝날 때까지 두 번째 연결을 처리하지 않습니다. 서버가 점점 더 많은 요청을 받게 되면, 이러한 순차적 실행은 점점 비효율적이 될 것입니다. 만약 서버가 처리하는 데 오랜 시간이 걸리는 요청을 받으면, 새로운 요청들이 빠르게 처리될 수 있더라도 긴 요청이 끝날 때까지 기다려야 합니다. 우리는 이를 해결해야 하지만, 먼저 문제가 실제로 발생하는 모습을 살펴보겠습니다.</p>
<h3 id="현재-서버-구현에서-느린-요청-시뮬레이션하기"><a class="header" href="#현재-서버-구현에서-느린-요청-시뮬레이션하기">현재 서버 구현에서 느린 요청 시뮬레이션하기</a></h3>
<p>처리가 느린 요청이 현재 서버 구현에 대한 다른 요청들에 어떤 영향을 미치는지 살펴보겠습니다. 예제 21-10은 _/sleep_에 대한 요청을 처리하는데, 응답하기 전에 서버를 5초 동안 재우는 방식으로 느린 응답을 시뮬레이션합니다.</p>
<Listing number="21-10" file-name="src/main.rs" caption="Simulating a slow request by sleeping for 5 seconds">
<pre><pre class="playground"><code class="language-rust no_run edition2021">use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
    thread,
    time::Duration,
};
// --생략--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn handle_connection(mut stream: TcpStream) {
    // --생략--

<span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span>    let (status_line, filename) = match &amp;request_line[..] {
        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
        "GET /sleep HTTP/1.1" =&gt; {
            thread::sleep(Duration::from_secs(5));
            ("HTTP/1.1 200 OK", "hello.html")
        }
        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
    };

    // --생략--
<span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span>}</code></pre></pre>
</Listing>
<p>이제 세 가지 케이스가 생겼으므로 <code>if</code>에서 <code>match</code>로 전환했습니다. 문자열 리터럴 값에 대해 패턴 매칭을 수행하려면 <code>request_line</code>의 슬라이스에 대해 명시적으로 매칭해야 합니다. <code>match</code>는 상등 비교(equality) 메서드와 달리 자동 참조 및 역참조를 수행하지 않기 때문입니다.</p>
<p>첫 번째 암(arm)은 예제 21-9의 <code>if</code> 블록과 동일합니다. 두 번째 암은 _/sleep_에 대한 요청과 매칭됩니다. 해당 요청이 수신되면, 서버는 성공 HTML 페이지를 렌더링하기 전에 5초 동안 잠들 것입니다. 세 번째 암은 예제 21-9의 <code>else</code> 블록과 동일합니다.</p>
<p>우리 서버가 얼마나 원시적인지 알 수 있습니다. 실제 라이브러리라면 훨씬 덜 장황한 방식으로 여러 요청을 식별하고 처리했을 것입니다!</p>
<p><code>cargo run</code>으로 서버를 시작하세요. 그런 다음 브라우저 창을 두 개 여세요. 하나는 _http://127.0.0.1:7878/_용이고 다른 하나는 _http://127.0.0.1:7878/sleep_용입니다. 이전처럼 <em>/</em> URI를 몇 번 입력하면 빠르게 응답하는 것을 볼 수 있습니다. 하지만 _/sleep_을 입력한 직후에 _/_를 로드하면, _/_는 <code>sleep</code>이 5초 동안 완전히 잠든 후에야 로드되는 것을 보게 될 것입니다.</p>
<p>느린 요청 뒤로 요청들이 밀리는 것을 방지하기 위해 사용할 수 있는 여러 기술이 있습니다. 17장에서 했던 것처럼 비동기(async)를 사용하는 것도 그중 하나입니다. 우리가 구현할 방법은 스레드 풀(thread pool)입니다.</p>
<h3 id="스레드-풀을-사용하여-처리량-개선하기"><a class="header" href="#스레드-풀을-사용하여-처리량-개선하기">스레드 풀을 사용하여 처리량 개선하기</a></h3>
<p>_스레드 풀(thread pool)_은 작업을 처리할 준비를 하고 대기 중인 생성된 스레드들의 집합입니다. 프로그램이 새로운 작업을 받으면 풀에 있는 스레드 중 하나를 해당 작업에 할당하고, 그 스레드가 작업을 처리합니다. 풀의 나머지 스레드들은 첫 번째 스레드가 작업을 처리하는 동안 들어오는 다른 작업들을 처리할 수 있습니다. 첫 번째 스레드가 작업 처리를 마치면 다시 유휴 스레드 풀로 돌아가 새로운 작업을 처리할 준비를 합니다. 스레드 풀을 사용하면 연결을 동시에 처리할 수 있어 서버의 처리량을 높일 수 있습니다.</p>
<p>DoS 공격으로부터 서버를 보호하기 위해 풀의 스레드 개수를 적은 수로 제한할 것입니다. 요청이 들어올 때마다 프로그램이 새로운 스레드를 생성하게 한다면, 누군가 우리 서버에 천만 개의 요청을 보냈을 때 서버의 모든 리소스를 소모하여 요청 처리가 중단되는 대혼란을 야기할 수 있기 때문입니다.</p>
<p>제한 없이 스레드를 생성하는 대신, 풀에서 대기하는 스레드의 개수를 고정할 것입니다. 들어오는 요청들은 처리를 위해 풀로 보내집니다. 풀은 들어오는 요청들의 큐(queue)를 유지 관리합니다. 풀의 각 스레드는 이 큐에서 요청을 하나씩 꺼내어 처리한 다음, 다시 큐에 다음 요청을 요청합니다. 이 설계를 통해 우리는 스레드 개수인 _<code>N</code>_개까지의 요청을 동시에 처리할 수 있습니다. 만약 각 스레드가 오래 걸리는 요청에 응답하고 있다면 후속 요청들이 여전히 큐에서 밀릴 수 있겠지만, 그 지점에 도달하기 전까지 우리가 처리할 수 있는 오래 걸리는 요청의 개수를 늘린 셈입니다.</p>
<p>이 기술은 웹 서버의 처리량을 향상시키는 여러 방법 중 하나일 뿐입니다. 여러분이 탐구해 볼 수 있는 다른 옵션으로는 fork/join 모델, 단일 스레드 비동기 I/O 모델, 그리고 멀티 스레드 비동기 I/O 모델 등이 있습니다. 이 주제에 관심이 있다면 다른 솔루션들에 대해 더 읽어보고 직접 구현해 보세요. 러스트와 같은 저수준 언어를 사용하면 이러한 모든 옵션이 가능합니다.</p>
<p>스레드 풀 구현을 시작하기 전에, 풀을 사용하는 모습이 어떠해야 하는지 이야기해 봅시다. 코드를 설계할 때 클라이언트 인터페이스를 먼저 작성하는 것이 설계의 방향을 잡는 데 도움이 될 수 있습니다. 호출하고 싶은 방식대로 코드의 API 구조를 먼저 잡으세요. 그런 다음 기능을 먼저 구현하고 나중에 공개 API를 설계하는 대신, 그 구조 안에서 기능을 구현하세요.</p>
<p>12장의 프로젝트에서 테스트 주도 개발(TDD)을 사용했던 것과 유사하게, 여기서는 컴파일러 주도 개발을 사용할 것입니다. 우리가 원하는 함수를 호출하는 코드를 먼저 작성하고, 컴파일러가 내뱉는 에러를 보면서 코드가 작동하게 하기 위해 다음에 무엇을 변경해야 할지 결정할 것입니다. 하지만 그전에, 시작점으로 사용하지 <em>않을</em> 기술에 대해 먼저 살펴보겠습니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="code-structure-if-we-could-spawn-a-thread-for-each-request"></a></p>
<h4 id="각-요청에-대해-스레드-생성하기"><a class="header" href="#각-요청에-대해-스레드-생성하기">각 요청에 대해 스레드 생성하기</a></h4>
<p>먼저, 모든 연결에 대해 새로운 스레드를 생성한다면 코드가 어떻게 보일지 살펴보겠습니다. 앞서 언급했듯이, 제한 없이 스레드를 생성할 수 있다는 문제점 때문에 이것이 우리의 최종 계획은 아닙니다. 하지만 작동하는 멀티스레드 서버를 먼저 만들기 위한 시작점으로는 적합합니다. 그런 다음 개선 사항으로 스레드 풀을 추가하면 두 솔루션을 대조하기가 더 쉬울 것입니다. 예제 21-11은 <code>for</code> 루프 내에서 각 스트림을 처리하기 위해 새로운 스레드를 생성하도록 <code>main</code>을 수정한 내용을 보여줍니다.</p>
<Listing number="21-11" file-name="src/main.rs" caption="Spawning a new thread for each stream">
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
</span><span class="boring">        "GET /sleep HTTP/1.1" =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            ("HTTP/1.1 200 OK", "hello.html")
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>16장에서 배웠듯이, <code>thread::spawn</code>은 새로운 스레드를 생성하고 클로저 안의 코드를 실행합니다. 이 코드를 실행하고 브라우저에서 _/sleep_을 로드한 다음, 두 개의 다른 탭에서 _/_를 로드해 보세요. 실제로 _/_에 대한 요청들이 _/sleep_이 끝나기를 기다릴 필요가 없음을 확인할 수 있을 것입니다. 하지만 앞서 언급했듯이, 제한 없이 새로운 스레드를 계속 만들게 되면 결국 시스템에 과부하를 주게 될 것입니다.</p>
<p>또한 17장에서 배웠던 것처럼, 이러한 상황이 바로 async와 await가 진정으로 빛을 발하는 지점입니다! 스레드 풀을 구축하면서 async를 사용했을 때와 무엇이 다르고 무엇이 같을지 생각하며 이 점을 염두에 두세요.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="creating-a-similar-interface-for-a-finite-number-of-threads"></a></p>
<h4 id="유한한-개수의-스레드-생성하기"><a class="header" href="#유한한-개수의-스레드-생성하기">유한한 개수의 스레드 생성하기</a></h4>
<p>우리는 우리 API를 사용하는 코드에 큰 변화를 주지 않고도 스레드 방식에서 스레드 풀 방식으로 전환할 수 있도록, 스레드 풀이 유사하고 친숙한 방식으로 작동하기를 원합니다. 예제 21-12는 <code>thread::spawn</code> 대신 사용하고 싶은 <code>ThreadPool</code> 구조체의 가상 인터페이스를 보여줍니다.</p>
<Listing number="21-12" file-name="src/main.rs" caption="Our ideal `ThreadPool` interface">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
</span><span class="boring">        "GET /sleep HTTP/1.1" =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            ("HTTP/1.1 200 OK", "hello.html")
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre>
</Listing>
<p>우리는 <code>ThreadPool::new</code>를 사용하여 설정 가능한 개수(여기서는 4개)의 스레드를 가진 새로운 스레드 풀을 생성합니다. 그런 다음 <code>for</code> 루프 내에서 <code>pool.execute</code>는 <code>thread::spawn</code>과 유사한 인터페이스를 가지며, 각 스트림에 대해 풀이 실행해야 할 클로저를 인수로 받습니다. 우리는 <code>pool.execute</code>가 클로저를 받아 풀에 있는 스레드에게 전달하여 실행하도록 구현해야 합니다. 이 코드는 아직 컴파일되지 않지만, 컴파일러가 해결 방법을 알려줄 수 있도록 시도해 보겠습니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="building-the-threadpool-struct-using-compiler-driven-development"></a></p>
<h4 id="컴파일러-주도-개발로-threadpool-구축하기"><a class="header" href="#컴파일러-주도-개발로-threadpool-구축하기">컴파일러 주도 개발로 <code>ThreadPool</code> 구축하기</a></h4>
<p>예제 21-12의 변경 사항을 _src/main.rs_에 적용한 다음, <code>cargo check</code>에서 발생하는 컴파일러 에러를 이용해 개발을 진행해 봅시다. 우리가 받게 될 첫 번째 에러는 다음과 같습니다.</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0433]: failed to resolve: use of undeclared type `ThreadPool`
  --&gt; src/main.rs:11:16
   |
11 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^ use of undeclared type `ThreadPool`

For more information about this error, try `rustc --explain E0433`.
error: could not compile `hello` (bin "hello") due to 1 previous error
</code></pre>
<p>좋습니다! 이 에러는 <code>ThreadPool</code> 타입이나 모듈이 필요하다는 것을 알려주므로, 이제 그것을 만들겠습니다. 우리의 <code>ThreadPool</code> 구현은 웹 서버가 하는 작업의 종류와는 독립적일 것입니다. 따라서 <code>hello</code> 크레이트를 바이너리 크레이트에서 <code>ThreadPool</code> 구현을 담을 라이브러리 크레이트로 전환해 봅시다. 라이브러리 크레이트로 변경한 후에는, 웹 요청을 처리하는 것뿐만 아니라 스레드 풀을 사용하는 모든 작업에 이 별도의 스레드 풀 라이브러리를 사용할 수 있게 됩니다.</p>
<p>현재로서 가질 수 있는 가장 단순한 형태의 <code>ThreadPool</code> 구조체 정의를 포함하는 <em>src/lib.rs</em> 파일을 생성하세요.</p>
<Listing file-name="src/lib.rs">
<pre><code class="language-rust noplayground">pub struct ThreadPool;</code></pre>
</Listing>
<p>그런 다음 <em>src/main.rs</em> 상단에 다음 코드를 추가하여 라이브러리 크레이트로부터 <code>ThreadPool</code>을 스코프로 가져오도록 수정하세요.</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore">use hello::ThreadPool;
<span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">    let pool = ThreadPool::new(4);
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        pool.execute(|| {
</span><span class="boring">            handle_connection(stream);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
</span><span class="boring">        "GET /sleep HTTP/1.1" =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            ("HTTP/1.1 200 OK", "hello.html")
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre>
</Listing>
<p>이 코드는 여전히 작동하지 않지만, 우리가 해결해야 할 다음 에러를 확인하기 위해 다시 체크해 봅시다.</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no function or associated item named `new` found for struct `ThreadPool` in the current scope
  --&gt; src/main.rs:12:28
   |
12 |     let pool = ThreadPool::new(4);
   |                            ^^^ function or associated item not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` (bin "hello") due to 1 previous error
</code></pre>
<p>이 에러는 다음으로 <code>ThreadPool</code>에 대한 <code>new</code>라는 이름의 연관 함수를 만들어야 함을 나타냅니다. 또한 <code>new</code>는 <code>4</code>를 인수로 받을 수 있는 하나의 파라미터를 가져야 하고 <code>ThreadPool</code> 인스턴스를 반환해야 한다는 것도 알고 있습니다. 이러한 특성을 가진 가장 단순한 <code>new</code> 함수를 구현해 봅시다.</p>
<Listing file-name="src/lib.rs">
<pre><code class="language-rust noplayground">pub struct ThreadPool;

impl ThreadPool {
    pub fn new(size: usize) -&gt; ThreadPool {
        ThreadPool
    }
}</code></pre>
</Listing>
<p>스레드 개수가 음수가 되는 것은 말이 되지 않으므로 <code>size</code> 파라미터의 타입으로 <code>usize</code>를 선택했습니다. 또한 3장의 <a href="ch03-02-data-types.html#integer-types">“정수 타입”</a><!-- ignore -->에서 논의한 것처럼, 이 <code>4</code>를 스레드 컬렉션의 요소 개수로 사용할 것이기 때문에 <code>usize</code> 타입이 적합합니다.</p>
<p>코드를 다시 체크해 봅시다.</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `execute` found for struct `ThreadPool` in the current scope
  --&gt; src/main.rs:17:14
   |
17 |         pool.execute(|| {
   |         -----^^^^^^^ method not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` (bin "hello") due to 1 previous error
</code></pre>
<p>이제 에러가 발생하는 이유는 <code>ThreadPool</code>에 <code>execute</code> 메서드가 없기 때문입니다. <a href="#creating-a-finite-number-of-threads">“유한한 개수의 스레드 생성하기”</a><!-- ignore --> 섹션에서 우리 스레드 풀이 <code>thread::spawn</code>과 유사한 인터페이스를 가져야 한다고 결정했던 것을 상기해 보세요. 추가적으로, 우리는 <code>execute</code> 함수가 받은 클로저를 풀에 있는 유휴 스레드에게 전달하여 실행하도록 구현할 것입니다.</p>
<p><code>ThreadPool</code>에 클로저를 파라미터로 받는 <code>execute</code> 메서드를 정의하겠습니다. 13장의 <a href="ch13-01-closures.html#moving-captured-values-out-of-the-closure-and-the-fn-traits">“클로저 밖으로 캡처한 값 이동하기와 <code>Fn</code> 트레이트”</a><!-- ignore --> 섹션에서 세 가지 다른 트레이트(<code>Fn</code>, <code>FnMut</code>, <code>FnOnce</code>)를 통해 클로저를 파라미터로 받을 수 있음을 배웠던 것을 상기해 보세요. 여기서는 어떤 종류의 클로저를 사용할지 결정해야 합니다. 우리는 결국 표준 라이브러리의 <code>thread::spawn</code> 구현과 유사한 작업을 하게 될 것이므로, <code>thread::spawn</code> 시그니처가 파라미터에 어떤 바운드를 가지고 있는지 살펴볼 수 있습니다. 문서는 다음과 같이 보여줍니다.</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static,</code></pre>
<p>여기서 우리가 관심을 갖는 것은 <code>F</code> 타입 파라미터입니다. <code>T</code> 타입 파라미터는 반환값과 관련된 것이며 여기서는 고려하지 않습니다. <code>spawn</code>이 <code>F</code>에 대한 트레이트 바운드로 <code>FnOnce</code>를 사용함을 알 수 있습니다. 우리가 <code>execute</code>에서 받은 인수를 결국 <code>spawn</code>으로 전달할 것이기 때문에, 이것이 우리가 원하는 것일 가능성이 큽니다. 또한 요청을 실행하기 위한 스레드는 해당 요청의 클로저를 단 한 번만 실행할 것이기 때문에, <code>FnOnce</code>의 <code>Once</code>와 의미상 일치한다는 점에서도 <code>FnOnce</code>가 적합함을 확신할 수 있습니다.</p>
<p><code>F</code> 타입 파라미터는 또한 <code>Send</code> 트레이트 바운드와 <code>'static</code> 라이프타임 바운드를 가지고 있는데, 이는 우리 상황에서도 유용합니다. 클로저를 한 스레드에서 다른 스레드로 전송하려면 <code>Send</code>가 필요하고, 스레드가 실행되는 데 얼마나 걸릴지 알 수 없으므로 <code>'static</code>이 필요합니다. 이러한 바운드를 가진 제네릭 파라미터 <code>F</code>를 받는 <code>ThreadPool</code>의 <code>execute</code> 메서드를 만들어 봅시다.</p>
<Listing file-name="src/lib.rs">
<pre><code class="language-rust noplayground"><span class="boring">pub struct ThreadPool;
</span><span class="boring">
</span>impl ThreadPool {
    // --생략--
<span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        ThreadPool
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
    }
}</code></pre>
</Listing>
<p><code>FnOnce</code> 뒤에 여전히 <code>()</code>를 사용하는데, 이는 이 <code>FnOnce</code>가 파라미터가 없고 유닛 타입 <code>()</code>을 반환하는 클로저를 나타내기 때문입니다. 함수 정의와 마찬가지로 반환 타입은 시그니처에서 생략될 수 있지만, 파라미터가 없더라도 괄호는 필요합니다.</p>
<p>다시 말하지만, 이는 <code>execute</code> 메서드의 가장 단순한 구현입니다. 아무 일도 하지 않지만, 우리는 단지 코드를 컴파일하려는 것입니다. 다시 체크해 봅시다.</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.24s
</code></pre>
<p>컴파일이 됩니다! 하지만 <code>cargo run</code>을 실행하고 브라우저에서 요청을 보내면, 이 장의 시작 부분에서 보았던 것과 같은 에러가 브라우저에 나타날 것입니다. 우리 라이브러리가 아직 <code>execute</code>에 전달된 클로저를 실제로 호출하고 있지 않기 때문입니다!</p>
<blockquote>
<p>참고: 하스켈이나 러스트처럼 엄격한 컴파일러를 가진 언어에 대해 “코드가 컴파일되면 작동한다”는 말을 들어보셨을 수도 있습니다. 하지만 이 말이 항상 진실인 것은 아닙니다. 우리 프로젝트는 컴파일되지만 아무 일도 하지 않습니다! 만약 우리가 실제의 완전한 프로젝트를 구축하고 있다면, 지금이 코드가 컴파일되는지뿐만 아니라 우리가 원하는 대로 동작하는지 확인하기 위해 유닛 테스트를 작성하기 시작할 좋은 시간일 것입니다.</p>
</blockquote>
<p>생각해 보세요. 만약 우리가 클로저 대신 _퓨처(future)_를 실행하려고 한다면 여기에서 무엇이 달라질까요?</p>
<h4 id="new에서-스레드-개수-검증하기"><a class="header" href="#new에서-스레드-개수-검증하기"><code>new</code>에서 스레드 개수 검증하기</a></h4>
<p>우리는 아직 <code>new</code>와 <code>execute</code>의 파라미터를 사용하여 아무것도 하고 있지 않습니다. 이 함수들의 본문을 우리가 원하는 동작으로 구현해 봅시다. 먼저 <code>new</code>에 대해 생각해 봅시다. 앞서 우리는 스레드 개수가 음수인 풀은 말이 되지 않기 때문에 <code>size</code> 파라미터에 부호 없는 타입을 선택했습니다. 하지만 스레드가 0개인 풀 또한 말이 되지 않는데, 0은 완전히 유효한 <code>usize</code> 값입니다. 예제 21-13에 표시된 대로 <code>assert!</code> 매크로를 사용하여 <code>size</code>가 0보다 큰지 확인하는 코드를 추가하고, 0을 받으면 프로그램이 패닉을 일으키도록 하겠습니다.</p>
<Listing number="21-13" file-name="src/lib.rs" caption="Implementing `ThreadPool::new` to panic if `size` is zero">
<pre><code class="language-rust noplayground"><span class="boring">pub struct ThreadPool;
</span><span class="boring">
</span>impl ThreadPool {
    /// 새로운 ThreadPool을 생성합니다.
    ///
    /// size는 풀의 스레드 개수입니다.
    ///
    /// # Panics
    ///
    /// `new` 함수는 size가 0일 경우 패닉을 일으킵니다.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        ThreadPool
    }

    // --생략--
<span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}</code></pre>
</Listing>
<p>또한 문서 주석(doc comments)을 사용하여 <code>ThreadPool</code>에 대한 문서도 추가했습니다. 14장에서 논의한 것처럼 우리 함수가 패닉을 일으킬 수 있는 상황을 명시하는 섹션을 추가하여 좋은 문서화 관례를 따랐습니다. <code>cargo doc --open</code>을 실행하고 <code>ThreadPool</code> 구조체를 클릭하여 <code>new</code>에 대해 생성된 문서가 어떻게 보이는지 확인해 보세요!</p>
<p>여기서 한 것처럼 <code>assert!</code> 매크로를 추가하는 대신, 12장의 예제 12-9에서 I/O 프로젝트의 <code>Config::build</code>에서 했던 것처럼 <code>new</code>를 <code>build</code>로 바꾸고 <code>Result</code>를 반환하도록 할 수도 있습니다. 하지만 이번 사례에서는 스레드가 하나도 없는 스레드 풀을 생성하려는 시도를 복구 불가능한 에러로 처리하기로 결정했습니다. 도전해 보고 싶다면, <code>new</code> 함수와 비교해 볼 수 있도록 다음과 같은 시그니처를 가진 <code>build</code> 함수를 작성해 보세요.</p>
<pre><code class="language-rust ignore">pub fn build(size: usize) -&gt; Result&lt;ThreadPool, PoolCreationError&gt; {</code></pre>
<h4 id="스레드를-저장할-공간-만들기"><a class="header" href="#스레드를-저장할-공간-만들기">스레드를 저장할 공간 만들기</a></h4>
<p>이제 풀에 저장할 유효한 스레드 개수를 알 수 있는 방법이 생겼으므로, 구조체를 반환하기 전에 해당 스레드들을 생성하여 <code>ThreadPool</code> 구조체에 저장할 수 있습니다. 그런데 스레드를 어떻게 “저장”할까요? <code>thread::spawn</code> 시그니처를 다시 살펴봅시다.</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static,</code></pre>
<p><code>spawn</code> 함수는 <code>JoinHandle&lt;T&gt;</code>를 반환하는데, 여기서 <code>T</code>는 클로저가 반환하는 타입입니다. 우리도 <code>JoinHandle</code>을 사용하여 어떤 일이 일어나는지 살펴봅시다. 우리 경우에 스레드 풀로 전달하는 클로저들은 연결을 처리하고 아무것도 반환하지 않으므로, <code>T</code>는 유닛 타입 <code>()</code>이 될 것입니다.</p>
<p>예제 21-14의 코드는 컴파일되지만 아직 스레드를 생성하지는 않습니다. 우리는 <code>ThreadPool</code> 정의를 <code>thread::JoinHandle&lt;()&gt;</code> 인스턴스들의 벡터를 갖도록 변경하고, <code>size</code>만큼의 용량으로 벡터를 초기화했으며, 스레드를 생성하는 코드를 실행할 <code>for</code> 루프를 설정하고, 이를 포함하는 <code>ThreadPool</code> 인스턴스를 반환했습니다.</p>
<Listing number="21-14" file-name="src/lib.rs" caption="Creating a vector for `ThreadPool` to hold the threads">
<pre><code class="language-rust ignore not_desired_behavior">use std::thread;

pub struct ThreadPool {
    threads: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl ThreadPool {
    // --생략--
<span class="boring">    /// 새로운 ThreadPool을 생성합니다.
</span><span class="boring">    ///
</span><span class="boring">    /// size는 풀의 스레드 개수입니다.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// `new` 함수는 size가 0일 경우 패닉을 일으킵니다.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut threads = Vec::with_capacity(size);

        for _ in 0..size {
            // 스레드들을 생성하고 벡터에 저장합니다.
        }

        ThreadPool { threads }
    }
    // --생략--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}</code></pre>
</Listing>
<p><code>ThreadPool</code> 내 벡터의 아이템 타입으로 <code>thread::JoinHandle</code>을 사용하고 있으므로, 라이브러리 크레이트에서 <code>std::thread</code>를 스코프로 가져왔습니다.</p>
<p>유효한 크기를 받으면, <code>ThreadPool</code>은 <code>size</code>개의 아이템을 담을 수 있는 새로운 벡터를 생성합니다. <code>with_capacity</code> 함수는 <code>Vec::new</code>와 동일한 작업을 수행하지만 한 가지 중요한 차이점이 있습니다. 바로 벡터에 공간을 미리 할당한다는 점입니다. 우리는 벡터에 <code>size</code>개의 요소를 저장해야 한다는 것을 알고 있으므로, 요소가 삽입될 때마다 크기를 조정하는 <code>Vec::new</code>를 사용하는 것보다 미리 할당하는 것이 약간 더 효율적입니다.</p>
<p><code>cargo check</code>를 다시 실행하면 성공할 것입니다.</p>
<h4 id="threadpool에서-스레드로-코드를-보내는-책임을-갖는-worker-구조체"><a class="header" href="#threadpool에서-스레드로-코드를-보내는-책임을-갖는-worker-구조체"><code>ThreadPool</code>에서 스레드로 코드를 보내는 책임을 갖는 <code>Worker</code> 구조체</a></h4>
<p>예제 21-14의 <code>for</code> 루프에 스레드 생성에 관한 주석을 남겨두었습니다. 여기서는 실제로 스레드를 어떻게 생성하는지 살펴보겠습니다. 표준 라이브러리는 스레드를 생성하는 방법으로 <code>thread::spawn</code>을 제공하며, <code>thread::spawn</code>은 스레드가 생성되자마자 실행할 코드를 인수로 기대합니다. 하지만 우리의 경우, 스레드를 먼저 생성해 두고 나중에 보낼 코드를 <em>기다리게</em> 하고 싶습니다. 표준 라이브러리의 스레드 구현에는 이를 수행할 수 있는 방법이 포함되어 있지 않으므로, 우리가 직접 구현해야 합니다.</p>
<p>우리는 <code>ThreadPool</code>과 스레드 사이에 이 새로운 동작을 관리할 새로운 데이터 구조를 도입하여 이를 구현할 것입니다. 이 데이터 구조를 _워커(Worker)_라고 부르겠으며, 이는 풀링(pooling) 구현에서 흔히 사용되는 용어입니다. <code>Worker</code>는 실행되어야 할 코드를 가져와 자신의 스레드에서 해당 코드를 실행합니다.</p>
<p>식당 주방에서 일하는 사람들을 생각해 보세요. 워커들은 고객으로부터 주문이 들어올 때까지 기다렸다가, 주문을 받아서 처리하는 책임을 집니다.</p>
<p>스레드 풀에 <code>JoinHandle&lt;()&gt;</code> 인스턴스들의 벡터를 저장하는 대신, <code>Worker</code> 구조체의 인스턴스들을 저장할 것입니다. 각 <code>Worker</code>는 단일 <code>JoinHandle&lt;()&gt;</code> 인스턴스를 저장합니다. 그런 다음 <code>Worker</code>에 실행할 코드 클로저를 받아서 이미 실행 중인 스레드로 보내 실행하게 하는 메서드를 구현할 것입니다. 또한 로깅이나 디버깅 시 풀 내의 서로 다른 <code>Worker</code> 인스턴스들을 구분할 수 있도록 각 <code>Worker</code>에게 <code>id</code>를 부여하겠습니다.</p>
<p><code>ThreadPool</code>을 생성할 때 일어날 새로운 프로세스는 다음과 같습니다. <code>Worker</code>를 이런 방식으로 설정한 후에 클로저를 스레드로 보내는 코드를 구현할 것입니다.</p>
<ol>
<li><code>id</code>와 <code>JoinHandle&lt;()&gt;</code>을 갖는 <code>Worker</code> 구조체를 정의합니다.</li>
<li><code>ThreadPool</code>이 <code>Worker</code> 인스턴스들의 벡터를 갖도록 변경합니다.</li>
<li><code>id</code> 번호를 받아서 해당 <code>id</code>와 빈 클로저로 생성된 스레드를 갖는 <code>Worker</code> 인스턴스를 반환하는 <code>Worker::new</code> 함수를 정의합니다.</li>
<li><code>ThreadPool::new</code> 내에서 <code>for</code> 루프 카운터를 사용하여 <code>id</code>를 생성하고, 해당 <code>id</code>로 새로운 <code>Worker</code>를 생성한 뒤 이를 벡터에 저장합니다.</li>
</ol>
<p>도전해 보고 싶다면, 예제 21-15의 코드를 보기 전에 직접 이 변경 사항들을 구현해 보세요.</p>
<p>준비되셨나요? 예제 21-15는 앞서 설명한 수정을 수행하는 한 가지 방법을 보여줍니다.</p>
<Listing number="21-15" file-name="src/lib.rs" caption="Modifying `ThreadPool` to hold `Worker` instances instead of holding threads directly">
<pre><code class="language-rust noplayground">use std::thread;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
}

impl ThreadPool {
    // --생략--
<span class="boring">    /// 새로운 ThreadPool을 생성합니다.
</span><span class="boring">    ///
</span><span class="boring">    /// size는 풀의 스레드 개수입니다.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// `new` 함수는 size가 0일 경우 패닉을 일으킵니다.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers }
    }
    // --생략--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

struct Worker {
    id: usize,
    thread: thread::JoinHandle&lt;()&gt;,
}

impl Worker {
    fn new(id: usize) -&gt; Worker {
        let thread = thread::spawn(|| {});

        Worker { id, thread }
    }
}</code></pre>
</Listing>
<p>이제 <code>ThreadPool</code>이 <code>JoinHandle&lt;()&gt;</code> 인스턴스 대신 <code>Worker</code> 인스턴스들을 갖게 되었으므로 필드 이름을 <code>threads</code>에서 <code>workers</code>로 변경했습니다. <code>for</code> 루프의 카운터를 <code>Worker::new</code> 함수의 인수로 사용하고, 새로 생성된 각 <code>Worker</code>를 <code>workers</code>라는 이름의 벡터에 저장합니다.</p>
<p>외부 코드( _src/main.rs_에 있는 서버 등)는 <code>ThreadPool</code> 내부에서 <code>Worker</code> 구조체를 사용한다는 구현 세부 사항을 알 필요가 없으므로, <code>Worker</code> 구조체와 그 <code>new</code> 함수를 비공개(private)로 만듭니다. <code>Worker::new</code> 함수는 제공받은 <code>id</code>를 사용하며, 빈 클로저를 사용하여 새로운 스레드를 생성함으로써 만들어진 <code>JoinHandle&lt;()&gt;</code> 인스턴스를 저장합니다.</p>
<blockquote>
<p>참고: 시스템 리소스가 부족하여 운영 체제가 스레드를 생성할 수 없는 경우, <code>thread::spawn</code>은 패닉을 일으킵니다. 이는 비록 일부 스레드 생성에 성공했더라도 서버 전체를 패닉 상태로 빠뜨릴 것입니다. 단순함을 위해 이 동작을 그대로 두지만, 실제 프로덕션용 스레드 풀 구현에서는 대신 <code>Result</code>를 반환하는 <a href="../std/thread/struct.Builder.html"><code>std::thread::Builder</code></a>와 그 <a href="../std/thread/struct.Builder.html#method.spawn"><code>spawn</code></a> 메서드를 사용하고 싶을 것입니다.</p>
</blockquote>
<p>이 코드는 컴파일되며 <code>ThreadPool::new</code>에 인수로 전달한 개수만큼의 <code>Worker</code> 인스턴스들을 저장할 것입니다. 하지만 우리는 <em>여전히</em> <code>execute</code>에서 받은 클로저를 처리하지 않고 있습니다. 다음으로 그 방법을 살펴보겠습니다.</p>
<h4 id="채널을-통해-스레드에-요청-보내기"><a class="header" href="#채널을-통해-스레드에-요청-보내기">채널을 통해 스레드에 요청 보내기</a></h4>
<p>다음에 해결할 문제는 <code>thread::spawn</code>에 전달된 클로저들이 아무런 일도 하지 않는다는 점입니다. 현재 우리는 실행하고 싶은 클로저를 <code>execute</code> 메서드에서 받고 있습니다. 하지만 우리는 <code>ThreadPool</code>을 생성하는 동안 각 <code>Worker</code>를 만들 때 <code>thread::spawn</code>에 실행할 클로저를 주어야 합니다.</p>
<p>우리는 방금 생성한 <code>Worker</code> 구조체들이 <code>ThreadPool</code>이 보유한 큐에서 실행할 코드를 가져와서, 해당 코드를 자신의 스레드로 보내 실행하도록 하고 싶습니다.</p>
<p>16장에서 배웠던 채널(두 스레드 간에 통신하는 간단한 방법)이 이 사용 사례에 완벽할 것입니다. 채널을 작업 큐로 사용할 것이며, <code>execute</code>는 <code>ThreadPool</code>에서 <code>Worker</code> 인스턴스들로 작업을 보내고, 워커는 그 작업을 자신의 스레드로 보낼 것입니다. 계획은 다음과 같습니다.</p>
<ol>
<li><code>ThreadPool</code>은 채널을 생성하고 송신자(sender)를 보관합니다.</li>
<li>각 <code>Worker</code>는 수신자(receiver)를 보관합니다.</li>
<li>채널을 통해 보내고 싶은 클로저들을 담을 새로운 <code>Job</code> 구조체를 만들 것입니다.</li>
<li><code>execute</code> 메서드는 실행하고자 하는 작업을 송신자를 통해 보낼 것입니다.</li>
<li>워커는 자신의 스레드에서 수신자를 반복적으로 확인하며 수신된 모든 작업의 클로저를 실행할 것입니다.</li>
</ol>
<p>먼저 예제 21-16에 표시된 대로 <code>ThreadPool::new</code>에서 채널을 생성하고 <code>ThreadPool</code> 인스턴스에 송신자를 보관하는 것부터 시작하겠습니다. <code>Job</code> 구조체는 현재로서는 아무것도 가지고 있지 않지만, 채널을 통해 보낼 아이템의 타입이 될 것입니다.</p>
<Listing number="21-16" file-name="src/lib.rs" caption="Modifying `ThreadPool` to store the sender of a channel that transmits `Job` instances">
<pre><code class="language-rust noplayground">use std::{sync::mpsc, thread};

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Job&gt;,
}

struct Job;

impl ThreadPool {
    // --생략--
<span class="boring">    /// 새로운 ThreadPool을 생성합니다.
</span><span class="boring">    ///
</span><span class="boring">    /// size는 풀의 스레드 개수입니다.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// `new` 함수는 size가 0일 경우 패닉을 일으킵니다.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers, sender }
    }
    // --생략--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(|| {});
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p><code>ThreadPool::new</code>에서 새로운 채널을 생성하고 풀이 송신자를 보관하게 합니다. 이는 성공적으로 컴파일될 것입니다.</p>
<p>스레드 풀이 채널을 생성할 때 각 <code>Worker</code>에게 채널의 수신자를 전달해 봅시다. 우리는 <code>Worker</code> 인스턴스가 생성하는 스레드 내에서 수신자를 사용하고 싶으므로, 클로저 내에서 <code>receiver</code> 파라미터를 참조할 것입니다. 예제 21-17의 코드는 아직 컴파일되지 않을 것입니다.</p>
<Listing number="21-17" file-name="src/lib.rs" caption="Passing the receiver to each `Worker`">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{sync::mpsc, thread};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Job;
</span><span class="boring">
</span>impl ThreadPool {
    // --생략--
<span class="boring">    /// 새로운 ThreadPool을 생성합니다.
</span><span class="boring">    ///
</span><span class="boring">    /// size는 풀의 스레드 개수입니다.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// `new` 함수는 size가 0일 경우 패닉을 일으킵니다.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver));
        }

        ThreadPool { workers, sender }
    }
    // --생략--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// --생략--

<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
        let thread = thread::spawn(|| {
            receiver;
        });

        Worker { id, thread }
    }
}</code></pre>
</Listing>
<p>우리는 몇 가지 작고 간단한 변경을 했습니다. 수신자를 <code>Worker::new</code>로 전달하고, 클로저 내부에서 이를 사용하도록 했습니다.</p>
<p>이 코드를 체크하려고 하면 다음과 같은 에러가 발생합니다.</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0382]: use of moved value: `receiver`
  --&gt; src/lib.rs:26:42
   |
21 |         let (sender, receiver) = mpsc::channel();
   |                      -------- move occurs because `receiver` has type `std::sync::mpsc::Receiver&lt;Job&gt;`, which does not implement the `Copy` trait
...
25 |         for id in 0..size {
   |         ----------------- inside of this loop
26 |             workers.push(Worker::new(id, receiver));
   |                                          ^^^^^^^^ value moved here, in previous iteration of loop
   |
note: consider changing this parameter type in method `new` to borrow instead if owning the value isn't necessary
  --&gt; src/lib.rs:47:33
   |
47 |     fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
   |        --- in this method       ^^^^^^^^^^^^^^^^^^^ this parameter takes ownership of the value
help: consider moving the expression out of the loop so it is only moved once
   |
25 ~         let mut value = Worker::new(id, receiver);
26 ~         for id in 0..size {
27 ~             workers.push(value);
   |

For more information about this error, try `rustc --explain E0382`.
error: could not compile `hello` (lib) due to 1 previous error
</code></pre>
<p>코드가 <code>receiver</code>를 여러 <code>Worker</code> 인스턴스에 전달하려고 시도하고 있습니다. 16장에서 배웠던 것처럼 이는 작동하지 않을 것입니다. 러스트가 제공하는 채널 구현은 다중 <em>생성자(producer)</em>, 단일 <em>소비자(consumer)</em> 방식이기 때문입니다. 즉, 이 코드를 수정하기 위해 채널의 소비 단을 단순히 복제(clone)할 수는 없습니다. 또한 우리는 하나의 메시지를 여러 소비자에게 여러 번 보내고 싶은 것이 아니라, 하나의 메시지 목록을 여러 <code>Worker</code> 인스턴스가 공유하여 각 메시지가 단 한 번만 처리되기를 원합니다.</p>
<p>또한 채널 큐에서 작업을 꺼내는 일은 <code>receiver</code>를 수정하는 과정을 포함하므로, 스레드들이 <code>receiver</code>를 안전하게 공유하고 수정할 수 있는 방법이 필요합니다. 그렇지 않으면 (16장에서 다룬 것처럼) 레이스 컨디션이 발생할 수 있습니다.</p>
<p>16장에서 논의한 스레드 안전한 스마트 포인터를 떠올려 보세요. 여러 스레드 간에 소유권을 공유하고 스레드가 값을 수정할 수 있도록 하려면 <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>를 사용해야 합니다. <code>Arc</code> 타입은 여러 <code>Worker</code> 인스턴스가 수신자를 소유할 수 있게 해주고, <code>Mutex</code>는 한 번에 하나의 <code>Worker</code>만이 수신자로부터 작업을 가져오도록 보장합니다. 예제 21-18은 우리가 적용해야 할 변경 사항을 보여줍니다.</p>
<Listing number="21-18" file-name="src/lib.rs" caption="Sharing the receiver among the `Worker` instances using `Arc` and `Mutex`">
<pre><code class="language-rust noplayground">use std::{
    sync::{mpsc, Arc, Mutex},
    thread,
};
// --생략--

<span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Job;
</span><span class="boring">
</span>impl ThreadPool {
    // --생략--
<span class="boring">    /// 새로운 ThreadPool을 생성합니다.
</span><span class="boring">    ///
</span><span class="boring">    /// size는 풀의 스레드 개수입니다.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// `new` 함수는 size가 0일 경우 패닉을 일으킵니다.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool { workers, sender }
    }

    // --생략--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// --생략--

<span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --생략--
<span class="boring">        let thread = thread::spawn(|| {
</span><span class="boring">            receiver;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span>    }
}</code></pre>
</Listing>
<p><code>ThreadPool::new</code>에서 수신자를 <code>Arc</code>와 <code>Mutex</code>로 감쌉니다. 새로운 <code>Worker</code>를 생성할 때마다 <code>Arc</code>를 클론하여 참조 카운트를 증가시킴으로써 <code>Worker</code> 인스턴스들이 수신자의 소유권을 공유할 수 있게 합니다.</p>
<p>이러한 변경 사항을 적용하면 코드가 컴파일됩니다! 거의 다 왔습니다!</p>
<h4 id="execute-메서드-구현하기"><a class="header" href="#execute-메서드-구현하기"><code>execute</code> 메서드 구현하기</a></h4>
<p>드디어 <code>ThreadPool</code>의 <code>execute</code> 메서드를 구현해 봅시다. 또한 <code>Job</code>을 구조체에서 <code>execute</code>가 받는 클로저 타입을 담는 트레이트 객체의 타입 별칭으로 변경하겠습니다. 20장의 <a href="ch20-03-advanced-types.html#creating-type-synonyms-with-type-aliases">“타입 별칭으로 타입 동의어 만들기”</a><!-- ignore -->에서 논의한 것처럼, 타입 별칭을 사용하면 긴 타입을 짧게 줄여 사용하기 편리하게 만들 수 있습니다. 예제 21-19를 살펴보세요.</p>
<Listing number="21-19" file-name="src/lib.rs" caption="Creating a `Job` type alias for a `Box` that holds each closure and then sending the job down the channel">
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// --생략--

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    // --생략--
<span class="boring">    /// 새로운 ThreadPool을 생성합니다.
</span><span class="boring">    ///
</span><span class="boring">    /// size는 풀의 스레드 개수입니다.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// `new` 함수는 size가 0일 경우 패닉을 일으킵니다.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span>
    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(job).unwrap();
    }
}

// --생략--
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(|| {
</span><span class="boring">            receiver;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p><code>execute</code>에서 받은 클로저를 사용하여 새로운 <code>Job</code> 인스턴스를 생성한 후, 해당 작업을 채널의 송신 단으로 보냅니다. 전송이 실패할 경우를 대비해 <code>send</code>에 대해 <code>unwrap</code>을 호출합니다. 전송 실패는 예를 들어 우리가 모든 스레드의 실행을 중단시켜 수신 단이 새로운 메시지 수신을 멈춘 경우에 발생할 수 있습니다. 현재로서는 스레드 실행을 중단할 수 없으며, 풀이 존재하는 한 스레드는 계속 실행됩니다. 우리가 <code>unwrap</code>을 사용하는 이유는 실패 케이스가 발생하지 않을 것임을 알고 있기 때문이지만, 컴파일러는 이를 알지 못합니다.</p>
<p>하지만 아직 끝난 것이 아닙니다! <code>Worker</code>에서 <code>thread::spawn</code>으로 전달되는 클로저는 여전히 채널의 수신 단을 _참조_만 하고 있습니다. 대신, 우리는 클로저가 무한히 루프를 돌면서 채널의 수신 단에 작업을 요청하고, 작업을 받으면 이를 실행하도록 해야 합니다. 예제 21-20과 같이 <code>Worker::new</code>를 수정해 봅시다.</p>
<Listing number="21-20" file-name="src/lib.rs" caption="Receiving and executing the jobs in the `Worker` instance’s thread">
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// 새로운 ThreadPool을 생성합니다.
</span><span class="boring">    ///
</span><span class="boring">    /// size는 풀의 스레드 개수입니다.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// `new` 함수는 size가 0일 경우 패닉을 일으킵니다.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// --생략--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let job = receiver.lock().unwrap().recv().unwrap();

            println!("워커 {id}가 작업을 받았습니다. 실행합니다.");

            job();
        });

        Worker { id, thread }
    }
}</code></pre>
</Listing>
<p>여기서 우리는 먼저 뮤텍스를 획득하기 위해 <code>receiver</code>에 대해 <code>lock</code>을 호출하고, 에러 발생 시 패닉을 일으키도록 <code>unwrap</code>을 호출합니다. 뮤텍스가 <em>포이즌(poisoned)</em> 상태인 경우 락 획득이 실패할 수 있는데, 이는 다른 스레드가 락을 해제하지 않고 락을 보유한 채로 패닉을 일으켰을 때 발생할 수 있습니다. 이러한 상황에서는 현재 스레드도 패닉을 일으키도록 <code>unwrap</code>을 호출하는 것이 올바른 조치입니다. 원하신다면 이 <code>unwrap</code>을 여러분에게 의미 있는 에러 메시지를 담은 <code>expect</code>로 바꾸셔도 됩니다.</p>
<p>뮤텍스 락을 획득하면 채널로부터 <code>Job</code>을 받기 위해 <code>recv</code>를 호출합니다. 마지막 <code>unwrap</code>은 여기서 발생할 수 있는 에러도 처리하는데, 이는 송신자를 보유한 스레드가 종료되었을 때 발생할 수 있습니다. 이는 수신자가 종료되었을 때 <code>send</code> 메서드가 <code>Err</code>을 반환하는 것과 유사합니다.</p>
<p><code>recv</code> 호출은 블로킹 방식으로 동작하므로, 아직 작업이 없다면 현재 스레드는 작업이 사용 가능해질 때까지 대기합니다. <code>Mutex&lt;T&gt;</code>는 한 번에 하나의 <code>Worker</code> 스레드만이 작업을 요청하도록 보장합니다.</p>
<p>이제 우리 스레드 풀이 작동하는 상태가 되었습니다! <code>cargo run</code>을 실행하고 몇 가지 요청을 보내보세요.</p>
<!-- manual-regeneration
cd listings/ch21-web-server/listing-21-20
cargo run
make some requests to 127.0.0.1:7878
Can't automate because the output depends on making requests
-->
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
warning: field `workers` is never read
 --&gt; src/lib.rs:7:5
  |
6 | pub struct ThreadPool {
  |            ---------- field in this struct
7 |     workers: Vec&lt;Worker&gt;,
  |     ^^^^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: fields `id` and `thread` are never read
  --&gt; src/lib.rs:48:5
   |
47 | struct Worker {
   |        ------ fields in this struct
48 |     id: usize,
   |     ^^
49 |     thread: thread::JoinHandle&lt;()&gt;
   |     ^^^^^^

warning: `hello` (lib) generated 2 warnings
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 4.91s
     Running `target/debug/hello`
워커 0이 작업을 받았습니다. 실행합니다.
워커 2가 작업을 받았습니다. 실행합니다.
워커 1이 작업을 받았습니다. 실행합니다.
워커 3이 작업을 받았습니다. 실행합니다.
워커 0이 작업을 받았습니다. 실행합니다.
워커 2가 작업을 받았습니다. 실행합니다.
워커 1이 작업을 받았습니다. 실행합니다.
워커 3이 작업을 받았습니다. 실행합니다.
워커 0이 작업을 받았습니다. 실행합니다.
워커 2가 작업을 받았습니다. 실행합니다.
</code></pre>
<p>성공입니다! 이제 연결을 비동기적으로 실행하는 스레드 풀을 갖게 되었습니다. 생성되는 스레드는 4개를 넘지 않으므로, 서버가 많은 요청을 받더라도 시스템에 과부하가 걸리지 않을 것입니다. _/sleep_에 대한 요청을 보내더라도, 서버는 다른 스레드를 통해 다른 요청들을 처리할 수 있습니다.</p>
<blockquote>
<p>참고: 만약 여러 브라우저 창에서 동시에 _/sleep_을 열면, 5초 간격으로 하나씩 로드될 수도 있습니다. 일부 웹 브라우저는 캐싱 등의 이유로 동일한 요청의 여러 인스턴스를 순차적으로 실행합니다. 이러한 제한은 우리 웹 서버 때문에 발생하는 것이 아닙니다.</p>
</blockquote>
<p>잠시 멈추고, 수행할 작업에 클로저 대신 퓨처(future)를 사용했다면 예제 21-18, 21-19, 21-20의 코드가 어떻게 달라졌을지 생각해 보기 좋은 시간입니다. 어떤 타입들이 바뀌었을까요? 메서드 시그니처는 어떻게 달라졌을까요(혹은 그대로일까요)? 코드의 어떤 부분들이 그대로 유지되었을까요?</p>
<p>17장과 18장에서 <code>while let</code> 루프에 대해 배우고 난 뒤, 왜 워커 스레드 코드를 예제 21-21과 같이 작성하지 않았는지 궁금해하실 수도 있습니다.</p>
<Listing number="21-21" file-name="src/lib.rs" caption="An alternative implementation of `Worker::new` using `while let`">
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// 새로운 ThreadPool을 생성합니다.
</span><span class="boring">    ///
</span><span class="boring">    /// size는 풀의 스레드 개수입니다.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// `new` 함수는 size가 0일 경우 패닉을 일으킵니다.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span>// --생략--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            while let Ok(job) = receiver.lock().unwrap().recv() {
                println!("워커 {id}가 작업을 받았습니다. 실행합니다.");

                job();
            }
        });

        Worker { id, thread }
    }
}</code></pre>
</Listing>
<p>이 코드는 컴파일되고 실행되지만 우리가 원하는 스레딩 동작을 보여주지는 않습니다. 즉, 느린 요청이 여전히 다른 요청들의 처리를 대기하게 만듭니다. 그 이유는 다소 미묘합니다. <code>Mutex</code> 구조체에는 공개된 <code>unlock</code> 메서드가 없는데, 락(lock)의 소유권은 <code>lock</code> 메서드가 반환하는 <code>LockResult&lt;MutexGuard&lt;T&gt;&gt;</code> 내 <code>MutexGuard&lt;T&gt;</code>의 라이프타임에 기반하기 때문입니다. 이를 통해 컴파일 타임에 대여 검사기는 우리가 락을 보유하고 있지 않는 한 <code>Mutex</code>에 의해 보호되는 리소스에 접근할 수 없다는 규칙을 강제할 수 있습니다. 하지만 이 구현은 <code>MutexGuard&lt;T&gt;</code>의 라이프타임을 주의 깊게 관리하지 않으면 의도했던 것보다 더 오랫동안 락을 보유하게 되는 결과를 초래할 수 있습니다.</p>
<p><code>let job = receiver.lock().unwrap().recv().unwrap();</code>를 사용하는 예제 21-20의 코드가 작동하는 이유는, <code>let</code>을 사용하면 등호 오른편 표현식에서 사용된 모든 임시 값들이 <code>let</code> 문이 끝날 때 즉시 드롭되기 때문입니다. 하지만 <code>while let</code> (그리고 <code>if let</code>과 <code>match</code>)은 연관된 블록이 끝날 때까지 임시 값들을 드롭하지 않습니다. 예제 21-21에서 락은 <code>job()</code> 호출이 진행되는 동안 계속 유지되며, 이는 다른 <code>Worker</code> 인스턴스들이 작업을 받을 수 없음을 의미합니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch21-01-single-threaded.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch21-03-graceful-shutdown-and-cleanup.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch21-01-single-threaded.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch21-03-graceful-shutdown-and-cleanup.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
