<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>From Single-Threaded to Multithreaded Server - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch21-02-multithreaded.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch21-02-multithreaded.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Old headings. Do not remove or links may break. -->
<p><a id="turning-our-single-threaded-server-into-a-multithreaded-server"></a> <a id="from-single-threaded-to-multithreaded-server"></a></p>
<h2 id="from-a-single-threaded-to-a-multithreaded-server"><a class="header" href="#from-a-single-threaded-to-a-multithreaded-server">From a Single-Threaded to a Multithreaded Server</a></h2>
<p>Right now, the server will process each request in turn, meaning it won’t process a second connection until the first connection is finished processing. If the server received more and more requests, this serial execution would be less and less optimal. If the server receives a request that takes a long time to process, subsequent requests will have to wait until the long request is finished, even if the new requests can be processed quickly. We’ll need to fix this, but first we’ll look at the problem in action.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="simulating-a-slow-request-in-the-current-server-implementation"></a></p>
<h3 id="simulating-a-slow-request"><a class="header" href="#simulating-a-slow-request">Simulating a Slow Request</a></h3>
<p>We’ll look at how a slowly processing request can affect other requests made to our current server implementation. Listing 21-10 implements handling a request to <em>/sleep</em> with a simulated slow response that will cause the server to sleep for five seconds before responding.</p>
<Listing number="21-10" file-name="src/main.rs" caption="Simulating a slow request by sleeping for five seconds">
<pre><pre class="playground"><code class="language-rust no_run edition2024">use std::{
    fs,
    io::{BufReader, prelude::*},
    net::{TcpListener, TcpStream},
    thread,
    time::Duration,
};
// --생략--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn handle_connection(mut stream: TcpStream) {
    // --생략--

<span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span>    let (status_line, filename) = match &amp;request_line[..] {
        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
        "GET /sleep HTTP/1.1" =&gt; {
            thread::sleep(Duration::from_secs(5));
            ("HTTP/1.1 200 OK", "hello.html")
        }
        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
    };

    // --생략--
<span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span>}</code></pre></pre>
</Listing>
<p>We switched from <code>if</code> to <code>match</code> now that we have three cases. We need to explicitly match on a slice of <code>request_line</code> to pattern-match against the string literal values; <code>match</code> doesn’t do automatic referencing and dereferencing, like the equality method does.</p>
<p>첫 번째 암(arm)은 예제 21-9의 <code>if</code> 블록과 동일합니다. 두 번째 암은 _/sleep_에 대한 요청과 매칭됩니다. 해당 요청이 수신되면, 서버는 성공 HTML 페이지를 렌더링하기 전에 5초 동안 잠들 것입니다. 세 번째 암은 예제 21-9의 <code>else</code> 블록과 동일합니다.</p>
<p>You can see how primitive our server is: Real libraries would handle the recognition of multiple requests in a much less verbose way!</p>
<p>Start the server using <code>cargo run</code>. Then, open two browser windows: one for <em>http://127.0.0.1:7878</em> and the other for <em>http://127.0.0.1:7878/sleep</em>. If you enter the <em>/</em> URI a few times, as before, you’ll see it respond quickly. But if you enter <em>/sleep</em> and then load <em>/</em>, you’ll see that <em>/</em> waits until <code>sleep</code> has slept for its full five seconds before loading.</p>
<p>느린 요청 뒤로 요청들이 밀리는 것을 방지하기 위해 사용할 수 있는 여러 기술이 있습니다. 17장에서 했던 것처럼 비동기(async)를 사용하는 것도 그중 하나입니다. 우리가 구현할 방법은 스레드 풀(thread pool)입니다.</p>
<h3 id="스레드-풀을-사용하여-처리량-개선하기"><a class="header" href="#스레드-풀을-사용하여-처리량-개선하기">스레드 풀을 사용하여 처리량 개선하기</a></h3>
<p>A <em>thread pool</em> is a group of spawned threads that are ready and waiting to handle a task. When the program receives a new task, it assigns one of the threads in the pool to the task, and that thread will process the task. The remaining threads in the pool are available to handle any other tasks that come in while the first thread is processing. When the first thread is done processing its task, it’s returned to the pool of idle threads, ready to handle a new task. A thread pool allows you to process connections concurrently, increasing the throughput of your server.</p>
<p>We’ll limit the number of threads in the pool to a small number to protect us from DoS attacks; if we had our program create a new thread for each request as it came in, someone making 10 million requests to our server could wreak havoc by using up all our server’s resources and grinding the processing of requests to a halt.</p>
<p>제한 없이 스레드를 생성하는 대신, 풀에서 대기하는 스레드의 개수를 고정할 것입니다. 들어오는 요청들은 처리를 위해 풀로 보내집니다. 풀은 들어오는 요청들의 큐(queue)를 유지 관리합니다. 풀의 각 스레드는 이 큐에서 요청을 하나씩 꺼내어 처리한 다음, 다시 큐에 다음 요청을 요청합니다. 이 설계를 통해 우리는 스레드 개수인 _<code>N</code>_개까지의 요청을 동시에 처리할 수 있습니다. 만약 각 스레드가 오래 걸리는 요청에 응답하고 있다면 후속 요청들이 여전히 큐에서 밀릴 수 있겠지만, 그 지점에 도달하기 전까지 우리가 처리할 수 있는 오래 걸리는 요청의 개수를 늘린 셈입니다.</p>
<p>This technique is just one of many ways to improve the throughput of a web server. Other options you might explore are the fork/join model, the single-threaded async I/O model, and the multithreaded async I/O model. If you’re interested in this topic, you can read more about other solutions and try to implement them; with a low-level language like Rust, all of these options are possible.</p>
<p>Before we begin implementing a thread pool, let’s talk about what using the pool should look like. When you’re trying to design code, writing the client interface first can help guide your design. Write the API of the code so that it’s structured in the way you want to call it; then, implement the functionality within that structure rather than implementing the functionality and then designing the public API.</p>
<p>12장의 프로젝트에서 테스트 주도 개발(TDD)을 사용했던 것과 유사하게, 여기서는 컴파일러 주도 개발을 사용할 것입니다. 우리가 원하는 함수를 호출하는 코드를 먼저 작성하고, 컴파일러가 내뱉는 에러를 보면서 코드가 작동하게 하기 위해 다음에 무엇을 변경해야 할지 결정할 것입니다. 하지만 그전에, 시작점으로 사용하지 <em>않을</em> 기술에 대해 먼저 살펴보겠습니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="code-structure-if-we-could-spawn-a-thread-for-each-request"></a></p>
<h4 id="각-요청에-대해-스레드-생성하기"><a class="header" href="#각-요청에-대해-스레드-생성하기">각 요청에 대해 스레드 생성하기</a></h4>
<p>First, let’s explore how our code might look if it did create a new thread for every connection. As mentioned earlier, this isn’t our final plan due to the problems with potentially spawning an unlimited number of threads, but it is a starting point to get a working multithreaded server first. Then, we’ll add the thread pool as an improvement, and contrasting the two solutions will be easier.</p>
<p>Listing 21-11 shows the changes to make to <code>main</code> to spawn a new thread to handle each stream within the <code>for</code> loop.</p>
<Listing number="21-11" file-name="src/main.rs" caption="Spawning a new thread for each stream">
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{BufReader, prelude::*},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
</span><span class="boring">        "GET /sleep HTTP/1.1" =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            ("HTTP/1.1 200 OK", "hello.html")
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>16장에서 배웠듯이, <code>thread::spawn</code>은 새로운 스레드를 생성하고 클로저 안의 코드를 실행합니다. 이 코드를 실행하고 브라우저에서 _/sleep_을 로드한 다음, 두 개의 다른 탭에서 _/_를 로드해 보세요. 실제로 _/_에 대한 요청들이 _/sleep_이 끝나기를 기다릴 필요가 없음을 확인할 수 있을 것입니다. 하지만 앞서 언급했듯이, 제한 없이 새로운 스레드를 계속 만들게 되면 결국 시스템에 과부하를 주게 될 것입니다.</p>
<p>또한 17장에서 배웠던 것처럼, 이러한 상황이 바로 async와 await가 진정으로 빛을 발하는 지점입니다! 스레드 풀을 구축하면서 async를 사용했을 때와 무엇이 다르고 무엇이 같을지 생각하며 이 점을 염두에 두세요.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="creating-a-similar-interface-for-a-finite-number-of-threads"></a></p>
<h4 id="유한한-개수의-스레드-생성하기"><a class="header" href="#유한한-개수의-스레드-생성하기">유한한 개수의 스레드 생성하기</a></h4>
<p>우리는 우리 API를 사용하는 코드에 큰 변화를 주지 않고도 스레드 방식에서 스레드 풀 방식으로 전환할 수 있도록, 스레드 풀이 유사하고 친숙한 방식으로 작동하기를 원합니다. 예제 21-12는 <code>thread::spawn</code> 대신 사용하고 싶은 <code>ThreadPool</code> 구조체의 가상 인터페이스를 보여줍니다.</p>
<Listing number="21-12" file-name="src/main.rs" caption="Our ideal `ThreadPool` interface">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{BufReader, prelude::*},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
</span><span class="boring">        "GET /sleep HTTP/1.1" =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            ("HTTP/1.1 200 OK", "hello.html")
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre>
</Listing>
<p>We use <code>ThreadPool::new</code> to create a new thread pool with a configurable number of threads, in this case four. Then, in the <code>for</code> loop, <code>pool.execute</code> has a similar interface as <code>thread::spawn</code> in that it takes a closure that the pool should run for each stream. We need to implement <code>pool.execute</code> so that it takes the closure and gives it to a thread in the pool to run. This code won’t yet compile, but we’ll try so that the compiler can guide us in how to fix it.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="building-the-threadpool-struct-using-compiler-driven-development"></a></p>
<h4 id="building-threadpool-using-compiler-driven-development"><a class="header" href="#building-threadpool-using-compiler-driven-development">Building <code>ThreadPool</code> Using Compiler-Driven Development</a></h4>
<p>예제 21-12의 변경 사항을 _src/main.rs_에 적용한 다음, <code>cargo check</code>에서 발생하는 컴파일러 에러를 이용해 개발을 진행해 봅시다. 우리가 받게 될 첫 번째 에러는 다음과 같습니다.</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0433]: failed to resolve: use of undeclared type `ThreadPool`
  --&gt; src/main.rs:11:16
   |
11 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^ use of undeclared type `ThreadPool`

For more information about this error, try `rustc --explain E0433`.
error: could not compile `hello` (bin "hello") due to 1 previous error
</code></pre>
<p>Great! This error tells us we need a <code>ThreadPool</code> type or module, so we’ll build one now. Our <code>ThreadPool</code> implementation will be independent of the kind of work our web server is doing. So, let’s switch the <code>hello</code> crate from a binary crate to a library crate to hold our <code>ThreadPool</code> implementation. After we change to a library crate, we could also use the separate thread pool library for any work we want to do using a thread pool, not just for serving web requests.</p>
<p>현재로서 가질 수 있는 가장 단순한 형태의 <code>ThreadPool</code> 구조체 정의를 포함하는 <em>src/lib.rs</em> 파일을 생성하세요.</p>
<Listing file-name="src/lib.rs">
<pre><code class="language-rust noplayground">pub struct ThreadPool;</code></pre>
</Listing>
<p>Then, edit the <em>main.rs</em> file to bring <code>ThreadPool</code> into scope from the library crate by adding the following code to the top of <em>src/main.rs</em>:</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore">use hello::ThreadPool;
<span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{BufReader, prelude::*},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">    let pool = ThreadPool::new(4);
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        pool.execute(|| {
</span><span class="boring">            handle_connection(stream);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
</span><span class="boring">        "GET /sleep HTTP/1.1" =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            ("HTTP/1.1 200 OK", "hello.html")
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre>
</Listing>
<p>이 코드는 여전히 작동하지 않지만, 우리가 해결해야 할 다음 에러를 확인하기 위해 다시 체크해 봅시다.</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no function or associated item named `new` found for struct `ThreadPool` in the current scope
  --&gt; src/main.rs:12:28
   |
12 |     let pool = ThreadPool::new(4);
   |                            ^^^ function or associated item not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` (bin "hello") due to 1 previous error
</code></pre>
<p>이 에러는 다음으로 <code>ThreadPool</code>에 대한 <code>new</code>라는 이름의 연관 함수를 만들어야 함을 나타냅니다. 또한 <code>new</code>는 <code>4</code>를 인수로 받을 수 있는 하나의 파라미터를 가져야 하고 <code>ThreadPool</code> 인스턴스를 반환해야 한다는 것도 알고 있습니다. 이러한 특성을 가진 가장 단순한 <code>new</code> 함수를 구현해 봅시다.</p>
<Listing file-name="src/lib.rs">
<pre><code class="language-rust noplayground">pub struct ThreadPool;

impl ThreadPool {
    pub fn new(size: usize) -&gt; ThreadPool {
        ThreadPool
    }
}</code></pre>
</Listing>
<p>We chose <code>usize</code> as the type of the <code>size</code> parameter because we know that a negative number of threads doesn’t make any sense. We also know we’ll use this <code>4</code> as the number of elements in a collection of threads, which is what the <code>usize</code> type is for, as discussed in the <a href="ch03-02-data-types.html#integer-types">“Integer Types”</a><!--
ignore --> section in Chapter 3.</p>
<p>코드를 다시 체크해 봅시다.</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `execute` found for struct `ThreadPool` in the current scope
  --&gt; src/main.rs:17:14
   |
17 |         pool.execute(|| {
   |         -----^^^^^^^ method not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` (bin "hello") due to 1 previous error
</code></pre>
<p>Now the error occurs because we don’t have an <code>execute</code> method on <code>ThreadPool</code>. Recall from the <a href="#creating-a-finite-number-of-threads">“Creating a Finite Number of Threads”</a><!-- ignore --> section that we decided our thread pool should have an interface similar to <code>thread::spawn</code>. In addition, we’ll implement the <code>execute</code> function so that it takes the closure it’s given and gives it to an idle thread in the pool to run.</p>
<p>We’ll define the <code>execute</code> method on <code>ThreadPool</code> to take a closure as a parameter. Recall from the <a href="ch13-01-closures.html#moving-captured-values-out-of-closures">“Moving Captured Values Out of Closures”</a><!-- ignore --> in Chapter 13 that we can take closures as parameters with three different traits: <code>Fn</code>, <code>FnMut</code>, and <code>FnOnce</code>. We need to decide which kind of closure to use here. We know we’ll end up doing something similar to the standard library <code>thread::spawn</code> implementation, so we can look at what bounds the signature of <code>thread::spawn</code> has on its parameter. The documentation shows us the following:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static,</code></pre>
<p>여기서 우리가 관심을 갖는 것은 <code>F</code> 타입 파라미터입니다. <code>T</code> 타입 파라미터는 반환값과 관련된 것이며 여기서는 고려하지 않습니다. <code>spawn</code>이 <code>F</code>에 대한 트레이트 바운드로 <code>FnOnce</code>를 사용함을 알 수 있습니다. 우리가 <code>execute</code>에서 받은 인수를 결국 <code>spawn</code>으로 전달할 것이기 때문에, 이것이 우리가 원하는 것일 가능성이 큽니다. 또한 요청을 실행하기 위한 스레드는 해당 요청의 클로저를 단 한 번만 실행할 것이기 때문에, <code>FnOnce</code>의 <code>Once</code>와 의미상 일치한다는 점에서도 <code>FnOnce</code>가 적합함을 확신할 수 있습니다.</p>
<p>The <code>F</code> type parameter also has the trait bound <code>Send</code> and the lifetime bound <code>'static</code>, which are useful in our situation: We need <code>Send</code> to transfer the closure from one thread to another and <code>'static</code> because we don’t know how long the thread will take to execute. Let’s create an <code>execute</code> method on <code>ThreadPool</code> that will take a generic parameter of type <code>F</code> with these bounds:</p>
<Listing file-name="src/lib.rs">
<pre><code class="language-rust noplayground"><span class="boring">pub struct ThreadPool;
</span><span class="boring">
</span>impl ThreadPool {
    // --생략--
<span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        ThreadPool
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
    }
}</code></pre>
</Listing>
<p><code>FnOnce</code> 뒤에 여전히 <code>()</code>를 사용하는데, 이는 이 <code>FnOnce</code>가 파라미터가 없고 유닛 타입 <code>()</code>을 반환하는 클로저를 나타내기 때문입니다. 함수 정의와 마찬가지로 반환 타입은 시그니처에서 생략될 수 있지만, 파라미터가 없더라도 괄호는 필요합니다.</p>
<p>Again, this is the simplest implementation of the <code>execute</code> method: It does nothing, but we’re only trying to make our code compile. Let’s check it again:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.24s
</code></pre>
<p>컴파일이 됩니다! 하지만 <code>cargo run</code>을 실행하고 브라우저에서 요청을 보내면, 이 장의 시작 부분에서 보았던 것과 같은 에러가 브라우저에 나타날 것입니다. 우리 라이브러리가 아직 <code>execute</code>에 전달된 클로저를 실제로 호출하고 있지 않기 때문입니다!</p>
<blockquote>
<p>Note: A saying you might hear about languages with strict compilers, such as Haskell and Rust, is “If the code compiles, it works.” But this saying is not universally true. Our project compiles, but it does absolutely nothing! If we were building a real, complete project, this would be a good time to start writing unit tests to check that the code compiles <em>and</em> has the behavior we want.</p>
</blockquote>
<p>Consider: What would be different here if we were going to execute a future instead of a closure?</p>
<h4 id="new에서-스레드-개수-검증하기"><a class="header" href="#new에서-스레드-개수-검증하기"><code>new</code>에서 스레드 개수 검증하기</a></h4>
<p>We aren’t doing anything with the parameters to <code>new</code> and <code>execute</code>. Let’s implement the bodies of these functions with the behavior we want. To start, let’s think about <code>new</code>. Earlier we chose an unsigned type for the <code>size</code> parameter because a pool with a negative number of threads makes no sense. However, a pool with zero threads also makes no sense, yet zero is a perfectly valid <code>usize</code>. We’ll add code to check that <code>size</code> is greater than zero before we return a <code>ThreadPool</code> instance, and we’ll have the program panic if it receives a zero by using the <code>assert!</code> macro, as shown in Listing 21-13.</p>
<Listing number="21-13" file-name="src/lib.rs" caption="Implementing `ThreadPool::new` to panic if `size` is zero">
<pre><code class="language-rust noplayground"><span class="boring">pub struct ThreadPool;
</span><span class="boring">
</span>impl ThreadPool {
    /// 새로운 ThreadPool을 생성합니다.
    ///
    /// size는 풀의 스레드 개수입니다.
    ///
    /// # Panics
    ///
    /// `new` 함수는 size가 0일 경우 패닉을 일으킵니다.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        ThreadPool
    }

    // --생략--
<span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}</code></pre>
</Listing>
<p>또한 문서 주석(doc comments)을 사용하여 <code>ThreadPool</code>에 대한 문서도 추가했습니다. 14장에서 논의한 것처럼 우리 함수가 패닉을 일으킬 수 있는 상황을 명시하는 섹션을 추가하여 좋은 문서화 관례를 따랐습니다. <code>cargo doc --open</code>을 실행하고 <code>ThreadPool</code> 구조체를 클릭하여 <code>new</code>에 대해 생성된 문서가 어떻게 보이는지 확인해 보세요!</p>
<p>여기서 한 것처럼 <code>assert!</code> 매크로를 추가하는 대신, 12장의 예제 12-9에서 I/O 프로젝트의 <code>Config::build</code>에서 했던 것처럼 <code>new</code>를 <code>build</code>로 바꾸고 <code>Result</code>를 반환하도록 할 수도 있습니다. 하지만 이번 사례에서는 스레드가 하나도 없는 스레드 풀을 생성하려는 시도를 복구 불가능한 에러로 처리하기로 결정했습니다. 도전해 보고 싶다면, <code>new</code> 함수와 비교해 볼 수 있도록 다음과 같은 시그니처를 가진 <code>build</code> 함수를 작성해 보세요.</p>
<pre><code class="language-rust ignore">pub fn build(size: usize) -&gt; Result&lt;ThreadPool, PoolCreationError&gt; {</code></pre>
<h4 id="스레드를-저장할-공간-만들기"><a class="header" href="#스레드를-저장할-공간-만들기">스레드를 저장할 공간 만들기</a></h4>
<p>이제 풀에 저장할 유효한 스레드 개수를 알 수 있는 방법이 생겼으므로, 구조체를 반환하기 전에 해당 스레드들을 생성하여 <code>ThreadPool</code> 구조체에 저장할 수 있습니다. 그런데 스레드를 어떻게 “저장”할까요? <code>thread::spawn</code> 시그니처를 다시 살펴봅시다.</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static,</code></pre>
<p><code>spawn</code> 함수는 <code>JoinHandle&lt;T&gt;</code>를 반환하는데, 여기서 <code>T</code>는 클로저가 반환하는 타입입니다. 우리도 <code>JoinHandle</code>을 사용하여 어떤 일이 일어나는지 살펴봅시다. 우리 경우에 스레드 풀로 전달하는 클로저들은 연결을 처리하고 아무것도 반환하지 않으므로, <code>T</code>는 유닛 타입 <code>()</code>이 될 것입니다.</p>
<p>The code in Listing 21-14 will compile, but it doesn’t create any threads yet. We’ve changed the definition of <code>ThreadPool</code> to hold a vector of <code>thread::JoinHandle&lt;()&gt;</code> instances, initialized the vector with a capacity of <code>size</code>, set up a <code>for</code> loop that will run some code to create the threads, and returned a <code>ThreadPool</code> instance containing them.</p>
<Listing number="21-14" file-name="src/lib.rs" caption="Creating a vector for `ThreadPool` to hold the threads">
<pre><code class="language-rust ignore not_desired_behavior">use std::thread;

pub struct ThreadPool {
    threads: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl ThreadPool {
    // --생략--
<span class="boring">    /// 새로운 ThreadPool을 생성합니다.
</span><span class="boring">    ///
</span><span class="boring">    /// size는 풀의 스레드 개수입니다.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// `new` 함수는 size가 0일 경우 패닉을 일으킵니다.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut threads = Vec::with_capacity(size);

        for _ in 0..size {
            // 스레드들을 생성하고 벡터에 저장합니다.
        }

        ThreadPool { threads }
    }
    // --생략--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}</code></pre>
</Listing>
<p><code>ThreadPool</code> 내 벡터의 아이템 타입으로 <code>thread::JoinHandle</code>을 사용하고 있으므로, 라이브러리 크레이트에서 <code>std::thread</code>를 스코프로 가져왔습니다.</p>
<p>Once a valid size is received, our <code>ThreadPool</code> creates a new vector that can hold <code>size</code> items. The <code>with_capacity</code> function performs the same task as <code>Vec::new</code> but with an important difference: It pre-allocates space in the vector. Because we know we need to store <code>size</code> elements in the vector, doing this allocation up front is slightly more efficient than using <code>Vec::new</code>, which resizes itself as elements are inserted.</p>
<p><code>cargo check</code>를 다시 실행하면 성공할 것입니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id ="a-worker-struct-responsible-for-sending-code-from-the-threadpool-to-a-thread"></a></p>
<h4 id="sending-code-from-the-threadpool-to-a-thread"><a class="header" href="#sending-code-from-the-threadpool-to-a-thread">Sending Code from the <code>ThreadPool</code> to a Thread</a></h4>
<p>예제 21-14의 <code>for</code> 루프에 스레드 생성에 관한 주석을 남겨두었습니다. 여기서는 실제로 스레드를 어떻게 생성하는지 살펴보겠습니다. 표준 라이브러리는 스레드를 생성하는 방법으로 <code>thread::spawn</code>을 제공하며, <code>thread::spawn</code>은 스레드가 생성되자마자 실행할 코드를 인수로 기대합니다. 하지만 우리의 경우, 스레드를 먼저 생성해 두고 나중에 보낼 코드를 <em>기다리게</em> 하고 싶습니다. 표준 라이브러리의 스레드 구현에는 이를 수행할 수 있는 방법이 포함되어 있지 않으므로, 우리가 직접 구현해야 합니다.</p>
<p>We’ll implement this behavior by introducing a new data structure between the <code>ThreadPool</code> and the threads that will manage this new behavior. We’ll call this data structure <em>Worker</em>, which is a common term in pooling implementations. The <code>Worker</code> picks up code that needs to be run and runs the code in its thread.</p>
<p>Think of people working in the kitchen at a restaurant: The workers wait until orders come in from customers, and then they’re responsible for taking those orders and filling them.</p>
<p>Instead of storing a vector of <code>JoinHandle&lt;()&gt;</code> instances in the thread pool, we’ll store instances of the <code>Worker</code> struct. Each <code>Worker</code> will store a single <code>JoinHandle&lt;()&gt;</code> instance. Then, we’ll implement a method on <code>Worker</code> that will take a closure of code to run and send it to the already running thread for execution. We’ll also give each <code>Worker</code> an <code>id</code> so that we can distinguish between the different instances of <code>Worker</code> in the pool when logging or debugging.</p>
<p><code>ThreadPool</code>을 생성할 때 일어날 새로운 프로세스는 다음과 같습니다. <code>Worker</code>를 이런 방식으로 설정한 후에 클로저를 스레드로 보내는 코드를 구현할 것입니다.</p>
<ol>
<li><code>id</code>와 <code>JoinHandle&lt;()&gt;</code>을 갖는 <code>Worker</code> 구조체를 정의합니다.</li>
<li><code>ThreadPool</code>이 <code>Worker</code> 인스턴스들의 벡터를 갖도록 변경합니다.</li>
<li><code>id</code> 번호를 받아서 해당 <code>id</code>와 빈 클로저로 생성된 스레드를 갖는 <code>Worker</code> 인스턴스를 반환하는 <code>Worker::new</code> 함수를 정의합니다.</li>
<li>In <code>ThreadPool::new</code>, use the <code>for</code> loop counter to generate an <code>id</code>, create a new <code>Worker</code> with that <code>id</code>, and store the <code>Worker</code> in the vector.</li>
</ol>
<p>도전해 보고 싶다면, 예제 21-15의 코드를 보기 전에 직접 이 변경 사항들을 구현해 보세요.</p>
<p>준비되셨나요? 예제 21-15는 앞서 설명한 수정을 수행하는 한 가지 방법을 보여줍니다.</p>
<Listing number="21-15" file-name="src/lib.rs" caption="Modifying `ThreadPool` to hold `Worker` instances instead of holding threads directly">
<pre><code class="language-rust noplayground">use std::thread;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
}

impl ThreadPool {
    // --생략--
<span class="boring">    /// 새로운 ThreadPool을 생성합니다.
</span><span class="boring">    ///
</span><span class="boring">    /// size는 풀의 스레드 개수입니다.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// `new` 함수는 size가 0일 경우 패닉을 일으킵니다.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers }
    }
    // --생략--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

struct Worker {
    id: usize,
    thread: thread::JoinHandle&lt;()&gt;,
}

impl Worker {
    fn new(id: usize) -&gt; Worker {
        let thread = thread::spawn(|| {});

        Worker { id, thread }
    }
}</code></pre>
</Listing>
<p>이제 <code>ThreadPool</code>이 <code>JoinHandle&lt;()&gt;</code> 인스턴스 대신 <code>Worker</code> 인스턴스들을 갖게 되었으므로 필드 이름을 <code>threads</code>에서 <code>workers</code>로 변경했습니다. <code>for</code> 루프의 카운터를 <code>Worker::new</code> 함수의 인수로 사용하고, 새로 생성된 각 <code>Worker</code>를 <code>workers</code>라는 이름의 벡터에 저장합니다.</p>
<p>외부 코드( _src/main.rs_에 있는 서버 등)는 <code>ThreadPool</code> 내부에서 <code>Worker</code> 구조체를 사용한다는 구현 세부 사항을 알 필요가 없으므로, <code>Worker</code> 구조체와 그 <code>new</code> 함수를 비공개(private)로 만듭니다. <code>Worker::new</code> 함수는 제공받은 <code>id</code>를 사용하며, 빈 클로저를 사용하여 새로운 스레드를 생성함으로써 만들어진 <code>JoinHandle&lt;()&gt;</code> 인스턴스를 저장합니다.</p>
<blockquote>
<p>참고: 시스템 리소스가 부족하여 운영 체제가 스레드를 생성할 수 없는 경우, <code>thread::spawn</code>은 패닉을 일으킵니다. 이는 비록 일부 스레드 생성에 성공했더라도 서버 전체를 패닉 상태로 빠뜨릴 것입니다. 단순함을 위해 이 동작을 그대로 두지만, 실제 프로덕션용 스레드 풀 구현에서는 대신 <code>Result</code>를 반환하는 <a href="../std/thread/struct.Builder.html"><code>std::thread::Builder</code></a>와 그 <a href="../std/thread/struct.Builder.html#method.spawn"><code>spawn</code></a> 메서드를 사용하고 싶을 것입니다.</p>
</blockquote>
<p>이 코드는 컴파일되며 <code>ThreadPool::new</code>에 인수로 전달한 개수만큼의 <code>Worker</code> 인스턴스들을 저장할 것입니다. 하지만 우리는 <em>여전히</em> <code>execute</code>에서 받은 클로저를 처리하지 않고 있습니다. 다음으로 그 방법을 살펴보겠습니다.</p>
<h4 id="채널을-통해-스레드에-요청-보내기"><a class="header" href="#채널을-통해-스레드에-요청-보내기">채널을 통해 스레드에 요청 보내기</a></h4>
<p>다음에 해결할 문제는 <code>thread::spawn</code>에 전달된 클로저들이 아무런 일도 하지 않는다는 점입니다. 현재 우리는 실행하고 싶은 클로저를 <code>execute</code> 메서드에서 받고 있습니다. 하지만 우리는 <code>ThreadPool</code>을 생성하는 동안 각 <code>Worker</code>를 만들 때 <code>thread::spawn</code>에 실행할 클로저를 주어야 합니다.</p>
<p>우리는 방금 생성한 <code>Worker</code> 구조체들이 <code>ThreadPool</code>이 보유한 큐에서 실행할 코드를 가져와서, 해당 코드를 자신의 스레드로 보내 실행하도록 하고 싶습니다.</p>
<p>16장에서 배웠던 채널(두 스레드 간에 통신하는 간단한 방법)이 이 사용 사례에 완벽할 것입니다. 채널을 작업 큐로 사용할 것이며, <code>execute</code>는 <code>ThreadPool</code>에서 <code>Worker</code> 인스턴스들로 작업을 보내고, 워커는 그 작업을 자신의 스레드로 보낼 것입니다. 계획은 다음과 같습니다.</p>
<ol>
<li><code>ThreadPool</code>은 채널을 생성하고 송신자(sender)를 보관합니다.</li>
<li>각 <code>Worker</code>는 수신자(receiver)를 보관합니다.</li>
<li>채널을 통해 보내고 싶은 클로저들을 담을 새로운 <code>Job</code> 구조체를 만들 것입니다.</li>
<li><code>execute</code> 메서드는 실행하고자 하는 작업을 송신자를 통해 보낼 것입니다.</li>
<li>워커는 자신의 스레드에서 수신자를 반복적으로 확인하며 수신된 모든 작업의 클로저를 실행할 것입니다.</li>
</ol>
<p>먼저 예제 21-16에 표시된 대로 <code>ThreadPool::new</code>에서 채널을 생성하고 <code>ThreadPool</code> 인스턴스에 송신자를 보관하는 것부터 시작하겠습니다. <code>Job</code> 구조체는 현재로서는 아무것도 가지고 있지 않지만, 채널을 통해 보낼 아이템의 타입이 될 것입니다.</p>
<Listing number="21-16" file-name="src/lib.rs" caption="Modifying `ThreadPool` to store the sender of a channel that transmits `Job` instances">
<pre><code class="language-rust noplayground">use std::{sync::mpsc, thread};

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Job&gt;,
}

struct Job;

impl ThreadPool {
    // --생략--
<span class="boring">    /// 새로운 ThreadPool을 생성합니다.
</span><span class="boring">    ///
</span><span class="boring">    /// size는 풀의 스레드 개수입니다.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// `new` 함수는 size가 0일 경우 패닉을 일으킵니다.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers, sender }
    }
    // --생략--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(|| {});
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p><code>ThreadPool::new</code>에서 새로운 채널을 생성하고 풀이 송신자를 보관하게 합니다. 이는 성공적으로 컴파일될 것입니다.</p>
<p>스레드 풀이 채널을 생성할 때 각 <code>Worker</code>에게 채널의 수신자를 전달해 봅시다. 우리는 <code>Worker</code> 인스턴스가 생성하는 스레드 내에서 수신자를 사용하고 싶으므로, 클로저 내에서 <code>receiver</code> 파라미터를 참조할 것입니다. 예제 21-17의 코드는 아직 컴파일되지 않을 것입니다.</p>
<Listing number="21-17" file-name="src/lib.rs" caption="Passing the receiver to each `Worker`">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{sync::mpsc, thread};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Job;
</span><span class="boring">
</span>impl ThreadPool {
    // --생략--
<span class="boring">    /// 새로운 ThreadPool을 생성합니다.
</span><span class="boring">    ///
</span><span class="boring">    /// size는 풀의 스레드 개수입니다.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// `new` 함수는 size가 0일 경우 패닉을 일으킵니다.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver));
        }

        ThreadPool { workers, sender }
    }
    // --생략--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// --생략--

<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
        let thread = thread::spawn(|| {
            receiver;
        });

        Worker { id, thread }
    }
}</code></pre>
</Listing>
<p>We’ve made some small and straightforward changes: We pass the receiver into <code>Worker::new</code>, and then we use it inside the closure.</p>
<p>이 코드를 체크하려고 하면 다음과 같은 에러가 발생합니다.</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0382]: use of moved value: `receiver`
  --&gt; src/lib.rs:26:42
   |
21 |         let (sender, receiver) = mpsc::channel();
   |                      -------- move occurs because `receiver` has type `std::sync::mpsc::Receiver&lt;Job&gt;`, which does not implement the `Copy` trait
...
25 |         for id in 0..size {
   |         ----------------- inside of this loop
26 |             workers.push(Worker::new(id, receiver));
   |                                          ^^^^^^^^ value moved here, in previous iteration of loop
   |
note: consider changing this parameter type in method `new` to borrow instead if owning the value isn't necessary
  --&gt; src/lib.rs:47:33
   |
47 |     fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
   |        --- in this method       ^^^^^^^^^^^^^^^^^^^ this parameter takes ownership of the value
help: consider moving the expression out of the loop so it is only moved once
   |
25 ~         let mut value = Worker::new(id, receiver);
26 ~         for id in 0..size {
27 ~             workers.push(value);
   |

For more information about this error, try `rustc --explain E0382`.
error: could not compile `hello` (lib) due to 1 previous error
</code></pre>
<p>The code is trying to pass <code>receiver</code> to multiple <code>Worker</code> instances. This won’t work, as you’ll recall from Chapter 16: The channel implementation that Rust provides is multiple <em>producer</em>, single <em>consumer</em>. This means we can’t just clone the consuming end of the channel to fix this code. We also don’t want to send a message multiple times to multiple consumers; we want one list of messages with multiple <code>Worker</code> instances such that each message gets processed once.</p>
<p>또한 채널 큐에서 작업을 꺼내는 일은 <code>receiver</code>를 수정하는 과정을 포함하므로, 스레드들이 <code>receiver</code>를 안전하게 공유하고 수정할 수 있는 방법이 필요합니다. 그렇지 않으면 (16장에서 다룬 것처럼) 레이스 컨디션이 발생할 수 있습니다.</p>
<p>Recall the thread-safe smart pointers discussed in Chapter 16: To share ownership across multiple threads and allow the threads to mutate the value, we need to use <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>. The <code>Arc</code> type will let multiple <code>Worker</code> instances own the receiver, and <code>Mutex</code> will ensure that only one <code>Worker</code> gets a job from the receiver at a time. Listing 21-18 shows the changes we need to make.</p>
<Listing number="21-18" file-name="src/lib.rs" caption="Sharing the receiver among the `Worker` instances using `Arc` and `Mutex`">
<pre><code class="language-rust noplayground">use std::{
    sync::{Arc, Mutex, mpsc},
    thread,
};
// --생략--

<span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Job;
</span><span class="boring">
</span>impl ThreadPool {
    // --생략--
<span class="boring">    /// 새로운 ThreadPool을 생성합니다.
</span><span class="boring">    ///
</span><span class="boring">    /// size는 풀의 스레드 개수입니다.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// `new` 함수는 size가 0일 경우 패닉을 일으킵니다.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool { workers, sender }
    }

    // --생략--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// --생략--

<span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --생략--
<span class="boring">        let thread = thread::spawn(|| {
</span><span class="boring">            receiver;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span>    }
}</code></pre>
</Listing>
<p>In <code>ThreadPool::new</code>, we put the receiver in an <code>Arc</code> and a <code>Mutex</code>. For each new <code>Worker</code>, we clone the <code>Arc</code> to bump the reference count so that the <code>Worker</code> instances can share ownership of the receiver.</p>
<p>이러한 변경 사항을 적용하면 코드가 컴파일됩니다! 거의 다 왔습니다!</p>
<h4 id="execute-메서드-구현하기"><a class="header" href="#execute-메서드-구현하기"><code>execute</code> 메서드 구현하기</a></h4>
<p>Let’s finally implement the <code>execute</code> method on <code>ThreadPool</code>. We’ll also change <code>Job</code> from a struct to a type alias for a trait object that holds the type of closure that <code>execute</code> receives. As discussed in the <a href="ch20-03-advanced-types.html#type-synonyms-and-type-aliases">“Type Synonyms and Type Aliases”</a><!-- ignore --> section in Chapter 20, type aliases allow us to make long types shorter for ease of use. Look at Listing 21-19.</p>
<Listing number="21-19" file-name="src/lib.rs" caption="Creating a `Job` type alias for a `Box` that holds each closure and then sending the job down the channel">
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{Arc, Mutex, mpsc},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// --생략--

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    // --생략--
<span class="boring">    /// 새로운 ThreadPool을 생성합니다.
</span><span class="boring">    ///
</span><span class="boring">    /// size는 풀의 스레드 개수입니다.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// `new` 함수는 size가 0일 경우 패닉을 일으킵니다.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span>
    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(job).unwrap();
    }
}

// --생략--
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(|| {
</span><span class="boring">            receiver;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>After creating a new <code>Job</code> instance using the closure we get in <code>execute</code>, we send that job down the sending end of the channel. We’re calling <code>unwrap</code> on <code>send</code> for the case that sending fails. This might happen if, for example, we stop all our threads from executing, meaning the receiving end has stopped receiving new messages. At the moment, we can’t stop our threads from executing: Our threads continue executing as long as the pool exists. The reason we use <code>unwrap</code> is that we know the failure case won’t happen, but the compiler doesn’t know that.</p>
<p>하지만 아직 끝난 것이 아닙니다! <code>Worker</code>에서 <code>thread::spawn</code>으로 전달되는 클로저는 여전히 채널의 수신 단을 _참조_만 하고 있습니다. 대신, 우리는 클로저가 무한히 루프를 돌면서 채널의 수신 단에 작업을 요청하고, 작업을 받으면 이를 실행하도록 해야 합니다. 예제 21-20과 같이 <code>Worker::new</code>를 수정해 봅시다.</p>
<Listing number="21-20" file-name="src/lib.rs" caption="Receiving and executing the jobs in the `Worker` instance’s thread">
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{Arc, Mutex, mpsc},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// 새로운 ThreadPool을 생성합니다.
</span><span class="boring">    ///
</span><span class="boring">    /// size는 풀의 스레드 개수입니다.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// `new` 함수는 size가 0일 경우 패닉을 일으킵니다.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// --생략--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            loop {
                let job = receiver.lock().unwrap().recv().unwrap();

                println!("워커 {id}가 작업을 받았습니다. 실행합니다.");

                job();
            }
        });

        Worker { id, thread }
    }
}</code></pre>
</Listing>
<p>여기서 우리는 먼저 뮤텍스를 획득하기 위해 <code>receiver</code>에 대해 <code>lock</code>을 호출하고, 에러 발생 시 패닉을 일으키도록 <code>unwrap</code>을 호출합니다. 뮤텍스가 <em>포이즌(poisoned)</em> 상태인 경우 락 획득이 실패할 수 있는데, 이는 다른 스레드가 락을 해제하지 않고 락을 보유한 채로 패닉을 일으켰을 때 발생할 수 있습니다. 이러한 상황에서는 현재 스레드도 패닉을 일으키도록 <code>unwrap</code>을 호출하는 것이 올바른 조치입니다. 원하신다면 이 <code>unwrap</code>을 여러분에게 의미 있는 에러 메시지를 담은 <code>expect</code>로 바꾸셔도 됩니다.</p>
<p>뮤텍스 락을 획득하면 채널로부터 <code>Job</code>을 받기 위해 <code>recv</code>를 호출합니다. 마지막 <code>unwrap</code>은 여기서 발생할 수 있는 에러도 처리하는데, 이는 송신자를 보유한 스레드가 종료되었을 때 발생할 수 있습니다. 이는 수신자가 종료되었을 때 <code>send</code> 메서드가 <code>Err</code>을 반환하는 것과 유사합니다.</p>
<p><code>recv</code> 호출은 블로킹 방식으로 동작하므로, 아직 작업이 없다면 현재 스레드는 작업이 사용 가능해질 때까지 대기합니다. <code>Mutex&lt;T&gt;</code>는 한 번에 하나의 <code>Worker</code> 스레드만이 작업을 요청하도록 보장합니다.</p>
<p>이제 우리 스레드 풀이 작동하는 상태가 되었습니다! <code>cargo run</code>을 실행하고 몇 가지 요청을 보내보세요.</p>
<!-- manual-regeneration
cd listings/ch21-web-server/listing-21-20
cargo run
make some requests to 127.0.0.1:7878
Can't automate because the output depends on making requests
-->
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
warning: field `workers` is never read
 --&gt; src/lib.rs:7:5
  |
6 | pub struct ThreadPool {
  |            ---------- field in this struct
7 |     workers: Vec&lt;Worker&gt;,
  |     ^^^^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: fields `id` and `thread` are never read
  --&gt; src/lib.rs:48:5
   |
47 | struct Worker {
   |        ------ fields in this struct
48 |     id: usize,
   |     ^^
49 |     thread: thread::JoinHandle&lt;()&gt;
   |     ^^^^^^

warning: `hello` (lib) generated 2 warnings
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 4.91s
     Running `target/debug/hello`
워커 0이 작업을 받았습니다. 실행합니다.
워커 2가 작업을 받았습니다. 실행합니다.
워커 1이 작업을 받았습니다. 실행합니다.
워커 3이 작업을 받았습니다. 실행합니다.
워커 0이 작업을 받았습니다. 실행합니다.
워커 2가 작업을 받았습니다. 실행합니다.
워커 1이 작업을 받았습니다. 실행합니다.
워커 3이 작업을 받았습니다. 실행합니다.
워커 0이 작업을 받았습니다. 실행합니다.
워커 2가 작업을 받았습니다. 실행합니다.
</code></pre>
<p>성공입니다! 이제 연결을 비동기적으로 실행하는 스레드 풀을 갖게 되었습니다. 생성되는 스레드는 4개를 넘지 않으므로, 서버가 많은 요청을 받더라도 시스템에 과부하가 걸리지 않을 것입니다. _/sleep_에 대한 요청을 보내더라도, 서버는 다른 스레드를 통해 다른 요청들을 처리할 수 있습니다.</p>
<blockquote>
<p>참고: 만약 여러 브라우저 창에서 동시에 _/sleep_을 열면, 5초 간격으로 하나씩 로드될 수도 있습니다. 일부 웹 브라우저는 캐싱 등의 이유로 동일한 요청의 여러 인스턴스를 순차적으로 실행합니다. 이러한 제한은 우리 웹 서버 때문에 발생하는 것이 아닙니다.</p>
</blockquote>
<p>잠시 멈추고, 수행할 작업에 클로저 대신 퓨처(future)를 사용했다면 예제 21-18, 21-19, 21-20의 코드가 어떻게 달라졌을지 생각해 보기 좋은 시간입니다. 어떤 타입들이 바뀌었을까요? 메서드 시그니처는 어떻게 달라졌을까요(혹은 그대로일까요)? 코드의 어떤 부분들이 그대로 유지되었을까요?</p>
<p>After learning about the <code>while let</code> loop in Chapter 17 and Chapter 19, you might be wondering why we didn’t write the <code>Worker</code> thread code as shown in Listing 21-21.</p>
<Listing number="21-21" file-name="src/lib.rs" caption="An alternative implementation of `Worker::new` using `while let`">
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">use std::{
</span><span class="boring">    sync::{Arc, Mutex, mpsc},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// 새로운 ThreadPool을 생성합니다.
</span><span class="boring">    ///
</span><span class="boring">    /// size는 풀의 스레드 개수입니다.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// `new` 함수는 size가 0일 경우 패닉을 일으킵니다.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span>// --생략--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            while let Ok(job) = receiver.lock().unwrap().recv() {
                println!("워커 {id}가 작업을 받았습니다. 실행합니다.");

                job();
            }
        });

        Worker { id, thread }
    }
}</code></pre>
</Listing>
<p>This code compiles and runs but doesn’t result in the desired threading behavior: A slow request will still cause other requests to wait to be processed. The reason is somewhat subtle: The <code>Mutex</code> struct has no public <code>unlock</code> method because the ownership of the lock is based on the lifetime of the <code>MutexGuard&lt;T&gt;</code> within the <code>LockResult&lt;MutexGuard&lt;T&gt;&gt;</code> that the <code>lock</code> method returns. At compile time, the borrow checker can then enforce the rule that a resource guarded by a <code>Mutex</code> cannot be accessed unless we hold the lock. However, this implementation can also result in the lock being held longer than intended if we aren’t mindful of the lifetime of the <code>MutexGuard&lt;T&gt;</code>.</p>
<p>The code in Listing 21-20 that uses <code>let job = receiver.lock().unwrap().recv().unwrap();</code> works because with <code>let</code>, any temporary values used in the expression on the right-hand side of the equal sign are immediately dropped when the <code>let</code> statement ends. However, <code>while let</code> (and <code>if let</code> and <code>match</code>) does not drop temporary values until the end of the associated block. In Listing 21-21, the lock remains held for the duration of the call to <code>job()</code>, meaning other <code>Worker</code> instances cannot receive jobs.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch21-01-single-threaded.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch21-03-graceful-shutdown-and-cleanup.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch21-01-single-threaded.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch21-03-graceful-shutdown-and-cleanup.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
