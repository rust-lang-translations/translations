<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>객체 지향 디자인 패턴 구현하기 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch18-03-oo-design-patterns.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch18-03-oo-design-patterns.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="객체-지향-디자인-패턴-구현하기"><a class="header" href="#객체-지향-디자인-패턴-구현하기">객체 지향 디자인 패턴 구현하기</a></h2>
<p>The <em>state pattern</em> is an object-oriented design pattern. The crux of the pattern is that we define a set of states a value can have internally. The states are represented by a set of <em>state objects</em>, and the value’s behavior changes based on its state. We’re going to work through an example of a blog post struct that has a field to hold its state, which will be a state object from the set “draft,” “review,” or “published.”</p>
<p>The state objects share functionality: In Rust, of course, we use structs and traits rather than objects and inheritance. Each state object is responsible for its own behavior and for governing when it should change into another state. The value that holds a state object knows nothing about the different behavior of the states or when to transition between states.</p>
<p>상태 패턴을 사용하는 것의 장점은 프로그램의 비즈니스 요구사항이 변경될 때, 상태를 보유한 값의 코드나 그 값을 사용하는 코드를 변경할 필요가 없다는 것입니다. 단지 상태 객체 중 하나의 내부 코드를 업데이트하여 규칙을 변경하거나, 새로운 상태 객체를 추가하기만 하면 됩니다.</p>
<p>First, we’re going to implement the state pattern in a more traditional object-oriented way. Then, we’ll use an approach that’s a bit more natural in Rust. Let’s dig in to incrementally implement a blog post workflow using the state pattern.</p>
<p>최종 기능은 다음과 같은 모습이 될 것입니다.</p>
<ol>
<li>블로그 포스트는 빈 초안으로 시작합니다.</li>
<li>초안 작성이 완료되면, 포스트에 대한 리뷰가 요청됩니다.</li>
<li>포스트가 승인되면, 게시됩니다.</li>
<li>Only published blog posts return content to print so that unapproved posts can’t accidentally be published.</li>
</ol>
<p>포스트에 시도된 다른 모든 변경 사항은 아무런 효과가 없어야 합니다. 예를 들어, 리뷰를 요청하기 전에 초안 블로그 포스트를 승인하려고 시도하면, 포스트는 게시되지 않은 초안 상태로 남아 있어야 합니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="a-traditional-object-oriented-attempt"></a></p>
<h3 id="attempting-traditional-object-oriented-style"><a class="header" href="#attempting-traditional-object-oriented-style">Attempting Traditional Object-Oriented Style</a></h3>
<p>There are infinite ways to structure code to solve the same problem, each with different trade-offs. This section’s implementation is more of a traditional object-oriented style, which is possible to write in Rust, but doesn’t take advantage of some of Rust’s strengths. Later, we’ll demonstrate a different solution that still uses the object-oriented design pattern but is structured in a way that might look less familiar to programmers with object-oriented experience. We’ll compare the two solutions to experience the trade-offs of designing Rust code differently than code in other languages.</p>
<p>Listing 18-11 shows this workflow in code form: This is an example usage of the API we’ll implement in a library crate named <code>blog</code>. This won’t compile yet because we haven’t implemented the <code>blog</code> crate.</p>
<Listing number="18-11" file-name="src/main.rs" caption="Code that demonstrates the desired behavior we want our `blog` crate to have">
<pre><code class="language-rust ignore does_not_compile">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("나는 오늘 점심으로 샐러드를 먹었다");
    assert_eq!("", post.content());

    post.request_review();
    assert_eq!("", post.content());

    post.approve();
    assert_eq!("나는 오늘 점심으로 샐러드를 먹었다", post.content());
}</code></pre>
</Listing>
<p>우리는 사용자가 <code>Post::new</code>로 새로운 초안 블로그 포스트를 생성할 수 있게 하고자 합니다. 또한 블로그 포스트에 텍스트를 추가할 수 있게 하고 싶습니다. 만약 승인되기 전인 초안 상태에서 즉시 포스트의 내용을 가져오려고 시도한다면, 어떤 텍스트도 얻지 못해야 합니다. 설명을 돕기 위해 코드에 <code>assert_eq!</code>를 추가했습니다. 이에 대한 훌륭한 유닛 테스트는 초안 블로그 포스트의 <code>content</code> 메서드가 빈 문자열을 반환하는지 확인하는 것이겠지만, 이 예제에서는 테스트를 작성하지 않겠습니다.</p>
<p>다음으로, 포스트에 대한 리뷰 요청을 가능하게 하고 싶으며, 리뷰를 기다리는 동안에도 <code>content</code>가 빈 문자열을 반환하게 하고 싶습니다. 포스트가 승인을 받으면 게시되어야 하며, 이는 <code>content</code>가 호출될 때 포스트의 텍스트가 반환됨을 의미합니다.</p>
<p>Notice that the only type we’re interacting with from the crate is the <code>Post</code> type. This type will use the state pattern and will hold a value that will be one of three state objects representing the various states a post can be in—draft, review, or published. Changing from one state to another will be managed internally within the <code>Post</code> type. The states change in response to the methods called by our library’s users on the <code>Post</code> instance, but they don’t have to manage the state changes directly. Also, users can’t make a mistake with the states, such as publishing a post before it’s reviewed.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="defining-post-and-creating-a-new-instance-in-the-draft-state"></a></p>
<h4 id="defining-post-and-creating-a-new-instance"><a class="header" href="#defining-post-and-creating-a-new-instance">Defining <code>Post</code> and Creating a New Instance</a></h4>
<p>라이브러리 구현을 시작해 봅시다! 우리는 내용을 담을 공개된 <code>Post</code> 구조체가 필요하다는 것을 알고 있으므로, 목록 18-12에 나타난 것처럼 구조체의 정의와 <code>Post</code> 인스턴스를 생성하는 연관된 공개 <code>new</code> 함수로 시작합니다. 또한 <code>Post</code>를 위한 모든 상태 객체가 가져야 할 동작을 정의하는 비공개 <code>State</code> 트레이트를 만들 것입니다.</p>
<p>Then, <code>Post</code> will hold a trait object of <code>Box&lt;dyn State&gt;</code> inside an <code>Option&lt;T&gt;</code> in a private field named <code>state</code> to hold the state object. You’ll see why the <code>Option&lt;T&gt;</code> is necessary in a bit.</p>
<Listing number="18-12" file-name="src/lib.rs" caption="Definition of a `Post` struct and a `new` function that creates a new `Post` instance, a `State` trait, and a `Draft` struct">
<pre><code class="language-rust noplayground">pub struct Post {
    state: Option&lt;Box&lt;dyn State&gt;&gt;,
    content: String,
}

impl Post {
    pub fn new() -&gt; Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}</code></pre>
</Listing>
<p><code>State</code> 트레이트는 서로 다른 포스트 상태들이 공유하는 동작을 정의합니다. 상태 객체들은 <code>Draft</code>, <code>PendingReview</code>, <code>Published</code>이며, 이들은 모두 <code>State</code> 트레이트를 구현할 것입니다. 현재로서는 이 트레이트에 메서드가 없으며, 포스트가 시작되어야 할 상태인 <code>Draft</code> 상태부터 정의하며 시작해 보겠습니다.</p>
<p>When we create a new <code>Post</code>, we set its <code>state</code> field to a <code>Some</code> value that holds a <code>Box</code>. This <code>Box</code> points to a new instance of the <code>Draft</code> struct. This ensures that whenever we create a new instance of <code>Post</code>, it will start out as a draft. Because the <code>state</code> field of <code>Post</code> is private, there is no way to create a <code>Post</code> in any other state! In the <code>Post::new</code> function, we set the <code>content</code> field to a new, empty <code>String</code>.</p>
<h4 id="포스트-내용의-텍스트-저장하기"><a class="header" href="#포스트-내용의-텍스트-저장하기">포스트 내용의 텍스트 저장하기</a></h4>
<p>We saw in Listing 18-11 that we want to be able to call a method named <code>add_text</code> and pass it a <code>&amp;str</code> that is then added as the text content of the blog post. We implement this as a method, rather than exposing the <code>content</code> field as <code>pub</code>, so that later we can implement a method that will control how the <code>content</code> field’s data is read. The <code>add_text</code> method is pretty straightforward, so let’s add the implementation in Listing 18-13 to the <code>impl Post</code> block.</p>
<Listing number="18-13" file-name="src/lib.rs" caption="Implementing the `add_text` method to add text to a post’s `content`">
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --생략--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}</span></code></pre>
</Listing>
<p>The <code>add_text</code> method takes a mutable reference to <code>self</code> because we’re changing the <code>Post</code> instance that we’re calling <code>add_text</code> on. We then call <code>push_str</code> on the <code>String</code> in <code>content</code> and pass the <code>text</code> argument to add to the saved <code>content</code>. This behavior doesn’t depend on the state the post is in, so it’s not part of the state pattern. The <code>add_text</code> method doesn’t interact with the <code>state</code> field at all, but it is part of the behavior we want to support.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="ensuring-the-content-of-a-draft-post-is-empty"></a></p>
<h4 id="ensuring-that-the-content-of-a-draft-post-is-empty"><a class="header" href="#ensuring-that-the-content-of-a-draft-post-is-empty">Ensuring That the Content of a Draft Post Is Empty</a></h4>
<p>Even after we’ve called <code>add_text</code> and added some content to our post, we still want the <code>content</code> method to return an empty string slice because the post is still in the draft state, as shown by the first <code>assert_eq!</code> in Listing 18-11. For now, let’s implement the <code>content</code> method with the simplest thing that will fulfill this requirement: always returning an empty string slice. We’ll change this later once we implement the ability to change a post’s state so that it can be published. So far, posts can only be in the draft state, so the post content should always be empty. Listing 18-14 shows this placeholder implementation.</p>
<Listing number="18-14" file-name="src/lib.rs" caption="Adding a placeholder implementation for the `content` method on `Post` that always returns an empty string slice">
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --생략--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        ""
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}</span></code></pre>
</Listing>
<p>With this added <code>content</code> method, everything in Listing 18-11 through the first <code>assert_eq!</code> works as intended.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="requesting-a-review-of-the-post-changes-its-state"></a> <a id="requesting-a-review-changes-the-posts-state"></a></p>
<h4 id="requesting-a-review-which-changes-the-posts-state"><a class="header" href="#requesting-a-review-which-changes-the-posts-state">Requesting a Review, Which Changes the Post’s State</a></h4>
<p>Next, we need to add functionality to request a review of a post, which should change its state from <code>Draft</code> to <code>PendingReview</code>. Listing 18-15 shows this code.</p>
<Listing number="18-15" file-name="src/lib.rs" caption="Implementing `request_review` methods on `Post` and the `State` trait">
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --생략--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        ""
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}</code></pre>
</Listing>
<p>We give <code>Post</code> a public method named <code>request_review</code> that will take a mutable reference to <code>self</code>. Then, we call an internal <code>request_review</code> method on the current state of <code>Post</code>, and this second <code>request_review</code> method consumes the current state and returns a new state.</p>
<p>We add the <code>request_review</code> method to the <code>State</code> trait; all types that implement the trait will now need to implement the <code>request_review</code> method. Note that rather than having <code>self</code>, <code>&amp;self</code>, or <code>&amp;mut self</code> as the first parameter of the method, we have <code>self: Box&lt;Self&gt;</code>. This syntax means the method is only valid when called on a <code>Box</code> holding the type. This syntax takes ownership of <code>Box&lt;Self&gt;</code>, invalidating the old state so that the state value of the <code>Post</code> can transform into a new state.</p>
<p>To consume the old state, the <code>request_review</code> method needs to take ownership of the state value. This is where the <code>Option</code> in the <code>state</code> field of <code>Post</code> comes in: We call the <code>take</code> method to take the <code>Some</code> value out of the <code>state</code> field and leave a <code>None</code> in its place because Rust doesn’t let us have unpopulated fields in structs. This lets us move the <code>state</code> value out of <code>Post</code> rather than borrowing it. Then, we’ll set the post’s <code>state</code> value to the result of this operation.</p>
<p>We need to set <code>state</code> to <code>None</code> temporarily rather than setting it directly with code like <code>self.state = self.state.request_review();</code> to get ownership of the <code>state</code> value. This ensures that <code>Post</code> can’t use the old <code>state</code> value after we’ve transformed it into a new state.</p>
<p>The <code>request_review</code> method on <code>Draft</code> returns a new, boxed instance of a new <code>PendingReview</code> struct, which represents the state when a post is waiting for a review. The <code>PendingReview</code> struct also implements the <code>request_review</code> method but doesn’t do any transformations. Rather, it returns itself because when we request a review on a post already in the <code>PendingReview</code> state, it should stay in the <code>PendingReview</code> state.</p>
<p>Now we can start seeing the advantages of the state pattern: The <code>request_review</code> method on <code>Post</code> is the same no matter its <code>state</code> value. Each state is responsible for its own rules.</p>
<p>We’ll leave the <code>content</code> method on <code>Post</code> as is, returning an empty string slice. We can now have a <code>Post</code> in the <code>PendingReview</code> state as well as in the <code>Draft</code> state, but we want the same behavior in the <code>PendingReview</code> state. Listing 18-11 now works up to the second <code>assert_eq!</code> call!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="adding-the-approve-method-that-changes-the-behavior-of-content"></a> <a id="adding-approve-to-change-the-behavior-of-content"></a></p>
<h4 id="adding-approve-to-change-contents-behavior"><a class="header" href="#adding-approve-to-change-contents-behavior">Adding <code>approve</code> to Change <code>content</code>'s Behavior</a></h4>
<p>The <code>approve</code> method will be similar to the <code>request_review</code> method: It will set <code>state</code> to the value that the current state says it should have when that state is approved, as shown in Listing 18-16.</p>
<Listing number="18-16" file-name="src/lib.rs" caption="Implementing the `approve` method on `Post` and the `State` trait">
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --생략--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        ""
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn approve(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    // --생략--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
    // --생략--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }

    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}</code></pre>
</Listing>
<p>우리는 <code>State</code> 트레이트에 <code>approve</code> 메서드를 추가하고, <code>State</code>를 구현하는 새로운 구조체인 <code>Published</code> 상태를 추가합니다.</p>
<p>Similar to the way <code>request_review</code> on <code>PendingReview</code> works, if we call the <code>approve</code> method on a <code>Draft</code>, it will have no effect because <code>approve</code> will return <code>self</code>. When we call <code>approve</code> on <code>PendingReview</code>, it returns a new, boxed instance of the <code>Published</code> struct. The <code>Published</code> struct implements the <code>State</code> trait, and for both the <code>request_review</code> method and the <code>approve</code> method, it returns itself because the post should stay in the <code>Published</code> state in those cases.</p>
<p>Now we need to update the <code>content</code> method on <code>Post</code>. We want the value returned from <code>content</code> to depend on the current state of the <code>Post</code>, so we’re going to have the <code>Post</code> delegate to a <code>content</code> method defined on its <code>state</code>, as shown in Listing 18-17.</p>
<Listing number="18-17" file-name="src/lib.rs" caption="Updating the `content` method on `Post` to delegate to a `content` method on `State`">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --생략--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        self.state.as_ref().unwrap().content(self)
    }
    // --생략--
<span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">trait State {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Published {}
</span><span class="boring">
</span><span class="boring">impl State for Published {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>Because the goal is to keep all of these rules inside the structs that implement <code>State</code>, we call a <code>content</code> method on the value in <code>state</code> and pass the post instance (that is, <code>self</code>) as an argument. Then, we return the value that’s returned from using the <code>content</code> method on the <code>state</code> value.</p>
<p>우리는 값의 소유권보다는 <code>Option</code> 내부의 값에 대한 참조를 원하므로 <code>Option</code>에 대해 <code>as_ref</code> 메서드를 호출합니다. <code>state</code>가 <code>Option&lt;Box&lt;dyn State&gt;&gt;</code>이므로, <code>as_ref</code>를 호출하면 <code>Option&lt;&amp;Box&lt;dyn State&gt;&gt;</code>가 반환됩니다. 만약 <code>as_ref</code>를 호출하지 않는다면, 함수 매개변수인 대여된 <code>&amp;self</code>로부터 <code>state</code>를 밖으로 이동시킬 수 없기 때문에 에러가 발생할 것입니다.</p>
<p>We then call the <code>unwrap</code> method, which we know will never panic because we know the methods on <code>Post</code> ensure that <code>state</code> will always contain a <code>Some</code> value when those methods are done. This is one of the cases we talked about in the <a href="ch09-03-to-panic-or-not-to-panic.html#cases-in-which-you-have-more-information-than-the-compiler">“When You Have More Information Than the Compiler”</a><!-- ignore --> section of Chapter 9 when we know that a <code>None</code> value is never possible, even though the compiler isn’t able to understand that.</p>
<p>At this point, when we call <code>content</code> on the <code>&amp;Box&lt;dyn State&gt;</code>, deref coercion will take effect on the <code>&amp;</code> and the <code>Box</code> so that the <code>content</code> method will ultimately be called on the type that implements the <code>State</code> trait. That means we need to add <code>content</code> to the <code>State</code> trait definition, and that is where we’ll put the logic for what content to return depending on which state we have, as shown in Listing 18-18.</p>
<Listing number="18-18" file-name="src/lib.rs" caption="Adding the `content` method to the `State` trait">
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        self.state.as_ref().unwrap().content(self)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>trait State {
    // --생략--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        ""
    }
}

// --생략--
<span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Published {}

impl State for Published {
    // --생략--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &amp;post.content
    }
}</code></pre>
</Listing>
<p>We add a default implementation for the <code>content</code> method that returns an empty string slice. That means we don’t need to implement <code>content</code> on the <code>Draft</code> and <code>PendingReview</code> structs. The <code>Published</code> struct will override the <code>content</code> method and return the value in <code>post.content</code>. While convenient, having the <code>content</code> method on <code>State</code> determine the content of the <code>Post</code> is blurring the lines between the responsibility of <code>State</code> and the responsibility of <code>Post</code>.</p>
<p>10장에서 논의했던 것처럼, 이 메서드에는 라이프타임 어노테이션이 필요하다는 점에 유의하세요. 우리는 <code>post</code>에 대한 참조를 인수로 받고 해당 <code>post</code>의 일부에 대한 참조를 반환하므로, 반환되는 참조의 라이프타임은 <code>post</code> 인수의 라이프타임과 관련이 있습니다.</p>
<p>이제 다 되었습니다—목록 18-11의 모든 코드가 정상 작동합니다! 우리는 블로그 포스트 워크플로우의 규칙들을 사용하여 상태 패턴을 구현했습니다. 규칙과 관련된 로직은 <code>Post</code> 전체에 흩어져 있는 대신 상태 객체들 내부에 위치하게 됩니다.</p>
<blockquote>
<h3 id="왜-열거형은-사용하지-않았나요"><a class="header" href="#왜-열거형은-사용하지-않았나요">왜 열거형은 사용하지 않았나요?</a></h3>
<p>You may have been wondering why we didn’t use an enum with the different possible post states as variants. That’s certainly a possible solution; try it and compare the end results to see which you prefer! One disadvantage of using an enum is that every place that checks the value of the enum will need a <code>match</code> expression or similar to handle every possible variant. This could get more repetitive than this trait object solution.</p>
</blockquote>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="trade-offs-of-the-state-pattern"></a></p>
<h4 id="evaluating-the-state-pattern"><a class="header" href="#evaluating-the-state-pattern">Evaluating the State Pattern</a></h4>
<p>We’ve shown that Rust is capable of implementing the object-oriented state pattern to encapsulate the different kinds of behavior a post should have in each state. The methods on <code>Post</code> know nothing about the various behaviors. Because of the way we organized the code, we have to look in only one place to know the different ways a published post can behave: the implementation of the <code>State</code> trait on the <code>Published</code> struct.</p>
<p>If we were to create an alternative implementation that didn’t use the state pattern, we might instead use <code>match</code> expressions in the methods on <code>Post</code> or even in the <code>main</code> code that checks the state of the post and changes behavior in those places. That would mean we would have to look in several places to understand all the implications of a post being in the published state.</p>
<p>With the state pattern, the <code>Post</code> methods and the places we use <code>Post</code> don’t need <code>match</code> expressions, and to add a new state, we would only need to add a new struct and implement the trait methods on that one struct in one location.</p>
<p>상태 패턴을 사용한 구현은 기능을 더 추가하기 위해 확장하기 쉽습니다. 상태 패턴을 사용하는 코드의 유지보수 편의성을 확인해 보려면, 다음의 제안 사항들을 몇 가지 시도해 보세요.</p>
<ul>
<li>포스트의 상태를 <code>PendingReview</code>에서 다시 <code>Draft</code>로 되돌리는 <code>reject</code> 메서드를 추가해 보세요.</li>
<li>상태가 <code>Published</code>로 변경되기 전에 <code>approve</code>를 두 번 호출하도록 요구해 보세요.</li>
<li>포스트가 <code>Draft</code> 상태일 때만 사용자가 텍스트 내용을 추가할 수 있도록 허용해 보세요. 힌트: 상태 객체가 내용의 변경 가능 여부를 책임지게 하되, <code>Post</code>를 수정하는 책임은 가지지 않도록 하세요.</li>
</ul>
<p>상태 패턴의 한 가지 단점은, 상태들이 상태 간의 전환을 구현하기 때문에 일부 상태들이 서로 결합된다는 점입니다. 만약 <code>PendingReview</code>와 <code>Published</code> 사이에 <code>Scheduled</code>와 같은 다른 상태를 추가한다면, <code>Scheduled</code>로 전환되도록 <code>PendingReview</code>의 코드를 변경해야 합니다. 새로운 상태가 추가될 때 <code>PendingReview</code>를 변경할 필요가 없다면 작업이 더 줄어들겠지만, 이는 다른 디자인 패턴으로의 전환을 의미할 것입니다.</p>
<p>Another downside is that we’ve duplicated some logic. To eliminate some of the duplication, we might try to make default implementations for the <code>request_review</code> and <code>approve</code> methods on the <code>State</code> trait that return <code>self</code>. However, this wouldn’t work: When using <code>State</code> as a trait object, the trait doesn’t know what the concrete <code>self</code> will be exactly, so the return type isn’t known at compile time. (This is one of the dyn compatibility rules mentioned earlier.)</p>
<p>Other duplication includes the similar implementations of the <code>request_review</code> and <code>approve</code> methods on <code>Post</code>. Both methods use <code>Option::take</code> with the <code>state</code> field of <code>Post</code>, and if <code>state</code> is <code>Some</code>, they delegate to the wrapped value’s implementation of the same method and set the new value of the <code>state</code> field to the result. If we had a lot of methods on <code>Post</code> that followed this pattern, we might consider defining a macro to eliminate the repetition (see the <a href="ch20-05-macros.html#macros">“Macros”</a><!-- ignore --> section in Chapter 20).</p>
<p>By implementing the state pattern exactly as it’s defined for object-oriented languages, we’re not taking as full advantage of Rust’s strengths as we could. Let’s look at some changes we can make to the <code>blog</code> crate that can make invalid states and transitions into compile-time errors.</p>
<h3 id="상태와-동작을-타입으로-인코딩하기"><a class="header" href="#상태와-동작을-타입으로-인코딩하기">상태와 동작을 타입으로 인코딩하기</a></h3>
<p>We’ll show you how to rethink the state pattern to get a different set of trade-offs. Rather than encapsulating the states and transitions completely so that outside code has no knowledge of them, we’ll encode the states into different types. Consequently, Rust’s type-checking system will prevent attempts to use draft posts where only published posts are allowed by issuing a compiler error.</p>
<p>목록 18-11에 있는 <code>main</code>의 첫 번째 부분을 살펴봅시다.</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore"><span class="boring">use blog::Post;
</span><span class="boring">
</span>fn main() {
    let mut post = Post::new();

    post.add_text("나는 오늘 점심으로 샐러드를 먹었다");
    assert_eq!("", post.content());
<span class="boring">
</span><span class="boring">    post.request_review();
</span><span class="boring">    assert_eq!("", post.content());
</span><span class="boring">
</span><span class="boring">    post.approve();
</span><span class="boring">    assert_eq!("나는 오늘 점심으로 샐러드를 먹었다", post.content());
</span>}</code></pre>
</Listing>
<p>We still enable the creation of new posts in the draft state using <code>Post::new</code> and the ability to add text to the post’s content. But instead of having a <code>content</code> method on a draft post that returns an empty string, we’ll make it so that draft posts don’t have the <code>content</code> method at all. That way, if we try to get a draft post’s content, we’ll get a compiler error telling us the method doesn’t exist. As a result, it will be impossible for us to accidentally display draft post content in production because that code won’t even compile. Listing 18-19 shows the definition of a <code>Post</code> struct and a <code>DraftPost</code> struct, as well as methods on each.</p>
<Listing number="18-19" file-name="src/lib.rs" caption="A `Post` with a `content` method and a `DraftPost` without a `content` method">
<pre><code class="language-rust noplayground">pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -&gt; DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&amp;self) -&gt; &amp;str {
        &amp;self.content
    }
}

impl DraftPost {
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}</code></pre>
</Listing>
<p><code>Post</code>와 <code>DraftPost</code> 구조체 모두 블로그 포스트 텍스트를 저장하는 비공개 <code>content</code> 필드를 가집니다. 상태 인코딩을 구조체 타입으로 옮겼기 때문에 구조체들은 더 이상 <code>state</code> 필드를 가지지 않습니다. <code>Post</code> 구조체는 게시된 포스트를 나타내며, <code>content</code>를 반환하는 <code>content</code> 메서드를 가집니다.</p>
<p>우리는 여전히 <code>Post::new</code> 함수를 가지고 있지만, <code>Post</code> 인스턴스 대신 <code>DraftPost</code> 인스턴스를 반환합니다. <code>content</code>가 비공개이고 <code>Post</code>를 반환하는 함수가 없기 때문에, 현재로서는 <code>Post</code> 인스턴스를 생성하는 것이 불가능합니다.</p>
<p>The <code>DraftPost</code> struct has an <code>add_text</code> method, so we can add text to <code>content</code> as before, but note that <code>DraftPost</code> does not have a <code>content</code> method defined! So now the program ensures that all posts start as draft posts, and draft posts don’t have their content available for display. Any attempt to get around these constraints will result in a compiler error.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="implementing-transitions-as-transformations-into-different-types"></a></p>
<p>So, how do we get a published post? We want to enforce the rule that a draft post has to be reviewed and approved before it can be published. A post in the pending review state should still not display any content. Let’s implement these constraints by adding another struct, <code>PendingReviewPost</code>, defining the <code>request_review</code> method on <code>DraftPost</code> to return a <code>PendingReviewPost</code> and defining an <code>approve</code> method on <code>PendingReviewPost</code> to return a <code>Post</code>, as shown in Listing 18-20.</p>
<Listing number="18-20" file-name="src/lib.rs" caption="A `PendingReviewPost` that gets created by calling `request_review` on `DraftPost` and an `approve` method that turns a `PendingReviewPost` into a published `Post`">
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct DraftPost {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; DraftPost {
</span><span class="boring">        DraftPost {
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.content
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl DraftPost {
    // --생략--
<span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(self) -&gt; PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -&gt; Post {
        Post {
            content: self.content,
        }
    }
}</code></pre>
</Listing>
<p><code>request_review</code>와 <code>approve</code> 메서드는 <code>self</code>의 소유권을 가져가므로, <code>DraftPost</code>와 <code>PendingReviewPost</code> 인스턴스를 소비하고 이를 각각 <code>PendingReviewPost</code>와 게시된 <code>Post</code>로 변환합니다. 이런 식으로, 우리는 <code>request_review</code>를 호출한 후에 남아있는 <code>DraftPost</code> 인스턴스를 가지지 않게 됩니다. <code>PendingReviewPost</code> 구조체에는 <code>content</code> 메서드가 정의되어 있지 않으므로, 해당 내용을 읽으려는 시도는 <code>DraftPost</code>와 마찬가지로 컴파일 타임 에러를 발생시킵니다. <code>content</code> 메서드가 정의된 게시된 <code>Post</code> 인스턴스를 얻는 유일한 방법은 <code>PendingReviewPost</code>에서 <code>approve</code> 메서드를 호출하는 것이고, <code>PendingReviewPost</code>를 얻는 유일한 방법은 <code>DraftPost</code>에서 <code>request_review</code> 메서드를 호출하는 것이기 때문에, 우리는 이제 블로그 포스트 워크플로우를 타입 시스템에 인코딩했습니다.</p>
<p>But we also have to make some small changes to <code>main</code>. The <code>request_review</code> and <code>approve</code> methods return new instances rather than modifying the struct they’re called on, so we need to add more <code>let post =</code> shadowing assignments to save the returned instances. We also can’t have the assertions about the draft and pending review posts’ contents be empty strings, nor do we need them: We can’t compile code that tries to use the content of posts in those states any longer. The updated code in <code>main</code> is shown in Listing 18-21.</p>
<Listing number="18-21" file-name="src/main.rs" caption="Modifications to `main` to use the new implementation of the blog post workflow">
<pre><code class="language-rust ignore">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("나는 오늘 점심으로 샐러드를 먹었다");

    let post = post.request_review();

    let post = post.approve();

    assert_eq!("나는 오늘 점심으로 샐러드를 먹었다", post.content());
}</code></pre>
</Listing>
<p>The changes we needed to make to <code>main</code> to reassign <code>post</code> mean that this implementation doesn’t quite follow the object-oriented state pattern anymore: The transformations between the states are no longer encapsulated entirely within the <code>Post</code> implementation. However, our gain is that invalid states are now impossible because of the type system and the type checking that happens at compile time! This ensures that certain bugs, such as display of the content of an unpublished post, will be discovered before they make it to production.</p>
<p>목록 18-21 이후의 <code>blog</code> 크레이트에 대해 이 섹션의 시작 부분에서 제안했던 과제들을 시도해 보면서, 이 버전의 코드 설계에 대해 어떻게 생각하시는지 확인해 보세요. 일부 과제들은 이 설계에서 이미 완료되었을 수도 있습니다.</p>
<p>우리는 러스트가 객체 지향 디자인 패턴을 구현할 수 있을 뿐만 아니라, 상태를 타입 시스템에 인코딩하는 것과 같은 다른 패턴들도 러스트에서 가능함을 보았습니다. 이러한 패턴들은 각기 다른 트레이드오프를 가집니다. 객체 지향 패턴에 매우 익숙할지라도, 러스트의 기능을 활용하기 위해 문제를 다시 생각해 보는 것은 컴파일 타임에 일부 버그를 방지하는 것과 같은 이점을 제공할 수 있습니다. 객체 지향 언어에는 없는 소유권과 같은 특정 기능들 때문에, 객체 지향 패턴이 러스트에서 항상 최선의 해결책인 것은 아닙니다.</p>
<h2 id="요약"><a class="header" href="#요약">요약</a></h2>
<p>Regardless of whether you think Rust is an object-oriented language after reading this chapter, you now know that you can use trait objects to get some object-oriented features in Rust. Dynamic dispatch can give your code some flexibility in exchange for a bit of runtime performance. You can use this flexibility to implement object-oriented patterns that can help your code’s maintainability. Rust also has other features, like ownership, that object-oriented languages don’t have. An object-oriented pattern won’t always be the best way to take advantage of Rust’s strengths, but it is an available option.</p>
<p>다음으로, 많은 유연성을 가능하게 하는 러스트의 또 다른 기능인 패턴에 대해 알아보겠습니다. 책 전체에 걸쳐 짧게 살펴보긴 했지만, 아직 그 전체 기능을 보지는 못했습니다. 자, 시작해 봅시다!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch18-02-trait-objects.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch19-00-patterns.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch18-02-trait-objects.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch19-00-patterns.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
