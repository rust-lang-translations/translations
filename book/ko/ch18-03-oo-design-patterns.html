<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>객체 지향 디자인 패턴 구현하기 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch18-03-oo-design-patterns.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch18-03-oo-design-patterns.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="객체-지향-디자인-패턴-구현하기"><a class="header" href="#객체-지향-디자인-패턴-구현하기">객체 지향 디자인 패턴 구현하기</a></h2>
<p>_상태 패턴(state pattern)_은 객체 지향 디자인 패턴입니다. 이 패턴의 핵심은 값이 내부적으로 가질 수 있는 일련의 상태들을 정의하는 것입니다. 각 상태는 일련의 _상태 객체들_로 표현되며, 값의 동작은 자신의 상태에 따라 달라집니다. 우리는 자신의 상태를 보유할 필드를 가진 블로그 포스트 구조체의 예제를 통해 살펴볼 것입니다. 이때 상태는 "초안(draft)", "리뷰(review)", "게시됨(published)" 상태 세트 중 하나의 상태 객체가 될 것입니다.</p>
<p>상태 객체들은 기능을 공유합니다. 물론 러스트에서는 객체와 상속 대신 구조체와 트레이트를 사용합니다. 각 상태 객체는 자신의 동작과 다른 상태로 언제 전환되어야 하는지를 관리할 책임이 있습니다. 상태 객체를 보유한 값은 상태들의 서로 다른 동작이나 상태 간의 전환 시점에 대해 전혀 알지 못합니다.</p>
<p>상태 패턴을 사용하는 것의 장점은 프로그램의 비즈니스 요구사항이 변경될 때, 상태를 보유한 값의 코드나 그 값을 사용하는 코드를 변경할 필요가 없다는 것입니다. 단지 상태 객체 중 하나의 내부 코드를 업데이트하여 규칙을 변경하거나, 새로운 상태 객체를 추가하기만 하면 됩니다.</p>
<p>먼저 보다 전통적인 객체 지향 방식으로 상태 패턴을 구현해 보고, 그런 다음 러스트에 좀 더 자연스러운 방식을 사용해 보겠습니다. 상태 패턴을 사용하여 블로그 포스트 워크플로우를 점진적으로 구현해 봅시다.</p>
<p>최종 기능은 다음과 같은 모습이 될 것입니다.</p>
<ol>
<li>블로그 포스트는 빈 초안으로 시작합니다.</li>
<li>초안 작성이 완료되면, 포스트에 대한 리뷰가 요청됩니다.</li>
<li>포스트가 승인되면, 게시됩니다.</li>
<li>게시된 블로그 포스트만 출력할 내용을 반환하므로, 승인되지 않은 포스트가 실수로 게시되는 일을 방지할 수 있습니다.</li>
</ol>
<p>포스트에 시도된 다른 모든 변경 사항은 아무런 효과가 없어야 합니다. 예를 들어, 리뷰를 요청하기 전에 초안 블로그 포스트를 승인하려고 시도하면, 포스트는 게시되지 않은 초안 상태로 남아 있어야 합니다.</p>
<p>목록 18-11은 이 워크플로우를 코드 형태로 보여줍니다. 이는 우리가 <code>blog</code>라는 이름의 라이브러리 크레이트에서 구현할 API의 사용 예시입니다. <code>blog</code> 크레이트를 아직 구현하지 않았으므로 이 코드는 아직 컴파일되지 않습니다.</p>
<Listing number="18-11" file-name="src/main.rs" caption="Code that demonstrates the desired behavior we want our `blog` crate to have">
<pre><code class="language-rust ignore does_not_compile">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("나는 오늘 점심으로 샐러드를 먹었다");
    assert_eq!("", post.content());

    post.request_review();
    assert_eq!("", post.content());

    post.approve();
    assert_eq!("나는 오늘 점심으로 샐러드를 먹었다", post.content());
}</code></pre>
</Listing>
<p>우리는 사용자가 <code>Post::new</code>로 새로운 초안 블로그 포스트를 생성할 수 있게 하고자 합니다. 또한 블로그 포스트에 텍스트를 추가할 수 있게 하고 싶습니다. 만약 승인되기 전인 초안 상태에서 즉시 포스트의 내용을 가져오려고 시도한다면, 어떤 텍스트도 얻지 못해야 합니다. 설명을 돕기 위해 코드에 <code>assert_eq!</code>를 추가했습니다. 이에 대한 훌륭한 유닛 테스트는 초안 블로그 포스트의 <code>content</code> 메서드가 빈 문자열을 반환하는지 확인하는 것이겠지만, 이 예제에서는 테스트를 작성하지 않겠습니다.</p>
<p>다음으로, 포스트에 대한 리뷰 요청을 가능하게 하고 싶으며, 리뷰를 기다리는 동안에도 <code>content</code>가 빈 문자열을 반환하게 하고 싶습니다. 포스트가 승인을 받으면 게시되어야 하며, 이는 <code>content</code>가 호출될 때 포스트의 텍스트가 반환됨을 의미합니다.</p>
<p>우리가 이 크레이트에서 상호작용하는 유일한 타입이 <code>Post</code> 타입이라는 점에 주목하세요. 이 타입은 상태 패턴을 사용하며, 포스트가 가질 수 있는 세 가지 상태(초안, 리뷰 대기 중, 게시됨) 중 하나를 나타내는 상태 객체를 값으로 보유합니다. 한 상태에서 다른 상태로의 전환은 <code>Post</code> 타입 내부에서 관리됩니다. 상태는 라이브러리 사용자가 <code>Post</code> 인스턴스에 대해 호출하는 메서드에 응답하여 변경되지만, 사용자가 직접 상태 변경을 관리할 필요는 없습니다. 또한 사용자는 리뷰 전에 포스트를 게시하는 것과 같이 상태와 관련된 실수를 할 수 없습니다.</p>
<h3 id="post-정의-및-초안-상태의-새-인스턴스-생성하기"><a class="header" href="#post-정의-및-초안-상태의-새-인스턴스-생성하기"><code>Post</code> 정의 및 초안 상태의 새 인스턴스 생성하기</a></h3>
<p>라이브러리 구현을 시작해 봅시다! 우리는 내용을 담을 공개된 <code>Post</code> 구조체가 필요하다는 것을 알고 있으므로, 목록 18-12에 나타난 것처럼 구조체의 정의와 <code>Post</code> 인스턴스를 생성하는 연관된 공개 <code>new</code> 함수로 시작합니다. 또한 <code>Post</code>를 위한 모든 상태 객체가 가져야 할 동작을 정의하는 비공개 <code>State</code> 트레이트를 만들 것입니다.</p>
<p>그런 다음 <code>Post</code>는 상태 객체를 보유하기 위해 <code>state</code>라는 이름의 비공개 필드에 <code>Option&lt;T&gt;</code>로 감싸진 <code>Box&lt;dyn State&gt;</code> 트레이트 객체를 보유하게 됩니다. 왜 <code>Option&lt;T&gt;</code>가 필요한지는 잠시 후에 보게 될 것입니다.</p>
<Listing number="18-12" file-name="src/lib.rs" caption="Definition of a `Post` struct and a `new` function that creates a new `Post` instance, a `State` trait, and a `Draft` struct">
<pre><code class="language-rust noplayground">pub struct Post {
    state: Option&lt;Box&lt;dyn State&gt;&gt;,
    content: String,
}

impl Post {
    pub fn new() -&gt; Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}</code></pre>
</Listing>
<p><code>State</code> 트레이트는 서로 다른 포스트 상태들이 공유하는 동작을 정의합니다. 상태 객체들은 <code>Draft</code>, <code>PendingReview</code>, <code>Published</code>이며, 이들은 모두 <code>State</code> 트레이트를 구현할 것입니다. 현재로서는 이 트레이트에 메서드가 없으며, 포스트가 시작되어야 할 상태인 <code>Draft</code> 상태부터 정의하며 시작해 보겠습니다.</p>
<p>새로운 <code>Post</code>를 생성할 때, 우리는 <code>state</code> 필드를 <code>Box</code>를 담고 있는 <code>Some</code> 값으로 설정합니다. 이 <code>Box</code>는 <code>Draft</code> 구조체의 새로운 인스턴스를 가리킵니다. 이를 통해 <code>Post</code> 인스턴스를 생성할 때마다 항상 초안으로 시작함을 보장합니다. <code>Post</code>의 <code>state</code> 필드는 비공개이므로, 다른 상태로 <code>Post</code>를 생성할 방법이 없습니다! <code>Post::new</code> 함수에서 우리는 <code>content</code> 필드를 새롭고 비어 있는 <code>String</code>으로 설정합니다.</p>
<h3 id="포스트-내용의-텍스트-저장하기"><a class="header" href="#포스트-내용의-텍스트-저장하기">포스트 내용의 텍스트 저장하기</a></h3>
<p>우리는 목록 18-11에서 <code>add_text</code>라는 메서드를 호출하고 <code>&amp;str</code>을 전달하여 블로그 포스트의 텍스트 내용으로 추가되기를 원한다는 것을 보았습니다. 우리는 <code>content</code> 필드를 <code>pub</code>으로 노출하는 대신 메서드로 구현했는데, 이는 나중에 <code>content</code> 필드의 데이터가 읽히는 방식을 제어하는 메서드를 구현할 수 있도록 하기 위해서입니다. <code>add_text</code> 메서드는 매우 단순하므로, 목록 18-13의 구현을 <code>impl Post</code> 블록에 추가해 봅시다.</p>
<Listing number="18-13" file-name="src/lib.rs" caption="Implementing the `add_text` method to add text to a post’s `content`">
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --생략--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}</span></code></pre>
</Listing>
<p><code>add_text</code> 메서드는 호출 대상인 <code>Post</code> 인스턴스를 변경해야 하므로 <code>self</code>에 대한 가변 참조를 받습니다. 그런 다음 <code>content</code> 필드의 <code>String</code>에 대해 <code>push_str</code>을 호출하고 <code>text</code> 인수를 전달하여 저장된 내용에 추가합니다. 이 동작은 포스트의 현재 상태에 의존하지 않으므로 상태 패턴의 일부는 아닙니다. <code>add_text</code> 메서드는 <code>state</code> 필드와 전혀 상호작용하지 않지만, 우리가 지원하고자 하는 동작의 일부입니다.</p>
<h3 id="초안-포스트의-내용이-비어-있음을-보장하기"><a class="header" href="#초안-포스트의-내용이-비어-있음을-보장하기">초안 포스트의 내용이 비어 있음을 보장하기</a></h3>
<p><code>add_text</code>를 호출하여 포스트에 내용을 추가한 후에도, 목록 18-11의 7번 라인에 나타난 것처럼 포스트가 여전히 초안 상태라면 <code>content</code> 메서드가 빈 문자열 슬라이스를 반환하기를 원합니다. 지금은 이 요구사항을 충족하는 가장 간단한 방법으로 <code>content</code> 메서드를 구현해 봅시다. 즉, 항상 빈 문자열 슬라이스를 반환하는 것입니다. 나중에 포스트 상태를 변경하여 게시할 수 있는 기능을 구현하면 이를 수정할 것입니다. 현재까지 포스트는 초안 상태만 가질 수 있으므로, 포스트 내용은 항상 비어 있어야 합니다. 목록 18-14는 이 임시 구현을 보여줍니다.</p>
<Listing number="18-14" file-name="src/lib.rs" caption="Adding a placeholder implementation for the `content` method on `Post` that always returns an empty string slice">
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --생략--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        ""
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}</span></code></pre>
</Listing>
<p>이 <code>content</code> 메서드를 추가함으로써, 목록 18-11의 7번 라인까지의 모든 코드가 의도한 대로 작동합니다.</p>
<h3 id="포스트의-리뷰를-요청하면-상태가-변경된다"><a class="header" href="#포스트의-리뷰를-요청하면-상태가-변경된다">포스트의 리뷰를 요청하면 상태가 변경된다</a></h3>
<p>다음으로, 포스트의 리뷰를 요청하는 기능을 추가해야 하며, 이는 포스트의 상태를 <code>Draft</code>에서 <code>PendingReview</code>로 변경해야 합니다. 목록 18-15는 이 코드를 보여줍니다.</p>
<Listing number="18-15" file-name="src/lib.rs" caption="Implementing `request_review` methods on `Post` and the `State` trait">
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --생략--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        ""
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}</code></pre>
</Listing>
<p>우리는 <code>Post</code>에 <code>self</code>에 대한 가변 참조를 받는 공개 메서드 <code>request_review</code>를 추가합니다. 그런 다음 <code>Post</code>의 현재 상태에 대해 내부적인 <code>request_review</code> 메서드를 호출하며, 이 두 번째 <code>request_review</code> 메서드는 현재 상태를 소비하고 새로운 상태를 반환합니다.</p>
<p>우리는 <code>State</code> 트레이트에 <code>request_review</code> 메서드를 추가합니다. 이제 이 트레이트를 구현하는 모든 타입은 <code>request_review</code> 메서드를 구현해야 합니다. 메서드의 첫 번째 매개변수로 <code>self</code>, <code>&amp;self</code>, 또는 <code>&amp;mut self</code>를 사용하는 대신 <code>self: Box&lt;Self&gt;</code>를 사용했다는 점에 주목하세요. 이 문법은 해당 타입을 담고 있는 <code>Box</code>에 대해 호출될 때만 메서드가 유효함을 의미합니다. 이 문법은 <code>Box&lt;Self&gt;</code>의 소유권을 가져와서 이전 상태를 무효화함으로써, <code>Post</code>의 상태 값이 새로운 상태로 변환될 수 있게 합니다.</p>
<p>이전 상태를 소비하기 위해, <code>request_review</code> 메서드는 상태 값의 소유권을 가져와야 합니다. 여기서 <code>Post</code> 구조체의 <code>state</code> 필드에 있는 <code>Option</code>이 역할을 합니다. 우리는 <code>take</code> 메서드를 호출하여 <code>state</code> 필드에서 <code>Some</code> 값을 꺼내고 그 자리에 <code>None</code>을 남깁니다. 러스트는 구조체에 비어 있는 필드를 허용하지 않기 때문입니다. 이를 통해 우리는 <code>state</code> 값을 대여하는 대신 <code>Post</code> 밖으로 이동시킬 수 있습니다. 그런 다음 포스트의 <code>state</code> 값을 이 작업의 결과로 설정할 것입니다.</p>
<p>우리는 <code>state</code> 값의 소유권을 얻기 위해, <code>self.state = self.state.request_review();</code>와 같은 코드로 직접 설정하는 대신 일시적으로 <code>state</code>를 <code>None</code>으로 설정해야 합니다. 이는 우리가 새로운 상태로 변환한 후에 <code>Post</code>가 이전 <code>state</code> 값을 사용할 수 없도록 보장합니다.</p>
<p><code>Draft</code>에서의 <code>request_review</code> 메서드는 새로운 <code>PendingReview</code> 구조체의 박스형 인스턴스를 반환합니다. 이는 포스트가 리뷰를 기다리고 있는 상태를 나타냅니다. <code>PendingReview</code> 구조체 역시 <code>request_review</code> 메서드를 구현하지만, 어떤 변환도 수행하지 않습니다. 대신 자기 자신을 반환하는데, 이미 <code>PendingReview</code> 상태인 포스트에 대해 리뷰를 요청할 경우 계속 <code>PendingReview</code> 상태로 유지되어야 하기 때문입니다.</p>
<p>이제 상태 패턴의 장점들이 보이기 시작합니다. <code>Post</code>의 <code>request_review</code> 메서드는 <code>state</code> 값에 상관없이 동일합니다. 각 상태가 자신만의 규칙을 책임집니다.</p>
<p><code>Post</code>의 <code>content</code> 메서드는 그대로 두어 빈 문자열 슬라이스를 반환하게 합니다. 이제 우리는 <code>Draft</code> 상태뿐만 아니라 <code>PendingReview</code> 상태의 <code>Post</code>도 가질 수 있게 되었지만, <code>PendingReview</code> 상태에서도 동일한 동작을 원합니다. 이제 목록 18-11의 10번 라인까지 코드가 작동합니다!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="adding-the-approve-method-that-changes-the-behavior-of-content"></a></p>
<h3 id="content의-동작을-변경하기-위해-approve-추가하기"><a class="header" href="#content의-동작을-변경하기-위해-approve-추가하기"><code>content</code>의 동작을 변경하기 위해 <code>approve</code> 추가하기</a></h3>
<p><code>approve</code> 메서드는 <code>request_review</code> 메서드와 유사할 것입니다. 목록 18-16에 나타난 것처럼, 현재 상태가 승인되었을 때 가져야 할 값으로 <code>state</code>를 설정합니다.</p>
<Listing number="18-16" file-name="src/lib.rs" caption="Implementing the `approve` method on `Post` and the `State` trait">
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --생략--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        ""
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn approve(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    // --생략--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
    // --생략--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }

    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}</code></pre>
</Listing>
<p>우리는 <code>State</code> 트레이트에 <code>approve</code> 메서드를 추가하고, <code>State</code>를 구현하는 새로운 구조체인 <code>Published</code> 상태를 추가합니다.</p>
<p><code>PendingReview</code>에서의 <code>request_review</code> 작동 방식과 유사하게, 만약 <code>Draft</code>에서 <code>approve</code> 메서드를 호출하면 <code>approve</code>가 <code>self</code>를 반환하므로 아무런 효과가 없습니다. <code>PendingReview</code>에서 <code>approve</code>를 호출하면 <code>Published</code> 구조체의 새로운 박스형 인스턴스를 반환합니다. <code>Published</code> 구조체는 <code>State</code> 트레이트를 구현하며, <code>request_review</code> 메서드와 <code>approve</code> 메서드 모두에서 자기 자신을 반환합니다. 이 경우 포스트가 <code>Published</code> 상태로 유지되어야 하기 때문입니다.</p>
<p>이제 <code>Post</code>의 <code>content</code> 메서드를 업데이트해야 합니다. 우리는 <code>content</code>로부터 반환되는 값이 <code>Post</code>의 현재 상태에 따라 달라지기를 원하므로, 목록 18-17에 나타난 것처럼 <code>Post</code>가 자신의 <code>state</code>에 정의된 <code>content</code> 메서드에 위임하도록 할 것입니다.</p>
<Listing number="18-17" file-name="src/lib.rs" caption="Updating the `content` method on `Post` to delegate to a `content` method on `State`">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --생략--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        self.state.as_ref().unwrap().content(self)
    }
    // --생략--
<span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">trait State {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Published {}
</span><span class="boring">
</span><span class="boring">impl State for Published {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>모든 규칙을 <code>State</code>를 구현하는 구조체들 내부에 유지하는 것이 목표이므로, <code>state</code>에 있는 값에 대해 <code>content</code> 메서드를 호출하고 포스트 인스턴스(즉, <code>self</code>)를 인수로 전달합니다. 그런 다음 <code>state</code> 값의 <code>content</code> 메서드를 사용하여 반환된 값을 반환합니다.</p>
<p>우리는 값의 소유권보다는 <code>Option</code> 내부의 값에 대한 참조를 원하므로 <code>Option</code>에 대해 <code>as_ref</code> 메서드를 호출합니다. <code>state</code>가 <code>Option&lt;Box&lt;dyn State&gt;&gt;</code>이므로, <code>as_ref</code>를 호출하면 <code>Option&lt;&amp;Box&lt;dyn State&gt;&gt;</code>가 반환됩니다. 만약 <code>as_ref</code>를 호출하지 않는다면, 함수 매개변수인 대여된 <code>&amp;self</code>로부터 <code>state</code>를 밖으로 이동시킬 수 없기 때문에 에러가 발생할 것입니다.</p>
<p>그런 다음 <code>unwrap</code> 메서드를 호출합니다. 우리는 <code>Post</code>의 메서드들이 완료될 때 <code>state</code>가 항상 <code>Some</code> 값을 포함하도록 보장한다는 것을 알고 있으므로, 이 호출이 결코 패닉을 일으키지 않을 것임을 압니다. 이는 9장의 <a href="ch09-03-to-panic-or-not-to-panic.html#cases-in-which-you-have-more-information-than-the-compiler">“컴파일러보다 여러분이 더 많은 정보를 가지고 있는 경우”</a><!-- ignore --> 섹션에서 이야기했던 사례 중 하나로, 컴파일러는 이해하지 못하더라도 우리는 <code>None</code> 값이 결코 불가능함을 알고 있는 경우입니다.</p>
<p>이 시점에서 <code>&amp;Box&lt;dyn State&gt;</code>에 대해 <code>content</code>를 호출하면, <code>&amp;</code>와 <code>Box</code>에 역참조 강제(deref coercion)가 적용되어 결국 <code>State</code> 트레이트를 구현하는 타입에 대해 <code>content</code> 메서드가 호출됩니다. 이는 <code>State</code> 트레이트 정의에 <code>content</code>를 추가해야 함을 의미하며, 목록 18-18에 나타난 것처럼 우리가 어떤 상태에 있는지에 따라 어떤 내용을 반환할지에 대한 로직을 그곳에 둘 것입니다.</p>
<Listing number="18-18" file-name="src/lib.rs" caption="Adding the `content` method to the `State` trait">
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        self.state.as_ref().unwrap().content(self)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>trait State {
    // --생략--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        ""
    }
}

// --생략--
<span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Published {}

impl State for Published {
    // --생략--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &amp;post.content
    }
}</code></pre>
</Listing>
<p>우리는 빈 문자열 슬라이스를 반환하는 <code>content</code> 메서드의 기본 구현을 추가합니다. 이는 <code>Draft</code>와 <code>PendingReview</code> 구조체에서 <code>content</code>를 구현할 필요가 없음을 의미합니다. <code>Published</code> 구조체는 <code>content</code> 메서드를 오버라이드하여 <code>post.content</code>에 있는 값을 반환할 것입니다.</p>
<p>10장에서 논의했던 것처럼, 이 메서드에는 라이프타임 어노테이션이 필요하다는 점에 유의하세요. 우리는 <code>post</code>에 대한 참조를 인수로 받고 해당 <code>post</code>의 일부에 대한 참조를 반환하므로, 반환되는 참조의 라이프타임은 <code>post</code> 인수의 라이프타임과 관련이 있습니다.</p>
<p>이제 다 되었습니다—목록 18-11의 모든 코드가 정상 작동합니다! 우리는 블로그 포스트 워크플로우의 규칙들을 사용하여 상태 패턴을 구현했습니다. 규칙과 관련된 로직은 <code>Post</code> 전체에 흩어져 있는 대신 상태 객체들 내부에 위치하게 됩니다.</p>
<blockquote>
<h4 id="왜-열거형은-사용하지-않았나요"><a class="header" href="#왜-열거형은-사용하지-않았나요">왜 열거형은 사용하지 않았나요?</a></h4>
<p>가능한 포스트 상태들을 변형(variant)으로 가지는 <code>enum</code>을 왜 사용하지 않았는지 궁금할 수 있습니다. 그것도 분명 가능한 해결책이니, 직접 시도해 보고 결과물을 비교하여 어떤 방식이 더 마음에 드는지 확인해 보세요! 열거형을 사용할 때의 한 가지 단점은, 열거형 값을 확인하는 모든 곳에서 모든 가능한 변형을 처리하기 위해 <code>match</code> 표현식이나 그와 유사한 구문이 필요하다는 점입니다. 이는 이번 트레이트 객체 해결책보다 더 반복적인 작업이 될 수 있습니다.</p>
</blockquote>
<h3 id="상태-패턴의-트레이드오프"><a class="header" href="#상태-패턴의-트레이드오프">상태 패턴의 트레이드오프</a></h3>
<p>우리는 러스트가 포스트가 각 상태에서 가져야 할 서로 다른 동작들을 캡슐화하기 위해 객체 지향 상태 패턴을 구현할 수 있음을 보여주었습니다. <code>Post</code>의 메서드들은 다양한 동작들에 대해 아무것도 알지 못합니다. 우리가 코드를 구성한 방식에 따르면, 게시된 포스트가 어떻게 동작하는지 알기 위해 오직 한 곳만 확인하면 됩니다. 바로 <code>Published</code> 구조체에 구현된 <code>State</code> 트레이트입니다.</p>
<p>상태 패턴을 사용하지 않는 대안적인 구현을 만든다면, 대신 <code>Post</code>의 메서드들이나 심지어 <code>main</code> 코드에서 포스트의 상태를 확인하고 그에 따라 동작을 변경하는 <code>match</code> 표현식들을 사용했을 것입니다. 이는 포스트가 게시됨 상태일 때의 모든 영향을 이해하기 위해 여러 곳을 찾아봐야 함을 의미합니다! 상태를 더 추가할수록 이런 부담은 늘어날 뿐입니다. 각 <code>match</code> 표현식마다 새로운 가지(arm)를 추가해야 할 테니까요.</p>
<p>상태 패턴을 사용하면, <code>Post</code> 메서드들과 <code>Post</code>를 사용하는 곳에서 <code>match</code> 표현식이 필요하지 않으며, 새로운 상태를 추가하려면 그저 새로운 구조체를 추가하고 그 구조체에 트레이트 메서드들을 구현하기만 하면 됩니다.</p>
<p>상태 패턴을 사용한 구현은 기능을 더 추가하기 위해 확장하기 쉽습니다. 상태 패턴을 사용하는 코드의 유지보수 편의성을 확인해 보려면, 다음의 제안 사항들을 몇 가지 시도해 보세요.</p>
<ul>
<li>포스트의 상태를 <code>PendingReview</code>에서 다시 <code>Draft</code>로 되돌리는 <code>reject</code> 메서드를 추가해 보세요.</li>
<li>상태가 <code>Published</code>로 변경되기 전에 <code>approve</code>를 두 번 호출하도록 요구해 보세요.</li>
<li>포스트가 <code>Draft</code> 상태일 때만 사용자가 텍스트 내용을 추가할 수 있도록 허용해 보세요. 힌트: 상태 객체가 내용의 변경 가능 여부를 책임지게 하되, <code>Post</code>를 수정하는 책임은 가지지 않도록 하세요.</li>
</ul>
<p>상태 패턴의 한 가지 단점은, 상태들이 상태 간의 전환을 구현하기 때문에 일부 상태들이 서로 결합된다는 점입니다. 만약 <code>PendingReview</code>와 <code>Published</code> 사이에 <code>Scheduled</code>와 같은 다른 상태를 추가한다면, <code>Scheduled</code>로 전환되도록 <code>PendingReview</code>의 코드를 변경해야 합니다. 새로운 상태가 추가될 때 <code>PendingReview</code>를 변경할 필요가 없다면 작업이 더 줄어들겠지만, 이는 다른 디자인 패턴으로의 전환을 의미할 것입니다.</p>
<p>또 다른 단점은 일부 로직이 중복된다는 것입니다. 중복을 제거하기 위해 <code>State</code> 트레이트의 <code>request_review</code>와 <code>approve</code> 메서드에 <code>self</code>를 반환하는 기본 구현을 만들려고 시도할 수도 있습니다. 하지만 이는 dyn 호환(dyn compatible)되지 않을 것입니다. 트레이트는 구체적인 <code>self</code>가 정확히 무엇일지 알 수 없기 때문입니다. 우리는 <code>State</code>를 트레이트 객체로 사용하기를 원하므로, 그 메서드들이 dyn 호환되어야 합니다.</p>
<p>다른 중복으로는 <code>Post</code>에 구현된 <code>request_review</code>와 <code>approve</code> 메서드의 유사한 모습이 있습니다. 두 메서드 모두 <code>Option</code>의 <code>state</code> 필드에 있는 값의 동일한 메서드 구현에 위임하고, 그 결과로 <code>state</code> 필드의 새로운 값을 설정합니다. 만약 <code>Post</code>에 이런 패턴을 따르는 메서드가 아주 많다면, 반복을 줄이기 위해 매크로 정의를 고려해 볼 수 있습니다 (20장의 <a href="ch20-05-macros.html#macros">“매크로”</a><!-- ignore --> 섹션 참조).</p>
<p>상태 패턴을 객체 지향 언어에서 정의된 그대로 구현함으로써, 우리는 러스트의 강점을 충분히 활용하지 못하고 있습니다. 이제 유효하지 않은 상태와 상태 전환을 컴파일 타임 에러로 만들 수 있도록 <code>blog</code> 크레이트에 가할 수 있는 몇 가지 변경 사항들을 살펴봅시다.</p>
<h4 id="상태와-동작을-타입으로-인코딩하기"><a class="header" href="#상태와-동작을-타입으로-인코딩하기">상태와 동작을 타입으로 인코딩하기</a></h4>
<p>다른 트레이드오프 세트를 얻기 위해 상태 패턴을 재구성하는 방법을 보여드리겠습니다. 상태와 상태 전환을 완전히 캡슐화하여 외부 코드에서 알 수 없게 만드는 대신, 상태를 서로 다른 타입으로 인코딩할 것입니다. 결과적으로 러스트의 타입 체크 시스템은 게시된 포스트만 허용되는 곳에 초안 포스트를 사용하려는 시도를 컴파일 타임 에러를 통해 방지해 줄 것입니다.</p>
<p>목록 18-11에 있는 <code>main</code>의 첫 번째 부분을 살펴봅시다.</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore"><span class="boring">use blog::Post;
</span><span class="boring">
</span>fn main() {
    let mut post = Post::new();

    post.add_text("나는 오늘 점심으로 샐러드를 먹었다");
    assert_eq!("", post.content());
<span class="boring">
</span><span class="boring">    post.request_review();
</span><span class="boring">    assert_eq!("", post.content());
</span><span class="boring">
</span><span class="boring">    post.approve();
</span><span class="boring">    assert_eq!("나는 오늘 점심으로 샐러드를 먹었다", post.content());
</span>}</code></pre>
</Listing>
<p>우리는 여전히 <code>Post::new</code>를 사용하여 초안 상태의 새로운 포스트를 생성하고 포스트의 내용에 텍스트를 추가할 수 있게 합니다. 하지만 초안 포스트에 빈 문자열을 반환하는 <code>content</code> 메서드를 두는 대신, 아예 <code>content</code> 메서드가 없도록 만들 것입니다. 그렇게 하면 초안 포스트의 내용을 가져오려고 시도할 때 해당 메서드가 존재하지 않는다는 컴파일 타임 에러를 받게 됩니다. 결과적으로, 해당 코드는 컴파일조차 되지 않을 것이기 때문에 우리가 실수로 프로덕션에서 초안 포스트의 내용을 표시하는 것이 불가능해집니다. 목록 18-19는 <code>Post</code> 구조체와 <code>DraftPost</code> 구조체의 정의, 그리고 각각의 메서드들을 보여줍니다.</p>
<Listing number="18-19" file-name="src/lib.rs" caption="A `Post` with a `content` method and `DraftPost` without a `content` method">
<pre><code class="language-rust noplayground">pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -&gt; DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&amp;self) -&gt; &amp;str {
        &amp;self.content
    }
}

impl DraftPost {
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}</code></pre>
</Listing>
<p><code>Post</code>와 <code>DraftPost</code> 구조체 모두 블로그 포스트 텍스트를 저장하는 비공개 <code>content</code> 필드를 가집니다. 상태 인코딩을 구조체 타입으로 옮겼기 때문에 구조체들은 더 이상 <code>state</code> 필드를 가지지 않습니다. <code>Post</code> 구조체는 게시된 포스트를 나타내며, <code>content</code>를 반환하는 <code>content</code> 메서드를 가집니다.</p>
<p>우리는 여전히 <code>Post::new</code> 함수를 가지고 있지만, <code>Post</code> 인스턴스 대신 <code>DraftPost</code> 인스턴스를 반환합니다. <code>content</code>가 비공개이고 <code>Post</code>를 반환하는 함수가 없기 때문에, 현재로서는 <code>Post</code> 인스턴스를 생성하는 것이 불가능합니다.</p>
<p><code>DraftPost</code> 구조체는 <code>add_text</code> 메서드를 가지고 있어서 이전처럼 <code>content</code>에 텍스트를 추가할 수 있지만, <code>DraftPost</code>에는 <code>content</code> 메서드가 정의되어 있지 않다는 점에 주목하세요! 이제 프로그램은 모든 포스트가 초안으로 시작함을 보장하며, 초안 포스트는 표시할 내용을 제공하지 않습니다. 이러한 제약 사항을 우회하려는 모든 시도는 컴파일 타임 에러로 이어질 것입니다.</p>
<h4 id="상태-전환을-서로-다른-타입-간의-변환으로-구현하기"><a class="header" href="#상태-전환을-서로-다른-타입-간의-변환으로-구현하기">상태 전환을 서로 다른 타입 간의 변환으로 구현하기</a></h4>
<p>So how do we get a published post? We want to enforce the rule that a draft post has to be reviewed and approved before it can be published. A post in the pending review state should still not display any content. Let’s implement these constraints by adding another struct, <code>PendingReviewPost</code>, defining the <code>request_review</code> method on <code>DraftPost</code> to return a <code>PendingReviewPost</code>, and defining an <code>approve</code> method on <code>PendingReviewPost</code> to return a <code>Post</code>, as shown in Listing 18-20:</p>
<Listing number="18-20" file-name="src/lib.rs" caption="A `PendingReviewPost` that gets created by calling `request_review` on `DraftPost` and an `approve` method that turns a `PendingReviewPost` into a published `Post`">
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct DraftPost {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; DraftPost {
</span><span class="boring">        DraftPost {
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.content
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl DraftPost {
    // --생략--
<span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(self) -&gt; PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -&gt; Post {
        Post {
            content: self.content,
        }
    }
}</code></pre>
</Listing>
<p><code>request_review</code>와 <code>approve</code> 메서드는 <code>self</code>의 소유권을 가져가므로, <code>DraftPost</code>와 <code>PendingReviewPost</code> 인스턴스를 소비하고 이를 각각 <code>PendingReviewPost</code>와 게시된 <code>Post</code>로 변환합니다. 이런 식으로, 우리는 <code>request_review</code>를 호출한 후에 남아있는 <code>DraftPost</code> 인스턴스를 가지지 않게 됩니다. <code>PendingReviewPost</code> 구조체에는 <code>content</code> 메서드가 정의되어 있지 않으므로, 해당 내용을 읽으려는 시도는 <code>DraftPost</code>와 마찬가지로 컴파일 타임 에러를 발생시킵니다. <code>content</code> 메서드가 정의된 게시된 <code>Post</code> 인스턴스를 얻는 유일한 방법은 <code>PendingReviewPost</code>에서 <code>approve</code> 메서드를 호출하는 것이고, <code>PendingReviewPost</code>를 얻는 유일한 방법은 <code>DraftPost</code>에서 <code>request_review</code> 메서드를 호출하는 것이기 때문에, 우리는 이제 블로그 포스트 워크플로우를 타입 시스템에 인코딩했습니다.</p>
<p>하지만 <code>main</code>에도 몇 가지 작은 변경을 해야 합니다. <code>request_review</code>와 <code>approve</code> 메서드가 호출된 구조체를 직접 수정하는 대신 새로운 인스턴스를 반환하므로, 반환된 인스턴스를 저장하기 위해 더 많은 <code>let post =</code> 섀도잉(shadowing) 할당을 추가해야 합니다. 또한 초안 및 리뷰 대기 중인 포스트의 내용이 빈 문자열이라는 어설션(assertion)을 가질 수 없으며, 가질 필요도 없습니다. 해당 상태의 포스트 내용을 사용하려고 시도하는 코드는 이제 컴파일조차 되지 않기 때문입니다. 업데이트된 <code>main</code> 코드가 목록 18-21에 나와 있습니다.</p>
<Listing number="18-21" file-name="src/main.rs" caption="Modifications to `main` to use the new implementation of the blog post workflow">
<pre><code class="language-rust ignore">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("나는 오늘 점심으로 샐러드를 먹었다");

    let post = post.request_review();

    let post = post.approve();

    assert_eq!("나는 오늘 점심으로 샐러드를 먹었다", post.content());
}</code></pre>
</Listing>
<p><code>post</code>를 재할당하기 위해 <code>main</code>에 가한 변경 사항들은, 이 구현이 더 이상 객체 지향 상태 패턴을 정확히 따르지는 않음을 의미합니다. 상태 간의 전환이 더 이상 <code>Post</code> 구현 내부에 완전히 캡슐화되어 있지 않기 때문입니다. 하지만 타입 시스템과 컴파일 타임에 수행되는 타입 체크 덕분에 이제 유효하지 않은 상태를 가지는 것이 아예 불가능해졌다는 이득을 얻었습니다! 이는 게시되지 않은 포스트의 내용이 표시되는 것과 같은 특정 버그들이 실제 프로덕션에 나가기 전에 발견될 것임을 보장합니다.</p>
<p>목록 18-21 이후의 <code>blog</code> 크레이트에 대해 이 섹션의 시작 부분에서 제안했던 과제들을 시도해 보면서, 이 버전의 코드 설계에 대해 어떻게 생각하시는지 확인해 보세요. 일부 과제들은 이 설계에서 이미 완료되었을 수도 있습니다.</p>
<p>우리는 러스트가 객체 지향 디자인 패턴을 구현할 수 있을 뿐만 아니라, 상태를 타입 시스템에 인코딩하는 것과 같은 다른 패턴들도 러스트에서 가능함을 보았습니다. 이러한 패턴들은 각기 다른 트레이드오프를 가집니다. 객체 지향 패턴에 매우 익숙할지라도, 러스트의 기능을 활용하기 위해 문제를 다시 생각해 보는 것은 컴파일 타임에 일부 버그를 방지하는 것과 같은 이점을 제공할 수 있습니다. 객체 지향 언어에는 없는 소유권과 같은 특정 기능들 때문에, 객체 지향 패턴이 러스트에서 항상 최선의 해결책인 것은 아닙니다.</p>
<h2 id="요약"><a class="header" href="#요약">요약</a></h2>
<p>이 장을 읽은 후 러스트가 객체 지향 언어라고 생각하든 그렇지 않든, 이제 트레이트 객체를 사용하여 러스트에서 일부 객체 지향 기능을 사용할 수 있음을 알게 되었습니다. 동적 디스패치는 약간의 런타임 성능을 희생하는 대신 코드에 유연성을 제공할 수 있습니다. 여러분은 이 유연성을 사용하여 코드의 유지보수성에 도움이 되는 객체 지향 패턴을 구현할 수 있습니다. 또한 러스트에는 객체 지향 언어에는 없는 소유권과 같은 다른 기능들도 있습니다. 객체 지향 패턴이 항상 러스트의 강점을 활용하는 최선의 방법은 아니겠지만, 선택 가능한 옵션 중 하나입니다.</p>
<p>다음으로, 많은 유연성을 가능하게 하는 러스트의 또 다른 기능인 패턴에 대해 알아보겠습니다. 책 전체에 걸쳐 짧게 살펴보긴 했지만, 아직 그 전체 기능을 보지는 못했습니다. 자, 시작해 봅시다!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch18-02-trait-objects.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch19-00-patterns.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch18-02-trait-objects.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch19-00-patterns.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
