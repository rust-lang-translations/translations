<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Rust Programming Language</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/print.md`;
                    } else {
                        canonical_href = `${base}/${lang}/print.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="러스트-프로그래밍-언어"><a class="header" href="#러스트-프로그래밍-언어">러스트 프로그래밍 언어</a></h1>
<p><em>Steve Klabnik, Carol Nichols, Chris Krycho 저, 러스트 커뮤니티 기여</em></p>
<p>이 텍스트 버전은 Rust 1.82.0 (2024-10-17 출시) 이상을 사용한다고 가정합니다. Rust를 설치하거나 업데이트하려면 <a href="ch01-01-installation.html">1장의 "설치" 섹션</a><!-- ignore -->을 참조하세요.</p>
<p>HTML 형식은 온라인에서 <a href="https://doc.rust-lang.org/stable/book/">https://doc.rust-lang.org/stable/book/</a>에서 이용할 수 있으며, <code>rustup</code>으로 설치한 Rust와 함께 오프라인에서도 이용할 수 있습니다. <code>rustup doc --book</code>을 실행하여 열 수 있습니다.</p>
<p>여러 커뮤니티 <a href="appendix-06-translation.html">번역본</a>도 이용할 수 있습니다.</p>
<p>이 텍스트는 <a href="https://nostarch.com/rust-programming-language-2nd-edition">No Starch Press에서 종이책과 전자책 형식</a>으로 이용할 수 있습니다.</p>
<blockquote>
<p><strong>🚨 더 상호작용적인 학습 경험을 원하시나요? 퀴즈, 하이라이팅, 시각화 등을 포함한 다른 버전의 Rust Book을 시도해보세요</strong>: <a href="https://rust-book.cs.brown.edu">https://rust-book.cs.brown.edu</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="서문"><a class="header" href="#서문">서문</a></h1>
<p>항상 명확하지는 않았지만, 러스트 프로그래밍 언어는 근본적으로 _역량 강화_에 관한 것입니다: 지금 어떤 종류의 코드를 작성하고 있든, 러스트는 여러분이 더 멀리 나아가고, 이전보다 더 다양한 영역에서 자신감을 가지고 프로그래밍할 수 있도록 힘을 실어줍니다.</p>
<p>예를 들어, 메모리 관리, 데이터 표현, 동시성의 저수준 세부사항을 다루는 "시스템 수준" 작업을 생각해보세요. 전통적으로 이 프로그래밍 영역은 신비로운 것으로 여겨져, 악명 높은 함정들을 피하는 방법을 배우는 데 필요한 수년을 투자한 선택받은 소수만이 접근할 수 있다고 여겨졌습니다. 그리고 이를 실천하는 사람들조차도 자신의 코드가 익스플로잇, 크래시, 또는 손상에 노출되지 않도록 조심스럽게 작업합니다.</p>
<p>러스트는 기존의 함정들을 제거하고 여러분을 도와줄 친근하고 세련된 도구 세트를 제공함으로써 이러한 장벽을 허뭅니다. 더 낮은 수준의 제어로 "내려가야" 하는 프로그래머들은 러스트를 사용하여 관례적인 크래시나 보안 홀의 위험을 감수하지 않고도, 그리고 변덕스러운 툴체인의 세부사항을 배울 필요 없이도 그렇게 할 수 있습니다. 더 나아가, 이 언어는 속도와 메모리 사용량 측면에서 효율적인 신뢰할 수 있는 코드로 자연스럽게 안내하도록 설계되었습니다.</p>
<p>이미 저수준 코드로 작업하고 프로그래머들은 러스트를 사용하여 자신의 야망을 높일 수 있습니다. 예를 들어, 러스트에서 병렬성을 도입하는 것은 상대적으로 위험이 낮은 작업입니다: 컴파일러가 고전적인 실수들을 잡아줄 것입니다. 그리고 여러분은 실수로 크래시나 취약점을 도입하지 않을 것이라는 확신을 가지고 코드에서 더 공격적인 최적화를 다룰 수 있습니다.</p>
<p>하지만 러스트는 저수준 시스템 프로그래밍에만 국한되지 않습니다. CLI 앱, 웹 서버, 그리고 다른 많은 종류의 코드를 작성하기에 충분히 표현력이 풍부하고 인체공학적입니다 — 책의 뒷부분에서 둘 다의 간단한 예제를 찾을 수 있을 것입니다. 러스트로 작업하면 한 영역에서 다른 영역으로 전이되는 기술을 구축할 수 있습니다; 웹 앱을 작성하여 러스트를 배운 다음, 동일한 기술을 적용하여 라즈베리 파이를 대상으로 할 수 있습니다.</p>
<p>이 책은 사용자들에게 힘을 실어주는 러스트의 잠재력을 완전히 받아들입니다. 이것은 러스트에 대한 지식뿐만 아니라 일반적으로 프로그래머로서의 여러분의 영향력과 자신감을 향상시키는 데 도움을 주기 위한 친근하고 접근하기 쉬운 텍스트입니다. 그러니 뛰어들어 배울 준비를 하세요—그리고 러스트 커뮤니티에 오신 것을 환영합니다!</p>
<p>— Nicholas Matsakis와 Aaron Turon</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="소개"><a class="header" href="#소개">소개</a></h1>
<blockquote>
<p>참고: 이 책의 에디션은 <a href="https://nostarch.com/">No Starch Press</a>에서 인쇄본과 전자책 형식으로 제공되는 <a href="https://nostarch.com/rust-programming-language-2nd-edition">The Rust Programming Language</a>과 동일합니다.</p>
</blockquote>
<p>_러스트 프로그래밍 언어_에 오신 것을 환영합니다. 러스트에 대한 입문서입니다. 러스트 프로그래밍 언어는 더 빠르고 더 신뢰할 수 있는 소프트웨어를 작성하는 데 도움을 줍니다. 고수준 인체공학과 저수준 제어는 프로그래밍 언어 설계에서 종종 상충됩니다. 러스트는 그 갈등에 도전합니다. 강력한 기술적 역량과 훌륭한 개발자 경험의 균형을 통해, 러스트는 전통적으로 그러한 제어와 관련된 모든 번거로움 없이 저수준 세부사항(예: 메모리 사용량)을 제어할 수 있는 옵션을 제공합니다.</p>
<h2 id="러스트는-누구를-위한-것인가"><a class="header" href="#러스트는-누구를-위한-것인가">러스트는 누구를 위한 것인가</a></h2>
<p>러스트는 다양한 이유로 많은 사람들에게 이상적입니다. 가장 중요한 몇 가지 그룹을 살펴보겠습니다.</p>
<h3 id="개발자-팀"><a class="header" href="#개발자-팀">개발자 팀</a></h3>
<p>러스트는 다양한 수준의 시스템 프로그래밍 지식을 가진 대규모 개발자 팀 간의 협업을 위한 생산적인 도구임이 입증되고 있습니다. 저수준 코드는 다양한 미묘한 버그에 취약하며, 대부분의 다른 언어에서는 광범위한 테스트와 경험 있는 개발자의 신중한 코드 리뷰를 통해서만 잡을 수 있습니다. 러스트에서는 컴파일러가 동시성 버그를 포함하여 이러한 파악하기 어려운 버그가 있는 코드의 컴파일을 거부함으로써 문지기 역할을 합니다. 컴파일러와 함께 작업함으로써, 팀은 버그를 쫓아다니는 대신 프로그램의 로직에 집중하는 데 시간을 보낼 수 있습니다.</p>
<p>러스트는 또한 현대적인 개발자 도구를 시스템 프로그래밍 세계에 가져옵니다:</p>
<ul>
<li>포함된 의존성 관리자이자 빌드 도구인 Cargo는 러스트 생태계 전반에 걸쳐 의존성을 추가하고, 컴파일하고, 관리하는 것을 고통 없고 일관되게 만듭니다.</li>
<li>Rustfmt 포맷팅 도구는 개발자들 간에 일관된 코딩 스타일을 보장합니다.</li>
<li>rust-analyzer는 코드 완성과 인라인 에러 메시지를 위한 통합 개발 환경(IDE) 통합을 지원합니다.</li>
</ul>
<p>러스트 생태계의 이러한 도구들과 다른 도구들을 사용함으로써, 개발자들은 시스템 수준 코드를 작성하면서도 생산적일 수 있습니다.</p>
<h3 id="학생들"><a class="header" href="#학생들">학생들</a></h3>
<p>러스트는 학생들과 시스템 개념에 대해 배우는 데 관심이 있는 사람들을 위한 것입니다. 러스트를 사용하여 많은 사람들이 운영 체제 개발과 같은 주제에 대해 배웠습니다. 커뮤니티는 매우 환영하며 학생들의 질문에 기꺼이 답변합니다. 이 책과 같은 노력을 통해, 러스트 팀은 시스템 개념을 더 많은 사람들에게, 특히 프로그래밍을 처음 접하는 사람들에게 더 접근하기 쉽게 만들고자 합니다.</p>
<h3 id="기업들"><a class="header" href="#기업들">기업들</a></h3>
<p>크고 작은 수백 개의 기업들이 명령줄 도구, 웹 서비스, DevOps 도구, 임베디드 장치, 오디오 및 비디오 분석과 트랜스코딩, 암호화폐, 생물정보학, 검색 엔진, 사물 인터넷 애플리케이션, 머신 러닝, 그리고 Firefox 웹 브라우저의 주요 부분까지 포함하여 다양한 작업을 위해 프로덕션에서 러스트를 사용합니다.</p>
<h3 id="오픈-소스-개발자들"><a class="header" href="#오픈-소스-개발자들">오픈 소스 개발자들</a></h3>
<p>러스트는 러스트 프로그래밍 언어, 커뮤니티, 개발자 도구, 라이브러리를 구축하고자 하는 사람들을 위한 것입니다. 여러분이 러스트 언어에 기여해주시면 좋겠습니다.</p>
<h3 id="속도와-안정성을-중시하는-사람들"><a class="header" href="#속도와-안정성을-중시하는-사람들">속도와 안정성을 중시하는 사람들</a></h3>
<p>러스트는 언어에서 속도와 안정성을 갈망하는 사람들을 위한 것입니다. 속도란 러스트 코드가 얼마나 빠르게 실행되는지와 러스트가 프로그램을 작성할 수 있게 해주는 속도를 모두 의미합니다. 러스트 컴파일러의 검사는 기능 추가와 리팩터링을 통해 안정성을 보장합니다. 이는 이러한 검사가 없는 언어의 취약한 레거시 코드와 대조적이며, 개발자들은 종종 이를 수정하기를 두려워합니다. 제로 코스트 추상화—수동으로 작성한 코드만큼 빠른 저수준 코드로 컴파일되는 고수준 기능—를 추구함으로써, 러스트는 안전한 코드가 빠른 코드이기도 하도록 노력합니다.</p>
<p>러스트 언어는 다른 많은 사용자들도 지원하기를 희망합니다. 여기서 언급된 것들은 단지 가장 큰 이해관계자들 중 일부일 뿐입니다. 전반적으로, 러스트의 가장 큰 야망은 안전성 <em>그리고</em> 생산성, 속도 <em>그리고</em> 인체공학을 제공함으로써 프로그래머들이 수십 년 동안 받아들여온 트레이드오프를 제거하는 것입니다. 러스트를 시도해보고 그 선택이 여러분에게 맞는지 확인해보세요.</p>
<h2 id="이-책은-누구를-위한-것인가"><a class="header" href="#이-책은-누구를-위한-것인가">이 책은 누구를 위한 것인가</a></h2>
<p>이 책은 여러분이 다른 프로그래밍 언어로 코드를 작성해본 경험이 있다고 가정하지만 어떤 언어인지에 대해서는 가정하지 않습니다. 우리는 다양한 프로그래밍 배경을 가진 사람들이 폭넓게 접근할 수 있도록 자료를 만들려고 노력했습니다. 프로그래밍이 <em>무엇인지</em> 또는 그것에 대해 어떻게 생각해야 하는지에 대해 많은 시간을 할애하지 않습니다. 프로그래밍을 완전히 처음 접한다면, 프로그래밍에 대한 입문을 구체적으로 제공하는 책을 읽는 것이 더 도움이 될 것입니다.</p>
<h2 id="이-책을-사용하는-방법"><a class="header" href="#이-책을-사용하는-방법">이 책을 사용하는 방법</a></h2>
<p>일반적으로, 이 책은 여러분이 앞에서부터 뒤로 순서대로 읽는다고 가정합니다. 후반 장들은 앞선 장들의 개념을 기반으로 하며, 앞선 장들은 특정 주제에 대한 세부사항을 깊이 다루지 않을 수 있지만 후반 장에서 그 주제를 다시 다룰 것입니다.</p>
<p>이 책에서는 두 가지 종류의 장을 찾을 수 있습니다: 개념 장과 프로젝트 장입니다. 개념 장에서는 러스트의 한 측면에 대해 배우게 됩니다. 프로젝트 장에서는 지금까지 배운 것을 적용하여 함께 작은 프로그램을 만들어볼 것입니다. 2장, 12장, 21장이 프로젝트 장이고, 나머지는 개념 장입니다.</p>
<p>1장은 러스트를 설치하는 방법, "Hello, world!" 프로그램을 작성하는 방법, 그리고 러스트의 패키지 관리자이자 빌드 도구인 Cargo를 사용하는 방법을 설명합니다. 2장은 러스트로 프로그램을 작성하는 실습 입문으로, 숫자 맞추기 게임을 만들어봅니다. 여기서는 개념을 높은 수준에서 다루며, 후반 장에서 추가적인 세부사항을 제공할 것입니다. 바로 실습을 해보고 싶다면, 2장이 그 장소입니다. 3장은 다른 프로그래밍 언어와 유사한 러스트 기능들을 다루고, 4장에서는 러스트의 소유권 시스템에 대해 배우게 됩니다. 다음으로 넘어가기 전에 모든 세부사항을 배우는 것을 선호하는 특히 꼼꼼한 학습자라면, 2장을 건너뛰고 바로 3장으로 가서, 배운 세부사항을 적용하는 프로젝트를 작업하고 싶을 때 2장으로 돌아오는 것이 좋을 수도 있습니다.</p>
<p>5장은 구조체와 메서드를 다루고, 6장은 열거형, <code>match</code> 표현식, 그리고 <code>if let</code> 제어 흐름 구조를 다룹니다. 러스트에서 커스텀 타입을 만들기 위해 구조체와 열거형을 사용하게 될 것입니다.</p>
<p>7장에서는 러스트의 모듈 시스템과 코드와 공개 애플리케이션 프로그래밍 인터페이스(API)를 구성하기 위한 프라이버시 규칙에 대해 배우게 됩니다. 8장은 벡터, 문자열, 해시 맵과 같이 표준 라이브러리가 제공하는 일반적인 컬렉션 데이터 구조들을 다룹니다. 9장은 러스트의 에러 처리 철학과 기법들을 탐구합니다.</p>
<p>10장은 여러 타입에 적용되는 코드를 정의할 수 있는 기능을 제공하는 제네릭, 트레이트, 라이프타임을 깊이 다룹니다. 11장은 러스트의 안전성 보장에도 불구하고 프로그램의 로직이 올바른지 확인하기 위해 필요한 테스팅에 관한 모든 것입니다. 12장에서는 파일 내에서 텍스트를 검색하는 <code>grep</code> 명령줄 도구의 기능 일부를 우리만의 구현으로 만들어볼 것입니다. 이를 위해 이전 장들에서 논의한 많은 개념들을 사용할 것입니다.</p>
<p>13장은 함수형 프로그래밍 언어에서 파생된 러스트의 기능인 클로저와 반복자를 탐구합니다. 14장에서는 Cargo를 더 깊이 살펴보고 다른 사람들과 라이브러리를 공유하기 위한 모범 사례에 대해 이야기할 것입니다. 15장에서는 표준 라이브러리가 제공하는 스마트 포인터와 그 기능을 가능하게 하는 트레이트를 논의합니다.</p>
<p>16장에서는 동시 프로그래밍의 다양한 모델을 살펴보고 러스트가 어떻게 여러 스레드에서 두려움 없이 프로그래밍할 수 있도록 도와주는지 이야기합니다. 17장에서는 러스트의 async와 await 문법과 그들이 지원하는 경량 동시성 모델을 탐구함으로써 그것을 기반으로 구축할 것입니다.</p>
<p>18장에서는 러스트 관용구가 여러분이 익숙할 수 있는 객체지향 프로그래밍 원칙과 어떻게 비교되는지 살펴봅니다.</p>
<p>19장은 러스트 프로그램 전반에 걸쳐 아이디어를 표현하는 강력한 방법인 패턴과 패턴 매칭에 대한 참조입니다. 20장은 안전하지 않은 러스트, 매크로, 그리고 라이프타임, 트레이트, 타입, 함수, 클로저에 대한 더 많은 내용을 포함하여 흥미로운 고급 주제들을 다양하게 다룹니다.</p>
<p>21장에서는 저수준 멀티스레드 웹 서버를 구현하는 프로젝트를 완료할 것입니다!</p>
<p>마지막으로, 일부 부록에는 언어에 대한 유용한 정보가 더 참조 형식으로 포함되어 있습니다. <strong>부록 A</strong>는 러스트의 키워드를 다루고, <strong>부록 B</strong>는 러스트의 연산자와 기호를 다루며, <strong>부록 C</strong>는 표준 라이브러리에서 제공하는 파생 가능한 트레이트를 다루고, <strong>부록 D</strong>는 몇 가지 유용한 개발 도구를 다루며, <strong>부록 E</strong>는 러스트 에디션을 설명합니다. <strong>부록 F</strong>에서는 책의 번역본을 찾을 수 있으며, <strong>부록 G</strong>에서는 러스트가 어떻게 만들어지는지와 나이틀리 러스트가 무엇인지 다룰 것입니다.</p>
<p>There is no wrong way to read this book: if you want to skip ahead, go for it! You might have to jump back to earlier chapters if you experience any confusion. But do whatever works for you.</p>
<p><span id="ferris"></span></p>
<p>러스트를 배우는 과정에서 중요한 부분은 컴파일러가 표시하는 오류 메시지를 읽는 방법을 배우는 것입니다. 이 메시지는 작동하는 코드를 향해 여러분을 안내할 것입니다. 따라서 컴파일러가 각 상황에서 보여줄 오류 메시지와 함께 컴파일되지 않는 많은 예제를 제공할 것입니다. 무작위 예제를 입력하고 실행하면 컴파일되지 않을 수 있다는 점을 알아두세요! 실행하려는 예제가 오류를 발생시키도록 의도된 것인지 확인하려면 주변 텍스트를 읽으십시오. 페리스는 또한 작동하도록 의도되지 않은 코드를 구별하는 데 도움을 줄 것입니다:</p>
<div class="table-wrapper"><table><thead><tr><th>페리스</th><th>의미</th></tr></thead><tbody>
<tr><td><img src="img/ferris/does_not_compile.svg" class="ferris-explain" alt="물음표가 있는 Ferris"/></td><td></td></tr>
<tr><td>이 코드는 컴파일되지 않습니다!</td><td></td></tr>
<tr><td><img src="img/ferris/panics.svg" class="ferris-explain" alt="손을 들어올리는 Ferris"/></td><td></td></tr>
<tr><td>이 코드는 패닉을 일으킵니다!</td><td></td></tr>
<tr><td><img src="img/ferris/not_desired_behavior.svg" class="ferris-explain" alt="한 발톱을 들고 어깨를 으쓱하는 Ferris"/></td><td></td></tr>
<tr><td>이 코드는 원하는 동작을 생성하지 않습니다.</td><td></td></tr>
</tbody></table>
</div>
<p>대부분의 상황에서 컴파일되지 않는 코드의 올바른 버전으로 안내할 것입니다.</p>
<h2 id="소스-코드"><a class="header" href="#소스-코드">소스 코드</a></h2>
<p>이 책이 생성되는 소스 파일들은 <a href="https://github.com/rust-lang/book/tree/main/src">GitHub</a>에서 찾을 수 있습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="시작하기"><a class="header" href="#시작하기">시작하기</a></h1>
<p>러스트 여정을 시작해봅시다! 배울 것이 많지만, 모든 여정은 어딘가에서 시작됩니다. 이 장에서는 다음을 다룰 것입니다:</p>
<ul>
<li>Linux, macOS, Windows에서 러스트 설치하기</li>
<li><code>Hello, world!</code>를 출력하는 프로그램 작성하기</li>
<li>러스트의 패키지 관리자이자 빌드 시스템인 <code>cargo</code> 사용하기</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="설치"><a class="header" href="#설치">설치</a></h2>
<p>첫 번째 단계는 러스트를 설치하는 것입니다. 러스트 버전과 관련 도구를 관리하는 명령줄 도구인 <code>rustup</code>을 통해 러스트를 다운로드할 것입니다. 다운로드를 위해 인터넷 연결이 필요합니다.</p>
<blockquote>
<p>참고: 어떤 이유로 <code>rustup</code>을 사용하고 싶지 않다면, 더 많은 옵션을 위해 <a href="https://forge.rust-lang.org/infra/other-installation-methods.html">다른 러스트 설치 방법 페이지</a>를 참조하세요.</p>
</blockquote>
<p>다음 단계는 러스트 컴파일러의 최신 안정 버전을 설치합니다. 러스트의 안정성 보장은 책의 모든 예제가 컴파일되면 더 새로운 러스트 버전에서도 계속 컴파일될 것임을 보장합니다. 러스트는 종종 오류 메시지와 경고를 개선하기 때문에 버전 간에 출력이 약간 다를 수 있습니다. 즉, 이 단계를 사용하여 설치하는 모든 최신 안정 러스트 버전은 이 책의 내용과 예상대로 작동해야 합니다.</p>
<blockquote>
<h3 id="명령줄-표기법"><a class="header" href="#명령줄-표기법">명령줄 표기법</a></h3>
<p>이 장과 책 전체에서 터미널에서 사용되는 몇 가지 명령을 보여줄 것입니다. 터미널에 입력해야 하는 줄은 모두 <code>$</code>로 시작합니다. <code>$</code> 문자를 입력할 필요는 없습니다. 각 명령의 시작을 나타내는 명령줄 프롬프트입니다. <code>$</code>로 시작하지 않는 줄은 일반적으로 이전 명령의 출력을 보여줍니다. 또한 PowerShell 특정 예제는 <code>$</code> 대신 <code>&gt;</code>를 사용합니다.</p>
</blockquote>
<h3 id="linux-또는-macos에서-rustup-설치하기"><a class="header" href="#linux-또는-macos에서-rustup-설치하기">Linux 또는 macOS에서 <code>rustup</code> 설치하기</a></h3>
<p>Linux 또는 macOS를 사용하는 경우 터미널을 열고 다음 명령을 입력하세요:</p>
<pre><code class="language-console">$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
</code></pre>
<p>이 명령은 스크립트를 다운로드하고 러스트의 최신 안정 버전을 설치하는 <code>rustup</code> 도구의 설치를 시작합니다. 비밀번호를 입력하라는 메시지가 나타날 수 있습니다. 설치가 성공하면 다음 줄이 나타날 것입니다:</p>
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<p>또한 러스트가 컴파일된 출력을 하나의 파일로 결합하는 데 사용하는 프로그램인 _링커_가 필요합니다. 이미 하나를 가지고 있을 가능성이 높습니다. 링커 에러가 발생하면 일반적으로 링커를 포함하는 C 컴파일러를 설치해야 합니다. 일부 일반적인 러스트 패키지가 C 코드에 의존하고 C 컴파일러가 필요하기 때문에 C 컴파일러도 유용합니다.</p>
<p>macOS에서는 다음을 실행하여 C 컴파일러를 얻을 수 있습니다:</p>
<pre><code class="language-console">$ xcode-select --install
</code></pre>
<p>Linux 사용자는 일반적으로 배포판 문서에 따라 GCC 또는 Clang을 설치해야 합니다. 예를 들어 Ubuntu를 사용하는 경우 <code>build-essential</code> 패키지를 설치할 수 있습니다.</p>
<h3 id="windows에서-rustup-설치하기"><a class="header" href="#windows에서-rustup-설치하기">Windows에서 <code>rustup</code> 설치하기</a></h3>
<p>Windows에서는 <a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a>로 이동하여 Rust 설치 지침을 따르세요. 설치 과정 중 어느 시점에서 Visual Studio를 설치하라는 메시지가 나타날 것입니다. 이는 프로그램을 컴파일하는 데 필요한 링커와 네이티브 라이브러리를 제공합니다. 이 단계에 대한 추가 도움이 필요하면 <a href="https://rust-lang.github.io/rustup/installation/windows-msvc.html">https://rust-lang.github.io/rustup/installation/windows-msvc.html</a>을 참조하세요.</p>
<p>이 책의 나머지 부분에서는 _cmd.exe_와 PowerShell 모두에서 작동하는 명령을 사용합니다. 특정 차이점이 있는 경우 어떤 것을 사용해야 하는지 설명할 것입니다.</p>
<h3 id="문제-해결"><a class="header" href="#문제-해결">문제 해결</a></h3>
<p>Rust가 올바르게 설치되었는지 확인하려면 셸을 열고 다음 줄을 입력하세요:</p>
<pre><code class="language-console">$ rustc --version
</code></pre>
<p>릴리스된 최신 안정 버전의 버전 번호, 커밋 해시 및 커밋 날짜가 다음 형식으로 표시되어야 합니다:</p>
<pre><code class="language-text">rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre>
<p>이 정보가 표시되면 Rust가 성공적으로 설치된 것입니다! 이 정보가 표시되지 않으면 다음과 같이 Rust가 <code>%PATH%</code> 시스템 변수에 있는지 확인하세요.</p>
<p>Windows CMD에서는 다음을 사용하세요:</p>
<pre><code class="language-console">&gt; echo %PATH%
</code></pre>
<p>PowerShell에서는 다음을 사용하세요:</p>
<pre><code class="language-powershell">&gt; echo $env:Path
</code></pre>
<p>Linux와 macOS에서는 다음을 사용하세요:</p>
<pre><code class="language-console">$ echo $PATH
</code></pre>
<p>모든 것이 올바른데도 Rust가 여전히 작동하지 않는다면 도움을 받을 수 있는 여러 곳이 있습니다. <a href="https://www.rust-lang.org/community">커뮤니티 페이지</a>에서 다른 Rustaceans(우리가 스스로를 부르는 우스꽝스러운 별명)와 연락하는 방법을 알아보세요.</p>
<h3 id="업데이트와-제거"><a class="header" href="#업데이트와-제거">업데이트와 제거</a></h3>
<p><code>rustup</code>을 통해 Rust가 설치되면 새로 릴리스된 버전으로 업데이트하는 것은 쉽습니다. 셸에서 다음 업데이트 스크립트를 실행하세요:</p>
<pre><code class="language-console">$ rustup update
</code></pre>
<p>Rust와 <code>rustup</code>을 제거하려면 셸에서 다음 제거 스크립트를 실행하세요:</p>
<pre><code class="language-console">$ rustup self uninstall
</code></pre>
<h3 id="로컬-문서"><a class="header" href="#로컬-문서">로컬 문서</a></h3>
<p>Rust 설치에는 문서의 로컬 복사본도 포함되어 있어 오프라인으로 읽을 수 있습니다. <code>rustup doc</code>을 실행하여 브라우저에서 로컬 문서를 여세요.</p>
<p>표준 라이브러리에서 제공하는 타입이나 함수가 무엇을 하는지 또는 어떻게 사용하는지 확실하지 않을 때는 언제든지 애플리케이션 프로그래밍 인터페이스(API) 문서를 사용하여 알아보세요!</p>
<h3 id="텍스트-에디터와-통합-개발-환경"><a class="header" href="#텍스트-에디터와-통합-개발-환경">텍스트 에디터와 통합 개발 환경</a></h3>
<p>이 책은 Rust 코드를 작성하는 데 어떤 도구를 사용하는지에 대해 가정하지 않습니다. 거의 모든 텍스트 편집기가 작업을 수행할 것입니다! 그러나 많은 텍스트 편집기와 통합 개발 환경(IDE)에는 Rust에 대한 내장 지원이 있습니다. Rust 웹사이트의 <a href="https://www.rust-lang.org/tools">도구 페이지</a>에서 많은 편집기와 IDE의 상당히 최신 목록을 항상 찾을 수 있습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="헬로-월드"><a class="header" href="#헬로-월드">헬로, 월드!</a></h2>
<p>이제 Rust를 설치했으니 첫 Rust 프로그램을 작성할 시간입니다. 새로운 언어를 배울 때 <code>Hello, world!</code> 텍스트를 화면에 출력하는 작은 프로그램을 작성하는 것이 전통적이므로 여기서도 그렇게 할 것입니다!</p>
<blockquote>
<p>참고: 이 책은 명령줄에 대한 기본적인 지식을 가정합니다. Rust는 편집 또는 도구 사용 또는 코드 위치에 대해 특별한 요구 사항이 없으므로 명령줄 대신 통합 개발 환경(IDE)을 사용하려는 경우 좋아하는 IDE를 자유롭게 사용하십시오. 많은 IDE가 이제 Rust 지원을 어느 정도 제공합니다. 자세한 내용은 IDE 문서를 확인하십시오. Rust 팀은 <code>rust-analyzer</code>를 통해 훌륭한 IDE 지원을 가능하게 하는 데 집중하고 있습니다. 자세한 내용은 <a href="appendix-04-useful-development-tools.html">부록 D</a><!-- ignore -->를 참조하십시오.</p>
</blockquote>
<h3 id="프로젝트-디렉터리-생성하기"><a class="header" href="#프로젝트-디렉터리-생성하기">프로젝트 디렉터리 생성하기</a></h3>
<p>Rust 코드를 저장할 디렉토리를 만드는 것부터 시작할 것입니다. Rust에게 코드가 어디에 있든 상관없지만, 이 책의 연습 문제와 프로젝트를 위해 홈 디렉토리에 <em>projects</em> 디렉토리를 만들고 모든 프로젝트를 그곳에 보관하는 것을 제안합니다.</p>
<p>터미널을 열고 다음 명령을 입력하여 <em>projects</em> 디렉토리와 <em>projects</em> 디렉토리 내에 "Hello, world!" 프로젝트용 디렉토리를 만드세요.</p>
<p>Linux, macOS, Windows의 PowerShell에서는 다음을 입력하세요:</p>
<pre><code class="language-console">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<p>Windows CMD에서는 다음을 입력하세요:</p>
<pre><code class="language-cmd">&gt; mkdir "%USERPROFILE%\projects"
&gt; cd /d "%USERPROFILE%\projects"
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<h3 id="러스트-프로그램-작성하고-실행하기"><a class="header" href="#러스트-프로그램-작성하고-실행하기">러스트 프로그램 작성하고 실행하기</a></h3>
<p>다음으로, 새 소스 파일을 만들고 _main.rs_라고 부르세요. Rust 파일은 항상 <em>.rs</em> 확장자로 끝납니다. 파일 이름에 두 개 이상의 단어를 사용하는 경우, 언더스코어를 사용하여 구분하는 것이 관례입니다. 예를 들어 <em>helloworld.rs</em> 대신 _hello_world.rs_를 사용하세요.</p>
<p>이제 방금 생성한 <em>main.rs</em> 파일을 열고 목록 1-1의 코드를 입력하세요.</p>
<Listing number="1-1" file-name="main.rs" caption="A program that prints `Hello, world!`">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    println!("헬로, 월드!");
}</code></pre></pre>
</Listing>
<p>파일을 저장하고 <em>~/projects/hello_world</em> 디렉토리의 터미널 창으로 돌아가세요. Linux 또는 macOS에서 다음 명령을 입력하여 파일을 컴파일하고 실행하세요:</p>
<pre><code class="language-console">$ rustc main.rs
$ ./main
Hello, world!
</code></pre>
<p>Windows에서는 <code>./main</code> 대신 <code>.\main.exe</code> 명령을 입력하세요:</p>
<pre><code class="language-powershell">&gt; rustc main.rs
&gt; .\main.exe
Hello, world!
</code></pre>
<p>운영 체제에 관계없이 <code>Hello, world!</code> 문자열이 터미널에 출력되어야 합니다. 이 출력이 표시되지 않으면 <a href="ch01-01-installation.html#troubleshooting">“문제 해결”</a><!-- ignore --> 설치 섹션의 도움말을 참조하세요.</p>
<p><code>Hello, world!</code>가 출력되었다면 축하합니다! 공식적으로 Rust 프로그램을 작성했습니다. 이제 Rust 프로그래머가 되셨습니다—환영합니다!</p>
<h3 id="러스트-프로그램의-구조"><a class="header" href="#러스트-프로그램의-구조">러스트 프로그램의 구조</a></h3>
<p>이 "Hello, world!" 프로그램을 자세히 살펴보겠습니다. 여기 퍼즐의 첫 번째 조각이 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {

}</code></pre></pre>
<p>이 줄들은 <code>main</code>이라는 함수를 정의합니다. <code>main</code> 함수는 특별합니다. 모든 실행 가능한 Rust 프로그램에서 항상 가장 먼저 실행되는 코드입니다. 여기서 첫 번째 줄은 매개변수가 없고 아무것도 반환하지 않는 <code>main</code>이라는 함수를 선언합니다. 매개변수가 있다면 괄호 <code>()</code> 안에 들어갈 것입니다.</p>
<p>함수 본문은 <code>{}</code>로 묶여 있습니다. Rust는 모든 함수 본문에 중괄호를 요구합니다. 여는 중괄호를 함수 선언과 같은 줄에 배치하고 그 사이에 공백 하나를 추가하는 것이 좋은 스타일입니다.</p>
<blockquote>
<p>참고: Rust 프로젝트 전반에 걸쳐 표준 스타일을 유지하고 싶다면 <code>rustfmt</code>라는 자동 포맷터 도구를 사용하여 코드를 특정 스타일로 포맷할 수 있습니다(자세한 내용은 <a href="appendix-04-useful-development-tools.html">부록 D</a><!-- ignore -->에서 <code>rustfmt</code>에 대해 더 알아보세요). Rust 팀은 <code>rustc</code>와 마찬가지로 이 도구를 표준 Rust 배포판에 포함했으므로 컴퓨터에 이미 설치되어 있을 것입니다!</p>
</blockquote>
<p><code>main</code> 함수의 본문에는 다음 코드가 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!("헬로, 월드!");
<span class="boring">}</span></code></pre></pre>
<p>이 줄은 이 작은 프로그램의 모든 작업을 수행합니다. 텍스트를 화면에 출력합니다. 여기에는 주목해야 할 네 가지 중요한 세부 사항이 있습니다.</p>
<p>첫째, <code>println!</code>은 Rust 매크로를 호출합니다. 함수를 호출했다면 <code>println</code> ( <code>!</code> 없음)으로 입력되었을 것입니다. 20장에서 Rust 매크로에 대해 더 자세히 논의할 것입니다. 지금은 <code>!</code>를 사용하는 것이 일반 함수 대신 매크로를 호출하는 것을 의미하며 매크로가 항상 함수와 동일한 규칙을 따르지는 않는다는 것을 알아야 합니다.</p>
<p>둘째, <code>"Hello, world!"</code> 문자열이 보입니다. 이 문자열을 <code>println!</code>에 인수로 전달하면 문자열이 화면에 출력됩니다.</p>
<p>셋째, 줄을 세미콜론(<code>;</code>)으로 끝냅니다. 이는 이 표현식이 끝났고 다음 표현식이 시작될 준비가 되었음을 나타냅니다. 대부분의 Rust 코드 줄은 세미콜론으로 끝납니다.</p>
<h3 id="컴파일과-실행은-별개의-단계입니다"><a class="header" href="#컴파일과-실행은-별개의-단계입니다">컴파일과 실행은 별개의 단계입니다</a></h3>
<p>방금 새로 생성된 프로그램을 실행했으므로 프로세스의 각 단계를 살펴보겠습니다.</p>
<p>Rust 프로그램을 실행하기 전에 <code>rustc</code> 명령을 입력하고 소스 파일 이름을 전달하여 Rust 컴파일러를 사용하여 컴파일해야 합니다. 다음과 같이요:</p>
<pre><code class="language-console">$ rustc main.rs
</code></pre>
<p>C 또는 C++ 배경이 있다면 이것이 <code>gcc</code> 또는 <code>clang</code>과 유사하다는 것을 알 수 있을 것입니다. 성공적으로 컴파일한 후 Rust는 바이너리 실행 파일을 출력합니다.</p>
<p>Linux, macOS, Windows의 PowerShell에서 셸에 <code>ls</code> 명령을 입력하여 실행 파일을 볼 수 있습니다:</p>
<pre><code class="language-console">$ ls
main  main.rs
</code></pre>
<p>Linux와 macOS에서는 두 개의 파일이 보일 것입니다. Windows의 PowerShell에서는 CMD를 사용할 때와 동일한 세 개의 파일이 보일 것입니다. Windows의 CMD에서는 다음을 입력할 것입니다:</p>
<pre><code class="language-cmd">&gt; dir /B %= the /B option says to only show the file names =%
main.exe
main.pdb
main.rs
</code></pre>
<p>이것은 <em>.rs</em> 확장자를 가진 소스 코드 파일, 실행 파일(Windows에서는 <em>main.exe</em>, 다른 모든 플랫폼에서는 <em>main</em>), 그리고 Windows를 사용하는 경우 <em>.pdb</em> 확장자를 가진 디버깅 정보가 포함된 파일을 보여줍니다. 여기에서 <em>main</em> 또는 <em>main.exe</em> 파일을 다음과 같이 실행합니다:</p>
<pre><code class="language-console">$ ./main # or .\main.exe on Windows
</code></pre>
<p>만약 _main.rs_가 "Hello, world!" 프로그램이라면, 이 줄은 터미널에 <code>Hello, world!</code>를 출력합니다.</p>
<p>Ruby, Python 또는 JavaScript와 같은 동적 언어에 더 익숙하다면 프로그램을 별도의 단계로 컴파일하고 실행하는 데 익숙하지 않을 수 있습니다. Rust는 <em>사전 컴파일</em> 언어이므로 프로그램을 컴파일하고 실행 파일을 다른 사람에게 제공할 수 있으며, 그들은 Rust가 설치되어 있지 않아도 실행할 수 있습니다. 누군가에게 <em>.rb</em>, <em>.py</em> 또는 <em>.js</em> 파일을 제공하면 해당 언어의 구현(각각)이 설치되어 있어야 합니다. 그러나 해당 언어에서는 프로그램을 컴파일하고 실행하는 데 하나의 명령만 필요합니다. 모든 것은 언어 설계의 트레이드오프입니다.</p>
<p><code>rustc</code>로만 컴파일하는 것은 간단한 프로그램에는 괜찮지만, 프로젝트가 커지면 모든 옵션을 관리하고 코드를 쉽게 공유하고 싶을 것입니다. 다음으로 실제 Rust 프로그램을 작성하는 데 도움이 될 Cargo 도구를 소개합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="헬로-카고"><a class="header" href="#헬로-카고">헬로, 카고!</a></h2>
<p>Cargo는 Rust의 빌드 시스템이자 패키지 관리자입니다. 대부분의 Rustaceans는 Cargo가 코드 빌드, 코드에 의존하는 라이브러리 다운로드, 해당 라이브러리 빌드와 같은 많은 작업을 처리해주기 때문에 이 도구를 사용하여 Rust 프로젝트를 관리합니다. (코드에 필요한 라이브러리를 _의존성_이라고 부릅니다.)</p>
<p>지금까지 작성한 것과 같은 가장 간단한 Rust 프로그램은 의존성이 없습니다. "Hello, world!" 프로젝트를 Cargo로 빌드했다면 코드 빌드를 처리하는 Cargo 부분만 사용했을 것입니다. 더 복잡한 Rust 프로그램을 작성할수록 의존성을 추가하게 될 것이며, Cargo를 사용하여 프로젝트를 시작하면 의존성을 추가하는 것이 훨씬 쉬워질 것입니다.</p>
<p>대부분의 Rust 프로젝트가 Cargo를 사용하므로 이 책의 나머지 부분에서도 Cargo를 사용한다고 가정합니다. <a href="ch01-01-installation.html#installation">“설치”</a><!-- ignore --> 섹션에서 설명한 공식 설치 프로그램을 사용했다면 Cargo는 Rust와 함께 설치됩니다. 다른 방법으로 Rust를 설치했다면 터미널에 다음을 입력하여 Cargo가 설치되었는지 확인하세요:</p>
<pre><code class="language-console">$ cargo --version
</code></pre>
<p>버전 번호가 보이면 설치된 것입니다! <code>command not found</code>와 같은 오류가 표시되면 설치 방법에 대한 문서를 참조하여 Cargo를 별도로 설치하는 방법을 확인하세요.</p>
<h3 id="cargo로-프로젝트-생성하기"><a class="header" href="#cargo로-프로젝트-생성하기">Cargo로 프로젝트 생성하기</a></h3>
<p>Cargo를 사용하여 새 프로젝트를 만들고 원래의 "Hello, world!" 프로젝트와 어떻게 다른지 살펴보겠습니다. <em>projects</em> 디렉토리(또는 코드를 저장하기로 결정한 곳)로 돌아가세요. 그런 다음 모든 운영 체제에서 다음을 실행하세요:</p>
<pre><code class="language-console">$ cargo new hello_cargo
$ cd hello_cargo
</code></pre>
<p>첫 번째 명령은 _hello_cargo_라는 새 디렉토리와 프로젝트를 만듭니다. 프로젝트 이름을 _hello_cargo_로 지정했으며, Cargo는 동일한 이름의 디렉토리에 파일을 만듭니다.</p>
<p><em>hello_cargo</em> 디렉토리로 이동하여 파일을 나열하세요. Cargo가 두 개의 파일과 하나의 디렉토리를 생성했음을 알 수 있습니다. <em>Cargo.toml</em> 파일과 그 안에 <em>main.rs</em> 파일이 있는 <em>src</em> 디렉토리입니다.</p>
<p>또한 <em>.gitignore</em> 파일과 함께 새 Git 리포지토리를 초기화했습니다. 기존 Git 리포지토리 내에서 <code>cargo new</code>를 실행하면 Git 파일이 생성되지 않습니다. <code>cargo new --vcs=git</code>을 사용하여 이 동작을 재정의할 수 있습니다.</p>
<blockquote>
<p>참고: Git은 일반적인 버전 관리 시스템입니다. <code>--vcs</code> 플래그를 사용하여 <code>cargo new</code>가 다른 버전 관리 시스템을 사용하거나 버전 관리 시스템을 사용하지 않도록 변경할 수 있습니다. 사용 가능한 옵션을 보려면 <code>cargo new --help</code>를 실행하세요.</p>
</blockquote>
<p>선택한 텍스트 편집기에서 _Cargo.toml_을 여세요. 목록 1-2의 코드와 유사하게 보일 것입니다.</p>
<Listing number="1-2" file-name="Cargo.toml" caption="Contents of *Cargo.toml* generated by `cargo new`">
<pre><code class="language-toml">[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

[dependencies]
</code></pre>
</Listing>
<p>이 파일은 Cargo의 구성 형식인 <a href="https://toml.io"><em>TOML</em></a><!-- ignore --> (<em>Tom’s Obvious, Minimal Language</em>) 형식입니다.</p>
<p>첫 번째 줄인 <code>[package]</code>는 다음 문이 패키지를 구성하고 있음을 나타내는 섹션 제목입니다. 이 파일에 더 많은 정보를 추가할수록 다른 섹션을 추가할 것입니다.</p>
<p>다음 세 줄은 Cargo가 프로그램을 컴파일하는 데 필요한 구성 정보(이름, 버전, 사용할 Rust 에디션)를 설정합니다. <a href="appendix-05-editions.html">부록 E</a><!-- ignore -->에서 <code>edition</code> 키에 대해 이야기할 것입니다.</p>
<p>마지막 줄인 <code>[dependencies]</code>는 프로젝트의 의존성을 나열하는 섹션의 시작입니다. Rust에서는 코드 패키지를 _크레이트_라고 부릅니다. 이 프로젝트에는 다른 크레이트가 필요하지 않지만, 2장의 첫 번째 프로젝트에서는 필요할 것이므로 그때 이 의존성 섹션을 사용할 것입니다.</p>
<p>이제 _src/main.rs_를 열어서 살펴보세요:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    println!("헬로, 월드!");
}</code></pre></pre>
<p>Cargo는 목록 1-1에서 작성한 것과 똑같은 "Hello, world!" 프로그램을 생성했습니다! 지금까지 우리 프로젝트와 Cargo가 생성한 프로젝트의 차이점은 Cargo가 코드를 <em>src</em> 디렉토리에 배치했고 최상위 디렉토리에 <em>Cargo.toml</em> 구성 파일이 있다는 것입니다.</p>
<p>Cargo는 소스 파일이 <em>src</em> 디렉토리 안에 있어야 한다고 예상합니다. 최상위 프로젝트 디렉토리는 README 파일, 라이선스 정보, 구성 파일 및 코드와 관련 없는 다른 모든 것을 위한 것입니다. Cargo를 사용하면 프로젝트를 구성하는 데 도움이 됩니다. 모든 것에는 제자리가 있고, 모든 것은 제자리에 있습니다.</p>
<p>Cargo를 사용하지 않는 프로젝트를 시작했다면, "Hello, world!" 프로젝트에서 했던 것처럼 Cargo를 사용하는 프로젝트로 변환할 수 있습니다. 프로젝트 코드를 <em>src</em> 디렉토리로 이동하고 적절한 <em>Cargo.toml</em> 파일을 만드세요. <em>Cargo.toml</em> 파일을 얻는 한 가지 쉬운 방법은 <code>cargo init</code>을 실행하는 것입니다. 그러면 자동으로 생성됩니다.</p>
<h3 id="cargo-프로젝트-빌드하고-실행하기"><a class="header" href="#cargo-프로젝트-빌드하고-실행하기">Cargo 프로젝트 빌드하고 실행하기</a></h3>
<p>이제 Cargo로 "Hello, world!" 프로그램을 빌드하고 실행할 때 무엇이 다른지 살펴보겠습니다! <em>hello_cargo</em> 디렉토리에서 다음 명령을 입력하여 프로젝트를 빌드하세요:</p>
<pre><code class="language-console">$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
<p>이 명령은 현재 디렉토리가 아닌 <em>target/debug/hello_cargo</em> (Windows에서는 <em>target\debug\hello_cargo.exe</em>)에 실행 파일을 만듭니다. 기본 빌드가 디버그 빌드이므로 Cargo는 바이너리를 _debug_라는 디렉토리에 넣습니다. 이 명령으로 실행 파일을 실행할 수 있습니다:</p>
<pre><code class="language-console">$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
Hello, world!
</code></pre>
<p>모든 것이 잘 진행되면 <code>Hello, world!</code>가 터미널에 출력되어야 합니다. <code>cargo build</code>를 처음 실행하면 Cargo는 최상위 수준에 _Cargo.lock_이라는 새 파일을 만듭니다. 이 파일은 프로젝트의 의존성 정확한 버전을 추적합니다. 이 프로젝트에는 의존성이 없으므로 파일은 다소 희박합니다. 이 파일을 수동으로 변경할 필요는 없습니다. Cargo가 내용을 관리합니다.</p>
<p>방금 <code>cargo build</code>로 프로젝트를 빌드하고 <code>./target/debug/hello_cargo</code>로 실행했지만, <code>cargo run</code>을 사용하여 코드를 컴파일한 다음 결과 실행 파일을 한 번에 실행할 수도 있습니다:</p>
<pre><code class="language-console">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p><code>cargo run</code>을 사용하는 것이 <code>cargo build</code>를 실행한 다음 바이너리의 전체 경로를 기억해야 하는 것보다 편리하므로 대부분의 개발자는 <code>cargo run</code>을 사용합니다.</p>
<p>이번에는 Cargo가 <code>hello_cargo</code>를 컴파일하고 있다는 출력이 표시되지 않았습니다. Cargo는 파일이 변경되지 않았음을 파악했으므로 다시 빌드하지 않고 바이너리를 실행했습니다. 소스 코드를 수정했다면 Cargo는 실행하기 전에 프로젝트를 다시 빌드했을 것이며, 이 출력이 표시되었을 것입니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Cargo는 <code>cargo check</code>라는 명령도 제공합니다. 이 명령은 코드가 컴파일되는지 빠르게 확인하지만 실행 파일을 생성하지는 않습니다:</p>
<pre><code class="language-console">$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
<p>실행 파일을 원하지 않는 이유는 무엇입니까? 종종 <code>cargo check</code>는 실행 파일을 생성하는 단계를 건너뛰기 때문에 <code>cargo build</code>보다 훨씬 빠릅니다. 코드를 작성하는 동안 작업을 계속 확인하는 경우 <code>cargo check</code>를 사용하면 프로젝트가 여전히 컴파일되는지 여부를 알려주는 프로세스 속도를 높일 수 있습니다! 따라서 많은 Rustaceans는 프로그램을 작성하면서 주기적으로 <code>cargo check</code>를 실행하여 컴파일되는지 확인합니다. 그런 다음 실행 파일을 사용할 준비가 되면 <code>cargo build</code>를 실행합니다.</p>
<p>Cargo에 대해 지금까지 배운 내용을 요약해 봅시다:</p>
<ul>
<li><code>cargo new</code>를 사용하여 프로젝트를 생성할 수 있습니다.</li>
<li><code>cargo build</code>를 사용하여 프로젝트를 빌드할 수 있습니다.</li>
<li><code>cargo run</code>을 사용하여 한 번에 프로젝트를 빌드하고 실행할 수 있습니다.</li>
<li><code>cargo check</code>를 사용하여 바이너리를 생성하지 않고 프로젝트를 빌드하여 오류를 확인할 수 있습니다.</li>
<li>빌드 결과를 코드와 동일한 디렉토리에 저장하는 대신 Cargo는 <em>target/debug</em> 디렉토리에 저장합니다.</li>
</ul>
<p>Cargo를 사용하는 추가적인 장점은 작업하는 운영 체제에 관계없이 명령이 동일하다는 것입니다. 따라서 이 시점부터 Linux 및 macOS와 Windows에 대한 특정 지침은 더 이상 제공하지 않습니다.</p>
<h3 id="릴리스용-빌드"><a class="header" href="#릴리스용-빌드">릴리스용 빌드</a></h3>
<p>프로젝트가 마침내 릴리스 준비가 되면 <code>cargo build --release</code>를 사용하여 최적화와 함께 컴파일할 수 있습니다. 이 명령은 <em>target/debug</em> 대신 _target/release_에 실행 파일을 만듭니다. 최적화는 Rust 코드를 더 빠르게 실행하지만, 이를 켜면 프로그램 컴파일 시간이 길어집니다. 이것이 두 가지 다른 프로필이 있는 이유입니다. 하나는 개발용으로, 빠르고 자주 다시 빌드하고 싶을 때 사용하고, 다른 하나는 사용자에게 제공할 최종 프로그램을 빌드할 때 사용합니다. 이 프로그램은 반복적으로 다시 빌드되지 않으며 가능한 한 빠르게 실행됩니다. 코드의 실행 시간을 벤치마킹하는 경우 <code>cargo build --release</code>를 실행하고 _target/release_의 실행 파일로 벤치마킹해야 합니다.</p>
<h3 id="관례로서의-cargo"><a class="header" href="#관례로서의-cargo">관례로서의 Cargo</a></h3>
<p>간단한 프로젝트에서는 Cargo가 단지 <code>rustc</code>를 사용하는 것보다 큰 가치를 제공하지는 않지만, 프로그램이 더 복잡해지면 그 가치를 증명할 것입니다. 프로그램이 여러 파일로 커지거나 의존성이 필요하게 되면 Cargo가 빌드를 조정하도록 하는 것이 훨씬 쉽습니다.</p>
<p><code>hello_cargo</code> 프로젝트는 간단하지만, 여러분의 나머지 러스트 경력에서 사용하게 될 실제 도구의 많은 부분을 이미 사용하고 있습니다. 사실, 기존의 어떤 프로젝트에서든 작업하기 위해 다음 명령을 사용하여 Git으로 코드를 확인하고, 해당 프로젝트의 디렉토리로 변경한 다음, 빌드할 수 있습니다:</p>
<pre><code class="language-console">$ git clone example.org/someproject
$ cd someproject
$ cargo build
</code></pre>
<p>Cargo에 대한 더 많은 정보를 원하시면, <a href="https://doc.rust-lang.org/cargo/">공식 문서</a>를 확인하세요.</p>
<h2 id="요약"><a class="header" href="#요약">요약</a></h2>
<p>여러분은 이미 러스트 여정을 순조롭게 시작했습니다! 이번 장에서 여러분은 다음을 배웠습니다:</p>
<ul>
<li><code>rustup</code>을 사용하여 최신 안정 버전의 러스트 설치하기</li>
<li>새로운 러스트 버전으로 업데이트하기</li>
<li>로컬에 설치된 문서 열기</li>
<li><code>rustc</code>를 직접 사용하여 “Hello, world!” 프로그램을 작성하고 실행하기</li>
<li>Cargo의 관례를 사용하여 새 프로젝트 생성하고 실행하기</li>
</ul>
<p>이제 러스트 코드를 읽고 쓰는 데 익숙해지기 위해 더 실질적인 프로그램을 만들어 볼 좋은 시간입니다. 그래서 2장에서는 추측 게임 프로그램을 만들 것입니다. 만약 러스트에서 일반적인 프로그래밍 개념이 어떻게 작동하는지 먼저 배우고 싶다면, 3장을 보고 2장으로 돌아오세요.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="추측-게임-프로그래밍"><a class="header" href="#추측-게임-프로그래밍">추측 게임 프로그래밍</a></h1>
<p>함께 실습 프로젝트를 통해 Rust에 뛰어들어 봅시다! 이 장에서는 몇 가지 일반적인 Rust 개념을 실제 프로그램에서 사용하는 방법을 보여줌으로써 소개합니다. <code>let</code>, <code>match</code>, 메서드, 연관 함수, 외부 크레이트 등에 대해 배울 것입니다! 다음 장에서는 이러한 아이디어를 더 자세히 탐구할 것입니다. 이 장에서는 기본 사항만 연습할 것입니다.</p>
<p>고전적인 초보자 프로그래밍 문제인 숫자 맞추기 게임을 구현할 것입니다. 작동 방식은 다음과 같습니다. 프로그램은 1에서 100 사이의 무작위 정수를 생성합니다. 그런 다음 플레이어에게 추측을 입력하라는 메시지를 표시합니다. 추측이 입력되면 프로그램은 추측이 너무 낮은지 또는 너무 높은지 나타냅니다. 추측이 맞으면 게임은 축하 메시지를 인쇄하고 종료합니다.</p>
<h2 id="새-프로젝트-설정하기"><a class="header" href="#새-프로젝트-설정하기">새 프로젝트 설정하기</a></h2>
<p>새 프로젝트를 설정하려면 1장에서 만든 <em>projects</em> 디렉토리로 이동하여 Cargo를 사용하여 새 프로젝트를 만드세요. 다음과 같이요:</p>
<pre><code class="language-console">$ cargo new guessing_game
$ cd guessing_game
</code></pre>
<p>첫 번째 명령인 <code>cargo new</code>는 프로젝트 이름(<code>guessing_game</code>)을 첫 번째 인수로 받습니다. 두 번째 명령은 새 프로젝트 디렉토리로 변경합니다.</p>
<p>생성된 <em>Cargo.toml</em> 파일을 살펴보세요:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial
rm -rf no-listing-01-cargo-new
cargo new no-listing-01-cargo-new --name guessing_game
cd no-listing-01-cargo-new
cargo run > output.txt 2>&1
cd ../../..
-->
<p><span class="filename">파일명: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
version = "0.1.0"
edition = "2021"

[dependencies]
</code></pre>
<p>1장에서 보았듯이 <code>cargo new</code>는 "Hello, world!" 프로그램을 생성합니다. <em>src/main.rs</em> 파일을 확인하세요:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    println!("헬로, 월드!");
}</code></pre></pre>
<p>이제 <code>cargo run</code> 명령을 사용하여 이 "Hello, world!" 프로그램을 컴파일하고 같은 단계에서 실행해 봅시다:</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.20s
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
<p><code>run</code> 명령은 이 게임에서처럼 프로젝트를 빠르게 반복해야 할 때 유용합니다. 다음 반복으로 넘어가기 전에 각 반복을 빠르게 테스트합니다.</p>
<p><em>src/main.rs</em> 파일을 다시 여세요. 이 파일에 모든 코드를 작성할 것입니다.</p>
<h2 id="추측-처리하기"><a class="header" href="#추측-처리하기">추측 처리하기</a></h2>
<p>추측 게임 프로그램의 첫 번째 부분은 사용자 입력을 요청하고, 그 입력을 처리하고, 입력이 예상된 형식인지 확인합니다. 시작하려면, 플레이어가 추측을 입력하도록 허용할 것입니다. 목록 2-1의 코드를 _src/main.rs_에 입력하세요.</p>
<Listing number="2-1" file-name="src/main.rs" caption="Code that gets a guess from the user and prints it">
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!("숫자를 맞춰보세요!");

    println!(추측을 입력하세요.);

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("줄 읽기 실패");

    println!("당신의 추측: {}", guess);
}</code></pre>
</Listing>
<p>이 코드는 많은 정보를 담고 있으므로, 한 줄씩 살펴보겠습니다. 사용자 입력을 받고 그 결과를 출력으로 인쇄하려면, <code>io</code> 입출력 라이브러리를 스코프로 가져와야 합니다. <code>io</code> 라이브러리는 <code>std</code>로 알려진 표준 라이브러리에서 제공됩니다:</p>
<pre><code class="language-rust ignore">use std::io;
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    println!(추측을 입력하세요.);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("줄 읽기 실패");
</span><span class="boring">
</span><span class="boring">    println!("당신의 추측: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>기본적으로, 러스트는 모든 프로그램의 스코프로 가져오는 표준 라이브러리에 정의된 아이템 세트를 가지고 있습니다. 이 세트를 _프렐류드_라고 하며, <a href="../std/prelude/index.html">표준 라이브러리 문서</a>에서 모든 것을 볼 수 있습니다.</p>
<p>사용하려는 타입이 프렐류드에 없으면, <code>use</code> 문을 사용하여 해당 타입을 명시적으로 스코프로 가져와야 합니다. <code>std::io</code> 라이브러리를 사용하면 사용자 입력을 받는 기능을 포함하여 여러 유용한 기능을 사용할 수 있습니다.</p>
<p>1장에서 보았듯이, <code>main</code> 함수는 프로그램의 진입점입니다:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span>fn main() {
<span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    println!(추측을 입력하세요.);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("줄 읽기 실패");
</span><span class="boring">
</span><span class="boring">    println!("당신의 추측: {}", guess);
</span><span class="boring">}</span></code></pre>
<p><code>fn</code> 구문은 새 함수를 선언하고, 괄호 <code>()</code>는 매개변수가 없음을 나타내며, 중괄호 <code>{</code>는 함수 본문의 시작을 나타냅니다.</p>
<p>1장에서 배운 것처럼, <code>println!</code>은 화면에 문자열을 출력하는 매크로입니다:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    println!("숫자를 맞춰보세요!");

    println!(추측을 입력하세요.);
<span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("줄 읽기 실패");
</span><span class="boring">
</span><span class="boring">    println!("당신의 추측: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>이 코드는 게임이 무엇인지 알리고 사용자로부터 입력을 요청하는 프롬프트를 출력합니다.</p>
<h3 id="변수로-값-저장하기"><a class="header" href="#변수로-값-저장하기">변수로 값 저장하기</a></h3>
<p>다음으로, 사용자 입력을 저장할 _변수_를 다음과 같이 생성합니다:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    println!(추측을 입력하세요.);
</span><span class="boring">
</span>    let mut guess = String::new();
<span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("줄 읽기 실패");
</span><span class="boring">
</span><span class="boring">    println!("당신의 추측: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>이제 프로그램이 흥미로워졌습니다! 이 작은 한 줄에 많은 일이 일어나고 있습니다. <code>let</code> 문을 사용하여 변수를 생성합니다. 다음은 또 다른 예입니다:</p>
<pre><code class="language-rust ignore">let apples = 5;</code></pre>
<p>이 줄은 <code>apples</code>라는 새 변수를 만들고 값 5에 바인딩합니다. 러스트에서 변수는 기본적으로 불변이므로, 일단 변수에 값을 주면 그 값은 변하지 않습니다. 이 개념에 대해서는 3장의 <a href="ch03-01-variables-and-mutability.html#variables-and-mutability">“변수와 가변성”</a><!-- ignore --> 섹션에서 자세히 다룰 것입니다. 변수를 가변으로 만들려면, 변수 이름 앞에 <code>mut</code>를 추가합니다:</p>
<pre><code class="language-rust ignore">let apples = 5; // 불변
let mut bananas = 5; // 가변</code></pre>
<blockquote>
<p>참고: <code>//</code> 구문은 줄 끝까지 계속되는 주석을 시작합니다. 러스트는 주석의 모든 것을 무시합니다. 주석에 대해서는 <a href="ch03-04-comments.html">3장</a><!-- ignore -->에서 더 자세히 다룰 것입니다.</p>
</blockquote>
<p>추측 게임 프로그램으로 돌아가서, 이제 <code>let mut guess</code>가 <code>guess</code>라는 가변 변수를 도입한다는 것을 알게 되었습니다. 등호(<code>=</code>)는 러스트에게 지금 변수에 무언가를 바인딩하고 싶다고 알려줍니다. 등호 오른쪽에는 <code>guess</code>가 바인딩되는 값이 있는데, 이는 <code>String</code>의 새 인스턴스를 반환하는 함수인 <code>String::new</code>를 호출한 결과입니다. <a href="../std/string/struct.String.html"><code>String</code></a><!-- ignore -->은 표준 라이브러리에서 제공하는 문자열 타입으로, 커질 수 있는 UTF-8 인코딩된 텍스트 조각입니다.</p>
<p><code>::new</code> 줄의 <code>::</code> 구문은 <code>new</code>가 <code>String</code> 타입의 연관 함수임을 나타냅니다. _연관 함수_는 타입에 구현된 함수이며, 이 경우 <code>String</code>입니다. 이 <code>new</code> 함수는 새롭고 비어있는 문자열을 만듭니다. 많은 타입에서 <code>new</code> 함수를 찾을 수 있는데, 이는 어떤 종류의 새 값을 만드는 함수의 일반적인 이름이기 때문입니다.</p>
<p>전체적으로, <code>let mut guess = String::new();</code> 줄은 현재 <code>String</code>의 새롭고 비어있는 인스턴스에 바인딩된 가변 변수를 생성했습니다. 휴!</p>
<h3 id="사용자-입력-받기"><a class="header" href="#사용자-입력-받기">사용자 입력 받기</a></h3>
<p>프로그램의 첫 줄에 <code>use std::io;</code>로 표준 라이브러리에서 입출력 기능을 포함시켰던 것을 기억하세요. 이제 <code>io</code> 모듈에서 <code>stdin</code> 함수를 호출하여 사용자 입력을 처리할 수 있도록 할 것입니다:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    println!(추측을 입력하세요.);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span>    io::stdin()
        .read_line(&amp;mut guess)
<span class="boring">        .expect("줄 읽기 실패");
</span><span class="boring">
</span><span class="boring">    println!("당신의 추측: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>만약 프로그램 시작 부분에 <code>use std::io;</code>로 <code>io</code> 라이브러리를 가져오지 않았다면, 이 함수 호출을 <code>std::io::stdin</code>으로 작성하여 함수를 계속 사용할 수 있습니다. <code>stdin</code> 함수는 터미널의 표준 입력을 나타내는 타입인 <a href="../std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore -->의 인스턴스를 반환합니다.</p>
<p>다음으로, <code>.read_line(&amp;mut guess)</code> 줄은 표준 입력 핸들에서 <a href="../std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a><!--
무시 --> 메서드를 호출하여 사용자로부터 입력을 받습니다. 또한 <code>read_line</code>에 <code>&amp;mut guess</code>를 인수로 전달하여 사용자 입력을 저장할 문자열을 알려줍니다. <code>read_line</code>의 전체 작업은 사용자가 표준 입력에 입력하는 모든 것을 가져와 문자열에 추가하는 것(내용을 덮어쓰지 않고)이므로, 따라서 해당 문자열을 인수로 전달합니다. 메서드가 문자열의 내용을 변경할 수 있도록 문자열 인수는 가변적이어야 합니다.</p>
<p><code>&amp;</code>는 이 인수가 _참조_임을 나타내며, 이는 코드의 여러 부분이 데이터를 메모리에 여러 번 복사할 필요 없이 데이터 한 조각에 액세스할 수 있는 방법을 제공합니다. 참조는 복잡한 기능이며, 러스트의 주요 장점 중 하나는 참조를 사용하는 것이 얼마나 안전하고 쉬운가 하는 것입니다. 이 프로그램을 마치기 위해 이러한 세부 사항을 많이 알 필요는 없습니다. 지금은 변수와 마찬가지로 참조도 기본적으로 불변이라는 것만 알면 됩니다. 따라서 가변으로 만들려면 <code>&amp;guess</code>가 아닌 <code>&amp;mut guess</code>를 작성해야 합니다. (4장에서 참조에 대해 더 자세히 설명할 것입니다.)</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="handling-potential-failure-with-the-result-type"></a></p>
<h3 id="result로-잠재적-실패-처리하기"><a class="header" href="#result로-잠재적-실패-처리하기"><code>Result</code>로 잠재적 실패 처리하기</a></h3>
<p>우리는 아직 이 코드 라인에서 작업 중입니다. 이제 세 번째 텍스트 라인을 논의하고 있지만, 이것이 여전히 단일 논리적 코드 라인의 일부라는 점에 유의하세요. 다음 부분은 이 메서드입니다:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    println!(추측을 입력하세요.);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span>        .expect("줄 읽기 실패");
<span class="boring">
</span><span class="boring">    println!("당신의 추측: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>이 코드를 다음과 같이 작성할 수도 있었습니다:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess).expect("줄 읽기 실패");</code></pre>
<p>그러나 한 줄이 길면 읽기 어려우므로 나누는 것이 가장 좋습니다. <code>.method_name()</code> 구문으로 메서드를 호출할 때 긴 줄을 나누는 데 도움이 되도록 줄 바꿈 및 기타 공백을 도입하는 것이 현명할 때가 많습니다. 이제 이 줄이 무엇을 하는지 논의해 보겠습니다.</p>
<p>앞서 언급했듯이, <code>read_line</code>은 사용자가 입력하는 모든 것을 우리가 전달하는 문자열에 넣지만, <code>Result</code> 값도 반환합니다. <a href="../std/result/enum.Result.html"><code>Result</code></a><!--
무시 -->는 종종 _열거형_이라고 불리는 <a href="ch06-00-enums.html"><em>열거형</em></a><!-- 무시 -->이며, 여러 가능한 상태 중 하나일 수 있는 타입입니다. 우리는 각 가능한 상태를 _variant_라고 부릅니다.</p>
<p><a href="ch06-00-enums.html">6장</a><!-- ignore -->에서 열거형에 대해 더 자세히 다룰 것입니다. 이러한 <code>Result</code> 타입의 목적은 오류 처리 정보를 인코딩하는 것입니다.</p>
<p><code>Result</code>의 variant는 <code>Ok</code>와 <code>Err</code>입니다. <code>Ok</code> variant는 작업이 성공했음을 나타내며, 성공적으로 생성된 값을 포함합니다. <code>Err</code> variant는 작업이 실패했음을 의미하며, 작업이 실패한 방법이나 이유에 대한 정보를 포함합니다.</p>
<p><code>Result</code> 타입의 값은 다른 타입의 값과 마찬가지로 메서드가 정의되어 있습니다. <code>Result</code>의 인스턴스에는 호출할 수 있는 <a href="../std/result/enum.Result.html#method.expect"><code>expect</code> 메서드</a><!-- ignore -->가 있습니다. 이 <code>Result</code> 인스턴스가 <code>Err</code> 값이면, <code>expect</code>는 프로그램을 충돌시키고 <code>expect</code>에 인수로 전달한 메시지를 표시합니다. <code>read_line</code> 메서드가 <code>Err</code>를 반환하면, 이는 기본 운영 체제에서 발생하는 오류의 결과일 가능성이 높습니다. 이 <code>Result</code> 인스턴스가 <code>Ok</code> 값이면, <code>expect</code>는 <code>Ok</code>가 가지고 있는 반환 값을 가져와서 사용할 수 있도록 해당 값만 반환합니다. 이 경우, 그 값은 사용자 입력의 바이트 수입니다.</p>
<p><code>expect</code>를 호출하지 않으면 프로그램은 컴파일되지만, 경고가 표시됩니다:</p>
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `Result` that must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
10 |     let _ = io::stdin().read_line(&amp;mut guess);
   |     +++++++

warning: `guessing_game` (bin "guessing_game") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>러스트는 <code>read_line</code>에서 반환된 <code>Result</code> 값을 사용하지 않았다고 경고하며, 이는 프로그램이 가능한 오류를 처리하지 않았음을 나타냅니다.</p>
<p>경고를 억제하는 올바른 방법은 실제로 오류 처리 코드를 작성하는 것이지만, 이 경우에는 문제가 발생했을 때 프로그램을 충돌시키고 싶기 때문에 <code>expect</code>를 사용할 수 있습니다. 오류로부터 복구하는 방법에 대해서는 <a href="ch09-02-recoverable-errors-with-result.html">9장</a><!-- ignore -->에서 배울 것입니다.</p>
<h3 id="println-플레이스홀더로-값-출력하기"><a class="header" href="#println-플레이스홀더로-값-출력하기"><code>println!</code> 플레이스홀더로 값 출력하기</a></h3>
<p>닫는 중괄호를 제외하고, 지금까지 코드에서 논의할 줄은 한 줄 더 있습니다:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    println!(추측을 입력하세요.);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("줄 읽기 실패");
</span><span class="boring">
</span>    println!("당신의 추측: {}", guess);
<span class="boring">}</span></code></pre>
<p>이 줄은 이제 사용자 입력을 포함하는 문자열을 출력합니다. <code>{}</code> 중괄호 세트는 플레이스홀더입니다: <code>{}</code>를 값을 제자리에 고정하는 작은 게 집게라고 생각하세요. 변수 값을 출력할 때, 변수 이름은 중괄호 안에 들어갈 수 있습니다. 표현식 평가 결과를 출력할 때, 형식 문자열에 빈 중괄호를 넣은 다음, 형식 문자열 뒤에 쉼표로 구분된 표현식 목록을 각 빈 중괄호 플레이스홀더에 같은 순서로 출력합니다. <code>println!</code> 한 번의 호출로 변수와 표현식 결과를 출력하는 것은 다음과 같습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = 10;

println!("x = {x} and y + 2 = {}", y + 2);
<span class="boring">}</span></code></pre></pre>
<p>이 코드는 <code>x = 5 and y + 2 = 12</code>를 출력할 것입니다.</p>
<h3 id="첫-번째-부분-테스트하기"><a class="header" href="#첫-번째-부분-테스트하기">첫 번째 부분 테스트하기</a></h3>
<p>추측 게임의 첫 번째 부분을 테스트해 봅시다. <code>cargo run</code>을 사용하여 실행하세요:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-01/
cargo clean
cargo run
input 6 -->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
``````console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
</code></pre>
<p>이 시점에서 게임의 첫 번째 부분이 완료되었습니다: 키보드에서 입력을 받아 출력하고 있습니다.</p>
<h2 id="비밀-번호-생성하기"><a class="header" href="#비밀-번호-생성하기">비밀 번호 생성하기</a></h2>
<p>다음으로, 사용자가 추측할 비밀 번호를 생성해야 합니다. 게임을 여러 번 즐길 수 있도록 비밀 번호는 매번 달라야 합니다. 게임이 너무 어렵지 않도록 1에서 100 사이의 난수를 사용할 것입니다. 러스트는 아직 표준 라이브러리에 난수 기능을 포함하고 있지 않습니다. 그러나 러스트 팀은 해당 기능을 가진 <a href="https://crates.io/crates/rand"><code>rand</code> 크레이트</a>를 제공합니다.</p>
<h3 id="크레이트를-사용하여-더-많은-기능-얻기"><a class="header" href="#크레이트를-사용하여-더-많은-기능-얻기">크레이트를 사용하여 더 많은 기능 얻기</a></h3>
<p>크레이트는 러스트 소스 코드 파일의 모음이라는 것을 기억하세요. 우리가 빌드해 온 프로젝트는 실행 파일인 _바이너리 크레이트_입니다. <code>rand</code> 크레이트는 다른 프로그램에서 사용하도록 의도된 코드를 포함하고 자체적으로 실행할 수 없는 _라이브러리 크레이트_입니다.</p>
<p>Cargo의 외부 크레이트 조정은 Cargo가 정말 빛을 발하는 부분입니다. <code>rand</code>를 사용하는 코드를 작성하기 전에, <code>rand</code> 크레이트를 의존성으로 포함하도록 <em>Cargo.toml</em> 파일을 수정해야 합니다. 지금 그 파일을 열고 Cargo가 생성한 <code>[dependencies]</code> 섹션 헤더 아래 맨 아래에 다음 줄을 추가하세요. 여기에 있는 버전 번호와 정확히 동일하게 <code>rand</code>를 지정해야 합니다. 그렇지 않으면 이 튜토리얼의 코드 예제가 작동하지 않을 수 있습니다:</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
* ch14-03-cargo-workspaces.md
-->
<p><span class="filename">파일명: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = "0.8.5"
</code></pre>
<p><em>Cargo.toml</em> 파일에서 헤더 뒤에 오는 모든 것은 다른 섹션이 시작될 때까지 해당 섹션의 일부입니다. <code>[dependencies]</code>에서 Cargo에게 프로젝트가 의존하는 외부 크레이트와 필요한 크레이트의 버전을 알려줍니다. 이 경우, 우리는 의미론적 버전 지정자 <code>0.8.5</code>로 <code>rand</code> 크레이트를 지정합니다. Cargo는 버전 번호를 작성하는 표준인 <a href="http://semver.org">의미론적 버전 관리</a><!-- ignore --> (때로는 _SemVer_라고도 함)를 이해합니다. 지정자 <code>0.8.5</code>는 실제로는 <code>^0.8.5</code>의 약식이며, 이는 0.8.5 이상이지만 0.9.0 미만인 모든 버전을 의미합니다.</p>
<p>Cargo는 이러한 버전이 0.8.5 버전과 호환되는 공개 API를 가지고 있다고 간주하며, 이 사양은 이 장의 코드와 여전히 컴파일될 최신 패치 릴리스를 얻을 수 있도록 보장합니다. 0.9.0 이상의 모든 버전은 다음 예제에서 사용하는 것과 동일한 API를 가지고 있다고 보장되지 않습니다.</p>
<p>이제 코드를 변경하지 않고, 목록 2-2와 같이 프로젝트를 빌드해 보겠습니다.</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
rm Cargo.lock
cargo clean
cargo build -->
<Listing number="2-2" caption="The output from running `cargo build` after adding the rand crate as a dependency">
<pre><code class="language-console">$ cargo build
    Updating crates.io index
     Locking 16 packages to latest compatible versions
      Adding wasi v0.11.0+wasi-snapshot-preview1 (latest: v0.13.3+wasi-0.2.2)
      Adding zerocopy v0.7.35 (latest: v0.8.9)
      Adding zerocopy-derive v0.7.35 (latest: v0.8.9)
  Downloaded syn v2.0.87
  Downloaded 1 crate (278.1 KB) in 0.16s
   Compiling proc-macro2 v1.0.89
   Compiling unicode-ident v1.0.13
   Compiling libc v0.2.161
   Compiling cfg-if v1.0.0
   Compiling byteorder v1.5.0
   Compiling getrandom v0.2.15
   Compiling rand_core v0.6.4
   Compiling quote v1.0.37
   Compiling syn v2.0.87
   Compiling zerocopy-derive v0.7.35
   Compiling zerocopy v0.7.35
   Compiling ppv-lite86 v0.2.20
   Compiling rand_chacha v0.3.1
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 3.69s
</code></pre>
</Listing>
<p>다른 버전 번호(하지만 SemVer 덕분에 모두 코드와 호환됩니다!)와 다른 줄(운영 체제에 따라 다름)이 표시될 수 있으며, 줄 순서가 다를 수 있습니다.</p>
<p>외부 의존성을 포함하면, Cargo는 해당 의존성이 필요로 하는 모든 것의 최신 버전을 _레지스트리_에서 가져옵니다. 레지스트리는 <a href="https://crates.io/">Crates.io</a>의 데이터 사본입니다. Crates.io는 러스트 생태계의 사람들이 다른 사람들이 사용할 수 있도록 오픈 소스 러스트 프로젝트를 게시하는 곳입니다.</p>
<p>레지스트리를 업데이트한 후, Cargo는 <code>[dependencies]</code> 섹션을 확인하고 아직 다운로드되지 않은 모든 크레이트를 다운로드합니다. 이 경우, 우리는 <code>rand</code>만 의존성으로 나열했지만, Cargo는 <code>rand</code>가 작동하는 데 의존하는 다른 크레이트도 가져왔습니다. 크레이트를 다운로드한 후, 러스트는 그것들을 컴파일한 다음 사용 가능한 의존성으로 프로젝트를 컴파일합니다.</p>
<p>변경 사항 없이 즉시 <code>cargo build</code>를 다시 실행하면, <code>Finished</code> 줄 외에는 아무런 출력도 얻지 못할 것입니다. Cargo는 이미 의존성을 다운로드하고 컴파일했으며, <em>Cargo.toml</em> 파일에서 의존성에 대해 아무것도 변경하지 않았다는 것을 알고 있습니다. Cargo는 또한 코드에 대해 아무것도 변경하지 않았다는 것을 알고 있으므로, 그것도 다시 컴파일하지 않습니다. 할 일이 없으면, 그냥 종료됩니다.</p>
<p><em>src/main.rs</em> 파일을 열고, 사소한 변경을 한 다음, 저장하고 다시 빌드하면, 두 줄의 출력만 보게 될 것입니다:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
touch src/main.rs
cargo build -->
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s
</code></pre>
<p>이 줄들은 Cargo가 <em>src/main.rs</em> 파일에 대한 작은 변경 사항으로만 빌드를 업데이트한다는 것을 보여줍니다. 의존성은 변경되지 않았으므로, Cargo는 이미 다운로드하고 컴파일한 것을 재사용할 수 있다는 것을 알고 있습니다.</p>
<h4 id="cargolock-파일로-재현-가능한-빌드-보장하기"><a class="header" href="#cargolock-파일로-재현-가능한-빌드-보장하기"><em>Cargo.lock</em> 파일로 재현 가능한 빌드 보장하기</a></h4>
<p>Cargo에는 당신이나 다른 사람이 코드를 빌드할 때마다 동일한 아티팩트를 다시 빌드할 수 있도록 보장하는 메커니즘이 있습니다: Cargo는 당신이 달리 명시할 때까지 지정한 의존성 버전만 사용합니다. 예를 들어, 다음 주에 <code>rand</code> 크레이트의 0.8.6 버전이 나오고, 그 버전에 중요한 버그 수정이 포함되어 있지만, 코드를 손상시키는 회귀도 포함되어 있다고 가정해 보겠습니다. 이를 처리하기 위해, 러스트는 <code>cargo build</code>를 처음 실행할 때 <em>Cargo.lock</em> 파일을 생성하므로, 이제 <em>guessing_game</em> 디렉토리에 이 파일이 있습니다.</p>
<p>프로젝트를 처음 빌드할 때, Cargo는 기준에 맞는 모든 의존성 버전을 파악한 다음 <em>Cargo.lock</em> 파일에 씁니다. 나중에 프로젝트를 빌드할 때, Cargo는 <em>Cargo.lock</em> 파일이 존재하는 것을 보고 버전 파악 작업을 다시 수행하는 대신 거기에 지정된 버전을 사용합니다. 이를 통해 자동으로 재현 가능한 빌드를 가질 수 있습니다. 즉, <em>Cargo.lock</em> 파일 덕분에 명시적으로 업그레이드할 때까지 프로젝트는 0.8.5 버전에 머물러 있을 것입니다. <em>Cargo.lock</em> 파일은 재현 가능한 빌드에 중요하기 때문에, 종종 프로젝트의 나머지 코드와 함께 소스 제어에 체크인됩니다.</p>
<h4 id="새-버전을-얻기-위해-크레이트-업데이트하기"><a class="header" href="#새-버전을-얻기-위해-크레이트-업데이트하기">새 버전을 얻기 위해 크레이트 업데이트하기</a></h4>
<p>크레이트를 업데이트하고 싶을 때, Cargo는 <code>update</code> 명령을 제공합니다. 이 명령은 <em>Cargo.lock</em> 파일을 무시하고 _Cargo.toml_의 사양에 맞는 모든 최신 버전을 파악합니다. 그런 다음 Cargo는 해당 버전을 <em>Cargo.lock</em> 파일에 씁니다. 이 경우, Cargo는 0.8.5보다 크고 0.9.0보다 작은 버전만 찾습니다. <code>rand</code> 크레이트가 0.8.6과 0.9.0이라는 두 가지 새 버전을 출시했다면, <code>cargo update</code>를 실행하면 다음과 같이 표시됩니다:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
cargo update
assuming there is a new 0.8.x version of rand; otherwise use another update
as a guide to creating the hypothetical output shown here -->
<pre><code class="language-console">$ cargo update
    Updating crates.io index
    Updating rand v0.8.5 -&gt; v0.8.6
</code></pre>
<p>Cargo는 0.9.0 릴리스를 무시합니다. 이 시점에서, 당신은 또한 <em>Cargo.lock</em> 파일에서 현재 사용하고 있는 <code>rand</code> 크레이트의 버전이 0.8.6이라는 변경 사항을 발견하게 될 것입니다. <code>rand</code> 버전 0.9.0 또는 0.9.<em>x</em> 시리즈의 버전을 사용하려면, 대신 <em>Cargo.toml</em> 파일을 다음과 같이 업데이트해야 합니다:</p>
<pre><code class="language-toml">[dependencies]
rand = "0.9.0"
</code></pre>
<p>다음에 <code>cargo build</code>를 실행하면, Cargo는 사용 가능한 크레이트의 레지스트리를 업데이트하고 지정한 새 버전에 따라 <code>rand</code> 요구 사항을 다시 평가합니다.</p>
<p><a href="https://doc.rust-lang.org/cargo/">Cargo</a><!-- ignore -->와 <a href="https://doc.rust-lang.org/cargo/reference/publishing.html">그 생태계</a><!-- ignore -->에 대해 할 말이 더 많지만, 14장에서 논의할 것이고, 지금은 이것만 알면 됩니다. Cargo는 라이브러리를 매우 쉽게 재사용할 수 있게 해주므로, 러스트 개발자들은 여러 패키지로 조립된 더 작은 프로젝트를 작성할 수 있습니다.</p>
<h3 id="난수-생성하기"><a class="header" href="#난수-생성하기">난수 생성하기</a></h3>
<p><code>rand</code>를 사용하여 추측할 숫자를 생성해 보겠습니다. 다음 단계는 목록 2-3과 같이 _src/main.rs_를 업데이트하는 것입니다.</p>
<Listing number="2-3" file-name="src/main.rs" caption="Adding code to generate a random number">
<pre><code class="language-rust ignore">use std::io;
use rand::Rng;

fn main() {
    println!("숫자를 맞춰보세요!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    println!("비밀 번호는: {secret_number}");

    println!(추측을 입력하세요.);

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("줄 읽기 실패");

    println!("당신의 추측: {guess}");
}</code></pre>
</Listing>
<p>먼저 <code>use rand::Rng;</code> 줄을 추가합니다. <code>Rng</code> 트레이트는 난수 생성기가 구현하는 메서드를 정의하며, 이 트레이트는 해당 메서드를 사용하기 위해 스코프 내에 있어야 합니다. 10장에서 트레이트에 대해 자세히 다룰 것입니다.</p>
<p>다음으로, 중간에 두 줄을 추가합니다. 첫 번째 줄에서는, 우리가 사용할 특정 난수 생성기를 제공하는 <code>rand::thread_rng</code> 함수를 호출합니다: 현재 실행 스레드에 로컬이며 운영 체제에 의해 시드됩니다. 그런 다음 난수 생성기에서 <code>gen_range</code> 메서드를 호출합니다. 이 메서드는 <code>use rand::Rng;</code> 문으로 스코프에 가져온 <code>Rng</code> 트레이트에 의해 정의됩니다. <code>gen_range</code> 메서드는 범위 표현식을 인수로 사용하고 범위 내에서 난수를 생성합니다. 여기서 사용하는 범위 표현식의 종류는 <code>start..=end</code> 형식을 취하며 하한과 상한을 포함하므로, 1에서 100 사이의 숫자를 요청하려면 <code>1..=100</code>을 지정해야 합니다.</p>
<blockquote>
<p>참고: 어떤 트레이트를 사용해야 하고, 어떤 메서드와 함수를 크레이트에서 호출해야 하는지 그냥 알 수는 없으므로, 각 크레이트에는 사용 지침이 포함된 문서가 있습니다. Cargo의 또 다른 멋진 기능은 <code>cargo doc --open</code> 명령을 실행하면 모든 의존성에서 제공하는 문서를 로컬에서 빌드하고 브라우저에서 열어준다는 것입니다. 예를 들어, <code>rand</code> 크레이트의 다른 기능에 관심이 있다면, <code>cargo doc --open</code>을 실행하고 왼쪽 사이드바에서 <code>rand</code>를 클릭하세요.</p>
</blockquote>
<p>두 번째 새 줄은 비밀 번호를 출력합니다. 이것은 프로그램을 개발하는 동안 테스트할 수 있도록 유용하지만, 최종 버전에서는 삭제할 것입니다. 프로그램이 시작하자마자 답을 출력하면 게임이 별로 재미없으니까요!</p>
<p>프로그램을 몇 번 실행해보세요:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-03/
cargo run
4
cargo run
5
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4

$ cargo run
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
</code></pre>
<p>다른 난수를 얻어야 하며, 모두 1에서 100 사이의 숫자여야 합니다. 잘했습니다!</p>
<h2 id="추측을-비밀-번호와-비교하기"><a class="header" href="#추측을-비밀-번호와-비교하기">추측을 비밀 번호와 비교하기</a></h2>
<p>이제 사용자 입력과 난수가 있으므로 비교할 수 있습니다. 그 단계는 목록 2-4에 나와 있습니다. 설명하겠지만, 이 코드는 아직 컴파일되지 않습니다.</p>
<Listing number="2-4" file-name="src/main.rs" caption="Handling the possible return values of comparing two numbers">
<pre><code class="language-rust ignore does_not_compile">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --생략--
<span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("비밀 번호는: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!(추측을 입력하세요.);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("줄 읽기 실패");
</span>
    println!("당신의 추측: {guess}");

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!("너무 작아요!"),
        Ordering::Greater =&gt; println!("너무 커요!"),
        Ordering::Equal =&gt; println!("당신이 이겼습니다!"),
    }
}</code></pre>
</Listing>
<p>먼저 또 다른 <code>use</code> 문을 추가하여, 표준 라이브러리에서 <code>std::cmp::Ordering</code>이라는 타입을 스코프로 가져옵니다. <code>Ordering</code> 타입은 또 다른 열거형이며 <code>Less</code>, <code>Greater</code>, <code>Equal</code> variant를 가집니다. 이것들은 두 값을 비교할 때 가능한 세 가지 결과입니다.</p>
<p>그런 다음 <code>Ordering</code> 타입을 사용하는 다섯 줄의 새 코드를 맨 아래에 추가합니다. <code>cmp</code> 메서드는 두 값을 비교하며, 비교할 수 있는 모든 것에서 호출할 수 있습니다. 비교하려는 대상에 대한 참조를 인수로 받습니다: 여기서는 <code>guess</code>를 <code>secret_number</code>와 비교합니다. 그런 다음 <code>use</code> 문으로 스코프에 가져온 <code>Ordering</code> 열거형의 variant를 반환합니다. <code>guess</code>와 <code>secret_number</code>의 값으로 <code>cmp</code>를 호출하여 반환된 <code>Ordering</code>의 variant에 따라 다음에 무엇을 할지 결정하기 위해 <a href="ch06-02-match.html"><code>match</code></a><!-- ignore --> 표현식을 사용합니다.</p>
<p><code>match</code> 표현식은 _arm_으로 구성됩니다. arm은 매치할 _패턴_과 <code>match</code>에 주어진 값이 해당 arm의 패턴에 맞을 경우 실행되어야 하는 코드로 구성됩니다. 러스트는 <code>match</code>에 주어진 값을 가져와 각 arm의 패턴을 차례로 살펴봅니다. 패턴과 <code>match</code> 구조는 강력한 러스트 기능입니다: 코드가 마주칠 수 있는 다양한 상황을 표현할 수 있게 해주며, 모든 상황을 처리하도록 보장합니다. 이러한 기능은 각각 6장과 19장에서 자세히 다룰 것입니다.</p>
<p>여기서 사용하는 <code>match</code> 표현식의 예를 살펴보겠습니다. 사용자가 50을 추측했고 이번에 무작위로 생성된 비밀 번호가 38이라고 가정해 보겠습니다.</p>
<p>코드가 50을 38과 비교할 때, <code>cmp</code> 메서드는 50이 38보다 크기 때문에 <code>Ordering::Greater</code>를 반환합니다. <code>match</code> 표현식은 <code>Ordering::Greater</code> 값을 얻고 각 arm의 패턴을 확인하기 시작합니다. 첫 번째 arm의 패턴인 <code>Ordering::Less</code>를 보고, <code>Ordering::Greater</code> 값이 <code>Ordering::Less</code>와 일치하지 않음을 확인하고, 해당 arm의 코드를 무시하고 다음 arm으로 이동합니다. 다음 arm의 패턴은 <code>Ordering::Greater</code>이며, 이는 <code>Ordering::Greater</code>와 <em>일치합니다</em>! 해당 arm의 연관 코드가 실행되고 화면에 <code>Too big!</code>을 출력합니다. <code>match</code> 표현식은 첫 번째 성공적인 매치 후에 종료되므로, 이 시나리오에서는 마지막 arm을 보지 않습니다.</p>
<p>그러나 목록 2-4의 코드는 아직 컴파일되지 않습니다. 시도해 보겠습니다:</p>
<!--
The error numbers in this output should be that of the code **WITHOUT** the
anchor or snip comments
-->
<pre><code class="language-console">$ cargo build
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_core v0.6.2
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
   --&gt; src/main.rs:22:21
    |
22  |     match guess.cmp(&amp;secret_number) {
    |                 --- ^^^^^^^^^^^^^^ expected `&amp;String`, found `&amp;{integer}`
    |                 |
    |                 arguments to this method are incorrect
    |
    = note: expected reference `&amp;String`
               found reference `&amp;{integer}`
note: method defined here
   --&gt; file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/core/src/cmp.rs:838:8
    |
838 |     fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering;
    |        ^^^

For more information about this error, try `rustc --explain E0308`.
error: could not compile `guessing_game` (bin "guessing_game") due to 1 previous error
</code></pre>
<p>오류의 핵심은 _일치하지 않는 타입_이 있다는 것입니다. 러스트는 강력한 정적 타입 시스템을 가지고 있습니다. 그러나 타입 추론도 가지고 있습니다. <code>let mut guess = String::new()</code>를 작성했을 때, 러스트는 <code>guess</code>가 <code>String</code>이어야 한다고 추론할 수 있었고, 우리가 타입을 작성하도록 강요하지 않았습니다. 반면에 <code>secret_number</code>는 숫자 타입입니다. 러스트의 몇 가지 숫자 타입은 1에서 100 사이의 값을 가질 수 있습니다: <code>i32</code>, 32비트 숫자; <code>u32</code>, 부호 없는 32비트 숫자; <code>i64</code>, 64비트 숫자; 등등. 달리 명시하지 않는 한, 러스트는 <code>i32</code>를 기본값으로 사용하며, 다른 곳에서 러스트가 다른 숫자 타입을 추론하도록 하는 타입 정보를 추가하지 않는 한 <code>secret_number</code>의 타입입니다. 오류의 이유는 러스트가 문자열과 숫자 타입을 비교할 수 없기 때문입니다.</p>
<p>궁극적으로, 프로그램이 입력으로 읽는 <code>String</code>을 숫자 타입으로 변환하여 비밀 번호와 숫자로 비교하고 싶습니다. <code>main</code> 함수 본문에 이 줄을 추가하여 그렇게 합니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("비밀 번호는: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!(추측을 입력하세요.);
</span><span class="boring">
</span>    // --생략--

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("줄 읽기 실패");

    let guess: u32 = guess.trim().parse().expect("숫자를 입력해주세요!");

    println!("당신의 추측: {guess}");

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!("너무 작아요!"),
        Ordering::Greater =&gt; println!("너무 커요!"),
        Ordering::Equal =&gt; println!("당신이 이겼습니다!"),
    }
<span class="boring">}</span></code></pre>
<p>해당 줄은 다음과 같습니다:</p>
<pre><code class="language-rust ignore">let guess: u32 = guess.trim().parse().expect("숫자를 입력해주세요!");</code></pre>
<p><code>guess</code>라는 이름의 변수를 만듭니다. 하지만 잠깐, 프로그램에 이미 <code>guess</code>라는 이름의 변수가 있지 않나요? 그렇습니다. 하지만 고맙게도 러스트는 이전 <code>guess</code> 값을 새 값으로 섀도잉할 수 있도록 허용합니다. _섀도잉_을 사용하면 예를 들어 <code>guess_str</code>과 <code>guess</code>와 같이 두 개의 고유한 변수를 만들도록 강요하는 대신 <code>guess</code> 변수 이름을 재사용할 수 있습니다. 이에 대해서는 <a href="ch03-01-variables-and-mutability.html#shadowing">3장</a><!-- ignore -->에서 더 자세히 다룰 것이지만, 지금은 이 기능이 한 타입의 값을 다른 타입으로 변환하고 싶을 때 자주 사용된다는 점만 알아두세요.</p>
<p>우리는 이 새로운 변수를 <code>guess.trim().parse()</code> 표현식에 바인딩합니다. 표현식의 <code>guess</code>는 입력값을 문자열로 담고 있던 원래 <code>guess</code> 변수를 가리킵니다. <code>String</code> 인스턴스의 <code>trim</code> 메서드는 시작과 끝의 모든 공백을 제거합니다. 이는 문자열을 숫자 데이터만 담을 수 있는 <code>u32</code>로 변환하기 전에 반드시 해야 하는 작업입니다. 사용자가 <code>read_line</code>을 만족시키고 추측값을 입력하려면 <kbd>enter</kbd>를 눌러야 하는데, 이때 문자열에 줄바꿈 문자가 추가됩니다. 예를 들어, 사용자가 <kbd>5</kbd>를 입력하고 <kbd>enter</kbd>를 누르면 <code>guess</code>는 <code>5\n</code>과 같이 보입니다. <code>\n</code>은 '줄바꿈'을 나타냅니다. (윈도우에서 <kbd>enter</kbd>를 누르면 캐리지 리턴과 줄바꿈인 <code>\r\n</code>이 발생합니다.) <code>trim</code> 메서드는 <code>\n</code> 또는 <code>\r\n</code>을 제거하여 딱 <code>5</code>만 남게 합니다.</p>
<p>문자열의 <a href="../std/primitive.str.html#method.parse"><code>parse</code> 메서드</a><!-- ignore -->는 문자열을 다른 타입으로 변환합니다. 여기서는 문자열을 숫자로 변환하는 데 사용합니다. <code>let guess: u32</code>를 사용하여 러스트에게 우리가 원하는 정확한 숫자 타입을 알려줄 필요가 있습니다. <code>guess</code> 뒤의 콜론(<code>:</code>)은 변수의 타입을 어노테이션할 것임을 러스트에게 알려줍니다. 러스트에는 몇 가지 내장된 숫자 타입이 있습니다. 여기서 보는 <code>u32</code>는 부호 없는 32비트 정수입니다. 이는 작은 양수에 대한 좋은 기본 선택입니다. <a href="ch03-02-data-types.html#integer-types">3장</a><!-- ignore -->에서 다른 숫자 타입에 대해 배우게 될 것입니다.</p>
<p>또한 이 예제 프로그램의 <code>u32</code> 어노테이션과 <code>secret_number</code>와의 비교는 러스트가 <code>secret_number</code> 역시 <code>u32</code>여야 한다고 추론하게 함을 의미합니다. 따라서 이제 동일한 타입의 두 값 사이의 비교가 이루어집니다!</p>
<p><code>parse</code> 메서드는 논리적으로 숫자로 변환될 수 있는 문자에 대해서만 작동하므로 에러가 발생하기 쉽습니다. 예를 들어, 문자열에 <code>A👍%</code>가 포함되어 있다면 이를 숫자로 변환할 방법이 없습니다. 실패할 수 있기 때문에 <code>parse</code> 메서드는 <code>read_line</code> 메서드와 마찬가지로 <code>Result</code> 타입을 반환합니다 (앞서 <a href="ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-result">“<code>Result</code>로 잠재적 실패 다루기”</a><!-- ignore -->에서 논의했습니다). 우리는 <code>expect</code> 메서드를 다시 사용하여 이 <code>Result</code>를 동일한 방식으로 다룰 것입니다. 문자열에서 숫자를 만들 수 없어 <code>parse</code>가 <code>Err</code> <code>Result</code> 변리언트를 반환하면, <code>expect</code> 호출은 게임을 중단시키고 우리가 제공한 메시지를 출력할 것입니다. <code>parse</code>가 문자열을 숫자로 성공적으로 변환할 수 있으면 <code>Result</code>의 <code>Ok</code> 변리언트를 반환할 것이고, <code>expect</code>는 <code>Ok</code> 값에서 우리가 원하는 숫자를 반환할 것입니다.</p>
<p>이제 프로그램을 실행해 봅시다:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/
touch src/main.rs
cargo run
  76
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.26s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
</code></pre>
<p>좋아요! 추측 앞에 공백이 추가되었음에도 불구하고, 프로그램은 사용자가 76을 추측했다는 것을 알아냈습니다. 프로그램을 몇 번 실행하여 다른 종류의 입력에 대한 다른 동작을 확인하세요: 숫자를 정확하게 추측하고, 너무 높은 숫자를 추측하고, 너무 낮은 숫자를 추측하세요.</p>
<p>이제 대부분의 게임이 작동하지만, 사용자는 한 번만 추측할 수 있습니다. 반복문을 추가하여 그것을 변경해 봅시다!</p>
<h2 id="반복문으로-여러-번-추측-허용하기"><a class="header" href="#반복문으로-여러-번-추측-허용하기">반복문으로 여러 번 추측 허용하기</a></h2>
<p><code>loop</code> 키워드는 무한 루프를 만듭니다. 사용자가 숫자를 추측할 기회를 더 많이 주기 위해 루프를 추가할 것입니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    // --생략--

    println!("비밀 번호는: {secret_number}");

    loop {
        println!(추측을 입력하세요.);

        // --생략--

<span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("줄 읽기 실패");
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect("숫자를 입력해주세요!");
</span><span class="boring">
</span><span class="boring">        println!("당신의 추측: {guess}");
</span><span class="boring">
</span>        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("너무 작아요!"),
            Ordering::Greater =&gt; println!("너무 커요!"),
            Ordering::Equal =&gt; println!("당신이 이겼습니다!"),
        }
    }
}</code></pre>
<p>보시다시피, 추측 입력 프롬프트부터 모든 것을 루프 안으로 옮겼습니다. 루프 안의 줄들을 각각 네 칸씩 더 들여쓰고 프로그램을 다시 실행하세요. 이제 프로그램은 영원히 다른 추측을 요구할 것이며, 이는 실제로 새로운 문제를 야기합니다. 사용자가 종료할 수 없는 것 같습니다!</p>
<p>사용자는 언제든지 키보드 단축키 <kbd>ctrl</kbd>-<kbd>c</kbd>를 사용하여 프로그램을 중단할 수 있습니다. 하지만 <a href="ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">“추측을 비밀 번호와 비교하기”</a><!-- ignore -->의 <code>parse</code> 논의에서 언급했듯이, 이 끈질긴 괴물에서 벗어날 수 있는 또 다른 방법이 있습니다: 사용자가 숫자가 아닌 답변을 입력하면 프로그램이 종료(크래시)되는 것입니다. 여기 보이는 것처럼 이를 이용하여 사용자가 종료할 수 있도록 할 수 있습니다:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-04-looping/
touch src/main.rs
cargo run
(too small guess)
(too big guess)
(correct guess)
quit
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.23s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/main.rs:28:47
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p><code>quit</code>을 입력하면 게임이 종료되지만, 눈치채셨겠지만, 다른 숫자가 아닌 입력을 입력해도 마찬가지입니다. 이것은 좋지 않은 방법입니다. 우리는 정답을 맞췄을 때도 게임이 멈추기를 원합니다.</p>
<h3 id="정답-맞춘-후-종료하기"><a class="header" href="#정답-맞춘-후-종료하기">정답 맞춘 후 종료하기</a></h3>
<p><code>break</code> 문을 추가하여 사용자가 이겼을 때 게임이 종료되도록 프로그래밍해 봅시다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("비밀 번호는: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(추측을 입력하세요.);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("줄 읽기 실패");
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect("숫자를 입력해주세요!");
</span><span class="boring">
</span><span class="boring">        println!("당신의 추측: {guess}");
</span><span class="boring">
</span>        // --생략--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("너무 작아요!"),
            Ordering::Greater =&gt; println!("너무 커요!"),
            Ordering::Equal =&gt; {
                println!("당신이 이겼습니다!");
                break;
            }
        }
    }
}</code></pre>
<p><code>You win!</code> 뒤에 <code>break</code> 줄을 추가하면 사용자가 비밀 번호를 정확하게 추측했을 때 프로그램이 루프를 종료합니다. 루프를 종료하는 것은 또한 프로그램을 종료하는 것을 의미합니다. 왜냐하면 루프는 <code>main</code>의 마지막 부분이기 때문입니다.</p>
<h3 id="잘못된-입력-처리하기"><a class="header" href="#잘못된-입력-처리하기">잘못된 입력 처리하기</a></h3>
<p>게임의 동작을 더욱 개선하기 위해, 사용자가 숫자가 아닌 값을 입력했을 때 프로그램을 충돌시키는 대신, 게임이 숫자가 아닌 값을 무시하도록 하여 사용자가 계속 추측할 수 있도록 만들어 봅시다. 목록 2-5와 같이 <code>guess</code>가 <code>String</code>에서 <code>u32</code>로 변환되는 줄을 변경하여 그렇게 할 수 있습니다.</p>
<Listing number="2-5" file-name="src/main.rs" caption="Ignoring a non-number guess and asking for another guess instead of crashing the program">
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("비밀 번호는: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(추측을 입력하세요.);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span>        // --생략--

        io::stdin()
            .read_line(&amp;mut guess)
            .expect("줄 읽기 실패");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!("당신의 추측: {guess}");

        // --생략--
<span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!("너무 작아요!"),
</span><span class="boring">            Ordering::Greater =&gt; println!("너무 커요!"),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!("당신이 이겼습니다!");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>오류 발생 시 충돌하는 것에서 오류를 처리하는 것으로 이동하기 위해 <code>expect</code> 호출에서 <code>match</code> 표현식으로 전환합니다. <code>parse</code>가 <code>Result</code> 타입을 반환하고 <code>Result</code>가 <code>Ok</code>와 <code>Err</code> variant를 갖는 열거형임을 기억하세요. <code>cmp</code> 메서드의 <code>Ordering</code> 결과와 마찬가지로 여기서도 <code>match</code> 표현식을 사용하고 있습니다.</p>
<p><code>parse</code>가 문자열을 숫자로 성공적으로 변환할 수 있으면, 결과 숫자를 포함하는 <code>Ok</code> 값을 반환합니다. 해당 <code>Ok</code> 값은 첫 번째 arm의 패턴과 일치하며, <code>match</code> 표현식은 <code>parse</code>가 생성하여 <code>Ok</code> 값 안에 넣은 <code>num</code> 값을 반환합니다. 그 숫자는 우리가 생성하는 새 <code>guess</code> 변수에서 원하는 바로 그 위치에 있게 됩니다.</p>
<p><code>parse</code>가 문자열을 숫자로 변환할 수 <em>없는</em> 경우, 오류에 대한 자세한 정보가 포함된 <code>Err</code> 값을 반환합니다. <code>Err</code> 값은 첫 번째 <code>match</code> arm의 <code>Ok(num)</code> 패턴과 일치하지 않지만, 두 번째 arm의 <code>Err(_)</code> 패턴과 일치합니다. 밑줄 <code>_</code>는 모든 것을 포괄하는 값입니다. 이 예에서는 내부에 어떤 정보가 있든 모든 <code>Err</code> 값과 일치시키고 싶다고 말하는 것입니다. 따라서 프로그램은 두 번째 arm의 코드인 <code>continue</code>를 실행하며, 이는 프로그램에게 <code>loop</code>의 다음 반복으로 이동하여 다른 추측을 요청하도록 지시합니다. 따라서 효과적으로 프로그램은 <code>parse</code>가 마주칠 수 있는 모든 오류를 무시합니다!</p>
<p>이제 프로그램의 모든 것이 예상대로 작동해야 합니다. 시도해 보겠습니다:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-05/
cargo run
(too small guess)
(too big guess)
foo
(correct guess)
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
</code></pre>
<p>멋지네요! 마지막으로 작은 수정 하나만 더 하면 추측 게임을 완성할 수 있습니다. 프로그램이 여전히 비밀 번호를 출력하고 있다는 것을 기억하세요. 테스트에는 효과적이었지만, 게임의 재미를 망칩니다. 비밀 번호를 출력하는 <code>println!</code>을 삭제합시다. 목록 2-6은 최종 코드를 보여줍니다.</p>
<Listing number="2-6" file-name="src/main.rs" caption="Complete guessing game code">
<pre><code class="language-rust ignore">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!("숫자를 맞춰보세요!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    loop {
        println!(추측을 입력하세요.);

        let mut guess = String::new();

        io::stdin()
            .read_line(&amp;mut guess)
            .expect("줄 읽기 실패");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!("당신의 추측: {guess}");

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("너무 작아요!"),
            Ordering::Greater =&gt; println!("너무 커요!"),
            Ordering::Equal =&gt; {
                println!("당신이 이겼습니다!");
                break;
            }
        }
    }
}</code></pre>
</Listing>
<p>이 시점에서, 당신은 성공적으로 추측 게임을 만들었습니다. 축하합니다!</p>
<h2 id="요약-1"><a class="header" href="#요약-1">요약</a></h2>
<p>이 프로젝트는 <code>let</code>, <code>match</code>, 함수, 외부 크레이트 사용 등 많은 새로운 러스트 개념을 소개하는 실습 방법이었습니다. 다음 몇 장에서는 이러한 개념에 대해 더 자세히 배울 것입니다. 3장에서는 변수, 데이터 타입, 함수와 같이 대부분의 프로그래밍 언어가 가지고 있는 개념을 다루고, 러스트에서 사용하는 방법을 보여줍니다. 4장에서는 러스트를 다른 언어와 다르게 만드는 기능인 소유권을 탐구합니다. 5장에서는 구조체와 메서드 구문을 논의하고, 6장에서는 열거형이 어떻게 작동하는지 설명합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="일반적인-프로그래밍-개념"><a class="header" href="#일반적인-프로그래밍-개념">일반적인 프로그래밍 개념</a></h1>
<p>이 장에서는 거의 모든 프로그래밍 언어에 나타나는 개념과 러스트에서 어떻게 작동하는지 다룹니다. 많은 프로그래밍 언어는 핵심적으로 많은 공통점을 가지고 있습니다. 이 장에서 제시된 개념 중 어느 것도 러스트에만 고유한 것은 아니지만, 러스트의 맥락에서 논의하고 이러한 개념을 사용하는 관례에 대해 설명할 것입니다.</p>
<p>구체적으로, 변수, 기본 타입, 함수, 주석, 제어 흐름에 대해 배울 것입니다. 이러한 기초는 모든 러스트 프로그램에 있으며, 일찍 배우면 강력한 핵심을 가지고 시작할 수 있습니다.</p>
<blockquote>
<h4 id="키워드"><a class="header" href="#키워드">키워드</a></h4>
<p>러스트 언어는 다른 언어와 마찬가지로 언어에서만 사용하도록 예약된 <em>키워드</em> 세트를 가지고 있습니다. 이러한 단어는 변수나 함수의 이름으로 사용할 수 없다는 점을 명심하세요. 대부분의 키워드는 특별한 의미를 가지며, 러스트 프로그램에서 다양한 작업을 수행하는 데 사용됩니다. 몇몇은 현재 관련 기능이 없지만 나중에 러스트에 추가될 수 있는 기능을 위해 예약되어 있습니다. 키워드 목록은 <a href="appendix-01-keywords.html">부록 A</a><!-- ignore -->에서 찾을 수 있습니다.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="변수와-가변성"><a class="header" href="#변수와-가변성">변수와 가변성</a></h2>
<p><a href="ch02-00-guessing-game-tutorial.html#storing-values-with-variables">“변수로 값 저장하기”</a><!-- ignore --> 섹션에서 언급했듯이, 기본적으로 변수는 불변입니다. 이것은 러스트가 제공하는 안전성과 쉬운 동시성을 활용하는 방식으로 코드를 작성하도록 유도하는 많은 유인책 중 하나입니다. 그러나 변수를 가변으로 만들 수 있는 옵션도 있습니다. 러스트가 왜 불변성을 선호하도록 권장하는지, 그리고 때로는 왜 그것을 선택하지 않을 수 있는지 살펴보겠습니다.</p>
<p>변수가 불변일 때, 값이 이름에 바인딩되면 그 값을 변경할 수 없습니다. 이를 설명하기 위해, <code>cargo new variables</code>를 사용하여 <em>projects</em> 디렉토리에 _variables_라는 새 프로젝트를 생성하세요.</p>
<p>그런 다음, 새 <em>variables</em> 디렉토리에서 _src/main.rs_를 열고, 아직 컴파일되지 않는 다음 코드로 내용을 교체하세요:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    println!("x의 값은: {x}");
    x = 6;
    println!("x의 값은: {x}");
}</code></pre>
<p><code>cargo run</code>을 사용하여 프로그램을 저장하고 실행하세요. 이 출력과 같이 불변성 오류에 대한 오류 메시지를 받아야 합니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         - first assignment to `x`
3 |     println!("The value of x is: {x}");
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable
  |
help: consider making this binding mutable
  |
2 |     let mut x = 5;
  |         +++

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` (bin "variables") due to 1 previous error
</code></pre>
<p>이 예는 컴파일러가 프로그램에서 오류를 찾는 데 어떻게 도움이 되는지 보여줍니다. 컴파일러 오류는 답답할 수 있지만, 실제로는 프로그램이 아직 원하는 작업을 안전하게 수행하지 못하고 있다는 의미일 뿐입니다. 당신이 좋은 프로그래머가 아니라는 의미는 <em>아닙니다</em>! 숙련된 러스트 개발자도 여전히 컴파일러 오류를 받습니다.</p>
<p>불변 변수 <code>x</code>에 두 번 할당할 수 없다는 오류 메시지를 받았습니다. 왜냐하면 불변 <code>x</code> 변수에 두 번째 값을 할당하려고 했기 때문입니다.</p>
<p>불변으로 지정된 값을 변경하려고 할 때 컴파일 타임 오류가 발생하는 것이 중요합니다. 왜냐하면 바로 이 상황이 버그로 이어질 수 있기 때문입니다. 코드의 한 부분이 값이 절대 변경되지 않을 것이라는 가정 하에 작동하고 다른 부분이 그 값을 변경하면, 코드의 첫 번째 부분이 의도한 대로 작동하지 않을 수 있습니다. 이런 종류의 버그의 원인은 사후에 추적하기 어려울 수 있으며, 특히 두 번째 코드가 값을 _때때로_만 변경하는 경우에는 더욱 그렇습니다. 러스트 컴파일러는 값이 변경되지 않을 것이라고 명시하면, 실제로 변경되지 않을 것임을 보장하므로, 직접 추적할 필요가 없습니다. 따라서 코드를 더 쉽게 추론할 수 있습니다.</p>
<p>하지만 가변성은 매우 유용할 수 있으며, 코드를 더 편리하게 작성할 수 있게 해줍니다. 변수는 기본적으로 불변이지만, <a href="ch02-00-guessing-game-tutorial.html#storing-values-with-variables">2장</a><!-- ignore -->에서 했던 것처럼 변수 이름 앞에 <code>mut</code>를 추가하여 가변으로 만들 수 있습니다. <code>mut</code>를 추가하면 코드의 다른 부분이 이 변수의 값을 변경할 것임을 나타내어 코드의 미래 독자에게 의도를 전달합니다.</p>
<p>예를 들어, _src/main.rs_를 다음과 같이 변경해 보겠습니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut x = 5;
    println!("x의 값은: {x}");
    x = 6;
    println!("x의 값은: {x}");
}</code></pre></pre>
<p>이제 프로그램을 실행하면 다음과 같은 결과를 얻습니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
</code></pre>
<p><code>mut</code>를 사용하면 <code>x</code>에 바인딩된 값을 <code>5</code>에서 <code>6</code>으로 변경할 수 있습니다. 궁극적으로, 가변성을 사용할지 여부는 당신에게 달려 있으며, 특정 상황에서 무엇이 가장 명확하다고 생각하는지에 따라 달라집니다.</p>
<h3 id="상수"><a class="header" href="#상수">상수</a></h3>
<p>불변 변수와 마찬가지로, _상수_는 이름에 바인딩되고 변경이 허용되지 않는 값이지만, 상수와 변수 사이에는 몇 가지 차이점이 있습니다.</p>
<p>첫째, 상수에 <code>mut</code>를 사용할 수 없습니다. 상수는 기본적으로 불변일 뿐만 아니라 항상 불변입니다. <code>let</code> 키워드 대신 <code>const</code> 키워드를 사용하여 상수를 선언하며, 값의 타입은 <em>반드시</em> 명시해야 합니다. 타입과 타입 명시에 대해서는 다음 섹션인 <a href="ch03-02-data-types.html#data-types">“데이터 타입”</a><!-- ignore -->에서 다룰 것이므로, 지금은 세부 사항에 대해 걱정하지 마세요. 항상 타입을 명시해야 한다는 것만 알아두세요.</p>
<p>상수는 전역 스코프를 포함한 모든 스코프에서 선언할 수 있으므로, 코드의 여러 부분에서 알아야 할 값에 유용합니다.</p>
<p>마지막 차이점은 상수는 런타임에만 계산할 수 있는 값의 결과가 아닌, 상수 표현식에만 설정할 수 있다는 것입니다.</p>
<p>다음은 상수 선언의 예입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
<span class="boring">}</span></code></pre></pre>
<p>상수의 이름은 <code>THREE_HOURS_IN_SECONDS</code>이고 그 값은 60(1분의 초)에 60(1시간의 분)을 곱하고 3(이 프로그램에서 계산하려는 시간)을 곱한 결과로 설정됩니다. 러스트의 상수 명명 규칙은 단어 사이에 밑줄을 사용하여 모두 대문자로 사용하는 것입니다. 컴파일러는 컴파일 타임에 제한된 연산 집합을 평가할 수 있으므로, 이 상수를 10,800 값으로 설정하는 대신 더 이해하고 확인하기 쉬운 방식으로 이 값을 작성하도록 선택할 수 있습니다. 상수를 선언할 때 사용할 수 있는 연산에 대한 자세한 내용은 <a href="../reference/const_eval.html">러스트 참조의 상수 평가 섹션</a>을 참조하세요.</p>
<p>상수는 선언된 스코프 내에서 프로그램이 실행되는 전체 시간 동안 유효합니다. 이 속성은 상수를 게임 플레이어가 얻을 수 있는 최대 점수나 빛의 속도와 같이 프로그램의 여러 부분에서 알아야 할 애플리케이션 도메인의 값에 유용하게 만듭니다.</p>
<p>프로그램 전체에서 사용되는 하드코딩된 값을 상수로 명명하는 것은 해당 값의 의미를 코드의 미래 유지보수자에게 전달하는 데 유용합니다. 또한 나중에 하드코딩된 값을 업데이트해야 할 경우 변경해야 할 코드가 한 곳에만 있도록 도와줍니다.</p>
<h3 id="섀도잉"><a class="header" href="#섀도잉">섀도잉</a></h3>
<p><a href="ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">2장</a><!-- ignore -->의 추측 게임 튜토리얼에서 보았듯이, 이전 변수와 동일한 이름으로 새 변수를 선언할 수 있습니다. 러스트 개발자들은 첫 번째 변수가 두 번째 변수에 의해 _섀도잉_되었다고 말하는데, 이는 변수 이름을 사용할 때 컴파일러가 보게 될 것이 두 번째 변수라는 것을 의미합니다. 사실상, 두 번째 변수는 첫 번째 변수를 가리고, 변수 이름의 모든 사용을 스스로 가져가거나 스코프가 끝날 때까지 가져갑니다. 다음과 같이 동일한 변수 이름을 사용하고 <code>let</code> 키워드를 반복 사용하여 변수를 섀도잉할 수 있습니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("내부 스코프에서 x의 값은: {x}");
    }

    println!("x의 값은: {x}");
}</code></pre></pre>
<p>이 프로그램은 먼저 <code>x</code>를 <code>5</code> 값에 바인딩합니다. 그런 다음 <code>let x =</code>를 반복하여 새 변수 <code>x</code>를 만들고, 원래 값에 <code>1</code>을 더하여 <code>x</code>의 값을 <code>6</code>으로 만듭니다. 그런 다음, 중괄호로 생성된 내부 스코프 내에서 세 번째 <code>let</code> 문도 <code>x</code>를 섀도잉하고 새 변수를 만들어 이전 값에 <code>2</code>를 곱하여 <code>x</code>에 <code>12</code> 값을 부여합니다. 해당 스코프가 끝나면 내부 섀도잉이 끝나고 <code>x</code>는 <code>6</code>으로 돌아갑니다. 이 프로그램을 실행하면 다음과 같이 출력됩니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
The value of x in the inner scope is: 12
The value of x is: 6
</code></pre>
<p>섀도잉은 변수를 <code>mut</code>로 표시하는 것과 다릅니다. 왜냐하면 <code>let</code> 키워드를 사용하지 않고 이 변수에 실수로 다시 할당하려고 하면 컴파일 타임 오류가 발생하기 때문입니다. <code>let</code>을 사용하면 값에 몇 가지 변환을 수행할 수 있지만, 해당 변환이 완료된 후에는 변수가 불변이 됩니다.</p>
<p><code>mut</code>와 섀도잉의 또 다른 차이점은 <code>let</code> 키워드를 다시 사용할 때 효과적으로 새 변수를 생성하기 때문에 값의 타입을 변경하면서도 동일한 이름을 재사용할 수 있다는 것입니다. 예를 들어, 프로그램이 사용자에게 일부 텍스트 사이에 원하는 공백 수를 공백 문자를 입력하여 표시하도록 요청한 다음, 해당 입력을 숫자로 저장하고 싶다고 가정해 보겠습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let spaces = "   ";
    let spaces = spaces.len();
<span class="boring">}</span></code></pre></pre>
<p>첫 번째 <code>spaces</code> 변수는 문자열 타입이고 두 번째 <code>spaces</code> 변수는 숫자 타입입니다. 따라서 섀도잉은 <code>spaces_str</code>과 <code>spaces_num</code>과 같이 다른 이름을 생각해 낼 필요 없이 더 간단한 <code>spaces</code> 이름을 재사용할 수 있게 해줍니다. 그러나 여기에 표시된 것처럼 <code>mut</code>를 사용하려고 하면 컴파일 타임 오류가 발생합니다:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut spaces = "   ";
    spaces = spaces.len();
<span class="boring">}</span></code></pre>
<p>오류는 변수의 타입을 변경할 수 없다고 말합니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 --&gt; src/main.rs:3:14
  |
2 |     let mut spaces = "   ";
  |                      ----- expected due to this value
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&amp;str`, found `usize`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `variables` (bin "variables") due to 1 previous error
</code></pre>
<p>이제 변수가 어떻게 작동하는지 살펴보았으니, 변수가 가질 수 있는 더 많은 데이터 타입을 살펴보겠습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="데이터-타입"><a class="header" href="#데이터-타입">데이터 타입</a></h2>
<p>러스트의 모든 값은 특정 _데이터 타입_을 가지며, 이는 러스트에게 어떤 종류의 데이터가 지정되었는지 알려주어 해당 데이터를 어떻게 처리해야 하는지 알 수 있도록 합니다. 우리는 두 가지 데이터 타입 하위 집합인 스칼라와 복합을 살펴볼 것입니다.</p>
<p>러스트는 <em>정적 타입</em> 언어라는 점을 명심하세요. 즉, 컴파일 타임에 모든 변수의 타입을 알아야 합니다. 컴파일러는 일반적으로 값과 사용 방식을 기반으로 우리가 사용하려는 타입을 추론할 수 있습니다. 2장의 <a href="ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">“추측을 비밀 번호와 비교하기”</a><!-- ignore --> 섹션에서 <code>parse</code>를 사용하여 <code>String</code>을 숫자 타입으로 변환했을 때와 같이 여러 타입이 가능한 경우, 다음과 같이 타입 명시를 추가해야 합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let guess: u32 = "42".parse().expect("숫자가 아닙니다!");
<span class="boring">}</span></code></pre></pre>
<p>앞의 코드에 표시된 <code>: u32</code> 타입 명시를 추가하지 않으면, 러스트는 다음 오류를 표시합니다. 이는 컴파일러가 우리가 사용하려는 타입을 알기 위해 더 많은 정보가 필요하다는 것을 의미합니다:</p>
<pre><code class="language-console">$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0284]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^        ----- type must be known at this point
  |
  = note: cannot satisfy `&lt;_ as FromStr&gt;::Err == _`
help: consider giving `guess` an explicit type
  |
2 |     let guess: /* Type */ = "42".parse().expect("Not a number!");
  |              ++++++++++++

For more information about this error, try `rustc --explain E0284`.
error: could not compile `no_type_annotations` (bin "no_type_annotations") due to 1 previous error
</code></pre>
<p>다른 데이터 타입에 대한 다른 타입 명시를 보게 될 것입니다.</p>
<h3 id="스칼라-타입"><a class="header" href="#스칼라-타입">스칼라 타입</a></h3>
<p><em>스칼라</em> 타입은 단일 값을 나타냅니다. 러스트에는 정수, 부동소수점 숫자, 불리언, 문자의 네 가지 기본 스칼라 타입이 있습니다. 다른 프로그래밍 언어에서 이것들을 본 적이 있을 것입니다. 러스트에서 어떻게 작동하는지 살펴보겠습니다.</p>
<h4 id="정수-타입"><a class="header" href="#정수-타입">정수 타입</a></h4>
<p>_정수_는 소수 부분이 없는 숫자입니다. 2장에서 <code>u32</code> 타입이라는 한 가지 정수 타입을 사용했습니다. 이 타입 선언은 연관된 값이 32비트 공간을 차지하는 부호 없는 정수(부호 있는 정수 타입은 <code>u</code> 대신 <code>i</code>로 시작)여야 함을 나타냅니다. 표 3-1은 러스트의 내장 정수 타입을 보여줍니다. 이러한 variant 중 하나를 사용하여 정수 값의 타입을 선언할 수 있습니다.</p>
<p><span class="caption">표 3-1: 러스트의 정수 타입</span></p>
<div class="table-wrapper"><table><thead><tr><th>길이</th><th>부호 있음</th><th>부호 없음</th></tr></thead><tbody>
<tr><td>8비트</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16비트</td><td><code>i16</code></td><td><code>u16</code>"</td></tr>
<tr><td>32비트</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64비트</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128비트</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td>아키텍처</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
</div>
<p>각 variant는 부호 있거나 부호 없을 수 있으며 명시적인 크기를 가집니다. _부호 있음_과 _부호 없음_은 숫자가 음수일 수 있는지 여부, 즉 숫자에 부호가 있어야 하는지(부호 있음) 또는 항상 양수이므로 부호 없이 표현할 수 있는지(부호 없음)를 나타냅니다. 종이에 숫자를 쓰는 것과 같습니다: 부호가 중요할 때, 숫자는 더하기 부호나 빼기 부호와 함께 표시됩니다. 그러나 숫자가 양수라고 가정해도 안전할 때, 부호 없이 표시됩니다. 부호 있는 숫자는 <a href="https://en.wikipedia.org/wiki/Two%27s_complement">2의 보수</a><!-- ignore
--> 표현을 사용하여 저장됩니다.</p>
<p>각 부호 있는 variant는 −(2<sup>n − 1</sup>)에서 2<sup>n − 1</sup> − 1까지의 숫자를 포함하여 저장할 수 있으며, 여기서 _n_은 해당 variant가 사용하는 비트 수입니다. 따라서 <code>i8</code>은 −(2<sup>7</sup>)에서 2<sup>7</sup> − 1까지, 즉 −128에서 127까지의 숫자를 저장할 수 있습니다. 부호 없는 variant는 0에서 2<sup>n</sup> − 1까지의 숫자를 저장할 수 있으므로, <code>u8</code>은 0에서 2<sup>8</sup> − 1까지, 즉 0에서 255까지의 숫자를 저장할 수 있습니다.</p>
<p>또한, <code>isize</code>와 <code>usize</code> 타입은 프로그램이 실행되는 컴퓨터의 아키텍처에 따라 달라지며, 표에서는 “arch”로 표시됩니다: 64비트 아키텍처에서는 64비트, 32비트 아키텍처에서는 32비트입니다.</p>
<p>표 3-2에 표시된 형식 중 하나로 정수 리터럴을 작성할 수 있습니다. 여러 숫자 타입이 될 수 있는 숫자 리터럴은 타입을 지정하기 위해 <code>57u8</code>과 같은 타입 접미사를 허용합니다. 또한 숫자 리터럴은 숫자를 더 쉽게 읽을 수 있도록 시각적 구분 기호로 <code>_</code>를 사용할 수 있습니다. 예를 들어, <code>1_000</code>은 <code>1000</code>을 지정한 것과 동일한 값을 가집니다.</p>
<p><span class="caption">표 3-2: 러스트의 정수 리터럴</span></p>
<div class="table-wrapper"><table><thead><tr><th>숫자 리터럴</th><th>예시</th></tr></thead><tbody>
<tr><td>십진수</td><td><code>98_222</code></td></tr>
<tr><td>16진수</td><td><code>0xff</code></td></tr>
<tr><td>8진수</td><td><code>0o77</code></td></tr>
<tr><td>2진수</td><td><code>0b1111_0000</code></td></tr>
<tr><td>바이트 (<code>u8</code> 전용)</td><td><code>b'A'</code></td></tr>
</tbody></table>
</div>
<p>그렇다면 어떤 정수 타입을 사용해야 할까요? 확실하지 않다면, 러스트의 기본값이 일반적으로 좋은 시작점입니다: 정수 타입은 기본적으로 <code>i32</code>입니다. <code>isize</code> 또는 <code>usize</code>를 사용하는 주된 상황은 어떤 종류의 컬렉션을 인덱싱할 때입니다.</p>
<blockquote>
<h5 id="정수-오버플로"><a class="header" href="#정수-오버플로">정수 오버플로</a></h5>
<p>0에서 255 사이의 값을 가질 수 있는 <code>u8</code> 타입의 변수가 있다고 가정해 봅시다. 변수를 256과 같이 해당 범위를 벗어나는 값으로 변경하려고 하면 _정수 오버플로_가 발생하며, 이는 두 가지 동작 중 하나를 초래할 수 있습니다. 디버그 모드에서 컴파일할 때, 러스트는 정수 오버플로에 대한 검사를 포함하여 이 동작이 발생하면 런타임에 프로그램이 _패닉_하도록 합니다. 러스트는 프로그램이 오류와 함께 종료될 때 _패닉_이라는 용어를 사용합니다. 패닉에 대해서는 9장의 <a href="ch09-01-unrecoverable-errors-with-panic.html">“<code>panic!</code>을 사용한 복구 불가능한 오류”</a><!-- ignore --> 섹션에서 더 자세히 다룰 것입니다.</p>
<p>--release<code>플래그를 사용하여 릴리스 모드로 컴파일할 때, 러스트는 패닉을 유발하는 정수 오버플로 검사를 _포함하지 않습니다_. 대신, 오버플로가 발생하면 러스트는 _2의 보수 래핑_을 수행합니다. 간단히 말해, 타입이 가질 수 있는 최대값을 초과하는 값은 타입이 가질 수 있는 최소값으로 "래핑"됩니다.</code>u8`의 경우, 값 256은 0이 되고, 값 257은 1이 되는 식입니다. 프로그램은 패닉하지 않지만, 변수는 아마도 당신이 예상했던 값이 아닐 것입니다. 정수 오버플로의 래핑 동작에 의존하는 것은 오류로 간주됩니다.</p>
<p>오버플로 가능성을 명시적으로 처리하려면, 기본 숫자 타입에 대해 표준 라이브러리에서 제공하는 다음 메서드들을 사용할 수 있습니다:</p>
<ul>
<li><code>wrapping_add</code>와 같은 <code>wrapping_*</code> 메서드를 사용하여 모든 모드에서 래핑합니다.</li>
<li><code>checked_*</code> 메서드를 사용하여 오버플로가 발생하면 <code>None</code> 값을 반환합니다.</li>
<li><code>overflowing_*</code> 메서드를 사용하여 값과 오버플로 발생 여부를 나타내는 불리언을 반환합니다.</li>
<li><code>saturating_*</code> 메서드를 사용하여 값의 최소 또는 최대값에서 포화시킵니다.</li>
</ul>
</blockquote>
<h4 id="부동소수점-타입"><a class="header" href="#부동소수점-타입">부동소수점 타입</a></h4>
<p>러스트는 또한 소수점이 있는 숫자, 즉 _부동소수점 숫자_를 위한 두 가지 기본 타입을 가지고 있습니다. 러스트의 부동소수점 타입은 <code>f32</code>와 <code>f64</code>이며, 각각 32비트와 64비트 크기입니다. 현대 CPU에서는 <code>f32</code>와 거의 같은 속도이지만 더 높은 정밀도를 가질 수 있기 때문에 기본 타입은 <code>f64</code>입니다. 모든 부동소수점 타입은 부호가 있습니다.</p>
<p>다음은 부동소수점 숫자가 작동하는 방식을 보여주는 예입니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}</code></pre></pre>
<p>부동소수점 숫자는 IEEE-754 표준에 따라 표현됩니다.</p>
<h4 id="수치-연산"><a class="header" href="#수치-연산">수치 연산</a></h4>
<p>러스트는 모든 숫자 타입에 대해 예상할 수 있는 기본적인 수학 연산(덧셈, 뺄셈, 곱셈, 나눗셈, 나머지)을 지원합니다. 정수 나눗셈은 0에 가까운 가장 가까운 정수로 절삭합니다. 다음 코드는 <code>let</code> 문에서 각 수치 연산을 사용하는 방법을 보여줍니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    // 덧셈
    let sum = 5 + 10;

    // 뺄셈
    let difference = 95.5 - 4.3;

    // 곱셈
    let product = 4 * 30;

    // 나눗셈
    let quotient = 56.7 / 32.2;
    let truncated = -5 / 3; // 결과는 -1

    // 나머지
    let remainder = 43 % 5;
}</code></pre></pre>
<p>이 문장의 각 표현식은 수학 연산자를 사용하며 단일 값으로 평가되고, 이 값은 변수에 바인딩됩니다. <a href="appendix-02-operators.html">부록 B</a><!-- ignore -->에는 러스트가 제공하는 모든 연산자 목록이 포함되어 있습니다.</p>
<h4 id="불리언-타입"><a class="header" href="#불리언-타입">불리언 타입</a></h4>
<p>대부분의 다른 프로그래밍 언어와 마찬가지로, 러스트의 불리언 타입은 <code>true</code>와 <code>false</code> 두 가지 가능한 값을 가집니다. 불리언은 1바이트 크기입니다. 러스트의 불리언 타입은 <code>bool</code>을 사용하여 지정됩니다. 예를 들어:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let t = true;

    let f: bool = false; // 명시적 타입 명시와 함께
}</code></pre></pre>
<p>불리언 값을 사용하는 주된 방법은 <code>if</code> 표현식과 같은 조건문을 통해서입니다. 러스트에서 <code>if</code> 표현식이 어떻게 작동하는지는 <a href="ch03-05-control-flow.html#control-flow">“제어 흐름”</a><!-- ignore --> 섹션에서 다룰 것입니다.</p>
<h4 id="문자-타입"><a class="header" href="#문자-타입">문자 타입</a></h4>
<p>러스트의 <code>char</code> 타입은 언어의 가장 기본적인 알파벳 타입입니다. 다음은 <code>char</code> 값을 선언하는 몇 가지 예입니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let c = 'z';
    let z: char = 'ℤ'; // 명시적 타입 명시와 함께
    let heart_eyed_cat = '😻';
}</code></pre></pre>
<p>문자열 리터럴이 큰따옴표를 사용하는 것과 달리, <code>char</code> 리터럴은 작은따옴표로 지정한다는 점에 유의하세요. 러스트의 <code>char</code> 타입은 4바이트 크기이며 유니코드 스칼라 값을 나타냅니다. 이는 ASCII보다 훨씬 더 많은 것을 표현할 수 있다는 의미입니다. 악센트가 있는 문자, 중국어, 일본어, 한국어 문자, 이모지, 그리고 너비가 0인 공백은 모두 러스트에서 유효한 <code>char</code> 값입니다. 유니코드 스칼라 값은 <code>U+0000</code>부터 <code>U+D7FF</code>까지, 그리고 <code>U+E000</code>부터 <code>U+10FFFF</code>까지 포함합니다. 그러나 유니코드에서 "문자"는 실제 개념이 아니므로, "문자"에 대한 인간의 직관이 러스트의 <code>char</code>와 일치하지 않을 수 있습니다. 이 주제는 8장의 <a href="ch08-02-strings.html#storing-utf-8-encoded-text-with-strings">“문자열로 UTF-8 인코딩된 텍스트 저장하기”</a><!-- ignore -->에서 자세히 다룰 것입니다.</p>
<h3 id="복합-타입"><a class="header" href="#복합-타입">복합 타입</a></h3>
<p>_복합 타입_은 여러 값을 하나의 타입으로 그룹화할 수 있습니다. 러스트에는 튜플과 배열이라는 두 가지 기본 복합 타입이 있습니다.</p>
<h4 id="튜플-타입"><a class="header" href="#튜플-타입">튜플 타입</a></h4>
<p>_튜플_은 다양한 타입의 여러 값을 하나의 복합 타입으로 묶는 일반적인 방법입니다. 튜플은 고정된 길이를 가집니다: 일단 선언되면 크기가 커지거나 줄어들 수 없습니다.</p>
<p>괄호 안에 쉼표로 구분된 값 목록을 작성하여 튜플을 생성합니다. 튜플의 각 위치는 타입을 가지며, 튜플 내의 다른 값들의 타입은 같을 필요가 없습니다. 이 예제에서는 선택적 타입 명시를 추가했습니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}</code></pre></pre>
<p>The variable <code>tup</code> binds to the entire tuple because a tuple is considered a single compound element. To get the individual values out of a tuple, we can use pattern matching to destructure a tuple value, like this:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("y의 값은: {y}");
}</code></pre></pre>
<p>이 프로그램은 먼저 튜플을 생성하고 <code>tup</code> 변수에 바인딩합니다. 그런 다음 <code>let</code>과 함께 패턴을 사용하여 <code>tup</code>을 가져와 <code>x</code>, <code>y</code>, <code>z</code> 세 개의 개별 변수로 만듭니다. 이것은 단일 튜플을 세 부분으로 나누기 때문에 _구조 분해_라고 불립니다. 마지막으로, 프로그램은 <code>y</code>의 값인 <code>6.4</code>를 출력합니다.</p>
<p>점(<code>.</code>) 뒤에 접근하려는 값의 인덱스를 사용하여 튜플 요소를 직접 접근할 수도 있습니다. 예를 들어:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}</code></pre></pre>
<p>이 프로그램은 튜플 <code>x</code>를 생성한 다음, 각 요소의 인덱스를 사용하여 튜플의 각 요소에 접근합니다. 대부분의 프로그래밍 언어와 마찬가지로, 튜플의 첫 번째 인덱스는 0입니다.</p>
<p>값이 없는 튜플은 _유닛_이라는 특별한 이름을 가집니다. 이 값과 해당 타입은 모두 <code>()</code>로 작성되며 빈 값 또는 빈 반환 타입을 나타냅니다. 표현식은 다른 값을 반환하지 않으면 암시적으로 유닛 값을 반환합니다.</p>
<h4 id="배열-타입"><a class="header" href="#배열-타입">배열 타입</a></h4>
<p>여러 값의 컬렉션을 가지는 또 다른 방법은 _배열_을 사용하는 것입니다. 튜플과 달리, 배열의 모든 요소는 동일한 타입을 가져야 합니다. 다른 일부 언어의 배열과 달리, 러스트의 배열은 고정된 길이를 가집니다.</p>
<p>배열의 값은 대괄호 안에 쉼표로 구분된 목록으로 작성합니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let a = [1, 2, 3, 4, 5];
}</code></pre></pre>
<p>배열은 지금까지 본 다른 타입과 마찬가지로 데이터를 힙이 아닌 스택에 할당하고 싶을 때(스택과 힙에 대해서는 <a href="ch04-01-what-is-ownership.html#the-stack-and-the-heap">4장</a><!-- ignore -->에서 더 자세히 논의할 것입니다) 또는 항상 고정된 수의 요소를 가지고 있음을 보장하고 싶을 때 유용합니다. 하지만 배열은 벡터 타입만큼 유연하지 않습니다. _벡터_는 표준 라이브러리에서 제공하는 유사한 컬렉션 타입으로, 크기가 커지거나 줄어들 수 있습니다. 배열을 사용할지 벡터를 사용할지 확실하지 않다면, 아마도 벡터를 사용해야 할 것입니다. <a href="ch08-01-vectors.html">8장</a><!-- ignore -->에서 벡터에 대해 더 자세히 논의합니다.</p>
<p>그러나 배열은 요소의 수가 변경될 필요가 없다는 것을 알 때 더 유용합니다. 예를 들어, 프로그램에서 월 이름을 사용한다면, 항상 12개의 요소를 포함한다는 것을 알기 때문에 벡터보다는 배열을 사용할 것입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
<span class="boring">}</span></code></pre></pre>
<p>배열의 타입은 각 요소의 타입, 세미콜론, 그리고 배열의 요소 수를 대괄호 안에 사용하여 다음과 같이 작성합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];
<span class="boring">}</span></code></pre></pre>
<p>여기서 <code>i32</code>는 각 요소의 타입입니다. 세미콜론 뒤의 숫자 <code>5</code>는 배열이 다섯 개의 요소를 포함한다는 것을 나타냅니다.</p>
<p>또한 여기에 표시된 것처럼 초기 값을 지정하고 세미콜론, 그리고 대괄호 안에 배열의 길이를 지정하여 각 요소에 동일한 값을 포함하도록 배열을 초기화할 수도 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [3; 5];
<span class="boring">}</span></code></pre></pre>
<p><code>a</code>라는 이름의 배열은 처음에 모두 <code>3</code> 값으로 설정될 <code>5</code>개의 요소를 포함할 것입니다. 이것은 <code>let a = [3, 3, 3, 3, 3];</code>라고 작성하는 것과 같지만 더 간결한 방법입니다.</p>
<h5 id="배열-요소에-접근하기"><a class="header" href="#배열-요소에-접근하기">배열 요소에 접근하기</a></h5>
<p>배열은 알려진 고정 크기의 단일 메모리 덩어리로, 스택에 할당될 수 있습니다. 다음과 같이 인덱싱을 사용하여 배열의 요소에 접근할 수 있습니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}</code></pre></pre>
<p>이 예에서 <code>first</code>라는 변수는 배열의 인덱스 <code>[0]</code>에 있는 값이므로 <code>1</code>을 얻게 됩니다. <code>second</code>라는 변수는 배열의 인덱스 <code>[1]</code>에서 <code>2</code> 값을 얻게 됩니다.</p>
<h5 id="잘못된-배열-요소-접근"><a class="header" href="#잘못된-배열-요소-접근">잘못된 배열 요소 접근</a></h5>
<p>배열의 끝을 넘어선 배열 요소에 접근하려고 하면 어떻게 되는지 살펴보겠습니다. 2장의 추측 게임과 유사하게, 사용자로부터 배열 인덱스를 얻기 위해 이 코드를 실행한다고 가정해 봅시다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><code class="language-rust ignore panics">use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!("배열 인덱스를 입력하세요.");

    let mut index = String::new();

    io::stdin()
        .read_line(&amp;mut index)
        .expect("줄 읽기 실패");

    let index: usize = index
        .trim()
        .parse()
        .expect("입력된 인덱스가 숫자가 아닙니다");

    let element = a[index];

    println!("인덱스 {index}에 있는 요소의 값은: {element}");
}</code></pre>
<p>이 코드는 성공적으로 컴파일됩니다. <code>cargo run</code>을 사용하여 이 코드를 실행하고 <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code> 또는 <code>4</code>를 입력하면 프로그램은 배열의 해당 인덱스에 있는 해당 값을 출력합니다. 대신 배열의 끝을 지난 숫자(예: <code>10</code>)를 입력하면 다음과 같은 출력이 표시됩니다.</p>
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access
cargo run
10
-->
<pre><code class="language-console">thread 'main' panicked at src/main.rs:19:19:
index out of bounds: the len is 5 but the index is 10
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>프로그램은 인덱싱 작업에서 유효하지 않은 값을 사용하는 지점에서 <em>런타임</em> 오류가 발생했습니다. 프로그램은 오류 메시지와 함께 종료되었고 최종 <code>println!</code> 문을 실행하지 않았습니다. 인덱싱을 사용하여 요소에 접근하려고 할 때 Rust는 지정한 인덱스가 배열 길이보다 작은지 확인합니다. 인덱스가 길이보다 크거나 같으면 Rust는 패닉합니다. 이 확인은 런타임에 발생해야 합니다. 특히 이 경우 컴파일러는 사용자가 나중에 코드를 실행할 때 어떤 값을 입력할지 알 수 없기 때문입니다.</p>
<p>이것은 러스트의 메모리 안전 원칙이 실제로 작동하는 예입니다. 많은 저수준 언어에서는 이러한 종류의 확인을 수행하지 않으며, 잘못된 인덱스를 제공하면 유효하지 않은 메모리에 접근할 수 있습니다. 러스트는 메모리 접근을 허용하고 계속 진행하는 대신 즉시 종료하여 이러한 종류의 오류로부터 사용자를 보호합니다. 9장에서는 러스트의 오류 처리에 대해 더 자세히 논의하고, 패닉을 일으키거나 유효하지 않은 메모리 접근을 허용하지 않는 읽기 쉽고 안전한 코드를 작성하는 방법을 설명합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="함수"><a class="header" href="#함수">함수</a></h2>
<p>함수는 러스트 코드에서 널리 사용됩니다. 여러분은 이미 언어에서 가장 중요한 함수 중 하나인 <code>main</code> 함수를 보았습니다. 이 함수는 많은 프로그램의 진입점입니다. 또한 새 함수를 선언할 수 있게 해주는 <code>fn</code> 키워드도 보았습니다.</p>
<p>러스트 코드는 함수와 변수 이름에 대한 관례적인 스타일로 _스네이크 케이스_를 사용합니다. 스네이크 케이스에서는 모든 글자가 소문자이고 밑줄이 단어를 구분합니다. 다음은 함수 정의 예시를 포함하는 프로그램입니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    println!("헬로, 월드!");

    another_function();
}

fn another_function() {
    println!("또 다른 함수.");
}</code></pre></pre>
<p>러스트에서는 <code>fn</code> 다음에 함수 이름과 한 쌍의 괄호를 입력하여 함수를 정의합니다. 중괄호는 컴파일러에게 함수 본문이 시작되고 끝나는 위치를 알려줍니다.</p>
<p>정의한 함수는 이름 뒤에 괄호를 붙여 호출할 수 있습니다. <code>another_function</code>은 프로그램에 정의되어 있으므로 <code>main</code> 함수 내에서 호출할 수 있습니다. 소스 코드에서 <code>main</code> 함수 <em>뒤에</em> <code>another_function</code>을 정의했지만, 그 전에도 정의할 수 있었습니다. 러스트는 함수를 어디에 정의하는지는 신경 쓰지 않고, 호출자가 볼 수 있는 범위 내 어딘가에 정의되어 있기만 하면 됩니다.</p>
<p>함수를 더 자세히 알아보기 위해 _functions_라는 새 바이너리 프로젝트를 시작하겠습니다. <code>another_function</code> 예제를 _src/main.rs_에 넣고 실행하세요. 다음과 같은 출력이 표시되어야 합니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.28s
     Running `target/debug/functions`
Hello, world!
Another function.
</code></pre>
<p>줄은 <code>main</code> 함수에 나타나는 순서대로 실행됩니다. 먼저 “Hello, world!” 메시지가 출력된 다음 <code>another_function</code>이 호출되고 해당 메시지가 출력됩니다.</p>
<h3 id="매개변수"><a class="header" href="#매개변수">매개변수</a></h3>
<p>함수는 함수의 시그니처의 일부인 특별한 변수인 _매개변수_를 갖도록 정의할 수 있습니다. 함수에 매개변수가 있으면 해당 매개변수에 대한 구체적인 값을 제공할 수 있습니다. 기술적으로 구체적인 값은 _인수_라고 하지만, 일상적인 대화에서는 사람들이 함수 정의의 변수나 함수를 호출할 때 전달되는 구체적인 값 모두에 대해 _매개변수_와 _인수_라는 단어를 혼용하여 사용하는 경향이 있습니다.</p>
<p>이 버전의 <code>another_function</code>에서는 매개변수를 추가합니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!("x의 값은: {x}");
}</code></pre></pre>
<p>이 프로그램을 실행해 보세요. 다음과 같은 출력을 얻어야 합니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.21s
     Running `target/debug/functions`
The value of x is: 5
</code></pre>
<p><code>another_function</code>의 선언에는 <code>x</code>라는 이름의 매개변수가 하나 있습니다. <code>x</code>의 타입은 <code>i32</code>로 지정됩니다. <code>another_function</code>에 <code>5</code>를 전달하면 <code>println!</code> 매크로는 형식 문자열에서 <code>x</code>를 포함하는 중괄호 쌍이 있던 위치에 <code>5</code>를 넣습니다.</p>
<p>함수 시그니처에서는 각 매개변수의 타입을 <em>반드시</em> 선언해야 합니다. 이것은 러스트 디자인의 의도적인 결정입니다. 함수 정의에서 타입 명시를 요구하면 컴파일러가 코드의 다른 곳에서 타입을 파악하기 위해 타입 명시를 거의 필요로 하지 않게 됩니다. 또한 컴파일러는 함수가 어떤 타입을 예상하는지 알면 더 유용한 오류 메시지를 제공할 수 있습니다.</p>
<p>여러 매개변수를 정의할 때는 다음과 같이 쉼표로 매개변수 선언을 구분합니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("측정값은: {value}{unit_label}");
}</code></pre></pre>
<p>이 예제는 두 개의 매개변수를 가진 <code>print_labeled_measurement</code>라는 이름의 함수를 만듭니다. 첫 번째 매개변수는 <code>value</code>라는 이름의 <code>i32</code>입니다. 두 번째는 <code>unit_label</code>이라는 이름의 <code>char</code> 타입입니다. 그런 다음 함수는 <code>value</code>와 <code>unit_label</code>을 모두 포함하는 텍스트를 출력합니다.</p>
<p>이 코드를 실행해 봅시다. 현재 <em>functions</em> 프로젝트의 <em>src/main.rs</em> 파일에 있는 프로그램을 앞의 예제로 바꾸고 <code>cargo run</code>을 사용하여 실행하세요:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/functions`
The measurement is: 5h
</code></pre>
<p><code>value</code>에 대한 값으로 <code>5</code>를, <code>unit_label</code>에 대한 값으로 <code>'h'</code>를 사용하여 함수를 호출했기 때문에 프로그램 출력에는 해당 값이 포함됩니다.</p>
<h3 id="문과-표현식"><a class="header" href="#문과-표현식">문과 표현식</a></h3>
<p>함수 본문은 선택적으로 표현식으로 끝나는 일련의 문으로 구성됩니다. 지금까지 다룬 함수에는 끝나는 표현식이 포함되지 않았지만, 문의 일부로 표현식을 본 적이 있습니다. 러스트는 표현식 기반 언어이므로 이것은 이해해야 할 중요한 구별입니다. 다른 언어에는 동일한 구별이 없으므로 문과 표현식이 무엇이며 그 차이가 함수 본문에 어떤 영향을 미치는지 살펴보겠습니다.</p>
<ul>
<li><strong>문</strong>은 어떤 동작을 수행하고 값을 반환하지 않는 명령어입니다.</li>
<li><strong>표현식</strong>은 결과 값으로 평가됩니다. 몇 가지 예를 살펴보겠습니다.</li>
</ul>
<p>사실 우리는 이미 문과 표현식을 사용했습니다. <code>let</code> 키워드로 변수를 만들고 값을 할당하는 것은 문입니다. 목록 3-1에서 <code>let y = 6;</code>은 문입니다.</p>
<Listing number="3-1" file-name="src/main.rs" caption="A `main` function declaration containing one statement">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let y = 6;
}</code></pre></pre>
</Listing>
<p>함수 정의도 문입니다. 앞의 전체 예제는 그 자체로 문입니다. (아래에서 보겠지만, 함수를 _호출_하는 것은 문이 아닙니다.)</p>
<p>문은 값을 반환하지 않습니다. 따라서 다음 코드가 시도하는 것처럼 <code>let</code> 문을 다른 변수에 할당할 수 없습니다. 오류가 발생합니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = (let y = 6);
}</code></pre>
<p>이 프로그램을 실행하면 다음과 같은 오류가 발생합니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found `let` statement
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^
  |
  = note: only supported directly in conditions of `if` and `while` expressions

warning: unnecessary parentheses around assigned value
 --&gt; src/main.rs:2:13
  |
2 |     let x = (let y = 6);
  |             ^         ^
  |
  = note: `#[warn(unused_parens)]` on by default
help: remove these parentheses
  |
2 -     let x = (let y = 6);
2 +     let x = let y = 6;
  |

warning: `functions` (bin "functions") generated 1 warning
error: could not compile `functions` (bin "functions") due to 1 previous error; 1 warning emitted
</code></pre>
<p><code>let y = 6</code> 문은 값을 반환하지 않으므로 <code>x</code>에 바인딩할 것이 없습니다. 이것은 할당이 할당 값을 반환하는 C 및 Ruby와 같은 다른 언어에서 발생하는 것과 다릅니다. 해당 언어에서는 <code>x = y = 6</code>을 작성하여 <code>x</code>와 <code>y</code> 모두 <code>6</code> 값을 갖게 할 수 있지만 러스트에서는 그렇지 않습니다.</p>
<p>표현식은 값으로 평가되며 러스트에서 작성할 나머지 코드의 대부분을 구성합니다. <code>5 + 6</code>과 같은 수학 연산을 생각해 보세요. 이것은 <code>11</code>이라는 값으로 평가되는 표현식입니다. 표현식은 문의 일부가 될 수 있습니다. 목록 3-1에서 <code>let y = 6;</code> 문의 <code>6</code>은 <code>6</code>이라는 값으로 평가되는 표현식입니다. 함수를 호출하는 것은 표현식입니다. 매크로를 호출하는 것은 표현식입니다. 중괄호로 만든 새 범위 블록은 표현식입니다. 예를 들면 다음과 같습니다.</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("y의 값은: {y}");
}</code></pre></pre>
<p>이 표현식은:</p>
<pre><code class="language-rust ignore">{
    let x = 3;
    x + 1
}</code></pre>
<p>는 이 경우 <code>4</code>로 평가되는 블록입니다. 그 값은 <code>let</code> 문의 일부로 <code>y</code>에 바인딩됩니다. <code>x + 1</code> 줄 끝에 세미콜론이 없다는 점에 유의하세요. 이는 지금까지 본 대부분의 줄과 다릅니다. 표현식에는 끝나는 세미콜론이 포함되지 않습니다. 표현식 끝에 세미콜론을 추가하면 문으로 바뀌고 값을 반환하지 않습니다. 다음에 함수 반환 값과 표현식을 탐색할 때 이 점을 명심하세요.</p>
<h3 id="반환-값이-있는-함수"><a class="header" href="#반환-값이-있는-함수">반환 값이 있는 함수</a></h3>
<p>함수는 호출한 코드로 값을 반환할 수 있습니다. 반환 값의 이름은 지정하지 않지만, 화살표(<code>-&gt;</code>) 뒤에 타입을 선언해야 합니다. 러스트에서 함수의 반환 값은 함수 본문 블록의 마지막 표현식 값과 동의어입니다. <code>return</code> 키워드를 사용하고 값을 지정하여 함수에서 일찍 반환할 수 있지만, 대부분의 함수는 마지막 표현식을 암시적으로 반환합니다. 다음은 값을 반환하는 함수의 예입니다.</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn five() -&gt; i32 {
    5
}

fn main() {
    let x = five();

    println!("x의 값은: {x}");
}</code></pre></pre>
<p><code>five</code> 함수에는 함수 호출, 매크로 또는 <code>let</code> 문조차 없습니다. 단지 숫자 <code>5</code>만 있습니다. 이것은 러스트에서 완벽하게 유효한 함수입니다. 함수의 반환 타입도 <code>-&gt; i32</code>로 지정되어 있습니다. 이 코드를 실행해 보세요. 출력은 다음과 같아야 합니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/functions`
The value of x is: 5
</code></pre>
<p><code>five</code>의 <code>5</code>는 함수의 반환 값이므로 반환 타입은 <code>i32</code>입니다. 이것을 더 자세히 살펴보겠습니다. 두 가지 중요한 점이 있습니다. 첫째, <code>let x = five();</code> 줄은 함수 반환 값을 사용하여 변수를 초기화하고 있음을 보여줍니다. <code>five</code> 함수가 <code>5</code>를 반환하기 때문에 해당 줄은 다음과 같습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}</span></code></pre></pre>
<p>둘째, <code>five</code> 함수는 매개변수가 없고 반환 값의 타입을 정의하지만, 함수 본문은 반환하려는 값의 표현식이므로 세미콜론이 없는 외로운 <code>5</code>입니다.</p>
<p>다른 예를 살펴보겠습니다.</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = plus_one(5);

    println!("x의 값은: {x}");
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1
}</code></pre></pre>
<p>이 코드를 실행하면 <code>x의 값은: 6</code>이 출력됩니다. 하지만 <code>x + 1</code>을 포함하는 줄 끝에 세미콜론을 넣어 표현식에서 문으로 바꾸면 오류가 발생합니다.</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = plus_one(5);

    println!("x의 값은: {x}");
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1;
}</code></pre>
<p>이 코드를 컴파일하면 다음과 같이 오류가 발생합니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:24
  |
7 | fn plus_one(x: i32) -&gt; i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
8 |     x + 1;
  |          - help: remove this semicolon to return this value

For more information about this error, try `rustc --explain E0308`.
error: could not compile `functions` (bin "functions") due to 1 previous error
</code></pre>
<p>주요 오류 메시지인 <code>mismatched types</code>는 이 코드의 핵심 문제를 보여줍니다. <code>plus_one</code> 함수의 정의는 <code>i32</code>를 반환한다고 되어 있지만, 문은 값으로 평가되지 않으며, 이는 단위 타입인 <code>()</code>로 표현됩니다. 따라서 아무것도 반환되지 않으며, 이는 함수 정의와 모순되어 오류가 발생합니다. 이 출력에서 러스트는 이 문제를 해결하는 데 도움이 될 수 있는 메시지를 제공합니다. 즉, 세미콜론을 제거하면 오류가 해결될 것이라고 제안합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="주석"><a class="header" href="#주석">주석</a></h2>
<p>모든 프로그래머는 코드를 이해하기 쉽게 만들려고 노력하지만, 때로는 추가 설명이 필요합니다. 이러한 경우 프로그래머는 소스 코드에 _주석_을 남겨 컴파일러는 무시하지만 소스 코드를 읽는 사람들에게는 유용할 수 있습니다.</p>
<p>다음은 간단한 주석입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// hello, world
<span class="boring">}</span></code></pre></pre>
<p>러스트에서 관용적인 주석 스타일은 두 개의 슬래시로 주석을 시작하고, 주석은 줄 끝까지 계속됩니다. 한 줄을 넘는 주석의 경우, 다음과 같이 각 줄에 <code>//</code>를 포함해야 합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// So we're doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain what's going on.
<span class="boring">}</span></code></pre></pre>
<p>주석은 코드가 포함된 줄 끝에도 배치할 수 있습니다.</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let lucky_number = 7; // I'm feeling lucky today
}</code></pre></pre>
<p>하지만 주석이 달린 코드 위의 별도 줄에 주석이 있는 이 형식으로 더 자주 사용되는 것을 볼 수 있습니다.</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    // I'm feeling lucky today
    let lucky_number = 7;
}</code></pre></pre>
<p>러스트에는 문서 주석이라는 또 다른 종류의 주석도 있으며, 이에 대해서는 14장의 <a href="ch14-02-publishing-to-crates-io.html">“Crate를 Crates.io에 게시하기”</a><!-- ignore --> 섹션에서 설명합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="제어-흐름"><a class="header" href="#제어-흐름">제어 흐름</a></h2>
<p>조건이 <code>true</code>인지 여부에 따라 일부 코드를 실행하고 조건이 <code>true</code>인 동안 일부 코드를 반복적으로 실행하는 기능은 대부분의 프로그래밍 언어에서 기본적인 구성 요소입니다. 러스트 코드의 실행 흐름을 제어할 수 있는 가장 일반적인 구문은 <code>if</code> 표현식과 루프입니다.</p>
<h3 id="if-표현식"><a class="header" href="#if-표현식"><code>if</code> 표현식</a></h3>
<p><code>if</code> 표현식은 조건에 따라 코드를 분기할 수 있게 해줍니다. 조건을 제공한 다음 “이 조건이 충족되면 이 코드 블록을 실행하세요. 조건이 충족되지 않으면 이 코드 블록을 실행하지 마세요.”라고 명시합니다.</p>
<p><code>if</code> 표현식을 탐색하기 위해 <em>projects</em> 디렉토리에 _branches_라는 새 프로젝트를 만드세요. <em>src/main.rs</em> 파일에 다음을 입력하세요.</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let number = 3;

    if number &lt; 5 {
        println!("조건이 참이었습니다");
    } else {
        println!("조건이 거짓이었습니다");
    }
}</code></pre></pre>
<p>모든 <code>if</code> 표현식은 <code>if</code> 키워드로 시작하고 그 뒤에 조건이 옵니다. 이 경우 조건은 <code>number</code> 변수의 값이 5보다 작은지 여부를 확인합니다. 조건이 <code>true</code>일 때 실행할 코드 블록은 조건 바로 뒤에 중괄호 안에 배치합니다. <code>if</code> 표현식의 조건과 관련된 코드 블록은 2장의 <a href="ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">“추측을 비밀 번호와 비교하기”</a><!--
 ignore --> 섹션에서 논의한 <code>match</code> 표현식의 암(arm)과 마찬가지로 때때로 _암(arm)_이라고 불립니다.</p>
<p>선택적으로, <code>else</code> 표현식을 포함할 수도 있습니다. 여기서는 조건이 <code>false</code>로 평가될 경우 프로그램이 실행할 대체 코드 블록을 제공하기 위해 그렇게 했습니다. <code>else</code> 표현식을 제공하지 않고 조건이 <code>false</code>이면 프로그램은 <code>if</code> 블록을 건너뛰고 다음 코드 부분으로 넘어갑니다.</p>
<p>이 코드를 실행해 보세요. 다음과 같은 출력이 표시되어야 합니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was true
</code></pre>
<p><code>number</code>의 값을 조건을 <code>false</code>로 만드는 값으로 변경하여 어떤 일이 발생하는지 살펴보겠습니다.</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    let number = 7;
<span class="boring">
</span><span class="boring">    if number &lt; 5 {
</span><span class="boring">        println!("조건이 참이었습니다");
</span><span class="boring">    } else {
</span><span class="boring">        println!("조건이 거짓이었습니다");
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>프로그램을 다시 실행하고 출력을 확인하세요.</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was false
</code></pre>
<p>이 코드의 조건은 <code>bool</code>이어야 한다는 점도 주목할 가치가 있습니다. 조건이 <code>bool</code>이 아니면 오류가 발생합니다. 예를 들어 다음 코드를 실행해 보세요.</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let number = 3;

    if number {
        println!("숫자는 3이었습니다");
    }
}</code></pre>
<p>이번에는 <code>if</code> 조건이 <code>3</code> 값으로 평가되고, 러스트는 오류를 발생시킵니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: mismatched types
 --&gt; src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected `bool`, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` (bin "branches") due to 1 previous error
</code></pre>
<p>오류는 러스트가 <code>bool</code>을 예상했지만 정수를 받았음을 나타냅니다. Ruby 및 JavaScript와 같은 언어와 달리 러스트는 비불리언 타입을 자동으로 불리언으로 변환하려고 시도하지 않습니다. 명시적으로 <code>if</code>에 항상 불리언을 조건으로 제공해야 합니다. 예를 들어 숫자가 <code>0</code>과 같지 않을 때만 <code>if</code> 코드 블록을 실행하려면 <code>if</code> 표현식을 다음과 같이 변경할 수 있습니다.</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let number = 3;

    if number != 0 {
        println!("숫자는 0이 아니었습니다");
    }
}</code></pre></pre>
<p>이 코드를 실행하면 <code>숫자는 0이 아니었습니다</code>가 출력됩니다.</p>
<h4 id="else-if로-여러-조건-처리하기"><a class="header" href="#else-if로-여러-조건-처리하기"><code>else if</code>로 여러 조건 처리하기</a></h4>
<p><code>else if</code> 표현식에서 <code>if</code>와 <code>else</code>를 결합하여 여러 조건을 사용할 수 있습니다. 예를 들어:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("숫자는 4로 나누어집니다");
    } else if number % 3 == 0 {
        println!("숫자는 3으로 나누어집니다");
    } else if number % 2 == 0 {
        println!("숫자는 2로 나누어집니다");
    } else {
        println!("숫자는 4, 3, 2로 나누어지지 않습니다");
    }
}</code></pre></pre>
<p>이 프로그램은 네 가지 가능한 경로를 가질 수 있습니다. 실행 후 다음과 같은 출력이 표시되어야 합니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
number is divisible by 3
</code></pre>
<p>이 프로그램이 실행되면 각 <code>if</code> 표현식을 차례로 확인하고 조건이 <code>true</code>로 평가되는 첫 번째 본문을 실행합니다. 6은 2로 나누어지지만, <code>number is divisible by 2</code>라는 출력이나 <code>else</code> 블록의 <code>number is not divisible by 4, 3, or 2</code> 텍스트는 볼 수 없습니다. 이는 러스트가 첫 번째 <code>true</code> 조건에 대한 블록만 실행하고, 하나를 찾으면 나머지는 확인하지 않기 때문입니다.</p>
<p>너무 많은 <code>else if</code> 표현식을 사용하면 코드가 복잡해질 수 있으므로, 하나 이상인 경우 코드를 리팩토링하는 것이 좋습니다. 6장에서는 이러한 경우를 위한 <code>match</code>라는 강력한 러스트 분기 구문에 대해 설명합니다.</p>
<h4 id="let-문에서-if-사용하기"><a class="header" href="#let-문에서-if-사용하기"><code>let</code> 문에서 <code>if</code> 사용하기</a></h4>
<p><code>if</code>는 표현식이므로, 목록 3-2와 같이 <code>let</code> 문의 오른쪽에 사용하여 결과를 변수에 할당할 수 있습니다.</p>
<Listing number="3-2" file-name="src/main.rs" caption="Assigning the result of an `if` expression to a variable">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("숫자의 값은: {number}");
}</code></pre></pre>
</Listing>
<p><code>number</code> 변수는 <code>if</code> 표현식의 결과에 따라 값에 바인딩됩니다. 이 코드를 실행하여 어떤 일이 발생하는지 확인하세요.</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/branches`
The value of number is: 5
</code></pre>
<p>코드 블록은 마지막 표현식으로 평가되며, 숫자 자체도 표현식이라는 것을 기억하세요. 이 경우 전체 <code>if</code> 표현식의 값은 어떤 코드 블록이 실행되는지에 따라 달라집니다. 이는 <code>if</code>의 각 암(arm)에서 결과가 될 수 있는 값들이 동일한 타입이어야 함을 의미합니다. 목록 3-2에서 <code>if</code> 암과 <code>else</code> 암의 결과는 모두 <code>i32</code> 정수였습니다. 다음 예제와 같이 타입이 일치하지 않으면 오류가 발생합니다.</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let condition = true;

    let number = if condition { 5 } else { "여섯" };

    println!("숫자의 값은: {number}");
}</code></pre>
<p>이 코드를 컴파일하려고 하면 오류가 발생합니다. <code>if</code>와 <code>else</code> 암(arm)은 호환되지 않는 값 타입을 가지며, 러스트는 프로그램에서 문제가 있는 정확한 위치를 알려줍니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: `if` and `else` have incompatible types
 --&gt; src/main.rs:4:44
  |
4 |     let number = if condition { 5 } else { "six" };
  |                                 -          ^^^^^ expected integer, found `&amp;str`
  |                                 |
  |                                 expected because of this

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` (bin "branches") due to 1 previous error
</code></pre>
<p><code>if</code> 블록의 표현식은 정수로 평가되고, <code>else</code> 블록의 표현식은 문자열로 평가됩니다. 변수는 단일 타입을 가져야 하고, 러스트는 컴파일 시점에 <code>number</code> 변수의 타입을 명확하게 알아야 하므로 이것은 작동하지 않습니다. <code>number</code>의 타입을 알면 컴파일러는 <code>number</code>를 사용하는 모든 곳에서 타입이 유효한지 확인할 수 있습니다. <code>number</code>의 타입이 런타임에만 결정된다면 러스트는 그렇게 할 수 없을 것입니다. 컴파일러는 더 복잡해지고 어떤 변수에 대해 여러 가상의 타입을 추적해야 한다면 코드에 대한 보장을 덜 할 것입니다.</p>
<h3 id="반복문으로-반복하기"><a class="header" href="#반복문으로-반복하기">반복문으로 반복하기</a></h3>
<p>코드 블록을 여러 번 실행하는 것이 종종 유용합니다. 이 작업을 위해 러스트는 여러 _루프_를 제공합니다. 루프는 루프 본문 안의 코드를 끝까지 실행한 다음 즉시 처음으로 돌아갑니다. 루프를 실험하기 위해 _loops_라는 새 프로젝트를 만들어 보겠습니다.</p>
<p>러스트에는 <code>loop</code>, <code>while</code>, <code>for</code> 세 가지 종류의 루프가 있습니다. 각각을 시도해 보겠습니다.</p>
<h4 id="loop로-코드-반복하기"><a class="header" href="#loop로-코드-반복하기"><code>loop</code>로 코드 반복하기</a></h4>
<p><code>loop</code> 키워드는 러스트에게 코드 블록을 영원히 또는 명시적으로 중지하라고 지시할 때까지 계속해서 실행하도록 지시합니다.</p>
<p>예를 들어, <em>loops</em> 디렉토리의 <em>src/main.rs</em> 파일을 다음과 같이 변경하세요.</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!("다시!");
    }
}</code></pre>
<p>이 프로그램을 실행하면 프로그램을 수동으로 중지할 때까지 <code>again!</code>이 계속해서 반복적으로 출력되는 것을 볼 수 있습니다. 대부분의 터미널은 연속 루프에 갇힌 프로그램을 중단하기 위해 <kbd>ctrl</kbd>-<kbd>c</kbd> 키보드 단축키를 지원합니다. 시도해 보세요:</p>
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-32-loop
cargo run
CTRL-C
-->
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.08s
     Running `target/debug/loops`
again!
again!
again!
again!
^Cagain!
</code></pre>
<p><code>^C</code> 기호는 <kbd>ctrl</kbd>-<kbd>c</kbd>를 눌렀음을 나타냅니다. 인터럽트 신호를 받았을 때 코드가 루프의 어느 위치에 있었는지에 따라 <code>^C</code> 뒤에 <code>again!</code>이라는 단어가 인쇄될 수도 있고 인쇄되지 않을 수도 있습니다.</p>
<p>다행히 러스트는 코드를 사용하여 루프를 빠져나오는 방법도 제공합니다. <code>break</code> 키워드를 루프 안에 배치하여 프로그램이 루프 실행을 언제 중지해야 하는지 알려줄 수 있습니다. 2장의 <a href="ch02-00-guessing-game-tutorial.html#quitting-after-a-correct-guess">“정답 맞춘 후 종료하기”</a><!-- ignore
 --> 섹션에서 사용자가 정답을 맞춰 게임에서 이겼을 때 프로그램을 종료하기 위해 이 작업을 수행했습니다.</p>
<p>또한 추측 게임에서 <code>continue</code>를 사용했습니다. 이는 루프에서 프로그램에게 현재 루프 반복의 나머지 코드를 건너뛰고 다음 반복으로 이동하도록 지시합니다.</p>
<h4 id="루프에서-값-반환하기"><a class="header" href="#루프에서-값-반환하기">루프에서 값 반환하기</a></h4>
<p><code>loop</code>의 용도 중 하나는 실패할 수 있는 작업을 재시도하는 것입니다. 예를 들어 스레드가 작업을 완료했는지 확인하는 것과 같습니다. 또한 해당 작업의 결과를 루프 밖으로 코드의 나머지 부분으로 전달해야 할 수도 있습니다. 이를 위해 루프를 중지하는 데 사용하는 <code>break</code> 표현식 뒤에 반환하려는 값을 추가할 수 있습니다. 이 값은 루프 밖으로 반환되어 여기 표시된 것처럼 사용할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("결과는 {result}입니다");
}</code></pre></pre>
<p>루프 전에 <code>counter</code>라는 변수를 선언하고 <code>0</code>으로 초기화합니다. 그런 다음 루프에서 반환된 값을 저장할 <code>result</code>라는 변수를 선언합니다. 루프의 모든 반복에서 <code>1</code>을 <code>counter</code> 변수에 더한 다음 <code>counter</code>가 <code>10</code>과 같은지 확인합니다. 같으면 <code>counter * 2</code> 값과 함께 <code>break</code> 키워드를 사용합니다. 루프 후에 세미콜론을 사용하여 <code>result</code>에 값을 할당하는 문을 종료합니다. 마지막으로 <code>result</code>의 값을 출력하는데, 이 경우 <code>20</code>입니다.</p>
<p>루프 안에서 <code>return</code>할 수도 있습니다. <code>break</code>는 현재 루프만 종료하지만, <code>return</code>은 항상 현재 함수를 종료합니다.</p>
<h4 id="여러-루프-간의-모호성을-없애기-위한-루프-레이블"><a class="header" href="#여러-루프-간의-모호성을-없애기-위한-루프-레이블">여러 루프 간의 모호성을 없애기 위한 루프 레이블</a></h4>
<p>루프 안에 루프가 있는 경우, <code>break</code>와 <code>continue</code>는 해당 지점의 가장 안쪽 루프에 적용됩니다. 선택적으로 루프에 _루프 레이블_을 지정할 수 있으며, 이 레이블을 <code>break</code> 또는 <code>continue</code>와 함께 사용하여 해당 키워드가 가장 안쪽 루프 대신 레이블이 지정된 루프에 적용되도록 지정할 수 있습니다. 루프 레이블은 작은따옴표로 시작해야 합니다. 다음은 두 개의 중첩된 루프 예시입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {count}");
        let mut remaining = 10;

        loop {
            println!("remaining = {remaining}");
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("최종 count = {count}");
}</code></pre></pre>
<p>바깥쪽 루프에는 <code>'counting_up</code> 레이블이 있으며, 0부터 2까지 카운트합니다. 레이블이 없는 안쪽 루프는 10부터 9까지 카운트합니다. 레이블을 지정하지 않은 첫 번째 <code>break</code>는 안쪽 루프만 종료합니다. <code>break 'counting_up;</code> 문은 바깥쪽 루프를 종료합니다. 이 코드는 다음을 출력합니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running `target/debug/loops`
count = 0
remaining = 10
remaining = 9
count = 1
remaining = 10
remaining = 9
count = 2
remaining = 10
End count = 2
</code></pre>
<h4 id="while을-사용한-조건부-루프"><a class="header" href="#while을-사용한-조건부-루프"><code>while</code>을 사용한 조건부 루프</a></h4>
<p>프로그램은 종종 루프 내에서 조건을 평가해야 합니다. 조건이 <code>true</code>인 동안 루프가 실행됩니다. 조건이 <code>true</code>가 아니게 되면 프로그램은 <code>break</code>를 호출하여 루프를 중지합니다. <code>loop</code>, <code>if</code>, <code>else</code>, <code>break</code>의 조합을 사용하여 이와 같은 동작을 구현할 수 있습니다. 원한다면 지금 프로그램에서 시도해 볼 수 있습니다. 그러나 이 패턴은 너무 흔해서 러스트에는 <code>while</code> 루프라는 내장 언어 구문이 있습니다. 목록 3-3에서는 <code>while</code>을 사용하여 프로그램을 세 번 반복하고, 매번 카운트다운한 다음, 루프 후에 메시지를 출력하고 종료합니다.</p>
<Listing number="3-3" file-name="src/main.rs" caption="Using a `while` loop to run code while a condition holds true">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{number}!");

        number -= 1;
    }

    println!("발사!!!");
}</code></pre></pre>
</Listing>
<p>이 구문은 <code>loop</code>, <code>if</code>, <code>else</code>, <code>break</code>를 사용했을 때 필요했을 많은 중첩을 제거하며, 더 명확합니다. 조건이 <code>true</code>로 평가되는 동안 코드가 실행되고, 그렇지 않으면 루프를 종료합니다.</p>
<h4 id="for로-컬렉션-반복하기"><a class="header" href="#for로-컬렉션-반복하기"><code>for</code>로 컬렉션 반복하기</a></h4>
<p><code>while</code> 구문을 사용하여 배열과 같은 컬렉션의 요소를 반복할 수도 있습니다. 예를 들어, 목록 3-4의 루프는 배열 <code>a</code>의 각 요소를 출력합니다.</p>
<Listing number="3-4" file-name="src/main.rs" caption="Looping through each element of a collection using a `while` loop">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }
}</code></pre></pre>
</Listing>
<p>여기서 코드는 배열의 요소를 통해 카운트합니다. 인덱스 <code>0</code>에서 시작하여 배열의 마지막 인덱스에 도달할 때까지 루프를 실행합니다(즉, <code>index &lt; 5</code>가 더 이상 <code>true</code>가 아닐 때). 이 코드를 실행하면 배열의 모든 요소가 출력됩니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.32s
     Running `target/debug/loops`
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50
</code></pre>
<p>예상대로 다섯 개의 배열 값이 모두 터미널에 나타납니다. <code>index</code>가 어느 시점에서 <code>5</code>에 도달하더라도, 루프는 배열에서 여섯 번째 값을 가져오려고 시도하기 전에 실행을 중지합니다.</p>
<p>그러나 이 접근 방식은 오류가 발생하기 쉽습니다. 인덱스 값이나 테스트 조건이 잘못되면 프로그램이 패닉 상태에 빠질 수 있습니다. 예를 들어, <code>a</code> 배열의 정의를 네 개의 요소를 갖도록 변경했지만 조건을 <code>while index &lt; 4</code>로 업데이트하는 것을 잊었다면 코드는 패닉할 것입니다. 또한 컴파일러가 루프의 모든 반복에서 인덱스가 배열 범위 내에 있는지 조건부 검사를 수행하기 위해 런타임 코드를 추가하므로 느립니다.</p>
<p>더 간결한 대안으로, <code>for</code> 루프를 사용하여 컬렉션의 각 항목에 대해 일부 코드를 실행할 수 있습니다. <code>for</code> 루프는 목록 3-5의 코드와 같습니다.</p>
<Listing number="3-5" file-name="src/main.rs" caption="Looping through each element of a collection using a `for` loop">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("값은: {element}입니다");
    }
}</code></pre></pre>
</Listing>
<p>이 코드를 실행하면 목록 3-4와 동일한 출력을 볼 수 있습니다. 더 중요하게는, 이제 코드의 안전성을 높이고 배열의 끝을 넘어가거나 충분히 멀리 가지 못해 일부 항목을 놓치는 것으로 인해 발생할 수 있는 버그의 가능성을 제거했습니다.</p>
<p><code>for</code> 루프를 사용하면 목록 3-4에서 사용된 메서드처럼 배열의 값 수를 변경하더라도 다른 코드를 변경할 필요가 없습니다.</p>
<p><code>for</code> 루프의 안전성과 간결성은 러스트에서 가장 일반적으로 사용되는 루프 구문입니다. 목록 3-3의 <code>while</code> 루프를 사용한 카운트다운 예제처럼 특정 횟수만큼 코드를 실행하려는 상황에서도 대부분의 러스트 개발자는 <code>for</code> 루프를 사용할 것입니다. 그렇게 하려면 표준 라이브러리에서 제공하는 <code>Range</code>를 사용해야 합니다. <code>Range</code>는 한 숫자부터 시작하여 다른 숫자 앞에서 끝나는 모든 숫자를 순서대로 생성합니다.</p>
<p>다음은 <code>for</code> 루프와 아직 이야기하지 않은 다른 메서드인 <code>rev</code>를 사용하여 범위를 역순으로 만드는 카운트다운의 모습입니다.</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    for number in (1..4).rev() {
        println!("{number}!");
    }
    println!("발사!!!");
}</code></pre></pre>
<p>이 코드가 좀 더 깔끔하죠?</p>
<h2 id="요약-2"><a class="header" href="#요약-2">요약</a></h2>
<p>해냈습니다! 이번 장은 상당한 분량이었습니다. 변수, 스칼라 및 복합 데이터 타입, 함수, 주석, <code>if</code> 표현식, 루프에 대해 배웠습니다! 이 장에서 논의된 개념을 연습하려면 다음을 수행하는 프로그램을 만들어 보세요.</p>
<ul>
<li>화씨와 섭씨 온도 변환.</li>
<li>_n_번째 피보나치 수 생성.</li>
<li>크리스마스 캐럴 “The Twelve Days of Christmas”의 가사를 노래의 반복을 활용하여 출력합니다.</li>
</ul>
<p>다음으로 넘어갈 준비가 되면, 다른 프로그래밍 언어에는 일반적으로 존재하지 않는 러스트의 개념인 소유권에 대해 이야기하겠습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="소유권-이해하기"><a class="header" href="#소유권-이해하기">소유권 이해하기</a></h1>
<p>소유권은 러스트의 가장 독특한 기능이며 나머지 언어에 깊은 영향을 미칩니다. 이는 러스트가 가비지 컬렉터 없이 메모리 안전 보장을 할 수 있도록 해주므로, 소유권이 어떻게 작동하는지 이해하는 것이 중요합니다. 이 장에서는 소유권뿐만 아니라 몇 가지 관련 기능인 빌림, 슬라이스, 그리고 러스트가 메모리에 데이터를 배치하는 방법에 대해 이야기할 것입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="소유권이란-무엇인가"><a class="header" href="#소유권이란-무엇인가">소유권이란 무엇인가?</a></h2>
<p>_소유권_은 러스트 프로그램이 메모리를 관리하는 방법을 규정하는 규칙 집합입니다. 모든 프로그램은 실행 중에 컴퓨터의 메모리 사용 방식을 관리해야 합니다. 일부 언어에는 프로그램이 실행되는 동안 더 이상 사용되지 않는 메모리를 정기적으로 찾는 가비지 컬렉션이 있습니다. 다른 언어에서는 프로그래머가 메모리를 명시적으로 할당하고 해제해야 합니다. 러스트는 세 번째 접근 방식을 사용합니다. 메모리는 컴파일러가 확인하는 일련의 규칙을 가진 소유권 시스템을 통해 관리됩니다. 규칙 중 하나라도 위반되면 프로그램은 컴파일되지 않습니다. 소유권의 어떤 기능도 프로그램 실행 속도를 늦추지 않습니다.</p>
<p>소유권은 많은 프로그래머에게 새로운 개념이므로 익숙해지는 데 시간이 걸립니다. 좋은 소식은 러스트와 소유권 시스템 규칙에 더 익숙해질수록 안전하고 효율적인 코드를 자연스럽게 개발하는 것이 더 쉬워진다는 것입니다. 계속 노력하세요!</p>
<p>소유권을 이해하면 러스트를 독특하게 만드는 기능을 이해하는 데 견고한 기반을 갖게 될 것입니다. 이 장에서는 매우 일반적인 데이터 구조인 문자열에 초점을 맞춘 몇 가지 예제를 통해 소유권을 배울 것입니다.</p>
<blockquote>
<h3 id="스택과-힙"><a class="header" href="#스택과-힙">스택과 힙</a></h3>
<p>많은 프로그래밍 언어는 스택과 힙에 대해 자주 생각할 필요가 없습니다. 하지만 러스트와 같은 시스템 프로그래밍 언어에서는 값이 스택에 있는지 힙에 있는지가 언어의 동작 방식과 특정 결정을 내려야 하는 이유에 영향을 미칩니다. 소유권의 일부는 이 장의 뒷부분에서 스택과 힙과 관련하여 설명될 것이므로, 여기서는 준비를 위한 간략한 설명을 제공합니다.</p>
<p>스택과 힙은 모두 런타임에 코드가 사용할 수 있는 메모리 영역이지만, 서로 다른 방식으로 구성됩니다. 스택은 값을 가져온 순서대로 저장하고 반대 순서로 값을 제거합니다. 이를 _후입선출_이라고 합니다. 접시 더미를 생각해 보세요. 접시를 더 추가할 때는 더미 위에 놓고, 접시가 필요할 때는 맨 위에서 하나를 가져갑니다. 중간이나 아래에서 접시를 추가하거나 제거하는 것은 잘 작동하지 않을 것입니다! 데이터를 추가하는 것을 _스택에 푸시_라고 하고, 데이터를 제거하는 것을 _스택에서 팝_이라고 합니다. 스택에 저장되는 모든 데이터는 알려진 고정된 크기를 가져야 합니다. 컴파일 시점에 크기를 알 수 없거나 크기가 변경될 수 있는 데이터는 대신 힙에 저장되어야 합니다.</p>
<p>힙은 덜 조직적입니다. 힙에 데이터를 넣을 때, 특정 양의 공간을 요청합니다. 메모리 할당자는 힙에서 충분히 큰 빈 공간을 찾아 사용 중으로 표시하고, 해당 위치의 주소인 _포인터_를 반환합니다. 이 과정을 _힙에 할당_이라고 하며 때로는 단순히 _할당_이라고 줄여 말합니다(값을 스택에 푸시하는 것은 할당으로 간주되지 않습니다). 힙에 대한 포인터는 알려진 고정 크기이므로 포인터를 스택에 저장할 수 있지만, 실제 데이터를 원할 때는 포인터를 따라가야 합니다. 식당에 앉아 있는 것을 생각해 보세요. 입장할 때 그룹 인원수를 말하면, 호스트가 모두에게 맞는 빈 테이블을 찾아 안내합니다. 그룹의 누군가가 늦게 오면, 당신이 어디에 앉아 있는지 물어 찾아올 수 있습니다.</p>
<p>스택에 푸시하는 것이 힙에 할당하는 것보다 빠릅니다. 할당자가 새 데이터를 저장할 공간을 검색할 필요가 없기 때문입니다. 해당 위치는 항상 스택의 맨 위에 있습니다. 비교적으로 힙에 공간을 할당하는 것은 더 많은 작업을 필요로 합니다. 할당자가 먼저 데이터를 담을 충분히 큰 공간을 찾은 다음 다음 할당을 준비하기 위해 장부 정리를 수행해야 하기 때문입니다.</p>
<p>힙의 데이터에 접근하는 것은 스택의 데이터에 접근하는 것보다 느립니다. 포인터를 따라가야 하기 때문입니다. 현대 프로세서는 메모리에서 덜 이동할수록 더 빠릅니다. 비유를 계속하자면, 식당에서 여러 테이블의 주문을 받는 서버를 생각해 보세요. 다음 테이블로 이동하기 전에 한 테이블의 모든 주문을 받는 것이 가장 효율적입니다. 테이블 A에서 주문을 받고, 테이블 B에서 주문을 받고, 다시 A에서 하나, 다시 B에서 하나를 받는 것은 훨씬 느린 과정일 것입니다. 마찬가지로 프로세서는 다른 데이터와 가까운 데이터(스택에 있는 것처럼)에서 작업할 때 더 멀리 떨어진 데이터(힙에 있을 수 있는 것처럼)에서 작업할 때보다 작업을 더 잘 수행할 수 있습니다.</p>
<p>코드가 함수를 호출하면 함수에 전달된 값(잠재적으로 힙의 데이터에 대한 포인터 포함)과 함수의 지역 변수가 스택에 푸시됩니다. 함수가 끝나면 해당 값은 스택에서 팝됩니다.</p>
<p>코드의 어떤 부분이 힙의 어떤 데이터를 사용하고 있는지 추적하고, 힙의 중복 데이터 양을 최소화하며, 공간 부족을 방지하기 위해 힙의 사용되지 않는 데이터를 정리하는 것은 모두 소유권이 다루는 문제입니다. 소유권을 이해하면 스택과 힙에 대해 자주 생각할 필요가 없지만, 소유권의 주요 목적이 힙 데이터를 관리하는 것임을 알면 소유권이 작동하는 방식을 설명하는 데 도움이 될 수 있습니다.</p>
</blockquote>
<h3 id="소유권-규칙"><a class="header" href="#소유권-규칙">소유권 규칙</a></h3>
<p>먼저 소유권 규칙을 살펴보겠습니다. 다음 예제를 통해 설명할 때 이 규칙들을 염두에 두세요.</p>
<ul>
<li>러스트의 모든 값에는 _소유자_가 있습니다.</li>
<li>한 번에 하나의 소유자만 있을 수 있습니다.</li>
<li>소유자가 스코프를 벗어나면 값은 드롭됩니다.</li>
</ul>
<h3 id="변수-스코프"><a class="header" href="#변수-스코프">변수 스코프</a></h3>
<p>이제 기본적인 러스트 구문을 넘어섰으므로, 예제에 모든 <code>fn main() {</code> 코드를 포함하지 않을 것입니다. 따라서 따라하고 있다면, 다음 예제들을 수동으로 <code>main</code> 함수 안에 넣으세요. 결과적으로, 우리의 예제는 상용구 코드보다는 실제 세부 사항에 집중할 수 있도록 좀 더 간결해질 것입니다.</p>
<p>소유권의 첫 번째 예시로, 일부 변수의 _스코프_를 살펴보겠습니다. 스코프는 프로그램 내에서 항목이 유효한 범위입니다. 다음 변수를 예로 들어 보겠습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = "hello";
<span class="boring">}</span></code></pre></pre>
<p>변수 <code>s</code>는 문자열 리터럴을 참조하며, 문자열의 값은 프로그램 텍스트에 하드코딩됩니다. 변수는 선언된 시점부터 현재 _스코프_가 끝날 때까지 유효합니다. 목록 4-1은 변수 <code>s</code>가 유효한 위치를 주석으로 표시한 프로그램을 보여줍니다.</p>
<Listing number="4-1" caption="A variable and the scope in which it is valid">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    {                      // s is not valid here, it’s not yet declared
        let s = "hello";   // s는 이 시점부터 유효합니다.

        // s로 작업 수행
    }                      // 이 스코프는 이제 끝났고, s는 더 이상 유효하지 않습니다.
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>다시 말해, 여기에는 두 가지 중요한 시점이 있습니다.</p>
<ul>
<li><code>s</code>가 스코프 <em>안으로</em> 들어오면 유효합니다.</li>
<li>스코프 <em>밖으로</em> 나갈 때까지 유효합니다.</li>
</ul>
<p>이 시점에서 스코프와 변수가 유효한 시점 간의 관계는 다른 프로그래밍 언어와 유사합니다. 이제 이 이해를 바탕으로 <code>String</code> 타입을 소개하겠습니다.</p>
<h3 id="string-타입"><a class="header" href="#string-타입"><code>String</code> 타입</a></h3>
<p>소유권 규칙을 설명하기 위해 3장의 <a href="ch03-02-data-types.html#data-types">“데이터 타입”</a><!-- ignore --> 섹션에서 다룬 것보다 더 복잡한 데이터 타입이 필요합니다. 이전에 다룬 타입들은 알려진 크기를 가지며, 스택에 저장되고 스코프가 끝나면 스택에서 팝될 수 있으며, 코드의 다른 부분이 다른 스코프에서 동일한 값을 사용해야 하는 경우 새롭고 독립적인 인스턴스를 만들기 위해 빠르고 간단하게 복사될 수 있습니다. 그러나 우리는 힙에 저장된 데이터를 살펴보고 러스트가 언제 해당 데이터를 정리해야 하는지 어떻게 아는지 탐구하고 싶으며, <code>String</code> 타입은 좋은 예시입니다.</p>
<p><code>String</code>의 소유권과 관련된 부분에 집중할 것입니다. 이러한 측면은 표준 라이브러리에서 제공되거나 직접 생성한 다른 복잡한 데이터 타입에도 적용됩니다. <code>String</code>에 대해서는 <a href="ch08-02-strings.html">8장</a><!-- ignore -->에서 더 자세히 논의할 것입니다.</p>
<p>우리는 이미 문자열 리터럴을 보았습니다. 문자열 값은 프로그램에 하드코딩됩니다. 문자열 리터럴은 편리하지만, 텍스트를 사용하려는 모든 상황에 적합하지는 않습니다. 한 가지 이유는 불변이기 때문입니다. 또 다른 이유는 모든 문자열 값을 코드를 작성할 때 알 수 없기 때문입니다. 예를 들어 사용자 입력을 받아 저장하고 싶다면 어떻게 해야 할까요? 이러한 상황을 위해 러스트에는 두 번째 문자열 타입인 <code>String</code>이 있습니다. 이 타입은 힙에 할당된 데이터를 관리하며, 따라서 컴파일 시점에 알 수 없는 양의 텍스트를 저장할 수 있습니다. <code>from</code> 함수를 사용하여 문자열 리터럴에서 <code>String</code>을 만들 수 있습니다. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");
<span class="boring">}</span></code></pre></pre>
<p>이중 콜론 <code>::</code> 연산자를 사용하면 <code>string_from</code>과 같은 이름을 사용하는 대신 <code>String</code> 타입 아래에 이 특정 <code>from</code> 함수를 네임스페이스화할 수 있습니다. 이 구문에 대해서는 5장의 <a href="ch05-03-method-syntax.html#method-syntax">“메서드 구문”</a><!-- ignore --> 섹션과 7장의 <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“모듈 트리에서 항목을 참조하는 경로”</a><!-- ignore -->에서 모듈을 사용한 네임스페이스화에 대해 이야기할 때 더 자세히 논의할 것입니다.</p>
<p>이러한 종류의 문자열은 <em>변경될 수 있습니다</em>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    s.push_str(", world!"); // push_str() appends a literal to a String

    println!("{s}"); // This will print `hello, world!`
<span class="boring">}</span></code></pre></pre>
<p>그렇다면 여기서 차이점은 무엇일까요? 왜 <code>String</code>은 변경될 수 있지만 리터럴은 변경될 수 없을까요? 차이점은 이 두 타입이 메모리를 다루는 방식에 있습니다.</p>
<h3 id="메모리-및-할당"><a class="header" href="#메모리-및-할당">메모리 및 할당</a></h3>
<p>문자열 리터럴의 경우, 컴파일 시점에 내용을 알 수 있으므로 텍스트가 최종 실행 파일에 직접 하드코딩됩니다. 이것이 문자열 리터럴이 빠르고 효율적인 이유입니다. 하지만 이러한 속성은 문자열 리터럴의 불변성에서만 비롯됩니다. 불행히도, 컴파일 시점에 크기를 알 수 없고 프로그램 실행 중에 크기가 변경될 수 있는 각 텍스트 조각에 대해 메모리 블롭을 바이너리에 넣을 수는 없습니다.</p>
<p><code>String</code> 타입을 사용하면 변경 가능하고 확장 가능한 텍스트 조각을 지원하기 위해 컴파일 시점에 알 수 없는 양의 메모리를 힙에 할당하여 내용을 저장해야 합니다. 이는 다음을 의미합니다.</p>
<ul>
<li>메모리는 런타임에 메모리 할당자에게 요청되어야 합니다.</li>
<li><code>String</code> 사용을 마쳤을 때 이 메모리를 할당자에게 반환하는 방법이 필요합니다.</li>
</ul>
<p>첫 번째 부분은 우리가 수행합니다. <code>String::from</code>을 호출하면 해당 구현이 필요한 메모리를 요청합니다. 이는 프로그래밍 언어에서 거의 보편적입니다.</p>
<p>그러나 두 번째 부분은 다릅니다. _가비지 컬렉터(GC)_가 있는 언어에서는 GC가 더 이상 사용되지 않는 메모리를 추적하고 정리하므로 우리는 이에 대해 생각할 필요가 없습니다. GC가 없는 대부분의 언어에서는 메모리가 더 이상 사용되지 않을 때를 식별하고 요청했던 것처럼 명시적으로 해제하는 코드를 호출하는 것이 우리의 책임입니다. 이를 올바르게 수행하는 것은 역사적으로 어려운 프로그래밍 문제였습니다. 잊어버리면 메모리를 낭비하게 됩니다. 너무 일찍 해제하면 유효하지 않은 변수를 갖게 됩니다. 두 번 해제하면 그것도 버그입니다. 정확히 하나의 <code>allocate</code>와 정확히 하나의 <code>free</code>를 짝지어야 합니다.</p>
<p>러스트는 다른 경로를 택합니다. 메모리는 소유한 변수가 스코프를 벗어나면 자동으로 반환됩니다. 다음은 문자열 리터럴 대신 <code>String</code>을 사용한 목록 4-1의 스코프 예제 버전입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    {
        let s = String::from("hello"); // s는 이 시점부터 유효합니다.

        // s로 작업 수행
    }                                  // 이 스코프는 이제 끝났고, s는 더 이상 유효하지 않습니다.
<span class="boring">}</span></code></pre></pre>
<p><code>String</code>이 필요로 하는 메모리를 할당자에게 반환할 수 있는 자연스러운 시점이 있습니다. 바로 <code>s</code>가 스코프를 벗어날 때입니다. 변수가 스코프를 벗어나면 러스트는 우리를 위해 특별한 함수를 호출합니다. 이 함수는 <a href="../std/ops/trait.Drop.html#tymethod.drop"><code>drop</code></a><!-- ignore -->이라고 불리며, <code>String</code>의 작성자가 메모리를 반환하는 코드를 넣을 수 있는 곳입니다. 러스트는 닫는 중괄호에서 <code>drop</code>을 자동으로 호출합니다.</p>
<blockquote>
<p>참고: C++에서는 항목의 수명 끝에 리소스를 할당 해제하는 이 패턴을 때때로 _자원 획득은 초기화(RAII)_라고 부릅니다. RAII 패턴을 사용해 본 적이 있다면 러스트의 <code>drop</code> 함수가 익숙할 것입니다.</p>
</blockquote>
<p>이 패턴은 러스트 코드가 작성되는 방식에 지대한 영향을 미칩니다. 지금은 간단해 보일 수 있지만, 여러 변수가 힙에 할당한 데이터를 사용하려고 할 때 더 복잡한 상황에서는 코드의 동작이 예상치 못할 수 있습니다. 이제 그러한 상황 중 일부를 살펴보겠습니다.</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="ways-variables-and-data-interact-move"></a></p>
<h4 id="이동과-상호작용하는-변수와-데이터"><a class="header" href="#이동과-상호작용하는-변수와-데이터">이동과 상호작용하는 변수와 데이터</a></h4>
<p>러스트에서는 여러 변수가 동일한 데이터와 다른 방식으로 상호 작용할 수 있습니다. 목록 4-2의 정수를 사용한 예제를 살펴보겠습니다.</p>
<Listing number="4-2" caption="Assigning the integer value of variable `x` to `y`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>이것이 무엇을 하는지 짐작할 수 있습니다. “값 <code>5</code>를 <code>x</code>에 바인딩한 다음, <code>x</code>의 값을 복사하여 <code>y</code>에 바인딩합니다.” 이제 <code>x</code>와 <code>y</code> 두 개의 변수가 있고, 둘 다 <code>5</code>와 같습니다. 정수는 알려진 고정 크기를 가진 단순한 값이므로 실제로 이런 일이 발생하며, 이 두 <code>5</code> 값은 스택에 푸시됩니다.</p>
<p>이제 <code>String</code> 버전을 살펴보겠습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");
    let s2 = s1;
<span class="boring">}</span></code></pre></pre>
<p>이것은 매우 유사해 보이므로, 작동 방식도 같을 것이라고 가정할 수 있습니다. 즉, 두 번째 줄은 <code>s1</code>의 값을 복사하여 <code>s2</code>에 바인딩할 것입니다. 하지만 실제로는 그렇지 않습니다.</p>
<p>그림 4-1을 보면 <code>String</code>이 내부적으로 어떻게 작동하는지 알 수 있습니다. <code>String</code>은 왼쪽에 표시된 세 부분으로 구성됩니다. 문자열 내용을 담는 메모리에 대한 포인터, 길이, 용량입니다. 이 데이터 그룹은 스택에 저장됩니다. 오른쪽에는 내용을 담는 힙의 메모리가 있습니다.</p>
<p><img alt="Two tables: the first table contains the representation of s1 on the
stack, consisting of its length (5), capacity (5), and a pointer to the first
value in the second table. The second table contains the representation of the
string data on the heap, byte by byte." src="img/trpl04-01.svg" class="center"
style="width: 50%;" /></p>
<p><span class="caption">그림 4-1: <code>s1</code>에 바인딩된 값 <code>"hello"</code>를 가진 <code>String</code>의 메모리 표현</span></p>
<p>길이는 <code>String</code>의 내용이 현재 사용하고 있는 메모리 양(바이트 단위)입니다. 용량은 <code>String</code>이 할당자로부터 받은 총 메모리 양(바이트 단위)입니다. 길이와 용량의 차이는 중요하지만, 이 컨텍스트에서는 그렇지 않으므로 지금은 용량을 무시해도 됩니다.</p>
<p><code>s1</code>을 <code>s2</code>에 할당할 때 <code>String</code> 데이터가 복사됩니다. 즉, 스택에 있는 포인터, 길이, 용량이 복사됩니다. 포인터가 참조하는 힙의 데이터는 복사되지 않습니다. 다시 말해, 메모리의 데이터 표현은 그림 4-2와 같습니다.</p>
<p><img alt="세 개의 테이블: 각각 스택에 있는 해당 문자열을 나타내는 s1 및 s2 테이블이며, 둘 다 힙의 동일한 문자열 데이터를 가리킵니다."
src="img/trpl04-02.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">그림 4-2: <code>s1</code>의 포인터, 길이, 용량의 복사본을 가진 변수 <code>s2</code>의 메모리 표현</span></p>
<p>표현은 그림 4-3과 같지 <em>않습니다</em>. 만약 러스트가 힙 데이터도 복사했다면 메모리는 그림 4-3과 같았을 것입니다. 만약 러스트가 이렇게 했다면, 힙의 데이터가 클 경우 <code>s2 = s1</code> 연산은 런타임 성능 측면에서 매우 비쌀 수 있습니다.</p>
<p><img alt="네 개의 테이블: s1 및 s2에 대한 스택 데이터를 나타내는 두 개의 테이블이며, 각각은 힙에 있는 자체 문자열 데이터 복사본을 가리킵니다."
src="img/trpl04-03.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">그림 4-3: 러스트가 힙 데이터도 복사했다면 <code>s2 = s1</code>이 수행할 수 있는 또 다른 가능성</span></p>
<p>앞서 변수가 스코프를 벗어나면 러스트가 자동으로 <code>drop</code> 함수를 호출하여 해당 변수의 힙 메모리를 정리한다고 말했습니다. 하지만 그림 4-2는 두 데이터 포인터가 모두 동일한 위치를 가리키고 있음을 보여줍니다. 이것은 문제입니다. <code>s2</code>와 <code>s1</code>이 스코프를 벗어나면 둘 다 동일한 메모리를 해제하려고 시도할 것입니다. 이것은 <em>이중 해제</em> 오류로 알려져 있으며 이전에 언급한 메모리 안전 버그 중 하나입니다. 메모리를 두 번 해제하면 메모리 손상으로 이어질 수 있으며, 이는 잠재적으로 보안 취약점으로 이어질 수 있습니다.</p>
<p>메모리 안전을 보장하기 위해 <code>let s2 = s1;</code> 줄 다음에 러스트는 <code>s1</code>을 더 이상 유효하지 않은 것으로 간주합니다. 따라서 <code>s1</code>이 스코프를 벗어날 때 러스트는 아무것도 해제할 필요가 없습니다. <code>s2</code>가 생성된 후 <code>s1</code>을 사용하려고 할 때 어떤 일이 발생하는지 확인해 보세요. 작동하지 않을 것입니다:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");
    let s2 = s1;

    println!("{s1}, 월드!");
<span class="boring">}</span></code></pre>
<p>러스트가 유효하지 않은 참조를 사용하는 것을 막기 때문에 다음과 같은 오류가 발생합니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --&gt; src/main.rs:5:15
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |
5 |     println!("{s1}, world!");
  |               ^^^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider cloning the value if the performance cost is acceptable
  |
3 |     let s2 = s1.clone();
  |                ++++++++

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>다른 언어로 작업하면서 _얕은 복사_와 _깊은 복사_라는 용어를 들어본 적이 있다면, 데이터를 복사하지 않고 포인터, 길이, 용량을 복사하는 개념은 얕은 복사를 만드는 것처럼 들릴 것입니다. 하지만 러스트는 첫 번째 변수도 무효화하기 때문에 얕은 복사라고 불리는 대신 _이동_으로 알려져 있습니다. 이 예에서는 <code>s1</code>이 <code>s2</code>로 _이동_되었다고 말할 것입니다. 따라서 실제로 일어나는 일은 그림 4-4에 나와 있습니다.</p>
<p><img alt="세 개의 테이블: 각각 스택에 있는 해당 문자열을 나타내는 s1 및 s2 테이블이며, 둘 다 힙의 동일한 문자열 데이터를 가리킵니다.
s1은 더 이상 유효하지 않기 때문에 회색으로 표시되며, s2만 힙 데이터에 접근하는 데 사용할 수 있습니다."
src="img/trpl04-04.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">그림 4-4: <code>s1</code>이 무효화된 후의 메모리 표현</span></p>
<p>문제가 해결되었습니다! <code>s2</code>만 유효하므로, 스코프를 벗어나면 <code>s2</code>만 메모리를 해제하고 작업이 완료됩니다.</p>
<p>또한, 이것이 암시하는 설계 선택이 있습니다: 러스트는 데이터의 "깊은" 복사본을 자동으로 생성하지 않습니다. 따라서 모든 <em>자동</em> 복사는 런타임 성능 측면에서 비용이 저렴하다고 가정할 수 있습니다.</p>
<h4 id="스코프와-할당"><a class="header" href="#스코프와-할당">스코프와 할당</a></h4>
<p>이것의 역도 스코핑, 소유권, 그리고 <code>drop</code> 함수를 통한 메모리 해제 사이의 관계에 해당합니다. 기존 변수에 완전히 새로운 값을 할당하면, 러스트는 <code>drop</code>을 호출하고 원래 값의 메모리를 즉시 해제합니다. 예를 들어, 이 코드를 고려해 보세요:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");
    s = String::from("아호이");

    println!(" {s}, 세상아!");
<span class="boring">}</span></code></pre></pre>
<p>처음에 <code>s</code>라는 변수를 선언하고 <code>"hello"</code> 값을 가진 <code>String</code>에 바인딩합니다. 그런 다음 즉시 <code>"ahoy"</code> 값을 가진 새 <code>String</code>을 만들고 <code>s</code>에 할당합니다. 이 시점에서 힙의 원래 값을 참조하는 것은 아무것도 없습니다.</p>
<p><img alt="스택의 문자열 값을 나타내는 하나의 테이블 s는 힙의 두 번째 문자열 데이터(ahoy)를 가리키고 있으며, 원래 문자열 데이터(hello)는 더 이상 접근할 수 없으므로 회색으로 표시됩니다."
src="img/trpl04-05.svg"
class="center"
style="width: 50%;"
/></p>
<p><span class="caption">그림 4-5: 초기 값이 전체적으로 교체된 후의 메모리 표현.</span></p>
<p>The original string thus immediately goes out of scope. Rust will run the <code>drop</code> function on it and its memory will be freed right away. When we print the value at the end, it will be <code>"ahoy, world!"</code>.</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="ways-variables-and-data-interact-clone"></a></p>
<h4 id="variables-and-data-interacting-with-clone"><a class="header" href="#variables-and-data-interacting-with-clone">Variables and Data Interacting with Clone</a></h4>
<p>If we <em>do</em> want to deeply copy the heap data of the <code>String</code>, not just the stack data, we can use a common method called <code>clone</code>. We’ll discuss method syntax in Chapter 5, but because methods are a common feature in many programming languages, you’ve probably seen them before.</p>
<p>다음은 <code>clone</code> 메서드가 작동하는 예입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {s1}, s2 = {s2}");
<span class="boring">}</span></code></pre></pre>
<p>이것은 잘 작동하며 그림 4-3에 표시된 동작, 즉 힙 데이터가 <em>복사되는</em> 동작을 명시적으로 생성합니다.</p>
<p><code>clone</code> 호출을 보면 임의의 코드가 실행되고 있으며 해당 코드는 비용이 많이들 수 있다는 것을 알 수 있습니다. 이것은 뭔가 다른 일이 일어나고 있다는 시각적 표시입니다.</p>
<h4 id="스택-전용-데이터-복사"><a class="header" href="#스택-전용-데이터-복사">스택 전용 데이터: 복사</a></h4>
<p>아직 이야기하지 않은 또 다른 주름이 있습니다. 정수를 사용하는 이 코드(일부는 목록 4-2에 표시됨)는 작동하며 유효합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;

    println!("x = {x}, y = {y}");
<span class="boring">}</span></code></pre></pre>
<p>하지만 이 코드는 우리가 방금 배운 것과 모순되는 것 같습니다. <code>clone</code>을 호출하지 않았지만 <code>x</code>는 여전히 유효하며 <code>y</code>로 이동되지 않았습니다.</p>
<p>그 이유는 컴파일 타임에 알려진 크기를 가진 정수와 같은 타입은 전적으로 스택에 저장되므로 실제 값의 복사본을 빠르게 만들 수 있기 때문입니다. 즉, 변수 <code>y</code>를 만든 후 <code>x</code>가 유효하지 않도록 막을 이유가 없습니다. 다시 말해, 여기서는 깊은 복사와 얕은 복사 사이에 차이가 없으므로 <code>clone</code>을 호출해도 일반적인 얕은 복사와 다른 작업을 수행하지 않으며 생략할 수 있습니다.</p>
<p>러스트에는 정수와 같이 스택에 저장되는 타입에 배치할 수 있는 <code>Copy</code> 트레이트라는 특별한 어노테이션이 있습니다(트레이트에 대해서는 <a href="ch10-02-traits.html">10장</a><!-- 무시 -->에서 더 자세히 다룰 것입니다). 타입이 <code>Copy</code> 트레이트를 구현하면 해당 타입을 사용하는 변수는 이동되지 않고 간단하게 복사되어 다른 변수에 할당된 후에도 여전히 유효합니다.</p>
<p>타입 또는 그 일부가 <code>Drop</code> 트레이트를 구현한 경우 러스트는 해당 타입에 <code>Copy</code> 어노테이션을 추가하는 것을 허용하지 않습니다. 값이 스코프를 벗어날 때 특별한 일이 일어나야 하는 타입에 <code>Copy</code> 어노테이션을 추가하면 컴파일 타임 오류가 발생합니다. 타입에 <code>Copy</code> 어노테이션을 추가하여 트레이트를 구현하는 방법에 대해 알아보려면 부록 C의 <a href="appendix-03-derivable-traits.html">“파생 가능한 트레이트”</a><!-- 무시 -->를 참조하세요.</p>
<p>그렇다면 어떤 타입이 <code>Copy</code> 트레이트를 구현할까요? 확실히 하려면 해당 타입의 문서를 확인할 수 있지만, 일반적인 규칙으로 간단한 스칼라 값 그룹은 <code>Copy</code>를 구현할 수 있으며, 할당이 필요하거나 어떤 형태의 리소스인 것은 <code>Copy</code>를 구현할 수 없습니다. 다음은 <code>Copy</code>를 구현하는 몇 가지 타입입니다:</p>
<ul>
<li><code>u32</code>와 같은 모든 정수 타입.</li>
<li><code>true</code>와 <code>false</code> 값을 갖는 불리언 타입, <code>bool</code>.</li>
<li><code>f64</code>와 같은 모든 부동 소수점 타입.</li>
<li>문자 타입, <code>char</code>.</li>
<li>튜플, 만약 <code>Copy</code>를 구현하는 타입만 포함하는 경우. 예를 들어, <code>(i32, i32)</code>는 <code>Copy</code>를 구현하지만 <code>(i32, String)</code>은 그렇지 않습니다.</li>
</ul>
<h3 id="소유권과-함수"><a class="header" href="#소유권과-함수">소유권과 함수</a></h3>
<p>The mechanics of passing a value to a function are similar to those when assigning a value to a variable. Passing a variable to a function will move or copy, just as assignment does. Listing 4-3 has an example with some annotations showing where variables go into and out of scope.</p>
<Listing number="4-3" file-name="src/main.rs" caption="Functions with ownership and scope annotated">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let s = String::from("hello");  // s가 스코프 안으로 들어옵니다

    takes_ownership(s);             // s's value moves into the function...
                                    // ... and so is no longer valid here

    let x = 5;                      // x가 스코프 안으로 들어옵니다

    makes_copy(x);                  // i32는 Copy 트레이트를 구현하므로,
                                    // x는 함수로 이동하지 않습니다,
    println!("{}", x);              // 그래서 나중에 x를 사용해도 괜찮습니다

} // 여기서 x가 스코프를 벗어난 다음 s가 벗어납니다. 하지만 s의 값은 이동되었으므로,
  // 특별한 일은 일어나지 않습니다.

fn takes_ownership(some_string: String) { // some_string이 스코프 안으로 들어옵니다
    println!("{some_string}");
} // 여기서 some_string이 스코프를 벗어나고 `drop`이 호출됩니다. 배후의
  // 메모리가 해제됩니다.

fn makes_copy(some_integer: i32) { // some_integer가 스코프 안으로 들어옵니다
    println!("{some_integer}");
} // 여기서 some_integer가 스코프를 벗어납니다. 특별한 일은 일어나지 않습니다.</code></pre></pre>
</Listing>
<p><code>takes_ownership</code> 호출 후 <code>s</code>를 사용하려고 하면 러스트는 컴파일 타임 오류를 발생시킵니다. 이러한 정적 검사는 우리를 실수로부터 보호합니다. <code>main</code>에 <code>s</code>와 <code>x</code>를 사용하는 코드를 추가하여 어디서 사용할 수 있고 어디서 소유권 규칙이 사용을 방해하는지 확인해 보세요.</p>
<h3 id="반환-값과-스코프"><a class="header" href="#반환-값과-스코프">반환 값과 스코프</a></h3>
<p>값을 반환하는 것도 소유권을 이전할 수 있습니다. 목록 4-4는 목록 4-3과 유사한 주석이 있는, 어떤 값을 반환하는 함수의 예입니다.</p>
<Listing number="4-4" file-name="src/main.rs" caption="Transferring ownership of return values">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let s1 = gives_ownership();        // gives_ownership은 반환 값을
                                       // s1으로 이동시킵니다

    let s2 = String::from("hello");    // s2가 스코프 안으로 들어옵니다

    let s3 = takes_and_gives_back(s2); // s2 is moved into
                                       // takes_and_gives_back, which also
                                       // moves its return value into s3
} // 여기서 s3는 스코프를 벗어나 드롭됩니다. s2는 이동되었으므로 아무 일도 일어나지 않습니다. s1은 스코프를 벗어나 드롭됩니다.
fn gives_ownership() -&gt; String {       // gives_ownership will move its
                                       // return value into the function
                                       // that calls it

    let some_string = String::from("yours"); // some_string이 스코프 안으로 들어옵니다

    some_string                        // some_string이 반환되어 호출한
                                       // 함수로
                                       // 이동합니다
}

// 이 함수는 String을 가져와서 String을 반환합니다.
fn takes_and_gives_back(a_string: String) -&gt; String {
    // a_string이 스코프 안으로
    // 들어옵니다

    a_string  // a_string이 반환되어 호출한 함수로 이동합니다
}</code></pre></pre>
</Listing>
<p>변수의 소유권은 매번 동일한 패턴을 따릅니다: 다른 변수에 값을 할당하면 값이 이동합니다. 힙에 데이터를 포함하는 변수가 스코프를 벗어나면, 데이터의 소유권이 다른 변수로 이동하지 않는 한 <code>drop</code>에 의해 값이 정리됩니다.</p>
<p>이 방법이 작동하기는 하지만, 모든 함수에서 소유권을 가져갔다가 다시 반환하는 것은 조금 번거롭습니다. 함수가 소유권을 가져가지 않고 값을 사용하게 하려면 어떻게 해야 할까요? 다시 사용하고 싶을 때 전달한 모든 것을 다시 돌려받아야 한다는 점과, 함수 본문에서 발생한 반환하고 싶은 모든 데이터까지 돌려받아야 한다는 점은 꽤 짜증스러운 일입니다.</p>
<p>러스트는 목록 4-5에 표시된 것처럼 튜플을 사용하여 여러 값을 반환할 수 있게 해줍니다.</p>
<Listing number="4-5" file-name="src/main.rs" caption="Returning ownership of parameters">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("'{s2}'의 길이는 {len}입니다.");
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len()은 String의 길이를 반환합니다

    (s, length)
}</code></pre></pre>
</Listing>
<p>하지만 이는 너무 형식적이고 일반적이어야 할 개념에 대해 너무 많은 작업이 필요합니다. 다행히도 러스트에는 소유권을 이전하지 않고 값을 사용할 수 있는 _참조(references)_라는 기능이 있습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="참조와-대여"><a class="header" href="#참조와-대여">참조와 대여</a></h2>
<p>목록 4-5의 튜플 코드의 문제는 <code>String</code>이 <code>calculate_length</code>로 이동되었기 때문에 <code>calculate_length</code> 호출 후에도 <code>String</code>을 계속 사용하려면 호출한 함수로 다시 반환해야 한다는 점입니다. 대신 <code>String</code> 값에 대한 참조를 제공할 수 있습니다. _참조_는 포인터와 유사하게 해당 주소에 저장된 데이터에 접근하기 위해 따라갈 수 있는 주소입니다. 해당 데이터는 다른 변수가 소유하고 있습니다. 포인터와 달리 참조는 참조의 수명 동안 특정 타입의 유효한 값을 가리키는 것이 보장됩니다.</p>
<p>소유권을 가져가는 대신 객체에 대한 참조를 매개변수로 사용하는 <code>calculate_length</code> 함수를 정의하고 사용하는 방법은 다음과 같습니다.</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&amp;s1);

    println!("{s1}"의 길이는 {len}입니다.);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}</code></pre></pre>
</Listing>
<p>첫째, 변수 선언과 함수 반환 값의 모든 튜플 코드가 사라진 것을 확인하세요. 둘째, <code>calculate_length</code>에 <code>&amp;s1</code>을 전달하고, 정의에서는 <code>String</code> 대신 <code>&amp;String</code>을 받는다는 점에 유의하세요. 이 앰퍼샌드(&amp;)는 _참조_를 나타내며, 소유권을 가져가지 않고 어떤 값을 참조할 수 있게 해줍니다. 그림 4-6은 이 개념을 묘사합니다.</p>
<img alt="세 개의 테이블: s에 대한 테이블은 s1에 대한 테이블 포인터만 포함합니다. s1에 대한 테이블은 s1의 스택 데이터를 포함하고 힙의 문자열 데이터를 가리킵니다." src="img/trpl04-06.svg" class="center" />
<span class="caption">그림 4-6: `String s1`을 가리키는 `&String s` 도식</span>
<blockquote>
<p>참고: <code>&amp;</code>를 사용하는 참조의 반대는 _역참조(dereferencing)_이며, 역참조 연산자인 <code>*</code>를 통해 수행됩니다. 8장에서 역참조 연산자의 몇 가지 사용 사례를 살펴보고, 15장에서 역참조의 세부 사항을 논의할 것입니다.</p>
</blockquote>
<p>여기서 함수 호출을 자세히 살펴보겠습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");

    let len = calculate_length(&amp;s1);
<span class="boring">
</span><span class="boring">    println!("{s1}"의 길이는 {len}입니다.);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn calculate_length(s: &amp;String) -&gt; usize {
</span><span class="boring">    s.len()
</span><span class="boring">}</span></code></pre></pre>
<p><code>&amp;s1</code> 구문을 사용하면 <code>s1</code> 값을 _참조_하지만 소유하지는 않는 참조를 생성할 수 있습니다. 참조가 소유권을 갖지 않기 때문에, 참조 사용이 중단되어도 참조가 가리키는 값은 드롭되지 않습니다.</p>
<p>마찬가지로, 함수의 시그니처에서 <code>&amp;</code>를 사용하여 매개변수 <code>s</code>의 타입이 참조임을 나타냅니다. 설명을 위한 주석을 추가해 보겠습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    let s1 = String::from("hello");
</span><span class="boring">
</span><span class="boring">    let len = calculate_length(&amp;s1);
</span><span class="boring">
</span><span class="boring">    println!("{s1}"의 길이는 {len}입니다.);
</span><span class="boring">}
</span><span class="boring">
</span>fn calculate_length(s: &amp;String) -&gt; usize { // s는 String에 대한 참조입니다
    s.len()
} // 여기서 s가 스코프를 벗어납니다. 하지만 s는 참조하는 것에 대한 소유권이 없으므로,
  // 값이 드롭되지 않습니다.</code></pre></pre>
<p>변수 <code>s</code>가 유효한 스코프는 여느 함수 매개변수의 스코프와 같지만, <code>s</code>가 소유권을 갖고 있지 않기 때문에 <code>s</code> 사용이 끝날 때 참조가 가리키는 값은 드롭되지 않습니다. 함수가 실제 값 대신 참조를 매개변수로 사용하면 소유권이 없으므로, 소유권을 되돌려주기 위해 값을 반환할 필요도 없습니다.</p>
<p>We call the action of creating a reference <em>borrowing</em>. As in real life, if a person owns something, you can borrow it from them. When you’re done, you have to give it back. You don’t own it.</p>
<p>그렇다면 빌린 것을 수정하려고 하면 어떻게 될까요? 목록 4-6의 코드를 시도해 보세요. 미리 말씀드리자면, 작동하지 않습니다!</p>
<Listing number="4-6" file-name="src/main.rs" caption="Attempting to modify a borrowed value">
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let s = String::from("hello");

    change(&amp;s);
}

fn change(some_string: &amp;String) {
    some_string.push_str(", world");
}</code></pre>
</Listing>
<p>발생하는 오류는 다음과 같습니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference
 --&gt; src/main.rs:8:5
  |
8 |     some_string.push_str(", world");
  |     ^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable
  |
help: consider changing this to be a mutable reference
  |
7 | fn change(some_string: &amp;mut String) {
  |                         +++

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>변수가 기본적으로 불변인 것처럼 참조도 마찬가지입니다. 참조하는 것을 수정할 수 없습니다.</p>
<h3 id="가변-참조"><a class="header" href="#가변-참조">가변 참조</a></h3>
<p>목록 4-6의 코드를 약간 수정하여 _가변 참조(mutable reference)_를 사용하면 빌린 값을 수정할 수 있습니다.</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut s = String::from("hello");

    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(", world");
}</code></pre></pre>
</Listing>
<p>먼저 <code>s</code>를 <code>mut</code>로 변경합니다. 그런 다음 <code>change</code> 함수를 호출하는 곳에서 <code>&amp;mut s</code>로 가변 참조를 생성하고, 함수의 시그니처를 <code>some_string: &amp;mut String</code>으로 업데이트하여 가변 참조를 받게 합니다. 이를 통해 <code>change</code> 함수가 빌린 값을 수정할 것임을 아주 명확하게 나타낼 수 있습니다.</p>
<p>가변 참조에는 한 가지 큰 제약이 있습니다: 어떤 값에 대한 가변 참조가 있다면, 그 값에 대한 다른 참조는 가질 수 없습니다. <code>s</code>에 대한 두 개의 가변 참조를 생성하려고 시도하는 다음 코드는 실패합니다:</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    println!("{}, {}", r1, r2);
<span class="boring">}</span></code></pre>
</Listing>
<p>발생하는 오류는 다음과 같습니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; src/main.rs:5:14
  |
4 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 |
7 |     println!("{}, {}", r1, r2);
  |                        -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>이 오류는 한 번에 둘 이상의 가변 참조를 가질 수 없기 때문에 이 코드가 유효하지 않다고 말합니다. 첫 번째 가변 참조는 <code>r1</code>에 있으며 <code>println!</code>에서 사용될 때까지 지속되어야 하지만, 가변 참조의 생성과 사용 사이에 <code>r1</code>과 동일한 데이터를 빌리는 다른 가변 참조를 <code>r2</code>에서 생성하려고 시도했습니다.</p>
<p>동일한 데이터에 대해 동시에 여러 가변 참조를 방지하는 제약 조건은 가변성을 허용하되 매우 통제된 방식으로 허용합니다. 대부분의 언어에서는 원할 때 언제든지 수정할 수 있기 때문에 새로운 러스트 사용자(Rustaceans)들이 힘들어하는 부분입니다. 이 제약 조건의 이점은 러스트가 컴파일 타임에 데이터 경합을 방지할 수 있다는 것입니다. _데이터 경합(data race)_은 레이스 조건과 유사하며 다음 세 가지 동작이 발생할 때 발생합니다:</p>
<ul>
<li>둘 이상의 포인터가 동시에 동일한 데이터에 접근합니다.</li>
<li>포인터 중 하나 이상이 데이터를 쓰는 데 사용됩니다.</li>
<li>데이터 접근을 동기화하는 메커니즘이 사용되지 않습니다.</li>
</ul>
<p>데이터 경합은 정의되지 않은 동작을 유발하며 런타임에 추적하려고 할 때 진단하고 수정하기 어려울 수 있습니다. 러스트는 데이터 경합이 있는 코드의 컴파일을 거부함으로써 이 문제를 방지합니다!</p>
<p>항상 그렇듯이 중괄호를 사용하여 새로운 스코프를 만들 수 있으며, 이를 통해 여러 가변 참조를 가질 수 있습니다. 다만 _동시_에 가질 수 없을 뿐입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    {
        let r1 = &amp;mut s;
    } // r1은 여기서 스코프를 벗어나므로, 문제 없이 새로운 참조를 만들 수 있습니다.

    let r2 = &amp;mut s;
<span class="boring">}</span></code></pre></pre>
<p>러스트는 가변 참조와 불변 참조를 혼용하는 것에 대해서도 유사한 규칙을 강제합니다. 다음 코드는 오류를 발생시킵니다:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    let r1 = &amp;s; // 문제 없음
    let r2 = &amp;s; // 문제 없음
    let r3 = &amp;mut s; // 큰 문제

    println!("{}, {}, 그리고 {}", r1, r2, r3);
<span class="boring">}</span></code></pre>
<p>발생하는 오류는 다음과 같습니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:14
  |
4 |     let r1 = &amp;s; // no problem
  |              -- immutable borrow occurs here
5 |     let r2 = &amp;s; // no problem
6 |     let r3 = &amp;mut s; // BIG PROBLEM
  |              ^^^^^^ mutable borrow occurs here
7 |
8 |     println!("{}, {}, and {}", r1, r2, r3);
  |                                -- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>와! 또한 동일한 값에 대해 불변 참조가 있는 동안에는 가변 참조를 가질 수 없습니다.</p>
<p>불변 참조를 사용하는 사용자는 자신이 사용 중인 값이 갑자기 변할 것이라고 기대하지 않습니다! 하지만 데이터를 읽기만 하는 사람은 다른 사람이 데이터를 읽는 방식에 영향을 줄 수 없으므로, 여러 개의 불변 참조를 갖는 것은 허용됩니다.</p>
<p>참조의 스코프는 참조가 도입된 곳에서 시작하여 해당 참조가 마지막으로 사용된 시점까지 계속된다는 점에 유의하세요. 예를 들어, 다음 코드는 불변 참조의 마지막 사용이 가변 참조가 도입되기 전인 <code>println!</code>에 있기 때문에 컴파일됩니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    let r1 = &amp;s; // 문제 없음
    let r2 = &amp;s; // 문제 없음
    println!("{r1} 그리고 {r2}");
    // 변수 r1과 r2는 이 지점 이후로 사용되지 않습니다.

    let r3 = &amp;mut s; // 문제 없음
    println!("{r3}");
<span class="boring">}</span></code></pre></pre>
<p>불변 참조 <code>r1</code>과 <code>r2</code>의 스코프는 이들이 마지막으로 사용되는 <code>println!</code> 이후에 종료되며, 이는 가변 참조 <code>r3</code>가 생성되기 전입니다. 이들의 스코프는 겹치지 않으므로, 이 코드는 허용됩니다. 컴파일러는 참조가 스코프가 끝나기 전의 어느 지점 이후로 더 이상 사용되지 않음을 감지할 수 있습니다.</p>
<p>때때로 빌림(borrowing) 오류가 짜증스러울 수도 있지만, 이는 러스트 컴파일러가 잠재적인 버그를 조기에(런타임이 아닌 컴파일 타임에) 지적하고 정확히 어디가 문제인지 알려주는 것임을 기억하세요. 그러면 데이터가 왜 생각과 다른지 추적할 필요가 없어집니다.</p>
<h3 id="댕글링-참조"><a class="header" href="#댕글링-참조">댕글링 참조</a></h3>
<p>포인터가 있는 언어에서는 어떤 메모리를 해제하면서 해당 메모리에 대한 포인터를 유지함으로써, 다른 사람에게 이미 할당되었을 수도 있는 메모리 위치를 가리키는 _댕글링 포인터(dangling pointer)_를 실수로 생성하기 쉽습니다. 반면 러스트에서 컴파일러는 참조가 결코 댕글링 참조가 되지 않음을 보장합니다. 만약 어떤 데이터에 대한 참조가 있다면, 컴파일러는 해당 데이터가 참조보다 먼저 스코프를 벗어나지 않도록 보장합니다.</p>
<p>댕글링 참조를 생성하여 러스트가 어떻게 컴파일 타임 오류로 이를 방지하는지 살펴봅시다:</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from("hello");

    &amp;s
}</code></pre>
</Listing>
<p>발생하는 오류는 다음과 같습니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:5:16
  |
5 | fn dangle() -&gt; &amp;String {
  |                ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime, but this is uncommon unless you're returning a borrowed value from a `const` or a `static`
  |
5 | fn dangle() -&gt; &amp;'static String {
  |                 +++++++
help: instead, you are more likely to want to return an owned value
  |
5 - fn dangle() -&gt; &amp;String {
5 + fn dangle() -&gt; String {
  |

error[E0515]: cannot return reference to local variable `s`
 --&gt; src/main.rs:8:5
  |
8 |     &amp;s
  |     ^^ returns a reference to data owned by the current function

Some errors have detailed explanations: E0106, E0515.
For more information about an error, try `rustc --explain E0106`.
error: could not compile `ownership` (bin "ownership") due to 2 previous errors
</code></pre>
<p>이 오류 메시지는 우리가 아직 다루지 않은 기능인 라이프타임(lifetimes)을 언급하고 있습니다. 라이프타임에 대해서는 10장에서 자세히 다룰 것입니다. 하지만 라이프타임에 관한 부분을 무시하더라도, 이 메시지에는 이 코드가 왜 문제인지에 대한 핵심이 포함되어 있습니다.</p>
<pre><code class="language-text">this function's return type contains a borrowed value, but there is no value
for it to be borrowed from
</code></pre>
<p><code>dangle</code> 코드의 각 단계에서 정확히 어떤 일이 일어나는지 자세히 살펴보겠습니다:</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let reference_to_nothing = dangle();
</span><span class="boring">}
</span><span class="boring">
</span>fn dangle() -&gt; &amp;String { // dangle은 String에 대한 참조를 반환합니다

    let s = String::from("hello"); // s는 새로운 String입니다

    &amp;s // 우리는 String s에 대한 참조를 반환합니다
} // 여기서 s는 스코프를 벗어나고 드롭되므로, 그 메모리는 사라집니다.
  // 위험합니다!</code></pre>
</Listing>
<p><code>s</code>는 <code>dangle</code> 내부에서 생성되었으므로, <code>dangle</code> 코드가 끝나면 <code>s</code>는 할당 해제됩니다. 하지만 우리는 <code>s</code>에 대한 참조를 반환하려고 시도했습니다. 이는 이 참조가 유효하지 않은 <code>String</code>을 가리키게 된다는 것을 의미합니다. 좋지 않군요! 러스트는 우리가 이렇게 하도록 내버려 두지 않습니다.</p>
<p>여기서 해결책은 <code>String</code>을 직접 반환하는 것입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    let string = no_dangle();
</span><span class="boring">}
</span><span class="boring">
</span>fn no_dangle() -&gt; String {
    let s = String::from("hello");

    s
}</code></pre></pre>
<p>이 코드는 문제없이 작동합니다. 소유권은 밖으로 이동되었고, 아무것도 할당 해제되지 않습니다.</p>
<h3 id="참조의-규칙"><a class="header" href="#참조의-규칙">참조의 규칙</a></h3>
<p>참조에 대해 논의한 내용을 요약해 보겠습니다:</p>
<ul>
<li>어느 시점에서든, 하나의 가변 참조 <em>또는</em> 여러 개의 불변 참조 중 하나만 가질 수 있습니다.</li>
<li>참조는 항상 유효해야 합니다.</li>
</ul>
<p>다음으로, 다른 종류의 참조인 슬라이스(slices)를 살펴보겠습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="슬라이스-타입"><a class="header" href="#슬라이스-타입">슬라이스 타입</a></h2>
<p>_슬라이스(slices)_는 <a href="ch08-00-common-collections.html">컬렉션(collection)</a> 전체가 아니라 컬렉션 내의 연속된 요소 시퀀스를 참조할 수 있게 해줍니다. 슬라이스는 참조의 일종이므로 소유권을 갖지 않습니다.</p>
<p>여기에 작은 프로그래밍 문제가 있습니다: 공백으로 구분된 단어들의 문자열을 받아서 그 문자열에서 찾은 첫 번째 단어를 반환하는 함수를 작성하세요. 만약 함수가 문자열에서 공백을 찾지 못하면, 전체 문자열이 하나의 단어라는 뜻이므로 전체 문자열을 반환해야 합니다.</p>
<p>슬라이스가 해결할 문제를 이해하기 위해, 슬라이스를 사용하지 않고 이 함수의 시그니처를 어떻게 작성할지 살펴보겠습니다.</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; ?</code></pre>
<p><code>first_word</code> 함수는 <code>&amp;String</code>을 매개변수로 가집니다. 소유권이 필요 없으므로 이 방식은 적절합니다. (관용적인 러스트에서 함수는 꼭 필요한 경우가 아니면 인수의 소유권을 가져가지 않는데, 그 이유는 앞으로 진행하면서 명확해질 것입니다!) 그런데 무엇을 반환해야 할까요? 문자열의 일부를 나타낼 방법이 마땅치 않습니다. 하지만 공백으로 표시된 단어 끝의 인덱스를 반환할 수는 있을 것입니다. 목록 4-7과 같이 시도해 봅시다.</p>
<Listing number="4-7" file-name="src/main.rs" caption="The `first_word` function that returns a byte index value into the `String` parameter">
<pre><pre class="playground"><code class="language-rust edition2021">fn first_word(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p><code>String</code>의 요소를 하나씩 훑으며 값이 공백인지 확인해야 하므로, <code>as_bytes</code> 메서드를 사용하여 <code>String</code>을 바이트 배열로 변환하겠습니다.</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span>    let bytes = s.as_bytes();
<span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>다음으로, <code>iter</code> 메서드를 사용하여 바이트 배열에 대한 반복자(iterator)를 생성합니다:</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span>    for (i, &amp;item) in bytes.iter().enumerate() {
<span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>반복자에 대해서는 <a href="ch13-02-iterators.html">13장</a><!-- ignore -->에서 더 자세히 다룰 것입니다. 지금은 <code>iter</code>가 컬렉션의 각 요소를 반환하는 메서드이며, <code>enumerate</code>가 <code>iter</code>의 결과를 감싸서 각 요소를 튜플의 일부로 반환한다는 점만 알아두세요. <code>enumerate</code>가 반환하는 튜플의 첫 번째 요소는 인덱스이고, 두 번째 요소는 해당 요소에 대한 참조입니다. 이는 우리가 직접 인덱스를 계산하는 것보다 조금 더 편리합니다.</p>
<p><code>enumerate</code> 메서드는 튜플을 반환하므로, 패턴을 사용하여 그 튜플을 해체(destructure)할 수 있습니다. 패턴에 대해서는 <a href="ch06-02-match.html#patterns-that-bind-to-values">6장</a><!-- ignore -->에서 더 자세히 논의할 것입니다. <code>for</code> 루프에서 튜플의 인덱스에 대해서는 <code>i</code>를, 튜플의 단일 바이트에 대해서는 <code>&amp;item</code>을 사용하는 패턴을 지정합니다. <code>.iter().enumerate()</code>로부터 요소에 대한 참조를 얻기 때문에, 패턴에서 <code>&amp;</code>를 사용합니다.</p>
<p><code>for</code> 루프 내부에서 바이트 리터럴 문법을 사용하여 공백을 나타내는 바이트를 찾습니다. 공백을 찾으면 해당 위치를 반환합니다. 그렇지 않으면 <code>s.len()</code>을 사용하여 문자열의 길이를 반환합니다.</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span>        if item == b' ' {
            return i;
        }
    }

    s.len()
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>이제 문자열에서 첫 번째 단어 끝의 인덱스를 찾아낼 수 있게 되었지만, 문제가 하나 있습니다. <code>usize</code>를 독자적으로 반환하고 있는데, 이 숫자는 <code>&amp;String</code>의 맥락 안에서만 의미가 있습니다. 즉, <code>String</code>과는 별개의 값이기 때문에 나중에도 이 인덱스가 유효할 것이라는 보장이 없습니다. 목록 4-7의 <code>first_word</code> 함수를 사용하는 목록 4-8의 프로그램을 살펴봅시다.</p>
<Listing number="4-8" file-name="src/main.rs" caption="Storing the result from calling the `first_word` function and then changing the `String` contents">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&amp;s); // word는 5라는 값을 갖게 됩니다

    s.clear(); // 이 코드는 String을 비워서 ""와 같게 만듭니다

    // word는 여기서 여전히 5라는 값을 갖지만, s에는 이제 5라는 값과 함께
    // 의미 있게 사용할 수 있는 내용이 없으므로, word는 이제
    // 완전히 유효하지 않습니다!
}</code></pre></pre>
</Listing>
<p>이 프로그램은 아무런 오류 없이 컴파일되며, <code>s.clear()</code>를 호출한 뒤에 <code>word</code>를 사용하더라도 마찬가지입니다. <code>word</code>는 <code>s</code>의 상태와 전혀 연결되어 있지 않기 때문에, <code>word</code>는 여전히 <code>5</code>라는 값을 담고 있습니다. 변수 <code>s</code>와 함께 이 <code>5</code>라는 값을 사용하여 첫 번째 단어를 추출해내려 할 수도 있겠지만, <code>word</code>에 <code>5</code>를 저장한 이후로 <code>s</code>의 내용이 바뀌었기 때문에 이는 버그가 될 것입니다.</p>
<p><code>word</code>의 인덱스가 <code>s</code>의 데이터와 동기화되지 않을까 봐 걱정하는 것은 번거롭고 오류가 발생하기 쉽습니다! <code>second_word</code> 함수를 작성한다면 이러한 인덱스 관리는 훨씬 더 취약해질 것입니다. 그 함수의 시그니처는 아마 다음과 같을 것입니다:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; (usize, usize) {</code></pre>
<p>이제 우리는 시작 인덱스_와_ 끝 인덱스를 추적하게 되었고, 특정 상태의 데이터로부터 계산되었으면서도 그 상태에 전혀 묶여 있지 않은 값들이 더 많아졌습니다. 서로 동기화되어야 할 관련 없는 변수 세 개가 여기저기 떠다니게 된 것입니다.</p>
<p>다행히 러스트는 이 문제에 대한 해결책인 문자열 슬라이스를 가지고 있습니다.</p>
<h3 id="문자열-슬라이스"><a class="header" href="#문자열-슬라이스">문자열 슬라이스</a></h3>
<p>_문자열 슬라이스_는 <code>String</code>의 일부에 대한 참조이며, 다음과 같습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s = String::from("hello world");

    let hello = &amp;s[0..5];
    let world = &amp;s[6..11];
<span class="boring">}</span></code></pre></pre>
<p>전체 <code>String</code>에 대한 참조라기보다는, <code>hello</code>는 추가 <code>[0..5]</code> 비트에 지정된 <code>String</code>의 일부에 대한 참조입니다. 우리는 대괄호 안에 <code>[starting_index..ending_index]</code>를 지정하여 범위를 사용하여 슬라이스를 생성합니다. 여기서 _<code>starting_index</code>_는 슬라이스의 첫 번째 위치이고 _<code>ending_index</code>_는 슬라이스의 마지막 위치보다 하나 더 큰 값입니다. 내부적으로 슬라이스 데이터 구조는 시작 위치와 슬라이스의 길이를 저장하며, 이는 _<code>ending_index</code>_에서 _<code>starting_index</code>_를 뺀 값에 해당합니다. 따라서 <code>let world = &amp;s[6..11];</code>의 경우, <code>world</code>는 <code>s</code>의 인덱스 6에 있는 바이트에 대한 포인터와 길이 값 <code>5</code>를 포함하는 슬라이스가 됩니다.</p>
<p>그림 4-7은 이를 다이어그램으로 보여줍니다.</p>
<p><img alt="세 개의 테이블: s의 스택 데이터를 나타내는 테이블은 힙에 있는 문자열 데이터 &quot;hello world&quot; 테이블의 인덱스 0에 있는 바이트를 가리킵니다. 세 번째 테이블은 슬라이스 world의 스택 데이터를 나타내며, 길이 값은 5이고 힙 데이터 테이블의 바이트 6을 가리킵니다."
src="img/trpl04-07.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">그림 4-7: <code>String</code>의 일부를 참조하는 문자열 슬라이스</span></p>
<p>러스트의 <code>..</code> 범위 구문을 사용하면, 인덱스 0에서 시작하고 싶을 때 두 개의 점 앞에 있는 값을 생략할 수 있습니다. 즉, 다음은 동일합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
<span class="boring">}</span></code></pre></pre>
<p>마찬가지로, 슬라이스에 <code>String</code>의 마지막 바이트가 포함되면, 뒤에 오는 숫자를 생략할 수 있습니다. 즉, 다음은 동일합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");

let len = s.len();

let slice = &amp;s[3..len];
let slice = &amp;s[3..];
<span class="boring">}</span></code></pre></pre>
<p>전체 문자열의 슬라이스를 가져오기 위해 두 값 모두를 생략할 수도 있습니다. 따라서 다음은 동일합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");

let len = s.len();

let slice = &amp;s[0..len];
let slice = &amp;s[..];
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>참고: 문자열 슬라이스 범위 인덱스는 유효한 UTF-8 문자 경계에서 발생해야 합니다. 멀티바이트 문자 중간에 문자열 슬라이스를 생성하려고 하면 프로그램이 오류와 함께 종료됩니다. 문자열 슬라이스를 소개하기 위해 이 섹션에서는 ASCII만 가정합니다. UTF-8 처리에 대한 더 자세한 논의는 8장의 <a href="ch08-02-strings.html#storing-utf-8-encoded-text-with-strings">“문자열로 UTF-8 인코딩된 텍스트 저장하기”</a><!-- ignore --> 섹션에 있습니다.</p>
</blockquote>
<p>이 모든 정보를 염두에 두고, <code>first_word</code>를 슬라이스를 반환하도록 다시 작성해 봅시다. "문자열 슬라이스"를 나타내는 타입은 <code>&amp;str</code>로 작성됩니다:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021">fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p>목록 4-7에서 했던 것과 동일한 방식으로 공백의 첫 번째 발생을 찾아 단어 끝의 인덱스를 얻습니다. 공백을 찾으면 문자열의 시작과 공백의 인덱스를 시작 및 끝 인덱스로 사용하여 문자열 슬라이스를 반환합니다.</p>
<p>이제 <code>first_word</code>를 호출하면, 기본 데이터에 연결된 단일 값을 반환받습니다. 이 값은 슬라이스의 시작점에 대한 참조와 슬라이스 내 요소의 수로 구성됩니다.</p>
<p>슬라이스를 반환하는 것은 <code>second_word</code> 함수에서도 작동할 것입니다:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; &amp;str {</code></pre>
<p>이제 컴파일러가 <code>String</code>에 대한 참조가 유효하게 유지되도록 보장하기 때문에 훨씬 더 망가뜨리기 어려운 간단한 API를 갖게 되었습니다. 목록 4-8의 프로그램에서 첫 번째 단어의 끝 인덱스를 얻었지만 문자열을 지워서 인덱스가 유효하지 않게 되었던 버그를 기억하세요? 그 코드는 논리적으로는 잘못되었지만 즉각적인 오류를 보여주지는 않았습니다. 비워진 문자열과 함께 첫 번째 단어 인덱스를 계속 사용하려고 하면 나중에 문제가 나타났을 것입니다. 슬라이스는 이러한 버그를 불가능하게 만들고 코드에 문제가 있음을 훨씬 더 빨리 알 수 있도록 합니다. <code>first_word</code>의 슬라이스 버전을 사용하면 컴파일 타임 오류가 발생합니다:</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn first_word(s: &amp;String) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&amp;s);

    s.clear(); // 오류!

    println!("첫 번째 단어는: {word}");
}</code></pre>
</Listing>
<p>다음은 컴파일러 오류입니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:18:5
   |
16 |     let word = first_word(&amp;s);
   |                           -- immutable borrow occurs here
17 |
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 |
20 |     println!("the first word is: {word}");
   |                                  ------ immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>빌림 규칙에서 기억하듯이, 어떤 것에 대한 불변 참조가 있다면 가변 참조도 가질 수 없습니다. <code>clear</code>는 <code>String</code>을 잘라내야 하므로 가변 참조를 얻어야 합니다. <code>clear</code> 호출 후의 <code>println!</code>은 <code>word</code>의 참조를 사용하므로, 불변 참조는 그 시점에도 활성화되어 있어야 합니다. 러스트는 <code>clear</code>의 가변 참조와 <code>word</code>의 불변 참조가 동시에 존재하는 것을 허용하지 않으며, 컴파일이 실패합니다. 러스트는 API를 사용하기 쉽게 만들었을 뿐만 아니라, 컴파일 타임에 전체 오류 클래스를 제거했습니다!</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="string-literals-are-slices"></a></p>
<h4 id="슬라이스로서의-문자열-리터럴"><a class="header" href="#슬라이스로서의-문자열-리터럴">슬라이스로서의 문자열 리터럴</a></h4>
<p>문자열 리터럴이 바이너리 내부에 저장된다는 것을 기억하세요. 이제 슬라이스에 대해 알았으니, 문자열 리터럴을 제대로 이해할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = "헬로, 월드!";
<span class="boring">}</span></code></pre></pre>
<p>여기서 <code>s</code>의 타입은 <code>&amp;str</code>입니다: 이는 바이너리의 특정 지점을 가리키는 슬라이스입니다. 이것이 문자열 리터럴이 불변인 이유이기도 합니다. <code>&amp;str</code>은 불변 참조입니다.</p>
<h4 id="매개변수로서의-문자열-슬라이스"><a class="header" href="#매개변수로서의-문자열-슬라이스">매개변수로서의 문자열 슬라이스</a></h4>
<p>리터럴과 <code>String</code> 값의 슬라이스를 가져올 수 있다는 것을 알면 <code>first_word</code>에 대한 한 가지 개선점으로 이어지며, 그것은 바로 시그니처입니다:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; &amp;str {</code></pre>
<p>더 숙련된 러스트 개발자는 목록 4-9에 표시된 시그니처를 대신 작성할 것입니다. 왜냐하면 <code>&amp;String</code> 값과 <code>&amp;str</code> 값 모두에 동일한 함수를 사용할 수 있기 때문입니다.</p>
<Listing number="4-9" caption="Improving the `first_word` function by using a string slice for the type of the `s` parameter">
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
<span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from("hello world");
</span><span class="boring">
</span><span class="boring">    // `first_word`는 String의 슬라이스에 대해 작동합니다. 부분적이든 전체이든 상관없습니다.
</span><span class="boring">    let word = first_word(&amp;my_string[0..6]);
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">    // `first_word`는 String에 대한 참조에 대해서도 작동하며, 이는 String의
</span><span class="boring">    // 전체 슬라이스와 동일합니다.
</span><span class="boring">    let word = first_word(&amp;my_string);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = "hello world";
</span><span class="boring">
</span><span class="boring">    // `first_word`는 문자열 리터럴의 슬라이스에 대해 작동합니다. 부분적이든
</span><span class="boring">    // 전체이든 상관없습니다.
</span><span class="boring">    let word = first_word(&amp;my_string_literal[0..6]);
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // 문자열 리터럴은 이미 문자열 슬라이스이기 때문에,
</span><span class="boring">    // 슬라이스 구문 없이도 잘 작동합니다!
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}</span></code></pre>
</Listing>
<p>문자열 슬라이스가 있다면 이를 직접 전달할 수 있습니다. <code>String</code>이 있다면 <code>String</code>의 슬라이스나 <code>String</code>에 대한 참조를 전달할 수 있습니다. 이러한 유연성은 15장의 <a href="ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods">“함수와 메서드를 이용한 암시적 역참조 강제”</a><!--ignore--> 섹션에서 다룰 기능인 _역참조 강제(deref coercions)_를 활용합니다.</p>
<p>함수가 <code>String</code>에 대한 참조 대신 문자열 슬라이스를 받도록 정의하면, 기능을 전혀 잃지 않으면서도 API를 더 범용적이고 유용하게 만들 수 있습니다:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn first_word(s: &amp;str) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let my_string = String::from("hello world");

    // `first_word`는 String의 슬라이스에 대해 작동합니다. 부분적이든 전체이든 상관없습니다.
    let word = first_word(&amp;my_string[0..6]);
    let word = first_word(&amp;my_string[..]);
    // `first_word`는 String에 대한 참조에 대해서도 작동하며, 이는 String의
    // 전체 슬라이스와 동일합니다.
    let word = first_word(&amp;my_string);

    let my_string_literal = "hello world";

    // `first_word`는 문자열 리터럴의 슬라이스에 대해 작동합니다. 부분적이든
    // 전체이든 상관없습니다.
    let word = first_word(&amp;my_string_literal[0..6]);
    let word = first_word(&amp;my_string_literal[..]);

    // 문자열 리터럴은 이미 문자열 슬라이스이기 때문에,
    // 슬라이스 구문 없이도 잘 작동합니다!
    let word = first_word(my_string_literal);
}</code></pre></pre>
</Listing>
<h3 id="다른-슬라이스들"><a class="header" href="#다른-슬라이스들">다른 슬라이스들</a></h3>
<p>문자열 슬라이스는 예상하셨겠지만 문자열에 특화되어 있습니다. 하지만 더 범용적인 슬라이스 타입도 있습니다. 다음 배열을 살펴보세요:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
<span class="boring">}</span></code></pre></pre>
<p>문자열의 일부를 참조하고 싶을 때와 마찬가지로, 배열의 일부를 참조하고 싶을 때가 있습니다. 다음과 같이 할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];

assert_eq!(slice, &amp;[2, 3]);
<span class="boring">}</span></code></pre></pre>
<p>이 슬라이스는 <code>&amp;[i32]</code> 타입을 갖습니다. 이는 첫 번째 요소에 대한 참조와 길이를 저장함으로써 문자열 슬라이스와 동일한 방식으로 작동합니다. 이런 종류의 슬라이스는 다른 모든 종류의 컬렉션에 대해서도 사용하게 될 것입니다. 8장에서 벡터를 다룰 때 이러한 컬렉션들에 대해 자세히 논의하겠습니다.</p>
<h2 id="요약-3"><a class="header" href="#요약-3">요약</a></h2>
<p>소유권, 빌림, 그리고 슬라이스 개념은 컴파일 타임에 러스트 프로그램의 메모리 안전성을 보장합니다. 러스트 언어는 다른 시스템 프로그래밍 언어와 마찬가지로 메모리 사용에 대한 제어권을 제공하지만, 데이터 소유자가 스코프를 벗어날 때 자동으로 데이터를 정리해주므로 이러한 제어를 위해 추가적인 코드를 작성하고 디버깅할 필요가 없습니다.</p>
<p>소유권은 러스트의 다른 많은 부분들이 작동하는 방식에 영향을 미치므로, 책의 나머지 부분에서도 이러한 개념들을 계속 이야기할 것입니다. 이제 5장으로 넘어가서 <code>struct</code>를 사용해 데이터 조각들을 그룹화하는 방법을 살펴보겠습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="구조체를-사용하여-관련-데이터-구조화하기"><a class="header" href="#구조체를-사용하여-관련-데이터-구조화하기">구조체를 사용하여 관련 데이터 구조화하기</a></h1>
<p><em>구조체(struct)</em> 혹은 _structure_는 여러 개의 관련 있는 값들을 하나로 묶고 이름을 붙여서 의미 있는 그룹을 만들 수 있게 해주는 커스텀 데이터 타입입니다. 만약 객체 지향 언어에 익숙하시다면, _구조체_는 객체의 데이터 속성과 비슷합니다. 이번 장에서는 여러분이 이미 알고 있는 튜플과 구조체를 비교하고 대조하여, 언제 구조체를 사용하는 것이 데이터를 그룹화하기에 더 좋은 방법인지 보여드리겠습니다.</p>
<p>구조체를 정의하고 인스턴스화하는 방법을 보여드리겠습니다. 또한 구조체 타입과 연관된 동작을 지정하기 위해 연관 함수, 특히 _메서드(methods)_라고 불리는 종류의 연관 함수를 정의하는 방법에 대해 논의할 것입니다. 구조체와 열거형(6장에서 다룸)은 러스트의 컴파일 타임 타입 검사 기능을 최대한 활용하여 프로그램의 도메인에 맞는 새로운 타입을 만들기 위한 기본 구성 요소입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="구조체-정의하고-인스턴스화하기"><a class="header" href="#구조체-정의하고-인스턴스화하기">구조체 정의하고 인스턴스화하기</a></h2>
<p>구조체는 <a href="ch03-02-data-types.html#the-tuple-type">“튜플 타입”</a><!--
ignore --> 섹션에서 논의한 튜플과 유사하게 여러 개의 관련 값을 보유합니다. 튜플과 마찬가지로 구조체의 각 부분은 서로 다른 타입일 수 있습니다. 하지만 튜플과 달리 구조체에서는 각 데이터 조각에 이름을 붙여서 각 값의 의미를 명확히 합니다. 이러한 이름을 추가하면 구조체가 튜플보다 더 유연해집니다. 즉, 인스턴스의 값을 지정하거나 접근할 때 데이터의 순서에 의존할 필요가 없습니다.</p>
<p>구조체를 정의하려면 <code>struct</code> 키워드를 입력하고 구조체 전체의 이름을 짓습니다. 구조체의 이름은 함께 그룹화되는 데이터 조각들의 의미를 잘 나타내야 합니다. 그런 다음 중괄호 안에서 _필드(fields)_라고 부르는 데이터 조각들의 이름과 타입을 정의합니다. 예를 들어, 목록 5-1은 사용자 계정에 대한 정보를 저장하는 구조체를 보여줍니다.</p>
<Listing number="5-1" file-name="src/main.rs" caption="A `User` struct definition">
<pre><pre class="playground"><code class="language-rust edition2021">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p>구조체를 정의한 후 이를 사용하려면, 각 필드에 구체적인 값을 지정하여 해당 구조체의 _인스턴스(instance)_를 생성합니다. 인스턴스를 생성할 때는 구조체의 이름을 말하고, 중괄호 안에 <em>키: 값</em> 쌍을 추가합니다. 여기서 키는 필드의 이름이고 값은 해당 필드에 저장하고자 하는 데이터입니다. 필드를 구조체에서 선언한 순서대로 지정할 필요는 없습니다. 즉, 구조체 정의는 타입에 대한 일반적인 템플릿과 같으며, 인스턴스는 그 템플릿을 특정 데이터로 채워 해당 타입의 값을 생성합니다. 예를 들어, 목록 5-2와 같이 특정 사용자를 선언할 수 있습니다.</p>
<Listing number="5-2" file-name="src/main.rs" caption="Creating an instance of the `User` struct">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };
}</code></pre></pre>
</Listing>
<p>구조체에서 특정 값을 가져오려면 점(.) 표기법을 사용합니다. 예를 들어, 이 사용자의 이메일 주소에 접근하려면 <code>user1.email</code>을 사용합니다. 인스턴스가 가변적(mutable)이라면, 점 표기법을 사용하고 특정 필드에 값을 할당하여 값을 변경할 수 있습니다. 목록 5-3은 가변 <code>User</code> 인스턴스의 <code>email</code> 필드 값을 변경하는 방법을 보여줍니다.</p>
<Listing number="5-3" file-name="src/main.rs" caption="Changing the value in the `email` field of a `User` instance">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };

    user1.email = String::from("anotheremail@example.com");
}</code></pre></pre>
</Listing>
<p>인스턴스 전체가 가변적이어야 한다는 점에 유의하세요. 러스트는 특정 필드만 가변으로 표시하는 것을 허용하지 않습니다. 다른 표현식과 마찬가지로, 함수 본문의 마지막 표현식으로 구조체의 새 인스턴스를 생성하여 해당 인스턴스를 암시적으로 반환할 수 있습니다.</p>
<p>목록 5-4는 주어진 이메일과 사용자 이름을 가진 <code>User</code> 인스턴스를 반환하는 <code>build_user</code> 함수를 보여줍니다. <code>active</code> 필드는 <code>true</code> 값을 갖고, <code>sign_in_count</code>는 <code>1</code> 값을 갖습니다.</p>
<Listing number="5-4" file-name="src/main.rs" caption="A `build_user` function that takes an email and username and returns a `User` instance">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        username: username,
        email: email,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from("someone@example.com"),
</span><span class="boring">        String::from("someusername123"),
</span><span class="boring">    );
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>함수의 매개변수 이름을 구조체의 필드 이름과 동일하게 짓는 것은 합리적이지만, <code>email</code>과 <code>username</code>이라는 필드 이름과 변수 이름을 계속 반복하는 것은 조금 번거로운 일입니다. 구조체에 필드가 더 많았다면 각 이름을 반복하는 것이 훨씬 더 귀찮아졌을 것입니다. 다행히도, 편리한 줄임 문법이 있습니다!</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="using-the-field-init-shorthand-when-variables-and-fields-have-the-same-name"></a></p>
<h3 id="필드-초기화-줄임-문법-사용하기"><a class="header" href="#필드-초기화-줄임-문법-사용하기">필드 초기화 줄임 문법 사용하기</a></h3>
<p>목록 5-4에서 매개변수 이름과 구조체 필드 이름이 완전히 동일하기 때문에, <em>필드 초기화 줄임(field init shorthand)</em> 문법을 사용하여 <code>build_user</code>를 다시 작성할 수 있습니다. 목록 5-5에 나타난 것처럼, 기능은 동일하면서도 <code>username</code>과 <code>email</code>을 반복하지 않아도 됩니다.</p>
<Listing number="5-5" file-name="src/main.rs" caption="A `build_user` function that uses field init shorthand because the `username` and `email` parameters have the same name as struct fields">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        username,
        email,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from("someone@example.com"),
</span><span class="boring">        String::from("someusername123"),
</span><span class="boring">    );
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>여기서 우리는 <code>email</code>이라는 이름의 필드를 가진 <code>User</code> 구조체의 새 인스턴스를 생성하고 있습니다. <code>email</code> 필드의 값을 <code>build_user</code> 함수의 <code>email</code> 매개변수 값으로 설정하려고 합니다. <code>email</code> 필드와 <code>email</code> 매개변수의 이름이 같기 때문에, <code>email: email</code>이라고 쓰는 대신 <code>email</code>만 쓰면 됩니다.</p>
<h3 id="구조체-업데이트-문법을-사용하여-다른-인스턴스로부터-인스턴스-생성하기"><a class="header" href="#구조체-업데이트-문법을-사용하여-다른-인스턴스로부터-인스턴스-생성하기">구조체 업데이트 문법을 사용하여 다른 인스턴스로부터 인스턴스 생성하기</a></h3>
<p>기존 인스턴스의 값 대부분을 포함하면서 일부만 변경하여 새로운 구조체 인스턴스를 생성하는 것이 유용할 때가 많습니다. 이는 _구조체 업데이트 문법(struct update syntax)_을 사용하여 수행할 수 있습니다.</p>
<p>먼저 목록 5-6에서는 업데이트 문법 없이 일반적인 방식으로 <code>user2</code>라는 새로운 <code>User</code> 인스턴스를 생성하는 방법을 보여줍니다. <code>email</code>에 대해서는 새로운 값을 설정하고, 나머지는 목록 5-2에서 생성한 <code>user1</code>의 값들을 그대로 사용합니다.</p>
<Listing number="5-6" file-name="src/main.rs" caption="Creating a new `User` instance using all but one of the values from `user1`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // --생략--
<span class="boring">
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from("someone@example.com"),
</span><span class="boring">        username: String::from("someusername123"),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span>
    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from("another@example.com"),
        sign_in_count: user1.sign_in_count,
    };
}</code></pre></pre>
</Listing>
<p>목록 5-7에 나타난 것처럼, 구조체 업데이트 문법을 사용하면 더 적은 코드로 동일한 효과를 얻을 수 있습니다. <code>..</code> 문법은 명시적으로 설정되지 않은 나머지 필드들이 주어진 인스턴스의 필드와 동일한 값을 가져야 함을 지정합니다.</p>
<Listing number="5-7" file-name="src/main.rs" caption="Using struct update syntax to set a new `email` value for a `User` instance but to use the rest of the values from `user1`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // --생략--
<span class="boring">
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from("someone@example.com"),
</span><span class="boring">        username: String::from("someusername123"),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span>
    let user2 = User {
        email: String::from("another@example.com"),
        ..user1
    };
}</code></pre></pre>
</Listing>
<p>목록 5-7의 코드 또한 <code>email</code> 값은 다르지만 <code>username</code>, <code>active</code>, <code>sign_in_count</code> 필드는 <code>user1</code>과 동일한 값을 갖는 <code>user2</code> 인스턴스를 생성합니다. <code>..user1</code>은 나머지 필드들이 <code>user1</code>의 해당 필드로부터 값을 가져와야 함을 명시하기 위해 반드시 마지막에 와야 합니다. 하지만 구조체 정의에서의 필드 순서와 상관없이, 우리가 원하는 만큼 많은 필드의 값을 임의의 순서로 지정할 수 있습니다.</p>
<p>구조체 업데이트 문법은 할당과 같이 <code>=</code>를 사용한다는 점에 유의하세요. 이는 <a href="ch04-01-what-is-ownership.html#variables-and-data-interacting-with-move">“이동과 상호작용하는 변수와 데이터”</a><!-- ignore --> 섹션에서 보았듯이 데이터를 이동시키기 때문입니다. 이 예제에서는 <code>user2</code>를 생성한 후 <code>user1</code> 전체를 더 이상 사용할 수 없는데, <code>user1</code>의 <code>username</code> 필드에 있는 <code>String</code>이 <code>user2</code>로 이동되었기 때문입니다. 만약 <code>user2</code>에 <code>email</code>과 <code>username</code> 모두에 대해 새로운 <code>String</code> 값을 주었다면, <code>user1</code>의 <code>active</code>와 <code>sign_in_count</code> 값만 사용했을 것이므로 <code>user2</code> 생성 후에도 <code>user1</code>은 여전히 유효했을 것입니다. <code>active</code>와 <code>sign_in_count</code>는 모두 <code>Copy</code> 트레이트를 구현하는 타입이므로, <a href="ch04-01-what-is-ownership.html#stack-only-data-copy">“스택에만 저장되는 데이터: 복사”</a><!-- ignore --> 섹션에서 논의한 동작이 적용됩니다. 이 예제에서 <code>user1.email</code>은 여전히 사용할 수 있는데, 그 값은 밖으로 이동되지 않았기 때문입니다.</p>
<h3 id="이름-없는-필드를-가진-튜플-구조체를-사용하여-다른-타입-생성하기"><a class="header" href="#이름-없는-필드를-가진-튜플-구조체를-사용하여-다른-타입-생성하기">이름 없는 필드를 가진 튜플 구조체를 사용하여 다른 타입 생성하기</a></h3>
<p>Rust also supports structs that look similar to tuples, called <em>tuple structs</em>. Tuple structs have the added meaning the struct name provides but don’t have names associated with their fields; rather, they just have the types of the fields. Tuple structs are useful when you want to give the whole tuple a name and make the tuple a different type from other tuples, and when naming each field as in a regular struct would be verbose or redundant.</p>
<p>튜플 구조체를 정의하려면, <code>struct</code> 키워드와 구조체 이름 뒤에 튜플에 들어갈 타입들을 적습니다. 예를 들어, 여기서는 <code>Color</code>와 <code>Point</code>라는 두 개의 튜플 구조체를 정의하고 사용합니다:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021">struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}</code></pre></pre>
</Listing>
<p><code>black</code>과 <code>origin</code> 값은 서로 다른 튜플 구조체의 인스턴스이므로 타입이 다릅니다. 여러분이 정의하는 각 구조체는 비록 그 안의 필드들이 동일한 타입을 가질지라도 각자의 고유한 타입입니다. 예를 들어, <code>Color</code> 타입을 매개변수로 받는 함수는 비록 두 타입 모두 세 개의 <code>i32</code> 값으로 구성되어 있더라도 <code>Point</code>를 인수로 받을 수 없습니다. 그 외에 튜플 구조체 인스턴스는 튜플과 유사하게 개별 조각으로 해체할 수 있으며, <code>.</code> 뒤에 인덱스를 붙여 개별 값에 접근할 수 있습니다. 튜플과 달리, 튜플 구조체를 해체할 때는 구조체의 타입 이름을 명시해야 합니다. 예를 들어, <code>let Point(x, y, z) = point</code>와 같이 작성합니다.</p>
<h3 id="필드가-없는-단위-구조체"><a class="header" href="#필드가-없는-단위-구조체">필드가 없는 단위 구조체</a></h3>
<p>필드가 전혀 없는 구조체를 정의할 수도 있습니다! 이런 구조체는 <a href="ch03-02-data-types.html#the-tuple-type">“튜플 타입”</a><!-- ignore --> 섹션에서 언급한 단위 타입인 <code>()</code>와 유사하게 동작하기 때문에 _단위 구조체(unit-like structs)_라고 불립니다. 단위 구조체는 어떤 타입에 대해 트레이트를 구현해야 하지만 타입 자체에 저장할 데이터는 없을 때 유용할 수 있습니다. 트레이트에 대해서는 10장에서 논의할 것입니다. 여기서는 <code>AlwaysEqual</code>이라는 이름의 단위 구조체를 선언하고 인스턴스화하는 예시를 보여줍니다:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021">struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}</code></pre></pre>
</Listing>
<p><code>AlwaysEqual</code>을 정의하려면 <code>struct</code> 키워드와 원하는 이름을 쓰고 세미콜론을 붙입니다. 중괄호나 괄호는 필요하지 않습니다! 그런 다음 <code>subject</code> 변수에서 유사한 방식으로 <code>AlwaysEqual</code>의 인스턴스를 얻을 수 있습니다. 중괄호나 괄호 없이 정의한 이름을 사용하면 됩니다. 나중에 테스트 목적으로 모든 인스턴스가 다른 타입의 모든 인스턴스와 항상 같다는 동작을 이 타입에 대해 구현한다고 가정해 보겠습니다. 그 동작을 구현하는 데 어떤 데이터도 필요하지 않을 것입니다! 10장에서 트레이트를 정의하고 단위 구조체를 포함한 모든 타입에 이를 구현하는 방법을 보게 될 것입니다.</p>
<blockquote>
<h3 id="구조체-데이터의-소유권"><a class="header" href="#구조체-데이터의-소유권">구조체 데이터의 소유권</a></h3>
<p>목록 5-1의 <code>User</code> 구조체 정의에서, 우리는 <code>&amp;str</code> 문자열 슬라이스 타입 대신 소유권이 있는 <code>String</code> 타입을 사용했습니다. 이는 이 구조체의 각 인스턴스가 모든 데이터를 소유하고, 전체 구조체가 유효한 동안 그 데이터도 유효하도록 하기 위한 의도적인 선택입니다.</p>
<p>구조체가 다른 것이 소유한 데이터에 대한 참조를 저장하는 것도 가능하지만, 그러기 위해서는 10장에서 논의할 러스트의 기능인 _라이프타임(lifetimes)_을 사용해야 합니다. 라이프타임은 구조체가 유효한 동안 구조체가 참조하는 데이터도 유효함을 보장합니다. 라이프타임을 지정하지 않고 구조체에 참조를 저장하려고 하면 다음과 같이 작동하지 않을 것입니다:</p>
<Listing file-name="src/main.rs">
<!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><code class="language-rust ignore does_not_compile">struct User {
    active: bool,
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        active: true,
        username: "someusername123",
        email: "someone@example.com",
        sign_in_count: 1,
    };
}</code></pre>
</Listing>
<p>컴파일러는 라이프타임 지정자가 필요하다고 불평할 것입니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:3:15
  |
3 |     username: &amp;str,
  |               ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     active: bool,
3 ~     username: &amp;'a str,
  |

error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:4:12
  |
4 |     email: &amp;str,
  |            ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     active: bool,
3 |     username: &amp;str,
4 ~     email: &amp;'a str,
  |

For more information about this error, try `rustc --explain E0106`.
error: could not compile `structs` (bin "structs") due to 2 previous errors
</code></pre>
<p>10장에서는 이러한 오류를 수정하여 구조체에 참조를 저장할 수 있는 방법을 논의하겠지만, 지금은 <code>&amp;str</code>과 같은 참조 대신 <code>String</code>과 같은 소유권이 있는 타입을 사용하여 이러한 오류를 수정할 것입니다.</p>
</blockquote>
<!-- manual-regeneration
for the error above
after running update-rustc.sh:
pbcopy < listings/ch05-using-structs-to-structure-related-data/no-listing-02-reference-in-struct/output.txt
paste above
add `> ` before every line -->
<div style="break-before: page; page-break-before: always;"></div><h2 id="구조체를-사용한-예제-프로그램"><a class="header" href="#구조체를-사용한-예제-프로그램">구조체를 사용한 예제 프로그램</a></h2>
<p>어떤 경우에 구조체를 사용하는 것이 좋은지 이해하기 위해, 사각형의 넓이를 계산하는 프로그램을 작성해 봅시다. 처음에는 개별 변수를 사용하는 것으로 시작해서, 나중에는 구조체를 사용하도록 프로그램을 리팩토링할 것입니다.</p>
<p>픽셀 단위로 지정된 사각형의 가로와 세로를 받아서 사각형의 넓이를 계산하는 _rectangles_라는 새 바이너리 프로젝트를 Cargo로 만들어 봅시다. 목록 5-8은 우리 프로젝트의 _src/main.rs_에서 바로 그 작업을 수행하는 한 가지 방법을 보여주는 짧은 프로그램입니다.</p>
<Listing number="5-8" file-name="src/main.rs" caption="Calculating the area of a rectangle specified by separate width and height variables">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let width1 = 30;
    let height1 = 50;

    println!(
        "사각형의 넓이는 {} 제곱 픽셀입니다.",
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -&gt; u32 {
    width * height
}</code></pre></pre>
</Listing>
<p>이제 <code>cargo run</code>을 사용하여 이 프로그램을 실행해 보세요:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/rectangles`
The area of the rectangle is 1500 square pixels.
</code></pre>
<p>이 코드는 각 차수를 인수로 <code>area</code> 함수를 호출하여 사각형의 넓이를 계산하는 데 성공하지만, 이 코드를 더 명확하고 읽기 쉽게 만들기 위해 더 많은 일을 할 수 있습니다.</p>
<p>이 코드의 문제는 <code>area</code>의 시그니처에서 분명하게 드러납니다:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    let width1 = 30;
</span><span class="boring">    let height1 = 50;
</span><span class="boring">
</span><span class="boring">    println!(
</span><span class="boring">        "사각형의 넓이는 {} 제곱 픽셀입니다.",
</span><span class="boring">        area(width1, height1)
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span>fn area(width: u32, height: u32) -&gt; u32 {
<span class="boring">    width * height
</span><span class="boring">}</span></code></pre>
<p><code>area</code> 함수는 하나의 사각형 넓이를 계산하도록 되어 있지만, 우리가 작성한 함수는 두 개의 매개변수를 가지고 있으며, 프로그램의 어느 곳에서도 이 매개변수들이 서로 관련되어 있다는 것이 명확하지 않습니다. 가로와 세로를 하나로 그룹화하는 것이 더 읽기 쉽고 관리하기 쉬울 것입니다. 우리는 이미 3장의 <a href="ch03-02-data-types.html#the-tuple-type">“튜플 타입”</a><!-- ignore --> 섹션에서 튜플을 사용하여 이를 수행할 수 있는 한 가지 방법을 논의했습니다.</p>
<h3 id="튜플을-이용한-리팩토링"><a class="header" href="#튜플을-이용한-리팩토링">튜플을 이용한 리팩토링</a></h3>
<p>목록 5-9는 튜플을 사용하는 프로그램의 또 다른 버전을 보여줍니다.</p>
<Listing number="5-9" file-name="src/main.rs" caption="Specifying the width and height of the rectangle with a tuple">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let rect1 = (30, 50);

    println!(
        "사각형의 넓이는 {} 제곱 픽셀입니다.",
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -&gt; u32 {
    dimensions.0 * dimensions.1
}</code></pre></pre>
</Listing>
<p>어떤 면에서 이 프로그램은 더 낫습니다. 튜플을 통해 약간의 구조를 추가할 수 있었고, 이제 인수를 하나만 전달합니다. 하지만 다른 면에서 이 버전은 덜 명확합니다. 튜플은 요소에 이름을 붙이지 않으므로 튜플의 각 부분에 인덱스로 접근해야 하며, 이로 인해 계산식이 덜 직관적이게 됩니다.</p>
<p>가로와 세로를 뒤바꾸는 것은 넓이 계산에는 문제가 되지 않겠지만, 사각형을 화면에 그리려 한다면 문제가 될 것입니다! <code>width</code>가 튜플 인덱스 <code>0</code>이고 <code>height</code>가 튜플 인덱스 <code>1</code>이라는 점을 항상 명심해야 합니다. 다른 사람이 우리의 코드를 사용한다면 이를 파악하고 기억하는 것은 훨씬 더 어려울 것입니다. 코드에서 데이터의 의미를 전달하지 않았기 때문에, 이제 실수를 저지르기가 더 쉬워졌습니다.</p>
<h3 id="구조체를-이용한-리팩토링-더-많은-의미-추가하기"><a class="header" href="#구조체를-이용한-리팩토링-더-많은-의미-추가하기">구조체를 이용한 리팩토링: 더 많은 의미 추가하기</a></h3>
<p>우리는 데이터에 레이블을 붙여 의미를 추가하기 위해 구조체를 사용합니다. 목록 5-10에 나타난 것처럼, 우리가 사용하고 있는 튜플을 전체에 대한 이름뿐만 아니라 각 부분에 대한 이름도 가진 구조체로 변환할 수 있습니다.</p>
<Listing number="5-10" file-name="src/main.rs" caption="Defining a `Rectangle` struct">
<pre><pre class="playground"><code class="language-rust edition2021">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "사각형의 넓이는 {} 제곱 픽셀입니다.",
        area(&amp;rect1)
    );
}

fn area(rectangle: &amp;Rectangle) -&gt; u32 {
    rectangle.width * rectangle.height
}</code></pre></pre>
</Listing>
<p>여기서 우리는 구조체를 정의하고 <code>Rectangle</code>이라고 이름 지었습니다. 중괄호 안에서 필드를 <code>width</code>와 <code>height</code>로 정의했으며, 둘 다 <code>u32</code> 타입을 갖습니다. 그런 다음 <code>main</code>에서 가로 30, 세로 50인 <code>Rectangle</code>의 특정 인스턴스를 생성했습니다.</p>
<p>이제 <code>area</code> 함수는 <code>rectangle</code>이라는 이름의 매개변수 하나를 갖도록 정의되었으며, 그 타입은 <code>Rectangle</code> 구조체 인스턴스의 불변 빌림입니다. 4장에서 언급했듯이, 우리는 구조체의 소유권을 가져오는 대신 빌려오기를 원합니다. 이렇게 하면 <code>main</code>이 소유권을 유지하고 <code>rect1</code>을 계속 사용할 수 있습니다. 이것이 함수 시그니처와 함수 호출부에서 <code>&amp;</code>를 사용하는 이유입니다.</p>
<p><code>area</code> 함수는 <code>Rectangle</code> 인스턴스의 <code>width</code>와 <code>height</code> 필드에 접근합니다 (빌려온 구조체 인스턴스의 필드에 접근해도 필드 값이 이동하지 않는다는 점에 유의하세요. 이것이 구조체 빌림을 자주 보게 되는 이유입니다). 이제 <code>area</code>의 함수 시그니처는 우리가 의도한 바를 정확히 나타냅니다: <code>Rectangle</code>의 <code>width</code>와 <code>height</code> 필드를 사용하여 넓이를 계산한다는 것입니다. 이는 가로와 세로가 서로 관련되어 있음을 전달하며, 튜플 인덱스 <code>0</code>과 <code>1</code> 대신 값에 설명적인 이름을 부여합니다. 이는 명확성 측면에서 큰 진전입니다.</p>
<h3 id="파생-트레이트로-유용한-기능-추가하기"><a class="header" href="#파생-트레이트로-유용한-기능-추가하기">파생 트레이트로 유용한 기능 추가하기</a></h3>
<p>프로그램을 디버깅하는 동안 <code>Rectangle</code>의 인스턴스를 출력하여 모든 필드의 값을 볼 수 있다면 유용할 것입니다. 목록 5-11에서는 이전 장들에서 사용했던 것처럼 <a href="../std/macro.println.html"><code>println!</code> 매크로</a><!-- ignore -->를 사용하려고 시도합니다. 하지만 이는 작동하지 않을 것입니다.</p>
<Listing number="5-11" file-name="src/main.rs" caption="Attempting to print a `Rectangle` instance">
<pre><code class="language-rust ignore does_not_compile">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1은 {}", rect1);
}</code></pre>
</Listing>
<p>이 코드를 컴파일하면 다음과 같은 핵심 메시지가 포함된 오류가 발생합니다:</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
</code></pre>
<p><code>println!</code> 매크로는 여러 종류의 포맷팅을 수행할 수 있으며, 기본적으로 중괄호는 <code>println!</code>에게 <code>Display</code>라고 알려진 포맷팅을 사용하도록 지시합니다. 이는 최종 사용자가 직접 소비하도록 의도된 출력입니다. 지금까지 본 기본 타입들은 <code>1</code>이나 다른 기본 타입들을 사용자에게 보여주는 방법이 한 가지뿐이기 때문에 기본적으로 <code>Display</code>를 구현하고 있습니다. 하지만 구조체의 경우, <code>println!</code>이 출력을 포맷팅해야 하는 방식이 덜 명확합니다. 쉼표를 사용할 것인지, 중괄호를 출력할 것인지, 모든 필드를 보여줄 것인지 등 표시 가능성이 더 많기 때문입니다. 이러한 모호함 때문에 러스트는 우리가 원하는 것을 추측하려 하지 않으며, 구조체에는 <code>println!</code>과 <code>{}</code> 자리표시자와 함께 사용할 수 있는 <code>Display</code> 구현이 기본으로 제공되지 않습니다.</p>
<p>오류 메시지를 계속 읽어보면 다음과 같은 도움이 되는 노트를 발견할 수 있습니다:</p>
<pre><code class="language-text">   = help: the trait `std::fmt::Display` is not implemented for `Rectangle`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
</code></pre>
<p>한번 시도해 봅시다! 이제 <code>println!</code> 매크 호출은 <code>println!("rect1은 {rect1:?}");</code>과 같은 모습이 될 것입니다. 중괄호 안에 <code>:?</code> 명시자를 넣으면 <code>println!</code>에게 <code>Debug</code>라고 불리는 출력 포맷을 사용하고 싶다고 알리는 것입니다. <code>Debug</code> 트레이트는 개발자에게 유용한 방식으로 구조체를 출력할 수 있게 해주어, 코드를 디버깅하는 동안 그 값을 확인할 수 있게 합니다.</p>
<p>이 변경 사항을 적용하여 코드를 컴파일해 봅시다. 이런! 여전히 오류가 발생합니다:</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `Debug`
</code></pre>
<p>하지만 다시 한번, 컴파일러는 도움이 되는 노트를 제공합니다:</p>
<pre><code class="language-text">   = help: the trait `Debug` is not implemented for `Rectangle`
   = note: add `#[derive(Debug)]` to `Rectangle` or manually `impl Debug for Rectangle`
</code></pre>
<p>러스트는 디버깅 정보를 출력하는 기능을 <em>포함하고</em> 있지만, 우리의 구조체에서 그 기능을 사용할 수 있게 하려면 명시적으로 선택해야 합니다. 그렇게 하기 위해, 목록 5-12에 나타난 것처럼 구조체 정의 바로 앞에 <code>#[derive(Debug)]</code>라는 외부 속성(outer attribute)을 추가합니다.</p>
<Listing number="5-12" file-name="src/main.rs" caption="Adding the attribute to derive the `Debug` trait and printing the `Rectangle` instance using debug formatting">
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1은 {rect1:?}");
}</code></pre></pre>
</Listing>
<p>이제 프로그램을 실행하면 오류가 발생하지 않으며, 다음과 같은 출력을 보게 될 것입니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 is Rectangle { width: 30, height: 50 }
</code></pre>
<p>좋습니다! 아주 예쁜 출력은 아니지만, 이 인스턴스의 모든 필드 값을 보여주므로 디버깅 중에 확실히 도움이 될 것입니다. 구조체가 더 큰 경우에는 출력을 조금 더 읽기 쉽게 만드는 것이 유용합니다. 그런 경우 <code>println!</code> 문자열에서 <code>{:?}</code> 대신 <code>{:#?}</code>를 사용할 수 있습니다. 이 예제에서 <code>{:#?}</code> 스타일을 사용하면 다음과 같이 출력됩니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 is Rectangle {
    width: 30,
    height: 50,
}
</code></pre>
<p><code>Debug</code> 포맷을 사용하여 값을 출력하는 또 다른 방법은 <a href="../std/macro.dbg.html"><code>dbg!</code> 매크로</a><!-- ignore -->를 사용하는 것입니다. <code>dbg!</code> 매크로는 표현식의 소유권을 가져와서 (참조를 가져오는 <code>println!</code>과 반대), 코드에서 <code>dbg!</code> 호출이 발생한 파일 이름과 줄 번호를 해당 표현식의 결과 값과 함께 출력하고, 값의 소유권을 다시 반환합니다.</p>
<blockquote>
<p>참고: <code>dbg!</code> 매크로를 호출하면 표준 출력 콘솔 스트림(<code>stdout</code>)에 출력하는 <code>println!</code>과 달리 표준 에러 콘솔 스트림(<code>stderr</code>)에 출력합니다. <code>stderr</code>와 <code>stdout</code>에 대해서는 12장의 <a href="ch12-06-writing-to-stderr-instead-of-stdout.html">“표준 출력 대신 표준 에러로 에러 메시지 작성하기”</a><!-- ignore --> 섹션에서 더 자세히 이야기하겠습니다.</p>
</blockquote>
<p>여기 <code>width</code> 필드에 할당되는 값과 <code>rect1</code> 구조체 전체의 값에 관심이 있는 예제가 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale),
        height: 50,
    };

    dbg!(&amp;rect1);
}</code></pre></pre>
<p>표현식 <code>30 * scale</code>을 <code>dbg!</code>로 감쌀 수 있습니다. <code>dbg!</code>는 표현식 값의 소유권을 반환하기 때문에, <code>width</code> 필드는 <code>dbg!</code> 호출이 없었을 때와 동일한 값을 갖게 됩니다. <code>rect1</code>의 소유권을 <code>dbg!</code>가 가져가는 것을 원하지 않으므로, 다음 호출에서는 <code>rect1</code>에 대한 참조를 사용합니다. 이 예제의 출력은 다음과 같습니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/rectangles`
[src/main.rs:10:16] 30 * scale = 60
[src/main.rs:14:5] &amp;rect1 = Rectangle {
    width: 60,
    height: 50,
}
</code></pre>
<p>첫 번째 출력 조각은 <code>30 * scale</code> 표현식을 디버깅하고 있는 <em>src/main.rs</em> 10행에서 온 것이며, 결과 값은 <code>60</code>입니다 (정수에 대해 구현된 <code>Debug</code> 포맷팅은 값만 출력하는 것입니다). <em>src/main.rs</em> 14행의 <code>dbg!</code> 호출은 <code>Rectangle</code> 구조체인 <code>&amp;rect1</code>의 값을 출력합니다. 이 출력은 <code>Rectangle</code> 타입의 예쁜 <code>Debug</code> 포맷팅을 사용합니다. <code>dbg!</code> 매크로는 코드가 무엇을 하고 있는지 파악하려고 할 때 정말 도움이 될 수 있습니다!</p>
<p><code>Debug</code> 트레이트 외에도, 러스트는 커스텀 타입에 유용한 동작을 추가할 수 있도록 <code>derive</code> 속성과 함께 사용할 수 있는 여러 트레이트를 제공합니다. 이러한 트레이트와 그 동작은 <a href="appendix-03-derivable-traits.html">부록 C</a><!--
ignore -->에 나열되어 있습니다. 10장에서는 커스텀 동작으로 이러한 트레이트를 구현하는 방법과 여러분만의 트레이트를 만드는 방법을 다룰 것입니다. <code>derive</code> 외에도 많은 속성이 있습니다. 자세한 내용은 <a href="../reference/attributes.html">러스트 레퍼런스의 “Attributes” 섹션</a>을 참조하세요.</p>
<p>우리의 <code>area</code> 함수는 매우 구체적입니다. 사각형의 넓이만 계산하죠. 이 동작은 다른 타입과는 작동하지 않으므로, <code>Rectangle</code> 구조체와 더 밀접하게 연결하는 것이 도움이 될 것입니다. <code>area</code> 함수를 <code>Rectangle</code> 타입에 정의된 <code>area</code> _메서드_로 바꾸어 이 코드를 계속 리팩토링하는 방법을 살펴봅시다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="메서드-문법"><a class="header" href="#메서드-문법">메서드 문법</a></h2>
<p>_메서드(methods)_는 함수와 유사합니다. <code>fn</code> 키워드와 이름을 사용하여 선언하며, 매개변수와 반환 값을 가질 수 있고, 다른 곳에서 호출될 때 실행되는 코드를 포함합니다. 하지만 함수와 달리 메서드는 구조체(또는 6장과 17장에서 각각 다루는 열거형이나 트레이트 객체)의 맥락 내에서 정의되며, 첫 번째 매개변수는 항상 메서드가 호출되는 구조체의 인스턴스를 나타내는 <code>self</code>입니다.</p>
<h3 id="메서드-정의하기"><a class="header" href="#메서드-정의하기">메서드 정의하기</a></h3>
<p>목록 5-13에 나타난 것처럼, <code>Rectangle</code> 인스턴스를 매개변수로 갖는 <code>area</code> 함수를 변경하여 <code>Rectangle</code> 구조체에 정의된 <code>area</code> 메서드로 만들어 봅시다.</p>
<Listing number="5-13" file-name="src/main.rs" caption="Defining an `area` method on the `Rectangle` struct">
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "사각형의 넓이는 {} 제곱 픽셀입니다.",
        rect1.area()
    );
}</code></pre></pre>
</Listing>
<p>To define the function within the context of <code>Rectangle</code>, we start an <code>impl</code> (implementation) block for <code>Rectangle</code>. Everything within this <code>impl</code> block will be associated with the <code>Rectangle</code> type. Then we move the <code>area</code> function within the <code>impl</code> curly brackets and change the first (and in this case, only) parameter to be <code>self</code> in the signature and everywhere within the body. In <code>main</code>, where we called the <code>area</code> function and passed <code>rect1</code> as an argument, we can instead use <em>method syntax</em> to call the <code>area</code> method on our <code>Rectangle</code> instance. The method syntax goes after an instance: we add a dot followed by the method name, parentheses, and any arguments.</p>
<p><code>area</code>의 시그니처에서 <code>rectangle: &amp;Rectangle</code> 대신 <code>&amp;self</code>를 사용합니다. <code>&amp;self</code>는 실제로는 <code>self: &amp;Self</code>의 약어입니다. <code>impl</code> 블록 내에서 <code>Self</code> 타입은 <code>impl</code> 블록이 적용되는 타입의 별칭입니다. 메서드는 첫 번째 매개변수로 <code>Self</code> 타입의 <code>self</code>라는 매개변수를 가져야 하므로, 러스트는 첫 번째 매개변수 위치에 <code>self</code>라는 이름만으로 이를 축약할 수 있도록 합니다. 이 메서드가 <code>Self</code> 인스턴스를 빌려온다는 것을 나타내기 위해 <code>self</code> 약어 앞에 <code>&amp;</code>를 여전히 사용해야 합니다. 이는 <code>rectangle: &amp;Rectangle</code>에서 했던 것과 같습니다. 메서드는 <code>self</code>의 소유권을 가져가거나, 여기서처럼 <code>self</code>를 불변으로 빌려오거나, 다른 매개변수와 마찬가지로 <code>self</code>를 가변으로 빌려올 수 있습니다.</p>
<p>여기서 <code>&amp;self</code>를 선택한 이유는 함수 버전에서 <code>&amp;Rectangle</code>을 사용한 것과 동일합니다: 우리는 소유권을 가져가고 싶지 않고, 구조체의 데이터를 읽기만 하고 쓰지 않으려 합니다. 메서드가 수행하는 작업의 일부로 메서드를 호출한 인스턴스를 변경하고 싶다면, 첫 번째 매개변수로 <code>&amp;mut self</code>를 사용할 것입니다. 첫 번째 매개변수로 <code>self</code>만 사용하여 인스턴스의 소유권을 가져가는 메서드는 드뭅니다. 이 기술은 일반적으로 메서드가 <code>self</code>를 다른 것으로 변환하고 변환 후에 호출자가 원래 인스턴스를 사용하는 것을 방지하려는 경우에 사용됩니다.</p>
<p>메서드 구문을 제공하고 모든 메서드의 시그니처에서 <code>self</code>의 타입을 반복할 필요가 없다는 점 외에, 함수 대신 메서드를 사용하는 주된 이유는 조직화 때문입니다. 우리는 타입의 인스턴스로 할 수 있는 모든 것을 하나의 <code>impl</code> 블록에 넣어, 우리가 제공하는 라이브러리의 다양한 곳에서 <code>Rectangle</code>의 기능을 찾아야 하는 미래의 사용자들을 번거롭게 하지 않습니다.</p>
<p>메서드에 구조체의 필드와 동일한 이름을 부여할 수 있다는 점에 유의하세요. 예를 들어, <code>Rectangle</code>에 <code>width</code>라는 이름의 메서드를 정의할 수 있습니다:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn width(&amp;self) -&gt; bool {
        self.width &gt; 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() {
        println!(직사각형의 너비는 0이 아닙니다. 너비는 {}입니다, rect1.width);
    }
}</code></pre></pre>
</Listing>
<p>여기서 우리는 인스턴스의 <code>width</code> 필드 값이 <code>0</code>보다 크면 <code>width</code> 메서드가 <code>true</code>를 반환하고, 값이 <code>0</code>이면 <code>false</code>를 반환하도록 선택합니다. 즉, 동일한 이름의 메서드 내에서 필드를 어떤 목적으로든 사용할 수 있습니다. <code>main</code>에서 <code>rect1.width</code> 뒤에 괄호를 붙이면 러스트는 메서드 <code>width</code>를 의미한다는 것을 압니다. 괄호를 사용하지 않으면 러스트는 필드 <code>width</code>를 의미한다는 것을 압니다.</p>
<p>항상 그런 것은 아니지만, 메서드에 필드와 동일한 이름을 부여할 때, 필드의 값만 반환하고 다른 것은 아무것도 하지 않기를 원할 때가 많습니다. 이러한 메서드를 _게터_라고 하며, 러스트는 다른 일부 언어처럼 구조체 필드에 대해 자동으로 구현하지 않습니다. 게터는 필드를 비공개로 만들고 메서드를 공개로 만들어 타입의 공개 API의 일부로 해당 필드에 대한 읽기 전용 접근을 가능하게 하므로 유용합니다. 공개 및 비공개가 무엇인지, 그리고 필드나 메서드를 공개 또는 비공개로 지정하는 방법은 <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword">7장</a><!-- ignore -->에서 논의할 것입니다.</p>
<blockquote>
<h3 id="--연산자는-어디에-있나요"><a class="header" href="#--연산자는-어디에-있나요"><code>-&gt;</code> 연산자는 어디에 있나요?</a></h3>
<p>C와 C++에서는 메서드를 호출하는 데 두 가지 다른 연산자가 사용됩니다. 객체에서 직접 메서드를 호출할 때는 <code>.</code>을 사용하고, 객체에 대한 포인터에서 메서드를 호출하고 먼저 포인터를 역참조해야 할 때는 <code>-&gt;</code>를 사용합니다. 다시 말해, <code>object</code>가 포인터인 경우 <code>object-&gt;something()</code>은 <code>(*object).something()</code>과 유사합니다.</p>
<p>러스트에는 <code>-&gt;</code> 연산자에 해당하는 것이 없습니다. 대신 러스트에는 _자동 참조 및 역참조_라는 기능이 있습니다. 메서드 호출은 러스트에서 이러한 동작을 보이는 몇 안 되는 곳 중 하나입니다.</p>
<p>작동 방식은 다음과 같습니다: <code>object.something()</code>으로 메서드를 호출하면, 러스트는 <code>&amp;</code>, <code>&amp;mut</code>, 또는 <code>*</code>를 자동으로 추가하여 <code>object</code>가 메서드의 시그니처와 일치하도록 합니다. 즉, 다음은 동일합니다:</p>
<!-- CAN'T EXTRACT SEE BUG https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug,Copy,Clone)]
</span><span class="boring">struct Point {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Point {
</span><span class="boring">   fn distance(&amp;self, other: &amp;Point) -&gt; f64 {
</span><span class="boring">       let x_squared = f64::powi(other.x - self.x, 2);
</span><span class="boring">       let y_squared = f64::powi(other.y - self.y, 2);
</span><span class="boring">
</span><span class="boring">       f64::sqrt(x_squared + y_squared)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">let p1 = Point { x: 0.0, y: 0.0 };
</span><span class="boring">let p2 = Point { x: 5.0, y: 6.5 };
</span>p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
<span class="boring">}</span></code></pre></pre>
<p>첫 번째 것이 훨씬 깔끔해 보입니다. 이 자동 참조 동작은 메서드가 명확한 수신자(즉, <code>self</code>의 타입)를 가지고 있기 때문에 작동합니다. 수신자와 메서드 이름을 고려하여 러스트는 메서드가 읽기(<code>&amp;self</code>), 변경(<code>&amp;mut self</code>), 또는 소비(<code>self</code>) 중 무엇을 하는지 명확하게 파악할 수 있습니다. 러스트가 메서드 수신자에 대해 빌림을 암시적으로 만드는 사실은 소유권을 실제로 인체공학적으로 만드는 데 큰 부분을 차지합니다.</p>
</blockquote>
<h3 id="더-많은-매개변수를-가진-메서드"><a class="header" href="#더-많은-매개변수를-가진-메서드">더 많은 매개변수를 가진 메서드</a></h3>
<p><code>Rectangle</code> 구조체에 두 번째 메서드를 구현하여 메서드 사용을 연습해 봅시다. 이번에는 <code>Rectangle</code> 인스턴스가 다른 <code>Rectangle</code> 인스턴스를 받아, 두 번째 <code>Rectangle</code>이 <code>self</code> (첫 번째 <code>Rectangle</code>) 안에 완전히 들어갈 수 있으면 <code>true</code>를 반환하고, 그렇지 않으면 <code>false</code>를 반환하도록 할 것입니다. 즉, <code>can_hold</code> 메서드를 정의한 후, 목록 5-14에 표시된 프로그램을 작성할 수 있기를 원합니다.</p>
<Listing number="5-14" file-name="src/main.rs" caption="Using the as-yet-unwritten `can_hold` method">
<pre><code class="language-rust ignore">fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!("rect1이 rect2를 포함할 수 있나요? {}", rect1.can_hold(&amp;rect2));
    println!("rect1이 rect3를 포함할 수 있나요? {}", rect1.can_hold(&amp;rect3));
}</code></pre>
</Listing>
<p>예상되는 출력은 다음과 같을 것입니다. <code>rect2</code>의 두 치수 모두 <code>rect1</code>의 치수보다 작지만, <code>rect3</code>은 <code>rect1</code>보다 넓기 때문입니다:</p>
<pre><code class="language-text">Can rect1 hold rect2? true
Can rect1 hold rect3? false
</code></pre>
<p>우리는 메서드를 정의하고 싶으므로, <code>impl Rectangle</code> 블록 안에 있을 것입니다. 메서드 이름은 <code>can_hold</code>가 될 것이고, 다른 <code>Rectangle</code>의 불변 빌림을 매개변수로 받을 것입니다. 매개변수의 타입을 알기 위해서는 메서드를 호출하는 코드를 보면 됩니다: <code>rect1.can_hold(&amp;rect2)</code>는 <code>&amp;rect2</code>를 전달하는데, 이는 <code>Rectangle</code> 인스턴스인 <code>rect2</code>에 대한 불변 빌림입니다. 이는 <code>rect2</code>를 읽기만 하면 되기 때문에 (쓰려면 가변 빌림이 필요할 것입니다) 합리적이며, <code>main</code>이 <code>rect2</code>의 소유권을 유지하여 <code>can_hold</code> 메서드를 호출한 후에도 다시 사용할 수 있도록 하기 위함입니다. <code>can_hold</code>의 반환 값은 불리언이 될 것이고, 구현은 <code>self</code>의 너비와 높이가 다른 <code>Rectangle</code>의 너비와 높이보다 각각 큰지 확인할 것입니다. 목록 5-15에 표시된 목록 5-13의 <code>impl</code> 블록에 새 <code>can_hold</code> 메서드를 추가해 봅시다.</p>
<Listing number="5-15" file-name="src/main.rs" caption="Implementing the `can_hold` method on `Rectangle` that takes another `Rectangle` instance as a parameter">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("rect1이 rect2를 포함할 수 있나요? {}", rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!("rect1이 rect3를 포함할 수 있나요? {}", rect1.can_hold(&amp;rect3));
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>목록 5-14의 <code>main</code> 함수와 함께 이 코드를 실행하면, 우리가 원하는 출력을 얻을 것입니다. 메서드는 <code>self</code> 매개변수 뒤에 추가하는 여러 매개변수를 가질 수 있으며, 이 매개변수들은 함수에서의 매개변수와 동일하게 작동합니다.</p>
<h3 id="연관-함수"><a class="header" href="#연관-함수">연관 함수</a></h3>
<p><code>impl</code> 블록 내에 정의된 모든 함수는 _연관 함수_라고 불립니다. 왜냐하면 <code>impl</code> 뒤에 오는 타입과 연관되어 있기 때문입니다. 첫 번째 매개변수로 <code>self</code>를 가지지 않는 (따라서 메서드가 아닌) 연관 함수를 정의할 수 있습니다. 왜냐하면 이들은 작업할 타입의 인스턴스가 필요 없기 때문입니다. 우리는 이미 <code>String</code> 타입에 정의된 <code>String::from</code> 함수와 같은 함수를 사용했습니다.</p>
<p>메서드가 아닌 연관 함수는 종종 구조체의 새 인스턴스를 반환하는 생성자로 사용됩니다. 이들은 종종 <code>new</code>라고 불리지만, <code>new</code>는 특별한 이름이 아니며 언어에 내장되어 있지 않습니다. 예를 들어, 우리는 <code>square</code>라는 이름의 연관 함수를 제공하여 하나의 차원 매개변수를 가지고 그것을 너비와 높이로 모두 사용하여, 동일한 값을 두 번 지정할 필요 없이 정사각형 <code>Rectangle</code>을 더 쉽게 생성할 수 있습니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn square(size: u32) -&gt; Self {
        Self {
            width: size,
            height: size,
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let sq = Rectangle::square(3);
</span><span class="boring">}</span></code></pre></pre>
<p>함수의 반환 타입과 본문에 있는 <code>Self</code> 키워드는 <code>impl</code> 키워드 뒤에 나타나는 타입의 별칭이며, 이 경우 <code>Rectangle</code>입니다.</p>
<p>이 연관 함수를 호출하려면 구조체 이름과 함께 <code>::</code> 구문을 사용합니다. <code>let sq = Rectangle::square(3);</code>가 그 예입니다. 이 함수는 구조체에 의해 네임스페이스가 지정됩니다. <code>::</code> 구문은 연관 함수와 모듈에 의해 생성된 네임스페이스 모두에 사용됩니다. <a href="ch07-02-defining-modules-to-control-scope-and-privacy.html">7장</a><!-- ignore -->에서 모듈에 대해 논의할 것입니다.</p>
<h3 id="여러-impl-블록"><a class="header" href="#여러-impl-블록">여러 <code>impl</code> 블록</a></h3>
<p>각 구조체는 여러 <code>impl</code> 블록을 가질 수 있습니다. 예를 들어, 목록 5-15는 각 메서드가 자체 <code>impl</code> 블록에 있는 목록 5-16에 표시된 코드와 동일합니다.</p>
<Listing number="5-16" caption="Rewriting Listing 5-15 using multiple `impl` blocks">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("rect1이 rect2를 포함할 수 있나요? {}", rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!("rect1이 rect3를 포함할 수 있나요? {}", rect1.can_hold(&amp;rect3));
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>여기서 이 메서드들을 여러 <code>impl</code> 블록으로 분리할 이유는 없지만, 이것은 유효한 구문입니다. 여러 <code>impl</code> 블록이 유용한 경우는 10장에서 제네릭 타입과 트레이트를 논의할 때 볼 것입니다.</p>
<h2 id="요약-4"><a class="header" href="#요약-4">요약</a></h2>
<p>구조체를 사용하면 도메인에 의미 있는 사용자 정의 타입을 생성할 수 있습니다. 구조체를 사용함으로써 연관된 데이터 조각들을 서로 연결하고 각 조각에 이름을 부여하여 코드를 명확하게 만들 수 있습니다. <code>impl</code> 블록에서는 타입과 연관된 함수를 정의할 수 있으며, 메서드는 구조체 인스턴스가 가지는 동작을 지정할 수 있는 일종의 연관 함수입니다.</p>
<p>하지만 구조체만이 사용자 정의 타입을 생성하는 유일한 방법은 아닙니다. 러스트의 열거형 기능을 사용하여 도구 상자에 또 다른 도구를 추가해 봅시다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="열거형과-패턴-매칭"><a class="header" href="#열거형과-패턴-매칭">열거형과 패턴 매칭</a></h1>
<p>이 장에서는 _열거형_이라고도 불리는 _enums_를 살펴볼 것입니다. 열거형은 가능한 _variant_를 열거하여 타입을 정의할 수 있도록 합니다. 먼저 열거형이 데이터와 함께 의미를 어떻게 인코딩할 수 있는지 보여주기 위해 열거형을 정의하고 사용할 것입니다. 다음으로, 값이 어떤 것이거나 아무것도 아닐 수 있음을 표현하는 특히 유용한 열거형인 <code>Option</code>을 탐구할 것입니다. 그런 다음 <code>match</code> 표현식의 패턴 매칭이 열거형의 다른 값에 대해 다른 코드를 실행하는 것을 얼마나 쉽게 만드는지 살펴볼 것입니다. 마지막으로, <code>if let</code> 구문이 코드에서 열거형을 처리하는 데 사용할 수 있는 또 다른 편리하고 간결한 관용구임을 다룰 것입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="열거형-정의하기"><a class="header" href="#열거형-정의하기">열거형 정의하기</a></h2>
<p>구조체가 <code>width</code>와 <code>height</code>를 가진 <code>Rectangle</code>처럼 관련 필드와 데이터를 함께 그룹화하는 방법을 제공하는 반면, 열거형은 값이 가능한 값 집합 중 하나라고 말하는 방법을 제공합니다. 예를 들어, <code>Rectangle</code>이 <code>Circle</code>과 <code>Triangle</code>을 포함하는 가능한 도형 집합 중 하나라고 말하고 싶을 수 있습니다. 이를 위해 러스트는 이러한 가능성을 열거형으로 인코딩할 수 있도록 합니다.</p>
<p>코드에서 표현하고 싶은 상황을 살펴보고, 이 경우 열거형이 구조체보다 유용하고 더 적절한 이유를 알아보겠습니다. IP 주소로 작업해야 한다고 가정해 봅시다. 현재 IP 주소에는 두 가지 주요 표준인 버전 4와 버전 6이 사용됩니다. 이들이 우리 프로그램이 접하게 될 IP 주소의 유일한 가능성이므로, 모든 가능한 variant를 _열거_할 수 있으며, 여기서 열거형이라는 이름이 유래합니다.</p>
<p>어떤 IP 주소든 버전 4 또는 버전 6 주소일 수 있지만, 동시에 둘 다일 수는 없습니다. IP 주소의 이러한 속성은 열거형 데이터 구조를 적절하게 만듭니다. 왜냐하면 열거형 값은 오직 하나의 variant만 가질 수 있기 때문입니다. 버전 4와 버전 6 주소 모두 여전히 근본적으로 IP 주소이므로, 어떤 종류의 IP 주소에도 적용되는 상황을 코드가 처리할 때 동일한 타입으로 취급되어야 합니다.</p>
<p>우리는 <code>IpAddrKind</code> 열거형을 정의하고 IP 주소가 될 수 있는 가능한 종류인 <code>V4</code>와 <code>V6</code>를 나열함으로써 이 개념을 코드로 표현할 수 있습니다. 이것들이 열거형의 variant입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021">enum IpAddrKind {
    V4,
    V6,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p><code>IpAddrKind</code>는 이제 코드의 다른 곳에서 사용할 수 있는 사용자 정의 데이터 타입입니다.</p>
<h3 id="열거형-값"><a class="header" href="#열거형-값">열거형 값</a></h3>
<p><code>IpAddrKind</code>의 두 가지 variant 각각의 인스턴스를 다음과 같이 생성할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
<span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p>열거형의 variant는 해당 식별자 아래에 네임스페이스가 지정되며, 두 개를 구분하기 위해 이중 콜론을 사용한다는 점에 유의하세요. 이는 이제 <code>IpAddrKind::V4</code>와 <code>IpAddrKind::V6</code> 두 값 모두 <code>IpAddrKind</code>라는 동일한 타입이기 때문에 유용합니다. 예를 들어, 어떤 <code>IpAddrKind</code>든 받아들이는 함수를 정의할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span>fn route(ip_kind: IpAddrKind) {}</code></pre></pre>
<p>그리고 우리는 이 함수를 두 variant 중 하나로 호출할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span>    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p>열거형을 사용하는 것은 더 많은 장점을 가집니다. IP 주소 타입에 대해 더 생각해 보면, 현재 우리는 실제 IP 주소 _데이터_를 저장할 방법이 없습니다. 우리는 단지 그것이 어떤 _종류_인지 알고 있을 뿐입니다. 5장에서 구조체에 대해 방금 배웠다는 점을 고려하면, 목록 6-1에 표시된 것처럼 구조체로 이 문제를 해결하고 싶을 수도 있습니다.</p>
<Listing number="6-1" caption="Storing the data and `IpAddrKind` variant of an IP address using a `struct`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    enum IpAddrKind {
        V4,
        V6,
    }

    struct IpAddr {
        kind: IpAddrKind,
        address: String,
    }

    let home = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from("127.0.0.1"),
    };

    let loopback = IpAddr {
        kind: IpAddrKind::V6,
        address: String::from("::1"),
    };
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>여기서 우리는 <code>IpAddr</code> 구조체를 정의했습니다. 이 구조체는 두 개의 필드를 가집니다: <code>IpAddrKind</code> 타입의 <code>kind</code> 필드(이전에 정의한 열거형)와 <code>String</code> 타입의 <code>address</code> 필드입니다. 이 구조체의 두 인스턴스가 있습니다. 첫 번째는 <code>home</code>이며, <code>IpAddrKind::V4</code> 값을 <code>kind</code>로 가지고 <code>127.0.0.1</code> 주소 데이터를 연관시킵니다. 두 번째 인스턴스는 <code>loopback</code>입니다. 이것은 <code>IpAddrKind</code>의 다른 variant인 <code>V6</code>를 <code>kind</code> 값으로 가지고 <code>::1</code> 주소를 연관시킵니다. 우리는 <code>kind</code>와 <code>address</code> 값을 함께 묶기 위해 구조체를 사용했으며, 이제 variant는 값과 연관됩니다.</p>
<p>그러나 동일한 개념을 열거형만 사용하여 표현하는 것이 더 간결합니다. 구조체 안에 열거형을 넣는 대신, 각 열거형 variant에 직접 데이터를 넣을 수 있습니다. <code>IpAddr</code> 열거형의 이 새로운 정의는 <code>V4</code>와 <code>V6</code> variant 모두 연관된 <code>String</code> 값을 가질 것이라고 말합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(String),
        V6(String),
    }

    let home = IpAddr::V4(String::from("127.0.0.1"));

    let loopback = IpAddr::V6(String::from("::1"));
<span class="boring">}</span></code></pre></pre>
<p>열거형의 각 variant에 직접 데이터를 첨부하므로, 추가 구조체가 필요 없습니다. 여기서 열거형이 작동하는 또 다른 세부 사항을 더 쉽게 볼 수 있습니다: 우리가 정의하는 각 열거형 variant의 이름은 열거형의 인스턴스를 구성하는 함수도 됩니다. 즉, <code>IpAddr::V4()</code>는 <code>String</code> 인수를 받아 <code>IpAddr</code> 타입의 인스턴스를 반환하는 함수 호출입니다. 열거형을 정의한 결과로 이 생성자 함수가 자동으로 정의됩니다.</p>
<p>구조체 대신 열거형을 사용하는 또 다른 장점은 각 variant가 다른 타입과 양의 연관 데이터를 가질 수 있다는 것입니다. 버전 4 IP 주소는 항상 0에서 255 사이의 값을 가지는 네 개의 숫자 구성 요소를 가질 것입니다. 만약 <code>V4</code> 주소를 네 개의 <code>u8</code> 값으로 저장하면서도 <code>V6</code> 주소를 하나의 <code>String</code> 값으로 표현하고 싶다면, 구조체로는 그렇게 할 수 없을 것입니다. 열거형은 이 경우를 쉽게 처리합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from("::1"));
<span class="boring">}</span></code></pre></pre>
<p>버전 4와 버전 6 IP 주소를 저장하기 위한 여러 가지 데이터 구조 정의 방법을 보여드렸습니다. 그러나 IP 주소를 저장하고 그 종류를 인코딩하는 것이 매우 흔한 일이라서 <a href="../std/net/enum.IpAddr.html">표준 라이브러리에 우리가 사용할 수 있는 정의가 있습니다!</a><!-- ignore --> 표준 라이브러리가 <code>IpAddr</code>를 어떻게 정의하는지 살펴보겠습니다. 우리가 정의하고 사용한 것과 정확히 동일한 열거형과 variant를 가지고 있지만, 각 variant에 대해 다르게 정의된 두 가지 다른 구조체 형태로 주소 데이터를 variant 내부에 포함합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ipv4Addr {
    // --생략--
}

struct Ipv6Addr {
    // --생략--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
<span class="boring">}</span></code></pre></pre>
<p>이 코드는 열거형 variant 안에 문자열, 숫자 타입, 또는 구조체와 같은 어떤 종류의 데이터도 넣을 수 있음을 보여줍니다. 심지어 다른 열거형을 포함할 수도 있습니다! 또한, 표준 라이브러리 타입은 종종 당신이 생각해낼 수 있는 것보다 훨씬 복잡하지 않습니다.</p>
<p>표준 라이브러리에 <code>IpAddr</code>에 대한 정의가 포함되어 있더라도, 표준 라이브러리의 정의를 우리 스코프로 가져오지 않았기 때문에 충돌 없이 우리만의 정의를 생성하고 사용할 수 있다는 점에 유의하세요. 7장에서 타입을 스코프로 가져오는 것에 대해 더 자세히 이야기할 것입니다.</p>
<p>목록 6-2에 있는 열거형의 또 다른 예를 살펴보겠습니다. 이 열거형은 variant에 다양한 타입이 내장되어 있습니다.</p>
<Listing number="6-2" caption="A `Message` enum whose variants each store different amounts and types of values">
<pre><pre class="playground"><code class="language-rust edition2021">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p>이 열거형은 네 가지 다른 타입을 가진 variant를 가집니다:</p>
<ul>
<li><code>Quit</code>은 연관된 데이터가 전혀 없습니다.</li>
<li><code>Move</code>는 구조체처럼 이름 있는 필드를 가집니다.</li>
<li><code>Write</code>는 단일 <code>String</code>을 포함합니다.</li>
<li><code>ChangeColor</code>는 세 개의 <code>i32</code> 값을 포함합니다.</li>
</ul>
<p>목록 6-2와 같은 variant를 가진 열거형을 정의하는 것은 다른 종류의 구조체 정의와 유사합니다. 단, 열거형은 <code>struct</code> 키워드를 사용하지 않고 모든 variant가 <code>Message</code> 타입 아래에 함께 그룹화된다는 점이 다릅니다. 다음 구조체들은 이전 열거형 variant들이 가지고 있는 동일한 데이터를 가질 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct QuitMessage; // 유닛 구조체
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // 튜플 구조체
struct ChangeColorMessage(i32, i32, i32); // 튜플 구조체
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>하지만 각각 고유한 타입을 가진 다른 구조체를 사용한다면, 목록 6-2에 정의된 <code>Message</code> 열거형처럼 단일 타입인 경우만큼 쉽게 이러한 종류의 메시지를 받는 함수를 정의할 수 없을 것입니다.</p>
<p>열거형과 구조체 사이에는 한 가지 더 유사점이 있습니다. <code>impl</code>을 사용하여 구조체에 메서드를 정의할 수 있는 것처럼, 열거형에도 메서드를 정의할 수 있습니다. 다음은 <code>Message</code> 열거형에 정의할 수 있는 <code>call</code>이라는 메서드입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    enum Message {
</span><span class="boring">        Quit,
</span><span class="boring">        Move { x: i32, y: i32 },
</span><span class="boring">        Write(String),
</span><span class="boring">        ChangeColor(i32, i32, i32),
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Message {
        fn call(&amp;self) {
            // 메서드 본문은 여기에 정의됩니다
        }
    }

    let m = Message::Write(String::from("hello"));
    m.call();
<span class="boring">}</span></code></pre></pre>
<p>메서드의 본문은 <code>self</code>를 사용하여 메서드가 호출된 값을 가져옵니다. 이 예제에서 우리는 <code>Message::Write(String::from("hello"))</code> 값을 가진 변수 <code>m</code>을 생성했으며, 이는 <code>m.call()</code>이 실행될 때 <code>call</code> 메서드 본문의 <code>self</code>가 됩니다.</p>
<p>표준 라이브러리에서 매우 흔하고 유용한 또 다른 열거형인 <code>Option</code>을 살펴보겠습니다.</p>
<h3 id="option-열거형과-null-값에-대한-이점"><a class="header" href="#option-열거형과-null-값에-대한-이점"><code>Option</code> 열거형과 Null 값에 대한 이점</a></h3>
<p>이 섹션에서는 표준 라이브러리에 의해 정의된 또 다른 열거형인 <code>Option</code>의 사례 연구를 탐구합니다. <code>Option</code> 타입은 값이 무엇인가일 수도 있고 아무것도 아닐 수도 있는 매우 흔한 시나리오를 인코딩합니다.</p>
<p>예를 들어, 비어 있지 않은 목록에서 첫 번째 항목을 요청하면 값을 얻게 됩니다. 비어 있는 목록에서 첫 번째 항목을 요청하면 아무것도 얻지 못합니다. 이 개념을 타입 시스템 측면에서 표현한다는 것은 컴파일러가 여러분이 처리해야 할 모든 사례를 처리했는지 확인할 수 있음을 의미합니다. 이 기능은 다른 프로그래밍 언어에서 매우 흔한 버그를 방지할 수 있습니다.</p>
<p>프로그래밍 언어 설계는 종종 어떤 기능을 포함하느냐의 관점에서 생각되지만, 제외하는 기능도 중요합니다. 러스트에는 다른 많은 언어들이 가지고 있는 null 기능이 없습니다. _Null_은 그곳에 값이 없음을 의미하는 값입니다. null이 있는 언어에서 변수는 항상 null 또는 null이 아님이라는 두 가지 상태 중 하나에 있을 수 있습니다.</p>
<p>null의 창시자인 토니 호어(Tony Hoare)는 2009년 발표인 “Null References: The Billion Dollar Mistake”에서 다음과 같이 말했습니다.</p>
<blockquote>
<p>나는 그것을 나의 10억 달러짜리 실수라고 부릅니다. 그 당시 나는 객체 지향 언어의 참조를 위한 최초의 포괄적인 타입 시스템을 설계하고 있었습니다. 나의 목표는 컴파일러에 의해 자동으로 수행되는 검사를 통해 모든 참조 사용이 절대적으로 안전함을 보장하는 것이었습니다. 하지만 나는 단지 구현하기가 너무 쉽다는 이유만으로 null 참조를 넣고 싶은 유혹을 떨쳐낼 수 없었습니다. 이것은 지난 40년 동안 아마도 10억 달러의 고통과 피해를 초래했을 수많은 오류, 취약점 및 시스템 크래시로 이어졌습니다.</p>
</blockquote>
<p>null 값의 문제는 null 값을 null이 아닌 값처럼 사용하려고 하면 어떤 종류의 오류가 발생한다는 것입니다. 이 null 또는 null이 아님 속성은 어디에나 존재하기 때문에 이러한 종류의 실수를 저지르기가 매우 쉽습니다.</p>
<p>하지만 null이 표현하려고 하는 개념은 여전히 유용한 것입니다. null은 어떤 이유로 현재 유효하지 않거나 결여된 값입니다.</p>
<p>문제는 개념 자체가 아니라 특정 구현에 있습니다. 따라서 러스트에는 null이 없지만, 값이 있거나 없는 개념을 인코딩할 수 있는 열거형이 있습니다. 이 열거형은 <code>Option&lt;T&gt;</code>이며, <a href="../std/option/enum.Option.html">표준 라이브러리에 의해 정의</a><!-- ignore -->된 내용은 다음과 같습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    None,
    Some(T),
}
<span class="boring">}</span></code></pre></pre>
<p><code>Option&lt;T&gt;</code> 열거형은 매우 유용하여 프렐류드(prelude)에도 포함되어 있습니다. 명시적으로 스코프로 가져올 필요가 없습니다. 그 variant들도 프렐류드에 포함되어 있습니다. <code>Option::</code> 접두사 없이 <code>Some</code>과 <code>None</code>을 직접 사용할 수 있습니다. <code>Option&lt;T&gt;</code> 열거형은 여전히 일반적인 열거형일 뿐이며, <code>Some(T)</code>와 <code>None</code>은 여전히 <code>Option&lt;T&gt;</code> 타입의 variant입니다.</p>
<p><code>&lt;T&gt;</code> 구문은 우리가 아직 이야기하지 않은 러스트의 기능입니다. 이는 제네릭 타입 매개변수이며, 10장에서 제네릭에 대해 더 자세히 다룰 것입니다. 지금은 <code>&lt;T&gt;</code>가 <code>Option</code> 열거형의 <code>Some</code> variant가 어떤 타입의 데이터라도 하나 가질 수 있음을 의미하며, <code>T</code> 자리에 사용되는 각 구체적인 타입이 전체 <code>Option&lt;T&gt;</code> 타입을 서로 다른 타입으로 만든다는 것만 알면 됩니다. 다음은 숫자 타입과 문자 타입을 담기 위해 <code>Option</code> 값을 사용하는 몇 가지 예입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let some_number = Some(5);
    let some_char = Some('e');

    let absent_number: Option&lt;i32&gt; = None;
<span class="boring">}</span></code></pre></pre>
<p><code>some_number</code>의 타입은 <code>Option&lt;i32&gt;</code>입니다. <code>some_char</code>의 타입은 <code>Option&lt;char&gt;</code>이며, 이는 다른 타입입니다. <code>Some</code> variant 내부에 값을 지정했기 때문에 러스트는 이러한 타입들을 추론할 수 있습니다. <code>absent_number</code>의 경우, 러스트는 전체 <code>Option</code> 타입을 명시할 것을 요구합니다. 컴파일러는 <code>None</code> 값만 보고서는 그에 대응하는 <code>Some</code> variant가 어떤 타입을 가질지 추론할 수 없기 때문입니다. 여기서 우리는 <code>absent_number</code>가 <code>Option&lt;i32&gt;</code> 타입임을 러스트에게 알립니다.</p>
<p><code>Some</code> 값을 가질 때, 우리는 값이 존재하고 그 값이 <code>Some</code> 안에 있다는 것을 압니다. <code>None</code> 값을 가질 때, 그것은 어떤 의미에서 null과 같은 의미입니다. 즉, 유효한 값이 없다는 것이죠. 그렇다면 <code>Option&lt;T&gt;</code>를 갖는 것이 null을 갖는 것보다 왜 더 나을까요?</p>
<p>요컨대, <code>Option&lt;T&gt;</code>와 <code>T</code>(<code>T</code>는 어떤 타입이든 될 수 있음)는 서로 다른 타입이기 때문에, 컴파일러는 <code>Option&lt;T&gt;</code> 값을 마치 확실히 유효한 값인 것처럼 사용하도록 내버려 두지 않습니다. 예를 들어, 다음 코드는 <code>i8</code>에 <code>Option&lt;i8&gt;</code>을 더하려 하기 때문에 컴파일되지 않습니다.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let x: i8 = 5;
    let y: Option&lt;i8&gt; = Some(5);

    let sum = x + y;
<span class="boring">}</span></code></pre>
<p>이 코드를 실행하면 다음과 같은 오류 메시지가 발생합니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option&lt;i8&gt;` to `i8`
 --&gt; src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option&lt;i8&gt;`
  |
  = help: the trait `Add&lt;Option&lt;i8&gt;&gt;` is not implemented for `i8`
  = help: the following other types implement trait `Add&lt;Rhs&gt;`:
            `&amp;'a i8` implements `Add&lt;i8&gt;`
            `&amp;i8` implements `Add&lt;&amp;i8&gt;`
            `i8` implements `Add&lt;&amp;i8&gt;`
            `i8` implements `Add`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums` (bin "enums") due to 1 previous error
</code></pre>
<p>강렬하군요! 사실상 이 오류 메시지는 러스트가 <code>i8</code>과 <code>Option&lt;i8&gt;</code>을 더하는 방법을 이해하지 못한다는 것을 의미합니다. 둘은 서로 다른 타입이기 때문이죠. 러스트에서 <code>i8</code>과 같은 타입의 값을 가질 때, 컴파일러는 우리가 항상 유효한 값을 갖고 있음을 보장할 것입니다. 우리는 그 값을 사용하기 전에 null 체크를 할 필요 없이 자신 있게 진행할 수 있습니다. 오직 <code>Option&lt;i8&gt;</code>(또는 우리가 작업 중인 어떤 타입의 값이든)을 가질 때만 값이 없을 가능성에 대해 걱정해야 하며, 컴파일러는 우리가 그 값을 사용하기 전에 해당 케이스를 처리하도록 보장할 것입니다.</p>
<p>즉, <code>T</code>에 대한 연산을 수행하기 전에 <code>Option&lt;T&gt;</code>를 <code>T</code>로 변환해야 합니다. 일반적으로 이는 null과 관련된 가장 흔한 문제 중 하나인, 실제로는 null인데 null이 아니라고 가정하는 문제를 잡아내는 데 도움이 됩니다.</p>
<p>null이 아닌 값을 잘못 가정하는 위험을 제거하면 코드에 대해 더 자신감을 가질 수 있게 됩니다. null일 가능성이 있는 값을 갖기 위해서는, 해당 값의 타입을 <code>Option&lt;T&gt;</code>로 만들어 명시적으로 선택해야 합니다. 그런 다음 그 값을 사용할 때, 값이 null인 경우를 명시적으로 처리해야 합니다. 값이 <code>Option&lt;T&gt;</code>가 아닌 타입을 가진 모든 곳에서, 여러분은 그 값이 null이 아니라고 <em>안전하게</em> 가정할 수 있습니다. 이는 null의 만연함을 제한하고 러스트 코드의 안전성을 높이기 위한 러스트의 의도적인 설계 결정이었습니다.</p>
<p>그렇다면 <code>Option&lt;T&gt;</code> 타입의 값을 가질 때, 그 값을 사용하기 위해 <code>Some</code> variant에서 <code>T</code> 값을 어떻게 꺼낼까요? <code>Option&lt;T&gt;</code> 열거형은 다양한 상황에서 유용한 많은 메서드를 가지고 있습니다. <a href="../std/option/enum.Option.html">문서</a><!-- ignore -->에서 확인해 보세요. <code>Option&lt;T&gt;</code>의 메서드들에 익숙해지는 것은 여러분의 러스트 여정에 매우 유용할 것입니다.</p>
<p>일반적으로 <code>Option&lt;T&gt;</code> 값을 사용하려면 각 variant를 처리하는 코드가 필요합니다. <code>Some(T)</code> 값을 가질 때만 실행되고 내부의 <code>T</code>를 사용할 수 있는 코드와, <code>None</code> 값을 가질 때만 실행되고 <code>T</code> 값을 사용할 수 없는 다른 코드가 필요할 것입니다. <code>match</code> 표현식은 열거형과 함께 사용될 때 바로 이 일을 하는 제어 흐름 구문입니다. 열거형의 어떤 variant이냐에 따라 서로 다른 코드를 실행하며, 그 코드는 매칭된 값 내부의 데이터를 사용할 수 있습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- Old heading. Do not remove or links may break. -->
<p><a id="the-match-control-flow-operator"></a></p>
<h2 id="match-제어-흐름-구조"><a class="header" href="#match-제어-흐름-구조"><code>match</code> 제어 흐름 구조</a></h2>
<p>러스트는 <code>match</code>라고 불리는 매우 강력한 제어 흐름 구문을 가지고 있는데, 이는 값을 일련의 패턴과 비교하여 어떤 패턴이 일치하느냐에 따라 코드를 실행할 수 있게 해줍니다. 패턴은 리터럴 값, 변수 이름, 와일드카드 및 기타 여러 가지로 구성될 수 있습니다. <a href="ch19-00-patterns.html">19장</a><!-- ignore -->에서는 모든 다양한 종류의 패턴과 그 역할을 다룹니다. <code>match</code>의 강력함은 패턴의 표현력과 모든 가능한 경우의 수가 처리되었음을 컴파일러가 확인한다는 사실에서 나옵니다.</p>
<p><code>match</code> 표현식을 동전 분류기와 비슷하다고 생각해 보세요. 동전들은 다양한 크기의 구멍이 뚫린 트랙을 따라 미끄러져 내려가며, 각 동전은 자신에게 맞는 첫 번째 구멍으로 떨어집니다. 마찬가지로, 값은 <code>match</code> 내의 각 패턴을 통과하며, 값이 “맞는” 첫 번째 패턴에서 해당 값은 실행 중에 사용될 관련 코드 블록으로 떨어집니다.</p>
<p>동전 이야기가 나왔으니, <code>match</code>를 사용하는 예제로 동전을 사용해 봅시다! 목록 6-3에 나타난 것처럼, 알 수 없는 미국 동전을 받아서 동전 분류기와 유사한 방식으로 그것이 어떤 동전인지 판별하고 그 가치를 센트 단위로 반환하는 함수를 작성할 수 있습니다.</p>
<Listing number="6-3" caption="An enum and a `match` expression that has the variants of the enum as its patterns">
<pre><pre class="playground"><code class="language-rust edition2021">enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p><code>value_in_cents</code> 함수의 <code>match</code>를 분석해 봅시다. 먼저 <code>match</code> 키워드를 적고 그 뒤에 표현식을 적는데, 이 경우 <code>coin</code> 값입니다. 이는 <code>if</code>와 함께 사용되는 조건식과 매우 유사해 보이지만, 큰 차이점이 있습니다. <code>if</code>의 경우 조건이 불리언 값으로 평가되어야 하지만, 여기서는 어떤 타입이든 될 수 있습니다. 이 예제에서 <code>coin</code>의 타입은 첫 번째 줄에서 정의한 <code>Coin</code> 열거형입니다.</p>
<p>다음은 <code>match</code> 암(arm)들입니다. 하나의 암은 패턴과 코드라는 두 부분으로 구성됩니다. 여기서 첫 번째 암은 <code>Coin::Penny</code>라는 값을 패턴으로 가지며, 그 뒤에 패턴과 실행할 코드를 구분하는 <code>=&gt;</code> 연산자가 옵니다. 이 경우 코드는 단지 <code>1</code>이라는 값입니다. 각 암은 다음 암과 쉼표로 구분됩니다.</p>
<p><code>match</code> 표현식이 실행되면, 결과 값을 각 암의 패턴과 순서대로 비교합니다. 패턴이 값과 일치하면, 그 패턴과 연관된 코드가 실행됩니다. 패턴이 값과 일치하지 않으면, 동전 분류기와 마찬가지로 다음 암으로 실행이 계속됩니다. 필요한 만큼 많은 암을 가질 수 있습니다. 목록 6-3에서 우리의 <code>match</code>는 네 개의 암을 가집니다.</p>
<p>각 암과 연관된 코드는 표현식이며, 매칭된 암의 표현식 결과 값은 전체 <code>match</code> 표현식에 대해 반환되는 값이 됩니다.</p>
<p>목록 6-3에서처럼 각 암이 단지 값을 반환하는 정도로 코드가 짧다면 보통 중괄호를 사용하지 않습니다. 만약 match 암에서 여러 줄의 코드를 실행하고 싶다면 중괄호를 사용해야 하며, 이 경우 암 뒤의 쉼표는 생략 가능합니다. 예를 들어, 다음 코드는 <code>Coin::Penny</code>와 함께 메서드가 호출될 때마다 “운 좋은 페니!”를 출력하지만, 여전히 블록의 마지막 값인 <code>1</code>을 반환합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter,
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; {
            println!("운 좋은 페니!");
            1
        }
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<h3 id="값에-바인딩하는-패턴"><a class="header" href="#값에-바인딩하는-패턴">값에 바인딩하는 패턴</a></h3>
<p>match 암의 또 다른 유용한 기능은 패턴과 일치하는 값의 일부에 바인딩할 수 있다는 점입니다. 이를 통해 열거형 variant에서 값을 추출할 수 있습니다.</p>
<p>예를 들어, 우리 열거형 variant 중 하나가 내부에 데이터를 가지도록 변경해 봅시다. 1999년부터 2008년까지 미국은 한쪽 면에 50개 주마다 다른 디자인을 넣은 쿼터(25센트 동전)를 주조했습니다. 다른 어떤 동전도 주마다 다른 디자인을 갖지 않았으므로, 쿼터만이 이 특별한 값을 가집니다. 우리는 <code>UsState</code> 값을 내부에 저장하도록 <code>Quarter</code> variant를 변경하여 이 정보를 <code>enum</code>에 추가할 수 있습니다. 목록 6-4에서 그 작업을 수행했습니다.</p>
<Listing number="6-4" caption="A `Coin` enum in which the `Quarter` variant also holds a `UsState` value">
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)] // 잠시 후에 상태를 검사할 수 있도록
enum UsState {
    Alabama,
    Alaska,
    // --생략--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p>한 친구가 50개 주의 쿼터를 모두 모으려 한다고 상상해 봅시다. 우리가 동전들을 종류별로 분류하는 동안, 각 쿼터에 연관된 주의 이름을 불러주어 만약 친구가 없는 것이라면 수집품에 추가할 수 있게 해줄 것입니다.</p>
<p>이 코드의 match 표현식에서, <code>Coin::Quarter</code> variant의 값과 일치하는 패턴에 <code>state</code>라는 변수를 추가합니다. <code>Coin::Quarter</code>가 매칭되면, <code>state</code> 변수는 해당 쿼터의 주(state) 값에 바인딩됩니다. 그러면 다음과 같이 해당 암의 코드에서 <code>state</code>를 사용할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --생략--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!("{state:?} 주 동전!");
            25
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    value_in_cents(Coin::Quarter(UsState::Alaska));
</span><span class="boring">}</span></code></pre></pre>
<p><code>value_in_cents(Coin::Quarter(UsState::Alaska))</code>를 호출하면 <code>coin</code>은 <code>Coin::Quarter(UsState::Alaska)</code>가 됩니다. 이 값을 각 매치 암과 비교하면 <code>Coin::Quarter(state)</code>에 도달할 때까지 아무것도 일치하지 않습니다. 그 시점에서 <code>state</code>에 대한 바인딩은 <code>UsState::Alaska</code> 값이 됩니다. 그런 다음 <code>println!</code> 표현식에서 해당 바인딩을 사용하여 <code>Quarter</code>에 대한 <code>Coin</code> 열거형 variant에서 내부 상태 값을 가져올 수 있습니다.</p>
<h3 id="optiont로-매칭하기"><a class="header" href="#optiont로-매칭하기"><code>Option&lt;T&gt;</code>로 매칭하기</a></h3>
<p>이전 섹션에서 우리는 <code>Option&lt;T&gt;</code>를 사용할 때 <code>Some</code> 케이스에서 내부의 <code>T</code> 값을 가져오고 싶었습니다. 우리는 <code>Coin</code> 열거형에서 했던 것처럼 <code>match</code>를 사용하여 <code>Option&lt;T&gt;</code>를 처리할 수 있습니다! 동전을 비교하는 대신 <code>Option&lt;T&gt;</code>의 variant들을 비교하게 되지만, <code>match</code> 표현식이 작동하는 방식은 동일합니다.</p>
<p><code>Option&lt;i32&gt;</code>를 인수로 받아서, 내부에 값이 있으면 그 값에 1을 더하는 함수를 작성하고 싶다고 가정해 봅시다. 내부에 값이 없으면 함수는 <code>None</code> 값을 반환하고 어떤 연산도 시도하지 않아야 합니다.</p>
<p><code>match</code> 덕분에 이 함수는 작성하기 매우 쉬우며, 목록 6-5와 같은 모습이 될 것입니다.</p>
<Listing number="6-5" caption="A function that uses a `match` expression on an `Option<i32>`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            None =&gt; None,
            Some(i) =&gt; Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
<span class="boring">}</span></code></pre></pre>
</Listing>
<p><code>plus_one</code>이 처음 실행되는 과정을 더 자세히 살펴봅시다. <code>plus_one(five)</code>를 호출하면, <code>plus_one</code> 본문의 변수 <code>x</code>는 <code>Some(5)</code> 값을 갖게 됩니다. 그런 다음 이를 각 match 암과 비교합니다.</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p><code>Some(5)</code> 값은 <code>None</code> 패턴과 일치하지 않으므로 다음 암으로 넘어갑니다.</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span><span class="boring">            None =&gt; None,
</span>            Some(i) =&gt; Some(i + 1),
<span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p><code>Some(5)</code>가 <code>Some(i)</code>와 일치하나요? 그렇습니다! 같은 variant입니다. <code>i</code>는 <code>Some</code>에 담긴 값에 바인딩되므로, <code>i</code>는 <code>5</code>라는 값을 갖게 됩니다. 그런 다음 match 암의 코드가 실행되어 <code>i</code> 값에 1을 더하고, 내부에 합계인 <code>6</code>을 담은 새로운 <code>Some</code> 값을 생성합니다.</p>
<p>이제 <code>x</code>가 <code>None</code>인 목록 6-5의 <code>plus_one</code> 두 번째 호출을 생각해 봅시다. <code>match</code>에 진입하여 첫 번째 암과 비교합니다.</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p>일치합니다! 더할 값이 없으므로 프로그램은 멈추고 <code>=&gt;</code> 오른쪽에 있는 <code>None</code> 값을 반환합니다. 첫 번째 암이 일치했으므로 다른 암은 비교하지 않습니다.</p>
<p><code>match</code>와 열거형을 결합하는 것은 많은 상황에서 유용합니다. 러스트 코드에서 이런 패턴을 많이 보게 될 것입니다: 열거형에 대해 <code>match</code>를 수행하고, 내부 데이터에 변수를 바인딩한 다음, 그에 따라 코드를 실행하는 것이죠. 처음에는 조금 까다롭지만, 일단 익숙해지면 모든 언어에 이 기능이 있었으면 좋겠다고 생각하게 될 것입니다. 이 기능은 사용자들에게 일관되게 사랑받는 기능입니다.</p>
<h3 id="매치는-완전해야-합니다"><a class="header" href="#매치는-완전해야-합니다">매치는 완전해야 합니다</a></h3>
<p><code>match</code>에 대해 논의해야 할 또 다른 측면이 있습니다: 암의 패턴은 모든 가능성을 다루어야 한다는 점입니다. 버그가 있어 컴파일되지 않는 다음 버전의 <code>plus_one</code> 함수를 생각해 봅시다.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            Some(i) =&gt; Some(i + 1),
        }
    }
<span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}</span></code></pre>
<p><code>None</code> 케이스를 처리하지 않았기 때문에 이 코드는 버그를 유발할 것입니다. 다행히 러스트는 이 버그를 잡아낼 줄 압니다. 이 코드를 컴파일하려고 시도하면 다음과 같은 오류를 보게 될 것입니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
   --&gt; src/main.rs:3:15
    |
3   |         match x {
    |               ^ pattern `None` not covered
    |
note: `Option&lt;i32&gt;` defined here
   --&gt; file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/core/src/option.rs:571:1
    |
571 | pub enum Option&lt;T&gt; {
    | ^^^^^^^^^^^^^^^^^^
...
575 |     None,
    |     ---- not covered
    = note: the matched value is of type `Option&lt;i32&gt;`
help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown
    |
4   ~             Some(i) =&gt; Some(i + 1),
5   ~             None =&gt; todo!(),
    |

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums` (bin "enums") due to 1 previous error
</code></pre>
<p>러스트는 우리가 모든 가능한 경우를 다루지 않았음을 알고 있으며, 심지어 우리가 어떤 패턴을 잊었는지도 알고 있습니다! 러스트의 매칭은 _철저(exhaustive)_해야 합니다. 코드가 유효하려면 마지막 가능성 하나까지 모두 소진해야 합니다. 특히 <code>Option&lt;T&gt;</code>의 경우, 러스트가 <code>None</code> 케이스를 명시적으로 처리하는 것을 잊지 않게 함으로써, 값이 null일 수도 있는데 값이 있다고 가정하는 것으로부터 우리를 보호합니다. 이로써 앞서 논의한 10억 달러짜리 실수를 불가능하게 만듭니다.</p>
<h3 id="모든-것을-포괄하는-패턴과-_-플레이스홀더"><a class="header" href="#모든-것을-포괄하는-패턴과-_-플레이스홀더">모든 것을 포괄하는 패턴과 <code>_</code> 플레이스홀더</a></h3>
<p>열거형을 사용하면 몇 가지 특정 값에 대해 특별한 조치를 취하고, 나머지 모든 값에 대해서는 하나의 기본 조치를 취할 수도 있습니다. 주사위를 굴려서 3이 나오면 플레이어는 이동하지 않고 대신 멋진 새 모자를 얻고, 7이 나오면 멋진 모자를 잃는 게임을 구현한다고 상상해 봅시다. 그 외의 모든 값에 대해서는 플레이어가 주사위 눈만큼 게임 판에서 이동합니다. 여기 그 로직을 구현한 <code>match</code>가 있습니다. 주사위 결과는 난수 대신 하드코딩되어 있고, 다른 모든 로직은 실제 구현이 이 예제의 범위를 벗어나기 때문에 본문이 없는 함수로 표현되었습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        other =&gt; move_player(other),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn move_player(num_spaces: u8) {}
<span class="boring">}</span></code></pre></pre>
<p>처음 두 암(arm)의 패턴은 리터럴 값 <code>3</code>과 <code>7</code>입니다. 다른 모든 가능한 값을 다루는 마지막 암의 패턴은 우리가 <code>other</code>라고 이름 붙인 변수입니다. <code>other</code> 암에 대해 실행되는 코드는 이 변수를 <code>move_player</code> 함수에 전달하여 사용합니다.</p>
<p><code>u8</code>이 가질 수 있는 모든 가능한 값을 나열하지 않았음에도 이 코드가 컴파일되는 이유는, 마지막 패턴이 명시적으로 나열되지 않은 모든 값과 일치하기 때문입니다. 이러한 포괄적(catch-all) 패턴은 <code>match</code>가 철저해야 한다는 요구 사항을 충족합니다. 패턴은 순서대로 평가되기 때문에 포괄적 암을 반드시 마지막에 두어야 함에 유의하세요. 포괄적 암을 앞에 두면 그 뒤의 암들은 절대 실행되지 않으므로, 러스트는 포괄적 암 뒤에 다른 암을 추가하면 경고를 보냅니다!</p>
<p>러스트에는 포괄적 패턴을 원하지만 그 값을 _사용_하고 싶지는 않을 때 사용할 수 있는 패턴도 있습니다. <code>_</code>는 모든 값과 일치하지만 그 값에 바인딩되지는 않는 특별한 패턴입니다. 이는 러스트에게 우리가 그 값을 사용하지 않을 것임을 알려주며, 따라서 러스트는 사용되지 않는 변수에 대해 경고하지 않습니다.</p>
<p>게임 규칙을 변경해 봅시다: 이제 3이나 7이 아닌 다른 것을 굴리면 다시 굴려야 합니다. 더 이상 catch-all 값을 사용할 필요가 없으므로, <code>other</code>라는 변수 대신 <code>_</code>를 사용하도록 코드를 변경할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        _ =&gt; reroll(),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn reroll() {}
<span class="boring">}</span></code></pre></pre>
<p>이 예제는 마지막 arm에서 다른 모든 값을 명시적으로 무시하므로 완전성 요구 사항도 충족합니다. 우리는 아무것도 잊지 않았습니다.</p>
<p>마지막으로, 게임 규칙을 한 번 더 변경하여 3이나 7이 아닌 다른 것을 굴리면 당신의 차례에 아무 일도 일어나지 않도록 할 것입니다. 이는 유닛 값( <a href="ch03-02-data-types.html#the-tuple-type">“튜플 타입”</a><!-- ignore --> 섹션에서 언급한 빈 튜플 타입)을 <code>_</code> arm과 함께 가는 코드로 사용하여 표현할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        _ =&gt; (),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
<span class="boring">}</span></code></pre></pre>
<p>여기서 우리는 러스트에게 이전 arm의 패턴과 일치하지 않는 다른 어떤 값도 사용하지 않을 것이며, 이 경우 어떤 코드도 실행하고 싶지 않다고 명시적으로 말하고 있습니다.</p>
<p><a href="ch19-00-patterns.html">19장</a><!-- ignore -->에서 패턴과 매칭에 대해 더 자세히 다룰 것입니다. 지금은 <code>match</code> 표현식이 다소 장황한 상황에서 유용할 수 있는 <code>if let</code> 구문으로 넘어가겠습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="if-let과-let-else를-사용한-간결한-제어-흐름"><a class="header" href="#if-let과-let-else를-사용한-간결한-제어-흐름"><code>if let</code>과 <code>let else</code>를 사용한 간결한 제어 흐름</a></h2>
<p><code>if let</code> 구문은 <code>if</code>와 <code>let</code>을 결합하여 하나의 패턴과 일치하는 값을 처리하고 나머지는 무시하는 덜 장황한 방법을 제공합니다. <code>config_max</code> 변수의 <code>Option&lt;u8&gt;</code> 값과 일치하지만 값이 <code>Some</code> variant인 경우에만 코드를 실행하려는 목록 6-6의 프로그램을 고려해 보세요.</p>
<Listing number="6-6" caption="A `match` that only cares about executing code when the value is `Some`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let config_max = Some(3u8);
    match config_max {
        Some(max) =&gt; println!("최댓값이 {max}로 설정되었습니다"),
        _ =&gt; (),
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>값이 <code>Some</code>이면, 패턴에서 값을 변수 <code>max</code>에 바인딩하여 <code>Some</code> variant 안의 값을 출력합니다. 우리는 <code>None</code> 값에 대해서는 아무것도 하고 싶지 않습니다. <code>match</code> 표현식을 만족시키려면 단 하나의 variant만 처리한 후에도 <code>_ =&gt; ()</code>를 추가해야 하는데, 이는 추가하기 번거로운 보일러플레이트 코드입니다.</p>
<p>대신, <code>if let</code>을 사용하여 이를 더 짧게 쓸 수 있습니다. 다음 코드는 목록 6-6의 <code>match</code>와 동일하게 동작합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let config_max = Some(3u8);
    if let Some(max) = config_max {
        println!("최댓값이 {max}로 설정되었습니다");
    }
<span class="boring">}</span></code></pre></pre>
<p><code>if let</code> 문법은 등호로 구분된 패턴과 표현식을 받습니다. 이는 표현식이 <code>match</code>에 주어지고 패턴이 그 첫 번째 암인 <code>match</code>와 동일하게 작동합니다. 이 경우 패턴은 <code>Some(max)</code>이며, <code>max</code>는 <code>Some</code> 내부의 값에 바인딩됩니다. 그런 다음 대응하는 <code>match</code> 암에서 <code>max</code>를 사용했던 것과 동일한 방식으로 <code>if let</code> 블록 본문에서 <code>max</code>를 사용할 수 있습니다. <code>if let</code> 블록의 코드는 값이 패턴과 일치할 때만 실행됩니다.</p>
<p><code>if let</code>을 사용하면 타이핑이 줄어들고, 들여쓰기가 줄어들며, 보일러플레이트 코드도 줄어듭니다. 하지만 <code>match</code>가 강제하는 철저한 검사 기능을 잃게 됩니다. <code>match</code>와 <code>if let</code> 사이의 선택은 여러분의 특정 상황에서 무엇을 하고 있는지, 그리고 간결함을 얻는 것이 철저한 검사를 잃는 것에 대한 적절한 트레이드오프인지에 따라 달라집니다.</p>
<p>다시 말해, <code>if let</code>을 값이 하나의 패턴과 일치할 때 코드를 실행하고 다른 모든 값은 무시하는 <code>match</code>에 대한 구문 설탕(syntax sugar)으로 생각할 수 있습니다.</p>
<p><code>if let</code>과 함께 <code>else</code>를 포함할 수도 있습니다. <code>else</code>와 함께 가는 코드 블록은 <code>if let</code> 및 <code>else</code>와 동일한 <code>match</code> 표현식에서 <code>_</code> 케이스와 함께 가는 코드 블록과 같습니다. <code>Quarter</code> variant가 <code>UsState</code> 값도 가졌던 목록 6-4의 <code>Coin</code> 열거형 정의를 기억해 보세요. 쿼터가 아닌 모든 동전의 개수를 세면서 쿼터의 주(state)를 발표하고 싶다면, 다음과 같이 <code>match</code> 표현식으로 할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --생략--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let coin = Coin::Penny;
</span>    let mut count = 0;
    match coin {
        Coin::Quarter(state) =&gt; println!("{state:?} 주 동전!"),
        _ =&gt; count += 1,
    }
<span class="boring">}</span></code></pre></pre>
<p>또는 다음과 같이 <code>if let</code>과 <code>else</code> 표현식을 사용할 수도 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --생략--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let coin = Coin::Penny;
</span>    let mut count = 0;
    if let Coin::Quarter(state) = coin {
        println!("{state:?} 주 동전!");
    } else {
        count += 1;
    }
<span class="boring">}</span></code></pre></pre>
<h2 id="let-else로-행복한-경로-유지하기"><a class="header" href="#let-else로-행복한-경로-유지하기"><code>let else</code>로 “행복한 경로” 유지하기</a></h2>
<p>한 가지 흔한 패턴은 값이 존재할 때 어떤 계산을 수행하고 그렇지 않으면 기본값을 반환하는 것입니다. <code>UsState</code> 값을 가진 동전 예제를 계속해서, 쿼터에 있는 주가 얼마나 오래되었는지에 따라 재미있는 말을 하고 싶다면, 다음과 같이 주의 나이를 확인하는 메서드를 <code>UsState</code>에 도입할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)] // 잠시 후에 상태를 검사할 수 있도록
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --생략--
</span><span class="boring">}
</span><span class="boring">
</span>impl UsState {
    fn existed_in(&amp;self, year: u16) -&gt; bool {
        match self {
            UsState::Alabama =&gt; year &gt;= 1819,
            UsState::Alaska =&gt; year &gt;= 1959,
            // -- 생략 --
        }
    }
}
<span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn describe_state_quarter(coin: Coin) -&gt; Option&lt;String&gt; {
</span><span class="boring">    if let Coin::Quarter(state) = coin {
</span><span class="boring">        if state.existed_in(1900) {
</span><span class="boring">            Some(format!("{state:?}는 미국치고는 꽤 오래되었네요!"))
</span><span class="boring">        } else {
</span><span class="boring">            Some(format!("{state:?}는 상대적으로 새 주네요."))
</span><span class="boring">        }
</span><span class="boring">    } else {
</span><span class="boring">        None
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    if let Some(desc) = describe_state_quarter(Coin::Quarter(UsState::Alaska)) {
</span><span class="boring">        println!("{desc}");
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<p>그런 다음 <code>if let</code>을 사용하여 코인의 타입과 일치시키고, 목록 6-7과 같이 조건 본문 내에 <code>state</code> 변수를 도입할 수 있습니다.</p>
<Listing number="6-7" caption="Using" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)] // 잠시 후에 상태를 검사할 수 있도록
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --생략--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl UsState {
</span><span class="boring">    fn existed_in(&amp;self, year: u16) -&gt; bool {
</span><span class="boring">        match self {
</span><span class="boring">            UsState::Alabama =&gt; year &gt;= 1819,
</span><span class="boring">            UsState::Alaska =&gt; year &gt;= 1959,
</span><span class="boring">            // -- 생략 --
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn describe_state_quarter(coin: Coin) -&gt; Option&lt;String&gt; {
    if let Coin::Quarter(state) = coin {
        if state.existed_in(1900) {
            Some(format!("{state:?}는 미국치고는 꽤 오래되었네요!"))
        } else {
            Some(format!("{state:?}는 상대적으로 새 주네요."))
        }
    } else {
        None
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    if let Some(desc) = describe_state_quarter(Coin::Quarter(UsState::Alaska)) {
</span><span class="boring">        println!("{desc}");
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>그것은 작업을 완료하지만, 작업을 <code>if let</code> 문의 본문으로 밀어 넣었고, 수행할 작업이 더 복잡하다면 최상위 분기가 어떻게 관련되는지 정확히 파악하기 어려울 수 있습니다. 우리는 표현식이 값을 생성한다는 사실을 활용하여 <code>if let</code>에서 <code>state</code>를 생성하거나 목록 6-8과 같이 일찍 반환할 수도 있습니다. (물론 <code>match</code>로도 유사하게 할 수 있습니다!)</p>
<Listing number="6-8" caption="Using `if let` to produce a value or return early." file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)] // 잠시 후에 상태를 검사할 수 있도록
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --생략--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl UsState {
</span><span class="boring">    fn existed_in(&amp;self, year: u16) -&gt; bool {
</span><span class="boring">        match self {
</span><span class="boring">            UsState::Alabama =&gt; year &gt;= 1819,
</span><span class="boring">            UsState::Alaska =&gt; year &gt;= 1959,
</span><span class="boring">            // -- 생략 --
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn describe_state_quarter(coin: Coin) -&gt; Option&lt;String&gt; {
    let state = if let Coin::Quarter(state) = coin {
        state
    } else {
        return None;
    };

    if state.existed_in(1900) {
        Some(format!("{state:?}는 미국치고는 꽤 오래되었네요!"))
    } else {
        Some(format!("{state:?}는 상대적으로 새 주네요."))
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    if let Some(desc) = describe_state_quarter(Coin::Quarter(UsState::Alaska)) {
</span><span class="boring">        println!("{desc}");
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>하지만 이것은 나름대로 따라가기 좀 번거롭습니다! <code>if let</code>의 한 분기는 값을 생성하고, 다른 분기는 함수에서 완전히 반환됩니다.</p>
<p>이러한 흔한 패턴을 더 멋지게 표현하기 위해, 러스트에는 <code>let</code>-<code>else</code>가 있습니다. <code>let</code>-<code>else</code> 구문은 왼쪽에 패턴을, 오른쪽에 표현식을 취하며, <code>if let</code>과 매우 유사하지만 <code>if</code> 분기 없이 오직 <code>else</code> 분기만 가집니다. 패턴이 일치하면, 패턴에서 나온 값을 바깥 스코프에 바인딩합니다. 만약 패턴이 일치하지 <em>않으면</em>, 프로그램 흐름은 <code>else</code> 암(arm)으로 들어가며, 이 암은 반드시 함수에서 반환되어야 합니다.</p>
<p>목록 6-9에서는 목록 6-8을 <code>if let</code> 대신 <code>let</code>-<code>else</code>를 사용하여 작성했을 때 어떤 모습인지 볼 수 있습니다. <code>if let</code>이 두 분기에 대해 상당히 다른 제어 흐름을 가졌던 것과 달리, 이 방식은 함수의 주요 본문에서 “행복한 경로(happy path)”를 유지한다는 점에 주목하세요.</p>
<Listing number="6-9" caption="Using `let`-`else` to clarify the flow through the function." file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)] // 잠시 후에 상태를 검사할 수 있도록
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --생략--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl UsState {
</span><span class="boring">    fn existed_in(&amp;self, year: u16) -&gt; bool {
</span><span class="boring">        match self {
</span><span class="boring">            UsState::Alabama =&gt; year &gt;= 1819,
</span><span class="boring">            UsState::Alaska =&gt; year &gt;= 1959,
</span><span class="boring">            // -- 생략 --
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn describe_state_quarter(coin: Coin) -&gt; Option&lt;String&gt; {
    let Coin::Quarter(state) = coin else {
        return None;
    };

    if state.existed_in(1900) {
        Some(format!("{state:?}는 미국치고는 꽤 오래되었네요!"))
    } else {
        Some(format!("{state:?}는 상대적으로 새 주네요."))
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    if let Some(desc) = describe_state_quarter(Coin::Quarter(UsState::Alaska)) {
</span><span class="boring">        println!("{desc}");
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>프로그램의 로직이 <code>match</code>를 사용하기에는 너무 장황한 상황이라면, <code>if let</code>과 <code>let else</code> 또한 여러분의 러스트 도구함에 있다는 사실을 기억하세요.</p>
<h2 id="요약-5"><a class="header" href="#요약-5">요약</a></h2>
<p>지금까지 우리는 나열된 값 중 하나가 될 수 있는 커스텀 타입을 만들기 위해 열거형을 사용하는 방법을 살펴보았습니다. 또한 표준 라이브러리의 <code>Option&lt;T&gt;</code> 타입이 오류를 방지하기 위해 타입 시스템을 사용하는 데 어떻게 도움이 되는지도 보여드렸습니다. 열거형 값이 내부에 데이터를 가지고 있는 경우, 처리해야 할 사례의 수에 따라 <code>match</code>나 <code>if let</code>을 사용하여 해당 값들을 추출하고 사용할 수 있습니다.</p>
<p>이제 여러분의 러스트 프로그램은 구조체와 열거형을 사용하여 여러분의 도메인 내의 개념들을 표현할 수 있습니다. 여러분의 API에서 사용할 커스텀 타입을 만드는 것은 타입 안전성을 보장합니다. 즉, 컴파일러는 여러분의 함수가 오직 각 함수가 기대하는 타입의 값만을 받도록 확실히 할 것입니다.</p>
<p>사용자에게 사용하기 쉽고 오직 필요한 것만 노출하는 잘 구성된 API를 제공하기 위해, 이제 러스트의 모듈에 대해 살펴보겠습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="패키지-크레이트-모듈로-성장하는-프로젝트-관리하기"><a class="header" href="#패키지-크레이트-모듈로-성장하는-프로젝트-관리하기">패키지, 크레이트, 모듈로 성장하는 프로젝트 관리하기</a></h1>
<p>대규모 프로그램을 작성할수록 코드를 조직화하는 것이 점점 더 중요해집니다. 관련 기능을 그룹화하고 별개의 특징을 가진 코드를 분리함으로써, 특정 기능을 구현하는 코드가 어디에 있는지, 그리고 기능의 작동 방식을 변경하려면 어디로 가야 하는지를 명확히 할 수 있습니다.</p>
<p>지금까지 우리가 작성한 프로그램들은 하나의 파일 안의 하나의 모듈에 있었습니다. 프로젝트가 커짐에 따라, 여러분은 코드를 여러 모듈로 나눈 다음 여러 파일로 분리하여 조직화해야 합니다. 패키지는 여러 개의 바이너리 크레이트를 포함할 수 있고, 선택적으로 하나의 라이브러리 크레이트를 포함할 수 있습니다. 패키지가 커지면 일부를 별도의 크레이트로 추출하여 외부 의존성으로 만들 수 있습니다. 이번 장에서는 이 모든 기법들을 다룹니다. 함께 진화하는 상호 관련된 패키지들로 구성된 매우 큰 프로젝트의 경우, Cargo는 _워크스페이스(workspaces)_를 제공하는데, 이는 14장의 <a href="ch14-03-cargo-workspaces.html">“Cargo 워크스페이스”</a><!-- ignore -->에서 다룰 것입니다.</p>
<p>또한 구현 세부 사항을 캡슐화하는 것에 대해서도 논의할 것입니다. 이를 통해 더 높은 수준에서 코드를 재사용할 수 있습니다. 즉, 어떤 작업을 한 번 구현하고 나면, 다른 코드는 구현 방식이 어떻게 되는지 알 필요 없이 공개 인터페이스(public interface)를 통해 여러분의 코드를 호출할 수 있습니다. 여러분이 코드를 작성하는 방식은 어떤 부분이 다른 코드가 사용할 수 있는 공개 부분인지, 그리고 어떤 부분이 여러분이 변경할 권리를 갖는 비공개 구현 세부 사항인지를 정의합니다. 이는 여러분이 머릿속에 담아두어야 할 세부 사항의 양을 제한하는 또 다른 방법입니다.</p>
<p>관련된 개념은 스코프(scope)입니다. 코드가 작성되는 중첩된 맥락은 “스코프 안에(in scope)” 정의된 이름들의 집합을 가집니다. 코드를 읽고, 쓰고, 컴파일할 때 프로그래머와 컴파일러는 특정 지점의 특정 이름이 변수, 함수, 구조체, 열거형, 모듈, 상수 또는 다른 항목을 가리키는지, 그리고 그 항목이 무엇을 의미하는지 알아야 합니다. 여러분은 스코프를 생성하고 어떤 이름이 스코프 안에 있거나 밖에 있는지 변경할 수 있습니다. 동일한 스코프 내에 같은 이름을 가진 두 항목을 가질 수 없으며, 이름 충돌을 해결하기 위한 도구들이 준비되어 있습니다.</p>
<p>러스트는 어떤 세부 사항이 노출되는지, 어떤 세부 사항이 비공개인지, 그리고 프로그램의 각 스코프에 어떤 이름들이 있는지 등 코드의 조직화를 관리할 수 있게 해주는 여러 기능을 가지고 있습니다. 때때로 _모듈 시스템(module system)_이라고 통칭되는 이러한 기능들은 다음을 포함합니다.</p>
<ul>
<li><strong>패키지(Packages):</strong> 크레이트를 빌드, 테스트, 공유할 수 있게 해주는 Cargo 기능입니다.</li>
<li><strong>크레이트(Crates):</strong> 라이브러리나 실행 파일을 생성하는 모듈들의 트리입니다.</li>
<li>**모듈(Modules)**과 <strong>use:</strong> 경로의 조직화, 스코프, 프라이버시를 제어할 수 있게 해줍니다.</li>
<li><strong>경로(Paths):</strong> 구조체, 함수, 모듈 등의 항목에 이름을 붙이는 방법입니다.</li>
</ul>
<p>이번 장에서는 이러한 모든 기능을 다루고, 기능들이 서로 어떻게 상호작용하는지 논의하며, 스코프를 관리하기 위해 이를 사용하는 방법을 설명할 것입니다. 장을 마칠 때쯤이면 여러분은 모듈 시스템을 확실히 이해하게 될 것이며, 전문가처럼 스코프를 다룰 수 있게 될 것입니다!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="패키지와-크레이트"><a class="header" href="#패키지와-크레이트">패키지와 크레이트</a></h2>
<p>우리가 다룰 모듈 시스템의 첫 번째 부분은 패키지와 크레이트입니다.</p>
<p>_크레이트(crate)_는 러스트 컴파일러가 한 번에 고려하는 최소 단위의 코드입니다. 만약 여러분이 <code>cargo</code> 대신 <code>rustc</code>를 실행하여 단일 소스 코드 파일을 전달하더라도(1장의 “러스트 프로그램 작성하고 실행하기”에서 했던 것처럼), 컴파일러는 해당 파일을 하나의 크레이트로 간주합니다. 크레이트는 모듈을 포함할 수 있으며, 이어지는 섹션들에서 보게 되듯이 모듈은 크레이트와 함께 컴파일되는 다른 파일들에 정의될 수도 있습니다.</p>
<p>크레이트는 바이너리 크레이트나 라이브러리 크레이트 중 하나의 형태가 될 수 있습니다. _바이너리 크레이트(binary crates)_는 명령줄 프로그램이나 서버와 같이 여러분이 실행할 수 있는 파일로 컴파일할 수 있는 프로그램입니다. 각 바이너리 크레이트는 실행 파일이 실행될 때 어떤 일이 일어날지 정의하는 <code>main</code>이라는 이름의 함수를 반드시 가지고 있어야 합니다. 지금까지 우리가 만든 모든 크레이트는 바이너리 크레이트였습니다.</p>
<p>_라이브러리 크레이트(library crates)_는 <code>main</code> 함수를 가지지 않으며, 실행 파일로 컴파일되지 않습니다. 대신, 여러 프로젝트에서 공유될 의도인 기능을 정의합니다. 예를 들어, <a href="ch02-00-guessing-game-tutorial.html#generating-a-random-number">2장</a><!-- ignore -->에서 사용한 <code>rand</code> 크레이트는 난수를 생성하는 기능을 제공합니다. 대부분의 경우 러스트 사용자(Rustaceans)들이 “크레이트”라고 말할 때는 라이브러리 크레이트를 의미하며, 일반적인 프로그래밍 개념인 “라이브러리”와 혼용해서 사용합니다.</p>
<p>_크레이트 루트(crate root)_는 러스트 컴파일러가 시작점이자 여러분의 크레이트의 루트 모듈을 구성하는 소스 파일입니다(<a href="ch07-02-defining-modules-to-control-scope-and-privacy.html">“스코프와 프라이버시를 제어하는 모듈 정의하기”</a><!-- ignore -->에서 모듈에 대해 깊이 있게 설명할 것입니다).</p>
<p>_패키지(package)_는 일련의 기능을 제공하는 하나 이상의 크레이트 묶음입니다. 패키지는 해당 크레이트들을 어떻게 빌드할지 설명하는 <em>Cargo.toml</em> 파일을 포함합니다. Cargo는 사실 여러분이 코드를 빌드할 때 사용해 온 명령줄 도구의 바이너리 크레이트를 포함하는 패키지입니다. 또한 Cargo 패키지는 바이너리 크레이트가 의존하는 라이브러리 크레이트도 포함하고 있습니다. 다른 프로젝트들은 Cargo 라이브러리 크레이트에 의존하여 Cargo 명령줄 도구가 사용하는 것과 동일한 로직을 사용할 수 있습니다. 패키지는 여러분이 원하는 만큼 많은 바이너리 크레이트를 포함할 수 있지만, 라이브러리 크레이트는 최대 하나만 가질 수 있습니다. 패키지는 라이브러리든 바이너리든 상관없이 적어도 하나의 크레이트를 포함해야 합니다.</p>
<p>패키지를 만들 때 어떤 일이 일어나는지 살펴봅시다. 먼저 <code>cargo new my-project</code> 명령을 입력합니다.</p>
<pre><code class="language-console">$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
</code></pre>
<p><code>cargo new my-project</code>를 실행한 후, <code>ls</code>를 사용하여 Cargo가 무엇을 생성하는지 확인해 봅니다. 프로젝트 디렉토리에는 <em>Cargo.toml</em> 파일이 있어 패키지를 구성합니다. 또한 _main.rs_를 포함하는 <em>src</em> 디렉토리도 있습니다. 텍스트 편집기로 _Cargo.toml_을 열어보면 _src/main.rs_에 대한 언급이 없음을 알 수 있습니다. Cargo는 _src/main.rs_가 패키지와 동일한 이름을 가진 바이너리 크레이트의 크레이트 루트라는 관례를 따릅니다. 마찬가지로, Cargo는 패키지 디렉토리에 _src/lib.rs_가 포함되어 있으면, 해당 패키지가 패키지와 동일한 이름을 가진 라이브러리 크레이트를 포함하고 있으며 _src/lib.rs_가 그 크레이트 루트임을 압니다. Cargo는 라이브러리나 바이너리를 빌드하기 위해 크레이트 루트 파일들을 <code>rustc</code>에 전달합니다.</p>
<p>여기서 우리는 _src/main.rs_만 포함하는 패키지를 가지고 있는데, 이는 오직 <code>my-project</code>라는 이름의 바이너리 크레이트만 포함하고 있음을 의미합니다. 만약 패키지가 _src/main.rs_와 _src/lib.rs_를 모두 포함하고 있다면, 패키지 이름과 동일한 이름을 가진 바이너리 크레이트와 라이브러리 크레이트 두 개를 갖게 됩니다. 패키지는 <em>src/bin</em> 디렉토리에 파일들을 배치함으로써 여러 개의 바이너리 크레이트를 가질 수 있는데, 각 파일은 별개의 바이너리 크레이트가 됩니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="스코프와-프라이버시를-제어하는-모듈-정의하기"><a class="header" href="#스코프와-프라이버시를-제어하는-모듈-정의하기">스코프와 프라이버시를 제어하는 모듈 정의하기</a></h2>
<p>이번 섹션에서는 모듈과 모듈 시스템의 다른 부분들, 즉 항목에 이름을 붙일 수 있게 해주는 <em>경로(paths)</em>, 경로를 스코프로 가져오는 <code>use</code> 키워드, 그리고 항목을 공개로 만드는 <code>pub</code> 키워드에 대해 이야기하겠습니다. 또한 <code>as</code> 키워드, 외부 패키지, 그리고 글롭(glob) 연산자에 대해서도 논의할 것입니다.</p>
<h3 id="모듈-치트-시트"><a class="header" href="#모듈-치트-시트">모듈 치트 시트</a></h3>
<p>모듈과 경로에 대한 자세한 내용을 살펴보기 전에, 여기서는 모듈, 경로, <code>use</code> 키워드, 그리고 <code>pub</code> 키워드가 컴파일러에서 어떻게 작동하는지, 그리고 대부분의 개발자들이 코드를 어떻게 조직화하는지에 대한 빠른 참조를 제공합니다. 이번 장 전반에 걸쳐 이러한 규칙들의 각 예제를 살펴볼 것이지만, 이곳은 모듈의 작동 방식을 상기하고 싶을 때 참조하기에 아주 좋은 곳입니다.</p>
<ul>
<li><strong>크레이트 루트에서 시작</strong>: 크레이트를 컴파일할 때, 컴파일러는 먼저 크레이트 루트 파일(보통 라이브러리 크레이트의 경우 <em>src/lib.rs</em>, 바이너리 크레이트의 경우 <em>src/main.rs</em>)에서 컴파일할 코드를 찾습니다.</li>
<li><strong>모듈 선언</strong>: 크레이트 루트 파일에서 새로운 모듈을 선언할 수 있습니다. 예를 들어 <code>mod garden;</code>으로 “garden” 모듈을 선언한다고 해봅시다. 컴파일러는 다음 장소들에서 모듈의 코드를 찾을 것입니다:
<ul>
<li><code>mod garden</code> 뒤의 세미콜론을 대신하는 중괄호 안의 인라인 코드</li>
<li><em>src/garden.rs</em> 파일에</li>
<li><em>src/garden/mod.rs</em> 파일에</li>
</ul>
</li>
<li><strong>서브모듈 선언</strong>: 크레이트 루트가 아닌 다른 파일에서 서브모듈을 선언할 수 있습니다. 예를 들어 _src/garden.rs_에서 <code>mod vegetables;</code>를 선언할 수 있습니다. 컴파일러는 부모 모듈의 이름을 딴 디렉토리 내의 다음 장소들에서 서브모듈의 코드를 찾을 것입니다:
<ul>
<li><code>mod vegetables</code> 바로 뒤의 세미콜론 대신 중괄호 안의 인라인 코드</li>
<li><em>src/garden/vegetables.rs</em> 파일에</li>
<li><em>src/garden/vegetables/mod.rs</em> 파일에</li>
</ul>
</li>
<li><strong>모듈 내 코드에 대한 경로</strong>: 모듈이 크레이트의 일부가 되면, 프라이버시 규칙이 허용하는 한 해당 크레이트 내의 어디에서나 코드 경로를 사용하여 그 모듈의 코드를 참조할 수 있습니다. 예를 들어, garden vegetables 모듈의 <code>Asparagus</code> 타입은 <code>crate::garden::vegetables::Asparagus</code>에서 찾을 수 있습니다.</li>
<li><strong>비공개 vs 공개</strong>: 모듈 내의 코드는 기본적으로 부모 모듈로부터 비공개(private) 상태입니다. 모듈을 공개(public)로 만들려면 <code>mod</code> 대신 <code>pub mod</code>로 선언합니다. 공개 모듈 내의 항목들도 공개로 만들려면 선언 앞에 <code>pub</code>을 사용합니다.</li>
<li><strong><code>use</code> 키워드</strong>: 스코프 내에서 <code>use</code> 키워드는 긴 경로의 반복을 줄이기 위해 항목에 대한 바로가기를 만듭니다. <code>crate::garden::vegetables::Asparagus</code>를 참조할 수 있는 어떤 스코프에서든 <code>use crate::garden::vegetables::Asparagus;</code>로 바로가기를 만들 수 있으며, 그 이후로는 해당 스코프에서 그 타입을 사용하기 위해 <code>Asparagus</code>만 쓰면 됩니다.</li>
</ul>
<p>여기서는 이러한 규칙들을 설명하기 위해 <code>backyard</code>라는 이름의 바이너리 크레이트를 만듭니다. 크레이트의 디렉토리(이름도 <code>backyard</code>)에는 다음과 같은 파일들과 디렉토리들이 포함되어 있습니다.</p>
<pre><code class="language-text">backyard
├── Cargo.lock
├── Cargo.toml
└── src
    ├── garden
    │   └── vegetables.rs
    ├── garden.rs
    └── main.rs
</code></pre>
<p>이 경우 크레이트 루트 파일은 _src/main.rs_이며, 다음을 포함합니다:</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust noplayground ignore">use crate::garden::vegetables::Asparagus;

pub mod garden;

fn main() {
    let plant = Asparagus {};
    println!("저는 {plant:?}를 키우고 있어요!");
}</code></pre>
</Listing>
<p><code>pub mod garden;</code> 줄은 컴파일러에게 _src/garden.rs_에서 찾은 코드를 포함하라고 지시하며, 그 내용은 다음과 같습니다.</p>
<Listing file-name="src/garden.rs">
<pre><code class="language-rust noplayground ignore">pub mod vegetables;</code></pre>
</Listing>
<p>여기서 <code>pub mod vegetables;</code>는 _src/garden/vegetables.rs_의 코드도 포함됨을 의미합니다. 그 코드는 다음과 같습니다.</p>
<pre><code class="language-rust noplayground ignore">#[derive(Debug)]
pub struct Asparagus {}</code></pre>
<p>이제 이러한 규칙들의 세부 사항을 살펴보고 실제 작동하는 모습을 확인해 봅시다!</p>
<h3 id="모듈로-관련-코드-그룹화하기"><a class="header" href="#모듈로-관련-코드-그룹화하기">모듈로 관련 코드 그룹화하기</a></h3>
<p>_모듈(Modules)_은 가독성과 재사용성을 위해 크레이트 내의 코드를 조직화할 수 있게 해줍니다. 모듈 내의 코드는 기본적으로 비공개이므로, 모듈을 통해 항목의 _프라이버시(privacy)_를 제어할 수 있습니다. 비공개 항목은 외부에서 사용할 수 없는 내부 구현 세부 사항입니다. 모듈과 그 안의 항목들을 공개로 선택할 수 있으며, 이를 통해 외부 코드가 그들을 사용하고 의존할 수 있도록 노출할 수 있습니다.</p>
<p>예를 들어, 레스토랑의 기능을 제공하는 라이브러리 크레이트를 작성해 봅시다. 레스토랑의 실제 구현보다는 코드의 조직화에 집중하기 위해 함수의 시그니처만 정의하고 본문은 비워두겠습니다.</p>
<p>레스토랑 업계에서 레스토랑의 일부는 _프런트 오브 하우스(front of house)_라고 불리고 다른 부분은 _백 오브 하우스(back of house)_라고 불립니다. 프런트 오브 하우스는 고객이 있는 곳으로, 호스트가 고객을 안내하고, 서버가 주문과 결제를 받고, 바텐더가 음료를 만드는 곳을 포함합니다. 백 오브 하우스는 셰프와 요리사들이 주방에서 일하고, 식기 세척기가 청소하고, 매니저가 행정 업무를 보는 곳입니다.</p>
<p>이런 방식으로 우리 크레이트를 구성하기 위해, 함수들을 중첩된 모듈로 조직화할 수 있습니다. <code>cargo new restaurant --lib</code>를 실행하여 <code>restaurant</code>라는 새 라이브러리를 만드세요. 그런 다음 목록 7-1의 코드를 _src/lib.rs_에 입력하여 몇 개의 모듈과 함수 시그니처를 정의하세요. 이 코드는 프런트 오브 하우스 섹션입니다.</p>
<Listing number="7-1" file-name="src/lib.rs" caption="A `front_of_house` module containing other modules that then contain functions">
<pre><code class="language-rust noplayground">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}</code></pre>
</Listing>
<p>모듈은 <code>mod</code> 키워드 뒤에 모듈의 이름(이 경우 <code>front_of_house</code>)을 붙여 정의합니다. 모듈의 본문은 중괄호 안에 들어갑니다. 모듈 안에는 이번 예제의 <code>hosting</code>과 <code>serving</code> 모듈처럼 다른 모듈을 넣을 수 있습니다. 또한 모듈은 구조체, 열거형, 상수, 트레이트, 그리고 목록 7-1에서와 같이 함수 등 다른 항목에 대한 정의도 가질 수 있습니다.</p>
<p>모듈을 사용함으로써 관련 있는 정의들을 하나로 묶고 그들이 왜 관련 있는지 이름을 붙일 수 있습니다. 이 코드를 사용하는 프로그래머는 모든 정의를 읽을 필요 없이 그룹을 바탕으로 코드를 탐색할 수 있어, 자신에게 필요한 정의를 더 쉽게 찾을 수 있습니다. 또한 새로운 기능을 추가하는 프로그래머는 프로그램의 조직화를 유지하기 위해 코드를 어디에 두어야 할지 알 수 있습니다.</p>
<p>앞서 우리는 _src/main.rs_와 _src/lib.rs_를 크레이트 루트라고 부른다고 언급했습니다. 그렇게 불리는 이유는 이 두 파일 중 하나의 내용이 크레이트의 모듈 구조( _모듈 트리(module tree)_라고 알려진)의 루트에서 <code>crate</code>라는 이름의 모듈을 형성하기 때문입니다.</p>
<p>목록 7-2는 목록 7-1의 구조에 대한 모듈 트리를 보여줍니다.</p>
<Listing number="7-2" caption="The module tree for the code in Listing 7-1">
<pre><code class="language-text">crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
</code></pre>
</Listing>
<p>이 트리는 어떤 모듈이 다른 모듈 안에 어떻게 중첩되는지 보여줍니다. 예를 들어, <code>hosting</code>은 <code>front_of_house</code> 안에 중첩되어 있습니다. 또한 트리는 일부 모듈이 <em>형제(siblings)</em> 관계임을 보여주는데, 이는 그들이 동일한 모듈 내에 정의되어 있음을 의미합니다. <code>hosting</code>과 <code>serving</code>은 <code>front_of_house</code> 내에 정의된 형제입니다. 만약 모듈 A가 모듈 B 안에 포함되어 있다면, 모듈 A는 모듈 B의 _자식(child)_이고 모듈 B는 모듈 A의 _부모(parent)_라고 말합니다. 전체 모듈 트리는 <code>crate</code>라는 이름의 암시적 모듈 아래에 뿌리를 두고 있음에 주목하세요.</p>
<p>모듈 트리는 컴퓨터의 파일 시스템 디렉토리 트리를 연상시킬 수 있는데, 이는 매우 적절한 비유입니다! 파일 시스템의 디렉토리와 마찬가지로, 여러분은 코드를 조직화하기 위해 모듈을 사용합니다. 그리고 디렉토리 안의 파일들처럼, 우리에게는 모듈을 찾을 방법이 필요합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="모듈-트리의-항목을-참조하는-경로"><a class="header" href="#모듈-트리의-항목을-참조하는-경로">모듈 트리의 항목을 참조하는 경로</a></h2>
<p>러스트에게 모듈 트리에서 항목을 어디서 찾을지 알려주기 위해, 우리는 파일 시스템을 탐색할 때 경로를 사용하는 것과 동일한 방식으로 경로를 사용합니다. 함수를 호출하려면 그 함수의 경로를 알아야 합니다.</p>
<p>경로는 두 가지 형태를 가질 수 있습니다:</p>
<ul>
<li>_절대 경로(absolute path)_는 크레이트 루트로부터 시작하는 전체 경로입니다. 외부 크레이트로부터 온 코드의 경우 절대 경로는 크레이트 이름으로 시작하고, 현재 크레이트로부터 온 코드의 경우 <code>crate</code> 리터럴로 시작합니다.</li>
<li>_상대 경로(relative path)_는 현재 모듈로부터 시작하며 <code>self</code>, <code>super</code>, 혹은 현재 모듈 내의 식별자를 사용합니다.</li>
</ul>
<p>절대 경로와 상대 경로 모두 이중 콜론(<code>::</code>)으로 구분된 하나 이상의 식별자가 뒤따릅니다.</p>
<p>목록 7-1로 돌아가서, 우리가 <code>add_to_waitlist</code> 함수를 호출하고 싶다고 해봅시다. 이는 <code>add_to_waitlist</code> 함수의 경로가 무엇인지 묻는 것과 같습니다. 목록 7-3은 일부 모듈과 함수를 제거한 목록 7-1을 포함하고 있습니다.</p>
<p>크레이트 루트에 정의된 새로운 함수 <code>eat_at_restaurant</code>에서 <code>add_to_waitlist</code> 함수를 호출하는 두 가지 방법을 보여드리겠습니다. 이 경로들은 정확하지만, 이 예제가 그대로 컴파일되는 것을 막는 또 다른 문제가 남아 있습니다. 그 이유는 잠시 후에 설명하겠습니다.</p>
<p>The <code>eat_at_restaurant</code> function is part of our library crate’s public API, so we mark it with the <code>pub</code> keyword. In the <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword">“Exposing Paths with the <code>pub</code> Keyword”</a><!-- ignore --> section, we’ll go into more detail about <code>pub</code>.</p>
<Listing number="7-3" file-name="src/lib.rs" caption="Calling the `add_to_waitlist` function using absolute and relative paths">
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}</code></pre>
</Listing>
<p>The first time we call the <code>add_to_waitlist</code> function in <code>eat_at_restaurant</code>, we use an absolute path. The <code>add_to_waitlist</code> function is defined in the same crate as <code>eat_at_restaurant</code>, which means we can use the <code>crate</code> keyword to start an absolute path. We then include each of the successive modules until we make our way to <code>add_to_waitlist</code>. You can imagine a filesystem with the same structure: we’d specify the path <code>/front_of_house/hosting/add_to_waitlist</code> to run the <code>add_to_waitlist</code> program; using the <code>crate</code> name to start from the crate root is like using <code>/</code> to start from the filesystem root in your shell.</p>
<p>The second time we call <code>add_to_waitlist</code> in <code>eat_at_restaurant</code>, we use a relative path. The path starts with <code>front_of_house</code>, the name of the module defined at the same level of the module tree as <code>eat_at_restaurant</code>. Here the filesystem equivalent would be using the path <code>front_of_house/hosting/add_to_waitlist</code>. Starting with a module name means that the path is relative.</p>
<p>Choosing whether to use a relative or absolute path is a decision you’ll make based on your project, and it depends on whether you’re more likely to move item definition code separately from or together with the code that uses the item. For example, if we moved the <code>front_of_house</code> module and the <code>eat_at_restaurant</code> function into a module named <code>customer_experience</code>, we’d need to update the absolute path to <code>add_to_waitlist</code>, but the relative path would still be valid. However, if we moved the <code>eat_at_restaurant</code> function separately into a module named <code>dining</code>, the absolute path to the <code>add_to_waitlist</code> call would stay the same, but the relative path would need to be updated. Our preference in general is to specify absolute paths because it’s more likely we’ll want to move code definitions and item calls independently of each other.</p>
<p>Let’s try to compile Listing 7-3 and find out why it won’t compile yet! The errors we get are shown in Listing 7-4.</p>
<Listing number="7-4" caption="Compiler errors from building the code in Listing 7-3">
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `hosting` is private
 --&gt; src/lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^  --------------- function `add_to_waitlist` is not publicly re-exported
  |                            |
  |                            private module
  |
note: the module `hosting` is defined here
 --&gt; src/lib.rs:2:5
  |
2 |     mod hosting {
  |     ^^^^^^^^^^^

error[E0603]: module `hosting` is private
  --&gt; src/lib.rs:12:21
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^  --------------- function `add_to_waitlist` is not publicly re-exported
   |                     |
   |                     private module
   |
note: the module `hosting` is defined here
  --&gt; src/lib.rs:2:5
   |
2  |     mod hosting {
   |     ^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` (lib) due to 2 previous errors
</code></pre>
</Listing>
<p>오류 메시지는 <code>hosting</code> 모듈이 비공개(private)라고 말합니다. 즉, <code>hosting</code> 모듈과 <code>add_to_waitlist</code> 함수에 대한 올바른 경로를 가지고 있지만, 러스트는 비공개 섹션에 접근할 수 없기 때문에 이를 사용하도록 허용하지 않습니다. 러스트에서 모든 항목(함수, 메서드, 구조체, 열거형, 모듈, 상수)은 기본적으로 부모 모듈에 대해 비공개 상태입니다. 함수나 구조체와 같은 항목을 비공개로 만들고 싶다면, 모듈 안에 넣으면 됩니다.</p>
<p>부모 모듈의 항목은 자식 모듈 내부의 비공개 항목을 사용할 수 없지만, 자식 모듈의 항목은 자신의 조상 모듈에 있는 항목을 사용할 수 있습니다. 이는 자식 모듈이 자신의 구현 세부 사항을 감싸서 숨기기 때문이지만, 자식 모듈은 자신이 정의된 맥락을 볼 수 있기 때문입니다. 비유를 계속하자면, 프라이버시 규칙을 레스토랑의 백 오피스(관리 사무실)와 같다고 생각하세요. 그 안에서 일어나는 일은 고객에게는 비공개이지만, 사무실 매니저는 자신이 운영하는 레스토랑의 모든 것을 보고 처리할 수 있습니다.</p>
<p>러스트는 내부 구현 세부 사항을 숨기는 것을 기본값으로 하기 위해 모듈 시스템이 이렇게 작동하도록 선택했습니다. 그렇게 하면 내부 코드의 어떤 부분을 외부 코드를 망가뜨리지 않고 변경할 수 있는지 알 수 있습니다. 하지만 러스트는 <code>pub</code> 키워드를 사용하여 항목을 공개(public)로 만듦으로써 자식 모듈 코드의 내부 부품을 조상 모듈에 노출할 수 있는 옵션을 제공합니다.</p>
<h3 id="pub-키워드로-경로-노출하기"><a class="header" href="#pub-키워드로-경로-노출하기"><code>pub</code> 키워드로 경로 노출하기</a></h3>
<p>목록 7-4에서 <code>hosting</code> 모듈이 비공개라고 했던 오류로 돌아가 봅시다. 부모 모듈의 <code>eat_at_restaurant</code> 함수가 자식 모듈의 <code>add_to_waitlist</code> 함수에 접근할 수 있게 하고 싶으므로, 목록 7-5에 표시된 것처럼 <code>hosting</code> 모듈을 <code>pub</code> 키워드로 표시합니다.</p>
<Listing number="7-5" file-name="src/lib.rs" caption="Declaring the `hosting` module as `pub` to use it from `eat_at_restaurant`">
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

// -- 생략 --
<span class="boring">pub fn eat_at_restaurant() {
</span><span class="boring">    // Absolute path
</span><span class="boring">    crate::front_of_house::hosting::add_to_waitlist();
</span><span class="boring">
</span><span class="boring">    // Relative path
</span><span class="boring">    front_of_house::hosting::add_to_waitlist();
</span><span class="boring">}</span></code></pre>
</Listing>
<p>안타깝게도 목록 7-5의 코드는 목록 7-6에 표시된 것처럼 여전히 컴파일러 오류를 발생시킵니다.</p>
<Listing number="7-6" caption="Compiler errors from building the code in Listing 7-5">
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: function `add_to_waitlist` is private
 --&gt; src/lib.rs:9:37
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                                     ^^^^^^^^^^^^^^^ private function
  |
note: the function `add_to_waitlist` is defined here
 --&gt; src/lib.rs:3:9
  |
3 |         fn add_to_waitlist() {}
  |         ^^^^^^^^^^^^^^^^^^^^

error[E0603]: function `add_to_waitlist` is private
  --&gt; src/lib.rs:12:30
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                              ^^^^^^^^^^^^^^^ private function
   |
note: the function `add_to_waitlist` is defined here
  --&gt; src/lib.rs:3:9
   |
3  |         fn add_to_waitlist() {}
   |         ^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` (lib) due to 2 previous errors
</code></pre>
</Listing>
<p>무슨 일이 일어난 걸까요? <code>mod hosting</code> 앞에 <code>pub</code> 키워드를 추가하면 모듈이 공개됩니다. 이 변경으로 <code>front_of_house</code>에 접근할 수 있다면 <code>hosting</code>에도 접근할 수 있게 됩니다. 하지만 <code>hosting</code>의 _내용물_은 여전히 비공개입니다. 모듈을 공개로 만든다고 해서 그 내용물까지 공개되는 것은 아닙니다. 모듈에 붙은 <code>pub</code> 키워드는 단지 조상 모듈의 코드가 해당 모듈을 참조할 수 있게 할 뿐이며, 내부 코드에 접근할 수 있게 하는 것은 아닙니다. 모듈은 컨테이너이므로, 모듈만 공개로 해서는 할 수 있는 일이 많지 않습니다. 더 나아가 모듈 내의 하나 이상의 항목도 공개로 만들도록 선택해야 합니다.</p>
<p>목록 7-6의 오류들은 <code>add_to_waitlist</code> 함수가 비공개라고 말합니다. 프라이버시 규칙은 모듈뿐만 아니라 구조체, 열거형, 함수, 메서드에도 적용됩니다.</p>
<p>목록 7-7처럼 정의 앞에 <code>pub</code> 키워드를 추가하여 <code>add_to_waitlist</code> 함수도 공개로 만들어 봅시다.</p>
<Listing number="7-7" file-name="src/lib.rs" caption="Adding the `pub` keyword to `mod hosting` and `fn add_to_waitlist` lets us call the function from `eat_at_restaurant`">
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

// -- 생략 --
<span class="boring">pub fn eat_at_restaurant() {
</span><span class="boring">    // Absolute path
</span><span class="boring">    crate::front_of_house::hosting::add_to_waitlist();
</span><span class="boring">
</span><span class="boring">    // Relative path
</span><span class="boring">    front_of_house::hosting::add_to_waitlist();
</span><span class="boring">}</span></code></pre>
</Listing>
<p>이제 코드가 컴파일됩니다! <code>pub</code> 키워드를 추가한 것이 왜 프라이버시 규칙 측면에서 <code>eat_at_restaurant</code> 내의 이 경로들을 사용할 수 있게 해주는지 알아보기 위해, 절대 경로와 상대 경로를 살펴봅시다.</p>
<p>절대 경로에서는 우리 크레이트 모듈 트리의 루트인 <code>crate</code>로 시작합니다. <code>front_of_house</code> 모듈은 크레이트 루트에 정의되어 있습니다. <code>front_of_house</code>가 공개는 아니지만, <code>eat_at_restaurant</code> 함수가 <code>front_of_house</code>와 동일한 모듈에 정의되어 있기 때문에(즉, 둘은 형제 관계입니다), <code>eat_at_restaurant</code>에서 <code>front_of_house</code>를 참조할 수 있습니다. 다음은 <code>pub</code>으로 표시된 <code>hosting</code> 모듈입니다. 우리는 <code>hosting</code>의 부모 모듈에 접근할 수 있으므로, <code>hosting</code>에도 접근할 수 있습니다. 마지막으로 <code>add_to_waitlist</code> 함수도 <code>pub</code>으로 표시되어 있고 우리가 그 부모 모듈에 접근할 수 있으므로, 이 함수 호출은 성공합니다!</p>
<p>상대 경로의 경우, 첫 단계를 제외하고는 절대 경로와 로직이 동일합니다. 크레이트 루트에서 시작하는 대신 <code>front_of_house</code>에서 시작합니다. <code>front_of_house</code> 모듈은 <code>eat_at_restaurant</code>와 동일한 모듈 내에 정의되어 있으므로, <code>eat_at_restaurant</code>가 정의된 모듈에서 시작하는 상대 경로가 작동합니다. 그 다음 <code>hosting</code>과 <code>add_to_waitlist</code>가 <code>pub</code>으로 표시되어 있으므로 경로의 나머지 부분도 작동하며, 이 함수 호출은 유효합니다!</p>
<p>다른 프로젝트에서 여러분의 코드를 사용할 수 있도록 라이브러리 크레이트를 공유할 계획이라면, 공개 API는 여러분의 크레이트 사용자와의 계약이며 그들이 여러분의 코드와 상호작용하는 방식을 결정합니다. 사람들이 여러분의 크레이트에 더 쉽게 의존할 수 있도록 공개 API의 변경 사항을 관리하는 데에는 많은 고려 사항이 있습니다. 이러한 고려 사항들은 이 책의 범위를 벗어납니다. 이 주제에 관심이 있다면 <a href="https://rust-lang.github.io/api-guidelines/">러스트 API 가이드라인</a>을 참조하세요.</p>
<blockquote>
<h4 id="바이너리-및-라이브러리가-있는-패키지-모범-사례"><a class="header" href="#바이너리-및-라이브러리가-있는-패키지-모범-사례">바이너리 및 라이브러리가 있는 패키지 모범 사례</a></h4>
<p>우리는 패키지가 <em>src/main.rs</em> 바이너리 크레이트 루트와 <em>src/lib.rs</em> 라이브러리 크레이트 루트를 모두 포함할 수 있으며, 두 크레이트 모두 기본적으로 패키지 이름을 갖는다고 언급했습니다. 일반적으로 라이브러리와 바이너리 크레이트를 모두 포함하는 이러한 패턴의 패키지는, 라이브러리 크레이트 내의 코드를 호출하여 실행 파일을 시작할 정도의 최소한의 코드만 바이너리 크레이트에 가집니다. 이렇게 하면 라이브러리 크레이트의 코드가 공유될 수 있으므로 다른 프로젝트들이 패키지가 제공하는 대부분의 기능으로부터 혜택을 얻을 수 있습니다.</p>
<p>모듈 트리는 _src/lib.rs_에 정의되어야 합니다. 그러면 바이너리 크레이트에서 패키지 이름으로 시작하는 경로를 사용하여 모든 공개 항목을 사용할 수 있습니다. 바이너리 크레이트는 완전히 외부의 크레이트가 라이브러리 크레이트를 사용하는 것과 마찬가지로 라이브러리 크레이트의 사용자가 됩니다. 즉, 오직 공개 API만 사용할 수 있습니다. 이는 여러분이 작성자일 뿐만 아니라 클라이언트이기도 하므로 좋은 API를 설계하는 데 도움이 됩니다!</p>
<p><a href="ch12-00-an-io-project.html">12장</a><!-- ignore -->에서, 바이너리 크레이트와 라이브러리 크레이트를 모두 포함하는 명령줄 프로그램을 통해 이러한 조직화 관례를 보여드리겠습니다.</p>
</blockquote>
<h3 id="super로-상대-경로-시작하기"><a class="header" href="#super로-상대-경로-시작하기"><code>super</code>로 상대 경로 시작하기</a></h3>
<p>우리는 경로의 시작 부분에 <code>super</code>를 사용하여 현재 모듈이나 크레이트 루트가 아닌 부모 모듈에서 시작하는 상대 경로를 만들 수 있습니다. 이는 파일 시스템 경로를 <code>..</code> 문법으로 시작하는 것과 비슷합니다. <code>super</code>를 사용하면 부모 모듈에 있다는 것을 알고 있는 항목을 참조할 수 있게 해주며, 이는 해당 모듈이 부모와 밀접하게 관련되어 있지만 언젠가 부모가 모듈 트리의 다른 곳으로 옮겨질 수도 있는 상황에서 모듈 트리를 재배치하는 것을 더 쉽게 만들어 줄 수 있습니다.</p>
<p>셰프가 잘못된 주문을 수정하고 고객에게 직접 가져다주는 상황을 모델링한 목록 7-8의 코드를 살펴봅시다. <code>back_of_house</code> 모듈에 정의된 <code>fix_incorrect_order</code> 함수는 <code>super</code>로 시작하는 <code>deliver_order</code> 경로를 지정하여 부모 모듈에 정의된 <code>deliver_order</code> 함수를 호출합니다.</p>
<Listing number="7-8" file-name="src/lib.rs" caption="Calling a function using a relative path starting with `super`">
<pre><code class="language-rust noplayground test_harness">fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order();
    }

    fn cook_order() {}
}</code></pre>
</Listing>
<p><code>fix_incorrect_order</code> 함수는 <code>back_of_house</code> 모듈에 있으므로, <code>super</code>를 사용하여 <code>back_of_house</code>의 부모 모듈(이 경우 루트인 <code>crate</code>)로 갈 수 있습니다. 거기서 <code>deliver_order</code>를 찾아 성공적으로 호출합니다! 우리는 크레이트의 모듈 트리를 재조직하더라도 <code>back_of_house</code> 모듈과 <code>deliver_order</code> 함수가 서로 동일한 관계를 유지하며 함께 이동할 가능성이 높다고 생각합니다. 따라서 <code>super</code>를 사용함으로써, 향후 이 코드가 다른 모듈로 이동하더라도 코드를 업데이트해야 할 곳을 줄일 수 있습니다.</p>
<h3 id="구조체와-열거형을-공개로-만들기"><a class="header" href="#구조체와-열거형을-공개로-만들기">구조체와 열거형을 공개로 만들기</a></h3>
<p>우리는 또한 <code>pub</code>을 사용하여 구조체와 열거형을 공개로 지정할 수 있지만, 구조체와 열거형에 <code>pub</code>을 사용하는 데에는 몇 가지 추가적인 세부 사항이 있습니다. 구조체 정의 앞에 <code>pub</code>을 사용하면 구조체는 공개되지만, 구조체의 필드들은 여전히 비공개 상태입니다. 우리는 각 필드를 상황에 따라 공개로 만들거나 만들지 않을 수 있습니다. 목록 7-9에서는 공개된 <code>toast</code> 필드와 비공개된 <code>seasonal_fruit</code> 필드를 가진 공개 구조체 <code>back_of_house::Breakfast</code>를 정의했습니다. 이는 고객이 식사와 함께 제공되는 빵의 종류를 선택할 수 있지만, 셰프가 제철 과일과 재고 상황에 따라 곁들일 과일을 결정하는 레스토랑의 상황을 모델링한 것입니다. 사용 가능한 과일은 자주 바뀌므로, 고객은 과일을 선택할 수 없으며 어떤 과일이 나올지 미리 알 수도 없습니다.</p>
<Listing number="7-9" file-name="src/lib.rs" caption="A struct with some public fields and some private fields">
<pre><code class="language-rust noplayground">mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &amp;str) -&gt; Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("복숭아"),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // 호밀 토스트와 함께 여름 아침 식사를 주문하세요.
    let mut meal = back_of_house::Breakfast::summer("호밀");
    // 어떤 빵을 먹을지 마음을 바꿉니다.
    meal.toast = String::from("밀");
    println!("{} 토스트 부탁드립니다", meal.toast);

    // 다음 줄은 주석을 해제하면 컴파일되지 않습니다. 우리는 식사와 함께 제공되는
    // 제철 과일을 보거나 수정할 수 없습니다.
    // meal.seasonal_fruit = String::from("blueberries");
}</code></pre>
</Listing>
<p><code>back_of_house::Breakfast</code> 구조체의 <code>toast</code> 필드는 공개(public)이므로, <code>eat_at_restaurant</code>에서 점 표기법을 사용하여 <code>toast</code> 필드에 쓰고 읽을 수 있습니다. <code>seasonal_fruit</code> 필드는 비공개(private)이므로 <code>eat_at_restaurant</code>에서 사용할 수 없다는 점에 유의하세요. <code>seasonal_fruit</code> 필드 값을 수정하는 줄의 주석을 해제하여 어떤 오류가 발생하는지 확인해 보세요!</p>
<p>또한, <code>back_of_house::Breakfast</code>에 비공개 필드가 있기 때문에, 구조체는 <code>Breakfast</code>의 인스턴스를 구성하는 공개 연관 함수를 제공해야 한다는 점에 유의하세요 (여기서는 <code>summer</code>라고 이름 붙였습니다). 만약 <code>Breakfast</code>에 그러한 함수가 없었다면, <code>eat_at_restaurant</code>에서 비공개 <code>seasonal_fruit</code> 필드의 값을 설정할 수 없었기 때문에 <code>eat_at_restaurant</code>에서 <code>Breakfast</code>의 인스턴스를 생성할 수 없었을 것입니다.</p>
<p>대조적으로, 열거형을 공개(public)로 만들면 모든 variant가 공개됩니다. 목록 7-10에 표시된 것처럼 <code>enum</code> 키워드 앞에 <code>pub</code>만 있으면 됩니다.</p>
<Listing number="7-10" file-name="src/lib.rs" caption="Designating an enum as public makes all its variants public.">
<pre><code class="language-rust noplayground">mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}</code></pre>
</Listing>
<p><code>Appetizer</code> 열거형을 공개로 만들었기 때문에, <code>eat_at_restaurant</code>에서 <code>Soup</code>과 <code>Salad</code> variant를 사용할 수 있습니다.</p>
<p>열거형은 variant가 공개되지 않으면 그다지 유용하지 않습니다. 모든 경우에 모든 열거형 variant에 <code>pub</code>을 명시해야 한다면 번거로울 것이므로, 열거형 variant의 기본값은 공개입니다. 구조체는 필드가 공개되지 않아도 유용한 경우가 많으므로, 구조체 필드는 <code>pub</code>으로 명시되지 않는 한 모든 것이 기본적으로 비공개라는 일반적인 규칙을 따릅니다.</p>
<p><code>pub</code>과 관련된 한 가지 더 다루지 않은 상황이 있는데, 그것은 우리의 마지막 모듈 시스템 기능인 <code>use</code> 키워드입니다. 먼저 <code>use</code> 자체를 다룬 다음, <code>pub</code>과 <code>use</code>를 결합하는 방법을 보여줄 것입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="use-키워드로-경로를-스코프로-가져오기"><a class="header" href="#use-키워드로-경로를-스코프로-가져오기"><code>use</code> 키워드로 경로를 스코프로 가져오기</a></h2>
<p>함수를 호출하기 위해 경로를 모두 작성하는 것은 불편하고 반복적일 수 있습니다. 목록 7-7에서 <code>add_to_waitlist</code> 함수에 대한 절대 경로 또는 상대 경로를 선택했든 상관없이, <code>add_to_waitlist</code>를 호출할 때마다 <code>front_of_house</code>와 <code>hosting</code>도 지정해야 했습니다. 다행히 이 과정을 단순화하는 방법이 있습니다. <code>use</code> 키워드를 사용하여 경로에 대한 단축키를 한 번 생성한 다음, 스코프의 다른 모든 곳에서 더 짧은 이름을 사용할 수 있습니다.</p>
<p>목록 7-11에서 <code>crate::front_of_house::hosting</code> 모듈을 <code>eat_at_restaurant</code> 함수의 스코프로 가져와서, <code>eat_at_restaurant</code> 함수에서 <code>add_to_waitlist</code> 함수를 호출하기 위해 <code>hosting::add_to_waitlist</code>만 지정하면 됩니다.</p>
<Listing number="7-11" file-name="src/lib.rs" caption="Bringing a module into scope with `use`">
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}</code></pre>
</Listing>
<p>스코프에 <code>use</code>와 경로를 추가하는 것은 파일 시스템에 심볼릭 링크를 생성하는 것과 유사합니다. 크레이트 루트에 <code>use crate::front_of_house::hosting</code>을 추가하면, <code>hosting</code>은 이제 해당 스코프에서 유효한 이름이 됩니다. 마치 <code>hosting</code> 모듈이 크레이트 루트에 정의된 것처럼 말이죠. <code>use</code>로 스코프로 가져온 경로는 다른 경로와 마찬가지로 프라이버시도 확인합니다.</p>
<p><code>use</code>는 <code>use</code>가 발생하는 특정 스코프에 대해서만 단축키를 생성한다는 점에 유의하세요. 목록 7-12는 <code>eat_at_restaurant</code> 함수를 <code>customer</code>라는 새 자식 모듈로 이동시키는데, 이 모듈은 <code>use</code> 문과는 다른 스코프이므로 함수 본문은 컴파일되지 않을 것입니다.</p>
<Listing number="7-12" file-name="src/lib.rs" caption="A `use` statement only applies in the scope it’s in.">
<pre><code class="language-rust noplayground test_harness does_not_compile ignore">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

mod customer {
    pub fn eat_at_restaurant() {
        hosting::add_to_waitlist();
    }
}</code></pre>
</Listing>
<p>컴파일러 오류는 단축키가 <code>customer</code> 모듈 내에서 더 이상 적용되지 않음을 보여줍니다:</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0433]: failed to resolve: use of undeclared crate or module `hosting`
  --&gt; src/lib.rs:11:9
   |
11 |         hosting::add_to_waitlist();
   |         ^^^^^^^ use of undeclared crate or module `hosting`
   |
help: consider importing this module through its public re-export
   |
10 +     use crate::hosting;
   |

warning: unused import: `crate::front_of_house::hosting`
 --&gt; src/lib.rs:7:5
  |
7 | use crate::front_of_house::hosting;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

For more information about this error, try `rustc --explain E0433`.
warning: `restaurant` (lib) generated 1 warning
error: could not compile `restaurant` (lib) due to 1 previous error; 1 warning emitted
</code></pre>
<p>Notice there’s also a warning that the <code>use</code> is no longer used in its scope! To fix this problem, move the <code>use</code> within the <code>customer</code> module too, or reference the shortcut in the parent module with <code>super::hosting</code> within the child <code>customer</code> module.</p>
<h3 id="관용적인-use-경로-생성하기"><a class="header" href="#관용적인-use-경로-생성하기">관용적인 <code>use</code> 경로 생성하기</a></h3>
<p>목록 7-11에서 <code>use crate::front_of_house::hosting</code>을 지정한 다음 <code>eat_at_restaurant</code>에서 <code>hosting::add_to_waitlist</code>를 호출한 이유가 궁금했을 수도 있습니다. 목록 7-13에서처럼 동일한 결과를 얻기 위해 <code>add_to_waitlist</code> 함수까지 <code>use</code> 경로를 모두 지정하지 않은 이유 말입니다.</p>
<Listing number="7-13" file-name="src/lib.rs" caption="Bringing the `add_to_waitlist` function into scope with `use`, which is unidiomatic">
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
}</code></pre>
</Listing>
<p>목록 7-11과 목록 7-13 모두 동일한 작업을 수행하지만, 목록 7-11은 <code>use</code>를 사용하여 함수를 스코프로 가져오는 관용적인 방법입니다. 함수의 부모 모듈을 <code>use</code>로 스코프로 가져오는 것은 함수를 호출할 때 부모 모듈을 지정해야 함을 의미합니다. 함수를 호출할 때 부모 모듈을 지정하면 함수가 로컬에서 정의되지 않았음을 명확히 하면서도 전체 경로의 반복을 최소화할 수 있습니다. 목록 7-13의 코드는 <code>add_to_waitlist</code>가 어디에 정의되었는지 불분명합니다.</p>
<p>반면에, <code>use</code>를 사용하여 구조체, 열거형 및 기타 항목을 가져올 때는 전체 경로를 지정하는 것이 관용적입니다. 목록 7-14는 표준 라이브러리의 <code>HashMap</code> 구조체를 바이너리 크레이트의 스코프로 가져오는 관용적인 방법을 보여줍니다.</p>
<Listing number="7-14" file-name="src/main.rs" caption="Bringing `HashMap` into scope in an idiomatic way">
<pre><pre class="playground"><code class="language-rust edition2021">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}</code></pre></pre>
</Listing>
<p>이러한 관용구 뒤에는 강력한 이유가 없습니다. 단지 나타난 관례이며, 사람들은 이런 방식으로 러스트 코드를 읽고 쓰는 데 익숙해졌을 뿐입니다.</p>
<p>이 관용구의 예외는 <code>use</code> 문으로 동일한 이름을 가진 두 항목을 스코프로 가져오는 경우입니다. 러스트는 이를 허용하지 않기 때문입니다. 목록 7-15는 동일한 이름을 가졌지만 부모 모듈이 다른 두 <code>Result</code> 타입을 스코프로 가져오는 방법과 이를 참조하는 방법을 보여줍니다.</p>
<Listing number="7-15" file-name="src/lib.rs" caption="Bringing two types with the same name into the same scope requires using their parent modules.">
<pre><code class="language-rust noplayground">use std::fmt;
use std::io;

fn function1() -&gt; fmt::Result {
    // --생략--
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; io::Result&lt;()&gt; {
    // --생략--
<span class="boring">    Ok(())
</span>}</code></pre>
</Listing>
<p>보시다시피, 부모 모듈을 사용하면 두 <code>Result</code> 타입을 구별할 수 있습니다. 만약 <code>use std::fmt::Result</code>와 <code>use std::io::Result</code>를 대신 지정했다면, 동일한 스코프에 두 개의 <code>Result</code> 타입이 있게 되어 러스트는 <code>Result</code>를 사용했을 때 어떤 것을 의미하는지 알 수 없을 것입니다.</p>
<h3 id="as-키워드로-새-이름-제공하기"><a class="header" href="#as-키워드로-새-이름-제공하기"><code>as</code> 키워드로 새 이름 제공하기</a></h3>
<p><code>use</code>를 사용하여 동일한 이름의 두 타입을 동일한 스코프로 가져오는 문제에 대한 또 다른 해결책이 있습니다. 경로 뒤에 <code>as</code>와 타입에 대한 새 로컬 이름 또는 _별칭_을 지정할 수 있습니다. 목록 7-16은 <code>as</code>를 사용하여 두 <code>Result</code> 타입 중 하나를 이름을 변경함으로써 목록 7-15의 코드를 작성하는 또 다른 방법을 보여줍니다.</p>
<Listing number="7-16" file-name="src/lib.rs" caption="Renaming a type when it’s brought into scope with the `as` keyword">
<pre><code class="language-rust noplayground">use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -&gt; Result {
    // --생략--
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; IoResult&lt;()&gt; {
    // --생략--
<span class="boring">    Ok(())
</span>}</code></pre>
</Listing>
<p>두 번째 <code>use</code> 문에서 우리는 <code>std::io::Result</code> 타입에 대해 <code>IoResult</code>라는 새 이름을 선택했습니다. 이는 우리가 스코프로 가져온 <code>std::fmt</code>의 <code>Result</code>와 충돌하지 않을 것입니다. 목록 7-15와 목록 7-16은 관용적인 것으로 간주되므로 선택은 당신에게 달려 있습니다!</p>
<h3 id="pub-use로-이름-재내보내기"><a class="header" href="#pub-use로-이름-재내보내기"><code>pub use</code>로 이름 재내보내기</a></h3>
<p><code>use</code> 키워드로 이름을 스코프로 가져오면, 새 스코프에서 사용 가능한 이름은 비공개입니다. 우리 코드를 호출하는 코드가 마치 그 코드의 스코프에서 정의된 것처럼 그 이름을 참조할 수 있도록 하려면 <code>pub</code>과 <code>use</code>를 결합할 수 있습니다. 이 기술을 _재내보내기_라고 하는데, 항목을 스코프로 가져오면서도 다른 사람들이 자신의 스코프로 가져올 수 있도록 해당 항목을 사용할 수 있게 만들기 때문입니다.</p>
<p>목록 7-17은 루트 모듈의 <code>use</code>가 <code>pub use</code>로 변경된 목록 7-11의 코드를 보여줍니다.</p>
<Listing number="7-17" file-name="src/lib.rs" caption="Making a name available for any code to use from a new scope with `pub use`">
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}</code></pre>
</Listing>
<p>이 변경 전에는 외부 코드가 <code>restaurant::front_of_house::hosting::add_to_waitlist()</code> 경로를 사용하여 <code>add_to_waitlist</code> 함수를 호출해야 했으며, 이는 <code>front_of_house</code> 모듈도 <code>pub</code>으로 표시되어야 했을 것입니다. 이제 이 <code>pub use</code>가 루트 모듈에서 <code>hosting</code> 모듈을 재내보냈으므로, 외부 코드는 대신 <code>restaurant::hosting::add_to_waitlist()</code> 경로를 사용할 수 있습니다.</p>
<p>재내보내기는 코드의 내부 구조가 코드를 호출하는 프로그래머가 도메인에 대해 생각하는 방식과 다를 때 유용합니다. 예를 들어, 이 레스토랑 비유에서 레스토랑을 운영하는 사람들은 "프론트 오브 하우스"와 "백 오브 하우스"에 대해 생각합니다. 하지만 레스토랑을 방문하는 고객들은 아마도 그런 용어로 레스토랑의 부분을 생각하지 않을 것입니다. <code>pub use</code>를 사용하면 하나의 구조로 코드를 작성하면서도 다른 구조를 노출할 수 있습니다. 이렇게 하면 라이브러리에서 작업하는 프로그래머와 라이브러리를 호출하는 프로그래머 모두에게 라이브러리가 잘 조직됩니다. 14장의 <a href="ch14-02-publishing-to-crates-io.html#exporting-a-convenient-public-api-with-pub-use">“<code>pub use</code>로 편리한 공개 API 내보내기”</a><!-- ignore -->에서 <code>pub use</code>의 또 다른 예와 그것이 크레이트 문서에 미치는 영향을 살펴볼 것입니다.</p>
<h3 id="외부-패키지-사용하기"><a class="header" href="#외부-패키지-사용하기">외부 패키지 사용하기</a></h3>
<p>2장에서 우리는 <code>rand</code>라는 외부 패키지를 사용하여 난수를 얻는 추측 게임 프로젝트를 프로그래밍했습니다. 프로젝트에서 <code>rand</code>를 사용하기 위해 _Cargo.toml_에 다음 줄을 추가했습니다:</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch02-00-guessing-game-tutorial.md
* ch14-03-cargo-workspaces.md
-->
<Listing file-name="Cargo.toml">
<pre><code class="language-toml">rand = "0.8.5"
</code></pre>
</Listing>
<p>_Cargo.toml_에 <code>rand</code>를 의존성으로 추가하면 Cargo는 <code>rand</code> 패키지와 <a href="https://crates.io/">crates.io</a>에서 모든 의존성을 다운로드하고 <code>rand</code>를 우리 프로젝트에서 사용할 수 있도록 합니다.</p>
<p>Then, to bring <code>rand</code> definitions into the scope of our package, we added a <code>use</code> line starting with the name of the crate, <code>rand</code>, and listed the items we wanted to bring into scope. Recall that in <a href="ch02-00-guessing-game-tutorial.html#generating-a-random-number">“Generating a Random Number”</a><!-- ignore --> in Chapter 2, we brought the <code>Rng</code> trait into scope and called the <code>rand::thread_rng</code> function:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span>use rand::Rng;

fn main() {
<span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span>    let secret_number = rand::thread_rng().gen_range(1..=100);
<span class="boring">
</span><span class="boring">    println!("비밀 번호는: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!(추측을 입력하세요.);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("줄 읽기 실패");
</span><span class="boring">
</span><span class="boring">    println!("당신의 추측: {guess}");
</span>}</code></pre>
<p>러스트 커뮤니티 구성원들은 <a href="https://crates.io/">crates.io</a>에 많은 패키지를 제공했으며, 이들 중 어떤 것이든 당신의 패키지로 가져오는 것은 동일한 단계를 포함합니다: 패키지의 <em>Cargo.toml</em> 파일에 나열하고 <code>use</code>를 사용하여 해당 크레이트의 항목을 스코프로 가져오는 것입니다.</p>
<p>표준 라이브러리 <code>std</code>도 우리 패키지 외부에 있는 크레이트라는 점에 유의하세요. 표준 라이브러리는 러스트 언어와 함께 제공되므로, _Cargo.toml_을 변경하여 <code>std</code>를 포함할 필요는 없습니다. 하지만 <code>use</code>를 사용하여 거기서 항목을 우리 패키지의 스코프로 가져와야 합니다. 예를 들어, <code>HashMap</code>의 경우 이 줄을 사용할 것입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
<span class="boring">}</span></code></pre></pre>
<p>이것은 표준 라이브러리 크레이트의 이름인 <code>std</code>로 시작하는 절대 경로입니다.</p>
<h3 id="중첩-경로를-사용하여-긴-use-목록-정리하기"><a class="header" href="#중첩-경로를-사용하여-긴-use-목록-정리하기">중첩 경로를 사용하여 긴 <code>use</code> 목록 정리하기</a></h3>
<p>동일한 크레이트 또는 동일한 모듈에 정의된 여러 항목을 사용하는 경우, 각 항목을 자체 줄에 나열하면 파일에서 많은 수직 공간을 차지할 수 있습니다. 예를 들어, 목록 2-4의 추측 게임에서 사용했던 이 두 <code>use</code> 문은 <code>std</code>의 항목을 스코프로 가져옵니다:</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// --생략--
use std::cmp::Ordering;
use std::io;
// --생략--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("비밀 번호는: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!(추측을 입력하세요.);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("줄 읽기 실패");
</span><span class="boring">
</span><span class="boring">    println!("당신의 추측: {guess}");
</span><span class="boring">
</span><span class="boring">    match guess.cmp(&amp;secret_number) {
</span><span class="boring">        Ordering::Less =&gt; println!("너무 작아요!"),
</span><span class="boring">        Ordering::Greater =&gt; println!("너무 커요!"),
</span><span class="boring">        Ordering::Equal =&gt; println!("당신이 이겼습니다!"),
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>대신, 중첩 경로를 사용하여 동일한 항목을 한 줄로 스코프로 가져올 수 있습니다. 이는 경로의 공통 부분을 지정하고, 이중 콜론을 붙인 다음, 목록 7-18에 표시된 것처럼 다른 경로 부분 목록을 중괄호로 묶어 수행합니다.</p>
<Listing number="7-18" file-name="src/main.rs" caption="Specifying a nested path to bring multiple items with the same prefix into scope">
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// --생략--
use std::{cmp::Ordering, io};
// --생략--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("비밀 번호는: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!(추측을 입력하세요.);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("줄 읽기 실패");
</span><span class="boring">
</span><span class="boring">    let guess: u32 = guess.trim().parse().expect("숫자를 입력해주세요!");
</span><span class="boring">
</span><span class="boring">    println!("당신의 추측: {guess}");
</span><span class="boring">
</span><span class="boring">    match guess.cmp(&amp;secret_number) {
</span><span class="boring">        Ordering::Less =&gt; println!("너무 작아요!"),
</span><span class="boring">        Ordering::Greater =&gt; println!("너무 커요!"),
</span><span class="boring">        Ordering::Equal =&gt; println!("당신이 이겼습니다!"),
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>더 큰 프로그램에서는 중첩 경로를 사용하여 동일한 크레이트 또는 모듈에서 많은 항목을 스코프로 가져오면 필요한 개별 <code>use</code> 문의 수를 크게 줄일 수 있습니다!</p>
<p>경로의 어떤 수준에서든 중첩 경로를 사용할 수 있으며, 이는 하위 경로를 공유하는 두 <code>use</code> 문을 결합할 때 유용합니다. 예를 들어, 목록 7-19는 두 개의 <code>use</code> 문을 보여줍니다. 하나는 <code>std::io</code>를 스코프로 가져오고, 다른 하나는 <code>std::io::Write</code>를 스코프로 가져옵니다.</p>
<Listing number="7-19" file-name="src/lib.rs" caption="Two `use` statements where one is a subpath of the other">
<pre><code class="language-rust noplayground">use std::io;
use std::io::Write;</code></pre>
</Listing>
<p>이 두 경로의 공통 부분은 <code>std::io</code>이며, 이것이 완전한 첫 번째 경로입니다. 이 두 경로를 하나의 <code>use</code> 문으로 병합하려면, 목록 7-20에 표시된 것처럼 중첩 경로에서 <code>self</code>를 사용할 수 있습니다.</p>
<Listing number="7-20" file-name="src/lib.rs" caption="Combining the paths in Listing 7-19 into one `use` statement">
<pre><code class="language-rust noplayground">use std::io::{self, Write};</code></pre>
</Listing>
<p>이 줄은 <code>std::io</code>와 <code>std::io::Write</code>를 스코프로 가져옵니다.</p>
<h3 id="글로브-연산자"><a class="header" href="#글로브-연산자">글로브 연산자</a></h3>
<p>경로에 정의된 <em>모든</em> 공개 항목을 스코프로 가져오려면, 해당 경로 뒤에 <code>*</code> 글로브 연산자를 지정할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::*;
<span class="boring">}</span></code></pre></pre>
<p>이 <code>use</code> 문은 <code>std::collections</code>에 정의된 모든 공개 항목을 현재 스코프로 가져옵니다. 글로브 연산자를 사용할 때는 주의하세요! 글로브는 어떤 이름이 스코프에 있고 프로그램에서 사용된 이름이 어디에 정의되었는지 파악하기 어렵게 만들 수 있습니다.</p>
<p>The glob operator is often used when testing to bring everything under test into the <code>tests</code> module; we’ll talk about that in <a href="ch11-01-writing-tests.html#how-to-write-tests">“How to Write Tests”</a><!-- ignore --> in Chapter 11. The glob operator is also sometimes used as part of the prelude pattern: see <a href="../std/prelude/index.html#other-preludes">the standard library documentation</a><!-- ignore --> for more information on that pattern.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="모듈을-다른-파일로-분리하기"><a class="header" href="#모듈을-다른-파일로-분리하기">모듈을 다른 파일로 분리하기</a></h2>
<p>지금까지 이 장의 모든 예제는 하나의 파일에 여러 모듈을 정의했습니다. 모듈이 커지면 코드를 더 쉽게 탐색할 수 있도록 정의를 별도의 파일로 옮기고 싶을 수 있습니다.</p>
<p>예를 들어, 여러 레스토랑 모듈을 가졌던 목록 7-17의 코드부터 시작해 봅시다. 모든 모듈을 크레이트 루트 파일에 정의하는 대신 모듈을 파일로 추출할 것입니다. 이 경우 크레이트 루트 파일은 _src/lib.rs_이지만, 이 절차는 크레이트 루트 파일이 _src/main.rs_인 바이너리 크레이트에서도 작동합니다.</p>
<p>먼저 <code>front_of_house</code> 모듈을 자체 파일로 추출할 것입니다. <code>front_of_house</code> 모듈의 중괄호 안의 코드를 제거하고 <code>mod front_of_house;</code> 선언만 남겨서 _src/lib.rs_가 목록 7-21에 표시된 코드를 포함하도록 합니다. 목록 7-22에서 <em>src/front_of_house.rs</em> 파일을 생성하기 전까지는 컴파일되지 않을 것입니다.</p>
<Listing number="7-21" file-name="src/lib.rs" caption="Declaring the `front_of_house` module whose body will be in *src/front_of_house.rs*">
<pre><code class="language-rust ignore does_not_compile">mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}</code></pre>
</Listing>
<p>다음으로, 중괄호 안에 있던 코드를 목록 7-22에 표시된 것처럼 _src/front_of_house.rs_라는 새 파일에 배치합니다. 컴파일러는 크레이트 루트에서 <code>front_of_house</code>라는 이름의 모듈 선언을 발견했기 때문에 이 파일을 찾아볼 것입니다.</p>
<Listing number="7-22" file-name="src/front_of_house.rs" caption="Definitions inside the `front_of_house` module in *src/front_of_house.rs*">
<pre><code class="language-rust ignore">pub mod hosting {
    pub fn add_to_waitlist() {}
}</code></pre>
</Listing>
<p>모듈 트리에서 <code>mod</code> 선언을 사용하여 파일을 <em>한 번만</em> 로드하면 된다는 점에 유의하세요. 컴파일러가 파일이 프로젝트의 일부임을 알게 되면 (그리고 <code>mod</code> 문을 어디에 두었는지 때문에 모듈 트리에서 코드가 어디에 있는지 알게 되면), 프로젝트의 다른 파일은 <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“모듈 트리에서 항목을 참조하는 경로”</a><!-- ignore --> 섹션에서 다룬 것처럼 선언된 경로를 사용하여 로드된 파일의 코드를 참조해야 합니다. 즉, <code>mod</code>는 다른 프로그래밍 언어에서 보았을 수 있는 "include" 연산이 <em>아닙니다</em>.</p>
<p>다음으로, <code>hosting</code> 모듈을 자체 파일로 추출할 것입니다. <code>hosting</code>은 루트 모듈이 아닌 <code>front_of_house</code>의 자식 모듈이므로 과정이 약간 다릅니다. <code>hosting</code> 파일을 모듈 트리에서 그 조상들의 이름을 따서 명명될 새 디렉토리, 이 경우 _src/front_of_house_에 배치할 것입니다.</p>
<p><code>hosting</code>을 이동하기 시작하려면, _src/front_of_house.rs_를 <code>hosting</code> 모듈의 선언만 포함하도록 변경합니다:</p>
<Listing file-name="src/front_of_house.rs">
<pre><code class="language-rust ignore">pub mod hosting;</code></pre>
</Listing>
<p>그런 다음 <em>src/front_of_house</em> 디렉토리와 <em>hosting.rs</em> 파일을 생성하여 <code>hosting</code> 모듈에 정의된 내용을 포함하도록 합니다:</p>
<Listing file-name="src/front_of_house/hosting.rs">
<pre><code class="language-rust ignore">pub fn add_to_waitlist() {}</code></pre>
</Listing>
<p>만약 _hosting.rs_를 <em>src</em> 디렉토리에 넣었다면, 컴파일러는 <em>hosting.rs</em> 코드가 크레이트 루트에 선언된 <code>hosting</code> 모듈에 있을 것으로 예상하고, <code>front_of_house</code> 모듈의 자식으로 선언되지 않을 것입니다. 컴파일러가 어떤 모듈의 코드를 어떤 파일에서 찾아야 하는지에 대한 규칙은 디렉토리와 파일이 모듈 트리와 더 밀접하게 일치한다는 것을 의미합니다.</p>
<blockquote>
<h3 id="대체-파일-경로"><a class="header" href="#대체-파일-경로">대체 파일 경로</a></h3>
<p>지금까지 러스트 컴파일러가 사용하는 가장 관용적인 파일 경로를 다루었지만, 러스트는 또한 오래된 스타일의 파일 경로도 지원합니다. 크레이트 루트에 선언된 <code>front_of_house</code>라는 이름의 모듈의 경우, 컴파일러는 다음 위치에서 모듈의 코드를 찾을 것입니다:</p>
<ul>
<li><em>src/front_of_house.rs</em> (우리가 다룬 내용)</li>
<li><em>src/front_of_house/mod.rs</em> (오래된 스타일, 여전히 지원되는 경로)</li>
</ul>
<p><code>front_of_house</code>의 하위 모듈인 <code>hosting</code>이라는 이름의 모듈의 경우, 컴파일러는 다음 위치에서 모듈의 코드를 찾을 것입니다:</p>
<ul>
<li><em>src/front_of_house/hosting.rs</em> (우리가 다룬 내용)</li>
<li><em>src/front_of_house/hosting/mod.rs</em> (오래된 스타일, 여전히 지원되는 경로)</li>
</ul>
<p>동일한 모듈에 두 가지 스타일을 모두 사용하면 컴파일러 오류가 발생합니다. 동일한 프로젝트 내에서 다른 모듈에 두 가지 스타일을 혼합하여 사용하는 것은 허용되지만, 프로젝트를 탐색하는 사람들에게 혼란을 줄 수 있습니다.</p>
<p>_mod.rs_라는 이름의 파일을 사용하는 스타일의 주요 단점은 프로젝트에 _mod.rs_라는 이름의 파일이 많아질 수 있으며, 이를 편집기에서 동시에 열어두면 혼란스러울 수 있다는 것입니다.</p>
</blockquote>
<p>각 모듈의 코드를 별도의 파일로 옮겼으며, 모듈 트리는 동일하게 유지됩니다. 정의가 다른 파일에 있더라도 <code>eat_at_restaurant</code>의 함수 호출은 수정 없이 작동할 것입니다. 이 기술을 사용하면 모듈의 크기가 커짐에 따라 새 파일로 이동할 수 있습니다.</p>
<p>_src/lib.rs_의 <code>pub use crate::front_of_house::hosting</code> 문도 변경되지 않았으며, <code>use</code>는 크레이트의 일부로 컴파일되는 파일에 어떤 영향도 미치지 않는다는 점에 유의하세요. <code>mod</code> 키워드는 모듈을 선언하고, 러스트는 해당 모듈에 들어가는 코드를 모듈과 동일한 이름의 파일에서 찾습니다.</p>
<h2 id="요약-6"><a class="header" href="#요약-6">요약</a></h2>
<p>러스트는 패키지를 여러 크레이트로, 크레이트를 모듈로 분할할 수 있도록 하여 한 모듈에 정의된 항목을 다른 모듈에서 참조할 수 있게 합니다. 절대 경로 또는 상대 경로를 지정하여 이를 수행할 수 있습니다. 이러한 경로는 <code>use</code> 문으로 스코프로 가져올 수 있으므로 해당 스코프에서 항목을 여러 번 사용할 때 더 짧은 경로를 사용할 수 있습니다. 모듈 코드는 기본적으로 비공개이지만, <code>pub</code> 키워드를 추가하여 정의를 공개로 만들 수 있습니다.</p>
<p>다음 장에서는 깔끔하게 정리된 코드에서 사용할 수 있는 표준 라이브러리의 몇 가지 컬렉션 데이터 구조를 살펴볼 것입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="일반적인-컬렉션"><a class="header" href="#일반적인-컬렉션">일반적인 컬렉션</a></h1>
<p>러스트의 표준 라이브러리에는 _컬렉션_이라고 불리는 매우 유용한 데이터 구조가 많이 포함되어 있습니다. 대부분의 다른 데이터 타입은 하나의 특정 값을 나타내지만, 컬렉션은 여러 값을 포함할 수 있습니다. 내장 배열 및 튜플 타입과 달리, 이러한 컬렉션이 가리키는 데이터는 힙에 저장됩니다. 이는 데이터 양이 컴파일 타임에 알려질 필요가 없으며 프로그램 실행 중에 커지거나 줄어들 수 있음을 의미합니다. 각 컬렉션 종류는 다른 기능과 비용을 가지며, 현재 상황에 적합한 것을 선택하는 것은 시간이 지남에 따라 개발될 기술입니다. 이 장에서는 러스트 프로그램에서 매우 자주 사용되는 세 가지 컬렉션을 논의할 것입니다:</p>
<ul>
<li>_벡터_는 가변적인 수의 값을 서로 옆에 저장할 수 있도록 합니다.</li>
<li>_문자열_은 문자들의 컬렉션입니다. 이전에 <code>String</code> 타입에 대해 언급했지만, 이 장에서는 더 깊이 다룰 것입니다.</li>
<li>_해시 맵_은 특정 키에 값을 연관시킬 수 있도록 합니다. 이는 _맵_이라고 불리는 더 일반적인 데이터 구조의 특정 구현입니다.</li>
</ul>
<p>표준 라이브러리에서 제공하는 다른 종류의 컬렉션에 대해 알아보려면, <a href="../std/collections/index.html">문서</a>를 참조하세요.</p>
<p>벡터, 문자열, 해시 맵을 생성하고 업데이트하는 방법과 각각의 특별한 점에 대해 논의할 것입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="벡터로-값의-목록-저장하기"><a class="header" href="#벡터로-값의-목록-저장하기">벡터로 값의 목록 저장하기</a></h2>
<p>우리가 살펴볼 첫 번째 컬렉션 타입은 <code>Vec&lt;T&gt;</code>이며, _벡터_라고도 알려져 있습니다. 벡터는 메모리에서 모든 값을 서로 옆에 배치하는 단일 데이터 구조에 여러 값을 저장할 수 있도록 합니다. 벡터는 동일한 타입의 값만 저장할 수 있습니다. 파일의 텍스트 줄이나 장바구니의 항목 가격과 같이 항목 목록이 있을 때 유용합니다.</p>
<h3 id="새-벡터-생성하기"><a class="header" href="#새-벡터-생성하기">새 벡터 생성하기</a></h3>
<p>새로운 빈 벡터를 생성하려면, 목록 8-1에 표시된 것처럼 <code>Vec::new</code> 함수를 호출합니다.</p>
<Listing number="8-1" caption="Creating a new, empty vector to hold values of type `i32`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let v: Vec&lt;i32&gt; = Vec::new();
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>여기서 타입 명시를 추가했다는 점에 유의하세요. 이 벡터에 어떤 값도 삽입하지 않기 때문에, 러스트는 우리가 어떤 종류의 요소를 저장할 의도인지 알지 못합니다. 이것은 중요한 점입니다. 벡터는 제네릭을 사용하여 구현됩니다. 10장에서 자신만의 타입으로 제네릭을 사용하는 방법을 다룰 것입니다. 지금은 표준 라이브러리에서 제공하는 <code>Vec&lt;T&gt;</code> 타입이 어떤 타입이든 담을 수 있다는 것만 알아두세요. 특정 타입을 담을 벡터를 생성할 때, 꺾쇠 괄호 안에 타입을 지정할 수 있습니다. 목록 8-1에서 우리는 러스트에게 <code>v</code>의 <code>Vec&lt;T&gt;</code>가 <code>i32</code> 타입의 요소를 담을 것이라고 알려주었습니다.</p>
<p>대부분의 경우, 초기 값을 사용하여 <code>Vec&lt;T&gt;</code>를 생성하면 러스트가 저장하려는 값의 타입을 추론하므로, 이러한 타입 명시를 할 필요는 거의 없습니다. 러스트는 편리하게 <code>vec!</code> 매크로를 제공하며, 이 매크로는 주어진 값을 담는 새 벡터를 생성합니다. 목록 8-2는 <code>1</code>, <code>2</code>, <code>3</code> 값을 담는 새 <code>Vec&lt;i32&gt;</code>를 생성합니다. 정수 타입은 <code>i32</code>인데, 이는 3장의 <a href="ch03-02-data-types.html#data-types">“데이터 타입”</a><!-- ignore --> 섹션에서 논의했듯이 기본 정수 타입이기 때문입니다.</p>
<Listing number="8-2" caption="Creating a new vector containing values">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>초기 <code>i32</code> 값을 주었기 때문에, 러스트는 <code>v</code>의 타입이 <code>Vec&lt;i32&gt;</code>임을 추론할 수 있으며, 타입 명시는 필요하지 않습니다. 다음으로, 벡터를 수정하는 방법을 살펴보겠습니다.</p>
<h3 id="벡터-업데이트하기"><a class="header" href="#벡터-업데이트하기">벡터 업데이트하기</a></h3>
<p>벡터를 생성한 다음 요소를 추가하려면, 목록 8-3에 나타난 것처럼 <code>push</code> 메서드를 사용할 수 있습니다.</p>
<Listing number="8-3" caption="Using the `push` method to add values to a vector">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut v = Vec::new();

    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>다른 변수와 마찬가지로, 값을 변경할 수 있도록 하려면 3장에서 논의했듯이 <code>mut</code> 키워드를 사용하여 가변으로 만들어야 합니다. 우리가 안에 넣는 숫자들은 모두 <code>i32</code> 타입이며, 러스트는 이를 데이터로부터 추론하므로 <code>Vec&lt;i32&gt;</code> 명시가 필요 없습니다.</p>
<h3 id="벡터-요소-읽기"><a class="header" href="#벡터-요소-읽기">벡터 요소 읽기</a></h3>
<p>벡터에 저장된 값을 참조하는 방법은 인덱싱을 통하거나 <code>get</code> 메서드를 사용하는 두 가지가 있습니다. 다음 예제에서는 추가적인 명확성을 위해 이 함수들에서 반환되는 값의 타입을 명시했습니다.</p>
<p>목록 8-4는 인덱싱 구문과 <code>get</code> 메서드를 사용하여 벡터의 값에 접근하는 두 가지 방법을 보여줍니다.</p>
<Listing number="8-4" caption="Using indexing syntax and using the `get` method to access an item in a vector">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3, 4, 5];

    let third: &amp;i32 = &amp;v[2];
    println!("세 번째 요소는 {third}입니다");

    let third: Option&lt;&amp;i32&gt; = v.get(2);
    match third {
        Some(third) =&gt; println!("세 번째 요소는 {third}입니다"),
        None =&gt; println!("세 번째 요소가 없습니다."),
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>여기서 몇 가지 세부 사항을 주목하세요. 벡터는 0부터 시작하는 숫자로 인덱스가 지정되므로 세 번째 요소를 얻기 위해 인덱스 값 <code>2</code>를 사용합니다. <code>&amp;</code>와 <code>[]</code>를 사용하면 해당 인덱스 위치의 요소에 대한 참조를 얻습니다. 인덱스를 인수로 전달하여 <code>get</code> 메서드를 사용하면 <code>match</code>와 함께 사용할 수 있는 <code>Option&lt;&amp;T&gt;</code>를 얻게 됩니다.</p>
<p>러스트는 요소에 접근하는 이 두 가지 방법을 제공하여, 기존 요소 범위를 벗어난 인덱스 값을 사용하려고 할 때 프로그램이 어떻게 동작할지 선택할 수 있게 합니다. 예시로, 요소가 5개인 벡터가 있을 때 각 기술을 사용하여 인덱스 100의 요소에 접근하려고 하면 어떤 일이 일어나는지 목록 8-5에서 살펴보겠습니다.</p>
<Listing number="8-5" caption="Attempting to access the element at index 100 in a vector containing five elements">
<pre><pre class="playground"><code class="language-rust should_panic panics edition2021"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3, 4, 5];

    let does_not_exist = &amp;v[100];
    let does_not_exist = v.get(100);
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 코드를 실행하면, 첫 번째 <code>[]</code> 방식은 존재하지 않는 요소를 참조하기 때문에 프로그램이 패닉(panic)을 일으키게 됩니다. 이 방식은 벡터의 끝을 넘어선 요소에 접근하려고 할 때 프로그램을 종료시키고 싶을 때 사용하기 가장 좋습니다.</p>
<p><code>get</code> 메서드에 벡터 범위를 벗어난 인덱스가 전달되면, 패닉 없이 <code>None</code>을 반환합니다. 일반적인 상황에서 벡터 범위를 벗어난 요소에 접근하는 일이 가끔 발생할 수 있다면 이 메서드를 사용하세요. 그러면 여러분의 코드는 6장에서 논의한 것처럼 <code>Some(&amp;element)</code> 또는 <code>None</code>을 처리하는 로직을 갖게 될 것입니다. 예를 들어, 인덱스가 사용자가 입력한 숫자로부터 올 수 있습니다. 사용자가 실수로 너무 큰 숫자를 입력하여 프로그램이 <code>None</code> 값을 받게 된다면, 현재 벡터에 몇 개의 항목이 있는지 사용자에게 알려주고 유효한 값을 입력할 수 있는 기회를 다시 줄 수 있습니다. 이는 오타 때문에 프로그램을 종료시키는 것보다 훨씬 사용자 친화적일 것입니다!</p>
<p>프로그램이 유효한 참조를 가지고 있을 때, 대여 검사기(borrow checker)는 소유권 및 빌림 규칙(4장에서 다룸)을 강제하여 이 참조와 벡터 내용에 대한 다른 모든 참조들이 유효하게 유지되도록 보장합니다. 동일한 스코프 내에서 가변 참조와 불변 참조를 동시에 가질 수 없다는 규칙을 기억하세요. 그 규칙이 목록 8-6에 적용되는데, 여기서 우리는 벡터의 첫 번째 요소에 대한 불변 참조를 보유한 상태에서 끝에 요소를 추가하려고 시도합니다. 함수 뒷부분에서 해당 요소를 다시 참조하려고 하면 이 프로그램은 작동하지 않을 것입니다.</p>
<Listing number="8-6" caption="Attempting to add an element to a vector while holding a reference to an item">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5];

    let first = &amp;v[0];

    v.push(6);

    println!("첫 번째 요소는: {first}입니다");
<span class="boring">}</span></code></pre>
</Listing>
<p>이 코드를 컴파일하면 다음과 같은 오류가 발생합니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:5
  |
4 |     let first = &amp;v[0];
  |                  - immutable borrow occurs here
5 |
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 |
8 |     println!("The first element is: {first}");
  |                                     ------- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `collections` (bin "collections") due to 1 previous error
</code></pre>
<p>목록 8-6의 코드는 겉보기에는 작동해야 할 것처럼 보입니다. 왜 첫 번째 요소에 대한 참조가 벡터 끝의 변경 사항을 신경 써야 할까요? 이 오류는 벡터가 작동하는 방식 때문입니다. 벡터는 메모리에서 값들을 서로 이웃하게 배치하므로, 벡터 끝에 새로운 요소를 추가할 때 현재 벡터가 저장된 위치에 모든 요소를 나란히 놓을 공간이 부족하다면 새로운 메모리를 할당하고 기존 요소들을 새로운 공간으로 복사해야 할 수도 있습니다. 이 경우, 첫 번째 요소에 대한 참조는 할당 해제된 메모리를 가리키게 됩니다. 빌림 규칙은 프로그램이 이러한 상황에 처하는 것을 방지합니다.</p>
<blockquote>
<p>참고: <code>Vec&lt;T&gt;</code> 타입의 구현 세부 사항에 대해 더 자세히 알고 싶다면 <a href="../nomicon/vec/vec.html">“The Rustonomicon”</a>을 참조하세요.</p>
</blockquote>
<h3 id="벡터의-값들을-순회하기"><a class="header" href="#벡터의-값들을-순회하기">벡터의 값들을 순회하기</a></h3>
<p>벡터의 각 요소에 차례로 접근하기 위해, 인덱스를 사용하여 하나씩 접근하는 대신 모든 요소를 순회할 수 있습니다. 목록 8-7은 <code>for</code> 루프를 사용하여 <code>i32</code> 값 벡터의 각 요소에 대한 불변 참조를 얻고 이를 출력하는 방법을 보여줍니다.</p>
<Listing number="8-7" caption="Printing each element in a vector by iterating over the elements using a `for` loop">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let v = vec![100, 32, 57];
    for i in &amp;v {
        println!("{i}");
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>가변 벡터의 각 요소에 대한 가변 참조를 순회하여 모든 요소를 변경할 수도 있습니다. 목록 8-8의 <code>for</code> 루프는 각 요소에 <code>50</code>을 더할 것입니다.</p>
<Listing number="8-8" caption="Iterating over mutable references to elements in a vector">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut v = vec![100, 32, 57];
    for i in &amp;mut v {
        *i += 50;
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>가변 참조가 가리키는 값을 변경하려면, <code>+=</code> 연산자를 사용하기 전에 <code>*</code> 역참조 연산자를 사용하여 <code>i</code>의 값에 접근해야 합니다. 역참조 연산자에 대해서는 15장의 <a href="ch15-02-deref.html#following-the-pointer-to-the-value-with-the-dereference-operator">“포인터를 따라 값에 접근하기”</a><!-- ignore --> 섹션에서 더 자세히 이야기하겠습니다.</p>
<p>벡터를 불변으로든 가변으로든 순회하는 것은 대여 검사기의 규칙 덕분에 안전합니다. 만약 목록 8-7과 목록 8-8의 <code>for</code> 루프 본문에서 항목을 삽입하거나 제거하려고 시도한다면, 목록 8-6의 코드에서와 유사한 컴파일러 오류가 발생할 것입니다. <code>for</code> 루프가 보유한 벡터에 대한 참조가 벡터 전체의 동시 수정을 방지하기 때문입니다.</p>
<h3 id="열거형을-사용하여-여러-타입-저장하기"><a class="header" href="#열거형을-사용하여-여러-타입-저장하기">열거형을 사용하여 여러 타입 저장하기</a></h3>
<p>벡터는 동일한 타입의 값들만 저장할 수 있습니다. 이는 때때로 불편할 수 있는데, 서로 다른 타입의 항목 목록을 저장해야 하는 유스케이스가 분명히 존재하기 때문입니다. 다행히도, 열거형의 variant들은 동일한 열거형 타입 아래에 정의되므로, 서로 다른 타입의 요소들을 나타내기 위해 하나의 타입이 필요할 때 열거형을 정의하여 사용할 수 있습니다!</p>
<p>예를 들어, 어떤 열은 정수, 어떤 열은 부동 소수점 숫자, 그리고 어떤 열은 문자열을 포함하는 스프레드시트의 행에서 값들을 가져오고 싶다고 가정해 봅시다. 우리는 서로 다른 값 타입들을 담을 variant들을 가진 열거형을 정의할 수 있으며, 모든 열거형 variant들은 해당 열거형이라는 동일한 타입으로 간주됩니다. 그러면 그 열거형을 담는 벡터를 만들 수 있고, 결과적으로 서로 다른 타입들을 담을 수 있게 됩니다. 이를 목록 8-9에서 보여줍니다.</p>
<Listing number="8-9" caption="Defining an `enum` to store values of different types in one vector">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from("blue")),
        SpreadsheetCell::Float(10.12),
    ];
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>러스트는 컴파일 타임에 벡터에 어떤 타입이 들어갈지 알아야 각 요소를 저장하는 데 힙 메모리가 정확히 얼마나 필요한지 알 수 있습니다. 또한 이 벡터에 허용되는 타입들을 명시적으로 밝혀야 합니다. 만약 러스트가 벡터에 어떤 타입이든 담을 수 있게 허용한다면, 벡터의 요소들에 대해 수행되는 연산에서 하나 이상의 타입이 오류를 일으킬 가능성이 생깁니다. 열거형과 <code>match</code> 표현식을 함께 사용하면, 6장에서 논의했듯이 러스트는 컴파일 타임에 모든 가능한 경우를 처리하도록 보장할 것입니다.</p>
<p>프로그램이 런타임에 벡터에 저장할 타입들의 전체 집합을 미리 알 수 없다면, 열거형 방식은 작동하지 않을 것입니다. 대신 18장에서 다룰 트레이트 객체(trait object)를 사용할 수 있습니다.</p>
<p>벡터를 사용하는 가장 일반적인 방법들을 논의했으므로, 표준 라이브러리가 <code>Vec&lt;T&gt;</code>에 정의해 둔 수많은 유용한 메서드들을 <a href="../std/vec/struct.Vec.html">API 문서</a><!-- ignore -->에서 꼭 확인해 보시기 바랍니다. 예를 들어, <code>push</code> 외에도 마지막 요소를 제거하고 반환하는 <code>pop</code> 메서드가 있습니다.</p>
<h3 id="벡터를-드롭하면-그-요소들도-드롭됩니다"><a class="header" href="#벡터를-드롭하면-그-요소들도-드롭됩니다">벡터를 드롭하면 그 요소들도 드롭됩니다</a></h3>
<p>다른 모든 <code>struct</code>와 마찬가지로, 벡터는 목록 8-10의 주석에 나타난 것처럼 스코프를 벗어날 때 해제됩니다.</p>
<Listing number="8-10" caption="Showing where the vector and its elements are dropped">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    {
        let v = vec![1, 2, 3, 4];

        // v를 사용하여 작업 수행
    } // &lt;- v가 스코프를 벗어나고 여기서 해제됨
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>벡터가 드롭될 때 그 안의 모든 내용물도 함께 드롭됩니다. 즉, 벡터가 담고 있던 정수들도 정리됩니다. 대여 검사기는 벡터 자체의 유효성이 유지되는 동안에만 벡터 내용에 대한 참조가 사용되도록 보장합니다.</p>
<p>다음 컬렉션 타입인 <code>String</code>으로 넘어가 봅시다!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="문자열로-utf-8-인코딩된-텍스트-저장하기"><a class="header" href="#문자열로-utf-8-인코딩된-텍스트-저장하기">문자열로 UTF-8 인코딩된 텍스트 저장하기</a></h2>
<p>우리는 4장에서 문자열에 대해 이야기했지만, 이제 더 깊이 있게 살펴보겠습니다. 새로운 러스트 사용자들은 흔히 세 가지 이유가 복합적으로 작용하여 문자열에서 막히곤 합니다: 발생 가능한 오류를 노출하려는 러스트의 경향, 문자열이 많은 프로그래머들이 생각하는 것보다 더 복잡한 데이터 구조라는 점, 그리고 UTF-8입니다. 이러한 요인들이 결합되어 다른 프로그래밍 언어에서 온 사람들에게는 어렵게 느껴질 수 있습니다.</p>
<p>문자열은 바이트 컬렉션에 이 바이트들이 텍스트로 해석될 때 유용한 기능을 제공하는 몇 가지 메서드가 추가된 형태로 구현되어 있기 때문에, 컬렉션의 맥락에서 논의합니다. 이번 섹션에서는 생성, 업데이트, 읽기 등 모든 컬렉션 타입이 가지고 있는 <code>String</code>에 대한 연산들을 살펴보겠습니다. 또한 <code>String</code>이 다른 컬렉션과 다른 점, 즉 사람과 컴퓨터가 <code>String</code> 데이터를 해석하는 방식의 차이로 인해 <code>String</code>에 대한 인덱싱이 어떻게 복잡해지는지도 논의할 것입니다.</p>
<h3 id="문자열이란-무엇인가"><a class="header" href="#문자열이란-무엇인가">문자열이란 무엇인가?</a></h3>
<p>먼저 _문자열(string)_이라는 용어가 무엇을 의미하는지 정의해 보겠습니다. 러스트의 코어 언어에는 오직 하나의 문자열 타입만 있는데, 바로 빌린 형태인 <code>&amp;str</code>로 주로 보이는 문자열 슬라이스 <code>str</code>입니다. 4장에서 우리는 다른 곳에 저장된 UTF-8 인코딩된 문자열 데이터에 대한 참조인 _문자열 슬라이스_에 대해 이야기했습니다. 예를 들어 문자열 리터럴은 프로그램의 바이너리에 저장되므로 문자열 슬라이스입니다.</p>
<p>러스트의 표준 라이브러리에서 제공되며 코어 언어에 코딩되지 않은 <code>String</code> 타입은 확장 가능하고, 가변적이며, 소유권을 가지는 UTF-8 인코딩된 문자열 타입입니다. 러스트 개발자들이 러스트에서 "문자열"이라고 언급할 때, 그들은 <code>String</code> 또는 문자열 슬라이스 <code>&amp;str</code> 타입 중 하나를 지칭할 수 있으며, 단순히 한 가지 타입만을 의미하지는 않습니다. 이 섹션은 주로 <code>String</code>에 대한 것이지만, 두 타입 모두 러스트의 표준 라이브러리에서 많이 사용되며, <code>String</code>과 문자열 슬라이스 모두 UTF-8로 인코딩됩니다.</p>
<h3 id="새-문자열-생성하기"><a class="header" href="#새-문자열-생성하기">새 문자열 생성하기</a></h3>
<p><code>Vec&lt;T&gt;</code>에서 사용 가능한 많은 동일한 연산들이 <code>String</code>에서도 사용 가능합니다. <code>String</code>은 실제로 몇 가지 추가 보장, 제한 및 기능을 가진 바이트 벡터를 감싸는 래퍼로 구현되어 있기 때문입니다. <code>Vec&lt;T&gt;</code>와 <code>String</code>에서 동일하게 작동하는 함수의 예는 목록 8-11에 표시된 인스턴스를 생성하는 <code>new</code> 함수입니다.</p>
<Listing number="8-11" caption="Creating a new, empty `String`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::new();
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 줄은 <code>s</code>라는 새롭고 빈 문자열을 생성하며, 여기에 데이터를 로드할 수 있습니다. 종종 문자열을 시작할 초기 데이터가 있을 것입니다. 이를 위해 문자열 리터럴처럼 <code>Display</code> 트레이트를 구현하는 모든 타입에서 사용 가능한 <code>to_string</code> 메서드를 사용합니다. 목록 8-12는 두 가지 예시를 보여줍니다.</p>
<Listing number="8-12" caption="Using the `to_string` method to create a `String` from a string literal">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let data = "초기 내용";

    let s = data.to_string();

    // 이 메서드는 리터럴에서도 직접 작동합니다:
    let s = "초기 내용".to_string();
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 코드는 <code>initial contents</code>를 포함하는 문자열을 생성합니다.</p>
<p>또한 <code>String::from</code> 함수를 사용하여 문자열 리터럴로부터 <code>String</code>을 생성할 수도 있습니다. 목록 8-13의 코드는 <code>to_string</code>을 사용하는 목록 8-12의 코드와 동일합니다.</p>
<Listing number="8-13" caption="Using the `String::from` function to create a `String` from a string literal">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s = String::from("초기 내용");
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>문자열은 매우 다양한 용도로 사용되기 때문에, 문자열에 대해 여러 가지 제네릭 API를 사용할 수 있으며, 이는 우리에게 많은 선택지를 제공합니다. 일부는 중복되어 보일 수 있지만, 모두 제 역할을 합니다! 이 경우 <code>String::from</code>과 <code>to_string</code>은 동일한 작업을 수행하므로, 어떤 것을 선택할지는 스타일과 가독성의 문제입니다.</p>
<p>문자열은 UTF-8로 인코딩된다는 점을 기억하세요. 따라서 목록 8-14에 표시된 것처럼 올바르게 인코딩된 모든 데이터를 포함할 수 있습니다.</p>
<Listing number="8-14" caption="Storing greetings in different languages in strings">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let hello = String::from("السلام عليكم");
    let hello = String::from(Dobrý den);
    let hello = String::from("Hello");
    let hello = String::from("שלום");
    let hello = String::from("नमस्ते");
    let hello = String::from("こんにちは");
    let hello = String::from("안녕하세요");
    let hello = String::from("你好");
    let hello = String::from("Olá");
    let hello = String::from("Здравствуйте");
    let hello = String::from("Hola");
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 모든 것은 유효한 <code>String</code> 값입니다.</p>
<h3 id="문자열-업데이트하기"><a class="header" href="#문자열-업데이트하기">문자열 업데이트하기</a></h3>
<p><code>String</code>은 <code>Vec&lt;T&gt;</code>의 내용처럼 크기가 커지고 내용이 변경될 수 있습니다. 데이터를 더 추가하면 말이죠. 또한 <code>+</code> 연산자나 <code>format!</code> 매크로를 편리하게 사용하여 <code>String</code> 값을 연결할 수 있습니다.</p>
<h4 id="push_str과-push로-문자열에-추가하기"><a class="header" href="#push_str과-push로-문자열에-추가하기"><code>push_str</code>과 <code>push</code>로 문자열에 추가하기</a></h4>
<p>목록 8-15에 나타난 것처럼 <code>push_str</code> 메서드를 사용하여 문자열 슬라이스를 추가함으로써 <code>String</code>을 확장할 수 있습니다.</p>
<Listing number="8-15" caption="Appending a string slice to a `String` using the `push_str` method">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::from("foo");
    s.push_str("bar");
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 두 줄이 실행된 후 <code>s</code>는 <code>foobar</code>를 포함하게 됩니다. <code>push_str</code> 메서드는 우리가 매개변수의 소유권을 가져오는 것을 반드시 원하지는 않기 때문에 문자열 슬라이스를 받습니다. 예를 들어, 목록 8-16의 코드에서 우리는 <code>s2</code>의 내용을 <code>s1</code>에 추가한 후에도 <code>s2</code>를 계속 사용하고 싶어 합니다.</p>
<Listing number="8-16" caption="Using a string slice after appending its contents to a `String`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s1 = String::from("foo");
    let s2 = "bar";
    s1.push_str(s2);
    println!("s2는 {s2}입니다");
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>만약 <code>push_str</code> 메서드가 <code>s2</code>의 소유권을 가져갔다면, 마지막 줄에서 그 값을 출력할 수 없었을 것입니다. 하지만 이 코드는 우리가 기대한 대로 작동합니다!</p>
<p><code>push</code> 메서드는 단일 문자를 매개변수로 받아 <code>String</code>에 추가합니다. 목록 8-17은 <code>push</code> 메서드를 사용하여 <code>String</code>에 글자 'l'을 추가합니다.</p>
<Listing number="8-17" caption="Adding one character to a `String` value using `push`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::from("lo");
    s.push('l');
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>결과적으로 <code>s</code>는 <code>lol</code>을 포함하게 됩니다.</p>
<h4 id="-연산자나-format-매크로를-이용한-문자열-연결"><a class="header" href="#-연산자나-format-매크로를-이용한-문자열-연결"><code>+</code> 연산자나 <code>format!</code> 매크로를 이용한 문자열 연결</a></h4>
<p>종종 두 개의 기존 문자열을 결합하고 싶을 때가 있습니다. 한 가지 방법은 목록 8-18에 나타난 것처럼 <code>+</code> 연산자를 사용하는 것입니다.</p>
<Listing number="8-18" caption="Using the `+` operator to combine two `String` values into a new `String` value">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    let s3 = s1 + &amp;s2; // s1은 여기로 이동되어 더 이상 사용할 수 없음에 유의하세요.
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>문자열 <code>s3</code>은 <code>Hello, world!</code>를 포함하게 됩니다. 더하기 연산 후 <code>s1</code>이 더 이상 유효하지 않은 이유와 <code>s2</code>에 대한 참조를 사용한 이유는 <code>+</code> 연산자를 사용할 때 호출되는 메서드의 시그니처와 관련이 있습니다. <code>+</code> 연산자는 <code>add</code> 메서드를 사용하며, 그 시그니처는 대략 다음과 같습니다.</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {</code></pre>
<p>표준 라이브러리에서 여러분은 제네릭과 연관 타입(associated types)을 사용하여 정의된 <code>add</code>를 보게 될 것입니다. 여기서는 <code>String</code> 값으로 이 메서드를 호출할 때 일어나는 일인 구체적인 타입들로 대체했습니다. 제네릭에 대해서는 10장에서 논의할 것입니다. 이 시그니처는 우리가 <code>+</code> 연산자의 까다로운 부분들을 이해하는 데 필요한 단서들을 제공합니다.</p>
<p>첫째, <code>s2</code>에는 <code>&amp;</code>가 있는데, 이는 두 번째 문자열의 _참조_를 첫 번째 문자열에 더하고 있음을 의미합니다. 이는 <code>add</code> 함수의 <code>s</code> 매개변수 때문입니다. 우리는 <code>String</code>에 <code>&amp;str</code>만 더할 수 있으며, 두 <code>String</code> 값을 더할 수는 없습니다. 하지만 잠깐만요, <code>add</code>의 두 번째 매개변수로 지정된 것은 <code>&amp;str</code>인데 <code>&amp;s2</code>의 타입은 <code>&amp;String</code>입니다. 그렇다면 왜 목록 8-18이 컴파일될까요?</p>
<p><code>add</code> 호출 시 <code>&amp;s2</code>를 사용할 수 있는 이유는 컴파일러가 <code>&amp;String</code> 인수를 <code>&amp;str</code>로 _강제(coerce)_할 수 있기 때문입니다. 우리가 <code>add</code> 메서드를 호출할 때, 러스트는 _역참조 강제(deref coercion)_를 사용하는데, 이는 여기서 <code>&amp;s2</code>를 <code>&amp;s2[..]</code>로 바꿉니다. 15장에서 역참조 강제에 대해 더 깊이 다룰 것입니다. <code>add</code>는 <code>s</code> 매개변수의 소유권을 가져가지 않으므로, 이 연산 후에도 <code>s2</code>는 여전히 유효한 <code>String</code>으로 남습니다.</p>
<p>둘째, 시그니처를 보면 <code>self</code>에 <code>&amp;</code>가 없으므로 <code>add</code>가 <code>self</code>의 소유권을 가져간다는 것을 알 수 있습니다. 이는 목록 8-18의 <code>s1</code>이 <code>add</code> 호출로 이동되어 그 이후로는 더 이상 유효하지 않음을 의미합니다. 따라서 <code>let s3 = s1 + &amp;s2;</code>가 두 문자열을 모두 복사하고 새로운 문자열을 만드는 것처럼 보일지라도, 실제로는 <code>s1</code>의 소유권을 가져와서 <code>s2</code>의 내용 복사본을 덧붙인 다음 결과의 소유권을 반환합니다. 즉, 많은 복사가 일어나는 것처럼 보이지만 실제로는 그렇지 않으며, 구현이 복사보다 더 효율적입니다.</p>
<p>여러 문자열을 결합해야 하는 경우, <code>+</code> 연산자의 동작은 다루기 불편해집니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = s1 + "-" + &amp;s2 + "-" + &amp;s3;
<span class="boring">}</span></code></pre></pre>
<p>이 지점에서 <code>s</code>는 <code>tic-tac-toe</code>가 됩니다. 수많은 <code>+</code>와 <code>"</code> 문자로 인해 코드가 무엇을 하는지 한눈에 파악하기 어렵습니다. 문자열을 더 복잡한 방식으로 결합하려면 대신 <code>format!</code> 매크로를 사용할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = format!("{s1}-{s2}-{s3}");
<span class="boring">}</span></code></pre></pre>
<p>이 코드 역시 <code>s</code>를 <code>tic-tac-toe</code>로 설정합니다. <code>format!</code> 매크로는 <code>println!</code>과 비슷하게 작동하지만, 출력을 화면에 인쇄하는 대신 그 내용을 담은 <code>String</code>을 반환합니다. <code>format!</code>을 사용한 버전이 훨씬 읽기 쉬우며, <code>format!</code> 매크로가 생성하는 코드는 참조를 사용하므로 이 호출은 매개변수의 소유권을 가져가지 않습니다.</p>
<h3 id="문자열-인덱싱"><a class="header" href="#문자열-인덱싱">문자열 인덱싱</a></h3>
<p>다른 많은 프로그래밍 언어에서는 인덱스로 문자열의 개별 문자에 접근하는 것이 유효하고 일반적인 연산입니다. 하지만 러스트에서 인덱싱 구문을 사용하여 <code>String</code>의 일부에 접근하려고 하면 오류가 발생합니다. 목록 8-19의 유효하지 않은 코드를 살펴봅시다.</p>
<Listing number="8-19" caption="Attempting to use indexing syntax with a String">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");
    let h = s1[0];
<span class="boring">}</span></code></pre>
</Listing>
<p>이 코드는 다음과 같은 오류를 발생시킵니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `str` cannot be indexed by `{integer}`
 --&gt; src/main.rs:3:16
  |
3 |     let h = s1[0];
  |                ^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex&lt;str&gt;` is not implemented for `{integer}`, which is required by `String: Index&lt;_&gt;`
  = note: you can use `.chars().nth()` or `.bytes().nth()`
          for more information, see chapter 8 in The Book: &lt;https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings&gt;
  = help: the trait `SliceIndex&lt;[_]&gt;` is implemented for `usize`
  = help: for that trait implementation, expected `[_]`, found `str`
  = note: required for `String` to implement `Index&lt;{integer}&gt;`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections` (bin "collections") due to 1 previous error
</code></pre>
<p>오류 메시지와 노트가 상황을 잘 설명해 줍니다: 러스트 문자열은 인덱싱을 지원하지 않습니다. 그런데 왜 그럴까요? 그 질문에 답하기 위해, 러스트가 메모리에 문자열을 저장하는 방식을 논의해야 합니다.</p>
<h4 id="내부-표현"><a class="header" href="#내부-표현">내부 표현</a></h4>
<p><code>String</code>은 <code>Vec&lt;u8&gt;</code>을 감싼 래퍼입니다. 목록 8-14에서 보았던 적절히 인코딩된 UTF-8 예제 문자열들을 몇 가지 살펴보겠습니다. 먼저 이것입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from("السلام عليكم");
</span><span class="boring">    let hello = String::from(Dobrý den);
</span><span class="boring">    let hello = String::from("Hello");
</span><span class="boring">    let hello = String::from("שלום");
</span><span class="boring">    let hello = String::from("नमस्ते");
</span><span class="boring">    let hello = String::from("こんにちは");
</span><span class="boring">    let hello = String::from("안녕하세요");
</span><span class="boring">    let hello = String::from("你好");
</span><span class="boring">    let hello = String::from("Olá");
</span><span class="boring">    let hello = String::from("Здравствуйте");
</span>    let hello = String::from("Hola");
<span class="boring">}</span></code></pre></pre>
<p>이 경우 <code>len</code>은 <code>4</code>가 되며, 이는 <code>"Hola"</code> 문자열을 저장하는 벡터의 길이가 4바이트임을 의미합니다. 이 글자들은 UTF-8로 인코딩될 때 각각 1바이트를 차지합니다. 하지만 다음 줄은 여러분을 놀라게 할 수도 있습니다 (이 문자열은 숫자 3이 아니라 키릴 문자 대문자 _Ze_로 시작함에 유의하세요):</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from("السلام عليكم");
</span><span class="boring">    let hello = String::from(Dobrý den);
</span><span class="boring">    let hello = String::from("Hello");
</span><span class="boring">    let hello = String::from("שלום");
</span><span class="boring">    let hello = String::from("नमस्ते");
</span><span class="boring">    let hello = String::from("こんにちは");
</span><span class="boring">    let hello = String::from("안녕하세요");
</span><span class="boring">    let hello = String::from("你好");
</span><span class="boring">    let hello = String::from("Olá");
</span>    let hello = String::from("Здравствуйте");
<span class="boring">    let hello = String::from("Hola");
</span><span class="boring">}</span></code></pre></pre>
<p>이 문자열의 길이가 얼마냐고 묻는다면 12라고 답할 수도 있을 것입니다. 하지만 러스트의 답은 24입니다. 이는 “Здравствуйте”를 UTF-8로 인코딩하는 데 필요한 바이트 수인데, 이 문자열의 각 유니코드 스칼라 값이 2바이트의 저장 공간을 차지하기 때문입니다. 따라서 문자열 바이트에 대한 인덱스가 항상 유효한 유니코드 스칼라 값과 일치하는 것은 아닙니다. 이를 설명하기 위해, 다음의 유효하지 않은 러스트 코드를 살펴보세요:</p>
<pre><code class="language-rust ignore does_not_compile">let hello = "Здравствуйте";
let answer = &amp;hello[0];</code></pre>
<p>이미 알고 있듯이 <code>answer</code>는 첫 글자인 <code>З</code>가 되지 않을 것입니다. UTF-8로 인코딩될 때 <code>З</code>의 첫 번째 바이트는 <code>208</code>이고 두 번째 바이트는 <code>151</code>이므로, <code>answer</code>는 사실상 <code>208</code>이 되어야 할 것처럼 보이지만, <code>208</code>은 그 자체로 유효한 문자가 아닙니다. 이 문자열의 첫 글자를 요청했을 때 <code>208</code>을 반환하는 것은 아마도 사용자가 원하는 결과가 아닐 것입니다. 하지만 그것이 러스트가 바이트 인덱스 0에서 가진 유일한 데이터입니다. 문자열에 라틴 문자만 포함되어 있더라도 사용자는 일반적으로 바이트 값이 반환되는 것을 원하지 않습니다. 만약 <code>&amp;"hi"[0]</code>가 바이트 값을 반환하는 유효한 코드였다면, <code>h</code>가 아니라 <code>104</code>를 반환했을 것입니다.</p>
<p>따라서 예상치 못한 값을 반환하여 즉시 발견되지 않을 수도 있는 버그를 일으키는 것을 방지하기 위해, 러스트는 이 코드를 아예 컴파일하지 않으며 개발 과정 초기에 오해를 방지합니다.</p>
<h4 id="바이트와-스칼라-값과-그래핌-클러스터-오-이런"><a class="header" href="#바이트와-스칼라-값과-그래핌-클러스터-오-이런">바이트와 스칼라 값과 그래핌 클러스터! 오 이런!</a></h4>
<p>UTF-8에 대한 또 다른 요점은, 러스트의 관점에서 문자열을 바라보는 세 가지 유의미한 방법이 있다는 것입니다: 바이트, 스칼라 값, 그리고 그래핌 클러스터(우리가 _글자_라고 부르는 것에 가장 가까운 것)입니다.</p>
<p>데바나가리 문자로 쓰인 힌디어 단어 “नमस्ते”를 살펴보면, 다음과 같은 <code>u8</code> 값의 벡터로 저장됩니다.</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>이는 18바이트이며 컴퓨터가 궁극적으로 이 데이터를 저장하는 방식입니다. 이를 러스트의 <code>char</code> 타입인 유니코드 스칼라 값으로 바라본다면, 이 바이트들은 다음과 같이 보입니다.</p>
<pre><code class="language-text">['न', 'म', 'स', '्', 'त', 'े']
</code></pre>
<p>여기에는 6개의 <code>char</code> 값이 있지만, 네 번째와 여섯 번째는 글자가 아닙니다. 그것들은 그 자체로는 의미가 없는 발음 구별 부호(diacritics)입니다. 마지막으로, 이를 그래핌 클러스터로 바라본다면, 사람이 힌디어 단어를 구성하는 네 개의 글자라고 부를 만한 결과를 얻게 됩니다.</p>
<pre><code class="language-text">["न", "म", "स्", "ते"]
</code></pre>
<p>러스트는 컴퓨터가 저장하는 원시 문자열 데이터를 해석하는 다양한 방법을 제공하므로, 데이터가 어떤 인간 언어로 되어 있든 각 프로그램이 필요한 해석 방식을 선택할 수 있습니다.</p>
<p>러스트가 <code>String</code>에 인덱싱하여 문자를 가져오는 것을 허용하지 않는 마지막 이유는 인덱싱 작업이 항상 상수 시간(O(1))이 걸릴 것으로 예상되기 때문입니다. 그러나 <code>String</code>으로는 그 성능을 보장할 수 없습니다. 왜냐하면 러스트는 유효한 문자가 몇 개인지 확인하기 위해 내용의 시작부터 인덱스까지 훑어야 하기 때문입니다.</p>
<h3 id="문자열-슬라이싱"><a class="header" href="#문자열-슬라이싱">문자열 슬라이싱</a></h3>
<p>문자열 인덱싱은 종종 좋지 않은 생각인데, 문자열 인덱싱 연산의 반환 타입이 무엇이어야 할지 명확하지 않기 때문입니다: 바이트 값, 문자, 그래핌 클러스터, 또는 문자열 슬라이스 중 무엇일까요? 따라서 인덱스를 사용하여 문자열 슬라이스를 만들어야 한다면, 러스트는 더 구체적으로 명시할 것을 요구합니다.</p>
<p>단일 숫자로 <code>[]</code>를 사용하여 인덱싱하는 대신, 범위와 함께 <code>[]</code>를 사용하여 특정 바이트를 포함하는 문자열 슬라이스를 만들 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = "Здравствуйте";

let s = &amp;hello[0..4];
<span class="boring">}</span></code></pre></pre>
<p>여기서 <code>s</code>는 문자열의 처음 4바이트를 포함하는 <code>&amp;str</code>이 될 것입니다. 앞서 각 문자가 2바이트라고 언급했으므로, <code>s</code>는 <code>Зд</code>가 될 것입니다.</p>
<p>만약 <code>&amp;hello[0..1]</code>과 같이 문자의 바이트 일부만 슬라이스하려고 시도한다면, 벡터에서 유효하지 않은 인덱스에 접근했을 때와 마찬가지로 런타임에 패닉이 발생할 것입니다:</p>
<pre><code> Running `target/debug/collections`
</code></pre>
<p>thread 'main' panicked at src/main.rs:4:19: byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of <code>Здравствуйте</code> note: run with <code>RUST_BACKTRACE=1</code> environment variable to display a backtrace</p>
<pre><code></code></pre>
<p>범위를 사용하여 문자열 슬라이스를 만들 때는 주의해야 합니다. 그렇게 하면 프로그램이 충돌할 수 있기 때문입니다.</p>
<h3 id="문자열을-반복하는-메서드"><a class="header" href="#문자열을-반복하는-메서드">문자열을 반복하는 메서드</a></h3>
<p>문자열 조각을 조작하는 가장 좋은 방법은 문자 또는 바이트를 원하는지 명시적으로 지정하는 것입니다. 개별 유니코드 스칼라 값의 경우 <code>chars</code> 메서드를 사용하십시오. “Зд”에 대해 <code>chars</code>를 호출하면 두 개의 <code>char</code> 타입 값이 분리되어 반환되며, 결과를 반복하여 각 요소에 접근할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for c in "Зд".chars() {
    println!("{c}");
}
<span class="boring">}</span></code></pre></pre>
<p>이 코드는 다음을 출력합니다:</p>
<pre><code class="language-text">З
д
</code></pre>
<p>또는 <code>bytes</code> 메서드는 각 원시 바이트를 반환하며, 이는 여러분의 도메인에 적합할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for b in "Зд".bytes() {
    println!("{b}");
}
<span class="boring">}</span></code></pre></pre>
<p>이 코드는 이 문자열을 구성하는 4바이트를 출력합니다:</p>
<pre><code class="language-text">208
151
208
180
</code></pre>
<p>하지만 유효한 유니코드 스칼라 값은 1바이트 이상으로 구성될 수 있다는 점을 기억하십시오.</p>
<p>데바나가리 문자와 같이 문자열에서 그래핌 클러스터를 얻는 것은 복잡하므로 표준 라이브러리에서는 이 기능을 제공하지 않습니다. 이 기능이 필요한 경우 <a href="https://crates.io/">crates.io</a><!-- ignore -->에서 크레이트를 사용할 수 있습니다.</p>
<h3 id="문자열은-그렇게-간단하지-않습니다"><a class="header" href="#문자열은-그렇게-간단하지-않습니다">문자열은 그렇게 간단하지 않습니다</a></h3>
<p>요약하자면, 문자열은 복잡합니다. 프로그래밍 언어마다 이 복잡성을 프로그래머에게 제시하는 방법에 대해 서로 다른 선택을 합니다. 러스트는 모든 러스트 프로그램의 기본 동작으로 <code>String</code> 데이터를 올바르게 처리하도록 선택했습니다. 이는 프로그래머가 UTF-8 데이터를 처리하는 데 미리 더 많은 생각을 해야 함을 의미합니다. 이 트레이드오프는 다른 프로그래밍 언어에서보다 문자열의 복잡성을 더 많이 노출하지만, 개발 수명 주기 후반에 비 ASCII 문자와 관련된 오류를 처리해야 하는 것을 방지합니다.</p>
<p>좋은 소식은 표준 라이브러리가 이러한 복잡한 상황을 올바르게 처리하는 데 도움이 되도록 <code>String</code> 및 <code>&amp;str</code> 타입을 기반으로 구축된 많은 기능을 제공한다는 것입니다. 문자열 내에서 검색하기 위한 <code>contains</code>와 문자열 일부를 다른 문자열로 대체하기 위한 <code>replace</code>와 같은 유용한 메서드에 대한 문서를 확인하십시오.</p>
<p>조금 덜 복잡한 것으로 전환해 봅시다: 해시 맵!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="해시-맵에서-키와-연관된-값-저장하기"><a class="header" href="#해시-맵에서-키와-연관된-값-저장하기">해시 맵에서 키와 연관된 값 저장하기</a></h2>
<p>_해싱 함수_를 사용하여 이 키와 값을 메모리에 배치하는 방법을 결정합니다. 많은 프로그래밍 언어가 이러한 종류의 데이터 구조를 지원하지만, <em>해시</em>, <em>맵</em>, <em>객체</em>, <em>해시 테이블</em>, <em>딕셔너리</em>, 또는 _연관 배열_과 같이 다른 이름을 사용하는 경우가 많습니다.</p>
<p>해시 맵은 벡터처럼 인덱스를 사용하는 대신 어떤 타입이든 될 수 있는 키를 사용하여 데이터를 조회하려 할 때 유용합니다. 예를 들어 게임에서 각 팀의 점수를 해시 맵에 기록할 수 있는데, 여기서 키는 팀 이름이고 값은 각 팀의 점수입니다. 팀 이름이 주어지면 점수를 조회할 수 있습니다.</p>
<p>이 섹션에서는 해시 맵의 기본 API를 살펴보겠지만, 표준 라이브러리의 <code>HashMap&lt;K, V&gt;</code>에 정의된 함수에는 더 많은 유용한 기능이 숨어 있습니다. 항상 그렇듯이 자세한 내용은 표준 라이브러리 문서를 확인하십시오.</p>
<h3 id="새로운-해시-맵-생성하기"><a class="header" href="#새로운-해시-맵-생성하기">새로운 해시 맵 생성하기</a></h3>
<p>빈 해시 맵을 만드는 한 가지 방법은 <code>new</code>를 사용하고 <code>insert</code>로 요소를 추가하는 것입니다. 목록 8-20에서는 이름이 _Blue_와 _Yellow_인 두 팀의 점수를 기록하고 있습니다. Blue 팀은 10점으로 시작하고 Yellow 팀은 50점으로 시작합니다.</p>
<Listing number="8-20" caption="Creating a new hash map and inserting some keys and values">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>먼저 표준 라이브러리의 컬렉션 부분에서 <code>HashMap</code>을 <code>use</code>해야 한다는 점에 유의하십시오. 세 가지 일반적인 컬렉션 중 이 컬렉션은 가장 적게 사용되므로 프렐류드에서 자동으로 스코프로 가져오는 기능에 포함되어 있지 않습니다. 해시 맵은 또한 표준 라이브러리로부터 지원을 덜 받습니다; 예를 들어 해시 맵을 생성하는 내장 매크로가 없습니다.</p>
<p>벡터와 마찬가지로 해시 맵은 데이터를 힙에 저장합니다. 이 <code>HashMap</code>은 <code>String</code> 타입의 키와 <code>i32</code> 타입의 값을 가집니다. 벡터와 마찬가지로 해시 맵은 동질적입니다: 모든 키는 동일한 타입을 가져야 하며, 모든 값도 동일한 타입을 가져야 합니다.</p>
<h3 id="해시-맵의-값에-접근하기"><a class="header" href="#해시-맵의-값에-접근하기">해시 맵의 값에 접근하기</a></h3>
<p>목록 8-21과 같이 <code>get</code> 메서드에 키를 제공하여 해시 맵에서 값을 가져올 수 있습니다.</p>
<Listing number="8-21" caption="Accessing the score for the Blue team stored in the hash map">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);

    let team_name = String::from("Blue");
    let score = scores.get(&amp;team_name).copied().unwrap_or(0);
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>여기서 <code>score</code>는 Blue 팀과 연관된 값을 갖게 되며, 결과는 <code>10</code>이 될 것입니다. <code>get</code> 메서드는 <code>Option&lt;&amp;V&gt;</code>를 반환합니다; 만약 해시 맵에 해당 키에 대한 값이 없다면 <code>get</code>은 <code>None</code>을 반환할 것입니다. 이 프로그램은 <code>Option</code>을 처리하기 위해 <code>copied</code>를 호출하여 <code>Option&lt;&amp;i32&gt;</code> 대신 <code>Option&lt;i32&gt;</code>를 얻은 다음, <code>unwrap_or</code>를 사용하여 <code>scores</code>에 해당 키에 대한 항목이 없으면 <code>score</code>를 0으로 설정합니다.</p>
<p>벡터와 유사한 방식으로 <code>for</code> 루프를 사용하여 해시 맵의 각 키-값 쌍을 반복할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);

    for (key, value) in &amp;scores {
        println!("{key}: {value}");
    }
<span class="boring">}</span></code></pre></pre>
<p>이 코드는 임의의 순서로 각 쌍을 출력합니다:</p>
<pre><code class="language-text">Yellow: 50
Blue: 10
</code></pre>
<h3 id="해시-맵과-소유권"><a class="header" href="#해시-맵과-소유권">해시 맵과 소유권</a></h3>
<p><code>i32</code>와 같이 <code>Copy</code> 트레이트를 구현하는 타입의 경우 값들이 해시 맵으로 복사됩니다. <code>String</code>과 같이 소유된 값의 경우, 값들이 이동되어 해시 맵이 그 값들의 소유자가 될 것입니다. 이는 목록 8-22에서 보여줍니다.</p>
<Listing number="8-22" caption="Showing that keys and values are owned by the hash map once they’re inserted">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let field_name = String::from("Favorite color");
    let field_value = String::from("Blue");

    let mut map = HashMap::new();
    map.insert(field_name, field_value);
    // field_name과 field_value는 이 시점에서 유효하지 않습니다. 사용해 보고
    // 어떤 컴파일러 에러가 발생하는지 확인해 보세요!
<span class="boring">}</span></code></pre></pre>
</Listing>
<p><code>insert</code> 호출로 해시 맵으로 이동된 후에는 <code>field_name</code>과 <code>field_value</code> 변수를 사용할 수 없습니다.</p>
<p>값에 대한 참조를 해시 맵에 삽입하면 값은 해시 맵으로 이동되지 않습니다. 참조가 가리키는 값은 적어도 해시 맵이 유효한 동안에는 유효해야 합니다. 이러한 문제에 대해서는 10장의 <a href="ch10-03-lifetime-syntax.html#validating-references-with-lifetimes">“라이프타임으로 참조 유효성 검증하기”</a><!-- ignore -->에서 더 자세히 이야기할 것입니다.</p>
<h3 id="해시-맵-갱신하기"><a class="header" href="#해시-맵-갱신하기">해시 맵 갱신하기</a></h3>
<p>키와 값 쌍의 수는 늘어날 수 있지만, 각 고유 키는 한 번에 하나의 값만 연관될 수 있습니다 (하지만 그 반대는 성립하지 않습니다: 예를 들어 Blue 팀과 Yellow 팀 모두 <code>scores</code> 해시 맵에 <code>10</code>이라는 값을 저장할 수 있습니다).</p>
<p>해시 맵의 데이터를 변경하려고 할 때, 키에 이미 값이 할당된 경우를 어떻게 처리할지 결정해야 합니다. 이전 값을 완전히 무시하고 새 값으로 대체할 수 있습니다. 또는 이전 값을 유지하고 새 값을 무시하며, 키에 값이 <em>없는</em> 경우에만 새 값을 추가할 수도 있습니다. 아니면 이전 값과 새 값을 결합할 수도 있습니다. 각각 어떻게 하는지 살펴보겠습니다!</p>
<h4 id="값-덮어쓰기"><a class="header" href="#값-덮어쓰기">값 덮어쓰기</a></h4>
<p>키와 값을 해시 맵에 삽입한 다음 동일한 키를 다른 값으로 삽입하면 해당 키와 연관된 값이 대체됩니다. 목록 8-23의 코드가 <code>insert</code>를 두 번 호출하더라도, Blue 팀의 키에 대해 두 번 모두 값을 삽입하고 있기 때문에 해시 맵에는 하나의 키-값 쌍만 포함될 것입니다.</p>
<Listing number="8-23" caption="Replacing a value stored with a particular key">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Blue"), 25);

    println!("{scores:?}");
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 코드는 <code>{"Blue": 25}</code>를 출력할 것입니다. 원래 값 <code>10</code>은 덮어씌워졌습니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="only-inserting-a-value-if-the-key-has-no-value"></a></p>
<h4 id="키가-없을-때만-키와-값-추가하기"><a class="header" href="#키가-없을-때만-키와-값-추가하기">키가 없을 때만 키와 값 추가하기</a></h4>
<p>특정 키가 해시 맵에 값과 함께 이미 존재하는지 확인한 다음 다음과 같은 조치를 취하는 것이 일반적입니다. 키가 해시 맵에 존재하면 기존 값은 그대로 유지되어야 합니다. 키가 존재하지 않으면 키와 값을 삽입합니다.</p>
<p>해시 맵에는 확인하려는 키를 매개변수로 받는 <code>entry</code>라는 특별한 API가 있습니다. <code>entry</code> 메서드의 반환 값은 존재할 수도 있고 존재하지 않을 수도 있는 값을 나타내는 <code>Entry</code>라는 열거형입니다. Yellow 팀의 키에 연관된 값이 있는지 확인하고 싶다고 가정해 봅시다. 만약 없다면 값 <code>50</code>을 삽입하고, Blue 팀에 대해서도 마찬가지로 하고 싶습니다. <code>entry</code> API를 사용하면 코드는 목록 8-24와 같습니다.</p>
<Listing number="8-24" caption="Using the `entry` method to only insert if the key does not already have a value">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();
    scores.insert(String::from("Blue"), 10);

    scores.entry(String::from("Yellow")).or_insert(50);
    scores.entry(String::from("Blue")).or_insert(50);

    println!("{scores:?}");
<span class="boring">}</span></code></pre></pre>
</Listing>
<p><code>Entry</code>의 <code>or_insert</code> 메서드는 해당 <code>Entry</code> 키가 존재할 경우 해당 키에 대한 값의 가변 참조를 반환하도록 정의되어 있으며, 존재하지 않을 경우 매개변수를 이 키의 새 값으로 삽입하고 새 값에 대한 가변 참조를 반환합니다. 이 기법은 로직을 직접 작성하는 것보다 훨씬 깔끔하며, 덤으로 빌림 검사기와도 더 잘 어울립니다.</p>
<p>목록 8-24의 코드를 실행하면 <code>{"Yellow": 50, "Blue": 10}</code>이 출력됩니다. <code>entry</code>에 대한 첫 번째 호출은 Yellow 팀이 아직 값을 가지고 있지 않기 때문에 Yellow 팀의 키를 값 <code>50</code>과 함께 삽입합니다. <code>entry</code>에 대한 두 번째 호출은 Blue 팀이 이미 값 <code>10</code>을 가지고 있기 때문에 해시 맵을 변경하지 않습니다.</p>
<h4 id="이전-값을-기반으로-값-갱신하기"><a class="header" href="#이전-값을-기반으로-값-갱신하기">이전 값을 기반으로 값 갱신하기</a></h4>
<p>해시 맵의 또 다른 일반적인 사용 사례는 키의 값을 조회한 다음 이전 값을 기반으로 업데이트하는 것입니다. 예를 들어, 목록 8-25는 텍스트에 각 단어가 몇 번 나타나는지 세는 코드를 보여줍니다. 단어를 키로 사용하여 해시 맵을 사용하고, 해당 단어를 몇 번 보았는지 추적하기 위해 값을 증가시킵니다. 단어를 처음 본 경우 먼저 값 <code>0</code>을 삽입합니다.</p>
<Listing number="8-25" caption="Counting occurrences of words using a hash map that stores words and counts">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let text = "hello world wonderful world";

    let mut map = HashMap::new();

    for word in text.split_whitespace() {
        let count = map.entry(word).or_insert(0);
        *count += 1;
    }

    println!("{map:?}");
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 코드는 <code>{"world": 2, "hello": 1, "wonderful": 1}</code>을 출력할 것입니다. 동일한 키-값 쌍이 다른 순서로 출력되는 것을 볼 수 있습니다: <a href="ch08-03-hash-maps.html#accessing-values-in-a-hash-map">“해시 맵의 값에 접근하기”</a><!-- ignore -->에서 해시 맵을 반복하는 것은 임의의 순서로 발생한다는 것을 상기하십시오.</p>
<p><code>split_whitespace</code> 메서드는 <code>text</code>의 값을 공백으로 구분한 하위 슬라이스에 대한 반복자를 반환합니다. <code>or_insert</code> 메서드는 지정된 키에 대한 값의 가변 참조(<code>&amp;mut V</code>)를 반환합니다. 여기서 우리는 가변 참조를 <code>count</code> 변수에 저장하므로, 해당 값에 할당하려면 먼저 별표(<code>*</code>)를 사용하여 <code>count</code>를 역참조해야 합니다. 가변 참조는 <code>for</code> 루프가 끝날 때 스코프를 벗어나므로, 이 모든 변경은 안전하며 빌림 규칙에 의해 허용됩니다.</p>
<h3 id="해싱-함수"><a class="header" href="#해싱-함수">해싱 함수</a></h3>
<p>기본적으로 <code>HashMap</code>은 해시 테이블과 관련된 서비스 거부(DoS) 공격에 저항할 수 있는 _SipHash_라는 해싱 함수를 사용합니다<sup class="footnote-reference"><a href="#siphash">1</a></sup><!-- ignore -->. 이것은 가장 빠른 해싱 알고리즘은 아니지만, 성능 저하를 감수하고 얻는 더 나은 보안이라는 트레이드오프는 그만한 가치가 있습니다. 코드를 프로파일링한 결과 기본 해시 함수가 목적에 비해 너무 느리다면, 다른 해셔(hasher)를 지정하여 다른 함수로 전환할 수 있습니다. _해셔_는 <code>BuildHasher</code> 트레이트를 구현하는 타입입니다. 트레이트와 이를 구현하는 방법에 대해서는 <a href="ch10-02-traits.html">10장</a><!-- ignore -->에서 이야기할 것입니다. 굳이 처음부터 해셔를 직접 구현할 필요는 없습니다. <a href="https://crates.io/">crates.io</a><!-- ignore -->에는 다른 러스트 사용자가 공유한, 많은 일반적인 해싱 알고리즘을 구현하는 해셔를 제공하는 라이브러리가 있습니다.</p>
<div class="footnote-definition" id="siphash"><sup class="footnote-definition-label">1</sup>
<p><a href="https://en.wikipedia.org/wiki/SipHash">https://en.wikipedia.org/wiki/SipHash</a></p>
</div>
<h2 id="요약-7"><a class="header" href="#요약-7">요약</a></h2>
<p>벡터, 문자열, 해시 맵은 데이터 저장, 접근, 수정이 필요한 프로그램에서 필수적인 방대한 기능을 제공할 것입니다. 이제 여러분은 다음 연습 문제들을 해결할 준비가 되었을 것입니다:</p>
<ol>
<li>정수 목록이 주어졌을 때, 벡터를 사용하여 목록의 중앙값(정렬되었을 때 중간 위치에 있는 값)과 최빈값(가장 자주 발생하는 값; 해시 맵이 도움이 될 것입니다)을 반환하세요.</li>
<li>문자열을 피그 라틴(Pig Latin)으로 변환하세요. 각 단어의 첫 자음은 단어 끝으로 이동하고 _ay_가 추가되므로, _first_는 _irst-fay_가 됩니다. 모음으로 시작하는 단어는 끝에 _hay_가 추가됩니다 (_apple_은 _apple-hay_가 됩니다). UTF-8 인코딩에 대한 세부 사항을 염두에 두세요!</li>
<li>해시 맵과 벡터를 사용하여 사용자가 회사 부서에 직원 이름을 추가할 수 있는 텍스트 인터페이스를 만드세요. 예를 들어 “Add Sally to Engineering” 또는 “Add Amir to Sales”와 같이 말이죠. 그런 다음 사용자가 부서의 모든 사람 목록이나 부서별로 회사의 모든 사람 목록을 알파벳순으로 정렬하여 조회할 수 있게 하세요.</li>
</ol>
<p>표준 라이브러리 API 문서는 이 연습 문제들에 도움이 될 벡터, 문자열, 해시 맵의 메서드들을 설명합니다!</p>
<p>작업이 실패할 수 있는 더 복잡한 프로그램으로 들어가고 있으므로, 에러 처리에 대해 논의하기에 완벽한 시기입니다. 다음으로 그 내용을 다루겠습니다!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="에러-처리"><a class="header" href="#에러-처리">에러 처리</a></h1>
<p>소프트웨어에서 에러는 피할 수 없는 현실이므로, 러스트는 무언가 잘못되는 상황을 처리하기 위한 여러 기능을 갖추고 있습니다. 많은 경우, 러스트는 코드를 컴파일하기 전에 에러 가능성을 인지하고 어떤 조치를 취하도록 요구합니다. 이 요구사항은 코드를 프로덕션에 배포하기 전에 에러를 발견하고 적절하게 처리하도록 보장함으로써 프로그램을 더 견고하게 만듭니다!</p>
<p>러스트는 에러를 크게 두 가지 범주로 분류합니다: <em>복구 가능한</em> 에러와 <em>복구 불가능한</em> 에러입니다. <em>파일을 찾을 수 없음</em> 에러와 같은 복구 가능한 에러의 경우, 대개 사용자에게 문제를 알리고 작업을 재시도하기를 원합니다. 복구 불가능한 에러는 배열 끝을 넘어선 위치에 접근하려고 하는 것과 같은 버그의 증상이며, 따라서 즉시 프로그램을 중지하기를 원합니다.</p>
<p>대부분의 언어는 이 두 종류의 에러를 구별하지 않고 예외와 같은 메커니즘을 사용하여 동일한 방식으로 처리합니다. 러스트에는 예외가 없습니다. 대신 복구 가능한 에러를 위한 <code>Result&lt;T, E&gt;</code> 타입과 프로그램이 복구 불가능한 에러를 만났을 때 실행을 중지하는 <code>panic!</code> 매크로가 있습니다. 이 장에서는 먼저 <code>panic!</code> 호출을 다루고 나서 <code>Result&lt;T, E&gt;</code> 값을 반환하는 것에 대해 이야기할 것입니다. 또한 에러로부터 복구를 시도할지 실행을 중지할지 결정할 때 고려해야 할 사항들을 탐구할 것입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="panic으로-복구-불가능한-에러-처리하기"><a class="header" href="#panic으로-복구-불가능한-에러-처리하기"><code>panic!</code>으로 복구 불가능한 에러 처리하기</a></h2>
<p>때로는 코드에서 나쁜 일이 발생하고, 그것에 대해 할 수 있는 일이 아무것도 없을 때가 있습니다. 이런 경우를 위해 러스트에는 <code>panic!</code> 매크로가 있습니다. 실제로 패닉을 일으키는 방법은 두 가지가 있습니다: 코드가 패닉을 일으키는 동작을 취하거나(배열 끝을 넘어 접근하는 등) 명시적으로 <code>panic!</code> 매크로를 호출하는 것입니다. 두 경우 모두 프로그램에서 패닉을 일으킵니다. 기본적으로 이러한 패닉은 실패 메시지를 출력하고, 되감고(unwind), 스택을 정리하고, 종료합니다. 환경 변수를 통해 패닉이 발생했을 때 호출 스택을 표시하게 하여 패닉의 원인을 더 쉽게 추적할 수도 있습니다.</p>
<blockquote>
<h3 id="패닉에-대한-응답으로-스택-되감기-또는-중단하기"><a class="header" href="#패닉에-대한-응답으로-스택-되감기-또는-중단하기">패닉에 대한 응답으로 스택 되감기 또는 중단하기</a></h3>
<p>기본적으로 패닉이 발생하면 프로그램은 <em>되감기(unwinding)</em> 를 시작합니다. 이는 러스트가 스택을 거슬러 올라가면서 만나는 각 함수에서 데이터를 정리한다는 의미입니다. 그러나 거슬러 올라가서 정리하는 것은 많은 작업입니다. 따라서 러스트는 즉시 <em>중단(aborting)</em> 하는 대안을 선택할 수 있도록 허용하며, 이는 정리 작업 없이 프로그램을 종료합니다.</p>
<p>결과 바이너리를 가능한 한 작게 만들어야 한다면, <em>Cargo.toml</em> 파일의 적절한 <code>[profile]</code> 섹션에 <code>panic = 'abort'</code>를 추가하여 패닉 시 되감기(unwinding) 대신 중단(aborting)으로 전환할 수 있습니다. 예를 들어 릴리스 모드에서 패닉 시 중단하려면 다음을 추가하세요:</p>
<pre><code class="language-toml">[profile.release]
panic = 'abort'
</code></pre>
</blockquote>
<p>간단한 프로그램에서 <code>panic!</code>을 호출해 봅시다:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust should_panic panics edition2021">fn main() {
    panic!("충돌 및 소실");
}</code></pre></pre>
</Listing>
<p>프로그램을 실행하면 다음과 같은 내용을 볼 수 있습니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.25s
     Running `target/debug/panic`
thread 'main' panicked at src/main.rs:2:5:
crash and burn
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p><code>panic!</code> 호출은 마지막 두 줄에 포함된 에러 메시지를 발생시킵니다. 첫 번째 줄은 패닉 메시지와 소스 코드에서 패닉이 발생한 위치를 보여줍니다. _src/main.rs:2:5_는 <em>src/main.rs</em> 파일의 두 번째 줄, 다섯 번째 문자를 나타냅니다.</p>
<p>이 경우, 표시된 줄은 우리 코드의 일부이며, 해당 줄로 가면 <code>panic!</code> 매크로 호출을 볼 수 있습니다. 다른 경우에는 <code>panic!</code> 호출이 우리 코드가 호출하는 코드에 있을 수 있으며, 에러 메시지에 보고된 파일 이름과 줄 번호는 결국 <code>panic!</code> 호출로 이어진 우리 코드의 줄이 아니라 <code>panic!</code> 매크로가 호출된 다른 사람의 코드일 수 있습니다.</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="using-a-panic-backtrace"></a></p>
<p><code>panic!</code> 호출이 발생한 함수의 백트레이스(backtrace)를 사용하여 문제의 원인이 되는 코드 부분을 파악할 수 있습니다. <code>panic!</code> 백트레이스를 사용하는 방법을 이해하기 위해, 다른 예제를 통해 우리 코드가 매크로를 직접 호출하는 대신 우리 코드의 버그로 인해 라이브러리에서 <code>panic!</code> 호출이 발생할 때 어떤 모습인지 살펴보겠습니다. 목록 9-1에는 유효한 인덱스 범위를 벗어난 벡터의 인덱스에 접근하려는 코드가 있습니다.</p>
<Listing number="9-1" file-name="src/main.rs" caption="Attempting to access an element beyond the end of a vector, which will cause a call to `panic!`">
<pre><pre class="playground"><code class="language-rust should_panic panics edition2021">fn main() {
    let v = vec![1, 2, 3];

    v[99];
}</code></pre></pre>
</Listing>
<p>여기서 우리는 벡터의 100번째 요소(인덱싱이 0부터 시작하므로 인덱스 99)에 접근하려고 시도하지만, 벡터에는 세 개의 요소만 있습니다. 이 상황에서 러스트는 패닉을 일으킬 것입니다. <code>[]</code>를 사용하면 요소를 반환해야 하지만, 유효하지 않은 인덱스를 전달하면 러스트가 여기서 올바르게 반환할 수 있는 요소가 없습니다.</p>
<p>C에서는 데이터 구조의 끝을 넘어 읽으려고 시도하는 것은 정의되지 않은 동작입니다. 메모리가 해당 구조에 속하지 않더라도 데이터 구조의 해당 요소에 해당하는 메모리 위치에 있는 것을 얻을 수 있습니다. 이를 <em>버퍼 오버리드(buffer overread)</em> 라고 하며, 공격자가 인덱스를 조작하여 데이터 구조 뒤에 저장된 허용되지 않는 데이터를 읽을 수 있게 되면 보안 취약점으로 이어질 수 있습니다.</p>
<p>존재하지 않는 인덱스의 요소를 읽으려고 시도하면 러스트는 실행을 중지하고 계속하기를 거부합니다. 한번 시도해 봅시다:</p>
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/panic`
thread 'main' panicked at src/main.rs:4:6:
index out of bounds: the len is 3 but the index is 99
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>이 에러는 우리가 <code>v</code> 벡터의 인덱스 <code>99</code>에 접근하려고 시도하는 _main.rs_의 4번째 줄을 가리킵니다.</p>
<p><code>note:</code> 줄은 <code>RUST_BACKTRACE</code> 환경 변수를 설정하여 에러를 일으킨 원인이 정확히 무엇인지에 대한 백트레이스를 얻을 수 있다고 알려줍니다. _백트레이스_는 이 지점에 도달하기 위해 호출된 모든 함수의 목록입니다. 러스트의 백트레이스는 다른 언어에서와 마찬가지로 작동합니다. 백트레이스를 읽는 핵심은 맨 위에서부터 시작하여 여러분이 작성한 파일을 볼 때까지 읽는 것입니다. 그 지점이 문제가 시작된 곳입니다. 그 지점 위의 줄은 여러분의 코드가 호출한 코드이고, 아래 줄은 여러분의 코드를 호출한 코드입니다. 이러한 전후 라인에는 핵심 러스트 코드, 표준 라이브러리 코드 또는 사용 중인 크레이트가 포함될 수 있습니다. <code>RUST_BACKTRACE</code> 환경 변수를 <code>0</code>이 아닌 값으로 설정하여 백트레이스를 얻어 봅시다. 목록 9-2는 여러분이 보게 될 것과 유사한 출력을 보여줍니다.</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/listing-09-01
RUST_BACKTRACE=1 cargo run
copy the backtrace output below
check the backtrace number mentioned in the text below the listing
-->
<Listing number="9-2" caption="The backtrace generated by a call to `panic!` displayed when the environment variable `RUST_BACKTRACE` is set">
<pre><code class="language-console">$ RUST_BACKTRACE=1 cargo run
thread 'main' panicked at src/main.rs:4:6:
index out of bounds: the len is 3 but the index is 99
stack backtrace:
   0: rust_begin_unwind
             at /rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14/library/std/src/panicking.rs:662:5
   1: core::panicking::panic_fmt
             at /rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14/library/core/src/panicking.rs:74:14
   2: core::panicking::panic_bounds_check
             at /rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14/library/core/src/panicking.rs:276:5
   3: &lt;usize as core::slice::index::SliceIndex&lt;[T]&gt;&gt;::index
             at /rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14/library/core/src/slice/index.rs:302:10
   4: core::slice::index::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index
             at /rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14/library/core/src/slice/index.rs:16:9
   5: &lt;alloc::vec::Vec&lt;T,A&gt; as core::ops::index::Index&lt;I&gt;&gt;::index
             at /rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14/library/alloc/src/vec/mod.rs:2920:9
   6: panic::main
             at ./src/main.rs:4:6
   7: core::ops::function::FnOnce::call_once
             at /rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14/library/core/src/ops/function.rs:250:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre>
</Listing>
<p>출력이 꽤 많군요! 여러분이 보는 정확한 출력은 운영 체제와 러스트 버전에 따라 다를 수 있습니다. 이 정보가 포함된 백트레이스를 얻으려면 디버그 심볼이 활성화되어 있어야 합니다. 여기서처럼 <code>--release</code> 플래그 없이 <code>cargo build</code> 또는 <code>cargo run</code>을 사용할 때는 디버그 심볼이 기본적으로 활성화됩니다.</p>
<p>목록 9-2의 출력에서 백트레이스의 6번째 줄은 문제를 일으키는 우리 프로젝트의 줄인 _src/main.rs_의 4번째 줄을 가리킵니다. 프로그램이 패닉을 일으키지 않게 하려면, 우리가 작성한 파일을 언급하는 첫 번째 줄이 가리키는 위치에서 조사를 시작해야 합니다. 목록 9-1에서 의도적으로 패닉을 일으킬 코드를 작성한 경우, 패닉을 해결하는 방법은 벡터 인덱스 범위를 벗어난 요소를 요청하지 않는 것입니다. 앞으로 코드가 패닉을 일으키면, 코드가 어떤 값으로 어떤 동작을 수행하여 패닉을 일으키는지, 그리고 대신 코드가 무엇을 해야 하는지 파악해야 할 것입니다.</p>
<p>이 장의 뒷부분에 있는 <a href="ch09-03-to-panic-or-not-to-panic.html#to-panic-or-not-to-panic">“<code>panic!</code>을 사용할 것인가 말 것인가”</a><!-- ignore --> 섹션에서 <code>panic!</code>과 에러 상황을 처리하기 위해 <code>panic!</code>을 사용해야 하는 경우와 사용하지 말아야 하는 경우에 대해 다시 다룰 것입니다. 다음으로 <code>Result</code>를 사용하여 에러로부터 복구하는 방법을 살펴보겠습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="result로-복구-가능한-에러-처리하기"><a class="header" href="#result로-복구-가능한-에러-처리하기"><code>Result</code>로 복구 가능한 에러 처리하기</a></h2>
<p>대부분의 에러는 프로그램이 완전히 멈춰야 할 정도로 심각하지 않습니다. 때로는 함수가 실패하는 이유를 쉽게 해석하고 대응할 수 있습니다. 예를 들어, 파일을 열려고 시도했는데 파일이 존재하지 않아 작업이 실패하면, 프로세스를 종료하는 대신 파일을 생성하고 싶을 수 있습니다.</p>
<p>2장의 <a href="ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-result">“<code>Result</code>로 잠재적 실패 처리하기”</a><!-- ignore -->에서 <code>Result</code> 열거형이 다음과 같이 <code>Ok</code>와 <code>Err</code>라는 두 가지 변형을 갖는 것으로 정의되었던 것을 상기해보세요.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p><code>T</code>와 <code>E</code>는 제네릭 타입 매개변수입니다. 제네릭에 대해서는 10장에서 더 자세히 논의할 것입니다. 지금 알아야 할 것은 <code>T</code>는 성공 시 <code>Ok</code> 변형 내에서 반환될 값의 타입을 나타내고, <code>E</code>는 실패 시 <code>Err</code> 변형 내에서 반환될 에러의 타입을 나타낸다는 것입니다. <code>Result</code>는 이러한 제네릭 타입 매개변수를 가지므로, 우리가 반환하고자 하는 성공 값과 에러 값이 다를 수 있는 다양한 상황에서 <code>Result</code> 타입과 그 위에 정의된 함수들을 사용할 수 있습니다.</p>
<p>함수가 실패할 수 있으므로 <code>Result</code> 값을 반환하는 함수를 호출해 봅시다. 목록 9-3에서 파일을 열려고 시도합니다.</p>
<Listing number="9-3" file-name="src/main.rs" caption="Opening a file">
<pre><pre class="playground"><code class="language-rust edition2021">use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");
}</code></pre></pre>
</Listing>
<p><code>File::open</code>의 반환 타입은 <code>Result&lt;T, E&gt;</code>입니다. 제네릭 매개변수 <code>T</code>는 <code>File::open</code>의 구현에 의해 성공 값의 타입인 <code>std::fs::File</code> (파일 핸들)로 채워졌습니다. 오류 값에 사용된 <code>E</code>의 타입은 <code>std::io::Error</code>입니다. 이 반환 타입은 <code>File::open</code> 호출이 성공하여 읽거나 쓸 수 있는 파일 핸들을 반환할 수도 있고, 실패할 수도 있음을 의미합니다. 예를 들어, 파일이 존재하지 않거나 파일에 접근할 권한이 없을 수 있습니다. <code>File::open</code> 함수는 성공했는지 실패했는지 알려주는 방법과 동시에 파일 핸들 또는 오류 정보를 제공해야 합니다. 이 정보가 바로 <code>Result</code> 열거형이 전달하는 내용입니다.</p>
<p><code>File::open</code>이 성공하는 경우, <code>greeting_file_result</code> 변수의 값은 파일 핸들을 포함하는 <code>Ok</code> 인스턴스가 될 것입니다. 실패하는 경우, <code>greeting_file_result</code>의 값은 발생한 오류 종류에 대한 더 많은 정보를 포함하는 <code>Err</code> 인스턴스가 될 것입니다.</p>
<p>목록 9-3의 코드에 <code>File::open</code>이 반환하는 값에 따라 다른 동작을 취하도록 추가해야 합니다. 목록 9-4는 6장에서 논의했던 기본 도구인 <code>match</code> 표현식을 사용하여 <code>Result</code>를 처리하는 한 가지 방법을 보여줍니다.</p>
<Listing number="9-4" file-name="src/main.rs" caption="Using a `match` expression to handle the `Result` variants that might be returned">
<pre><pre class="playground"><code class="language-rust should_panic edition2021">use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; panic!("파일을 여는 중 문제 발생: {error:?}"),
    };
}</code></pre></pre>
</Listing>
<p><code>Option</code> 열거형과 마찬가지로 <code>Result</code> 열거형과 그 변형들은 프렐류드에 의해 스코프로 가져와지므로, <code>match</code> 갈래에서 <code>Ok</code>와 <code>Err</code> 변형 앞에 <code>Result::</code>를 지정할 필요가 없습니다.</p>
<p>결과가 <code>Ok</code>이면, 이 코드는 <code>Ok</code> 변형에서 내부 <code>file</code> 값을 반환하고, 그 파일 핸들 값을 <code>greeting_file</code> 변수에 할당합니다. <code>match</code> 이후에는 읽거나 쓰기 위해 파일 핸들을 사용할 수 있습니다.</p>
<p><code>match</code>의 다른 갈래는 <code>File::open</code>에서 <code>Err</code> 값을 받는 경우를 처리합니다. 이 예제에서는 <code>panic!</code> 매크로를 호출하기로 했습니다. 현재 디렉토리에 _hello.txt_라는 파일이 없고 이 코드를 실행하면, <code>panic!</code> 매크로에서 다음과 같은 출력을 보게 될 것입니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/error-handling`
thread 'main' panicked at src/main.rs:8:23:
Problem opening the file: Os { code: 2, kind: NotFound, message: "No such file or directory" }
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>여느 때와 같이, 이 출력은 무엇이 잘못되었는지 정확히 알려줍니다.</p>
<h3 id="다른-에러에-매칭하기"><a class="header" href="#다른-에러에-매칭하기">다른 에러에 매칭하기</a></h3>
<p>The code in Listing 9-4 will <code>panic!</code> no matter why <code>File::open</code> failed. However, we want to take different actions for different failure reasons. If <code>File::open</code> failed because the file doesn’t exist, we want to create the file and return the handle to the new file. If <code>File::open</code> failed for any other reason—for example, because we didn’t have permission to open the file—we still want the code to <code>panic!</code> in the same way it did in Listing 9-4. For this, we add an inner <code>match</code> expression, shown in Listing 9-5.</p>
<Listing number="9-5" file-name="src/main.rs" caption="Handling different kinds of errors in different ways">
<!-- ignore this test because otherwise it creates hello.txt which causes other
tests to fail lol -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; match error.kind() {
            ErrorKind::NotFound =&gt; match File::create("hello.txt") {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!("파일 생성 중 문제 발생: {e:?}"),
            },
            other_error =&gt; {
                panic!("파일 여는 중 문제 발생: {other_error:?}");
            }
        },
    };
}</code></pre>
</Listing>
<p><code>File::open</code>이 <code>Err</code> 변형 내부에서 반환하는 값의 타입은 <code>io::Error</code>이며, 이는 표준 라이브러리에서 제공하는 구조체입니다. 이 구조체에는 <code>io::ErrorKind</code> 값을 얻기 위해 호출할 수 있는 <code>kind</code> 메서드가 있습니다. <code>io::ErrorKind</code> 열거형은 표준 라이브러리에서 제공하며 <code>io</code> 작업에서 발생할 수 있는 다양한 종류의 에러를 나타내는 변형들을 가지고 있습니다. 우리가 사용하고자 하는 변형은 <code>ErrorKind::NotFound</code>인데, 이는 우리가 열려고 하는 파일이 아직 존재하지 않음을 나타냅니다. 따라서 우리는 <code>greeting_file_result</code>에 대해 매칭하지만, <code>error.kind()</code>에 대한 내부 매칭도 가지고 있습니다.</p>
<p>내부 매칭에서 확인하려는 조건은 <code>error.kind()</code>가 반환한 값이 <code>ErrorKind</code> 열거형의 <code>NotFound</code> 변형인지 여부입니다. 만약 그렇다면, <code>File::create</code>로 파일 생성을 시도합니다. 하지만 <code>File::create</code>도 실패할 수 있으므로, 내부 <code>match</code> 표현식에 두 번째 갈래가 필요합니다. 파일이 생성될 수 없을 때, 다른 에러 메시지가 출력됩니다. 외부 <code>match</code>의 두 번째 갈래는 동일하게 유지되므로, 프로그램은 파일 없음 에러 이외의 모든 에러에 대해 패닉을 일으킵니다.</p>
<blockquote>
<h4 id="resultt-e와-함께-match를-사용하는-것에-대한-대안"><a class="header" href="#resultt-e와-함께-match를-사용하는-것에-대한-대안"><code>Result&lt;T, E&gt;</code>와 함께 <code>match</code>를 사용하는 것에 대한 대안</a></h4>
<p><code>match</code>가 정말 많네요! <code>match</code> 표현식은 매우 유용하지만 매우 원시적이기도 합니다. 13장에서는 <code>Result&lt;T, E&gt;</code>에 정의된 많은 메서드와 함께 사용되는 클로저에 대해 배울 것입니다. 이러한 메서드들은 코드에서 <code>Result&lt;T, E&gt;</code> 값을 처리할 때 <code>match</code>를 사용하는 것보다 더 간결할 수 있습니다.</p>
<p>예를 들어, 목록 9-5에 표시된 것과 동일한 로직을 작성하는 또 다른 방법이 있습니다. 이번에는 클로저와 <code>unwrap_or_else</code> 메서드를 사용합니다:</p>
<!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("파일 생성 중 문제 발생: {error:?}");
            })
        } else {
            panic!("파일을 여는 중 문제 발생: {error:?}");
        }
    });
}</code></pre>
<p>이 코드는 목록 9-5와 동일하게 동작하지만, <code>match</code> 표현식이 포함되어 있지 않아 읽기가 더 깔끔합니다. 13장을 읽은 후 이 예제로 돌아와서 표준 라이브러리 문서에서 <code>unwrap_or_else</code> 메서드를 찾아보세요. 에러를 다룰 때 거대한 중첩된 <code>match</code> 표현식을 정리할 수 있는 이러한 메서드가 훨씬 더 많이 있습니다.</p>
</blockquote>
<h4 id="에러-시-패닉을-위한-단축-unwrap과-expect"><a class="header" href="#에러-시-패닉을-위한-단축-unwrap과-expect">에러 시 패닉을 위한 단축: <code>unwrap</code>과 <code>expect</code></a></h4>
<p><code>match</code>를 사용하는 것은 충분히 잘 작동하지만, 다소 장황할 수 있고 항상 의도를 잘 전달하는 것은 아닙니다. <code>Result&lt;T, E&gt;</code> 타입에는 다양하고 더 구체적인 작업을 수행하기 위해 정의된 많은 도우미 메서드가 있습니다. <code>unwrap</code> 메서드는 우리가 목록 9-4에서 작성한 <code>match</code> 표현식과 똑같이 구현된 단축 메서드입니다. <code>Result</code> 값이 <code>Ok</code> 변형이면 <code>unwrap</code>은 <code>Ok</code> 내부의 값을 반환합니다. <code>Result</code>가 <code>Err</code> 변형이면 <code>unwrap</code>은 우리를 위해 <code>panic!</code> 매크로를 호출합니다. 다음은 작동 중인 <code>unwrap</code>의 예입니다:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust should_panic edition2021">use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap();
}</code></pre></pre>
</Listing>
<p><em>hello.txt</em> 파일 없이 이 코드를 실행하면, <code>unwrap</code> 메서드가 호출한 <code>panic!</code> 호출의 에러 메시지를 보게 될 것입니다:</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-04-unwrap
cargo run
copy and paste relevant text
-->
<pre><code class="language-text">thread 'main' panicked at src/main.rs:4:49:
called `Result::unwrap()` on an `Err` value: Os { code: 2, kind: NotFound, message: "No such file or directory" }
</code></pre>
<p>비슷하게, <code>expect</code> 메서드는 <code>panic!</code> 에러 메시지를 선택할 수 있게 해줍니다. <code>unwrap</code> 대신 <code>expect</code>를 사용하고 좋은 에러 메시지를 제공하면 의도를 전달하고 패닉의 원인을 추적하기가 더 쉬워집니다. <code>expect</code>의 문법은 다음과 같습니다:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust should_panic edition2021">use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")
        .expect("hello.txt는 이 프로젝트에 포함되어야 합니다");
}</code></pre></pre>
</Listing>
<p><code>expect</code>는 <code>unwrap</code>과 같은 방식으로 사용합니다. 즉, 파일 핸들을 반환하거나 <code>panic!</code> 매크로를 호출합니다. <code>expect</code>가 <code>panic!</code> 호출 시 사용하는 에러 메시지는 <code>unwrap</code>이 사용하는 기본 <code>panic!</code> 메시지 대신 <code>expect</code>에 전달하는 매개변수가 될 것입니다. 다음과 같이 보입니다:</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-05-expect
cargo run
copy and paste relevant text
-->
<pre><code class="language-text">thread 'main' panicked at src/main.rs:5:10:
hello.txt should be included in this project: Os { code: 2, kind: NotFound, message: "No such file or directory" }
</code></pre>
<p>프로덕션 품질의 코드에서 대부분의 러스트 사용자들은 <code>unwrap</code>보다는 <code>expect</code>를 선택하고, 왜 작업이 항상 성공할 것으로 예상되는지에 대한 더 많은 문맥을 제공합니다. 그렇게 하면 만약 가정이 틀렸음이 밝혀졌을 때, 디버깅에 사용할 수 있는 더 많은 정보를 갖게 됩니다.</p>
<h3 id="에러-전파하기"><a class="header" href="#에러-전파하기">에러 전파하기</a></h3>
<p>함수의 구현이 실패할 수 있는 무언가를 호출할 때, 함수 자체 내에서 에러를 처리하는 대신 호출하는 코드에 에러를 반환하여 호출하는 코드가 어떻게 할지 결정하게 할 수 있습니다. 이것은 에러를 <em>전파(propagating)</em> 하는 것으로 알려져 있으며, 호출하는 코드에 더 많은 제어권을 줍니다. 호출하는 코드에는 에러를 어떻게 처리해야 하는지 지시하는 정보나 로직이 여러분의 코드 컨텍스트에서 사용 가능한 것보다 더 많이 있을 수 있기 때문입니다.</p>
<p>예를 들어, 목록 9-6은 파일에서 사용자 이름을 읽는 함수를 보여줍니다. 파일이 존재하지 않거나 읽을 수 없는 경우, 이 함수는 해당 에러를 함수를 호출한 코드에 반환합니다.</p>
<Listing number="9-6" file-name="src/main.rs" caption="A function that returns errors to the calling code using `match`">
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let username_file_result = File::open("hello.txt");

    let mut username_file = match username_file_result {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&amp;mut username) {
        Ok(_) =&gt; Ok(username),
        Err(e) =&gt; Err(e),
    }
}
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 함수는 훨씬 더 짧은 방식으로 작성될 수 있지만, 에러 처리를 탐구하기 위해 많은 부분을 수동으로 수행하는 것으로 시작할 것입니다; 마지막에는 더 짧은 방법을 보여줄 것입니다. 먼저 함수의 반환 타입을 살펴봅시다: <code>Result&lt;String, io::Error&gt;</code>. 이는 함수가 <code>Result&lt;T, E&gt;</code> 타입의 값을 반환하고 있음을 의미하며, 여기서 제네릭 매개변수 <code>T</code>는 구체적인 타입 <code>String</code>으로 채워졌고 제네릭 타입 <code>E</code>는 구체적인 타입 <code>io::Error</code>로 채워졌습니다.</p>
<p>이 함수가 아무 문제 없이 성공하면, 이 함수를 호출하는 코드는 <code>Ok</code> 값을 받게 되는데, 여기에는 이 함수가 파일에서 읽은 <code>username</code>인 <code>String</code>이 들어 있습니다. 이 함수가 문제를 겪게 되면, 호출하는 코드는 <code>Err</code> 값을 받게 되는데, 여기에는 문제가 무엇이었는지에 대한 더 많은 정보를 담고 있는 <code>io::Error</code>의 인스턴스가 들어 있습니다. 우리는 이 함수의 반환 타입으로 <code>io::Error</code>를 선택했는데, 왜냐하면 이 함수 본문에서 호출하는 실패할 수 있는 두 작업, 즉 <code>File::open</code> 함수와 <code>read_to_string</code> 메서드 모두에서 반환되는 에러 값의 타입이 바로 그것이기 때문입니다.</p>
<p>함수의 본문은 <code>File::open</code> 함수를 호출하는 것으로 시작합니다. 그런 다음 목록 9-4의 <code>match</code>와 유사하게 <code>match</code>를 사용하여 <code>Result</code> 값을 처리합니다. <code>File::open</code>이 성공하면 패턴 변수 <code>file</code>의 파일 핸들이 가변 변수 <code>username_file</code>의 값이 되고 함수는 계속됩니다. <code>Err</code>의 경우, <code>panic!</code>을 호출하는 대신 <code>return</code> 키워드를 사용하여 함수 전체에서 조기에 반환하고, 이제 패턴 변수 <code>e</code>에 있는 <code>File::open</code>의 에러 값을 이 함수의 에러 값으로 호출 코드에 다시 전달합니다.</p>
<p>따라서 <code>username_file</code>에 파일 핸들이 있다면, 함수는 <code>username</code> 변수에 새 <code>String</code>을 생성하고 <code>username_file</code>의 파일 핸들에 <code>read_to_string</code> 메서드를 호출하여 파일 내용을 <code>username</code>으로 읽어들입니다. <code>read_to_string</code> 메서드 또한 <code>Result</code>를 반환하는데, <code>File::open</code>이 성공했더라도 실패할 수 있기 때문입니다. 따라서 그 <code>Result</code>를 처리하기 위해 또 다른 <code>match</code>가 필요합니다: <code>read_to_string</code>이 성공하면 우리 함수도 성공한 것이므로, 이제 <code>username</code>에 있는 파일의 사용자 이름을 <code>Ok</code>로 감싸서 반환합니다. <code>read_to_string</code>이 실패하면, <code>File::open</code>의 반환 값을 처리한 <code>match</code>에서 에러 값을 반환했던 것과 같은 방식으로 에러 값을 반환합니다. 하지만 이것이 함수의 마지막 표현식이므로 명시적으로 <code>return</code>이라고 말할 필요는 없습니다.</p>
<p>이 코드를 호출하는 코드는 사용자 이름을 포함하는 <code>Ok</code> 값이나 <code>io::Error</code>를 포함하는 <code>Err</code> 값 중 하나를 받아서 처리하게 됩니다. 이 값들로 무엇을 할지는 호출하는 코드가 결정합니다. 호출하는 코드가 <code>Err</code> 값을 받으면 <code>panic!</code>을 호출하여 프로그램을 중단시키거나, 기본 사용자 이름을 사용하거나, 파일이 아닌 다른 곳에서 사용자 이름을 조회하는 등의 작업을 할 수 있습니다. 호출하는 코드가 실제로 무엇을 하려는지에 대한 정보가 충분하지 않으므로, 우리는 모든 성공 또는 에러 정보를 위로 전파하여 적절하게 처리하도록 합니다.</p>
<p>에러를 전파하는 이 패턴은 러스트에서 매우 흔하므로, 러스트는 이를 더 쉽게 만들기 위해 물음표 연산자 <code>?</code>를 제공합니다.</p>
<h4 id="에러-전파를-위한-단축--연산자"><a class="header" href="#에러-전파를-위한-단축--연산자">에러 전파를 위한 단축: <code>?</code> 연산자</a></h4>
<p>목록 9-7은 목록 9-6과 동일한 기능을 가지지만 <code>?</code> 연산자를 사용하는 <code>read_username_from_file</code>의 구현을 보여줍니다.</p>
<Listing number="9-7" file-name="src/main.rs" caption="A function that returns errors to the calling code using the `?` operator">
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username_file = File::open("hello.txt")?;
    let mut username = String::new();
    username_file.read_to_string(&amp;mut username)?;
    Ok(username)
}
<span class="boring">}</span></code></pre></pre>
</Listing>
<p><code>Result</code> 값 뒤에 배치된 <code>?</code>는 목록 9-6에서 <code>Result</code> 값을 처리하기 위해 정의한 <code>match</code> 표현식과 거의 같은 방식으로 작동하도록 정의되어 있습니다. <code>Result</code>의 값이 <code>Ok</code>이면 <code>Ok</code> 내부의 값이 이 표현식에서 반환되고 프로그램이 계속됩니다. 값이 <code>Err</code>이면 <code>return</code> 키워드를 사용한 것처럼 <code>Err</code>가 전체 함수에서 반환되어 에러 값이 호출하는 코드로 전파됩니다.</p>
<p>목록 9-6의 <code>match</code> 표현식과 <code>?</code> 연산자가 하는 일에는 차이가 있습니다: <code>?</code> 연산자가 호출된 에러 값들은 표준 라이브러리의 <code>From</code> 트레이트에 정의된 <code>from</code> 함수를 거치게 되는데, 이 함수는 한 타입의 값을 다른 타입으로 변환하는 데 사용됩니다. <code>?</code> 연산자가 <code>from</code> 함수를 호출할 때, 받은 에러 타입은 현재 함수의 반환 타입에 정의된 에러 타입으로 변환됩니다. 이는 함수의 일부분이 여러 다른 이유로 실패할 수 있더라도, 함수가 실패할 수 있는 모든 방법을 나타내는 하나의 에러 타입을 반환할 때 유용합니다.</p>
<p>예를 들어, 목록 9-7의 <code>read_username_from_file</code> 함수를 변경하여 우리가 정의한 <code>OurError</code>라는 사용자 정의 에러 타입을 반환하게 할 수 있습니다. 만약 <code>io::Error</code>로부터 <code>OurError</code>의 인스턴스를 생성하는 <code>impl From&lt;io::Error&gt; for OurError</code>도 정의한다면, <code>read_username_from_file</code> 본문의 <code>?</code> 연산자 호출은 <code>from</code>을 호출하여 함수에 더 이상 코드를 추가할 필요 없이 에러 타입을 변환할 것입니다.</p>
<p>목록 9-7의 문맥에서 <code>File::open</code> 호출 끝에 있는 <code>?</code>는 <code>Ok</code> 내부의 값을 <code>username_file</code> 변수에 반환할 것입니다. 에러가 발생하면 <code>?</code> 연산자는 전체 함수에서 일찍 반환하고 호출하는 코드에 <code>Err</code> 값을 줄 것입니다. <code>read_to_string</code> 호출 끝에 있는 <code>?</code>에도 동일한 내용이 적용됩니다.</p>
<p><code>?</code> 연산자는 많은 상용구(boilerplate)를 제거하고 이 함수의 구현을 더 간단하게 만듭니다. 목록 9-8에 나와 있듯이 <code>?</code> 바로 뒤에 메서드 호출을 연결하여 이 코드를 더 줄일 수도 있습니다.</p>
<Listing number="9-8" file-name="src/main.rs" caption="Chaining method calls after the `?` operator">
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username = String::new();

    File::open("hello.txt")?.read_to_string(&amp;mut username)?;

    Ok(username)
}
<span class="boring">}</span></code></pre></pre>
</Listing>
<p><code>File::open("hello.txt")?</code>의 결과에 <code>read_to_string</code> 호출을 직접 연결했습니다. <code>read_to_string</code> 호출 끝에 여전히 <code>?</code>가 있고, <code>File::open</code>과 <code>read_to_string</code>이 모두 성공했을 때 에러를 반환하는 대신 <code>username</code>을 포함하는 <code>Ok</code> 값을 여전히 반환합니다. 기능은 목록 9-6 및 목록 9-7과 동일합니다. 단지 작성하는 방식이 다르고 더 인체공학적일 뿐입니다.</p>
<p>목록 9-9는 <code>fs::read_to_string</code>을 사용하여 이를 더 짧게 만드는 방법을 보여줍니다.</p>
<Listing number="9-9" file-name="src/main.rs" caption="Using `fs::read_to_string` instead of opening and then reading the file">
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::io;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    fs::read_to_string("hello.txt")
}
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>파일을 문자열로 읽는 것은 꽤 일반적인 작업이므로, 표준 라이브러리는 파일을 열고, 새 <code>String</code>을 생성하고, 파일 내용을 읽고, 내용을 그 <code>String</code>에 넣고, 반환하는 편리한 <code>fs::read_to_string</code> 함수를 제공합니다. 물론 <code>fs::read_to_string</code>을 사용하면 모든 에러 처리를 설명할 기회가 없었기 때문에 먼저 더 긴 방법으로 했습니다.</p>
<h4 id="-연산자를-사용할-수-있는-곳"><a class="header" href="#-연산자를-사용할-수-있는-곳"><code>?</code> 연산자를 사용할 수 있는 곳</a></h4>
<p><code>?</code> 연산자는 <code>?</code>가 사용된 값과 호환되는 반환 타입을 가진 함수에서만 사용할 수 있습니다. 이는 <code>?</code> 연산자가 목록 9-6에서 정의한 <code>match</code> 표현식과 같은 방식으로 함수에서 값을 일찍 반환하도록 정의되어 있기 때문입니다. 목록 9-6에서 <code>match</code>는 <code>Result</code> 값을 사용하고 있었고, 조기 반환 갈래는 <code>Err(e)</code> 값을 반환했습니다. 함수의 반환 타입은 이 <code>return</code>과 호환되도록 <code>Result</code>여야 합니다.</p>
<p>목록 9-10에서, <code>?</code>를 사용하는 값의 타입과 호환되지 않는 반환 타입을 가진 <code>main</code> 함수에서 <code>?</code> 연산자를 사용하면 어떤 에러가 발생하는지 살펴봅시다.</p>
<Listing number="9-10" file-name="src/main.rs" caption="Attempting to use the `?` in the `main` function that returns `()` won’t compile.">
<pre><code class="language-rust ignore does_not_compile">use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")?;
}</code></pre>
</Listing>
<p>이 코드는 파일을 여는데, 실패할 수 있습니다. <code>?</code> 연산자는 <code>File::open</code>이 반환한 <code>Result</code> 값을 따르지만, 이 <code>main</code> 함수는 <code>Result</code>가 아닌 <code>()</code> 반환 타입을 가집니다. 이 코드를 컴파일하면 다음과 같은 에러 메시지를 얻습니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
 --&gt; src/main.rs:4:48
  |
3 | fn main() {
  | --------- this function should return `Result` or `Option` to accept `?`
4 |     let greeting_file = File::open("hello.txt")?;
  |                                                ^ cannot use the `?` operator in a function that returns `()`
  |
  = help: the trait `FromResidual&lt;Result&lt;Infallible, std::io::Error&gt;&gt;` is not implemented for `()`
help: consider adding return type
  |
3 ~ fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
4 |     let greeting_file = File::open("hello.txt")?;
5 +     Ok(())
  |

For more information about this error, try `rustc --explain E0277`.
error: could not compile `error-handling` (bin "error-handling") due to 1 previous error
</code></pre>
<p>이 에러는 우리가 <code>Result</code>, <code>Option</code>, 또는 <code>FromResidual</code>을 구현하는 다른 타입을 반환하는 함수에서만 <code>?</code> 연산자를 사용할 수 있다고 지적합니다.</p>
<p>에러를 수정하려면 두 가지 선택지가 있습니다. 하나는 함수가 이를 막는 제한이 없는 한, <code>?</code> 연산자를 사용하는 값과 호환되도록 함수의 반환 타입을 변경하는 것입니다. 다른 하나는 <code>match</code>나 <code>Result&lt;T, E&gt;</code> 메서드 중 하나를 사용하여 적절한 방식으로 <code>Result&lt;T, E&gt;</code>를 처리하는 것입니다.</p>
<p>에러 메시지에는 <code>?</code>를 <code>Option&lt;T&gt;</code> 값에도 사용할 수 있다고 언급되었습니다. <code>Result</code>에 <code>?</code>를 사용하는 것과 마찬가지로, <code>Option</code>을 반환하는 함수에서만 <code>Option</code>에 <code>?</code>를 사용할 수 있습니다. <code>Option&lt;T&gt;</code>에서 호출될 때 <code>?</code> 연산자의 동작은 <code>Result&lt;T, E&gt;</code>에서 호출될 때의 동작과 유사합니다. 값이 <code>None</code>이면 <code>None</code>이 그 시점에서 함수로부터 조기에 반환됩니다. 값이 <code>Some</code>이면 <code>Some</code> 내부의 값이 표현식의 결과 값이 되고 함수는 계속됩니다. 목록 9-11에는 주어진 텍스트의 첫 번째 줄의 마지막 문자를 찾는 함수 예제가 있습니다.</p>
<Listing number="9-11" caption="Using the `?` operator on an `Option<T>` value">
<pre><pre class="playground"><code class="language-rust edition2021">fn last_char_of_first_line(text: &amp;str) -&gt; Option&lt;char&gt; {
    text.lines().next()?.chars().last()
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(
</span><span class="boring">        last_char_of_first_line("Hello, world\n오늘 기분 어떠세요?"),
</span><span class="boring">        Some(에러가 발생하면, `?` 연산자는 `from` 함수를 사용하여 받은 에러 타입을 현재 함수의 반환 타입에 정의된 에러 타입으로 변환합니다. 이는 함수가 여러 부분에서 다른 이유로 실패할 수 있더라도 모든 실패 이유를 나타내는 하나의 에러 타입을 반환할 때 유용합니다.)
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    assert_eq!(last_char_of_first_line(""), None);
</span><span class="boring">    assert_eq!(last_char_of_first_line("\nhi"), None);
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 함수는 <code>Option&lt;char&gt;</code>를 반환합니다. 문자가 있을 수도 있지만 없을 수도 있기 때문입니다. 이 코드는 <code>text</code> 문자열 슬라이스 인수를 받아 <code>lines</code> 메서드를 호출하는데, 이 메서드는 문자열의 줄에 대한 반복자를 반환합니다. 이 함수는 첫 번째 줄을 검사하고 싶어하므로 반복자에서 <code>next</code>를 호출하여 첫 번째 값을 가져옵니다. <code>text</code>가 빈 문자열이면 <code>next</code> 호출은 <code>None</code>을 반환할 것이고, 이 경우 우리는 <code>?</code>를 사용하여 멈추고 <code>last_char_of_first_line</code>에서 <code>None</code>을 반환합니다. <code>text</code>가 빈 문자열이 아니라면 <code>next</code>는 <code>text</code>의 첫 번째 줄의 문자열 슬라이스를 포함하는 <code>Some</code> 값을 반환할 것입니다.</p>
<p><code>?</code>는 문자열 슬라이스를 추출하고, 우리는 그 문자열 슬라이스에 <code>chars</code>를 호출하여 문자들의 반복자를 얻을 수 있습니다. 우리는 이 첫 번째 줄의 마지막 문자에 관심이 있으므로 <code>last</code>를 호출하여 반복자의 마지막 항목을 반환합니다. 이것은 <code>Option</code>인데, <code>"\nhi"</code>처럼 <code>text</code>가 빈 줄로 시작하지만 다른 줄에 문자가 있는 경우와 같이 첫 번째 줄이 빈 문자열일 가능성이 있기 때문입니다. 그러나 첫 번째 줄에 마지막 문자가 있다면 <code>Some</code> 변형으로 반환될 것입니다. 중간에 있는 <code>?</code> 연산자는 이 로직을 표현하는 간결한 방법을 제공하여 함수를 한 줄로 구현할 수 있게 해줍니다. <code>Option</code>에 <code>?</code> 연산자를 사용할 수 없었다면, 더 많은 메서드 호출이나 <code>match</code> 표현식을 사용하여 이 로직을 구현해야 했을 것입니다.</p>
<p><code>Result</code>를 반환하는 함수에서는 <code>Result</code>에 <code>?</code> 연산자를 사용할 수 있고, <code>Option</code>을 반환하는 함수에서는 <code>Option</code>에 <code>?</code> 연산자를 사용할 수 있지만, 섞어서 사용할 수는 없다는 점에 유의하세요. <code>?</code> 연산자는 자동으로 <code>Result</code>를 <code>Option</code>으로 또는 그 반대로 변환하지 않습니다. 그런 경우에는 <code>Result</code>의 <code>ok</code> 메서드나 <code>Option</code>의 <code>ok_or</code> 메서드와 같은 메서드를 사용하여 명시적으로 변환할 수 있습니다.</p>
<p>지금까지 사용한 모든 <code>main</code> 함수는 <code>()</code>를 반환했습니다. <code>main</code> 함수는 실행 가능한 프로그램의 진입점이자 종료점이기 때문에 특별하며, 프로그램이 예상대로 동작하기 위해 반환 타입이 될 수 있는 것에 제한이 있습니다.</p>
<p>다행히 <code>main</code>은 <code>Result&lt;(), E&gt;</code>도 반환할 수 있습니다. 목록 9-12는 목록 9-10의 코드를 가지고 있지만, <code>main</code>의 반환 타입을 <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>로 변경하고 끝에 반환 값 <code>Ok(())</code>를 추가했습니다. 이 코드는 이제 컴파일될 것입니다.</p>
<Listing number="9-12" file-name="src/main.rs" caption="Changing `main` to return `Result<(), E>` allows the use of the `?` operator on `Result` values.">
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs::File;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let greeting_file = File::open("hello.txt")?;

    Ok(())
}</code></pre>
</Listing>
<p><code>Box&lt;dyn Error&gt;</code> 타입은 _트레이트 객체_이며, 이에 대해서는 18장의 <a href="ch18-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">“다른 타입의 값을 허용하는 트레이트 객체 사용하기”</a><!-- ignore -->에서 이야기할 것입니다. 지금은 <code>Box&lt;dyn Error&gt;</code>를 “어떤 종류의 에러”라고 읽으시면 됩니다. 에러 타입이 <code>Box&lt;dyn Error&gt;</code>인 <code>main</code> 함수에서 <code>Result</code> 값에 <code>?</code>를 사용하는 것은 허용되는데, 이는 어떤 <code>Err</code> 값이라도 조기 반환할 수 있게 해주기 때문입니다. 이 <code>main</code> 함수의 본문은 <code>std::io::Error</code> 타입의 에러만 반환하겠지만, <code>Box&lt;dyn Error&gt;</code>를 지정함으로써 <code>main</code> 본문에 다른 에러를 반환하는 코드가 추가되더라도 이 시그니처는 계속 올바를 것입니다.</p>
<p><code>main</code> 함수가 <code>Result&lt;(), E&gt;</code>를 반환할 때, 실행 파일은 <code>main</code>이 <code>Ok(())</code>를 반환하면 값 <code>0</code>으로 종료하고 <code>main</code>이 <code>Err</code> 값을 반환하면 0이 아닌 값으로 종료할 것입니다. C로 작성된 실행 파일은 종료할 때 정수를 반환합니다: 성공적으로 종료하는 프로그램은 정수 <code>0</code>을 반환하고, 에러가 발생한 프로그램은 <code>0</code>이 아닌 어떤 정수를 반환합니다. 러스트 또한 이 관례와 호환되기 위해 실행 파일에서 정수를 반환합니다.</p>
<p>자신의 타입에 <code>Termination</code> 트레이트를 구현하는 것에 대한 자세한 내용은 표준 라이브러리 문서를 참조하세요.</p>
<p>이제 <code>panic!</code>을 호출하거나 <code>Result</code>를 반환하는 것의 세부 사항에 대해 논의했으므로, 어떤 경우에 어떤 것을 사용하는 것이 적절한지 결정하는 주제로 돌아가 보겠습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="panic을-사용할지-말지"><a class="header" href="#panic을-사용할지-말지"><code>panic!</code>을 사용할지 말지</a></h2>
<p>그렇다면 언제 <code>panic!</code>을 호출하고 언제 <code>Result</code>를 반환해야 할지 어떻게 결정할까요? 코드가 패닉을 일으키면 복구할 방법이 없습니다. 복구할 방법이 있든 없든 모든 에러 상황에 대해 <code>panic!</code>을 호출할 수 있지만, 그렇게 하면 호출하는 코드를 대신하여 상황이 복구 불가능하다고 결정하는 것입니다. <code>Result</code> 값을 반환하기로 선택하면 호출하는 코드에 선택권을 줍니다. 호출하는 코드는 상황에 맞는 방식으로 복구를 시도할 수도 있고, 이 경우의 <code>Err</code> 값이 복구 불가능하다고 판단하여 <code>panic!</code>을 호출하고 복구 가능한 에러를 복구 불가능한 에러로 바꿀 수도 있습니다. 따라서 실패할 수 있는 함수를 정의할 때는 <code>Result</code>를 반환하는 것이 좋은 기본 선택입니다.</p>
<p>예제, 프로토타입 코드, 테스트와 같은 상황에서는 <code>Result</code>를 반환하는 대신 패닉을 일으키는 코드를 작성하는 것이 더 적절합니다. 그 이유를 알아보고, 컴파일러는 실패가 불가능하다는 것을 알 수 없지만 사람은 알 수 있는 상황에 대해 논의해 보겠습니다. 이 장은 라이브러리 코드에서 패닉을 일으킬지 여부를 결정하는 방법에 대한 몇 가지 일반적인 지침으로 마무리할 것입니다.</p>
<h3 id="예제-프로토타입-코드-그리고-테스트"><a class="header" href="#예제-프로토타입-코드-그리고-테스트">예제, 프로토타입 코드, 그리고 테스트</a></h3>
<p>어떤 개념을 설명하기 위해 예제를 작성할 때, 견고한 에러 처리 코드까지 포함하면 예제가 덜 명확해질 수 있습니다. 예제에서 패닉을 일으킬 수 있는 <code>unwrap</code> 같은 메서드를 호출하는 것은 여러분이 애플리케이션에서 에러를 처리하고자 하는 방식에 대한 자리 표시자로 이해되며, 이는 나머지 코드가 수행하는 작업에 따라 달라질 수 있습니다.</p>
<p>마찬가지로, <code>unwrap</code>과 <code>expect</code> 메서드는 에러 처리 방법을 결정하기 전인 프로토타이핑 단계에서 매우 편리합니다. 이것들은 나중에 프로그램을 더 견고하게 만들 준비가 되었을 때를 위해 코드에 명확한 표시를 남깁니다.</p>
<p>테스트에서 메서드 호출이 실패하면, 해당 메서드가 테스트 대상 기능이 아니더라도 전체 테스트가 실패하기를 원할 것입니다. <code>panic!</code>은 테스트가 실패로 표시되는 방식이므로, <code>unwrap</code>이나 <code>expect</code>를 호출하는 것이 정확히 일어나야 할 일입니다.</p>
<h3 id="컴파일러보다-여러분이-더-많은-정보를-가지고-있는-경우"><a class="header" href="#컴파일러보다-여러분이-더-많은-정보를-가지고-있는-경우">컴파일러보다 여러분이 더 많은 정보를 가지고 있는 경우</a></h3>
<p><code>Result</code>가 <code>Ok</code> 값을 가질 것임을 보장하는 다른 로직이 있지만, 컴파일러가 그 로직을 이해하지 못할 때 <code>unwrap</code>이나 <code>expect</code>를 호출하는 것도 적절할 것입니다. 여러분은 여전히 처리해야 할 <code>Result</code> 값을 가지고 있습니다: 여러분이 호출하는 작업은 여러분의 특정 상황에서는 논리적으로 불가능하더라도 일반적으로는 여전히 실패할 가능성이 있습니다. 코드를 직접 검사하여 <code>Err</code> 변형이 절대 발생하지 않을 것임을 확신할 수 있다면 <code>unwrap</code>을 호출하는 것은 전적으로 허용되며, <code>expect</code> 텍스트에 <code>Err</code> 변형이 절대 발생하지 않을 것이라고 생각하는 이유를 문서화하는 것이 더 좋습니다. 여기 예제가 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    use std::net::IpAddr;

    let home: IpAddr = "127.0.0.1"
        .parse()
        .expect("하드코딩된 IP 주소는 유효해야 합니다");
<span class="boring">}</span></code></pre></pre>
<p>우리는 하드코딩된 문자열을 파싱하여 <code>IpAddr</code> 인스턴스를 생성하고 있습니다. <code>127.0.0.1</code>이 유효한 IP 주소라는 것을 알 수 있으므로, 여기서 <code>expect</code>를 사용하는 것은 허용됩니다. 하지만 하드코딩된 유효한 문자열이 있다고 해서 <code>parse</code> 메서드의 반환 타입이 바뀌지는 않습니다: 우리는 여전히 <code>Result</code> 값을 얻고, 컴파일러는 이 문자열이 항상 유효한 IP 주소라는 것을 알 만큼 똑똑하지 않기 때문에 여전히 <code>Err</code> 변형이 가능한 것처럼 <code>Result</code>를 처리하게 할 것입니다. 만약 IP 주소 문자열이 프로그램에 하드코딩된 것이 아니라 사용자로부터 입력받은 것이어서 실패할 가능성이 <em>있다면</em>, 우리는 분명히 <code>Result</code>를 더 견고한 방식으로 처리하고 싶을 것입니다. 이 IP 주소가 하드코딩되었다는 가정을 언급하면, 나중에 다른 소스에서 IP 주소를 가져와야 할 경우 <code>expect</code>를 더 나은 에러 처리 코드로 변경하도록 유도할 것입니다.</p>
<h3 id="에러-처리-가이드라인"><a class="header" href="#에러-처리-가이드라인">에러 처리 가이드라인</a></h3>
<p>코드가 나쁜 상태에 빠질 수 있을 때 코드가 패닉을 일으키도록 하는 것이 좋습니다. 이 문맥에서 _나쁜 상태_란 유효하지 않은 값, 모순되는 값, 또는 누락된 값이 코드에 전달되는 것과 같이 일부 가정, 보장, 계약 또는 불변성이 깨진 경우를 말하며, 여기에 더해 다음 중 하나 이상에 해당할 때입니다:</p>
<ul>
<li>나쁜 상태는 사용자가 잘못된 형식의 데이터를 입력하는 것처럼 가끔 일어날 가능성이 있는 것이 아니라 예상치 못한 것입니다.</li>
<li>이 시점 이후의 코드는 매 단계마다 문제를 확인하는 대신 이 나쁜 상태에 있지 않다는 점에 의존해야 합니다.</li>
<li>사용하는 타입에 이 정보를 인코딩할 좋은 방법이 없습니다. 18장의 <a href="ch18-03-oo-design-patterns.html#encoding-states-and-behavior-as-types">“상태와 동작을 타입으로 인코딩하기”</a><!-- ignore -->에서 이것이 무슨 뜻인지 예제를 통해 살펴볼 것입니다.</li>
</ul>
<p>누군가 여러분의 코드를 호출하고 말이 안 되는 값을 전달한다면, 가능하다면 에러를 반환하여 라이브러리 사용자가 그 경우에 무엇을 할지 결정할 수 있게 하는 것이 가장 좋습니다. 그러나 계속 진행하는 것이 안전하지 않거나 해로울 수 있는 경우, 가장 좋은 선택은 <code>panic!</code>을 호출하여 라이브러리를 사용하는 사람에게 코드의 버그를 알리고 개발 중에 수정할 수 있게 하는 것일 수 있습니다. 마찬가지로, 통제할 수 없는 외부 코드를 호출했는데 해결할 방법이 없는 유효하지 않은 상태를 반환하는 경우에도 <code>panic!</code>이 적절한 경우가 많습니다.</p>
<p>하지만 실패가 예상될 때는 <code>panic!</code> 호출보다는 <code>Result</code>를 반환하는 것이 더 적절합니다. 파서에 잘못된 형식의 데이터가 주어지거나 HTTP 요청이 속도 제한에 도달했음을 나타내는 상태를 반환하는 경우를 예로 들 수 있습니다. 이러한 경우 <code>Result</code>를 반환하는 것은 실패가 예상되는 가능성이며 호출하는 코드가 이를 처리하는 방법을 결정해야 함을 나타냅니다.</p>
<p>유효하지 않은 값을 사용하여 호출될 경우 사용자를 위험에 빠뜨릴 수 있는 작업을 코드가 수행할 때, 코드는 먼저 값이 유효한지 확인하고 유효하지 않으면 패닉을 일으켜야 합니다. 이는 주로 안전상의 이유 때문입니다: 유효하지 않은 데이터에 대한 작업 시도는 코드를 취약점에 노출시킬 수 있습니다. 이것이 범위를 벗어난 메모리 접근을 시도할 때 표준 라이브러리가 <code>panic!</code>을 호출하는 주된 이유입니다: 현재 데이터 구조에 속하지 않는 메모리에 접근하려고 하는 것은 일반적인 보안 문제입니다. 함수는 종종 _계약_을 가집니다: 입력이 특정 요구사항을 충족할 때만 동작이 보장됩니다. 계약이 위반되었을 때 패닉을 일으키는 것은 타당한데, 계약 위반은 항상 호출자 측 버그를 나타내며, 호출하는 코드가 명시적으로 처리해야 하는 종류의 에러가 아니기 때문입니다. 사실, 호출하는 코드가 복구할 수 있는 합리적인 방법은 없습니다; 호출하는 _프로그래머_가 코드를 수정해야 합니다. 함수에 대한 계약, 특히 위반 시 패닉을 유발하는 계약은 함수의 API 문서에 설명되어야 합니다.</p>
<p>하지만 모든 함수에 많은 오류 검사를 넣는 것은 장황하고 번거로울 것입니다. 다행히 러스트의 타입 시스템(따라서 컴파일러가 수행하는 타입 검사)을 사용하여 많은 검사를 대신 수행할 수 있습니다. 함수가 특정 타입을 매개변수로 가진다면, 컴파일러가 이미 유효한 값을 가지고 있음을 보장했으므로 코드의 로직을 진행할 수 있습니다. 예를 들어, <code>Option</code> 대신 타입을 가지고 있다면, 프로그램은 _아무것도 없음_이 아니라 _무언가_를 가질 것으로 예상합니다. 그러면 코드는 <code>Some</code>과 <code>None</code> variant에 대해 두 가지 경우를 처리할 필요가 없습니다. 확실히 값을 가지는 한 가지 경우만 처리하면 됩니다. 함수에 아무것도 전달하지 않으려는 코드는 컴파일조차 되지 않으므로, 함수는 런타임에 해당 경우를 확인할 필요가 없습니다. 또 다른 예는 매개변수가 절대 음수가 아님을 보장하는 <code>u32</code>와 같은 부호 없는 정수 타입을 사용하는 것입니다.</p>
<h3 id="유효성-검사를-위한-사용자-정의-타입-생성하기"><a class="header" href="#유효성-검사를-위한-사용자-정의-타입-생성하기">유효성 검사를 위한 사용자 정의 타입 생성하기</a></h3>
<p>러스트의 타입 시스템을 사용하여 유효한 값을 보장하는 아이디어를 한 단계 더 나아가 유효성 검사를 위한 사용자 정의 타입을 생성하는 방법을 살펴보겠습니다. 2장의 추측 게임에서 우리 코드가 사용자에게 1에서 100 사이의 숫자를 추측하도록 요청했던 것을 기억하세요. 우리는 사용자의 추측이 비밀 숫자와 비교하기 전에 해당 숫자들 사이에 있는지 유효성 검사를 하지 않았습니다. 단지 추측이 양수인지 여부만 유효성 검사했습니다. 이 경우 결과는 그리 심각하지 않았습니다. "너무 높음" 또는 "너무 낮음"이라는 출력은 여전히 올바를 것입니다. 하지만 사용자가 유효한 추측을 하도록 안내하고, 사용자가 범위를 벗어난 숫자를 추측하거나 예를 들어 문자를 입력할 때 다른 동작을 하도록 하는 유용한 개선 사항이 될 것입니다.</p>
<p>이를 수행하는 한 가지 방법은 추측을 <code>u32</code> 대신 <code>i32</code>로 파싱하여 잠재적으로 음수를 허용하고, 그런 다음 다음과 같이 숫자가 범위 내에 있는지 확인하는 검사를 추가하는 것입니다:</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    loop {
        // --생략--

<span class="boring">        println!(추측을 입력하세요.);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("줄 읽기 실패");
</span><span class="boring">
</span>        let guess: i32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        if guess &lt; 1 || guess &gt; 100 {
            println!("비밀 숫자는 1에서 100 사이입니다.");
            continue;
        }

        match guess.cmp(&amp;secret_number) {
            // --생략--
<span class="boring">            Ordering::Less =&gt; println!("너무 작아요!"),
</span><span class="boring">            Ordering::Greater =&gt; println!("너무 커요!"),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!("당신이 이겼습니다!");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span>    }
<span class="boring">}</span></code></pre>
</Listing>
<p><code>if</code> 표현식은 값이 범위를 벗어났는지 확인하고, 사용자에게 문제를 알리고, <code>continue</code>를 호출하여 루프의 다음 반복을 시작하고 다른 추측을 요청합니다. <code>if</code> 표현식 이후에는 <code>guess</code>가 1에서 100 사이임을 알고 <code>guess</code>와 비밀 숫자 간의 비교를 진행할 수 있습니다.</p>
<p>하지만 이것은 이상적인 해결책이 아닙니다. 만약 프로그램이 1에서 100 사이의 값으로만 작동하는 것이 절대적으로 중요하고, 이러한 요구 사항을 가진 함수가 많다면, 모든 함수에 이러한 검사를 포함하는 것은 지루할 것이며 (성능에 영향을 미칠 수도 있습니다).</p>
<p>대신, 새로운 타입을 만들고 유효성 검사를 함수에 넣어 타입의 인스턴스를 생성하도록 할 수 있습니다. 이렇게 하면 모든 곳에서 유효성 검사를 반복할 필요가 없습니다. 그렇게 하면 함수가 시그니처에서 새로운 타입을 안전하게 사용하고 받은 값을 확신을 가지고 사용할 수 있습니다. 목록 9-13은 <code>new</code> 함수가 1에서 100 사이의 값을 받을 때만 <code>Guess</code>의 인스턴스를 생성하는 <code>Guess</code> 타입을 정의하는 한 가지 방법을 보여줍니다.</p>
<Listing number="9-13" caption="A `Guess` type that will only continue with values between 1 and 100">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(추측 값은 1에서 100 사이여야 합니다. {value}를 받았습니다.);
        }

        Guess { value }
    }

    pub fn value(&amp;self) -&gt; i32 {
        self.value
    }
}
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>먼저 <code>value</code>라는 <code>i32</code> 타입의 필드를 가진 <code>Guess</code>라는 구조체를 정의합니다. 여기에 숫자가 저장될 것입니다.</p>
<p>그런 다음 <code>Guess</code>에 <code>new</code>라는 연관 함수를 구현하여 <code>Guess</code> 값의 인스턴스를 생성합니다. <code>new</code> 함수는 <code>i32</code> 타입의 <code>value</code>라는 매개변수 하나를 가지고 <code>Guess</code>를 반환하도록 정의됩니다. <code>new</code> 함수의 본문 코드는 <code>value</code>가 1에서 100 사이인지 확인합니다. 만약 <code>value</code>가 이 테스트를 통과하지 못하면 <code>panic!</code> 호출을 발생시켜, 호출 코드를 작성하는 프로그래머에게 수정해야 할 버그가 있음을 알립니다. 왜냐하면 이 범위를 벗어난 <code>value</code>로 <code>Guess</code>를 생성하는 것은 <code>Guess::new</code>가 의존하는 계약을 위반하기 때문입니다. <code>Guess::new</code>가 패닉을 일으킬 수 있는 조건은 공개 API 문서에서 논의되어야 합니다. 14장에서 생성할 API 문서에서 <code>panic!</code> 가능성을 나타내는 문서화 규칙을 다룰 것입니다. 만약 <code>value</code>가 테스트를 통과하면, <code>value</code> 필드가 <code>value</code> 매개변수로 설정된 새로운 <code>Guess</code>를 생성하고 <code>Guess</code>를 반환합니다.</p>
<p>다음으로, <code>self</code>를 빌리고 다른 매개변수는 없으며 <code>i32</code>를 반환하는 <code>value</code>라는 메서드를 구현합니다. 이러한 종류의 메서드는 필드에서 데이터를 가져와 반환하는 것이 목적이므로 때때로 _게터_라고 불립니다. 이 공개 메서드는 <code>Guess</code> 구조체의 <code>value</code> 필드가 비공개이기 때문에 필요합니다. <code>value</code> 필드가 비공개인 것이 중요한데, 이는 <code>Guess</code> 구조체를 사용하는 코드가 <code>value</code>를 직접 설정할 수 없도록 하기 위함입니다. 모듈 외부의 코드는 <code>Guess::new</code> 함수를 사용하여 <code>Guess</code> 인스턴스를 생성해야 하며, 이를 통해 <code>Guess</code>가 <code>Guess::new</code> 함수의 조건에 의해 확인되지 않은 <code>value</code>를 가질 수 없도록 보장합니다.</p>
<p>매개변수를 가지거나 1에서 100 사이의 숫자만 반환하는 함수는 시그니처에서 <code>i32</code> 대신 <code>Guess</code>를 받거나 반환한다고 선언할 수 있으며, 본문에서 추가적인 검사를 할 필요가 없습니다.</p>
<h2 id="요약-8"><a class="header" href="#요약-8">요약</a></h2>
<p>러스트의 오류 처리 기능은 더 견고한 코드를 작성하는 데 도움이 되도록 설계되었습니다. <code>panic!</code> 매크로는 프로그램이 처리할 수 없는 상태에 있음을 알리고, 유효하지 않거나 잘못된 값으로 계속 진행하려고 시도하는 대신 프로세스를 중지하도록 지시합니다. <code>Result</code> 열거형은 러스트의 타입 시스템을 사용하여 코드가 복구할 수 있는 방식으로 작업이 실패할 수 있음을 나타냅니다. <code>Result</code>를 사용하여 코드를 호출하는 코드에 잠재적인 성공 또는 실패를 처리해야 한다고 알릴 수 있습니다. 적절한 상황에서 <code>panic!</code>과 <code>Result</code>를 사용하면 피할 수 없는 문제에 직면했을 때 코드를 더 안정적으로 만들 수 있습니다.</p>
<p>이제 표준 라이브러리가 <code>Option</code> 및 <code>Result</code> 열거형과 함께 제네릭을 사용하는 유용한 방법을 보았으니, 제네릭이 어떻게 작동하고 코드에서 어떻게 사용할 수 있는지에 대해 이야기할 것입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="제네릭-타입-트레이트-라이프타임"><a class="header" href="#제네릭-타입-트레이트-라이프타임">제네릭 타입, 트레이트, 라이프타임</a></h1>
<p>모든 프로그래밍 언어에는 개념의 중복을 효과적으로 처리하기 위한 도구가 있습니다. 러스트에서 그러한 도구 중 하나는 _제네릭_입니다. 제네릭은 구체적인 타입 또는 다른 속성을 위한 추상적인 대체물입니다. 우리는 코드를 컴파일하고 실행할 때 무엇이 그 자리에 올지 알지 못하더라도 제네릭의 동작이나 다른 제네릭과의 관계를 표현할 수 있습니다.</p>
<p>함수는 <code>i32</code>나 <code>String</code>과 같은 구체적인 타입 대신 일부 제네릭 타입의 매개변수를 받을 수 있습니다. 이는 알 수 없는 값을 가진 매개변수를 받아 여러 구체적인 값에 대해 동일한 코드를 실행하는 방식과 같습니다. 사실, 우리는 이미 6장에서 <code>Option&lt;T&gt;</code>로, 8장에서 <code>Vec&lt;T&gt;</code>와 <code>HashMap&lt;K, V&gt;</code>로, 9장에서 <code>Result&lt;T, E&gt;</code>로 제네릭을 사용했습니다. 이 장에서는 제네릭을 사용하여 자신만의 타입, 함수, 메서드를 정의하는 방법을 탐구할 것입니다!</p>
<p>먼저 코드 중복을 줄이기 위해 함수를 추출하는 방법을 검토할 것입니다. 그런 다음 동일한 기술을 사용하여 매개변수 타입만 다른 두 함수로부터 제네릭 함수를 만들 것입니다. 또한 구조체 및 열거형 정의에서 제네릭 타입을 사용하는 방법을 설명할 것입니다.</p>
<p>그런 다음 _트레이트_를 사용하여 제네릭 방식으로 동작을 정의하는 방법을 배울 것입니다. 트레이트를 제네릭 타입과 결합하여 제네릭 타입이 특정 동작을 가진 타입만 허용하도록 제한할 수 있습니다. 단순히 어떤 타입이든 허용하는 것이 아니라 말이죠.</p>
<p>마지막으로, _라이프타임_에 대해 논의할 것입니다. 라이프타임은 참조가 서로 어떻게 관련되는지에 대한 정보를 컴파일러에 제공하는 다양한 제네릭입니다. 라이프타임을 통해 빌린 값에 대한 충분한 정보를 컴파일러에 제공하여, 컴파일러가 우리의 도움 없이도 참조가 더 많은 상황에서 유효하도록 보장할 수 있습니다.</p>
<h2 id="함수-추출을-통한-중복-제거"><a class="header" href="#함수-추출을-통한-중복-제거">함수 추출을 통한 중복 제거</a></h2>
<p>제네릭은 특정 타입을 여러 타입을 나타내는 플레이스홀더로 대체하여 코드 중복을 제거할 수 있도록 합니다. 제네릭 문법에 대해 자세히 알아보기 전에, 먼저 특정 값을 여러 값을 나타내는 플레이스홀더로 대체하는 함수를 추출하여 제네릭 타입을 사용하지 않고 중복을 제거하는 방법을 살펴보겠습니다. 그런 다음 동일한 기술을 적용하여 제네릭 함수를 추출할 것입니다! 함수로 추출할 수 있는 중복 코드를 인식하는 방법을 살펴보면, 제네릭을 사용할 수 있는 중복 코드를 인식하기 시작할 것입니다.</p>
<p>목록 10-1에 있는, 목록에서 가장 큰 숫자를 찾는 짧은 프로그램으로 시작하겠습니다.</p>
<Listing number="10-1" file-name="src/main.rs" caption="Finding the largest number in a list of numbers">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = &amp;number_list[0];

    for number in &amp;number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!("가장 큰 숫자는 {largest}입니다");
<span class="boring">    assert_eq!(*largest, 100);
</span>}</code></pre></pre>
</Listing>
<p>우리는 <code>number_list</code> 변수에 정수 목록을 저장하고, 목록의 첫 번째 숫자에 대한 참조를 <code>largest</code>라는 변수에 저장합니다. 그런 다음 목록의 모든 숫자를 반복하며, 현재 숫자가 <code>largest</code>에 저장된 숫자보다 크면 해당 변수의 참조를 교체합니다. 그러나 현재 숫자가 지금까지 본 가장 큰 숫자보다 작거나 같으면 변수는 변경되지 않고, 코드는 목록의 다음 숫자로 이동합니다. 목록의 모든 숫자를 고려한 후, <code>largest</code>는 가장 큰 숫자를 참조해야 하며, 이 경우 100입니다.</p>
<p>이제 두 개의 다른 숫자 목록에서 가장 큰 숫자를 찾는 작업을 맡게 되었습니다. 이를 위해 목록 10-1의 코드를 복제하고 프로그램의 두 다른 위치에서 동일한 로직을 사용할 수 있습니다. 이는 목록 10-2에 나와 있습니다.</p>
<Listing number="10-2" file-name="src/main.rs" caption="Code to find the largest number in *two* lists of numbers">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = &amp;number_list[0];

    for number in &amp;number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!("가장 큰 숫자는 {largest}입니다");

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = &amp;number_list[0];

    for number in &amp;number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!("가장 큰 숫자는 {largest}입니다");
}</code></pre></pre>
</Listing>
<p>이 코드는 작동하지만, 코드 중복은 지루하고 오류가 발생하기 쉽습니다. 또한 코드를 변경할 때 여러 곳에서 업데이트해야 한다는 점도 기억해야 합니다.</p>
<p>이 중복을 제거하기 위해, 매개변수로 전달된 모든 정수 목록에 대해 작동하는 함수를 정의하여 추상화를 생성할 것입니다. 이 해결책은 코드를 더 명확하게 만들고, 목록에서 가장 큰 숫자를 찾는 개념을 추상적으로 표현할 수 있도록 합니다.</p>
<p>목록 10-3에서는 가장 큰 숫자를 찾는 코드를 <code>largest</code>라는 함수로 추출합니다. 그런 다음 이 함수를 호출하여 목록 10-2의 두 목록에서 가장 큰 숫자를 찾습니다. 앞으로 가질 수 있는 다른 <code>i32</code> 값 목록에도 이 함수를 사용할 수 있습니다.</p>
<Listing number="10-3" file-name="src/main.rs" caption="Abstracted code to find the largest number in two lists">
<pre><pre class="playground"><code class="language-rust edition2021">fn largest(list: &amp;[i32]) -&gt; &amp;i32 {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!("가장 큰 숫자는 {result}입니다");
<span class="boring">    assert_eq!(*result, 100);
</span>
    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&amp;number_list);
    println!("가장 큰 숫자는 {result}입니다");
<span class="boring">    assert_eq!(*result, 6000);
</span>}</code></pre></pre>
</Listing>
<p><code>largest</code> 함수는 <code>list</code>라는 매개변수를 가지며, 이는 함수에 전달할 수 있는 <code>i32</code> 값의 구체적인 슬라이스를 나타냅니다. 결과적으로, 함수를 호출할 때 코드는 우리가 전달하는 특정 값에 대해 실행됩니다.</p>
<p>요약하자면, 목록 10-2의 코드를 목록 10-3으로 변경하기 위해 수행한 단계는 다음과 같습니다:</p>
<ol>
<li>중복 코드 식별.</li>
<li>중복 코드를 함수의 본문으로 추출하고, 함수 시그니처에 해당 코드의 입력 및 반환 값을 지정합니다.</li>
<li>중복된 코드의 두 인스턴스를 함수를 호출하도록 업데이트합니다.</li>
</ol>
<p>다음으로, 이와 동일한 단계를 제네릭과 함께 사용하여 코드 중복을 줄일 것입니다. 함수 본문이 특정 값 대신 추상적인 <code>list</code>에 대해 작동할 수 있는 것과 마찬가지로, 제네릭은 코드가 추상적인 타입에 대해 작동할 수 있도록 합니다.</p>
<p>예를 들어, <code>i32</code> 값 슬라이스에서 가장 큰 항목을 찾는 함수와 <code>char</code> 값 슬라이스에서 가장 큰 항목을 찾는 두 함수가 있다고 가정해 봅시다. 이 중복을 어떻게 제거할 수 있을까요? 알아봅시다!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="제네릭-데이터-타입"><a class="header" href="#제네릭-데이터-타입">제네릭 데이터 타입</a></h2>
<p>우리는 함수 시그니처나 구조체와 같은 항목에 대한 정의를 생성하기 위해 제네릭을 사용하며, 이를 다양한 구체적인 데이터 타입과 함께 사용할 수 있습니다. 먼저 제네릭을 사용하여 함수, 구조체, 열거형 및 메서드를 정의하는 방법을 살펴보고, 그런 다음 제네릭이 코드 성능에 미치는 영향에 대해 논의할 것입니다.</p>
<h3 id="함수-정의에서"><a class="header" href="#함수-정의에서">함수 정의에서</a></h3>
<p>제네릭을 사용하는 함수를 정의할 때, 일반적으로 매개변수와 반환 값의 데이터 타입을 지정하는 함수 시그니처에 제네릭을 배치합니다. 이렇게 하면 코드가 더 유연해지고, 코드 중복을 방지하면서 함수 호출자에게 더 많은 기능을 제공합니다.</p>
<p>우리의 <code>largest</code> 함수를 계속해서 살펴보면, 목록 10-4는 슬라이스에서 가장 큰 값을 찾는 두 함수를 보여줍니다. 그런 다음 이 함수들을 제네릭을 사용하는 단일 함수로 결합할 것입니다.</p>
<Listing number="10-4" file-name="src/main.rs" caption="Two functions that differ only in their names and in the types in their signatures">
<pre><pre class="playground"><code class="language-rust edition2021">fn largest_i32(list: &amp;[i32]) -&gt; &amp;i32 {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &amp;[char]) -&gt; &amp;char {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&amp;number_list);
    println!("가장 큰 숫자는 {result}입니다");
<span class="boring">    assert_eq!(*result, 100);
</span>
    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&amp;char_list);
    println!("가장 큰 문자는 {result}입니다");
<span class="boring">    assert_eq!(*result, 'y');
</span>}</code></pre></pre>
</Listing>
<p><code>largest_i32</code> 함수는 목록 10-3에서 추출한 것으로, 슬라이스에서 가장 큰 <code>i32</code>를 찾습니다. <code>largest_char</code> 함수는 슬라이스에서 가장 큰 <code>char</code>를 찾습니다. 함수 본문은 동일한 코드를 가지므로, 단일 함수에 제네릭 타입 매개변수를 도입하여 중복을 제거해 봅시다.</p>
<p>새로운 단일 함수에서 타입을 매개변수화하려면, 함수에 대한 값 매개변수와 마찬가지로 타입 매개변수의 이름을 지정해야 합니다. 어떤 식별자든 타입 매개변수 이름으로 사용할 수 있습니다. 하지만 러스트의 타입 매개변수 이름은 관례적으로 짧고 종종 한 글자이며, 러스트의 타입 명명 규칙은 CamelCase이기 때문에 <code>T</code>를 사용할 것입니다. _type_의 약자인 <code>T</code>는 대부분의 러스트 프로그래머가 기본적으로 선택하는 것입니다.</p>
<p>함수 본문에서 매개변수를 사용할 때, 컴파일러가 그 이름의 의미를 알 수 있도록 시그니처에 매개변수 이름을 선언해야 합니다. 마찬가지로, 함수 시그니처에서 타입 매개변수 이름을 사용할 때, 사용하기 전에 타입 매개변수 이름을 선언해야 합니다. 제네릭 <code>largest</code> 함수를 정의하려면, 함수 이름과 매개변수 목록 사이에 꺾쇠 괄호 <code>&lt;&gt;</code> 안에 타입 이름 선언을 다음과 같이 배치합니다:</p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {</code></pre>
<p>이 정의는 다음과 같이 해석됩니다. <code>largest</code> 함수는 어떤 타입 <code>T</code>에 대해 제네릭입니다. 이 함수는 <code>list</code>라는 하나의 매개변수를 가지며, 이는 <code>T</code> 타입 값의 슬라이스입니다. <code>largest</code> 함수는 동일한 <code>T</code> 타입 값에 대한 참조를 반환할 것입니다.</p>
<p>목록 10-5는 제네릭 데이터 타입을 시그니처에 사용하여 결합된 <code>largest</code> 함수 정의를 보여줍니다. 이 목록은 또한 <code>i32</code> 값 슬라이스 또는 <code>char</code> 값으로 함수를 호출하는 방법을 보여줍니다. 이 코드는 아직 컴파일되지 않지만, 이 장의 뒷부분에서 수정할 것입니다.</p>
<Listing number="10-5" file-name="src/main.rs" caption="The `largest` function using generic type parameters; this doesn’t compile yet">
<pre><code class="language-rust ignore does_not_compile">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!("가장 큰 숫자는 {result}입니다");

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!("가장 큰 문자는 {result}입니다");
}</code></pre>
</Listing>
<p>이 코드를 지금 컴파일하면 다음과 같은 오류가 발생할 것입니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `&amp;T`
 --&gt; src/main.rs:5:17
  |
5 |         if item &gt; largest {
  |            ---- ^ ------- &amp;T
  |            |
  |            &amp;T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; &amp;T {
  |             ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>도움말 텍스트는 _트레이트_인 <code>std::cmp::PartialOrd</code>를 언급하며, 다음 섹션에서 트레이트에 대해 이야기할 것입니다. 지금은 이 오류가 <code>largest</code>의 본문이 <code>T</code>가 될 수 있는 모든 가능한 타입에 대해 작동하지 않을 것임을 나타낸다는 것을 알아두세요. 본문에서 <code>T</code> 타입의 값을 비교하기를 원하므로, 값이 정렬될 수 있는 타입만 사용할 수 있습니다. 비교를 가능하게 하기 위해 표준 라이브러리에는 타입에 구현할 수 있는 <code>std::cmp::PartialOrd</code> 트레이트가 있습니다 (이 트레이트에 대한 자세한 내용은 부록 C를 참조하세요). 도움말 텍스트의 제안을 따르면, <code>T</code>에 유효한 타입을 <code>PartialOrd</code>를 구현하는 타입으로만 제한하며, 표준 라이브러리가 <code>i32</code>와 <code>char</code> 모두에 <code>PartialOrd</code>를 구현하므로 이 예제는 컴파일될 것입니다.</p>
<h3 id="구조체-정의에서"><a class="header" href="#구조체-정의에서">구조체 정의에서</a></h3>
<p>또한 <code>&lt;&gt;</code> 구문을 사용하여 하나 이상의 필드에 제네릭 타입 매개변수를 사용하도록 구조체를 정의할 수 있습니다. 목록 10-6은 어떤 타입의 <code>x</code> 및 <code>y</code> 좌표 값을 저장하는 <code>Point&lt;T&gt;</code> 구조체를 정의합니다.</p>
<Listing number="10-6" file-name="src/main.rs" caption="A `Point<T>` struct that holds `x` and `y` values of type `T`">
<pre><pre class="playground"><code class="language-rust edition2021">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}</code></pre></pre>
</Listing>
<p>구조체 정의에서 제네릭을 사용하는 문법은 함수 정의에서 사용되는 문법과 유사합니다. 먼저 구조체 이름 바로 뒤의 꺾쇠 괄호 안에 타입 매개변수 이름을 선언합니다. 그런 다음 구체적인 데이터 타입을 지정했을 구조체 정의에서 제네릭 타입을 사용합니다.</p>
<p>우리가 <code>Point&lt;T&gt;</code>를 정의하기 위해 하나의 제네릭 타입만 사용했기 때문에, 이 정의는 <code>Point&lt;T&gt;</code> 구조체가 어떤 타입 <code>T</code>에 대해 제네릭이며, <code>x</code>와 <code>y</code> 필드 <em>모두</em> 그 동일한 타입이라는 것을 의미합니다. 그 타입이 무엇이든 말이죠. 만약 목록 10-7과 같이 다른 타입의 값을 가진 <code>Point&lt;T&gt;</code> 인스턴스를 생성하면, 우리 코드는 컴파일되지 않을 것입니다.</p>
<Listing number="10-7" file-name="src/main.rs" caption="The fields `x` and `y` must be the same type because both have the same generic data type `T`.">
<pre><code class="language-rust ignore does_not_compile">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}</code></pre>
</Listing>
<p>이 예제에서 <code>x</code>에 정수 값 <code>5</code>를 할당하면, 컴파일러는 <code>Point&lt;T&gt;</code>의 이 인스턴스에 대해 제네릭 타입 <code>T</code>가 정수임을 알게 됩니다. 그런 다음 <code>x</code>와 동일한 타입을 가지도록 정의한 <code>y</code>에 <code>4.0</code>을 지정하면 다음과 같은 타입 불일치 오류가 발생할 것입니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-point number

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p><code>x</code>와 <code>y</code>가 모두 제네릭이지만 다른 타입을 가질 수 있는 <code>Point</code> 구조체를 정의하려면, 여러 제네릭 타입 매개변수를 사용할 수 있습니다. 예를 들어, 목록 10-8에서는 <code>Point</code>의 정의를 <code>x</code>가 <code>T</code> 타입이고 <code>y</code>가 <code>U</code> 타입인 <code>T</code>와 <code>U</code> 타입에 대해 제네릭으로 변경합니다.</p>
<Listing number="10-8" file-name="src/main.rs" caption="A `Point<T, U>` generic over two types so that `x` and `y` can be values of different types">
<pre><pre class="playground"><code class="language-rust edition2021">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}</code></pre></pre>
</Listing>
<p>이제 표시된 <code>Point</code>의 모든 인스턴스가 허용됩니다! 정의에서 원하는 만큼 많은 제네릭 타입 매개변수를 사용할 수 있지만, 몇 개 이상을 사용하면 코드를 읽기 어려워집니다. 코드에 많은 제네릭 타입이 필요하다고 생각되면, 코드를 더 작은 조각으로 재구성해야 함을 나타낼 수 있습니다.</p>
<h3 id="열거형-정의에서"><a class="header" href="#열거형-정의에서">열거형 정의에서</a></h3>
<p>구조체에서 했던 것처럼, 열거형을 정의하여 variant에 제네릭 데이터 타입을 담을 수 있습니다. 6장에서 사용했던 표준 라이브러리가 제공하는 <code>Option&lt;T&gt;</code> 열거형을 다시 살펴보겠습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}</span></code></pre></pre>
<p>이제 이 정의가 여러분에게 더 이해가 될 것입니다. 보시다시피, <code>Option&lt;T&gt;</code> 열거형은 <code>T</code> 타입에 대해 제네릭이며, <code>T</code> 타입의 값 하나를 담는 <code>Some</code>과 아무 값도 담지 않는 <code>None</code>이라는 두 가지 variant를 가집니다. <code>Option&lt;T&gt;</code> 열거형을 사용함으로써 선택적 값이라는 추상적인 개념을 표현할 수 있으며, <code>Option&lt;T&gt;</code>가 제네릭이므로 선택적 값의 타입이 무엇이든 이 추상화를 사용할 수 있습니다.</p>
<p>열거형은 여러 제네릭 타입을 사용할 수도 있습니다. 9장에서 사용했던 <code>Result</code> 열거형의 정의가 한 예입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p><code>Result</code> 열거형은 <code>T</code>와 <code>E</code> 두 가지 타입에 대해 제네릭이며, <code>T</code> 타입의 값을 담는 <code>Ok</code>와 <code>E</code> 타입의 값을 담는 <code>Err</code> 두 가지 variant를 가집니다. 이 정의는 성공할 수도 있고 (<code>T</code> 타입의 값을 반환) 실패할 수도 있는 (<code>E</code> 타입의 오류를 반환) 작업이 있는 모든 곳에서 <code>Result</code> 열거형을 편리하게 사용할 수 있도록 합니다. 실제로 이것은 목록 9-3에서 파일을 열 때 사용했던 것으로, 파일이 성공적으로 열렸을 때 <code>T</code>는 <code>std::fs::File</code> 타입으로 채워졌고, 파일을 여는 데 문제가 있었을 때 <code>E</code>는 <code>std::io::Error</code> 타입으로 채워졌습니다.</p>
<p>코드에서 값의 타입만 다른 여러 구조체 또는 열거형 정의가 있는 상황을 인식하면, 대신 제네릭 타입을 사용하여 중복을 피할 수 있습니다.</p>
<h3 id="메서드-정의에서"><a class="header" href="#메서드-정의에서">메서드 정의에서</a></h3>
<p>구조체와 열거형에 메서드를 구현하고(5장에서 했던 것처럼) 정의에 제네릭 타입을 사용할 수도 있습니다. 목록 10-9는 목록 10-6에서 정의한 <code>Point&lt;T&gt;</code> 구조체에 <code>x</code>라는 메서드가 구현된 것을 보여줍니다.</p>
<Listing number="10-9" file-name="src/main.rs" caption="Implementing a method named `x` on the `Point<T>` struct that will return a reference to the `x` field of type `T`">
<pre><pre class="playground"><code class="language-rust edition2021">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}</code></pre></pre>
</Listing>
<p>여기서 우리는 <code>Point&lt;T&gt;</code>에 <code>x</code>라는 메서드를 정의했으며, 이 메서드는 필드 <code>x</code>의 데이터에 대한 참조를 반환합니다.</p>
<p><code>impl</code> 바로 뒤에 <code>T</code>를 선언해야 <code>T</code>를 사용하여 <code>Point&lt;T&gt;</code> 타입에 메서드를 구현하고 있음을 지정할 수 있다는 점에 유의하세요. <code>impl</code> 뒤에 <code>T</code>를 제네릭 타입으로 선언함으로써 러스트는 <code>Point</code>의 꺾쇠 괄호 안의 타입이 구체적인 타입이 아닌 제네릭 타입임을 식별할 수 있습니다. 구조체 정의에 선언된 제네릭 매개변수와 다른 이름을 이 제네릭 매개변수에 대해 선택할 수도 있었지만, 동일한 이름을 사용하는 것이 관례입니다. 제네릭 타입을 선언하는 <code>impl</code> 내부에 메서드를 작성하면, 해당 메서드는 어떤 구체적인 타입이 제네릭 타입을 대체하든 상관없이 해당 타입의 모든 인스턴스에 대해 정의될 것입니다.</p>
<p>타입에 메서드를 정의할 때 제네릭 타입에 대한 제약 조건을 지정할 수도 있습니다. 예를 들어, 어떤 제네릭 타입을 가진 <code>Point&lt;T&gt;</code> 인스턴스 대신 <code>Point&lt;f32&gt;</code> 인스턴스에만 메서드를 구현할 수 있습니다. 목록 10-10에서는 구체적인 타입 <code>f32</code>를 사용하며, 이는 <code>impl</code> 뒤에 어떤 타입도 선언하지 않음을 의미합니다.</p>
<Listing number="10-10" file-name="src/main.rs" caption="An `impl` block that only applies to a struct with a particular concrete type for the generic type parameter `T`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct Point&lt;T&gt; {
</span><span class="boring">    x: T,
</span><span class="boring">    y: T,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Point&lt;T&gt; {
</span><span class="boring">    fn x(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.x
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 5, y: 10 };
</span><span class="boring">
</span><span class="boring">    println!("p.x = {}", p.x());
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 코드는 <code>Point&lt;f32&gt;</code> 타입이 <code>distance_from_origin</code> 메서드를 가질 것임을 의미합니다. <code>T</code>가 <code>f32</code> 타입이 아닌 <code>Point&lt;T&gt;</code>의 다른 인스턴스에는 이 메서드가 정의되지 않습니다. 이 메서드는 우리 점이 좌표 (0.0, 0.0)의 점으로부터 얼마나 떨어져 있는지 측정하며, 부동 소수점 타입에만 사용 가능한 수학 연산을 사용합니다.</p>
<p>구조체 정의의 제네릭 타입 매개변수는 항상 동일한 구조체의 메서드 시그니처에서 사용하는 것과 같지 않습니다. 목록 10-11은 예제를 더 명확하게 하기 위해 <code>Point</code> 구조체에 <code>X1</code>과 <code>Y1</code> 제네릭 타입을 사용하고 <code>mixup</code> 메서드 시그니처에 <code>X2</code> <code>Y2</code>를 사용합니다. 이 메서드는 <code>self</code> <code>Point</code> (타입 <code>X1</code>)의 <code>x</code> 값과 전달된 <code>Point</code> (타입 <code>Y2</code>)의 <code>y</code> 값으로 새로운 <code>Point</code> 인스턴스를 생성합니다.</p>
<Listing number="10-11" file-name="src/main.rs" caption="A method that uses generic types different from its struct’s definition">
<pre><pre class="playground"><code class="language-rust edition2021">struct Point&lt;X1, Y1&gt; {
    x: X1,
    y: Y1,
}

impl&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; {
    fn mixup&lt;X2, Y2&gt;(self, other: Point&lt;X2, Y2&gt;) -&gt; Point&lt;X1, Y2&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c' };

    let p3 = p1.mixup(p2);

    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}</code></pre></pre>
</Listing>
<p><code>main</code>에서 우리는 <code>x</code>에 <code>i32</code> (값 <code>5</code>)를, <code>y</code>에 <code>f64</code> (값 <code>10.4</code>)를 가진 <code>Point</code>를 정의했습니다. <code>p2</code> 변수는 <code>x</code>에 문자열 슬라이스 (값 <code>"Hello"</code>)를, <code>y</code>에 <code>char</code> (값 <code>c</code>)를 가진 <code>Point</code> 구조체입니다. <code>p1</code>에 <code>p2</code> 인수를 사용하여 <code>mixup</code>을 호출하면 <code>p3</code>를 얻게 되는데, <code>x</code>는 <code>p1</code>에서 왔으므로 <code>p3</code>는 <code>x</code>에 <code>i32</code>를 가질 것입니다. <code>p3</code> 변수는 <code>y</code>에 <code>char</code>를 가질 것인데, <code>y</code>는 <code>p2</code>에서 왔기 때문입니다. <code>println!</code> 매크로 호출은 <code>p3.x = 5, p3.y = c</code>를 출력할 것입니다.</p>
<p>이 예제의 목적은 일부 제네릭 매개변수가 <code>impl</code>로 선언되고 일부는 메서드 정의로 선언되는 상황을 보여주는 것입니다. 여기서 제네릭 매개변수 <code>X1</code>과 <code>Y1</code>은 구조체 정의와 함께 사용되므로 <code>impl</code> 뒤에 선언됩니다. 제네릭 매개변수 <code>X2</code>와 <code>Y2</code>는 메서드에만 관련되므로 <code>fn mixup</code> 뒤에 선언됩니다.</p>
<h3 id="제네릭을-사용하는-코드의-성능"><a class="header" href="#제네릭을-사용하는-코드의-성능">제네릭을 사용하는 코드의 성능</a></h3>
<p>제네릭 타입 매개변수를 사용할 때 런타임 비용이 발생하는지 궁금할 수 있습니다. 좋은 소식은 제네릭 타입을 사용해도 구체적인 타입을 사용할 때보다 프로그램 실행 속도가 느려지지 않는다는 것입니다.</p>
<p>러스트는 컴파일 시 제네릭을 사용하는 코드의 단형성(monomorphization)을 수행하여 이를 달성합니다. _단형성_은 컴파일될 때 사용되는 구체적인 타입을 채워 제네릭 코드를 특정 코드로 변환하는 과정입니다. 이 과정에서 컴파일러는 목록 10-5에서 제네릭 함수를 생성하는 데 사용했던 단계와 반대되는 작업을 수행합니다. 컴파일러는 제네릭 코드가 호출되는 모든 위치를 살펴보고 제네릭 코드가 호출되는 구체적인 타입에 대한 코드를 생성합니다.</p>
<p>표준 라이브러리의 제네릭 <code>Option&lt;T&gt;</code> 열거형을 사용하여 이것이 어떻게 작동하는지 살펴보겠습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let integer = Some(5);
let float = Some(5.0);
<span class="boring">}</span></code></pre></pre>
<p>러스트가 이 코드를 컴파일할 때, 단형성(monomorphization)을 수행합니다. 이 과정에서 컴파일러는 <code>Option&lt;T&gt;</code> 인스턴스에서 사용된 값을 읽고 두 가지 종류의 <code>Option&lt;T&gt;</code>를 식별합니다. 하나는 <code>i32</code>이고 다른 하나는 <code>f64</code>입니다. 따라서 <code>Option&lt;T&gt;</code>의 제네릭 정의를 <code>i32</code>와 <code>f64</code>에 특화된 두 가지 정의로 확장하여 제네릭 정의를 특정 정의로 대체합니다.</p>
<p>단형성된 코드 버전은 다음(컴파일러는 여기에서 설명 목적으로 사용하는 이름과 다른 이름을 사용합니다)과 유사하게 보입니다:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}</code></pre></pre>
</Listing>
<p>제네릭 <code>Option&lt;T&gt;</code>는 컴파일러가 생성한 특정 정의로 대체됩니다. 러스트는 제네릭 코드를 각 인스턴스에서 타입을 지정하는 코드로 컴파일하기 때문에, 제네릭을 사용해도 런타임 비용이 발생하지 않습니다. 코드가 실행될 때, 각 정의를 수동으로 복제한 것과 동일하게 작동합니다. 단형성(monomorphization) 과정은 러스트의 제네릭을 런타임에 매우 효율적으로 만듭니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="트레이트-공유-동작-정의하기"><a class="header" href="#트레이트-공유-동작-정의하기">트레이트: 공유 동작 정의하기</a></h2>
<p>_트레이트_는 특정 타입이 가지는 기능과 다른 타입과 공유할 수 있는 기능을 정의합니다. 트레이트를 사용하여 공유된 동작을 추상적인 방식으로 정의할 수 있습니다. _트레이트 바운드_를 사용하여 제네릭 타입이 특정 동작을 가진 어떤 타입이든 될 수 있음을 지정할 수 있습니다.</p>
<blockquote>
<p>참고: 트레이트는 다른 언어에서 종종 _인터페이스_라고 불리는 기능과 유사하지만, 몇 가지 차이점이 있습니다.</p>
</blockquote>
<h3 id="트레이트-정의하기"><a class="header" href="#트레이트-정의하기">트레이트 정의하기</a></h3>
<p>타입의 동작은 해당 타입에서 호출할 수 있는 메서드로 구성됩니다. 모든 타입에서 동일한 메서드를 호출할 수 있다면 다른 타입들도 동일한 동작을 공유합니다. 트레이트 정의는 특정 목적을 달성하는 데 필요한 일련의 동작을 정의하기 위해 메서드 시그니처를 함께 그룹화하는 방법입니다.</p>
<p>예를 들어, 다양한 종류와 양의 텍스트를 담는 여러 구조체가 있다고 가정해 봅시다. 특정 위치에 보관된 뉴스 기사를 담는 <code>NewsArticle</code> 구조체와, 최대 280자까지 가능하며 새 트윗인지, 리트윗인지, 다른 트윗에 대한 답장인지 나타내는 메타데이터를 포함하는 <code>Tweet</code>입니다.</p>
<p>우리는 <code>NewsArticle</code> 또는 <code>Tweet</code> 인스턴스에 저장될 수 있는 데이터의 요약을 표시할 수 있는 <code>aggregator</code>라는 미디어 애그리게이터 라이브러리 크레이트를 만들고 싶습니다. 이를 위해 각 타입에서 요약이 필요하며, 인스턴스에서 <code>summarize</code> 메서드를 호출하여 해당 요약을 요청할 것입니다. 목록 10-12는 이러한 동작을 표현하는 공개 <code>Summary</code> 트레이트의 정의를 보여줍니다.</p>
<Listing number="10-12" file-name="src/lib.rs" caption="A `Summary` trait that consists of the behavior provided by a `summarize` method">
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}</code></pre>
</Listing>
<p>여기서 우리는 <code>trait</code> 키워드와 트레이트 이름(이 경우 <code>Summary</code>)을 사용하여 트레이트를 선언합니다. 또한 이 트레이트를 <code>pub</code>으로 선언하여 이 크레이트에 의존하는 크레이트도 이 트레이트를 사용할 수 있도록 합니다. 몇 가지 예제에서 이를 확인할 것입니다. 중괄호 안에는 이 트레이트를 구현하는 타입의 동작을 설명하는 메서드 시그니처를 선언하며, 이 경우 <code>fn summarize(&amp;self) -&gt; String</code>입니다.</p>
<p>메서드 시그니처 뒤에는 중괄호 안에 구현을 제공하는 대신 세미콜론을 사용합니다. 이 트레이트를 구현하는 각 타입은 메서드 본문에 대해 자체적인 사용자 정의 동작을 제공해야 합니다. 컴파일러는 <code>Summary</code> 트레이트를 가진 모든 타입이 이 시그니처와 정확히 일치하는 <code>summarize</code> 메서드를 정의하도록 강제할 것입니다.</p>
<p>트레이트는 본문에 여러 메서드를 가질 수 있습니다. 메서드 시그니처는 한 줄에 하나씩 나열되며, 각 줄은 세미콜론으로 끝납니다.</p>
<h3 id="타입에-트레이트-구현하기"><a class="header" href="#타입에-트레이트-구현하기">타입에 트레이트 구현하기</a></h3>
<p>이제 <code>Summary</code> 트레이트 메서드의 원하는 시그니처를 정의했으므로, 미디어 애그리게이터의 타입에 이를 구현할 수 있습니다. 목록 10-13은 <code>NewsArticle</code> 구조체에 <code>Summary</code> 트레이트를 구현한 것을 보여주며, 헤드라인, 작성자 및 위치를 사용하여 <code>summarize</code>의 반환 값을 생성합니다. <code>Tweet</code> 구조체의 경우, 트윗 내용이 이미 280자로 제한되어 있다고 가정하고 <code>summarize</code>를 사용자 이름 뒤에 전체 트윗 텍스트로 정의합니다.</p>
<Listing number="10-13" file-name="src/lib.rs" caption="Implementing the `Summary` trait on the `NewsArticle` and `Tweet` types">
<pre><code class="language-rust noplayground"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!("{}, {} 작성 ({})", self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!("{}: {}", self.username, self.content)
    }
}</code></pre>
</Listing>
<p>타입에 트레이트를 구현하는 것은 일반 메서드를 구현하는 것과 유사합니다. 차이점은 <code>impl</code> 다음에 구현하려는 트레이트 이름을 넣고, 그 다음 <code>for</code> 키워드를 사용한 다음, 트레이트를 구현하려는 타입의 이름을 지정한다는 것입니다. <code>impl</code> 블록 내에는 트레이트 정의가 정의한 메서드 시그니처를 넣습니다. 각 시그니처 뒤에 세미콜론을 추가하는 대신 중괄호를 사용하고 해당 타입에 대해 트레이트의 메서드가 가져야 할 특정 동작으로 메서드 본문을 채웁니다.</p>
<p>이제 라이브러리가 <code>NewsArticle</code>과 <code>Tweet</code>에 <code>Summary</code> 트레이트를 구현했으므로, 크레이트 사용자는 일반 메서드를 호출하는 것과 동일한 방식으로 <code>NewsArticle</code> 및 <code>Tweet</code> 인스턴스에서 트레이트 메서드를 호출할 수 있습니다. 유일한 차이점은 사용자가 타입뿐만 아니라 트레이트도 스코프로 가져와야 한다는 것입니다. 다음은 바이너리 크레이트가 <code>aggregator</code> 라이브러리 크레이트를 사용하는 방법의 예입니다:</p>
<pre><code class="language-rust ignore">use aggregator::{Summary, Tweet};

fn main() {
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "물론, 이미 알고 계시겠지만, 사람들",
        ),
        reply: false,
        retweet: false,
    };

    println!("새 트윗 1개: {}", tweet.summarize());
}</code></pre>
<p>이 코드는 <code>새 트윗 1개: horse_ebooks: 물론, 이미 알고 계시겠지만, 사람들</code>을 출력합니다.</p>
<p><code>aggregator</code> 크레이트에 의존하는 다른 크레이트들도 <code>Summary</code> 트레이트를 스코프로 가져와 자신의 타입에 <code>Summary</code>를 구현할 수 있습니다. 주의해야 할 제한 사항은 트레이트나 타입 중 하나, 또는 둘 다 우리 크레이트에 로컬인 경우에만 타입에 트레이트를 구현할 수 있다는 것입니다. 예를 들어, <code>Tweet</code> 타입이 <code>aggregator</code> 크레이트에 로컬이기 때문에 <code>aggregator</code> 크레이트 기능의 일부로 <code>Tweet</code>과 같은 사용자 정의 타입에 <code>Display</code>와 같은 표준 라이브러리 트레이트를 구현할 수 있습니다. 또한 <code>Summary</code> 트레이트가 <code>aggregator</code> 크레이트에 로컬이기 때문에 <code>aggregator</code> 크레이트에서 <code>Vec&lt;T&gt;</code>에 <code>Summary</code>를 구현할 수도 있습니다.</p>
<p>하지만 외부 타입에 외부 트레이트를 구현할 수는 없습니다. 예를 들어, <code>Display</code>와 <code>Vec&lt;T&gt;</code>는 모두 표준 라이브러리에 정의되어 있고 <code>aggregator</code> 크레이트에 로컬이 아니기 때문에 <code>aggregator</code> 크레이트 내에서 <code>Vec&lt;T&gt;</code>에 <code>Display</code> 트레이트를 구현할 수 없습니다. 이 제한은 <em>일관성(coherence)</em> 이라고 불리는 속성의 일부이며, 더 구체적으로는 부모 타입이 존재하지 않는다고 해서 <em>고아 규칙(orphan rule)</em> 이라고 불립니다. 이 규칙은 다른 사람의 코드가 여러분의 코드를 망가뜨리거나 그 반대의 경우가 발생하지 않도록 보장합니다. 이 규칙이 없다면 두 크레이트가 동일한 타입에 대해 동일한 트레이트를 구현할 수 있고, 러스트는 어떤 구현을 사용해야 할지 알 수 없게 됩니다.</p>
<h3 id="기본-구현"><a class="header" href="#기본-구현">기본 구현</a></h3>
<p>때로는 모든 타입에서 모든 메서드를 구현하도록 요구하는 대신 트레이트의 일부 또는 모든 메서드에 대해 기본 동작을 갖는 것이 유용할 때가 있습니다. 그러면 특정 타입에 트레이트를 구현할 때 각 메서드의 기본 동작을 유지하거나 재정의할 수 있습니다.</p>
<p>목록 10-14에서는 목록 10-12에서 했던 것처럼 메서드 시그니처만 정의하는 대신, <code>Summary</code> 트레이트의 <code>summarize</code> 메서드에 대한 기본 문자열을 지정합니다.</p>
<Listing number="10-14" file-name="src/lib.rs" caption="Defining a `Summary` trait with a default implementation of the `summarize` method">
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        String::from("(더 읽어보기...)")
    }
}
<span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p><code>NewsArticle</code> 인스턴스를 요약하기 위해 기본 구현을 사용하려면, <code>impl Summary for NewsArticle {}</code>과 같이 빈 <code>impl</code> 블록을 지정합니다.</p>
<p><code>NewsArticle</code>에 <code>summarize</code> 메서드를 직접 정의하지는 않았지만, 기본 구현을 제공하고 <code>NewsArticle</code>이 <code>Summary</code> 트레이트를 구현한다고 지정했습니다. 결과적으로 다음과 같이 <code>NewsArticle</code>의 인스턴스에서 <code>summarize</code> 메서드를 호출할 수 있습니다:</p>
<pre><code class="language-rust ignore"><span class="boring">use aggregator::{self, NewsArticle, Summary};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let article = NewsArticle {
        headline: String::from("펭귄스, 스탠리 컵 챔피언십 우승!"),
        location: String::from("미국 펜실베이니아주 피츠버그"),
        author: String::from("아이스버그"),
        content: String::from(
            "피츠버그 펭귄스는 다시 한번 NHL 최고의 \
             하키 팀이 되었습니다.",
        ),
    };

    println!("새로운 기사를 볼 수 있습니다! {}", article.summarize());
<span class="boring">}</span></code></pre>
<p>이 코드는 <code>새로운 기사를 볼 수 있습니다! (더 읽어보기...)</code>를 출력합니다.</p>
<p>기본 구현을 생성한다고 해서 목록 10-13의 <code>Tweet</code>에 대한 <code>Summary</code> 구현을 변경할 필요는 없습니다. 기본 구현을 재정의하는 문법은 기본 구현이 없는 트레이트 메서드를 구현하는 문법과 동일하기 때문입니다.</p>
<p>기본 구현은 동일한 트레이트 내의 다른 메서드를 호출할 수 있습니다. 그 다른 메서드에 기본 구현이 없더라도 상관없습니다. 이런 방식으로 트레이트는 많은 유용한 기능을 제공하면서 구현자가 그 중 일부만 지정하도록 요구할 수 있습니다. 예를 들어, <code>Summary</code> 트레이트에 구현이 필요한 <code>summarize_author</code> 메서드를 정의하고, <code>summarize</code> 메서드는 <code>summarize_author</code> 메서드를 호출하는 기본 구현을 갖도록 정의할 수 있습니다:</p>
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        format!("(...{}에서 더 읽어보기)", self.summarize_author())
    }
}
<span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String {
</span><span class="boring">        format!("@{}", self.username)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>이 <code>Summary</code> 버전을 사용하려면, 타입에 트레이트를 구현할 때 <code>summarize_author</code>만 정의하면 됩니다:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String;
</span><span class="boring">
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("(...{}에서 더 읽어보기)", self.summarize_author())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Summary for Tweet {
    fn summarize_author(&amp;self) -&gt; String {
        format!("@{}", self.username)
    }
}</code></pre>
<p><code>summarize_author</code>를 정의한 후에는 <code>Tweet</code> 구조체의 인스턴스에서 <code>summarize</code>를 호출할 수 있으며, <code>summarize</code>의 기본 구현은 우리가 제공한 <code>summarize_author</code>의 정의를 호출할 것입니다. <code>summarize_author</code>를 구현했으므로, <code>Summary</code> 트레이트는 우리가 더 이상 코드를 작성하지 않아도 <code>summarize</code> 메서드의 동작을 제공합니다. 다음과 같이 보입니다:</p>
<pre><code class="language-rust ignore"><span class="boring">use aggregator::{self, Summary, Tweet};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "물론, 이미 알고 계시겠지만, 사람들",
        ),
        reply: false,
        retweet: false,
    };

    println!("새 트윗 1개: {}", tweet.summarize());
<span class="boring">}</span></code></pre>
<p>이 코드는 <code>새 트윗 1개: (@horse_ebooks에서 더 읽어보기...)</code>를 출력합니다.</p>
<p>동일한 메서드를 재정의하는 구현에서는 기본 구현을 호출할 수 없다는 점에 유의하세요.</p>
<h3 id="매개변수로서의-트레이트"><a class="header" href="#매개변수로서의-트레이트">매개변수로서의 트레이트</a></h3>
<p>이제 트레이트를 정의하고 구현하는 방법을 알았으므로, 여러 다른 타입을 허용하는 함수를 정의하기 위해 트레이트를 사용하는 방법을 탐구해 볼 수 있습니다. 목록 10-13에서 <code>NewsArticle</code>과 <code>Tweet</code> 타입에 구현한 <code>Summary</code> 트레이트를 사용하여, <code>Summary</code> 트레이트를 구현하는 어떤 타입의 <code>item</code> 매개변수에 대해 <code>summarize</code> 메서드를 호출하는 <code>notify</code> 함수를 정의할 것입니다. 이를 위해 다음과 같이 <code>impl Trait</code> 문법을 사용합니다:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}, {} 작성 ({})", self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn notify(item: &amp;impl Summary) {
    println!("속보! {}", item.summarize());
}</code></pre>
<p><code>item</code> 매개변수에 구체적인 타입 대신 <code>impl</code> 키워드와 트레이트 이름을 지정합니다. 이 매개변수는 지정된 트레이트를 구현하는 어떤 타입이든 허용합니다. <code>notify</code> 본문에서는 <code>summarize</code>와 같이 <code>Summary</code> 트레이트에서 온 어떤 메서드든 <code>item</code>에서 호출할 수 있습니다. <code>notify</code>를 호출할 때 <code>NewsArticle</code>이나 <code>Tweet</code>의 인스턴스를 전달할 수 있습니다. <code>String</code>이나 <code>i32</code>와 같이 다른 타입으로 함수를 호출하는 코드는 <code>Summary</code>를 구현하지 않기 때문에 컴파일되지 않을 것입니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="fixing-the-largest-function-with-trait-bounds"></a></p>
<h4 id="트레이트-바운드-문법"><a class="header" href="#트레이트-바운드-문법">트레이트 바운드 문법</a></h4>
<p><code>impl Trait</code> 문법은 간단한 경우에는 잘 작동하지만, 실제로는 _트레이트 바운드_라고 알려진 더 긴 형태에 대한 문법적 설탕(syntax sugar)입니다. 다음과 같이 생겼습니다:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item: &amp;T) {
    println!("속보! {}", item.summarize());
}</code></pre>
<p>이 더 긴 형태는 이전 섹션의 예제와 동일하지만 더 장황합니다. 제네릭 타입 매개변수 선언과 함께 콜론 뒤에, 그리고 꺾쇠 괄호 안에 트레이트 바운드를 배치합니다.</p>
<p><code>impl Trait</code> 문법은 편리하고 간단한 경우에 코드를 더 간결하게 만들지만, 더 완전한 트레이트 바운드 문법은 다른 경우에 더 많은 복잡성을 표현할 수 있습니다. 예를 들어, <code>Summary</code>를 구현하는 두 개의 매개변수를 가질 수 있습니다. <code>impl Trait</code> 문법으로 그렇게 하면 다음과 같습니다:</p>
<pre><code class="language-rust ignore">pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {</code></pre>
<p><code>impl Trait</code>을 사용하는 것은 <code>item1</code>과 <code>item2</code>가 다른 타입을 갖도록 허용하려는 경우(두 타입 모두 <code>Summary</code>를 구현하는 한)에 적절합니다. 하지만 두 매개변수가 동일한 타입을 갖도록 강제하려면 다음과 같이 트레이트 바운드를 사용해야 합니다:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {</code></pre>
<p><code>item1</code>과 <code>item2</code> 매개변수의 타입으로 지정된 제네릭 타입 <code>T</code>는 <code>item1</code>과 <code>item2</code>에 대한 인수로 전달되는 값의 구체적인 타입이 동일해야 하도록 함수를 제약합니다.</p>
<h4 id="-문법으로-여러-트레이트-바운드-지정하기"><a class="header" href="#-문법으로-여러-트레이트-바운드-지정하기"><code>+</code> 문법으로 여러 트레이트 바운드 지정하기</a></h4>
<p>둘 이상의 트레이트 바운드를 지정할 수도 있습니다. <code>notify</code>가 <code>item</code>에 대해 <code>summarize</code>뿐만 아니라 디스플레이 포맷팅도 사용하기를 원한다고 가정해 봅시다: <code>notify</code> 정의에서 <code>item</code>이 <code>Display</code>와 <code>Summary</code>를 모두 구현해야 한다고 지정합니다. <code>+</code> 문법을 사용하여 그렇게 할 수 있습니다:</p>
<pre><code class="language-rust ignore">pub fn notify(item: &amp;(impl Summary + Display)) {</code></pre>
<p><code>+</code> 문법은 제네릭 타입의 트레이트 바운드에서도 유효합니다:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {</code></pre>
<p>두 개의 트레이트 바운드가 지정되었으므로 <code>notify</code>의 본문은 <code>summarize</code>를 호출하고 <code>{}</code>를 사용하여 <code>item</code>을 포맷팅할 수 있습니다.</p>
<h4 id="where-절로-트레이트-바운드를-더-명확하게-하기"><a class="header" href="#where-절로-트레이트-바운드를-더-명확하게-하기"><code>where</code> 절로 트레이트 바운드를 더 명확하게 하기</a></h4>
<p>너무 많은 트레이트 바운드를 사용하는 것에는 단점이 있습니다. 각 제네릭에는 고유한 트레이트 바운드가 있으므로, 여러 제네릭 타입 매개변수를 가진 함수는 함수 이름과 매개변수 목록 사이에 많은 트레이트 바운드 정보를 포함할 수 있어 함수 시그니처를 읽기 어렵게 만듭니다. 이러한 이유로 러스트는 함수 시그니처 뒤의 <code>where</code> 절 내부에 트레이트 바운드를 지정하는 대체 문법을 제공합니다. 따라서 이렇게 쓰는 대신:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {</code></pre>
<p>다음과 같이 <code>where</code> 절을 사용할 수 있습니다:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
where
    T: Display + Clone,
    U: Clone + Debug,
{
<span class="boring">    unimplemented!()
</span><span class="boring">}</span></code></pre>
<p>이 함수의 시그니처는 덜 복잡합니다: 함수 이름, 매개변수 목록, 반환 타입이 가까이 있어 트레이트 바운드가 많지 않은 함수와 비슷합니다.</p>
<h3 id="트레이트를-구현하는-타입-반환하기"><a class="header" href="#트레이트를-구현하는-타입-반환하기">트레이트를 구현하는 타입 반환하기</a></h3>
<p>여기서 보여지는 것처럼, 트레이트를 구현하는 어떤 타입의 값을 반환하기 위해 반환 위치에 <code>impl Trait</code> 문법을 사용할 수도 있습니다:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}, {} 작성 ({})", self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable() -&gt; impl Summary {
    Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "물론, 이미 알고 계시겠지만, 사람들",
        ),
        reply: false,
        retweet: false,
    }
}</code></pre>
<p>반환 타입에 <code>impl Summary</code>를 사용함으로써, 우리는 구체적인 타입을 명시하지 않고 <code>returns_summarizable</code> 함수가 <code>Summary</code> 트레이트를 구현하는 어떤 타입을 반환한다고 지정합니다. 이 경우 <code>returns_summarizable</code>은 <code>Tweet</code>를 반환하지만, 이 함수를 호출하는 코드는 그것을 알 필요가 없습니다.</p>
<p>구현하는 트레이트로만 반환 타입을 지정하는 기능은 13장에서 다루는 클로저와 반복자의 문맥에서 특히 유용합니다. 클로저와 반복자는 컴파일러만 아는 타입이나 지정하기 매우 긴 타입을 생성합니다. <code>impl Trait</code> 문법은 매우 긴 타입을 작성할 필요 없이 함수가 <code>Iterator</code> 트레이트를 구현하는 어떤 타입을 반환한다고 간결하게 지정할 수 있게 해줍니다.</p>
<p>하지만 단일 타입을 반환하는 경우에만 <code>impl Trait</code>을 사용할 수 있습니다. 예를 들어, 반환 타입이 <code>impl Summary</code>로 지정된 상태에서 <code>NewsArticle</code>이나 <code>Tweet</code> 중 하나를 반환하는 이 코드는 작동하지 않을 것입니다:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}, {} 작성 ({})", self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable(switch: bool) -&gt; impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                "펭귄스, 스탠리 컵 챔피언십 우승!",
            ),
            location: String::from("미국 펜실베이니아주 피츠버그"),
            author: String::from("아이스버그"),
            content: String::from(
                "피츠버그 펭귄스가 다시 한 번 NHL 최고의 \
                 하키 팀이 되었습니다.",
            ),
        }
    } else {
        Tweet {
            username: String::from("horse_ebooks"),
            content: String::from(
                "물론, 이미 알고 계시겠지만, 사람들",
            ),
            reply: false,
            retweet: false,
        }
    }
}</code></pre>
<p><code>impl Trait</code> 문법이 컴파일러에 구현된 방식에 대한 제한 때문에 <code>NewsArticle</code>이나 <code>Tweet</code> 중 하나를 반환하는 것은 허용되지 않습니다. 18장의 <a href="ch18-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">“다른 타입의 값을 허용하는 트레이트 객체 사용하기”</a><!--
ignore --> 섹션에서 이러한 동작을 하는 함수를 작성하는 방법을 다룰 것입니다.</p>
<h3 id="트레이트-바운드를-사용하여-메서드를-조건부로-구현하기"><a class="header" href="#트레이트-바운드를-사용하여-메서드를-조건부로-구현하기">트레이트 바운드를 사용하여 메서드를 조건부로 구현하기</a></h3>
<p>제네릭 타입 매개변수를 사용하는 <code>impl</code> 블록에 트레이트 바운드를 사용하면, 지정된 트레이트를 구현하는 타입에 대해서만 메서드를 조건부로 구현할 수 있습니다. 예를 들어, 목록 10-15의 <code>Pair&lt;T&gt;</code> 타입은 항상 <code>Pair&lt;T&gt;</code>의 새 인스턴스를 반환하는 <code>new</code> 함수를 구현합니다(5장의 <a href="ch05-03-method-syntax.html#defining-methods">“메서드 정의하기”</a><!-- ignore --> 섹션에서 <code>Self</code>가 <code>impl</code> 블록의 타입에 대한 타입 별칭임을 기억하세요. 이 경우 <code>Pair&lt;T&gt;</code>입니다). 하지만 다음 <code>impl</code> 블록에서 <code>Pair&lt;T&gt;</code>는 내부 타입 <code>T</code>가 비교를 가능하게 하는 <code>PartialOrd</code> 트레이트 <em>와</em> 출력을 가능하게 하는 <code>Display</code> 트레이트를 구현하는 경우에만 <code>cmp_display</code> 메서드를 구현합니다.</p>
<Listing number="10-15" file-name="src/lib.rs" caption="Conditionally implementing methods on a generic type depending on trait bounds">
<pre><code class="language-rust noplayground">use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self { x, y }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!("가장 큰 멤버는 x = {}", self.x);
        } else {
            println!("가장 큰 멤버는 y = {}", self.y);
        }
    }
}</code></pre>
</Listing>
<p>우리는 또한 다른 트레이트를 구현하는 모든 타입에 대해 트레이트를 조건부로 구현할 수 있습니다. 트레이트 바운드를 만족하는 모든 타입에 대한 트레이트 구현을 _포괄적 구현(blanket implementations)_이라고 하며, 러스트 표준 라이브러리에서 광범위하게 사용됩니다. 예를 들어, 표준 라이브러리는 <code>Display</code> 트레이트를 구현하는 모든 타입에 대해 <code>ToString</code> 트레이트를 구현합니다. 표준 라이브러리의 <code>impl</code> 블록은 이 코드와 유사해 보입니다:</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --생략--
}</code></pre>
<p>표준 라이브러리에 이러한 포괄적 구현이 있기 때문에, <code>Display</code> 트레이트를 구현하는 모든 타입에서 <code>ToString</code> 트레이트에 정의된 <code>to_string</code> 메서드를 호출할 수 있습니다. 예를 들어, 정수는 <code>Display</code>를 구현하므로 다음과 같이 정수를 해당 <code>String</code> 값으로 바꿀 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = 3.to_string();
<span class="boring">}</span></code></pre></pre>
<p>포괄적 구현은 트레이트 문서의 “Implementors” 섹션에 나타납니다.</p>
<p>트레이트와 트레이트 바운드를 사용하면 제네릭 타입 매개변수를 사용하여 중복을 줄이는 동시에, 컴파일러에게 제네릭 타입이 특정 동작을 갖도록 하겠다고 지정할 수 있습니다. 그러면 컴파일러는 트레이트 바운드 정보를 사용하여 코드에 사용된 모든 구체적인 타입이 올바른 동작을 제공하는지 확인할 수 있습니다. 동적 타입 언어에서는 메서드를 정의하지 않은 타입에서 메서드를 호출하면 런타임에 에러가 발생합니다. 하지만 러스트는 이러한 에러를 컴파일 타임으로 옮겨 코드를 실행하기도 전에 문제를 해결하도록 강제합니다. 또한 컴파일 타임에 이미 확인했기 때문에 런타임에 동작을 확인하는 코드를 작성할 필요가 없습니다. 이렇게 하면 제네릭의 유연성을 포기하지 않고도 성능을 향상시킬 수 있습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="라이프타임으로-참조-유효성-검증하기"><a class="header" href="#라이프타임으로-참조-유효성-검증하기">라이프타임으로 참조 유효성 검증하기</a></h2>
<p>라이프타임은 우리가 이미 사용하고 있던 또 다른 종류의 제네릭입니다. 타입이 우리가 원하는 동작을 갖도록 보장하는 대신, 라이프타임은 참조가 필요한 만큼 오랫동안 유효하도록 보장합니다.</p>
<p>4장의 <a href="ch04-02-references-and-borrowing.html#references-and-borrowing">“참조와 대여”</a><!-- ignore --> 섹션에서 논의하지 않은 한 가지 세부 사항은 러스트의 모든 참조에는 _라이프타임_이 있다는 것입니다. 이는 해당 참조가 유효한 스코프입니다. 대부분의 경우 타입이 추론되는 것처럼, 라이프타임도 대부분 암시적이고 추론됩니다. 여러 타입이 가능할 때만 타입을 명시해야 합니다. 마찬가지로, 참조의 라이프타임이 몇 가지 다른 방식으로 연관될 수 있을 때 라이프타임을 명시해야 합니다. 러스트는 런타임에 사용되는 실제 참조가 확실히 유효하도록 보장하기 위해 제네릭 라이프타임 매개변수를 사용하여 관계를 명시할 것을 요구합니다.</p>
<p>라이프타임 명시는 대부분의 다른 프로그래밍 언어에는 없는 개념이므로 낯설게 느껴질 것입니다. 이 장에서 라이프타임 전체를 다루지는 않겠지만, 개념에 익숙해질 수 있도록 라이프타임 문법을 접할 수 있는 일반적인 방법을 논의할 것입니다.</p>
<h3 id="라이프타임으로-댕글링-참조-방지하기"><a class="header" href="#라이프타임으로-댕글링-참조-방지하기">라이프타임으로 댕글링 참조 방지하기</a></h3>
<p>라이프타임의 주된 목적은 _댕글링 참조(dangling references)_를 방지하는 것이며, 이는 프로그램이 의도한 데이터가 아닌 다른 데이터를 참조하게 만드는 원인이 됩니다. 외부 스코프와 내부 스코프가 있는 목록 10-16의 프로그램을 살펴보겠습니다.</p>
<Listing number="10-16" caption="An attempt to use a reference whose value has gone out of scope">
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let r;

    {
        let x = 5;
        r = &amp;x;
    }

    println!("r: {r}");
}</code></pre>
</Listing>
<blockquote>
<p>참고: 목록 10-16, 10-17, 그리고 10-23의 예제들은 초깃값을 주지 않고 변수를 선언하므로, 변수 이름이 외부 스코프에 존재합니다. 이는 언뜻 보기에 널(null) 값이 없는 러스트의 특성과 충돌하는 것처럼 보일 수 있습니다. 하지만 변수에 값을 할당하기 전에 사용하려고 하면 컴파일 타임 에러가 발생하며, 이는 러스트가 실제로 널 값을 허용하지 않는다는 것을 보여줍니다.</p>
</blockquote>
<p>외부 스코프는 초깃값이 없는 <code>r</code>이라는 변수를 선언하고, 내부 스코프는 초깃값이 <code>5</code>인 <code>x</code>라는 변수를 선언합니다. 내부 스코프 안에서 <code>r</code>의 값을 <code>x</code>에 대한 참조로 설정하려고 시도합니다. 그런 다음 내부 스코프가 끝나고 <code>r</code>에 있는 값을 출력하려고 시도합니다. 이 코드는 <code>r</code>이 참조하고 있는 값이 사용하기 전에 스코프를 벗어났기 때문에 컴파일되지 않습니다. 에러 메시지는 다음과 같습니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
 --&gt; src/main.rs:6:13
  |
5 |         let x = 5;
  |             - binding `x` declared here
6 |         r = &amp;x;
  |             ^^ borrowed value does not live long enough
7 |     }
  |     - `x` dropped here while still borrowed
8 |
9 |     println!("r: {r}");
  |                  --- borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>에러 메시지는 변수 <code>x</code>가 “충분히 오래 살지 못한다(does not live long enough)”고 말합니다. 그 이유는 7행에서 내부 스코프가 끝날 때 <code>x</code>가 스코프를 벗어나기 때문입니다. 하지만 <code>r</code>은 여전히 외부 스코프에 대해 유효합니다. 스코프가 더 크기 때문에 우리는 그것이 “더 오래 산다”고 말합니다. 만약 러스트가 이 코드를 작동하도록 허용했다면, <code>r</code>은 <code>x</code>가 스코프를 벗어났을 때 해제된 메모리를 참조하게 될 것이고, <code>r</code>로 하려고 시도하는 모든 것이 올바르게 작동하지 않을 것입니다. 그렇다면 러스트는 이 코드가 유효하지 않다는 것을 어떻게 결정할까요? 바로 빌려주기 검사기(borrow checker)를 사용합니다.</p>
<h3 id="빌려주기-검사기"><a class="header" href="#빌려주기-검사기">빌려주기 검사기</a></h3>
<p>러스트 컴파일러는 모든 대여가 유효한지 결정하기 위해 스코프를 비교하는 _빌려주기 검사기(borrow checker)_를 가지고 있습니다. 목록 10-17은 목록 10-16과 동일한 코드에 변수의 라이프타임을 보여주는 주석을 추가한 것입니다.</p>
<Listing number="10-17" caption="Annotations of the lifetimes of `r` and `x`, named `'a` and `'b`, respectively">
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &amp;x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {r}");   //          |
}                         // ---------+</code></pre>
</Listing>
<p>여기서 우리는 <code>r</code>의 라이프타임을 <code>'a</code>로, <code>x</code>의 라이프타임을 <code>'b</code>로 표시했습니다. 보시다시피, 안쪽의 <code>'b</code> 블록은 바깥쪽의 <code>'a</code> 라이프타임 블록보다 훨씬 작습니다. 컴파일 타임에 러스트는 두 라이프타임의 크기를 비교하고, <code>r</code>의 라이프타임은 <code>'a</code>이지만  라이프타임을 가진 메모리를 참조하고 있음을 확인합니다. <code>'b</code>가 <code>'a</code>보다 짧기 때문에 프로그램은 거부됩니다. 참조의 대상이 참조만큼 오래 살지 못하기 때문입니다.</p>
<p>목록 10-18은 댕글링 참조가 발생하지 않도록 코드를 수정한 것으로, 에러 없이 컴파일됩니다.</p>
<Listing number="10-18" caption="A valid reference because the data has a longer lifetime than the reference">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &amp;x;           // --+-- 'a  |
                          //   |       |
    println!("r: {r}");   //   |       |
                          // --+       |
}                         // ----------+</code></pre></pre>
</Listing>
<p>여기서 <code>x</code>는 라이프타임 <code>'b</code>를 가지며, 이 경우에는 <code>'a</code>보다 큽니다. 이는 러스트가 <code>x</code>가 유효한 동안 <code>r</code>의 참조도 항상 유효하다는 것을 알기 때문에 <code>r</code>이 <code>x</code>를 참조할 수 있음을 의미합니다.</p>
<p>참조의 라이프타임이 어디에 있는지, 그리고 러스트가 참조를 항상 유효하게 보장하기 위해 라이프타임을 어떻게 분석하는지 알게 되었으니, 이제 함수의 문맥에서 매개변수와 반환 값의 제네릭 라이프타임을 살펴보겠습니다.</p>
<h3 id="함수에서의-제네릭-라이프타임"><a class="header" href="#함수에서의-제네릭-라이프타임">함수에서의 제네릭 라이프타임</a></h3>
<p>두 문자열 슬라이스 중 더 긴 것을 반환하는 함수를 작성해 보겠습니다. 이 함수는 두 개의 문자열 슬라이스를 입력받아 하나의 문자열 슬라이스를 반환합니다. <code>longest</code> 함수를 구현한 후, 목록 10-19의 코드는 <code>The longest string is abcd</code>를 출력해야 합니다.</p>
<Listing number="10-19" file-name="src/main.rs" caption="A `main` function that calls the `longest` function to find the longer of two string slices">
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {result}");
}</code></pre>
</Listing>
<p>우리는 <code>longest</code> 함수가 매개변수의 소유권을 가져가는 것을 원하지 않기 때문에, 함수가 <code>String</code> 대신 참조인 문자열 슬라이스를 받기를 원한다는 점에 유의하세요. 목록 10-19에서 우리가 사용하는 매개변수들이 왜 우리가 원하는 것들인지에 대한 더 자세한 논의는 4장의 <a href="ch04-03-slices.html#string-slices-as-parameters">“매개변수로서의 문자열 슬라이스”</a><!-- ignore -->를 참조하세요.</p>
<p>목록 10-20에 나온 것처럼 <code>longest</code> 함수를 구현하려고 하면, 컴파일되지 않습니다.</p>
<Listing number="10-20" file-name="src/main.rs" caption="An implementation of the `longest` function that returns the longer of two string slices but does not yet compile">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}</code></pre>
</Listing>
<p>대신 라이프타임에 관한 다음과 같은 에러가 발생합니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:9:33
  |
9 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
  |               ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
  |
9 | fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
  |           ++++     ++          ++          ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>도움말 텍스트를 보면 반환되는 참조가 <code>x</code>인지 <code>y</code>인지 러스트가 알 수 없기 때문에 반환 타입에 제네릭 라이프타임 매개변수가 필요함을 알 수 있습니다. 사실 우리도 알 수 없는데, 이 함수의 본문에서 <code>if</code> 블록은 <code>x</code>에 대한 참조를 반환하고 <code>else</code> 블록은 <code>y</code>에 대한 참조를 반환하기 때문입니다!</p>
<p>이 함수를 정의할 때 우리는 함수에 어떤 구체적인 값이 전달될지 알 수 없으므로, <code>if</code> 케이스가 실행될지 <code>else</code> 케이스가 실행될지 알 수 없습니다. 또한 전달될 참조들의 구체적인 라이프타임도 알 수 없으므로, 목록 10-17과 10-18에서 했던 것처럼 스코프를 살펴보고 우리가 반환하는 참조가 항상 유효할지 결정할 수도 없습니다. 빌려주기 검사기 역시 <code>x</code>와 <code>y</code>의 라이프타임이 반환 값의 라이프타임과 어떻게 연관되는지 알지 못하기 때문에 이를 결정할 수 없습니다. 이 에러를 수정하기 위해, 빌려주기 검사기가 분석을 수행할 수 있도록 참조들 간의 관계를 정의하는 제네릭 라이프타임 매개변수를 추가하겠습니다.</p>
<h3 id="라이프타임-명시-문법"><a class="header" href="#라이프타임-명시-문법">라이프타임 명시 문법</a></h3>
<p>라이프타임 명시는 참조가 얼마나 오래 사는지에 영향을 주지 않습니다. 그보다는 여러 참조의 라이프타임 간의 관계를 라이프타임에 영향을 주지 않으면서 기술하는 것입니다. 시그니처에 제네릭 타입 매개변수를 지정했을 때 함수가 어떤 타입이든 받아들일 수 있는 것처럼, 제네릭 라이프타임 매개변수를 지정하면 함수가 어떤 라이프타임의 참조든 받아들일 수 있습니다.</p>
<p>라이프타임 명시는 약간 특이한 문법을 가지고 있습니다. 라이프타임 매개변수의 이름은 반드시 어포스트로피(<code>'</code>)로 시작해야 하며, 제네릭 타입처럼 보통은 아주 짧고 모두 소문자입니다. 대부분의 사람들은 첫 번째 라이프타임 명시로 <code>'a</code>라는 이름을 사용합니다. 라이프타임 매개변수 명시는 참조의 <code>&amp;</code> 뒤에 위치하며, 명시와 참조 타입을 구분하기 위해 공백을 하나 둡니다.</p>
<p>여기에 몇 가지 예가 있습니다. 라이프타임 매개변수가 없는 <code>i32</code>에 대한 참조, <code>'a</code>라는 이름의 라이프타임 매개변수가 있는 <code>i32</code>에 대한 참조, 그리고 역시 <code>'a</code>라는 라이프타임을 가진 <code>i32</code>에 대한 가변 참조입니다.</p>
<pre><code class="language-rust ignore">&amp;i32        // 참조
&amp;'a i32     // 명시적인 라이프타임이 있는 참조
&amp;'a mut i32 // 명시적인 라이프타임이 있는 가변 참조</code></pre>
<p>라이프타임 명시 하나만으로는 큰 의미가 없는데, 명시의 목적은 여러 참조의 제네릭 라이프타임 매개변수가 서로 어떻게 연관되는지 러스트에게 알려주는 것이기 때문입니다. <code>longest</code> 함수의 문맥에서 라이프타임 명시들이 서로 어떻게 연관되는지 살펴보겠습니다.</p>
<h3 id="함수-시그니처에서의-라이프타임-명시"><a class="header" href="#함수-시그니처에서의-라이프타임-명시">함수 시그니처에서의 라이프타임 명시</a></h3>
<p>함수 시그니처에서 라이프타임 명시를 사용하려면, 제네릭 <em>타입</em> 매개변수와 마찬가지로 함수 이름과 매개변수 목록 사이의 꺾쇠 괄호 안에 제네릭 <em>라이프타임</em> 매개변수를 선언해야 합니다.</p>
<p>우리는 시그니처가 다음과 같은 제약 조건을 표현하기를 원합니다. 즉, 반환된 참조는 두 매개변수가 모두 유효한 동안에만 유효해야 한다는 것입니다. 이것이 매개변수와 반환 값의 라이프타임 간의 관계입니다. 라이프타임의 이름을 <code>'a</code>라고 짓고, 목록 10-21에 나온 것처럼 각 참조에 추가하겠습니다.</p>
<Listing number="10-21" file-name="src/main.rs" caption="The `longest` function definition specifying that all the references in the signature must have the same lifetime `'a`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}</code></pre></pre>
</Listing>
<p>이 코드는 목록 10-19의 <code>main</code> 함수와 함께 사용했을 때 컴파일되고 우리가 원하는 결과를 생성할 것입니다.</p>
<p>이제 함수 시그니처는 어떤 라이프타임 <code>'a</code>에 대해, 이 함수는 두 개의 매개변수를 받으며 둘 다 적어도 라이프타임 <code>'a</code>만큼은 살아있는 문자열 슬라이스라는 것을 러스트에게 알려줍니다. 또한 이 시그니처는 함수로부터 반환된 문자열 슬라이스도 적어도 라이프타임 <code>'a</code>만큼은 살아있을 것임을 알려줍니다. 실제로 이는 <code>longest</code> 함수에 의해 반환된 참조의 라이프타임이 함수 인수가 참조하는 값들의 라이프타임 중 더 짧은 쪽과 동일하다는 것을 의미합니다. 이러한 관계가 우리가 러스트에게 이 코드를 분석할 때 사용하길 원하는 것입니다.</p>
<p>기억하세요, 이 함수 시그니처에서 라이프타임 매개변수를 지정한다고 해서 전달되거나 반환되는 값의 라이프타임이 변하는 것은 아닙니다. 그보다는 빌려주기 검사기가 이 제약 조건을 지키지 않는 값들을 거부해야 한다고 명시하는 것입니다. <code>longest</code> 함수는 <code>x</code>와 <code>y</code>가 얼마나 오래 살지 정확히 알 필요가 없으며, 단지 이 시그니처를 만족할 수 있는 어떤 스코프가 <code>'a</code>를 대체할 수 있다는 것만 알면 됩니다.</p>
<p>함수에서 라이프타임을 명시할 때, 그 명시는 함수 본문이 아닌 함수 시그니처에 위치합니다. 라이프타임 명시는 시그니처의 타입들과 마찬가지로 함수의 계약(contract) 중 일부가 됩니다. 함수 시그니처가 라이프타임 계약을 포함하게 되면 러스트 컴파일러가 수행하는 분석이 더 단순해질 수 있습니다. 함수가 명시된 방식이나 호출된 방식에 문제가 있다면, 컴파일러 에러는 우리 코드의 해당 부분과 제약 조건을 더 정확하게 가리킬 수 있습니다. 만약 대신 러스트 컴파일러가 우리가 의도한 라이프타임 관계에 대해 더 많은 추론을 한다면, 컴파일러는 문제의 원인으로부터 여러 단계 떨어진 코드 사용 지점만을 가리킬 수밖에 없을 것입니다.</p>
<p><code>longest</code>에 구체적인 참조를 전달할 때, <code>'a</code>를 대체하는 구체적인 라이프타임은 <code>x</code>의 스코프와 <code>y</code>의 스코프가 겹치는 부분입니다. 다시 말해, 제네릭 라이프타임 <code>'a</code>는 <code>x</code>와 <code>y</code>의 라이프타임 중 더 작은 쪽과 동일한 구체적인 라이프타임을 갖게 됩니다. 반환되는 참조를 동일한 라이프타임 매개변수 <code>'a</code>로 명시했으므로, 반환된 참조 또한 <code>x</code>와 <code>y</code>의 라이프타임 중 더 짧은 쪽의 길이 동안 유효할 것입니다.</p>
<p>서로 다른 구체적 라이프타임을 가진 참조를 전달함으로써 라이프타임 명시가 <code>longest</code> 함수를 어떻게 제한하는지 살펴보겠습니다. 목록 10-22는 간단한 예제입니다.</p>
<Listing number="10-22" file-name="src/main.rs" caption="Using the `longest` function with references to `String` values that have different concrete lifetimes">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let string1 = String::from("long string is long");

    {
        let string2 = String::from("xyz");
        let result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {result}");
    }
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 예제에서 <code>string1</code>은 외부 스코프가 끝날 때까지 유효하고, <code>string2</code>는 내부 스코프가 끝날 때까지 유효하며, <code>result</code>는 내부 스코프가 끝날 때까지 유효한 무언가를 참조합니다. 이 코드를 실행하면 빌려주기 검사기가 승인함을 알 수 있습니다. 컴파일될 것이며 <code>The longest string is long string is long</code>을 출력할 것입니다.</p>
<p>다음으로, <code>result</code>에 담긴 참조의 라이프타임이 두 인수 중 더 작은 라이프타임이어야 함을 보여주는 예제를 시도해 보겠습니다. <code>result</code> 변수의 선언을 내부 스코프 밖으로 옮기되, <code>result</code> 변수에 값을 할당하는 것은 <code>string2</code>가 있는 스코프 내부에 남겨두겠습니다. 그런 다음 <code>result</code>를 사용하는 <code>println!</code>을 내부 스코프 밖, 즉 내부 스코프가 끝난 뒤로 옮기겠습니다. 목록 10-23의 코드는 컴파일되지 않습니다.</p>
<Listing number="10-23" file-name="src/main.rs" caption="Attempting to use `result` after `string2` has gone out of scope">
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {result}");
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>이 코드를 컴파일하려고 시도하면, 다음과 같은 에러가 발생합니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `string2` does not live long enough
 --&gt; src/main.rs:6:44
  |
5 |         let string2 = String::from("xyz");
  |             ------- binding `string2` declared here
6 |         result = longest(string1.as_str(), string2.as_str());
  |                                            ^^^^^^^ borrowed value does not live long enough
7 |     }
  |     - `string2` dropped here while still borrowed
8 |     println!("The longest string is {result}");
  |                                     -------- borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>이 에러는 <code>result</code>가 <code>println!</code> 문에서 유효하기 위해서는 <code>string2</code>가 외부 스코프 끝까지 유효해야 함을 보여줍니다. 우리가 함수의 매개변수와 반환 값의 라이프타임을 동일한 라이프타임 매개변수 <code>'a</code>를 사용하여 명시했기 때문에 러스트는 이를 알 수 있습니다.</p>
<p>사람의 관점에서는 이 코드를 보고 <code>string1</code>이 <code>string2</code>보다 길기 때문에 <code>result</code>가 <code>string1</code>에 대한 참조를 갖게 될 것임을 알 수 있습니다. <code>string1</code>은 아직 스코프를 벗어나지 않았으므로, <code>string1</code>에 대한 참조는 <code>println!</code> 문에서 여전히 유효할 것입니다. 하지만 컴파일러는 이 경우에 참조가 유효하다는 것을 알지 못합니다. 우리는 러스트에게 <code>longest</code> 함수가 반환하는 참조의 라이프타임이 전달된 참조들의 라이프타임 중 더 짧은 쪽과 같다고 말했습니다. 따라서 빌려주기 검사기는 목록 10-23의 코드가 유효하지 않은 참조를 가질 가능성이 있다고 보고 허용하지 않습니다.</p>
<p><code>longest</code> 함수에 전달되는 참조의 값과 라이프타임, 그리고 반환된 참조가 사용되는 방식을 다양하게 바꾸며 더 많은 실험을 설계해 보세요. 컴파일하기 전에 여러분의 실험이 빌려주기 검사기를 통과할지 가설을 세워보고, 여러분의 생각이 맞는지 확인해 보세요!</p>
<h3 id="라이프타임의-관점에서-생각하기"><a class="header" href="#라이프타임의-관점에서-생각하기">라이프타임의 관점에서 생각하기</a></h3>
<p>라이프타임 매개변수를 지정해야 하는 방식은 함수가 하는 일에 따라 달라집니다. 예를 들어, <code>longest</code> 함수의 구현을 가장 긴 문자열 슬라이스 대신 항상 첫 번째 매개변수를 반환하도록 변경한다면, <code>y</code> 매개변수에는 라이프타임을 지정할 필요가 없습니다. 다음 코드는 컴파일됩니다:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "efghijklmnopqrstuvwxyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}</code></pre></pre>
</Listing>
<p>우리는 매개변수 <code>x</code>와 반환 타입에 대해서는 라이프타임 매개변수 <code>'a</code>를 지정했지만, 매개변수 <code>y</code>에 대해서는 지정하지 않았습니다. <code>y</code>의 라이프타임은 <code>x</code>나 반환 값의 라이프타임과 아무런 관련이 없기 때문입니다.</p>
<p>함수에서 참조를 반환할 때, 반환 타입의 라이프타임 매개변수는 매개변수 중 하나의 라이프타임 매개변수와 일치해야 합니다. 만약 반환된 참조가 매개변수 중 하나를 참조하지 <em>않는다면</em>, 그것은 반드시 함수 내부에서 생성된 값을 참조해야 합니다. 하지만 이는 함수가 끝날 때 값이 스코프를 벗어나게 되므로 댕글링 참조가 될 것입니다. 다음과 같이 <code>longest</code> 함수를 구현하려고 시도해 보았다고 가정해 봅시다.</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    let result = String::from("really long string");
    result.as_str()
}</code></pre>
</Listing>
<p>여기서 반환 타입에 라이프타임 매개변수 <code>'a</code>를 지정했음에도 불구하고, 반환 값의 라이프타임이 매개변수의 라이프타임과 전혀 관련이 없기 때문에 이 구현은 컴파일에 실패합니다. 우리가 받게 될 에러 메시지는 다음과 같습니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0515]: cannot return value referencing local variable `result`
  --&gt; src/main.rs:11:5
   |
11 |     result.as_str()
   |     ------^^^^^^^^^
   |     |
   |     returns a value referencing data owned by the current function
   |     `result` is borrowed here

For more information about this error, try `rustc --explain E0515`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>문제는 <code>result</code>가 <code>longest</code> 함수가 끝날 때 스코프를 벗어나 메모리에서 해제된다는 점입니다. 그런데 우리는 함수에서 <code>result</code>에 대한 참조를 반환하려고 하고 있습니다. 댕글링 참조를 해결할 수 있는 라이프타임 매개변수를 지정할 방법은 없으며, 러스트는 우리가 댕글링 참조를 만드는 것을 허용하지 않습니다. 이 경우 가장 좋은 해결책은 참조가 아닌 소유권이 있는 데이터 타입을 반환하여 호출한 함수가 값을 해제할 책임을 갖도록 하는 것입니다.</p>
<p>결국 라이프타임 문법은 함수의 다양한 매개변수와 반환 값의 라이프타임을 서로 연결하는 것에 관한 것입니다. 이들이 연결되면, 러스트는 메모리 안전한 연산을 허용하고 댕글링 포인터를 생성하거나 메모리 안전성을 위반하는 연산을 막기에 충분한 정보를 갖게 됩니다.</p>
<h3 id="구조체-정의에서의-라이프타임-명시"><a class="header" href="#구조체-정의에서의-라이프타임-명시">구조체 정의에서의 라이프타임 명시</a></h3>
<p>지금까지 우리가 정의한 구조체들은 모두 소유권이 있는 타입들만 가지고 있었습니다. 참조를 가지는 구조체를 정의할 수도 있지만, 그런 경우에는 구조체 정의에 포함된 모든 참조에 라이프타임 명시를 추가해야 합니다. 목록 10-24에는 문자열 슬라이스를 가지는 <code>ImportantExcerpt</code>라는 구조체가 있습니다.</p>
<Listing number="10-24" file-name="src/main.rs" caption="A struct that holds a reference, requiring a lifetime annotation">
<pre><pre class="playground"><code class="language-rust edition2021">struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().unwrap();
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}</code></pre></pre>
</Listing>
<p>이 구조체는 참조인 문자열 슬라이스를 담는 <code>part</code>라는 하나의 필드를 가집니다. 제네릭 데이터 타입과 마찬가지로, 구조체 이름 뒤의 꺾쇠 괄호 안에 제네릭 라이프타임 매개변수의 이름을 선언하여 구조체 정의 본문에서 라이프타임 매개변수를 사용할 수 있도록 합니다. 이 명시는 <code>ImportantExcerpt</code> 인스턴스가 <code>part</code> 필드에 담긴 참조보다 더 오래 살 수 없음을 의미합니다.</p>
<p>여기서 <code>main</code> 함수는 <code>novel</code> 변수가 소유한 <code>String</code>의 첫 번째 문장에 대한 참조를 담는 <code>ImportantExcerpt</code> 구조체의 인스턴스를 생성합니다. <code>novel</code>에 담긴 데이터는 <code>ImportantExcerpt</code> 인스턴스가 생성되기 전부터 존재합니다. 또한, <code>novel</code>은 <code>ImportantExcerpt</code>가 스코프를 벗어날 때까지 스코프를 벗어나지 않으므로, <code>ImportantExcerpt</code> 인스턴스 안의 참조는 유효합니다.</p>
<h3 id="라이프타임-생략lifetime-elision"><a class="header" href="#라이프타임-생략lifetime-elision">라이프타임 생략(Lifetime Elision)</a></h3>
<p>여러분은 모든 참조에는 라이프타임이 있으며, 참조를 사용하는 함수나 구조체에는 라이프타임 매개변수를 지정해야 한다는 것을 배웠습니다. 하지만 목록 4-9에서 보았고 목록 10-25에서 다시 보여주는 이 함수는 라이프타임 명시 없이도 컴파일됩니다.</p>
<Listing number="10-25" file-name="src/lib.rs" caption="A function we defined in Listing 4-9 that compiled without lifetime annotations, even though the parameter and return type are references">
<pre><pre class="playground"><code class="language-rust edition2021">fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from("hello world");
</span><span class="boring">
</span><span class="boring">    // first_word는 `String`의 슬라이스에 작동합니다
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = "hello world";
</span><span class="boring">
</span><span class="boring">    // first_word는 문자열 리터럴의 슬라이스에 작동합니다
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // 문자열 리터럴은 이미 문자열 슬라이스이기 때문에,
</span><span class="boring">    // 슬라이스 구문 없이도 잘 작동합니다!
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 함수가 라이프타임 명시 없이 컴파일되는 이유는 역사적인 이유가 있습니다. 초기 버전(1.0 이전)의 러스트에서는 모든 참조에 명시적인 라이프타임이 필요했기 때문에 이 코드가 컴파일되지 않았을 것입니다. 당시에는 함수 시그니처를 다음과 같이 작성해야 했습니다:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {</code></pre>
<p>많은 러스트 코드를 작성해본 뒤, 러스트 팀은 러스트 프로그래머들이 특정한 상황에서 똑같은 라이프타임 명시를 반복해서 쓰고 있다는 사실을 발견했습니다. 이러한 상황들은 예측 가능했으며 몇 가지 결정론적인 패턴을 따랐습니다. 개발자들은 빌려주기 검사기가 이러한 상황에서 라이프타임을 추론할 수 있도록 이 패턴들을 컴파일러 코드에 프로그래밍했고, 그 결과 명시적인 라이프타임 명시가 필요 없게 되었습니다.</p>
<p>러스트의 이러한 역사가 중요한 이유는 앞으로 더 많은 결정론적인 패턴들이 발견되어 컴파일러에 추가될 수 있기 때문입니다. 미래에는 훨씬 더 적은 라이프타임 명시만 필요하게 될지도 모릅니다.</p>
<p>참조 분석을 위해 러스트에 프로그래밍된 패턴들을 _라이프타임 생략 규칙(lifetime elision rules)_이라고 부릅니다. 이는 프로그래머가 지켜야 할 규칙이 아닙니다. 컴파일러가 고려하는 몇 가지 특정한 경우의 모음이며, 여러분의 코드가 이 경우에 해당한다면 라이프타임을 명시적으로 작성할 필요가 없습니다.</p>
<p>생략 규칙이 완전한 추론을 제공하는 것은 아닙니다. 만약 러스트가 규칙을 적용한 뒤에도 참조들의 라이프타임에 여전히 모호함이 남아있다면, 컴파일러는 남은 참조들이 어떤 라이프타임을 가져야 할지 추측하지 않습니다. 추측하는 대신, 컴파일러는 에러를 발생시키며 여러분은 라이프타임 명시를 추가하여 이를 해결할 수 있습니다.</p>
<p>함수나 메서드의 매개변수에 대한 라이프타임을 _입력 라이프타임(input lifetimes)_이라고 하며, 반환 값에 대한 라이프타임을 _출력 라이프타임(output lifetimes)_이라고 합니다.</p>
<p>명시적인 라이프타임 명시가 없을 때, 컴파일러는 세 가지 규칙을 사용하여 참조의 라이프타임을 파악합니다. 첫 번째 규칙은 입력 라이프타임에 적용되고, 두 번째와 세 번째 규칙은 출력 라이프타임에 적용됩니다. 만약 컴파일러가 세 가지 규칙을 모두 적용한 뒤에도 라이프타임을 파악할 수 없는 참조가 남아있다면, 컴파일러는 에러와 함께 멈춥니다. 이 규칙들은 <code>fn</code> 정의뿐만 아니라 <code>impl</code> 블록에도 적용됩니다.</p>
<p>첫 번째 규칙은 참조인 각 매개변수에 대해 컴파일러가 라이프타임 매개변수를 할당한다는 것입니다. 즉, 매개변수가 하나인 함수는 하나의 라이프타임 매개변수를 갖습니다: <code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>. 매개변수가 두 개인 함수는 두 개의 개별 라이프타임 매개변수를 갖습니다: <code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>. 이런 식입니다.</p>
<p>두 번째 규칙은 입력 라이프타임 매개변수가 딱 하나라면, 그 라이프타임이 모든 출력 라이프타임 매개변수에 할당된다는 것입니다: <code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>.</p>
<p>세 번째 규칙은 매개변수가 여러 개인 경우, 그것이 메서드라서 그중 하나가 <code>&amp;self</code> 혹은 <code>&amp;mut self</code>라면 <code>self</code>의 라이프타임이 모든 출력 라이프타임 매개변수에 할당된다는 것입니다. 이 세 번째 규칙 덕분에 메서드를 읽고 쓰기가 훨씬 수월해지는데, 필요한 기호들이 적어지기 때문입니다.</p>
<p>우리가 컴파일러라고 가정해 봅시다. 목록 10-25에 있는 <code>first_word</code> 함수 시그니처에서 참조의 라이프타임을 파악하기 위해 이 규칙들을 적용해 보겠습니다. 시그니처는 참조와 관련된 어떤 라이프타임도 없이 시작합니다:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {</code></pre>
<p>그런 다음 컴파일러는 첫 번째 규칙을 적용합니다. 이 규칙은 각 매개변수가 자신만의 라이프타임을 갖도록 명시합니다. 평소처럼 <code>'a</code>라고 부르겠습니다. 이제 시그니처는 다음과 같습니다:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {</code></pre>
<p>입력 라이프타임이 정확히 하나뿐이므로 두 번째 규칙이 적용됩니다. 두 번째 규칙은 하나의 입력 매개변수의 라이프타임이 출력 라이프타임에 할당되도록 명시합니다. 이제 시그니처는 다음과 같습니다:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {</code></pre>
<p>이제 이 함수 시그니처의 모든 참조가 라이프타임을 갖게 되었으며, 컴파일러는 프로그래머가 이 함수 시그니처에 라이프타임을 명시할 필요 없이 분석을 계속할 수 있습니다.</p>
<p>이번에는 목록 10-20에서 작업하기 시작했을 때 라이프타임 매개변수가 없었던 <code>longest</code> 함수를 사용하여 다른 예제를 살펴보겠습니다:</p>
<pre><code class="language-rust ignore">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {</code></pre>
<p>첫 번째 규칙을 적용해 봅시다. 각 매개변수는 자체 라이프타임을 가집니다. 이번에는 매개변수가 하나가 아니라 두 개이므로 두 개의 라이프타임을 가집니다:</p>
<pre><code class="language-rust ignore">fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {</code></pre>
<p>두 번째 규칙은 입력 라이프타임이 하나 이상이므로 적용되지 않습니다. 세 번째 규칙도 <code>longest</code>가 메서드가 아닌 함수이므로 매개변수 중 <code>self</code>가 없기 때문에 적용되지 않습니다. 세 가지 규칙을 모두 적용한 후에도 반환 타입의 라이프타임이 무엇인지 파악하지 못했습니다. 이것이 목록 10-20의 코드를 컴파일하려고 할 때 오류가 발생한 이유입니다. 컴파일러는 라이프타임 생략 규칙을 적용했지만 시그니처의 참조에 대한 모든 라이프타임을 여전히 파악할 수 없었습니다.</p>
<p>세 번째 규칙은 실제로 메서드 시그니처에만 적용되므로, 다음으로 해당 컨텍스트에서 라이프타임을 살펴보고 세 번째 규칙 때문에 메서드 시그니처에 라이프타임을 자주 명시할 필요가 없는 이유를 알아보겠습니다.</p>
<h3 id="메서드-정의의-라이프타임-명시"><a class="header" href="#메서드-정의의-라이프타임-명시">메서드 정의의 라이프타임 명시</a></h3>
<p>라이프타임을 가진 구조체에 메서드를 구현할 때, 목록 10-11에 표시된 것처럼 제네릭 타입 매개변수와 동일한 문법을 사용합니다. 라이프타임 매개변수를 선언하고 사용하는 위치는 구조체 필드와 관련이 있는지, 아니면 메서드 매개변수 및 반환 값과 관련이 있는지에 따라 달라집니다.</p>
<p>구조체 필드의 라이프타임 이름은 항상 <code>impl</code> 키워드 뒤에 선언되어야 하며, 그런 다음 구조체 이름 뒤에 사용되어야 합니다. 왜냐하면 해당 라이프타임은 구조체 타입의 일부이기 때문입니다.</p>
<p><code>impl</code> 블록 내부의 메서드 시그니처에서 참조는 구조체 필드의 참조 라이프타임에 묶여 있을 수도 있고, 독립적일 수도 있습니다. 또한 라이프타임 생략 규칙으로 인해 메서드 시그니처에 라이프타임 명시가 필요 없는 경우가 많습니다. 목록 10-24에서 정의한 <code>ImportantExcerpt</code>라는 구조체를 사용하여 몇 가지 예제를 살펴보겠습니다.</p>
<p>먼저 유일한 매개변수가 <code>self</code>에 대한 참조이고 반환 값이 <code>i32</code>인 <code>level</code>이라는 메서드를 사용할 것입니다. <code>i32</code>는 어떤 것에도 대한 참조가 아닙니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}
<span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
</span><span class="boring">        println!("Attention please: {announcement}");
</span><span class="boring">        self.part
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from("Call me Ishmael. Some years ago...");
</span><span class="boring">    let first_sentence = novel.split('.').next().unwrap();
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}</span></code></pre></pre>
<p><code>impl</code> 뒤의 라이프타임 매개변수 선언과 타입 이름 뒤의 사용은 필수적이지만, 첫 번째 생략 규칙 때문에 <code>self</code>에 대한 참조의 라이프타임을 명시할 필요는 없습니다.</p>
<p>다음은 세 번째 라이프타임 생략 규칙이 적용되는 예제입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn level(&amp;self) -&gt; i32 {
</span><span class="boring">        3
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        println!("Attention please: {announcement}");
        self.part
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from("Call me Ishmael. Some years ago...");
</span><span class="boring">    let first_sentence = novel.split('.').next().unwrap();
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}</span></code></pre></pre>
<p>두 개의 입력 라이프타임이 있으므로, 러스트는 첫 번째 라이프타임 생략 규칙을 적용하여 <code>&amp;self</code>와 <code>announcement</code> 모두에게 자체 라이프타임을 부여합니다. 그런 다음 매개변수 중 하나가 <code>&amp;self</code>이므로 반환 타입은 <code>&amp;self</code>의 라이프타임을 얻게 되며, 모든 라이프타임이 고려됩니다.</p>
<h3 id="정적-라이프타임"><a class="header" href="#정적-라이프타임">정적 라이프타임</a></h3>
<p>논의해야 할 한 가지 특별한 라이프타임은 <code>'static</code>입니다. 이는 영향을 받는 참조가 프로그램의 전체 기간 동안 _살아있을 수 있음_을 나타냅니다. 모든 문자열 리터럴은 <code>'static</code> 라이프타임을 가지며, 다음과 같이 명시할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;'static str = "나는 정적 라이프타임을 가지고 있습니다.";
<span class="boring">}</span></code></pre></pre>
<p>이 문자열의 텍스트는 프로그램의 바이너리에 직접 저장되며, 이는 항상 사용 가능합니다. 따라서 모든 문자열 리터럴의 라이프타임은 <code>'static</code>입니다.</p>
<p>오류 메시지에서 <code>'static</code> 라이프타임을 사용하라는 제안을 볼 수도 있습니다. 하지만 참조에 대해 <code>'static</code>을 라이프타임으로 지정하기 전에, 가지고 있는 참조가 실제로 프로그램의 전체 라이프타임 동안 살아있는지 여부와 그렇게 되기를 원하는지 생각해 보세요. 대부분의 경우, <code>'static</code> 라이프타임을 제안하는 오류 메시지는 매달린 참조를 생성하려 했거나 사용 가능한 라이프타임이 일치하지 않아 발생합니다. 이러한 경우 해결책은 <code>'static</code> 라이프타임을 지정하는 것이 아니라 해당 문제를 해결하는 것입니다.</p>
<h2 id="제네릭-타입-매개변수-트레이트-바운드-및-라이프타임-함께-사용하기"><a class="header" href="#제네릭-타입-매개변수-트레이트-바운드-및-라이프타임-함께-사용하기">제네릭 타입 매개변수, 트레이트 바운드 및 라이프타임 함께 사용하기</a></h2>
<p>제네릭 타입 매개변수, 트레이트 바운드, 라이프타임을 모두 하나의 함수에서 지정하는 문법을 간략하게 살펴보겠습니다!</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest_with_an_announcement(
</span><span class="boring">        string1.as_str(),
</span><span class="boring">        string2,
</span><span class="boring">        "오늘은 누군가의 생일입니다!",
</span><span class="boring">    );
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>use std::fmt::Display;

fn longest_with_an_announcement&lt;'a, T&gt;(
    x: &amp;'a str,
    y: &amp;'a str,
    ann: T,
) -&gt; &amp;'a str
where
    T: Display,
{
    println!("Announcement! {ann}");
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}</code></pre></pre>
<p>이것은 목록 10-21의 <code>longest</code> 함수로, 두 문자열 슬라이스 중 더 긴 것을 반환합니다. 하지만 이제 <code>where</code> 절에 지정된 대로 <code>Display</code> 트레이트를 구현하는 모든 타입으로 채워질 수 있는 제네릭 타입 <code>T</code>의 <code>ann</code>이라는 추가 매개변수를 가집니다. 이 추가 매개변수는 <code>{}</code>를 사용하여 출력될 것이며, 이것이 <code>Display</code> 트레이트 바운드가 필요한 이유입니다. 라이프타임은 제네릭의 한 종류이므로, 라이프타임 매개변수 <code>'a</code>와 제네릭 타입 매개변수 <code>T</code>의 선언은 함수 이름 뒤의 꺾쇠 괄호 안의 동일한 목록에 들어갑니다.</p>
<h2 id="요약-9"><a class="header" href="#요약-9">요약</a></h2>
<p>이 장에서 많은 내용을 다루었습니다! 이제 제네릭 타입 매개변수, 트레이트 및 트레이트 바운드, 제네릭 라이프타임 매개변수에 대해 알게 되었으므로, 다양한 상황에서 작동하는 반복 없는 코드를 작성할 준비가 되었습니다. 제네릭 타입 매개변수를 사용하면 코드를 다른 타입에 적용할 수 있습니다. 트레이트 및 트레이트 바운드는 타입이 제네릭이더라도 코드가 필요로 하는 동작을 가질 수 있도록 보장합니다. 라이프타임 명시를 사용하여 이 유연한 코드가 매달린 참조를 가지지 않도록 보장하는 방법을 배웠습니다. 그리고 이 모든 분석은 컴파일 타임에 이루어지므로 런타임 성능에 영향을 미치지 않습니다!</p>
<p>믿거나 말거나, 이 장에서 논의한 주제에 대해 배울 것이 훨씬 더 많습니다. 18장에서는 트레이트를 사용하는 또 다른 방법인 트레이트 객체에 대해 다룹니다. 또한 매우 고급 시나리오에서만 필요한 라이프타임 명시와 관련된 더 복잡한 시나리오도 있습니다. 이에 대해서는 <a href="../reference/index.html">러스트 참조</a>를 읽어야 합니다. 하지만 다음으로, 코드가 제대로 작동하는지 확인할 수 있도록 러스트에서 테스트를 작성하는 방법을 배울 것입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="자동화된-테스트-작성하기"><a class="header" href="#자동화된-테스트-작성하기">자동화된 테스트 작성하기</a></h1>
<p>1972년 에세이 “겸손한 프로그래머”에서 에츠허르 W. 다익스트라는 “프로그램 테스트는 버그의 존재를 보여주는 매우 효과적인 방법일 수 있지만, 버그의 부재를 보여주는 데는 절망적으로 부적절하다”고 말했습니다. 그렇다고 해서 우리가 할 수 있는 한 많이 테스트하지 말아야 한다는 의미는 아닙니다!</p>
<p>우리 프로그램의 정확성은 코드가 의도한 대로 작동하는 정도를 의미합니다. 러스트는 프로그램의 정확성에 대한 높은 관심으로 설계되었지만, 정확성은 복잡하고 증명하기 쉽지 않습니다. 러스트의 타입 시스템이 이 부담의 상당 부분을 담당하지만, 타입 시스템이 모든 것을 잡아낼 수는 없습니다. 따라서 러스트는 자동화된 소프트웨어 테스트 작성을 지원합니다.</p>
<p>매개변수로 전달된 숫자에 2를 더하는 <code>add_two</code> 함수를 작성한다고 가정해 봅시다. 이 함수의 시그니처는 정수를 매개변수로 받고 정수를 결과로 반환합니다. 이 함수를 구현하고 컴파일할 때, 러스트는 지금까지 배운 모든 타입 검사와 빌림 검사를 수행하여 예를 들어 <code>String</code> 값이나 유효하지 않은 참조를 이 함수에 전달하지 않도록 보장합니다. 하지만 러스트는 이 함수가 우리가 의도한 대로 정확히 작동하는지, 즉 매개변수에 10을 더하거나 50을 빼는 대신 매개변수에 2를 더하는지 <em>확인할 수 없습니다</em>! 바로 이 지점에서 테스트가 필요합니다.</p>
<p>예를 들어, <code>add_two</code> 함수에 <code>3</code>을 전달했을 때 반환 값이 <code>5</code>임을 단언하는 테스트를 작성할 수 있습니다. 코드에 변경 사항이 있을 때마다 이러한 테스트를 실행하여 기존의 올바른 동작이 변경되지 않았는지 확인할 수 있습니다.</p>
<p>테스트는 복잡한 기술입니다. 이 한 장에서 좋은 테스트를 작성하는 모든 세부 사항을 다룰 수는 없지만, 이 장에서는 러스트의 테스트 기능의 메커니즘에 대해 논의할 것입니다. 테스트를 작성할 때 사용할 수 있는 어노테이션과 매크로, 테스트 실행을 위해 제공되는 기본 동작과 옵션, 그리고 테스트를 단위 테스트와 통합 테스트로 구성하는 방법에 대해 이야기할 것입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="테스트-작성-방법"><a class="header" href="#테스트-작성-방법">테스트 작성 방법</a></h2>
<p>테스트는 비테스트 코드가 예상대로 작동하는지 확인하는 러스트 함수입니다. 테스트 함수의 본문은 일반적으로 다음 세 가지 작업을 수행합니다:</p>
<ul>
<li>필요한 데이터 또는 상태를 설정합니다.</li>
<li>테스트하려는 코드를 실행합니다.</li>
<li>결과가 예상한 것과 일치하는지 단언합니다.</li>
</ul>
<p>러스트가 이러한 작업을 수행하는 테스트 작성을 위해 특별히 제공하는 기능을 살펴보겠습니다. 여기에는 <code>test</code> 속성, 몇 가지 매크로, 그리고 <code>should_panic</code> 속성이 포함됩니다.</p>
<h3 id="테스트-함수의-구조"><a class="header" href="#테스트-함수의-구조">테스트 함수의 구조</a></h3>
<p>가장 간단하게, 러스트의 테스트는 <code>test</code> 속성으로 주석이 달린 함수입니다. 속성은 러스트 코드 조각에 대한 메타데이터입니다. 한 가지 예는 5장에서 구조체와 함께 사용했던 <code>derive</code> 속성입니다. 함수를 테스트 함수로 변경하려면 <code>fn</code> 앞에 <code>#[test]</code>를 추가합니다. <code>cargo test</code> 명령으로 테스트를 실행하면, 러스트는 주석이 달린 함수를 실행하고 각 테스트 함수가 통과했는지 실패했는지 보고하는 테스트 러너 바이너리를 빌드합니다.</p>
<p>Cargo로 새 라이브러리 프로젝트를 만들 때마다 테스트 함수가 포함된 테스트 모듈이 자동으로 생성됩니다. 이 모듈은 테스트 작성을 위한 템플릿을 제공하므로 새 프로젝트를 시작할 때마다 정확한 구조와 구문을 찾아볼 필요가 없습니다. 원하는 만큼 추가 테스트 함수와 테스트 모듈을 추가할 수 있습니다!</p>
<p>실제로 코드를 테스트하기 전에 템플릿 테스트를 실험하여 테스트가 어떻게 작동하는지 몇 가지 측면을 탐구할 것입니다. 그런 다음 우리가 작성한 코드를 호출하고 그 동작이 올바른지 단언하는 실제 테스트를 작성할 것입니다.</p>
<p>두 숫자를 더하는 <code>adder</code>라는 새 라이브러리 프로젝트를 만들어 보겠습니다:</p>
<pre><code class="language-console">$ cargo new adder --lib
     Created library `adder` project
$ cd adder
</code></pre>
<p>여러분의 <code>adder</code> 라이브러리의 <em>src/lib.rs</em> 파일 내용은 목록 11-1과 같아야 합니다.</p>
<Listing number="11-1" file-name="src/lib.rs" caption="The code generated automatically by `cargo new`">
<!-- manual-regeneration
cd listings/ch11-writing-automated-tests
rm -rf listing-11-01
cargo new listing-11-01 --lib --name adder
cd listing-11-01
echo "$ cargo test" > output.txt
RUSTFLAGS="-A unused_variables -A dead_code" RUST_TEST_THREADS=1 cargo test >> output.txt 2>&1
git diff output.txt # commit any relevant changes; discard irrelevant ones
cd ../../..
-->
<pre><code class="language-rust noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
</Listing>
<p>파일은 예제 <code>add</code> 함수로 시작하므로, 테스트할 무언가가 있습니다.</p>
<p>지금은 <code>it_works</code> 함수에만 집중해 봅시다. <code>#[test]</code> 어노테이션에 주목하세요. 이 속성은 이것이 테스트 함수임을 나타내므로, 테스트 러너는 이 함수를 테스트로 처리해야 한다는 것을 압니다. <code>tests</code> 모듈에는 공통 시나리오를 설정하거나 공통 작업을 수행하는 데 도움이 되는 비테스트 함수도 있을 수 있으므로, 어떤 함수가 테스트인지 항상 표시해야 합니다.</p>
<p>예제 함수 본문은 <code>assert_eq!</code> 매크로를 사용하여 2와 2를 더한 <code>add</code> 호출의 결과인 <code>result</code>가 4와 같음을 단언합니다. 이 단언은 일반적인 테스트 형식의 예시 역할을 합니다. 이 테스트가 통과하는지 확인하기 위해 실행해 봅시다.</p>
<p>목록 11-2에 나온 것처럼 <code>cargo test</code> 명령은 프로젝트의 모든 테스트를 실행합니다.</p>
<Listing number="11-2" caption="The output from running the automatically generated test">
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.57s
     Running unittests src/lib.rs (file:///projects/adder/target/debug/deps/adder-7acb243c25ffd9dc)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
</Listing>
<p>Cargo가 테스트를 컴파일하고 실행했습니다. <code>running 1 test</code> 줄이 보입니다. 다음 줄은 생성된 테스트 함수 <code>tests::it_works</code>의 이름과 해당 테스트 실행 결과가 <code>ok</code>임을 보여줍니다. 전체 요약 <code>test result: ok.</code>는 모든 테스트가 통과했음을 의미하며, <code>1 passed; 0 failed</code> 부분은 통과하거나 실패한 테스트의 총 개수를 나타냅니다.</p>
<p>특정 인스턴스에서 실행되지 않도록 테스트를 무시로 표시할 수 있습니다. 이에 대해서는 이 장의 뒷부분에 있는 <a href="ch11-02-running-tests.html#ignoring-some-tests-unless-specifically-requested">“특별히 요청하지 않는 한 일부 테스트 무시하기”</a><!-- ignore --> 섹션에서 다룰 것입니다. 여기서는 그렇게 하지 않았으므로 요약에는 <code>0 ignored</code>가 표시됩니다. <code>cargo test</code> 명령에 문자열과 이름이 일치하는 테스트만 실행하도록 인수를 전달할 수도 있습니다. 이를 _필터링_이라고 하며, <a href="ch11-02-running-tests.html#running-a-subset-of-tests-by-name">“이름으로 테스트 하위 집합 실행하기”</a><!-- ignore --> 섹션에서 다룰 것입니다. 여기서는 실행되는 테스트를 필터링하지 않았으므로 요약 끝에는 <code>0 filtered out</code>이 표시됩니다.</p>
<p><code>0 measured</code> 통계는 성능을 측정하는 벤치마크 테스트를 위한 것입니다. 벤치마크 테스트는 이 글을 쓰는 시점에는 nightly Rust에서만 사용할 수 있습니다. 자세한 내용은 <a href="../unstable-book/library-features/test.html">벤치마크 테스트에 대한 문서</a>를 참조하세요.</p>
<p><code>Doc-tests adder</code>에서 시작하는 테스트 출력의 다음 부분은 모든 문서 테스트 결과에 대한 것입니다. 아직 문서 테스트는 없지만, 러스트는 API 문서에 나타나는 모든 코드 예제를 컴파일할 수 있습니다. 이 기능은 문서와 코드를 동기화하는 데 도움이 됩니다! 14장의 <a href="ch14-02-publishing-to-crates-io.html#documentation-comments-as-tests">“테스트로서의 문서 주석”</a><!-- ignore --> 섹션에서 문서 테스트를 작성하는 방법을 논의할 것입니다. 지금은 <code>Doc-tests</code> 출력을 무시하겠습니다.</p>
<p>이제 테스트를 우리의 필요에 맞게 사용자 정의해 봅시다. 먼저 <code>it_works</code> 함수의 이름을 <code>exploration</code>과 같은 다른 이름으로 변경합니다. 다음과 같이 말이죠:</p>
<p><span class="filename">파일명: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn exploration() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<p>그런 다음 <code>cargo test</code>를 다시 실행합니다. 이제 출력은 <code>it_works</code> 대신 <code>exploration</code>을 보여줍니다:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.59s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>이제 또 다른 테스트를 추가할 것입니다. 하지만 이번에는 실패하는 테스트를 만들 것입니다! 테스트 함수 내에서 무언가가 패닉을 일으키면 테스트는 실패합니다. 각 테스트는 새 스레드에서 실행되며, 메인 스레드가 테스트 스레드가 종료된 것을 확인하면 테스트는 실패로 표시됩니다. 9장에서 가장 간단한 패닉 방법은 <code>panic!</code> 매크로를 호출하는 것이라고 이야기했습니다. 새 테스트를 <code>another</code>라는 함수로 입력하면 <em>src/lib.rs</em> 파일은 목록 11-3과 같아집니다.</p>
<Listing number="11-3" file-name="src/lib.rs" caption="Adding a second test that will fail because we call the `panic!` macro">
<pre><code class="language-rust panics noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn exploration() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }

    #[test]
    fn another() {
        panic!("이 테스트를 실패하게 만드세요");
    }
}</code></pre>
</Listing>
<p><code>cargo test</code>를 사용하여 테스트를 다시 실행합니다. 출력은 목록 11-4와 같아야 하며, <code>exploration</code> 테스트는 통과하고 <code>another</code> 테스트는 실패했음을 보여줍니다.</p>
<Listing number="11-4" caption="Test results when one test passes and one test fails">
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.72s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::another ... FAILED
test tests::exploration ... ok

failures:

---- tests::another stdout ----
thread 'tests::another' panicked at src/lib.rs:17:9:
Make this test fail
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
</Listing>
<!-- manual-regeneration
rg panicked listings/ch11-writing-automated-tests/listing-11-03/output.txt
check the line number of the panic matches the line number in the following paragraph
 -->
<p><code>ok</code> 대신 <code>test tests::another</code> 줄은 <code>FAILED</code>를 보여줍니다. 개별 결과와 요약 사이에 두 개의 새로운 섹션이 나타납니다. 첫 번째 섹션은 각 테스트 실패에 대한 자세한 이유를 표시합니다. 이 경우 <code>another</code>가 <em>src/lib.rs</em> 파일의 17번째 줄에서 <code>panicked at 'Make this test fail'</code>로 인해 실패했다는 세부 정보를 얻습니다. 다음 섹션은 실패한 모든 테스트의 이름만 나열하며, 이는 많은 테스트와 많은 자세한 실패 테스트 출력이 있을 때 유용합니다. 실패한 테스트의 이름을 사용하여 해당 테스트만 실행하여 더 쉽게 디버깅할 수 있습니다. <a href="ch11-02-running-tests.html#controlling-how-tests-are-run">“테스트 실행 방법 제어하기”</a><!-- ignore --> 섹션에서 테스트 실행 방법에 대해 더 자세히 이야기할 것입니다.</p>
<p>요약 줄은 마지막에 표시됩니다. 전체적으로 테스트 결과는 <code>FAILED</code>입니다. 하나의 테스트가 통과했고 하나의 테스트가 실패했습니다.</p>
<p>이제 다양한 시나리오에서 테스트 결과가 어떻게 보이는지 확인했으니, 테스트에 유용한 <code>panic!</code> 외의 다른 매크로들을 살펴보겠습니다.</p>
<h3 id="assert-매크로로-결과-확인하기"><a class="header" href="#assert-매크로로-결과-확인하기"><code>assert!</code> 매크로로 결과 확인하기</a></h3>
<p>표준 라이브러리에서 제공하는 <code>assert!</code> 매크로는 테스트의 어떤 조건이 <code>true</code>임을 보장하고 싶을 때 유용합니다. <code>assert!</code> 매크로에는 불리언으로 평가되는 인수를 전달합니다. 값이 <code>true</code>이면 아무 일도 일어나지 않고 테스트는 통과합니다. 값이 <code>false</code>이면 <code>assert!</code> 매크로는 <code>panic!</code>을 호출하여 테스트를 실패하게 만듭니다. <code>assert!</code> 매크로를 사용하면 우리 코드가 의도한 대로 작동하는지 확인하는 데 도움이 됩니다.</p>
<p>5장 목록 5-15에서 <code>Rectangle</code> 구조체와 <code>can_hold</code> 메서드를 사용했는데, 이는 목록 11-5에 다시 반복됩니다. 이 코드를 <em>src/lib.rs</em> 파일에 넣고, <code>assert!</code> 매크로를 사용하여 몇 가지 테스트를 작성해 봅시다.</p>
<Listing number="11-5" file-name="src/lib.rs" caption="The `Rectangle` struct and its `can_hold` method from Chapter 5">
<pre><code class="language-rust noplayground">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}</code></pre>
</Listing>
<p><code>can_hold</code> 메서드는 불리언을 반환하므로, <code>assert!</code> 매크로에 완벽한 사용 사례입니다. 목록 11-6에서는 너비 8, 높이 7인 <code>Rectangle</code> 인스턴스를 생성하고, 너비 5, 높이 1인 다른 <code>Rectangle</code> 인스턴스를 담을 수 있음을 단언하여 <code>can_hold</code> 메서드를 테스트하는 코드를 작성합니다.</p>
<Listing number="11-6" file-name="src/lib.rs" caption="A test for `can_hold` that checks whether a larger rectangle can indeed hold a smaller rectangle">
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(larger.can_hold(&amp;smaller));
    }
}</code></pre>
</Listing>
<p>Note the <code>use super::*;</code> line inside the <code>tests</code> module. The <code>tests</code> module is a regular module that follows the usual visibility rules we covered in Chapter 7 in the <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“Paths for Referring to an Item in the Module Tree”</a><!-- ignore --> section. Because the <code>tests</code> module is an inner module, we need to bring the code under test in the outer module into the scope of the inner module. We use a glob here, so anything we define in the outer module is available to this <code>tests</code> module.</p>
<p>우리는 테스트 이름을 <code>larger_can_hold_smaller</code>로 지정했고, 필요한 두 <code>Rectangle</code> 인스턴스를 생성했습니다. 그런 다음 <code>assert!</code> 매크로를 호출하고 <code>larger.can_hold(&amp;smaller)</code> 호출 결과를 전달했습니다. 이 표현식은 <code>true</code>를 반환해야 하므로 테스트는 통과해야 합니다. 확인해 봅시다!</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>통과했습니다! 이제 다른 테스트를 추가해 봅시다. 이번에는 더 작은 사각형이 더 큰 사각형을 담을 수 없음을 단언하는 테스트입니다:</p>
<p><span class="filename">파일명: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        // --생략--
<span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span>    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(!smaller.can_hold(&amp;larger));
    }
}</code></pre>
<p>이 경우 <code>can_hold</code> 함수의 올바른 결과는 <code>false</code>이므로, <code>assert!</code> 매크로에 전달하기 전에 그 결과를 부정해야 합니다. 결과적으로 <code>can_hold</code>가 <code>false</code>를 반환하면 테스트는 통과할 것입니다:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... ok
test tests::smaller_cannot_hold_larger ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>두 개의 테스트가 통과했습니다! 이제 코드에 버그를 도입했을 때 테스트 결과가 어떻게 되는지 살펴봅시다. 너비를 비교할 때 <code>can_hold</code> 메서드의 구현에서 크다 기호를 작다 기호로 변경할 것입니다:</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>// --생략--
impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &lt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn larger_can_hold_smaller() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn smaller_cannot_hold_larger() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(!smaller.can_hold(&amp;larger));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>이제 테스트를 실행하면 다음과 같은 결과가 나옵니다:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... FAILED
test tests::smaller_cannot_hold_larger ... ok

failures:

---- tests::larger_can_hold_smaller stdout ----
thread 'tests::larger_can_hold_smaller' panicked at src/lib.rs:28:9:
assertion failed: larger.can_hold(&amp;smaller)
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>우리 테스트가 버그를 잡았습니다! <code>larger.width</code>는 <code>8</code>이고 <code>smaller.width</code>는 <code>5</code>이므로, <code>can_hold</code>에서의 너비 비교는 이제 <code>false</code>를 반환합니다. 8은 5보다 작지 않기 때문입니다.</p>
<h3 id="assert_eq와-assert_ne-매크로를-이용한-공통성-테스트"><a class="header" href="#assert_eq와-assert_ne-매크로를-이용한-공통성-테스트"><code>assert_eq!</code>와 <code>assert_ne!</code> 매크로를 이용한 공통성 테스트</a></h3>
<p>기능을 검증하는 일반적인 방법은 테스트 중인 코드의 결과와 코드가 반환할 것으로 기대하는 값 사이의 일치 여부를 테스트하는 것입니다. 이는 <code>assert!</code> 매크로에 <code>==</code> 연산자를 사용하는 표현식을 전달하여 수행할 수 있습니다. 하지만 이는 매우 흔한 테스트이므로, 표준 라이브러리는 이 테스트를 더 편리하게 수행할 수 있도록 <code>assert_eq!</code>와 <code>assert_ne!</code>라는 한 쌍의 매크로를 제공합니다. 이 매크로들은 각각 두 인수를 비교하여 같은지 또는 다른지 확인합니다. 또한 단언(assertion)이 실패할 경우 두 값을 모두 출력하므로, 테스트가 <em>왜</em> 실패했는지 더 쉽게 알 수 있습니다. 반면 <code>assert!</code> 매크로는 <code>==</code> 표현식에 대해 <code>false</code> 값을 얻었다는 것만 알려줄 뿐, <code>false</code> 값을 유도한 두 값들을 출력하지는 않습니다.</p>
<p>목록 11-7에서는 매개변수에 <code>2</code>를 더하는 <code>add_two</code> 함수를 작성하고, <code>assert_eq!</code> 매크로를 사용하여 이 함수를 테스트합니다.</p>
<Listing number="11-7" file-name="src/lib.rs" caption="Testing the function `add_two` using the `assert_eq!` macro">
<pre><code class="language-rust noplayground">pub fn add_two(a: usize) -&gt; usize {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        let result = add_two(2);
        assert_eq!(result, 4);
    }
}</code></pre>
</Listing>
<p>통과하는지 확인해 봅시다!</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p><code>add_two(2)</code>를 호출한 결과를 담는 <code>result</code>라는 변수를 생성합니다. 그런 다음 <code>result</code>와 <code>4</code>를 <code>assert_eq!</code>의 인수로 전달합니다. 이 테스트의 출력 라인은 <code>test tests::it_adds_two ... ok</code>이며, <code>ok</code> 텍스트는 우리 테스트가 통과했음을 나타냅니다!</p>
<p>실패했을 때 <code>assert_eq!</code>가 어떻게 보이는지 확인하기 위해 코드에 버그를 도입해 봅시다. <code>add_two</code> 함수의 구현을 <code>2</code> 대신 <code>3</code>을 더하도록 변경합니다:</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn add_two(a: usize) -&gt; usize {
    a + 3
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_adds_two() {
</span><span class="boring">        let result = add_two(2);
</span><span class="boring">        assert_eq!(result, 4);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>테스트를 다시 실행합니다:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----
thread 'tests::it_adds_two' panicked at src/lib.rs:12:9:
assertion `left == right` failed
  left: 5
 right: 4
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>우리 테스트가 버그를 잡았습니다! <code>it_adds_two</code> 테스트가 실패했고, 메시지는 실패한 단언이 <code>assertion `left == right` failed</code>라는 것과 <code>left</code> 및 <code>right</code> 값이 무엇인지 알려줍니다. 이 메시지는 디버깅을 시작하는 데 도움이 됩니다. <code>add_two(2)</code>를 호출한 결과인 <code>left</code> 인수는 <code>5</code>였지만, <code>right</code> 인수는 <code>4</code>였습니다. 테스트가 많을 때 이 메시지가 특히 얼마나 도움이 될지 상상하실 수 있을 것입니다.</p>
<p>어떤 언어나 테스트 프레임워크에서는 일치 여부 단언 함수의 매개변수를 <code>expected</code>와 <code>actual</code>이라고 부르며, 인수를 지정하는 순서가 중요합니다. 하지만 러스트에서는 <code>left</code>와 <code>right</code>라고 부르며, 우리가 기대하는 값과 코드가 생성한 값의 순서는 중요하지 않습니다. 이 테스트의 단언을 <code>assert_eq!(4, result)</code>라고 작성할 수도 있으며, 이 경우에도 여전히 <code>assertion failed: `(left == right)`</code>라는 동일한 실패 메시지가 나타날 것입니다.</p>
<p><code>assert_ne!</code> 매크로는 우리가 전달한 두 값이 서로 같지 않으면 통과하고, 같으면 실패합니다. 이 매크로는 어떤 값이 <em>무엇이 될지</em> 확신할 수는 없지만, 무엇이 <em>되어서는 안 되는지</em> 확실히 알고 있는 경우에 가장 유용합니다. 예를 들어, 입력값을 어떤 식으로든 변경하는 것이 보장된 함수를 테스트하는데, 그 변경 방식이 테스트를 실행하는 요일에 따라 달라진다면, 함수의 출력값이 입력값과 같지 않음을 단언하는 것이 가장 좋은 방법일 수 있습니다.</p>
<p>내부적으로 <code>assert_eq!</code>와 <code>assert_ne!</code> 매크로는 각각 <code>==</code>와 <code>!=</code> 연산자를 사용합니다. 단언이 실패할 경우, 이 매크로들은 디버그 포맷팅을 사용하여 인수들을 출력합니다. 이는 비교 대상이 되는 값들이 반드시 <code>PartialEq</code>와 <code>Debug</code> 트레이트를 구현해야 함을 의미합니다. 모든 기본 타입들과 대부분의 표준 라이브러리 타입들은 이 트레이트들을 구현하고 있습니다. 직접 정의한 구조체나 열거형의 경우, 해당 타입의 일치 여부를 단언하려면 <code>PartialEq</code>를 구현해야 합니다. 또한 단언이 실패했을 때 값을 출력하려면 <code>Debug</code>도 구현해야 합니다. 5장의 목록 5-12에서 언급했듯이 두 트레이트 모두 파생 가능한(derivable) 트레이트이므로, 구조체나 열거형 정의 위에 <code>#[derive(PartialEq, Debug)]</code> 어노테이션을 추가하는 것만으로 충분한 경우가 많습니다. 이 트레이트들과 다른 파생 가능한 트레이트들에 대한 자세한 내용은 부록 C, <a href="appendix-03-derivable-traits.html">“파생 가능한 트레이트”</a><!-- ignore -->를 참조하세요.</p>
<h3 id="커스텀-실패-메시지-추가하기"><a class="header" href="#커스텀-실패-메시지-추가하기">커스텀 실패 메시지 추가하기</a></h3>
<p><code>assert!</code>, <code>assert_eq!</code>, <code>assert_ne!</code> 매크로의 선택적 인수로 실패 메시지와 함께 출력될 커스텀 메시지를 추가할 수도 있습니다. 필수 인수 뒤에 지정된 모든 인수는 <code>format!</code> 매크로(8장의 <a href="ch08-02-strings.html#concatenation-with-the--operator-or-the-format-macro">“<code>+</code> 연산자나 <code>format!</code> 매크로를 이용한 연결”</a><!-- ignore -->에서 다룸)로 전달되므로, <code>{}</code> 자리표시자와 그 안에 들어갈 값들을 포함한 포맷 문자열을 전달할 수 있습니다. 커스텀 메시지는 단언이 무엇을 의미하는지 문서화하는 데 유용하며, 테스트가 실패했을 때 코드의 어떤 부분이 문제인지 더 잘 파악할 수 있게 해줍니다.</p>
<p>예를 들어, 사람의 이름을 받아 인사를 하는 함수가 있고, 함수에 전달한 이름이 출력 결과에 포함되는지 테스트하고 싶다고 가정해 봅시다:</p>
<p><span class="filename">파일명: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    format!("Hello {name}!")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting("Carol");
        assert!(result.contains("Carol"));
    }
}</code></pre>
<p>이 프로그램의 요구사항은 아직 합의되지 않았으며, 인삿말 시작 부분의 <code>Hello</code>라는 텍스트가 바뀔 것이 거의 확실합니다. 우리는 요구사항이 바뀔 때마다 테스트를 업데이트하고 싶지 않으므로, <code>greeting</code> 함수에서 반환된 값과 정확히 일치하는지 확인하는 대신, 출력이 입력 매개변수의 텍스트를 포함하고 있는지만 단언하기로 결정했습니다.</p>
<p>이제 기본 테스트 실패가 어떻게 보이는지 확인하기 위해, <code>greeting</code>에서 <code>name</code>을 제외하도록 코드를 수정하여 버그를 도입해 봅시다:</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    String::from("Hello!")
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greeting_contains_name() {
</span><span class="boring">        let result = greeting("Carol");
</span><span class="boring">        assert!(result.contains("Carol"));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>이 테스트를 실행하면 다음과 같은 결과가 나옵니다:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:
assertion failed: result.contains("Carol")
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>이 결과는 단지 단언이 실패했다는 것과 단언이 몇 번째 줄에 있는지만을 알려줍니다. 더 유용한 실패 메시지는 <code>greeting</code> 함수로부터 얻은 값을 출력하는 것입니다. <code>greeting</code> 함수로부터 실제로 얻은 값을 자리표시자에 채워 넣는 포맷 문자열로 구성된 커스텀 실패 메시지를 추가해 봅시다:</p>
<pre><code class="language-rust ignore"><span class="boring">pub fn greeting(name: &amp;str) -&gt; String {
</span><span class="boring">    String::from("Hello!")
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn greeting_contains_name() {
        let result = greeting("Carol");
        assert!(
            result.contains("Carol"),
            "Greeting did not contain name, value was `{result}`"
        );
    }
<span class="boring">}</span></code></pre>
<p>이제 테스트를 실행하면 더 많은 정보를 담은 에러 메시지를 얻게 됩니다:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.93s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:
Greeting did not contain name, value was `Hello!`
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>테스트 출력에서 실제로 얻은 값을 확인할 수 있으며, 이는 우리가 기대했던 일 대신 어떤 일이 일어났는지 디버깅하는 데 도움이 될 것입니다.</p>
<h3 id="should_panic을-이용한-패닉-확인"><a class="header" href="#should_panic을-이용한-패닉-확인"><code>should_panic</code>을 이용한 패닉 확인</a></h3>
<p>반환 값을 확인하는 것뿐만 아니라, 우리 코드가 예상대로 에러 조건을 처리하는지 확인하는 것도 중요합니다. 예를 들어, 9장의 목록 9-13에서 만들었던 <code>Guess</code> 타입을 생각해 봅시다. <code>Guess</code>를 사용하는 다른 코드들은 <code>Guess</code> 인스턴스가 1에서 100 사이의 값만을 포함한다는 보장에 의존합니다. 우리는 해당 범위를 벗어나는 값으로 <code>Guess</code> 인스턴스를 생성하려 할 때 패닉이 발생하는지 보장하는 테스트를 작성할 수 있습니다.</p>
<p>이는 테스트 함수에 <code>should_panic</code> 속성을 추가함으로써 가능합니다. 이 속성이 추가된 테스트는 함수 내부의 코드가 패닉을 일으키면 통과하고, 패닉을 일으키지 않으면 실패합니다.</p>
<p>목록 11-8은 <code>Guess::new</code>의 에러 조건이 우리가 예상한 대로 발생하는지 확인하는 테스트를 보여줍니다.</p>
<Listing number="11-8" file-name="src/lib.rs" caption="Testing that a condition will cause a `panic!`">
<pre><code class="language-rust noplayground">pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(추측 값은 1에서 100 사이여야 합니다. {value}를 받았습니다.);
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}</code></pre>
</Listing>
<p><code>#[should_panic]</code> 속성은 <code>#[test]</code> 속성 뒤, 그리고 해당 속성이 적용될 테스트 함수 앞에 배치합니다. 이 테스트가 통과했을 때의 결과를 살펴봅시다:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests guessing_game

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>좋군요! 이제 100보다 큰 값일 때 <code>new</code> 함수가 패닉을 일으켜야 한다는 조건을 제거하여 코드에 버그를 도입해 봅시다:</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --생략--
impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(추측 값은 1에서 100 사이여야 합니다. {value}를 받았습니다.);
        }

        Guess { value }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>목록 11-8의 테스트를 실행하면, 다음과 같이 실패할 것입니다:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
note: test did not panic as expected

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>이 경우에는 아주 도움이 되는 메시지를 얻지는 못하지만, 테스트 함수를 살펴보면 <code>#[should_panic]</code>이 달려 있는 것을 볼 수 있습니다. 우리가 받은 실패는 테스트 함수 내의 코드가 패닉을 일으키지 않았음을 의미합니다.</p>
<p><code>should_panic</code>을 사용하는 테스트는 부정확할 수 있습니다. 우리가 예상한 이유와 다른 이유로 패닉이 발생하더라도 <code>should_panic</code> 테스트는 통과될 수 있기 때문입니다. <code>should_panic</code> 테스트를 더 정확하게 만들기 위해 <code>should_panic</code> 속성에 선택적인 <code>expected</code> 매개변수를 추가할 수 있습니다. 테스트 하네스는 실패 메시지가 제공된 텍스트를 포함하는지 확인합니다. 예를 들어, 목록 11-9와 같이 값이 너무 작거나 큰지에 따라 다른 메시지로 패닉을 일으키도록 수정된 <code>Guess</code> 코드를 생각해 봅시다.</p>
<Listing number="11-9" file-name="src/lib.rs" caption="Testing for a `panic!` with a panic message containing a specified substring">
<pre><code class="language-rust noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --생략--

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(
                "Guess value must be greater than or equal to 1, got {value}."
            );
        } else if value &gt; 100 {
            panic!(
                "Guess value must be less than or equal to 100, got {value}."
            );
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = "less than or equal to 100")]
    fn greater_than_100() {
        Guess::new(200);
    }
}</code></pre>
</Listing>
<p>이 테스트는 통과하는데, <code>should_panic</code> 속성의 <code>expected</code> 매개변수에 넣은 값이 <code>Guess::new</code> 함수가 패닉을 일으킬 때의 메시지의 부분 문자열이기 때문입니다. 우리가 기대하는 전체 패닉 메시지를 지정할 수도 있었는데, 이 경우에는 <code>Guess value must be less than or equal to 100, got 200</code>이 될 것입니다. 무엇을 지정할지는 패닉 메시지의 얼마나 많은 부분이 고유하거나 동적인지, 그리고 테스트를 얼마나 정밀하게 만들고 싶은지에 따라 달라집니다. 이번 경우에는 패닉 메시지의 부분 문자열만으로도 테스트 함수의 코드가 <code>else if value &gt; 100</code> 케이스를 실행하는지 보장하기에 충분합니다.</p>
<p><code>expected</code> 메시지가 있는 <code>should_panic</code> 테스트가 실패하면 어떤 일이 일어나는지 확인하기 위해, <code>if value &lt; 1</code> 블록과 <code>else if value &gt; 100</code> 블록의 본문을 서로 바꿔서 코드에 다시 버그를 도입해 봅시다:</p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Guess {
</span><span class="boring">    pub fn new(value: i32) -&gt; Guess {
</span>        if value &lt; 1 {
            panic!(
                "Guess value must be less than or equal to 100, got {value}."
            );
        } else if value &gt; 100 {
            panic!(
                "Guess value must be greater than or equal to 1, got {value}."
            );
        }
<span class="boring">
</span><span class="boring">        Guess { value }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic(expected = "less than or equal to 100")]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>이번에 <code>should_panic</code> 테스트를 실행하면, 다음과 같이 실패할 것입니다:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
thread 'tests::greater_than_100' panicked at src/lib.rs:12:13:
Guess value must be greater than or equal to 1, got 200.
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
note: panic did not contain expected string
      panic message: `"Guess value must be greater than or equal to 1, got 200."`,
 expected substring: `"less than or equal to 100"`

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>실패 메시지는 이 테스트가 우리가 예상한 대로 실제로 패닉을 일으켰음을 나타내지만, 패닉 메시지에 기대했던 문자열인 <code>less than or equal to 100</code>이 포함되지 않았습니다. 이 경우 우리가 실제로 받은 패닉 메시지는 <code>Guess value must be greater than or equal to 1, got 200.</code>이었습니다. 이제 우리 버그가 어디에 있는지 파악하기 시작할 수 있습니다!</p>
<h3 id="테스트에서-resultt-e-사용하기"><a class="header" href="#테스트에서-resultt-e-사용하기">테스트에서 <code>Result&lt;T, E&gt;</code> 사용하기</a></h3>
<p>지금까지의 테스트들은 실패할 때 모두 패닉을 일으켰습니다. <code>Result&lt;T, E&gt;</code>를 사용하는 테스트를 작성할 수도 있습니다! 목록 11-1의 테스트를 패닉 대신 <code>Result&lt;T, E&gt;</code>를 사용하고 <code>Err</code>을 반환하도록 다시 작성하면 다음과 같습니다:</p>
<pre><code class="language-rust noplayground"><span class="boring">pub fn add(left: u64, right: u64) -&gt; u64 {
</span><span class="boring">    left + right
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn it_works() -&gt; Result&lt;(), String&gt; {
        let result = add(2, 2);

        if result == 4 {
            Ok(())
        } else {
            Err(String::from("two plus two does not equal four"))
        }
    }
<span class="boring">}</span></code></pre>
<p>이제 <code>it_works</code> 함수는 <code>Result&lt;(), String&gt;</code> 반환 타입을 가집니다. 함수 본문에서 <code>assert_eq!</code> 매크로를 호출하는 대신, 테스트가 통과하면 <code>Ok(())</code>를 반환하고 테스트가 실패하면 <code>String</code>을 담은 <code>Err</code>을 반환합니다.</p>
<p>테스트가 <code>Result&lt;T, E&gt;</code>를 반환하도록 작성하면 테스트 본문에서 물음표 연산자를 사용할 수 있습니다. 이는 내부의 어떤 연산이라도 <code>Err</code> 변형을 반환할 경우 실패해야 하는 테스트를 작성하는 편리한 방법이 될 수 있습니다.</p>
<p><code>Result&lt;T, E&gt;</code>를 사용하는 테스트에는 <code>#[should_panic]</code> 어노테이션을 사용할 수 없습니다. 어떤 연산이 <code>Err</code> 변형을 반환함을 단언하려면, <code>Result&lt;T, E&gt;</code> 값에 물음표 연산자를 사용하지 <em>마세요</em>. 대신 <code>assert!(value.is_err())</code>를 사용하세요.</p>
<p>이제 테스트를 작성하는 여러 가지 방법을 알게 되었으니, 테스트를 실행할 때 어떤 일이 일어나는지 살펴보고 <code>cargo test</code>와 함께 사용할 수 있는 다양한 옵션들을 탐구해 봅시다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="테스트-실행-방법-제어하기"><a class="header" href="#테스트-실행-방법-제어하기">테스트 실행 방법 제어하기</a></h2>
<p><code>cargo run</code>이 코드를 컴파일하고 결과 바이너리를 실행하는 것과 마찬가지로, <code>cargo test</code>는 테스트 모드에서 코드를 컴파일하고 결과 테스트 바이너리를 실행합니다. <code>cargo test</code>로 생성된 바이너리의 기본 동작은 모든 테스트를 병렬로 실행하고 테스트 실행 중에 생성된 출력을 캡처하여 출력이 표시되지 않도록 함으로써 테스트 결과와 관련된 출력을 읽기 쉽게 만드는 것입니다. 하지만 커맨드 라인 옵션을 지정하여 이러한 기본 동작을 변경할 수 있습니다.</p>
<p>어떤 커맨드 라인 옵션은 <code>cargo test</code>로 전달되고, 어떤 옵션은 결과 테스트 바이너리로 전달됩니다. 이 두 종류의 인수를 구분하기 위해, <code>cargo test</code>로 전달될 인수들을 먼저 쓰고 구분자 <code>--</code>를 쓴 다음 테스트 바이너리로 전달될 인수들을 씁니다. <code>cargo test --help</code>를 실행하면 <code>cargo test</code>에서 사용할 수 있는 옵션이 표시되고, <code>cargo test -- --help</code>를 실행하면 구분자 뒤에서 사용할 수 있는 옵션이 표시됩니다. 이러한 옵션들은 <a href="https://doc.rust-lang.org/rustc/index.html">rustc 북</a>의 <a href="https://doc.rust-lang.org/rustc/tests/index.html">“테스트” 섹션</a>에도 문서화되어 있습니다.</p>
<h3 id="테스트를-병렬-혹은-순차적으로-실행하기"><a class="header" href="#테스트를-병렬-혹은-순차적으로-실행하기">테스트를 병렬 혹은 순차적으로 실행하기</a></h3>
<p>여러 테스트를 실행할 때, 기본적으로 테스트는 스레드를 사용하여 병렬로 실행됩니다. 이는 테스트가 더 빨리 끝나고 피드백을 더 빨리 받을 수 있음을 의미합니다. 테스트들이 동시에 실행되기 때문에, 여러분은 테스트들이 서로 의존하지 않거나 현재 작업 디렉터리나 환경 변수와 같은 공유 환경을 포함한 어떤 공유 상태에도 의존하지 않도록 보장해야 합니다.</p>
<p>예를 들어, 각 테스트가 디스크에 _test-output.txt_라는 파일을 만들고 데이터를 쓰는 코드를 실행한다고 가정해 봅시다. 그런 다음 각 테스트는 해당 파일을 읽고 파일이 특정 값을 포함하고 있는지 단언하는데, 이 값은 테스트마다 다릅니다. 테스트가 동시에 실행되기 때문에, 한 테스트가 파일을 쓰고 읽는 사이의 시간에 다른 테스트가 파일을 덮어쓸 수 있습니다. 그러면 두 번째 테스트는 코드가 틀려서가 아니라 테스트들이 병렬로 실행되면서 서로 간섭했기 때문에 실패하게 됩니다. 한 가지 해결책은 각 테스트가 서로 다른 파일에 쓰도록 하는 것이고, 다른 해결책은 테스트를 한 번에 하나씩 실행하는 것입니다.</p>
<p>테스트를 병렬로 실행하고 싶지 않거나 사용되는 스레드 수에 대해 더 세밀한 제어를 원한다면, <code>--test-threads</code> 플래그와 사용하고자 하는 스레드 수를 테스트 바이러리에 전달할 수 있습니다. 다음 예제를 살펴보세요:</p>
<pre><code class="language-console">$ cargo test -- --test-threads=1
</code></pre>
<p>테스트 스레드 수를 <code>1</code>로 설정하여 프로그램에 어떤 병렬 처리도 사용하지 말라고 지시합니다. 하나의 스레드를 사용하여 테스트를 실행하면 병렬로 실행하는 것보다 시간이 더 오래 걸리겠지만, 상태를 공유하더라도 테스트들이 서로 간섭하지 않을 것입니다.</p>
<h3 id="함수-출력-표시하기"><a class="header" href="#함수-출력-표시하기">함수 출력 표시하기</a></h3>
<p>기본적으로 테스트가 통과하면 러스트의 테스트 라이브러리는 표준 출력으로 인쇄된 모든 내용을 캡처합니다. 예를 들어, 테스트에서 <code>println!</code>을 호출하고 테스트가 통과하면 터미널에서 <code>println!</code> 출력을 볼 수 없으며, 테스트가 통과했음을 나타내는 라인만 보게 됩니다. 테스트가 실패하면 표준 출력에 인쇄된 내용과 나머지 실패 메시지를 함께 보게 됩니다.</p>
<p>예를 들어, 목록 11-10에는 매개변수의 값을 출력하고 10을 반환하는 단순한 함수와, 통과하는 테스트 및 실패하는 테스트가 하나씩 있습니다.</p>
<Listing number="11-10" file-name="src/lib.rs" caption="Tests for a function that calls `println!`">
<pre><code class="language-rust panics noplayground">fn prints_and_returns_10(a: i32) -&gt; i32 {
    println!("I got the value {a}");
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn this_test_will_pass() {
        let value = prints_and_returns_10(4);
        assert_eq!(value, 10);
    }

    #[test]
    fn this_test_will_fail() {
        let value = prints_and_returns_10(8);
        assert_eq!(value, 5);
    }
}</code></pre>
</Listing>
<p>이 테스트들을 <code>cargo test</code>로 실행하면 다음과 같은 출력을 보게 됩니다:</p>
<pre><code class="language-console">$ cargo test
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

failures:

---- tests::this_test_will_fail stdout ----
I got the value 8
thread 'tests::this_test_will_fail' panicked at src/lib.rs:19:9:
assertion `left == right` failed
  left: 10
 right: 5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>이 출력 어디에서도 통과한 테스트가 실행될 때 인쇄된 <code>I got the value 4</code>를 볼 수 없다는 점에 주목하세요. 해당 출력은 캡처되었습니다. 실패한 테스트의 출력인 <code>I got the value 8</code>은 테스트 요약 출력 섹션에 나타나며, 테스트 실패 원인도 함께 보여줍니다.</p>
<p>통과한 테스트의 출력값도 보고 싶다면, <code>--show-output</code> 플래그를 사용하여 성공한 테스트의 출력도 표시하도록 러스트에게 지시할 수 있습니다.</p>
<pre><code class="language-console">$ cargo test -- --show-output
</code></pre>
<p>목록 11-10의 테스트를 <code>--show-output</code> 플래그와 함께 다시 실행하면, 다음과 같은 출력을 보게 됩니다:</p>
<pre><code class="language-console">$ cargo test -- --show-output
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

successes:

---- tests::this_test_will_pass stdout ----
I got the value 4


successes:
    tests::this_test_will_pass

failures:

---- tests::this_test_will_fail stdout ----
I got the value 8
thread 'tests::this_test_will_fail' panicked at src/lib.rs:19:9:
assertion `left == right` failed
  left: 10
 right: 5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<h3 id="이름으로-테스트-하위-집합-실행하기"><a class="header" href="#이름으로-테스트-하위-집합-실행하기">이름으로 테스트 하위 집합 실행하기</a></h3>
<p>때때로 전체 테스트 모음을 실행하는 데 오랜 시간이 걸릴 수 있습니다. 특정 영역의 코드를 작업 중이라면, 해당 코드와 관련된 테스트만 실행하고 싶을 것입니다. 실행하고 싶은 테스트의 이름을 <code>cargo test</code>의 인수로 전달하여 실행할 테스트를 선택할 수 있습니다.</p>
<p>테스트 하위 집합을 실행하는 방법을 보여주기 위해, 먼저 목록 11-11과 같이 <code>add_two</code> 함수를 위한 세 개의 테스트를 만들고 그중 어떤 것을 실행할지 선택해 보겠습니다.</p>
<Listing number="11-11" file-name="src/lib.rs" caption="Three tests with three different names">
<pre><code class="language-rust noplayground">pub fn add_two(a: usize) -&gt; usize {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        let result = add_two(2);
        assert_eq!(result, 4);
    }

    #[test]
    fn add_three_and_two() {
        let result = add_two(3);
        assert_eq!(result, 5);
    }

    #[test]
    fn one_hundred() {
        let result = add_two(100);
        assert_eq!(result, 102);
    }
}</code></pre>
</Listing>
<p>앞서 본 것처럼 아무런 인수 없이 테스트를 실행하면 모든 테스트가 병렬로 실행됩니다:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 3 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok
test tests::one_hundred ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<h4 id="단일-테스트-실행하기"><a class="header" href="#단일-테스트-실행하기">단일 테스트 실행하기</a></h4>
<p><code>cargo test</code>에 임의의 테스트 함수 이름을 전달하여 해당 테스트만 실행할 수 있습니다.</p>
<pre><code class="language-console">$ cargo test one_hundred
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.69s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::one_hundred ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out; finished in 0.00s

</code></pre>
<p><code>one_hundred</code>라는 이름의 테스트만 실행되었습니다. 나머지 두 테스트는 그 이름과 일치하지 않았습니다. 테스트 출력의 마지막에 표시된 <code>2 filtered out</code>을 통해 실행되지 않은 테스트가 더 있음을 알 수 있습니다.</p>
<p>이런 방식으로는 여러 테스트의 이름을 지정할 수 없습니다. <code>cargo test</code>에 주어진 첫 번째 값만 사용되기 때문입니다. 하지만 여러 테스트를 실행할 수 있는 방법이 있습니다.</p>
<h4 id="여러-테스트를-실행하기-위한-필터링"><a class="header" href="#여러-테스트를-실행하기-위한-필터링">여러 테스트를 실행하기 위한 필터링</a></h4>
<p>테스트 이름의 일부를 지정할 수 있으며, 해당 값과 이름이 일치하는 모든 테스트가 실행됩니다. 예를 들어, 우리 테스트 중 두 개의 이름에 <code>add</code>가 포함되어 있으므로, <code>cargo test add</code>를 실행하여 그 두 테스트를 실행할 수 있습니다.</p>
<pre><code class="language-console">$ cargo test add
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

</code></pre>
<p>이 명령은 이름에 <code>add</code>가 포함된 모든 테스트를 실행하고 <code>one_hundred</code>라는 이름의 테스트는 필터링했습니다. 또한 테스트가 속한 모듈이 테스트 이름의 일부가 되므로, 모듈 이름을 필터링하여 해당 모듈 내의 모든 테스트를 실행할 수도 있습니다.</p>
<h3 id="명시적으로-요청하지-않는-한-일부-테스트-무시하기"><a class="header" href="#명시적으로-요청하지-않는-한-일부-테스트-무시하기">명시적으로 요청하지 않는 한 일부 테스트 무시하기</a></h3>
<p>때때로 몇몇 특정 테스트는 실행하는 데 시간이 매우 오래 걸릴 수 있으므로, 대부분의 <code>cargo test</code> 실행 시에는 제외하고 싶을 것입니다. 실행하려는 모든 테스트를 인수로 나열하는 대신, 다음과 같이 <code>ignore</code> 속성을 사용하여 시간이 오래 걸리는 테스트를 제외하도록 어노테이션을 달 수 있습니다.</p>
<p><span class="filename">파일명: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub fn add(left: u64, right: u64) -&gt; u64 {
</span><span class="boring">    left + right
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }

    #[test]
    #[ignore]
    fn expensive_test() {
        // 실행하는 데 한 시간이 걸리는 코드
    }
}</code></pre>
<p><code>#[test]</code> 뒤에, 제외하고 싶은 테스트에 <code>#[ignore]</code> 라인을 추가합니다. 이제 테스트를 실행하면 <code>it_works</code>는 실행되지만, <code>expensive_test</code>는 실행되지 않습니다:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::expensive_test ... ignored
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p><code>expensive_test</code> 함수가 <code>ignored</code>로 표시되었습니다. 무시된 테스트만 실행하고 싶다면, <code>cargo test -- --ignored</code>를 사용할 수 있습니다.</p>
<pre><code class="language-console">$ cargo test -- --ignored
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>어떤 테스트를 실행할지 제어함으로써, <code>cargo test</code> 결과가 빠르게 반환되도록 보장할 수 있습니다. <code>ignored</code> 테스트들의 결과를 확인할 시점이 되었고 결과를 기다릴 시간이 있다면, 대신 <code>cargo test -- --ignored</code>를 실행할 수 있습니다. 무시 여부와 상관없이 모든 테스트를 실행하고 싶다면 <code>cargo test -- --include-ignored</code>를 실행하면 됩니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="테스트-구성"><a class="header" href="#테스트-구성">테스트 구성</a></h2>
<p>이 장의 시작 부분에서 언급했듯이, 테스트는 복잡한 분야이며 사람마다 사용하는 용어와 구성 방식이 다릅니다. 러스트 커뮤니티는 테스트를 크게 두 가지 범주로 나눕니다: 단위 테스트(unit tests)와 통합 테스트(integration tests)입니다. _단위 테스트_는 작고 집중적이며, 한 번에 하나의 모듈을 분리하여 테스트하고 비공개 인터페이스도 테스트할 수 있습니다. _통합 테스트_는 라이브러리 외부에서 완전히 독립되어 있으며, 다른 외부 코드가 사용하는 것과 동일한 방식으로 여러분의 코드를 사용합니다. 오직 공개 인터페이스만 사용하며 한 테스트당 여러 모듈을 테스트할 수도 있습니다.</p>
<p>라이브러리의 각 조각들이 따로따로 그리고 함께 의도한 대로 작동하는지 보장하기 위해서는 두 종류의 테스트를 모두 작성하는 것이 중요합니다.</p>
<h3 id="단위-테스트"><a class="header" href="#단위-테스트">단위 테스트</a></h3>
<p>단위 테스트의 목적은 나머지 코드와 분리된 각 코드 단위를 테스트하여, 코드가 예상대로 작동하는 부분과 그렇지 않은 부분을 신속하게 찾아내는 것입니다. 단위 테스트는 테스트할 코드가 있는 <em>src</em> 디렉토리의 각 파일에 넣습니다. 관례적으로 각 파일에 테스트 함수를 포함하는 <code>tests</code>라는 이름의 모듈을 만들고, 그 모듈에 <code>cfg(test)</code> 어노테이션을 답니다.</p>
<h4 id="테스트-모듈과-cfgtest"><a class="header" href="#테스트-모듈과-cfgtest">테스트 모듈과 <code>#[cfg(test)]</code></a></h4>
<p><code>tests</code> 모듈에 붙은 <code>#[cfg(test)]</code> 어노테이션은 <code>cargo build</code>를 실행할 때가 아니라 <code>cargo test</code>를 실행할 때만 테스트 코드를 컴파일하고 실행하도록 러스트에게 지시합니다. 이는 라이브러리만 빌드하고 싶을 때 컴파일 시간을 절약해주고, 결과물인 컴파일된 아티팩트에 테스트가 포함되지 않으므로 용량도 절약해줍니다. 뒤에 보시겠지만 통합 테스트는 다른 디렉토리에 위치하기 때문에 <code>#[cfg(test)]</code> 어노테이션이 필요하지 않습니다. 하지만 단위 테스트는 코드와 같은 파일에 위치하므로, 컴파일 결과에 포함되지 않도록 <code>#[cfg(test)]</code>를 사용해야 합니다.</p>
<p>이 장의 첫 번째 섹션에서 새로운 <code>adder</code> 프로젝트를 생성했을 때, Cargo가 우리를 위해 생성해준 다음 코드를 기억해 보세요:</p>
<p><span class="filename">파일명: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<p>자동으로 생성된 <code>tests</code> 모듈에서 <code>cfg</code> 속성은 _설정(configuration)_을 의미하며, 특정 설정 옵션이 주어졌을 때만 이어지는 항목을 포함해야 한다고 러스트에게 알려줍니다. 이 경우 설정 옵션은 <code>test</code>인데, 이는 테스트를 컴파일하고 실행하기 위해 러스트에서 제공하는 옵션입니다. <code>cfg</code> 속성을 사용함으로써, Cargo는 우리가 <code>cargo test</code>를 통해 적극적으로 테스트를 실행할 때만 테스트 코드를 컴파일합니다. 여기에는 <code>#[test]</code> 어노테이션이 달린 함수들뿐만 아니라 이 모듈 내에 있을 수 있는 모든 헬퍼 함수들도 포함됩니다.</p>
<h4 id="비공개-함수-테스트하기"><a class="header" href="#비공개-함수-테스트하기">비공개 함수 테스트하기</a></h4>
<p>테스트 커뮤니티 내에서는 비공개 함수를 직접 테스트해야 하는지에 대한 논쟁이 있으며, 다른 언어들은 비공개 함수를 테스트하기 어렵게 하거나 불가능하게 만들기도 합니다. 여러분이 어떤 테스트 철학을 지지하든 상관없이, 러스트의 가시성 규칙은 비공개 함수를 테스트할 수 있게 해줍니다. 비공개 함수 <code>internal_adder</code>가 포함된 목록 11-12의 코드를 살펴봅시다.</p>
<Listing number="11-12" file-name="src/lib.rs" caption="Testing a private function">
<pre><code class="language-rust noplayground">pub fn add_two(a: usize) -&gt; usize {
    internal_adder(a, 2)
}

fn internal_adder(left: usize, right: usize) -&gt; usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        let result = internal_adder(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
</Listing>
<p><code>internal_adder</code> 함수는 <code>pub</code>으로 표시되지 않았음에 주목하세요. 테스트는 그저 러스트 코드일 뿐이며, <code>tests</code> 모듈도 그저 또 다른 모듈일 뿐입니다. 7장의 <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“모듈 트리에서 항목을 참조하는 경로”</a><!-- ignore -->에서 논의했듯이, 자식 모듈의 아이템은 조상 모듈의 아이템을 사용할 수 있습니다. 이 테스트에서 우리는 <code>use super::*</code>를 사용하여 <code>tests</code> 모듈 부모의 모든 아이템을 스코프로 가져왔고, 따라서 테스트에서 <code>internal_adder</code>를 호출할 수 있습니다. 만약 비공개 함수를 테스트하면 안 된다고 생각하신다면, 러스트에서 그렇게 하라고 강요하는 것은 아무것도 없습니다.</p>
<h3 id="통합-테스트"><a class="header" href="#통합-테스트">통합 테스트</a></h3>
<p>러스트에서 통합 테스트는 라이브러리 외부에서 완전히 독립적입니다. 다른 코드가 사용하는 것과 동일한 방식으로 여러분의 라이브러리를 사용하며, 이는 라이브러리의 공개 API에 속하는 함수들만 호출할 수 있음을 의미합니다. 통합 테스트의 목적은 라이브러리의 여러 부분이 함께 올바르게 작동하는지 테스트하는 것입니다. 개별적으로는 올바르게 작동하는 코드 단위들도 통합되었을 때는 문제가 발생할 수 있으므로, 통합된 코드에 대한 테스트 커버리지도 매우 중요합니다. 통합 테스트를 만들기 위해서는 먼저 <em>tests</em> 디렉토리가 필요합니다.</p>
<h4 id="tests-디렉토리"><a class="header" href="#tests-디렉토리"><em>tests</em> 디렉토리</a></h4>
<p>프로젝트 디렉토리의 최상위 수준에 _src_와 나란히 <em>tests</em> 디렉토리를 만듭니다. Cargo는 이 디렉토리에서 통합 테스트 파일들을 찾는 방법을 알고 있습니다. 우리는 원하는 만큼 테스트 파일을 만들 수 있으며, Cargo는 각 파일을 개별 크레이트로 컴파일할 것입니다.</p>
<p>통합 테스트를 만들어 봅시다. 목록 11-12의 코드가 여전히 <em>src/lib.rs</em> 파일에 있는 상태에서, <em>tests</em> 디렉토리를 만들고 _tests/integration_test.rs_라는 새 파일을 생성합니다. 디렉토리 구조는 다음과 같아야 합니다:</p>
<pre><code class="language-text">adder
├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    └── integration_test.rs
</code></pre>
<p>목록 11-13의 코드를 <em>tests/integration_test.rs</em> 파일에 입력하세요.</p>
<Listing number="11-13" file-name="tests/integration_test.rs" caption="An integration test of a function in the `adder` crate">
<pre><code class="language-rust ignore">use adder::add_two;

#[test]
fn it_adds_two() {
    let result = add_two(2);
    assert_eq!(result, 4);
}</code></pre>
</Listing>
<p><em>tests</em> 디렉토리의 각 파일은 별개의 크레이트이므로, 각 테스트 크레이트의 스코프로 라이브러리를 가져와야 합니다. 그러한 이유로 코드 상단에 <code>use adder::add_two;</code>를 추가하는데, 이는 단위 테스트에서는 필요하지 않았던 작업입니다.</p>
<p>_tests/integration_test.rs_의 어떤 코드에도 <code>#[cfg(test)]</code>를 달 필요가 없습니다. Cargo는 <em>tests</em> 디렉토리를 특별하게 취급하여, <code>cargo test</code>를 실행할 때만 이 디렉토리의 파일들을 컴파일합니다. 이제 <code>cargo test</code>를 실행해 봅시다:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.31s
     Running unittests src/lib.rs (target/debug/deps/adder-1082c4b063a8fbe6)

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-1082c4b063a8fbe6)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>출력의 세 섹션은 단위 테스트, 통합 테스트, 그리고 문서 테스트를 포함합니다. 어떤 섹션에서라도 테스트가 실패하면 다음 섹션들은 실행되지 않는다는 점에 주의하세요. 예를 들어, 단위 테스트가 실패하면 통합 테스트와 문서 테스트의 출력은 나타나지 않는데, 이들은 모든 단위 테스트가 통과했을 때만 실행되기 때문입니다.</p>
<p>단위 테스트를 위한 첫 번째 섹션은 우리가 보아온 것과 같습니다. 각 단위 테스트(목록 11-12에서 추가한 <code>internal</code>)에 대해 한 줄씩 출력되고 단위 테스트 요약 줄이 나타납니다.</p>
<p>통합 테스트 섹션은 <code>Running tests/integration_test.rs</code>라는 줄로 시작합니다. 다음으로 해당 통합 테스트의 각 테스트 함수에 대한 줄이 있고, <code>Doc-tests adder</code> 섹션이 시작되기 직전에 통합 테스트 결과에 대한 요약 줄이 나타납니다.</p>
<p>각 통합 테스트 파일은 자신만의 섹션을 가지므로, <em>tests</em> 디렉토리에 더 많은 파일을 추가하면 더 많은 통합 테스트 섹션이 생길 것입니다.</p>
<p>여전히 <code>cargo test</code>의 인수로 테스트 함수 이름을 지정하여 특정 통합 테스트 함수를 실행할 수 있습니다. 특정 통합 테스트 파일의 모든 테스트를 실행하려면 <code>cargo test</code>의 <code>--test</code> 인수 뒤에 파일 이름을 붙여 사용하세요:</p>
<pre><code class="language-console">$ cargo test --test integration_test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.64s
     Running tests/integration_test.rs (target/debug/deps/integration_test-82e7799c1bc62298)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>이 명령은 <em>tests/integration_test.rs</em> 파일에 있는 테스트들만 실행합니다.</p>
<h4 id="통합-테스트에서의-하위-모듈"><a class="header" href="#통합-테스트에서의-하위-모듈">통합 테스트에서의 하위 모듈</a></h4>
<p>통합 테스트가 늘어남에 따라 이들을 체계적으로 관리하기 위해 <em>tests</em> 디렉토리에 더 많은 파일을 만들고 싶을 수 있습니다. 예를 들어, 테스트하는 기능별로 테스트 함수들을 그룹화할 수 있습니다. 앞서 언급했듯이, <em>tests</em> 디렉토리의 각 파일은 별개의 크레이트로 컴파일되는데, 이는 최종 사용자가 여러분의 크레이트를 사용하는 방식과 더 가깝게 별도의 스코프를 만드는 데 유용합니다. 하지만 이는 <em>tests</em> 디렉토리의 파일들이 7장에서 배운 <em>src</em> 파일들과는 다르게 작동한다는 것을 의미합니다.</p>
<p><em>tests</em> 디렉토리 파일들의 이러한 차이점은 여러 통합 테스트 파일에서 사용할 헬퍼 함수들을 공통 모듈로 분리하려 할 때 가장 두드러집니다. 7장의 <a href="ch07-05-separating-modules-into-different-files.html">“모듈을 다른 파일로 분리하기”</a><!-- ignore --> 섹션의 단계를 따라 공통 모듈을 만들려 할 때 말이죠. 예를 들어, <em>tests/common.rs</em> 파일을 만들고 그 안에 <code>setup</code>이라는 함수를 넣는다면, 여러 테스트 파일의 여러 테스트 함수에서 호출하고 싶은 코드를 <code>setup</code>에 추가할 수 있습니다:</p>
<p><span class="filename">파일명: tests/common.rs</span></p>
<pre><code class="language-rust noplayground">pub fn setup() {
    // 여러분 라이브러리의 테스트와 관련된 설정 코드가 여기에 들어갑니다
}</code></pre>
<p>테스트를 다시 실행하면, <em>common.rs</em> 파일에 대한 새로운 섹션이 테스트 출력에 나타납니다. 이 파일에는 테스트 함수가 포함되어 있지 않고 어디에서도 <code>setup</code> 함수를 호출하지 않았음에도 불구하고 말이죠:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.89s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/common.rs (target/debug/deps/common-92948b65e88960b4)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-92948b65e88960b4)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>테스트 결과에 <code>common</code>이 나타나고 <code>running 0 tests</code>라고 표시되는 것은 우리가 원하던 바가 아닙니다. 우리는 단지 다른 통합 테스트 파일들과 코드를 공유하고 싶었을 뿐입니다. <code>common</code>이 테스트 출력에 나타나지 않게 하려면, _tests/common.rs_를 만드는 대신 _tests/common/mod.rs_를 만들어야 합니다. 이제 프로젝트 디렉토리는 다음과 같은 모습이 됩니다:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    ├── common
    │   └── mod.rs
    └── integration_test.rs
</code></pre>
<p>이는 7장의 <a href="ch07-05-separating-modules-into-different-files.html#alternate-file-paths">“대체 파일 경로”</a><!-- ignore -->에서 언급했던, 러스트가 이해하는 오래된 명명 관례입니다. 파일을 이런 식으로 명명하면 러스트는 <code>common</code> 모듈을 통합 테스트 파일로 취급하지 않습니다. <code>setup</code> 함수 코드를 _tests/common/mod.rs_로 옮기고 <em>tests/common.rs</em> 파일을 삭제하면, 테스트 출력에서 해당 섹션이 더 이상 나타나지 않습니다. <em>tests</em> 디렉토리의 하위 디렉토리에 있는 파일들은 별개의 크레이트로 컴파일되지 않으며 테스트 출력에 섹션을 가지지도 않습니다.</p>
<p>_tests/common/mod.rs_를 만든 후에는, 어떤 통합 테스트 파일에서든 이를 모듈로 사용할 수 있습니다. 다음은 _tests/integration_test.rs_의 <code>it_adds_two</code> 테스트에서 <code>setup</code> 함수를 호출하는 예입니다:</p>
<p><span class="filename">파일명: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">use adder::add_two;

mod common;

#[test]
fn it_adds_two() {
    common::setup();

    let result = add_two(2);
    assert_eq!(result, 4);
}</code></pre>
<p><code>mod common;</code> 선언은 목록 7-21에서 보여준 모듈 선언과 동일하다는 점에 주목하세요. 그런 다음 테스트 함수에서 <code>common::setup()</code> 함수를 호출할 수 있습니다.</p>
<h4 id="바이너리-크레이트를-위한-통합-테스트"><a class="header" href="#바이너리-크레이트를-위한-통합-테스트">바이너리 크레이트를 위한 통합 테스트</a></h4>
<p>만약 프로젝트가 <em>src/lib.rs</em> 파일 없이 <em>src/main.rs</em> 파일만 있는 바이너리 크레이트라면, <em>tests</em> 디렉토리에 통합 테스트를 만들고 <code>use</code> 문을 통해 _src/main.rs_에 정의된 함수를 가져올 수 없습니다. 오직 라이브러리 크레이트만이 다른 크레이트가 사용할 수 있는 함수를 노출하며, 바이너리 크레이트는 단독으로 실행되는 것을 목적으로 하기 때문입니다.</p>
<p>이것이 바이너리를 제공하는 러스트 프로젝트들이 _src/lib.rs_에 로직을 두고 _src/main.rs_는 이를 호출하는 구조를 갖는 이유 중 하나입니다. 이러한 구조를 사용하면 통합 테스트에서 <code>use</code>를 통해 라이브러리 크레이트의 중요한 기능을 테스트할 수 있습니다. 중요한 기능들이 잘 작동한다면 _src/main.rs_에 있는 소량의 코드도 잘 작동할 것이며, 그 소량의 코드는 따로 테스트할 필요가 없습니다.</p>
<h2 id="요약-10"><a class="header" href="#요약-10">요약</a></h2>
<p>러스트의 테스트 기능은 코드가 어떻게 작동해야 하는지 명시함으로써, 코드를 수정하더라도 예상대로 계속 작동함을 보장하는 방법을 제공합니다. 단위 테스트는 라이브러리의 각 부분을 개별적으로 검증하며 비공개 구현 세부 사항도 테스트할 수 있습니다. 통합 테스트는 라이브러리의 여러 부분이 함께 올바르게 작동하는지 확인하며, 외부 코드가 사용하는 것과 동일하게 라이브러리의 공개 API를 사용하여 코드를 테스트합니다. 러스트의 타입 시스템과 소유권 규칙이 일부 버그를 방지하는 데 도움을 주지만, 코드가 어떻게 행동할 것으로 기대되는지와 관련된 로직 버그를 줄이기 위해 테스트는 여전히 중요합니다.</p>
<p>이 장과 이전 장들에서 배운 지식을 결합하여 프로젝트를 진행해 봅시다!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="io-프로젝트-명령줄-프로그램-만들기"><a class="header" href="#io-프로젝트-명령줄-프로그램-만들기">I/O 프로젝트: 명령줄 프로그램 만들기</a></h1>
<p>이 장은 지금까지 배운 많은 기술을 요약하고 몇 가지 표준 라이브러리 기능을 더 탐구하는 장입니다. 파일 및 명령줄 입출력과 상호작용하는 명령줄 도구를 만들어 보면서, 지금까지 익힌 러스트 개념들을 연습해 보겠습니다.</p>
<p>러스트의 속도, 안전성, 단일 바이너리 출력, 그리고 크로스 플랫폼 지원은 명령줄 도구를 만드는 데 이상적인 언어로 만들어 줍니다. 따라서 우리 프로젝트에서는 고전적인 명령줄 검색 도구인 <code>grep</code> (<strong>g</strong>lobally search a <strong>r</strong>egular <strong>e</strong>xpression and <strong>p</strong>rint)의 우리 버전 버전을 만들어 볼 것입니다. 가장 단순한 사용 사례에서 <code>grep</code>은 지정된 파일에서 지정된 문자열을 검색합니다. 이를 위해 <code>grep</code>은 파일 경로와 문자열을 인수로 받습니다. 그런 다음 파일을 읽고, 파일 안에서 해당 문자열 인수를 포함하는 줄을 찾아 출력합니다.</p>
<p>진행하면서 우리는 많은 다른 명령줄 도구들이 사용하는 터미널 기능을 우리 도구도 사용하도록 만드는 방법을 보여줄 것입니다. 사용자가 도구의 동작을 설정할 수 있도록 환경 변수의 값을 읽을 것입니다. 또한 에러 메시지를 표준 출력(<code>stdout</code>) 대신 표준 에러(<code>stderr</code>) 콘솔 스트림으로 인쇄하여, 예를 들어 사용자가 성공적인 출력은 파일로 리다이렉션하면서도 에러 메시지는 여전히 화면에서 볼 수 있도록 할 것입니다.</p>
<p>러스트 커뮤니티 멤버인 앤드류 갤런트(Andrew Gallant)는 이미 <code>ripgrep</code>이라는 이름의, 기능이 풍부하고 매우 빠른 <code>grep</code> 버전을 만들었습니다. 그에 비해 우리 버전은 상당히 단순하겠지만, 이 장은 <code>ripgrep</code>과 같은 실제 프로젝트를 이해하는 데 필요한 배경 지식을 제공해 줄 것입니다.</p>
<p>우리 <code>grep</code> 프로젝트는 지금까지 배운 여러 개념을 결합할 것입니다:</p>
<ul>
<li>코드 정리하기 (<a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">7장</a><!-- ignore -->)</li>
<li>벡터와 문자열 사용하기 (<a href="ch08-00-common-collections.html">8장</a><!-- ignore -->)</li>
<li>에러 처리하기 (<a href="ch09-00-error-handling.html">9장</a><!-- ignore -->)</li>
<li>적절한 곳에 트레이트와 라이프타임 사용하기 (<a href="ch10-00-generics.html">10장</a><!-- ignore -->)</li>
<li>테스트 작성하기 (<a href="ch11-00-testing.html">11장</a><!-- ignore -->)</li>
</ul>
<p>또한 클로저, 반복자, 트레이트 객체에 대해서도 간략히 소개할 것인데, 이들은 <a href="ch13-00-functional-features.html">13장</a><!-- ignore -->과 <a href="ch18-00-oop.html">18장</a><!-- ignore -->에서 자세히 다룰 예정입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="명령줄-인수-받기"><a class="header" href="#명령줄-인수-받기">명령줄 인수 받기</a></h2>
<p>언제나처럼 <code>cargo new</code>를 사용하여 새 프로젝트를 만들어 봅시다. 이미 시스템에 있을 수도 있는 <code>grep</code> 도구와 구분하기 위해 우리 프로젝트의 이름은 <code>minigrep</code>으로 짓겠습니다.</p>
<pre><code class="language-console">$ cargo new minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
</code></pre>
<p>첫 번째 과제는 <code>minigrep</code>이 두 개의 명령줄 인수, 즉 파일 경로와 검색할 문자열을 받아들이도록 만드는 것입니다. 다시 말해, <code>cargo run</code> 다음에 뒤따르는 인수들이 <code>cargo</code>가 아닌 우리 프로그램을 위한 것임을 나타내는 두 개의 하이픈을 쓰고, 검색할 문자열과 검색 대상 파일의 경로를 다음과 같이 실행할 수 있기를 원합니다:</p>
<pre><code class="language-console">$ cargo run -- searchstring example-filename.txt
</code></pre>
<p>현재 <code>cargo new</code>로 생성된 프로그램은 우리가 주는 인수들을 처리할 수 없습니다. <a href="https://crates.io/">crates.io</a>에 있는 몇몇 기존 라이브러리들이 명령줄 인수를 받는 프로그램을 작성하는 데 도움을 줄 수 있지만, 여러분은 이제 막 이 개념을 배우고 있으므로 이 기능을 직접 구현해 보겠습니다.</p>
<h3 id="인수-값-읽기"><a class="header" href="#인수-값-읽기">인수 값 읽기</a></h3>
<p><code>minigrep</code>에 전달된 명령줄 인수의 값을 읽을 수 있도록 하려면, 러스트 표준 라이브러리에서 제공하는 <code>std::env::args</code> 함수가 필요합니다. 이 함수는 <code>minigrep</code>에 전달된 명령줄 인수의 반복자(iterator)를 반환합니다. 반복자에 대해서는 <a href="ch13-00-functional-features.html">13장</a><!-- ignore -->에서 자세히 다룰 것입니다. 지금은 반복자에 대해 두 가지 세부 사항만 알면 됩니다. 반복자는 일련의 값들을 생성하며, 반복자에 <code>collect</code> 메서드를 호출하여 반복자가 생성하는 모든 요소를 담은 벡터와 같은 컬렉션으로 바꿀 수 있다는 점입니다.</p>
<p>목록 12-1의 코드는 <code>minigrep</code> 프로그램이 전달된 모든 명령줄 인수를 읽고, 그 값들을 벡터로 수집할 수 있게 해줍니다.</p>
<Listing number="12-1" file-name="src/main.rs" caption="Collecting the command line arguments into a vector and printing them">
<pre><pre class="playground"><code class="language-rust edition2021">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    dbg!(args);
}</code></pre></pre>
</Listing>
<p>먼저 <code>args</code> 함수를 사용할 수 있도록 <code>use</code> 문을 사용하여 <code>std::env</code> 모듈을 스코프로 가져옵니다. <code>std::env::args</code> 함수가 두 단계의 모듈 안에 중첩되어 있음에 주목하세요. 7장의 <a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#creating-idiomatic-use-paths">“관용적인 use 경로 만들기”</a><!-- ignore -->에서 논의했듯이, 원하는 함수가 둘 이상의 모듈에 중첩된 경우 함수 자체가 아닌 부모 모듈을 스코프로 가져오는 방식을 택했습니다. 이렇게 함으로써 <code>std::env</code>에 있는 다른 함수들도 쉽게 사용할 수 있습니다. 또한 <code>use std::env::args</code>를 추가하고 함수를 그냥 <code>args</code>라고 호출하는 것보다 모호함이 적은데, <code>args</code>가 현재 모듈에 정의된 함수로 쉽게 오해받을 수 있기 때문입니다.</p>
<blockquote>
<h3 id="args-함수와-유효하지-않은-유니코드"><a class="header" href="#args-함수와-유효하지-않은-유니코드"><code>args</code> 함수와 유효하지 않은 유니코드</a></h3>
<p>어떤 인수라도 유효하지 않은 유니코드를 포함하고 있으면 <code>std::env::args</code>가 패닉을 일으킨다는 점에 유의하세요. 프로그램이 유효하지 않은 유니코드를 포함한 인수를 받아들여야 한다면, 대신 <code>std::env::args_os</code>를 사용하세요. 그 함수는 <code>String</code> 값 대신 <code>OsString</code> 값을 생성하는 반복자를 반환합니다. 여기서는 단순함을 위해 <code>std::env::args</code>를 사용하기로 했는데, <code>OsString</code> 값은 플랫폼마다 다르며 <code>String</code> 값보다 다루기가 더 복잡하기 때문입니다.</p>
</blockquote>
<p><code>main</code>의 첫 번째 줄에서 <code>env::args</code>를 호출하고, 반복자가 생성하는 모든 값을 담은 벡터로 바꾸기 위해 즉시 <code>collect</code>를 사용합니다. <code>collect</code> 함수는 다양한 종류의 컬렉션을 만드는 데 사용될 수 있으므로, 우리가 문자열 벡터를 원한다는 것을 명시하기 위해 <code>args</code>의 타입을 명시적으로 적어줍니다. 러스트에서 타입을 명시해야 하는 경우는 매우 드물지만, <code>collect</code>는 러스트가 여러분이 어떤 종류의 컬렉션을 원하는지 추론할 수 없기 때문에 종종 타입 명시가 필요한 함수 중 하나입니다.</p>
<p>마지막으로, 디버그 매크로를 사용하여 벡터를 출력합니다. 먼저 인수 없이 실행해 보고, 그 다음에는 두 개의 인수를 주어 실행해 봅시다:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/minigrep`
[src/main.rs:5:5] args = [
    "target/debug/minigrep",
]
</code></pre>
<pre><code class="language-console">$ cargo run -- needle haystack
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.57s
     Running `target/debug/minigrep needle haystack`
[src/main.rs:5:5] args = [
    "target/debug/minigrep",
    "needle",
    "haystack",
]
</code></pre>
<p>벡터의 첫 번째 값이 우리 바이너리의 이름인 <code>"target/debug/minigrep"</code>임에 주목하세요. 이는 C 언어의 인수 목록 동작과 일치하며, 프로그램이 실행될 때 호출된 이름을 사용할 수 있게 해줍니다. 프로그램 이름을 출력 메시지에 포함하거나, 프로그램을 호출할 때 사용된 명령줄 별칭에 따라 동작을 변경하고 싶을 때 프로그램 이름에 접근할 수 있으면 종종 편리합니다. 하지만 이 장의 목적을 위해 우리는 이를 무시하고 필요한 두 개의 인수만 저장할 것입니다.</p>
<h3 id="인수-값을-변수에-저장하기"><a class="header" href="#인수-값을-변수에-저장하기">인수 값을 변수에 저장하기</a></h3>
<p>현재 프로그램은 명령줄 인수로 지정된 값들에 접근할 수 있습니다. 이제 프로그램의 나머지 부분에서 이 값들을 사용할 수 있도록 두 인수의 값을 변수에 저장해야 합니다. 목록 12-2에서 이 작업을 수행합니다.</p>
<Listing number="12-2" file-name="src/main.rs" caption="Creating variables to hold the query argument and file path argument">
<pre><code class="language-rust should_panic noplayground">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let query = &amp;args[1];
    let file_path = &amp;args[2];

    println!("Searching for {query}");
    println!("In file {file_path}");
}</code></pre>
</Listing>
<p>벡터를 출력했을 때 보았듯이, 프로그램 이름이 벡터의 첫 번째 값인 <code>args[0]</code>을 차지하므로, 우리는 인덱스 1부터 인수를 시작합니다. <code>minigrep</code>이 받는 첫 번째 인수는 우리가 검색할 문자열이므로, 첫 번째 인수의 참조를 <code>query</code> 변수에 넣습니다. 두 번째 인수는 파일 경로가 될 것이므로, 두 번째 인수의 참조를 <code>file_path</code> 변수에 넣습니다.</p>
<p>코드가 의도한 대로 작동하는지 확인하기 위해 이 변수들의 값을 임시로 출력해 보겠습니다. <code>test</code>와 <code>sample.txt</code>라는 인수를 주어 이 프로그램을 다시 실행해 봅시다:</p>
<pre><code class="language-console">$ cargo run -- test sample.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep test sample.txt`
Searching for test
In file sample.txt
</code></pre>
<p>좋습니다, 프로그램이 잘 작동하네요! 필요한 인수들의 값이 올바른 변수들에 저장되고 있습니다. 나중에 사용자가 아무런 인수를 제공하지 않는 경우와 같은 잠재적인 에러 상황을 처리하기 위해 에러 핸들링을 추가할 것이지만, 지금은 그 상황을 무시하고 대신 파일 읽기 기능을 추가하는 작업을 진행하겠습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="파일-읽기"><a class="header" href="#파일-읽기">파일 읽기</a></h2>
<p>이제 <code>file_path</code> 인수에 지정된 파일을 읽는 기능을 추가하겠습니다. 먼저 테스트에 사용할 샘플 파일이 필요합니다. 여러 줄에 걸쳐 적은 양의 텍스트가 있고 단어가 일부 반복되는 파일을 사용하겠습니다. 목록 12-3에 있는 에밀리 디킨슨(Emily Dickinson)의 시가 적당하겠네요! 프로젝트의 루트 레벨에 _poem.txt_라는 파일을 만들고, “I’m Nobody! Who are you?”라는 시를 입력하세요.</p>
<Listing number="12-3" file-name="poem.txt" caption="A poem by Emily Dickinson makes a good test case.">
<pre><code class="language-text">I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
</Listing>
<p>텍스트 파일이 준비되었으면, 목록 12-4와 같이 _src/main.rs_를 수정하여 파일을 읽는 코드를 추가합니다.</p>
<Listing number="12-4" file-name="src/main.rs" caption="Reading the contents of the file specified by the second argument">
<pre><code class="language-rust should_panic noplayground">use std::env;
use std::fs;

fn main() {
    // --생략--
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let query = &amp;args[1];
</span><span class="boring">    let file_path = &amp;args[2];
</span><span class="boring">
</span><span class="boring">    println!("Searching for {query}");
</span>    println!("In file {file_path}");

    let contents = fs::read_to_string(file_path)
        .expect("파일을 읽을 수 있어야 합니다");

    println!("텍스트 내용:\n{contents}");
}</code></pre>
</Listing>
<p>먼저 <code>use</code> 문을 사용하여 표준 라이브러리의 관련 부분을 가져옵니다. 파일을 다루기 위해 <code>std::fs</code>가 필요합니다.</p>
<p><code>main</code> 함수에서 새로 추가된 <code>fs::read_to_string</code> 문은 <code>file_path</code>를 받아 파일을 열고, 파일의 내용을 담은 <code>std::io::Result&lt;String&gt;</code> 타입의 값을 반환합니다.</p>
<p>그 다음, 파일이 읽힌 후 <code>contents</code>의 값을 출력하는 임시 <code>println!</code> 문을 다시 추가하여, 지금까지 프로그램이 잘 작동하는지 확인해 봅니다.</p>
<p>첫 번째 명령줄 인수로는 아무 문자열이나 주고(아직 검색 기능을 구현하지 않았으므로), 두 번째 인수로는 <em>poem.txt</em> 파일을 주어 이 코드를 실행해 봅시다:</p>
<pre><code class="language-console">$ cargo run -- the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

</code></pre>
<p>좋습니다! 코드가 파일을 읽고 그 내용을 성공적으로 출력했습니다. 하지만 이 코드에는 몇 가지 결함이 있습니다. 현재 <code>main</code> 함수는 여러 가지 책임을 가지고 있습니다. 일반적으로 각 함수가 하나의 일만 담당할 때 코드가 더 명확해지고 유지보수하기 쉬워집니다. 또 다른 문제는 에러 핸들링을 충분히 잘하고 있지 않다는 점입니다. 프로그램이 아직 작기 때문에 이러한 결함이 큰 문제는 아니지만, 프로그램이 커질수록 이를 깔끔하게 고치기가 더 어려워질 것입니다. 작은 양의 코드를 리팩터링하는 것이 훨씬 쉽기 때문에, 프로그램을 개발할 때 일찍 리팩터링을 시작하는 것이 좋습니다. 이제 그 작업을 해보겠습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="모듈성과-에러-처리-개선을-위한-리팩터링"><a class="header" href="#모듈성과-에러-처리-개선을-위한-리팩터링">모듈성과 에러 처리 개선을 위한 리팩터링</a></h2>
<p>프로그램을 개선하기 위해, 프로그램의 구조와 잠재적 에러 처리 방식과 관련된 네 가지 문제를 해결하겠습니다. 첫째, 현재 우리 <code>main</code> 함수는 인수를 파싱하고 파일을 읽는 두 가지 작업을 수행하고 있습니다. 프로그램이 커짐에 따라 <code>main</code> 함수가 처리해야 할 개별 작업의 수는 늘어날 것입니다. 함수가 더 많은 책임을 가질수록 그 함수를 이해하기 어려워지고, 테스트하기 힘들어지며, 다른 부분에 영향을 주지 않고 변경하기도 어려워집니다. 각 함수가 하나의 작업만 담당하도록 기능을 분리하는 것이 가장 좋습니다.</p>
<p>이 이슈는 두 번째 문제와도 연결됩니다. <code>query</code>와 <code>file_path</code>는 우리 프로그램의 설정 변수들이지만, <code>contents</code>와 같은 변수들은 프로그램의 로직을 수행하는 데 사용됩니다. <code>main</code>이 길어질수록 더 많은 변수들을 스코프로 가져와야 하며, 스코프 내의 변수가 많아질수록 각 변수의 목적을 파악하기가 더 힘들어집니다. 설정 변수들을 하나의 구조체로 묶어 그 목적을 명확히 하는 것이 좋습니다.</p>
<p>세 번째 문제는 파일을 읽는 데 실패했을 때 에러 메시지를 출력하기 위해 <code>expect</code>를 사용했다는 점인데, 에러 메시지는 그저 <code>Should have been able to read the file</code>이라고만 출력합니다. 파일을 읽는 것은 다양한 이유로 실패할 수 있습니다. 예를 들어 파일이 없거나, 파일을 열 권한이 없을 수도 있습니다. 현재로서는 상황에 상관없이 모든 경우에 동일한 에러 메시지를 출력하므로 사용자에게 아무런 정보도 주지 못합니다!</p>
<p>넷째, 에러 처리를 위해 <code>expect</code>를 사용하고 있는데, 사용자가 충분한 인수를 지정하지 않고 프로그램을 실행하면 러스트로부터 문제를 명확히 설명하지 못하는 <code>index out of bounds</code> 에러를 받게 됩니다. 에러 처리 로직을 변경해야 할 때 미래의 유지보수자가 한 곳만 확인하면 되도록 모든 에러 처리 코드가 한 곳에 모여 있는 것이 가장 좋습니다. 모든 에러 처리 코드를 한 곳에 모으면 우리 사용자들에게 의미 있는 메시지를 출력하도록 보장할 수도 있습니다.</p>
<p>프로젝트를 리팩터링하여 이 네 가지 문제를 해결해 봅시다.</p>
<h3 id="바이너리-프로젝트를-위한-관심사-분리"><a class="header" href="#바이너리-프로젝트를-위한-관심사-분리">바이너리 프로젝트를 위한 관심사 분리</a></h3>
<p><code>main</code> 함수에 여러 작업의 책임을 할당하는 조직적인 문제는 많은 바이너리 프로젝트에서 흔히 발생합니다. 그 결과, 러스트 커뮤니티는 <code>main</code>이 커지기 시작할 때 바이너리 프로그램의 개별 관심사를 분리하기 위한 가이드라인을 개발했습니다. 이 과정은 다음과 같은 단계로 이루어집니다:</p>
<ul>
<li>프로그램을 <em>main.rs</em> 파일과 <em>lib.rs</em> 파일로 나누고, 프로그램 로직을 _lib.rs_로 옮기세요.</li>
<li>명령줄 파싱 로직이 작다면 _main.rs_에 남아있어도 됩니다.</li>
<li>명령줄 파싱 로직이 복잡해지기 시작하면, _main.rs_에서 추출하여 _lib.rs_로 옮기세요.</li>
</ul>
<p>이 과정을 거친 후 <code>main</code> 함수에 남는 책임은 다음과 같이 제한되어야 합니다:</p>
<ul>
<li>인수 값들을 사용하여 명령줄 파싱 로직 호출하기</li>
<li>기타 다른 설정(configuration) 구성하기</li>
<li>_lib.rs_의 <code>run</code> 함수 호출하기</li>
<li><code>run</code> 함수가 에러를 반환할 때 에러 처리하기</li>
</ul>
<p>이 패턴은 관심사 분리에 관한 것입니다. _main.rs_는 프로그램 실행을 담당하고, _lib.rs_는 실제 작업의 모든 로직을 담당합니다. <code>main</code> 함수를 직접 테스트할 수 없기 때문에, 이러한 구조는 모든 프로그램 로직을 _lib.rs_의 함수로 옮김으로써 테스트가 가능하게 해줍니다. _main.rs_에 남는 코드는 읽는 것만으로도 올바름을 확인할 수 있을 정도로 작아질 것입니다. 이 과정을 따라 우리 프로그램을 다시 만들어 봅시다.</p>
<h4 id="인수-파서-추출하기"><a class="header" href="#인수-파서-추출하기">인수 파서 추출하기</a></h4>
<p>명령줄 파싱 로직을 _src/lib.rs_로 옮기기 위한 준비 단계로, 인수를 파싱하는 기능을 <code>main</code>이 호출할 함수로 추출하겠습니다. 목록 12-5는 새로운 함수 <code>parse_config</code>를 호출하는 <code>main</code>의 새로운 시작 부분을 보여줍니다. 현재로서는 <code>parse_config</code>를 _src/main.rs_에 정의할 것입니다.</p>
<Listing number="12-5" file-name="src/main.rs" caption="Extracting a `parse_config` function from `main`">
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (query, file_path) = parse_config(&amp;args);

    // --생략--
<span class="boring">
</span><span class="boring">    println!("Searching for {query}");
</span><span class="boring">    println!("In file {file_path}");
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(file_path)
</span><span class="boring">        .expect("파일을 읽을 수 있어야 합니다");
</span><span class="boring">
</span><span class="boring">    println!("텍스트 내용:\n{contents}");
</span>}

fn parse_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let query = &amp;args[1];
    let file_path = &amp;args[2];

    (query, file_path)
}</code></pre>
</Listing>
<p>우리는 여전히 명령줄 인수를 벡터로 수집하지만, <code>main</code> 함수 내에서 인덱스 1의 값을 <code>query</code> 변수에, 인덱스 2의 값을 <code>file_path</code> 변수에 직접 할당하는 대신, 전체 벡터를 <code>parse_config</code> 함수에 전달합니다. 그러면 <code>parse_config</code> 함수가 어떤 인수가 어떤 변수에 들어갈지 결정하는 로직을 갖고, 그 값들을 다시 <code>main</code>으로 돌려줍니다. <code>main</code>에서 <code>query</code>와 <code>file_path</code> 변수를 여전히 생성하지만, 명령줄 인수와 변수가 어떻게 대응되는지 결정하는 책임은 더 이상 <code>main</code>에 있지 않습니다.</p>
<p>이러한 재작업이 우리 작은 프로그램에는 과해 보일 수 있지만, 우리는 작고 점진적인 단계로 리팩터링을 진행하고 있습니다. 이 변경을 마친 후 프로그램을 다시 실행하여 인수 파싱이 여전히 잘 작동하는지 확인하세요. 문제가 발생했을 때 그 원인을 찾기 쉽도록 진행 상황을 자주 확인하는 것이 좋습니다.</p>
<h4 id="설정-값-그룹화하기"><a class="header" href="#설정-값-그룹화하기">설정 값 그룹화하기</a></h4>
<p><code>parse_config</code> 함수를 더 개선하기 위해 또 다른 작은 단계를 밟을 수 있습니다. 현재 우리는 튜플을 반환하고 있지만, 그 즉시 튜플을 다시 개별 부분으로 쪼개고 있습니다. 이는 아마도 우리가 아직 적절한 추상화를 갖지 못했다는 신호일 수 있습니다.</p>
<p>개선의 여지가 있다는 또 다른 지표는 <code>parse_config</code> 이름의 <code>config</code> 부분입니다. 이는 우리가 반환하는 두 값이 서로 관련이 있으며, 둘 다 하나의 설정 값의 일부임을 암시합니다. 현재로서는 두 값을 튜플로 묶는 것 외에는 데이터 구조에서 이러한 의미를 전달하지 못하고 있습니다. 대신 두 값을 하나의 구조체에 넣고 각 필드에 의미 있는 이름을 부여하겠습니다. 이렇게 하면 미래의 유지보수자들이 각 값들이 서로 어떻게 연관되어 있는지, 그리고 그 목적이 무엇인지 더 쉽게 이해할 수 있을 것입니다.</p>
<p>목록 12-6은 <code>parse_config</code> 함수의 개선된 모습을 보여줍니다.</p>
<Listing number="12-6" file-name="src/main.rs" caption="Refactoring `parse_config` to return an instance of a `Config` struct">
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = parse_config(&amp;args);

    println!("Searching for {}", config.query);
    println!("In file {}", config.file_path);

    let contents = fs::read_to_string(config.file_path)
        .expect("파일을 읽을 수 있어야 합니다");

    // --생략--
<span class="boring">
</span><span class="boring">    println!("텍스트 내용:\n{contents}");
</span>}

struct Config {
    query: String,
    file_path: String,
}

fn parse_config(args: &amp;[String]) -&gt; Config {
    let query = args[1].clone();
    let file_path = args[2].clone();

    Config { query, file_path }
}</code></pre>
</Listing>
<p><code>query</code>와 <code>file_path</code>라는 필드를 가진 <code>Config</code>라는 구조체를 추가했습니다. 이제 <code>parse_config</code>의 시그니처는 <code>Config</code> 값을 반환한다고 명시합니다. <code>args</code> 내의 <code>String</code> 값을 참조하는 문자열 슬라이스를 반환하던 <code>parse_config</code> 본문에서, 이제는 소유권이 있는 <code>String</code> 값을 담도록 <code>Config</code>를 정의합니다. <code>main</code>에 있는 <code>args</code> 변수가 인수 값들의 소유자이며 <code>parse_config</code> 함수에게는 단지 빌려주기만 할 뿐이므로, 만약 <code>Config</code>가 <code>args</code>에 있는 값들의 소유권을 가져오려 한다면 러스트의 대여 규칙을 위반하게 됩니다.</p>
<p><code>String</code> 데이터를 관리하는 방법은 여러 가지가 있습니다. 가장 쉽지만 다소 비효율적인 방법은 값들에 <code>clone</code> 메서드를 호출하는 것입니다. 이는 <code>Config</code> 인스턴스가 소유할 데이터의 전체 복사본을 만들며, 문자열 데이터에 대한 참조를 저장하는 것보다 더 많은 시간과 메모리를 소요합니다. 하지만 데이터를 복제하면 참조의 라이프타임을 관리할 필요가 없으므로 코드가 매우 단순해집니다. 이러한 상황에서는 단순함을 얻기 위해 약간의 성능을 포기하는 것이 가치 있는 트레이드오프가 될 수 있습니다.</p>
<blockquote>
<h3 id="clone-사용의-트레이드오프"><a class="header" href="#clone-사용의-트레이드오프"><code>clone</code> 사용의 트레이드오프</a></h3>
<p>많은 러스트 사용자들 사이에는 런타임 비용 때문에 소유권 문제를 해결하기 위해 <code>clone</code>을 사용하는 것을 피하려는 경향이 있습니다. <a href="ch13-00-functional-features.html">13장</a><!-- ignore -->에서는 이런 상황에서 더 효율적인 방법을 사용하는 법을 배우게 될 것입니다. 하지만 지금은 계속 진행하기 위해 몇 개의 문자열을 복사해도 괜찮습니다. 이러한 복사는 단 한 번만 일어나며, 파일 경로와 검색어 문자열은 매우 작기 때문입니다. 첫 번째 시도에서 코드를 과도하게 최적화하려 하기보다는, 약간 비효율적이더라도 작동하는 프로그램을 만드는 것이 낫습니다. 러스트에 더 익숙해지면 처음부터 가장 효율적인 해결책으로 시작하는 것이 더 쉬워지겠지만, 지금은 <code>clone</code>을 호출하는 것이 완벽하게 수용 가능합니다.</p>
</blockquote>
<p><code>parse_config</code>에서 반환된 <code>Config</code> 인스턴스를 <code>config</code>라는 변수에 담도록 <code>main</code>을 수정했고, 기존에 별도의 <code>query</code>와 <code>file_path</code> 변수를 사용하던 코드를 <code>Config</code> 구조체의 필드를 사용하도록 변경했습니다.</p>
<p>이제 우리 코드는 <code>query</code>와 <code>file_path</code>가 서로 연관되어 있으며, 그 목적이 프로그램의 동작 방식을 설정하는 것임을 더 명확하게 전달합니다. 이 값들을 사용하는 모든 코드는 <code>config</code> 인스턴스 내에서 그 목적에 맞게 이름 지어진 필드들을 통해 이 값들을 찾을 수 있습니다.</p>
<h4 id="config를-위한-생성자-만들기"><a class="header" href="#config를-위한-생성자-만들기"><code>Config</code>를 위한 생성자 만들기</a></h4>
<p>지금까지 우리는 명령줄 인수를 파싱하는 로직을 <code>main</code>에서 추출하여 <code>parse_config</code> 함수에 넣었습니다. 이 작업을 통해 <code>query</code>와 <code>file_path</code> 값이 서로 연관되어 있음을 확인했고, 코드에서도 그 관계를 표현해야 함을 알게 되었습니다. 그래서 <code>query</code>와 <code>file_path</code>의 연관된 목적을 나타내기 위해 <code>Config</code> 구조체를 추가했고, <code>parse_config</code> 함수에서 구조체 필드 이름을 통해 각 값의 이름을 반환할 수 있게 되었습니다.</p>
<p>이제 <code>parse_config</code> 함수의 목적이 <code>Config</code> 인스턴스를 생성하는 것이 되었으므로, 이를 일반 함수에서 <code>Config</code> 구조체와 연관된 <code>new</code>라는 이름의 함수로 변경할 수 있습니다. 이렇게 변경하면 코드가 더욱 관용적(idiomatic)이 됩니다. 우리가 <code>String::new</code>를 호출하여 <code>String</code>과 같은 표준 라이브러리 타입의 인스턴스를 생성하는 것처럼, <code>parse_config</code>를 <code>Config</code>와 연관된 <code>new</code> 함수로 바꿈으로써 <code>Config::new</code>를 호출하여 <code>Config</code> 인스턴스를 생성할 수 있게 됩니다. 목록 12-7은 우리가 해야 할 변경 사항을 보여줍니다.</p>
<Listing number="12-7" file-name="src/main.rs" caption="Changing `parse_config` into `Config::new`">
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);
<span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("파일을 읽을 수 있어야 합니다");
</span><span class="boring">
</span><span class="boring">    println!("텍스트 내용:\n{contents}");
</span>
    // --생략--
}

// --생략--

<span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let query = args[1].clone();
        let file_path = args[2].clone();

        Config { query, file_path }
    }
}</code></pre>
</Listing>
<p><code>parse_config</code>를 호출하던 <code>main</code>의 코드를 <code>Config::new</code>를 호출하도록 수정했습니다. <code>parse_config</code>의 이름을 <code>new</code>로 바꾸고 <code>impl</code> 블록 안으로 옮겨서, <code>new</code> 함수를 <code>Config</code>와 연관시켰습니다. 코드가 잘 작동하는지 확인하기 위해 다시 컴파일해 보세요.</p>
<h3 id="에러-핸들링-수정하기"><a class="header" href="#에러-핸들링-수정하기">에러 핸들링 수정하기</a></h3>
<p>이제 에러 핸들링을 수정해 보겠습니다. <code>args</code> 벡터에 아이템이 세 개보다 적을 때 인덱스 1이나 2의 값에 접근하려 하면 프로그램이 패닉을 일으킨다는 점을 기억하세요. 인수 없이 프로그램을 실행해 보면 다음과 같을 것입니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at src/main.rs:27:21:
index out of bounds: the len is 1 but the index is 1
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p><code>index out of bounds: the len is 1 but the index is 1</code>이라는 줄은 프로그래머를 위한 에러 메시지입니다. 우리 사용자들은 이 메시지를 보고 무엇을 해야 할지 알 수 없습니다. 이제 이를 수정해 봅시다.</p>
<h4 id="에러-메시지-개선하기"><a class="header" href="#에러-메시지-개선하기">에러 메시지 개선하기</a></h4>
<p>목록 12-8에서는 인덱스 1과 2에 접근하기 전에 슬라이스의 길이가 충분한지 확인하는 검사를 <code>new</code> 함수에 추가합니다. 슬라이스의 길이가 충분하지 않으면 프로그램이 패닉을 일으키고 더 나은 에러 메시지를 표시합니다.</p>
<Listing number="12-8" file-name="src/main.rs" caption="Adding a check for the number of arguments">
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("파일을 읽을 수 있어야 합니다");
</span><span class="boring">
</span><span class="boring">    println!("텍스트 내용:\n{contents}");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span>    // --생략--
    fn new(args: &amp;[String]) -&gt; Config {
        if args.len() &lt; 3 {
            panic!("인수가 부족합니다");
        }
        // --생략--
<span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Config { query, file_path }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>이 코드는 9장의 목록 9-13에서 작성했던 <a href="ch09-03-to-panic-or-not-to-panic.html#creating-custom-types-for-validation"><code>Guess::new</code> 함수</a><!-- ignore -->와 유사합니다. 거기서는 <code>value</code> 인수가 유효 범위를 벗어났을 때 <code>panic!</code>을 호출했었죠. 여기서는 값의 범위를 확인하는 대신 <code>args</code>의 길이가 최소한 <code>3</code>인지 확인하며, 이 조건이 충족되었다는 가정하에 함수의 나머지 부분이 작동하게 합니다. 만약 <code>args</code>의 아이템이 세 개보다 적다면 이 조건은 <code>true</code>가 되고, <code>panic!</code> 매크로를 호출하여 프로그램을 즉시 종료합니다.</p>
<p><code>new</code>에 이 몇 줄의 코드를 추가한 상태에서, 다시 인수 없이 프로그램을 실행하여 에러가 어떻게 보이는지 확인해 봅시다:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at src/main.rs:26:13:
not enough arguments
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>출력이 훨씬 나아졌습니다. 이제 합리적인 에러 메시지를 갖게 되었네요. 하지만 사용자에게 보여주고 싶지 않은 불필요한 정보도 여전히 포함되어 있습니다. 아마도 목록 9-13에서 사용한 기술이 여기에는 최선이 아닐 수도 있습니다. <a href="ch09-03-to-panic-or-not-to-panic.html#guidelines-for-error-handling">9장에서 논의했듯이</a><!-- ignore -->, <code>panic!</code> 호출은 사용상의 문제보다는 프로그래밍상의 문제에 더 적합하기 때문입니다. 대신 9장에서 배웠던 또 다른 기술인 성공 또는 에러를 나타내는 <a href="ch09-02-recoverable-errors-with-result.html"><code>Result</code> 반환하기</a><!-- ignore -->를 사용해 보겠습니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="returning-a-result-from-new-instead-of-calling-panic"></a></p>
<h4 id="panic-호출-대신-result-반환하기"><a class="header" href="#panic-호출-대신-result-반환하기"><code>panic!</code> 호출 대신 <code>Result</code> 반환하기</a></h4>
<p>대신 성공했을 때는 <code>Config</code> 인스턴스를 담고, 에러가 발생했을 때는 문제를 설명하는 <code>Result</code> 값을 반환할 수 있습니다. 또한 함수 이름을 <code>new</code>에서 <code>build</code>로 바꿀 것인데, 많은 프로그래머들이 <code>new</code> 함수는 절대 실패하지 않을 것이라고 기대하기 때문입니다. <code>Config::build</code>가 <code>main</code>과 통신할 때, <code>Result</code> 타입을 사용하여 문제가 발생했음을 알릴 수 있습니다. 그러면 <code>main</code>에서 <code>Err</code> 변형을 <code>panic!</code> 호출로 인한 <code>thread 'main'</code>이나 <code>RUST_BACKTRACE</code> 같은 텍스트 없이 사용자에게 더 실용적인 에러 메시지로 변환할 수 있습니다.</p>
<p>목록 12-9는 현재 <code>Config::build</code>라고 부르는 함수의 반환 값과 <code>Result</code>를 반환하는 데 필요한 함수 본문의 변경 사항을 보여줍니다. <code>main</code>도 함께 업데이트해야 컴파일이 되며, 이는 다음 목록에서 다룰 것입니다.</p>
<Listing number="12-9" file-name="src/main.rs" caption="Returning a `Result` from `Config::build`">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("파일을 읽을 수 있어야 합니다");
</span><span class="boring">
</span><span class="boring">    println!("텍스트 내용:\n{contents}");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err("인수가 부족합니다");
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        Ok(Config { query, file_path })
    }
}</code></pre>
</Listing>
<p>우리 <code>build</code> 함수는 성공 시 <code>Config</code> 인스턴스를 담고 에러 시 문자열 리터럴을 담는 <code>Result</code>를 반환합니다. 에러 값은 항상 <code>'static</code> 라이프타임을 가진 문자열 리터럴이 될 것입니다.</p>
<p>함수 본문에서 두 가지를 변경했습니다. 사용자가 인수를 충분히 전달하지 않았을 때 <code>panic!</code>을 호출하는 대신 이제 <code>Err</code> 값을 반환하며, <code>Config</code> 반환 값을 <code>Ok</code>로 감쌌습니다. 이러한 변경을 통해 함수가 새로운 타입 시그니처에 부합하게 되었습니다.</p>
<p><code>Config::build</code>에서 <code>Err</code> 값을 반환하면, <code>main</code> 함수가 <code>build</code> 함수로부터 반환된 <code>Result</code> 값을 처리하고 에러 발생 시 프로세스를 더 깔끔하게 종료할 수 있게 됩니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="calling-confignew-and-handling-errors"></a></p>
<h4 id="configbuild-호출-및-에러-처리하기"><a class="header" href="#configbuild-호출-및-에러-처리하기"><code>Config::build</code> 호출 및 에러 처리하기</a></h4>
<p>에러 상황을 처리하고 사용자 친화적인 메시지를 출력하기 위해, 목록 12-10과 같이 <code>Config::build</code>가 반환하는 <code>Result</code>를 처리하도록 <code>main</code>을 업데이트해야 합니다. 또한 0이 아닌 에러 코드로 명령줄 도구를 종료하는 책임을 <code>panic!</code>으로부터 가져와 직접 구현할 것입니다. 0이 아닌 종료 상태 값은 우리 프로그램을 호출한 프로세스에게 프로그램이 에러 상태로 종료되었음을 알리는 관례입니다.</p>
<Listing number="12-10" file-name="src/main.rs" caption="Exiting with an error code if building a `Config` fails">
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span>use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        println!("인수 파싱 중 문제 발생: {err}");
        process::exit(1);
    });

    // --생략--
<span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect("파일을 읽을 수 있어야 합니다");
</span><span class="boring">
</span><span class="boring">    println!("텍스트 내용:\n{contents}");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("인수가 부족합니다");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>이 목록에서 우리는 아직 자세히 다루지 않은 메서드인 <code>unwrap_or_else</code>를 사용했습니다. 이 메서드는 표준 라이브러리의 <code>Result&lt;T, E&gt;</code>에 정의되어 있습니다. <code>unwrap_or_else</code>를 사용하면 <code>panic!</code>이 아닌 커스텀 에러 처리를 정의할 수 있습니다. <code>Result</code>가 <code>Ok</code> 값이면 이 메서드의 동작은 <code>unwrap</code>과 유사합니다. 즉, <code>Ok</code>가 감싸고 있는 내부 값을 반환합니다. 하지만 값이 <code>Err</code>이면, 이 메서드는 우리가 정의하여 <code>unwrap_or_else</code>의 인수로 전달한 _클로저(closure)_의 코드를 호출합니다. 클로저에 대해서는 <a href="ch13-00-functional-features.html">13장</a><!-- ignore -->에서 더 자세히 다룰 것입니다. 지금은 <code>unwrap_or_else</code>가 <code>Err</code> 내부의 값(여기서는 목록 12-9에서 추가한 정적 문자열 <code>"인수가 부족합니다"</code>)을 수직 파이프 사이에 있는 인수 <code>err</code>을 통해 클로저로 전달한다는 것만 알면 됩니다. 그러면 클로저 내부의 코드가 실행될 때 이 <code>err</code> 값을 사용할 수 있습니다.</p>
<p>표준 라이브러리에서 <code>process</code>를 가져오기 위해 새로운 <code>use</code> 라인을 추가했습니다. 에러 발생 시 실행될 클로저 내부의 코드는 단 두 줄입니다. <code>err</code> 값을 출력하고 <code>process::exit</code>를 호출합니다. <code>process::exit</code> 함수는 프로그램을 즉시 중단하고 인수로 전달된 숫자를 종료 상태 코드로 반환합니다. 이는 목록 12-8에서 사용한 <code>panic!</code> 기반 처리와 유사하지만, 더 이상 불필요한 추가 출력들을 보지 않아도 됩니다. 실행해 봅시다:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/minigrep`
Problem parsing arguments: not enough arguments
</code></pre>
<p>좋습니다! 이 출력은 우리 사용자들에게 훨씬 더 친절합니다.</p>
<h3 id="main에서-로직-추출하기"><a class="header" href="#main에서-로직-추출하기"><code>main</code>에서 로직 추출하기</a></h3>
<p>설정 파싱의 리팩터링을 마쳤으니, 이제 프로그램의 로직으로 눈을 돌려봅시다. <a href="ch12-03-improving-error-handling-and-modularity.html#separation-of-concerns-for-binary-projects">“바이너리 프로젝트를 위한 관심사 분리”</a><!-- ignore -->에서 언급했듯이, 설정이나 에러 처리를 제외하고 현재 <code>main</code> 함수에 있는 모든 로직을 담을 <code>run</code>이라는 함수를 추출하겠습니다. 작업이 끝나면 <code>main</code>은 간결해지고 훑어보는 것만으로도 올바름을 검증할 수 있게 될 것이며, 다른 모든 로직에 대해서는 테스트를 작성할 수 있게 될 것입니다.</p>
<p>목록 12-11은 추출된 <code>run</code> 함수를 보여줍니다. 현재로서는 함수를 추출하는 작고 점진적인 개선만 진행하고 있습니다. 함수는 여전히 _src/main.rs_에 정의합니다.</p>
<Listing number="12-11" file-name="src/main.rs" caption="Extracting a `run` function containing the rest of the program logic">
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --생략--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("인수 파싱 중 문제 발생: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!("Searching for {}", config.query);
    println!("In file {}", config.file_path);

    run(config);
}

fn run(config: Config) {
    let contents = fs::read_to_string(config.file_path)
        .expect("파일을 읽을 수 있어야 합니다");

    println!("텍스트 내용:\n{contents}");
}

// --생략--
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("인수가 부족합니다");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p><code>run</code> 함수는 이제 파일을 읽는 것부터 시작하여 <code>main</code>에 남은 모든 로직을 포함합니다. <code>run</code> 함수는 <code>Config</code> 인스턴스를 인수로 받습니다.</p>
<h4 id="run-함수에서-에러-반환하기"><a class="header" href="#run-함수에서-에러-반환하기"><code>run</code> 함수에서 에러 반환하기</a></h4>
<p>나머지 프로그램 로직이 <code>run</code> 함수로 분리되었으므로, 목록 12-9의 <code>Config::build</code>에서 했던 것처럼 에러 처리를 개선할 수 있습니다. <code>expect</code>를 호출하여 프로그램이 패닉을 일으키게 두는 대신, 문제가 발생했을 때 <code>run</code> 함수가 <code>Result&lt;T, E&gt;</code>를 반환하도록 하겠습니다. 이렇게 하면 에러 처리에 관한 로직을 사용자 친화적인 방식으로 <code>main</code>에 더 통합할 수 있습니다. 목록 12-12는 <code>run</code>의 시그니처와 본문에 필요한 변경 사항을 보여줍니다.</p>
<Listing number="12-12" file-name="src/main.rs" caption="Changing the `run` function to return `Result`">
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span>use std::error::Error;

// --생략--

<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("인수 파싱 중 문제 발생: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span><span class="boring">    run(config);
</span><span class="boring">}
</span><span class="boring">
</span>fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    println!("텍스트 내용:\n{contents}");

    Ok(())
}
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("인수가 부족합니다");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>여기서 세 가지 중요한 변경을 했습니다. 첫째, <code>run</code> 함수의 반환 타입을 <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>로 변경했습니다. 이 함수는 이전에 유닛 타입 <code>()</code>를 반환했으므로, <code>Ok</code> 케이스에서 반환되는 값으로 이를 유지합니다.</p>
<p>에러 타입으로 _트레이트 객체_인 <code>Box&lt;dyn Error&gt;</code>를 사용했습니다(그리고 상단에 <code>use</code> 문을 사용하여 <code>std::error::Error</code>를 가져왔습니다). 트레이트 객체에 대해서는 <a href="ch18-00-oop.html">18장</a><!-- ignore -->에서 다룰 예정입니다. 지금은 <code>Box&lt;dyn Error&gt;</code>가 이 함수가 <code>Error</code> 트레이트를 구현하는 타입을 반환할 것이라는 의미이며, 반환 값이 구체적으로 어떤 타입일지 지정할 필요가 없다는 것만 알아두면 됩니다. 이를 통해 서로 다른 에러 상황에서 서로 다른 타입의 에러 값을 반환할 수 있는 유연성을 얻게 됩니다. <code>dyn</code> 키워드는 _동적(dynamic)_의 줄임말입니다.</p>
<p>두 번째로, <a href="ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator">9장</a><!-- ignore -->에서 이야기했듯이 <code>expect</code> 호출을 <code>?</code> 연산자로 대체했습니다. 오류 발생 시 <code>panic!</code>을 호출하는 대신, <code>?</code>는 현재 함수에서 오류 값을 반환하여 호출자가 처리하도록 합니다.</p>
<p>셋째, <code>run</code> 함수는 이제 성공 시 <code>Ok</code> 값을 반환합니다. 시그니처에서 <code>run</code> 함수의 성공 타입을 <code>()</code>로 선언했으므로, 유닛 타입 값을 <code>Ok</code> 값으로 감싸야 합니다. 이 <code>Ok(())</code> 문법이 처음에는 다소 생소해 보일 수 있지만, 이렇게 <code>()</code>를 사용하는 것은 <code>run</code> 함수를 호출하는 목적이 오직 부수 효과(side effect)에 있으며, 우리가 필요로 하는 값을 반환하지 않는다는 것을 나타내는 관용적인 방법입니다.</p>
<p>이 코드를 실행하면 컴파일은 되지만 경고가 표시될 것입니다:</p>
<pre><code class="language-console">$ cargo run -- the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
warning: unused `Result` that must be used
  --&gt; src/main.rs:19:5
   |
19 |     run(config);
   |     ^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
19 |     let _ = run(config);
   |     +++++++

warning: `minigrep` (bin "minigrep") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.71s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

</code></pre>
<p>러스트는 우리 코드가 <code>Result</code> 값을 무시했으며, 이 <code>Result</code> 값이 에러가 발생했음을 나타낼 수도 있다고 알려줍니다. 하지만 우리는 에러가 있었는지 확인하지 않고 있으며, 컴파일러는 여기에 에러 처리 코드가 필요할 것이라고 상기시켜 줍니다! 이제 이 문제를 해결해 봅시다.</p>
<h4 id="main에서-run이-반환한-에러-처리하기"><a class="header" href="#main에서-run이-반환한-에러-처리하기"><code>main</code>에서 <code>run</code>이 반환한 에러 처리하기</a></h4>
<p>목록 12-10에서 <code>Config::build</code>와 함께 사용했던 것과 유사하지만 약간의 차이가 있는 기술을 사용하여 에러를 확인하고 처리해 보겠습니다.</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --생략--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("인수 파싱 중 문제 발생: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!("Searching for {}", config.query);
    println!("In file {}", config.file_path);

    if let Err(e) = run(config) {
        println!("애플리케이션 에러: {e}");
        process::exit(1);
    }
}
<span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    println!("텍스트 내용:\n{contents}");
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("인수가 부족합니다");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><code>run</code>이 <code>Err</code> 값을 반환하는지 확인하고, 그럴 경우 <code>process::exit(1)</code>을 호출하기 위해 <code>unwrap_or_else</code> 대신 <code>if let</code>을 사용합니다. <code>run</code> 함수는 <code>Config::build</code>가 <code>Config</code> 인스턴스를 반환하는 것처럼 우리가 <code>unwrap</code>하고 싶은 값을 반환하지 않습니다. <code>run</code>은 성공 시 <code>()</code>를 반환하므로, 우리는 에러를 감지하는 것에만 관심이 있습니다. 따라서 단지 <code>()</code>일 뿐인 언랩된 값을 반환받기 위해 <code>unwrap_or_else</code>를 사용할 필요가 없습니다.</p>
<p>두 경우 모두 <code>if let</code>과 <code>unwrap_or_else</code> 함수의 본문은 동일합니다. 에러를 출력하고 종료하는 것이죠.</p>
<h3 id="코드를-라이브러리-크레이트로-분리하기"><a class="header" href="#코드를-라이브러리-크레이트로-분리하기">코드를 라이브러리 크레이트로 분리하기</a></h3>
<p>우리 <code>minigrep</code> 프로젝트가 지금까지는 아주 좋아 보이네요! 이제 <em>src/main.rs</em> 파일을 분리하여 일부 코드를 <em>src/lib.rs</em> 파일에 넣겠습니다. 그렇게 하면 코드를 테스트할 수 있고, <em>src/main.rs</em> 파일의 책임을 줄일 수 있습니다.</p>
<p><code>main</code> 함수에 있지 않은 모든 코드를 _src/main.rs_에서 _src/lib.rs_로 옮겨 봅시다:</p>
<ul>
<li><code>run</code> 함수 정의</li>
<li>관련 <code>use</code> 문들</li>
<li><code>Config</code> 정의</li>
<li><code>Config::build</code> 함수 정의</li>
</ul>
<p>_src/lib.rs_의 내용은 목록 12-13에 표시된 시그니처들을 가져야 합니다(간결함을 위해 함수 본문은 생략했습니다). 목록 12-14에서 _src/main.rs_를 수정하기 전까지는 컴파일되지 않는다는 점에 주의하세요.</p>
<Listing number="12-13" file-name="src/lib.rs" caption="Moving `Config` and `run` into *src/lib.rs*">
<pre><code class="language-rust ignore does_not_compile">use std::error::Error;
use std::fs;

pub struct Config {
    pub query: String,
    pub file_path: String,
}

impl Config {
    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --생략--
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("인수가 부족합니다");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span>    }
}

pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // --생략--
<span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    println!("텍스트 내용:\n{contents}");
</span><span class="boring">
</span><span class="boring">    Ok(())
</span>}</code></pre>
</Listing>
<p><code>Config</code>와 그 필드들, <code>build</code> 메서드, 그리고 <code>run</code> 함수에 <code>pub</code> 키워드를 아낌없이 사용했습니다. 이제 테스트 가능한 공개 API를 갖춘 라이브러리 크레이트가 생겼습니다!</p>
<p>이제 목록 12-14와 같이 _src/lib.rs_로 옮긴 코드를 _src/main.rs_의 바이너리 크레이트 스코프로 가져와야 합니다.</p>
<Listing number="12-14" file-name="src/main.rs" caption="Using the `minigrep` library crate in *src/main.rs*">
<pre><code class="language-rust ignore">use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // --생략--
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!("인수 파싱 중 문제 발생: {err}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("Searching for {}", config.query);
</span><span class="boring">    println!("In file {}", config.file_path);
</span><span class="boring">
</span>    if let Err(e) = minigrep::run(config) {
        // --생략--
<span class="boring">        println!("애플리케이션 에러: {e}");
</span><span class="boring">        process::exit(1);
</span>    }
}</code></pre>
</Listing>
<p>라이브러리 크레이트의 <code>Config</code> 타입을 바이너리 크레이트의 스코프로 가져오기 위해 <code>use minigrep::Config</code> 라인을 추가하고, <code>run</code> 함수 앞에 우리 크레이트 이름을 붙입니다. 이제 모든 기능이 연결되어 작동할 것입니다. <code>cargo run</code>으로 프로그램을 실행하여 모든 것이 올바르게 작동하는지 확인하세요.</p>
<p>휴! 일이 꽤 많았지만, 앞으로의 성공을 위한 기반을 닦았습니다. 이제 에러 처리가 훨씬 쉬워졌고, 코드도 더 모듈화되었습니다. 앞으로는 거의 모든 작업을 _src/lib.rs_에서 하게 될 것입니다.</p>
<p>이러한 모듈화의 장점을 활용하여 이전 코드에서는 어려웠지만 새 코드에서는 쉬운 작업을 해봅시다. 바로 테스트를 작성하는 것입니다!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="테스트-주도-개발로-라이브러리-기능-개발하기"><a class="header" href="#테스트-주도-개발로-라이브러리-기능-개발하기">테스트 주도 개발로 라이브러리 기능 개발하기</a></h2>
<p>로직을 _src/lib.rs_로 추출하고 인수 수집 및 에러 처리를 _src/main.rs_에 남겨두었으니, 이제 코드의 핵심 기능에 대한 테스트를 작성하기가 훨씬 쉬워졌습니다. 명령줄에서 바이너리를 직접 호출할 필요 없이, 다양한 인수를 사용하여 함수를 직접 호출하고 반환 값을 확인할 수 있습니다.</p>
<p>이 섹션에서는 다음과 같은 단계의 테스트 주도 개발(TDD) 프로세스를 사용하여 <code>minigrep</code> 프로그램에 검색 로직을 추가하겠습니다:</p>
<ol>
<li>실패하는 테스트를 작성하고 실행하여, 예상한 이유로 실패하는지 확인합니다.</li>
<li>새로운 테스트를 통과시키기에 딱 필요한 만큼만 코드를 작성하거나 수정합니다.</li>
<li>방금 추가하거나 변경한 코드를 리팩터링하고 테스트가 계속 통과하는지 확인합니다.</li>
<li>1단계부터 반복합니다!</li>
</ol>
<p>소프트웨어를 작성하는 여러 방법 중 하나일 뿐이지만, TDD는 코드 설계를 주도하는 데 도움이 될 수 있습니다. 테스트를 통과시키는 코드를 작성하기 전에 테스트를 먼저 작성하면 프로세스 전반에 걸쳐 높은 테스트 커버리지를 유지하는 데 도움이 됩니다.</p>
<p>파일 내용에서 검색어 문자열을 실제로 검색하고 검색어와 일치하는 줄 목록을 생성하는 기능의 구현을 TDD로 진행해 보겠습니다. 이 기능을 <code>search</code>라는 함수에 추가하겠습니다.</p>
<h3 id="실패하는-테스트-작성하기"><a class="header" href="#실패하는-테스트-작성하기">실패하는 테스트 작성하기</a></h3>
<p>더 이상 필요하지 않으므로, 프로그램의 동작을 확인하기 위해 사용했던 <code>println!</code> 문들을 _src/lib.rs_와 _src/main.rs_에서 제거합시다. 그런 다음 <a href="ch11-01-writing-tests.html#the-anatomy-of-a-test-function">11장</a><!-- ignore -->에서 했던 것처럼 _src/lib.rs_에 테스트 함수가 포함된 <code>tests</code> 모듈을 추가하겠습니다. 테스트 함수는 우리가 <code>search</code> 함수가 갖기를 원하는 동작을 명시합니다. 즉, 검색어와 검색할 텍스트를 인수로 받아, 텍스트 중에서 검색어를 포함하는 줄들만 반환해야 합니다. 목록 12-15는 아직 컴파일되지 않는 이 테스트를 보여줍니다.</p>
<Listing number="12-15" file-name="src/lib.rs" caption="Creating a failing test for the `search` function we wish we had">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("인수가 부족합니다");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_result() {
        let query = "duct";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.";

        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
    }
}</code></pre>
</Listing>
<p>이 테스트는 <code>"duct"</code>라는 문자열을 검색합니다. 검색 대상 텍스트는 세 줄이며, 그중 한 줄만 <code>"duct"</code>를 포함하고 있습니다(여는 따옴표 뒤의 백슬래시는 러스트에게 이 문자열 리터럴의 시작 부분에 개행 문자를 넣지 말라고 알려주는 것임에 주의하세요). 우리는 <code>search</code> 함수에서 반환된 값이 우리가 기대하는 줄만 포함하고 있는지 단언합니다.</p>
<p>아직은 이 테스트를 실행하여 실패하는 것을 볼 수 없는데, 테스트가 컴파일조차 되지 않기 때문입니다. <code>search</code> 함수가 아직 존재하지 않으니까요! TDD 원칙에 따라, 목록 12-16과 같이 항상 빈 벡터를 반환하는 <code>search</code> 함수의 정의를 추가하여 테스트가 컴파일되고 실행되기에 충분한 코드만 추가하겠습니다. 그러면 테스트는 컴파일될 것이고, 빈 벡터가 <code>"safe, fast, productive."</code>라는 줄을 포함한 벡터와 일치하지 않기 때문에 실패할 것입니다.</p>
<Listing number="12-16" file-name="src/lib.rs" caption="Defining just enough of the `search` function so our test will compile">
<pre><code class="language-rust noplayground"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("인수가 부족합니다");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    vec![]
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p><code>search</code>의 시그니처에서 명시적인 라이프타임 <code>'a</code>를 정의하고, 이를 <code>contents</code> 인수와 반환 값에 사용해야 함에 주목하세요. <a href="ch10-03-lifetime-syntax.html">10장</a><!-- ignore -->에서 배웠듯이, 라이프타임 매개변수는 어떤 인수의 라이프타임이 반환 값의 라이프타임과 연결되는지를 명시합니다. 이 경우, 반환된 벡터가 (<code>query</code> 인수가 아닌) <code>contents</code> 인수의 슬라이스를 참조하는 문자열 슬라이스들을 포함해야 함을 나타냅니다.</p>
<p>다시 말해, 우리는 <code>search</code> 함수가 반환하는 데이터가 <code>contents</code> 인수로 전달된 데이터만큼 오래 살 것이라고 러스트에게 알려주는 것입니다. 이는 중요합니다! 슬라이스에 의해 참조되는 데이터는 그 참조가 유효한 동안 반드시 유효해야 합니다. 만약 컴파일러가 우리가 <code>contents</code>가 아닌 <code>query</code>의 문자열 슬라이스를 만든다고 가정한다면, 안전성 검사를 잘못 수행하게 될 것입니다.</p>
<p>만약 라이프타임 명시를 잊어버리고 이 함수를 컴파일하려고 하면, 다음과 같은 에러가 발생합니다:</p>
<pre><code class="language-console">$ cargo build
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
error[E0106]: missing lifetime specifier
  --&gt; src/lib.rs:28:51
   |
28 | pub fn search(query: &amp;str, contents: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
   |                      ----            ----         ^ expected named lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `query` or `contents`
help: consider introducing a named lifetime parameter
   |
28 | pub fn search&lt;'a&gt;(query: &amp;'a str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
   |              ++++         ++                 ++              ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `minigrep` (lib) due to 1 previous error
</code></pre>
<p>러스트가 두 인수 중 어느 것이 필요한지 알 방법이 없으므로, 우리가 명시적으로 알려주어야 합니다. <code>contents</code>가 모든 텍스트를 담고 있는 인수이고 우리는 그 텍스트 중 일치하는 부분들을 반환하고 싶어 하므로, <code>contents</code>가 라이프타임 문법을 통해 반환 값과 연결되어야 할 인수라는 것을 알 수 있습니다.</p>
<p>다른 프로그래밍 언어들은 시그니처에서 인수와 반환 값을 연결할 것을 요구하지 않지만, 이 관행은 시간이 지남에 따라 익숙해질 것입니다. 이 예제를 10장의 <a href="ch10-03-lifetime-syntax.html#validating-references-with-lifetimes">“라이프타임으로 참조 유효성 검증하기”</a><!-- ignore --> 섹션에 있는 예제들과 비교해 보는 것도 좋을 것입니다.</p>
<p>이제 테스트를 실행해 봅시다:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.97s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::one_result ... FAILED

failures:

---- tests::one_result stdout ----
thread 'tests::one_result' panicked at src/lib.rs:44:9:
assertion `left == right` failed
  left: ["safe, fast, productive."]
 right: []
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::one_result

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>좋습니다, 테스트가 정확히 예상했던 대로 실패하네요. 이제 테스트를 통과시켜 봅시다!</p>
<h3 id="테스트를-통과시키기-위한-코드-작성하기"><a class="header" href="#테스트를-통과시키기-위한-코드-작성하기">테스트를 통과시키기 위한 코드 작성하기</a></h3>
<p>현재 우리 테스트는 항상 빈 벡터를 반환하기 때문에 실패하고 있습니다. 이를 해결하고 <code>search</code>를 구현하기 위해, 우리 프로그램은 다음과 같은 단계들을 거쳐야 합니다:</p>
<ol>
<li>내용의 각 줄을 반복합니다.</li>
<li>해당 줄이 검색어 문자열을 포함하고 있는지 확인합니다.</li>
<li>포함하고 있다면, 반환할 값 목록에 추가합니다.</li>
<li>포함하고 있지 않다면, 아무것도 하지 않습니다.</li>
<li>일치하는 결과 목록을 반환합니다.</li>
</ol>
<p>각 단계를 차례대로 진행해 보죠. 먼저 줄들을 반복하는 것부터 시작합니다.</p>
<h4 id="lines-메서드로-줄-반복하기"><a class="header" href="#lines-메서드로-줄-반복하기"><code>lines</code> 메서드로 줄 반복하기</a></h4>
<p>Rust has a helpful method to handle line-by-line iteration of strings, conveniently named <code>lines</code>, that works as shown in Listing 12-17. Note that this won’t compile yet.</p>
<Listing number="12-17" file-name="src/lib.rs" caption="Iterating through each line in `contents`">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("인수가 부족합니다");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        // 여기서 line으로 무언가를 합니다
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p><code>lines</code> 메서드는 반복자를 반환합니다. 반복자에 대해서는 <a href="ch13-02-iterators.html">13장</a><!-- ignore -->에서 깊이 있게 다루겠지만, <a href="ch03-05-control-flow.html#looping-through-a-collection-with-for">목록 3-5</a><!-- ignore -->에서 컬렉션의 각 아이템에 대해 코드를 실행하기 위해 반복자와 <code>for</code> 루프를 사용했던 방식을 기억해 보세요.</p>
<h4 id="각-줄에서-검색어-찾기"><a class="header" href="#각-줄에서-검색어-찾기">각 줄에서 검색어 찾기</a></h4>
<p>다음으로, 현재 줄이 우리 검색어 문자열을 포함하고 있는지 확인하겠습니다. 다행히 문자열에는 이를 대신해 주는 <code>contains</code>라는 유용한 메서드가 있습니다! 목록 12-18에 나온 것처럼 <code>search</code> 함수에서 <code>contains</code> 메서드를 호출하도록 추가하세요. 이 코드는 여전히 컴파일되지 않는다는 점에 주의하세요.</p>
<Listing number="12-18" file-name="src/lib.rs" caption="Adding functionality to see whether the line contains the string in `query`">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("인수가 부족합니다");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        if line.contains(query) {
            // 여기서 line으로 무언가를 합니다
        }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>현재 우리는 기능을 하나씩 만들어가는 중입니다. 코드를 컴파일하려면, 함수 시그니처에서 명시한 대로 본문에서 값을 반환해야 합니다.</p>
<h4 id="일치하는-줄-저장하기"><a class="header" href="#일치하는-줄-저장하기">일치하는 줄 저장하기</a></h4>
<p>이 함수를 완성하려면, 우리가 반환하고자 하는 일치하는 줄들을 저장할 방법이 필요합니다. 이를 위해 <code>for</code> 루프 이전에 가변 벡터를 만들고, 벡터의 <code>push</code> 메서드를 호출하여 <code>line</code>을 저장할 수 있습니다. <code>for</code> 루프가 끝난 뒤에는 목록 12-19와 같이 벡터를 반환합니다.</p>
<Listing number="12-19" file-name="src/lib.rs" caption="Storing the lines that match so we can return them">
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("인수가 부족합니다");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>이제 <code>search</code> 함수는 <code>query</code>를 포함하는 줄들만 반환해야 하며, 우리 테스트는 통과해야 합니다. 테스트를 실행해 봅시다:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.22s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::one_result ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>테스트가 통과했으니, 우리는 이것이 작동한다는 것을 압니다!</p>
<p>이 시점에서, 동일한 기능을 유지하면서 테스트를 통과시킨 채로 <code>search</code> 함수의 구현을 리팩터링할 기회를 고려해 볼 수 있습니다. <code>search</code> 함수의 코드가 나쁘지는 않지만, 반복자의 몇몇 유용한 기능을 활용하고 있지는 않습니다. <a href="ch13-02-iterators.html">13장</a><!-- ignore -->에서 반복자를 자세히 다루며 이 예제로 돌아와 어떻게 개선할 수 있는지 살펴보겠습니다.</p>
<h4 id="run-함수에서-search-함수-사용하기"><a class="header" href="#run-함수에서-search-함수-사용하기"><code>run</code> 함수에서 <code>search</code> 함수 사용하기</a></h4>
<p><code>search</code> 함수가 잘 작동하고 테스트도 통과했으므로, 이제 <code>run</code> 함수에서 <code>search</code>를 호출해야 합니다. <code>config.query</code> 값과 <code>run</code>이 파일에서 읽어온 <code>contents</code>를 <code>search</code> 함수에 전달해야 합니다. 그러면 <code>run</code>은 <code>search</code>에서 반환된 각 줄을 출력할 것입니다:</p>
<p><span class="filename">파일명: src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("인수가 부족합니다");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    for line in search(&amp;config.query, &amp;contents) {
        println!("{line}");
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>우리는 여전히 <code>for</code> 루프를 사용하여 <code>search</code>에서 반환된 각 줄을 출력합니다.</p>
<p>이제 프로그램 전체가 작동할 것입니다! 먼저 에밀리 디킨슨의 시에서 정확히 한 줄만 반환해야 하는 단어인 _frog_로 테스트해 봅시다.</p>
<pre><code class="language-console">$ cargo run -- frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.38s
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
</code></pre>
<p>멋지네요! 이번에는 _body_와 같이 여러 줄에 매칭되는 단어를 시도해 봅시다:</p>
<pre><code class="language-console">$ cargo run -- body poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep body poem.txt`
I'm nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>마지막으로, 시의 어디에도 없는 단어인 _monomorphization_으로 검색했을 때 아무런 줄도 나오지 않는지 확인해 봅시다.</p>
<pre><code class="language-console">$ cargo run -- monomorphization poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep monomorphization poem.txt`
</code></pre>
<p>훌륭합니다! 우리는 고전적인 도구의 미니 버전을 직접 만들어 보았고, 애플리케이션을 구조화하는 방법에 대해 많은 것을 배웠습니다. 또한 파일 입출력, 라이프타임, 테스팅, 그리고 명령줄 파싱에 대해서도 조금 더 알게 되었습니다.</p>
<p>이 프로젝트를 마무리하기 위해, 명령줄 프로그램을 작성할 때 유용한 환경 변수 사용법과 표준 에러 출력 방법을 간략히 시연해 보겠습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="환경-변수-다루기"><a class="header" href="#환경-변수-다루기">환경 변수 다루기</a></h2>
<p>우리는 <code>minigrep</code>에 추가 기능을 더해 개선해 보겠습니다. 바로 사용자가 환경 변수를 통해 켤 수 있는 대소문자 구분 없는 검색 옵션입니다. 이 기능을 명령줄 옵션으로 만들어 매번 입력하게 할 수도 있지만, 대신 환경 변수로 만들면 사용자가 해당 터미널 세션에서 한 번만 설정하면 모든 검색에 대소문자 구분을 없앨 수 있습니다.</p>
<h3 id="대소문자-구분-없는-search-함수를-위한-실패하는-테스트-작성하기"><a class="header" href="#대소문자-구분-없는-search-함수를-위한-실패하는-테스트-작성하기">대소문자 구분 없는 <code>search</code> 함수를 위한 실패하는 테스트 작성하기</a></h3>
<p>먼저 환경 변수가 설정되어 있을 때 호출될 새로운 <code>search_case_insensitive</code> 함수를 추가하겠습니다. 우리는 계속해서 TDD 프로세스를 따를 것이므로, 첫 번째 단계는 다시 실패하는 테스트를 작성하는 것입니다. 목록 12-20에 나온 것처럼 새로운 <code>search_case_insensitive</code> 함수를 위한 테스트를 추가하고, 두 테스트의 차이를 명확히 하기 위해 기존의 <code>one_result</code> 테스트 이름을 <code>case_sensitive</code>로 변경하겠습니다.</p>
<Listing number="12-20" file-name="src/lib.rs" caption="Adding a new failing test for the case-insensitive function we’re about to add">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("인수가 부족합니다");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    for line in search(&amp;config.query, &amp;contents) {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn case_sensitive() {
        let query = "duct";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.
Duct tape.";

        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
    }

    #[test]
    fn case_insensitive() {
        let query = "rUsT";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.
Trust me.";

        assert_eq!(
            vec!["Rust:", "Trust me."],
            search_case_insensitive(query, contents)
        );
    }
}</code></pre>
</Listing>
<p>기존 테스트의 <code>contents</code>도 수정했음에 주목하세요. 대문자 _D_로 시작하는 <code>"Duct tape."</code>이라는 새로운 줄을 추가했는데, 이는 대소문자를 구분하는 검색에서 <code>"duct"</code>와 일치하지 않아야 합니다. 기존 테스트를 이런 식으로 변경하면 이미 구현된 대소문자 구분 검색 기능을 실수로 망가뜨리지 않도록 보장하는 데 도움이 됩니다. 이 테스트는 지금도 통과해야 하며, 우리가 대소문자 구분 없는 검색 작업을 하는 동안에도 계속 통과해야 합니다.</p>
<p>대소문자를 <em>구분하지 않는</em> 검색을 위한 새로운 테스트는 <code>"rUsT"</code>를 검색어로 사용합니다. 우리가 추가할 <code>search_case_insensitive</code> 함수에서, <code>"rUsT"</code> 검색어는 대문자 _R_이 포함된 <code>"Rust:"</code> 줄과도 매치되어야 하고, 대소문자가 다르지만 <code>"Trust me."</code> 줄과도 매치되어야 합니다. 이것이 우리의 실패하는 테스트이며, 아직 <code>search_case_insensitive</code> 함수를 정의하지 않았으므로 컴파일에 실패할 것입니다. 목록 12-16의 <code>search</code> 함수에서 했던 것처럼 항상 빈 벡터를 반환하는 뼈대 구현을 추가하여 테스트가 컴파일되고 실패하는 것을 확인해도 좋습니다.</p>
<h3 id="search_case_insensitive-함수-구현하기"><a class="header" href="#search_case_insensitive-함수-구현하기"><code>search_case_insensitive</code> 함수 구현하기</a></h3>
<p>목록 12-21에 표시된 <code>search_case_insensitive</code> 함수는 <code>search</code> 함수와 거의 동일할 것입니다. 유일한 차이점은 <code>query</code>와 각 <code>line</code>을 소문자로 변환하여, 입력 인수의 대소문자가 어떻든 간에 해당 줄이 검색어를 포함하고 있는지 확인할 때는 동일한 대소문자가 되도록 한다는 것입니다.</p>
<Listing number="12-21" file-name="src/lib.rs" caption="Defining the `search_case_insensitive` function to lowercase the query and the line before comparing them">
<pre><code class="language-rust noplayground"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("인수가 부족합니다");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    for line in search(&amp;config.query, &amp;contents) {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search_case_insensitive&lt;'a&gt;(
    query: &amp;str,
    contents: &amp;'a str,
) -&gt; Vec&lt;&amp;'a str&gt; {
    let query = query.to_lowercase();
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.to_lowercase().contains(&amp;query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>먼저 <code>query</code> 문자열을 소문자로 변환하고 같은 이름의 새 변수에 저장하여 원래 변수를 섀도잉(shadowing)합니다. 사용자의 검색어가 <code>"rust"</code>, <code>"RUST"</code>, <code>"Rust"</code>, 또는 <code>"rUsT"</code> 등 무엇이든 상관없이 <code>"rust"</code>인 것처럼 처리하고 대소문자를 구분하지 않게 하려면 쿼리에 <code>to_lowercase</code>를 호출해야 합니다. <code>to_lowercase</code>는 기본적인 유니코드를 처리하지만 100% 정확하지는 않습니다. 실제 애플리케이션을 작성한다면 여기서 더 많은 작업을 해야 하겠지만, 이 섹션은 유니코드가 아닌 환경 변수에 관한 내용이므로 여기까지만 하겠습니다.</p>
<p><code>to_lowercase</code>를 호출하면 기존 데이터를 참조하는 것이 아니라 새로운 데이터를 생성하므로, <code>query</code>는 이제 문자열 슬라이스가 아니라 <code>String</code>이라는 점에 유의하세요. 예를 들어 쿼리가 <code>"rUsT"</code>라고 해봅시다. 그 문자열 슬라이스에는 우리가 사용할 수 있는 소문자 <code>u</code>나 <code>t</code>가 포함되어 있지 않으므로, <code>"rust"</code>를 포함하는 새로운 <code>String</code>을 할당해야 합니다. 이제 <code>contains</code> 메서드에 <code>query</code>를 인수로 전달할 때, <code>contains</code>의 시그니처가 문자열 슬라이스를 받도록 정의되어 있으므로 앰퍼샌드(&amp;)를 추가해야 합니다.</p>
<p>다음으로, 모든 문자를 소문자로 만들기 위해 각 <code>line</code>에 <code>to_lowercase</code> 호출을 추가합니다. 이제 <code>line</code>과 <code>query</code>를 모두 소문자로 변환했으므로, 쿼리의 대소문자가 어떻든 상관없이 일치하는 항목을 찾을 수 있습니다.</p>
<p>이 구현이 테스트를 통과하는지 확인해 봅시다:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.33s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 2 tests
test tests::case_insensitive ... ok
test tests::case_sensitive ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>좋습니다! 테스트들이 통과했습니다. 이제 <code>run</code> 함수에서 새로운 <code>search_case_insensitive</code> 함수를 호출해 봅시다. 먼저 <code>Config</code> 구조체에 대소문자 구분 검색과 구분 없는 검색을 전환할 수 있는 설정 옵션을 추가하겠습니다. 이 필드를 추가하면 아직 어디에서도 초기화하고 있지 않기 때문에 컴파일러 에러가 발생할 것입니다:</p>
<p><span class="filename">파일명: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>pub struct Config {
    pub query: String,
    pub file_path: String,
    pub ignore_case: bool,
}
<span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("인수가 부족합니다");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>불리언 값을 저장하는 <code>ignore_case</code> 필드를 추가했습니다. 다음으로, 목록 12-22에 나온 것처럼 <code>run</code> 함수가 <code>ignore_case</code> 필드 값을 확인하여 <code>search</code> 함수를 호출할지 <code>search_case_insensitive</code> 함수를 호출할지 결정하도록 해야 합니다. 이 코드는 아직 컴파일되지 않습니다.</p>
<Listing number="12-22" file-name="src/lib.rs" caption="Calling either `search` or `search_case_insensitive` based on the value in `config.ignore_case`">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("인수가 부족합니다");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    let results = if config.ignore_case {
        search_case_insensitive(&amp;config.query, &amp;contents)
    } else {
        search(&amp;config.query, &amp;contents)
    };

    for line in results {
        println!("{line}");
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>마지막으로, 환경 변수를 확인해야 합니다. 환경 변수를 다루는 함수들은 표준 라이브러리의 <code>env</code> 모듈에 있으므로, <em>src/lib.rs</em> 상단에서 해당 모듈을 스코프로 가져옵니다. 그런 다음 목록 12-23에 나온 것처럼 <code>env</code> 모듈의 <code>var</code> 함수를 사용하여 <code>IGNORE_CASE</code>라는 이름의 환경 변수에 어떤 값이 설정되어 있는지 확인합니다.</p>
<Listing number="12-23" file-name="src/lib.rs" caption="Checking for any value in an environment variable named `IGNORE_CASE`">
<pre><code class="language-rust noplayground">use std::env;
// --생략--

<span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err("인수가 부족합니다");
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        let ignore_case = env::var("IGNORE_CASE").is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>여기서 <code>ignore_case</code>라는 새 변수를 생성합니다. 이 값을 설정하기 위해 <code>env::var</code> 함수를 호출하고 <code>IGNORE_CASE</code> 환경 변수의 이름을 전달합니다. <code>env::var</code> 함수는 환경 변수가 어떤 값으로든 설정되어 있으면 그 값을 포함하는 성공적인 <code>Ok</code> 변형이 될 <code>Result</code>를 반환합니다. 환경 변수가 설정되어 있지 않으면 <code>Err</code> 변형을 반환할 것입니다.</p>
<p>우리는 <code>Result</code>의 <code>is_ok</code> 메서드를 사용하여 환경 변수가 설정되어 있는지 확인하는데, 설정되어 있다는 것은 프로그램이 대소문자를 구분하지 않는 검색을 해야 한다는 것을 의미합니다. <code>IGNORE_CASE</code> 환경 변수가 설정되어 있지 않다면, <code>is_ok</code>는 <code>false</code>를 반환하고 프로그램은 대소문자를 구분하는 검색을 수행할 것입니다. 우리는 환경 변수의 _값_에는 관심이 없고 단지 설정되었는지 여부만 중요하므로, <code>unwrap</code>이나 <code>expect</code> 또는 우리가 <code>Result</code>에서 보았던 다른 메서드들 대신 <code>is_ok</code>를 사용하고 있습니다.</p>
<p>우리는 <code>ignore_case</code> 변수의 값을 <code>Config</code> 인스턴스에 전달하여, 목록 12-22에서 구현한 것처럼 <code>run</code> 함수가 그 값을 읽고 <code>search_case_insensitive</code>를 호출할지 <code>search</code>를 호출할지 결정할 수 있게 합니다.</p>
<p>한번 시도해 봅시다! 먼저 환경 변수를 설정하지 않고 쿼리를 <code>to</code>로 하여 프로그램을 실행해 보겠습니다. 이는 소문자 _to_가 포함된 모든 줄과 매치되어야 합니다:</p>
<pre><code class="language-console">$ cargo run -- to poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>여전히 잘 작동하는 것 같군요! 이제 <code>IGNORE_CASE</code>를 <code>1</code>로 설정하고 동일한 쿼리 _to_로 프로그램을 실행해 봅시다:</p>
<pre><code class="language-console">$ IGNORE_CASE=1 cargo run -- to poem.txt
</code></pre>
<p>PowerShell을 사용하고 있다면, 환경 변수를 설정하는 명령과 프로그램을 실행하는 명령을 따로 입력해야 합니다:</p>
<pre><code class="language-console">PS&gt; $Env:IGNORE_CASE=1; cargo run -- to poem.txt
</code></pre>
<p>이렇게 하면 <code>IGNORE_CASE</code>가 현재 셸 세션이 끝날 때까지 유지됩니다. <code>Remove-Item</code> cmdlet을 사용하여 설정을 해제할 수 있습니다:</p>
<pre><code class="language-console">PS&gt; Remove-Item Env:IGNORE_CASE
</code></pre>
<p>이제 대문자를 포함하고 있을 수도 있는 _to_가 들어간 줄들을 얻어야 합니다:</p>
<!-- manual-regeneration
cd listings/ch12-an-io-project/listing-12-23
IGNORE_CASE=1 cargo run -- to poem.txt
can't extract because of the environment variable
-->
<pre><code class="language-console">Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>훌륭합니다, _To_가 포함된 줄도 얻었습니다! 이제 우리 <code>minigrep</code> 프로그램은 환경 변수로 제어되는 대소문자 구분 없는 검색을 수행할 수 있습니다. 이제 여러분은 명령줄 인수나 환경 변수를 사용하여 설정된 옵션을 관리하는 방법을 알게 되었습니다.</p>
<p>어떤 프로그램들은 동일한 설정을 위해 인수 <em>와</em> 환경 변수를 모두 허용합니다. 그런 경우, 프로그램은 둘 중 하나에 우선순위를 둡니다. 직접 해보는 또 다른 연습으로, 명령줄 인수나 환경 변수 중 하나를 통해 대소문자 구분을 제어해 보세요. 프로그램이 실행될 때 하나는 대소문자 구분을 설정하고 다른 하나는 무시하도록 설정되어 있다면, 명령줄 인수와 환경 변수 중 어느 것이 우선할지 결정해 보세요.</p>
<p><code>std::env</code> 모듈은 환경 변수를 다루기 위한 더 많은 유용한 기능들을 포함하고 있습니다. 문서에서 무엇을 사용할 수 있는지 확인해 보세요.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="표준-출력-대신-표준-에러로-에러-메시지-출력하기"><a class="header" href="#표준-출력-대신-표준-에러로-에러-메시지-출력하기">표준 출력 대신 표준 에러로 에러 메시지 출력하기</a></h2>
<p>현재 우리는 <code>println!</code> 매크로를 사용하여 모든 출력을 터미널에 쓰고 있습니다. 대부분의 터미널에는 두 종류의 출력이 있습니다. 일반 정보를 위한 <em>표준 출력</em>(<code>stdout</code>)과 에러 메시지를 위한 <em>표준 에러</em>(<code>stderr</code>)입니다. 이러한 구분은 사용자가 프로그램의 성공적인 출력을 파일로 보내면서도 에러 메시지는 여전히 화면에 출력되도록 선택할 수 있게 해줍니다.</p>
<p><code>println!</code> 매크로는 표준 출력으로만 인쇄할 수 있으므로, 표준 에러로 인쇄하려면 다른 것을 사용해야 합니다.</p>
<h3 id="에러가-어디에-쓰이는지-확인하기"><a class="header" href="#에러가-어디에-쓰이는지-확인하기">에러가 어디에 쓰이는지 확인하기</a></h3>
<p>먼저 <code>minigrep</code>이 출력하는 내용이 현재 어떻게 표준 출력으로 쓰이는지 관찰해 봅시다. 여기에는 우리가 표준 에러로 쓰고 싶어 하는 에러 메시지도 포함됩니다. 의도적으로 에러를 일으키면서 표준 출력 스트림을 파일로 리다이렉션하여 이를 확인해 보겠습니다. 표준 에러 스트림은 리다이렉션하지 않을 것이므로, 표준 에러로 전송된 내용은 계속 화면에 표시될 것입니다.</p>
<p>명령줄 프로그램은 표준 출력 스트림을 파일로 리다이렉션하더라도 화면에서 에러 메시지를 볼 수 있도록 에러 메시지를 표준 에러 스트림으로 보낼 것으로 기대됩니다. 우리 프로그램은 현재 올바르게 동작하고 있지 않습니다. 에러 메시지 출력이 파일로 저장되는 것을 보게 될 것입니다!</p>
<p>이 동작을 증명하기 위해, <code>&gt;</code>와 표준 출력 스트림을 리다이렉션할 파일 경로인 _output.txt_를 사용하여 프로그램을 실행해 보겠습니다. 에러를 유발하기 위해 아무런 인수도 전달하지 않겠습니다:</p>
<pre><code class="language-console">$ cargo run &gt; output.txt
</code></pre>
<p><code>&gt;</code> 문법은 셸에게 표준 출력의 내용을 화면 대신 _output.txt_에 쓰라고 지시합니다. 우리가 기대했던 에러 메시지가 화면에 출력되지 않았으므로, 이는 파일에 기록되었음이 분명합니다. _output.txt_의 내용은 다음과 같습니다:</p>
<pre><code class="language-text">Problem parsing arguments: not enough arguments
</code></pre>
<p>네, 에러 메시지가 표준 출력으로 인쇄되고 있군요. 이런 에러 메시지는 표준 에러로 인쇄되어, 성공적인 실행 결과만 파일에 저장되는 것이 훨씬 더 유용합니다. 이 부분을 수정해 보겠습니다.</p>
<h3 id="표준-에러로-에러-출력하기"><a class="header" href="#표준-에러로-에러-출력하기">표준 에러로 에러 출력하기</a></h3>
<p>목록 12-24의 코드를 사용하여 에러 메시지가 출력되는 방식을 변경해 보겠습니다. 이 장의 앞부분에서 수행한 리팩터링 덕분에, 에러 메시지를 출력하는 모든 코드는 하나의 함수, 즉 <code>main</code>에 모여 있습니다. 표준 라이브러리는 표준 에러 스트림으로 출력하는 <code>eprintln!</code> 매크로를 제공하므로, 에러를 출력하기 위해 <code>println!</code>을 호출하던 두 곳을 <code>eprintln!</code>으로 변경해 봅시다.</p>
<Listing number="12-24" file-name="src/main.rs" caption="Writing error messages to standard error instead of standard output using `eprintln!`">
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        eprintln!("인수 파싱 중 문제 발생: {err}");
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!("애플리케이션 에러: {e}");
        process::exit(1);
    }
}</code></pre>
</Listing>
<p>이제 이전과 같은 방식으로, 인수 없이 그리고 <code>&gt;</code>로 표준 출력을 리다이렉션하여 프로그램을 다시 실행해 봅시다:</p>
<pre><code class="language-console">$ cargo run &gt; output.txt
Problem parsing arguments: not enough arguments
</code></pre>
<p>이제 화면에서 에러를 볼 수 있고 _output.txt_에는 아무것도 들어있지 않습니다. 이것이 우리가 명령줄 프로그램에 기대하는 동작입니다.</p>
<p>에러를 일으키지 않는 인수를 사용하되 여전히 표준 출력을 파일로 리다이렉션하여 프로그램을 다시 실행해 봅시다. 다음과 같이요:</p>
<pre><code class="language-console">$ cargo run -- to poem.txt &gt; output.txt
</code></pre>
<p>터미널에는 아무런 출력도 나타나지 않으며, 결과는 _output.txt_에 담길 것입니다:</p>
<p><span class="filename">파일명: output.txt</span></p>
<pre><code class="language-text">Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>이는 우리가 이제 성공적인 출력에는 표준 출력을, 에러 출력에는 표준 에러를 적절하게 사용하고 있음을 보여줍니다.</p>
<h2 id="요약-11"><a class="header" href="#요약-11">요약</a></h2>
<p>이 장에서는 지금까지 배운 주요 개념들을 요약하고 러스트에서 일반적인 I/O 작업을 수행하는 방법을 다루었습니다. 명령줄 인수, 파일, 환경 변수, 그리고 에러 출력을 위한 <code>eprintln!</code> 매크로를 사용하여, 이제 여러분은 명령줄 애플리케이션을 작성할 준비가 되었습니다. 이전 장들의 개념들과 결합하면, 여러분의 코드는 잘 조직되고, 적절한 데이터 구조에 데이터를 효과적으로 저장하며, 에러를 훌륭하게 처리하고, 잘 테스트될 것입니다.</p>
<p>다음으로, 함수형 언어의 영향을 받은 러스트의 기능들인 클로저와 반복자에 대해 탐구해 보겠습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="함수형-언어-기능-반복자와-클로저"><a class="header" href="#함수형-언어-기능-반복자와-클로저">함수형 언어 기능: 반복자와 클로저</a></h1>
<p>러스트의 설계는 많은 기존 언어와 기술에서 영감을 받았으며, 중요한 영향을 준 것 중 하나는 _함수형 프로그래밍_입니다. 함수형 스타일의 프로그래밍은 함수를 인수로 전달하거나, 다른 함수에서 반환하거나, 나중에 실행하기 위해 변수에 할당하는 등 함수를 값처럼 사용하는 것을 포함합니다.</p>
<p>이 장에서는 함수형 프로그래밍이 무엇인지 아닌지에 대해 논쟁하지 않고, 대신 함수형이라고 불리는 많은 언어의 기능과 유사한 러스트의 몇 가지 기능에 대해 논의할 것입니다.</p>
<p>더 구체적으로, 다음 내용을 다룰 것입니다:</p>
<ul>
<li><em>클로저(Closures)</em>: 변수에 저장할 수 있는 함수와 유사한 구조</li>
<li><em>반복자(Iterators)</em>: 일련의 요소를 처리하는 방법</li>
<li>클로저와 반복자를 사용하여 12장의 I/O 프로젝트를 개선하는 방법</li>
<li>클로저와 반복자의 성능 (스포일러 주의: 생각보다 빠릅니다!)</li>
</ul>
<p>우리는 이미 패턴 매칭이나 열거형과 같이 함수형 스타일의 영향을 받은 다른 러스트 기능들을 다루었습니다. 클로저와 반복자를 마스터하는 것은 관용적이고 빠른 러스트 코드를 작성하는 데 중요한 부분이므로, 이 장 전체를 할애하여 다루겠습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- Old heading. Do not remove or links may break. -->
<p><a id="closures-anonymous-functions-that-can-capture-their-environment"></a></p>
<h2 id="클로저-환경을-캡처하는-익명-함수"><a class="header" href="#클로저-환경을-캡처하는-익명-함수">클로저: 환경을 캡처하는 익명 함수</a></h2>
<p>러스트의 클로저는 변수에 저장하거나 다른 함수에 인수로 전달할 수 있는 익명 함수입니다. 한 곳에서 클로저를 생성한 다음 다른 곳에서 호출하여 다른 컨텍스트에서 평가할 수 있습니다. 함수와 달리 클로저는 정의된 스코프의 값을 캡처할 수 있습니다. 이러한 클로저의 기능이 어떻게 코드 재사용과 동작 커스터마이징을 가능하게 하는지 보여드리겠습니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="creating-an-abstraction-of-behavior-with-closures"></a> <a id="refactoring-using-functions"></a> <a id="refactoring-with-closures-to-store-code"></a></p>
<h3 id="클로저로-환경-캡처하기"><a class="header" href="#클로저로-환경-캡처하기">클로저로 환경 캡처하기</a></h3>
<p>먼저 클로저를 사용하여 나중에 사용할 수 있도록 정의된 환경의 값을 캡처하는 방법을 살펴보겠습니다. 시나리오는 다음과 같습니다: 우리 티셔츠 회사는 가끔 프로모션으로 메일링 리스트에 있는 누군가에게 독점 한정판 셔츠를 무료로 증정합니다. 메일링 리스트에 있는 사람들은 선택적으로 자신의 프로필에 좋아하는 색상을 추가할 수 있습니다. 무료 셔츠 당첨자로 선정된 사람이 좋아하는 색상을 설정했다면, 그 색상의 셔츠를 받습니다. 좋아하는 색상을 지정하지 않았다면, 회사가 현재 가장 많이 보유하고 있는 색상의 셔츠를 받습니다.</p>
<p>이를 구현하는 방법은 여러 가지가 있습니다. 이 예제에서는 <code>Red</code>와 <code>Blue</code> 변형을 가진 <code>ShirtColor</code>라는 열거형을 사용하겠습니다(단순함을 위해 색상 수를 제한했습니다). 회사의 재고는 현재 재고에 있는 셔츠 색상을 나타내는 <code>Vec&lt;ShirtColor&gt;</code>를 담은 <code>shirts</code> 필드를 가진 <code>Inventory</code> 구조체로 나타냅니다. <code>Inventory</code>에 정의된 <code>giveaway</code> 메서드는 무료 셔츠 당첨자의 선택적인 선호 색상을 받아 그 사람이 받게 될 셔츠 색상을 반환합니다. 이 설정은 목록 13-1에 나와 있습니다:</p>
<Listing number="13-1" file-name="src/main.rs" caption="Shirt company giveaway situation">
<pre><code class="language-rust noplayground">#[derive(Debug, PartialEq, Copy, Clone)]
enum ShirtColor {
    Red,
    Blue,
}

struct Inventory {
    shirts: Vec&lt;ShirtColor&gt;,
}

impl Inventory {
    fn giveaway(&amp;self, user_preference: Option&lt;ShirtColor&gt;) -&gt; ShirtColor {
        user_preference.unwrap_or_else(|| self.most_stocked())
    }

    fn most_stocked(&amp;self) -&gt; ShirtColor {
        let mut num_red = 0;
        let mut num_blue = 0;

        for color in &amp;self.shirts {
            match color {
                ShirtColor::Red =&gt; num_red += 1,
                ShirtColor::Blue =&gt; num_blue += 1,
            }
        }
        if num_red &gt; num_blue {
            ShirtColor::Red
        } else {
            ShirtColor::Blue
        }
    }
}

fn main() {
    let store = Inventory {
        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],
    };

    let user_pref1 = Some(ShirtColor::Red);
    let giveaway1 = store.giveaway(user_pref1);
    println!(
        "선호도가 {:?}인 사용자는 {:?}를 받습니다",
        user_pref1, giveaway1
    );

    let user_pref2 = None;
    let giveaway2 = store.giveaway(user_pref2);
    println!(
        "선호도가 {:?}인 사용자는 {:?}를 받습니다",
        user_pref2, giveaway2
    );
}</code></pre>
</Listing>
<p><code>main</code>에 정의된 <code>store</code>는 이번 한정판 프로모션을 위해 파란색 셔츠 두 장과 빨간색 셔츠 한 장을 남겨두고 있습니다. 우리는 빨간색 셔츠를 선호하는 사용자와 선호도가 없는 사용자에 대해 <code>giveaway</code> 메서드를 호출합니다.</p>
<p>다시 말하지만, 이 코드는 여러 방식으로 구현될 수 있습니다. 여기서는 클로저에 집중하기 위해, 클로저를 사용하는 <code>giveaway</code> 메서드의 본문을 제외하고는 여러분이 이미 배운 개념들을 고수했습니다. <code>giveaway</code> 메서드에서 우리는 사용자 선호도를 <code>Option&lt;ShirtColor&gt;</code> 타입의 매개변수로 받고 <code>user_preference</code>에 대해 <code>unwrap_or_else</code> 메서드를 호출합니다. 표준 라이브러리에 정의된 <a href="../std/option/enum.Option.html#method.unwrap_or_else"><code>Option&lt;T&gt;</code>의 <code>unwrap_or_else</code> 메서드</a><!-- ignore -->는 인수를 하나 받는데, 그 인수는 매개변수가 없고 <code>T</code> 값(<code>Option&lt;T&gt;</code>의 <code>Some</code> 변형에 저장된 것과 같은 타입, 이 경우 <code>ShirtColor</code>)을 반환하는 클로저입니다. <code>Option&lt;T&gt;</code>가 <code>Some</code> 변형이면 <code>unwrap_or_else</code>는 <code>Some</code> 내부의 값을 반환합니다. <code>Option&lt;T&gt;</code>가 <code>None</code> 변형이면 <code>unwrap_or_else</code>는 클로저를 호출하고 클로저가 반환한 값을 반환합니다.</p>
<p>우리는 <code>|| self.most_stocked()</code>라는 클로저 표현식을 <code>unwrap_or_else</code>의 인수로 지정했습니다. 이것은 매개변수를 받지 않는 클로저입니다(클로저에 매개변수가 있다면 두 수직 막대 사이에 나타날 것입니다). 클로저의 본문은 <code>self.most_stocked()</code>를 호출합니다. 우리는 여기서 클로저를 정의하고 있으며, <code>unwrap_or_else</code>의 구현은 나중에 결과가 필요할 때 클로저를 평가할 것입니다.</p>
<p>이 코드를 실행하면 다음과 같이 출력됩니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling shirt-company v0.1.0 (file:///projects/shirt-company)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/shirt-company`
The user with preference Some(Red) gets Red
The user with preference None gets Blue
</code></pre>
<p>여기서 한 가지 흥미로운 점은 현재 <code>Inventory</code> 인스턴스에 대해 <code>self.most_stocked()</code>를 호출하는 클로저를 전달했다는 것입니다. 표준 라이브러리는 우리가 정의한 <code>Inventory</code>나 <code>ShirtColor</code> 타입, 또는 이 시나리오에서 사용하려는 로직에 대해 아무것도 알 필요가 없었습니다. 클로저는 <code>self</code> <code>Inventory</code> 인스턴스에 대한 불변 참조를 캡처하고, 우리가 지정한 코드와 함께 그것을 <code>unwrap_or_else</code> 메서드로 전달합니다. 반면 함수는 이런 방식으로 환경을 캡처할 수 없습니다.</p>
<h3 id="클로저-타입-추론과-어노테이션"><a class="header" href="#클로저-타입-추론과-어노테이션">클로저 타입 추론과 어노테이션</a></h3>
<p>함수와 클로저 사이에는 더 많은 차이점이 있습니다. 클로저는 보통 <code>fn</code> 함수처럼 매개변수나 반환 값의 타입을 명시할 것을 요구하지 않습니다. 함수에 타입 어노테이션이 필요한 이유는 타입이 사용자에게 노출되는 명시적인 인터페이스의 일부이기 때문입니다. 이 인터페이스를 엄격하게 정의하는 것은 함수가 어떤 타입의 값을 사용하고 반환하는지에 대해 모두가 동의하도록 보장하는 데 중요합니다. 반면 클로저는 이렇게 노출된 인터페이스에서 사용되지 않습니다. 변수에 저장되고, 이름 없이 사용되며, 라이브러리 사용자에게 노출되지 않습니다.</p>
<p>클로저는 일반적으로 짧으며 임의의 시나리오보다는 좁은 문맥 안에서만 관련이 있습니다. 이러한 제한된 문맥 안에서 컴파일러는 대부분의 변수 타입을 추론할 수 있는 것과 마찬가지로 매개변수와 반환 타입을 추론할 수 있습니다(컴파일러가 클로저 타입 어노테이션을 필요로 하는 드문 경우도 있긴 합니다).</p>
<p>변수와 마찬가지로, 엄격하게 필요한 것보다 더 장황해지는 비용을 치르더라도 명시성과 명확성을 높이고 싶다면 타입 어노테이션을 추가할 수 있습니다. 클로저에 타입을 명시하는 것은 목록 13-2에 나온 정의와 같습니다. 이 예제에서는 목록 13-1에서처럼 인수로 전달하는 지점에서 클로저를 정의하는 대신, 클로저를 정의하고 변수에 저장하고 있습니다.</p>
<Listing number="13-2" file-name="src/main.rs" caption="Adding optional type annotations of the parameter and return value types in the closure">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {
</span>    let expensive_closure = |num: u32| -&gt; u32 {
        println!("천천히 계산 중...");
        thread::sleep(Duration::from_secs(2));
        num
    };
<span class="boring">
</span><span class="boring">    if intensity &lt; 25 {
</span><span class="boring">        println!("오늘은 팔굽혀펴기 {}회를 하세요!", expensive_closure(intensity));
</span><span class="boring">        println!("다음으로, 윗몸일으키기 {}회를 하세요!", expensive_closure(intensity));
</span><span class="boring">    } else {
</span><span class="boring">        if random_number == 3 {
</span><span class="boring">            println!("오늘은 휴식을 취하세요! 수분 섭취를 잊지 마세요!");
</span><span class="boring">        } else {
</span><span class="boring">            println!(
</span><span class="boring">                "오늘은 {}분간 달리세요!",
</span><span class="boring">                expensive_closure(intensity)
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let simulated_user_specified_value = 10;
</span><span class="boring">    let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">    generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>타입 어노테이션이 추가되면, 클로저의 문법은 함수의 문법과 더 비슷해 보입니다. 여기서 우리는 비교를 위해 매개변수에 1을 더하는 함수와 동일한 동작을 하는 클로저를 정의합니다. 관련 부분들을 정렬하기 위해 공백을 좀 추가했습니다. 이는 파이프의 사용과 선택적인 문법의 양을 제외하면 클로저 문법이 함수 문법과 얼마나 유사한지 보여줍니다:</p>
<pre><code class="language-rust ignore">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;</code></pre>
<p>첫 번째 줄은 함수 정의를 보여주고, 두 번째 줄은 완전히 어노테이션된 클로저 정의를 보여줍니다. 세 번째 줄에서는 클로저 정의에서 타입 어노테이션을 제거했습니다. 네 번째 줄에서는 중괄호를 제거했는데, 클로저 본문에 표현식이 하나만 있는 경우 중괄호는 선택 사항이기 때문입니다. 이것들은 모두 유효한 정의이며 호출되었을 때 동일한 동작을 수행합니다. <code>add_one_v3</code>와 <code>add_one_v4</code> 라인은 사용 방식을 통해 타입이 추론되므로, 컴파일되려면 클로저가 평가되어야 합니다. 이는 <code>let v = Vec::new();</code>가 러스트가 타입을 추론할 수 있도록 타입 어노테이션이나 <code>Vec</code>에 삽입될 어떤 타입의 값이 필요한 것과 유사합니다.</p>
<p>클로저 정의의 경우, 컴파일러는 각 매개변수와 반환 값에 대해 하나의 구체적인 타입을 추론합니다. 예를 들어, 목록 13-3은 매개변수로 받은 값을 그대로 반환하는 짧은 클로저의 정의를 보여줍니다. 이 클로저는 예제 목적 외에는 별로 유용하지 않습니다. 정의에 아무런 타입 어노테이션도 추가하지 않았다는 점에 유의하세요. 타입 어노테이션이 없기 때문에 어떤 타입으로도 클로저를 호출할 수 있으며, 여기서는 처음으로 <code>String</code>과 함께 호출했습니다. 그런 다음 <code>example_closure</code>를 정수와 함께 호출하려고 하면 에러가 발생합니다.</p>
<Listing number="13-3" file-name="src/main.rs" caption="Attempting to call a closure whose types are inferred with two different types">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let example_closure = |x| x;

    let s = example_closure(String::from("hello"));
    let n = example_closure(5);
<span class="boring">}</span></code></pre>
</Listing>
<p>컴파일러는 다음과 같은 에러를 줍니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
error[E0308]: mismatched types
 --&gt; src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |             --------------- ^- help: try using a conversion method: `.to_string()`
  |             |               |
  |             |               expected `String`, found integer
  |             arguments to this function are incorrect
  |
note: expected because the closure was earlier called with an argument of type `String`
 --&gt; src/main.rs:4:29
  |
4 |     let s = example_closure(String::from("hello"));
  |             --------------- ^^^^^^^^^^^^^^^^^^^^^ expected because this argument is of type `String`
  |             |
  |             in this closure call
note: closure parameter defined here
 --&gt; src/main.rs:2:28
  |
2 |     let example_closure = |x| x;
  |                            ^

For more information about this error, try `rustc --explain E0308`.
error: could not compile `closure-example` (bin "closure-example") due to 1 previous error
</code></pre>
<p>처음 <code>example_closure</code>를 <code>String</code> 값으로 호출할 때, 컴파일러는 <code>x</code>의 타입과 클로저의 반환 타입을 <code>String</code>으로 추론합니다. 그러면 그 타입들이 <code>example_closure</code>의 클로저에 고정되며, 다음에 다른 타입으로 <code>example_closure</code>를 호출하려고 하면 타입 에러가 발생합니다.</p>
<h3 id="참조-캡처하기-또는-소유권-이동하기"><a class="header" href="#참조-캡처하기-또는-소유권-이동하기">참조 캡처하기 또는 소유권 이동하기</a></h3>
<p>클로저는 세 가지 방식으로 환경에서 값을 캡처할 수 있으며, 이는 함수가 매개변수를 받는 세 가지 방식인 불변 대여, 가변 대여, 소유권 가져오기와 직접적으로 대응됩니다. 클로저는 함수 본문이 캡처된 값으로 무엇을 하는지에 따라 이 중 어떤 것을 사용할지 결정합니다.</p>
<p>목록 13-4에서는 <code>list</code>라는 벡터에 대한 불변 참조를 캡처하는 클로저를 정의합니다. 값을 출력하기 위해서는 불변 참조만 있으면 되기 때문입니다:</p>
<Listing number="13-4" file-name="src/main.rs" caption="Defining and calling a closure that captures an immutable reference">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let list = vec![1, 2, 3];
    println!("클로저 정의 전: {list:?}");

    let only_borrows = || println!("클로저 안에서: {list:?}");

    println!("클로저 호출 전: {list:?}");
    only_borrows();
    println!("클로저 호출 후: {list:?}");
}</code></pre></pre>
</Listing>
<p>이 예제는 또한 변수가 클로저 정의에 바인딩될 수 있으며, 나중에 변수 이름과 괄호를 사용하여 마치 함수 이름인 것처럼 클로저를 호출할 수 있음을 보여줍니다.</p>
<p><code>list</code>에 대한 불변 참조는 동시에 여러 개 가질 수 있으므로, 클로저 정의 전, 클로저 정의 후지만 호출 전, 그리고 클로저 호출 후에도 코드에서 <code>list</code>에 여전히 접근할 수 있습니다. 이 코드는 컴파일되고, 실행되며, 다음과 같이 출력합니다:</p>
<pre><code class="language-console">$ cargo run
     Locking 1 package to latest compatible version
      Adding closure-example v0.1.0 (/Users/chris/dev/rust-lang/book/tmp/listings/ch13-functional-features/listing-13-04)
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Before defining closure: [1, 2, 3]
Before calling closure: [1, 2, 3]
From closure: [1, 2, 3]
After calling closure: [1, 2, 3]
</code></pre>
<p>다음으로, 목록 13-5에서는 클로저 본문을 변경하여 <code>list</code> 벡터에 요소를 추가하도록 합니다. 이제 클로저는 가변 참조를 캡처합니다:</p>
<Listing number="13-5" file-name="src/main.rs" caption="Defining and calling a closure that captures a mutable reference">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut list = vec![1, 2, 3];
    println!("클로저 정의 전: {list:?}");

    let mut borrows_mutably = || list.push(7);

    borrows_mutably();
    println!("클로저 호출 후: {list:?}");
}</code></pre></pre>
</Listing>
<p>이 코드는 컴파일되고, 실행되며, 다음과 같이 출력합니다:</p>
<pre><code class="language-console">$ cargo run
     Locking 1 package to latest compatible version
      Adding closure-example v0.1.0 (/Users/chris/dev/rust-lang/book/tmp/listings/ch13-functional-features/listing-13-05)
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Before defining closure: [1, 2, 3]
After calling closure: [1, 2, 3, 7]
</code></pre>
<p><code>borrows_mutably</code> 클로저의 정의와 호출 사이에 더 이상 <code>println!</code>이 없다는 점에 유의하세요: <code>borrows_mutably</code>가 정의될 때, 이 클로저는 <code>list</code>에 대한 가변 참조를 캡처합니다. 클로저가 호출된 후에는 클로저를 다시 사용하지 않으므로, 가변 대여가 끝납니다. 클로저 정의와 클로저 호출 사이에는 출력하기 위한 불변 대여가 허용되지 않는데, 이는 가변 대여가 있을 때 다른 대여가 허용되지 않기 때문입니다. 그곳에 <code>println!</code>을 추가하여 어떤 오류 메시지가 나타나는지 확인해 보세요!</p>
<p>클로저 본문이 엄밀히 말해 소유권을 필요로 하지 않더라도, 클로저가 환경에서 사용하는 값의 소유권을 가져오도록 강제하고 싶다면 매개변수 목록 앞에 <code>move</code> 키워드를 사용할 수 있습니다.</p>
<p>이 기술은 주로 새로운 스레드로 클로저를 전달할 때 데이터를 이동시켜 새 스레드가 그 데이터를 소유하도록 할 때 유용합니다. 스레드와 왜 스레드를 사용하고 싶은지에 대해서는 16장에서 동시성을 다룰 때 자세히 논의하겠지만, 지금은 <code>move</code> 키워드가 필요한 클로저를 사용하여 새 스레드를 생성하는 것을 간단히 살펴보겠습니다. 목록 13-6은 메인 스레드 대신 새 스레드에서 벡터를 출력하도록 목록 13-4를 수정한 것입니다:</p>
<Listing number="13-6" file-name="src/main.rs" caption="Using `move` to force the closure for the thread to take ownership of `list`">
<pre><pre class="playground"><code class="language-rust edition2021">use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    println!("클로저 정의 전: {list:?}");

    thread::spawn(move || println!("스레드에서: {list:?}"))
        .join()
        .unwrap();
}</code></pre></pre>
</Listing>
<p>우리는 실행할 클로저를 인수로 주어 새 스레드를 생성합니다. 클로저 본문은 리스트를 출력합니다. 목록 13-4에서 클로저는 <code>list</code>를 출력하는 데 필요한 최소한의 접근 권한인 불변 참조만을 사용하여 <code>list</code>를 캡처했습니다. 이 예제에서도 클로저 본문은 여전히 불변 참조만 필요로 하지만, 클로저 정의 앞에 <code>move</code> 키워드를 넣어 <code>list</code>가 클로저로 이동되어야 함을 명시해야 합니다. 새 스레드는 메인 스레드의 나머지 부분이 끝나기 전에 끝날 수도 있고, 메인 스레드가 먼저 끝날 수도 있습니다. 만약 메인 스레드가 <code>list</code>의 소유권을 유지하다가 새 스레드보다 먼저 끝나서 <code>list</code>를 드롭해 버린다면, 스레드 안의 불변 참조는 유효하지 않게 될 것입니다. 따라서 컴파일러는 참조가 유효하도록 <code>list</code>를 새 스레드에 주어진 클로저로 이동시킬 것을 요구합니다. <code>move</code> 키워드를 제거하거나 클로저가 정의된 후 메인 스레드에서 <code>list</code>를 사용하여 어떤 컴파일러 에러가 발생하는지 확인해 보세요!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="storing-closures-using-generic-parameters-and-the-fn-traits"></a> <a id="limitations-of-the-cacher-implementation"></a> <a id="moving-captured-values-out-of-the-closure-and-the-fn-traits"></a></p>
<h3 id="캡처된-값을-클로저-밖으로-이동하기와-fn-트레이트"><a class="header" href="#캡처된-값을-클로저-밖으로-이동하기와-fn-트레이트">캡처된 값을 클로저 밖으로 이동하기와 <code>Fn</code> 트레이트</a></h3>
<p>클로저가 정의된 환경에서 참조를 캡처하거나 값의 소유권을 캡처하고 나면(이는 무엇이 클로저 <em>안으로</em> 이동되는지에 영향을 미칩니다), 클로저 본문의 코드는 나중에 클로저가 평가될 때 그 참조나 값들에 무슨 일이 일어날지 정의합니다(이는 무엇이 클로저 <em>밖으로</em> 이동되는지에 영향을 미칩니다). 클로저 본문은 다음 중 하나를 수행할 수 있습니다: 캡처된 값을 클로저 밖으로 이동하기, 캡처된 값을 변경하기, 값을 이동하지도 변경하지도 않기, 또는 애초에 환경에서 아무것도 캡처하지 않기.</p>
<p>클로저가 환경의 값을 캡처하고 처리하는 방식은 클로저가 구현하는 트레이트에 영향을 미치며, 함수나 구조체는 트레이트를 사용하여 어떤 종류의 클로저를 사용할 수 있는지 명시할 수 있습니다. 클로저는 본문이 값을 처리하는 방식에 따라 다음 세 가지 <code>Fn</code> 트레이트 중 하나, 둘 또는 셋 모두를 자동으로 구현합니다:</p>
<ol>
<li><code>FnOnce</code>는 한 번 호출될 수 있는 클로저에 적용됩니다. 모든 클로저는 호출될 수 있으므로, 모든 클로저는 적어도 이 트레이트를 구현합니다. 캡처된 값을 본문 밖으로 이동시키는 클로저는 <code>FnOnce</code>만 구현하며 다른 <code>Fn</code> 트레이트는 구현하지 않습니다. 왜냐하면 한 번만 호출될 수 있기 때문입니다.</li>
<li><code>FnMut</code>은 캡처된 값을 본문 밖으로 이동시키지는 않지만 변경할 수 있는 클로저에 적용됩니다. 이러한 클로저는 두 번 이상 호출될 수 있습니다.</li>
<li><code>Fn</code>은 캡처된 값을 본문 밖으로 이동시키지 않고 변경하지도 않는 클로저, 또는 환경에서 아무것도 캡처하지 않는 클로저에 적용됩니다. 이러한 클로저는 환경을 변경하지 않고 두 번 이상 호출될 수 있으며, 이는 클로저를 동시에 여러 번 호출하는 것과 같은 경우에 중요합니다.</li>
</ol>
<p>목록 13-1에서 사용했던 <code>Option&lt;T&gt;</code>의 <code>unwrap_or_else</code> 메서드 정의를 살펴봅시다:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap_or_else&lt;F&gt;(self, f: F) -&gt; T
    where
        F: FnOnce() -&gt; T
    {
        match self {
            Some(x) =&gt; x,
            None =&gt; f(),
        }
    }
}</code></pre>
<p><code>T</code>는 <code>Option</code>의 <code>Some</code> 변형에 들어있는 값의 타입을 나타내는 제네릭 타입임을 기억하세요. 이 <code>T</code> 타입은 <code>unwrap_or_else</code> 함수의 반환 타입이기도 합니다. 예를 들어, <code>Option&lt;String&gt;</code>에 대해 <code>unwrap_or_else</code>를 호출하는 코드는 <code>String</code>을 얻게 됩니다.</p>
<p>다음으로, <code>unwrap_or_else</code> 함수가 추가적인 제네릭 타입 매개변수 <code>F</code>를 가지고 있음에 주목하세요. <code>F</code> 타입은 <code>f</code>라는 이름의 매개변수 타입이며, 이는 <code>unwrap_or_else</code>를 호출할 때 우리가 제공하는 클로저입니다.</p>
<p>제네릭 타입 <code>F</code>에 지정된 트레이트 바운드는 <code>FnOnce() -&gt; T</code>입니다. 이는 <code>F</code>가 한 번 호출될 수 있어야 하고, 인수를 받지 않으며, <code>T</code>를 반환해야 함을 의미합니다. 트레이트 바운드에 <code>FnOnce</code>를 사용하는 것은 <code>unwrap_or_else</code>가 <code>f</code>를 최대 한 번만 호출할 것임을 제약 조건으로 표현합니다. <code>unwrap_or_else</code>의 본문에서 <code>Option</code>이 <code>Some</code>이면 <code>f</code>가 호출되지 않는 것을 볼 수 있습니다. <code>Option</code>이 <code>None</code>이면 <code>f</code>는 한 번 호출됩니다. 모든 클로저는 <code>FnOnce</code>를 구현하므로, <code>unwrap_or_else</code>는 세 가지 종류의 클로저를 모두 받아들일 수 있으며 가능한 한 유연하게 작동합니다.</p>
<blockquote>
<p>참고: 우리가 하려는 작업이 환경에서 값을 캡처할 필요가 없다면, 클로저 대신 함수 이름을 사용할 수 있습니다. 예를 들어, <code>Option&lt;Vec&lt;T&gt;&gt;</code> 값에 대해 <code>unwrap_or_else(Vec::new)</code>를 호출하면 값이 <code>None</code>일 때 새로운 빈 벡터를 얻게 됩니다. 컴파일러는 함수 정의에 적용 가능한 <code>Fn</code> 트레이트가 무엇이든 자동으로 구현합니다.</p>
</blockquote>
<p>이제 슬라이스에 정의된 표준 라이브러리 메서드 <code>sort_by_key</code>가 <code>unwrap_or_else</code>와 어떻게 다른지, 그리고 <code>sort_by_key</code>가 트레이트 바운드에 <code>FnOnce</code> 대신 <code>FnMut</code>을 사용하는 이유를 살펴보겠습니다. 이 클로저는 고려 중인 슬라이스의 현재 아이템에 대한 참조 형식으로 인수를 하나 받고, 정렬 가능한 <code>K</code> 타입의 값을 반환합니다. 이 함수는 각 아이템의 특정 속성에 따라 슬라이스를 정렬하고 싶을 때 유용합니다. 목록 13-7에서는 <code>Rectangle</code> 인스턴스 리스트가 있고, <code>sort_by_key</code>를 사용하여 <code>width</code> 속성에 따라 낮은 값에서 높은 값 순으로 정렬합니다:</p>
<Listing number="13-7" file-name="src/main.rs" caption="Using `sort_by_key` to order rectangles by width">
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    list.sort_by_key(|r| r.width);
    println!("{list:#?}");
}</code></pre></pre>
</Listing>
<p>이 코드는 다음을 출력합니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.41s
     Running `target/debug/rectangles`
[
    Rectangle {
        width: 3,
        height: 5,
    },
    Rectangle {
        width: 7,
        height: 12,
    },
    Rectangle {
        width: 10,
        height: 1,
    },
]
</code></pre>
<p><code>sort_by_key</code>가 <code>FnMut</code> 클로저를 받도록 정의된 이유는 슬라이스의 각 아이템에 대해 한 번씩, 즉 클로저를 여러 번 호출하기 때문입니다. <code>|r| r.width</code> 클로저는 환경에서 아무것도 캡처하거나, 변경하거나, 밖으로 이동시키지 않으므로 트레이트 바운드 요구사항을 충족합니다.</p>
<p>반면, 목록 13-8은 환경에서 값을 밖으로 이동시키기 때문에 <code>FnOnce</code> 트레이트만 구현하는 클로저의 예를 보여줍니다. 컴파일러는 우리가 이 클로저를 <code>sort_by_key</code>와 함께 사용하는 것을 허용하지 않을 것입니다:</p>
<Listing number="13-8" file-name="src/main.rs" caption="Attempting to use an `FnOnce` closure with `sort_by_key`">
<pre><code class="language-rust ignore does_not_compile">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut sort_operations = vec![];
    let value = String::from("클로저 호출됨");

    list.sort_by_key(|r| {
        sort_operations.push(value);
        r.width
    });
    println!("{list:#?}");
}</code></pre>
</Listing>
<p>이는 <code>list</code>를 정렬할 때 <code>sort_by_key</code>가 클로저를 몇 번 호출하는지 세어보려고 시도하는 부자연스럽고 복잡한(그리고 작동하지 않는) 방식입니다. 이 코드는 클로저 환경의 <code>String</code>인 <code>value</code>를 <code>sort_operations</code> 벡터에 푸시함으로써 횟수를 세려고 시도합니다. 클로저는 <code>value</code>를 캡처한 다음, <code>value</code>의 소유권을 <code>sort_operations</code> 벡터로 이전함으로써 <code>value</code>를 클로저 밖으로 이동시킵니다. 이 클로저는 한 번만 호출될 수 있습니다. 두 번째로 호출하려고 시도하면 <code>value</code>가 더 이상 환경에 존재하지 않아 <code>sort_operations</code>에 다시 푸시할 수 없기 때문입니다! 따라서 이 클로저는 <code>FnOnce</code>만 구현합니다. 이 코드를 컴파일하려고 하면, 클로저가 반드시 <code>FnMut</code>을 구현해야 하므로 <code>value</code>를 클로저 밖으로 이동시킬 수 없다는 다음과 같은 에러가 발생합니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
error[E0507]: cannot move out of `value`, a captured variable in an `FnMut` closure
  --&gt; src/main.rs:18:30
   |
15 |     let value = String::from("closure called");
   |         ----- captured outer variable
16 |
17 |     list.sort_by_key(|r| {
   |                      --- captured by this `FnMut` closure
18 |         sort_operations.push(value);
   |                              ^^^^^ move occurs because `value` has type `String`, which does not implement the `Copy` trait
   |
help: consider cloning the value if the performance cost is acceptable
   |
18 |         sort_operations.push(value.clone());
   |                                   ++++++++

For more information about this error, try `rustc --explain E0507`.
error: could not compile `rectangles` (bin "rectangles") due to 1 previous error
</code></pre>
<p>오류는 환경 밖으로 <code>value</code>를 이동시키는 클로저 본문의 라인을 가리킵니다. 이를 해결하려면 환경 밖으로 값을 이동시키지 않도록 클로저 본문을 변경해야 합니다. 클로저가 호출된 횟수를 세기 위해 환경에 카운터를 유지하고 클로저 본문에서 그 값을 증가시키는 것이 더 간단한 계산 방법입니다. 목록 13-9의 클로저는 <code>num_sort_operations</code> 카운터에 대한 가변 참조만 캡처하므로 <code>sort_by_key</code>와 함께 작동하며, 따라서 한 번 이상 호출될 수 있습니다:</p>
<Listing number="13-9" file-name="src/main.rs" caption="Using an `FnMut` closure with `sort_by_key` is allowed">
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut num_sort_operations = 0;
    list.sort_by_key(|r| {
        num_sort_operations += 1;
        r.width
    });
    println!("{list:#?}, {num_sort_operations}번의 연산으로 정렬됨");
}</code></pre></pre>
</Listing>
<p><code>Fn</code> 트레이트는 클로저를 사용하는 함수나 타입을 정의하거나 사용할 때 중요합니다. 다음 섹션에서는 반복자에 대해 논의하겠습니다. 많은 반복자 메서드들이 클로저를 인수로 받으므로, 앞으로 진행하면서 이러한 클로저의 세부 사항들을 기억해 두세요!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="반복자로-일련의-항목-처리하기"><a class="header" href="#반복자로-일련의-항목-처리하기">반복자로 일련의 항목 처리하기</a></h2>
<p>반복자(iterator) 패턴을 사용하면 일련의 아이템들에 대해 차례대로 어떤 작업을 수행할 수 있습니다. 반복자는 각 아이템을 순회하는 로직과 언제 시퀀스가 끝날지 결정하는 책임을 집니다. 반복자를 사용하면 이러한 로직을 직접 다시 구현할 필요가 없습니다.</p>
<p>러스트에서 반복자는 <em>게으릅니다(lazy)</em>. 즉, 반복자를 소비하여 사용하는 메서드를 호출하기 전까지는 아무런 효과가 없습니다. 예를 들어, 목록 13-10의 코드는 <code>Vec&lt;T&gt;</code>에 정의된 <code>iter</code> 메서드를 호출하여 벡터 <code>v1</code>의 아이템들에 대한 반복자를 생성합니다. 이 코드 자체만으로는 아무런 유용한 일을 하지 않습니다.</p>
<Listing number="13-10" file-name="src/main.rs" caption="Creating an iterator">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>반복자는 <code>v1_iter</code> 변수에 저장됩니다. 반복자를 생성하고 나면 다양한 방식으로 사용할 수 있습니다. 3장의 목록 3-5에서 우리는 각 아이템에 대해 어떤 코드를 실행하기 위해 <code>for</code> 루프를 사용하여 배열을 순회했습니다. 내부적으로 이는 암묵적으로 반복자를 생성하고 소비한 것이지만, 지금까지는 그것이 정확히 어떻게 작동하는지 언급하지 않고 넘어갔습니다.</p>
<p>목록 13-11의 예제에서는 반복자의 생성과 <code>for</code> 루프에서의 반복자 사용을 분리합니다. <code>v1_iter</code>에 있는 반복자를 사용하여 <code>for</code> 루프가 호출되면, 반복자의 각 요소가 루프의 한 반복(iteration)에서 사용되어 각 값을 출력합니다.</p>
<Listing number="13-11" file-name="src/main.rs" caption="Using an iterator in a `for` loop">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    for val in v1_iter {
        println!("받음: {val}");
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>표준 라이브러리에서 반복자를 제공하지 않는 언어에서는 인덱스 0에서 변수를 시작하고, 그 변수를 사용하여 벡터의 값을 가져오기 위해 인덱싱하며, 벡터의 전체 항목 수에 도달할 때까지 루프에서 변수 값을 증가시키는 방식으로 동일한 기능을 작성했을 것입니다.</p>
<p>반복자는 이 모든 로직을 처리해주므로, 실수할 수 있는 반복적인 코드를 줄여줍니다. 반복자는 벡터와 같이 인덱싱할 수 있는 데이터 구조뿐만 아니라 다양한 종류의 시퀀스에 동일한 로직을 사용할 수 있도록 더 많은 유연성을 제공합니다. 반복자가 어떻게 그렇게 하는지 살펴보겠습니다.</p>
<h3 id="iterator-트레이트와-next-메서드"><a class="header" href="#iterator-트레이트와-next-메서드"><code>Iterator</code> 트레이트와 <code>next</code> 메서드</a></h3>
<p>모든 반복자는 표준 라이브러리에 정의된 <code>Iterator</code>라는 트레이트를 구현합니다. 이 트레이트의 정의는 다음과 같습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // 기본 구현이 있는 메서드는 생략됨
}
<span class="boring">}</span></code></pre></pre>
<p>이 정의가 <code>type Item</code>과 <code>Self::Item</code>이라는 새로운 문법을 사용하고 있다는 점에 주목하세요. 이는 이 트레이트와 _연관된 타입(associated type)_을 정의하고 있습니다. 연관된 타입에 대해서는 20장에서 자세히 다룰 것입니다. 지금은 이 코드가 <code>Iterator</code> 트레이트를 구현하려면 <code>Item</code> 타입도 정의해야 하며, 이 <code>Item</code> 타입이 <code>next</code> 메서드의 반환 타입으로 사용된다는 것을 의미한다는 것만 알면 됩니다. 다시 말해, <code>Item</code> 타입은 반복자에서 반환되는 타입이 될 것입니다.</p>
<p><code>Iterator</code> 트레이트는 구현자가 단 하나의 메서드, 즉 <code>next</code> 메서드만 정의할 것을 요구합니다. 이 메서드는 반복자의 아이템을 한 번에 하나씩 <code>Some</code>으로 감싸서 반환하고, 반복이 끝나면 <code>None</code>을 반환합니다.</p>
<p>반복자에서 <code>next</code> 메서드를 직접 호출할 수 있습니다. 목록 13-12는 벡터에서 생성된 반복자에서 <code>next</code>를 반복적으로 호출할 때 반환되는 값을 보여줍니다.</p>
<Listing number="13-12" file-name="src/lib.rs" caption="Calling the `next` method on an iterator">
<pre><code class="language-rust noplayground"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn iterator_demonstration() {
        let v1 = vec![1, 2, 3];

        let mut v1_iter = v1.iter();

        assert_eq!(v1_iter.next(), Some(&amp;1));
        assert_eq!(v1_iter.next(), Some(&amp;2));
        assert_eq!(v1_iter.next(), Some(&amp;3));
        assert_eq!(v1_iter.next(), None);
    }
<span class="boring">}</span></code></pre>
</Listing>
<p><code>v1_iter</code>를 가변으로 만들어야 했다는 점에 유의하세요: 반복자에서 <code>next</code> 메서드를 호출하면 반복자가 시퀀스의 어디에 있는지 추적하는 데 사용하는 내부 상태가 변경됩니다. 다시 말해, 이 코드는 반복자를 _소비(consume)_하거나 다 써버립니다. <code>next</code>를 호출할 때마다 반복자에서 항목을 하나씩 먹어치웁니다. <code>for</code> 루프를 사용할 때는 <code>v1_iter</code>를 가변으로 만들 필요가 없었는데, 이는 루프가 <code>v1_iter</code>의 소유권을 가져와서 내부적으로 가변으로 만들었기 때문입니다.</p>
<p>또한 <code>next</code> 호출에서 얻는 값은 벡터에 있는 값에 대한 불변 참조라는 점에도 유의하세요. <code>iter</code> 메서드는 불변 참조에 대한 반복자를 생성합니다. 만약 <code>v1</code>의 소유권을 가져와서 소유된 값을 반환하는 반복자를 만들고 싶다면, <code>iter</code> 대신 <code>into_iter</code>를 호출할 수 있습니다. 마찬가지로, 가변 참조에 대해 반복하고 싶다면 <code>iter</code> 대신 <code>iter_mut</code>을 호출할 수 있습니다.</p>
<h3 id="반복자를-소비하는-메서드"><a class="header" href="#반복자를-소비하는-메서드">반복자를 소비하는 메서드</a></h3>
<p><code>Iterator</code> 트레이트에는 표준 라이브러리에서 제공하는 기본 구현이 포함된 다양한 메서드들이 있습니다. <code>Iterator</code> 트레이트에 대한 표준 라이브러리 API 문서를 보면 이 메서드들에 대해 알아볼 수 있습니다. 이 메서드들 중 일부는 정의 내에서 <code>next</code> 메서드를 호출하는데, 이것이 <code>Iterator</code> 트레이트를 구현할 때 <code>next</code> 메서드를 구현해야 하는 이유입니다.</p>
<p><code>next</code>를 호출하는 메서드들은 반복자를 다 써버리기 때문에 _소비 어댑터(consuming adapters)_라고 부릅니다. 한 가지 예로 <code>sum</code> 메서드가 있는데, 이 메서드는 반복자의 소유권을 가져와서 반복적으로 <code>next</code>를 호출하여 항목들을 순회하며, 따라서 반복자를 소비합니다. 순회하는 동안 각 항목을 현재 총합에 더하고 반복이 완료되면 총합을 반환합니다. 목록 13-13은 <code>sum</code> 메서드의 사용을 보여주는 테스트입니다:</p>
<Listing number="13-13" file-name="src/lib.rs" caption="Calling the `sum` method to get the total of all items in the iterator">
<pre><code class="language-rust noplayground"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn iterator_sum() {
        let v1 = vec![1, 2, 3];

        let v1_iter = v1.iter();

        let total: i32 = v1_iter.sum();

        assert_eq!(total, 6);
    }
<span class="boring">}</span></code></pre>
</Listing>
<p><code>sum</code> 호출 이후에는 <code>v1_iter</code>를 사용할 수 없는데, 이는 <code>sum</code>이 호출된 반복자의 소유권을 가져가기 때문입니다.</p>
<h3 id="다른-반복자를-생성하는-메서드"><a class="header" href="#다른-반복자를-생성하는-메서드">다른 반복자를 생성하는 메서드</a></h3>
<p>_반복자 어댑터(Iterator adapters)_는 <code>Iterator</code> 트레이트에 정의된 메서드로, 반복자를 소비하지 않습니다. 대신, 원래 반복자의 어떤 측면을 변경하여 다른 반복자를 생성합니다.</p>
<p>목록 13-14는 반복자 어댑터 메서드인 <code>map</code>을 호출하는 예를 보여주는데, 이 메서드는 항목들을 순회할 때 각 항목에 대해 호출할 클로저를 인자로 받습니다. <code>map</code> 메서드는 수정된 항목들을 생성하는 새로운 반복자를 반환합니다. 여기의 클로저는 벡터의 각 항목이 1씩 증가된 새로운 반복자를 생성합니다:</p>
<Listing number="13-14" file-name="src/main.rs" caption="Calling the iterator adapter `map` to create a new iterator">
<pre><pre class="playground"><code class="language-rust not_desired_behavior edition2021"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    v1.iter().map(|x| x + 1);
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>하지만 이 코드는 경고를 발생시킵니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling iterators v0.1.0 (file:///projects/iterators)
warning: unused `Map` that must be used
 --&gt; src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: iterators are lazy and do nothing unless consumed
  = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
  |
4 |     let _ = v1.iter().map(|x| x + 1);
  |     +++++++

warning: `iterators` (bin "iterators") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.47s
     Running `target/debug/iterators`
</code></pre>
<p>목록 13-14의 코드는 아무것도 하지 않습니다. 우리가 지정한 클로저는 절대 호출되지 않습니다. 경고는 그 이유를 상기시켜 줍니다. 반복자 어댑터는 지연(lazy)이며, 여기서 반복자를 소비해야 합니다.</p>
<p>이 경고를 해결하고 반복자를 소비하기 위해, 목록 12-1의 12장에서 <code>env::args</code>와 함께 사용했던 <code>collect</code> 메서드를 사용할 것입니다. 이 메서드는 반복자를 소비하고 결과 값들을 컬렉션 데이터 타입으로 수집합니다.</p>
<p>목록 13-15에서는 <code>map</code> 호출에서 반환된 반복자를 순회한 결과를 벡터로 수집합니다. 이 벡터는 결국 원래 벡터의 각 항목에 1을 더한 값들을 포함하게 됩니다.</p>
<Listing number="13-15" file-name="src/main.rs" caption="Calling the `map` method to create a new iterator and then calling the `collect` method to consume the new iterator and create a vector">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);
<span class="boring">}</span></code></pre></pre>
</Listing>
<p><code>map</code>은 클로저를 인자로 받기 때문에, 각 항목에 대해 수행하고 싶은 어떤 연산이라도 지정할 수 있습니다. 이는 <code>Iterator</code> 트레이트가 제공하는 반복 동작을 재사용하면서 클로저를 통해 특정 동작을 커스터마이징할 수 있게 해주는 좋은 예입니다.</p>
<p>반복자 어댑터 호출을 여러 번 연결하여 복잡한 작업을 읽기 쉬운 방식으로 수행할 수 있습니다. 하지만 모든 반복자는 지연(lazy)이기 때문에, 반복자 어댑터 호출로부터 결과를 얻으려면 소비 어댑터 메서드 중 하나를 호출해야 합니다.</p>
<h3 id="환경을-캡처하는-클로저-사용하기"><a class="header" href="#환경을-캡처하는-클로저-사용하기">환경을 캡처하는 클로저 사용하기</a></h3>
<p>많은 반복자 어댑터는 클로저를 인자로 받으며, 일반적으로 우리가 반복자 어댑터의 인자로 지정하는 클로저는 자신의 환경을 캡처하는 클로저입니다.</p>
<p>이 예제에서는 클로저를 받는 <code>filter</code> 메서드를 사용할 것입니다. 이 클로저는 반복자로부터 항목을 하나 받아서 <code>bool</code>을 반환합니다. 클로저가 <code>true</code>를 반환하면, 그 값은 <code>filter</code>에 의해 생성된 반복에 포함될 것입니다. 클로저가 <code>false</code>를 반환하면, 그 값은 포함되지 않습니다.</p>
<p>목록 13-16에서는 환경으로부터 <code>shoe_size</code> 변수를 캡처하는 클로저와 함께 <code>filter</code>를 사용하여 <code>Shoe</code> 구조체 인스턴스 컬렉션을 순회합니다. 이 코드는 지정된 사이즈의 신발만 반환할 것입니다.</p>
<Listing number="13-16" file-name="src/lib.rs" caption="Using the `filter` method with a closure that captures `shoe_size`">
<pre><code class="language-rust noplayground">#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn filters_by_size() {
        let shoes = vec![
            Shoe {
                size: 10,
                style: String::from("스니커즈"),
            },
            Shoe {
                size: 13,
                style: String::from("샌들"),
            },
            Shoe {
                size: 10,
                style: String::from("부츠"),
            },
        ];

        let in_my_size = shoes_in_size(shoes, 10);

        assert_eq!(
            in_my_size,
            vec![
                Shoe {
                    size: 10,
                    style: String::from("스니커즈")
                },
                Shoe {
                    size: 10,
                    style: String::from("부츠")
                },
            ]
        );
    }
}</code></pre>
</Listing>
<p><code>shoes_in_size</code> 함수는 신발 벡터와 신발 사이즈를 매개변수로 소유권을 가져옵니다. 이 함수는 지정된 사이즈의 신발만 포함하는 벡터를 반환합니다.</p>
<p><code>shoes_in_size</code> 본문에서는 <code>into_iter</code>를 호출하여 벡터의 소유권을 가져오는 반복자를 생성합니다. 그런 다음 <code>filter</code>를 호출하여 클로저가 <code>true</code>를 반환하는 요소들만 포함하는 새로운 반복자로 해당 반복자를 변형합니다.</p>
<p>클로저는 환경으로부터 <code>shoe_size</code> 매개변수를 캡처하고 그 값을 각 신발의 사이즈와 비교하여, 지정된 사이즈의 신발만 남깁니다. 마지막으로, <code>collect</code>를 호출하여 변형된 반복자가 반환하는 값들을 모아 함수가 반환할 벡터로 만듭니다.</p>
<p>테스트 결과는 <code>shoes_in_size</code>를 호출했을 때 우리가 지정한 값과 같은 사이즈의 신발들만 돌아온다는 것을 보여줍니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="io-프로젝트-개선하기"><a class="header" href="#io-프로젝트-개선하기">I/O 프로젝트 개선하기</a></h2>
<p>반복자에 대한 새로운 지식을 바탕으로, 반복자를 사용하여 코드의 여러 부분을 더 명확하고 간결하게 만듦으로써 12장의 I/O 프로젝트를 개선할 수 있습니다. 반복자가 <code>Config::build</code> 함수와 <code>search</code> 함수의 구현을 어떻게 개선할 수 있는지 살펴봅시다.</p>
<h3 id="반복자를-사용하여-clone-제거하기"><a class="header" href="#반복자를-사용하여-clone-제거하기">반복자를 사용하여 <code>clone</code> 제거하기</a></h3>
<p>목록 12-6에서 우리는 <code>String</code> 값들의 슬라이스를 받아서 인덱싱을 통해 값들을 복제(clone)하여 <code>Config</code> 구조체의 인스턴스를 생성하는 코드를 추가했습니다. 이를 통해 <code>Config</code> 구조체가 해당 값들을 소유할 수 있게 했습니다. 목록 13-17에는 목록 12-23에 있었던 <code>Config::build</code> 함수의 구현을 다시 가져왔습니다:</p>
<Listing number="13-17" file-name="src/lib.rs" caption="Reproduction of the `Config::build` function from Listing 12-23">
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err("인수가 부족합니다");
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        let ignore_case = env::var("IGNORE_CASE").is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>당시에는 나중에 비효율적인 <code>clone</code> 호출을 제거할 것이므로 걱정하지 말라고 말했습니다. 자, 바로 지금이 그때입니다!</p>
<p>여기서 <code>clone</code>이 필요했던 이유는 매개변수 <code>args</code>에 <code>String</code> 요소가 있는 슬라이스가 들어있지만, <code>build</code> 함수가 <code>args</code>를 소유하고 있지 않기 때문입니다. <code>Config</code> 인스턴스의 소유권을 반환하려면, <code>Config</code> 인스턴스가 자신의 값을 소유할 수 있도록 <code>query</code>와 <code>file_path</code> 필드의 값들을 복제해야 했습니다.</p>
<p>반복자에 대한 새로운 지식을 활용하면, <code>build</code> 함수가 슬라이스를 대여하는 대신 반복자의 소유권을 인자로 받도록 변경할 수 있습니다. 슬라이스의 길이를 확인하고 특정 위치를 인덱싱하는 코드 대신 반복자 기능을 사용할 것입니다. 반복자가 값들에 접근하게 되므로 <code>Config::build</code> 함수가 무엇을 하는지 더 명확해질 것입니다.</p>
<p><code>Config::build</code>가 반복자의 소유권을 가져오고 대여를 사용하는 인덱싱 연산을 중단하면, <code>clone</code>을 호출하여 새로운 메모리 할당을 하는 대신 반복자의 <code>String</code> 값들을 <code>Config</code>로 이동시킬 수 있습니다.</p>
<h4 id="반환된-반복자를-직접-사용하기"><a class="header" href="#반환된-반복자를-직접-사용하기">반환된 반복자를 직접 사용하기</a></h4>
<p>I/O 프로젝트의 <em>src/main.rs</em> 파일을 여세요. 다음과 같은 모습일 것입니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        eprintln!("인수 파싱 중 문제 발생: {err}");
        process::exit(1);
    });

    // --생략--
<span class="boring">
</span><span class="boring">    if let Err(e) = minigrep::run(config) {
</span><span class="boring">        eprintln!("애플리케이션 에러: {e}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}</code></pre>
<p>먼저 목록 12-24에 있었던 <code>main</code> 함수의 시작 부분을 반복자를 사용하는 목록 13-18의 코드로 바꿀 것입니다. <code>Config::build</code>도 업데이트하기 전까지는 컴파일되지 않을 것입니다.</p>
<Listing number="13-18" file-name="src/main.rs" caption="Passing the return value of `env::args` to `Config::build`">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let config = Config::build(env::args()).unwrap_or_else(|err| {
        eprintln!("인수 파싱 중 문제 발생: {err}");
        process::exit(1);
    });

    // --생략--
<span class="boring">
</span><span class="boring">    if let Err(e) = minigrep::run(config) {
</span><span class="boring">        eprintln!("애플리케이션 에러: {e}");
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}</code></pre>
</Listing>
<p><code>env::args</code> 함수는 반복자를 반환합니다! 반복자 값들을 벡터로 수집한 다음 <code>Config::build</code>에 슬라이스를 전달하는 대신, 이제 <code>env::args</code>에서 반환된 반복자의 소유권을 <code>Config::build</code>에 직접 전달합니다.</p>
<p>다음으로, <code>Config::build</code>의 정의를 업데이트해야 합니다. I/O 프로젝트의 <em>src/lib.rs</em> 파일에서 <code>Config::build</code>의 시그니처를 목록 13-19와 같이 변경합시다. 함수 본문을 업데이트해야 하므로 아직은 컴파일되지 않을 것입니다.</p>
<Listing number="13-19" file-name="src/lib.rs" caption="Updating the signature of `Config::build` to expect an iterator">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(
        mut args: impl Iterator&lt;Item = String&gt;,
    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --생략--
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("인수가 부족합니다");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        let ignore_case = env::var("IGNORE_CASE").is_ok();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            query,
</span><span class="boring">            file_path,
</span><span class="boring">            ignore_case,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p><code>env::args</code> 함수에 대한 표준 라이브러리 문서를 보면 반환되는 반복자의 타입이 <code>std::env::Args</code>임을 알 수 있으며, 이 타입은 <code>Iterator</code> 트레이트를 구현하고 <code>String</code> 값들을 반환합니다.</p>
<p><code>Config::build</code> 함수의 시그니처를 업데이트하여 <code>args</code> 매개변수가 <code>&amp;[String]</code> 대신 <code>impl Iterator&lt;Item = String&gt;</code>이라는 트레이트 바운드를 가진 제네릭 타입을 갖도록 했습니다. 10장의 <a href="ch10-02-traits.html#traits-as-parameters">“매개변수로서의 트레이트”</a><!-- ignore --> 섹션에서 다루었던 <code>impl Trait</code> 문법을 사용한 것은, <code>args</code>가 <code>Iterator</code> 트레이트를 구현하고 <code>String</code> 항목을 반환하는 어떤 타입이라도 될 수 있음을 의미합니다.</p>
<p>리는 <code>args</code>의 소유권을 가져오고 순회를 통해 <code>args</code>를 변경할 것이므로, <code>args</code> 매개변수 명시에 <code>mut</code> 키워드를 추가하여 가변으로 만들 수 있습니다.</p>
<h4 id="인덱싱-대신-iterator-트레이트-메서드-사용하기"><a class="header" href="#인덱싱-대신-iterator-트레이트-메서드-사용하기">인덱싱 대신 <code>Iterator</code> 트레이트 메서드 사용하기</a></h4>
<p>다음으로, <code>Config::build</code>의 본문을 수정할 것입니다. <code>args</code>가 <code>Iterator</code> 트레이트를 구현하므로, 그 위에서 <code>next</code> 메서드를 호출할 수 있다는 것을 알고 있습니다! 목록 13-20은 목록 12-23의 코드를 <code>next</code> 메서드를 사용하도록 업데이트합니다:</p>
<Listing number="13-20" file-name="src/lib.rs" caption="Changing the body of `Config::build` to use iterator methods">
<pre><code class="language-rust noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(
        mut args: impl Iterator&lt;Item = String&gt;,
    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
        args.next();

        let query = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err("검색어를 얻지 못했습니다"),
        };

        let file_path = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err("파일 경로를 얻지 못했습니다"),
        };

        let ignore_case = env::var("IGNORE_CASE").is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>먼저 <code>next</code>를 호출하여 실행 파일의 이름이 포함된 첫 번째 값을 건너뜁니다. 두 번째로, <code>next</code>를 호출하여 <code>Config</code>의 <code>query</code> 필드에 넣고 싶은 값을 가져옵니다. 만약 <code>next</code>가 <code>Some</code>을 반환하면 <code>match</code>를 사용하여 그 값을 추출합니다. <code>None</code>을 반환하면 인수가 충분하지 않다는 의미이므로 <code>Err</code> 값과 함께 조기 반환(early return)합니다. <code>file_path</code> 값에 대해서도 동일한 작업을 수행합니다.</p>
<h3 id="반복자-어댑터로-코드를-더-명확하게-만들기"><a class="header" href="#반복자-어댑터로-코드를-더-명확하게-만들기">반복자 어댑터로 코드를 더 명확하게 만들기</a></h3>
<p>I/O 프로젝트의 <code>search</code> 함수에서도 반복자의 장점을 활용할 수 있습니다. 목록 12-19에 있었던 코드를 목록 13-21에 다시 가져왔습니다:</p>
<Listing number="13-21" file-name="src/lib.rs" caption="The implementation of the `search` function from Listing 12-19">
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err("인수가 부족합니다");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>반복자 어댑터 메서드들을 사용하여 이 코드를 더 간결하게 작성할 수 있습니다. 그렇게 함으로써 가변적인 중간 <code>results</code> 벡터를 두지 않아도 됩니다. 함수형 프로그래밍 스타일은 코드를 더 명확하게 만들기 위해 가변 상태의 양을 최소화하는 것을 선호합니다. 가변 상태를 제거하면 <code>results</code> 벡터에 대한 동시 접근을 관리할 필요가 없기 때문에, 나중에 검색을 병렬로 수행하도록 개선하는 것이 가능해질 수 있습니다. 목록 13-22는 이러한 변경 사항을 보여줍니다:</p>
<Listing number="13-22" file-name="src/lib.rs" caption="Using iterator adapter methods in the implementation of the `search` function">
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(
</span><span class="boring">        mut args: impl Iterator&lt;Item = String&gt;,
</span><span class="boring">    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        args.next();
</span><span class="boring">
</span><span class="boring">        let query = match args.next() {
</span><span class="boring">            Some(arg) =&gt; arg,
</span><span class="boring">            None =&gt; return Err("검색어를 얻지 못했습니다"),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let file_path = match args.next() {
</span><span class="boring">            Some(arg) =&gt; arg,
</span><span class="boring">            None =&gt; return Err("파일 경로를 얻지 못했습니다"),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let ignore_case = env::var("IGNORE_CASE").is_ok();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            query,
</span><span class="boring">            file_path,
</span><span class="boring">            ignore_case,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!("{line}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    contents
        .lines()
        .filter(|line| line.contains(query))
        .collect()
}
<span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = "rUsT";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec!["Rust:", "Trust me."],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p><code>search</code> 함수의 목적은 <code>contents</code> 내에서 <code>query</code>를 포함하는 모든 라인을 반환하는 것이었음을 상기해 보세요. 목록 13-16의 <code>filter</code> 예제와 유사하게, 이 코드는 <code>line.contains(query)</code>가 <code>true</code>를 반환하는 라인들만 남기기 위해 <code>filter</code> 어댑터를 사용합니다. 그런 다음 <code>collect</code>를 통해 매칭된 라인들을 다른 벡터로 수집합니다. 훨씬 단순해졌죠! <code>search_case_insensitive</code> 함수도 반복자 메서드를 사용하도록 똑같이 변경해 보세요.</p>
<h3 id="루프와-반복자-중-선택하기"><a class="header" href="#루프와-반복자-중-선택하기">루프와 반복자 중 선택하기</a></h3>
<p>그다음 자연스러운 질문은 자신의 코드에서 어떤 스타일을 왜 선택해야 하느냐일 것입니다: 목록 13-21의 원래 구현일까요, 아니면 목록 13-22의 반복자를 사용한 버전일까요? 대부분의 러스트 프로그래머들은 반복자 스타일을 선호합니다. 처음에는 익숙해지는 데 약간의 노력이 필요하지만, 다양한 반복자 어댑터와 그 기능을 이해하고 나면 반복자가 더 이해하기 쉬울 수 있습니다. 루프를 돌리고 새로운 벡터를 만드는 세부 사항을 만지작거리거는 대신, 코드는 루프의 고수준 목적에 집중합니다. 이는 흔한 코드들을 추상화하여, 반복자의 각 요소가 통과해야 하는 필터링 조건과 같이 이 코드에 고유한 개념들을 더 쉽게 볼 수 있게 해줍니다.</p>
<p>하지만 두 구현이 정말로 동일할까요? 직관적으로는 저수준의 루프가 더 빠를 것이라고 가정할 수 있습니다. 성능에 대해 이야기해 봅시다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="성능-비교-루프-vs-반복자"><a class="header" href="#성능-비교-루프-vs-반복자">성능 비교: 루프 vs. 반복자</a></h2>
<p>루프와 반복자 중 어느 것을 사용할지 결정하려면, 어떤 구현이 더 빠른지 알아야 합니다: 명시적인 <code>for</code> 루프를 사용한 <code>search</code> 함수 버전인지, 아니면 반복자를 사용한 버전인지 말이죠.</p>
<p>아서 코난 도일 경의 <em>셜록 홈즈의 모험</em> 전체 내용을 <code>String</code>으로 불러온 다음, 내용 중에서 단어 _the_를 찾는 방식으로 벤치마크를 실행했습니다. <code>for</code> 루프를 사용한 <code>search</code> 버전과 반복자를 사용한 버전의 벤치마크 결과는 다음과 같습니다:</p>
<pre><code class="language-text">test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
</code></pre>
<p>두 구현의 성능은 비슷합니다! 여기서 벤치마크 코드를 설명하지는 않을 것인데, 핵심은 두 버전이 완전히 동일하다는 것을 증명하는 것이 아니라 이 두 구현이 성능 측면에서 어떻게 비교되는지에 대한 일반적인 감을 잡는 것이기 때문입니다.</p>
<p>더 포괄적인 벤치마크를 위해서는 다양한 크기의 여러 텍스트를 <code>contents</code>로 사용하고, 다양한 단어와 길이를 <code>query</code>로 사용하는 등 모든 종류의 변수들을 확인해야 합니다. 요점은 이것입니다: 반복자는 고수준의 추상화임에도 불구하고, 저수준 코드를 직접 작성했을 때와 거의 동일한 코드로 컴파일됩니다. 반복자는 러스트의 <em>제로 코스트 추상화(zero-cost abstractions)</em> 중 하나로, 이는 추상화를 사용하더라도 추가적인 런타임 오버헤드가 발생하지 않음을 의미합니다. 이는 C++의 최초 설계자이자 구현자인 비야네 스트롭스트룹(Bjarne Stroustrup)이 “Foundations of C++” (2012)에서 _제로 오버헤드(zero-overhead)_를 정의한 방식과 유사합니다:</p>
<blockquote>
<p>일반적으로, C++ 구현은 제로 오버헤드 원칙을 따릅니다: 사용하지 않는 것에 대해서는 비용을 지불하지 않습니다. 더 나아가: 사용하는 것에 대해서는, 직접 코드를 작성하더라도 그보다 더 잘할 수는 없습니다.</p>
</blockquote>
<p>또 다른 예로, 다음 코드는 오디오 디코더에서 가져온 것입니다. 디코딩 알고리즘은 선형 예측(linear prediction) 연산을 사용하여 이전 샘플들의 선형 함수를 기반으로 미래 값을 추정합니다. 이 코드는 반복자 체인을 사용하여 스코프 내의 세 변수에 대해 수학 연산을 수행합니다: 데이터 슬라이스인 <code>buffer</code>, 12개의 계수가 담긴 <code>coefficients</code> 배열, 그리고 <code>qlp_shift</code>만큼 데이터를 시프트할 양입니다. 이 예제에서는 변수들을 선언만 하고 값을 주지는 않았습니다. 이 코드가 문맥 밖에서는 큰 의미가 없을지라도, 러스트가 고수준의 아이디어를 어떻게 저수준 코드로 번역하는지 보여주는 간결하고 실질적인 예입니다.</p>
<pre><code class="language-rust ignore">let buffer: &amp;mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
                                 .zip(&amp;buffer[i - 12..i])
                                 .map(|(&amp;c, &amp;s)| c * s as i64)
                                 .sum::&lt;i64&gt;() &gt;&gt; qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}</code></pre>
<p><code>prediction</code> 값을 계산하기 위해, 이 코드는 <code>coefficients</code>에 있는 12개의 각 값을 순회하면서 <code>zip</code> 메서드를 사용하여 계수 값들을 <code>buffer</code>의 이전 12개 값과 쌍으로 묶습니다. 그런 다음 각 쌍에 대해 두 값을 곱하고, 그 결과들을 모두 합산한 뒤, 합계의 비트를 <code>qlp_shift</code>만큼 오른쪽으로 시프트합니다.</p>
<p>오디오 디코더와 같은 애플리케이션의 계산은 종종 성능을 최우선으로 고려합니다. 여기서 우리는 반복자를 생성하고, 두 개의 어댑터를 사용한 다음, 값을 소비합니다. 이 러스트 코드는 어떤 어셈블리 코드로 컴파일될까요? 음, 이 글을 쓰는 시점에서는 직접 손으로 작성한 것과 동일한 어셈블리로 컴파일됩니다. <code>coefficients</code>의 값들을 순회하는 것에 대응하는 루프가 전혀 없습니다: 러스트는 12번의 반복이 있음을 알고 있기 때문에 루프를 “언롤(unroll)”합니다. _언롤링(Unrolling)_은 루프 제어 코드의 오버헤드를 제거하고 대신 루프의 각 반복에 대해 반복되는 코드를 생성하는 최적화 기법입니다.</p>
<p>모든 계수(coefficients)가 레지스터에 저장되므로, 값에 접근하는 것이 매우 빠릅니다. 런타임에 배열 접근에 대한 경계 검사(bounds checks)도 없습니다. 러스트가 적용할 수 있는 이러한 모든 최적화는 결과 코드를 매우 효율적으로 만듭니다. 이제 이 사실을 알았으니, 두려움 없이 반복자와 클로저를 사용할 수 있습니다! 이들은 코드를 더 고수준으로 보이게 만들지만, 그렇게 함으로써 발생하는 런타임 성능 저하는 없습니다.</p>
<h2 id="요약-12"><a class="header" href="#요약-12">요약</a></h2>
<p>클로저와 반복자는 함수형 프로그래밍 언어의 아이디어에서 영감을 받은 러스트의 기능입니다. 이들은 저수준 성능을 유지하면서도 고수준의 아이디어를 명확하게 표현할 수 있는 러스트의 능력에 기여합니다. 클로저와 반복자의 구현은 런타임 성능에 영향을 주지 않도록 설계되었습니다. 이는 제로 코스트 추상화를 제공하고자 하는 러스트의 목표 중 일부입니다.</p>
<p>이제 I/O 프로젝트의 표현력을 향상시켰으니, 프로젝트를 전 세계와 공유하는 데 도움이 될 <code>cargo</code>의 몇 가지 추가 기능들을 살펴봅시다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo와-cratesio에-대해-더-알아보기"><a class="header" href="#cargo와-cratesio에-대해-더-알아보기">Cargo와 Crates.io에 대해 더 알아보기</a></h1>
<p>지금까지 우리는 코드를 빌드하고, 실행하고, 테스트하기 위해 Cargo의 가장 기본적인 기능들만 사용해 왔지만, Cargo는 훨씬 더 많은 일을 할 수 있습니다. 이번 장에서는 Cargo의 다른 고급 기능들 중 일부를 살펴보고 다음 작업들을 어떻게 수행하는지 보여드릴 것입니다:</p>
<ul>
<li>릴리스 프로필을 통해 빌드 커스터마이징하기</li>
<li><a href="https://crates.io/">crates.io</a>에 라이브러리 게시하기<!-- ignore --></li>
<li>워크스페이스를 사용하여 대규모 프로젝트 구성하기</li>
<li><a href="https://crates.io/">crates.io</a>에서 바이너리 설치하기<!-- ignore --></li>
<li>커스텀 명령을 사용하여 Cargo 확장하기</li>
</ul>
<p>Cargo는 이번 장에서 다루는 기능보다 훨씬 더 많은 일을 할 수 있으므로, 모든 기능에 대한 자세한 설명은 <a href="https://doc.rust-lang.org/cargo/">Cargo 공식 문서</a>를 참조하십시오.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="릴리스-프로필로-빌드-커스터마이징하기"><a class="header" href="#릴리스-프로필로-빌드-커스터마이징하기">릴리스 프로필로 빌드 커스터마이징하기</a></h2>
<p>러스트에서 _릴리스 프로필(release profiles)_은 프로그래머가 코드 컴파일을 위한 다양한 옵션들을 더 세밀하게 제어할 수 있게 해주는, 서로 다른 설정으로 미리 정의되거나 커스터마이징 가능한 프로필입니다. 각 프로필은 다른 프로필과 독립적으로 설정됩니다.</p>
<p>Cargo에는 두 가지 주요 프로필이 있습니다: <code>cargo build</code>를 실행할 때 사용되는 <code>dev</code> 프로필과, <code>cargo build --release</code>를 실행할 때 사용되는 <code>release</code> 프로필입니다. <code>dev</code> 프로필은 개발에 적합한 기본값들로 정의되어 있으며, <code>release</code> 프로필은 릴리스 빌드에 적합한 기본값들로 정의되어 있습니다.</p>
<p>이 프로필 이름들은 빌드 출력 결과에서 보셨을 수도 있어 익숙할 것입니다:</p>
<!-- manual-regeneration
anywhere, run:
cargo build
cargo build --release
and ensure output below is accurate
-->
<pre><code class="language-console">$ cargo build
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.00s
$ cargo build --release
    Finished `release` profile [optimized] target(s) in 0.32s
</code></pre>
<p><code>dev</code>와 <code>release</code>가 바로 컴파일러가 사용하는 서로 다른 프로필들입니다.</p>
<p>Cargo에는 각 프로필에 대한 기본 설정이 있으며, 이는 프로젝트의 <em>Cargo.toml</em> 파일에 <code>[profile.*]</code> 섹션을 명시적으로 추가하지 않았을 때 적용됩니다. 커스터마이징하고 싶은 프로필에 대해 <code>[profile.*]</code> 섹션을 추가하면, 기본 설정의 일부를 덮어쓸 수 있습니다. 예를 들어, <code>dev</code>와 <code>release</code> 프로필의 <code>opt-level</code> 설정에 대한 기본값은 다음과 같습니다:</p>
<p><span class="filename">파일명: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
</code></pre>
<p><code>opt-level</code> 설정은 러스트가 코드에 적용할 최적화 수준을 0에서 3 사이의 범위로 제어합니다. 더 많은 최적화를 적용하면 컴파일 시간이 길어지므로, 개발 중이고 코드를 자주 컴파일한다면 결과 코드가 느리게 실행되더라도 더 빠른 컴파일을 위해 적은 최적화를 원할 것입니다. 따라서 <code>dev</code>의 기본 <code>opt-level</code>은 <code>0</code>입니다. 코드를 릴리스할 준비가 되었을 때는 컴파일에 더 많은 시간을 들이는 것이 좋습니다. 릴리스 모드에서는 컴파일을 한 번만 하겠지만, 컴파일된 프로그램은 여러 번 실행할 것이므로, 릴리스 모드는 더 빠른 실행 코드를 위해 더 긴 컴파일 시간과 맞바꿉니다. 이것이 <code>release</code> 프로필의 기본 <code>opt-level</code>이 <code>3</code>인 이유입니다.</p>
<p>_Cargo.toml_에 다른 값을 추가하여 기본 설정을 덮어쓸 수 있습니다. 예를 들어, 개발 프로필에서 최적화 레벨 1을 사용하고 싶다면, 프로젝트의 <em>Cargo.toml</em> 파일에 다음 두 줄을 추가하면 됩니다:</p>
<p><span class="filename">파일명: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 1
</code></pre>
<p>이 코드는 기본 설정인 <code>0</code>을 덮어씁니다. 이제 <code>cargo build</code>를 실행하면, Cargo는 <code>dev</code> 프로필의 기본값에 우리가 커스터마이징한 <code>opt-level</code>을 더해 사용하게 됩니다. <code>opt-level</code>을 <code>1</code>로 설정했기 때문에, Cargo는 기본값보다는 더 많은 최적화를 적용하겠지만 릴리스 빌드만큼은 아닐 것입니다.</p>
<p>각 프로필에 대한 설정 옵션 및 기본값의 전체 목록은 <a href="https://doc.rust-lang.org/cargo/reference/profiles.html">Cargo 공식 문서</a>를 참조하십시오.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cratesio에-크레이트-게시하기"><a class="header" href="#cratesio에-크레이트-게시하기">Crates.io에 크레이트 게시하기</a></h2>
<p>지금까지 우리는 <a href="https://crates.io/">crates.io</a><!-- ignore -->의 패키지들을 프로젝트의 의존성으로 사용해 왔지만, 여러분의 패키지를 게시하여 다른 사람들과 코드를 공유할 수도 있습니다. <a href="https://crates.io/">crates.io</a><!-- ignore -->의 크레이트 레지스트리는 여러분 패키지의 소스 코드를 배포하므로, 주로 오픈 소스 코드를 호스팅합니다.지금까지 우리는 <a href="https://crates.io/">crates.io</a><!-- ignore -->의 패키지들을 프로젝트의 의존성으로 사용해 왔지만, 여러분의 패키지를 게시하여 다른 사람들과 코드를 공유할 수도 있습니다. <a href="https://crates.io/">crates.io</a><!-- ignore -->의 크레이트 레지스트리는 여러분 패키지의 소스 코드를 배포하므로, 주로 오픈 소스 코드를 호스팅합니다.</p>
<p>러스트와 Cargo에는 게시된 패키지를 사람들이 더 쉽게 찾고 사용할 수 있게 해주는 기능들이 있습니다. 다음으로 이러한 기능들 중 일부를 살펴보고, 패키지를 게시하는 방법을 설명하겠습니다.</p>
<h3 id="유용한-문서-주석-만들기"><a class="header" href="#유용한-문서-주석-만들기">유용한 문서 주석 만들기</a></h3>
<p>패키지를 정확하게 문서화하면 다른 사용자들이 언제 어떻게 패키지를 사용해야 하는지 알 수 있으므로, 문서를 작성하는 데 시간을 투자할 가치가 있습니다. 3장에서 우리는 두 개의 슬래시(<code>//</code>)를 사용하여 러스트 코드에 주석을 다는 방법을 논의했습니다. 러스트에는 HTML 문서를 생성해 주는 _문서 주석(documentation comment)_이라고 불리는 특별한 종류의 주석도 있습니다. 이 HTML은 여러분의 크레이트가 어떻게 _구현_되었는지가 아니라, 크레이트를 어떻게 _사용_하는지에 관심이 있는 프로그래머들을 위해 공개 API 항목들에 대한 문서 주석 내용을 보여줍니다.</p>
<p>문서 주석은 두 개의 슬래시 대신 세 개의 슬래시(<code>///</code>)를 사용하며, 텍스트 서식을 위한 마크다운(Markdown) 표기법을 지원합니다. 문서 주석은 해당 주석이 설명하는 항목 바로 앞에 배치합니다. 목록 14-1은 <code>my_crate</code>라는 이름의 크레이트에 있는 <code>add_one</code> 함수에 대한 문서 주석을 보여줍니다.</p>
<Listing number="14-1" file-name="src/lib.rs" caption="A documentation comment for a function">
<pre><code class="language-rust ignore">/// 주어진 숫자에 1을 더합니다.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}</code></pre>
</Listing>
<p>여기서는 <code>add_one</code> 함수가 무엇을 하는지에 대한 설명을 제공하고, <code>Examples</code>라는 제목의 섹션을 시작한 다음, <code>add_one</code> 함수를 어떻게 사용하는지 보여주는 코드를 제시했습니다. 이 문서 주석으로부터 <code>cargo doc</code>을 실행하여 HTML 문서를 생성할 수 있습니다. 이 명령은 러스트와 함께 배포되는 <code>rustdoc</code> 도구를 실행하고, 생성된 HTML 문서를 <em>target/doc</em> 디렉토리에 넣습니다.</p>
<p>편리하게도, <code>cargo doc --open</code>을 실행하면 현재 크레이트의 문서(및 크레이트의 모든 의존성 문서)를 위한 HTML을 빌드하고 그 결과를 웹 브라우저에서 열어줍니다. <code>add_one</code> 함수로 이동하면 그림 14-1에 표시된 것처럼 문서 주석의 텍스트가 어떻게 렌더링되는지 볼 수 있습니다:</p>
<img alt="Rendered HTML documentation for the `add_one` function of `my_crate`" src="img/trpl14-01.png" class="center" />
<p><span class="caption">그림 14-1: <code>add_one</code> 함수의 HTML 문서</span></p>
<h4 id="자주-사용되는-섹션들"><a class="header" href="#자주-사용되는-섹션들">자주 사용되는 섹션들</a></h4>
<p>목록 14-1에서는 <code># Examples</code> 마크다운 헤더를 사용하여 HTML에 “Examples”라는 제목의 섹션을 만들었습니다. 다음은 크레이트 작성자들이 문서에서 자주 사용하는 다른 섹션들입니다:</p>
<ul>
<li><strong>Panics</strong>: 설명하고 있는 함수가 패닉을 일으킬 수 있는 시나리오입니다. 프로그램이 패닉에 빠지는 것을 원하지 않는 함수 호출자는 이러한 상황에서 함수를 호출하지 않도록 주의해야 합니다.</li>
<li><strong>Errors</strong>: 만약 함수가 <code>Result</code>를 반환한다면, 발생할 수 있는 에러의 종류와 어떤 조건에서 그러한 에러가 반환되는지 설명하는 것이 호출자에게 도움이 됩니다. 호출자는 이를 통해 다양한 종류의 에러를 서로 다른 방식으로 처리하는 코드를 작성할 수 있습니다.</li>
<li><strong>Safety</strong>: 만약 함수가 호출하기에 <code>unsafe</code>하다면(20장에서 안전하지 않음에 대해 다룹니다), 왜 함수가 안전하지 않은지 설명하고 호출자가 준수해야 할 불변성(invariants)을 다루는 섹션이 있어야 합니다.</li>
</ul>
<p>대부분의 문서 주석에 이 모든 섹션이 필요한 것은 아니지만, 이는 사용자들이 여러분의 코드에 대해 알고 싶어 할 만한 측면들을 상기시켜 주는 좋은 체크리스트가 됩니다.</p>
<h4 id="테스트로서의-문서-주석"><a class="header" href="#테스트로서의-문서-주석">테스트로서의 문서 주석</a></h4>
<p>문서 주석에 예제 코드 블록을 추가하면 라이브러리 사용 방법을 보여주는 데 도움이 되며, 여기에는 추가적인 보너스가 있습니다: <code>cargo test</code>를 실행하면 문서에 있는 코드 예제들이 테스트로서 실행됩니다! 예제가 포함된 문서보다 더 좋은 것은 없습니다. 하지만 문서가 작성된 이후 코드가 변경되어 작동하지 않는 예제보다 더 나쁜 것도 없습니다. 목록 14-1의 <code>add_one</code> 함수 문서와 함께 <code>cargo test</code>를 실행하면, 테스트 결과에서 다음과 같은 섹션을 볼 수 있을 것입니다:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-01/
cargo test
copy just the doc-tests section below
-->
<pre><code class="language-text">   Doc-tests my_crate

running 1 test
test src/lib.rs - add_one (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.27s
</code></pre>
<p>이제 함수나 예제 중 하나를 변경하여 예제의 <code>assert_eq!</code>가 패닉을 일으키도록 하고 다시 <code>cargo test</code>를 실행하면, 문서 테스트(doc tests)가 예제와 코드가 서로 일치하지 않는다는 것을 잡아내는 것을 볼 수 있습니다!</p>
<h4 id="항목을-포함하고-있는-요소에-주석-달기"><a class="header" href="#항목을-포함하고-있는-요소에-주석-달기">항목을 포함하고 있는 요소에 주석 달기</a></h4>
<p><code>//!</code> 스타일의 문서 주석은 주석 뒤에 오는 항목이 아니라, 주석을 포함하고 있는 항목에 문서를 추가합니다. 우리는 일반적으로 크레이트 루트 파일(관례상 <em>src/lib.rs</em>)이나 모듈 내부에 이러한 문서 주석을 사용하여 크레이트나 모듈 전체를 문서화합니다.</p>
<p>예를 들어, <code>add_one</code> 함수를 포함하고 있는 <code>my_crate</code> 크레이트의 목적을 설명하는 문서를 추가하려면, 목록 14-2와 같이 <em>src/lib.rs</em> 파일의 시작 부분에 <code>//!</code>로 시작하는 문서 주석을 추가합니다.</p>
<Listing number="14-2" file-name="src/lib.rs" caption="Documentation for the `my_crate` crate as a whole">
<pre><code class="language-rust ignore">//! # My Crate
//!
//! `my_crate`는 특정 계산을 더 편리하게 수행할 수 있게 해주는
//! 유틸리티 모음입니다.

/// 주어진 숫자에 1을 더합니다.
// --snip--
<span class="boring">///
</span><span class="boring">/// # Examples
</span><span class="boring">///
</span><span class="boring">/// ```
</span><span class="boring">/// let arg = 5;
</span><span class="boring">/// let answer = my_crate::add_one(arg);
</span><span class="boring">///
</span><span class="boring">/// assert_eq!(6, answer);
</span><span class="boring">/// ```
</span><span class="boring">pub fn add_one(x: i32) -&gt; i32 {
</span><span class="boring">    x + 1
</span><span class="boring">}</span></code></pre>
</Listing>
<p><code>//!</code>로 시작하는 마지막 줄 뒤에 코드가 전혀 없다는 점에 주목하세요. <code>///</code> 대신 <code>//!</code>로 주석을 시작했기 때문에, 주석 뒤에 오는 항목이 아니라 이 주석을 포함하는 항목을 문서화하고 있습니다. 이 경우 그 항목은 크레이트 루트인 <em>src/lib.rs</em> 파일입니다. 이 주석들은 크레이트 전체를 설명합니다.</p>
<p><code>cargo doc --open</code>을 실행하면 그림 14-2에 표시된 것처럼 크레이트의 공개 항목 목록 위에 <code>my_crate</code> 문서의 메인 페이지에 이 주석들이 표시됩니다:</p>
<img alt="Rendered HTML documentation with a comment for the crate as a whole" src="img/trpl14-02.png" class="center" />
<p><span class="caption">그림 14-2: 크레이트 전체를 설명하는 주석이 포함된 <code>my_crate</code> 문서 렌더링 결과</span></p>
<p>항목 내의 문서 주석은 특히 크레이트와 모듈을 설명하는 데 유용합니다. 컨테이너의 전반적인 목적을 설명하여 사용자가 크레이트의 구성을 이해하는 데 도움을 주기 위해 사용하세요.</p>
<h3 id="pub-use를-사용하여-편리한-공개-api-내보내기"><a class="header" href="#pub-use를-사용하여-편리한-공개-api-내보내기"><code>pub use</code>를 사용하여 편리한 공개 API 내보내기</a></h3>
<p>공개 API의 구조는 크레이트를 게시할 때 주요 고려 사항 중 하나입니다. 여러분의 크레이트를 사용하는 사람들은 여러분보다 구조에 익숙하지 않으며, 크레이트의 모듈 계층 구조가 크다면 원하는 부분을 찾는 데 어려움을 겪을 수 있습니다.</p>
<p>7장에서 우리는 <code>pub</code> 키워드를 사용하여 항목을 공개하는 방법과 <code>use</code> 키워드를 사용하여 항목을 스코프로 가져오는 방법을 다루었습니다. 하지만 크레이트를 작성하는 동안 여러분에게는 합리적이었던 구조가 사용자에게는 그리 편리하지 않을 수 있습니다. 여러분은 여러 수준의 계층 구조로 구조체를 구성하고 싶을 수 있지만, 계층 구조 깊은 곳에 정의된 타입을 사용하려는 사람들은 해당 타입의 존재를 찾는 데 어려움을 겪을 수 있습니다. 또한 <code>use</code> <code>my_crate::UsefulType;</code> 대신 <code>use</code> <code>my_crate::some_module::another_module::UsefulType;</code>를 입력해야 하는 것에 불편함을 느낄 수도 있습니다.</p>
<p>다행히도, 내부 구조가 다른 라이브러리에서 사용하기에 편리하지 않더라도 내부 조직을 재배치할 필요는 없습니다. 대신 <code>pub use</code>를 사용하여 내부 구조와는 다른 공개 구조로 항목들을 다시 내보낼(re-export) 수 있습니다. 다시 내보내기는 한 위치에 있는 공개 항목을 가져와서, 마치 다른 위치에서 정의된 것처럼 다른 위치에서 공개되도록 합니다.</p>
<p>예를 들어, 예술적 개념을 모델링하기 위해 <code>art</code>라는 이름의 라이브러리를 만들었다고 가정해 봅시다. 목록 14-3과 같이 이 라이브러리 내에는 <code>PrimaryColor</code>와 <code>SecondaryColor</code>라는 두 개의 열거형을 포함하는 <code>kinds</code> 모듈과 <code>mix</code>라는 함수를 포함하는 <code>utils</code> 모듈이 있습니다:</p>
<Listing number="14-3" file-name="src/lib.rs" caption="An `art` library with items organized into `kinds` and `utils` modules">
<pre><code class="language-rust noplayground test_harness">//! # Art
//!
//! 예술적 개념을 모델링하기 위한 라이브러리입니다.

pub mod kinds {
    /// RYB 색상 모델에 따른 1차색.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// RYB 색상 모델에 따른 2차색.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use crate::kinds::*;

    /// 두 가지 1차색을 동일한 양으로 혼합하여
    /// 2차색을 만듭니다.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
        // --생략--
<span class="boring">        unimplemented!();
</span>    }
}</code></pre>
</Listing>
<p>그림 14-3은 <code>cargo doc</code>에 의해 생성된 이 크레이트 문서의 메인 페이지가 어떤 모습일지를 보여줍니다:</p>
<img alt="Rendered documentation for the `art` crate that lists the `kinds` and `utils` modules" src="img/trpl14-03.png" class="center" />
<p><span class="caption">그림 14-3: <code>kinds</code>와 <code>utils</code> 모듈이 나열된 <code>art</code> 문서의 메인 페이지</span></p>
<p><code>PrimaryColor</code>와 <code>SecondaryColor</code> 타입뿐만 아니라 <code>mix</code> 함수도 메인 페이지에 나열되지 않는다는 점에 유의하세요. 이들을 보려면 <code>kinds</code>와 <code>utils</code>를 클릭해야 합니다.</p>
<p>이 라이브러리에 의존하는 다른 크레이트는 현재 정의된 모듈 구조를 명시하여 <code>art</code>로부터 항목들을 스코프로 가져오는 <code>use</code> 구문이 필요할 것입니다. 목록 14-4는 <code>art</code> 크레이트의 <code>PrimaryColor</code>와 <code>mix</code> 항목을 사용하는 크레이트의 예입니다:</p>
<Listing number="14-4" file-name="src/main.rs" caption="A crate using the `art` crate’s items with its internal structure exported">
<pre><code class="language-rust ignore">use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}</code></pre>
</Listing>
<p>목록 14-4의 코드를 작성한 사람은 <code>art</code> 크레이트를 사용하기 위해 <code>PrimaryColor</code>가 <code>kinds</code> 모듈에 있고 <code>mix</code>가 <code>utils</code> 모듈에 있다는 것을 알아내야 했습니다. <code>art</code> 크레이트의 모듈 구조는 이 크레이트를 사용하는 사람보다 개발하는 사람에게 더 관련이 있습니다. 이러한 내부 구조는 <code>art</code> 크레이트를 어떻게 사용하는지 이해하려는 사람에게는 유용한 정보를 제공하지 않으며, 오히려 어디를 찾아야 할지 알아내야 하고 <code>use</code> 구문에 모듈 이름을 명시해야 하므로 혼란을 야기합니다.</p>
<p>공개 API에서 내부 조직을 감추기 위해, 목록 14-5와 같이 목록 14-3의 <code>art</code> 크레이트 코드를 수정하여 항목들을 최상위 수준에서 다시 내보내는 <code>pub use</code> 구문을 추가할 수 있습니다:</p>
<Listing number="14-5" file-name="src/lib.rs" caption="Adding `pub use` statements to re-export items">
<pre><code class="language-rust ignore">//! # Art
//!
//! 예술적 개념을 모델링하기 위한 라이브러리입니다.

pub use self::kinds::PrimaryColor;
pub use self::kinds::SecondaryColor;
pub use self::utils::mix;

pub mod kinds {
    // --생략--
<span class="boring">    /// RYB 색상 모델에 따른 1차색.
</span><span class="boring">    pub enum PrimaryColor {
</span><span class="boring">        Red,
</span><span class="boring">        Yellow,
</span><span class="boring">        Blue,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// RYB 색상 모델에 따른 2차색.
</span><span class="boring">    pub enum SecondaryColor {
</span><span class="boring">        Orange,
</span><span class="boring">        Green,
</span><span class="boring">        Purple,
</span><span class="boring">    }
</span>}

pub mod utils {
    // --생략--
<span class="boring">    use crate::kinds::*;
</span><span class="boring">
</span><span class="boring">    /// 두 가지 1차색을 동일한 양으로 혼합하여
</span><span class="boring">    /// 2차색을 만듭니다.
</span><span class="boring">    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
</span><span class="boring">        SecondaryColor::Orange
</span><span class="boring">    }
</span>}</code></pre>
</Listing>
<p><code>cargo doc</code>이 생성하는 이 크레이트의 API 문서는 이제 그림 14-4와 같이 메인 페이지에 다시 내보낸 항목들을 나열하고 링크를 제공하므로, <code>PrimaryColor</code>, <code>SecondaryColor</code> 타입과 <code>mix</code> 함수를 더 쉽게 찾을 수 있습니다.</p>
<img alt="Rendered documentation for the `art` crate with the re-exports on the front page" src="img/trpl14-04.png" class="center" />
<p><span class="caption">그림 14-4: 다시 내보낸 항목들이 나열된 <code>art</code> 문서의 메인 페이지</span></p>
<p><code>art</code> 크레이트 사용자들은 여전히 목록 14-4에서 보여준 것처럼 목록 14-3의 내부 구조를 보고 사용할 수도 있고, 목록 14-6과 같이 목록 14-5의 더 편리한 구조를 사용할 수도 있습니다:</p>
<Listing number="14-6" file-name="src/main.rs" caption="A program using the re-exported items from the `art` crate">
<pre><code class="language-rust ignore">use art::mix;
use art::PrimaryColor;

fn main() {
    // --생략--
<span class="boring">    let red = PrimaryColor::Red;
</span><span class="boring">    let yellow = PrimaryColor::Yellow;
</span><span class="boring">    mix(red, yellow);
</span>}</code></pre>
</Listing>
<p>모듈이 깊게 중첩된 경우, <code>pub use</code>를 사용하여 최상위 수준에서 타입을 다시 내보내는 것은 크레이트 사용자들의 경험에 큰 차이를 만들 수 있습니다. <code>pub use</code>의 또 다른 일반적인 용도는 현재 크레이트의 의존성 정의를 다시 내보내어 해당 크레이트의 정의를 여러분 크레이트의 공개 API의 일부로 만드는 것입니다.</p>
<p>유용한 공개 API 구조를 만드는 것은 과학이라기보다 예술에 가까우며, 사용자에게 가장 잘 맞는 API를 찾기 위해 반복해서 개선할 수 있습니다. <code>pub use</code>를 사용하면 크레이트의 내부 구조를 유연하게 설계할 수 있으며, 그 내부 구조를 사용자에게 보여주는 방식과 분리할 수 있습니다. 여러분이 설치한 크레이트들의 코드를 살펴보며 내부 구조가 공개 API와 다른지 확인해 보세요.</p>
<h3 id="cratesio-계정-설정하기"><a class="header" href="#cratesio-계정-설정하기">Crates.io 계정 설정하기</a></h3>
<p>크레이트를 게시하려면 먼저 <a href="https://crates.io/">crates.io</a><!-- ignore -->에 계정을 만들고 API 토큰을 얻어야 합니다. 그렇게 하려면 <a href="https://crates.io/">crates.io</a><!-- ignore --> 홈페이지를 방문하여 깃허브(GitHub) 계정으로 로그인하세요. (현재는 깃허브 계정이 필수지만, 나중에는 다른 계정 생성 방법도 지원될 수 있습니다.) 로그인한 후 <a href="https://crates.io/me/">https://crates.io/me/</a><!-- ignore -->에서 계정 설정을 방문하여 API 키를 가져오세요. 그런 다음 <code>cargo login</code> 명령을 실행하고 안내에 따라 다음과 같이 API 키를 붙여넣으세요:</p>
<pre><code class="language-console">$ cargo login
abcdefghijklmnopqrstuvwxyz012345
</code></pre>
<p>이 명령은 Cargo에 여러분의 API 토큰을 알려주고 이를 로컬의 _~/.cargo/credentials_에 저장합니다. 이 토큰은 _비밀_이므로 다른 사람과 공유하지 마세요. 만약 어떤 이유로든 토큰을 공유했다면, 즉시 이를 취소하고 <a href="https://crates.io/">crates.io</a><!-- ignore -->에서 새로운 토큰을 생성해야 합니다.</p>
<h3 id="새-크레이트에-메타데이터-추가하기"><a class="header" href="#새-크레이트에-메타데이터-추가하기">새 크레이트에 메타데이터 추가하기</a></h3>
<p>게시하고 싶은 크레이트가 있다고 가정해 봅시다. 게시하기 전에, 크레이트의 <em>Cargo.toml</em> 파일에 있는 <code>[package]</code> 섹션에 몇 가지 메타데이터를 추가해야 합니다.</p>
<p>크레이트에는 고유한 이름이 필요합니다. 로컬에서 크레이트를 작업하는 동안에는 원하는 이름을 자유롭게 지을 수 있습니다. 하지만 <a href="https://crates.io/">crates.io</a><!-- ignore -->의 크레이트 이름은 선착순으로 할당됩니다. 누군가 이름을 사용 중이라면 다른 누구도 그 이름으로 크레이트를 게시할 수 없습니다. 크레이트 게시를 시도하기 전에 사용하려는 이름을 검색해 보세요. 만약 이름이 이미 사용 중이라면, 다른 이름을 찾아 <em>Cargo.toml</em> 파일의 <code>[package]</code> 섹션 아래에 있는 <code>name</code> 필드를 다음과 같이 새로운 이름으로 수정해야 합니다:</p>
<p><span class="filename">파일명: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
</code></pre>
<p>고유한 이름을 선택했더라도, 이 시점에서 크레이트를 게시하기 위해 <code>cargo publish</code>를 실행하면 경고와 함께 오류가 발생할 것입니다:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-01/
cargo publish
copy just the relevant lines below
-->
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
warning: manifest has no description, license, license-file, documentation, homepage or repository.
See https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata for more info.
--snip--
error: failed to publish to registry at https://crates.io

Caused by:
  the remote server responded with an error (status 400 Bad Request): missing or empty metadata fields: description, license. Please see https://doc.rust-lang.org/cargo/reference/manifest.html for more information on configuring these field
</code></pre>
<p>이 오류는 몇 가지 중요한 정보가 누락되었기 때문에 발생합니다: 사람들이 여러분의 크레이트가 무엇을 하는지, 그리고 어떤 조건에서 사용할 수 있는지 알 수 있도록 설명(description)과 라이선스(license)가 필수적으로 요구됩니다. _Cargo.toml_에 한두 문장 정도의 설명을 추가하세요. 이 설명은 검색 결과에서 크레이트와 함께 표시됩니다. <code>license</code> 필드에는 _라이선스 식별자 값_을 넣어야 합니다. <a href="http://spdx.org/licenses/">Linux Foundation의 SPDX(Software Package Data Exchange)</a>는 이 값으로 사용할 수 있는 식별자 목록을 제공합니다. 예를 들어, 크레이트에 MIT 라이선스를 적용하려면 <code>MIT</code> 식별자를 추가하세요:</p>
<p><span class="filename">파일명: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
license = "MIT"
</code></pre>
<p>SPDX에 나타나지 않는 라이선스를 사용하고 싶다면, 해당 라이선스의 텍스트를 파일에 담아 프로젝트에 포함시킨 뒤, <code>license</code> 키 대신 <code>license-file</code>을 사용하여 그 파일의 이름을 지정해야 합니다.</p>
<p>여러분의 프로젝트에 어떤 라이선스가 적합한지에 대한 안내는 이 책의 범위를 벗어납니다. 러스트 커뮤니티의 많은 사람들은 <code>MIT OR Apache-2.0</code>의 이중 라이선스를 사용하여 러스트와 동일한 방식으로 프로젝트 라이선스를 지정합니다. 이러한 관행은 <code>OR</code>로 구분된 여러 라이선스 식별자를 지정하여 프로젝트에 대해 여러 라이선스를 가질 수 있음을 보여줍니다.</p>
<p>고유한 이름, 버전, 설명, 그리고 라이선스가 추가된, 게시 준비가 완료된 프로젝트의 <em>Cargo.toml</em> 파일은 다음과 같은 모습일 것입니다:</p>
<p><span class="filename">파일명: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
version = "0.1.0"
edition = "2021"
description = "컴퓨터가 선택한 숫자를 맞히는 재미있는 게임입니다."
license = "MIT OR Apache-2.0"

[dependencies]
</code></pre>
<p><a href="https://doc.rust-lang.org/cargo/">Cargo 공식 문서</a>에는 다른 사람들이 여러분의 크레이트를 더 쉽게 발견하고 사용할 수 있도록 지정할 수 있는 추가 메타데이터가 설명되어 있습니다.</p>
<h3 id="cratesio에-게시하기"><a class="header" href="#cratesio에-게시하기">Crates.io에 게시하기</a></h3>
<p>계정을 만들고, API 토큰을 저장하고, 크레이트 이름을 선택하고, 필수 메타데이터까지 지정했다면 이제 게시할 준비가 되었습니다! 크레이트를 게시하면 다른 사람들이 사용할 수 있도록 특정 버전이 <a href="https://crates.io/">crates.io</a><!-- ignore -->에 업로드됩니다.</p>
<p>게시는 _영구적_이므로 주의해야 합니다. 해당 버전은 절대 덮어쓸 수 없으며, 코드를 삭제할 수도 없습니다. <a href="https://crates.io/">crates.io</a><!-- ignore -->의 주요 목표 중 하나는 코드의 영구적인 아카이브 역할을 하여, <a href="https://crates.io/">crates.io</a><!-- ignore -->의 크레이트에 의존하는 모든 프로젝트의 빌드가 계속해서 작동하도록 보장하는 것입니다. 버전을 삭제할 수 있게 하면 이 목표를 달성하는 것이 불가능해집니다. 하지만 게시할 수 있는 크레이트 버전의 수에는 제한이 없습니다.</p>
<p><code>cargo publish</code> 명령을 다시 실행해 보세요. 이제 성공할 것입니다:</p>
<!-- manual-regeneration
go to some valid crate, publish a new version
cargo publish
copy just the relevant lines below
-->
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
   Packaging guessing_game v0.1.0 (file:///projects/guessing_game)
   Verifying guessing_game v0.1.0 (file:///projects/guessing_game)
   Compiling guessing_game v0.1.0
(file:///projects/guessing_game/target/package/guessing_game-0.1.0)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.19s
   Uploading guessing_game v0.1.0 (file:///projects/guessing_game)
</code></pre>
<p>축하합니다! 이제 여러분의 코드를 러스트 커뮤니티와 공유했으며, 누구든지 자신의 프로젝트에 여러분의 크레이트를 의존성으로 쉽게 추가할 수 있습니다.</p>
<h3 id="기존-크레이트의-새로운-버전-게시하기"><a class="header" href="#기존-크레이트의-새로운-버전-게시하기">기존 크레이트의 새로운 버전 게시하기</a></h3>
<p>크레이트를 수정하고 새로운 버전을 릴리스할 준비가 되면, <em>Cargo.toml</em> 파일에 명시된 <code>version</code> 값을 변경하고 다시 게시합니다. 여러분이 수행한 변경 사항의 종류에 따라 <a href="http://semver.org/">시맨틱 버저닝(Semantic Versioning) 규칙</a>을 사용하여 적절한 다음 버전 번호를 결정하세요. 그런 다음 <code>cargo publish</code>를 실행하여 새로운 버전을 업로드합니다.</p>
<!-- Old link, do not remove -->
<p><a id="removing-versions-from-cratesio-with-cargo-yank"></a></p>
<h3 id="cargo-yank를-사용하여-cratesio의-버전-관리하기"><a class="header" href="#cargo-yank를-사용하여-cratesio의-버전-관리하기"><code>cargo yank</code>를 사용하여 Crates.io의 버전 관리하기</a></h3>
<p>크레이트의 이전 버전을 삭제할 수는 없지만, 향후 프로젝트들이 해당 버전을 새로운 의존성으로 추가하는 것을 방지할 수는 있습니다. 이는 어떤 이유로든 크레이트 버전이 깨진 경우에 유용합니다. 이러한 상황에서 Cargo는 크레이트 버전을 _yank(끌어내기)_하는 기능을 지원합니다.</p>
<p>버전을 yank하면 새로운 프로젝트가 해당 버전에 의존하는 것을 방지하는 동시에, 해당 버전에 이미 의존하고 있는 기존 프로젝트들은 계속해서 작동할 수 있게 합니다. 본질적으로 yank는 <em>Cargo.lock</em> 파일이 있는 모든 프로젝트가 깨지지 않도록 보장하며, 향후 생성되는 어떤 <em>Cargo.lock</em> 파일도 yank된 버전을 사용하지 않게 된다는 것을 의미합니다.</p>
<p>크레이트 버전을 yank하려면 이전에 게시한 크레이트 디렉토리에서 <code>cargo yank</code>를 실행하고 yank할 버전을 지정하세요. 예를 들어, <code>guessing_game</code> 크레이트의 1.0.1 버전을 게시했는데 이를 yank하고 싶다면, <code>guessing_game</code> 프로젝트 디렉토리에서 다음을 실행합니다:</p>
<!-- manual-regeneration:
cargo yank carol-test --version 2.1.0
cargo yank carol-test --version 2.1.0 --undo
-->
<pre><code class="language-console">$ cargo yank --vers 1.0.1
    Updating crates.io index
        Yank guessing_game@1.0.1
</code></pre>
<p>명령어에 <code>--undo</code>를 추가하면 yank를 취소하고 프로젝트들이 다시 해당 버전에 의존할 수 있도록 허용할 수도 있습니다:</p>
<pre><code class="language-console">$ cargo yank --vers 1.0.1 --undo
    Updating crates.io index
      Unyank guessing_game@1.0.1
</code></pre>
<p>yank는 코드를 삭제하지 <em>않습니다</em>. 예를 들어, 실수로 업로드된 비밀 정보를 삭제할 수 없습니다. 만약 그런 일이 발생한다면, 즉시 해당 비밀 정보를 재설정해야 합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cargo-워크스페이스"><a class="header" href="#cargo-워크스페이스">Cargo 워크스페이스</a></h2>
<p>12장에서 우리는 바이너리 크레이트와 라이브러리 크레이트를 포함하는 패키지를 빌드했습니다. 프로젝트가 발전함에 따라 라이브러리 크레이트가 계속 커져서 패키지를 여러 라이브러리 크레이트로 더 나누고 싶어질 수 있습니다. Cargo는 함께 개발되는 여러 관련 패키지들을 관리하는 데 도움을 주는 _워크스페이스(workspaces)_라는 기능을 제공합니다.</p>
<h3 id="워크스페이스-생성하기"><a class="header" href="#워크스페이스-생성하기">워크스페이스 생성하기</a></h3>
<p>_워크스페이스_는 동일한 _Cargo.lock_과 출력 디렉토리를 공유하는 패키지들의 집합입니다. 워크스페이스를 사용하여 프로젝트를 만들어 봅시다. 워크스페이스의 구조에 집중할 수 있도록 아주 간단한 코드를 사용하겠습니다. 워크스페이스를 구성하는 방법은 여러 가지가 있지만, 여기서는 가장 일반적인 방법 중 하나를 보여드리겠습니다. 하나의 바이너리와 두 개의 라이브러리를 포함하는 워크스페이스를 만들 것입니다. 주요 기능을 제공할 바이너리는 두 라이브러리에 의존하게 됩니다. 한 라이브러리는 <code>add_one</code> 함수를 제공하고, 두 번째 라이브러리는 <code>add_two</code> 함수를 제공할 것입니다. 이 세 크레이트는 동일한 워크스페이스의 일부가 될 것입니다. 먼저 워크스페이스를 위한 디렉토리를 만드는 것부터 시작합시다.</p>
<pre><code class="language-console">$ mkdir add
$ cd add
</code></pre>
<p>다음으로, <em>add</em> 디렉토리에 전체 워크스페이스를 설정할 <em>Cargo.toml</em> 파일을 생성합니다. 이 파일에는 <code>[package]</code> 섹션이 없습니다. 대신 <code>[workspace]</code> 섹션으로 시작하여 워크스페이스에 멤버를 추가할 수 있게 합니다. 또한 <code>resolver</code>를 <code>"2"</code>로 설정하여 워크스페이스에서 최신 버전의 Cargo 리졸버(resolver) 알고리즘을 사용하도록 명시합니다.</p>
<p><span class="filename">파일명: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]
resolver = "2"
</code></pre>
<p>다음으로, <em>add</em> 디렉토리 내에서 <code>cargo new</code>를 실행하여 <code>adder</code> 바이너리 크레이트를 생성합니다:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-01-adder-crate/add
rm -rf adder
cargo new adder
copy output below
-->
<pre><code class="language-console">$ cargo new adder
    Creating binary (application) `adder` package
      Adding `adder` as member of workspace at `file:///projects/add`
</code></pre>
<p>워크스페이스 내부에서 <code>cargo new</code>를 실행하면, 다음과 같이 워크스페이스 _Cargo.toml_의 <code>[workspace]</code> 정의에 있는 <code>members</code> 키에 새로 생성된 패키지가 자동으로 추가됩니다:</p>
<pre><code class="language-toml">[workspace]
resolver = "2"
members = ["adder"]
</code></pre>
<p>이 시점에서 <code>cargo build</code>를 실행하여 워크스페이스를 빌드할 수 있습니다. <em>add</em> 디렉토리의 파일 구조는 다음과 같아야 합니다:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<p>워크스페이스는 컴파일된 결과물이 들어갈 하나의 <em>target</em> 디렉토리를 최상위 수준에 가집니다. <code>adder</code> 패키지는 자신만의 <em>target</em> 디렉토리를 갖지 않습니다. 비록 <code>adder</code> 디렉토리 내부에서 <code>cargo build</code>를 실행하더라도, 컴파일된 결과물은 _add/adder/target_이 아니라 _add/target_에 위치하게 됩니다. Cargo가 워크스페이스에서 <em>target</em> 디렉토리 구조를 이렇게 만드는 이유는 워크스페이스 내의 크레이트들이 서로 의존하기 때문입니다. 만약 각 크레이트가 자신만의 <em>target</em> 디렉토리를 가진다면, 각 크레이트는 자신의 <em>target</em> 디렉토리에 결과물을 넣기 위해 워크스페이스 내의 다른 크레이트들을 매번 다시 컴파일해야 할 것입니다. 하나의 <em>target</em> 디렉토리를 공유함으로써, 크레이트들은 불필요한 재빌드를 피할 수 있습니다.</p>
<h3 id="워크스페이스의-두-번째-패키지-생성하기"><a class="header" href="#워크스페이스의-두-번째-패키지-생성하기">워크스페이스의 두 번째 패키지 생성하기</a></h3>
<p>다음으로, 워크스페이스에 <code>add_one</code>이라는 또 다른 멤버 패키지를 생성해 봅시다. 최상위 _Cargo.toml_을 수정하여 <code>members</code> 목록에 <em>add_one</em> 경로를 추가합니다:</p>
<p><span class="filename">파일명: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]
resolver = "2"
members = ["adder", "add_one"]
</code></pre>
<p>그 다음 <code>add_one</code>이라는 이름의 새로운 라이브러리 크레이트를 생성합니다:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-02-add-one/add
rm -rf add_one
cargo new add_one --lib
copy output below
-->
<pre><code class="language-console">$ cargo new add_one --lib
    Creating library `add_one` package
      Adding `add_one` as member of workspace at `file:///projects/add`
</code></pre>
<p>이제 <em>add</em> 디렉토리에는 다음과 같은 디렉토리와 파일들이 있어야 합니다:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── add_one
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<p><em>add_one/src/lib.rs</em> 파일에 <code>add_one</code> 함수를 추가해 봅시다:</p>
<p><span class="filename">파일명: add_one/src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}</code></pre>
<p>이제 바이너리가 포함된 <code>adder</code> 패키지가 라이브러리가 포함된 <code>add_one</code> 패키지에 의존하게 만들 수 있습니다. 먼저, _adder/Cargo.toml_에 <code>add_one</code>에 대한 경로 의존성을 추가해야 합니다.</p>
<p><span class="filename">파일명: adder/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
add_one = { path = "../add_one" }
</code></pre>
<p>Cargo는 워크스페이스 내의 크레이트들이 서로 의존할 것이라고 가정하지 않으므로, 의존성 관계에 대해 명시해야 합니다.</p>
<p>다음으로, <code>add_one</code> 크레이트의 <code>add_one</code> 함수를 <code>adder</code> 크레이트에서 사용해 봅시다. <em>adder/src/main.rs</em> 파일을 열고, 목록 14-7과 같이 <code>main</code> 함수가 <code>add_one</code> 함수를 호출하도록 수정합니다.</p>
<Listing number="14-7" file-name="adder/src/main.rs" caption="Using the `add_one` library crate in the `adder` crate">
<pre><code class="language-rust ignore">fn main() {
    let num = 10;
    println!("안녕하세요! {num} 더하기 1은 {}입니다!", add_one::add_one(num));
}</code></pre>
</Listing>
<p>최상위 <em>add</em> 디렉토리에서 <code>cargo build</code>를 실행하여 워크스페이스를 빌드해 봅시다!</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-07/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo build
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.22s
</code></pre>
<p><em>add</em> 디렉토리에서 바이너리 크레이트를 실행하려면, <code>cargo run</code>에 <code>-p</code> 인수와 패키지 이름을 사용하여 워크스페이스 내의 어떤 패키지를 실행할지 지정할 수 있습니다:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-07/add
cargo run -p adder
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo run -p adder
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.00s
     Running `target/debug/adder`
Hello, world! 10 plus one is 11!
</code></pre>
<p>이것은 <code>add_one</code> 크레이트에 의존하는 _adder/src/main.rs_의 코드를 실행합니다.</p>
<h4 id="워크스페이스에서-외부-패키지에-의존하기"><a class="header" href="#워크스페이스에서-외부-패키지에-의존하기">워크스페이스에서 외부 패키지에 의존하기</a></h4>
<p>각 크레이트의 디렉토리에 _Cargo.lock_을 두는 대신 하나만 사용함으로써, 모든 크레이트가 모든 의존성에 대해 동일한 버전을 사용하도록 보장합니다. 만약 <code>rand</code> 패키지를 _adder/Cargo.toml_과 <em>add_one/Cargo.toml</em> 파일에 추가하면, Cargo는 이 둘을 모두 하나의 <code>rand</code> 버전으로 해결하고 이를 하나의 _Cargo.lock_에 기록할 것입니다. 워크스페이스의 모든 크레이트가 동일한 의존성을 사용하게 하는 것은 크레이트들이 항상 서로 호환됨을 의미합니다. <code>add_one</code> 크레이트에서 <code>rand</code> 크레이트를 사용할 수 있도록 <em>add_one/Cargo.toml</em> 파일의 <code>[dependencies]</code> 섹션에 <code>rand</code> 크레이트를 추가해 봅시다:</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch02-00-guessing-game-tutorial.md
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
-->
<p><span class="filename">파일명: add_one/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = "0.8.5"
</code></pre>
<p>이제 <em>add_one/src/lib.rs</em> 파일에 <code>use rand;</code>를 추가할 수 있으며, <em>add</em> 디렉토리에서 <code>cargo build</code>를 실행하여 전체 워크스페이스를 빌드하면 <code>rand</code> 크레이트를 가져와서 컴파일할 것입니다. 스코프로 가져온 <code>rand</code>를 참조하지 않았기 때문에 하나의 경고가 발생할 것입니다:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-03-workspace-with-external-dependency/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.5
   --snip--
   Compiling rand v0.8.5
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
warning: unused import: `rand`
 --&gt; add_one/src/lib.rs:1:5
  |
1 | use rand;
  |     ^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: `add_one` (lib) generated 1 warning (run `cargo fix --lib -p add_one` to apply 1 suggestion)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.95s
</code></pre>
<p>최상위 _Cargo.lock_에는 이제 <code>add_one</code>이 <code>rand</code>에 의존한다는 정보가 포함되어 있습니다. 하지만 워크스페이스 어딘가에서 <code>rand</code>를 사용하고 있더라도, 해당 크레이트의 <em>Cargo.toml</em> 파일에 <code>rand</code>를 추가하지 않는 한 워크스페이스 내의 다른 크레이트에서 <code>rand</code>를 사용할 수 없습니다. 예를 들어, <code>adder</code> 패키지의 <em>adder/src/main.rs</em> 파일에 <code>use rand;</code>를 추가하면 에러가 발생합니다:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-03-use-rand/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo build
  --snip--
   Compiling adder v0.1.0 (file:///projects/add/adder)
error[E0432]: unresolved import `rand`
 --&gt; adder/src/main.rs:2:5
  |
2 | use rand;
  |     ^^^^ no external crate `rand`
</code></pre>
<p>이를 해결하려면, <code>adder</code> 패키지의 <em>Cargo.toml</em> 파일을 수정하여 <code>rand</code>가 해당 패키지의 의존성임을 명시하세요. <code>adder</code> 패키지를 빌드하면 _Cargo.lock_의 <code>adder</code> 의존성 목록에 <code>rand</code>가 추가되지만, <code>rand</code>가 추가로 다운로드되지는 않습니다. Cargo는 호환 가능한 버전을 지정하는 한, 워크스페이스 내에서 <code>rand</code> 패키지를 사용하는 모든 패키지의 모든 크레이트가 동일한 버전을 사용하도록 보장하여 공간을 절약하고 워크스페이스 내 크레이트 간의 호환성을 보장합니다.</p>
<p>워크스페이스 내의 크레이트들이 동일한 의존성에 대해 호환되지 않는 버전을 지정하는 경우, Cargo는 각각을 해결(resolve)하겠지만, 여전히 가능한 한 적은 수의 버전을 사용하도록 시도할 것입니다.</p>
<h4 id="워크스페이스에-테스트-추가하기"><a class="header" href="#워크스페이스에-테스트-추가하기">워크스페이스에 테스트 추가하기</a></h4>
<p>또 다른 개선을 위해, <code>add_one</code> 크레이트 내에 <code>add_one::add_one</code> 함수에 대한 테스트를 추가해 봅시다:</p>
<p><span class="filename">파일명: add_one/src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(3, add_one(2));
    }
}</code></pre>
<p>이제 최상위 <em>add</em> 디렉토리에서 <code>cargo test</code>를 실행하세요. 이와 같은 구조의 워크스페이스에서 <code>cargo test</code>를 실행하면 워크스페이스 내의 모든 크레이트에 대한 테스트가 실행됩니다:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-04-workspace-with-tests/add
cargo test
copy output below; the output updating script doesn't handle subdirectories in
paths properly
-->
<pre><code class="language-console">$ cargo test
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.20s
     Running unittests src/lib.rs (target/debug/deps/add_one-f0253159197f7841)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/adder-49979ff40686fa8e)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests add_one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>출력의 첫 번째 섹션은 <code>add_one</code> 크레이트의 <code>it_works</code> 테스트가 통과했음을 보여줍니다. 다음 섹션은 <code>adder</code> 크레이트에서 테스트가 발견되지 않았음을 보여주고, 마지막 섹션은 <code>add_one</code> 크레이트에서 문서 테스트가 발견되지 않았음을 보여줍니다.</p>
<p>워크스페이스의 최상위 디렉토리에서 <code>-p</code> 플래그와 테스트하고 싶은 크레이트 이름을 지정하여 특정 크레이트에 대한 테스트만 실행할 수도 있습니다:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-04-workspace-with-tests/add
cargo test -p add_one
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo test -p add_one
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.00s
     Running unittests src/lib.rs (target/debug/deps/add_one-b3235fea9a156f74)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests add_one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>이 출력은 <code>cargo test</code>가 <code>add_one</code> 크레이트의 테스트만 실행하고 <code>adder</code> 크레이트의 테스트는 실행하지 않았음을 보여줍니다.</p>
<p>워크스페이스의 크레이트들을 <a href="https://crates.io/">crates.io</a>에 게시하려면, 워크스페이스 내의 각 크레이트를 별도로 게시해야 합니다. <code>cargo test</code>와 마찬가지로, <code>-p</code> 플래그와 게시하려는 크레이트의 이름을 지정하여 워크스페이스의 특정 크레이트를 게시할 수 있습니다.</p>
<p>추가 연습을 위해, <code>add_one</code> 크레이트와 유사한 방식으로 <code>add_two</code> 크레이트를 이 워크스페이스에 추가해 보세요!</p>
<p>프로젝트가 커짐에 따라 워크스페이스를 사용하는 것을 고려해 보세요: 거대한 코드 덩어리 하나보다 작고 개별적인 컴포넌트들을 이해하는 것이 더 쉽습니다. 또한, 크레이트들이 자주 동시에 변경된다면 워크스페이스 내에 크레이트들을 유지하는 것이 크레이트 간의 조율을 더 쉽게 만들어줄 수 있습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- Old link, do not remove -->
<p><a id="installing-binaries-from-cratesio-with-cargo-install"></a></p>
<h2 id="cargo-install을-사용하여-바이너리-설치하기"><a class="header" href="#cargo-install을-사용하여-바이너리-설치하기"><code>cargo install</code>을 사용하여 바이너리 설치하기</a></h2>
<p><code>cargo install</code> 명령을 사용하면 바이너리 크레이트를 로컬에 설치하고 사용할 수 있습니다. 이는 시스템 패키지를 대체하기 위한 것이 아니라, 다른 사람들이 <a href="https://crates.io/">crates.io</a><!-- ignore -->에 공유한 도구들을 러스트 개발자들이 편리하게 설치할 수 있도록 하기 위한 것입니다. 바이너리 타겟이 있는 패키지만 설치할 수 있다는 점에 유의하세요. _바이너리 타겟_은 크레이트에 <em>src/main.rs</em> 파일이 있거나 바이너리로 지정된 다른 파일이 있을 때 생성되는 실행 가능한 프로그램입니다. 반대로 라이브러리 타겟은 그 자체로는 실행할 수 없지만 다른 프로그램에 포함시키기에 적합합니다. 보통 크레이트의 <em>README</em> 파일에는 해당 크레이트가 라이브러리인지, 바이너리 타겟이 있는지, 아니면 둘 다인지에 대한 정보가 들어있습니다.</p>
<p><code>cargo install</code>로 설치된 모든 바이너리는 설치 루트의 <em>bin</em> 폴더에 저장됩니다. 만약 _rustup.rs_를 사용하여 러스트를 설치했고 커스텀 설정을 하지 않았다면, 이 디렉토리는 _$HOME/.cargo/bin_이 될 것입니다. <code>cargo install</code>로 설치한 프로그램들을 실행할 수 있도록 해당 디렉토리가 <code>$PATH</code>에 포함되어 있는지 확인하세요.</p>
<p>예를 들어, 12장에서 우리는 파일을 검색하기 위한 <code>grep</code> 도구의 러스트 구현체인 <code>ripgrep</code>이 있다고 언급했습니다. <code>ripgrep</code>을 설치하려면 다음을 실행하면 됩니다:</p>
<!-- manual-regeneration
cargo install something you don't have, copy relevant output below
-->
<pre><code class="language-console">$ cargo install ripgrep
    Updating crates.io index
  Downloaded ripgrep v13.0.0
  Downloaded 1 crate (243.3 KB) in 0.88s
  Installing ripgrep v13.0.0
--snip--
   Compiling ripgrep v13.0.0
    Finished `release` profile [optimized + debuginfo] target(s) in 10.64s
  Installing ~/.cargo/bin/rg
   Installed package `ripgrep v13.0.0` (executable `rg`)
</code></pre>
<p>출력의 마지막에서 두 번째 줄은 설치된 바이너리의 위치와 이름을 보여주는데, <code>ripgrep</code>의 경우 <code>rg</code>입니다. 이전에 언급했듯이 설치 디렉토리가 <code>$PATH</code>에 있는 한, <code>rg --help</code>를 실행하여 파일을 검색하기 위한 더 빠르고 러스트다운 도구를 사용할 수 있습니다!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="커스텀-명령어로-cargo-확장하기"><a class="header" href="#커스텀-명령어로-cargo-확장하기">커스텀 명령어로 Cargo 확장하기</a></h2>
<p>Cargo는 Cargo 자체를 수정하지 않고도 새로운 서브커맨드로 확장할 수 있도록 설계되었습니다. <code>$PATH</code>에 있는 바이너리 이름이 <code>cargo-something</code>이라면, <code>cargo something</code>을 실행하여 마치 Cargo 서브커맨드인 것처럼 실행할 수 있습니다. 이러한 커스텀 명령들은 <code>cargo --list</code>를 실행할 때도 나열됩니다. <code>cargo install</code>을 사용하여 확장 도구들을 설치하고, 이를 내장 Cargo 도구처럼 실행할 수 있다는 점은 Cargo 설계의 매우 편리한 장점입니다!</p>
<h2 id="요약-13"><a class="header" href="#요약-13">요약</a></h2>
<p>Cargo와 <a href="https://crates.io/">crates.io</a><!-- ignore -->를 통해 코드를 공유하는 것은 러스트 생태계가 다양한 작업에 유용하게 쓰일 수 있도록 만드는 핵심 요소입니다. 러스트의 표준 라이브러리는 작고 안정적이지만, 크레이트는 언어 자체와는 다른 타임라인에서 쉽게 공유되고, 사용되며, 개선될 수 있습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="스마트-포인터"><a class="header" href="#스마트-포인터">스마트 포인터</a></h1>
<p>_포인터(pointer)_는 메모리 주소를 담고 있는 변수를 일컫는 일반적인 개념입니다. 이 주소는 다른 어떤 데이터를 참조하거나 “가리킵니다”. 러스트에서 가장 일반적인 종류의 포인터는 4장에서 배운 참조(reference)입니다. 참조는 <code>&amp;</code> 기호로 표시되며 가리키는 값을 대여합니다. 데이터를 참조하는 것 외에는 특별한 능력이 없으며, 오버헤드도 없습니다.</p>
<p><em>Smart pointers</em>, on the other hand, are data structures that act like a pointer but also have additional metadata and capabilities. The concept of smart pointers isn’t unique to Rust: smart pointers originated in C++ and exist in other languages as well. Rust has a variety of smart pointers defined in the standard library that provide functionality beyond that provided by references. To explore the general concept, we’ll look at a couple of different examples of smart pointers, including a <em>reference counting</em> smart pointer type. This pointer enables you to allow data to have multiple owners by keeping track of the number of owners and, when no owners remain, cleaning up the data.</p>
<p>소유권과 대여 개념이 있는 러스트에서, 참조와 스마트 포인터 사이에는 추가적인 차이점이 있습니다: 참조는 데이터를 대여하기만 하지만, 많은 경우 스마트 포인터는 가리키는 데이터를 _소유_합니다.</p>
<p>당시에는 그렇게 부르지 않았지만, 우리는 이미 이 책의 8장에서 <code>String</code>과 <code>Vec&lt;T&gt;</code>를 포함한 몇 가지 스마트 포인터를 만났습니다. 이 두 타입은 모두 일부 메모리를 소유하고 이를 조작할 수 있게 해주기 때문에 스마트 포인터로 간주됩니다. 또한 이들은 메타데이터와 추가적인 능력 또는 보장을 가지고 있습니다. 예를 들어 <code>String</code>은 용량(capacity)을 메타데이터로 저장하며, 데이터가 항상 유효한 UTF-8임을 보장하는 추가 능력을 가지고 있습니다.</p>
<p>스마트 포인터는 주로 구조체를 사용하여 구현됩니다. 일반적인 구조체와 달리, 스마트 포인터는 <code>Deref</code>와 <code>Drop</code> 트레이트를 구현합니다. <code>Deref</code> 트레이트는 스마트 포인터 구조체의 인스턴스가 참조처럼 동작하도록 하여, 참조 또는 스마트 포인터 중 어느 것과도 작동하는 코드를 작성할 수 있게 해줍니다. <code>Drop</code> 트레이트는 스마트 포인터 인스턴스가 스코프를 벗어날 때 실행되는 코드를 커스터마이징할 수 있게 해줍니다. 이번 장에서는 이 두 트레이트에 대해 논의하고, 왜 이들이 스마트 포인터에 중요한지 보여드리겠습니다.</p>
<p>스마트 포인터 패턴은 러스트에서 자주 사용되는 일반적인 디자인 패턴이므로, 이번 장에서 모든 스마트 포인터를 다루지는 않을 것입니다. 많은 라이브러리들이 자신만의 스마트 포인터를 가지고 있으며, 여러분도 직접 작성할 수 있습니다. 우리는 표준 라이브러리에서 가장 일반적인 스마트 포인터들을 다룰 것입니다:</p>
<ul>
<li>힙에 값을 할당하기 위한 <code>Box&lt;T&gt;</code></li>
<li>다중 소유권을 가능하게 하는 참조 카운팅 타입인 <code>Rc&lt;T&gt;</code></li>
<li>컴파일 타임이 아닌 런타임에 대여 규칙을 강제하는 타입인 <code>RefCell&lt;T&gt;</code>를 통해 접근하는 <code>Ref&lt;T&gt;</code>와 <code>RefMut&lt;T&gt;</code></li>
</ul>
<p>또한, 불변 타입이 내부 값을 수정할 수 있는 API를 노출하는 <em>내부 가변성(interior mutability)</em> 패턴을 다룰 것입니다. 또한 _참조 순환(reference cycles)_이 어떻게 메모리 누수를 일으킬 수 있는지와 이를 방지하는 방법에 대해서도 논의할 것입니다.</p>
<p>시작해 봅시다!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="boxt를-사용하여-힙의-데이터-가리키기"><a class="header" href="#boxt를-사용하여-힙의-데이터-가리키기"><code>Box&lt;T&gt;</code>를 사용하여 힙의 데이터 가리키기</a></h2>
<p>가장 단순한 스마트 포인터는 _박스(box)_이며, 그 타입은 <code>Box&lt;T&gt;</code>로 작성됩니다. 박스는 데이터를 스택이 아닌 힙에 저장할 수 있게 해줍니다. 스택에 남는 것은 힙 데이터를 가리키는 포인터입니다. 스택과 힙의 차이점을 복습하려면 4장을 참조하세요.</p>
<p>박스는 데이터를 스택 대신 힙에 저장한다는 점 외에는 성능 오버헤드가 없습니다. 하지만 추가적인 기능도 많지 않습니다. 박스는 주로 다음과 같은 상황에서 사용하게 될 것입니다:</p>
<ul>
<li>컴파일 타임에 크기를 알 수 없는 타입을 가지고 있고, 정확한 크기를 요구하는 맥락에서 그 타입의 값을 사용하고 싶을 때</li>
<li>많은 양의 데이터를 가지고 있고 소유권을 이전하고 싶지만, 그 과정에서 데이터가 복사되지 않도록 보장하고 싶을 때</li>
<li>어떤 값을 소유하고 싶고, 그 값이 특정 타입이기보다는 특정 트레이트를 구현하는 타입이라는 점만 중요할 때</li>
</ul>
<p>첫 번째 상황은 <a href="ch15-01-box.html#enabling-recursive-types-with-boxes">“박스를 사용하여 재귀적 타입 가능하게 하기”</a><!-- ignore --> 섹션에서 보여드리겠습니다. 두 번째 경우, 많은 양의 데이터의 소유권을 이전하는 것은 데이터가 스택에서 복사되기 때문에 오랜 시간이 걸릴 수 있습니다. 이러한 상황에서 성능을 향상시키기 위해, 많은 양의 데이터를 박스에 넣어 힙에 저장할 수 있습니다. 그러면 스택에서는 오직 적은 양의 포인터 데이터만 복사되고, 참조하는 데이터는 힙의 한 자리에 머물게 됩니다. 세 번째 경우는 _트레이트 객체(trait object)_라고 알려져 있으며, 18장에서 <a href="ch18-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">“다른 타입의 값을 허용하는 트레이트 객체 사용하기”</a><!-- ignore -->라는 제목으로 한 섹션 전체를 할애하여 다룹니다. 따라서 여기서 배우는 내용을 18장에서 다시 적용하게 될 것입니다!</p>
<h3 id="boxt를-사용하여-힙에-데이터-저장하기"><a class="header" href="#boxt를-사용하여-힙에-데이터-저장하기"><code>Box&lt;T&gt;</code>를 사용하여 힙에 데이터 저장하기</a></h3>
<p><code>Box&lt;T&gt;</code>의 힙 저장소 사용 사례를 논의하기 전에, 문법과 <code>Box&lt;T&gt;</code> 내에 저장된 값과 상호작용하는 방법을 다루겠습니다.</p>
<p>목록 15-1은 박스를 사용하여 힙에 <code>i32</code> 값을 저장하는 방법을 보여줍니다:</p>
<Listing number="15-1" file-name="src/main.rs" caption="Storing an `i32` value on the heap using a box">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let b = Box::new(5);
    println!("b = {b}");
}</code></pre></pre>
</Listing>
<p>변수 <code>b</code>를 힙에 할당된 값 <code>5</code>를 가리키는 <code>Box</code> 값을 갖도록 정의합니다. 이 프로그램은 <code>b = 5</code>를 출력할 것입니다. 이 경우, 데이터가 스택에 있을 때와 유사한 방식으로 박스 내의 데이터에 접근할 수 있습니다. 다른 소유된 값과 마찬가지로, <code>main</code>의 끝에서 <code>b</code>가 스코프를 벗어나면 박스는 할당 해제됩니다. 할당 해제는 박스 자체(스택에 저장됨)와 박스가 가리키는 데이터(힙에 저장됨) 모두에 대해 일어납니다.</p>
<p>단일 값을 힙에 두는 것은 그다지 유용하지 않으므로, 박스를 이런 식으로 단독으로 사용하는 일은 많지 않을 것입니다. 단일 <code>i32</code>와 같은 값들은 기본적으로 스택에 저장되며, 대다수의 상황에서 그것이 더 적절합니다. 이제 박스가 없다면 허용되지 않았을 타입들을 박스를 통해 정의할 수 있는 경우를 살펴보겠습니다.</p>
<h3 id="박스로-재귀적-타입-가능하게-하기"><a class="header" href="#박스로-재귀적-타입-가능하게-하기">박스로 재귀적 타입 가능하게 하기</a></h3>
<p>_재귀적 타입(recursive type)_의 값은 자신을 구성하는 일부로 동일한 타입의 또 다른 값을 가질 수 있습니다. 재귀적 타입은 컴파일 타임에 러스트가 타입이 얼마나 많은 공간을 차지하는지 알아야 하기 때문에 문제가 됩니다. 하지만 재귀적 타입의 값 중첩은 이론적으로 무한히 계속될 수 있으므로, 러스트는 해당 값에 필요한 공간이 얼마나 되는지 알 수 없습니다. 박스는 고정된 크기를 가지므로, 재귀적 타입 정의 내에 박스를 삽입함으로써 재귀적 타입을 가능하게 할 수 있습니다.</p>
<p>재귀적 타입의 예로 _콘스 리스트(cons list)_를 살펴보겠습니다. 이는 함수형 프로그래밍 언어에서 흔히 발견되는 데이터 타입입니다. 우리가 정의할 콘스 리스트 타입은 재귀를 제외하면 단순합니다. 따라서 우리가 다룰 예제의 개념들은 재귀적 타입과 관련된 더 복잡한 상황에 처했을 때 유용하게 쓰일 것입니다.</p>
<h4 id="콘스-리스트에-대한-추가-정보"><a class="header" href="#콘스-리스트에-대한-추가-정보">콘스 리스트에 대한 추가 정보</a></h4>
<p>_콘스 리스트_는 리스프(Lisp) 프로그래밍 언어와 그 방언들로부터 유래된 데이터 구조로 중첩된 쌍(pair)으로 이루어져 있으며, 링크드 리스트(linked list)의 리스프 버전입니다. 그 이름은 리스프에서 두 개의 인자를 사용하여 새로운 쌍을 생성하는 <code>cons</code> 함수(“construct function”의 줄임말)에서 유래했습니다. 값 하나와 또 다른 쌍으로 구성된 쌍에 대해 <code>cons</code>를 호출함으로써, 재귀적인 쌍들로 구성된 콘스 리스트를 만들 수 있습니다.</p>
<p>예를 들어, 리스트 1, 2, 3을 포함하고 각 쌍을 괄호로 묶은 콘스 리스트의 의사코드(pseudocode) 표현은 다음과 같습니다:</p>
<pre><code class="language-text">(1, (2, (3, Nil)))
</code></pre>
<p>콘스 리스트의 각 항목은 현재 항목의 값과 다음 항목이라는 두 개의 요소를 포함합니다. 리스트의 마지막 항목은 다음 항목 없이 <code>Nil</code>이라고 불리는 값만 포함합니다. 콘스 리스트는 <code>cons</code> 함수를 재귀적으로 호출함으로써 만들어집니다. 재귀의 기저 사례(base case)를 나타내는 표준적인 이름은 <code>Nil</code>입니다. 이는 6장에서 논의했던 무효하거나 부재하는 값을 의미하는 “null”이나 “nil” 개념과는 다릅니다.</p>
<p>콘스 리스트는 러스트에서 흔히 사용되는 데이터 구조가 아닙니다. 러스트에서 항목 목록이 필요할 때는 대부분의 경우 <code>Vec&lt;T&gt;</code>가 더 나은 선택입니다. 다른 더 복잡한 재귀적 데이터 타입들은 다양한 상황에서 유용하지만, 이번 장에서 콘스 리스트로 시작함으로써 큰 혼란 없이 박스가 어떻게 재귀적 데이터 타입을 정의할 수 있게 해주는지 탐구해 볼 수 있습니다.</p>
<p>목록 15-2는 콘스 리스트를 위한 열거형 정의를 담고 있습니다. 이 코드는 <code>List</code> 타입의 크기를 알 수 없기 때문에 아직 컴파일되지 않는데, 그 이유를 곧 보여드리겠습니다.</p>
<Listing number="15-2" file-name="src/main.rs" caption="The first attempt at defining an enum to represent a cons list data structure of `i32` values">
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, List),
    Nil,
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
</Listing>
<blockquote>
<p>참고: 이 예제에서는 <code>i32</code> 값만 담는 콘스 리스트를 구현하고 있습니다. 10장에서 논의한 것처럼 제네릭을 사용하여 어떤 타입의 값도 저장할 수 있는 콘스 리스트 타입을 정의할 수도 있었습니다.</p>
</blockquote>
<p><code>List</code> 타입을 사용하여 리스트 <code>1, 2, 3</code>을 저장하면 목록 15-3의 코드와 같은 모습이 됩니다:</p>
<Listing number="15-3" file-name="src/main.rs" caption="Using the `List` enum to store the list `1, 2, 3`">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, List),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span>use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}</code></pre>
</Listing>
<p>첫 번째 <code>Cons</code> 값은 <code>1</code>과 또 다른 <code>List</code> 값을 가집니다. 이 <code>List</code> 값은 <code>2</code>와 또 다른 <code>List</code> 값을 가진 또 다른 <code>Cons</code> 값입니다. 이 <code>List</code> 값은 <code>3</code>과 <code>List</code> 값을 가진 하나 더 있는 <code>Cons</code> 값이며, 이 <code>List</code> 값은 마침내 리스트의 끝을 알리는 비재귀적 변종인 <code>Nil</code>입니다.</p>
<p>목록 15-3의 코드를 컴파일하려고 시도하면, 목록 15-4와 같은 에러를 얻게 됩니다:</p>
<Listing number="15-4" file-name="output.txt" caption="The error we get when attempting to define a recursive enum">
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0072]: recursive type `List` has infinite size
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
2 |     Cons(i32, List),
  |               ---- recursive without indirection
  |
help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to break the cycle
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +

error[E0391]: cycle detected when computing when `List` needs drop
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
  |
  = note: ...which immediately requires computing when `List` needs drop again
  = note: cycle used when computing whether `List` needs drop
  = note: see https://rustc-dev-guide.rust-lang.org/overview.html#queries and https://rustc-dev-guide.rust-lang.org/query.html for more information

Some errors have detailed explanations: E0072, E0391.
For more information about an error, try `rustc --explain E0072`.
error: could not compile `cons-list` (bin "cons-list") due to 2 previous errors
</code></pre>
</Listing>
<p>이 에러는 이 타입이 “무한한 크기를 가짐”을 보여줍니다. 그 이유는 <code>List</code>를 재귀적인 변종(variant)으로 정의했기 때문입니다: 즉, 자기 자신의 값을 직접 보유합니다. 그 결과, 러스트는 <code>List</code> 값을 저장하는 데 얼마나 많은 공간이 필요한지 알아낼 수 없습니다. 왜 이런 에러가 발생하는지 분석해 봅시다. 먼저, 러스트가 비재귀적 타입의 값을 저장하는 데 필요한 공간을 어떻게 결정하는지 살펴보겠습니다.</p>
<h4 id="비재귀적-타입의-크기-계산하기"><a class="header" href="#비재귀적-타입의-크기-계산하기">비재귀적 타입의 크기 계산하기</a></h4>
<p>6장에서 열거형 정의를 논의할 때 목록 6-2에서 정의했던 <code>Message</code> 열거형을 떠올려 보세요:</p>
<pre><pre class="playground"><code class="language-rust edition2021">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><code>Message</code> 값에 대해 얼마나 많은 공간을 할당할지 결정하기 위해, 러스트는 각 변종들을 훑어보며 어떤 변종이 가장 많은 공간을 필요로 하는지 확인합니다. 러스트는 <code>Message::Quit</code>이 공간을 전혀 필요로 하지 않고, <code>Message::Move</code>는 두 개의 <code>i32</code> 값을 저장하기에 충분한 공간이 필요하다는 것 등을 확인합니다. 단 하나의 변종만 사용될 것이기 때문에, <code>Message</code> 값이 필요로 하는 최대 공간은 가장 큰 변종을 저장하는 데 필요한 공간입니다.</p>
<p>이와 대조적으로 러스트가 목록 15-2의 <code>List</code> 열거형과 같은 재귀적 타입에 필요한 공간을 결정하려고 할 때 어떤 일이 일어나는지 봅시다. 컴파일러는 <code>i32</code> 타입의 값과 <code>List</code> 타입의 값을 가지는 <code>Cons</code> 변종을 살펴보는 것으로 시작합니다. 따라서 <code>Cons</code>는 <code>i32</code>의 크기에 <code>List</code>의 크기를 더한 만큼의 공간이 필요합니다. <code>List</code> 타입이 얼마나 많은 메모리를 필요로 하는지 알아내기 위해, 컴파일러는 <code>Cons</code> 변종부터 시작하여 변종들을 살펴봅니다. <code>Cons</code> 변종은 <code>i32</code> 값과 <code>List</code> 값을 가지고 있으며, 그림 15-1에서 보여주듯 이 과정은 무한히 계속됩니다.</p>
<img alt="An infinite Cons list" src="img/trpl15-01.svg" class="center" style="width: 50%;" />
<p><span class="caption">그림 15-1: 무한한 <code>Cons</code> 변종들로 구성된 무한한 <code>List</code></span></p>
<h4 id="박스를-사용하여-크기를-알-수-있는-재귀적-타입-만들기"><a class="header" href="#박스를-사용하여-크기를-알-수-있는-재귀적-타입-만들기">박스를 사용하여 크기를 알 수 있는 재귀적 타입 만들기</a></h4>
<p>러스트는 재귀적으로 정의된 타입에 대해 얼마나 많은 공간을 할당해야 할지 알아낼 수 없기 때문에, 컴파일러는 다음과 같은 유용한 제안과 함께 에러를 발생시킵니다:</p>
<!-- manual-regeneration
after doing automatic regeneration, look at listings/ch15-smart-pointers/listing-15-03/output.txt and copy the relevant line
-->
<pre><code class="language-text">help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to break the cycle
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +
</code></pre>
<p>이 제안에서 “간접(indirection)”이라는 말은 값을 직접 저장하는 대신, 값에 대한 포인터를 저장함으로써 값을 간접적으로 저장하도록 데이터 구조를 바꾸어야 함을 의미합니다.</p>
<p><code>Box&lt;T&gt;</code>는 포인터이기 때문에, 러스트는 항상 <code>Box&lt;T&gt;</code>가 얼마나 많은 공간을 필요로 하는지 알고 있습니다: 포인터의 크기는 가리키는 데이터의 양에 따라 변하지 않습니다. 이는 <code>Cons</code> 변종 내부에 다른 <code>List</code> 값을 직접 넣는 대신 <code>Box&lt;T&gt;</code>를 넣을 수 있음을 의미합니다. <code>Box&lt;T&gt;</code>는 <code>Cons</code> 변종 내부가 아닌 힙에 위치할 다음 <code>List</code> 값을 가리키게 될 것입니다. 개념적으로는 여전히 리스트가 다른 리스트를 보유하는 방식으로 만들어진 리스트이지만, 이제 이 구현은 항목을 서로의 내부에 넣는 것이 아니라 서로 옆에 나열하는 것에 더 가깝습니다.</p>
<p>목록 15-2의 <code>List</code> 열거형 정의와 목록 15-3의 <code>List</code> 사용법을 목록 15-5의 코드로 변경할 수 있으며, 이 코드는 컴파일됩니다:</p>
<Listing number="15-5" file-name="src/main.rs" caption="Definition of `List` that uses `Box<T>` in order to have a known size">
<pre><pre class="playground"><code class="language-rust edition2021">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}</code></pre></pre>
</Listing>
<p><code>Cons</code> 변종은 <code>i32</code>의 크기에 박스의 포인터 데이터를 저장할 공간을 더한 만큼이 필요합니다. <code>Nil</code> 변종은 아무런 값도 저장하지 않으므로, <code>Cons</code> 변종보다 적은 공간을 필요로 합니다. 이제 우리는 어떤 <code>List</code> 값이라도 <code>i32</code>의 크기에 박스의 포인터 데이터 크기를 더한 만큼의 공간을 차지한다는 것을 알고 있습니다. 박스를 사용함으로써 무한한 재귀 체인을 끊었으며, 덕분에 컴파일러는 <code>List</code> 값을 저장하는 데 필요한 크기를 알아낼 수 있습니다. 그림 15-2는 현재의 <code>Cons</code> 변종이 어떤 모습인지 보여줍니다.</p>
<img alt="A finite Cons list" src="img/trpl15-02.svg" class="center" />
<p><span class="caption">그림 15-2: <code>Cons</code>가 <code>Box</code>를 가지고 있어 크기가 무한하지 않은 <code>List</code></span></p>
<p>박스는 오직 간접 지정(indirection)과 힙 할당만을 제공합니다. 다른 스마트 포인터 타입들에서 보게 될 다른 특별한 능력은 없습니다. 또한 이러한 특별한 능력이 초래하는 성능 오버헤드도 없으므로, 콘스 리스트와 같이 간접 지정만이 유일하게 필요한 기능인 타입에서 유용할 수 있습니다. 18장에서도 박스의 더 많은 사용 사례들을 살펴볼 것입니다.</p>
<p><code>Box&lt;T&gt;</code> 타입은 <code>Deref</code> 트레이트를 구현하기 때문에 스마트 포인터입니다. <code>Deref</code> 트레이트는 <code>Box&lt;T&gt;</code> 값이 참조처럼 다뤄질 수 있게 해줍니다. 박스 값이 스코프를 벗어나면, <code>Drop</code> 트레이트 구현 덕분에 박스가 가리키는 힙 데이터도 함께 정리됩니다. 이 두 트레이트는 이번 장의 나머지 부분에서 다룰 다른 스마트 포인터 타입들이 제공하는 기능에 있어 훨씬 더 중요합니다. 이 두 트레이트에 대해 더 자세히 살펴보겠습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="deref-트레이트로-스마트-포인터를-일반-참조처럼-다루기"><a class="header" href="#deref-트레이트로-스마트-포인터를-일반-참조처럼-다루기"><code>Deref</code> 트레이트로 스마트 포인터를 일반 참조처럼 다루기</a></h2>
<p><code>Deref</code> 트레이트를 구현하면 <em>역참조 연산자(dereference operator)</em> <code>*</code>(곱셈이나 글로브(glob) 연산자와 혼동하지 마세요)의 동작을 커스터마이징할 수 있습니다. 스마트 포인터를 일반 참조처럼 다룰 수 있도록 <code>Deref</code>를 구현함으로써, 참조에 대해 작동하는 코드를 작성하고 이를 스마트 포인터와도 함께 사용할 수 있습니다.</p>
<p>먼저 역참조 연산자가 일반 참조와 어떻게 작동하는지 살펴보겠습니다. 그런 다음 <code>Box&lt;T&gt;</code>처럼 작동하는 커스텀 타입을 정의해 보고, 왜 역참조 연산자가 우리가 새로 정의한 타입에서는 참조처럼 작동하지 않는지 확인해 보겠습니다. <code>Deref</code> 트레이트를 구현하는 것이 어떻게 스마트 포인터가 참조와 유사한 방식으로 작동할 수 있게 하는지 알아볼 것입니다. 마지막으로 러스트의 <em>역참조 강제(deref coercion)</em> 기능과, 이 기능이 어떻게 참조나 스마트 포인터 모두와 함께 작동할 수 있게 해주는지 살펴보겠습니다.</p>
<blockquote>
<p>참고: 우리가 만들려는 <code>MyBox&lt;T&gt;</code> 타입과 실제 <code>Box&lt;T&gt;</code> 사이에는 한 가지 큰 차이점이 있습니다: 우리의 버전은 데이터를 힙에 저장하지 않을 것입니다. 이 예제는 <code>Deref</code>에 집중하고 있으므로, 데이터가 실제로 어디에 저장되는지는 포인터와 같은 동작보다 덜 중요합니다.</p>
</blockquote>
<!-- Old link, do not remove -->
<p><a id="following-the-pointer-to-the-value-with-the-dereference-operator"></a></p>
<h3 id="포인터를-따라-값에-접근하기"><a class="header" href="#포인터를-따라-값에-접근하기">포인터를 따라 값에 접근하기</a></h3>
<p>일반 참조는 포인터의 일종이며, 포인터를 생각하는 한 가지 방법은 다른 어딘가에 저장된 값을 가리키는 화살표로 생각하는 것입니다. 목록 15-6에서는 <code>i32</code> 값에 대한 참조를 생성한 다음, 역참조 연산자를 사용하여 참조를 따라 값에 접근합니다:</p>
<Listing number="15-6" file-name="src/main.rs" caption="Using the dereference operator to follow a reference to an `i32` value">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre></pre>
</Listing>
<p>변수 <code>x</code>는 <code>i32</code> 값 <code>5</code>를 보유합니다. <code>y</code>를 <code>x</code>에 대한 참조로 설정합니다. <code>x</code>가 <code>5</code>와 같음을 단언(assert)할 수 있습니다. 하지만 <code>y</code>에 들어있는 값에 대해 단언하고 싶다면, 컴파일러가 실제 값을 비교할 수 있도록 참조가 가리키는 값을 따라가는 <code>*y</code>를 사용해야 합니다(그래서 _역참조_라고 합니다). <code>y</code>를 역참조하고 나면, <code>y</code>가 가리키는 정수 값에 접근할 수 있게 되며 이를 <code>5</code>와 비교할 수 있습니다.</p>
<p>만약 대신 <code>assert_eq!(5, y);</code>라고 작성하려고 한다면, 다음과 같은 컴파일 에러가 발생할 것입니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0277]: can't compare `{integer}` with `&amp;{integer}`
 --&gt; src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^ no implementation for `{integer} == &amp;{integer}`
  |
  = help: the trait `PartialEq&lt;&amp;{integer}&gt;` is not implemented for `{integer}`
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider dereferencing here
 --&gt; file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/core/src/macros/mod.rs:46:35
  |
46|                 if !(*left_val == **right_val) {
  |                                   +

For more information about this error, try `rustc --explain E0277`.
error: could not compile `deref-example` (bin "deref-example") due to 1 previous error
</code></pre>
<p>숫자와 숫자에 대한 참조를 비교하는 것은 서로 다른 타입이기 때문에 허용되지 않습니다. 참조가 가리키는 값을 따라가려면 역참조 연산자를 사용해야 합니다.</p>
<h3 id="boxt를-참조처럼-사용하기"><a class="header" href="#boxt를-참조처럼-사용하기"><code>Box&lt;T&gt;</code>를 참조처럼 사용하기</a></h3>
<p>목록 15-6의 코드를 참조 대신 <code>Box&lt;T&gt;</code>를 사용하도록 다시 작성할 수 있습니다. 목록 15-7에서 <code>Box&lt;T&gt;</code>에 사용된 역참조 연산자는 목록 15-6에서 참조에 사용된 역참조 연산자와 동일한 방식으로 작동합니다:</p>
<Listing number="15-7" file-name="src/main.rs" caption="Using the dereference operator on a `Box<i32>`">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre></pre>
</Listing>
<p>목록 15-7과 목록 15-6의 주요 차이점은 여기서 <code>y</code>가 <code>x</code>의 값을 가리키는 참조가 아니라, <code>x</code>의 복사본을 가리키는 <code>Box&lt;T&gt;</code> 인스턴스라는 점입니다. 마지막 단언(assertion)에서 우리는 <code>y</code>가 참조였을 때와 같은 방식으로 역참조 연산자를 사용하여 <code>Box&lt;T&gt;</code>의 포인터를 따라갈 수 있습니다. 다음으로는 우리만의 타입을 정의해 봄으로써, 역참조 연산자를 사용할 수 있게 해주는 <code>Box&lt;T&gt;</code>의 특별한 점이 무엇인지 알아보겠습니다.</p>
<h3 id="우리만의-스마트-포인터-정의하기"><a class="header" href="#우리만의-스마트-포인터-정의하기">우리만의 스마트 포인터 정의하기</a></h3>
<p>표준 라이브러리에서 제공하는 <code>Box&lt;T&gt;</code> 타입과 유사한 스마트 포인터를 직접 만들어 봄으로써, 스마트 포인터가 기본적으로 참조와 어떻게 다르게 행동하는지 경험해 봅시다. 그런 다음 역참조 연산자를 사용할 수 있는 능력을 추가하는 방법을 알아보겠습니다.</p>
<p><code>Box&lt;T&gt;</code> 타입은 결과적으로 하나의 요소를 가진 튜플 구조체로 정의되어 있으므로, 목록 15-8도 같은 방식으로 <code>MyBox&lt;T&gt;</code> 타입을 정의합니다. 또한 <code>Box&lt;T&gt;</code>에 정의된 <code>new</code> 함수와 일치하도록 <code>new</code> 함수도 정의할 것입니다.</p>
<Listing number="15-8" file-name="src/main.rs" caption="Defining a `MyBox<T>` type">
<pre><pre class="playground"><code class="language-rust edition2021">struct MyBox&lt;T&gt;(T);

impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox(x)
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p><code>MyBox</code>라는 이름의 구조체를 정의하고 제네릭 매개변수 <code>T</code>를 선언합니다. 우리 타입이 어떤 타입의 값도 보유할 수 있기를 원하기 때문입니다. <code>MyBox</code> 타입은 <code>T</code> 타입의 요소 하나를 가진 튜플 구조체입니다. <code>MyBox::new</code> 함수는 <code>T</code> 타입의 매개변수 하나를 받아 전달된 값을 보유하는 <code>MyBox</code> 인스턴스를 반환합니다.</p>
<p>Let’s try adding the <code>main</code> function in Listing 15-7 to Listing 15-8 and changing it to use the <code>MyBox&lt;T&gt;</code> type we’ve defined instead of <code>Box&lt;T&gt;</code>. The code in Listing 15-9 won’t compile because Rust doesn’t know how to dereference <code>MyBox</code>.</p>
<Listing number="15-9" file-name="src/main.rs" caption="Attempting to use `MyBox<T>` in the same way we used references and `Box<T>`">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre>
</Listing>
<p>Here’s the resulting compilation error:</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0614]: type `MyBox&lt;{integer}&gt;` cannot be dereferenced
  --&gt; src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^

For more information about this error, try `rustc --explain E0614`.
error: could not compile `deref-example` (bin "deref-example") due to 1 previous error
</code></pre>
<p><code>MyBox&lt;T&gt;</code> 타입은 우리가 아직 그 능력을 구현하지 않았기 때문에 역참조될 수 없습니다. <code>*</code> 연산자로 역참조가 가능하게 하려면, <code>Deref</code> 트레이트를 구현해야 합니다.</p>
<!-- Old link, do not remove -->
<p><a id="treating-a-type-like-a-reference-by-implementing-the-deref-trait"></a></p>
<h3 id="deref-트레이트-구현하기"><a class="header" href="#deref-트레이트-구현하기"><code>Deref</code> 트레이트 구현하기</a></h3>
<p>10장의 <a href="ch10-02-traits.html#implementing-a-trait-on-a-type">“타입에 트레이트 구현하기”</a><!-- ignore --> 섹션에서 논의했듯이, 트레이트를 구현하려면 트레이트가 요구하는 메서드들의 구현을 제공해야 합니다. 표준 라이브러리에서 제공하는 <code>Deref</code> 트레이트는 <code>self</code>를 대여하고 내부 데이터에 대한 참조를 반환하는 <code>deref</code>라는 메서드 하나를 구현할 것을 요구합니다. 목록 15-10은 <code>MyBox&lt;T&gt;</code> 정의에 추가할 <code>Deref</code> 구현을 담고 있습니다:</p>
<Listing number="15-10" file-name="src/main.rs" caption="Implementing `Deref` on `MyBox<T>`">
<pre><pre class="playground"><code class="language-rust edition2021">use std::ops::Deref;

impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}
<span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let x = 5;
</span><span class="boring">    let y = MyBox::new(x);
</span><span class="boring">
</span><span class="boring">    assert_eq!(5, x);
</span><span class="boring">    assert_eq!(5, *y);
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p><code>type Target = T;</code> 문법은 <code>Deref</code> 트레이트에서 사용할 연관 타입(associated type)을 정의합니다. 연관 타입은 제네릭 매개변수를 선언하는 약간 다른 방법이지만, 지금은 걱정하실 필요 없습니다. 20장에서 더 자세히 다룰 것입니다.</p>
<p><code>deref</code> 메서드의 본문을 <code>&amp;self.0</code>으로 채우면, <code>deref</code>는 <code>*</code> 연산자를 통해 접근하고자 하는 값에 대한 참조를 반환합니다. 5장의 <a href="ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types">“명명된 필드가 없는 튜플 구조체를 사용하여 다른 타입 만들기”</a><!-- ignore --> 섹션에서 다루었듯이 <code>.0</code>은 튜플 구조체의 첫 번째 값에 접근합니다. 이제 <code>MyBox&lt;T&gt;</code> 값에 대해 <code>*</code>를 호출하는 목록 15-9의 <code>main</code> 함수가 컴파일되고 단언문들이 통과합니다!</p>
<p><code>Deref</code> 트레이트가 없다면 컴파일러는 <code>&amp;</code> 참조만 역참조할 수 있습니다. <code>deref</code> 메서드는 컴파일러에게 <code>Deref</code>를 구현하는 어떤 타입의 값이라도 받아서, <code>deref</code> 메서드를 호출하여 역참조하는 방법을 알고 있는 <code>&amp;</code> 참조를 얻을 수 있는 능력을 부여합니다.</p>
<p>목록 15-9에서 <code>*y</code>를 입력했을 때, 배후에서 러스트는 실제로 다음 코드를 실행했습니다:</p>
<pre><code class="language-rust ignore">*(y.deref())</code></pre>
<p>러스트는 <code>*</code> 연산자를 <code>deref</code> 메서드 호출과 그에 따른 평범한 역참조로 대체하므로, 우리는 <code>deref</code> 메서드를 호출해야 할지 말지 고민할 필요가 없습니다. 이러한 러스트의 기능 덕분에 우리는 일반 참조를 가지고 있든 <code>Deref</code>를 구현하는 타입을 가지고 있든 동일하게 작동하는 코드를 작성할 수 있습니다.</p>
<p><code>deref</code> 메서드가 값 자체가 아닌 값에 대한 참조를 반환하는 이유, 그리고 <code>*(y.deref())</code>에서 괄호 바깥의 평범한 역참조가 여전히 필요한 이유는 소유권 시스템 때문입니다. 만약 <code>deref</code> 메서드가 값에 대한 참조 대신 값을 직접 반환했다면, 그 값은 <code>self</code> 밖으로 이동(move)되었을 것입니다. 이 경우나 역참조 연산자를 사용하는 대부분의 경우에서, 우리는 <code>MyBox&lt;T&gt;</code> 내부의 값에 대한 소유권을 가져오고 싶지 않습니다.</p>
<p>코드에서 <code>*</code>를 사용할 때마다, <code>*</code> 연산자가 <code>deref</code> 메서드 호출과 그 뒤의 단 한 번의 <code>*</code> 연산자 호출로 대체된다는 점에 유의하세요. <code>*</code> 연산자의 대체가 무한히 재귀적으로 일어나지 않기 때문에, 결과적으로 <code>i32</code> 타입의 데이터를 얻게 되며, 이는 목록 15-9의 <code>assert_eq!</code>에 있는 <code>5</code>와 일치합니다.</p>
<h3 id="함수와-메서드에-일어나는-암묵적-역참조-강제"><a class="header" href="#함수와-메서드에-일어나는-암묵적-역참조-강제">함수와 메서드에 일어나는 암묵적 역참조 강제</a></h3>
<p>_역참조 강제(Deref coercion)_는 <code>Deref</code> 트레이트를 구현하는 타입에 대한 참조를 다른 타입에 대한 참조로 변환해 줍니다. 예를 들어, 역참조 강제는 <code>&amp;String</code>을 <code>&amp;str</code>로 변환할 수 있는데, 이는 <code>String</code>이 <code>&amp;str</code>을 반환하도록 <code>Deref</code> 트레이트를 구현하고 있기 때문입니다. 역참조 강제는 러스트가 함수와 메서드의 인자에 대해 수행하는 편의 기능이며, <code>Deref</code> 트레이트를 구현한 타입에 대해서만 작동합니다. 이는 우리가 특정 타입의 값에 대한 참조를 함수나 메서드의 인자로 전달할 때, 그 인자의 타입이 함수나 메서드 정의에 있는 매개변수의 타입과 일치하지 않을 경우 자동으로 발생합니다. 일련의 <code>deref</code> 메서드 호출을 통해 우리가 제공한 타입이 매개변수가 필요로 하는 타입으로 변환됩니다.</p>
<p>역참조 강제는 함수나 메서드를 호출하는 프로그래머가 <code>&amp;</code>와 <code>*</code>를 사용하여 명시적인 참조와 역참조를 많이 추가할 필요가 없도록 러스트에 추가되었습니다. 또한 역참조 강제 기능 덕분에 우리는 참조와 스마트 포인터 모두에 대해 작동할 수 있는 코드를 더 많이 작성할 수 있습니다.</p>
<p>역참조 강제가 실제로 작동하는 것을 보기 위해, 목록 15-8에서 정의한 <code>MyBox&lt;T&gt;</code> 타입과 목록 15-10에서 추가한 <code>Deref</code> 구현을 사용해 봅시다. 목록 15-11은 문자열 슬라이스를 매개변수로 받는 함수의 정의를 보여줍니다:</p>
<Listing number="15-11" file-name="src/main.rs" caption="A `hello` function that has the parameter `name` of type `&str`">
<pre><pre class="playground"><code class="language-rust edition2021">fn hello(name: &amp;str) {
    println!("안녕하세요, {name}!");
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p>우리는 <code>hello</code> 함수를 <code>hello("Rust");</code>와 같이 문자열 슬라이스를 인자로 하여 호출할 수 있습니다. 역참조 강제 덕분에 목록 15-12와 같이 <code>MyBox&lt;String&gt;</code> 타입의 값에 대한 참조로도 <code>hello</code>를 호출하는 것이 가능합니다:</p>
<Listing number="15-12" file-name="src/main.rs" caption="Calling `hello` with a reference to a `MyBox<String>` value, which works because of deref coercion">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!("안녕하세요, {name}!");
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from("러스트"));
    hello(&amp;m);
}</code></pre></pre>
</Listing>
<p>여기서 우리는 <code>MyBox&lt;String&gt;</code> 값에 대한 참조인 <code>&amp;m</code>을 인자로 하여 <code>hello</code> 함수를 호출하고 있습니다. 목록 15-10에서 <code>MyBox&lt;T&gt;</code>에 대해 <code>Deref</code> 트레이트를 구현했으므로, 러스트는 <code>deref</code>를 호출하여 <code>&amp;MyBox&lt;String&gt;</code>을 <code>&amp;String</code>으로 바꿀 수 있습니다. 표준 라이브러리는 <code>String</code>에 대해 문자열 슬라이스를 반환하도록 <code>Deref</code>를 구현하고 있으며, 이는 <code>Deref</code>의 API 문서에서 확인할 수 있습니다. 러스트는 <code>deref</code>를 다시 한 번 호출하여 <code>&amp;String</code>을 <code>&amp;str</code>로 변환하고, 이는 <code>hello</code> 함수의 정의와 일치하게 됩니다.</p>
<p>만약 러스트에 역참조 강제 기능이 없었다면, <code>&amp;MyBox&lt;String&gt;</code> 타입의 값으로 <code>hello</code>를 호출하기 위해 목록 15-12의 코드 대신 목록 15-13의 코드와 같이 작성해야 했을 것입니다.</p>
<Listing number="15-13" file-name="src/main.rs" caption="The code we would have to write if Rust didn’t have deref coercion">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!("안녕하세요, {name}!");
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from("러스트"));
    hello(&amp;(*m)[..]);
}</code></pre></pre>
</Listing>
<p><code>(*m)</code>은 <code>MyBox&lt;String&gt;</code>을 <code>String</code>으로 역참조합니다. 그런 다음 <code>&amp;</code>와 <code>[..]</code>가 <code>String</code>의 전체 문자열에 해당하는 문자열 슬라이스를 가져와 <code>hello</code>의 시그니처와 일치시킵니다. 역참조 강제가 없는 이 코드는 이러한 모든 기호들이 포함되어 읽고, 쓰고, 이해하기가 더 어렵습니다. 역참조 강제는 러스트가 이러한 변환들을 우리 대신 자동으로 처리할 수 있게 해줍니다.</p>
<p>관련된 타입들에 대해 <code>Deref</code> 트레이트가 정의되어 있으면, 러스트는 해당 타입들을 분석하여 매개변수의 타입과 일치하는 참조를 얻기 위해 필요한 만큼 <code>Deref::deref</code>를 사용합니다. <code>Deref::deref</code>가 삽입되어야 하는 횟수는 컴파일 타임에 결정되므로, 역참조 강제를 활용함에 따른 런타임 페널티는 전혀 없습니다!</p>
<h3 id="역참조-강제가-가변성과-상호작용하는-방식"><a class="header" href="#역참조-강제가-가변성과-상호작용하는-방식">역참조 강제가 가변성과 상호작용하는 방식</a></h3>
<p>불변 참조에 대해 <code>*</code> 연산자를 오버라이드하기 위해 <code>Deref</code> 트레이트를 사용하는 것과 유사하게, 가변 참조에 대해 <code>*</code> 연산자를 오버라이드하려면 <code>DerefMut</code> 트레이트를 사용할 수 있습니다.</p>
<p>러스트는 다음 세 가지 경우에 타입 및 트레이트 구현을 찾아 역참조 강제를 수행합니다:</p>
<ol>
<li><code>T: Deref&lt;Target=U&gt;</code>일 때 <code>&amp;T</code>에서 <code>&amp;U</code>로</li>
<li><code>T: DerefMut&lt;Target=U&gt;</code>일 때 <code>&amp;mut T</code>에서 <code>&amp;mut U</code>로</li>
<li><code>T: Deref&lt;Target=U&gt;</code>일 때 <code>&amp;mut T</code>에서 <code>&amp;mut U</code>로</li>
</ol>
<p>처음 두 경우는 두 번째 경우가 가변성을 구현한다는 점을 제외하면 동일합니다. 첫 번째 경우는 <code>&amp;T</code>를 가지고 있고 <code>T</code>가 어떤 타입 <code>U</code>에 대해 <code>Deref</code>를 구현했다면, 자동으로 <code>&amp;U</code>를 얻을 수 있음을 명시합니다. 두 번째 경우는 가변 참조에 대해서도 동일한 역참조 강제가 일어남을 명시합니다.</p>
<p>세 번째 경우는 좀 더 까다롭습니다: 러스트는 가변 참조를 불변 참조로 강제 변환하기도 합니다. 하지만 그 반대는 _불가능_합니다: 불변 참조는 결코 가변 참조로 강제 변환되지 않습니다. 대여 규칙에 따라, 가변 참조를 가지고 있다면 그 가변 참조는 해당 데이터에 대한 유일한 참조여야 합니다(그렇지 않으면 프로그램이 컴파일되지 않습니다). 하나의 가변 참조를 하나의 불변 참조로 변환하는 것은 결코 대여 규칙을 깨뜨리지 않습니다. 불변 참조를 가변 참조로 변환하려면 초기의 불변 참조가 해당 데이터에 대한 유일한 불변 참조여야 하는데, 대여 규칙은 이를 보장하지 않습니다. 따라서 러스트는 불변 참조를 가변 참조로 변환하는 것이 가능하다는 가정을 할 수 없습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="drop-트레이트로-정리-시-코드-실행하기"><a class="header" href="#drop-트레이트로-정리-시-코드-실행하기"><code>Drop</code> 트레이트로 정리 시 코드 실행하기</a></h2>
<p>스마트 포인터 패턴에 중요한 두 번째 트레이트는 <code>Drop</code>입니다. <code>Drop</code>을 사용하면 값이 스코프를 벗어나려고 할 때 일어날 일을 커스터마이징할 수 있습니다. 어떤 타입에 대해서든 <code>Drop</code> 트레이트 구현을 제공할 수 있으며, 그 코드는 파일이나 네트워크 연결과 같은 자원을 해제하는 데 사용될 수 있습니다.</p>
<p>우리가 스마트 포인터의 맥락에서 <code>Drop</code>을 소개하는 이유는 <code>Drop</code> 트레이트의 기능이 스마트 포인터를 구현할 때 거의 항상 사용되기 때문입니다. 예를 들어, <code>Box&lt;T&gt;</code>가 드롭될 때, 박스가 가리키는 힙 공간을 할당 해제합니다.</p>
<p>일부 언어에서는 특정 타입의 인스턴스를 다 사용하고 나면 프로그래머가 직접 메모리나 자원을 해제하는 코드를 호출해야 합니다. 파일 핸들, 소켓, 또는 락(lock) 등이 그 예입니다. 만약 이를 잊어버리면 시스템에 과부하가 걸려 크래시가 발생할 수 있습니다. 러스트에서는 값이 스코프를 벗어날 때마다 특정 코드가 실행되도록 지정할 수 있으며, 컴파일러가 이 코드를 자동으로 삽입해 줍니다. 결과적으로, 특정 타입의 인스턴스 사용이 끝나는 프로그램의 모든 곳에 정리 코드를 넣으려고 주의를 기울일 필요가 없으면서도, 자원 누수는 발생하지 않습니다!</p>
<p><code>Drop</code> 트레이트를 구현함으로써 값이 스코프를 벗어날 때 실행될 코드를 지정할 수 있습니다. <code>Drop</code> 트레이트는 <code>self</code>에 대한 가변 참조를 받는 <code>drop</code>이라는 이름의 메서드 하나를 구현할 것을 요구합니다. 러스트가 언제 <code>drop</code>을 호출하는지 보기 위해, 우선 <code>println!</code> 문을 사용하여 <code>drop</code>을 구현해 봅시다.</p>
<p>목록 15-14는 인스턴스가 스코프를 벗어날 때 <code>Dropping CustomSmartPointer!</code>를 출력하는 것이 유일한 커스텀 기능인 <code>CustomSmartPointer</code> 구조체를 보여줍니다. 이를 통해 러스트가 언제 <code>drop</code> 함수를 실행하는지 확인할 수 있습니다.</p>
<Listing number="15-14" file-name="src/main.rs" caption="A `CustomSmartPointer` struct that implements the `Drop` trait where we would put our cleanup code">
<pre><pre class="playground"><code class="language-rust edition2021">struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!("`{}` 데이터를 가진 CustomSmartPointer를 드롭합니다!", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from("내 데이터"),
    };
    let d = CustomSmartPointer {
        data: String::from("다른 데이터"),
    };
    println!("CustomSmartPointer들이 생성되었습니다.");
}</code></pre></pre>
</Listing>
<p><code>Drop</code> 트레이트는 프렐루드(prelude)에 포함되어 있으므로, 별도로 스코프로 가져올 필요가 없습니다. <code>CustomSmartPointer</code>에 <code>Drop</code> 트레이트를 구현하고 <code>println!</code>을 호출하는 <code>drop</code> 메서드 구현을 제공합니다. <code>drop</code> 함수의 본문은 여러분의 타입 인스턴스가 스코프를 벗어날 때 실행하고 싶은 로직을 두는 곳입니다. 여기서는 러스트가 언제 <code>drop</code>을 호출하는지 시각적으로 보여주기 위해 텍스트를 출력하고 있습니다.</p>
<p><code>main</code>에서 두 개의 <code>CustomSmartPointer</code> 인스턴스를 생성한 다음 <code>CustomSmartPointers created</code>를 출력합니다. <code>main</code>의 끝에서 <code>CustomSmartPointer</code> 인스턴스들이 스코프를 벗어나고, 러스트는 우리가 <code>drop</code> 메서드에 넣은 코드를 호출하여 마지막 메시지를 출력할 것입니다. 우리가 <code>drop</code> 메서드를 명시적으로 호출할 필요가 없었다는 점에 주목하세요.</p>
<p>이 프로그램을 실행하면 다음과 같은 출력을 보게 될 것입니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.60s
     Running `target/debug/drop-example`
CustomSmartPointers created.
Dropping CustomSmartPointer with data `other stuff`!
Dropping CustomSmartPointer with data `my stuff`!
</code></pre>
<p>러스트는 인스턴스가 스코프를 벗어날 때 우리가 지정한 코드를 호출하면서 자동으로 <code>drop</code>을 호출했습니다. 변수들은 생성된 순서의 역순으로 드롭되므로, <code>d</code>가 <code>c</code>보다 먼저 드롭되었습니다. 이 예제의 목적은 <code>drop</code> 메서드가 어떻게 작동하는지 시각적으로 보여주는 것입니다. 보통은 출력 메시지가 아니라 여러분의 타입에 필요한 정리 코드를 지정하게 될 것입니다.</p>
<h3 id="stdmemdrop을-사용하여-값을-일찍-드롭하기"><a class="header" href="#stdmemdrop을-사용하여-값을-일찍-드롭하기"><code>std::mem::drop</code>을 사용하여 값을 일찍 드롭하기</a></h3>
<p>안타깝게도, 자동 <code>drop</code> 기능을 비활성화하는 것은 간단하지 않습니다. 보통 <code>drop</code>을 비활성화할 필요는 없습니다. <code>Drop</code> 트레이트의 핵심은 자동으로 처리된다는 점이기 때문입니다. 하지만 가끔은 값을 일찍 정리하고 싶을 때가 있을 수 있습니다. 한 가지 예로 락(lock)을 관리하는 스마트 포인터를 사용할 때입니다: 같은 스코프 내의 다른 코드가 락을 획득할 수 있도록 락을 해제하는 <code>drop</code> 메서드를 강제로 호출하고 싶을 수 있습니다. 러스트는 <code>Drop</code> 트레이트의 <code>drop</code> 메서드를 수동으로 호출하는 것을 허용하지 않습니다. 대신 스코프가 끝나기 전에 강제로 값을 드롭하고 싶다면 표준 라이브러리에서 제공하는 <code>std::mem::drop</code> 함수를 호출해야 합니다.</p>
<p>목록 15-14의 <code>main</code> 함수를 목록 15-15와 같이 수정하여 <code>Drop</code> 트레이트의 <code>drop</code> 메서드를 수동으로 호출하려고 시도하면, 컴파일 에러가 발생합니다:</p>
<Listing number="15-15" file-name="src/main.rs" caption="Attempting to call the `drop` method from the `Drop` trait manually to clean up early">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">struct CustomSmartPointer {
</span><span class="boring">    data: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for CustomSmartPointer {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!("`{}` 데이터를 가진 CustomSmartPointer를 드롭합니다!", self.data);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = CustomSmartPointer {
        data: String::from("어떤 데이터"),
    };
    println!("CustomSmartPointer가 생성되었습니다.");
    c.drop();
    println!("main이 끝나기 전에 CustomSmartPointer가 드롭되었습니다.");
}</code></pre>
</Listing>
<p>이 코드를 컴파일하려고 시도하면, 다음과 같은 에러가 발생합니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
error[E0040]: explicit use of destructor method
  --&gt; src/main.rs:16:7
   |
16 |     c.drop();
   |       ^^^^ explicit destructor calls not allowed
   |
help: consider using `drop` function
   |
16 |     drop(c);
   |     +++++ ~

For more information about this error, try `rustc --explain E0040`.
error: could not compile `drop-example` (bin "drop-example") due to 1 previous error
</code></pre>
<p>이 에러 메시지는 <code>drop</code>을 명시적으로 호출하는 것이 허용되지 않음을 알려줍니다. 에러 메시지에는 _소멸자(destructor)_라는 용어가 사용되었는데, 이는 인스턴스를 정리하는 함수를 일컫는 일반적인 프로그래밍 용어입니다. 소멸자는 인스턴스를 생성하는 _생성자(constructor)_와 유사한 개념입니다. 러스트의 <code>drop</code> 함수는 하나의 특정한 소멸자입니다.</p>
<p>러스트가 <code>drop</code>을 명시적으로 호출하지 못하게 하는 이유는 러스트가 <code>main</code>의 끝에서 해당 값에 대해 여전히 자동으로 <code>drop</code>을 호출할 것이기 때문입니다. 이로 인해 러스트가 동일한 값을 두 번 정리하려고 시도하게 되어 <em>이중 해제(double free)</em> 에러가 발생할 수 있습니다.</p>
<p>값이 스코프를 벗어날 때 <code>drop</code>이 자동으로 삽입되는 것을 막을 수 없고, <code>drop</code> 메서드를 명시적으로 호출할 수도 없습니다. 따라서 값을 일찍 정리해야 할 필요가 있다면 <code>std::mem::drop</code> 함수를 사용합니다.</p>
<p><code>std::mem::drop</code> 함수는 <code>Drop</code> 트레이트의 <code>drop</code> 메서드와 다릅니다. 강제로 드롭시키고 싶은 값을 인자로 전달하여 이 함수를 호출합니다. 이 함수는 프렐루드에 포함되어 있으므로, 목록 15-16과 같이 목록 15-15의 <code>main</code>을 수정하여 <code>drop</code> 함수를 호출할 수 있습니다:</p>
<Listing number="15-16" file-name="src/main.rs" caption="Calling `std::mem::drop` to explicitly drop a value before it goes out of scope">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct CustomSmartPointer {
</span><span class="boring">    data: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for CustomSmartPointer {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!("`{}` 데이터를 가진 CustomSmartPointer를 드롭합니다!", self.data);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = CustomSmartPointer {
        data: String::from("어떤 데이터"),
    };
    println!("CustomSmartPointer가 생성되었습니다.");
    drop(c);
    println!("main이 끝나기 전에 CustomSmartPointer가 드롭되었습니다.");
}</code></pre></pre>
</Listing>
<p>이 코드를 실행하면 다음과 같이 출력됩니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/drop-example`
CustomSmartPointer created.
Dropping CustomSmartPointer with data `some data`!
CustomSmartPointer dropped before the end of main.
</code></pre>
<p><code>Dropping CustomSmartPointer with data `some data`!</code>라는 텍스트가 <code>CustomSmartPointer created.</code>와 <code>CustomSmartPointer dropped before the end of main.</code> 사이에 출력되었으며, 이는 그 시점에서 <code>c</code>를 드롭하기 위해 <code>drop</code> 메서드 코드가 호출되었음을 보여줍니다.</p>
<p><code>Drop</code> 트레이트 구현에 지정된 코드를 다양한 방식으로 사용하여 정리를 편리하고 안전하게 만들 수 있습니다: 예를 들어, 이를 사용하여 여러분만의 메모리 할당자를 만들 수도 있습니다! <code>Drop</code> 트레이트와 러스트의 소유권 시스템 덕분에 러스트가 자동으로 정리를 수행하므로, 여러분은 정리를 직접 챙길 필요가 없습니다.</p>
<p>또한 사용 중인 값을 실수로 정리하여 발생하는 문제에 대해서도 걱정할 필요가 없습니다: 참조가 항상 유효함을 보장하는 소유권 시스템은 값이 더 이상 사용되지 않을 때 <code>drop</code>이 단 한 번만 호출되도록 보장합니다.</p>
<p>지금까지 <code>Box&lt;T&gt;</code>와 스마트 포인터의 몇 가지 특성을 살펴보았으므로, 표준 라이브러리에 정의된 다른 몇 가지 스마트 포인터들을 알아보겠습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="rct-참조-카운팅-스마트-포인터"><a class="header" href="#rct-참조-카운팅-스마트-포인터"><code>Rc&lt;T&gt;</code>, 참조 카운팅 스마트 포인터</a></h2>
<p>대부분의 경우 소유권은 명확합니다: 어떤 변수가 주어진 값을 소유하는지 정확히 알 수 있습니다. 하지만 하나의 값이 여러 소유자를 가질 수 있는 경우도 있습니다. 예를 들어, 그래프 데이터 구조에서 여러 에지(edge)가 동일한 노드를 가리킬 수 있으며, 그 노드는 개념적으로 자신을 가리키는 모든 에지에 의해 소유됩니다. 노드는 자신을 가리키는 에지가 하나도 없어서 소유자가 없을 때만 정리되어야 합니다.</p>
<p>러스트의 <code>Rc&lt;T&gt;</code> 타입을 사용하여 명시적으로 다중 소유권을 활성화해야 합니다. <code>Rc&lt;T&gt;</code>는 _참조 카운팅(reference counting)_의 약자입니다. <code>Rc&lt;T&gt;</code> 타입은 값이 여전히 사용 중인지 결정하기 위해 그 값에 대한 참조 횟수를 추적합니다. 만약 값에 대한 참조가 0개라면, 어떤 참조도 무효화되지 않은 채로 그 값을 정리할 수 있습니다.</p>
<p><code>Rc&lt;T&gt;</code>를 거실에 있는 TV라고 상상해 보세요. 한 사람이 TV를 보러 들어오면 TV를 켭니다. 다른 사람들도 방에 들어와 TV를 볼 수 있습니다. 마지막 사람이 방을 나갈 때, 더 이상 사용되지 않으므로 TV를 끕니다. 만약 다른 사람들이 여전히 TV를 보고 있는데 누군가 TV를 꺼버린다면, 남아있는 시청자들이 가만히 있지 않겠죠!</p>
<p>프로그램의 여러 부분에서 읽을 수 있도록 힙에 데이터를 할당하고 싶지만, 컴파일 타임에 어떤 부분이 마지막으로 그 데이터를 사용할지 결정할 수 없을 때 <code>Rc&lt;T&gt;</code> 타입을 사용합니다. 만약 어떤 부분이 마지막에 끝날지 안다면, 그 부분을 데이터의 소유자로 만들면 컴파일 타임에 강제되는 일반적인 소유권 규칙이 적용될 것입니다.</p>
<p><code>Rc&lt;T&gt;</code>는 오직 단일 스레드 시나리오에서만 사용 가능하다는 점에 유의하세요. 16장에서 동시성을 논의할 때, 멀티스레드 프로그램에서 참조 카운팅을 하는 방법을 다룰 것입니다.</p>
<h3 id="rct를-사용하여-데이터-공유하기"><a class="header" href="#rct를-사용하여-데이터-공유하기"><code>Rc&lt;T&gt;</code>를 사용하여 데이터 공유하기</a></h3>
<p>목록 15-5의 콘스 리스트 예제로 돌아가 봅시다. 우리가 이를 <code>Box&lt;T&gt;</code>를 사용하여 정의했음을 상기해 보세요. 이번에는 세 번째 리스트의 소유권을 공유하는 두 개의 리스트를 만들 것입니다. 개념적으로는 그림 15-3과 유사한 모습입니다:</p>
<img alt="Two lists that share ownership of a third list" src="img/trpl15-03.svg" class="center" />
<p><span class="caption">그림 15-3: 세 번째 리스트 <code>a</code>를 공유 소유하는 두 리스트 <code>b</code>와 <code>c</code></span></p>
<p>5와 10을 포함하는 리스트 <code>a</code>를 생성할 것입니다. 그런 다음 3으로 시작하는 리스트 <code>b</code>와 4로 시작하는 리스트 <code>c</code>를 만들 것입니다. 리스트 <code>b</code>와 <code>c</code> 모두 5와 10을 포함하는 첫 번째 리스트 <code>a</code>로 이어지게 됩니다. 즉, 두 리스트 모두 5와 10을 포함하는 첫 번째 리스트를 공유하게 됩니다.</p>
<p><code>Box&lt;T&gt;</code>를 사용한 우리의 <code>List</code> 정의로 이 시나리오를 구현하려는 시도는 목록 15-17에서 보여주듯이 작동하지 않을 것입니다:</p>
<Listing number="15-17" file-name="src/main.rs" caption="Demonstrating we’re not allowed to have two lists using `Box<T>` that try to share ownership of a third list">
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}</code></pre>
</Listing>
<p>이 코드를 컴파일하면 다음과 같은 에러가 발생합니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0382]: use of moved value: `a`
  --&gt; src/main.rs:11:30
   |
9  |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
   |         - move occurs because `a` has type `List`, which does not implement the `Copy` trait
10 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
11 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `cons-list` (bin "cons-list") due to 1 previous error
</code></pre>
<p><code>Cons</code> 변종은 자신이 보유한 데이터를 소유하므로, 리스트 <code>b</code>를 생성할 때 <code>a</code>는 <code>b</code>로 이동하고 <code>b</code>가 <code>a</code>를 소유하게 됩니다. 그런 다음 <code>c</code>를 생성할 때 <code>a</code>를 다시 사용하려고 시도하면, <code>a</code>가 이미 이동되었기 때문에 허용되지 않습니다.</p>
<p><code>Cons</code>가 참조를 보유하도록 정의를 변경할 수도 있지만, 그렇게 하면 라이프타임 매개변수를 지정해야 합니다. 라이프타임 매개변수를 지정한다는 것은 리스트의 모든 요소가 전체 리스트만큼은 오래 살 것임을 명시하는 것입니다. 목록 15-17의 요소들과 리스트들이 바로 그런 경우지만, 모든 시나리오가 그렇지는 않습니다.</p>
<p>대신, 목록 15-18에서처럼 <code>Box&lt;T&gt;</code> 대신 <code>Rc&lt;T&gt;</code>를 사용하도록 <code>List</code> 정의를 변경하겠습니다. 이제 각 <code>Cons</code> 변종은 값 하나와 <code>List</code>를 가리키는 <code>Rc&lt;T&gt;</code>를 보유하게 됩니다. <code>b</code>를 생성할 때 <code>a</code>의 소유권을 가져오는 대신, <code>a</code>가 보유하고 있는 <code>Rc&lt;List&gt;</code>를 복제(clone)할 것입니다. 이렇게 하면 참조 횟수가 1에서 2로 증가하며, <code>a</code>와 <code>b</code>가 그 <code>Rc&lt;List&gt;</code> 안의 데이터에 대한 소유권을 공유하게 됩니다. 또한 <code>c</code>를 생성할 때도 <code>a</code>를 복제하여 참조 횟수를 2에서 3으로 늘릴 것입니다. <code>Rc::clone</code>을 호출할 때마다 <code>Rc&lt;List&gt;</code> 내부 데이터에 대한 참조 횟수가 증가하며, 참조 횟수가 0이 되지 않는 한 데이터는 정리되지 않을 것입니다.</p>
<Listing number="15-18" file-name="src/main.rs" caption="A definition of `List` that uses `Rc<T>`">
<pre><pre class="playground"><code class="language-rust edition2021">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));
    let c = Cons(4, Rc::clone(&amp;a));
}</code></pre></pre>
</Listing>
<p><code>Rc&lt;T&gt;</code>는 프렐루드에 포함되어 있지 않으므로, 이를 스코프로 가져오기 위해 <code>use</code> 구문을 추가해야 합니다. <code>main</code>에서는 5와 10을 보유한 리스트를 생성하여 <code>a</code>에 새로운 <code>Rc&lt;List&gt;</code>로 저장합니다. 그런 다음 <code>b</code>와 <code>c</code>를 생성할 때, <code>Rc::clone</code> 함수를 호출하고 <code>a</code>에 있는 <code>Rc&lt;List&gt;</code>에 대한 참조를 인자로 전달합니다.</p>
<p><code>Rc::clone(&amp;a)</code> 대신 <code>a.clone()</code>을 호출할 수도 있었겠지만, 이 경우에는 <code>Rc::clone</code>을 사용하는 것이 러스트의 관례입니다. <code>Rc::clone</code>의 구현은 대부분의 타입들이 구현하는 <code>clone</code>처럼 모든 데이터를 깊은 복사(deep copy)하지 않습니다. <code>Rc::clone</code> 호출은 참조 횟수만 증가시키며, 이는 시간이 오래 걸리지 않습니다. 데이터의 깊은 복사는 많은 시간이 걸릴 수 있습니다. 참조 카운팅을 위해 <code>Rc::clone</code>을 사용함으로써, 우리는 깊은 복사류의 클론과 참조 횟수만 증가시키는 종류의 클론을 시각적으로 구분할 수 있습니다. 코드에서 성능 문제를 찾을 때, 깊은 복사 클론만 고려하면 되고 <code>Rc::clone</code> 호출은 무시할 수 있습니다.</p>
<h3 id="rct를-복제하면-참조-횟수가-증가합니다"><a class="header" href="#rct를-복제하면-참조-횟수가-증가합니다"><code>Rc&lt;T&gt;</code>를 복제하면 참조 횟수가 증가합니다</a></h3>
<p>목록 15-18의 예제를 수정하여, <code>a</code>에 있는 <code>Rc&lt;List&gt;</code>에 대한 참조를 만들고 드롭함에 따라 참조 횟수가 어떻게 변하는지 확인해 봅시다.</p>
<p>목록 15-19에서는 <code>main</code>을 수정하여 리스트 <code>c</code>를 감싸는 내부 스코프를 만들겠습니다. 그러면 <code>c</code>가 스코프를 벗어날 때 참조 횟수가 어떻게 변하는지 볼 수 있습니다.</p>
<Listing number="15-19" file-name="src/main.rs" caption="Printing the reference count">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, Rc&lt;List&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("a 생성 후의 횟수 = {}", Rc::strong_count(&amp;a));
    let b = Cons(3, Rc::clone(&amp;a));
    println!("b 생성 후의 횟수 = {}", Rc::strong_count(&amp;a));
    {
        let c = Cons(4, Rc::clone(&amp;a));
        println!("c 생성 후의 횟수 = {}", Rc::strong_count(&amp;a));
    }
    println!("c가 스코프를 벗어난 후의 횟수 = {}", Rc::strong_count(&amp;a));
}</code></pre></pre>
</Listing>
<p>At each point in the program where the reference count changes, we print the reference count, which we get by calling the <code>Rc::strong_count</code> function. This function is named <code>strong_count</code> rather than <code>count</code> because the <code>Rc&lt;T&gt;</code> type also has a <code>weak_count</code>; we’ll see what <code>weak_count</code> is used for in <a href="ch15-06-reference-cycles.html#preventing-reference-cycles-turning-an-rct-into-a-weakt">“Preventing Reference Cycles: Turning an <code>Rc&lt;T&gt;</code> into a <code>Weak&lt;T&gt;</code>”</a><!-- ignore -->.</p>
<p>이 코드는 다음과 같이 출력합니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.45s
     Running `target/debug/cons-list`
count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
</code></pre>
<p><code>a</code>에 있는 <code>Rc&lt;List&gt;</code>의 초기 참조 횟수가 1임을 알 수 있습니다. 그 후 <code>clone</code>을 호출할 때마다 횟수가 1씩 증가합니다. <code>c</code>가 스코프를 벗어나면 횟수가 1 감소합니다. 참조 횟수를 늘리기 위해 <code>Rc::clone</code>을 호출해야 하는 것과 달리, 참조 횟수를 줄이기 위해 어떤 함수를 호출할 필요는 없습니다: <code>Rc&lt;T&gt;</code> 값이 스코프를 벗어날 때 <code>Drop</code> 트레이트의 구현이 자동으로 참조 횟수를 감소시킵니다.</p>
<p>이 예제에서 볼 수 없는 점은 <code>main</code>의 끝에서 <code>b</code>와 <code>a</code>가 스코프를 벗어날 때 참조 횟수가 0이 되고, <code>Rc&lt;List&gt;</code>가 완전히 정리된다는 것입니다. <code>Rc&lt;T&gt;</code>를 사용하면 하나의 값이 여러 명의 소유자를 가질 수 있으며, 참조 횟수는 소유자 중 누구라도 남아있는 한 값이 유효하게 유지됨을 보장합니다.</p>
<p>불변 참조를 통해, <code>Rc&lt;T&gt;</code>는 프로그램의 여러 부분 사이에서 오직 읽기 전용으로만 데이터를 공유할 수 있게 해줍니다. 만약 <code>Rc&lt;T&gt;</code>가 여러 개의 가변 참조도 허용했다면, 4장에서 논의했던 대여 규칙 중 하나를 위반하게 될 것입니다: 동일한 위치에 대한 여러 개의 가변 대여는 데이터 경합(data races)과 부정합을 일으킬 수 있습니다. 하지만 데이터를 수정할 수 있는 것은 매우 유용합니다! 다음 섹션에서는 이러한 불변성 제한과 함께 작업하기 위해 <code>Rc&lt;T&gt;</code>와 결합하여 사용할 수 있는 내부 가변성 패턴과 <code>RefCell&lt;T&gt;</code> 타입에 대해 논의하겠습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="refcellt과-내부-가변성-패턴"><a class="header" href="#refcellt과-내부-가변성-패턴"><code>RefCell&lt;T&gt;</code>과 내부 가변성 패턴</a></h2>
<p>_내부 가변성(Interior mutability)_은 데이터에 대한 불변 참조가 있더라도 데이터를 수정할 수 있게 해주는 러스트의 디자인 패턴입니다; 보통 이 작업은 대여 규칙에 의해 허용되지 않습니다. 데이터를 수정하기 위해, 이 패턴은 데이터 구조 내부에서 <code>unsafe</code> 코드를 사용하여 수정과 대여를 다스리는 러스트의 일반적인 규칙을 구부립니다. <code>unsafe</code> 코드는 우리가 컴파일러에게 의존하는 대신 규칙을 수동으로 확인하고 있음을 컴파일러에게 알립니다. <code>unsafe</code> 코드에 대해서는 20장에서 더 자세히 다룰 것입니다.</p>
<p>컴파일러가 보장할 수 없더라도 런타임에 대여 규칙이 준수될 것임을 우리가 확신할 수 있는 경우에만 내부 가변성 패턴을 사용하는 타입들을 사용할 수 있습니다. 관련된 <code>unsafe</code> 코드는 안전한 API로 감싸지며, 외부 타입은 여전히 불변입니다.</p>
<p>내부 가변성 패턴을 따르는 <code>RefCell&lt;T&gt;</code> 타입을 살펴보며 이 개념을 탐구해 봅시다.</p>
<h3 id="refcellt로-런타임에-대여-규칙-강제하기"><a class="header" href="#refcellt로-런타임에-대여-규칙-강제하기"><code>RefCell&lt;T&gt;</code>로 런타임에 대여 규칙 강제하기</a></h3>
<p><code>Rc&lt;T&gt;</code>와 달리, <code>RefCell&lt;T&gt;</code> 타입은 보유한 데이터에 대해 단일 소유권을 나타냅니다. 그렇다면 <code>RefCell&lt;T&gt;</code>가 <code>Box&lt;T&gt;</code>와 같은 타입과 다른 점은 무엇일까요? 4장에서 배운 대여 규칙을 상기해 보세요:</p>
<ul>
<li>어느 때든, 하나의 가변 참조 <em>또는</em> 여러 개의 불변 참조 중 하나만 가질 수 있습니다(둘 다 가질 수는 없습니다).</li>
<li>참조는 항상 유효해야 합니다.</li>
</ul>
<p>참조와 <code>Box&lt;T&gt;</code>의 경우, 대여 규칙의 불변성(invariants)은 컴파일 타임에 강제됩니다. <code>RefCell&lt;T&gt;</code>의 경우, 이러한 불변성들은 <em>런타임에</em> 강제됩니다. 참조의 경우 규칙을 어기면 컴파일 에러를 받게 됩니다. <code>RefCell&lt;T&gt;</code>의 경우 규칙을 어기면 프로그램이 패닉(panic)을 일으키고 종료될 것입니다.</p>
<p>컴파일 타임에 대여 규칙을 검사하면 개발 과정에서 에러를 더 일찍 발견할 수 있고, 모든 분석이 사전에 완료되므로 런타임 성능에 영향이 없다는 장점이 있습니다. 이러한 이유로 대부분의 경우 컴파일 타임에 대여 규칙을 검사하는 것이 최선의 선택이며, 이것이 러스트의 기본 설정입니다.</p>
<p>반면 런타임에 대여 규칙을 검사하면 컴파일 타임 검사에서는 허용되지 않았을 특정 메모리 안전 시나리오가 허용된다는 장점이 있습니다. 러스트 컴파일러와 같은 정적 분석은 본질적으로 보수적입니다. 코드의 어떤 속성들은 코드를 분석하는 것만으로는 감지가 불가능합니다. 가장 유명한 예는 정지 문제(Halting Problem)이며, 이는 이 책의 범위를 벗어나지만 연구해 볼 만한 흥미로운 주제입니다.</p>
<p>일부 분석이 불가능하기 때문에, 러스트 컴파일러가 코드가 소유권 규칙을 준수하는지 확신할 수 없다면 올바른 프로그램이라도 거부할 수 있습니다. 이런 면에서 컴파일러는 보수적입니다. 만약 러스트가 잘못된 프로그램을 허용한다면 사용자는 러스트가 제공하는 보장을 신뢰할 수 없을 것입니다. 하지만 러스트가 올바른 프로그램을 거부한다면 프로그래머는 불편함을 겪겠지만 재앙적인 일은 일어나지 않습니다. <code>RefCell&lt;T&gt;</code> 타입은 여러분의 코드가 대여 규칙을 준수한다고 확신하지만 컴파일러가 이를 이해하고 보장할 수 없을 때 유용합니다.</p>
<p><code>Rc&lt;T&gt;</code>와 마찬가지로, <code>RefCell&lt;T&gt;</code>는 오직 단일 스레드 시나리오에서만 사용 가능하며 멀티스레드 문맥에서 사용하려고 하면 컴파일 에러를 발생시킵니다. 16장에서 멀티스레드 프로그램에서 <code>RefCell&lt;T&gt;</code>과 같은 기능을 얻는 방법을 살펴보겠습니다.</p>
<p><code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code>, 혹은 <code>RefCell&lt;T&gt;</code>를 선택하는 이유를 요약하면 다음과 같습니다:</p>
<ul>
<li><code>Rc&lt;T&gt;</code>는 동일한 데이터에 대해 여러 소유자를 가능하게 합니다. <code>Box&lt;T&gt;</code>와 <code>RefCell&lt;T&gt;</code>는 단일 소유자만 가집니다.</li>
<li><code>Box&lt;T&gt;</code>는 컴파일 타임에 검사되는 불변 또는 가변 대여를 허용합니다. <code>Rc&lt;T&gt;</code>는 컴파일 타임에 검사되는 불변 대여만 허용합니다. <code>RefCell&lt;T&gt;</code>는 런타임에 검사되는 불변 또는 가변 대여를 허용합니다.</li>
<li><code>RefCell&lt;T&gt;</code>는 런타임에 검사되는 가변 대여를 허용하기 때문에, <code>RefCell&lt;T&gt;</code>가 불변인 경우에도 <code>RefCell&lt;T&gt;</code> 내부의 값을 수정할 수 있습니다.</li>
</ul>
<p>불변인 값 내부의 값을 수정하는 것이 바로 <em>내부 가변성</em> 패턴입니다. 내부 가변성이 유용한 상황을 살펴보고 이것이 어떻게 가능한지 알아봅시다.</p>
<h3 id="내부-가변성-불변-값에-대한-가변-대여"><a class="header" href="#내부-가변성-불변-값에-대한-가변-대여">내부 가변성: 불변 값에 대한 가변 대여</a></h3>
<p>대여 규칙의 결과로, 불변 값을 가지고 있을 때는 이를 가변으로 대여할 수 없습니다. 예를 들어, 다음 코드는 컴파일되지 않습니다:</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    let y = &amp;mut x;
}</code></pre>
<p>이 코드를 컴파일하려고 하면 다음과 같은 에러가 발생합니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling borrowing v0.1.0 (file:///projects/borrowing)
error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
 --&gt; src/main.rs:3:13
  |
3 |     let y = &amp;mut x;
  |             ^^^^^^ cannot borrow as mutable
  |
help: consider changing this to be mutable
  |
2 |     let mut x = 5;
  |         +++

For more information about this error, try `rustc --explain E0596`.
error: could not compile `borrowing` (bin "borrowing") due to 1 previous error
</code></pre>
<p>하지만 어떤 값이 자신의 메서드 내에서는 스스로를 변경할 수 있지만 다른 코드에게는 불변으로 보이게 하는 것이 유용한 상황이 있습니다. 그 값의 메서드 외부의 코드는 해당 값을 수정할 수 없습니다. <code>RefCell&lt;T&gt;</code>를 사용하는 것은 내부 가변성을 얻는 한 가지 방법이지만, <code>RefCell&lt;T&gt;</code>가 대여 규칙을 완전히 피하게 해주는 것은 아닙니다. 컴파일러의 대여 검사기는 이러한 내부 가변성을 허용하는 대신, 대여 규칙을 런타임에 검사합니다. 만약 규칙을 어긴다면 컴파일 에러 대신 <code>panic!</code>을 얻게 될 것입니다.</p>
<p><code>RefCell&lt;T&gt;</code>를 사용하여 불변 값을 수정하는 실질적인 예제를 통해 이것이 왜 유용한지 살펴보겠습니다.</p>
<h4 id="내부-가변성의-사용-사례-목-객체mock-objects"><a class="header" href="#내부-가변성의-사용-사례-목-객체mock-objects">내부 가변성의 사용 사례: 목 객체(Mock Objects)</a></h4>
<p>Sometimes during testing a programmer will use a type in place of another type, in order to observe particular behavior and assert it’s implemented correctly. This placeholder type is called a <em>test double</em>. Think of it in the sense of a “stunt double” in filmmaking, where a person steps in and substitutes for an actor to do a particular tricky scene. Test doubles stand in for other types when we’re running tests. <em>Mock objects</em> are specific types of test doubles that record what happens during a test so you can assert that the correct actions took place.</p>
<p>Rust doesn’t have objects in the same sense as other languages have objects, and Rust doesn’t have mock object functionality built into the standard library as some other languages do. However, you can definitely create a struct that will serve the same purposes as a mock object.</p>
<p>Here’s the scenario we’ll test: we’ll create a library that tracks a value against a maximum value and sends messages based on how close to the maximum value the current value is. This library could be used to keep track of a user’s quota for the number of API calls they’re allowed to make, for example.</p>
<p>Our library will only provide the functionality of tracking how close to the maximum a value is and what the messages should be at what times. Applications that use our library will be expected to provide the mechanism for sending the messages: the application could put a message in the application, send an email, send a text message, or something else. The library doesn’t need to know that detail. All it needs is something that implements a trait we’ll provide called <code>Messenger</code>. Listing 15-20 shows the library code:</p>
<Listing number="15-20" file-name="src/lib.rs" caption="A library to keep track of how close a value is to a maximum value and warn when the value is at certain levels">
<pre><code class="language-rust noplayground">pub trait Messenger {
    fn send(&amp;self, msg: &amp;str);
}

pub struct LimitTracker&lt;'a, T: Messenger&gt; {
    messenger: &amp;'a T,
    value: usize,
    max: usize,
}

impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
where
    T: Messenger,
{
    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&amp;mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max &gt;= 1.0 {
            self.messenger.send("에러: 할당량을 초과했습니다!");
        } else if percentage_of_max &gt;= 0.9 {
            self.messenger
                .send("긴급 경고: 할당량의 90% 이상을 사용했습니다!");
        } else if percentage_of_max &gt;= 0.75 {
            self.messenger
                .send("경고: 할당량의 75% 이상을 사용했습니다!");
        }
    }
}</code></pre>
</Listing>
<p>중요한 부분은 <code>LimitTracker</code>의 <code>set_value</code> 메서드 동작을 테스트하고 싶다는 것입니다. <code>value</code> 매개변수로 전달하는 값을 변경할 수 있지만, <code>set_value</code>는 우리가 단언(assertion)할 수 있는 어떤 것도 반환하지 않습니다. 우리는 <code>Messenger</code> 트레이트를 구현하는 무언가와 특정한 <code>max</code> 값을 가지고 <code>LimitTracker</code>를 만들었을 때, <code>value</code>로 다른 숫자들을 전달하면 메신저가 적절한 메시지를 보내도록 요청받는지를 말할 수 있기를 원합니다.</p>
<p>우리는 <code>send</code>를 호출할 때 이메일이나 텍스트 메시지를 보내는 대신, 보내도록 요청받은 메시지만 추적하는 목 객체가 필요합니다. 목 객체의 새 인스턴스를 만들고, 그 목 객체를 사용하는 <code>LimitTracker</code>를 만든 뒤, <code>LimitTracker</code>의 <code>set_value</code> 메서드를 호출하고 목 객체가 우리가 예상한 메시지들을 가지고 있는지 확인할 수 있습니다. 목록 15-21은 바로 그 작업을 수행하기 위한 목 객체 구현 시도를 보여주지만, 대여 검사기가 이를 허용하지 않을 것입니다.</p>
<Listing number="15-21" file-name="src/lib.rs" caption="An attempt to implement a `MockMessenger` that isn’t allowed by the borrow checker">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("에러: 할당량을 초과했습니다!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("긴급 경고: 할당량의 90% 이상을 사용했습니다!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("경고: 할당량의 75% 이상을 사용했습니다!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec&lt;String&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: vec![],
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}</code></pre>
</Listing>
<p>이 테스트 코드는 보내도록 요청받은 메시지를 추적하기 위해 <code>String</code> 값들의 <code>Vec</code>을 가지는 <code>sent_messages</code> 필드가 있는 <code>MockMessenger</code> 구조체를 정의합니다. 또한 빈 메시지 목록으로 시작하는 새로운 <code>MockMessenger</code> 값을 편리하게 생성할 수 있도록 <code>new</code> 연관 함수를 정의합니다. 그다음 <code>MockMessenger</code>를 <code>LimitTracker</code>에 전달할 수 있도록 <code>Messenger</code> 트레이트를 구현합니다. <code>send</code> 메서드 정의에서는 매개변수로 전달된 메시지를 가져와 <code>MockMessenger</code>의 <code>sent_messages</code> 목록에 저장합니다.</p>
<p>테스트에서는 <code>LimitTracker</code>가 <code>value</code>를 <code>max</code> 값의 75%보다 큰 값으로 설정하도록 요청받았을 때 어떤 일이 일어나는지 테스트합니다. 먼저, 빈 메시지 목록으로 시작하는 새로운 <code>MockMessenger</code>를 생성합니다. 그런 다음 새로운 <code>LimitTracker</code>를 생성하고 여기에 새로운 <code>MockMessenger</code>에 대한 참조와 100이라는 <code>max</code> 값을 전달합니다. 100의 75%보다 큰 값인 80을 사용하여 <code>LimitTracker</code>의 <code>set_value</code> 메서드를 호출합니다. 그다음 <code>MockMessenger</code>가 추적하고 있는 메시지 목록에 이제 하나의 메시지가 들어있어야 한다고 단언합니다.</p>
<p>하지만 여기에 나타난 것처럼 이 테스트에는 한 가지 문제가 있습니다:</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
error[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a `&amp;` reference
  --&gt; src/lib.rs:58:13
   |
58 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable
   |
help: consider changing this to be a mutable reference in the `impl` method and the `trait` definition
   |
2  ~     fn send(&amp;mut self, msg: &amp;str);
3  | }
...
56 |     impl Messenger for MockMessenger {
57 ~         fn send(&amp;mut self, message: &amp;str) {
   |

For more information about this error, try `rustc --explain E0596`.
error: could not compile `limit-tracker` (lib test) due to 1 previous error
</code></pre>
<p>우리는 메시지를 추적하기 위해 <code>MockMessenger</code>를 수정할 수 없는데, 이는 <code>send</code> 메서드가 <code>self</code>에 대한 불변 참조를 받기 때문입니다. 또한 에러 텍스트의 제안대로 <code>impl</code> 메서드와 <code>trait</code> 정의 양쪽 모두에 <code>&amp;mut self</code>를 사용할 수도 없습니다. 오로지 테스트만을 위해서 <code>Messenger</code> 트레이트를 변경하고 싶지는 않기 때문입니다. 대신, 기존 설계와 함께 우리 테스트 코드가 올바르게 작동하도록 만들 방법을 찾아야 합니다.</p>
<p>이러한 상황이 바로 내부 가변성이 도움이 될 수 있는 상황입니다! <code>sent_messages</code>를 <code>RefCell&lt;T&gt;</code> 내부에 저장할 것이고, 그러면 <code>send</code> 메서드는 우리가 본 메시지들을 저장하기 위해 <code>sent_messages</code>를 수정할 수 있게 될 것입니다. 목록 15-22는 그 모습이 어떠한지 보여줍니다:</p>
<Listing number="15-22" file-name="src/lib.rs" caption="Using `RefCell<T>` to mutate an inner value while the outer value is considered immutable">
<pre><code class="language-rust noplayground"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("에러: 할당량을 초과했습니다!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("긴급 경고: 할당량의 90% 이상을 사용했습니다!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("경고: 할당량의 75% 이상을 사용했습니다!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: RefCell::new(vec![]),
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --생략--
<span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span>
        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}</code></pre>
</Listing>
<p>이제 <code>sent_messages</code> 필드는 <code>Vec&lt;String&gt;</code> 대신 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> 타입이 되었습니다. <code>new</code> 함수에서는 빈 벡터를 감싸는 새로운 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> 인스턴스를 생성합니다.</p>
<p><code>send</code> 메서드 구현에서, 첫 번째 매개변수는 여전히 <code>self</code>에 대한 불변 대여이며, 이는 트레이트 정의와 일치합니다. 우리는 <code>self.sent_messages</code>에 있는 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>에 대해 <code>borrow_mut</code>를 호출하여 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> 내부의 값, 즉 벡터에 대한 가변 참조를 얻습니다. 그런 다음 벡터에 대한 가변 참조에 대해 <code>push</code>를 호출하여 테스트 중에 전송된 메시지를 추적할 수 있습니다.</p>
<p>마지막으로 수정해야 할 부분은 단언(assertion)입니다: 내부 벡터에 몇 개의 항목이 있는지 확인하기 위해, <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>에 대해 <code>borrow</code>를 호출하여 벡터에 대한 불변 참조를 얻습니다.</p>
<p>이제 <code>RefCell&lt;T&gt;</code>를 사용하는 방법을 살펴보았으니, 내부적으로 어떻게 작동하는지 파헤쳐 봅시다!</p>
<h4 id="refcellt로-런타임에-대여-추적하기"><a class="header" href="#refcellt로-런타임에-대여-추적하기"><code>RefCell&lt;T&gt;</code>로 런타임에 대여 추적하기</a></h4>
<p>불변 참조와 가변 참조를 생성할 때, 우리는 각각 <code>&amp;</code>와 <code>&amp;mut</code> 문법을 사용합니다. <code>RefCell&lt;T&gt;</code>의 경우에는 <code>RefCell&lt;T&gt;</code>에 속한 안전한 API인 <code>borrow</code>와 <code>borrow_mut</code> 메서드를 사용합니다. <code>borrow</code> 메서드는 스마트 포인터 타입인 <code>Ref&lt;T&gt;</code>를 반환하고, <code>borrow_mut</code>는 스마트 포인터 타입인 <code>RefMut&lt;T&gt;</code>를 반환합니다. 두 타입 모두 <code>Deref</code>를 구현하므로, 우리는 이들을 일반 참조처럼 다룰 수 있습니다.</p>
<p><code>RefCell&lt;T&gt;</code>는 현재 얼마나 많은 <code>Ref&lt;T&gt;</code>와 <code>RefMut&lt;T&gt;</code> 스마트 포인터가 활성화되어 있는지 추적합니다. <code>borrow</code>를 호출할 때마다 <code>RefCell&lt;T&gt;</code>는 활성화된 불변 대여의 개수를 늘립니다. <code>Ref&lt;T&gt;</code> 값이 스코프를 벗어나면 불변 대여의 개수가 하나 줄어듭니다. 컴파일 타임 대여 규칙과 마찬가지로, <code>RefCell&lt;T&gt;</code>는 어느 시점이든 여러 개의 불변 대여 혹은 단 하나의 가변 대여만 가질 수 있게 합니다.</p>
<p>우리가 만약 이 규칙들을 위반하려고 하면, 참조를 사용할 때처럼 컴파일 에러를 받는 대신 <code>RefCell&lt;T&gt;</code>의 구현체는 런타임에 패닉을 발생시킵니다. 목록 15-23은 목록 15-22의 <code>send</code> 구현을 수정한 모습을 보여줍니다. <code>RefCell&lt;T&gt;</code>가 런타임에 이러한 행위를 방지한다는 것을 설명하기 위해, 동일한 스코프에서 두 개의 활성화된 가변 대여를 의도적으로 생성해 보았습니다.</p>
<Listing number="15-23" file-name="src/lib.rs" caption="Creating two mutable references in the same scope to see that `RefCell<T>` will panic">
<pre><code class="language-rust ignore panics"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("에러: 할당량을 초과했습니다!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("긴급 경고: 할당량의 90% 이상을 사용했습니다!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("경고: 할당량의 75% 이상을 사용했습니다!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">    struct MockMessenger {
</span><span class="boring">        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl MockMessenger {
</span><span class="boring">        fn new() -&gt; MockMessenger {
</span><span class="boring">            MockMessenger {
</span><span class="boring">                sent_messages: RefCell::new(vec![]),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            let mut one_borrow = self.sent_messages.borrow_mut();
            let mut two_borrow = self.sent_messages.borrow_mut();

            one_borrow.push(String::from(message));
            two_borrow.push(String::from(message));
        }
    }
<span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_sends_an_over_75_percent_warning_message() {
</span><span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span><span class="boring">
</span><span class="boring">        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p><code>borrow_mut</code>로부터 반환된 <code>RefMut&lt;T&gt;</code> 스마트 포인터를 위해 <code>one_borrow</code>라는 변수를 생성합니다. 그런 다음 동일한 방식으로 <code>two_borrow</code>라는 변수에 또 다른 가변 대여를 생성합니다. 이는 동일한 스코프에 두 개의 가변 참조를 만들며, 이는 허용되지 않습니다. 우리 라이브러리의 테스트를 실행하면 목록 15-23의 코드는 에러 없이 컴파일되지만 테스트는 실패할 것입니다:</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/limit_tracker-e599811fa246dbde)

running 1 test
test tests::it_sends_an_over_75_percent_warning_message ... FAILED

failures:

---- tests::it_sends_an_over_75_percent_warning_message stdout ----
thread 'tests::it_sends_an_over_75_percent_warning_message' panicked at src/lib.rs:60:53:
already borrowed: BorrowMutError
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_sends_an_over_75_percent_warning_message

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>코드가 <code>already borrowed: BorrowMutError</code>라는 메시지와 함께 패닉을 일으켰다는 점에 주목하세요. 이것이 <code>RefCell&lt;T&gt;</code>가 런타임에 대여 규칙 위반을 처리하는 방식입니다.</p>
<p>여기서 한 것처럼 대여 에러를 컴파일 타임이 아닌 런타임에 잡기로 선택하는 것은, 개발 과정의 더 늦은 시점(아마도 코드가 프로덕션에 배포된 이후일 수도 있음)에 코드의 실수를 발견하게 될 수도 있음을 의미합니다. 또한 코드는 런타임에 대여를 추적하기 때문에 약간의 런타임 성능 저하가 발생할 것입니다. 하지만 <code>RefCell&lt;T&gt;</code>를 사용하면 불변 값만 허용되는 맥락에서 사용되는 동안에도 스스로를 수정하여 본 메시지들을 추적할 수 있는 목 객체를 작성하는 것이 가능해집니다. 이러한 트레이드오프에도 불구하고 일반 참조가 제공하는 것 이상의 기능을 얻기 위해 <code>RefCell&lt;T&gt;</code>를 사용할 수 있습니다.</p>
<h3 id="rc와-refcell를-조합하여-가변-데이터의-다중-소유자-만들기"><a class="header" href="#rc와-refcell를-조합하여-가변-데이터의-다중-소유자-만들기">Rc<T>와 RefCell<T>를 조합하여 가변 데이터의 다중 소유자 만들기</a></h3>
<p>RefCell<T>를 사용하는 일반적인 방법은 Rc<T>와 함께 사용하는 것입니다. Rc<T>를 사용하면 어떤 데이터에 대해 여러 소유자를 가질 수 있지만, 그 데이터에 대해 불변 접근만 제공한다는 것을 기억하세요. RefCell<T>를 보유하는 Rc<T>가 있다면, 여러 소유자를 가질 수 <em>있고</em> 변경할 수도 있는 값을 얻을 수 있습니다!</p>
<p>예를 들어, 여러 리스트가 다른 리스트의 소유권을 공유하도록 하기 위해 Rc<T>를 사용했던 목록 15-18의 cons 리스트 예제를 떠올려보세요. Rc<T>는 불변 값만 보유하기 때문에, 일단 리스트를 생성하면 리스트의 어떤 값도 변경할 수 없습니다. 리스트의 값을 변경할 수 있는 기능을 얻기 위해 RefCell<T>를 추가해봅시다. 목록 15-24는 Cons 정의에 RefCell<T>를 사용함으로써 모든 리스트에 저장된 값을 수정할 수 있음을 보여줍니다:</p>
<Listing number="15-24" file-name="src/main.rs" caption="Using `Rc<RefCell<i32>>` to create a `List` that we can mutate">
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a));

    *value.borrow_mut() += 10;

    println!("변경 후 a = {a:?}");
    println!("변경 후 b = {b:?}");
    println!("변경 후 c = {c:?}");
}</code></pre></pre>
</Listing>
<p>Rc&lt;RefCell<i32>&gt;의 인스턴스인 값을 생성하고 나중에 직접 접근할 수 있도록 value라는 변수에 저장합니다. 그런 다음 value를 보유하는 Cons 변형으로 a에 List를 생성합니다. value에서 a로 소유권을 이전하거나 a가 value에서 대여하는 대신, a와 value 모두 내부의 5 값에 대한 소유권을 갖도록 value를 클론해야 합니다.</p>
<p>리스트 a를 Rc<T>로 감싸서 리스트 b와 c를 생성할 때 둘 다 a를 참조할 수 있도록 합니다. 이는 목록 15-18에서 했던 것과 같습니다.</p>
<p>a, b, c에 리스트를 생성한 후, value의 값에 10을 더하려고 합니다. 이를 위해 value에서 borrow_mut를 호출하는데, 이는 5장에서 논의했던 자동 역참조 기능(<a href="ch05-03-method-syntax.html#wheres-the---operator">“-&gt; 연산자는 어디에 있나요?”</a><!-- ignore --> 참조)을 사용하여 Rc<T>를 내부의 RefCell<T> 값으로 역참조합니다. borrow_mut 메서드는 RefMut<T> 스마트 포인터를 반환하며, 우리는 그 위에 역참조 연산자를 사용하여 내부 값을 변경합니다.</p>
<p>a, b, c를 출력해보면, 모두 5가 아닌 수정된 값 15를 가지고 있음을 볼 수 있습니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.63s
     Running `target/debug/cons-list`
변경 후 a = Cons(RefCell { value: 15 }, Nil)
변경 후 b = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))
변경 후 c = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<p>이 기법은 꽤 훌륭합니다! RefCell<T>를 사용하면 겉보기에는 불변인 List 값을 갖게 됩니다. 하지만 필요할 때 데이터를 수정할 수 있도록 내부 가변성에 대한 접근을 제공하는 RefCell<T>의 메서드를 사용할 수 있습니다. 대여 규칙의 런타임 검사는 데이터 경합으로부터 우리를 보호하며, 데이터 구조에서의 이러한 유연성을 위해 약간의 속도를 희생할 가치가 있습니다. RefCell<T>는 멀티스레드 코드에서는 작동하지 않는다는 점에 유의하세요! Mutex<T>는 RefCell<T>의 스레드 안전 버전이며 16장에서 Mutex<T>에 대해 논의할 것입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="참조-순환은-메모리-누수를-일으킬-수-있다"><a class="header" href="#참조-순환은-메모리-누수를-일으킬-수-있다">참조 순환은 메모리 누수를 일으킬 수 있다</a></h2>
<p>러스트의 메모리 안전성 보장은 정리되지 않는 메모리를 우연히 생성하는 것(메모리 누수라고 함)을 어렵게 만들지만 불가능하지는 않습니다. 메모리 누수를 완전히 방지하는 것은 러스트의 보장 중 하나가 아니며, 이는 메모리 누수가 러스트에서 메모리 안전함을 의미합니다. Rc<T>와 RefCell<T>를 사용하여 러스트가 메모리 누수를 허용함을 볼 수 있습니다: 항목들이 서로를 순환 참조하는 참조를 생성하는 것이 가능합니다. 이는 순환의 각 항목에 대한 참조 카운트가 결코 0에 도달하지 않고 값들이 결코 드롭되지 않기 때문에 메모리 누수를 생성합니다.</p>
<h3 id="순환-참조-생성하기"><a class="header" href="#순환-참조-생성하기">순환 참조 생성하기</a></h3>
<p>순환 참조가 어떻게 발생할 수 있는지와 이를 방지하는 방법을 목록 15-25의 List 열거형 정의와 tail 메서드로 시작하여 살펴봅시다:</p>
<Listing number="15-25" file-name="src/main.rs" caption="A cons list definition that holds a `RefCell<T>` so we can modify what a `Cons` variant is referring to">
<pre><pre class="playground"><code class="language-rust edition2021">use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match self {
            Cons(_, item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}

fn main() {}</code></pre></pre>
</Listing>
<p>목록 15-5의 List 정의의 또 다른 변형을 사용하고 있습니다. Cons 변형의 두 번째 요소는 이제 RefCell&lt;Rc<List>&gt;이며, 이는 목록 15-24에서 했던 것처럼 i32 값을 수정하는 기능 대신 Cons 변형이 가리키는 List 값을 수정하고자 함을 의미합니다. 또한 Cons 변형이 있는 경우 두 번째 항목에 편리하게 접근할 수 있도록 tail 메서드를 추가하고 있습니다.</p>
<p>목록 15-26에서는 목록 15-25의 정의를 사용하는 main 함수를 추가하고 있습니다. 이 코드는 a에 리스트를 생성하고 b에 a의 리스트를 가리키는 리스트를 생성합니다. 그런 다음 a의 리스트가 b를 가리키도록 수정하여 순환 참조를 생성합니다. 이 과정의 다양한 지점에서 참조 카운트가 무엇인지 보여주기 위해 println! 문들이 있습니다.</p>
<Listing number="15-26" file-name="src/main.rs" caption="Creating a reference cycle of two `List` values pointing to each other">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum List {
</span><span class="boring">    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
</span><span class="boring">        match self {
</span><span class="boring">            Cons(_, item) =&gt; Some(item),
</span><span class="boring">            Nil =&gt; None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!("a의 초기 rc 카운트 = {}", Rc::strong_count(&amp;a));
    println!("a의 다음 항목 = {:?}", a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));

    println!("b 생성 후 a의 rc 카운트 = {}", Rc::strong_count(&amp;a));
    println!("b의 초기 rc 카운트 = {}", Rc::strong_count(&amp;b));
    println!("b의 다음 항목 = {:?}", b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&amp;b);
    }

    println!("a 변경 후 b의 rc 카운트 = {}", Rc::strong_count(&amp;b));
    println!("a 변경 후 a의 rc 카운트 = {}", Rc::strong_count(&amp;a));

    // 다음 줄의 주석을 해제하면 순환이 있음을 볼 수 있습니다;
    // 스택 오버플로가 발생할 것입니다.
    // println!("a의 다음 항목 = {:?}", a.tail());
}</code></pre></pre>
</Listing>
<p>초기 리스트 5, Nil을 갖는 변수 a에 List 값을 보유하는 Rc<List> 인스턴스를 생성합니다. 그런 다음 값 10을 포함하고 a의 리스트를 가리키는 또 다른 List 값을 보유하는 Rc<List> 인스턴스를 변수 b에 생성합니다.</p>
<p>a가 Nil 대신 b를 가리키도록 수정하여 순환을 생성합니다. 이를 위해 tail 메서드를 사용하여 a의 RefCell&lt;Rc<List>&gt;에 대한 참조를 얻고, 이를 link 변수에 넣습니다. 그런 다음 RefCell&lt;Rc<List>&gt;에서 borrow_mut 메서드를 사용하여 내부 값을 Nil 값을 보유하는 Rc<List>에서 b의 Rc<List>로 변경합니다.</p>
<p>이 코드를 실행할 때, 마지막 println!을 주석 처리한 상태로 두면 다음과 같은 출력을 얻을 것입니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.53s
     Running `target/debug/cons-list`
a의 초기 rc 카운트 = 1
a의 다음 항목 = Some(RefCell { value: Nil })
b 생성 후 a의 rc 카운트 = 2
b의 초기 rc 카운트 = 1
b의 다음 항목 = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
a 변경 후 b의 rc 카운트 = 2
a 변경 후 a의 rc 카운트 = 2
</code></pre>
<p>a의 리스트가 b를 가리키도록 변경한 후 a와 b의 Rc<List> 인스턴스에 대한 참조 카운트는 모두 2입니다. main의 끝에서 러스트는 변수 b를 드롭하고, 이는 b의 Rc<List> 인스턴스의 참조 카운트를 2에서 1로 줄입니다. Rc<List>가 힙에 가지고 있는 메모리는 이 시점에서 드롭되지 않습니다. 참조 카운트가 0이 아니라 1이기 때문입니다. 그런 다음 러스트는 a를 드롭하고, 이는 a의 Rc<List> 인스턴스의 참조 카운트도 2에서 1로 줄입니다. 이 인스턴스의 메모리 또한 드롭될 수 없습니다. 다른 Rc<List> 인스턴스가 여전히 그것을 참조하고 있기 때문입니다. 리스트에 할당된 메모리는 영원히 회수되지 않은 채로 남을 것입니다. 이 순환 참조를 시각화하기 위해 그림 15-4의 다이어그램을 만들었습니다.</p>
<img alt="Reference cycle of lists" src="img/trpl15-04.svg" class="center" />
<p><span class="caption">그림 15-4: 서로를 가리키는 리스트 a와 b의 순환 참조</span></p>
<p>마지막 println!의 주석을 해제하고 프로그램을 실행하면, 러스트는 a가 b를 가리키고 b가 a를 가리키는 식으로 스택이 오버플로될 때까지 이 순환을 출력하려고 시도할 것입니다.</p>
<p>실제 프로그램과 비교할 때, 이 예제에서 순환 참조를 생성하는 것의 결과는 그리 끔찍하지 않습니다. 순환 참조를 생성한 직후 프로그램이 종료되기 때문입니다. 하지만 더 복잡한 프로그램이 순환 내에서 많은 메모리를 할당하고 오랫동안 유지한다면, 프로그램은 필요한 것보다 더 많은 메모리를 사용하여 시스템을 압도하고 사용 가능한 메모리가 부족하게 만들 수 있습니다.</p>
<p>순환 참조를 생성하는 것은 쉽지 않지만, 불가능하지도 않습니다. Rc<T> 값을 포함하는 RefCell<T> 값이나 내부 가변성과 참조 카운팅이 있는 타입의 유사한 중첩 조합이 있는 경우, 순환을 생성하지 않도록 보장해야 합니다. 러스트가 그것들을 잡아낼 것이라고 의존할 수 없습니다. 순환 참조를 생성하는 것은 프로그램의 논리 버그일 것이며, 자동화된 테스트, 코드 리뷰 및 기타 소프트웨어 개발 관행을 사용하여 최소화해야 합니다.</p>
<p>순환 참조를 피하는 또 다른 해결책은 일부 참조는 소유권을 표현하고 일부 참조는 그렇지 않도록 데이터 구조를 재구성하는 것입니다. 결과적으로 일부 소유권 관계와 일부 비소유권 관계로 구성된 순환을 가질 수 있으며, 소유권 관계만이 값이 드롭될 수 있는지 여부에 영향을 미칩니다. 목록 15-25에서는 Cons 변형이 항상 리스트를 소유하기를 원하므로 데이터 구조를 재구성하는 것이 불가능합니다. 비소유권 관계가 순환 참조를 방지하는 적절한 방법이 되는 경우를 보기 위해 부모 노드와 자식 노드로 구성된 그래프를 사용하는 예제를 살펴봅시다.</p>
<h3 id="순환-참조-방지하기-rc를-weak로-바꾸기"><a class="header" href="#순환-참조-방지하기-rc를-weak로-바꾸기">순환 참조 방지하기: Rc<T>를 Weak<T>로 바꾸기</a></h3>
<p>지금까지 Rc::clone을 호출하면 Rc<T> 인스턴스의 strong_count가 증가하고, Rc<T> 인스턴스는 strong_count가 0일 때만 정리된다는 것을 보여주었습니다. 또한 Rc::downgrade를 호출하고 Rc<T>에 대한 참조를 전달하여 Rc<T> 인스턴스 내의 값에 대한 약한 참조를 생성할 수도 있습니다. 강한 참조는 Rc<T> 인스턴스의 소유권을 공유하는 방법입니다. 약한 참조는 소유권 관계를 표현하지 않으며, 그 카운트는 Rc<T> 인스턴스가 정리되는 시점에 영향을 미치지 않습니다. 약한 참조를 포함하는 순환은 관련된 값의 강한 참조 카운트가 0이 되면 깨지기 때문에 순환 참조를 일으키지 않습니다.</p>
<p>Rc::downgrade를 호출하면 Weak<T> 타입의 스마트 포인터를 얻습니다. Rc<T> 인스턴스의 strong_count를 1 증가시키는 대신, Rc::downgrade를 호출하면 weak_count가 1 증가합니다. Rc<T> 타입은 strong_count와 유사하게 존재하는 Weak<T> 참조의 수를 추적하기 위해 weak_count를 사용합니다. 차이점은 Rc<T> 인스턴스가 정리되기 위해 weak_count가 0일 필요는 없다는 것입니다.</p>
<p>Weak<T>가 참조하는 값은 드롭되었을 수 있으므로, Weak<T>가 가리키는 값으로 무언가를 하려면 값이 여전히 존재하는지 확인해야 합니다. Weak<T> 인스턴스에서 upgrade 메서드를 호출하여 이를 수행하며, 이는 Option&lt;Rc<T>&gt;를 반환합니다. Rc<T> 값이 아직 드롭되지 않았다면 Some 결과를, Rc<T> 값이 드롭되었다면 None 결과를 얻을 것입니다. upgrade는 Option&lt;Rc<T>&gt;를 반환하므로, 러스트는 Some 케이스와 None 케이스가 처리되도록 보장하며, 유효하지 않은 포인터는 없을 것입니다.</p>
<p>예를 들어, 항목이 다음 항목에 대해서만 알고 있는 리스트를 사용하는 대신, 항목이 자식 항목 <em>및</em> 부모 항목에 대해 알고 있는 트리를 생성할 것입니다.</p>
<h4 id="트리-데이터-구조-생성하기-자식-노드가-있는-node"><a class="header" href="#트리-데이터-구조-생성하기-자식-노드가-있는-node">트리 데이터 구조 생성하기: 자식 노드가 있는 Node</a></h4>
<p>시작하기 위해, 자식 노드에 대해 알고 있는 노드가 있는 트리를 구축할 것입니다. 자체 i32 값과 자식 Node 값에 대한 참조를 보유하는 Node라는 구조체를 생성할 것입니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<p>Node가 자식을 소유하고, 트리의 각 Node에 직접 접근할 수 있도록 그 소유권을 변수와 공유하고 싶습니다. 이를 위해 Vec<T> 항목을 Rc<Node> 타입의 값으로 정의합니다. 또한 다른 노드의 자식인 노드를 수정하고 싶으므로 Vec&lt;Rc<Node>&gt;를 감싸는 children에 RefCell<T>를 사용합니다.</p>
<p>다음으로, 구조체 정의를 사용하여 목록 15-27에 표시된 것처럼 값 3과 자식이 없는 leaf라는 Node 인스턴스 하나와, 값 5와 leaf를 자식 중 하나로 갖는 branch라는 또 다른 인스턴스를 생성할 것입니다:</p>
<Listing number="15-27" file-name="src/main.rs" caption="Creating a `leaf` node with no children and a `branch` node with `leaf` as one of its children">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });
}</code></pre></pre>
</Listing>
<p>leaf의 Rc<Node>를 클론하여 branch에 저장합니다. 이는 leaf의 Node가 이제 leaf와 branch라는 두 소유자를 가짐을 의미합니다. branch.children을 통해 branch에서 leaf로 이동할 수 있지만, leaf에서 branch로 이동할 방법은 없습니다. 이유는 leaf가 branch에 대한 참조를 가지고 있지 않고 서로 관련되어 있다는 것을 모르기 때문입니다. leaf가 branch가 자신의 부모라는 것을 알기를 원합니다. 다음으로 그 작업을 할 것입니다.</p>
<h4 id="자식에서-부모로의-참조-추가하기"><a class="header" href="#자식에서-부모로의-참조-추가하기">자식에서 부모로의 참조 추가하기</a></h4>
<p>자식 노드가 부모를 인식하도록 하려면 Node 구조체 정의에 parent 필드를 추가해야 합니다. 문제는 parent의 타입을 무엇으로 할지 결정하는 것입니다. Rc<T>를 포함할 수 없다는 것을 알고 있습니다. 왜냐하면 leaf.parent가 branch를 가리키고 branch.children이 leaf를 가리키는 순환 참조를 생성하여 strong_count 값이 결코 0이 되지 않게 만들기 때문입니다.</p>
<p>관계를 다른 방식으로 생각해보면, 부모 노드는 자식을 소유해야 합니다. 부모 노드가 드롭되면 자식 노드들도 드롭되어야 합니다. 그러나 자식은 부모를 소유해서는 안 됩니다. 자식 노드를 드롭하더라도 부모는 여전히 존재해야 합니다. 이것은 약한 참조가 필요한 경우입니다!</p>
<p>그래서 Rc<T> 대신 parent의 타입이 Weak<T>, 구체적으로는 RefCell&lt;Weak<Node>&gt;를 사용하도록 만들 것입니다. 이제 Node 구조체 정의는 다음과 같습니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("leaf의 부모 = {:?}", leaf.parent.borrow().upgrade());
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);
</span><span class="boring">
</span><span class="boring">    println!("leaf의 부모 = {:?}", leaf.parent.borrow().upgrade());
</span><span class="boring">}</span></code></pre></pre>
<p>노드는 부모 노드를 참조할 수 있지만 부모를 소유하지는 않습니다. 목록 15-28에서 이 새로운 정의를 사용하도록 main을 업데이트하여 leaf 노드가 부모인 branch를 참조할 수 있는 방법을 갖도록 합니다:</p>
<Listing number="15-28" file-name="src/main.rs" caption="A `leaf` node with a weak reference to its parent node `branch`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!("leaf의 부모 = {:?}", leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

    println!("leaf의 부모 = {:?}", leaf.parent.borrow().upgrade());
}</code></pre></pre>
</Listing>
<p>leaf 노드를 생성하는 것은 parent 필드를 제외하고는 목록 15-27과 유사해 보입니다. leaf는 부모 없이 시작하므로, 새롭고 빈 Weak<Node> 참조 인스턴스를 생성합니다.</p>
<p>이 시점에서, upgrade 메서드를 사용하여 leaf의 부모에 대한 참조를 얻으려고 시도하면 None 값을 얻습니다. 첫 번째 println! 문의 출력에서 이를 확인할 수 있습니다:</p>
<pre><code class="language-text">leaf parent = None
</code></pre>
<p>branch 노드를 생성할 때, branch도 부모 노드가 없기 때문에 parent 필드에 새로운 Weak<Node> 참조를 가질 것입니다. 여전히 leaf를 branch의 자식 중 하나로 가지고 있습니다. branch에 Node 인스턴스가 생기면, leaf를 수정하여 부모에 대한 Weak<Node> 참조를 줄 수 있습니다. leaf의 parent 필드에 있는 RefCell&lt;Weak<Node>&gt;에서 borrow_mut 메서드를 사용한 다음, Rc::downgrade 함수를 사용하여 branch의 Rc<Node>에서 branch에 대한 Weak<Node> 참조를 생성합니다.</p>
<p>leaf의 부모를 다시 출력하면, 이번에는 branch를 보유하는 Some 변형을 얻게 될 것입니다. 이제 leaf는 부모에 접근할 수 있습니다! leaf를 출력할 때, 목록 15-26에서처럼 결국 스택 오버플로로 끝나는 순환도 피하게 됩니다. Weak<Node> 참조는 (Weak)로 출력됩니다:</p>
<pre><code class="language-text">leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
</code></pre>
<p>무한 출력이 없다는 것은 이 코드가 순환 참조를 생성하지 않았음을 나타냅니다. Rc::strong_count와 Rc::weak_count를 호출하여 얻은 값을 보고도 이를 알 수 있습니다.</p>
<h4 id="strong_count와-weak_count의-변화-시각화하기"><a class="header" href="#strong_count와-weak_count의-변화-시각화하기">strong_count와 weak_count의 변화 시각화하기</a></h4>
<p>새로운 내부 스코프를 생성하고 branch 생성을 그 스코프로 이동시켜 Rc<Node> 인스턴스의 strong_count와 weak_count 값이 어떻게 변하는지 살펴봅시다. 그렇게 함으로써 branch가 생성되고 스코프를 벗어날 때 드롭되면 어떤 일이 발생하는지 볼 수 있습니다. 수정 사항은 목록 15-29에 나와 있습니다:</p>
<Listing number="15-29" file-name="src/main.rs" caption="Creating `branch` in an inner scope and examining strong and weak reference counts">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

        println!(
            "branch strong = {}, weak = {}",
            Rc::strong_count(&amp;branch),
            Rc::weak_count(&amp;branch),
        );

        println!(
            "leaf strong = {}, weak = {}",
            Rc::strong_count(&amp;leaf),
            Rc::weak_count(&amp;leaf),
        );
    }

    println!("leaf의 부모 = {:?}", leaf.parent.borrow().upgrade());
    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );
}</code></pre></pre>
</Listing>
<p>leaf가 생성된 후, Rc<Node>의 강한 카운트는 1, 약한 카운트는 0입니다. 내부 스코프에서 branch를 생성하고 leaf와 연결합니다. 이때 카운트를 출력하면 branch의 Rc<Node>는 강한 카운트 1, 약한 카운트 1을 갖게 됩니다(leaf.parent가 Weak<Node>로 branch를 가리키기 때문입니다). leaf의 카운트를 출력하면 강한 카운트가 2가 되는 것을 볼 수 있습니다. branch가 이제 branch.children에 저장된 leaf의 Rc<Node> 클론을 가지고 있기 때문입니다. 하지만 약한 카운트는 여전히 0일 것입니다.</p>
<p>내부 스코프가 끝나면 branch는 스코프를 벗어나고 Rc<Node>의 강한 카운트가 0으로 감소하므로 Node가 드롭됩니다. leaf.parent의 약한 카운트 1은 Node의 드롭 여부에 아무런 영향을 미치지 않으므로 메모리 누수가 발생하지 않습니다!</p>
<p>스코프가 끝난 후 leaf의 부모에 접근하려고 하면 다시 None을 얻게 됩니다. 프로그램이 끝날 때 leaf의 Rc<Node>는 강한 카운트 1, 약한 카운트 0을 갖습니다. 이제 leaf 변수만이 Rc<Node>에 대한 유일한 참조이기 때문입니다.</p>
<p>카운트와 값 드롭을 관리하는 모든 로직은 Rc<T>와 Weak<T> 그리고 그들의 Drop 트레이트 구현에 내장되어 있습니다. Node 정의에서 자식에서 부모로의 관계가 Weak<T> 참조여야 한다고 지정함으로써, 순환 참조와 메모리 누수를 생성하지 않고 부모 노드가 자식 노드를 가리키고 그 반대도 가능하게 할 수 있습니다.</p>
<h2 id="요약-14"><a class="header" href="#요약-14">요약</a></h2>
<p>이 장에서는 일반 참조와 다른 보증 및 절충안을 만들기 위해 스마트 포인터를 사용하는 방법을 다루었습니다. <code>Box&lt;T&gt;</code> 타입은 알려진 크기를 가지며 힙에 할당된 데이터를 가리킵니다. <code>Rc&lt;T&gt;</code> 타입은 힙의 데이터에 대한 참조 수를 추적하여 데이터가 여러 소유자를 가질 수 있도록 합니다. 내부 가변성을 가진 <code>RefCell&lt;T&gt;</code> 타입은 불변 타입이 필요하지만 해당 타입의 내부 값을 변경해야 할 때 사용할 수 있는 타입을 제공하며, 컴파일 타임 대신 런타임에 빌림 규칙을 적용합니다.</p>
<p>또한 스마트 포인터의 많은 기능을 가능하게 하는 Deref와 Drop 트레이트에 대해서도 논의했습니다. 메모리 누수를 일으킬 수 있는 순환 참조와 Weak<T>를 사용하여 이를 방지하는 방법을 살펴보았습니다.</p>
<p>이 장이 흥미로웠고 자신만의 스마트 포인터를 구현하고 싶다면, 더 유용한 정보를 위해 <a href="../nomicon/index.html">“The Rustonomicon”</a>을 확인하세요.</p>
<p>다음으로, 러스트의 동시성에 대해 이야기할 것입니다. 몇 가지 새로운 스마트 포인터에 대해서도 배우게 될 것입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="두려움-없는-동시성"><a class="header" href="#두려움-없는-동시성">두려움 없는 동시성</a></h1>
<p>동시 프로그래밍을 안전하고 효율적으로 처리하는 것은 러스트의 또 다른 주요 목표입니다. 프로그램의 서로 다른 부분이 독립적으로 실행되는 _동시 프로그래밍_과 프로그램의 서로 다른 부분이 동시에 실행되는 _병렬 프로그래밍_은 더 많은 컴퓨터가 다중 프로세서를 활용함에 따라 점점 더 중요해지고 있습니다. 역사적으로 이러한 환경에서의 프로그래밍은 어렵고 오류가 발생하기 쉬웠습니다. 러스트는 그것을 바꾸기를 희망합니다.</p>
<p>처음에 러스트 팀은 메모리 안전성을 보장하는 것과 동시성 문제를 예방하는 것이 서로 다른 방법으로 해결해야 할 두 가지 별개의 과제라고 생각했습니다. 시간이 지남에 따라 팀은 소유권과 타입 시스템이 메모리 안전성 <em>그리고</em> 동시성 문제를 관리하는 데 도움이 되는 강력한 도구 세트라는 것을 발견했습니다! 소유권과 타입 검사를 활용함으로써 많은 동시성 오류는 러스트에서 런타임 오류가 아닌 컴파일 타임 오류가 됩니다. 따라서 런타임 동시성 버그가 발생하는 정확한 상황을 재현하기 위해 많은 시간을 소비하게 만드는 대신, 잘못된 코드는 컴파일을 거부하고 문제를 설명하는 오류를 제시할 것입니다. 결과적으로 코드가 프로덕션에 배포된 후가 아니라 작업하는 동안 코드를 수정할 수 있습니다. 우리는 러스트의 이러한 측면에 _두려움 없는 동시성_이라는 별명을 붙였습니다. 두려움 없는 동시성은 미묘한 버그가 없고 새로운 버그를 도입하지 않고 리팩터링하기 쉬운 코드를 작성할 수 있게 해줍니다.</p>
<blockquote>
<p>참고: 단순화를 위해, _동시적 및/또는 병렬적_이라고 더 정확하게 말하는 대신 많은 문제를 _동시적_이라고 지칭할 것입니다. 이 책이 동시성 및/또는 병렬성에 관한 책이었다면 더 구체적으로 설명했을 것입니다. 이 장에서는 우리가 _동시적_을 사용할 때마다 마음속으로 _동시적 및/또는 병렬적_으로 대체해 주세요.</p>
</blockquote>
<p>많은 언어들이 동시성 문제를 처리하기 위해 제공하는 솔루션에 대해 독단적입니다. 예를 들어, Erlang은 메시지 전달 동시성을 위한 우아한 기능을 가지고 있지만 스레드 간에 상태를 공유하는 방법은 모호합니다. 가능한 솔루션의 일부만 지원하는 것은 고수준 언어에 합리적인 전략입니다. 고수준 언어는 추상화를 얻기 위해 일부 제어를 포기함으로써 이점을 약속하기 때문입니다. 그러나 저수준 언어는 어떤 상황에서도 최상의 성능을 제공하는 솔루션을 제공하고 하드웨어에 대한 추상화가 더 적을 것으로 예상됩니다. 따라서 러스트는 상황과 요구 사항에 적합한 방식으로 문제를 모델링할 수 있는 다양한 도구를 제공합니다.</p>
<p>이 장에서 다룰 주제는 다음과 같습니다:</p>
<ul>
<li>동시에 여러 코드 조각을 실행하기 위해 스레드를 생성하는 방법</li>
<li>채널이 스레드 간에 메시지를 보내는 <em>메시지 전달</em> 동시성</li>
<li>여러 스레드가 어떤 데이터에 접근할 수 있는 <em>공유 상태</em> 동시성</li>
<li>러스트의 동시성 보장을 표준 라이브러리에서 제공하는 타입뿐만 아니라 사용자 정의 타입으로 확장하는 Sync와 Send 트레이트</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="스레드를-사용하여-코드를-동시에-실행하기"><a class="header" href="#스레드를-사용하여-코드를-동시에-실행하기">스레드를 사용하여 코드를 동시에 실행하기</a></h2>
<p>대부분의 최신 운영 체제에서 실행된 프로그램의 코드는 <em>프로세스</em> 내에서 실행되며, 운영 체제는 한 번에 여러 프로세스를 관리합니다. 프로그램 내에서 동시에 실행되는 독립적인 부분을 가질 수도 있습니다. 이러한 독립적인 부분을 실행하는 기능을 _스레드_라고 합니다. 예를 들어, 웹 서버는 동시에 여러 요청에 응답할 수 있도록 여러 스레드를 가질 수 있습니다.</p>
<p>여러 작업을 동시에 실행하기 위해 프로그램의 계산을 여러 스레드로 나누면 성능이 향상될 수 있지만 복잡성도 추가됩니다. 스레드는 동시에 실행될 수 있기 때문에 다른 스레드에 있는 코드의 부분이 실행되는 순서에 대한 내재적인 보장이 없습니다. 이는 다음과 같은 문제로 이어질 수 있습니다:</p>
<ul>
<li>스레드가 일관되지 않은 순서로 데이터나 리소스에 접근하는 경쟁 상태</li>
<li>두 스레드가 서로를 기다리며 두 스레드 모두 계속 진행하지 못하게 하는 교착 상태</li>
<li>특정 상황에서만 발생하고 안정적으로 재현하고 수정하기 어려운 버그</li>
</ul>
<p>러스트는 스레드 사용의 부정적인 영향을 완화하려고 시도하지만, 멀티스레드 환경에서의 프로그래밍은 여전히 신중한 고려가 필요하며 단일 스레드에서 실행되는 프로그램과는 다른 코드 구조를 요구합니다.</p>
<p>프로그래밍 언어는 몇 가지 다른 방식으로 스레드를 구현하며, 많은 운영 체제는 새로운 스레드를 생성하기 위해 언어가 호출할 수 있는 API를 제공합니다. 러스트 표준 라이브러리는 스레드 구현의 <em>1:1</em> 모델을 사용하는데, 이는 프로그램이 하나의 언어 스레드당 하나의 운영 체제 스레드를 사용한다는 것을 의미합니다. 1:1 모델과 다른 트레이드오프를 만드는 다른 스레딩 모델을 구현하는 크레이트들도 있습니다. (다음 장에서 보게 될 러스트의 비동기 시스템은 동시성에 대한 또 다른 접근 방식을 제공합니다.)</p>
<h3 id="spawn으로-새로운-스레드-생성하기"><a class="header" href="#spawn으로-새로운-스레드-생성하기"><code>spawn</code>으로 새로운 스레드 생성하기</a></h3>
<p>새로운 스레드를 생성하기 위해, 우리는 thread::spawn 함수를 호출하고 새로운 스레드에서 실행하고 싶은 코드를 담은 클로저(클로저에 대해서는 13장에서 이야기했습니다)를 전달합니다. 목록 16-1의 예제는 메인 스레드에서 일부 텍스트를 출력하고 새로운 스레드에서 다른 텍스트를 출력합니다:</p>
<Listing number="16-1" file-name="src/main.rs" caption="Creating a new thread to print one thing while the main thread prints something else">
<pre><pre class="playground"><code class="language-rust edition2021">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!("생성된 스레드에서 안녕하세요 숫자 {i}!");
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("메인 스레드에서 안녕하세요 숫자 {i}!");
        thread::sleep(Duration::from_millis(1));
    }
}</code></pre></pre>
</Listing>
<p>러스트 프로그램의 메인 스레드가 완료되면, 실행이 완료되었는지 여부와 상관없이 모든 생성된 스레드가 종료된다는 점에 유의하세요. 이 프로그램의 출력은 매번 조금씩 다를 수 있지만, 다음과 비슷하게 보일 것입니다:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the main thread!
hi number 1 from the spawned thread!
hi number 2 from the main thread!
hi number 2 from the spawned thread!
hi number 3 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the main thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
</code></pre>
<p>thread::sleep 호출은 스레드가 짧은 시간 동안 실행을 중지하도록 강제하여 다른 스레드가 실행될 수 있도록 합니다. 스레드들은 아마도 번갈아 가며 실행되겠지만, 보장되지는 않습니다: 운영 체제가 스레드를 어떻게 스케줄링하느냐에 달려 있습니다. 이 실행에서는 생성된 스레드의 print 문이 코드에 먼저 나타나지만 메인 스레드가 먼저 출력했습니다. 그리고 생성된 스레드에게 i가 9가 될 때까지 출력하라고 했지만, 메인 스레드가 종료되기 전에 5까지만 도달했습니다.</p>
<p>이 코드를 실행했을 때 메인 스레드의 출력만 보이거나 겹치는 부분이 보이지 않는다면, 운영 체제가 스레드 간 전환을 할 수 있는 기회를 더 많이 만들 수 있도록 범위의 숫자를 늘려보세요.</p>
<h3 id="join-핸들을-사용하여-모든-스레드가-끝나기를-기다리기"><a class="header" href="#join-핸들을-사용하여-모든-스레드가-끝나기를-기다리기"><code>join</code> 핸들을 사용하여 모든 스레드가 끝나기를 기다리기</a></h3>
<p>목록 16-1의 코드는 메인 스레드가 종료되어 대부분의 경우 생성된 스레드를 조기에 중지할 뿐만 아니라, 스레드가 실행되는 순서에 대한 보장이 없기 때문에 생성된 스레드가 실행될 것이라는 보장도 할 수 없습니다!</p>
<p>thread::spawn의 반환 값을 변수에 저장하여 생성된 스레드가 실행되지 않거나 조기에 종료되는 문제를 해결할 수 있습니다. thread::spawn의 반환 타입은 JoinHandle입니다. JoinHandle은 소유된 값으로, join 메서드를 호출하면 해당 스레드가 끝날 때까지 기다립니다. 목록 16-2는 목록 16-1에서 생성한 스레드의 JoinHandle을 사용하는 방법과 메인이 종료되기 전에 생성된 스레드가 완료되도록 join을 호출하는 방법을 보여줍니다:</p>
<Listing number="16-2" file-name="src/main.rs" caption="Saving a `JoinHandle` from `thread::spawn` to guarantee the thread is run to completion">
<pre><pre class="playground"><code class="language-rust edition2021">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("생성된 스레드에서 안녕하세요 숫자 {i}!");
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("메인 스레드에서 안녕하세요 숫자 {i}!");
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}</code></pre></pre>
</Listing>
<p>핸들에서 join을 호출하면 핸들이 나타내는 스레드가 종료될 때까지 현재 실행 중인 스레드를 차단합니다. 스레드를 _차단_한다는 것은 해당 스레드가 작업을 수행하거나 종료하지 못하도록 막는다는 것을 의미합니다. 메인 스레드의 for 루프 뒤에 join 호출을 넣었으므로, 목록 16-2를 실행하면 다음과 유사한 출력이 생성되어야 합니다:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 1 from the spawned thread!
hi number 3 from the main thread!
hi number 2 from the spawned thread!
hi number 4 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
</code></pre>
<p>두 스레드는 계속 번갈아 가며 실행되지만, 메인 스레드는 handle.join() 호출로 인해 기다리며 생성된 스레드가 완료될 때까지 종료되지 않습니다.</p>
<p>하지만 대신 handle.join()을 메인의 for 루프 앞으로 이동하면 어떤 일이 일어나는지 봅시다. 다음과 같이요:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("생성된 스레드에서 안녕하세요 숫자 {i}!");
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!("메인 스레드에서 안녕하세요 숫자 {i}!");
        thread::sleep(Duration::from_millis(1));
    }
}</code></pre></pre>
</Listing>
<p>메인 스레드는 생성된 스레드가 끝날 때까지 기다린 다음 for 루프를 실행하므로, 여기에 표시된 것처럼 출력은 더 이상 인터리브되지 않습니다:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the spawned thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 3 from the main thread!
hi number 4 from the main thread!
</code></pre>
<p>join이 호출되는 위치와 같은 작은 세부 사항이 스레드가 동시에 실행되는지 여부에 영향을 미칠 수 있습니다.</p>
<h3 id="스레드에-move-클로저-사용하기"><a class="header" href="#스레드에-move-클로저-사용하기">스레드에 <code>move</code> 클로저 사용하기</a></h3>
<p>우리는 종종 thread::spawn에 전달되는 클로저와 함께 move 키워드를 사용할 것입니다. 왜냐하면 클로저는 환경에서 사용하는 값의 소유권을 가져와서 해당 값의 소유권을 한 스레드에서 다른 스레드로 이전하기 때문입니다. 13장의 <a href="ch13-01-closures.html#capturing-references-or-moving-ownership">“참조 캡처 또는 소유권 이동”</a><!-- ignore -->에서 클로저 맥락에서의 move에 대해 논의했습니다. 이제 move와 thread::spawn 간의 상호 작용에 더 집중할 것입니다.</p>
<p>목록 16-1에서 thread::spawn에 전달하는 클로저는 인수를 받지 않는다는 점에 유의하세요. 생성된 스레드의 코드에서 메인 스레드의 데이터를 사용하지 않고 있습니다. 생성된 스레드에서 메인 스레드의 데이터를 사용하려면, 생성된 스레드의 클로저는 필요한 값을 캡처해야 합니다. 목록 16-3은 메인 스레드에서 벡터를 생성하고 생성된 스레드에서 이를 사용하려는 시도를 보여줍니다. 하지만 곧 보시겠지만 이것은 아직 작동하지 않을 것입니다.</p>
<Listing number="16-3" file-name="src/main.rs" caption="Attempting to use a vector created by the main thread in another thread">
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("여기 벡터가 있습니다: {v:?}");
    });

    handle.join().unwrap();
}</code></pre>
</Listing>
<p>클로저가 v를 사용하므로 v를 캡처하여 클로저 환경의 일부로 만듭니다. thread::spawn은 이 클로저를 새로운 스레드에서 실행하므로, 우리는 그 새로운 스레드 내부에서 v에 접근할 수 있어야 합니다. 하지만 이 예제를 컴파일하면 다음과 같은 에러를 얻습니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function
 --&gt; src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ 대여된 값 `v`보다 더 오래 살 수 있습니다
7 |         println!("Here's a vector: {v:?}");
  |                                     - `v`는 여기서 대여됩니다
  |
note: function requires argument type to outlive `'static`
 --&gt; src/main.rs:6:18
  |
6 |       let handle = thread::spawn(|| {
  |  __________________^
7 | |         println!("Here's a vector: {v:?}");
8 | |     });
  | |______^
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++

For more information about this error, try `rustc --explain E0373`.
error: could not compile `threads` (bin "threads") due to 1 previous error
</code></pre>
<p>러스트는 v를 캡처하는 방법을 _추론_하며, println!은 v에 대한 참조만 필요로 하므로 클로저는 v를 대여하려고 시도합니다. 하지만 문제가 있습니다. 러스트는 생성된 스레드가 얼마나 오래 실행될지 알 수 없으므로 v에 대한 참조가 항상 유효할지 알 수 없습니다.</p>
<p>목록 16-4는 유효하지 않게 될 v에 대한 참조를 가질 가능성이 더 높은 시나리오를 제공합니다:</p>
<Listing number="16-4" file-name="src/main.rs" caption="A thread with a closure that attempts to capture a reference to `v` from a main thread that drops `v`">
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("여기 벡터가 있습니다: {v:?}");
    });

    drop(v); // 안돼!

    handle.join().unwrap();
}</code></pre>
</Listing>
<p>러스트가 이 코드를 실행하도록 허용했다면, 생성된 스레드가 전혀 실행되지 않고 즉시 백그라운드로 전환될 가능성이 있습니다. 생성된 스레드는 내부에 v에 대한 참조를 가지고 있지만, 메인 스레드는 15장에서 논의한 drop 함수를 사용하여 즉시 v를 드롭합니다. 그러면 생성된 스레드가 실행을 시작할 때 v는 더 이상 유효하지 않으므로 이에 대한 참조도 유효하지 않습니다. 이런!</p>
<p>목록 16-3의 컴파일러 오류를 수정하기 위해 오류 메시지의 조언을 사용할 수 있습니다:</p>
<!-- manual-regeneration
after automatic regeneration, look at listings/ch16-fearless-concurrency/listing-16-03/output.txt and copy the relevant part
-->
<pre><code class="language-text">help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++
</code></pre>
<p>클로저 앞에 move 키워드를 추가함으로써, 러스트가 값을 대여해야 한다고 추론하게 하는 대신 클로저가 사용하는 값의 소유권을 가져오도록 강제합니다. 목록 16-5에 표시된 목록 16-3의 수정 사항은 우리가 의도한 대로 컴파일되고 실행될 것입니다:</p>
<Listing number="16-5" file-name="src/main.rs" caption="Using the `move` keyword to force a closure to take ownership of the values it uses">
<pre><pre class="playground"><code class="language-rust edition2021">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!("여기 벡터가 있습니다: {v:?}");
    });

    handle.join().unwrap();
}</code></pre></pre>
</Listing>
<p>move 클로저를 사용하여 메인 스레드가 drop을 호출한 목록 16-4의 코드를 수정하기 위해 같은 방법을 시도하고 싶을 수도 있습니다. 하지만 이 수정은 작동하지 않습니다. 목록 16-4가 하려는 작업은 다른 이유로 허용되지 않기 때문입니다. 클로저에 move를 추가하면 v를 클로저의 환경으로 이동시키게 되며, 더 이상 메인 스레드에서 drop을 호출할 수 없게 됩니다. 대신 다음과 같은 컴파일러 오류를 얻게 됩니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0382]: use of moved value: `v`
  --&gt; src/main.rs:10:10
   |
4  |     let v = vec![1, 2, 3];
   |         - `v`는 `Copy` 트레이트를 구현하지 않는 `Vec&lt;i32&gt;` 타입이므로 이동이 발생합니다
5  |
6  |     let handle = thread::spawn(move || {
   |                                ------- 여기서 값이 클로저로 이동됨
7  |         println!("Here's a vector: {v:?}");
   |                                     - 클로저 사용으로 인해 변수가 이동됨
...
10 |     drop(v); // oh no!
   |          ^ 이동 후 여기서 값이 사용됨

For more information about this error, try `rustc --explain E0382`.
error: could not compile `threads` (bin "threads") due to 1 previous error
</code></pre>
<p>러스트의 소유권 규칙이 우리를 다시 구했습니다! 목록 16-3의 코드에서 오류가 발생한 이유는 러스트가 보수적으로 스레드에 대해 v를 대여하기만 했기 때문이며, 이는 이론적으로 메인 스레드가 생성된 스레드의 참조를 무효화할 수 있음을 의미했습니다. 러스트에게 v의 소유권을 생성된 스레드로 이동하도록 지시함으로써, 우리는 러스트에게 메인 스레드가 더 이상 v를 사용하지 않을 것임을 보장합니다. 목록 16-4를 같은 방식으로 변경하면, 메인 스레드에서 v를 사용하려고 할 때 소유권 규칙을 위반하게 됩니다. move 키워드는 러스트의 보수적인 기본 대여를 재정의합니다. 그것은 우리가 소유권 규칙을 위반하도록 허용하지 않습니다.</p>
<p>스레드와 스레드 API에 대한 기본적인 이해를 바탕으로, 스레드로 무엇을 <em>할 수 있는지</em> 살펴봅시다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="메시지-전달을-사용하여-스레드-간-데이터-전송하기"><a class="header" href="#메시지-전달을-사용하여-스레드-간-데이터-전송하기">메시지 전달을 사용하여 스레드 간 데이터 전송하기</a></h2>
<p>안전한 동시성을 보장하기 위해 점점 더 인기 있는 접근 방식 중 하나는 _메시지 전달_입니다. 스레드나 액터가 데이터를 포함하는 메시지를 서로 보내 통신하는 방식입니다. <a href="https://golang.org/doc/effective_go.html#concurrency">Go 언어 문서</a>의 슬로건에 그 아이디어가 담겨 있습니다. “메모리를 공유하여 통신하지 말고, 통신하여 메모리를 공유하십시오.”</p>
<p>메시지 전송 동시성을 달성하기 위해 러스트의 표준 라이브러리는 채널 구현을 제공합니다. _채널_은 한 스레드에서 다른 스레드로 데이터가 전송되는 일반적인 프로그래밍 개념입니다.</p>
<p>프로그래밍에서의 채널을 개울이나 강과 같이 물이 흐르는 방향성 있는 수로라고 상상할 수 있습니다. 고무 오리 같은 것을 강에 넣으면 물길의 끝까지 하류로 이동할 것입니다.</p>
<p>채널에는 송신자와 수신자라는 두 부분이 있습니다. 송신자 부분은 고무 오리를 강에 넣는 상류 위치이고, 수신자 부분은 고무 오리가 도달하는 하류입니다. 코드의 한 부분은 보내려는 데이터로 송신자의 메서드를 호출하고, 다른 부분은 도착하는 메시지를 수신하는 쪽에서 확인합니다. 송신자 또는 수신자 중 하나가 드롭되면 채널이 _닫혔다_고 합니다.</p>
<p>여기서는 값을 생성하여 채널로 보내는 스레드 하나와 값을 받아 출력하는 다른 스레드를 가진 프로그램을 만들어볼 것입니다. 기능을 설명하기 위해 채널을 사용하여 스레드 간에 간단한 값을 보낼 것입니다. 이 기법에 익숙해지면 채팅 시스템이나 많은 스레드가 계산의 일부를 수행하고 결과를 집계하는 하나의 스레드로 부분을 보내는 시스템과 같이 서로 통신해야 하는 모든 스레드에 채널을 사용할 수 있습니다.</p>
<p>먼저, 목록 16-6에서는 채널을 생성하지만 아무것도 하지 않을 것입니다. 러스트가 채널을 통해 어떤 타입의 값을 보내고 싶은지 알 수 없기 때문에 아직 컴파일되지 않는다는 점에 유의하세요.</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
}</code></pre>
<p><span class="caption">목록 16-6: 채널을 생성하고 두 부분을 <code>tx</code>와 <code>rx</code>에 할당하기</span></p>
<p>mpsc::channel 함수를 사용하여 새 채널을 생성합니다. mpsc는 _다중 생산자, 단일 소비자(multiple producer, single consumer)_를 의미합니다. 간단히 말해, 러스트 표준 라이브러리가 채널을 구현하는 방식은 채널이 값을 생성하는 여러 <em>송신</em> 끝을 가질 수 있지만 해당 값을 소비하는 <em>수신</em> 끝은 하나만 가질 수 있음을 의미합니다. 여러 개울이 하나의 큰 강으로 함께 흐르는 것을 상상해 보세요. 어떤 개울로 보내진 것이든 결국에는 하나의 강에 도달하게 됩니다. 지금은 단일 생산자로 시작하겠지만, 이 예제가 작동하면 다중 생산자를 추가할 것입니다.</p>
<p>mpsc::channel 함수는 튜플을 반환하는데, 첫 번째 요소는 송신 끝인 송신자이고 두 번째 요소는 수신 끝인 수신자입니다. 약어 tx와 rx는 전통적으로 많은 분야에서 각각 _송신자(transmitter)_와 _수신자(receiver)_로 사용되므로, 각 끝을 나타내기 위해 변수 이름을 그렇게 지정합니다. 우리는 튜플을 구조 분해하는 패턴이 있는 let 문을 사용하고 있습니다. let 문에서의 패턴 사용과 구조 분해에 대해서는 19장에서 논의할 것입니다. 지금은 let 문을 이런 식으로 사용하는 것이 mpsc::channel이 반환한 튜플의 조각들을 추출하는 편리한 접근 방식이라는 것만 알아두세요.</p>
<p>송신 끝을 생성된 스레드로 이동시키고 하나의 문자열을 보내도록 하여 목록 16-7과 같이 생성된 스레드가 메인 스레드와 통신하도록 합시다. 이것은 강 상류에 고무 오리를 넣거나 한 스레드에서 다른 스레드로 채팅 메시지를 보내는 것과 같습니다.</p>
<Listing number="16-7" file-name="src/main.rs" caption="Moving `tx` to a spawned thread and sending “hi”">
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("안녕");
        tx.send(val).unwrap();
    });
}</code></pre></pre>
</Listing>
<p>다시 말하지만, 우리는 thread::spawn을 사용하여 새로운 스레드를 생성하고, 그 후 move를 사용하여 tx를 클로저로 이동시켜 생성된 스레드가 tx를 소유하게 합니다. 생성된 스레드는 채널을 통해 메시지를 보낼 수 있으려면 송신자를 소유해야 합니다.</p>
<p>송신자는 우리가 보내고 싶은 값을 취하는 send 메서드를 가지고 있습니다. send 메서드는 Result&lt;T, E&gt; 타입을 반환하므로, 수신자가 이미 드롭되어 값을 보낼 곳이 없다면 전송 작업은 에러를 반환할 것입니다. 이 예제에서는 에러가 발생할 경우 패닉을 일으키기 위해 unwrap을 호출하고 있습니다. 하지만 실제 애플리케이션에서는 적절하게 처리해야 합니다. 적절한 에러 처리 전략을 검토하려면 9장으로 돌아가세요.</p>
<p>목록 16-8에서는 메인 스레드의 수신자로부터 값을 얻을 것입니다. 이것은 강 끝의 물에서 고무 오리를 회수하거나 채팅 메시지를 받는 것과 같습니다.</p>
<Listing number="16-8" file-name="src/main.rs" caption="Receiving the value “hi” in the main thread and printing it">
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("안녕");
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("받음: {received}");
}</code></pre></pre>
</Listing>
<p>수신자에는 유용한 메서드 두 개가 있습니다. recv와 try_recv입니다. 우리는 _receive_의 줄임말인 recv를 사용하고 있는데, 이는 메인 스레드의 실행을 차단하고 채널로 값이 전송될 때까지 기다립니다. 값이 전송되면 recv는 Result&lt;T, E&gt;로 반환합니다. 송신자가 닫히면 recv는 더 이상 값이 오지 않을 것임을 알리기 위해 에러를 반환합니다.</p>
<p>try_recv 메서드는 차단하지 않고 대신 즉시 Result&lt;T, E&gt;를 반환합니다. 사용 가능한 메시지가 있으면 메시지를 보유한 Ok 값을, 이번에 메시지가 없으면 Err 값을 반환합니다. try_recv를 사용하는 것은 이 스레드가 메시지를 기다리는 동안 수행해야 할 다른 작업이 있는 경우 유용합니다. try_recv를 가끔 호출하고, 메시지가 있으면 처리하고, 그렇지 않으면 다시 확인할 때까지 잠시 다른 작업을 수행하는 루프를 작성할 수 있습니다.</p>
<p>이 예제에서는 단순화를 위해 recv를 사용했습니다. 메인 스레드가 메시지를 기다리는 것 외에는 할 일이 없으므로 메인 스레드를 차단하는 것이 적절합니다.</p>
<p>목록 16-8의 코드를 실행하면 메인 스레드에서 값이 출력되는 것을 볼 수 있습니다:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Got: hi
</code></pre>
<p>완벽하군요!</p>
<h3 id="채널과-소유권-이전"><a class="header" href="#채널과-소유권-이전">채널과 소유권 이전</a></h3>
<p>소유권 규칙은 안전한 동시성 코드를 작성하는 데 도움이 되기 때문에 메시지 전송에서 중요한 역할을 합니다. 동시 프로그래밍에서 오류를 방지하는 것은 러스트 프로그램 전반에 걸쳐 소유권에 대해 생각하는 것의 이점입니다. 채널과 소유권이 어떻게 함께 작동하여 문제를 방지하는지 보여주기 위해 실험을 해봅시다. 생성된 스레드에서 val 값을 채널로 보낸 _후_에 사용해 보겠습니다. 목록 16-9의 코드를 컴파일하여 이 코드가 허용되지 않는 이유를 확인해 보세요:</p>
<Listing number="16-9" file-name="src/main.rs" caption="Attempting to use `val` after we’ve sent it down the channel">
<pre><code class="language-rust ignore does_not_compile">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("안녕");
        tx.send(val).unwrap();
        println!("val은 {val}입니다");
    });

    let received = rx.recv().unwrap();
    println!("받음: {received}");
}</code></pre>
</Listing>
<p>여기서는 tx.send를 통해 채널로 보낸 후 val을 출력하려고 합니다. 이것을 허용하는 것은 나쁜 생각일 것입니다. 값이 다른 스레드로 전송되면, 우리가 값을 다시 사용하려고 하기 전에 그 스레드가 수정하거나 드롭할 수 있습니다. 잠재적으로 다른 스레드의 수정으로 인해 데이터가 일관성이 없거나 존재하지 않게 되어 오류나 예상치 못한 결과가 발생할 수 있습니다. 하지만 러스트는 목록 16-9의 코드를 컴파일하려고 하면 에러를 줍니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling message-passing v0.1.0 (file:///projects/message-passing)
error[E0382]: borrow of moved value: `val`
  --&gt; src/main.rs:10:26
   |
8  |         let val = String::from("hi");
   |             --- `val`은 `Copy` 트레이트를 구현하지 않는 `String` 타입이므로 이동이 발생합니다
9  |         tx.send(val).unwrap();
   |                 --- 여기서 값이 이동됨
10 |         println!("val is {val}");
   |                          ^^^^^ 이동 후 여기서 값이 대여됨
   |
   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0382`.
error: could not compile `message-passing` (bin "message-passing") due to 1 previous error
</code></pre>
<p>우리의 동시성 실수는 컴파일 타임 에러를 일으켰습니다. send 함수는 매개변수의 소유권을 가져가며, 값이 이동되면 수신자가 소유권을 가져갑니다. 이는 우리가 값을 보낸 후 실수로 다시 사용하는 것을 막아줍니다. 소유권 시스템이 모든 것이 괜찮은지 확인합니다.</p>
<h3 id="여러-값-보내기-및-수신자-대기-확인"><a class="header" href="#여러-값-보내기-및-수신자-대기-확인">여러 값 보내기 및 수신자 대기 확인</a></h3>
<p>목록 16-8의 코드는 컴파일되고 실행되었지만, 두 개의 별도 스레드가 채널을 통해 서로 이야기하고 있다는 것을 명확하게 보여주지는 않았습니다. 목록 16-10에서는 목록 16-8의 코드가 동시에 실행되고 있음을 증명할 몇 가지 수정을 가했습니다. 생성된 스레드는 이제 여러 메시지를 보내고 각 메시지 사이에 1초 동안 멈출 것입니다.</p>
<Listing number="16-10" file-name="src/main.rs" caption="Sending multiple messages and pausing between each">
<pre><code class="language-rust noplayground">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from("안녕"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("받음: {received}");
    }
}</code></pre>
</Listing>
<p>이번에는 생성된 스레드가 메인 스레드로 보내고 싶은 문자열 벡터를 가지고 있습니다. 이들을 반복하여 각각 개별적으로 보내고, 1초의 Duration 값을 사용하여 thread::sleep 함수를 호출함으로써 각 메시지 사이에서 멈춥니다.</p>
<p>메인 스레드에서는 더 이상 recv 함수를 명시적으로 호출하지 않습니다. 대신 rx를 반복자로 취급합니다. 수신된 각 값에 대해 이를 출력합니다. 채널이 닫히면 반복이 종료됩니다.</p>
<p>목록 16-10의 코드를 실행하면 각 줄 사이에 1초의 일시 중지와 함께 다음 출력이 표시되어야 합니다:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Got: hi
Got: from
Got: the
Got: thread
</code></pre>
<p>메인 스레드의 for 루프에는 일시 중지하거나 지연시키는 코드가 없으므로, 메인 스레드가 생성된 스레드로부터 값을 받기 위해 기다리고 있다는 것을 알 수 있습니다.</p>
<h3 id="송신자를-클론하여-다중-생산자-생성하기"><a class="header" href="#송신자를-클론하여-다중-생산자-생성하기">송신자를 클론하여 다중 생산자 생성하기</a></h3>
<p>앞서 mpsc가 _다중 생산자, 단일 소비자_의 약어라고 언급했습니다. mpsc를 사용하여 목록 16-10의 코드를 확장하여 모두 동일한 수신자로 값을 보내는 여러 스레드를 만들어 봅시다. 목록 16-11과 같이 송신자를 클론하여 그렇게 할 수 있습니다:</p>
<Listing number="16-11" file-name="src/main.rs" caption="Sending multiple messages from multiple producers">
<pre><code class="language-rust noplayground"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    // --생략--

    let (tx, rx) = mpsc::channel();

    let tx1 = tx.clone();
    thread::spawn(move || {
        let vals = vec![
            String::from("안녕"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx1.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from("more"),
            String::from("messages"),
            String::from("for"),
            String::from("you"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("받음: {received}");
    }

    // --생략--
<span class="boring">}</span></code></pre>
</Listing>
<p>이번에는 첫 번째 스레드를 생성하기 전에 송신자에 대해 <code>clone</code>을 호출합니다. 그러면 첫 번째 생성된 스레드에 전달할 수 있는 새로운 송신자가 생깁니다. 우리는 원래 송신자를 두 번째 생성된 스레드에 전달합니다. 이렇게 하면 각각 다른 메시지를 하나의 수신자로 보내는 두 개의 스레드가 생깁니다.</p>
<p>코드를 실행하면 다음과 비슷한 출력이 나타날 것입니다:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Got: hi
Got: more
Got: from
Got: messages
Got: for
Got: the
Got: thread
Got: you
</code></pre>
<p>시스템에 따라 다른 순서로 값을 볼 수도 있습니다. 이것이 동시성을 흥미롭게 만드는 동시에 어렵게 만드는 점입니다. <code>thread::sleep</code>을 사용하여 다른 스레드에 다양한 값을 주며 실험하면, 각 실행은 더욱 비결정적이 되어 매번 다른 출력을 생성할 것입니다.</p>
<p>채널이 어떻게 작동하는지 살펴보았으니, 이제 다른 동시성 방법을 살펴봅시다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="공유-상태-동시성"><a class="header" href="#공유-상태-동시성">공유 상태 동시성</a></h2>
<p>메시지 전달은 동시성을 처리하는 좋은 방법이지만 유일한 방법은 아닙니다. 또 다른 방법은 여러 스레드가 동일한 공유 데이터에 접근하는 것입니다. Go 언어 문서의 슬로건 중 이 부분을 다시 생각해 보세요: “메모리를 공유하여 통신하지 마십시오.”</p>
<p>메모리 공유를 통한 통신은 어떤 모습일까요? 또한, 메시지 전달 애호가들이 메모리 공유를 사용하지 말라고 경고하는 이유는 무엇일까요?</p>
<p>In a way, channels in any programming language are similar to single ownership, because once you transfer a value down a channel, you should no longer use that value. Shared memory concurrency is like multiple ownership: multiple threads can access the same memory location at the same time. As you saw in Chapter 15, where smart pointers made multiple ownership possible, multiple ownership can add complexity because these different owners need managing. Rust’s type system and ownership rules greatly assist in getting this management correct. For an example, let’s look at mutexes, one of the more common concurrency primitives for shared memory.</p>
<h3 id="뮤텍스를-사용하여-한-번에-한-스레드만-데이터에-접근하도록-허용하기"><a class="header" href="#뮤텍스를-사용하여-한-번에-한-스레드만-데이터에-접근하도록-허용하기">뮤텍스를 사용하여 한 번에 한 스레드만 데이터에 접근하도록 허용하기</a></h3>
<p>_뮤텍스(Mutex)_는 _상호 배제(mutual exclusion)_의 약자로, 뮤텍스는 주어진 시간에 하나의 스레드만 일부 데이터에 접근하도록 허용합니다. 뮤텍스의 데이터에 접근하려면, 스레드는 먼저 뮤텍스의 _잠금(lock)_을 획득하도록 요청하여 접근 권한을 원한다는 신호를 보내야 합니다. 잠금은 현재 누가 데이터에 대한 독점적 접근 권한을 가지고 있는지 추적하는 뮤텍스의 일부인 데이터 구조입니다. 따라서 뮤텍스는 잠금 시스템을 통해 보유하고 있는 데이터를 _보호(guarding)_한다고 설명됩니다.</p>
<p>뮤텍스는 사용하기 어렵다는 평판이 있습니다. 두 가지 규칙을 기억해야 하기 때문입니다:</p>
<ol>
<li>데이터를 사용하기 전에 락 획득을 시도해야 합니다.</li>
<li>뮤텍스가 보호하는 데이터 사용을 마치면, 다른 스레드가 락을 획득할 수 있도록 데이터의 잠금을 해제해야 합니다.</li>
</ol>
<p>For a real-world metaphor for a mutex, imagine a panel discussion at a conference with only one microphone. Before a panelist can speak, they have to ask or signal that they want to use the microphone. When they get the microphone, they can talk for as long as they want to and then hand the microphone to the next panelist who requests to speak. If a panelist forgets to hand the microphone off when they’re finished with it, no one else is able to speak. If management of the shared microphone goes wrong, the panel won’t work as planned!</p>
<p>뮤텍스 관리는 올바르게 수행하기가 믿을 수 없을 정도로 까다로울 수 있으며, 이것이 많은 사람들이 채널에 열광하는 이유입니다. 하지만 러스트의 타입 시스템과 소유권 규칙 덕분에 락과 잠금 해제를 잘못할 수 없습니다.</p>
<h4 id="mutext의-api"><a class="header" href="#mutext의-api"><code>Mutex&lt;T&gt;</code>의 API</a></h4>
<p>뮤텍스 사용법의 예로, 목록 16-12와 같이 단일 스레드 컨텍스트에서 뮤텍스를 사용하는 것으로 시작해 봅시다:</p>
<Listing number="16-12" file-name="src/main.rs" caption="Exploring the API of `Mutex<T>` in a single-threaded context for simplicity">
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!("m = {m:?}");
}</code></pre></pre>
</Listing>
<p>많은 타입들과 마찬가지로, 연관 함수 <code>new</code>를 사용하여 <code>Mutex&lt;T&gt;</code>를 생성합니다. 뮤텍스 내부의 데이터에 접근하기 위해, <code>lock</code> 메서드를 사용하여 락을 얻습니다. 이 호출은 현재 스레드를 차단하여 우리가 락을 가질 차례가 될 때까지 아무런 작업도 수행할 수 없게 합니다.</p>
<p>락을 보유한 다른 스레드가 패닉 상태에 빠지면 <code>lock</code> 호출은 실패할 것입니다. 그런 경우, 아무도 락을 얻을 수 없으므로, 우리는 그러한 상황에서 <code>unwrap</code>을 선택하여 이 스레드를 패닉 상태로 만들었습니다.</p>
<p>락을 얻은 후에는 반환 값(이 경우 <code>num</code>)을 내부 데이터에 대한 가변 참조로 취급할 수 있습니다. 타입 시스템은 <code>m</code>의 값을 사용하기 전에 락을 얻도록 보장합니다. <code>m</code>의 타입은 <code>i32</code>가 아니라 <code>Mutex&lt;i32&gt;</code>이므로, <code>i32</code> 값을 사용하려면 <code>lock</code>을 <em>반드시</em> 호출해야 합니다. 우리는 잊어버릴 수 없습니다; 그렇지 않으면 타입 시스템이 내부 <code>i32</code>에 접근하는 것을 허용하지 않을 것입니다.</p>
<p>As you might suspect, <code>Mutex&lt;T&gt;</code> is a smart pointer. More accurately, the call to <code>lock</code> <em>returns</em> a smart pointer called <code>MutexGuard</code>, wrapped in a <code>LockResult</code> that we handled with the call to <code>unwrap</code>. The <code>MutexGuard</code> smart pointer implements <code>Deref</code> to point at our inner data; the smart pointer also has a <code>Drop</code> implementation that releases the lock automatically when a <code>MutexGuard</code> goes out of scope, which happens at the end of the inner scope. As a result, we don’t risk forgetting to release the lock and blocking the mutex from being used by other threads, because the lock release happens automatically.</p>
<p>락을 드롭한 후 뮤텍스 값을 출력하여 내부 i32를 6으로 변경할 수 있었음을 확인할 수 있습니다.</p>
<h4 id="여러-스레드-간에-mutext-공유하기"><a class="header" href="#여러-스레드-간에-mutext-공유하기">여러 스레드 간에 <code>Mutex&lt;T&gt;</code> 공유하기</a></h4>
<p>이제 Mutex<T>를 사용하여 여러 스레드 간에 값을 공유해 봅시다. 10개의 스레드를 생성하고 각각 카운터 값을 1씩 증가시켜 카운터가 0에서 10이 되도록 할 것입니다. 목록 16-13의 다음 예제는 컴파일러 오류를 발생시킬 것이며, 우리는 그 오류를 사용하여 Mutex<T> 사용법과 러스트가 이를 올바르게 사용하도록 돕는 방법에 대해 더 배울 것입니다.</p>
<Listing number="16-13" file-name="src/main.rs" caption="Ten threads each increment a counter guarded by a `Mutex<T>`">
<pre><code class="language-rust ignore does_not_compile">use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("결과: {}", *counter.lock().unwrap());
}</code></pre>
</Listing>
<p>We create a <code>counter</code> variable to hold an <code>i32</code> inside a <code>Mutex&lt;T&gt;</code>, as we did in Listing 16-12. Next, we create 10 threads by iterating over a range of numbers. We use <code>thread::spawn</code> and give all the threads the same closure: one that moves the counter into the thread, acquires a lock on the <code>Mutex&lt;T&gt;</code> by calling the <code>lock</code> method, and then adds 1 to the value in the mutex. When a thread finishes running its closure, <code>num</code> will go out of scope and release the lock so another thread can acquire it.</p>
<p>메인 스레드에서 우리는 모든 조인 핸들을 수집합니다. 그런 다음 목록 16-2에서 했던 것처럼, 각 핸들에 대해 <code>join</code>을 호출하여 모든 스레드가 종료되었는지 확인합니다. 그 시점에서 메인 스레드는 락을 얻고 이 프로그램의 결과를 출력할 것입니다.</p>
<p>우리는 이 예제가 컴파일되지 않을 것이라고 암시했습니다. 이제 그 이유를 알아봅시다!</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0382]: borrow of moved value: `counter`
  --&gt; src/main.rs:21:29
   |
5  |     let counter = Mutex::new(0);
   |         ------- `counter`는 `Copy` 트레이트를 구현하지 않는 `Mutex&lt;i32&gt;` 타입이므로 이동이 발생합니다
...
8  |     for _ in 0..10 {
   |     -------------- 이 루프 안에서
9  |         let handle = thread::spawn(move || {
   |                                    ------- 여기서 값이 클로저로 이동됨, 루프의 이전 반복에서
...
21 |     println!("Result: {}", *counter.lock().unwrap());
   |                             ^^^^^^^ 이동 후 여기서 값이 대여됨
   |
help: consider moving the expression out of the loop so it is only moved once
   |
8  ~     let mut value = counter.lock();
9  ~     for _ in 0..10 {
10 |         let handle = thread::spawn(move || {
11 ~             let mut num = value.unwrap();
   |

For more information about this error, try `rustc --explain E0382`.
error: could not compile `shared-state` (bin "shared-state") due to 1 previous error
</code></pre>
<p>에러 메시지는 <code>counter</code> 값이 루프의 이전 반복에서 이동되었다고 말합니다. 러스트는 <code>counter</code>의 소유권을 여러 스레드로 이동할 수 없다고 말하고 있습니다. 15장에서 논의했던 다중 소유권 방법으로 컴파일러 에러를 수정해 봅시다.</p>
<h4 id="다중-스레드와-다중-소유권"><a class="header" href="#다중-스레드와-다중-소유권">다중 스레드와 다중 소유권</a></h4>
<p>15장에서 우리는 스마트 포인터 <code>Rc&lt;T&gt;</code>를 사용하여 참조 카운팅 값을 생성함으로써 값에 여러 소유자를 부여했습니다. 여기서도 똑같이 하고 무슨 일이 일어나는지 봅시다. 목록 16-14에서는 <code>Mutex&lt;T&gt;</code>를 <code>Rc&lt;T&gt;</code>로 감싸고, 소유권을 스레드로 이동하기 전에 <code>Rc&lt;T&gt;</code>를 클론할 것입니다.</p>
<Listing number="16-14" file-name="src/main.rs" caption="Attempting to use `Rc<T>` to allow multiple threads to own the `Mutex<T>`">
<pre><code class="language-rust ignore does_not_compile">use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("결과: {}", *counter.lock().unwrap());
}</code></pre>
</Listing>
<p>다시 한번, 컴파일하면… 다른 오류들이 발생합니다! 컴파일러가 우리에게 많은 것을 가르쳐주고 있습니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0277]: `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
   --&gt; src/main.rs:11:36
    |
11  |           let handle = thread::spawn(move || {
    |                        ------------- ^------
    |                        |             |
    |  ______________________|_____________이 `{closure@src/main.rs:11:36: 11:43}` 안에서
    | |                      |
    | |                      이 호출에 의해 도입된 바운드에 의해 요구됨
12  | |             let mut num = counter.lock().unwrap();
13  | |
14  | |             *num += 1;
15  | |         });
    | |_________^ `Rc&lt;Mutex&lt;i32&gt;&gt;`는 스레드 간에 안전하게 보내질 수 없습니다
    |
    = help: within `{closure@src/main.rs:11:36: 11:43}`, the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;`, which is required by `{closure@src/main.rs:11:36: 11:43}: Send`
note: required because it's used within this closure
   --&gt; src/main.rs:11:36
    |
11  |         let handle = thread::spawn(move || {
    |                                    ^^^^^^^
note: required by a bound in `spawn`
   --&gt; file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/std/src/thread/mod.rs:675:8
    |
672 | pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    |        ----- 이 함수의 바운드에 의해 요구됨
...
675 |     F: Send + 'static,
    |        ^^^^ spawn의 이 바운드에 의해 요구됨

For more information about this error, try `rustc --explain E0277`.
error: could not compile `shared-state` (bin "shared-state") due to 1 previous error
</code></pre>
<p>와, 에러 메시지가 정말 장황하네요! 집중해야 할 중요한 부분은 여기 있습니다: <code>`Rc&lt;Mutex&lt;i32&gt;&gt;`는 스레드 간에 안전하게 보내질 수 없습니다</code>. 컴파일러는 또한 그 이유를 말해주고 있습니다: <code>`Rc&lt;Mutex&lt;i32&gt;&gt;`에 대해 `Send` 트레이트가 구현되지 않았습니다</code>. 다음 절에서 <code>Send</code>에 대해 이야기할 것입니다. 이것은 우리가 스레드와 함께 사용하는 타입이 동시성 상황에서 사용되도록 의도되었음을 보장하는 트레이트 중 하나입니다.</p>
<p>불행히도, <code>Rc&lt;T&gt;</code>는 스레드 간에 공유하기에 안전하지 않습니다. <code>Rc&lt;T&gt;</code>가 참조 카운트를 관리할 때, <code>clone</code> 호출마다 카운트를 더하고 각 클론이 드롭될 때 카운트를 뺍니다. 하지만 카운트 변경이 다른 스레드에 의해 중단되지 않도록 보장하기 위한 어떠한 동시성 기본 요소도 사용하지 않습니다. 이는 잘못된 카운트로 이어질 수 있으며, 이는 결과적으로 메모리 누수나 우리가 사용을 마치기 전에 값이 드롭되는 미묘한 버그로 이어질 수 있습니다. 우리에게 필요한 것은 <code>Rc&lt;T&gt;</code>와 똑같지만 스레드 안전한 방식으로 참조 카운트를 변경하는 타입입니다.</p>
<h4 id="arct를-이용한-원자적-참조-카운팅"><a class="header" href="#arct를-이용한-원자적-참조-카운팅"><code>Arc&lt;T&gt;</code>를 이용한 원자적 참조 카운팅</a></h4>
<p>다행히도 <code>Arc&lt;T&gt;</code>는 동시성 상황에서 사용하기에 안전한 <code>Rc&lt;T&gt;</code>와 같은 타입_입니다_. _a_는 <em>atomic</em>(원자적)을 의미하며, 이는 <em>원자적으로 참조 카운팅되는</em> 타입임을 의미합니다. 원자적 요소는 여기서 자세히 다루지 않을 추가적인 종류의 동시성 기본 요소입니다. 자세한 내용은 <a href="../std/sync/atomic/index.html"><code>std::sync::atomic</code></a><!-- ignore -->에 대한 표준 라이브러리 문서를 참조하세요. 지금은 원자적 요소가 기본 타입처럼 작동하지만 스레드 간에 공유하기에 안전하다는 것만 알면 됩니다.</p>
<p>그러면 왜 모든 기본 타입이 원자적이지 않은지, 그리고 왜 표준 라이브러리 타입들이 기본적으로 <code>Arc&lt;T&gt;</code>를 사용하도록 구현되지 않았는지 궁금할 수 있습니다. 그 이유는 스레드 안전성에는 정말 필요할 때만 지불하고 싶은 성능 비용이 따르기 때문입니다. 단일 스레드 내의 값에 대해서만 연산을 수행하는 경우, 원자적 요소가 제공하는 보장을 강제할 필요가 없다면 코드가 더 빠르게 실행될 수 있습니다.</p>
<p>예제로 돌아가 봅시다: <code>Arc&lt;T&gt;</code>와 <code>Rc&lt;T&gt;</code>는 동일한 API를 가지고 있으므로, <code>use</code> 라인, <code>new</code> 호출, 그리고 <code>clone</code> 호출을 변경하여 프로그램을 수정합니다. 목록 16-15의 코드는 마침내 컴파일되고 실행될 것입니다:</p>
<Listing number="16-15" file-name="src/main.rs" caption="Using an `Arc<T>` to wrap the `Mutex<T>` to be able to share ownership across multiple threads">
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("결과: {}", *counter.lock().unwrap());
}</code></pre></pre>
</Listing>
<p>이 코드는 다음을 출력합니다:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Result: 10
</code></pre>
<p>해냈습니다! 0에서 10까지 셌는데, 별로 인상적이지 않아 보일 수도 있지만, <code>Mutex&lt;T&gt;</code>와 스레드 안전성에 대해 많은 것을 가르쳐주었습니다. 카운터를 증가시키는 것보다 더 복잡한 연산을 수행하기 위해 이 프로그램의 구조를 사용할 수도 있습니다. 이 전략을 사용하여 계산을 독립적인 부분으로 나누고, 그 부분들을 스레드에 분산시킨 다음, <code>Mutex&lt;T&gt;</code>를 사용하여 각 스레드가 자신의 부분으로 최종 결과를 업데이트하게 할 수 있습니다.</p>
<p>단순한 숫자 연산을 수행하는 경우, <a href="../std/sync/atomic/index.html">표준 라이브러리의 <code>std::sync::atomic</code> 모듈</a><!-- ignore -->에서 제공하는 <code>Mutex&lt;T&gt;</code> 타입보다 더 간단한 타입들이 있다는 점에 유의하세요. 이 타입들은 기본 타입에 대한 안전하고, 동시적이며, 원자적인 접근을 제공합니다. 우리는 <code>Mutex&lt;T&gt;</code>가 어떻게 작동하는지에 집중하기 위해 이 예제에서 기본 타입과 함께 <code>Mutex&lt;T&gt;</code>를 사용하는 것을 선택했습니다.</p>
<h3 id="refcelltrct와-mutextarct-간의-유사점"><a class="header" href="#refcelltrct와-mutextarct-간의-유사점"><code>RefCell&lt;T&gt;</code>/<code>Rc&lt;T&gt;</code>와 <code>Mutex&lt;T&gt;</code>/<code>Arc&lt;T&gt;</code> 간의 유사점</a></h3>
<p>여러분이 <code>counter</code>가 불변이지만 내부의 값에 대한 가변 참조를 얻을 수 있다는 것을 눈치챘을 수도 있습니다. 이는 <code>Cell</code> 계열이 그러하듯 <code>Mutex&lt;T&gt;</code>가 내부 가변성을 제공한다는 것을 의미합니다. 15장에서 <code>Rc&lt;T&gt;</code> 내부의 내용을 변경할 수 있도록 <code>RefCell&lt;T&gt;</code>를 사용했던 것과 같은 방식으로, <code>Arc&lt;T&gt;</code> 내부의 내용을 변경하기 위해 <code>Mutex&lt;T&gt;</code>를 사용합니다.</p>
<p>주목해야 할 또 다른 세부 사항은 <code>Mutex&lt;T&gt;</code>를 사용할 때 러스트가 모든 종류의 로직 에러로부터 여러분을 보호할 수는 없다는 것입니다. 15장에서 <code>Rc&lt;T&gt;</code>를 사용하는 것이 두 <code>Rc&lt;T&gt;</code> 값이 서로를 참조하여 메모리 누수를 일으키는 참조 순환을 생성할 위험이 있었음을 상기해 보세요. 마찬가지로, <code>Mutex&lt;T&gt;</code>는 _데드락(deadlocks)_을 생성할 위험이 있습니다. 이는 어떤 작업이 두 리소스를 잠가야 하는데 두 스레드가 각각 락 중 하나를 얻어 서로를 영원히 기다리게 될 때 발생합니다. 데드락에 관심이 있다면 데드락이 있는 러스트 프로그램을 만들어 보세요; 그런 다음 어떤 언어로든 뮤텍스에 대한 데드락 완화 전략을 조사하고 러스트에서 구현해 보세요. <code>Mutex&lt;T&gt;</code>와 <code>MutexGuard</code>에 대한 표준 라이브러리 API 문서는 유용한 정보를 제공합니다.</p>
<p><code>Send</code>와 <code>Sync</code> 트레이트 및 이를 커스텀 타입과 함께 사용하는 방법에 대해 이야기하며 이 장을 마무리하겠습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sync와-send-트레이트로-확장-가능한-동시성"><a class="header" href="#sync와-send-트레이트로-확장-가능한-동시성"><code>Sync</code>와 <code>Send</code> 트레이트로 확장 가능한 동시성</a></h2>
<p>흥미롭게도, 러스트 언어는 동시성 기능이 <em>거의</em> 없습니다. 이 장에서 지금까지 이야기한 거의 모든 동시성 기능은 언어가 아닌 표준 라이브러리의 일부였습니다. 동시성을 처리하는 여러분의 옵션은 언어나 표준 라이브러리에 제한되지 않습니다; 여러분은 자신만의 동시성 기능을 작성하거나 다른 사람들이 작성한 것을 사용할 수 있습니다.</p>
<p>하지만 두 가지 동시성 개념은 언어에 내장되어 있습니다: <code>std::marker</code> 트레이트인 <code>Sync</code>와 <code>Send</code>입니다.</p>
<h3 id="send를-사용하여-스레드-간-소유권-이동-허용하기"><a class="header" href="#send를-사용하여-스레드-간-소유권-이동-허용하기"><code>Send</code>를 사용하여 스레드 간 소유권 이동 허용하기</a></h3>
<p><code>Send</code> 마커 트레이트는 <code>Send</code>를 구현한 타입의 값의 소유권이 스레드 간에 이동될 수 있음을 나타냅니다. 거의 모든 러스트 타입은 <code>Send</code>이지만, <code>Rc&lt;T&gt;</code>를 포함한 몇 가지 예외가 있습니다: <code>Rc&lt;T&gt;</code> 값을 클론하여 클론의 소유권을 다른 스레드로 전송하려고 하면 두 스레드가 동시에 참조 카운트를 업데이트할 수 있기 때문에 <code>Send</code>가 될 수 없습니다. 이러한 이유로 <code>Rc&lt;T&gt;</code>는 스레드 안전 성능 페널티를 지불하고 싶지 않은 단일 스레드 상황에서 사용하도록 구현되었습니다.</p>
<p>따라서, 러스트의 타입 시스템과 트레이트 바운드는 여러분이 실수로 <code>Rc&lt;T&gt;</code> 값을 스레드 간에 안전하지 않게 보내는 일이 없도록 보장합니다. 목록 16-14에서 이를 시도했을 때, 우리는 <code>the trait Send is not implemented for Rc&lt;Mutex&lt;i32&gt;&gt;</code>라는 에러를 얻었습니다. <code>Send</code>인 <code>Arc&lt;T&gt;</code>로 전환했을 때 코드는 컴파일되었습니다.</p>
<p>Any type composed entirely of <code>Send</code> types is automatically marked as <code>Send</code> as well. Almost all primitive types are <code>Send</code>, aside from raw pointers, which we’ll discuss in Chapter 20.</p>
<h3 id="sync를-사용하여-여러-스레드에서의-접근-허용하기"><a class="header" href="#sync를-사용하여-여러-스레드에서의-접근-허용하기"><code>Sync</code>를 사용하여 여러 스레드에서의 접근 허용하기</a></h3>
<p><code>Sync</code> 마커 트레이트는 <code>Sync</code>를 구현한 타입이 여러 스레드에서 참조되기에 안전함을 나타냅니다. 즉, <code>&amp;T</code>(<code>T</code>에 대한 불변 참조)가 <code>Send</code>라면(참조가 다른 스레드로 안전하게 보내질 수 있다는 의미), <code>T</code>는 <code>Sync</code>입니다. <code>Send</code>와 마찬가지로 기본 타입은 <code>Sync</code>이며, <code>Sync</code>인 타입들로만 구성된 타입도 <code>Sync</code>입니다.</p>
<p>스마트 포인터 <code>Rc&lt;T&gt;</code>는 <code>Send</code>가 아닌 것과 같은 이유로 <code>Sync</code>도 아닙니다. <code>RefCell&lt;T&gt;</code> 타입(15장에서 다루었습니다)과 관련된 <code>Cell&lt;T&gt;</code> 계열의 타입들은 <code>Sync</code>가 아닙니다. <code>RefCell&lt;T&gt;</code>가 런타임에 수행하는 대여 검사 구현은 스레드 안전하지 않습니다. 스마트 포인터 <code>Mutex&lt;T&gt;</code>는 <code>Sync</code>이며, <a href="ch16-03-shared-state.html#sharing-a-mutext-between-multiple-threads">"여러 스레드 간에 <code>Mutex&lt;T&gt;</code> 공유하기"</a><!-- ignore -->에서 본 것처럼 여러 스레드와 접근을 공유하는 데 사용될 수 있습니다.</p>
<h3 id="send와-sync를-수동으로-구현하는-것은-안전하지-않습니다"><a class="header" href="#send와-sync를-수동으로-구현하는-것은-안전하지-않습니다"><code>Send</code>와 <code>Sync</code>를 수동으로 구현하는 것은 안전하지 않습니다</a></h3>
<p><code>Send</code>와 <code>Sync</code> 트레이트로 구성된 타입은 자동으로 <code>Send</code>와 <code>Sync</code>이기도 하므로, 우리는 그러한 트레이트를 수동으로 구현할 필요가 없습니다. 마커 트레이트로서, 구현할 메서드조차 없습니다. 단지 동시성과 관련된 불변성을 강제하는 데 유용할 뿐입니다.</p>
<p>이 트레이트들을 수동으로 구현하는 것은 안전하지 않은 러스트 코드를 구현하는 것을 포함합니다. 20장에서 안전하지 않은 러스트 코드를 사용하는 것에 대해 이야기할 것입니다; 지금으로서 중요한 정보는 <code>Send</code>와 <code>Sync</code> 부분으로 구성되지 않은 새로운 동시성 타입을 구축하는 것은 안전 보장을 유지하기 위해 신중한 생각이 필요하다는 것입니다. <a href="../nomicon/index.html">“The Rustonomicon”</a>에는 이러한 보장과 이를 유지하는 방법에 대한 더 많은 정보가 있습니다.</p>
<h2 id="요약-15"><a class="header" href="#요약-15">요약</a></h2>
<p>이 책에서 동시성을 보는 것은 이것이 마지막이 아닙니다. 다음 장 전체가 비동기 프로그래밍에 초점을 맞추고 있으며, 21장의 프로젝트는 여기서 논의된 작은 예제들보다 더 현실적인 상황에서 이 장의 개념들을 사용할 것입니다.</p>
<p>앞서 언급했듯이, 러스트가 동시성을 처리하는 방법 중 언어의 일부인 것은 거의 없기 때문에, 많은 동시성 솔루션이 크레이트로 구현되어 있습니다. 이들은 표준 라이브러리보다 더 빠르게 발전하므로, 멀티스레드 상황에서 사용할 현재의 최첨단 크레이트를 온라인에서 검색해 보세요.</p>
<p>러스트 표준 라이브러리는 메시지 전달을 위한 채널과 <code>Mutex&lt;T&gt;</code> 및 <code>Arc&lt;T&gt;</code>와 같은, 동시성 컨텍스트에서 사용하기에 안전한 스마트 포인터 타입을 제공합니다. 타입 시스템과 대여 검사기는 이러한 솔루션을 사용하는 코드가 데이터 레이스나 유효하지 않은 참조로 끝나지 않도록 보장합니다. 일단 코드를 컴파일하면, 다른 언어에서 흔히 발생하는 추적하기 어려운 버그 없이 멀티스레드에서 행복하게 실행될 것임을 확신할 수 있습니다. 동시 프로그래밍은 더 이상 두려워할 개념이 아닙니다: 나아가서 두려움 없이 프로그램을 동시적으로 만드세요!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="비동기-프로그래밍의-기초-async-await-future-stream"><a class="header" href="#비동기-프로그래밍의-기초-async-await-future-stream">비동기 프로그래밍의 기초: Async, Await, Future, Stream</a></h1>
<p>우리가 컴퓨터에게 요청하는 많은 작업은 완료하는 데 시간이 걸릴 수 있습니다. 오래 걸리는 프로세스가 완료되기를 기다리는 동안 다른 작업을 할 수 있다면 좋을 것입니다. 현대 컴퓨터는 한 번에 하나 이상의 작업을 수행하기 위한 두 가지 기술인 병렬성과 동시성을 제공합니다. 하지만 병렬 또는 동시 작업을 포함하는 프로그램을 작성하기 시작하면, 작업이 시작된 순서대로 순차적으로 완료되지 않을 수 있는 <em>비동기 프로그래밍</em> 고유의 새로운 과제에 빠르게 직면하게 됩니다. 이 장은 16장의 병렬성 및 동시성을 위한 스레드 사용을 바탕으로 비동기 프로그래밍에 대한 대안적 접근 방식인 러스트의 Future, Stream, 이를 지원하는 <code>async</code> 및 <code>await</code> 문법, 그리고 비동기 작업 간의 관리 및 조정을 위한 도구를 소개합니다.</p>
<p>예를 들어보겠습니다. 가족 축하 행사를 촬영한 비디오를 내보내기(export)한다고 가정해 봅시다. 이 작업은 몇 분에서 몇 시간까지 걸릴 수 있습니다. 비디오 내보내기는 가능한 한 많은 CPU와 GPU 파워를 사용할 것입니다. 만약 여러분에게 CPU 코어가 하나뿐이고 운영 체제가 내보내기가 완료될 때까지 일시 중지하지 않는다면—즉, 내보내기를 <em>동기적으로</em> 실행한다면—그 작업이 실행되는 동안 컴퓨터에서 다른 어떤 것도 할 수 없을 것입니다. 그것은 꽤 실망스러운 경험이 될 것입니다. 다행히도, 여러분의 컴퓨터 운영 체제는 내보내기 작업을 자주, 보이지 않게 중단시켜 여러분이 동시에 다른 작업을 할 수 있도록 할 수 있으며, 실제로 그렇게 합니다.</p>
<p>이제 다른 사람이 공유한 비디오를 다운로드한다고 가정해 봅시다. 이 또한 시간이 걸릴 수 있지만 CPU 시간을 많이 차지하지는 않습니다. 이 경우, CPU는 데이터가 네트워크로부터 도착할 때까지 기다려야 합니다. 데이터가 도착하기 시작하면 읽기 시작할 수 있지만, 모든 데이터가 나타날 때까지 시간이 좀 걸릴 수 있습니다. 데이터가 모두 존재하더라도 비디오가 꽤 크다면 모두 로드하는 데 적어도 1~2초가 걸릴 수 있습니다. 별것 아닌 것처럼 들릴 수 있지만, 초당 수십억 번의 연산을 수행할 수 있는 현대 프로세서에게는 매우 긴 시간입니다. 다시 말하지만, 운영 체제는 네트워크 호출이 완료되기를 기다리는 동안 CPU가 다른 작업을 수행할 수 있도록 프로그램을 보이지 않게 중단시킬 것입니다.</p>
<p>비디오 내보내기는 <em>CPU-bound</em> 또는 <em>compute-bound</em>(계산 중심) 작업의 예입니다. 이는 CPU나 GPU 내에서 컴퓨터의 잠재적 데이터 처리 속도와 그 속도 중 얼마나 많은 부분을 작업에 할당할 수 있는지에 의해 제한됩니다. 비디오 다운로드는 <em>IO-bound</em>(입출력 중심) 작업의 예입니다. 왜냐하면 컴퓨터의 <em>입력 및 출력</em> 속도에 의해 제한되기 때문입니다. 데이터가 네트워크를 통해 전송될 수 있는 속도만큼만 빠르게 진행될 수 있습니다.</p>
<p>이 두 예제 모두에서 운영 체제의 보이지 않는 인터럽트는 일종의 동시성을 제공합니다. 하지만 그 동시성은 전체 프로그램 수준에서만 발생합니다: 운영 체제는 다른 프로그램이 작업을 수행할 수 있도록 한 프로그램을 중단시킵니다. 많은 경우, 우리는 운영 체제보다 훨씬 더 세밀한 수준에서 우리 프로그램을 이해하기 때문에, 운영 체제가 볼 수 없는 동시성 기회를 발견할 수 있습니다.</p>
<p>예를 들어, 파일 다운로드를 관리하는 도구를 만들고 있다면, 하나의 다운로드를 시작해도 UI가 잠기지 않도록 프로그램을 작성할 수 있어야 하며, 사용자는 동시에 여러 다운로드를 시작할 수 있어야 합니다. 하지만 네트워크와 상호 작용하기 위한 많은 운영 체제 API는 <em>블로킹(blocking)</em> 방식입니다; 즉, 처리 중인 데이터가 완전히 준비될 때까지 프로그램의 진행을 차단합니다.</p>
<blockquote>
<p>Note: This is how <em>most</em> function calls work, if you think about it. However, the term <em>blocking</em> is usually reserved for function calls that interact with files, the network, or other resources on the computer, because those are the cases where an individual program would benefit from the operation being <em>non</em>-blocking.</p>
</blockquote>
<p>각 파일을 다운로드하기 위해 전용 스레드를 생성함으로써 메인 스레드가 차단되는 것을 피할 수 있습니다. 하지만 그러한 스레드의 오버헤드는 결국 문제가 될 것입니다. 애초에 호출이 차단되지 않는 것이 바람직할 것입니다. 또한 다음과 같이 블로킹 코드에서 사용하는 것과 같은 직접적인 스타일로 작성할 수 있다면 더 좋을 것입니다:</p>
<pre><code class="language-rust ignore does_not_compile">let data = fetch_data_from(url).await;
println!("{data}");</code></pre>
<p>이것이 바로 러스트의 <em>async</em>(_asynchronous_의 줄임말) 추상화가 우리에게 제공하는 것입니다. 이 장에서는 다음 주제들을 다루며 비동기에 대한 모든 것을 배울 것입니다:</p>
<ul>
<li>러스트의 <code>async</code>와 <code>await</code> 문법을 사용하는 방법</li>
<li>16장에서 살펴본 것과 동일한 과제를 해결하기 위해 비동기 모델을 사용하는 방법</li>
<li>멀티스레딩과 비동기가 어떻게 상호 보완적인 솔루션을 제공하며, 많은 경우에 이들을 결합할 수 있는지</li>
</ul>
<p>하지만 실제로 비동기가 어떻게 작동하는지 보기 전에, 병렬성과 동시성의 차이에 대해 논의하기 위해 잠시 우회해야 합니다.</p>
<h3 id="병렬성과-동시성"><a class="header" href="#병렬성과-동시성">병렬성과 동시성</a></h3>
<p>지금까지 우리는 병렬성과 동시성을 거의 상호 교환 가능한 것으로 취급해 왔습니다. 이제 작업을 시작하면서 그 차이가 드러날 것이므로, 이들을 더 정확하게 구별해야 합니다.</p>
<p>팀이 소프트웨어 프로젝트의 작업을 나누는 다양한 방법을 생각해 보세요. 한 구성원에게 여러 작업을 할당하거나, 각 구성원에게 하나의 작업을 할당하거나, 두 가지 접근 방식을 혼합하여 사용할 수 있습니다.</p>
<p>개인이 여러 다른 작업 중 어느 하나도 완료되지 않은 상태에서 여러 작업을 수행할 때, 이것이 _동시성(concurrency)_입니다. 컴퓨터에 두 개의 다른 프로젝트를 체크아웃해 두고, 한 프로젝트가 지루해지거나 막히면 다른 프로젝트로 전환할 수 있습니다. 여러분은 한 명뿐이므로 정확히 동시에 두 작업 모두 진전을 이룰 수는 없지만, 멀티태스킹을 통해 한 번에 하나씩 작업을 전환하며 진전을 이룰 수 있습니다(그림 17-1 참조).</p>
<figure>
<img src="img/trpl17-01.svg" class="center" alt="A diagram with boxes labeled Task A and Task B, with diamonds in them representing subtasks. There are arrows pointing from A1 to B1, B1 to A2, A2 to B2, B2 to A3, A3 to A4, and A4 to B3. The arrows between the subtasks cross the boxes between Task A and Task B." />
<figcaption>Figure 17-1: A concurrent workflow, switching between Task A and Task B</figcaption>
</figure>
<p>팀이 각 구성원에게 하나의 작업을 맡겨 혼자서 작업하게 함으로써 작업 그룹을 분할할 때, 이것이 _병렬성(parallelism)_입니다. 팀의 각 사람은 정확히 동시에 진전을 이룰 수 있습니다(그림 17-2 참조).</p>
<figure>
<img src="img/trpl17-02.svg" class="center" alt="A diagram with boxes labeled Task A and Task B, with diamonds in them representing subtasks. There are arrows pointing from A1 to A2, A2 to A3, A3 to A4, B1 to B2, and B2 to B3. No arrows cross between the boxes for Task A and Task B." />
<figcaption>Figure 17-2: A parallel workflow, where work happens on Task A and Task B independently</figcaption>
</figure>
<p>이 두 작업 흐름 모두에서, 서로 다른 작업 간의 조정이 필요할 수 있습니다. 아마도 여러분은 한 사람에게 할당된 작업이 다른 모든 사람의 작업과 완전히 독립적이라고 <em>생각했을</em> 수 있지만, 실제로는 팀의 다른 사람이 먼저 작업을 완료해야 할 수도 있습니다. 작업의 일부는 병렬로 수행될 수 있지만, 그 중 일부는 실제로 _직렬(serial)_이었습니다: 그림 17-3과 같이 한 작업이 끝난 후에 다른 작업이 이어지는 시리즈로만 일어날 수 있습니다.</p>
<figure>
<img src="img/trpl17-03.svg" class="center" alt="A diagram with boxes labeled Task A and Task B, with diamonds in them representing subtasks. There are arrows pointing from A1 to A2, A2 to a pair of thick vertical lines like a “pause” symbol, from that symbol to A3, B1 to B2, B2 to B3, which is below that symbol, B3 to A3, and B3 to B4." />
<figcaption>Figure 17-3: A partially parallel workflow, where work happens on Task A and Task B independently until Task A3 is blocked on the results of Task B3.</figcaption>
</figure>
<p>마찬가지로, 자신의 작업 중 하나가 다른 작업에 의존한다는 것을 깨달을 수도 있습니다. 이제 여러분의 동시 작업도 직렬 작업이 되었습니다.</p>
<p>병렬성과 동시성은 서로 교차할 수도 있습니다. 동료가 여러분의 작업 중 하나를 완료할 때까지 막혀 있다는 것을 알게 되면, 아마도 동료의 "차단을 해제"하기 위해 그 작업에 모든 노력을 집중할 것입니다. 여러분과 동료는 더 이상 병렬로 작업할 수 없으며, 여러분 또한 자신의 작업에 대해 더 이상 동시에 작업할 수 없습니다.</p>
<p>소프트웨어와 하드웨어에서도 동일한 기본 역학이 작용합니다. 단일 CPU 코어가 있는 머신에서 CPU는 한 번에 하나의 작업만 수행할 수 있지만, 여전히 동시에 작동할 수 있습니다. 스레드, 프로세스, 비동기와 같은 도구를 사용하여 컴퓨터는 한 활동을 일시 중지하고 다른 활동으로 전환한 후 결국 다시 첫 번째 활동으로 돌아올 수 있습니다. 다중 CPU 코어가 있는 머신에서는 병렬로 작업을 수행할 수도 있습니다. 한 코어가 한 작업을 수행하는 동안 다른 코어가 완전히 무관한 작업을 수행할 수 있으며, 이러한 작업은 실제로 동시에 일어납니다.</p>
<p>러스트에서 비동기로 작업할 때, 우리는 항상 동시성을 다루고 있습니다. 하드웨어, 운영 체제, 그리고 우리가 사용하는 비동기 런타임(비동기 런타임에 대해서는 잠시 후에 더 자세히 다루겠습니다)에 따라, 그 동시성은 내부적으로 병렬성을 사용할 수도 있습니다.</p>
<p>이제 러스트에서 비동기 프로그래밍이 실제로 어떻게 작동하는지 자세히 살펴봅시다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="future와-async-문법"><a class="header" href="#future와-async-문법">Future와 Async 문법</a></h2>
<p>러스트 비동기 프로그래밍의 핵심 요소는 _퓨처(futures)_와 러스트의 <code>async</code> 및 <code>await</code> 키워드입니다.</p>
<p>_퓨처(future)_는 지금은 준비되지 않았을 수 있지만 미래의 어느 시점에 준비될 값을 의미합니다. (이와 동일한 개념이 많은 언어에서 등장하며, 때로는 _태스크(task)_나 _프로미스(promise)_와 같은 다른 이름으로 불리기도 합니다.) 러스트는 <code>Future</code> 트레이트를 구성 요소로 제공하여, 서로 다른 비동기 작업을 다른 데이터 구조로 구현하되 공통 인터페이스를 갖도록 할 수 있습니다. 러스트에서 퓨처는 <code>Future</code> 트레이트를 구현하는 타입입니다. 각 퓨처는 진행 상황과 "준비됨"이 무엇을 의미하는지에 대한 자체 정보를 보유합니다.</p>
<p>You can apply the <code>async</code> keyword to blocks and functions to specify that they can be interrupted and resumed. Within an async block or async function, you can use the <code>await</code> keyword to <em>await a future</em> (that is, wait for it to become ready). Any point where you await a future within an async block or function is a potential spot for that async block or function to pause and resume. The process of checking with a future to see if its value is available yet is called <em>polling</em>.</p>
<p>C#이나 JavaScript와 같은 다른 언어들도 비동기 프로그래밍을 위해 <code>async</code>와 <code>await</code> 키워드를 사용합니다. 만약 그러한 언어들에 익숙하다면, 러스트가 문법을 처리하는 방식을 포함하여 일을 처리하는 방식에서 몇 가지 중요한 차이점을 발견할 수 있을 것입니다. 우리가 보게 되겠지만, 그럴만한 충분한 이유가 있습니다!</p>
<p>비동기 러스트를 작성할 때, 우리는 대부분 <code>async</code>와 <code>await</code> 키워드를 사용합니다. 러스트는 <code>for</code> 루프를 <code>Iterator</code> 트레이트를 사용하여 동등한 코드로 컴파일하는 것과 마찬가지로, 이들을 <code>Future</code> 트레이트를 사용하여 동등한 코드로 컴파일합니다. 하지만 러스트가 <code>Future</code> 트레이트를 제공하므로, 필요할 때 자신만의 데이터 타입에 대해 이를 구현할 수도 있습니다. 이 장 전반에 걸쳐 보게 될 많은 함수들은 <code>Future</code>에 대한 자체 구현을 가진 타입을 반환합니다. 이 장의 끝에서 트레이트의 정의로 돌아가 작동 방식에 대해 더 자세히 알아볼 것이지만, 지금은 앞으로 나아가기에 충분한 세부 사항입니다.</p>
<p>이 모든 것이 다소 추상적으로 느껴질 수 있으므로, 첫 번째 비동기 프로그램인 작은 웹 스크래퍼를 작성해 봅시다. 명령줄에서 두 개의 URL을 전달하고, 두 URL을 동시에 가져와서 먼저 완료되는 URL의 결과를 반환할 것입니다. 이 예제에는 꽤 많은 새로운 문법이 포함되겠지만 걱정하지 마세요. 진행하면서 필요한 모든 것을 설명해 드리겠습니다.</p>
<h2 id="첫-번째-비동기-프로그램"><a class="header" href="#첫-번째-비동기-프로그램">첫 번째 비동기 프로그램</a></h2>
<p>이 장의 초점을 생태계의 여러 부분을 조정하는 것보다 비동기를 배우는 데 맞추기 위해, 우리는 <code>trpl</code> 크레이트를 만들었습니다(<code>trpl</code>은 "The Rust Programming Language"의 줄임말입니다). 이 크레이트는 주로 <a href="https://crates.io/crates/futures"><code>futures</code></a><!-- ignore -->와 <a href="https://tokio.rs"><code>tokio</code></a><!-- ignore --> 크레이트에서 필요한 모든 타입, 트레이트, 함수를 다시 내보냅니다. <code>futures</code> 크레이트는 비동기 코드에 대한 러스트 실험의 공식적인 본거지이며, 실제로 <code>Future</code> 트레이트가 원래 설계된 곳입니다. Tokio는 오늘날 러스트에서 가장 널리 사용되는 비동기 런타임이며, 특히 웹 애플리케이션에서 그렇습니다. 그 밖에도 훌륭한 런타임이 있으며, 여러분의 목적에 더 적합할 수도 있습니다. 우리는 <code>trpl</code>의 내부에서 <code>tokio</code> 크레이트를 사용하는데, 이는 잘 테스트되어 있고 널리 사용되기 때문입니다.</p>
<p>어떤 경우에는, <code>trpl</code>이 이 장과 관련된 세부 사항에 집중할 수 있도록 원래 API의 이름을 변경하거나 래핑하기도 합니다. 이 크레이트가 무엇을 하는지 이해하고 싶다면 <a href="https://github.com/rust-lang/book/tree/main/packages/trpl">소스 코드</a><!-- ignore -->를 확인해 보시기 바랍니다. 각 재내보내기가 어떤 크레이트에서 왔는지 볼 수 있으며, 크레이트가 무엇을 하는지 설명하는 광범위한 주석을 남겨 두었습니다.</p>
<p><code>hello-async</code>라는 이름의 새 바이너리 프로젝트를 생성하고 <code>trpl</code> 크레이트를 의존성으로 추가하세요:</p>
<pre><code class="language-console">$ cargo new hello-async
$ cd hello-async
$ cargo add trpl
</code></pre>
<p>이제 <code>trpl</code>이 제공하는 다양한 조각들을 사용하여 우리의 첫 번째 비동기 프로그램을 작성할 수 있습니다. 두 개의 웹 페이지를 가져와서 각각 <code>&lt;title&gt;</code> 요소를 추출하고, 그 전체 과정을 먼저 완료하는 페이지의 제목을 출력하는 작은 명령줄 도구를 만들 것입니다.</p>
<h3 id="page_title-함수-정의하기"><a class="header" href="#page_title-함수-정의하기">page_title 함수 정의하기</a></h3>
<p>하나의 페이지 URL을 매개변수로 받아 요청을 보내고 타이틀 요소의 텍스트를 반환하는 함수를 작성하는 것으로 시작해 봅시다(목록 17-1 참조).</p>
<Listing number="17-1" file-name="src/main.rs" caption="Defining an async function to get the title element from an HTML page">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // TODO: 이건 다음에 추가할 것입니다!
</span><span class="boring">}
</span><span class="boring">
</span>use trpl::Html;

async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
    let response = trpl::get(url).await;
    let response_text = response.text().await;
    Html::parse(&amp;response_text)
        .select_first("title")
        .map(|title_element| title_element.inner_html())
}</code></pre></pre>
</Listing>
<p>먼저, <code>page_title</code>이라는 함수를 정의하고 <code>async</code> 키워드로 표시합니다. 그런 다음 전달된 URL을 가져오기 위해 <code>trpl::get</code> 함수를 사용하고 <code>await</code> 키워드를 추가하여 응답을 기다립니다. 응답의 텍스트를 얻기 위해 <code>text</code> 메서드를 호출하고, 다시 한번 <code>await</code> 키워드로 기다립니다. 이 두 단계는 모두 비동기적입니다. <code>get</code> 함수의 경우, HTTP 헤더, 쿠키 등을 포함하는 응답의 첫 번째 부분을 서버가 다시 보낼 때까지 기다려야 하며, 이는 응답 본문과 별도로 전달될 수 있습니다. 특히 본문이 매우 큰 경우 모든 것이 도착하는 데 시간이 걸릴 수 있습니다. 응답의 _전체_가 도착할 때까지 기다려야 하므로 <code>text</code> 메서드도 비동기입니다.</p>
<p>우리는 이 두 퓨처를 모두 명시적으로 기다려야 합니다. 왜냐하면 러스트의 퓨처는 <em>게으르기(lazy)</em> 때문입니다. <code>await</code> 키워드로 요청할 때까지 아무 것도 하지 않습니다. (사실, 퓨처를 사용하지 않으면 러스트는 컴파일러 경고를 표시할 것입니다.) 이는 13장의 <a href="ch13-02-iterators.html">반복자로 일련의 항목 처리하기</a><!-- ignore --> 섹션에서 반복자에 대한 논의를 떠올리게 할 수도 있습니다. 반복자는 <code>next</code> 메서드를 호출하지 않으면(<code>next</code>를 내부적으로 사용하는 <code>for</code> 루프나 <code>map</code> 같은 메서드를 직접 사용하든 간에) 아무 것도 하지 않습니다. 마찬가지로, 퓨처도 명시적으로 요청하지 않으면 아무 것도 하지 않습니다. 이러한 게으름은 러스트가 실제로 필요할 때까지 비동기 코드 실행을 피할 수 있게 해줍니다.</p>
<blockquote>
<p>참고: 이것은 이전 장의 <a href="ch16-01-threads.html#creating-a-new-thread-with-spawn">spawn으로 새로운 스레드 생성하기</a><!--ignore-->에서 <code>thread::spawn</code>을 사용할 때 보았던 동작과는 다릅니다. 거기서는 다른 스레드에 전달한 클로저가 즉시 실행되기 시작했습니다. 이는 또한 다른 많은 언어가 비동기에 접근하는 방식과도 다릅니다. 하지만 이것은 러스트에서 중요하며, 그 이유는 나중에 알게 될 것입니다.</p>
</blockquote>
<p><code>response_text</code>를 얻으면, <code>Html::parse</code>를 사용하여 <code>Html</code> 타입의 인스턴스로 파싱할 수 있습니다. 원시 문자열 대신, 이제 HTML을 더 풍부한 데이터 구조로 다루는 데 사용할 수 있는 데이터 타입을 갖게 되었습니다. 특히, <code>select_first</code> 메서드를 사용하여 주어진 CSS 선택자의 첫 번째 인스턴스를 찾을 수 있습니다. <code>"title"</code> 문자열을 전달함으로써, 문서에 <code>&lt;title&gt;</code> 요소가 있다면 첫 번째 요소를 얻을 것입니다. 일치하는 요소가 없을 수도 있으므로, <code>select_first</code>는 <code>Option&lt;ElementRef&gt;</code>를 반환합니다. 마지막으로 <code>Option::map</code> 메서드를 사용하는데, 이는 <code>Option</code>에 항목이 있으면 해당 항목으로 작업을 수행하고, 없으면 아무 것도 하지 않게 해줍니다. (여기서 <code>match</code> 표현식을 사용할 수도 있지만 <code>map</code>이 더 관용적입니다.) <code>map</code>에 제공하는 함수 본문에서 <code>title_element</code>에 대해 <code>inner_html</code>을 호출하여 그 내용(<code>String</code>)을 얻습니다. 모든 작업이 완료되면 우리는 <code>Option&lt;String&gt;</code>을 갖게 됩니다.</p>
<p>러스트의 <code>await</code> 키워드는 기다리는 표현식의 앞이 아니라 <em>뒤에</em> 온다는 점에 주목하세요. 즉, <em>접미사(postfix)</em> 키워드입니다. 이는 다른 언어에서 <code>async</code>를 사용해 본 경험이 있다면 익숙한 것과 다를 수 있지만, 러스트에서는 메서드 체인을 다루기가 훨씬 더 좋습니다. 결과적으로, 목록 17-2와 같이 <code>trpl::get</code>과 <code>text</code> 함수 호출을 그 사이에 <code>await</code>를 넣어 연결하도록 <code>page_url_for</code>의 본문을 변경할 수 있습니다.</p>
<Listing number="17-2" file-name="src/main.rs" caption="Chaining with the `await` keyword">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use trpl::Html;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // TODO: 이건 다음에 추가할 것입니다!
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
</span>    let response_text = trpl::get(url).await.text().await;
<span class="boring">    Html::parse(&amp;response_text)
</span><span class="boring">        .select_first("title")
</span><span class="boring">        .map(|title_element| title_element.inner_html())
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>이로써 우리는 첫 번째 비동기 함수를 성공적으로 작성했습니다! <code>main</code>에 코드를 추가하여 호출하기 전에, 우리가 작성한 내용과 그 의미에 대해 조금 더 이야기해 봅시다.</p>
<p>러스트가 <code>async</code> 키워드로 표시된 블록을 보면, 이를 <code>Future</code> 트레이트를 구현하는 고유하고 익명인 데이터 타입으로 컴파일합니다. 러스트가 <code>async</code>로 표시된 함수를 보면, 이를 본문이 비동기 블록인 비동기가 아닌 함수로 컴파일합니다. 비동기 함수의 반환 타입은 컴파일러가 해당 비동기 블록을 위해 생성하는 익명 데이터 타입의 타입입니다.</p>
<p>따라서 <code>async fn</code>을 작성하는 것은 반환 타입의 _퓨처_를 반환하는 함수를 작성하는 것과 같습니다. 컴파일러에게 목록 17-1의 <code>async fn page_title</code>과 같은 함수 정의는 다음과 같이 정의된 비동기가 아닌 함수와 동일합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span>use std::future::Future;
use trpl::Html;

fn page_title(url: &amp;str) -&gt; impl Future&lt;Output = Option&lt;String&gt;&gt; + '_ {
    async move {
        let text = trpl::get(url).await.text().await;
        Html::parse(&amp;text)
            .select_first("title")
            .map(|title| title.inner_html())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>변환된 버전의 각 부분을 살펴봅시다:</p>
<ul>
<li>이것은 10장의 <a href="ch10-02-traits.html#traits-as-parameters">“매개변수로서의 트레이트”</a><!-- ignore --> 섹션에서 논의했던 <code>impl Trait</code> 문법을 사용합니다.</li>
<li>반환된 트레이트는 연관 타입 <code>Output</code>을 가진 <code>Future</code>입니다. <code>Output</code> 타입이 <code>Option&lt;String&gt;</code>이라는 것에 주목하세요. 이는 <code>page_title</code>의 <code>async fn</code> 버전에서 원래 반환 타입과 동일합니다.</li>
<li>원래 함수의 본문에서 호출된 모든 코드는 <code>async move</code> 블록으로 감싸져 있습니다. 블록이 표현식이라는 것을 기억하세요. 이 전체 블록은 함수에서 반환되는 표현식입니다.</li>
<li>이 비동기 블록은 방금 설명한 대로 <code>Option&lt;String&gt;</code> 타입의 값을 생성합니다. 그 값은 반환 타입의 <code>Output</code> 타입과 일치합니다. 이것은 여러분이 보아온 다른 블록과 같습니다.</li>
<li>새로운 함수 본문은 <code>url</code> 매개변수를 사용하는 방식 때문에 <code>async move</code> 블록입니다. (<code>async</code>와 <code>async move</code>의 차이점에 대해서는 이 장의 뒷부분에서 더 자세히 이야기할 것입니다.)</li>
<li>함수의 새 버전에는 출력 타입에서 이전에 본 적 없는 종류의 라이프타임인 <code>'_</code>가 있습니다. 함수가 참조(이 경우 <code>url</code> 매개변수의 참조)를 가리키는 퓨처를 반환하기 때문에, 우리는 러스트에게 그 참조가 포함되기를 원한다고 말해야 합니다. 여기서는 라이프타임의 이름을 지정할 필요가 없습니다. 러스트는 관련될 수 있는 참조가 하나뿐이라는 것을 알 만큼 똑똑하기 때문입니다. 하지만 결과 퓨처가 그 라이프타임에 묶여 있다는 것은 명시해야 <em>합니다</em>.</li>
</ul>
<p>이제 <code>main</code>에서 <code>page_title</code>을 호출할 수 있습니다.</p>
<h2 id="단일-페이지의-제목-결정하기"><a class="header" href="#단일-페이지의-제목-결정하기">단일 페이지의 제목 결정하기</a></h2>
<p>시작하기 위해, 단일 페이지의 제목만 가져와 봅시다. 목록 17-3에서는 <a href="ch12-01-accepting-command-line-arguments.html">명령줄 인수 받기</a><!-- ignore --> 섹션의 12장에서 명령줄 인수를 얻기 위해 사용했던 것과 동일한 패턴을 따릅니다. 그런 다음 첫 번째 URL을 <code>page_title</code>에 전달하고 결과를 기다립니다. 퓨처가 생성하는 값은 <code>Option&lt;String&gt;</code>이므로, <code>match</code> 표현식을 사용하여 페이지에 <code>&lt;title&gt;</code>이 있었는지 여부에 따라 다른 메시지를 출력합니다.</p>
<Listing number="17-3" file-name="src/main.rs" caption="Calling the `page_title` function from `main` with a user-supplied argument">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use trpl::Html;
</span><span class="boring">
</span>async fn main() {
    let args: Vec&lt;String&gt; = std::env::args().collect();
    let url = &amp;args[1];
    match page_title(url).await {
        Some(title) =&gt; println!("The title for {url} was {title}"),
        None =&gt; println!("{url} had no title"),
    }
}
<span class="boring">
</span><span class="boring">async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
</span><span class="boring">    let response_text = trpl::get(url).await.text().await;
</span><span class="boring">    Html::parse(&amp;response_text)
</span><span class="boring">        .select_first("title")
</span><span class="boring">        .map(|title_element| title_element.inner_html())
</span><span class="boring">}</span></code></pre>
</Listing>
<p>불행히도, 이 코드는 컴파일되지 않습니다. <code>await</code> 키워드를 사용할 수 있는 유일한 장소는 비동기 함수나 블록 내부인데, 러스트는 특별한 <code>main</code> 함수를 <code>async</code>로 표시하는 것을 허용하지 않습니다.</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-03
cargo build
copy just the compiler error
-->
<pre><code class="language-text">error[E0752]: `main` function is not allowed to be `async`
 --&gt; src/main.rs:6:1
  |
6 | async fn main() {
  | ^^^^^^^^^^^^^^^ `main` function is not allowed to be `async`
</code></pre>
<p><code>main</code>을 <code>async</code>로 표시할 수 없는 이유는 비동기 코드에 _런타임(runtime)_이 필요하기 때문입니다. 런타임은 비동기 코드 실행의 세부 사항을 관리하는 러스트 크레이트입니다. 프로그램의 <code>main</code> 함수는 런타임을 _초기화_할 수는 있지만 런타임 _그 자체_는 아닙니다. (잠시 후에 왜 그런지에 대해 더 자세히 알아볼 것입니다.) 비동기 코드를 실행하는 모든 러스트 프로그램에는 런타임을 설정하고 퓨처를 실행하는 곳이 적어도 한 곳 있습니다.</p>
<p>Most languages that support async bundle a runtime, but Rust does not. Instead, there are many different async runtimes available, each of which makes different tradeoffs suitable to the use case it targets. For example, a high-throughput web server with many CPU cores and a large amount of RAM has very different needs than a microcontroller with a single core, a small amount of RAM, and no heap allocation ability. The crates that provide those runtimes also often supply async versions of common functionality such as file or network I/O.</p>
<p>여기서부터 이 장의 나머지 부분에서는 <code>trpl</code> 크레이트의 <code>run</code> 함수를 사용할 것입니다. 이 함수는 퓨처를 인수로 받아 완료될 때까지 실행합니다. 배후에서 <code>run</code>을 호출하면 전달된 퓨처를 실행하는 데 사용되는 런타임이 설정됩니다. 퓨처가 완료되면 <code>run</code>은 퓨처가 생성한 값을 반환합니다.</p>
<p><code>page_title</code>이 반환한 퓨처를 <code>run</code>에 직접 전달할 수도 있고, 완료되면 목록 17-3에서 시도했던 것처럼 결과 <code>Option&lt;String&gt;</code>을 매칭할 수도 있습니다. 하지만 이 장의 대부분의 예제(그리고 실제 세계의 대부분의 비동기 코드)에서는 단지 하나의 비동기 함수 호출만 하지는 않을 것이므로, 대신 목록 17-4와 같이 <code>async</code> 블록을 전달하고 <code>page_title</code> 호출의 결과를 명시적으로 기다릴 것입니다.</p>
<Listing number="17-4" caption="Awaiting an async block with `trpl::run`" file-name="src/main.rs">
<!-- should_panic,noplayground because mdbook test does not pass args -->
<pre><code class="language-rust should_panic noplayground"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use trpl::Html;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = std::env::args().collect();

    trpl::run(async {
        let url = &amp;args[1];
        match page_title(url).await {
            Some(title) =&gt; println!("The title for {url} was {title}"),
            None =&gt; println!("{url} had no title"),
        }
    })
}
<span class="boring">
</span><span class="boring">async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
</span><span class="boring">    let response_text = trpl::get(url).await.text().await;
</span><span class="boring">    Html::parse(&amp;response_text)
</span><span class="boring">        .select_first("title")
</span><span class="boring">        .map(|title_element| title_element.inner_html())
</span><span class="boring">}</span></code></pre>
</Listing>
<p>이 코드를 실행하면 처음에 예상했던 동작을 얻을 수 있습니다:</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-04
cargo build # skip all the build noise
cargo run https://www.rust-lang.org
# copy the output here
-->
<pre><code class="language-console">$ cargo run -- https://www.rust-lang.org
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.05s
     Running `target/debug/async_await 'https://www.rust-lang.org'`
The title for https://www.rust-lang.org was
            Rust Programming Language
</code></pre>
<p>휴—드디어 작동하는 비동기 코드를 얻었습니다! 하지만 두 사이트를 서로 경쟁시키는 코드를 추가하기 전에, 잠시 퓨처가 작동하는 방식에 다시 주의를 기울여 봅시다.</p>
<p>각 <em>await 지점</em>(즉, 코드에서 <code>await</code> 키워드를 사용하는 모든 곳)은 제어가 런타임으로 다시 넘어가는 곳을 나타냅니다. 이를 작동시키기 위해, 러스트는 런타임이 다른 작업을 시작하고 첫 번째 작업을 다시 진행할 준비가 되었을 때 돌아올 수 있도록 비동기 블록과 관련된 상태를 추적해야 합니다. 이것은 보이지 않는 상태 머신으로, 마치 각 await 지점에서 현재 상태를 저장하기 위해 다음과 같은 열거형을 작성한 것과 같습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span>enum PageTitleFuture&lt;'a&gt; {
    Initial { url: &amp;'a str },
    GetAwaitPoint { url: &amp;'a str },
    TextAwaitPoint { response: trpl::Response },
}
<span class="boring">}</span></code></pre></pre>
<p>하지만 각 상태 간의 전환 코드를 직접 작성하는 것은 지루하고 오류가 발생하기 쉽습니다. 특히 나중에 코드에 더 많은 기능과 상태를 추가해야 할 때는 더욱 그렇습니다. 다행히도 러스트 컴파일러는 비동기 코드를 위한 상태 머신 데이터 구조를 자동으로 생성하고 관리합니다. 데이터 구조에 대한 일반적인 대여 및 소유권 규칙이 모두 여전히 적용되며, 다행히도 컴파일러가 우리를 위해 이를 확인하고 유용한 에러 메시지를 제공합니다. 이 장의 뒷부분에서 몇 가지 예를 살펴볼 것입니다.</p>
<p>궁극적으로 무언가가 이 상태 머신을 실행해야 하며, 그 무언가가 바로 런타임입니다. (이것이 런타임을 살펴볼 때 _실행자(executors)_에 대한 언급을 접할 수 있는 이유입니다: 실행자는 비동기 코드를 실행하는 책임을 지는 런타임의 일부입니다.)</p>
<p>이제 목록 17-3에서 컴파일러가 <code>main</code> 자체를 비동기 함수로 만드는 것을 막은 이유를 알 수 있습니다. 만약 <code>main</code>이 비동기 함수라면, <code>main</code>이 반환하는 퓨처가 무엇이든 간에 다른 무언가가 그 상태 머신을 관리해야 할 텐데, <code>main</code>은 프로그램의 시작점입니다! 대신, 우리는 <code>main</code>에서 <code>trpl::run</code> 함수를 호출하여 런타임을 설정하고 <code>async</code> 블록에 의해 반환된 퓨처가 <code>Ready</code>를 반환할 때까지 실행했습니다.</p>
<blockquote>
<p>참고: 일부 런타임은 <code>async</code> <code>main</code> 함수를 작성할 수 <em>있도록</em> 매크로를 제공합니다. 이러한 매크로는 <code>async fn main() { ... }</code>를 일반적인 <code>fn main</code>으로 재작성하여, 우리가 목록 17-5에서 수동으로 했던 것과 동일한 일을 수행합니다: 즉, <code>trpl::run</code>이 하는 것처럼 퓨처를 완료될 때까지 실행하는 함수를 호출합니다.</p>
</blockquote>
<p>이제 이 조각들을 모아서 동시성 코드를 어떻게 작성할 수 있는지 살펴봅시다.</p>
<h3 id="두-url을-서로-경쟁시키기"><a class="header" href="#두-url을-서로-경쟁시키기">두 URL을 서로 경쟁시키기</a></h3>
<p>목록 17-5에서, 우리는 명령줄에서 전달된 두 개의 서로 다른 URL로 <code>page_title</code>을 호출하고 경쟁시킵니다.</p>
<Listing number="17-5" caption="" file-name="src/main.rs">
<!-- should_panic,noplayground because mdbook does not pass args -->
<pre><code class="language-rust should_panic noplayground"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span>use trpl::{Either, Html};

fn main() {
    let args: Vec&lt;String&gt; = std::env::args().collect();

    trpl::run(async {
        let title_fut_1 = page_title(&amp;args[1]);
        let title_fut_2 = page_title(&amp;args[2]);

        let (url, maybe_title) =
            match trpl::race(title_fut_1, title_fut_2).await {
                Either::Left(left) =&gt; left,
                Either::Right(right) =&gt; right,
            };

        println!("{url} returned first");
        match maybe_title {
            Some(title) =&gt; println!("Its page title is: '{title}'"),
            None =&gt; println!("제목을 파싱할 수 없습니다."),
        }
    })
}

async fn page_title(url: &amp;str) -&gt; (&amp;str, Option&lt;String&gt;) {
    let text = trpl::get(url).await.text().await;
    let title = Html::parse(&amp;text)
        .select_first("title")
        .map(|title| title.inner_html());
    (url, title)
}</code></pre>
</Listing>
<p>우리는 사용자가 제공한 각 URL에 대해 <code>page_title</code>을 호출하는 것으로 시작합니다. 결과 퓨처들을 <code>title_fut_1</code>과 <code>title_fut_2</code>로 저장합니다. 퓨처는 게으르고 우리가 아직 기다리지 않았기 때문에, 이것들은 아직 아무 것도 하지 않는다는 것을 기억하세요. 그런 다음 퓨처들을 <code>trpl::race</code>에 전달합니다. 이 함수는 전달된 퓨처들 중 어느 것이 먼저 완료되었는지 나타내는 값을 반환합니다.</p>
<blockquote>
<p>참고: <code>race</code>는 내부적으로 더 일반적인 함수인 <code>select</code>를 기반으로 구축되었습니다. 실제 러스트 코드에서는 <code>select</code>를 더 자주 접하게 될 것입니다. <code>select</code> 함수는 <code>trpl::race</code> 함수가 할 수 없는 많은 일을 할 수 있지만, 지금은 건너뛸 수 있는 추가적인 복잡성도 가지고 있습니다.</p>
</blockquote>
<p>두 퓨처 중 어느 쪽이든 합법적으로 "이길" 수 있으므로, <code>Result</code>를 반환하는 것은 의미가 없습니다. 대신, <code>race</code>는 이전에 본 적 없는 <code>trpl::Either</code>라는 타입을 반환합니다. <code>Either</code> 타입은 두 가지 경우가 있다는 점에서 <code>Result</code>와 다소 비슷합니다. 하지만 <code>Result</code>와 달리 <code>Either</code>에는 성공이나 실패의 개념이 포함되어 있지 않습니다. 대신 <code>Left</code>와 <code>Right</code>를 사용하여 "둘 중 하나"를 나타냅니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Either&lt;A, B&gt; {
    Left(A),
    Right(B),
}
<span class="boring">}</span></code></pre></pre>
<p><code>race</code> 함수는 첫 번째 인수가 이기면 해당 퓨처의 출력과 함께 <code>Left</code>를 반환하고, 두 번째 퓨처 인수가 이기면 해당 출력과 함께 <code>Right</code>를 반환합니다. 이는 함수를 호출할 때 인수가 나타나는 순서와 일치합니다: 첫 번째 인수는 두 번째 인수의 왼쪽에 있습니다.</p>
<p>우리는 또한 전달된 동일한 URL을 반환하도록 <code>page_title</code>을 업데이트합니다. 그렇게 하면 먼저 반환된 페이지에 우리가 해결할 수 있는 <code>&lt;title&gt;</code>이 없더라도 여전히 의미 있는 메시지를 출력할 수 있습니다. 해당 정보를 사용할 수 있게 되면, 어떤 URL이 먼저 완료되었는지와 해당 URL의 웹 페이지에 대한 <code>&lt;title&gt;</code>이 있다면 무엇인지를 모두 나타내도록 <code>println!</code> 출력을 업데이트하여 마무리합니다.</p>
<p>이제 작지만 작동하는 웹 스크래퍼를 만들었습니다! 두 개의 URL을 선택하여 명령줄 도구를 실행해 보세요. 어떤 사이트는 일관되게 다른 사이트보다 빠를 수 있고, 어떤 경우에는 실행할 때마다 더 빠른 사이트가 달라질 수도 있음을 발견할 수 있습니다. 더 중요한 것은 퓨처 작업의 기초를 배웠으므로, 이제 비동기로 무엇을 할 수 있는지 더 깊이 파고들 수 있다는 것입니다.</p>
<!-- TODO: map source link version to version of Rust? -->
<div style="break-before: page; page-break-before: always;"></div><h2 id="async로-동시성-적용하기"><a class="header" href="#async로-동시성-적용하기">Async로 동시성 적용하기</a></h2>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="concurrency-with-async"></a></p>
<p>이 절에서는 16장에서 스레드로 다루었던 몇 가지 동시성 과제에 비동기를 적용해 볼 것입니다. 거기서 이미 많은 핵심 아이디어에 대해 이야기했으므로, 이 절에서는 스레드와 퓨처 간의 차이점에 초점을 맞출 것입니다.</p>
<p>많은 경우, 비동기를 사용하여 동시성을 다루는 API는 스레드를 사용하는 것과 매우 유사합니다. 다른 경우에는 꽤 다르게 되기도 합니다. 스레드와 비동기 간에 API가 비슷해 <em>보일</em> 때조차도, 종종 다른 동작을 하며 거의 항상 다른 성능 특성을 가집니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="counting"></a></p>
<h3 id="spawn_task로-새로운-태스크-생성하기"><a class="header" href="#spawn_task로-새로운-태스크-생성하기"><code>spawn_task</code>로 새로운 태스크 생성하기</a></h3>
<p><a href="ch16-01-threads.html#creating-a-new-thread-with-spawn">spawn으로 새로운 스레드 생성하기</a><!-- ignore -->에서 처음 다룬 작업은 두 개의 별도 스레드에서 숫자를 세는 것이었습니다. 비동기를 사용하여 동일한 작업을 수행해 봅시다. <code>trpl</code> 크레이트는 <code>thread::spawn</code> API와 매우 유사해 보이는 <code>spawn_task</code> 함수와 <code>thread::sleep</code> API의 비동기 버전인 <code>sleep</code> 함수를 제공합니다. 목록 17-6과 같이 이들을 함께 사용하여 카운팅 예제를 구현할 수 있습니다.</p>
<Listing number="17-6" caption="Creating a new task to print one thing while the main task prints something else" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span>use std::time::Duration;

fn main() {
    trpl::run(async {
        trpl::spawn_task(async {
            for i in 1..10 {
                println!("첫 번째 태스크에서 안녕하세요 숫자 {i}!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        });

        for i in 1..5 {
            println!("두 번째 태스크에서 안녕하세요 숫자 {i}!");
            trpl::sleep(Duration::from_millis(500)).await;
        }
    });
}</code></pre></pre>
</Listing>
<p>시작점으로, 최상위 함수가 비동기가 될 수 있도록 <code>trpl::run</code>으로 <code>main</code> 함수를 설정합니다.</p>
<blockquote>
<p>참고: 이 장의 이 시점부터 모든 예제는 <code>main</code>에 <code>trpl::run</code>이 있는 이와 똑같은 래핑 코드를 포함하므로, <code>main</code>에서처럼 종종 생략할 것입니다. 코드에 포함하는 것을 잊지 마세요!</p>
</blockquote>
<p>그런 다음 그 블록 내에 두 개의 루프를 작성하는데, 각 루프는 다음 메시지를 보내기 전에 0.5초(500 밀리초) 동안 기다리는 <code>trpl::sleep</code> 호출을 포함합니다. 루프 하나는 <code>trpl::spawn_task</code>의 본문에 넣고, 다른 하나는 최상위 <code>for</code> 루프에 넣습니다. 또한 <code>sleep</code> 호출 뒤에 <code>await</code>를 추가합니다.</p>
<p>이 코드는 스레드 기반 구현과 유사하게 동작합니다—실행할 때 터미널에서 메시지가 다른 순서로 나타날 수 있다는 점을 포함해서 말이죠:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the second task!
hi number 1 from the first task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
</code></pre>
<p>이 버전은 메인 비동기 블록 본문의 <code>for</code> 루프가 끝나자마자 중지됩니다. 왜냐하면 <code>main</code> 함수가 끝날 때 <code>spawn_task</code>에 의해 생성된 태스크가 종료되기 때문입니다. 태스크가 완료될 때까지 계속 실행되기를 원한다면, 첫 번째 태스크가 완료되기를 기다리기 위해 조인 핸들을 사용해야 합니다. 스레드에서는 <code>join</code> 메서드를 사용하여 스레드 실행이 끝날 때까지 "차단(block)"했습니다. 목록 17-7에서는 태스크 핸들 자체가 퓨처이기 때문에 <code>await</code>를 사용하여 동일한 작업을 수행할 수 있습니다. 그것의 <code>Output</code> 타입은 <code>Result</code>이므로, 기다린 후에 <code>unwrap</code>도 수행합니다.</p>
<Listing number="17-7" caption="Using `await` with a join handle to run a task to completion" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let handle = trpl::spawn_task(async {
            for i in 1..10 {
                println!("첫 번째 태스크에서 안녕하세요 숫자 {i}!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        });

        for i in 1..5 {
            println!("두 번째 태스크에서 안녕하세요 숫자 {i}!");
            trpl::sleep(Duration::from_millis(500)).await;
        }

        handle.await.unwrap();
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 업데이트된 버전은 <em>두</em> 루프가 모두 끝날 때까지 실행됩니다.</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the second task!
hi number 1 from the first task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
hi number 6 from the first task!
hi number 7 from the first task!
hi number 8 from the first task!
hi number 9 from the first task!
</code></pre>
<p>지금까지는 비동기와 스레드가 기본적으로 동일한 결과를 제공하는 것처럼 보입니다. 단지 문법이 다를 뿐입니다. 조인 핸들에서 <code>join</code>을 호출하는 대신 <code>await</code>를 사용하고, <code>sleep</code> 호출을 기다리는 점이 다릅니다.</p>
<p>The bigger difference is that we didn’t need to spawn another operating system thread to do this. In fact, we don’t even need to spawn a task here. Because async blocks compile to anonymous futures, we can put each loop in an async block and have the runtime run them both to completion using the <code>trpl::join</code> function.</p>
<p><a href="ch16-01-threads.html#waiting-for-all-threads-to-finish-using-join-handles"><code>join</code> 핸들을 사용하여 모든 스레드가 끝나기를 기다리기</a><!-- ignore --> 섹션에서, <code>std::thread::spawn</code>을 호출할 때 반환되는 <code>JoinHandle</code> 타입의 <code>join</code> 메서드를 사용하는 방법을 보여주었습니다. <code>trpl::join</code> 함수는 비슷하지만 퓨처를 위한 것입니다. 두 개의 퓨처를 제공하면, 두 퓨처가 <em>모두</em> 완료되었을 때 전달한 각 퓨처의 출력을 포함하는 튜플을 출력으로 하는 하나의 새로운 퓨처를 생성합니다. 따라서 목록 17-8에서는 <code>trpl::join</code>을 사용하여 <code>fut1</code>과 <code>fut2</code>가 모두 완료되기를 기다립니다. 우리는 <code>fut1</code>과 <code>fut2</code>를 <em>기다리지 않고(await)</em>, 대신 <code>trpl::join</code>에 의해 생성된 새로운 퓨처를 기다립니다. 출력은 두 개의 유닛 값을 포함하는 튜플일 뿐이므로 무시합니다.</p>
<Listing number="17-8" caption="Using `trpl::join` to await two anonymous futures" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let fut1 = async {
            for i in 1..10 {
                println!("첫 번째 태스크에서 안녕하세요 숫자 {i}!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let fut2 = async {
            for i in 1..5 {
                println!("두 번째 태스크에서 안녕하세요 숫자 {i}!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        trpl::join(fut1, fut2).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>이것을 실행하면 두 퓨처가 모두 완료될 때까지 실행되는 것을 볼 수 있습니다:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the first task!
hi number 1 from the second task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
hi number 6 from the first task!
hi number 7 from the first task!
hi number 8 from the first task!
hi number 9 from the first task!
</code></pre>
<p>이제 매번 정확히 같은 순서를 볼 수 있는데, 이는 스레드에서 보았던 것과는 매우 다릅니다. 그 이유는 <code>trpl::join</code> 함수가 _공정(fair)_하기 때문입니다. 즉, 각 퓨처를 동일한 빈도로 확인하고 번갈아 가며 확인하며, 다른 하나가 준비되었는데 하나가 앞서 나가도록 두지 않습니다. 스레드의 경우, 운영 체제가 어떤 스레드를 확인하고 얼마나 오랫동안 실행할지 결정합니다. 비동기 러스트에서는 런타임이 어떤 태스크를 확인할지 결정합니다. (실제로는 비동기 런타임이 동시성을 관리하는 방법의 일부로 내부적으로 운영 체제 스레드를 사용할 수 있기 때문에 세부 사항이 복잡해질 수 있으며, 런타임이 공정성을 보장하는 것은 더 많은 작업이 필요할 수 있습니다. 하지만 여전히 가능합니다!) 런타임은 주어진 작업에 대해 공정성을 보장할 필요가 없으며, 종종 공정성을 원하는지 여부를 선택할 수 있도록 다른 API를 제공합니다.</p>
<p>퓨처를 기다리는 몇 가지 변형을 시도해보고 어떻게 동작하는지 확인해 보세요:</p>
<ul>
<li>루프 중 하나 또는 둘 다에서 비동기 블록을 제거해 보세요.</li>
<li>각 비동기 블록을 정의한 직후에 기다려(await) 보세요.</li>
<li>첫 번째 루프만 비동기 블록으로 감싸고, 두 번째 루프의 본문 뒤에서 결과 퓨처를 기다려 보세요.</li>
</ul>
<p>추가적인 도전 과제로, 코드를 실행하기 <em>전에</em> 각 경우에 출력이 어떻게 될지 알아낼 수 있는지 확인해 보세요!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="message-passing"></a></p>
<h3 id="메시지-전달을-사용하여-두-태스크에서-숫자-세기"><a class="header" href="#메시지-전달을-사용하여-두-태스크에서-숫자-세기">메시지 전달을 사용하여 두 태스크에서 숫자 세기</a></h3>
<p>Sharing data between futures will also be familiar: we’ll use message passing again, but this time with async versions of the types and functions. We’ll take a slightly different path than we did in <a href="ch16-02-message-passing.html">Using Message Passing to Transfer Data Between Threads</a><!-- ignore --> to illustrate some of the key differences between thread-based and futures-based concurrency. In Listing 17-9, we’ll begin with just a single async block—<em>not</em> spawning a separate task as we spawned a separate thread.</p>
<Listing number="17-9" caption="Creating an async channel and assigning the two halves to `tx` and `rx`" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let val = String::from("안녕");
        tx.send(val).unwrap();

        let received = rx.recv().await.unwrap();
        println!("받음: {received}");
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>여기서 우리는 16장에서 스레드와 함께 사용했던 다중 생산자, 단일 소비자 채널 API의 비동기 버전인 <code>trpl::channel</code>을 사용합니다. API의 비동기 버전은 스레드 기반 버전과 조금 다를 뿐입니다: 불변 수신자 <code>rx</code> 대신 가변 수신자를 사용하며, <code>recv</code> 메서드는 값을 직접 생성하는 대신 우리가 기다려야 하는 퓨처를 생성합니다. 이제 우리는 송신자에서 수신자로 메시지를 보낼 수 있습니다. 별도의 스레드나 태스크를 생성할 필요가 없다는 점에 주목하세요; 우리는 단지 <code>rx.recv</code> 호출을 기다리기만 하면 됩니다.</p>
<p><code>std::mpsc::channel</code>의 동기 <code>Receiver::recv</code> 메서드는 메시지를 받을 때까지 차단합니다. <code>trpl::Receiver::recv</code> 메서드는 비동기이므로 그렇지 않습니다. 차단하는 대신, 메시지를 받거나 채널의 송신 측이 닫힐 때까지 제어를 런타임에 다시 넘깁니다. 반면, <code>send</code> 호출은 차단하지 않으므로 기다리지 않습니다. 우리가 보내는 채널이 제한이 없기 때문에(unbounded) 기다릴 필요가 없습니다.</p>
<blockquote>
<p>참고: 이 모든 비동기 코드는 <code>trpl::run</code> 호출 내의 비동기 블록에서 실행되므로, 그 안의 모든 것은 차단을 피할 수 있습니다. 하지만 그 <em>외부의</em> 코드는 <code>run</code> 함수가 반환될 때까지 차단됩니다. 이것이 <code>trpl::run</code> 함수의 핵심입니다. 이것은 일련의 비동기 코드에서 어디서 차단할지, 따라서 동기 코드와 비동기 코드 사이를 어디서 전환할지 _선택_할 수 있게 해줍니다. 대부분의 비동기 런타임에서 <code>run</code>은 정확히 이러한 이유로 실제로 <code>block_on</code>이라는 이름을 가집니다.</p>
</blockquote>
<p>이 예제에서 두 가지 점에 주목하세요. 첫째, 메시지가 즉시 도착할 것입니다. 둘째, 여기서 퓨처를 사용하지만 아직 동시성은 없습니다. 목록의 모든 것은 퓨처가 관련되지 않은 것처럼 순차적으로 발생합니다.</p>
<p>목록 17-10과 같이 일련의 메시지를 보내고 그 사이에 잠을 자게 함으로써 첫 번째 부분을 해결해 봅시다.</p>
<!-- We cannot test this one because it never stops! -->
<Listing number="17-10" caption="Sending and receiving multiple messages over the async channel and sleeping with an `await` between each message" file-name="src/main.rs">
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let vals = vec![
            String::from("안녕"),
            String::from("from"),
            String::from("the"),
            String::from("future"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            trpl::sleep(Duration::from_millis(500)).await;
        }

        while let Some(value) = rx.recv().await {
            println!("received '{value}'");
        }
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
</Listing>
<p>메시지를 보내는 것 외에도, 우리는 메시지를 받아야 합니다. 이 경우, 얼마나 많은 메시지가 들어올지 알고 있기 때문에 <code>rx.recv().await</code>를 네 번 호출하여 수동으로 수행할 수 있습니다. 하지만 실제 세계에서는 일반적으로 <em>알 수 없는</em> 수의 메시지를 기다리게 되므로, 더 이상 메시지가 없다고 판단할 때까지 계속 기다려야 합니다.</p>
<p>목록 16-10에서는 동기 채널에서 수신된 모든 항목을 처리하기 위해 <code>for</code> 루프를 사용했습니다. 하지만 러스트에는 아직 <em>비동기</em> 항목 시리즈에 대해 <code>for</code> 루프를 작성하는 방법이 없으므로, 이전에 본 적 없는 루프인 <code>while let</code> 조건부 루프를 사용해야 합니다. 이것은 <a href="ch06-03-if-let.html">if let과 let else를 사용한 간결한 제어 흐름</a><!-- ignore --> 섹션에서 보았던 <code>if let</code> 구조의 루프 버전입니다. 루프는 지정된 패턴이 값과 계속 일치하는 한 실행을 계속합니다.</p>
<p><code>rx.recv</code> 호출은 퓨처를 생성하며, 우리는 이를 기다립니다. 런타임은 준비될 때까지 퓨처를 일시 중지합니다. 메시지가 도착하면, 메시지가 도착하는 횟수만큼 퓨처는 <code>Some(message)</code>로 해결됩니다. 채널이 닫히면, 메시지가 도착했는지 여부에 관계없이 퓨처는 대신 <code>None</code>으로 해결되어 더 이상 값이 없음을 나타내며, 따라서 폴링을 중지(즉, 기다림을 중지)해야 합니다.</p>
<p><code>while let</code> 루프는 이 모든 것을 하나로 묶습니다. <code>rx.recv().await</code> 호출의 결과가 <code>Some(message)</code>이면, <code>if let</code>과 마찬가지로 메시지에 접근하여 루프 본문에서 사용할 수 있습니다. 결과가 <code>None</code>이면 루프가 종료됩니다. 루프가 완료될 때마다 다시 await 지점에 도달하므로, 런타임은 다른 메시지가 도착할 때까지 다시 일시 중지합니다.</p>
<p>이제 코드는 모든 메시지를 성공적으로 보내고 받습니다. 불행히도, 여전히 몇 가지 문제가 있습니다. 첫째, 메시지가 0.5초 간격으로 도착하지 않습니다. 프로그램을 시작한 지 2초(2,000 밀리초) 후에 한꺼번에 도착합니다. 둘째, 이 프로그램은 절대 종료되지 않습니다! 대신, 새로운 메시지를 영원히 기다립니다. <span
class="keystroke">ctrl-c</span>를 사용하여 종료해야 합니다.</p>
<p>왜 메시지가 각각의 지연 시간과 함께 도착하지 않고 전체 지연 후 한꺼번에 도착하는지 살펴보는 것부터 시작해 봅시다. 주어진 비동기 블록 내에서, 코드에 <code>await</code> 키워드가 나타나는 순서는 프로그램이 실행될 때 실행되는 순서와 같습니다.</p>
<p>목록 17-10에는 단 하나의 비동기 블록만 있으므로, 그 안의 모든 것은 선형적으로 실행됩니다. 여전히 동시성은 없습니다. 모든 <code>tx.send</code> 호출은 모든 <code>trpl::sleep</code> 호출 및 관련 await 지점과 섞여서 발생합니다. 그 후에야 <code>while let</code> 루프가 <code>recv</code> 호출의 <code>await</code> 지점을 통과할 수 있습니다.</p>
<p>각 메시지 사이에 수면 지연이 발생하는 원하는 동작을 얻으려면, 목록 17-11과 같이 <code>tx</code>와 <code>rx</code> 작업을 각자의 비동기 블록에 넣어야 합니다. 그러면 런타임은 카운팅 예제에서와 마찬가지로 <code>trpl::join</code>을 사용하여 각각을 별도로 실행할 수 있습니다. 다시 말하지만, 우리는 개별 퓨처가 아니라 <code>trpl::join</code> 호출의 결과를 기다립니다. 만약 우리가 개별 퓨처를 순차적으로 기다린다면, 결국 다시 순차적인 흐름으로 돌아가게 될 것입니다. 이는 우리가 <em>피하려고</em> 하는 바로 그 상황입니다.</p>
<!-- We cannot test this one because it never stops! -->
<Listing number="17-11" caption="Separating `send` and `recv` into their own `async` blocks and awaiting the futures for those blocks" file-name="src/main.rs">
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span>        let tx_fut = async {
            let vals = vec![
                String::from("안녕"),
                String::from("from"),
                String::from("the"),
                String::from("future"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("received '{value}'");
            }
        };

        trpl::join(tx_fut, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
</Listing>
<p>목록 17-11의 업데이트된 코드를 사용하면 메시지가 2초 후에 한꺼번에 출력되는 대신 500밀리초 간격으로 출력됩니다.</p>
<p>하지만 <code>while let</code> 루프가 <code>trpl::join</code>과 상호작용하는 방식 때문에 프로그램은 여전히 종료되지 않습니다:</p>
<ul>
<li><code>trpl::join</code>에서 반환된 퓨처는 전달된 <em>두</em> 퓨처가 모두 완료된 후에만 완료됩니다.</li>
<li><code>tx</code> 퓨처는 <code>vals</code>의 마지막 메시지를 보낸 후 수면을 마쳤을 때 완료됩니다.</li>
<li><code>rx</code> 퓨처는 <code>while let</code> 루프가 끝날 때까지 완료되지 않습니다.</li>
<li><code>while let</code> 루프는 <code>rx.recv</code>를 기다리는 과정(await)에서 <code>None</code>이 생성될 때까지 끝나지 않습니다.</li>
<li><code>rx.recv</code>를 기다리는 과정은 채널의 반대편 끝이 닫힌 후에야 <code>None</code>을 반환합니다.</li>
<li>채널은 우리가 <code>rx.close</code>를 호출하거나 송신 측인 <code>tx</code>가 드롭될 때만 닫힙니다.</li>
<li>우리는 어디에서도 <code>rx.close</code>를 호출하지 않으며, <code>tx</code>는 <code>trpl::run</code>에 전달된 가장 바깥쪽의 비동기 블록이 끝날 때까지 드롭되지 않습니다.</li>
<li>그 블록은 <code>trpl::join</code>이 완료될 때까지 차단되어 끝날 수 없으며, 이는 우리를 다시 이 목록의 처음으로 되돌려 보냅니다.</li>
</ul>
<p>어딘가에서 <code>rx.close</code>를 호출하여 수동으로 <code>rx</code>를 닫을 수도 있지만, 그것은 별로 말이 되지 않습니다. 임의의 개수의 메시지를 처리한 후 중지하면 프로그램은 종료되겠지만, 메시지를 놓칠 수 있습니다. 우리는 함수가 끝나기 <em>전에</em> <code>tx</code>가 드롭되도록 보장할 다른 방법이 필요합니다.</p>
<p>현재 메시지를 보내는 비동기 블록은 <code>tx</code>를 대여하기만 하는데, 메시지를 보내는 데 소유권이 필요하지 않기 때문입니다. 하지만 만약 우리가 <code>tx</code>를 그 비동기 블록으로 이동시킬 수 있다면, 해당 블록이 끝날 때 <code>tx</code>가 드롭될 것입니다. 13장의 <a href="ch13-01-closures.html#capturing-references-or-moving-ownership">참조 캡처하기 또는 소유권 이동하기</a><!-- ignore --> 섹션에서 클로저와 함께 <code>move</code> 키워드를 사용하는 방법을 배웠고, 16장의 <a href="ch16-01-threads.html#using-move-closures-with-threads">스레드와 함께 <code>move</code> 클로저 사용하기</a><!-- ignore
--> 섹션에서 논의했듯이, 스레드로 작업할 때 종종 데이터를 클로저로 이동시켜야 합니다. 비동기 블록에도 동일한 기본 역학이 적용되므로, <code>move</code> 키워드는 클로저에서와 마찬가지로 비동기 블록에서도 작동합니다.</p>
<p>목록 17-12에서 우리는 메시지를 보내는 데 사용되는 블록을 <code>async</code>에서 <code>async move</code>로 변경합니다. 코드의 <em>이</em> 버전을 실행하면 마지막 메시지가 전송되고 수신된 후 우아하게 종료됩니다.</p>
<Listing number="17-12" caption="A  revision of the code from Listing 17-11 that correctly shuts down when complete" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let tx_fut = async move {
            let vals = vec![
                String::from("안녕"),
                String::from("from"),
                String::from("the"),
                String::from("future"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("received '{value}'");
            }
        };

        trpl::join(tx_fut, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 비동기 채널은 다중 생산자 채널이기도 하므로, 목록 17-13과 같이 여러 퓨처에서 메시지를 보내고 싶다면 <code>tx</code>에 대해 <code>clone</code>을 호출할 수 있습니다.</p>
<Listing number="17-13" caption="Using multiple producers with async blocks" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let tx1 = tx.clone();
        let tx1_fut = async move {
            let vals = vec![
                String::from("안녕"),
                String::from("from"),
                String::from("the"),
                String::from("future"),
            ];

            for val in vals {
                tx1.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("received '{value}'");
            }
        };

        let tx_fut = async move {
            let vals = vec![
                String::from("more"),
                String::from("messages"),
                String::from("for"),
                String::from("you"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(1500)).await;
            }
        };

        trpl::join3(tx1_fut, tx_fut, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>먼저 <code>tx</code>를 클론하여 첫 번째 비동기 블록 외부에서 <code>tx1</code>을 생성합니다. 이전에 <code>tx</code>로 했던 것과 마찬가지로 <code>tx1</code>을 해당 블록으로 이동시킵니다. 그런 다음 나중에 원래의 <code>tx</code>를 <em>새로운</em> 비동기 블록으로 이동시키고, 거기서 약간 더 느린 지연 시간으로 더 많은 메시지를 보냅니다. 우리는 우연히 이 새로운 비동기 블록을 메시지 수신을 위한 비동기 블록 뒤에 두었지만, 그 앞에 두어도 상관없습니다. 핵심은 퓨처가 생성되는 순서가 아니라 기다려지는(await) 순서입니다.</p>
<p>메시지를 보내기 위한 두 비동기 블록은 모두 <code>async move</code> 블록이어야 하며, 그래야 해당 블록이 끝날 때 <code>tx</code>와 <code>tx1</code>이 모두 드롭됩니다. 그렇지 않으면 처음 시작했던 것과 동일한 무한 루프에 빠지게 될 것입니다. 마지막으로, 추가된 퓨처를 처리하기 위해 <code>trpl::join</code>에서 <code>trpl::join3</code>으로 전환합니다.</p>
<p>이제 양쪽 송신 퓨처의 모든 메시지를 볼 수 있으며, 송신 퓨처들이 전송 후 약간 다른 지연 시간을 사용하기 때문에 메시지들도 서로 다른 간격으로 수신됩니다.</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">received 'hi'
received 'more'
received 'from'
received 'the'
received 'messages'
received 'future'
received 'for'
received 'you'
</code></pre>
<p>이것은 좋은 시작이지만, <code>join</code>으로는 2개, <code>join3</code>으로는 3개와 같이 소수의 퓨처로만 제한됩니다. 더 많은 퓨처를 사용하는 방법을 알아봅시다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="임의의-수의-퓨처와-작업하기"><a class="header" href="#임의의-수의-퓨처와-작업하기">임의의 수의 퓨처와 작업하기</a></h2>
<p>이전 섹션에서 두 개의 퓨처를 사용하다 세 개로 전환했을 때, <code>join</code>을 사용하는 대신 <code>join3</code>을 사용하도록 전환해야 했습니다. 조인하려는 퓨처의 개수를 변경할 때마다 다른 함수를 호출해야 한다면 번거로울 것입니다. 다행히도 우리는 임의의 수의 인수를 전달할 수 있는 매크로 형태의 <code>join</code>을 가지고 있습니다. 또한 이 매크로는 스스로 퓨처를 기다리는(await) 과정을 처리합니다. 따라서 목록 17-14에서와 같이 <code>join3</code> 대신 <code>join!</code>을 사용하도록 목록 17-13의 코드를 다시 작성할 수 있습니다.</p>
<Listing number="17-14" caption="Using `join!` to wait for multiple futures" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("안녕"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        trpl::join!(tx1_fut, tx_fut, rx_fut);
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p><code>join</code>, <code>join3</code>, <code>join4</code> 등을 번갈아 가며 사용하는 것보다 확실히 개선된 방식입니다! 하지만 이 매크로 형태조차도 퓨처의 개수를 미리 알고 있을 때만 작동합니다. 하지만 실제 러스트에서는 퓨처를 컬렉션에 넣고 그 중 일부 또는 전부가 완료되기를 기다리는 것이 일반적인 패턴입니다.</p>
<p>어떤 컬렉션에 있는 모든 퓨처를 확인하려면, 그것들을 반복(iterate)하고 <em>모두</em> 조인해야 합니다. <code>trpl::join_all</code> 함수는 13장의 <a href="ch13-02-iterators.html#the-iterator-trait-and-the-next-method">Iterator 트레이트와 next 메서드</a><!-- ignore -->에서 배운 <code>Iterator</code> 트레이트를 구현하는 모든 타입을 받아들이므로, 바로 우리가 찾던 것입니다. 목록 17-15와 같이 퓨처를 벡터에 넣고 <code>join!</code>을 <code>join_all</code>로 교체해 봅시다.</p>
<Listing  number="17-15" caption="Storing anonymous futures in a vector and calling `join_all`">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("안녕"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        let futures = vec![tx1_fut, rx_fut, tx_fut];

        trpl::join_all(futures).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
</Listing>
<p>불행히도 이 코드는 컴파일되지 않습니다. 대신 다음과 같은 에러가 발생합니다:</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-15/
cargo build
copy just the compiler error
-->
<pre><code class="language-text">error[E0308]: mismatched types
  --&gt; src/main.rs:45:37
   |
10 |         let tx1_fut = async move {
   |                       ---------- the expected `async` block
...
24 |         let rx_fut = async {
   |                      ----- the found `async` block
...
45 |         let futures = vec![tx1_fut, rx_fut, tx_fut];
   |                                     ^^^^^^ expected `async` block, found a 
different `async` block
   |
   = note: expected `async` block `{async block@src/main.rs:10:23: 10:33}`
              found `async` block `{async block@src/main.rs:24:22: 24:27}`
   = note: no two async blocks, even if identical, have the same type
   = help: consider pinning your async block and casting it to a trait object
</code></pre>
<p>이것은 놀라운 일일 수도 있습니다. 결국 어떤 비동기 블록도 아무것도 반환하지 않으므로, 각각은 <code>Future&lt;Output = ()&gt;</code>를 생성합니다. 하지만 <code>Future</code>는 트레이트이며, 컴파일러는 각 비동기 블록에 대해 고유한 열거형을 생성한다는 점을 기억하세요. 두 개의 서로 다른 수동 작성 구조체를 <code>Vec</code>에 넣을 수 없는 것처럼, 컴파일러가 생성한 서로 다른 열거형에도 동일한 규칙이 적용됩니다.</p>
<p>이를 작동시키려면 12장의 <a href="ch12-03-improving-error-handling-and-modularity.html">“run 함수에서 에러 반환하기”</a><!-- ignore -->에서 했던 것처럼 _트레이트 객체(trait objects)_를 사용해야 합니다. (18장에서 트레이트 객체에 대해 자세히 다룰 것입니다.) 트레이트 객체를 사용하면 이러한 타입들에 의해 생성된 각각의 익명 퓨처들을 동일한 타입으로 취급할 수 있는데, 이는 그것들이 모두 <code>Future</code> 트레이트를 구현하기 때문입니다.</p>
<blockquote>
<p>참고: 8장의 <a href="ch12-03-improving-error-handling-and-modularity.html#returning-errors-from-the-run-function">열거형을 사용하여 여러 타입 저장하기</a><!-- ignore --> 섹션에서, 우리는 <code>Vec</code>에 여러 타입을 포함시키는 또 다른 방법인 벡터에 나타날 수 있는 각 타입을 나타내는 열거형을 사용하는 것에 대해 논의했습니다. 하지만 여기서는 그렇게 할 수 없습니다. 우선, 각 타입이 익명이기 때문에 이름을 지정할 방법이 없습니다. 또한, 우리가 애초에 벡터와 <code>join_all</code>을 사용하려 했던 이유는 출력 타입이 동일하다는 점만 중요하게 여기는 동적인 퓨처 컬렉션으로 작업할 수 있기 때문이었습니다.</p>
</blockquote>
<p>목록 17-16과 같이 <code>vec!</code> 안의 각 퓨처를 <code>Box::new</code>로 감싸는 것으로 시작합니다.</p>
<Listing number="17-16" caption="Using `Box::new` to align the types of the futures in a `Vec`" file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("안녕"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        let futures =
            vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];

        trpl::join_all(futures).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
</Listing>
<p>불행히도 이 코드는 여전히 컴파일되지 않습니다. 사실, 우리는 두 번째와 세 번째 <code>Box::new</code> 호출 모두에 대해 이전에 발생했던 것과 동일한 기본적인 에러와, <code>Unpin</code> 트레이트를 언급하는 새로운 에러를 받게 됩니다. <code>Unpin</code> 에러에 대해서는 잠시 후에 다시 다루겠습니다. 먼저, <code>futures</code> 변수의 타입을 명시적으로 어노테이션하여 <code>Box::new</code> 호출에 대한 타입 에러를 수정해 봅시다(목록 17-17 참조).</p>
<Listing number="17-17" caption="Fixing the rest of the type mismatch errors by using an explicit type declaration" file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::{future::Future, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("안녕"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        let futures: Vec&lt;Box&lt;dyn Future&lt;Output = ()&gt;&gt;&gt; =
            vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];
<span class="boring">
</span><span class="boring">        trpl::join_all(futures).await;
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre>
</Listing>
<p>이 타입 선언은 조금 복잡하므로, 하나씩 살펴봅시다:</p>
<ol>
<li>가장 안쪽의 타입은 퓨처 그 자체입니다. <code>Future&lt;Output = ()&gt;</code>라고 작성하여 퓨처의 출력이 유닛 타입 <code>()</code>임을 명시적으로 나타냅니다.</li>
<li>그런 다음 트레이트에 <code>dyn</code>을 어노테이션하여 동적(dynamic)임을 표시합니다.</li>
<li>전체 트레이트 참조는 <code>Box</code>로 감싸져 있습니다.</li>
<li>마지막으로, <code>futures</code>가 이러한 항목들을 포함하는 <code>Vec</code>임을 명시적으로 선언합니다.</li>
</ol>
<p>그것만으로도 큰 차이가 생겼습니다. 이제 컴파일러를 실행하면 <code>Unpin</code>을 언급하는 에러만 발생합니다. 에러가 세 개나 되지만, 그 내용은 매우 유사합니다.</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-16
cargo build
# copy *only* the errors
# fix the paths
-->
<p>29 |     F: Future, |        ^^^^^^ <code>JoinAll</code>의 이 바운드에 의해 요구됨</p>
<pre><code></code></pre>
<p>소화해야 할 내용이 꽤 많으므로, 하나씩 쪼개어 봅시다. 메시지의 첫 번째 부분은 첫 번째 비동기 블록(<code>src/main.rs:8:23: 20:10</code>)이 <code>Unpin</code> 트레이트를 구현하지 않았음을 알려주고, 이를 해결하기 위해 <code>pin!</code>이나 <code>Box::pin</code>을 사용할 것을 제안합니다. 이 장의 뒷부분에서 <code>Pin</code>과 <code>Unpin</code>에 대한 세부 사항을 좀 더 깊이 파헤쳐 볼 것입니다. 하지만 지금은 일단 막힌 부분을 뚫기 위해 컴파일러의 조언을 따르기로 합시다. 목록 17-18에서는 먼저 각 <code>Box</code>를 <code>Pin</code>으로 감싸도록 <code>futures</code>의 타입 어노테이션을 업데이트하는 것으로 시작합니다. 두 번째로, 퓨처 자체를 피닝하기 위해 <code>Box::pin</code>을 사용합니다.</p>
<Listing number="17-18" caption="Using `Pin` and `Box::pin` to make the `Vec` type check" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::{
</span><span class="boring">    future::Future,
</span><span class="boring">    pin::{pin, Pin},
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = pin!(async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("안녕"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        let rx_fut = pin!(async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        let tx_fut = pin!(async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        });
</span><span class="boring">
</span>        let futures: Vec&lt;Pin&lt;Box&lt;dyn Future&lt;Output = ()&gt;&gt;&gt;&gt; =
            vec![Box::pin(tx1_fut), Box::pin(rx_fut), Box::pin(tx_fut)];
<span class="boring">
</span><span class="boring">        trpl::join_all(futures).await;
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>이를 컴파일하고 실행하면, 마침내 우리가 원하던 출력을 얻게 됩니다:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">received 'hi'
received 'more'
received 'from'
received 'messages'
received 'the'
received 'for'
received 'future'
received 'you'
</code></pre>
<p>휴!</p>
<p>여기서 더 탐구해 볼 내용이 좀 더 있습니다. 우선, <code>Pin&lt;Box&lt;T&gt;&gt;</code>를 사용하는 것은 이 퓨처들을 <code>Box</code>로 힙에 넣음으로써 약간의 오버헤드를 추가합니다. 그리고 우리는 단지 타입을 맞추기 위해 그렇게 하고 있는 것입니다. 결국 우리는 실제로 힙 할당이 필요하지 않습니다: 이 퓨처들은 이 특정 함수에 로컬인 것들이기 때문입니다. 앞에서 언급했듯이, <code>Pin</code> 자체도 래퍼 타입이므로, 힙 할당을 하지 않고도 <code>Vec</code>에 단일 타입을 가질 수 있는 이점(<code>Box</code>를 선택했던 원래 이유)을 얻을 수 있습니다. <code>std::pin::pin</code> 매크로를 사용하여 각 퓨처에 <code>Pin</code>을 직접 사용할 수 있습니다.</p>
<p>하지만 피닝된 참조의 타입을 여전히 명시해야 합니다. 그렇지 않으면 러스트는 여전히 이것들을 <code>Vec</code>에 필요한 동적 트레이트 객체로 해석하는 방법을 알지 못할 것입니다. 따라서 목록 17-19와 같이 각 퓨처를 정의할 때 <code>pin!</code>을 수행하고, <code>futures</code>를 동적 퓨처 타입에 대한 피닝된 가변 참조를 포함하는 <code>Vec</code>으로 정의합니다.</p>
<Listing number="17-19" caption="Using `Pin` directly with the `pin!` macro to avoid unnecessary heap allocations" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::{
</span><span class="boring">    future::Future,
</span><span class="boring">    pin::{pin, Pin},
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span>        let tx1_fut = pin!(async move {
            // --생략--
<span class="boring">            let vals = vec![
</span><span class="boring">                String::from("안녕"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span>        });

        let rx_fut = pin!(async {
            // --생략--
<span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span>        });

        let tx_fut = pin!(async move {
            // --생략--
<span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span>        });

        let futures: Vec&lt;Pin&lt;&amp;mut dyn Future&lt;Output = ()&gt;&gt;&gt; =
            vec![tx1_fut, rx_fut, tx_fut];
<span class="boring">
</span><span class="boring">        trpl::join_all(futures).await;
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>우리는 서로 다른 <code>Output</code> 타입을 가질 수 있다는 사실을 무시한 채 여기까지 왔습니다. 예를 들어, 목록 17-20에서 <code>a</code>에 대한 익명 퓨처는 <code>Future&lt;Output = u32&gt;</code>를 구현하고, <code>b</code>에 대한 익명 퓨처는 <code>Future&lt;Output = &amp;str&gt;</code>를 구현하며, <code>c</code>에 대한 익명 퓨처는 <code>Future&lt;Output = bool&gt;</code>를 구현합니다.</p>
<Listing number="17-20" caption="Three futures with distinct types" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let a = async { 1u32 };
        let b = async { "Hello!" };
        let c = async { true };

        let (a_result, b_result, c_result) = trpl::join!(a, b, c);
        println!("{a_result}, {b_result}, {c_result}");
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p><code>trpl::join!</code>은 여러 퓨처 타입을 전달할 수 있게 해주고 그 타입들의 튜플을 생성하므로, 이를 사용하여 그것들을 기다릴 수 있습니다. <code>trpl::join_all</code>은 전달된 모든 퓨처가 동일한 타입을 가질 것을 요구하기 때문에 사용할 수 <em>없습니다</em>. 기억하세요, 그 에러가 바로 우리를 <code>Pin</code>과 함께하는 이 모험으로 이끌었던 것입니다!</p>
<p>이것은 근본적인 트레이드오프입니다: 우리는 모든 퓨처가 동일한 타입을 가지고 있는 한 <code>join_all</code>로 동적인 수의 퓨처를 처리하거나, 타입이 다르더라도 <code>join</code> 함수들이나 <code>join!</code> 매크로를 사용하여 정해진 수의 퓨처를 처리할 수 있습니다. 이것은 러스트에서 다른 타입을 다룰 때 직면하게 되는 것과 동일한 시나리오입니다. 퓨처를 다루기 위한 몇 가지 멋진 문법이 있기는 하지만, 퓨처가 특별한 것은 아니며, 그것은 좋은 일입니다.</p>
<h3 id="퓨처-경쟁시키기"><a class="header" href="#퓨처-경쟁시키기">퓨처 경쟁시키기</a></h3>
<p>우리가 <code>join</code> 계열의 함수나 매크로로 퓨처들을 "조인"할 때는, 다음으로 넘어가기 전에 그것들이 <em>모두</em> 끝나기를 요구합니다. 하지만 가끔은 다음으로 넘어가기 전에 세트 중 <em>일부</em> 퓨처만 끝나면 되는 경우도 있는데, 이는 한 퓨처를 다른 퓨처와 경쟁시키는 것과 비슷합니다.</p>
<p>목록 17-21에서 우리는 다시 한번 <code>trpl::race</code>를 사용하여 <code>slow</code>와 <code>fast</code>라는 두 개의 퓨처를 서로 경쟁시킵니다.</p>
<Listing number="17-21" caption="Using `race` to get the result of whichever future finishes first" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let slow = async {
            println!("'slow' 시작됨.");
            trpl::sleep(Duration::from_millis(100)).await;
            println!("'slow' 완료됨.");
        };

        let fast = async {
            println!("'fast' 시작됨.");
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'fast' 완료됨.");
        };

        trpl::race(slow, fast).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>각 퓨처는 실행을 시작할 때 메시지를 출력하고, <code>sleep</code>을 호출하고 기다림으로써 일정 시간 동안 멈춘 뒤, 완료될 때 다른 메시지를 출력합니다. 그런 다음 <code>slow</code>와 <code>fast</code>를 모두 <code>trpl::race</code>에 전달하고 둘 중 하나가 끝날 때까지 기다립니다. (여기서 결과는 그리 놀랍지 않습니다: <code>fast</code>가 이깁니다.) <a href="ch17-01-futures-and-syntax.html#our-first-async-program">“첫 번째 비동기 프로그램”</a><!--
ignore -->에서 <code>race</code>를 사용했을 때와 달리, 여기서는 반환되는 <code>Either</code> 인스턴스를 그냥 무시합니다. 모든 흥미로운 동작이 비동기 블록의 본문 내에서 발생하기 때문입니다.</p>
<p><code>race</code>에 전달하는 인수의 순서를 뒤집으면, <code>fast</code> 퓨처가 항상 먼저 완료됨에도 불구하고 "started" 메시지의 순서가 바뀐다는 점에 주목하세요. 이는 이 특정 <code>race</code> 함수의 구현이 공정하지 않기 때문입니다. 이 함수는 항상 인수로 전달된 순서대로 퓨처를 실행합니다. 다른 구현들은 공정하며, 어떤 퓨처를 먼저 폴링할지 무작위로 선택합니다. 하지만 우리가 사용하는 <code>race</code> 구현이 공정한지 여부와 관계없이, 다른 태스크가 시작되기 전에 퓨처 중 _하나_는 본문의 첫 번째 <code>await</code>까지 실행됩니다.</p>
<p><a href="ch17-01-futures-and-syntax.html#our-first-async-program">첫 번째 비동기 프로그램</a><!-- ignore -->에서 보았듯이, 각 await 지점에서 러스트는 기다리고 있는 퓨처가 준비되지 않은 경우 런타임에 태스크를 일시 중지하고 다른 태스크로 전환할 기회를 줍니다. 그 반대도 마찬가지입니다: 러스트는 <em>오직</em> await 지점에서만 비동기 블록을 일시 중지하고 런타임에 제어권을 돌려줍니다. await 지점 사이의 모든 것은 동기적입니다.</p>
<p>이는 만약 여러분이 await 지점이 없는 비동기 블록에서 많은 작업을 수행한다면, 해당 퓨처가 다른 모든 퓨처의 진행을 차단하게 됨을 의미합니다. 때때로 이를 한 퓨처가 다른 퓨처를 <em>굶주리게(starving)</em> 한다고 표현하기도 합니다. 어떤 경우에는 큰 문제가 아닐 수도 있습니다. 하지만 비용이 많이 드는 설정이나 오래 걸리는 작업을 수행하거나, 특정 작업을 무기한 계속하는 퓨처가 있는 경우라면, 언제 어디서 런타임에 제어권을 넘겨줄지 생각해야 합니다.</p>
<p>같은 맥락에서, 오래 걸리는 블로킹 작업이 있는 경우, 비동기는 프로그램의 서로 다른 부분들이 서로 관계를 맺는 방식을 제공하는 유용한 도구가 될 수 있습니다.</p>
<p>하지만 그런 경우에 <em>어떻게</em> 런타임에 제어권을 넘겨줄 수 있을까요?</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="yielding"></a></p>
<h3 id="런타임에-제어권-양보하기"><a class="header" href="#런타임에-제어권-양보하기">런타임에 제어권 양보하기</a></h3>
<p>오래 걸리는 작업을 시뮬레이션해 봅시다. 목록 17-22는 <code>slow</code> 함수를 소개합니다.</p>
<Listing number="17-22" caption="Using `thread::sleep` to simulate slow operations" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        // 나중에 여기서 `slow`를 호출할 것입니다
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span>fn slow(name: &amp;str, ms: u64) {
    thread::sleep(Duration::from_millis(ms));
    println!("' {name}'이 {ms}ms 동안 실행되었습니다");
}</code></pre></pre>
</Listing>
<p>이 코드는 <code>trpl::sleep</code> 대신 <code>std::thread::sleep</code>을 사용하여 <code>slow</code>를 호출할 때 현재 스레드가 수 밀리초 동안 차단되도록 합니다. 우리는 <code>slow</code>를 사용하여 실행 시간이 길고 차단되는 실제 작업을 대신할 수 있습니다.</p>
<p>목록 17-23에서 우리는 한 쌍의 퓨처에서 이런 종류의 CPU 바운드 작업을 수행하는 것을 흉내내기 위해 <code>slow</code>를 사용합니다.목록 17-23에서 우리는 한 쌍의 퓨처에서 이런 종류의 CPU 바운드 작업을 수행하는 것을 흉내내기 위해 <code>slow</code>를 사용합니다.</p>
<Listing number="17-23" caption="Using `thread::sleep` to simulate slow operations" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let a = async {
            println!("'a'가 시작되었습니다.");
            slow("a", 30);
            slow("a", 10);
            slow("a", 20);
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'a'가 끝났습니다.");
        };

        let b = async {
            println!("'b'가 시작되었습니다.");
            slow("b", 75);
            slow("b", 10);
            slow("b", 15);
            slow("b", 350);
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'b' 완료됨.");
        };

        trpl::race(a, b).await;
<span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn slow(name: &amp;str, ms: u64) {
</span><span class="boring">    thread::sleep(Duration::from_millis(ms));
</span><span class="boring">    println!("' {name}'이 {ms}ms 동안 실행되었습니다");
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>우선, 각 퓨처는 일련의 느린 작업을 수행한 <em>후에야</em> 런타임에 제어권을 돌려줍니다. 이 코드를 실행하면 다음과 같은 출력이 표시됩니다.</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-23/
cargo run
copy just the output
-->
<pre><code class="language-text">'a' started.
'a' ran for 30ms
'a' ran for 10ms
'a' ran for 20ms
'b' started.
'b' ran for 75ms
'b' ran for 10ms
'b' ran for 15ms
'b' ran for 350ms
'a' finished.
</code></pre>
<p>이전 예제와 마찬가지로, <code>race</code>는 <code>a</code>가 끝나자마자 종료됩니다. 하지만 두 퓨처 사이에 교차 실행(interleaving)은 없습니다. <code>a</code> 퓨처는 <code>trpl::sleep</code> 호출이 기다려질 때(awaited)까지 모든 작업을 수행하고, 그 다음 <code>b</code> 퓨처가 자신의 <code>trpl::sleep</code> 호출이 기다려질 때까지 모든 작업을 수행하며, 마지막으로 <code>a</code> 퓨처가 완료됩니다. 두 퓨처가 느린 작업들 사이에서 번갈아 가며 진행되도록 하려면, 런타임에 제어권을 넘겨줄 수 있는 await 지점이 필요합니다. 즉, 우리가 기다릴 수 있는 무언가가 필요하다는 뜻입니다!</p>
<p>우리는 이미 목록 17-23에서 이런 종류의 제어권 양도가 일어나는 것을 볼 수 있습니다: 만약 <code>a</code> 퓨처 끝에 있는 <code>trpl::sleep</code>을 제거했다면, <code>b</code> 퓨처가 <em>전혀</em> 실행되지 않은 채로 <code>a</code>가 완료되었을 것입니다. 목록 17-24와 같이, 작업들이 서로 교대로 진행되도록 하는 시작점으로 <code>sleep</code> 함수를 사용해 봅시다.</p>
<Listing number="17-24" caption="Using `sleep` to let operations switch off making progress" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let one_ms = Duration::from_millis(1);

        let a = async {
            println!("'a'가 시작되었습니다.");
            slow("a", 30);
            trpl::sleep(one_ms).await;
            slow("a", 10);
            trpl::sleep(one_ms).await;
            slow("a", 20);
            trpl::sleep(one_ms).await;
            println!("'a'가 끝났습니다.");
        };

        let b = async {
            println!("'b'가 시작되었습니다.");
            slow("b", 75);
            trpl::sleep(one_ms).await;
            slow("b", 10);
            trpl::sleep(one_ms).await;
            slow("b", 15);
            trpl::sleep(one_ms).await;
            slow("b", 35);
            trpl::sleep(one_ms).await;
            println!("'b' 완료됨.");
        };
<span class="boring">
</span><span class="boring">        trpl::race(a, b).await;
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn slow(name: &amp;str, ms: u64) {
</span><span class="boring">    thread::sleep(Duration::from_millis(ms));
</span><span class="boring">    println!("' {name}'이 {ms}ms 동안 실행되었습니다");
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>목록 17-24에서는 각 <code>slow</code> 호출 사이에 await 지점이 있는 <code>trpl::sleep</code> 호출을 추가합니다. 이제 두 퓨처의 작업이 교차되어 실행됩니다.</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-24
cargo run
copy just the output
-->
<pre><code class="language-text">'a' started.
'a' ran for 30ms
'b' started.
'b' ran for 75ms
'a' ran for 10ms
'b' ran for 10ms
'a' ran for 20ms
'b' ran for 15ms
'a' finished.
</code></pre>
<p><code>a</code> 퓨처는 <code>trpl::sleep</code>을 호출하기 전에 <code>slow</code>를 호출하므로 제어권을 <code>b</code>에 넘겨주기 전까지 잠시 동안 실행되지만, 그 이후로는 한 퓨처가 await 지점에 도달할 때마다 두 퓨처가 번갈아 가며 실행됩니다. 이 경우에는 모든 <code>slow</code> 호출 뒤에 그렇게 했지만, 우리에게 가장 적합한 방식으로 작업을 나눌 수 있습니다.<code>a</code> 퓨처는 <code>trpl::sleep</code>을 호출하기 전에 <code>slow</code>를 호출하므로 제어권을 <code>b</code>에 넘겨주기 전까지 잠시 동안 실행되지만, 그 이후로는 한 퓨처가 await 지점에 도달할 때마다 두 퓨처가 번갈아 가며 실행됩니다. 이 경우에는 모든 <code>slow</code> 호출 뒤에 그렇게 했지만, 우리에게 가장 적합한 방식으로 작업을 나눌 수 있습니다.</p>
<p>하지만 여기서 정말로 <em>잠을 자고(sleep)</em> 싶은 것은 아닙니다: 우리는 가능한 한 빨리 작업을 진행하고 싶습니다. 단지 런타임에 제어권을 돌려주기만 하면 됩니다. <code>yield_now</code> 함수를 사용하여 이를 직접 수행할 수 있습니다. 목록 17-25에서는 모든 <code>sleep</code> 호출을 <code>yield_now</code>로 바꿉니다.</p>
<Listing number="17-25" caption="Using `yield_now` to let operations switch off making progress" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let a = async {
            println!("'a'가 시작되었습니다.");
            slow("a", 30);
            trpl::yield_now().await;
            slow("a", 10);
            trpl::yield_now().await;
            slow("a", 20);
            trpl::yield_now().await;
            println!("'a'가 끝났습니다.");
        };

        let b = async {
            println!("'b'가 시작되었습니다.");
            slow("b", 75);
            trpl::yield_now().await;
            slow("b", 10);
            trpl::yield_now().await;
            slow("b", 15);
            trpl::yield_now().await;
            slow("b", 35);
            trpl::yield_now().await;
            println!("'b' 완료됨.");
        };
<span class="boring">
</span><span class="boring">        trpl::race(a, b).await;
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn slow(name: &amp;str, ms: u64) {
</span><span class="boring">    thread::sleep(Duration::from_millis(ms));
</span><span class="boring">    println!("' {name}'이 {ms}ms 동안 실행되었습니다");
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 코드는 실제 의도를 더 명확하게 나타낼 뿐만 아니라, <code>sleep</code>을 사용하는 것보다 상당히 빠를 수 있습니다. 왜냐하면 <code>sleep</code>에서 사용하는 것과 같은 타이머는 종종 정밀도에 한계가 있기 때문입니다. 예를 들어 우리가 사용하는 <code>sleep</code> 버전은 1나노초의 <code>Duration</code>을 전달하더라도 항상 최소 1밀리초 동안 잠을 잡니다. 다시 말하지만, 현대의 컴퓨터는 <em>빠릅니다</em>: 1밀리초 동안 많은 일을 할 수 있습니다!</p>
<p>목록 17-26과 같은 간단한 벤치마크를 설정하여 이를 직접 확인할 수 있습니다. (이것이 특별히 엄격한 성능 테스트 방식은 아니지만, 여기에서 차이점을 보여주기에는 충분합니다.)</p>
<Listing number="17-26" caption="Comparing the performance of `sleep` and `yield_now`" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::time::{Duration, Instant};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let one_ns = Duration::from_nanos(1);
        let start = Instant::now();
        async {
            for _ in 1..1000 {
                trpl::sleep(one_ns).await;
            }
        }
        .await;
        let time = Instant::now() - start;
        println!(
            "'sleep' 버전이 {}초 후에 끝났습니다.",
            time.as_secs_f32()
        );

        let start = Instant::now();
        async {
            for _ in 1..1000 {
                trpl::yield_now().await;
            }
        }
        .await;
        let time = Instant::now() - start;
        println!(
            "'yield' 버전이 {}초 후에 끝났습니다.",
            time.as_secs_f32()
        );
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>여기서는 모든 상태 출력을 건너뛰고, <code>trpl::sleep</code>에 1나노초의 <code>Duration</code>을 전달하고, 각 퓨처가 서로 전환 없이 개별적으로 실행되도록 합니다. 그런 다음 1,000번 반복 실행하여 <code>trpl::sleep</code>을 사용하는 퓨처가 <code>trpl::yield_now</code>를 사용하는 퓨처와 비교하여 얼마나 걸리는지 확인합니다.</p>
<p><code>yield_now</code>를 사용한 버전이 <em>훨씬</em> 더 빠릅니다!</p>
<p>이는 프로그램의 다른 부분이 수행하는 작업에 따라 비동기가 계산 위주의 작업(compute-bound tasks)에도 유용할 수 있음을 의미합니다. 프로그램의 서로 다른 부분 간의 관계를 구조화하는 유용한 도구를 제공하기 때문입니다. 이것은 각 퓨처가 await 지점을 통해 언제 제어권을 넘겨줄지 결정할 수 있는 _협력적 멀티태스킹(cooperative multitasking)_의 한 형태입니다. 따라서 각 퓨처는 너무 오랫동안 차단(blocking)되지 않도록 할 책임도 있습니다. 일부 러스트 기반 임베디드 운영 체제에서는 이것이 <em>유일한</em> 종류의 멀티태스킹입니다!</p>
<p>물론 실제 코드에서는 모든 줄마다 함수 호출과 await 지점을 교대로 배치하지는 않을 것입니다. 이런 식으로 제어권을 양보하는 것이 상대적으로 비용이 적게 들긴 하지만, 공짜는 아닙니다. 많은 경우 계산 위주의 작업을 나누려고 시도하는 것이 작업을 상당히 느리게 만들 수 있으므로, 때로는 <em>전체적인</em> 성능을 위해 작업이 잠시 차단되도록 두는 것이 더 나을 수도 있습니다. 항상 여러분의 코드가 실제로 성능 병목 현상을 일으키는 부분이 어디인지 측정해 보세요. 하지만 만약 동시적으로 일어날 것이라고 예상했던 많은 작업들이 직렬로 일어나고 있는 것을 보고 있다면, 이러한 근본적인 역학 관계를 염두에 두는 것이 중요합니다!</p>
<h3 id="우리만의-비동기-추상화-구축하기"><a class="header" href="#우리만의-비동기-추상화-구축하기">우리만의 비동기 추상화 구축하기</a></h3>
<p>우리는 또한 퓨처들을 함께 조합하여 새로운 패턴을 만들 수도 있습니다. 예를 들어, 우리가 이미 가지고 있는 비동기 빌딩 블록들로 <code>timeout</code> 함수를 만들 수 있습니다. 작업을 마치면, 그 결과는 더 많은 비동기 추상화를 만드는 데 사용할 수 있는 또 다른 빌딩 블록이 될 것입니다.</p>
<p>목록 17-27은 느린 퓨처에 대해 이 <code>timeout</code>이 어떻게 작동할 것으로 기대되는지 보여줍니다.</p>
<Listing number="17-27" caption="Using our imagined `timeout` to run a slow operation with a time limit" file-name="src/main.rs">
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let slow = async {
            trpl::sleep(Duration::from_millis(100)).await;
            "완료했습니다!"
        };

        match timeout(slow, Duration::from_millis(10)).await {
            Ok(message) =&gt; println!("' {message}'로 성공했습니다"),
            Err(duration) =&gt; {
                println!({}초 후 실패했습니다, duration.as_secs())
            }
        }
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
</Listing>
<p>이를 구현해 봅시다! 시작하기 위해, <code>timeout</code>의 API에 대해 생각해 봅시다:</p>
<ul>
<li>우리가 그것을 기다릴(await) 수 있도록 그 자체로 비동기 함수여야 합니다.</li>
<li>첫 번째 매개변수는 실행할 퓨처여야 합니다. 어떤 퓨처와도 함께 작동할 수 있도록 제네릭으로 만들 수 있습니다.</li>
<li>두 번째 매개변수는 대기할 최대 시간입니다. <code>Duration</code>을 사용하면 <code>trpl::sleep</code>에 전달하기 쉬울 것입니다.</li>
<li>이것은 <code>Result</code>를 반환해야 합니다. 만약 퓨처가 성공적으로 완료되면, <code>Result</code>는 퓨처가 생성한 값과 함께 <code>Ok</code>가 될 것입니다. 만약 타임아웃이 먼저 경과하면, <code>Result</code>는 타임아웃이 대기한 시간과 함께 <code>Err</code>가 될 것입니다.</li>
</ul>
<p>목록 17-28은 이러한 선언을 보여줍니다.</p>
<!-- This is not tested because it intentionally does not compile. -->
<Listing number="17-28" caption="Defining the signature of `timeout`" file-name="src/main.rs">
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::{future::Future, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let slow = async {
</span><span class="boring">            trpl::sleep(Duration::from_secs(5)).await;
</span><span class="boring">            "마침내 완료됨"
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        match timeout(slow, Duration::from_millis(10)).await {
</span><span class="boring">            Ok(message) =&gt; println!("' {message}'로 성공했습니다"),
</span><span class="boring">            Err(duration) =&gt; {
</span><span class="boring">                println!({}초 후 실패했습니다, duration.as_secs())
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span>async fn timeout&lt;F: Future&gt;(
    future_to_try: F,
    max_time: Duration,
) -&gt; Result&lt;F::Output, Duration&gt; {
    // 여기에 우리의 구현이 들어갈 것입니다!
}</code></pre>
</Listing>
<p>이것으로 타입에 대한 우리의 목표를 달성했습니다. 이제 우리가 필요한 _동작_에 대해 생각해 봅시다: 우리는 전달된 퓨처를 지정된 시간과 경쟁시키고 싶습니다. <code>trpl::sleep</code>을 사용하여 해당 시간으로부터 타이머 퓨처를 만들고, <code>trpl::race</code>를 사용하여 호출자가 전달한 퓨처와 그 타이머를 함께 실행할 수 있습니다.</p>
<p>우리는 또한 <code>race</code>가 공정하지 않으며, 인수가 전달된 순서대로 폴링한다는 것을 알고 있습니다. 따라서 <code>max_time</code>이 매우 짧은 시간이라 하더라도 완료될 기회를 가질 수 있도록 <code>future_to_try</code>를 <code>race</code>에 먼저 전달합니다. 만약 <code>future_to_try</code>가 먼저 끝나면, <code>race</code>는 <code>future_to_try</code>의 출력과 함께 <code>Left</code>를 반환할 것입니다. 만약 <code>timer</code>가 먼저 끝나면, <code>race</code>는 타이머의 출력인 <code>()</code>와 함께 <code>Right</code>를 반환할 것입니다.</p>
<p>목록 17-29에서 우리는 <code>trpl::race</code>를 기다린(await) 결과에 대해 매칭을 수행합니다.</p>
<Listing number="17-29" caption="Defining `timeout` with `race` and `sleep`" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::{future::Future, time::Duration};
</span><span class="boring">
</span>use trpl::Either;

// --생략--

fn main() {
    trpl::run(async {
        let slow = async {
            trpl::sleep(Duration::from_secs(5)).await;
            "마침내 완료됨"
        };

        match timeout(slow, Duration::from_secs(2)).await {
            Ok(message) =&gt; println!("' {message}'로 성공했습니다"),
            Err(duration) =&gt; {
                println!({}초 후 실패했습니다, duration.as_secs())
            }
        }
    });
}

async fn timeout&lt;F: Future&gt;(
    future_to_try: F,
    max_time: Duration,
) -&gt; Result&lt;F::Output, Duration&gt; {
    match trpl::race(future_to_try, trpl::sleep(max_time)).await {
        Either::Left(output) =&gt; Ok(output),
        Either::Right(_) =&gt; Err(max_time),
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>만약 <code>future_to_try</code>가 성공하여 <code>Left(output)</code>을 얻으면, <code>Ok(output)</code>을 반환합니다. 대신 슬립 타이머가 경과하여 <code>Right(())</code>를 얻으면, <code>_</code>로 <code>()</code>를 무시하고 대신 <code>Err(max_time)</code>을 반환합니다.</p>
<p>이로써 우리는 다른 두 비동기 헬퍼로 구축된 작동하는 <code>timeout</code>을 갖게 되었습니다. 코드를 실행하면 타임아웃 후에 실패 모드가 출력될 것입니다.</p>
<pre><code class="language-text">Failed after 2 seconds
</code></pre>
<p>퓨처는 다른 퓨처들과 결합될 수 있기 때문에, 더 작은 비동기 구성 요소를 사용하여 매우 강력한 도구를 구축할 수 있습니다. 예를 들어, 동일한 접근 방식을 사용하여 타임아웃과 재시도(retries)를 결합할 수 있으며, 이를 다시 네트워크 호출과 같은 작업(이 장의 시작 부분에 나온 예제 중 하나)에 사용할 수 있습니다.</p>
<p>실제로 여러분은 대개 <code>async</code>와 <code>await</code>를 직접 사용하고, 보조적으로 <code>join</code>, <code>join_all</code>, <code>race</code> 등과 같은 함수 및 매크로를 사용하게 될 것입니다. 이러한 API들과 함께 퓨처를 사용하기 위해 이따금씩 <code>pin</code>이 필요할 뿐입니다.</p>
<p>우리는 지금까지 동시에 여러 퓨처로 작업하는 여러 가지 방법을 보았습니다. 다음으로, 우리는 _스트림(streams)_을 통해 시간이 지남에 따라 순차적으로 여러 퓨처로 작업하는 방법을 살펴볼 것입니다. 하지만 그 전에 먼저 고려해 볼 만한 몇 가지 사항이 더 있습니다.</p>
<ul>
<li>
<p>우리는 어떤 그룹의 모든 퓨처가 완료되기를 기다리기 위해 <code>join_all</code>과 함께 <code>Vec</code>을 사용했습니다. 대신 일련의 퓨처들을 순차적으로 처리하기 위해 <code>Vec</code>을 어떻게 사용할 수 있을까요? 그렇게 할 때의 트레이드오프는 무엇일까요?</p>
</li>
<li>
<p><code>futures</code> 크레이트의 <code>futures::stream::FuturesUnordered</code> 타입을 살펴보세요. 이를 사용하는 것이 <code>Vec</code>을 사용하는 것과 어떻게 다를까요? (그것이 크레이트의 <code>stream</code> 부분에 있다는 사실에 대해서는 걱정하지 마세요. 그것은 어떤 퓨처 컬렉션과도 잘 작동합니다.)</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="스트림-순차적인-future"><a class="header" href="#스트림-순차적인-future">스트림: 순차적인 Future</a></h2>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="streams"></a></p>
<p>이 장에서 지금까지 우리는 주로 개별 퓨처에 집중해 왔습니다. 유일하게 큰 예외는 우리가 사용했던 비동기 채널이었습니다. 이 장 앞부분의 <a href="ch17-02-concurrency-with-async.html#message-passing">“메시지 전달”</a><!-- ignore --> 섹션에서 비동기 채널의 수신자를 어떻게 사용했는지 떠올려 보세요. 비동기 <code>recv</code> 메서드는 시간이 지남에 따라 일련의 항목들을 생성합니다. 이것은 _스트림(stream)_이라고 알려진 훨씬 더 일반적인 패턴의 한 사례입니다.</p>
<p>우리는 13장 <a href="ch13-02-iterators.html#the-iterator-trait-and-the-next-method">반복자 트레이트와 <code>next</code> 메서드</a><!-- ignore
--> 섹션에서 <code>Iterator</code> 트레이트를 살펴볼 때 일련의 항목들을 보았지만, 반복자와 비동기 채널 수신자 사이에는 두 가지 차이점이 있습니다. 첫 번째 차이점은 시간입니다. 반복자는 동기식인 반면, 채널 수신자는 비동기식입니다. 두 번째는 API입니다. <code>Iterator</code>와 직접 작업할 때는 그것의 동기 <code>next</code> 메서드를 호출합니다. 특히 <code>trpl::Receiver</code> 스트림의 경우, 대신 비동기 <code>recv</code> 메서드를 호출했습니다. 그 외에 이 API들은 매우 비슷하게 느껴지는데, 그 유사성은 우연이 아닙니다. 스트림은 반복의 비동기 형태와 같습니다. 하지만 <code>trpl::Receiver</code>가 구체적으로 메시지를 받기를 기다리는 것과 달리, 범용 스트림 API는 훨씬 더 광범위합니다. 그것은 <code>Iterator</code>가 하는 것과 같은 방식으로 다음 항목을 제공하지만, 비동기식으로 제공합니다.</p>
<p>러스트에서 반복자와 스트림 사이의 유사성은 우리가 실제로 어떤 반복자로부터든 스트림을 생성할 수 있음을 의미합니다. 반복자와 마찬가지로, 목록 17-30에서처럼 스트림의 <code>next</code> 메서드를 호출하고 그 출력을 기다림으로써(awaiting) 스트림과 작업할 수 있습니다.</p>
<Listing number="17-30" caption="Creating a stream from an iterator and printing its values" file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        let iter = values.iter().map(|n| n * 2);
        let mut stream = trpl::stream_from_iter(iter);

        while let Some(value) = stream.next().await {
            println!("값은 {value}였습니다.");
        }
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
</Listing>
<p>숫자 배열로 시작하여 이를 반복자로 변환한 다음, <code>map</code>을 호출하여 모든 값을 두 배로 만듭니다. 그런 다음 <code>trpl::stream_from_iter</code> 함수를 사용하여 반복자를 스트림으로 변환합니다. 다음으로, 스트림의 항목들이 도착할 때마다 <code>while let</code> 루프로 반복합니다.</p>
<p>불행히도 코드를 실행하려고 하면 컴파일되지 않고, 대신 사용할 수 있는 <code>next</code> 메서드가 없다는 보고를 합니다.</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-30
cargo build
copy only the error output
-->
<pre><code class="language-console">error[E0599]: no method named `next` found for struct `Iter` in the current scope
  --&gt; src/main.rs:10:40
   |
10 |         while let Some(value) = stream.next().await {
   |                                        ^^^^
   |
   = note: the full type name has been written to 'file:///projects/async_await/target/debug/deps/async_await-9de943556a6001b8.long-type-1281356139287206597.txt'
   = note: 전체 타입 이름을 콘솔에 출력하려면 `--verbose`를 사용하는 것을 고려해 보세요
   = help: 트레이트의 항목들은 트레이트가 스코프에 있을 때만 사용될 수 있습니다
help: `next`를 제공하는 다음 트레이트들이 구현되어 있지만 스코프에 없습니다. 아마도 그 중 하나를 임포트하고 싶을 것입니다
   |
1  + use crate::trpl::StreamExt;
   |
1  + use futures_util::stream::stream::StreamExt;
   |
1  + use std::iter::Iterator;
   |
1  + use std::str::pattern::Searcher;
   |
help: 비슷한 이름의 `try_next` 메서드가 있습니다
   |
10 |         while let Some(value) = stream.try_next().await {
   |                                        ~~~~~~~~
</code></pre>
<p>이 출력 결과가 설명하듯이, 컴파일러 에러의 이유는 <code>next</code> 메서드를 사용하기 위해 올바른 트레이트가 스코프에 필요하기 때문입니다. 지금까지의 논의를 고려할 때, 여러분은 그 트레이트가 <code>Stream</code>일 것이라고 합리적으로 예상할 수도 있겠지만, 실제로는 <code>StreamExt</code>입니다. <em>extension</em>(확장)의 약자인 <code>Ext</code>는 한 트레이트를 다른 트레이트로 확장하기 위해 러스트 커뮤니티에서 흔히 사용하는 패턴입니다.</p>
<p>장 마지막 부분에서 <code>Stream</code>과 <code>StreamExt</code> 트레이트에 대해 좀 더 자세히 설명하겠지만, 지금 당장 알아야 할 것은 <code>Stream</code> 트레이트가 <code>Iterator</code>와 <code>Future</code> 트레이트를 효과적으로 결합한 저수준 인터페이스를 정의한다는 것입니다. <code>StreamExt</code>는 <code>next</code> 메서드뿐만 아니라 <code>Iterator</code> 트레이트에서 제공하는 것과 유사한 다른 유틸리티 메서드들을 포함하여, <code>Stream</code> 위에 고수준 API 세트를 제공합니다. <code>Stream</code>과 <code>StreamExt</code>는 아직 러스트 표준 라이브러리의 일부는 아니지만, 대부분의 생태계 크레이트들은 동일한 정의를 사용합니다.</p>
<p>컴파일러 에러의 해결책은 목록 17-31과 같이 <code>trpl::StreamExt</code>에 대한 <code>use</code> 문을 추가하는 것입니다.</p>
<Listing number="17-31" caption="Successfully using an iterator as the basis for a stream" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span>use trpl::StreamExt;

fn main() {
    trpl::run(async {
        let values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        let iter = values.iter().map(|n| n * 2);
        let mut stream = trpl::stream_from_iter(iter);

        while let Some(value) = stream.next().await {
            println!("값은 {value}였습니다.");
        }
    });
}</code></pre></pre>
</Listing>
<p>이 모든 조각들을 하나로 합치면, 이 코드는 우리가 원하는 방식으로 작동합니다! 게다가 이제 <code>StreamExt</code>가 스코프에 있으므로, 반복자와 마찬가지로 모든 유틸리티 메서드를 사용할 수 있습니다. 예를 들어, 목록 17-32에서는 <code>filter</code> 메서드를 사용하여 3과 5의 배수를 제외한 모든 것을 걸러냅니다.</p>
<Listing number="17-32" caption="Filtering a stream with the `StreamExt::filter` method" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span>use trpl::StreamExt;

fn main() {
    trpl::run(async {
        let values = 1..101;
        let iter = values.map(|n| n * 2);
        let stream = trpl::stream_from_iter(iter);

        let mut filtered =
            stream.filter(|value| value % 3 == 0 || value % 5 == 0);

        while let Some(value) = filtered.next().await {
            println!("값은 {value}였습니다.");
        }
    });
}</code></pre></pre>
</Listing>
<p>물론 이것은 일반 반복자로도 비동기 없이 똑같이 할 수 있기 때문에 그다지 흥미롭지 않습니다. 이제 스트림만이 할 수 있는 <em>고유한</em> 작업들을 살펴봅시다.</p>
<h3 id="스트림-조합하기"><a class="header" href="#스트림-조합하기">스트림 조합하기</a></h3>
<p>많은 개념들이 자연스럽게 스트림으로 표현됩니다: 큐에서 사용 가능해지는 항목들, 전체 데이터 세트가 컴퓨터 메모리에 비해 너무 클 때 파일 시스템에서 점진적으로 가져오는 데이터 청크들, 혹은 시간이 지나면서 네트워크를 통해 도착하는 데이터들이 그 예입니다. 스트림은 퓨처이기 때문에, 우리는 그것들을 다른 종류의 퓨처와 함께 사용하고 흥미로운 방식으로 결합할 수 있습니다. 예를 들어, 너무 많은 네트워크 호출을 유발하지 않도록 이벤트를 일괄 처리(batch up)하거나, 오래 걸리는 일련의 작업에 타임아웃을 설정하거나, 불필요한 작업을 피하기 위해 사용자 인터페이스 이벤트를 조절(throttle)할 수 있습니다.</p>
<p>목록 17-33과 같이 WebSocket이나 다른 실시간 통신 프로토콜에서 볼 수 있는 데이터 스트림을 대신할 작은 메시지 스트림을 만드는 것부터 시작해 봅시다.</p>
<Listing number="17-33" caption="Using the `rx` receiver as a `ReceiverStream`" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span>use trpl::{ReceiverStream, Stream, StreamExt};

fn main() {
    trpl::run(async {
        let mut messages = get_messages();

        while let Some(message) = messages.next().await {
            println!("{message}");
        }
    });
}

fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
    let (tx, rx) = trpl::channel();

    let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
    for message in messages {
        tx.send(format!("메시지: '{message}'")).unwrap();
    }

    ReceiverStream::new(rx)
}</code></pre></pre>
</Listing>
<p>먼저, <code>impl Stream&lt;Item = String&gt;</code>을 반환하는 <code>get_messages</code>라는 함수를 만듭니다. 구현을 위해 비동기 채널을 생성하고, 영어 알파벳의 처음 10글자를 루프로 돌며 채널을 통해 보냅니다.</p>
<p>또한 <code>trpl::channel</code>의 <code>rx</code> 수신자를 <code>next</code> 메서드가 있는 <code>Stream</code>으로 변환하는 새로운 타입인 <code>ReceiverStream</code>을 사용합니다. 다시 <code>main</code>에서 <code>while let</code> 루프를 사용하여 스트림의 모든 메시지를 출력합니다.</p>
<p>이 코드를 실행하면, 정확히 우리가 예상한 결과를 얻게 됩니다:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Message: 'a'
Message: 'b'
Message: 'c'
Message: 'd'
Message: 'e'
Message: 'f'
Message: 'g'
Message: 'h'
Message: 'i'
Message: 'j'
</code></pre>
<p>하지만 이것 역시 일반 <code>Receiver</code> API나 심지어 일반 <code>Iterator</code> API로도 가능하므로, 스트림이 필요한 기능을 추가해 봅시다. 목록 17-34와 같이 스트림의 모든 항목에 적용되는 타임아웃과 우리가 내보내는 항목들에 대한 지연을 추가해 보겠습니다.</p>
<Listing number="17-34" caption="Using the `StreamExt::timeout` method to set a time limit on the items in a stream" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span>use std::{pin::pin, time::Duration};
use trpl::{ReceiverStream, Stream, StreamExt};

fn main() {
    trpl::run(async {
        let mut messages =
            pin!(get_messages().timeout(Duration::from_millis(200)));

        while let Some(result) = messages.next().await {
            match result {
                Ok(message) =&gt; println!("{message}"),
                Err(reason) =&gt; eprintln!("문제: {reason:?}"),
            }
        }
    })
}
<span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">    for message in messages {
</span><span class="boring">        tx.send(format!("메시지: '{message}'")).unwrap();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>먼저 <code>StreamExt</code> 트레이트에서 제공하는 <code>timeout</code> 메서드를 사용하여 스트림에 타임아웃을 추가하는 것으로 시작합니다. 그런 다음 스트림이 이제 <code>Result</code>를 반환하므로 <code>while let</code> 루프의 본문을 업데이트합니다. <code>Ok</code> 변형은 메시지가 제시간에 도착했음을 나타내고, <code>Err</code> 변형은 메시지가 도착하기 전에 타임아웃이 지났음을 나타냅니다. 우리는 그 결과에 대해 <code>match</code>를 수행하여 메시지를 성공적으로 받았을 때는 메시지를 출력하고, 타임아웃이 발생했을 때는 그에 대한 알림을 출력합니다. 마지막으로, 타임아웃 헬퍼가 폴링(poll)되기 위해 피닝(pin)되어야 하는 스트림을 생성하므로, 메시지에 타임아웃을 적용한 후에 메시지를 피닝한다는 점에 유의하세요.</p>
<p>하지만 메시지 사이에 지연이 없기 때문에, 이 타임아웃은 프로그램의 동작을 변경하지 않습니다. 목록 17-35에 표시된 것처럼 우리가 보내는 메시지에 가변적인 지연을 추가해 봅시다.</p>
<Listing number="17-35" caption="Sending messages through `tx` with an async delay without making `get_messages` an async function" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let mut messages =
</span><span class="boring">            pin!(get_messages().timeout(Duration::from_millis(200)));
</span><span class="boring">
</span><span class="boring">        while let Some(result) = messages.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("문제: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span>fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
    let (tx, rx) = trpl::channel();

    trpl::spawn_task(async move {
        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
        for (index, message) in messages.into_iter().enumerate() {
            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
            trpl::sleep(Duration::from_millis(time_to_sleep)).await;

            tx.send(format!("메시지: '{message}'")).unwrap();
        }
    });

    ReceiverStream::new(rx)
}</code></pre></pre>
</Listing>
<p><code>get_messages</code>에서 우리는 <code>messages</code> 배열과 함께 <code>enumerate</code> 반복자 메서드를 사용하여 우리가 보내는 각 항목의 인덱스를 항목 자체와 함께 가져올 수 있습니다. 그런 다음 짝수 인덱스 항목에는 100밀리초 지연을 적용하고 홀수 인덱스 항목에는 300밀리초 지연을 적용하여 실제 상황의 메시지 스트림에서 볼 수 있는 다양한 지연을 시뮬레이션합니다. 타임아웃이 200밀리초이므로, 이는 메시지의 절반에 영향을 미칠 것입니다.</p>
<p><code>get_messages</code> 함수에서 블로킹 없이 메시지 사이에 잠을 자려면 비동기를 사용해야 합니다. 하지만 <code>get_messages</code> 자체를 비동기 함수로 만들 수는 없습니다. 그렇게 하면 <code>Stream&lt;Item = String&gt;</code> 대신 <code>Future&lt;Output = Stream&lt;Item = String&gt;&gt;</code>을 반환하게 되기 때문입니다. 호출자는 스트림에 접근하기 위해 <code>get_messages</code> 자체를 기다려야(await) 할 것입니다. 하지만 기억하세요: 주어진 퓨처 내의 모든 것은 선형적으로 발생하며, 동시성은 퓨처 _사이_에서 발생합니다. <code>get_messages</code>를 기다리는 것은 수신자 스트림을 반환하기 전에 각 메시지 사이의 수면 지연을 포함하여 모든 메시지를 보내도록 요구할 것입니다. 결과적으로 타임아웃은 쓸모가 없게 됩니다. 스트림 자체에는 지연이 없을 것이며, 모든 지연은 스트림이 사용 가능해지기도 전에 발생할 것입니다.</p>
<p>대신 우리는 <code>get_messages</code>를 스트림을 반환하는 일반 함수로 남겨두고, 비동기 <code>sleep</code> 호출을 처리하기 위해 태스크를 생성(spawn)합니다.</p>
<blockquote>
<p>참고: 이런 방식으로 <code>spawn_task</code>를 호출하는 것은 우리가 이미 런타임을 설정했기 때문에 작동합니다. 그렇지 않았다면 패닉이 발생했을 것입니다. 다른 구현들은 다른 트레이드오프를 선택합니다: 새로운 런타임을 생성하여 패닉을 피하지만 약간의 추가 오버헤드가 발생할 수 있고, 또는 런타임에 대한 참조 없이 태스크를 생성하는 독립적인 방법을 단순히 제공하지 않을 수도 있습니다. 여러분의 런타임이 어떤 트레이드오프를 선택했는지 확인하고 그에 따라 코드를 작성하세요!</p>
</blockquote>
<p>이제 우리 코드는 훨씬 더 흥미로운 결과를 보여줍니다. 매 두 메시지 쌍 사이에 <code>Problem: Elapsed(())</code> 에러가 발생합니다.</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-35
cargo run
copy only the program output, *not* the compiler output
-->
<pre><code class="language-text">Message: 'a'
Problem: Elapsed(())
Message: 'b'
Message: 'c'
Problem: Elapsed(())
Message: 'd'
Message: 'e'
Problem: Elapsed(())
Message: 'f'
Message: 'g'
Problem: Elapsed(())
Message: 'h'
Message: 'i'
Problem: Elapsed(())
Message: 'j'
</code></pre>
<p>타임아웃이 발생했다고 해서 메시지가 결국 도착하는 것을 막지는 못합니다. 우리 채널은 <em>제한이 없기(unbounded)</em> 때문에 메모리가 허용하는 한 많은 메시지를 보유할 수 있으며, 원래의 모든 메시지를 여전히 받게 됩니다. 메시지가 타임아웃 전에 도착하지 않으면 스트림 핸들러가 이를 처리하겠지만, 스트림을 다시 폴링할 때 메시지가 이미 도착해 있을 수 있습니다.</p>
<p>필요하다면 다른 종류의 채널이나 더 일반적으로 다른 종류의 스트림을 사용하여 다른 동작을 얻을 수 있습니다. 시간 간격 스트림을 이 메시지 스트림과 결합하여 그 중 하나를 실제로 살펴봅시다.</p>
<h3 id="스트림-병합하기"><a class="header" href="#스트림-병합하기">스트림 병합하기</a></h3>
<p>먼저, 직접 실행하면 매 밀리초마다 항목을 내보내는 또 다른 스트림을 만들어 봅시다. 단순함을 위해 <code>sleep</code> 함수를 사용하여 지연된 메시지를 보내고, <code>get_messages</code>에서 사용했던 채널로부터 스트림을 생성하는 것과 동일한 방식을 결합할 수 있습니다. 차이점은 이번에는 경과된 간격의 횟수를 보낼 것이므로 반환 타입이 <code>impl Stream&lt;Item = u32&gt;</code>가 되며, 함수 이름을 <code>get_intervals</code>라고 부를 수 있다는 점입니다(목록 17-36 참조).</p>
<Listing number="17-36" caption="Creating a stream with a counter that will be emitted once every millisecond" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let mut messages =
</span><span class="boring">            pin!(get_messages().timeout(Duration::from_millis(200)));
</span><span class="boring">
</span><span class="boring">        while let Some(result) = messages.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("문제: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">        for (index, message) in messages.into_iter().enumerate() {
</span><span class="boring">            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
</span><span class="boring">            trpl::sleep(Duration::from_millis(time_to_sleep)).await;
</span><span class="boring">
</span><span class="boring">            tx.send(format!("메시지: '{message}'")).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}
</span><span class="boring">
</span>fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
    let (tx, rx) = trpl::channel();

    trpl::spawn_task(async move {
        let mut count = 0;
        loop {
            trpl::sleep(Duration::from_millis(1)).await;
            count += 1;
            tx.send(count).unwrap();
        }
    });

    ReceiverStream::new(rx)
}</code></pre></pre>
</Listing>
<p>태스크 내에 <code>count</code>를 정의하는 것으로 시작합니다. (태스크 외부에서 정의할 수도 있지만, 주어진 변수의 스코프를 제한하는 것이 더 명확합니다.) 그런 다음 무한 루프를 생성합니다. 루프의 각 반복은 비동기적으로 1밀리초 동안 잠을 자고, 카운트를 증가시킨 다음, 채널을 통해 보냅니다. 이 모든 것이 <code>spawn_task</code>에 의해 생성된 태스크 내에 래핑되어 있으므로, 무한 루프를 포함한 모든 것이 런타임과 함께 정리될 것입니다.</p>
<p>런타임 전체가 종료될 때만 끝나는 이런 종류의 무한 루프는 비동기 러스트에서 꽤 흔합니다. 많은 프로그램들이 무기한으로 계속 실행될 필요가 있기 때문입니다. 비동기를 사용하면 루프의 각 반복마다 최소한 하나의 await 지점이 있는 한, 이것이 다른 어떤 것도 차단하지 않습니다.</p>
<p>이제 다시 메인 함수의 비동기 블록으로 돌아와서, 목록 17-37과 같이 <code>messages</code>와 <code>intervals</code> 스트림 병합을 시도해 볼 수 있습니다.</p>
<Listing number="17-37" caption="Attempting to merge the `messages` and `intervals` streams" file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let messages = get_messages().timeout(Duration::from_millis(200));
        let intervals = get_intervals();
        let merged = messages.merge(intervals);
<span class="boring">
</span><span class="boring">        while let Some(result) = merged.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("문제: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">        for (index, message) in messages.into_iter().enumerate() {
</span><span class="boring">            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
</span><span class="boring">            trpl::sleep(Duration::from_millis(time_to_sleep)).await;
</span><span class="boring">
</span><span class="boring">            tx.send(format!("메시지: '{message}'")).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let mut count = 0;
</span><span class="boring">        loop {
</span><span class="boring">            trpl::sleep(Duration::from_millis(1)).await;
</span><span class="boring">            count += 1;
</span><span class="boring">            tx.send(count).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}</span></code></pre>
</Listing>
<p>먼저 <code>get_intervals</code>를 호출하는 것으로 시작합니다. 그런 다음 <code>merge</code> 메서드를 사용하여 <code>messages</code>와 <code>intervals</code> 스트림을 병합합니다. 이 메서드는 여러 스트림을 하나의 스트림으로 결합하며, 소스 스트림 중 어느 하나에서든 항목이 사용 가능해지는 즉시 특정 순서 없이 항목을 생성합니다. 마지막으로, <code>messages</code> 대신 결합된 스트림에 대해 루프를 돕니다.</p>
<p>이 시점에서 <code>messages</code>나 <code>intervals</code> 모두 피닝되거나 가변적일 필요가 없습니다. 둘 다 단일 <code>merged</code> 스트림으로 결합될 것이기 때문입니다. 하지만 이 <code>merge</code> 호출은 컴파일되지 않습니다! (<code>while let</code> 루프의 <code>next</code> 호출도 마찬가지지만, 나중에 다시 다루겠습니다.) 이는 두 스트림의 타입이 다르기 때문입니다. <code>messages</code> 스트림은 <code>Timeout&lt;impl Stream&lt;Item = String&gt;&gt;</code> 타입을 갖는데, 여기서 <code>Timeout</code>은 <code>timeout</code> 호출에 대해 <code>Stream</code>을 구현하는 타입입니다. <code>intervals</code> 스트림은 <code>impl Stream&lt;Item = u32&gt;</code> 타입을 갖습니다. 이 두 스트림을 병합하려면 하나를 다른 하나와 일치하도록 변환해야 합니다. <code>messages</code>는 이미 우리가 원하는 기본 형식이고 타임아웃 에러를 처리해야 하므로, <code>intervals</code> 스트림을 재작업하겠습니다(목록 17-38 참조).</p>
<!-- We cannot directly test this one, because it never stops. -->
<Listing number="17-38" caption="Aligning the type of the the `intervals` stream with the type of the `messages` stream" file-name="src/main.rs">
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let messages = get_messages().timeout(Duration::from_millis(200));
        let intervals = get_intervals()
            .map(|count| format!("간격: {count}"))
            .timeout(Duration::from_secs(10));
        let merged = messages.merge(intervals);
        let mut stream = pin!(merged);
<span class="boring">
</span><span class="boring">        while let Some(result) = stream.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("문제: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">        for (index, message) in messages.into_iter().enumerate() {
</span><span class="boring">            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
</span><span class="boring">            trpl::sleep(Duration::from_millis(time_to_sleep)).await;
</span><span class="boring">
</span><span class="boring">            tx.send(format!("메시지: '{message}'")).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let mut count = 0;
</span><span class="boring">        loop {
</span><span class="boring">            trpl::sleep(Duration::from_millis(1)).await;
</span><span class="boring">            count += 1;
</span><span class="boring">            tx.send(count).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}</span></code></pre>
</Listing>
<p>첫째, <code>map</code> 헬퍼 메서드를 사용하여 <code>intervals</code>를 문자열로 변환할 수 있습니다. 둘째, <code>messages</code>의 <code>Timeout</code>과 일치시켜야 합니다. 하지만 <code>intervals</code>에 대해서는 실제로 타임아웃을 <em>원하지</em> 않으므로, 우리가 사용하고 있는 다른 기간보다 긴 타임아웃을 만들면 됩니다. 여기서는 <code>Duration::from_secs(10)</code>으로 10초 타임아웃을 만듭니다. 마지막으로, <code>while let</code> 루프의 <code>next</code> 호출이 스트림을 반복할 수 있도록 <code>stream</code>을 가변으로 만들고, 안전하게 반복할 수 있도록 피닝해야 합니다. 이제 우리가 원하는 목표에 <em>거의</em> 도달했습니다. 모든 타입 체크가 통과됩니다. 하지만 이를 실행하면 두 가지 문제가 발생합니다. 첫째, 절대로 멈추지 않습니다! <span class="keystroke">ctrl-c</span>로 강제 종료해야 할 것입니다. 둘째, 영어 알파벳 메시지들이 수많은 간격 카운터 메시지들 사이에 묻혀버릴 것입니다:첫째, <code>map</code> 헬퍼 메서드를 사용하여 <code>intervals</code>를 문자열로 변환할 수 있습니다. 둘째, <code>messages</code>의 <code>Timeout</code>과 일치시켜야 합니다. 하지만 <code>intervals</code>에 대해서는 실제로 타임아웃을 <em>원하지</em> 않으므로, 우리가 사용하고 있는 다른 기간보다 긴 타임아웃을 만들면 됩니다. 여기서는 <code>Duration::from_secs(10)</code>으로 10초 타임아웃을 만듭니다. 마지막으로, <code>while let</code> 루프의 <code>next</code> 호출이 스트림을 반복할 수 있도록 <code>stream</code>을 가변으로 만들고, 안전하게 반복할 수 있도록 피닝해야 합니다. 이제 우리가 원하는 목표에 <em>거의</em> 도달했습니다. 모든 타입 체크가 통과됩니다. 하지만 이를 실행하면 두 가지 문제가 발생합니다. 첫째, 절대로 멈추지 않습니다! <span class="keystroke">ctrl-c</span>로 강제 종료해야 할 것입니다. 둘째, 영어 알파벳 메시지들이 수많은 간격 카운터 메시지들 사이에 묻혀버릴 것입니다:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the tasks running differently rather than
changes in the compiler -->
<pre><code class="language-text">--snip--
Interval: 38
Interval: 39
Interval: 40
Message: 'a'
Interval: 41
Interval: 42
Interval: 43
--snip--
</code></pre>
<p>목록 17-39는 이 마지막 두 가지 문제를 해결하는 한 가지 방법을 보여줍니다.</p>
<Listing number="17-39" caption="Using `throttle` and `take` to manage the merged streams" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let messages = get_messages().timeout(Duration::from_millis(200));
        let intervals = get_intervals()
            .map(|count| format!("간격: {count}"))
            .throttle(Duration::from_millis(100))
            .timeout(Duration::from_secs(10));
        let merged = messages.merge(intervals).take(20);
        let mut stream = pin!(merged);
<span class="boring">
</span><span class="boring">        while let Some(result) = stream.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("문제: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">        for (index, message) in messages.into_iter().enumerate() {
</span><span class="boring">            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
</span><span class="boring">            trpl::sleep(Duration::from_millis(time_to_sleep)).await;
</span><span class="boring">
</span><span class="boring">            tx.send(format!("메시지: '{message}'")).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let mut count = 0;
</span><span class="boring">        loop {
</span><span class="boring">            trpl::sleep(Duration::from_millis(1)).await;
</span><span class="boring">            count += 1;
</span><span class="boring">            tx.send(count).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>첫째, <code>intervals</code> 스트림이 <code>messages</code> 스트림을 압도하지 않도록 <code>throttle</code> 메서드를 사용합니다. _스로틀링(Throttling)_은 함수가 호출되는 속도, 또는 이 경우에는 스트림이 폴링되는 빈도를 제한하는 방법입니다. 메시지가 도착하는 빈도와 대략 일치하는 100밀리초에 한 번 정도면 충분할 것입니다.</p>
<p>스트림에서 받아들일 항목의 수를 제한하기 위해, 우리는 <code>merged</code> 스트림에 <code>take</code> 메서드를 적용합니다. 어느 한쪽 스트림이 아니라 최종 출력을 제한하고 싶기 때문입니다.</p>
<p>이제 프로그램을 실행하면 스트림에서 20개의 항목을 가져온 후 중단되며, 간격 메시지가 일반 메시지를 압도하지 않습니다. 또한 매 밀리초마다 이벤트를 생성할 <em>수 있는</em> 소스 스트림이 있음에도 불구하고 <code>Interval: 100</code>이나 <code>Interval: 200</code> 등이 아닌 <code>Interval: 1</code>, <code>Interval: 2</code> 등을 받게 됩니다. 그 이유는 <code>throttle</code> 호출이 원래 스트림을 감싸는 새로운 스트림을 생성하여, 원래 스트림이 고유의 "네이티브" 속도가 아닌 스로틀 속도로만 폴링되도록 하기 때문입니다. 우리가 무시하기로 선택한 수많은 처리되지 않은 간격 메시지들이 쌓여 있는 것이 아닙니다. 대신, 우리는 애초에 그 간격 메시지들을 생성하지 않는 것입니다! 이는 우리가 성능 특성을 선택할 수 있게 해주는 러스트 퓨처 고유의 "게으름(laziness)"이 다시 한번 작용한 결과입니다.</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-39
cargo run
copy and paste only the program output
-->
<pre><code class="language-text">Interval: 1
Message: 'a'
Interval: 2
Interval: 3
Problem: Elapsed(())
Interval: 4
Message: 'b'
Interval: 5
Message: 'c'
Interval: 6
Interval: 7
Problem: Elapsed(())
Interval: 8
Message: 'd'
Interval: 9
Message: 'e'
Interval: 10
Interval: 11
Problem: Elapsed(())
Interval: 12
</code></pre>
<p>마지막으로 처리해야 할 것이 하나 더 있습니다: 바로 에러입니다! 이 두 가지 채널 기반 스트림 모두, 채널의 반대편이 닫힐 때 <code>send</code> 호출이 실패할 수 있습니다. 이는 런타임이 스트림을 구성하는 퓨처들을 어떻게 실행하느냐에 달린 문제입니다. 지금까지 우리는 <code>unwrap</code>을 호출하여 이 가능성을 무시해 왔지만, 잘 만들어진 앱이라면 에러를 명시적으로 처리해야 합니다. 최소한 더 이상 메시지를 보내지 않도록 루프를 종료해야 하죠. 목록 17-40은 문제를 출력하고 루프를 빠져나오는(break) 간단한 에러 전략을 보여줍니다.</p>
<Listing number="17-40" caption="Handling errors and shutting down the loops">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let messages = get_messages().timeout(Duration::from_millis(200));
</span><span class="boring">        let intervals = get_intervals()
</span><span class="boring">            .map(|count| format!("간격 #{count}"))
</span><span class="boring">            .throttle(Duration::from_millis(500))
</span><span class="boring">            .timeout(Duration::from_secs(10));
</span><span class="boring">        let merged = messages.merge(intervals).take(20);
</span><span class="boring">        let mut stream = pin!(merged);
</span><span class="boring">
</span><span class="boring">        while let Some(result) = stream.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(item) =&gt; println!("{item}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("문제: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span>fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
    let (tx, rx) = trpl::channel();

    trpl::spawn_task(async move {
        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];

        for (index, message) in messages.into_iter().enumerate() {
            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
            trpl::sleep(Duration::from_millis(time_to_sleep)).await;

            if let Err(send_error) = tx.send(format!("메시지: '{message}'")) {
                eprintln!("메시지 '{message}'를 보낼 수 없습니다: {send_error}");
                break;
            }
        }
    });

    ReceiverStream::new(rx)
}

fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
    let (tx, rx) = trpl::channel();

    trpl::spawn_task(async move {
        let mut count = 0;
        loop {
            trpl::sleep(Duration::from_millis(1)).await;
            count += 1;

            if let Err(send_error) = tx.send(count) {
                eprintln!("간격 {count}를 보낼 수 없습니다: {send_error}");
                break;
            };
        }
    });

    ReceiverStream::new(rx)
}</code></pre></pre>
</Listing>
<p>늘 그렇듯이, 메시지 전송 에러를 처리하는 올바른 방법은 상황에 따라 다를 것입니다. 단지 여러분만의 전략을 가지고 있는지 확인하세요.</p>
<p>이제 실제로 많은 비동기 사례들을 보았으니, 한 걸음 물러나서 <code>Future</code>, <code>Stream</code>, 그리고 러스트가 비동기를 작동시키기 위해 사용하는 다른 핵심 트레이트들이 어떻게 작동하는지에 대한 몇 가지 세부 사항을 파헤쳐 봅시다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="async를-위한-트레이트-자세히-살펴보기"><a class="header" href="#async를-위한-트레이트-자세히-살펴보기">Async를 위한 트레이트 자세히 살펴보기</a></h2>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="digging-into-the-traits-for-async"></a></p>
<p>이 장 전체에서 우리는 <code>Future</code>, <code>Pin</code>, <code>Unpin</code>, <code>Stream</code>, 그리고 <code>StreamExt</code> 트레이트들을 다양한 방식으로 사용해 왔습니다. 하지만 지금까지는 그것들이 어떻게 작동하는지 또는 어떻게 서로 맞춰지는지에 대한 세부 사항에 너무 깊이 들어가는 것을 피해 왔는데, 이는 일상적인 러스트 작업에서는 대부분의 경우 괜찮습니다. 하지만 가끔은 이러한 세부 사항을 좀 더 이해해야 하는 상황에 맞닥뜨리게 될 것입니다. 이 섹션에서는 그러한 시나리오에서 도움이 될 만큼만 파헤쳐 볼 것이며, <em>정말</em> 깊은 탐구는 다른 문서를 위해 남겨두겠습니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="future"></a></p>
<h3 id="future-트레이트"><a class="header" href="#future-트레이트"><code>Future</code> 트레이트</a></h3>
<p>먼저 <code>Future</code> 트레이트가 어떻게 작동하는지 자세히 살펴보는 것으로 시작해 봅시다. 러스트에서는 이를 다음과 같이 정의합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::pin::Pin;
use std::task::{Context, Poll};

pub trait Future {
    type Output;

    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>그 트레이트 정의에는 수많은 새로운 타입들과 우리가 전에 본 적 없는 몇 가지 문법들이 포함되어 있으므로, 정의를 하나하나 살펴봅시다.</p>
<p>첫째, <code>Future</code>의 연관 타입인 <code>Output</code>은 퓨처가 완료되었을 때 어떤 타입으로 해소되는지를 나타냅니다. 이는 <code>Iterator</code> 트레이트의 <code>Item</code> 연관 타입과 유사합니다. 둘째, <code>Future</code>는 <code>poll</code> 메서드도 가지고 있는데, 이 메서드는 <code>self</code> 매개변수로 특별한 <code>Pin</code> 참조를 받고 <code>Context</code> 타입에 대한 가변 참조를 받으며, <code>Poll&lt;Self::Output&gt;</code>을 반환합니다. <code>Pin</code>과 <code>Context</code>에 대해서는 잠시 후에 더 자세히 이야기하겠습니다. 지금은 메서드가 반환하는 타입인 <code>Poll</code> 타입에 집중해 봅시다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Poll&lt;T&gt; {
    Ready(T),
    Pending,
}
<span class="boring">}</span></code></pre></pre>
<p>이 <code>Poll</code> 타입은 <code>Option</code>과 비슷합니다. 값을 가지는 <code>Ready(T)</code> 변형과 값을 가지지 않는 <code>Pending</code> 변형이 있습니다. 하지만 <code>Poll</code>은 <code>Option</code>과는 꽤 다른 의미를 가집니다! <code>Pending</code> 변형은 퓨처가 아직 할 일이 남았음을 나타내며, 따라서 호출자는 나중에 다시 확인해야 합니다. <code>Ready</code> 변형은 퓨처가 작업을 마쳤으며 <code>T</code> 값을 사용할 수 있음을 나타냅니다.</p>
<blockquote>
<p>참고: 대부분의 퓨처에서 호출자는 퓨처가 <code>Ready</code>를 반환한 후에 다시 <code>poll</code>을 호출해서는 안 됩니다. 많은 퓨처들이 준비된 상태가 된 후 다시 폴링되면 패닉을 일으킵니다. 다시 폴링해도 안전한 퓨처들은 문서에 명시적으로 그렇게 기재되어 있을 것입니다. 이는 <code>Iterator::next</code>가 동작하는 방식과 비슷합니다.</p>
</blockquote>
<p><code>await</code>를 사용하는 코드를 보면, 러스트는 내부적으로 이를 <code>poll</code>을 호출하는 코드로 컴파일합니다. 단일 URL이 해소되었을 때 페이지 제목을 출력했던 목록 17-4를 다시 보면, 러스트는 이를 (정확히는 아니지만) 대략 다음과 같은 것으로 컴파일합니다.</p>
<pre><code class="language-rust ignore">match page_title(url).poll() {
    Ready(page_title) =&gt; match page_title {
        Some(title) =&gt; println!("The title for {url} was {title}"),
        None =&gt; println!("{url} had no title"),
    }
    Pending =&gt; {
        // 하지만 여기에 무엇이 들어갈까요?
    }
}</code></pre>
<p>퓨처가 여전히 <code>Pending</code> 상태일 때 우리는 무엇을 해야 할까요? 퓨처가 마침내 준비될 때까지 계속해서 다시 시도할 방법이 필요합니다. 즉, 루프가 필요합니다.</p>
<pre><code class="language-rust ignore">let mut page_title_fut = page_title(url);
loop {
    match page_title_fut.poll() {
        Ready(value) =&gt; match page_title {
            Some(title) =&gt; println!("The title for {url} was {title}"),
            None =&gt; println!("{url} had no title"),
        }
        Pending =&gt; {
            // 계속 진행
        }
    }
}</code></pre>
<p>하지만 러스트가 정확히 저 코드로 컴파일한다면, 모든 <code>await</code>는 블로킹될 것입니다—우리가 목표로 했던 것과는 정반대죠! 대신 러스트는 루프가 이 퓨처에 대한 작업을 일시 중단하고 다른 퓨처를 작업한 뒤 나중에 다시 이 퓨처를 확인할 수 있는 무언가에 제어권을 넘겨줄 수 있도록 보장합니다. 우리가 보았듯이, 그 무언가가 바로 비동기 런타임이며, 이러한 스케줄링과 조정 작업이 런타임의 주요 임무 중 하나입니다.</p>
<p>이 장의 앞부분에서 우리는 <code>rx.recv</code>를 기다리는 것에 대해 설명했습니다. <code>recv</code> 호출은 퓨처를 반환하며, 퓨처를 기다리는 것은 그것을 폴링하는 것입니다. 우리는 런타임이 채널이 닫힐 때 <code>Some(message)</code> 또는 <code>None</code>으로 준비될 때까지 퓨처를 일시 중지할 것이라고 언급했습니다. <code>Future</code> 트레이트, 특히 <code>Future::poll</code>에 대한 더 깊은 이해를 통해 우리는 그것이 어떻게 작동하는지 볼 수 있습니다. 런타임은 <code>Poll::Pending</code>을 반환할 때 퓨처가 준비되지 않았음을 압니다. 반대로, <code>poll</code>이 <code>Poll::Ready(Some(message))</code> 또는 <code>Poll::Ready(None)</code>을 반환하면 런타임은 퓨처가 준비되었음을 알고 다음으로 진행합니다.</p>
<p>런타임이 이를 어떻게 수행하는지에 대한 정확한 세부 사항은 이 책의 범위를 벗어나지만, 핵심은 퓨처의 기본적인 메커니즘을 이해하는 것입니다. 런타임은 자신이 책임지는 각 퓨처를 _폴링(poll)_하며, 아직 준비되지 않았을 때는 퓨처를 다시 잠들게 합니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="pinning-and-the-pin-and-unpin-traits"></a></p>
<h3 id="pin과-unpin-트레이트"><a class="header" href="#pin과-unpin-트레이트"><code>Pin</code>과 <code>Unpin</code> 트레이트</a></h3>
<p>목록 17-16에서 피닝(pinning)의 개념을 소개했을 때, 우리는 매우 까다로운 에러 메시지에 맞닥뜨렸습니다. 관련 부분만 다시 보겠습니다.</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-16
cargo build
copy *only* the final `error` block from the errors
-->
<p>29 |     F: Future, |        ^^^^^^ <code>JoinAll</code>의 이 바운드에 의해 요구됨</p>
<pre><code class="language-text">error[E0277]: `{async block@src/main.rs:10:23: 10:33}`는 언피닝(unpinned)될 수 없습니다
  --&gt; src/main.rs:48:33
   |
48 |         trpl::join_all(futures).await;
   |                                 ^^^^^ `{async block@src/main.rs:10:23: 10:33}`에 대해 `Unpin` 트레이트가 구현되지 않았으며, 이는 `Box&lt;{async block@src/main.rs:10:23: 10:33}&gt;: Future`에 의해 요구됩니다
   |
   = note: `pin!` 매크로 사용을 고려해 보세요
           현재 스코프 외부에서 피닝된 값에 접근해야 한다면 `Box::pin` 사용을 고려해 보세요
   = note: `Box&lt;{async block@src/main.rs:10:23: 10:33}&gt;`가 `Future`를 구현하기 위해 필요합니다
note: `futures_util::future::join_all::JoinAll`의 바운드에 의해 요구됩니다
  --&gt; file:///home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/futures-util-0.3.30/src/future/join_all.rs:29:8
   |
27 | pub struct JoinAll&lt;F&gt;
   |            ------- 이 구조체의 바운드에 의해 요구됨
28 | where
29 |     F: Future,
   |        ^^^^^^ `JoinAll`의 이 바운드에 의해 요구됨
```
</code></pre>
<p>This error message tells us not only that we need to pin the values but also why pinning is required. The <code>trpl::join_all</code> function returns a struct called <code>JoinAll</code>. That struct is generic over a type <code>F</code>, which is constrained to implement the <code>Future</code> trait. Directly awaiting a future with <code>await</code> pins the future implicitly. That’s why we don’t need to use <code>pin!</code> everywhere we want to await futures.</p>
<p>하지만 여기서는 퓨처를 직접 기다리고 있지 않습니다. 대신 <code>join_all</code> 함수에 퓨처 컬렉션을 전달하여 새로운 퓨처인 <code>JoinAll</code>을 구성합니다. <code>join_all</code>의 시그니처는 컬렉션에 포함된 아이템들의 타입이 모두 <code>Future</code> 트레이트를 구현할 것을 요구하며, <code>Box&lt;T&gt;</code>는 그것이 감싸고 있는 <code>T</code>가 <code>Unpin</code> 트레이트를 구현하는 퓨처인 경우에만 <code>Future</code>를 구현합니다.</p>
<p>소화해야 할 내용이 많네요! 이를 제대로 이해하기 위해, <code>Future</code> 트레이트가 실제로 어떻게 작동하는지, 특히 _피닝(pinning)_과 관련하여 좀 더 깊이 들어가 봅시다.</p>
<p><code>Future</code> 트레이트의 정의를 다시 살펴보세요.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::pin::Pin;
use std::task::{Context, Poll};

pub trait Future {
    type Output;

    // 필수 메서드
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p><code>cx</code> 매개변수와 그 <code>Context</code> 타입은 런타임이 지연(lazy) 상태를 유지하면서도 주어진 퓨처를 언제 확인해야 할지 실제로 아는 핵심 비결입니다. 다시 말하지만, 그것이 어떻게 작동하는지에 대한 세부 사항은 이 장의 범위를 벗어나며, 여러분은 일반적으로 커스텀 <code>Future</code> 구현을 작성할 때만 이를 생각하면 됩니다. 대신 우리는 <code>self</code>의 타입에 집중할 것입니다. 이는 우리가 <code>self</code>에 타입 어노테이션이 있는 메서드를 처음 보는 것이기 때문입니다. <code>self</code>에 대한 타입 어노테이션은 다른 함수 매개변수에 대한 타입 어노테이션과 비슷하게 작동하지만, 두 가지 주요 차이점이 있습니다.</p>
<ul>
<li>
<p>메서드가 호출되기 위해 <code>self</code>가 어떤 타입이어야 하는지를 러스트에게 알려줍니다.</p>
</li>
<li>
<p>단순히 아무 타입이나 될 수는 없습니다. 메서드가 구현된 타입, 그 타입에 대한 참조나 스마트 포인터, 또는 그 타입에 대한 참조를 감싸는 <code>Pin</code>으로 제한됩니다.</p>
</li>
</ul>
<p>이 문법에 대해서는 <a href="ch18-00-oop.html">18장</a><!-- ignore -->에서 더 자세히 보게 될 것입니다. 지금은 퓨처가 <code>Pending</code>인지 <code>Ready(Output)</code>인지 확인하기 위해 폴링하고 싶다면, 해당 타입에 대한 <code>Pin</code>으로 감싸인 가변 참조가 필요하다는 것만 알면 충분합니다.</p>
<p><code>Pin</code>은 <code>&amp;</code>, <code>&amp;mut</code>, <code>Box</code>, <code>Rc</code>와 같은 포인터 유사 타입들을 위한 래퍼입니다. (엄밀히 말하면 <code>Pin</code>은 <code>Deref</code>나 <code>DerefMut</code> 트레이트를 구현하는 타입들과 함께 작동하지만, 이는 사실상 포인터들하고만 작동하는 것과 같습니다.) <code>Pin</code>은 그 자체로 포인터가 아니며, 참조 카운팅을 하는 <code>Rc</code>나 <code>Arc</code>와 같은 고유한 동작을 가지고 있지도 않습니다. 그것은 순전히 컴파일러가 포인터 사용에 대한 제약 조건을 강제하기 위해 사용할 수 있는 도구일 뿐입니다.</p>
<p><code>await</code>가 <code>poll</code> 호출을 기반으로 구현된다는 점을 상기해 보면 아까 보았던 에러 메시지가 조금씩 이해되기 시작하지만, 그 에러는 <code>Pin</code>이 아니라 <code>Unpin</code>에 관한 것이었습니다. 그렇다면 정확히 <code>Pin</code>은 <code>Unpin</code>과 어떤 관계가 있으며, 왜 <code>Future</code>는 <code>poll</code>을 호출하기 위해 <code>self</code>가 <code>Pin</code> 타입 내에 있어야 할까요?</p>
<p>이 장의 앞부분에서 퓨처 내의 일련의 await 지점들이 상태 머신으로 컴파일되며, 컴파일러는 그 상태 머신이 대여 및 소유권을 포함하여 러스트의 모든 일반적인 안전성 규칙을 따르도록 보장한다는 점을 기억하세요. 이를 위해 러스트는 한 await 지점과 다음 await 지점 사이, 또는 비동기 블록의 끝 사이에 어떤 데이터가 필요한지 살펴봅니다. 그런 다음 컴파일된 상태 머신에 그에 대응하는 변형(variant)을 만듭니다. 각 변형은 소스 코드의 해당 섹션에서 사용될 데이터에 대해, 데이터의 소유권을 가져오거나 가변 또는 불변 참조를 얻음으로써 필요한 접근 권한을 갖게 됩니다.</p>
<p>여기까지는 좋습니다. 주어진 비동기 블록 내의 소유권이나 참조에 잘못된 점이 있다면 대여 검사기가 알려줄 테니까요. 하지만 그 블록에 해당하는 퓨처를 이동시키고 싶을 때—예를 들어 <code>join_all</code>에 전달하기 위해 <code>Vec</code>에 넣는 경우—상황은 더 까다로워집니다.</p>
<p>우리가 퓨처를 이동시킬 때—그것이 <code>join_all</code>에서 반복자로 사용하기 위해 데이터 구조에 밀어 넣는 것이든, 함수에서 반환하는 것이든—그것은 사실 러스트가 우리를 위해 만든 상태 머신을 이동시키는 것을 의미합니다. 그리고 러스트의 대부분의 다른 타입들과 달리, 비동기 블록을 위해 러스트가 만드는 퓨처들은 그림 17-4의 단순화된 삽화에서 보여주듯 주어진 변형의 필드에 자기 자신에 대한 참조를 가질 수 있게 됩니다.</p>
<figure>
<img alt="A single-column, three-row table representing a future, fut1, which has data values 0 and 1 in the first two rows and an arrow pointing from the third row back to the second row, representing an internal reference within the future." src="img/trpl17-04.svg" class="center" />
<figcaption>Figure 17-4: A self-referential data type.</figcaption>
</figure>
<p>하지만 기본적으로 자기 자신에 대한 참조를 가진 객체는 이동하기에 안전하지 않습니다. 참조는 항상 자신이 참조하는 대상의 실제 메모리 주소를 가리키기 때문입니다(그림 17-5 참조). 데이터 구조 자체를 이동시키면, 그 내부의 참조들은 예전 위치를 가리키는 채로 남게 됩니다. 하지만 그 메모리 위치는 이제 유효하지 않습니다. 우선 데이터 구조를 변경해도 그 값은 업데이트되지 않을 것입니다. 또한—더 중요한 것은—컴퓨터가 이제 그 메모리를 다른 용도로 자유롭게 재사용할 수 있다는 점입니다! 나중에 완전히 상관없는 데이터를 읽게 될 수도 있습니다.</p>
<figure>
<img alt="Two tables, depicting two futures, fut1 and fut2, each of which has one column and three rows, representing the result of having moved a future out of fut1 into fut2. The first, fut1, is grayed out, with a question mark in each index, representing unknown memory. The second, fut2, has 0 and 1 in the first and second rows and an arrow pointing from its third row back to the second row of fut1, representing a pointer that is referencing the old location in memory of the future before it was moved." src="img/trpl17-05.svg" class="center" />
<figcaption>Figure 17-5: The unsafe result of moving a self-referential data type</figcaption>
</figure>
<p>이론적으로는 러스트 컴파일러가 객체가 이동할 때마다 그 객체에 대한 모든 참조를 업데이트하도록 시도할 수도 있겠지만, 이는 특히 수많은 참조가 얽혀 있는 경우 막대한 성능 오버헤드를 발생시킬 수 있습니다. 대신 문제가 되는 데이터 구조가 <em>메모리에서 이동하지 않도록</em> 보장할 수 있다면, 참조를 업데이트할 필요가 없을 것입니다. 이것이 바로 러스트의 대여 검사기가 요구하는 사항입니다. 안전한 코드에서 대여 검사기는 활성화된 참조가 있는 항목을 이동시키지 못하게 합니다.</p>
<p><code>Pin</code>은 이를 기반으로 우리에게 필요한 정확한 보장을 제공합니다. 어떤 값에 대한 포인터를 <code>Pin</code>으로 감싸서 그 값을 _피닝(pin)_하면, 그 값은 더 이상 이동할 수 없게 됩니다. 따라서 <code>Pin&lt;Box&lt;SomeType&gt;&gt;</code>을 가지고 있다면, 실제로는 <code>Box</code> 포인터가 아니라 <code>SomeType</code> 값을 피닝하는 것입니다. 그림 17-6이 이 과정을 보여줍니다.</p>
<figure>
<img alt="Three boxes laid out side by side. The first is labeled “Pin”, the second “b1”, and the third “pinned”. Within “pinned” is a table labeled “fut”, with a single column; it represents a future with cells for each part of the data structure. Its first cell has the value “0”, its second cell has an arrow coming out of it and pointing to the fourth and final cell, which has the value “1” in it, and the third cell has dashed lines and an ellipsis to indicate there may be other parts to the data structure. All together, the “fut” table represents a future which is self-referential. An arrow leaves the box labeled “Pin”, goes through the box labeled “b1” and has terminates inside the “pinned” box at the “fut” table." src="img/trpl17-06.svg" class="center" />
<figcaption>Figure 17-6: Pinning a `Box` that points to a self-referential future type.</figcaption>
</figure>
<p>사실 <code>Box</code> 포인터 자체는 여전히 자유롭게 이동할 수 있습니다. 우리가 신경 쓰는 것은 궁극적으로 참조되는 데이터가 제자리에 머물도록 보장하는 것임을 기억하세요. 그림 17-7에서 보듯 포인터가 이동하더라도 <em>그것이 가리키는 데이터가 같은 위치에 있다면</em> 잠재적인 문제는 없습니다. (독자적인 연습 과제로, <code>std::pin</code> 모듈과 관련 타입들의 문서를 살펴보고 <code>Box</code>를 감싸는 <code>Pin</code>으로 이를 어떻게 수행할지 생각해 보세요.) 핵심은 자기 참조형 타입 자체가 여전히 피닝되어 있기 때문에 이동할 수 없다는 것입니다.</p>
<figure>
<img alt="Four boxes laid out in three rough columns, identical to the previous diagram with a change to the second column. Now there are two boxes in the second column, labeled “b1” and “b2”, “b1” is grayed out, and the arrow from “Pin” goes through “b2” instead of “b1”, indicating that the pointer has moved from “b1” to “b2”, but the data in “pinned” has not moved." src="img/trpl17-07.svg" class="center" />
<figcaption>Figure 17-7: Moving a `Box` which points to a self-referential future type.</figcaption>
</figure>
<p>하지만 설령 <code>Pin</code> 포인터 뒤에 있더라도 대부분의 타입들은 이동시키는 것이 완벽하게 안전합니다. 우리는 항목이 내부 참조를 가지고 있을 때만 피닝을 생각하면 됩니다. 숫자나 불리언 같은 기본 타입의 값들은 당연히 내부 참조가 없으므로 확실히 안전합니다. 여러분이 보통 러스트에서 다루는 대부분의 타입들도 마찬가지입니다. 예를 들어 <code>Vec</code>은 걱정 없이 이동시킬 수 있습니다. 지금까지 본 내용만 고려한다면, <code>Pin&lt;Vec&lt;String&gt;&gt;</code>을 가지고 있을 때 비록 <code>Vec&lt;String&gt;</code>에 다른 참조가 없어서 항상 이동하기에 안전하더라도 <code>Pin</code>이 제공하는 안전하지만 제한적인 API를 통해서만 모든 작업을 해야 할 것입니다. 우리는 이런 경우에 항목을 이동시켜도 괜찮다고 컴파일러에게 알려줄 방법이 필요하며, 바로 여기서 <code>Unpin</code>이 등장합니다.</p>
<p><code>Unpin</code>은 16장에서 보았던 <code>Send</code>, <code>Sync</code> 트레이트와 유사한 마커 트레이트이며, 따라서 그 자체로는 아무런 기능이 없습니다. 마커 트레이트는 오직 특정 맥락에서 주어진 트레이트를 구현하는 타입을 사용하는 것이 안전하다고 컴파일러에게 알려주기 위해 존재합니다. <code>Unpin</code>은 주어진 타입이 해당 값이 안전하게 이동될 수 있는지에 대한 어떠한 보장도 유지할 필요가 없음을 컴파일러에게 알려줍니다.</p>
<!--
  The inline `<code>` in the next block is to allow the inline `<em>` inside it,
  matching what NoStarch does style-wise, and emphasizing within the text here
  that it is something distinct from a normal type.
-->
<p><code>Send</code> 및 <code>Sync</code>와 마찬가지로, 컴파일러는 안전함이 증명된 모든 타입에 대해 <code>Unpin</code>을 자동으로 구현합니다. 역시 <code>Send</code> 및 <code>Sync</code>와 유사하게 <code>Unpin</code>이 구현되지 <em>않는</em> 특별한 경우는 <code>impl !Unpin for <em>SomeType</em></code>으로 표기하며, 여기서 <code><em>SomeType</em></code>은 해당 타입에 대한 포인터가 <code>Pin</code> 내에서 사용될 때마다 안전을 위해 그러한 보장을 유지해야 <em>하는</em> 타입의 이름입니다.</p>
<p>다시 말해, <code>Pin</code>과 <code>Unpin</code>의 관계에 대해 두 가지를 명심해야 합니다. 첫째, <code>Unpin</code>이 "일반적인" 경우이고 <code>!Unpin</code>이 특별한 경우입니다. 둘째, 어떤 타입이 <code>Unpin</code>을 구현하는지 혹은 <code>!Unpin</code>을 구현하는지는 오직 여러분이 <code>Pin&lt;&amp;mut <em>SomeType</em>&gt;</code>과 같이 해당 타입에 대한 피닝된 포인터를 사용할 때만 중요합니다.</p>
<p>이를 구체화하기 위해 <code>String</code>을 생각해 봅시다. <code>String</code>은 길이와 그것을 구성하는 유니코드 캐릭터들을 가지고 있습니다. 그림 17-8에서 보듯 <code>String</code>을 <code>Pin</code>으로 감쌀 수 있습니다. 하지만 <code>String</code>은 러스트의 대부분의 다른 타입들과 마찬가지로 자동으로 <code>Unpin</code>을 구현합니다.</p>
<figure>
<img alt="Concurrent work flow" src="img/trpl17-08.svg" class="center" />
<figcaption>Figure 17-8: Pinning a `String`; the dotted line indicates that the `String` implements the `Unpin` trait, and thus is not pinned.</figcaption>
</figure>
<p>그 결과, 만약 <code>String</code>이 대신 <code>!Unpin</code>을 구현했다면 불법이었을 일들을 할 수 있습니다. 예를 들어 그림 17-9와 같이 메모리의 정확히 동일한 위치에서 하나의 문자열을 다른 문자열로 교체하는 것이 가능합니다. 이는 <code>Pin</code> 계약을 위반하지 않는데, <code>String</code>은 이동시키기에 안전하지 않게 만드는 내부 참조를 가지고 있지 않기 때문입니다! 그것이 바로 <code>String</code>이 <code>!Unpin</code>이 아닌 <code>Unpin</code>을 구현하는 정확한 이유입니다.</p>
<figure>
<img alt="Concurrent work flow" src="img/trpl17-09.svg" class="center" />
<figcaption>Figure 17-9: Replacing the `String` with an entirely different `String` in memory.</figcaption>
</figure>
<p>이제 우리는 목록 17-17에서 보았던 <code>join_all</code> 호출 시 보고된 에러들을 이해할 수 있을 만큼 충분히 알게 되었습니다. 원래 우리는 비동기 블록에 의해 생성된 퓨처들을 <code>Vec&lt;Box&lt;dyn Future&lt;Output = ()&gt;&gt;&gt;</code>로 옮기려 했지만, 우리가 보았듯이 그 퓨처들은 내부 참조를 가질 수 있어 <code>Unpin</code>을 구현하지 않습니다. 그것들은 피닝(pinned)될 필요가 있으며, 그렇게 함으로써 우리는 퓨처 내부의 데이터가 이동하지 않을 것이라는 확신을 가지고 <code>Pin</code> 타입을 <code>Vec</code>에 전달할 수 있습니다.</p>
<p><code>Pin</code>과 <code>Unpin</code>은 일상적인 러스트 코드보다는 주로 저수준 라이브러리를 구축하거나 런타임 자체를 만들 때 중요합니다. 하지만 이제 에러 메시지에서 이러한 트레이트들을 보게 된다면, 코드를 어떻게 고쳐야 할지 더 잘 알게 되실 겁니다!</p>
<blockquote>
<p>참고: <code>Pin</code>과 <code>Unpin</code>의 조합은 자기 참조형(self-referential)이라서 구현하기 까다로웠을 일련의 복잡한 타입들을 러스트에서 안전하게 구현할 수 있게 해줍니다. 오늘날 비동기 러스트에서 <code>Pin</code>을 필요로 하는 타입들이 가장 흔히 나타나지만, 가끔씩 다른 맥락에서도 이들을 볼 수 있습니다.</p>
<p><code>Pin</code>과 <code>Unpin</code>이 어떻게 작동하는지, 그리고 이들이 지켜야 하는 규칙들에 대해서는 <code>std::pin</code>의 API 문서에서 광범위하게 다루고 있습니다. 더 자세히 알고 싶다면 그곳이 좋은 출발점이 될 것입니다.</p>
<p>내부적으로 어떻게 작동하는지 더 자세히 알고 싶다면, <a href="https://rust-lang.github.io/async-book/"><em>Asynchronous Programming in Rust</em></a>의 <a href="https://rust-lang.github.io/async-book/02_execution/01_chapter.html">2장</a>과 <a href="https://rust-lang.github.io/async-book/04_pinning/01_chapter.html">4장</a>을 참조하세요.</p>
</blockquote>
<h3 id="stream-트레이트"><a class="header" href="#stream-트레이트"><code>Stream</code> 트레이트</a></h3>
<p>이제 <code>Future</code>, <code>Pin</code>, <code>Unpin</code> 트레이트에 대해 더 깊이 이해했으니, <code>Stream</code> 트레이트로 관심을 돌려봅시다. 이 장의 앞부분에서 배웠듯이, 스트림은 비동기 반복자와 비슷합니다. 하지만 <code>Iterator</code>나 <code>Future</code>와 달리, 이 글을 쓰는 시점에 <code>Stream</code>은 표준 라이브러리에 정의되어 있지 않습니다. 대신 생태계 전반에서 사용되는 <code>futures</code> 크레이트의 매우 공통적인 정의가 존재합니다.</p>
<p><code>Stream</code> 트레이트가 이들을 어떻게 병합하는지 살펴보기 전에, <code>Iterator</code>와 <code>Future</code> 트레이트의 정의를 복습해 봅시다. <code>Iterator</code>로부터는 순차열(sequence)의 개념을 얻습니다. 그것의 <code>next</code> 메서드는 <code>Option&lt;Self::Item&gt;</code>을 제공하죠. <code>Future</code>로부터는 시간에 따른 준비성(readiness)의 개념을 얻습니다. 그것의 <code>poll</code> 메서드는 <code>Poll&lt;Self::Output&gt;</code>을 제공합니다. 시간이 지남에 따라 준비되는 일련의 항목들을 표현하기 위해, 우리는 이 기능들을 하나로 합친 <code>Stream</code> 트레이트를 정의합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::pin::Pin;
use std::task::{Context, Poll};

trait Stream {
    type Item;

    fn poll_next(
        self: Pin&lt;&amp;mut Self&gt;,
        cx: &amp;mut Context&lt;'_&gt;
    ) -&gt; Poll&lt;Option&lt;Self::Item&gt;&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p><code>Stream</code> 트레이트는 스트림에 의해 생성되는 항목들의 타입을 위해 <code>Item</code>이라는 연관 타입을 정의합니다. 이는 0개에서 여러 개의 항목이 있을 수 있는 <code>Iterator</code>와 비슷하며, 항상 단일 <code>Output</code>(설령 그것이 유닛 타입 <code>()</code>일지라도)을 가지는 <code>Future</code>와는 다릅니다.</p>
<p><code>Stream</code>은 또한 그 항목들을 가져오기 위한 메서드를 정의합니다. 우리는 이를 <code>poll_next</code>라고 부르는데, 이는 <code>Future::poll</code>과 같은 방식으로 폴링하고 <code>Iterator::next</code>와 같은 방식으로 일련의 항목을 생성한다는 것을 명확히 하기 위해서입니다. 그것의 반환 타입은 <code>Poll</code>과 <code>Option</code>을 결합한 것입니다. 퓨처와 마찬가지로 준비 상태를 확인해야 하므로 바깥쪽 타입은 <code>Poll</code>입니다. 안쪽 타입은 반복자와 마찬가지로 더 이상의 메시지가 있는지 알려주어야 하므로 <code>Option</code>입니다.</p>
<p>이 정의와 매우 유사한 것이 조만간 러스트 표준 라이브러리의 일부가 될 가능성이 높습니다. 그 전까지는 대부분의 런타임이 제공하는 도구의 일부이므로 안심하고 사용하셔도 되며, 우리가 다음에 다룰 모든 내용은 일반적으로 동일하게 적용될 것입니다!</p>
<p>하지만 스트리밍 섹션에서 보았던 예제에서는 <code>poll_next</code>나 <code>Stream</code>을 직접 사용하지 않고, 대신 <code>next</code>와 <code>StreamExt</code>를 사용했습니다. 물론 우리가 직접 <code>Stream</code> 상태 머신을 손으로 작성하여 <code>poll_next</code> API를 직접 다룰 수도 있습니다. 마치 <code>poll</code> 메서드를 통해 퓨처를 직접 다룰 수 있는 것과 마찬가지죠. 하지만 <code>await</code>를 사용하는 것이 훨씬 더 깔끔하며, <code>StreamExt</code> 트레이트가 <code>next</code> 메서드를 제공하므로 우리는 그렇게 할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::pin::Pin;
</span><span class="boring">use std::task::{Context, Poll};
</span><span class="boring">
</span><span class="boring">trait Stream {
</span><span class="boring">    type Item;
</span><span class="boring">    fn poll_next(
</span><span class="boring">        self: Pin&lt;&amp;mut Self&gt;,
</span><span class="boring">        cx: &amp;mut Context&lt;'_&gt;,
</span><span class="boring">    ) -&gt; Poll&lt;Option&lt;Self::Item&gt;&gt;;
</span><span class="boring">}
</span><span class="boring">
</span>trait StreamExt: Stream {
    async fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;
    where
        Self: Unpin;

    // 다른 메서드들...
}
<span class="boring">}</span></code></pre></pre>
<!--
TODO: update this if/when tokio/etc. update their MSRV and switch to using async functions
in traits, since the lack thereof is the reason they do not yet have this.
-->
<blockquote>
<p>참고: 이 장 앞부분에서 사용했던 실제 정의는 이와 약간 다르게 생겼는데, 이는 아직 트레이트에서 비동기 함수 사용을 지원하지 않던 러스트 버전들을 지원하기 위해서입니다. 그 결과, 다음과 같은 모습을 띠게 됩니다.</p>
<pre><code class="language-rust ignore">fn next(&amp;mut self) -&gt; Next&lt;'_, Self&gt; where Self: Unpin;</code></pre>
<p>저 <code>Next</code> 타입은 <code>Future</code>를 구현하는 <code>struct</code>이며, 우리가 <code>Next&lt;'_, Self&gt;</code>를 통해 <code>self</code>에 대한 참조의 라이프타임을 명명할 수 있게 해주어 <code>await</code>가 이 메서드와 함께 작동할 수 있도록 합니다.</p>
</blockquote>
<p><code>StreamExt</code> 트레이트는 스트림과 함께 사용할 수 있는 모든 흥미로운 메서드들이 모여 있는 곳이기도 합니다. <code>StreamExt</code>는 <code>Stream</code>을 구현하는 모든 타입에 대해 자동으로 구현되지만, 커뮤니티가 기초가 되는 트레이트에 영향을 주지 않으면서 편의용 API들을 발전시킬 수 있도록 이 트레이트들은 별도로 정의되어 있습니다.</p>
<p><code>trpl</code> 크레이트에서 사용되는 <code>StreamExt</code> 버전에서는, 이 트레이트가 <code>next</code> 메서드를 정의할 뿐만 아니라 <code>Stream::poll_next</code>를 호출하는 세부 사항을 올바르게 처리하는 <code>next</code>의 기본 구현도 제공합니다. 즉, 여러분이 자신만의 스트리밍 데이터 타입을 작성해야 할 때라도 <code>Stream</code>만 구현하면 되며, 그러면 여러분의 데이터 타입을 사용하는 누구라도 자동으로 <code>StreamExt</code>와 그 메서드들을 사용할 수 있게 됩니다.</p>
<p>이 트레이트들의 저수준 세부 사항에 대해 다룰 내용은 이것이 전부입니다. 마무리하면서, (스트림을 포함한) 퓨처, 태스크, 그리고 스레드가 모두 어떻게 함께 어우러지는지 생각해 봅시다!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="모든-것을-하나로-퓨처-태스크-스레드"><a class="header" href="#모든-것을-하나로-퓨처-태스크-스레드">모든 것을 하나로: 퓨처, 태스크, 스레드</a></h2>
<p><a href="http://localhost:3000/ch16-00-concurrency.html">16장</a><!-- ignore -->에서 보았듯이, 스레드는 동시성에 대한 한 가지 접근 방식을 제공합니다. 이 장에서 우리는 퓨처와 스트림과 함께 비동기를 사용하는 또 다른 접근 방식을 보았습니다. 어느 한 방법을 다른 방법보다 언제 선택해야 할지 궁금하다면, 답은 '상황에 따라 다르다'입니다! 그리고 많은 경우 선택은 스레드 <em>또는</em> 비동기가 아니라, 스레드 <em>그리고</em> 비동기입니다.</p>
<p>많은 운영 체제들이 수십 년 동안 스레드 기반 동시성 모델을 제공해 왔으며, 그 결과 많은 프로그래밍 언어들이 이를 지원합니다. 하지만 이러한 모델에도 트레이드오프는 존재합니다. 많은 운영 체제에서 각 스레드는 상당한 양의 메모리를 사용하며, 시작하고 종료하는 데 약간의 오버헤드가 따릅니다. 또한 스레드는 운영 체제와 하드웨어가 이를 지원할 때만 선택 가능한 옵션입니다. 주류 데스크톱 및 모바일 컴퓨터와 달리, 일부 임베디드 시스템은 OS가 아예 없기도 하며, 따라서 스레드도 없습니다.</p>
<p>비동기 모델은 이와 다르고 궁극적으로 보완적인 트레이드오프 세트를 제공합니다. 비동기 모델에서 동시 작업은 자신만의 스레드를 필요로 하지 않습니다. 대신, 스트림 섹션에서 동기 함수로부터 작업을 시작하기 위해 <code>trpl::spawn_task</code>를 사용했던 것처럼 태스크(task) 상에서 실행될 수 있습니다. 태스크는 스레드와 유사하지만, 운영 체제에 의해 관리되는 대신 라이브러리 수준의 코드인 런타임에 의해 관리됩니다.</p>
<p>이전 섹션에서 우리는 비동기 채널을 사용하고 동기 코드에서 호출할 수 있는 비동기 태스크를 생성함으로써 스트림을 구축할 수 있음을 보았습니다. 스레드로도 똑같은 작업을 할 수 있습니다. 목록 17-40에서는 <code>trpl::spawn_task</code>와 <code>trpl::sleep</code>을 사용했습니다. 목록 17-41에서는 <code>get_intervals</code> 함수 내에서 이들을 표준 라이브러리의 <code>thread::spawn</code> 및 <code>thread::sleep</code> API로 교체합니다.</p>
<Listing number="17-41" caption="Using the `std::thread` APIs instead of the async `trpl` APIs for the `get_intervals` function" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, thread, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let messages = get_messages().timeout(Duration::from_millis(200));
</span><span class="boring">        let intervals = get_intervals()
</span><span class="boring">            .map(|count| format!("간격 #{count}"))
</span><span class="boring">            .throttle(Duration::from_millis(500))
</span><span class="boring">            .timeout(Duration::from_secs(10));
</span><span class="boring">        let merged = messages.merge(intervals).take(20);
</span><span class="boring">        let mut stream = pin!(merged);
</span><span class="boring">
</span><span class="boring">        while let Some(result) = stream.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(item) =&gt; println!("{item}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("문제: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">
</span><span class="boring">        for (index, message) in messages.into_iter().enumerate() {
</span><span class="boring">            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
</span><span class="boring">            trpl::sleep(Duration::from_millis(time_to_sleep)).await;
</span><span class="boring">
</span><span class="boring">            if let Err(send_error) = tx.send(format!("메시지: '{message}'")) {
</span><span class="boring">                eprintln!("메시지 '{message}'를 보낼 수 없습니다: {send_error}");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}
</span><span class="boring">
</span>fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
    let (tx, rx) = trpl::channel();

    // 이것은 `trpl::spawn`이 아니라 `std::thread::spawn`입니다!
    thread::spawn(move || {
        let mut count = 0;
        loop {
            // 마찬가지로, 이것은 `trpl::sleep`이 아니라 `std::thread::sleep`입니다!
            thread::sleep(Duration::from_millis(1));
            count += 1;

            if let Err(send_error) = tx.send(count) {
                eprintln!("간격 {count}를 보낼 수 없습니다: {send_error}");
                break;
            };
        }
    });

    ReceiverStream::new(rx)
}</code></pre></pre>
</Listing>
<p>이 코드를 실행하면 출력 결과는 목록 17-40과 동일합니다. 그리고 호출하는 코드의 관점에서 얼마나 변화가 적은지 주목해 보세요. 게다가, 우리 함수 중 하나는 런타임 상에서 비동기 태스크를 생성했고 다른 하나는 OS 스레드를 생성했음에도 불구하고, 그 결과로 생성된 스트림들은 그 차이에 영향을 받지 않았습니다.</p>
<p>유사점에도 불구하고 이 두 접근 방식은 매우 다르게 작동합니다. 비록 이 아주 단순한 예제에서는 이를 측정하기 어려울 수 있지만요. 우리는 현대적인 어떤 개인용 컴퓨터에서도 수백만 개의 비동기 태스크를 생성할 수 있습니다. 만약 스레드로 그렇게 하려고 했다면, 말 그대로 메모리가 부족해졌을 것입니다!</p>
<p>하지만 이 API들이 이토록 유사한 데에는 이유가 있습니다. 스레드는 동기 작업 세트의 경계 역할을 하며, 스레드 _사이_에서 동시성이 가능합니다. 태스크는 <em>비동기</em> 작업 세트의 경계 역할을 하며, 태스크 본문 내에서 퓨처들을 전환할 수 있기 때문에 태스크 _사이_뿐만 아니라 태스크 _내부_에서도 동시성이 가능합니다. 마지막으로, 퓨처는 러스트에서 가장 미세한 동시성 단위이며, 각 퓨처는 다른 퓨처들의 트리를 나타낼 수 있습니다. 런타임—구체적으로는 그 실행기(executor)—은 태스크를 관리하고, 태스크는 퓨처를 관리합니다. 그런 점에서 태스크는 운영 체제 대신 런타임에 의해 관리됨으로써 얻는 추가적인 기능들을 갖춘, 가볍고 런타임 관리형인 스레드와 유사합니다.</p>
<p>그렇다고 해서 비동기 태스크가 항상 스레드보다 낫다(혹은 그 반대다)는 의미는 아닙니다. 스레드를 사용한 동시성은 어떤 면에서 <code>async</code>를 사용한 동시성보다 더 단순한 프로그래밍 모델입니다. 그것은 강점이 될 수도 있고 약점이 될 수도 있습니다. 스레드는 다소 "실행 후 망각(fire and forget)" 방식입니다. 퓨처에 대응하는 자체적인 요소가 없으므로, 운영 체제 자체에 의한 간섭을 제외하고는 단순히 완료될 때까지 실행됩니다. 즉, 퓨처처럼 _태스크 내 동시성(intratask concurrency)_을 위한 내장된 지원이 없습니다. 러스트의 스레드는 또한 취소 메커니즘이 없습니다. 이 주제는 이번 장에서 명시적으로 다루지는 않았지만, 우리가 퓨처를 종료할 때마다 그 상태가 올바르게 정리되었다는 사실에 암시되어 있었습니다.</p>
<p>이러한 제한 사항들은 또한 스레드를 퓨처보다 조합하기 어렵게 만듭니다. 예를 들어, 스레드를 사용하여 이 장 앞부분에서 만들었던 <code>timeout</code>이나 <code>throttle</code> 메서드 같은 헬퍼를 구축하는 것은 훨씬 더 어렵습니다. 우리가 보았듯이, 퓨처가 더 풍부한 데이터 구조라는 사실은 그것들이 더 자연스럽게 서로 조합될 수 있음을 의미합니다.</p>
<p>태스크는 퓨처에 대해 <em>추가적인</em> 제어권을 제공하여, 우리가 퓨처들을 어디서 어떻게 그룹화할지 선택할 수 있게 해줍니다. 그리고 스레드와 태스크는 종종 매우 잘 어우러지는데, 이는 태스크가 (적어도 일부 런타임에서는) 스레드 사이를 옮겨 다닐 수 있기 때문입니다. 사실 우리가 사용해 온 런타임은—<code>spawn_blocking</code> 및 <code>spawn_task</code> 함수를 포함하여—내부적으로 기본값이 멀티스레드입니다! 많은 런타임들이 시스템의 전체적인 성능을 향상시키기 위해, 스레드들이 현재 어떻게 활용되고 있는지에 따라 태스크를 스레드 간에 투명하게 이동시키는 _워크 스틸링(work stealing)_이라는 접근 방식을 사용합니다. 이 방식은 실제로 스레드 <em>그리고</em> 태스크를 필요로 하며, 결과적으로 퓨처도 필요합니다.</p>
<p>언제 어떤 방법을 사용할지 고민될 때는 다음과 같은 경험 법칙을 고려해 보세요.</p>
<ul>
<li>작업이 각 부분을 개별적으로 처리할 수 있는 대량의 데이터를 다루는 것과 같이 <em>매우 병렬화 가능하다면</em>, 스레드가 더 나은 선택입니다.</li>
<li>작업이 서로 다른 간격이나 속도로 들어올 수 있는 수많은 소스로부터의 메시지를 처리하는 것과 같이 <em>매우 동시적이라면</em>, 비동기가 더 나은 선택입니다.</li>
</ul>
<p>그리고 병렬성과 동시성이 모두 필요하다면, 스레드와 비동기 중 하나를 선택할 필요가 없습니다. 그것들을 자유롭게 함께 사용하여 각자가 가장 잘하는 역할을 수행하게 할 수 있습니다. 예를 들어, 목록 17-42는 실제 러스트 코드에서 이런 종류의 혼합이 사용되는 꽤 흔한 사례를 보여줍니다.</p>
<Listing number="17-42" caption="Sending messages with blocking code in a thread and awaiting the messages in an async block" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트용
</span><span class="boring">
</span>use std::{thread, time::Duration};

fn main() {
    let (tx, mut rx) = trpl::channel();

    thread::spawn(move || {
        for i in 1..11 {
            tx.send(i).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    trpl::run(async {
        while let Some(message) = rx.recv().await {
            println!("{message}");
        }
    });
}</code></pre></pre>
</Listing>
<p>먼저 비동기 채널을 생성한 다음, 채널의 송신 측 소유권을 가지는 스레드를 생성합니다. 스레드 내에서는 1부터 10까지의 숫자를 보내며, 각 숫자 사이에 1초씩 잠을 잡니다. 마지막으로, 이 장 전체에서 해왔던 것처럼 <code>trpl::run</code>에 전달된 비동기 블록으로 생성된 퓨처를 실행합니다. 그 퓨처 내에서 우리는 이전에 보았던 다른 메시지 전달 예제들과 마찬가지로 그 메시지들을 기다립니다.</p>
<p>이 장을 시작할 때의 시나리오로 돌아가서, 전용 스레드를 사용하여 일련의 비디오 인코딩 태스크를 실행하고(비디오 인코딩은 계산 위주의 작업이므로), 비동기 채널을 통해 UI에 해당 작업이 완료되었음을 알리는 것을 상상해 보세요. 실제 사용 사례에서 이러한 종류의 조합은 무수히 많습니다.</p>
<h2 id="요약-16"><a class="header" href="#요약-16">요약</a></h2>
<p>이 책에서 동시성을 다루는 것은 이것이 마지막이 아닙니다. <a href="ch21-00-final-project-a-web-server.html">21장</a>의 프로젝트에서는 여기서 논의된 간단한 예제들보다 더 현실적인 상황에 이러한 개념들을 적용하고, 스레딩 대 태스크를 통한 문제 해결을 더 직접적으로 비교해 볼 것입니다.</p>
<p>여러분이 이 접근 방식 중 어떤 것을 선택하든, 러스트는 안전하고 빠르며 동시적인 코드를 작성하는 데 필요한 도구들을 제공합니다—고성능 웹 서버를 위해서든 임베디드 운영 체제를 위해서든 말이죠.</p>
<p>다음으로, 러스트 프로그램이 커짐에 따라 문제를 모델링하고 솔루션을 구조화하는 관용적인 방법들에 대해 이야기할 것입니다. 또한 러스트의 관용구가 여러분이 익숙할 수도 있는 객체 지향 프로그래밍의 관용구와 어떤 관련이 있는지 논의할 것입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="러스트의-객체-지향-프로그래밍-기능"><a class="header" href="#러스트의-객체-지향-프로그래밍-기능">러스트의 객체 지향 프로그래밍 기능</a></h1>
<p>객체 지향 프로그래밍(OOP)은 프로그램을 모델링하는 한 방법입니다. 프로그래밍 개념으로서의 객체는 1960년대 프로그래밍 언어인 Simula에서 도입되었습니다. 이러한 객체들은 객체들이 서로 메시지를 주고받는 앨런 케이(Alan Kay)의 프로그래밍 아키텍처에 영향을 주었습니다. 그는 이 아키텍처를 설명하기 위해 1967년에 _객체 지향 프로그래밍_이라는 용어를 만들었습니다. OOP가 무엇인지에 대해 여러 가지 경쟁적인 정의가 존재하며, 어떤 정의에 따르면 러스트는 객체 지향적이지만 다른 정의에 따르면 그렇지 않습니다. 이 장에서는 일반적으로 객체 지향적이라고 여겨지는 몇 가지 특성들과 이러한 특성들이 관용적인 러스트로 어떻게 변환되는지 살펴볼 것입니다. 그런 다음 러스트에서 객체 지향 디자인 패턴을 구현하는 방법을 보여주고, 그렇게 하는 것과 러스트만의 강점을 활용하여 해결책을 구현하는 것 사이의 트레이드오프에 대해 논의할 것입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="객체-지향-언어의-특성"><a class="header" href="#객체-지향-언어의-특성">객체 지향 언어의 특성</a></h2>
<p>프로그래밍 커뮤니티에는 어떤 언어가 객체 지향으로 간주되기 위해 갖추어야 할 기능에 대한 합의가 없습니다. 러스트는 OOP를 포함한 많은 프로그래밍 패러다임의 영향을 받았습니다. 예를 들어, 우리는 13장에서 함수형 프로그래밍에서 유래한 기능들을 살펴보았습니다. 논쟁의 여지는 있지만, OOP 언어들은 객체, 캡슐화, 상속이라는 특정한 공통 특성을 공유합니다. 이러한 각각의 특성이 무엇을 의미하는지, 그리고 러스트가 이를 지원하는지 살펴보겠습니다.</p>
<h3 id="객체는-데이터와-동작을-담는다"><a class="header" href="#객체는-데이터와-동작을-담는다">객체는 데이터와 동작을 담는다</a></h3>
<p>에리히 감마(Erich Gamma), 리처드 헬름(Richard Helm), 랄프 존슨(Ralph Johnson), 존 블리시디스(John Vlissides)가 저술한 <em>Design Patterns: Elements of Reusable Object-Oriented Software</em> (Addison-Wesley Professional, 1994)는 구어체로 <em>GoF(Gang of Four)</em> 책이라고 불리며, 객체 지향 디자인 패턴의 카탈로그입니다. 이 책은 OOP를 다음과 같이 정의합니다.</p>
<blockquote>
<p>객체 지향 프로그램은 객체들로 구성된다. <strong>객체</strong>는 데이터와 그 데이터를 조작하는 프로시저를 모두 패키징한다. 프로시저는 일반적으로 <strong>메서드</strong> 또는 <strong>오퍼레이션</strong>이라고 불린다.</p>
</blockquote>
<p>이 정의를 사용하면 러스트는 객체 지향적입니다. 구조체와 열거형은 데이터를 가지며, <code>impl</code> 블록은 구조체와 열거형에 메서드를 제공합니다. 비록 메서드를 가진 구조체와 열거형이 객체라고 <em>불리지는</em> 않지만, GoF의 객체 정의에 따르면 동일한 기능을 제공합니다.</p>
<h3 id="구현-세부-사항을-숨기는-캡슐화"><a class="header" href="#구현-세부-사항을-숨기는-캡슐화">구현 세부 사항을 숨기는 캡슐화</a></h3>
<p>OOP와 흔히 연관되는 또 다른 측면은 _캡슐화(encapsulation)_라는 개념입니다. 이는 객체의 구현 세부 사항이 해당 객체를 사용하는 코드에 노출되지 않음을 의미합니다. 따라서 객체와 상호작용하는 유일한 방법은 공개된 API를 통해서이며, 객체를 사용하는 코드가 객체의 내부로 들어가 데이터나 동작을 직접 변경할 수 없어야 합니다. 이를 통해 프로그래머는 객체를 사용하는 코드를 변경할 필요 없이 객체의 내부를 변경하고 리팩터링할 수 있습니다.</p>
<p>우리는 7장에서 캡슐화를 제어하는 방법을 논의했습니다. <code>pub</code> 키워드를 사용하여 코드의 어떤 모듈, 타입, 함수, 메서드가 공개될지 결정할 수 있으며, 기본적으로 그 외의 모든 것은 비공개입니다. 예를 들어, <code>i32</code> 값들의 벡터를 포함하는 필드를 가진 <code>AveragedCollection</code> 구조체를 정의할 수 있습니다. 또한 이 구조체는 벡터 값들의 평균을 저장하는 필드를 가질 수 있는데, 이는 누군가가 필요로 할 때마다 매번 평균을 계산할 필요가 없음을 의미합니다. 즉, <code>AveragedCollection</code>은 계산된 평균을 우리를 위해 캐싱해 둡니다. 목록 18-1에 <code>AveragedCollection</code> 구조체의 정의가 있습니다.</p>
<Listing number="18-1" file-name="src/lib.rs" caption="An `AveragedCollection` struct that maintains a list of integers and the average of the items in the collection">
<pre><code class="language-rust noplayground">pub struct AveragedCollection {
    list: Vec&lt;i32&gt;,
    average: f64,
}</code></pre>
</Listing>
<p>이 구조체는 다른 코드에서 사용할 수 있도록 <code>pub</code>으로 표시되었지만, 구조체 내부의 필드들은 비공개로 유지됩니다. 이 사례에서 이는 중요한데, 리스트에서 값이 추가되거나 제거될 때마다 평균도 확실히 업데이트되기를 원하기 때문입니다. 우리는 목록 18-2에 나타난 것처럼 구조체에 <code>add</code>, <code>remove</code>, <code>average</code> 메서드를 구현함으로써 이를 달성합니다.</p>
<Listing number="18-2" file-name="src/lib.rs" caption="Implementations of the public methods `add`, `remove`, and `average` on `AveragedCollection`">
<pre><code class="language-rust noplayground"><span class="boring">pub struct AveragedCollection {
</span><span class="boring">    list: Vec&lt;i32&gt;,
</span><span class="boring">    average: f64,
</span><span class="boring">}
</span><span class="boring">
</span>impl AveragedCollection {
    pub fn add(&amp;mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let result = self.list.pop();
        match result {
            Some(value) =&gt; {
                self.update_average();
                Some(value)
            }
            None =&gt; None,
        }
    }

    pub fn average(&amp;self) -&gt; f64 {
        self.average
    }

    fn update_average(&amp;mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}</code></pre>
</Listing>
<p>공개 메서드인 <code>add</code>, <code>remove</code>, <code>average</code>는 <code>AveragedCollection</code> 인스턴스의 데이터에 접근하거나 이를 수정할 수 있는 유일한 방법입니다. <code>add</code> 메서드를 통해 <code>list</code>에 아이템이 추가되거나 <code>remove</code> 메서드를 통해 제거될 때, 각각의 구현은 <code>average</code> 필드의 업데이트까지 처리하는 비공개 메서드 <code>update_average</code>를 호출합니다.</p>
<p><code>list</code>와 <code>average</code> 필드를 비공개로 두었기 때문에 외부 코드에서 <code>list</code> 필드에 아이템을 직접 추가하거나 제거할 방법이 없습니다. 만약 직접 가능하다면 <code>list</code>가 변경될 때 <code>average</code> 필드가 동기화되지 않을 수 있습니다. <code>average</code> 메서드는 <code>average</code> 필드의 값을 반환하여, 외부 코드에서 평균값을 읽을 수는 있지만 수정할 수는 없게 합니다.</p>
<p>우리가 <code>AveragedCollection</code> 구조체의 구현 세부 사항을 캡슐화했기 때문에, 나중에 데이터 구조와 같은 측면들을 쉽게 변경할 수 있습니다. 예를 들어, <code>list</code> 필드에 <code>Vec&lt;i32&gt;</code> 대신 <code>HashSet&lt;i32&gt;</code>를 사용할 수도 있습니다. 공개 메서드인 <code>add</code>, <code>remove</code>, <code>average</code>의 시그니처가 동일하게 유지되는 한, <code>AveragedCollection</code>을 사용하는 코드는 컴파일을 위해 변경될 필요가 없습니다. 만약 대신 <code>list</code>를 공개로 만들었다면 상황은 달라졌을 것입니다. <code>HashSet&lt;i32&gt;</code>와 <code>Vec&lt;i32&gt;</code>는 아이템을 추가하고 제거하는 메서드가 다르므로, 외부 코드에서 <code>list</code>를 직접 수정하고 있었다면 코드를 변경해야 했을 것입니다.</p>
<p>캡슐화가 어떤 언어를 객체 지향 언어로 간주하기 위한 필수 조건이라면, 러스트는 그 조건을 충족합니다. 코드의 여러 부분에 대해 <code>pub</code> 사용 여부를 선택할 수 있으므로 구현 세부 사항의 캡슐화가 가능합니다.</p>
<h3 id="타입-시스템이자-코드-공유로서의-상속"><a class="header" href="#타입-시스템이자-코드-공유로서의-상속">타입 시스템이자 코드 공유로서의 상속</a></h3>
<p>_상속(Inheritance)_은 어떤 객체가 다른 객체의 정의로부터 요소들을 물려받을 수 있는 메커니즘으로, 이를 통해 부모 객체의 데이터와 동작을 다시 정의할 필요 없이 그대로 얻을 수 있습니다.</p>
<p>만약 어떤 언어가 객체 지향 언어이기 위해 상속을 반드시 가져야 한다면, 러스트는 객체 지향 언어가 아닙니다. 매크로를 사용하지 않고서는 부모 구조체의 필드와 메서드 구현을 상속받는 구조체를 정의할 방법이 없습니다.</p>
<p>하지만 프로그래밍 도구 상자에 상속이 있는 것에 익숙하다면, 애초에 왜 상속을 사용하려고 했는지에 따라 러스트에서 다른 해결책을 사용할 수 있습니다.</p>
<p>상속을 선택하는 데는 주로 두 가지 이유가 있습니다. 하나는 코드의 재사용입니다. 한 타입에 대해 특정 동작을 구현하고, 상속을 통해 다른 타입에서 그 구현을 재사용할 수 있습니다. 러스트 코드에서는 트레이트 메서드의 기본 구현을 사용하여 이를 제한적으로 수행할 수 있습니다. 이는 목록 10-14에서 <code>Summary</code> 트레이트에 <code>summarize</code> 메서드의 기본 구현을 추가했을 때 보았습니다. <code>Summary</code> 트레이트를 구현하는 모든 타입은 추가 코드 없이 <code>summarize</code> 메서드를 사용할 수 있습니다. 이는 부모 클래스가 메서드 구현을 가지고 있고 상속받는 자식 클래스도 해당 메서드 구현을 가지는 것과 유사합니다. 또한 <code>Summary</code> 트레이트를 구현할 때 <code>summarize</code> 메서드의 기본 구현을 오버라이드할 수도 있는데, 이는 자식 클래스가 부모 클래스로부터 상속받은 메서드의 구현을 오버라이드하는 것과 유사합니다.</p>
<p>상속을 사용하는 또 다른 이유는 타입 시스템과 관련이 있습니다. 자식 타입을 부모 타입이 사용되는 곳에서 동일하게 사용할 수 있게 하기 위해서입니다. 이를 _다형성(polymorphism)_이라고도 하는데, 이는 여러 객체가 특정 특성을 공유할 경우 런타임에 서로를 대체할 수 있음을 의미합니다.</p>
<blockquote>
<h3 id="다형성"><a class="header" href="#다형성">다형성</a></h3>
<p>많은 사람들에게 다형성은 상속과 동의어입니다. 하지만 실제로는 여러 타입의 데이터와 함께 작동할 수 있는 코드를 의미하는 더 일반적인 개념입니다. 상속의 경우, 이러한 타입들은 일반적으로 서브클래스들입니다.</p>
<p>러스트는 대신 제네릭을 사용하여 가능한 여러 타입에 대해 추상화하고, 트레이트 바운드를 사용하여 해당 타입들이 반드시 제공해야 하는 기능에 제약을 겁니다. 이를 때로는 _제한된 매개변수 다형성(bounded parametric polymorphism)_이라고 부릅니다.</p>
</blockquote>
<p>상속은 최근 많은 프로그래밍 언어에서 설계 솔루션으로서 인기를 잃고 있는데, 필요 이상의 코드를 공유하게 될 위험이 크기 때문입니다. 서브클래스가 부모 클래스의 모든 특성을 항상 공유해야 하는 것은 아니지만, 상속을 사용하면 그렇게 됩니다. 이는 프로그램의 설계를 덜 유연하게 만들 수 있습니다. 또한 서브클래스에 적용되지 않아 의미가 없거나 에러를 유발하는 메서드를 서브클래스에서 호출하게 될 가능성도 생깁니다. 게다가 일부 언어는 _단일 상속(single inheritance)_만 허용하여(서브클래스가 오직 하나의 클래스만 상속받을 수 있음을 의미), 프로그램 설계의 유연성을 더욱 제한합니다.</p>
<p>이러한 이유들로 인해, 러스트는 상속 대신 트레이트 객체를 사용하는 다른 접근 방식을 취합니다. 러스트에서 트레이트 객체가 어떻게 다형성을 가능하게 하는지 살펴봅시다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="다른-타입의-값을-허용하는-트레이트-객체-사용하기"><a class="header" href="#다른-타입의-값을-허용하는-트레이트-객체-사용하기">다른 타입의 값을 허용하는 트레이트 객체 사용하기</a></h2>
<p>8장에서 우리는 벡터의 한 가지 제한 사항이 오직 한 가지 타입의 요소만 저장할 수 있다는 점임을 언급했습니다. 목록 8-9에서 우리는 정수, 실수, 텍스트를 보유할 수 있는 변형들을 가진 <code>SpreadsheetCell</code> 열거형을 정의하여 우회 방법을 만들었습니다. 이는 각 셀에 서로 다른 타입의 데이터를 저장하면서도 셀의 한 행을 나타내는 벡터를 가질 수 있음을 의미했습니다. 이는 서로 교체 가능한 아이템들이 코드가 컴파일될 때 우리가 알고 있는 고정된 타입 세트인 경우에 완벽하게 좋은 해결책입니다.</p>
<p>하지만 때때로 우리는 라이브러리 사용자가 특정 상황에서 유효한 타입 세트를 확장할 수 있기를 원합니다. 이를 어떻게 달성할 수 있는지 보여주기 위해, 아이템 리스트를 순회하며 각 아이템의 <code>draw</code> 메서드를 호출하여 화면에 그리는 예제 GUI 도구를 만들 것입니다. 이는 GUI 도구에서 흔히 사용하는 기술입니다. 우리는 GUI 라이브러리의 구조를 담고 있는 <code>gui</code>라는 이름의 라이브러리 크레이트를 만들 것입니다. 이 크레이트에는 사용자들이 사용할 수 있는 <code>Button</code>이나 <code>TextField</code> 같은 타입들이 포함될 수 있습니다. 게다가 <code>gui</code> 사용자들은 화면에 그려질 수 있는 자신만의 타입을 만들고 싶어 할 것입니다. 예를 들어 어떤 프로그래머는 <code>Image</code>를 추가할 수 있고, 다른 프로그래머는 <code>SelectBox</code>를 추가할 수 있습니다.</p>
<p>We won’t implement a fully fledged GUI library for this example but will show how the pieces would fit together. At the time of writing the library, we can’t know and define all the types other programmers might want to create. But we do know that <code>gui</code> needs to keep track of many values of different types, and it needs to call a <code>draw</code> method on each of these differently typed values. It doesn’t need to know exactly what will happen when we call the <code>draw</code> method, just that the value will have that method available for us to call.</p>
<p>상속이 있는 언어에서 이를 수행하려면, <code>draw</code> 메서드를 가진 <code>Component</code>라는 클래스를 정의할 수 있습니다. <code>Button</code>, <code>Image</code>, <code>SelectBox</code> 같은 다른 클래스들은 <code>Component</code>를 상속받아 <code>draw</code> 메서드를 물려받게 됩니다. 각 클래스는 <code>draw</code> 메서드를 오버라이드하여 자신만의 커스텀 동작을 정의할 수 있고, 프레임워크는 모든 타입을 <code>Component</code> 인스턴스인 것처럼 취급하여 <code>draw</code>를 호출할 수 있습니다. 하지만 러스트에는 상속이 없으므로, 사용자들이 새로운 타입으로 확장할 수 있도록 <code>gui</code> 라이브러리를 구조화하는 다른 방법이 필요합니다.</p>
<h3 id="공통된-동작을-위한-트레이트-정의하기"><a class="header" href="#공통된-동작을-위한-트레이트-정의하기">공통된 동작을 위한 트레이트 정의하기</a></h3>
<p>우리가 <code>gui</code> 라이브러리에 바라는 동작을 구현하기 위해, <code>draw</code>라는 하나의 메서드를 가진 <code>Draw</code>라는 트레이트를 정의하겠습니다. 그런 다음 트레이트 객체를 담는 벡터를 정의할 수 있습니다. _트레이트 객체(trait object)_는 우리가 지정한 트레이트를 구현하는 타입의 인스턴스와, 런타임에 해당 타입의 트레이트 메서드를 찾기 위해 사용되는 테이블을 모두 가리킵니다. 트레이트 객체는 <code>&amp;</code> 참조나 <code>Box&lt;T&gt;</code> 스마트 포인터와 같은 포인터 종류를 명시하고, 그 뒤에 <code>dyn</code> 키워드와 관련 트레이트를 명시함으로써 생성합니다. (트레이트 객체가 반드시 포인터를 사용해야 하는 이유는 20장의 <a href="ch20-03-advanced-types.html#dynamically-sized-types-and-the-sized-trait">“동적 크기 타입과 <code>Sized</code> 트레이트”</a><!-- ignore -->에서 다룰 것입니다.) 우리는 제네릭이나 구체 타입 대신 트레이트 객체를 사용할 수 있습니다. 트레이트 객체를 사용하는 곳 어디에서나, 러스트의 타입 시스템은 해당 맥락에서 사용되는 모든 값이 트레이트 객체의 트레이트를 구현하도록 컴파일 타임에 보장합니다. 결과적으로 우리는 컴파일 타임에 모든 가능한 타입을 알 필요가 없습니다.</p>
<p>우리는 러스트의 구조체와 열거형을 다른 언어의 객체와 구별하기 위해 "객체"라고 부르는 것을 자제한다고 언급한 바 있습니다. 구조체나 열거형에서는 구조체 필드의 데이터와 <code>impl</code> 블록의 동작이 분리되어 있는 반면, 다른 언어에서는 데이터와 동작이 하나의 개념으로 결합된 것을 흔히 객체라고 부릅니다. 하지만 트레이트 객체는 데이터와 동작을 결합한다는 점에서 다른 언어의 객체와 더 <em>비슷합니다</em>. 하지만 트레이트 객체는 우리가 트레이트 객체에 데이터를 추가할 수 없다는 점에서 전통적인 객체와 다릅니다. 트레이트 객체는 다른 언어의 객체만큼 일반적으로 유용하지는 않습니다. 그것들의 특수한 목적은 공통된 동작에 대한 추상화를 허용하는 것입니다.</p>
<p>목록 18-3은 <code>draw</code>라는 하나의 메서드를 가진 <code>Draw</code>라는 이름의 트레이트를 정의하는 방법을 보여줍니다.</p>
<Listing number="18-3" file-name="src/lib.rs" caption="Definition of the `Draw` trait">
<pre><code class="language-rust noplayground">pub trait Draw {
    fn draw(&amp;self);
}</code></pre>
</Listing>
<p>이 문법은 10장에서 트레이트를 정의하는 방법을 논의했을 때 보았던 것과 익숙할 것입니다. 다음으로 새로운 문법이 나옵니다. 목록 18-4는 <code>components</code>라는 이름의 벡터를 가진 <code>Screen</code>이라는 구조체를 정의합니다. 이 벡터는 <code>Box&lt;dyn Draw&gt;</code> 타입인데, 이것이 바로 트레이트 객체입니다. 이는 <code>Draw</code> 트레이트를 구현하는 <code>Box</code> 내부의 모든 타입에 대한 대역입니다.</p>
<Listing number="18-4" file-name="src/lib.rs" caption="Definition of the `Screen` struct with a `components` field holding a vector of trait objects that implement the `Draw` trait">
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen {
    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
}</code></pre>
</Listing>
<p>목록 18-5에 나타난 것처럼, <code>Screen</code> 구조체에 각 <code>components</code>의 <code>draw</code> 메서드를 호출하는 <code>run</code> 메서드를 정의하겠습니다.</p>
<Listing number="18-5" file-name="src/lib.rs" caption="A `run` method on `Screen` that calls the `draw` method on each component">
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Screen {
</span><span class="boring">    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Screen {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}</code></pre>
</Listing>
<p>이는 트레이트 바운드가 있는 제네릭 타입 매개변수를 사용하는 구조체를 정의하는 것과는 다르게 작동합니다. 제네릭 타입 매개변수는 한 번에 하나의 구체 타입으로만 대체될 수 있는 반면, 트레이트 객체는 런타임에 여러 구체 타입이 트레이트 객체 자리를 채우는 것을 허용합니다. 예를 들어, 목록 18-6과 같이 제네릭 타입과 트레이트 바운드를 사용하여 <code>Screen</code> 구조체를 정의할 수도 있었을 것입니다.</p>
<Listing number="18-6" file-name="src/lib.rs" caption="An alternate implementation of the `Screen` struct and its `run` method using generics and trait bounds">
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen&lt;T: Draw&gt; {
    pub components: Vec&lt;T&gt;,
}

impl&lt;T&gt; Screen&lt;T&gt;
where
    T: Draw,
{
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}</code></pre>
</Listing>
<p>이렇게 하면 컴포넌트 리스트가 모두 <code>Button</code> 타입이거나 모두 <code>TextField</code> 타입인 <code>Screen</code> 인스턴스로 제한됩니다. 만약 항상 동일한 타입의 컬렉션만 가진다면, 정의가 컴파일 타임에 구체 타입을 사용하도록 단일화(monomorphized)되기 때문에 제네릭과 트레이트 바운드를 사용하는 것이 바람직합니다.</p>
<p>반면에 트레이트 객체를 사용하는 방식을 쓰면, 하나의 <code>Screen</code> 인스턴스가 <code>Box&lt;Button&gt;</code>과 <code>Box&lt;TextField&gt;</code>를 모두 포함하는 <code>Vec&lt;T&gt;</code>를 가질 수 있습니다. 이것이 어떻게 작동하는지 살펴보고, 이어서 런타임 성능에 미치는 영향에 대해 이야기해 보겠습니다.</p>
<h3 id="트레이트-구현하기"><a class="header" href="#트레이트-구현하기">트레이트 구현하기</a></h3>
<p>Now we’ll add some types that implement the <code>Draw</code> trait. We’ll provide the <code>Button</code> type. Again, actually implementing a GUI library is beyond the scope of this book, so the <code>draw</code> method won’t have any useful implementation in its body. To imagine what the implementation might look like, a <code>Button</code> struct might have fields for <code>width</code>, <code>height</code>, and <code>label</code>, as shown in Listing 18-7:</p>
<Listing number="18-7" file-name="src/lib.rs" caption="A `Button` struct that implements the `Draw` trait">
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Screen {
</span><span class="boring">    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Screen {
</span><span class="boring">    pub fn run(&amp;self) {
</span><span class="boring">        for component in self.components.iter() {
</span><span class="boring">            component.draw();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&amp;self) {
        // 버튼을 실제로 그리는 코드
    }
}</code></pre>
</Listing>
<p>사용자가 버튼을 클릭했을 때 일어나는 일들과 관련이 있습니다. 이러한 종류의 메서드들은 <code>TextField</code>와 같은 타입에는 적용되지 않을 것입니다.</p>
<p>우리 라이브러리를 사용하는 누군가가 <code>width</code>, <code>height</code>, <code>options</code> 필드를 가진 <code>SelectBox</code> 구조체를 구현하기로 했다면, 목록 18-8에 나타난 것처럼 <code>SelectBox</code> 타입에 대해서도 <code>Draw</code> 트레이트를 구현합니다.</p>
<Listing number="18-8" file-name="src/main.rs" caption="Another crate using `gui` and implementing the `Draw` trait on a `SelectBox` struct">
<pre><code class="language-rust ignore">use gui::Draw;

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec&lt;String&gt;,
}

impl Draw for SelectBox {
    fn draw(&amp;self) {
        // 셀렉트 박스를 실제로 그리는 코드
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
</Listing>
<p>이제 라이브러리 사용자는 <code>main</code> 함수를 작성하여 <code>Screen</code> 인스턴스를 생성할 수 있습니다. <code>Screen</code> 인스턴스에 <code>SelectBox</code>와 <code>Button</code>을 각각 <code>Box&lt;T&gt;</code>에 넣어 트레이트 객체로 만듦으로써 추가할 수 있습니다. 그런 다음 <code>Screen</code> 인스턴스의 <code>run</code> 메서드를 호출하면 각 컴포넌트의 <code>draw</code>를 호출할 것입니다. 목록 18-9에 이 구현이 나와 있습니다.</p>
<Listing number="18-9" file-name="src/main.rs" caption="Using trait objects to store values of different types that implement the same trait">
<pre><code class="language-rust ignore"><span class="boring">use gui::Draw;
</span><span class="boring">
</span><span class="boring">struct SelectBox {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">    options: Vec&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Draw for SelectBox {
</span><span class="boring">    fn draw(&amp;self) {
</span><span class="boring">        // 셀렉트 박스를 실제로 그리는 코드
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>use gui::{Button, Screen};

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from("예"),
                    String::from("글쎄요"),
                    String::from("아니요"),
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from("확인"),
            }),
        ],
    };

    screen.run();
}</code></pre>
</Listing>
<p>우리가 라이브러리를 작성할 때는 누군가가 <code>SelectBox</code> 타입을 추가할지 몰랐지만, 우리의 <code>Screen</code> 구현은 새로운 타입에 대해 작동하고 이를 그릴 수 있었습니다. <code>SelectBox</code>가 <code>Draw</code> 트레이트를 구현하고 있고, 이는 곧 <code>draw</code> 메서드를 구현하고 있음을 의미하기 때문입니다.</p>
<p>값의 구체적인 타입보다는 해당 값이 어떤 메시지에 응답하는지에만 관심을 갖는 이 개념은 동적 타입 언어의 <em>덕 타이핑(duck typing)</em> 개념과 유사합니다. 만약 어떤 것이 오리처럼 걷고 오리처럼 꽥꽥거린다면, 그것은 오리임에 틀림없다는 것이죠! 목록 18-5의 <code>Screen</code>에 구현된 <code>run</code> 메서드는 각 컴포넌트의 구체적인 타입이 무엇인지 알 필요가 없습니다. 컴포넌트가 <code>Button</code>의 인스턴스인지 <code>SelectBox</code>의 인스턴스인지 확인하지 않고, 그저 컴포넌트의 <code>draw</code> 메서드를 호출할 뿐입니다. <code>components</code> 벡터의 값 타입을 <code>Box&lt;dyn Draw&gt;</code>로 지정함으로써, 우리는 <code>Screen</code>이 <code>draw</code> 메서드를 호출할 수 있는 값들을 필요로 한다고 정의한 것입니다.</p>
<p>덕 타이핑을 사용하는 코드와 유사하게 작성하면서도 트레이트 객체와 러스트의 타입 시스템을 사용하는 것의 장점은, 런타임에 어떤 값이 특정 메서드를 구현하는지 확인할 필요가 없으며, 메서드를 구현하지 않은 값을 호출했을 때 발생할 에러를 걱정할 필요가 없다는 점입니다. 만약 값이 트레이트 객체가 요구하는 트레이트를 구현하지 않는다면 러스트는 코드를 컴파일하지 않을 것입니다.</p>
<p>예를 들어, 목록 18-10은 컴포넌트로 <code>String</code>을 넣어 <code>Screen</code>을 생성하려고 시도했을 때 어떤 일이 벌어지는지 보여줍니다.</p>
<Listing number="18-10" file-name="src/main.rs" caption="Attempting to use a type that doesn’t implement the trait object’s trait">
<pre><code class="language-rust ignore does_not_compile">use gui::Screen;

fn main() {
    let screen = Screen {
        components: vec![Box::new(String::from("안녕"))],
    };

    screen.run();
}</code></pre>
</Listing>
<p><code>String</code>은 <code>Draw</code> 트레이트를 구현하지 않으므로 다음과 같은 에러가 발생합니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling gui v0.1.0 (file:///projects/gui)
error[E0277]: the trait bound `String: Draw` is not satisfied
 --&gt; src/main.rs:5:26
  |
5 |         components: vec![Box::new(String::from("Hi"))],
  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`에 대해 `Draw` 트레이트가 구현되지 않았습니다
  |
  = help: `Button`에 대해 `Draw` 트레이트가 구현되어 있습니다
  = note: `Box&lt;String&gt;`에서 `Box&lt;dyn Draw&gt;`로의 캐스트를 위해 요구됩니다

이 에러에 대한 더 자세한 정보를 원하시면 `rustc --explain E0277`을 시도해 보세요.
에러: 1개의 이전 에러로 인해 `gui` (바이너리 "gui")를 컴파일할 수 없습니다
</code></pre>
<p>이 에러는 우리가 의도하지 않은 것을 <code>Screen</code>에 전달했으므로 다른 타입을 전달해야 하거나, <code>Screen</code>이 <code>draw</code>를 호출할 수 있도록 <code>String</code>에 <code>Draw</code>를 구현해야 함을 알려줍니다.</p>
<h3 id="트레이트-객체는-동적-디스패치를-수행한다"><a class="header" href="#트레이트-객체는-동적-디스패치를-수행한다">트레이트 객체는 동적 디스패치를 수행한다</a></h3>
<p>10장의 <a href="ch10-01-syntax.html#performance-of-code-using-generics">“제네릭을 사용한 코드의 성능”</a><!-- ignore -->에서 컴파일러가 제네릭에 대해 수행하는 단일화(monomorphization) 과정에 대해 논의했던 것을 상기해 보세요. 컴파일러는 제네릭 타입 매개변수 대신 우리가 사용하는 각 구체 타입에 대해 함수와 메서드의 비제네릭 구현을 생성합니다. 단일화의 결과로 생성된 코드는 _정적 디스패치(static dispatch)_를 수행하는데, 이는 컴파일러가 컴파일 타임에 여러분이 어떤 메서드를 호출하는지 알고 있음을 의미합니다. 이와 반대되는 개념은 _동적 디스패치(dynamic dispatch)_로, 컴파일러가 컴파일 타임에 어떤 메서드가 호출될지 알 수 없는 경우입니다. 동적 디스패치의 경우, 컴파일러는 런타임에 어떤 메서드를 호출할지 결정하는 코드를 생성합니다.</p>
<p>트레이트 객체를 사용할 때 러스트는 반드시 동적 디스패치를 사용해야 합니다. 컴파일러는 트레이트 객체를 사용하는 코드와 함께 어떤 타입들이 사용될지 모두 알지 못하므로, 어떤 타입에 구현된 어떤 메서드를 호출해야 할지 알 수 없습니다. 대신 런타임에 러스트는 트레이트 객체 내부의 포인터를 사용하여 어떤 메서드를 호출할지 파악합니다. 이러한 조회 과정은 정적 디스패치에서는 발생하지 않는 런타임 비용을 발생시킵니다. 또한 동적 디스패치는 컴파일러가 메서드 코드를 인라인(inline)화하는 것을 방해하여 일부 최적화를 수행하지 못하게 하며, 러스트에는 동적 디스패치를 사용할 수 있는 곳과 없는 곳에 대한 <a href="https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility"><em>dyn 호환성(dyn compatibility)</em></a>이라는 몇 가지 규칙이 있습니다. 하지만 우리는 목록 18-5에서 작성하고 목록 18-9에서 지원할 수 있었던 코드에서 추가적인 유연성을 얻었으므로, 이는 고려해 볼 만한 트레이드오프입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="객체-지향-디자인-패턴-구현하기"><a class="header" href="#객체-지향-디자인-패턴-구현하기">객체 지향 디자인 패턴 구현하기</a></h2>
<p>_상태 패턴(state pattern)_은 객체 지향 디자인 패턴입니다. 이 패턴의 핵심은 값이 내부적으로 가질 수 있는 일련의 상태들을 정의하는 것입니다. 각 상태는 일련의 _상태 객체들_로 표현되며, 값의 동작은 자신의 상태에 따라 달라집니다. 우리는 자신의 상태를 보유할 필드를 가진 블로그 포스트 구조체의 예제를 통해 살펴볼 것입니다. 이때 상태는 "초안(draft)", "리뷰(review)", "게시됨(published)" 상태 세트 중 하나의 상태 객체가 될 것입니다.</p>
<p>상태 객체들은 기능을 공유합니다. 물론 러스트에서는 객체와 상속 대신 구조체와 트레이트를 사용합니다. 각 상태 객체는 자신의 동작과 다른 상태로 언제 전환되어야 하는지를 관리할 책임이 있습니다. 상태 객체를 보유한 값은 상태들의 서로 다른 동작이나 상태 간의 전환 시점에 대해 전혀 알지 못합니다.</p>
<p>상태 패턴을 사용하는 것의 장점은 프로그램의 비즈니스 요구사항이 변경될 때, 상태를 보유한 값의 코드나 그 값을 사용하는 코드를 변경할 필요가 없다는 것입니다. 단지 상태 객체 중 하나의 내부 코드를 업데이트하여 규칙을 변경하거나, 새로운 상태 객체를 추가하기만 하면 됩니다.</p>
<p>먼저 보다 전통적인 객체 지향 방식으로 상태 패턴을 구현해 보고, 그런 다음 러스트에 좀 더 자연스러운 방식을 사용해 보겠습니다. 상태 패턴을 사용하여 블로그 포스트 워크플로우를 점진적으로 구현해 봅시다.</p>
<p>최종 기능은 다음과 같은 모습이 될 것입니다.</p>
<ol>
<li>블로그 포스트는 빈 초안으로 시작합니다.</li>
<li>초안 작성이 완료되면, 포스트에 대한 리뷰가 요청됩니다.</li>
<li>포스트가 승인되면, 게시됩니다.</li>
<li>게시된 블로그 포스트만 출력할 내용을 반환하므로, 승인되지 않은 포스트가 실수로 게시되는 일을 방지할 수 있습니다.</li>
</ol>
<p>포스트에 시도된 다른 모든 변경 사항은 아무런 효과가 없어야 합니다. 예를 들어, 리뷰를 요청하기 전에 초안 블로그 포스트를 승인하려고 시도하면, 포스트는 게시되지 않은 초안 상태로 남아 있어야 합니다.</p>
<p>목록 18-11은 이 워크플로우를 코드 형태로 보여줍니다. 이는 우리가 <code>blog</code>라는 이름의 라이브러리 크레이트에서 구현할 API의 사용 예시입니다. <code>blog</code> 크레이트를 아직 구현하지 않았으므로 이 코드는 아직 컴파일되지 않습니다.</p>
<Listing number="18-11" file-name="src/main.rs" caption="Code that demonstrates the desired behavior we want our `blog` crate to have">
<pre><code class="language-rust ignore does_not_compile">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("나는 오늘 점심으로 샐러드를 먹었다");
    assert_eq!("", post.content());

    post.request_review();
    assert_eq!("", post.content());

    post.approve();
    assert_eq!("나는 오늘 점심으로 샐러드를 먹었다", post.content());
}</code></pre>
</Listing>
<p>우리는 사용자가 <code>Post::new</code>로 새로운 초안 블로그 포스트를 생성할 수 있게 하고자 합니다. 또한 블로그 포스트에 텍스트를 추가할 수 있게 하고 싶습니다. 만약 승인되기 전인 초안 상태에서 즉시 포스트의 내용을 가져오려고 시도한다면, 어떤 텍스트도 얻지 못해야 합니다. 설명을 돕기 위해 코드에 <code>assert_eq!</code>를 추가했습니다. 이에 대한 훌륭한 유닛 테스트는 초안 블로그 포스트의 <code>content</code> 메서드가 빈 문자열을 반환하는지 확인하는 것이겠지만, 이 예제에서는 테스트를 작성하지 않겠습니다.</p>
<p>다음으로, 포스트에 대한 리뷰 요청을 가능하게 하고 싶으며, 리뷰를 기다리는 동안에도 <code>content</code>가 빈 문자열을 반환하게 하고 싶습니다. 포스트가 승인을 받으면 게시되어야 하며, 이는 <code>content</code>가 호출될 때 포스트의 텍스트가 반환됨을 의미합니다.</p>
<p>우리가 이 크레이트에서 상호작용하는 유일한 타입이 <code>Post</code> 타입이라는 점에 주목하세요. 이 타입은 상태 패턴을 사용하며, 포스트가 가질 수 있는 세 가지 상태(초안, 리뷰 대기 중, 게시됨) 중 하나를 나타내는 상태 객체를 값으로 보유합니다. 한 상태에서 다른 상태로의 전환은 <code>Post</code> 타입 내부에서 관리됩니다. 상태는 라이브러리 사용자가 <code>Post</code> 인스턴스에 대해 호출하는 메서드에 응답하여 변경되지만, 사용자가 직접 상태 변경을 관리할 필요는 없습니다. 또한 사용자는 리뷰 전에 포스트를 게시하는 것과 같이 상태와 관련된 실수를 할 수 없습니다.</p>
<h3 id="post-정의-및-초안-상태의-새-인스턴스-생성하기"><a class="header" href="#post-정의-및-초안-상태의-새-인스턴스-생성하기"><code>Post</code> 정의 및 초안 상태의 새 인스턴스 생성하기</a></h3>
<p>라이브러리 구현을 시작해 봅시다! 우리는 내용을 담을 공개된 <code>Post</code> 구조체가 필요하다는 것을 알고 있으므로, 목록 18-12에 나타난 것처럼 구조체의 정의와 <code>Post</code> 인스턴스를 생성하는 연관된 공개 <code>new</code> 함수로 시작합니다. 또한 <code>Post</code>를 위한 모든 상태 객체가 가져야 할 동작을 정의하는 비공개 <code>State</code> 트레이트를 만들 것입니다.</p>
<p>그런 다음 <code>Post</code>는 상태 객체를 보유하기 위해 <code>state</code>라는 이름의 비공개 필드에 <code>Option&lt;T&gt;</code>로 감싸진 <code>Box&lt;dyn State&gt;</code> 트레이트 객체를 보유하게 됩니다. 왜 <code>Option&lt;T&gt;</code>가 필요한지는 잠시 후에 보게 될 것입니다.</p>
<Listing number="18-12" file-name="src/lib.rs" caption="Definition of a `Post` struct and a `new` function that creates a new `Post` instance, a `State` trait, and a `Draft` struct">
<pre><code class="language-rust noplayground">pub struct Post {
    state: Option&lt;Box&lt;dyn State&gt;&gt;,
    content: String,
}

impl Post {
    pub fn new() -&gt; Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}</code></pre>
</Listing>
<p><code>State</code> 트레이트는 서로 다른 포스트 상태들이 공유하는 동작을 정의합니다. 상태 객체들은 <code>Draft</code>, <code>PendingReview</code>, <code>Published</code>이며, 이들은 모두 <code>State</code> 트레이트를 구현할 것입니다. 현재로서는 이 트레이트에 메서드가 없으며, 포스트가 시작되어야 할 상태인 <code>Draft</code> 상태부터 정의하며 시작해 보겠습니다.</p>
<p>새로운 <code>Post</code>를 생성할 때, 우리는 <code>state</code> 필드를 <code>Box</code>를 담고 있는 <code>Some</code> 값으로 설정합니다. 이 <code>Box</code>는 <code>Draft</code> 구조체의 새로운 인스턴스를 가리킵니다. 이를 통해 <code>Post</code> 인스턴스를 생성할 때마다 항상 초안으로 시작함을 보장합니다. <code>Post</code>의 <code>state</code> 필드는 비공개이므로, 다른 상태로 <code>Post</code>를 생성할 방법이 없습니다! <code>Post::new</code> 함수에서 우리는 <code>content</code> 필드를 새롭고 비어 있는 <code>String</code>으로 설정합니다.</p>
<h3 id="포스트-내용의-텍스트-저장하기"><a class="header" href="#포스트-내용의-텍스트-저장하기">포스트 내용의 텍스트 저장하기</a></h3>
<p>우리는 목록 18-11에서 <code>add_text</code>라는 메서드를 호출하고 <code>&amp;str</code>을 전달하여 블로그 포스트의 텍스트 내용으로 추가되기를 원한다는 것을 보았습니다. 우리는 <code>content</code> 필드를 <code>pub</code>으로 노출하는 대신 메서드로 구현했는데, 이는 나중에 <code>content</code> 필드의 데이터가 읽히는 방식을 제어하는 메서드를 구현할 수 있도록 하기 위해서입니다. <code>add_text</code> 메서드는 매우 단순하므로, 목록 18-13의 구현을 <code>impl Post</code> 블록에 추가해 봅시다.</p>
<Listing number="18-13" file-name="src/lib.rs" caption="Implementing the `add_text` method to add text to a post’s `content`">
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --생략--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}</span></code></pre>
</Listing>
<p><code>add_text</code> 메서드는 호출 대상인 <code>Post</code> 인스턴스를 변경해야 하므로 <code>self</code>에 대한 가변 참조를 받습니다. 그런 다음 <code>content</code> 필드의 <code>String</code>에 대해 <code>push_str</code>을 호출하고 <code>text</code> 인수를 전달하여 저장된 내용에 추가합니다. 이 동작은 포스트의 현재 상태에 의존하지 않으므로 상태 패턴의 일부는 아닙니다. <code>add_text</code> 메서드는 <code>state</code> 필드와 전혀 상호작용하지 않지만, 우리가 지원하고자 하는 동작의 일부입니다.</p>
<h3 id="초안-포스트의-내용이-비어-있음을-보장하기"><a class="header" href="#초안-포스트의-내용이-비어-있음을-보장하기">초안 포스트의 내용이 비어 있음을 보장하기</a></h3>
<p><code>add_text</code>를 호출하여 포스트에 내용을 추가한 후에도, 목록 18-11의 7번 라인에 나타난 것처럼 포스트가 여전히 초안 상태라면 <code>content</code> 메서드가 빈 문자열 슬라이스를 반환하기를 원합니다. 지금은 이 요구사항을 충족하는 가장 간단한 방법으로 <code>content</code> 메서드를 구현해 봅시다. 즉, 항상 빈 문자열 슬라이스를 반환하는 것입니다. 나중에 포스트 상태를 변경하여 게시할 수 있는 기능을 구현하면 이를 수정할 것입니다. 현재까지 포스트는 초안 상태만 가질 수 있으므로, 포스트 내용은 항상 비어 있어야 합니다. 목록 18-14는 이 임시 구현을 보여줍니다.</p>
<Listing number="18-14" file-name="src/lib.rs" caption="Adding a placeholder implementation for the `content` method on `Post` that always returns an empty string slice">
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --생략--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        ""
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}</span></code></pre>
</Listing>
<p>이 <code>content</code> 메서드를 추가함으로써, 목록 18-11의 7번 라인까지의 모든 코드가 의도한 대로 작동합니다.</p>
<h3 id="포스트의-리뷰를-요청하면-상태가-변경된다"><a class="header" href="#포스트의-리뷰를-요청하면-상태가-변경된다">포스트의 리뷰를 요청하면 상태가 변경된다</a></h3>
<p>다음으로, 포스트의 리뷰를 요청하는 기능을 추가해야 하며, 이는 포스트의 상태를 <code>Draft</code>에서 <code>PendingReview</code>로 변경해야 합니다. 목록 18-15는 이 코드를 보여줍니다.</p>
<Listing number="18-15" file-name="src/lib.rs" caption="Implementing `request_review` methods on `Post` and the `State` trait">
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --생략--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        ""
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}</code></pre>
</Listing>
<p>우리는 <code>Post</code>에 <code>self</code>에 대한 가변 참조를 받는 공개 메서드 <code>request_review</code>를 추가합니다. 그런 다음 <code>Post</code>의 현재 상태에 대해 내부적인 <code>request_review</code> 메서드를 호출하며, 이 두 번째 <code>request_review</code> 메서드는 현재 상태를 소비하고 새로운 상태를 반환합니다.</p>
<p>우리는 <code>State</code> 트레이트에 <code>request_review</code> 메서드를 추가합니다. 이제 이 트레이트를 구현하는 모든 타입은 <code>request_review</code> 메서드를 구현해야 합니다. 메서드의 첫 번째 매개변수로 <code>self</code>, <code>&amp;self</code>, 또는 <code>&amp;mut self</code>를 사용하는 대신 <code>self: Box&lt;Self&gt;</code>를 사용했다는 점에 주목하세요. 이 문법은 해당 타입을 담고 있는 <code>Box</code>에 대해 호출될 때만 메서드가 유효함을 의미합니다. 이 문법은 <code>Box&lt;Self&gt;</code>의 소유권을 가져와서 이전 상태를 무효화함으로써, <code>Post</code>의 상태 값이 새로운 상태로 변환될 수 있게 합니다.</p>
<p>이전 상태를 소비하기 위해, <code>request_review</code> 메서드는 상태 값의 소유권을 가져와야 합니다. 여기서 <code>Post</code> 구조체의 <code>state</code> 필드에 있는 <code>Option</code>이 역할을 합니다. 우리는 <code>take</code> 메서드를 호출하여 <code>state</code> 필드에서 <code>Some</code> 값을 꺼내고 그 자리에 <code>None</code>을 남깁니다. 러스트는 구조체에 비어 있는 필드를 허용하지 않기 때문입니다. 이를 통해 우리는 <code>state</code> 값을 대여하는 대신 <code>Post</code> 밖으로 이동시킬 수 있습니다. 그런 다음 포스트의 <code>state</code> 값을 이 작업의 결과로 설정할 것입니다.</p>
<p>우리는 <code>state</code> 값의 소유권을 얻기 위해, <code>self.state = self.state.request_review();</code>와 같은 코드로 직접 설정하는 대신 일시적으로 <code>state</code>를 <code>None</code>으로 설정해야 합니다. 이는 우리가 새로운 상태로 변환한 후에 <code>Post</code>가 이전 <code>state</code> 값을 사용할 수 없도록 보장합니다.</p>
<p><code>Draft</code>에서의 <code>request_review</code> 메서드는 새로운 <code>PendingReview</code> 구조체의 박스형 인스턴스를 반환합니다. 이는 포스트가 리뷰를 기다리고 있는 상태를 나타냅니다. <code>PendingReview</code> 구조체 역시 <code>request_review</code> 메서드를 구현하지만, 어떤 변환도 수행하지 않습니다. 대신 자기 자신을 반환하는데, 이미 <code>PendingReview</code> 상태인 포스트에 대해 리뷰를 요청할 경우 계속 <code>PendingReview</code> 상태로 유지되어야 하기 때문입니다.</p>
<p>이제 상태 패턴의 장점들이 보이기 시작합니다. <code>Post</code>의 <code>request_review</code> 메서드는 <code>state</code> 값에 상관없이 동일합니다. 각 상태가 자신만의 규칙을 책임집니다.</p>
<p><code>Post</code>의 <code>content</code> 메서드는 그대로 두어 빈 문자열 슬라이스를 반환하게 합니다. 이제 우리는 <code>Draft</code> 상태뿐만 아니라 <code>PendingReview</code> 상태의 <code>Post</code>도 가질 수 있게 되었지만, <code>PendingReview</code> 상태에서도 동일한 동작을 원합니다. 이제 목록 18-11의 10번 라인까지 코드가 작동합니다!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="adding-the-approve-method-that-changes-the-behavior-of-content"></a></p>
<h3 id="content의-동작을-변경하기-위해-approve-추가하기"><a class="header" href="#content의-동작을-변경하기-위해-approve-추가하기"><code>content</code>의 동작을 변경하기 위해 <code>approve</code> 추가하기</a></h3>
<p><code>approve</code> 메서드는 <code>request_review</code> 메서드와 유사할 것입니다. 목록 18-16에 나타난 것처럼, 현재 상태가 승인되었을 때 가져야 할 값으로 <code>state</code>를 설정합니다.</p>
<Listing number="18-16" file-name="src/lib.rs" caption="Implementing the `approve` method on `Post` and the `State` trait">
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --생략--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        ""
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn approve(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    // --생략--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
    // --생략--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }

    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}</code></pre>
</Listing>
<p>우리는 <code>State</code> 트레이트에 <code>approve</code> 메서드를 추가하고, <code>State</code>를 구현하는 새로운 구조체인 <code>Published</code> 상태를 추가합니다.</p>
<p><code>PendingReview</code>에서의 <code>request_review</code> 작동 방식과 유사하게, 만약 <code>Draft</code>에서 <code>approve</code> 메서드를 호출하면 <code>approve</code>가 <code>self</code>를 반환하므로 아무런 효과가 없습니다. <code>PendingReview</code>에서 <code>approve</code>를 호출하면 <code>Published</code> 구조체의 새로운 박스형 인스턴스를 반환합니다. <code>Published</code> 구조체는 <code>State</code> 트레이트를 구현하며, <code>request_review</code> 메서드와 <code>approve</code> 메서드 모두에서 자기 자신을 반환합니다. 이 경우 포스트가 <code>Published</code> 상태로 유지되어야 하기 때문입니다.</p>
<p>이제 <code>Post</code>의 <code>content</code> 메서드를 업데이트해야 합니다. 우리는 <code>content</code>로부터 반환되는 값이 <code>Post</code>의 현재 상태에 따라 달라지기를 원하므로, 목록 18-17에 나타난 것처럼 <code>Post</code>가 자신의 <code>state</code>에 정의된 <code>content</code> 메서드에 위임하도록 할 것입니다.</p>
<Listing number="18-17" file-name="src/lib.rs" caption="Updating the `content` method on `Post` to delegate to a `content` method on `State`">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --생략--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        self.state.as_ref().unwrap().content(self)
    }
    // --생략--
<span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">trait State {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Published {}
</span><span class="boring">
</span><span class="boring">impl State for Published {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>모든 규칙을 <code>State</code>를 구현하는 구조체들 내부에 유지하는 것이 목표이므로, <code>state</code>에 있는 값에 대해 <code>content</code> 메서드를 호출하고 포스트 인스턴스(즉, <code>self</code>)를 인수로 전달합니다. 그런 다음 <code>state</code> 값의 <code>content</code> 메서드를 사용하여 반환된 값을 반환합니다.</p>
<p>우리는 값의 소유권보다는 <code>Option</code> 내부의 값에 대한 참조를 원하므로 <code>Option</code>에 대해 <code>as_ref</code> 메서드를 호출합니다. <code>state</code>가 <code>Option&lt;Box&lt;dyn State&gt;&gt;</code>이므로, <code>as_ref</code>를 호출하면 <code>Option&lt;&amp;Box&lt;dyn State&gt;&gt;</code>가 반환됩니다. 만약 <code>as_ref</code>를 호출하지 않는다면, 함수 매개변수인 대여된 <code>&amp;self</code>로부터 <code>state</code>를 밖으로 이동시킬 수 없기 때문에 에러가 발생할 것입니다.</p>
<p>그런 다음 <code>unwrap</code> 메서드를 호출합니다. 우리는 <code>Post</code>의 메서드들이 완료될 때 <code>state</code>가 항상 <code>Some</code> 값을 포함하도록 보장한다는 것을 알고 있으므로, 이 호출이 결코 패닉을 일으키지 않을 것임을 압니다. 이는 9장의 <a href="ch09-03-to-panic-or-not-to-panic.html#cases-in-which-you-have-more-information-than-the-compiler">“컴파일러보다 여러분이 더 많은 정보를 가지고 있는 경우”</a><!-- ignore --> 섹션에서 이야기했던 사례 중 하나로, 컴파일러는 이해하지 못하더라도 우리는 <code>None</code> 값이 결코 불가능함을 알고 있는 경우입니다.</p>
<p>이 시점에서 <code>&amp;Box&lt;dyn State&gt;</code>에 대해 <code>content</code>를 호출하면, <code>&amp;</code>와 <code>Box</code>에 역참조 강제(deref coercion)가 적용되어 결국 <code>State</code> 트레이트를 구현하는 타입에 대해 <code>content</code> 메서드가 호출됩니다. 이는 <code>State</code> 트레이트 정의에 <code>content</code>를 추가해야 함을 의미하며, 목록 18-18에 나타난 것처럼 우리가 어떤 상태에 있는지에 따라 어떤 내용을 반환할지에 대한 로직을 그곳에 둘 것입니다.</p>
<Listing number="18-18" file-name="src/lib.rs" caption="Adding the `content` method to the `State` trait">
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        self.state.as_ref().unwrap().content(self)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>trait State {
    // --생략--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        ""
    }
}

// --생략--
<span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Published {}

impl State for Published {
    // --생략--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &amp;post.content
    }
}</code></pre>
</Listing>
<p>우리는 빈 문자열 슬라이스를 반환하는 <code>content</code> 메서드의 기본 구현을 추가합니다. 이는 <code>Draft</code>와 <code>PendingReview</code> 구조체에서 <code>content</code>를 구현할 필요가 없음을 의미합니다. <code>Published</code> 구조체는 <code>content</code> 메서드를 오버라이드하여 <code>post.content</code>에 있는 값을 반환할 것입니다.</p>
<p>10장에서 논의했던 것처럼, 이 메서드에는 라이프타임 어노테이션이 필요하다는 점에 유의하세요. 우리는 <code>post</code>에 대한 참조를 인수로 받고 해당 <code>post</code>의 일부에 대한 참조를 반환하므로, 반환되는 참조의 라이프타임은 <code>post</code> 인수의 라이프타임과 관련이 있습니다.</p>
<p>이제 다 되었습니다—목록 18-11의 모든 코드가 정상 작동합니다! 우리는 블로그 포스트 워크플로우의 규칙들을 사용하여 상태 패턴을 구현했습니다. 규칙과 관련된 로직은 <code>Post</code> 전체에 흩어져 있는 대신 상태 객체들 내부에 위치하게 됩니다.</p>
<blockquote>
<h4 id="왜-열거형은-사용하지-않았나요"><a class="header" href="#왜-열거형은-사용하지-않았나요">왜 열거형은 사용하지 않았나요?</a></h4>
<p>가능한 포스트 상태들을 변형(variant)으로 가지는 <code>enum</code>을 왜 사용하지 않았는지 궁금할 수 있습니다. 그것도 분명 가능한 해결책이니, 직접 시도해 보고 결과물을 비교하여 어떤 방식이 더 마음에 드는지 확인해 보세요! 열거형을 사용할 때의 한 가지 단점은, 열거형 값을 확인하는 모든 곳에서 모든 가능한 변형을 처리하기 위해 <code>match</code> 표현식이나 그와 유사한 구문이 필요하다는 점입니다. 이는 이번 트레이트 객체 해결책보다 더 반복적인 작업이 될 수 있습니다.</p>
</blockquote>
<h3 id="상태-패턴의-트레이드오프"><a class="header" href="#상태-패턴의-트레이드오프">상태 패턴의 트레이드오프</a></h3>
<p>우리는 러스트가 포스트가 각 상태에서 가져야 할 서로 다른 동작들을 캡슐화하기 위해 객체 지향 상태 패턴을 구현할 수 있음을 보여주었습니다. <code>Post</code>의 메서드들은 다양한 동작들에 대해 아무것도 알지 못합니다. 우리가 코드를 구성한 방식에 따르면, 게시된 포스트가 어떻게 동작하는지 알기 위해 오직 한 곳만 확인하면 됩니다. 바로 <code>Published</code> 구조체에 구현된 <code>State</code> 트레이트입니다.</p>
<p>상태 패턴을 사용하지 않는 대안적인 구현을 만든다면, 대신 <code>Post</code>의 메서드들이나 심지어 <code>main</code> 코드에서 포스트의 상태를 확인하고 그에 따라 동작을 변경하는 <code>match</code> 표현식들을 사용했을 것입니다. 이는 포스트가 게시됨 상태일 때의 모든 영향을 이해하기 위해 여러 곳을 찾아봐야 함을 의미합니다! 상태를 더 추가할수록 이런 부담은 늘어날 뿐입니다. 각 <code>match</code> 표현식마다 새로운 가지(arm)를 추가해야 할 테니까요.</p>
<p>상태 패턴을 사용하면, <code>Post</code> 메서드들과 <code>Post</code>를 사용하는 곳에서 <code>match</code> 표현식이 필요하지 않으며, 새로운 상태를 추가하려면 그저 새로운 구조체를 추가하고 그 구조체에 트레이트 메서드들을 구현하기만 하면 됩니다.</p>
<p>상태 패턴을 사용한 구현은 기능을 더 추가하기 위해 확장하기 쉽습니다. 상태 패턴을 사용하는 코드의 유지보수 편의성을 확인해 보려면, 다음의 제안 사항들을 몇 가지 시도해 보세요.</p>
<ul>
<li>포스트의 상태를 <code>PendingReview</code>에서 다시 <code>Draft</code>로 되돌리는 <code>reject</code> 메서드를 추가해 보세요.</li>
<li>상태가 <code>Published</code>로 변경되기 전에 <code>approve</code>를 두 번 호출하도록 요구해 보세요.</li>
<li>포스트가 <code>Draft</code> 상태일 때만 사용자가 텍스트 내용을 추가할 수 있도록 허용해 보세요. 힌트: 상태 객체가 내용의 변경 가능 여부를 책임지게 하되, <code>Post</code>를 수정하는 책임은 가지지 않도록 하세요.</li>
</ul>
<p>상태 패턴의 한 가지 단점은, 상태들이 상태 간의 전환을 구현하기 때문에 일부 상태들이 서로 결합된다는 점입니다. 만약 <code>PendingReview</code>와 <code>Published</code> 사이에 <code>Scheduled</code>와 같은 다른 상태를 추가한다면, <code>Scheduled</code>로 전환되도록 <code>PendingReview</code>의 코드를 변경해야 합니다. 새로운 상태가 추가될 때 <code>PendingReview</code>를 변경할 필요가 없다면 작업이 더 줄어들겠지만, 이는 다른 디자인 패턴으로의 전환을 의미할 것입니다.</p>
<p>또 다른 단점은 일부 로직이 중복된다는 것입니다. 중복을 제거하기 위해 <code>State</code> 트레이트의 <code>request_review</code>와 <code>approve</code> 메서드에 <code>self</code>를 반환하는 기본 구현을 만들려고 시도할 수도 있습니다. 하지만 이는 dyn 호환(dyn compatible)되지 않을 것입니다. 트레이트는 구체적인 <code>self</code>가 정확히 무엇일지 알 수 없기 때문입니다. 우리는 <code>State</code>를 트레이트 객체로 사용하기를 원하므로, 그 메서드들이 dyn 호환되어야 합니다.</p>
<p>다른 중복으로는 <code>Post</code>에 구현된 <code>request_review</code>와 <code>approve</code> 메서드의 유사한 모습이 있습니다. 두 메서드 모두 <code>Option</code>의 <code>state</code> 필드에 있는 값의 동일한 메서드 구현에 위임하고, 그 결과로 <code>state</code> 필드의 새로운 값을 설정합니다. 만약 <code>Post</code>에 이런 패턴을 따르는 메서드가 아주 많다면, 반복을 줄이기 위해 매크로 정의를 고려해 볼 수 있습니다 (20장의 <a href="ch20-05-macros.html#macros">“매크로”</a><!-- ignore --> 섹션 참조).</p>
<p>상태 패턴을 객체 지향 언어에서 정의된 그대로 구현함으로써, 우리는 러스트의 강점을 충분히 활용하지 못하고 있습니다. 이제 유효하지 않은 상태와 상태 전환을 컴파일 타임 에러로 만들 수 있도록 <code>blog</code> 크레이트에 가할 수 있는 몇 가지 변경 사항들을 살펴봅시다.</p>
<h4 id="상태와-동작을-타입으로-인코딩하기"><a class="header" href="#상태와-동작을-타입으로-인코딩하기">상태와 동작을 타입으로 인코딩하기</a></h4>
<p>다른 트레이드오프 세트를 얻기 위해 상태 패턴을 재구성하는 방법을 보여드리겠습니다. 상태와 상태 전환을 완전히 캡슐화하여 외부 코드에서 알 수 없게 만드는 대신, 상태를 서로 다른 타입으로 인코딩할 것입니다. 결과적으로 러스트의 타입 체크 시스템은 게시된 포스트만 허용되는 곳에 초안 포스트를 사용하려는 시도를 컴파일 타임 에러를 통해 방지해 줄 것입니다.</p>
<p>목록 18-11에 있는 <code>main</code>의 첫 번째 부분을 살펴봅시다.</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore"><span class="boring">use blog::Post;
</span><span class="boring">
</span>fn main() {
    let mut post = Post::new();

    post.add_text("나는 오늘 점심으로 샐러드를 먹었다");
    assert_eq!("", post.content());
<span class="boring">
</span><span class="boring">    post.request_review();
</span><span class="boring">    assert_eq!("", post.content());
</span><span class="boring">
</span><span class="boring">    post.approve();
</span><span class="boring">    assert_eq!("나는 오늘 점심으로 샐러드를 먹었다", post.content());
</span>}</code></pre>
</Listing>
<p>우리는 여전히 <code>Post::new</code>를 사용하여 초안 상태의 새로운 포스트를 생성하고 포스트의 내용에 텍스트를 추가할 수 있게 합니다. 하지만 초안 포스트에 빈 문자열을 반환하는 <code>content</code> 메서드를 두는 대신, 아예 <code>content</code> 메서드가 없도록 만들 것입니다. 그렇게 하면 초안 포스트의 내용을 가져오려고 시도할 때 해당 메서드가 존재하지 않는다는 컴파일 타임 에러를 받게 됩니다. 결과적으로, 해당 코드는 컴파일조차 되지 않을 것이기 때문에 우리가 실수로 프로덕션에서 초안 포스트의 내용을 표시하는 것이 불가능해집니다. 목록 18-19는 <code>Post</code> 구조체와 <code>DraftPost</code> 구조체의 정의, 그리고 각각의 메서드들을 보여줍니다.</p>
<Listing number="18-19" file-name="src/lib.rs" caption="A `Post` with a `content` method and `DraftPost` without a `content` method">
<pre><code class="language-rust noplayground">pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -&gt; DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&amp;self) -&gt; &amp;str {
        &amp;self.content
    }
}

impl DraftPost {
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}</code></pre>
</Listing>
<p><code>Post</code>와 <code>DraftPost</code> 구조체 모두 블로그 포스트 텍스트를 저장하는 비공개 <code>content</code> 필드를 가집니다. 상태 인코딩을 구조체 타입으로 옮겼기 때문에 구조체들은 더 이상 <code>state</code> 필드를 가지지 않습니다. <code>Post</code> 구조체는 게시된 포스트를 나타내며, <code>content</code>를 반환하는 <code>content</code> 메서드를 가집니다.</p>
<p>우리는 여전히 <code>Post::new</code> 함수를 가지고 있지만, <code>Post</code> 인스턴스 대신 <code>DraftPost</code> 인스턴스를 반환합니다. <code>content</code>가 비공개이고 <code>Post</code>를 반환하는 함수가 없기 때문에, 현재로서는 <code>Post</code> 인스턴스를 생성하는 것이 불가능합니다.</p>
<p><code>DraftPost</code> 구조체는 <code>add_text</code> 메서드를 가지고 있어서 이전처럼 <code>content</code>에 텍스트를 추가할 수 있지만, <code>DraftPost</code>에는 <code>content</code> 메서드가 정의되어 있지 않다는 점에 주목하세요! 이제 프로그램은 모든 포스트가 초안으로 시작함을 보장하며, 초안 포스트는 표시할 내용을 제공하지 않습니다. 이러한 제약 사항을 우회하려는 모든 시도는 컴파일 타임 에러로 이어질 것입니다.</p>
<h4 id="상태-전환을-서로-다른-타입-간의-변환으로-구현하기"><a class="header" href="#상태-전환을-서로-다른-타입-간의-변환으로-구현하기">상태 전환을 서로 다른 타입 간의 변환으로 구현하기</a></h4>
<p>So how do we get a published post? We want to enforce the rule that a draft post has to be reviewed and approved before it can be published. A post in the pending review state should still not display any content. Let’s implement these constraints by adding another struct, <code>PendingReviewPost</code>, defining the <code>request_review</code> method on <code>DraftPost</code> to return a <code>PendingReviewPost</code>, and defining an <code>approve</code> method on <code>PendingReviewPost</code> to return a <code>Post</code>, as shown in Listing 18-20:</p>
<Listing number="18-20" file-name="src/lib.rs" caption="A `PendingReviewPost` that gets created by calling `request_review` on `DraftPost` and an `approve` method that turns a `PendingReviewPost` into a published `Post`">
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct DraftPost {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; DraftPost {
</span><span class="boring">        DraftPost {
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.content
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl DraftPost {
    // --생략--
<span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(self) -&gt; PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -&gt; Post {
        Post {
            content: self.content,
        }
    }
}</code></pre>
</Listing>
<p><code>request_review</code>와 <code>approve</code> 메서드는 <code>self</code>의 소유권을 가져가므로, <code>DraftPost</code>와 <code>PendingReviewPost</code> 인스턴스를 소비하고 이를 각각 <code>PendingReviewPost</code>와 게시된 <code>Post</code>로 변환합니다. 이런 식으로, 우리는 <code>request_review</code>를 호출한 후에 남아있는 <code>DraftPost</code> 인스턴스를 가지지 않게 됩니다. <code>PendingReviewPost</code> 구조체에는 <code>content</code> 메서드가 정의되어 있지 않으므로, 해당 내용을 읽으려는 시도는 <code>DraftPost</code>와 마찬가지로 컴파일 타임 에러를 발생시킵니다. <code>content</code> 메서드가 정의된 게시된 <code>Post</code> 인스턴스를 얻는 유일한 방법은 <code>PendingReviewPost</code>에서 <code>approve</code> 메서드를 호출하는 것이고, <code>PendingReviewPost</code>를 얻는 유일한 방법은 <code>DraftPost</code>에서 <code>request_review</code> 메서드를 호출하는 것이기 때문에, 우리는 이제 블로그 포스트 워크플로우를 타입 시스템에 인코딩했습니다.</p>
<p>하지만 <code>main</code>에도 몇 가지 작은 변경을 해야 합니다. <code>request_review</code>와 <code>approve</code> 메서드가 호출된 구조체를 직접 수정하는 대신 새로운 인스턴스를 반환하므로, 반환된 인스턴스를 저장하기 위해 더 많은 <code>let post =</code> 섀도잉(shadowing) 할당을 추가해야 합니다. 또한 초안 및 리뷰 대기 중인 포스트의 내용이 빈 문자열이라는 어설션(assertion)을 가질 수 없으며, 가질 필요도 없습니다. 해당 상태의 포스트 내용을 사용하려고 시도하는 코드는 이제 컴파일조차 되지 않기 때문입니다. 업데이트된 <code>main</code> 코드가 목록 18-21에 나와 있습니다.</p>
<Listing number="18-21" file-name="src/main.rs" caption="Modifications to `main` to use the new implementation of the blog post workflow">
<pre><code class="language-rust ignore">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("나는 오늘 점심으로 샐러드를 먹었다");

    let post = post.request_review();

    let post = post.approve();

    assert_eq!("나는 오늘 점심으로 샐러드를 먹었다", post.content());
}</code></pre>
</Listing>
<p><code>post</code>를 재할당하기 위해 <code>main</code>에 가한 변경 사항들은, 이 구현이 더 이상 객체 지향 상태 패턴을 정확히 따르지는 않음을 의미합니다. 상태 간의 전환이 더 이상 <code>Post</code> 구현 내부에 완전히 캡슐화되어 있지 않기 때문입니다. 하지만 타입 시스템과 컴파일 타임에 수행되는 타입 체크 덕분에 이제 유효하지 않은 상태를 가지는 것이 아예 불가능해졌다는 이득을 얻었습니다! 이는 게시되지 않은 포스트의 내용이 표시되는 것과 같은 특정 버그들이 실제 프로덕션에 나가기 전에 발견될 것임을 보장합니다.</p>
<p>목록 18-21 이후의 <code>blog</code> 크레이트에 대해 이 섹션의 시작 부분에서 제안했던 과제들을 시도해 보면서, 이 버전의 코드 설계에 대해 어떻게 생각하시는지 확인해 보세요. 일부 과제들은 이 설계에서 이미 완료되었을 수도 있습니다.</p>
<p>우리는 러스트가 객체 지향 디자인 패턴을 구현할 수 있을 뿐만 아니라, 상태를 타입 시스템에 인코딩하는 것과 같은 다른 패턴들도 러스트에서 가능함을 보았습니다. 이러한 패턴들은 각기 다른 트레이드오프를 가집니다. 객체 지향 패턴에 매우 익숙할지라도, 러스트의 기능을 활용하기 위해 문제를 다시 생각해 보는 것은 컴파일 타임에 일부 버그를 방지하는 것과 같은 이점을 제공할 수 있습니다. 객체 지향 언어에는 없는 소유권과 같은 특정 기능들 때문에, 객체 지향 패턴이 러스트에서 항상 최선의 해결책인 것은 아닙니다.</p>
<h2 id="요약-17"><a class="header" href="#요약-17">요약</a></h2>
<p>이 장을 읽은 후 러스트가 객체 지향 언어라고 생각하든 그렇지 않든, 이제 트레이트 객체를 사용하여 러스트에서 일부 객체 지향 기능을 사용할 수 있음을 알게 되었습니다. 동적 디스패치는 약간의 런타임 성능을 희생하는 대신 코드에 유연성을 제공할 수 있습니다. 여러분은 이 유연성을 사용하여 코드의 유지보수성에 도움이 되는 객체 지향 패턴을 구현할 수 있습니다. 또한 러스트에는 객체 지향 언어에는 없는 소유권과 같은 다른 기능들도 있습니다. 객체 지향 패턴이 항상 러스트의 강점을 활용하는 최선의 방법은 아니겠지만, 선택 가능한 옵션 중 하나입니다.</p>
<p>다음으로, 많은 유연성을 가능하게 하는 러스트의 또 다른 기능인 패턴에 대해 알아보겠습니다. 책 전체에 걸쳐 짧게 살펴보긴 했지만, 아직 그 전체 기능을 보지는 못했습니다. 자, 시작해 봅시다!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="패턴과-매칭"><a class="header" href="#패턴과-매칭">패턴과 매칭</a></h1>
<p>_패턴(Patterns)_은 복잡하거나 단순한 타입들의 구조에 대해 매칭을 수행하기 위한 러스트의 특별한 문법입니다. 패턴을 <code>match</code> 표현식 및 다른 구문들과 결합하여 사용하면 프로그램의 제어 흐름을 더 세밀하게 제어할 수 있습니다. 패턴은 다음과 같은 요소들의 조합으로 구성됩니다.</p>
<ul>
<li>리터럴</li>
<li>구조분해된 배열, 열거형, 구조체, 또는 튜플</li>
<li>변수</li>
<li>와일드카드</li>
<li>플레이스홀더</li>
</ul>
<p>패턴의 예로는 <code>x</code>, <code>(a, 3)</code>, <code>Some(Color::Red)</code> 등이 있습니다. 패턴이 유효한 맥락에서 이러한 구성 요소들은 데이터의 형태를 묘사합니다. 프로그램은 값을 패턴과 비교하여, 특정 코드를 계속 실행하기 위해 필요한 올바른 형태의 데이터를 가지고 있는지 결정합니다.</p>
<p>패턴을 사용하기 위해 우리는 그것을 어떤 값과 비교합니다. 만약 패턴이 값과 매치되면, 우리는 그 값의 조각들을 코드에서 사용합니다. 동전 분류기 예제처럼 패턴을 사용했던 6장의 <code>match</code> 표현식을 떠올려 보세요. 만약 값이 패턴의 형태에 맞는다면, 이름 붙여진 조각들을 사용할 수 있습니다. 맞지 않는다면 해당 패턴과 연결된 코드는 실행되지 않습니다.</p>
<p>이번 장은 패턴과 관련된 모든 것들에 대한 참조입니다. 우리는 패턴을 사용할 수 있는 유효한 장소들, 반박 가능한(refutable) 패턴과 반박 불가능한(irrefutable) 패턴의 차이, 그리고 여러분이 보게 될 다양한 종류의 패턴 문법들을 다룰 것입니다. 이번 장을 마칠 때쯤이면 여러분은 패턴을 사용하여 많은 개념들을 명확하게 표현하는 방법을 알게 될 것입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="패턴을-사용할-수-있는-모든-곳"><a class="header" href="#패턴을-사용할-수-있는-모든-곳">패턴을 사용할 수 있는 모든 곳</a></h2>
<p>패턴은 러스트의 여러 곳에서 나타나며, 여러분은 자신도 모르는 사이에 패턴을 많이 사용해 왔습니다! 이 섹션에서는 패턴이 유효한 모든 장소들에 대해 논의합니다.</p>
<h3 id="match-가지arms"><a class="header" href="#match-가지arms"><code>match</code> 가지(Arms)</a></h3>
<p>6장에서 논의했듯이, 우리는 <code>match</code> 표현식의 가지에서 패턴을 사용합니다. 공식적으로 <code>match</code> 표현식은 <code>match</code> 키워드, 매칭할 값, 그리고 하나 이상의 매치 가지들로 정의됩니다. 매치 가지는 패턴과, 값이 해당 가지의 패턴과 매치될 경우 실행할 표현식으로 구성됩니다. 다음과 같은 식이죠.</p>
<pre><code class="language-text">match VALUE {
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
}
</code></pre>
<p>예를 들어, 변수 <code>x</code>에 담긴 <code>Option&lt;i32&gt;</code> 값을 매칭하는 목록 6-5의 <code>match</code> 표현식은 다음과 같습니다.</p>
<pre><code class="language-rust ignore">match x {
    None =&gt; None,
    Some(i) =&gt; Some(i + 1),
}</code></pre>
<p>이 <code>match</code> 표현식에서 패턴은 각 화살표 왼쪽의 <code>None</code>과 <code>Some(i)</code>입니다.</p>
<p><code>match</code> 표현식의 한 가지 요구사항은 _포괄적(exhaustive)_이어야 한다는 것입니다. 즉, <code>match</code> 표현식에 들어오는 값의 모든 가능성이 고려되어야 합니다. 모든 가능성을 보장하는 한 가지 방법은 마지막 가지에 모든 것을 매칭하는(catch-all) 패턴을 두는 것입니다. 예를 들어, 어떤 값에도 매치되는 변수 이름은 결코 실패하지 않으므로 남은 모든 경우를 처리합니다.</p>
<p>특수한 패턴인 <code>_</code>는 모든 것에 매치되지만 결코 변수에 바인딩되지 않으므로, 흔히 마지막 매치 가지에 사용됩니다. 예를 들어 명시되지 않은 모든 값을 무시하고 싶을 때 <code>_</code> 패턴이 유용할 수 있습니다. <code>_</code> 패턴에 대해서는 이번 장 뒷부분의 <a href="ch19-03-pattern-syntax.html#ignoring-values-in-a-pattern">“패턴에서 값 무시하기”</a><!-- ignore --> 섹션에서 더 자세히 다룰 것입니다.</p>
<h3 id="조건부-if-let-표현식"><a class="header" href="#조건부-if-let-표현식">조건부 <code>if let</code> 표현식</a></h3>
<p>6장에서 우리는 주로 단 하나의 경우만 매칭하는 <code>match</code>와 동일한 코드를 더 짧게 쓰기 위한 방법으로 <code>if let</code> 표현식을 사용하는 법을 논의했습니다. 선택적으로 <code>if let</code>은 그에 대응하는 <code>else</code>를 가질 수 있으며, 여기에는 <code>if let</code>의 패턴이 매치되지 않을 때 실행할 코드를 담습니다.</p>
<p>목록 19-1은 <code>if let</code>, <code>else if</code>, <code>else if let</code> 표현식들을 섞어서 사용하는 것도 가능함을 보여줍니다. 이렇게 하면 패턴과 비교할 값을 단 하나만 표현할 수 있는 <code>match</code> 표현식보다 더 많은 유연성을 얻을 수 있습니다. 또한 러스트는 일련의 <code>if let</code>, <code>else if</code>, <code>else if let</code> 가지들의 조건들이 서로 관련되어 있을 것을 요구하지 않습니다.</p>
<p>목록 19-1의 코드는 여러 조건에 대한 일련의 검사를 바탕으로 배경색을 무엇으로 할지 결정합니다. 이 예제를 위해, 실제 프로그램이라면 사용자 입력으로부터 받았을 법한 값들을 하드코딩된 변수로 만들었습니다.</p>
<Listing number="19-1" file-name="src/main.rs" caption="Mixing `if let`, `else if`, `else if let`, and `else`">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let favorite_color: Option&lt;&amp;str&gt; = None;
    let is_tuesday = false;
    let age: Result&lt;u8, _&gt; = "34".parse();

    if let Some(color) = favorite_color {
        println!("좋아하는 색상 {color}을 배경색으로 사용합니다");
    } else if is_tuesday {
        println!("화요일은 초록의 날입니다!");
    } else if let Ok(age) = age {
        if age &gt; 30 {
            println!("보라색을 배경색으로 사용합니다");
        } else {
            println!("오렌지색을 배경색으로 사용합니다");
        }
    } else {
        println!("파란색을 배경색으로 사용합니다");
    }
}</code></pre></pre>
</Listing>
<p>사용자가 좋아하는 색상을 지정하면 그 색상이 배경으로 사용됩니다. 좋아하는 색상이 지정되지 않았고 오늘이 화요일이라면 배경색은 초록색이 됩니다. 그렇지 않고 사용자가 나이를 문자열로 지정했으며 이를 숫자로 성공적으로 파싱할 수 있다면, 숫자의 값에 따라 보라색이나 오렌지색이 됩니다. 이 조건들 중 어느 것도 해당하지 않는다면 배경색은 파란색이 됩니다.</p>
<p>이러한 조건 구조를 통해 복잡한 요구사항을 지원할 수 있습니다. 여기에 있는 하드코딩된 값들을 사용하면, 이 예제는 <code>보라색을 배경색으로 사용합니다</code>를 출력할 것입니다.</p>
<p><code>match</code> 가지에서와 마찬가지로 <code>if let</code>도 기존 변수를 섀도잉하는 새로운 변수를 도입할 수 있음을 볼 수 있습니다. <code>if let Ok(age) = age</code> 라인은 <code>Ok</code> 변형 내부의 값을 담는 새로운 <code>age</code> 변수를 도입하여 기존의 <code>age</code> 변수를 섀도잉합니다. 이는 <code>if age &gt; 30</code> 조건을 해당 블록 내부에 두어야 함을 의미합니다. 이 두 조건을 <code>if let Ok(age) = age &amp;&amp; age &gt; 30</code>으로 결합할 수는 없습니다. 30과 비교하고자 하는 새로운 <code>age</code>는 중괄호와 함께 새로운 스코프가 시작되기 전까지는 유효하지 않기 때문입니다.</p>
<p><code>if let</code> 표현식을 사용하는 것의 단점은 컴파일러가 포괄성(exhaustiveness)을 검사하지 않는다는 점입니다. 반면 <code>match</code> 표현식은 검사합니다. 만약 우리가 마지막 <code>else</code> 블록을 생략하여 일부 경우를 놓치더라도, 컴파일러는 잠재적인 로직 버그에 대해 경고해 주지 않을 것입니다.</p>
<h3 id="while-let-조건부-루프"><a class="header" href="#while-let-조건부-루프"><code>while let</code> 조건부 루프</a></h3>
<p><code>if let</code>과 구조가 유사한 <code>while let</code> 조건부 루프는 패턴이 계속 매치되는 한 <code>while</code> 루프를 실행할 수 있게 해줍니다. 우리는 17장에서 스트림이 새로운 값을 생성하는 동안 계속 루프를 돌기 위해 <code>while let</code> 루프를 처음 보았습니다. 이와 비슷하게, 목록 19-2에서는 스레드 간에 전송된 메시지를 기다리는 <code>while let</code> 루프를 보여주는데, 이번에는 <code>Option</code> 대신 <code>Result</code>를 검사합니다.</p>
<Listing number="19-2" caption="Using a `while let` loop to print values for as long as `rx.recv()` returns `Ok`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let (tx, rx) = std::sync::mpsc::channel();
    std::thread::spawn(move || {
        for val in [1, 2, 3] {
            tx.send(val).unwrap();
        }
    });

    while let Ok(value) = rx.recv() {
        println!("{value}");
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 예제는 1, 2, 3을 출력합니다. 16장에서 <code>recv</code>를 보았을 때 우리는 에러를 직접 언랩하거나 <code>for</code> 루프를 사용하여 반복자로 상호작용했습니다. 하지만 목록 19-2에서 보여주듯 <code>while let</code>도 사용할 수 있습니다. <code>recv</code> 메서드는 송신자가 메시지를 보내는 동안 <code>Ok</code>를 반환하고, 송신 측이 연결을 끊으면 <code>Err</code>를 발생시키기 때문입니다.</p>
<h3 id="for-루프"><a class="header" href="#for-루프"><code>for</code> 루프</a></h3>
<p><code>for</code> 루프에서 <code>for</code> 키워드 바로 뒤에 오는 값은 패턴입니다. 예를 들어, <code>for x in y</code>에서 <code>x</code>가 패턴입니다. 목록 19-3은 튜플을 구조분해(destructure) 하거나 해체하기 위해 <code>for</code> 루프에서 패턴을 사용하는 방법을 보여줍니다.</p>
<Listing number="19-3" caption="Using a pattern in a `for` loop to destructure a tuple">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let v = vec!['a', 'b', 'c'];

    for (index, value) in v.iter().enumerate() {
        println!("{value}는 인덱스 {index}에 있습니다");
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>목록 19-3의 코드는 다음과 같이 출력할 것입니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.52s
     Running `target/debug/patterns`
a는 인덱스 0에 있습니다
b는 인덱스 1에 있습니다
c는 인덱스 2에 있습니다
</code></pre>
<p>우리는 <code>enumerate</code> 메서드를 사용하여 반복자가 값과 그 값의 인덱스를 한 쌍의 튜플로 생성하도록 조정합니다. 처음 생성된 값은 튜플 <code>(0, 'a')</code>입니다. 이 값이 패턴 <code>(index, value)</code>와 매치되면 <code>index</code>는 <code>0</code>이 되고 <code>value</code>는 <code>'a'</code>가 되어 출력의 첫 번째 줄을 출력하게 됩니다.</p>
<h3 id="let-문"><a class="header" href="#let-문"><code>let</code> 문</a></h3>
<p>이번 장 이전까지 우리는 오직 <code>match</code>와 <code>if let</code>에서 패턴을 사용하는 것에 대해서만 명시적으로 논의했었지만, 사실 우리는 <code>let</code> 문을 포함하여 다른 곳에서도 패턴을 사용해 왔습니다. 예를 들어, <code>let</code>을 사용한 간단한 변수 할당을 생각해 봅시다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}</span></code></pre></pre>
<p>여러분이 이런 식의 <code>let</code> 문을 사용할 때마다 여러분은 패턴을 사용해 왔던 것입니다. 비록 깨닫지 못했을 수도 있겠지만요! 좀 더 공식적으로, <code>let</code> 문은 다음과 같이 생겼습니다.</p>
<pre><code class="language-text">let PATTERN = EXPRESSION;
</code></pre>
<p><code>PATTERN</code> 자리에 변수 이름이 있는 <code>let x = 5;</code>와 같은 문장에서, 변수 이름은 단지 매우 단순한 형태의 패턴일 뿐입니다. 러스트는 표현식을 패턴과 비교하고 발견된 모든 이름에 값을 할당합니다. 따라서 <code>let x = 5;</code> 예제에서 <code>x</code>는 "여기에 매치되는 것을 변수 <code>x</code>에 바인딩하라"는 의미의 패턴입니다. 이름 <code>x</code>가 패턴의 전부이므로, 이 패턴은 사실상 "값이 무엇이든 모든 것을 변수 <code>x</code>에 바인딩하라"는 의미가 됩니다.</p>
<p><code>let</code>의 패턴 매칭 측면을 좀 더 명확히 보기 위해, <code>let</code>과 함께 패턴을 사용하여 튜플을 구조분해하는 목록 19-4를 살펴봅시다.</p>
<Listing number="19-4" caption="Using a pattern to destructure a tuple and create three variables at once">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let (x, y, z) = (1, 2, 3);
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>여기서 우리는 튜플을 패턴에 매칭합니다. 러스트는 값 <code>(1, 2, 3)</code>을 패턴 <code>(x, y, z)</code>와 비교하고 값이 패턴에 매치됨을 확인합니다. 그래서 러스트는 <code>1</code>을 <code>x</code>에, <code>2</code>를 <code>y</code>에, <code>3</code>을 <code>z</code>에 바인딩합니다. 이 튜플 패턴은 내부에 세 개의 개별적인 변수 패턴이 중첩된 것으로 생각할 수 있습니다.</p>
<p>만약 패턴의 요소 개수가 튜플의 요소 개수와 일치하지 않는다면, 전체 타입이 일치하지 않게 되어 컴파일러 에러가 발생할 것입니다. 예를 들어, 목록 19-5는 세 개의 요소를 가진 튜플을 두 개의 변수로 구조분해하려는 시도를 보여주는데, 이는 작동하지 않습니다.</p>
<Listing number="19-5" caption="Incorrectly constructing a pattern whose variables don’t match the number of elements in the tuple">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let (x, y) = (1, 2, 3);
<span class="boring">}</span></code></pre>
</Listing>
<p>이 코드를 컴파일하려고 시도하면 다음과 같은 타입 에러가 발생합니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0308]: mismatched types
 --&gt; src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^   --------- 이 표현식은 `({integer}, {integer}, {integer})` 타입을 가집니다
  |         |
  |         3개의 요소를 가진 튜플을 예상했으나, 2개의 요소를 가진 튜플이 발견되었습니다
  |
  = note: 튜플 `({integer}, {integer}, {integer})`를 예상했으나
             튜플 `(_, _)`를 발견했습니다

이 에러에 대한 더 자세한 정보를 원하시면 `rustc --explain E0308`을 시도해 보세요.
에러: 1개의 이전 에러로 인해 `patterns` (바이너리 "patterns")를 컴파일할 수 없습니다
</code></pre>
<p>에러를 고치려면, 이번 장의 <a href="ch19-03-pattern-syntax.html#ignoring-values-in-a-pattern">“패턴에서 값 무시하기”</a><!-- ignore --> 섹션에서 보게 될 <code>_</code>나 <code>..</code>를 사용하여 튜플의 하나 이상의 값을 무시할 수 있습니다. 만약 문제가 패턴에 너무 많은 변수가 있는 것이라면, 변수의 개수가 튜플의 요소 개수와 같아지도록 변수를 제거하여 타입을 일치시키는 것이 해결책입니다.</p>
<h3 id="함수-매개변수"><a class="header" href="#함수-매개변수">함수 매개변수</a></h3>
<p>함수 매개변수 또한 패턴이 될 수 있습니다. <code>i32</code> 타입의 <code>x</code>라는 매개변수를 하나 받는 <code>foo</code>라는 함수를 선언하는 목록 19-6의 코드는 이제 익숙해 보일 것입니다.</p>
<Listing number="19-6" caption="A function signature uses patterns in the parameters">
<pre><pre class="playground"><code class="language-rust edition2021">fn foo(x: i32) {
    // 코드가 여기에 들어갑니다
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p><code>x</code> 부분이 바로 패턴입니다! <code>let</code>에서 했던 것처럼, 함수의 인수에서 튜플을 패턴에 매칭할 수 있습니다. 목록 19-7은 튜플을 함수에 전달할 때 그 안의 값들을 쪼개어 받습니다.</p>
<Listing number="19-7" file-name="src/main.rs" caption="A function with parameters that destructure a tuple">
<pre><pre class="playground"><code class="language-rust edition2021">fn print_coordinates(&amp;(x, y): &amp;(i32, i32)) {
    println!("현재 위치: ({x}, {y})");
}

fn main() {
    let point = (3, 5);
    print_coordinates(&amp;point);
}</code></pre></pre>
</Listing>
<p>이 코드는 <code>현재 위치: (3, 5)</code>를 출력합니다. 값 <code>&amp;(3, 5)</code>가 패턴 <code>&amp;(x, y)</code>와 매치되므로, <code>x</code>는 <code>3</code>이 되고 <code>y</code>는 <code>5</code>가 됩니다.</p>
<p>13장에서 논의했듯이 클로저는 함수와 유사하므로, 함수 매개변수 리스트에서와 동일한 방식으로 클로저 매개변수 리스트에서도 패턴을 사용할 수 있습니다.</p>
<p>지금까지 여러분은 패턴을 사용하는 여러 가지 방법들을 보았습니다. 하지만 패턴이 사용되는 모든 곳에서 동일하게 작동하는 것은 아닙니다. 어떤 곳에서는 패턴이 반드시 반박 불가능(irrefutable)해야 하며, 다른 상황에서는 반박 가능(refutable) 할 수도 있습니다. 다음으로 이 두 가지 개념에 대해 논의해 보겠습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="반박-가능성-패턴이-매치에-실패할-수-있는지-여부"><a class="header" href="#반박-가능성-패턴이-매치에-실패할-수-있는지-여부">반박 가능성: 패턴이 매치에 실패할 수 있는지 여부</a></h2>
<p>패턴에는 두 가지 형태가 있습니다: 반박 가능(refutable)과 반박 불가능(irrefutable)입니다. 전달될 수 있는 모든 가능한 값에 대해 매치되는 패턴을 _반박 불가능_하다고 합니다. 예를 들어 <code>let x = 5;</code> 문장에서 <code>x</code>는 무엇이든 매치되므로 매칭에 실패할 수 없습니다. 반면 일부 가능한 값에 대해 매칭이 실패할 수 있는 패턴을 _반박 가능_하다고 합니다. 한 예로 <code>if let Some(x) = a_value</code> 표현식에서 <code>Some(x)</code>를 들 수 있는데, 만약 <code>a_value</code> 변수의 값이 <code>Some</code>이 아니라 <code>None</code>이라면 <code>Some(x)</code> 패턴은 매치되지 않기 때문입니다.</p>
<p>함수 매개변수, <code>let</code> 문, 그리고 <code>for</code> 루프는 오직 반박 불가능한 패턴만 허용할 수 있습니다. 값이 매치되지 않을 때 프로그램이 의미 있는 작업을 수행할 수 없기 때문입니다. <code>if let</code>과 <code>while let</code> 표현식, 그리고 <code>let</code>-<code>else</code> 문은 반박 가능한 패턴과 반박 불가능한 패턴을 모두 허용하지만, 컴파일러는 반박 불가능한 패턴에 대해 경고를 보냅니다. 왜냐하면 조건문은 본질적으로 발생 가능한 실패를 처리하기 위한 것이기 때문입니다. 즉, 조건문의 기능은 성공 또는 실패에 따라 다르게 동작할 수 있는 능력에 있습니다.</p>
<p>일반적으로 여러분은 반박 가능한 패턴과 반박 불가능한 패턴의 구분에 대해 걱정할 필요가 없습니다. 하지만 에러 메시지에서 이 개념을 보게 되었을 때 대응할 수 있도록 익숙해질 필요는 있습니다. 그런 경우, 코드의 의도된 동작에 따라 패턴을 변경하거나 패턴과 함께 사용하는 구문을 변경해야 할 것입니다.</p>
<p>러스트가 반박 불가능한 패턴을 요구하는 곳에 반박 가능한 패턴을 사용하려고 시도했을 때, 그리고 그 반대의 경우에 어떤 일이 일어나는지 예제를 통해 살펴봅시다. 목록 19-8은 <code>let</code> 문을 보여주지만, 패턴으로 반박 가능한 패턴인 <code>Some(x)</code>를 지정했습니다. 예상하시겠지만, 이 코드는 컴파일되지 않습니다.</p>
<Listing number="19-8" caption="Attempting to use a refutable pattern with `let`">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let some_option_value: Option&lt;i32&gt; = None;
</span>    let Some(x) = some_option_value;
<span class="boring">}</span></code></pre>
</Listing>
<p>만약 <code>some_option_value</code>가 <code>None</code> 값이었다면 <code>Some(x)</code> 패턴 매칭에 실패했을 것이고, 이는 해당 패턴이 반박 가능함을 의미합니다. 하지만 <code>let</code> 문은 오직 반박 불가능한 패턴만 허용할 수 있는데, <code>None</code> 값에 대해 코드가 수행할 수 있는 유효한 작업이 없기 때문입니다. 컴파일 타임에 러스트는 반박 불가능한 패턴이 필요한 곳에 반박 가능한 패턴을 사용하려 했다고 불평할 것입니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0005]: 로컬 바인딩에 반박 가능한 패턴이 사용되었습니다
 --&gt; src/main.rs:3:9
  |
3 |     let Some(x) = some_option_value;
  |         ^^^^^^^ `None` 패턴이 커버되지 않았습니다
  |
  = note: `let` 바인딩은 구조체나 변형이 하나뿐인 열거형과 같은 "반박 불가능한 패턴"을 요구합니다
  = note: 더 자세한 정보는 https://doc.rust-lang.org/book/ch18-02-refutability.html 를 방문하세요
  = note: 매칭된 값의 타입은 `Option&lt;i32&gt;`입니다
help: 매치되지 않는 변형을 처리하기 위해 `let else` 사용을 고려해 보세요
  |
3 |     let Some(x) = some_option_value else { todo!() };
  |                                     ++++++++++++++++

이 에러에 대한 더 자세한 정보를 원하시면 `rustc --explain E0005`를 시도해 보세요.
에러: 1개의 이전 에러로 인해 `patterns` (바이너리 "patterns")를 컴파일할 수 없습니다
</code></pre>
<p>패턴 <code>Some(x)</code>로 모든 유효한 값을 커버하지 않았기(그리고 커버할 수도 없었기!) 때문에, 러스트는 당연하게도 컴파일러 에러를 발생시킵니다.</p>
<p>반박 불가능한 패턴이 필요한 곳에 반박 가능한 패턴이 있다면, 패턴을 사용하는 코드를 변경함으로써 이를 고칠 수 있습니다. <code>let</code> 대신 <code>if let</code>을 사용하는 것이죠. 그렇게 하면 패턴이 매치되지 않을 때 중괄호 안의 코드를 그냥 건너뛰어, 프로그램이 유효하게 계속 실행될 수 있는 방법을 제공합니다. 목록 19-9는 목록 19-8의 코드를 고치는 방법을 보여줍니다.</p>
<Listing number="19-9" caption="Using `if let` and a block with refutable patterns instead of `let`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    let some_option_value: Option&lt;i32&gt; = None;
</span>    if let Some(x) = some_option_value {
        println!("{x}");
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>우리는 코드에게 탈출구를 주었습니다! 이제 이 코드는 완벽하게 유효합니다. 하지만 목록 19-10에 나타난 것처럼 <code>if let</code>에 <code>x</code>와 같이 항상 매치되는 반박 불가능한 패턴을 준다면, 컴파일러는 경고를 보낼 것입니다.</p>
<Listing number="19-10" caption="Attempting to use an irrefutable pattern with `if let`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    if let x = 5 {
        println!("{x}");
    };
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>러스트는 반박 불가능한 패턴과 함께 <code>if let</code>을 사용하는 것이 의미가 없다고 불평합니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
warning: 반박 불가능한 `if let` 패턴입니다
 --&gt; src/main.rs:2:8
  |
2 |     if let x = 5 {
  |        ^^^^^^^^^
  |
  = note: 이 패턴은 항상 매치되므로, `if let`은 쓸모가 없습니다
  = help: `if let`을 `let`으로 바꾸는 것을 고려해 보세요
  = note: `#[warn(irrefutable_let_patterns)]` 경고가 기본적으로 켜져 있습니다

경고: `patterns` (바이너리 "patterns")에서 1개의 경고가 생성되었습니다
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.39s
     Running `target/debug/patterns`
5
</code></pre>
<p>이러한 이유로, 매치 가지는 반드시 반박 가능한 패턴을 사용해야 합니다. 단, 마지막 가지는 남은 모든 값을 반박 불가능한 패턴으로 매치해야 합니다. 러스트는 단 하나의 가지만 있는 <code>match</code>에서 반박 불가능한 패턴을 사용하는 것을 허용하지만, 이 문법은 딱히 유용하지 않으며 더 간단한 <code>let</code> 문으로 대체될 수 있습니다.</p>
<p>이제 패턴을 어디에서 사용하는지, 그리고 반박 가능한 패턴과 반박 불가능한 패턴의 차이가 무엇인지 알게 되었으니, 패턴을 만들기 위해 사용할 수 있는 모든 문법을 다뤄봅시다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="패턴-문법"><a class="header" href="#패턴-문법">패턴 문법</a></h2>
<p>이 섹션에서는 패턴에서 유효한 모든 문법을 모아보고, 각각을 왜 그리고 언제 사용하고 싶을지 논의해 보겠습니다.</p>
<h3 id="리터럴-매칭하기"><a class="header" href="#리터럴-매칭하기">리터럴 매칭하기</a></h3>
<p>6장에서 보았듯이, 여러분은 패턴을 리터럴과 직접 매칭할 수 있습니다. 다음 코드는 몇 가지 예시를 보여줍니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 =&gt; println!("하나"),
        2 =&gt; println!("둘"),
        3 =&gt; println!("셋"),
        _ =&gt; println!("무엇이든"),
    }
<span class="boring">}</span></code></pre></pre>
<p>이 코드는 <code>x</code>의 값이 1이므로 <code>one</code>을 출력합니다. 이 문법은 특정한 구체적인 값을 받았을 때 어떤 동작을 취하게 하고 싶을 때 유용합니다.</p>
<h3 id="이름-붙은-변수-매칭하기"><a class="header" href="#이름-붙은-변수-매칭하기">이름 붙은 변수 매칭하기</a></h3>
<p>이름 붙은 변수는 모든 값에 매치되는 반박 불가능한 패턴이며, 우리는 이 책에서 여러 번 사용해 왔습니다. 하지만 <code>match</code>, <code>if let</code>, 또는 <code>while let</code> 표현식에서 이름 붙은 변수를 사용할 때는 복잡한 점이 있습니다. 이러한 표현식들은 각각 새로운 스코프를 시작하기 때문에, 표현식 내부의 패턴 일부로 선언된 변수는 모든 변수가 그러하듯 외부의 동일한 이름을 가진 변수를 섀도잉하게 됩니다. 목록 19-11에서는 <code>Some(5)</code> 값을 가진 변수 <code>x</code>와 <code>10</code> 값을 가진 변수 <code>y</code>를 선언합니다. 그런 다음 값 <code>x</code>에 대해 <code>match</code> 표현식을 만듭니다. 매치 가지의 패턴과 마지막의 <code>println!</code>을 살펴보고, 이 코드를 실행하거나 더 읽기 전에 코드가 무엇을 출력할지 맞춰보세요.</p>
<Listing number="19-11" file-name="src/main.rs" caption="A `match` expression with an arm that introduces a new variable which shadows an existing variable `y`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!("50을 얻었습니다"),
        Some(y) =&gt; println!("매치됨, y = {y}"),
        _ =&gt; println!("기본 케이스, x = {x:?}"),
    }

    println!("마지막에: x = {x:?}, y = {y}");
<span class="boring">}</span></code></pre></pre>
</Listing>
<p><code>match</code> 표현식이 실행될 때 어떤 일이 일어나는지 살펴봅시다. 첫 번째 매치 가지의 패턴은 <code>x</code>에 정의된 값과 매치되지 않으므로, 코드는 계속 진행됩니다.</p>
<p>두 번째 매치 가지의 패턴은 <code>Some</code> 값 내부의 모든 값과 매치될 <code>y</code>라는 새로운 변수를 도입합니다. 우리는 <code>match</code> 표현식 내부의 새로운 스코프에 있기 때문에, 이것은 새로운 <code>y</code> 변수이지 처음에 10이라는 값으로 선언한 <code>y</code>가 아닙니다. 이 새로운 <code>y</code> 바인딩은 <code>Some</code> 내부의 모든 값과 매치될 것이며, 이것이 우리가 <code>x</code>에 가지고 있는 것입니다. 따라서 이 새로운 <code>y</code>는 <code>x</code>에 있는 <code>Some</code> 내부의 값에 바인딩됩니다. 그 값은 <code>5</code>이므로, 해당 가지의 표현식이 실행되어 <code>Matched, y = 5</code>를 출력합니다.</p>
<p>만약 <code>x</code>가 <code>Some(5)</code> 대신 <code>None</code> 값이었다면, 처음 두 가지의 패턴은 매치되지 않았을 것이므로 값은 언더스코어에 매치되었을 것입니다. 우리는 언더스코어 가지의 패턴에서 <code>x</code> 변수를 도입하지 않았으므로, 표현식의 <code>x</code>는 여전히 섀도잉되지 않은 외부의 <code>x</code>입니다. 이 가상의 경우, <code>match</code>는 <code>Default case, x = None</code>을 출력할 것입니다.</p>
<p><code>match</code> 표현식이 끝나면 그 스코프가 종료되고, 내부의 <code>y</code> 스코프도 함께 종료됩니다. 마지막 <code>println!</code>은 <code>at the end: x = Some(5), y = 10</code>을 출력합니다.</p>
<p>기존 <code>y</code> 변수를 섀도잉하는 새로운 변수를 도입하는 대신, 외부의 <code>x</code>와 <code>y</code> 값을 비교하는 <code>match</code> 표현식을 만들려면 매치 가드(match guard) 조건문을 사용해야 합니다. 매치 가드에 대해서는 나중에 <a href="ch19-03-pattern-syntax.html#extra-conditionals-with-match-guards">“매치 가드를 이용한 추가 조건”</a><!-- ignore --> 섹션에서 다룰 것입니다.</p>
<h3 id="다중-패턴"><a class="header" href="#다중-패턴">다중 패턴</a></h3>
<p>패턴 <em>or</em> 연산자인 <code>|</code> 문법을 사용하여 여러 패턴을 매칭할 수 있습니다. 예를 들어 다음 코드에서는 <code>x</code>의 값을 매치 가지들과 비교하는데, 첫 번째 가지에 <em>or</em> 옵션이 있습니다. 즉, <code>x</code>의 값이 해당 가지의 값들 중 하나라도 일치하면 그 가지의 코드가 실행됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 | 2 =&gt; println!("하나 또는 둘"),
        3 =&gt; println!("셋"),
        _ =&gt; println!("무엇이든"),
    }
<span class="boring">}</span></code></pre></pre>
<p>이 코드는 <code>one or two</code>를 출력합니다.</p>
<h3 id="를-사용한-값의-범위-매칭"><a class="header" href="#를-사용한-값의-범위-매칭"><code>..=</code>를 사용한 값의 범위 매칭</a></h3>
<p><code>..=</code> 문법은 포함 범위(inclusive range)의 값들을 매칭할 수 있게 해줍니다. 다음 코드에서 패턴이 주어진 범위 내의 어떤 값과 매치되면 해당 가지가 실행됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 5;

    match x {
        1..=5 =&gt; println!("하나부터 다섯까지"),
        _ =&gt; println!("그 외의 것"),
    }
<span class="boring">}</span></code></pre></pre>
<p>만약 <code>x</code>가 1, 2, 3, 4, 또는 5라면 첫 번째 가지가 매치됩니다. 이 문법은 동일한 의미를 <code>|</code> 연산자로 표현하는 것보다 여러 값을 매칭할 때 더 편리합니다. 만약 <code>|</code>를 사용했다면 <code>1 | 2 | 3 | 4 | 5</code>라고 명시해야 했을 것입니다. 범위를 지정하는 것은 훨씬 짧으며, 특히 1에서 1,000 사이의 임의의 숫자를 매칭하고 싶을 때 유용합니다!</p>
<p>컴파일러는 컴파일 타임에 범위가 비어 있지 않은지 확인합니다. 러스트가 범위가 비어 있는지 여부를 판단할 수 있는 유일한 타입은 <code>char</code>와 숫자 값뿐이므로, 범위는 숫자나 <code>char</code> 값에 대해서만 허용됩니다.</p>
<p>다음은 <code>char</code> 값의 범위를 사용하는 예제입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 'c';

    match x {
        'a'..='j' =&gt; println!("앞쪽 ASCII 문자"),
        'k'..='z' =&gt; println!("뒤쪽 ASCII 문자"),
        _ =&gt; println!("그 외의 것"),
    }
<span class="boring">}</span></code></pre></pre>
<p>러스트는 <code>'c'</code>가 첫 번째 패턴의 범위 내에 있음을 판단하고 <code>early ASCII letter</code>를 출력합니다.</p>
<h3 id="값을-분해하기-위한-구조분해"><a class="header" href="#값을-분해하기-위한-구조분해">값을 분해하기 위한 구조분해</a></h3>
<p>구조체, 열거형, 튜플을 구조분해하여 이 값들의 서로 다른 부분들을 사용하기 위해 패턴을 사용할 수도 있습니다. 각 값을 하나씩 살펴봅시다.</p>
<h4 id="구조체-구조분해하기"><a class="header" href="#구조체-구조분해하기">구조체 구조분해하기</a></h4>
<p>목록 19-12는 <code>let</code> 문과 패턴을 사용하여 분해할 수 있는 <code>x</code>와 <code>y</code> 두 필드를 가진 <code>Point</code> 구조체를 보여줍니다.</p>
<Listing number="19-12" file-name="src/main.rs" caption="Destructuring a struct’s fields into separate variables">
<pre><pre class="playground"><code class="language-rust edition2021">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}</code></pre></pre>
</Listing>
<p>이 코드는 <code>p</code> 구조체의 <code>x</code>와 <code>y</code> 필드 값에 매치되는 변수 <code>a</code>와 <code>b</code>를 생성합니다. 이 예제는 패턴의 변수 이름이 구조체의 필드 이름과 반드시 일치할 필요는 없음을 보여줍니다. 하지만 어떤 변수가 어떤 필드에서 왔는지 더 쉽게 기억하기 위해 변수 이름을 필드 이름과 일치시키는 것이 일반적입니다. 이러한 흔한 사용법 때문에, 그리고 <code>let Point { x: x, y: y } = p;</code>라고 쓰는 것이 많은 중복을 포함하기 때문에, 러스트는 구조체 필드와 매치되는 패턴에 대한 단축 문법을 제공합니다. 구조체 필드의 이름만 나열하면 되며, 패턴으로부터 생성된 변수들은 동일한 이름을 갖게 됩니다. 목록 19-13은 목록 19-12의 코드와 동일하게 동작하지만, <code>let</code> 패턴에서 생성된 변수들은 <code>a</code>, <code>b</code> 대신 <code>x</code>, <code>y</code>가 됩니다.</p>
<Listing number="19-13" file-name="src/main.rs" caption="Destructuring struct fields using struct field shorthand">
<pre><pre class="playground"><code class="language-rust edition2021">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}</code></pre></pre>
</Listing>
<p>이 코드는 변수 <code>p</code>의 <code>x</code>와 <code>y</code> 필드에 매치되는 변수 <code>x</code>와 <code>y</code>를 생성합니다. 그 결과 변수 <code>x</code>와 <code>y</code>는 <code>p</code> 구조체의 값들을 담게 됩니다.</p>
<p>모든 필드에 대해 변수를 생성하는 대신, 구조체 패턴의 일부로 리터럴 값을 사용하여 구조분해할 수도 있습니다. 이를 통해 다른 필드들을 구조분해할 변수들을 생성하면서 동시에 일부 필드들이 특정 값을 가졌는지 테스트할 수 있습니다.</p>
<p>목록 19-14에서는 <code>Point</code> 값을 세 가지 경우로 나누는 <code>match</code> 표현식을 보여줍니다. 축 <code>x</code> 위에 직접 놓인 점(<code>y = 0</code>인 경우), 축 <code>y</code> 위에 놓인 점(<code>x = 0</code>), 혹은 둘 다 아닌 경우입니다.</p>
<Listing number="19-14" file-name="src/main.rs" caption="Destructuring and matching literal values in one pattern">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!("x축 위의 {x}에 있습니다"),
        Point { x: 0, y } =&gt; println!("y축 위의 {y}에 있습니다"),
        Point { x, y } =&gt; {
            println!("어느 축 위에도 있지 않습니다: ({x}, {y})");
        }
    }
}</code></pre></pre>
</Listing>
<p>첫 번째 가지는 <code>y</code> 필드의 값이 리터럴 <code>0</code>과 매치되도록 지정함으로써 <code>x</code>축 위에 놓인 모든 점과 매치됩니다. 이 패턴은 여전히 해당 가지의 코드에서 사용할 수 있는 <code>x</code> 변수를 생성합니다.</p>
<p>마찬가지로, 두 번째 가지는 <code>x</code> 필드의 값이 <code>0</code>인 경우 매치되도록 지정하여 <code>y</code>축 위의 모든 점과 매치되며, <code>y</code> 필드 값을 위한 변수 <code>y</code>를 생성합니다. 세 번째 가지는 어떠한 리터럴도 지정하지 않으므로 다른 모든 <code>Point</code>와 매치되며 <code>x</code>와 <code>y</code> 필드 모두에 대해 변수를 생성합니다.</p>
<p>이 예제에서 값 <code>p</code>는 <code>x</code>가 0을 포함하고 있으므로 두 번째 가지와 매치됩니다. 따라서 이 코드는 <code>y축 위의 7에 있습니다</code>를 출력할 것입니다.</p>
<p><code>match</code> 표현식은 첫 번째로 매칭되는 패턴을 찾으면 가지 확인을 멈춘다는 점을 기억하세요. 따라서 <code>Point { x: 0, y: 0}</code>이 <code>x</code>축과 <code>y</code>축 모두 위에 있을지라도, 이 코드는 오직 <code>x축 위의 0에 있습니다</code>만 출력할 것입니다.</p>
<h4 id="열거형-구조분해하기"><a class="header" href="#열거형-구조분해하기">열거형 구조분해하기</a></h4>
<p>우리는 이 책에서 열거형을 구조분해해 왔지만(예를 들어 6장의 목록 6-5), 열거형을 구조분해하는 패턴이 열거형 내부에 데이터가 정의된 방식과 일치한다는 점을 아직 명시적으로 논의하지 않았습니다. 예로서, 목록 19-15에서는 목록 6-2의 <code>Message</code> 열거형을 사용하고 각각의 내부 값을 구조분해하는 패턴을 가진 <code>match</code>를 작성합니다.</p>
<Listing number="19-15" file-name="src/main.rs" caption="Destructuring enum variants that hold different kinds of values">
<pre><pre class="playground"><code class="language-rust edition2021">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            println!("Quit 변형은 구조분해할 데이터가 없습니다.");
        }
        Message::Move { x, y } =&gt; {
            println!("x 방향으로 {x}만큼, y 방향으로 {y}만큼 이동합니다");
        }
        Message::Write(text) =&gt; {
            println!("텍스트 메시지: {text}");
        }
        Message::ChangeColor(r, g, b) =&gt; {
            println!("색상을 빨간색 {r}, 녹색 {g}, 파란색 {b}으로 변경합니다");
        }
    }
}</code></pre></pre>
</Listing>
<p>이 코드는 <code>색상을 빨간색 0, 녹색 160, 파란색 255로 변경합니다</code>를 출력할 것입니다. <code>msg</code>의 값을 변경하여 다른 가지의 코드가 실행되는 것을 확인해 보세요.</p>
<p><code>Message::Quit</code>과 같이 아무런 데이터도 없는 열거형 변형의 경우, 해당 값을 더 이상 구조분해할 수 없습니다. 오직 리터럴 <code>Message::Quit</code> 값에 대해서만 매칭할 수 있으며, 해당 패턴에는 변수가 없습니다.</p>
<p><code>Message::Move</code>와 같은 구조체 형태의 열거형 변형의 경우, 구조체를 매칭할 때 사용하는 것과 유사한 패턴을 사용할 수 있습니다. 변형 이름 뒤에 중괄호를 넣고 변수와 함께 필드들을 나열하여, 해당 가지의 코드에서 사용할 수 있도록 조각들을 분리해 냅니다. 여기서는 목록 19-13에서 했던 것처럼 단축 형태를 사용합니다.</p>
<p>하나의 요소를 가진 튜플을 담는 <code>Message::Write</code>나 세 개의 요소를 가진 튜플을 담는 <code>Message::ChangeColor</code>와 같은 튜플 형태의 열거형 변형의 경우, 패턴은 튜플을 매칭할 때 지정하는 패턴과 유사합니다. 패턴 내 변수의 개수는 매칭하려는 변형의 요소 개수와 일치해야 합니다.</p>
<h4 id="중첩된-구조체와-열거형-구조분해하기"><a class="header" href="#중첩된-구조체와-열거형-구조분해하기">중첩된 구조체와 열거형 구조분해하기</a></h4>
<p>지금까지의 예제들은 모두 한 단계 깊이의 구조체나 열거형을 매칭하는 것이었지만, 매칭은 중첩된 아이템에 대해서도 작동할 수 있습니다! 예를 들어, 목록 19-16에 나타난 것처럼 <code>ChangeColor</code> 메시지에서 RGB와 HSV 색상을 지원하도록 목록 19-15의 코드를 리팩터링할 수 있습니다.</p>
<Listing number="19-16" caption="Matching on nested enums">
<pre><pre class="playground"><code class="language-rust edition2021">enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; {
            println!("색상을 빨간색 {r}, 녹색 {g}, 파란색 {b}으로 변경합니다");
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; {
            println!("색상을 색상 {h}, 채도 {s}, 명도 {v}로 변경합니다");
        }
        _ =&gt; (),
    }
}</code></pre></pre>
</Listing>
<p><code>match</code> 표현식의 첫 번째 가지 패턴은 <code>Color::Rgb</code> 변형을 포함하는 <code>Message::ChangeColor</code> 열거형 변형과 매치됩니다. 그런 다음 패턴은 세 개의 내부 <code>i32</code> 값에 바인딩됩니다. 두 번째 가지의 패턴 또한 <code>Message::ChangeColor</code> 열거형 변형과 매치되지만, 내부 열거형은 대신 <code>Color::Hsv</code>와 매치됩니다. 우리는 두 개의 열거형이 관련되어 있음에도 불구하고 하나의 <code>match</code> 표현식 내에서 이러한 복잡한 조건들을 지정할 수 있습니다.</p>
<h4 id="구조체와-튜플-구조분해하기"><a class="header" href="#구조체와-튜플-구조분해하기">구조체와 튜플 구조분해하기</a></h4>
<p>우리는 구조분해 패턴을 훨씬 더 복잡한 방식으로 섞고, 매치하고, 중첩할 수 있습니다. 다음 예제는 튜플 내부에 구조체와 튜플을 중첩시키고 모든 원시 값들을 구조분해하는 복잡한 구조분해를 보여줍니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    struct Point {
</span><span class="boring">        x: i32,
</span><span class="boring">        y: i32,
</span><span class="boring">    }
</span><span class="boring">
</span>    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
<span class="boring">}</span></code></pre></pre>
<p>이 코드는 복잡한 타입을 구성 요소별로 분해하여 우리가 관심 있는 값들을 개별적으로 사용할 수 있게 해줍니다.</p>
<p>패턴을 이용한 구조분해는 구조체의 각 필드 값과 같이 값의 조각들을 서로 개별적으로 사용할 수 있는 편리한 방법입니다.</p>
<h3 id="패턴에서-값-무시하기"><a class="header" href="#패턴에서-값-무시하기">패턴에서 값 무시하기</a></h3>
<p>여러분은 <code>match</code>의 마지막 가지에서처럼 패턴에서 값을 무시하는 것이 가끔 유용하다는 것을 보았습니다. 이는 실제로 아무것도 하지 않지만 나머지 모든 가능한 값들을 처리하는 포괄적인 처리를 얻기 위함입니다. 패턴에서 전체 값이나 값의 일부를 무시하는 방법에는 몇 가지가 있습니다: <code>_</code> 패턴 사용하기(이미 보았습니다), 다른 패턴 내에서 <code>_</code> 패턴 사용하기, 언더스코어로 시작하는 이름 사용하기, 또는 값의 나머지 부분을 무시하기 위해 <code>..</code> 사용하기가 그것입니다. 이 패턴들을 각각 어떻게 그리고 왜 사용하는지 알아봅시다.</p>
<h4 id="_로-전체-값-무시하기"><a class="header" href="#_로-전체-값-무시하기"><code>_</code>로 전체 값 무시하기</a></h4>
<p>우리는 어떤 값과도 매치되지만 값에 바인딩되지는 않는 와일드카드 패턴으로 언더스코어를 사용해 왔습니다. 이는 특히 <code>match</code> 표현식의 마지막 가지로서 유용하지만, 목록 19-17에 나타난 것처럼 함수 매개변수를 포함한 모든 패턴에서 사용할 수 있습니다.</p>
<Listing number="19-17" file-name="src/main.rs" caption="Using `_` in a function signature">
<pre><pre class="playground"><code class="language-rust edition2021">fn foo(_: i32, y: i32) {
    println!("이 코드는 오직 y 매개변수만 사용합니다: {y}");
}

fn main() {
    foo(3, 4);
}</code></pre></pre>
</Listing>
<p>이 코드는 첫 번째 인수로 전달된 값 <code>3</code>을 완전히 무시하고, <code>이 코드는 오직 y 매개변수만 사용합니다: 4</code>를 출력할 것입니다.</p>
<p>대부분의 경우 특정 함수 매개변수가 더 이상 필요하지 않다면, 사용하지 않는 매개변수를 포함하지 않도록 시그니처를 변경할 것입니다. 함수 매개변수를 무시하는 것은 예를 들어, 특정 타입 시그니처가 필요한 트레이트를 구현하지만 구현부의 함수 본문에서는 매개변수 중 하나가 필요하지 않은 경우에 특히 유용할 수 있습니다. 그러면 대신 이름을 사용했을 때와 달리 사용하지 않는 함수 매개변수에 대한 컴파일러 경고를 피할 수 있습니다.</p>
<h4 id="중첩된-_로-값의-일부-무시하기"><a class="header" href="#중첩된-_로-값의-일부-무시하기">중첩된 <code>_</code>로 값의 일부 무시하기</a></h4>
<p>또한 값의 일부만 테스트하고 싶지만 실행하려는 해당 코드에서 다른 부분은 사용할 필요가 없을 때, 다른 패턴 내부에서 <code>_</code>를 사용하여 값의 일부만 무시할 수 있습니다. 목록 19-18은 설정값을 관리하는 코드를 보여줍니다. 비즈니스 요구사항은 사용자가 설정의 기존 커스터마이징을 덮어쓰는 것은 허용되지 않지만, 현재 설정이 해제되어 있다면 설정을 해제하거나 값을 줄 수 있어야 한다는 것입니다.</p>
<Listing number="19-18" caption=" Using an underscore within patterns that match `Some` variants when we don’t need to use the value inside the `Some`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut setting_value = Some(5);
    let new_setting_value = Some(10);

    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) =&gt; {
            println!("기존의 커스터마이징된 값을 덮어쓸 수 없습니다");
        }
        _ =&gt; {
            setting_value = new_setting_value;
        }
    }

    println!("설정은 {setting_value:?}입니다");
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 코드는 <code>기존의 커스터마이징된 값을 덮어쓸 수 없습니다</code>를 출력한 다음 <code>설정은 Some(5)입니다</code>를 출력할 것입니다. 첫 번째 매치 가지에서, 우리는 어느 <code>Some</code> 변형 내부의 값에 대해서도 매칭하거나 사용할 필요가 없지만, <code>setting_value</code>와 <code>new_setting_value</code>가 모두 <code>Some</code> 변형인 경우를 테스트할 필요는 있습니다. 그 경우 <code>setting_value</code>를 변경하지 않는 이유를 출력하고, 값은 변경되지 않습니다.</p>
<p>두 번째 가지의 <code>_</code> 패턴으로 표현된 모든 다른 경우(<code>setting_value</code>나 <code>new_setting_value</code> 중 하나라도 <code>None</code>인 경우)에는 <code>new_setting_value</code>가 <code>setting_value</code>가 되는 것을 허용하고 싶습니다.</p>
<p>또한 특정 값들을 무시하기 위해 하나의 패턴 내 여러 곳에서 언더스코어를 사용할 수 있습니다. 목록 19-19는 5개의 아이템을 가진 튜플에서 두 번째와 네 번째 값을 무시하는 예제를 보여줍니다.</p>
<Listing number="19-19" caption="Ignoring multiple parts of a tuple">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) =&gt; {
            println!("어떤 숫자들: {first}, {third}, {fifth}")
        }
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 코드는 <code>어떤 숫자들: 2, 8, 32</code>를 출력하고, 값 4와 16은 무시될 것입니다.</p>
<h4 id="변수-이름을-_로-시작하여-사용하지-않는-변수-무시하기"><a class="header" href="#변수-이름을-_로-시작하여-사용하지-않는-변수-무시하기">변수 이름을 <code>_</code>로 시작하여 사용하지 않는 변수 무시하기</a></h4>
<p>변수를 만들고 어디에서도 사용하지 않는다면, 사용하지 않는 변수는 버그일 가능성이 있기 때문에 러스트는 보통 경고를 보냅니다. 하지만 프로토타이핑을 하거나 프로젝트를 막 시작했을 때처럼, 아직 사용하지 않을 변수를 미리 만들어두는 것이 유용할 때가 있습니다. 이런 상황에서는 변수 이름을 언더스코어로 시작함으로써 러스트에게 해당 변수에 대해 경고하지 말라고 말할 수 있습니다. 목록 19-20에서 우리는 두 개의 사용하지 않는 변수를 생성하지만, 이 코드를 컴파일하면 오직 그중 하나에 대해서만 경고를 받게 될 것입니다.</p>
<Listing number="19-20" file-name="src/main.rs" caption="Starting a variable name with an underscore to avoid getting unused variable warnings">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let _x = 5;
    let y = 10;
}</code></pre></pre>
</Listing>
<p>여기서 우리는 변수 <code>y</code>를 사용하지 않았다는 경고를 받지만, <code>_x</code>를 사용하지 않았다는 경고는 받지 않습니다.</p>
<p>단순히 <code>_</code>만 사용하는 것과 언더스코어로 시작하는 이름을 사용하는 것 사이에는 미묘한 차이가 있음에 주의하세요. <code>_x</code> 문법은 여전히 값을 변수에 바인딩하지만, <code>_</code>는 전혀 바인딩하지 않습니다. 이 구분이 중요한 사례를 보여주기 위해, 목록 19-21은 우리에게 에러를 발생시킬 것입니다.</p>
<Listing number="19-21" caption="An unused variable starting with an underscore still binds the value, which might take ownership of the value">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s = Some(String::from("Hello!"));

    if let Some(_s) = s {
        println!("문자열을 발견했습니다");
    }

    println!("{s:?}");
<span class="boring">}</span></code></pre>
</Listing>
<p>우리는 <code>s</code> 값이 여전히 <code>_s</code>로 이동(move)되어 <code>s</code>를 다시 사용할 수 없게 되기 때문에 에러를 받게 됩니다. 하지만 언더스코어 그 자체를 사용하는 것은 값에 바인딩되지 않습니다. 목록 19-22는 <code>s</code>가 <code>_</code>로 이동되지 않기 때문에 아무런 에러 없이 컴파일될 것입니다.</p>
<Listing number="19-22" caption="Using an underscore does not bind the value">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s = Some(String::from("Hello!"));

    if let Some(_) = s {
        println!("문자열을 발견했습니다");
    }

    println!("{s:?}");
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 코드는 우리가 <code>s</code>를 어디에도 바인딩하지 않았으므로 잘 작동합니다. 즉, 이동되지 않았습니다.</p>
<h4 id="를-사용하여-값의-나머지-부분-무시하기"><a class="header" href="#를-사용하여-값의-나머지-부분-무시하기"><code>..</code>를 사용하여 값의 나머지 부분 무시하기</a></h4>
<p>많은 부분을 가진 값의 경우, <code>..</code> 문법을 사용하여 특정 부분만 사용하고 나머지는 무시할 수 있습니다. 이를 통해 무시할 각 값에 대해 언더스코어를 나열해야 하는 수고를 덜 수 있습니다. <code>..</code> 패턴은 패턴의 나머지 부분에서 명시적으로 매칭하지 않은 값의 모든 부분을 무시합니다. 목록 19-23에서는 3차원 공간의 좌표를 담는 <code>Point</code> 구조체가 있습니다. <code>match</code> 표현식에서 우리는 오직 <code>x</code> 좌표에 대해서만 작업하고 <code>y</code>와 <code>z</code> 필드의 값은 무시하고 싶습니다.</p>
<Listing number="19-23" caption="Ignoring all fields of a `Point` except for `x` by using `..`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } =&gt; println!("x는 {x}입니다"),
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>우리는 <code>x</code> 값을 나열하고 그 뒤에 단순히 <code>..</code> 패턴을 포함시킵니다. 이는 <code>y: _</code>와 <code>z: _</code>를 일일이 나열하는 것보다 빠릅니다. 특히 필드가 아주 많은 구조체에서 오직 한두 개의 필드만이 관련이 있는 상황에서 작업할 때 유용합니다.</p>
<p><code>..</code> 문법은 필요한 만큼의 많은 값으로 확장될 것입니다. 목록 19-24는 튜플과 함께 <code>..</code>를 사용하는 방법을 보여줍니다.</p>
<Listing number="19-24" file-name="src/main.rs" caption="Matching only the first and last values in a tuple and ignoring all other values">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!("어떤 숫자들: {first}, {last}");
        }
    }
}</code></pre></pre>
</Listing>
<p>이 코드에서 첫 번째와 마지막 값은 <code>first</code>와 <code>last</code>에 매치됩니다. <code>..</code>은 중간에 있는 모든 것을 매치하고 무시할 것입니다.</p>
<p>하지만 <code>..</code> 사용은 모호하지 않아야 합니다. 어떤 값이 매칭을 위한 것이고 어떤 값이 무시되어야 하는지가 불명확하다면, 러스트는 에러를 발생시킵니다. 목록 19-25는 <code>..</code>를 모호하게 사용한 예제를 보여주며, 이 코드는 컴파일되지 않습니다.</p>
<Listing number="19-25" file-name="src/main.rs" caption="An attempt to use `..` in an ambiguous way">
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!("어떤 숫자들: {second}")
        },
    }
}</code></pre>
</Listing>
<p>이 예제를 컴파일하면 다음과 같은 에러를 얻게 됩니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error: `..`은 튜플 패턴당 한 번만 사용할 수 있습니다
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |          --          ^^ 튜플 패턴당 한 번만 사용할 수 있습니다
  |          |
  |          이전에 여기서 사용되었습니다

error: 1개의 이전 에러로 인해 `patterns` (바이너리 "patterns")를 컴파일할 수 없습니다
</code></pre>
<p>러스트가 <code>second</code>와 매치하기 전에 튜플에서 얼마나 많은 값을 무시해야 할지, 그리고 그 후에 얼마나 더 많은 값을 무시해야 할지 결정하는 것은 불가능합니다. 이 코드는 <code>2</code>를 무시하고 <code>second</code>를 <code>4</code>에 바인딩한 다음 <code>8</code>, <code>16</code>, <code>32</code>를 무시하겠다는 의미일 수도 있고, <code>2</code>와 <code>4</code>를 무시하고 <code>second</code>를 <code>8</code>에 바인딩한 다음 <code>16</code>과 <code>32</code>를 무시하겠다는 의미일 수도 있는 등 그 해석이 다양합니다. 변수 이름 <code>second</code>는 러스트에게 특별한 의미가 없으므로, 이와 같이 두 곳에서 <code>..</code>를 사용하는 것은 모호하여 컴파일러 에러가 발생합니다.</p>
<h3 id="매치-가드를-이용한-추가-조건"><a class="header" href="#매치-가드를-이용한-추가-조건">매치 가드를 이용한 추가 조건</a></h3>
<p>_매치 가드(match guard)_는 <code>match</code> 가지의 패턴 뒤에 지정되는 추가적인 <code>if</code> 조건으로, 해당 가지가 선택되기 위해 패턴 매칭과 함께 이 조건도 만족되어야 합니다. 매치 가드는 패턴만으로는 표현할 수 없는 더 복잡한 개념을 표현할 때 유용합니다. 매치 가드는 <code>match</code> 표현식에서만 사용할 수 있으며, <code>if let</code>이나 <code>while let</code> 표현식에서는 사용할 수 없습니다.</p>
<p>매치 가드의 조건에서는 패턴에서 생성된 변수를 사용할 수 있습니다. 목록 19-26은 첫 번째 가지가 <code>Some(x)</code> 패턴을 가지면서 <code>if x % 2 == 0</code>(숫자가 짝수라면 참)이라는 매치 가드도 가지고 있는 <code>match</code>를 보여줍니다.</p>
<Listing number="19-26" caption="Adding a match guard to a pattern">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let num = Some(4);

    match num {
        Some(x) if x % 2 == 0 =&gt; println!("숫자 {x}는 짝수입니다"),
        Some(x) =&gt; println!("숫자 {x}는 홀수입니다"),
        None =&gt; (),
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 예제는 <code>숫자 4는 짝수입니다</code>를 출력할 것입니다. <code>num</code>이 첫 번째 가지의 패턴과 비교될 때 <code>Some(4)</code>는 <code>Some(x)</code>와 매치되므로 매칭에 성공합니다. 그다음 매치 가드가 <code>x</code>를 2로 나눈 나머지가 0인지 확인하고, 참이므로 첫 번째 가지가 선택됩니다.</p>
<p>만약 <code>num</code>이 대신 <code>Some(5)</code>였다면, 첫 번째 가지의 매치 가드는 5를 2로 나눈 나머지가 1(0이 아님)이므로 거짓이 되었을 것입니다. 그러면 러스트는 두 번째 가지로 이동할 것이고, 두 번째 가지는 매치 가드가 없으므로 모든 <code>Some</code> 변형과 매치됩니다.</p>
<p>패턴 내에서는 <code>if x % 2 == 0</code> 조건을 표현할 방법이 없으므로, 매치 가드는 이러한 로직을 표현할 수 있는 능력을 제공합니다. 이러한 추가적인 표현력의 단점은 매치 가드 표현식이 포함될 때 컴파일러가 철저함(exhaustiveness) 검사를 시도하지 않는다는 점입니다.</p>
<p>목록 19-11에서 우리는 패턴 섀도잉 문제를 해결하기 위해 매치 가드를 사용할 수 있다고 언급했습니다. <code>match</code> 표현식 외부의 변수를 사용하는 대신 <code>match</code> 내의 패턴 안에서 새로운 변수를 생성했던 것을 기억해 보세요. 그 새로운 변수는 외부 변수의 값에 대해 테스트할 수 없음을 의미했습니다. 목록 19-27은 매치 가드를 사용하여 이 문제를 해결하는 방법을 보여줍니다.</p>
<Listing number="19-27" file-name="src/main.rs" caption="Using a match guard to test for equality with an outer variable">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!("50을 얻었습니다"),
        Some(n) if n == y =&gt; println!("매치됨, n = {n}"),
        _ =&gt; println!("기본 케이스, x = {x:?}"),
    }

    println!("마지막에: x = {x:?}, y = {y}");
}</code></pre></pre>
</Listing>
<p>이제 이 코드는 <code>기본 케이스, x = Some(5)</code>을 출력할 것입니다. 두 번째 매치 가지의 패턴은 외부의 <code>y</code>를 섀도잉할 새로운 변수 <code>y</code>를 도입하지 않으므로, 매치 가드에서 외부의 <code>y</code>를 사용할 수 있습니다. 외부의 <code>y</code>를 섀도잉했을 <code>Some(y)</code>로 패턴을 지정하는 대신, 우리는 <code>Some(n)</code>을 지정합니다. 이는 <code>match</code> 외부에 <code>n</code> 변수가 없으므로 아무것도 섀도잉하지 않는 새로운 변수 <code>n</code>을 생성합니다.</p>
<p>매치 가드 <code>if n == y</code>는 패턴이 아니므로 새로운 변수를 도입하지 않습니다. 이 <code>y</code>는 새로운 <code>y</code>가 섀도잉하는 것이 아니라 <em>외부의</em> <code>y</code>이며, 우리는 <code>n</code>과 <code>y</code>를 비교함으로써 외부의 <code>y</code>와 동일한 값을 가진 값을 찾을 수 있습니다.</p>
<p>매치 가드에서 <em>or</em> 연산자인 <code>|</code>를 사용하여 여러 패턴을 지정할 수도 있습니다. 이때 매치 가드 조건은 모든 패턴에 적용됩니다. 목록 19-28은 <code>|</code>를 사용하는 패턴과 매치 가드를 결합할 때의 우선순위를 보여줍니다. 이 예제의 중요한 점은 <code>if y</code> 매치 가드가 비록 <code>6</code>에만 적용되는 것처럼 보일지라도, <code>4</code>, <code>5</code>, <em>그리고</em> <code>6</code> 모두에 적용된다는 것입니다.</p>
<Listing number="19-28" caption="Combining multiple patterns with a match guard">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 4;
    let y = false;

    match x {
        4 | 5 | 6 if y =&gt; println!("네"),
        _ =&gt; println!("아니요"),
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>매치 조건은 <code>x</code>의 값이 <code>4</code>, <code>5</code>, 또는 <code>6</code>과 같고 <em>동시에</em> <code>y</code>가 <code>true</code>인 경우에만 해당 가지가 매치된다고 명시합니다. 이 코드가 실행될 때, <code>x</code>가 <code>4</code>이므로 첫 번째 가지의 패턴은 매치되지만, 매치 가드 <code>if y</code>가 거짓이므로 첫 번째 가지는 선택되지 않습니다. 코드는 두 번째 가지로 넘어가고, 이는 매치되므로 이 프로그램은 <code>no</code>를 출력합니다. 그 이유는 <code>if</code> 조건이 마지막 값인 <code>6</code>뿐만 아니라 전체 패턴 <code>4 | 5 | 6</code>에 적용되기 때문입니다. 다시 말해, 패턴과 관련된 매치 가드의 우선순위는 다음과 같이 동작합니다.</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<p>다음과 같이 동작하는 것이 아닙니다.</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<p>코드를 실행해 보면 우선순위 동작이 분명해집니다. 만약 매치 가드가 <code>|</code> 연산자를 사용하여 지정된 값 목록의 마지막 값에만 적용되었다면, 그 가지는 매치되었을 것이고 프로그램은 <code>yes</code>를 출력했을 것입니다.</p>
<h3 id="-바인딩"><a class="header" href="#-바인딩"><code>@</code> 바인딩</a></h3>
<p><em>at</em> 연산자인 <code>@</code>를 사용하면 어떤 값이 패턴과 매치되는지 테스트하는 동시에, 그 값을 보관할 변수를 생성할 수 있습니다. 목록 19-29에서 우리는 <code>Message::Hello</code>의 <code>id</code> 필드가 <code>3..=7</code> 범위 내에 있는지 테스트하고 싶습니다. 또한 그 값을 <code>id_variable</code> 변수에 바인딩하여 해당 가지와 관련된 코드에서 사용하고 싶습니다. 이 변수 이름을 필드 이름과 동일하게 <code>id</code>라고 지을 수도 있지만, 이 예제에서는 다른 이름을 사용하겠습니다.</p>
<Listing number="19-29" caption="Using `@` to bind to a value in a pattern while also testing it">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } =&gt; println!("범위 내의 id를 발견했습니다: {id_variable}"),
        Message::Hello { id: 10..=12 } =&gt; {
            println!("다른 범위의 id를 발견했습니다")
        }
        Message::Hello { id } =&gt; println!("다른 id를 발견했습니다: {id}"),
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 예제는 <code>범위 내의 id를 발견했습니다: 5</code>를 출력할 것입니다. 범위 <code>3..=7</code> 앞에 <code>id_variable @</code>를 지정함으로써, 해당 범위에 매치되는 어떤 값이든 캡처하는 동시에 그 값이 범위 패턴에 매치되는지 테스트하고 있습니다.</p>
<p>패턴에 범위만 지정된 두 번째 가지에서는, 가지와 관련된 코드에 <code>id</code> 필드의 실제 값을 담고 있는 변수가 없습니다. <code>id</code> 필드의 값은 10, 11, 또는 12였을 수 있지만, 해당 패턴과 연관된 코드는 그것이 무엇인지 알 수 없습니다. 우리는 <code>id</code> 값을 변수에 저장하지 않았기 때문에, 패턴 코드에서 <code>id</code> 필드의 값을 사용할 수 없습니다.</p>
<p>범위 없이 변수만 지정된 마지막 가지에서는, <code>id</code>라는 이름의 변수를 통해 가지의 코드에서 사용할 수 있는 값을 가집니다. 그 이유는 구조체 필드 단축 문법을 사용했기 때문입니다. 하지만 이 가지에서는 처음 두 가지에서 했던 것처럼 <code>id</code> 필드의 값에 대해 어떠한 테스트도 적용하지 않았습니다. 즉, 어떤 값이라도 이 패턴과 매치될 것입니다.</p>
<p><code>@</code>를 사용하면 하나의 패턴 내에서 값을 테스트하는 동시에 변수에 저장할 수 있습니다.</p>
<h2 id="요약-18"><a class="header" href="#요약-18">요약</a></h2>
<p>러스트의 패턴은 서로 다른 종류의 데이터를 구분하는 데 매우 유용합니다. <code>match</code> 표현식에서 사용될 때, 러스트는 패턴이 모든 가능한 값을 커버하도록 보장하며, 그렇지 않으면 프로그램이 컴파일되지 않습니다. <code>let</code> 문과 함수 매개변수에서의 패턴은 이러한 구문들을 더욱 유용하게 만들어주며, 값을 더 작은 조각으로 구조분해하고 그 조각들을 변수에 할당할 수 있게 해줍니다. 우리는 필요에 따라 단순하거나 복잡한 패턴을 만들 수 있습니다.</p>
<p>다음으로, 이 책의 마지막에서 두 번째 장에서는 러스트의 다양한 기능들에 대한 몇 가지 고급 측면들을 살펴보겠습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="고급-기능"><a class="header" href="#고급-기능">고급 기능</a></h1>
<p>이제 여러분은 러스트 프로그래밍 언어에서 가장 흔히 사용되는 부분들을 배웠습니다. 21장에서 마지막 프로젝트를 하나 더 수행하기 전에, 가끔 마주칠 수는 있지만 매일 사용하지는 않을 수도 있는 언어의 몇 가지 측면들을 살펴보겠습니다. 여러분은 이 장을 알지 못하는 것을 발견했을 때를 위한 참고 자료로 사용할 수 있습니다. 여기서 다루는 기능들은 매우 특정한 상황에서 유용합니다. 비록 자주 사용하게 되지는 않더라도, 러스트가 제공하는 모든 기능들에 대해 파악하고 있기를 바랍니다.</p>
<p>이 장에서는 다음 내용을 다룹니다:</p>
<ul>
<li>안전하지 않은 러스트(Unsafe Rust): 러스트의 일부 보증을 거부하고 해당 보증을 수동으로 유지하는 책임을 지는 방법</li>
<li>고급 트레이트: 연관 타입(associated types), 기본 타입 매개변수, 완전 정규화 문법(fully qualified syntax), 슈퍼트레이트(supertraits), 그리고 트레이트와 관련된 뉴타입(newtype) 패턴</li>
<li>고급 타입: 뉴타입 패턴에 대한 자세한 내용, 타입 별칭(type aliases), 네버 타입(never type), 그리고 동적 크기 타입(dynamically sized types)</li>
<li>고급 함수와 클로저: 함수 포인터와 클로저 반환하기</li>
<li>매크로: 컴파일 타임에 더 많은 코드를 정의하는 코드를 정의하는 방법들</li>
</ul>
<p>모두를 위한 러스트의 다양한 기능들입니다! 자, 시작해 봅시다!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="안전하지-않은-러스트"><a class="header" href="#안전하지-않은-러스트">안전하지 않은 러스트</a></h2>
<p>지금까지 논의한 모든 코드는 컴파일 타임에 러스트의 메모리 안전성 보증이 강제되었습니다. 하지만 러스트의 내부에는 이러한 메모리 안전성 보증을 강제하지 않는 두 번째 언어가 숨어 있습니다. 이것을 _안전하지 않은 러스트(unsafe Rust)_라고 부르며, 일반적인 러스트와 똑같이 작동하지만 우리에게 추가적인 초능력을 부여합니다.</p>
<p>안전하지 않은 러스트가 존재하는 이유는 본질적으로 정적 분석이 보수적이기 때문입니다. 컴파일러가 코드가 보증을 유지하는지 여부를 판단할 때, 일부 유효하지 않은 프로그램을 허용하는 것보다 일부 유효한 프로그램을 거부하는 것이 낫습니다. 코드가 <em>괜찮을 수도</em> 있지만, 러스트 컴파일러가 확신할 수 있는 충분한 정보를 가지고 있지 않다면 코드를 거부할 것입니다. 이런 경우, 여러분은 unsafe 코드를 사용하여 컴파일러에게 "나를 믿어라, 내가 무엇을 하고 있는지 알고 있다"라고 말할 수 있습니다. 하지만 안전하지 않은 러스트를 사용하는 것은 본인의 책임이라는 점을 유의하세요. unsafe 코드를 잘못 사용하면 널 포인터 역참조와 같은 메모리 불안전성으로 인해 문제가 발생할 수 있습니다.</p>
<p>러스트가 안전하지 않은 또 다른 자아를 가진 이유는 기저의 컴퓨터 하드웨어가 본질적으로 안전하지 않기 때문입니다. 러스트가 unsafe 연산을 허용하지 않는다면, 여러분은 특정한 작업들을 수행할 수 없을 것입니다. 러스트는 운영체제와 직접 상호작용하거나 심지어 자신만의 운영체제를 작성하는 것과 같은 저수준 시스템 프로그래밍을 허용해야 합니다. 저수준 시스템 프로그래밍 작업을 가능하게 하는 것은 이 언어의 목표 중 하나입니다. 안전하지 않은 러스트로 무엇을 할 수 있고, 어떻게 하는지 알아봅시다.</p>
<h3 id="안전하지-않은-초능력"><a class="header" href="#안전하지-않은-초능력">안전하지 않은 초능력</a></h3>
<p>안전하지 않은 러스트로 전환하려면 <code>unsafe</code> 키워드를 사용하고, unsafe 코드를 담을 새로운 블록을 시작하세요. 안전한 러스트에서는 할 수 없지만 안전하지 않은 러스트에서는 할 수 있는 다섯 가지 동작이 있으며, 우리는 이를 _안전하지 않은 초능력(unsafe superpowers)_이라고 부릅니다. 이 초능력들은 다음과 같은 능력을 포함합니다.</p>
<ul>
<li>원시 포인터(raw pointer)를 역참조하기</li>
<li>안전하지 않은 함수 또는 메서드 호출하기</li>
<li>가변 정적 변수(mutable static variable)에 접근하거나 수정하기</li>
<li>안전하지 않은 트레이트 구현하기</li>
<li><code>union</code>의 필드에 접근하기</li>
</ul>
<p><code>unsafe</code>가 빌림 검사기(borrow checker)를 끄거나 러스트의 다른 안전성 검사를 비활성화하지 않는다는 점을 이해하는 것이 중요합니다. unsafe 코드에서 참조를 사용하더라도 그것은 여전히 검사됩니다. <code>unsafe</code> 키워드는 컴파일러가 메모리 안전성을 검사하지 않는 이 다섯 가지 기능에 대한 접근 권한만을 부여할 뿐입니다. 여러분은 여전히 unsafe 블록 내부에서도 어느 정도의 안전성을 보장받을 수 있습니다.</p>
<p>또한 <code>unsafe</code>가 해당 블록 내부의 코드가 반드시 위험하거나 무조건 메모리 안전성 문제를 일으킬 것이라는 의미는 아닙니다. 프로그래머로서 여러분이 <code>unsafe</code> 블록 내부의 코드가 유효한 방식으로 메모리에 접근함을 보장하겠다는 의도입니다.</p>
<p>사람은 실수할 수 있고 잘못은 일어나기 마련입니다. 하지만 이 다섯 가지 unsafe 작업을 <code>unsafe</code>로 표시된 블록 내부에 있도록 강제함으로써, 여러분은 메모리 안전성과 관련된 모든 에러가 반드시 <code>unsafe</code> 블록 내에 있음을 알 수 있게 됩니다. <code>unsafe</code> 블록을 작게 유지하세요. 나중에 메모리 버그를 조사할 때 그렇게 하길 잘했다고 생각하게 될 것입니다.</p>
<p>To isolate unsafe code as much as possible, it’s best to enclose unsafe code within a safe abstraction and provide a safe API, which we’ll discuss later in the chapter when we examine unsafe functions and methods. Parts of the standard library are implemented as safe abstractions over unsafe code that has been audited. Wrapping unsafe code in a safe abstraction prevents uses of <code>unsafe</code> from leaking out into all the places that you or your users might want to use the functionality implemented with <code>unsafe</code> code, because using a safe abstraction is safe.</p>
<p>이제 다섯 가지 안전하지 않은 초능력을 하나씩 살펴보겠습니다. 또한 unsafe 코드에 대한 안전한 인터페이스를 제공하는 몇 가지 추상화에 대해서도 알아보겠습니다.</p>
<h3 id="원시-포인터-역참조하기"><a class="header" href="#원시-포인터-역참조하기">원시 포인터 역참조하기</a></h3>
<p>4장의 <a href="ch04-02-references-and-borrowing.html#dangling-references">“대롱거리는 참조”</a><!-- ignore --> 섹션에서 우리는 컴파일러가 참조가 항상 유효함을 보장한다고 언급했습니다. 안전하지 않은 러스트에는 참조와 유사한 _원시 포인터(raw pointers)_라고 불리는 두 가지 새로운 타입이 있습니다. 참조와 마찬가지로 원시 포인터도 불변이거나 가변일 수 있으며, 각각 <code>*const T</code>와 <code>*mut T</code>로 작성됩니다. 여기서 별표는 역참조 연산자가 아니라 타입 이름의 일부입니다. 원시 포인터의 맥락에서 _불변_이란 포인터가 역참조된 후에 직접 값을 할당할 수 없음을 의미합니다.</p>
<p>참조나 스마트 포인터와 달리 원시 포인터는 다음과 같은 특징을 갖습니다.</p>
<ul>
<li>동일한 위치에 대해 불변 포인터와 가변 포인터를 동시에 갖거나, 여러 개의 가변 포인터를 가짐으로써 빌림 규칙을 무시할 수 있습니다.</li>
<li>유효한 메모리를 가리킨다는 보장이 없습니다</li>
<li>널(null)이 될 수 있습니다</li>
<li>어떠한 자동 정리 기능도 구현하지 않습니다</li>
</ul>
<p>러스트가 이러한 보증을 강제하는 것을 거부함으로써, 여러분은 보장된 안전성을 포기하는 대신 더 높은 성능을 얻거나 러스트의 보증이 적용되지 않는 다른 언어 또는 하드웨어와 인터페이스할 수 있는 능력을 얻을 수 있습니다.</p>
<p>목록 20-1은 불변 원시 포인터와 가변 원시 포인터를 만드는 방법을 보여줍니다.</p>
<Listing number="20-1" caption="Creating raw pointers with the raw borrow operators">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;raw const num;
    let r2 = &amp;raw mut num;
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 코드에는 <code>unsafe</code> 키워드가 포함되어 있지 않음에 주목하세요. 우리는 안전한 코드에서도 원시 포인터를 생성할 수 있습니다. 잠시 후에 보게 되겠지만, 단지 unsafe 블록 외부에서 원시 포인터를 역참조할 수 없을 뿐입니다.</p>
<p>우리는 원시 빌림 연산자(raw borrow operators)를 사용하여 원시 포인터를 생성했습니다. <code>&amp;raw const num</code>은 <code>*const i32</code> 불변 원시 포인터를 생성하고, <code>&amp;raw mut num</code>은 <code>*mut i32</code> 가변 원시 포인터를 생성합니다. 우리는 지역 변수로부터 직접 생성했기 때문에 이 특정한 원시 포인터들이 유효하다는 것을 알고 있지만, 모든 원시 포인터에 대해 그러한 가정을 할 수는 없습니다.</p>
<p>이를 시연하기 위해, 다음으로는 원시 참조 연산자를 사용하는 대신 <code>as</code>를 사용하여 값을 캐스팅함으로써 유효성을 확신할 수 없는 원시 포인터를 생성해 보겠습니다. 목록 20-2는 메모리의 임의 지점에 대한 원시 포인터를 생성하는 방법을 보여줍니다. 임의의 메모리를 사용하려는 시도는 정의되지 않은 동작(undefined)입니다. 해당 주소에 데이터가 있을 수도 있고 없을 수도 있으며, 컴파일러가 메모리 접근이 없도록 코드를 최적화할 수도 있고, 프로그램이 세그멘테이션 결함(segmentation fault) 에러를 내며 종료될 수도 있습니다. 보통 이런 식의 코드를 작성할 좋은 이유는 없으며, 특히 원시 빌림 연산자를 대신 사용할 수 있는 경우에는 더욱 그렇습니다. 하지만 어쨌든 가능은 합니다.</p>
<Listing number="20-2" caption="Creating a raw pointer to an arbitrary memory address">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let address = 0x012345usize;
    let r = address as *const i32;
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>앞서 말했듯 안전한 코드에서도 원시 포인터를 생성할 수는 있지만, 원시 포인터를 _역참조_하여 가리키는 데이터를 읽을 수는 없습니다. 목록 20-3에서는 <code>unsafe</code> 블록이 필요한 원시 포인터에 역참조 연산자 <code>*</code>를 사용합니다.</p>
<Listing number="20-3" caption="Dereferencing raw pointers within an `unsafe` block">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;raw const num;
    let r2 = &amp;raw mut num;

    unsafe {
        println!("r1은: {}"입니다, *r1);
        println!("r2는: {}"입니다, *r2);
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>포인터를 생성하는 것 자체는 해롭지 않습니다. 포인터가 가리키는 값에 접근하려고 시도할 때 비로소 유효하지 않은 값을 다루게 될 위험이 생기는 것입니다.</p>
<p>또한 목록 20-1과 20-3에서 우리는 <code>num</code>이 저장된 동일한 메모리 위치를 가리키는 <code>*const i32</code>와 <code>*mut i32</code> 원시 포인터를 생성했음에 주목하세요. 만약 대신 <code>num</code>에 대한 불변 참조와 가변 참조를 생성하려 했다면, 러스트의 소유권 규칙이 불변 참조가 존재하는 동안 가변 참조를 허용하지 않기 때문에 코드가 컴파일되지 않았을 것입니다. 원시 포인터를 사용하면 동일한 위치에 대해 가변 포인터와 불변 포인터를 동시에 생성할 수 있고 가변 포인터를 통해 데이터를 변경할 수 있으므로, 잠재적으로 데이터 경합(data race)이 발생할 수 있습니다. 주의하세요!</p>
<p>이러한 모든 위험에도 불구하고 왜 원시 포인터를 사용할까요? 한 가지 주요 사용 사례는 다음 섹션인 <a href="ch20-01-unsafe-rust.html#calling-an-unsafe-function-or-method">“안전하지 않은 함수 또는 메서드 호출하기”</a><!-- ignore -->에서 보게 될 C 코드와의 인터페이스입니다. 또 다른 사례는 빌림 검사기가 이해하지 못하는 안전한 추상화를 구축할 때입니다. 먼저 unsafe 함수를 소개한 다음, unsafe 코드를 사용하는 안전한 추상화의 예제를 살펴보겠습니다.</p>
<h3 id="안전하지-않은-함수-또는-메서드-호출하기"><a class="header" href="#안전하지-않은-함수-또는-메서드-호출하기">안전하지 않은 함수 또는 메서드 호출하기</a></h3>
<p>unsafe 블록에서 수행할 수 있는 두 번째 유형의 작업은 unsafe 함수를 호출하는 것입니다. unsafe 함수와 메서드는 일반적인 함수 및 메서드와 똑같이 생겼지만, 정의부 앞에 <code>unsafe</code>가 추가로 붙습니다. 이 맥락에서 <code>unsafe</code> 키워드는 러스트가 우리가 해당 요구사항을 충족했는지 보장할 수 없기 때문에, 이 함수를 호출할 때 우리가 지켜야 할 요구사항이 있음을 나타냅니다. <code>unsafe</code> 블록 내에서 unsafe 함수를 호출함으로써, 우리는 이 함수의 문서를 읽었으며 함수의 계약(contracts)을 준수할 책임을 지겠다고 선언하는 것입니다.</p>
<p>다음은 본문에서 아무것도 하지 않는 <code>dangerous</code>라는 이름의 unsafe 함수입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    unsafe fn dangerous() {}

    unsafe {
        dangerous();
    }
<span class="boring">}</span></code></pre></pre>
<p>우리는 <code>dangerous</code> 함수를 별도의 <code>unsafe</code> 블록 내에서 호출해야 합니다. 만약 <code>unsafe</code> 블록 없이 <code>dangerous</code>를 호출하려 하면, 다음과 같은 에러가 발생합니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0133]: unsafe 함수 `dangerous`를 호출하는 것은 안전하지 않으며
              unsafe 함수나 블록이 필요합니다
 --&gt; src/main.rs:4:5
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ unsafe 함수 호출
  |
  = note: 정의되지 않은 동작(undefined behavior)을 피하는 방법은 함수의
          문서를 참고하세요

이 에러에 대한 더 자세한 정보를 원하시면 `rustc --explain E0133`을 시도해 보세요.
에러: 1개의 이전 에러로 인해 `unsafe-example` (바이너리 "unsafe-example")를 컴파일할 수 없습니다
</code></pre>
<p><code>unsafe</code> 블록을 사용함으로써, 우리는 러스트에게 우리가 함수의 문서를 읽었으며, 함수를 올바르게 사용하는 법을 이해했고, 함수의 계약(contract)을 준수하고 있음을 확인했다고 단언하는 것입니다.</p>
<p>unsafe 함수의 본문에서 unsafe 작업을 수행할 때도 일반적인 함수 내에서와 마찬가지로 여전히 <code>unsafe</code> 블록을 사용해야 하며, 이를 잊는다면 컴파일러가 경고를 보낼 것입니다. 이는 unsafe 작업이 전체 함수 본문에 걸쳐 필요하지는 않을 수 있으므로, <code>unsafe</code> 블록을 가능한 한 작게 유지하는 데 도움이 됩니다.</p>
<h4 id="unsafe-코드에-대한-안전한-추상화-만들기"><a class="header" href="#unsafe-코드에-대한-안전한-추상화-만들기">unsafe 코드에 대한 안전한 추상화 만들기</a></h4>
<p>함수에 unsafe 코드가 포함되어 있다고 해서 함수 전체를 unsafe로 표시할 필요는 없습니다. 사실, unsafe 코드를 안전한 함수로 감싸는 것은 흔한 추상화 기법입니다. 예로서, 약간의 unsafe 코드가 필요한 표준 라이브러리의 <code>split_at_mut</code> 함수를 연구해 봅시다. 우리는 이 함수를 어떻게 구현할 수 있을지 탐구해 보겠습니다. 이 안전한 메서드는 가변 슬라이스에 정의되어 있습니다. 이는 하나의 슬라이스를 받아 인수로 주어진 인덱스에서 슬라이스를 쪼개어 두 개로 만듭니다. 목록 20-4는 <code>split_at_mut</code>을 사용하는 방법을 보여줍니다.</p>
<Listing number="20-4" caption="Using the safe `split_at_mut` function">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5, 6];

    let r = &amp;mut v[..];

    let (a, b) = r.split_at_mut(3);

    assert_eq!(a, &amp;mut [1, 2, 3]);
    assert_eq!(b, &amp;mut [4, 5, 6]);
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>우리는 오직 안전한 러스트만으로는 이 함수를 구현할 수 없습니다. 시도해 본다면 컴파일되지 않는 목록 20-5와 같은 모습이 될 것입니다. 단순함을 위해, 우리는 <code>split_at_mut</code>을 메서드가 아닌 함수로 구현할 것이며, 제네릭 타입 <code>T</code>가 아닌 <code>i32</code> 값의 슬라이스에 대해서만 구현하겠습니다.</p>
<Listing number="20-5" caption="An attempted implementation of `split_at_mut` using only safe Rust">
<pre><code class="language-rust ignore does_not_compile">fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();

    assert!(mid &lt;= len);

    (&amp;mut values[..mid], &amp;mut values[mid..])
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}</span></code></pre>
</Listing>
<p>이 함수는 먼저 슬라이스의 전체 길이를 가져옵니다. 그런 다음 매개변수로 주어진 인덱스가 슬라이스의 길이보다 작거나 같은지 확인함으로써 인덱스가 슬라이스 내에 있는지 단언(assert)합니다. 이 단언은 만약 슬라이스를 쪼개려는 위치인 인덱스가 길이보다 큰 값을 전달하면, 해당 인덱스를 사용하기 전에 함수가 패닉을 일으킬 것임을 의미합니다.</p>
<p>그다음 튜플로 두 개의 가변 슬라이스를 반환합니다. 하나는 원래 슬라이스의 시작부터 <code>mid</code> 인덱스까지이고, 다른 하나는 <code>mid</code>부터 슬라이스의 끝까지입니다.</p>
<p>목록 20-5의 코드를 컴파일하려 하면 에러가 발생합니다.</p>
<p>러스트의 대여 검사기는 우리가 슬라이스의 서로 다른 부분을 대여하고 있다는 것을 이해하지 못합니다. 단지 우리가 같은 슬라이스에서 두 번 대여하고 있다는 것만 알고 있습니다. 슬라이스의 서로 다른 부분을 대여하는 것은 두 슬라이스가 겹치지 않기 때문에 근본적으로 괜찮지만, 러스트는 이를 알 만큼 영리하지 않습니다. 코드가 괜찮다는 것을 우리가 알지만 러스트는 모를 때가 바로 안전하지 않은 코드를 사용해야 할 때입니다.Rust’s borrow checker can’t understand that we’re borrowing different parts of the slice; it only knows that we’re borrowing from the same slice twice. Borrowing different parts of a slice is fundamentally okay because the two slices aren’t overlapping, but Rust isn’t smart enough to know this. When we know code is okay, but Rust doesn’t, it’s time to reach for unsafe code.</p>
<p>예제 20-6은 <code>split_at_mut</code> 구현이 작동하도록 <code>unsafe</code> 블록, 원시 포인터, 그리고 몇 가지 안전하지 않은 함수 호출을 사용하는 방법을 보여줍니다.</p>
<Listing number="20-6" caption="Using unsafe code in the implementation of the `split_at_mut` function">
<pre><pre class="playground"><code class="language-rust edition2021">use std::slice;

fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();
    let ptr = values.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>4장의 <a href="ch04-03-slices.html#the-slice-type">“슬라이스 타입”</a><!-- ignore -->에서 슬라이스는 데이터에 대한 포인터와 슬라이스의 길이라는 점을 상기해 보세요. <code>len</code> 메서드를 사용하여 슬라이스의 길이를 얻고, <code>as_mut_ptr</code> 메서드를 사용하여 슬라이스의 원시 포인터에 접근합니다. 이 경우 <code>i32</code> 값에 대한 가변 슬라이스가 있으므로, <code>as_mut_ptr</code>은 <code>*mut i32</code> 타입의 원시 포인터를 반환하며 이를 <code>ptr</code> 변수에 저장했습니다.</p>
<p><code>mid</code> 인덱스가 슬라이스 내에 있다는 단언(assertion)을 유지합니다. 그런 다음 안전하지 않은 코드에 도달합니다. <code>slice::from_raw_parts_mut</code> 함수는 원시 포인터와 길이를 인수로 받아 슬라이스를 생성합니다. 이 함수를 사용하여 <code>ptr</code>에서 시작하고 길이가 <code>mid</code>인 슬라이스를 생성합니다. 그다음 <code>ptr</code>에서 <code>add</code> 메서드를 <code>mid</code>를 인수로 호출하여 <code>mid</code>에서 시작하는 원시 포인터를 얻고, 그 포인터와 <code>mid</code> 이후의 남은 항목 수를 길이로 사용하여 슬라이스를 생성합니다.</p>
<p><code>slice::from_raw_parts_mut</code> 함수는 원시 포인터를 인수로 받고 이 포인터가 유효하다고 믿어야 하기 때문에 안전하지 않습니다. 원시 포인터의 <code>add</code> 메서드 또한 오프셋 위치가 유효한 포인터라고 믿어야 하기 때문에 안전하지 않습니다. 따라서 <code>slice::from_raw_parts_mut</code>와 <code>add</code> 호출을 가능하게 하려면 <code>unsafe</code> 블록으로 감싸야 했습니다. 코드를 살펴보고 <code>mid</code>가 <code>len</code>보다 작거나 같아야 한다는 단언을 추가함으로써, <code>unsafe</code> 블록 내에서 사용된 모든 원시 포인터가 슬라이스 내 데이터에 대한 유효한 포인터가 될 것임을 알 수 있습니다. 이는 <code>unsafe</code>를 허용 가능하고 적절하게 사용한 예입니다.</p>
<p>결과물인 <code>split_at_mut</code> 함수를 <code>unsafe</code>로 표시할 필요는 없으며, 안전한 러스트에서 이 함수를 호출할 수 있습니다. 이 함수가 접근할 수 있는 데이터로부터 유효한 포인터만을 생성하기 때문에, <code>unsafe</code> 코드를 안전하게 사용하는 함수의 구현으로 안전하지 않은 코드에 대한 안전한 추상화를 만든 것입니다.</p>
<p>반면, 예제 20-7에서 <code>slice::from_raw_parts_mut</code>을 사용하는 것은 슬라이스가 사용될 때 크래시가 발생할 가능성이 큽니다. 이 코드는 임의의 메모리 위치를 가져와 10,000개 항목 길이의 슬라이스를 생성합니다.</p>
<Listing number="20-7" caption="Creating a slice from an arbitrary memory location">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    use std::slice;

    let address = 0x01234usize;
    let r = address as *mut i32;

    let values: &amp;[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>우리는 이 임의의 위치의 메모리를 소유하지 않으며, 이 코드가 생성하는 슬라이스가 유효한 <code>i32</code> 값을 포함한다는 보장도 없습니다. <code>values</code>를 마치 유효한 슬라이스인 것처럼 사용하려고 시도하면 정의되지 않은 동작(undefined behavior)이 발생합니다.</p>
<h4 id="외부-코드를-호출하기-위해-extern-함수-사용하기"><a class="header" href="#외부-코드를-호출하기-위해-extern-함수-사용하기">외부 코드를 호출하기 위해 <code>extern</code> 함수 사용하기</a></h4>
<p>때때로 러스트 코드가 다른 언어로 작성된 코드와 상호작용해야 할 수도 있습니다. 이를 위해 러스트에는 _외부 함수 인터페이스(Foreign Function Interface, FFI)_의 생성 및 사용을 용이하게 하는 <code>extern</code> 키워드가 있습니다. FFI는 프로그래밍 언어가 함수를 정의하고 다른 (외부) 프로그래밍 언어가 해당 함수를 호출할 수 있도록 하는 방법입니다.</p>
<p>예제 20-8은 C 표준 라이브러리의 <code>abs</code> 함수와의 통합을 설정하는 방법을 보여줍니다. <code>extern</code> 블록 내에 선언된 함수는 대개 러스트 코드에서 호출하기에 안전하지 않으므로, 이들 또한 <code>unsafe</code>로 표시되어야 합니다. 그 이유는 다른 언어들이 러스트의 규칙과 보장을 강제하지 않고 러스트가 이를 확인할 수 없기 때문이며, 따라서 안전을 보장할 책임은 프로그래머에게 있습니다.</p>
<Listing number="20-8" file-name="src/main.rs" caption="Declaring and calling an `extern` function defined in another language">
<pre><pre class="playground"><code class="language-rust edition2021">unsafe extern "C" {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!("C에 따른 -3의 절대값: {}", abs(-3));
    }
}</code></pre></pre>
</Listing>
<p><code>unsafe extern "C"</code> 블록 내에서는 호출하려는 다른 언어의 외부 함수 이름과 시그니처를 나열합니다. <code>"C"</code> 부분은 해당 외부 함수가 어떤 _애플리케이션 이진 인터페이스(application binary interface, ABI)_를 사용하는지 정의합니다. ABI는 어셈블리 수준에서 함수를 호출하는 방법을 정의합니다. <code>"C"</code> ABI가 가장 일반적이며 C 프로그래밍 언어의 ABI를 따릅니다.</p>
<p>하지만 이 특정 함수는 메모리 안전성 고려 사항이 없습니다. 사실, 어떤 <code>i32</code>에 대해서도 <code>abs</code> 호출은 항상 안전하다는 것을 알고 있으므로, <code>safe</code> 키워드를 사용하여 이 특정 함수가 <code>unsafe extern</code> 블록 내에 있더라도 호출하기에 안전하다고 말할 수 있습니다. 그렇게 변경하고 나면 예제 20-9와 같이 더 이상 이를 호출할 때 <code>unsafe</code> 블록이 필요하지 않습니다.</p>
<Listing number="20-9" file-name="src/main.rs" caption="Explicitly marking a function as `safe` within an `unsafe extern` block and calling it safely">
<pre><pre class="playground"><code class="language-rust edition2021">unsafe extern "C" {
    safe fn abs(input: i32) -&gt; i32;
}

fn main() {
    println!("C에 따른 -3의 절대값: {}", abs(-3));
}</code></pre></pre>
</Listing>
<p>함수를 <code>safe</code>로 표시한다고 해서 본질적으로 안전해지는 것은 아닙니다! 대신, 그것이 안전하다는 약속을 러스트에게 하는 것과 같습니다. 그 약속이 지켜지도록 하는 것은 여전히 여러분의 책임입니다!</p>
<blockquote>
<h4 id="다른-언어에서-러스트-함수-호출하기"><a class="header" href="#다른-언어에서-러스트-함수-호출하기">다른 언어에서 러스트 함수 호출하기</a></h4>
<p>또한 <code>extern</code>을 사용하여 다른 언어에서 러스트 함수를 호출할 수 있도록 하는 인터페이스를 만들 수 있습니다. 전체 <code>extern</code> 블록을 만드는 대신, 관련 함수의 <code>fn</code> 키워드 바로 앞에 <code>extern</code> 키워드를 추가하고 사용할 ABI를 지정합니다. 또한 러스트 컴파일러가 이 함수의 이름을 맹글링(mangle)하지 않도록 <code>#[unsafe(no_mangle)]</code> 어노테이션을 추가해야 합니다. _맹글링_은 컴파일러가 우리가 함수에 부여한 이름을 컴파일 과정의 다른 부분에서 사용하기 위해 더 많은 정보를 포함하지만 사람이 읽기에는 어려운 다른 이름으로 바꾸는 것을 말합니다. 모든 프로그래밍 언어 컴파일러는 이름을 조금씩 다르게 맹글링하므로, 다른 언어에서 러스트 함수를 이름으로 호출할 수 있게 하려면 러스트 컴파일러의 이름 맹글링을 비활성화해야 합니다. 이는 내장된 맹글링 없이는 라이브러리 간에 이름 충돌이 발생할 수 있기 때문에 안전하지 않으므로, 우리가 내보낸 이름이 맹글링 없이도 내보내기에 안전한지 확인하는 것은 우리의 책임입니다.</p>
<p>다음 예제에서는 <code>call_from_c</code> 함수를 공유 라이브러리로 컴파일하고 C에서 링크한 후, C 코드에서 접근할 수 있게 만듭니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[unsafe(no_mangle)]
pub extern "C" fn call_from_c() {
    println!("C에서 러스트 함수를 방금 호출했습니다!");
}
<span class="boring">}</span></code></pre></pre>
<p>이러한 <code>extern</code> 사용에는 <code>unsafe</code>가 필요하지 않습니다.</p>
</blockquote>
<h3 id="가변-정적-변수에-접근하거나-수정하기"><a class="header" href="#가변-정적-변수에-접근하거나-수정하기">가변 정적 변수에 접근하거나 수정하기</a></h3>
<p>이 책에서는 아직 _전역 변수(global variables)_에 대해 이야기하지 않았는데, 러스트는 이를 지원하지만 러스트의 소유권 규칙상 문제가 될 수 있습니다. 만약 두 스레드가 동일한 가변 전역 변수에 접근한다면, 데이터 경합(data race)이 발생할 수 있습니다.</p>
<p>러스트에서 전역 변수는 <em>정적(static)</em> 변수라고 불립니다. 예제 20-10은 문자열 슬라이스를 값으로 가지는 정적 변수의 선언과 사용 예를 보여줍니다.</p>
<Listing number="20-10" file-name="src/main.rs" caption="Defining and using an immutable static variable">
<pre><pre class="playground"><code class="language-rust edition2021">static HELLO_WORLD: &amp;str = "헬로, 월드!";

fn main() {
    println!("이름은: {HELLO_WORLD}");
}</code></pre></pre>
</Listing>
<p>정적 변수는 3장의 <a href="ch03-01-variables-and-mutability.html#constants">“상수”</a><!-- ignore -->에서 다룬 상수와 유사합니다. 정적 변수의 이름은 관례에 따라 <code>SCREAMING_SNAKE_CASE</code>로 작성합니다. 정적 변수는 <code>'static</code> 라이프타임을 가진 참조만을 저장할 수 있는데, 이는 러스트 컴파일러가 라이프타임을 파악할 수 있으므로 우리가 명시적으로 어노테이션을 달 필요가 없음을 의미합니다. 불변 정적 변수에 접근하는 것은 안전합니다.</p>
<p>상수와 불변 정적 변수의 미묘한 차이점은 정적 변수의 값은 메모리상의 고정된 주소를 가진다는 점입니다. 값을 사용하면 항상 동일한 데이터에 접근하게 됩니다. 반면 상수는 사용될 때마다 데이터가 복제될 수 있습니다. 또 다른 차이점은 정적 변수는 가변적일 수 있다는 것입니다. 가변 정적 변수에 접근하고 이를 수정하는 것은 안전하지 않습니다. 예제 20-11은 <code>COUNTER</code>라는 가변 정적 변수를 선언, 접근 및 수정하는 방법을 보여줍니다.</p>
<Listing number="20-11" file-name="src/main.rs" caption="Reading from or writing to a mutable static variable is unsafe">
<pre><pre class="playground"><code class="language-rust edition2021">static mut COUNTER: u32 = 0;

/// SAFETY: 한 번에 둘 이상의 스레드에서 이를 호출하는 것은 정의되지 않은 동작이므로,
/// 한 번에 오직 하나의 스레드에서만 이를 호출하도록 보장해야 합니다.
unsafe fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    unsafe {
        // SAFETY: 이는 `main`의 단일 스레드에서만 호출됩니다.
        add_to_count(3);
        println!("COUNTER: {}", *(&amp;raw const COUNTER));
    }
}</code></pre></pre>
</Listing>
<p>일반 변수와 마찬가지로 <code>mut</code> 키워드를 사용하여 가변성을 지정합니다. <code>COUNTER</code>를 읽거나 쓰는 모든 코드는 <code>unsafe</code> 블록 내에 있어야 합니다. 예제 20-11의 코드는 단일 스레드이므로 예상대로 컴파일되고 <code>COUNTER: 3</code>을 출력합니다. 여러 스레드가 <code>COUNTER</code>에 접근하는 것은 데이터 경합을 초래할 가능성이 높으며, 이는 정의되지 않은 동작입니다. 따라서 함수 전체를 <code>unsafe</code>로 표시하고 안전상의 제한 사항을 문서화하여, 함수를 호출하는 누구나 안전하게 수행할 수 있는 일과 없는 일이 무엇인지 알 수 있도록 해야 합니다.</p>
<p>안전하지 않은 함수를 작성할 때마다 <code>SAFETY</code>로 시작하는 주석을 작성하여 호출자가 함수를 안전하게 호출하기 위해 무엇을 해야 하는지 설명하는 것이 관례입니다. 마찬가지로, 안전하지 않은 연산을 수행할 때마다 <code>SAFETY</code>로 시작하는 주석을 작성하여 안전 규칙이 어떻게 준수되는지 설명하는 것이 관례입니다.</p>
<p>또한 컴파일러는 가변 정적 변수에 대한 참조를 만드는 것을 허용하지 않습니다. 원시 대여 연산자 중 하나를 사용하여 만든 원시 포인터를 통해서만 접근할 수 있습니다. 여기에는 이 코드 예제의 <code>println!</code>에서 사용될 때처럼 참조가 보이지 않게 생성되는 경우도 포함됩니다. 가변 정적 변수에 대한 참조가 오직 원시 포인터를 통해서만 생성될 수 있다는 요구 사항은 이를 사용하는 데 필요한 안전 요건을 더 명확하게 만드는 데 도움이 됩니다.</p>
<p>전역적으로 접근 가능한 가변 데이터의 경우 데이터 경합이 없음을 보장하기 어렵기 때문에, 러스트는 가변 정적 변수를 안전하지 않다고 간주합니다. 가능하다면 16장에서 논의한 동시성 기술과 스레드 안전한 스마트 포인터를 사용하는 것이 좋습니다. 그러면 컴파일러가 서로 다른 스레드에서 데이터에 안전하게 접근하는지 확인할 수 있습니다.</p>
<h3 id="안전하지-않은-트레이트-구현하기"><a class="header" href="#안전하지-않은-트레이트-구현하기">안전하지 않은 트레이트 구현하기</a></h3>
<p><code>unsafe</code>를 사용하여 안전하지 않은 트레이트를 구현할 수 있습니다. 트레이트의 메서드 중 적어도 하나에 컴파일러가 확인할 수 없는 불변성(invariant)이 있을 때 해당 트레이트는 안전하지 않습니다. 트레이트를 선언할 때 <code>trait</code> 앞에 <code>unsafe</code> 키워드를 추가하고, 해당 트레이트의 구현부 역시 <code>unsafe</code>로 표시함으로써 안전하지 않은 트레이트임을 선언합니다. 예제 20-12가 이를 보여줍니다.</p>
<Listing number="20-12" caption="Defining and implementing an unsafe trait">
<pre><pre class="playground"><code class="language-rust edition2021">unsafe trait Foo {
    // 메서드가 여기에 옵니다
}

unsafe impl Foo for i32 {
    // 메서드 구현이 여기에 옵니다
}

fn main() {}</code></pre></pre>
</Listing>
<p><code>unsafe impl</code>을 사용함으로써, 컴파일러가 확인할 수 없는 불변성을 우리가 준수할 것임을 약속하는 것입니다.</p>
<p>예를 들어, 16장의 <a href="ch16-04-extensible-concurrency-sync-and-send.html#extensible-concurrency-with-the-sync-and-send-traits">“<code>Sync</code>와 <code>Send</code> 트레이트로 확장 가능한 동시성”</a><!-- ignore -->에서 다룬 <code>Sync</code>와 <code>Send</code> 마커 트레이트를 떠올려 보세요. 컴파일러는 타입이 전적으로 <code>Send</code>와 <code>Sync</code> 타입으로만 구성되어 있다면 이 트레이트들을 자동으로 구현합니다. 만약 원시 포인터와 같이 <code>Send</code>나 <code>Sync</code>가 아닌 타입을 포함하는 타입을 구현하면서 그 타입을 <code>Send</code>나 <code>Sync</code>로 표시하고 싶다면, 반드시 <code>unsafe</code>를 사용해야 합니다. 러스트는 우리 타입이 스레드 간에 안전하게 전달될 수 있는지 혹은 여러 스레드에서 안전하게 접근될 수 있는지에 대한 보장을 준수하는지 확인할 수 없습니다. 따라서 우리가 직접 그 검사를 수행하고 <code>unsafe</code>로 그 사실을 명시해야 합니다.</p>
<h3 id="유니온의-필드에-접근하기"><a class="header" href="#유니온의-필드에-접근하기">유니온의 필드에 접근하기</a></h3>
<p><code>unsafe</code>에서만 작동하는 마지막 동작은 _유니온(union)_의 필드에 접근하는 것입니다. <code>union</code>은 <code>struct</code>와 유사하지만, 특정 인스턴스에서 한 번에 하나의 필드만 사용됩니다. 유니온은 주로 C 코드의 유니온과 인터페이스하는 데 사용됩니다. 유니온 인스턴스에 현재 저장된 데이터의 타입을 러스트가 보장할 수 없기 때문에 유니온 필드에 접근하는 것은 안전하지 않습니다. 유니온에 대한 자세한 내용은 <a href="../reference/items/unions.html">러스트 레퍼런스(Rust Reference)</a>에서 확인할 수 있습니다.</p>
<h3 id="miri를-사용하여-안전하지-않은-코드-확인하기"><a class="header" href="#miri를-사용하여-안전하지-않은-코드-확인하기">Miri를 사용하여 안전하지 않은 코드 확인하기</a></h3>
<p>안전하지 않은 코드를 작성할 때, 여러분이 작성한 것이 실제로 안전하고 올바른지 확인하고 싶을 수 있습니다. 이를 위한 가장 좋은 방법 중 하나는 정의되지 않은 동작을 감지하기 위한 공식 러스트 도구인 <a href="https://github.com/rust-lang/miri">Miri</a>를 사용하는 것입니다. 대여 검사기가 컴파일 시간에 작동하는 <em>정적(static)</em> 도구인 반면, Miri는 런타임에 작동하는 <em>동적(dynamic)</em> 도구입니다. Miri는 여러분의 프로그램이나 테스트 스위트를 실행하여 러스트가 어떻게 작동해야 하는지에 대해 알고 있는 규칙을 위반하는 경우를 감지함으로써 코드를 확인합니다.</p>
<p>Miri를 사용하려면 러스트 나이틀리 빌드가 필요합니다(이에 대해서는 <a href="appendix-07-nightly-rust.html">부록 G: 러스트가 만들어지는 방법과 "나이틀리 러스트"</a>에서 더 자세히 다룹니다). <code>rustup +nightly component add miri</code>를 입력하여 나이틀리 버전의 러스트와 Miri 도구를 모두 설치할 수 있습니다. 이는 여러분의 프로젝트가 사용하는 러스트 버전을 변경하지는 않습니다. 단지 시스템에 도구를 추가하여 원할 때 사용할 수 있도록 할 뿐입니다. 프로젝트에서 <code>cargo +nightly miri run</code> 또는 <code>cargo +nightly miri test</code>를 입력하여 Miri를 실행할 수 있습니다.</p>
<p>이것이 얼마나 도움이 될 수 있는지에 대한 예로, 예제 20-11에 대해 Miri를 실행했을 때 어떤 일이 발생하는지 고려해 보세요.</p>
<pre><code class="language-console">$ cargo +nightly miri run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.01s
     Running `/Users/chris/.rustup/toolchains/nightly-aarch64-apple-darwin/bin/cargo-miri runner target/miri/aarch64-apple-darwin/debug/unsafe-example`
warning: creating a shared reference to mutable static is discouraged
  --&gt; src/main.rs:14:33
   |
14 |         println!("COUNTER: {}", COUNTER);
   |                                 ^^^^^^^ shared reference to mutable static
   |
   = note: for more information, see &lt;https://doc.rust-lang.org/nightly/edition-guide/rust-2024/static-mut-references.html&gt;
   = note: shared references to mutable statics are dangerous; it's undefined behavior if the static is mutated or if a mutable reference is created for it while the shared reference lives
   = note: `#[warn(static_mut_refs)]` on by default

COUNTER: 3
</code></pre>
<p>Miri는 가변 데이터에 대한 공유 참조가 있음을 유용하고 정확하게 인지하고 이에 대해 경고합니다. 이 경우 문제를 해결하는 방법을 알려주지는 않지만, 가능한 문제가 있음을 알게 되어 이를 어떻게 안전하게 만들 수 있을지 생각할 수 있게 해줍니다. 다른 경우에는 실제로 어떤 코드가 <em>확실히</em> 잘못되었음을 알려주고 이를 해결하는 방법에 대한 권장 사항을 제시할 수도 있습니다.</p>
<p>Miri가 안전하지 않은 코드를 작성할 때 저지를 수 있는 <em>모든</em> 실수를 잡아내는 것은 아닙니다. 우선 Miri는 동적 검사이기 때문에 실제로 실행되는 코드의 문제만 잡아냅니다. 즉, 여러분이 작성한 안전하지 않은 코드에 대한 확신을 높이려면 좋은 테스트 기법과 함께 Miri를 사용해야 함을 의미합니다. 또한 Miri가 여러분의 코드가 견고하지 않을 수 있는 모든 가능성을 다루지는 않습니다. Miri가 문제를 잡아낸다면 버그가 있다는 것을 알 수 있지만, Miri가 버그를 잡아내지 못했다고 해서 문제가 없다는 뜻은 아닙니다. 그럼에도 Miri는 많은 것을 잡아낼 수 있습니다. 이 장의 다른 안전하지 않은 코드 예제들에 대해 Miri를 실행해 보고 어떤 결과가 나오는지 확인해 보세요!</p>
<h3 id="언제-안전하지-않은-코드를-사용하는가"><a class="header" href="#언제-안전하지-않은-코드를-사용하는가">언제 안전하지 않은 코드를 사용하는가</a></h3>
<p>방금 논의한 다섯 가지 동작(슈퍼파워) 중 하나를 수행하기 위해 <code>unsafe</code>를 사용하는 것은 잘못된 것이 아니며 눈총을 받을 일도 아닙니다. 하지만 컴파일러가 메모리 안전성을 보장하는 데 도움을 줄 수 없기 때문에 <code>unsafe</code> 코드를 올바르게 작성하는 것은 더 까다롭습니다. <code>unsafe</code> 코드를 사용해야 할 이유가 있다면 그렇게 할 수 있으며, 명시적인 <code>unsafe</code> 어노테이션이 있으면 문제가 발생했을 때 문제의 근원을 추적하기가 더 쉬워집니다. 안전하지 않은 코드를 작성할 때마다 Miri를 사용하여 여러분이 작성한 코드가 러스트의 규칙을 준수하는지 더 확신할 수 있습니다.</p>
<p>안전하지 않은 러스트를 효과적으로 다루는 방법에 대해 훨씬 더 깊이 탐구하고 싶다면, 이 주제에 대한 러스트 공식 가이드인 <a href="https://doc.rust-lang.org/nomicon/">러스토노미콘(Rustonomicon)</a>을 읽어보세요.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="고급-트레이트"><a class="header" href="#고급-트레이트">고급 트레이트</a></h2>
<p>트레이트는 10장의 <a href="ch10-02-traits.html#traits-defining-shared-behavior">“트레이트: 공유 동작 정의하기”</a><!-- ignore -->에서 처음 다루었지만, 더 고급 세부 사항에 대해서는 논의하지 않았습니다. 이제 러스트에 대해 더 많이 알게 되었으므로, 핵심적인 내용을 다룰 수 있습니다.</p>
<h3 id="연관-타입을-사용하여-트레이트-정의에서-자리표시자-타입-지정하기"><a class="header" href="#연관-타입을-사용하여-트레이트-정의에서-자리표시자-타입-지정하기">연관 타입을 사용하여 트레이트 정의에서 자리표시자 타입 지정하기</a></h3>
<p>_연관 타입(Associated types)_은 타입 자리표시자를 트레이트와 연결하여 트레이트 메서드 정의가 시그니처에서 이러한 자리표시자 타입을 사용할 수 있게 합니다. 트레이트 구현자는 특정 구현에서 자리표시자 타입 대신 사용될 구체적인 타입을 지정하게 됩니다. 이런 방식으로 트레이트가 구현될 때까지 해당 타입들이 정확히 무엇인지 알 필요 없이 일부 타입을 사용하는 트레이트를 정의할 수 있습니다.</p>
<p>우리는 이 장의 대부분의 고급 기능들이 거의 필요하지 않다고 설명했습니다. 연관 타입은 그 중간 어디쯤에 있습니다. 책의 나머지 부분에서 설명한 기능들보다는 덜 사용되지만, 이 장에서 논의된 다른 많은 기능들보다는 더 흔히 사용됩니다.</p>
<p>연관 타입이 있는 트레이트의 한 예는 표준 라이브러리에서 제공하는 <code>Iterator</code> 트레이트입니다. 연관 타입의 이름은 <code>Item</code>이며, <code>Iterator</code> 트레이트를 구현하는 타입이 반복하고 있는 값들의 타입을 대신합니다. <code>Iterator</code> 트레이트의 정의는 예제 20-13과 같습니다.</p>
<Listing number="20-13" caption="The definition of the `Iterator` trait that has an associated type `Item`">
<pre><code class="language-rust noplayground">pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}</code></pre>
</Listing>
<p><code>Item</code> 타입은 자리표시자이며, <code>next</code> 메서드의 정의는 이것이 <code>Option&lt;Self::Item&gt;</code> 타입의 값을 반환할 것임을 보여줍니다. <code>Iterator</code> 트레이트 구현자는 <code>Item</code>에 대한 구체적인 타입을 지정할 것이고, <code>next</code> 메서드는 해당 구체적인 타입의 값을 포함하는 <code>Option</code>을 반환할 것입니다.</p>
<p>연관 타입은 제네릭과 유사한 개념처럼 보일 수 있는데, 제네릭 또한 처리할 타입을 지정하지 않고 함수를 정의할 수 있게 해주기 때문입니다. 두 개념의 차이점을 살펴보기 위해, <code>Item</code> 타입을 <code>u32</code>로 지정하는 <code>Counter</code> 타입에 대한 <code>Iterator</code> 트레이트 구현을 살펴보겠습니다.</p>
<Listing file-name="src/lib.rs">
<pre><code class="language-rust ignore"><span class="boring">struct Counter {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Counter {
</span><span class="boring">    fn new() -&gt; Counter {
</span><span class="boring">        Counter { count: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // --생략--
<span class="boring">        if self.count &lt; 5 {
</span><span class="boring">            self.count += 1;
</span><span class="boring">            Some(self.count)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>이 문법은 제네릭의 문법과 비슷해 보입니다. 그렇다면 왜 예제 20-14와 같이 제네릭을 사용하여 <code>Iterator</code> 트레이트를 정의하지 않을까요?</p>
<Listing number="20-14" caption="A hypothetical definition of the `Iterator` trait using generics">
<pre><code class="language-rust noplayground">pub trait Iterator&lt;T&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;
}</code></pre>
</Listing>
<p>차이점은 예제 20-14처럼 제네릭을 사용할 경우 각 구현에서 타입을 명시해야 한다는 점입니다. <code>Iterator&lt;String&gt; for Counter</code>나 다른 어떤 타입에 대해서도 구현할 수 있기 때문에, <code>Counter</code>에 대해 여러 개의 <code>Iterator</code> 구현을 가질 수 있습니다. 다시 말해, 트레이트에 제네릭 파라미터가 있으면 매번 제네릭 타입 파라미터의 구체적인 타입을 바꾸어가며 한 타입에 대해 여러 번 구현할 수 있습니다. 우리가 <code>Counter</code>에서 <code>next</code> 메서드를 사용할 때, 어떤 <code>Iterator</code> 구현을 사용하고 싶은지 나타내기 위해 타입 어노테이션을 제공해야 할 것입니다.</p>
<p>연관 타입을 사용하면 트레이트를 한 타입에 대해 여러 번 구현할 수 없기 때문에 타입 어노테이션을 달 필요가 없습니다. 연관 타입을 사용하는 예제 20-13의 정의에서는 <code>impl Iterator for Counter</code>가 단 하나만 존재할 수 있기 때문에 <code>Item</code>의 타입을 단 한 번만 선택할 수 있습니다. 따라서 <code>Counter</code>에서 <code>next</code>를 호출하는 어디에서도 <code>u32</code> 값에 대한 반복자를 원한다고 명시할 필요가 없습니다.</p>
<p>연관 타입은 또한 트레이트 계약의 일부가 됩니다. 트레이트 구현자는 연관 타입 자리표시자를 대신할 타입을 반드시 제공해야 합니다. 연관 타입은 종종 해당 타입이 어떻게 사용될지를 설명하는 이름을 가지며, API 문서에서 연관 타입을 문서화하는 것은 좋은 관례입니다.</p>
<h3 id="기본-제네릭-타입-파라미터와-연산자-오버로딩"><a class="header" href="#기본-제네릭-타입-파라미터와-연산자-오버로딩">기본 제네릭 타입 파라미터와 연산자 오버로딩</a></h3>
<p>When we use generic type parameters, we can specify a default concrete type for the generic type. This eliminates the need for implementors of the trait to specify a concrete type if the default type works. You specify a default type when declaring a generic type with the <code>&lt;PlaceholderType=ConcreteType&gt;</code> syntax.</p>
<p>이 기술이 유용한 상황의 좋은 예는 특정 상황에서 연산자(예: <code>+</code>)의 동작을 커스터마이징하는 _연산자 오버로딩(operator overloading)_입니다.</p>
<p>러스트는 여러분만의 연산자를 만들거나 임의의 연산자를 오버로딩하는 것을 허용하지 않습니다. 하지만 연산자와 관련된 트레이트를 구현함으로써 <code>std::ops</code>에 나열된 연산들과 그에 대응하는 트레이트들을 오버로딩할 수 있습니다. 예를 들어, 예제 20-15에서는 <code>+</code> 연산자를 오버로딩하여 두 <code>Point</code> 인스턴스를 더합니다. 우리는 이를 <code>Point</code> 구조체에 <code>Add</code> 트레이트를 구현함으로써 수행합니다.</p>
<Listing number="20-15" file-name="src/main.rs" caption="Implementing the `Add` trait to overload the `+` operator for `Point` instances">
<pre><pre class="playground"><code class="language-rust edition2021">use std::ops::Add;

#[derive(Debug, Copy, Clone, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(
        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
        Point { x: 3, y: 3 }
    );
}</code></pre></pre>
</Listing>
<p><code>add</code> 메서드는 두 <code>Point</code> 인스턴스의 <code>x</code> 값들을 더하고 두 <code>Point</code> 인스턴스의 <code>y</code> 값들을 더해 새로운 <code>Point</code>를 생성합니다. <code>Add</code> 트레이트에는 <code>add</code> 메서드에서 반환되는 타입을 결정하는 <code>Output</code>이라는 연관 타입이 있습니다.</p>
<p>이 코드의 기본 제네릭 타입은 <code>Add</code> 트레이트 내에 있습니다. 다음은 그 정의입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Add&lt;Rhs=Self&gt; {
    type Output;

    fn add(self, rhs: Rhs) -&gt; Self::Output;
}
<span class="boring">}</span></code></pre></pre>
<p>이 코드는 일반적으로 익숙해 보일 것입니다. 하나의 메서드와 하나의 연관 타입을 가진 트레이트입니다. 새로운 부분은 <code>Rhs=Self</code>입니다. 이 문법은 _기본 타입 파라미터(default type parameters)_라고 불립니다. <code>Rhs</code> 제네릭 타입 파라미터(“right hand side”의 약자)는 <code>add</code> 메서드의 <code>rhs</code> 파라미터 타입을 정의합니다. <code>Add</code> 트레이트를 구현할 때 <code>Rhs</code>에 대한 구체 타입을 지정하지 않으면, <code>Rhs</code> 타입은 기본적으로 <code>Self</code>가 되며, 이는 우리가 <code>Add</code>를 구현하고 있는 타입이 될 것입니다.</p>
<p><code>Point</code>에 대해 <code>Add</code>를 구현할 때, 두 <code>Point</code> 인스턴스를 더하고 싶었기 때문에 <code>Rhs</code>에 대해 기본값을 사용했습니다. 이제 기본값을 사용하는 대신 <code>Rhs</code> 타입을 커스터마이징하고 싶은 경우의 <code>Add</code> 트레이트 구현 예를 살펴보겠습니다.</p>
<p>서로 다른 단위의 값을 저장하는 <code>Millimeters</code>와 <code>Meters</code>라는 두 구조체가 있습니다. 기존 타입을 다른 구조체로 얇게 감싸는 이 방식은 _뉴타입 패턴(newtype pattern)_으로 알려져 있으며, 이에 대해서는 <a href="ch20-02-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types">“외부 타입에 외부 트레이트를 구현하기 위해 뉴타입 패턴 사용하기”</a><!-- ignore --> 섹션에서 더 자세히 설명합니다. 우리는 밀리미터 단위의 값에 미터 단위의 값을 더하고 싶고, <code>Add</code> 구현이 변환을 올바르게 수행하도록 하고 싶습니다. 예제 20-16에 표시된 대로 <code>Meters</code>를 <code>Rhs</code>로 하여 <code>Millimeters</code>에 대해 <code>Add</code>를 구현할 수 있습니다.</p>
<Listing number="20-16" file-name="src/lib.rs" caption="Implementing the `Add` trait on `Millimeters` to add `Millimeters` to `Meters`">
<pre><code class="language-rust noplayground">use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add&lt;Meters&gt; for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -&gt; Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}</code></pre>
</Listing>
<p><code>Millimeters</code>와 <code>Meters</code>를 더하기 위해, <code>Self</code>인 기본값 대신 <code>Rhs</code> 타입 파라미터의 값을 설정하도록 <code>impl Add&lt;Meters&gt;</code>를 지정합니다.</p>
<p>기본 타입 파라미터는 주로 다음 두 가지 방식으로 사용됩니다.</p>
<ol>
<li>기존 코드를 깨뜨리지 않고 타입을 확장하기 위해</li>
<li>대부분의 사용자가 필요로 하지 않는 특정 사례에서 커스터마이징을 허용하기 위해</li>
</ol>
<p>표준 라이브러리의 <code>Add</code> 트레이트는 두 번째 목적의 예입니다. 보통은 동일한 두 타입을 더하겠지만, <code>Add</code> 트레이트는 그 이상의 커스터마이징 기능을 제공합니다. <code>Add</code> 트레이트 정의에서 기본 타입 파라미터를 사용한다는 것은 대부분의 경우 추가 파라미터를 지정할 필요가 없음을 의미합니다. 즉, 약간의 구현 상용구(boilerplate)가 필요하지 않으므로 트레이트를 더 쉽게 사용할 수 있습니다.</p>
<p>첫 번째 목적은 두 번째와 비슷하지만 반대의 경우입니다. 기존 트레이트에 타입 파라미터를 추가하고 싶을 때, 기존 구현 코드를 깨뜨리지 않고 트레이트 기능을 확장할 수 있도록 기본값을 제공할 수 있습니다.</p>
<h3 id="모호성-해소를-위한-완전-정규화-문법-이름이-같은-메서드-호출하기"><a class="header" href="#모호성-해소를-위한-완전-정규화-문법-이름이-같은-메서드-호출하기">모호성 해소를 위한 완전 정규화 문법: 이름이 같은 메서드 호출하기</a></h3>
<p>러스트에서 트레이트가 다른 트레이트의 메서드와 같은 이름을 가진 메서드를 갖는 것을 막지 않으며, 한 타입에 두 트레이트를 모두 구현하는 것도 막지 않습니다. 또한 트레이트의 메서드와 같은 이름의 메서드를 타입에 직접 구현하는 것도 가능합니다.</p>
<p>같은 이름의 메서드를 호출할 때, 러스트에게 어떤 메서드를 사용하고 싶은지 알려주어야 합니다. 예제 20-17의 코드를 살펴보세요. 여기서는 모두 <code>fly</code>라는 이름의 메서드를 가진 <code>Pilot</code>과 <code>Wizard</code>라는 두 트레이트를 정의했습니다. 그런 다음 이미 <code>fly</code>라는 이름의 메서드가 직접 구현되어 있는 <code>Human</code> 타입에 이 두 트레이트를 모두 구현합니다. 각 <code>fly</code> 메서드는 서로 다른 동작을 수행합니다.</p>
<Listing number="20-17" file-name="src/main.rs" caption="Two traits are defined to have a ` method and are implemented on the `Human` type, and a `fly` method is implemented on `Human` directly">
<pre><pre class="playground"><code class="language-rust edition2021">trait Pilot {
    fn fly(&amp;self);
}

trait Wizard {
    fn fly(&amp;self);
}

struct Human;

impl Pilot for Human {
    fn fly(&amp;self) {
        println!("기장입니다. 안내 말씀 드립니다.");
    }
}

impl Wizard for Human {
    fn fly(&amp;self) {
        println!("상승!");
    }
}

impl Human {
    fn fly(&amp;self) {
        println!("*팔을 미친듯이 흔드는 중*");
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p><code>Human</code>의 인스턴스에서 <code>fly</code>를 호출하면, 컴파일러는 예제 20-18에 표시된 대로 타입에 직접 구현된 메서드를 호출하는 것을 기본으로 합니다.</p>
<Listing number="20-18" file-name="src/main.rs" caption="Calling `fly` on an instance of `Human`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("기장입니다. 안내 말씀 드립니다.");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("상승!");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("*팔을 미친듯이 흔드는 중*");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    person.fly();
}</code></pre></pre>
</Listing>
<p>이 코드를 실행하면 <code>*팔을 미친듯이 흔드는 중*</code>이 출력되며, 이는 러스트가 <code>Human</code>에 직접 구현된 <code>fly</code> 메서드를 호출했음을 보여줍니다.</p>
<p><code>Pilot</code> 트레이트나 <code>Wizard</code> 트레이트 중 하나의 <code>fly</code> 메서드를 호출하려면, 우리가 의도하는 <code>fly</code> 메서드가 무엇인지 명시하기 위해 더 구체적인 문법을 사용해야 합니다. 예제 20-19에서 이 문법을 보여줍니다.</p>
<Listing number="20-19" file-name="src/main.rs" caption="Specifying which trait’s `fly` method we want to call">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("기장입니다. 안내 말씀 드립니다.");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("상승!");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("*팔을 미친듯이 흔드는 중*");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    Pilot::fly(&amp;person);
    Wizard::fly(&amp;person);
    person.fly();
}</code></pre></pre>
</Listing>
<p>메서드 이름 앞에 트레이트 이름을 지정하면 우리가 호출하고자 하는 <code>fly</code> 구현이 무엇인지 러스트에게 명확하게 전달됩니다. 또한 <code>Human::fly(&amp;person)</code>라고 쓸 수도 있는데, 이는 예제 20-19에서 사용한 <code>person.fly()</code>와 동일하지만 모호성을 해소할 필요가 없다면 조금 더 길게 쓰는 셈이 됩니다.</p>
<p>이 코드를 실행하면 다음과 같이 출력됩니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.46s
     Running `target/debug/traits-example`
기장입니다. 안내 말씀 드립니다.
상승!
*팔을 미친듯이 흔드는 중*
</code></pre>
<p><code>fly</code> 메서드는 <code>self</code> 파라미터를 받기 때문에, 만약 한 트레이트를 구현하는 두 _타입_이 있다면 러스트는 <code>self</code>의 타입에 기반하여 어떤 트레이트 구현을 사용할지 알아낼 수 있습니다.</p>
<p>하지만 메서드가 아닌 연관 함수는 <code>self</code> 파라미터가 없습니다. 같은 이름의 메서드가 아닌 함수를 정의하는 여러 타입이나 트레이트가 있을 때, _완전 정규화 문법(fully qualified syntax)_을 사용하지 않으면 러스트는 여러분이 어떤 타입을 의도하는지 항상 알 수 있는 것은 아닙니다. 예를 들어, 예제 20-20에서는 모든 새끼 강아지의 이름을 _Spot_이라고 짓고 싶어 하는 동물 보호소를 위한 트레이트를 만듭니다. 메서드가 아닌 연관 함수 <code>baby_name</code>을 가진 <code>Animal</code> 트레이트를 만듭니다. <code>Dog</code> 구조체에 대해 <code>Animal</code> 트레이트를 구현하고, <code>Dog</code>에 직접 메서드가 아닌 연관 함수 <code>baby_name</code>을 제공합니다.</p>
<Listing number="20-20" file-name="src/main.rs" caption="A trait with an associated function and a type with an associated function of the same name that also implements the trait">
<pre><pre class="playground"><code class="language-rust edition2021">trait Animal {
    fn baby_name() -&gt; String;
}

struct Dog;

impl Dog {
    fn baby_name() -&gt; String {
        String::from("Spot")
    }
}

impl Animal for Dog {
    fn baby_name() -&gt; String {
        String::from("강아지")
    }
}

fn main() {
    println!("새끼 개는 {}라고 불립니다", Dog::baby_name());
}</code></pre></pre>
</Listing>
<p>모든 강아지의 이름을 Spot으로 짓는 코드를 <code>Dog</code>에 정의된 <code>baby_name</code> 연관 함수에 구현합니다. <code>Dog</code> 타입은 또한 모든 동물이 가진 특성을 묘사하는 <code>Animal</code> 트레이트를 구현합니다. 새끼 개는 강아지(puppy)라고 불리며, 이는 <code>Animal</code> 트레이트와 연관된 <code>baby_name</code> 함수 내의 <code>Dog</code>에 대한 <code>Animal</code> 트레이트 구현에서 표현됩니다.</p>
<p><code>main</code>에서 <code>Dog::baby_name</code> 함수를 호출하면 <code>Dog</code>에 직접 정의된 연관 함수가 호출됩니다. 이 코드는 다음과 같이 출력됩니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.54s
     Running `target/debug/traits-example`
새끼 개는 Spot이라고 불립니다
</code></pre>
<p>이 출력은 우리가 원하던 것이 아닙니다. 우리는 <code>Dog</code>에 구현된 <code>Animal</code> 트레이트의 일부인 <code>baby_name</code> 함수를 호출하여 <code>새끼 개는 강아지라고 불립니다</code>가 출력되기를 원합니다. 예제 20-19에서 사용했던 트레이트 이름을 지정하는 기술은 여기서 도움이 되지 않습니다. <code>main</code>을 예제 20-21의 코드로 변경하면 컴파일 에러가 발생합니다.</p>
<Listing number="20-21" file-name="src/main.rs" caption="Attempting to call the `baby_name` function from the `Animal` trait, but Rust doesn’t know which implementation to use">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("Spot")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("강아지")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!("새끼 개는 {}라고 불립니다", Animal::baby_name());
}</code></pre>
</Listing>
<p><code>Animal::baby_name</code>은 <code>self</code> 파라미터가 없고, <code>Animal</code> 트레이트를 구현하는 다른 타입들이 있을 수 있기 때문에, 러스트는 우리가 어떤 <code>Animal::baby_name</code> 구현을 원하는지 알아낼 수 없습니다. 다음과 같은 컴파일러 에러가 발생합니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0790]: cannot call associated function on trait without specifying the corresponding `impl` type
  --&gt; src/main.rs:20:43
   |
2  |     fn baby_name() -&gt; String;
   |     ------------------------- `Animal::baby_name` defined here
...
20 |     println!("A baby dog is called a {}", Animal::baby_name());
   |                                           ^^^^^^^^^^^^^^^^^^^ cannot call associated function of trait
   |
help: use the fully-qualified path to the only available implementation
   |
20 |     println!("A baby dog is called a {}", &lt;Dog as Animal&gt;::baby_name());
   |                                           +++++++       +

For more information about this error, try `rustc --explain E0790`.
error: could not compile `traits-example` (bin "traits-example") due to 1 previous error
</code></pre>
<p>모호성을 해소하고 다른 타입에 대한 <code>Animal</code> 구현이 아닌 <code>Dog</code>에 대한 <code>Animal</code> 구현을 사용하고 싶다고 러스트에게 알리려면, 완전 정규화 문법을 사용해야 합니다. 예제 20-22에서 완전 정규화 문법을 사용하는 방법을 보여줍니다.</p>
<Listing number="20-22" file-name="src/main.rs" caption="Using fully qualified syntax to specify that we want to call the `baby_name` function from the `Animal` trait as implemented on `Dog`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("Spot")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("강아지")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!("새끼 개는 {}라고 불립니다", &lt;Dog as Animal&gt;::baby_name());
}</code></pre></pre>
</Listing>
<p>우리는 꺾쇠괄호 안에 타입 어노테이션을 제공하여, 이 함수 호출을 위해 <code>Dog</code> 타입을 <code>Animal</code>로 취급하고 싶다고 말함으로써 <code>Dog</code>에 구현된 <code>Animal</code> 트레이트의 <code>baby_name</code> 메서드를 호출하고 싶다는 것을 러스트에 명시합니다. 이제 이 코드는 우리가 원하던 것을 출력합니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/traits-example`
새끼 개는 강아지라고 불립니다
</code></pre>
<p>일반적으로 완전 정규화 문법은 다음과 같이 정의됩니다.</p>
<pre><code class="language-rust ignore">&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);</code></pre>
<p>메서드가 아닌 연관 함수의 경우 <code>receiver</code>가 없으며, 다른 인수들의 목록만 있게 됩니다. 함수나 메서드를 호출하는 모든 곳에서 완전 정규화 문법을 사용할 수 있습니다. 하지만 프로그램의 다른 정보로부터 러스트가 파악할 수 있는 부분은 생략할 수 있습니다. 같은 이름을 사용하는 여러 구현이 있어서 러스트가 여러분이 호출하고자 하는 구현이 무엇인지 식별하는 데 도움이 필요한 경우에만 이 더 장황한 문법을 사용하면 됩니다.</p>
<h3 id="슈퍼트레이트를-사용하여-한-트레이트-내에서-다른-트레이트의-기능-요구하기"><a class="header" href="#슈퍼트레이트를-사용하여-한-트레이트-내에서-다른-트레이트의-기능-요구하기">슈퍼트레이트를 사용하여 한 트레이트 내에서 다른 트레이트의 기능 요구하기</a></h3>
<p>때때로 다른 트레이트에 의존하는 트레이트 정의를 작성해야 할 수도 있습니다. 즉, 어떤 타입이 첫 번째 트레이트를 구현하려면 해당 타입이 두 번째 트레이트도 구현하도록 요구하고 싶은 경우입니다. 이렇게 하면 여러분의 트레이트 정의에서 두 번째 트레이트의 연관 아이템들을 활용할 수 있습니다. 여러분의 트레이트 정의가 의존하고 있는 트레이트를 해당 트레이트의 _슈퍼트레이트(supertrait)_라고 부릅니다.</p>
<p>예를 들어, 주어진 값을 별표(*)로 감싸서 출력하는 <code>outline_print</code> 메서드를 가진 <code>OutlinePrint</code> 트레이트를 만들고 싶다고 해봅시다. 즉, 표준 라이브러리 트레이트인 <code>Display</code>를 구현하여 <code>(x, y)</code>라는 결과를 내는 <code>Point</code> 구조체가 있을 때, <code>x</code>가 <code>1</code>이고 <code>y</code>가 <code>3</code>인 <code>Point</code> 인스턴스에서 <code>outline_print</code>를 호출하면 다음과 같이 출력되어야 합니다.</p>
<pre><code class="language-text">**********
*        *
* (1, 3) *
*        *
**********
</code></pre>
<p><code>outline_print</code> 메서드 구현에서 <code>Display</code> 트레이트의 기능을 사용하고 싶습니다. 따라서 <code>OutlinePrint</code> 트레이트는 <code>Display</code>를 구현하고 <code>OutlinePrint</code>가 필요로 하는 기능을 제공하는 타입에 대해서만 작동하도록 지정해야 합니다. 트레이트 정의에서 <code>OutlinePrint: Display</code>라고 명시함으로써 이를 수행할 수 있습니다. 이 기술은 트레이트에 트레이트 바운드(trait bound)를 추가하는 것과 유사합니다. 예제 20-23은 <code>OutlinePrint</code> 트레이트의 구현을 보여줍니다.</p>
<Listing number="20-23" file-name="src/main.rs" caption="Implementing the `OutlinePrint` trait that requires the functionality from `Display`">
<pre><pre class="playground"><code class="language-rust edition2021">use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&amp;self) {
        let output = self.to_string();
        let len = output.len();
        println!("{}", "*".repeat(len + 4));
        println!("*{}*", " ".repeat(len + 2));
        println!("* {output} *");
        println!("*{}*", " ".repeat(len + 2));
        println!("{}", "*".repeat(len + 4));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p><code>OutlinePrint</code>가 <code>Display</code> 트레이트를 필요로 하도록 지정했기 때문에, <code>Display</code>를 구현하는 모든 타입에 대해 자동으로 구현되는 <code>to_string</code> 함수를 사용할 수 있습니다. 트레이트 이름 뒤에 콜론을 찍고 <code>Display</code> 트레이트를 지정하지 않은 채 <code>to_string</code>을 사용하려고 시도하면, 현재 스코프의 <code>&amp;Self</code> 타입에 대해 <code>to_string</code>이라는 이름의 메서드를 찾을 수 없다는 에러가 발생합니다.</p>
<p><code>Point</code> 구조체와 같이 <code>Display</code>를 구현하지 않은 타입에 <code>OutlinePrint</code>를 구현하려고 시도하면 어떤 일이 발생하는지 살펴봅시다.</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("* {output} *");
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}</span></code></pre>
</Listing>
<p><code>Display</code>가 필요하지만 구현되지 않았다는 에러가 발생합니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --&gt; src/main.rs:20:23
   |
20 | impl OutlinePrint for Point {}
   |                       ^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
note: required by a bound in `OutlinePrint`
  --&gt; src/main.rs:3:21
   |
3  | trait OutlinePrint: fmt::Display {
   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint`

error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --&gt; src/main.rs:24:7
   |
24 |     p.outline_print();
   |       ^^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
note: required by a bound in `OutlinePrint::outline_print`
  --&gt; src/main.rs:3:21
   |
3  | trait OutlinePrint: fmt::Display {
   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint::outline_print`
4  |     fn outline_print(&amp;self) {
   |        ------------- required by a bound in this associated function

For more information about this error, try `rustc --explain E0277`.
error: could not compile `traits-example` (bin "traits-example") due to 2 previous errors
</code></pre>
<p>이를 해결하기 위해, 다음과 같이 <code>Point</code>에 <code>Display</code>를 구현하여 <code>OutlinePrint</code>가 요구하는 제약 조건을 충족시킵니다.</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("* {output} *");
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl OutlinePrint for Point {}
</span><span class="boring">
</span>use std::fmt;

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>그러면 <code>Point</code>에 <code>OutlinePrint</code> 트레이트를 구현하는 것이 성공적으로 컴파일될 것이며, <code>Point</code> 인스턴스에서 <code>outline_print</code>를 호출하여 별표 테두리 안에 이를 표시할 수 있습니다.</p>
<h3 id="외부-타입에-외부-트레이트를-구현하기-위해-뉴타입-패턴-사용하기"><a class="header" href="#외부-타입에-외부-트레이트를-구현하기-위해-뉴타입-패턴-사용하기">외부 타입에 외부 트레이트를 구현하기 위해 뉴타입 패턴 사용하기</a></h3>
<p>10장의 <a href="ch10-02-traits.html#implementing-a-trait-on-a-type">“타입에 트레이트 구현하기”</a><!-- ignore -->에서 우리는 트레이트나 타입 중 하나가 우리 크레이트에 로컬인 경우에만 타입에 트레이트를 구현할 수 있다는 고립 규칙(orphan rule)에 대해 언급했습니다. 튜플 구조체에서 새로운 타입을 생성하는 _뉴타입 패턴(newtype pattern)_을 사용하면 이 제한을 우회할 수 있습니다. (우리는 5장의 <a href="ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types">“이름이 없는 필드를 가진 튜플 구조체를 사용하여 다른 타입 만들기”</a><!-- ignore -->에서 튜플 구조체를 다루었습니다.) 튜플 구조체는 하나의 필드를 가지며 우리가 트레이트를 구현하고자 하는 타입을 감싸는 얇은 래퍼(wrapper)가 됩니다. 그러면 이 래퍼 타입은 우리 크레이트에 로컬이 되므로, 우리는 래퍼에 트레이트를 구현할 수 있습니다. _뉴타입(Newtype)_은 하스켈(Haskell) 프로그래밍 언어에서 유래한 용어입니다. 이 패턴을 사용한다고 해서 런타임 성능 저하가 발생하지는 않으며, 래퍼 타입은 컴파일 시간에 생략됩니다.</p>
<p>예를 들어, <code>Vec&lt;T&gt;</code>에 <code>Display</code>를 구현하고 싶다고 해봅시다. 고립 규칙은 <code>Display</code> 트레이트와 <code>Vec&lt;T&gt;</code> 타입 모두 우리 크레이트 외부에서 정의되었기 때문에 우리가 이를 직접 하는 것을 방지합니다. 우리는 <code>Vec&lt;T&gt;</code> 인스턴스를 보관하는 <code>Wrapper</code> 구조체를 만들 수 있습니다. 그런 다음 예제 20-24에 표시된 대로 <code>Wrapper</code>에 <code>Display</code>를 구현하고 <code>Vec&lt;T&gt;</code> 값을 사용할 수 있습니다.</p>
<Listing number="20-24" file-name="src/main.rs" caption="Creating a `Wrapper` type around `Vec<String>` to implement `Display`">
<pre><pre class="playground"><code class="language-rust edition2021">use std::fmt;

struct Wrapper(Vec&lt;String&gt;);

impl fmt::Display for Wrapper {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}

fn main() {
    let w = Wrapper(vec![String::from("hello"), String::from("world")]);
    println!("w = {w}");
}</code></pre></pre>
</Listing>
<p><code>Wrapper</code>는 튜플 구조체이고 <code>Vec&lt;T&gt;</code>는 튜플의 인덱스 0에 있는 아이템이므로, <code>Display</code> 구현에서는 <code>self.0</code>을 사용하여 내부의 <code>Vec&lt;T&gt;</code>에 접근합니다. 이제 <code>Wrapper</code>에서 <code>Display</code> 트레이트의 기능을 사용할 수 있습니다.</p>
<p>이 기술을 사용하는 것의 단점은 <code>Wrapper</code>가 새로운 타입이기 때문에, 자신이 들고 있는 값의 메서드들을 가지고 있지 않다는 점입니다. 우리는 <code>Wrapper</code>가 정확히 <code>Vec&lt;T&gt;</code>처럼 취급될 수 있도록, 모든 메서드가 <code>self.0</code>으로 위임되는 <code>Vec&lt;T&gt;</code>의 모든 메서드들을 <code>Wrapper</code>에 직접 구현해야 할 것입니다. 만약 새로운 타입이 내부 타입이 가진 모든 메서드를 갖기를 원한다면, 15장의 <a href="ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait">“<code>Deref</code> 트레이트로 스마트 포인터를 일반 참조처럼 다루기”</a><!-- ignore -->에서 다룬 <code>Deref</code> 트레이트를 <code>Wrapper</code>에 구현하여 내부 타입을 반환하도록 하는 것이 해결책이 될 수 있습니다. 만약 <code>Wrapper</code> 타입이 내부 타입의 모든 메서드를 갖기를 원하지 않는다면 (예를 들어 <code>Wrapper</code> 타입의 동작을 제한하고 싶다면), 우리가 원하는 메서드들만 수동으로 구현해야 합니다.</p>
<p>이 뉴타입 패턴은 트레이트와 관련이 없을 때도 유용합니다. 이제 화제를 돌려 러스트의 타입 시스템과 상호작용하는 몇 가지 고급 방법들을 살펴보겠습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="고급-타입"><a class="header" href="#고급-타입">고급 타입</a></h2>
<p>러스트 타입 시스템에는 지금까지 언급은 했지만 아직 논의하지 않은 몇 가지 기능들이 있습니다. 먼저 뉴타입이 타입으로서 왜 유용한지 살펴보면서 일반적인 뉴타입에 대해 논의하겠습니다. 그런 다음 뉴타입과 유사하지만 의미론적으로 약간 다른 기능인 타입 별칭(type aliases)으로 넘어가겠습니다. 또한 <code>!</code> 타입과 동적 크기 타입(dynamically sized types)에 대해서도 논의할 것입니다.</p>
<h3 id="타입-안전성과-추상화를-위해-뉴타입-패턴-사용하기"><a class="header" href="#타입-안전성과-추상화를-위해-뉴타입-패턴-사용하기">타입 안전성과 추상화를 위해 뉴타입 패턴 사용하기</a></h3>
<p>이 섹션은 여러분이 앞서 <a href="ch20-02-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types">“외부 타입에 외부 트레이트를 구현하기 위해 뉴타입 패턴 사용하기”</a><!-- ignore --> 섹션을 읽었다고 가정합니다. 뉴타입 패턴은 우리가 지금까지 논의한 것 이상의 작업에도 유용하며, 여기에는 값이 혼동되지 않도록 정적으로 강제하는 것과 값의 단위를 나타내는 것이 포함됩니다. 예제 20-16에서 단위를 나타내기 위해 뉴타입을 사용하는 예를 보았습니다. <code>Millimeters</code>와 <code>Meters</code> 구조체가 <code>u32</code> 값을 뉴타입으로 감쌌던 것을 상기해 보세요. 만약 우리가 <code>Millimeters</code> 타입의 파라미터를 가진 함수를 작성한다면, 실수로 <code>Meters</code> 타입이나 평범한 <code>u32</code> 값으로 해당 함수를 호출하려는 프로그램은 컴파일되지 않을 것입니다.</p>
<p>또한 뉴타입 패턴을 사용하여 타입의 일부 구현 세부 사항을 추상화할 수 있습니다. 새로운 타입은 비공개(private)인 내부 타입의 API와는 다른 공개(public) API를 노출할 수 있습니다.</p>
<p>뉴타입은 또한 내부 구현을 숨길 수 있습니다. 예를 들어, 사람의 ID와 이름을 연결하여 저장하는 <code>HashMap&lt;i32, String&gt;</code>을 감싸는 <code>People</code> 타입을 제공할 수 있습니다. <code>People</code>을 사용하는 코드는 우리가 제공하는 공개 API(예: <code>People</code> 컬렉션에 이름 문자열을 추가하는 메서드)하고만 상호작용할 뿐이며, 우리가 내부적으로 이름에 <code>i32</code> ID를 할당한다는 사실을 알 필요가 없습니다. 뉴타입 패턴은 18장의 <a href="ch18-01-what-is-oo.html#encapsulation-that-hides-implementation-details">“구현 세부 정보를 숨기는 캡슐화”</a><!-- ignore -->에서 다루었던 구현 세부 사항을 숨기는 캡슐화를 달성하는 가벼운 방법입니다.</p>
<h3 id="타입-별칭으로-타입-동의어-만들기"><a class="header" href="#타입-별칭으로-타입-동의어-만들기">타입 별칭으로 타입 동의어 만들기</a></h3>
<p>러스트는 기존 타입에 다른 이름을 부여하는 _타입 별칭(type alias)_을 선언하는 기능을 제공합니다. 이를 위해 <code>type</code> 키워드를 사용합니다. 예를 들어, 다음과 같이 <code>i32</code>에 대한 별칭 <code>Kilometers</code>를 만들 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    type Kilometers = i32;
<span class="boring">
</span><span class="boring">    let x: i32 = 5;
</span><span class="boring">    let y: Kilometers = 5;
</span><span class="boring">
</span><span class="boring">    println!("x + y = {}", x + y);
</span><span class="boring">}</span></code></pre></pre>
<p>이제 별칭 <code>Kilometers</code>는 <code>i32</code>에 대한 _동의어(synonym)_입니다. 예제 20-16에서 만들었던 <code>Millimeters</code>나 <code>Meters</code> 타입과는 달리, <code>Kilometers</code>는 별개의 새로운 타입이 아닙니다. <code>Kilometers</code> 타입을 가진 값은 <code>i32</code> 타입의 값과 똑같이 취급됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    type Kilometers = i32;

    let x: i32 = 5;
    let y: Kilometers = 5;

    println!("x + y = {}", x + y);
<span class="boring">}</span></code></pre></pre>
<p><code>Kilometers</code>와 <code>i32</code>는 같은 타입이므로, 두 타입의 값을 서로 더할 수 있고 <code>i32</code> 파라미터를 받는 함수에 <code>Kilometers</code> 값을 전달할 수 있습니다. 하지만 이 방식으로는 앞서 논의한 뉴타입 패턴에서 얻을 수 있는 타입 검사 이점을 얻지 못합니다. 즉, 어딘가에서 <code>Kilometers</code>와 <code>i32</code> 값을 섞어서 사용하더라도 컴파일러는 에러를 내지 않을 것입니다.</p>
<p>타입 동의어의 주요 사용 사례는 반복을 줄이는 것입니다. 예를 들어, 다음과 같이 긴 타입이 있을 수 있습니다.</p>
<pre><code class="language-rust ignore">Box&lt;dyn Fn() + Send + 'static&gt;</code></pre>
<p>코드 곳곳에서 함수 시그니처나 타입 어노테이션으로 이 긴 타입을 쓰는 것은 지루하고 실수하기 쉽습니다. 예제 20-25와 같은 코드로 가득 찬 프로젝트를 상상해 보세요.</p>
<Listing number="20-25" caption="Using a long type in many places">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let f: Box&lt;dyn Fn() + Send + 'static&gt; = Box::new(|| println!("안녕"));

    fn takes_long_type(f: Box&lt;dyn Fn() + Send + 'static&gt;) {
        // --생략--
    }

    fn returns_long_type() -&gt; Box&lt;dyn Fn() + Send + 'static&gt; {
        // --생략--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>타입 별칭은 반복을 줄임으로써 이 코드를 더 관리하기 쉽게 만들어 줍니다. 예제 20-26에서는 장황한 타입을 위해 <code>Thunk</code>라는 별칭을 도입했으며, 해당 타입의 모든 사용처를 짧은 별칭인 <code>Thunk</code>로 대체할 수 있습니다.</p>
<Listing number="20-26" caption="Introducing a type alias, `Thunk`, to reduce repetition">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    type Thunk = Box&lt;dyn Fn() + Send + 'static&gt;;

    let f: Thunk = Box::new(|| println!("안녕"));

    fn takes_long_type(f: Thunk) {
        // --생략--
    }

    fn returns_long_type() -&gt; Thunk {
        // --생략--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 코드는 훨씬 읽고 쓰기 쉽습니다! 타입 별칭에 의미 있는 이름을 선택하면 의도를 전달하는 데에도 도움이 될 수 있습니다 (_thunk_는 나중에 평가될 코드를 의미하는 단어이므로, 저장되는 클로저에 적절한 이름입니다).</p>
<p>타입 별칭은 반복을 줄이기 위해 <code>Result&lt;T, E&gt;</code> 타입과 함께 자주 사용되기도 합니다. 표준 라이브러리의 <code>std::io</code> 모듈을 예로 들어보겠습니다. I/O 작업은 작업이 실패하는 상황을 처리하기 위해 종종 <code>Result&lt;T, E&gt;</code>를 반환합니다. 이 라이브러리에는 모든 가능한 I/O 에러를 나타내는 <code>std::io::Error</code> 구조체가 있습니다. <code>std::io</code>에 있는 많은 함수는 <code>E</code>가 <code>std::io::Error</code>인 <code>Result&lt;T, E&gt;</code>를 반환할 것입니다. 예를 들어 <code>Write</code> 트레이트의 다음 함수들이 그러합니다.</p>
<pre><code class="language-rust noplayground">use std::fmt;
use std::io::Error;

pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;
}</code></pre>
<p><code>Result&lt;..., Error&gt;</code>가 매우 많이 반복됩니다. 이에 따라 <code>std::io</code>에는 다음과 같은 타입 별칭 선언이 있습니다.</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span>type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
<span class="boring">
</span><span class="boring">pub trait Write {
</span><span class="boring">    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
</span><span class="boring">    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;
</span><span class="boring">
</span><span class="boring">    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
</span><span class="boring">    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
</span><span class="boring">}</span></code></pre>
<p>이 선언은 <code>std::io</code> 모듈에 있기 때문에, 우리는 완전 정규화된 별칭인 <code>std::io::Result&lt;T&gt;</code>를 사용할 수 있습니다. 즉, <code>E</code>가 <code>std::io::Error</code>로 채워진 <code>Result&lt;T, E&gt;</code>입니다. 결과적으로 <code>Write</code> 트레이트 함수의 시그니처는 다음과 같이 보이게 됩니다.</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
</span><span class="boring">
</span>pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
}</code></pre>
<p>타입 별칭은 두 가지 면에서 도움이 됩니다. 코드를 작성하기 쉽게 만들어 주며, <code>std::io</code> 전체에 걸쳐 일관된 인터페이스를 제공합니다. 이것은 별칭일 뿐이므로 다른 <code>Result&lt;T, E&gt;</code>와 동일하며, 따라서 <code>Result&lt;T, E&gt;</code>에서 작동하는 모든 메서드뿐만 아니라 <code>?</code> 연산자와 같은 특별한 문법도 함께 사용할 수 있습니다.</p>
<h3 id="결코-반환하지-않는-네버-타입"><a class="header" href="#결코-반환하지-않는-네버-타입">결코 반환하지 않는 네버 타입</a></h3>
<p>러스트에는 <code>!</code>라는 특별한 타입이 있는데, 타입 이론 용어로는 값이 없기 때문에 _빈 타입(empty type)_으로 알려져 있습니다. 우리는 함수가 결코 반환되지 않을 때 반환 타입의 자리에 위치하기 때문에 이를 _네버 타입(never type)_이라고 부르는 것을 선호합니다. 다음은 그 예입니다.</p>
<pre><code class="language-rust noplayground">fn bar() -&gt; ! {
    // --생략--
<span class="boring">    panic!();
</span>}</code></pre>
<p>이 코드는 “함수 <code>bar</code>는 네버를 반환한다”라고 읽습니다. 네버를 반환하는 함수를 _발산하는 함수(diverging functions)_라고 부릅니다. 우리는 <code>!</code> 타입의 값을 생성할 수 없으므로 <code>bar</code>는 결코 반환될 수 없습니다.</p>
<p>그런데 값을 결코 생성할 수 없는 타입이 무슨 소용이 있을까요? 숫자 맞추기 게임의 일부였던 예제 2-5의 코드를 떠올려 보세요. 예제 20-27에 그 일부를 다시 가져왔습니다.</p>
<Listing number="20-27" caption="A `match` with an arm that ends in `continue`">
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("비밀 번호는: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(추측을 입력하세요.);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        // --생략--
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("줄 읽기 실패");
</span><span class="boring">
</span>        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };
<span class="boring">
</span><span class="boring">        println!("당신의 추측: {guess}");
</span><span class="boring">
</span><span class="boring">        // --생략--
</span><span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!("너무 작아요!"),
</span><span class="boring">            Ordering::Greater =&gt; println!("너무 커요!"),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!("당신이 이겼습니다!");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>당시에 우리는 이 코드의 일부 세부 사항을 건너뛰었습니다. 6장의 <a href="ch06-02-match.html#the-match-control-flow-operator">“<code>match</code> 제어 흐름 연산자”</a><!-- ignore -->에서 우리는 <code>match</code> 암(arm)들이 모두 같은 타입을 반환해야 한다고 논의했습니다. 따라서 예를 들어 다음 코드는 작동하지 않습니다.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let guess = "3";
</span>    let guess = match guess.trim().parse() {
        Ok(_) =&gt; 5,
        Err(_) =&gt; "hello",
    };
<span class="boring">}</span></code></pre>
<p>이 코드에서 <code>guess</code>의 타입은 정수_이면서 동시에_ 문자열이어야 하는데, 러스트는 <code>guess</code>가 단 하나의 타입만 가질 것을 요구합니다. 그렇다면 <code>continue</code>는 무엇을 반환할까요? 예제 20-27에서 어떻게 한쪽 암에서는 <code>u32</code>를 반환하고 다른 쪽 암은 <code>continue</code>로 끝낼 수 있었을까요?</p>
<p>여러분이 짐작하셨겠지만, <code>continue</code>는 <code>!</code> 값을 가집니다. 즉, 러스트가 <code>guess</code>의 타입을 계산할 때 두 <code>match</code> 암을 모두 살피는데, 전자는 <code>u32</code> 값을 가지고 후자는 <code>!</code> 값을 가집니다. <code>!</code>는 결코 값을 가질 수 없기 때문에, 러스트는 <code>guess</code>의 타입이 <code>u32</code>라고 결정합니다.</p>
<p>이 동작을 설명하는 공식적인 방법은 <code>!</code> 타입의 표현식은 다른 어떤 타입으로도 강제 변환(coerced)될 수 있다는 것입니다. 우리가 이 <code>match</code> 암을 <code>continue</code>로 끝낼 수 있는 이유는 <code>continue</code>가 값을 반환하지 않기 때문입니다. 대신 제어 흐름을 루프의 처음으로 되돌리므로, <code>Err</code> 케이스에서는 <code>guess</code>에 결코 값을 할당하지 않게 됩니다.</p>
<p>네버 타입은 <code>panic!</code> 매크로와 함께 사용할 때도 유용합니다. <code>Option&lt;T&gt;</code> 값에서 값을 생성하거나 패닉을 일으키기 위해 호출하는 <code>unwrap</code> 함수의 정의를 떠올려 보세요.</p>
<pre><code class="language-rust ignore"><span class="boring">enum Option&lt;T&gt; {
</span><span class="boring">    Some(T),
</span><span class="boring">    None,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::Option::*;
</span><span class="boring">
</span>impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!(`None` 값에 대해 `Option::unwrap()`을 호출했습니다),
        }
    }
}</code></pre>
<p>이 코드에서도 예제 20-27의 <code>match</code>와 같은 일이 일어납니다. 러스트는 <code>val</code>이 <code>T</code> 타입을 가지고 <code>panic!</code>이 <code>!</code> 타입을 가지는 것을 확인하므로, 전체 <code>match</code> 표현식의 결과는 <code>T</code>가 됩니다. 이 코드가 작동하는 이유는 <code>panic!</code>이 값을 생성하는 대신 프로그램을 종료하기 때문입니다. <code>None</code> 케이스의 경우 <code>unwrap</code>에서 값을 반환하지 않게 되므로, 이 코드는 유효합니다.</p>
<p><code>!</code> 타입을 갖는 마지막 표현식은 <code>loop</code>입니다.</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    print!("영원히 ");

    loop {
        print!("그리고 언제까지나 ");
    }
<span class="boring">}</span></code></pre>
<p>여기서 루프는 결코 끝나지 않으므로, 표현식의 값은 <code>!</code>가 됩니다. 하지만 <code>break</code>를 포함한다면 이야기가 달라지는데, <code>break</code>에 도달했을 때 루프가 종료되기 때문입니다.</p>
<h3 id="동적-크기-타입과-sized-트레이트"><a class="header" href="#동적-크기-타입과-sized-트레이트">동적 크기 타입과 <code>Sized</code> 트레이트</a></h3>
<p>러스트는 특정 타입의 값에 대해 얼마만큼의 공간을 할당해야 하는지와 같은 타입에 대한 특정 세부 사항을 알아야 합니다. 이 때문에 타입 시스템의 한 구석이 처음에는 조금 혼란스러울 수 있는데, 바로 _동적 크기 타입(dynamically sized types)_이라는 개념입니다. 때때로 <em>DST</em> 또는 _크기가 정해지지 않은 타입(unsized types)_이라고도 불리는 이 타입들은 런타임에만 크기를 알 수 있는 값을 사용하여 코드를 작성할 수 있게 해줍니다.</p>
<p>이 책 전반에 걸쳐 사용해 온 <code>str</code>이라는 동적 크기 타입에 대해 자세히 알아보겠습니다. 그렇습니다, <code>&amp;str</code>이 아니라 <code>str</code> 그 자체가 DST입니다. 우리는 런타임 전까지는 문자열이 얼마나 긴지 알 수 없으며, 이는 우리가 <code>str</code> 타입의 변수를 생성하거나 <code>str</code> 타입의 인수를 받을 수 없음을 의미합니다. 작동하지 않는 다음 코드를 살펴보세요.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1: str = "Hello there!";
    let s2: str = "잘 지내시나요?";
<span class="boring">}</span></code></pre>
<p>러스트는 특정 타입의 모든 값에 대해 얼마만큼의 메모리를 할당해야 하는지 알아야 하며, 같은 타입의 모든 값은 동일한 양의 메모리를 사용해야 합니다. 만약 러스트가 이 코드를 허용했다면, 이 두 <code>str</code> 값은 동일한 양의 공간을 차지해야 했을 것입니다. 하지만 이들은 길이가 다릅니다. <code>s1</code>은 12바이트의 저장 공간이 필요하고 <code>s2</code>는 15바이트가 필요합니다. 이것이 동적 크기 타입을 담는 변수를 생성하는 것이 불가능한 이유입니다.</p>
<p>그렇다면 어떻게 해야 할까요? 이 경우 여러분은 이미 답을 알고 있습니다. <code>s1</code>과 <code>s2</code>의 타입을 <code>str</code>이 아닌 <code>&amp;str</code>로 만드는 것입니다. 4장의 <a href="ch04-03-slices.html#string-slices">“문자열 슬라이스”</a><!-- ignore -->에서 슬라이스 데이터 구조는 슬라이스의 시작 위치와 길이만을 저장한다고 했던 것을 상기해 보세요. 따라서 <code>&amp;T</code>는 <code>T</code>가 위치한 메모리 주소를 저장하는 단일 값이지만, <code>&amp;str</code>은 <code>str</code>의 주소와 그 길이라는 _두 개_의 값입니다. 이처럼 우리는 컴파일 시간에 <code>&amp;str</code> 값의 크기를 알 수 있습니다. 그것은 <code>usize</code> 길이의 두 배입니다. 즉, 우리는 참조하는 문자열이 아무리 길더라도 <code>&amp;str</code>의 크기를 항상 알 수 있습니다. 일반적으로 이것이 러스트에서 동적 크기 타입이 사용되는 방식입니다. 이들은 동적 정보의 크기를 저장하는 추가적인 메타데이터를 가집니다. 동적 크기 타입의 황금률은 우리가 반드시 동적 크기 타입의 값을 어떤 종류의 포인터 뒤에 두어야 한다는 것입니다.</p>
<p>우리는 <code>str</code>을 모든 종류의 포인터와 결합할 수 있습니다. 예를 들어 <code>Box&lt;str&gt;</code>이나 <code>Rc&lt;str&gt;</code>이 있습니다. 사실, 여러분은 이미 다른 동적 크기 타입인 트레이트에서 이를 본 적이 있습니다. 모든 트레이트는 트레이트의 이름을 사용하여 참조할 수 있는 동적 크기 타입입니다. 18장의 <a href="ch18-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">“다른 타입의 값을 허용하는 트레이트 객체 사용하기”</a><!-- ignore -->에서 트레이트를 트레이트 객체로 사용하려면 <code>&amp;dyn Trait</code>나 <code>Box&lt;dyn Trait&gt;</code> (<code>Rc&lt;dyn Trait&gt;</code>도 가능)와 같이 포인터 뒤에 두어야 한다고 언급했습니다.</p>
<p>DST를 다루기 위해, 러스트는 타입의 크기를 컴파일 시간에 알 수 있는지 여부를 결정하는 <code>Sized</code> 트레이트를 제공합니다. 이 트레이트는 컴파일 시간에 크기를 알 수 있는 모든 것에 대해 자동으로 구현됩니다. 또한, 러스트는 모든 제네릭 함수에 대해 <code>Sized</code> 바운드를 암묵적으로 추가합니다. 즉, 다음과 같은 제네릭 함수 정의는</p>
<pre><code class="language-rust ignore">fn generic&lt;T&gt;(t: T) {
    // --생략--
}</code></pre>
<p>사실상 다음과 같이 작성한 것과 같이 취급됩니다.</p>
<pre><code class="language-rust ignore">fn generic&lt;T: Sized&gt;(t: T) {
    // --생략--
}</code></pre>
<p>기본적으로 제네릭 함수는 컴파일 시간에 크기가 알려진 타입에 대해서만 작동합니다. 하지만 다음과 같은 특별한 문법을 사용하여 이 제한을 완화할 수 있습니다.</p>
<pre><code class="language-rust ignore">fn generic&lt;T: ?Sized&gt;(t: &amp;T) {
    // --생략--
}</code></pre>
<p><code>?Sized</code> 트레이트 바운드는 “<code>T</code>는 <code>Sized</code>일 수도 있고 아닐 수도 있다”는 것을 의미하며, 이 표기법은 제네릭 타입이 컴파일 시간에 알려진 크기를 가져야 한다는 기본 규칙을 덮어씁니다. 이러한 의미를 갖는 <code>?Trait</code> 문법은 오직 <code>Sized</code>에 대해서만 사용 가능하며, 다른 트레이트에는 사용할 수 없습니다.</p>
<p>또한 <code>t</code> 파라미터의 타입을 <code>T</code>에서 <code>&amp;T</code>로 변경했다는 점에 주목하세요. 해당 타입이 <code>Sized</code>가 아닐 수도 있기 때문에, 우리는 이를 어떤 종류의 포인터 뒤에서 사용해야 합니다. 이 경우에는 참조자를 선택했습니다.</p>
<p>다음으로 함수와 클로저에 대해 이야기하겠습니다!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="고급-함수와-클로저"><a class="header" href="#고급-함수와-클로저">고급 함수와 클로저</a></h2>
<p>이 섹션에서는 함수 포인터와 클로저 반환을 포함하여 함수 및 클로저와 관련된 몇 가지 고급 기능을 살펴봅니다.</p>
<h3 id="함수-포인터"><a class="header" href="#함수-포인터">함수 포인터</a></h3>
<p>우리는 함수에 클로저를 전달하는 방법에 대해 이야기했습니다. 그런데 일반 함수를 함수에 전달할 수도 있습니다! 이 기술은 새로운 클로저를 정의하는 대신 이미 정의한 함수를 전달하고 싶을 때 유용합니다. 함수는 <code>fn</code> 타입(소문자 f)으로 강제 변환(coerce)되는데, 이는 <code>Fn</code> 클로저 트레이트와 혼동해서는 안 됩니다. <code>fn</code> 타입을 _함수 포인터(function pointer)_라고 부릅니다. 함수 포인터로 함수를 전달하면 함수를 다른 함수의 인수로 사용할 수 있습니다.</p>
<p>파라미터가 함수 포인터임을 지정하는 문법은 클로저의 문법과 유사합니다. 예제 20-28에 표시된 것처럼 파라미터에 1을 더하는 <code>add_one</code> 함수를 정의했습니다. <code>do_twice</code> 함수는 두 개의 파라미터를 받습니다. 하나는 <code>i32</code> 파라미터를 받아 <code>i32</code>를 반환하는 임의의 함수에 대한 함수 포인터이고, 다른 하나는 하나의 <code>i32</code> 값입니다. <code>do_twice</code> 함수는 함수 <code>f</code>를 두 번 호출하면서 <code>arg</code> 값을 전달하고, 두 함수 호출 결과를 합산합니다. <code>main</code> 함수는 <code>add_one</code>과 <code>5</code>를 인수로 하여 <code>do_twice</code>를 호출합니다.</p>
<Listing number="20-28" file-name="src/main.rs" caption="Using the `fn` type to accept a function pointer as an argument">
<pre><pre class="playground"><code class="language-rust edition2021">fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!("결과값은: {answer}");
}</code></pre></pre>
</Listing>
<p>이 코드는 <code>결과값은: 12</code>를 출력합니다. <code>do_twice</code>의 파라미터 <code>f</code>가 <code>i32</code> 타입의 파라미터 하나를 받아 <code>i32</code>를 반환하는 <code>fn</code>임을 지정합니다. 그러면 <code>do_twice</code> 본문에서 <code>f</code>를 호출할 수 있습니다. <code>main</code>에서는 함수 이름 <code>add_one</code>을 <code>do_twice</code>의 첫 번째 인수로 전달할 수 있습니다.</p>
<p>클로저와 달리 <code>fn</code>은 트레이트가 아니라 타입이므로, <code>Fn</code> 트레이트 중 하나를 트레이트 바운드로 하는 제네릭 타입 파라미터를 선언하는 대신 <code>fn</code>을 직접 파라미터 타입으로 지정합니다.</p>
<p>함수 포인터는 세 가지 클로저 트레이트(<code>Fn</code>, <code>FnMut</code>, <code>FnOnce</code>)를 모두 구현하므로, 클로저를 기대하는 함수의 인수로 항상 함수 포인터를 전달할 수 있습니다. 여러분의 함수가 함수나 클로저를 모두 받아들일 수 있도록 제네릭 타입과 클로저 트레이트 중 하나를 사용하여 함수를 작성하는 것이 가장 좋습니다.</p>
<p>그렇긴 하지만, 클로저가 아닌 <code>fn</code>만을 허용하고 싶은 한 가지 사례는 클로저가 없는 외부 코드와 인터페이스할 때입니다. C 함수는 함수를 인수로 받을 수 있지만 C에는 클로저가 없습니다.</p>
<p>인라인으로 정의된 클로저나 이름이 있는 함수 중 하나를 사용할 수 있는 예로, 표준 라이브러리의 <code>Iterator</code> 트레이트가 제공하는 <code>map</code> 메서드의 사용 예를 살펴보겠습니다. <code>map</code> 함수를 사용하여 숫자 벡터를 문자열 벡터로 바꾸기 위해, 다음과 같이 클로저를 사용할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(|i| i.to_string()).collect();
<span class="boring">}</span></code></pre></pre>
<p>혹은 클로저 대신 다음과 같이 함수 이름을 <code>map</code>의 인수로 사용할 수도 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(ToString::to_string).collect();
<span class="boring">}</span></code></pre></pre>
<p><code>to_string</code>이라는 이름의 함수가 여러 개 존재하기 때문에, <a href="ch20-02-advanced-traits.html#advanced-traits">“고급 트레이트”</a><!-- ignore --> 섹션에서 이야기했던 완전 정규화 문법을 사용해야 한다는 점에 주의하세요. 여기서는 <code>ToString</code> 트레이트에 정의된 <code>to_string</code> 함수를 사용하고 있으며, 표준 라이브러리는 <code>Display</code>를 구현하는 모든 타입에 대해 이 트레이트를 구현해 두었습니다.</p>
<p>6장의 <a href="ch06-01-defining-an-enum.html#enum-values">“열거형 값”</a><!-- ignore --> 섹션에서 정의한 각 열거형 변형의 이름이 초기화 함수가 되기도 한다는 점을 상기해 보세요. 우리는 이러한 초기화 함수들을 클로저 트레이트를 구현하는 함수 포인터로 사용할 수 있습니다. 즉, 다음과 같이 클로저를 받는 메서드의 인수로 초기화 함수를 지정할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    enum Status {
        Value(u32),
        Stop,
    }

    let list_of_statuses: Vec&lt;Status&gt; = (0u32..20).map(Status::Value).collect();
<span class="boring">}</span></code></pre></pre>
<p>여기서는 <code>Status::Value</code>의 초기화 함수를 사용하여 <code>map</code>이 호출되는 범위 내의 각 <code>u32</code> 값을 이용해 <code>Status::Value</code> 인스턴스를 생성합니다. 어떤 사람들은 이 스타일을 선호하고, 어떤 사람들은 클로저 사용을 선호합니다. 이들은 동일한 코드로 컴파일되므로, 여러분에게 더 명확해 보이는 스타일을 사용하세요.</p>
<h3 id="클로저-반환하기"><a class="header" href="#클로저-반환하기">클로저 반환하기</a></h3>
<p>클로저는 트레이트로 표현되므로, 클로저를 직접 반환할 수는 없습니다. 트레이트를 반환하고 싶은 대부분의 경우, 대신 해당 트레이트를 구현하는 구체 타입을 함수의 반환값으로 사용할 수 있습니다. 하지만 클로저의 경우에는 반환 가능한 구체 타입이 없기 때문에 그렇게 할 수 없습니다. 예를 들어, 함수 포인터 <code>fn</code>을 반환 타입으로 사용하는 것은 허용되지 않습니다.</p>
<p>대신, 보통 10장에서 배웠던 <code>impl Trait</code> 문법을 사용합니다. <code>Fn</code>, <code>FnOnce</code>, <code>FnMut</code>를 사용하여 어떤 함수 타입이든 반환할 수 있습니다. 예를 들어, 다음 코드는 문제없이 작동할 것입니다.</p>
<pre><code class="language-rust ignore does_not_compile">fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {
    |x| x + 1
}</code></pre>
<p>하지만 13장의 <a href="ch13-01-closures.html#closure-type-inference-and-annotation">“클로저 타입 추론과 어노테이션”</a><!-- ignore --> 섹션에서 언급했듯이, 각 클로저는 자신만의 고유한 타입을 가집니다. 시그니처는 같지만 구현이 다른 여러 함수를 다뤄야 한다면, 트레이트 객체를 사용해야 합니다.</p>
<pre><code class="language-rust noplayground">fn main() {
    let handlers = vec![returns_closure(), returns_initialized_closure(123)];
    for handler in handlers {
        let output = handler(5);
        println!("{output}");
    }
}

fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}

fn returns_initialized_closure(init: i32) -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(move |x| x + init)
}</code></pre>
<p>이 코드는 문제없이 컴파일되지만, 만약 <code>impl Fn(i32) -&gt; i32</code>를 고집했다면 컴파일되지 않았을 것입니다. 트레이트 객체에 대한 더 자세한 내용은 18장의 <a href="ch18-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">“다른 타입의 값을 허용하는 트레이트 객체 사용하기”</a><!-- ignore --> 섹션을 참조하세요.</p>
<p>다음으로 매크로를 살펴보겠습니다!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="매크로"><a class="header" href="#매크로">매크로</a></h2>
<p>이 책 전반에 걸쳐 <code>println!</code>과 같은 매크로를 사용해 왔지만, 매크로가 무엇인지 그리고 어떻게 작동하는지에 대해서는 충분히 탐구하지 않았습니다. _매크로(macro)_라는 용어는 러스트의 일련의 기능을 지칭합니다. 여기에는 <code>macro_rules!</code>를 사용하는 <em>선언적(declarative)</em> 매크로와 세 가지 종류의 <em>절차적(procedural)</em> 매크로가 포함됩니다.</p>
<ul>
<li>구조체와 열거형에 사용되는 <code>derive</code> 속성으로 추가되는 코드를 지정하는 커스텀 <code>#[derive]</code> 매크로</li>
<li>모든 아이템에 사용할 수 있는 커스텀 속성을 정의하는 속성형(Attribute-like) 매크로</li>
<li>함수 호출처럼 보이지만 인수로 지정된 토큰들에 대해 작동하는 함수형(Function-like) 매크로</li>
</ul>
<p>이들 각각에 대해 차례로 살펴보겠지만, 먼저 이미 함수가 있는데 왜 매크로가 필요한지에 대해 알아보겠습니다.</p>
<h3 id="매크로와-함수의-차이점"><a class="header" href="#매크로와-함수의-차이점">매크로와 함수의 차이점</a></h3>
<p>근본적으로 매크로는 다른 코드를 작성하는 코드를 작성하는 방식이며, 이를 _메타프로그래밍(metaprogramming)_이라고 합니다. 부록 C에서는 여러분을 위해 다양한 트레이트의 구현을 생성해 주는 <code>derive</code> 속성에 대해 논의합니다. 우리는 또한 책 전반에 걸쳐 <code>println!</code>과 <code>vec!</code> 매크로를 사용해 왔습니다. 이 모든 매크로들은 여러분이 수동으로 작성한 코드보다 더 많은 코드를 생성하기 위해 _확장(expand)_됩니다.</p>
<p>메타프로그래밍은 여러분이 작성하고 유지 관리해야 하는 코드의 양을 줄이는 데 유용하며, 이는 함수의 역할이기도 합니다. 하지만 매크로는 함수가 갖지 못한 몇 가지 추가적인 능력을 갖추고 있습니다.</p>
<p>함수 시그니처는 함수가 가진 파라미터의 개수와 타입을 선언해야 합니다. 반면 매크로는 가변 인자를 받을 수 있습니다. 예를 들어 하나의 인수로 <code>println!("hello")</code>를 호출하거나 두 개의 인수로 <code>println!("hello {}", name)</code>를 호출할 수 있습니다. 또한 매크로는 컴파일러가 코드의 의미를 해석하기 전에 확장되므로, 예를 들어 주어진 타입에 대해 트레이트를 구현할 수 있습니다. 함수는 런타임에 호출되고 트레이트는 컴파일 타임에 구현되어야 하므로 함수로는 이를 수행할 수 없습니다.</p>
<p>함수 대신 매크로를 구현할 때의 단점은 매크로 정의가 함수 정의보다 더 복잡하다는 것입니다. 여러분은 러스트 코드를 작성하는 러스트 코드를 작성하고 있기 때문입니다. 이러한 간접성 때문에 매크로 정의는 일반적으로 함수 정의보다 읽고, 이해하고, 유지 관리하기가 더 어렵습니다.</p>
<p>매크로와 함수의 또 다른 중요한 차이점은, 함수는 어디서든 정의하고 어디서든 호출할 수 있는 반면, 매크로는 파일에서 호출하기 <em>전에</em> 정의하거나 스코프로 가져와야 한다는 점입니다.</p>
<h3 id="일반적인-메타프로그래밍을-위한-macro_rules를-사용한-선언적-매크로"><a class="header" href="#일반적인-메타프로그래밍을-위한-macro_rules를-사용한-선언적-매크로">일반적인 메타프로그래밍을 위한 <code>macro_rules!</code>를 사용한 선언적 매크로</a></h3>
<p>러스트에서 가장 널리 사용되는 매크로 형태는 _선언적 매크로(declarative macro)_입니다. 이들은 때때로 “예제에 의한 매크로(macros by example)”, “<code>macro_rules!</code> 매크로”, 또는 그냥 단순히 “매크로”라고 불리기도 합니다. 선언적 매크로의 핵심은 여러분이 러스트의 <code>match</code> 표현식과 유사한 것을 작성할 수 있게 해준다는 점입니다. 6장에서 논의했듯이, <code>match</code> 표현식은 표현식을 받아 그 결과값을 패턴과 비교한 다음 일치하는 패턴과 연관된 코드를 실행하는 제어 구조입니다. 매크로 또한 특정 코드와 연관된 패턴과 값을 비교합니다. 이 상황에서 값은 매크로에 전달된 리터럴 러스트 소스 코드이며, 패턴은 해당 소스 코드의 구조와 비교됩니다. 그리고 각 패턴과 연관된 코드는 일치할 경우 매크로에 전달된 코드를 대체하게 됩니다. 이 모든 과정은 컴파일 중에 일어납니다.</p>
<p>매크로를 정의하려면 <code>macro_rules!</code> 구문을 사용합니다. <code>vec!</code> 매크로가 어떻게 정의되어 있는지 살펴보면서 <code>macro_rules!</code>의 사용법을 탐구해 보겠습니다. 8장에서는 특정 값들을 가진 새로운 벡터를 생성하기 위해 <code>vec!</code> 매크로를 사용하는 방법을 다루었습니다. 예를 들어, 다음 매크로는 세 개의 정수를 포함하는 새로운 벡터를 생성합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;u32&gt; = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<p>우리는 또한 <code>vec!</code> 매크로를 사용하여 두 개의 정수를 가진 벡터나 다섯 개의 문자열 슬라이스를 가진 벡터를 만들 수도 있습니다. 값의 개수나 타입을 미리 알 수 없기 때문에 함수로는 이와 같은 일을 할 수 없습니다.</p>
<p>예제 20-29는 <code>vec!</code> 매크로의 약간 단순화된 정의를 보여줍니다.</p>
<Listing number="20-29" file-name="src/lib.rs" caption="A simplified version of the `vec!` macro definition">
<pre><code class="language-rust noplayground">#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}</code></pre>
</Listing>
<blockquote>
<p>참고: 표준 라이브러리에 있는 <code>vec!</code> 매크로의 실제 정의에는 미리 적절한 양의 메모리를 할당하는 코드가 포함되어 있습니다. 그 코드는 최적화를 위한 것이며, 예제를 단순하게 만들기 위해 여기서는 포함하지 않았습니다.</p>
</blockquote>
<p><code>#[macro_export]</code> 어노테이션은 이 매크로가 정의된 크레이트가 스코프로 들어올 때마다 이 매크로를 사용할 수 있도록 해야 함을 나타냅니다. 이 어노테이션이 없으면 매크로를 스코프로 가져올 수 없습니다.</p>
<p>그런 다음 <code>macro_rules!</code>와 정의하려는 매크로의 이름을 느낌표 <em>없이</em> 사용하여 매크로 정의를 시작합니다. 이 경우 이름은 <code>vec</code>이며, 매크로 정의의 본문을 나타내는 중괄호가 뒤따릅니다.</p>
<p><code>vec!</code> 본문의 구조는 <code>match</code> 표현식의 구조와 유사합니다. 여기서는 <code>( $( $x:expr ),* )</code> 패턴을 가진 하나의 암(arm)이 있고, 그 뒤에 <code>=&gt;</code>와 이 패턴에 연관된 코드 블록이 옵니다. 패턴이 일치하면 연관된 코드 블록이 생성됩니다. 이 매크로에는 패턴이 하나뿐이므로 일치하는 유효한 방법도 하나뿐입니다. 다른 패턴은 에러를 발생시킬 것입니다. 더 복잡한 매크로는 두 개 이상의 암을 가질 것입니다.</p>
<p>매크로 정의에서 사용하는 유효한 패턴 문법은 19장에서 다룬 패턴 문법과는 다른데, 매크로 패턴은 값이 아닌 러스트 코드 구조에 대해 매칭되기 때문입니다. 예제 20-29의 패턴 조각들이 무엇을 의미하는지 살펴보겠습니다. 전체 매크로 패턴 문법은 <a href="../reference/macros-by-example.html">러스트 레퍼런스(Rust Reference)</a>를 참조하세요.</p>
<p>먼저, 전체 패턴을 감싸기 위해 한 쌍의 소괄호를 사용합니다. 패턴과 일치하는 러스트 코드를 담을 변수를 매크로 시스템에 선언하기 위해 달러 기호(<code>$</code>)를 사용합니다. 달러 기호는 이것이 일반적인 러스트 변수가 아니라 매크로 변수임을 명확히 해줍니다. 다음으로 대체 코드에서 사용할 수 있도록 소괄호 안의 패턴과 일치하는 값들을 캡처하는 소괄호 쌍이 옵니다. <code>$()</code> 안에는 어떤 러스트 표현식과도 일치하고 그 표현식에 <code>$x</code>라는 이름을 부여하는 <code>$x:expr</code>이 있습니다.</p>
<p><code>$()</code> 뒤에 오는 쉼표는 <code>$()</code> 안의 코드와 일치하는 각 코드 인스턴스 사이에 리터럴 쉼표 구분자가 나타나야 함을 나타냅니다. <code>*</code>는 <code>*</code> 앞에 오는 것이 0번 이상 반복해서 일치할 수 있음을 지정합니다.</p>
<p><code>vec![1, 2, 3];</code>으로 이 매크로를 호출하면, <code>$x</code> 패턴은 세 개의 표현식 <code>1</code>, <code>2</code>, <code>3</code>에 대해 세 번 일치하게 됩니다.</p>
<p>이제 이 암과 연관된 코드 본문의 패턴을 살펴보겠습니다. <code>$()*</code> 안의 <code>temp_vec.push()</code>는 패턴이 몇 번 일치하느냐에 따라 패턴의 <code>$()</code>와 일치하는 각 부분에 대해 0번 이상 생성됩니다. <code>$x</code>는 일치하는 각 표현식으로 대체됩니다. <code>vec![1, 2, 3];</code>으로 이 매크로를 호출하면, 이 매크로 호출을 대체하여 생성되는 코드는 다음과 같습니다.</p>
<pre><code class="language-rust ignore">{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}</code></pre>
<p>우리는 임의의 타입의 인수를 몇 개든 받을 수 있고, 지정된 요소들을 포함하는 벡터를 생성하는 코드를 만들어낼 수 있는 매크로를 정의했습니다.</p>
<p>매크로를 작성하는 방법에 대해 더 알고 싶다면, 온라인 문서나 다니엘 킵(Daniel Keep)이 시작하고 루카스 비르트(Lukas Wirth)가 이어받은 <a href="https://veykril.github.io/tlborm/">“The Little Book of Rust Macros”</a>와 같은 다른 리소스들을 참고하세요.</p>
<h3 id="속성으로부터-코드를-생성하는-절차적-매크로"><a class="header" href="#속성으로부터-코드를-생성하는-절차적-매크로">속성으로부터 코드를 생성하는 절차적 매크로</a></h3>
<p>매크로의 두 번째 형태는 _절차적 매크로(procedural macro)_로, 함수(그리고 프로시저의 일종)와 더 비슷하게 동작합니다. 절차적 매크로는 선언적 매크로처럼 패턴을 매칭하고 코드를 다른 코드로 대체하는 대신, 어떤 코드를 입력으로 받아 그 코드에 대해 작업을 수행하고 결과물로 어떤 코드를 생성합니다. 절차적 매크로에는 커스텀 파생(custom derive), 속성형(attribute-like), 함수형(function-like)의 세 가지 종류가 있으며, 모두 비슷한 방식으로 작동합니다.</p>
<p>절차적 매크로를 만들 때, 정의는 특별한 크레이트 타입을 가진 자체 크레이트에 위치해야 합니다. 이는 향후 제거되기를 희망하는 복잡한 기술적 이유 때문입니다. 예제 20-30에서는 절차적 매크로를 정의하는 방법을 보여줍니다. 여기서 <code>some_attribute</code>는 특정 매크로 종류를 사용하기 위한 자리표시자입니다.</p>
<Listing number="20-30" file-name="src/lib.rs" caption="An example of defining a procedural macro">
<pre><code class="language-rust ignore">use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -&gt; TokenStream {
}</code></pre>
</Listing>
<p>절차적 매크로를 정의하는 함수는 <code>TokenStream</code>을 입력으로 받고 <code>TokenStream</code>을 출력으로 생성합니다. <code>TokenStream</code> 타입은 러스트에 포함된 <code>proc_macro</code> 크레이트에 정의되어 있으며 토큰 시퀀스를 나타냅니다. 이것이 매크로의 핵심입니다. 매크로가 작동하는 소스 코드가 입력 <code>TokenStream</code>을 구성하고, 매크로가 생성하는 코드가 출력 <code>TokenStream</code>이 됩니다. 또한 함수에는 우리가 어떤 종류의 절차적 매크로를 만들고 있는지 지정하는 속성이 붙어 있습니다. 동일한 크레이트에 여러 종류의 절차적 매크로를 가질 수 있습니다.</p>
<p>절차적 매크로의 서로 다른 종류들을 살펴보겠습니다. 커스텀 파생 매크로부터 시작하여, 다른 형태들과의 작은 차이점들을 설명하겠습니다.</p>
<h3 id="커스텀-derive-매크로를-작성하는-방법"><a class="header" href="#커스텀-derive-매크로를-작성하는-방법">커스텀 <code>derive</code> 매크로를 작성하는 방법</a></h3>
<p><code>hello_macro</code>라는 이름의 연관 함수 하나를 가진 <code>HelloMacro</code> 트레이트를 정의하는 <code>hello_macro</code> 크레이트를 만들어 봅시다. 사용자가 자신의 각 타입에 대해 <code>HelloMacro</code> 트레이트를 직접 구현하게 하는 대신, 사용자가 자신의 타입에 <code>#[derive(HelloMacro)]</code> 어노테이션을 달면 <code>hello_macro</code> 함수의 기본 구현을 얻을 수 있도록 절차적 매크로를 제공할 것입니다. 기본 구현은 <code>Hello, Macro! My name is TypeName!</code>을 출력하며, 여기서 <code>TypeName</code>은 이 트레이트가 정의된 타입의 이름입니다. 다시 말해, 다른 프로그래머가 우리 크레이트를 사용하여 예제 20-31과 같은 코드를 작성할 수 있게 해주는 크레이트를 작성할 것입니다.</p>
<Listing number="20-31" file-name="src/main.rs" caption="The code a user of our crate will be able to write when using our procedural macro">
<pre><code class="language-rust ignore does_not_compile">use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}</code></pre>
</Listing>
<p>작업이 완료되면 이 코드는 <code>Hello, Macro! My name is Pancakes!</code>를 출력할 것입니다. 첫 번째 단계는 다음과 같이 새로운 라이브러리 크레이트를 만드는 것입니다.</p>
<pre><code class="language-console">$ cargo new hello_macro --lib
</code></pre>
<p>다음으로, <code>HelloMacro</code> 트레이트와 그 연관 함수를 정의하겠습니다.</p>
<Listing file-name="src/lib.rs">
<pre><code class="language-rust noplayground">pub trait HelloMacro {
    fn hello_macro();
}</code></pre>
</Listing>
<p>트레이트와 그 함수가 준비되었습니다. 이 시점에서 우리 크레이트 사용자는 다음과 같이 트레이트를 구현하여 원하는 기능을 얻을 수 있습니다.</p>
<pre><code class="language-rust ignore">use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!("Hello, Macro! My name is Pancakes!");
    }
}

fn main() {
    Pancakes::hello_macro();
}</code></pre>
<p>하지만 사용자는 <code>hello_macro</code>를 사용하려는 각 타입에 대해 구현 블록을 작성해야 할 것입니다. 우리는 사용자가 이 작업을 직접 하지 않아도 되도록 하고 싶습니다.</p>
<p>또한, 트레이트가 구현된 타입의 이름을 출력하는 <code>hello_macro</code> 함수의 기본 구현을 아직 제공할 수 없습니다. 러스트는 리플렉션(reflection) 기능이 없어서 런타임에 타입의 이름을 찾아낼 수 없기 때문입니다. 컴파일 타임에 코드를 생성하기 위해 매크로가 필요합니다.</p>
<p>다음 단계는 절차적 매크로를 정의하는 것입니다. 이 글을 쓰는 시점에서는 절차적 매크로가 자체 크레이트에 있어야 합니다. 결국 이 제한은 해제될 수도 있습니다. 크레이트와 매크로 크레이트를 구성하는 관례는 다음과 같습니다. <code>foo</code>라는 이름의 크레이트가 있을 때, 커스텀 파생 절차적 매크로 크레이트의 이름은 <code>foo_derive</code>라고 짓습니다. <code>hello_macro</code> 프로젝트 내부에 <code>hello_macro_derive</code>라는 새로운 크레이트를 시작해 봅시다.</p>
<pre><code class="language-console">$ cargo new hello_macro_derive --lib
</code></pre>
<p>두 크레이트는 밀접하게 연관되어 있으므로, <code>hello_macro</code> 크레이트의 디렉토리 내에 절차적 매크로 크레이트를 생성합니다. 만약 <code>hello_macro</code>에서 트레이트 정의를 변경하면, <code>hello_macro_derive</code>에 있는 절차적 매크로의 구현도 변경해야 합니다. 두 크레이트는 개별적으로 게시되어야 하며, 이 크레이트들을 사용하는 프로그래머는 두 크레이트 모두를 의존성으로 추가하고 둘 다 스코프로 가져와야 합니다. 대신 <code>hello_macro</code> 크레이트가 <code>hello_macro_derive</code>를 의존성으로 사용하게 하고 절차적 매크로 코드를 다시 내보내기(re-export) 하도록 할 수도 있습니다. 하지만 우리가 프로젝트를 구성한 방식은 프로그래머들이 <code>derive</code> 기능을 원하지 않더라도 <code>hello_macro</code>를 사용할 수 있게 해줍니다.</p>
<p><code>hello_macro_derive</code> 크레이트를 절차적 매크로 크레이트로 선언해야 합니다. 또한 잠시 후에 보게 되겠지만 <code>syn</code>과 <code>quote</code> 크레이트의 기능이 필요하므로, 이들을 의존성으로 추가해야 합니다. <code>hello_macro_derive</code>를 위한 <em>Cargo.toml</em> 파일에 다음을 추가하세요.</p>
<Listing file-name="hello_macro_derive/Cargo.toml">
<pre><code class="language-toml">[lib]
proc-macro = true

[dependencies]
syn = "2.0"
quote = "1.0"
</code></pre>
</Listing>
<p>절차적 매크로 정의를 시작하기 위해, 예제 20-32의 코드를 <code>hello_macro_derive</code> 크레이트의 <em>src/lib.rs</em> 파일에 작성하세요. <code>impl_hello_macro</code> 함수의 정의를 추가하기 전까지는 이 코드가 컴파일되지 않는다는 점에 주의하세요.</p>
<Listing number="20-32" file-name="hello_macro_derive/src/lib.rs" caption="Code that most procedural macro crates will require in order to process Rust code">
<pre><code class="language-rust ignore does_not_compile">use proc_macro::TokenStream;
use quote::quote;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
    // 우리가 조작할 수 있는 구문 트리 형태로 러스트 코드의 표현을 구성합니다.
    let ast = syn::parse(input).unwrap();

    // 트레이트 구현을 작성합니다.
    impl_hello_macro(&amp;ast)
}</code></pre>
</Listing>
<p><code>TokenStream</code> 파싱을 담당하는 <code>hello_macro_derive</code> 함수와 구문 트리 변환을 담당하는 <code>impl_hello_macro</code> 함수로 코드를 나누었다는 점에 주목하세요. 이렇게 하면 절차적 매크로를 작성하는 것이 더 편리해집니다. 외부 함수(이 경우 <code>hello_macro_derive</code>)의 코드는 여러분이 보거나 만드는 거의 모든 절차적 매크로 크레이트에서 동일할 것입니다. 내부 함수(이 경우 <code>impl_hello_macro</code>)의 본문에 지정하는 코드는 절차적 매크로의 목적에 따라 달라질 것입니다.</p>
<p>우리는 세 개의 새로운 크레이트인 <code>proc_macro</code>, <a href="https://crates.io/crates/syn"><code>syn</code></a>, <a href="https://crates.io/crates/quote"><code>quote</code></a>를 도입했습니다. <code>proc_macro</code> 크레이트는 러스트에 기본 포함되어 있으므로 _Cargo.toml_의 의존성에 추가할 필요가 없습니다. <code>proc_macro</code> 크레이트는 우리 코드에서 러스트 코드를 읽고 조작할 수 있게 해주는 컴파일러의 API입니다.</p>
<p><code>syn</code> 크레이트는 문자열 형태의 러스트 코드를 우리가 연산을 수행할 수 있는 데이터 구조로 파싱합니다. <code>quote</code> 크레이트는 <code>syn</code> 데이터 구조를 다시 러스트 코드로 변환합니다. 이 크레이트들은 우리가 처리하고자 하는 어떤 종류의 러스트 코드라도 파싱하는 것을 훨씬 단순하게 만들어 줍니다. 러스트 코드를 위한 완전한 파서를 직접 작성하는 것은 결코 쉬운 일이 아닙니다.</p>
<p><code>hello_macro_derive</code> 함수는 우리 라이브러리의 사용자가 타입에 <code>#[derive(HelloMacro)]</code>를 지정할 때 호출될 것입니다. 이것이 가능한 이유는 여기서 <code>hello_macro_derive</code> 함수에 <code>proc_macro_derive</code> 어노테이션을 달고 우리 트레이트 이름과 일치하는 <code>HelloMacro</code>라는 이름을 지정했기 때문입니다. 이것이 대부분의 절차적 매크로가 따르는 관례입니다.</p>
<p><code>hello_macro_derive</code> 함수는 먼저 <code>input</code>을 <code>TokenStream</code>에서 우리가 해석하고 연산을 수행할 수 있는 데이터 구조로 변환합니다. 여기서 <code>syn</code>이 사용됩니다. <code>syn</code>의 <code>parse</code> 함수는 <code>TokenStream</code>을 인수로 받아 파싱된 러스트 코드를 나타내는 <code>DeriveInput</code> 구조체를 반환합니다. 예제 20-33은 <code>struct Pancakes;</code> 문자열을 파싱하여 얻은 <code>DeriveInput</code> 구조체의 관련 부분들을 보여줍니다.</p>
<Listing number="20-33" caption="The `DeriveInput` instance we get when parsing the code that has the macro’s attribute in Listing 20-31">
<pre><code class="language-rust ignore">DeriveInput {
    // --생략--

    ident: Ident {
        ident: "Pancakes",
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}</code></pre>
</Listing>
<p>이 구조체의 필드들은 우리가 파싱한 러스트 코드가 <code>Pancakes</code>라는 <code>ident</code>(식별자, 즉 이름을 의미)를 가진 유닛 구조체임을 보여줍니다. 이 구조체에는 온갖 종류의 러스트 코드를 설명하기 위한 더 많은 필드들이 있습니다. 자세한 정보는 <a href="https://docs.rs/syn/2.0/syn/struct.DeriveInput.html"><code>syn</code>의 <code>DeriveInput</code> 문서</a>를 참조하세요.</p>
<p>이제 우리가 포함시키고자 하는 새로운 러스트 코드를 작성할 <code>impl_hello_macro</code> 함수를 정의할 것입니다. 그전에, 우리 파생 매크로의 출력 또한 <code>TokenStream</code>이라는 점에 주목하세요. 반환된 <code>TokenStream</code>은 우리 크레이트 사용자가 작성한 코드에 추가되므로, 사용자가 자신의 크레이트를 컴파일할 때 수정된 <code>TokenStream</code>에 우리가 제공한 추가 기능이 포함되게 됩니다.</p>
<p>여기서 <code>syn::parse</code> 함수 호출이 실패할 경우 <code>hello_macro_derive</code> 함수가 패닉을 일으키도록 <code>unwrap</code>을 호출하고 있음을 눈치채셨을 것입니다. 절차적 매크로 API를 따르기 위해 <code>proc_macro_derive</code> 함수는 <code>Result</code>가 아닌 <code>TokenStream</code>을 반환해야 하므로, 에러 발생 시 우리 절차적 매크로가 패닉을 일으키는 것이 필요합니다. 이 예제에서는 <code>unwrap</code>을 사용하여 단순화했지만, 실제 프로덕션 코드에서는 <code>panic!</code>이나 <code>expect</code>를 사용하여 무엇이 잘못되었는지에 대한 더 구체적인 에러 메시지를 제공해야 합니다.</p>
<p>이제 어노테이션이 달린 러스트 코드를 <code>TokenStream</code>에서 <code>DeriveInput</code> 인스턴스로 변환하는 코드가 준비되었으므로, 예제 20-34와 같이 해당 타입에 <code>HelloMacro</code> 트레이트를 구현하는 코드를 생성해 봅시다.</p>
<Listing number="20-34" file-name="hello_macro_derive/src/lib.rs" caption="Implementing the `HelloMacro` trait using the parsed Rust code">
<pre><code class="language-rust ignore"><span class="boring">use proc_macro::TokenStream;
</span><span class="boring">use quote::quote;
</span><span class="boring">
</span><span class="boring">#[proc_macro_derive(HelloMacro)]
</span><span class="boring">pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
</span><span class="boring">    // 우리가 조작할 수 있는 구문 트리 형태로
</span><span class="boring">    // 러스트 코드의 표현을 구성합니다.
</span><span class="boring">    let ast = syn::parse(input).unwrap();
</span><span class="boring">
</span><span class="boring">    // 트레이트 구현을 작성합니다.
</span><span class="boring">    impl_hello_macro(&amp;ast)
</span><span class="boring">}
</span><span class="boring">
</span>fn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; TokenStream {
    let name = &amp;ast.ident;
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Hello, Macro! My name is {}!", stringify!(#name));
            }
        }
    };
    gen.into()
}</code></pre>
</Listing>
<p><code>ast.ident</code>를 사용하여 어노테이션이 달린 타입의 이름(식별자)을 담고 있는 <code>Ident</code> 구조체 인스턴스를 얻습니다. 예제 20-33의 구조체는 예제 20-31의 코드에 대해 <code>impl_hello_macro</code> 함수를 실행할 때 얻게 되는 <code>ident</code>가 <code>"Pancakes"</code>라는 값을 가진 <code>ident</code> 필드를 갖게 될 것임을 보여줍니다. 따라서 예제 20-34의 <code>name</code> 변수는 출력 시 예제 20-31에 있는 구조체의 이름인 <code>"Pancakes"</code> 문자열이 될 <code>Ident</code> 구조체 인스턴스를 포함하게 됩니다.</p>
<p><code>quote!</code> 매크로는 우리가 반환하고자 하는 러스트 코드를 정의할 수 있게 해줍니다. 컴파일러는 <code>quote!</code> 매크로 실행의 직접적인 결과와는 다른 것을 기대하므로, 이를 <code>TokenStream</code>으로 변환해야 합니다. 우리는 <code>into</code> 메서드를 호출함으로써 이를 수행하며, 이 메서드는 중간 표현(intermediate representation)을 소비하고 필요한 <code>TokenStream</code> 타입의 값을 반환합니다.</p>
<p><code>quote!</code> 매크로는 매우 멋진 템플릿 메커니즘도 제공합니다. <code>#name</code>이라고 입력하면 <code>quote!</code>는 이를 <code>name</code> 변수의 값으로 대체합니다. 일반 매크로가 작동하는 방식과 유사한 반복 작업도 수행할 수 있습니다. 자세한 소개는 <a href="https://docs.rs/quote"><code>quote</code> 크레이트 문서</a>를 확인하세요.</p>
<p>우리는 절차적 매크로가 사용자가 어노테이션을 단 타입에 대해 <code>HelloMacro</code> 트레이트 구현을 생성하기를 원하며, 이는 <code>#name</code>을 사용하여 얻을 수 있습니다. 트레이트 구현에는 <code>hello_macro</code>라는 하나의 함수가 있으며, 그 본문에는 우리가 제공하고자 하는 기능인 <code>Hello, Macro! My name is</code>와 어노테이션이 달린 타입의 이름을 출력하는 기능이 포함됩니다.</p>
<p>여기서 사용된 <code>stringify!</code> 매크로는 러스트에 내장되어 있습니다. 이 매크로는 <code>1 + 2</code>와 같은 러스트 표현식을 받아 컴파일 타임에 <code>"1 + 2"</code>와 같은 문자열 리터럴로 변환합니다. 이는 표현식을 평가한 후 결과를 <code>String</code>으로 변환하는 <code>format!</code>이나 <code>println!</code> 매크로와는 다릅니다. <code>#name</code> 입력이 문자 그대로 출력해야 할 표현식일 가능성이 있으므로 <code>stringify!</code>를 사용합니다. 또한 <code>stringify!</code>를 사용하면 컴파일 타임에 <code>#name</code>을 문자열 리터럴로 변환하므로 할당(allocation)을 절약할 수 있습니다.</p>
<p>이 시점에서 <code>hello_macro</code>와 <code>hello_macro_derive</code> 모두에서 <code>cargo build</code>가 성공적으로 완료되어야 합니다. 이제 이 크레이트들을 예제 20-31의 코드에 연결하여 절차적 매크로가 실제로 작동하는 모습을 확인해 봅시다! <code>cargo new pancakes</code> 명령을 사용하여 <em>projects</em> 디렉토리에 새로운 바이너리 프로젝트를 만듭니다. <code>pancakes</code> 크레이트의 _Cargo.toml_에 <code>hello_macro</code>와 <code>hello_macro_derive</code>를 의존성으로 추가해야 합니다. 만약 여러분의 <code>hello_macro</code>와 <code>hello_macro_derive</code> 버전을 <a href="https://crates.io/">crates.io</a>에 게시한다면 일반적인 의존성이 되겠지만, 그렇지 않다면 다음과 같이 <code>path</code> 의존성으로 지정할 수 있습니다.</p>
<pre><code class="language-toml">hello_macro = { path = "../hello_macro" }
hello_macro_derive = { path = "../hello_macro/hello_macro_derive" }
</code></pre>
<p>예제 20-31의 코드를 _src/main.rs_에 넣고 <code>cargo run</code>을 실행하세요. 그러면 <code>Hello, Macro! My name is Pancakes!</code>가 출력될 것입니다. 절차적 매크로를 통한 <code>HelloMacro</code> 트레이트 구현이 <code>pancakes</code> 크레이트에서 직접 구현할 필요 없이 포함되었습니다. <code>#[derive(HelloMacro)]</code>가 트레이트 구현을 추가해 준 것입니다.</p>
<p>다음으로, 다른 종류의 절차적 매크로들이 커스텀 파생 매크로와 어떻게 다른지 살펴보겠습니다.</p>
<h3 id="속성형attribute-like-매크로"><a class="header" href="#속성형attribute-like-매크로">속성형(Attribute-Like) 매크로</a></h3>
<p>속성형 매크로는 커스텀 파생 매크로와 유사하지만, <code>derive</code> 속성을 위한 코드를 생성하는 대신 새로운 속성을 만들 수 있게 해줍니다. 또한 더 유연합니다. <code>derive</code>는 구조체와 열거형에만 작동하는 반면, 속성은 함수와 같은 다른 아이템에도 적용될 수 있습니다. 속성형 매크로의 사용 예시는 다음과 같습니다. 웹 애플리케이션 프레임워크를 사용할 때 함수에 어노테이션을 다는 <code>route</code>라는 이름의 속성이 있다고 해봅시다.</p>
<pre><code class="language-rust ignore">#[route(GET, "/")]
fn index() {</code></pre>
<p>이 <code>#[route]</code> 속성은 프레임워크에 의해 절차적 매크로로 정의될 것입니다. 매크로 정의 함수의 시그니처는 다음과 같을 것입니다.</p>
<pre><code class="language-rust ignore">#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -&gt; TokenStream {</code></pre>
<p>여기에는 <code>TokenStream</code> 타입의 두 파라미터가 있습니다. 첫 번째는 속성의 내용, 즉 <code>GET, "/"</code> 부분을 위한 것입니다. 두 번째는 속성이 붙어 있는 아이템의 본문입니다. 이 경우 <code>fn index() {}</code>와 함수의 나머지 본문이 해당됩니다.</p>
<p>그 외에 속성형 매크로는 커스텀 파생 매크로와 동일한 방식으로 작동합니다. <code>proc-macro</code> 크레이트 타입을 가진 크레이트를 만들고 원하는 코드를 생성하는 함수를 구현하면 됩니다!</p>
<h3 id="함수형function-like-매크로"><a class="header" href="#함수형function-like-매크로">함수형(Function-Like) 매크로</a></h3>
<p>함수형 매크로는 함수 호출처럼 보이는 매크로를 정의합니다. <code>macro_rules!</code> 매크로와 유사하게 함수보다 유연합니다. 예를 들어, 인수의 개수를 미리 알 수 없는 경우에도 사용할 수 있습니다. 하지만 <code>macro_rules!</code> 매크로는 앞서 <a href="ch20-05-macros.html#declarative-macros-with-macro_rules-for-general-metaprogramming">“일반적인 메타프로그래밍을 위한 <code>macro_rules!</code>를 사용한 선언적 매크로”</a><!-- ignore --> 섹션에서 논의한 <code>match</code>와 유사한 문법으로만 정의될 수 있습니다. 함수형 매크로는 <code>TokenStream</code> 파라미터를 받으며, 다른 두 종류의 절차적 매크로와 마찬가지로 러스트 코드를 사용하여 해당 <code>TokenStream</code>을 조작하도록 정의됩니다. 함수형 매크로의 예로 다음과 같이 호출될 수 있는 <code>sql!</code> 매크로를 들 수 있습니다.</p>
<pre><code class="language-rust ignore">let sql = sql!(SELECT * FROM posts WHERE id=1);</code></pre>
<p>이 매크로는 내부에 있는 SQL 문을 파싱하고 구문적으로 올바른지 확인하는데, 이는 <code>macro_rules!</code> 매크로가 할 수 있는 것보다 훨씬 더 복잡한 처리입니다. <code>sql!</code> 매크로는 다음과 같이 정의될 것입니다.</p>
<pre><code class="language-rust ignore">#[proc_macro]
pub fn sql(input: TokenStream) -&gt; TokenStream {</code></pre>
<p>이 정의는 커스텀 파생 매크로의 시그니처와 유사합니다. 우리는 소괄호 안에 있는 토큰들을 받아서 우리가 생성하고자 하는 코드를 반환합니다.</p>
<h2 id="요약-19"><a class="header" href="#요약-19">요약</a></h2>
<p>휴! 이제 여러분의 도구 상자에는 자주 사용하지는 않겠지만 매우 특별한 상황에서 사용할 수 있다는 것을 알고 있는 몇 가지 러스트 기능들이 생겼습니다. 에러 메시지의 제안이나 다른 사람의 코드에서 이러한 개념과 문법을 만났을 때 알아볼 수 있도록 여러 복잡한 주제들을 소개했습니다. 이 장을 해결책으로 안내하는 참고 자료로 활용하세요.</p>
<p>다음으로, 책 전체에서 논의한 모든 내용을 실습에 적용하여 한 가지 프로젝트를 더 진행해 보겠습니다!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="최종-프로젝트-멀티스레드-웹-서버-만들기"><a class="header" href="#최종-프로젝트-멀티스레드-웹-서버-만들기">최종 프로젝트: 멀티스레드 웹 서버 만들기</a></h1>
<p>긴 여정이었지만, 이제 책의 끝에 도달했습니다. 이 장에서는 마지막 장들에서 다루었던 개념 중 일부를 보여주고 이전 레슨들을 요약하기 위해 한 가지 프로젝트를 더 함께 만들어 보겠습니다.</p>
<p>최종 프로젝트로, 웹 브라우저에서 그림 21-1과 같이 보이고 “hello”라고 인사하는 웹 서버를 만들 것입니다.</p>
<p><img src="img/trpl21-01.png" alt="hello from rust" /></p>
<p><span class="caption">그림 21-1: 우리의 마지막 공동 프로젝트</span></p>
<p>웹 서버를 구축하기 위한 계획은 다음과 같습니다.</p>
<ol>
<li>TCP와 HTTP에 대해 조금 배우기</li>
<li>소켓에서 TCP 연결 대기하기</li>
<li>소수의 HTTP 요청 파싱하기</li>
<li>적절한 HTTP 응답 생성하기</li>
<li>스레드 풀을 사용하여 서버의 처리량 개선하기</li>
</ol>
<p>시작하기 전에 두 가지 세부 사항을 언급해야 합니다. 첫째, 우리가 사용할 방법이 러스트로 웹 서버를 구축하는 최선의 방법은 아닐 것입니다. 커뮤니티 멤버들은 우리가 만들 것보다 더 완벽한 웹 서버 및 스레드 풀 구현을 제공하는, <a href="https://crates.io/">crates.io</a>에서 사용 가능한 다수의 프로덕션용 크레이트들을 게시해 두었습니다. 하지만 이 장의 의도는 여러분이 쉬운 길을 택하게 하는 것이 아니라 학습을 돕는 것입니다. 러스트는 시스템 프로그래밍 언어이기 때문에 우리가 작업하고 싶은 추상화 수준을 선택할 수 있으며, 다른 언어에서는 불가능하거나 실용적이지 않은 낮은 수준까지 내려갈 수 있습니다.</p>
<p>둘째, 여기서는 async와 await를 사용하지 않을 것입니다. 스레드 풀을 구축하는 것만으로도 충분히 도전적인 과제이며, 여기에 비동기 런타임 구축까지 추가하고 싶지는 않기 때문입니다! 하지만 이번 장에서 보게 될 몇 가지 동일한 문제들에 async와 await가 어떻게 적용될 수 있는지 언급할 것입니다. 궁극적으로 17장에서 언급했듯이, 많은 비동기 런타임들은 작업을 관리하기 위해 스레드 풀을 사용합니다.</p>
<p>따라서 우리는 기본적인 HTTP 서버와 스레드 풀을 수동으로 작성하여, 여러분이 미래에 사용할 수도 있는 크레이트들 이면에 있는 일반적인 아이디어와 기술들을 배울 수 있도록 할 것입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="단일-스레드-웹-서버-만들기"><a class="header" href="#단일-스레드-웹-서버-만들기">단일 스레드 웹 서버 만들기</a></h2>
<p>먼저 단일 스레드 웹 서버를 작동시키는 것부터 시작하겠습니다. 시작하기 전에 웹 서버 구축과 관련된 프로토콜에 대해 간략히 살펴보겠습니다. 이러한 프로토콜의 세부 사항은 이 책의 범위를 벗어나지만, 간략한 개요를 통해 필요한 정보를 얻을 수 있을 것입니다.</p>
<p>웹 서버와 관련된 두 가지 주요 프로토콜은 _HTTP(Hypertext Transfer Protocol)_와 _TCP(Transmission Control Protocol)_입니다. 두 프로토콜 모두 <em>요청-응답(request-response)</em> 프로토콜로, _클라이언트(client)_가 요청을 시작하고 _서버(server)_가 요청을 대기하다가 클라이언트에게 응답을 제공한다는 의미입니다. 이러한 요청과 응답의 내용은 프로토콜에 의해 정의됩니다.</p>
<p>TCP는 정보가 한 서버에서 다른 서버로 전달되는 방식에 대한 세부 사항을 기술하는 하위 수준 프로토콜이지만, 그 정보가 무엇인지는 지정하지 않습니다. HTTP는 요청과 응답의 내용을 정의함으로써 TCP 위에서 구축됩니다. 기술적으로는 HTTP를 다른 프로토콜과 함께 사용하는 것도 가능하지만, 대부분의 경우 HTTP는 TCP를 통해 데이터를 전송합니다. 우리는 TCP와 HTTP 요청 및 응답의 원시 바이트(raw bytes)를 직접 다룰 것입니다.</p>
<h3 id="tcp-연결-대기하기"><a class="header" href="#tcp-연결-대기하기">TCP 연결 대기하기</a></h3>
<p>우리 웹 서버는 TCP 연결을 대기해야 하므로, 이것이 우리가 작업할 첫 번째 부분입니다. 표준 라이브러리는 이를 가능하게 해주는 <code>std::net</code> 모듈을 제공합니다. 평소와 같은 방식으로 새 프로젝트를 만들어 봅시다.</p>
<pre><code class="language-console">$ cargo new hello
     Created binary (application) `hello` project
$ cd hello
</code></pre>
<p>이제 시작을 위해 예제 21-1의 코드를 _src/main.rs_에 입력하세요. 이 코드는 로컬 주소 <code>127.0.0.1:7878</code>에서 들어오는 TCP 스트림을 대기합니다. 들어오는 스트림이 있으면 <code>연결되었습니다!</code>라고 출력할 것입니다.</p>
<Listing number="21-1" file-name="src/main.rs" caption="Listening for incoming streams and printing a message when we receive a stream">
<pre><pre class="playground"><code class="language-rust no_run edition2021">use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        println!("연결되었습니다!");
    }
}</code></pre></pre>
</Listing>
<p><code>TcpListener</code>를 사용하여 주소 <code>127.0.0.1:7878</code>에서 TCP 연결을 대기할 수 있습니다. 주소에서 콜론 앞부분은 여러분의 컴퓨터를 나타내는 IP 주소이고(이는 모든 컴퓨터에서 동일하며 저자의 컴퓨터를 특별히 나타내는 것은 아닙니다), <code>7878</code>은 포트입니다. 우리가 이 포트를 선택한 이유는 두 가지입니다. 보통 이 포트에서는 HTTP가 허용되지 않으므로 우리 서버가 여러분의 기기에서 실행 중인 다른 웹 서버와 충돌할 가능성이 낮으며, 7878은 전화기 자판에서 _rust_를 쳤을 때의 숫자입니다.</p>
<p>이 시나리오에서 <code>bind</code> 함수는 새로운 <code>TcpListener</code> 인스턴스를 반환한다는 점에서 <code>new</code> 함수처럼 작동합니다. 이 함수가 <code>bind</code>라고 불리는 이유는 네트워킹에서 대기할 포트에 연결하는 것을 “포트에 바인딩(binding to a port)”한다고 하기 때문입니다.</p>
<p><code>bind</code> 함수는 <code>Result&lt;T, E&gt;</code>를 반환하는데, 이는 바인딩이 실패할 가능성이 있음을 나타냅니다. 예를 들어, 80번 포트에 연결하려면 관리자 권한이 필요하며(관리자가 아닌 사용자는 1023보다 큰 포트만 대기할 수 있습니다), 관리자가 아닌 상태에서 80번 포트에 연결을 시도하면 바인딩이 작동하지 않을 것입니다. 또한, 예를 들어 우리 프로그램을 두 개 실행하여 두 프로그램이 동일한 포트에서 대기하도록 하는 경우에도 바인딩은 작동하지 않습니다. 우리는 단지 학습 목적으로 기본적인 서버를 작성하는 것이므로, 이러한 종류의 에러 처리에 대해서는 걱정하지 않을 것입니다. 대신 에러가 발생하면 <code>unwrap</code>을 사용하여 프로그램을 중단시킵니다.</p>
<p><code>TcpListener</code>의 <code>incoming</code> 메서드는 스트림 시퀀스(더 정확하게는 <code>TcpStream</code> 타입의 스트림들)를 제공하는 반복자를 반환합니다. 단일 _스트림(stream)_은 클라이언트와 서버 사이의 열린 연결을 나타냅니다. _연결(connection)_은 클라이언트가 서버에 연결하고, 서버가 응답을 생성하고, 서버가 연결을 닫는 전체 요청 및 응답 프로세스의 이름입니다. 따라서 우리는 <code>TcpStream</code>으로부터 읽어 들여 클라이언트가 무엇을 보냈는지 확인하고, 스트림에 우리의 응답을 써서 클라이언트에게 데이터를 다시 보낼 것입니다. 전반적으로, 이 <code>for</code> 루프는 각 연결을 차례로 처리하고 우리가 처리할 일련의 스트림을 생성할 것입니다.</p>
<p>지금으로서 우리가 스트림을 처리하는 방식은, 스트림에 에러가 있는 경우 프로그램을 종료하도록 <code>unwrap</code>을 호출하는 것으로 구성됩니다. 에러가 없다면 프로그램은 메시지를 출력합니다. 다음 예제에서는 성공적인 경우에 대해 더 많은 기능을 추가할 것입니다. 클라이언트가 서버에 연결할 때 <code>incoming</code> 메서드로부터 에러를 받을 수 있는 이유는, 우리가 실제로 연결들에 대해 반복하는 것이 아니기 때문입니다. 대신 우리는 _연결 시도(connection attempts)_에 대해 반복하고 있습니다. 여러 가지 이유로 연결이 성공하지 못할 수 있으며, 그중 다수는 운영 체제에 따라 다릅니다. 예를 들어, 많은 운영 체제는 지원할 수 있는 동시 열린 연결 수에 제한을 둡니다. 그 수를 초과하는 새로운 연결 시도는 열린 연결 중 일부가 닫힐 때까지 에러를 발생시킬 것입니다.</p>
<p>이 코드를 실행해 봅시다! 터미널에서 <code>cargo run</code>을 실행한 다음 웹 브라우저에서 _127.0.0.1:7878_로 접속하세요. 서버가 현재 어떤 데이터도 돌려보내지 않기 때문에 브라우저에는 “연결 재설정”과 같은 에러 메시지가 표시될 것입니다. 하지만 터미널을 보면 브라우저가 서버에 연결되었을 때 출력된 여러 메시지를 볼 수 있을 것입니다!</p>
<pre><code class="language-text">     Running `target/debug/hello`
Connection established!
Connection established!
Connection established!
</code></pre>
<p>때때로 한 번의 브라우저 요청에 대해 여러 메시지가 출력되는 것을 볼 수 있는데, 그 이유는 브라우저가 페이지에 대한 요청뿐만 아니라 브라우저 탭에 나타나는 <em>favicon.ico</em> 아이콘과 같은 다른 리소스에 대한 요청도 보내기 때문일 수 있습니다.</p>
<p>또한 서버가 데이터로 응답하지 않기 때문에 브라우저가 서버에 여러 번 연결을 시도하는 것일 수도 있습니다. <code>stream</code>이 스코프를 벗어나 루프 끝에서 드롭될 때, <code>drop</code> 구현의 일부로 연결이 닫힙니다. 브라우저는 문제가 일시적일 수 있다고 판단하여 닫힌 연결에 대해 재시도를 하기도 합니다. 중요한 점은 우리가 TCP 연결에 대한 핸들을 성공적으로 얻었다는 것입니다!</p>
<p>코드의 특정 버전 실행을 마쳤을 때는 <kbd>ctrl</kbd>-<kbd>c</kbd>를 눌러 프로그램을 중단하는 것을 잊지 마세요. 그런 다음 코드를 변경할 때마다 <code>cargo run</code> 명령을 실행하여 최신 코드가 실행되고 있는지 확인하며 프로그램을 다시 시작하세요.</p>
<h3 id="요청-읽기"><a class="header" href="#요청-읽기">요청 읽기</a></h3>
<p>브라우저로부터 요청을 읽는 기능을 구현해 봅시다! 먼저 연결을 얻는 것과 그 연결로 어떤 동작을 수행하는 것에 대한 관심사를 분리하기 위해, 연결 처리를 위한 새로운 함수를 시작하겠습니다. 이 새로운 <code>handle_connection</code> 함수에서는 TCP 스트림으로부터 데이터를 읽고 이를 출력하여 브라우저에서 전송되는 데이터를 확인할 것입니다. 코드를 예제 21-2와 같이 변경하세요.</p>
<Listing number="21-2" file-name="src/main.rs" caption="Reading from the `TcpStream` and printing the data">
<pre><pre class="playground"><code class="language-rust no_run edition2021">use std::{
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
};

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    println!("요청: {http_request:#?}");
}</code></pre></pre>
</Listing>
<p>스트림을 읽고 쓰기 위해 필요한 트레이트와 타입들에 접근할 수 있도록 <code>std::io::prelude</code>와 <code>std::io::BufReader</code>를 스코프로 가져옵니다. <code>main</code> 함수의 <code>for</code> 루프에서는 연결이 되었다는 메시지를 출력하는 대신, 새로운 <code>handle_connection</code> 함수를 호출하고 여기에 <code>stream</code>을 전달합니다.</p>
<p><code>handle_connection</code> 함수에서는 <code>stream</code>에 대한 참조를 감싸는 새로운 <code>BufReader</code> 인스턴스를 생성합니다. <code>BufReader</code>는 우리 대신 <code>std::io::Read</code> 트레이트 메서드들의 호출을 관리함으로써 버퍼링 기능을 추가해 줍니다.</p>
<p>브라우저가 우리 서버에 보내는 요청의 각 줄을 수집하기 위해 <code>http_request</code>라는 변수를 만듭니다. <code>Vec&lt;_&gt;</code> 타입 어노테이션을 추가하여 이 줄들을 벡터에 수집하고 싶다는 것을 명시합니다.</p>
<p><code>BufReader</code>는 <code>lines</code> 메서드를 제공하는 <code>std::io::BufRead</code> 트레이트를 구현합니다. <code>lines</code> 메서드는 줄바꿈 바이트를 만날 때마다 데이터 스트림을 쪼개어 <code>Result&lt;String, std::io::Error&gt;</code>의 반복자를 반환합니다. 각 <code>String</code>을 얻기 위해 각 <code>Result</code>에 대해 맵(map)을 수행하고 <code>unwrap</code>을 호출합니다. 데이터가 유효한 UTF-8이 아니거나 스트림을 읽는 중에 문제가 발생하면 <code>Result</code>는 에러가 될 수 있습니다. 다시 말씀드리지만, 실제 프로덕션 프로그램은 이러한 에러를 더 우아하게 처리해야 하지만, 여기서는 단순함을 위해 에러 발생 시 프로그램을 중단시키는 방법을 택했습니다.</p>
<p>브라우저는 두 개의 줄바꿈 문자를 연속으로 보내 HTTP 요청의 끝을 알립니다. 따라서 스트림에서 하나의 요청을 얻으려면 빈 문자열인 줄이 나올 때까지 줄을 읽어 들입니다. 줄들을 벡터에 수집한 후에는, 웹 브라우저가 우리 서버에 보내는 명령들을 살펴볼 수 있도록 예쁜 디버그 포맷(pretty debug formatting)을 사용하여 출력합니다.</p>
<p>이 코드를 실행해 봅시다! 프로그램을 시작하고 웹 브라우저에서 다시 요청을 보내세요. 브라우저에는 여전히 에러 페이지가 표시되겠지만, 터미널에 표시되는 우리 프로그램의 출력은 이제 다음과 유사할 것입니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/hello`
Request: [
    "GET / HTTP/1.1",
    "Host: 127.0.0.1:7878",
    "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:99.0) Gecko/20100101 Firefox/99.0",
    "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
    "Accept-Language: en-US,en;q=0.5",
    "Accept-Encoding: gzip, deflate, br",
    "DNT: 1",
    "Connection: keep-alive",
    "Upgrade-Insecure-Requests: 1",
    "Sec-Fetch-Dest: document",
    "Sec-Fetch-Mode: navigate",
    "Sec-Fetch-Site: none",
    "Sec-Fetch-User: ?1",
    "Cache-Control: max-age=0",
]
</code></pre>
<p>브라우저에 따라 출력이 약간 다를 수 있습니다. 이제 요청 데이터를 출력하고 있으므로, 요청의 첫 번째 줄에서 <code>GET</code> 뒤에 오는 경로를 살펴봄으로써 왜 한 번의 브라우저 요청으로부터 여러 개의 연결이 발생하는지 알 수 있습니다. 반복되는 연결들이 모두 _/_를 요청하고 있다면, 브라우저가 우리 프로그램으로부터 응답을 받지 못해 반복적으로 _/_를 가져오려고 시도하고 있음을 알 수 있습니다.</p>
<p>브라우저가 우리 프로그램에 무엇을 요청하고 있는지 이해하기 위해 이 요청 데이터를 분석해 봅시다.</p>
<h3 id="http-요청-자세히-살펴보기"><a class="header" href="#http-요청-자세히-살펴보기">HTTP 요청 자세히 살펴보기</a></h3>
<p>HTTP는 텍스트 기반 프로토콜이며, 요청은 다음과 같은 형식을 가집니다.</p>
<pre><code class="language-text">Method Request-URI HTTP-Version CRLF
headers CRLF
message-body
</code></pre>
<p>첫 번째 줄은 클라이언트가 무엇을 요청하고 있는지에 대한 정보를 담고 있는 _요청 라인(request line)_입니다. 요청 라인의 첫 번째 부분은 사용 중인 <em>메서드(method)</em> (예: <code>GET</code> 또는 <code>POST</code>)를 나타내며, 이는 클라이언트가 이 요청을 어떻게 하고 있는지를 설명합니다. 우리 클라이언트는 정보를 요청하고 있음을 의미하는 <code>GET</code> 요청을 사용했습니다.</p>
<p>요청 라인의 다음 부분은 클라이언트가 요청하는 _URI(Uniform Resource Identifier)_를 나타내는 _/_입니다. URI는 _URL(Uniform Resource Locator)_과 거의 비슷하지만 완전히 같지는 않습니다. 이번 장의 목적상 URI와 URL의 차이는 중요하지 않으므로, 여기서는 그냥 URI를 URL로 생각하셔도 무방합니다.</p>
<p>마지막 부분은 클라이언트가 사용하는 HTTP 버전이며, 요청 라인은 CRLF 시퀀스로 끝납니다. (CRLF는 _캐리지 리턴(carriage return)_과 _라인 피드(line feed)_의 약자로, 타자기 시절부터 쓰던 용어입니다!) CRLF 시퀀스는 <code>\r\n</code>으로도 쓸 수 있는데, 여기서 <code>\r</code>은 캐리지 리턴이고 <code>\n</code>은 라인 피드입니다. _CRLF 시퀀스_는 요청 라인을 나머지 요청 데이터와 분리합니다. CRLF가 출력될 때는 <code>\r\n</code> 대신 새로운 줄이 시작되는 것을 볼 수 있습니다.</p>
<p>지금까지 프로그램을 실행하여 받은 요청 라인 데이터를 보면, <code>GET</code>은 메서드이고 _/_는 요청 URI이며 <code>HTTP/1.1</code>은 버전임을 알 수 있습니다.</p>
<p>요청 라인 이후에 <code>Host:</code>로 시작하는 나머지 줄들은 헤더입니다. <code>GET</code> 요청은 본문(body)이 없습니다.</p>
<p>다른 브라우저에서 요청을 보내거나 _127.0.0.1:7878/test_와 같이 다른 주소를 요청하여 요청 데이터가 어떻게 변하는지 확인해 보세요.</p>
<p>이제 브라우저가 무엇을 요청하는지 알았으니, 데이터를 다시 보내봅시다!</p>
<h3 id="응답-작성하기"><a class="header" href="#응답-작성하기">응답 작성하기</a></h3>
<p>클라이언트 요청에 대한 응답으로 데이터를 보내는 기능을 구현하겠습니다. 응답은 다음과 같은 형식을 가집니다.</p>
<pre><code class="language-text">HTTP-Version Status-Code Reason-Phrase CRLF
headers CRLF
message-body
</code></pre>
<p>첫 번째 줄은 _상태 라인(status line)_으로, 응답에 사용된 HTTP 버전, 요청 결과를 요약하는 숫자 상태 코드, 그리고 상태 코드에 대한 텍스트 설명을 제공하는 사유 구문(reason phrase)을 포함합니다. CRLF 시퀀스 다음에는 헤더들이 오고, 또 다른 CRLF 시퀀스 뒤에 응답 본문이 옵니다.</p>
<p>다음은 HTTP 버전 1.1을 사용하고 상태 코드가 200이며 OK 사유 구문을 갖고 헤더와 본문이 없는 응답의 예입니다.</p>
<pre><code class="language-text">HTTP/1.1 200 OK\r\n\r\n
</code></pre>
<p>상태 코드 200은 표준 성공 응답입니다. 이 텍스트는 아주 작은 성공적인 HTTP 응답입니다. 성공적인 요청에 대한 응답으로 이것을 스트림에 써 봅시다! <code>handle_connection</code> 함수에서 요청 데이터를 출력하던 <code>println!</code>을 제거하고 예제 21-3의 코드로 교체하세요.</p>
<Listing number="21-3" file-name="src/main.rs" caption="Writing a tiny successful HTTP response to the stream">
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">use std::{
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let response = "HTTP/1.1 200 OK\r\n\r\n";

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
</Listing>
<p>첫 번째로 추가된 줄은 성공 메시지 데이터를 담는 <code>response</code> 변수를 정의합니다. 그런 다음 <code>response</code>에 대해 <code>as_bytes</code>를 호출하여 문자열 데이터를 바이트로 변환합니다. <code>stream</code>의 <code>write_all</code> 메서드는 이 바이트들을 받아 연결을 통해 직접 전송합니다. <code>write_all</code> 작업이 실패할 수 있으므로 이전과 마찬가지로 에러 결과에 대해 <code>unwrap</code>을 사용합니다. 다시 말씀드리지만, 실제 애플리케이션에서는 여기에 에러 처리를 추가해야 합니다. 마지막으로, <code>flush</code>는 모든 바이트가 연결에 쓰여질 때까지 기다렸다가 프로그램이 계속 진행되도록 합니다. <code>TcpStream</code>은 기본 운영 체제에 대한 호출을 최소화하기 위해 내부 버퍼를 포함하고 있습니다.</p>
<p>이러한 변경 사항들을 적용하고 코드를 실행하여 요청을 보내봅시다. 이제 터미널에 데이터를 출력하지 않으므로 Cargo의 출력 외에는 아무것도 보이지 않을 것입니다. 웹 브라우저에서 _127.0.0.1:7878_로 접속하면 에러 대신 빈 페이지가 나타날 것입니다. 여러분은 방금 HTTP 요청을 받고 응답을 보내는 과정을 직접 코딩하셨습니다!</p>
<h3 id="실제-html-반환하기"><a class="header" href="#실제-html-반환하기">실제 HTML 반환하기</a></h3>
<p>빈 페이지 이상의 것을 반환하는 기능을 구현해 봅시다. 프로젝트 디렉토리의 루트( <em>src</em> 디렉토리가 아닌 곳)에 새로운 파일 _hello.html_을 만드세요. 원하는 HTML을 무엇이든 넣으셔도 됩니다. 예제 21-4는 그중 한 가지 예시입니다.</p>
<Listing number="21-4" file-name="hello.html" caption="A sample HTML file to return in a response">
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="ko"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello!&lt;/h1&gt;
    &lt;p&gt;Hi from Rust&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
</Listing>
<p>이는 헤더와 약간의 텍스트가 있는 최소한의 HTML5 문서입니다. 요청을 받았을 때 서버에서 이를 반환하기 위해, 예제 21-5와 같이 <code>handle_connection</code>을 수정하여 HTML 파일을 읽고 이를 응답 본문에 추가하여 전송하도록 하겠습니다.</p>
<Listing number="21-5" file-name="src/main.rs" caption="Sending the contents of *hello.html* as the body of the response">
<pre><pre class="playground"><code class="language-rust no_run edition2021">use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
};
// --생략--

<span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let status_line = "HTTP/1.1 200 OK";
    let contents = fs::read_to_string("hello.html").unwrap();
    let length = contents.len();

    let response =
        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
</Listing>
<p>표준 라이브러리의 파일 시스템 모듈을 스코프로 가져오기 위해 <code>use</code>문에 <code>fs</code>를 추가했습니다. 파일 내용을 문자열로 읽어 들이는 코드는 익숙하실 것입니다. 12장의 예제 12-4에서 I/O 프로젝트를 위해 파일 내용을 읽을 때 사용했었습니다.</p>
<p>다음으로, <code>format!</code>을 사용하여 파일 내용을 성공 응답의 본문으로 추가합니다. 유효한 HTTP 응답임을 보장하기 위해, 응답 본문의 크기(이 경우에는 <code>hello.html</code>의 크기)로 설정된 <code>Content-Length</code> 헤더를 추가합니다.</p>
<p><code>cargo run</code>으로 이 코드를 실행하고 브라우저에서 _127.0.0.1:7878_에 접속해 보세요. 여러분의 HTML이 렌더링된 것을 볼 수 있을 것입니다!</p>
<p>현재 우리는 <code>http_request</code>에 담긴 요청 데이터를 무시하고 HTML 파일의 내용을 무조건적으로 되돌려보내고 있습니다. 즉, 브라우저에서 _127.0.0.1:7878/something-else_를 요청하더라도 동일한 HTML 응답을 받게 된다는 뜻입니다. 지금 우리 서버는 매우 제한적이며 대부분의 웹 서버가 하는 일을 하지 못합니다. 우리는 요청에 따라 응답을 커스터마이징하고, _/_에 대한 올바른 형식의 요청에 대해서만 HTML 파일을 반환하고 싶습니다.</p>
<h3 id="요청-검증-및-선택적-응답"><a class="header" href="#요청-검증-및-선택적-응답">요청 검증 및 선택적 응답</a></h3>
<p>지금 우리 웹 서버는 클라이언트가 무엇을 요청하든 파일에 있는 HTML을 반환합니다. HTML 파일을 반환하기 전에 브라우저가 _/_를 요청하고 있는지 확인하고, 그 외의 것을 요청하면 에러를 반환하는 기능을 추가해 봅시다. 이를 위해 예제 21-6에 표시된 대로 <code>handle_connection</code>을 수정해야 합니다. 이 새로운 코드는 수신된 요청의 내용을 우리가 알고 있는 _/_에 대한 요청 형식과 비교하고, <code>if</code>와 <code>else</code> 블록을 추가하여 요청을 다르게 처리합니다.</p>
<Listing number="21-6" file-name="src/main.rs" caption="Handling requests to */* differently from other requests">
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>// --생략--

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;stream);
    let request_line = buf_reader.lines().next().unwrap().unwrap();

    if request_line == "GET / HTTP/1.1" {
        let status_line = "HTTP/1.1 200 OK";
        let contents = fs::read_to_string("hello.html").unwrap();
        let length = contents.len();

        let response = format!(
            "{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}"
        );

        stream.write_all(response.as_bytes()).unwrap();
    } else {
        // 그 외의 요청
    }
}</code></pre></pre>
</Listing>
<p>우리는 HTTP 요청의 첫 번째 줄만 살펴볼 것이므로, 전체 요청을 벡터로 읽어 들이는 대신 반복자에서 첫 번째 아이템을 얻기 위해 <code>next</code>를 호출합니다. 첫 번째 <code>unwrap</code>은 <code>Option</code>을 처리하며 반복자에 아이템이 없으면 프로그램을 중단시킵니다. 두 번째 <code>unwrap</code>은 <code>Result</code>를 처리하며 예제 21-2에서 추가된 <code>map</code> 안에 있던 <code>unwrap</code>과 동일한 효과를 냅니다.</p>
<p>다음으로, <code>request_line</code>이 <em>/</em> 경로에 대한 GET 요청의 요청 라인과 일치하는지 확인합니다. 일치한다면 <code>if</code> 블록은 HTML 파일의 내용을 반환합니다.</p>
<p><code>request_line</code>이 <em>/</em> 경로에 대한 GET 요청과 일치하지 않는다면, 이는 우리가 다른 어떤 요청을 받았음을 의미합니다. 잠시 후에 모든 다른 요청에 응답하기 위한 코드를 <code>else</code> 블록에 추가할 것입니다.</p>
<p>이제 이 코드를 실행하고 _127.0.0.1:7878_을 요청해 보세요. _hello.html_에 있는 HTML을 받게 될 것입니다. _127.0.0.1:7878/something-else_와 같이 다른 요청을 하면, 예제 21-1과 21-2의 코드를 실행했을 때 보았던 것과 같은 연결 에러가 발생할 것입니다.</p>
<p>이제 요청한 콘텐츠를 찾을 수 없음을 나타내는 상태 코드 404와 함께 응답을 반환하도록 예제 21-7의 코드를 <code>else</code> 블록에 추가해 봅시다. 또한 최종 사용자에게 응답을 표시하기 위해 브라우저에서 렌더링할 HTML도 함께 반환할 것입니다.</p>
<Listing number="21-7" file-name="src/main.rs" caption="Responding with status code 404 and an error page if anything other than */* was requested">
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    if request_line == "GET / HTTP/1.1" {
</span><span class="boring">        let status_line = "HTTP/1.1 200 OK";
</span><span class="boring">        let contents = fs::read_to_string("hello.html").unwrap();
</span><span class="boring">        let length = contents.len();
</span><span class="boring">
</span><span class="boring">        let response = format!(
</span><span class="boring">            "{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}"
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        stream.write_all(response.as_bytes()).unwrap();
</span>    // --생략--
    } else {
        let status_line = "HTTP/1.1 404 NOT FOUND";
        let contents = fs::read_to_string("404.html").unwrap();
        let length = contents.len();

        let response = format!(
            "{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}"
        );

        stream.write_all(response.as_bytes()).unwrap();
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>여기서 우리 응답은 상태 코드 404와 사유 구문 <code>NOT FOUND</code>가 포함된 상태 라인을 가집니다. 응답 본문은 <em>404.html</em> 파일에 있는 HTML이 될 것입니다. 에러 페이지를 위해 <em>hello.html</em> 옆에 <em>404.html</em> 파일을 만들어야 합니다. 다시 말씀드리지만 원하는 HTML을 사용하시거나 예제 21-8의 HTML을 사용하세요.</p>
<Listing number="21-8" file-name="404.html" caption="Sample content for the page to send back with any 404 response">
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="ko"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Oops!&lt;/h1&gt;
    &lt;p&gt;Sorry, I don't know what you're asking for.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
</Listing>
<p>이러한 변경 사항을 적용하고 서버를 다시 실행하세요. _127.0.0.1:7878_을 요청하면 _hello.html_의 내용이 반환되어야 하며, _127.0.0.1:7878/foo_와 같은 다른 모든 요청은 _404.html_의 에러 HTML을 반환해야 합니다.</p>
<h3 id="약간의-리팩터링"><a class="header" href="#약간의-리팩터링">약간의 리팩터링</a></h3>
<p>현재 <code>if</code>와 <code>else</code> 블록에는 많은 중복이 있습니다. 둘 다 파일을 읽고 그 내용을 스트림에 쓰고 있습니다. 유일한 차이점은 상태 라인과 파일 이름뿐입니다. 이러한 차이점들을 상태 라인과 파일 이름의 값을 변수에 할당하는 별도의 <code>if</code>와 <code>else</code> 라인으로 추출하여 코드를 더 간결하게 만들어 봅시다. 그런 다음 파일 읽기와 응답 쓰기 코드에서 이 변수들을 무조건적으로 사용할 수 있습니다. 예제 21-9는 거대한 <code>if</code>와 <code>else</code> 블록을 교체한 후의 결과 코드를 보여줍니다.</p>
<Listing number="21-9" file-name="src/main.rs" caption="Refactoring the `if` and `else` blocks to contain only the code that differs between the two cases">
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>// --생략--

fn handle_connection(mut stream: TcpStream) {
    // --생략--
<span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span>
    let (status_line, filename) = if request_line == "GET / HTTP/1.1" {
        ("HTTP/1.1 200 OK", "hello.html")
    } else {
        ("HTTP/1.1 404 NOT FOUND", "404.html")
    };

    let contents = fs::read_to_string(filename).unwrap();
    let length = contents.len();

    let response =
        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
</Listing>
<p>이제 <code>if</code>와 <code>else</code> 블록은 튜플 형태로 적절한 상태 라인과 파일 이름 값만 반환합니다. 그런 다음 19장에서 논의한 것처럼 <code>let</code> 문에서 패턴을 사용하는 구조 분해(destructuring)를 통해 이 두 값을 <code>status_line</code>과 <code>filename</code>에 할당합니다.</p>
<p>이전에 중복되었던 코드는 이제 <code>if</code>와 <code>else</code> 블록 밖에 있으며 <code>status_line</code>과 <code>filename</code> 변수를 사용합니다. 이렇게 하면 두 케이스 사이의 차이점을 더 쉽게 알 수 있으며, 파일 읽기 및 응답 쓰기 방식이 변경될 때 수정해야 할 곳이 한 곳뿐임을 의미합니다. 예제 21-9 코드의 동작은 예제 21-7과 동일합니다.</p>
<p>멋지네요! 이제 약 40줄의 러스트 코드로 특정 요청에는 콘텐츠 페이지로 응답하고 다른 모든 요청에는 404 응답을 보내는 간단한 웹 서버를 갖게 되었습니다.</p>
<p>현재 우리 서버는 단일 스레드에서 실행되므로 한 번에 하나의 요청만 처리할 수 있습니다. 몇 가지 느린 요청을 시뮬레이션하여 이것이 어떻게 문제가 될 수 있는지 살펴보겠습니다. 그런 다음 우리 서버가 한 번에 여러 요청을 처리할 수 있도록 수정하겠습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="단일-스레드-서버를-멀티스레드-서버로-바꾸기"><a class="header" href="#단일-스레드-서버를-멀티스레드-서버로-바꾸기">단일 스레드 서버를 멀티스레드 서버로 바꾸기</a></h2>
<p>현재 서버는 각 요청을 차례대로 처리합니다. 즉, 첫 번째 연결 처리가 끝날 때까지 두 번째 연결을 처리하지 않습니다. 서버가 점점 더 많은 요청을 받게 되면, 이러한 순차적 실행은 점점 비효율적이 될 것입니다. 만약 서버가 처리하는 데 오랜 시간이 걸리는 요청을 받으면, 새로운 요청들이 빠르게 처리될 수 있더라도 긴 요청이 끝날 때까지 기다려야 합니다. 우리는 이를 해결해야 하지만, 먼저 문제가 실제로 발생하는 모습을 살펴보겠습니다.</p>
<h3 id="현재-서버-구현에서-느린-요청-시뮬레이션하기"><a class="header" href="#현재-서버-구현에서-느린-요청-시뮬레이션하기">현재 서버 구현에서 느린 요청 시뮬레이션하기</a></h3>
<p>처리가 느린 요청이 현재 서버 구현에 대한 다른 요청들에 어떤 영향을 미치는지 살펴보겠습니다. 예제 21-10은 _/sleep_에 대한 요청을 처리하는데, 응답하기 전에 서버를 5초 동안 재우는 방식으로 느린 응답을 시뮬레이션합니다.</p>
<Listing number="21-10" file-name="src/main.rs" caption="Simulating a slow request by sleeping for 5 seconds">
<pre><pre class="playground"><code class="language-rust no_run edition2021">use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
    thread,
    time::Duration,
};
// --생략--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn handle_connection(mut stream: TcpStream) {
    // --생략--

<span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span>    let (status_line, filename) = match &amp;request_line[..] {
        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
        "GET /sleep HTTP/1.1" =&gt; {
            thread::sleep(Duration::from_secs(5));
            ("HTTP/1.1 200 OK", "hello.html")
        }
        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
    };

    // --생략--
<span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span>}</code></pre></pre>
</Listing>
<p>이제 세 가지 케이스가 생겼으므로 <code>if</code>에서 <code>match</code>로 전환했습니다. 문자열 리터럴 값에 대해 패턴 매칭을 수행하려면 <code>request_line</code>의 슬라이스에 대해 명시적으로 매칭해야 합니다. <code>match</code>는 상등 비교(equality) 메서드와 달리 자동 참조 및 역참조를 수행하지 않기 때문입니다.</p>
<p>첫 번째 암(arm)은 예제 21-9의 <code>if</code> 블록과 동일합니다. 두 번째 암은 _/sleep_에 대한 요청과 매칭됩니다. 해당 요청이 수신되면, 서버는 성공 HTML 페이지를 렌더링하기 전에 5초 동안 잠들 것입니다. 세 번째 암은 예제 21-9의 <code>else</code> 블록과 동일합니다.</p>
<p>우리 서버가 얼마나 원시적인지 알 수 있습니다. 실제 라이브러리라면 훨씬 덜 장황한 방식으로 여러 요청을 식별하고 처리했을 것입니다!</p>
<p><code>cargo run</code>으로 서버를 시작하세요. 그런 다음 브라우저 창을 두 개 여세요. 하나는 _http://127.0.0.1:7878/_용이고 다른 하나는 _http://127.0.0.1:7878/sleep_용입니다. 이전처럼 <em>/</em> URI를 몇 번 입력하면 빠르게 응답하는 것을 볼 수 있습니다. 하지만 _/sleep_을 입력한 직후에 _/_를 로드하면, _/_는 <code>sleep</code>이 5초 동안 완전히 잠든 후에야 로드되는 것을 보게 될 것입니다.</p>
<p>느린 요청 뒤로 요청들이 밀리는 것을 방지하기 위해 사용할 수 있는 여러 기술이 있습니다. 17장에서 했던 것처럼 비동기(async)를 사용하는 것도 그중 하나입니다. 우리가 구현할 방법은 스레드 풀(thread pool)입니다.</p>
<h3 id="스레드-풀을-사용하여-처리량-개선하기"><a class="header" href="#스레드-풀을-사용하여-처리량-개선하기">스레드 풀을 사용하여 처리량 개선하기</a></h3>
<p>_스레드 풀(thread pool)_은 작업을 처리할 준비를 하고 대기 중인 생성된 스레드들의 집합입니다. 프로그램이 새로운 작업을 받으면 풀에 있는 스레드 중 하나를 해당 작업에 할당하고, 그 스레드가 작업을 처리합니다. 풀의 나머지 스레드들은 첫 번째 스레드가 작업을 처리하는 동안 들어오는 다른 작업들을 처리할 수 있습니다. 첫 번째 스레드가 작업 처리를 마치면 다시 유휴 스레드 풀로 돌아가 새로운 작업을 처리할 준비를 합니다. 스레드 풀을 사용하면 연결을 동시에 처리할 수 있어 서버의 처리량을 높일 수 있습니다.</p>
<p>DoS 공격으로부터 서버를 보호하기 위해 풀의 스레드 개수를 적은 수로 제한할 것입니다. 요청이 들어올 때마다 프로그램이 새로운 스레드를 생성하게 한다면, 누군가 우리 서버에 천만 개의 요청을 보냈을 때 서버의 모든 리소스를 소모하여 요청 처리가 중단되는 대혼란을 야기할 수 있기 때문입니다.</p>
<p>제한 없이 스레드를 생성하는 대신, 풀에서 대기하는 스레드의 개수를 고정할 것입니다. 들어오는 요청들은 처리를 위해 풀로 보내집니다. 풀은 들어오는 요청들의 큐(queue)를 유지 관리합니다. 풀의 각 스레드는 이 큐에서 요청을 하나씩 꺼내어 처리한 다음, 다시 큐에 다음 요청을 요청합니다. 이 설계를 통해 우리는 스레드 개수인 _<code>N</code>_개까지의 요청을 동시에 처리할 수 있습니다. 만약 각 스레드가 오래 걸리는 요청에 응답하고 있다면 후속 요청들이 여전히 큐에서 밀릴 수 있겠지만, 그 지점에 도달하기 전까지 우리가 처리할 수 있는 오래 걸리는 요청의 개수를 늘린 셈입니다.</p>
<p>이 기술은 웹 서버의 처리량을 향상시키는 여러 방법 중 하나일 뿐입니다. 여러분이 탐구해 볼 수 있는 다른 옵션으로는 fork/join 모델, 단일 스레드 비동기 I/O 모델, 그리고 멀티 스레드 비동기 I/O 모델 등이 있습니다. 이 주제에 관심이 있다면 다른 솔루션들에 대해 더 읽어보고 직접 구현해 보세요. 러스트와 같은 저수준 언어를 사용하면 이러한 모든 옵션이 가능합니다.</p>
<p>스레드 풀 구현을 시작하기 전에, 풀을 사용하는 모습이 어떠해야 하는지 이야기해 봅시다. 코드를 설계할 때 클라이언트 인터페이스를 먼저 작성하는 것이 설계의 방향을 잡는 데 도움이 될 수 있습니다. 호출하고 싶은 방식대로 코드의 API 구조를 먼저 잡으세요. 그런 다음 기능을 먼저 구현하고 나중에 공개 API를 설계하는 대신, 그 구조 안에서 기능을 구현하세요.</p>
<p>12장의 프로젝트에서 테스트 주도 개발(TDD)을 사용했던 것과 유사하게, 여기서는 컴파일러 주도 개발을 사용할 것입니다. 우리가 원하는 함수를 호출하는 코드를 먼저 작성하고, 컴파일러가 내뱉는 에러를 보면서 코드가 작동하게 하기 위해 다음에 무엇을 변경해야 할지 결정할 것입니다. 하지만 그전에, 시작점으로 사용하지 <em>않을</em> 기술에 대해 먼저 살펴보겠습니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="code-structure-if-we-could-spawn-a-thread-for-each-request"></a></p>
<h4 id="각-요청에-대해-스레드-생성하기"><a class="header" href="#각-요청에-대해-스레드-생성하기">각 요청에 대해 스레드 생성하기</a></h4>
<p>먼저, 모든 연결에 대해 새로운 스레드를 생성한다면 코드가 어떻게 보일지 살펴보겠습니다. 앞서 언급했듯이, 제한 없이 스레드를 생성할 수 있다는 문제점 때문에 이것이 우리의 최종 계획은 아닙니다. 하지만 작동하는 멀티스레드 서버를 먼저 만들기 위한 시작점으로는 적합합니다. 그런 다음 개선 사항으로 스레드 풀을 추가하면 두 솔루션을 대조하기가 더 쉬울 것입니다. 예제 21-11은 <code>for</code> 루프 내에서 각 스트림을 처리하기 위해 새로운 스레드를 생성하도록 <code>main</code>을 수정한 내용을 보여줍니다.</p>
<Listing number="21-11" file-name="src/main.rs" caption="Spawning a new thread for each stream">
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
</span><span class="boring">        "GET /sleep HTTP/1.1" =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            ("HTTP/1.1 200 OK", "hello.html")
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>16장에서 배웠듯이, <code>thread::spawn</code>은 새로운 스레드를 생성하고 클로저 안의 코드를 실행합니다. 이 코드를 실행하고 브라우저에서 _/sleep_을 로드한 다음, 두 개의 다른 탭에서 _/_를 로드해 보세요. 실제로 _/_에 대한 요청들이 _/sleep_이 끝나기를 기다릴 필요가 없음을 확인할 수 있을 것입니다. 하지만 앞서 언급했듯이, 제한 없이 새로운 스레드를 계속 만들게 되면 결국 시스템에 과부하를 주게 될 것입니다.</p>
<p>또한 17장에서 배웠던 것처럼, 이러한 상황이 바로 async와 await가 진정으로 빛을 발하는 지점입니다! 스레드 풀을 구축하면서 async를 사용했을 때와 무엇이 다르고 무엇이 같을지 생각하며 이 점을 염두에 두세요.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="creating-a-similar-interface-for-a-finite-number-of-threads"></a></p>
<h4 id="유한한-개수의-스레드-생성하기"><a class="header" href="#유한한-개수의-스레드-생성하기">유한한 개수의 스레드 생성하기</a></h4>
<p>우리는 우리 API를 사용하는 코드에 큰 변화를 주지 않고도 스레드 방식에서 스레드 풀 방식으로 전환할 수 있도록, 스레드 풀이 유사하고 친숙한 방식으로 작동하기를 원합니다. 예제 21-12는 <code>thread::spawn</code> 대신 사용하고 싶은 <code>ThreadPool</code> 구조체의 가상 인터페이스를 보여줍니다.</p>
<Listing number="21-12" file-name="src/main.rs" caption="Our ideal `ThreadPool` interface">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
</span><span class="boring">        "GET /sleep HTTP/1.1" =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            ("HTTP/1.1 200 OK", "hello.html")
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre>
</Listing>
<p>우리는 <code>ThreadPool::new</code>를 사용하여 설정 가능한 개수(여기서는 4개)의 스레드를 가진 새로운 스레드 풀을 생성합니다. 그런 다음 <code>for</code> 루프 내에서 <code>pool.execute</code>는 <code>thread::spawn</code>과 유사한 인터페이스를 가지며, 각 스트림에 대해 풀이 실행해야 할 클로저를 인수로 받습니다. 우리는 <code>pool.execute</code>가 클로저를 받아 풀에 있는 스레드에게 전달하여 실행하도록 구현해야 합니다. 이 코드는 아직 컴파일되지 않지만, 컴파일러가 해결 방법을 알려줄 수 있도록 시도해 보겠습니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="building-the-threadpool-struct-using-compiler-driven-development"></a></p>
<h4 id="컴파일러-주도-개발로-threadpool-구축하기"><a class="header" href="#컴파일러-주도-개발로-threadpool-구축하기">컴파일러 주도 개발로 <code>ThreadPool</code> 구축하기</a></h4>
<p>예제 21-12의 변경 사항을 _src/main.rs_에 적용한 다음, <code>cargo check</code>에서 발생하는 컴파일러 에러를 이용해 개발을 진행해 봅시다. 우리가 받게 될 첫 번째 에러는 다음과 같습니다.</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0433]: failed to resolve: use of undeclared type `ThreadPool`
  --&gt; src/main.rs:11:16
   |
11 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^ use of undeclared type `ThreadPool`

For more information about this error, try `rustc --explain E0433`.
error: could not compile `hello` (bin "hello") due to 1 previous error
</code></pre>
<p>좋습니다! 이 에러는 <code>ThreadPool</code> 타입이나 모듈이 필요하다는 것을 알려주므로, 이제 그것을 만들겠습니다. 우리의 <code>ThreadPool</code> 구현은 웹 서버가 하는 작업의 종류와는 독립적일 것입니다. 따라서 <code>hello</code> 크레이트를 바이너리 크레이트에서 <code>ThreadPool</code> 구현을 담을 라이브러리 크레이트로 전환해 봅시다. 라이브러리 크레이트로 변경한 후에는, 웹 요청을 처리하는 것뿐만 아니라 스레드 풀을 사용하는 모든 작업에 이 별도의 스레드 풀 라이브러리를 사용할 수 있게 됩니다.</p>
<p>현재로서 가질 수 있는 가장 단순한 형태의 <code>ThreadPool</code> 구조체 정의를 포함하는 <em>src/lib.rs</em> 파일을 생성하세요.</p>
<Listing file-name="src/lib.rs">
<pre><code class="language-rust noplayground">pub struct ThreadPool;</code></pre>
</Listing>
<p>그런 다음 <em>src/main.rs</em> 상단에 다음 코드를 추가하여 라이브러리 크레이트로부터 <code>ThreadPool</code>을 스코프로 가져오도록 수정하세요.</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore">use hello::ThreadPool;
<span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">    let pool = ThreadPool::new(4);
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        pool.execute(|| {
</span><span class="boring">            handle_connection(stream);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
</span><span class="boring">        "GET /sleep HTTP/1.1" =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            ("HTTP/1.1 200 OK", "hello.html")
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre>
</Listing>
<p>이 코드는 여전히 작동하지 않지만, 우리가 해결해야 할 다음 에러를 확인하기 위해 다시 체크해 봅시다.</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no function or associated item named `new` found for struct `ThreadPool` in the current scope
  --&gt; src/main.rs:12:28
   |
12 |     let pool = ThreadPool::new(4);
   |                            ^^^ function or associated item not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` (bin "hello") due to 1 previous error
</code></pre>
<p>이 에러는 다음으로 <code>ThreadPool</code>에 대한 <code>new</code>라는 이름의 연관 함수를 만들어야 함을 나타냅니다. 또한 <code>new</code>는 <code>4</code>를 인수로 받을 수 있는 하나의 파라미터를 가져야 하고 <code>ThreadPool</code> 인스턴스를 반환해야 한다는 것도 알고 있습니다. 이러한 특성을 가진 가장 단순한 <code>new</code> 함수를 구현해 봅시다.</p>
<Listing file-name="src/lib.rs">
<pre><code class="language-rust noplayground">pub struct ThreadPool;

impl ThreadPool {
    pub fn new(size: usize) -&gt; ThreadPool {
        ThreadPool
    }
}</code></pre>
</Listing>
<p>스레드 개수가 음수가 되는 것은 말이 되지 않으므로 <code>size</code> 파라미터의 타입으로 <code>usize</code>를 선택했습니다. 또한 3장의 <a href="ch03-02-data-types.html#integer-types">“정수 타입”</a><!-- ignore -->에서 논의한 것처럼, 이 <code>4</code>를 스레드 컬렉션의 요소 개수로 사용할 것이기 때문에 <code>usize</code> 타입이 적합합니다.</p>
<p>코드를 다시 체크해 봅시다.</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `execute` found for struct `ThreadPool` in the current scope
  --&gt; src/main.rs:17:14
   |
17 |         pool.execute(|| {
   |         -----^^^^^^^ method not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` (bin "hello") due to 1 previous error
</code></pre>
<p>이제 에러가 발생하는 이유는 <code>ThreadPool</code>에 <code>execute</code> 메서드가 없기 때문입니다. <a href="ch21-02-multithreaded.html#creating-a-finite-number-of-threads">“유한한 개수의 스레드 생성하기”</a><!-- ignore --> 섹션에서 우리 스레드 풀이 <code>thread::spawn</code>과 유사한 인터페이스를 가져야 한다고 결정했던 것을 상기해 보세요. 추가적으로, 우리는 <code>execute</code> 함수가 받은 클로저를 풀에 있는 유휴 스레드에게 전달하여 실행하도록 구현할 것입니다.</p>
<p><code>ThreadPool</code>에 클로저를 파라미터로 받는 <code>execute</code> 메서드를 정의하겠습니다. 13장의 <a href="ch13-01-closures.html#moving-captured-values-out-of-the-closure-and-the-fn-traits">“클로저 밖으로 캡처한 값 이동하기와 <code>Fn</code> 트레이트”</a><!-- ignore --> 섹션에서 세 가지 다른 트레이트(<code>Fn</code>, <code>FnMut</code>, <code>FnOnce</code>)를 통해 클로저를 파라미터로 받을 수 있음을 배웠던 것을 상기해 보세요. 여기서는 어떤 종류의 클로저를 사용할지 결정해야 합니다. 우리는 결국 표준 라이브러리의 <code>thread::spawn</code> 구현과 유사한 작업을 하게 될 것이므로, <code>thread::spawn</code> 시그니처가 파라미터에 어떤 바운드를 가지고 있는지 살펴볼 수 있습니다. 문서는 다음과 같이 보여줍니다.</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static,</code></pre>
<p>여기서 우리가 관심을 갖는 것은 <code>F</code> 타입 파라미터입니다. <code>T</code> 타입 파라미터는 반환값과 관련된 것이며 여기서는 고려하지 않습니다. <code>spawn</code>이 <code>F</code>에 대한 트레이트 바운드로 <code>FnOnce</code>를 사용함을 알 수 있습니다. 우리가 <code>execute</code>에서 받은 인수를 결국 <code>spawn</code>으로 전달할 것이기 때문에, 이것이 우리가 원하는 것일 가능성이 큽니다. 또한 요청을 실행하기 위한 스레드는 해당 요청의 클로저를 단 한 번만 실행할 것이기 때문에, <code>FnOnce</code>의 <code>Once</code>와 의미상 일치한다는 점에서도 <code>FnOnce</code>가 적합함을 확신할 수 있습니다.</p>
<p><code>F</code> 타입 파라미터는 또한 <code>Send</code> 트레이트 바운드와 <code>'static</code> 라이프타임 바운드를 가지고 있는데, 이는 우리 상황에서도 유용합니다. 클로저를 한 스레드에서 다른 스레드로 전송하려면 <code>Send</code>가 필요하고, 스레드가 실행되는 데 얼마나 걸릴지 알 수 없으므로 <code>'static</code>이 필요합니다. 이러한 바운드를 가진 제네릭 파라미터 <code>F</code>를 받는 <code>ThreadPool</code>의 <code>execute</code> 메서드를 만들어 봅시다.</p>
<Listing file-name="src/lib.rs">
<pre><code class="language-rust noplayground"><span class="boring">pub struct ThreadPool;
</span><span class="boring">
</span>impl ThreadPool {
    // --생략--
<span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        ThreadPool
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
    }
}</code></pre>
</Listing>
<p><code>FnOnce</code> 뒤에 여전히 <code>()</code>를 사용하는데, 이는 이 <code>FnOnce</code>가 파라미터가 없고 유닛 타입 <code>()</code>을 반환하는 클로저를 나타내기 때문입니다. 함수 정의와 마찬가지로 반환 타입은 시그니처에서 생략될 수 있지만, 파라미터가 없더라도 괄호는 필요합니다.</p>
<p>다시 말하지만, 이는 <code>execute</code> 메서드의 가장 단순한 구현입니다. 아무 일도 하지 않지만, 우리는 단지 코드를 컴파일하려는 것입니다. 다시 체크해 봅시다.</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.24s
</code></pre>
<p>컴파일이 됩니다! 하지만 <code>cargo run</code>을 실행하고 브라우저에서 요청을 보내면, 이 장의 시작 부분에서 보았던 것과 같은 에러가 브라우저에 나타날 것입니다. 우리 라이브러리가 아직 <code>execute</code>에 전달된 클로저를 실제로 호출하고 있지 않기 때문입니다!</p>
<blockquote>
<p>참고: 하스켈이나 러스트처럼 엄격한 컴파일러를 가진 언어에 대해 “코드가 컴파일되면 작동한다”는 말을 들어보셨을 수도 있습니다. 하지만 이 말이 항상 진실인 것은 아닙니다. 우리 프로젝트는 컴파일되지만 아무 일도 하지 않습니다! 만약 우리가 실제의 완전한 프로젝트를 구축하고 있다면, 지금이 코드가 컴파일되는지뿐만 아니라 우리가 원하는 대로 동작하는지 확인하기 위해 유닛 테스트를 작성하기 시작할 좋은 시간일 것입니다.</p>
</blockquote>
<p>생각해 보세요. 만약 우리가 클로저 대신 _퓨처(future)_를 실행하려고 한다면 여기에서 무엇이 달라질까요?</p>
<h4 id="new에서-스레드-개수-검증하기"><a class="header" href="#new에서-스레드-개수-검증하기"><code>new</code>에서 스레드 개수 검증하기</a></h4>
<p>우리는 아직 <code>new</code>와 <code>execute</code>의 파라미터를 사용하여 아무것도 하고 있지 않습니다. 이 함수들의 본문을 우리가 원하는 동작으로 구현해 봅시다. 먼저 <code>new</code>에 대해 생각해 봅시다. 앞서 우리는 스레드 개수가 음수인 풀은 말이 되지 않기 때문에 <code>size</code> 파라미터에 부호 없는 타입을 선택했습니다. 하지만 스레드가 0개인 풀 또한 말이 되지 않는데, 0은 완전히 유효한 <code>usize</code> 값입니다. 예제 21-13에 표시된 대로 <code>assert!</code> 매크로를 사용하여 <code>size</code>가 0보다 큰지 확인하는 코드를 추가하고, 0을 받으면 프로그램이 패닉을 일으키도록 하겠습니다.</p>
<Listing number="21-13" file-name="src/lib.rs" caption="Implementing `ThreadPool::new` to panic if `size` is zero">
<pre><code class="language-rust noplayground"><span class="boring">pub struct ThreadPool;
</span><span class="boring">
</span>impl ThreadPool {
    /// 새로운 ThreadPool을 생성합니다.
    ///
    /// size는 풀의 스레드 개수입니다.
    ///
    /// # Panics
    ///
    /// `new` 함수는 size가 0일 경우 패닉을 일으킵니다.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        ThreadPool
    }

    // --생략--
<span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}</code></pre>
</Listing>
<p>또한 문서 주석(doc comments)을 사용하여 <code>ThreadPool</code>에 대한 문서도 추가했습니다. 14장에서 논의한 것처럼 우리 함수가 패닉을 일으킬 수 있는 상황을 명시하는 섹션을 추가하여 좋은 문서화 관례를 따랐습니다. <code>cargo doc --open</code>을 실행하고 <code>ThreadPool</code> 구조체를 클릭하여 <code>new</code>에 대해 생성된 문서가 어떻게 보이는지 확인해 보세요!</p>
<p>여기서 한 것처럼 <code>assert!</code> 매크로를 추가하는 대신, 12장의 예제 12-9에서 I/O 프로젝트의 <code>Config::build</code>에서 했던 것처럼 <code>new</code>를 <code>build</code>로 바꾸고 <code>Result</code>를 반환하도록 할 수도 있습니다. 하지만 이번 사례에서는 스레드가 하나도 없는 스레드 풀을 생성하려는 시도를 복구 불가능한 에러로 처리하기로 결정했습니다. 도전해 보고 싶다면, <code>new</code> 함수와 비교해 볼 수 있도록 다음과 같은 시그니처를 가진 <code>build</code> 함수를 작성해 보세요.</p>
<pre><code class="language-rust ignore">pub fn build(size: usize) -&gt; Result&lt;ThreadPool, PoolCreationError&gt; {</code></pre>
<h4 id="스레드를-저장할-공간-만들기"><a class="header" href="#스레드를-저장할-공간-만들기">스레드를 저장할 공간 만들기</a></h4>
<p>이제 풀에 저장할 유효한 스레드 개수를 알 수 있는 방법이 생겼으므로, 구조체를 반환하기 전에 해당 스레드들을 생성하여 <code>ThreadPool</code> 구조체에 저장할 수 있습니다. 그런데 스레드를 어떻게 “저장”할까요? <code>thread::spawn</code> 시그니처를 다시 살펴봅시다.</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static,</code></pre>
<p><code>spawn</code> 함수는 <code>JoinHandle&lt;T&gt;</code>를 반환하는데, 여기서 <code>T</code>는 클로저가 반환하는 타입입니다. 우리도 <code>JoinHandle</code>을 사용하여 어떤 일이 일어나는지 살펴봅시다. 우리 경우에 스레드 풀로 전달하는 클로저들은 연결을 처리하고 아무것도 반환하지 않으므로, <code>T</code>는 유닛 타입 <code>()</code>이 될 것입니다.</p>
<p>예제 21-14의 코드는 컴파일되지만 아직 스레드를 생성하지는 않습니다. 우리는 <code>ThreadPool</code> 정의를 <code>thread::JoinHandle&lt;()&gt;</code> 인스턴스들의 벡터를 갖도록 변경하고, <code>size</code>만큼의 용량으로 벡터를 초기화했으며, 스레드를 생성하는 코드를 실행할 <code>for</code> 루프를 설정하고, 이를 포함하는 <code>ThreadPool</code> 인스턴스를 반환했습니다.</p>
<Listing number="21-14" file-name="src/lib.rs" caption="Creating a vector for `ThreadPool` to hold the threads">
<pre><code class="language-rust ignore not_desired_behavior">use std::thread;

pub struct ThreadPool {
    threads: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl ThreadPool {
    // --생략--
<span class="boring">    /// 새로운 ThreadPool을 생성합니다.
</span><span class="boring">    ///
</span><span class="boring">    /// size는 풀의 스레드 개수입니다.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// `new` 함수는 size가 0일 경우 패닉을 일으킵니다.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut threads = Vec::with_capacity(size);

        for _ in 0..size {
            // 스레드들을 생성하고 벡터에 저장합니다.
        }

        ThreadPool { threads }
    }
    // --생략--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}</code></pre>
</Listing>
<p><code>ThreadPool</code> 내 벡터의 아이템 타입으로 <code>thread::JoinHandle</code>을 사용하고 있으므로, 라이브러리 크레이트에서 <code>std::thread</code>를 스코프로 가져왔습니다.</p>
<p>유효한 크기를 받으면, <code>ThreadPool</code>은 <code>size</code>개의 아이템을 담을 수 있는 새로운 벡터를 생성합니다. <code>with_capacity</code> 함수는 <code>Vec::new</code>와 동일한 작업을 수행하지만 한 가지 중요한 차이점이 있습니다. 바로 벡터에 공간을 미리 할당한다는 점입니다. 우리는 벡터에 <code>size</code>개의 요소를 저장해야 한다는 것을 알고 있으므로, 요소가 삽입될 때마다 크기를 조정하는 <code>Vec::new</code>를 사용하는 것보다 미리 할당하는 것이 약간 더 효율적입니다.</p>
<p><code>cargo check</code>를 다시 실행하면 성공할 것입니다.</p>
<h4 id="threadpool에서-스레드로-코드를-보내는-책임을-갖는-worker-구조체"><a class="header" href="#threadpool에서-스레드로-코드를-보내는-책임을-갖는-worker-구조체"><code>ThreadPool</code>에서 스레드로 코드를 보내는 책임을 갖는 <code>Worker</code> 구조체</a></h4>
<p>예제 21-14의 <code>for</code> 루프에 스레드 생성에 관한 주석을 남겨두었습니다. 여기서는 실제로 스레드를 어떻게 생성하는지 살펴보겠습니다. 표준 라이브러리는 스레드를 생성하는 방법으로 <code>thread::spawn</code>을 제공하며, <code>thread::spawn</code>은 스레드가 생성되자마자 실행할 코드를 인수로 기대합니다. 하지만 우리의 경우, 스레드를 먼저 생성해 두고 나중에 보낼 코드를 <em>기다리게</em> 하고 싶습니다. 표준 라이브러리의 스레드 구현에는 이를 수행할 수 있는 방법이 포함되어 있지 않으므로, 우리가 직접 구현해야 합니다.</p>
<p>우리는 <code>ThreadPool</code>과 스레드 사이에 이 새로운 동작을 관리할 새로운 데이터 구조를 도입하여 이를 구현할 것입니다. 이 데이터 구조를 _워커(Worker)_라고 부르겠으며, 이는 풀링(pooling) 구현에서 흔히 사용되는 용어입니다. <code>Worker</code>는 실행되어야 할 코드를 가져와 자신의 스레드에서 해당 코드를 실행합니다.</p>
<p>식당 주방에서 일하는 사람들을 생각해 보세요. 워커들은 고객으로부터 주문이 들어올 때까지 기다렸다가, 주문을 받아서 처리하는 책임을 집니다.</p>
<p>스레드 풀에 <code>JoinHandle&lt;()&gt;</code> 인스턴스들의 벡터를 저장하는 대신, <code>Worker</code> 구조체의 인스턴스들을 저장할 것입니다. 각 <code>Worker</code>는 단일 <code>JoinHandle&lt;()&gt;</code> 인스턴스를 저장합니다. 그런 다음 <code>Worker</code>에 실행할 코드 클로저를 받아서 이미 실행 중인 스레드로 보내 실행하게 하는 메서드를 구현할 것입니다. 또한 로깅이나 디버깅 시 풀 내의 서로 다른 <code>Worker</code> 인스턴스들을 구분할 수 있도록 각 <code>Worker</code>에게 <code>id</code>를 부여하겠습니다.</p>
<p><code>ThreadPool</code>을 생성할 때 일어날 새로운 프로세스는 다음과 같습니다. <code>Worker</code>를 이런 방식으로 설정한 후에 클로저를 스레드로 보내는 코드를 구현할 것입니다.</p>
<ol>
<li><code>id</code>와 <code>JoinHandle&lt;()&gt;</code>을 갖는 <code>Worker</code> 구조체를 정의합니다.</li>
<li><code>ThreadPool</code>이 <code>Worker</code> 인스턴스들의 벡터를 갖도록 변경합니다.</li>
<li><code>id</code> 번호를 받아서 해당 <code>id</code>와 빈 클로저로 생성된 스레드를 갖는 <code>Worker</code> 인스턴스를 반환하는 <code>Worker::new</code> 함수를 정의합니다.</li>
<li><code>ThreadPool::new</code> 내에서 <code>for</code> 루프 카운터를 사용하여 <code>id</code>를 생성하고, 해당 <code>id</code>로 새로운 <code>Worker</code>를 생성한 뒤 이를 벡터에 저장합니다.</li>
</ol>
<p>도전해 보고 싶다면, 예제 21-15의 코드를 보기 전에 직접 이 변경 사항들을 구현해 보세요.</p>
<p>준비되셨나요? 예제 21-15는 앞서 설명한 수정을 수행하는 한 가지 방법을 보여줍니다.</p>
<Listing number="21-15" file-name="src/lib.rs" caption="Modifying `ThreadPool` to hold `Worker` instances instead of holding threads directly">
<pre><code class="language-rust noplayground">use std::thread;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
}

impl ThreadPool {
    // --생략--
<span class="boring">    /// 새로운 ThreadPool을 생성합니다.
</span><span class="boring">    ///
</span><span class="boring">    /// size는 풀의 스레드 개수입니다.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// `new` 함수는 size가 0일 경우 패닉을 일으킵니다.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers }
    }
    // --생략--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

struct Worker {
    id: usize,
    thread: thread::JoinHandle&lt;()&gt;,
}

impl Worker {
    fn new(id: usize) -&gt; Worker {
        let thread = thread::spawn(|| {});

        Worker { id, thread }
    }
}</code></pre>
</Listing>
<p>이제 <code>ThreadPool</code>이 <code>JoinHandle&lt;()&gt;</code> 인스턴스 대신 <code>Worker</code> 인스턴스들을 갖게 되었으므로 필드 이름을 <code>threads</code>에서 <code>workers</code>로 변경했습니다. <code>for</code> 루프의 카운터를 <code>Worker::new</code> 함수의 인수로 사용하고, 새로 생성된 각 <code>Worker</code>를 <code>workers</code>라는 이름의 벡터에 저장합니다.</p>
<p>외부 코드( _src/main.rs_에 있는 서버 등)는 <code>ThreadPool</code> 내부에서 <code>Worker</code> 구조체를 사용한다는 구현 세부 사항을 알 필요가 없으므로, <code>Worker</code> 구조체와 그 <code>new</code> 함수를 비공개(private)로 만듭니다. <code>Worker::new</code> 함수는 제공받은 <code>id</code>를 사용하며, 빈 클로저를 사용하여 새로운 스레드를 생성함으로써 만들어진 <code>JoinHandle&lt;()&gt;</code> 인스턴스를 저장합니다.</p>
<blockquote>
<p>참고: 시스템 리소스가 부족하여 운영 체제가 스레드를 생성할 수 없는 경우, <code>thread::spawn</code>은 패닉을 일으킵니다. 이는 비록 일부 스레드 생성에 성공했더라도 서버 전체를 패닉 상태로 빠뜨릴 것입니다. 단순함을 위해 이 동작을 그대로 두지만, 실제 프로덕션용 스레드 풀 구현에서는 대신 <code>Result</code>를 반환하는 <a href="../std/thread/struct.Builder.html"><code>std::thread::Builder</code></a>와 그 <a href="../std/thread/struct.Builder.html#method.spawn"><code>spawn</code></a> 메서드를 사용하고 싶을 것입니다.</p>
</blockquote>
<p>이 코드는 컴파일되며 <code>ThreadPool::new</code>에 인수로 전달한 개수만큼의 <code>Worker</code> 인스턴스들을 저장할 것입니다. 하지만 우리는 <em>여전히</em> <code>execute</code>에서 받은 클로저를 처리하지 않고 있습니다. 다음으로 그 방법을 살펴보겠습니다.</p>
<h4 id="채널을-통해-스레드에-요청-보내기"><a class="header" href="#채널을-통해-스레드에-요청-보내기">채널을 통해 스레드에 요청 보내기</a></h4>
<p>다음에 해결할 문제는 <code>thread::spawn</code>에 전달된 클로저들이 아무런 일도 하지 않는다는 점입니다. 현재 우리는 실행하고 싶은 클로저를 <code>execute</code> 메서드에서 받고 있습니다. 하지만 우리는 <code>ThreadPool</code>을 생성하는 동안 각 <code>Worker</code>를 만들 때 <code>thread::spawn</code>에 실행할 클로저를 주어야 합니다.</p>
<p>우리는 방금 생성한 <code>Worker</code> 구조체들이 <code>ThreadPool</code>이 보유한 큐에서 실행할 코드를 가져와서, 해당 코드를 자신의 스레드로 보내 실행하도록 하고 싶습니다.</p>
<p>16장에서 배웠던 채널(두 스레드 간에 통신하는 간단한 방법)이 이 사용 사례에 완벽할 것입니다. 채널을 작업 큐로 사용할 것이며, <code>execute</code>는 <code>ThreadPool</code>에서 <code>Worker</code> 인스턴스들로 작업을 보내고, 워커는 그 작업을 자신의 스레드로 보낼 것입니다. 계획은 다음과 같습니다.</p>
<ol>
<li><code>ThreadPool</code>은 채널을 생성하고 송신자(sender)를 보관합니다.</li>
<li>각 <code>Worker</code>는 수신자(receiver)를 보관합니다.</li>
<li>채널을 통해 보내고 싶은 클로저들을 담을 새로운 <code>Job</code> 구조체를 만들 것입니다.</li>
<li><code>execute</code> 메서드는 실행하고자 하는 작업을 송신자를 통해 보낼 것입니다.</li>
<li>워커는 자신의 스레드에서 수신자를 반복적으로 확인하며 수신된 모든 작업의 클로저를 실행할 것입니다.</li>
</ol>
<p>먼저 예제 21-16에 표시된 대로 <code>ThreadPool::new</code>에서 채널을 생성하고 <code>ThreadPool</code> 인스턴스에 송신자를 보관하는 것부터 시작하겠습니다. <code>Job</code> 구조체는 현재로서는 아무것도 가지고 있지 않지만, 채널을 통해 보낼 아이템의 타입이 될 것입니다.</p>
<Listing number="21-16" file-name="src/lib.rs" caption="Modifying `ThreadPool` to store the sender of a channel that transmits `Job` instances">
<pre><code class="language-rust noplayground">use std::{sync::mpsc, thread};

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Job&gt;,
}

struct Job;

impl ThreadPool {
    // --생략--
<span class="boring">    /// 새로운 ThreadPool을 생성합니다.
</span><span class="boring">    ///
</span><span class="boring">    /// size는 풀의 스레드 개수입니다.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// `new` 함수는 size가 0일 경우 패닉을 일으킵니다.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers, sender }
    }
    // --생략--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(|| {});
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p><code>ThreadPool::new</code>에서 새로운 채널을 생성하고 풀이 송신자를 보관하게 합니다. 이는 성공적으로 컴파일될 것입니다.</p>
<p>스레드 풀이 채널을 생성할 때 각 <code>Worker</code>에게 채널의 수신자를 전달해 봅시다. 우리는 <code>Worker</code> 인스턴스가 생성하는 스레드 내에서 수신자를 사용하고 싶으므로, 클로저 내에서 <code>receiver</code> 파라미터를 참조할 것입니다. 예제 21-17의 코드는 아직 컴파일되지 않을 것입니다.</p>
<Listing number="21-17" file-name="src/lib.rs" caption="Passing the receiver to each `Worker`">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{sync::mpsc, thread};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Job;
</span><span class="boring">
</span>impl ThreadPool {
    // --생략--
<span class="boring">    /// 새로운 ThreadPool을 생성합니다.
</span><span class="boring">    ///
</span><span class="boring">    /// size는 풀의 스레드 개수입니다.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// `new` 함수는 size가 0일 경우 패닉을 일으킵니다.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver));
        }

        ThreadPool { workers, sender }
    }
    // --생략--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// --생략--

<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
        let thread = thread::spawn(|| {
            receiver;
        });

        Worker { id, thread }
    }
}</code></pre>
</Listing>
<p>우리는 몇 가지 작고 간단한 변경을 했습니다. 수신자를 <code>Worker::new</code>로 전달하고, 클로저 내부에서 이를 사용하도록 했습니다.</p>
<p>이 코드를 체크하려고 하면 다음과 같은 에러가 발생합니다.</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0382]: use of moved value: `receiver`
  --&gt; src/lib.rs:26:42
   |
21 |         let (sender, receiver) = mpsc::channel();
   |                      -------- move occurs because `receiver` has type `std::sync::mpsc::Receiver&lt;Job&gt;`, which does not implement the `Copy` trait
...
25 |         for id in 0..size {
   |         ----------------- inside of this loop
26 |             workers.push(Worker::new(id, receiver));
   |                                          ^^^^^^^^ value moved here, in previous iteration of loop
   |
note: consider changing this parameter type in method `new` to borrow instead if owning the value isn't necessary
  --&gt; src/lib.rs:47:33
   |
47 |     fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
   |        --- in this method       ^^^^^^^^^^^^^^^^^^^ this parameter takes ownership of the value
help: consider moving the expression out of the loop so it is only moved once
   |
25 ~         let mut value = Worker::new(id, receiver);
26 ~         for id in 0..size {
27 ~             workers.push(value);
   |

For more information about this error, try `rustc --explain E0382`.
error: could not compile `hello` (lib) due to 1 previous error
</code></pre>
<p>코드가 <code>receiver</code>를 여러 <code>Worker</code> 인스턴스에 전달하려고 시도하고 있습니다. 16장에서 배웠던 것처럼 이는 작동하지 않을 것입니다. 러스트가 제공하는 채널 구현은 다중 <em>생성자(producer)</em>, 단일 <em>소비자(consumer)</em> 방식이기 때문입니다. 즉, 이 코드를 수정하기 위해 채널의 소비 단을 단순히 복제(clone)할 수는 없습니다. 또한 우리는 하나의 메시지를 여러 소비자에게 여러 번 보내고 싶은 것이 아니라, 하나의 메시지 목록을 여러 <code>Worker</code> 인스턴스가 공유하여 각 메시지가 단 한 번만 처리되기를 원합니다.</p>
<p>또한 채널 큐에서 작업을 꺼내는 일은 <code>receiver</code>를 수정하는 과정을 포함하므로, 스레드들이 <code>receiver</code>를 안전하게 공유하고 수정할 수 있는 방법이 필요합니다. 그렇지 않으면 (16장에서 다룬 것처럼) 레이스 컨디션이 발생할 수 있습니다.</p>
<p>16장에서 논의한 스레드 안전한 스마트 포인터를 떠올려 보세요. 여러 스레드 간에 소유권을 공유하고 스레드가 값을 수정할 수 있도록 하려면 <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>를 사용해야 합니다. <code>Arc</code> 타입은 여러 <code>Worker</code> 인스턴스가 수신자를 소유할 수 있게 해주고, <code>Mutex</code>는 한 번에 하나의 <code>Worker</code>만이 수신자로부터 작업을 가져오도록 보장합니다. 예제 21-18은 우리가 적용해야 할 변경 사항을 보여줍니다.</p>
<Listing number="21-18" file-name="src/lib.rs" caption="Sharing the receiver among the `Worker` instances using `Arc` and `Mutex`">
<pre><code class="language-rust noplayground">use std::{
    sync::{mpsc, Arc, Mutex},
    thread,
};
// --생략--

<span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Job;
</span><span class="boring">
</span>impl ThreadPool {
    // --생략--
<span class="boring">    /// 새로운 ThreadPool을 생성합니다.
</span><span class="boring">    ///
</span><span class="boring">    /// size는 풀의 스레드 개수입니다.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// `new` 함수는 size가 0일 경우 패닉을 일으킵니다.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool { workers, sender }
    }

    // --생략--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// --생략--

<span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --생략--
<span class="boring">        let thread = thread::spawn(|| {
</span><span class="boring">            receiver;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span>    }
}</code></pre>
</Listing>
<p><code>ThreadPool::new</code>에서 수신자를 <code>Arc</code>와 <code>Mutex</code>로 감쌉니다. 새로운 <code>Worker</code>를 생성할 때마다 <code>Arc</code>를 클론하여 참조 카운트를 증가시킴으로써 <code>Worker</code> 인스턴스들이 수신자의 소유권을 공유할 수 있게 합니다.</p>
<p>이러한 변경 사항을 적용하면 코드가 컴파일됩니다! 거의 다 왔습니다!</p>
<h4 id="execute-메서드-구현하기"><a class="header" href="#execute-메서드-구현하기"><code>execute</code> 메서드 구현하기</a></h4>
<p>드디어 <code>ThreadPool</code>의 <code>execute</code> 메서드를 구현해 봅시다. 또한 <code>Job</code>을 구조체에서 <code>execute</code>가 받는 클로저 타입을 담는 트레이트 객체의 타입 별칭으로 변경하겠습니다. 20장의 <a href="ch20-03-advanced-types.html#creating-type-synonyms-with-type-aliases">“타입 별칭으로 타입 동의어 만들기”</a><!-- ignore -->에서 논의한 것처럼, 타입 별칭을 사용하면 긴 타입을 짧게 줄여 사용하기 편리하게 만들 수 있습니다. 예제 21-19를 살펴보세요.</p>
<Listing number="21-19" file-name="src/lib.rs" caption="Creating a `Job` type alias for a `Box` that holds each closure and then sending the job down the channel">
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// --생략--

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    // --생략--
<span class="boring">    /// 새로운 ThreadPool을 생성합니다.
</span><span class="boring">    ///
</span><span class="boring">    /// size는 풀의 스레드 개수입니다.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// `new` 함수는 size가 0일 경우 패닉을 일으킵니다.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span>
    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(job).unwrap();
    }
}

// --생략--
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(|| {
</span><span class="boring">            receiver;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p><code>execute</code>에서 받은 클로저를 사용하여 새로운 <code>Job</code> 인스턴스를 생성한 후, 해당 작업을 채널의 송신 단으로 보냅니다. 전송이 실패할 경우를 대비해 <code>send</code>에 대해 <code>unwrap</code>을 호출합니다. 전송 실패는 예를 들어 우리가 모든 스레드의 실행을 중단시켜 수신 단이 새로운 메시지 수신을 멈춘 경우에 발생할 수 있습니다. 현재로서는 스레드 실행을 중단할 수 없으며, 풀이 존재하는 한 스레드는 계속 실행됩니다. 우리가 <code>unwrap</code>을 사용하는 이유는 실패 케이스가 발생하지 않을 것임을 알고 있기 때문이지만, 컴파일러는 이를 알지 못합니다.</p>
<p>하지만 아직 끝난 것이 아닙니다! <code>Worker</code>에서 <code>thread::spawn</code>으로 전달되는 클로저는 여전히 채널의 수신 단을 _참조_만 하고 있습니다. 대신, 우리는 클로저가 무한히 루프를 돌면서 채널의 수신 단에 작업을 요청하고, 작업을 받으면 이를 실행하도록 해야 합니다. 예제 21-20과 같이 <code>Worker::new</code>를 수정해 봅시다.</p>
<Listing number="21-20" file-name="src/lib.rs" caption="Receiving and executing the jobs in the `Worker` instance’s thread">
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// 새로운 ThreadPool을 생성합니다.
</span><span class="boring">    ///
</span><span class="boring">    /// size는 풀의 스레드 개수입니다.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// `new` 함수는 size가 0일 경우 패닉을 일으킵니다.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// --생략--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let job = receiver.lock().unwrap().recv().unwrap();

            println!("워커 {id}가 작업을 받았습니다. 실행합니다.");

            job();
        });

        Worker { id, thread }
    }
}</code></pre>
</Listing>
<p>여기서 우리는 먼저 뮤텍스를 획득하기 위해 <code>receiver</code>에 대해 <code>lock</code>을 호출하고, 에러 발생 시 패닉을 일으키도록 <code>unwrap</code>을 호출합니다. 뮤텍스가 <em>포이즌(poisoned)</em> 상태인 경우 락 획득이 실패할 수 있는데, 이는 다른 스레드가 락을 해제하지 않고 락을 보유한 채로 패닉을 일으켰을 때 발생할 수 있습니다. 이러한 상황에서는 현재 스레드도 패닉을 일으키도록 <code>unwrap</code>을 호출하는 것이 올바른 조치입니다. 원하신다면 이 <code>unwrap</code>을 여러분에게 의미 있는 에러 메시지를 담은 <code>expect</code>로 바꾸셔도 됩니다.</p>
<p>뮤텍스 락을 획득하면 채널로부터 <code>Job</code>을 받기 위해 <code>recv</code>를 호출합니다. 마지막 <code>unwrap</code>은 여기서 발생할 수 있는 에러도 처리하는데, 이는 송신자를 보유한 스레드가 종료되었을 때 발생할 수 있습니다. 이는 수신자가 종료되었을 때 <code>send</code> 메서드가 <code>Err</code>을 반환하는 것과 유사합니다.</p>
<p><code>recv</code> 호출은 블로킹 방식으로 동작하므로, 아직 작업이 없다면 현재 스레드는 작업이 사용 가능해질 때까지 대기합니다. <code>Mutex&lt;T&gt;</code>는 한 번에 하나의 <code>Worker</code> 스레드만이 작업을 요청하도록 보장합니다.</p>
<p>이제 우리 스레드 풀이 작동하는 상태가 되었습니다! <code>cargo run</code>을 실행하고 몇 가지 요청을 보내보세요.</p>
<!-- manual-regeneration
cd listings/ch21-web-server/listing-21-20
cargo run
make some requests to 127.0.0.1:7878
Can't automate because the output depends on making requests
-->
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
warning: field `workers` is never read
 --&gt; src/lib.rs:7:5
  |
6 | pub struct ThreadPool {
  |            ---------- field in this struct
7 |     workers: Vec&lt;Worker&gt;,
  |     ^^^^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: fields `id` and `thread` are never read
  --&gt; src/lib.rs:48:5
   |
47 | struct Worker {
   |        ------ fields in this struct
48 |     id: usize,
   |     ^^
49 |     thread: thread::JoinHandle&lt;()&gt;
   |     ^^^^^^

warning: `hello` (lib) generated 2 warnings
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 4.91s
     Running `target/debug/hello`
워커 0이 작업을 받았습니다. 실행합니다.
워커 2가 작업을 받았습니다. 실행합니다.
워커 1이 작업을 받았습니다. 실행합니다.
워커 3이 작업을 받았습니다. 실행합니다.
워커 0이 작업을 받았습니다. 실행합니다.
워커 2가 작업을 받았습니다. 실행합니다.
워커 1이 작업을 받았습니다. 실행합니다.
워커 3이 작업을 받았습니다. 실행합니다.
워커 0이 작업을 받았습니다. 실행합니다.
워커 2가 작업을 받았습니다. 실행합니다.
</code></pre>
<p>성공입니다! 이제 연결을 비동기적으로 실행하는 스레드 풀을 갖게 되었습니다. 생성되는 스레드는 4개를 넘지 않으므로, 서버가 많은 요청을 받더라도 시스템에 과부하가 걸리지 않을 것입니다. _/sleep_에 대한 요청을 보내더라도, 서버는 다른 스레드를 통해 다른 요청들을 처리할 수 있습니다.</p>
<blockquote>
<p>참고: 만약 여러 브라우저 창에서 동시에 _/sleep_을 열면, 5초 간격으로 하나씩 로드될 수도 있습니다. 일부 웹 브라우저는 캐싱 등의 이유로 동일한 요청의 여러 인스턴스를 순차적으로 실행합니다. 이러한 제한은 우리 웹 서버 때문에 발생하는 것이 아닙니다.</p>
</blockquote>
<p>잠시 멈추고, 수행할 작업에 클로저 대신 퓨처(future)를 사용했다면 예제 21-18, 21-19, 21-20의 코드가 어떻게 달라졌을지 생각해 보기 좋은 시간입니다. 어떤 타입들이 바뀌었을까요? 메서드 시그니처는 어떻게 달라졌을까요(혹은 그대로일까요)? 코드의 어떤 부분들이 그대로 유지되었을까요?</p>
<p>17장과 18장에서 <code>while let</code> 루프에 대해 배우고 난 뒤, 왜 워커 스레드 코드를 예제 21-21과 같이 작성하지 않았는지 궁금해하실 수도 있습니다.</p>
<Listing number="21-21" file-name="src/lib.rs" caption="An alternative implementation of `Worker::new` using `while let`">
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// 새로운 ThreadPool을 생성합니다.
</span><span class="boring">    ///
</span><span class="boring">    /// size는 풀의 스레드 개수입니다.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// `new` 함수는 size가 0일 경우 패닉을 일으킵니다.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span>// --생략--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            while let Ok(job) = receiver.lock().unwrap().recv() {
                println!("워커 {id}가 작업을 받았습니다. 실행합니다.");

                job();
            }
        });

        Worker { id, thread }
    }
}</code></pre>
</Listing>
<p>이 코드는 컴파일되고 실행되지만 우리가 원하는 스레딩 동작을 보여주지는 않습니다. 즉, 느린 요청이 여전히 다른 요청들의 처리를 대기하게 만듭니다. 그 이유는 다소 미묘합니다. <code>Mutex</code> 구조체에는 공개된 <code>unlock</code> 메서드가 없는데, 락(lock)의 소유권은 <code>lock</code> 메서드가 반환하는 <code>LockResult&lt;MutexGuard&lt;T&gt;&gt;</code> 내 <code>MutexGuard&lt;T&gt;</code>의 라이프타임에 기반하기 때문입니다. 이를 통해 컴파일 타임에 대여 검사기는 우리가 락을 보유하고 있지 않는 한 <code>Mutex</code>에 의해 보호되는 리소스에 접근할 수 없다는 규칙을 강제할 수 있습니다. 하지만 이 구현은 <code>MutexGuard&lt;T&gt;</code>의 라이프타임을 주의 깊게 관리하지 않으면 의도했던 것보다 더 오랫동안 락을 보유하게 되는 결과를 초래할 수 있습니다.</p>
<p><code>let job = receiver.lock().unwrap().recv().unwrap();</code>를 사용하는 예제 21-20의 코드가 작동하는 이유는, <code>let</code>을 사용하면 등호 오른편 표현식에서 사용된 모든 임시 값들이 <code>let</code> 문이 끝날 때 즉시 드롭되기 때문입니다. 하지만 <code>while let</code> (그리고 <code>if let</code>과 <code>match</code>)은 연관된 블록이 끝날 때까지 임시 값들을 드롭하지 않습니다. 예제 21-21에서 락은 <code>job()</code> 호출이 진행되는 동안 계속 유지되며, 이는 다른 <code>Worker</code> 인스턴스들이 작업을 받을 수 없음을 의미합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="우아한-종료와-정리"><a class="header" href="#우아한-종료와-정리">우아한 종료와 정리</a></h2>
<p>예제 21-20의 코드는 의도한 대로 스레드 풀을 사용하여 요청에 비동기적으로 응답하고 있습니다. 우리가 직접적으로 사용하지 않는 <code>workers</code>, <code>id</code>, <code>thread</code> 필드에 대한 경고가 발생하는데, 이는 우리가 아직 아무것도 정리하지 않았음을 상기시켜 줍니다. 덜 우아한 방식인 <kbd>ctrl</kbd>-<kbd>c</kbd>를 사용하여 메인 스레드를 중단하면, 다른 모든 스레드들도 요청을 처리하는 도중이더라도 즉시 중단됩니다.</p>
<p>그다음으로, 풀에 있는 각 스레드에 대해 <code>join</code>을 호출하도록 <code>Drop</code> 트레이트를 구현하겠습니다. 이를 통해 각 스레드가 종료되기 전에 처리 중인 요청을 완료할 수 있게 됩니다. 그런 다음 스레드들에게 새로운 요청 수락을 중단하고 종료해야 함을 알리는 방법을 구현할 것입니다. 이 코드가 실제로 작동하는지 확인하기 위해, 서버가 두 개의 요청만 수락한 뒤 스레드 풀을 우아하게 종료하도록 수정하겠습니다.</p>
<p>진행하면서 한 가지 주목할 점은, 이 중 어느 것도 클로저 실행을 처리하는 코드 부분에는 영향을 주지 않는다는 것입니다. 따라서 비동기 런타임을 위해 스레드 풀을 사용하는 경우에도 여기의 모든 내용은 동일하게 적용될 것입니다.</p>
<h3 id="threadpool에-drop-트레이트-구현하기"><a class="header" href="#threadpool에-drop-트레이트-구현하기"><code>ThreadPool</code>에 <code>Drop</code> 트레이트 구현하기</a></h3>
<p>먼저 스레드 풀에 <code>Drop</code>을 구현하는 것부터 시작하겠습니다. 풀이 드롭될 때, 모든 스레드들이 작업을 마칠 수 있도록 <code>join</code>을 호출해야 합니다. 예제 21-22는 <code>Drop</code> 구현의 첫 번째 시도를 보여줍니다. 이 코드는 아직 제대로 작동하지 않을 것입니다.</p>
<Listing number="21-22" file-name="src/lib.rs" caption="Joining each thread when the thread pool goes out of scope">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// 새로운 ThreadPool을 생성합니다.
</span><span class="boring">    ///
</span><span class="boring">    /// size는 풀의 스레드 개수입니다.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// `new` 함수는 size가 0일 경우 패닉을 일으킵니다.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!("워커 {}를 종료합니다", worker.id);

            worker.thread.join().unwrap();
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!("워커 {id}가 작업을 받았습니다. 실행합니다.");
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>먼저, 스레드 풀의 각 <code>workers</code>에 대해 루프를 돕니다. <code>self</code>가 가변 참조자이고 <code>worker</code>를 수정할 수 있어야 하므로 <code>&amp;mut</code>을 사용합니다. 각 워커에 대해 해당 <code>Worker</code> 인스턴스가 종료된다는 메시지를 출력한 다음, 그 <code>Worker</code> 인스턴스의 스레드에 대해 <code>join</code>을 호출합니다. 만약 <code>join</code> 호출이 실패하면, <code>unwrap</code>을 사용하여 러스트가 패닉을 일으키고 우아하지 않은 종료(ungraceful shutdown) 상태가 되도록 합니다.</p>
<p>이 코드를 컴파일할 때 발생하는 에러는 다음과 같습니다.</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0507]: cannot move out of `worker.thread` which is behind a mutable reference
    --&gt; src/lib.rs:52:13
     |
52   |             worker.thread.join().unwrap();
     |             ^^^^^^^^^^^^^ ------ `worker.thread` moved due to this method call
     |             |
     |             move occurs because `worker.thread` has type `JoinHandle&lt;()&gt;`, which does not implement the `Copy` trait
     |
note: `JoinHandle::&lt;T&gt;::join` takes ownership of the receiver `self`, which moves `worker.thread`
    --&gt; file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/std/src/thread/mod.rs:1763:17
     |
1763 |     pub fn join(self) -&gt; Result&lt;T&gt; {
     |                 ^^^^

For more information about this error, try `rustc --explain E0507`.
error: could not compile `hello` (lib) due to 1 previous error
</code></pre>
<p>이 에러는 우리가 각 <code>worker</code>에 대해 가변 대여(mutable borrow)만 가지고 있고 <code>join</code>은 그 인수의 소유권을 가져가기 때문에 <code>join</code>을 호출할 수 없음을 알려줍니다. 이 문제를 해결하려면 <code>join</code>이 스레드를 소비할 수 있도록 <code>thread</code>를 소유하고 있는 <code>Worker</code> 인스턴스 밖으로 스레드를 이동시켜야 합니다. 한 가지 방법은 예제 18-15에서 했던 것과 같은 방식을 취하는 것입니다. 만약 <code>Worker</code>가 <code>Option&lt;thread::JoinHandle&lt;()&gt;&gt;</code>를 들고 있다면, <code>Option</code>에 대해 <code>take</code> 메서드를 호출하여 <code>Some</code> 변형에서 값을 꺼내오고 그 자리에 <code>None</code> 변형을 남겨둘 수 있습니다. 즉, 실행 중인 <code>Worker</code>는 <code>thread</code> 필드에 <code>Some</code> 변형을 가지고 있을 것이고, <code>Worker</code>를 정리하고 싶을 때는 <code>Some</code>을 <code>None</code>으로 교체하여 해당 <code>Worker</code>가 실행할 스레드를 가지지 않도록 만드는 것입니다.</p>
<p>하지만 이 방식은 <code>Worker</code>를 드롭할 때에만 필요한 반면, 그 대가로 <code>worker.thread</code>에 접근하는 모든 곳에서 <code>Option&lt;thread::JoinHandle&lt;()&gt;&gt;</code>를 다뤄야만 합니다. 관용적인 러스트는 <code>Option</code>을 꽤 많이 사용하지만, 이처럼 항상 존재할 것임을 알고 있는 무언가를 임시방편으로 <code>Option</code>으로 감싸고 있다는 것을 알게 된다면, 대안적인 접근 방식을 찾아보는 것이 좋습니다. 대안을 통해 코드를 더 깔끔하고 에러가 적게 만들 수 있습니다.</p>
<p>이 경우에는 더 나은 대안이 존재합니다. 바로 <code>Vec::drain</code> 메서드입니다. 이 메서드는 <code>Vec</code>에서 제거할 아이템들의 범위를 파라미터로 받으며, 해당 아이템들의 반복자를 반환합니다. <code>..</code> 범위 문법을 전달하면 <code>Vec</code>에서 <em>모든</em> 값을 제거합니다.</p>
<p>따라서 <code>ThreadPool</code>의 <code>drop</code> 구현을 다음과 같이 업데이트해야 합니다.</p>
<Listing file-name="src/lib.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// 새로운 ThreadPool을 생성합니다.
</span><span class="boring">    ///
</span><span class="boring">    /// size는 풀의 스레드 개수입니다.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// `new` 함수는 size가 0일 경우 패닉을 일으킵니다.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in self.workers.drain(..) {
            println!("워커 {}를 종료합니다", worker.id);

            worker.thread.join().unwrap();
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!("워커 {id}가 작업을 받았습니다. 실행합니다.");
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>이것으로 컴파일러 에러가 해결되며 우리 코드에 다른 변경 사항은 필요하지 않습니다.</p>
<h3 id="스레드들에게-작업-대기-중단을-신호하기"><a class="header" href="#스레드들에게-작업-대기-중단을-신호하기">스레드들에게 작업 대기 중단을 신호하기</a></h3>
<p>지금까지의 모든 변경 사항을 적용하면 코드는 경고 없이 컴파일됩니다. 하지만 안타깝게도 이 코드는 아직 우리가 원하는 대로 작동하지 않습니다. 핵심은 <code>Worker</code> 인스턴스의 스레드들이 실행하는 클로저 내부의 로직입니다. 현재 우리는 <code>join</code>을 호출하고 있지만, 스레드들은 작업을 찾기 위해 영원히 루프(<code>loop</code>)를 돌고 있기 때문에 종료되지 않을 것입니다. 현재의 <code>drop</code> 구현으로 <code>ThreadPool</code>을 드롭하려고 시도하면, 메인 스레드는 첫 번째 스레드가 끝나기를 기다리며 영원히 블록될 것입니다.</p>
<p>이 문제를 해결하려면 <code>ThreadPool</code>의 <code>drop</code> 구현을 변경하고, 이어서 <code>Worker</code>의 루프를 변경해야 합니다.</p>
<p>먼저 스레드들이 종료되기를 기다리기 전에 <code>sender</code>를 명시적으로 드롭하도록 <code>ThreadPool</code>의 <code>drop</code> 구현을 변경하겠습니다. 예제 21-23은 <code>sender</code>를 명시적으로 드롭하기 위한 <code>ThreadPool</code>의 변경 사항을 보여줍니다. 스레드 때와 마찬가지로, 여기서도 <code>Option::take</code>를 사용하여 <code>sender</code>를 <code>ThreadPool</code> 밖으로 꺼내오기 위해 <code>Option</code>을 사용해야 합니다.</p>
<Listing number="21-23" file-name="src/lib.rs" caption="Explicitly drop `sender` before joining the `Worker` threads">
<pre><code class="language-rust noplayground not_desired_behavior"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span>pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,
}
// --생략--
<span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span>impl ThreadPool {
<span class="boring">    /// 새로운 ThreadPool을 생성합니다.
</span><span class="boring">    ///
</span><span class="boring">    /// size는 풀의 스레드 개수입니다.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// `new` 함수는 size가 0일 경우 패닉을 일으킵니다.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        // --생략--

<span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span>        ThreadPool {
            workers,
            sender: Some(sender),
        }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.as_ref().unwrap().send(job).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        drop(self.sender.take());

        for worker in self.workers.drain(..) {
            println!("워커 {}를 종료합니다", worker.id);

            worker.thread.join().unwrap();
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!("워커 {id}가 작업을 받았습니다. 실행합니다.");
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p><code>sender</code>를 드롭하면 채널이 닫히며, 이는 더 이상의 메시지가 전송되지 않을 것임을 나타냅니다. 그렇게 되면 무한 루프 내에서 <code>Worker</code> 인스턴스들이 수행하는 모든 <code>recv</code> 호출은 에러를 반환할 것입니다. 예제 21-24에서는 그러한 경우에 루프를 우아하게 빠져나오도록 <code>Worker</code> 루프를 수정합니다. 이는 <code>ThreadPool</code>의 <code>drop</code> 구현이 스레드들에 대해 <code>join</code>을 호출할 때 스레드들이 종료될 수 있음을 의미합니다.</p>
<Listing number="21-24" file-name="src/lib.rs" caption="Explicitly breaking out of the loop when `recv` returns an error">
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// 새로운 ThreadPool을 생성합니다.
</span><span class="boring">    ///
</span><span class="boring">    /// size는 풀의 스레드 개수입니다.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// `new` 함수는 size가 0일 경우 패닉을 일으킵니다.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool {
</span><span class="boring">            workers,
</span><span class="boring">            sender: Some(sender),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.as_ref().unwrap().send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for ThreadPool {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        drop(self.sender.take());
</span><span class="boring">
</span><span class="boring">        for worker in self.workers.drain(..) {
</span><span class="boring">            println!("워커 {}를 종료합니다", worker.id);
</span><span class="boring">
</span><span class="boring">            worker.thread.join().unwrap();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv();

            match message {
                Ok(job) =&gt; {
                    println!("워커 {id}가 작업을 받았습니다. 실행합니다.");

                    job();
                }
                Err(_) =&gt; {
                    println!("워커 {id}의 연결이 끊겼습니다. 종료합니다.");
                    break;
                }
            }
        });

        Worker { id, thread }
    }
}</code></pre>
</Listing>
<p>이 코드가 작동하는 모습을 보기 위해, 예제 21-25와 같이 서버가 두 개의 요청만 수락한 후 우아하게 종료되도록 <code>main</code>을 수정하겠습니다.</p>
<Listing number="21-25" file-name="src/main.rs" caption="Shutting down the server after serving two requests by exiting the loop">
<pre><code class="language-rust ignore"><span class="boring">use hello::ThreadPool;
</span><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!("종료합니다.");
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
</span><span class="boring">        "GET /sleep HTTP/1.1" =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            ("HTTP/1.1 200 OK", "hello.html")
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre>
</Listing>
<p>실제 웹 서버가 단 두 개의 요청만 처리하고 종료되는 것을 원하지는 않으실 겁니다. 이 코드는 단지 우아한 종료와 정리가 제대로 작동하는지 보여주기 위한 것입니다.</p>
<p><code>take</code> 메서드는 <code>Iterator</code> 트레이트에 정의되어 있으며 반복을 최대 처음 두 개의 아이템으로 제한합니다. <code>main</code>의 끝에서 <code>ThreadPool</code>이 스코프를 벗어나게 되고, <code>drop</code> 구현이 실행될 것입니다.</p>
<p><code>cargo run</code>으로 서버를 시작하고 세 번의 요청을 보내보세요. 세 번째 요청에서는 에러가 발생해야 하며, 터미널에서는 다음과 유사한 출력을 볼 수 있을 것입니다.</p>
<!-- manual-regeneration
cd listings/ch21-web-server/listing-21-25
cargo run
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
third request will error because server will have shut down
copy output below
Can't automate because the output depends on making requests
-->
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.41s
     Running `target/debug/hello`
워커 0이 작업을 받았습니다. 실행합니다.
종료합니다.
워커 0를 종료합니다
워커 3이 작업을 받았습니다. 실행합니다.
워커 1의 연결이 끊겼습니다. 종료합니다.
워커 2의 연결이 끊겼습니다. 종료합니다.
워커 3의 연결이 끊겼습니다. 종료합니다.
워커 0의 연결이 끊겼습니다. 종료합니다.
워커 1를 종료합니다
워커 2를 종료합니다
워커 3를 종료합니다
</code></pre>
<p>워커 ID와 출력되는 메시지의 순서는 다르게 보일 수 있습니다. 우리는 메시지를 통해 이 코드가 어떻게 작동하는지 알 수 있습니다. 워커 0과 3이 처음 두 개의 요청을 받았습니다. 서버는 두 번째 연결 이후 연결 수락을 중단했고, <code>ThreadPool</code>의 <code>Drop</code> 구현은 워커 3이 작업을 시작하기도 전에 실행되기 시작했습니다. <code>sender</code>를 드롭하면 모든 워커 인스턴스와의 연결이 끊어지고 종료를 지시합니다. 각 워커 인스턴스는 연결이 끊길 때 메시지를 출력하고, 스레드 풀은 각 워커 스레드가 완료될 때까지 기다리기 위해 <code>join</code>을 호출합니다.</p>
<p>이 특정 실행에서 흥미로운 점 하나를 주목해 보세요. <code>ThreadPool</code>이 <code>sender</code>를 드롭했고, 어떤 워커도 에러를 받기 전에 우리가 워커 0에 대해 조인(join)을 시도했습니다. 워커 0은 아직 <code>recv</code>로부터 에러를 받지 못했으므로, 메인 스레드는 워커 0이 끝나기를 기다리며 블록되었습니다. 그동안 워커 3은 작업을 받았고 그 후에 모든 스레드가 에러를 받았습니다. 워커 0이 종료되자 메인 스레드는 나머지 워커 인스턴스들이 종료되기를 기다렸습니다. 그 시점에서 워커들은 모두 루프를 빠져나와 정지된 상태였습니다.</p>
<p>축하합니다! 이제 프로젝트를 완료했습니다. 우리는 스레드 풀을 사용하여 비동기적으로 응답하는 기본적인 웹 서버를 갖게 되었습니다. 또한 서버를 우아하게 종료하고 풀의 모든 스레드를 정리할 수 있게 되었습니다.</p>
<p>참고를 위한 전체 코드는 다음과 같습니다.</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore">use hello::ThreadPool;
use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
    thread,
    time::Duration,
};

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!("종료합니다.");
}

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;stream);
    let request_line = buf_reader.lines().next().unwrap().unwrap();

    let (status_line, filename) = match &amp;request_line[..] {
        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
        "GET /sleep HTTP/1.1" =&gt; {
            thread::sleep(Duration::from_secs(5));
            ("HTTP/1.1 200 OK", "hello.html")
        }
        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
    };

    let contents = fs::read_to_string(filename).unwrap();
    let length = contents.len();

    let response =
        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre>
</Listing>
<Listing file-name="src/lib.rs">
<pre><code class="language-rust noplayground">use std::{
    sync::{mpsc, Arc, Mutex},
    thread,
};

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,
}

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    /// 새로운 ThreadPool을 생성합니다.
    ///
    /// size는 풀의 스레드 개수입니다.
    ///
    /// # Panics
    ///
    /// `new` 함수는 size가 0일 경우 패닉을 일으킵니다.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool {
            workers,
            sender: Some(sender),
        }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.as_ref().unwrap().send(job).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        drop(self.sender.take());

        for worker in &amp;mut self.workers {
            println!("워커 {}를 종료합니다", worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}

struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv();

            match message {
                Ok(job) =&gt; {
                    println!("워커 {id}가 작업을 받았습니다. 실행합니다.");

                    job();
                }
                Err(_) =&gt; {
                    println!("워커 {id}의 연결이 끊겼습니다. 종료합니다.");
                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}</code></pre>
</Listing>
<p>여기서 더 많은 것을 할 수 있습니다! 이 프로젝트를 계속 개선하고 싶다면 다음과 같은 아이디어들이 있습니다.</p>
<ul>
<li><code>ThreadPool</code>과 그 공개 메서드들에 더 많은 문서를 추가해 보세요.</li>
<li>라이브러리의 기능에 대한 테스트를 추가해 보세요.</li>
<li><code>unwrap</code> 호출을 더 견고한 에러 처리 방식으로 변경해 보세요.</li>
<li>웹 요청 처리 외에 다른 작업을 수행하는 데 <code>ThreadPool</code>을 사용해 보세요.</li>
<li><a href="https://crates.io/">crates.io</a>에서 스레드 풀 크레이트를 찾아보고, 대신 그 크레이트를 사용하여 유사한 웹 서버를 구현해 보세요. 그런 다음 해당 크레이트의 API 및 견고함을 우리가 구현한 스레드 풀과 비교해 보세요.</li>
</ul>
<h2 id="요약-20"><a class="header" href="#요약-20">요약</a></h2>
<p>수고하셨습니다! 책의 마지막까지 오셨네요! 러스트로의 이 여정에 함께 해주셔서 감사합니다. 이제 여러분은 자신만의 러스트 프로젝트를 구현하고 다른 사람들의 프로젝트를 도울 준비가 되었습니다. 여러분의 러스트 여정에서 마주하게 될 어떤 도전 과제라도 기꺼이 도와줄 친절한 러스타시안(Rustaceans) 커뮤니티가 있다는 것을 잊지 마세요.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="부록"><a class="header" href="#부록">부록</a></h1>
<p>다음 섹션들은 여러분의 러스트 여정에서 유용하게 참고할 수 있는 자료들을 담고 있습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="부록-a-키워드"><a class="header" href="#부록-a-키워드">부록 A: 키워드</a></h2>
<p>다음 목록은 현재 또는 향후 러스트 언어에서 사용하기 위해 예약된 키워드들을 담고 있습니다. 따라서 이들은 (“<a href="appendix-01-keywords.html#raw-identifiers">원시 식별자</a><!-- ignore -->” 섹션에서 논의할 원시 식별자로 사용하는 경우를 제외하고) 식별자로 사용될 수 없습니다. 식별자란 함수, 변수, 파라미터, 구조체 필드, 모듈, 크레이트, 상수, 매크로, 정적 값, 속성, 타입, 트레이트, 또는 라이프타임의 이름을 말합니다.</p>
<h3 id="현재-사용-중인-키워드"><a class="header" href="#현재-사용-중인-키워드">현재 사용 중인 키워드</a></h3>
<p>다음은 현재 사용 중인 키워드들의 목록과 그 기능에 대한 설명입니다.</p>
<ul>
<li><code>as</code> - 기본 캐스팅을 수행하거나, 아이템을 포함하는 특정 트레이트의 모호성을 해소하거나, <code>use</code> 문에서 아이템의 이름을 바꿉니다.</li>
<li><code>async</code> - 현재 스레드를 차단하는 대신 <code>Future</code>를 반환합니다.</li>
<li><code>await</code> - <code>Future</code>의 결과가 준비될 때까지 실행을 일시 중단합니다.</li>
<li><code>break</code> - 루프를 즉시 빠져나옵니다.</li>
<li><code>const</code> - 상수 아이템이나 상수 원시 포인터를 정의합니다.</li>
<li><code>continue</code> - 루프의 다음 반복으로 넘어갑니다.</li>
<li><code>crate</code> - 모듈 경로에서 크레이트 루트를 참조합니다.</li>
<li><code>dyn</code> - 트레이트 객체로의 동적 디스패치(dynamic dispatch)를 수행합니다.</li>
<li><code>else</code> - <code>if</code> 및 <code>if let</code> 제어 흐름 구조에서 조건이 맞지 않을 때의 처리를 담당합니다.</li>
<li><code>enum</code> - 열거형을 정의합니다.</li>
<li><code>extern</code> - 외부 함수나 변수를 연결합니다.</li>
<li><code>false</code> - 불리언 거짓(false) 리터럴입니다.</li>
<li><code>fn</code> - 함수나 함수 포인터 타입을 정의합니다.</li>
<li><code>for</code> - 반복자의 아이템들에 대해 루프를 돌거나, 트레이트를 구현하거나, 고차 라이프타임(higher-ranked lifetime)을 지정합니다.</li>
<li><code>if</code> - 조건식의 결과에 따라 분기합니다.</li>
<li><code>impl</code> - 고유 기능이나 트레이트 기능을 구현합니다.</li>
<li><code>in</code> - <code>for</code> 루프 문법의 일부입니다.</li>
<li><code>let</code> - 변수를 바인딩합니다.</li>
<li><code>loop</code> - 조건 없이 무한 루프를 돕니다.</li>
<li><code>match</code> - 값을 패턴과 매칭시킵니다.</li>
<li><code>mod</code> - 모듈을 정의합니다.</li>
<li><code>move</code> - 클로저가 캡처한 모든 값의 소유권을 가져오도록 만듭니다.</li>
<li><code>mut</code> - 참조자, 원시 포인터, 또는 패턴 바인딩에서 가변성을 나타냅니다.</li>
<li><code>pub</code> - 구조체 필드, <code>impl</code> 블록, 또는 모듈에서 공개 가시성(visibility)을 나타냅니다.</li>
<li><code>ref</code> - 참조에 의해 바인딩합니다.</li>
<li><code>return</code> - 함수에서 반환</li>
<li><code>Self</code> - 정의하거나 구현하는 타입에 대한 타입 별칭</li>
<li><code>self</code> - 메서드 주체 또는 현재 모듈</li>
<li><code>static</code> - 전역 변수 또는 전체 프로그램 실행 동안 지속되는 라이프타임</li>
<li><code>struct</code> - 구조체 정의</li>
<li><code>super</code> - 현재 모듈의 부모 모듈</li>
<li><code>trait</code> - 트레이트 정의</li>
<li><code>true</code> - 불리언 참 리터럴</li>
<li><code>type</code> - 타입 별칭 또는 연관 타입 정의</li>
<li><code>union</code> - <a href="../reference/items/unions.html">유니온</a><!-- ignore --> 정의; 유니온 선언에서 사용될 때만 키워드입니다</li>
<li><code>unsafe</code> - 안전하지 않은 코드, 함수, 트레이트 또는 구현을 나타냄</li>
<li><code>use</code> - 심볼을 스코프로 가져옴; 제네릭 및 라이프타임 바운드에 대한 정확한 캡처 지정</li>
<li><code>where</code> - 타입을 제약하는 절을 나타냄</li>
<li><code>while</code> - 표현식의 결과에 따라 조건부로 반복</li>
</ul>
<h3 id="향후-사용을-위해-예약된-키워드"><a class="header" href="#향후-사용을-위해-예약된-키워드">향후 사용을 위해 예약된 키워드</a></h3>
<p>다음 키워드들은 아직 기능이 없지만 러스트에서 잠재적인 미래 사용을 위해 예약되어 있습니다.</p>
<ul>
<li><code>abstract</code></li>
<li><code>become</code></li>
<li><code>box</code></li>
<li><code>do</code></li>
<li><code>final</code></li>
<li><code>gen</code></li>
<li><code>macro</code></li>
<li><code>override</code></li>
<li><code>priv</code></li>
<li><code>try</code></li>
<li><code>typeof</code></li>
<li><code>unsized</code></li>
<li><code>virtual</code></li>
<li><code>yield</code></li>
</ul>
<h3 id="원시-식별자"><a class="header" href="#원시-식별자">원시 식별자</a></h3>
<p>_원시 식별자_는 일반적으로 허용되지 않는 곳에 키워드를 사용할 수 있게 해주는 문법입니다. 키워드 앞에 <code>r#</code>를 붙여 원시 식별자를 사용합니다.</p>
<p>예를 들어, <code>match</code>는 키워드입니다. <code>match</code>를 이름으로 사용하는 다음 함수를 컴파일하려고 하면:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}</code></pre>
<p>다음과 같은 오류가 발생합니다:</p>
<pre><code class="language-text">error: expected identifier, found keyword `match`
 --&gt; src/main.rs:4:4
  |
4 | fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
  |    ^^^^^ expected identifier, found keyword
</code></pre>
<p>오류는 <code>match</code> 키워드를 함수 식별자로 사용할 수 없음을 보여줍니다. <code>match</code>를 함수 이름으로 사용하려면 다음과 같이 원시 식별자 구문을 사용해야 합니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn r#match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match("foo", "foobar"));
}</code></pre></pre>
<p>이 코드는 오류 없이 컴파일됩니다. 함수 정의의 함수 이름과 <code>main</code>에서 함수가 호출되는 곳에 <code>r#</code> 접두사가 붙어 있음을 확인하세요.</p>
<p>원시 식별자를 사용하면 예약된 키워드라도 원하는 단어를 식별자로 사용할 수 있습니다. 이는 식별자 이름을 선택하는 데 더 많은 자유를 제공하며, 해당 단어가 키워드가 아닌 언어로 작성된 프로그램과 통합할 수 있게 해줍니다. 또한 원시 식별자를 사용하면 크레이트가 사용하는 Rust 에디션과 다른 에디션으로 작성된 라이브러리를 사용할 수 있습니다. 예를 들어, <code>try</code>는 2015년 에디션에서는 키워드가 아니지만 2018, 2021, 2024년 에디션에서는 키워드입니다. 2015년 에디션을 사용하여 작성되었고 <code>try</code> 함수를 가진 라이브러리에 의존하는 경우, 2018년 에디션 코드에서 해당 함수를 호출하려면 이 경우 <code>r#try</code>와 같은 원시 식별자 구문을 사용해야 합니다. 에디션에 대한 자세한 내용은 <a href="appendix-05-editions.html">부록 E</a><!-- ignore -->를 참조하세요.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="부록-b-연산자와-기호"><a class="header" href="#부록-b-연산자와-기호">부록 B: 연산자와 기호</a></h2>
<p>이 부록에는 연산자 및 경로, 제네릭, 트레이트 바운드, 매크로, 속성, 주석, 튜플, 대괄호 컨텍스트에서 단독으로 또는 함께 나타나는 기타 기호를 포함한 Rust 구문 용어집이 포함되어 있습니다.</p>
<h3 id="연산자"><a class="header" href="#연산자">연산자</a></h3>
<p>표 B-1에는 Rust의 연산자, 컨텍스트에서 연산자가 어떻게 나타나는지에 대한 예시, 간략한 설명, 그리고 해당 연산자가 오버로드 가능한지 여부가 포함되어 있습니다. 연산자가 오버로드 가능하다면, 해당 연산자를 오버로드하는 데 사용할 관련 트레이트가 나열됩니다.</p>
<p><span class="caption">표 B-1: 연산자</span></p>
<div class="table-wrapper"><table><thead><tr><th>연산자</th><th>예시</th><th>설명</th><th>오버로드 가능?</th></tr></thead><tbody>
<tr><td><code>!</code></td><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>매크로 확장</td><td></td></tr>
<tr><td><code>!</code></td><td><code>!expr</code></td><td>비트 단위 또는 논리적 보수</td><td><code>Not</code></td></tr>
<tr><td><code>!=</code></td><td><code>expr != expr</code></td><td>불평등 비교</td><td><code>PartialEq</code></td></tr>
<tr><td><code>%</code></td><td><code>expr % expr</code></td><td>산술 나머지</td><td><code>Rem</code></td></tr>
<tr><td><code>%=</code></td><td><code>var %= expr</code></td><td>산술 나머지 및 할당</td><td><code>RemAssign</code></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;expr</code>, <code>&amp;mut expr</code></td><td>대여</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;type</code>, <code>&amp;mut type</code>, <code>&amp;'a type</code>, <code>&amp;'a mut type</code></td><td>대여된 포인터 타입</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>expr &amp; expr</code></td><td>비트 단위 AND</td><td><code>BitAnd</code></td></tr>
<tr><td><code>&amp;=</code></td><td><code>var &amp;= expr</code></td><td>비트 단위 AND 및 할당</td><td><code>BitAndAssign</code></td></tr>
<tr><td><code>&amp;&amp;</code></td><td><code>expr &amp;&amp; expr</code></td><td>단락 논리 AND</td><td></td></tr>
<tr><td><code>*</code></td><td><code>expr * expr</code></td><td>산술 곱셈</td><td><code>Mul</code></td></tr>
<tr><td><code>*=</code></td><td><code>var *= expr</code></td><td>산술 곱셈 및 할당</td><td><code>MulAssign</code></td></tr>
<tr><td><code>*</code></td><td><code>*expr</code></td><td>역참조</td><td><code>Deref</code></td></tr>
<tr><td><code>*</code></td><td><code>*const type</code>, <code>*mut type</code></td><td>원시 포인터</td><td></td></tr>
<tr><td><code>+</code></td><td><code>trait + trait</code>, <code>'a + trait</code></td><td>복합 타입 제약</td><td></td></tr>
<tr><td><code>+</code></td><td><code>expr + expr</code></td><td>산술 덧셈</td><td><code>Add</code></td></tr>
<tr><td><code>+=</code></td><td><code>var += expr</code></td><td>산술 덧셈 및 할당</td><td><code>AddAssign</code></td></tr>
<tr><td><code>,</code></td><td><code>expr, expr</code></td><td>인수 및 요소 구분자</td><td></td></tr>
<tr><td><code>-</code></td><td><code>- expr</code></td><td>산술 부정</td><td><code>Neg</code></td></tr>
<tr><td><code>-</code></td><td><code>expr - expr</code></td><td>산술 뺄셈</td><td><code>Sub</code></td></tr>
<tr><td><code>-=</code></td><td><code>var -= expr</code></td><td>산술 뺄셈 및 할당</td><td><code>SubAssign</code></td></tr>
<tr><td><code>-&gt;</code></td><td><code>fn(...) -&gt; type</code>, <code>|...| -&gt; type</code></td><td>함수 및 클로저 반환 타입</td><td></td></tr>
<tr><td><code>.</code></td><td><code>expr.ident</code></td><td>멤버 접근</td><td></td></tr>
<tr><td><code>..</code></td><td><code>..</code>, <code>expr..</code>, <code>..expr</code>, <code>expr..expr</code></td><td>오른쪽 배타적 범위 리터럴</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>..=</code></td><td><code>..=expr</code>, <code>expr..=expr</code></td><td>오른쪽 포함 범위 리터럴</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>..</code></td><td><code>..expr</code></td><td>구조체 리터럴 업데이트 구문</td><td></td></tr>
<tr><td><code>..</code></td><td><code>variant(x, ..)</code>, <code>struct_type { x, .. }</code></td><td>"나머지" 패턴 바인딩</td><td></td></tr>
<tr><td><code>...</code></td><td><code>expr...expr</code></td><td>(더 이상 사용되지 않음, 대신 <code>..=</code> 사용) 패턴에서: 포함 범위 패턴</td><td></td></tr>
<tr><td><code>/</code></td><td><code>expr / expr</code></td><td>산술 나눗셈</td><td><code>Div</code></td></tr>
<tr><td><code>/=</code></td><td><code>var /= expr</code></td><td>산술 나눗셈 및 할당</td><td><code>DivAssign</code></td></tr>
<tr><td><code>:</code></td><td><code>pat: type</code>, <code>ident: type</code></td><td>제약 조건</td><td></td></tr>
<tr><td><code>:</code></td><td><code>ident: expr</code></td><td>구조체 필드 초기화자</td><td></td></tr>
<tr><td><code>:</code></td><td><code>'a: loop {...}</code></td><td>루프 레이블</td><td></td></tr>
<tr><td><code>;</code></td><td><code>expr;</code></td><td>문장 및 아이템 종결자</td><td></td></tr>
<tr><td><code>;</code></td><td><code>[...; len]</code></td><td>고정 크기 배열 문법의 일부</td><td></td></tr>
<tr><td><code>&lt;&lt;</code></td><td><code>expr &lt;&lt; expr</code></td><td>왼쪽 시프트</td><td><code>Shl</code></td></tr>
<tr><td><code>&lt;&lt;=</code></td><td><code>var &lt;&lt;= expr</code></td><td>왼쪽 시프트 및 할당</td><td><code>ShlAssign</code></td></tr>
<tr><td><code>&lt;</code></td><td><code>expr &lt; expr</code></td><td>미만 비교</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&lt;=</code></td><td><code>expr &lt;= expr</code></td><td>이하 비교</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>=</code></td><td><code>var = expr</code>, <code>ident = type</code></td><td>할당/동등</td><td></td></tr>
<tr><td><code>==</code></td><td><code>expr == expr</code></td><td>등호 비교</td><td><code>PartialEq</code></td></tr>
<tr><td><code>=&gt;</code></td><td><code>pat =&gt; expr</code></td><td>매치 암 문법의 일부</td><td></td></tr>
<tr><td><code>&gt;</code></td><td><code>expr &gt; expr</code></td><td>초과 비교</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;=</code></td><td><code>expr &gt;= expr</code></td><td>이상 비교</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;&gt;</code></td><td><code>expr &gt;&gt; expr</code></td><td>오른쪽 시프트</td><td><code>Shr</code></td></tr>
<tr><td><code>&gt;&gt;=</code></td><td><code>var &gt;&gt;= expr</code></td><td>오른쪽 시프트 및 할당</td><td><code>ShrAssign</code></td></tr>
<tr><td><code>@</code></td><td><code>ident @ pat</code></td><td>패턴 바인딩</td><td></td></tr>
<tr><td><code>^</code></td><td><code>expr ^ expr</code></td><td>비트 단위 배타적 OR (XOR)</td><td><code>BitXor</code></td></tr>
<tr><td><code>^=</code></td><td><code>var ^= expr</code></td><td>비트 단위 배타적 OR 및 할당</td><td><code>BitXorAssign</code></td></tr>
<tr><td><code>|</code></td><td><code>pat | pat</code></td><td>패턴 대안</td><td></td></tr>
<tr><td><code>|</code></td><td><code>expr | expr</code></td><td>비트 단위 OR</td><td><code>BitOr</code></td></tr>
<tr><td><code>|=</code></td><td><code>var |= expr</code></td><td>비트 단위 OR 및 할당</td><td><code>BitOrAssign</code></td></tr>
<tr><td><code>||</code></td><td><code>expr || expr</code></td><td>단락 논리 OR</td><td></td></tr>
<tr><td><code>?</code></td><td><code>expr?</code></td><td>에러 전파</td><td></td></tr>
</tbody></table>
</div>
<h3 id="연산자가-아닌-기호"><a class="header" href="#연산자가-아닌-기호">연산자가 아닌 기호</a></h3>
<p>다음 목록에는 연산자로 기능하지 않는 모든 기호, 즉 함수나 메서드 호출처럼 동작하지 않는 기호들이 포함되어 있습니다.</p>
<p>표 B-2는 단독으로 나타나며 다양한 위치에서 유효한 기호들을 보여줍니다.</p>
<p><span class="caption">표 B-2: 단독 구문</span></p>
<div class="table-wrapper"><table><thead><tr><th>기호</th><th>설명</th></tr></thead><tbody>
<tr><td><code>'ident</code></td><td>이름이 있는 라이프타임 또는 루프 레이블</td></tr>
<tr><td><code>...u8</code>, <code>...i32</code>, <code>...f64</code>, <code>...usize</code> 등</td><td>특정 타입의 숫자 리터럴</td></tr>
<tr><td><code>"..."</code></td><td>문자열 리터럴</td></tr>
<tr><td><code>r"..."</code>, <code>r#"..."#</code>, <code>r##"..."##</code> 등</td><td>원시 문자열 리터럴, 이스케이프 문자가 처리되지 않음</td></tr>
<tr><td><code>b"..."</code></td><td>바이트 문자열 리터럴. 문자열 대신 바이트 배열을 생성함</td></tr>
<tr><td><code>br"..."</code>, <code>br#"..."#</code>, <code>br##"..."##</code>, etc.</td><td>원시 바이트 문자열 리터럴. 원시 문자열 리터럴과 바이트 문자열 리터럴의 조합</td></tr>
<tr><td><code>'...'</code></td><td>문자 리터럴</td></tr>
<tr><td><code>b'...'</code></td><td>ASCII 바이트 리터럴</td></tr>
<tr><td><code>|...| expr</code></td><td>클로저</td></tr>
<tr><td><code>!</code></td><td>발산하는 함수를 위한 항상 비어있는 하위 타입(bottom type)</td></tr>
<tr><td><code>_</code></td><td>"무시된" 패턴 바인딩. 정수 리터럴의 가독성을 높이는 데에도 사용됨</td></tr>
</tbody></table>
</div>
<p>표 B-3은 모듈 계층 구조를 통해 아이템으로 가는 경로(path)의 컨텍스트에서 나타나는 기호들을 보여줍니다.</p>
<p><span class="caption">표 B-3: 경로 관련 구문</span></p>
<div class="table-wrapper"><table><thead><tr><th>기호</th><th>설명</th></tr></thead><tbody>
<tr><td><code>ident::ident</code></td><td>네임스페이스 경로</td></tr>
<tr><td><code>::path</code></td><td>외부 프렐류드(extern prelude)에 대한 상대 경로. 다른 모든 크레이트가 루트로 있는 곳 (즉, 크레이트 이름을 포함한 명시적인 절대 경로)</td></tr>
<tr><td><code>self::path</code></td><td>현재 모듈에 대한 상대 경로 (즉, 명시적인 상대 경로)</td></tr>
<tr><td><code>super::path</code></td><td>현재 모듈의 부모에 대한 상대 경로</td></tr>
<tr><td><code>type::ident</code>, <code>&lt;type as trait&gt;::ident</code></td><td>연관 상수, 함수 및 타입</td></tr>
<tr><td><code>&lt;type&gt;::...</code></td><td>직접 이름을 지정할 수 없는 타입에 대한 연관 아이템 (예: <code>&lt;&amp;T&gt;::...</code>, <code>&lt;[T]&gt;::...</code> 등)</td></tr>
<tr><td><code>trait::method(...)</code></td><td>메서드를 정의한 트레이트의 이름을 명시하여 메서드 호출의 모호성을 해소함</td></tr>
<tr><td><code>type::method(...)</code></td><td>메서드가 정의된 타입의 이름을 명시하여 메서드 호출의 모호성을 해소함</td></tr>
<tr><td><code>&lt;type as trait&gt;::method(...)</code></td><td>트레이트와 타입의 이름을 명시하여 메서드 호출의 모호성을 해소함</td></tr>
</tbody></table>
</div>
<p>표 B-4는 제네릭 타입 파라미터를 사용하는 컨텍스트에서 나타나는 기호들을 보여줍니다.</p>
<p><span class="caption">표 B-4: 제네릭</span></p>
<div class="table-wrapper"><table><thead><tr><th>기호</th><th>설명</th></tr></thead><tbody>
<tr><td><code>path&lt;...&gt;</code></td><td>타입 내에서 제네릭 타입에 대한 파라미터를 지정함 (예: <code>Vec&lt;u8&gt;</code>)</td></tr>
<tr><td><code>path::&lt;...&gt;</code>, <code>method::&lt;...&gt;</code></td><td>표현식 내에서 제네릭 타입, 함수 또는 메서드에 대한 파라미터를 지정함. 흔히 터보피쉬(turbofish)라고 불림 (예: <code>"42".parse::&lt;i32&gt;()</code>)</td></tr>
<tr><td><code>fn ident&lt;...&gt; ...</code></td><td>제네릭 함수 정의</td></tr>
<tr><td><code>struct ident&lt;...&gt; ...</code></td><td>제네릭 구조체 정의</td></tr>
<tr><td><code>enum ident&lt;...&gt; ...</code></td><td>제네릭 열거형 정의</td></tr>
<tr><td><code>impl&lt;...&gt; ...</code></td><td>제네릭 구현 정의</td></tr>
<tr><td><code>for&lt;...&gt; type</code></td><td>고차 라이프타임 바운드(Higher-ranked lifetime bounds)</td></tr>
<tr><td><code>type&lt;ident=type&gt;</code></td><td>하나 이상의 연관 타입에 특정 할당이 있는 제네릭 타입 (예: <code>Iterator&lt;Item=T&gt;</code>)</td></tr>
</tbody></table>
</div>
<p>표 B-5는 트레이트 바운드로 제네릭 타입 파라미터를 제약하는 컨텍스트에서 나타나는 기호들을 보여줍니다.</p>
<p><span class="caption">표 B-5: 트레이트 바운드 제약 조건</span></p>
<div class="table-wrapper"><table><thead><tr><th>기호</th><th>설명</th></tr></thead><tbody>
<tr><td><code>T: U</code></td><td><code>U</code>를 구현하는 타입으로 제약된 제네릭 파라미터 <code>T</code></td></tr>
<tr><td><code>T: 'a</code></td><td>제네릭 타입 <code>T</code>는 라이프타임 <code>'a</code>보다 오래 살아야 함 (즉, 해당 타입은 <code>'a</code>보다 짧은 라이프타임을 가진 참조를 간접적으로라도 포함할 수 없음)</td></tr>
<tr><td><code>T: 'static</code></td><td>제네릭 타입 <code>T</code>가 <code>'static</code>이 아닌 대여된 참조를 포함하지 않음</td></tr>
<tr><td><code>'b: 'a</code></td><td>제네릭 라이프타임 <code>'b</code>는 라이프타임 <code>'a</code>보다 오래 지속되어야 함</td></tr>
<tr><td><code>T: ?Sized</code></td><td>제네릭 타입 파라미터가 동적 크기 타입이 될 수 있도록 허용함</td></tr>
<tr><td><code>'a + trait</code>, <code>trait + trait</code></td><td>복합 타입 제약</td></tr>
</tbody></table>
</div>
<p>표 B-6은 매크로를 호출하거나 정의하고 아이템에 속성을 지정하는 컨텍스트에서 나타나는 기호들을 보여줍니다.</p>
<p><span class="caption">표 B-6: 매크로 및 속성</span></p>
<div class="table-wrapper"><table><thead><tr><th>기호</th><th>설명</th></tr></thead><tbody>
<tr><td><code>#[meta]</code></td><td>외부(Outer) 속성</td></tr>
<tr><td><code>#![meta]</code></td><td>내부(Inner) 속성</td></tr>
<tr><td><code>$ident</code></td><td>매크로 치환</td></tr>
<tr><td><code>$ident:kind</code></td><td>매크로 캡처</td></tr>
<tr><td><code>$(…)…</code></td><td>매크로 반복</td></tr>
<tr><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>매크로 호출</td></tr>
</tbody></table>
</div>
<p>표 B-7은 주석을 생성하는 기호들을 보여줍니다.</p>
<p><span class="caption">표 B-7: 주석</span></p>
<div class="table-wrapper"><table><thead><tr><th>기호</th><th>설명</th></tr></thead><tbody>
<tr><td><code>//</code></td><td>한 줄 주석</td></tr>
<tr><td><code>//!</code></td><td>내부 한 줄 문서 주석</td></tr>
<tr><td><code>///</code></td><td>외부 한 줄 문서 주석</td></tr>
<tr><td><code>/*...*/</code></td><td>블록 주석</td></tr>
<tr><td><code>/*!...*/</code></td><td>내부 블록 문서 주석</td></tr>
<tr><td><code>/**...*/</code></td><td>외부 블록 문서 주석</td></tr>
</tbody></table>
</div>
<p>표 B-8은 튜플을 사용하는 컨텍스트에서 나타나는 기호들을 보여줍니다.</p>
<p><span class="caption">표 B-8: 튜플</span></p>
<div class="table-wrapper"><table><thead><tr><th>기호</th><th>설명</th></tr></thead><tbody>
<tr><td><code>()</code></td><td>빈 튜플 (유닛 타입), 리터럴 및 타입 모두 해당</td></tr>
<tr><td><code>(expr)</code></td><td>괄호로 감싸진 표현식</td></tr>
<tr><td><code>(expr,)</code></td><td>단일 요소 튜플 표현식</td></tr>
<tr><td><code>(type,)</code></td><td>단일 요소 튜플 타입</td></tr>
<tr><td><code>(expr, ...)</code></td><td>튜플 표현식</td></tr>
<tr><td><code>(type, ...)</code></td><td>튜플 타입</td></tr>
<tr><td><code>expr(expr, ...)</code></td><td>함수 호출 표현식. 또한 튜플 구조체 및 튜플 열거형 변형을 초기화하는 데에도 사용됨</td></tr>
<tr><td><code>expr.0</code>, <code>expr.1</code> 등</td><td>튜플 인덱싱</td></tr>
</tbody></table>
</div>
<p>표 B-9는 중괄호가 사용되는 컨텍스트를 보여줍니다.</p>
<p><span class="caption">표 B-9: 중괄호</span></p>
<div class="table-wrapper"><table><thead><tr><th>컨텍스트</th><th>설명</th></tr></thead><tbody>
<tr><td><code>{...}</code></td><td>블록 표현식</td></tr>
<tr><td><code>Type {...}</code></td><td>구조체 리터럴</td></tr>
</tbody></table>
</div>
<p>표 B-10은 대괄호가 사용되는 컨텍스트를 보여줍니다.</p>
<p><span class="caption">표 B-10: 대괄호</span></p>
<div class="table-wrapper"><table><thead><tr><th>컨텍스트</th><th>설명</th></tr></thead><tbody>
<tr><td><code>[...]</code></td><td>배열 리터럴</td></tr>
<tr><td><code>[expr; len]</code></td><td><code>expr</code>을 <code>len</code>개 복사한 값을 포함하는 배열 리터럴</td></tr>
<tr><td><code>[type; len]</code></td><td><code>type</code> 인스턴스 <code>len</code>개를 포함하는 배열 타입</td></tr>
<tr><td><code>expr[expr]</code></td><td>컬렉션 인덱싱. 오버로드 가능 (<code>Index</code>, <code>IndexMut</code>)</td></tr>
<tr><td><code>expr[..]</code>, <code>expr[a..]</code>, <code>expr[..b]</code>, <code>expr[a..b]</code></td><td><code>Range</code>, <code>RangeFrom</code>, <code>RangeTo</code> 또는 <code>RangeFull</code>을 “인덱스”로 사용하여 컬렉션 슬라이싱인 것처럼 동작하는 컬렉션 인덱싱</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="부록-c-파생-가능한-트레이트"><a class="header" href="#부록-c-파생-가능한-트레이트">부록 C: 파생 가능한 트레이트</a></h2>
<p>이 책의 여러 곳에서 우리는 구조체나 열거형 정의에 적용할 수 있는 <code>derive</code> 속성에 대해 논의했습니다. <code>derive</code> 속성은 여러분이 <code>derive</code> 구문으로 어노테이션을 단 타입에 대해 트레이트의 기본 구현을 생성하는 코드를 만들어 줍니다.</p>
<p>이 부록에서는 <code>derive</code>와 함께 사용할 수 있는 표준 라이브러리의 모든 트레이트에 대한 참조를 제공합니다. 각 섹션에서는 다음 내용을 다룹니다.</p>
<ul>
<li>이 트레이트를 파생(deriving)함으로써 사용할 수 있게 되는 연산자와 메서드</li>
<li><code>derive</code>에 의해 제공되는 트레이트 구현이 하는 일</li>
<li>이 트레이트를 구현하는 것이 해당 타입에 대해 무엇을 의미하는지</li>
<li>트레이트 구현이 허용되거나 허용되지 않는 조건</li>
<li>해당 트레이트를 필요로 하는 연산의 예시</li>
</ul>
<p><code>derive</code> 속성이 제공하는 것과 다른 동작을 원한다면, 각 트레이트를 수동으로 구현하는 방법에 대한 자세한 내용은 <a href="../std/index.html">표준 라이브러리 문서</a><!-- ignore -->를 참조하세요.</p>
<p>여기에 나열된 트레이트들은 표준 라이브러리에서 정의한 것들 중 <code>derive</code>를 사용하여 여러분의 타입에 구현할 수 있는 유일한 것들입니다. 표준 라이브러리에 정의된 다른 트레이트들은 합리적인 기본 동작을 가지고 있지 않으므로, 여러분이 달성하고자 하는 목적에 맞게 직접 구현해야 합니다.</p>
<p><code>derive</code> 할 수 없는 트레이트의 예로, 최종 사용자를 위한 포맷팅을 처리하는 <code>Display</code>가 있습니다. 타입을 사용자에게 표시할 때는 항상 적절한 방식을 고려해야 합니다. 타입의 어떤 부분을 사용자에게 보여주어야 할까요? 사용자가 어떤 부분에 관심을 가질까요? 어떤 데이터 포맷이 사용자에게 가장 적절할까요? 러스트 컴파일러는 이러한 통찰력을 가지고 있지 않으므로, 여러분을 대신해 적절한 기본 동작을 제공할 수 없습니다.</p>
<p>이 부록에 나열된 파생 가능한 트레이트 목록이 전부는 아닙니다. 라이브러리들은 자신의 트레이트에 대해 <code>derive</code>를 구현할 수 있으므로, <code>derive</code>와 함께 사용할 수 있는 트레이트 목록은 사실상 무한합니다. <code>derive</code>를 구현하는 과정에는 20장의 <a href="ch20-05-macros.html#macros">“매크로”</a><!-- ignore --> 섹션에서 다루는 절차적 매크로를 사용하는 것이 포함됩니다.</p>
<h3 id="프로그래머-출력을-위한-debug"><a class="header" href="#프로그래머-출력을-위한-debug">프로그래머 출력을 위한 <code>Debug</code></a></h3>
<p><code>Debug</code> 트레이트는 포맷 문자열에서 디버그 포맷팅을 가능하게 하며, <code>{}</code> 자리표시자 안에 <code>:?</code>를 추가하여 이를 지정합니다.</p>
<p><code>Debug</code> 트레이트를 사용하면 디버깅 목적으로 타입의 인스턴스를 출력할 수 있으므로, 여러분과 여러분의 타입을 사용하는 다른 프로그래머들이 프로그램 실행 중 특정 시점에 인스턴스의 상태를 검사할 수 있습니다.</p>
<p><code>Debug</code> 트레이트는 예를 들어 <code>assert_eq!</code> 매크로를 사용하는 데 필요합니다. 이 매크로는 상등 단언(equality assertion)이 실패할 경우 인수로 주어진 인스턴스들의 값을 출력하여, 프로그래머가 왜 두 인스턴스가 같지 않은지 확인할 수 있도록 합니다.</p>
<h3 id="상등-비교를-위한-partialeq와-eq"><a class="header" href="#상등-비교를-위한-partialeq와-eq">상등 비교를 위한 <code>PartialEq</code>와 <code>Eq</code></a></h3>
<p><code>PartialEq</code> 트레이트를 사용하면 타입의 인스턴스들을 비교하여 같은지 확인할 수 있으며, <code>==</code> 및 <code>!=</code> 연산자를 사용할 수 있게 됩니다.</p>
<p><code>PartialEq</code>를 파생하면 <code>eq</code> 메서드가 구현됩니다. 구조체에서 <code>PartialEq</code>를 파생할 경우, <em>모든</em> 필드가 같아야만 두 인스턴스가 같은 것으로 간주되며, 어느 한 필드라도 다르면 같지 않은 것으로 간주됩니다. 열거형에서 파생할 경우, 각 변형(variant)은 자기 자신과만 같고 다른 변형과는 같지 않습니다.</p>
<p><code>PartialEq</code> 트레이트는 예를 들어 <code>assert_eq!</code> 매크로를 사용하는 데 필요한데, 이 매크로는 타입의 두 인스턴스가 같은지 비교할 수 있어야 하기 때문입니다.</p>
<p><code>Eq</code> 트레이트에는 메서드가 없습니다. 이 트레이트의 목적은 어노테이션이 달린 타입의 모든 값에 대해, 그 값이 자기 자신과 같음을 나타내는 것입니다. <code>Eq</code> 트레이트는 <code>PartialEq</code>를 구현하는 타입에만 적용할 수 있지만, <code>PartialEq</code>를 구현한다고 해서 모든 타입이 <code>Eq</code>를 구현할 수 있는 것은 아닙니다. 한 가지 예로 부동 소수점 숫자 타입이 있습니다. 부동 소수점 숫자의 구현 명세에 따르면, 숫자가 아님(<code>NaN</code>)을 나타내는 두 값은 서로 같지 않습니다.</p>
<p><code>Eq</code>가 필요한 예로 <code>HashMap&lt;K, V&gt;</code>의 키가 있습니다. 그래야 <code>HashMap&lt;K, V&gt;</code>가 두 키가 같은지 판별할 수 있기 때문입니다.</p>
<h3 id="순서-비교를-위한-partialord와-ord"><a class="header" href="#순서-비교를-위한-partialord와-ord">순서 비교를 위한 <code>PartialOrd</code>와 <code>Ord</code></a></h3>
<p><code>PartialOrd</code> 트레이트를 사용하면 정렬 목적으로 타입의 인스턴스들을 비교할 수 있습니다. <code>PartialOrd</code>를 구현하는 타입은 <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> 연산자와 함께 사용될 수 있습니다. <code>PartialOrd</code> 트레이트는 <code>PartialEq</code>를 구현하는 타입에만 적용할 수 있습니다.</p>
<p><code>PartialOrd</code>를 파생하면 <code>partial_cmp</code> 메서드가 구현되는데, 이 메서드는 주어진 값들 사이에 순서가 정의되지 않을 경우 <code>None</code>이 되는 <code>Option&lt;Ordering&gt;</code>을 반환합니다. 해당 타입의 대부분의 값들은 비교 가능하지만 순서가 정의되지 않는 값의 예로는 부동 소수점의 <code>NaN</code> 값이 있습니다. 어떤 부동 소수점 숫자와 <code>NaN</code> 값을 인수로 하여 <code>partial_cmp</code>를 호출하면 <code>None</code>이 반환됩니다.</p>
<p>구조체에서 파생된 경우, <code>PartialOrd</code>는 구조체 정의에 필드가 나타나는 순서대로 각 필드의 값을 비교하여 두 인스턴스를 비교합니다. 열거형에서 파생된 경우, 열거형 정의에서 앞쪽에 선언된 변형(variant)이 뒤쪽에 나열된 변형보다 작은 것으로 간주됩니다.</p>
<p><code>PartialOrd</code> 트레이트는 예를 들어, 범위 표현식으로 지정된 범위 내에서 임의의 값을 생성하는 <code>rand</code> 크레이트의 <code>gen_range</code> 메서드에서 필요합니다.</p>
<p><code>Ord</code> 트레이트를 사용하면 어노테이션이 달린 타입의 어떤 두 값에 대해서도 유효한 순서가 존재함을 알 수 있습니다. <code>Ord</code> 트레이트는 <code>cmp</code> 메서드를 구현하는데, 유효한 순서가 항상 가능하므로 <code>Option&lt;Ordering&gt;</code>이 아닌 <code>Ordering</code>을 반환합니다. <code>Ord</code> 트레이트는 <code>PartialOrd</code>와 <code>Eq</code>를 모두 구현하는 타입에만 적용할 수 있습니다 (그리고 <code>Eq</code>는 <code>PartialEq</code>를 필요로 합니다). 구조체와 열거형에서 파생된 경우, <code>cmp</code>는 <code>PartialOrd</code>에서 파생된 <code>partial_cmp</code> 구현과 동일하게 동작합니다.</p>
<p><code>Ord</code>가 필요한 예로는 값의 정렬 순서에 따라 데이터를 저장하는 데이터 구조인 <code>BTreeSet&lt;T&gt;</code>에 값을 저장하는 경우가 있습니다.</p>
<h3 id="값-복제를-위한-clone과-copy"><a class="header" href="#값-복제를-위한-clone과-copy">값 복제를 위한 <code>Clone</code>과 <code>Copy</code></a></h3>
<p><code>Clone</code> 트레이트를 사용하면 값의 깊은 복사(deep copy)를 명시적으로 생성할 수 있으며, 복제 과정에서 임의의 코드가 실행되거나 힙 데이터가 복사될 수 있습니다. <code>Clone</code>에 대한 자세한 내용은 4장의 <a href="ch04-01-what-is-ownership.html#variables-and-data-interacting-with-clone">“변수와 데이터가 상호작용하는 방식: 클론”</a><!-- ignore -->을 참조하세요.</p>
<p><code>Clone</code>을 파생하면 <code>clone</code> 메서드가 구현되는데, 타입 전체에 대해 구현될 때 타입의 각 구성 요소에 대해 <code>clone</code>을 호출합니다. 즉, <code>Clone</code>을 파생하려면 타입의 모든 필드나 값들도 <code>Clone</code>을 구현해야 함을 의미합니다.</p>
<p><code>Clone</code>이 필요한 예로는 슬라이스에서 <code>to_vec</code> 메서드를 호출하는 경우가 있습니다. 슬라이스는 자신이 포함하고 있는 타입 인스턴스들을 소유하지 않지만, <code>to_vec</code>에서 반환된 벡터는 인스턴스들을 소유해야 하므로 각 아이템에 대해 <code>clone</code>을 호출합니다. 따라서 슬라이스에 저장된 타입은 반드시 <code>Clone</code>을 구현해야 합니다.</p>
<p><code>Copy</code> 트레이트를 사용하면 스택에 저장된 비트만 복사하여 값을 복제할 수 있으며, 어떠한 임의의 코드도 필요하지 않습니다. <code>Copy</code>에 대한 자세한 내용은 4장의 <a href="ch04-01-what-is-ownership.html#stack-only-data-copy">“스택 전용 데이터: 복사”</a><!-- ignore -->를 참조하세요.</p>
<p><code>Copy</code> 트레이트는 프로그래머가 메서드를 오버로딩하여 임의의 코드가 실행되지 않는다는 가정을 위반하는 것을 방지하기 위해 어떠한 메서드도 정의하지 않습니다. 이런 방식으로 모든 프로그래머는 값을 복사하는 것이 매우 빠를 것이라고 가정할 수 있습니다.</p>
<p>모든 구성 요소가 <code>Copy</code>를 구현하는 타입이라면 무엇이든 <code>Copy</code>를 파생할 수 있습니다. <code>Copy</code>를 구현하는 타입은 반드시 <code>Clone</code>도 구현해야 하는데, <code>Copy</code>를 구현하는 타입은 <code>Copy</code>와 동일한 작업을 수행하는 단순한 <code>Clone</code> 구현을 가지기 때문입니다.</p>
<p><code>Copy</code> 트레이트가 필수인 경우는 드뭅니다. <code>Copy</code>를 구현하는 타입은 최적화가 가능하므로 <code>clone</code>을 호출할 필요가 없으며, 이는 코드를 더 간결하게 만듭니다.</p>
<p><code>Copy</code>로 가능한 모든 작업은 <code>Clone</code>으로도 수행할 수 있지만, 코드가 더 느려지거나 곳곳에서 <code>clone</code>을 사용해야 할 수 있습니다.</p>
<h3 id="값을-고정-크기-값으로-매핑하기-위한-hash"><a class="header" href="#값을-고정-크기-값으로-매핑하기-위한-hash">값을 고정 크기 값으로 매핑하기 위한 <code>Hash</code></a></h3>
<p><code>Hash</code> 트레이트를 사용하면 임의 크기의 타입 인스턴스를 해시 함수를 사용하여 고정 크기의 값으로 매핑할 수 있습니다. <code>Hash</code>를 파생하면 <code>hash</code> 메서드가 구현됩니다. 파생된 <code>hash</code> 메서드 구현은 타입의 각 구성 요소에 대해 <code>hash</code>를 호출한 결과를 결합합니다. 즉, <code>Hash</code>를 파생하려면 모든 필드나 값들도 <code>Hash</code>를 구현해야 함을 의미합니다.</p>
<p><code>Hash</code>가 필요한 예로는 데이터를 효율적으로 저장하기 위해 <code>HashMap&lt;K, V&gt;</code>의 키로 사용하는 경우가 있습니다.</p>
<h3 id="기본값을-위한-default"><a class="header" href="#기본값을-위한-default">기본값을 위한 <code>Default</code></a></h3>
<p><code>Default</code> 트레이트를 사용하면 타입에 대한 기본값을 생성할 수 있습니다. <code>Default</code>를 파생하면 <code>default</code> 함수가 구현됩니다. 파생된 <code>default</code> 함수 구현은 타입의 각 구성 요소에 대해 <code>default</code> 함수를 호출합니다. 즉, <code>Default</code>를 파생하려면 타입의 모든 필드나 값들도 <code>Default</code>를 구현해야 함을 의미합니다.</p>
<p><code>Default::default</code> 함수는 5장의 <a href="ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax">“구조체 업데이트 구문을 사용하여 기존 인스턴스로부터 새로운 인스턴스 생성하기”</a><!-- ignore -->에서 다룬 구조체 업데이트 구문과 함께 자주 사용됩니다. 구조체의 몇몇 필드만 커스터마이징하고 나머지 필드들은 <code>..Default::default()</code>를 사용하여 기본값으로 설정하고 사용할 수 있습니다.</p>
<p><code>Default</code> 트레이트는 예를 들어 <code>Option&lt;T&gt;</code> 인스턴스에서 <code>unwrap_or_default</code> 메서드를 사용할 때 필요합니다. 만약 <code>Option&lt;T&gt;</code>가 <code>None</code>인 경우, <code>unwrap_or_default</code> 메서드는 <code>Option&lt;T&gt;</code>에 저장된 타입 <code>T</code>에 대한 <code>Default::default</code> 결과를 반환합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="부록-d---유용한-개발-도구"><a class="header" href="#부록-d---유용한-개발-도구">부록 D - 유용한 개발 도구</a></h2>
<p>이 부록에서는 러스트 프로젝트에서 제공하는 몇 가지 유용한 개발 도구들에 대해 이야기합니다. 자동 포맷팅, 경고 수정 사항을 빠르게 적용하는 방법, 린터(linter), 그리고 IDE와의 통합에 대해 살펴보겠습니다.</p>
<h3 id="rustfmt를-사용한-자동-포맷팅"><a class="header" href="#rustfmt를-사용한-자동-포맷팅"><code>rustfmt</code>를 사용한 자동 포맷팅</a></h3>
<p><code>rustfmt</code> 도구는 커뮤니티 코드 스타일에 따라 여러분의 코드를 다시 포맷해 줍니다. 많은 협업 프로젝트에서 러스트 코드를 작성할 때 어떤 스타일을 사용할지에 대한 논쟁을 방지하기 위해 <code>rustfmt</code>를 사용합니다. 즉, 모든 사람이 이 도구를 사용하여 코드를 포맷합니다.</p>
<p><code>rustfmt</code>를 설치하려면 다음을 입력하세요.</p>
<pre><code class="language-console">$ rustup component add rustfmt
</code></pre>
<p>이 명령을 실행하면 러스트가 <code>rustc</code>와 <code>cargo</code>를 모두 제공하는 것과 유사하게 <code>rustfmt</code>와 <code>cargo-fmt</code>를 모두 사용할 수 있게 됩니다. 어떤 Cargo 프로젝트든 포맷하려면 다음을 입력하세요.</p>
<pre><code class="language-console">$ cargo fmt
</code></pre>
<p>이 명령을 실행하면 현재 크레이트에 있는 모든 러스트 코드가 다시 포맷됩니다. 이 도구는 코드의 의미(semantics)는 바꾸지 않고 스타일만 변경해야 합니다. <code>rustfmt</code>에 대한 자세한 정보는 <a href="https://github.com/rust-lang/rustfmt">해당 문서</a>를 참조하세요.</p>
<h3 id="rustfix로-코드-수정하기"><a class="header" href="#rustfix로-코드-수정하기"><code>rustfix</code>로 코드 수정하기</a></h3>
<p>rustfix 도구는 러스트 설치 시 포함되어 있으며, 문제를 해결할 명확한 방법이 있는 컴파일러 경고를 자동으로 수정해 줍니다. 이전에 컴파일러 경고를 본 적이 있을 것입니다. 예를 들어, 다음 코드를 생각해 보세요.</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut x = 42;
    println!("{x}");
}</code></pre></pre>
<p>여기서 변수 <code>x</code>를 가변(mutable)으로 정의했지만, 실제로 값을 변경하지는 않았습니다. 러스트는 이에 대해 경고를 보냅니다.</p>
<pre><code class="language-console">$ cargo build
   Compiling myprogram v0.1.0 (file:///projects/myprogram)
warning: variable does not need to be mutable
 --&gt; src/main.rs:2:9
  |
2 |     let mut x = 0;
  |         ----^
  |         |
  |         help: remove this `mut`
  |
  = note: `#[warn(unused_mut)]` on by default
</code></pre>
<p>경고는 <code>mut</code> 키워드를 제거하라고 제안합니다. <code>cargo fix</code> 명령을 실행하여 <code>rustfix</code> 도구로 이 제안을 자동으로 적용할 수 있습니다.</p>
<pre><code class="language-console">$ cargo fix
    Checking myprogram v0.1.0 (file:///projects/myprogram)
      Fixing src/main.rs (1 fix)
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>_src/main.rs_를 다시 확인해 보면, <code>cargo fix</code>가 코드를 변경했음을 알 수 있습니다.</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = 42;
    println!("{x}");
}</code></pre></pre>
<p>변수 <code>x</code>는 이제 불변(immutable)이 되었고, 경고는 더 이상 나타나지 않습니다.</p>
<p>또한 <code>cargo fix</code> 명령을 사용하여 코드를 다른 러스트 에디션으로 전환할 수도 있습니다. 에디션에 대해서는 <a href="appendix-05-editions.html">부록 E</a>에서 다룹니다.</p>
<h3 id="clippy를-이용한-더-많은-린트"><a class="header" href="#clippy를-이용한-더-많은-린트">Clippy를 이용한 더 많은 린트</a></h3>
<p>Clippy 도구는 코드를 분석하여 흔한 실수를 잡아내고 러스트 코드를 개선할 수 있도록 돕는 린트(lint) 모음입니다.</p>
<p>Clippy를 설치하려면 다음을 입력하세요.</p>
<pre><code class="language-console">$ rustup component add clippy
</code></pre>
<p>어떤 Cargo 프로젝트에서든 Clippy 린트를 실행하려면 다음을 입력하세요.</p>
<pre><code class="language-console">$ cargo clippy
</code></pre>
<p>예를 들어, 다음과 같이 원주율(pi)과 같은 수학적 상수의 근사치를 사용하는 프로그램을 작성했다고 해봅시다.</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = 3.1415;
    let r = 8.0;
    println!("원 넓이는 {}입니다", x * r * r);
}</code></pre></pre>
<p>이 프로젝트에서 <code>cargo clippy</code>를 실행하면 다음과 같은 에러가 발생합니다.</p>
<pre><code class="language-text">error: approximate value of `f{32, 64}::consts::PI` found
 --&gt; src/main.rs:2:13
  |
2 |     let x = 3.1415;
  |             ^^^^^^
  |
  = note: `#[deny(clippy::approx_constant)]` on by default
  = help: consider using the constant directly
  = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#approx_constant
</code></pre>
<p>이 에러는 러스트에 이미 더 정밀한 <code>PI</code> 상수가 정의되어 있으며, 직접 값을 쓰는 대신 이 상수를 사용하는 것이 더 정확하다는 점을 알려줍니다. 그러면 여러분은 <code>PI</code> 상수를 사용하도록 코드를 변경할 것입니다. 다음 코드는 Clippy로부터 어떠한 에러나 경고도 발생시키지 않습니다.</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = std::f64::consts::PI;
    let r = 8.0;
    println!("원 넓이는 {}입니다", x * r * r);
}</code></pre></pre>
<p>Clippy에 대한 더 많은 정보는 <a href="https://github.com/rust-lang/rust-clippy">해당 문서</a>를 참조하세요.</p>
<h3 id="rust-analyzer를-이용한-ide-통합"><a class="header" href="#rust-analyzer를-이용한-ide-통합"><code>rust-analyzer</code>를 이용한 IDE 통합</a></h3>
<p>IDE 통합을 위해 러스트 커뮤니티는 <a href="https://rust-analyzer.github.io"><code>rust-analyzer</code></a><!-- ignore -->를 사용할 것을 권장합니다. 이 도구는 IDE와 프로그래밍 언어가 서로 통신하기 위한 규격인 <a href="http://langserver.org/">LSP(Language Server Protocol)</a><!-- ignore -->를 지원하는 컴파일러 중심 유틸리티 모음입니다. <a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer">Visual Studio Code용 Rust analyzer 플러그인</a>과 같이 다양한 클라이언트가 <code>rust-analyzer</code>를 사용할 수 있습니다.</p>
<p><code>rust-analyzer</code> 프로젝트의 <a href="https://rust-analyzer.github.io">홈페이지</a><!-- ignore -->에서 설치 지침을 확인한 다음, 사용 중인 IDE에 언어 서버 지원을 설치하세요. 그러면 자동 완성, 정의로 이동, 인라인 오류와 같은 기능을 IDE에서 사용할 수 있습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="부록-e---에디션"><a class="header" href="#부록-e---에디션">부록 E - 에디션</a></h2>
<p>1장에서 여러분은 <code>cargo new</code>가 <em>Cargo.toml</em> 파일에 에디션에 관한 약간의 메타데이터를 추가하는 것을 보았습니다. 이 부록에서는 그것이 무엇을 의미하는지에 대해 이야기합니다!</p>
<p>러스트 언어와 컴파일러는 6주마다 릴리스되므로 사용자들은 새로운 기능을 지속적으로 제공받습니다. 다른 프로그래밍 언어들은 큰 변화를 가끔 릴리스하는 반면, 러스트는 작은 업데이트를 더 자주 릴리스합니다. 시간이 흐르면 이러한 작은 변화들이 쌓이게 됩니다. 하지만 릴리스를 거듭하다 보면 뒤를 돌아보며 “와, 러스트 1.10과 1.31 사이에 러스트가 정말 많이 변했네!”라고 말하기 어려울 수 있습니다.</p>
<p>2~3년마다 러스트 팀은 새로운 러스트 _에디션(edition)_을 만듭니다. 각 에디션은 그동안 추가된 기능들을 하나의 명확한 패키지로 묶고, 완전히 업데이트된 문서와 도구들을 제공합니다. 새로운 에디션은 일반적인 6주 단위 릴리스 프로세스의 일부로 제공됩니다.</p>
<p>에디션은 사람마다 서로 다른 목적을 수행합니다.</p>
<ul>
<li>활동적인 러스트 사용자들에게 새로운 에디션은 점진적인 변화들을 이해하기 쉬운 하나의 패키지로 묶어 제공합니다.</li>
<li>비사용자들에게 새로운 에디션은 몇 가지 주요 발전 사항이 적용되었음을 알리는 신호이며, 러스트를 다시 한번 살펴볼 가치가 있게 만듭니다.</li>
<li>러스트를 개발하는 사람들에게 새로운 에디션은 프로젝트 전체의 결집점을 제공합니다.</li>
</ul>
<p>이 글을 쓰는 시점에 사용 가능한 러스트 에디션은 네 가지입니다: 러스트 2015, 러스트 2018, 러스트 2021, 그리고 러스트 2024입니다. 이 책은 러스트 2024 에디션의 관용구를 사용하여 작성되었습니다.</p>
<p>_Cargo.toml_의 <code>edition</code> 키는 컴파일러가 여러분의 코드에 어떤 에디션을 사용해야 하는지 나타냅니다. 이 키가 존재하지 않으면, 하위 호환성을 위해 <code>2015</code>를 에디션 값으로 사용합니다.</p>
<p>각 프로젝트는 기본값인 2015 에디션 이외의 에디션을 선택할 수 있습니다. 에디션에는 코드 내의 식별자와 충돌하는 새로운 키워드를 포함하는 것과 같이 호환되지 않는 변경 사항이 포함될 수 있습니다. 하지만 여러분이 그러한 변경 사항을 명시적으로 선택하지 않는 한, 러스트 컴파일러 버전을 업그레이드하더라도 여러분의 코드는 계속해서 컴파일될 것입니다.</p>
<p>모든 러스트 컴파일러 버전은 해당 컴파일러 출시 이전에 존재했던 모든 에디션을 지원하며, 지원되는 모든 에디션의 크레이트들을 함께 링크할 수 있습니다. 에디션 변경은 컴파일러가 처음에 코드를 파싱하는 방식에만 영향을 미칩니다. 따라서 여러분이 러스트 2015를 사용하고 의존성 중 하나가 러스트 2018을 사용하더라도, 프로젝트는 성공적으로 컴파일되어 해당 의존성을 사용할 수 있습니다. 반대로 프로젝트가 러스트 2018을 사용하고 의존성이 러스트 2015를 사용하는 경우에도 마찬가지로 잘 작동합니다.</p>
<p>분명히 말씀드리자면, 대부분의 기능은 모든 에디션에서 사용 가능합니다. 어떤 러스트 에디션을 사용하는 개발자든 새로운 안정화 버전이 출시됨에 따라 계속해서 개선 사항을 경험하게 될 것입니다. 하지만 새로운 키워드가 추가되는 경우 등 일부 사례에서는 새로운 기능이 이후 에디션에서만 제공될 수 있습니다. 그러한 기능을 활용하고 싶다면 에디션을 전환해야 합니다.</p>
<p>더 자세한 내용은 에디션 간의 차이점을 나열하고 <code>cargo fix</code>를 통해 코드를 새로운 에디션으로 자동 업그레이드하는 방법을 설명하는 에디션 전문서인 <a href="https://doc.rust-lang.org/stable/edition-guide/"><em>에디션 가이드(Edition Guide)</em></a>를 참조하세요.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="부록-f-책의-번역본"><a class="header" href="#부록-f-책의-번역본">부록 F: 책의 번역본</a></h2>
<p>영어가 아닌 다른 언어로 된 자료입니다. 대부분 아직 진행 중입니다. <a href="https://github.com/rust-lang/book/issues?q=is%3Aopen+is%3Aissue+label%3ATranslations">번역 레이블</a>을 참조하여 도움을 주시거나 새로운 번역에 대해 알려주세요!</p>
<ul>
<li><a href="https://github.com/rust-br/rust-book-pt-br">Português</a> (BR)</li>
<li><a href="https://github.com/nunojesus/rust-book-pt-pt">Português</a> (PT)</li>
<li>간체 중문: <a href="https://github.com/KaiserY/trpl-zh-cn">KaiserY/trpl-zh-cn</a>, <a href="https://github.com/gnu4cn/rust-lang-Zh_CN">gnu4cn/rust-lang-Zh_CN</a>简体中文: <a href="https://github.com/KaiserY/trpl-zh-cn">KaiserY/trpl-zh-cn</a>, <a href="https://github.com/gnu4cn/rust-lang-Zh_CN">gnu4cn/rust-lang-Zh_CN</a></li>
<li><a href="https://github.com/rust-tw/book-tw">正體中文</a></li>
<li><a href="https://rust-lang-ua.github.io/rustbook_ukrainian">Українська</a></li>
<li><a href="https://github.com/thecodix/book">Español</a>, <a href="https://github.com/ManRR/rust-book-es">alternate</a>, <a href="https://github.com/RustLangES/rust-book-es">Español por RustLangES</a></li>
<li><a href="https://github.com/rust-lang-ru/book">Русский</a></li>
<li><a href="https://github.com/rust-kr/doc.rust-kr.org">한국어</a></li>
<li><a href="https://github.com/rust-lang-ja/book-ja">日本語</a></li>
<li><a href="https://github.com/Jimskapt/rust-book-fr">Français</a></li>
<li><a href="https://github.com/paytchoo/book-pl">Polski</a></li>
<li><a href="https://github.com/agentzero1/book">Cebuano</a></li>
<li><a href="https://github.com/josephace135/book">Tagalog</a></li>
<li><a href="https://github.com/psychoslave/Rust-libro">Esperanto</a></li>
<li><a href="https://github.com/TChatzigiannakis/rust-book-greek">ελληνική</a></li>
<li><a href="https://github.com/sebras/book">Svenska</a></li>
<li><a href="https://github.com/RustFarsi/book">Farsi</a>, <a href="https://github.com/persian-rust/book">Persian (FA)</a></li>
<li><a href="https://github.com/rust-lang-de/rustbook-de">Deutsch</a></li>
<li><a href="https://github.com/venkatarun95/rust-book-hindi">हिंदी</a></li>
<li><a href="https://github.com/rust-lang-th/book-th">ไทย</a></li>
<li><a href="https://github.com/DanKHansen/book-dk">Danske</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="부록-g---rust는-어떻게-만들어지며-nightly-rust란-무엇인가"><a class="header" href="#부록-g---rust는-어떻게-만들어지며-nightly-rust란-무엇인가">부록 G - Rust는 어떻게 만들어지며 “Nightly Rust”란 무엇인가</a></h2>
<p>이 부록은 Rust가 어떻게 만들어지는지와 그것이 Rust 개발자로서 당신에게 어떤 영향을 미치는지에 대한 내용입니다.</p>
<h3 id="정체-없는-안정성"><a class="header" href="#정체-없는-안정성">정체 없는 안정성</a></h3>
<p>언어로서 Rust는 코드의 안정성에 대해 <em>매우</em> 중요하게 생각합니다. 우리는 Rust가 여러분이 구축할 수 있는 견고한 기반이 되기를 원하며, 만약 상황이 계속해서 바뀐다면 그것은 불가능할 것입니다. 동시에, 새로운 기능을 실험할 수 없다면, 출시 후에야 중요한 결함을 발견하게 될 수 있으며, 그때는 더 이상 변경할 수 없습니다.</p>
<p>이 문제에 대한 우리의 해결책은 “정체 없는 안정성”이라고 부르는 것이며, 우리의 기본 원칙은 다음과 같습니다. 안정적인 Rust의 새 버전으로 업그레이드하는 것을 두려워해서는 안 됩니다. 각 업그레이드는 고통 없이 이루어져야 하며, 새로운 기능, 더 적은 버그, 더 빠른 컴파일 시간을 제공해야 합니다.</p>
<h3 id="추-추-릴리스-채널과-기차-타기"><a class="header" href="#추-추-릴리스-채널과-기차-타기">추-추! 릴리스 채널과 기차 타기</a></h3>
<p>Rust 개발은 _기차 일정_에 따라 운영됩니다. 즉, 모든 개발은 Rust 저장소의 <code>master</code> 브랜치에서 이루어집니다. 릴리스는 Cisco IOS 및 기타 소프트웨어 프로젝트에서 사용된 소프트웨어 릴리스 트레인 모델을 따릅니다. Rust에는 세 가지 _릴리스 채널_이 있습니다:</p>
<ul>
<li>나이틀리</li>
<li>베타</li>
<li>스테이블</li>
</ul>
<p>대부분의 Rust 개발자는 주로 안정 채널을 사용하지만, 실험적인 새로운 기능을 사용해보고 싶은 사람들은 나이틀리 또는 베타를 사용할 수 있습니다.</p>
<p>개발 및 릴리스 프로세스가 어떻게 작동하는지에 대한 예는 다음과 같습니다. Rust 팀이 Rust 1.5 릴리스 작업을 하고 있다고 가정해 보겠습니다. 해당 릴리스는 2015년 12월에 있었지만, 현실적인 버전 번호를 제공할 것입니다. 새로운 기능이 Rust에 추가됩니다. 새로운 커밋이 <code>master</code> 브랜치에 적용됩니다. 매일 밤 새로운 나이틀리 버전의 Rust가 생성됩니다. 매일이 릴리스 날이며, 이러한 릴리스는 릴리스 인프라에서 자동으로 생성됩니다. 따라서 시간이 지남에 따라 릴리스는 하룻밤에 한 번씩 다음과 같이 보입니다:</p>
<pre><code class="language-text">nightly: * - - * - - *
</code></pre>
<p>6주마다 새로운 릴리스를 준비할 시간이 돌아옵니다! 러스트 저장소의 <code>beta</code> 브랜치는 나이틀리에서 사용하는 <code>master</code> 브랜치로부터 갈라져 나옵니다. 이제 두 개의 릴리스가 존재하게 됩니다.</p>
<pre><code class="language-text">nightly: * - - * - - *
                     |
beta:                *
</code></pre>
<p>대부분의 러스트 사용자들은 베타 릴리스를 적극적으로 사용하지는 않지만, 자신들의 CI 시스템에서 베타 버전을 테스트함으로써 러스트가 발생 가능한 회귀 버그(regression)를 발견하도록 돕습니다. 그동안에도 매일 밤 나이틀리 릴리스는 계속됩니다.</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - *
                     |
beta:                *
</code></pre>
<p>회귀 버그가 발견되었다고 가정해 봅시다. 회귀 버그가 안정 버전 릴리스에 몰래 들어가기 전에 베타 릴리스를 테스트할 시간이 있었다는 것은 다행스러운 일입니다! 수정 사항은 <code>master</code> 브랜치에 적용되어 나이틀리 버전이 수정되고, 그런 다음 해당 수정 사항이 <code>beta</code> 브랜치로 백포트(backport)되어 새로운 베타 릴리스가 생성됩니다.</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - *
                     |
beta:                * - - - - - - - - *
</code></pre>
<p>첫 번째 베타가 생성된 지 6주가 지나면, 이제 안정 버전(stable)을 릴리스할 시간입니다! <code>stable</code> 브랜치는 <code>beta</code> 브랜치로부터 만들어집니다.</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |
beta:                * - - - - - - - - *
                                       |
stable:                                *
</code></pre>
<p>만세! 러스트 1.5가 완성되었습니다! 하지만 우리가 잊은 것이 하나 있습니다. 6주가 지났기 때문에, 러스트의 <em>다음</em> 버전인 1.6의 새로운 베타 버전도 필요하다는 점입니다. 따라서 <code>stable</code>이 <code>beta</code>에서 갈라져 나온 후, 다음 버전의 <code>beta</code>가 다시 <code>nightly</code>에서 갈라져 나옵니다.</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |                         |
beta:                * - - - - - - - - *       *
                                       |
stable:                                *
</code></pre>
<p>이것을 “기차 모델(train model)”이라고 부르는 이유는 6주마다 릴리스가 “역을 출발”하지만, 안정 버전으로 도착하기 전까지 베타 채널을 통과하는 여정을 거쳐야 하기 때문입니다.</p>
<p>러스트는 시계태엽처럼 정확히 6주마다 릴리스됩니다. 여러분이 한 러스트 릴리스 날짜를 안다면, 다음 릴리스 날짜도 알 수 있습니다. 바로 6주 뒤입니다. 6주마다 릴리스가 예정되어 있다는 점의 좋은 점은 다음 기차가 곧 온다는 것입니다. 만약 어떤 기능이 특정 릴리스 기차를 놓치더라도 걱정할 필요가 없습니다. 머지않아 다음 기차가 올 것이기 때문입니다! 덕분에 릴리스 마감 기한에 맞춰 아직 다듬어지지 않은 기능을 무리하게 밀어 넣어야 한다는 압박감을 줄여줍니다.</p>
<p>이러한 프로세스 덕분에 여러분은 항상 러스트의 다음 빌드를 확인하고 업그레이드가 용이한지 직접 검증할 수 있습니다. 만약 베타 릴리스가 예상대로 작동하지 않는다면 팀에 보고하여 다음 안정 버전이 릴리스되기 전에 수정할 수 있습니다! 베타 릴리스에서 하위 호환성이 깨지는 일은 비교적 드물지만, <code>rustc</code> 또한 소프트웨어의 일종이므로 버그는 존재할 수 있습니다.</p>
<h3 id="유지보수-기간"><a class="header" href="#유지보수-기간">유지보수 기간</a></h3>
<p>러스트 프로젝트는 가장 최신의 안정 버전을 지원합니다. 새로운 안정 버전이 릴리스되면 이전 버전은 수명 종료(End of Life, EOL) 단계에 접어듭니다. 즉, 각 버전은 6주 동안 지원됩니다.</p>
<h3 id="불안정한-기능"><a class="header" href="#불안정한-기능">불안정한 기능</a></h3>
<p>이 릴리스 모델에는 한 가지가 더 있습니다. 바로 불안정한 기능(unstable features)입니다. 러스트는 특정 릴리스에서 어떤 기능이 활성화될지 결정하기 위해 “기능 플래그(feature flags)”라는 기술을 사용합니다. 새로운 기능이 활발히 개발 중이라면 <code>master</code> 브랜치에 적용되어 나이틀리 버전에 포함되지만, <em>기능 플래그</em> 뒤에 숨겨진 상태가 됩니다. 사용자로서 현재 개발 중인 기능을 시도해보고 싶다면 그렇게 할 수 있지만, 반드시 러스트 나이틀리 버전을 사용해야 하며 소스 코드에 적절한 플래그를 달아 해당 기능을 사용하겠다고 명시해야 합니다.</p>
<p>만약 여러분이 러스트의 베타나 안정 버전을 사용 중이라면, 어떠한 기능 플래그도 사용할 수 없습니다. 이것은 우리가 어떤 기능을 영구적으로 안정적이라고 선언하기 전에 새로운 기능들을 실제로 사용해 볼 수 있게 해주는 핵심 장치입니다. 최첨단 기능을 사용해 보고 싶은 사람들은 그렇게 할 수 있고, 견고한 경험을 원하는 사람들은 안정 버전을 고수하면서 자신의 코드가 깨지지 않을 것임을 확신할 수 있습니다. 이것이 바로 정체 없는 안정성입니다.</p>
<p>이 책은 오직 안정 버전의 기능들에 대한 정보만을 담고 있습니다. 개발 중인 기능들은 여전히 변경되고 있으며, 이 책이 쓰인 시점과 해당 기능이 안정 버전에서 활성화되는 시점 사이에는 분명 차이가 있을 것이기 때문입니다. 나이틀리 전용 기능들에 대한 문서는 온라인에서 찾아볼 수 있습니다.</p>
<h3 id="rustup과-러스트-나이틀리의-역할"><a class="header" href="#rustup과-러스트-나이틀리의-역할">Rustup과 러스트 나이틀리의 역할</a></h3>
<p>Rustup을 사용하면 글로벌 또는 프로젝트 단위로 러스트의 서로 다른 릴리스 채널을 쉽게 전환할 수 있습니다. 기본적으로는 안정 버전의 러스트가 설치되어 있을 것입니다. 예를 들어 나이틀리 버전을 설치하려면 다음과 같이 합니다.</p>
<pre><code class="language-console">$ rustup toolchain install nightly
</code></pre>
<p><code>rustup</code>으로 설치한 모든 <em>툴체인(toolchains)</em> (러스트 릴리스 및 관련 컴포넌트) 목록도 확인할 수 있습니다. 다음은 저자 중 한 명의 윈도우 컴퓨터에서의 예시입니다.</p>
<pre><code class="language-powershell">&gt; rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
</code></pre>
<p>보시는 것처럼 안정 버전 툴체인이 기본값입니다. 대부분의 러스트 사용자들은 대부분의 시간에 안정 버전을 사용합니다. 하지만 특정 프로젝트에서는 최첨단 기능이 필요하여 나이틀리 버전을 사용하고 싶을 수도 있습니다. 그럴 때는 해당 프로젝트 디렉토리에서 <code>rustup override</code>를 사용하여, 그 디렉토리에 있을 때 <code>rustup</code>이 나이틀리 툴체인을 사용하도록 설정할 수 있습니다.</p>
<pre><code class="language-console">$ cd ~/projects/needs-nightly
$ rustup override set nightly
</code></pre>
<p>이제 <em>~/projects/needs-nightly</em> 내부에서 <code>rustc</code>나 <code>cargo</code>를 호출할 때마다, <code>rustup</code>은 기본인 안정 버전 대신 나이틀리 버전의 러스트를 사용하도록 보장할 것입니다. 이는 여러 러스트 프로젝트를 다룰 때 매우 유용합니다!</p>
<h3 id="rfc-프로세스와-팀"><a class="header" href="#rfc-프로세스와-팀">RFC 프로세스와 팀</a></h3>
<p>그렇다면 이러한 새로운 기능들에 대해서는 어떻게 알 수 있을까요? 러스트의 개발 모델은 _RFC(Request For Comments) 프로세스_를 따릅니다. 러스트에서 개선하고 싶은 점이 있다면 RFC라고 불리는 제안서를 작성할 수 있습니다.</p>
<p>누구나 러스트를 개선하기 위한 RFC를 작성할 수 있으며, 제안된 내용은 여러 주제별 서브팀으로 구성된 러스트 팀에 의해 검토되고 논의됩니다. <a href="https://www.rust-lang.org/governance">러스트 웹사이트</a>에서 팀 전체 목록을 볼 수 있으며, 여기에는 언어 설계, 컴파일러 구현, 인프라, 문서화 등 프로젝트의 각 영역별 팀이 포함되어 있습니다. 담당 팀이 제안서와 댓글들을 읽고 직접 의견을 작성하며, 최종적으로 해당 기능을 수락하거나 거절할지에 대한 합의를 도출합니다.</p>
<p>기능이 수락되면 러스트 저장소에 이슈가 생성되고, 누군가가 이를 구현할 수 있습니다. 기능을 구현하는 사람이 반드시 처음 기능을 제안한 사람이어야 하는 것은 아닙니다! 구현이 완료되면 <a href="appendix-07-nightly-rust.html#unstable-features">“불안정한 기능”</a><!-- ignore --> 섹션에서 논의한 것처럼 기능 게이트 뒤에 숨겨진 채로 <code>master</code> 브랜치에 적용됩니다.</p>
<p>어느 정도 시간이 지나 나이틀리 버전을 사용하는 러스트 개발자들이 새로운 기능을 충분히 시도해 본 뒤에는, 팀 멤버들이 해당 기능이 나이틀리에서 어떻게 작동했는지 논의하고 이를 안정 버전에 포함할지 여부를 결정합니다. 진행하기로 결정되면 기능 게이트가 제거되고, 해당 기능은 이제 안정적인 것으로 간주됩니다! 그리고 기차를 타고 러스트의 새로운 안정 버전 릴리스에 포함됩니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
