<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>패턴을 사용할 수 있는 모든 곳 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch19-01-all-the-places-for-patterns.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch19-01-all-the-places-for-patterns.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="패턴을-사용할-수-있는-모든-곳"><a class="header" href="#패턴을-사용할-수-있는-모든-곳">패턴을 사용할 수 있는 모든 곳</a></h2>
<p>패턴은 러스트의 여러 곳에서 나타나며, 여러분은 자신도 모르는 사이에 패턴을 많이 사용해 왔습니다! 이 섹션에서는 패턴이 유효한 모든 장소들에 대해 논의합니다.</p>
<h3 id="match-가지arms"><a class="header" href="#match-가지arms"><code>match</code> 가지(Arms)</a></h3>
<p>6장에서 논의했듯이, 우리는 <code>match</code> 표현식의 가지에서 패턴을 사용합니다. 공식적으로 <code>match</code> 표현식은 <code>match</code> 키워드, 매칭할 값, 그리고 하나 이상의 매치 가지들로 정의됩니다. 매치 가지는 패턴과, 값이 해당 가지의 패턴과 매치될 경우 실행할 표현식으로 구성됩니다. 다음과 같은 식이죠.</p>
<!--
  Manually formatted rather than using Markdown intentionally: Markdown does not
  support italicizing code in the body of a block like this!
-->
<pre><code>match <em>VALUE</em> {
    <em>PATTERN</em> => <em>EXPRESSION</em>,
    <em>PATTERN</em> => <em>EXPRESSION</em>,
    <em>PATTERN</em> => <em>EXPRESSION</em>,
}</code></pre>
<p>For example, here’s the <code>match</code> expression from Listing 6-5 that matches on an <code>Option&lt;i32&gt;</code> value in the variable <code>x</code>:</p>
<pre><code class="language-rust ignore">match x {
    None =&gt; None,
    Some(i) =&gt; Some(i + 1),
}</code></pre>
<p>The patterns in this <code>match</code> expression are the <code>None</code> and <code>Some(i)</code> to the left of each arrow.</p>
<p>One requirement for <code>match</code> expressions is that they need to be exhaustive in the sense that all possibilities for the value in the <code>match</code> expression must be accounted for. One way to ensure that you’ve covered every possibility is to have a catch-all pattern for the last arm: For example, a variable name matching any value can never fail and thus covers every remaining case.</p>
<p>The particular pattern <code>_</code> will match anything, but it never binds to a variable, so it’s often used in the last match arm. The <code>_</code> pattern can be useful when you want to ignore any value not specified, for example. We’ll cover the <code>_</code> pattern in more detail in <a href="ch19-03-pattern-syntax.html#ignoring-values-in-a-pattern">“Ignoring Values in a Pattern”</a><!-- ignore --> later in this chapter.</p>
<h3 id="let-문"><a class="header" href="#let-문"><code>let</code> 문</a></h3>
<p>이번 장 이전까지 우리는 오직 <code>match</code>와 <code>if let</code>에서 패턴을 사용하는 것에 대해서만 명시적으로 논의했었지만, 사실 우리는 <code>let</code> 문을 포함하여 다른 곳에서도 패턴을 사용해 왔습니다. 예를 들어, <code>let</code>을 사용한 간단한 변수 할당을 생각해 봅시다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}</span></code></pre></pre>
<p>Every time you’ve used a <code>let</code> statement like this you’ve been using patterns, although you might not have realized it! More formally, a <code>let</code> statement looks like this:</p>
<!--
  Manually formatted rather than using Markdown intentionally: Markdown does not
  support italicizing code in the body of a block like this!
-->
<pre>
<code>let <em>PATTERN</em> = <em>EXPRESSION</em>;</code>
</pre>
<p>In statements like <code>let x = 5;</code> with a variable name in the PATTERN slot, the variable name is just a particularly simple form of a pattern. Rust compares the expression against the pattern and assigns any names it finds. So, in the <code>let x = 5;</code> example, <code>x</code> is a pattern that means “bind what matches here to the variable <code>x</code>.” Because the name <code>x</code> is the whole pattern, this pattern effectively means “bind everything to the variable <code>x</code>, whatever the value is.”</p>
<p>To see the pattern-matching aspect of <code>let</code> more clearly, consider Listing 19-1, which uses a pattern with <code>let</code> to destructure a tuple.</p>
<Listing number="19-1" caption="Using a pattern to destructure a tuple and create three variables at once">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let (x, y, z) = (1, 2, 3);
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>Here, we match a tuple against a pattern. Rust compares the value <code>(1, 2, 3)</code> to the pattern <code>(x, y, z)</code> and sees that the value matches the pattern—that is, it sees that the number of elements is the same in both—so Rust binds <code>1</code> to <code>x</code>, <code>2</code> to <code>y</code>, and <code>3</code> to <code>z</code>. You can think of this tuple pattern as nesting three individual variable patterns inside it.</p>
<p>If the number of elements in the pattern doesn’t match the number of elements in the tuple, the overall type won’t match and we’ll get a compiler error. For example, Listing 19-2 shows an attempt to destructure a tuple with three elements into two variables, which won’t work.</p>
<Listing number="19-2" caption="Incorrectly constructing a pattern whose variables don’t match the number of elements in the tuple">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let (x, y) = (1, 2, 3);
<span class="boring">}</span></code></pre>
</Listing>
<p>이 코드를 컴파일하려고 시도하면 다음과 같은 타입 에러가 발생합니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0308]: mismatched types
 --&gt; src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^   --------- 이 표현식은 `({integer}, {integer}, {integer})` 타입을 가집니다
  |         |
  |         3개의 요소를 가진 튜플을 예상했으나, 2개의 요소를 가진 튜플이 발견되었습니다
  |
  = note: 튜플 `({integer}, {integer}, {integer})`를 예상했으나
             튜플 `(_, _)`를 발견했습니다

이 에러에 대한 더 자세한 정보를 원하시면 `rustc --explain E0308`을 시도해 보세요.
에러: 1개의 이전 에러로 인해 `patterns` (바이너리 "patterns")를 컴파일할 수 없습니다
</code></pre>
<p>To fix the error, we could ignore one or more of the values in the tuple using <code>_</code> or <code>..</code>, as you’ll see in the <a href="ch19-03-pattern-syntax.html#ignoring-values-in-a-pattern">“Ignoring Values in a Pattern”</a><!-- ignore --> section. If the problem is that we have too many variables in the pattern, the solution is to make the types match by removing variables so that the number of variables equals the number of elements in the tuple.</p>
<h3 id="조건부-if-let-표현식"><a class="header" href="#조건부-if-let-표현식">조건부 <code>if let</code> 표현식</a></h3>
<p>In Chapter 6, we discussed how to use <code>if let</code> expressions mainly as a shorter way to write the equivalent of a <code>match</code> that only matches one case. Optionally, <code>if let</code> can have a corresponding <code>else</code> containing code to run if the pattern in the <code>if let</code> doesn’t match.</p>
<p>Listing 19-3 shows that it’s also possible to mix and match <code>if let</code>, <code>else if</code>, and <code>else if let</code> expressions. Doing so gives us more flexibility than a <code>match</code> expression in which we can express only one value to compare with the patterns. Also, Rust doesn’t require that the conditions in a series of <code>if let</code>, <code>else if</code>, and <code>else if let</code> arms relate to each other.</p>
<p>The code in Listing 19-3 determines what color to make your background based on a series of checks for several conditions. For this example, we’ve created variables with hardcoded values that a real program might receive from user input.</p>
<Listing number="19-3" file-name="src/main.rs" caption="Mixing `if let`, `else if`, `else if let`, and `else`">
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let favorite_color: Option&lt;&amp;str&gt; = None;
    let is_tuesday = false;
    let age: Result&lt;u8, _&gt; = "34".parse();

    if let Some(color) = favorite_color {
        println!("좋아하는 색상 {color}을 배경색으로 사용합니다");
    } else if is_tuesday {
        println!("화요일은 초록의 날입니다!");
    } else if let Ok(age) = age {
        if age &gt; 30 {
            println!("보라색을 배경색으로 사용합니다");
        } else {
            println!("오렌지색을 배경색으로 사용합니다");
        }
    } else {
        println!("파란색을 배경색으로 사용합니다");
    }
}</code></pre></pre>
</Listing>
<p>사용자가 좋아하는 색상을 지정하면 그 색상이 배경으로 사용됩니다. 좋아하는 색상이 지정되지 않았고 오늘이 화요일이라면 배경색은 초록색이 됩니다. 그렇지 않고 사용자가 나이를 문자열로 지정했으며 이를 숫자로 성공적으로 파싱할 수 있다면, 숫자의 값에 따라 보라색이나 오렌지색이 됩니다. 이 조건들 중 어느 것도 해당하지 않는다면 배경색은 파란색이 됩니다.</p>
<p>이러한 조건 구조를 통해 복잡한 요구사항을 지원할 수 있습니다. 여기에 있는 하드코딩된 값들을 사용하면, 이 예제는 <code>보라색을 배경색으로 사용합니다</code>를 출력할 것입니다.</p>
<p>You can see that <code>if let</code> can also introduce new variables that shadow existing variables in the same way that <code>match</code> arms can: The line <code>if let Ok(age) = age</code> introduces a new <code>age</code> variable that contains the value inside the <code>Ok</code> variant, shadowing the existing <code>age</code> variable. This means we need to place the <code>if age &gt; 30</code> condition within that block: We can’t combine these two conditions into <code>if let Ok(age) = age &amp;&amp; age &gt; 30</code>. The new <code>age</code> we want to compare to 30 isn’t valid until the new scope starts with the curly bracket.</p>
<p><code>if let</code> 표현식을 사용하는 것의 단점은 컴파일러가 포괄성(exhaustiveness)을 검사하지 않는다는 점입니다. 반면 <code>match</code> 표현식은 검사합니다. 만약 우리가 마지막 <code>else</code> 블록을 생략하여 일부 경우를 놓치더라도, 컴파일러는 잠재적인 로직 버그에 대해 경고해 주지 않을 것입니다.</p>
<h3 id="while-let-조건부-루프"><a class="header" href="#while-let-조건부-루프"><code>while let</code> 조건부 루프</a></h3>
<p>Similar in construction to <code>if let</code>, the <code>while let</code> conditional loop allows a <code>while</code> loop to run for as long as a pattern continues to match. In Listing 19-4, we show a <code>while let</code> loop that waits on messages sent between threads, but in this case checking a <code>Result</code> instead of an <code>Option</code>.</p>
<Listing number="19-4" caption="Using a `while let` loop to print values for as long as `rx.recv()` returns `Ok`">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let (tx, rx) = std::sync::mpsc::channel();
    std::thread::spawn(move || {
        for val in [1, 2, 3] {
            tx.send(val).unwrap();
        }
    });

    while let Ok(value) = rx.recv() {
        println!("{value}");
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>This example prints <code>1</code>, <code>2</code>, and then <code>3</code>. The <code>recv</code> method takes the first message out of the receiver side of the channel and returns an <code>Ok(value)</code>. When we first saw <code>recv</code> back in Chapter 16, we unwrapped the error directly, or we interacted with it as an iterator using a <code>for</code> loop. As Listing 19-4 shows, though, we can also use <code>while let</code>, because the <code>recv</code> method returns an <code>Ok</code> each time a message arrives, as long as the sender exists, and then produces an <code>Err</code> once the sender side disconnects.</p>
<h3 id="for-루프"><a class="header" href="#for-루프"><code>for</code> 루프</a></h3>
<p>In a <code>for</code> loop, the value that directly follows the keyword <code>for</code> is a pattern. For example, in <code>for x in y</code>, the <code>x</code> is the pattern. Listing 19-5 demonstrates how to use a pattern in a <code>for</code> loop to destructure, or break apart, a tuple as part of the <code>for</code> loop.</p>
<Listing number="19-5" caption="Using a pattern in a `for` loop to destructure a tuple">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let v = vec!['a', 'b', 'c'];

    for (index, value) in v.iter().enumerate() {
        println!("{value}는 인덱스 {index}에 있습니다");
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>The code in Listing 19-5 will print the following:</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.52s
     Running `target/debug/patterns`
a는 인덱스 0에 있습니다
b는 인덱스 1에 있습니다
c는 인덱스 2에 있습니다
</code></pre>
<p>We adapt an iterator using the <code>enumerate</code> method so that it produces a value and the index for that value, placed into a tuple. The first value produced is the tuple <code>(0, 'a')</code>. When this value is matched to the pattern <code>(index, value)</code>, index will be <code>0</code> and value will be <code>'a'</code>, printing the first line of the output.</p>
<h3 id="함수-매개변수"><a class="header" href="#함수-매개변수">함수 매개변수</a></h3>
<p>함수 매개변수 또한 패턴이 될 수 있습니다. <code>i32</code> 타입의 <code>x</code>라는 매개변수를 하나 받는 <code>foo</code>라는 함수를 선언하는 목록 19-6의 코드는 이제 익숙해 보일 것입니다.</p>
<Listing number="19-6" caption="A function signature using patterns in the parameters">
<pre><pre class="playground"><code class="language-rust edition2024">fn foo(x: i32) {
    // 코드가 여기에 들어갑니다
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p><code>x</code> 부분이 바로 패턴입니다! <code>let</code>에서 했던 것처럼, 함수의 인수에서 튜플을 패턴에 매칭할 수 있습니다. 목록 19-7은 튜플을 함수에 전달할 때 그 안의 값들을 쪼개어 받습니다.</p>
<Listing number="19-7" file-name="src/main.rs" caption="A function with parameters that destructure a tuple">
<pre><pre class="playground"><code class="language-rust edition2024">fn print_coordinates(&amp;(x, y): &amp;(i32, i32)) {
    println!("현재 위치: ({x}, {y})");
}

fn main() {
    let point = (3, 5);
    print_coordinates(&amp;point);
}</code></pre></pre>
</Listing>
<p>이 코드는 <code>현재 위치: (3, 5)</code>를 출력합니다. 값 <code>&amp;(3, 5)</code>가 패턴 <code>&amp;(x, y)</code>와 매치되므로, <code>x</code>는 <code>3</code>이 되고 <code>y</code>는 <code>5</code>가 됩니다.</p>
<p>We can also use patterns in closure parameter lists in the same way as in function parameter lists because closures are similar to functions, as discussed in Chapter 13.</p>
<p>At this point, you’ve seen several ways to use patterns, but patterns don’t work the same in every place we can use them. In some places, the patterns must be irrefutable; in other circumstances, they can be refutable. We’ll discuss these two concepts next.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch19-00-patterns.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch19-02-refutability.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch19-00-patterns.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch19-02-refutability.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
