<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>임의의 수의 Future와 작업하기 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch17-03-more-futures.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch17-03-more-futures.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Old headings. Do not remove or links may break. -->
<p><a id="yielding"></a></p>
<h3 id="런타임에-제어권-양보하기"><a class="header" href="#런타임에-제어권-양보하기">런타임에 제어권 양보하기</a></h3>
<p>Recall from the <a href="ch17-01-futures-and-syntax.html#our-first-async-program">“Our First Async Program”</a><!-- ignore --> section that at each await point, Rust gives a runtime a chance to pause the task and switch to another one if the future being awaited isn’t ready. The inverse is also true: Rust <em>only</em> pauses async blocks and hands control back to a runtime at an await point. Everything between await points is synchronous.</p>
<p>이는 만약 여러분이 await 지점이 없는 비동기 블록에서 많은 작업을 수행한다면, 해당 퓨처가 다른 모든 퓨처의 진행을 차단하게 됨을 의미합니다. 때때로 이를 한 퓨처가 다른 퓨처를 <em>굶주리게(starving)</em> 한다고 표현하기도 합니다. 어떤 경우에는 큰 문제가 아닐 수도 있습니다. 하지만 비용이 많이 드는 설정이나 오래 걸리는 작업을 수행하거나, 특정 작업을 무기한 계속하는 퓨처가 있는 경우라면, 언제 어디서 런타임에 제어권을 넘겨줄지 생각해야 합니다.</p>
<p>Let’s simulate a long-running operation to illustrate the starvation problem, then explore how to solve it. Listing 17-14 introduces a <code>slow</code> function.</p>
<Listing number="17-14" caption="Using `thread::sleep` to simulate slow operations" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span><span class="boring">        // 나중에 여기서 `slow`를 호출할 것입니다
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span>fn slow(name: &amp;str, ms: u64) {
    thread::sleep(Duration::from_millis(ms));
    println!("' {name}'이 {ms}ms 동안 실행되었습니다");
}</code></pre></pre>
</Listing>
<p>이 코드는 <code>trpl::sleep</code> 대신 <code>std::thread::sleep</code>을 사용하여 <code>slow</code>를 호출할 때 현재 스레드가 수 밀리초 동안 차단되도록 합니다. 우리는 <code>slow</code>를 사용하여 실행 시간이 길고 차단되는 실제 작업을 대신할 수 있습니다.</p>
<p>In Listing 17-15, we use <code>slow</code> to emulate doing this kind of CPU-bound work in a pair of futures.</p>
<Listing number="17-15" caption="Calling the `slow` function to simulate slow operations" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span>        let a = async {
            println!("'a'가 시작되었습니다.");
            slow("a", 30);
            slow("a", 10);
            slow("a", 20);
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'a'가 끝났습니다.");
        };

        let b = async {
            println!("'b'가 시작되었습니다.");
            slow("b", 75);
            slow("b", 10);
            slow("b", 15);
            slow("b", 350);
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'b' 완료됨.");
        };

        trpl::select(a, b).await;
<span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn slow(name: &amp;str, ms: u64) {
</span><span class="boring">    thread::sleep(Duration::from_millis(ms));
</span><span class="boring">    println!("' {name}'이 {ms}ms 동안 실행되었습니다");
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>Each future hands control back to the runtime only <em>after</em> carrying out a bunch of slow operations. If you run this code, you will see this output:</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-15/
cargo run
copy just the output
-->
<pre><code class="language-text">'a' started.
'a' ran for 30ms
'a' ran for 10ms
'a' ran for 20ms
'b' started.
'b' ran for 75ms
'b' ran for 10ms
'b' ran for 15ms
'b' ran for 350ms
'a' finished.
</code></pre>
<p>As with Listing 17-5 where we used <code>trpl::select</code> to race futures fetching two URLs, <code>select</code> still finishes as soon as <code>a</code> is done. There’s no interleaving between the calls to <code>slow</code> in the two futures, though. The <code>a</code> future does all of its work until the <code>trpl::sleep</code> call is awaited, then the <code>b</code> future does all of its work until its own <code>trpl::sleep</code> call is awaited, and finally the <code>a</code> future completes. To allow both futures to make progress between their slow tasks, we need await points so we can hand control back to the runtime. That means we need something we can await!</p>
<p>We can already see this kind of handoff happening in Listing 17-15: if we removed the <code>trpl::sleep</code> at the end of the <code>a</code> future, it would complete without the <code>b</code> future running <em>at all</em>. Let’s try using the <code>trpl::sleep</code> function as a starting point for letting operations switch off making progress, as shown in Listing 17-16.</p>
<Listing number="17-16" caption="Using `trpl::sleep` to let operations switch off making progress" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span>        let one_ms = Duration::from_millis(1);

        let a = async {
            println!("'a'가 시작되었습니다.");
            slow("a", 30);
            trpl::sleep(one_ms).await;
            slow("a", 10);
            trpl::sleep(one_ms).await;
            slow("a", 20);
            trpl::sleep(one_ms).await;
            println!("'a'가 끝났습니다.");
        };

        let b = async {
            println!("'b'가 시작되었습니다.");
            slow("b", 75);
            trpl::sleep(one_ms).await;
            slow("b", 10);
            trpl::sleep(one_ms).await;
            slow("b", 15);
            trpl::sleep(one_ms).await;
            slow("b", 350);
            trpl::sleep(one_ms).await;
            println!("'b' 완료됨.");
        };
<span class="boring">
</span><span class="boring">        trpl::select(a, b).await;
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn slow(name: &amp;str, ms: u64) {
</span><span class="boring">    thread::sleep(Duration::from_millis(ms));
</span><span class="boring">    println!("' {name}'이 {ms}ms 동안 실행되었습니다");
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>We’ve added <code>trpl::sleep</code> calls with await points between each call to <code>slow</code>. Now the two futures’ work is interleaved:</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-16
cargo run
copy just the output
-->
<pre><code class="language-text">'a' started.
'a' ran for 30ms
'b' started.
'b' ran for 75ms
'a' ran for 10ms
'b' ran for 10ms
'a' ran for 20ms
'b' ran for 15ms
'a' finished.
</code></pre>
<p><code>a</code> 퓨처는 <code>trpl::sleep</code>을 호출하기 전에 <code>slow</code>를 호출하므로 제어권을 <code>b</code>에 넘겨주기 전까지 잠시 동안 실행되지만, 그 이후로는 한 퓨처가 await 지점에 도달할 때마다 두 퓨처가 번갈아 가며 실행됩니다. 이 경우에는 모든 <code>slow</code> 호출 뒤에 그렇게 했지만, 우리에게 가장 적합한 방식으로 작업을 나눌 수 있습니다.<code>a</code> 퓨처는 <code>trpl::sleep</code>을 호출하기 전에 <code>slow</code>를 호출하므로 제어권을 <code>b</code>에 넘겨주기 전까지 잠시 동안 실행되지만, 그 이후로는 한 퓨처가 await 지점에 도달할 때마다 두 퓨처가 번갈아 가며 실행됩니다. 이 경우에는 모든 <code>slow</code> 호출 뒤에 그렇게 했지만, 우리에게 가장 적합한 방식으로 작업을 나눌 수 있습니다.</p>
<p>We don’t really want to <em>sleep</em> here, though: we want to make progress as fast as we can. We just need to hand back control to the runtime. We can do that directly, using the <code>trpl::yield_now</code> function. In Listing 17-17, we replace all those <code>trpl::sleep</code> calls with <code>trpl::yield_now</code>.</p>
<Listing number="17-17" caption="Using `yield_now` to let operations switch off making progress" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span>        let a = async {
            println!("'a'가 시작되었습니다.");
            slow("a", 30);
            trpl::yield_now().await;
            slow("a", 10);
            trpl::yield_now().await;
            slow("a", 20);
            trpl::yield_now().await;
            println!("'a'가 끝났습니다.");
        };

        let b = async {
            println!("'b'가 시작되었습니다.");
            slow("b", 75);
            trpl::yield_now().await;
            slow("b", 10);
            trpl::yield_now().await;
            slow("b", 15);
            trpl::yield_now().await;
            slow("b", 350);
            trpl::yield_now().await;
            println!("'b' 완료됨.");
        };
<span class="boring">
</span><span class="boring">        trpl::select(a, b).await;
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn slow(name: &amp;str, ms: u64) {
</span><span class="boring">    thread::sleep(Duration::from_millis(ms));
</span><span class="boring">    println!("' {name}'이 {ms}ms 동안 실행되었습니다");
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 코드는 실제 의도를 더 명확하게 나타낼 뿐만 아니라, <code>sleep</code>을 사용하는 것보다 상당히 빠를 수 있습니다. 왜냐하면 <code>sleep</code>에서 사용하는 것과 같은 타이머는 종종 정밀도에 한계가 있기 때문입니다. 예를 들어 우리가 사용하는 <code>sleep</code> 버전은 1나노초의 <code>Duration</code>을 전달하더라도 항상 최소 1밀리초 동안 잠을 잡니다. 다시 말하지만, 현대의 컴퓨터는 <em>빠릅니다</em>: 1밀리초 동안 많은 일을 할 수 있습니다!</p>
<p>This means that async can be useful even for compute-bound tasks, depending on what else your program is doing, because it provides a useful tool for structuring the relationships between different parts of the program (but at a cost of the overhead of the async state machine). This is a form of <em>cooperative multitasking</em>, where each future has the power to determine when it hands over control via await points. Each future therefore also has the responsibility to avoid blocking for too long. In some Rust-based embedded operating systems, this is the <em>only</em> kind of multitasking!</p>
<p>물론 실제 코드에서는 모든 줄마다 함수 호출과 await 지점을 교대로 배치하지는 않을 것입니다. 이런 식으로 제어권을 양보하는 것이 상대적으로 비용이 적게 들긴 하지만, 공짜는 아닙니다. 많은 경우 계산 위주의 작업을 나누려고 시도하는 것이 작업을 상당히 느리게 만들 수 있으므로, 때로는 <em>전체적인</em> 성능을 위해 작업이 잠시 차단되도록 두는 것이 더 나을 수도 있습니다. 항상 여러분의 코드가 실제로 성능 병목 현상을 일으키는 부분이 어디인지 측정해 보세요. 하지만 만약 동시적으로 일어날 것이라고 예상했던 많은 작업들이 직렬로 일어나고 있는 것을 보고 있다면, 이러한 근본적인 역학 관계를 염두에 두는 것이 중요합니다!</p>
<h3 id="우리만의-비동기-추상화-구축하기"><a class="header" href="#우리만의-비동기-추상화-구축하기">우리만의 비동기 추상화 구축하기</a></h3>
<p>우리는 또한 퓨처들을 함께 조합하여 새로운 패턴을 만들 수도 있습니다. 예를 들어, 우리가 이미 가지고 있는 비동기 빌딩 블록들로 <code>timeout</code> 함수를 만들 수 있습니다. 작업을 마치면, 그 결과는 더 많은 비동기 추상화를 만드는 데 사용할 수 있는 또 다른 빌딩 블록이 될 것입니다.</p>
<p>Listing 17-18 shows how we would expect this <code>timeout</code> to work with a slow future.</p>
<Listing number="17-18" caption="Using our imagined `timeout` to run a slow operation with a time limit" file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span>        let slow = async {
            trpl::sleep(Duration::from_secs(5)).await;
            "마침내 완료됨"
        };

        match timeout(slow, Duration::from_secs(2)).await {
            Ok(message) =&gt; println!("' {message}'로 성공했습니다"),
            Err(duration) =&gt; {
                println!({}초 후 실패했습니다, duration.as_secs())
            }
        }
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
</Listing>
<p>이를 구현해 봅시다! 시작하기 위해, <code>timeout</code>의 API에 대해 생각해 봅시다:</p>
<ul>
<li>우리가 그것을 기다릴(await) 수 있도록 그 자체로 비동기 함수여야 합니다.</li>
<li>첫 번째 매개변수는 실행할 퓨처여야 합니다. 어떤 퓨처와도 함께 작동할 수 있도록 제네릭으로 만들 수 있습니다.</li>
<li>두 번째 매개변수는 대기할 최대 시간입니다. <code>Duration</code>을 사용하면 <code>trpl::sleep</code>에 전달하기 쉬울 것입니다.</li>
<li>이것은 <code>Result</code>를 반환해야 합니다. 만약 퓨처가 성공적으로 완료되면, <code>Result</code>는 퓨처가 생성한 값과 함께 <code>Ok</code>가 될 것입니다. 만약 타임아웃이 먼저 경과하면, <code>Result</code>는 타임아웃이 대기한 시간과 함께 <code>Err</code>가 될 것입니다.</li>
</ul>
<p>Listing 17-19 shows this declaration.</p>
<!-- This is not tested because it intentionally does not compile. -->
<Listing number="17-19" caption="Defining the signature of `timeout`" file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span><span class="boring">        let slow = async {
</span><span class="boring">            trpl::sleep(Duration::from_secs(5)).await;
</span><span class="boring">            "마침내 완료됨"
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        match timeout(slow, Duration::from_secs(2)).await {
</span><span class="boring">            Ok(message) =&gt; println!("' {message}'로 성공했습니다"),
</span><span class="boring">            Err(duration) =&gt; {
</span><span class="boring">                println!({}초 후 실패했습니다, duration.as_secs())
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span>async fn timeout&lt;F: Future&gt;(
    future_to_try: F,
    max_time: Duration,
) -&gt; Result&lt;F::Output, Duration&gt; {
    // 여기에 우리의 구현이 들어갈 것입니다!
}</code></pre>
</Listing>
<p>That satisfies our goals for the types. Now let’s think about the <em>behavior</em> we need: we want to race the future passed in against the duration. We can use <code>trpl::sleep</code> to make a timer future from the duration, and use <code>trpl::select</code> to run that timer with the future the caller passes in.</p>
<p>In Listing 17-20, we implement <code>timeout</code> by matching on the result of awaiting <code>trpl::select</code>.</p>
<Listing number="17-20" caption="Defining `timeout` with `select` and `sleep`" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>use trpl::Either;

// --생략--

<span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span><span class="boring">        let slow = async {
</span><span class="boring">            trpl::sleep(Duration::from_secs(5)).await;
</span><span class="boring">            "마침내 완료됨"
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        match timeout(slow, Duration::from_secs(2)).await {
</span><span class="boring">            Ok(message) =&gt; println!("' {message}'로 성공했습니다"),
</span><span class="boring">            Err(duration) =&gt; {
</span><span class="boring">                println!({}초 후 실패했습니다, duration.as_secs())
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span>async fn timeout&lt;F: Future&gt;(
    future_to_try: F,
    max_time: Duration,
) -&gt; Result&lt;F::Output, Duration&gt; {
    match trpl::select(future_to_try, trpl::sleep(max_time)).await {
        Either::Left(output) =&gt; Ok(output),
        Either::Right(_) =&gt; Err(max_time),
    }
}</code></pre></pre>
</Listing>
<p>The implementation of <code>trpl::select</code> is not fair: it always polls arguments in the order in which they are passed (other <code>select</code> implementations will randomly choose which argument to poll first). Thus, we pass <code>future_to_try</code> to <code>select</code> first so it gets a chance to complete even if <code>max_time</code> is a very short duration. If <code>future_to_try</code> finishes first, <code>select</code> will return <code>Left</code> with the output from <code>future_to_try</code>. If <code>timer</code> finishes first, <code>select</code> will return <code>Right</code> with the timer’s output of <code>()</code>.</p>
<p>만약 <code>future_to_try</code>가 성공하여 <code>Left(output)</code>을 얻으면, <code>Ok(output)</code>을 반환합니다. 대신 슬립 타이머가 경과하여 <code>Right(())</code>를 얻으면, <code>_</code>로 <code>()</code>를 무시하고 대신 <code>Err(max_time)</code>을 반환합니다.</p>
<p>이로써 우리는 다른 두 비동기 헬퍼로 구축된 작동하는 <code>timeout</code>을 갖게 되었습니다. 코드를 실행하면 타임아웃 후에 실패 모드가 출력될 것입니다.</p>
<pre><code class="language-text">Failed after 2 seconds
</code></pre>
<p>Because futures compose with other futures, you can build really powerful tools using smaller async building blocks. For example, you can use this same approach to combine timeouts with retries, and in turn use those with operations such as network calls (such as those in Listing 17-5).</p>
<p>In practice, you’ll usually work directly with <code>async</code> and <code>await</code>, and secondarily with functions such as <code>select</code> and macros such as the <code>join!</code> macro to control how the outermost futures are executed.</p>
<p>We’ve now seen a number of ways to work with multiple futures at the same time. Up next, we’ll look at how we can work with multiple futures in a sequence over time with <em>streams</em>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch17-02-concurrency-with-async.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch17-04-streams.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch17-02-concurrency-with-async.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch17-04-streams.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
