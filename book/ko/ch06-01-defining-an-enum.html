<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>열거형 정의하기 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch06-01-defining-an-enum.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch06-01-defining-an-enum.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="열거형-정의하기"><a class="header" href="#열거형-정의하기">열거형 정의하기</a></h2>
<p>구조체가 <code>width</code>와 <code>height</code>를 가진 <code>Rectangle</code>처럼 관련 필드와 데이터를 함께 그룹화하는 방법을 제공하는 반면, 열거형은 값이 가능한 값 집합 중 하나라고 말하는 방법을 제공합니다. 예를 들어, <code>Rectangle</code>이 <code>Circle</code>과 <code>Triangle</code>을 포함하는 가능한 도형 집합 중 하나라고 말하고 싶을 수 있습니다. 이를 위해 러스트는 이러한 가능성을 열거형으로 인코딩할 수 있도록 합니다.</p>
<p>코드에서 표현하고 싶은 상황을 살펴보고, 이 경우 열거형이 구조체보다 유용하고 더 적절한 이유를 알아보겠습니다. IP 주소로 작업해야 한다고 가정해 봅시다. 현재 IP 주소에는 두 가지 주요 표준인 버전 4와 버전 6이 사용됩니다. 이들이 우리 프로그램이 접하게 될 IP 주소의 유일한 가능성이므로, 모든 가능한 variant를 _열거_할 수 있으며, 여기서 열거형이라는 이름이 유래합니다.</p>
<p>어떤 IP 주소든 버전 4 또는 버전 6 주소일 수 있지만, 동시에 둘 다일 수는 없습니다. IP 주소의 이러한 속성은 열거형 데이터 구조를 적절하게 만듭니다. 왜냐하면 열거형 값은 오직 하나의 variant만 가질 수 있기 때문입니다. 버전 4와 버전 6 주소 모두 여전히 근본적으로 IP 주소이므로, 어떤 종류의 IP 주소에도 적용되는 상황을 코드가 처리할 때 동일한 타입으로 취급되어야 합니다.</p>
<p>우리는 <code>IpAddrKind</code> 열거형을 정의하고 IP 주소가 될 수 있는 가능한 종류인 <code>V4</code>와 <code>V6</code>를 나열함으로써 이 개념을 코드로 표현할 수 있습니다. 이것들이 열거형의 variant입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021">enum IpAddrKind {
    V4,
    V6,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p><code>IpAddrKind</code>는 이제 코드의 다른 곳에서 사용할 수 있는 사용자 정의 데이터 타입입니다.</p>
<h3 id="열거형-값"><a class="header" href="#열거형-값">열거형 값</a></h3>
<p><code>IpAddrKind</code>의 두 가지 variant 각각의 인스턴스를 다음과 같이 생성할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
<span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p>열거형의 variant는 해당 식별자 아래에 네임스페이스가 지정되며, 두 개를 구분하기 위해 이중 콜론을 사용한다는 점에 유의하세요. 이는 이제 <code>IpAddrKind::V4</code>와 <code>IpAddrKind::V6</code> 두 값 모두 <code>IpAddrKind</code>라는 동일한 타입이기 때문에 유용합니다. 예를 들어, 어떤 <code>IpAddrKind</code>든 받아들이는 함수를 정의할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span>fn route(ip_kind: IpAddrKind) {}</code></pre></pre>
<p>그리고 우리는 이 함수를 두 variant 중 하나로 호출할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span>    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p>열거형을 사용하는 것은 더 많은 장점을 가집니다. IP 주소 타입에 대해 더 생각해 보면, 현재 우리는 실제 IP 주소 _데이터_를 저장할 방법이 없습니다. 우리는 단지 그것이 어떤 _종류_인지 알고 있을 뿐입니다. 5장에서 구조체에 대해 방금 배웠다는 점을 고려하면, 목록 6-1에 표시된 것처럼 구조체로 이 문제를 해결하고 싶을 수도 있습니다.</p>
<Listing number="6-1" caption="Storing the data and `IpAddrKind` variant of an IP address using a `struct`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    enum IpAddrKind {
        V4,
        V6,
    }

    struct IpAddr {
        kind: IpAddrKind,
        address: String,
    }

    let home = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from("127.0.0.1"),
    };

    let loopback = IpAddr {
        kind: IpAddrKind::V6,
        address: String::from("::1"),
    };
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>여기서 우리는 <code>IpAddr</code> 구조체를 정의했습니다. 이 구조체는 두 개의 필드를 가집니다: <code>IpAddrKind</code> 타입의 <code>kind</code> 필드(이전에 정의한 열거형)와 <code>String</code> 타입의 <code>address</code> 필드입니다. 이 구조체의 두 인스턴스가 있습니다. 첫 번째는 <code>home</code>이며, <code>IpAddrKind::V4</code> 값을 <code>kind</code>로 가지고 <code>127.0.0.1</code> 주소 데이터를 연관시킵니다. 두 번째 인스턴스는 <code>loopback</code>입니다. 이것은 <code>IpAddrKind</code>의 다른 variant인 <code>V6</code>를 <code>kind</code> 값으로 가지고 <code>::1</code> 주소를 연관시킵니다. 우리는 <code>kind</code>와 <code>address</code> 값을 함께 묶기 위해 구조체를 사용했으며, 이제 variant는 값과 연관됩니다.</p>
<p>그러나 동일한 개념을 열거형만 사용하여 표현하는 것이 더 간결합니다. 구조체 안에 열거형을 넣는 대신, 각 열거형 variant에 직접 데이터를 넣을 수 있습니다. <code>IpAddr</code> 열거형의 이 새로운 정의는 <code>V4</code>와 <code>V6</code> variant 모두 연관된 <code>String</code> 값을 가질 것이라고 말합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(String),
        V6(String),
    }

    let home = IpAddr::V4(String::from("127.0.0.1"));

    let loopback = IpAddr::V6(String::from("::1"));
<span class="boring">}</span></code></pre></pre>
<p>열거형의 각 variant에 직접 데이터를 첨부하므로, 추가 구조체가 필요 없습니다. 여기서 열거형이 작동하는 또 다른 세부 사항을 더 쉽게 볼 수 있습니다: 우리가 정의하는 각 열거형 variant의 이름은 열거형의 인스턴스를 구성하는 함수도 됩니다. 즉, <code>IpAddr::V4()</code>는 <code>String</code> 인수를 받아 <code>IpAddr</code> 타입의 인스턴스를 반환하는 함수 호출입니다. 열거형을 정의한 결과로 이 생성자 함수가 자동으로 정의됩니다.</p>
<p>구조체 대신 열거형을 사용하는 또 다른 장점은 각 variant가 다른 타입과 양의 연관 데이터를 가질 수 있다는 것입니다. 버전 4 IP 주소는 항상 0에서 255 사이의 값을 가지는 네 개의 숫자 구성 요소를 가질 것입니다. 만약 <code>V4</code> 주소를 네 개의 <code>u8</code> 값으로 저장하면서도 <code>V6</code> 주소를 하나의 <code>String</code> 값으로 표현하고 싶다면, 구조체로는 그렇게 할 수 없을 것입니다. 열거형은 이 경우를 쉽게 처리합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from("::1"));
<span class="boring">}</span></code></pre></pre>
<p>버전 4와 버전 6 IP 주소를 저장하기 위한 여러 가지 데이터 구조 정의 방법을 보여드렸습니다. 그러나 IP 주소를 저장하고 그 종류를 인코딩하는 것이 매우 흔한 일이라서 <a href="../std/net/enum.IpAddr.html">표준 라이브러리에 우리가 사용할 수 있는 정의가 있습니다!</a><!-- ignore --> 표준 라이브러리가 <code>IpAddr</code>를 어떻게 정의하는지 살펴보겠습니다. 우리가 정의하고 사용한 것과 정확히 동일한 열거형과 variant를 가지고 있지만, 각 variant에 대해 다르게 정의된 두 가지 다른 구조체 형태로 주소 데이터를 variant 내부에 포함합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ipv4Addr {
    // --생략--
}

struct Ipv6Addr {
    // --생략--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
<span class="boring">}</span></code></pre></pre>
<p>이 코드는 열거형 variant 안에 문자열, 숫자 타입, 또는 구조체와 같은 어떤 종류의 데이터도 넣을 수 있음을 보여줍니다. 심지어 다른 열거형을 포함할 수도 있습니다! 또한, 표준 라이브러리 타입은 종종 당신이 생각해낼 수 있는 것보다 훨씬 복잡하지 않습니다.</p>
<p>표준 라이브러리에 <code>IpAddr</code>에 대한 정의가 포함되어 있더라도, 표준 라이브러리의 정의를 우리 스코프로 가져오지 않았기 때문에 충돌 없이 우리만의 정의를 생성하고 사용할 수 있다는 점에 유의하세요. 7장에서 타입을 스코프로 가져오는 것에 대해 더 자세히 이야기할 것입니다.</p>
<p>목록 6-2에 있는 열거형의 또 다른 예를 살펴보겠습니다. 이 열거형은 variant에 다양한 타입이 내장되어 있습니다.</p>
<Listing number="6-2" caption="A `Message` enum whose variants each store different amounts and types of values">
<pre><pre class="playground"><code class="language-rust edition2021">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p>이 열거형은 네 가지 다른 타입을 가진 variant를 가집니다:</p>
<ul>
<li><code>Quit</code>은 연관된 데이터가 전혀 없습니다.</li>
<li><code>Move</code>는 구조체처럼 이름 있는 필드를 가집니다.</li>
<li><code>Write</code>는 단일 <code>String</code>을 포함합니다.</li>
<li><code>ChangeColor</code>는 세 개의 <code>i32</code> 값을 포함합니다.</li>
</ul>
<p>목록 6-2와 같은 variant를 가진 열거형을 정의하는 것은 다른 종류의 구조체 정의와 유사합니다. 단, 열거형은 <code>struct</code> 키워드를 사용하지 않고 모든 variant가 <code>Message</code> 타입 아래에 함께 그룹화된다는 점이 다릅니다. 다음 구조체들은 이전 열거형 variant들이 가지고 있는 동일한 데이터를 가질 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct QuitMessage; // 유닛 구조체
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // 튜플 구조체
struct ChangeColorMessage(i32, i32, i32); // 튜플 구조체
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>하지만 각각 고유한 타입을 가진 다른 구조체를 사용한다면, 목록 6-2에 정의된 <code>Message</code> 열거형처럼 단일 타입인 경우만큼 쉽게 이러한 종류의 메시지를 받는 함수를 정의할 수 없을 것입니다.</p>
<p>열거형과 구조체 사이에는 한 가지 더 유사점이 있습니다. <code>impl</code>을 사용하여 구조체에 메서드를 정의할 수 있는 것처럼, 열거형에도 메서드를 정의할 수 있습니다. 다음은 <code>Message</code> 열거형에 정의할 수 있는 <code>call</code>이라는 메서드입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    enum Message {
</span><span class="boring">        Quit,
</span><span class="boring">        Move { x: i32, y: i32 },
</span><span class="boring">        Write(String),
</span><span class="boring">        ChangeColor(i32, i32, i32),
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Message {
        fn call(&amp;self) {
            // 메서드 본문은 여기에 정의됩니다
        }
    }

    let m = Message::Write(String::from("hello"));
    m.call();
<span class="boring">}</span></code></pre></pre>
<p>The body of the method would use <code>self</code> to get the value that we called the method on. In this example, we’ve created a variable <code>m</code> that has the value <code>Message::Write(String::from("hello"))</code>, and that is what <code>self</code> will be in the body of the <code>call</code> method when <code>m.call()</code> runs.</p>
<p>Let’s look at another enum in the standard library that is very common and useful: <code>Option</code>.</p>
<h3 id="option-열거형과-null-값에-대한-이점"><a class="header" href="#option-열거형과-null-값에-대한-이점"><code>Option</code> 열거형과 Null 값에 대한 이점</a></h3>
<p>This section explores a case study of <code>Option</code>, which is another enum defined by the standard library. The <code>Option</code> type encodes the very common scenario in which a value could be something or it could be nothing.</p>
<p>For example, if you request the first item in a non-empty list, you would get a value. If you request the first item in an empty list, you would get nothing. Expressing this concept in terms of the type system means the compiler can check whether you’ve handled all the cases you should be handling; this functionality can prevent bugs that are extremely common in other programming languages.</p>
<p>Programming language design is often thought of in terms of which features you include, but the features you exclude are important too. Rust doesn’t have the null feature that many other languages have. <em>Null</em> is a value that means there is no value there. In languages with null, variables can always be in one of two states: null or not-null.</p>
<p>In his 2009 presentation “Null References: The Billion Dollar Mistake,” Tony Hoare, the inventor of null, has this to say:</p>
<blockquote>
<p>I call it my billion-dollar mistake. At that time, I was designing the first comprehensive type system for references in an object-oriented language. My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn’t resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.</p>
</blockquote>
<p>The problem with null values is that if you try to use a null value as a not-null value, you’ll get an error of some kind. Because this null or not-null property is pervasive, it’s extremely easy to make this kind of error.</p>
<p>However, the concept that null is trying to express is still a useful one: a null is a value that is currently invalid or absent for some reason.</p>
<p>The problem isn’t really with the concept but with the particular implementation. As such, Rust does not have nulls, but it does have an enum that can encode the concept of a value being present or absent. This enum is <code>Option&lt;T&gt;</code>, and it is <a href="../std/option/enum.Option.html">defined by the standard library</a><!-- ignore --> as follows:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    None,
    Some(T),
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>Option&lt;T&gt;</code> enum is so useful that it’s even included in the prelude; you don’t need to bring it into scope explicitly. Its variants are also included in the prelude: you can use <code>Some</code> and <code>None</code> directly without the <code>Option::</code> prefix. The <code>Option&lt;T&gt;</code> enum is still just a regular enum, and <code>Some(T)</code> and <code>None</code> are still variants of type <code>Option&lt;T&gt;</code>.</p>
<p>The <code>&lt;T&gt;</code> syntax is a feature of Rust we haven’t talked about yet. It’s a generic type parameter, and we’ll cover generics in more detail in Chapter 10. For now, all you need to know is that <code>&lt;T&gt;</code> means that the <code>Some</code> variant of the <code>Option</code> enum can hold one piece of data of any type, and that each concrete type that gets used in place of <code>T</code> makes the overall <code>Option&lt;T&gt;</code> type a different type. Here are some examples of using <code>Option</code> values to hold number types and char types:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let some_number = Some(5);
    let some_char = Some('e');

    let absent_number: Option&lt;i32&gt; = None;
<span class="boring">}</span></code></pre></pre>
<p>The type of <code>some_number</code> is <code>Option&lt;i32&gt;</code>. The type of <code>some_char</code> is <code>Option&lt;char&gt;</code>, which is a different type. Rust can infer these types because we’ve specified a value inside the <code>Some</code> variant. For <code>absent_number</code>, Rust requires us to annotate the overall <code>Option</code> type: the compiler can’t infer the type that the corresponding <code>Some</code> variant will hold by looking only at a <code>None</code> value. Here, we tell Rust that we mean for <code>absent_number</code> to be of type <code>Option&lt;i32&gt;</code>.</p>
<p>When we have a <code>Some</code> value, we know that a value is present and the value is held within the <code>Some</code>. When we have a <code>None</code> value, in some sense it means the same thing as null: we don’t have a valid value. So why is having <code>Option&lt;T&gt;</code> any better than having null?</p>
<p>In short, because <code>Option&lt;T&gt;</code> and <code>T</code> (where <code>T</code> can be any type) are different types, the compiler won’t let us use an <code>Option&lt;T&gt;</code> value as if it were definitely a valid value. For example, this code won’t compile, because it’s trying to add an <code>i8</code> to an <code>Option&lt;i8&gt;</code>:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let x: i8 = 5;
    let y: Option&lt;i8&gt; = Some(5);

    let sum = x + y;
<span class="boring">}</span></code></pre>
<p>If we run this code, we get an error message like this one:</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option&lt;i8&gt;` to `i8`
 --&gt; src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option&lt;i8&gt;`
  |
  = help: the trait `Add&lt;Option&lt;i8&gt;&gt;` is not implemented for `i8`
  = help: the following other types implement trait `Add&lt;Rhs&gt;`:
            `&amp;'a i8` implements `Add&lt;i8&gt;`
            `&amp;i8` implements `Add&lt;&amp;i8&gt;`
            `i8` implements `Add&lt;&amp;i8&gt;`
            `i8` implements `Add`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums` (bin "enums") due to 1 previous error
</code></pre>
<p>Intense! In effect, this error message means that Rust doesn’t understand how to add an <code>i8</code> and an <code>Option&lt;i8&gt;</code>, because they’re different types. When we have a value of a type like <code>i8</code> in Rust, the compiler will ensure that we always have a valid value. We can proceed confidently without having to check for null before using that value. Only when we have an <code>Option&lt;i8&gt;</code> (or whatever type of value we’re working with) do we have to worry about possibly not having a value, and the compiler will make sure we handle that case before using the value.</p>
<p>In other words, you have to convert an <code>Option&lt;T&gt;</code> to a <code>T</code> before you can perform <code>T</code> operations with it. Generally, this helps catch one of the most common issues with null: assuming that something isn’t null when it actually is.</p>
<p>Eliminating the risk of incorrectly assuming a not-null value helps you to be more confident in your code. In order to have a value that can possibly be null, you must explicitly opt in by making the type of that value <code>Option&lt;T&gt;</code>. Then, when you use that value, you are required to explicitly handle the case when the value is null. Everywhere that a value has a type that isn’t an <code>Option&lt;T&gt;</code>, you <em>can</em> safely assume that the value isn’t null. This was a deliberate design decision for Rust to limit null’s pervasiveness and increase the safety of Rust code.</p>
<p>So how do you get the <code>T</code> value out of a <code>Some</code> variant when you have a value of type <code>Option&lt;T&gt;</code> so that you can use that value? The <code>Option&lt;T&gt;</code> enum has a large number of methods that are useful in a variety of situations; you can check them out in <a href="../std/option/enum.Option.html">its documentation</a><!-- ignore -->. Becoming familiar with the methods on <code>Option&lt;T&gt;</code> will be extremely useful in your journey with Rust.</p>
<p>In general, in order to use an <code>Option&lt;T&gt;</code> value, you want to have code that will handle each variant. You want some code that will run only when you have a <code>Some(T)</code> value, and this code is allowed to use the inner <code>T</code>. You want some other code to run only if you have a <code>None</code> value, and that code doesn’t have a <code>T</code> value available. The <code>match</code> expression is a control flow construct that does just this when used with enums: it will run different code depending on which variant of the enum it has, and that code can use the data inside the matching value.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch06-00-enums.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch06-02-match.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch06-00-enums.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch06-02-match.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
