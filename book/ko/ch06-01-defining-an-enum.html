<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>열거형 정의하기 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch06-01-defining-an-enum.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch06-01-defining-an-enum.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="열거형-정의하기"><a class="header" href="#열거형-정의하기">열거형 정의하기</a></h2>
<p>구조체가 <code>width</code>와 <code>height</code>를 가진 <code>Rectangle</code>처럼 관련 필드와 데이터를 함께 그룹화하는 방법을 제공하는 반면, 열거형은 값이 가능한 값 집합 중 하나라고 말하는 방법을 제공합니다. 예를 들어, <code>Rectangle</code>이 <code>Circle</code>과 <code>Triangle</code>을 포함하는 가능한 도형 집합 중 하나라고 말하고 싶을 수 있습니다. 이를 위해 러스트는 이러한 가능성을 열거형으로 인코딩할 수 있도록 합니다.</p>
<p>코드에서 표현하고 싶은 상황을 살펴보고, 이 경우 열거형이 구조체보다 유용하고 더 적절한 이유를 알아보겠습니다. IP 주소로 작업해야 한다고 가정해 봅시다. 현재 IP 주소에는 두 가지 주요 표준인 버전 4와 버전 6이 사용됩니다. 이들이 우리 프로그램이 접하게 될 IP 주소의 유일한 가능성이므로, 모든 가능한 variant를 _열거_할 수 있으며, 여기서 열거형이라는 이름이 유래합니다.</p>
<p>어떤 IP 주소든 버전 4 또는 버전 6 주소일 수 있지만, 동시에 둘 다일 수는 없습니다. IP 주소의 이러한 속성은 열거형 데이터 구조를 적절하게 만듭니다. 왜냐하면 열거형 값은 오직 하나의 variant만 가질 수 있기 때문입니다. 버전 4와 버전 6 주소 모두 여전히 근본적으로 IP 주소이므로, 어떤 종류의 IP 주소에도 적용되는 상황을 코드가 처리할 때 동일한 타입으로 취급되어야 합니다.</p>
<p>우리는 <code>IpAddrKind</code> 열거형을 정의하고 IP 주소가 될 수 있는 가능한 종류인 <code>V4</code>와 <code>V6</code>를 나열함으로써 이 개념을 코드로 표현할 수 있습니다. 이것들이 열거형의 variant입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024">enum IpAddrKind {
    V4,
    V6,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p><code>IpAddrKind</code>는 이제 코드의 다른 곳에서 사용할 수 있는 사용자 정의 데이터 타입입니다.</p>
<h3 id="열거형-값"><a class="header" href="#열거형-값">열거형 값</a></h3>
<p><code>IpAddrKind</code>의 두 가지 variant 각각의 인스턴스를 다음과 같이 생성할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
<span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p>열거형의 variant는 해당 식별자 아래에 네임스페이스가 지정되며, 두 개를 구분하기 위해 이중 콜론을 사용한다는 점에 유의하세요. 이는 이제 <code>IpAddrKind::V4</code>와 <code>IpAddrKind::V6</code> 두 값 모두 <code>IpAddrKind</code>라는 동일한 타입이기 때문에 유용합니다. 예를 들어, 어떤 <code>IpAddrKind</code>든 받아들이는 함수를 정의할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span>fn route(ip_kind: IpAddrKind) {}</code></pre></pre>
<p>그리고 우리는 이 함수를 두 variant 중 하나로 호출할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span>    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p>열거형을 사용하는 것은 더 많은 장점을 가집니다. IP 주소 타입에 대해 더 생각해 보면, 현재 우리는 실제 IP 주소 _데이터_를 저장할 방법이 없습니다. 우리는 단지 그것이 어떤 _종류_인지 알고 있을 뿐입니다. 5장에서 구조체에 대해 방금 배웠다는 점을 고려하면, 목록 6-1에 표시된 것처럼 구조체로 이 문제를 해결하고 싶을 수도 있습니다.</p>
<Listing number="6-1" caption="Storing the data and `IpAddrKind` variant of an IP address using a `struct`">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    enum IpAddrKind {
        V4,
        V6,
    }

    struct IpAddr {
        kind: IpAddrKind,
        address: String,
    }

    let home = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from("127.0.0.1"),
    };

    let loopback = IpAddr {
        kind: IpAddrKind::V6,
        address: String::from("::1"),
    };
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>여기서 우리는 <code>IpAddr</code> 구조체를 정의했습니다. 이 구조체는 두 개의 필드를 가집니다: <code>IpAddrKind</code> 타입의 <code>kind</code> 필드(이전에 정의한 열거형)와 <code>String</code> 타입의 <code>address</code> 필드입니다. 이 구조체의 두 인스턴스가 있습니다. 첫 번째는 <code>home</code>이며, <code>IpAddrKind::V4</code> 값을 <code>kind</code>로 가지고 <code>127.0.0.1</code> 주소 데이터를 연관시킵니다. 두 번째 인스턴스는 <code>loopback</code>입니다. 이것은 <code>IpAddrKind</code>의 다른 variant인 <code>V6</code>를 <code>kind</code> 값으로 가지고 <code>::1</code> 주소를 연관시킵니다. 우리는 <code>kind</code>와 <code>address</code> 값을 함께 묶기 위해 구조체를 사용했으며, 이제 variant는 값과 연관됩니다.</p>
<p>However, representing the same concept using just an enum is more concise: Rather than an enum inside a struct, we can put data directly into each enum variant. This new definition of the <code>IpAddr</code> enum says that both <code>V4</code> and <code>V6</code> variants will have associated <code>String</code> values:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(String),
        V6(String),
    }

    let home = IpAddr::V4(String::from("127.0.0.1"));

    let loopback = IpAddr::V6(String::from("::1"));
<span class="boring">}</span></code></pre></pre>
<p>We attach data to each variant of the enum directly, so there is no need for an extra struct. Here, it’s also easier to see another detail of how enums work: The name of each enum variant that we define also becomes a function that constructs an instance of the enum. That is, <code>IpAddr::V4()</code> is a function call that takes a <code>String</code> argument and returns an instance of the <code>IpAddr</code> type. We automatically get this constructor function defined as a result of defining the enum.</p>
<p>There’s another advantage to using an enum rather than a struct: Each variant can have different types and amounts of associated data. Version four IP addresses will always have four numeric components that will have values between 0 and 255. If we wanted to store <code>V4</code> addresses as four <code>u8</code> values but still express <code>V6</code> addresses as one <code>String</code> value, we wouldn’t be able to with a struct. Enums handle this case with ease:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from("::1"));
<span class="boring">}</span></code></pre></pre>
<p>We’ve shown several different ways to define data structures to store version four and version six IP addresses. However, as it turns out, wanting to store IP addresses and encode which kind they are is so common that <a href="../std/net/enum.IpAddr.html">the standard library has a definition we can use!</a><!-- ignore --> Let’s look at how the standard library defines <code>IpAddr</code>. It has the exact enum and variants that we’ve defined and used, but it embeds the address data inside the variants in the form of two different structs, which are defined differently for each variant:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ipv4Addr {
    // --생략--
}

struct Ipv6Addr {
    // --생략--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
<span class="boring">}</span></code></pre></pre>
<p>이 코드는 열거형 variant 안에 문자열, 숫자 타입, 또는 구조체와 같은 어떤 종류의 데이터도 넣을 수 있음을 보여줍니다. 심지어 다른 열거형을 포함할 수도 있습니다! 또한, 표준 라이브러리 타입은 종종 당신이 생각해낼 수 있는 것보다 훨씬 복잡하지 않습니다.</p>
<p>표준 라이브러리에 <code>IpAddr</code>에 대한 정의가 포함되어 있더라도, 표준 라이브러리의 정의를 우리 스코프로 가져오지 않았기 때문에 충돌 없이 우리만의 정의를 생성하고 사용할 수 있다는 점에 유의하세요. 7장에서 타입을 스코프로 가져오는 것에 대해 더 자세히 이야기할 것입니다.</p>
<p>Let’s look at another example of an enum in Listing 6-2: This one has a wide variety of types embedded in its variants.</p>
<Listing number="6-2" caption="A `Message` enum whose variants each store different amounts and types of values">
<pre><pre class="playground"><code class="language-rust edition2024">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p>이 열거형은 네 가지 다른 타입을 가진 variant를 가집니다:</p>
<ul>
<li><code>Quit</code>: Has no data associated with it at all</li>
<li><code>Move</code>: Has named fields, like a struct does</li>
<li><code>Write</code>: Includes a single <code>String</code></li>
<li><code>ChangeColor</code>: Includes three <code>i32</code> values</li>
</ul>
<p>목록 6-2와 같은 variant를 가진 열거형을 정의하는 것은 다른 종류의 구조체 정의와 유사합니다. 단, 열거형은 <code>struct</code> 키워드를 사용하지 않고 모든 variant가 <code>Message</code> 타입 아래에 함께 그룹화된다는 점이 다릅니다. 다음 구조체들은 이전 열거형 variant들이 가지고 있는 동일한 데이터를 가질 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024">struct QuitMessage; // 유닛 구조체
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // 튜플 구조체
struct ChangeColorMessage(i32, i32, i32); // 튜플 구조체
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>하지만 각각 고유한 타입을 가진 다른 구조체를 사용한다면, 목록 6-2에 정의된 <code>Message</code> 열거형처럼 단일 타입인 경우만큼 쉽게 이러한 종류의 메시지를 받는 함수를 정의할 수 없을 것입니다.</p>
<p>There is one more similarity between enums and structs: Just as we’re able to define methods on structs using <code>impl</code>, we’re also able to define methods on enums. Here’s a method named <code>call</code> that we could define on our <code>Message</code> enum:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    enum Message {
</span><span class="boring">        Quit,
</span><span class="boring">        Move { x: i32, y: i32 },
</span><span class="boring">        Write(String),
</span><span class="boring">        ChangeColor(i32, i32, i32),
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Message {
        fn call(&amp;self) {
            // 메서드 본문은 여기에 정의됩니다
        }
    }

    let m = Message::Write(String::from("hello"));
    m.call();
<span class="boring">}</span></code></pre></pre>
<p>메서드의 본문은 <code>self</code>를 사용하여 메서드가 호출된 값을 가져옵니다. 이 예제에서 우리는 <code>Message::Write(String::from("hello"))</code> 값을 가진 변수 <code>m</code>을 생성했으며, 이는 <code>m.call()</code>이 실행될 때 <code>call</code> 메서드 본문의 <code>self</code>가 됩니다.</p>
<p>표준 라이브러리에서 매우 흔하고 유용한 또 다른 열거형인 <code>Option</code>을 살펴보겠습니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="the-option-enum-and-its-advantages-over-null-values"></a></p>
<h3 id="the-option-enum"><a class="header" href="#the-option-enum">The <code>Option</code> Enum</a></h3>
<p>This section explores a case study of <code>Option</code>, which is another enum defined by the standard library. The <code>Option</code> type encodes the very common scenario in which a value could be something, or it could be nothing.</p>
<p>예를 들어, 비어 있지 않은 목록에서 첫 번째 항목을 요청하면 값을 얻게 됩니다. 비어 있는 목록에서 첫 번째 항목을 요청하면 아무것도 얻지 못합니다. 이 개념을 타입 시스템 측면에서 표현한다는 것은 컴파일러가 여러분이 처리해야 할 모든 사례를 처리했는지 확인할 수 있음을 의미합니다. 이 기능은 다른 프로그래밍 언어에서 매우 흔한 버그를 방지할 수 있습니다.</p>
<p>프로그래밍 언어 설계는 종종 어떤 기능을 포함하느냐의 관점에서 생각되지만, 제외하는 기능도 중요합니다. 러스트에는 다른 많은 언어들이 가지고 있는 null 기능이 없습니다. _Null_은 그곳에 값이 없음을 의미하는 값입니다. null이 있는 언어에서 변수는 항상 null 또는 null이 아님이라는 두 가지 상태 중 하나에 있을 수 있습니다.</p>
<p>In his 2009 presentation “Null References: The Billion Dollar Mistake,” Tony Hoare, the inventor of null, had this to say:</p>
<blockquote>
<p>나는 그것을 나의 10억 달러짜리 실수라고 부릅니다. 그 당시 나는 객체 지향 언어의 참조를 위한 최초의 포괄적인 타입 시스템을 설계하고 있었습니다. 나의 목표는 컴파일러에 의해 자동으로 수행되는 검사를 통해 모든 참조 사용이 절대적으로 안전함을 보장하는 것이었습니다. 하지만 나는 단지 구현하기가 너무 쉽다는 이유만으로 null 참조를 넣고 싶은 유혹을 떨쳐낼 수 없었습니다. 이것은 지난 40년 동안 아마도 10억 달러의 고통과 피해를 초래했을 수많은 오류, 취약점 및 시스템 크래시로 이어졌습니다.</p>
</blockquote>
<p>null 값의 문제는 null 값을 null이 아닌 값처럼 사용하려고 하면 어떤 종류의 오류가 발생한다는 것입니다. 이 null 또는 null이 아님 속성은 어디에나 존재하기 때문에 이러한 종류의 실수를 저지르기가 매우 쉽습니다.</p>
<p>However, the concept that null is trying to express is still a useful one: A null is a value that is currently invalid or absent for some reason.</p>
<p>문제는 개념 자체가 아니라 특정 구현에 있습니다. 따라서 러스트에는 null이 없지만, 값이 있거나 없는 개념을 인코딩할 수 있는 열거형이 있습니다. 이 열거형은 <code>Option&lt;T&gt;</code>이며, <a href="../std/option/enum.Option.html">표준 라이브러리에 의해 정의</a><!-- ignore -->된 내용은 다음과 같습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    None,
    Some(T),
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>Option&lt;T&gt;</code> enum is so useful that it’s even included in the prelude; you don’t need to bring it into scope explicitly. Its variants are also included in the prelude: You can use <code>Some</code> and <code>None</code> directly without the <code>Option::</code> prefix. The <code>Option&lt;T&gt;</code> enum is still just a regular enum, and <code>Some(T)</code> and <code>None</code> are still variants of type <code>Option&lt;T&gt;</code>.</p>
<p><code>&lt;T&gt;</code> 구문은 우리가 아직 이야기하지 않은 러스트의 기능입니다. 이는 제네릭 타입 매개변수이며, 10장에서 제네릭에 대해 더 자세히 다룰 것입니다. 지금은 <code>&lt;T&gt;</code>가 <code>Option</code> 열거형의 <code>Some</code> variant가 어떤 타입의 데이터라도 하나 가질 수 있음을 의미하며, <code>T</code> 자리에 사용되는 각 구체적인 타입이 전체 <code>Option&lt;T&gt;</code> 타입을 서로 다른 타입으로 만든다는 것만 알면 됩니다. 다음은 숫자 타입과 문자 타입을 담기 위해 <code>Option</code> 값을 사용하는 몇 가지 예입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let some_number = Some(5);
    let some_char = Some('e');

    let absent_number: Option&lt;i32&gt; = None;
<span class="boring">}</span></code></pre></pre>
<p>The type of <code>some_number</code> is <code>Option&lt;i32&gt;</code>. The type of <code>some_char</code> is <code>Option&lt;char&gt;</code>, which is a different type. Rust can infer these types because we’ve specified a value inside the <code>Some</code> variant. For <code>absent_number</code>, Rust requires us to annotate the overall <code>Option</code> type: The compiler can’t infer the type that the corresponding <code>Some</code> variant will hold by looking only at a <code>None</code> value. Here, we tell Rust that we mean for <code>absent_number</code> to be of type <code>Option&lt;i32&gt;</code>.</p>
<p>When we have a <code>Some</code> value, we know that a value is present, and the value is held within the <code>Some</code>. When we have a <code>None</code> value, in some sense it means the same thing as null: We don’t have a valid value. So, why is having <code>Option&lt;T&gt;</code> any better than having null?</p>
<p>요컨대, <code>Option&lt;T&gt;</code>와 <code>T</code>(<code>T</code>는 어떤 타입이든 될 수 있음)는 서로 다른 타입이기 때문에, 컴파일러는 <code>Option&lt;T&gt;</code> 값을 마치 확실히 유효한 값인 것처럼 사용하도록 내버려 두지 않습니다. 예를 들어, 다음 코드는 <code>i8</code>에 <code>Option&lt;i8&gt;</code>을 더하려 하기 때문에 컴파일되지 않습니다.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let x: i8 = 5;
    let y: Option&lt;i8&gt; = Some(5);

    let sum = x + y;
<span class="boring">}</span></code></pre>
<p>이 코드를 실행하면 다음과 같은 오류 메시지가 발생합니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option&lt;i8&gt;` to `i8`
 --&gt; src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option&lt;i8&gt;`
  |
  = help: the trait `Add&lt;Option&lt;i8&gt;&gt;` is not implemented for `i8`
  = help: the following other types implement trait `Add&lt;Rhs&gt;`:
            `&amp;i8` implements `Add&lt;i8&gt;`
            `&amp;i8` implements `Add`
            `i8` implements `Add&lt;&amp;i8&gt;`
            `i8` implements `Add`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums` (bin "enums") due to 1 previous error
</code></pre>
<p>강렬하군요! 사실상 이 오류 메시지는 러스트가 <code>i8</code>과 <code>Option&lt;i8&gt;</code>을 더하는 방법을 이해하지 못한다는 것을 의미합니다. 둘은 서로 다른 타입이기 때문이죠. 러스트에서 <code>i8</code>과 같은 타입의 값을 가질 때, 컴파일러는 우리가 항상 유효한 값을 갖고 있음을 보장할 것입니다. 우리는 그 값을 사용하기 전에 null 체크를 할 필요 없이 자신 있게 진행할 수 있습니다. 오직 <code>Option&lt;i8&gt;</code>(또는 우리가 작업 중인 어떤 타입의 값이든)을 가질 때만 값이 없을 가능성에 대해 걱정해야 하며, 컴파일러는 우리가 그 값을 사용하기 전에 해당 케이스를 처리하도록 보장할 것입니다.</p>
<p>즉, <code>T</code>에 대한 연산을 수행하기 전에 <code>Option&lt;T&gt;</code>를 <code>T</code>로 변환해야 합니다. 일반적으로 이는 null과 관련된 가장 흔한 문제 중 하나인, 실제로는 null인데 null이 아니라고 가정하는 문제를 잡아내는 데 도움이 됩니다.</p>
<p>Eliminating the risk of incorrectly assuming a not-null value helps you be more confident in your code. In order to have a value that can possibly be null, you must explicitly opt in by making the type of that value <code>Option&lt;T&gt;</code>. Then, when you use that value, you are required to explicitly handle the case when the value is null. Everywhere that a value has a type that isn’t an <code>Option&lt;T&gt;</code>, you <em>can</em> safely assume that the value isn’t null. This was a deliberate design decision for Rust to limit null’s pervasiveness and increase the safety of Rust code.</p>
<p>그렇다면 <code>Option&lt;T&gt;</code> 타입의 값을 가질 때, 그 값을 사용하기 위해 <code>Some</code> variant에서 <code>T</code> 값을 어떻게 꺼낼까요? <code>Option&lt;T&gt;</code> 열거형은 다양한 상황에서 유용한 많은 메서드를 가지고 있습니다. <a href="../std/option/enum.Option.html">문서</a><!-- ignore -->에서 확인해 보세요. <code>Option&lt;T&gt;</code>의 메서드들에 익숙해지는 것은 여러분의 러스트 여정에 매우 유용할 것입니다.</p>
<p>In general, in order to use an <code>Option&lt;T&gt;</code> value, you want to have code that will handle each variant. You want some code that will run only when you have a <code>Some(T)</code> value, and this code is allowed to use the inner <code>T</code>. You want some other code to run only if you have a <code>None</code> value, and that code doesn’t have a <code>T</code> value available. The <code>match</code> expression is a control flow construct that does just this when used with enums: It will run different code depending on which variant of the enum it has, and that code can use the data inside the matching value.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch06-00-enums.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch06-02-match.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch06-00-enums.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch06-02-match.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
