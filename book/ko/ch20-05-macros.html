<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>매크로 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch20-05-macros.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch20-05-macros.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="매크로"><a class="header" href="#매크로">매크로</a></h2>
<p>We’ve used macros like <code>println!</code> throughout this book, but we haven’t fully explored what a macro is and how it works. The term <em>macro</em> refers to a family of features in Rust—declarative macros with <code>macro_rules!</code> and three kinds of procedural macros:</p>
<ul>
<li>구조체와 열거형에 사용되는 <code>derive</code> 속성으로 추가되는 코드를 지정하는 커스텀 <code>#[derive]</code> 매크로</li>
<li>모든 아이템에 사용할 수 있는 커스텀 속성을 정의하는 속성형(Attribute-like) 매크로</li>
<li>함수 호출처럼 보이지만 인수로 지정된 토큰들에 대해 작동하는 함수형(Function-like) 매크로</li>
</ul>
<p>이들 각각에 대해 차례로 살펴보겠지만, 먼저 이미 함수가 있는데 왜 매크로가 필요한지에 대해 알아보겠습니다.</p>
<h3 id="매크로와-함수의-차이점"><a class="header" href="#매크로와-함수의-차이점">매크로와 함수의 차이점</a></h3>
<p>근본적으로 매크로는 다른 코드를 작성하는 코드를 작성하는 방식이며, 이를 _메타프로그래밍(metaprogramming)_이라고 합니다. 부록 C에서는 여러분을 위해 다양한 트레이트의 구현을 생성해 주는 <code>derive</code> 속성에 대해 논의합니다. 우리는 또한 책 전반에 걸쳐 <code>println!</code>과 <code>vec!</code> 매크로를 사용해 왔습니다. 이 모든 매크로들은 여러분이 수동으로 작성한 코드보다 더 많은 코드를 생성하기 위해 _확장(expand)_됩니다.</p>
<p>Metaprogramming is useful for reducing the amount of code you have to write and maintain, which is also one of the roles of functions. However, macros have some additional powers that functions don’t have.</p>
<p>A function signature must declare the number and type of parameters the function has. Macros, on the other hand, can take a variable number of parameters: We can call <code>println!("hello")</code> with one argument or <code>println!("hello {}", name)</code> with two arguments. Also, macros are expanded before the compiler interprets the meaning of the code, so a macro can, for example, implement a trait on a given type. A function can’t, because it gets called at runtime and a trait needs to be implemented at compile time.</p>
<p>함수 대신 매크로를 구현할 때의 단점은 매크로 정의가 함수 정의보다 더 복잡하다는 것입니다. 여러분은 러스트 코드를 작성하는 러스트 코드를 작성하고 있기 때문입니다. 이러한 간접성 때문에 매크로 정의는 일반적으로 함수 정의보다 읽고, 이해하고, 유지 관리하기가 더 어렵습니다.</p>
<p>매크로와 함수의 또 다른 중요한 차이점은, 함수는 어디서든 정의하고 어디서든 호출할 수 있는 반면, 매크로는 파일에서 호출하기 <em>전에</em> 정의하거나 스코프로 가져와야 한다는 점입니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="declarative-macros-with-macro_rules-for-general-metaprogramming"></a></p>
<h3 id="declarative-macros-for-general-metaprogramming"><a class="header" href="#declarative-macros-for-general-metaprogramming">Declarative Macros for General Metaprogramming</a></h3>
<p>The most widely used form of macros in Rust is the <em>declarative macro</em>. These are also sometimes referred to as “macros by example,” “<code>macro_rules!</code> macros,” or just plain “macros.” At their core, declarative macros allow you to write something similar to a Rust <code>match</code> expression. As discussed in Chapter 6, <code>match</code> expressions are control structures that take an expression, compare the resultant value of the expression to patterns, and then run the code associated with the matching pattern. Macros also compare a value to patterns that are associated with particular code: In this situation, the value is the literal Rust source code passed to the macro; the patterns are compared with the structure of that source code; and the code associated with each pattern, when matched, replaces the code passed to the macro. This all happens during compilation.</p>
<p>매크로를 정의하려면 <code>macro_rules!</code> 구문을 사용합니다. <code>vec!</code> 매크로가 어떻게 정의되어 있는지 살펴보면서 <code>macro_rules!</code>의 사용법을 탐구해 보겠습니다. 8장에서는 특정 값들을 가진 새로운 벡터를 생성하기 위해 <code>vec!</code> 매크로를 사용하는 방법을 다루었습니다. 예를 들어, 다음 매크로는 세 개의 정수를 포함하는 새로운 벡터를 생성합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;u32&gt; = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<p>우리는 또한 <code>vec!</code> 매크로를 사용하여 두 개의 정수를 가진 벡터나 다섯 개의 문자열 슬라이스를 가진 벡터를 만들 수도 있습니다. 값의 개수나 타입을 미리 알 수 없기 때문에 함수로는 이와 같은 일을 할 수 없습니다.</p>
<p>Listing 20-35 shows a slightly simplified definition of the <code>vec!</code> macro.</p>
<Listing number="20-35" file-name="src/lib.rs" caption="A simplified version of the `vec!` macro definition">
<pre><code class="language-rust noplayground">#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}</code></pre>
</Listing>
<blockquote>
<p>Note: The actual definition of the <code>vec!</code> macro in the standard library includes code to pre-allocate the correct amount of memory up front. That code is an optimization that we don’t include here, to make the example simpler.</p>
</blockquote>
<p><code>#[macro_export]</code> 어노테이션은 이 매크로가 정의된 크레이트가 스코프로 들어올 때마다 이 매크로를 사용할 수 있도록 해야 함을 나타냅니다. 이 어노테이션이 없으면 매크로를 스코프로 가져올 수 없습니다.</p>
<p>그런 다음 <code>macro_rules!</code>와 정의하려는 매크로의 이름을 느낌표 <em>없이</em> 사용하여 매크로 정의를 시작합니다. 이 경우 이름은 <code>vec</code>이며, 매크로 정의의 본문을 나타내는 중괄호가 뒤따릅니다.</p>
<p><code>vec!</code> 본문의 구조는 <code>match</code> 표현식의 구조와 유사합니다. 여기서는 <code>( $( $x:expr ),* )</code> 패턴을 가진 하나의 암(arm)이 있고, 그 뒤에 <code>=&gt;</code>와 이 패턴에 연관된 코드 블록이 옵니다. 패턴이 일치하면 연관된 코드 블록이 생성됩니다. 이 매크로에는 패턴이 하나뿐이므로 일치하는 유효한 방법도 하나뿐입니다. 다른 패턴은 에러를 발생시킬 것입니다. 더 복잡한 매크로는 두 개 이상의 암을 가질 것입니다.</p>
<p>Valid pattern syntax in macro definitions is different from the pattern syntax covered in Chapter 19 because macro patterns are matched against Rust code structure rather than values. Let’s walk through what the pattern pieces in Listing 20-29 mean; for the full macro pattern syntax, see the <a href="../reference/macros-by-example.html">Rust Reference</a>.</p>
<p>먼저, 전체 패턴을 감싸기 위해 한 쌍의 소괄호를 사용합니다. 패턴과 일치하는 러스트 코드를 담을 변수를 매크로 시스템에 선언하기 위해 달러 기호(<code>$</code>)를 사용합니다. 달러 기호는 이것이 일반적인 러스트 변수가 아니라 매크로 변수임을 명확히 해줍니다. 다음으로 대체 코드에서 사용할 수 있도록 소괄호 안의 패턴과 일치하는 값들을 캡처하는 소괄호 쌍이 옵니다. <code>$()</code> 안에는 어떤 러스트 표현식과도 일치하고 그 표현식에 <code>$x</code>라는 이름을 부여하는 <code>$x:expr</code>이 있습니다.</p>
<p>The comma following <code>$()</code> indicates that a literal comma separator character must appear between each instance of the code that matches the code in <code>$()</code>. The <code>*</code> specifies that the pattern matches zero or more of whatever precedes the <code>*</code>.</p>
<p><code>vec![1, 2, 3];</code>으로 이 매크로를 호출하면, <code>$x</code> 패턴은 세 개의 표현식 <code>1</code>, <code>2</code>, <code>3</code>에 대해 세 번 일치하게 됩니다.</p>
<p>이제 이 암과 연관된 코드 본문의 패턴을 살펴보겠습니다. <code>$()*</code> 안의 <code>temp_vec.push()</code>는 패턴이 몇 번 일치하느냐에 따라 패턴의 <code>$()</code>와 일치하는 각 부분에 대해 0번 이상 생성됩니다. <code>$x</code>는 일치하는 각 표현식으로 대체됩니다. <code>vec![1, 2, 3];</code>으로 이 매크로를 호출하면, 이 매크로 호출을 대체하여 생성되는 코드는 다음과 같습니다.</p>
<pre><code class="language-rust ignore">{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}</code></pre>
<p>우리는 임의의 타입의 인수를 몇 개든 받을 수 있고, 지정된 요소들을 포함하는 벡터를 생성하는 코드를 만들어낼 수 있는 매크로를 정의했습니다.</p>
<p>매크로를 작성하는 방법에 대해 더 알고 싶다면, 온라인 문서나 다니엘 킵(Daniel Keep)이 시작하고 루카스 비르트(Lukas Wirth)가 이어받은 <a href="https://veykril.github.io/tlborm/">“The Little Book of Rust Macros”</a>와 같은 다른 리소스들을 참고하세요.</p>
<h3 id="속성으로부터-코드를-생성하는-절차적-매크로"><a class="header" href="#속성으로부터-코드를-생성하는-절차적-매크로">속성으로부터 코드를 생성하는 절차적 매크로</a></h3>
<p>The second form of macros is the procedural macro, which acts more like a function (and is a type of procedure). <em>Procedural macros</em> accept some code as an input, operate on that code, and produce some code as an output rather than matching against patterns and replacing the code with other code as declarative macros do. The three kinds of procedural macros are custom <code>derive</code>, attribute-like, and function-like, and all work in a similar fashion.</p>
<p>When creating procedural macros, the definitions must reside in their own crate with a special crate type. This is for complex technical reasons that we hope to eliminate in the future. In Listing 20-36, we show how to define a procedural macro, where <code>some_attribute</code> is a placeholder for using a specific macro variety.</p>
<Listing number="20-36" file-name="src/lib.rs" caption="An example of defining a procedural macro">
<pre><code class="language-rust ignore">use proc_macro::TokenStream;

#[some_attribute]
pub fn some_name(input: TokenStream) -&gt; TokenStream {
}</code></pre>
</Listing>
<p>The function that defines a procedural macro takes a <code>TokenStream</code> as an input and produces a <code>TokenStream</code> as an output. The <code>TokenStream</code> type is defined by the <code>proc_macro</code> crate that is included with Rust and represents a sequence of tokens. This is the core of the macro: The source code that the macro is operating on makes up the input <code>TokenStream</code>, and the code the macro produces is the output <code>TokenStream</code>. The function also has an attribute attached to it that specifies which kind of procedural macro we’re creating. We can have multiple kinds of procedural macros in the same crate.</p>
<p>Let’s look at the different kinds of procedural macros. We’ll start with a custom <code>derive</code> macro and then explain the small dissimilarities that make the other forms different.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="how-to-write-a-custom-derive-macro"></a></p>
<h3 id="custom-derive-macros"><a class="header" href="#custom-derive-macros">Custom <code>derive</code> Macros</a></h3>
<p>Let’s create a crate named <code>hello_macro</code> that defines a trait named <code>HelloMacro</code> with one associated function named <code>hello_macro</code>. Rather than making our users implement the <code>HelloMacro</code> trait for each of their types, we’ll provide a procedural macro so that users can annotate their type with <code>#[derive(HelloMacro)]</code> to get a default implementation of the <code>hello_macro</code> function. The default implementation will print <code>Hello, Macro! My name is TypeName!</code> where <code>TypeName</code> is the name of the type on which this trait has been defined. In other words, we’ll write a crate that enables another programmer to write code like Listing 20-37 using our crate.</p>
<Listing number="20-37" file-name="src/main.rs" caption="The code a user of our crate will be able to write when using our procedural macro">
<pre><code class="language-rust ignore does_not_compile">use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}</code></pre>
</Listing>
<p>작업이 완료되면 이 코드는 <code>Hello, Macro! My name is Pancakes!</code>를 출력할 것입니다. 첫 번째 단계는 다음과 같이 새로운 라이브러리 크레이트를 만드는 것입니다.</p>
<pre><code class="language-console">$ cargo new hello_macro --lib
</code></pre>
<p>Next, in Listing 20-38, we’ll define the <code>HelloMacro</code> trait and its associated function.</p>
<Listing file-name="src/lib.rs" number="20-38" caption="A simple trait that we will use with the `derive` macro">
<pre><code class="language-rust noplayground">pub trait HelloMacro {
    fn hello_macro();
}</code></pre>
</Listing>
<p>We have a trait and its function. At this point, our crate user could implement the trait to achieve the desired functionality, as in Listing 20-39.</p>
<Listing number="20-39" file-name="src/main.rs" caption="How it would look if users wrote a manual implementation of the `HelloMacro` trait">
<pre><code class="language-rust ignore">use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!("Hello, Macro! My name is Pancakes!");
    }
}

fn main() {
    Pancakes::hello_macro();
}</code></pre>
</Listing>
<p>하지만 사용자는 <code>hello_macro</code>를 사용하려는 각 타입에 대해 구현 블록을 작성해야 할 것입니다. 우리는 사용자가 이 작업을 직접 하지 않아도 되도록 하고 싶습니다.</p>
<p>또한, 트레이트가 구현된 타입의 이름을 출력하는 <code>hello_macro</code> 함수의 기본 구현을 아직 제공할 수 없습니다. 러스트는 리플렉션(reflection) 기능이 없어서 런타임에 타입의 이름을 찾아낼 수 없기 때문입니다. 컴파일 타임에 코드를 생성하기 위해 매크로가 필요합니다.</p>
<p>The next step is to define the procedural macro. At the time of this writing, procedural macros need to be in their own crate. Eventually, this restriction might be lifted. The convention for structuring crates and macro crates is as follows: For a crate named <code>foo</code>, a custom <code>derive</code> procedural macro crate is called <code>foo_derive</code>. Let’s start a new crate called <code>hello_macro_derive</code> inside our <code>hello_macro</code> project:</p>
<pre><code class="language-console">$ cargo new hello_macro_derive --lib
</code></pre>
<p>두 크레이트는 밀접하게 연관되어 있으므로, <code>hello_macro</code> 크레이트의 디렉토리 내에 절차적 매크로 크레이트를 생성합니다. 만약 <code>hello_macro</code>에서 트레이트 정의를 변경하면, <code>hello_macro_derive</code>에 있는 절차적 매크로의 구현도 변경해야 합니다. 두 크레이트는 개별적으로 게시되어야 하며, 이 크레이트들을 사용하는 프로그래머는 두 크레이트 모두를 의존성으로 추가하고 둘 다 스코프로 가져와야 합니다. 대신 <code>hello_macro</code> 크레이트가 <code>hello_macro_derive</code>를 의존성으로 사용하게 하고 절차적 매크로 코드를 다시 내보내기(re-export) 하도록 할 수도 있습니다. 하지만 우리가 프로젝트를 구성한 방식은 프로그래머들이 <code>derive</code> 기능을 원하지 않더라도 <code>hello_macro</code>를 사용할 수 있게 해줍니다.</p>
<p><code>hello_macro_derive</code> 크레이트를 절차적 매크로 크레이트로 선언해야 합니다. 또한 잠시 후에 보게 되겠지만 <code>syn</code>과 <code>quote</code> 크레이트의 기능이 필요하므로, 이들을 의존성으로 추가해야 합니다. <code>hello_macro_derive</code>를 위한 <em>Cargo.toml</em> 파일에 다음을 추가하세요.</p>
<Listing file-name="hello_macro_derive/Cargo.toml">
<pre><code class="language-toml">[lib]
proc-macro = true

[dependencies]
syn = "2.0"
quote = "1.0"
</code></pre>
</Listing>
<p>To start defining the procedural macro, place the code in Listing 20-40 into your <em>src/lib.rs</em> file for the <code>hello_macro_derive</code> crate. Note that this code won’t compile until we add a definition for the <code>impl_hello_macro</code> function.</p>
<Listing number="20-40" file-name="hello_macro_derive/src/lib.rs" caption="Code that most procedural macro crates will require in order to process Rust code">
<pre><code class="language-rust ignore does_not_compile">use proc_macro::TokenStream;
use quote::quote;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
    // 우리가 조작할 수 있는 구문 트리 형태로 러스트 코드의 표현을 구성합니다.
    let ast = syn::parse(input).unwrap();

    // 트레이트 구현을 작성합니다.
    impl_hello_macro(&amp;ast)
}</code></pre>
</Listing>
<p>Notice that we’ve split the code into the <code>hello_macro_derive</code> function, which is responsible for parsing the <code>TokenStream</code>, and the <code>impl_hello_macro</code> function, which is responsible for transforming the syntax tree: This makes writing a procedural macro more convenient. The code in the outer function (<code>hello_macro_derive</code> in this case) will be the same for almost every procedural macro crate you see or create. The code you specify in the body of the inner function (<code>impl_hello_macro</code> in this case) will be different depending on your procedural macro’s purpose.</p>
<p>We’ve introduced three new crates: <code>proc_macro</code>, <a href="https://crates.io/crates/syn"><code>syn</code></a><!-- ignore -->, and <a href="https://crates.io/crates/quote"><code>quote</code></a><!-- ignore -->. The <code>proc_macro</code> crate comes with Rust, so we didn’t need to add that to the dependencies in <em>Cargo.toml</em>. The <code>proc_macro</code> crate is the compiler’s API that allows us to read and manipulate Rust code from our code.</p>
<p>The <code>syn</code> crate parses Rust code from a string into a data structure that we can perform operations on. The <code>quote</code> crate turns <code>syn</code> data structures back into Rust code. These crates make it much simpler to parse any sort of Rust code we might want to handle: Writing a full parser for Rust code is no simple task.</p>
<p><code>hello_macro_derive</code> 함수는 우리 라이브러리의 사용자가 타입에 <code>#[derive(HelloMacro)]</code>를 지정할 때 호출될 것입니다. 이것이 가능한 이유는 여기서 <code>hello_macro_derive</code> 함수에 <code>proc_macro_derive</code> 어노테이션을 달고 우리 트레이트 이름과 일치하는 <code>HelloMacro</code>라는 이름을 지정했기 때문입니다. 이것이 대부분의 절차적 매크로가 따르는 관례입니다.</p>
<p>The <code>hello_macro_derive</code> function first converts the <code>input</code> from a <code>TokenStream</code> to a data structure that we can then interpret and perform operations on. This is where <code>syn</code> comes into play. The <code>parse</code> function in <code>syn</code> takes a <code>TokenStream</code> and returns a <code>DeriveInput</code> struct representing the parsed Rust code. Listing 20-41 shows the relevant parts of the <code>DeriveInput</code> struct we get from parsing the <code>struct Pancakes;</code> string.</p>
<Listing number="20-41" caption="The `DeriveInput` instance we get when parsing the code that has the macro’s attribute in Listing 20-37">
<pre><code class="language-rust ignore">DeriveInput {
    // --생략--

    ident: Ident {
        ident: "Pancakes",
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}</code></pre>
</Listing>
<p>The fields of this struct show that the Rust code we’ve parsed is a unit struct with the <code>ident</code> (<em>identifier</em>, meaning the name) of <code>Pancakes</code>. There are more fields on this struct for describing all sorts of Rust code; check the <a href="https://docs.rs/syn/2.0/syn/struct.DeriveInput.html"><code>syn</code> documentation for <code>DeriveInput</code></a> for more information.</p>
<p>Soon we’ll define the <code>impl_hello_macro</code> function, which is where we’ll build the new Rust code we want to include. But before we do, note that the output for our <code>derive</code> macro is also a <code>TokenStream</code>. The returned <code>TokenStream</code> is added to the code that our crate users write, so when they compile their crate, they’ll get the extra functionality that we provide in the modified <code>TokenStream</code>.</p>
<p>여기서 <code>syn::parse</code> 함수 호출이 실패할 경우 <code>hello_macro_derive</code> 함수가 패닉을 일으키도록 <code>unwrap</code>을 호출하고 있음을 눈치채셨을 것입니다. 절차적 매크로 API를 따르기 위해 <code>proc_macro_derive</code> 함수는 <code>Result</code>가 아닌 <code>TokenStream</code>을 반환해야 하므로, 에러 발생 시 우리 절차적 매크로가 패닉을 일으키는 것이 필요합니다. 이 예제에서는 <code>unwrap</code>을 사용하여 단순화했지만, 실제 프로덕션 코드에서는 <code>panic!</code>이나 <code>expect</code>를 사용하여 무엇이 잘못되었는지에 대한 더 구체적인 에러 메시지를 제공해야 합니다.</p>
<p>Now that we have the code to turn the annotated Rust code from a <code>TokenStream</code> into a <code>DeriveInput</code> instance, let’s generate the code that implements the <code>HelloMacro</code> trait on the annotated type, as shown in Listing 20-42.</p>
<Listing number="20-42" file-name="hello_macro_derive/src/lib.rs" caption="Implementing the `HelloMacro` trait using the parsed Rust code">
<pre><code class="language-rust ignore"><span class="boring">use proc_macro::TokenStream;
</span><span class="boring">use quote::quote;
</span><span class="boring">
</span><span class="boring">#[proc_macro_derive(HelloMacro)]
</span><span class="boring">pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
</span><span class="boring">    // 우리가 조작할 수 있는 구문 트리 형태로
</span><span class="boring">    // 러스트 코드의 표현을 구성합니다.
</span><span class="boring">    let ast = syn::parse(input).unwrap();
</span><span class="boring">
</span><span class="boring">    // 트레이트 구현을 작성합니다.
</span><span class="boring">    impl_hello_macro(&amp;ast)
</span><span class="boring">}
</span><span class="boring">
</span>fn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; TokenStream {
    let name = &amp;ast.ident;
    let generated = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Hello, Macro! My name is {}!", stringify!(#name));
            }
        }
    };
    generated.into()
}</code></pre>
</Listing>
<p>We get an <code>Ident</code> struct instance containing the name (identifier) of the annotated type using <code>ast.ident</code>. The struct in Listing 20-41 shows that when we run the <code>impl_hello_macro</code> function on the code in Listing 20-37, the <code>ident</code> we get will have the <code>ident</code> field with a value of <code>"Pancakes"</code>. Thus, the <code>name</code> variable in Listing 20-42 will contain an <code>Ident</code> struct instance that, when printed, will be the string <code>"Pancakes"</code>, the name of the struct in Listing 20-37.</p>
<p>The <code>quote!</code> macro lets us define the Rust code that we want to return. The compiler expects something different from the direct result of the <code>quote!</code> macro’s execution, so we need to convert it to a <code>TokenStream</code>. We do this by calling the <code>into</code> method, which consumes this intermediate representation and returns a value of the required <code>TokenStream</code> type.</p>
<p>The <code>quote!</code> macro also provides some very cool templating mechanics: We can enter <code>#name</code>, and <code>quote!</code> will replace it with the value in the variable <code>name</code>. You can even do some repetition similar to the way regular macros work. Check out <a href="https://docs.rs/quote">the <code>quote</code> crate’s docs</a> for a thorough introduction.</p>
<p>우리는 절차적 매크로가 사용자가 어노테이션을 단 타입에 대해 <code>HelloMacro</code> 트레이트 구현을 생성하기를 원하며, 이는 <code>#name</code>을 사용하여 얻을 수 있습니다. 트레이트 구현에는 <code>hello_macro</code>라는 하나의 함수가 있으며, 그 본문에는 우리가 제공하고자 하는 기능인 <code>Hello, Macro! My name is</code>와 어노테이션이 달린 타입의 이름을 출력하는 기능이 포함됩니다.</p>
<p>The <code>stringify!</code> macro used here is built into Rust. It takes a Rust expression, such as <code>1 + 2</code>, and at compile time turns the expression into a string literal, such as <code>"1 + 2"</code>. This is different from <code>format!</code> or <code>println!</code>, which are macros that evaluate the expression and then turn the result into a <code>String</code>. There is a possibility that the <code>#name</code> input might be an expression to print literally, so we use <code>stringify!</code>. Using <code>stringify!</code> also saves an allocation by converting <code>#name</code> to a string literal at compile time.</p>
<p>At this point, <code>cargo build</code> should complete successfully in both <code>hello_macro</code> and <code>hello_macro_derive</code>. Let’s hook up these crates to the code in Listing 20-37 to see the procedural macro in action! Create a new binary project in your <em>projects</em> directory using <code>cargo new pancakes</code>. We need to add <code>hello_macro</code> and <code>hello_macro_derive</code> as dependencies in the <code>pancakes</code> crate’s <em>Cargo.toml</em>. If you’re publishing your versions of <code>hello_macro</code> and <code>hello_macro_derive</code> to <a href="https://crates.io/">crates.io</a><!-- ignore -->, they would be regular dependencies; if not, you can specify them as <code>path</code> dependencies as follows:</p>
<pre><code class="language-toml">[dependencies]
hello_macro = { path = "../hello_macro" }
hello_macro_derive = { path = "../hello_macro/hello_macro_derive" }
</code></pre>
<p>Put the code in Listing 20-37 into <em>src/main.rs</em>, and run <code>cargo run</code>: It should print <code>Hello, Macro! My name is Pancakes!</code>. The implementation of the <code>HelloMacro</code> trait from the procedural macro was included without the <code>pancakes</code> crate needing to implement it; the <code>#[derive(HelloMacro)]</code> added the trait implementation.</p>
<p>Next, let’s explore how the other kinds of procedural macros differ from custom <code>derive</code> macros.</p>
<h3 id="attribute-like-macros"><a class="header" href="#attribute-like-macros">Attribute-Like Macros</a></h3>
<p>Attribute-like macros are similar to custom <code>derive</code> macros, but instead of generating code for the <code>derive</code> attribute, they allow you to create new attributes. They’re also more flexible: <code>derive</code> only works for structs and enums; attributes can be applied to other items as well, such as functions. Here’s an example of using an attribute-like macro. Say you have an attribute named <code>route</code> that annotates functions when using a web application framework:</p>
<pre><code class="language-rust ignore">#[route(GET, "/")]
fn index() {</code></pre>
<p>이 <code>#[route]</code> 속성은 프레임워크에 의해 절차적 매크로로 정의될 것입니다. 매크로 정의 함수의 시그니처는 다음과 같을 것입니다.</p>
<pre><code class="language-rust ignore">#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -&gt; TokenStream {</code></pre>
<p>여기에는 <code>TokenStream</code> 타입의 두 파라미터가 있습니다. 첫 번째는 속성의 내용, 즉 <code>GET, "/"</code> 부분을 위한 것입니다. 두 번째는 속성이 붙어 있는 아이템의 본문입니다. 이 경우 <code>fn index() {}</code>와 함수의 나머지 본문이 해당됩니다.</p>
<p>Other than that, attribute-like macros work the same way as custom <code>derive</code> macros: You create a crate with the <code>proc-macro</code> crate type and implement a function that generates the code you want!</p>
<h3 id="function-like-macros"><a class="header" href="#function-like-macros">Function-Like Macros</a></h3>
<p>Function-like macros define macros that look like function calls. Similarly to <code>macro_rules!</code> macros, they’re more flexible than functions; for example, they can take an unknown number of arguments. However, <code>macro_rules!</code> macros can only be defined using the match-like syntax we discussed in the <a href="#declarative-macros-with-macro_rules-for-general-metaprogramming">“Declarative Macros for General Metaprogramming”</a><!-- ignore --> section earlier. Function-like macros take a <code>TokenStream</code> parameter, and their definition manipulates that <code>TokenStream</code> using Rust code as the other two types of procedural macros do. An example of a function-like macro is an <code>sql!</code> macro that might be called like so:</p>
<pre><code class="language-rust ignore">let sql = sql!(SELECT * FROM posts WHERE id=1);</code></pre>
<p>이 매크로는 내부에 있는 SQL 문을 파싱하고 구문적으로 올바른지 확인하는데, 이는 <code>macro_rules!</code> 매크로가 할 수 있는 것보다 훨씬 더 복잡한 처리입니다. <code>sql!</code> 매크로는 다음과 같이 정의될 것입니다.</p>
<pre><code class="language-rust ignore">#[proc_macro]
pub fn sql(input: TokenStream) -&gt; TokenStream {</code></pre>
<p>This definition is similar to the custom <code>derive</code> macro’s signature: We receive the tokens that are inside the parentheses and return the code we wanted to generate.</p>
<h2 id="요약"><a class="header" href="#요약">요약</a></h2>
<p>Whew! Now you have some Rust features in your toolbox that you likely won’t use often, but you’ll know they’re available in very particular circumstances. We’ve introduced several complex topics so that when you encounter them in error message suggestions or in other people’s code, you’ll be able to recognize these concepts and syntax. Use this chapter as a reference to guide you to solutions.</p>
<p>다음으로, 책 전체에서 논의한 모든 내용을 실습에 적용하여 한 가지 프로젝트를 더 진행해 보겠습니다!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch20-04-advanced-functions-and-closures.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch21-00-final-project-a-web-server.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch20-04-advanced-functions-and-closures.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch21-00-final-project-a-web-server.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
