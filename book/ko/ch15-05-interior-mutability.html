<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RefCell&lt;T&gt;과 내부 가변성 패턴 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch15-05-interior-mutability.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch15-05-interior-mutability.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="refcellt과-내부-가변성-패턴"><a class="header" href="#refcellt과-내부-가변성-패턴"><code>RefCell&lt;T&gt;</code>과 내부 가변성 패턴</a></h2>
<p>_내부 가변성(Interior mutability)_은 데이터에 대한 불변 참조가 있더라도 데이터를 수정할 수 있게 해주는 러스트의 디자인 패턴입니다; 보통 이 작업은 대여 규칙에 의해 허용되지 않습니다. 데이터를 수정하기 위해, 이 패턴은 데이터 구조 내부에서 <code>unsafe</code> 코드를 사용하여 수정과 대여를 다스리는 러스트의 일반적인 규칙을 구부립니다. <code>unsafe</code> 코드는 우리가 컴파일러에게 의존하는 대신 규칙을 수동으로 확인하고 있음을 컴파일러에게 알립니다. <code>unsafe</code> 코드에 대해서는 20장에서 더 자세히 다룰 것입니다.</p>
<p>컴파일러가 보장할 수 없더라도 런타임에 대여 규칙이 준수될 것임을 우리가 확신할 수 있는 경우에만 내부 가변성 패턴을 사용하는 타입들을 사용할 수 있습니다. 관련된 <code>unsafe</code> 코드는 안전한 API로 감싸지며, 외부 타입은 여전히 불변입니다.</p>
<p>내부 가변성 패턴을 따르는 <code>RefCell&lt;T&gt;</code> 타입을 살펴보며 이 개념을 탐구해 봅시다.</p>
<h3 id="refcellt로-런타임에-대여-규칙-강제하기"><a class="header" href="#refcellt로-런타임에-대여-규칙-강제하기"><code>RefCell&lt;T&gt;</code>로 런타임에 대여 규칙 강제하기</a></h3>
<p><code>Rc&lt;T&gt;</code>와 달리, <code>RefCell&lt;T&gt;</code> 타입은 보유한 데이터에 대해 단일 소유권을 나타냅니다. 그렇다면 <code>RefCell&lt;T&gt;</code>가 <code>Box&lt;T&gt;</code>와 같은 타입과 다른 점은 무엇일까요? 4장에서 배운 대여 규칙을 상기해 보세요:</p>
<ul>
<li>어느 때든, 하나의 가변 참조 <em>또는</em> 여러 개의 불변 참조 중 하나만 가질 수 있습니다(둘 다 가질 수는 없습니다).</li>
<li>참조는 항상 유효해야 합니다.</li>
</ul>
<p>참조와 <code>Box&lt;T&gt;</code>의 경우, 대여 규칙의 불변성(invariants)은 컴파일 타임에 강제됩니다. <code>RefCell&lt;T&gt;</code>의 경우, 이러한 불변성들은 <em>런타임에</em> 강제됩니다. 참조의 경우 규칙을 어기면 컴파일 에러를 받게 됩니다. <code>RefCell&lt;T&gt;</code>의 경우 규칙을 어기면 프로그램이 패닉(panic)을 일으키고 종료될 것입니다.</p>
<p>컴파일 타임에 대여 규칙을 검사하면 개발 과정에서 에러를 더 일찍 발견할 수 있고, 모든 분석이 사전에 완료되므로 런타임 성능에 영향이 없다는 장점이 있습니다. 이러한 이유로 대부분의 경우 컴파일 타임에 대여 규칙을 검사하는 것이 최선의 선택이며, 이것이 러스트의 기본 설정입니다.</p>
<p>반면 런타임에 대여 규칙을 검사하면 컴파일 타임 검사에서는 허용되지 않았을 특정 메모리 안전 시나리오가 허용된다는 장점이 있습니다. 러스트 컴파일러와 같은 정적 분석은 본질적으로 보수적입니다. 코드의 어떤 속성들은 코드를 분석하는 것만으로는 감지가 불가능합니다. 가장 유명한 예는 정지 문제(Halting Problem)이며, 이는 이 책의 범위를 벗어나지만 연구해 볼 만한 흥미로운 주제입니다.</p>
<p>일부 분석이 불가능하기 때문에, 러스트 컴파일러가 코드가 소유권 규칙을 준수하는지 확신할 수 없다면 올바른 프로그램이라도 거부할 수 있습니다. 이런 면에서 컴파일러는 보수적입니다. 만약 러스트가 잘못된 프로그램을 허용한다면 사용자는 러스트가 제공하는 보장을 신뢰할 수 없을 것입니다. 하지만 러스트가 올바른 프로그램을 거부한다면 프로그래머는 불편함을 겪겠지만 재앙적인 일은 일어나지 않습니다. <code>RefCell&lt;T&gt;</code> 타입은 여러분의 코드가 대여 규칙을 준수한다고 확신하지만 컴파일러가 이를 이해하고 보장할 수 없을 때 유용합니다.</p>
<p><code>Rc&lt;T&gt;</code>와 마찬가지로, <code>RefCell&lt;T&gt;</code>는 오직 단일 스레드 시나리오에서만 사용 가능하며 멀티스레드 문맥에서 사용하려고 하면 컴파일 에러를 발생시킵니다. 16장에서 멀티스레드 프로그램에서 <code>RefCell&lt;T&gt;</code>과 같은 기능을 얻는 방법을 살펴보겠습니다.</p>
<p><code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code>, 혹은 <code>RefCell&lt;T&gt;</code>를 선택하는 이유를 요약하면 다음과 같습니다:</p>
<ul>
<li><code>Rc&lt;T&gt;</code>는 동일한 데이터에 대해 여러 소유자를 가능하게 합니다. <code>Box&lt;T&gt;</code>와 <code>RefCell&lt;T&gt;</code>는 단일 소유자만 가집니다.</li>
<li><code>Box&lt;T&gt;</code>는 컴파일 타임에 검사되는 불변 또는 가변 대여를 허용합니다. <code>Rc&lt;T&gt;</code>는 컴파일 타임에 검사되는 불변 대여만 허용합니다. <code>RefCell&lt;T&gt;</code>는 런타임에 검사되는 불변 또는 가변 대여를 허용합니다.</li>
<li><code>RefCell&lt;T&gt;</code>는 런타임에 검사되는 가변 대여를 허용하기 때문에, <code>RefCell&lt;T&gt;</code>가 불변인 경우에도 <code>RefCell&lt;T&gt;</code> 내부의 값을 수정할 수 있습니다.</li>
</ul>
<p>불변인 값 내부의 값을 수정하는 것이 바로 <em>내부 가변성</em> 패턴입니다. 내부 가변성이 유용한 상황을 살펴보고 이것이 어떻게 가능한지 알아봅시다.</p>
<h3 id="내부-가변성-불변-값에-대한-가변-대여"><a class="header" href="#내부-가변성-불변-값에-대한-가변-대여">내부 가변성: 불변 값에 대한 가변 대여</a></h3>
<p>대여 규칙의 결과로, 불변 값을 가지고 있을 때는 이를 가변으로 대여할 수 없습니다. 예를 들어, 다음 코드는 컴파일되지 않습니다:</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    let y = &amp;mut x;
}</code></pre>
<p>이 코드를 컴파일하려고 하면 다음과 같은 에러가 발생합니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling borrowing v0.1.0 (file:///projects/borrowing)
error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
 --&gt; src/main.rs:3:13
  |
3 |     let y = &amp;mut x;
  |             ^^^^^^ cannot borrow as mutable
  |
help: consider changing this to be mutable
  |
2 |     let mut x = 5;
  |         +++

For more information about this error, try `rustc --explain E0596`.
error: could not compile `borrowing` (bin "borrowing") due to 1 previous error
</code></pre>
<p>하지만 어떤 값이 자신의 메서드 내에서는 스스로를 변경할 수 있지만 다른 코드에게는 불변으로 보이게 하는 것이 유용한 상황이 있습니다. 그 값의 메서드 외부의 코드는 해당 값을 수정할 수 없습니다. <code>RefCell&lt;T&gt;</code>를 사용하는 것은 내부 가변성을 얻는 한 가지 방법이지만, <code>RefCell&lt;T&gt;</code>가 대여 규칙을 완전히 피하게 해주는 것은 아닙니다. 컴파일러의 대여 검사기는 이러한 내부 가변성을 허용하는 대신, 대여 규칙을 런타임에 검사합니다. 만약 규칙을 어긴다면 컴파일 에러 대신 <code>panic!</code>을 얻게 될 것입니다.</p>
<p><code>RefCell&lt;T&gt;</code>를 사용하여 불변 값을 수정하는 실질적인 예제를 통해 이것이 왜 유용한지 살펴보겠습니다.</p>
<h4 id="내부-가변성의-사용-사례-목-객체mock-objects"><a class="header" href="#내부-가변성의-사용-사례-목-객체mock-objects">내부 가변성의 사용 사례: 목 객체(Mock Objects)</a></h4>
<p>Sometimes during testing a programmer will use a type in place of another type, in order to observe particular behavior and assert it’s implemented correctly. This placeholder type is called a <em>test double</em>. Think of it in the sense of a “stunt double” in filmmaking, where a person steps in and substitutes for an actor to do a particular tricky scene. Test doubles stand in for other types when we’re running tests. <em>Mock objects</em> are specific types of test doubles that record what happens during a test so you can assert that the correct actions took place.</p>
<p>Rust doesn’t have objects in the same sense as other languages have objects, and Rust doesn’t have mock object functionality built into the standard library as some other languages do. However, you can definitely create a struct that will serve the same purposes as a mock object.</p>
<p>Here’s the scenario we’ll test: we’ll create a library that tracks a value against a maximum value and sends messages based on how close to the maximum value the current value is. This library could be used to keep track of a user’s quota for the number of API calls they’re allowed to make, for example.</p>
<p>Our library will only provide the functionality of tracking how close to the maximum a value is and what the messages should be at what times. Applications that use our library will be expected to provide the mechanism for sending the messages: the application could put a message in the application, send an email, send a text message, or something else. The library doesn’t need to know that detail. All it needs is something that implements a trait we’ll provide called <code>Messenger</code>. Listing 15-20 shows the library code:</p>
<Listing number="15-20" file-name="src/lib.rs" caption="A library to keep track of how close a value is to a maximum value and warn when the value is at certain levels">
<pre><code class="language-rust noplayground">pub trait Messenger {
    fn send(&amp;self, msg: &amp;str);
}

pub struct LimitTracker&lt;'a, T: Messenger&gt; {
    messenger: &amp;'a T,
    value: usize,
    max: usize,
}

impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
where
    T: Messenger,
{
    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&amp;mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max &gt;= 1.0 {
            self.messenger.send("에러: 할당량을 초과했습니다!");
        } else if percentage_of_max &gt;= 0.9 {
            self.messenger
                .send("긴급 경고: 할당량의 90% 이상을 사용했습니다!");
        } else if percentage_of_max &gt;= 0.75 {
            self.messenger
                .send("경고: 할당량의 75% 이상을 사용했습니다!");
        }
    }
}</code></pre>
</Listing>
<p>중요한 부분은 <code>LimitTracker</code>의 <code>set_value</code> 메서드 동작을 테스트하고 싶다는 것입니다. <code>value</code> 매개변수로 전달하는 값을 변경할 수 있지만, <code>set_value</code>는 우리가 단언(assertion)할 수 있는 어떤 것도 반환하지 않습니다. 우리는 <code>Messenger</code> 트레이트를 구현하는 무언가와 특정한 <code>max</code> 값을 가지고 <code>LimitTracker</code>를 만들었을 때, <code>value</code>로 다른 숫자들을 전달하면 메신저가 적절한 메시지를 보내도록 요청받는지를 말할 수 있기를 원합니다.</p>
<p>우리는 <code>send</code>를 호출할 때 이메일이나 텍스트 메시지를 보내는 대신, 보내도록 요청받은 메시지만 추적하는 목 객체가 필요합니다. 목 객체의 새 인스턴스를 만들고, 그 목 객체를 사용하는 <code>LimitTracker</code>를 만든 뒤, <code>LimitTracker</code>의 <code>set_value</code> 메서드를 호출하고 목 객체가 우리가 예상한 메시지들을 가지고 있는지 확인할 수 있습니다. 목록 15-21은 바로 그 작업을 수행하기 위한 목 객체 구현 시도를 보여주지만, 대여 검사기가 이를 허용하지 않을 것입니다.</p>
<Listing number="15-21" file-name="src/lib.rs" caption="An attempt to implement a `MockMessenger` that isn’t allowed by the borrow checker">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("에러: 할당량을 초과했습니다!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("긴급 경고: 할당량의 90% 이상을 사용했습니다!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("경고: 할당량의 75% 이상을 사용했습니다!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec&lt;String&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: vec![],
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}</code></pre>
</Listing>
<p>이 테스트 코드는 보내도록 요청받은 메시지를 추적하기 위해 <code>String</code> 값들의 <code>Vec</code>을 가지는 <code>sent_messages</code> 필드가 있는 <code>MockMessenger</code> 구조체를 정의합니다. 또한 빈 메시지 목록으로 시작하는 새로운 <code>MockMessenger</code> 값을 편리하게 생성할 수 있도록 <code>new</code> 연관 함수를 정의합니다. 그다음 <code>MockMessenger</code>를 <code>LimitTracker</code>에 전달할 수 있도록 <code>Messenger</code> 트레이트를 구현합니다. <code>send</code> 메서드 정의에서는 매개변수로 전달된 메시지를 가져와 <code>MockMessenger</code>의 <code>sent_messages</code> 목록에 저장합니다.</p>
<p>테스트에서는 <code>LimitTracker</code>가 <code>value</code>를 <code>max</code> 값의 75%보다 큰 값으로 설정하도록 요청받았을 때 어떤 일이 일어나는지 테스트합니다. 먼저, 빈 메시지 목록으로 시작하는 새로운 <code>MockMessenger</code>를 생성합니다. 그런 다음 새로운 <code>LimitTracker</code>를 생성하고 여기에 새로운 <code>MockMessenger</code>에 대한 참조와 100이라는 <code>max</code> 값을 전달합니다. 100의 75%보다 큰 값인 80을 사용하여 <code>LimitTracker</code>의 <code>set_value</code> 메서드를 호출합니다. 그다음 <code>MockMessenger</code>가 추적하고 있는 메시지 목록에 이제 하나의 메시지가 들어있어야 한다고 단언합니다.</p>
<p>하지만 여기에 나타난 것처럼 이 테스트에는 한 가지 문제가 있습니다:</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
error[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a `&amp;` reference
  --&gt; src/lib.rs:58:13
   |
58 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable
   |
help: consider changing this to be a mutable reference in the `impl` method and the `trait` definition
   |
2  ~     fn send(&amp;mut self, msg: &amp;str);
3  | }
...
56 |     impl Messenger for MockMessenger {
57 ~         fn send(&amp;mut self, message: &amp;str) {
   |

For more information about this error, try `rustc --explain E0596`.
error: could not compile `limit-tracker` (lib test) due to 1 previous error
</code></pre>
<p>우리는 메시지를 추적하기 위해 <code>MockMessenger</code>를 수정할 수 없는데, 이는 <code>send</code> 메서드가 <code>self</code>에 대한 불변 참조를 받기 때문입니다. 또한 에러 텍스트의 제안대로 <code>impl</code> 메서드와 <code>trait</code> 정의 양쪽 모두에 <code>&amp;mut self</code>를 사용할 수도 없습니다. 오로지 테스트만을 위해서 <code>Messenger</code> 트레이트를 변경하고 싶지는 않기 때문입니다. 대신, 기존 설계와 함께 우리 테스트 코드가 올바르게 작동하도록 만들 방법을 찾아야 합니다.</p>
<p>이러한 상황이 바로 내부 가변성이 도움이 될 수 있는 상황입니다! <code>sent_messages</code>를 <code>RefCell&lt;T&gt;</code> 내부에 저장할 것이고, 그러면 <code>send</code> 메서드는 우리가 본 메시지들을 저장하기 위해 <code>sent_messages</code>를 수정할 수 있게 될 것입니다. 목록 15-22는 그 모습이 어떠한지 보여줍니다:</p>
<Listing number="15-22" file-name="src/lib.rs" caption="Using `RefCell<T>` to mutate an inner value while the outer value is considered immutable">
<pre><code class="language-rust noplayground"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("에러: 할당량을 초과했습니다!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("긴급 경고: 할당량의 90% 이상을 사용했습니다!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("경고: 할당량의 75% 이상을 사용했습니다!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: RefCell::new(vec![]),
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --생략--
<span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span>
        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}</code></pre>
</Listing>
<p>이제 <code>sent_messages</code> 필드는 <code>Vec&lt;String&gt;</code> 대신 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> 타입이 되었습니다. <code>new</code> 함수에서는 빈 벡터를 감싸는 새로운 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> 인스턴스를 생성합니다.</p>
<p><code>send</code> 메서드 구현에서, 첫 번째 매개변수는 여전히 <code>self</code>에 대한 불변 대여이며, 이는 트레이트 정의와 일치합니다. 우리는 <code>self.sent_messages</code>에 있는 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>에 대해 <code>borrow_mut</code>를 호출하여 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> 내부의 값, 즉 벡터에 대한 가변 참조를 얻습니다. 그런 다음 벡터에 대한 가변 참조에 대해 <code>push</code>를 호출하여 테스트 중에 전송된 메시지를 추적할 수 있습니다.</p>
<p>마지막으로 수정해야 할 부분은 단언(assertion)입니다: 내부 벡터에 몇 개의 항목이 있는지 확인하기 위해, <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>에 대해 <code>borrow</code>를 호출하여 벡터에 대한 불변 참조를 얻습니다.</p>
<p>이제 <code>RefCell&lt;T&gt;</code>를 사용하는 방법을 살펴보았으니, 내부적으로 어떻게 작동하는지 파헤쳐 봅시다!</p>
<h4 id="refcellt로-런타임에-대여-추적하기"><a class="header" href="#refcellt로-런타임에-대여-추적하기"><code>RefCell&lt;T&gt;</code>로 런타임에 대여 추적하기</a></h4>
<p>불변 참조와 가변 참조를 생성할 때, 우리는 각각 <code>&amp;</code>와 <code>&amp;mut</code> 문법을 사용합니다. <code>RefCell&lt;T&gt;</code>의 경우에는 <code>RefCell&lt;T&gt;</code>에 속한 안전한 API인 <code>borrow</code>와 <code>borrow_mut</code> 메서드를 사용합니다. <code>borrow</code> 메서드는 스마트 포인터 타입인 <code>Ref&lt;T&gt;</code>를 반환하고, <code>borrow_mut</code>는 스마트 포인터 타입인 <code>RefMut&lt;T&gt;</code>를 반환합니다. 두 타입 모두 <code>Deref</code>를 구현하므로, 우리는 이들을 일반 참조처럼 다룰 수 있습니다.</p>
<p><code>RefCell&lt;T&gt;</code>는 현재 얼마나 많은 <code>Ref&lt;T&gt;</code>와 <code>RefMut&lt;T&gt;</code> 스마트 포인터가 활성화되어 있는지 추적합니다. <code>borrow</code>를 호출할 때마다 <code>RefCell&lt;T&gt;</code>는 활성화된 불변 대여의 개수를 늘립니다. <code>Ref&lt;T&gt;</code> 값이 스코프를 벗어나면 불변 대여의 개수가 하나 줄어듭니다. 컴파일 타임 대여 규칙과 마찬가지로, <code>RefCell&lt;T&gt;</code>는 어느 시점이든 여러 개의 불변 대여 혹은 단 하나의 가변 대여만 가질 수 있게 합니다.</p>
<p>우리가 만약 이 규칙들을 위반하려고 하면, 참조를 사용할 때처럼 컴파일 에러를 받는 대신 <code>RefCell&lt;T&gt;</code>의 구현체는 런타임에 패닉을 발생시킵니다. 목록 15-23은 목록 15-22의 <code>send</code> 구현을 수정한 모습을 보여줍니다. <code>RefCell&lt;T&gt;</code>가 런타임에 이러한 행위를 방지한다는 것을 설명하기 위해, 동일한 스코프에서 두 개의 활성화된 가변 대여를 의도적으로 생성해 보았습니다.</p>
<Listing number="15-23" file-name="src/lib.rs" caption="Creating two mutable references in the same scope to see that `RefCell<T>` will panic">
<pre><code class="language-rust ignore panics"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("에러: 할당량을 초과했습니다!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("긴급 경고: 할당량의 90% 이상을 사용했습니다!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("경고: 할당량의 75% 이상을 사용했습니다!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">    struct MockMessenger {
</span><span class="boring">        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl MockMessenger {
</span><span class="boring">        fn new() -&gt; MockMessenger {
</span><span class="boring">            MockMessenger {
</span><span class="boring">                sent_messages: RefCell::new(vec![]),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            let mut one_borrow = self.sent_messages.borrow_mut();
            let mut two_borrow = self.sent_messages.borrow_mut();

            one_borrow.push(String::from(message));
            two_borrow.push(String::from(message));
        }
    }
<span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_sends_an_over_75_percent_warning_message() {
</span><span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span><span class="boring">
</span><span class="boring">        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p><code>borrow_mut</code>로부터 반환된 <code>RefMut&lt;T&gt;</code> 스마트 포인터를 위해 <code>one_borrow</code>라는 변수를 생성합니다. 그런 다음 동일한 방식으로 <code>two_borrow</code>라는 변수에 또 다른 가변 대여를 생성합니다. 이는 동일한 스코프에 두 개의 가변 참조를 만들며, 이는 허용되지 않습니다. 우리 라이브러리의 테스트를 실행하면 목록 15-23의 코드는 에러 없이 컴파일되지만 테스트는 실패할 것입니다:</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/limit_tracker-e599811fa246dbde)

running 1 test
test tests::it_sends_an_over_75_percent_warning_message ... FAILED

failures:

---- tests::it_sends_an_over_75_percent_warning_message stdout ----
thread 'tests::it_sends_an_over_75_percent_warning_message' panicked at src/lib.rs:60:53:
already borrowed: BorrowMutError
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_sends_an_over_75_percent_warning_message

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>코드가 <code>already borrowed: BorrowMutError</code>라는 메시지와 함께 패닉을 일으켰다는 점에 주목하세요. 이것이 <code>RefCell&lt;T&gt;</code>가 런타임에 대여 규칙 위반을 처리하는 방식입니다.</p>
<p>여기서 한 것처럼 대여 에러를 컴파일 타임이 아닌 런타임에 잡기로 선택하는 것은, 개발 과정의 더 늦은 시점(아마도 코드가 프로덕션에 배포된 이후일 수도 있음)에 코드의 실수를 발견하게 될 수도 있음을 의미합니다. 또한 코드는 런타임에 대여를 추적하기 때문에 약간의 런타임 성능 저하가 발생할 것입니다. 하지만 <code>RefCell&lt;T&gt;</code>를 사용하면 불변 값만 허용되는 맥락에서 사용되는 동안에도 스스로를 수정하여 본 메시지들을 추적할 수 있는 목 객체를 작성하는 것이 가능해집니다. 이러한 트레이드오프에도 불구하고 일반 참조가 제공하는 것 이상의 기능을 얻기 위해 <code>RefCell&lt;T&gt;</code>를 사용할 수 있습니다.</p>
<h3 id="rc와-refcell를-조합하여-가변-데이터의-다중-소유자-만들기"><a class="header" href="#rc와-refcell를-조합하여-가변-데이터의-다중-소유자-만들기">Rc<T>와 RefCell<T>를 조합하여 가변 데이터의 다중 소유자 만들기</a></h3>
<p>RefCell<T>를 사용하는 일반적인 방법은 Rc<T>와 함께 사용하는 것입니다. Rc<T>를 사용하면 어떤 데이터에 대해 여러 소유자를 가질 수 있지만, 그 데이터에 대해 불변 접근만 제공한다는 것을 기억하세요. RefCell<T>를 보유하는 Rc<T>가 있다면, 여러 소유자를 가질 수 <em>있고</em> 변경할 수도 있는 값을 얻을 수 있습니다!</p>
<p>예를 들어, 여러 리스트가 다른 리스트의 소유권을 공유하도록 하기 위해 Rc<T>를 사용했던 목록 15-18의 cons 리스트 예제를 떠올려보세요. Rc<T>는 불변 값만 보유하기 때문에, 일단 리스트를 생성하면 리스트의 어떤 값도 변경할 수 없습니다. 리스트의 값을 변경할 수 있는 기능을 얻기 위해 RefCell<T>를 추가해봅시다. 목록 15-24는 Cons 정의에 RefCell<T>를 사용함으로써 모든 리스트에 저장된 값을 수정할 수 있음을 보여줍니다:</p>
<Listing number="15-24" file-name="src/main.rs" caption="Using `Rc<RefCell<i32>>` to create a `List` that we can mutate">
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a));

    *value.borrow_mut() += 10;

    println!("변경 후 a = {a:?}");
    println!("변경 후 b = {b:?}");
    println!("변경 후 c = {c:?}");
}</code></pre></pre>
</Listing>
<p>Rc&lt;RefCell<i32>&gt;의 인스턴스인 값을 생성하고 나중에 직접 접근할 수 있도록 value라는 변수에 저장합니다. 그런 다음 value를 보유하는 Cons 변형으로 a에 List를 생성합니다. value에서 a로 소유권을 이전하거나 a가 value에서 대여하는 대신, a와 value 모두 내부의 5 값에 대한 소유권을 갖도록 value를 클론해야 합니다.</p>
<p>리스트 a를 Rc<T>로 감싸서 리스트 b와 c를 생성할 때 둘 다 a를 참조할 수 있도록 합니다. 이는 목록 15-18에서 했던 것과 같습니다.</p>
<p>a, b, c에 리스트를 생성한 후, value의 값에 10을 더하려고 합니다. 이를 위해 value에서 borrow_mut를 호출하는데, 이는 5장에서 논의했던 자동 역참조 기능(<a href="ch05-03-method-syntax.html#wheres-the---operator">“-&gt; 연산자는 어디에 있나요?”</a><!-- ignore --> 참조)을 사용하여 Rc<T>를 내부의 RefCell<T> 값으로 역참조합니다. borrow_mut 메서드는 RefMut<T> 스마트 포인터를 반환하며, 우리는 그 위에 역참조 연산자를 사용하여 내부 값을 변경합니다.</p>
<p>a, b, c를 출력해보면, 모두 5가 아닌 수정된 값 15를 가지고 있음을 볼 수 있습니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.63s
     Running `target/debug/cons-list`
변경 후 a = Cons(RefCell { value: 15 }, Nil)
변경 후 b = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))
변경 후 c = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<p>이 기법은 꽤 훌륭합니다! RefCell<T>를 사용하면 겉보기에는 불변인 List 값을 갖게 됩니다. 하지만 필요할 때 데이터를 수정할 수 있도록 내부 가변성에 대한 접근을 제공하는 RefCell<T>의 메서드를 사용할 수 있습니다. 대여 규칙의 런타임 검사는 데이터 경합으로부터 우리를 보호하며, 데이터 구조에서의 이러한 유연성을 위해 약간의 속도를 희생할 가치가 있습니다. RefCell<T>는 멀티스레드 코드에서는 작동하지 않는다는 점에 유의하세요! Mutex<T>는 RefCell<T>의 스레드 안전 버전이며 16장에서 Mutex<T>에 대해 논의할 것입니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch15-04-rc.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch15-06-reference-cycles.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch15-04-rc.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch15-06-reference-cycles.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
