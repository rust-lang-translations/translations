<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RefCell&lt;T&gt;과 내부 가변성 패턴 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch15-05-interior-mutability.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch15-05-interior-mutability.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="refcellt과-내부-가변성-패턴"><a class="header" href="#refcellt과-내부-가변성-패턴"><code>RefCell&lt;T&gt;</code>과 내부 가변성 패턴</a></h2>
<p>_내부 가변성(Interior mutability)_은 데이터에 대한 불변 참조가 있더라도 데이터를 수정할 수 있게 해주는 러스트의 디자인 패턴입니다; 보통 이 작업은 대여 규칙에 의해 허용되지 않습니다. 데이터를 수정하기 위해, 이 패턴은 데이터 구조 내부에서 <code>unsafe</code> 코드를 사용하여 수정과 대여를 다스리는 러스트의 일반적인 규칙을 구부립니다. <code>unsafe</code> 코드는 우리가 컴파일러에게 의존하는 대신 규칙을 수동으로 확인하고 있음을 컴파일러에게 알립니다. <code>unsafe</code> 코드에 대해서는 20장에서 더 자세히 다룰 것입니다.</p>
<p>컴파일러가 보장할 수 없더라도 런타임에 대여 규칙이 준수될 것임을 우리가 확신할 수 있는 경우에만 내부 가변성 패턴을 사용하는 타입들을 사용할 수 있습니다. 관련된 <code>unsafe</code> 코드는 안전한 API로 감싸지며, 외부 타입은 여전히 불변입니다.</p>
<p>내부 가변성 패턴을 따르는 <code>RefCell&lt;T&gt;</code> 타입을 살펴보며 이 개념을 탐구해 봅시다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="enforcing-borrowing-rules-at-runtime-with-refcellt"></a></p>
<h3 id="enforcing-borrowing-rules-at-runtime"><a class="header" href="#enforcing-borrowing-rules-at-runtime">Enforcing Borrowing Rules at Runtime</a></h3>
<p><code>Rc&lt;T&gt;</code>와 달리, <code>RefCell&lt;T&gt;</code> 타입은 보유한 데이터에 대해 단일 소유권을 나타냅니다. 그렇다면 <code>RefCell&lt;T&gt;</code>가 <code>Box&lt;T&gt;</code>와 같은 타입과 다른 점은 무엇일까요? 4장에서 배운 대여 규칙을 상기해 보세요:</p>
<ul>
<li>At any given time, you can have <em>either</em> one mutable reference or any number of immutable references (but not both).</li>
<li>참조는 항상 유효해야 합니다.</li>
</ul>
<p>참조와 <code>Box&lt;T&gt;</code>의 경우, 대여 규칙의 불변성(invariants)은 컴파일 타임에 강제됩니다. <code>RefCell&lt;T&gt;</code>의 경우, 이러한 불변성들은 <em>런타임에</em> 강제됩니다. 참조의 경우 규칙을 어기면 컴파일 에러를 받게 됩니다. <code>RefCell&lt;T&gt;</code>의 경우 규칙을 어기면 프로그램이 패닉(panic)을 일으키고 종료될 것입니다.</p>
<p>컴파일 타임에 대여 규칙을 검사하면 개발 과정에서 에러를 더 일찍 발견할 수 있고, 모든 분석이 사전에 완료되므로 런타임 성능에 영향이 없다는 장점이 있습니다. 이러한 이유로 대부분의 경우 컴파일 타임에 대여 규칙을 검사하는 것이 최선의 선택이며, 이것이 러스트의 기본 설정입니다.</p>
<p>The advantage of checking the borrowing rules at runtime instead is that certain memory-safe scenarios are then allowed, where they would’ve been disallowed by the compile-time checks. Static analysis, like the Rust compiler, is inherently conservative. Some properties of code are impossible to detect by analyzing the code: The most famous example is the Halting Problem, which is beyond the scope of this book but is an interesting topic to research.</p>
<p>Because some analysis is impossible, if the Rust compiler can’t be sure the code complies with the ownership rules, it might reject a correct program; in this way, it’s conservative. If Rust accepted an incorrect program, users wouldn’t be able to trust the guarantees Rust makes. However, if Rust rejects a correct program, the programmer will be inconvenienced, but nothing catastrophic can occur. The <code>RefCell&lt;T&gt;</code> type is useful when you’re sure your code follows the borrowing rules but the compiler is unable to understand and guarantee that.</p>
<p><code>Rc&lt;T&gt;</code>와 마찬가지로, <code>RefCell&lt;T&gt;</code>는 오직 단일 스레드 시나리오에서만 사용 가능하며 멀티스레드 문맥에서 사용하려고 하면 컴파일 에러를 발생시킵니다. 16장에서 멀티스레드 프로그램에서 <code>RefCell&lt;T&gt;</code>과 같은 기능을 얻는 방법을 살펴보겠습니다.</p>
<p><code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code>, 혹은 <code>RefCell&lt;T&gt;</code>를 선택하는 이유를 요약하면 다음과 같습니다:</p>
<ul>
<li><code>Rc&lt;T&gt;</code>는 동일한 데이터에 대해 여러 소유자를 가능하게 합니다. <code>Box&lt;T&gt;</code>와 <code>RefCell&lt;T&gt;</code>는 단일 소유자만 가집니다.</li>
<li><code>Box&lt;T&gt;</code>는 컴파일 타임에 검사되는 불변 또는 가변 대여를 허용합니다. <code>Rc&lt;T&gt;</code>는 컴파일 타임에 검사되는 불변 대여만 허용합니다. <code>RefCell&lt;T&gt;</code>는 런타임에 검사되는 불변 또는 가변 대여를 허용합니다.</li>
<li><code>RefCell&lt;T&gt;</code>는 런타임에 검사되는 가변 대여를 허용하기 때문에, <code>RefCell&lt;T&gt;</code>가 불변인 경우에도 <code>RefCell&lt;T&gt;</code> 내부의 값을 수정할 수 있습니다.</li>
</ul>
<p>Mutating the value inside an immutable value is the interior mutability pattern. Let’s look at a situation in which interior mutability is useful and examine how it’s possible.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="interior-mutability-a-mutable-borrow-to-an-immutable-value"></a></p>
<h3 id="using-interior-mutability"><a class="header" href="#using-interior-mutability">Using Interior Mutability</a></h3>
<p>대여 규칙의 결과로, 불변 값을 가지고 있을 때는 이를 가변으로 대여할 수 없습니다. 예를 들어, 다음 코드는 컴파일되지 않습니다:</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    let y = &amp;mut x;
}</code></pre>
<p>이 코드를 컴파일하려고 하면 다음과 같은 에러가 발생합니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling borrowing v0.1.0 (file:///projects/borrowing)
error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
 --&gt; src/main.rs:3:13
  |
3 |     let y = &amp;mut x;
  |             ^^^^^^ cannot borrow as mutable
  |
help: consider changing this to be mutable
  |
2 |     let mut x = 5;
  |         +++

For more information about this error, try `rustc --explain E0596`.
error: could not compile `borrowing` (bin "borrowing") due to 1 previous error
</code></pre>
<p>However, there are situations in which it would be useful for a value to mutate itself in its methods but appear immutable to other code. Code outside the value’s methods would not be able to mutate the value. Using <code>RefCell&lt;T&gt;</code> is one way to get the ability to have interior mutability, but <code>RefCell&lt;T&gt;</code> doesn’t get around the borrowing rules completely: The borrow checker in the compiler allows this interior mutability, and the borrowing rules are checked at runtime instead. If you violate the rules, you’ll get a <code>panic!</code> instead of a compiler error.</p>
<p><code>RefCell&lt;T&gt;</code>를 사용하여 불변 값을 수정하는 실질적인 예제를 통해 이것이 왜 유용한지 살펴보겠습니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="a-use-case-for-interior-mutability-mock-objects"></a></p>
<h4 id="testing-with-mock-objects"><a class="header" href="#testing-with-mock-objects">Testing with Mock Objects</a></h4>
<p>Sometimes during testing a programmer will use a type in place of another type, in order to observe particular behavior and assert that it’s implemented correctly. This placeholder type is called a <em>test double</em>. Think of it in the sense of a stunt double in filmmaking, where a person steps in and substitutes for an actor to do a particularly tricky scene. Test doubles stand in for other types when we’re running tests. <em>Mock objects</em> are specific types of test doubles that record what happens during a test so that you can assert that the correct actions took place.</p>
<p>Rust doesn’t have objects in the same sense as other languages have objects, and Rust doesn’t have mock object functionality built into the standard library as some other languages do. However, you can definitely create a struct that will serve the same purposes as a mock object.</p>
<p>Here’s the scenario we’ll test: We’ll create a library that tracks a value against a maximum value and sends messages based on how close to the maximum value the current value is. This library could be used to keep track of a user’s quota for the number of API calls they’re allowed to make, for example.</p>
<p>Our library will only provide the functionality of tracking how close to the maximum a value is and what the messages should be at what times. Applications that use our library will be expected to provide the mechanism for sending the messages: The application could show the message to the user directly, send an email, send a text message, or do something else. The library doesn’t need to know that detail. All it needs is something that implements a trait we’ll provide, called <code>Messenger</code>. Listing 15-20 shows the library code.</p>
<Listing number="15-20" file-name="src/lib.rs" caption="A library to keep track of how close a value is to a maximum value and warn when the value is at certain levels">
<pre><code class="language-rust noplayground">pub trait Messenger {
    fn send(&amp;self, msg: &amp;str);
}

pub struct LimitTracker&lt;'a, T: Messenger&gt; {
    messenger: &amp;'a T,
    value: usize,
    max: usize,
}

impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
where
    T: Messenger,
{
    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&amp;mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max &gt;= 1.0 {
            self.messenger.send("에러: 할당량을 초과했습니다!");
        } else if percentage_of_max &gt;= 0.9 {
            self.messenger
                .send("긴급 경고: 할당량의 90% 이상을 사용했습니다!");
        } else if percentage_of_max &gt;= 0.75 {
            self.messenger
                .send("경고: 할당량의 75% 이상을 사용했습니다!");
        }
    }
}</code></pre>
</Listing>
<p>One important part of this code is that the <code>Messenger</code> trait has one method called <code>send</code> that takes an immutable reference to <code>self</code> and the text of the message. This trait is the interface our mock object needs to implement so that the mock can be used in the same way a real object is. The other important part is that we want to test the behavior of the <code>set_value</code> method on the <code>LimitTracker</code>. We can change what we pass in for the <code>value</code> parameter, but <code>set_value</code> doesn’t return anything for us to make assertions on. We want to be able to say that if we create a <code>LimitTracker</code> with something that implements the <code>Messenger</code> trait and a particular value for <code>max</code>, the messenger is told to send the appropriate messages when we pass different numbers for <code>value</code>.</p>
<p>We need a mock object that, instead of sending an email or text message when we call <code>send</code>, will only keep track of the messages it’s told to send. We can create a new instance of the mock object, create a <code>LimitTracker</code> that uses the mock object, call the <code>set_value</code> method on <code>LimitTracker</code>, and then check that the mock object has the messages we expect. Listing 15-21 shows an attempt to implement a mock object to do just that, but the borrow checker won’t allow it.</p>
<Listing number="15-21" file-name="src/lib.rs" caption="An attempt to implement a `MockMessenger` that isn’t allowed by the borrow checker">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("에러: 할당량을 초과했습니다!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("긴급 경고: 할당량의 90% 이상을 사용했습니다!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("경고: 할당량의 75% 이상을 사용했습니다!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec&lt;String&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: vec![],
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}</code></pre>
</Listing>
<p>This test code defines a <code>MockMessenger</code> struct that has a <code>sent_messages</code> field with a <code>Vec</code> of <code>String</code> values to keep track of the messages it’s told to send. We also define an associated function <code>new</code> to make it convenient to create new <code>MockMessenger</code> values that start with an empty list of messages. We then implement the <code>Messenger</code> trait for <code>MockMessenger</code> so that we can give a <code>MockMessenger</code> to a <code>LimitTracker</code>. In the definition of the <code>send</code> method, we take the message passed in as a parameter and store it in the <code>MockMessenger</code> list of <code>sent_messages</code>.</p>
<p>In the test, we’re testing what happens when the <code>LimitTracker</code> is told to set <code>value</code> to something that is more than 75 percent of the <code>max</code> value. First, we create a new <code>MockMessenger</code>, which will start with an empty list of messages. Then, we create a new <code>LimitTracker</code> and give it a reference to the new <code>MockMessenger</code> and a <code>max</code> value of <code>100</code>. We call the <code>set_value</code> method on the <code>LimitTracker</code> with a value of <code>80</code>, which is more than 75 percent of 100. Then, we assert that the list of messages that the <code>MockMessenger</code> is keeping track of should now have one message in it.</p>
<p>하지만 여기에 나타난 것처럼 이 테스트에는 한 가지 문제가 있습니다:</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
error[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a `&amp;` reference
  --&gt; src/lib.rs:58:13
   |
58 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable
   |
help: consider changing this to be a mutable reference in the `impl` method and the `trait` definition
   |
 2 ~     fn send(&amp;mut self, msg: &amp;str);
 3 | }
...
56 |     impl Messenger for MockMessenger {
57 ~         fn send(&amp;mut self, message: &amp;str) {
   |

For more information about this error, try `rustc --explain E0596`.
error: could not compile `limit-tracker` (lib test) due to 1 previous error
</code></pre>
<p>We can’t modify the <code>MockMessenger</code> to keep track of the messages, because the <code>send</code> method takes an immutable reference to <code>self</code>. We also can’t take the suggestion from the error text to use <code>&amp;mut self</code> in both the <code>impl</code> method and the trait definition. We do not want to change the <code>Messenger</code> trait solely for the sake of testing. Instead, we need to find a way to make our test code work correctly with our existing design.</p>
<p>This is a situation in which interior mutability can help! We’ll store the <code>sent_messages</code> within a <code>RefCell&lt;T&gt;</code>, and then the <code>send</code> method will be able to modify <code>sent_messages</code> to store the messages we’ve seen. Listing 15-22 shows what that looks like.</p>
<Listing number="15-22" file-name="src/lib.rs" caption="Using `RefCell<T>` to mutate an inner value while the outer value is considered immutable">
<pre><code class="language-rust noplayground"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("에러: 할당량을 초과했습니다!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("긴급 경고: 할당량의 90% 이상을 사용했습니다!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("경고: 할당량의 75% 이상을 사용했습니다!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: RefCell::new(vec![]),
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --생략--
<span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span>
        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}</code></pre>
</Listing>
<p>이제 <code>sent_messages</code> 필드는 <code>Vec&lt;String&gt;</code> 대신 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> 타입이 되었습니다. <code>new</code> 함수에서는 빈 벡터를 감싸는 새로운 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> 인스턴스를 생성합니다.</p>
<p>For the implementation of the <code>send</code> method, the first parameter is still an immutable borrow of <code>self</code>, which matches the trait definition. We call <code>borrow_mut</code> on the <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> in <code>self.sent_messages</code> to get a mutable reference to the value inside the <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>, which is the vector. Then, we can call <code>push</code> on the mutable reference to the vector to keep track of the messages sent during the test.</p>
<p>The last change we have to make is in the assertion: To see how many items are in the inner vector, we call <code>borrow</code> on the <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> to get an immutable reference to the vector.</p>
<p>이제 <code>RefCell&lt;T&gt;</code>를 사용하는 방법을 살펴보았으니, 내부적으로 어떻게 작동하는지 파헤쳐 봅시다!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="keeping-track-of-borrows-at-runtime-with-refcellt"></a></p>
<h4 id="tracking-borrows-at-runtime"><a class="header" href="#tracking-borrows-at-runtime">Tracking Borrows at Runtime</a></h4>
<p>불변 참조와 가변 참조를 생성할 때, 우리는 각각 <code>&amp;</code>와 <code>&amp;mut</code> 문법을 사용합니다. <code>RefCell&lt;T&gt;</code>의 경우에는 <code>RefCell&lt;T&gt;</code>에 속한 안전한 API인 <code>borrow</code>와 <code>borrow_mut</code> 메서드를 사용합니다. <code>borrow</code> 메서드는 스마트 포인터 타입인 <code>Ref&lt;T&gt;</code>를 반환하고, <code>borrow_mut</code>는 스마트 포인터 타입인 <code>RefMut&lt;T&gt;</code>를 반환합니다. 두 타입 모두 <code>Deref</code>를 구현하므로, 우리는 이들을 일반 참조처럼 다룰 수 있습니다.</p>
<p>The <code>RefCell&lt;T&gt;</code> keeps track of how many <code>Ref&lt;T&gt;</code> and <code>RefMut&lt;T&gt;</code> smart pointers are currently active. Every time we call <code>borrow</code>, the <code>RefCell&lt;T&gt;</code> increases its count of how many immutable borrows are active. When a <code>Ref&lt;T&gt;</code> value goes out of scope, the count of immutable borrows goes down by 1. Just like the compile-time borrowing rules, <code>RefCell&lt;T&gt;</code> lets us have many immutable borrows or one mutable borrow at any point in time.</p>
<p>우리가 만약 이 규칙들을 위반하려고 하면, 참조를 사용할 때처럼 컴파일 에러를 받는 대신 <code>RefCell&lt;T&gt;</code>의 구현체는 런타임에 패닉을 발생시킵니다. 목록 15-23은 목록 15-22의 <code>send</code> 구현을 수정한 모습을 보여줍니다. <code>RefCell&lt;T&gt;</code>가 런타임에 이러한 행위를 방지한다는 것을 설명하기 위해, 동일한 스코프에서 두 개의 활성화된 가변 대여를 의도적으로 생성해 보았습니다.</p>
<Listing number="15-23" file-name="src/lib.rs" caption="Creating two mutable references in the same scope to see that `RefCell<T>` will panic">
<pre><code class="language-rust ignore panics"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("에러: 할당량을 초과했습니다!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("긴급 경고: 할당량의 90% 이상을 사용했습니다!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("경고: 할당량의 75% 이상을 사용했습니다!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">    struct MockMessenger {
</span><span class="boring">        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl MockMessenger {
</span><span class="boring">        fn new() -&gt; MockMessenger {
</span><span class="boring">            MockMessenger {
</span><span class="boring">                sent_messages: RefCell::new(vec![]),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            let mut one_borrow = self.sent_messages.borrow_mut();
            let mut two_borrow = self.sent_messages.borrow_mut();

            one_borrow.push(String::from(message));
            two_borrow.push(String::from(message));
        }
    }
<span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_sends_an_over_75_percent_warning_message() {
</span><span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span><span class="boring">
</span><span class="boring">        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>We create a variable <code>one_borrow</code> for the <code>RefMut&lt;T&gt;</code> smart pointer returned from <code>borrow_mut</code>. Then, we create another mutable borrow in the same way in the variable <code>two_borrow</code>. This makes two mutable references in the same scope, which isn’t allowed. When we run the tests for our library, the code in Listing 15-23 will compile without any errors, but the test will fail:</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/limit_tracker-e599811fa246dbde)

running 1 test
test tests::it_sends_an_over_75_percent_warning_message ... FAILED

failures:

---- tests::it_sends_an_over_75_percent_warning_message stdout ----

thread 'tests::it_sends_an_over_75_percent_warning_message' panicked at src/lib.rs:60:53:
RefCell already borrowed
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_sends_an_over_75_percent_warning_message

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>코드가 <code>already borrowed: BorrowMutError</code>라는 메시지와 함께 패닉을 일으켰다는 점에 주목하세요. 이것이 <code>RefCell&lt;T&gt;</code>가 런타임에 대여 규칙 위반을 처리하는 방식입니다.</p>
<p>여기서 한 것처럼 대여 에러를 컴파일 타임이 아닌 런타임에 잡기로 선택하는 것은, 개발 과정의 더 늦은 시점(아마도 코드가 프로덕션에 배포된 이후일 수도 있음)에 코드의 실수를 발견하게 될 수도 있음을 의미합니다. 또한 코드는 런타임에 대여를 추적하기 때문에 약간의 런타임 성능 저하가 발생할 것입니다. 하지만 <code>RefCell&lt;T&gt;</code>를 사용하면 불변 값만 허용되는 맥락에서 사용되는 동안에도 스스로를 수정하여 본 메시지들을 추적할 수 있는 목 객체를 작성하는 것이 가능해집니다. 이러한 트레이드오프에도 불구하고 일반 참조가 제공하는 것 이상의 기능을 얻기 위해 <code>RefCell&lt;T&gt;</code>를 사용할 수 있습니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="having-multiple-owners-of-mutable-data-by-combining-rc-t-and-ref-cell-t"></a> <a id="allowing-multiple-owners-of-mutable-data-with-rct-and-refcellt"></a></p>
<h3 id="allowing-multiple-owners-of-mutable-data"><a class="header" href="#allowing-multiple-owners-of-mutable-data">Allowing Multiple Owners of Mutable Data</a></h3>
<p>RefCell<T>를 사용하는 일반적인 방법은 Rc<T>와 함께 사용하는 것입니다. Rc<T>를 사용하면 어떤 데이터에 대해 여러 소유자를 가질 수 있지만, 그 데이터에 대해 불변 접근만 제공한다는 것을 기억하세요. RefCell<T>를 보유하는 Rc<T>가 있다면, 여러 소유자를 가질 수 <em>있고</em> 변경할 수도 있는 값을 얻을 수 있습니다!</p>
<p>For example, recall the cons list example in Listing 15-18 where we used <code>Rc&lt;T&gt;</code> to allow multiple lists to share ownership of another list. Because <code>Rc&lt;T&gt;</code> holds only immutable values, we can’t change any of the values in the list once we’ve created them. Let’s add in <code>RefCell&lt;T&gt;</code> for its ability to change the values in the lists. Listing 15-24 shows that by using a <code>RefCell&lt;T&gt;</code> in the <code>Cons</code> definition, we can modify the value stored in all the lists.</p>
<Listing number="15-24" file-name="src/main.rs" caption="Using `Rc<RefCell<i32>>` to create a `List` that we can mutate">
<pre><pre class="playground"><code class="language-rust edition2024">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a));

    *value.borrow_mut() += 10;

    println!("변경 후 a = {a:?}");
    println!("변경 후 b = {b:?}");
    println!("변경 후 c = {c:?}");
}</code></pre></pre>
</Listing>
<p>We create a value that is an instance of <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> and store it in a variable named <code>value</code> so that we can access it directly later. Then, we create a <code>List</code> in <code>a</code> with a <code>Cons</code> variant that holds <code>value</code>. We need to clone <code>value</code> so that both <code>a</code> and <code>value</code> have ownership of the inner <code>5</code> value rather than transferring ownership from <code>value</code> to <code>a</code> or having <code>a</code> borrow from <code>value</code>.</p>
<p>리스트 a를 Rc<T>로 감싸서 리스트 b와 c를 생성할 때 둘 다 a를 참조할 수 있도록 합니다. 이는 목록 15-18에서 했던 것과 같습니다.</p>
<p>After we’ve created the lists in <code>a</code>, <code>b</code>, and <code>c</code>, we want to add 10 to the value in <code>value</code>. We do this by calling <code>borrow_mut</code> on <code>value</code>, which uses the automatic dereferencing feature we discussed in <a href="ch05-03-method-syntax.html#wheres-the---operator">“Where’s the <code>-&gt;</code> Operator?”</a><!-- ignore --> in Chapter 5 to dereference the <code>Rc&lt;T&gt;</code> to the inner <code>RefCell&lt;T&gt;</code> value. The <code>borrow_mut</code> method returns a <code>RefMut&lt;T&gt;</code> smart pointer, and we use the dereference operator on it and change the inner value.</p>
<p>When we print <code>a</code>, <code>b</code>, and <code>c</code>, we can see that they all have the modified value of <code>15</code> rather than <code>5</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.63s
     Running `target/debug/cons-list`
변경 후 a = Cons(RefCell { value: 15 }, Nil)
변경 후 b = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))
변경 후 c = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<p>This technique is pretty neat! By using <code>RefCell&lt;T&gt;</code>, we have an outwardly immutable <code>List</code> value. But we can use the methods on <code>RefCell&lt;T&gt;</code> that provide access to its interior mutability so that we can modify our data when we need to. The runtime checks of the borrowing rules protect us from data races, and it’s sometimes worth trading a bit of speed for this flexibility in our data structures. Note that <code>RefCell&lt;T&gt;</code> does not work for multithreaded code! <code>Mutex&lt;T&gt;</code> is the thread-safe version of <code>RefCell&lt;T&gt;</code>, and we’ll discuss <code>Mutex&lt;T&gt;</code> in Chapter 16.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch15-04-rc.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch15-06-reference-cycles.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch15-04-rc.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch15-06-reference-cycles.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
