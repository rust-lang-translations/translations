<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Adding Functionality with Test Driven Development - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch12-04-testing-the-librarys-functionality.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch12-04-testing-the-librarys-functionality.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Old headings. Do not remove or links may break. -->
<p><a id="developing-the-librarys-functionality-with-test-driven-development"></a></p>
<h2 id="adding-functionality-with-test-driven-development"><a class="header" href="#adding-functionality-with-test-driven-development">Adding Functionality with Test-Driven Development</a></h2>
<p>Now that we have the search logic in <em>src/lib.rs</em> separate from the <code>main</code> function, it’s much easier to write tests for the core functionality of our code. We can call functions directly with various arguments and check return values without having to call our binary from the command line.</p>
<p>이 섹션에서는 다음과 같은 단계의 테스트 주도 개발(TDD) 프로세스를 사용하여 <code>minigrep</code> 프로그램에 검색 로직을 추가하겠습니다:</p>
<ol>
<li>실패하는 테스트를 작성하고 실행하여, 예상한 이유로 실패하는지 확인합니다.</li>
<li>새로운 테스트를 통과시키기에 딱 필요한 만큼만 코드를 작성하거나 수정합니다.</li>
<li>방금 추가하거나 변경한 코드를 리팩터링하고 테스트가 계속 통과하는지 확인합니다.</li>
<li>1단계부터 반복합니다!</li>
</ol>
<p>Though it’s just one of many ways to write software, TDD can help drive code design. Writing the test before you write the code that makes the test pass helps maintain high test coverage throughout the process.</p>
<p>파일 내용에서 검색어 문자열을 실제로 검색하고 검색어와 일치하는 줄 목록을 생성하는 기능의 구현을 TDD로 진행해 보겠습니다. 이 기능을 <code>search</code>라는 함수에 추가하겠습니다.</p>
<h3 id="실패하는-테스트-작성하기"><a class="header" href="#실패하는-테스트-작성하기">실패하는 테스트 작성하기</a></h3>
<p>In <em>src/lib.rs</em>, we’ll add a <code>tests</code> module with a test function, as we did in <a href="ch11-01-writing-tests.html#the-anatomy-of-a-test-function">Chapter 11</a><!-- ignore -->. The test function specifies the behavior we want the <code>search</code> function to have: It will take a query and the text to search, and it will return only the lines from the text that contain the query. Listing 12-15 shows this test.</p>
<Listing number="12-15" file-name="src/lib.rs" caption="Creating a failing test for the `search` function for the functionality we wish we had">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    unimplemented!();
</span><span class="boring">}
</span><span class="boring">
</span>// --생략--

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_result() {
        let query = "duct";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.";

        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
    }
}</code></pre>
</Listing>
<p>이 테스트는 <code>"duct"</code>라는 문자열을 검색합니다. 검색 대상 텍스트는 세 줄이며, 그중 한 줄만 <code>"duct"</code>를 포함하고 있습니다(여는 따옴표 뒤의 백슬래시는 러스트에게 이 문자열 리터럴의 시작 부분에 개행 문자를 넣지 말라고 알려주는 것임에 주의하세요). 우리는 <code>search</code> 함수에서 반환된 값이 우리가 기대하는 줄만 포함하고 있는지 단언합니다.</p>
<p>If we run this test, it will currently fail because the <code>unimplemented!</code> macro panics with the message “not implemented”. In accordance with TDD principles, we’ll take a small step of adding just enough code to get the test to not panic when calling the function by defining the <code>search</code> function to always return an empty vector, as shown in Listing 12-16. Then, the test should compile and fail because an empty vector doesn’t match a vector containing the line <code>"safe, fast, productive."</code>.</p>
<Listing number="12-16" file-name="src/lib.rs" caption="Defining just enough of the `search` function so that calling it won’t panic">
<pre><code class="language-rust noplayground">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    vec![]
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>Now let’s discuss why we need to define an explicit lifetime <code>'a</code> in the signature of <code>search</code> and use that lifetime with the <code>contents</code> argument and the return value. Recall in <a href="ch10-03-lifetime-syntax.html">Chapter 10</a><!-- ignore --> that the lifetime parameters specify which argument lifetime is connected to the lifetime of the return value. In this case, we indicate that the returned vector should contain string slices that reference slices of the argument <code>contents</code> (rather than the argument <code>query</code>).</p>
<p>다시 말해, 우리는 <code>search</code> 함수가 반환하는 데이터가 <code>contents</code> 인수로 전달된 데이터만큼 오래 살 것이라고 러스트에게 알려주는 것입니다. 이는 중요합니다! 슬라이스에 의해 참조되는 데이터는 그 참조가 유효한 동안 반드시 유효해야 합니다. 만약 컴파일러가 우리가 <code>contents</code>가 아닌 <code>query</code>의 문자열 슬라이스를 만든다고 가정한다면, 안전성 검사를 잘못 수행하게 될 것입니다.</p>
<p>만약 라이프타임 명시를 잊어버리고 이 함수를 컴파일하려고 하면, 다음과 같은 에러가 발생합니다:</p>
<pre><code class="language-console">$ cargo build
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
error[E0106]: missing lifetime specifier
 --&gt; src/lib.rs:1:51
  |
1 | pub fn search(query: &amp;str, contents: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
  |                      ----            ----         ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `query` or `contents`
help: consider introducing a named lifetime parameter
  |
1 | pub fn search&lt;'a&gt;(query: &amp;'a str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
  |              ++++         ++                 ++              ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `minigrep` (lib) due to 1 previous error
</code></pre>
<p>Rust can’t know which of the two parameters we need for the output, so we need to tell it explicitly. Note that the help text suggests specifying the same lifetime parameter for all the parameters and the output type, which is incorrect! Because <code>contents</code> is the parameter that contains all of our text and we want to return the parts of that text that match, we know <code>contents</code> is the only parameter that should be connected to the return value using the lifetime syntax.</p>
<p>다른 프로그래밍 언어들은 시그니처에서 인수와 반환 값을 연결할 것을 요구하지 않지만, 이 관행은 시간이 지남에 따라 익숙해질 것입니다. 이 예제를 10장의 <a href="ch10-03-lifetime-syntax.html#validating-references-with-lifetimes">“라이프타임으로 참조 유효성 검증하기”</a><!-- ignore --> 섹션에 있는 예제들과 비교해 보는 것도 좋을 것입니다.</p>
<h3 id="테스트를-통과시키기-위한-코드-작성하기"><a class="header" href="#테스트를-통과시키기-위한-코드-작성하기">테스트를 통과시키기 위한 코드 작성하기</a></h3>
<p>현재 우리 테스트는 항상 빈 벡터를 반환하기 때문에 실패하고 있습니다. 이를 해결하고 <code>search</code>를 구현하기 위해, 우리 프로그램은 다음과 같은 단계들을 거쳐야 합니다:</p>
<ol>
<li>내용의 각 줄을 반복합니다.</li>
<li>해당 줄이 검색어 문자열을 포함하고 있는지 확인합니다.</li>
<li>포함하고 있다면, 반환할 값 목록에 추가합니다.</li>
<li>포함하고 있지 않다면, 아무것도 하지 않습니다.</li>
<li>일치하는 결과 목록을 반환합니다.</li>
</ol>
<p>각 단계를 차례대로 진행해 보죠. 먼저 줄들을 반복하는 것부터 시작합니다.</p>
<h4 id="lines-메서드로-줄-반복하기"><a class="header" href="#lines-메서드로-줄-반복하기"><code>lines</code> 메서드로 줄 반복하기</a></h4>
<p>Rust has a helpful method to handle line-by-line iteration of strings, conveniently named <code>lines</code>, that works as shown in Listing 12-17. Note that this won’t compile yet.</p>
<Listing number="12-17" file-name="src/lib.rs" caption="Iterating through each line in `contents`">
<pre><code class="language-rust ignore does_not_compile">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        // 여기서 line으로 무언가를 합니다
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>The <code>lines</code> method returns an iterator. We’ll talk about iterators in depth in <a href="ch13-02-iterators.html">Chapter 13</a><!-- ignore -->. But recall that you saw this way of using an iterator in <a href="ch03-05-control-flow.html#looping-through-a-collection-with-for">Listing 3-5</a><!-- ignore -->, where we used a <code>for</code> loop with an iterator to run some code on each item in a collection.</p>
<h4 id="각-줄에서-검색어-찾기"><a class="header" href="#각-줄에서-검색어-찾기">각 줄에서 검색어 찾기</a></h4>
<p>다음으로, 현재 줄이 우리 검색어 문자열을 포함하고 있는지 확인하겠습니다. 다행히 문자열에는 이를 대신해 주는 <code>contains</code>라는 유용한 메서드가 있습니다! 목록 12-18에 나온 것처럼 <code>search</code> 함수에서 <code>contains</code> 메서드를 호출하도록 추가하세요. 이 코드는 여전히 컴파일되지 않는다는 점에 주의하세요.</p>
<Listing number="12-18" file-name="src/lib.rs" caption="Adding functionality to see whether the line contains the string in `query`">
<pre><code class="language-rust ignore does_not_compile">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        if line.contains(query) {
            // 여기서 line으로 무언가를 합니다
        }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>현재 우리는 기능을 하나씩 만들어가는 중입니다. 코드를 컴파일하려면, 함수 시그니처에서 명시한 대로 본문에서 값을 반환해야 합니다.</p>
<h4 id="일치하는-줄-저장하기"><a class="header" href="#일치하는-줄-저장하기">일치하는 줄 저장하기</a></h4>
<p>이 함수를 완성하려면, 우리가 반환하고자 하는 일치하는 줄들을 저장할 방법이 필요합니다. 이를 위해 <code>for</code> 루프 이전에 가변 벡터를 만들고, 벡터의 <code>push</code> 메서드를 호출하여 <code>line</code>을 저장할 수 있습니다. <code>for</code> 루프가 끝난 뒤에는 목록 12-19와 같이 벡터를 반환합니다.</p>
<Listing number="12-19" file-name="src/lib.rs" caption="Storing the lines that match so that we can return them">
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = "duct";
</span><span class="boring">        let contents = "\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.";
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec!["safe, fast, productive."], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>이제 <code>search</code> 함수는 <code>query</code>를 포함하는 줄들만 반환해야 하며, 우리 테스트는 통과해야 합니다. 테스트를 실행해 봅시다:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.22s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::one_result ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>테스트가 통과했으니, 우리는 이것이 작동한다는 것을 압니다!</p>
<p>이 시점에서, 동일한 기능을 유지하면서 테스트를 통과시킨 채로 <code>search</code> 함수의 구현을 리팩터링할 기회를 고려해 볼 수 있습니다. <code>search</code> 함수의 코드가 나쁘지는 않지만, 반복자의 몇몇 유용한 기능을 활용하고 있지는 않습니다. <a href="ch13-02-iterators.html">13장</a><!-- ignore -->에서 반복자를 자세히 다루며 이 예제로 돌아와 어떻게 개선할 수 있는지 살펴보겠습니다.</p>
<p>이제 프로그램 전체가 작동할 것입니다! 먼저 에밀리 디킨슨의 시에서 정확히 한 줄만 반환해야 하는 단어인 _frog_로 테스트해 봅시다.</p>
<pre><code class="language-console">$ cargo run -- frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.38s
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
</code></pre>
<p>멋지네요! 이번에는 _body_와 같이 여러 줄에 매칭되는 단어를 시도해 봅시다:</p>
<pre><code class="language-console">$ cargo run -- body poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep body poem.txt`
I'm nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>마지막으로, 시의 어디에도 없는 단어인 _monomorphization_으로 검색했을 때 아무런 줄도 나오지 않는지 확인해 봅시다.</p>
<pre><code class="language-console">$ cargo run -- monomorphization poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep monomorphization poem.txt`
</code></pre>
<p>훌륭합니다! 우리는 고전적인 도구의 미니 버전을 직접 만들어 보았고, 애플리케이션을 구조화하는 방법에 대해 많은 것을 배웠습니다. 또한 파일 입출력, 라이프타임, 테스팅, 그리고 명령줄 파싱에 대해서도 조금 더 알게 되었습니다.</p>
<p>이 프로젝트를 마무리하기 위해, 명령줄 프로그램을 작성할 때 유용한 환경 변수 사용법과 표준 에러 출력 방법을 간략히 시연해 보겠습니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch12-03-improving-error-handling-and-modularity.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch12-05-working-with-environment-variables.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch12-03-improving-error-handling-and-modularity.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch12-05-working-with-environment-variables.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
