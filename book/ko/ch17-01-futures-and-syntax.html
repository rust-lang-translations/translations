<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Future와 Async 문법 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch17-01-futures-and-syntax.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch17-01-futures-and-syntax.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="future와-async-문법"><a class="header" href="#future와-async-문법">Future와 Async 문법</a></h2>
<p>러스트 비동기 프로그래밍의 핵심 요소는 _퓨처(futures)_와 러스트의 <code>async</code> 및 <code>await</code> 키워드입니다.</p>
<p>A <em>future</em> is a value that may not be ready now but will become ready at some point in the future. (This same concept shows up in many languages, sometimes under other names such as <em>task</em> or <em>promise</em>.) Rust provides a <code>Future</code> trait as a building block so that different async operations can be implemented with different data structures but with a common interface. In Rust, futures are types that implement the <code>Future</code> trait. Each future holds its own information about the progress that has been made and what “ready” means.</p>
<p>You can apply the <code>async</code> keyword to blocks and functions to specify that they can be interrupted and resumed. Within an async block or async function, you can use the <code>await</code> keyword to <em>await a future</em> (that is, wait for it to become ready). Any point where you await a future within an async block or function is a potential spot for that block or function to pause and resume. The process of checking with a future to see if its value is available yet is called <em>polling</em>.</p>
<p>Some other languages, such as C# and JavaScript, also use <code>async</code> and <code>await</code> keywords for async programming. If you’re familiar with those languages, you may notice some significant differences in how Rust handles the syntax. That’s for good reason, as we’ll see!</p>
<p>비동기 러스트를 작성할 때, 우리는 대부분 <code>async</code>와 <code>await</code> 키워드를 사용합니다. 러스트는 <code>for</code> 루프를 <code>Iterator</code> 트레이트를 사용하여 동등한 코드로 컴파일하는 것과 마찬가지로, 이들을 <code>Future</code> 트레이트를 사용하여 동등한 코드로 컴파일합니다. 하지만 러스트가 <code>Future</code> 트레이트를 제공하므로, 필요할 때 자신만의 데이터 타입에 대해 이를 구현할 수도 있습니다. 이 장 전반에 걸쳐 보게 될 많은 함수들은 <code>Future</code>에 대한 자체 구현을 가진 타입을 반환합니다. 이 장의 끝에서 트레이트의 정의로 돌아가 작동 방식에 대해 더 자세히 알아볼 것이지만, 지금은 앞으로 나아가기에 충분한 세부 사항입니다.</p>
<p>이 모든 것이 다소 추상적으로 느껴질 수 있으므로, 첫 번째 비동기 프로그램인 작은 웹 스크래퍼를 작성해 봅시다. 명령줄에서 두 개의 URL을 전달하고, 두 URL을 동시에 가져와서 먼저 완료되는 URL의 결과를 반환할 것입니다. 이 예제에는 꽤 많은 새로운 문법이 포함되겠지만 걱정하지 마세요. 진행하면서 필요한 모든 것을 설명해 드리겠습니다.</p>
<h2 id="첫-번째-비동기-프로그램"><a class="header" href="#첫-번째-비동기-프로그램">첫 번째 비동기 프로그램</a></h2>
<p>이 장의 초점을 생태계의 여러 부분을 조정하는 것보다 비동기를 배우는 데 맞추기 위해, 우리는 <code>trpl</code> 크레이트를 만들었습니다(<code>trpl</code>은 "The Rust Programming Language"의 줄임말입니다). 이 크레이트는 주로 <a href="https://crates.io/crates/futures"><code>futures</code></a><!-- ignore -->와 <a href="https://tokio.rs"><code>tokio</code></a><!-- ignore --> 크레이트에서 필요한 모든 타입, 트레이트, 함수를 다시 내보냅니다. <code>futures</code> 크레이트는 비동기 코드에 대한 러스트 실험의 공식적인 본거지이며, 실제로 <code>Future</code> 트레이트가 원래 설계된 곳입니다. Tokio는 오늘날 러스트에서 가장 널리 사용되는 비동기 런타임이며, 특히 웹 애플리케이션에서 그렇습니다. 그 밖에도 훌륭한 런타임이 있으며, 여러분의 목적에 더 적합할 수도 있습니다. 우리는 <code>trpl</code>의 내부에서 <code>tokio</code> 크레이트를 사용하는데, 이는 잘 테스트되어 있고 널리 사용되기 때문입니다.</p>
<p>In some cases, <code>trpl</code> also renames or wraps the original APIs to keep you focused on the details relevant to this chapter. If you want to understand what the crate does, we encourage you to check out <a href="https://github.com/rust-lang/book/tree/main/packages/trpl">its source code</a>. You’ll be able to see what crate each re-export comes from, and we’ve left extensive comments explaining what the crate does.</p>
<p><code>hello-async</code>라는 이름의 새 바이너리 프로젝트를 생성하고 <code>trpl</code> 크레이트를 의존성으로 추가하세요:</p>
<pre><code class="language-console">$ cargo new hello-async
$ cd hello-async
$ cargo add trpl
</code></pre>
<p>이제 <code>trpl</code>이 제공하는 다양한 조각들을 사용하여 우리의 첫 번째 비동기 프로그램을 작성할 수 있습니다. 두 개의 웹 페이지를 가져와서 각각 <code>&lt;title&gt;</code> 요소를 추출하고, 그 전체 과정을 먼저 완료하는 페이지의 제목을 출력하는 작은 명령줄 도구를 만들 것입니다.</p>
<h3 id="page_title-함수-정의하기"><a class="header" href="#page_title-함수-정의하기">page_title 함수 정의하기</a></h3>
<p>Let’s start by writing a function that takes one page URL as a parameter, makes a request to it, and returns the text of the <code>&lt;title&gt;</code> element (see Listing 17-1).</p>
<Listing number="17-1" file-name="src/main.rs" caption="Defining an async function to get the title element from an HTML page">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // TODO: 이건 다음에 추가할 것입니다!
</span><span class="boring">}
</span><span class="boring">
</span>use trpl::Html;

async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
    let response = trpl::get(url).await;
    let response_text = response.text().await;
    Html::parse(&amp;response_text)
        .select_first("title")
        .map(|title| title.inner_html())
}</code></pre></pre>
</Listing>
<p>First, we define a function named <code>page_title</code> and mark it with the <code>async</code> keyword. Then we use the <code>trpl::get</code> function to fetch whatever URL is passed in and add the <code>await</code> keyword to await the response. To get the text of the <code>response</code>, we call its <code>text</code> method and once again await it with the <code>await</code> keyword. Both of these steps are asynchronous. For the <code>get</code> function, we have to wait for the server to send back the first part of its response, which will include HTTP headers, cookies, and so on and can be delivered separately from the response body. Especially if the body is very large, it can take some time for it all to arrive. Because we have to wait for the <em>entirety</em> of the response to arrive, the <code>text</code> method is also async.</p>
<p>We have to explicitly await both of these futures, because futures in Rust are <em>lazy</em>: they don’t do anything until you ask them to with the <code>await</code> keyword. (In fact, Rust will show a compiler warning if you don’t use a future.) This might remind you of the discussion of iterators in the <a href="ch13-02-iterators.html">“Processing a Series of Items with Iterators”</a><!-- ignore --> section in Chapter 13. Iterators do nothing unless you call their <code>next</code> method—whether directly or by using <code>for</code> loops or methods such as <code>map</code> that use <code>next</code> under the hood. Likewise, futures do nothing unless you explicitly ask them to. This laziness allows Rust to avoid running async code until it’s actually needed.</p>
<blockquote>
<p>Note: This is different from the behavior we saw when using <code>thread::spawn</code> in the <a href="ch16-01-threads.html#creating-a-new-thread-with-spawn">“Creating a New Thread with spawn”</a><!-- ignore --> section in Chapter 16, where the closure we passed to another thread started running immediately. It’s also different from how many other languages approach async. But it’s important for Rust to be able to provide its performance guarantees, just as it is with iterators.</p>
</blockquote>
<p>Once we have <code>response_text</code>, we can parse it into an instance of the <code>Html</code> type using <code>Html::parse</code>. Instead of a raw string, we now have a data type we can use to work with the HTML as a richer data structure. In particular, we can use the <code>select_first</code> method to find the first instance of a given CSS selector. By passing the string <code>"title"</code>, we’ll get the first <code>&lt;title&gt;</code> element in the document, if there is one. Because there may not be any matching element, <code>select_first</code> returns an <code>Option&lt;ElementRef&gt;</code>. Finally, we use the <code>Option::map</code> method, which lets us work with the item in the <code>Option</code> if it’s present, and do nothing if it isn’t. (We could also use a <code>match</code> expression here, but <code>map</code> is more idiomatic.) In the body of the function we supply to <code>map</code>, we call <code>inner_html</code> on the <code>title</code> to get its content, which is a <code>String</code>. When all is said and done, we have an <code>Option&lt;String&gt;</code>.</p>
<p>Notice that Rust’s <code>await</code> keyword goes <em>after</em> the expression you’re awaiting, not before it. That is, it’s a <em>postfix</em> keyword. This may differ from what you’re used to if you’ve used <code>async</code> in other languages, but in Rust it makes chains of methods much nicer to work with. As a result, we could change the body of <code>page_title</code> to chain the <code>trpl::get</code> and <code>text</code> function calls together with <code>await</code> between them, as shown in Listing 17-2.</p>
<Listing number="17-2" file-name="src/main.rs" caption="Chaining with the `await` keyword">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use trpl::Html;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // TODO: 이건 다음에 추가할 것입니다!
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
</span>    let response_text = trpl::get(url).await.text().await;
<span class="boring">    Html::parse(&amp;response_text)
</span><span class="boring">        .select_first("title")
</span><span class="boring">        .map(|title| title.inner_html())
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>이로써 우리는 첫 번째 비동기 함수를 성공적으로 작성했습니다! <code>main</code>에 코드를 추가하여 호출하기 전에, 우리가 작성한 내용과 그 의미에 대해 조금 더 이야기해 봅시다.</p>
<p>When Rust sees a <em>block</em> marked with the <code>async</code> keyword, it compiles it into a unique, anonymous data type that implements the <code>Future</code> trait. When Rust sees a <em>function</em> marked with <code>async</code>, it compiles it into a non-async function whose body is an async block. An async function’s return type is the type of the anonymous data type the compiler creates for that async block.</p>
<p>Thus, writing <code>async fn</code> is equivalent to writing a function that returns a <em>future</em> of the return type. To the compiler, a function definition such as the <code>async fn page_title</code> in Listing 17-1 is roughly equivalent to a non-async function defined like this:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span>use std::future::Future;
use trpl::Html;

fn page_title(url: &amp;str) -&gt; impl Future&lt;Output = Option&lt;String&gt;&gt; {
    async move {
        let text = trpl::get(url).await.text().await;
        Html::parse(&amp;text)
            .select_first("title")
            .map(|title| title.inner_html())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>변환된 버전의 각 부분을 살펴봅시다:</p>
<ul>
<li>이것은 10장의 <a href="ch10-02-traits.html#traits-as-parameters">“매개변수로서의 트레이트”</a><!-- ignore --> 섹션에서 논의했던 <code>impl Trait</code> 문법을 사용합니다.</li>
<li>The returned value implements the <code>Future</code> trait with an associated type of <code>Output</code>. Notice that the <code>Output</code> type is <code>Option&lt;String&gt;</code>, which is the same as the original return type from the <code>async fn</code> version of <code>page_title</code>.</li>
<li>원래 함수의 본문에서 호출된 모든 코드는 <code>async move</code> 블록으로 감싸져 있습니다. 블록이 표현식이라는 것을 기억하세요. 이 전체 블록은 함수에서 반환되는 표현식입니다.</li>
<li>이 비동기 블록은 방금 설명한 대로 <code>Option&lt;String&gt;</code> 타입의 값을 생성합니다. 그 값은 반환 타입의 <code>Output</code> 타입과 일치합니다. 이것은 여러분이 보아온 다른 블록과 같습니다.</li>
<li>새로운 함수 본문은 <code>url</code> 매개변수를 사용하는 방식 때문에 <code>async move</code> 블록입니다. (<code>async</code>와 <code>async move</code>의 차이점에 대해서는 이 장의 뒷부분에서 더 자세히 이야기할 것입니다.)</li>
</ul>
<p>이제 <code>main</code>에서 <code>page_title</code>을 호출할 수 있습니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id ="determining-a-single-pages-title"></a></p>
<h3 id="executing-an-async-function-with-a-runtime"><a class="header" href="#executing-an-async-function-with-a-runtime">Executing an Async Function with a Runtime</a></h3>
<p>To start, we’ll get the title for a single page, shown in Listing 17-3. Unfortunately, this code doesn’t compile yet.</p>
<Listing number="17-3" file-name="src/main.rs" caption="Calling the `page_title` function from `main` with a user-supplied argument">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use trpl::Html;
</span><span class="boring">
</span>async fn main() {
    let args: Vec&lt;String&gt; = std::env::args().collect();
    let url = &amp;args[1];
    match page_title(url).await {
        Some(title) =&gt; println!("The title for {url} was {title}"),
        None =&gt; println!("{url} had no title"),
    }
}
<span class="boring">
</span><span class="boring">async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
</span><span class="boring">    let response_text = trpl::get(url).await.text().await;
</span><span class="boring">    Html::parse(&amp;response_text)
</span><span class="boring">        .select_first("title")
</span><span class="boring">        .map(|title| title.inner_html())
</span><span class="boring">}</span></code></pre>
</Listing>
<p>We follow the same pattern we used to get command line arguments in the <a href="ch12-01-accepting-command-line-arguments.html">“Accepting Command Line Arguments”</a><!-- ignore --> section in Chapter 12. Then we pass the URL argument to <code>page_title</code> and await the result. Because the value produced by the future is an <code>Option&lt;String&gt;</code>, we use a <code>match</code> expression to print different messages to account for whether the page had a <code>&lt;title&gt;</code>.</p>
<p>The only place we can use the <code>await</code> keyword is in async functions or blocks, and Rust won’t let us mark the special <code>main</code> function as <code>async</code>.</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-03
cargo build
copy just the compiler error
-->
<pre><code class="language-text">error[E0752]: `main` function is not allowed to be `async`
 --&gt; src/main.rs:6:1
  |
6 | async fn main() {
  | ^^^^^^^^^^^^^^^ `main` function is not allowed to be `async`
</code></pre>
<p>The reason <code>main</code> can’t be marked <code>async</code> is that async code needs a <em>runtime</em>: a Rust crate that manages the details of executing asynchronous code. A program’s <code>main</code> function can <em>initialize</em> a runtime, but it’s not a runtime <em>itself</em>. (We’ll see more about why this is the case in a bit.) Every Rust program that executes async code has at least one place where it sets up a runtime that executes the futures.</p>
<p>Most languages that support async bundle a runtime, but Rust does not. Instead, there are many different async runtimes available, each of which makes different tradeoffs suitable to the use case it targets. For example, a high-throughput web server with many CPU cores and a large amount of RAM has very different needs than a microcontroller with a single core, a small amount of RAM, and no heap allocation ability. The crates that provide those runtimes also often supply async versions of common functionality such as file or network I/O.</p>
<p>Here, and throughout the rest of this chapter, we’ll use the <code>block_on</code> function from the <code>trpl</code> crate, which takes a future as an argument and blocks the current thread until this future runs to completion. Behind the scenes, calling <code>block_on</code> sets up a runtime using the <code>tokio</code> crate that’s used to run the future passed in (the <code>trpl</code> crate’s <code>block_on</code> behavior is similar to other runtime crates’ <code>block_on</code> functions). Once the future completes, <code>block_on</code> returns whatever value the future produced.</p>
<p>We could pass the future returned by <code>page_title</code> directly to <code>block_on</code> and, once it completed, we could match on the resulting <code>Option&lt;String&gt;</code> as we tried to do in Listing 17-3. However, for most of the examples in the chapter (and most async code in the real world), we’ll be doing more than just one async function call, so instead we’ll pass an <code>async</code> block and explicitly await the result of the <code>page_title</code> call, as in Listing 17-4.</p>
<Listing number="17-4" caption="Awaiting an async block with `trpl::block_on`" file-name="src/main.rs">
<!-- should_panic,noplayground because mdbook test does not pass args -->
<pre><code class="language-rust should_panic noplayground"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use trpl::Html;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = std::env::args().collect();

    trpl::block_on(async {
        let url = &amp;args[1];
        match page_title(url).await {
            Some(title) =&gt; println!("The title for {url} was {title}"),
            None =&gt; println!("{url} had no title"),
        }
    })
}
<span class="boring">
</span><span class="boring">async fn page_title(url: &amp;str) -&gt; Option&lt;String&gt; {
</span><span class="boring">    let response_text = trpl::get(url).await.text().await;
</span><span class="boring">    Html::parse(&amp;response_text)
</span><span class="boring">        .select_first("title")
</span><span class="boring">        .map(|title| title.inner_html())
</span><span class="boring">}</span></code></pre>
</Listing>
<p>이 코드를 실행하면 처음에 예상했던 동작을 얻을 수 있습니다:</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-04
cargo build # skip all the build noise
cargo run -- "https://www.rust-lang.org"
# copy the output here
-->
<pre><code class="language-console">$ cargo run -- "https://www.rust-lang.org"
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.05s
     Running `target/debug/async_await 'https://www.rust-lang.org'`
The title for https://www.rust-lang.org was
            Rust Programming Language
</code></pre>
<p>Phew—we finally have some working async code! But before we add the code to race two sites against each other, let’s briefly turn our attention back to how futures work.</p>
<p>Each <em>await point</em>—that is, every place where the code uses the <code>await</code> keyword—represents a place where control is handed back to the runtime. To make that work, Rust needs to keep track of the state involved in the async block so that the runtime could kick off some other work and then come back when it’s ready to try advancing the first one again. This is an invisible state machine, as if you’d written an enum like this to save the current state at each await point:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span>enum PageTitleFuture&lt;'a&gt; {
    Initial { url: &amp;'a str },
    GetAwaitPoint { url: &amp;'a str },
    TextAwaitPoint { response: trpl::Response },
}
<span class="boring">}</span></code></pre></pre>
<p>하지만 각 상태 간의 전환 코드를 직접 작성하는 것은 지루하고 오류가 발생하기 쉽습니다. 특히 나중에 코드에 더 많은 기능과 상태를 추가해야 할 때는 더욱 그렇습니다. 다행히도 러스트 컴파일러는 비동기 코드를 위한 상태 머신 데이터 구조를 자동으로 생성하고 관리합니다. 데이터 구조에 대한 일반적인 대여 및 소유권 규칙이 모두 여전히 적용되며, 다행히도 컴파일러가 우리를 위해 이를 확인하고 유용한 에러 메시지를 제공합니다. 이 장의 뒷부분에서 몇 가지 예를 살펴볼 것입니다.</p>
<p>Ultimately, something has to execute this state machine, and that something is a runtime. (This is why you may come across mentions of <em>executors</em> when looking into runtimes: an executor is the part of a runtime responsible for executing the async code.)</p>
<p>Now you can see why the compiler stopped us from making <code>main</code> itself an async function back in Listing 17-3. If <code>main</code> were an async function, something else would need to manage the state machine for whatever future <code>main</code> returned, but <code>main</code> is the starting point for the program! Instead, we called the <code>trpl::block_on</code> function in <code>main</code> to set up a runtime and run the future returned by the <code>async</code> block until it’s done.</p>
<blockquote>
<p>Note: Some runtimes provide macros so you <em>can</em> write an async <code>main</code> function. Those macros rewrite <code>async fn main() { ... }</code> to be a normal <code>fn main</code>, which does the same thing we did by hand in Listing 17-4: call a function that runs a future to completion the way <code>trpl::block_on</code> does.</p>
</blockquote>
<p>이제 이 조각들을 모아서 동시성 코드를 어떻게 작성할 수 있는지 살펴봅시다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="racing-our-two-urls-against-each-other"></a></p>
<h3 id="racing-two-urls-against-each-other-concurrently"><a class="header" href="#racing-two-urls-against-each-other-concurrently">Racing Two URLs Against Each Other Concurrently</a></h3>
<p>In Listing 17-5, we call <code>page_title</code> with two different URLs passed in from the command line and race them by selecting whichever future finishes first.</p>
<Listing number="17-5" caption="Calling `page_title` for two URLs to see which returns first" file-name="src/main.rs">
<!-- should_panic,noplayground because mdbook does not pass args -->
<pre><code class="language-rust should_panic noplayground"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span>use trpl::{Either, Html};

fn main() {
    let args: Vec&lt;String&gt; = std::env::args().collect();

    trpl::block_on(async {
        let title_fut_1 = page_title(&amp;args[1]);
        let title_fut_2 = page_title(&amp;args[2]);

        let (url, maybe_title) =
            match trpl::select(title_fut_1, title_fut_2).await {
                Either::Left(left) =&gt; left,
                Either::Right(right) =&gt; right,
            };

        println!("{url} returned first");
        match maybe_title {
            Some(title) =&gt; println!("Its page title was: '{title}'"),
            None =&gt; println!("It had no title."),
        }
    })
}

async fn page_title(url: &amp;str) -&gt; (&amp;str, Option&lt;String&gt;) {
    let response_text = trpl::get(url).await.text().await;
    let title = Html::parse(&amp;response_text)
        .select_first("title")
        .map(|title| title.inner_html());
    (url, title)
}</code></pre>
</Listing>
<p>We begin by calling <code>page_title</code> for each of the user-supplied URLs. We save the resulting futures as <code>title_fut_1</code> and <code>title_fut_2</code>. Remember, these don’t do anything yet, because futures are lazy and we haven’t yet awaited them. Then we pass the futures to <code>trpl::select</code>, which returns a value to indicate which of the futures passed to it finishes first.</p>
<blockquote>
<p>Note: Under the hood, <code>trpl::select</code> is built on a more general <code>select</code> function defined in the <code>futures</code> crate. The <code>futures</code> crate’s <code>select</code> function can do a lot of things that the <code>trpl::select</code> function can’t, but it also has some additional complexity that we can skip over for now.</p>
</blockquote>
<p>Either future can legitimately “win,” so it doesn’t make sense to return a <code>Result</code>. Instead, <code>trpl::select</code> returns a type we haven’t seen before, <code>trpl::Either</code>. The <code>Either</code> type is somewhat similar to a <code>Result</code> in that it has two cases. Unlike <code>Result</code>, though, there is no notion of success or failure baked into <code>Either</code>. Instead, it uses <code>Left</code> and <code>Right</code> to indicate “one or the other”:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Either&lt;A, B&gt; {
    Left(A),
    Right(B),
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>select</code> function returns <code>Left</code> with that future’s output if the first argument wins, and <code>Right</code> with the second future argument’s output if <em>that</em> one wins. This matches the order the arguments appear in when calling the function: the first argument is to the left of the second argument.</p>
<p>우리는 또한 전달된 동일한 URL을 반환하도록 <code>page_title</code>을 업데이트합니다. 그렇게 하면 먼저 반환된 페이지에 우리가 해결할 수 있는 <code>&lt;title&gt;</code>이 없더라도 여전히 의미 있는 메시지를 출력할 수 있습니다. 해당 정보를 사용할 수 있게 되면, 어떤 URL이 먼저 완료되었는지와 해당 URL의 웹 페이지에 대한 <code>&lt;title&gt;</code>이 있다면 무엇인지를 모두 나타내도록 <code>println!</code> 출력을 업데이트하여 마무리합니다.</p>
<p>이제 작지만 작동하는 웹 스크래퍼를 만들었습니다! 두 개의 URL을 선택하여 명령줄 도구를 실행해 보세요. 어떤 사이트는 일관되게 다른 사이트보다 빠를 수 있고, 어떤 경우에는 실행할 때마다 더 빠른 사이트가 달라질 수도 있음을 발견할 수 있습니다. 더 중요한 것은 퓨처 작업의 기초를 배웠으므로, 이제 비동기로 무엇을 할 수 있는지 더 깊이 파고들 수 있다는 것입니다.</p>
<!-- TODO: map source link version to version of Rust? -->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch17-00-async-await.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch17-02-concurrency-with-async.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch17-00-async-await.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch17-02-concurrency-with-async.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
