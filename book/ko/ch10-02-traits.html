<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>트레이트: 공유 동작 정의하기 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch10-02-traits.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch10-02-traits.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="트레이트-공유-동작-정의하기"><a class="header" href="#트레이트-공유-동작-정의하기">트레이트: 공유 동작 정의하기</a></h2>
<p>_트레이트_는 특정 타입이 가지는 기능과 다른 타입과 공유할 수 있는 기능을 정의합니다. 트레이트를 사용하여 공유된 동작을 추상적인 방식으로 정의할 수 있습니다. _트레이트 바운드_를 사용하여 제네릭 타입이 특정 동작을 가진 어떤 타입이든 될 수 있음을 지정할 수 있습니다.</p>
<blockquote>
<p>참고: 트레이트는 다른 언어에서 종종 _인터페이스_라고 불리는 기능과 유사하지만, 몇 가지 차이점이 있습니다.</p>
</blockquote>
<h3 id="트레이트-정의하기"><a class="header" href="#트레이트-정의하기">트레이트 정의하기</a></h3>
<p>타입의 동작은 해당 타입에서 호출할 수 있는 메서드로 구성됩니다. 모든 타입에서 동일한 메서드를 호출할 수 있다면 다른 타입들도 동일한 동작을 공유합니다. 트레이트 정의는 특정 목적을 달성하는 데 필요한 일련의 동작을 정의하기 위해 메서드 시그니처를 함께 그룹화하는 방법입니다.</p>
<p>예를 들어, 다양한 종류와 양의 텍스트를 담는 여러 구조체가 있다고 가정해 봅시다. 특정 위치에 보관된 뉴스 기사를 담는 <code>NewsArticle</code> 구조체와, 최대 280자까지 가능하며 새 트윗인지, 리트윗인지, 다른 트윗에 대한 답장인지 나타내는 메타데이터를 포함하는 <code>Tweet</code>입니다.</p>
<p>우리는 <code>NewsArticle</code> 또는 <code>Tweet</code> 인스턴스에 저장될 수 있는 데이터의 요약을 표시할 수 있는 <code>aggregator</code>라는 미디어 애그리게이터 라이브러리 크레이트를 만들고 싶습니다. 이를 위해 각 타입에서 요약이 필요하며, 인스턴스에서 <code>summarize</code> 메서드를 호출하여 해당 요약을 요청할 것입니다. 목록 10-12는 이러한 동작을 표현하는 공개 <code>Summary</code> 트레이트의 정의를 보여줍니다.</p>
<Listing number="10-12" file-name="src/lib.rs" caption="A `Summary` trait that consists of the behavior provided by a `summarize` method">
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}</code></pre>
</Listing>
<p>여기서 우리는 <code>trait</code> 키워드와 트레이트 이름(이 경우 <code>Summary</code>)을 사용하여 트레이트를 선언합니다. 또한 이 트레이트를 <code>pub</code>으로 선언하여 이 크레이트에 의존하는 크레이트도 이 트레이트를 사용할 수 있도록 합니다. 몇 가지 예제에서 이를 확인할 것입니다. 중괄호 안에는 이 트레이트를 구현하는 타입의 동작을 설명하는 메서드 시그니처를 선언하며, 이 경우 <code>fn summarize(&amp;self) -&gt; String</code>입니다.</p>
<p>메서드 시그니처 뒤에는 중괄호 안에 구현을 제공하는 대신 세미콜론을 사용합니다. 이 트레이트를 구현하는 각 타입은 메서드 본문에 대해 자체적인 사용자 정의 동작을 제공해야 합니다. 컴파일러는 <code>Summary</code> 트레이트를 가진 모든 타입이 이 시그니처와 정확히 일치하는 <code>summarize</code> 메서드를 정의하도록 강제할 것입니다.</p>
<p>트레이트는 본문에 여러 메서드를 가질 수 있습니다. 메서드 시그니처는 한 줄에 하나씩 나열되며, 각 줄은 세미콜론으로 끝납니다.</p>
<h3 id="타입에-트레이트-구현하기"><a class="header" href="#타입에-트레이트-구현하기">타입에 트레이트 구현하기</a></h3>
<p>이제 <code>Summary</code> 트레이트 메서드의 원하는 시그니처를 정의했으므로, 미디어 애그리게이터의 타입에 이를 구현할 수 있습니다. 목록 10-13은 <code>NewsArticle</code> 구조체에 <code>Summary</code> 트레이트를 구현한 것을 보여주며, 헤드라인, 작성자 및 위치를 사용하여 <code>summarize</code>의 반환 값을 생성합니다. <code>Tweet</code> 구조체의 경우, 트윗 내용이 이미 280자로 제한되어 있다고 가정하고 <code>summarize</code>를 사용자 이름 뒤에 전체 트윗 텍스트로 정의합니다.</p>
<Listing number="10-13" file-name="src/lib.rs" caption="Implementing the `Summary` trait on the `NewsArticle` and `Tweet` types">
<pre><code class="language-rust noplayground"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!("{}, {} 작성 ({})", self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!("{}: {}", self.username, self.content)
    }
}</code></pre>
</Listing>
<p>타입에 트레이트를 구현하는 것은 일반 메서드를 구현하는 것과 유사합니다. 차이점은 <code>impl</code> 다음에 구현하려는 트레이트 이름을 넣고, 그 다음 <code>for</code> 키워드를 사용한 다음, 트레이트를 구현하려는 타입의 이름을 지정한다는 것입니다. <code>impl</code> 블록 내에는 트레이트 정의가 정의한 메서드 시그니처를 넣습니다. 각 시그니처 뒤에 세미콜론을 추가하는 대신 중괄호를 사용하고 해당 타입에 대해 트레이트의 메서드가 가져야 할 특정 동작으로 메서드 본문을 채웁니다.</p>
<p>이제 라이브러리가 <code>NewsArticle</code>과 <code>Tweet</code>에 <code>Summary</code> 트레이트를 구현했으므로, 크레이트 사용자는 일반 메서드를 호출하는 것과 동일한 방식으로 <code>NewsArticle</code> 및 <code>Tweet</code> 인스턴스에서 트레이트 메서드를 호출할 수 있습니다. 유일한 차이점은 사용자가 타입뿐만 아니라 트레이트도 스코프로 가져와야 한다는 것입니다. 다음은 바이너리 크레이트가 <code>aggregator</code> 라이브러리 크레이트를 사용하는 방법의 예입니다:</p>
<pre><code class="language-rust ignore">use aggregator::{Summary, Tweet};

fn main() {
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "물론, 이미 알고 계시겠지만, 사람들",
        ),
        reply: false,
        retweet: false,
    };

    println!("새 트윗 1개: {}", tweet.summarize());
}</code></pre>
<p>이 코드는 <code>새 트윗 1개: horse_ebooks: 물론, 이미 알고 계시겠지만, 사람들</code>을 출력합니다.</p>
<p><code>aggregator</code> 크레이트에 의존하는 다른 크레이트들도 <code>Summary</code> 트레이트를 스코프로 가져와 자신의 타입에 <code>Summary</code>를 구현할 수 있습니다. 주의해야 할 제한 사항은 트레이트나 타입 중 하나, 또는 둘 다 우리 크레이트에 로컬인 경우에만 타입에 트레이트를 구현할 수 있다는 것입니다. 예를 들어, <code>Tweet</code> 타입이 <code>aggregator</code> 크레이트에 로컬이기 때문에 <code>aggregator</code> 크레이트 기능의 일부로 <code>Tweet</code>과 같은 사용자 정의 타입에 <code>Display</code>와 같은 표준 라이브러리 트레이트를 구현할 수 있습니다. 또한 <code>Summary</code> 트레이트가 <code>aggregator</code> 크레이트에 로컬이기 때문에 <code>aggregator</code> 크레이트에서 <code>Vec&lt;T&gt;</code>에 <code>Summary</code>를 구현할 수도 있습니다.</p>
<p>하지만 외부 타입에 외부 트레이트를 구현할 수는 없습니다. 예를 들어, <code>Display</code>와 <code>Vec&lt;T&gt;</code>는 모두 표준 라이브러리에 정의되어 있고 <code>aggregator</code> 크레이트에 로컬이 아니기 때문에 <code>aggregator</code> 크레이트 내에서 <code>Vec&lt;T&gt;</code>에 <code>Display</code> 트레이트를 구현할 수 없습니다. 이 제한은 <em>일관성(coherence)</em> 이라고 불리는 속성의 일부이며, 더 구체적으로는 부모 타입이 존재하지 않는다고 해서 <em>고아 규칙(orphan rule)</em> 이라고 불립니다. 이 규칙은 다른 사람의 코드가 여러분의 코드를 망가뜨리거나 그 반대의 경우가 발생하지 않도록 보장합니다. 이 규칙이 없다면 두 크레이트가 동일한 타입에 대해 동일한 트레이트를 구현할 수 있고, 러스트는 어떤 구현을 사용해야 할지 알 수 없게 됩니다.</p>
<h3 id="기본-구현"><a class="header" href="#기본-구현">기본 구현</a></h3>
<p>때로는 모든 타입에서 모든 메서드를 구현하도록 요구하는 대신 트레이트의 일부 또는 모든 메서드에 대해 기본 동작을 갖는 것이 유용할 때가 있습니다. 그러면 특정 타입에 트레이트를 구현할 때 각 메서드의 기본 동작을 유지하거나 재정의할 수 있습니다.</p>
<p>목록 10-14에서는 목록 10-12에서 했던 것처럼 메서드 시그니처만 정의하는 대신, <code>Summary</code> 트레이트의 <code>summarize</code> 메서드에 대한 기본 문자열을 지정합니다.</p>
<Listing number="10-14" file-name="src/lib.rs" caption="Defining a `Summary` trait with a default implementation of the `summarize` method">
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        String::from("(더 읽어보기...)")
    }
}
<span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p><code>NewsArticle</code> 인스턴스를 요약하기 위해 기본 구현을 사용하려면, <code>impl Summary for NewsArticle {}</code>과 같이 빈 <code>impl</code> 블록을 지정합니다.</p>
<p><code>NewsArticle</code>에 <code>summarize</code> 메서드를 직접 정의하지는 않았지만, 기본 구현을 제공하고 <code>NewsArticle</code>이 <code>Summary</code> 트레이트를 구현한다고 지정했습니다. 결과적으로 다음과 같이 <code>NewsArticle</code>의 인스턴스에서 <code>summarize</code> 메서드를 호출할 수 있습니다:</p>
<pre><code class="language-rust ignore"><span class="boring">use aggregator::{self, NewsArticle, Summary};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let article = NewsArticle {
        headline: String::from("펭귄스, 스탠리 컵 챔피언십 우승!"),
        location: String::from("미국 펜실베이니아주 피츠버그"),
        author: String::from("아이스버그"),
        content: String::from(
            "피츠버그 펭귄스는 다시 한번 NHL 최고의 \
             하키 팀이 되었습니다.",
        ),
    };

    println!("새로운 기사를 볼 수 있습니다! {}", article.summarize());
<span class="boring">}</span></code></pre>
<p>이 코드는 <code>새로운 기사를 볼 수 있습니다! (더 읽어보기...)</code>를 출력합니다.</p>
<p>기본 구현을 생성한다고 해서 목록 10-13의 <code>Tweet</code>에 대한 <code>Summary</code> 구현을 변경할 필요는 없습니다. 기본 구현을 재정의하는 문법은 기본 구현이 없는 트레이트 메서드를 구현하는 문법과 동일하기 때문입니다.</p>
<p>기본 구현은 동일한 트레이트 내의 다른 메서드를 호출할 수 있습니다. 그 다른 메서드에 기본 구현이 없더라도 상관없습니다. 이런 방식으로 트레이트는 많은 유용한 기능을 제공하면서 구현자가 그 중 일부만 지정하도록 요구할 수 있습니다. 예를 들어, <code>Summary</code> 트레이트에 구현이 필요한 <code>summarize_author</code> 메서드를 정의하고, <code>summarize</code> 메서드는 <code>summarize_author</code> 메서드를 호출하는 기본 구현을 갖도록 정의할 수 있습니다:</p>
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        format!("(...{}에서 더 읽어보기)", self.summarize_author())
    }
}
<span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String {
</span><span class="boring">        format!("@{}", self.username)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>이 <code>Summary</code> 버전을 사용하려면, 타입에 트레이트를 구현할 때 <code>summarize_author</code>만 정의하면 됩니다:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String;
</span><span class="boring">
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("(...{}에서 더 읽어보기)", self.summarize_author())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Summary for Tweet {
    fn summarize_author(&amp;self) -&gt; String {
        format!("@{}", self.username)
    }
}</code></pre>
<p><code>summarize_author</code>를 정의한 후에는 <code>Tweet</code> 구조체의 인스턴스에서 <code>summarize</code>를 호출할 수 있으며, <code>summarize</code>의 기본 구현은 우리가 제공한 <code>summarize_author</code>의 정의를 호출할 것입니다. <code>summarize_author</code>를 구현했으므로, <code>Summary</code> 트레이트는 우리가 더 이상 코드를 작성하지 않아도 <code>summarize</code> 메서드의 동작을 제공합니다. 다음과 같이 보입니다:</p>
<pre><code class="language-rust ignore"><span class="boring">use aggregator::{self, Summary, Tweet};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "물론, 이미 알고 계시겠지만, 사람들",
        ),
        reply: false,
        retweet: false,
    };

    println!("새 트윗 1개: {}", tweet.summarize());
<span class="boring">}</span></code></pre>
<p>이 코드는 <code>새 트윗 1개: (@horse_ebooks에서 더 읽어보기...)</code>를 출력합니다.</p>
<p>동일한 메서드를 재정의하는 구현에서는 기본 구현을 호출할 수 없다는 점에 유의하세요.</p>
<h3 id="매개변수로서의-트레이트"><a class="header" href="#매개변수로서의-트레이트">매개변수로서의 트레이트</a></h3>
<p>이제 트레이트를 정의하고 구현하는 방법을 알았으므로, 여러 다른 타입을 허용하는 함수를 정의하기 위해 트레이트를 사용하는 방법을 탐구해 볼 수 있습니다. 목록 10-13에서 <code>NewsArticle</code>과 <code>Tweet</code> 타입에 구현한 <code>Summary</code> 트레이트를 사용하여, <code>Summary</code> 트레이트를 구현하는 어떤 타입의 <code>item</code> 매개변수에 대해 <code>summarize</code> 메서드를 호출하는 <code>notify</code> 함수를 정의할 것입니다. 이를 위해 다음과 같이 <code>impl Trait</code> 문법을 사용합니다:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}, {} 작성 ({})", self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn notify(item: &amp;impl Summary) {
    println!("속보! {}", item.summarize());
}</code></pre>
<p><code>item</code> 매개변수에 구체적인 타입 대신 <code>impl</code> 키워드와 트레이트 이름을 지정합니다. 이 매개변수는 지정된 트레이트를 구현하는 어떤 타입이든 허용합니다. <code>notify</code> 본문에서는 <code>summarize</code>와 같이 <code>Summary</code> 트레이트에서 온 어떤 메서드든 <code>item</code>에서 호출할 수 있습니다. <code>notify</code>를 호출할 때 <code>NewsArticle</code>이나 <code>Tweet</code>의 인스턴스를 전달할 수 있습니다. <code>String</code>이나 <code>i32</code>와 같이 다른 타입으로 함수를 호출하는 코드는 <code>Summary</code>를 구현하지 않기 때문에 컴파일되지 않을 것입니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="fixing-the-largest-function-with-trait-bounds"></a></p>
<h4 id="트레이트-바운드-문법"><a class="header" href="#트레이트-바운드-문법">트레이트 바운드 문법</a></h4>
<p><code>impl Trait</code> 문법은 간단한 경우에는 잘 작동하지만, 실제로는 _트레이트 바운드_라고 알려진 더 긴 형태에 대한 문법적 설탕(syntax sugar)입니다. 다음과 같이 생겼습니다:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item: &amp;T) {
    println!("속보! {}", item.summarize());
}</code></pre>
<p>이 더 긴 형태는 이전 섹션의 예제와 동일하지만 더 장황합니다. 제네릭 타입 매개변수 선언과 함께 콜론 뒤에, 그리고 꺾쇠 괄호 안에 트레이트 바운드를 배치합니다.</p>
<p><code>impl Trait</code> 문법은 편리하고 간단한 경우에 코드를 더 간결하게 만들지만, 더 완전한 트레이트 바운드 문법은 다른 경우에 더 많은 복잡성을 표현할 수 있습니다. 예를 들어, <code>Summary</code>를 구현하는 두 개의 매개변수를 가질 수 있습니다. <code>impl Trait</code> 문법으로 그렇게 하면 다음과 같습니다:</p>
<pre><code class="language-rust ignore">pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {</code></pre>
<p><code>impl Trait</code>을 사용하는 것은 <code>item1</code>과 <code>item2</code>가 다른 타입을 갖도록 허용하려는 경우(두 타입 모두 <code>Summary</code>를 구현하는 한)에 적절합니다. 하지만 두 매개변수가 동일한 타입을 갖도록 강제하려면 다음과 같이 트레이트 바운드를 사용해야 합니다:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {</code></pre>
<p><code>item1</code>과 <code>item2</code> 매개변수의 타입으로 지정된 제네릭 타입 <code>T</code>는 <code>item1</code>과 <code>item2</code>에 대한 인수로 전달되는 값의 구체적인 타입이 동일해야 하도록 함수를 제약합니다.</p>
<h4 id="-문법으로-여러-트레이트-바운드-지정하기"><a class="header" href="#-문법으로-여러-트레이트-바운드-지정하기"><code>+</code> 문법으로 여러 트레이트 바운드 지정하기</a></h4>
<p>둘 이상의 트레이트 바운드를 지정할 수도 있습니다. <code>notify</code>가 <code>item</code>에 대해 <code>summarize</code>뿐만 아니라 디스플레이 포맷팅도 사용하기를 원한다고 가정해 봅시다: <code>notify</code> 정의에서 <code>item</code>이 <code>Display</code>와 <code>Summary</code>를 모두 구현해야 한다고 지정합니다. <code>+</code> 문법을 사용하여 그렇게 할 수 있습니다:</p>
<pre><code class="language-rust ignore">pub fn notify(item: &amp;(impl Summary + Display)) {</code></pre>
<p><code>+</code> 문법은 제네릭 타입의 트레이트 바운드에서도 유효합니다:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {</code></pre>
<p>두 개의 트레이트 바운드가 지정되었으므로 <code>notify</code>의 본문은 <code>summarize</code>를 호출하고 <code>{}</code>를 사용하여 <code>item</code>을 포맷팅할 수 있습니다.</p>
<h4 id="where-절로-트레이트-바운드를-더-명확하게-하기"><a class="header" href="#where-절로-트레이트-바운드를-더-명확하게-하기"><code>where</code> 절로 트레이트 바운드를 더 명확하게 하기</a></h4>
<p>너무 많은 트레이트 바운드를 사용하는 것에는 단점이 있습니다. 각 제네릭에는 고유한 트레이트 바운드가 있으므로, 여러 제네릭 타입 매개변수를 가진 함수는 함수 이름과 매개변수 목록 사이에 많은 트레이트 바운드 정보를 포함할 수 있어 함수 시그니처를 읽기 어렵게 만듭니다. 이러한 이유로 러스트는 함수 시그니처 뒤의 <code>where</code> 절 내부에 트레이트 바운드를 지정하는 대체 문법을 제공합니다. 따라서 이렇게 쓰는 대신:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {</code></pre>
<p>다음과 같이 <code>where</code> 절을 사용할 수 있습니다:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
where
    T: Display + Clone,
    U: Clone + Debug,
{
<span class="boring">    unimplemented!()
</span><span class="boring">}</span></code></pre>
<p>이 함수의 시그니처는 덜 복잡합니다: 함수 이름, 매개변수 목록, 반환 타입이 가까이 있어 트레이트 바운드가 많지 않은 함수와 비슷합니다.</p>
<h3 id="트레이트를-구현하는-타입-반환하기"><a class="header" href="#트레이트를-구현하는-타입-반환하기">트레이트를 구현하는 타입 반환하기</a></h3>
<p>여기서 보여지는 것처럼, 트레이트를 구현하는 어떤 타입의 값을 반환하기 위해 반환 위치에 <code>impl Trait</code> 문법을 사용할 수도 있습니다:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}, {} 작성 ({})", self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable() -&gt; impl Summary {
    Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "물론, 이미 알고 계시겠지만, 사람들",
        ),
        reply: false,
        retweet: false,
    }
}</code></pre>
<p>반환 타입에 <code>impl Summary</code>를 사용함으로써, 우리는 구체적인 타입을 명시하지 않고 <code>returns_summarizable</code> 함수가 <code>Summary</code> 트레이트를 구현하는 어떤 타입을 반환한다고 지정합니다. 이 경우 <code>returns_summarizable</code>은 <code>Tweet</code>를 반환하지만, 이 함수를 호출하는 코드는 그것을 알 필요가 없습니다.</p>
<p>구현하는 트레이트로만 반환 타입을 지정하는 기능은 13장에서 다루는 클로저와 반복자의 문맥에서 특히 유용합니다. 클로저와 반복자는 컴파일러만 아는 타입이나 지정하기 매우 긴 타입을 생성합니다. <code>impl Trait</code> 문법은 매우 긴 타입을 작성할 필요 없이 함수가 <code>Iterator</code> 트레이트를 구현하는 어떤 타입을 반환한다고 간결하게 지정할 수 있게 해줍니다.</p>
<p>하지만 단일 타입을 반환하는 경우에만 <code>impl Trait</code>을 사용할 수 있습니다. 예를 들어, 반환 타입이 <code>impl Summary</code>로 지정된 상태에서 <code>NewsArticle</code>이나 <code>Tweet</code> 중 하나를 반환하는 이 코드는 작동하지 않을 것입니다:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}, {} 작성 ({})", self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable(switch: bool) -&gt; impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                "펭귄스, 스탠리 컵 챔피언십 우승!",
            ),
            location: String::from("미국 펜실베이니아주 피츠버그"),
            author: String::from("아이스버그"),
            content: String::from(
                "피츠버그 펭귄스가 다시 한 번 NHL 최고의 \
                 하키 팀이 되었습니다.",
            ),
        }
    } else {
        Tweet {
            username: String::from("horse_ebooks"),
            content: String::from(
                "물론, 이미 알고 계시겠지만, 사람들",
            ),
            reply: false,
            retweet: false,
        }
    }
}</code></pre>
<p><code>impl Trait</code> 문법이 컴파일러에 구현된 방식에 대한 제한 때문에 <code>NewsArticle</code>이나 <code>Tweet</code> 중 하나를 반환하는 것은 허용되지 않습니다. 18장의 <a href="ch18-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">“다른 타입의 값을 허용하는 트레이트 객체 사용하기”</a><!--
ignore --> 섹션에서 이러한 동작을 하는 함수를 작성하는 방법을 다룰 것입니다.</p>
<h3 id="트레이트-바운드를-사용하여-메서드를-조건부로-구현하기"><a class="header" href="#트레이트-바운드를-사용하여-메서드를-조건부로-구현하기">트레이트 바운드를 사용하여 메서드를 조건부로 구현하기</a></h3>
<p>제네릭 타입 매개변수를 사용하는 <code>impl</code> 블록에 트레이트 바운드를 사용하면, 지정된 트레이트를 구현하는 타입에 대해서만 메서드를 조건부로 구현할 수 있습니다. 예를 들어, 목록 10-15의 <code>Pair&lt;T&gt;</code> 타입은 항상 <code>Pair&lt;T&gt;</code>의 새 인스턴스를 반환하는 <code>new</code> 함수를 구현합니다(5장의 <a href="ch05-03-method-syntax.html#defining-methods">“메서드 정의하기”</a><!-- ignore --> 섹션에서 <code>Self</code>가 <code>impl</code> 블록의 타입에 대한 타입 별칭임을 기억하세요. 이 경우 <code>Pair&lt;T&gt;</code>입니다). 하지만 다음 <code>impl</code> 블록에서 <code>Pair&lt;T&gt;</code>는 내부 타입 <code>T</code>가 비교를 가능하게 하는 <code>PartialOrd</code> 트레이트 <em>와</em> 출력을 가능하게 하는 <code>Display</code> 트레이트를 구현하는 경우에만 <code>cmp_display</code> 메서드를 구현합니다.</p>
<Listing number="10-15" file-name="src/lib.rs" caption="Conditionally implementing methods on a generic type depending on trait bounds">
<pre><code class="language-rust noplayground">use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self { x, y }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!("가장 큰 멤버는 x = {}", self.x);
        } else {
            println!("가장 큰 멤버는 y = {}", self.y);
        }
    }
}</code></pre>
</Listing>
<p>우리는 또한 다른 트레이트를 구현하는 모든 타입에 대해 트레이트를 조건부로 구현할 수 있습니다. 트레이트 바운드를 만족하는 모든 타입에 대한 트레이트 구현을 _포괄적 구현(blanket implementations)_이라고 하며, 러스트 표준 라이브러리에서 광범위하게 사용됩니다. 예를 들어, 표준 라이브러리는 <code>Display</code> 트레이트를 구현하는 모든 타입에 대해 <code>ToString</code> 트레이트를 구현합니다. 표준 라이브러리의 <code>impl</code> 블록은 이 코드와 유사해 보입니다:</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --생략--
}</code></pre>
<p>표준 라이브러리에 이러한 포괄적 구현이 있기 때문에, <code>Display</code> 트레이트를 구현하는 모든 타입에서 <code>ToString</code> 트레이트에 정의된 <code>to_string</code> 메서드를 호출할 수 있습니다. 예를 들어, 정수는 <code>Display</code>를 구현하므로 다음과 같이 정수를 해당 <code>String</code> 값으로 바꿀 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = 3.to_string();
<span class="boring">}</span></code></pre></pre>
<p>포괄적 구현은 트레이트 문서의 “Implementors” 섹션에 나타납니다.</p>
<p>트레이트와 트레이트 바운드를 사용하면 제네릭 타입 매개변수를 사용하여 중복을 줄이는 동시에, 컴파일러에게 제네릭 타입이 특정 동작을 갖도록 하겠다고 지정할 수 있습니다. 그러면 컴파일러는 트레이트 바운드 정보를 사용하여 코드에 사용된 모든 구체적인 타입이 올바른 동작을 제공하는지 확인할 수 있습니다. 동적 타입 언어에서는 메서드를 정의하지 않은 타입에서 메서드를 호출하면 런타임에 에러가 발생합니다. 하지만 러스트는 이러한 에러를 컴파일 타임으로 옮겨 코드를 실행하기도 전에 문제를 해결하도록 강제합니다. 또한 컴파일 타임에 이미 확인했기 때문에 런타임에 동작을 확인하는 코드를 작성할 필요가 없습니다. 이렇게 하면 제네릭의 유연성을 포기하지 않고도 성능을 향상시킬 수 있습니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch10-01-syntax.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch10-03-lifetime-syntax.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch10-01-syntax.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch10-03-lifetime-syntax.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
