<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Defining Shared Behavior with Traits - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch10-02-traits.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch10-02-traits.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Old headings. Do not remove or links may break. -->
<p><a id="traits-defining-shared-behavior"></a></p>
<h2 id="defining-shared-behavior-with-traits"><a class="header" href="#defining-shared-behavior-with-traits">Defining Shared Behavior with Traits</a></h2>
<p>_트레이트_는 특정 타입이 가지는 기능과 다른 타입과 공유할 수 있는 기능을 정의합니다. 트레이트를 사용하여 공유된 동작을 추상적인 방식으로 정의할 수 있습니다. _트레이트 바운드_를 사용하여 제네릭 타입이 특정 동작을 가진 어떤 타입이든 될 수 있음을 지정할 수 있습니다.</p>
<blockquote>
<p>참고: 트레이트는 다른 언어에서 종종 _인터페이스_라고 불리는 기능과 유사하지만, 몇 가지 차이점이 있습니다.</p>
</blockquote>
<h3 id="트레이트-정의하기"><a class="header" href="#트레이트-정의하기">트레이트 정의하기</a></h3>
<p>타입의 동작은 해당 타입에서 호출할 수 있는 메서드로 구성됩니다. 모든 타입에서 동일한 메서드를 호출할 수 있다면 다른 타입들도 동일한 동작을 공유합니다. 트레이트 정의는 특정 목적을 달성하는 데 필요한 일련의 동작을 정의하기 위해 메서드 시그니처를 함께 그룹화하는 방법입니다.</p>
<p>For example, let’s say we have multiple structs that hold various kinds and amounts of text: a <code>NewsArticle</code> struct that holds a news story filed in a particular location and a <code>SocialPost</code> that can have, at most, 280 characters along with metadata that indicates whether it was a new post, a repost, or a reply to another post.</p>
<p>We want to make a media aggregator library crate named <code>aggregator</code> that can display summaries of data that might be stored in a <code>NewsArticle</code> or <code>SocialPost</code> instance. To do this, we need a summary from each type, and we’ll request that summary by calling a <code>summarize</code> method on an instance. Listing 10-12 shows the definition of a public <code>Summary</code> trait that expresses this behavior.</p>
<Listing number="10-12" file-name="src/lib.rs" caption="A `Summary` trait that consists of the behavior provided by a `summarize` method">
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}</code></pre>
</Listing>
<p>여기서 우리는 <code>trait</code> 키워드와 트레이트 이름(이 경우 <code>Summary</code>)을 사용하여 트레이트를 선언합니다. 또한 이 트레이트를 <code>pub</code>으로 선언하여 이 크레이트에 의존하는 크레이트도 이 트레이트를 사용할 수 있도록 합니다. 몇 가지 예제에서 이를 확인할 것입니다. 중괄호 안에는 이 트레이트를 구현하는 타입의 동작을 설명하는 메서드 시그니처를 선언하며, 이 경우 <code>fn summarize(&amp;self) -&gt; String</code>입니다.</p>
<p>메서드 시그니처 뒤에는 중괄호 안에 구현을 제공하는 대신 세미콜론을 사용합니다. 이 트레이트를 구현하는 각 타입은 메서드 본문에 대해 자체적인 사용자 정의 동작을 제공해야 합니다. 컴파일러는 <code>Summary</code> 트레이트를 가진 모든 타입이 이 시그니처와 정확히 일치하는 <code>summarize</code> 메서드를 정의하도록 강제할 것입니다.</p>
<p>A trait can have multiple methods in its body: The method signatures are listed one per line, and each line ends in a semicolon.</p>
<h3 id="타입에-트레이트-구현하기"><a class="header" href="#타입에-트레이트-구현하기">타입에 트레이트 구현하기</a></h3>
<p>Now that we’ve defined the desired signatures of the <code>Summary</code> trait’s methods, we can implement it on the types in our media aggregator. Listing 10-13 shows an implementation of the <code>Summary</code> trait on the <code>NewsArticle</code> struct that uses the headline, the author, and the location to create the return value of <code>summarize</code>. For the <code>SocialPost</code> struct, we define <code>summarize</code> as the username followed by the entire text of the post, assuming that the post content is already limited to 280 characters.</p>
<Listing number="10-13" file-name="src/lib.rs" caption="Implementing the `Summary` trait on the `NewsArticle` and `SocialPost` types">
<pre><code class="language-rust noplayground"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!("{}, {} 작성 ({})", self.headline, self.author, self.location)
    }
}

pub struct SocialPost {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub repost: bool,
}

impl Summary for SocialPost {
    fn summarize(&amp;self) -&gt; String {
        format!("{}: {}", self.username, self.content)
    }
}</code></pre>
</Listing>
<p>타입에 트레이트를 구현하는 것은 일반 메서드를 구현하는 것과 유사합니다. 차이점은 <code>impl</code> 다음에 구현하려는 트레이트 이름을 넣고, 그 다음 <code>for</code> 키워드를 사용한 다음, 트레이트를 구현하려는 타입의 이름을 지정한다는 것입니다. <code>impl</code> 블록 내에는 트레이트 정의가 정의한 메서드 시그니처를 넣습니다. 각 시그니처 뒤에 세미콜론을 추가하는 대신 중괄호를 사용하고 해당 타입에 대해 트레이트의 메서드가 가져야 할 특정 동작으로 메서드 본문을 채웁니다.</p>
<p>Now that the library has implemented the <code>Summary</code> trait on <code>NewsArticle</code> and <code>SocialPost</code>, users of the crate can call the trait methods on instances of <code>NewsArticle</code> and <code>SocialPost</code> in the same way we call regular methods. The only difference is that the user must bring the trait into scope as well as the types. Here’s an example of how a binary crate could use our <code>aggregator</code> library crate:</p>
<pre><code class="language-rust ignore">use aggregator::{SocialPost, Summary};

fn main() {
    let post = SocialPost {
        username: String::from("horse_ebooks"),
        content: String::from(
            "물론, 이미 알고 계시겠지만, 사람들",
        ),
        reply: false,
        repost: false,
    };

    println!("1 new post: {}", post.summarize());
}</code></pre>
<p>This code prints <code>1 new post: horse_ebooks: of course, as you probably already know, people</code>.</p>
<p>Other crates that depend on the <code>aggregator</code> crate can also bring the <code>Summary</code> trait into scope to implement <code>Summary</code> on their own types. One restriction to note is that we can implement a trait on a type only if either the trait or the type, or both, are local to our crate. For example, we can implement standard library traits like <code>Display</code> on a custom type like <code>SocialPost</code> as part of our <code>aggregator</code> crate functionality because the type <code>SocialPost</code> is local to our <code>aggregator</code> crate. We can also implement <code>Summary</code> on <code>Vec&lt;T&gt;</code> in our <code>aggregator</code> crate because the trait <code>Summary</code> is local to our <code>aggregator</code> crate.</p>
<p>But we can’t implement external traits on external types. For example, we can’t implement the <code>Display</code> trait on <code>Vec&lt;T&gt;</code> within our <code>aggregator</code> crate, because <code>Display</code> and <code>Vec&lt;T&gt;</code> are both defined in the standard library and aren’t local to our <code>aggregator</code> crate. This restriction is part of a property called <em>coherence</em>, and more specifically the <em>orphan rule</em>, so named because the parent type is not present. This rule ensures that other people’s code can’t break your code and vice versa. Without the rule, two crates could implement the same trait for the same type, and Rust wouldn’t know which implementation to use.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="default-implementations"></a></p>
<h3 id="using-default-implementations"><a class="header" href="#using-default-implementations">Using Default Implementations</a></h3>
<p>때로는 모든 타입에서 모든 메서드를 구현하도록 요구하는 대신 트레이트의 일부 또는 모든 메서드에 대해 기본 동작을 갖는 것이 유용할 때가 있습니다. 그러면 특정 타입에 트레이트를 구현할 때 각 메서드의 기본 동작을 유지하거나 재정의할 수 있습니다.</p>
<p>목록 10-14에서는 목록 10-12에서 했던 것처럼 메서드 시그니처만 정의하는 대신, <code>Summary</code> 트레이트의 <code>summarize</code> 메서드에 대한 기본 문자열을 지정합니다.</p>
<Listing number="10-14" file-name="src/lib.rs" caption="Defining a `Summary` trait with a default implementation of the `summarize` method">
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        String::from("(더 읽어보기...)")
    }
}
<span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {}
</span><span class="boring">
</span><span class="boring">pub struct SocialPost {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for SocialPost {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p><code>NewsArticle</code> 인스턴스를 요약하기 위해 기본 구현을 사용하려면, <code>impl Summary for NewsArticle {}</code>과 같이 빈 <code>impl</code> 블록을 지정합니다.</p>
<p><code>NewsArticle</code>에 <code>summarize</code> 메서드를 직접 정의하지는 않았지만, 기본 구현을 제공하고 <code>NewsArticle</code>이 <code>Summary</code> 트레이트를 구현한다고 지정했습니다. 결과적으로 다음과 같이 <code>NewsArticle</code>의 인스턴스에서 <code>summarize</code> 메서드를 호출할 수 있습니다:</p>
<pre><code class="language-rust ignore"><span class="boring">use aggregator::{self, NewsArticle, Summary};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let article = NewsArticle {
        headline: String::from("펭귄스, 스탠리 컵 챔피언십 우승!"),
        location: String::from("미국 펜실베이니아주 피츠버그"),
        author: String::from("아이스버그"),
        content: String::from(
            "피츠버그 펭귄스는 다시 한번 NHL 최고의 \
             하키 팀이 되었습니다.",
        ),
    };

    println!("새로운 기사를 볼 수 있습니다! {}", article.summarize());
<span class="boring">}</span></code></pre>
<p>이 코드는 <code>새로운 기사를 볼 수 있습니다! (더 읽어보기...)</code>를 출력합니다.</p>
<p>Creating a default implementation doesn’t require us to change anything about the implementation of <code>Summary</code> on <code>SocialPost</code> in Listing 10-13. The reason is that the syntax for overriding a default implementation is the same as the syntax for implementing a trait method that doesn’t have a default implementation.</p>
<p>기본 구현은 동일한 트레이트 내의 다른 메서드를 호출할 수 있습니다. 그 다른 메서드에 기본 구현이 없더라도 상관없습니다. 이런 방식으로 트레이트는 많은 유용한 기능을 제공하면서 구현자가 그 중 일부만 지정하도록 요구할 수 있습니다. 예를 들어, <code>Summary</code> 트레이트에 구현이 필요한 <code>summarize_author</code> 메서드를 정의하고, <code>summarize</code> 메서드는 <code>summarize_author</code> 메서드를 호출하는 기본 구현을 갖도록 정의할 수 있습니다:</p>
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        format!("(...{}에서 더 읽어보기)", self.summarize_author())
    }
}
<span class="boring">
</span><span class="boring">pub struct SocialPost {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for SocialPost {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String {
</span><span class="boring">        format!("@{}", self.username)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>이 <code>Summary</code> 버전을 사용하려면, 타입에 트레이트를 구현할 때 <code>summarize_author</code>만 정의하면 됩니다:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String;
</span><span class="boring">
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("(...{}에서 더 읽어보기)", self.summarize_author())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct SocialPost {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Summary for SocialPost {
    fn summarize_author(&amp;self) -&gt; String {
        format!("@{}", self.username)
    }
}</code></pre>
<p>After we define <code>summarize_author</code>, we can call <code>summarize</code> on instances of the <code>SocialPost</code> struct, and the default implementation of <code>summarize</code> will call the definition of <code>summarize_author</code> that we’ve provided. Because we’ve implemented <code>summarize_author</code>, the <code>Summary</code> trait has given us the behavior of the <code>summarize</code> method without requiring us to write any more code. Here’s what that looks like:</p>
<pre><code class="language-rust ignore"><span class="boring">use aggregator::{self, SocialPost, Summary};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let post = SocialPost {
        username: String::from("horse_ebooks"),
        content: String::from(
            "물론, 이미 알고 계시겠지만, 사람들",
        ),
        reply: false,
        repost: false,
    };

    println!("1 new post: {}", post.summarize());
<span class="boring">}</span></code></pre>
<p>This code prints <code>1 new post: (Read more from @horse_ebooks...)</code>.</p>
<p>동일한 메서드를 재정의하는 구현에서는 기본 구현을 호출할 수 없다는 점에 유의하세요.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="traits-as-parameters"></a></p>
<h3 id="using-traits-as-parameters"><a class="header" href="#using-traits-as-parameters">Using Traits as Parameters</a></h3>
<p>Now that you know how to define and implement traits, we can explore how to use traits to define functions that accept many different types. We’ll use the <code>Summary</code> trait we implemented on the <code>NewsArticle</code> and <code>SocialPost</code> types in Listing 10-13 to define a <code>notify</code> function that calls the <code>summarize</code> method on its <code>item</code> parameter, which is of some type that implements the <code>Summary</code> trait. To do this, we use the <code>impl Trait</code> syntax, like this:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}, {} 작성 ({})", self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct SocialPost {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for SocialPost {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn notify(item: &amp;impl Summary) {
    println!("속보! {}", item.summarize());
}</code></pre>
<p>Instead of a concrete type for the <code>item</code> parameter, we specify the <code>impl</code> keyword and the trait name. This parameter accepts any type that implements the specified trait. In the body of <code>notify</code>, we can call any methods on <code>item</code> that come from the <code>Summary</code> trait, such as <code>summarize</code>. We can call <code>notify</code> and pass in any instance of <code>NewsArticle</code> or <code>SocialPost</code>. Code that calls the function with any other type, such as a <code>String</code> or an <code>i32</code>, won’t compile, because those types don’t implement <code>Summary</code>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="fixing-the-largest-function-with-trait-bounds"></a></p>
<h4 id="트레이트-바운드-문법"><a class="header" href="#트레이트-바운드-문법">트레이트 바운드 문법</a></h4>
<p><code>impl Trait</code> 문법은 간단한 경우에는 잘 작동하지만, 실제로는 _트레이트 바운드_라고 알려진 더 긴 형태에 대한 문법적 설탕(syntax sugar)입니다. 다음과 같이 생겼습니다:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item: &amp;T) {
    println!("속보! {}", item.summarize());
}</code></pre>
<p>이 더 긴 형태는 이전 섹션의 예제와 동일하지만 더 장황합니다. 제네릭 타입 매개변수 선언과 함께 콜론 뒤에, 그리고 꺾쇠 괄호 안에 트레이트 바운드를 배치합니다.</p>
<p><code>impl Trait</code> 문법은 편리하고 간단한 경우에 코드를 더 간결하게 만들지만, 더 완전한 트레이트 바운드 문법은 다른 경우에 더 많은 복잡성을 표현할 수 있습니다. 예를 들어, <code>Summary</code>를 구현하는 두 개의 매개변수를 가질 수 있습니다. <code>impl Trait</code> 문법으로 그렇게 하면 다음과 같습니다:</p>
<pre><code class="language-rust ignore">pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {</code></pre>
<p><code>impl Trait</code>을 사용하는 것은 <code>item1</code>과 <code>item2</code>가 다른 타입을 갖도록 허용하려는 경우(두 타입 모두 <code>Summary</code>를 구현하는 한)에 적절합니다. 하지만 두 매개변수가 동일한 타입을 갖도록 강제하려면 다음과 같이 트레이트 바운드를 사용해야 합니다:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {</code></pre>
<p><code>item1</code>과 <code>item2</code> 매개변수의 타입으로 지정된 제네릭 타입 <code>T</code>는 <code>item1</code>과 <code>item2</code>에 대한 인수로 전달되는 값의 구체적인 타입이 동일해야 하도록 함수를 제약합니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="specifying-multiple-trait-bounds-with-the--syntax"></a></p>
<h4 id="multiple-trait-bounds-with-the--syntax"><a class="header" href="#multiple-trait-bounds-with-the--syntax">Multiple Trait Bounds with the <code>+</code> Syntax</a></h4>
<p>We can also specify more than one trait bound. Say we wanted <code>notify</code> to use display formatting as well as <code>summarize</code> on <code>item</code>: We specify in the <code>notify</code> definition that <code>item</code> must implement both <code>Display</code> and <code>Summary</code>. We can do so using the <code>+</code> syntax:</p>
<pre><code class="language-rust ignore">pub fn notify(item: &amp;(impl Summary + Display)) {</code></pre>
<p><code>+</code> 문법은 제네릭 타입의 트레이트 바운드에서도 유효합니다:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {</code></pre>
<p>두 개의 트레이트 바운드가 지정되었으므로 <code>notify</code>의 본문은 <code>summarize</code>를 호출하고 <code>{}</code>를 사용하여 <code>item</code>을 포맷팅할 수 있습니다.</p>
<h4 id="where-절로-트레이트-바운드를-더-명확하게-하기"><a class="header" href="#where-절로-트레이트-바운드를-더-명확하게-하기"><code>where</code> 절로 트레이트 바운드를 더 명확하게 하기</a></h4>
<p>너무 많은 트레이트 바운드를 사용하는 것에는 단점이 있습니다. 각 제네릭에는 고유한 트레이트 바운드가 있으므로, 여러 제네릭 타입 매개변수를 가진 함수는 함수 이름과 매개변수 목록 사이에 많은 트레이트 바운드 정보를 포함할 수 있어 함수 시그니처를 읽기 어렵게 만듭니다. 이러한 이유로 러스트는 함수 시그니처 뒤의 <code>where</code> 절 내부에 트레이트 바운드를 지정하는 대체 문법을 제공합니다. 따라서 이렇게 쓰는 대신:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {</code></pre>
<p>다음과 같이 <code>where</code> 절을 사용할 수 있습니다:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
where
    T: Display + Clone,
    U: Clone + Debug,
{
<span class="boring">    unimplemented!()
</span><span class="boring">}</span></code></pre>
<p>This function’s signature is less cluttered: The function name, parameter list, and return type are close together, similar to a function without lots of trait bounds.</p>
<h3 id="트레이트를-구현하는-타입-반환하기"><a class="header" href="#트레이트를-구현하는-타입-반환하기">트레이트를 구현하는 타입 반환하기</a></h3>
<p>여기서 보여지는 것처럼, 트레이트를 구현하는 어떤 타입의 값을 반환하기 위해 반환 위치에 <code>impl Trait</code> 문법을 사용할 수도 있습니다:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}, {} 작성 ({})", self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct SocialPost {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for SocialPost {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable() -&gt; impl Summary {
    SocialPost {
        username: String::from("horse_ebooks"),
        content: String::from(
            "물론, 이미 알고 계시겠지만, 사람들",
        ),
        reply: false,
        repost: false,
    }
}</code></pre>
<p>By using <code>impl Summary</code> for the return type, we specify that the <code>returns_summarizable</code> function returns some type that implements the <code>Summary</code> trait without naming the concrete type. In this case, <code>returns_summarizable</code> returns a <code>SocialPost</code>, but the code calling this function doesn’t need to know that.</p>
<p>구현하는 트레이트로만 반환 타입을 지정하는 기능은 13장에서 다루는 클로저와 반복자의 문맥에서 특히 유용합니다. 클로저와 반복자는 컴파일러만 아는 타입이나 지정하기 매우 긴 타입을 생성합니다. <code>impl Trait</code> 문법은 매우 긴 타입을 작성할 필요 없이 함수가 <code>Iterator</code> 트레이트를 구현하는 어떤 타입을 반환한다고 간결하게 지정할 수 있게 해줍니다.</p>
<p>However, you can only use <code>impl Trait</code> if you’re returning a single type. For example, this code that returns either a <code>NewsArticle</code> or a <code>SocialPost</code> with the return type specified as <code>impl Summary</code> wouldn’t work:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}, {} 작성 ({})", self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct SocialPost {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub repost: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for SocialPost {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable(switch: bool) -&gt; impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                "펭귄스, 스탠리 컵 챔피언십 우승!",
            ),
            location: String::from("미국 펜실베이니아주 피츠버그"),
            author: String::from("아이스버그"),
            content: String::from(
                "피츠버그 펭귄스가 다시 한 번 NHL 최고의 \
                 하키 팀이 되었습니다.",
            ),
        }
    } else {
        SocialPost {
            username: String::from("horse_ebooks"),
            content: String::from(
                "물론, 이미 알고 계시겠지만, 사람들",
            ),
            reply: false,
            repost: false,
        }
    }
}</code></pre>
<p>Returning either a <code>NewsArticle</code> or a <code>SocialPost</code> isn’t allowed due to restrictions around how the <code>impl Trait</code> syntax is implemented in the compiler. We’ll cover how to write a function with this behavior in the <a href="ch18-02-trait-objects.html#using-trait-objects-to-abstract-over-shared-behavior">“Using Trait Objects to Abstract over Shared Behavior”</a><!-- ignore --> section of Chapter 18.</p>
<h3 id="트레이트-바운드를-사용하여-메서드를-조건부로-구현하기"><a class="header" href="#트레이트-바운드를-사용하여-메서드를-조건부로-구현하기">트레이트 바운드를 사용하여 메서드를 조건부로 구현하기</a></h3>
<p>By using a trait bound with an <code>impl</code> block that uses generic type parameters, we can implement methods conditionally for types that implement the specified traits. For example, the type <code>Pair&lt;T&gt;</code> in Listing 10-15 always implements the <code>new</code> function to return a new instance of <code>Pair&lt;T&gt;</code> (recall from the <a href="ch05-03-method-syntax.html#method-syntax">“Method Syntax”</a><!-- ignore --> section of Chapter 5 that <code>Self</code> is a type alias for the type of the <code>impl</code> block, which in this case is <code>Pair&lt;T&gt;</code>). But in the next <code>impl</code> block, <code>Pair&lt;T&gt;</code> only implements the <code>cmp_display</code> method if its inner type <code>T</code> implements the <code>PartialOrd</code> trait that enables comparison <em>and</em> the <code>Display</code> trait that enables printing.</p>
<Listing number="10-15" file-name="src/lib.rs" caption="Conditionally implementing methods on a generic type depending on trait bounds">
<pre><code class="language-rust noplayground">use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self { x, y }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!("가장 큰 멤버는 x = {}", self.x);
        } else {
            println!("가장 큰 멤버는 y = {}", self.y);
        }
    }
}</code></pre>
</Listing>
<p>우리는 또한 다른 트레이트를 구현하는 모든 타입에 대해 트레이트를 조건부로 구현할 수 있습니다. 트레이트 바운드를 만족하는 모든 타입에 대한 트레이트 구현을 _포괄적 구현(blanket implementations)_이라고 하며, 러스트 표준 라이브러리에서 광범위하게 사용됩니다. 예를 들어, 표준 라이브러리는 <code>Display</code> 트레이트를 구현하는 모든 타입에 대해 <code>ToString</code> 트레이트를 구현합니다. 표준 라이브러리의 <code>impl</code> 블록은 이 코드와 유사해 보입니다:</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --생략--
}</code></pre>
<p>표준 라이브러리에 이러한 포괄적 구현이 있기 때문에, <code>Display</code> 트레이트를 구현하는 모든 타입에서 <code>ToString</code> 트레이트에 정의된 <code>to_string</code> 메서드를 호출할 수 있습니다. 예를 들어, 정수는 <code>Display</code>를 구현하므로 다음과 같이 정수를 해당 <code>String</code> 값으로 바꿀 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = 3.to_string();
<span class="boring">}</span></code></pre></pre>
<p>포괄적 구현은 트레이트 문서의 “Implementors” 섹션에 나타납니다.</p>
<p>Traits and trait bounds let us write code that uses generic type parameters to reduce duplication but also specify to the compiler that we want the generic type to have particular behavior. The compiler can then use the trait bound information to check that all the concrete types used with our code provide the correct behavior. In dynamically typed languages, we would get an error at runtime if we called a method on a type that didn’t define the method. But Rust moves these errors to compile time so that we’re forced to fix the problems before our code is even able to run. Additionally, we don’t have to write code that checks for behavior at runtime, because we’ve already checked at compile time. Doing so improves performance without having to give up the flexibility of generics.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch10-01-syntax.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch10-03-lifetime-syntax.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch10-01-syntax.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch10-03-lifetime-syntax.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
