<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>스트림: 순차적인 Future - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch17-04-streams.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch17-04-streams.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="스트림-순차적인-future"><a class="header" href="#스트림-순차적인-future">스트림: 순차적인 Future</a></h2>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="streams"></a></p>
<p>이 장에서 지금까지 우리는 주로 개별 퓨처에 집중해 왔습니다. 유일하게 큰 예외는 우리가 사용했던 비동기 채널이었습니다. 이 장 앞부분의 <a href="ch17-02-concurrency-with-async.html#message-passing">“메시지 전달”</a><!-- ignore --> 섹션에서 비동기 채널의 수신자를 어떻게 사용했는지 떠올려 보세요. 비동기 <code>recv</code> 메서드는 시간이 지남에 따라 일련의 항목들을 생성합니다. 이것은 _스트림(stream)_이라고 알려진 훨씬 더 일반적인 패턴의 한 사례입니다.</p>
<p>우리는 13장 <a href="ch13-02-iterators.html#the-iterator-trait-and-the-next-method">반복자 트레이트와 <code>next</code> 메서드</a><!-- ignore
--> 섹션에서 <code>Iterator</code> 트레이트를 살펴볼 때 일련의 항목들을 보았지만, 반복자와 비동기 채널 수신자 사이에는 두 가지 차이점이 있습니다. 첫 번째 차이점은 시간입니다. 반복자는 동기식인 반면, 채널 수신자는 비동기식입니다. 두 번째는 API입니다. <code>Iterator</code>와 직접 작업할 때는 그것의 동기 <code>next</code> 메서드를 호출합니다. 특히 <code>trpl::Receiver</code> 스트림의 경우, 대신 비동기 <code>recv</code> 메서드를 호출했습니다. 그 외에 이 API들은 매우 비슷하게 느껴지는데, 그 유사성은 우연이 아닙니다. 스트림은 반복의 비동기 형태와 같습니다. 하지만 <code>trpl::Receiver</code>가 구체적으로 메시지를 받기를 기다리는 것과 달리, 범용 스트림 API는 훨씬 더 광범위합니다. 그것은 <code>Iterator</code>가 하는 것과 같은 방식으로 다음 항목을 제공하지만, 비동기식으로 제공합니다.</p>
<p>러스트에서 반복자와 스트림 사이의 유사성은 우리가 실제로 어떤 반복자로부터든 스트림을 생성할 수 있음을 의미합니다. 반복자와 마찬가지로, 목록 17-30에서처럼 스트림의 <code>next</code> 메서드를 호출하고 그 출력을 기다림으로써(awaiting) 스트림과 작업할 수 있습니다.</p>
<Listing number="17-30" caption="Creating a stream from an iterator and printing its values" file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        let iter = values.iter().map(|n| n * 2);
        let mut stream = trpl::stream_from_iter(iter);

        while let Some(value) = stream.next().await {
            println!("값은 {value}였습니다.");
        }
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
</Listing>
<p>숫자 배열로 시작하여 이를 반복자로 변환한 다음, <code>map</code>을 호출하여 모든 값을 두 배로 만듭니다. 그런 다음 <code>trpl::stream_from_iter</code> 함수를 사용하여 반복자를 스트림으로 변환합니다. 다음으로, 스트림의 항목들이 도착할 때마다 <code>while let</code> 루프로 반복합니다.</p>
<p>불행히도 코드를 실행하려고 하면 컴파일되지 않고, 대신 사용할 수 있는 <code>next</code> 메서드가 없다는 보고를 합니다.</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-30
cargo build
copy only the error output
-->
<pre><code class="language-console">error[E0599]: no method named `next` found for struct `Iter` in the current scope
  --&gt; src/main.rs:10:40
   |
10 |         while let Some(value) = stream.next().await {
   |                                        ^^^^
   |
   = note: the full type name has been written to 'file:///projects/async_await/target/debug/deps/async_await-9de943556a6001b8.long-type-1281356139287206597.txt'
   = note: 전체 타입 이름을 콘솔에 출력하려면 `--verbose`를 사용하는 것을 고려해 보세요
   = help: 트레이트의 항목들은 트레이트가 스코프에 있을 때만 사용될 수 있습니다
help: `next`를 제공하는 다음 트레이트들이 구현되어 있지만 스코프에 없습니다. 아마도 그 중 하나를 임포트하고 싶을 것입니다
   |
1  + use crate::trpl::StreamExt;
   |
1  + use futures_util::stream::stream::StreamExt;
   |
1  + use std::iter::Iterator;
   |
1  + use std::str::pattern::Searcher;
   |
help: 비슷한 이름의 `try_next` 메서드가 있습니다
   |
10 |         while let Some(value) = stream.try_next().await {
   |                                        ~~~~~~~~
</code></pre>
<p>이 출력 결과가 설명하듯이, 컴파일러 에러의 이유는 <code>next</code> 메서드를 사용하기 위해 올바른 트레이트가 스코프에 필요하기 때문입니다. 지금까지의 논의를 고려할 때, 여러분은 그 트레이트가 <code>Stream</code>일 것이라고 합리적으로 예상할 수도 있겠지만, 실제로는 <code>StreamExt</code>입니다. <em>extension</em>(확장)의 약자인 <code>Ext</code>는 한 트레이트를 다른 트레이트로 확장하기 위해 러스트 커뮤니티에서 흔히 사용하는 패턴입니다.</p>
<p>장 마지막 부분에서 <code>Stream</code>과 <code>StreamExt</code> 트레이트에 대해 좀 더 자세히 설명하겠지만, 지금 당장 알아야 할 것은 <code>Stream</code> 트레이트가 <code>Iterator</code>와 <code>Future</code> 트레이트를 효과적으로 결합한 저수준 인터페이스를 정의한다는 것입니다. <code>StreamExt</code>는 <code>next</code> 메서드뿐만 아니라 <code>Iterator</code> 트레이트에서 제공하는 것과 유사한 다른 유틸리티 메서드들을 포함하여, <code>Stream</code> 위에 고수준 API 세트를 제공합니다. <code>Stream</code>과 <code>StreamExt</code>는 아직 러스트 표준 라이브러리의 일부는 아니지만, 대부분의 생태계 크레이트들은 동일한 정의를 사용합니다.</p>
<p>컴파일러 에러의 해결책은 목록 17-31과 같이 <code>trpl::StreamExt</code>에 대한 <code>use</code> 문을 추가하는 것입니다.</p>
<Listing number="17-31" caption="Successfully using an iterator as the basis for a stream" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span>use trpl::StreamExt;

fn main() {
    trpl::run(async {
        let values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        let iter = values.iter().map(|n| n * 2);
        let mut stream = trpl::stream_from_iter(iter);

        while let Some(value) = stream.next().await {
            println!("값은 {value}였습니다.");
        }
    });
}</code></pre></pre>
</Listing>
<p>이 모든 조각들을 하나로 합치면, 이 코드는 우리가 원하는 방식으로 작동합니다! 게다가 이제 <code>StreamExt</code>가 스코프에 있으므로, 반복자와 마찬가지로 모든 유틸리티 메서드를 사용할 수 있습니다. 예를 들어, 목록 17-32에서는 <code>filter</code> 메서드를 사용하여 3과 5의 배수를 제외한 모든 것을 걸러냅니다.</p>
<Listing number="17-32" caption="Filtering a stream with the `StreamExt::filter` method" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span>use trpl::StreamExt;

fn main() {
    trpl::run(async {
        let values = 1..101;
        let iter = values.map(|n| n * 2);
        let stream = trpl::stream_from_iter(iter);

        let mut filtered =
            stream.filter(|value| value % 3 == 0 || value % 5 == 0);

        while let Some(value) = filtered.next().await {
            println!("값은 {value}였습니다.");
        }
    });
}</code></pre></pre>
</Listing>
<p>물론 이것은 일반 반복자로도 비동기 없이 똑같이 할 수 있기 때문에 그다지 흥미롭지 않습니다. 이제 스트림만이 할 수 있는 <em>고유한</em> 작업들을 살펴봅시다.</p>
<h3 id="스트림-조합하기"><a class="header" href="#스트림-조합하기">스트림 조합하기</a></h3>
<p>많은 개념들이 자연스럽게 스트림으로 표현됩니다: 큐에서 사용 가능해지는 항목들, 전체 데이터 세트가 컴퓨터 메모리에 비해 너무 클 때 파일 시스템에서 점진적으로 가져오는 데이터 청크들, 혹은 시간이 지나면서 네트워크를 통해 도착하는 데이터들이 그 예입니다. 스트림은 퓨처이기 때문에, 우리는 그것들을 다른 종류의 퓨처와 함께 사용하고 흥미로운 방식으로 결합할 수 있습니다. 예를 들어, 너무 많은 네트워크 호출을 유발하지 않도록 이벤트를 일괄 처리(batch up)하거나, 오래 걸리는 일련의 작업에 타임아웃을 설정하거나, 불필요한 작업을 피하기 위해 사용자 인터페이스 이벤트를 조절(throttle)할 수 있습니다.</p>
<p>목록 17-33과 같이 WebSocket이나 다른 실시간 통신 프로토콜에서 볼 수 있는 데이터 스트림을 대신할 작은 메시지 스트림을 만드는 것부터 시작해 봅시다.</p>
<Listing number="17-33" caption="Using the `rx` receiver as a `ReceiverStream`" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span>use trpl::{ReceiverStream, Stream, StreamExt};

fn main() {
    trpl::run(async {
        let mut messages = get_messages();

        while let Some(message) = messages.next().await {
            println!("{message}");
        }
    });
}

fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
    let (tx, rx) = trpl::channel();

    let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
    for message in messages {
        tx.send(format!("메시지: '{message}'")).unwrap();
    }

    ReceiverStream::new(rx)
}</code></pre></pre>
</Listing>
<p>먼저, <code>impl Stream&lt;Item = String&gt;</code>을 반환하는 <code>get_messages</code>라는 함수를 만듭니다. 구현을 위해 비동기 채널을 생성하고, 영어 알파벳의 처음 10글자를 루프로 돌며 채널을 통해 보냅니다.</p>
<p>또한 <code>trpl::channel</code>의 <code>rx</code> 수신자를 <code>next</code> 메서드가 있는 <code>Stream</code>으로 변환하는 새로운 타입인 <code>ReceiverStream</code>을 사용합니다. 다시 <code>main</code>에서 <code>while let</code> 루프를 사용하여 스트림의 모든 메시지를 출력합니다.</p>
<p>이 코드를 실행하면, 정확히 우리가 예상한 결과를 얻게 됩니다:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Message: 'a'
Message: 'b'
Message: 'c'
Message: 'd'
Message: 'e'
Message: 'f'
Message: 'g'
Message: 'h'
Message: 'i'
Message: 'j'
</code></pre>
<p>하지만 이것 역시 일반 <code>Receiver</code> API나 심지어 일반 <code>Iterator</code> API로도 가능하므로, 스트림이 필요한 기능을 추가해 봅시다. 목록 17-34와 같이 스트림의 모든 항목에 적용되는 타임아웃과 우리가 내보내는 항목들에 대한 지연을 추가해 보겠습니다.</p>
<Listing number="17-34" caption="Using the `StreamExt::timeout` method to set a time limit on the items in a stream" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span>use std::{pin::pin, time::Duration};
use trpl::{ReceiverStream, Stream, StreamExt};

fn main() {
    trpl::run(async {
        let mut messages =
            pin!(get_messages().timeout(Duration::from_millis(200)));

        while let Some(result) = messages.next().await {
            match result {
                Ok(message) =&gt; println!("{message}"),
                Err(reason) =&gt; eprintln!("문제: {reason:?}"),
            }
        }
    })
}
<span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">    for message in messages {
</span><span class="boring">        tx.send(format!("메시지: '{message}'")).unwrap();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>먼저 <code>StreamExt</code> 트레이트에서 제공하는 <code>timeout</code> 메서드를 사용하여 스트림에 타임아웃을 추가하는 것으로 시작합니다. 그런 다음 스트림이 이제 <code>Result</code>를 반환하므로 <code>while let</code> 루프의 본문을 업데이트합니다. <code>Ok</code> 변형은 메시지가 제시간에 도착했음을 나타내고, <code>Err</code> 변형은 메시지가 도착하기 전에 타임아웃이 지났음을 나타냅니다. 우리는 그 결과에 대해 <code>match</code>를 수행하여 메시지를 성공적으로 받았을 때는 메시지를 출력하고, 타임아웃이 발생했을 때는 그에 대한 알림을 출력합니다. 마지막으로, 타임아웃 헬퍼가 폴링(poll)되기 위해 피닝(pin)되어야 하는 스트림을 생성하므로, 메시지에 타임아웃을 적용한 후에 메시지를 피닝한다는 점에 유의하세요.</p>
<p>하지만 메시지 사이에 지연이 없기 때문에, 이 타임아웃은 프로그램의 동작을 변경하지 않습니다. 목록 17-35에 표시된 것처럼 우리가 보내는 메시지에 가변적인 지연을 추가해 봅시다.</p>
<Listing number="17-35" caption="Sending messages through `tx` with an async delay without making `get_messages` an async function" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let mut messages =
</span><span class="boring">            pin!(get_messages().timeout(Duration::from_millis(200)));
</span><span class="boring">
</span><span class="boring">        while let Some(result) = messages.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("문제: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span>fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
    let (tx, rx) = trpl::channel();

    trpl::spawn_task(async move {
        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
        for (index, message) in messages.into_iter().enumerate() {
            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
            trpl::sleep(Duration::from_millis(time_to_sleep)).await;

            tx.send(format!("메시지: '{message}'")).unwrap();
        }
    });

    ReceiverStream::new(rx)
}</code></pre></pre>
</Listing>
<p><code>get_messages</code>에서 우리는 <code>messages</code> 배열과 함께 <code>enumerate</code> 반복자 메서드를 사용하여 우리가 보내는 각 항목의 인덱스를 항목 자체와 함께 가져올 수 있습니다. 그런 다음 짝수 인덱스 항목에는 100밀리초 지연을 적용하고 홀수 인덱스 항목에는 300밀리초 지연을 적용하여 실제 상황의 메시지 스트림에서 볼 수 있는 다양한 지연을 시뮬레이션합니다. 타임아웃이 200밀리초이므로, 이는 메시지의 절반에 영향을 미칠 것입니다.</p>
<p><code>get_messages</code> 함수에서 블로킹 없이 메시지 사이에 잠을 자려면 비동기를 사용해야 합니다. 하지만 <code>get_messages</code> 자체를 비동기 함수로 만들 수는 없습니다. 그렇게 하면 <code>Stream&lt;Item = String&gt;</code> 대신 <code>Future&lt;Output = Stream&lt;Item = String&gt;&gt;</code>을 반환하게 되기 때문입니다. 호출자는 스트림에 접근하기 위해 <code>get_messages</code> 자체를 기다려야(await) 할 것입니다. 하지만 기억하세요: 주어진 퓨처 내의 모든 것은 선형적으로 발생하며, 동시성은 퓨처 _사이_에서 발생합니다. <code>get_messages</code>를 기다리는 것은 수신자 스트림을 반환하기 전에 각 메시지 사이의 수면 지연을 포함하여 모든 메시지를 보내도록 요구할 것입니다. 결과적으로 타임아웃은 쓸모가 없게 됩니다. 스트림 자체에는 지연이 없을 것이며, 모든 지연은 스트림이 사용 가능해지기도 전에 발생할 것입니다.</p>
<p>대신 우리는 <code>get_messages</code>를 스트림을 반환하는 일반 함수로 남겨두고, 비동기 <code>sleep</code> 호출을 처리하기 위해 태스크를 생성(spawn)합니다.</p>
<blockquote>
<p>참고: 이런 방식으로 <code>spawn_task</code>를 호출하는 것은 우리가 이미 런타임을 설정했기 때문에 작동합니다. 그렇지 않았다면 패닉이 발생했을 것입니다. 다른 구현들은 다른 트레이드오프를 선택합니다: 새로운 런타임을 생성하여 패닉을 피하지만 약간의 추가 오버헤드가 발생할 수 있고, 또는 런타임에 대한 참조 없이 태스크를 생성하는 독립적인 방법을 단순히 제공하지 않을 수도 있습니다. 여러분의 런타임이 어떤 트레이드오프를 선택했는지 확인하고 그에 따라 코드를 작성하세요!</p>
</blockquote>
<p>이제 우리 코드는 훨씬 더 흥미로운 결과를 보여줍니다. 매 두 메시지 쌍 사이에 <code>Problem: Elapsed(())</code> 에러가 발생합니다.</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-35
cargo run
copy only the program output, *not* the compiler output
-->
<pre><code class="language-text">Message: 'a'
Problem: Elapsed(())
Message: 'b'
Message: 'c'
Problem: Elapsed(())
Message: 'd'
Message: 'e'
Problem: Elapsed(())
Message: 'f'
Message: 'g'
Problem: Elapsed(())
Message: 'h'
Message: 'i'
Problem: Elapsed(())
Message: 'j'
</code></pre>
<p>타임아웃이 발생했다고 해서 메시지가 결국 도착하는 것을 막지는 못합니다. 우리 채널은 <em>제한이 없기(unbounded)</em> 때문에 메모리가 허용하는 한 많은 메시지를 보유할 수 있으며, 원래의 모든 메시지를 여전히 받게 됩니다. 메시지가 타임아웃 전에 도착하지 않으면 스트림 핸들러가 이를 처리하겠지만, 스트림을 다시 폴링할 때 메시지가 이미 도착해 있을 수 있습니다.</p>
<p>필요하다면 다른 종류의 채널이나 더 일반적으로 다른 종류의 스트림을 사용하여 다른 동작을 얻을 수 있습니다. 시간 간격 스트림을 이 메시지 스트림과 결합하여 그 중 하나를 실제로 살펴봅시다.</p>
<h3 id="스트림-병합하기"><a class="header" href="#스트림-병합하기">스트림 병합하기</a></h3>
<p>먼저, 직접 실행하면 매 밀리초마다 항목을 내보내는 또 다른 스트림을 만들어 봅시다. 단순함을 위해 <code>sleep</code> 함수를 사용하여 지연된 메시지를 보내고, <code>get_messages</code>에서 사용했던 채널로부터 스트림을 생성하는 것과 동일한 방식을 결합할 수 있습니다. 차이점은 이번에는 경과된 간격의 횟수를 보낼 것이므로 반환 타입이 <code>impl Stream&lt;Item = u32&gt;</code>가 되며, 함수 이름을 <code>get_intervals</code>라고 부를 수 있다는 점입니다(목록 17-36 참조).</p>
<Listing number="17-36" caption="Creating a stream with a counter that will be emitted once every millisecond" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let mut messages =
</span><span class="boring">            pin!(get_messages().timeout(Duration::from_millis(200)));
</span><span class="boring">
</span><span class="boring">        while let Some(result) = messages.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("문제: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">        for (index, message) in messages.into_iter().enumerate() {
</span><span class="boring">            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
</span><span class="boring">            trpl::sleep(Duration::from_millis(time_to_sleep)).await;
</span><span class="boring">
</span><span class="boring">            tx.send(format!("메시지: '{message}'")).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}
</span><span class="boring">
</span>fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
    let (tx, rx) = trpl::channel();

    trpl::spawn_task(async move {
        let mut count = 0;
        loop {
            trpl::sleep(Duration::from_millis(1)).await;
            count += 1;
            tx.send(count).unwrap();
        }
    });

    ReceiverStream::new(rx)
}</code></pre></pre>
</Listing>
<p>태스크 내에 <code>count</code>를 정의하는 것으로 시작합니다. (태스크 외부에서 정의할 수도 있지만, 주어진 변수의 스코프를 제한하는 것이 더 명확합니다.) 그런 다음 무한 루프를 생성합니다. 루프의 각 반복은 비동기적으로 1밀리초 동안 잠을 자고, 카운트를 증가시킨 다음, 채널을 통해 보냅니다. 이 모든 것이 <code>spawn_task</code>에 의해 생성된 태스크 내에 래핑되어 있으므로, 무한 루프를 포함한 모든 것이 런타임과 함께 정리될 것입니다.</p>
<p>런타임 전체가 종료될 때만 끝나는 이런 종류의 무한 루프는 비동기 러스트에서 꽤 흔합니다. 많은 프로그램들이 무기한으로 계속 실행될 필요가 있기 때문입니다. 비동기를 사용하면 루프의 각 반복마다 최소한 하나의 await 지점이 있는 한, 이것이 다른 어떤 것도 차단하지 않습니다.</p>
<p>이제 다시 메인 함수의 비동기 블록으로 돌아와서, 목록 17-37과 같이 <code>messages</code>와 <code>intervals</code> 스트림 병합을 시도해 볼 수 있습니다.</p>
<Listing number="17-37" caption="Attempting to merge the `messages` and `intervals` streams" file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let messages = get_messages().timeout(Duration::from_millis(200));
        let intervals = get_intervals();
        let merged = messages.merge(intervals);
<span class="boring">
</span><span class="boring">        while let Some(result) = merged.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("문제: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">        for (index, message) in messages.into_iter().enumerate() {
</span><span class="boring">            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
</span><span class="boring">            trpl::sleep(Duration::from_millis(time_to_sleep)).await;
</span><span class="boring">
</span><span class="boring">            tx.send(format!("메시지: '{message}'")).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let mut count = 0;
</span><span class="boring">        loop {
</span><span class="boring">            trpl::sleep(Duration::from_millis(1)).await;
</span><span class="boring">            count += 1;
</span><span class="boring">            tx.send(count).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}</span></code></pre>
</Listing>
<p>먼저 <code>get_intervals</code>를 호출하는 것으로 시작합니다. 그런 다음 <code>merge</code> 메서드를 사용하여 <code>messages</code>와 <code>intervals</code> 스트림을 병합합니다. 이 메서드는 여러 스트림을 하나의 스트림으로 결합하며, 소스 스트림 중 어느 하나에서든 항목이 사용 가능해지는 즉시 특정 순서 없이 항목을 생성합니다. 마지막으로, <code>messages</code> 대신 결합된 스트림에 대해 루프를 돕니다.</p>
<p>이 시점에서 <code>messages</code>나 <code>intervals</code> 모두 피닝되거나 가변적일 필요가 없습니다. 둘 다 단일 <code>merged</code> 스트림으로 결합될 것이기 때문입니다. 하지만 이 <code>merge</code> 호출은 컴파일되지 않습니다! (<code>while let</code> 루프의 <code>next</code> 호출도 마찬가지지만, 나중에 다시 다루겠습니다.) 이는 두 스트림의 타입이 다르기 때문입니다. <code>messages</code> 스트림은 <code>Timeout&lt;impl Stream&lt;Item = String&gt;&gt;</code> 타입을 갖는데, 여기서 <code>Timeout</code>은 <code>timeout</code> 호출에 대해 <code>Stream</code>을 구현하는 타입입니다. <code>intervals</code> 스트림은 <code>impl Stream&lt;Item = u32&gt;</code> 타입을 갖습니다. 이 두 스트림을 병합하려면 하나를 다른 하나와 일치하도록 변환해야 합니다. <code>messages</code>는 이미 우리가 원하는 기본 형식이고 타임아웃 에러를 처리해야 하므로, <code>intervals</code> 스트림을 재작업하겠습니다(목록 17-38 참조).</p>
<!-- We cannot directly test this one, because it never stops. -->
<Listing number="17-38" caption="Aligning the type of the the `intervals` stream with the type of the `messages` stream" file-name="src/main.rs">
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let messages = get_messages().timeout(Duration::from_millis(200));
        let intervals = get_intervals()
            .map(|count| format!("간격: {count}"))
            .timeout(Duration::from_secs(10));
        let merged = messages.merge(intervals);
        let mut stream = pin!(merged);
<span class="boring">
</span><span class="boring">        while let Some(result) = stream.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("문제: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">        for (index, message) in messages.into_iter().enumerate() {
</span><span class="boring">            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
</span><span class="boring">            trpl::sleep(Duration::from_millis(time_to_sleep)).await;
</span><span class="boring">
</span><span class="boring">            tx.send(format!("메시지: '{message}'")).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let mut count = 0;
</span><span class="boring">        loop {
</span><span class="boring">            trpl::sleep(Duration::from_millis(1)).await;
</span><span class="boring">            count += 1;
</span><span class="boring">            tx.send(count).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}</span></code></pre>
</Listing>
<p>첫째, <code>map</code> 헬퍼 메서드를 사용하여 <code>intervals</code>를 문자열로 변환할 수 있습니다. 둘째, <code>messages</code>의 <code>Timeout</code>과 일치시켜야 합니다. 하지만 <code>intervals</code>에 대해서는 실제로 타임아웃을 <em>원하지</em> 않으므로, 우리가 사용하고 있는 다른 기간보다 긴 타임아웃을 만들면 됩니다. 여기서는 <code>Duration::from_secs(10)</code>으로 10초 타임아웃을 만듭니다. 마지막으로, <code>while let</code> 루프의 <code>next</code> 호출이 스트림을 반복할 수 있도록 <code>stream</code>을 가변으로 만들고, 안전하게 반복할 수 있도록 피닝해야 합니다. 이제 우리가 원하는 목표에 <em>거의</em> 도달했습니다. 모든 타입 체크가 통과됩니다. 하지만 이를 실행하면 두 가지 문제가 발생합니다. 첫째, 절대로 멈추지 않습니다! <span class="keystroke">ctrl-c</span>로 강제 종료해야 할 것입니다. 둘째, 영어 알파벳 메시지들이 수많은 간격 카운터 메시지들 사이에 묻혀버릴 것입니다:첫째, <code>map</code> 헬퍼 메서드를 사용하여 <code>intervals</code>를 문자열로 변환할 수 있습니다. 둘째, <code>messages</code>의 <code>Timeout</code>과 일치시켜야 합니다. 하지만 <code>intervals</code>에 대해서는 실제로 타임아웃을 <em>원하지</em> 않으므로, 우리가 사용하고 있는 다른 기간보다 긴 타임아웃을 만들면 됩니다. 여기서는 <code>Duration::from_secs(10)</code>으로 10초 타임아웃을 만듭니다. 마지막으로, <code>while let</code> 루프의 <code>next</code> 호출이 스트림을 반복할 수 있도록 <code>stream</code>을 가변으로 만들고, 안전하게 반복할 수 있도록 피닝해야 합니다. 이제 우리가 원하는 목표에 <em>거의</em> 도달했습니다. 모든 타입 체크가 통과됩니다. 하지만 이를 실행하면 두 가지 문제가 발생합니다. 첫째, 절대로 멈추지 않습니다! <span class="keystroke">ctrl-c</span>로 강제 종료해야 할 것입니다. 둘째, 영어 알파벳 메시지들이 수많은 간격 카운터 메시지들 사이에 묻혀버릴 것입니다:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the tasks running differently rather than
changes in the compiler -->
<pre><code class="language-text">--snip--
Interval: 38
Interval: 39
Interval: 40
Message: 'a'
Interval: 41
Interval: 42
Interval: 43
--snip--
</code></pre>
<p>목록 17-39는 이 마지막 두 가지 문제를 해결하는 한 가지 방법을 보여줍니다.</p>
<Listing number="17-39" caption="Using `throttle` and `take` to manage the merged streams" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let messages = get_messages().timeout(Duration::from_millis(200));
        let intervals = get_intervals()
            .map(|count| format!("간격: {count}"))
            .throttle(Duration::from_millis(100))
            .timeout(Duration::from_secs(10));
        let merged = messages.merge(intervals).take(20);
        let mut stream = pin!(merged);
<span class="boring">
</span><span class="boring">        while let Some(result) = stream.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(message) =&gt; println!("{message}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("문제: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">        for (index, message) in messages.into_iter().enumerate() {
</span><span class="boring">            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
</span><span class="boring">            trpl::sleep(Duration::from_millis(time_to_sleep)).await;
</span><span class="boring">
</span><span class="boring">            tx.send(format!("메시지: '{message}'")).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let mut count = 0;
</span><span class="boring">        loop {
</span><span class="boring">            trpl::sleep(Duration::from_millis(1)).await;
</span><span class="boring">            count += 1;
</span><span class="boring">            tx.send(count).unwrap();
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>첫째, <code>intervals</code> 스트림이 <code>messages</code> 스트림을 압도하지 않도록 <code>throttle</code> 메서드를 사용합니다. _스로틀링(Throttling)_은 함수가 호출되는 속도, 또는 이 경우에는 스트림이 폴링되는 빈도를 제한하는 방법입니다. 메시지가 도착하는 빈도와 대략 일치하는 100밀리초에 한 번 정도면 충분할 것입니다.</p>
<p>스트림에서 받아들일 항목의 수를 제한하기 위해, 우리는 <code>merged</code> 스트림에 <code>take</code> 메서드를 적용합니다. 어느 한쪽 스트림이 아니라 최종 출력을 제한하고 싶기 때문입니다.</p>
<p>이제 프로그램을 실행하면 스트림에서 20개의 항목을 가져온 후 중단되며, 간격 메시지가 일반 메시지를 압도하지 않습니다. 또한 매 밀리초마다 이벤트를 생성할 <em>수 있는</em> 소스 스트림이 있음에도 불구하고 <code>Interval: 100</code>이나 <code>Interval: 200</code> 등이 아닌 <code>Interval: 1</code>, <code>Interval: 2</code> 등을 받게 됩니다. 그 이유는 <code>throttle</code> 호출이 원래 스트림을 감싸는 새로운 스트림을 생성하여, 원래 스트림이 고유의 "네이티브" 속도가 아닌 스로틀 속도로만 폴링되도록 하기 때문입니다. 우리가 무시하기로 선택한 수많은 처리되지 않은 간격 메시지들이 쌓여 있는 것이 아닙니다. 대신, 우리는 애초에 그 간격 메시지들을 생성하지 않는 것입니다! 이는 우리가 성능 특성을 선택할 수 있게 해주는 러스트 퓨처 고유의 "게으름(laziness)"이 다시 한번 작용한 결과입니다.</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-39
cargo run
copy and paste only the program output
-->
<pre><code class="language-text">Interval: 1
Message: 'a'
Interval: 2
Interval: 3
Problem: Elapsed(())
Interval: 4
Message: 'b'
Interval: 5
Message: 'c'
Interval: 6
Interval: 7
Problem: Elapsed(())
Interval: 8
Message: 'd'
Interval: 9
Message: 'e'
Interval: 10
Interval: 11
Problem: Elapsed(())
Interval: 12
</code></pre>
<p>마지막으로 처리해야 할 것이 하나 더 있습니다: 바로 에러입니다! 이 두 가지 채널 기반 스트림 모두, 채널의 반대편이 닫힐 때 <code>send</code> 호출이 실패할 수 있습니다. 이는 런타임이 스트림을 구성하는 퓨처들을 어떻게 실행하느냐에 달린 문제입니다. 지금까지 우리는 <code>unwrap</code>을 호출하여 이 가능성을 무시해 왔지만, 잘 만들어진 앱이라면 에러를 명시적으로 처리해야 합니다. 최소한 더 이상 메시지를 보내지 않도록 루프를 종료해야 하죠. 목록 17-40은 문제를 출력하고 루프를 빠져나오는(break) 간단한 에러 전략을 보여줍니다.</p>
<Listing number="17-40" caption="Handling errors and shutting down the loops">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate trpl; // mdbook 테스트에 필요함
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let messages = get_messages().timeout(Duration::from_millis(200));
</span><span class="boring">        let intervals = get_intervals()
</span><span class="boring">            .map(|count| format!("간격 #{count}"))
</span><span class="boring">            .throttle(Duration::from_millis(500))
</span><span class="boring">            .timeout(Duration::from_secs(10));
</span><span class="boring">        let merged = messages.merge(intervals).take(20);
</span><span class="boring">        let mut stream = pin!(merged);
</span><span class="boring">
</span><span class="boring">        while let Some(result) = stream.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(item) =&gt; println!("{item}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("문제: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span>fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
    let (tx, rx) = trpl::channel();

    trpl::spawn_task(async move {
        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];

        for (index, message) in messages.into_iter().enumerate() {
            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
            trpl::sleep(Duration::from_millis(time_to_sleep)).await;

            if let Err(send_error) = tx.send(format!("메시지: '{message}'")) {
                eprintln!("메시지 '{message}'를 보낼 수 없습니다: {send_error}");
                break;
            }
        }
    });

    ReceiverStream::new(rx)
}

fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
    let (tx, rx) = trpl::channel();

    trpl::spawn_task(async move {
        let mut count = 0;
        loop {
            trpl::sleep(Duration::from_millis(1)).await;
            count += 1;

            if let Err(send_error) = tx.send(count) {
                eprintln!("간격 {count}를 보낼 수 없습니다: {send_error}");
                break;
            };
        }
    });

    ReceiverStream::new(rx)
}</code></pre></pre>
</Listing>
<p>늘 그렇듯이, 메시지 전송 에러를 처리하는 올바른 방법은 상황에 따라 다를 것입니다. 단지 여러분만의 전략을 가지고 있는지 확인하세요.</p>
<p>이제 실제로 많은 비동기 사례들을 보았으니, 한 걸음 물러나서 <code>Future</code>, <code>Stream</code>, 그리고 러스트가 비동기를 작동시키기 위해 사용하는 다른 핵심 트레이트들이 어떻게 작동하는지에 대한 몇 가지 세부 사항을 파헤쳐 봅시다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch17-03-more-futures.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch17-05-traits-for-async.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch17-03-more-futures.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch17-05-traits-for-async.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
