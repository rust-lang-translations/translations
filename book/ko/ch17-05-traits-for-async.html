<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Async를 위한 트레이트 자세히 살펴보기 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch17-05-traits-for-async.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch17-05-traits-for-async.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="async를-위한-트레이트-자세히-살펴보기"><a class="header" href="#async를-위한-트레이트-자세히-살펴보기">Async를 위한 트레이트 자세히 살펴보기</a></h2>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="digging-into-the-traits-for-async"></a></p>
<p>이 장 전체에서 우리는 <code>Future</code>, <code>Pin</code>, <code>Unpin</code>, <code>Stream</code>, 그리고 <code>StreamExt</code> 트레이트들을 다양한 방식으로 사용해 왔습니다. 하지만 지금까지는 그것들이 어떻게 작동하는지 또는 어떻게 서로 맞춰지는지에 대한 세부 사항에 너무 깊이 들어가는 것을 피해 왔는데, 이는 일상적인 러스트 작업에서는 대부분의 경우 괜찮습니다. 하지만 가끔은 이러한 세부 사항을 좀 더 이해해야 하는 상황에 맞닥뜨리게 될 것입니다. 이 섹션에서는 그러한 시나리오에서 도움이 될 만큼만 파헤쳐 볼 것이며, <em>정말</em> 깊은 탐구는 다른 문서를 위해 남겨두겠습니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="future"></a></p>
<h3 id="future-트레이트"><a class="header" href="#future-트레이트"><code>Future</code> 트레이트</a></h3>
<p>먼저 <code>Future</code> 트레이트가 어떻게 작동하는지 자세히 살펴보는 것으로 시작해 봅시다. 러스트에서는 이를 다음과 같이 정의합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::pin::Pin;
use std::task::{Context, Poll};

pub trait Future {
    type Output;

    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>그 트레이트 정의에는 수많은 새로운 타입들과 우리가 전에 본 적 없는 몇 가지 문법들이 포함되어 있으므로, 정의를 하나하나 살펴봅시다.</p>
<p>첫째, <code>Future</code>의 연관 타입인 <code>Output</code>은 퓨처가 완료되었을 때 어떤 타입으로 해소되는지를 나타냅니다. 이는 <code>Iterator</code> 트레이트의 <code>Item</code> 연관 타입과 유사합니다. 둘째, <code>Future</code>는 <code>poll</code> 메서드도 가지고 있는데, 이 메서드는 <code>self</code> 매개변수로 특별한 <code>Pin</code> 참조를 받고 <code>Context</code> 타입에 대한 가변 참조를 받으며, <code>Poll&lt;Self::Output&gt;</code>을 반환합니다. <code>Pin</code>과 <code>Context</code>에 대해서는 잠시 후에 더 자세히 이야기하겠습니다. 지금은 메서드가 반환하는 타입인 <code>Poll</code> 타입에 집중해 봅시다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Poll&lt;T&gt; {
    Ready(T),
    Pending,
}
<span class="boring">}</span></code></pre></pre>
<p>이 <code>Poll</code> 타입은 <code>Option</code>과 비슷합니다. 값을 가지는 <code>Ready(T)</code> 변형과 값을 가지지 않는 <code>Pending</code> 변형이 있습니다. 하지만 <code>Poll</code>은 <code>Option</code>과는 꽤 다른 의미를 가집니다! <code>Pending</code> 변형은 퓨처가 아직 할 일이 남았음을 나타내며, 따라서 호출자는 나중에 다시 확인해야 합니다. <code>Ready</code> 변형은 퓨처가 작업을 마쳤으며 <code>T</code> 값을 사용할 수 있음을 나타냅니다.</p>
<blockquote>
<p>참고: 대부분의 퓨처에서 호출자는 퓨처가 <code>Ready</code>를 반환한 후에 다시 <code>poll</code>을 호출해서는 안 됩니다. 많은 퓨처들이 준비된 상태가 된 후 다시 폴링되면 패닉을 일으킵니다. 다시 폴링해도 안전한 퓨처들은 문서에 명시적으로 그렇게 기재되어 있을 것입니다. 이는 <code>Iterator::next</code>가 동작하는 방식과 비슷합니다.</p>
</blockquote>
<p><code>await</code>를 사용하는 코드를 보면, 러스트는 내부적으로 이를 <code>poll</code>을 호출하는 코드로 컴파일합니다. 단일 URL이 해소되었을 때 페이지 제목을 출력했던 목록 17-4를 다시 보면, 러스트는 이를 (정확히는 아니지만) 대략 다음과 같은 것으로 컴파일합니다.</p>
<pre><code class="language-rust ignore">match page_title(url).poll() {
    Ready(page_title) =&gt; match page_title {
        Some(title) =&gt; println!("The title for {url} was {title}"),
        None =&gt; println!("{url} had no title"),
    }
    Pending =&gt; {
        // 하지만 여기에 무엇이 들어갈까요?
    }
}</code></pre>
<p>퓨처가 여전히 <code>Pending</code> 상태일 때 우리는 무엇을 해야 할까요? 퓨처가 마침내 준비될 때까지 계속해서 다시 시도할 방법이 필요합니다. 즉, 루프가 필요합니다.</p>
<pre><code class="language-rust ignore">let mut page_title_fut = page_title(url);
loop {
    match page_title_fut.poll() {
        Ready(value) =&gt; match page_title {
            Some(title) =&gt; println!("The title for {url} was {title}"),
            None =&gt; println!("{url} had no title"),
        }
        Pending =&gt; {
            // 계속 진행
        }
    }
}</code></pre>
<p>하지만 러스트가 정확히 저 코드로 컴파일한다면, 모든 <code>await</code>는 블로킹될 것입니다—우리가 목표로 했던 것과는 정반대죠! 대신 러스트는 루프가 이 퓨처에 대한 작업을 일시 중단하고 다른 퓨처를 작업한 뒤 나중에 다시 이 퓨처를 확인할 수 있는 무언가에 제어권을 넘겨줄 수 있도록 보장합니다. 우리가 보았듯이, 그 무언가가 바로 비동기 런타임이며, 이러한 스케줄링과 조정 작업이 런타임의 주요 임무 중 하나입니다.</p>
<p>이 장의 앞부분에서 우리는 <code>rx.recv</code>를 기다리는 것에 대해 설명했습니다. <code>recv</code> 호출은 퓨처를 반환하며, 퓨처를 기다리는 것은 그것을 폴링하는 것입니다. 우리는 런타임이 채널이 닫힐 때 <code>Some(message)</code> 또는 <code>None</code>으로 준비될 때까지 퓨처를 일시 중지할 것이라고 언급했습니다. <code>Future</code> 트레이트, 특히 <code>Future::poll</code>에 대한 더 깊은 이해를 통해 우리는 그것이 어떻게 작동하는지 볼 수 있습니다. 런타임은 <code>Poll::Pending</code>을 반환할 때 퓨처가 준비되지 않았음을 압니다. 반대로, <code>poll</code>이 <code>Poll::Ready(Some(message))</code> 또는 <code>Poll::Ready(None)</code>을 반환하면 런타임은 퓨처가 준비되었음을 알고 다음으로 진행합니다.</p>
<p>런타임이 이를 어떻게 수행하는지에 대한 정확한 세부 사항은 이 책의 범위를 벗어나지만, 핵심은 퓨처의 기본적인 메커니즘을 이해하는 것입니다. 런타임은 자신이 책임지는 각 퓨처를 _폴링(poll)_하며, 아직 준비되지 않았을 때는 퓨처를 다시 잠들게 합니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="pinning-and-the-pin-and-unpin-traits"></a></p>
<h3 id="pin과-unpin-트레이트"><a class="header" href="#pin과-unpin-트레이트"><code>Pin</code>과 <code>Unpin</code> 트레이트</a></h3>
<p>목록 17-16에서 피닝(pinning)의 개념을 소개했을 때, 우리는 매우 까다로운 에러 메시지에 맞닥뜨렸습니다. 관련 부분만 다시 보겠습니다.</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-16
cargo build
copy *only* the final `error` block from the errors
-->
<p>29 |     F: Future, |        ^^^^^^ <code>JoinAll</code>의 이 바운드에 의해 요구됨</p>
<pre><code class="language-text">error[E0277]: `{async block@src/main.rs:10:23: 10:33}`는 언피닝(unpinned)될 수 없습니다
  --&gt; src/main.rs:48:33
   |
48 |         trpl::join_all(futures).await;
   |                                 ^^^^^ `{async block@src/main.rs:10:23: 10:33}`에 대해 `Unpin` 트레이트가 구현되지 않았으며, 이는 `Box&lt;{async block@src/main.rs:10:23: 10:33}&gt;: Future`에 의해 요구됩니다
   |
   = note: `pin!` 매크로 사용을 고려해 보세요
           현재 스코프 외부에서 피닝된 값에 접근해야 한다면 `Box::pin` 사용을 고려해 보세요
   = note: `Box&lt;{async block@src/main.rs:10:23: 10:33}&gt;`가 `Future`를 구현하기 위해 필요합니다
note: `futures_util::future::join_all::JoinAll`의 바운드에 의해 요구됩니다
  --&gt; file:///home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/futures-util-0.3.30/src/future/join_all.rs:29:8
   |
27 | pub struct JoinAll&lt;F&gt;
   |            ------- 이 구조체의 바운드에 의해 요구됨
28 | where
29 |     F: Future,
   |        ^^^^^^ `JoinAll`의 이 바운드에 의해 요구됨
```
</code></pre>
<p>This error message tells us not only that we need to pin the values but also why pinning is required. The <code>trpl::join_all</code> function returns a struct called <code>JoinAll</code>. That struct is generic over a type <code>F</code>, which is constrained to implement the <code>Future</code> trait. Directly awaiting a future with <code>await</code> pins the future implicitly. That’s why we don’t need to use <code>pin!</code> everywhere we want to await futures.</p>
<p>하지만 여기서는 퓨처를 직접 기다리고 있지 않습니다. 대신 <code>join_all</code> 함수에 퓨처 컬렉션을 전달하여 새로운 퓨처인 <code>JoinAll</code>을 구성합니다. <code>join_all</code>의 시그니처는 컬렉션에 포함된 아이템들의 타입이 모두 <code>Future</code> 트레이트를 구현할 것을 요구하며, <code>Box&lt;T&gt;</code>는 그것이 감싸고 있는 <code>T</code>가 <code>Unpin</code> 트레이트를 구현하는 퓨처인 경우에만 <code>Future</code>를 구현합니다.</p>
<p>소화해야 할 내용이 많네요! 이를 제대로 이해하기 위해, <code>Future</code> 트레이트가 실제로 어떻게 작동하는지, 특히 _피닝(pinning)_과 관련하여 좀 더 깊이 들어가 봅시다.</p>
<p><code>Future</code> 트레이트의 정의를 다시 살펴보세요.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::pin::Pin;
use std::task::{Context, Poll};

pub trait Future {
    type Output;

    // 필수 메서드
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p><code>cx</code> 매개변수와 그 <code>Context</code> 타입은 런타임이 지연(lazy) 상태를 유지하면서도 주어진 퓨처를 언제 확인해야 할지 실제로 아는 핵심 비결입니다. 다시 말하지만, 그것이 어떻게 작동하는지에 대한 세부 사항은 이 장의 범위를 벗어나며, 여러분은 일반적으로 커스텀 <code>Future</code> 구현을 작성할 때만 이를 생각하면 됩니다. 대신 우리는 <code>self</code>의 타입에 집중할 것입니다. 이는 우리가 <code>self</code>에 타입 어노테이션이 있는 메서드를 처음 보는 것이기 때문입니다. <code>self</code>에 대한 타입 어노테이션은 다른 함수 매개변수에 대한 타입 어노테이션과 비슷하게 작동하지만, 두 가지 주요 차이점이 있습니다.</p>
<ul>
<li>
<p>메서드가 호출되기 위해 <code>self</code>가 어떤 타입이어야 하는지를 러스트에게 알려줍니다.</p>
</li>
<li>
<p>단순히 아무 타입이나 될 수는 없습니다. 메서드가 구현된 타입, 그 타입에 대한 참조나 스마트 포인터, 또는 그 타입에 대한 참조를 감싸는 <code>Pin</code>으로 제한됩니다.</p>
</li>
</ul>
<p>이 문법에 대해서는 <a href="ch18-00-oop.html">18장</a><!-- ignore -->에서 더 자세히 보게 될 것입니다. 지금은 퓨처가 <code>Pending</code>인지 <code>Ready(Output)</code>인지 확인하기 위해 폴링하고 싶다면, 해당 타입에 대한 <code>Pin</code>으로 감싸인 가변 참조가 필요하다는 것만 알면 충분합니다.</p>
<p><code>Pin</code>은 <code>&amp;</code>, <code>&amp;mut</code>, <code>Box</code>, <code>Rc</code>와 같은 포인터 유사 타입들을 위한 래퍼입니다. (엄밀히 말하면 <code>Pin</code>은 <code>Deref</code>나 <code>DerefMut</code> 트레이트를 구현하는 타입들과 함께 작동하지만, 이는 사실상 포인터들하고만 작동하는 것과 같습니다.) <code>Pin</code>은 그 자체로 포인터가 아니며, 참조 카운팅을 하는 <code>Rc</code>나 <code>Arc</code>와 같은 고유한 동작을 가지고 있지도 않습니다. 그것은 순전히 컴파일러가 포인터 사용에 대한 제약 조건을 강제하기 위해 사용할 수 있는 도구일 뿐입니다.</p>
<p><code>await</code>가 <code>poll</code> 호출을 기반으로 구현된다는 점을 상기해 보면 아까 보았던 에러 메시지가 조금씩 이해되기 시작하지만, 그 에러는 <code>Pin</code>이 아니라 <code>Unpin</code>에 관한 것이었습니다. 그렇다면 정확히 <code>Pin</code>은 <code>Unpin</code>과 어떤 관계가 있으며, 왜 <code>Future</code>는 <code>poll</code>을 호출하기 위해 <code>self</code>가 <code>Pin</code> 타입 내에 있어야 할까요?</p>
<p>이 장의 앞부분에서 퓨처 내의 일련의 await 지점들이 상태 머신으로 컴파일되며, 컴파일러는 그 상태 머신이 대여 및 소유권을 포함하여 러스트의 모든 일반적인 안전성 규칙을 따르도록 보장한다는 점을 기억하세요. 이를 위해 러스트는 한 await 지점과 다음 await 지점 사이, 또는 비동기 블록의 끝 사이에 어떤 데이터가 필요한지 살펴봅니다. 그런 다음 컴파일된 상태 머신에 그에 대응하는 변형(variant)을 만듭니다. 각 변형은 소스 코드의 해당 섹션에서 사용될 데이터에 대해, 데이터의 소유권을 가져오거나 가변 또는 불변 참조를 얻음으로써 필요한 접근 권한을 갖게 됩니다.</p>
<p>여기까지는 좋습니다. 주어진 비동기 블록 내의 소유권이나 참조에 잘못된 점이 있다면 대여 검사기가 알려줄 테니까요. 하지만 그 블록에 해당하는 퓨처를 이동시키고 싶을 때—예를 들어 <code>join_all</code>에 전달하기 위해 <code>Vec</code>에 넣는 경우—상황은 더 까다로워집니다.</p>
<p>우리가 퓨처를 이동시킬 때—그것이 <code>join_all</code>에서 반복자로 사용하기 위해 데이터 구조에 밀어 넣는 것이든, 함수에서 반환하는 것이든—그것은 사실 러스트가 우리를 위해 만든 상태 머신을 이동시키는 것을 의미합니다. 그리고 러스트의 대부분의 다른 타입들과 달리, 비동기 블록을 위해 러스트가 만드는 퓨처들은 그림 17-4의 단순화된 삽화에서 보여주듯 주어진 변형의 필드에 자기 자신에 대한 참조를 가질 수 있게 됩니다.</p>
<figure>
<img alt="A single-column, three-row table representing a future, fut1, which has data values 0 and 1 in the first two rows and an arrow pointing from the third row back to the second row, representing an internal reference within the future." src="img/trpl17-04.svg" class="center" />
<figcaption>Figure 17-4: A self-referential data type.</figcaption>
</figure>
<p>하지만 기본적으로 자기 자신에 대한 참조를 가진 객체는 이동하기에 안전하지 않습니다. 참조는 항상 자신이 참조하는 대상의 실제 메모리 주소를 가리키기 때문입니다(그림 17-5 참조). 데이터 구조 자체를 이동시키면, 그 내부의 참조들은 예전 위치를 가리키는 채로 남게 됩니다. 하지만 그 메모리 위치는 이제 유효하지 않습니다. 우선 데이터 구조를 변경해도 그 값은 업데이트되지 않을 것입니다. 또한—더 중요한 것은—컴퓨터가 이제 그 메모리를 다른 용도로 자유롭게 재사용할 수 있다는 점입니다! 나중에 완전히 상관없는 데이터를 읽게 될 수도 있습니다.</p>
<figure>
<img alt="Two tables, depicting two futures, fut1 and fut2, each of which has one column and three rows, representing the result of having moved a future out of fut1 into fut2. The first, fut1, is grayed out, with a question mark in each index, representing unknown memory. The second, fut2, has 0 and 1 in the first and second rows and an arrow pointing from its third row back to the second row of fut1, representing a pointer that is referencing the old location in memory of the future before it was moved." src="img/trpl17-05.svg" class="center" />
<figcaption>Figure 17-5: The unsafe result of moving a self-referential data type</figcaption>
</figure>
<p>이론적으로는 러스트 컴파일러가 객체가 이동할 때마다 그 객체에 대한 모든 참조를 업데이트하도록 시도할 수도 있겠지만, 이는 특히 수많은 참조가 얽혀 있는 경우 막대한 성능 오버헤드를 발생시킬 수 있습니다. 대신 문제가 되는 데이터 구조가 <em>메모리에서 이동하지 않도록</em> 보장할 수 있다면, 참조를 업데이트할 필요가 없을 것입니다. 이것이 바로 러스트의 대여 검사기가 요구하는 사항입니다. 안전한 코드에서 대여 검사기는 활성화된 참조가 있는 항목을 이동시키지 못하게 합니다.</p>
<p><code>Pin</code>은 이를 기반으로 우리에게 필요한 정확한 보장을 제공합니다. 어떤 값에 대한 포인터를 <code>Pin</code>으로 감싸서 그 값을 _피닝(pin)_하면, 그 값은 더 이상 이동할 수 없게 됩니다. 따라서 <code>Pin&lt;Box&lt;SomeType&gt;&gt;</code>을 가지고 있다면, 실제로는 <code>Box</code> 포인터가 아니라 <code>SomeType</code> 값을 피닝하는 것입니다. 그림 17-6이 이 과정을 보여줍니다.</p>
<figure>
<img alt="Three boxes laid out side by side. The first is labeled “Pin”, the second “b1”, and the third “pinned”. Within “pinned” is a table labeled “fut”, with a single column; it represents a future with cells for each part of the data structure. Its first cell has the value “0”, its second cell has an arrow coming out of it and pointing to the fourth and final cell, which has the value “1” in it, and the third cell has dashed lines and an ellipsis to indicate there may be other parts to the data structure. All together, the “fut” table represents a future which is self-referential. An arrow leaves the box labeled “Pin”, goes through the box labeled “b1” and has terminates inside the “pinned” box at the “fut” table." src="img/trpl17-06.svg" class="center" />
<figcaption>Figure 17-6: Pinning a `Box` that points to a self-referential future type.</figcaption>
</figure>
<p>사실 <code>Box</code> 포인터 자체는 여전히 자유롭게 이동할 수 있습니다. 우리가 신경 쓰는 것은 궁극적으로 참조되는 데이터가 제자리에 머물도록 보장하는 것임을 기억하세요. 그림 17-7에서 보듯 포인터가 이동하더라도 <em>그것이 가리키는 데이터가 같은 위치에 있다면</em> 잠재적인 문제는 없습니다. (독자적인 연습 과제로, <code>std::pin</code> 모듈과 관련 타입들의 문서를 살펴보고 <code>Box</code>를 감싸는 <code>Pin</code>으로 이를 어떻게 수행할지 생각해 보세요.) 핵심은 자기 참조형 타입 자체가 여전히 피닝되어 있기 때문에 이동할 수 없다는 것입니다.</p>
<figure>
<img alt="Four boxes laid out in three rough columns, identical to the previous diagram with a change to the second column. Now there are two boxes in the second column, labeled “b1” and “b2”, “b1” is grayed out, and the arrow from “Pin” goes through “b2” instead of “b1”, indicating that the pointer has moved from “b1” to “b2”, but the data in “pinned” has not moved." src="img/trpl17-07.svg" class="center" />
<figcaption>Figure 17-7: Moving a `Box` which points to a self-referential future type.</figcaption>
</figure>
<p>하지만 설령 <code>Pin</code> 포인터 뒤에 있더라도 대부분의 타입들은 이동시키는 것이 완벽하게 안전합니다. 우리는 항목이 내부 참조를 가지고 있을 때만 피닝을 생각하면 됩니다. 숫자나 불리언 같은 기본 타입의 값들은 당연히 내부 참조가 없으므로 확실히 안전합니다. 여러분이 보통 러스트에서 다루는 대부분의 타입들도 마찬가지입니다. 예를 들어 <code>Vec</code>은 걱정 없이 이동시킬 수 있습니다. 지금까지 본 내용만 고려한다면, <code>Pin&lt;Vec&lt;String&gt;&gt;</code>을 가지고 있을 때 비록 <code>Vec&lt;String&gt;</code>에 다른 참조가 없어서 항상 이동하기에 안전하더라도 <code>Pin</code>이 제공하는 안전하지만 제한적인 API를 통해서만 모든 작업을 해야 할 것입니다. 우리는 이런 경우에 항목을 이동시켜도 괜찮다고 컴파일러에게 알려줄 방법이 필요하며, 바로 여기서 <code>Unpin</code>이 등장합니다.</p>
<p><code>Unpin</code>은 16장에서 보았던 <code>Send</code>, <code>Sync</code> 트레이트와 유사한 마커 트레이트이며, 따라서 그 자체로는 아무런 기능이 없습니다. 마커 트레이트는 오직 특정 맥락에서 주어진 트레이트를 구현하는 타입을 사용하는 것이 안전하다고 컴파일러에게 알려주기 위해 존재합니다. <code>Unpin</code>은 주어진 타입이 해당 값이 안전하게 이동될 수 있는지에 대한 어떠한 보장도 유지할 필요가 없음을 컴파일러에게 알려줍니다.</p>
<!--
  The inline `<code>` in the next block is to allow the inline `<em>` inside it,
  matching what NoStarch does style-wise, and emphasizing within the text here
  that it is something distinct from a normal type.
-->
<p><code>Send</code> 및 <code>Sync</code>와 마찬가지로, 컴파일러는 안전함이 증명된 모든 타입에 대해 <code>Unpin</code>을 자동으로 구현합니다. 역시 <code>Send</code> 및 <code>Sync</code>와 유사하게 <code>Unpin</code>이 구현되지 <em>않는</em> 특별한 경우는 <code>impl !Unpin for <em>SomeType</em></code>으로 표기하며, 여기서 <code><em>SomeType</em></code>은 해당 타입에 대한 포인터가 <code>Pin</code> 내에서 사용될 때마다 안전을 위해 그러한 보장을 유지해야 <em>하는</em> 타입의 이름입니다.</p>
<p>다시 말해, <code>Pin</code>과 <code>Unpin</code>의 관계에 대해 두 가지를 명심해야 합니다. 첫째, <code>Unpin</code>이 "일반적인" 경우이고 <code>!Unpin</code>이 특별한 경우입니다. 둘째, 어떤 타입이 <code>Unpin</code>을 구현하는지 혹은 <code>!Unpin</code>을 구현하는지는 오직 여러분이 <code>Pin&lt;&amp;mut <em>SomeType</em>&gt;</code>과 같이 해당 타입에 대한 피닝된 포인터를 사용할 때만 중요합니다.</p>
<p>이를 구체화하기 위해 <code>String</code>을 생각해 봅시다. <code>String</code>은 길이와 그것을 구성하는 유니코드 캐릭터들을 가지고 있습니다. 그림 17-8에서 보듯 <code>String</code>을 <code>Pin</code>으로 감쌀 수 있습니다. 하지만 <code>String</code>은 러스트의 대부분의 다른 타입들과 마찬가지로 자동으로 <code>Unpin</code>을 구현합니다.</p>
<figure>
<img alt="Concurrent work flow" src="img/trpl17-08.svg" class="center" />
<figcaption>Figure 17-8: Pinning a `String`; the dotted line indicates that the `String` implements the `Unpin` trait, and thus is not pinned.</figcaption>
</figure>
<p>그 결과, 만약 <code>String</code>이 대신 <code>!Unpin</code>을 구현했다면 불법이었을 일들을 할 수 있습니다. 예를 들어 그림 17-9와 같이 메모리의 정확히 동일한 위치에서 하나의 문자열을 다른 문자열로 교체하는 것이 가능합니다. 이는 <code>Pin</code> 계약을 위반하지 않는데, <code>String</code>은 이동시키기에 안전하지 않게 만드는 내부 참조를 가지고 있지 않기 때문입니다! 그것이 바로 <code>String</code>이 <code>!Unpin</code>이 아닌 <code>Unpin</code>을 구현하는 정확한 이유입니다.</p>
<figure>
<img alt="Concurrent work flow" src="img/trpl17-09.svg" class="center" />
<figcaption>Figure 17-9: Replacing the `String` with an entirely different `String` in memory.</figcaption>
</figure>
<p>이제 우리는 목록 17-17에서 보았던 <code>join_all</code> 호출 시 보고된 에러들을 이해할 수 있을 만큼 충분히 알게 되었습니다. 원래 우리는 비동기 블록에 의해 생성된 퓨처들을 <code>Vec&lt;Box&lt;dyn Future&lt;Output = ()&gt;&gt;&gt;</code>로 옮기려 했지만, 우리가 보았듯이 그 퓨처들은 내부 참조를 가질 수 있어 <code>Unpin</code>을 구현하지 않습니다. 그것들은 피닝(pinned)될 필요가 있으며, 그렇게 함으로써 우리는 퓨처 내부의 데이터가 이동하지 않을 것이라는 확신을 가지고 <code>Pin</code> 타입을 <code>Vec</code>에 전달할 수 있습니다.</p>
<p><code>Pin</code>과 <code>Unpin</code>은 일상적인 러스트 코드보다는 주로 저수준 라이브러리를 구축하거나 런타임 자체를 만들 때 중요합니다. 하지만 이제 에러 메시지에서 이러한 트레이트들을 보게 된다면, 코드를 어떻게 고쳐야 할지 더 잘 알게 되실 겁니다!</p>
<blockquote>
<p>참고: <code>Pin</code>과 <code>Unpin</code>의 조합은 자기 참조형(self-referential)이라서 구현하기 까다로웠을 일련의 복잡한 타입들을 러스트에서 안전하게 구현할 수 있게 해줍니다. 오늘날 비동기 러스트에서 <code>Pin</code>을 필요로 하는 타입들이 가장 흔히 나타나지만, 가끔씩 다른 맥락에서도 이들을 볼 수 있습니다.</p>
<p><code>Pin</code>과 <code>Unpin</code>이 어떻게 작동하는지, 그리고 이들이 지켜야 하는 규칙들에 대해서는 <code>std::pin</code>의 API 문서에서 광범위하게 다루고 있습니다. 더 자세히 알고 싶다면 그곳이 좋은 출발점이 될 것입니다.</p>
<p>내부적으로 어떻게 작동하는지 더 자세히 알고 싶다면, <a href="https://rust-lang.github.io/async-book/"><em>Asynchronous Programming in Rust</em></a>의 <a href="https://rust-lang.github.io/async-book/02_execution/01_chapter.html">2장</a>과 <a href="https://rust-lang.github.io/async-book/04_pinning/01_chapter.html">4장</a>을 참조하세요.</p>
</blockquote>
<h3 id="stream-트레이트"><a class="header" href="#stream-트레이트"><code>Stream</code> 트레이트</a></h3>
<p>이제 <code>Future</code>, <code>Pin</code>, <code>Unpin</code> 트레이트에 대해 더 깊이 이해했으니, <code>Stream</code> 트레이트로 관심을 돌려봅시다. 이 장의 앞부분에서 배웠듯이, 스트림은 비동기 반복자와 비슷합니다. 하지만 <code>Iterator</code>나 <code>Future</code>와 달리, 이 글을 쓰는 시점에 <code>Stream</code>은 표준 라이브러리에 정의되어 있지 않습니다. 대신 생태계 전반에서 사용되는 <code>futures</code> 크레이트의 매우 공통적인 정의가 존재합니다.</p>
<p><code>Stream</code> 트레이트가 이들을 어떻게 병합하는지 살펴보기 전에, <code>Iterator</code>와 <code>Future</code> 트레이트의 정의를 복습해 봅시다. <code>Iterator</code>로부터는 순차열(sequence)의 개념을 얻습니다. 그것의 <code>next</code> 메서드는 <code>Option&lt;Self::Item&gt;</code>을 제공하죠. <code>Future</code>로부터는 시간에 따른 준비성(readiness)의 개념을 얻습니다. 그것의 <code>poll</code> 메서드는 <code>Poll&lt;Self::Output&gt;</code>을 제공합니다. 시간이 지남에 따라 준비되는 일련의 항목들을 표현하기 위해, 우리는 이 기능들을 하나로 합친 <code>Stream</code> 트레이트를 정의합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::pin::Pin;
use std::task::{Context, Poll};

trait Stream {
    type Item;

    fn poll_next(
        self: Pin&lt;&amp;mut Self&gt;,
        cx: &amp;mut Context&lt;'_&gt;
    ) -&gt; Poll&lt;Option&lt;Self::Item&gt;&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p><code>Stream</code> 트레이트는 스트림에 의해 생성되는 항목들의 타입을 위해 <code>Item</code>이라는 연관 타입을 정의합니다. 이는 0개에서 여러 개의 항목이 있을 수 있는 <code>Iterator</code>와 비슷하며, 항상 단일 <code>Output</code>(설령 그것이 유닛 타입 <code>()</code>일지라도)을 가지는 <code>Future</code>와는 다릅니다.</p>
<p><code>Stream</code>은 또한 그 항목들을 가져오기 위한 메서드를 정의합니다. 우리는 이를 <code>poll_next</code>라고 부르는데, 이는 <code>Future::poll</code>과 같은 방식으로 폴링하고 <code>Iterator::next</code>와 같은 방식으로 일련의 항목을 생성한다는 것을 명확히 하기 위해서입니다. 그것의 반환 타입은 <code>Poll</code>과 <code>Option</code>을 결합한 것입니다. 퓨처와 마찬가지로 준비 상태를 확인해야 하므로 바깥쪽 타입은 <code>Poll</code>입니다. 안쪽 타입은 반복자와 마찬가지로 더 이상의 메시지가 있는지 알려주어야 하므로 <code>Option</code>입니다.</p>
<p>이 정의와 매우 유사한 것이 조만간 러스트 표준 라이브러리의 일부가 될 가능성이 높습니다. 그 전까지는 대부분의 런타임이 제공하는 도구의 일부이므로 안심하고 사용하셔도 되며, 우리가 다음에 다룰 모든 내용은 일반적으로 동일하게 적용될 것입니다!</p>
<p>하지만 스트리밍 섹션에서 보았던 예제에서는 <code>poll_next</code>나 <code>Stream</code>을 직접 사용하지 않고, 대신 <code>next</code>와 <code>StreamExt</code>를 사용했습니다. 물론 우리가 직접 <code>Stream</code> 상태 머신을 손으로 작성하여 <code>poll_next</code> API를 직접 다룰 수도 있습니다. 마치 <code>poll</code> 메서드를 통해 퓨처를 직접 다룰 수 있는 것과 마찬가지죠. 하지만 <code>await</code>를 사용하는 것이 훨씬 더 깔끔하며, <code>StreamExt</code> 트레이트가 <code>next</code> 메서드를 제공하므로 우리는 그렇게 할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::pin::Pin;
</span><span class="boring">use std::task::{Context, Poll};
</span><span class="boring">
</span><span class="boring">trait Stream {
</span><span class="boring">    type Item;
</span><span class="boring">    fn poll_next(
</span><span class="boring">        self: Pin&lt;&amp;mut Self&gt;,
</span><span class="boring">        cx: &amp;mut Context&lt;'_&gt;,
</span><span class="boring">    ) -&gt; Poll&lt;Option&lt;Self::Item&gt;&gt;;
</span><span class="boring">}
</span><span class="boring">
</span>trait StreamExt: Stream {
    async fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;
    where
        Self: Unpin;

    // 다른 메서드들...
}
<span class="boring">}</span></code></pre></pre>
<!--
TODO: update this if/when tokio/etc. update their MSRV and switch to using async functions
in traits, since the lack thereof is the reason they do not yet have this.
-->
<blockquote>
<p>참고: 이 장 앞부분에서 사용했던 실제 정의는 이와 약간 다르게 생겼는데, 이는 아직 트레이트에서 비동기 함수 사용을 지원하지 않던 러스트 버전들을 지원하기 위해서입니다. 그 결과, 다음과 같은 모습을 띠게 됩니다.</p>
<pre><code class="language-rust ignore">fn next(&amp;mut self) -&gt; Next&lt;'_, Self&gt; where Self: Unpin;</code></pre>
<p>저 <code>Next</code> 타입은 <code>Future</code>를 구현하는 <code>struct</code>이며, 우리가 <code>Next&lt;'_, Self&gt;</code>를 통해 <code>self</code>에 대한 참조의 라이프타임을 명명할 수 있게 해주어 <code>await</code>가 이 메서드와 함께 작동할 수 있도록 합니다.</p>
</blockquote>
<p><code>StreamExt</code> 트레이트는 스트림과 함께 사용할 수 있는 모든 흥미로운 메서드들이 모여 있는 곳이기도 합니다. <code>StreamExt</code>는 <code>Stream</code>을 구현하는 모든 타입에 대해 자동으로 구현되지만, 커뮤니티가 기초가 되는 트레이트에 영향을 주지 않으면서 편의용 API들을 발전시킬 수 있도록 이 트레이트들은 별도로 정의되어 있습니다.</p>
<p><code>trpl</code> 크레이트에서 사용되는 <code>StreamExt</code> 버전에서는, 이 트레이트가 <code>next</code> 메서드를 정의할 뿐만 아니라 <code>Stream::poll_next</code>를 호출하는 세부 사항을 올바르게 처리하는 <code>next</code>의 기본 구현도 제공합니다. 즉, 여러분이 자신만의 스트리밍 데이터 타입을 작성해야 할 때라도 <code>Stream</code>만 구현하면 되며, 그러면 여러분의 데이터 타입을 사용하는 누구라도 자동으로 <code>StreamExt</code>와 그 메서드들을 사용할 수 있게 됩니다.</p>
<p>이 트레이트들의 저수준 세부 사항에 대해 다룰 내용은 이것이 전부입니다. 마무리하면서, (스트림을 포함한) 퓨처, 태스크, 그리고 스레드가 모두 어떻게 함께 어우러지는지 생각해 봅시다!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch17-04-streams.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch17-06-futures-tasks-threads.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch17-04-streams.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch17-06-futures-tasks-threads.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
