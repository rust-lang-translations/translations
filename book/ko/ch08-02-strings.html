<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>문자열로 UTF-8 인코딩된 텍스트 저장하기 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch08-02-strings.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch08-02-strings.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="문자열로-utf-8-인코딩된-텍스트-저장하기"><a class="header" href="#문자열로-utf-8-인코딩된-텍스트-저장하기">문자열로 UTF-8 인코딩된 텍스트 저장하기</a></h2>
<p>우리는 4장에서 문자열에 대해 이야기했지만, 이제 더 깊이 있게 살펴보겠습니다. 새로운 러스트 사용자들은 흔히 세 가지 이유가 복합적으로 작용하여 문자열에서 막히곤 합니다: 발생 가능한 오류를 노출하려는 러스트의 경향, 문자열이 많은 프로그래머들이 생각하는 것보다 더 복잡한 데이터 구조라는 점, 그리고 UTF-8입니다. 이러한 요인들이 결합되어 다른 프로그래밍 언어에서 온 사람들에게는 어렵게 느껴질 수 있습니다.</p>
<p>문자열은 바이트 컬렉션에 이 바이트들이 텍스트로 해석될 때 유용한 기능을 제공하는 몇 가지 메서드가 추가된 형태로 구현되어 있기 때문에, 컬렉션의 맥락에서 논의합니다. 이번 섹션에서는 생성, 업데이트, 읽기 등 모든 컬렉션 타입이 가지고 있는 <code>String</code>에 대한 연산들을 살펴보겠습니다. 또한 <code>String</code>이 다른 컬렉션과 다른 점, 즉 사람과 컴퓨터가 <code>String</code> 데이터를 해석하는 방식의 차이로 인해 <code>String</code>에 대한 인덱싱이 어떻게 복잡해지는지도 논의할 것입니다.</p>
<h3 id="문자열이란-무엇인가"><a class="header" href="#문자열이란-무엇인가">문자열이란 무엇인가?</a></h3>
<p>먼저 _문자열(string)_이라는 용어가 무엇을 의미하는지 정의해 보겠습니다. 러스트의 코어 언어에는 오직 하나의 문자열 타입만 있는데, 바로 빌린 형태인 <code>&amp;str</code>로 주로 보이는 문자열 슬라이스 <code>str</code>입니다. 4장에서 우리는 다른 곳에 저장된 UTF-8 인코딩된 문자열 데이터에 대한 참조인 _문자열 슬라이스_에 대해 이야기했습니다. 예를 들어 문자열 리터럴은 프로그램의 바이너리에 저장되므로 문자열 슬라이스입니다.</p>
<p>러스트의 표준 라이브러리에서 제공되며 코어 언어에 코딩되지 않은 <code>String</code> 타입은 확장 가능하고, 가변적이며, 소유권을 가지는 UTF-8 인코딩된 문자열 타입입니다. 러스트 개발자들이 러스트에서 "문자열"이라고 언급할 때, 그들은 <code>String</code> 또는 문자열 슬라이스 <code>&amp;str</code> 타입 중 하나를 지칭할 수 있으며, 단순히 한 가지 타입만을 의미하지는 않습니다. 이 섹션은 주로 <code>String</code>에 대한 것이지만, 두 타입 모두 러스트의 표준 라이브러리에서 많이 사용되며, <code>String</code>과 문자열 슬라이스 모두 UTF-8로 인코딩됩니다.</p>
<h3 id="새-문자열-생성하기"><a class="header" href="#새-문자열-생성하기">새 문자열 생성하기</a></h3>
<p><code>Vec&lt;T&gt;</code>에서 사용 가능한 많은 동일한 연산들이 <code>String</code>에서도 사용 가능합니다. <code>String</code>은 실제로 몇 가지 추가 보장, 제한 및 기능을 가진 바이트 벡터를 감싸는 래퍼로 구현되어 있기 때문입니다. <code>Vec&lt;T&gt;</code>와 <code>String</code>에서 동일하게 작동하는 함수의 예는 목록 8-11에 표시된 인스턴스를 생성하는 <code>new</code> 함수입니다.</p>
<Listing number="8-11" caption="Creating a new, empty `String`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::new();
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 줄은 <code>s</code>라는 새롭고 빈 문자열을 생성하며, 여기에 데이터를 로드할 수 있습니다. 종종 문자열을 시작할 초기 데이터가 있을 것입니다. 이를 위해 문자열 리터럴처럼 <code>Display</code> 트레이트를 구현하는 모든 타입에서 사용 가능한 <code>to_string</code> 메서드를 사용합니다. 목록 8-12는 두 가지 예시를 보여줍니다.</p>
<Listing number="8-12" caption="Using the `to_string` method to create a `String` from a string literal">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let data = "초기 내용";

    let s = data.to_string();

    // 이 메서드는 리터럴에서도 직접 작동합니다:
    let s = "초기 내용".to_string();
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 코드는 <code>initial contents</code>를 포함하는 문자열을 생성합니다.</p>
<p>또한 <code>String::from</code> 함수를 사용하여 문자열 리터럴로부터 <code>String</code>을 생성할 수도 있습니다. 목록 8-13의 코드는 <code>to_string</code>을 사용하는 목록 8-12의 코드와 동일합니다.</p>
<Listing number="8-13" caption="Using the `String::from` function to create a `String` from a string literal">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s = String::from("초기 내용");
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>문자열은 매우 다양한 용도로 사용되기 때문에, 문자열에 대해 여러 가지 제네릭 API를 사용할 수 있으며, 이는 우리에게 많은 선택지를 제공합니다. 일부는 중복되어 보일 수 있지만, 모두 제 역할을 합니다! 이 경우 <code>String::from</code>과 <code>to_string</code>은 동일한 작업을 수행하므로, 어떤 것을 선택할지는 스타일과 가독성의 문제입니다.</p>
<p>문자열은 UTF-8로 인코딩된다는 점을 기억하세요. 따라서 목록 8-14에 표시된 것처럼 올바르게 인코딩된 모든 데이터를 포함할 수 있습니다.</p>
<Listing number="8-14" caption="Storing greetings in different languages in strings">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let hello = String::from("السلام عليكم");
    let hello = String::from(Dobrý den);
    let hello = String::from("Hello");
    let hello = String::from("שלום");
    let hello = String::from("नमस्ते");
    let hello = String::from("こんにちは");
    let hello = String::from("안녕하세요");
    let hello = String::from("你好");
    let hello = String::from("Olá");
    let hello = String::from("Здравствуйте");
    let hello = String::from("Hola");
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 모든 것은 유효한 <code>String</code> 값입니다.</p>
<h3 id="문자열-업데이트하기"><a class="header" href="#문자열-업데이트하기">문자열 업데이트하기</a></h3>
<p><code>String</code>은 <code>Vec&lt;T&gt;</code>의 내용처럼 크기가 커지고 내용이 변경될 수 있습니다. 데이터를 더 추가하면 말이죠. 또한 <code>+</code> 연산자나 <code>format!</code> 매크로를 편리하게 사용하여 <code>String</code> 값을 연결할 수 있습니다.</p>
<h4 id="push_str과-push로-문자열에-추가하기"><a class="header" href="#push_str과-push로-문자열에-추가하기"><code>push_str</code>과 <code>push</code>로 문자열에 추가하기</a></h4>
<p>목록 8-15에 나타난 것처럼 <code>push_str</code> 메서드를 사용하여 문자열 슬라이스를 추가함으로써 <code>String</code>을 확장할 수 있습니다.</p>
<Listing number="8-15" caption="Appending a string slice to a `String` using the `push_str` method">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::from("foo");
    s.push_str("bar");
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 두 줄이 실행된 후 <code>s</code>는 <code>foobar</code>를 포함하게 됩니다. <code>push_str</code> 메서드는 우리가 매개변수의 소유권을 가져오는 것을 반드시 원하지는 않기 때문에 문자열 슬라이스를 받습니다. 예를 들어, 목록 8-16의 코드에서 우리는 <code>s2</code>의 내용을 <code>s1</code>에 추가한 후에도 <code>s2</code>를 계속 사용하고 싶어 합니다.</p>
<Listing number="8-16" caption="Using a string slice after appending its contents to a `String`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s1 = String::from("foo");
    let s2 = "bar";
    s1.push_str(s2);
    println!("s2는 {s2}입니다");
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>만약 <code>push_str</code> 메서드가 <code>s2</code>의 소유권을 가져갔다면, 마지막 줄에서 그 값을 출력할 수 없었을 것입니다. 하지만 이 코드는 우리가 기대한 대로 작동합니다!</p>
<p><code>push</code> 메서드는 단일 문자를 매개변수로 받아 <code>String</code>에 추가합니다. 목록 8-17은 <code>push</code> 메서드를 사용하여 <code>String</code>에 글자 'l'을 추가합니다.</p>
<Listing number="8-17" caption="Adding one character to a `String` value using `push`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::from("lo");
    s.push('l');
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>결과적으로 <code>s</code>는 <code>lol</code>을 포함하게 됩니다.</p>
<h4 id="-연산자나-format-매크로를-이용한-문자열-연결"><a class="header" href="#-연산자나-format-매크로를-이용한-문자열-연결"><code>+</code> 연산자나 <code>format!</code> 매크로를 이용한 문자열 연결</a></h4>
<p>종종 두 개의 기존 문자열을 결합하고 싶을 때가 있습니다. 한 가지 방법은 목록 8-18에 나타난 것처럼 <code>+</code> 연산자를 사용하는 것입니다.</p>
<Listing number="8-18" caption="Using the `+` operator to combine two `String` values into a new `String` value">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    let s3 = s1 + &amp;s2; // s1은 여기로 이동되어 더 이상 사용할 수 없음에 유의하세요.
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>문자열 <code>s3</code>은 <code>Hello, world!</code>를 포함하게 됩니다. 더하기 연산 후 <code>s1</code>이 더 이상 유효하지 않은 이유와 <code>s2</code>에 대한 참조를 사용한 이유는 <code>+</code> 연산자를 사용할 때 호출되는 메서드의 시그니처와 관련이 있습니다. <code>+</code> 연산자는 <code>add</code> 메서드를 사용하며, 그 시그니처는 대략 다음과 같습니다.</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {</code></pre>
<p>표준 라이브러리에서 여러분은 제네릭과 연관 타입(associated types)을 사용하여 정의된 <code>add</code>를 보게 될 것입니다. 여기서는 <code>String</code> 값으로 이 메서드를 호출할 때 일어나는 일인 구체적인 타입들로 대체했습니다. 제네릭에 대해서는 10장에서 논의할 것입니다. 이 시그니처는 우리가 <code>+</code> 연산자의 까다로운 부분들을 이해하는 데 필요한 단서들을 제공합니다.</p>
<p>첫째, <code>s2</code>에는 <code>&amp;</code>가 있는데, 이는 두 번째 문자열의 _참조_를 첫 번째 문자열에 더하고 있음을 의미합니다. 이는 <code>add</code> 함수의 <code>s</code> 매개변수 때문입니다. 우리는 <code>String</code>에 <code>&amp;str</code>만 더할 수 있으며, 두 <code>String</code> 값을 더할 수는 없습니다. 하지만 잠깐만요, <code>add</code>의 두 번째 매개변수로 지정된 것은 <code>&amp;str</code>인데 <code>&amp;s2</code>의 타입은 <code>&amp;String</code>입니다. 그렇다면 왜 목록 8-18이 컴파일될까요?</p>
<p><code>add</code> 호출 시 <code>&amp;s2</code>를 사용할 수 있는 이유는 컴파일러가 <code>&amp;String</code> 인수를 <code>&amp;str</code>로 _강제(coerce)_할 수 있기 때문입니다. 우리가 <code>add</code> 메서드를 호출할 때, 러스트는 _역참조 강제(deref coercion)_를 사용하는데, 이는 여기서 <code>&amp;s2</code>를 <code>&amp;s2[..]</code>로 바꿉니다. 15장에서 역참조 강제에 대해 더 깊이 다룰 것입니다. <code>add</code>는 <code>s</code> 매개변수의 소유권을 가져가지 않으므로, 이 연산 후에도 <code>s2</code>는 여전히 유효한 <code>String</code>으로 남습니다.</p>
<p>둘째, 시그니처를 보면 <code>self</code>에 <code>&amp;</code>가 없으므로 <code>add</code>가 <code>self</code>의 소유권을 가져간다는 것을 알 수 있습니다. 이는 목록 8-18의 <code>s1</code>이 <code>add</code> 호출로 이동되어 그 이후로는 더 이상 유효하지 않음을 의미합니다. 따라서 <code>let s3 = s1 + &amp;s2;</code>가 두 문자열을 모두 복사하고 새로운 문자열을 만드는 것처럼 보일지라도, 실제로는 <code>s1</code>의 소유권을 가져와서 <code>s2</code>의 내용 복사본을 덧붙인 다음 결과의 소유권을 반환합니다. 즉, 많은 복사가 일어나는 것처럼 보이지만 실제로는 그렇지 않으며, 구현이 복사보다 더 효율적입니다.</p>
<p>여러 문자열을 결합해야 하는 경우, <code>+</code> 연산자의 동작은 다루기 불편해집니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = s1 + "-" + &amp;s2 + "-" + &amp;s3;
<span class="boring">}</span></code></pre></pre>
<p>이 지점에서 <code>s</code>는 <code>tic-tac-toe</code>가 됩니다. 수많은 <code>+</code>와 <code>"</code> 문자로 인해 코드가 무엇을 하는지 한눈에 파악하기 어렵습니다. 문자열을 더 복잡한 방식으로 결합하려면 대신 <code>format!</code> 매크로를 사용할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = format!("{s1}-{s2}-{s3}");
<span class="boring">}</span></code></pre></pre>
<p>이 코드 역시 <code>s</code>를 <code>tic-tac-toe</code>로 설정합니다. <code>format!</code> 매크로는 <code>println!</code>과 비슷하게 작동하지만, 출력을 화면에 인쇄하는 대신 그 내용을 담은 <code>String</code>을 반환합니다. <code>format!</code>을 사용한 버전이 훨씬 읽기 쉬우며, <code>format!</code> 매크로가 생성하는 코드는 참조를 사용하므로 이 호출은 매개변수의 소유권을 가져가지 않습니다.</p>
<h3 id="문자열-인덱싱"><a class="header" href="#문자열-인덱싱">문자열 인덱싱</a></h3>
<p>다른 많은 프로그래밍 언어에서는 인덱스로 문자열의 개별 문자에 접근하는 것이 유효하고 일반적인 연산입니다. 하지만 러스트에서 인덱싱 구문을 사용하여 <code>String</code>의 일부에 접근하려고 하면 오류가 발생합니다. 목록 8-19의 유효하지 않은 코드를 살펴봅시다.</p>
<Listing number="8-19" caption="Attempting to use indexing syntax with a String">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");
    let h = s1[0];
<span class="boring">}</span></code></pre>
</Listing>
<p>이 코드는 다음과 같은 오류를 발생시킵니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `str` cannot be indexed by `{integer}`
 --&gt; src/main.rs:3:16
  |
3 |     let h = s1[0];
  |                ^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex&lt;str&gt;` is not implemented for `{integer}`, which is required by `String: Index&lt;_&gt;`
  = note: you can use `.chars().nth()` or `.bytes().nth()`
          for more information, see chapter 8 in The Book: &lt;https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings&gt;
  = help: the trait `SliceIndex&lt;[_]&gt;` is implemented for `usize`
  = help: for that trait implementation, expected `[_]`, found `str`
  = note: required for `String` to implement `Index&lt;{integer}&gt;`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections` (bin "collections") due to 1 previous error
</code></pre>
<p>오류 메시지와 노트가 상황을 잘 설명해 줍니다: 러스트 문자열은 인덱싱을 지원하지 않습니다. 그런데 왜 그럴까요? 그 질문에 답하기 위해, 러스트가 메모리에 문자열을 저장하는 방식을 논의해야 합니다.</p>
<h4 id="내부-표현"><a class="header" href="#내부-표현">내부 표현</a></h4>
<p><code>String</code>은 <code>Vec&lt;u8&gt;</code>을 감싼 래퍼입니다. 목록 8-14에서 보았던 적절히 인코딩된 UTF-8 예제 문자열들을 몇 가지 살펴보겠습니다. 먼저 이것입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from("السلام عليكم");
</span><span class="boring">    let hello = String::from(Dobrý den);
</span><span class="boring">    let hello = String::from("Hello");
</span><span class="boring">    let hello = String::from("שלום");
</span><span class="boring">    let hello = String::from("नमस्ते");
</span><span class="boring">    let hello = String::from("こんにちは");
</span><span class="boring">    let hello = String::from("안녕하세요");
</span><span class="boring">    let hello = String::from("你好");
</span><span class="boring">    let hello = String::from("Olá");
</span><span class="boring">    let hello = String::from("Здравствуйте");
</span>    let hello = String::from("Hola");
<span class="boring">}</span></code></pre></pre>
<p>이 경우 <code>len</code>은 <code>4</code>가 되며, 이는 <code>"Hola"</code> 문자열을 저장하는 벡터의 길이가 4바이트임을 의미합니다. 이 글자들은 UTF-8로 인코딩될 때 각각 1바이트를 차지합니다. 하지만 다음 줄은 여러분을 놀라게 할 수도 있습니다 (이 문자열은 숫자 3이 아니라 키릴 문자 대문자 _Ze_로 시작함에 유의하세요):</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from("السلام عليكم");
</span><span class="boring">    let hello = String::from(Dobrý den);
</span><span class="boring">    let hello = String::from("Hello");
</span><span class="boring">    let hello = String::from("שלום");
</span><span class="boring">    let hello = String::from("नमस्ते");
</span><span class="boring">    let hello = String::from("こんにちは");
</span><span class="boring">    let hello = String::from("안녕하세요");
</span><span class="boring">    let hello = String::from("你好");
</span><span class="boring">    let hello = String::from("Olá");
</span>    let hello = String::from("Здравствуйте");
<span class="boring">    let hello = String::from("Hola");
</span><span class="boring">}</span></code></pre></pre>
<p>이 문자열의 길이가 얼마냐고 묻는다면 12라고 답할 수도 있을 것입니다. 하지만 러스트의 답은 24입니다. 이는 “Здравствуйте”를 UTF-8로 인코딩하는 데 필요한 바이트 수인데, 이 문자열의 각 유니코드 스칼라 값이 2바이트의 저장 공간을 차지하기 때문입니다. 따라서 문자열 바이트에 대한 인덱스가 항상 유효한 유니코드 스칼라 값과 일치하는 것은 아닙니다. 이를 설명하기 위해, 다음의 유효하지 않은 러스트 코드를 살펴보세요:</p>
<pre><code class="language-rust ignore does_not_compile">let hello = "Здравствуйте";
let answer = &amp;hello[0];</code></pre>
<p>이미 알고 있듯이 <code>answer</code>는 첫 글자인 <code>З</code>가 되지 않을 것입니다. UTF-8로 인코딩될 때 <code>З</code>의 첫 번째 바이트는 <code>208</code>이고 두 번째 바이트는 <code>151</code>이므로, <code>answer</code>는 사실상 <code>208</code>이 되어야 할 것처럼 보이지만, <code>208</code>은 그 자체로 유효한 문자가 아닙니다. 이 문자열의 첫 글자를 요청했을 때 <code>208</code>을 반환하는 것은 아마도 사용자가 원하는 결과가 아닐 것입니다. 하지만 그것이 러스트가 바이트 인덱스 0에서 가진 유일한 데이터입니다. 문자열에 라틴 문자만 포함되어 있더라도 사용자는 일반적으로 바이트 값이 반환되는 것을 원하지 않습니다. 만약 <code>&amp;"hi"[0]</code>가 바이트 값을 반환하는 유효한 코드였다면, <code>h</code>가 아니라 <code>104</code>를 반환했을 것입니다.</p>
<p>따라서 예상치 못한 값을 반환하여 즉시 발견되지 않을 수도 있는 버그를 일으키는 것을 방지하기 위해, 러스트는 이 코드를 아예 컴파일하지 않으며 개발 과정 초기에 오해를 방지합니다.</p>
<h4 id="바이트와-스칼라-값과-그래핌-클러스터-오-이런"><a class="header" href="#바이트와-스칼라-값과-그래핌-클러스터-오-이런">바이트와 스칼라 값과 그래핌 클러스터! 오 이런!</a></h4>
<p>UTF-8에 대한 또 다른 요점은, 러스트의 관점에서 문자열을 바라보는 세 가지 유의미한 방법이 있다는 것입니다: 바이트, 스칼라 값, 그리고 그래핌 클러스터(우리가 _글자_라고 부르는 것에 가장 가까운 것)입니다.</p>
<p>데바나가리 문자로 쓰인 힌디어 단어 “नमस्ते”를 살펴보면, 다음과 같은 <code>u8</code> 값의 벡터로 저장됩니다.</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>이는 18바이트이며 컴퓨터가 궁극적으로 이 데이터를 저장하는 방식입니다. 이를 러스트의 <code>char</code> 타입인 유니코드 스칼라 값으로 바라본다면, 이 바이트들은 다음과 같이 보입니다.</p>
<pre><code class="language-text">['न', 'म', 'स', '्', 'त', 'े']
</code></pre>
<p>여기에는 6개의 <code>char</code> 값이 있지만, 네 번째와 여섯 번째는 글자가 아닙니다. 그것들은 그 자체로는 의미가 없는 발음 구별 부호(diacritics)입니다. 마지막으로, 이를 그래핌 클러스터로 바라본다면, 사람이 힌디어 단어를 구성하는 네 개의 글자라고 부를 만한 결과를 얻게 됩니다.</p>
<pre><code class="language-text">["न", "म", "स्", "ते"]
</code></pre>
<p>러스트는 컴퓨터가 저장하는 원시 문자열 데이터를 해석하는 다양한 방법을 제공하므로, 데이터가 어떤 인간 언어로 되어 있든 각 프로그램이 필요한 해석 방식을 선택할 수 있습니다.</p>
<p>러스트가 <code>String</code>에 인덱싱하여 문자를 가져오는 것을 허용하지 않는 마지막 이유는 인덱싱 작업이 항상 상수 시간(O(1))이 걸릴 것으로 예상되기 때문입니다. 그러나 <code>String</code>으로는 그 성능을 보장할 수 없습니다. 왜냐하면 러스트는 유효한 문자가 몇 개인지 확인하기 위해 내용의 시작부터 인덱스까지 훑어야 하기 때문입니다.</p>
<h3 id="문자열-슬라이싱"><a class="header" href="#문자열-슬라이싱">문자열 슬라이싱</a></h3>
<p>문자열 인덱싱은 종종 좋지 않은 생각인데, 문자열 인덱싱 연산의 반환 타입이 무엇이어야 할지 명확하지 않기 때문입니다: 바이트 값, 문자, 그래핌 클러스터, 또는 문자열 슬라이스 중 무엇일까요? 따라서 인덱스를 사용하여 문자열 슬라이스를 만들어야 한다면, 러스트는 더 구체적으로 명시할 것을 요구합니다.</p>
<p>단일 숫자로 <code>[]</code>를 사용하여 인덱싱하는 대신, 범위와 함께 <code>[]</code>를 사용하여 특정 바이트를 포함하는 문자열 슬라이스를 만들 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = "Здравствуйте";

let s = &amp;hello[0..4];
<span class="boring">}</span></code></pre></pre>
<p>여기서 <code>s</code>는 문자열의 처음 4바이트를 포함하는 <code>&amp;str</code>이 될 것입니다. 앞서 각 문자가 2바이트라고 언급했으므로, <code>s</code>는 <code>Зд</code>가 될 것입니다.</p>
<p>만약 <code>&amp;hello[0..1]</code>과 같이 문자의 바이트 일부만 슬라이스하려고 시도한다면, 벡터에서 유효하지 않은 인덱스에 접근했을 때와 마찬가지로 런타임에 패닉이 발생할 것입니다:</p>
<pre><code> Running `target/debug/collections`
</code></pre>
<p>thread 'main' panicked at src/main.rs:4:19: byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of <code>Здравствуйте</code> note: run with <code>RUST_BACKTRACE=1</code> environment variable to display a backtrace</p>
<pre><code></code></pre>
<p>범위를 사용하여 문자열 슬라이스를 만들 때는 주의해야 합니다. 그렇게 하면 프로그램이 충돌할 수 있기 때문입니다.</p>
<h3 id="문자열을-반복하는-메서드"><a class="header" href="#문자열을-반복하는-메서드">문자열을 반복하는 메서드</a></h3>
<p>문자열 조각을 조작하는 가장 좋은 방법은 문자 또는 바이트를 원하는지 명시적으로 지정하는 것입니다. 개별 유니코드 스칼라 값의 경우 <code>chars</code> 메서드를 사용하십시오. “Зд”에 대해 <code>chars</code>를 호출하면 두 개의 <code>char</code> 타입 값이 분리되어 반환되며, 결과를 반복하여 각 요소에 접근할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for c in "Зд".chars() {
    println!("{c}");
}
<span class="boring">}</span></code></pre></pre>
<p>이 코드는 다음을 출력합니다:</p>
<pre><code class="language-text">З
д
</code></pre>
<p>또는 <code>bytes</code> 메서드는 각 원시 바이트를 반환하며, 이는 여러분의 도메인에 적합할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for b in "Зд".bytes() {
    println!("{b}");
}
<span class="boring">}</span></code></pre></pre>
<p>이 코드는 이 문자열을 구성하는 4바이트를 출력합니다:</p>
<pre><code class="language-text">208
151
208
180
</code></pre>
<p>하지만 유효한 유니코드 스칼라 값은 1바이트 이상으로 구성될 수 있다는 점을 기억하십시오.</p>
<p>데바나가리 문자와 같이 문자열에서 그래핌 클러스터를 얻는 것은 복잡하므로 표준 라이브러리에서는 이 기능을 제공하지 않습니다. 이 기능이 필요한 경우 <a href="https://crates.io/">crates.io</a><!-- ignore -->에서 크레이트를 사용할 수 있습니다.</p>
<h3 id="문자열은-그렇게-간단하지-않습니다"><a class="header" href="#문자열은-그렇게-간단하지-않습니다">문자열은 그렇게 간단하지 않습니다</a></h3>
<p>요약하자면, 문자열은 복잡합니다. 프로그래밍 언어마다 이 복잡성을 프로그래머에게 제시하는 방법에 대해 서로 다른 선택을 합니다. 러스트는 모든 러스트 프로그램의 기본 동작으로 <code>String</code> 데이터를 올바르게 처리하도록 선택했습니다. 이는 프로그래머가 UTF-8 데이터를 처리하는 데 미리 더 많은 생각을 해야 함을 의미합니다. 이 트레이드오프는 다른 프로그래밍 언어에서보다 문자열의 복잡성을 더 많이 노출하지만, 개발 수명 주기 후반에 비 ASCII 문자와 관련된 오류를 처리해야 하는 것을 방지합니다.</p>
<p>좋은 소식은 표준 라이브러리가 이러한 복잡한 상황을 올바르게 처리하는 데 도움이 되도록 <code>String</code> 및 <code>&amp;str</code> 타입을 기반으로 구축된 많은 기능을 제공한다는 것입니다. 문자열 내에서 검색하기 위한 <code>contains</code>와 문자열 일부를 다른 문자열로 대체하기 위한 <code>replace</code>와 같은 유용한 메서드에 대한 문서를 확인하십시오.</p>
<p>조금 덜 복잡한 것으로 전환해 봅시다: 해시 맵!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch08-01-vectors.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch08-03-hash-maps.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch08-01-vectors.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch08-03-hash-maps.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
