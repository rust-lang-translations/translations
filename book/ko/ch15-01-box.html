<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Box&lt;T&gt;를 사용하여 힙의 데이터 가리키기 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch15-01-box.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch15-01-box.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="boxt를-사용하여-힙의-데이터-가리키기"><a class="header" href="#boxt를-사용하여-힙의-데이터-가리키기"><code>Box&lt;T&gt;</code>를 사용하여 힙의 데이터 가리키기</a></h2>
<p>The most straightforward smart pointer is a box, whose type is written <code>Box&lt;T&gt;</code>. <em>Boxes</em> allow you to store data on the heap rather than the stack. What remains on the stack is the pointer to the heap data. Refer to Chapter 4 to review the difference between the stack and the heap.</p>
<p>박스는 데이터를 스택 대신 힙에 저장한다는 점 외에는 성능 오버헤드가 없습니다. 하지만 추가적인 기능도 많지 않습니다. 박스는 주로 다음과 같은 상황에서 사용하게 될 것입니다:</p>
<ul>
<li>When you have a type whose size can’t be known at compile time, and you want to use a value of that type in a context that requires an exact size</li>
<li>When you have a large amount of data, and you want to transfer ownership but ensure that the data won’t be copied when you do so</li>
<li>When you want to own a value, and you care only that it’s a type that implements a particular trait rather than being of a specific type</li>
</ul>
<p>We’ll demonstrate the first situation in <a href="#enabling-recursive-types-with-boxes">“Enabling Recursive Types with Boxes”</a><!-- ignore -->. In the second case, transferring ownership of a large amount of data can take a long time because the data is copied around on the stack. To improve performance in this situation, we can store the large amount of data on the heap in a box. Then, only the small amount of pointer data is copied around on the stack, while the data it references stays in one place on the heap. The third case is known as a <em>trait object</em>, and <a href="ch18-02-trait-objects.html#using-trait-objects-to-abstract-over-shared-behavior">“Using Trait Objects to Abstract over Shared Behavior”</a><!-- ignore --> in Chapter 18 is devoted to that topic. So, what you learn here you’ll apply again in that section!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="using-boxt-to-store-data-on-the-heap"></a></p>
<h3 id="storing-data-on-the-heap"><a class="header" href="#storing-data-on-the-heap">Storing Data on the Heap</a></h3>
<p><code>Box&lt;T&gt;</code>의 힙 저장소 사용 사례를 논의하기 전에, 문법과 <code>Box&lt;T&gt;</code> 내에 저장된 값과 상호작용하는 방법을 다루겠습니다.</p>
<p>Listing 15-1 shows how to use a box to store an <code>i32</code> value on the heap.</p>
<Listing number="15-1" file-name="src/main.rs" caption="Storing an `i32` value on the heap using a box">
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let b = Box::new(5);
    println!("b = {b}");
}</code></pre></pre>
</Listing>
<p>변수 <code>b</code>를 힙에 할당된 값 <code>5</code>를 가리키는 <code>Box</code> 값을 갖도록 정의합니다. 이 프로그램은 <code>b = 5</code>를 출력할 것입니다. 이 경우, 데이터가 스택에 있을 때와 유사한 방식으로 박스 내의 데이터에 접근할 수 있습니다. 다른 소유된 값과 마찬가지로, <code>main</code>의 끝에서 <code>b</code>가 스코프를 벗어나면 박스는 할당 해제됩니다. 할당 해제는 박스 자체(스택에 저장됨)와 박스가 가리키는 데이터(힙에 저장됨) 모두에 대해 일어납니다.</p>
<p>Putting a single value on the heap isn’t very useful, so you won’t use boxes by themselves in this way very often. Having values like a single <code>i32</code> on the stack, where they’re stored by default, is more appropriate in the majority of situations. Let’s look at a case where boxes allow us to define types that we wouldn’t be allowed to define if we didn’t have boxes.</p>
<h3 id="박스로-재귀적-타입-가능하게-하기"><a class="header" href="#박스로-재귀적-타입-가능하게-하기">박스로 재귀적 타입 가능하게 하기</a></h3>
<p>A value of a <em>recursive type</em> can have another value of the same type as part of itself. Recursive types pose an issue because Rust needs to know at compile time how much space a type takes up. However, the nesting of values of recursive types could theoretically continue infinitely, so Rust can’t know how much space the value needs. Because boxes have a known size, we can enable recursive types by inserting a box in the recursive type definition.</p>
<p>As an example of a recursive type, let’s explore the cons list. This is a data type commonly found in functional programming languages. The cons list type we’ll define is straightforward except for the recursion; therefore, the concepts in the example we’ll work with will be useful anytime you get into more complex situations involving recursive types.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="more-information-about-the-cons-list"></a></p>
<h4 id="understanding-the-cons-list"><a class="header" href="#understanding-the-cons-list">Understanding the Cons List</a></h4>
<p>A <em>cons list</em> is a data structure that comes from the Lisp programming language and its dialects, is made up of nested pairs, and is the Lisp version of a linked list. Its name comes from the <code>cons</code> function (short for <em>construct function</em>) in Lisp that constructs a new pair from its two arguments. By calling <code>cons</code> on a pair consisting of a value and another pair, we can construct cons lists made up of recursive pairs.</p>
<p>For example, here’s a pseudocode representation of a cons list containing the list <code>1, 2, 3</code> with each pair in parentheses:</p>
<pre><code class="language-text">(1, (2, (3, Nil)))
</code></pre>
<p>Each item in a cons list contains two elements: the value of the current item and of the next item. The last item in the list contains only a value called <code>Nil</code> without a next item. A cons list is produced by recursively calling the <code>cons</code> function. The canonical name to denote the base case of the recursion is <code>Nil</code>. Note that this is not the same as the “null” or “nil” concept discussed in Chapter 6, which is an invalid or absent value.</p>
<p>콘스 리스트는 러스트에서 흔히 사용되는 데이터 구조가 아닙니다. 러스트에서 항목 목록이 필요할 때는 대부분의 경우 <code>Vec&lt;T&gt;</code>가 더 나은 선택입니다. 다른 더 복잡한 재귀적 데이터 타입들은 다양한 상황에서 유용하지만, 이번 장에서 콘스 리스트로 시작함으로써 큰 혼란 없이 박스가 어떻게 재귀적 데이터 타입을 정의할 수 있게 해주는지 탐구해 볼 수 있습니다.</p>
<p>Listing 15-2 contains an enum definition for a cons list. Note that this code won’t compile yet, because the <code>List</code> type doesn’t have a known size, which we’ll demonstrate.</p>
<Listing number="15-2" file-name="src/main.rs" caption="The first attempt at defining an enum to represent a cons list data structure of `i32` values">
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, List),
    Nil,
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
</Listing>
<blockquote>
<p>참고: 이 예제에서는 <code>i32</code> 값만 담는 콘스 리스트를 구현하고 있습니다. 10장에서 논의한 것처럼 제네릭을 사용하여 어떤 타입의 값도 저장할 수 있는 콘스 리스트 타입을 정의할 수도 있었습니다.</p>
</blockquote>
<p>Using the <code>List</code> type to store the list <code>1, 2, 3</code> would look like the code in Listing 15-3.</p>
<Listing number="15-3" file-name="src/main.rs" caption="Using the `List` enum to store the list `1, 2, 3`">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, List),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span>// --생략--

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}</code></pre>
</Listing>
<p>첫 번째 <code>Cons</code> 값은 <code>1</code>과 또 다른 <code>List</code> 값을 가집니다. 이 <code>List</code> 값은 <code>2</code>와 또 다른 <code>List</code> 값을 가진 또 다른 <code>Cons</code> 값입니다. 이 <code>List</code> 값은 <code>3</code>과 <code>List</code> 값을 가진 하나 더 있는 <code>Cons</code> 값이며, 이 <code>List</code> 값은 마침내 리스트의 끝을 알리는 비재귀적 변종인 <code>Nil</code>입니다.</p>
<p>If we try to compile the code in Listing 15-3, we get the error shown in Listing 15-4.</p>
<Listing number="15-4" caption="The error we get when attempting to define a recursive enum">
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0072]: recursive type `List` has infinite size
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
2 |     Cons(i32, List),
  |               ---- recursive without indirection
  |
help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to break the cycle
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +

error[E0391]: cycle detected when computing when `List` needs drop
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
  |
  = note: ...which immediately requires computing when `List` needs drop again
  = note: cycle used when computing whether `List` needs drop
  = note: see https://rustc-dev-guide.rust-lang.org/overview.html#queries and https://rustc-dev-guide.rust-lang.org/query.html for more information

Some errors have detailed explanations: E0072, E0391.
For more information about an error, try `rustc --explain E0072`.
error: could not compile `cons-list` (bin "cons-list") due to 2 previous errors
</code></pre>
</Listing>
<p>The error shows this type “has infinite size.” The reason is that we’ve defined <code>List</code> with a variant that is recursive: It holds another value of itself directly. As a result, Rust can’t figure out how much space it needs to store a <code>List</code> value. Let’s break down why we get this error. First, we’ll look at how Rust decides how much space it needs to store a value of a non-recursive type.</p>
<h4 id="비재귀적-타입의-크기-계산하기"><a class="header" href="#비재귀적-타입의-크기-계산하기">비재귀적 타입의 크기 계산하기</a></h4>
<p>6장에서 열거형 정의를 논의할 때 목록 6-2에서 정의했던 <code>Message</code> 열거형을 떠올려 보세요:</p>
<pre><pre class="playground"><code class="language-rust edition2024">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><code>Message</code> 값에 대해 얼마나 많은 공간을 할당할지 결정하기 위해, 러스트는 각 변종들을 훑어보며 어떤 변종이 가장 많은 공간을 필요로 하는지 확인합니다. 러스트는 <code>Message::Quit</code>이 공간을 전혀 필요로 하지 않고, <code>Message::Move</code>는 두 개의 <code>i32</code> 값을 저장하기에 충분한 공간이 필요하다는 것 등을 확인합니다. 단 하나의 변종만 사용될 것이기 때문에, <code>Message</code> 값이 필요로 하는 최대 공간은 가장 큰 변종을 저장하는 데 필요한 공간입니다.</p>
<p>이와 대조적으로 러스트가 목록 15-2의 <code>List</code> 열거형과 같은 재귀적 타입에 필요한 공간을 결정하려고 할 때 어떤 일이 일어나는지 봅시다. 컴파일러는 <code>i32</code> 타입의 값과 <code>List</code> 타입의 값을 가지는 <code>Cons</code> 변종을 살펴보는 것으로 시작합니다. 따라서 <code>Cons</code>는 <code>i32</code>의 크기에 <code>List</code>의 크기를 더한 만큼의 공간이 필요합니다. <code>List</code> 타입이 얼마나 많은 메모리를 필요로 하는지 알아내기 위해, 컴파일러는 <code>Cons</code> 변종부터 시작하여 변종들을 살펴봅니다. <code>Cons</code> 변종은 <code>i32</code> 값과 <code>List</code> 값을 가지고 있으며, 그림 15-1에서 보여주듯 이 과정은 무한히 계속됩니다.</p>
<img alt="An infinite Cons list: a rectangle labeled 'Cons' split into two smaller rectangles. The first smaller rectangle holds the label 'i32', and the second smaller rectangle holds the label 'Cons' and a smaller version of the outer 'Cons' rectangle. The 'Cons' rectangles continue to hold smaller and smaller versions of themselves until the smallest comfortably sized rectangle holds an infinity symbol, indicating that this repetition goes on forever." src="img/trpl15-01.svg" class="center" style="width: 50%;" />
<p><span class="caption">그림 15-1: 무한한 <code>Cons</code> 변종들로 구성된 무한한 <code>List</code></span></p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="using-boxt-to-get-a-recursive-type-with-a-known-size"></a></p>
<h4 id="getting-a-recursive-type-with-a-known-size"><a class="header" href="#getting-a-recursive-type-with-a-known-size">Getting a Recursive Type with a Known Size</a></h4>
<p>러스트는 재귀적으로 정의된 타입에 대해 얼마나 많은 공간을 할당해야 할지 알아낼 수 없기 때문에, 컴파일러는 다음과 같은 유용한 제안과 함께 에러를 발생시킵니다:</p>
<!-- manual-regeneration
after doing automatic regeneration, look at listings/ch15-smart-pointers/listing-15-03/output.txt and copy the relevant line
-->
<pre><code class="language-text">help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to break the cycle
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +
</code></pre>
<p>In this suggestion, <em>indirection</em> means that instead of storing a value directly, we should change the data structure to store the value indirectly by storing a pointer to the value instead.</p>
<p>Because a <code>Box&lt;T&gt;</code> is a pointer, Rust always knows how much space a <code>Box&lt;T&gt;</code> needs: A pointer’s size doesn’t change based on the amount of data it’s pointing to. This means we can put a <code>Box&lt;T&gt;</code> inside the <code>Cons</code> variant instead of another <code>List</code> value directly. The <code>Box&lt;T&gt;</code> will point to the next <code>List</code> value that will be on the heap rather than inside the <code>Cons</code> variant. Conceptually, we still have a list, created with lists holding other lists, but this implementation is now more like placing the items next to one another rather than inside one another.</p>
<p>We can change the definition of the <code>List</code> enum in Listing 15-2 and the usage of the <code>List</code> in Listing 15-3 to the code in Listing 15-5, which will compile.</p>
<Listing number="15-5" file-name="src/main.rs" caption="The definition of `List` that uses `Box<T>` in order to have a known size">
<pre><pre class="playground"><code class="language-rust edition2024">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}</code></pre></pre>
</Listing>
<p>The <code>Cons</code> variant needs the size of an <code>i32</code> plus the space to store the box’s pointer data. The <code>Nil</code> variant stores no values, so it needs less space on the stack than the <code>Cons</code> variant. We now know that any <code>List</code> value will take up the size of an <code>i32</code> plus the size of a box’s pointer data. By using a box, we’ve broken the infinite, recursive chain, so the compiler can figure out the size it needs to store a <code>List</code> value. Figure 15-2 shows what the <code>Cons</code> variant looks like now.</p>
<img alt="A rectangle labeled 'Cons' split into two smaller rectangles. The first smaller rectangle holds the label 'i32', and the second smaller rectangle holds the label 'Box' with one inner rectangle that contains the label 'usize', representing the finite size of the box's pointer." src="img/trpl15-02.svg" class="center" />
<p><span class="caption">Figure 15-2: A <code>List</code> that is not infinitely sized, because <code>Cons</code> holds a <code>Box</code></span></p>
<p>Boxes provide only the indirection and heap allocation; they don’t have any other special capabilities, like those we’ll see with the other smart pointer types. They also don’t have the performance overhead that these special capabilities incur, so they can be useful in cases like the cons list where the indirection is the only feature we need. We’ll look at more use cases for boxes in Chapter 18.</p>
<p><code>Box&lt;T&gt;</code> 타입은 <code>Deref</code> 트레이트를 구현하기 때문에 스마트 포인터입니다. <code>Deref</code> 트레이트는 <code>Box&lt;T&gt;</code> 값이 참조처럼 다뤄질 수 있게 해줍니다. 박스 값이 스코프를 벗어나면, <code>Drop</code> 트레이트 구현 덕분에 박스가 가리키는 힙 데이터도 함께 정리됩니다. 이 두 트레이트는 이번 장의 나머지 부분에서 다룰 다른 스마트 포인터 타입들이 제공하는 기능에 있어 훨씬 더 중요합니다. 이 두 트레이트에 대해 더 자세히 살펴보겠습니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch15-00-smart-pointers.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch15-02-deref.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch15-00-smart-pointers.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch15-02-deref.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
