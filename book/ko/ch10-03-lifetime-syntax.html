<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>라이프타임으로 참조 유효성 검증하기 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch10-03-lifetime-syntax.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch10-03-lifetime-syntax.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="라이프타임으로-참조-유효성-검증하기"><a class="header" href="#라이프타임으로-참조-유효성-검증하기">라이프타임으로 참조 유효성 검증하기</a></h2>
<p>라이프타임은 우리가 이미 사용하고 있던 또 다른 종류의 제네릭입니다. 타입이 우리가 원하는 동작을 갖도록 보장하는 대신, 라이프타임은 참조가 필요한 만큼 오랫동안 유효하도록 보장합니다.</p>
<p>One detail we didn’t discuss in the <a href="ch04-02-references-and-borrowing.html#references-and-borrowing">“References and Borrowing”</a><!-- ignore --> section in Chapter 4 is that every reference in Rust has a lifetime, which is the scope for which that reference is valid. Most of the time, lifetimes are implicit and inferred, just like most of the time, types are inferred. We are only required to annotate types when multiple types are possible. In a similar way, we must annotate lifetimes when the lifetimes of references could be related in a few different ways. Rust requires us to annotate the relationships using generic lifetime parameters to ensure that the actual references used at runtime will definitely be valid.</p>
<p>Annotating lifetimes is not even a concept most other programming languages have, so this is going to feel unfamiliar. Although we won’t cover lifetimes in their entirety in this chapter, we’ll discuss common ways you might encounter lifetime syntax so that you can get comfortable with the concept.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="preventing-dangling-references-with-lifetimes"></a></p>
<h3 id="댕글링-참조"><a class="header" href="#댕글링-참조">댕글링 참조</a></h3>
<p>The main aim of lifetimes is to prevent dangling references, which, if they were allowed to exist, would cause a program to reference data other than the data it’s intended to reference. Consider the program in Listing 10-16, which has an outer scope and an inner scope.</p>
<Listing number="10-16" caption="An attempt to use a reference whose value has gone out of scope">
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let r;

    {
        let x = 5;
        r = &amp;x;
    }

    println!("r: {r}");
}</code></pre>
</Listing>
<blockquote>
<p>Note: The examples in Listings 10-16, 10-17, and 10-23 declare variables without giving them an initial value, so the variable name exists in the outer scope. At first glance, this might appear to be in conflict with Rust having no null values. However, if we try to use a variable before giving it a value, we’ll get a compile-time error, which shows that indeed Rust does not allow null values.</p>
</blockquote>
<p>The outer scope declares a variable named <code>r</code> with no initial value, and the inner scope declares a variable named <code>x</code> with the initial value of <code>5</code>. Inside the inner scope, we attempt to set the value of <code>r</code> as a reference to <code>x</code>. Then, the inner scope ends, and we attempt to print the value in <code>r</code>. This code won’t compile, because the value that <code>r</code> is referring to has gone out of scope before we try to use it. Here is the error message:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
 --&gt; src/main.rs:6:13
  |
5 |         let x = 5;
  |             - binding `x` declared here
6 |         r = &amp;x;
  |             ^^ borrowed value does not live long enough
7 |     }
  |     - `x` dropped here while still borrowed
8 |
9 |     println!("r: {r}");
  |                   - borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>The error message says that the variable <code>x</code> “does not live long enough.” The reason is that <code>x</code> will be out of scope when the inner scope ends on line 7. But <code>r</code> is still valid for the outer scope; because its scope is larger, we say that it “lives longer.” If Rust allowed this code to work, <code>r</code> would be referencing memory that was deallocated when <code>x</code> went out of scope, and anything we tried to do with <code>r</code> wouldn’t work correctly. So, how does Rust determine that this code is invalid? It uses a borrow checker.</p>
<h3 id="빌려주기-검사기"><a class="header" href="#빌려주기-검사기">빌려주기 검사기</a></h3>
<p>러스트 컴파일러는 모든 대여가 유효한지 결정하기 위해 스코프를 비교하는 _빌려주기 검사기(borrow checker)_를 가지고 있습니다. 목록 10-17은 목록 10-16과 동일한 코드에 변수의 라이프타임을 보여주는 주석을 추가한 것입니다.</p>
<Listing number="10-17" caption="Annotations of the lifetimes of `r` and `x`, named `'a` and `'b`, respectively">
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &amp;x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {r}");   //          |
}                         // ---------+</code></pre>
</Listing>
<p>Here, we’ve annotated the lifetime of <code>r</code> with <code>'a</code> and the lifetime of <code>x</code> with <code>'b</code>. As you can see, the inner <code>'b</code> block is much smaller than the outer <code>'a</code> lifetime block. At compile time, Rust compares the size of the two lifetimes and sees that <code>r</code> has a lifetime of <code>'a</code> but that it refers to memory with a lifetime of <code>'b</code>. The program is rejected because <code>'b</code> is shorter than <code>'a</code>: The subject of the reference doesn’t live as long as the reference.</p>
<p>Listing 10-18 fixes the code so that it doesn’t have a dangling reference and it compiles without any errors.</p>
<Listing number="10-18" caption="A valid reference because the data has a longer lifetime than the reference">
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &amp;x;           // --+-- 'a  |
                          //   |       |
    println!("r: {r}");   //   |       |
                          // --+       |
}                         // ----------+</code></pre></pre>
</Listing>
<p>여기서 <code>x</code>는 라이프타임 <code>'b</code>를 가지며, 이 경우에는 <code>'a</code>보다 큽니다. 이는 러스트가 <code>x</code>가 유효한 동안 <code>r</code>의 참조도 항상 유효하다는 것을 알기 때문에 <code>r</code>이 <code>x</code>를 참조할 수 있음을 의미합니다.</p>
<p>Now that you know where the lifetimes of references are and how Rust analyzes lifetimes to ensure that references will always be valid, let’s explore generic lifetimes in function parameters and return values.</p>
<h3 id="함수에서의-제네릭-라이프타임"><a class="header" href="#함수에서의-제네릭-라이프타임">함수에서의 제네릭 라이프타임</a></h3>
<p>두 문자열 슬라이스 중 더 긴 것을 반환하는 함수를 작성해 보겠습니다. 이 함수는 두 개의 문자열 슬라이스를 입력받아 하나의 문자열 슬라이스를 반환합니다. <code>longest</code> 함수를 구현한 후, 목록 10-19의 코드는 <code>The longest string is abcd</code>를 출력해야 합니다.</p>
<Listing number="10-19" file-name="src/main.rs" caption="A `main` function that calls the `longest` function to find the longer of two string slices">
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {result}");
}</code></pre>
</Listing>
<p>우리는 <code>longest</code> 함수가 매개변수의 소유권을 가져가는 것을 원하지 않기 때문에, 함수가 <code>String</code> 대신 참조인 문자열 슬라이스를 받기를 원한다는 점에 유의하세요. 목록 10-19에서 우리가 사용하는 매개변수들이 왜 우리가 원하는 것들인지에 대한 더 자세한 논의는 4장의 <a href="ch04-03-slices.html#string-slices-as-parameters">“매개변수로서의 문자열 슬라이스”</a><!-- ignore -->를 참조하세요.</p>
<p>목록 10-20에 나온 것처럼 <code>longest</code> 함수를 구현하려고 하면, 컴파일되지 않습니다.</p>
<Listing number="10-20" file-name="src/main.rs" caption="An implementation of the `longest` function that returns the longer of two string slices but does not yet compile">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() { x } else { y }
}</code></pre>
</Listing>
<p>대신 라이프타임에 관한 다음과 같은 에러가 발생합니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:9:33
  |
9 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
  |               ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
  |
9 | fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
  |           ++++     ++          ++          ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>도움말 텍스트를 보면 반환되는 참조가 <code>x</code>인지 <code>y</code>인지 러스트가 알 수 없기 때문에 반환 타입에 제네릭 라이프타임 매개변수가 필요함을 알 수 있습니다. 사실 우리도 알 수 없는데, 이 함수의 본문에서 <code>if</code> 블록은 <code>x</code>에 대한 참조를 반환하고 <code>else</code> 블록은 <code>y</code>에 대한 참조를 반환하기 때문입니다!</p>
<p>When we’re defining this function, we don’t know the concrete values that will be passed into this function, so we don’t know whether the <code>if</code> case or the <code>else</code> case will execute. We also don’t know the concrete lifetimes of the references that will be passed in, so we can’t look at the scopes as we did in Listings 10-17 and 10-18 to determine whether the reference we return will always be valid. The borrow checker can’t determine this either, because it doesn’t know how the lifetimes of <code>x</code> and <code>y</code> relate to the lifetime of the return value. To fix this error, we’ll add generic lifetime parameters that define the relationship between the references so that the borrow checker can perform its analysis.</p>
<h3 id="라이프타임-명시-문법"><a class="header" href="#라이프타임-명시-문법">라이프타임 명시 문법</a></h3>
<p>라이프타임 명시는 참조가 얼마나 오래 사는지에 영향을 주지 않습니다. 그보다는 여러 참조의 라이프타임 간의 관계를 라이프타임에 영향을 주지 않으면서 기술하는 것입니다. 시그니처에 제네릭 타입 매개변수를 지정했을 때 함수가 어떤 타입이든 받아들일 수 있는 것처럼, 제네릭 라이프타임 매개변수를 지정하면 함수가 어떤 라이프타임의 참조든 받아들일 수 있습니다.</p>
<p>Lifetime annotations have a slightly unusual syntax: The names of lifetime parameters must start with an apostrophe (<code>'</code>) and are usually all lowercase and very short, like generic types. Most people use the name <code>'a</code> for the first lifetime annotation. We place lifetime parameter annotations after the <code>&amp;</code> of a reference, using a space to separate the annotation from the reference’s type.</p>
<p>Here are some examples—a reference to an <code>i32</code> without a lifetime parameter, a reference to an <code>i32</code> that has a lifetime parameter named <code>'a</code>, and a mutable reference to an <code>i32</code> that also has the lifetime <code>'a</code>:</p>
<pre><code class="language-rust ignore">&amp;i32        // 참조
&amp;'a i32     // 명시적인 라이프타임이 있는 참조
&amp;'a mut i32 // 명시적인 라이프타임이 있는 가변 참조</code></pre>
<p>One lifetime annotation by itself doesn’t have much meaning, because the annotations are meant to tell Rust how generic lifetime parameters of multiple references relate to each other. Let’s examine how the lifetime annotations relate to each other in the context of the <code>longest</code> function.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="lifetime-annotations-in-function-signatures"></a></p>
<h3 id="in-function-signatures"><a class="header" href="#in-function-signatures">In Function Signatures</a></h3>
<p>To use lifetime annotations in function signatures, we need to declare the generic lifetime parameters inside angle brackets between the function name and the parameter list, just as we did with generic type parameters.</p>
<p>We want the signature to express the following constraint: The returned reference will be valid as long as both of the parameters are valid. This is the relationship between lifetimes of the parameters and the return value. We’ll name the lifetime <code>'a</code> and then add it to each reference, as shown in Listing 10-21.</p>
<Listing number="10-21" file-name="src/main.rs" caption="The `longest` function definition specifying that all the references in the signature must have the same lifetime `'a`">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() { x } else { y }
}</code></pre></pre>
</Listing>
<p>이 코드는 목록 10-19의 <code>main</code> 함수와 함께 사용했을 때 컴파일되고 우리가 원하는 결과를 생성할 것입니다.</p>
<p>이제 함수 시그니처는 어떤 라이프타임 <code>'a</code>에 대해, 이 함수는 두 개의 매개변수를 받으며 둘 다 적어도 라이프타임 <code>'a</code>만큼은 살아있는 문자열 슬라이스라는 것을 러스트에게 알려줍니다. 또한 이 시그니처는 함수로부터 반환된 문자열 슬라이스도 적어도 라이프타임 <code>'a</code>만큼은 살아있을 것임을 알려줍니다. 실제로 이는 <code>longest</code> 함수에 의해 반환된 참조의 라이프타임이 함수 인수가 참조하는 값들의 라이프타임 중 더 짧은 쪽과 동일하다는 것을 의미합니다. 이러한 관계가 우리가 러스트에게 이 코드를 분석할 때 사용하길 원하는 것입니다.</p>
<p>기억하세요, 이 함수 시그니처에서 라이프타임 매개변수를 지정한다고 해서 전달되거나 반환되는 값의 라이프타임이 변하는 것은 아닙니다. 그보다는 빌려주기 검사기가 이 제약 조건을 지키지 않는 값들을 거부해야 한다고 명시하는 것입니다. <code>longest</code> 함수는 <code>x</code>와 <code>y</code>가 얼마나 오래 살지 정확히 알 필요가 없으며, 단지 이 시그니처를 만족할 수 있는 어떤 스코프가 <code>'a</code>를 대체할 수 있다는 것만 알면 됩니다.</p>
<p>함수에서 라이프타임을 명시할 때, 그 명시는 함수 본문이 아닌 함수 시그니처에 위치합니다. 라이프타임 명시는 시그니처의 타입들과 마찬가지로 함수의 계약(contract) 중 일부가 됩니다. 함수 시그니처가 라이프타임 계약을 포함하게 되면 러스트 컴파일러가 수행하는 분석이 더 단순해질 수 있습니다. 함수가 명시된 방식이나 호출된 방식에 문제가 있다면, 컴파일러 에러는 우리 코드의 해당 부분과 제약 조건을 더 정확하게 가리킬 수 있습니다. 만약 대신 러스트 컴파일러가 우리가 의도한 라이프타임 관계에 대해 더 많은 추론을 한다면, 컴파일러는 문제의 원인으로부터 여러 단계 떨어진 코드 사용 지점만을 가리킬 수밖에 없을 것입니다.</p>
<p><code>longest</code>에 구체적인 참조를 전달할 때, <code>'a</code>를 대체하는 구체적인 라이프타임은 <code>x</code>의 스코프와 <code>y</code>의 스코프가 겹치는 부분입니다. 다시 말해, 제네릭 라이프타임 <code>'a</code>는 <code>x</code>와 <code>y</code>의 라이프타임 중 더 작은 쪽과 동일한 구체적인 라이프타임을 갖게 됩니다. 반환되는 참조를 동일한 라이프타임 매개변수 <code>'a</code>로 명시했으므로, 반환된 참조 또한 <code>x</code>와 <code>y</code>의 라이프타임 중 더 짧은 쪽의 길이 동안 유효할 것입니다.</p>
<p>서로 다른 구체적 라이프타임을 가진 참조를 전달함으로써 라이프타임 명시가 <code>longest</code> 함수를 어떻게 제한하는지 살펴보겠습니다. 목록 10-22는 간단한 예제입니다.</p>
<Listing number="10-22" file-name="src/main.rs" caption="Using the `longest` function with references to `String` values that have different concrete lifetimes">
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let string1 = String::from("long string is long");

    {
        let string2 = String::from("xyz");
        let result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {result}");
    }
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() { x } else { y }
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 예제에서 <code>string1</code>은 외부 스코프가 끝날 때까지 유효하고, <code>string2</code>는 내부 스코프가 끝날 때까지 유효하며, <code>result</code>는 내부 스코프가 끝날 때까지 유효한 무언가를 참조합니다. 이 코드를 실행하면 빌려주기 검사기가 승인함을 알 수 있습니다. 컴파일될 것이며 <code>The longest string is long string is long</code>을 출력할 것입니다.</p>
<p>Next, let’s try an example that shows that the lifetime of the reference in <code>result</code> must be the smaller lifetime of the two arguments. We’ll move the declaration of the <code>result</code> variable outside the inner scope but leave the assignment of the value to the <code>result</code> variable inside the scope with <code>string2</code>. Then, we’ll move the <code>println!</code> that uses <code>result</code> to outside the inner scope, after the inner scope has ended. The code in Listing 10-23 will not compile.</p>
<Listing number="10-23" file-name="src/main.rs" caption="Attempting to use `result` after `string2` has gone out of scope">
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {result}");
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() { x } else { y }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>이 코드를 컴파일하려고 시도하면, 다음과 같은 에러가 발생합니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `string2` does not live long enough
 --&gt; src/main.rs:6:44
  |
5 |         let string2 = String::from("xyz");
  |             ------- binding `string2` declared here
6 |         result = longest(string1.as_str(), string2.as_str());
  |                                            ^^^^^^^ borrowed value does not live long enough
7 |     }
  |     - `string2` dropped here while still borrowed
8 |     println!("The longest string is {result}");
  |                                      ------ borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>이 에러는 <code>result</code>가 <code>println!</code> 문에서 유효하기 위해서는 <code>string2</code>가 외부 스코프 끝까지 유효해야 함을 보여줍니다. 우리가 함수의 매개변수와 반환 값의 라이프타임을 동일한 라이프타임 매개변수 <code>'a</code>를 사용하여 명시했기 때문에 러스트는 이를 알 수 있습니다.</p>
<p>사람의 관점에서는 이 코드를 보고 <code>string1</code>이 <code>string2</code>보다 길기 때문에 <code>result</code>가 <code>string1</code>에 대한 참조를 갖게 될 것임을 알 수 있습니다. <code>string1</code>은 아직 스코프를 벗어나지 않았으므로, <code>string1</code>에 대한 참조는 <code>println!</code> 문에서 여전히 유효할 것입니다. 하지만 컴파일러는 이 경우에 참조가 유효하다는 것을 알지 못합니다. 우리는 러스트에게 <code>longest</code> 함수가 반환하는 참조의 라이프타임이 전달된 참조들의 라이프타임 중 더 짧은 쪽과 같다고 말했습니다. 따라서 빌려주기 검사기는 목록 10-23의 코드가 유효하지 않은 참조를 가질 가능성이 있다고 보고 허용하지 않습니다.</p>
<p>Try designing more experiments that vary the values and lifetimes of the references passed in to the <code>longest</code> function and how the returned reference is used. Make hypotheses about whether or not your experiments will pass the borrow checker before you compile; then, check to see if you’re right!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="thinking-in-terms-of-lifetimes"></a></p>
<h3 id="relationships"><a class="header" href="#relationships">Relationships</a></h3>
<p>라이프타임 매개변수를 지정해야 하는 방식은 함수가 하는 일에 따라 달라집니다. 예를 들어, <code>longest</code> 함수의 구현을 가장 긴 문자열 슬라이스 대신 항상 첫 번째 매개변수를 반환하도록 변경한다면, <code>y</code> 매개변수에는 라이프타임을 지정할 필요가 없습니다. 다음 코드는 컴파일됩니다:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "efghijklmnopqrstuvwxyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}</code></pre></pre>
</Listing>
<p>우리는 매개변수 <code>x</code>와 반환 타입에 대해서는 라이프타임 매개변수 <code>'a</code>를 지정했지만, 매개변수 <code>y</code>에 대해서는 지정하지 않았습니다. <code>y</code>의 라이프타임은 <code>x</code>나 반환 값의 라이프타임과 아무런 관련이 없기 때문입니다.</p>
<p>함수에서 참조를 반환할 때, 반환 타입의 라이프타임 매개변수는 매개변수 중 하나의 라이프타임 매개변수와 일치해야 합니다. 만약 반환된 참조가 매개변수 중 하나를 참조하지 <em>않는다면</em>, 그것은 반드시 함수 내부에서 생성된 값을 참조해야 합니다. 하지만 이는 함수가 끝날 때 값이 스코프를 벗어나게 되므로 댕글링 참조가 될 것입니다. 다음과 같이 <code>longest</code> 함수를 구현하려고 시도해 보았다고 가정해 봅시다.</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    let result = String::from("really long string");
    result.as_str()
}</code></pre>
</Listing>
<p>여기서 반환 타입에 라이프타임 매개변수 <code>'a</code>를 지정했음에도 불구하고, 반환 값의 라이프타임이 매개변수의 라이프타임과 전혀 관련이 없기 때문에 이 구현은 컴파일에 실패합니다. 우리가 받게 될 에러 메시지는 다음과 같습니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0515]: cannot return value referencing local variable `result`
  --&gt; src/main.rs:11:5
   |
11 |     result.as_str()
   |     ------^^^^^^^^^
   |     |
   |     returns a value referencing data owned by the current function
   |     `result` is borrowed here

For more information about this error, try `rustc --explain E0515`.
error: could not compile `chapter10` (bin "chapter10") due to 1 previous error
</code></pre>
<p>The problem is that <code>result</code> goes out of scope and gets cleaned up at the end of the <code>longest</code> function. We’re also trying to return a reference to <code>result</code> from the function. There is no way we can specify lifetime parameters that would change the dangling reference, and Rust won’t let us create a dangling reference. In this case, the best fix would be to return an owned data type rather than a reference so that the calling function is then responsible for cleaning up the value.</p>
<p>결국 라이프타임 문법은 함수의 다양한 매개변수와 반환 값의 라이프타임을 서로 연결하는 것에 관한 것입니다. 이들이 연결되면, 러스트는 메모리 안전한 연산을 허용하고 댕글링 포인터를 생성하거나 메모리 안전성을 위반하는 연산을 막기에 충분한 정보를 갖게 됩니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="lifetime-annotations-in-struct-definitions"></a></p>
<h3 id="구조체-정의에서"><a class="header" href="#구조체-정의에서">구조체 정의에서</a></h3>
<p>So far, the structs we’ve defined all hold owned types. We can define structs to hold references, but in that case, we would need to add a lifetime annotation on every reference in the struct’s definition. Listing 10-24 has a struct named <code>ImportantExcerpt</code> that holds a string slice.</p>
<Listing number="10-24" file-name="src/main.rs" caption="A struct that holds a reference, requiring a lifetime annotation">
<pre><pre class="playground"><code class="language-rust edition2024">struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().unwrap();
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}</code></pre></pre>
</Listing>
<p>This struct has the single field <code>part</code> that holds a string slice, which is a reference. As with generic data types, we declare the name of the generic lifetime parameter inside angle brackets after the name of the struct so that we can use the lifetime parameter in the body of the struct definition. This annotation means an instance of <code>ImportantExcerpt</code> can’t outlive the reference it holds in its <code>part</code> field.</p>
<p>여기서 <code>main</code> 함수는 <code>novel</code> 변수가 소유한 <code>String</code>의 첫 번째 문장에 대한 참조를 담는 <code>ImportantExcerpt</code> 구조체의 인스턴스를 생성합니다. <code>novel</code>에 담긴 데이터는 <code>ImportantExcerpt</code> 인스턴스가 생성되기 전부터 존재합니다. 또한, <code>novel</code>은 <code>ImportantExcerpt</code>가 스코프를 벗어날 때까지 스코프를 벗어나지 않으므로, <code>ImportantExcerpt</code> 인스턴스 안의 참조는 유효합니다.</p>
<h3 id="라이프타임-생략lifetime-elision"><a class="header" href="#라이프타임-생략lifetime-elision">라이프타임 생략(Lifetime Elision)</a></h3>
<p>여러분은 모든 참조에는 라이프타임이 있으며, 참조를 사용하는 함수나 구조체에는 라이프타임 매개변수를 지정해야 한다는 것을 배웠습니다. 하지만 목록 4-9에서 보았고 목록 10-25에서 다시 보여주는 이 함수는 라이프타임 명시 없이도 컴파일됩니다.</p>
<Listing number="10-25" file-name="src/lib.rs" caption="A function we defined in Listing 4-9 that compiled without lifetime annotations, even though the parameter and return type are references">
<pre><pre class="playground"><code class="language-rust edition2024">fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from("hello world");
</span><span class="boring">
</span><span class="boring">    // first_word는 `String`의 슬라이스에 작동합니다
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = "hello world";
</span><span class="boring">
</span><span class="boring">    // first_word는 문자열 리터럴의 슬라이스에 작동합니다
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // 문자열 리터럴은 이미 문자열 슬라이스이기 때문에,
</span><span class="boring">    // 슬라이스 구문 없이도 잘 작동합니다!
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>The reason this function compiles without lifetime annotations is historical: In early versions (pre-1.0) of Rust, this code wouldn’t have compiled, because every reference needed an explicit lifetime. At that time, the function signature would have been written like this:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {</code></pre>
<p>After writing a lot of Rust code, the Rust team found that Rust programmers were entering the same lifetime annotations over and over in particular situations. These situations were predictable and followed a few deterministic patterns. The developers programmed these patterns into the compiler’s code so that the borrow checker could infer the lifetimes in these situations and wouldn’t need explicit annotations.</p>
<p>러스트의 이러한 역사가 중요한 이유는 앞으로 더 많은 결정론적인 패턴들이 발견되어 컴파일러에 추가될 수 있기 때문입니다. 미래에는 훨씬 더 적은 라이프타임 명시만 필요하게 될지도 모릅니다.</p>
<p>참조 분석을 위해 러스트에 프로그래밍된 패턴들을 _라이프타임 생략 규칙(lifetime elision rules)_이라고 부릅니다. 이는 프로그래머가 지켜야 할 규칙이 아닙니다. 컴파일러가 고려하는 몇 가지 특정한 경우의 모음이며, 여러분의 코드가 이 경우에 해당한다면 라이프타임을 명시적으로 작성할 필요가 없습니다.</p>
<p>The elision rules don’t provide full inference. If there is still ambiguity about what lifetimes the references have after Rust applies the rules, the compiler won’t guess what the lifetime of the remaining references should be. Instead of guessing, the compiler will give you an error that you can resolve by adding the lifetime annotations.</p>
<p>함수나 메서드의 매개변수에 대한 라이프타임을 _입력 라이프타임(input lifetimes)_이라고 하며, 반환 값에 대한 라이프타임을 _출력 라이프타임(output lifetimes)_이라고 합니다.</p>
<p>명시적인 라이프타임 명시가 없을 때, 컴파일러는 세 가지 규칙을 사용하여 참조의 라이프타임을 파악합니다. 첫 번째 규칙은 입력 라이프타임에 적용되고, 두 번째와 세 번째 규칙은 출력 라이프타임에 적용됩니다. 만약 컴파일러가 세 가지 규칙을 모두 적용한 뒤에도 라이프타임을 파악할 수 없는 참조가 남아있다면, 컴파일러는 에러와 함께 멈춥니다. 이 규칙들은 <code>fn</code> 정의뿐만 아니라 <code>impl</code> 블록에도 적용됩니다.</p>
<p>첫 번째 규칙은 참조인 각 매개변수에 대해 컴파일러가 라이프타임 매개변수를 할당한다는 것입니다. 즉, 매개변수가 하나인 함수는 하나의 라이프타임 매개변수를 갖습니다: <code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>. 매개변수가 두 개인 함수는 두 개의 개별 라이프타임 매개변수를 갖습니다: <code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>. 이런 식입니다.</p>
<p>두 번째 규칙은 입력 라이프타임 매개변수가 딱 하나라면, 그 라이프타임이 모든 출력 라이프타임 매개변수에 할당된다는 것입니다: <code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>.</p>
<p>세 번째 규칙은 매개변수가 여러 개인 경우, 그것이 메서드라서 그중 하나가 <code>&amp;self</code> 혹은 <code>&amp;mut self</code>라면 <code>self</code>의 라이프타임이 모든 출력 라이프타임 매개변수에 할당된다는 것입니다. 이 세 번째 규칙 덕분에 메서드를 읽고 쓰기가 훨씬 수월해지는데, 필요한 기호들이 적어지기 때문입니다.</p>
<p>우리가 컴파일러라고 가정해 봅시다. 목록 10-25에 있는 <code>first_word</code> 함수 시그니처에서 참조의 라이프타임을 파악하기 위해 이 규칙들을 적용해 보겠습니다. 시그니처는 참조와 관련된 어떤 라이프타임도 없이 시작합니다:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {</code></pre>
<p>Then, the compiler applies the first rule, which specifies that each parameter gets its own lifetime. We’ll call it <code>'a</code> as usual, so now the signature is this:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {</code></pre>
<p>입력 라이프타임이 정확히 하나뿐이므로 두 번째 규칙이 적용됩니다. 두 번째 규칙은 하나의 입력 매개변수의 라이프타임이 출력 라이프타임에 할당되도록 명시합니다. 이제 시그니처는 다음과 같습니다:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {</code></pre>
<p>이제 이 함수 시그니처의 모든 참조가 라이프타임을 갖게 되었으며, 컴파일러는 프로그래머가 이 함수 시그니처에 라이프타임을 명시할 필요 없이 분석을 계속할 수 있습니다.</p>
<p>이번에는 목록 10-20에서 작업하기 시작했을 때 라이프타임 매개변수가 없었던 <code>longest</code> 함수를 사용하여 다른 예제를 살펴보겠습니다:</p>
<pre><code class="language-rust ignore">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {</code></pre>
<p>Let’s apply the first rule: Each parameter gets its own lifetime. This time we have two parameters instead of one, so we have two lifetimes:</p>
<pre><code class="language-rust ignore">fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {</code></pre>
<p>You can see that the second rule doesn’t apply, because there is more than one input lifetime. The third rule doesn’t apply either, because <code>longest</code> is a function rather than a method, so none of the parameters are <code>self</code>. After working through all three rules, we still haven’t figured out what the return type’s lifetime is. This is why we got an error trying to compile the code in Listing 10-20: The compiler worked through the lifetime elision rules but still couldn’t figure out all the lifetimes of the references in the signature.</p>
<p>세 번째 규칙은 실제로 메서드 시그니처에만 적용되므로, 다음으로 해당 컨텍스트에서 라이프타임을 살펴보고 세 번째 규칙 때문에 메서드 시그니처에 라이프타임을 자주 명시할 필요가 없는 이유를 알아보겠습니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="lifetime-annotations-in-method-definitions"></a></p>
<h3 id="메서드-정의에서"><a class="header" href="#메서드-정의에서">메서드 정의에서</a></h3>
<p>라이프타임을 가진 구조체에 메서드를 구현할 때, 목록 10-11에 표시된 것처럼 제네릭 타입 매개변수와 동일한 문법을 사용합니다. 라이프타임 매개변수를 선언하고 사용하는 위치는 구조체 필드와 관련이 있는지, 아니면 메서드 매개변수 및 반환 값과 관련이 있는지에 따라 달라집니다.</p>
<p>구조체 필드의 라이프타임 이름은 항상 <code>impl</code> 키워드 뒤에 선언되어야 하며, 그런 다음 구조체 이름 뒤에 사용되어야 합니다. 왜냐하면 해당 라이프타임은 구조체 타입의 일부이기 때문입니다.</p>
<p><code>impl</code> 블록 내부의 메서드 시그니처에서 참조는 구조체 필드의 참조 라이프타임에 묶여 있을 수도 있고, 독립적일 수도 있습니다. 또한 라이프타임 생략 규칙으로 인해 메서드 시그니처에 라이프타임 명시가 필요 없는 경우가 많습니다. 목록 10-24에서 정의한 <code>ImportantExcerpt</code>라는 구조체를 사용하여 몇 가지 예제를 살펴보겠습니다.</p>
<p>First, we’ll use a method named <code>level</code> whose only parameter is a reference to <code>self</code> and whose return value is an <code>i32</code>, which is not a reference to anything:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}
<span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
</span><span class="boring">        println!("Attention please: {announcement}");
</span><span class="boring">        self.part
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from("Call me Ishmael. Some years ago...");
</span><span class="boring">    let first_sentence = novel.split('.').next().unwrap();
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}</span></code></pre></pre>
<p>The lifetime parameter declaration after <code>impl</code> and its use after the type name are required, but because of the first elision rule, we’re not required to annotate the lifetime of the reference to <code>self</code>.</p>
<p>다음은 세 번째 라이프타임 생략 규칙이 적용되는 예제입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn level(&amp;self) -&gt; i32 {
</span><span class="boring">        3
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        println!("Attention please: {announcement}");
        self.part
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from("Call me Ishmael. Some years ago...");
</span><span class="boring">    let first_sentence = novel.split('.').next().unwrap();
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}</span></code></pre></pre>
<p>두 개의 입력 라이프타임이 있으므로, 러스트는 첫 번째 라이프타임 생략 규칙을 적용하여 <code>&amp;self</code>와 <code>announcement</code> 모두에게 자체 라이프타임을 부여합니다. 그런 다음 매개변수 중 하나가 <code>&amp;self</code>이므로 반환 타입은 <code>&amp;self</code>의 라이프타임을 얻게 되며, 모든 라이프타임이 고려됩니다.</p>
<h3 id="정적-라이프타임"><a class="header" href="#정적-라이프타임">정적 라이프타임</a></h3>
<p>논의해야 할 한 가지 특별한 라이프타임은 <code>'static</code>입니다. 이는 영향을 받는 참조가 프로그램의 전체 기간 동안 _살아있을 수 있음_을 나타냅니다. 모든 문자열 리터럴은 <code>'static</code> 라이프타임을 가지며, 다음과 같이 명시할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;'static str = "나는 정적 라이프타임을 가지고 있습니다.";
<span class="boring">}</span></code></pre></pre>
<p>이 문자열의 텍스트는 프로그램의 바이너리에 직접 저장되며, 이는 항상 사용 가능합니다. 따라서 모든 문자열 리터럴의 라이프타임은 <code>'static</code>입니다.</p>
<p>You might see suggestions in error messages to use the <code>'static</code> lifetime. But before specifying <code>'static</code> as the lifetime for a reference, think about whether or not the reference you have actually lives the entire lifetime of your program, and whether you want it to. Most of the time, an error message suggesting the <code>'static</code> lifetime results from attempting to create a dangling reference or a mismatch of the available lifetimes. In such cases, the solution is to fix those problems, not to specify the <code>'static</code> lifetime.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="generic-type-parameters-trait-bounds-and-lifetimes-together"></a></p>
<h2 id="generic-type-parameters-trait-bounds-and-lifetimes"><a class="header" href="#generic-type-parameters-trait-bounds-and-lifetimes">Generic Type Parameters, Trait Bounds, and Lifetimes</a></h2>
<p>제네릭 타입 매개변수, 트레이트 바운드, 라이프타임을 모두 하나의 함수에서 지정하는 문법을 간략하게 살펴보겠습니다!</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from("abcd");
</span><span class="boring">    let string2 = "xyz";
</span><span class="boring">
</span><span class="boring">    let result = longest_with_an_announcement(
</span><span class="boring">        string1.as_str(),
</span><span class="boring">        string2,
</span><span class="boring">        "오늘은 누군가의 생일입니다!",
</span><span class="boring">    );
</span><span class="boring">    println!("The longest string is {result}");
</span><span class="boring">}
</span><span class="boring">
</span>use std::fmt::Display;

fn longest_with_an_announcement&lt;'a, T&gt;(
    x: &amp;'a str,
    y: &amp;'a str,
    ann: T,
) -&gt; &amp;'a str
where
    T: Display,
{
    println!("Announcement! {ann}");
    if x.len() &gt; y.len() { x } else { y }
}</code></pre></pre>
<p>이것은 목록 10-21의 <code>longest</code> 함수로, 두 문자열 슬라이스 중 더 긴 것을 반환합니다. 하지만 이제 <code>where</code> 절에 지정된 대로 <code>Display</code> 트레이트를 구현하는 모든 타입으로 채워질 수 있는 제네릭 타입 <code>T</code>의 <code>ann</code>이라는 추가 매개변수를 가집니다. 이 추가 매개변수는 <code>{}</code>를 사용하여 출력될 것이며, 이것이 <code>Display</code> 트레이트 바운드가 필요한 이유입니다. 라이프타임은 제네릭의 한 종류이므로, 라이프타임 매개변수 <code>'a</code>와 제네릭 타입 매개변수 <code>T</code>의 선언은 함수 이름 뒤의 꺾쇠 괄호 안의 동일한 목록에 들어갑니다.</p>
<h2 id="요약"><a class="header" href="#요약">요약</a></h2>
<p>이 장에서 많은 내용을 다루었습니다! 이제 제네릭 타입 매개변수, 트레이트 및 트레이트 바운드, 제네릭 라이프타임 매개변수에 대해 알게 되었으므로, 다양한 상황에서 작동하는 반복 없는 코드를 작성할 준비가 되었습니다. 제네릭 타입 매개변수를 사용하면 코드를 다른 타입에 적용할 수 있습니다. 트레이트 및 트레이트 바운드는 타입이 제네릭이더라도 코드가 필요로 하는 동작을 가질 수 있도록 보장합니다. 라이프타임 명시를 사용하여 이 유연한 코드가 매달린 참조를 가지지 않도록 보장하는 방법을 배웠습니다. 그리고 이 모든 분석은 컴파일 타임에 이루어지므로 런타임 성능에 영향을 미치지 않습니다!</p>
<p>Believe it or not, there is much more to learn on the topics we discussed in this chapter: Chapter 18 discusses trait objects, which are another way to use traits. There are also more complex scenarios involving lifetime annotations that you will only need in very advanced scenarios; for those, you should read the <a href="../reference/trait-bounds.html">Rust Reference</a>. But next, you’ll learn how to write tests in Rust so that you can make sure your code is working the way it should.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch10-02-traits.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch11-00-testing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch10-02-traits.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch11-00-testing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
