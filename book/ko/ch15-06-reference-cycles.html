<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>참조 순환은 메모리 누수를 일으킬 수 있다 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch15-06-reference-cycles.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch15-06-reference-cycles.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="참조-순환은-메모리-누수를-일으킬-수-있다"><a class="header" href="#참조-순환은-메모리-누수를-일으킬-수-있다">참조 순환은 메모리 누수를 일으킬 수 있다</a></h2>
<p>Rust’s memory safety guarantees make it difficult, but not impossible, to accidentally create memory that is never cleaned up (known as a <em>memory leak</em>). Preventing memory leaks entirely is not one of Rust’s guarantees, meaning memory leaks are memory safe in Rust. We can see that Rust allows memory leaks by using <code>Rc&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code>: It’s possible to create references where items refer to each other in a cycle. This creates memory leaks because the reference count of each item in the cycle will never reach 0, and the values will never be dropped.</p>
<h3 id="순환-참조-생성하기"><a class="header" href="#순환-참조-생성하기">순환 참조 생성하기</a></h3>
<p>Let’s look at how a reference cycle might happen and how to prevent it, starting with the definition of the <code>List</code> enum and a <code>tail</code> method in Listing 15-25.</p>
<Listing number="15-25" file-name="src/main.rs" caption="A cons list definition that holds a `RefCell<T>` so that we can modify what a `Cons` variant is referring to">
<pre><pre class="playground"><code class="language-rust edition2024">use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match self {
            Cons(_, item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p>목록 15-5의 List 정의의 또 다른 변형을 사용하고 있습니다. Cons 변형의 두 번째 요소는 이제 RefCell&lt;Rc<List>&gt;이며, 이는 목록 15-24에서 했던 것처럼 i32 값을 수정하는 기능 대신 Cons 변형이 가리키는 List 값을 수정하고자 함을 의미합니다. 또한 Cons 변형이 있는 경우 두 번째 항목에 편리하게 접근할 수 있도록 tail 메서드를 추가하고 있습니다.</p>
<p>In Listing 15-26, we’re adding a <code>main</code> function that uses the definitions in Listing 15-25. This code creates a list in <code>a</code> and a list in <code>b</code> that points to the list in <code>a</code>. Then, it modifies the list in <code>a</code> to point to <code>b</code>, creating a reference cycle. There are <code>println!</code> statements along the way to show what the reference counts are at various points in this process.</p>
<Listing number="15-26" file-name="src/main.rs" caption="Creating a reference cycle of two `List` values pointing to each other">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum List {
</span><span class="boring">    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
</span><span class="boring">        match self {
</span><span class="boring">            Cons(_, item) =&gt; Some(item),
</span><span class="boring">            Nil =&gt; None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!("a의 초기 rc 카운트 = {}", Rc::strong_count(&amp;a));
    println!("a의 다음 항목 = {:?}", a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));

    println!("b 생성 후 a의 rc 카운트 = {}", Rc::strong_count(&amp;a));
    println!("b의 초기 rc 카운트 = {}", Rc::strong_count(&amp;b));
    println!("b의 다음 항목 = {:?}", b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&amp;b);
    }

    println!("a 변경 후 b의 rc 카운트 = {}", Rc::strong_count(&amp;b));
    println!("a 변경 후 a의 rc 카운트 = {}", Rc::strong_count(&amp;a));

    // 다음 줄의 주석을 해제하면 순환이 있음을 볼 수 있습니다;
    // 스택 오버플로가 발생할 것입니다.
    // println!("a의 다음 항목 = {:?}", a.tail());
}</code></pre></pre>
</Listing>
<p>We create an <code>Rc&lt;List&gt;</code> instance holding a <code>List</code> value in the variable <code>a</code> with an initial list of <code>5, Nil</code>. We then create an <code>Rc&lt;List&gt;</code> instance holding another <code>List</code> value in the variable <code>b</code> that contains the value <code>10</code> and points to the list in <code>a</code>.</p>
<p>We modify <code>a</code> so that it points to <code>b</code> instead of <code>Nil</code>, creating a cycle. We do that by using the <code>tail</code> method to get a reference to the <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> in <code>a</code>, which we put in the variable <code>link</code>. Then, we use the <code>borrow_mut</code> method on the <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> to change the value inside from an <code>Rc&lt;List&gt;</code> that holds a <code>Nil</code> value to the <code>Rc&lt;List&gt;</code> in <code>b</code>.</p>
<p>이 코드를 실행할 때, 마지막 println!을 주석 처리한 상태로 두면 다음과 같은 출력을 얻을 것입니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.53s
     Running `target/debug/cons-list`
a의 초기 rc 카운트 = 1
a의 다음 항목 = Some(RefCell { value: Nil })
b 생성 후 a의 rc 카운트 = 2
b의 초기 rc 카운트 = 1
b의 다음 항목 = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
a 변경 후 b의 rc 카운트 = 2
a 변경 후 a의 rc 카운트 = 2
</code></pre>
<p>The reference count of the <code>Rc&lt;List&gt;</code> instances in both <code>a</code> and <code>b</code> is 2 after we change the list in <code>a</code> to point to <code>b</code>. At the end of <code>main</code>, Rust drops the variable <code>b</code>, which decreases the reference count of the <code>b</code> <code>Rc&lt;List&gt;</code> instance from 2 to 1. The memory that <code>Rc&lt;List&gt;</code> has on the heap won’t be dropped at this point because its reference count is 1, not 0. Then, Rust drops <code>a</code>, which decreases the reference count of the <code>a</code> <code>Rc&lt;List&gt;</code> instance from 2 to 1 as well. This instance’s memory can’t be dropped either, because the other <code>Rc&lt;List&gt;</code> instance still refers to it. The memory allocated to the list will remain uncollected forever. To visualize this reference cycle, we’ve created the diagram in Figure 15-4.</p>
<img alt="A rectangle labeled 'a' that points to a rectangle containing the integer 5. A rectangle labeled 'b' that points to a rectangle containing the integer 10. The rectangle containing 5 points to the rectangle containing 10, and the rectangle containing 10 points back to the rectangle containing 5, creating a cycle." src="img/trpl15-04.svg" class="center" />
<p><span class="caption">그림 15-4: 서로를 가리키는 리스트 a와 b의 순환 참조</span></p>
<p>If you uncomment the last <code>println!</code> and run the program, Rust will try to print this cycle with <code>a</code> pointing to <code>b</code> pointing to <code>a</code> and so forth until it overflows the stack.</p>
<p>Compared to a real-world program, the consequences of creating a reference cycle in this example aren’t very dire: Right after we create the reference cycle, the program ends. However, if a more complex program allocated lots of memory in a cycle and held onto it for a long time, the program would use more memory than it needed and might overwhelm the system, causing it to run out of available memory.</p>
<p>순환 참조를 생성하는 것은 쉽지 않지만, 불가능하지도 않습니다. Rc<T> 값을 포함하는 RefCell<T> 값이나 내부 가변성과 참조 카운팅이 있는 타입의 유사한 중첩 조합이 있는 경우, 순환을 생성하지 않도록 보장해야 합니다. 러스트가 그것들을 잡아낼 것이라고 의존할 수 없습니다. 순환 참조를 생성하는 것은 프로그램의 논리 버그일 것이며, 자동화된 테스트, 코드 리뷰 및 기타 소프트웨어 개발 관행을 사용하여 최소화해야 합니다.</p>
<p>순환 참조를 피하는 또 다른 해결책은 일부 참조는 소유권을 표현하고 일부 참조는 그렇지 않도록 데이터 구조를 재구성하는 것입니다. 결과적으로 일부 소유권 관계와 일부 비소유권 관계로 구성된 순환을 가질 수 있으며, 소유권 관계만이 값이 드롭될 수 있는지 여부에 영향을 미칩니다. 목록 15-25에서는 Cons 변형이 항상 리스트를 소유하기를 원하므로 데이터 구조를 재구성하는 것이 불가능합니다. 비소유권 관계가 순환 참조를 방지하는 적절한 방법이 되는 경우를 보기 위해 부모 노드와 자식 노드로 구성된 그래프를 사용하는 예제를 살펴봅시다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="preventing-reference-cycles-turning-an-rct-into-a-weakt"></a></p>
<h3 id="preventing-reference-cycles-using-weakt"><a class="header" href="#preventing-reference-cycles-using-weakt">Preventing Reference Cycles Using <code>Weak&lt;T&gt;</code></a></h3>
<p>So far, we’ve demonstrated that calling <code>Rc::clone</code> increases the <code>strong_count</code> of an <code>Rc&lt;T&gt;</code> instance, and an <code>Rc&lt;T&gt;</code> instance is only cleaned up if its <code>strong_count</code> is 0. You can also create a weak reference to the value within an <code>Rc&lt;T&gt;</code> instance by calling <code>Rc::downgrade</code> and passing a reference to the <code>Rc&lt;T&gt;</code>. <em>Strong references</em> are how you can share ownership of an <code>Rc&lt;T&gt;</code> instance. <em>Weak references</em> don’t express an ownership relationship, and their count doesn’t affect when an <code>Rc&lt;T&gt;</code> instance is cleaned up. They won’t cause a reference cycle, because any cycle involving some weak references will be broken once the strong reference count of values involved is 0.</p>
<p>Rc::downgrade를 호출하면 Weak<T> 타입의 스마트 포인터를 얻습니다. Rc<T> 인스턴스의 strong_count를 1 증가시키는 대신, Rc::downgrade를 호출하면 weak_count가 1 증가합니다. Rc<T> 타입은 strong_count와 유사하게 존재하는 Weak<T> 참조의 수를 추적하기 위해 weak_count를 사용합니다. 차이점은 Rc<T> 인스턴스가 정리되기 위해 weak_count가 0일 필요는 없다는 것입니다.</p>
<p>Because the value that <code>Weak&lt;T&gt;</code> references might have been dropped, to do anything with the value that a <code>Weak&lt;T&gt;</code> is pointing to you must make sure the value still exists. Do this by calling the <code>upgrade</code> method on a <code>Weak&lt;T&gt;</code> instance, which will return an <code>Option&lt;Rc&lt;T&gt;&gt;</code>. You’ll get a result of <code>Some</code> if the <code>Rc&lt;T&gt;</code> value has not been dropped yet and a result of <code>None</code> if the <code>Rc&lt;T&gt;</code> value has been dropped. Because <code>upgrade</code> returns an <code>Option&lt;Rc&lt;T&gt;&gt;</code>, Rust will ensure that the <code>Some</code> case and the <code>None</code> case are handled, and there won’t be an invalid pointer.</p>
<p>As an example, rather than using a list whose items know only about the next item, we’ll create a tree whose items know about their child items <em>and</em> their parent items.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="creating-a-tree-data-structure-a-node-with-child-nodes"></a></p>
<h4 id="creating-a-tree-data-structure"><a class="header" href="#creating-a-tree-data-structure">Creating a Tree Data Structure</a></h4>
<p>To start, we’ll build a tree with nodes that know about their child nodes. We’ll create a struct named <code>Node</code> that holds its own <code>i32</code> value as well as references to its child <code>Node</code> values:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<p>We want a <code>Node</code> to own its children, and we want to share that ownership with variables so that we can access each <code>Node</code> in the tree directly. To do this, we define the <code>Vec&lt;T&gt;</code> items to be values of type <code>Rc&lt;Node&gt;</code>. We also want to modify which nodes are children of another node, so we have a <code>RefCell&lt;T&gt;</code> in <code>children</code> around the <code>Vec&lt;Rc&lt;Node&gt;&gt;</code>.</p>
<p>Next, we’ll use our struct definition and create one <code>Node</code> instance named <code>leaf</code> with the value <code>3</code> and no children, and another instance named <code>branch</code> with the value <code>5</code> and <code>leaf</code> as one of its children, as shown in Listing 15-27.</p>
<Listing number="15-27" file-name="src/main.rs" caption="Creating a `leaf` node with no children and a `branch` node with `leaf` as one of its children">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });
}</code></pre></pre>
</Listing>
<p>leaf의 Rc<Node>를 클론하여 branch에 저장합니다. 이는 leaf의 Node가 이제 leaf와 branch라는 두 소유자를 가짐을 의미합니다. branch.children을 통해 branch에서 leaf로 이동할 수 있지만, leaf에서 branch로 이동할 방법은 없습니다. 이유는 leaf가 branch에 대한 참조를 가지고 있지 않고 서로 관련되어 있다는 것을 모르기 때문입니다. leaf가 branch가 자신의 부모라는 것을 알기를 원합니다. 다음으로 그 작업을 할 것입니다.</p>
<h4 id="자식에서-부모로의-참조-추가하기"><a class="header" href="#자식에서-부모로의-참조-추가하기">자식에서 부모로의 참조 추가하기</a></h4>
<p>자식 노드가 부모를 인식하도록 하려면 Node 구조체 정의에 parent 필드를 추가해야 합니다. 문제는 parent의 타입을 무엇으로 할지 결정하는 것입니다. Rc<T>를 포함할 수 없다는 것을 알고 있습니다. 왜냐하면 leaf.parent가 branch를 가리키고 branch.children이 leaf를 가리키는 순환 참조를 생성하여 strong_count 값이 결코 0이 되지 않게 만들기 때문입니다.</p>
<p>Thinking about the relationships another way, a parent node should own its children: If a parent node is dropped, its child nodes should be dropped as well. However, a child should not own its parent: If we drop a child node, the parent should still exist. This is a case for weak references!</p>
<p>So, instead of <code>Rc&lt;T&gt;</code>, we’ll make the type of <code>parent</code> use <code>Weak&lt;T&gt;</code>, specifically a <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code>. Now our <code>Node</code> struct definition looks like this:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("leaf의 부모 = {:?}", leaf.parent.borrow().upgrade());
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);
</span><span class="boring">
</span><span class="boring">    println!("leaf의 부모 = {:?}", leaf.parent.borrow().upgrade());
</span><span class="boring">}</span></code></pre></pre>
<p>A node will be able to refer to its parent node but doesn’t own its parent. In Listing 15-28, we update <code>main</code> to use this new definition so that the <code>leaf</code> node will have a way to refer to its parent, <code>branch</code>.</p>
<Listing number="15-28" file-name="src/main.rs" caption="A `leaf` node with a weak reference to its parent node, `branch`">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!("leaf의 부모 = {:?}", leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

    println!("leaf의 부모 = {:?}", leaf.parent.borrow().upgrade());
}</code></pre></pre>
</Listing>
<p>leaf 노드를 생성하는 것은 parent 필드를 제외하고는 목록 15-27과 유사해 보입니다. leaf는 부모 없이 시작하므로, 새롭고 빈 Weak<Node> 참조 인스턴스를 생성합니다.</p>
<p>이 시점에서, upgrade 메서드를 사용하여 leaf의 부모에 대한 참조를 얻으려고 시도하면 None 값을 얻습니다. 첫 번째 println! 문의 출력에서 이를 확인할 수 있습니다:</p>
<pre><code class="language-text">leaf parent = None
</code></pre>
<p>When we create the <code>branch</code> node, it will also have a new <code>Weak&lt;Node&gt;</code> reference in the <code>parent</code> field because <code>branch</code> doesn’t have a parent node. We still have <code>leaf</code> as one of the children of <code>branch</code>. Once we have the <code>Node</code> instance in <code>branch</code>, we can modify <code>leaf</code> to give it a <code>Weak&lt;Node&gt;</code> reference to its parent. We use the <code>borrow_mut</code> method on the <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code> in the <code>parent</code> field of <code>leaf</code>, and then we use the <code>Rc::downgrade</code> function to create a <code>Weak&lt;Node&gt;</code> reference to <code>branch</code> from the <code>Rc&lt;Node&gt;</code> in <code>branch</code>.</p>
<p>When we print the parent of <code>leaf</code> again, this time we’ll get a <code>Some</code> variant holding <code>branch</code>: Now <code>leaf</code> can access its parent! When we print <code>leaf</code>, we also avoid the cycle that eventually ended in a stack overflow like we had in Listing 15-26; the <code>Weak&lt;Node&gt;</code> references are printed as <code>(Weak)</code>:</p>
<pre><code class="language-text">leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
</code></pre>
<p>무한 출력이 없다는 것은 이 코드가 순환 참조를 생성하지 않았음을 나타냅니다. Rc::strong_count와 Rc::weak_count를 호출하여 얻은 값을 보고도 이를 알 수 있습니다.</p>
<h4 id="strong_count와-weak_count의-변화-시각화하기"><a class="header" href="#strong_count와-weak_count의-변화-시각화하기">strong_count와 weak_count의 변화 시각화하기</a></h4>
<p>Let’s look at how the <code>strong_count</code> and <code>weak_count</code> values of the <code>Rc&lt;Node&gt;</code> instances change by creating a new inner scope and moving the creation of <code>branch</code> into that scope. By doing so, we can see what happens when <code>branch</code> is created and then dropped when it goes out of scope. The modifications are shown in Listing 15-29.</p>
<Listing number="15-29" file-name="src/main.rs" caption="Creating `branch` in an inner scope and examining strong and weak reference counts">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

        println!(
            "branch strong = {}, weak = {}",
            Rc::strong_count(&amp;branch),
            Rc::weak_count(&amp;branch),
        );

        println!(
            "leaf strong = {}, weak = {}",
            Rc::strong_count(&amp;leaf),
            Rc::weak_count(&amp;leaf),
        );
    }

    println!("leaf의 부모 = {:?}", leaf.parent.borrow().upgrade());
    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );
}</code></pre></pre>
</Listing>
<p>After <code>leaf</code> is created, its <code>Rc&lt;Node&gt;</code> has a strong count of 1 and a weak count of 0. In the inner scope, we create <code>branch</code> and associate it with <code>leaf</code>, at which point when we print the counts, the <code>Rc&lt;Node&gt;</code> in <code>branch</code> will have a strong count of 1 and a weak count of 1 (for <code>leaf.parent</code> pointing to <code>branch</code> with a <code>Weak&lt;Node&gt;</code>). When we print the counts in <code>leaf</code>, we’ll see it will have a strong count of 2 because <code>branch</code> now has a clone of the <code>Rc&lt;Node&gt;</code> of <code>leaf</code> stored in <code>branch.children</code> but will still have a weak count of 0.</p>
<p>내부 스코프가 끝나면 branch는 스코프를 벗어나고 Rc<Node>의 강한 카운트가 0으로 감소하므로 Node가 드롭됩니다. leaf.parent의 약한 카운트 1은 Node의 드롭 여부에 아무런 영향을 미치지 않으므로 메모리 누수가 발생하지 않습니다!</p>
<p>If we try to access the parent of <code>leaf</code> after the end of the scope, we’ll get <code>None</code> again. At the end of the program, the <code>Rc&lt;Node&gt;</code> in <code>leaf</code> has a strong count of 1 and a weak count of 0 because the variable <code>leaf</code> is now the only reference to the <code>Rc&lt;Node&gt;</code> again.</p>
<p>카운트와 값 드롭을 관리하는 모든 로직은 Rc<T>와 Weak<T> 그리고 그들의 Drop 트레이트 구현에 내장되어 있습니다. Node 정의에서 자식에서 부모로의 관계가 Weak<T> 참조여야 한다고 지정함으로써, 순환 참조와 메모리 누수를 생성하지 않고 부모 노드가 자식 노드를 가리키고 그 반대도 가능하게 할 수 있습니다.</p>
<h2 id="요약"><a class="header" href="#요약">요약</a></h2>
<p>This chapter covered how to use smart pointers to make different guarantees and trade-offs from those Rust makes by default with regular references. The <code>Box&lt;T&gt;</code> type has a known size and points to data allocated on the heap. The <code>Rc&lt;T&gt;</code> type keeps track of the number of references to data on the heap so that the data can have multiple owners. The <code>RefCell&lt;T&gt;</code> type with its interior mutability gives us a type that we can use when we need an immutable type but need to change an inner value of that type; it also enforces the borrowing rules at runtime instead of at compile time.</p>
<p>또한 스마트 포인터의 많은 기능을 가능하게 하는 Deref와 Drop 트레이트에 대해서도 논의했습니다. 메모리 누수를 일으킬 수 있는 순환 참조와 Weak<T>를 사용하여 이를 방지하는 방법을 살펴보았습니다.</p>
<p>이 장이 흥미로웠고 자신만의 스마트 포인터를 구현하고 싶다면, 더 유용한 정보를 위해 <a href="../nomicon/index.html">“The Rustonomicon”</a>을 확인하세요.</p>
<p>다음으로, 러스트의 동시성에 대해 이야기할 것입니다. 몇 가지 새로운 스마트 포인터에 대해서도 배우게 될 것입니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch15-05-interior-mutability.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch16-00-concurrency.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch15-05-interior-mutability.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch16-00-concurrency.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
