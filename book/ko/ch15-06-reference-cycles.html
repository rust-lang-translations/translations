<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>참조 순환은 메모리 누수를 일으킬 수 있다 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch15-06-reference-cycles.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch15-06-reference-cycles.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="참조-순환은-메모리-누수를-일으킬-수-있다"><a class="header" href="#참조-순환은-메모리-누수를-일으킬-수-있다">참조 순환은 메모리 누수를 일으킬 수 있다</a></h2>
<p>러스트의 메모리 안전성 보장은 정리되지 않는 메모리를 우연히 생성하는 것(메모리 누수라고 함)을 어렵게 만들지만 불가능하지는 않습니다. 메모리 누수를 완전히 방지하는 것은 러스트의 보장 중 하나가 아니며, 이는 메모리 누수가 러스트에서 메모리 안전함을 의미합니다. Rc<T>와 RefCell<T>를 사용하여 러스트가 메모리 누수를 허용함을 볼 수 있습니다: 항목들이 서로를 순환 참조하는 참조를 생성하는 것이 가능합니다. 이는 순환의 각 항목에 대한 참조 카운트가 결코 0에 도달하지 않고 값들이 결코 드롭되지 않기 때문에 메모리 누수를 생성합니다.</p>
<h3 id="순환-참조-생성하기"><a class="header" href="#순환-참조-생성하기">순환 참조 생성하기</a></h3>
<p>순환 참조가 어떻게 발생할 수 있는지와 이를 방지하는 방법을 목록 15-25의 List 열거형 정의와 tail 메서드로 시작하여 살펴봅시다:</p>
<Listing number="15-25" file-name="src/main.rs" caption="A cons list definition that holds a `RefCell<T>` so we can modify what a `Cons` variant is referring to">
<pre><pre class="playground"><code class="language-rust edition2021">use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match self {
            Cons(_, item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}

fn main() {}</code></pre></pre>
</Listing>
<p>목록 15-5의 List 정의의 또 다른 변형을 사용하고 있습니다. Cons 변형의 두 번째 요소는 이제 RefCell&lt;Rc<List>&gt;이며, 이는 목록 15-24에서 했던 것처럼 i32 값을 수정하는 기능 대신 Cons 변형이 가리키는 List 값을 수정하고자 함을 의미합니다. 또한 Cons 변형이 있는 경우 두 번째 항목에 편리하게 접근할 수 있도록 tail 메서드를 추가하고 있습니다.</p>
<p>목록 15-26에서는 목록 15-25의 정의를 사용하는 main 함수를 추가하고 있습니다. 이 코드는 a에 리스트를 생성하고 b에 a의 리스트를 가리키는 리스트를 생성합니다. 그런 다음 a의 리스트가 b를 가리키도록 수정하여 순환 참조를 생성합니다. 이 과정의 다양한 지점에서 참조 카운트가 무엇인지 보여주기 위해 println! 문들이 있습니다.</p>
<Listing number="15-26" file-name="src/main.rs" caption="Creating a reference cycle of two `List` values pointing to each other">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum List {
</span><span class="boring">    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
</span><span class="boring">        match self {
</span><span class="boring">            Cons(_, item) =&gt; Some(item),
</span><span class="boring">            Nil =&gt; None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!("a의 초기 rc 카운트 = {}", Rc::strong_count(&amp;a));
    println!("a의 다음 항목 = {:?}", a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));

    println!("b 생성 후 a의 rc 카운트 = {}", Rc::strong_count(&amp;a));
    println!("b의 초기 rc 카운트 = {}", Rc::strong_count(&amp;b));
    println!("b의 다음 항목 = {:?}", b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&amp;b);
    }

    println!("a 변경 후 b의 rc 카운트 = {}", Rc::strong_count(&amp;b));
    println!("a 변경 후 a의 rc 카운트 = {}", Rc::strong_count(&amp;a));

    // 다음 줄의 주석을 해제하면 순환이 있음을 볼 수 있습니다;
    // 스택 오버플로가 발생할 것입니다.
    // println!("a의 다음 항목 = {:?}", a.tail());
}</code></pre></pre>
</Listing>
<p>초기 리스트 5, Nil을 갖는 변수 a에 List 값을 보유하는 Rc<List> 인스턴스를 생성합니다. 그런 다음 값 10을 포함하고 a의 리스트를 가리키는 또 다른 List 값을 보유하는 Rc<List> 인스턴스를 변수 b에 생성합니다.</p>
<p>a가 Nil 대신 b를 가리키도록 수정하여 순환을 생성합니다. 이를 위해 tail 메서드를 사용하여 a의 RefCell&lt;Rc<List>&gt;에 대한 참조를 얻고, 이를 link 변수에 넣습니다. 그런 다음 RefCell&lt;Rc<List>&gt;에서 borrow_mut 메서드를 사용하여 내부 값을 Nil 값을 보유하는 Rc<List>에서 b의 Rc<List>로 변경합니다.</p>
<p>이 코드를 실행할 때, 마지막 println!을 주석 처리한 상태로 두면 다음과 같은 출력을 얻을 것입니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.53s
     Running `target/debug/cons-list`
a의 초기 rc 카운트 = 1
a의 다음 항목 = Some(RefCell { value: Nil })
b 생성 후 a의 rc 카운트 = 2
b의 초기 rc 카운트 = 1
b의 다음 항목 = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
a 변경 후 b의 rc 카운트 = 2
a 변경 후 a의 rc 카운트 = 2
</code></pre>
<p>a의 리스트가 b를 가리키도록 변경한 후 a와 b의 Rc<List> 인스턴스에 대한 참조 카운트는 모두 2입니다. main의 끝에서 러스트는 변수 b를 드롭하고, 이는 b의 Rc<List> 인스턴스의 참조 카운트를 2에서 1로 줄입니다. Rc<List>가 힙에 가지고 있는 메모리는 이 시점에서 드롭되지 않습니다. 참조 카운트가 0이 아니라 1이기 때문입니다. 그런 다음 러스트는 a를 드롭하고, 이는 a의 Rc<List> 인스턴스의 참조 카운트도 2에서 1로 줄입니다. 이 인스턴스의 메모리 또한 드롭될 수 없습니다. 다른 Rc<List> 인스턴스가 여전히 그것을 참조하고 있기 때문입니다. 리스트에 할당된 메모리는 영원히 회수되지 않은 채로 남을 것입니다. 이 순환 참조를 시각화하기 위해 그림 15-4의 다이어그램을 만들었습니다.</p>
<img alt="Reference cycle of lists" src="img/trpl15-04.svg" class="center" />
<p><span class="caption">그림 15-4: 서로를 가리키는 리스트 a와 b의 순환 참조</span></p>
<p>마지막 println!의 주석을 해제하고 프로그램을 실행하면, 러스트는 a가 b를 가리키고 b가 a를 가리키는 식으로 스택이 오버플로될 때까지 이 순환을 출력하려고 시도할 것입니다.</p>
<p>실제 프로그램과 비교할 때, 이 예제에서 순환 참조를 생성하는 것의 결과는 그리 끔찍하지 않습니다. 순환 참조를 생성한 직후 프로그램이 종료되기 때문입니다. 하지만 더 복잡한 프로그램이 순환 내에서 많은 메모리를 할당하고 오랫동안 유지한다면, 프로그램은 필요한 것보다 더 많은 메모리를 사용하여 시스템을 압도하고 사용 가능한 메모리가 부족하게 만들 수 있습니다.</p>
<p>순환 참조를 생성하는 것은 쉽지 않지만, 불가능하지도 않습니다. Rc<T> 값을 포함하는 RefCell<T> 값이나 내부 가변성과 참조 카운팅이 있는 타입의 유사한 중첩 조합이 있는 경우, 순환을 생성하지 않도록 보장해야 합니다. 러스트가 그것들을 잡아낼 것이라고 의존할 수 없습니다. 순환 참조를 생성하는 것은 프로그램의 논리 버그일 것이며, 자동화된 테스트, 코드 리뷰 및 기타 소프트웨어 개발 관행을 사용하여 최소화해야 합니다.</p>
<p>순환 참조를 피하는 또 다른 해결책은 일부 참조는 소유권을 표현하고 일부 참조는 그렇지 않도록 데이터 구조를 재구성하는 것입니다. 결과적으로 일부 소유권 관계와 일부 비소유권 관계로 구성된 순환을 가질 수 있으며, 소유권 관계만이 값이 드롭될 수 있는지 여부에 영향을 미칩니다. 목록 15-25에서는 Cons 변형이 항상 리스트를 소유하기를 원하므로 데이터 구조를 재구성하는 것이 불가능합니다. 비소유권 관계가 순환 참조를 방지하는 적절한 방법이 되는 경우를 보기 위해 부모 노드와 자식 노드로 구성된 그래프를 사용하는 예제를 살펴봅시다.</p>
<h3 id="순환-참조-방지하기-rc를-weak로-바꾸기"><a class="header" href="#순환-참조-방지하기-rc를-weak로-바꾸기">순환 참조 방지하기: Rc<T>를 Weak<T>로 바꾸기</a></h3>
<p>지금까지 Rc::clone을 호출하면 Rc<T> 인스턴스의 strong_count가 증가하고, Rc<T> 인스턴스는 strong_count가 0일 때만 정리된다는 것을 보여주었습니다. 또한 Rc::downgrade를 호출하고 Rc<T>에 대한 참조를 전달하여 Rc<T> 인스턴스 내의 값에 대한 약한 참조를 생성할 수도 있습니다. 강한 참조는 Rc<T> 인스턴스의 소유권을 공유하는 방법입니다. 약한 참조는 소유권 관계를 표현하지 않으며, 그 카운트는 Rc<T> 인스턴스가 정리되는 시점에 영향을 미치지 않습니다. 약한 참조를 포함하는 순환은 관련된 값의 강한 참조 카운트가 0이 되면 깨지기 때문에 순환 참조를 일으키지 않습니다.</p>
<p>Rc::downgrade를 호출하면 Weak<T> 타입의 스마트 포인터를 얻습니다. Rc<T> 인스턴스의 strong_count를 1 증가시키는 대신, Rc::downgrade를 호출하면 weak_count가 1 증가합니다. Rc<T> 타입은 strong_count와 유사하게 존재하는 Weak<T> 참조의 수를 추적하기 위해 weak_count를 사용합니다. 차이점은 Rc<T> 인스턴스가 정리되기 위해 weak_count가 0일 필요는 없다는 것입니다.</p>
<p>Weak<T>가 참조하는 값은 드롭되었을 수 있으므로, Weak<T>가 가리키는 값으로 무언가를 하려면 값이 여전히 존재하는지 확인해야 합니다. Weak<T> 인스턴스에서 upgrade 메서드를 호출하여 이를 수행하며, 이는 Option&lt;Rc<T>&gt;를 반환합니다. Rc<T> 값이 아직 드롭되지 않았다면 Some 결과를, Rc<T> 값이 드롭되었다면 None 결과를 얻을 것입니다. upgrade는 Option&lt;Rc<T>&gt;를 반환하므로, 러스트는 Some 케이스와 None 케이스가 처리되도록 보장하며, 유효하지 않은 포인터는 없을 것입니다.</p>
<p>예를 들어, 항목이 다음 항목에 대해서만 알고 있는 리스트를 사용하는 대신, 항목이 자식 항목 <em>및</em> 부모 항목에 대해 알고 있는 트리를 생성할 것입니다.</p>
<h4 id="트리-데이터-구조-생성하기-자식-노드가-있는-node"><a class="header" href="#트리-데이터-구조-생성하기-자식-노드가-있는-node">트리 데이터 구조 생성하기: 자식 노드가 있는 Node</a></h4>
<p>시작하기 위해, 자식 노드에 대해 알고 있는 노드가 있는 트리를 구축할 것입니다. 자체 i32 값과 자식 Node 값에 대한 참조를 보유하는 Node라는 구조체를 생성할 것입니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<p>Node가 자식을 소유하고, 트리의 각 Node에 직접 접근할 수 있도록 그 소유권을 변수와 공유하고 싶습니다. 이를 위해 Vec<T> 항목을 Rc<Node> 타입의 값으로 정의합니다. 또한 다른 노드의 자식인 노드를 수정하고 싶으므로 Vec&lt;Rc<Node>&gt;를 감싸는 children에 RefCell<T>를 사용합니다.</p>
<p>다음으로, 구조체 정의를 사용하여 목록 15-27에 표시된 것처럼 값 3과 자식이 없는 leaf라는 Node 인스턴스 하나와, 값 5와 leaf를 자식 중 하나로 갖는 branch라는 또 다른 인스턴스를 생성할 것입니다:</p>
<Listing number="15-27" file-name="src/main.rs" caption="Creating a `leaf` node with no children and a `branch` node with `leaf` as one of its children">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });
}</code></pre></pre>
</Listing>
<p>leaf의 Rc<Node>를 클론하여 branch에 저장합니다. 이는 leaf의 Node가 이제 leaf와 branch라는 두 소유자를 가짐을 의미합니다. branch.children을 통해 branch에서 leaf로 이동할 수 있지만, leaf에서 branch로 이동할 방법은 없습니다. 이유는 leaf가 branch에 대한 참조를 가지고 있지 않고 서로 관련되어 있다는 것을 모르기 때문입니다. leaf가 branch가 자신의 부모라는 것을 알기를 원합니다. 다음으로 그 작업을 할 것입니다.</p>
<h4 id="자식에서-부모로의-참조-추가하기"><a class="header" href="#자식에서-부모로의-참조-추가하기">자식에서 부모로의 참조 추가하기</a></h4>
<p>자식 노드가 부모를 인식하도록 하려면 Node 구조체 정의에 parent 필드를 추가해야 합니다. 문제는 parent의 타입을 무엇으로 할지 결정하는 것입니다. Rc<T>를 포함할 수 없다는 것을 알고 있습니다. 왜냐하면 leaf.parent가 branch를 가리키고 branch.children이 leaf를 가리키는 순환 참조를 생성하여 strong_count 값이 결코 0이 되지 않게 만들기 때문입니다.</p>
<p>관계를 다른 방식으로 생각해보면, 부모 노드는 자식을 소유해야 합니다. 부모 노드가 드롭되면 자식 노드들도 드롭되어야 합니다. 그러나 자식은 부모를 소유해서는 안 됩니다. 자식 노드를 드롭하더라도 부모는 여전히 존재해야 합니다. 이것은 약한 참조가 필요한 경우입니다!</p>
<p>그래서 Rc<T> 대신 parent의 타입이 Weak<T>, 구체적으로는 RefCell&lt;Weak<Node>&gt;를 사용하도록 만들 것입니다. 이제 Node 구조체 정의는 다음과 같습니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!("leaf의 부모 = {:?}", leaf.parent.borrow().upgrade());
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);
</span><span class="boring">
</span><span class="boring">    println!("leaf의 부모 = {:?}", leaf.parent.borrow().upgrade());
</span><span class="boring">}</span></code></pre></pre>
<p>노드는 부모 노드를 참조할 수 있지만 부모를 소유하지는 않습니다. 목록 15-28에서 이 새로운 정의를 사용하도록 main을 업데이트하여 leaf 노드가 부모인 branch를 참조할 수 있는 방법을 갖도록 합니다:</p>
<Listing number="15-28" file-name="src/main.rs" caption="A `leaf` node with a weak reference to its parent node `branch`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!("leaf의 부모 = {:?}", leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

    println!("leaf의 부모 = {:?}", leaf.parent.borrow().upgrade());
}</code></pre></pre>
</Listing>
<p>leaf 노드를 생성하는 것은 parent 필드를 제외하고는 목록 15-27과 유사해 보입니다. leaf는 부모 없이 시작하므로, 새롭고 빈 Weak<Node> 참조 인스턴스를 생성합니다.</p>
<p>이 시점에서, upgrade 메서드를 사용하여 leaf의 부모에 대한 참조를 얻으려고 시도하면 None 값을 얻습니다. 첫 번째 println! 문의 출력에서 이를 확인할 수 있습니다:</p>
<pre><code class="language-text">leaf parent = None
</code></pre>
<p>branch 노드를 생성할 때, branch도 부모 노드가 없기 때문에 parent 필드에 새로운 Weak<Node> 참조를 가질 것입니다. 여전히 leaf를 branch의 자식 중 하나로 가지고 있습니다. branch에 Node 인스턴스가 생기면, leaf를 수정하여 부모에 대한 Weak<Node> 참조를 줄 수 있습니다. leaf의 parent 필드에 있는 RefCell&lt;Weak<Node>&gt;에서 borrow_mut 메서드를 사용한 다음, Rc::downgrade 함수를 사용하여 branch의 Rc<Node>에서 branch에 대한 Weak<Node> 참조를 생성합니다.</p>
<p>leaf의 부모를 다시 출력하면, 이번에는 branch를 보유하는 Some 변형을 얻게 될 것입니다. 이제 leaf는 부모에 접근할 수 있습니다! leaf를 출력할 때, 목록 15-26에서처럼 결국 스택 오버플로로 끝나는 순환도 피하게 됩니다. Weak<Node> 참조는 (Weak)로 출력됩니다:</p>
<pre><code class="language-text">leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
</code></pre>
<p>무한 출력이 없다는 것은 이 코드가 순환 참조를 생성하지 않았음을 나타냅니다. Rc::strong_count와 Rc::weak_count를 호출하여 얻은 값을 보고도 이를 알 수 있습니다.</p>
<h4 id="strong_count와-weak_count의-변화-시각화하기"><a class="header" href="#strong_count와-weak_count의-변화-시각화하기">strong_count와 weak_count의 변화 시각화하기</a></h4>
<p>새로운 내부 스코프를 생성하고 branch 생성을 그 스코프로 이동시켜 Rc<Node> 인스턴스의 strong_count와 weak_count 값이 어떻게 변하는지 살펴봅시다. 그렇게 함으로써 branch가 생성되고 스코프를 벗어날 때 드롭되면 어떤 일이 발생하는지 볼 수 있습니다. 수정 사항은 목록 15-29에 나와 있습니다:</p>
<Listing number="15-29" file-name="src/main.rs" caption="Creating `branch` in an inner scope and examining strong and weak reference counts">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

        println!(
            "branch strong = {}, weak = {}",
            Rc::strong_count(&amp;branch),
            Rc::weak_count(&amp;branch),
        );

        println!(
            "leaf strong = {}, weak = {}",
            Rc::strong_count(&amp;leaf),
            Rc::weak_count(&amp;leaf),
        );
    }

    println!("leaf의 부모 = {:?}", leaf.parent.borrow().upgrade());
    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );
}</code></pre></pre>
</Listing>
<p>leaf가 생성된 후, Rc<Node>의 강한 카운트는 1, 약한 카운트는 0입니다. 내부 스코프에서 branch를 생성하고 leaf와 연결합니다. 이때 카운트를 출력하면 branch의 Rc<Node>는 강한 카운트 1, 약한 카운트 1을 갖게 됩니다(leaf.parent가 Weak<Node>로 branch를 가리키기 때문입니다). leaf의 카운트를 출력하면 강한 카운트가 2가 되는 것을 볼 수 있습니다. branch가 이제 branch.children에 저장된 leaf의 Rc<Node> 클론을 가지고 있기 때문입니다. 하지만 약한 카운트는 여전히 0일 것입니다.</p>
<p>내부 스코프가 끝나면 branch는 스코프를 벗어나고 Rc<Node>의 강한 카운트가 0으로 감소하므로 Node가 드롭됩니다. leaf.parent의 약한 카운트 1은 Node의 드롭 여부에 아무런 영향을 미치지 않으므로 메모리 누수가 발생하지 않습니다!</p>
<p>스코프가 끝난 후 leaf의 부모에 접근하려고 하면 다시 None을 얻게 됩니다. 프로그램이 끝날 때 leaf의 Rc<Node>는 강한 카운트 1, 약한 카운트 0을 갖습니다. 이제 leaf 변수만이 Rc<Node>에 대한 유일한 참조이기 때문입니다.</p>
<p>카운트와 값 드롭을 관리하는 모든 로직은 Rc<T>와 Weak<T> 그리고 그들의 Drop 트레이트 구현에 내장되어 있습니다. Node 정의에서 자식에서 부모로의 관계가 Weak<T> 참조여야 한다고 지정함으로써, 순환 참조와 메모리 누수를 생성하지 않고 부모 노드가 자식 노드를 가리키고 그 반대도 가능하게 할 수 있습니다.</p>
<h2 id="요약"><a class="header" href="#요약">요약</a></h2>
<p>이 장에서는 일반 참조와 다른 보증 및 절충안을 만들기 위해 스마트 포인터를 사용하는 방법을 다루었습니다. <code>Box&lt;T&gt;</code> 타입은 알려진 크기를 가지며 힙에 할당된 데이터를 가리킵니다. <code>Rc&lt;T&gt;</code> 타입은 힙의 데이터에 대한 참조 수를 추적하여 데이터가 여러 소유자를 가질 수 있도록 합니다. 내부 가변성을 가진 <code>RefCell&lt;T&gt;</code> 타입은 불변 타입이 필요하지만 해당 타입의 내부 값을 변경해야 할 때 사용할 수 있는 타입을 제공하며, 컴파일 타임 대신 런타임에 빌림 규칙을 적용합니다.</p>
<p>또한 스마트 포인터의 많은 기능을 가능하게 하는 Deref와 Drop 트레이트에 대해서도 논의했습니다. 메모리 누수를 일으킬 수 있는 순환 참조와 Weak<T>를 사용하여 이를 방지하는 방법을 살펴보았습니다.</p>
<p>이 장이 흥미로웠고 자신만의 스마트 포인터를 구현하고 싶다면, 더 유용한 정보를 위해 <a href="../nomicon/index.html">“The Rustonomicon”</a>을 확인하세요.</p>
<p>다음으로, 러스트의 동시성에 대해 이야기할 것입니다. 몇 가지 새로운 스마트 포인터에 대해서도 배우게 될 것입니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch15-05-interior-mutability.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch16-00-concurrency.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch15-05-interior-mutability.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch16-00-concurrency.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
