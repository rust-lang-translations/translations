<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>안전하지 않은 러스트 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch20-01-unsafe-rust.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch20-01-unsafe-rust.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="안전하지-않은-러스트"><a class="header" href="#안전하지-않은-러스트">안전하지 않은 러스트</a></h2>
<p>All the code we’ve discussed so far has had Rust’s memory safety guarantees enforced at compile time. However, Rust has a second language hidden inside it that doesn’t enforce these memory safety guarantees: It’s called <em>unsafe Rust</em> and works just like regular Rust but gives us extra superpowers.</p>
<p>Unsafe Rust exists because, by nature, static analysis is conservative. When the compiler tries to determine whether or not code upholds the guarantees, it’s better for it to reject some valid programs than to accept some invalid programs. Although the code <em>might</em> be okay, if the Rust compiler doesn’t have enough information to be confident, it will reject the code. In these cases, you can use unsafe code to tell the compiler, “Trust me, I know what I’m doing.” Be warned, however, that you use unsafe Rust at your own risk: If you use unsafe code incorrectly, problems can occur due to memory unsafety, such as null pointer dereferencing.</p>
<p>러스트가 안전하지 않은 또 다른 자아를 가진 이유는 기저의 컴퓨터 하드웨어가 본질적으로 안전하지 않기 때문입니다. 러스트가 unsafe 연산을 허용하지 않는다면, 여러분은 특정한 작업들을 수행할 수 없을 것입니다. 러스트는 운영체제와 직접 상호작용하거나 심지어 자신만의 운영체제를 작성하는 것과 같은 저수준 시스템 프로그래밍을 허용해야 합니다. 저수준 시스템 프로그래밍 작업을 가능하게 하는 것은 이 언어의 목표 중 하나입니다. 안전하지 않은 러스트로 무엇을 할 수 있고, 어떻게 하는지 알아봅시다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="unsafe-superpowers"></a></p>
<h3 id="performing-unsafe-superpowers"><a class="header" href="#performing-unsafe-superpowers">Performing Unsafe Superpowers</a></h3>
<p>안전하지 않은 러스트로 전환하려면 <code>unsafe</code> 키워드를 사용하고, unsafe 코드를 담을 새로운 블록을 시작하세요. 안전한 러스트에서는 할 수 없지만 안전하지 않은 러스트에서는 할 수 있는 다섯 가지 동작이 있으며, 우리는 이를 _안전하지 않은 초능력(unsafe superpowers)_이라고 부릅니다. 이 초능력들은 다음과 같은 능력을 포함합니다.</p>
<ol>
<li>Dereference a raw pointer.</li>
<li>Call an unsafe function or method.</li>
<li>Access or modify a mutable static variable.</li>
<li>Implement an unsafe trait.</li>
<li>Access fields of <code>union</code>s.</li>
</ol>
<p>It’s important to understand that <code>unsafe</code> doesn’t turn off the borrow checker or disable any of Rust’s other safety checks: If you use a reference in unsafe code, it will still be checked. The <code>unsafe</code> keyword only gives you access to these five features that are then not checked by the compiler for memory safety. You’ll still get some degree of safety inside an unsafe block.</p>
<p>In addition, <code>unsafe</code> does not mean the code inside the block is necessarily dangerous or that it will definitely have memory safety problems: The intent is that as the programmer, you’ll ensure that the code inside an <code>unsafe</code> block will access memory in a valid way.</p>
<p>People are fallible and mistakes will happen, but by requiring these five unsafe operations to be inside blocks annotated with <code>unsafe</code>, you’ll know that any errors related to memory safety must be within an <code>unsafe</code> block. Keep <code>unsafe</code> blocks small; you’ll be thankful later when you investigate memory bugs.</p>
<p>To isolate unsafe code as much as possible, it’s best to enclose such code within a safe abstraction and provide a safe API, which we’ll discuss later in the chapter when we examine unsafe functions and methods. Parts of the standard library are implemented as safe abstractions over unsafe code that has been audited. Wrapping unsafe code in a safe abstraction prevents uses of <code>unsafe</code> from leaking out into all the places that you or your users might want to use the functionality implemented with <code>unsafe</code> code, because using a safe abstraction is safe.</p>
<p>이제 다섯 가지 안전하지 않은 초능력을 하나씩 살펴보겠습니다. 또한 unsafe 코드에 대한 안전한 인터페이스를 제공하는 몇 가지 추상화에 대해서도 알아보겠습니다.</p>
<h3 id="원시-포인터-역참조하기"><a class="header" href="#원시-포인터-역참조하기">원시 포인터 역참조하기</a></h3>
<p>In Chapter 4, in the <a href="ch04-02-references-and-borrowing.html#dangling-references">“Dangling References”</a><!-- ignore
--> section, we mentioned that the compiler ensures that references are always valid. Unsafe Rust has two new types called <em>raw pointers</em> that are similar to references. As with references, raw pointers can be immutable or mutable and are written as <code>*const T</code> and <code>*mut T</code>, respectively. The asterisk isn’t the dereference operator; it’s part of the type name. In the context of raw pointers, <em>immutable</em> means that the pointer can’t be directly assigned to after being dereferenced.</p>
<p>참조나 스마트 포인터와 달리 원시 포인터는 다음과 같은 특징을 갖습니다.</p>
<ul>
<li>동일한 위치에 대해 불변 포인터와 가변 포인터를 동시에 갖거나, 여러 개의 가변 포인터를 가짐으로써 빌림 규칙을 무시할 수 있습니다.</li>
<li>유효한 메모리를 가리킨다는 보장이 없습니다</li>
<li>널(null)이 될 수 있습니다</li>
<li>어떠한 자동 정리 기능도 구현하지 않습니다</li>
</ul>
<p>러스트가 이러한 보증을 강제하는 것을 거부함으로써, 여러분은 보장된 안전성을 포기하는 대신 더 높은 성능을 얻거나 러스트의 보증이 적용되지 않는 다른 언어 또는 하드웨어와 인터페이스할 수 있는 능력을 얻을 수 있습니다.</p>
<p>목록 20-1은 불변 원시 포인터와 가변 원시 포인터를 만드는 방법을 보여줍니다.</p>
<Listing number="20-1" caption="Creating raw pointers with the raw borrow operators">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;raw const num;
    let r2 = &amp;raw mut num;
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 코드에는 <code>unsafe</code> 키워드가 포함되어 있지 않음에 주목하세요. 우리는 안전한 코드에서도 원시 포인터를 생성할 수 있습니다. 잠시 후에 보게 되겠지만, 단지 unsafe 블록 외부에서 원시 포인터를 역참조할 수 없을 뿐입니다.</p>
<p>우리는 원시 빌림 연산자(raw borrow operators)를 사용하여 원시 포인터를 생성했습니다. <code>&amp;raw const num</code>은 <code>*const i32</code> 불변 원시 포인터를 생성하고, <code>&amp;raw mut num</code>은 <code>*mut i32</code> 가변 원시 포인터를 생성합니다. 우리는 지역 변수로부터 직접 생성했기 때문에 이 특정한 원시 포인터들이 유효하다는 것을 알고 있지만, 모든 원시 포인터에 대해 그러한 가정을 할 수는 없습니다.</p>
<p>To demonstrate this, next we’ll create a raw pointer whose validity we can’t be so certain of, using the keyword <code>as</code> to cast a value instead of using the raw borrow operator. Listing 20-2 shows how to create a raw pointer to an arbitrary location in memory. Trying to use arbitrary memory is undefined: There might be data at that address or there might not, the compiler might optimize the code so that there is no memory access, or the program might terminate with a segmentation fault. Usually, there is no good reason to write code like this, especially in cases where you can use a raw borrow operator instead, but it is possible.</p>
<Listing number="20-2" caption="Creating a raw pointer to an arbitrary memory address">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let address = 0x012345usize;
    let r = address as *const i32;
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>Recall that we can create raw pointers in safe code, but we can’t dereference raw pointers and read the data being pointed to. In Listing 20-3, we use the dereference operator <code>*</code> on a raw pointer that requires an <code>unsafe</code> block.</p>
<Listing number="20-3" caption="Dereferencing raw pointers within an `unsafe` block">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;raw const num;
    let r2 = &amp;raw mut num;

    unsafe {
        println!("r1은: {}"입니다, *r1);
        println!("r2는: {}"입니다, *r2);
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>포인터를 생성하는 것 자체는 해롭지 않습니다. 포인터가 가리키는 값에 접근하려고 시도할 때 비로소 유효하지 않은 값을 다루게 될 위험이 생기는 것입니다.</p>
<p>Note also that in Listings 20-1 and 20-3, we created <code>*const i32</code> and <code>*mut i32</code> raw pointers that both pointed to the same memory location, where <code>num</code> is stored. If we instead tried to create an immutable and a mutable reference to <code>num</code>, the code would not have compiled because Rust’s ownership rules don’t allow a mutable reference at the same time as any immutable references. With raw pointers, we can create a mutable pointer and an immutable pointer to the same location and change data through the mutable pointer, potentially creating a data race. Be careful!</p>
<p>With all of these dangers, why would you ever use raw pointers? One major use case is when interfacing with C code, as you’ll see in the next section. Another case is when building up safe abstractions that the borrow checker doesn’t understand. We’ll introduce unsafe functions and then look at an example of a safe abstraction that uses unsafe code.</p>
<h3 id="안전하지-않은-함수-또는-메서드-호출하기"><a class="header" href="#안전하지-않은-함수-또는-메서드-호출하기">안전하지 않은 함수 또는 메서드 호출하기</a></h3>
<p>The second type of operation you can perform in an unsafe block is calling unsafe functions. Unsafe functions and methods look exactly like regular functions and methods, but they have an extra <code>unsafe</code> before the rest of the definition. The <code>unsafe</code> keyword in this context indicates the function has requirements we need to uphold when we call this function, because Rust can’t guarantee we’ve met these requirements. By calling an unsafe function within an <code>unsafe</code> block, we’re saying that we’ve read this function’s documentation and we take responsibility for upholding the function’s contracts.</p>
<p>다음은 본문에서 아무것도 하지 않는 <code>dangerous</code>라는 이름의 unsafe 함수입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    unsafe fn dangerous() {}

    unsafe {
        dangerous();
    }
<span class="boring">}</span></code></pre></pre>
<p>우리는 <code>dangerous</code> 함수를 별도의 <code>unsafe</code> 블록 내에서 호출해야 합니다. 만약 <code>unsafe</code> 블록 없이 <code>dangerous</code>를 호출하려 하면, 다음과 같은 에러가 발생합니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0133]: call to unsafe function `dangerous` is unsafe and requires unsafe block
 --&gt; src/main.rs:4:5
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
  |
  = note: consult the function's documentation for information on how to avoid undefined behavior

For more information about this error, try `rustc --explain E0133`.
error: could not compile `unsafe-example` (bin "unsafe-example") due to 1 previous error
</code></pre>
<p><code>unsafe</code> 블록을 사용함으로써, 우리는 러스트에게 우리가 함수의 문서를 읽었으며, 함수를 올바르게 사용하는 법을 이해했고, 함수의 계약(contract)을 준수하고 있음을 확인했다고 단언하는 것입니다.</p>
<p>To perform unsafe operations in the body of an <code>unsafe</code> function, you still need to use an <code>unsafe</code> block, just as within a regular function, and the compiler will warn you if you forget. This helps us keep <code>unsafe</code> blocks as small as possible, as unsafe operations may not be needed across the whole function body.</p>
<h4 id="unsafe-코드에-대한-안전한-추상화-만들기"><a class="header" href="#unsafe-코드에-대한-안전한-추상화-만들기">unsafe 코드에 대한 안전한 추상화 만들기</a></h4>
<p>Just because a function contains unsafe code doesn’t mean we need to mark the entire function as unsafe. In fact, wrapping unsafe code in a safe function is a common abstraction. As an example, let’s study the <code>split_at_mut</code> function from the standard library, which requires some unsafe code. We’ll explore how we might implement it. This safe method is defined on mutable slices: It takes one slice and makes it two by splitting the slice at the index given as an argument. Listing 20-4 shows how to use <code>split_at_mut</code>.</p>
<Listing number="20-4" caption="Using the safe `split_at_mut` function">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5, 6];

    let r = &amp;mut v[..];

    let (a, b) = r.split_at_mut(3);

    assert_eq!(a, &amp;mut [1, 2, 3]);
    assert_eq!(b, &amp;mut [4, 5, 6]);
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>우리는 오직 안전한 러스트만으로는 이 함수를 구현할 수 없습니다. 시도해 본다면 컴파일되지 않는 목록 20-5와 같은 모습이 될 것입니다. 단순함을 위해, 우리는 <code>split_at_mut</code>을 메서드가 아닌 함수로 구현할 것이며, 제네릭 타입 <code>T</code>가 아닌 <code>i32</code> 값의 슬라이스에 대해서만 구현하겠습니다.</p>
<Listing number="20-5" caption="An attempted implementation of `split_at_mut` using only safe Rust">
<pre><code class="language-rust ignore does_not_compile">fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();

    assert!(mid &lt;= len);

    (&amp;mut values[..mid], &amp;mut values[mid..])
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}</span></code></pre>
</Listing>
<p>This function first gets the total length of the slice. Then, it asserts that the index given as a parameter is within the slice by checking whether it’s less than or equal to the length. The assertion means that if we pass an index that is greater than the length to split the slice at, the function will panic before it attempts to use that index.</p>
<p>Then, we return two mutable slices in a tuple: one from the start of the original slice to the <code>mid</code> index and another from <code>mid</code> to the end of the slice.</p>
<p>When we try to compile the code in Listing 20-5, we’ll get an error:</p>
<p>러스트의 대여 검사기는 우리가 슬라이스의 서로 다른 부분을 대여하고 있다는 것을 이해하지 못합니다. 단지 우리가 같은 슬라이스에서 두 번 대여하고 있다는 것만 알고 있습니다. 슬라이스의 서로 다른 부분을 대여하는 것은 두 슬라이스가 겹치지 않기 때문에 근본적으로 괜찮지만, 러스트는 이를 알 만큼 영리하지 않습니다. 코드가 괜찮다는 것을 우리가 알지만 러스트는 모를 때가 바로 안전하지 않은 코드를 사용해야 할 때입니다.Rust’s borrow checker can’t understand that we’re borrowing different parts of the slice; it only knows that we’re borrowing from the same slice twice. Borrowing different parts of a slice is fundamentally okay because the two slices aren’t overlapping, but Rust isn’t smart enough to know this. When we know code is okay, but Rust doesn’t, it’s time to reach for unsafe code.</p>
<p>예제 20-6은 <code>split_at_mut</code> 구현이 작동하도록 <code>unsafe</code> 블록, 원시 포인터, 그리고 몇 가지 안전하지 않은 함수 호출을 사용하는 방법을 보여줍니다.</p>
<Listing number="20-6" caption="Using unsafe code in the implementation of the `split_at_mut` function">
<pre><pre class="playground"><code class="language-rust edition2024">use std::slice;

fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();
    let ptr = values.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>Recall from <a href="ch04-03-slices.html#the-slice-type">“The Slice Type”</a><!-- ignore --> section in Chapter 4 that a slice is a pointer to some data and the length of the slice. We use the <code>len</code> method to get the length of a slice and the <code>as_mut_ptr</code> method to access the raw pointer of a slice. In this case, because we have a mutable slice to <code>i32</code> values, <code>as_mut_ptr</code> returns a raw pointer with the type <code>*mut i32</code>, which we’ve stored in the variable <code>ptr</code>.</p>
<p>We keep the assertion that the <code>mid</code> index is within the slice. Then, we get to the unsafe code: The <code>slice::from_raw_parts_mut</code> function takes a raw pointer and a length, and it creates a slice. We use this function to create a slice that starts from <code>ptr</code> and is <code>mid</code> items long. Then, we call the <code>add</code> method on <code>ptr</code> with <code>mid</code> as an argument to get a raw pointer that starts at <code>mid</code>, and we create a slice using that pointer and the remaining number of items after <code>mid</code> as the length.</p>
<p>The function <code>slice::from_raw_parts_mut</code> is unsafe because it takes a raw pointer and must trust that this pointer is valid. The <code>add</code> method on raw pointers is also unsafe because it must trust that the offset location is also a valid pointer. Therefore, we had to put an <code>unsafe</code> block around our calls to <code>slice::from_raw_parts_mut</code> and <code>add</code> so that we could call them. By looking at the code and by adding the assertion that <code>mid</code> must be less than or equal to <code>len</code>, we can tell that all the raw pointers used within the <code>unsafe</code> block will be valid pointers to data within the slice. This is an acceptable and appropriate use of <code>unsafe</code>.</p>
<p>Note that we don’t need to mark the resultant <code>split_at_mut</code> function as <code>unsafe</code>, and we can call this function from safe Rust. We’ve created a safe abstraction to the unsafe code with an implementation of the function that uses <code>unsafe</code> code in a safe way, because it creates only valid pointers from the data this function has access to.</p>
<p>반면, 예제 20-7에서 <code>slice::from_raw_parts_mut</code>을 사용하는 것은 슬라이스가 사용될 때 크래시가 발생할 가능성이 큽니다. 이 코드는 임의의 메모리 위치를 가져와 10,000개 항목 길이의 슬라이스를 생성합니다.</p>
<Listing number="20-7" caption="Creating a slice from an arbitrary memory location">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    use std::slice;

    let address = 0x01234usize;
    let r = address as *mut i32;

    let values: &amp;[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>우리는 이 임의의 위치의 메모리를 소유하지 않으며, 이 코드가 생성하는 슬라이스가 유효한 <code>i32</code> 값을 포함한다는 보장도 없습니다. <code>values</code>를 마치 유효한 슬라이스인 것처럼 사용하려고 시도하면 정의되지 않은 동작(undefined behavior)이 발생합니다.</p>
<h4 id="외부-코드를-호출하기-위해-extern-함수-사용하기"><a class="header" href="#외부-코드를-호출하기-위해-extern-함수-사용하기">외부 코드를 호출하기 위해 <code>extern</code> 함수 사용하기</a></h4>
<p>Sometimes your Rust code might need to interact with code written in another language. For this, Rust has the keyword <code>extern</code> that facilitates the creation and use of a <em>Foreign Function Interface (FFI)</em>, which is a way for a programming language to define functions and enable a different (foreign) programming language to call those functions.</p>
<p>Listing 20-8 demonstrates how to set up an integration with the <code>abs</code> function from the C standard library. Functions declared within <code>extern</code> blocks are generally unsafe to call from Rust code, so <code>extern</code> blocks must also be marked <code>unsafe</code>. The reason is that other languages don’t enforce Rust’s rules and guarantees, and Rust can’t check them, so responsibility falls on the programmer to ensure safety.</p>
<Listing number="20-8" file-name="src/main.rs" caption="Declaring and calling an `extern` function defined in another language">
<pre><pre class="playground"><code class="language-rust edition2024">unsafe extern "C" {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!("C에 따른 -3의 절대값: {}", abs(-3));
    }
}</code></pre></pre>
</Listing>
<p>Within the <code>unsafe extern "C"</code> block, we list the names and signatures of external functions from another language we want to call. The <code>"C"</code> part defines which <em>application binary interface (ABI)</em> the external function uses: The ABI defines how to call the function at the assembly level. The <code>"C"</code> ABI is the most common and follows the C programming language’s ABI. Information about all the ABIs Rust supports is available in <a href="../reference/items/external-blocks.html#abi">the Rust Reference</a>.</p>
<p>Every item declared within an <code>unsafe extern</code> block is implicitly unsafe. However, some FFI functions <em>are</em> safe to call. For example, the <code>abs</code> function from C’s standard library does not have any memory safety considerations, and we know it can be called with any <code>i32</code>. In cases like this, we can use the <code>safe</code> keyword to say that this specific function is safe to call even though it is in an <code>unsafe extern</code> block. Once we make that change, calling it no longer requires an <code>unsafe</code> block, as shown in Listing 20-9.</p>
<Listing number="20-9" file-name="src/main.rs" caption="Explicitly marking a function as `safe` within an `unsafe extern` block and calling it safely">
<pre><pre class="playground"><code class="language-rust edition2024">unsafe extern "C" {
    safe fn abs(input: i32) -&gt; i32;
}

fn main() {
    println!("C에 따른 -3의 절대값: {}", abs(-3));
}</code></pre></pre>
</Listing>
<p>Marking a function as <code>safe</code> does not inherently make it safe! Instead, it is like a promise you are making to Rust that it is safe. It is still your responsibility to make sure that promise is kept!</p>
<h4 id="다른-언어에서-러스트-함수-호출하기"><a class="header" href="#다른-언어에서-러스트-함수-호출하기">다른 언어에서 러스트 함수 호출하기</a></h4>
<p>We can also use <code>extern</code> to create an interface that allows other languages to call Rust functions. Instead of creating a whole <code>extern</code> block, we add the <code>extern</code> keyword and specify the ABI to use just before the <code>fn</code> keyword for the relevant function. We also need to add an <code>#[unsafe(no_mangle)]</code> annotation to tell the Rust compiler not to mangle the name of this function. <em>Mangling</em> is when a compiler changes the name we’ve given a function to a different name that contains more information for other parts of the compilation process to consume but is less human readable. Every programming language compiler mangles names slightly differently, so for a Rust function to be nameable by other languages, we must disable the Rust compiler’s name mangling. This is unsafe because there might be name collisions across libraries without the built-in mangling, so it is our responsibility to make sure the name we choose is safe to export without mangling.</p>
<p>다음 예제에서는 <code>call_from_c</code> 함수를 공유 라이브러리로 컴파일하고 C에서 링크한 후, C 코드에서 접근할 수 있게 만듭니다.</p>
<pre><code>#[unsafe(no_mangle)]
pub extern "C" fn call_from_c() {
    println!("Just called a Rust function from C!");
}
</code></pre>
<p>This usage of <code>extern</code> requires <code>unsafe</code> only in the attribute, not on the <code>extern</code> block.</p>
<h3 id="가변-정적-변수에-접근하거나-수정하기"><a class="header" href="#가변-정적-변수에-접근하거나-수정하기">가변 정적 변수에 접근하거나 수정하기</a></h3>
<p>In this book, we’ve not yet talked about global variables, which Rust does support but which can be problematic with Rust’s ownership rules. If two threads are accessing the same mutable global variable, it can cause a data race.</p>
<p>러스트에서 전역 변수는 <em>정적(static)</em> 변수라고 불립니다. 예제 20-10은 문자열 슬라이스를 값으로 가지는 정적 변수의 선언과 사용 예를 보여줍니다.</p>
<Listing number="20-10" file-name="src/main.rs" caption="Defining and using an immutable static variable">
<pre><pre class="playground"><code class="language-rust edition2024">static HELLO_WORLD: &amp;str = "헬로, 월드!";

fn main() {
    println!("value is: {HELLO_WORLD}");
}</code></pre></pre>
</Listing>
<p>Static variables are similar to constants, which we discussed in the <a href="ch03-01-variables-and-mutability.html#declaring-constants">“Declaring Constants”</a><!-- ignore --> section in Chapter 3. The names of static variables are in <code>SCREAMING_SNAKE_CASE</code> by convention. Static variables can only store references with the <code>'static</code> lifetime, which means the Rust compiler can figure out the lifetime and we aren’t required to annotate it explicitly. Accessing an immutable static variable is safe.</p>
<p>상수와 불변 정적 변수의 미묘한 차이점은 정적 변수의 값은 메모리상의 고정된 주소를 가진다는 점입니다. 값을 사용하면 항상 동일한 데이터에 접근하게 됩니다. 반면 상수는 사용될 때마다 데이터가 복제될 수 있습니다. 또 다른 차이점은 정적 변수는 가변적일 수 있다는 것입니다. 가변 정적 변수에 접근하고 이를 수정하는 것은 안전하지 않습니다. 예제 20-11은 <code>COUNTER</code>라는 가변 정적 변수를 선언, 접근 및 수정하는 방법을 보여줍니다.</p>
<Listing number="20-11" file-name="src/main.rs" caption="Reading from or writing to a mutable static variable is unsafe.">
<pre><pre class="playground"><code class="language-rust edition2024">static mut COUNTER: u32 = 0;

/// SAFETY: 한 번에 둘 이상의 스레드에서 이를 호출하는 것은 정의되지 않은 동작이므로,
/// 한 번에 오직 하나의 스레드에서만 이를 호출하도록 보장해야 합니다.
unsafe fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    unsafe {
        // SAFETY: 이는 `main`의 단일 스레드에서만 호출됩니다.
        add_to_count(3);
        println!("COUNTER: {}", *(&amp;raw const COUNTER));
    }
}</code></pre></pre>
</Listing>
<p>As with regular variables, we specify mutability using the <code>mut</code> keyword. Any code that reads or writes from <code>COUNTER</code> must be within an <code>unsafe</code> block. The code in Listing 20-11 compiles and prints <code>COUNTER: 3</code> as we would expect because it’s single threaded. Having multiple threads access <code>COUNTER</code> would likely result in data races, so it is undefined behavior. Therefore, we need to mark the entire function as <code>unsafe</code> and document the safety limitation so that anyone calling the function knows what they are and are not allowed to do safely.</p>
<p>안전하지 않은 함수를 작성할 때마다 <code>SAFETY</code>로 시작하는 주석을 작성하여 호출자가 함수를 안전하게 호출하기 위해 무엇을 해야 하는지 설명하는 것이 관례입니다. 마찬가지로, 안전하지 않은 연산을 수행할 때마다 <code>SAFETY</code>로 시작하는 주석을 작성하여 안전 규칙이 어떻게 준수되는지 설명하는 것이 관례입니다.</p>
<p>Additionally, the compiler will deny by default any attempt to create references to a mutable static variable through a compiler lint. You must either explicitly opt out of that lint’s protections by adding an <code>#[allow(static_mut_refs)]</code> annotation or access the mutable static variable via a raw pointer created with one of the raw borrow operators. That includes cases where the reference is created invisibly, as when it is used in the <code>println!</code> in this code listing. Requiring references to static mutable variables to be created via raw pointers helps make the safety requirements for using them more obvious.</p>
<p>With mutable data that is globally accessible, it’s difficult to ensure that there are no data races, which is why Rust considers mutable static variables to be unsafe. Where possible, it’s preferable to use the concurrency techniques and thread-safe smart pointers we discussed in Chapter 16 so that the compiler checks that data access from different threads is done safely.</p>
<h3 id="안전하지-않은-트레이트-구현하기"><a class="header" href="#안전하지-않은-트레이트-구현하기">안전하지 않은 트레이트 구현하기</a></h3>
<p><code>unsafe</code>를 사용하여 안전하지 않은 트레이트를 구현할 수 있습니다. 트레이트의 메서드 중 적어도 하나에 컴파일러가 확인할 수 없는 불변성(invariant)이 있을 때 해당 트레이트는 안전하지 않습니다. 트레이트를 선언할 때 <code>trait</code> 앞에 <code>unsafe</code> 키워드를 추가하고, 해당 트레이트의 구현부 역시 <code>unsafe</code>로 표시함으로써 안전하지 않은 트레이트임을 선언합니다. 예제 20-12가 이를 보여줍니다.</p>
<Listing number="20-12" caption="Defining and implementing an unsafe trait">
<pre><pre class="playground"><code class="language-rust edition2024">unsafe trait Foo {
    // 메서드가 여기에 옵니다
}

unsafe impl Foo for i32 {
    // 메서드 구현이 여기에 옵니다
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p><code>unsafe impl</code>을 사용함으로써, 컴파일러가 확인할 수 없는 불변성을 우리가 준수할 것임을 약속하는 것입니다.</p>
<p>As an example, recall the <code>Send</code> and <code>Sync</code> marker traits we discussed in the <a href="ch16-04-extensible-concurrency-sync-and-send.html">“Extensible Concurrency with <code>Send</code> and <code>Sync</code>”</a><!-- ignore --> section in Chapter 16: The compiler implements these traits automatically if our types are composed entirely of other types that implement <code>Send</code> and <code>Sync</code>. If we implement a type that contains a type that does not implement <code>Send</code> or <code>Sync</code>, such as raw pointers, and we want to mark that type as <code>Send</code> or <code>Sync</code>, we must use <code>unsafe</code>. Rust can’t verify that our type upholds the guarantees that it can be safely sent across threads or accessed from multiple threads; therefore, we need to do those checks manually and indicate as such with <code>unsafe</code>.</p>
<h3 id="유니온의-필드에-접근하기"><a class="header" href="#유니온의-필드에-접근하기">유니온의 필드에 접근하기</a></h3>
<p>The final action that works only with <code>unsafe</code> is accessing fields of a union. A <em>union</em> is similar to a <code>struct</code>, but only one declared field is used in a particular instance at one time. Unions are primarily used to interface with unions in C code. Accessing union fields is unsafe because Rust can’t guarantee the type of the data currently being stored in the union instance. You can learn more about unions in <a href="../reference/items/unions.html">the Rust Reference</a>.</p>
<h3 id="using-miri-to-check-unsafe-code"><a class="header" href="#using-miri-to-check-unsafe-code">Using Miri to Check Unsafe Code</a></h3>
<p>When writing unsafe code, you might want to check that what you have written actually is safe and correct. One of the best ways to do that is to use Miri, an official Rust tool for detecting undefined behavior. Whereas the borrow checker is a <em>static</em> tool that works at compile time, Miri is a <em>dynamic</em> tool that works at runtime. It checks your code by running your program, or its test suite, and detecting when you violate the rules it understands about how Rust should work.</p>
<p>Using Miri requires a nightly build of Rust (which we talk about more in <a href="appendix-07-nightly-rust.html">Appendix G: How Rust is Made and “Nightly Rust”</a><!-- ignore -->). You can install both a nightly version of Rust and the Miri tool by typing <code>rustup +nightly component add miri</code>. This does not change what version of Rust your project uses; it only adds the tool to your system so you can use it when you want to. You can run Miri on a project by typing <code>cargo +nightly miri run</code> or <code>cargo +nightly miri test</code>.</p>
<p>For an example of how helpful this can be, consider what happens when we run it against Listing 20-7.</p>
<pre><code class="language-console">$ cargo +nightly miri run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.01s
     Running `file:///home/.rustup/toolchains/nightly/bin/cargo-miri runner target/miri/debug/unsafe-example`
warning: integer-to-pointer cast
 --&gt; src/main.rs:5:13
  |
5 |     let r = address as *mut i32;
  |             ^^^^^^^^^^^^^^^^^^^ integer-to-pointer cast
  |
  = help: this program is using integer-to-pointer casts or (equivalently) `ptr::with_exposed_provenance`, which means that Miri might miss pointer bugs in this program
  = help: see https://doc.rust-lang.org/nightly/std/ptr/fn.with_exposed_provenance.html for more details on that operation
  = help: to ensure that Miri does not miss bugs in your program, use Strict Provenance APIs (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance, https://crates.io/crates/sptr) instead
  = help: you can then set `MIRIFLAGS=-Zmiri-strict-provenance` to ensure you are not relying on `with_exposed_provenance` semantics
  = help: alternatively, `MIRIFLAGS=-Zmiri-permissive-provenance` disables this warning
  = note: BACKTRACE:
  = note: inside `main` at src/main.rs:5:13: 5:32

error: Undefined Behavior: pointer not dereferenceable: pointer must be dereferenceable for 40000 bytes, but got 0x1234[noalloc] which is a dangling pointer (it has no provenance)
 --&gt; src/main.rs:7:35
  |
7 |     let values: &amp;[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Undefined Behavior occurred here
  |
  = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior
  = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information
  = note: BACKTRACE:
  = note: inside `main` at src/main.rs:7:35: 7:70

note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace

error: aborting due to 1 previous error; 1 warning emitted

</code></pre>
<p>Miri correctly warns us that we’re casting an integer to a pointer, which might be a problem, but Miri can’t determine whether a problem exists because it doesn’t know how the pointer originated. Then, Miri returns an error where Listing 20-7 has undefined behavior because we have a dangling pointer. Thanks to Miri, we now know there is a risk of undefined behavior, and we can think about how to make the code safe. In some cases, Miri can even make recommendations about how to fix errors.</p>
<p>Miri doesn’t catch everything you might get wrong when writing unsafe code. Miri is a dynamic analysis tool, so it only catches problems with code that actually gets run. That means you will need to use it in conjunction with good testing techniques to increase your confidence about the unsafe code you have written. Miri also does not cover every possible way your code can be unsound.</p>
<p>Put another way: If Miri <em>does</em> catch a problem, you know there’s a bug, but just because Miri <em>doesn’t</em> catch a bug doesn’t mean there isn’t a problem. It can catch a lot, though. Try running it on the other examples of unsafe code in this chapter and see what it says!</p>
<p>You can learn more about Miri at <a href="https://github.com/rust-lang/miri">its GitHub repository</a>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="when-to-use-unsafe-code"></a></p>
<h3 id="using-unsafe-code-correctly"><a class="header" href="#using-unsafe-code-correctly">Using Unsafe Code Correctly</a></h3>
<p>Using <code>unsafe</code> to use one of the five superpowers just discussed isn’t wrong or even frowned upon, but it is trickier to get <code>unsafe</code> code correct because the compiler can’t help uphold memory safety. When you have a reason to use <code>unsafe</code> code, you can do so, and having the explicit <code>unsafe</code> annotation makes it easier to track down the source of problems when they occur. Whenever you write unsafe code, you can use Miri to help you be more confident that the code you have written upholds Rust’s rules.</p>
<p>For a much deeper exploration of how to work effectively with unsafe Rust, read Rust’s official guide for <code>unsafe</code>, <a href="https://doc.rust-lang.org/nomicon/">The Rustonomicon</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch20-00-advanced-features.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch20-02-advanced-traits.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch20-00-advanced-features.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch20-02-advanced-traits.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
