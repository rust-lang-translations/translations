<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>소유권이란 무엇인가? - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch04-01-what-is-ownership.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch04-01-what-is-ownership.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="소유권이란-무엇인가"><a class="header" href="#소유권이란-무엇인가">소유권이란 무엇인가?</a></h2>
<p>_소유권_은 러스트 프로그램이 메모리를 관리하는 방법을 규정하는 규칙 집합입니다. 모든 프로그램은 실행 중에 컴퓨터의 메모리 사용 방식을 관리해야 합니다. 일부 언어에는 프로그램이 실행되는 동안 더 이상 사용되지 않는 메모리를 정기적으로 찾는 가비지 컬렉션이 있습니다. 다른 언어에서는 프로그래머가 메모리를 명시적으로 할당하고 해제해야 합니다. 러스트는 세 번째 접근 방식을 사용합니다. 메모리는 컴파일러가 확인하는 일련의 규칙을 가진 소유권 시스템을 통해 관리됩니다. 규칙 중 하나라도 위반되면 프로그램은 컴파일되지 않습니다. 소유권의 어떤 기능도 프로그램 실행 속도를 늦추지 않습니다.</p>
<p>소유권은 많은 프로그래머에게 새로운 개념이므로 익숙해지는 데 시간이 걸립니다. 좋은 소식은 러스트와 소유권 시스템 규칙에 더 익숙해질수록 안전하고 효율적인 코드를 자연스럽게 개발하는 것이 더 쉬워진다는 것입니다. 계속 노력하세요!</p>
<p>소유권을 이해하면 러스트를 독특하게 만드는 기능을 이해하는 데 견고한 기반을 갖게 될 것입니다. 이 장에서는 매우 일반적인 데이터 구조인 문자열에 초점을 맞춘 몇 가지 예제를 통해 소유권을 배울 것입니다.</p>
<blockquote>
<h3 id="스택과-힙"><a class="header" href="#스택과-힙">스택과 힙</a></h3>
<p>많은 프로그래밍 언어는 스택과 힙에 대해 자주 생각할 필요가 없습니다. 하지만 러스트와 같은 시스템 프로그래밍 언어에서는 값이 스택에 있는지 힙에 있는지가 언어의 동작 방식과 특정 결정을 내려야 하는 이유에 영향을 미칩니다. 소유권의 일부는 이 장의 뒷부분에서 스택과 힙과 관련하여 설명될 것이므로, 여기서는 준비를 위한 간략한 설명을 제공합니다.</p>
<p>스택과 힙은 모두 런타임에 코드가 사용할 수 있는 메모리 영역이지만, 서로 다른 방식으로 구성됩니다. 스택은 값을 가져온 순서대로 저장하고 반대 순서로 값을 제거합니다. 이를 _후입선출_이라고 합니다. 접시 더미를 생각해 보세요. 접시를 더 추가할 때는 더미 위에 놓고, 접시가 필요할 때는 맨 위에서 하나를 가져갑니다. 중간이나 아래에서 접시를 추가하거나 제거하는 것은 잘 작동하지 않을 것입니다! 데이터를 추가하는 것을 _스택에 푸시_라고 하고, 데이터를 제거하는 것을 _스택에서 팝_이라고 합니다. 스택에 저장되는 모든 데이터는 알려진 고정된 크기를 가져야 합니다. 컴파일 시점에 크기를 알 수 없거나 크기가 변경될 수 있는 데이터는 대신 힙에 저장되어야 합니다.</p>
<p>힙은 덜 조직적입니다. 힙에 데이터를 넣을 때, 특정 양의 공간을 요청합니다. 메모리 할당자는 힙에서 충분히 큰 빈 공간을 찾아 사용 중으로 표시하고, 해당 위치의 주소인 _포인터_를 반환합니다. 이 과정을 _힙에 할당_이라고 하며 때로는 단순히 _할당_이라고 줄여 말합니다(값을 스택에 푸시하는 것은 할당으로 간주되지 않습니다). 힙에 대한 포인터는 알려진 고정 크기이므로 포인터를 스택에 저장할 수 있지만, 실제 데이터를 원할 때는 포인터를 따라가야 합니다. 식당에 앉아 있는 것을 생각해 보세요. 입장할 때 그룹 인원수를 말하면, 호스트가 모두에게 맞는 빈 테이블을 찾아 안내합니다. 그룹의 누군가가 늦게 오면, 당신이 어디에 앉아 있는지 물어 찾아올 수 있습니다.</p>
<p>스택에 푸시하는 것이 힙에 할당하는 것보다 빠릅니다. 할당자가 새 데이터를 저장할 공간을 검색할 필요가 없기 때문입니다. 해당 위치는 항상 스택의 맨 위에 있습니다. 비교적으로 힙에 공간을 할당하는 것은 더 많은 작업을 필요로 합니다. 할당자가 먼저 데이터를 담을 충분히 큰 공간을 찾은 다음 다음 할당을 준비하기 위해 장부 정리를 수행해야 하기 때문입니다.</p>
<p>힙의 데이터에 접근하는 것은 스택의 데이터에 접근하는 것보다 느립니다. 포인터를 따라가야 하기 때문입니다. 현대 프로세서는 메모리에서 덜 이동할수록 더 빠릅니다. 비유를 계속하자면, 식당에서 여러 테이블의 주문을 받는 서버를 생각해 보세요. 다음 테이블로 이동하기 전에 한 테이블의 모든 주문을 받는 것이 가장 효율적입니다. 테이블 A에서 주문을 받고, 테이블 B에서 주문을 받고, 다시 A에서 하나, 다시 B에서 하나를 받는 것은 훨씬 느린 과정일 것입니다. 마찬가지로 프로세서는 다른 데이터와 가까운 데이터(스택에 있는 것처럼)에서 작업할 때 더 멀리 떨어진 데이터(힙에 있을 수 있는 것처럼)에서 작업할 때보다 작업을 더 잘 수행할 수 있습니다.</p>
<p>코드가 함수를 호출하면 함수에 전달된 값(잠재적으로 힙의 데이터에 대한 포인터 포함)과 함수의 지역 변수가 스택에 푸시됩니다. 함수가 끝나면 해당 값은 스택에서 팝됩니다.</p>
<p>코드의 어떤 부분이 힙의 어떤 데이터를 사용하고 있는지 추적하고, 힙의 중복 데이터 양을 최소화하며, 공간 부족을 방지하기 위해 힙의 사용되지 않는 데이터를 정리하는 것은 모두 소유권이 다루는 문제입니다. 소유권을 이해하면 스택과 힙에 대해 자주 생각할 필요가 없지만, 소유권의 주요 목적이 힙 데이터를 관리하는 것임을 알면 소유권이 작동하는 방식을 설명하는 데 도움이 될 수 있습니다.</p>
</blockquote>
<h3 id="소유권-규칙"><a class="header" href="#소유권-규칙">소유권 규칙</a></h3>
<p>먼저 소유권 규칙을 살펴보겠습니다. 다음 예제를 통해 설명할 때 이 규칙들을 염두에 두세요.</p>
<ul>
<li>러스트의 모든 값에는 _소유자_가 있습니다.</li>
<li>한 번에 하나의 소유자만 있을 수 있습니다.</li>
<li>소유자가 스코프를 벗어나면 값은 드롭됩니다.</li>
</ul>
<h3 id="변수-스코프"><a class="header" href="#변수-스코프">변수 스코프</a></h3>
<p>이제 기본적인 러스트 구문을 넘어섰으므로, 예제에 모든 <code>fn main() {</code> 코드를 포함하지 않을 것입니다. 따라서 따라하고 있다면, 다음 예제들을 수동으로 <code>main</code> 함수 안에 넣으세요. 결과적으로, 우리의 예제는 상용구 코드보다는 실제 세부 사항에 집중할 수 있도록 좀 더 간결해질 것입니다.</p>
<p>소유권의 첫 번째 예시로, 일부 변수의 _스코프_를 살펴보겠습니다. 스코프는 프로그램 내에서 항목이 유효한 범위입니다. 다음 변수를 예로 들어 보겠습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = "hello";
<span class="boring">}</span></code></pre></pre>
<p>변수 <code>s</code>는 문자열 리터럴을 참조하며, 문자열의 값은 프로그램 텍스트에 하드코딩됩니다. 변수는 선언된 시점부터 현재 _스코프_가 끝날 때까지 유효합니다. 목록 4-1은 변수 <code>s</code>가 유효한 위치를 주석으로 표시한 프로그램을 보여줍니다.</p>
<Listing number="4-1" caption="A variable and the scope in which it is valid">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    {                      // s is not valid here, it’s not yet declared
        let s = "hello";   // s는 이 시점부터 유효합니다.

        // s로 작업 수행
    }                      // 이 스코프는 이제 끝났고, s는 더 이상 유효하지 않습니다.
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>다시 말해, 여기에는 두 가지 중요한 시점이 있습니다.</p>
<ul>
<li><code>s</code>가 스코프 <em>안으로</em> 들어오면 유효합니다.</li>
<li>스코프 <em>밖으로</em> 나갈 때까지 유효합니다.</li>
</ul>
<p>이 시점에서 스코프와 변수가 유효한 시점 간의 관계는 다른 프로그래밍 언어와 유사합니다. 이제 이 이해를 바탕으로 <code>String</code> 타입을 소개하겠습니다.</p>
<h3 id="string-타입"><a class="header" href="#string-타입"><code>String</code> 타입</a></h3>
<p>소유권 규칙을 설명하기 위해 3장의 <a href="ch03-02-data-types.html#data-types">“데이터 타입”</a><!-- ignore --> 섹션에서 다룬 것보다 더 복잡한 데이터 타입이 필요합니다. 이전에 다룬 타입들은 알려진 크기를 가지며, 스택에 저장되고 스코프가 끝나면 스택에서 팝될 수 있으며, 코드의 다른 부분이 다른 스코프에서 동일한 값을 사용해야 하는 경우 새롭고 독립적인 인스턴스를 만들기 위해 빠르고 간단하게 복사될 수 있습니다. 그러나 우리는 힙에 저장된 데이터를 살펴보고 러스트가 언제 해당 데이터를 정리해야 하는지 어떻게 아는지 탐구하고 싶으며, <code>String</code> 타입은 좋은 예시입니다.</p>
<p><code>String</code>의 소유권과 관련된 부분에 집중할 것입니다. 이러한 측면은 표준 라이브러리에서 제공되거나 직접 생성한 다른 복잡한 데이터 타입에도 적용됩니다. <code>String</code>에 대해서는 <a href="ch08-02-strings.html">8장</a><!-- ignore -->에서 더 자세히 논의할 것입니다.</p>
<p>우리는 이미 문자열 리터럴을 보았습니다. 문자열 값은 프로그램에 하드코딩됩니다. 문자열 리터럴은 편리하지만, 텍스트를 사용하려는 모든 상황에 적합하지는 않습니다. 한 가지 이유는 불변이기 때문입니다. 또 다른 이유는 모든 문자열 값을 코드를 작성할 때 알 수 없기 때문입니다. 예를 들어 사용자 입력을 받아 저장하고 싶다면 어떻게 해야 할까요? 이러한 상황을 위해 러스트에는 두 번째 문자열 타입인 <code>String</code>이 있습니다. 이 타입은 힙에 할당된 데이터를 관리하며, 따라서 컴파일 시점에 알 수 없는 양의 텍스트를 저장할 수 있습니다. <code>from</code> 함수를 사용하여 문자열 리터럴에서 <code>String</code>을 만들 수 있습니다. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");
<span class="boring">}</span></code></pre></pre>
<p>이중 콜론 <code>::</code> 연산자를 사용하면 <code>string_from</code>과 같은 이름을 사용하는 대신 <code>String</code> 타입 아래에 이 특정 <code>from</code> 함수를 네임스페이스화할 수 있습니다. 이 구문에 대해서는 5장의 <a href="ch05-03-method-syntax.html#method-syntax">“메서드 구문”</a><!-- ignore --> 섹션과 7장의 <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“모듈 트리에서 항목을 참조하는 경로”</a><!-- ignore -->에서 모듈을 사용한 네임스페이스화에 대해 이야기할 때 더 자세히 논의할 것입니다.</p>
<p>이러한 종류의 문자열은 <em>변경될 수 있습니다</em>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");

    s.push_str(", world!"); // push_str() appends a literal to a String

    println!("{s}"); // This will print `hello, world!`
<span class="boring">}</span></code></pre></pre>
<p>그렇다면 여기서 차이점은 무엇일까요? 왜 <code>String</code>은 변경될 수 있지만 리터럴은 변경될 수 없을까요? 차이점은 이 두 타입이 메모리를 다루는 방식에 있습니다.</p>
<h3 id="메모리-및-할당"><a class="header" href="#메모리-및-할당">메모리 및 할당</a></h3>
<p>문자열 리터럴의 경우, 컴파일 시점에 내용을 알 수 있으므로 텍스트가 최종 실행 파일에 직접 하드코딩됩니다. 이것이 문자열 리터럴이 빠르고 효율적인 이유입니다. 하지만 이러한 속성은 문자열 리터럴의 불변성에서만 비롯됩니다. 불행히도, 컴파일 시점에 크기를 알 수 없고 프로그램 실행 중에 크기가 변경될 수 있는 각 텍스트 조각에 대해 메모리 블롭을 바이너리에 넣을 수는 없습니다.</p>
<p><code>String</code> 타입을 사용하면 변경 가능하고 확장 가능한 텍스트 조각을 지원하기 위해 컴파일 시점에 알 수 없는 양의 메모리를 힙에 할당하여 내용을 저장해야 합니다. 이는 다음을 의미합니다.</p>
<ul>
<li>메모리는 런타임에 메모리 할당자에게 요청되어야 합니다.</li>
<li><code>String</code> 사용을 마쳤을 때 이 메모리를 할당자에게 반환하는 방법이 필요합니다.</li>
</ul>
<p>첫 번째 부분은 우리가 수행합니다. <code>String::from</code>을 호출하면 해당 구현이 필요한 메모리를 요청합니다. 이는 프로그래밍 언어에서 거의 보편적입니다.</p>
<p>그러나 두 번째 부분은 다릅니다. _가비지 컬렉터(GC)_가 있는 언어에서는 GC가 더 이상 사용되지 않는 메모리를 추적하고 정리하므로 우리는 이에 대해 생각할 필요가 없습니다. GC가 없는 대부분의 언어에서는 메모리가 더 이상 사용되지 않을 때를 식별하고 요청했던 것처럼 명시적으로 해제하는 코드를 호출하는 것이 우리의 책임입니다. 이를 올바르게 수행하는 것은 역사적으로 어려운 프로그래밍 문제였습니다. 잊어버리면 메모리를 낭비하게 됩니다. 너무 일찍 해제하면 유효하지 않은 변수를 갖게 됩니다. 두 번 해제하면 그것도 버그입니다. 정확히 하나의 <code>allocate</code>와 정확히 하나의 <code>free</code>를 짝지어야 합니다.</p>
<p>러스트는 다른 경로를 택합니다. 메모리는 소유한 변수가 스코프를 벗어나면 자동으로 반환됩니다. 다음은 문자열 리터럴 대신 <code>String</code>을 사용한 목록 4-1의 스코프 예제 버전입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    {
        let s = String::from("hello"); // s는 이 시점부터 유효합니다.

        // s로 작업 수행
    }                                  // 이 스코프는 이제 끝났고, s는 더 이상 유효하지 않습니다.
<span class="boring">}</span></code></pre></pre>
<p><code>String</code>이 필요로 하는 메모리를 할당자에게 반환할 수 있는 자연스러운 시점이 있습니다. 바로 <code>s</code>가 스코프를 벗어날 때입니다. 변수가 스코프를 벗어나면 러스트는 우리를 위해 특별한 함수를 호출합니다. 이 함수는 <a href="../std/ops/trait.Drop.html#tymethod.drop"><code>drop</code></a><!-- ignore -->이라고 불리며, <code>String</code>의 작성자가 메모리를 반환하는 코드를 넣을 수 있는 곳입니다. 러스트는 닫는 중괄호에서 <code>drop</code>을 자동으로 호출합니다.</p>
<blockquote>
<p>참고: C++에서는 항목의 수명 끝에 리소스를 할당 해제하는 이 패턴을 때때로 _자원 획득은 초기화(RAII)_라고 부릅니다. RAII 패턴을 사용해 본 적이 있다면 러스트의 <code>drop</code> 함수가 익숙할 것입니다.</p>
</blockquote>
<p>이 패턴은 러스트 코드가 작성되는 방식에 지대한 영향을 미칩니다. 지금은 간단해 보일 수 있지만, 여러 변수가 힙에 할당한 데이터를 사용하려고 할 때 더 복잡한 상황에서는 코드의 동작이 예상치 못할 수 있습니다. 이제 그러한 상황 중 일부를 살펴보겠습니다.</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="ways-variables-and-data-interact-move"></a></p>
<h4 id="이동과-상호작용하는-변수와-데이터"><a class="header" href="#이동과-상호작용하는-변수와-데이터">이동과 상호작용하는 변수와 데이터</a></h4>
<p>러스트에서는 여러 변수가 동일한 데이터와 다른 방식으로 상호 작용할 수 있습니다. 목록 4-2의 정수를 사용한 예제를 살펴보겠습니다.</p>
<Listing number="4-2" caption="Assigning the integer value of variable `x` to `y`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>이것이 무엇을 하는지 짐작할 수 있습니다. “값 <code>5</code>를 <code>x</code>에 바인딩한 다음, <code>x</code>의 값을 복사하여 <code>y</code>에 바인딩합니다.” 이제 <code>x</code>와 <code>y</code> 두 개의 변수가 있고, 둘 다 <code>5</code>와 같습니다. 정수는 알려진 고정 크기를 가진 단순한 값이므로 실제로 이런 일이 발생하며, 이 두 <code>5</code> 값은 스택에 푸시됩니다.</p>
<p>이제 <code>String</code> 버전을 살펴보겠습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");
    let s2 = s1;
<span class="boring">}</span></code></pre></pre>
<p>이것은 매우 유사해 보이므로, 작동 방식도 같을 것이라고 가정할 수 있습니다. 즉, 두 번째 줄은 <code>s1</code>의 값을 복사하여 <code>s2</code>에 바인딩할 것입니다. 하지만 실제로는 그렇지 않습니다.</p>
<p>그림 4-1을 보면 <code>String</code>이 내부적으로 어떻게 작동하는지 알 수 있습니다. <code>String</code>은 왼쪽에 표시된 세 부분으로 구성됩니다. 문자열 내용을 담는 메모리에 대한 포인터, 길이, 용량입니다. 이 데이터 그룹은 스택에 저장됩니다. 오른쪽에는 내용을 담는 힙의 메모리가 있습니다.</p>
<p><img alt="Two tables: the first table contains the representation of s1 on the
stack, consisting of its length (5), capacity (5), and a pointer to the first
value in the second table. The second table contains the representation of the
string data on the heap, byte by byte." src="img/trpl04-01.svg" class="center"
style="width: 50%;" /></p>
<p><span class="caption">그림 4-1: <code>s1</code>에 바인딩된 값 <code>"hello"</code>를 가진 <code>String</code>의 메모리 표현</span></p>
<p>길이는 <code>String</code>의 내용이 현재 사용하고 있는 메모리 양(바이트 단위)입니다. 용량은 <code>String</code>이 할당자로부터 받은 총 메모리 양(바이트 단위)입니다. 길이와 용량의 차이는 중요하지만, 이 컨텍스트에서는 그렇지 않으므로 지금은 용량을 무시해도 됩니다.</p>
<p><code>s1</code>을 <code>s2</code>에 할당할 때 <code>String</code> 데이터가 복사됩니다. 즉, 스택에 있는 포인터, 길이, 용량이 복사됩니다. 포인터가 참조하는 힙의 데이터는 복사되지 않습니다. 다시 말해, 메모리의 데이터 표현은 그림 4-2와 같습니다.</p>
<p><img alt="세 개의 테이블: 각각 스택에 있는 해당 문자열을 나타내는 s1 및 s2 테이블이며, 둘 다 힙의 동일한 문자열 데이터를 가리킵니다."
src="img/trpl04-02.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">그림 4-2: <code>s1</code>의 포인터, 길이, 용량의 복사본을 가진 변수 <code>s2</code>의 메모리 표현</span></p>
<p>표현은 그림 4-3과 같지 <em>않습니다</em>. 만약 러스트가 힙 데이터도 복사했다면 메모리는 그림 4-3과 같았을 것입니다. 만약 러스트가 이렇게 했다면, 힙의 데이터가 클 경우 <code>s2 = s1</code> 연산은 런타임 성능 측면에서 매우 비쌀 수 있습니다.</p>
<p><img alt="네 개의 테이블: s1 및 s2에 대한 스택 데이터를 나타내는 두 개의 테이블이며, 각각은 힙에 있는 자체 문자열 데이터 복사본을 가리킵니다."
src="img/trpl04-03.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">그림 4-3: 러스트가 힙 데이터도 복사했다면 <code>s2 = s1</code>이 수행할 수 있는 또 다른 가능성</span></p>
<p>앞서 변수가 스코프를 벗어나면 러스트가 자동으로 <code>drop</code> 함수를 호출하여 해당 변수의 힙 메모리를 정리한다고 말했습니다. 하지만 그림 4-2는 두 데이터 포인터가 모두 동일한 위치를 가리키고 있음을 보여줍니다. 이것은 문제입니다. <code>s2</code>와 <code>s1</code>이 스코프를 벗어나면 둘 다 동일한 메모리를 해제하려고 시도할 것입니다. 이것은 <em>이중 해제</em> 오류로 알려져 있으며 이전에 언급한 메모리 안전 버그 중 하나입니다. 메모리를 두 번 해제하면 메모리 손상으로 이어질 수 있으며, 이는 잠재적으로 보안 취약점으로 이어질 수 있습니다.</p>
<p>메모리 안전을 보장하기 위해 <code>let s2 = s1;</code> 줄 다음에 러스트는 <code>s1</code>을 더 이상 유효하지 않은 것으로 간주합니다. 따라서 <code>s1</code>이 스코프를 벗어날 때 러스트는 아무것도 해제할 필요가 없습니다. <code>s2</code>가 생성된 후 <code>s1</code>을 사용하려고 할 때 어떤 일이 발생하는지 확인해 보세요. 작동하지 않을 것입니다:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");
    let s2 = s1;

    println!("{s1}, 월드!");
<span class="boring">}</span></code></pre>
<p>러스트가 유효하지 않은 참조를 사용하는 것을 막기 때문에 다음과 같은 오류가 발생합니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --&gt; src/main.rs:5:15
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |
5 |     println!("{s1}, world!");
  |               ^^^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider cloning the value if the performance cost is acceptable
  |
3 |     let s2 = s1.clone();
  |                ++++++++

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>다른 언어로 작업하면서 _얕은 복사_와 _깊은 복사_라는 용어를 들어본 적이 있다면, 데이터를 복사하지 않고 포인터, 길이, 용량을 복사하는 개념은 얕은 복사를 만드는 것처럼 들릴 것입니다. 하지만 러스트는 첫 번째 변수도 무효화하기 때문에 얕은 복사라고 불리는 대신 _이동_으로 알려져 있습니다. 이 예에서는 <code>s1</code>이 <code>s2</code>로 _이동_되었다고 말할 것입니다. 따라서 실제로 일어나는 일은 그림 4-4에 나와 있습니다.</p>
<p><img alt="세 개의 테이블: 각각 스택에 있는 해당 문자열을 나타내는 s1 및 s2 테이블이며, 둘 다 힙의 동일한 문자열 데이터를 가리킵니다.
s1은 더 이상 유효하지 않기 때문에 회색으로 표시되며, s2만 힙 데이터에 접근하는 데 사용할 수 있습니다."
src="img/trpl04-04.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">그림 4-4: <code>s1</code>이 무효화된 후의 메모리 표현</span></p>
<p>문제가 해결되었습니다! <code>s2</code>만 유효하므로, 스코프를 벗어나면 <code>s2</code>만 메모리를 해제하고 작업이 완료됩니다.</p>
<p>또한, 이것이 암시하는 설계 선택이 있습니다: 러스트는 데이터의 "깊은" 복사본을 자동으로 생성하지 않습니다. 따라서 모든 <em>자동</em> 복사는 런타임 성능 측면에서 비용이 저렴하다고 가정할 수 있습니다.</p>
<h4 id="스코프와-할당"><a class="header" href="#스코프와-할당">스코프와 할당</a></h4>
<p>이것의 역도 스코핑, 소유권, 그리고 <code>drop</code> 함수를 통한 메모리 해제 사이의 관계에 해당합니다. 기존 변수에 완전히 새로운 값을 할당하면, 러스트는 <code>drop</code>을 호출하고 원래 값의 메모리를 즉시 해제합니다. 예를 들어, 이 코드를 고려해 보세요:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::from("hello");
    s = String::from("아호이");

    println!(" {s}, 세상아!");
<span class="boring">}</span></code></pre></pre>
<p>처음에 <code>s</code>라는 변수를 선언하고 <code>"hello"</code> 값을 가진 <code>String</code>에 바인딩합니다. 그런 다음 즉시 <code>"ahoy"</code> 값을 가진 새 <code>String</code>을 만들고 <code>s</code>에 할당합니다. 이 시점에서 힙의 원래 값을 참조하는 것은 아무것도 없습니다.</p>
<p><img alt="스택의 문자열 값을 나타내는 하나의 테이블 s는 힙의 두 번째 문자열 데이터(ahoy)를 가리키고 있으며, 원래 문자열 데이터(hello)는 더 이상 접근할 수 없으므로 회색으로 표시됩니다."
src="img/trpl04-05.svg"
class="center"
style="width: 50%;"
/></p>
<p><span class="caption">그림 4-5: 초기 값이 전체적으로 교체된 후의 메모리 표현.</span></p>
<p>The original string thus immediately goes out of scope. Rust will run the <code>drop</code> function on it and its memory will be freed right away. When we print the value at the end, it will be <code>"ahoy, world!"</code>.</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="ways-variables-and-data-interact-clone"></a></p>
<h4 id="variables-and-data-interacting-with-clone"><a class="header" href="#variables-and-data-interacting-with-clone">Variables and Data Interacting with Clone</a></h4>
<p>If we <em>do</em> want to deeply copy the heap data of the <code>String</code>, not just the stack data, we can use a common method called <code>clone</code>. We’ll discuss method syntax in Chapter 5, but because methods are a common feature in many programming languages, you’ve probably seen them before.</p>
<p>다음은 <code>clone</code> 메서드가 작동하는 예입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {s1}, s2 = {s2}");
<span class="boring">}</span></code></pre></pre>
<p>이것은 잘 작동하며 그림 4-3에 표시된 동작, 즉 힙 데이터가 <em>복사되는</em> 동작을 명시적으로 생성합니다.</p>
<p><code>clone</code> 호출을 보면 임의의 코드가 실행되고 있으며 해당 코드는 비용이 많이들 수 있다는 것을 알 수 있습니다. 이것은 뭔가 다른 일이 일어나고 있다는 시각적 표시입니다.</p>
<h4 id="스택-전용-데이터-복사"><a class="header" href="#스택-전용-데이터-복사">스택 전용 데이터: 복사</a></h4>
<p>아직 이야기하지 않은 또 다른 주름이 있습니다. 정수를 사용하는 이 코드(일부는 목록 4-2에 표시됨)는 작동하며 유효합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;

    println!("x = {x}, y = {y}");
<span class="boring">}</span></code></pre></pre>
<p>하지만 이 코드는 우리가 방금 배운 것과 모순되는 것 같습니다. <code>clone</code>을 호출하지 않았지만 <code>x</code>는 여전히 유효하며 <code>y</code>로 이동되지 않았습니다.</p>
<p>그 이유는 컴파일 타임에 알려진 크기를 가진 정수와 같은 타입은 전적으로 스택에 저장되므로 실제 값의 복사본을 빠르게 만들 수 있기 때문입니다. 즉, 변수 <code>y</code>를 만든 후 <code>x</code>가 유효하지 않도록 막을 이유가 없습니다. 다시 말해, 여기서는 깊은 복사와 얕은 복사 사이에 차이가 없으므로 <code>clone</code>을 호출해도 일반적인 얕은 복사와 다른 작업을 수행하지 않으며 생략할 수 있습니다.</p>
<p>러스트에는 정수와 같이 스택에 저장되는 타입에 배치할 수 있는 <code>Copy</code> 트레이트라는 특별한 어노테이션이 있습니다(트레이트에 대해서는 <a href="ch10-02-traits.html">10장</a><!-- 무시 -->에서 더 자세히 다룰 것입니다). 타입이 <code>Copy</code> 트레이트를 구현하면 해당 타입을 사용하는 변수는 이동되지 않고 간단하게 복사되어 다른 변수에 할당된 후에도 여전히 유효합니다.</p>
<p>타입 또는 그 일부가 <code>Drop</code> 트레이트를 구현한 경우 러스트는 해당 타입에 <code>Copy</code> 어노테이션을 추가하는 것을 허용하지 않습니다. 값이 스코프를 벗어날 때 특별한 일이 일어나야 하는 타입에 <code>Copy</code> 어노테이션을 추가하면 컴파일 타임 오류가 발생합니다. 타입에 <code>Copy</code> 어노테이션을 추가하여 트레이트를 구현하는 방법에 대해 알아보려면 부록 C의 <a href="appendix-03-derivable-traits.html">“파생 가능한 트레이트”</a><!-- 무시 -->를 참조하세요.</p>
<p>그렇다면 어떤 타입이 <code>Copy</code> 트레이트를 구현할까요? 확실히 하려면 해당 타입의 문서를 확인할 수 있지만, 일반적인 규칙으로 간단한 스칼라 값 그룹은 <code>Copy</code>를 구현할 수 있으며, 할당이 필요하거나 어떤 형태의 리소스인 것은 <code>Copy</code>를 구현할 수 없습니다. 다음은 <code>Copy</code>를 구현하는 몇 가지 타입입니다:</p>
<ul>
<li><code>u32</code>와 같은 모든 정수 타입.</li>
<li><code>true</code>와 <code>false</code> 값을 갖는 불리언 타입, <code>bool</code>.</li>
<li><code>f64</code>와 같은 모든 부동 소수점 타입.</li>
<li>문자 타입, <code>char</code>.</li>
<li>튜플, 만약 <code>Copy</code>를 구현하는 타입만 포함하는 경우. 예를 들어, <code>(i32, i32)</code>는 <code>Copy</code>를 구현하지만 <code>(i32, String)</code>은 그렇지 않습니다.</li>
</ul>
<h3 id="소유권과-함수"><a class="header" href="#소유권과-함수">소유권과 함수</a></h3>
<p>The mechanics of passing a value to a function are similar to those when assigning a value to a variable. Passing a variable to a function will move or copy, just as assignment does. Listing 4-3 has an example with some annotations showing where variables go into and out of scope.</p>
<Listing number="4-3" file-name="src/main.rs" caption="Functions with ownership and scope annotated">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let s = String::from("hello");  // s가 스코프 안으로 들어옵니다

    takes_ownership(s);             // s's value moves into the function...
                                    // ... and so is no longer valid here

    let x = 5;                      // x가 스코프 안으로 들어옵니다

    makes_copy(x);                  // i32는 Copy 트레이트를 구현하므로,
                                    // x는 함수로 이동하지 않습니다,
    println!("{}", x);              // 그래서 나중에 x를 사용해도 괜찮습니다

} // 여기서 x가 스코프를 벗어난 다음 s가 벗어납니다. 하지만 s의 값은 이동되었으므로,
  // 특별한 일은 일어나지 않습니다.

fn takes_ownership(some_string: String) { // some_string이 스코프 안으로 들어옵니다
    println!("{some_string}");
} // 여기서 some_string이 스코프를 벗어나고 `drop`이 호출됩니다. 배후의
  // 메모리가 해제됩니다.

fn makes_copy(some_integer: i32) { // some_integer가 스코프 안으로 들어옵니다
    println!("{some_integer}");
} // 여기서 some_integer가 스코프를 벗어납니다. 특별한 일은 일어나지 않습니다.</code></pre></pre>
</Listing>
<p><code>takes_ownership</code> 호출 후 <code>s</code>를 사용하려고 하면 러스트는 컴파일 타임 오류를 발생시킵니다. 이러한 정적 검사는 우리를 실수로부터 보호합니다. <code>main</code>에 <code>s</code>와 <code>x</code>를 사용하는 코드를 추가하여 어디서 사용할 수 있고 어디서 소유권 규칙이 사용을 방해하는지 확인해 보세요.</p>
<h3 id="반환-값과-스코프"><a class="header" href="#반환-값과-스코프">반환 값과 스코프</a></h3>
<p>값을 반환하는 것도 소유권을 이전할 수 있습니다. 목록 4-4는 목록 4-3과 유사한 주석이 있는, 어떤 값을 반환하는 함수의 예입니다.</p>
<Listing number="4-4" file-name="src/main.rs" caption="Transferring ownership of return values">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let s1 = gives_ownership();        // gives_ownership은 반환 값을
                                       // s1으로 이동시킵니다

    let s2 = String::from("hello");    // s2가 스코프 안으로 들어옵니다

    let s3 = takes_and_gives_back(s2); // s2 is moved into
                                       // takes_and_gives_back, which also
                                       // moves its return value into s3
} // 여기서 s3는 스코프를 벗어나 드롭됩니다. s2는 이동되었으므로 아무 일도 일어나지 않습니다. s1은 스코프를 벗어나 드롭됩니다.
fn gives_ownership() -&gt; String {       // gives_ownership will move its
                                       // return value into the function
                                       // that calls it

    let some_string = String::from("yours"); // some_string이 스코프 안으로 들어옵니다

    some_string                        // some_string이 반환되어 호출한
                                       // 함수로
                                       // 이동합니다
}

// 이 함수는 String을 가져와서 String을 반환합니다.
fn takes_and_gives_back(a_string: String) -&gt; String {
    // a_string이 스코프 안으로
    // 들어옵니다

    a_string  // a_string이 반환되어 호출한 함수로 이동합니다
}</code></pre></pre>
</Listing>
<p>변수의 소유권은 매번 동일한 패턴을 따릅니다: 다른 변수에 값을 할당하면 값이 이동합니다. 힙에 데이터를 포함하는 변수가 스코프를 벗어나면, 데이터의 소유권이 다른 변수로 이동하지 않는 한 <code>drop</code>에 의해 값이 정리됩니다.</p>
<p>이 방법이 작동하기는 하지만, 모든 함수에서 소유권을 가져갔다가 다시 반환하는 것은 조금 번거롭습니다. 함수가 소유권을 가져가지 않고 값을 사용하게 하려면 어떻게 해야 할까요? 다시 사용하고 싶을 때 전달한 모든 것을 다시 돌려받아야 한다는 점과, 함수 본문에서 발생한 반환하고 싶은 모든 데이터까지 돌려받아야 한다는 점은 꽤 짜증스러운 일입니다.</p>
<p>러스트는 목록 4-5에 표시된 것처럼 튜플을 사용하여 여러 값을 반환할 수 있게 해줍니다.</p>
<Listing number="4-5" file-name="src/main.rs" caption="Returning ownership of parameters">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("'{s2}'의 길이는 {len}입니다.");
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len()은 String의 길이를 반환합니다

    (s, length)
}</code></pre></pre>
</Listing>
<p>하지만 이는 너무 형식적이고 일반적이어야 할 개념에 대해 너무 많은 작업이 필요합니다. 다행히도 러스트에는 소유권을 이전하지 않고 값을 사용할 수 있는 _참조(references)_라는 기능이 있습니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch04-00-understanding-ownership.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch04-02-references-and-borrowing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch04-00-understanding-ownership.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch04-02-references-and-borrowing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
