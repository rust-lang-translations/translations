<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Result로 복구 가능한 에러 처리하기 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch09-02-recoverable-errors-with-result.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch09-02-recoverable-errors-with-result.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="result로-복구-가능한-에러-처리하기"><a class="header" href="#result로-복구-가능한-에러-처리하기"><code>Result</code>로 복구 가능한 에러 처리하기</a></h2>
<p>Most errors aren’t serious enough to require the program to stop entirely. Sometimes when a function fails, it’s for a reason that you can easily interpret and respond to. For example, if you try to open a file and that operation fails because the file doesn’t exist, you might want to create the file instead of terminating the process.</p>
<p>2장의 <a href="ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-result">“<code>Result</code>로 잠재적 실패 처리하기”</a><!-- ignore -->에서 <code>Result</code> 열거형이 다음과 같이 <code>Ok</code>와 <code>Err</code>라는 두 가지 변형을 갖는 것으로 정의되었던 것을 상기해보세요.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>T</code> and <code>E</code> are generic type parameters: We’ll discuss generics in more detail in Chapter 10. What you need to know right now is that <code>T</code> represents the type of the value that will be returned in a success case within the <code>Ok</code> variant, and <code>E</code> represents the type of the error that will be returned in a failure case within the <code>Err</code> variant. Because <code>Result</code> has these generic type parameters, we can use the <code>Result</code> type and the functions defined on it in many different situations where the success value and error value we want to return may differ.</p>
<p>Let’s call a function that returns a <code>Result</code> value because the function could fail. In Listing 9-3, we try to open a file.</p>
<Listing number="9-3" file-name="src/main.rs" caption="Opening a file">
<pre><pre class="playground"><code class="language-rust edition2024">use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");
}</code></pre></pre>
</Listing>
<p>The return type of <code>File::open</code> is a <code>Result&lt;T, E&gt;</code>. The generic parameter <code>T</code> has been filled in by the implementation of <code>File::open</code> with the type of the success value, <code>std::fs::File</code>, which is a file handle. The type of <code>E</code> used in the error value is <code>std::io::Error</code>. This return type means the call to <code>File::open</code> might succeed and return a file handle that we can read from or write to. The function call also might fail: For example, the file might not exist, or we might not have permission to access the file. The <code>File::open</code> function needs to have a way to tell us whether it succeeded or failed and at the same time give us either the file handle or error information. This information is exactly what the <code>Result</code> enum conveys.</p>
<p><code>File::open</code>이 성공하는 경우, <code>greeting_file_result</code> 변수의 값은 파일 핸들을 포함하는 <code>Ok</code> 인스턴스가 될 것입니다. 실패하는 경우, <code>greeting_file_result</code>의 값은 발생한 오류 종류에 대한 더 많은 정보를 포함하는 <code>Err</code> 인스턴스가 될 것입니다.</p>
<p>목록 9-3의 코드에 <code>File::open</code>이 반환하는 값에 따라 다른 동작을 취하도록 추가해야 합니다. 목록 9-4는 6장에서 논의했던 기본 도구인 <code>match</code> 표현식을 사용하여 <code>Result</code>를 처리하는 한 가지 방법을 보여줍니다.</p>
<Listing number="9-4" file-name="src/main.rs" caption="Using a `match` expression to handle the `Result` variants that might be returned">
<pre><pre class="playground"><code class="language-rust should_panic edition2024">use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; panic!("파일을 여는 중 문제 발생: {error:?}"),
    };
}</code></pre></pre>
</Listing>
<p><code>Option</code> 열거형과 마찬가지로 <code>Result</code> 열거형과 그 변형들은 프렐류드에 의해 스코프로 가져와지므로, <code>match</code> 갈래에서 <code>Ok</code>와 <code>Err</code> 변형 앞에 <code>Result::</code>를 지정할 필요가 없습니다.</p>
<p>결과가 <code>Ok</code>이면, 이 코드는 <code>Ok</code> 변형에서 내부 <code>file</code> 값을 반환하고, 그 파일 핸들 값을 <code>greeting_file</code> 변수에 할당합니다. <code>match</code> 이후에는 읽거나 쓰기 위해 파일 핸들을 사용할 수 있습니다.</p>
<p><code>match</code>의 다른 갈래는 <code>File::open</code>에서 <code>Err</code> 값을 받는 경우를 처리합니다. 이 예제에서는 <code>panic!</code> 매크로를 호출하기로 했습니다. 현재 디렉토리에 _hello.txt_라는 파일이 없고 이 코드를 실행하면, <code>panic!</code> 매크로에서 다음과 같은 출력을 보게 될 것입니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/error-handling`

thread 'main' panicked at src/main.rs:8:23:
Problem opening the file: Os { code: 2, kind: NotFound, message: "No such file or directory" }
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>여느 때와 같이, 이 출력은 무엇이 잘못되었는지 정확히 알려줍니다.</p>
<h3 id="다른-에러에-매칭하기"><a class="header" href="#다른-에러에-매칭하기">다른 에러에 매칭하기</a></h3>
<p>The code in Listing 9-4 will <code>panic!</code> no matter why <code>File::open</code> failed. However, we want to take different actions for different failure reasons. If <code>File::open</code> failed because the file doesn’t exist, we want to create the file and return the handle to the new file. If <code>File::open</code> failed for any other reason—for example, because we didn’t have permission to open the file—we still want the code to <code>panic!</code> in the same way it did in Listing 9-4. For this, we add an inner <code>match</code> expression, shown in Listing 9-5.</p>
<Listing number="9-5" file-name="src/main.rs" caption="Handling different kinds of errors in different ways">
<!-- ignore this test because otherwise it creates hello.txt which causes other
tests to fail lol -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; match error.kind() {
            ErrorKind::NotFound =&gt; match File::create("hello.txt") {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!("파일 생성 중 문제 발생: {e:?}"),
            },
            _ =&gt; {
                panic!("파일을 여는 중 문제 발생: {error:?}");
            }
        },
    };
}</code></pre>
</Listing>
<p>The type of the value that <code>File::open</code> returns inside the <code>Err</code> variant is <code>io::Error</code>, which is a struct provided by the standard library. This struct has a method, <code>kind</code>, that we can call to get an <code>io::ErrorKind</code> value. The enum <code>io::ErrorKind</code> is provided by the standard library and has variants representing the different kinds of errors that might result from an <code>io</code> operation. The variant we want to use is <code>ErrorKind::NotFound</code>, which indicates the file we’re trying to open doesn’t exist yet. So, we match on <code>greeting_file_result</code>, but we also have an inner match on <code>error.kind()</code>.</p>
<p>내부 매칭에서 확인하려는 조건은 <code>error.kind()</code>가 반환한 값이 <code>ErrorKind</code> 열거형의 <code>NotFound</code> 변형인지 여부입니다. 만약 그렇다면, <code>File::create</code>로 파일 생성을 시도합니다. 하지만 <code>File::create</code>도 실패할 수 있으므로, 내부 <code>match</code> 표현식에 두 번째 갈래가 필요합니다. 파일이 생성될 수 없을 때, 다른 에러 메시지가 출력됩니다. 외부 <code>match</code>의 두 번째 갈래는 동일하게 유지되므로, 프로그램은 파일 없음 에러 이외의 모든 에러에 대해 패닉을 일으킵니다.</p>
<blockquote>
<h4 id="resultt-e와-함께-match를-사용하는-것에-대한-대안"><a class="header" href="#resultt-e와-함께-match를-사용하는-것에-대한-대안"><code>Result&lt;T, E&gt;</code>와 함께 <code>match</code>를 사용하는 것에 대한 대안</a></h4>
<p><code>match</code>가 정말 많네요! <code>match</code> 표현식은 매우 유용하지만 매우 원시적이기도 합니다. 13장에서는 <code>Result&lt;T, E&gt;</code>에 정의된 많은 메서드와 함께 사용되는 클로저에 대해 배울 것입니다. 이러한 메서드들은 코드에서 <code>Result&lt;T, E&gt;</code> 값을 처리할 때 <code>match</code>를 사용하는 것보다 더 간결할 수 있습니다.</p>
<p>예를 들어, 목록 9-5에 표시된 것과 동일한 로직을 작성하는 또 다른 방법이 있습니다. 이번에는 클로저와 <code>unwrap_or_else</code> 메서드를 사용합니다:</p>
<!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("파일 생성 중 문제 발생: {error:?}");
            })
        } else {
            panic!("파일을 여는 중 문제 발생: {error:?}");
        }
    });
}</code></pre>
<p>Although this code has the same behavior as Listing 9-5, it doesn’t contain any <code>match</code> expressions and is cleaner to read. Come back to this example after you’ve read Chapter 13 and look up the <code>unwrap_or_else</code> method in the standard library documentation. Many more of these methods can clean up huge, nested <code>match</code> expressions when you’re dealing with errors.</p>
</blockquote>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="shortcuts-for-panic-on-error-unwrap-and-expect"></a></p>
<h4 id="shortcuts-for-panic-on-error"><a class="header" href="#shortcuts-for-panic-on-error">Shortcuts for Panic on Error</a></h4>
<p><code>match</code>를 사용하는 것은 충분히 잘 작동하지만, 다소 장황할 수 있고 항상 의도를 잘 전달하는 것은 아닙니다. <code>Result&lt;T, E&gt;</code> 타입에는 다양하고 더 구체적인 작업을 수행하기 위해 정의된 많은 도우미 메서드가 있습니다. <code>unwrap</code> 메서드는 우리가 목록 9-4에서 작성한 <code>match</code> 표현식과 똑같이 구현된 단축 메서드입니다. <code>Result</code> 값이 <code>Ok</code> 변형이면 <code>unwrap</code>은 <code>Ok</code> 내부의 값을 반환합니다. <code>Result</code>가 <code>Err</code> 변형이면 <code>unwrap</code>은 우리를 위해 <code>panic!</code> 매크로를 호출합니다. 다음은 작동 중인 <code>unwrap</code>의 예입니다:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust should_panic edition2024">use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap();
}</code></pre></pre>
</Listing>
<p><em>hello.txt</em> 파일 없이 이 코드를 실행하면, <code>unwrap</code> 메서드가 호출한 <code>panic!</code> 호출의 에러 메시지를 보게 될 것입니다:</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-04-unwrap
cargo run
copy and paste relevant text
-->
<pre><code class="language-text">thread 'main' panicked at src/main.rs:4:49:
called `Result::unwrap()` on an `Err` value: Os { code: 2, kind: NotFound, message: "No such file or directory" }
</code></pre>
<p>비슷하게, <code>expect</code> 메서드는 <code>panic!</code> 에러 메시지를 선택할 수 있게 해줍니다. <code>unwrap</code> 대신 <code>expect</code>를 사용하고 좋은 에러 메시지를 제공하면 의도를 전달하고 패닉의 원인을 추적하기가 더 쉬워집니다. <code>expect</code>의 문법은 다음과 같습니다:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust should_panic edition2024">use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")
        .expect("hello.txt는 이 프로젝트에 포함되어야 합니다");
}</code></pre></pre>
</Listing>
<p><code>expect</code>는 <code>unwrap</code>과 같은 방식으로 사용합니다. 즉, 파일 핸들을 반환하거나 <code>panic!</code> 매크로를 호출합니다. <code>expect</code>가 <code>panic!</code> 호출 시 사용하는 에러 메시지는 <code>unwrap</code>이 사용하는 기본 <code>panic!</code> 메시지 대신 <code>expect</code>에 전달하는 매개변수가 될 것입니다. 다음과 같이 보입니다:</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-05-expect
cargo run
copy and paste relevant text
-->
<pre><code class="language-text">thread 'main' panicked at src/main.rs:5:10:
hello.txt should be included in this project: Os { code: 2, kind: NotFound, message: "No such file or directory" }
</code></pre>
<p>프로덕션 품질의 코드에서 대부분의 러스트 사용자들은 <code>unwrap</code>보다는 <code>expect</code>를 선택하고, 왜 작업이 항상 성공할 것으로 예상되는지에 대한 더 많은 문맥을 제공합니다. 그렇게 하면 만약 가정이 틀렸음이 밝혀졌을 때, 디버깅에 사용할 수 있는 더 많은 정보를 갖게 됩니다.</p>
<h3 id="에러-전파하기"><a class="header" href="#에러-전파하기">에러 전파하기</a></h3>
<p>When a function’s implementation calls something that might fail, instead of handling the error within the function itself, you can return the error to the calling code so that it can decide what to do. This is known as <em>propagating</em> the error and gives more control to the calling code, where there might be more information or logic that dictates how the error should be handled than what you have available in the context of your code.</p>
<p>예를 들어, 목록 9-6은 파일에서 사용자 이름을 읽는 함수를 보여줍니다. 파일이 존재하지 않거나 읽을 수 없는 경우, 이 함수는 해당 에러를 함수를 호출한 코드에 반환합니다.</p>
<Listing number="9-6" file-name="src/main.rs" caption="A function that returns errors to the calling code using `match`">
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let username_file_result = File::open("hello.txt");

    let mut username_file = match username_file_result {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&amp;mut username) {
        Ok(_) =&gt; Ok(username),
        Err(e) =&gt; Err(e),
    }
}
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 함수는 훨씬 더 짧은 방식으로 작성될 수 있지만, 에러 처리를 탐구하기 위해 많은 부분을 수동으로 수행하는 것으로 시작할 것입니다; 마지막에는 더 짧은 방법을 보여줄 것입니다. 먼저 함수의 반환 타입을 살펴봅시다: <code>Result&lt;String, io::Error&gt;</code>. 이는 함수가 <code>Result&lt;T, E&gt;</code> 타입의 값을 반환하고 있음을 의미하며, 여기서 제네릭 매개변수 <code>T</code>는 구체적인 타입 <code>String</code>으로 채워졌고 제네릭 타입 <code>E</code>는 구체적인 타입 <code>io::Error</code>로 채워졌습니다.</p>
<p>이 함수가 아무 문제 없이 성공하면, 이 함수를 호출하는 코드는 <code>Ok</code> 값을 받게 되는데, 여기에는 이 함수가 파일에서 읽은 <code>username</code>인 <code>String</code>이 들어 있습니다. 이 함수가 문제를 겪게 되면, 호출하는 코드는 <code>Err</code> 값을 받게 되는데, 여기에는 문제가 무엇이었는지에 대한 더 많은 정보를 담고 있는 <code>io::Error</code>의 인스턴스가 들어 있습니다. 우리는 이 함수의 반환 타입으로 <code>io::Error</code>를 선택했는데, 왜냐하면 이 함수 본문에서 호출하는 실패할 수 있는 두 작업, 즉 <code>File::open</code> 함수와 <code>read_to_string</code> 메서드 모두에서 반환되는 에러 값의 타입이 바로 그것이기 때문입니다.</p>
<p>The body of the function starts by calling the <code>File::open</code> function. Then, we handle the <code>Result</code> value with a <code>match</code> similar to the <code>match</code> in Listing 9-4. If <code>File::open</code> succeeds, the file handle in the pattern variable <code>file</code> becomes the value in the mutable variable <code>username_file</code> and the function continues. In the <code>Err</code> case, instead of calling <code>panic!</code>, we use the <code>return</code> keyword to return early out of the function entirely and pass the error value from <code>File::open</code>, now in the pattern variable <code>e</code>, back to the calling code as this function’s error value.</p>
<p>So, if we have a file handle in <code>username_file</code>, the function then creates a new <code>String</code> in variable <code>username</code> and calls the <code>read_to_string</code> method on the file handle in <code>username_file</code> to read the contents of the file into <code>username</code>. The <code>read_to_string</code> method also returns a <code>Result</code> because it might fail, even though <code>File::open</code> succeeded. So, we need another <code>match</code> to handle that <code>Result</code>: If <code>read_to_string</code> succeeds, then our function has succeeded, and we return the username from the file that’s now in <code>username</code> wrapped in an <code>Ok</code>. If <code>read_to_string</code> fails, we return the error value in the same way that we returned the error value in the <code>match</code> that handled the return value of <code>File::open</code>. However, we don’t need to explicitly say <code>return</code>, because this is the last expression in the function.</p>
<p>이 코드를 호출하는 코드는 사용자 이름을 포함하는 <code>Ok</code> 값이나 <code>io::Error</code>를 포함하는 <code>Err</code> 값 중 하나를 받아서 처리하게 됩니다. 이 값들로 무엇을 할지는 호출하는 코드가 결정합니다. 호출하는 코드가 <code>Err</code> 값을 받으면 <code>panic!</code>을 호출하여 프로그램을 중단시키거나, 기본 사용자 이름을 사용하거나, 파일이 아닌 다른 곳에서 사용자 이름을 조회하는 등의 작업을 할 수 있습니다. 호출하는 코드가 실제로 무엇을 하려는지에 대한 정보가 충분하지 않으므로, 우리는 모든 성공 또는 에러 정보를 위로 전파하여 적절하게 처리하도록 합니다.</p>
<p>에러를 전파하는 이 패턴은 러스트에서 매우 흔하므로, 러스트는 이를 더 쉽게 만들기 위해 물음표 연산자 <code>?</code>를 제공합니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="a-shortcut-for-propagating-errors-the--operator"></a></p>
<h4 id="the--operator-shortcut"><a class="header" href="#the--operator-shortcut">The <code>?</code> Operator Shortcut</a></h4>
<p>목록 9-7은 목록 9-6과 동일한 기능을 가지지만 <code>?</code> 연산자를 사용하는 <code>read_username_from_file</code>의 구현을 보여줍니다.</p>
<Listing number="9-7" file-name="src/main.rs" caption="A function that returns errors to the calling code using the `?` operator">
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username_file = File::open("hello.txt")?;
    let mut username = String::new();
    username_file.read_to_string(&amp;mut username)?;
    Ok(username)
}
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>The <code>?</code> placed after a <code>Result</code> value is defined to work in almost the same way as the <code>match</code> expressions that we defined to handle the <code>Result</code> values in Listing 9-6. If the value of the <code>Result</code> is an <code>Ok</code>, the value inside the <code>Ok</code> will get returned from this expression, and the program will continue. If the value is an <code>Err</code>, the <code>Err</code> will be returned from the whole function as if we had used the <code>return</code> keyword so that the error value gets propagated to the calling code.</p>
<p>There is a difference between what the <code>match</code> expression from Listing 9-6 does and what the <code>?</code> operator does: Error values that have the <code>?</code> operator called on them go through the <code>from</code> function, defined in the <code>From</code> trait in the standard library, which is used to convert values from one type into another. When the <code>?</code> operator calls the <code>from</code> function, the error type received is converted into the error type defined in the return type of the current function. This is useful when a function returns one error type to represent all the ways a function might fail, even if parts might fail for many different reasons.</p>
<p>예를 들어, 목록 9-7의 <code>read_username_from_file</code> 함수를 변경하여 우리가 정의한 <code>OurError</code>라는 사용자 정의 에러 타입을 반환하게 할 수 있습니다. 만약 <code>io::Error</code>로부터 <code>OurError</code>의 인스턴스를 생성하는 <code>impl From&lt;io::Error&gt; for OurError</code>도 정의한다면, <code>read_username_from_file</code> 본문의 <code>?</code> 연산자 호출은 <code>from</code>을 호출하여 함수에 더 이상 코드를 추가할 필요 없이 에러 타입을 변환할 것입니다.</p>
<p>목록 9-7의 문맥에서 <code>File::open</code> 호출 끝에 있는 <code>?</code>는 <code>Ok</code> 내부의 값을 <code>username_file</code> 변수에 반환할 것입니다. 에러가 발생하면 <code>?</code> 연산자는 전체 함수에서 일찍 반환하고 호출하는 코드에 <code>Err</code> 값을 줄 것입니다. <code>read_to_string</code> 호출 끝에 있는 <code>?</code>에도 동일한 내용이 적용됩니다.</p>
<p><code>?</code> 연산자는 많은 상용구(boilerplate)를 제거하고 이 함수의 구현을 더 간단하게 만듭니다. 목록 9-8에 나와 있듯이 <code>?</code> 바로 뒤에 메서드 호출을 연결하여 이 코드를 더 줄일 수도 있습니다.</p>
<Listing number="9-8" file-name="src/main.rs" caption="Chaining method calls after the `?` operator">
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username = String::new();

    File::open("hello.txt")?.read_to_string(&amp;mut username)?;

    Ok(username)
}
<span class="boring">}</span></code></pre></pre>
</Listing>
<p><code>File::open("hello.txt")?</code>의 결과에 <code>read_to_string</code> 호출을 직접 연결했습니다. <code>read_to_string</code> 호출 끝에 여전히 <code>?</code>가 있고, <code>File::open</code>과 <code>read_to_string</code>이 모두 성공했을 때 에러를 반환하는 대신 <code>username</code>을 포함하는 <code>Ok</code> 값을 여전히 반환합니다. 기능은 목록 9-6 및 목록 9-7과 동일합니다. 단지 작성하는 방식이 다르고 더 인체공학적일 뿐입니다.</p>
<p>목록 9-9는 <code>fs::read_to_string</code>을 사용하여 이를 더 짧게 만드는 방법을 보여줍니다.</p>
<Listing number="9-9" file-name="src/main.rs" caption="Using `fs::read_to_string` instead of opening and then reading the file">
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::io;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    fs::read_to_string("hello.txt")
}
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>파일을 문자열로 읽는 것은 꽤 일반적인 작업이므로, 표준 라이브러리는 파일을 열고, 새 <code>String</code>을 생성하고, 파일 내용을 읽고, 내용을 그 <code>String</code>에 넣고, 반환하는 편리한 <code>fs::read_to_string</code> 함수를 제공합니다. 물론 <code>fs::read_to_string</code>을 사용하면 모든 에러 처리를 설명할 기회가 없었기 때문에 먼저 더 긴 방법으로 했습니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="where-the--operator-can-be-used"></a></p>
<h4 id="where-to-use-the--operator"><a class="header" href="#where-to-use-the--operator">Where to Use the <code>?</code> Operator</a></h4>
<p><code>?</code> 연산자는 <code>?</code>가 사용된 값과 호환되는 반환 타입을 가진 함수에서만 사용할 수 있습니다. 이는 <code>?</code> 연산자가 목록 9-6에서 정의한 <code>match</code> 표현식과 같은 방식으로 함수에서 값을 일찍 반환하도록 정의되어 있기 때문입니다. 목록 9-6에서 <code>match</code>는 <code>Result</code> 값을 사용하고 있었고, 조기 반환 갈래는 <code>Err(e)</code> 값을 반환했습니다. 함수의 반환 타입은 이 <code>return</code>과 호환되도록 <code>Result</code>여야 합니다.</p>
<p>목록 9-10에서, <code>?</code>를 사용하는 값의 타입과 호환되지 않는 반환 타입을 가진 <code>main</code> 함수에서 <code>?</code> 연산자를 사용하면 어떤 에러가 발생하는지 살펴봅시다.</p>
<Listing number="9-10" file-name="src/main.rs" caption="Attempting to use the `?` in the `main` function that returns `()` won’t compile.">
<pre><code class="language-rust ignore does_not_compile">use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")?;
}</code></pre>
</Listing>
<p>이 코드는 파일을 여는데, 실패할 수 있습니다. <code>?</code> 연산자는 <code>File::open</code>이 반환한 <code>Result</code> 값을 따르지만, 이 <code>main</code> 함수는 <code>Result</code>가 아닌 <code>()</code> 반환 타입을 가집니다. 이 코드를 컴파일하면 다음과 같은 에러 메시지를 얻습니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
 --&gt; src/main.rs:4:48
  |
3 | fn main() {
  | --------- this function should return `Result` or `Option` to accept `?`
4 |     let greeting_file = File::open("hello.txt")?;
  |                                                ^ cannot use the `?` operator in a function that returns `()`
  |
help: consider adding return type
  |
3 ~ fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
4 |     let greeting_file = File::open("hello.txt")?;
5 +     Ok(())
  |

For more information about this error, try `rustc --explain E0277`.
error: could not compile `error-handling` (bin "error-handling") due to 1 previous error
</code></pre>
<p>이 에러는 우리가 <code>Result</code>, <code>Option</code>, 또는 <code>FromResidual</code>을 구현하는 다른 타입을 반환하는 함수에서만 <code>?</code> 연산자를 사용할 수 있다고 지적합니다.</p>
<p>에러를 수정하려면 두 가지 선택지가 있습니다. 하나는 함수가 이를 막는 제한이 없는 한, <code>?</code> 연산자를 사용하는 값과 호환되도록 함수의 반환 타입을 변경하는 것입니다. 다른 하나는 <code>match</code>나 <code>Result&lt;T, E&gt;</code> 메서드 중 하나를 사용하여 적절한 방식으로 <code>Result&lt;T, E&gt;</code>를 처리하는 것입니다.</p>
<p>The error message also mentioned that <code>?</code> can be used with <code>Option&lt;T&gt;</code> values as well. As with using <code>?</code> on <code>Result</code>, you can only use <code>?</code> on <code>Option</code> in a function that returns an <code>Option</code>. The behavior of the <code>?</code> operator when called on an <code>Option&lt;T&gt;</code> is similar to its behavior when called on a <code>Result&lt;T, E&gt;</code>: If the value is <code>None</code>, the <code>None</code> will be returned early from the function at that point. If the value is <code>Some</code>, the value inside the <code>Some</code> is the resultant value of the expression, and the function continues. Listing 9-11 has an example of a function that finds the last character of the first line in the given text.</p>
<Listing number="9-11" caption="Using the `?` operator on an `Option<T>` value">
<pre><pre class="playground"><code class="language-rust edition2024">fn last_char_of_first_line(text: &amp;str) -&gt; Option&lt;char&gt; {
    text.lines().next()?.chars().last()
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(
</span><span class="boring">        last_char_of_first_line("Hello, world\n오늘 기분 어떠세요?"),
</span><span class="boring">        Some(에러가 발생하면, `?` 연산자는 `from` 함수를 사용하여 받은 에러 타입을 현재 함수의 반환 타입에 정의된 에러 타입으로 변환합니다. 이는 함수가 여러 부분에서 다른 이유로 실패할 수 있더라도 모든 실패 이유를 나타내는 하나의 에러 타입을 반환할 때 유용합니다.)
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    assert_eq!(last_char_of_first_line(""), None);
</span><span class="boring">    assert_eq!(last_char_of_first_line("\nhi"), None);
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 함수는 <code>Option&lt;char&gt;</code>를 반환합니다. 문자가 있을 수도 있지만 없을 수도 있기 때문입니다. 이 코드는 <code>text</code> 문자열 슬라이스 인수를 받아 <code>lines</code> 메서드를 호출하는데, 이 메서드는 문자열의 줄에 대한 반복자를 반환합니다. 이 함수는 첫 번째 줄을 검사하고 싶어하므로 반복자에서 <code>next</code>를 호출하여 첫 번째 값을 가져옵니다. <code>text</code>가 빈 문자열이면 <code>next</code> 호출은 <code>None</code>을 반환할 것이고, 이 경우 우리는 <code>?</code>를 사용하여 멈추고 <code>last_char_of_first_line</code>에서 <code>None</code>을 반환합니다. <code>text</code>가 빈 문자열이 아니라면 <code>next</code>는 <code>text</code>의 첫 번째 줄의 문자열 슬라이스를 포함하는 <code>Some</code> 값을 반환할 것입니다.</p>
<p><code>?</code>는 문자열 슬라이스를 추출하고, 우리는 그 문자열 슬라이스에 <code>chars</code>를 호출하여 문자들의 반복자를 얻을 수 있습니다. 우리는 이 첫 번째 줄의 마지막 문자에 관심이 있으므로 <code>last</code>를 호출하여 반복자의 마지막 항목을 반환합니다. 이것은 <code>Option</code>인데, <code>"\nhi"</code>처럼 <code>text</code>가 빈 줄로 시작하지만 다른 줄에 문자가 있는 경우와 같이 첫 번째 줄이 빈 문자열일 가능성이 있기 때문입니다. 그러나 첫 번째 줄에 마지막 문자가 있다면 <code>Some</code> 변형으로 반환될 것입니다. 중간에 있는 <code>?</code> 연산자는 이 로직을 표현하는 간결한 방법을 제공하여 함수를 한 줄로 구현할 수 있게 해줍니다. <code>Option</code>에 <code>?</code> 연산자를 사용할 수 없었다면, 더 많은 메서드 호출이나 <code>match</code> 표현식을 사용하여 이 로직을 구현해야 했을 것입니다.</p>
<p><code>Result</code>를 반환하는 함수에서는 <code>Result</code>에 <code>?</code> 연산자를 사용할 수 있고, <code>Option</code>을 반환하는 함수에서는 <code>Option</code>에 <code>?</code> 연산자를 사용할 수 있지만, 섞어서 사용할 수는 없다는 점에 유의하세요. <code>?</code> 연산자는 자동으로 <code>Result</code>를 <code>Option</code>으로 또는 그 반대로 변환하지 않습니다. 그런 경우에는 <code>Result</code>의 <code>ok</code> 메서드나 <code>Option</code>의 <code>ok_or</code> 메서드와 같은 메서드를 사용하여 명시적으로 변환할 수 있습니다.</p>
<p>지금까지 사용한 모든 <code>main</code> 함수는 <code>()</code>를 반환했습니다. <code>main</code> 함수는 실행 가능한 프로그램의 진입점이자 종료점이기 때문에 특별하며, 프로그램이 예상대로 동작하기 위해 반환 타입이 될 수 있는 것에 제한이 있습니다.</p>
<p>다행히 <code>main</code>은 <code>Result&lt;(), E&gt;</code>도 반환할 수 있습니다. 목록 9-12는 목록 9-10의 코드를 가지고 있지만, <code>main</code>의 반환 타입을 <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>로 변경하고 끝에 반환 값 <code>Ok(())</code>를 추가했습니다. 이 코드는 이제 컴파일될 것입니다.</p>
<Listing number="9-12" file-name="src/main.rs" caption="Changing `main` to return `Result<(), E>` allows the use of the `?` operator on `Result` values.">
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs::File;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let greeting_file = File::open("hello.txt")?;

    Ok(())
}</code></pre>
</Listing>
<p>The <code>Box&lt;dyn Error&gt;</code> type is a trait object, which we’ll talk about in <a href="ch18-02-trait-objects.html#using-trait-objects-to-abstract-over-shared-behavior">“Using Trait Objects to Abstract over Shared Behavior”</a><!-- ignore --> in Chapter 18. For now, you can read <code>Box&lt;dyn Error&gt;</code> to mean “any kind of error.” Using <code>?</code> on a <code>Result</code> value in a <code>main</code> function with the error type <code>Box&lt;dyn Error&gt;</code> is allowed because it allows any <code>Err</code> value to be returned early. Even though the body of this <code>main</code> function will only ever return errors of type <code>std::io::Error</code>, by specifying <code>Box&lt;dyn Error&gt;</code>, this signature will continue to be correct even if more code that returns other errors is added to the body of <code>main</code>.</p>
<p>When a <code>main</code> function returns a <code>Result&lt;(), E&gt;</code>, the executable will exit with a value of <code>0</code> if <code>main</code> returns <code>Ok(())</code> and will exit with a nonzero value if <code>main</code> returns an <code>Err</code> value. Executables written in C return integers when they exit: Programs that exit successfully return the integer <code>0</code>, and programs that error return some integer other than <code>0</code>. Rust also returns integers from executables to be compatible with this convention.</p>
<p>자신의 타입에 <code>Termination</code> 트레이트를 구현하는 것에 대한 자세한 내용은 표준 라이브러리 문서를 참조하세요.</p>
<p>이제 <code>panic!</code>을 호출하거나 <code>Result</code>를 반환하는 것의 세부 사항에 대해 논의했으므로, 어떤 경우에 어떤 것을 사용하는 것이 적절한지 결정하는 주제로 돌아가 보겠습니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch09-01-unrecoverable-errors-with-panic.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch09-03-to-panic-or-not-to-panic.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch09-01-unrecoverable-errors-with-panic.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch09-03-to-panic-or-not-to-panic.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
