<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>단일 스레드 웹 서버 만들기 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch21-01-single-threaded.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch21-01-single-threaded.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="단일-스레드-웹-서버-만들기"><a class="header" href="#단일-스레드-웹-서버-만들기">단일 스레드 웹 서버 만들기</a></h2>
<p>먼저 단일 스레드 웹 서버를 작동시키는 것부터 시작하겠습니다. 시작하기 전에 웹 서버 구축과 관련된 프로토콜에 대해 간략히 살펴보겠습니다. 이러한 프로토콜의 세부 사항은 이 책의 범위를 벗어나지만, 간략한 개요를 통해 필요한 정보를 얻을 수 있을 것입니다.</p>
<p>웹 서버와 관련된 두 가지 주요 프로토콜은 _HTTP(Hypertext Transfer Protocol)_와 _TCP(Transmission Control Protocol)_입니다. 두 프로토콜 모두 <em>요청-응답(request-response)</em> 프로토콜로, _클라이언트(client)_가 요청을 시작하고 _서버(server)_가 요청을 대기하다가 클라이언트에게 응답을 제공한다는 의미입니다. 이러한 요청과 응답의 내용은 프로토콜에 의해 정의됩니다.</p>
<p>TCP는 정보가 한 서버에서 다른 서버로 전달되는 방식에 대한 세부 사항을 기술하는 하위 수준 프로토콜이지만, 그 정보가 무엇인지는 지정하지 않습니다. HTTP는 요청과 응답의 내용을 정의함으로써 TCP 위에서 구축됩니다. 기술적으로는 HTTP를 다른 프로토콜과 함께 사용하는 것도 가능하지만, 대부분의 경우 HTTP는 TCP를 통해 데이터를 전송합니다. 우리는 TCP와 HTTP 요청 및 응답의 원시 바이트(raw bytes)를 직접 다룰 것입니다.</p>
<h3 id="tcp-연결-대기하기"><a class="header" href="#tcp-연결-대기하기">TCP 연결 대기하기</a></h3>
<p>우리 웹 서버는 TCP 연결을 대기해야 하므로, 이것이 우리가 작업할 첫 번째 부분입니다. 표준 라이브러리는 이를 가능하게 해주는 <code>std::net</code> 모듈을 제공합니다. 평소와 같은 방식으로 새 프로젝트를 만들어 봅시다.</p>
<pre><code class="language-console">$ cargo new hello
     Created binary (application) `hello` project
$ cd hello
</code></pre>
<p>이제 시작을 위해 예제 21-1의 코드를 _src/main.rs_에 입력하세요. 이 코드는 로컬 주소 <code>127.0.0.1:7878</code>에서 들어오는 TCP 스트림을 대기합니다. 들어오는 스트림이 있으면 <code>연결되었습니다!</code>라고 출력할 것입니다.</p>
<Listing number="21-1" file-name="src/main.rs" caption="Listening for incoming streams and printing a message when we receive a stream">
<pre><pre class="playground"><code class="language-rust no_run edition2024">use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        println!("연결되었습니다!");
    }
}</code></pre></pre>
</Listing>
<p>Using <code>TcpListener</code>, we can listen for TCP connections at the address <code>127.0.0.1:7878</code>. In the address, the section before the colon is an IP address representing your computer (this is the same on every computer and doesn’t represent the authors’ computer specifically), and <code>7878</code> is the port. We’ve chosen this port for two reasons: HTTP isn’t normally accepted on this port, so our server is unlikely to conflict with any other web server you might have running on your machine, and 7878 is <em>rust</em> typed on a telephone.</p>
<p>이 시나리오에서 <code>bind</code> 함수는 새로운 <code>TcpListener</code> 인스턴스를 반환한다는 점에서 <code>new</code> 함수처럼 작동합니다. 이 함수가 <code>bind</code>라고 불리는 이유는 네트워킹에서 대기할 포트에 연결하는 것을 “포트에 바인딩(binding to a port)”한다고 하기 때문입니다.</p>
<p>The <code>bind</code> function returns a <code>Result&lt;T, E&gt;</code>, which indicates that it’s possible for binding to fail, for example, if we ran two instances of our program and so had two programs listening to the same port. Because we’re writing a basic server just for learning purposes, we won’t worry about handling these kinds of errors; instead, we use <code>unwrap</code> to stop the program if errors happen.</p>
<p>The <code>incoming</code> method on <code>TcpListener</code> returns an iterator that gives us a sequence of streams (more specifically, streams of type <code>TcpStream</code>). A single <em>stream</em> represents an open connection between the client and the server. <em>Connection</em> is the name for the full request and response process in which a client connects to the server, the server generates a response, and the server closes the connection. As such, we will read from the <code>TcpStream</code> to see what the client sent and then write our response to the stream to send data back to the client. Overall, this <code>for</code> loop will process each connection in turn and produce a series of streams for us to handle.</p>
<p>지금으로서 우리가 스트림을 처리하는 방식은, 스트림에 에러가 있는 경우 프로그램을 종료하도록 <code>unwrap</code>을 호출하는 것으로 구성됩니다. 에러가 없다면 프로그램은 메시지를 출력합니다. 다음 예제에서는 성공적인 경우에 대해 더 많은 기능을 추가할 것입니다. 클라이언트가 서버에 연결할 때 <code>incoming</code> 메서드로부터 에러를 받을 수 있는 이유는, 우리가 실제로 연결들에 대해 반복하는 것이 아니기 때문입니다. 대신 우리는 _연결 시도(connection attempts)_에 대해 반복하고 있습니다. 여러 가지 이유로 연결이 성공하지 못할 수 있으며, 그중 다수는 운영 체제에 따라 다릅니다. 예를 들어, 많은 운영 체제는 지원할 수 있는 동시 열린 연결 수에 제한을 둡니다. 그 수를 초과하는 새로운 연결 시도는 열린 연결 중 일부가 닫힐 때까지 에러를 발생시킬 것입니다.</p>
<p>이 코드를 실행해 봅시다! 터미널에서 <code>cargo run</code>을 실행한 다음 웹 브라우저에서 _127.0.0.1:7878_로 접속하세요. 서버가 현재 어떤 데이터도 돌려보내지 않기 때문에 브라우저에는 “연결 재설정”과 같은 에러 메시지가 표시될 것입니다. 하지만 터미널을 보면 브라우저가 서버에 연결되었을 때 출력된 여러 메시지를 볼 수 있을 것입니다!</p>
<pre><code class="language-text">     Running `target/debug/hello`
Connection established!
Connection established!
Connection established!
</code></pre>
<p>때때로 한 번의 브라우저 요청에 대해 여러 메시지가 출력되는 것을 볼 수 있는데, 그 이유는 브라우저가 페이지에 대한 요청뿐만 아니라 브라우저 탭에 나타나는 <em>favicon.ico</em> 아이콘과 같은 다른 리소스에 대한 요청도 보내기 때문일 수 있습니다.</p>
<p>It could also be that the browser is trying to connect to the server multiple times because the server isn’t responding with any data. When <code>stream</code> goes out of scope and is dropped at the end of the loop, the connection is closed as part of the <code>drop</code> implementation. Browsers sometimes deal with closed connections by retrying, because the problem might be temporary.</p>
<p>Browsers also sometimes open multiple connections to the server without sending any requests so that if they <em>do</em> later send requests, those requests can happen more quickly. When this occurs, our server will see each connection, regardless of whether there are any requests over that connection. Many versions of Chrome-based browsers do this, for example; you can disable that optimization by using private browsing mode or using a different browser.</p>
<p>The important factor is that we’ve successfully gotten a handle to a TCP connection!</p>
<p>Remember to stop the program by pressing <kbd>ctrl</kbd>-<kbd>C</kbd> when you’re done running a particular version of the code. Then, restart the program by invoking the <code>cargo run</code> command after you’ve made each set of code changes to make sure you’re running the newest code.</p>
<h3 id="요청-읽기"><a class="header" href="#요청-읽기">요청 읽기</a></h3>
<p>Let’s implement the functionality to read the request from the browser! To separate the concerns of first getting a connection and then taking some action with the connection, we’ll start a new function for processing connections. In this new <code>handle_connection</code> function, we’ll read data from the TCP stream and print it so that we can see the data being sent from the browser. Change the code to look like Listing 21-2.</p>
<Listing number="21-2" file-name="src/main.rs" caption="Reading from the `TcpStream` and printing the data">
<pre><pre class="playground"><code class="language-rust no_run edition2024">use std::{
    io::{BufReader, prelude::*},
    net::{TcpListener, TcpStream},
};

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    println!("요청: {http_request:#?}");
}</code></pre></pre>
</Listing>
<p>We bring <code>std::io::BufReader</code> and <code>std::io::prelude</code> into scope to get access to traits and types that let us read from and write to the stream. In the <code>for</code> loop in the <code>main</code> function, instead of printing a message that says we made a connection, we now call the new <code>handle_connection</code> function and pass the <code>stream</code> to it.</p>
<p><code>handle_connection</code> 함수에서는 <code>stream</code>에 대한 참조를 감싸는 새로운 <code>BufReader</code> 인스턴스를 생성합니다. <code>BufReader</code>는 우리 대신 <code>std::io::Read</code> 트레이트 메서드들의 호출을 관리함으로써 버퍼링 기능을 추가해 줍니다.</p>
<p>브라우저가 우리 서버에 보내는 요청의 각 줄을 수집하기 위해 <code>http_request</code>라는 변수를 만듭니다. <code>Vec&lt;_&gt;</code> 타입 어노테이션을 추가하여 이 줄들을 벡터에 수집하고 싶다는 것을 명시합니다.</p>
<p><code>BufReader</code> implements the <code>std::io::BufRead</code> trait, which provides the <code>lines</code> method. The <code>lines</code> method returns an iterator of <code>Result&lt;String, std::io::Error&gt;</code> by splitting the stream of data whenever it sees a newline byte. To get each <code>String</code>, we <code>map</code> and <code>unwrap</code> each <code>Result</code>. The <code>Result</code> might be an error if the data isn’t valid UTF-8 or if there was a problem reading from the stream. Again, a production program should handle these errors more gracefully, but we’re choosing to stop the program in the error case for simplicity.</p>
<p>The browser signals the end of an HTTP request by sending two newline characters in a row, so to get one request from the stream, we take lines until we get a line that is the empty string. Once we’ve collected the lines into the vector, we’re printing them out using pretty debug formatting so that we can take a look at the instructions the web browser is sending to our server.</p>
<p>이 코드를 실행해 봅시다! 프로그램을 시작하고 웹 브라우저에서 다시 요청을 보내세요. 브라우저에는 여전히 에러 페이지가 표시되겠지만, 터미널에 표시되는 우리 프로그램의 출력은 이제 다음과 유사할 것입니다.</p>
<!-- manual-regeneration
cd listings/ch21-web-server/listing-21-02
cargo run
make a request to 127.0.0.1:7878
Can't automate because the output depends on making requests
-->
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/hello`
Request: [
    "GET / HTTP/1.1",
    "Host: 127.0.0.1:7878",
    "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:99.0) Gecko/20100101 Firefox/99.0",
    "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
    "Accept-Language: en-US,en;q=0.5",
    "Accept-Encoding: gzip, deflate, br",
    "DNT: 1",
    "Connection: keep-alive",
    "Upgrade-Insecure-Requests: 1",
    "Sec-Fetch-Dest: document",
    "Sec-Fetch-Mode: navigate",
    "Sec-Fetch-Site: none",
    "Sec-Fetch-User: ?1",
    "Cache-Control: max-age=0",
]
</code></pre>
<p>브라우저에 따라 출력이 약간 다를 수 있습니다. 이제 요청 데이터를 출력하고 있으므로, 요청의 첫 번째 줄에서 <code>GET</code> 뒤에 오는 경로를 살펴봄으로써 왜 한 번의 브라우저 요청으로부터 여러 개의 연결이 발생하는지 알 수 있습니다. 반복되는 연결들이 모두 _/_를 요청하고 있다면, 브라우저가 우리 프로그램으로부터 응답을 받지 못해 반복적으로 _/_를 가져오려고 시도하고 있음을 알 수 있습니다.</p>
<p>브라우저가 우리 프로그램에 무엇을 요청하고 있는지 이해하기 위해 이 요청 데이터를 분석해 봅시다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="a-closer-look-at-an-http-request"></a> <a id="looking-closer-at-an-http-request"></a></p>
<h3 id="looking-more-closely-at-an-http-request"><a class="header" href="#looking-more-closely-at-an-http-request">Looking More Closely at an HTTP Request</a></h3>
<p>HTTP는 텍스트 기반 프로토콜이며, 요청은 다음과 같은 형식을 가집니다.</p>
<pre><code class="language-text">Method Request-URI HTTP-Version CRLF
headers CRLF
message-body
</code></pre>
<p>The first line is the <em>request line</em> that holds information about what the client is requesting. The first part of the request line indicates the method being used, such as <code>GET</code> or <code>POST</code>, which describes how the client is making this request. Our client used a <code>GET</code> request, which means it is asking for information.</p>
<p>The next part of the request line is <em>/</em>, which indicates the <em>uniform resource identifier</em> <em>(URI)</em> the client is requesting: A URI is almost, but not quite, the same as a <em>uniform resource locator</em> <em>(URL)</em>. The difference between URIs and URLs isn’t important for our purposes in this chapter, but the HTTP spec uses the term <em>URI</em>, so we can just mentally substitute <em>URL</em> for <em>URI</em> here.</p>
<p>The last part is the HTTP version the client uses, and then the request line ends in a CRLF sequence. (<em>CRLF</em> stands for <em>carriage return</em> and <em>line feed</em>, which are terms from the typewriter days!) The CRLF sequence can also be written as <code>\r\n</code>, where <code>\r</code> is a carriage return and <code>\n</code> is a line feed. The <em>CRLF sequence</em> separates the request line from the rest of the request data. Note that when the CRLF is printed, we see a new line start rather than <code>\r\n</code>.</p>
<p>지금까지 프로그램을 실행하여 받은 요청 라인 데이터를 보면, <code>GET</code>은 메서드이고 _/_는 요청 URI이며 <code>HTTP/1.1</code>은 버전임을 알 수 있습니다.</p>
<p>요청 라인 이후에 <code>Host:</code>로 시작하는 나머지 줄들은 헤더입니다. <code>GET</code> 요청은 본문(body)이 없습니다.</p>
<p>다른 브라우저에서 요청을 보내거나 _127.0.0.1:7878/test_와 같이 다른 주소를 요청하여 요청 데이터가 어떻게 변하는지 확인해 보세요.</p>
<p>이제 브라우저가 무엇을 요청하는지 알았으니, 데이터를 다시 보내봅시다!</p>
<h3 id="응답-작성하기"><a class="header" href="#응답-작성하기">응답 작성하기</a></h3>
<p>클라이언트 요청에 대한 응답으로 데이터를 보내는 기능을 구현하겠습니다. 응답은 다음과 같은 형식을 가집니다.</p>
<pre><code class="language-text">HTTP-Version Status-Code Reason-Phrase CRLF
headers CRLF
message-body
</code></pre>
<p>첫 번째 줄은 _상태 라인(status line)_으로, 응답에 사용된 HTTP 버전, 요청 결과를 요약하는 숫자 상태 코드, 그리고 상태 코드에 대한 텍스트 설명을 제공하는 사유 구문(reason phrase)을 포함합니다. CRLF 시퀀스 다음에는 헤더들이 오고, 또 다른 CRLF 시퀀스 뒤에 응답 본문이 옵니다.</p>
<p>Here is an example response that uses HTTP version 1.1 and has a status code of 200, an OK reason phrase, no headers, and no body:</p>
<pre><code class="language-text">HTTP/1.1 200 OK\r\n\r\n
</code></pre>
<p>상태 코드 200은 표준 성공 응답입니다. 이 텍스트는 아주 작은 성공적인 HTTP 응답입니다. 성공적인 요청에 대한 응답으로 이것을 스트림에 써 봅시다! <code>handle_connection</code> 함수에서 요청 데이터를 출력하던 <code>println!</code>을 제거하고 예제 21-3의 코드로 교체하세요.</p>
<Listing number="21-3" file-name="src/main.rs" caption="Writing a tiny successful HTTP response to the stream">
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">use std::{
</span><span class="boring">    io::{BufReader, prelude::*},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let response = "HTTP/1.1 200 OK\r\n\r\n";

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
</Listing>
<p>The first new line defines the <code>response</code> variable that holds the success message’s data. Then, we call <code>as_bytes</code> on our <code>response</code> to convert the string data to bytes. The <code>write_all</code> method on <code>stream</code> takes a <code>&amp;[u8]</code> and sends those bytes directly down the connection. Because the <code>write_all</code> operation could fail, we use <code>unwrap</code> on any error result as before. Again, in a real application, you would add error handling here.</p>
<p>이러한 변경 사항들을 적용하고 코드를 실행하여 요청을 보내봅시다. 이제 터미널에 데이터를 출력하지 않으므로 Cargo의 출력 외에는 아무것도 보이지 않을 것입니다. 웹 브라우저에서 _127.0.0.1:7878_로 접속하면 에러 대신 빈 페이지가 나타날 것입니다. 여러분은 방금 HTTP 요청을 받고 응답을 보내는 과정을 직접 코딩하셨습니다!</p>
<h3 id="실제-html-반환하기"><a class="header" href="#실제-html-반환하기">실제 HTML 반환하기</a></h3>
<p>빈 페이지 이상의 것을 반환하는 기능을 구현해 봅시다. 프로젝트 디렉토리의 루트( <em>src</em> 디렉토리가 아닌 곳)에 새로운 파일 _hello.html_을 만드세요. 원하는 HTML을 무엇이든 넣으셔도 됩니다. 예제 21-4는 그중 한 가지 예시입니다.</p>
<Listing number="21-4" file-name="hello.html" caption="A sample HTML file to return in a response">
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="ko"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello!&lt;/h1&gt;
    &lt;p&gt;Hi from Rust&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
</Listing>
<p>이는 헤더와 약간의 텍스트가 있는 최소한의 HTML5 문서입니다. 요청을 받았을 때 서버에서 이를 반환하기 위해, 예제 21-5와 같이 <code>handle_connection</code>을 수정하여 HTML 파일을 읽고 이를 응답 본문에 추가하여 전송하도록 하겠습니다.</p>
<Listing number="21-5" file-name="src/main.rs" caption="Sending the contents of *hello.html* as the body of the response">
<pre><pre class="playground"><code class="language-rust no_run edition2024">use std::{
    fs,
    io::{BufReader, prelude::*},
    net::{TcpListener, TcpStream},
};
// --생략--

<span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let status_line = "HTTP/1.1 200 OK";
    let contents = fs::read_to_string("hello.html").unwrap();
    let length = contents.len();

    let response =
        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
</Listing>
<p>표준 라이브러리의 파일 시스템 모듈을 스코프로 가져오기 위해 <code>use</code>문에 <code>fs</code>를 추가했습니다. 파일 내용을 문자열로 읽어 들이는 코드는 익숙하실 것입니다. 12장의 예제 12-4에서 I/O 프로젝트를 위해 파일 내용을 읽을 때 사용했었습니다.</p>
<p>Next, we use <code>format!</code> to add the file’s contents as the body of the success response. To ensure a valid HTTP response, we add the <code>Content-Length</code> header, which is set to the size of our response body—in this case, the size of <code>hello.html</code>.</p>
<p><code>cargo run</code>으로 이 코드를 실행하고 브라우저에서 _127.0.0.1:7878_에 접속해 보세요. 여러분의 HTML이 렌더링된 것을 볼 수 있을 것입니다!</p>
<p>현재 우리는 <code>http_request</code>에 담긴 요청 데이터를 무시하고 HTML 파일의 내용을 무조건적으로 되돌려보내고 있습니다. 즉, 브라우저에서 _127.0.0.1:7878/something-else_를 요청하더라도 동일한 HTML 응답을 받게 된다는 뜻입니다. 지금 우리 서버는 매우 제한적이며 대부분의 웹 서버가 하는 일을 하지 못합니다. 우리는 요청에 따라 응답을 커스터마이징하고, _/_에 대한 올바른 형식의 요청에 대해서만 HTML 파일을 반환하고 싶습니다.</p>
<h3 id="요청-검증-및-선택적-응답"><a class="header" href="#요청-검증-및-선택적-응답">요청 검증 및 선택적 응답</a></h3>
<p>Right now, our web server will return the HTML in the file no matter what the client requested. Let’s add functionality to check that the browser is requesting <em>/</em> before returning the HTML file and to return an error if the browser requests anything else. For this we need to modify <code>handle_connection</code>, as shown in Listing 21-6. This new code checks the content of the request received against what we know a request for <em>/</em> looks like and adds <code>if</code> and <code>else</code> blocks to treat requests differently.</p>
<Listing number="21-6" file-name="src/main.rs" caption="Handling requests to */* differently from other requests">
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{BufReader, prelude::*},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>// --생략--

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;stream);
    let request_line = buf_reader.lines().next().unwrap().unwrap();

    if request_line == "GET / HTTP/1.1" {
        let status_line = "HTTP/1.1 200 OK";
        let contents = fs::read_to_string("hello.html").unwrap();
        let length = contents.len();

        let response = format!(
            "{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}"
        );

        stream.write_all(response.as_bytes()).unwrap();
    } else {
        // 그 외의 요청
    }
}</code></pre></pre>
</Listing>
<p>우리는 HTTP 요청의 첫 번째 줄만 살펴볼 것이므로, 전체 요청을 벡터로 읽어 들이는 대신 반복자에서 첫 번째 아이템을 얻기 위해 <code>next</code>를 호출합니다. 첫 번째 <code>unwrap</code>은 <code>Option</code>을 처리하며 반복자에 아이템이 없으면 프로그램을 중단시킵니다. 두 번째 <code>unwrap</code>은 <code>Result</code>를 처리하며 예제 21-2에서 추가된 <code>map</code> 안에 있던 <code>unwrap</code>과 동일한 효과를 냅니다.</p>
<p>다음으로, <code>request_line</code>이 <em>/</em> 경로에 대한 GET 요청의 요청 라인과 일치하는지 확인합니다. 일치한다면 <code>if</code> 블록은 HTML 파일의 내용을 반환합니다.</p>
<p><code>request_line</code>이 <em>/</em> 경로에 대한 GET 요청과 일치하지 않는다면, 이는 우리가 다른 어떤 요청을 받았음을 의미합니다. 잠시 후에 모든 다른 요청에 응답하기 위한 코드를 <code>else</code> 블록에 추가할 것입니다.</p>
<p>이제 이 코드를 실행하고 _127.0.0.1:7878_을 요청해 보세요. _hello.html_에 있는 HTML을 받게 될 것입니다. _127.0.0.1:7878/something-else_와 같이 다른 요청을 하면, 예제 21-1과 21-2의 코드를 실행했을 때 보았던 것과 같은 연결 에러가 발생할 것입니다.</p>
<p>이제 요청한 콘텐츠를 찾을 수 없음을 나타내는 상태 코드 404와 함께 응답을 반환하도록 예제 21-7의 코드를 <code>else</code> 블록에 추가해 봅시다. 또한 최종 사용자에게 응답을 표시하기 위해 브라우저에서 렌더링할 HTML도 함께 반환할 것입니다.</p>
<Listing number="21-7" file-name="src/main.rs" caption="Responding with status code 404 and an error page if anything other than */* was requested">
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{BufReader, prelude::*},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    if request_line == "GET / HTTP/1.1" {
</span><span class="boring">        let status_line = "HTTP/1.1 200 OK";
</span><span class="boring">        let contents = fs::read_to_string("hello.html").unwrap();
</span><span class="boring">        let length = contents.len();
</span><span class="boring">
</span><span class="boring">        let response = format!(
</span><span class="boring">            "{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}"
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        stream.write_all(response.as_bytes()).unwrap();
</span>    // --생략--
    } else {
        let status_line = "HTTP/1.1 404 NOT FOUND";
        let contents = fs::read_to_string("404.html").unwrap();
        let length = contents.len();

        let response = format!(
            "{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}"
        );

        stream.write_all(response.as_bytes()).unwrap();
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>Here, our response has a status line with status code 404 and the reason phrase <code>NOT FOUND</code>. The body of the response will be the HTML in the file <em>404.html</em>. You’ll need to create a <em>404.html</em> file next to <em>hello.html</em> for the error page; again, feel free to use any HTML you want, or use the example HTML in Listing 21-8.</p>
<Listing number="21-8" file-name="404.html" caption="Sample content for the page to send back with any 404 response">
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="ko"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Oops!&lt;/h1&gt;
    &lt;p&gt;Sorry, I don't know what you're asking for.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
</Listing>
<p>이러한 변경 사항을 적용하고 서버를 다시 실행하세요. _127.0.0.1:7878_을 요청하면 _hello.html_의 내용이 반환되어야 하며, _127.0.0.1:7878/foo_와 같은 다른 모든 요청은 _404.html_의 에러 HTML을 반환해야 합니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="a-touch-of-refactoring"></a></p>
<h3 id="refactoring"><a class="header" href="#refactoring">Refactoring</a></h3>
<p>At the moment, the <code>if</code> and <code>else</code> blocks have a lot of repetition: They’re both reading files and writing the contents of the files to the stream. The only differences are the status line and the filename. Let’s make the code more concise by pulling out those differences into separate <code>if</code> and <code>else</code> lines that will assign the values of the status line and the filename to variables; we can then use those variables unconditionally in the code to read the file and write the response. Listing 21-9 shows the resultant code after replacing the large <code>if</code> and <code>else</code> blocks.</p>
<Listing number="21-9" file-name="src/main.rs" caption="Refactoring the `if` and `else` blocks to contain only the code that differs between the two cases">
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{BufReader, prelude::*},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>// --생략--

fn handle_connection(mut stream: TcpStream) {
    // --생략--
<span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span>
    let (status_line, filename) = if request_line == "GET / HTTP/1.1" {
        ("HTTP/1.1 200 OK", "hello.html")
    } else {
        ("HTTP/1.1 404 NOT FOUND", "404.html")
    };

    let contents = fs::read_to_string(filename).unwrap();
    let length = contents.len();

    let response =
        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
</Listing>
<p>이제 <code>if</code>와 <code>else</code> 블록은 튜플 형태로 적절한 상태 라인과 파일 이름 값만 반환합니다. 그런 다음 19장에서 논의한 것처럼 <code>let</code> 문에서 패턴을 사용하는 구조 분해(destructuring)를 통해 이 두 값을 <code>status_line</code>과 <code>filename</code>에 할당합니다.</p>
<p>이전에 중복되었던 코드는 이제 <code>if</code>와 <code>else</code> 블록 밖에 있으며 <code>status_line</code>과 <code>filename</code> 변수를 사용합니다. 이렇게 하면 두 케이스 사이의 차이점을 더 쉽게 알 수 있으며, 파일 읽기 및 응답 쓰기 방식이 변경될 때 수정해야 할 곳이 한 곳뿐임을 의미합니다. 예제 21-9 코드의 동작은 예제 21-7과 동일합니다.</p>
<p>멋지네요! 이제 약 40줄의 러스트 코드로 특정 요청에는 콘텐츠 페이지로 응답하고 다른 모든 요청에는 404 응답을 보내는 간단한 웹 서버를 갖게 되었습니다.</p>
<p>Currently, our server runs in a single thread, meaning it can only serve one request at a time. Let’s examine how that can be a problem by simulating some slow requests. Then, we’ll fix it so that our server can handle multiple requests at once.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch21-00-final-project-a-web-server.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch21-02-multithreaded.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch21-00-final-project-a-web-server.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch21-02-multithreaded.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
