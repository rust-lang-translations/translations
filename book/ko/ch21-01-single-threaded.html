<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>단일 스레드 웹 서버 만들기 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch21-01-single-threaded.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch21-01-single-threaded.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="단일-스레드-웹-서버-만들기"><a class="header" href="#단일-스레드-웹-서버-만들기">단일 스레드 웹 서버 만들기</a></h2>
<p>먼저 단일 스레드 웹 서버를 작동시키는 것부터 시작하겠습니다. 시작하기 전에 웹 서버 구축과 관련된 프로토콜에 대해 간략히 살펴보겠습니다. 이러한 프로토콜의 세부 사항은 이 책의 범위를 벗어나지만, 간략한 개요를 통해 필요한 정보를 얻을 수 있을 것입니다.</p>
<p>웹 서버와 관련된 두 가지 주요 프로토콜은 _HTTP(Hypertext Transfer Protocol)_와 _TCP(Transmission Control Protocol)_입니다. 두 프로토콜 모두 <em>요청-응답(request-response)</em> 프로토콜로, _클라이언트(client)_가 요청을 시작하고 _서버(server)_가 요청을 대기하다가 클라이언트에게 응답을 제공한다는 의미입니다. 이러한 요청과 응답의 내용은 프로토콜에 의해 정의됩니다.</p>
<p>TCP는 정보가 한 서버에서 다른 서버로 전달되는 방식에 대한 세부 사항을 기술하는 하위 수준 프로토콜이지만, 그 정보가 무엇인지는 지정하지 않습니다. HTTP는 요청과 응답의 내용을 정의함으로써 TCP 위에서 구축됩니다. 기술적으로는 HTTP를 다른 프로토콜과 함께 사용하는 것도 가능하지만, 대부분의 경우 HTTP는 TCP를 통해 데이터를 전송합니다. 우리는 TCP와 HTTP 요청 및 응답의 원시 바이트(raw bytes)를 직접 다룰 것입니다.</p>
<h3 id="tcp-연결-대기하기"><a class="header" href="#tcp-연결-대기하기">TCP 연결 대기하기</a></h3>
<p>우리 웹 서버는 TCP 연결을 대기해야 하므로, 이것이 우리가 작업할 첫 번째 부분입니다. 표준 라이브러리는 이를 가능하게 해주는 <code>std::net</code> 모듈을 제공합니다. 평소와 같은 방식으로 새 프로젝트를 만들어 봅시다.</p>
<pre><code class="language-console">$ cargo new hello
     Created binary (application) `hello` project
$ cd hello
</code></pre>
<p>이제 시작을 위해 예제 21-1의 코드를 _src/main.rs_에 입력하세요. 이 코드는 로컬 주소 <code>127.0.0.1:7878</code>에서 들어오는 TCP 스트림을 대기합니다. 들어오는 스트림이 있으면 <code>연결되었습니다!</code>라고 출력할 것입니다.</p>
<Listing number="21-1" file-name="src/main.rs" caption="Listening for incoming streams and printing a message when we receive a stream">
<pre><pre class="playground"><code class="language-rust no_run edition2021">use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        println!("연결되었습니다!");
    }
}</code></pre></pre>
</Listing>
<p><code>TcpListener</code>를 사용하여 주소 <code>127.0.0.1:7878</code>에서 TCP 연결을 대기할 수 있습니다. 주소에서 콜론 앞부분은 여러분의 컴퓨터를 나타내는 IP 주소이고(이는 모든 컴퓨터에서 동일하며 저자의 컴퓨터를 특별히 나타내는 것은 아닙니다), <code>7878</code>은 포트입니다. 우리가 이 포트를 선택한 이유는 두 가지입니다. 보통 이 포트에서는 HTTP가 허용되지 않으므로 우리 서버가 여러분의 기기에서 실행 중인 다른 웹 서버와 충돌할 가능성이 낮으며, 7878은 전화기 자판에서 _rust_를 쳤을 때의 숫자입니다.</p>
<p>이 시나리오에서 <code>bind</code> 함수는 새로운 <code>TcpListener</code> 인스턴스를 반환한다는 점에서 <code>new</code> 함수처럼 작동합니다. 이 함수가 <code>bind</code>라고 불리는 이유는 네트워킹에서 대기할 포트에 연결하는 것을 “포트에 바인딩(binding to a port)”한다고 하기 때문입니다.</p>
<p><code>bind</code> 함수는 <code>Result&lt;T, E&gt;</code>를 반환하는데, 이는 바인딩이 실패할 가능성이 있음을 나타냅니다. 예를 들어, 80번 포트에 연결하려면 관리자 권한이 필요하며(관리자가 아닌 사용자는 1023보다 큰 포트만 대기할 수 있습니다), 관리자가 아닌 상태에서 80번 포트에 연결을 시도하면 바인딩이 작동하지 않을 것입니다. 또한, 예를 들어 우리 프로그램을 두 개 실행하여 두 프로그램이 동일한 포트에서 대기하도록 하는 경우에도 바인딩은 작동하지 않습니다. 우리는 단지 학습 목적으로 기본적인 서버를 작성하는 것이므로, 이러한 종류의 에러 처리에 대해서는 걱정하지 않을 것입니다. 대신 에러가 발생하면 <code>unwrap</code>을 사용하여 프로그램을 중단시킵니다.</p>
<p><code>TcpListener</code>의 <code>incoming</code> 메서드는 스트림 시퀀스(더 정확하게는 <code>TcpStream</code> 타입의 스트림들)를 제공하는 반복자를 반환합니다. 단일 _스트림(stream)_은 클라이언트와 서버 사이의 열린 연결을 나타냅니다. _연결(connection)_은 클라이언트가 서버에 연결하고, 서버가 응답을 생성하고, 서버가 연결을 닫는 전체 요청 및 응답 프로세스의 이름입니다. 따라서 우리는 <code>TcpStream</code>으로부터 읽어 들여 클라이언트가 무엇을 보냈는지 확인하고, 스트림에 우리의 응답을 써서 클라이언트에게 데이터를 다시 보낼 것입니다. 전반적으로, 이 <code>for</code> 루프는 각 연결을 차례로 처리하고 우리가 처리할 일련의 스트림을 생성할 것입니다.</p>
<p>지금으로서 우리가 스트림을 처리하는 방식은, 스트림에 에러가 있는 경우 프로그램을 종료하도록 <code>unwrap</code>을 호출하는 것으로 구성됩니다. 에러가 없다면 프로그램은 메시지를 출력합니다. 다음 예제에서는 성공적인 경우에 대해 더 많은 기능을 추가할 것입니다. 클라이언트가 서버에 연결할 때 <code>incoming</code> 메서드로부터 에러를 받을 수 있는 이유는, 우리가 실제로 연결들에 대해 반복하는 것이 아니기 때문입니다. 대신 우리는 _연결 시도(connection attempts)_에 대해 반복하고 있습니다. 여러 가지 이유로 연결이 성공하지 못할 수 있으며, 그중 다수는 운영 체제에 따라 다릅니다. 예를 들어, 많은 운영 체제는 지원할 수 있는 동시 열린 연결 수에 제한을 둡니다. 그 수를 초과하는 새로운 연결 시도는 열린 연결 중 일부가 닫힐 때까지 에러를 발생시킬 것입니다.</p>
<p>이 코드를 실행해 봅시다! 터미널에서 <code>cargo run</code>을 실행한 다음 웹 브라우저에서 _127.0.0.1:7878_로 접속하세요. 서버가 현재 어떤 데이터도 돌려보내지 않기 때문에 브라우저에는 “연결 재설정”과 같은 에러 메시지가 표시될 것입니다. 하지만 터미널을 보면 브라우저가 서버에 연결되었을 때 출력된 여러 메시지를 볼 수 있을 것입니다!</p>
<pre><code class="language-text">     Running `target/debug/hello`
Connection established!
Connection established!
Connection established!
</code></pre>
<p>때때로 한 번의 브라우저 요청에 대해 여러 메시지가 출력되는 것을 볼 수 있는데, 그 이유는 브라우저가 페이지에 대한 요청뿐만 아니라 브라우저 탭에 나타나는 <em>favicon.ico</em> 아이콘과 같은 다른 리소스에 대한 요청도 보내기 때문일 수 있습니다.</p>
<p>또한 서버가 데이터로 응답하지 않기 때문에 브라우저가 서버에 여러 번 연결을 시도하는 것일 수도 있습니다. <code>stream</code>이 스코프를 벗어나 루프 끝에서 드롭될 때, <code>drop</code> 구현의 일부로 연결이 닫힙니다. 브라우저는 문제가 일시적일 수 있다고 판단하여 닫힌 연결에 대해 재시도를 하기도 합니다. 중요한 점은 우리가 TCP 연결에 대한 핸들을 성공적으로 얻었다는 것입니다!</p>
<p>코드의 특정 버전 실행을 마쳤을 때는 <kbd>ctrl</kbd>-<kbd>c</kbd>를 눌러 프로그램을 중단하는 것을 잊지 마세요. 그런 다음 코드를 변경할 때마다 <code>cargo run</code> 명령을 실행하여 최신 코드가 실행되고 있는지 확인하며 프로그램을 다시 시작하세요.</p>
<h3 id="요청-읽기"><a class="header" href="#요청-읽기">요청 읽기</a></h3>
<p>브라우저로부터 요청을 읽는 기능을 구현해 봅시다! 먼저 연결을 얻는 것과 그 연결로 어떤 동작을 수행하는 것에 대한 관심사를 분리하기 위해, 연결 처리를 위한 새로운 함수를 시작하겠습니다. 이 새로운 <code>handle_connection</code> 함수에서는 TCP 스트림으로부터 데이터를 읽고 이를 출력하여 브라우저에서 전송되는 데이터를 확인할 것입니다. 코드를 예제 21-2와 같이 변경하세요.</p>
<Listing number="21-2" file-name="src/main.rs" caption="Reading from the `TcpStream` and printing the data">
<pre><pre class="playground"><code class="language-rust no_run edition2021">use std::{
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
};

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    println!("요청: {http_request:#?}");
}</code></pre></pre>
</Listing>
<p>스트림을 읽고 쓰기 위해 필요한 트레이트와 타입들에 접근할 수 있도록 <code>std::io::prelude</code>와 <code>std::io::BufReader</code>를 스코프로 가져옵니다. <code>main</code> 함수의 <code>for</code> 루프에서는 연결이 되었다는 메시지를 출력하는 대신, 새로운 <code>handle_connection</code> 함수를 호출하고 여기에 <code>stream</code>을 전달합니다.</p>
<p><code>handle_connection</code> 함수에서는 <code>stream</code>에 대한 참조를 감싸는 새로운 <code>BufReader</code> 인스턴스를 생성합니다. <code>BufReader</code>는 우리 대신 <code>std::io::Read</code> 트레이트 메서드들의 호출을 관리함으로써 버퍼링 기능을 추가해 줍니다.</p>
<p>브라우저가 우리 서버에 보내는 요청의 각 줄을 수집하기 위해 <code>http_request</code>라는 변수를 만듭니다. <code>Vec&lt;_&gt;</code> 타입 어노테이션을 추가하여 이 줄들을 벡터에 수집하고 싶다는 것을 명시합니다.</p>
<p><code>BufReader</code>는 <code>lines</code> 메서드를 제공하는 <code>std::io::BufRead</code> 트레이트를 구현합니다. <code>lines</code> 메서드는 줄바꿈 바이트를 만날 때마다 데이터 스트림을 쪼개어 <code>Result&lt;String, std::io::Error&gt;</code>의 반복자를 반환합니다. 각 <code>String</code>을 얻기 위해 각 <code>Result</code>에 대해 맵(map)을 수행하고 <code>unwrap</code>을 호출합니다. 데이터가 유효한 UTF-8이 아니거나 스트림을 읽는 중에 문제가 발생하면 <code>Result</code>는 에러가 될 수 있습니다. 다시 말씀드리지만, 실제 프로덕션 프로그램은 이러한 에러를 더 우아하게 처리해야 하지만, 여기서는 단순함을 위해 에러 발생 시 프로그램을 중단시키는 방법을 택했습니다.</p>
<p>브라우저는 두 개의 줄바꿈 문자를 연속으로 보내 HTTP 요청의 끝을 알립니다. 따라서 스트림에서 하나의 요청을 얻으려면 빈 문자열인 줄이 나올 때까지 줄을 읽어 들입니다. 줄들을 벡터에 수집한 후에는, 웹 브라우저가 우리 서버에 보내는 명령들을 살펴볼 수 있도록 예쁜 디버그 포맷(pretty debug formatting)을 사용하여 출력합니다.</p>
<p>이 코드를 실행해 봅시다! 프로그램을 시작하고 웹 브라우저에서 다시 요청을 보내세요. 브라우저에는 여전히 에러 페이지가 표시되겠지만, 터미널에 표시되는 우리 프로그램의 출력은 이제 다음과 유사할 것입니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/hello`
Request: [
    "GET / HTTP/1.1",
    "Host: 127.0.0.1:7878",
    "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:99.0) Gecko/20100101 Firefox/99.0",
    "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
    "Accept-Language: en-US,en;q=0.5",
    "Accept-Encoding: gzip, deflate, br",
    "DNT: 1",
    "Connection: keep-alive",
    "Upgrade-Insecure-Requests: 1",
    "Sec-Fetch-Dest: document",
    "Sec-Fetch-Mode: navigate",
    "Sec-Fetch-Site: none",
    "Sec-Fetch-User: ?1",
    "Cache-Control: max-age=0",
]
</code></pre>
<p>브라우저에 따라 출력이 약간 다를 수 있습니다. 이제 요청 데이터를 출력하고 있으므로, 요청의 첫 번째 줄에서 <code>GET</code> 뒤에 오는 경로를 살펴봄으로써 왜 한 번의 브라우저 요청으로부터 여러 개의 연결이 발생하는지 알 수 있습니다. 반복되는 연결들이 모두 _/_를 요청하고 있다면, 브라우저가 우리 프로그램으로부터 응답을 받지 못해 반복적으로 _/_를 가져오려고 시도하고 있음을 알 수 있습니다.</p>
<p>브라우저가 우리 프로그램에 무엇을 요청하고 있는지 이해하기 위해 이 요청 데이터를 분석해 봅시다.</p>
<h3 id="http-요청-자세히-살펴보기"><a class="header" href="#http-요청-자세히-살펴보기">HTTP 요청 자세히 살펴보기</a></h3>
<p>HTTP는 텍스트 기반 프로토콜이며, 요청은 다음과 같은 형식을 가집니다.</p>
<pre><code class="language-text">Method Request-URI HTTP-Version CRLF
headers CRLF
message-body
</code></pre>
<p>첫 번째 줄은 클라이언트가 무엇을 요청하고 있는지에 대한 정보를 담고 있는 _요청 라인(request line)_입니다. 요청 라인의 첫 번째 부분은 사용 중인 <em>메서드(method)</em> (예: <code>GET</code> 또는 <code>POST</code>)를 나타내며, 이는 클라이언트가 이 요청을 어떻게 하고 있는지를 설명합니다. 우리 클라이언트는 정보를 요청하고 있음을 의미하는 <code>GET</code> 요청을 사용했습니다.</p>
<p>요청 라인의 다음 부분은 클라이언트가 요청하는 _URI(Uniform Resource Identifier)_를 나타내는 _/_입니다. URI는 _URL(Uniform Resource Locator)_과 거의 비슷하지만 완전히 같지는 않습니다. 이번 장의 목적상 URI와 URL의 차이는 중요하지 않으므로, 여기서는 그냥 URI를 URL로 생각하셔도 무방합니다.</p>
<p>마지막 부분은 클라이언트가 사용하는 HTTP 버전이며, 요청 라인은 CRLF 시퀀스로 끝납니다. (CRLF는 _캐리지 리턴(carriage return)_과 _라인 피드(line feed)_의 약자로, 타자기 시절부터 쓰던 용어입니다!) CRLF 시퀀스는 <code>\r\n</code>으로도 쓸 수 있는데, 여기서 <code>\r</code>은 캐리지 리턴이고 <code>\n</code>은 라인 피드입니다. _CRLF 시퀀스_는 요청 라인을 나머지 요청 데이터와 분리합니다. CRLF가 출력될 때는 <code>\r\n</code> 대신 새로운 줄이 시작되는 것을 볼 수 있습니다.</p>
<p>지금까지 프로그램을 실행하여 받은 요청 라인 데이터를 보면, <code>GET</code>은 메서드이고 _/_는 요청 URI이며 <code>HTTP/1.1</code>은 버전임을 알 수 있습니다.</p>
<p>요청 라인 이후에 <code>Host:</code>로 시작하는 나머지 줄들은 헤더입니다. <code>GET</code> 요청은 본문(body)이 없습니다.</p>
<p>다른 브라우저에서 요청을 보내거나 _127.0.0.1:7878/test_와 같이 다른 주소를 요청하여 요청 데이터가 어떻게 변하는지 확인해 보세요.</p>
<p>이제 브라우저가 무엇을 요청하는지 알았으니, 데이터를 다시 보내봅시다!</p>
<h3 id="응답-작성하기"><a class="header" href="#응답-작성하기">응답 작성하기</a></h3>
<p>클라이언트 요청에 대한 응답으로 데이터를 보내는 기능을 구현하겠습니다. 응답은 다음과 같은 형식을 가집니다.</p>
<pre><code class="language-text">HTTP-Version Status-Code Reason-Phrase CRLF
headers CRLF
message-body
</code></pre>
<p>첫 번째 줄은 _상태 라인(status line)_으로, 응답에 사용된 HTTP 버전, 요청 결과를 요약하는 숫자 상태 코드, 그리고 상태 코드에 대한 텍스트 설명을 제공하는 사유 구문(reason phrase)을 포함합니다. CRLF 시퀀스 다음에는 헤더들이 오고, 또 다른 CRLF 시퀀스 뒤에 응답 본문이 옵니다.</p>
<p>다음은 HTTP 버전 1.1을 사용하고 상태 코드가 200이며 OK 사유 구문을 갖고 헤더와 본문이 없는 응답의 예입니다.</p>
<pre><code class="language-text">HTTP/1.1 200 OK\r\n\r\n
</code></pre>
<p>상태 코드 200은 표준 성공 응답입니다. 이 텍스트는 아주 작은 성공적인 HTTP 응답입니다. 성공적인 요청에 대한 응답으로 이것을 스트림에 써 봅시다! <code>handle_connection</code> 함수에서 요청 데이터를 출력하던 <code>println!</code>을 제거하고 예제 21-3의 코드로 교체하세요.</p>
<Listing number="21-3" file-name="src/main.rs" caption="Writing a tiny successful HTTP response to the stream">
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">use std::{
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let response = "HTTP/1.1 200 OK\r\n\r\n";

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
</Listing>
<p>첫 번째로 추가된 줄은 성공 메시지 데이터를 담는 <code>response</code> 변수를 정의합니다. 그런 다음 <code>response</code>에 대해 <code>as_bytes</code>를 호출하여 문자열 데이터를 바이트로 변환합니다. <code>stream</code>의 <code>write_all</code> 메서드는 이 바이트들을 받아 연결을 통해 직접 전송합니다. <code>write_all</code> 작업이 실패할 수 있으므로 이전과 마찬가지로 에러 결과에 대해 <code>unwrap</code>을 사용합니다. 다시 말씀드리지만, 실제 애플리케이션에서는 여기에 에러 처리를 추가해야 합니다. 마지막으로, <code>flush</code>는 모든 바이트가 연결에 쓰여질 때까지 기다렸다가 프로그램이 계속 진행되도록 합니다. <code>TcpStream</code>은 기본 운영 체제에 대한 호출을 최소화하기 위해 내부 버퍼를 포함하고 있습니다.</p>
<p>이러한 변경 사항들을 적용하고 코드를 실행하여 요청을 보내봅시다. 이제 터미널에 데이터를 출력하지 않으므로 Cargo의 출력 외에는 아무것도 보이지 않을 것입니다. 웹 브라우저에서 _127.0.0.1:7878_로 접속하면 에러 대신 빈 페이지가 나타날 것입니다. 여러분은 방금 HTTP 요청을 받고 응답을 보내는 과정을 직접 코딩하셨습니다!</p>
<h3 id="실제-html-반환하기"><a class="header" href="#실제-html-반환하기">실제 HTML 반환하기</a></h3>
<p>빈 페이지 이상의 것을 반환하는 기능을 구현해 봅시다. 프로젝트 디렉토리의 루트( <em>src</em> 디렉토리가 아닌 곳)에 새로운 파일 _hello.html_을 만드세요. 원하는 HTML을 무엇이든 넣으셔도 됩니다. 예제 21-4는 그중 한 가지 예시입니다.</p>
<Listing number="21-4" file-name="hello.html" caption="A sample HTML file to return in a response">
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="ko"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello!&lt;/h1&gt;
    &lt;p&gt;Hi from Rust&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
</Listing>
<p>이는 헤더와 약간의 텍스트가 있는 최소한의 HTML5 문서입니다. 요청을 받았을 때 서버에서 이를 반환하기 위해, 예제 21-5와 같이 <code>handle_connection</code>을 수정하여 HTML 파일을 읽고 이를 응답 본문에 추가하여 전송하도록 하겠습니다.</p>
<Listing number="21-5" file-name="src/main.rs" caption="Sending the contents of *hello.html* as the body of the response">
<pre><pre class="playground"><code class="language-rust no_run edition2021">use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
};
// --생략--

<span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let status_line = "HTTP/1.1 200 OK";
    let contents = fs::read_to_string("hello.html").unwrap();
    let length = contents.len();

    let response =
        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
</Listing>
<p>표준 라이브러리의 파일 시스템 모듈을 스코프로 가져오기 위해 <code>use</code>문에 <code>fs</code>를 추가했습니다. 파일 내용을 문자열로 읽어 들이는 코드는 익숙하실 것입니다. 12장의 예제 12-4에서 I/O 프로젝트를 위해 파일 내용을 읽을 때 사용했었습니다.</p>
<p>다음으로, <code>format!</code>을 사용하여 파일 내용을 성공 응답의 본문으로 추가합니다. 유효한 HTTP 응답임을 보장하기 위해, 응답 본문의 크기(이 경우에는 <code>hello.html</code>의 크기)로 설정된 <code>Content-Length</code> 헤더를 추가합니다.</p>
<p><code>cargo run</code>으로 이 코드를 실행하고 브라우저에서 _127.0.0.1:7878_에 접속해 보세요. 여러분의 HTML이 렌더링된 것을 볼 수 있을 것입니다!</p>
<p>현재 우리는 <code>http_request</code>에 담긴 요청 데이터를 무시하고 HTML 파일의 내용을 무조건적으로 되돌려보내고 있습니다. 즉, 브라우저에서 _127.0.0.1:7878/something-else_를 요청하더라도 동일한 HTML 응답을 받게 된다는 뜻입니다. 지금 우리 서버는 매우 제한적이며 대부분의 웹 서버가 하는 일을 하지 못합니다. 우리는 요청에 따라 응답을 커스터마이징하고, _/_에 대한 올바른 형식의 요청에 대해서만 HTML 파일을 반환하고 싶습니다.</p>
<h3 id="요청-검증-및-선택적-응답"><a class="header" href="#요청-검증-및-선택적-응답">요청 검증 및 선택적 응답</a></h3>
<p>지금 우리 웹 서버는 클라이언트가 무엇을 요청하든 파일에 있는 HTML을 반환합니다. HTML 파일을 반환하기 전에 브라우저가 _/_를 요청하고 있는지 확인하고, 그 외의 것을 요청하면 에러를 반환하는 기능을 추가해 봅시다. 이를 위해 예제 21-6에 표시된 대로 <code>handle_connection</code>을 수정해야 합니다. 이 새로운 코드는 수신된 요청의 내용을 우리가 알고 있는 _/_에 대한 요청 형식과 비교하고, <code>if</code>와 <code>else</code> 블록을 추가하여 요청을 다르게 처리합니다.</p>
<Listing number="21-6" file-name="src/main.rs" caption="Handling requests to */* differently from other requests">
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>// --생략--

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;stream);
    let request_line = buf_reader.lines().next().unwrap().unwrap();

    if request_line == "GET / HTTP/1.1" {
        let status_line = "HTTP/1.1 200 OK";
        let contents = fs::read_to_string("hello.html").unwrap();
        let length = contents.len();

        let response = format!(
            "{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}"
        );

        stream.write_all(response.as_bytes()).unwrap();
    } else {
        // 그 외의 요청
    }
}</code></pre></pre>
</Listing>
<p>우리는 HTTP 요청의 첫 번째 줄만 살펴볼 것이므로, 전체 요청을 벡터로 읽어 들이는 대신 반복자에서 첫 번째 아이템을 얻기 위해 <code>next</code>를 호출합니다. 첫 번째 <code>unwrap</code>은 <code>Option</code>을 처리하며 반복자에 아이템이 없으면 프로그램을 중단시킵니다. 두 번째 <code>unwrap</code>은 <code>Result</code>를 처리하며 예제 21-2에서 추가된 <code>map</code> 안에 있던 <code>unwrap</code>과 동일한 효과를 냅니다.</p>
<p>다음으로, <code>request_line</code>이 <em>/</em> 경로에 대한 GET 요청의 요청 라인과 일치하는지 확인합니다. 일치한다면 <code>if</code> 블록은 HTML 파일의 내용을 반환합니다.</p>
<p><code>request_line</code>이 <em>/</em> 경로에 대한 GET 요청과 일치하지 않는다면, 이는 우리가 다른 어떤 요청을 받았음을 의미합니다. 잠시 후에 모든 다른 요청에 응답하기 위한 코드를 <code>else</code> 블록에 추가할 것입니다.</p>
<p>이제 이 코드를 실행하고 _127.0.0.1:7878_을 요청해 보세요. _hello.html_에 있는 HTML을 받게 될 것입니다. _127.0.0.1:7878/something-else_와 같이 다른 요청을 하면, 예제 21-1과 21-2의 코드를 실행했을 때 보았던 것과 같은 연결 에러가 발생할 것입니다.</p>
<p>이제 요청한 콘텐츠를 찾을 수 없음을 나타내는 상태 코드 404와 함께 응답을 반환하도록 예제 21-7의 코드를 <code>else</code> 블록에 추가해 봅시다. 또한 최종 사용자에게 응답을 표시하기 위해 브라우저에서 렌더링할 HTML도 함께 반환할 것입니다.</p>
<Listing number="21-7" file-name="src/main.rs" caption="Responding with status code 404 and an error page if anything other than */* was requested">
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    if request_line == "GET / HTTP/1.1" {
</span><span class="boring">        let status_line = "HTTP/1.1 200 OK";
</span><span class="boring">        let contents = fs::read_to_string("hello.html").unwrap();
</span><span class="boring">        let length = contents.len();
</span><span class="boring">
</span><span class="boring">        let response = format!(
</span><span class="boring">            "{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}"
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        stream.write_all(response.as_bytes()).unwrap();
</span>    // --생략--
    } else {
        let status_line = "HTTP/1.1 404 NOT FOUND";
        let contents = fs::read_to_string("404.html").unwrap();
        let length = contents.len();

        let response = format!(
            "{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}"
        );

        stream.write_all(response.as_bytes()).unwrap();
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>여기서 우리 응답은 상태 코드 404와 사유 구문 <code>NOT FOUND</code>가 포함된 상태 라인을 가집니다. 응답 본문은 <em>404.html</em> 파일에 있는 HTML이 될 것입니다. 에러 페이지를 위해 <em>hello.html</em> 옆에 <em>404.html</em> 파일을 만들어야 합니다. 다시 말씀드리지만 원하는 HTML을 사용하시거나 예제 21-8의 HTML을 사용하세요.</p>
<Listing number="21-8" file-name="404.html" caption="Sample content for the page to send back with any 404 response">
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="ko"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Oops!&lt;/h1&gt;
    &lt;p&gt;Sorry, I don't know what you're asking for.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
</Listing>
<p>이러한 변경 사항을 적용하고 서버를 다시 실행하세요. _127.0.0.1:7878_을 요청하면 _hello.html_의 내용이 반환되어야 하며, _127.0.0.1:7878/foo_와 같은 다른 모든 요청은 _404.html_의 에러 HTML을 반환해야 합니다.</p>
<h3 id="약간의-리팩터링"><a class="header" href="#약간의-리팩터링">약간의 리팩터링</a></h3>
<p>현재 <code>if</code>와 <code>else</code> 블록에는 많은 중복이 있습니다. 둘 다 파일을 읽고 그 내용을 스트림에 쓰고 있습니다. 유일한 차이점은 상태 라인과 파일 이름뿐입니다. 이러한 차이점들을 상태 라인과 파일 이름의 값을 변수에 할당하는 별도의 <code>if</code>와 <code>else</code> 라인으로 추출하여 코드를 더 간결하게 만들어 봅시다. 그런 다음 파일 읽기와 응답 쓰기 코드에서 이 변수들을 무조건적으로 사용할 수 있습니다. 예제 21-9는 거대한 <code>if</code>와 <code>else</code> 블록을 교체한 후의 결과 코드를 보여줍니다.</p>
<Listing number="21-9" file-name="src/main.rs" caption="Refactoring the `if` and `else` blocks to contain only the code that differs between the two cases">
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>// --생략--

fn handle_connection(mut stream: TcpStream) {
    // --생략--
<span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span>
    let (status_line, filename) = if request_line == "GET / HTTP/1.1" {
        ("HTTP/1.1 200 OK", "hello.html")
    } else {
        ("HTTP/1.1 404 NOT FOUND", "404.html")
    };

    let contents = fs::read_to_string(filename).unwrap();
    let length = contents.len();

    let response =
        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre></pre>
</Listing>
<p>이제 <code>if</code>와 <code>else</code> 블록은 튜플 형태로 적절한 상태 라인과 파일 이름 값만 반환합니다. 그런 다음 19장에서 논의한 것처럼 <code>let</code> 문에서 패턴을 사용하는 구조 분해(destructuring)를 통해 이 두 값을 <code>status_line</code>과 <code>filename</code>에 할당합니다.</p>
<p>이전에 중복되었던 코드는 이제 <code>if</code>와 <code>else</code> 블록 밖에 있으며 <code>status_line</code>과 <code>filename</code> 변수를 사용합니다. 이렇게 하면 두 케이스 사이의 차이점을 더 쉽게 알 수 있으며, 파일 읽기 및 응답 쓰기 방식이 변경될 때 수정해야 할 곳이 한 곳뿐임을 의미합니다. 예제 21-9 코드의 동작은 예제 21-7과 동일합니다.</p>
<p>멋지네요! 이제 약 40줄의 러스트 코드로 특정 요청에는 콘텐츠 페이지로 응답하고 다른 모든 요청에는 404 응답을 보내는 간단한 웹 서버를 갖게 되었습니다.</p>
<p>현재 우리 서버는 단일 스레드에서 실행되므로 한 번에 하나의 요청만 처리할 수 있습니다. 몇 가지 느린 요청을 시뮬레이션하여 이것이 어떻게 문제가 될 수 있는지 살펴보겠습니다. 그런 다음 우리 서버가 한 번에 여러 요청을 처리할 수 있도록 수정하겠습니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch21-00-final-project-a-web-server.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch21-02-multithreaded.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch21-00-final-project-a-web-server.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch21-02-multithreaded.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
