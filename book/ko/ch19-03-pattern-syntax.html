<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>패턴 문법 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch19-03-pattern-syntax.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch19-03-pattern-syntax.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="패턴-문법"><a class="header" href="#패턴-문법">패턴 문법</a></h2>
<p>이 섹션에서는 패턴에서 유효한 모든 문법을 모아보고, 각각을 왜 그리고 언제 사용하고 싶을지 논의해 보겠습니다.</p>
<h3 id="리터럴-매칭하기"><a class="header" href="#리터럴-매칭하기">리터럴 매칭하기</a></h3>
<p>6장에서 보았듯이, 여러분은 패턴을 리터럴과 직접 매칭할 수 있습니다. 다음 코드는 몇 가지 예시를 보여줍니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 =&gt; println!("하나"),
        2 =&gt; println!("둘"),
        3 =&gt; println!("셋"),
        _ =&gt; println!("무엇이든"),
    }
<span class="boring">}</span></code></pre></pre>
<p>이 코드는 <code>x</code>의 값이 1이므로 <code>one</code>을 출력합니다. 이 문법은 특정한 구체적인 값을 받았을 때 어떤 동작을 취하게 하고 싶을 때 유용합니다.</p>
<h3 id="이름-붙은-변수-매칭하기"><a class="header" href="#이름-붙은-변수-매칭하기">이름 붙은 변수 매칭하기</a></h3>
<p>이름 붙은 변수는 모든 값에 매치되는 반박 불가능한 패턴이며, 우리는 이 책에서 여러 번 사용해 왔습니다. 하지만 <code>match</code>, <code>if let</code>, 또는 <code>while let</code> 표현식에서 이름 붙은 변수를 사용할 때는 복잡한 점이 있습니다. 이러한 표현식들은 각각 새로운 스코프를 시작하기 때문에, 표현식 내부의 패턴 일부로 선언된 변수는 모든 변수가 그러하듯 외부의 동일한 이름을 가진 변수를 섀도잉하게 됩니다. 목록 19-11에서는 <code>Some(5)</code> 값을 가진 변수 <code>x</code>와 <code>10</code> 값을 가진 변수 <code>y</code>를 선언합니다. 그런 다음 값 <code>x</code>에 대해 <code>match</code> 표현식을 만듭니다. 매치 가지의 패턴과 마지막의 <code>println!</code>을 살펴보고, 이 코드를 실행하거나 더 읽기 전에 코드가 무엇을 출력할지 맞춰보세요.</p>
<Listing number="19-11" file-name="src/main.rs" caption="A `match` expression with an arm that introduces a new variable which shadows an existing variable `y`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!("50을 얻었습니다"),
        Some(y) =&gt; println!("매치됨, y = {y}"),
        _ =&gt; println!("기본 케이스, x = {x:?}"),
    }

    println!("마지막에: x = {x:?}, y = {y}");
<span class="boring">}</span></code></pre></pre>
</Listing>
<p><code>match</code> 표현식이 실행될 때 어떤 일이 일어나는지 살펴봅시다. 첫 번째 매치 가지의 패턴은 <code>x</code>에 정의된 값과 매치되지 않으므로, 코드는 계속 진행됩니다.</p>
<p>두 번째 매치 가지의 패턴은 <code>Some</code> 값 내부의 모든 값과 매치될 <code>y</code>라는 새로운 변수를 도입합니다. 우리는 <code>match</code> 표현식 내부의 새로운 스코프에 있기 때문에, 이것은 새로운 <code>y</code> 변수이지 처음에 10이라는 값으로 선언한 <code>y</code>가 아닙니다. 이 새로운 <code>y</code> 바인딩은 <code>Some</code> 내부의 모든 값과 매치될 것이며, 이것이 우리가 <code>x</code>에 가지고 있는 것입니다. 따라서 이 새로운 <code>y</code>는 <code>x</code>에 있는 <code>Some</code> 내부의 값에 바인딩됩니다. 그 값은 <code>5</code>이므로, 해당 가지의 표현식이 실행되어 <code>Matched, y = 5</code>를 출력합니다.</p>
<p>만약 <code>x</code>가 <code>Some(5)</code> 대신 <code>None</code> 값이었다면, 처음 두 가지의 패턴은 매치되지 않았을 것이므로 값은 언더스코어에 매치되었을 것입니다. 우리는 언더스코어 가지의 패턴에서 <code>x</code> 변수를 도입하지 않았으므로, 표현식의 <code>x</code>는 여전히 섀도잉되지 않은 외부의 <code>x</code>입니다. 이 가상의 경우, <code>match</code>는 <code>Default case, x = None</code>을 출력할 것입니다.</p>
<p><code>match</code> 표현식이 끝나면 그 스코프가 종료되고, 내부의 <code>y</code> 스코프도 함께 종료됩니다. 마지막 <code>println!</code>은 <code>at the end: x = Some(5), y = 10</code>을 출력합니다.</p>
<p>기존 <code>y</code> 변수를 섀도잉하는 새로운 변수를 도입하는 대신, 외부의 <code>x</code>와 <code>y</code> 값을 비교하는 <code>match</code> 표현식을 만들려면 매치 가드(match guard) 조건문을 사용해야 합니다. 매치 가드에 대해서는 나중에 <a href="#extra-conditionals-with-match-guards">“매치 가드를 이용한 추가 조건”</a><!-- ignore --> 섹션에서 다룰 것입니다.</p>
<h3 id="다중-패턴"><a class="header" href="#다중-패턴">다중 패턴</a></h3>
<p>패턴 <em>or</em> 연산자인 <code>|</code> 문법을 사용하여 여러 패턴을 매칭할 수 있습니다. 예를 들어 다음 코드에서는 <code>x</code>의 값을 매치 가지들과 비교하는데, 첫 번째 가지에 <em>or</em> 옵션이 있습니다. 즉, <code>x</code>의 값이 해당 가지의 값들 중 하나라도 일치하면 그 가지의 코드가 실행됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 | 2 =&gt; println!("하나 또는 둘"),
        3 =&gt; println!("셋"),
        _ =&gt; println!("무엇이든"),
    }
<span class="boring">}</span></code></pre></pre>
<p>이 코드는 <code>one or two</code>를 출력합니다.</p>
<h3 id="를-사용한-값의-범위-매칭"><a class="header" href="#를-사용한-값의-범위-매칭"><code>..=</code>를 사용한 값의 범위 매칭</a></h3>
<p><code>..=</code> 문법은 포함 범위(inclusive range)의 값들을 매칭할 수 있게 해줍니다. 다음 코드에서 패턴이 주어진 범위 내의 어떤 값과 매치되면 해당 가지가 실행됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 5;

    match x {
        1..=5 =&gt; println!("하나부터 다섯까지"),
        _ =&gt; println!("그 외의 것"),
    }
<span class="boring">}</span></code></pre></pre>
<p>만약 <code>x</code>가 1, 2, 3, 4, 또는 5라면 첫 번째 가지가 매치됩니다. 이 문법은 동일한 의미를 <code>|</code> 연산자로 표현하는 것보다 여러 값을 매칭할 때 더 편리합니다. 만약 <code>|</code>를 사용했다면 <code>1 | 2 | 3 | 4 | 5</code>라고 명시해야 했을 것입니다. 범위를 지정하는 것은 훨씬 짧으며, 특히 1에서 1,000 사이의 임의의 숫자를 매칭하고 싶을 때 유용합니다!</p>
<p>컴파일러는 컴파일 타임에 범위가 비어 있지 않은지 확인합니다. 러스트가 범위가 비어 있는지 여부를 판단할 수 있는 유일한 타입은 <code>char</code>와 숫자 값뿐이므로, 범위는 숫자나 <code>char</code> 값에 대해서만 허용됩니다.</p>
<p>다음은 <code>char</code> 값의 범위를 사용하는 예제입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 'c';

    match x {
        'a'..='j' =&gt; println!("앞쪽 ASCII 문자"),
        'k'..='z' =&gt; println!("뒤쪽 ASCII 문자"),
        _ =&gt; println!("그 외의 것"),
    }
<span class="boring">}</span></code></pre></pre>
<p>러스트는 <code>'c'</code>가 첫 번째 패턴의 범위 내에 있음을 판단하고 <code>early ASCII letter</code>를 출력합니다.</p>
<h3 id="값을-분해하기-위한-구조분해"><a class="header" href="#값을-분해하기-위한-구조분해">값을 분해하기 위한 구조분해</a></h3>
<p>구조체, 열거형, 튜플을 구조분해하여 이 값들의 서로 다른 부분들을 사용하기 위해 패턴을 사용할 수도 있습니다. 각 값을 하나씩 살펴봅시다.</p>
<h4 id="구조체-구조분해하기"><a class="header" href="#구조체-구조분해하기">구조체 구조분해하기</a></h4>
<p>목록 19-12는 <code>let</code> 문과 패턴을 사용하여 분해할 수 있는 <code>x</code>와 <code>y</code> 두 필드를 가진 <code>Point</code> 구조체를 보여줍니다.</p>
<Listing number="19-12" file-name="src/main.rs" caption="Destructuring a struct’s fields into separate variables">
<pre><pre class="playground"><code class="language-rust edition2021">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}</code></pre></pre>
</Listing>
<p>이 코드는 <code>p</code> 구조체의 <code>x</code>와 <code>y</code> 필드 값에 매치되는 변수 <code>a</code>와 <code>b</code>를 생성합니다. 이 예제는 패턴의 변수 이름이 구조체의 필드 이름과 반드시 일치할 필요는 없음을 보여줍니다. 하지만 어떤 변수가 어떤 필드에서 왔는지 더 쉽게 기억하기 위해 변수 이름을 필드 이름과 일치시키는 것이 일반적입니다. 이러한 흔한 사용법 때문에, 그리고 <code>let Point { x: x, y: y } = p;</code>라고 쓰는 것이 많은 중복을 포함하기 때문에, 러스트는 구조체 필드와 매치되는 패턴에 대한 단축 문법을 제공합니다. 구조체 필드의 이름만 나열하면 되며, 패턴으로부터 생성된 변수들은 동일한 이름을 갖게 됩니다. 목록 19-13은 목록 19-12의 코드와 동일하게 동작하지만, <code>let</code> 패턴에서 생성된 변수들은 <code>a</code>, <code>b</code> 대신 <code>x</code>, <code>y</code>가 됩니다.</p>
<Listing number="19-13" file-name="src/main.rs" caption="Destructuring struct fields using struct field shorthand">
<pre><pre class="playground"><code class="language-rust edition2021">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}</code></pre></pre>
</Listing>
<p>이 코드는 변수 <code>p</code>의 <code>x</code>와 <code>y</code> 필드에 매치되는 변수 <code>x</code>와 <code>y</code>를 생성합니다. 그 결과 변수 <code>x</code>와 <code>y</code>는 <code>p</code> 구조체의 값들을 담게 됩니다.</p>
<p>모든 필드에 대해 변수를 생성하는 대신, 구조체 패턴의 일부로 리터럴 값을 사용하여 구조분해할 수도 있습니다. 이를 통해 다른 필드들을 구조분해할 변수들을 생성하면서 동시에 일부 필드들이 특정 값을 가졌는지 테스트할 수 있습니다.</p>
<p>목록 19-14에서는 <code>Point</code> 값을 세 가지 경우로 나누는 <code>match</code> 표현식을 보여줍니다. 축 <code>x</code> 위에 직접 놓인 점(<code>y = 0</code>인 경우), 축 <code>y</code> 위에 놓인 점(<code>x = 0</code>), 혹은 둘 다 아닌 경우입니다.</p>
<Listing number="19-14" file-name="src/main.rs" caption="Destructuring and matching literal values in one pattern">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!("x축 위의 {x}에 있습니다"),
        Point { x: 0, y } =&gt; println!("y축 위의 {y}에 있습니다"),
        Point { x, y } =&gt; {
            println!("어느 축 위에도 있지 않습니다: ({x}, {y})");
        }
    }
}</code></pre></pre>
</Listing>
<p>첫 번째 가지는 <code>y</code> 필드의 값이 리터럴 <code>0</code>과 매치되도록 지정함으로써 <code>x</code>축 위에 놓인 모든 점과 매치됩니다. 이 패턴은 여전히 해당 가지의 코드에서 사용할 수 있는 <code>x</code> 변수를 생성합니다.</p>
<p>마찬가지로, 두 번째 가지는 <code>x</code> 필드의 값이 <code>0</code>인 경우 매치되도록 지정하여 <code>y</code>축 위의 모든 점과 매치되며, <code>y</code> 필드 값을 위한 변수 <code>y</code>를 생성합니다. 세 번째 가지는 어떠한 리터럴도 지정하지 않으므로 다른 모든 <code>Point</code>와 매치되며 <code>x</code>와 <code>y</code> 필드 모두에 대해 변수를 생성합니다.</p>
<p>이 예제에서 값 <code>p</code>는 <code>x</code>가 0을 포함하고 있으므로 두 번째 가지와 매치됩니다. 따라서 이 코드는 <code>y축 위의 7에 있습니다</code>를 출력할 것입니다.</p>
<p><code>match</code> 표현식은 첫 번째로 매칭되는 패턴을 찾으면 가지 확인을 멈춘다는 점을 기억하세요. 따라서 <code>Point { x: 0, y: 0}</code>이 <code>x</code>축과 <code>y</code>축 모두 위에 있을지라도, 이 코드는 오직 <code>x축 위의 0에 있습니다</code>만 출력할 것입니다.</p>
<h4 id="열거형-구조분해하기"><a class="header" href="#열거형-구조분해하기">열거형 구조분해하기</a></h4>
<p>우리는 이 책에서 열거형을 구조분해해 왔지만(예를 들어 6장의 목록 6-5), 열거형을 구조분해하는 패턴이 열거형 내부에 데이터가 정의된 방식과 일치한다는 점을 아직 명시적으로 논의하지 않았습니다. 예로서, 목록 19-15에서는 목록 6-2의 <code>Message</code> 열거형을 사용하고 각각의 내부 값을 구조분해하는 패턴을 가진 <code>match</code>를 작성합니다.</p>
<Listing number="19-15" file-name="src/main.rs" caption="Destructuring enum variants that hold different kinds of values">
<pre><pre class="playground"><code class="language-rust edition2021">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            println!("Quit 변형은 구조분해할 데이터가 없습니다.");
        }
        Message::Move { x, y } =&gt; {
            println!("x 방향으로 {x}만큼, y 방향으로 {y}만큼 이동합니다");
        }
        Message::Write(text) =&gt; {
            println!("텍스트 메시지: {text}");
        }
        Message::ChangeColor(r, g, b) =&gt; {
            println!("색상을 빨간색 {r}, 녹색 {g}, 파란색 {b}으로 변경합니다");
        }
    }
}</code></pre></pre>
</Listing>
<p>이 코드는 <code>색상을 빨간색 0, 녹색 160, 파란색 255로 변경합니다</code>를 출력할 것입니다. <code>msg</code>의 값을 변경하여 다른 가지의 코드가 실행되는 것을 확인해 보세요.</p>
<p><code>Message::Quit</code>과 같이 아무런 데이터도 없는 열거형 변형의 경우, 해당 값을 더 이상 구조분해할 수 없습니다. 오직 리터럴 <code>Message::Quit</code> 값에 대해서만 매칭할 수 있으며, 해당 패턴에는 변수가 없습니다.</p>
<p><code>Message::Move</code>와 같은 구조체 형태의 열거형 변형의 경우, 구조체를 매칭할 때 사용하는 것과 유사한 패턴을 사용할 수 있습니다. 변형 이름 뒤에 중괄호를 넣고 변수와 함께 필드들을 나열하여, 해당 가지의 코드에서 사용할 수 있도록 조각들을 분리해 냅니다. 여기서는 목록 19-13에서 했던 것처럼 단축 형태를 사용합니다.</p>
<p>하나의 요소를 가진 튜플을 담는 <code>Message::Write</code>나 세 개의 요소를 가진 튜플을 담는 <code>Message::ChangeColor</code>와 같은 튜플 형태의 열거형 변형의 경우, 패턴은 튜플을 매칭할 때 지정하는 패턴과 유사합니다. 패턴 내 변수의 개수는 매칭하려는 변형의 요소 개수와 일치해야 합니다.</p>
<h4 id="중첩된-구조체와-열거형-구조분해하기"><a class="header" href="#중첩된-구조체와-열거형-구조분해하기">중첩된 구조체와 열거형 구조분해하기</a></h4>
<p>지금까지의 예제들은 모두 한 단계 깊이의 구조체나 열거형을 매칭하는 것이었지만, 매칭은 중첩된 아이템에 대해서도 작동할 수 있습니다! 예를 들어, 목록 19-16에 나타난 것처럼 <code>ChangeColor</code> 메시지에서 RGB와 HSV 색상을 지원하도록 목록 19-15의 코드를 리팩터링할 수 있습니다.</p>
<Listing number="19-16" caption="Matching on nested enums">
<pre><pre class="playground"><code class="language-rust edition2021">enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; {
            println!("색상을 빨간색 {r}, 녹색 {g}, 파란색 {b}으로 변경합니다");
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; {
            println!("색상을 색상 {h}, 채도 {s}, 명도 {v}로 변경합니다");
        }
        _ =&gt; (),
    }
}</code></pre></pre>
</Listing>
<p><code>match</code> 표현식의 첫 번째 가지 패턴은 <code>Color::Rgb</code> 변형을 포함하는 <code>Message::ChangeColor</code> 열거형 변형과 매치됩니다. 그런 다음 패턴은 세 개의 내부 <code>i32</code> 값에 바인딩됩니다. 두 번째 가지의 패턴 또한 <code>Message::ChangeColor</code> 열거형 변형과 매치되지만, 내부 열거형은 대신 <code>Color::Hsv</code>와 매치됩니다. 우리는 두 개의 열거형이 관련되어 있음에도 불구하고 하나의 <code>match</code> 표현식 내에서 이러한 복잡한 조건들을 지정할 수 있습니다.</p>
<h4 id="구조체와-튜플-구조분해하기"><a class="header" href="#구조체와-튜플-구조분해하기">구조체와 튜플 구조분해하기</a></h4>
<p>우리는 구조분해 패턴을 훨씬 더 복잡한 방식으로 섞고, 매치하고, 중첩할 수 있습니다. 다음 예제는 튜플 내부에 구조체와 튜플을 중첩시키고 모든 원시 값들을 구조분해하는 복잡한 구조분해를 보여줍니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span><span class="boring">    struct Point {
</span><span class="boring">        x: i32,
</span><span class="boring">        y: i32,
</span><span class="boring">    }
</span><span class="boring">
</span>    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
<span class="boring">}</span></code></pre></pre>
<p>이 코드는 복잡한 타입을 구성 요소별로 분해하여 우리가 관심 있는 값들을 개별적으로 사용할 수 있게 해줍니다.</p>
<p>패턴을 이용한 구조분해는 구조체의 각 필드 값과 같이 값의 조각들을 서로 개별적으로 사용할 수 있는 편리한 방법입니다.</p>
<h3 id="패턴에서-값-무시하기"><a class="header" href="#패턴에서-값-무시하기">패턴에서 값 무시하기</a></h3>
<p>여러분은 <code>match</code>의 마지막 가지에서처럼 패턴에서 값을 무시하는 것이 가끔 유용하다는 것을 보았습니다. 이는 실제로 아무것도 하지 않지만 나머지 모든 가능한 값들을 처리하는 포괄적인 처리를 얻기 위함입니다. 패턴에서 전체 값이나 값의 일부를 무시하는 방법에는 몇 가지가 있습니다: <code>_</code> 패턴 사용하기(이미 보았습니다), 다른 패턴 내에서 <code>_</code> 패턴 사용하기, 언더스코어로 시작하는 이름 사용하기, 또는 값의 나머지 부분을 무시하기 위해 <code>..</code> 사용하기가 그것입니다. 이 패턴들을 각각 어떻게 그리고 왜 사용하는지 알아봅시다.</p>
<h4 id="_로-전체-값-무시하기"><a class="header" href="#_로-전체-값-무시하기"><code>_</code>로 전체 값 무시하기</a></h4>
<p>우리는 어떤 값과도 매치되지만 값에 바인딩되지는 않는 와일드카드 패턴으로 언더스코어를 사용해 왔습니다. 이는 특히 <code>match</code> 표현식의 마지막 가지로서 유용하지만, 목록 19-17에 나타난 것처럼 함수 매개변수를 포함한 모든 패턴에서 사용할 수 있습니다.</p>
<Listing number="19-17" file-name="src/main.rs" caption="Using `_` in a function signature">
<pre><pre class="playground"><code class="language-rust edition2021">fn foo(_: i32, y: i32) {
    println!("이 코드는 오직 y 매개변수만 사용합니다: {y}");
}

fn main() {
    foo(3, 4);
}</code></pre></pre>
</Listing>
<p>이 코드는 첫 번째 인수로 전달된 값 <code>3</code>을 완전히 무시하고, <code>이 코드는 오직 y 매개변수만 사용합니다: 4</code>를 출력할 것입니다.</p>
<p>대부분의 경우 특정 함수 매개변수가 더 이상 필요하지 않다면, 사용하지 않는 매개변수를 포함하지 않도록 시그니처를 변경할 것입니다. 함수 매개변수를 무시하는 것은 예를 들어, 특정 타입 시그니처가 필요한 트레이트를 구현하지만 구현부의 함수 본문에서는 매개변수 중 하나가 필요하지 않은 경우에 특히 유용할 수 있습니다. 그러면 대신 이름을 사용했을 때와 달리 사용하지 않는 함수 매개변수에 대한 컴파일러 경고를 피할 수 있습니다.</p>
<h4 id="중첩된-_로-값의-일부-무시하기"><a class="header" href="#중첩된-_로-값의-일부-무시하기">중첩된 <code>_</code>로 값의 일부 무시하기</a></h4>
<p>또한 값의 일부만 테스트하고 싶지만 실행하려는 해당 코드에서 다른 부분은 사용할 필요가 없을 때, 다른 패턴 내부에서 <code>_</code>를 사용하여 값의 일부만 무시할 수 있습니다. 목록 19-18은 설정값을 관리하는 코드를 보여줍니다. 비즈니스 요구사항은 사용자가 설정의 기존 커스터마이징을 덮어쓰는 것은 허용되지 않지만, 현재 설정이 해제되어 있다면 설정을 해제하거나 값을 줄 수 있어야 한다는 것입니다.</p>
<Listing number="19-18" caption=" Using an underscore within patterns that match `Some` variants when we don’t need to use the value inside the `Some`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut setting_value = Some(5);
    let new_setting_value = Some(10);

    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) =&gt; {
            println!("기존의 커스터마이징된 값을 덮어쓸 수 없습니다");
        }
        _ =&gt; {
            setting_value = new_setting_value;
        }
    }

    println!("설정은 {setting_value:?}입니다");
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 코드는 <code>기존의 커스터마이징된 값을 덮어쓸 수 없습니다</code>를 출력한 다음 <code>설정은 Some(5)입니다</code>를 출력할 것입니다. 첫 번째 매치 가지에서, 우리는 어느 <code>Some</code> 변형 내부의 값에 대해서도 매칭하거나 사용할 필요가 없지만, <code>setting_value</code>와 <code>new_setting_value</code>가 모두 <code>Some</code> 변형인 경우를 테스트할 필요는 있습니다. 그 경우 <code>setting_value</code>를 변경하지 않는 이유를 출력하고, 값은 변경되지 않습니다.</p>
<p>두 번째 가지의 <code>_</code> 패턴으로 표현된 모든 다른 경우(<code>setting_value</code>나 <code>new_setting_value</code> 중 하나라도 <code>None</code>인 경우)에는 <code>new_setting_value</code>가 <code>setting_value</code>가 되는 것을 허용하고 싶습니다.</p>
<p>또한 특정 값들을 무시하기 위해 하나의 패턴 내 여러 곳에서 언더스코어를 사용할 수 있습니다. 목록 19-19는 5개의 아이템을 가진 튜플에서 두 번째와 네 번째 값을 무시하는 예제를 보여줍니다.</p>
<Listing number="19-19" caption="Ignoring multiple parts of a tuple">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) =&gt; {
            println!("어떤 숫자들: {first}, {third}, {fifth}")
        }
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 코드는 <code>어떤 숫자들: 2, 8, 32</code>를 출력하고, 값 4와 16은 무시될 것입니다.</p>
<h4 id="변수-이름을-_로-시작하여-사용하지-않는-변수-무시하기"><a class="header" href="#변수-이름을-_로-시작하여-사용하지-않는-변수-무시하기">변수 이름을 <code>_</code>로 시작하여 사용하지 않는 변수 무시하기</a></h4>
<p>변수를 만들고 어디에서도 사용하지 않는다면, 사용하지 않는 변수는 버그일 가능성이 있기 때문에 러스트는 보통 경고를 보냅니다. 하지만 프로토타이핑을 하거나 프로젝트를 막 시작했을 때처럼, 아직 사용하지 않을 변수를 미리 만들어두는 것이 유용할 때가 있습니다. 이런 상황에서는 변수 이름을 언더스코어로 시작함으로써 러스트에게 해당 변수에 대해 경고하지 말라고 말할 수 있습니다. 목록 19-20에서 우리는 두 개의 사용하지 않는 변수를 생성하지만, 이 코드를 컴파일하면 오직 그중 하나에 대해서만 경고를 받게 될 것입니다.</p>
<Listing number="19-20" file-name="src/main.rs" caption="Starting a variable name with an underscore to avoid getting unused variable warnings">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let _x = 5;
    let y = 10;
}</code></pre></pre>
</Listing>
<p>여기서 우리는 변수 <code>y</code>를 사용하지 않았다는 경고를 받지만, <code>_x</code>를 사용하지 않았다는 경고는 받지 않습니다.</p>
<p>단순히 <code>_</code>만 사용하는 것과 언더스코어로 시작하는 이름을 사용하는 것 사이에는 미묘한 차이가 있음에 주의하세요. <code>_x</code> 문법은 여전히 값을 변수에 바인딩하지만, <code>_</code>는 전혀 바인딩하지 않습니다. 이 구분이 중요한 사례를 보여주기 위해, 목록 19-21은 우리에게 에러를 발생시킬 것입니다.</p>
<Listing number="19-21" caption="An unused variable starting with an underscore still binds the value, which might take ownership of the value">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s = Some(String::from("Hello!"));

    if let Some(_s) = s {
        println!("문자열을 발견했습니다");
    }

    println!("{s:?}");
<span class="boring">}</span></code></pre>
</Listing>
<p>우리는 <code>s</code> 값이 여전히 <code>_s</code>로 이동(move)되어 <code>s</code>를 다시 사용할 수 없게 되기 때문에 에러를 받게 됩니다. 하지만 언더스코어 그 자체를 사용하는 것은 값에 바인딩되지 않습니다. 목록 19-22는 <code>s</code>가 <code>_</code>로 이동되지 않기 때문에 아무런 에러 없이 컴파일될 것입니다.</p>
<Listing number="19-22" caption="Using an underscore does not bind the value">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let s = Some(String::from("Hello!"));

    if let Some(_) = s {
        println!("문자열을 발견했습니다");
    }

    println!("{s:?}");
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 코드는 우리가 <code>s</code>를 어디에도 바인딩하지 않았으므로 잘 작동합니다. 즉, 이동되지 않았습니다.</p>
<h4 id="를-사용하여-값의-나머지-부분-무시하기"><a class="header" href="#를-사용하여-값의-나머지-부분-무시하기"><code>..</code>를 사용하여 값의 나머지 부분 무시하기</a></h4>
<p>많은 부분을 가진 값의 경우, <code>..</code> 문법을 사용하여 특정 부분만 사용하고 나머지는 무시할 수 있습니다. 이를 통해 무시할 각 값에 대해 언더스코어를 나열해야 하는 수고를 덜 수 있습니다. <code>..</code> 패턴은 패턴의 나머지 부분에서 명시적으로 매칭하지 않은 값의 모든 부분을 무시합니다. 목록 19-23에서는 3차원 공간의 좌표를 담는 <code>Point</code> 구조체가 있습니다. <code>match</code> 표현식에서 우리는 오직 <code>x</code> 좌표에 대해서만 작업하고 <code>y</code>와 <code>z</code> 필드의 값은 무시하고 싶습니다.</p>
<Listing number="19-23" caption="Ignoring all fields of a `Point` except for `x` by using `..`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } =&gt; println!("x는 {x}입니다"),
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>우리는 <code>x</code> 값을 나열하고 그 뒤에 단순히 <code>..</code> 패턴을 포함시킵니다. 이는 <code>y: _</code>와 <code>z: _</code>를 일일이 나열하는 것보다 빠릅니다. 특히 필드가 아주 많은 구조체에서 오직 한두 개의 필드만이 관련이 있는 상황에서 작업할 때 유용합니다.</p>
<p><code>..</code> 문법은 필요한 만큼의 많은 값으로 확장될 것입니다. 목록 19-24는 튜플과 함께 <code>..</code>를 사용하는 방법을 보여줍니다.</p>
<Listing number="19-24" file-name="src/main.rs" caption="Matching only the first and last values in a tuple and ignoring all other values">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!("어떤 숫자들: {first}, {last}");
        }
    }
}</code></pre></pre>
</Listing>
<p>이 코드에서 첫 번째와 마지막 값은 <code>first</code>와 <code>last</code>에 매치됩니다. <code>..</code>은 중간에 있는 모든 것을 매치하고 무시할 것입니다.</p>
<p>하지만 <code>..</code> 사용은 모호하지 않아야 합니다. 어떤 값이 매칭을 위한 것이고 어떤 값이 무시되어야 하는지가 불명확하다면, 러스트는 에러를 발생시킵니다. 목록 19-25는 <code>..</code>를 모호하게 사용한 예제를 보여주며, 이 코드는 컴파일되지 않습니다.</p>
<Listing number="19-25" file-name="src/main.rs" caption="An attempt to use `..` in an ambiguous way">
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!("어떤 숫자들: {second}")
        },
    }
}</code></pre>
</Listing>
<p>이 예제를 컴파일하면 다음과 같은 에러를 얻게 됩니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error: `..`은 튜플 패턴당 한 번만 사용할 수 있습니다
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |          --          ^^ 튜플 패턴당 한 번만 사용할 수 있습니다
  |          |
  |          이전에 여기서 사용되었습니다

error: 1개의 이전 에러로 인해 `patterns` (바이너리 "patterns")를 컴파일할 수 없습니다
</code></pre>
<p>러스트가 <code>second</code>와 매치하기 전에 튜플에서 얼마나 많은 값을 무시해야 할지, 그리고 그 후에 얼마나 더 많은 값을 무시해야 할지 결정하는 것은 불가능합니다. 이 코드는 <code>2</code>를 무시하고 <code>second</code>를 <code>4</code>에 바인딩한 다음 <code>8</code>, <code>16</code>, <code>32</code>를 무시하겠다는 의미일 수도 있고, <code>2</code>와 <code>4</code>를 무시하고 <code>second</code>를 <code>8</code>에 바인딩한 다음 <code>16</code>과 <code>32</code>를 무시하겠다는 의미일 수도 있는 등 그 해석이 다양합니다. 변수 이름 <code>second</code>는 러스트에게 특별한 의미가 없으므로, 이와 같이 두 곳에서 <code>..</code>를 사용하는 것은 모호하여 컴파일러 에러가 발생합니다.</p>
<h3 id="매치-가드를-이용한-추가-조건"><a class="header" href="#매치-가드를-이용한-추가-조건">매치 가드를 이용한 추가 조건</a></h3>
<p>_매치 가드(match guard)_는 <code>match</code> 가지의 패턴 뒤에 지정되는 추가적인 <code>if</code> 조건으로, 해당 가지가 선택되기 위해 패턴 매칭과 함께 이 조건도 만족되어야 합니다. 매치 가드는 패턴만으로는 표현할 수 없는 더 복잡한 개념을 표현할 때 유용합니다. 매치 가드는 <code>match</code> 표현식에서만 사용할 수 있으며, <code>if let</code>이나 <code>while let</code> 표현식에서는 사용할 수 없습니다.</p>
<p>매치 가드의 조건에서는 패턴에서 생성된 변수를 사용할 수 있습니다. 목록 19-26은 첫 번째 가지가 <code>Some(x)</code> 패턴을 가지면서 <code>if x % 2 == 0</code>(숫자가 짝수라면 참)이라는 매치 가드도 가지고 있는 <code>match</code>를 보여줍니다.</p>
<Listing number="19-26" caption="Adding a match guard to a pattern">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let num = Some(4);

    match num {
        Some(x) if x % 2 == 0 =&gt; println!("숫자 {x}는 짝수입니다"),
        Some(x) =&gt; println!("숫자 {x}는 홀수입니다"),
        None =&gt; (),
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 예제는 <code>숫자 4는 짝수입니다</code>를 출력할 것입니다. <code>num</code>이 첫 번째 가지의 패턴과 비교될 때 <code>Some(4)</code>는 <code>Some(x)</code>와 매치되므로 매칭에 성공합니다. 그다음 매치 가드가 <code>x</code>를 2로 나눈 나머지가 0인지 확인하고, 참이므로 첫 번째 가지가 선택됩니다.</p>
<p>만약 <code>num</code>이 대신 <code>Some(5)</code>였다면, 첫 번째 가지의 매치 가드는 5를 2로 나눈 나머지가 1(0이 아님)이므로 거짓이 되었을 것입니다. 그러면 러스트는 두 번째 가지로 이동할 것이고, 두 번째 가지는 매치 가드가 없으므로 모든 <code>Some</code> 변형과 매치됩니다.</p>
<p>패턴 내에서는 <code>if x % 2 == 0</code> 조건을 표현할 방법이 없으므로, 매치 가드는 이러한 로직을 표현할 수 있는 능력을 제공합니다. 이러한 추가적인 표현력의 단점은 매치 가드 표현식이 포함될 때 컴파일러가 철저함(exhaustiveness) 검사를 시도하지 않는다는 점입니다.</p>
<p>목록 19-11에서 우리는 패턴 섀도잉 문제를 해결하기 위해 매치 가드를 사용할 수 있다고 언급했습니다. <code>match</code> 표현식 외부의 변수를 사용하는 대신 <code>match</code> 내의 패턴 안에서 새로운 변수를 생성했던 것을 기억해 보세요. 그 새로운 변수는 외부 변수의 값에 대해 테스트할 수 없음을 의미했습니다. 목록 19-27은 매치 가드를 사용하여 이 문제를 해결하는 방법을 보여줍니다.</p>
<Listing number="19-27" file-name="src/main.rs" caption="Using a match guard to test for equality with an outer variable">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!("50을 얻었습니다"),
        Some(n) if n == y =&gt; println!("매치됨, n = {n}"),
        _ =&gt; println!("기본 케이스, x = {x:?}"),
    }

    println!("마지막에: x = {x:?}, y = {y}");
}</code></pre></pre>
</Listing>
<p>이제 이 코드는 <code>기본 케이스, x = Some(5)</code>을 출력할 것입니다. 두 번째 매치 가지의 패턴은 외부의 <code>y</code>를 섀도잉할 새로운 변수 <code>y</code>를 도입하지 않으므로, 매치 가드에서 외부의 <code>y</code>를 사용할 수 있습니다. 외부의 <code>y</code>를 섀도잉했을 <code>Some(y)</code>로 패턴을 지정하는 대신, 우리는 <code>Some(n)</code>을 지정합니다. 이는 <code>match</code> 외부에 <code>n</code> 변수가 없으므로 아무것도 섀도잉하지 않는 새로운 변수 <code>n</code>을 생성합니다.</p>
<p>매치 가드 <code>if n == y</code>는 패턴이 아니므로 새로운 변수를 도입하지 않습니다. 이 <code>y</code>는 새로운 <code>y</code>가 섀도잉하는 것이 아니라 <em>외부의</em> <code>y</code>이며, 우리는 <code>n</code>과 <code>y</code>를 비교함으로써 외부의 <code>y</code>와 동일한 값을 가진 값을 찾을 수 있습니다.</p>
<p>매치 가드에서 <em>or</em> 연산자인 <code>|</code>를 사용하여 여러 패턴을 지정할 수도 있습니다. 이때 매치 가드 조건은 모든 패턴에 적용됩니다. 목록 19-28은 <code>|</code>를 사용하는 패턴과 매치 가드를 결합할 때의 우선순위를 보여줍니다. 이 예제의 중요한 점은 <code>if y</code> 매치 가드가 비록 <code>6</code>에만 적용되는 것처럼 보일지라도, <code>4</code>, <code>5</code>, <em>그리고</em> <code>6</code> 모두에 적용된다는 것입니다.</p>
<Listing number="19-28" caption="Combining multiple patterns with a match guard">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let x = 4;
    let y = false;

    match x {
        4 | 5 | 6 if y =&gt; println!("네"),
        _ =&gt; println!("아니요"),
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>매치 조건은 <code>x</code>의 값이 <code>4</code>, <code>5</code>, 또는 <code>6</code>과 같고 <em>동시에</em> <code>y</code>가 <code>true</code>인 경우에만 해당 가지가 매치된다고 명시합니다. 이 코드가 실행될 때, <code>x</code>가 <code>4</code>이므로 첫 번째 가지의 패턴은 매치되지만, 매치 가드 <code>if y</code>가 거짓이므로 첫 번째 가지는 선택되지 않습니다. 코드는 두 번째 가지로 넘어가고, 이는 매치되므로 이 프로그램은 <code>no</code>를 출력합니다. 그 이유는 <code>if</code> 조건이 마지막 값인 <code>6</code>뿐만 아니라 전체 패턴 <code>4 | 5 | 6</code>에 적용되기 때문입니다. 다시 말해, 패턴과 관련된 매치 가드의 우선순위는 다음과 같이 동작합니다.</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<p>다음과 같이 동작하는 것이 아닙니다.</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<p>코드를 실행해 보면 우선순위 동작이 분명해집니다. 만약 매치 가드가 <code>|</code> 연산자를 사용하여 지정된 값 목록의 마지막 값에만 적용되었다면, 그 가지는 매치되었을 것이고 프로그램은 <code>yes</code>를 출력했을 것입니다.</p>
<h3 id="-바인딩"><a class="header" href="#-바인딩"><code>@</code> 바인딩</a></h3>
<p><em>at</em> 연산자인 <code>@</code>를 사용하면 어떤 값이 패턴과 매치되는지 테스트하는 동시에, 그 값을 보관할 변수를 생성할 수 있습니다. 목록 19-29에서 우리는 <code>Message::Hello</code>의 <code>id</code> 필드가 <code>3..=7</code> 범위 내에 있는지 테스트하고 싶습니다. 또한 그 값을 <code>id_variable</code> 변수에 바인딩하여 해당 가지와 관련된 코드에서 사용하고 싶습니다. 이 변수 이름을 필드 이름과 동일하게 <code>id</code>라고 지을 수도 있지만, 이 예제에서는 다른 이름을 사용하겠습니다.</p>
<Listing number="19-29" caption="Using `@` to bind to a value in a pattern while also testing it">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } =&gt; println!("범위 내의 id를 발견했습니다: {id_variable}"),
        Message::Hello { id: 10..=12 } =&gt; {
            println!("다른 범위의 id를 발견했습니다")
        }
        Message::Hello { id } =&gt; println!("다른 id를 발견했습니다: {id}"),
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 예제는 <code>범위 내의 id를 발견했습니다: 5</code>를 출력할 것입니다. 범위 <code>3..=7</code> 앞에 <code>id_variable @</code>를 지정함으로써, 해당 범위에 매치되는 어떤 값이든 캡처하는 동시에 그 값이 범위 패턴에 매치되는지 테스트하고 있습니다.</p>
<p>패턴에 범위만 지정된 두 번째 가지에서는, 가지와 관련된 코드에 <code>id</code> 필드의 실제 값을 담고 있는 변수가 없습니다. <code>id</code> 필드의 값은 10, 11, 또는 12였을 수 있지만, 해당 패턴과 연관된 코드는 그것이 무엇인지 알 수 없습니다. 우리는 <code>id</code> 값을 변수에 저장하지 않았기 때문에, 패턴 코드에서 <code>id</code> 필드의 값을 사용할 수 없습니다.</p>
<p>범위 없이 변수만 지정된 마지막 가지에서는, <code>id</code>라는 이름의 변수를 통해 가지의 코드에서 사용할 수 있는 값을 가집니다. 그 이유는 구조체 필드 단축 문법을 사용했기 때문입니다. 하지만 이 가지에서는 처음 두 가지에서 했던 것처럼 <code>id</code> 필드의 값에 대해 어떠한 테스트도 적용하지 않았습니다. 즉, 어떤 값이라도 이 패턴과 매치될 것입니다.</p>
<p><code>@</code>를 사용하면 하나의 패턴 내에서 값을 테스트하는 동시에 변수에 저장할 수 있습니다.</p>
<h2 id="요약"><a class="header" href="#요약">요약</a></h2>
<p>러스트의 패턴은 서로 다른 종류의 데이터를 구분하는 데 매우 유용합니다. <code>match</code> 표현식에서 사용될 때, 러스트는 패턴이 모든 가능한 값을 커버하도록 보장하며, 그렇지 않으면 프로그램이 컴파일되지 않습니다. <code>let</code> 문과 함수 매개변수에서의 패턴은 이러한 구문들을 더욱 유용하게 만들어주며, 값을 더 작은 조각으로 구조분해하고 그 조각들을 변수에 할당할 수 있게 해줍니다. 우리는 필요에 따라 단순하거나 복잡한 패턴을 만들 수 있습니다.</p>
<p>다음으로, 이 책의 마지막에서 두 번째 장에서는 러스트의 다양한 기능들에 대한 몇 가지 고급 측면들을 살펴보겠습니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch19-02-refutability.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch20-00-advanced-features.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch19-02-refutability.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch20-00-advanced-features.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
