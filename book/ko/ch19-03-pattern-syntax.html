<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>패턴 문법 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch19-03-pattern-syntax.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch19-03-pattern-syntax.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="패턴-문법"><a class="header" href="#패턴-문법">패턴 문법</a></h2>
<p>In this section, we gather all the syntax that is valid in patterns and discuss why and when you might want to use each one.</p>
<h3 id="리터럴-매칭하기"><a class="header" href="#리터럴-매칭하기">리터럴 매칭하기</a></h3>
<p>6장에서 보았듯이, 여러분은 패턴을 리터럴과 직접 매칭할 수 있습니다. 다음 코드는 몇 가지 예시를 보여줍니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 =&gt; println!("하나"),
        2 =&gt; println!("둘"),
        3 =&gt; println!("셋"),
        _ =&gt; println!("무엇이든"),
    }
<span class="boring">}</span></code></pre></pre>
<p>This code prints <code>one</code> because the value in <code>x</code> is <code>1</code>. This syntax is useful when you want your code to take an action if it gets a particular concrete value.</p>
<h3 id="이름-붙은-변수-매칭하기"><a class="header" href="#이름-붙은-변수-매칭하기">이름 붙은 변수 매칭하기</a></h3>
<p>Named variables are irrefutable patterns that match any value, and we’ve used them many times in this book. However, there is a complication when you use named variables in <code>match</code>, <code>if let</code>, or <code>while let</code> expressions. Because each of these kinds of expressions starts a new scope, variables declared as part of a pattern inside these expressions will shadow those with the same name outside the constructs, as is the case with all variables. In Listing 19-11, we declare a variable named <code>x</code> with the value <code>Some(5)</code> and a variable <code>y</code> with the value <code>10</code>. We then create a <code>match</code> expression on the value <code>x</code>. Look at the patterns in the match arms and <code>println!</code> at the end, and try to figure out what the code will print before running this code or reading further.</p>
<Listing number="19-11" file-name="src/main.rs" caption="A `match` expression with an arm that introduces a new variable which shadows an existing variable `y`">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!("50을 얻었습니다"),
        Some(y) =&gt; println!("매치됨, y = {y}"),
        _ =&gt; println!("기본 케이스, x = {x:?}"),
    }

    println!("마지막에: x = {x:?}, y = {y}");
<span class="boring">}</span></code></pre></pre>
</Listing>
<p><code>match</code> 표현식이 실행될 때 어떤 일이 일어나는지 살펴봅시다. 첫 번째 매치 가지의 패턴은 <code>x</code>에 정의된 값과 매치되지 않으므로, 코드는 계속 진행됩니다.</p>
<p>The pattern in the second match arm introduces a new variable named <code>y</code> that will match any value inside a <code>Some</code> value. Because we’re in a new scope inside the <code>match</code> expression, this is a new <code>y</code> variable, not the <code>y</code> we declared at the beginning with the value <code>10</code>. This new <code>y</code> binding will match any value inside a <code>Some</code>, which is what we have in <code>x</code>. Therefore, this new <code>y</code> binds to the inner value of the <code>Some</code> in <code>x</code>. That value is <code>5</code>, so the expression for that arm executes and prints <code>Matched, y = 5</code>.</p>
<p>만약 <code>x</code>가 <code>Some(5)</code> 대신 <code>None</code> 값이었다면, 처음 두 가지의 패턴은 매치되지 않았을 것이므로 값은 언더스코어에 매치되었을 것입니다. 우리는 언더스코어 가지의 패턴에서 <code>x</code> 변수를 도입하지 않았으므로, 표현식의 <code>x</code>는 여전히 섀도잉되지 않은 외부의 <code>x</code>입니다. 이 가상의 경우, <code>match</code>는 <code>Default case, x = None</code>을 출력할 것입니다.</p>
<p><code>match</code> 표현식이 끝나면 그 스코프가 종료되고, 내부의 <code>y</code> 스코프도 함께 종료됩니다. 마지막 <code>println!</code>은 <code>at the end: x = Some(5), y = 10</code>을 출력합니다.</p>
<p>To create a <code>match</code> expression that compares the values of the outer <code>x</code> and <code>y</code>, rather than introducing a new variable that shadows the existing <code>y</code> variable, we would need to use a match guard conditional instead. We’ll talk about match guards later in the <a href="#adding-conditionals-with-match-guards">“Adding Conditionals with Match Guards”</a><!-- ignore --> section.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="multiple-patterns"></a></p>
<h3 id="matching-multiple-patterns"><a class="header" href="#matching-multiple-patterns">Matching Multiple Patterns</a></h3>
<p>In <code>match</code> expressions, you can match multiple patterns using the <code>|</code> syntax, which is the pattern <em>or</em> operator. For example, in the following code, we match the value of <code>x</code> against the match arms, the first of which has an <em>or</em> option, meaning if the value of <code>x</code> matches either of the values in that arm, that arm’s code will run:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 | 2 =&gt; println!("하나 또는 둘"),
        3 =&gt; println!("셋"),
        _ =&gt; println!("무엇이든"),
    }
<span class="boring">}</span></code></pre></pre>
<p>이 코드는 <code>one or two</code>를 출력합니다.</p>
<h3 id="를-사용한-값의-범위-매칭"><a class="header" href="#를-사용한-값의-범위-매칭"><code>..=</code>를 사용한 값의 범위 매칭</a></h3>
<p><code>..=</code> 문법은 포함 범위(inclusive range)의 값들을 매칭할 수 있게 해줍니다. 다음 코드에서 패턴이 주어진 범위 내의 어떤 값과 매치되면 해당 가지가 실행됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let x = 5;

    match x {
        1..=5 =&gt; println!("하나부터 다섯까지"),
        _ =&gt; println!("그 외의 것"),
    }
<span class="boring">}</span></code></pre></pre>
<p>If <code>x</code> is <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, or <code>5</code>, the first arm will match. This syntax is more convenient for multiple match values than using the <code>|</code> operator to express the same idea; if we were to use <code>|</code>, we would have to specify <code>1 | 2 | 3 | 4 | 5</code>. Specifying a range is much shorter, especially if we want to match, say, any number between 1 and 1,000!</p>
<p>컴파일러는 컴파일 타임에 범위가 비어 있지 않은지 확인합니다. 러스트가 범위가 비어 있는지 여부를 판단할 수 있는 유일한 타입은 <code>char</code>와 숫자 값뿐이므로, 범위는 숫자나 <code>char</code> 값에 대해서만 허용됩니다.</p>
<p>다음은 <code>char</code> 값의 범위를 사용하는 예제입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let x = 'c';

    match x {
        'a'..='j' =&gt; println!("앞쪽 ASCII 문자"),
        'k'..='z' =&gt; println!("뒤쪽 ASCII 문자"),
        _ =&gt; println!("그 외의 것"),
    }
<span class="boring">}</span></code></pre></pre>
<p>러스트는 <code>'c'</code>가 첫 번째 패턴의 범위 내에 있음을 판단하고 <code>early ASCII letter</code>를 출력합니다.</p>
<h3 id="값을-분해하기-위한-구조분해"><a class="header" href="#값을-분해하기-위한-구조분해">값을 분해하기 위한 구조분해</a></h3>
<p>구조체, 열거형, 튜플을 구조분해하여 이 값들의 서로 다른 부분들을 사용하기 위해 패턴을 사용할 수도 있습니다. 각 값을 하나씩 살펴봅시다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="destructuring-structs"></a></p>
<h4 id="structs"><a class="header" href="#structs">Structs</a></h4>
<p>목록 19-12는 <code>let</code> 문과 패턴을 사용하여 분해할 수 있는 <code>x</code>와 <code>y</code> 두 필드를 가진 <code>Point</code> 구조체를 보여줍니다.</p>
<Listing number="19-12" file-name="src/main.rs" caption="Destructuring a struct’s fields into separate variables">
<pre><pre class="playground"><code class="language-rust edition2024">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}</code></pre></pre>
</Listing>
<p>This code creates the variables <code>a</code> and <code>b</code> that match the values of the <code>x</code> and <code>y</code> fields of the <code>p</code> struct. This example shows that the names of the variables in the pattern don’t have to match the field names of the struct. However, it’s common to match the variable names to the field names to make it easier to remember which variables came from which fields. Because of this common usage, and because writing <code>let Point { x: x, y: y } = p;</code> contains a lot of duplication, Rust has a shorthand for patterns that match struct fields: You only need to list the name of the struct field, and the variables created from the pattern will have the same names. Listing 19-13 behaves in the same way as the code in Listing 19-12, but the variables created in the <code>let</code> pattern are <code>x</code> and <code>y</code> instead of <code>a</code> and <code>b</code>.</p>
<Listing number="19-13" file-name="src/main.rs" caption="Destructuring struct fields using struct field shorthand">
<pre><pre class="playground"><code class="language-rust edition2024">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}</code></pre></pre>
</Listing>
<p>이 코드는 변수 <code>p</code>의 <code>x</code>와 <code>y</code> 필드에 매치되는 변수 <code>x</code>와 <code>y</code>를 생성합니다. 그 결과 변수 <code>x</code>와 <code>y</code>는 <code>p</code> 구조체의 값들을 담게 됩니다.</p>
<p>모든 필드에 대해 변수를 생성하는 대신, 구조체 패턴의 일부로 리터럴 값을 사용하여 구조분해할 수도 있습니다. 이를 통해 다른 필드들을 구조분해할 변수들을 생성하면서 동시에 일부 필드들이 특정 값을 가졌는지 테스트할 수 있습니다.</p>
<p>In Listing 19-14, we have a <code>match</code> expression that separates <code>Point</code> values into three cases: points that lie directly on the <code>x</code> axis (which is true when <code>y = 0</code>), on the <code>y</code> axis (<code>x = 0</code>), or on neither axis.</p>
<Listing number="19-14" file-name="src/main.rs" caption="Destructuring and matching literal values in one pattern">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!("x축 위의 {x}에 있습니다"),
        Point { x: 0, y } =&gt; println!("y축 위의 {y}에 있습니다"),
        Point { x, y } =&gt; {
            println!("어느 축 위에도 있지 않습니다: ({x}, {y})");
        }
    }
}</code></pre></pre>
</Listing>
<p>첫 번째 가지는 <code>y</code> 필드의 값이 리터럴 <code>0</code>과 매치되도록 지정함으로써 <code>x</code>축 위에 놓인 모든 점과 매치됩니다. 이 패턴은 여전히 해당 가지의 코드에서 사용할 수 있는 <code>x</code> 변수를 생성합니다.</p>
<p>마찬가지로, 두 번째 가지는 <code>x</code> 필드의 값이 <code>0</code>인 경우 매치되도록 지정하여 <code>y</code>축 위의 모든 점과 매치되며, <code>y</code> 필드 값을 위한 변수 <code>y</code>를 생성합니다. 세 번째 가지는 어떠한 리터럴도 지정하지 않으므로 다른 모든 <code>Point</code>와 매치되며 <code>x</code>와 <code>y</code> 필드 모두에 대해 변수를 생성합니다.</p>
<p>In this example, the value <code>p</code> matches the second arm by virtue of <code>x</code> containing a <code>0</code>, so this code will print <code>On the y axis at 7</code>.</p>
<p>Remember that a <code>match</code> expression stops checking arms once it has found the first matching pattern, so even though <code>Point { x: 0, y: 0 }</code> is on the <code>x</code> axis and the <code>y</code> axis, this code would only print <code>On the x axis at 0</code>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="destructuring-enums"></a></p>
<h4 id="enums"><a class="header" href="#enums">Enums</a></h4>
<p>We’ve destructured enums in this book (for example, Listing 6-5 in Chapter 6), but we haven’t yet explicitly discussed that the pattern to destructure an enum corresponds to the way the data stored within the enum is defined. As an example, in Listing 19-15, we use the <code>Message</code> enum from Listing 6-2 and write a <code>match</code> with patterns that will destructure each inner value.</p>
<Listing number="19-15" file-name="src/main.rs" caption="Destructuring enum variants that hold different kinds of values">
<pre><pre class="playground"><code class="language-rust edition2024">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            println!("Quit 변형은 구조분해할 데이터가 없습니다.");
        }
        Message::Move { x, y } =&gt; {
            println!("x 방향으로 {x}만큼, y 방향으로 {y}만큼 이동합니다");
        }
        Message::Write(text) =&gt; {
            println!("텍스트 메시지: {text}");
        }
        Message::ChangeColor(r, g, b) =&gt; {
            println!("색상을 빨간색 {r}, 녹색 {g}, 파란색 {b}으로 변경합니다");
        }
    }
}</code></pre></pre>
</Listing>
<p>This code will print <code>Change color to red 0, green 160, and blue 255</code>. Try changing the value of <code>msg</code> to see the code from the other arms run.</p>
<p><code>Message::Quit</code>과 같이 아무런 데이터도 없는 열거형 변형의 경우, 해당 값을 더 이상 구조분해할 수 없습니다. 오직 리터럴 <code>Message::Quit</code> 값에 대해서만 매칭할 수 있으며, 해당 패턴에는 변수가 없습니다.</p>
<p>For struct-like enum variants, such as <code>Message::Move</code>, we can use a pattern similar to the pattern we specify to match structs. After the variant name, we place curly brackets and then list the fields with variables so that we break apart the pieces to use in the code for this arm. Here we use the shorthand form as we did in Listing 19-13.</p>
<p>하나의 요소를 가진 튜플을 담는 <code>Message::Write</code>나 세 개의 요소를 가진 튜플을 담는 <code>Message::ChangeColor</code>와 같은 튜플 형태의 열거형 변형의 경우, 패턴은 튜플을 매칭할 때 지정하는 패턴과 유사합니다. 패턴 내 변수의 개수는 매칭하려는 변형의 요소 개수와 일치해야 합니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="destructuring-nested-structs-and-enums"></a></p>
<h4 id="nested-structs-and-enums"><a class="header" href="#nested-structs-and-enums">Nested Structs and Enums</a></h4>
<p>지금까지의 예제들은 모두 한 단계 깊이의 구조체나 열거형을 매칭하는 것이었지만, 매칭은 중첩된 아이템에 대해서도 작동할 수 있습니다! 예를 들어, 목록 19-16에 나타난 것처럼 <code>ChangeColor</code> 메시지에서 RGB와 HSV 색상을 지원하도록 목록 19-15의 코드를 리팩터링할 수 있습니다.</p>
<Listing number="19-16" caption="Matching on nested enums">
<pre><pre class="playground"><code class="language-rust edition2024">enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; {
            println!("색상을 빨간색 {r}, 녹색 {g}, 파란색 {b}으로 변경합니다");
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; {
            println!("색상을 색상 {h}, 채도 {s}, 명도 {v}로 변경합니다");
        }
        _ =&gt; (),
    }
}</code></pre></pre>
</Listing>
<p>The pattern of the first arm in the <code>match</code> expression matches a <code>Message::ChangeColor</code> enum variant that contains a <code>Color::Rgb</code> variant; then, the pattern binds to the three inner <code>i32</code> values. The pattern of the second arm also matches a <code>Message::ChangeColor</code> enum variant, but the inner enum matches <code>Color::Hsv</code> instead. We can specify these complex conditions in one <code>match</code> expression, even though two enums are involved.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="destructuring-structs-and-tuples"></a></p>
<h4 id="structs-and-tuples"><a class="header" href="#structs-and-tuples">Structs and Tuples</a></h4>
<p>우리는 구조분해 패턴을 훨씬 더 복잡한 방식으로 섞고, 매치하고, 중첩할 수 있습니다. 다음 예제는 튜플 내부에 구조체와 튜플을 중첩시키고 모든 원시 값들을 구조분해하는 복잡한 구조분해를 보여줍니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    struct Point {
</span><span class="boring">        x: i32,
</span><span class="boring">        y: i32,
</span><span class="boring">    }
</span><span class="boring">
</span>    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
<span class="boring">}</span></code></pre></pre>
<p>This code lets us break complex types into their component parts so that we can use the values we’re interested in separately.</p>
<p>패턴을 이용한 구조분해는 구조체의 각 필드 값과 같이 값의 조각들을 서로 개별적으로 사용할 수 있는 편리한 방법입니다.</p>
<h3 id="패턴에서-값-무시하기"><a class="header" href="#패턴에서-값-무시하기">패턴에서 값 무시하기</a></h3>
<p>여러분은 <code>match</code>의 마지막 가지에서처럼 패턴에서 값을 무시하는 것이 가끔 유용하다는 것을 보았습니다. 이는 실제로 아무것도 하지 않지만 나머지 모든 가능한 값들을 처리하는 포괄적인 처리를 얻기 위함입니다. 패턴에서 전체 값이나 값의 일부를 무시하는 방법에는 몇 가지가 있습니다: <code>_</code> 패턴 사용하기(이미 보았습니다), 다른 패턴 내에서 <code>_</code> 패턴 사용하기, 언더스코어로 시작하는 이름 사용하기, 또는 값의 나머지 부분을 무시하기 위해 <code>..</code> 사용하기가 그것입니다. 이 패턴들을 각각 어떻게 그리고 왜 사용하는지 알아봅시다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="ignoring-an-entire-value-with-_"></a></p>
<h4 id="an-entire-value-with-_"><a class="header" href="#an-entire-value-with-_">An Entire Value with <code>_</code></a></h4>
<p>우리는 어떤 값과도 매치되지만 값에 바인딩되지는 않는 와일드카드 패턴으로 언더스코어를 사용해 왔습니다. 이는 특히 <code>match</code> 표현식의 마지막 가지로서 유용하지만, 목록 19-17에 나타난 것처럼 함수 매개변수를 포함한 모든 패턴에서 사용할 수 있습니다.</p>
<Listing number="19-17" file-name="src/main.rs" caption="Using `_` in a function signature">
<pre><pre class="playground"><code class="language-rust edition2024">fn foo(_: i32, y: i32) {
    println!("이 코드는 오직 y 매개변수만 사용합니다: {y}");
}

fn main() {
    foo(3, 4);
}</code></pre></pre>
</Listing>
<p>이 코드는 첫 번째 인수로 전달된 값 <code>3</code>을 완전히 무시하고, <code>이 코드는 오직 y 매개변수만 사용합니다: 4</code>를 출력할 것입니다.</p>
<p>In most cases when you no longer need a particular function parameter, you would change the signature so that it doesn’t include the unused parameter. Ignoring a function parameter can be especially useful in cases when, for example, you’re implementing a trait when you need a certain type signature but the function body in your implementation doesn’t need one of the parameters. You then avoid getting a compiler warning about unused function parameters, as you would if you used a name instead.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="ignoring-parts-of-a-value-with-a-nested-_"></a></p>
<h4 id="parts-of-a-value-with-a-nested-_"><a class="header" href="#parts-of-a-value-with-a-nested-_">Parts of a Value with a Nested <code>_</code></a></h4>
<p>또한 값의 일부만 테스트하고 싶지만 실행하려는 해당 코드에서 다른 부분은 사용할 필요가 없을 때, 다른 패턴 내부에서 <code>_</code>를 사용하여 값의 일부만 무시할 수 있습니다. 목록 19-18은 설정값을 관리하는 코드를 보여줍니다. 비즈니스 요구사항은 사용자가 설정의 기존 커스터마이징을 덮어쓰는 것은 허용되지 않지만, 현재 설정이 해제되어 있다면 설정을 해제하거나 값을 줄 수 있어야 한다는 것입니다.</p>
<Listing number="19-18" caption="Using an underscore within patterns that match `Some` variants when we don’t need to use the value inside the `Some`">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut setting_value = Some(5);
    let new_setting_value = Some(10);

    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) =&gt; {
            println!("기존의 커스터마이징된 값을 덮어쓸 수 없습니다");
        }
        _ =&gt; {
            setting_value = new_setting_value;
        }
    }

    println!("설정은 {setting_value:?}입니다");
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 코드는 <code>기존의 커스터마이징된 값을 덮어쓸 수 없습니다</code>를 출력한 다음 <code>설정은 Some(5)입니다</code>를 출력할 것입니다. 첫 번째 매치 가지에서, 우리는 어느 <code>Some</code> 변형 내부의 값에 대해서도 매칭하거나 사용할 필요가 없지만, <code>setting_value</code>와 <code>new_setting_value</code>가 모두 <code>Some</code> 변형인 경우를 테스트할 필요는 있습니다. 그 경우 <code>setting_value</code>를 변경하지 않는 이유를 출력하고, 값은 변경되지 않습니다.</p>
<p>In all other cases (if either <code>setting_value</code> or <code>new_setting_value</code> is <code>None</code>) expressed by the <code>_</code> pattern in the second arm, we want to allow <code>new_setting_value</code> to become <code>setting_value</code>.</p>
<p>또한 특정 값들을 무시하기 위해 하나의 패턴 내 여러 곳에서 언더스코어를 사용할 수 있습니다. 목록 19-19는 5개의 아이템을 가진 튜플에서 두 번째와 네 번째 값을 무시하는 예제를 보여줍니다.</p>
<Listing number="19-19" caption="Ignoring multiple parts of a tuple">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) =&gt; {
            println!("어떤 숫자들: {first}, {third}, {fifth}");
        }
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>This code will print <code>Some numbers: 2, 8, 32</code>, and the values <code>4</code> and <code>16</code> will be ignored.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="ignoring-an-unused-variable-by-starting-its-name-with-_"></a></p>
<h4 id="an-unused-variable-by-starting-its-name-with-_"><a class="header" href="#an-unused-variable-by-starting-its-name-with-_">An Unused Variable by Starting Its Name with <code>_</code></a></h4>
<p>변수를 만들고 어디에서도 사용하지 않는다면, 사용하지 않는 변수는 버그일 가능성이 있기 때문에 러스트는 보통 경고를 보냅니다. 하지만 프로토타이핑을 하거나 프로젝트를 막 시작했을 때처럼, 아직 사용하지 않을 변수를 미리 만들어두는 것이 유용할 때가 있습니다. 이런 상황에서는 변수 이름을 언더스코어로 시작함으로써 러스트에게 해당 변수에 대해 경고하지 말라고 말할 수 있습니다. 목록 19-20에서 우리는 두 개의 사용하지 않는 변수를 생성하지만, 이 코드를 컴파일하면 오직 그중 하나에 대해서만 경고를 받게 될 것입니다.</p>
<Listing number="19-20" file-name="src/main.rs" caption="Starting a variable name with an underscore to avoid getting unused variable warnings">
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let _x = 5;
    let y = 10;
}</code></pre></pre>
</Listing>
<p>Here, we get a warning about not using the variable <code>y</code>, but we don’t get a warning about not using <code>_x</code>.</p>
<p>단순히 <code>_</code>만 사용하는 것과 언더스코어로 시작하는 이름을 사용하는 것 사이에는 미묘한 차이가 있음에 주의하세요. <code>_x</code> 문법은 여전히 값을 변수에 바인딩하지만, <code>_</code>는 전혀 바인딩하지 않습니다. 이 구분이 중요한 사례를 보여주기 위해, 목록 19-21은 우리에게 에러를 발생시킬 것입니다.</p>
<Listing number="19-21" caption="An unused variable starting with an underscore still binds the value, which might take ownership of the value.">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s = Some(String::from("Hello!"));

    if let Some(_s) = s {
        println!("문자열을 발견했습니다");
    }

    println!("{s:?}");
<span class="boring">}</span></code></pre>
</Listing>
<p>우리는 <code>s</code> 값이 여전히 <code>_s</code>로 이동(move)되어 <code>s</code>를 다시 사용할 수 없게 되기 때문에 에러를 받게 됩니다. 하지만 언더스코어 그 자체를 사용하는 것은 값에 바인딩되지 않습니다. 목록 19-22는 <code>s</code>가 <code>_</code>로 이동되지 않기 때문에 아무런 에러 없이 컴파일될 것입니다.</p>
<Listing number="19-22" caption="Using an underscore does not bind the value.">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let s = Some(String::from("Hello!"));

    if let Some(_) = s {
        println!("문자열을 발견했습니다");
    }

    println!("{s:?}");
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 코드는 우리가 <code>s</code>를 어디에도 바인딩하지 않았으므로 잘 작동합니다. 즉, 이동되지 않았습니다.</p>
<p><a id="ignoring-remaining-parts-of-a-value-with-"></a></p>
<h4 id="remaining-parts-of-a-value-with-"><a class="header" href="#remaining-parts-of-a-value-with-">Remaining Parts of a Value with <code>..</code></a></h4>
<p>많은 부분을 가진 값의 경우, <code>..</code> 문법을 사용하여 특정 부분만 사용하고 나머지는 무시할 수 있습니다. 이를 통해 무시할 각 값에 대해 언더스코어를 나열해야 하는 수고를 덜 수 있습니다. <code>..</code> 패턴은 패턴의 나머지 부분에서 명시적으로 매칭하지 않은 값의 모든 부분을 무시합니다. 목록 19-23에서는 3차원 공간의 좌표를 담는 <code>Point</code> 구조체가 있습니다. <code>match</code> 표현식에서 우리는 오직 <code>x</code> 좌표에 대해서만 작업하고 <code>y</code>와 <code>z</code> 필드의 값은 무시하고 싶습니다.</p>
<Listing number="19-23" caption="Ignoring all fields of a `Point` except for `x` by using `..`">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } =&gt; println!("x는 {x}입니다"),
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>우리는 <code>x</code> 값을 나열하고 그 뒤에 단순히 <code>..</code> 패턴을 포함시킵니다. 이는 <code>y: _</code>와 <code>z: _</code>를 일일이 나열하는 것보다 빠릅니다. 특히 필드가 아주 많은 구조체에서 오직 한두 개의 필드만이 관련이 있는 상황에서 작업할 때 유용합니다.</p>
<p><code>..</code> 문법은 필요한 만큼의 많은 값으로 확장될 것입니다. 목록 19-24는 튜플과 함께 <code>..</code>를 사용하는 방법을 보여줍니다.</p>
<Listing number="19-24" file-name="src/main.rs" caption="Matching only the first and last values in a tuple and ignoring all other values">
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!("어떤 숫자들: {first}, {last}");
        }
    }
}</code></pre></pre>
</Listing>
<p>In this code, the first and last values are matched with <code>first</code> and <code>last</code>. The <code>..</code> will match and ignore everything in the middle.</p>
<p>하지만 <code>..</code> 사용은 모호하지 않아야 합니다. 어떤 값이 매칭을 위한 것이고 어떤 값이 무시되어야 하는지가 불명확하다면, 러스트는 에러를 발생시킵니다. 목록 19-25는 <code>..</code>를 모호하게 사용한 예제를 보여주며, 이 코드는 컴파일되지 않습니다.</p>
<Listing number="19-25" file-name="src/main.rs" caption="An attempt to use `..` in an ambiguous way">
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!("어떤 숫자들: {second}")
        },
    }
}</code></pre>
</Listing>
<p>이 예제를 컴파일하면 다음과 같은 에러를 얻게 됩니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error: `..`은 튜플 패턴당 한 번만 사용할 수 있습니다
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |          --          ^^ 튜플 패턴당 한 번만 사용할 수 있습니다
  |          |
  |          이전에 여기서 사용되었습니다

error: 1개의 이전 에러로 인해 `patterns` (바이너리 "patterns")를 컴파일할 수 없습니다
</code></pre>
<p>러스트가 <code>second</code>와 매치하기 전에 튜플에서 얼마나 많은 값을 무시해야 할지, 그리고 그 후에 얼마나 더 많은 값을 무시해야 할지 결정하는 것은 불가능합니다. 이 코드는 <code>2</code>를 무시하고 <code>second</code>를 <code>4</code>에 바인딩한 다음 <code>8</code>, <code>16</code>, <code>32</code>를 무시하겠다는 의미일 수도 있고, <code>2</code>와 <code>4</code>를 무시하고 <code>second</code>를 <code>8</code>에 바인딩한 다음 <code>16</code>과 <code>32</code>를 무시하겠다는 의미일 수도 있는 등 그 해석이 다양합니다. 변수 이름 <code>second</code>는 러스트에게 특별한 의미가 없으므로, 이와 같이 두 곳에서 <code>..</code>를 사용하는 것은 모호하여 컴파일러 에러가 발생합니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="extra-conditionals-with-match-guards"></a></p>
<h3 id="adding-conditionals-with-match-guards"><a class="header" href="#adding-conditionals-with-match-guards">Adding Conditionals with Match Guards</a></h3>
<p>A <em>match guard</em> is an additional <code>if</code> condition, specified after the pattern in a <code>match</code> arm, that must also match for that arm to be chosen. Match guards are useful for expressing more complex ideas than a pattern alone allows. Note, however, that they are only available in <code>match</code> expressions, not <code>if let</code> or <code>while let</code> expressions.</p>
<p>The condition can use variables created in the pattern. Listing 19-26 shows a <code>match</code> where the first arm has the pattern <code>Some(x)</code> and also has a match guard of <code>if x % 2 == 0</code> (which will be <code>true</code> if the number is even).</p>
<Listing number="19-26" caption="Adding a match guard to a pattern">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let num = Some(4);

    match num {
        Some(x) if x % 2 == 0 =&gt; println!("숫자 {x}는 짝수입니다"),
        Some(x) =&gt; println!("숫자 {x}는 홀수입니다"),
        None =&gt; (),
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>This example will print <code>The number 4 is even</code>. When <code>num</code> is compared to the pattern in the first arm, it matches because <code>Some(4)</code> matches <code>Some(x)</code>. Then, the match guard checks whether the remainder of dividing <code>x</code> by 2 is equal to 0, and because it is, the first arm is selected.</p>
<p>If <code>num</code> had been <code>Some(5)</code> instead, the match guard in the first arm would have been <code>false</code> because the remainder of 5 divided by 2 is 1, which is not equal to 0. Rust would then go to the second arm, which would match because the second arm doesn’t have a match guard and therefore matches any <code>Some</code> variant.</p>
<p>There is no way to express the <code>if x % 2 == 0</code> condition within a pattern, so the match guard gives us the ability to express this logic. The downside of this additional expressiveness is that the compiler doesn’t try to check for exhaustiveness when match guard expressions are involved.</p>
<p>When discussing Listing 19-11, we mentioned that we could use match guards to solve our pattern-shadowing problem. Recall that we created a new variable inside the pattern in the <code>match</code> expression instead of using the variable outside the <code>match</code>. That new variable meant we couldn’t test against the value of the outer variable. Listing 19-27 shows how we can use a match guard to fix this problem.</p>
<Listing number="19-27" file-name="src/main.rs" caption="Using a match guard to test for equality with an outer variable">
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!("50을 얻었습니다"),
        Some(n) if n == y =&gt; println!("매치됨, n = {n}"),
        _ =&gt; println!("기본 케이스, x = {x:?}"),
    }

    println!("마지막에: x = {x:?}, y = {y}");
}</code></pre></pre>
</Listing>
<p>이제 이 코드는 <code>기본 케이스, x = Some(5)</code>을 출력할 것입니다. 두 번째 매치 가지의 패턴은 외부의 <code>y</code>를 섀도잉할 새로운 변수 <code>y</code>를 도입하지 않으므로, 매치 가드에서 외부의 <code>y</code>를 사용할 수 있습니다. 외부의 <code>y</code>를 섀도잉했을 <code>Some(y)</code>로 패턴을 지정하는 대신, 우리는 <code>Some(n)</code>을 지정합니다. 이는 <code>match</code> 외부에 <code>n</code> 변수가 없으므로 아무것도 섀도잉하지 않는 새로운 변수 <code>n</code>을 생성합니다.</p>
<p>매치 가드 <code>if n == y</code>는 패턴이 아니므로 새로운 변수를 도입하지 않습니다. 이 <code>y</code>는 새로운 <code>y</code>가 섀도잉하는 것이 아니라 <em>외부의</em> <code>y</code>이며, 우리는 <code>n</code>과 <code>y</code>를 비교함으로써 외부의 <code>y</code>와 동일한 값을 가진 값을 찾을 수 있습니다.</p>
<p>매치 가드에서 <em>or</em> 연산자인 <code>|</code>를 사용하여 여러 패턴을 지정할 수도 있습니다. 이때 매치 가드 조건은 모든 패턴에 적용됩니다. 목록 19-28은 <code>|</code>를 사용하는 패턴과 매치 가드를 결합할 때의 우선순위를 보여줍니다. 이 예제의 중요한 점은 <code>if y</code> 매치 가드가 비록 <code>6</code>에만 적용되는 것처럼 보일지라도, <code>4</code>, <code>5</code>, <em>그리고</em> <code>6</code> 모두에 적용된다는 것입니다.</p>
<Listing number="19-28" caption="Combining multiple patterns with a match guard">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let x = 4;
    let y = false;

    match x {
        4 | 5 | 6 if y =&gt; println!("네"),
        _ =&gt; println!("아니요"),
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>The match condition states that the arm only matches if the value of <code>x</code> is equal to <code>4</code>, <code>5</code>, or <code>6</code> <em>and</em> if <code>y</code> is <code>true</code>. When this code runs, the pattern of the first arm matches because <code>x</code> is <code>4</code>, but the match guard <code>if y</code> is <code>false</code>, so the first arm is not chosen. The code moves on to the second arm, which does match, and this program prints <code>no</code>. The reason is that the <code>if</code> condition applies to the whole pattern <code>4 | 5 | 6</code>, not just to the last value <code>6</code>. In other words, the precedence of a match guard in relation to a pattern behaves like this:</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<p>다음과 같이 동작하는 것이 아닙니다.</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<p>After running the code, the precedence behavior is evident: If the match guard were applied only to the final value in the list of values specified using the <code>|</code> operator, the arm would have matched, and the program would have printed <code>yes</code>.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="-bindings"></a></p>
<h3 id="using--bindings"><a class="header" href="#using--bindings">Using <code>@</code> Bindings</a></h3>
<p>The <em>at</em> operator <code>@</code> lets us create a variable that holds a value at the same time we’re testing that value for a pattern match. In Listing 19-29, we want to test that a <code>Message::Hello</code> <code>id</code> field is within the range <code>3..=7</code>. We also want to bind the value to the variable <code>id</code> so that we can use it in the code associated with the arm.</p>
<Listing number="19-29" caption="Using `@` to bind to a value in a pattern while also testing it">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello { id: id @ 3..=7 } =&gt; {
            println!("Found an id in range: {id}")
        }
        Message::Hello { id: 10..=12 } =&gt; {
            println!("다른 범위의 id를 발견했습니다")
        }
        Message::Hello { id } =&gt; println!("다른 id를 발견했습니다: {id}"),
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>This example will print <code>Found an id in range: 5</code>. By specifying <code>id @</code> before the range <code>3..=7</code>, we’re capturing whatever value matched the range in a variable named <code>id</code> while also testing that the value matched the range pattern.</p>
<p>In the second arm, where we only have a range specified in the pattern, the code associated with the arm doesn’t have a variable that contains the actual value of the <code>id</code> field. The <code>id</code> field’s value could have been 10, 11, or 12, but the code that goes with that pattern doesn’t know which it is. The pattern code isn’t able to use the value from the <code>id</code> field because we haven’t saved the <code>id</code> value in a variable.</p>
<p>In the last arm, where we’ve specified a variable without a range, we do have the value available to use in the arm’s code in a variable named <code>id</code>. The reason is that we’ve used the struct field shorthand syntax. But we haven’t applied any test to the value in the <code>id</code> field in this arm, as we did with the first two arms: Any value would match this pattern.</p>
<p><code>@</code>를 사용하면 하나의 패턴 내에서 값을 테스트하는 동시에 변수에 저장할 수 있습니다.</p>
<h2 id="요약"><a class="header" href="#요약">요약</a></h2>
<p>Rust’s patterns are very useful in distinguishing between different kinds of data. When used in <code>match</code> expressions, Rust ensures that your patterns cover every possible value, or your program won’t compile. Patterns in <code>let</code> statements and function parameters make those constructs more useful, enabling the destructuring of values into smaller parts and assigning those parts to variables. We can create simple or complex patterns to suit our needs.</p>
<p>다음으로, 이 책의 마지막에서 두 번째 장에서는 러스트의 다양한 기능들에 대한 몇 가지 고급 측면들을 살펴보겠습니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch19-02-refutability.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch20-00-advanced-features.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch19-02-refutability.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch20-00-advanced-features.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
