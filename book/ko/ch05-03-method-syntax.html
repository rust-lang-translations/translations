<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>메서드 문법 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch05-03-method-syntax.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch05-03-method-syntax.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="메서드-문법"><a class="header" href="#메서드-문법">메서드 문법</a></h2>
<p><em>Methods</em> are similar to functions: we declare them with the <code>fn</code> keyword and a name, they can have parameters and a return value, and they contain some code that’s run when the method is called from somewhere else. Unlike functions, methods are defined within the context of a struct (or an enum or a trait object, which we cover in <a href="ch06-00-enums.html">Chapter 6</a><!-- ignore --> and <a href="ch18-02-trait-objects.html">Chapter 17</a><!-- ignore -->, respectively), and their first parameter is always <code>self</code>, which represents the instance of the struct the method is being called on.</p>
<h3 id="메서드-정의하기"><a class="header" href="#메서드-정의하기">메서드 정의하기</a></h3>
<p>Let’s change the <code>area</code> function that has a <code>Rectangle</code> instance as a parameter and instead make an <code>area</code> method defined on the <code>Rectangle</code> struct, as shown in Listing 5-13.</p>
<Listing number="5-13" file-name="src/main.rs" caption="Defining an `area` method on the `Rectangle` struct">
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}</code></pre></pre>
</Listing>
<p>To define the function within the context of <code>Rectangle</code>, we start an <code>impl</code> (implementation) block for <code>Rectangle</code>. Everything within this <code>impl</code> block will be associated with the <code>Rectangle</code> type. Then we move the <code>area</code> function within the <code>impl</code> curly brackets and change the first (and in this case, only) parameter to be <code>self</code> in the signature and everywhere within the body. In <code>main</code>, where we called the <code>area</code> function and passed <code>rect1</code> as an argument, we can instead use <em>method syntax</em> to call the <code>area</code> method on our <code>Rectangle</code> instance. The method syntax goes after an instance: we add a dot followed by the method name, parentheses, and any arguments.</p>
<p><code>area</code>의 시그니처에서 <code>rectangle: &amp;Rectangle</code> 대신 <code>&amp;self</code>를 사용합니다. <code>&amp;self</code>는 실제로는 <code>self: &amp;Self</code>의 약어입니다. <code>impl</code> 블록 내에서 <code>Self</code> 타입은 <code>impl</code> 블록이 적용되는 타입의 별칭입니다. 메서드는 첫 번째 매개변수로 <code>Self</code> 타입의 <code>self</code>라는 매개변수를 가져야 하므로, 러스트는 첫 번째 매개변수 위치에 <code>self</code>라는 이름만으로 이를 축약할 수 있도록 합니다. 이 메서드가 <code>Self</code> 인스턴스를 빌려온다는 것을 나타내기 위해 <code>self</code> 약어 앞에 <code>&amp;</code>를 여전히 사용해야 합니다. 이는 <code>rectangle: &amp;Rectangle</code>에서 했던 것과 같습니다. 메서드는 <code>self</code>의 소유권을 가져가거나, 여기서처럼 <code>self</code>를 불변으로 빌려오거나, 다른 매개변수와 마찬가지로 <code>self</code>를 가변으로 빌려올 수 있습니다.</p>
<p>여기서 <code>&amp;self</code>를 선택한 이유는 함수 버전에서 <code>&amp;Rectangle</code>을 사용한 것과 동일합니다: 우리는 소유권을 가져가고 싶지 않고, 구조체의 데이터를 읽기만 하고 쓰지 않으려 합니다. 메서드가 수행하는 작업의 일부로 메서드를 호출한 인스턴스를 변경하고 싶다면, 첫 번째 매개변수로 <code>&amp;mut self</code>를 사용할 것입니다. 첫 번째 매개변수로 <code>self</code>만 사용하여 인스턴스의 소유권을 가져가는 메서드는 드뭅니다. 이 기술은 일반적으로 메서드가 <code>self</code>를 다른 것으로 변환하고 변환 후에 호출자가 원래 인스턴스를 사용하는 것을 방지하려는 경우에 사용됩니다.</p>
<p>메서드 구문을 제공하고 모든 메서드의 시그니처에서 <code>self</code>의 타입을 반복할 필요가 없다는 점 외에, 함수 대신 메서드를 사용하는 주된 이유는 조직화 때문입니다. 우리는 타입의 인스턴스로 할 수 있는 모든 것을 하나의 <code>impl</code> 블록에 넣어, 우리가 제공하는 라이브러리의 다양한 곳에서 <code>Rectangle</code>의 기능을 찾아야 하는 미래의 사용자들을 번거롭게 하지 않습니다.</p>
<p>메서드에 구조체의 필드와 동일한 이름을 부여할 수 있다는 점에 유의하세요. 예를 들어, <code>Rectangle</code>에 <code>width</code>라는 이름의 메서드를 정의할 수 있습니다:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn width(&amp;self) -&gt; bool {
        self.width &gt; 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() {
        println!(직사각형의 너비는 0이 아닙니다. 너비는 {}입니다, rect1.width);
    }
}</code></pre></pre>
</Listing>
<p>여기서 우리는 인스턴스의 <code>width</code> 필드 값이 <code>0</code>보다 크면 <code>width</code> 메서드가 <code>true</code>를 반환하고, 값이 <code>0</code>이면 <code>false</code>를 반환하도록 선택합니다. 즉, 동일한 이름의 메서드 내에서 필드를 어떤 목적으로든 사용할 수 있습니다. <code>main</code>에서 <code>rect1.width</code> 뒤에 괄호를 붙이면 러스트는 메서드 <code>width</code>를 의미한다는 것을 압니다. 괄호를 사용하지 않으면 러스트는 필드 <code>width</code>를 의미한다는 것을 압니다.</p>
<p>항상 그런 것은 아니지만, 메서드에 필드와 동일한 이름을 부여할 때, 필드의 값만 반환하고 다른 것은 아무것도 하지 않기를 원할 때가 많습니다. 이러한 메서드를 _게터_라고 하며, 러스트는 다른 일부 언어처럼 구조체 필드에 대해 자동으로 구현하지 않습니다. 게터는 필드를 비공개로 만들고 메서드를 공개로 만들어 타입의 공개 API의 일부로 해당 필드에 대한 읽기 전용 접근을 가능하게 하므로 유용합니다. 공개 및 비공개가 무엇인지, 그리고 필드나 메서드를 공개 또는 비공개로 지정하는 방법은 <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword">7장</a><!-- ignore -->에서 논의할 것입니다.</p>
<blockquote>
<h3 id="--연산자는-어디에-있나요"><a class="header" href="#--연산자는-어디에-있나요"><code>-&gt;</code> 연산자는 어디에 있나요?</a></h3>
<p>C와 C++에서는 메서드를 호출하는 데 두 가지 다른 연산자가 사용됩니다. 객체에서 직접 메서드를 호출할 때는 <code>.</code>을 사용하고, 객체에 대한 포인터에서 메서드를 호출하고 먼저 포인터를 역참조해야 할 때는 <code>-&gt;</code>를 사용합니다. 다시 말해, <code>object</code>가 포인터인 경우 <code>object-&gt;something()</code>은 <code>(*object).something()</code>과 유사합니다.</p>
<p>러스트에는 <code>-&gt;</code> 연산자에 해당하는 것이 없습니다. 대신 러스트에는 _자동 참조 및 역참조_라는 기능이 있습니다. 메서드 호출은 러스트에서 이러한 동작을 보이는 몇 안 되는 곳 중 하나입니다.</p>
<p>작동 방식은 다음과 같습니다: <code>object.something()</code>으로 메서드를 호출하면, 러스트는 <code>&amp;</code>, <code>&amp;mut</code>, 또는 <code>*</code>를 자동으로 추가하여 <code>object</code>가 메서드의 시그니처와 일치하도록 합니다. 즉, 다음은 동일합니다:</p>
<!-- CAN'T EXTRACT SEE BUG https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug,Copy,Clone)]
</span><span class="boring">struct Point {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Point {
</span><span class="boring">   fn distance(&amp;self, other: &amp;Point) -&gt; f64 {
</span><span class="boring">       let x_squared = f64::powi(other.x - self.x, 2);
</span><span class="boring">       let y_squared = f64::powi(other.y - self.y, 2);
</span><span class="boring">
</span><span class="boring">       f64::sqrt(x_squared + y_squared)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">let p1 = Point { x: 0.0, y: 0.0 };
</span><span class="boring">let p2 = Point { x: 5.0, y: 6.5 };
</span>p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
<span class="boring">}</span></code></pre></pre>
<p>첫 번째 것이 훨씬 깔끔해 보입니다. 이 자동 참조 동작은 메서드가 명확한 수신자(즉, <code>self</code>의 타입)를 가지고 있기 때문에 작동합니다. 수신자와 메서드 이름을 고려하여 러스트는 메서드가 읽기(<code>&amp;self</code>), 변경(<code>&amp;mut self</code>), 또는 소비(<code>self</code>) 중 무엇을 하는지 명확하게 파악할 수 있습니다. 러스트가 메서드 수신자에 대해 빌림을 암시적으로 만드는 사실은 소유권을 실제로 인체공학적으로 만드는 데 큰 부분을 차지합니다.</p>
</blockquote>
<h3 id="더-많은-매개변수를-가진-메서드"><a class="header" href="#더-많은-매개변수를-가진-메서드">더 많은 매개변수를 가진 메서드</a></h3>
<p><code>Rectangle</code> 구조체에 두 번째 메서드를 구현하여 메서드 사용을 연습해 봅시다. 이번에는 <code>Rectangle</code> 인스턴스가 다른 <code>Rectangle</code> 인스턴스를 받아, 두 번째 <code>Rectangle</code>이 <code>self</code> (첫 번째 <code>Rectangle</code>) 안에 완전히 들어갈 수 있으면 <code>true</code>를 반환하고, 그렇지 않으면 <code>false</code>를 반환하도록 할 것입니다. 즉, <code>can_hold</code> 메서드를 정의한 후, 목록 5-14에 표시된 프로그램을 작성할 수 있기를 원합니다.</p>
<Listing number="5-14" file-name="src/main.rs" caption="Using the as-yet-unwritten `can_hold` method">
<pre><code class="language-rust ignore">fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!("Can rect1 hold rect2? {}", rect1.can_hold(&amp;rect2));
    println!("Can rect1 hold rect3? {}", rect1.can_hold(&amp;rect3));
}</code></pre>
</Listing>
<p>예상되는 출력은 다음과 같을 것입니다. <code>rect2</code>의 두 치수 모두 <code>rect1</code>의 치수보다 작지만, <code>rect3</code>은 <code>rect1</code>보다 넓기 때문입니다:</p>
<pre><code class="language-text">Can rect1 hold rect2? true
Can rect1 hold rect3? false
</code></pre>
<p>우리는 메서드를 정의하고 싶으므로, <code>impl Rectangle</code> 블록 안에 있을 것입니다. 메서드 이름은 <code>can_hold</code>가 될 것이고, 다른 <code>Rectangle</code>의 불변 빌림을 매개변수로 받을 것입니다. 매개변수의 타입을 알기 위해서는 메서드를 호출하는 코드를 보면 됩니다: <code>rect1.can_hold(&amp;rect2)</code>는 <code>&amp;rect2</code>를 전달하는데, 이는 <code>Rectangle</code> 인스턴스인 <code>rect2</code>에 대한 불변 빌림입니다. 이는 <code>rect2</code>를 읽기만 하면 되기 때문에 (쓰려면 가변 빌림이 필요할 것입니다) 합리적이며, <code>main</code>이 <code>rect2</code>의 소유권을 유지하여 <code>can_hold</code> 메서드를 호출한 후에도 다시 사용할 수 있도록 하기 위함입니다. <code>can_hold</code>의 반환 값은 불리언이 될 것이고, 구현은 <code>self</code>의 너비와 높이가 다른 <code>Rectangle</code>의 너비와 높이보다 각각 큰지 확인할 것입니다. 목록 5-15에 표시된 목록 5-13의 <code>impl</code> 블록에 새 <code>can_hold</code> 메서드를 추가해 봅시다.</p>
<Listing number="5-15" file-name="src/main.rs" caption="Implementing the `can_hold` method on `Rectangle` that takes another `Rectangle` instance as a parameter">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("Can rect1 hold rect2? {}", rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!("Can rect1 hold rect3? {}", rect1.can_hold(&amp;rect3));
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>목록 5-14의 <code>main</code> 함수와 함께 이 코드를 실행하면, 우리가 원하는 출력을 얻을 것입니다. 메서드는 <code>self</code> 매개변수 뒤에 추가하는 여러 매개변수를 가질 수 있으며, 이 매개변수들은 함수에서의 매개변수와 동일하게 작동합니다.</p>
<h3 id="연관-함수"><a class="header" href="#연관-함수">연관 함수</a></h3>
<p><code>impl</code> 블록 내에 정의된 모든 함수는 _연관 함수_라고 불립니다. 왜냐하면 <code>impl</code> 뒤에 오는 타입과 연관되어 있기 때문입니다. 첫 번째 매개변수로 <code>self</code>를 가지지 않는 (따라서 메서드가 아닌) 연관 함수를 정의할 수 있습니다. 왜냐하면 이들은 작업할 타입의 인스턴스가 필요 없기 때문입니다. 우리는 이미 <code>String</code> 타입에 정의된 <code>String::from</code> 함수와 같은 함수를 사용했습니다.</p>
<p>메서드가 아닌 연관 함수는 종종 구조체의 새 인스턴스를 반환하는 생성자로 사용됩니다. 이들은 종종 <code>new</code>라고 불리지만, <code>new</code>는 특별한 이름이 아니며 언어에 내장되어 있지 않습니다. 예를 들어, 우리는 <code>square</code>라는 이름의 연관 함수를 제공하여 하나의 차원 매개변수를 가지고 그것을 너비와 높이로 모두 사용하여, 동일한 값을 두 번 지정할 필요 없이 정사각형 <code>Rectangle</code>을 더 쉽게 생성할 수 있습니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn square(size: u32) -&gt; Self {
        Self {
            width: size,
            height: size,
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let sq = Rectangle::square(3);
</span><span class="boring">}</span></code></pre></pre>
<p>함수의 반환 타입과 본문에 있는 <code>Self</code> 키워드는 <code>impl</code> 키워드 뒤에 나타나는 타입의 별칭이며, 이 경우 <code>Rectangle</code>입니다.</p>
<p>이 연관 함수를 호출하려면 구조체 이름과 함께 <code>::</code> 구문을 사용합니다. <code>let sq = Rectangle::square(3);</code>가 그 예입니다. 이 함수는 구조체에 의해 네임스페이스가 지정됩니다. <code>::</code> 구문은 연관 함수와 모듈에 의해 생성된 네임스페이스 모두에 사용됩니다. <a href="ch07-02-defining-modules-to-control-scope-and-privacy.html">7장</a><!-- ignore -->에서 모듈에 대해 논의할 것입니다.</p>
<h3 id="여러-impl-블록"><a class="header" href="#여러-impl-블록">여러 <code>impl</code> 블록</a></h3>
<p>각 구조체는 여러 <code>impl</code> 블록을 가질 수 있습니다. 예를 들어, 목록 5-15는 각 메서드가 자체 <code>impl</code> 블록에 있는 목록 5-16에 표시된 코드와 동일합니다.</p>
<Listing number="5-16" caption="Rewriting Listing 5-15 using multiple `impl` blocks">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("Can rect1 hold rect2? {}", rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!("Can rect1 hold rect3? {}", rect1.can_hold(&amp;rect3));
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>여기서 이 메서드들을 여러 <code>impl</code> 블록으로 분리할 이유는 없지만, 이것은 유효한 구문입니다. 여러 <code>impl</code> 블록이 유용한 경우는 10장에서 제네릭 타입과 트레이트를 논의할 때 볼 것입니다.</p>
<h2 id="요약"><a class="header" href="#요약">요약</a></h2>
<p>구조체를 사용하면 도메인에 의미 있는 사용자 정의 타입을 생성할 수 있습니다. 구조체를 사용함으로써 연관된 데이터 조각들을 서로 연결하고 각 조각에 이름을 부여하여 코드를 명확하게 만들 수 있습니다. <code>impl</code> 블록에서는 타입과 연관된 함수를 정의할 수 있으며, 메서드는 구조체 인스턴스가 가지는 동작을 지정할 수 있는 일종의 연관 함수입니다.</p>
<p>하지만 구조체만이 사용자 정의 타입을 생성하는 유일한 방법은 아닙니다. 러스트의 열거형 기능을 사용하여 도구 상자에 또 다른 도구를 추가해 봅시다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch05-02-example-structs.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch06-00-enums.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch05-02-example-structs.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch06-00-enums.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
