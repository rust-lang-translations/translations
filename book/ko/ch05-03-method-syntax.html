<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Methods - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch05-03-method-syntax.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch05-03-method-syntax.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<p>Methods are similar to functions: We declare them with the <code>fn</code> keyword and a name, they can have parameters and a return value, and they contain some code that’s run when the method is called from somewhere else. Unlike functions, methods are defined within the context of a struct (or an enum or a trait object, which we cover in <a href="ch06-00-enums.html">Chapter 6</a><!-- ignore --> and <a href="ch18-02-trait-objects.html">Chapter 18</a><!-- ignore -->, respectively), and their first parameter is always <code>self</code>, which represents the instance of the struct the method is being called on.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="defining-methods"></a></p>
<h3 id="메서드-문법"><a class="header" href="#메서드-문법">메서드 문법</a></h3>
<p>목록 5-13에 나타난 것처럼, <code>Rectangle</code> 인스턴스를 매개변수로 갖는 <code>area</code> 함수를 변경하여 <code>Rectangle</code> 구조체에 정의된 <code>area</code> 메서드로 만들어 봅시다.</p>
<Listing number="5-13" file-name="src/main.rs" caption="Defining an `area` method on the `Rectangle` struct">
<pre><pre class="playground"><code class="language-rust edition2024">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "사각형의 넓이는 {} 제곱 픽셀입니다.",
        rect1.area()
    );
}</code></pre></pre>
</Listing>
<p>To define the function within the context of <code>Rectangle</code>, we start an <code>impl</code> (implementation) block for <code>Rectangle</code>. Everything within this <code>impl</code> block will be associated with the <code>Rectangle</code> type. Then, we move the <code>area</code> function within the <code>impl</code> curly brackets and change the first (and in this case, only) parameter to be <code>self</code> in the signature and everywhere within the body. In <code>main</code>, where we called the <code>area</code> function and passed <code>rect1</code> as an argument, we can instead use <em>method syntax</em> to call the <code>area</code> method on our <code>Rectangle</code> instance. The method syntax goes after an instance: We add a dot followed by the method name, parentheses, and any arguments.</p>
<p><code>area</code>의 시그니처에서 <code>rectangle: &amp;Rectangle</code> 대신 <code>&amp;self</code>를 사용합니다. <code>&amp;self</code>는 실제로는 <code>self: &amp;Self</code>의 약어입니다. <code>impl</code> 블록 내에서 <code>Self</code> 타입은 <code>impl</code> 블록이 적용되는 타입의 별칭입니다. 메서드는 첫 번째 매개변수로 <code>Self</code> 타입의 <code>self</code>라는 매개변수를 가져야 하므로, 러스트는 첫 번째 매개변수 위치에 <code>self</code>라는 이름만으로 이를 축약할 수 있도록 합니다. 이 메서드가 <code>Self</code> 인스턴스를 빌려온다는 것을 나타내기 위해 <code>self</code> 약어 앞에 <code>&amp;</code>를 여전히 사용해야 합니다. 이는 <code>rectangle: &amp;Rectangle</code>에서 했던 것과 같습니다. 메서드는 <code>self</code>의 소유권을 가져가거나, 여기서처럼 <code>self</code>를 불변으로 빌려오거나, 다른 매개변수와 마찬가지로 <code>self</code>를 가변으로 빌려올 수 있습니다.</p>
<p>We chose <code>&amp;self</code> here for the same reason we used <code>&amp;Rectangle</code> in the function version: We don’t want to take ownership, and we just want to read the data in the struct, not write to it. If we wanted to change the instance that we’ve called the method on as part of what the method does, we’d use <code>&amp;mut self</code> as the first parameter. Having a method that takes ownership of the instance by using just <code>self</code> as the first parameter is rare; this technique is usually used when the method transforms <code>self</code> into something else and you want to prevent the caller from using the original instance after the transformation.</p>
<p>메서드 구문을 제공하고 모든 메서드의 시그니처에서 <code>self</code>의 타입을 반복할 필요가 없다는 점 외에, 함수 대신 메서드를 사용하는 주된 이유는 조직화 때문입니다. 우리는 타입의 인스턴스로 할 수 있는 모든 것을 하나의 <code>impl</code> 블록에 넣어, 우리가 제공하는 라이브러리의 다양한 곳에서 <code>Rectangle</code>의 기능을 찾아야 하는 미래의 사용자들을 번거롭게 하지 않습니다.</p>
<p>메서드에 구조체의 필드와 동일한 이름을 부여할 수 있다는 점에 유의하세요. 예를 들어, <code>Rectangle</code>에 <code>width</code>라는 이름의 메서드를 정의할 수 있습니다:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn width(&amp;self) -&gt; bool {
        self.width &gt; 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() {
        println!(직사각형의 너비는 0이 아닙니다. 너비는 {}입니다, rect1.width);
    }
}</code></pre></pre>
</Listing>
<p>Here, we’re choosing to make the <code>width</code> method return <code>true</code> if the value in the instance’s <code>width</code> field is greater than <code>0</code> and <code>false</code> if the value is <code>0</code>: We can use a field within a method of the same name for any purpose. In <code>main</code>, when we follow <code>rect1.width</code> with parentheses, Rust knows we mean the method <code>width</code>. When we don’t use parentheses, Rust knows we mean the field <code>width</code>.</p>
<p>Often, but not always, when we give a method the same name as a field we want it to only return the value in the field and do nothing else. Methods like this are called <em>getters</em>, and Rust does not implement them automatically for struct fields as some other languages do. Getters are useful because you can make the field private but the method public and thus enable read-only access to that field as part of the type’s public API. We will discuss what public and private are and how to designate a field or method as public or private in <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword">Chapter 7</a><!-- ignore -->.</p>
<blockquote>
<h3 id="--연산자는-어디에-있나요"><a class="header" href="#--연산자는-어디에-있나요"><code>-&gt;</code> 연산자는 어디에 있나요?</a></h3>
<p>In C and C++, two different operators are used for calling methods: You use <code>.</code> if you’re calling a method on the object directly and <code>-&gt;</code> if you’re calling the method on a pointer to the object and need to dereference the pointer first. In other words, if <code>object</code> is a pointer, <code>object-&gt;something()</code> is similar to <code>(*object).something()</code>.</p>
<p>러스트에는 <code>-&gt;</code> 연산자에 해당하는 것이 없습니다. 대신 러스트에는 _자동 참조 및 역참조_라는 기능이 있습니다. 메서드 호출은 러스트에서 이러한 동작을 보이는 몇 안 되는 곳 중 하나입니다.</p>
<p>Here’s how it works: When you call a method with <code>object.something()</code>, Rust automatically adds in <code>&amp;</code>, <code>&amp;mut</code>, or <code>*</code> so that <code>object</code> matches the signature of the method. In other words, the following are the same:</p>
<!-- CAN'T EXTRACT SEE BUG https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug,Copy,Clone)]
</span><span class="boring">struct Point {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Point {
</span><span class="boring">   fn distance(&amp;self, other: &amp;Point) -&gt; f64 {
</span><span class="boring">       let x_squared = f64::powi(other.x - self.x, 2);
</span><span class="boring">       let y_squared = f64::powi(other.y - self.y, 2);
</span><span class="boring">
</span><span class="boring">       f64::sqrt(x_squared + y_squared)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">let p1 = Point { x: 0.0, y: 0.0 };
</span><span class="boring">let p2 = Point { x: 5.0, y: 6.5 };
</span>p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
<span class="boring">}</span></code></pre></pre>
<p>첫 번째 것이 훨씬 깔끔해 보입니다. 이 자동 참조 동작은 메서드가 명확한 수신자(즉, <code>self</code>의 타입)를 가지고 있기 때문에 작동합니다. 수신자와 메서드 이름을 고려하여 러스트는 메서드가 읽기(<code>&amp;self</code>), 변경(<code>&amp;mut self</code>), 또는 소비(<code>self</code>) 중 무엇을 하는지 명확하게 파악할 수 있습니다. 러스트가 메서드 수신자에 대해 빌림을 암시적으로 만드는 사실은 소유권을 실제로 인체공학적으로 만드는 데 큰 부분을 차지합니다.</p>
</blockquote>
<h3 id="더-많은-매개변수를-가진-메서드"><a class="header" href="#더-많은-매개변수를-가진-메서드">더 많은 매개변수를 가진 메서드</a></h3>
<p><code>Rectangle</code> 구조체에 두 번째 메서드를 구현하여 메서드 사용을 연습해 봅시다. 이번에는 <code>Rectangle</code> 인스턴스가 다른 <code>Rectangle</code> 인스턴스를 받아, 두 번째 <code>Rectangle</code>이 <code>self</code> (첫 번째 <code>Rectangle</code>) 안에 완전히 들어갈 수 있으면 <code>true</code>를 반환하고, 그렇지 않으면 <code>false</code>를 반환하도록 할 것입니다. 즉, <code>can_hold</code> 메서드를 정의한 후, 목록 5-14에 표시된 프로그램을 작성할 수 있기를 원합니다.</p>
<Listing number="5-14" file-name="src/main.rs" caption="Using the as-yet-unwritten `can_hold` method">
<pre><code class="language-rust ignore">fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!("rect1이 rect2를 포함할 수 있나요? {}", rect1.can_hold(&amp;rect2));
    println!("rect1이 rect3를 포함할 수 있나요? {}", rect1.can_hold(&amp;rect3));
}</code></pre>
</Listing>
<p>예상되는 출력은 다음과 같을 것입니다. <code>rect2</code>의 두 치수 모두 <code>rect1</code>의 치수보다 작지만, <code>rect3</code>은 <code>rect1</code>보다 넓기 때문입니다:</p>
<pre><code class="language-text">Can rect1 hold rect2? true
Can rect1 hold rect3? false
</code></pre>
<p>We know we want to define a method, so it will be within the <code>impl Rectangle</code> block. The method name will be <code>can_hold</code>, and it will take an immutable borrow of another <code>Rectangle</code> as a parameter. We can tell what the type of the parameter will be by looking at the code that calls the method: <code>rect1.can_hold(&amp;rect2)</code> passes in <code>&amp;rect2</code>, which is an immutable borrow to <code>rect2</code>, an instance of <code>Rectangle</code>. This makes sense because we only need to read <code>rect2</code> (rather than write, which would mean we’d need a mutable borrow), and we want <code>main</code> to retain ownership of <code>rect2</code> so that we can use it again after calling the <code>can_hold</code> method. The return value of <code>can_hold</code> will be a Boolean, and the implementation will check whether the width and height of <code>self</code> are greater than the width and height of the other <code>Rectangle</code>, respectively. Let’s add the new <code>can_hold</code> method to the <code>impl</code> block from Listing 5-13, shown in Listing 5-15.</p>
<Listing number="5-15" file-name="src/main.rs" caption="Implementing the `can_hold` method on `Rectangle` that takes another `Rectangle` instance as a parameter">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("rect1이 rect2를 포함할 수 있나요? {}", rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!("rect1이 rect3를 포함할 수 있나요? {}", rect1.can_hold(&amp;rect3));
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>목록 5-14의 <code>main</code> 함수와 함께 이 코드를 실행하면, 우리가 원하는 출력을 얻을 것입니다. 메서드는 <code>self</code> 매개변수 뒤에 추가하는 여러 매개변수를 가질 수 있으며, 이 매개변수들은 함수에서의 매개변수와 동일하게 작동합니다.</p>
<h3 id="연관-함수"><a class="header" href="#연관-함수">연관 함수</a></h3>
<p><code>impl</code> 블록 내에 정의된 모든 함수는 _연관 함수_라고 불립니다. 왜냐하면 <code>impl</code> 뒤에 오는 타입과 연관되어 있기 때문입니다. 첫 번째 매개변수로 <code>self</code>를 가지지 않는 (따라서 메서드가 아닌) 연관 함수를 정의할 수 있습니다. 왜냐하면 이들은 작업할 타입의 인스턴스가 필요 없기 때문입니다. 우리는 이미 <code>String</code> 타입에 정의된 <code>String::from</code> 함수와 같은 함수를 사용했습니다.</p>
<p>메서드가 아닌 연관 함수는 종종 구조체의 새 인스턴스를 반환하는 생성자로 사용됩니다. 이들은 종종 <code>new</code>라고 불리지만, <code>new</code>는 특별한 이름이 아니며 언어에 내장되어 있지 않습니다. 예를 들어, 우리는 <code>square</code>라는 이름의 연관 함수를 제공하여 하나의 차원 매개변수를 가지고 그것을 너비와 높이로 모두 사용하여, 동일한 값을 두 번 지정할 필요 없이 정사각형 <code>Rectangle</code>을 더 쉽게 생성할 수 있습니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn square(size: u32) -&gt; Self {
        Self {
            width: size,
            height: size,
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let sq = Rectangle::square(3);
</span><span class="boring">}</span></code></pre></pre>
<p>함수의 반환 타입과 본문에 있는 <code>Self</code> 키워드는 <code>impl</code> 키워드 뒤에 나타나는 타입의 별칭이며, 이 경우 <code>Rectangle</code>입니다.</p>
<p>To call this associated function, we use the <code>::</code> syntax with the struct name; <code>let sq = Rectangle::square(3);</code> is an example. This function is namespaced by the struct: The <code>::</code> syntax is used for both associated functions and namespaces created by modules. We’ll discuss modules in <a href="ch07-02-defining-modules-to-control-scope-and-privacy.html">Chapter 7</a><!-- ignore -->.</p>
<h3 id="여러-impl-블록"><a class="header" href="#여러-impl-블록">여러 <code>impl</code> 블록</a></h3>
<p>각 구조체는 여러 <code>impl</code> 블록을 가질 수 있습니다. 예를 들어, 목록 5-15는 각 메서드가 자체 <code>impl</code> 블록에 있는 목록 5-16에 표시된 코드와 동일합니다.</p>
<Listing number="5-16" caption="Rewriting Listing 5-15 using multiple `impl` blocks">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("rect1이 rect2를 포함할 수 있나요? {}", rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!("rect1이 rect3를 포함할 수 있나요? {}", rect1.can_hold(&amp;rect3));
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>여기서 이 메서드들을 여러 <code>impl</code> 블록으로 분리할 이유는 없지만, 이것은 유효한 구문입니다. 여러 <code>impl</code> 블록이 유용한 경우는 10장에서 제네릭 타입과 트레이트를 논의할 때 볼 것입니다.</p>
<h2 id="요약"><a class="header" href="#요약">요약</a></h2>
<p>구조체를 사용하면 도메인에 의미 있는 사용자 정의 타입을 생성할 수 있습니다. 구조체를 사용함으로써 연관된 데이터 조각들을 서로 연결하고 각 조각에 이름을 부여하여 코드를 명확하게 만들 수 있습니다. <code>impl</code> 블록에서는 타입과 연관된 함수를 정의할 수 있으며, 메서드는 구조체 인스턴스가 가지는 동작을 지정할 수 있는 일종의 연관 함수입니다.</p>
<p>But structs aren’t the only way you can create custom types: Let’s turn to Rust’s enum feature to add another tool to your toolbox.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch05-02-example-structs.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch06-00-enums.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch05-02-example-structs.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch06-00-enums.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
