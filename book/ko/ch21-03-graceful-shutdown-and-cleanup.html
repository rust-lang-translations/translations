<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>우아한 종료와 정리 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch21-03-graceful-shutdown-and-cleanup.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch21-03-graceful-shutdown-and-cleanup.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="우아한-종료와-정리"><a class="header" href="#우아한-종료와-정리">우아한 종료와 정리</a></h2>
<p>예제 21-20의 코드는 의도한 대로 스레드 풀을 사용하여 요청에 비동기적으로 응답하고 있습니다. 우리가 직접적으로 사용하지 않는 <code>workers</code>, <code>id</code>, <code>thread</code> 필드에 대한 경고가 발생하는데, 이는 우리가 아직 아무것도 정리하지 않았음을 상기시켜 줍니다. 덜 우아한 방식인 <kbd>ctrl</kbd>-<kbd>c</kbd>를 사용하여 메인 스레드를 중단하면, 다른 모든 스레드들도 요청을 처리하는 도중이더라도 즉시 중단됩니다.</p>
<p>그다음으로, 풀에 있는 각 스레드에 대해 <code>join</code>을 호출하도록 <code>Drop</code> 트레이트를 구현하겠습니다. 이를 통해 각 스레드가 종료되기 전에 처리 중인 요청을 완료할 수 있게 됩니다. 그런 다음 스레드들에게 새로운 요청 수락을 중단하고 종료해야 함을 알리는 방법을 구현할 것입니다. 이 코드가 실제로 작동하는지 확인하기 위해, 서버가 두 개의 요청만 수락한 뒤 스레드 풀을 우아하게 종료하도록 수정하겠습니다.</p>
<p>진행하면서 한 가지 주목할 점은, 이 중 어느 것도 클로저 실행을 처리하는 코드 부분에는 영향을 주지 않는다는 것입니다. 따라서 비동기 런타임을 위해 스레드 풀을 사용하는 경우에도 여기의 모든 내용은 동일하게 적용될 것입니다.</p>
<h3 id="threadpool에-drop-트레이트-구현하기"><a class="header" href="#threadpool에-drop-트레이트-구현하기"><code>ThreadPool</code>에 <code>Drop</code> 트레이트 구현하기</a></h3>
<p>먼저 스레드 풀에 <code>Drop</code>을 구현하는 것부터 시작하겠습니다. 풀이 드롭될 때, 모든 스레드들이 작업을 마칠 수 있도록 <code>join</code>을 호출해야 합니다. 예제 21-22는 <code>Drop</code> 구현의 첫 번째 시도를 보여줍니다. 이 코드는 아직 제대로 작동하지 않을 것입니다.</p>
<Listing number="21-22" file-name="src/lib.rs" caption="Joining each thread when the thread pool goes out of scope">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// 새로운 ThreadPool을 생성합니다.
</span><span class="boring">    ///
</span><span class="boring">    /// size는 풀의 스레드 개수입니다.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// `new` 함수는 size가 0일 경우 패닉을 일으킵니다.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!("워커 {}를 종료합니다", worker.id);

            worker.thread.join().unwrap();
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!("워커 {id}가 작업을 받았습니다. 실행합니다.");
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>먼저, 스레드 풀의 각 <code>workers</code>에 대해 루프를 돕니다. <code>self</code>가 가변 참조자이고 <code>worker</code>를 수정할 수 있어야 하므로 <code>&amp;mut</code>을 사용합니다. 각 워커에 대해 해당 <code>Worker</code> 인스턴스가 종료된다는 메시지를 출력한 다음, 그 <code>Worker</code> 인스턴스의 스레드에 대해 <code>join</code>을 호출합니다. 만약 <code>join</code> 호출이 실패하면, <code>unwrap</code>을 사용하여 러스트가 패닉을 일으키고 우아하지 않은 종료(ungraceful shutdown) 상태가 되도록 합니다.</p>
<p>이 코드를 컴파일할 때 발생하는 에러는 다음과 같습니다.</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0507]: cannot move out of `worker.thread` which is behind a mutable reference
    --&gt; src/lib.rs:52:13
     |
52   |             worker.thread.join().unwrap();
     |             ^^^^^^^^^^^^^ ------ `worker.thread` moved due to this method call
     |             |
     |             move occurs because `worker.thread` has type `JoinHandle&lt;()&gt;`, which does not implement the `Copy` trait
     |
note: `JoinHandle::&lt;T&gt;::join` takes ownership of the receiver `self`, which moves `worker.thread`
    --&gt; file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/std/src/thread/mod.rs:1763:17
     |
1763 |     pub fn join(self) -&gt; Result&lt;T&gt; {
     |                 ^^^^

For more information about this error, try `rustc --explain E0507`.
error: could not compile `hello` (lib) due to 1 previous error
</code></pre>
<p>이 에러는 우리가 각 <code>worker</code>에 대해 가변 대여(mutable borrow)만 가지고 있고 <code>join</code>은 그 인수의 소유권을 가져가기 때문에 <code>join</code>을 호출할 수 없음을 알려줍니다. 이 문제를 해결하려면 <code>join</code>이 스레드를 소비할 수 있도록 <code>thread</code>를 소유하고 있는 <code>Worker</code> 인스턴스 밖으로 스레드를 이동시켜야 합니다. 한 가지 방법은 예제 18-15에서 했던 것과 같은 방식을 취하는 것입니다. 만약 <code>Worker</code>가 <code>Option&lt;thread::JoinHandle&lt;()&gt;&gt;</code>를 들고 있다면, <code>Option</code>에 대해 <code>take</code> 메서드를 호출하여 <code>Some</code> 변형에서 값을 꺼내오고 그 자리에 <code>None</code> 변형을 남겨둘 수 있습니다. 즉, 실행 중인 <code>Worker</code>는 <code>thread</code> 필드에 <code>Some</code> 변형을 가지고 있을 것이고, <code>Worker</code>를 정리하고 싶을 때는 <code>Some</code>을 <code>None</code>으로 교체하여 해당 <code>Worker</code>가 실행할 스레드를 가지지 않도록 만드는 것입니다.</p>
<p>하지만 이 방식은 <code>Worker</code>를 드롭할 때에만 필요한 반면, 그 대가로 <code>worker.thread</code>에 접근하는 모든 곳에서 <code>Option&lt;thread::JoinHandle&lt;()&gt;&gt;</code>를 다뤄야만 합니다. 관용적인 러스트는 <code>Option</code>을 꽤 많이 사용하지만, 이처럼 항상 존재할 것임을 알고 있는 무언가를 임시방편으로 <code>Option</code>으로 감싸고 있다는 것을 알게 된다면, 대안적인 접근 방식을 찾아보는 것이 좋습니다. 대안을 통해 코드를 더 깔끔하고 에러가 적게 만들 수 있습니다.</p>
<p>이 경우에는 더 나은 대안이 존재합니다. 바로 <code>Vec::drain</code> 메서드입니다. 이 메서드는 <code>Vec</code>에서 제거할 아이템들의 범위를 파라미터로 받으며, 해당 아이템들의 반복자를 반환합니다. <code>..</code> 범위 문법을 전달하면 <code>Vec</code>에서 <em>모든</em> 값을 제거합니다.</p>
<p>따라서 <code>ThreadPool</code>의 <code>drop</code> 구현을 다음과 같이 업데이트해야 합니다.</p>
<Listing file-name="src/lib.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// 새로운 ThreadPool을 생성합니다.
</span><span class="boring">    ///
</span><span class="boring">    /// size는 풀의 스레드 개수입니다.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// `new` 함수는 size가 0일 경우 패닉을 일으킵니다.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in self.workers.drain(..) {
            println!("워커 {}를 종료합니다", worker.id);

            worker.thread.join().unwrap();
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!("워커 {id}가 작업을 받았습니다. 실행합니다.");
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>이것으로 컴파일러 에러가 해결되며 우리 코드에 다른 변경 사항은 필요하지 않습니다.</p>
<h3 id="스레드들에게-작업-대기-중단을-신호하기"><a class="header" href="#스레드들에게-작업-대기-중단을-신호하기">스레드들에게 작업 대기 중단을 신호하기</a></h3>
<p>지금까지의 모든 변경 사항을 적용하면 코드는 경고 없이 컴파일됩니다. 하지만 안타깝게도 이 코드는 아직 우리가 원하는 대로 작동하지 않습니다. 핵심은 <code>Worker</code> 인스턴스의 스레드들이 실행하는 클로저 내부의 로직입니다. 현재 우리는 <code>join</code>을 호출하고 있지만, 스레드들은 작업을 찾기 위해 영원히 루프(<code>loop</code>)를 돌고 있기 때문에 종료되지 않을 것입니다. 현재의 <code>drop</code> 구현으로 <code>ThreadPool</code>을 드롭하려고 시도하면, 메인 스레드는 첫 번째 스레드가 끝나기를 기다리며 영원히 블록될 것입니다.</p>
<p>이 문제를 해결하려면 <code>ThreadPool</code>의 <code>drop</code> 구현을 변경하고, 이어서 <code>Worker</code>의 루프를 변경해야 합니다.</p>
<p>먼저 스레드들이 종료되기를 기다리기 전에 <code>sender</code>를 명시적으로 드롭하도록 <code>ThreadPool</code>의 <code>drop</code> 구현을 변경하겠습니다. 예제 21-23은 <code>sender</code>를 명시적으로 드롭하기 위한 <code>ThreadPool</code>의 변경 사항을 보여줍니다. 스레드 때와 마찬가지로, 여기서도 <code>Option::take</code>를 사용하여 <code>sender</code>를 <code>ThreadPool</code> 밖으로 꺼내오기 위해 <code>Option</code>을 사용해야 합니다.</p>
<Listing number="21-23" file-name="src/lib.rs" caption="Explicitly drop `sender` before joining the `Worker` threads">
<pre><code class="language-rust noplayground not_desired_behavior"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span>pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,
}
// --생략--
<span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span>impl ThreadPool {
<span class="boring">    /// 새로운 ThreadPool을 생성합니다.
</span><span class="boring">    ///
</span><span class="boring">    /// size는 풀의 스레드 개수입니다.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// `new` 함수는 size가 0일 경우 패닉을 일으킵니다.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        // --생략--

<span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span>        ThreadPool {
            workers,
            sender: Some(sender),
        }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.as_ref().unwrap().send(job).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        drop(self.sender.take());

        for worker in self.workers.drain(..) {
            println!("워커 {}를 종료합니다", worker.id);

            worker.thread.join().unwrap();
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!("워커 {id}가 작업을 받았습니다. 실행합니다.");
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p><code>sender</code>를 드롭하면 채널이 닫히며, 이는 더 이상의 메시지가 전송되지 않을 것임을 나타냅니다. 그렇게 되면 무한 루프 내에서 <code>Worker</code> 인스턴스들이 수행하는 모든 <code>recv</code> 호출은 에러를 반환할 것입니다. 예제 21-24에서는 그러한 경우에 루프를 우아하게 빠져나오도록 <code>Worker</code> 루프를 수정합니다. 이는 <code>ThreadPool</code>의 <code>drop</code> 구현이 스레드들에 대해 <code>join</code>을 호출할 때 스레드들이 종료될 수 있음을 의미합니다.</p>
<Listing number="21-24" file-name="src/lib.rs" caption="Explicitly breaking out of the loop when `recv` returns an error">
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// 새로운 ThreadPool을 생성합니다.
</span><span class="boring">    ///
</span><span class="boring">    /// size는 풀의 스레드 개수입니다.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// `new` 함수는 size가 0일 경우 패닉을 일으킵니다.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool {
</span><span class="boring">            workers,
</span><span class="boring">            sender: Some(sender),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.as_ref().unwrap().send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for ThreadPool {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        drop(self.sender.take());
</span><span class="boring">
</span><span class="boring">        for worker in self.workers.drain(..) {
</span><span class="boring">            println!("워커 {}를 종료합니다", worker.id);
</span><span class="boring">
</span><span class="boring">            worker.thread.join().unwrap();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv();

            match message {
                Ok(job) =&gt; {
                    println!("워커 {id}가 작업을 받았습니다. 실행합니다.");

                    job();
                }
                Err(_) =&gt; {
                    println!("워커 {id}의 연결이 끊겼습니다. 종료합니다.");
                    break;
                }
            }
        });

        Worker { id, thread }
    }
}</code></pre>
</Listing>
<p>이 코드가 작동하는 모습을 보기 위해, 예제 21-25와 같이 서버가 두 개의 요청만 수락한 후 우아하게 종료되도록 <code>main</code>을 수정하겠습니다.</p>
<Listing number="21-25" file-name="src/main.rs" caption="Shutting down the server after serving two requests by exiting the loop">
<pre><code class="language-rust ignore"><span class="boring">use hello::ThreadPool;
</span><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!("종료합니다.");
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
</span><span class="boring">        "GET /sleep HTTP/1.1" =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            ("HTTP/1.1 200 OK", "hello.html")
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre>
</Listing>
<p>실제 웹 서버가 단 두 개의 요청만 처리하고 종료되는 것을 원하지는 않으실 겁니다. 이 코드는 단지 우아한 종료와 정리가 제대로 작동하는지 보여주기 위한 것입니다.</p>
<p><code>take</code> 메서드는 <code>Iterator</code> 트레이트에 정의되어 있으며 반복을 최대 처음 두 개의 아이템으로 제한합니다. <code>main</code>의 끝에서 <code>ThreadPool</code>이 스코프를 벗어나게 되고, <code>drop</code> 구현이 실행될 것입니다.</p>
<p><code>cargo run</code>으로 서버를 시작하고 세 번의 요청을 보내보세요. 세 번째 요청에서는 에러가 발생해야 하며, 터미널에서는 다음과 유사한 출력을 볼 수 있을 것입니다.</p>
<!-- manual-regeneration
cd listings/ch21-web-server/listing-21-25
cargo run
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
third request will error because server will have shut down
copy output below
Can't automate because the output depends on making requests
-->
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.41s
     Running `target/debug/hello`
워커 0이 작업을 받았습니다. 실행합니다.
종료합니다.
워커 0를 종료합니다
워커 3이 작업을 받았습니다. 실행합니다.
워커 1의 연결이 끊겼습니다. 종료합니다.
워커 2의 연결이 끊겼습니다. 종료합니다.
워커 3의 연결이 끊겼습니다. 종료합니다.
워커 0의 연결이 끊겼습니다. 종료합니다.
워커 1를 종료합니다
워커 2를 종료합니다
워커 3를 종료합니다
</code></pre>
<p>워커 ID와 출력되는 메시지의 순서는 다르게 보일 수 있습니다. 우리는 메시지를 통해 이 코드가 어떻게 작동하는지 알 수 있습니다. 워커 0과 3이 처음 두 개의 요청을 받았습니다. 서버는 두 번째 연결 이후 연결 수락을 중단했고, <code>ThreadPool</code>의 <code>Drop</code> 구현은 워커 3이 작업을 시작하기도 전에 실행되기 시작했습니다. <code>sender</code>를 드롭하면 모든 워커 인스턴스와의 연결이 끊어지고 종료를 지시합니다. 각 워커 인스턴스는 연결이 끊길 때 메시지를 출력하고, 스레드 풀은 각 워커 스레드가 완료될 때까지 기다리기 위해 <code>join</code>을 호출합니다.</p>
<p>이 특정 실행에서 흥미로운 점 하나를 주목해 보세요. <code>ThreadPool</code>이 <code>sender</code>를 드롭했고, 어떤 워커도 에러를 받기 전에 우리가 워커 0에 대해 조인(join)을 시도했습니다. 워커 0은 아직 <code>recv</code>로부터 에러를 받지 못했으므로, 메인 스레드는 워커 0이 끝나기를 기다리며 블록되었습니다. 그동안 워커 3은 작업을 받았고 그 후에 모든 스레드가 에러를 받았습니다. 워커 0이 종료되자 메인 스레드는 나머지 워커 인스턴스들이 종료되기를 기다렸습니다. 그 시점에서 워커들은 모두 루프를 빠져나와 정지된 상태였습니다.</p>
<p>축하합니다! 이제 프로젝트를 완료했습니다. 우리는 스레드 풀을 사용하여 비동기적으로 응답하는 기본적인 웹 서버를 갖게 되었습니다. 또한 서버를 우아하게 종료하고 풀의 모든 스레드를 정리할 수 있게 되었습니다.</p>
<p>참고를 위한 전체 코드는 다음과 같습니다.</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore">use hello::ThreadPool;
use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
    thread,
    time::Duration,
};

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!("종료합니다.");
}

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;stream);
    let request_line = buf_reader.lines().next().unwrap().unwrap();

    let (status_line, filename) = match &amp;request_line[..] {
        "GET / HTTP/1.1" =&gt; ("HTTP/1.1 200 OK", "hello.html"),
        "GET /sleep HTTP/1.1" =&gt; {
            thread::sleep(Duration::from_secs(5));
            ("HTTP/1.1 200 OK", "hello.html")
        }
        _ =&gt; ("HTTP/1.1 404 NOT FOUND", "404.html"),
    };

    let contents = fs::read_to_string(filename).unwrap();
    let length = contents.len();

    let response =
        format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}");

    stream.write_all(response.as_bytes()).unwrap();
}</code></pre>
</Listing>
<Listing file-name="src/lib.rs">
<pre><code class="language-rust noplayground">use std::{
    sync::{mpsc, Arc, Mutex},
    thread,
};

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,
}

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    /// 새로운 ThreadPool을 생성합니다.
    ///
    /// size는 풀의 스레드 개수입니다.
    ///
    /// # Panics
    ///
    /// `new` 함수는 size가 0일 경우 패닉을 일으킵니다.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool {
            workers,
            sender: Some(sender),
        }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.as_ref().unwrap().send(job).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        drop(self.sender.take());

        for worker in &amp;mut self.workers {
            println!("워커 {}를 종료합니다", worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}

struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv();

            match message {
                Ok(job) =&gt; {
                    println!("워커 {id}가 작업을 받았습니다. 실행합니다.");

                    job();
                }
                Err(_) =&gt; {
                    println!("워커 {id}의 연결이 끊겼습니다. 종료합니다.");
                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}</code></pre>
</Listing>
<p>여기서 더 많은 것을 할 수 있습니다! 이 프로젝트를 계속 개선하고 싶다면 다음과 같은 아이디어들이 있습니다.</p>
<ul>
<li><code>ThreadPool</code>과 그 공개 메서드들에 더 많은 문서를 추가해 보세요.</li>
<li>라이브러리의 기능에 대한 테스트를 추가해 보세요.</li>
<li><code>unwrap</code> 호출을 더 견고한 에러 처리 방식으로 변경해 보세요.</li>
<li>웹 요청 처리 외에 다른 작업을 수행하는 데 <code>ThreadPool</code>을 사용해 보세요.</li>
<li><a href="https://crates.io/">crates.io</a>에서 스레드 풀 크레이트를 찾아보고, 대신 그 크레이트를 사용하여 유사한 웹 서버를 구현해 보세요. 그런 다음 해당 크레이트의 API 및 견고함을 우리가 구현한 스레드 풀과 비교해 보세요.</li>
</ul>
<h2 id="요약"><a class="header" href="#요약">요약</a></h2>
<p>수고하셨습니다! 책의 마지막까지 오셨네요! 러스트로의 이 여정에 함께 해주셔서 감사합니다. 이제 여러분은 자신만의 러스트 프로젝트를 구현하고 다른 사람들의 프로젝트를 도울 준비가 되었습니다. 여러분의 러스트 여정에서 마주하게 될 어떤 도전 과제라도 기꺼이 도와줄 친절한 러스타시안(Rustaceans) 커뮤니티가 있다는 것을 잊지 마세요.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch21-02-multithreaded.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="appendix-00.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch21-02-multithreaded.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="appendix-00.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
