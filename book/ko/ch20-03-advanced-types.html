<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>고급 타입 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch20-03-advanced-types.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch20-03-advanced-types.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="고급-타입"><a class="header" href="#고급-타입">고급 타입</a></h2>
<p>러스트 타입 시스템에는 지금까지 언급은 했지만 아직 논의하지 않은 몇 가지 기능들이 있습니다. 먼저 뉴타입이 타입으로서 왜 유용한지 살펴보면서 일반적인 뉴타입에 대해 논의하겠습니다. 그런 다음 뉴타입과 유사하지만 의미론적으로 약간 다른 기능인 타입 별칭(type aliases)으로 넘어가겠습니다. 또한 <code>!</code> 타입과 동적 크기 타입(dynamically sized types)에 대해서도 논의할 것입니다.</p>
<h3 id="타입-안전성과-추상화를-위해-뉴타입-패턴-사용하기"><a class="header" href="#타입-안전성과-추상화를-위해-뉴타입-패턴-사용하기">타입 안전성과 추상화를 위해 뉴타입 패턴 사용하기</a></h3>
<p>이 섹션은 여러분이 앞서 <a href="ch20-02-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types">“외부 타입에 외부 트레이트를 구현하기 위해 뉴타입 패턴 사용하기”</a><!-- ignore --> 섹션을 읽었다고 가정합니다. 뉴타입 패턴은 우리가 지금까지 논의한 것 이상의 작업에도 유용하며, 여기에는 값이 혼동되지 않도록 정적으로 강제하는 것과 값의 단위를 나타내는 것이 포함됩니다. 예제 20-16에서 단위를 나타내기 위해 뉴타입을 사용하는 예를 보았습니다. <code>Millimeters</code>와 <code>Meters</code> 구조체가 <code>u32</code> 값을 뉴타입으로 감쌌던 것을 상기해 보세요. 만약 우리가 <code>Millimeters</code> 타입의 파라미터를 가진 함수를 작성한다면, 실수로 <code>Meters</code> 타입이나 평범한 <code>u32</code> 값으로 해당 함수를 호출하려는 프로그램은 컴파일되지 않을 것입니다.</p>
<p>또한 뉴타입 패턴을 사용하여 타입의 일부 구현 세부 사항을 추상화할 수 있습니다. 새로운 타입은 비공개(private)인 내부 타입의 API와는 다른 공개(public) API를 노출할 수 있습니다.</p>
<p>뉴타입은 또한 내부 구현을 숨길 수 있습니다. 예를 들어, 사람의 ID와 이름을 연결하여 저장하는 <code>HashMap&lt;i32, String&gt;</code>을 감싸는 <code>People</code> 타입을 제공할 수 있습니다. <code>People</code>을 사용하는 코드는 우리가 제공하는 공개 API(예: <code>People</code> 컬렉션에 이름 문자열을 추가하는 메서드)하고만 상호작용할 뿐이며, 우리가 내부적으로 이름에 <code>i32</code> ID를 할당한다는 사실을 알 필요가 없습니다. 뉴타입 패턴은 18장의 <a href="ch18-01-what-is-oo.html#encapsulation-that-hides-implementation-details">“구현 세부 정보를 숨기는 캡슐화”</a><!-- ignore -->에서 다루었던 구현 세부 사항을 숨기는 캡슐화를 달성하는 가벼운 방법입니다.</p>
<h3 id="타입-별칭으로-타입-동의어-만들기"><a class="header" href="#타입-별칭으로-타입-동의어-만들기">타입 별칭으로 타입 동의어 만들기</a></h3>
<p>러스트는 기존 타입에 다른 이름을 부여하는 _타입 별칭(type alias)_을 선언하는 기능을 제공합니다. 이를 위해 <code>type</code> 키워드를 사용합니다. 예를 들어, 다음과 같이 <code>i32</code>에 대한 별칭 <code>Kilometers</code>를 만들 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    type Kilometers = i32;
<span class="boring">
</span><span class="boring">    let x: i32 = 5;
</span><span class="boring">    let y: Kilometers = 5;
</span><span class="boring">
</span><span class="boring">    println!("x + y = {}", x + y);
</span><span class="boring">}</span></code></pre></pre>
<p>이제 별칭 <code>Kilometers</code>는 <code>i32</code>에 대한 _동의어(synonym)_입니다. 예제 20-16에서 만들었던 <code>Millimeters</code>나 <code>Meters</code> 타입과는 달리, <code>Kilometers</code>는 별개의 새로운 타입이 아닙니다. <code>Kilometers</code> 타입을 가진 값은 <code>i32</code> 타입의 값과 똑같이 취급됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    type Kilometers = i32;

    let x: i32 = 5;
    let y: Kilometers = 5;

    println!("x + y = {}", x + y);
<span class="boring">}</span></code></pre></pre>
<p><code>Kilometers</code>와 <code>i32</code>는 같은 타입이므로, 두 타입의 값을 서로 더할 수 있고 <code>i32</code> 파라미터를 받는 함수에 <code>Kilometers</code> 값을 전달할 수 있습니다. 하지만 이 방식으로는 앞서 논의한 뉴타입 패턴에서 얻을 수 있는 타입 검사 이점을 얻지 못합니다. 즉, 어딘가에서 <code>Kilometers</code>와 <code>i32</code> 값을 섞어서 사용하더라도 컴파일러는 에러를 내지 않을 것입니다.</p>
<p>타입 동의어의 주요 사용 사례는 반복을 줄이는 것입니다. 예를 들어, 다음과 같이 긴 타입이 있을 수 있습니다.</p>
<pre><code class="language-rust ignore">Box&lt;dyn Fn() + Send + 'static&gt;</code></pre>
<p>코드 곳곳에서 함수 시그니처나 타입 어노테이션으로 이 긴 타입을 쓰는 것은 지루하고 실수하기 쉽습니다. 예제 20-25와 같은 코드로 가득 찬 프로젝트를 상상해 보세요.</p>
<Listing number="20-25" caption="Using a long type in many places">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let f: Box&lt;dyn Fn() + Send + 'static&gt; = Box::new(|| println!("안녕"));

    fn takes_long_type(f: Box&lt;dyn Fn() + Send + 'static&gt;) {
        // --생략--
    }

    fn returns_long_type() -&gt; Box&lt;dyn Fn() + Send + 'static&gt; {
        // --생략--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>타입 별칭은 반복을 줄임으로써 이 코드를 더 관리하기 쉽게 만들어 줍니다. 예제 20-26에서는 장황한 타입을 위해 <code>Thunk</code>라는 별칭을 도입했으며, 해당 타입의 모든 사용처를 짧은 별칭인 <code>Thunk</code>로 대체할 수 있습니다.</p>
<Listing number="20-26" caption="Introducing a type alias, `Thunk`, to reduce repetition">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    type Thunk = Box&lt;dyn Fn() + Send + 'static&gt;;

    let f: Thunk = Box::new(|| println!("안녕"));

    fn takes_long_type(f: Thunk) {
        // --생략--
    }

    fn returns_long_type() -&gt; Thunk {
        // --생략--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 코드는 훨씬 읽고 쓰기 쉽습니다! 타입 별칭에 의미 있는 이름을 선택하면 의도를 전달하는 데에도 도움이 될 수 있습니다 (_thunk_는 나중에 평가될 코드를 의미하는 단어이므로, 저장되는 클로저에 적절한 이름입니다).</p>
<p>타입 별칭은 반복을 줄이기 위해 <code>Result&lt;T, E&gt;</code> 타입과 함께 자주 사용되기도 합니다. 표준 라이브러리의 <code>std::io</code> 모듈을 예로 들어보겠습니다. I/O 작업은 작업이 실패하는 상황을 처리하기 위해 종종 <code>Result&lt;T, E&gt;</code>를 반환합니다. 이 라이브러리에는 모든 가능한 I/O 에러를 나타내는 <code>std::io::Error</code> 구조체가 있습니다. <code>std::io</code>에 있는 많은 함수는 <code>E</code>가 <code>std::io::Error</code>인 <code>Result&lt;T, E&gt;</code>를 반환할 것입니다. 예를 들어 <code>Write</code> 트레이트의 다음 함수들이 그러합니다.</p>
<pre><code class="language-rust noplayground">use std::fmt;
use std::io::Error;

pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;
}</code></pre>
<p><code>Result&lt;..., Error&gt;</code>가 매우 많이 반복됩니다. 이에 따라 <code>std::io</code>에는 다음과 같은 타입 별칭 선언이 있습니다.</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span>type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
<span class="boring">
</span><span class="boring">pub trait Write {
</span><span class="boring">    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
</span><span class="boring">    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;
</span><span class="boring">
</span><span class="boring">    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
</span><span class="boring">    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
</span><span class="boring">}</span></code></pre>
<p>이 선언은 <code>std::io</code> 모듈에 있기 때문에, 우리는 완전 정규화된 별칭인 <code>std::io::Result&lt;T&gt;</code>를 사용할 수 있습니다. 즉, <code>E</code>가 <code>std::io::Error</code>로 채워진 <code>Result&lt;T, E&gt;</code>입니다. 결과적으로 <code>Write</code> 트레이트 함수의 시그니처는 다음과 같이 보이게 됩니다.</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
</span><span class="boring">
</span>pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
}</code></pre>
<p>타입 별칭은 두 가지 면에서 도움이 됩니다. 코드를 작성하기 쉽게 만들어 주며, <code>std::io</code> 전체에 걸쳐 일관된 인터페이스를 제공합니다. 이것은 별칭일 뿐이므로 다른 <code>Result&lt;T, E&gt;</code>와 동일하며, 따라서 <code>Result&lt;T, E&gt;</code>에서 작동하는 모든 메서드뿐만 아니라 <code>?</code> 연산자와 같은 특별한 문법도 함께 사용할 수 있습니다.</p>
<h3 id="결코-반환하지-않는-네버-타입"><a class="header" href="#결코-반환하지-않는-네버-타입">결코 반환하지 않는 네버 타입</a></h3>
<p>러스트에는 <code>!</code>라는 특별한 타입이 있는데, 타입 이론 용어로는 값이 없기 때문에 _빈 타입(empty type)_으로 알려져 있습니다. 우리는 함수가 결코 반환되지 않을 때 반환 타입의 자리에 위치하기 때문에 이를 _네버 타입(never type)_이라고 부르는 것을 선호합니다. 다음은 그 예입니다.</p>
<pre><code class="language-rust noplayground">fn bar() -&gt; ! {
    // --생략--
<span class="boring">    panic!();
</span>}</code></pre>
<p>이 코드는 “함수 <code>bar</code>는 네버를 반환한다”라고 읽습니다. 네버를 반환하는 함수를 _발산하는 함수(diverging functions)_라고 부릅니다. 우리는 <code>!</code> 타입의 값을 생성할 수 없으므로 <code>bar</code>는 결코 반환될 수 없습니다.</p>
<p>그런데 값을 결코 생성할 수 없는 타입이 무슨 소용이 있을까요? 숫자 맞추기 게임의 일부였던 예제 2-5의 코드를 떠올려 보세요. 예제 20-27에 그 일부를 다시 가져왔습니다.</p>
<Listing number="20-27" caption="A `match` with an arm that ends in `continue`">
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("비밀 번호는: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(추측을 입력하세요.);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        // --생략--
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("줄 읽기 실패");
</span><span class="boring">
</span>        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };
<span class="boring">
</span><span class="boring">        println!("당신의 추측: {guess}");
</span><span class="boring">
</span><span class="boring">        // --생략--
</span><span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!("너무 작아요!"),
</span><span class="boring">            Ordering::Greater =&gt; println!("너무 커요!"),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!("당신이 이겼습니다!");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>당시에 우리는 이 코드의 일부 세부 사항을 건너뛰었습니다. 6장의 <a href="ch06-02-match.html#the-match-control-flow-operator">“<code>match</code> 제어 흐름 연산자”</a><!-- ignore -->에서 우리는 <code>match</code> 암(arm)들이 모두 같은 타입을 반환해야 한다고 논의했습니다. 따라서 예를 들어 다음 코드는 작동하지 않습니다.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let guess = "3";
</span>    let guess = match guess.trim().parse() {
        Ok(_) =&gt; 5,
        Err(_) =&gt; "hello",
    };
<span class="boring">}</span></code></pre>
<p>이 코드에서 <code>guess</code>의 타입은 정수_이면서 동시에_ 문자열이어야 하는데, 러스트는 <code>guess</code>가 단 하나의 타입만 가질 것을 요구합니다. 그렇다면 <code>continue</code>는 무엇을 반환할까요? 예제 20-27에서 어떻게 한쪽 암에서는 <code>u32</code>를 반환하고 다른 쪽 암은 <code>continue</code>로 끝낼 수 있었을까요?</p>
<p>여러분이 짐작하셨겠지만, <code>continue</code>는 <code>!</code> 값을 가집니다. 즉, 러스트가 <code>guess</code>의 타입을 계산할 때 두 <code>match</code> 암을 모두 살피는데, 전자는 <code>u32</code> 값을 가지고 후자는 <code>!</code> 값을 가집니다. <code>!</code>는 결코 값을 가질 수 없기 때문에, 러스트는 <code>guess</code>의 타입이 <code>u32</code>라고 결정합니다.</p>
<p>이 동작을 설명하는 공식적인 방법은 <code>!</code> 타입의 표현식은 다른 어떤 타입으로도 강제 변환(coerced)될 수 있다는 것입니다. 우리가 이 <code>match</code> 암을 <code>continue</code>로 끝낼 수 있는 이유는 <code>continue</code>가 값을 반환하지 않기 때문입니다. 대신 제어 흐름을 루프의 처음으로 되돌리므로, <code>Err</code> 케이스에서는 <code>guess</code>에 결코 값을 할당하지 않게 됩니다.</p>
<p>네버 타입은 <code>panic!</code> 매크로와 함께 사용할 때도 유용합니다. <code>Option&lt;T&gt;</code> 값에서 값을 생성하거나 패닉을 일으키기 위해 호출하는 <code>unwrap</code> 함수의 정의를 떠올려 보세요.</p>
<pre><code class="language-rust ignore"><span class="boring">enum Option&lt;T&gt; {
</span><span class="boring">    Some(T),
</span><span class="boring">    None,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::Option::*;
</span><span class="boring">
</span>impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!(`None` 값에 대해 `Option::unwrap()`을 호출했습니다),
        }
    }
}</code></pre>
<p>이 코드에서도 예제 20-27의 <code>match</code>와 같은 일이 일어납니다. 러스트는 <code>val</code>이 <code>T</code> 타입을 가지고 <code>panic!</code>이 <code>!</code> 타입을 가지는 것을 확인하므로, 전체 <code>match</code> 표현식의 결과는 <code>T</code>가 됩니다. 이 코드가 작동하는 이유는 <code>panic!</code>이 값을 생성하는 대신 프로그램을 종료하기 때문입니다. <code>None</code> 케이스의 경우 <code>unwrap</code>에서 값을 반환하지 않게 되므로, 이 코드는 유효합니다.</p>
<p><code>!</code> 타입을 갖는 마지막 표현식은 <code>loop</code>입니다.</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    print!("영원히 ");

    loop {
        print!("그리고 언제까지나 ");
    }
<span class="boring">}</span></code></pre>
<p>여기서 루프는 결코 끝나지 않으므로, 표현식의 값은 <code>!</code>가 됩니다. 하지만 <code>break</code>를 포함한다면 이야기가 달라지는데, <code>break</code>에 도달했을 때 루프가 종료되기 때문입니다.</p>
<h3 id="동적-크기-타입과-sized-트레이트"><a class="header" href="#동적-크기-타입과-sized-트레이트">동적 크기 타입과 <code>Sized</code> 트레이트</a></h3>
<p>러스트는 특정 타입의 값에 대해 얼마만큼의 공간을 할당해야 하는지와 같은 타입에 대한 특정 세부 사항을 알아야 합니다. 이 때문에 타입 시스템의 한 구석이 처음에는 조금 혼란스러울 수 있는데, 바로 _동적 크기 타입(dynamically sized types)_이라는 개념입니다. 때때로 <em>DST</em> 또는 _크기가 정해지지 않은 타입(unsized types)_이라고도 불리는 이 타입들은 런타임에만 크기를 알 수 있는 값을 사용하여 코드를 작성할 수 있게 해줍니다.</p>
<p>이 책 전반에 걸쳐 사용해 온 <code>str</code>이라는 동적 크기 타입에 대해 자세히 알아보겠습니다. 그렇습니다, <code>&amp;str</code>이 아니라 <code>str</code> 그 자체가 DST입니다. 우리는 런타임 전까지는 문자열이 얼마나 긴지 알 수 없으며, 이는 우리가 <code>str</code> 타입의 변수를 생성하거나 <code>str</code> 타입의 인수를 받을 수 없음을 의미합니다. 작동하지 않는 다음 코드를 살펴보세요.</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1: str = "Hello there!";
    let s2: str = "잘 지내시나요?";
<span class="boring">}</span></code></pre>
<p>러스트는 특정 타입의 모든 값에 대해 얼마만큼의 메모리를 할당해야 하는지 알아야 하며, 같은 타입의 모든 값은 동일한 양의 메모리를 사용해야 합니다. 만약 러스트가 이 코드를 허용했다면, 이 두 <code>str</code> 값은 동일한 양의 공간을 차지해야 했을 것입니다. 하지만 이들은 길이가 다릅니다. <code>s1</code>은 12바이트의 저장 공간이 필요하고 <code>s2</code>는 15바이트가 필요합니다. 이것이 동적 크기 타입을 담는 변수를 생성하는 것이 불가능한 이유입니다.</p>
<p>그렇다면 어떻게 해야 할까요? 이 경우 여러분은 이미 답을 알고 있습니다. <code>s1</code>과 <code>s2</code>의 타입을 <code>str</code>이 아닌 <code>&amp;str</code>로 만드는 것입니다. 4장의 <a href="ch04-03-slices.html#string-slices">“문자열 슬라이스”</a><!-- ignore -->에서 슬라이스 데이터 구조는 슬라이스의 시작 위치와 길이만을 저장한다고 했던 것을 상기해 보세요. 따라서 <code>&amp;T</code>는 <code>T</code>가 위치한 메모리 주소를 저장하는 단일 값이지만, <code>&amp;str</code>은 <code>str</code>의 주소와 그 길이라는 _두 개_의 값입니다. 이처럼 우리는 컴파일 시간에 <code>&amp;str</code> 값의 크기를 알 수 있습니다. 그것은 <code>usize</code> 길이의 두 배입니다. 즉, 우리는 참조하는 문자열이 아무리 길더라도 <code>&amp;str</code>의 크기를 항상 알 수 있습니다. 일반적으로 이것이 러스트에서 동적 크기 타입이 사용되는 방식입니다. 이들은 동적 정보의 크기를 저장하는 추가적인 메타데이터를 가집니다. 동적 크기 타입의 황금률은 우리가 반드시 동적 크기 타입의 값을 어떤 종류의 포인터 뒤에 두어야 한다는 것입니다.</p>
<p>우리는 <code>str</code>을 모든 종류의 포인터와 결합할 수 있습니다. 예를 들어 <code>Box&lt;str&gt;</code>이나 <code>Rc&lt;str&gt;</code>이 있습니다. 사실, 여러분은 이미 다른 동적 크기 타입인 트레이트에서 이를 본 적이 있습니다. 모든 트레이트는 트레이트의 이름을 사용하여 참조할 수 있는 동적 크기 타입입니다. 18장의 <a href="ch18-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">“다른 타입의 값을 허용하는 트레이트 객체 사용하기”</a><!-- ignore -->에서 트레이트를 트레이트 객체로 사용하려면 <code>&amp;dyn Trait</code>나 <code>Box&lt;dyn Trait&gt;</code> (<code>Rc&lt;dyn Trait&gt;</code>도 가능)와 같이 포인터 뒤에 두어야 한다고 언급했습니다.</p>
<p>DST를 다루기 위해, 러스트는 타입의 크기를 컴파일 시간에 알 수 있는지 여부를 결정하는 <code>Sized</code> 트레이트를 제공합니다. 이 트레이트는 컴파일 시간에 크기를 알 수 있는 모든 것에 대해 자동으로 구현됩니다. 또한, 러스트는 모든 제네릭 함수에 대해 <code>Sized</code> 바운드를 암묵적으로 추가합니다. 즉, 다음과 같은 제네릭 함수 정의는</p>
<pre><code class="language-rust ignore">fn generic&lt;T&gt;(t: T) {
    // --생략--
}</code></pre>
<p>사실상 다음과 같이 작성한 것과 같이 취급됩니다.</p>
<pre><code class="language-rust ignore">fn generic&lt;T: Sized&gt;(t: T) {
    // --생략--
}</code></pre>
<p>기본적으로 제네릭 함수는 컴파일 시간에 크기가 알려진 타입에 대해서만 작동합니다. 하지만 다음과 같은 특별한 문법을 사용하여 이 제한을 완화할 수 있습니다.</p>
<pre><code class="language-rust ignore">fn generic&lt;T: ?Sized&gt;(t: &amp;T) {
    // --생략--
}</code></pre>
<p><code>?Sized</code> 트레이트 바운드는 “<code>T</code>는 <code>Sized</code>일 수도 있고 아닐 수도 있다”는 것을 의미하며, 이 표기법은 제네릭 타입이 컴파일 시간에 알려진 크기를 가져야 한다는 기본 규칙을 덮어씁니다. 이러한 의미를 갖는 <code>?Trait</code> 문법은 오직 <code>Sized</code>에 대해서만 사용 가능하며, 다른 트레이트에는 사용할 수 없습니다.</p>
<p>또한 <code>t</code> 파라미터의 타입을 <code>T</code>에서 <code>&amp;T</code>로 변경했다는 점에 주목하세요. 해당 타입이 <code>Sized</code>가 아닐 수도 있기 때문에, 우리는 이를 어떤 종류의 포인터 뒤에서 사용해야 합니다. 이 경우에는 참조자를 선택했습니다.</p>
<p>다음으로 함수와 클로저에 대해 이야기하겠습니다!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch20-02-advanced-traits.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch20-04-advanced-functions-and-closures.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch20-02-advanced-traits.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch20-04-advanced-functions-and-closures.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
