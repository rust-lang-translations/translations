<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>고급 타입 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch20-03-advanced-types.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch20-03-advanced-types.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="고급-타입"><a class="header" href="#고급-타입">고급 타입</a></h2>
<p>The Rust type system has some features that we’ve so far mentioned but haven’t yet discussed. We’ll start by discussing newtypes in general as we examine why they are useful as types. Then, we’ll move on to type aliases, a feature similar to newtypes but with slightly different semantics. We’ll also discuss the <code>!</code> type and dynamically sized types.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="using-the-newtype-pattern-for-type-safety-and-abstraction"></a></p>
<h3 id="type-safety-and-abstraction-with-the-newtype-pattern"><a class="header" href="#type-safety-and-abstraction-with-the-newtype-pattern">Type Safety and Abstraction with the Newtype Pattern</a></h3>
<p>This section assumes you’ve read the earlier section <a href="ch20-02-advanced-traits.html#implementing-external-traits-with-the-newtype-pattern">“Implementing External Traits with the Newtype Pattern”</a><!-- ignore -->. The newtype pattern is also useful for tasks beyond those we’ve discussed so far, including statically enforcing that values are never confused and indicating the units of a value. You saw an example of using newtypes to indicate units in Listing 20-16: Recall that the <code>Millimeters</code> and <code>Meters</code> structs wrapped <code>u32</code> values in a newtype. If we wrote a function with a parameter of type <code>Millimeters</code>, we wouldn’t be able to compile a program that accidentally tried to call that function with a value of type <code>Meters</code> or a plain <code>u32</code>.</p>
<p>We can also use the newtype pattern to abstract away some implementation details of a type: The new type can expose a public API that is different from the API of the private inner type.</p>
<p>Newtypes can also hide internal implementation. For example, we could provide a <code>People</code> type to wrap a <code>HashMap&lt;i32, String&gt;</code> that stores a person’s ID associated with their name. Code using <code>People</code> would only interact with the public API we provide, such as a method to add a name string to the <code>People</code> collection; that code wouldn’t need to know that we assign an <code>i32</code> ID to names internally. The newtype pattern is a lightweight way to achieve encapsulation to hide implementation details, which we discussed in the <a href="ch18-01-what-is-oo.html#encapsulation-that-hides-implementation-details">“Encapsulation that Hides Implementation Details”</a><!-- ignore --> section in Chapter 18.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="creating-type-synonyms-with-type-aliases"></a></p>
<h3 id="type-synonyms-and-type-aliases"><a class="header" href="#type-synonyms-and-type-aliases">Type Synonyms and Type Aliases</a></h3>
<p>러스트는 기존 타입에 다른 이름을 부여하는 _타입 별칭(type alias)_을 선언하는 기능을 제공합니다. 이를 위해 <code>type</code> 키워드를 사용합니다. 예를 들어, 다음과 같이 <code>i32</code>에 대한 별칭 <code>Kilometers</code>를 만들 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    type Kilometers = i32;
<span class="boring">
</span><span class="boring">    let x: i32 = 5;
</span><span class="boring">    let y: Kilometers = 5;
</span><span class="boring">
</span><span class="boring">    println!("x + y = {}", x + y);
</span><span class="boring">}</span></code></pre></pre>
<p>Now the alias <code>Kilometers</code> is a <em>synonym</em> for <code>i32</code>; unlike the <code>Millimeters</code> and <code>Meters</code> types we created in Listing 20-16, <code>Kilometers</code> is not a separate, new type. Values that have the type <code>Kilometers</code> will be treated the same as values of type <code>i32</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    type Kilometers = i32;

    let x: i32 = 5;
    let y: Kilometers = 5;

    println!("x + y = {}", x + y);
<span class="boring">}</span></code></pre></pre>
<p>Because <code>Kilometers</code> and <code>i32</code> are the same type, we can add values of both types and can pass <code>Kilometers</code> values to functions that take <code>i32</code> parameters. However, using this method, we don’t get the type-checking benefits that we get from the newtype pattern discussed earlier. In other words, if we mix up <code>Kilometers</code> and <code>i32</code> values somewhere, the compiler will not give us an error.</p>
<p>타입 동의어의 주요 사용 사례는 반복을 줄이는 것입니다. 예를 들어, 다음과 같이 긴 타입이 있을 수 있습니다.</p>
<pre><code class="language-rust ignore">Box&lt;dyn Fn() + Send + 'static&gt;</code></pre>
<p>Writing this lengthy type in function signatures and as type annotations all over the code can be tiresome and error-prone. Imagine having a project full of code like that in Listing 20-25.</p>
<Listing number="20-25" caption="Using a long type in many places">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let f: Box&lt;dyn Fn() + Send + 'static&gt; = Box::new(|| println!("안녕"));

    fn takes_long_type(f: Box&lt;dyn Fn() + Send + 'static&gt;) {
        // --생략--
    }

    fn returns_long_type() -&gt; Box&lt;dyn Fn() + Send + 'static&gt; {
        // --생략--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>타입 별칭은 반복을 줄임으로써 이 코드를 더 관리하기 쉽게 만들어 줍니다. 예제 20-26에서는 장황한 타입을 위해 <code>Thunk</code>라는 별칭을 도입했으며, 해당 타입의 모든 사용처를 짧은 별칭인 <code>Thunk</code>로 대체할 수 있습니다.</p>
<Listing number="20-26" caption="Introducing a type alias, `Thunk`, to reduce repetition">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    type Thunk = Box&lt;dyn Fn() + Send + 'static&gt;;

    let f: Thunk = Box::new(|| println!("안녕"));

    fn takes_long_type(f: Thunk) {
        // --생략--
    }

    fn returns_long_type() -&gt; Thunk {
        // --생략--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>이 코드는 훨씬 읽고 쓰기 쉽습니다! 타입 별칭에 의미 있는 이름을 선택하면 의도를 전달하는 데에도 도움이 될 수 있습니다 (_thunk_는 나중에 평가될 코드를 의미하는 단어이므로, 저장되는 클로저에 적절한 이름입니다).</p>
<p>타입 별칭은 반복을 줄이기 위해 <code>Result&lt;T, E&gt;</code> 타입과 함께 자주 사용되기도 합니다. 표준 라이브러리의 <code>std::io</code> 모듈을 예로 들어보겠습니다. I/O 작업은 작업이 실패하는 상황을 처리하기 위해 종종 <code>Result&lt;T, E&gt;</code>를 반환합니다. 이 라이브러리에는 모든 가능한 I/O 에러를 나타내는 <code>std::io::Error</code> 구조체가 있습니다. <code>std::io</code>에 있는 많은 함수는 <code>E</code>가 <code>std::io::Error</code>인 <code>Result&lt;T, E&gt;</code>를 반환할 것입니다. 예를 들어 <code>Write</code> 트레이트의 다음 함수들이 그러합니다.</p>
<pre><code class="language-rust noplayground">use std::fmt;
use std::io::Error;

pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;
}</code></pre>
<p><code>Result&lt;..., Error&gt;</code>가 매우 많이 반복됩니다. 이에 따라 <code>std::io</code>에는 다음과 같은 타입 별칭 선언이 있습니다.</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span>type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
<span class="boring">
</span><span class="boring">pub trait Write {
</span><span class="boring">    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
</span><span class="boring">    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;
</span><span class="boring">
</span><span class="boring">    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
</span><span class="boring">    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
</span><span class="boring">}</span></code></pre>
<p>이 선언은 <code>std::io</code> 모듈에 있기 때문에, 우리는 완전 정규화된 별칭인 <code>std::io::Result&lt;T&gt;</code>를 사용할 수 있습니다. 즉, <code>E</code>가 <code>std::io::Error</code>로 채워진 <code>Result&lt;T, E&gt;</code>입니다. 결과적으로 <code>Write</code> 트레이트 함수의 시그니처는 다음과 같이 보이게 됩니다.</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
</span><span class="boring">
</span>pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
}</code></pre>
<p>The type alias helps in two ways: It makes code easier to write <em>and</em> it gives us a consistent interface across all of <code>std::io</code>. Because it’s an alias, it’s just another <code>Result&lt;T, E&gt;</code>, which means we can use any methods that work on <code>Result&lt;T, E&gt;</code> with it, as well as special syntax like the <code>?</code> operator.</p>
<h3 id="the-never-type-that-never-returns"><a class="header" href="#the-never-type-that-never-returns">The Never Type That Never Returns</a></h3>
<p>러스트에는 <code>!</code>라는 특별한 타입이 있는데, 타입 이론 용어로는 값이 없기 때문에 _빈 타입(empty type)_으로 알려져 있습니다. 우리는 함수가 결코 반환되지 않을 때 반환 타입의 자리에 위치하기 때문에 이를 _네버 타입(never type)_이라고 부르는 것을 선호합니다. 다음은 그 예입니다.</p>
<pre><code class="language-rust noplayground">fn bar() -&gt; ! {
    // --생략--
<span class="boring">    panic!();
</span>}</code></pre>
<p>This code is read as “the function <code>bar</code> returns never.” Functions that return never are called <em>diverging functions</em>. We can’t create values of the type <code>!</code>, so <code>bar</code> can never possibly return.</p>
<p>But what use is a type you can never create values for? Recall the code from Listing 2-5, part of the number-guessing game; we’ve reproduced a bit of it here in Listing 20-27.</p>
<Listing number="20-27" caption="A `match` with an arm that ends in `continue`">
<pre><code class="language-rust ignore"><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">use rand::Rng;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("비밀 번호는: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(추측을 입력하세요.);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        // --생략--
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("줄 읽기 실패");
</span><span class="boring">
</span>        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };
<span class="boring">
</span><span class="boring">        println!("당신의 추측: {guess}");
</span><span class="boring">
</span><span class="boring">        // --생략--
</span><span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!("너무 작아요!"),
</span><span class="boring">            Ordering::Greater =&gt; println!("너무 커요!"),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!("당신이 이겼습니다!");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>At the time, we skipped over some details in this code. In <a href="ch06-02-match.html#the-match-control-flow-construct">“The <code>match</code> Control Flow Construct”</a><!-- ignore --> section in Chapter 6, we discussed that <code>match</code> arms must all return the same type. So, for example, the following code doesn’t work:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let guess = "3";
</span>    let guess = match guess.trim().parse() {
        Ok(_) =&gt; 5,
        Err(_) =&gt; "hello",
    };
<span class="boring">}</span></code></pre>
<p>The type of <code>guess</code> in this code would have to be an integer <em>and</em> a string, and Rust requires that <code>guess</code> have only one type. So, what does <code>continue</code> return? How were we allowed to return a <code>u32</code> from one arm and have another arm that ends with <code>continue</code> in Listing 20-27?</p>
<p>여러분이 짐작하셨겠지만, <code>continue</code>는 <code>!</code> 값을 가집니다. 즉, 러스트가 <code>guess</code>의 타입을 계산할 때 두 <code>match</code> 암을 모두 살피는데, 전자는 <code>u32</code> 값을 가지고 후자는 <code>!</code> 값을 가집니다. <code>!</code>는 결코 값을 가질 수 없기 때문에, 러스트는 <code>guess</code>의 타입이 <code>u32</code>라고 결정합니다.</p>
<p>이 동작을 설명하는 공식적인 방법은 <code>!</code> 타입의 표현식은 다른 어떤 타입으로도 강제 변환(coerced)될 수 있다는 것입니다. 우리가 이 <code>match</code> 암을 <code>continue</code>로 끝낼 수 있는 이유는 <code>continue</code>가 값을 반환하지 않기 때문입니다. 대신 제어 흐름을 루프의 처음으로 되돌리므로, <code>Err</code> 케이스에서는 <code>guess</code>에 결코 값을 할당하지 않게 됩니다.</p>
<p>네버 타입은 <code>panic!</code> 매크로와 함께 사용할 때도 유용합니다. <code>Option&lt;T&gt;</code> 값에서 값을 생성하거나 패닉을 일으키기 위해 호출하는 <code>unwrap</code> 함수의 정의를 떠올려 보세요.</p>
<pre><code class="language-rust ignore"><span class="boring">enum Option&lt;T&gt; {
</span><span class="boring">    Some(T),
</span><span class="boring">    None,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::Option::*;
</span><span class="boring">
</span>impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!(`None` 값에 대해 `Option::unwrap()`을 호출했습니다),
        }
    }
}</code></pre>
<p>이 코드에서도 예제 20-27의 <code>match</code>와 같은 일이 일어납니다. 러스트는 <code>val</code>이 <code>T</code> 타입을 가지고 <code>panic!</code>이 <code>!</code> 타입을 가지는 것을 확인하므로, 전체 <code>match</code> 표현식의 결과는 <code>T</code>가 됩니다. 이 코드가 작동하는 이유는 <code>panic!</code>이 값을 생성하는 대신 프로그램을 종료하기 때문입니다. <code>None</code> 케이스의 경우 <code>unwrap</code>에서 값을 반환하지 않게 되므로, 이 코드는 유효합니다.</p>
<p>One final expression that has the type <code>!</code> is a loop:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    print!("영원히 ");

    loop {
        print!("그리고 언제까지나 ");
    }
<span class="boring">}</span></code></pre>
<p>여기서 루프는 결코 끝나지 않으므로, 표현식의 값은 <code>!</code>가 됩니다. 하지만 <code>break</code>를 포함한다면 이야기가 달라지는데, <code>break</code>에 도달했을 때 루프가 종료되기 때문입니다.</p>
<h3 id="동적-크기-타입과-sized-트레이트"><a class="header" href="#동적-크기-타입과-sized-트레이트">동적 크기 타입과 <code>Sized</code> 트레이트</a></h3>
<p>러스트는 특정 타입의 값에 대해 얼마만큼의 공간을 할당해야 하는지와 같은 타입에 대한 특정 세부 사항을 알아야 합니다. 이 때문에 타입 시스템의 한 구석이 처음에는 조금 혼란스러울 수 있는데, 바로 _동적 크기 타입(dynamically sized types)_이라는 개념입니다. 때때로 <em>DST</em> 또는 _크기가 정해지지 않은 타입(unsized types)_이라고도 불리는 이 타입들은 런타임에만 크기를 알 수 있는 값을 사용하여 코드를 작성할 수 있게 해줍니다.</p>
<p>Let’s dig into the details of a dynamically sized type called <code>str</code>, which we’ve been using throughout the book. That’s right, not <code>&amp;str</code>, but <code>str</code> on its own, is a DST. In many cases, such as when storing text entered by a user, we can’t know how long the string is until runtime. That means we can’t create a variable of type <code>str</code>, nor can we take an argument of type <code>str</code>. Consider the following code, which does not work:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1: str = "Hello there!";
    let s2: str = "잘 지내시나요?";
<span class="boring">}</span></code></pre>
<p>러스트는 특정 타입의 모든 값에 대해 얼마만큼의 메모리를 할당해야 하는지 알아야 하며, 같은 타입의 모든 값은 동일한 양의 메모리를 사용해야 합니다. 만약 러스트가 이 코드를 허용했다면, 이 두 <code>str</code> 값은 동일한 양의 공간을 차지해야 했을 것입니다. 하지만 이들은 길이가 다릅니다. <code>s1</code>은 12바이트의 저장 공간이 필요하고 <code>s2</code>는 15바이트가 필요합니다. 이것이 동적 크기 타입을 담는 변수를 생성하는 것이 불가능한 이유입니다.</p>
<p>So, what do we do? In this case, you already know the answer: We make the type of <code>s1</code> and <code>s2</code> string slice (<code>&amp;str</code>) rather than <code>str</code>. Recall from the <a href="ch04-03-slices.html#string-slices">“String Slices”</a><!-- ignore --> section in Chapter 4 that the slice data structure only stores the starting position and the length of the slice. So, although <code>&amp;T</code> is a single value that stores the memory address of where the <code>T</code> is located, a string slice is <em>two</em> values: the address of the <code>str</code> and its length. As such, we can know the size of a string slice value at compile time: It’s twice the length of a <code>usize</code>. That is, we always know the size of a string slice, no matter how long the string it refers to is. In general, this is the way in which dynamically sized types are used in Rust: They have an extra bit of metadata that stores the size of the dynamic information. The golden rule of dynamically sized types is that we must always put values of dynamically sized types behind a pointer of some kind.</p>
<p>We can combine <code>str</code> with all kinds of pointers: for example, <code>Box&lt;str&gt;</code> or <code>Rc&lt;str&gt;</code>. In fact, you’ve seen this before but with a different dynamically sized type: traits. Every trait is a dynamically sized type we can refer to by using the name of the trait. In the <a href="ch18-02-trait-objects.html#using-trait-objects-to-abstract-over-shared-behavior">“Using Trait Objects to Abstract over Shared Behavior”</a><!--
ignore --> section in Chapter 18, we mentioned that to use traits as trait objects, we must put them behind a pointer, such as <code>&amp;dyn Trait</code> or <code>Box&lt;dyn Trait&gt;</code> (<code>Rc&lt;dyn Trait&gt;</code> would work too).</p>
<p>DST를 다루기 위해, 러스트는 타입의 크기를 컴파일 시간에 알 수 있는지 여부를 결정하는 <code>Sized</code> 트레이트를 제공합니다. 이 트레이트는 컴파일 시간에 크기를 알 수 있는 모든 것에 대해 자동으로 구현됩니다. 또한, 러스트는 모든 제네릭 함수에 대해 <code>Sized</code> 바운드를 암묵적으로 추가합니다. 즉, 다음과 같은 제네릭 함수 정의는</p>
<pre><code class="language-rust ignore">fn generic&lt;T&gt;(t: T) {
    // --생략--
}</code></pre>
<p>사실상 다음과 같이 작성한 것과 같이 취급됩니다.</p>
<pre><code class="language-rust ignore">fn generic&lt;T: Sized&gt;(t: T) {
    // --생략--
}</code></pre>
<p>기본적으로 제네릭 함수는 컴파일 시간에 크기가 알려진 타입에 대해서만 작동합니다. 하지만 다음과 같은 특별한 문법을 사용하여 이 제한을 완화할 수 있습니다.</p>
<pre><code class="language-rust ignore">fn generic&lt;T: ?Sized&gt;(t: &amp;T) {
    // --생략--
}</code></pre>
<p>A trait bound on <code>?Sized</code> means “<code>T</code> may or may not be <code>Sized</code>,” and this notation overrides the default that generic types must have a known size at compile time. The <code>?Trait</code> syntax with this meaning is only available for <code>Sized</code>, not any other traits.</p>
<p>또한 <code>t</code> 파라미터의 타입을 <code>T</code>에서 <code>&amp;T</code>로 변경했다는 점에 주목하세요. 해당 타입이 <code>Sized</code>가 아닐 수도 있기 때문에, 우리는 이를 어떤 종류의 포인터 뒤에서 사용해야 합니다. 이 경우에는 참조자를 선택했습니다.</p>
<p>다음으로 함수와 클로저에 대해 이야기하겠습니다!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch20-02-advanced-traits.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch20-04-advanced-functions-and-closures.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch20-02-advanced-traits.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch20-04-advanced-functions-and-closures.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
