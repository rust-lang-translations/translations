<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>모듈 트리의 항목을 참조하는 경로 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="모듈-트리의-항목을-참조하는-경로"><a class="header" href="#모듈-트리의-항목을-참조하는-경로">모듈 트리의 항목을 참조하는 경로</a></h2>
<p>러스트에게 모듈 트리에서 항목을 어디서 찾을지 알려주기 위해, 우리는 파일 시스템을 탐색할 때 경로를 사용하는 것과 동일한 방식으로 경로를 사용합니다. 함수를 호출하려면 그 함수의 경로를 알아야 합니다.</p>
<p>경로는 두 가지 형태를 가질 수 있습니다:</p>
<ul>
<li>_절대 경로(absolute path)_는 크레이트 루트로부터 시작하는 전체 경로입니다. 외부 크레이트로부터 온 코드의 경우 절대 경로는 크레이트 이름으로 시작하고, 현재 크레이트로부터 온 코드의 경우 <code>crate</code> 리터럴로 시작합니다.</li>
<li>_상대 경로(relative path)_는 현재 모듈로부터 시작하며 <code>self</code>, <code>super</code>, 혹은 현재 모듈 내의 식별자를 사용합니다.</li>
</ul>
<p>절대 경로와 상대 경로 모두 이중 콜론(<code>::</code>)으로 구분된 하나 이상의 식별자가 뒤따릅니다.</p>
<p>목록 7-1로 돌아가서, 우리가 <code>add_to_waitlist</code> 함수를 호출하고 싶다고 해봅시다. 이는 <code>add_to_waitlist</code> 함수의 경로가 무엇인지 묻는 것과 같습니다. 목록 7-3은 일부 모듈과 함수를 제거한 목록 7-1을 포함하고 있습니다.</p>
<p>크레이트 루트에 정의된 새로운 함수 <code>eat_at_restaurant</code>에서 <code>add_to_waitlist</code> 함수를 호출하는 두 가지 방법을 보여드리겠습니다. 이 경로들은 정확하지만, 이 예제가 그대로 컴파일되는 것을 막는 또 다른 문제가 남아 있습니다. 그 이유는 잠시 후에 설명하겠습니다.</p>
<p>The <code>eat_at_restaurant</code> function is part of our library crate’s public API, so we mark it with the <code>pub</code> keyword. In the <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword">“Exposing Paths with the <code>pub</code> Keyword”</a><!-- ignore --> section, we’ll go into more detail about <code>pub</code>.</p>
<Listing number="7-3" file-name="src/lib.rs" caption="Calling the `add_to_waitlist` function using absolute and relative paths">
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}</code></pre>
</Listing>
<p>The first time we call the <code>add_to_waitlist</code> function in <code>eat_at_restaurant</code>, we use an absolute path. The <code>add_to_waitlist</code> function is defined in the same crate as <code>eat_at_restaurant</code>, which means we can use the <code>crate</code> keyword to start an absolute path. We then include each of the successive modules until we make our way to <code>add_to_waitlist</code>. You can imagine a filesystem with the same structure: we’d specify the path <code>/front_of_house/hosting/add_to_waitlist</code> to run the <code>add_to_waitlist</code> program; using the <code>crate</code> name to start from the crate root is like using <code>/</code> to start from the filesystem root in your shell.</p>
<p>The second time we call <code>add_to_waitlist</code> in <code>eat_at_restaurant</code>, we use a relative path. The path starts with <code>front_of_house</code>, the name of the module defined at the same level of the module tree as <code>eat_at_restaurant</code>. Here the filesystem equivalent would be using the path <code>front_of_house/hosting/add_to_waitlist</code>. Starting with a module name means that the path is relative.</p>
<p>Choosing whether to use a relative or absolute path is a decision you’ll make based on your project, and it depends on whether you’re more likely to move item definition code separately from or together with the code that uses the item. For example, if we moved the <code>front_of_house</code> module and the <code>eat_at_restaurant</code> function into a module named <code>customer_experience</code>, we’d need to update the absolute path to <code>add_to_waitlist</code>, but the relative path would still be valid. However, if we moved the <code>eat_at_restaurant</code> function separately into a module named <code>dining</code>, the absolute path to the <code>add_to_waitlist</code> call would stay the same, but the relative path would need to be updated. Our preference in general is to specify absolute paths because it’s more likely we’ll want to move code definitions and item calls independently of each other.</p>
<p>Let’s try to compile Listing 7-3 and find out why it won’t compile yet! The errors we get are shown in Listing 7-4.</p>
<Listing number="7-4" caption="Compiler errors from building the code in Listing 7-3">
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `hosting` is private
 --&gt; src/lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^  --------------- function `add_to_waitlist` is not publicly re-exported
  |                            |
  |                            private module
  |
note: the module `hosting` is defined here
 --&gt; src/lib.rs:2:5
  |
2 |     mod hosting {
  |     ^^^^^^^^^^^

error[E0603]: module `hosting` is private
  --&gt; src/lib.rs:12:21
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^  --------------- function `add_to_waitlist` is not publicly re-exported
   |                     |
   |                     private module
   |
note: the module `hosting` is defined here
  --&gt; src/lib.rs:2:5
   |
2  |     mod hosting {
   |     ^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` (lib) due to 2 previous errors
</code></pre>
</Listing>
<p>오류 메시지는 <code>hosting</code> 모듈이 비공개(private)라고 말합니다. 즉, <code>hosting</code> 모듈과 <code>add_to_waitlist</code> 함수에 대한 올바른 경로를 가지고 있지만, 러스트는 비공개 섹션에 접근할 수 없기 때문에 이를 사용하도록 허용하지 않습니다. 러스트에서 모든 항목(함수, 메서드, 구조체, 열거형, 모듈, 상수)은 기본적으로 부모 모듈에 대해 비공개 상태입니다. 함수나 구조체와 같은 항목을 비공개로 만들고 싶다면, 모듈 안에 넣으면 됩니다.</p>
<p>부모 모듈의 항목은 자식 모듈 내부의 비공개 항목을 사용할 수 없지만, 자식 모듈의 항목은 자신의 조상 모듈에 있는 항목을 사용할 수 있습니다. 이는 자식 모듈이 자신의 구현 세부 사항을 감싸서 숨기기 때문이지만, 자식 모듈은 자신이 정의된 맥락을 볼 수 있기 때문입니다. 비유를 계속하자면, 프라이버시 규칙을 레스토랑의 백 오피스(관리 사무실)와 같다고 생각하세요. 그 안에서 일어나는 일은 고객에게는 비공개이지만, 사무실 매니저는 자신이 운영하는 레스토랑의 모든 것을 보고 처리할 수 있습니다.</p>
<p>러스트는 내부 구현 세부 사항을 숨기는 것을 기본값으로 하기 위해 모듈 시스템이 이렇게 작동하도록 선택했습니다. 그렇게 하면 내부 코드의 어떤 부분을 외부 코드를 망가뜨리지 않고 변경할 수 있는지 알 수 있습니다. 하지만 러스트는 <code>pub</code> 키워드를 사용하여 항목을 공개(public)로 만듦으로써 자식 모듈 코드의 내부 부품을 조상 모듈에 노출할 수 있는 옵션을 제공합니다.</p>
<h3 id="pub-키워드로-경로-노출하기"><a class="header" href="#pub-키워드로-경로-노출하기"><code>pub</code> 키워드로 경로 노출하기</a></h3>
<p>목록 7-4에서 <code>hosting</code> 모듈이 비공개라고 했던 오류로 돌아가 봅시다. 부모 모듈의 <code>eat_at_restaurant</code> 함수가 자식 모듈의 <code>add_to_waitlist</code> 함수에 접근할 수 있게 하고 싶으므로, 목록 7-5에 표시된 것처럼 <code>hosting</code> 모듈을 <code>pub</code> 키워드로 표시합니다.</p>
<Listing number="7-5" file-name="src/lib.rs" caption="Declaring the `hosting` module as `pub` to use it from `eat_at_restaurant`">
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

// -- 생략 --
<span class="boring">pub fn eat_at_restaurant() {
</span><span class="boring">    // Absolute path
</span><span class="boring">    crate::front_of_house::hosting::add_to_waitlist();
</span><span class="boring">
</span><span class="boring">    // Relative path
</span><span class="boring">    front_of_house::hosting::add_to_waitlist();
</span><span class="boring">}</span></code></pre>
</Listing>
<p>안타깝게도 목록 7-5의 코드는 목록 7-6에 표시된 것처럼 여전히 컴파일러 오류를 발생시킵니다.</p>
<Listing number="7-6" caption="Compiler errors from building the code in Listing 7-5">
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: function `add_to_waitlist` is private
 --&gt; src/lib.rs:9:37
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                                     ^^^^^^^^^^^^^^^ private function
  |
note: the function `add_to_waitlist` is defined here
 --&gt; src/lib.rs:3:9
  |
3 |         fn add_to_waitlist() {}
  |         ^^^^^^^^^^^^^^^^^^^^

error[E0603]: function `add_to_waitlist` is private
  --&gt; src/lib.rs:12:30
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                              ^^^^^^^^^^^^^^^ private function
   |
note: the function `add_to_waitlist` is defined here
  --&gt; src/lib.rs:3:9
   |
3  |         fn add_to_waitlist() {}
   |         ^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` (lib) due to 2 previous errors
</code></pre>
</Listing>
<p>무슨 일이 일어난 걸까요? <code>mod hosting</code> 앞에 <code>pub</code> 키워드를 추가하면 모듈이 공개됩니다. 이 변경으로 <code>front_of_house</code>에 접근할 수 있다면 <code>hosting</code>에도 접근할 수 있게 됩니다. 하지만 <code>hosting</code>의 _내용물_은 여전히 비공개입니다. 모듈을 공개로 만든다고 해서 그 내용물까지 공개되는 것은 아닙니다. 모듈에 붙은 <code>pub</code> 키워드는 단지 조상 모듈의 코드가 해당 모듈을 참조할 수 있게 할 뿐이며, 내부 코드에 접근할 수 있게 하는 것은 아닙니다. 모듈은 컨테이너이므로, 모듈만 공개로 해서는 할 수 있는 일이 많지 않습니다. 더 나아가 모듈 내의 하나 이상의 항목도 공개로 만들도록 선택해야 합니다.</p>
<p>목록 7-6의 오류들은 <code>add_to_waitlist</code> 함수가 비공개라고 말합니다. 프라이버시 규칙은 모듈뿐만 아니라 구조체, 열거형, 함수, 메서드에도 적용됩니다.</p>
<p>목록 7-7처럼 정의 앞에 <code>pub</code> 키워드를 추가하여 <code>add_to_waitlist</code> 함수도 공개로 만들어 봅시다.</p>
<Listing number="7-7" file-name="src/lib.rs" caption="Adding the `pub` keyword to `mod hosting` and `fn add_to_waitlist` lets us call the function from `eat_at_restaurant`">
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

// -- 생략 --
<span class="boring">pub fn eat_at_restaurant() {
</span><span class="boring">    // Absolute path
</span><span class="boring">    crate::front_of_house::hosting::add_to_waitlist();
</span><span class="boring">
</span><span class="boring">    // Relative path
</span><span class="boring">    front_of_house::hosting::add_to_waitlist();
</span><span class="boring">}</span></code></pre>
</Listing>
<p>이제 코드가 컴파일됩니다! <code>pub</code> 키워드를 추가한 것이 왜 프라이버시 규칙 측면에서 <code>eat_at_restaurant</code> 내의 이 경로들을 사용할 수 있게 해주는지 알아보기 위해, 절대 경로와 상대 경로를 살펴봅시다.</p>
<p>절대 경로에서는 우리 크레이트 모듈 트리의 루트인 <code>crate</code>로 시작합니다. <code>front_of_house</code> 모듈은 크레이트 루트에 정의되어 있습니다. <code>front_of_house</code>가 공개는 아니지만, <code>eat_at_restaurant</code> 함수가 <code>front_of_house</code>와 동일한 모듈에 정의되어 있기 때문에(즉, 둘은 형제 관계입니다), <code>eat_at_restaurant</code>에서 <code>front_of_house</code>를 참조할 수 있습니다. 다음은 <code>pub</code>으로 표시된 <code>hosting</code> 모듈입니다. 우리는 <code>hosting</code>의 부모 모듈에 접근할 수 있으므로, <code>hosting</code>에도 접근할 수 있습니다. 마지막으로 <code>add_to_waitlist</code> 함수도 <code>pub</code>으로 표시되어 있고 우리가 그 부모 모듈에 접근할 수 있으므로, 이 함수 호출은 성공합니다!</p>
<p>상대 경로의 경우, 첫 단계를 제외하고는 절대 경로와 로직이 동일합니다. 크레이트 루트에서 시작하는 대신 <code>front_of_house</code>에서 시작합니다. <code>front_of_house</code> 모듈은 <code>eat_at_restaurant</code>와 동일한 모듈 내에 정의되어 있으므로, <code>eat_at_restaurant</code>가 정의된 모듈에서 시작하는 상대 경로가 작동합니다. 그 다음 <code>hosting</code>과 <code>add_to_waitlist</code>가 <code>pub</code>으로 표시되어 있으므로 경로의 나머지 부분도 작동하며, 이 함수 호출은 유효합니다!</p>
<p>다른 프로젝트에서 여러분의 코드를 사용할 수 있도록 라이브러리 크레이트를 공유할 계획이라면, 공개 API는 여러분의 크레이트 사용자와의 계약이며 그들이 여러분의 코드와 상호작용하는 방식을 결정합니다. 사람들이 여러분의 크레이트에 더 쉽게 의존할 수 있도록 공개 API의 변경 사항을 관리하는 데에는 많은 고려 사항이 있습니다. 이러한 고려 사항들은 이 책의 범위를 벗어납니다. 이 주제에 관심이 있다면 <a href="https://rust-lang.github.io/api-guidelines/">러스트 API 가이드라인</a>을 참조하세요.</p>
<blockquote>
<h4 id="바이너리-및-라이브러리가-있는-패키지-모범-사례"><a class="header" href="#바이너리-및-라이브러리가-있는-패키지-모범-사례">바이너리 및 라이브러리가 있는 패키지 모범 사례</a></h4>
<p>우리는 패키지가 <em>src/main.rs</em> 바이너리 크레이트 루트와 <em>src/lib.rs</em> 라이브러리 크레이트 루트를 모두 포함할 수 있으며, 두 크레이트 모두 기본적으로 패키지 이름을 갖는다고 언급했습니다. 일반적으로 라이브러리와 바이너리 크레이트를 모두 포함하는 이러한 패턴의 패키지는, 라이브러리 크레이트 내의 코드를 호출하여 실행 파일을 시작할 정도의 최소한의 코드만 바이너리 크레이트에 가집니다. 이렇게 하면 라이브러리 크레이트의 코드가 공유될 수 있으므로 다른 프로젝트들이 패키지가 제공하는 대부분의 기능으로부터 혜택을 얻을 수 있습니다.</p>
<p>모듈 트리는 _src/lib.rs_에 정의되어야 합니다. 그러면 바이너리 크레이트에서 패키지 이름으로 시작하는 경로를 사용하여 모든 공개 항목을 사용할 수 있습니다. 바이너리 크레이트는 완전히 외부의 크레이트가 라이브러리 크레이트를 사용하는 것과 마찬가지로 라이브러리 크레이트의 사용자가 됩니다. 즉, 오직 공개 API만 사용할 수 있습니다. 이는 여러분이 작성자일 뿐만 아니라 클라이언트이기도 하므로 좋은 API를 설계하는 데 도움이 됩니다!</p>
<p><a href="ch12-00-an-io-project.html">12장</a><!-- ignore -->에서, 바이너리 크레이트와 라이브러리 크레이트를 모두 포함하는 명령줄 프로그램을 통해 이러한 조직화 관례를 보여드리겠습니다.</p>
</blockquote>
<h3 id="super로-상대-경로-시작하기"><a class="header" href="#super로-상대-경로-시작하기"><code>super</code>로 상대 경로 시작하기</a></h3>
<p>우리는 경로의 시작 부분에 <code>super</code>를 사용하여 현재 모듈이나 크레이트 루트가 아닌 부모 모듈에서 시작하는 상대 경로를 만들 수 있습니다. 이는 파일 시스템 경로를 <code>..</code> 문법으로 시작하는 것과 비슷합니다. <code>super</code>를 사용하면 부모 모듈에 있다는 것을 알고 있는 항목을 참조할 수 있게 해주며, 이는 해당 모듈이 부모와 밀접하게 관련되어 있지만 언젠가 부모가 모듈 트리의 다른 곳으로 옮겨질 수도 있는 상황에서 모듈 트리를 재배치하는 것을 더 쉽게 만들어 줄 수 있습니다.</p>
<p>셰프가 잘못된 주문을 수정하고 고객에게 직접 가져다주는 상황을 모델링한 목록 7-8의 코드를 살펴봅시다. <code>back_of_house</code> 모듈에 정의된 <code>fix_incorrect_order</code> 함수는 <code>super</code>로 시작하는 <code>deliver_order</code> 경로를 지정하여 부모 모듈에 정의된 <code>deliver_order</code> 함수를 호출합니다.</p>
<Listing number="7-8" file-name="src/lib.rs" caption="Calling a function using a relative path starting with `super`">
<pre><code class="language-rust noplayground test_harness">fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order();
    }

    fn cook_order() {}
}</code></pre>
</Listing>
<p><code>fix_incorrect_order</code> 함수는 <code>back_of_house</code> 모듈에 있으므로, <code>super</code>를 사용하여 <code>back_of_house</code>의 부모 모듈(이 경우 루트인 <code>crate</code>)로 갈 수 있습니다. 거기서 <code>deliver_order</code>를 찾아 성공적으로 호출합니다! 우리는 크레이트의 모듈 트리를 재조직하더라도 <code>back_of_house</code> 모듈과 <code>deliver_order</code> 함수가 서로 동일한 관계를 유지하며 함께 이동할 가능성이 높다고 생각합니다. 따라서 <code>super</code>를 사용함으로써, 향후 이 코드가 다른 모듈로 이동하더라도 코드를 업데이트해야 할 곳을 줄일 수 있습니다.</p>
<h3 id="구조체와-열거형을-공개로-만들기"><a class="header" href="#구조체와-열거형을-공개로-만들기">구조체와 열거형을 공개로 만들기</a></h3>
<p>우리는 또한 <code>pub</code>을 사용하여 구조체와 열거형을 공개로 지정할 수 있지만, 구조체와 열거형에 <code>pub</code>을 사용하는 데에는 몇 가지 추가적인 세부 사항이 있습니다. 구조체 정의 앞에 <code>pub</code>을 사용하면 구조체는 공개되지만, 구조체의 필드들은 여전히 비공개 상태입니다. 우리는 각 필드를 상황에 따라 공개로 만들거나 만들지 않을 수 있습니다. 목록 7-9에서는 공개된 <code>toast</code> 필드와 비공개된 <code>seasonal_fruit</code> 필드를 가진 공개 구조체 <code>back_of_house::Breakfast</code>를 정의했습니다. 이는 고객이 식사와 함께 제공되는 빵의 종류를 선택할 수 있지만, 셰프가 제철 과일과 재고 상황에 따라 곁들일 과일을 결정하는 레스토랑의 상황을 모델링한 것입니다. 사용 가능한 과일은 자주 바뀌므로, 고객은 과일을 선택할 수 없으며 어떤 과일이 나올지 미리 알 수도 없습니다.</p>
<Listing number="7-9" file-name="src/lib.rs" caption="A struct with some public fields and some private fields">
<pre><code class="language-rust noplayground">mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &amp;str) -&gt; Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("복숭아"),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // 호밀 토스트와 함께 여름 아침 식사를 주문하세요.
    let mut meal = back_of_house::Breakfast::summer("호밀");
    // 어떤 빵을 먹을지 마음을 바꿉니다.
    meal.toast = String::from("밀");
    println!("{} 토스트 부탁드립니다", meal.toast);

    // 다음 줄은 주석을 해제하면 컴파일되지 않습니다. 우리는 식사와 함께 제공되는
    // 제철 과일을 보거나 수정할 수 없습니다.
    // meal.seasonal_fruit = String::from("blueberries");
}</code></pre>
</Listing>
<p><code>back_of_house::Breakfast</code> 구조체의 <code>toast</code> 필드는 공개(public)이므로, <code>eat_at_restaurant</code>에서 점 표기법을 사용하여 <code>toast</code> 필드에 쓰고 읽을 수 있습니다. <code>seasonal_fruit</code> 필드는 비공개(private)이므로 <code>eat_at_restaurant</code>에서 사용할 수 없다는 점에 유의하세요. <code>seasonal_fruit</code> 필드 값을 수정하는 줄의 주석을 해제하여 어떤 오류가 발생하는지 확인해 보세요!</p>
<p>또한, <code>back_of_house::Breakfast</code>에 비공개 필드가 있기 때문에, 구조체는 <code>Breakfast</code>의 인스턴스를 구성하는 공개 연관 함수를 제공해야 한다는 점에 유의하세요 (여기서는 <code>summer</code>라고 이름 붙였습니다). 만약 <code>Breakfast</code>에 그러한 함수가 없었다면, <code>eat_at_restaurant</code>에서 비공개 <code>seasonal_fruit</code> 필드의 값을 설정할 수 없었기 때문에 <code>eat_at_restaurant</code>에서 <code>Breakfast</code>의 인스턴스를 생성할 수 없었을 것입니다.</p>
<p>대조적으로, 열거형을 공개(public)로 만들면 모든 variant가 공개됩니다. 목록 7-10에 표시된 것처럼 <code>enum</code> 키워드 앞에 <code>pub</code>만 있으면 됩니다.</p>
<Listing number="7-10" file-name="src/lib.rs" caption="Designating an enum as public makes all its variants public.">
<pre><code class="language-rust noplayground">mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}</code></pre>
</Listing>
<p><code>Appetizer</code> 열거형을 공개로 만들었기 때문에, <code>eat_at_restaurant</code>에서 <code>Soup</code>과 <code>Salad</code> variant를 사용할 수 있습니다.</p>
<p>열거형은 variant가 공개되지 않으면 그다지 유용하지 않습니다. 모든 경우에 모든 열거형 variant에 <code>pub</code>을 명시해야 한다면 번거로울 것이므로, 열거형 variant의 기본값은 공개입니다. 구조체는 필드가 공개되지 않아도 유용한 경우가 많으므로, 구조체 필드는 <code>pub</code>으로 명시되지 않는 한 모든 것이 기본적으로 비공개라는 일반적인 규칙을 따릅니다.</p>
<p><code>pub</code>과 관련된 한 가지 더 다루지 않은 상황이 있는데, 그것은 우리의 마지막 모듈 시스템 기능인 <code>use</code> 키워드입니다. 먼저 <code>use</code> 자체를 다룬 다음, <code>pub</code>과 <code>use</code>를 결합하는 방법을 보여줄 것입니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch07-02-defining-modules-to-control-scope-and-privacy.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch07-02-defining-modules-to-control-scope-and-privacy.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
