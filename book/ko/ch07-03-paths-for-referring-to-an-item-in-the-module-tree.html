<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>모듈 트리의 항목을 참조하는 경로 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="모듈-트리의-항목을-참조하는-경로"><a class="header" href="#모듈-트리의-항목을-참조하는-경로">모듈 트리의 항목을 참조하는 경로</a></h2>
<p>러스트에게 모듈 트리에서 항목을 어디서 찾을지 알려주기 위해, 우리는 파일 시스템을 탐색할 때 경로를 사용하는 것과 동일한 방식으로 경로를 사용합니다. 함수를 호출하려면 그 함수의 경로를 알아야 합니다.</p>
<p>경로는 두 가지 형태를 가질 수 있습니다:</p>
<ul>
<li>_절대 경로(absolute path)_는 크레이트 루트로부터 시작하는 전체 경로입니다. 외부 크레이트로부터 온 코드의 경우 절대 경로는 크레이트 이름으로 시작하고, 현재 크레이트로부터 온 코드의 경우 <code>crate</code> 리터럴로 시작합니다.</li>
<li>_상대 경로(relative path)_는 현재 모듈로부터 시작하며 <code>self</code>, <code>super</code>, 혹은 현재 모듈 내의 식별자를 사용합니다.</li>
</ul>
<p>절대 경로와 상대 경로 모두 이중 콜론(<code>::</code>)으로 구분된 하나 이상의 식별자가 뒤따릅니다.</p>
<p>Returning to Listing 7-1, say we want to call the <code>add_to_waitlist</code> function. This is the same as asking: What’s the path of the <code>add_to_waitlist</code> function? Listing 7-3 contains Listing 7-1 with some of the modules and functions removed.</p>
<p>크레이트 루트에 정의된 새로운 함수 <code>eat_at_restaurant</code>에서 <code>add_to_waitlist</code> 함수를 호출하는 두 가지 방법을 보여드리겠습니다. 이 경로들은 정확하지만, 이 예제가 그대로 컴파일되는 것을 막는 또 다른 문제가 남아 있습니다. 그 이유는 잠시 후에 설명하겠습니다.</p>
<p>The <code>eat_at_restaurant</code> function is part of our library crate’s public API, so we mark it with the <code>pub</code> keyword. In the <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword">“Exposing Paths with the <code>pub</code> Keyword”</a><!-- ignore --> section, we’ll go into more detail about <code>pub</code>.</p>
<Listing number="7-3" file-name="src/lib.rs" caption="Calling the `add_to_waitlist` function using absolute and relative paths">
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}</code></pre>
</Listing>
<p>The first time we call the <code>add_to_waitlist</code> function in <code>eat_at_restaurant</code>, we use an absolute path. The <code>add_to_waitlist</code> function is defined in the same crate as <code>eat_at_restaurant</code>, which means we can use the <code>crate</code> keyword to start an absolute path. We then include each of the successive modules until we make our way to <code>add_to_waitlist</code>. You can imagine a filesystem with the same structure: We’d specify the path <code>/front_of_house/hosting/add_to_waitlist</code> to run the <code>add_to_waitlist</code> program; using the <code>crate</code> name to start from the crate root is like using <code>/</code> to start from the filesystem root in your shell.</p>
<p>The second time we call <code>add_to_waitlist</code> in <code>eat_at_restaurant</code>, we use a relative path. The path starts with <code>front_of_house</code>, the name of the module defined at the same level of the module tree as <code>eat_at_restaurant</code>. Here the filesystem equivalent would be using the path <code>front_of_house/hosting/add_to_waitlist</code>. Starting with a module name means that the path is relative.</p>
<p>Choosing whether to use a relative or absolute path is a decision you’ll make based on your project, and it depends on whether you’re more likely to move item definition code separately from or together with the code that uses the item. For example, if we moved the <code>front_of_house</code> module and the <code>eat_at_restaurant</code> function into a module named <code>customer_experience</code>, we’d need to update the absolute path to <code>add_to_waitlist</code>, but the relative path would still be valid. However, if we moved the <code>eat_at_restaurant</code> function separately into a module named <code>dining</code>, the absolute path to the <code>add_to_waitlist</code> call would stay the same, but the relative path would need to be updated. Our preference in general is to specify absolute paths because it’s more likely we’ll want to move code definitions and item calls independently of each other.</p>
<p>Let’s try to compile Listing 7-3 and find out why it won’t compile yet! The errors we get are shown in Listing 7-4.</p>
<Listing number="7-4" caption="Compiler errors from building the code in Listing 7-3">
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `hosting` is private
 --&gt; src/lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^  --------------- function `add_to_waitlist` is not publicly re-exported
  |                            |
  |                            private module
  |
note: the module `hosting` is defined here
 --&gt; src/lib.rs:2:5
  |
2 |     mod hosting {
  |     ^^^^^^^^^^^

error[E0603]: module `hosting` is private
  --&gt; src/lib.rs:12:21
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^  --------------- function `add_to_waitlist` is not publicly re-exported
   |                     |
   |                     private module
   |
note: the module `hosting` is defined here
  --&gt; src/lib.rs:2:5
   |
 2 |     mod hosting {
   |     ^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` (lib) due to 2 previous errors
</code></pre>
</Listing>
<p>오류 메시지는 <code>hosting</code> 모듈이 비공개(private)라고 말합니다. 즉, <code>hosting</code> 모듈과 <code>add_to_waitlist</code> 함수에 대한 올바른 경로를 가지고 있지만, 러스트는 비공개 섹션에 접근할 수 없기 때문에 이를 사용하도록 허용하지 않습니다. 러스트에서 모든 항목(함수, 메서드, 구조체, 열거형, 모듈, 상수)은 기본적으로 부모 모듈에 대해 비공개 상태입니다. 함수나 구조체와 같은 항목을 비공개로 만들고 싶다면, 모듈 안에 넣으면 됩니다.</p>
<p>Items in a parent module can’t use the private items inside child modules, but items in child modules can use the items in their ancestor modules. This is because child modules wrap and hide their implementation details, but the child modules can see the context in which they’re defined. To continue with our metaphor, think of the privacy rules as being like the back office of a restaurant: What goes on in there is private to restaurant customers, but office managers can see and do everything in the restaurant they operate.</p>
<p>Rust chose to have the module system function this way so that hiding inner implementation details is the default. That way, you know which parts of the inner code you can change without breaking the outer code. However, Rust does give you the option to expose inner parts of child modules’ code to outer ancestor modules by using the <code>pub</code> keyword to make an item public.</p>
<h3 id="pub-키워드로-경로-노출하기"><a class="header" href="#pub-키워드로-경로-노출하기"><code>pub</code> 키워드로 경로 노출하기</a></h3>
<p>목록 7-4에서 <code>hosting</code> 모듈이 비공개라고 했던 오류로 돌아가 봅시다. 부모 모듈의 <code>eat_at_restaurant</code> 함수가 자식 모듈의 <code>add_to_waitlist</code> 함수에 접근할 수 있게 하고 싶으므로, 목록 7-5에 표시된 것처럼 <code>hosting</code> 모듈을 <code>pub</code> 키워드로 표시합니다.</p>
<Listing number="7-5" file-name="src/lib.rs" caption="Declaring the `hosting` module as `pub` to use it from `eat_at_restaurant`">
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

// -- 생략 --
<span class="boring">pub fn eat_at_restaurant() {
</span><span class="boring">    // Absolute path
</span><span class="boring">    crate::front_of_house::hosting::add_to_waitlist();
</span><span class="boring">
</span><span class="boring">    // Relative path
</span><span class="boring">    front_of_house::hosting::add_to_waitlist();
</span><span class="boring">}</span></code></pre>
</Listing>
<p>안타깝게도 목록 7-5의 코드는 목록 7-6에 표시된 것처럼 여전히 컴파일러 오류를 발생시킵니다.</p>
<Listing number="7-6" caption="Compiler errors from building the code in Listing 7-5">
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: function `add_to_waitlist` is private
  --&gt; src/lib.rs:10:37
   |
10 |     crate::front_of_house::hosting::add_to_waitlist();
   |                                     ^^^^^^^^^^^^^^^ private function
   |
note: the function `add_to_waitlist` is defined here
  --&gt; src/lib.rs:3:9
   |
 3 |         fn add_to_waitlist() {}
   |         ^^^^^^^^^^^^^^^^^^^^

error[E0603]: function `add_to_waitlist` is private
  --&gt; src/lib.rs:13:30
   |
13 |     front_of_house::hosting::add_to_waitlist();
   |                              ^^^^^^^^^^^^^^^ private function
   |
note: the function `add_to_waitlist` is defined here
  --&gt; src/lib.rs:3:9
   |
 3 |         fn add_to_waitlist() {}
   |         ^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` (lib) due to 2 previous errors
</code></pre>
</Listing>
<p>무슨 일이 일어난 걸까요? <code>mod hosting</code> 앞에 <code>pub</code> 키워드를 추가하면 모듈이 공개됩니다. 이 변경으로 <code>front_of_house</code>에 접근할 수 있다면 <code>hosting</code>에도 접근할 수 있게 됩니다. 하지만 <code>hosting</code>의 _내용물_은 여전히 비공개입니다. 모듈을 공개로 만든다고 해서 그 내용물까지 공개되는 것은 아닙니다. 모듈에 붙은 <code>pub</code> 키워드는 단지 조상 모듈의 코드가 해당 모듈을 참조할 수 있게 할 뿐이며, 내부 코드에 접근할 수 있게 하는 것은 아닙니다. 모듈은 컨테이너이므로, 모듈만 공개로 해서는 할 수 있는 일이 많지 않습니다. 더 나아가 모듈 내의 하나 이상의 항목도 공개로 만들도록 선택해야 합니다.</p>
<p>목록 7-6의 오류들은 <code>add_to_waitlist</code> 함수가 비공개라고 말합니다. 프라이버시 규칙은 모듈뿐만 아니라 구조체, 열거형, 함수, 메서드에도 적용됩니다.</p>
<p>목록 7-7처럼 정의 앞에 <code>pub</code> 키워드를 추가하여 <code>add_to_waitlist</code> 함수도 공개로 만들어 봅시다.</p>
<Listing number="7-7" file-name="src/lib.rs" caption="Adding the `pub` keyword to `mod hosting` and `fn add_to_waitlist` lets us call the function from `eat_at_restaurant`.">
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

// -- 생략 --
<span class="boring">pub fn eat_at_restaurant() {
</span><span class="boring">    // Absolute path
</span><span class="boring">    crate::front_of_house::hosting::add_to_waitlist();
</span><span class="boring">
</span><span class="boring">    // Relative path
</span><span class="boring">    front_of_house::hosting::add_to_waitlist();
</span><span class="boring">}</span></code></pre>
</Listing>
<p>이제 코드가 컴파일됩니다! <code>pub</code> 키워드를 추가한 것이 왜 프라이버시 규칙 측면에서 <code>eat_at_restaurant</code> 내의 이 경로들을 사용할 수 있게 해주는지 알아보기 위해, 절대 경로와 상대 경로를 살펴봅시다.</p>
<p>In the absolute path, we start with <code>crate</code>, the root of our crate’s module tree. The <code>front_of_house</code> module is defined in the crate root. While <code>front_of_house</code> isn’t public, because the <code>eat_at_restaurant</code> function is defined in the same module as <code>front_of_house</code> (that is, <code>eat_at_restaurant</code> and <code>front_of_house</code> are siblings), we can refer to <code>front_of_house</code> from <code>eat_at_restaurant</code>. Next is the <code>hosting</code> module marked with <code>pub</code>. We can access the parent module of <code>hosting</code>, so we can access <code>hosting</code>. Finally, the <code>add_to_waitlist</code> function is marked with <code>pub</code>, and we can access its parent module, so this function call works!</p>
<p>In the relative path, the logic is the same as the absolute path except for the first step: Rather than starting from the crate root, the path starts from <code>front_of_house</code>. The <code>front_of_house</code> module is defined within the same module as <code>eat_at_restaurant</code>, so the relative path starting from the module in which <code>eat_at_restaurant</code> is defined works. Then, because <code>hosting</code> and <code>add_to_waitlist</code> are marked with <code>pub</code>, the rest of the path works, and this function call is valid!</p>
<p>If you plan to share your library crate so that other projects can use your code, your public API is your contract with users of your crate that determines how they can interact with your code. There are many considerations around managing changes to your public API to make it easier for people to depend on your crate. These considerations are beyond the scope of this book; if you’re interested in this topic, see <a href="https://rust-lang.github.io/api-guidelines/">the Rust API Guidelines</a>.</p>
<blockquote>
<h4 id="바이너리-및-라이브러리가-있는-패키지-모범-사례"><a class="header" href="#바이너리-및-라이브러리가-있는-패키지-모범-사례">바이너리 및 라이브러리가 있는 패키지 모범 사례</a></h4>
<p>We mentioned that a package can contain both a <em>src/main.rs</em> binary crate root as well as a <em>src/lib.rs</em> library crate root, and both crates will have the package name by default. Typically, packages with this pattern of containing both a library and a binary crate will have just enough code in the binary crate to start an executable that calls code defined in the library crate. This lets other projects benefit from the most functionality that the package provides because the library crate’s code can be shared.</p>
<p>The module tree should be defined in <em>src/lib.rs</em>. Then, any public items can be used in the binary crate by starting paths with the name of the package. The binary crate becomes a user of the library crate just like a completely external crate would use the library crate: It can only use the public API. This helps you design a good API; not only are you the author, but you’re also a client!</p>
<p><a href="ch12-00-an-io-project.html">12장</a><!-- ignore -->에서, 바이너리 크레이트와 라이브러리 크레이트를 모두 포함하는 명령줄 프로그램을 통해 이러한 조직화 관례를 보여드리겠습니다.</p>
</blockquote>
<h3 id="super로-상대-경로-시작하기"><a class="header" href="#super로-상대-경로-시작하기"><code>super</code>로 상대 경로 시작하기</a></h3>
<p>We can construct relative paths that begin in the parent module, rather than the current module or the crate root, by using <code>super</code> at the start of the path. This is like starting a filesystem path with the <code>..</code> syntax that means to go to the parent directory. Using <code>super</code> allows us to reference an item that we know is in the parent module, which can make rearranging the module tree easier when the module is closely related to the parent but the parent might be moved elsewhere in the module tree someday.</p>
<p>셰프가 잘못된 주문을 수정하고 고객에게 직접 가져다주는 상황을 모델링한 목록 7-8의 코드를 살펴봅시다. <code>back_of_house</code> 모듈에 정의된 <code>fix_incorrect_order</code> 함수는 <code>super</code>로 시작하는 <code>deliver_order</code> 경로를 지정하여 부모 모듈에 정의된 <code>deliver_order</code> 함수를 호출합니다.</p>
<Listing number="7-8" file-name="src/lib.rs" caption="Calling a function using a relative path starting with `super`">
<pre><code class="language-rust noplayground test_harness">fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order();
    }

    fn cook_order() {}
}</code></pre>
</Listing>
<p>The <code>fix_incorrect_order</code> function is in the <code>back_of_house</code> module, so we can use <code>super</code> to go to the parent module of <code>back_of_house</code>, which in this case is <code>crate</code>, the root. From there, we look for <code>deliver_order</code> and find it. Success! We think the <code>back_of_house</code> module and the <code>deliver_order</code> function are likely to stay in the same relationship to each other and get moved together should we decide to reorganize the crate’s module tree. Therefore, we used <code>super</code> so that we’ll have fewer places to update code in the future if this code gets moved to a different module.</p>
<h3 id="구조체와-열거형을-공개로-만들기"><a class="header" href="#구조체와-열거형을-공개로-만들기">구조체와 열거형을 공개로 만들기</a></h3>
<p>우리는 또한 <code>pub</code>을 사용하여 구조체와 열거형을 공개로 지정할 수 있지만, 구조체와 열거형에 <code>pub</code>을 사용하는 데에는 몇 가지 추가적인 세부 사항이 있습니다. 구조체 정의 앞에 <code>pub</code>을 사용하면 구조체는 공개되지만, 구조체의 필드들은 여전히 비공개 상태입니다. 우리는 각 필드를 상황에 따라 공개로 만들거나 만들지 않을 수 있습니다. 목록 7-9에서는 공개된 <code>toast</code> 필드와 비공개된 <code>seasonal_fruit</code> 필드를 가진 공개 구조체 <code>back_of_house::Breakfast</code>를 정의했습니다. 이는 고객이 식사와 함께 제공되는 빵의 종류를 선택할 수 있지만, 셰프가 제철 과일과 재고 상황에 따라 곁들일 과일을 결정하는 레스토랑의 상황을 모델링한 것입니다. 사용 가능한 과일은 자주 바뀌므로, 고객은 과일을 선택할 수 없으며 어떤 과일이 나올지 미리 알 수도 없습니다.</p>
<Listing number="7-9" file-name="src/lib.rs" caption="A struct with some public fields and some private fields">
<pre><code class="language-rust noplayground">mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &amp;str) -&gt; Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("복숭아"),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // 호밀 토스트와 함께 여름 아침 식사를 주문하세요.
    let mut meal = back_of_house::Breakfast::summer("호밀");
    // 어떤 빵을 먹을지 마음을 바꿉니다.
    meal.toast = String::from("밀");
    println!("{} 토스트 부탁드립니다", meal.toast);

    // 다음 줄은 주석을 해제하면 컴파일되지 않습니다. 우리는 식사와 함께 제공되는
    // 제철 과일을 보거나 수정할 수 없습니다.
    // meal.seasonal_fruit = String::from("blueberries");
}</code></pre>
</Listing>
<p><code>back_of_house::Breakfast</code> 구조체의 <code>toast</code> 필드는 공개(public)이므로, <code>eat_at_restaurant</code>에서 점 표기법을 사용하여 <code>toast</code> 필드에 쓰고 읽을 수 있습니다. <code>seasonal_fruit</code> 필드는 비공개(private)이므로 <code>eat_at_restaurant</code>에서 사용할 수 없다는 점에 유의하세요. <code>seasonal_fruit</code> 필드 값을 수정하는 줄의 주석을 해제하여 어떤 오류가 발생하는지 확인해 보세요!</p>
<p>Also, note that because <code>back_of_house::Breakfast</code> has a private field, the struct needs to provide a public associated function that constructs an instance of <code>Breakfast</code> (we’ve named it <code>summer</code> here). If <code>Breakfast</code> didn’t have such a function, we couldn’t create an instance of <code>Breakfast</code> in <code>eat_at_restaurant</code>, because we couldn’t set the value of the private <code>seasonal_fruit</code> field in <code>eat_at_restaurant</code>.</p>
<p>대조적으로, 열거형을 공개(public)로 만들면 모든 variant가 공개됩니다. 목록 7-10에 표시된 것처럼 <code>enum</code> 키워드 앞에 <code>pub</code>만 있으면 됩니다.</p>
<Listing number="7-10" file-name="src/lib.rs" caption="Designating an enum as public makes all its variants public.">
<pre><code class="language-rust noplayground">mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}</code></pre>
</Listing>
<p><code>Appetizer</code> 열거형을 공개로 만들었기 때문에, <code>eat_at_restaurant</code>에서 <code>Soup</code>과 <code>Salad</code> variant를 사용할 수 있습니다.</p>
<p>열거형은 variant가 공개되지 않으면 그다지 유용하지 않습니다. 모든 경우에 모든 열거형 variant에 <code>pub</code>을 명시해야 한다면 번거로울 것이므로, 열거형 variant의 기본값은 공개입니다. 구조체는 필드가 공개되지 않아도 유용한 경우가 많으므로, 구조체 필드는 <code>pub</code>으로 명시되지 않는 한 모든 것이 기본적으로 비공개라는 일반적인 규칙을 따릅니다.</p>
<p><code>pub</code>과 관련된 한 가지 더 다루지 않은 상황이 있는데, 그것은 우리의 마지막 모듈 시스템 기능인 <code>use</code> 키워드입니다. 먼저 <code>use</code> 자체를 다룬 다음, <code>pub</code>과 <code>use</code>를 결합하는 방법을 보여줄 것입니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch07-02-defining-modules-to-control-scope-and-privacy.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch07-02-defining-modules-to-control-scope-and-privacy.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
