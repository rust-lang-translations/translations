<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Treating Smart Pointers Like Regular References - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch15-02-deref.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch15-02-deref.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Old headings. Do not remove or links may break. -->
<p><a id="treating-smart-pointers-like-regular-references-with-the-deref-trait"></a> <a id="treating-smart-pointers-like-regular-references-with-deref"></a></p>
<h2 id="treating-smart-pointers-like-regular-references"><a class="header" href="#treating-smart-pointers-like-regular-references">Treating Smart Pointers Like Regular References</a></h2>
<p><code>Deref</code> 트레이트를 구현하면 <em>역참조 연산자(dereference operator)</em> <code>*</code>(곱셈이나 글로브(glob) 연산자와 혼동하지 마세요)의 동작을 커스터마이징할 수 있습니다. 스마트 포인터를 일반 참조처럼 다룰 수 있도록 <code>Deref</code>를 구현함으로써, 참조에 대해 작동하는 코드를 작성하고 이를 스마트 포인터와도 함께 사용할 수 있습니다.</p>
<p>Let’s first look at how the dereference operator works with regular references. Then, we’ll try to define a custom type that behaves like <code>Box&lt;T&gt;</code> and see why the dereference operator doesn’t work like a reference on our newly defined type. We’ll explore how implementing the <code>Deref</code> trait makes it possible for smart pointers to work in ways similar to references. Then, we’ll look at Rust’s deref coercion feature and how it lets us work with either references or smart pointers.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="following-the-pointer-to-the-value-with-the-dereference-operator"></a> <a id="following-the-pointer-to-the-value"></a></p>
<h3 id="following-the-reference-to-the-value"><a class="header" href="#following-the-reference-to-the-value">Following the Reference to the Value</a></h3>
<p>A regular reference is a type of pointer, and one way to think of a pointer is as an arrow to a value stored somewhere else. In Listing 15-6, we create a reference to an <code>i32</code> value and then use the dereference operator to follow the reference to the value.</p>
<Listing number="15-6" file-name="src/main.rs" caption="Using the dereference operator to follow a reference to an `i32` value">
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre></pre>
</Listing>
<p>The variable <code>x</code> holds an <code>i32</code> value <code>5</code>. We set <code>y</code> equal to a reference to <code>x</code>. We can assert that <code>x</code> is equal to <code>5</code>. However, if we want to make an assertion about the value in <code>y</code>, we have to use <code>*y</code> to follow the reference to the value it’s pointing to (hence, <em>dereference</em>) so that the compiler can compare the actual value. Once we dereference <code>y</code>, we have access to the integer value <code>y</code> is pointing to that we can compare with <code>5</code>.</p>
<p>만약 대신 <code>assert_eq!(5, y);</code>라고 작성하려고 한다면, 다음과 같은 컴파일 에러가 발생할 것입니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0277]: can't compare `{integer}` with `&amp;{integer}`
 --&gt; src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^ no implementation for `{integer} == &amp;{integer}`
  |
  = help: the trait `PartialEq&lt;&amp;{integer}&gt;` is not implemented for `{integer}`
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0277`.
error: could not compile `deref-example` (bin "deref-example") due to 1 previous error
</code></pre>
<p>숫자와 숫자에 대한 참조를 비교하는 것은 서로 다른 타입이기 때문에 허용되지 않습니다. 참조가 가리키는 값을 따라가려면 역참조 연산자를 사용해야 합니다.</p>
<h3 id="boxt를-참조처럼-사용하기"><a class="header" href="#boxt를-참조처럼-사용하기"><code>Box&lt;T&gt;</code>를 참조처럼 사용하기</a></h3>
<p>We can rewrite the code in Listing 15-6 to use a <code>Box&lt;T&gt;</code> instead of a reference; the dereference operator used on the <code>Box&lt;T&gt;</code> in Listing 15-7 functions in the same way as the dereference operator used on the reference in Listing 15-6.</p>
<Listing number="15-7" file-name="src/main.rs" caption="Using the dereference operator on a `Box<i32>`">
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre></pre>
</Listing>
<p>The main difference between Listing 15-7 and Listing 15-6 is that here we set <code>y</code> to be an instance of a box pointing to a copied value of <code>x</code> rather than a reference pointing to the value of <code>x</code>. In the last assertion, we can use the dereference operator to follow the box’s pointer in the same way that we did when <code>y</code> was a reference. Next, we’ll explore what is special about <code>Box&lt;T&gt;</code> that enables us to use the dereference operator by defining our own box type.</p>
<h3 id="우리만의-스마트-포인터-정의하기"><a class="header" href="#우리만의-스마트-포인터-정의하기">우리만의 스마트 포인터 정의하기</a></h3>
<p>Let’s build a wrapper type similar to the <code>Box&lt;T&gt;</code> type provided by the standard library to experience how smart pointer types behave differently from references by default. Then, we’ll look at how to add the ability to use the dereference operator.</p>
<blockquote>
<p>Note: There’s one big difference between the <code>MyBox&lt;T&gt;</code> type we’re about to build and the real <code>Box&lt;T&gt;</code>: Our version will not store its data on the heap. We are focusing this example on <code>Deref</code>, so where the data is actually stored is less important than the pointer-like behavior.</p>
</blockquote>
<p><code>Box&lt;T&gt;</code> 타입은 결과적으로 하나의 요소를 가진 튜플 구조체로 정의되어 있으므로, 목록 15-8도 같은 방식으로 <code>MyBox&lt;T&gt;</code> 타입을 정의합니다. 또한 <code>Box&lt;T&gt;</code>에 정의된 <code>new</code> 함수와 일치하도록 <code>new</code> 함수도 정의할 것입니다.</p>
<Listing number="15-8" file-name="src/main.rs" caption="Defining a `MyBox<T>` type">
<pre><pre class="playground"><code class="language-rust edition2024">struct MyBox&lt;T&gt;(T);

impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox(x)
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p>We define a struct named <code>MyBox</code> and declare a generic parameter <code>T</code> because we want our type to hold values of any type. The <code>MyBox</code> type is a tuple struct with one element of type <code>T</code>. The <code>MyBox::new</code> function takes one parameter of type <code>T</code> and returns a <code>MyBox</code> instance that holds the value passed in.</p>
<p>Let’s try adding the <code>main</code> function in Listing 15-7 to Listing 15-8 and changing it to use the <code>MyBox&lt;T&gt;</code> type we’ve defined instead of <code>Box&lt;T&gt;</code>. The code in Listing 15-9 won’t compile, because Rust doesn’t know how to dereference <code>MyBox</code>.</p>
<Listing number="15-9" file-name="src/main.rs" caption="Attempting to use `MyBox<T>` in the same way we used references and `Box<T>`">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre>
</Listing>
<p>Here’s the resultant compilation error:</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0614]: type `MyBox&lt;{integer}&gt;` cannot be dereferenced
  --&gt; src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^ can't be dereferenced

For more information about this error, try `rustc --explain E0614`.
error: could not compile `deref-example` (bin "deref-example") due to 1 previous error
</code></pre>
<p><code>MyBox&lt;T&gt;</code> 타입은 우리가 아직 그 능력을 구현하지 않았기 때문에 역참조될 수 없습니다. <code>*</code> 연산자로 역참조가 가능하게 하려면, <code>Deref</code> 트레이트를 구현해야 합니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="treating-a-type-like-a-reference-by-implementing-the-deref-trait"></a></p>
<h3 id="deref-트레이트-구현하기"><a class="header" href="#deref-트레이트-구현하기"><code>Deref</code> 트레이트 구현하기</a></h3>
<p>As discussed in <a href="ch10-02-traits.html#implementing-a-trait-on-a-type">“Implementing a Trait on a Type”</a><!-- ignore --> in Chapter 10, to implement a trait we need to provide implementations for the trait’s required methods. The <code>Deref</code> trait, provided by the standard library, requires us to implement one method named <code>deref</code> that borrows <code>self</code> and returns a reference to the inner data. Listing 15-10 contains an implementation of <code>Deref</code> to add to the definition of <code>MyBox&lt;T&gt;</code>.</p>
<Listing number="15-10" file-name="src/main.rs" caption="Implementing `Deref` on `MyBox<T>`">
<pre><pre class="playground"><code class="language-rust edition2024">use std::ops::Deref;

impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}
<span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let x = 5;
</span><span class="boring">    let y = MyBox::new(x);
</span><span class="boring">
</span><span class="boring">    assert_eq!(5, x);
</span><span class="boring">    assert_eq!(5, *y);
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p><code>type Target = T;</code> 문법은 <code>Deref</code> 트레이트에서 사용할 연관 타입(associated type)을 정의합니다. 연관 타입은 제네릭 매개변수를 선언하는 약간 다른 방법이지만, 지금은 걱정하실 필요 없습니다. 20장에서 더 자세히 다룰 것입니다.</p>
<p>We fill in the body of the <code>deref</code> method with <code>&amp;self.0</code> so that <code>deref</code> returns a reference to the value we want to access with the <code>*</code> operator; recall from <a href="ch05-01-defining-structs.html#creating-different-types-with-tuple-structs">“Creating Different Types with Tuple Structs”</a><!--
ignore --> in Chapter 5 that <code>.0</code> accesses the first value in a tuple struct. The <code>main</code> function in Listing 15-9 that calls <code>*</code> on the <code>MyBox&lt;T&gt;</code> value now compiles, and the assertions pass!</p>
<p>Without the <code>Deref</code> trait, the compiler can only dereference <code>&amp;</code> references. The <code>deref</code> method gives the compiler the ability to take a value of any type that implements <code>Deref</code> and call the <code>deref</code> method to get a reference that it knows how to dereference.</p>
<p>목록 15-9에서 <code>*y</code>를 입력했을 때, 배후에서 러스트는 실제로 다음 코드를 실행했습니다:</p>
<pre><code class="language-rust ignore">*(y.deref())</code></pre>
<p>Rust substitutes the <code>*</code> operator with a call to the <code>deref</code> method and then a plain dereference so that we don’t have to think about whether or not we need to call the <code>deref</code> method. This Rust feature lets us write code that functions identically whether we have a regular reference or a type that implements <code>Deref</code>.</p>
<p>The reason the <code>deref</code> method returns a reference to a value, and that the plain dereference outside the parentheses in <code>*(y.deref())</code> is still necessary, has to do with the ownership system. If the <code>deref</code> method returned the value directly instead of a reference to the value, the value would be moved out of <code>self</code>. We don’t want to take ownership of the inner value inside <code>MyBox&lt;T&gt;</code> in this case or in most cases where we use the dereference operator.</p>
<p>코드에서 <code>*</code>를 사용할 때마다, <code>*</code> 연산자가 <code>deref</code> 메서드 호출과 그 뒤의 단 한 번의 <code>*</code> 연산자 호출로 대체된다는 점에 유의하세요. <code>*</code> 연산자의 대체가 무한히 재귀적으로 일어나지 않기 때문에, 결과적으로 <code>i32</code> 타입의 데이터를 얻게 되며, 이는 목록 15-9의 <code>assert_eq!</code>에 있는 <code>5</code>와 일치합니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="implicit-deref-coercions-with-functions-and-methods"></a> <a id="using-deref-coercions-in-functions-and-methods"></a></p>
<h3 id="using-deref-coercion-in-functions-and-methods"><a class="header" href="#using-deref-coercion-in-functions-and-methods">Using Deref Coercion in Functions and Methods</a></h3>
<p><em>Deref coercion</em> converts a reference to a type that implements the <code>Deref</code> trait into a reference to another type. For example, deref coercion can convert <code>&amp;String</code> to <code>&amp;str</code> because <code>String</code> implements the <code>Deref</code> trait such that it returns <code>&amp;str</code>. Deref coercion is a convenience Rust performs on arguments to functions and methods, and it works only on types that implement the <code>Deref</code> trait. It happens automatically when we pass a reference to a particular type’s value as an argument to a function or method that doesn’t match the parameter type in the function or method definition. A sequence of calls to the <code>deref</code> method converts the type we provided into the type the parameter needs.</p>
<p>역참조 강제는 함수나 메서드를 호출하는 프로그래머가 <code>&amp;</code>와 <code>*</code>를 사용하여 명시적인 참조와 역참조를 많이 추가할 필요가 없도록 러스트에 추가되었습니다. 또한 역참조 강제 기능 덕분에 우리는 참조와 스마트 포인터 모두에 대해 작동할 수 있는 코드를 더 많이 작성할 수 있습니다.</p>
<p>To see deref coercion in action, let’s use the <code>MyBox&lt;T&gt;</code> type we defined in Listing 15-8 as well as the implementation of <code>Deref</code> that we added in Listing 15-10. Listing 15-11 shows the definition of a function that has a string slice parameter.</p>
<Listing number="15-11" file-name="src/main.rs" caption="A `hello` function that has the parameter `name` of type `&str`">
<pre><pre class="playground"><code class="language-rust edition2024">fn hello(name: &amp;str) {
    println!("안녕하세요, {name}!");
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p>We can call the <code>hello</code> function with a string slice as an argument, such as <code>hello("Rust");</code>, for example. Deref coercion makes it possible to call <code>hello</code> with a reference to a value of type <code>MyBox&lt;String&gt;</code>, as shown in Listing 15-12.</p>
<Listing number="15-12" file-name="src/main.rs" caption="Calling `hello` with a reference to a `MyBox<String>` value, which works because of deref coercion">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!("안녕하세요, {name}!");
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from("러스트"));
    hello(&amp;m);
}</code></pre></pre>
</Listing>
<p>여기서 우리는 <code>MyBox&lt;String&gt;</code> 값에 대한 참조인 <code>&amp;m</code>을 인자로 하여 <code>hello</code> 함수를 호출하고 있습니다. 목록 15-10에서 <code>MyBox&lt;T&gt;</code>에 대해 <code>Deref</code> 트레이트를 구현했으므로, 러스트는 <code>deref</code>를 호출하여 <code>&amp;MyBox&lt;String&gt;</code>을 <code>&amp;String</code>으로 바꿀 수 있습니다. 표준 라이브러리는 <code>String</code>에 대해 문자열 슬라이스를 반환하도록 <code>Deref</code>를 구현하고 있으며, 이는 <code>Deref</code>의 API 문서에서 확인할 수 있습니다. 러스트는 <code>deref</code>를 다시 한 번 호출하여 <code>&amp;String</code>을 <code>&amp;str</code>로 변환하고, 이는 <code>hello</code> 함수의 정의와 일치하게 됩니다.</p>
<p>만약 러스트에 역참조 강제 기능이 없었다면, <code>&amp;MyBox&lt;String&gt;</code> 타입의 값으로 <code>hello</code>를 호출하기 위해 목록 15-12의 코드 대신 목록 15-13의 코드와 같이 작성해야 했을 것입니다.</p>
<Listing number="15-13" file-name="src/main.rs" caption="The code we would have to write if Rust didn’t have deref coercion">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!("안녕하세요, {name}!");
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from("러스트"));
    hello(&amp;(*m)[..]);
}</code></pre></pre>
</Listing>
<p>The <code>(*m)</code> dereferences the <code>MyBox&lt;String&gt;</code> into a <code>String</code>. Then, the <code>&amp;</code> and <code>[..]</code> take a string slice of the <code>String</code> that is equal to the whole string to match the signature of <code>hello</code>. This code without deref coercions is harder to read, write, and understand with all of these symbols involved. Deref coercion allows Rust to handle these conversions for us automatically.</p>
<p>관련된 타입들에 대해 <code>Deref</code> 트레이트가 정의되어 있으면, 러스트는 해당 타입들을 분석하여 매개변수의 타입과 일치하는 참조를 얻기 위해 필요한 만큼 <code>Deref::deref</code>를 사용합니다. <code>Deref::deref</code>가 삽입되어야 하는 횟수는 컴파일 타임에 결정되므로, 역참조 강제를 활용함에 따른 런타임 페널티는 전혀 없습니다!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="how-deref-coercion-interacts-with-mutability"></a></p>
<h3 id="handling-deref-coercion-with-mutable-references"><a class="header" href="#handling-deref-coercion-with-mutable-references">Handling Deref Coercion with Mutable References</a></h3>
<p>불변 참조에 대해 <code>*</code> 연산자를 오버라이드하기 위해 <code>Deref</code> 트레이트를 사용하는 것과 유사하게, 가변 참조에 대해 <code>*</code> 연산자를 오버라이드하려면 <code>DerefMut</code> 트레이트를 사용할 수 있습니다.</p>
<p>러스트는 다음 세 가지 경우에 타입 및 트레이트 구현을 찾아 역참조 강제를 수행합니다:</p>
<ol>
<li><code>T: Deref&lt;Target=U&gt;</code>일 때 <code>&amp;T</code>에서 <code>&amp;U</code>로</li>
<li><code>T: DerefMut&lt;Target=U&gt;</code>일 때 <code>&amp;mut T</code>에서 <code>&amp;mut U</code>로</li>
<li><code>T: Deref&lt;Target=U&gt;</code>일 때 <code>&amp;mut T</code>에서 <code>&amp;mut U</code>로</li>
</ol>
<p>The first two cases are the same except that the second implements mutability. The first case states that if you have a <code>&amp;T</code>, and <code>T</code> implements <code>Deref</code> to some type <code>U</code>, you can get a <code>&amp;U</code> transparently. The second case states that the same deref coercion happens for mutable references.</p>
<p>The third case is trickier: Rust will also coerce a mutable reference to an immutable one. But the reverse is <em>not</em> possible: Immutable references will never coerce to mutable references. Because of the borrowing rules, if you have a mutable reference, that mutable reference must be the only reference to that data (otherwise, the program wouldn’t compile). Converting one mutable reference to one immutable reference will never break the borrowing rules. Converting an immutable reference to a mutable reference would require that the initial immutable reference is the only immutable reference to that data, but the borrowing rules don’t guarantee that. Therefore, Rust can’t make the assumption that converting an immutable reference to a mutable reference is possible.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch15-01-box.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch15-03-drop.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch15-01-box.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch15-03-drop.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
