<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Deref 트레이트로 스마트 포인터를 일반 참조처럼 다루기 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch15-02-deref.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch15-02-deref.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="deref-트레이트로-스마트-포인터를-일반-참조처럼-다루기"><a class="header" href="#deref-트레이트로-스마트-포인터를-일반-참조처럼-다루기"><code>Deref</code> 트레이트로 스마트 포인터를 일반 참조처럼 다루기</a></h2>
<p><code>Deref</code> 트레이트를 구현하면 <em>역참조 연산자(dereference operator)</em> <code>*</code>(곱셈이나 글로브(glob) 연산자와 혼동하지 마세요)의 동작을 커스터마이징할 수 있습니다. 스마트 포인터를 일반 참조처럼 다룰 수 있도록 <code>Deref</code>를 구현함으로써, 참조에 대해 작동하는 코드를 작성하고 이를 스마트 포인터와도 함께 사용할 수 있습니다.</p>
<p>먼저 역참조 연산자가 일반 참조와 어떻게 작동하는지 살펴보겠습니다. 그런 다음 <code>Box&lt;T&gt;</code>처럼 작동하는 커스텀 타입을 정의해 보고, 왜 역참조 연산자가 우리가 새로 정의한 타입에서는 참조처럼 작동하지 않는지 확인해 보겠습니다. <code>Deref</code> 트레이트를 구현하는 것이 어떻게 스마트 포인터가 참조와 유사한 방식으로 작동할 수 있게 하는지 알아볼 것입니다. 마지막으로 러스트의 <em>역참조 강제(deref coercion)</em> 기능과, 이 기능이 어떻게 참조나 스마트 포인터 모두와 함께 작동할 수 있게 해주는지 살펴보겠습니다.</p>
<blockquote>
<p>참고: 우리가 만들려는 <code>MyBox&lt;T&gt;</code> 타입과 실제 <code>Box&lt;T&gt;</code> 사이에는 한 가지 큰 차이점이 있습니다: 우리의 버전은 데이터를 힙에 저장하지 않을 것입니다. 이 예제는 <code>Deref</code>에 집중하고 있으므로, 데이터가 실제로 어디에 저장되는지는 포인터와 같은 동작보다 덜 중요합니다.</p>
</blockquote>
<!-- Old link, do not remove -->
<p><a id="following-the-pointer-to-the-value-with-the-dereference-operator"></a></p>
<h3 id="포인터를-따라-값에-접근하기"><a class="header" href="#포인터를-따라-값에-접근하기">포인터를 따라 값에 접근하기</a></h3>
<p>일반 참조는 포인터의 일종이며, 포인터를 생각하는 한 가지 방법은 다른 어딘가에 저장된 값을 가리키는 화살표로 생각하는 것입니다. 목록 15-6에서는 <code>i32</code> 값에 대한 참조를 생성한 다음, 역참조 연산자를 사용하여 참조를 따라 값에 접근합니다:</p>
<Listing number="15-6" file-name="src/main.rs" caption="Using the dereference operator to follow a reference to an `i32` value">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre></pre>
</Listing>
<p>변수 <code>x</code>는 <code>i32</code> 값 <code>5</code>를 보유합니다. <code>y</code>를 <code>x</code>에 대한 참조로 설정합니다. <code>x</code>가 <code>5</code>와 같음을 단언(assert)할 수 있습니다. 하지만 <code>y</code>에 들어있는 값에 대해 단언하고 싶다면, 컴파일러가 실제 값을 비교할 수 있도록 참조가 가리키는 값을 따라가는 <code>*y</code>를 사용해야 합니다(그래서 _역참조_라고 합니다). <code>y</code>를 역참조하고 나면, <code>y</code>가 가리키는 정수 값에 접근할 수 있게 되며 이를 <code>5</code>와 비교할 수 있습니다.</p>
<p>만약 대신 <code>assert_eq!(5, y);</code>라고 작성하려고 한다면, 다음과 같은 컴파일 에러가 발생할 것입니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0277]: can't compare `{integer}` with `&amp;{integer}`
 --&gt; src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^ no implementation for `{integer} == &amp;{integer}`
  |
  = help: the trait `PartialEq&lt;&amp;{integer}&gt;` is not implemented for `{integer}`
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider dereferencing here
 --&gt; file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/core/src/macros/mod.rs:46:35
  |
46|                 if !(*left_val == **right_val) {
  |                                   +

For more information about this error, try `rustc --explain E0277`.
error: could not compile `deref-example` (bin "deref-example") due to 1 previous error
</code></pre>
<p>숫자와 숫자에 대한 참조를 비교하는 것은 서로 다른 타입이기 때문에 허용되지 않습니다. 참조가 가리키는 값을 따라가려면 역참조 연산자를 사용해야 합니다.</p>
<h3 id="boxt를-참조처럼-사용하기"><a class="header" href="#boxt를-참조처럼-사용하기"><code>Box&lt;T&gt;</code>를 참조처럼 사용하기</a></h3>
<p>목록 15-6의 코드를 참조 대신 <code>Box&lt;T&gt;</code>를 사용하도록 다시 작성할 수 있습니다. 목록 15-7에서 <code>Box&lt;T&gt;</code>에 사용된 역참조 연산자는 목록 15-6에서 참조에 사용된 역참조 연산자와 동일한 방식으로 작동합니다:</p>
<Listing number="15-7" file-name="src/main.rs" caption="Using the dereference operator on a `Box<i32>`">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre></pre>
</Listing>
<p>목록 15-7과 목록 15-6의 주요 차이점은 여기서 <code>y</code>가 <code>x</code>의 값을 가리키는 참조가 아니라, <code>x</code>의 복사본을 가리키는 <code>Box&lt;T&gt;</code> 인스턴스라는 점입니다. 마지막 단언(assertion)에서 우리는 <code>y</code>가 참조였을 때와 같은 방식으로 역참조 연산자를 사용하여 <code>Box&lt;T&gt;</code>의 포인터를 따라갈 수 있습니다. 다음으로는 우리만의 타입을 정의해 봄으로써, 역참조 연산자를 사용할 수 있게 해주는 <code>Box&lt;T&gt;</code>의 특별한 점이 무엇인지 알아보겠습니다.</p>
<h3 id="우리만의-스마트-포인터-정의하기"><a class="header" href="#우리만의-스마트-포인터-정의하기">우리만의 스마트 포인터 정의하기</a></h3>
<p>표준 라이브러리에서 제공하는 <code>Box&lt;T&gt;</code> 타입과 유사한 스마트 포인터를 직접 만들어 봄으로써, 스마트 포인터가 기본적으로 참조와 어떻게 다르게 행동하는지 경험해 봅시다. 그런 다음 역참조 연산자를 사용할 수 있는 능력을 추가하는 방법을 알아보겠습니다.</p>
<p><code>Box&lt;T&gt;</code> 타입은 결과적으로 하나의 요소를 가진 튜플 구조체로 정의되어 있으므로, 목록 15-8도 같은 방식으로 <code>MyBox&lt;T&gt;</code> 타입을 정의합니다. 또한 <code>Box&lt;T&gt;</code>에 정의된 <code>new</code> 함수와 일치하도록 <code>new</code> 함수도 정의할 것입니다.</p>
<Listing number="15-8" file-name="src/main.rs" caption="Defining a `MyBox<T>` type">
<pre><pre class="playground"><code class="language-rust edition2021">struct MyBox&lt;T&gt;(T);

impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox(x)
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p><code>MyBox</code>라는 이름의 구조체를 정의하고 제네릭 매개변수 <code>T</code>를 선언합니다. 우리 타입이 어떤 타입의 값도 보유할 수 있기를 원하기 때문입니다. <code>MyBox</code> 타입은 <code>T</code> 타입의 요소 하나를 가진 튜플 구조체입니다. <code>MyBox::new</code> 함수는 <code>T</code> 타입의 매개변수 하나를 받아 전달된 값을 보유하는 <code>MyBox</code> 인스턴스를 반환합니다.</p>
<p>Let’s try adding the <code>main</code> function in Listing 15-7 to Listing 15-8 and changing it to use the <code>MyBox&lt;T&gt;</code> type we’ve defined instead of <code>Box&lt;T&gt;</code>. The code in Listing 15-9 won’t compile because Rust doesn’t know how to dereference <code>MyBox</code>.</p>
<Listing number="15-9" file-name="src/main.rs" caption="Attempting to use `MyBox<T>` in the same way we used references and `Box<T>`">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre>
</Listing>
<p>Here’s the resulting compilation error:</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0614]: type `MyBox&lt;{integer}&gt;` cannot be dereferenced
  --&gt; src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^

For more information about this error, try `rustc --explain E0614`.
error: could not compile `deref-example` (bin "deref-example") due to 1 previous error
</code></pre>
<p><code>MyBox&lt;T&gt;</code> 타입은 우리가 아직 그 능력을 구현하지 않았기 때문에 역참조될 수 없습니다. <code>*</code> 연산자로 역참조가 가능하게 하려면, <code>Deref</code> 트레이트를 구현해야 합니다.</p>
<!-- Old link, do not remove -->
<p><a id="treating-a-type-like-a-reference-by-implementing-the-deref-trait"></a></p>
<h3 id="deref-트레이트-구현하기"><a class="header" href="#deref-트레이트-구현하기"><code>Deref</code> 트레이트 구현하기</a></h3>
<p>10장의 <a href="ch10-02-traits.html#implementing-a-trait-on-a-type">“타입에 트레이트 구현하기”</a><!-- ignore --> 섹션에서 논의했듯이, 트레이트를 구현하려면 트레이트가 요구하는 메서드들의 구현을 제공해야 합니다. 표준 라이브러리에서 제공하는 <code>Deref</code> 트레이트는 <code>self</code>를 대여하고 내부 데이터에 대한 참조를 반환하는 <code>deref</code>라는 메서드 하나를 구현할 것을 요구합니다. 목록 15-10은 <code>MyBox&lt;T&gt;</code> 정의에 추가할 <code>Deref</code> 구현을 담고 있습니다:</p>
<Listing number="15-10" file-name="src/main.rs" caption="Implementing `Deref` on `MyBox<T>`">
<pre><pre class="playground"><code class="language-rust edition2021">use std::ops::Deref;

impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}
<span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let x = 5;
</span><span class="boring">    let y = MyBox::new(x);
</span><span class="boring">
</span><span class="boring">    assert_eq!(5, x);
</span><span class="boring">    assert_eq!(5, *y);
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p><code>type Target = T;</code> 문법은 <code>Deref</code> 트레이트에서 사용할 연관 타입(associated type)을 정의합니다. 연관 타입은 제네릭 매개변수를 선언하는 약간 다른 방법이지만, 지금은 걱정하실 필요 없습니다. 20장에서 더 자세히 다룰 것입니다.</p>
<p><code>deref</code> 메서드의 본문을 <code>&amp;self.0</code>으로 채우면, <code>deref</code>는 <code>*</code> 연산자를 통해 접근하고자 하는 값에 대한 참조를 반환합니다. 5장의 <a href="ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types">“명명된 필드가 없는 튜플 구조체를 사용하여 다른 타입 만들기”</a><!-- ignore --> 섹션에서 다루었듯이 <code>.0</code>은 튜플 구조체의 첫 번째 값에 접근합니다. 이제 <code>MyBox&lt;T&gt;</code> 값에 대해 <code>*</code>를 호출하는 목록 15-9의 <code>main</code> 함수가 컴파일되고 단언문들이 통과합니다!</p>
<p><code>Deref</code> 트레이트가 없다면 컴파일러는 <code>&amp;</code> 참조만 역참조할 수 있습니다. <code>deref</code> 메서드는 컴파일러에게 <code>Deref</code>를 구현하는 어떤 타입의 값이라도 받아서, <code>deref</code> 메서드를 호출하여 역참조하는 방법을 알고 있는 <code>&amp;</code> 참조를 얻을 수 있는 능력을 부여합니다.</p>
<p>목록 15-9에서 <code>*y</code>를 입력했을 때, 배후에서 러스트는 실제로 다음 코드를 실행했습니다:</p>
<pre><code class="language-rust ignore">*(y.deref())</code></pre>
<p>러스트는 <code>*</code> 연산자를 <code>deref</code> 메서드 호출과 그에 따른 평범한 역참조로 대체하므로, 우리는 <code>deref</code> 메서드를 호출해야 할지 말지 고민할 필요가 없습니다. 이러한 러스트의 기능 덕분에 우리는 일반 참조를 가지고 있든 <code>Deref</code>를 구현하는 타입을 가지고 있든 동일하게 작동하는 코드를 작성할 수 있습니다.</p>
<p><code>deref</code> 메서드가 값 자체가 아닌 값에 대한 참조를 반환하는 이유, 그리고 <code>*(y.deref())</code>에서 괄호 바깥의 평범한 역참조가 여전히 필요한 이유는 소유권 시스템 때문입니다. 만약 <code>deref</code> 메서드가 값에 대한 참조 대신 값을 직접 반환했다면, 그 값은 <code>self</code> 밖으로 이동(move)되었을 것입니다. 이 경우나 역참조 연산자를 사용하는 대부분의 경우에서, 우리는 <code>MyBox&lt;T&gt;</code> 내부의 값에 대한 소유권을 가져오고 싶지 않습니다.</p>
<p>코드에서 <code>*</code>를 사용할 때마다, <code>*</code> 연산자가 <code>deref</code> 메서드 호출과 그 뒤의 단 한 번의 <code>*</code> 연산자 호출로 대체된다는 점에 유의하세요. <code>*</code> 연산자의 대체가 무한히 재귀적으로 일어나지 않기 때문에, 결과적으로 <code>i32</code> 타입의 데이터를 얻게 되며, 이는 목록 15-9의 <code>assert_eq!</code>에 있는 <code>5</code>와 일치합니다.</p>
<h3 id="함수와-메서드에-일어나는-암묵적-역참조-강제"><a class="header" href="#함수와-메서드에-일어나는-암묵적-역참조-강제">함수와 메서드에 일어나는 암묵적 역참조 강제</a></h3>
<p>_역참조 강제(Deref coercion)_는 <code>Deref</code> 트레이트를 구현하는 타입에 대한 참조를 다른 타입에 대한 참조로 변환해 줍니다. 예를 들어, 역참조 강제는 <code>&amp;String</code>을 <code>&amp;str</code>로 변환할 수 있는데, 이는 <code>String</code>이 <code>&amp;str</code>을 반환하도록 <code>Deref</code> 트레이트를 구현하고 있기 때문입니다. 역참조 강제는 러스트가 함수와 메서드의 인자에 대해 수행하는 편의 기능이며, <code>Deref</code> 트레이트를 구현한 타입에 대해서만 작동합니다. 이는 우리가 특정 타입의 값에 대한 참조를 함수나 메서드의 인자로 전달할 때, 그 인자의 타입이 함수나 메서드 정의에 있는 매개변수의 타입과 일치하지 않을 경우 자동으로 발생합니다. 일련의 <code>deref</code> 메서드 호출을 통해 우리가 제공한 타입이 매개변수가 필요로 하는 타입으로 변환됩니다.</p>
<p>역참조 강제는 함수나 메서드를 호출하는 프로그래머가 <code>&amp;</code>와 <code>*</code>를 사용하여 명시적인 참조와 역참조를 많이 추가할 필요가 없도록 러스트에 추가되었습니다. 또한 역참조 강제 기능 덕분에 우리는 참조와 스마트 포인터 모두에 대해 작동할 수 있는 코드를 더 많이 작성할 수 있습니다.</p>
<p>역참조 강제가 실제로 작동하는 것을 보기 위해, 목록 15-8에서 정의한 <code>MyBox&lt;T&gt;</code> 타입과 목록 15-10에서 추가한 <code>Deref</code> 구현을 사용해 봅시다. 목록 15-11은 문자열 슬라이스를 매개변수로 받는 함수의 정의를 보여줍니다:</p>
<Listing number="15-11" file-name="src/main.rs" caption="A `hello` function that has the parameter `name` of type `&str`">
<pre><pre class="playground"><code class="language-rust edition2021">fn hello(name: &amp;str) {
    println!("안녕하세요, {name}!");
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p>우리는 <code>hello</code> 함수를 <code>hello("Rust");</code>와 같이 문자열 슬라이스를 인자로 하여 호출할 수 있습니다. 역참조 강제 덕분에 목록 15-12와 같이 <code>MyBox&lt;String&gt;</code> 타입의 값에 대한 참조로도 <code>hello</code>를 호출하는 것이 가능합니다:</p>
<Listing number="15-12" file-name="src/main.rs" caption="Calling `hello` with a reference to a `MyBox<String>` value, which works because of deref coercion">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!("안녕하세요, {name}!");
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from("러스트"));
    hello(&amp;m);
}</code></pre></pre>
</Listing>
<p>여기서 우리는 <code>MyBox&lt;String&gt;</code> 값에 대한 참조인 <code>&amp;m</code>을 인자로 하여 <code>hello</code> 함수를 호출하고 있습니다. 목록 15-10에서 <code>MyBox&lt;T&gt;</code>에 대해 <code>Deref</code> 트레이트를 구현했으므로, 러스트는 <code>deref</code>를 호출하여 <code>&amp;MyBox&lt;String&gt;</code>을 <code>&amp;String</code>으로 바꿀 수 있습니다. 표준 라이브러리는 <code>String</code>에 대해 문자열 슬라이스를 반환하도록 <code>Deref</code>를 구현하고 있으며, 이는 <code>Deref</code>의 API 문서에서 확인할 수 있습니다. 러스트는 <code>deref</code>를 다시 한 번 호출하여 <code>&amp;String</code>을 <code>&amp;str</code>로 변환하고, 이는 <code>hello</code> 함수의 정의와 일치하게 됩니다.</p>
<p>만약 러스트에 역참조 강제 기능이 없었다면, <code>&amp;MyBox&lt;String&gt;</code> 타입의 값으로 <code>hello</code>를 호출하기 위해 목록 15-12의 코드 대신 목록 15-13의 코드와 같이 작성해야 했을 것입니다.</p>
<Listing number="15-13" file-name="src/main.rs" caption="The code we would have to write if Rust didn’t have deref coercion">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!("안녕하세요, {name}!");
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from("러스트"));
    hello(&amp;(*m)[..]);
}</code></pre></pre>
</Listing>
<p><code>(*m)</code>은 <code>MyBox&lt;String&gt;</code>을 <code>String</code>으로 역참조합니다. 그런 다음 <code>&amp;</code>와 <code>[..]</code>가 <code>String</code>의 전체 문자열에 해당하는 문자열 슬라이스를 가져와 <code>hello</code>의 시그니처와 일치시킵니다. 역참조 강제가 없는 이 코드는 이러한 모든 기호들이 포함되어 읽고, 쓰고, 이해하기가 더 어렵습니다. 역참조 강제는 러스트가 이러한 변환들을 우리 대신 자동으로 처리할 수 있게 해줍니다.</p>
<p>관련된 타입들에 대해 <code>Deref</code> 트레이트가 정의되어 있으면, 러스트는 해당 타입들을 분석하여 매개변수의 타입과 일치하는 참조를 얻기 위해 필요한 만큼 <code>Deref::deref</code>를 사용합니다. <code>Deref::deref</code>가 삽입되어야 하는 횟수는 컴파일 타임에 결정되므로, 역참조 강제를 활용함에 따른 런타임 페널티는 전혀 없습니다!</p>
<h3 id="역참조-강제가-가변성과-상호작용하는-방식"><a class="header" href="#역참조-강제가-가변성과-상호작용하는-방식">역참조 강제가 가변성과 상호작용하는 방식</a></h3>
<p>불변 참조에 대해 <code>*</code> 연산자를 오버라이드하기 위해 <code>Deref</code> 트레이트를 사용하는 것과 유사하게, 가변 참조에 대해 <code>*</code> 연산자를 오버라이드하려면 <code>DerefMut</code> 트레이트를 사용할 수 있습니다.</p>
<p>러스트는 다음 세 가지 경우에 타입 및 트레이트 구현을 찾아 역참조 강제를 수행합니다:</p>
<ol>
<li><code>T: Deref&lt;Target=U&gt;</code>일 때 <code>&amp;T</code>에서 <code>&amp;U</code>로</li>
<li><code>T: DerefMut&lt;Target=U&gt;</code>일 때 <code>&amp;mut T</code>에서 <code>&amp;mut U</code>로</li>
<li><code>T: Deref&lt;Target=U&gt;</code>일 때 <code>&amp;mut T</code>에서 <code>&amp;mut U</code>로</li>
</ol>
<p>처음 두 경우는 두 번째 경우가 가변성을 구현한다는 점을 제외하면 동일합니다. 첫 번째 경우는 <code>&amp;T</code>를 가지고 있고 <code>T</code>가 어떤 타입 <code>U</code>에 대해 <code>Deref</code>를 구현했다면, 자동으로 <code>&amp;U</code>를 얻을 수 있음을 명시합니다. 두 번째 경우는 가변 참조에 대해서도 동일한 역참조 강제가 일어남을 명시합니다.</p>
<p>세 번째 경우는 좀 더 까다롭습니다: 러스트는 가변 참조를 불변 참조로 강제 변환하기도 합니다. 하지만 그 반대는 _불가능_합니다: 불변 참조는 결코 가변 참조로 강제 변환되지 않습니다. 대여 규칙에 따라, 가변 참조를 가지고 있다면 그 가변 참조는 해당 데이터에 대한 유일한 참조여야 합니다(그렇지 않으면 프로그램이 컴파일되지 않습니다). 하나의 가변 참조를 하나의 불변 참조로 변환하는 것은 결코 대여 규칙을 깨뜨리지 않습니다. 불변 참조를 가변 참조로 변환하려면 초기의 불변 참조가 해당 데이터에 대한 유일한 불변 참조여야 하는데, 대여 규칙은 이를 보장하지 않습니다. 따라서 러스트는 불변 참조를 가변 참조로 변환하는 것이 가능하다는 가정을 할 수 없습니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch15-01-box.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch15-03-drop.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch15-01-box.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch15-03-drop.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
