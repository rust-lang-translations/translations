<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Closures - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch13-01-closures.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch13-01-closures.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Old headings. Do not remove or links may break. -->
<p><a id="closures-anonymous-functions-that-can-capture-their-environment"></a> <a id="closures-anonymous-functions-that-capture-their-environment"></a></p>
<h2 id="closures"><a class="header" href="#closures">Closures</a></h2>
<p>러스트의 클로저는 변수에 저장하거나 다른 함수에 인수로 전달할 수 있는 익명 함수입니다. 한 곳에서 클로저를 생성한 다음 다른 곳에서 호출하여 다른 컨텍스트에서 평가할 수 있습니다. 함수와 달리 클로저는 정의된 스코프의 값을 캡처할 수 있습니다. 이러한 클로저의 기능이 어떻게 코드 재사용과 동작 커스터마이징을 가능하게 하는지 보여드리겠습니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="creating-an-abstraction-of-behavior-with-closures"></a> <a id="refactoring-using-functions"></a> <a id="refactoring-with-closures-to-store-code"></a> <a id="capturing-the-environment-with-closures"></a></p>
<h3 id="capturing-the-environment"><a class="header" href="#capturing-the-environment">Capturing the Environment</a></h3>
<p>We’ll first examine how we can use closures to capture values from the environment they’re defined in for later use. Here’s the scenario: Every so often, our T-shirt company gives away an exclusive, limited-edition shirt to someone on our mailing list as a promotion. People on the mailing list can optionally add their favorite color to their profile. If the person chosen for a free shirt has their favorite color set, they get that color shirt. If the person hasn’t specified a favorite color, they get whatever color the company currently has the most of.</p>
<p>There are many ways to implement this. For this example, we’re going to use an enum called <code>ShirtColor</code> that has the variants <code>Red</code> and <code>Blue</code> (limiting the number of colors available for simplicity). We represent the company’s inventory with an <code>Inventory</code> struct that has a field named <code>shirts</code> that contains a <code>Vec&lt;ShirtColor&gt;</code> representing the shirt colors currently in stock. The method <code>giveaway</code> defined on <code>Inventory</code> gets the optional shirt color preference of the free-shirt winner, and it returns the shirt color the person will get. This setup is shown in Listing 13-1.</p>
<Listing number="13-1" file-name="src/main.rs" caption="Shirt company giveaway situation">
<pre><code class="language-rust noplayground">#[derive(Debug, PartialEq, Copy, Clone)]
enum ShirtColor {
    Red,
    Blue,
}

struct Inventory {
    shirts: Vec&lt;ShirtColor&gt;,
}

impl Inventory {
    fn giveaway(&amp;self, user_preference: Option&lt;ShirtColor&gt;) -&gt; ShirtColor {
        user_preference.unwrap_or_else(|| self.most_stocked())
    }

    fn most_stocked(&amp;self) -&gt; ShirtColor {
        let mut num_red = 0;
        let mut num_blue = 0;

        for color in &amp;self.shirts {
            match color {
                ShirtColor::Red =&gt; num_red += 1,
                ShirtColor::Blue =&gt; num_blue += 1,
            }
        }
        if num_red &gt; num_blue {
            ShirtColor::Red
        } else {
            ShirtColor::Blue
        }
    }
}

fn main() {
    let store = Inventory {
        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],
    };

    let user_pref1 = Some(ShirtColor::Red);
    let giveaway1 = store.giveaway(user_pref1);
    println!(
        "선호도가 {:?}인 사용자는 {:?}를 받습니다",
        user_pref1, giveaway1
    );

    let user_pref2 = None;
    let giveaway2 = store.giveaway(user_pref2);
    println!(
        "선호도가 {:?}인 사용자는 {:?}를 받습니다",
        user_pref2, giveaway2
    );
}</code></pre>
</Listing>
<p><code>main</code>에 정의된 <code>store</code>는 이번 한정판 프로모션을 위해 파란색 셔츠 두 장과 빨간색 셔츠 한 장을 남겨두고 있습니다. 우리는 빨간색 셔츠를 선호하는 사용자와 선호도가 없는 사용자에 대해 <code>giveaway</code> 메서드를 호출합니다.</p>
<p>Again, this code could be implemented in many ways, and here, to focus on closures, we’ve stuck to concepts you’ve already learned, except for the body of the <code>giveaway</code> method that uses a closure. In the <code>giveaway</code> method, we get the user preference as a parameter of type <code>Option&lt;ShirtColor&gt;</code> and call the <code>unwrap_or_else</code> method on <code>user_preference</code>. The <a href="../std/option/enum.Option.html#method.unwrap_or_else"><code>unwrap_or_else</code> method on <code>Option&lt;T&gt;</code></a><!-- ignore --> is defined by the standard library. It takes one argument: a closure without any arguments that returns a value <code>T</code> (the same type stored in the <code>Some</code> variant of the <code>Option&lt;T&gt;</code>, in this case <code>ShirtColor</code>). If the <code>Option&lt;T&gt;</code> is the <code>Some</code> variant, <code>unwrap_or_else</code> returns the value from within the <code>Some</code>. If the <code>Option&lt;T&gt;</code> is the <code>None</code> variant, <code>unwrap_or_else</code> calls the closure and returns the value returned by the closure.</p>
<p>We specify the closure expression <code>|| self.most_stocked()</code> as the argument to <code>unwrap_or_else</code>. This is a closure that takes no parameters itself (if the closure had parameters, they would appear between the two vertical pipes). The body of the closure calls <code>self.most_stocked()</code>. We’re defining the closure here, and the implementation of <code>unwrap_or_else</code> will evaluate the closure later if the result is needed.</p>
<p>이 코드를 실행하면 다음과 같이 출력됩니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling shirt-company v0.1.0 (file:///projects/shirt-company)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/shirt-company`
The user with preference Some(Red) gets Red
The user with preference None gets Blue
</code></pre>
<p>여기서 한 가지 흥미로운 점은 현재 <code>Inventory</code> 인스턴스에 대해 <code>self.most_stocked()</code>를 호출하는 클로저를 전달했다는 것입니다. 표준 라이브러리는 우리가 정의한 <code>Inventory</code>나 <code>ShirtColor</code> 타입, 또는 이 시나리오에서 사용하려는 로직에 대해 아무것도 알 필요가 없었습니다. 클로저는 <code>self</code> <code>Inventory</code> 인스턴스에 대한 불변 참조를 캡처하고, 우리가 지정한 코드와 함께 그것을 <code>unwrap_or_else</code> 메서드로 전달합니다. 반면 함수는 이런 방식으로 환경을 캡처할 수 없습니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="closure-type-inference-and-annotation"></a></p>
<h3 id="inferring-and-annotating-closure-types"><a class="header" href="#inferring-and-annotating-closure-types">Inferring and Annotating Closure Types</a></h3>
<p>There are more differences between functions and closures. Closures don’t usually require you to annotate the types of the parameters or the return value like <code>fn</code> functions do. Type annotations are required on functions because the types are part of an explicit interface exposed to your users. Defining this interface rigidly is important for ensuring that everyone agrees on what types of values a function uses and returns. Closures, on the other hand, aren’t used in an exposed interface like this: They’re stored in variables, and they’re used without naming them and exposing them to users of our library.</p>
<p>클로저는 일반적으로 짧으며 임의의 시나리오보다는 좁은 문맥 안에서만 관련이 있습니다. 이러한 제한된 문맥 안에서 컴파일러는 대부분의 변수 타입을 추론할 수 있는 것과 마찬가지로 매개변수와 반환 타입을 추론할 수 있습니다(컴파일러가 클로저 타입 어노테이션을 필요로 하는 드문 경우도 있긴 합니다).</p>
<p>As with variables, we can add type annotations if we want to increase explicitness and clarity at the cost of being more verbose than is strictly necessary. Annotating the types for a closure would look like the definition shown in Listing 13-2. In this example, we’re defining a closure and storing it in a variable rather than defining the closure in the spot we pass it as an argument, as we did in Listing 13-1.</p>
<Listing number="13-2" file-name="src/main.rs" caption="Adding optional type annotations of the parameter and return value types in the closure">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {
</span>    let expensive_closure = |num: u32| -&gt; u32 {
        println!("천천히 계산 중...");
        thread::sleep(Duration::from_secs(2));
        num
    };
<span class="boring">
</span><span class="boring">    if intensity &lt; 25 {
</span><span class="boring">        println!("오늘은 팔굽혀펴기 {}회를 하세요!", expensive_closure(intensity));
</span><span class="boring">        println!("다음으로, 윗몸일으키기 {}회를 하세요!", expensive_closure(intensity));
</span><span class="boring">    } else {
</span><span class="boring">        if random_number == 3 {
</span><span class="boring">            println!("오늘은 휴식을 취하세요! 수분 섭취를 잊지 마세요!");
</span><span class="boring">        } else {
</span><span class="boring">            println!(
</span><span class="boring">                "오늘은 {}분간 달리세요!",
</span><span class="boring">                expensive_closure(intensity)
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let simulated_user_specified_value = 10;
</span><span class="boring">    let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">    generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>With type annotations added, the syntax of closures looks more similar to the syntax of functions. Here, we define a function that adds 1 to its parameter and a closure that has the same behavior, for comparison. We’ve added some spaces to line up the relevant parts. This illustrates how closure syntax is similar to function syntax except for the use of pipes and the amount of syntax that is optional:</p>
<pre><code class="language-rust ignore">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;</code></pre>
<p>The first line shows a function definition and the second line shows a fully annotated closure definition. In the third line, we remove the type annotations from the closure definition. In the fourth line, we remove the brackets, which are optional because the closure body has only one expression. These are all valid definitions that will produce the same behavior when they’re called. The <code>add_one_v3</code> and <code>add_one_v4</code> lines require the closures to be evaluated to be able to compile because the types will be inferred from their usage. This is similar to <code>let v = Vec::new();</code> needing either type annotations or values of some type to be inserted into the <code>Vec</code> for Rust to be able to infer the type.</p>
<p>클로저 정의의 경우, 컴파일러는 각 매개변수와 반환 값에 대해 하나의 구체적인 타입을 추론합니다. 예를 들어, 목록 13-3은 매개변수로 받은 값을 그대로 반환하는 짧은 클로저의 정의를 보여줍니다. 이 클로저는 예제 목적 외에는 별로 유용하지 않습니다. 정의에 아무런 타입 어노테이션도 추가하지 않았다는 점에 유의하세요. 타입 어노테이션이 없기 때문에 어떤 타입으로도 클로저를 호출할 수 있으며, 여기서는 처음으로 <code>String</code>과 함께 호출했습니다. 그런 다음 <code>example_closure</code>를 정수와 함께 호출하려고 하면 에러가 발생합니다.</p>
<Listing number="13-3" file-name="src/main.rs" caption="Attempting to call a closure whose types are inferred with two different types">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let example_closure = |x| x;

    let s = example_closure(String::from("hello"));
    let n = example_closure(5);
<span class="boring">}</span></code></pre>
</Listing>
<p>컴파일러는 다음과 같은 에러를 줍니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
error[E0308]: mismatched types
 --&gt; src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |             --------------- ^ expected `String`, found integer
  |             |
  |             arguments to this function are incorrect
  |
note: expected because the closure was earlier called with an argument of type `String`
 --&gt; src/main.rs:4:29
  |
4 |     let s = example_closure(String::from("hello"));
  |             --------------- ^^^^^^^^^^^^^^^^^^^^^ expected because this argument is of type `String`
  |             |
  |             in this closure call
note: closure parameter defined here
 --&gt; src/main.rs:2:28
  |
2 |     let example_closure = |x| x;
  |                            ^
help: try using a conversion method
  |
5 |     let n = example_closure(5.to_string());
  |                              ++++++++++++

For more information about this error, try `rustc --explain E0308`.
error: could not compile `closure-example` (bin "closure-example") due to 1 previous error
</code></pre>
<p>처음 <code>example_closure</code>를 <code>String</code> 값으로 호출할 때, 컴파일러는 <code>x</code>의 타입과 클로저의 반환 타입을 <code>String</code>으로 추론합니다. 그러면 그 타입들이 <code>example_closure</code>의 클로저에 고정되며, 다음에 다른 타입으로 <code>example_closure</code>를 호출하려고 하면 타입 에러가 발생합니다.</p>
<h3 id="참조-캡처하기-또는-소유권-이동하기"><a class="header" href="#참조-캡처하기-또는-소유권-이동하기">참조 캡처하기 또는 소유권 이동하기</a></h3>
<p>클로저는 세 가지 방식으로 환경에서 값을 캡처할 수 있으며, 이는 함수가 매개변수를 받는 세 가지 방식인 불변 대여, 가변 대여, 소유권 가져오기와 직접적으로 대응됩니다. 클로저는 함수 본문이 캡처된 값으로 무엇을 하는지에 따라 이 중 어떤 것을 사용할지 결정합니다.</p>
<p>In Listing 13-4, we define a closure that captures an immutable reference to the vector named <code>list</code> because it only needs an immutable reference to print the value.</p>
<Listing number="13-4" file-name="src/main.rs" caption="Defining and calling a closure that captures an immutable reference">
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let list = vec![1, 2, 3];
    println!("클로저 정의 전: {list:?}");

    let only_borrows = || println!("클로저 안에서: {list:?}");

    println!("클로저 호출 전: {list:?}");
    only_borrows();
    println!("클로저 호출 후: {list:?}");
}</code></pre></pre>
</Listing>
<p>이 예제는 또한 변수가 클로저 정의에 바인딩될 수 있으며, 나중에 변수 이름과 괄호를 사용하여 마치 함수 이름인 것처럼 클로저를 호출할 수 있음을 보여줍니다.</p>
<p><code>list</code>에 대한 불변 참조는 동시에 여러 개 가질 수 있으므로, 클로저 정의 전, 클로저 정의 후지만 호출 전, 그리고 클로저 호출 후에도 코드에서 <code>list</code>에 여전히 접근할 수 있습니다. 이 코드는 컴파일되고, 실행되며, 다음과 같이 출력합니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Before defining closure: [1, 2, 3]
Before calling closure: [1, 2, 3]
From closure: [1, 2, 3]
After calling closure: [1, 2, 3]
</code></pre>
<p>Next, in Listing 13-5, we change the closure body so that it adds an element to the <code>list</code> vector. The closure now captures a mutable reference.</p>
<Listing number="13-5" file-name="src/main.rs" caption="Defining and calling a closure that captures a mutable reference">
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let mut list = vec![1, 2, 3];
    println!("클로저 정의 전: {list:?}");

    let mut borrows_mutably = || list.push(7);

    borrows_mutably();
    println!("클로저 호출 후: {list:?}");
}</code></pre></pre>
</Listing>
<p>이 코드는 컴파일되고, 실행되며, 다음과 같이 출력합니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Before defining closure: [1, 2, 3]
After calling closure: [1, 2, 3, 7]
</code></pre>
<p>Note that there’s no longer a <code>println!</code> between the definition and the call of the <code>borrows_mutably</code> closure: When <code>borrows_mutably</code> is defined, it captures a mutable reference to <code>list</code>. We don’t use the closure again after the closure is called, so the mutable borrow ends. Between the closure definition and the closure call, an immutable borrow to print isn’t allowed, because no other borrows are allowed when there’s a mutable borrow. Try adding a <code>println!</code> there to see what error message you get!</p>
<p>클로저 본문이 엄밀히 말해 소유권을 필요로 하지 않더라도, 클로저가 환경에서 사용하는 값의 소유권을 가져오도록 강제하고 싶다면 매개변수 목록 앞에 <code>move</code> 키워드를 사용할 수 있습니다.</p>
<p>This technique is mostly useful when passing a closure to a new thread to move the data so that it’s owned by the new thread. We’ll discuss threads and why you would want to use them in detail in Chapter 16 when we talk about concurrency, but for now, let’s briefly explore spawning a new thread using a closure that needs the <code>move</code> keyword. Listing 13-6 shows Listing 13-4 modified to print the vector in a new thread rather than in the main thread.</p>
<Listing number="13-6" file-name="src/main.rs" caption="Using `move` to force the closure for the thread to take ownership of `list`">
<pre><pre class="playground"><code class="language-rust edition2024">use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    println!("클로저 정의 전: {list:?}");

    thread::spawn(move || println!("스레드에서: {list:?}"))
        .join()
        .unwrap();
}</code></pre></pre>
</Listing>
<p>We spawn a new thread, giving the thread a closure to run as an argument. The closure body prints out the list. In Listing 13-4, the closure only captured <code>list</code> using an immutable reference because that's the least amount of access to <code>list</code> needed to print it. In this example, even though the closure body still only needs an immutable reference, we need to specify that <code>list</code> should be moved into the closure by putting the <code>move</code> keyword at the beginning of the closure definition. If the main thread performed more operations before calling <code>join</code> on the new thread, the new thread might finish before the rest of the main thread finishes, or the main thread might finish first. If the main thread maintained ownership of <code>list</code> but ended before the new thread and drops <code>list</code>, the immutable reference in the thread would be invalid. Therefore, the compiler requires that <code>list</code> be moved into the closure given to the new thread so that the reference will be valid. Try removing the <code>move</code> keyword or using <code>list</code> in the main thread after the closure is defined to see what compiler errors you get!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="storing-closures-using-generic-parameters-and-the-fn-traits"></a> <a id="limitations-of-the-cacher-implementation"></a> <a id="moving-captured-values-out-of-the-closure-and-the-fn-traits"></a> <a id="moving-captured-values-out-of-closures-and-the-fn-traits"></a></p>
<h3 id="moving-captured-values-out-of-closures"><a class="header" href="#moving-captured-values-out-of-closures">Moving Captured Values Out of Closures</a></h3>
<p>Once a closure has captured a reference or captured ownership of a value from the environment where the closure is defined (thus affecting what, if anything, is moved <em>into</em> the closure), the code in the body of the closure defines what happens to the references or values when the closure is evaluated later (thus affecting what, if anything, is moved <em>out of</em> the closure).</p>
<p>A closure body can do any of the following: Move a captured value out of the closure, mutate the captured value, neither move nor mutate the value, or capture nothing from the environment to begin with.</p>
<p>클로저가 환경의 값을 캡처하고 처리하는 방식은 클로저가 구현하는 트레이트에 영향을 미치며, 함수나 구조체는 트레이트를 사용하여 어떤 종류의 클로저를 사용할 수 있는지 명시할 수 있습니다. 클로저는 본문이 값을 처리하는 방식에 따라 다음 세 가지 <code>Fn</code> 트레이트 중 하나, 둘 또는 셋 모두를 자동으로 구현합니다:</p>
<ul>
<li><code>FnOnce</code> applies to closures that can be called once. All closures implement at least this trait because all closures can be called. A closure that moves captured values out of its body will only implement <code>FnOnce</code> and none of the other <code>Fn</code> traits because it can only be called once.</li>
<li><code>FnMut</code> applies to closures that don’t move captured values out of their body but might mutate the captured values. These closures can be called more than once.</li>
<li><code>Fn</code> applies to closures that don’t move captured values out of their body and don’t mutate captured values, as well as closures that capture nothing from their environment. These closures can be called more than once without mutating their environment, which is important in cases such as calling a closure multiple times concurrently.</li>
</ul>
<p>목록 13-1에서 사용했던 <code>Option&lt;T&gt;</code>의 <code>unwrap_or_else</code> 메서드 정의를 살펴봅시다:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap_or_else&lt;F&gt;(self, f: F) -&gt; T
    where
        F: FnOnce() -&gt; T
    {
        match self {
            Some(x) =&gt; x,
            None =&gt; f(),
        }
    }
}</code></pre>
<p>Recall that <code>T</code> is the generic type representing the type of the value in the <code>Some</code> variant of an <code>Option</code>. That type <code>T</code> is also the return type of the <code>unwrap_or_else</code> function: Code that calls <code>unwrap_or_else</code> on an <code>Option&lt;String&gt;</code>, for example, will get a <code>String</code>.</p>
<p>다음으로, <code>unwrap_or_else</code> 함수가 추가적인 제네릭 타입 매개변수 <code>F</code>를 가지고 있음에 주목하세요. <code>F</code> 타입은 <code>f</code>라는 이름의 매개변수 타입이며, 이는 <code>unwrap_or_else</code>를 호출할 때 우리가 제공하는 클로저입니다.</p>
<p>The trait bound specified on the generic type <code>F</code> is <code>FnOnce() -&gt; T</code>, which means <code>F</code> must be able to be called once, take no arguments, and return a <code>T</code>. Using <code>FnOnce</code> in the trait bound expresses the constraint that <code>unwrap_or_else</code> will not call <code>f</code> more than once. In the body of <code>unwrap_or_else</code>, we can see that if the <code>Option</code> is <code>Some</code>, <code>f</code> won’t be called. If the <code>Option</code> is <code>None</code>, <code>f</code> will be called once. Because all closures implement <code>FnOnce</code>, <code>unwrap_or_else</code> accepts all three kinds of closures and is as flexible as it can be.</p>
<blockquote>
<p>Note: If what we want to do doesn’t require capturing a value from the environment, we can use the name of a function rather than a closure where we need something that implements one of the <code>Fn</code> traits. For example, on an <code>Option&lt;Vec&lt;T&gt;&gt;</code> value, we could call <code>unwrap_or_else(Vec::new)</code> to get a new, empty vector if the value is <code>None</code>. The compiler automatically implements whichever of the <code>Fn</code> traits is applicable for a function definition.</p>
</blockquote>
<p>Now let’s look at the standard library method <code>sort_by_key</code>, defined on slices, to see how that differs from <code>unwrap_or_else</code> and why <code>sort_by_key</code> uses <code>FnMut</code> instead of <code>FnOnce</code> for the trait bound. The closure gets one argument in the form of a reference to the current item in the slice being considered, and it returns a value of type <code>K</code> that can be ordered. This function is useful when you want to sort a slice by a particular attribute of each item. In Listing 13-7, we have a list of <code>Rectangle</code> instances, and we use <code>sort_by_key</code> to order them by their <code>width</code> attribute from low to high.</p>
<Listing number="13-7" file-name="src/main.rs" caption="Using `sort_by_key` to order rectangles by width">
<pre><pre class="playground"><code class="language-rust edition2024">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    list.sort_by_key(|r| r.width);
    println!("{list:#?}");
}</code></pre></pre>
</Listing>
<p>이 코드는 다음을 출력합니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.41s
     Running `target/debug/rectangles`
[
    Rectangle {
        width: 3,
        height: 5,
    },
    Rectangle {
        width: 7,
        height: 12,
    },
    Rectangle {
        width: 10,
        height: 1,
    },
]
</code></pre>
<p>The reason <code>sort_by_key</code> is defined to take an <code>FnMut</code> closure is that it calls the closure multiple times: once for each item in the slice. The closure <code>|r| r.width</code> doesn’t capture, mutate, or move anything out from its environment, so it meets the trait bound requirements.</p>
<p>In contrast, Listing 13-8 shows an example of a closure that implements just the <code>FnOnce</code> trait, because it moves a value out of the environment. The compiler won’t let us use this closure with <code>sort_by_key</code>.</p>
<Listing number="13-8" file-name="src/main.rs" caption="Attempting to use an `FnOnce` closure with `sort_by_key`">
<pre><code class="language-rust ignore does_not_compile">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut sort_operations = vec![];
    let value = String::from("클로저 호출됨");

    list.sort_by_key(|r| {
        sort_operations.push(value);
        r.width
    });
    println!("{list:#?}");
}</code></pre>
</Listing>
<p>This is a contrived, convoluted way (that doesn’t work) to try to count the number of times <code>sort_by_key</code> calls the closure when sorting <code>list</code>. This code attempts to do this counting by pushing <code>value</code>—a <code>String</code> from the closure’s environment—into the <code>sort_operations</code> vector. The closure captures <code>value</code> and then moves <code>value</code> out of the closure by transferring ownership of <code>value</code> to the <code>sort_operations</code> vector. This closure can be called once; trying to call it a second time wouldn’t work, because <code>value</code> would no longer be in the environment to be pushed into <code>sort_operations</code> again! Therefore, this closure only implements <code>FnOnce</code>. When we try to compile this code, we get this error that <code>value</code> can’t be moved out of the closure because the closure must implement <code>FnMut</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
error[E0507]: cannot move out of `value`, a captured variable in an `FnMut` closure
  --&gt; src/main.rs:18:30
   |
15 |     let value = String::from("closure called");
   |         -----   ------------------------------ move occurs because `value` has type `String`, which does not implement the `Copy` trait
   |         |
   |         captured outer variable
16 |
17 |     list.sort_by_key(|r| {
   |                      --- captured by this `FnMut` closure
18 |         sort_operations.push(value);
   |                              ^^^^^ `value` is moved here
   |
help: consider cloning the value if the performance cost is acceptable
   |
18 |         sort_operations.push(value.clone());
   |                                   ++++++++

For more information about this error, try `rustc --explain E0507`.
error: could not compile `rectangles` (bin "rectangles") due to 1 previous error
</code></pre>
<p>The error points to the line in the closure body that moves <code>value</code> out of the environment. To fix this, we need to change the closure body so that it doesn’t move values out of the environment. Keeping a counter in the environment and incrementing its value in the closure body is a more straightforward way to count the number of times the closure is called. The closure in Listing 13-9 works with <code>sort_by_key</code> because it is only capturing a mutable reference to the <code>num_sort_operations</code> counter and can therefore be called more than once.</p>
<Listing number="13-9" file-name="src/main.rs" caption="Using an `FnMut` closure with `sort_by_key` is allowed.">
<pre><pre class="playground"><code class="language-rust edition2024">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut num_sort_operations = 0;
    list.sort_by_key(|r| {
        num_sort_operations += 1;
        r.width
    });
    println!("{list:#?}, {num_sort_operations}번의 연산으로 정렬됨");
}</code></pre></pre>
</Listing>
<p><code>Fn</code> 트레이트는 클로저를 사용하는 함수나 타입을 정의하거나 사용할 때 중요합니다. 다음 섹션에서는 반복자에 대해 논의하겠습니다. 많은 반복자 메서드들이 클로저를 인수로 받으므로, 앞으로 진행하면서 이러한 클로저의 세부 사항들을 기억해 두세요!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch13-00-functional-features.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch13-02-iterators.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch13-00-functional-features.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch13-02-iterators.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
