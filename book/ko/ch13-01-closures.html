<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>클로저: 환경을 캡처하는 익명 함수 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch13-01-closures.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch13-01-closures.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Old heading. Do not remove or links may break. -->
<p><a id="closures-anonymous-functions-that-can-capture-their-environment"></a></p>
<h2 id="클로저-환경을-캡처하는-익명-함수"><a class="header" href="#클로저-환경을-캡처하는-익명-함수">클로저: 환경을 캡처하는 익명 함수</a></h2>
<p>러스트의 클로저는 변수에 저장하거나 다른 함수에 인수로 전달할 수 있는 익명 함수입니다. 한 곳에서 클로저를 생성한 다음 다른 곳에서 호출하여 다른 컨텍스트에서 평가할 수 있습니다. 함수와 달리 클로저는 정의된 스코프의 값을 캡처할 수 있습니다. 이러한 클로저의 기능이 어떻게 코드 재사용과 동작 커스터마이징을 가능하게 하는지 보여드리겠습니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="creating-an-abstraction-of-behavior-with-closures"></a> <a id="refactoring-using-functions"></a> <a id="refactoring-with-closures-to-store-code"></a></p>
<h3 id="클로저로-환경-캡처하기"><a class="header" href="#클로저로-환경-캡처하기">클로저로 환경 캡처하기</a></h3>
<p>먼저 클로저를 사용하여 나중에 사용할 수 있도록 정의된 환경의 값을 캡처하는 방법을 살펴보겠습니다. 시나리오는 다음과 같습니다: 우리 티셔츠 회사는 가끔 프로모션으로 메일링 리스트에 있는 누군가에게 독점 한정판 셔츠를 무료로 증정합니다. 메일링 리스트에 있는 사람들은 선택적으로 자신의 프로필에 좋아하는 색상을 추가할 수 있습니다. 무료 셔츠 당첨자로 선정된 사람이 좋아하는 색상을 설정했다면, 그 색상의 셔츠를 받습니다. 좋아하는 색상을 지정하지 않았다면, 회사가 현재 가장 많이 보유하고 있는 색상의 셔츠를 받습니다.</p>
<p>이를 구현하는 방법은 여러 가지가 있습니다. 이 예제에서는 <code>Red</code>와 <code>Blue</code> 변형을 가진 <code>ShirtColor</code>라는 열거형을 사용하겠습니다(단순함을 위해 색상 수를 제한했습니다). 회사의 재고는 현재 재고에 있는 셔츠 색상을 나타내는 <code>Vec&lt;ShirtColor&gt;</code>를 담은 <code>shirts</code> 필드를 가진 <code>Inventory</code> 구조체로 나타냅니다. <code>Inventory</code>에 정의된 <code>giveaway</code> 메서드는 무료 셔츠 당첨자의 선택적인 선호 색상을 받아 그 사람이 받게 될 셔츠 색상을 반환합니다. 이 설정은 목록 13-1에 나와 있습니다:</p>
<Listing number="13-1" file-name="src/main.rs" caption="Shirt company giveaway situation">
<pre><code class="language-rust noplayground">#[derive(Debug, PartialEq, Copy, Clone)]
enum ShirtColor {
    Red,
    Blue,
}

struct Inventory {
    shirts: Vec&lt;ShirtColor&gt;,
}

impl Inventory {
    fn giveaway(&amp;self, user_preference: Option&lt;ShirtColor&gt;) -&gt; ShirtColor {
        user_preference.unwrap_or_else(|| self.most_stocked())
    }

    fn most_stocked(&amp;self) -&gt; ShirtColor {
        let mut num_red = 0;
        let mut num_blue = 0;

        for color in &amp;self.shirts {
            match color {
                ShirtColor::Red =&gt; num_red += 1,
                ShirtColor::Blue =&gt; num_blue += 1,
            }
        }
        if num_red &gt; num_blue {
            ShirtColor::Red
        } else {
            ShirtColor::Blue
        }
    }
}

fn main() {
    let store = Inventory {
        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],
    };

    let user_pref1 = Some(ShirtColor::Red);
    let giveaway1 = store.giveaway(user_pref1);
    println!(
        "선호도가 {:?}인 사용자는 {:?}를 받습니다",
        user_pref1, giveaway1
    );

    let user_pref2 = None;
    let giveaway2 = store.giveaway(user_pref2);
    println!(
        "선호도가 {:?}인 사용자는 {:?}를 받습니다",
        user_pref2, giveaway2
    );
}</code></pre>
</Listing>
<p><code>main</code>에 정의된 <code>store</code>는 이번 한정판 프로모션을 위해 파란색 셔츠 두 장과 빨간색 셔츠 한 장을 남겨두고 있습니다. 우리는 빨간색 셔츠를 선호하는 사용자와 선호도가 없는 사용자에 대해 <code>giveaway</code> 메서드를 호출합니다.</p>
<p>다시 말하지만, 이 코드는 여러 방식으로 구현될 수 있습니다. 여기서는 클로저에 집중하기 위해, 클로저를 사용하는 <code>giveaway</code> 메서드의 본문을 제외하고는 여러분이 이미 배운 개념들을 고수했습니다. <code>giveaway</code> 메서드에서 우리는 사용자 선호도를 <code>Option&lt;ShirtColor&gt;</code> 타입의 매개변수로 받고 <code>user_preference</code>에 대해 <code>unwrap_or_else</code> 메서드를 호출합니다. 표준 라이브러리에 정의된 <a href="../std/option/enum.Option.html#method.unwrap_or_else"><code>Option&lt;T&gt;</code>의 <code>unwrap_or_else</code> 메서드</a><!-- ignore -->는 인수를 하나 받는데, 그 인수는 매개변수가 없고 <code>T</code> 값(<code>Option&lt;T&gt;</code>의 <code>Some</code> 변형에 저장된 것과 같은 타입, 이 경우 <code>ShirtColor</code>)을 반환하는 클로저입니다. <code>Option&lt;T&gt;</code>가 <code>Some</code> 변형이면 <code>unwrap_or_else</code>는 <code>Some</code> 내부의 값을 반환합니다. <code>Option&lt;T&gt;</code>가 <code>None</code> 변형이면 <code>unwrap_or_else</code>는 클로저를 호출하고 클로저가 반환한 값을 반환합니다.</p>
<p>우리는 <code>|| self.most_stocked()</code>라는 클로저 표현식을 <code>unwrap_or_else</code>의 인수로 지정했습니다. 이것은 매개변수를 받지 않는 클로저입니다(클로저에 매개변수가 있다면 두 수직 막대 사이에 나타날 것입니다). 클로저의 본문은 <code>self.most_stocked()</code>를 호출합니다. 우리는 여기서 클로저를 정의하고 있으며, <code>unwrap_or_else</code>의 구현은 나중에 결과가 필요할 때 클로저를 평가할 것입니다.</p>
<p>이 코드를 실행하면 다음과 같이 출력됩니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling shirt-company v0.1.0 (file:///projects/shirt-company)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/shirt-company`
The user with preference Some(Red) gets Red
The user with preference None gets Blue
</code></pre>
<p>여기서 한 가지 흥미로운 점은 현재 <code>Inventory</code> 인스턴스에 대해 <code>self.most_stocked()</code>를 호출하는 클로저를 전달했다는 것입니다. 표준 라이브러리는 우리가 정의한 <code>Inventory</code>나 <code>ShirtColor</code> 타입, 또는 이 시나리오에서 사용하려는 로직에 대해 아무것도 알 필요가 없었습니다. 클로저는 <code>self</code> <code>Inventory</code> 인스턴스에 대한 불변 참조를 캡처하고, 우리가 지정한 코드와 함께 그것을 <code>unwrap_or_else</code> 메서드로 전달합니다. 반면 함수는 이런 방식으로 환경을 캡처할 수 없습니다.</p>
<h3 id="클로저-타입-추론과-어노테이션"><a class="header" href="#클로저-타입-추론과-어노테이션">클로저 타입 추론과 어노테이션</a></h3>
<p>함수와 클로저 사이에는 더 많은 차이점이 있습니다. 클로저는 보통 <code>fn</code> 함수처럼 매개변수나 반환 값의 타입을 명시할 것을 요구하지 않습니다. 함수에 타입 어노테이션이 필요한 이유는 타입이 사용자에게 노출되는 명시적인 인터페이스의 일부이기 때문입니다. 이 인터페이스를 엄격하게 정의하는 것은 함수가 어떤 타입의 값을 사용하고 반환하는지에 대해 모두가 동의하도록 보장하는 데 중요합니다. 반면 클로저는 이렇게 노출된 인터페이스에서 사용되지 않습니다. 변수에 저장되고, 이름 없이 사용되며, 라이브러리 사용자에게 노출되지 않습니다.</p>
<p>클로저는 일반적으로 짧으며 임의의 시나리오보다는 좁은 문맥 안에서만 관련이 있습니다. 이러한 제한된 문맥 안에서 컴파일러는 대부분의 변수 타입을 추론할 수 있는 것과 마찬가지로 매개변수와 반환 타입을 추론할 수 있습니다(컴파일러가 클로저 타입 어노테이션을 필요로 하는 드문 경우도 있긴 합니다).</p>
<p>변수와 마찬가지로, 엄격하게 필요한 것보다 더 장황해지는 비용을 치르더라도 명시성과 명확성을 높이고 싶다면 타입 어노테이션을 추가할 수 있습니다. 클로저에 타입을 명시하는 것은 목록 13-2에 나온 정의와 같습니다. 이 예제에서는 목록 13-1에서처럼 인수로 전달하는 지점에서 클로저를 정의하는 대신, 클로저를 정의하고 변수에 저장하고 있습니다.</p>
<Listing number="13-2" file-name="src/main.rs" caption="Adding optional type annotations of the parameter and return value types in the closure">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {
</span>    let expensive_closure = |num: u32| -&gt; u32 {
        println!("천천히 계산 중...");
        thread::sleep(Duration::from_secs(2));
        num
    };
<span class="boring">
</span><span class="boring">    if intensity &lt; 25 {
</span><span class="boring">        println!("오늘은 팔굽혀펴기 {}회를 하세요!", expensive_closure(intensity));
</span><span class="boring">        println!("다음으로, 윗몸일으키기 {}회를 하세요!", expensive_closure(intensity));
</span><span class="boring">    } else {
</span><span class="boring">        if random_number == 3 {
</span><span class="boring">            println!("오늘은 휴식을 취하세요! 수분 섭취를 잊지 마세요!");
</span><span class="boring">        } else {
</span><span class="boring">            println!(
</span><span class="boring">                "오늘은 {}분간 달리세요!",
</span><span class="boring">                expensive_closure(intensity)
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let simulated_user_specified_value = 10;
</span><span class="boring">    let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">    generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>타입 어노테이션이 추가되면, 클로저의 문법은 함수의 문법과 더 비슷해 보입니다. 여기서 우리는 비교를 위해 매개변수에 1을 더하는 함수와 동일한 동작을 하는 클로저를 정의합니다. 관련 부분들을 정렬하기 위해 공백을 좀 추가했습니다. 이는 파이프의 사용과 선택적인 문법의 양을 제외하면 클로저 문법이 함수 문법과 얼마나 유사한지 보여줍니다:</p>
<pre><code class="language-rust ignore">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;</code></pre>
<p>첫 번째 줄은 함수 정의를 보여주고, 두 번째 줄은 완전히 어노테이션된 클로저 정의를 보여줍니다. 세 번째 줄에서는 클로저 정의에서 타입 어노테이션을 제거했습니다. 네 번째 줄에서는 중괄호를 제거했는데, 클로저 본문에 표현식이 하나만 있는 경우 중괄호는 선택 사항이기 때문입니다. 이것들은 모두 유효한 정의이며 호출되었을 때 동일한 동작을 수행합니다. <code>add_one_v3</code>와 <code>add_one_v4</code> 라인은 사용 방식을 통해 타입이 추론되므로, 컴파일되려면 클로저가 평가되어야 합니다. 이는 <code>let v = Vec::new();</code>가 러스트가 타입을 추론할 수 있도록 타입 어노테이션이나 <code>Vec</code>에 삽입될 어떤 타입의 값이 필요한 것과 유사합니다.</p>
<p>클로저 정의의 경우, 컴파일러는 각 매개변수와 반환 값에 대해 하나의 구체적인 타입을 추론합니다. 예를 들어, 목록 13-3은 매개변수로 받은 값을 그대로 반환하는 짧은 클로저의 정의를 보여줍니다. 이 클로저는 예제 목적 외에는 별로 유용하지 않습니다. 정의에 아무런 타입 어노테이션도 추가하지 않았다는 점에 유의하세요. 타입 어노테이션이 없기 때문에 어떤 타입으로도 클로저를 호출할 수 있으며, 여기서는 처음으로 <code>String</code>과 함께 호출했습니다. 그런 다음 <code>example_closure</code>를 정수와 함께 호출하려고 하면 에러가 발생합니다.</p>
<Listing number="13-3" file-name="src/main.rs" caption="Attempting to call a closure whose types are inferred with two different types">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let example_closure = |x| x;

    let s = example_closure(String::from("hello"));
    let n = example_closure(5);
<span class="boring">}</span></code></pre>
</Listing>
<p>컴파일러는 다음과 같은 에러를 줍니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
error[E0308]: mismatched types
 --&gt; src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |             --------------- ^- help: try using a conversion method: `.to_string()`
  |             |               |
  |             |               expected `String`, found integer
  |             arguments to this function are incorrect
  |
note: expected because the closure was earlier called with an argument of type `String`
 --&gt; src/main.rs:4:29
  |
4 |     let s = example_closure(String::from("hello"));
  |             --------------- ^^^^^^^^^^^^^^^^^^^^^ expected because this argument is of type `String`
  |             |
  |             in this closure call
note: closure parameter defined here
 --&gt; src/main.rs:2:28
  |
2 |     let example_closure = |x| x;
  |                            ^

For more information about this error, try `rustc --explain E0308`.
error: could not compile `closure-example` (bin "closure-example") due to 1 previous error
</code></pre>
<p>처음 <code>example_closure</code>를 <code>String</code> 값으로 호출할 때, 컴파일러는 <code>x</code>의 타입과 클로저의 반환 타입을 <code>String</code>으로 추론합니다. 그러면 그 타입들이 <code>example_closure</code>의 클로저에 고정되며, 다음에 다른 타입으로 <code>example_closure</code>를 호출하려고 하면 타입 에러가 발생합니다.</p>
<h3 id="참조-캡처하기-또는-소유권-이동하기"><a class="header" href="#참조-캡처하기-또는-소유권-이동하기">참조 캡처하기 또는 소유권 이동하기</a></h3>
<p>클로저는 세 가지 방식으로 환경에서 값을 캡처할 수 있으며, 이는 함수가 매개변수를 받는 세 가지 방식인 불변 대여, 가변 대여, 소유권 가져오기와 직접적으로 대응됩니다. 클로저는 함수 본문이 캡처된 값으로 무엇을 하는지에 따라 이 중 어떤 것을 사용할지 결정합니다.</p>
<p>목록 13-4에서는 <code>list</code>라는 벡터에 대한 불변 참조를 캡처하는 클로저를 정의합니다. 값을 출력하기 위해서는 불변 참조만 있으면 되기 때문입니다:</p>
<Listing number="13-4" file-name="src/main.rs" caption="Defining and calling a closure that captures an immutable reference">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let list = vec![1, 2, 3];
    println!("클로저 정의 전: {list:?}");

    let only_borrows = || println!("클로저 안에서: {list:?}");

    println!("클로저 호출 전: {list:?}");
    only_borrows();
    println!("클로저 호출 후: {list:?}");
}</code></pre></pre>
</Listing>
<p>이 예제는 또한 변수가 클로저 정의에 바인딩될 수 있으며, 나중에 변수 이름과 괄호를 사용하여 마치 함수 이름인 것처럼 클로저를 호출할 수 있음을 보여줍니다.</p>
<p><code>list</code>에 대한 불변 참조는 동시에 여러 개 가질 수 있으므로, 클로저 정의 전, 클로저 정의 후지만 호출 전, 그리고 클로저 호출 후에도 코드에서 <code>list</code>에 여전히 접근할 수 있습니다. 이 코드는 컴파일되고, 실행되며, 다음과 같이 출력합니다:</p>
<pre><code class="language-console">$ cargo run
     Locking 1 package to latest compatible version
      Adding closure-example v0.1.0 (/Users/chris/dev/rust-lang/book/tmp/listings/ch13-functional-features/listing-13-04)
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Before defining closure: [1, 2, 3]
Before calling closure: [1, 2, 3]
From closure: [1, 2, 3]
After calling closure: [1, 2, 3]
</code></pre>
<p>다음으로, 목록 13-5에서는 클로저 본문을 변경하여 <code>list</code> 벡터에 요소를 추가하도록 합니다. 이제 클로저는 가변 참조를 캡처합니다:</p>
<Listing number="13-5" file-name="src/main.rs" caption="Defining and calling a closure that captures a mutable reference">
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut list = vec![1, 2, 3];
    println!("클로저 정의 전: {list:?}");

    let mut borrows_mutably = || list.push(7);

    borrows_mutably();
    println!("클로저 호출 후: {list:?}");
}</code></pre></pre>
</Listing>
<p>이 코드는 컴파일되고, 실행되며, 다음과 같이 출력합니다:</p>
<pre><code class="language-console">$ cargo run
     Locking 1 package to latest compatible version
      Adding closure-example v0.1.0 (/Users/chris/dev/rust-lang/book/tmp/listings/ch13-functional-features/listing-13-05)
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Before defining closure: [1, 2, 3]
After calling closure: [1, 2, 3, 7]
</code></pre>
<p><code>borrows_mutably</code> 클로저의 정의와 호출 사이에 더 이상 <code>println!</code>이 없다는 점에 유의하세요: <code>borrows_mutably</code>가 정의될 때, 이 클로저는 <code>list</code>에 대한 가변 참조를 캡처합니다. 클로저가 호출된 후에는 클로저를 다시 사용하지 않으므로, 가변 대여가 끝납니다. 클로저 정의와 클로저 호출 사이에는 출력하기 위한 불변 대여가 허용되지 않는데, 이는 가변 대여가 있을 때 다른 대여가 허용되지 않기 때문입니다. 그곳에 <code>println!</code>을 추가하여 어떤 오류 메시지가 나타나는지 확인해 보세요!</p>
<p>클로저 본문이 엄밀히 말해 소유권을 필요로 하지 않더라도, 클로저가 환경에서 사용하는 값의 소유권을 가져오도록 강제하고 싶다면 매개변수 목록 앞에 <code>move</code> 키워드를 사용할 수 있습니다.</p>
<p>이 기술은 주로 새로운 스레드로 클로저를 전달할 때 데이터를 이동시켜 새 스레드가 그 데이터를 소유하도록 할 때 유용합니다. 스레드와 왜 스레드를 사용하고 싶은지에 대해서는 16장에서 동시성을 다룰 때 자세히 논의하겠지만, 지금은 <code>move</code> 키워드가 필요한 클로저를 사용하여 새 스레드를 생성하는 것을 간단히 살펴보겠습니다. 목록 13-6은 메인 스레드 대신 새 스레드에서 벡터를 출력하도록 목록 13-4를 수정한 것입니다:</p>
<Listing number="13-6" file-name="src/main.rs" caption="Using `move` to force the closure for the thread to take ownership of `list`">
<pre><pre class="playground"><code class="language-rust edition2021">use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    println!("클로저 정의 전: {list:?}");

    thread::spawn(move || println!("스레드에서: {list:?}"))
        .join()
        .unwrap();
}</code></pre></pre>
</Listing>
<p>우리는 실행할 클로저를 인수로 주어 새 스레드를 생성합니다. 클로저 본문은 리스트를 출력합니다. 목록 13-4에서 클로저는 <code>list</code>를 출력하는 데 필요한 최소한의 접근 권한인 불변 참조만을 사용하여 <code>list</code>를 캡처했습니다. 이 예제에서도 클로저 본문은 여전히 불변 참조만 필요로 하지만, 클로저 정의 앞에 <code>move</code> 키워드를 넣어 <code>list</code>가 클로저로 이동되어야 함을 명시해야 합니다. 새 스레드는 메인 스레드의 나머지 부분이 끝나기 전에 끝날 수도 있고, 메인 스레드가 먼저 끝날 수도 있습니다. 만약 메인 스레드가 <code>list</code>의 소유권을 유지하다가 새 스레드보다 먼저 끝나서 <code>list</code>를 드롭해 버린다면, 스레드 안의 불변 참조는 유효하지 않게 될 것입니다. 따라서 컴파일러는 참조가 유효하도록 <code>list</code>를 새 스레드에 주어진 클로저로 이동시킬 것을 요구합니다. <code>move</code> 키워드를 제거하거나 클로저가 정의된 후 메인 스레드에서 <code>list</code>를 사용하여 어떤 컴파일러 에러가 발생하는지 확인해 보세요!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="storing-closures-using-generic-parameters-and-the-fn-traits"></a> <a id="limitations-of-the-cacher-implementation"></a> <a id="moving-captured-values-out-of-the-closure-and-the-fn-traits"></a></p>
<h3 id="캡처된-값을-클로저-밖으로-이동하기와-fn-트레이트"><a class="header" href="#캡처된-값을-클로저-밖으로-이동하기와-fn-트레이트">캡처된 값을 클로저 밖으로 이동하기와 <code>Fn</code> 트레이트</a></h3>
<p>클로저가 정의된 환경에서 참조를 캡처하거나 값의 소유권을 캡처하고 나면(이는 무엇이 클로저 <em>안으로</em> 이동되는지에 영향을 미칩니다), 클로저 본문의 코드는 나중에 클로저가 평가될 때 그 참조나 값들에 무슨 일이 일어날지 정의합니다(이는 무엇이 클로저 <em>밖으로</em> 이동되는지에 영향을 미칩니다). 클로저 본문은 다음 중 하나를 수행할 수 있습니다: 캡처된 값을 클로저 밖으로 이동하기, 캡처된 값을 변경하기, 값을 이동하지도 변경하지도 않기, 또는 애초에 환경에서 아무것도 캡처하지 않기.</p>
<p>클로저가 환경의 값을 캡처하고 처리하는 방식은 클로저가 구현하는 트레이트에 영향을 미치며, 함수나 구조체는 트레이트를 사용하여 어떤 종류의 클로저를 사용할 수 있는지 명시할 수 있습니다. 클로저는 본문이 값을 처리하는 방식에 따라 다음 세 가지 <code>Fn</code> 트레이트 중 하나, 둘 또는 셋 모두를 자동으로 구현합니다:</p>
<ol>
<li><code>FnOnce</code>는 한 번 호출될 수 있는 클로저에 적용됩니다. 모든 클로저는 호출될 수 있으므로, 모든 클로저는 적어도 이 트레이트를 구현합니다. 캡처된 값을 본문 밖으로 이동시키는 클로저는 <code>FnOnce</code>만 구현하며 다른 <code>Fn</code> 트레이트는 구현하지 않습니다. 왜냐하면 한 번만 호출될 수 있기 때문입니다.</li>
<li><code>FnMut</code>은 캡처된 값을 본문 밖으로 이동시키지는 않지만 변경할 수 있는 클로저에 적용됩니다. 이러한 클로저는 두 번 이상 호출될 수 있습니다.</li>
<li><code>Fn</code>은 캡처된 값을 본문 밖으로 이동시키지 않고 변경하지도 않는 클로저, 또는 환경에서 아무것도 캡처하지 않는 클로저에 적용됩니다. 이러한 클로저는 환경을 변경하지 않고 두 번 이상 호출될 수 있으며, 이는 클로저를 동시에 여러 번 호출하는 것과 같은 경우에 중요합니다.</li>
</ol>
<p>목록 13-1에서 사용했던 <code>Option&lt;T&gt;</code>의 <code>unwrap_or_else</code> 메서드 정의를 살펴봅시다:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap_or_else&lt;F&gt;(self, f: F) -&gt; T
    where
        F: FnOnce() -&gt; T
    {
        match self {
            Some(x) =&gt; x,
            None =&gt; f(),
        }
    }
}</code></pre>
<p><code>T</code>는 <code>Option</code>의 <code>Some</code> 변형에 들어있는 값의 타입을 나타내는 제네릭 타입임을 기억하세요. 이 <code>T</code> 타입은 <code>unwrap_or_else</code> 함수의 반환 타입이기도 합니다. 예를 들어, <code>Option&lt;String&gt;</code>에 대해 <code>unwrap_or_else</code>를 호출하는 코드는 <code>String</code>을 얻게 됩니다.</p>
<p>다음으로, <code>unwrap_or_else</code> 함수가 추가적인 제네릭 타입 매개변수 <code>F</code>를 가지고 있음에 주목하세요. <code>F</code> 타입은 <code>f</code>라는 이름의 매개변수 타입이며, 이는 <code>unwrap_or_else</code>를 호출할 때 우리가 제공하는 클로저입니다.</p>
<p>제네릭 타입 <code>F</code>에 지정된 트레이트 바운드는 <code>FnOnce() -&gt; T</code>입니다. 이는 <code>F</code>가 한 번 호출될 수 있어야 하고, 인수를 받지 않으며, <code>T</code>를 반환해야 함을 의미합니다. 트레이트 바운드에 <code>FnOnce</code>를 사용하는 것은 <code>unwrap_or_else</code>가 <code>f</code>를 최대 한 번만 호출할 것임을 제약 조건으로 표현합니다. <code>unwrap_or_else</code>의 본문에서 <code>Option</code>이 <code>Some</code>이면 <code>f</code>가 호출되지 않는 것을 볼 수 있습니다. <code>Option</code>이 <code>None</code>이면 <code>f</code>는 한 번 호출됩니다. 모든 클로저는 <code>FnOnce</code>를 구현하므로, <code>unwrap_or_else</code>는 세 가지 종류의 클로저를 모두 받아들일 수 있으며 가능한 한 유연하게 작동합니다.</p>
<blockquote>
<p>참고: 우리가 하려는 작업이 환경에서 값을 캡처할 필요가 없다면, 클로저 대신 함수 이름을 사용할 수 있습니다. 예를 들어, <code>Option&lt;Vec&lt;T&gt;&gt;</code> 값에 대해 <code>unwrap_or_else(Vec::new)</code>를 호출하면 값이 <code>None</code>일 때 새로운 빈 벡터를 얻게 됩니다. 컴파일러는 함수 정의에 적용 가능한 <code>Fn</code> 트레이트가 무엇이든 자동으로 구현합니다.</p>
</blockquote>
<p>이제 슬라이스에 정의된 표준 라이브러리 메서드 <code>sort_by_key</code>가 <code>unwrap_or_else</code>와 어떻게 다른지, 그리고 <code>sort_by_key</code>가 트레이트 바운드에 <code>FnOnce</code> 대신 <code>FnMut</code>을 사용하는 이유를 살펴보겠습니다. 이 클로저는 고려 중인 슬라이스의 현재 아이템에 대한 참조 형식으로 인수를 하나 받고, 정렬 가능한 <code>K</code> 타입의 값을 반환합니다. 이 함수는 각 아이템의 특정 속성에 따라 슬라이스를 정렬하고 싶을 때 유용합니다. 목록 13-7에서는 <code>Rectangle</code> 인스턴스 리스트가 있고, <code>sort_by_key</code>를 사용하여 <code>width</code> 속성에 따라 낮은 값에서 높은 값 순으로 정렬합니다:</p>
<Listing number="13-7" file-name="src/main.rs" caption="Using `sort_by_key` to order rectangles by width">
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    list.sort_by_key(|r| r.width);
    println!("{list:#?}");
}</code></pre></pre>
</Listing>
<p>이 코드는 다음을 출력합니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.41s
     Running `target/debug/rectangles`
[
    Rectangle {
        width: 3,
        height: 5,
    },
    Rectangle {
        width: 7,
        height: 12,
    },
    Rectangle {
        width: 10,
        height: 1,
    },
]
</code></pre>
<p><code>sort_by_key</code>가 <code>FnMut</code> 클로저를 받도록 정의된 이유는 슬라이스의 각 아이템에 대해 한 번씩, 즉 클로저를 여러 번 호출하기 때문입니다. <code>|r| r.width</code> 클로저는 환경에서 아무것도 캡처하거나, 변경하거나, 밖으로 이동시키지 않으므로 트레이트 바운드 요구사항을 충족합니다.</p>
<p>반면, 목록 13-8은 환경에서 값을 밖으로 이동시키기 때문에 <code>FnOnce</code> 트레이트만 구현하는 클로저의 예를 보여줍니다. 컴파일러는 우리가 이 클로저를 <code>sort_by_key</code>와 함께 사용하는 것을 허용하지 않을 것입니다:</p>
<Listing number="13-8" file-name="src/main.rs" caption="Attempting to use an `FnOnce` closure with `sort_by_key`">
<pre><code class="language-rust ignore does_not_compile">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut sort_operations = vec![];
    let value = String::from("클로저 호출됨");

    list.sort_by_key(|r| {
        sort_operations.push(value);
        r.width
    });
    println!("{list:#?}");
}</code></pre>
</Listing>
<p>이는 <code>list</code>를 정렬할 때 <code>sort_by_key</code>가 클로저를 몇 번 호출하는지 세어보려고 시도하는 부자연스럽고 복잡한(그리고 작동하지 않는) 방식입니다. 이 코드는 클로저 환경의 <code>String</code>인 <code>value</code>를 <code>sort_operations</code> 벡터에 푸시함으로써 횟수를 세려고 시도합니다. 클로저는 <code>value</code>를 캡처한 다음, <code>value</code>의 소유권을 <code>sort_operations</code> 벡터로 이전함으로써 <code>value</code>를 클로저 밖으로 이동시킵니다. 이 클로저는 한 번만 호출될 수 있습니다. 두 번째로 호출하려고 시도하면 <code>value</code>가 더 이상 환경에 존재하지 않아 <code>sort_operations</code>에 다시 푸시할 수 없기 때문입니다! 따라서 이 클로저는 <code>FnOnce</code>만 구현합니다. 이 코드를 컴파일하려고 하면, 클로저가 반드시 <code>FnMut</code>을 구현해야 하므로 <code>value</code>를 클로저 밖으로 이동시킬 수 없다는 다음과 같은 에러가 발생합니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
error[E0507]: cannot move out of `value`, a captured variable in an `FnMut` closure
  --&gt; src/main.rs:18:30
   |
15 |     let value = String::from("closure called");
   |         ----- captured outer variable
16 |
17 |     list.sort_by_key(|r| {
   |                      --- captured by this `FnMut` closure
18 |         sort_operations.push(value);
   |                              ^^^^^ move occurs because `value` has type `String`, which does not implement the `Copy` trait
   |
help: consider cloning the value if the performance cost is acceptable
   |
18 |         sort_operations.push(value.clone());
   |                                   ++++++++

For more information about this error, try `rustc --explain E0507`.
error: could not compile `rectangles` (bin "rectangles") due to 1 previous error
</code></pre>
<p>오류는 환경 밖으로 <code>value</code>를 이동시키는 클로저 본문의 라인을 가리킵니다. 이를 해결하려면 환경 밖으로 값을 이동시키지 않도록 클로저 본문을 변경해야 합니다. 클로저가 호출된 횟수를 세기 위해 환경에 카운터를 유지하고 클로저 본문에서 그 값을 증가시키는 것이 더 간단한 계산 방법입니다. 목록 13-9의 클로저는 <code>num_sort_operations</code> 카운터에 대한 가변 참조만 캡처하므로 <code>sort_by_key</code>와 함께 작동하며, 따라서 한 번 이상 호출될 수 있습니다:</p>
<Listing number="13-9" file-name="src/main.rs" caption="Using an `FnMut` closure with `sort_by_key` is allowed">
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut num_sort_operations = 0;
    list.sort_by_key(|r| {
        num_sort_operations += 1;
        r.width
    });
    println!("{list:#?}, {num_sort_operations}번의 연산으로 정렬됨");
}</code></pre></pre>
</Listing>
<p><code>Fn</code> 트레이트는 클로저를 사용하는 함수나 타입을 정의하거나 사용할 때 중요합니다. 다음 섹션에서는 반복자에 대해 논의하겠습니다. 많은 반복자 메서드들이 클로저를 인수로 받으므로, 앞으로 진행하면서 이러한 클로저의 세부 사항들을 기억해 두세요!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch13-00-functional-features.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch13-02-iterators.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch13-00-functional-features.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch13-02-iterators.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
