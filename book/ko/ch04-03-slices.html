<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>슬라이스 타입 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch04-03-slices.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch04-03-slices.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="슬라이스-타입"><a class="header" href="#슬라이스-타입">슬라이스 타입</a></h2>
<p><em>Slices</em> let you reference a contiguous sequence of elements in a <a href="ch08-00-common-collections.html">collection</a><!-- ignore -->. A slice is a kind of reference, so it does not have ownership.</p>
<p>Here’s a small programming problem: Write a function that takes a string of words separated by spaces and returns the first word it finds in that string. If the function doesn’t find a space in the string, the whole string must be one word, so the entire string should be returned.</p>
<blockquote>
<p>Note: For the purposes of introducing slices, we are assuming ASCII only in this section; a more thorough discussion of UTF-8 handling is in the <a href="ch08-02-strings.html#storing-utf-8-encoded-text-with-strings">“Storing UTF-8 Encoded Text with Strings”</a><!-- ignore --> section of Chapter 8.</p>
</blockquote>
<p>슬라이스가 해결할 문제를 이해하기 위해, 슬라이스를 사용하지 않고 이 함수의 시그니처를 어떻게 작성할지 살펴보겠습니다.</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; ?</code></pre>
<p>The <code>first_word</code> function has a parameter of type <code>&amp;String</code>. We don’t need ownership, so this is fine. (In idiomatic Rust, functions do not take ownership of their arguments unless they need to, and the reasons for that will become clear as we keep going.) But what should we return? We don’t really have a way to talk about <em>part</em> of a string. However, we could return the index of the end of the word, indicated by a space. Let’s try that, as shown in Listing 4-7.</p>
<Listing number="4-7" file-name="src/main.rs" caption="The `first_word` function that returns a byte index value into the `String` parameter">
<pre><pre class="playground"><code class="language-rust edition2024">fn first_word(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p><code>String</code>의 요소를 하나씩 훑으며 값이 공백인지 확인해야 하므로, <code>as_bytes</code> 메서드를 사용하여 <code>String</code>을 바이트 배열로 변환하겠습니다.</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span>    let bytes = s.as_bytes();
<span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>다음으로, <code>iter</code> 메서드를 사용하여 바이트 배열에 대한 반복자(iterator)를 생성합니다:</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span>    for (i, &amp;item) in bytes.iter().enumerate() {
<span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>반복자에 대해서는 <a href="ch13-02-iterators.html">13장</a><!-- ignore -->에서 더 자세히 다룰 것입니다. 지금은 <code>iter</code>가 컬렉션의 각 요소를 반환하는 메서드이며, <code>enumerate</code>가 <code>iter</code>의 결과를 감싸서 각 요소를 튜플의 일부로 반환한다는 점만 알아두세요. <code>enumerate</code>가 반환하는 튜플의 첫 번째 요소는 인덱스이고, 두 번째 요소는 해당 요소에 대한 참조입니다. 이는 우리가 직접 인덱스를 계산하는 것보다 조금 더 편리합니다.</p>
<p><code>enumerate</code> 메서드는 튜플을 반환하므로, 패턴을 사용하여 그 튜플을 해체(destructure)할 수 있습니다. 패턴에 대해서는 <a href="ch06-02-match.html#patterns-that-bind-to-values">6장</a><!-- ignore -->에서 더 자세히 논의할 것입니다. <code>for</code> 루프에서 튜플의 인덱스에 대해서는 <code>i</code>를, 튜플의 단일 바이트에 대해서는 <code>&amp;item</code>을 사용하는 패턴을 지정합니다. <code>.iter().enumerate()</code>로부터 요소에 대한 참조를 얻기 때문에, 패턴에서 <code>&amp;</code>를 사용합니다.</p>
<p><code>for</code> 루프 내부에서 바이트 리터럴 문법을 사용하여 공백을 나타내는 바이트를 찾습니다. 공백을 찾으면 해당 위치를 반환합니다. 그렇지 않으면 <code>s.len()</code>을 사용하여 문자열의 길이를 반환합니다.</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span>        if item == b' ' {
            return i;
        }
    }

    s.len()
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>이제 문자열에서 첫 번째 단어 끝의 인덱스를 찾아낼 수 있게 되었지만, 문제가 하나 있습니다. <code>usize</code>를 독자적으로 반환하고 있는데, 이 숫자는 <code>&amp;String</code>의 맥락 안에서만 의미가 있습니다. 즉, <code>String</code>과는 별개의 값이기 때문에 나중에도 이 인덱스가 유효할 것이라는 보장이 없습니다. 목록 4-7의 <code>first_word</code> 함수를 사용하는 목록 4-8의 프로그램을 살펴봅시다.</p>
<Listing number="4-8" file-name="src/main.rs" caption="Storing the result from calling the `first_word` function and then changing the `String` contents">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&amp;s); // word는 5라는 값을 갖게 됩니다

    s.clear(); // 이 코드는 String을 비워서 ""와 같게 만듭니다

    // word still has the value 5 here, but s no longer has any content that we
    // could meaningfully use with the value 5, so word is now totally invalid!
}</code></pre></pre>
</Listing>
<p>이 프로그램은 아무런 오류 없이 컴파일되며, <code>s.clear()</code>를 호출한 뒤에 <code>word</code>를 사용하더라도 마찬가지입니다. <code>word</code>는 <code>s</code>의 상태와 전혀 연결되어 있지 않기 때문에, <code>word</code>는 여전히 <code>5</code>라는 값을 담고 있습니다. 변수 <code>s</code>와 함께 이 <code>5</code>라는 값을 사용하여 첫 번째 단어를 추출해내려 할 수도 있겠지만, <code>word</code>에 <code>5</code>를 저장한 이후로 <code>s</code>의 내용이 바뀌었기 때문에 이는 버그가 될 것입니다.</p>
<p>Having to worry about the index in <code>word</code> getting out of sync with the data in <code>s</code> is tedious and error-prone! Managing these indices is even more brittle if we write a <code>second_word</code> function. Its signature would have to look like this:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; (usize, usize) {</code></pre>
<p>이제 우리는 시작 인덱스_와_ 끝 인덱스를 추적하게 되었고, 특정 상태의 데이터로부터 계산되었으면서도 그 상태에 전혀 묶여 있지 않은 값들이 더 많아졌습니다. 서로 동기화되어야 할 관련 없는 변수 세 개가 여기저기 떠다니게 된 것입니다.</p>
<p>다행히 러스트는 이 문제에 대한 해결책인 문자열 슬라이스를 가지고 있습니다.</p>
<h3 id="문자열-슬라이스"><a class="header" href="#문자열-슬라이스">문자열 슬라이스</a></h3>
<p>A <em>string slice</em> is a reference to a contiguous sequence of the elements of a <code>String</code>, and it looks like this:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let s = String::from("hello world");

    let hello = &amp;s[0..5];
    let world = &amp;s[6..11];
<span class="boring">}</span></code></pre></pre>
<p>Rather than a reference to the entire <code>String</code>, <code>hello</code> is a reference to a portion of the <code>String</code>, specified in the extra <code>[0..5]</code> bit. We create slices using a range within square brackets by specifying <code>[starting_index..ending_index]</code>, where <em><code>starting_index</code></em> is the first position in the slice and <em><code>ending_index</code></em> is one more than the last position in the slice. Internally, the slice data structure stores the starting position and the length of the slice, which corresponds to <em><code>ending_index</code></em> minus <em><code>starting_index</code></em>. So, in the case of <code>let world = &amp;s[6..11];</code>, <code>world</code> would be a slice that contains a pointer to the byte at index 6 of <code>s</code> with a length value of <code>5</code>.</p>
<p>그림 4-7은 이를 다이어그램으로 보여줍니다.</p>
<p><img alt="Three tables: a table representing the stack data of s, which points
to the byte at index 0 in a table of the string data &quot;hello world&quot; on
the heap. The third table represents the stack data of the slice world, which
has a length value of 5 and points to byte 6 of the heap data table."
src="img/trpl04-07.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figure 4-7: A string slice referring to part of a <code>String</code></span></p>
<p>러스트의 <code>..</code> 범위 구문을 사용하면, 인덱스 0에서 시작하고 싶을 때 두 개의 점 앞에 있는 값을 생략할 수 있습니다. 즉, 다음은 동일합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
<span class="boring">}</span></code></pre></pre>
<p>마찬가지로, 슬라이스에 <code>String</code>의 마지막 바이트가 포함되면, 뒤에 오는 숫자를 생략할 수 있습니다. 즉, 다음은 동일합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");

let len = s.len();

let slice = &amp;s[3..len];
let slice = &amp;s[3..];
<span class="boring">}</span></code></pre></pre>
<p>You can also drop both values to take a slice of the entire string. So, these are equal:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello");

let len = s.len();

let slice = &amp;s[0..len];
let slice = &amp;s[..];
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Note: String slice range indices must occur at valid UTF-8 character boundaries. If you attempt to create a string slice in the middle of a multibyte character, your program will exit with an error.</p>
</blockquote>
<p>이 모든 정보를 염두에 두고, <code>first_word</code>를 슬라이스를 반환하도록 다시 작성해 봅시다. "문자열 슬라이스"를 나타내는 타입은 <code>&amp;str</code>로 작성됩니다:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2024">fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p>목록 4-7에서 했던 것과 동일한 방식으로 공백의 첫 번째 발생을 찾아 단어 끝의 인덱스를 얻습니다. 공백을 찾으면 문자열의 시작과 공백의 인덱스를 시작 및 끝 인덱스로 사용하여 문자열 슬라이스를 반환합니다.</p>
<p>이제 <code>first_word</code>를 호출하면, 기본 데이터에 연결된 단일 값을 반환받습니다. 이 값은 슬라이스의 시작점에 대한 참조와 슬라이스 내 요소의 수로 구성됩니다.</p>
<p>슬라이스를 반환하는 것은 <code>second_word</code> 함수에서도 작동할 것입니다:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; &amp;str {</code></pre>
<p>We now have a straightforward API that’s much harder to mess up because the compiler will ensure that the references into the <code>String</code> remain valid. Remember the bug in the program in Listing 4-8, when we got the index to the end of the first word but then cleared the string so our index was invalid? That code was logically incorrect but didn’t show any immediate errors. The problems would show up later if we kept trying to use the first word index with an emptied string. Slices make this bug impossible and let us know much sooner that we have a problem with our code. Using the slice version of <code>first_word</code> will throw a compile-time error:</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn first_word(s: &amp;String) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&amp;s);

    s.clear(); // 오류!

    println!("첫 번째 단어는: {word}");
}</code></pre>
</Listing>
<p>다음은 컴파일러 오류입니다:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:18:5
   |
16 |     let word = first_word(&amp;s);
   |                           -- immutable borrow occurs here
17 |
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 |
20 |     println!("the first word is: {word}");
   |                                   ---- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` (bin "ownership") due to 1 previous error
</code></pre>
<p>빌림 규칙에서 기억하듯이, 어떤 것에 대한 불변 참조가 있다면 가변 참조도 가질 수 없습니다. <code>clear</code>는 <code>String</code>을 잘라내야 하므로 가변 참조를 얻어야 합니다. <code>clear</code> 호출 후의 <code>println!</code>은 <code>word</code>의 참조를 사용하므로, 불변 참조는 그 시점에도 활성화되어 있어야 합니다. 러스트는 <code>clear</code>의 가변 참조와 <code>word</code>의 불변 참조가 동시에 존재하는 것을 허용하지 않으며, 컴파일이 실패합니다. 러스트는 API를 사용하기 쉽게 만들었을 뿐만 아니라, 컴파일 타임에 전체 오류 클래스를 제거했습니다!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="string-literals-are-slices"></a></p>
<h4 id="슬라이스로서의-문자열-리터럴"><a class="header" href="#슬라이스로서의-문자열-리터럴">슬라이스로서의 문자열 리터럴</a></h4>
<p>문자열 리터럴이 바이너리 내부에 저장된다는 것을 기억하세요. 이제 슬라이스에 대해 알았으니, 문자열 리터럴을 제대로 이해할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = "헬로, 월드!";
<span class="boring">}</span></code></pre></pre>
<p>The type of <code>s</code> here is <code>&amp;str</code>: It’s a slice pointing to that specific point of the binary. This is also why string literals are immutable; <code>&amp;str</code> is an immutable reference.</p>
<h4 id="매개변수로서의-문자열-슬라이스"><a class="header" href="#매개변수로서의-문자열-슬라이스">매개변수로서의 문자열 슬라이스</a></h4>
<p>리터럴과 <code>String</code> 값의 슬라이스를 가져올 수 있다는 것을 알면 <code>first_word</code>에 대한 한 가지 개선점으로 이어지며, 그것은 바로 시그니처입니다:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; &amp;str {</code></pre>
<p>더 숙련된 러스트 개발자는 목록 4-9에 표시된 시그니처를 대신 작성할 것입니다. 왜냐하면 <code>&amp;String</code> 값과 <code>&amp;str</code> 값 모두에 동일한 함수를 사용할 수 있기 때문입니다.</p>
<Listing number="4-9" caption="Improving the `first_word` function by using a string slice for the type of the `s` parameter">
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
<span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from("hello world");
</span><span class="boring">
</span><span class="boring">    // `first_word`는 String의 슬라이스에 대해 작동합니다. 부분적이든 전체이든 상관없습니다.
</span><span class="boring">    let word = first_word(&amp;my_string[0..6]);
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">    // `first_word`는 String에 대한 참조에 대해서도 작동하며, 이는 String의
</span><span class="boring">    // 전체 슬라이스와 동일합니다.
</span><span class="boring">    let word = first_word(&amp;my_string);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = "hello world";
</span><span class="boring">
</span><span class="boring">    // `first_word`는 문자열 리터럴의 슬라이스에 대해 작동합니다. 부분적이든
</span><span class="boring">    // 전체이든 상관없습니다.
</span><span class="boring">    let word = first_word(&amp;my_string_literal[0..6]);
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // 문자열 리터럴은 이미 문자열 슬라이스이기 때문에,
</span><span class="boring">    // 슬라이스 구문 없이도 잘 작동합니다!
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}</span></code></pre>
</Listing>
<p>If we have a string slice, we can pass that directly. If we have a <code>String</code>, we can pass a slice of the <code>String</code> or a reference to the <code>String</code>. This flexibility takes advantage of deref coercions, a feature we will cover in the <a href="ch15-02-deref.html#using-deref-coercions-in-functions-and-methods">“Using Deref Coercions in Functions and Methods”</a><!--
ignore --> section of Chapter 15.</p>
<p>함수가 <code>String</code>에 대한 참조 대신 문자열 슬라이스를 받도록 정의하면, 기능을 전혀 잃지 않으면서도 API를 더 범용적이고 유용하게 만들 수 있습니다:</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn first_word(s: &amp;str) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let my_string = String::from("hello world");

    // `first_word`는 String의 슬라이스에 대해 작동합니다. 부분적이든 전체이든 상관없습니다.
    let word = first_word(&amp;my_string[0..6]);
    let word = first_word(&amp;my_string[..]);
    // `first_word`는 String에 대한 참조에 대해서도 작동하며, 이는 String의
    // 전체 슬라이스와 동일합니다.
    let word = first_word(&amp;my_string);

    let my_string_literal = "hello world";

    // `first_word`는 문자열 리터럴의 슬라이스에 대해 작동합니다. 부분적이든
    // 전체이든 상관없습니다.
    let word = first_word(&amp;my_string_literal[0..6]);
    let word = first_word(&amp;my_string_literal[..]);

    // 문자열 리터럴은 이미 문자열 슬라이스이기 때문에,
    // 슬라이스 구문 없이도 잘 작동합니다!
    let word = first_word(my_string_literal);
}</code></pre></pre>
</Listing>
<h3 id="다른-슬라이스들"><a class="header" href="#다른-슬라이스들">다른 슬라이스들</a></h3>
<p>문자열 슬라이스는 예상하셨겠지만 문자열에 특화되어 있습니다. 하지만 더 범용적인 슬라이스 타입도 있습니다. 다음 배열을 살펴보세요:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
<span class="boring">}</span></code></pre></pre>
<p>문자열의 일부를 참조하고 싶을 때와 마찬가지로, 배열의 일부를 참조하고 싶을 때가 있습니다. 다음과 같이 할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];

assert_eq!(slice, &amp;[2, 3]);
<span class="boring">}</span></code></pre></pre>
<p>이 슬라이스는 <code>&amp;[i32]</code> 타입을 갖습니다. 이는 첫 번째 요소에 대한 참조와 길이를 저장함으로써 문자열 슬라이스와 동일한 방식으로 작동합니다. 이런 종류의 슬라이스는 다른 모든 종류의 컬렉션에 대해서도 사용하게 될 것입니다. 8장에서 벡터를 다룰 때 이러한 컬렉션들에 대해 자세히 논의하겠습니다.</p>
<h2 id="요약"><a class="header" href="#요약">요약</a></h2>
<p>The concepts of ownership, borrowing, and slices ensure memory safety in Rust programs at compile time. The Rust language gives you control over your memory usage in the same way as other systems programming languages. But having the owner of data automatically clean up that data when the owner goes out of scope means you don’t have to write and debug extra code to get this control.</p>
<p>소유권은 러스트의 다른 많은 부분들이 작동하는 방식에 영향을 미치므로, 책의 나머지 부분에서도 이러한 개념들을 계속 이야기할 것입니다. 이제 5장으로 넘어가서 <code>struct</code>를 사용해 데이터 조각들을 그룹화하는 방법을 살펴보겠습니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch04-02-references-and-borrowing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch05-00-structs.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch04-02-references-and-borrowing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch05-00-structs.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
