<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Crates.io에 크레이트 게시하기 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch14-02-publishing-to-crates-io.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch14-02-publishing-to-crates-io.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="cratesio에-크레이트-게시하기"><a class="header" href="#cratesio에-크레이트-게시하기">Crates.io에 크레이트 게시하기</a></h2>
<p>지금까지 우리는 <a href="https://crates.io/">crates.io</a><!-- ignore -->의 패키지들을 프로젝트의 의존성으로 사용해 왔지만, 여러분의 패키지를 게시하여 다른 사람들과 코드를 공유할 수도 있습니다. <a href="https://crates.io/">crates.io</a><!-- ignore -->의 크레이트 레지스트리는 여러분 패키지의 소스 코드를 배포하므로, 주로 오픈 소스 코드를 호스팅합니다.지금까지 우리는 <a href="https://crates.io/">crates.io</a><!-- ignore -->의 패키지들을 프로젝트의 의존성으로 사용해 왔지만, 여러분의 패키지를 게시하여 다른 사람들과 코드를 공유할 수도 있습니다. <a href="https://crates.io/">crates.io</a><!-- ignore -->의 크레이트 레지스트리는 여러분 패키지의 소스 코드를 배포하므로, 주로 오픈 소스 코드를 호스팅합니다.</p>
<p>러스트와 Cargo에는 게시된 패키지를 사람들이 더 쉽게 찾고 사용할 수 있게 해주는 기능들이 있습니다. 다음으로 이러한 기능들 중 일부를 살펴보고, 패키지를 게시하는 방법을 설명하겠습니다.</p>
<h3 id="유용한-문서-주석-만들기"><a class="header" href="#유용한-문서-주석-만들기">유용한 문서 주석 만들기</a></h3>
<p>패키지를 정확하게 문서화하면 다른 사용자들이 언제 어떻게 패키지를 사용해야 하는지 알 수 있으므로, 문서를 작성하는 데 시간을 투자할 가치가 있습니다. 3장에서 우리는 두 개의 슬래시(<code>//</code>)를 사용하여 러스트 코드에 주석을 다는 방법을 논의했습니다. 러스트에는 HTML 문서를 생성해 주는 _문서 주석(documentation comment)_이라고 불리는 특별한 종류의 주석도 있습니다. 이 HTML은 여러분의 크레이트가 어떻게 _구현_되었는지가 아니라, 크레이트를 어떻게 _사용_하는지에 관심이 있는 프로그래머들을 위해 공개 API 항목들에 대한 문서 주석 내용을 보여줍니다.</p>
<p>문서 주석은 두 개의 슬래시 대신 세 개의 슬래시(<code>///</code>)를 사용하며, 텍스트 서식을 위한 마크다운(Markdown) 표기법을 지원합니다. 문서 주석은 해당 주석이 설명하는 항목 바로 앞에 배치합니다. 목록 14-1은 <code>my_crate</code>라는 이름의 크레이트에 있는 <code>add_one</code> 함수에 대한 문서 주석을 보여줍니다.</p>
<Listing number="14-1" file-name="src/lib.rs" caption="A documentation comment for a function">
<pre><code class="language-rust ignore">/// 주어진 숫자에 1을 더합니다.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}</code></pre>
</Listing>
<p>여기서는 <code>add_one</code> 함수가 무엇을 하는지에 대한 설명을 제공하고, <code>Examples</code>라는 제목의 섹션을 시작한 다음, <code>add_one</code> 함수를 어떻게 사용하는지 보여주는 코드를 제시했습니다. 이 문서 주석으로부터 <code>cargo doc</code>을 실행하여 HTML 문서를 생성할 수 있습니다. 이 명령은 러스트와 함께 배포되는 <code>rustdoc</code> 도구를 실행하고, 생성된 HTML 문서를 <em>target/doc</em> 디렉토리에 넣습니다.</p>
<p>For convenience, running <code>cargo doc --open</code> will build the HTML for your current crate’s documentation (as well as the documentation for all of your crate’s dependencies) and open the result in a web browser. Navigate to the <code>add_one</code> function and you’ll see how the text in the documentation comments is rendered, as shown in Figure 14-1.</p>
<img alt="Rendered HTML documentation for the `add_one` function of `my_crate`" src="img/trpl14-01.png" class="center" />
<p><span class="caption">Figure 14-1: The HTML documentation for the <code>add_one</code> function</span></p>
<h4 id="자주-사용되는-섹션들"><a class="header" href="#자주-사용되는-섹션들">자주 사용되는 섹션들</a></h4>
<p>목록 14-1에서는 <code># Examples</code> 마크다운 헤더를 사용하여 HTML에 “Examples”라는 제목의 섹션을 만들었습니다. 다음은 크레이트 작성자들이 문서에서 자주 사용하는 다른 섹션들입니다:</p>
<ul>
<li><strong>Panics</strong>: These are the scenarios in which the function being documented could panic. Callers of the function who don’t want their programs to panic should make sure they don’t call the function in these situations.</li>
<li><strong>Errors</strong>: If the function returns a <code>Result</code>, describing the kinds of errors that might occur and what conditions might cause those errors to be returned can be helpful to callers so that they can write code to handle the different kinds of errors in different ways.</li>
<li><strong>Safety</strong>: 만약 함수가 호출하기에 <code>unsafe</code>하다면(20장에서 안전하지 않음에 대해 다룹니다), 왜 함수가 안전하지 않은지 설명하고 호출자가 준수해야 할 불변성(invariants)을 다루는 섹션이 있어야 합니다.</li>
</ul>
<p>대부분의 문서 주석에 이 모든 섹션이 필요한 것은 아니지만, 이는 사용자들이 여러분의 코드에 대해 알고 싶어 할 만한 측면들을 상기시켜 주는 좋은 체크리스트가 됩니다.</p>
<h4 id="테스트로서의-문서-주석"><a class="header" href="#테스트로서의-문서-주석">테스트로서의 문서 주석</a></h4>
<p>Adding example code blocks in your documentation comments can help demonstrate how to use your library and has an additional bonus: Running <code>cargo test</code> will run the code examples in your documentation as tests! Nothing is better than documentation with examples. But nothing is worse than examples that don’t work because the code has changed since the documentation was written. If we run <code>cargo test</code> with the documentation for the <code>add_one</code> function from Listing 14-1, we will see a section in the test results that looks like this:</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-01/
cargo test
copy just the doc-tests section below
-->
<pre><code class="language-text">   Doc-tests my_crate

running 1 test
test src/lib.rs - add_one (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.27s
</code></pre>
<p>Now, if we change either the function or the example so that the <code>assert_eq!</code> in the example panics, and run <code>cargo test</code> again, we’ll see that the doc tests catch that the example and the code are out of sync with each other!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="commenting-contained-items"></a></p>
<h4 id="contained-item-comments"><a class="header" href="#contained-item-comments">Contained Item Comments</a></h4>
<p>The style of doc comment <code>//!</code> adds documentation to the item that <em>contains</em> the comments rather than to the items <em>following</em> the comments. We typically use these doc comments inside the crate root file (<em>src/lib.rs</em> by convention) or inside a module to document the crate or the module as a whole.</p>
<p>For example, to add documentation that describes the purpose of the <code>my_crate</code> crate that contains the <code>add_one</code> function, we add documentation comments that start with <code>//!</code> to the beginning of the <em>src/lib.rs</em> file, as shown in Listing 14-2.</p>
<Listing number="14-2" file-name="src/lib.rs" caption="The documentation for the `my_crate` crate as a whole">
<pre><code class="language-rust ignore">//! # My Crate
//!
//! `my_crate`는 특정 계산을 더 편리하게 수행할 수 있게 해주는
//! 유틸리티 모음입니다.

/// 주어진 숫자에 1을 더합니다.
// --snip--
<span class="boring">///
</span><span class="boring">/// # Examples
</span><span class="boring">///
</span><span class="boring">/// ```
</span><span class="boring">/// let arg = 5;
</span><span class="boring">/// let answer = my_crate::add_one(arg);
</span><span class="boring">///
</span><span class="boring">/// assert_eq!(6, answer);
</span><span class="boring">/// ```
</span><span class="boring">pub fn add_one(x: i32) -&gt; i32 {
</span><span class="boring">    x + 1
</span><span class="boring">}</span></code></pre>
</Listing>
<p><code>//!</code>로 시작하는 마지막 줄 뒤에 코드가 전혀 없다는 점에 주목하세요. <code>///</code> 대신 <code>//!</code>로 주석을 시작했기 때문에, 주석 뒤에 오는 항목이 아니라 이 주석을 포함하는 항목을 문서화하고 있습니다. 이 경우 그 항목은 크레이트 루트인 <em>src/lib.rs</em> 파일입니다. 이 주석들은 크레이트 전체를 설명합니다.</p>
<p>When we run <code>cargo doc --open</code>, these comments will display on the front page of the documentation for <code>my_crate</code> above the list of public items in the crate, as shown in Figure 14-2.</p>
<p>항목 내의 문서 주석은 특히 크레이트와 모듈을 설명하는 데 유용합니다. 컨테이너의 전반적인 목적을 설명하여 사용자가 크레이트의 구성을 이해하는 데 도움을 주기 위해 사용하세요.</p>
<img alt="Rendered HTML documentation with a comment for the crate as a whole" src="img/trpl14-02.png" class="center" />
<p><span class="caption">Figure 14-2: The rendered documentation for <code>my_crate</code>, including the comment describing the crate as a whole</span></p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="exporting-a-convenient-public-api-with-pub-use"></a></p>
<h3 id="exporting-a-convenient-public-api"><a class="header" href="#exporting-a-convenient-public-api">Exporting a Convenient Public API</a></h3>
<p>공개 API의 구조는 크레이트를 게시할 때 주요 고려 사항 중 하나입니다. 여러분의 크레이트를 사용하는 사람들은 여러분보다 구조에 익숙하지 않으며, 크레이트의 모듈 계층 구조가 크다면 원하는 부분을 찾는 데 어려움을 겪을 수 있습니다.</p>
<p>In Chapter 7, we covered how to make items public using the <code>pub</code> keyword, and how to bring items into a scope with the <code>use</code> keyword. However, the structure that makes sense to you while you’re developing a crate might not be very convenient for your users. You might want to organize your structs in a hierarchy containing multiple levels, but then people who want to use a type you’ve defined deep in the hierarchy might have trouble finding out that type exists. They might also be annoyed at having to enter <code>use my_crate::some_module::another_module::UsefulType;</code> rather than <code>use my_crate::UsefulType;</code>.</p>
<p>The good news is that if the structure <em>isn’t</em> convenient for others to use from another library, you don’t have to rearrange your internal organization: Instead, you can re-export items to make a public structure that’s different from your private structure by using <code>pub use</code>. <em>Re-exporting</em> takes a public item in one location and makes it public in another location, as if it were defined in the other location instead.</p>
<p>For example, say we made a library named <code>art</code> for modeling artistic concepts. Within this library are two modules: a <code>kinds</code> module containing two enums named <code>PrimaryColor</code> and <code>SecondaryColor</code> and a <code>utils</code> module containing a function named <code>mix</code>, as shown in Listing 14-3.</p>
<Listing number="14-3" file-name="src/lib.rs" caption="An `art` library with items organized into `kinds` and `utils` modules">
<pre><code class="language-rust noplayground test_harness">//! # Art
//!
//! 예술적 개념을 모델링하기 위한 라이브러리입니다.

pub mod kinds {
    /// RYB 색상 모델에 따른 1차색.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// RYB 색상 모델에 따른 2차색.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use crate::kinds::*;

    /// 두 가지 1차색을 동일한 양으로 혼합하여
    /// 2차색을 만듭니다.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
        // --생략--
<span class="boring">        unimplemented!();
</span>    }
}</code></pre>
</Listing>
<p>Figure 14-3 shows what the front page of the documentation for this crate generated by <code>cargo doc</code> would look like.</p>
<img alt="Rendered documentation for the `art` crate that lists the `kinds` and `utils` modules" src="img/trpl14-03.png" class="center" />
<p><span class="caption">Figure 14-3: The front page of the documentation for <code>art</code> that lists the <code>kinds</code> and <code>utils</code> modules</span></p>
<p><code>PrimaryColor</code>와 <code>SecondaryColor</code> 타입뿐만 아니라 <code>mix</code> 함수도 메인 페이지에 나열되지 않는다는 점에 유의하세요. 이들을 보려면 <code>kinds</code>와 <code>utils</code>를 클릭해야 합니다.</p>
<p>Another crate that depends on this library would need <code>use</code> statements that bring the items from <code>art</code> into scope, specifying the module structure that’s currently defined. Listing 14-4 shows an example of a crate that uses the <code>PrimaryColor</code> and <code>mix</code> items from the <code>art</code> crate.</p>
<Listing number="14-4" file-name="src/main.rs" caption="A crate using the `art` crate’s items with its internal structure exported">
<pre><code class="language-rust ignore">use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}</code></pre>
</Listing>
<p>목록 14-4의 코드를 작성한 사람은 <code>art</code> 크레이트를 사용하기 위해 <code>PrimaryColor</code>가 <code>kinds</code> 모듈에 있고 <code>mix</code>가 <code>utils</code> 모듈에 있다는 것을 알아내야 했습니다. <code>art</code> 크레이트의 모듈 구조는 이 크레이트를 사용하는 사람보다 개발하는 사람에게 더 관련이 있습니다. 이러한 내부 구조는 <code>art</code> 크레이트를 어떻게 사용하는지 이해하려는 사람에게는 유용한 정보를 제공하지 않으며, 오히려 어디를 찾아야 할지 알아내야 하고 <code>use</code> 구문에 모듈 이름을 명시해야 하므로 혼란을 야기합니다.</p>
<p>To remove the internal organization from the public API, we can modify the <code>art</code> crate code in Listing 14-3 to add <code>pub use</code> statements to re-export the items at the top level, as shown in Listing 14-5.</p>
<Listing number="14-5" file-name="src/lib.rs" caption="Adding `pub use` statements to re-export items">
<pre><code class="language-rust ignore">//! # Art
//!
//! 예술적 개념을 모델링하기 위한 라이브러리입니다.

pub use self::kinds::PrimaryColor;
pub use self::kinds::SecondaryColor;
pub use self::utils::mix;

pub mod kinds {
    // --생략--
<span class="boring">    /// RYB 색상 모델에 따른 1차색.
</span><span class="boring">    pub enum PrimaryColor {
</span><span class="boring">        Red,
</span><span class="boring">        Yellow,
</span><span class="boring">        Blue,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// RYB 색상 모델에 따른 2차색.
</span><span class="boring">    pub enum SecondaryColor {
</span><span class="boring">        Orange,
</span><span class="boring">        Green,
</span><span class="boring">        Purple,
</span><span class="boring">    }
</span>}

pub mod utils {
    // --생략--
<span class="boring">    use crate::kinds::*;
</span><span class="boring">
</span><span class="boring">    /// 두 가지 1차색을 동일한 양으로 혼합하여
</span><span class="boring">    /// 2차색을 만듭니다.
</span><span class="boring">    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
</span><span class="boring">        SecondaryColor::Orange
</span><span class="boring">    }
</span>}</code></pre>
</Listing>
<p><code>cargo doc</code>이 생성하는 이 크레이트의 API 문서는 이제 그림 14-4와 같이 메인 페이지에 다시 내보낸 항목들을 나열하고 링크를 제공하므로, <code>PrimaryColor</code>, <code>SecondaryColor</code> 타입과 <code>mix</code> 함수를 더 쉽게 찾을 수 있습니다.</p>
<img alt="Rendered documentation for the `art` crate with the re-exports on the front page" src="img/trpl14-04.png" class="center" />
<p><span class="caption">그림 14-4: 다시 내보낸 항목들이 나열된 <code>art</code> 문서의 메인 페이지</span></p>
<p>The <code>art</code> crate users can still see and use the internal structure from Listing 14-3 as demonstrated in Listing 14-4, or they can use the more convenient structure in Listing 14-5, as shown in Listing 14-6.</p>
<Listing number="14-6" file-name="src/main.rs" caption="A program using the re-exported items from the `art` crate">
<pre><code class="language-rust ignore">use art::PrimaryColor;
use art::mix;

fn main() {
    // --생략--
<span class="boring">    let red = PrimaryColor::Red;
</span><span class="boring">    let yellow = PrimaryColor::Yellow;
</span><span class="boring">    mix(red, yellow);
</span>}</code></pre>
</Listing>
<p>모듈이 깊게 중첩된 경우, <code>pub use</code>를 사용하여 최상위 수준에서 타입을 다시 내보내는 것은 크레이트 사용자들의 경험에 큰 차이를 만들 수 있습니다. <code>pub use</code>의 또 다른 일반적인 용도는 현재 크레이트의 의존성 정의를 다시 내보내어 해당 크레이트의 정의를 여러분 크레이트의 공개 API의 일부로 만드는 것입니다.</p>
<p>Creating a useful public API structure is more an art than a science, and you can iterate to find the API that works best for your users. Choosing <code>pub use</code> gives you flexibility in how you structure your crate internally and decouples that internal structure from what you present to your users. Look at some of the code of crates you’ve installed to see if their internal structure differs from their public API.</p>
<h3 id="cratesio-계정-설정하기"><a class="header" href="#cratesio-계정-설정하기">Crates.io 계정 설정하기</a></h3>
<p>Before you can publish any crates, you need to create an account on <a href="https://crates.io/">crates.io</a><!-- ignore --> and get an API token. To do so, visit the home page at <a href="https://crates.io/">crates.io</a><!-- ignore --> and log in via a GitHub account. (The GitHub account is currently a requirement, but the site might support other ways of creating an account in the future.) Once you’re logged in, visit your account settings at <a href="https://crates.io/me/">https://crates.io/me/</a><!-- ignore --> and retrieve your API key. Then, run the <code>cargo login</code> command and paste your API key when prompted, like this:</p>
<pre><code class="language-console">$ cargo login
abcdefghijklmnopqrstuvwxyz012345
</code></pre>
<p>This command will inform Cargo of your API token and store it locally in <em>~/.cargo/credentials.toml</em>. Note that this token is a secret: Do not share it with anyone else. If you do share it with anyone for any reason, you should revoke it and generate a new token on <a href="https://crates.io/">crates.io</a><!-- ignore
-->.</p>
<h3 id="새-크레이트에-메타데이터-추가하기"><a class="header" href="#새-크레이트에-메타데이터-추가하기">새 크레이트에 메타데이터 추가하기</a></h3>
<p>게시하고 싶은 크레이트가 있다고 가정해 봅시다. 게시하기 전에, 크레이트의 <em>Cargo.toml</em> 파일에 있는 <code>[package]</code> 섹션에 몇 가지 메타데이터를 추가해야 합니다.</p>
<p>크레이트에는 고유한 이름이 필요합니다. 로컬에서 크레이트를 작업하는 동안에는 원하는 이름을 자유롭게 지을 수 있습니다. 하지만 <a href="https://crates.io/">crates.io</a><!-- ignore -->의 크레이트 이름은 선착순으로 할당됩니다. 누군가 이름을 사용 중이라면 다른 누구도 그 이름으로 크레이트를 게시할 수 없습니다. 크레이트 게시를 시도하기 전에 사용하려는 이름을 검색해 보세요. 만약 이름이 이미 사용 중이라면, 다른 이름을 찾아 <em>Cargo.toml</em> 파일의 <code>[package]</code> 섹션 아래에 있는 <code>name</code> 필드를 다음과 같이 새로운 이름으로 수정해야 합니다:</p>
<p><span class="filename">파일명: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
</code></pre>
<p>고유한 이름을 선택했더라도, 이 시점에서 크레이트를 게시하기 위해 <code>cargo publish</code>를 실행하면 경고와 함께 오류가 발생할 것입니다:</p>
<!-- manual-regeneration
Create a new package with an unregistered name, making no further modifications
  to the generated package, so it is missing the description and license fields.
cargo publish
copy just the relevant lines below
-->
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
warning: manifest has no description, license, license-file, documentation, homepage or repository.
See https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata for more info.
--snip--
error: failed to publish to registry at https://crates.io

Caused by:
  the remote server responded with an error (status 400 Bad Request): missing or empty metadata fields: description, license. Please see https://doc.rust-lang.org/cargo/reference/manifest.html for more information on configuring these fields
</code></pre>
<p>This results in an error because you’re missing some crucial information: A description and license are required so that people will know what your crate does and under what terms they can use it. In <em>Cargo.toml</em>, add a description that's just a sentence or two, because it will appear with your crate in search results. For the <code>license</code> field, you need to give a <em>license identifier value</em>. The <a href="https://spdx.org/licenses/">Linux Foundation’s Software Package Data Exchange (SPDX)</a> lists the identifiers you can use for this value. For example, to specify that you’ve licensed your crate using the MIT License, add the <code>MIT</code> identifier:</p>
<p><span class="filename">파일명: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
license = "MIT"
</code></pre>
<p>SPDX에 나타나지 않는 라이선스를 사용하고 싶다면, 해당 라이선스의 텍스트를 파일에 담아 프로젝트에 포함시킨 뒤, <code>license</code> 키 대신 <code>license-file</code>을 사용하여 그 파일의 이름을 지정해야 합니다.</p>
<p>여러분의 프로젝트에 어떤 라이선스가 적합한지에 대한 안내는 이 책의 범위를 벗어납니다. 러스트 커뮤니티의 많은 사람들은 <code>MIT OR Apache-2.0</code>의 이중 라이선스를 사용하여 러스트와 동일한 방식으로 프로젝트 라이선스를 지정합니다. 이러한 관행은 <code>OR</code>로 구분된 여러 라이선스 식별자를 지정하여 프로젝트에 대해 여러 라이선스를 가질 수 있음을 보여줍니다.</p>
<p>고유한 이름, 버전, 설명, 그리고 라이선스가 추가된, 게시 준비가 완료된 프로젝트의 <em>Cargo.toml</em> 파일은 다음과 같은 모습일 것입니다:</p>
<p><span class="filename">파일명: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
version = "0.1.0"
edition = "2024"
description = "A fun game where you guess what number the computer has chosen."
license = "MIT OR Apache-2.0"

[dependencies]
</code></pre>
<p><a href="https://doc.rust-lang.org/cargo/">Cargo’s documentation</a> describes other metadata you can specify to ensure that others can discover and use your crate more easily.</p>
<h3 id="cratesio에-게시하기"><a class="header" href="#cratesio에-게시하기">Crates.io에 게시하기</a></h3>
<p>계정을 만들고, API 토큰을 저장하고, 크레이트 이름을 선택하고, 필수 메타데이터까지 지정했다면 이제 게시할 준비가 되었습니다! 크레이트를 게시하면 다른 사람들이 사용할 수 있도록 특정 버전이 <a href="https://crates.io/">crates.io</a><!-- ignore -->에 업로드됩니다.</p>
<p>Be careful, because a publish is <em>permanent</em>. The version can never be overwritten, and the code cannot be deleted except in certain circumstances. One major goal of Crates.io is to act as a permanent archive of code so that builds of all projects that depend on crates from <a href="https://crates.io/">crates.io</a><!-- ignore --> will continue to work. Allowing version deletions would make fulfilling that goal impossible. However, there is no limit to the number of crate versions you can publish.</p>
<p><code>cargo publish</code> 명령을 다시 실행해 보세요. 이제 성공할 것입니다:</p>
<!-- manual-regeneration
go to some valid crate, publish a new version
cargo publish
copy just the relevant lines below
-->
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
   Packaging guessing_game v0.1.0 (file:///projects/guessing_game)
    Packaged 6 files, 1.2KiB (895.0B compressed)
   Verifying guessing_game v0.1.0 (file:///projects/guessing_game)
   Compiling guessing_game v0.1.0
(file:///projects/guessing_game/target/package/guessing_game-0.1.0)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.19s
   Uploading guessing_game v0.1.0 (file:///projects/guessing_game)
    Uploaded guessing_game v0.1.0 to registry `crates-io`
note: waiting for `guessing_game v0.1.0` to be available at registry
`crates-io`.
You may press ctrl-c to skip waiting; the crate should be available shortly.
   Published guessing_game v0.1.0 at registry `crates-io`
</code></pre>
<p>축하합니다! 이제 여러분의 코드를 러스트 커뮤니티와 공유했으며, 누구든지 자신의 프로젝트에 여러분의 크레이트를 의존성으로 쉽게 추가할 수 있습니다.</p>
<h3 id="기존-크레이트의-새로운-버전-게시하기"><a class="header" href="#기존-크레이트의-새로운-버전-게시하기">기존 크레이트의 새로운 버전 게시하기</a></h3>
<p>When you’ve made changes to your crate and are ready to release a new version, you change the <code>version</code> value specified in your <em>Cargo.toml</em> file and republish. Use the <a href="https://semver.org/">Semantic Versioning rules</a> to decide what an appropriate next version number is, based on the kinds of changes you’ve made. Then, run <code>cargo publish</code> to upload the new version.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="removing-versions-from-cratesio-with-cargo-yank"></a> <a id="deprecating-versions-from-cratesio-with-cargo-yank"></a></p>
<h3 id="deprecating-versions-from-cratesio"><a class="header" href="#deprecating-versions-from-cratesio">Deprecating Versions from Crates.io</a></h3>
<p>Although you can’t remove previous versions of a crate, you can prevent any future projects from adding them as a new dependency. This is useful when a crate version is broken for one reason or another. In such situations, Cargo supports yanking a crate version.</p>
<p><em>Yanking</em> a version prevents new projects from depending on that version while allowing all existing projects that depend on it to continue. Essentially, a yank means that all projects with a <em>Cargo.lock</em> will not break, and any future <em>Cargo.lock</em> files generated will not use the yanked version.</p>
<p>To yank a version of a crate, in the directory of the crate that you’ve previously published, run <code>cargo yank</code> and specify which version you want to yank. For example, if we’ve published a crate named <code>guessing_game</code> version 1.0.1 and we want to yank it, then we’d run the following in the project directory for <code>guessing_game</code>:</p>
<!-- manual-regeneration:
cargo yank carol-test --version 2.1.0
cargo yank carol-test --version 2.1.0 --undo
-->
<pre><code class="language-console">$ cargo yank --vers 1.0.1
    Updating crates.io index
        Yank guessing_game@1.0.1
</code></pre>
<p>명령어에 <code>--undo</code>를 추가하면 yank를 취소하고 프로젝트들이 다시 해당 버전에 의존할 수 있도록 허용할 수도 있습니다:</p>
<pre><code class="language-console">$ cargo yank --vers 1.0.1 --undo
    Updating crates.io index
      Unyank guessing_game@1.0.1
</code></pre>
<p>yank는 코드를 삭제하지 <em>않습니다</em>. 예를 들어, 실수로 업로드된 비밀 정보를 삭제할 수 없습니다. 만약 그런 일이 발생한다면, 즉시 해당 비밀 정보를 재설정해야 합니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch14-01-release-profiles.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch14-03-cargo-workspaces.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch14-01-release-profiles.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch14-03-cargo-workspaces.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
