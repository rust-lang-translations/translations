<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>고급 트레이트 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch20-02-advanced-traits.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch20-02-advanced-traits.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="고급-트레이트"><a class="header" href="#고급-트레이트">고급 트레이트</a></h2>
<p>트레이트는 10장의 <a href="ch10-02-traits.html#traits-defining-shared-behavior">“트레이트: 공유 동작 정의하기”</a><!-- ignore -->에서 처음 다루었지만, 더 고급 세부 사항에 대해서는 논의하지 않았습니다. 이제 러스트에 대해 더 많이 알게 되었으므로, 핵심적인 내용을 다룰 수 있습니다.</p>
<h3 id="연관-타입을-사용하여-트레이트-정의에서-자리표시자-타입-지정하기"><a class="header" href="#연관-타입을-사용하여-트레이트-정의에서-자리표시자-타입-지정하기">연관 타입을 사용하여 트레이트 정의에서 자리표시자 타입 지정하기</a></h3>
<p>_연관 타입(Associated types)_은 타입 자리표시자를 트레이트와 연결하여 트레이트 메서드 정의가 시그니처에서 이러한 자리표시자 타입을 사용할 수 있게 합니다. 트레이트 구현자는 특정 구현에서 자리표시자 타입 대신 사용될 구체적인 타입을 지정하게 됩니다. 이런 방식으로 트레이트가 구현될 때까지 해당 타입들이 정확히 무엇인지 알 필요 없이 일부 타입을 사용하는 트레이트를 정의할 수 있습니다.</p>
<p>우리는 이 장의 대부분의 고급 기능들이 거의 필요하지 않다고 설명했습니다. 연관 타입은 그 중간 어디쯤에 있습니다. 책의 나머지 부분에서 설명한 기능들보다는 덜 사용되지만, 이 장에서 논의된 다른 많은 기능들보다는 더 흔히 사용됩니다.</p>
<p>연관 타입이 있는 트레이트의 한 예는 표준 라이브러리에서 제공하는 <code>Iterator</code> 트레이트입니다. 연관 타입의 이름은 <code>Item</code>이며, <code>Iterator</code> 트레이트를 구현하는 타입이 반복하고 있는 값들의 타입을 대신합니다. <code>Iterator</code> 트레이트의 정의는 예제 20-13과 같습니다.</p>
<Listing number="20-13" caption="The definition of the `Iterator` trait that has an associated type `Item`">
<pre><code class="language-rust noplayground">pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}</code></pre>
</Listing>
<p><code>Item</code> 타입은 자리표시자이며, <code>next</code> 메서드의 정의는 이것이 <code>Option&lt;Self::Item&gt;</code> 타입의 값을 반환할 것임을 보여줍니다. <code>Iterator</code> 트레이트 구현자는 <code>Item</code>에 대한 구체적인 타입을 지정할 것이고, <code>next</code> 메서드는 해당 구체적인 타입의 값을 포함하는 <code>Option</code>을 반환할 것입니다.</p>
<p>연관 타입은 제네릭과 유사한 개념처럼 보일 수 있는데, 제네릭 또한 처리할 타입을 지정하지 않고 함수를 정의할 수 있게 해주기 때문입니다. 두 개념의 차이점을 살펴보기 위해, <code>Item</code> 타입을 <code>u32</code>로 지정하는 <code>Counter</code> 타입에 대한 <code>Iterator</code> 트레이트 구현을 살펴보겠습니다.</p>
<Listing file-name="src/lib.rs">
<pre><code class="language-rust ignore"><span class="boring">struct Counter {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Counter {
</span><span class="boring">    fn new() -&gt; Counter {
</span><span class="boring">        Counter { count: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // --생략--
<span class="boring">        if self.count &lt; 5 {
</span><span class="boring">            self.count += 1;
</span><span class="boring">            Some(self.count)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>이 문법은 제네릭의 문법과 비슷해 보입니다. 그렇다면 왜 예제 20-14와 같이 제네릭을 사용하여 <code>Iterator</code> 트레이트를 정의하지 않을까요?</p>
<Listing number="20-14" caption="A hypothetical definition of the `Iterator` trait using generics">
<pre><code class="language-rust noplayground">pub trait Iterator&lt;T&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;
}</code></pre>
</Listing>
<p>차이점은 예제 20-14처럼 제네릭을 사용할 경우 각 구현에서 타입을 명시해야 한다는 점입니다. <code>Iterator&lt;String&gt; for Counter</code>나 다른 어떤 타입에 대해서도 구현할 수 있기 때문에, <code>Counter</code>에 대해 여러 개의 <code>Iterator</code> 구현을 가질 수 있습니다. 다시 말해, 트레이트에 제네릭 파라미터가 있으면 매번 제네릭 타입 파라미터의 구체적인 타입을 바꾸어가며 한 타입에 대해 여러 번 구현할 수 있습니다. 우리가 <code>Counter</code>에서 <code>next</code> 메서드를 사용할 때, 어떤 <code>Iterator</code> 구현을 사용하고 싶은지 나타내기 위해 타입 어노테이션을 제공해야 할 것입니다.</p>
<p>연관 타입을 사용하면 트레이트를 한 타입에 대해 여러 번 구현할 수 없기 때문에 타입 어노테이션을 달 필요가 없습니다. 연관 타입을 사용하는 예제 20-13의 정의에서는 <code>impl Iterator for Counter</code>가 단 하나만 존재할 수 있기 때문에 <code>Item</code>의 타입을 단 한 번만 선택할 수 있습니다. 따라서 <code>Counter</code>에서 <code>next</code>를 호출하는 어디에서도 <code>u32</code> 값에 대한 반복자를 원한다고 명시할 필요가 없습니다.</p>
<p>연관 타입은 또한 트레이트 계약의 일부가 됩니다. 트레이트 구현자는 연관 타입 자리표시자를 대신할 타입을 반드시 제공해야 합니다. 연관 타입은 종종 해당 타입이 어떻게 사용될지를 설명하는 이름을 가지며, API 문서에서 연관 타입을 문서화하는 것은 좋은 관례입니다.</p>
<h3 id="기본-제네릭-타입-파라미터와-연산자-오버로딩"><a class="header" href="#기본-제네릭-타입-파라미터와-연산자-오버로딩">기본 제네릭 타입 파라미터와 연산자 오버로딩</a></h3>
<p>When we use generic type parameters, we can specify a default concrete type for the generic type. This eliminates the need for implementors of the trait to specify a concrete type if the default type works. You specify a default type when declaring a generic type with the <code>&lt;PlaceholderType=ConcreteType&gt;</code> syntax.</p>
<p>이 기술이 유용한 상황의 좋은 예는 특정 상황에서 연산자(예: <code>+</code>)의 동작을 커스터마이징하는 _연산자 오버로딩(operator overloading)_입니다.</p>
<p>러스트는 여러분만의 연산자를 만들거나 임의의 연산자를 오버로딩하는 것을 허용하지 않습니다. 하지만 연산자와 관련된 트레이트를 구현함으로써 <code>std::ops</code>에 나열된 연산들과 그에 대응하는 트레이트들을 오버로딩할 수 있습니다. 예를 들어, 예제 20-15에서는 <code>+</code> 연산자를 오버로딩하여 두 <code>Point</code> 인스턴스를 더합니다. 우리는 이를 <code>Point</code> 구조체에 <code>Add</code> 트레이트를 구현함으로써 수행합니다.</p>
<Listing number="20-15" file-name="src/main.rs" caption="Implementing the `Add` trait to overload the `+` operator for `Point` instances">
<pre><pre class="playground"><code class="language-rust edition2021">use std::ops::Add;

#[derive(Debug, Copy, Clone, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(
        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
        Point { x: 3, y: 3 }
    );
}</code></pre></pre>
</Listing>
<p><code>add</code> 메서드는 두 <code>Point</code> 인스턴스의 <code>x</code> 값들을 더하고 두 <code>Point</code> 인스턴스의 <code>y</code> 값들을 더해 새로운 <code>Point</code>를 생성합니다. <code>Add</code> 트레이트에는 <code>add</code> 메서드에서 반환되는 타입을 결정하는 <code>Output</code>이라는 연관 타입이 있습니다.</p>
<p>이 코드의 기본 제네릭 타입은 <code>Add</code> 트레이트 내에 있습니다. 다음은 그 정의입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Add&lt;Rhs=Self&gt; {
    type Output;

    fn add(self, rhs: Rhs) -&gt; Self::Output;
}
<span class="boring">}</span></code></pre></pre>
<p>이 코드는 일반적으로 익숙해 보일 것입니다. 하나의 메서드와 하나의 연관 타입을 가진 트레이트입니다. 새로운 부분은 <code>Rhs=Self</code>입니다. 이 문법은 _기본 타입 파라미터(default type parameters)_라고 불립니다. <code>Rhs</code> 제네릭 타입 파라미터(“right hand side”의 약자)는 <code>add</code> 메서드의 <code>rhs</code> 파라미터 타입을 정의합니다. <code>Add</code> 트레이트를 구현할 때 <code>Rhs</code>에 대한 구체 타입을 지정하지 않으면, <code>Rhs</code> 타입은 기본적으로 <code>Self</code>가 되며, 이는 우리가 <code>Add</code>를 구현하고 있는 타입이 될 것입니다.</p>
<p><code>Point</code>에 대해 <code>Add</code>를 구현할 때, 두 <code>Point</code> 인스턴스를 더하고 싶었기 때문에 <code>Rhs</code>에 대해 기본값을 사용했습니다. 이제 기본값을 사용하는 대신 <code>Rhs</code> 타입을 커스터마이징하고 싶은 경우의 <code>Add</code> 트레이트 구현 예를 살펴보겠습니다.</p>
<p>서로 다른 단위의 값을 저장하는 <code>Millimeters</code>와 <code>Meters</code>라는 두 구조체가 있습니다. 기존 타입을 다른 구조체로 얇게 감싸는 이 방식은 _뉴타입 패턴(newtype pattern)_으로 알려져 있으며, 이에 대해서는 <a href="ch20-02-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types">“외부 타입에 외부 트레이트를 구현하기 위해 뉴타입 패턴 사용하기”</a><!-- ignore --> 섹션에서 더 자세히 설명합니다. 우리는 밀리미터 단위의 값에 미터 단위의 값을 더하고 싶고, <code>Add</code> 구현이 변환을 올바르게 수행하도록 하고 싶습니다. 예제 20-16에 표시된 대로 <code>Meters</code>를 <code>Rhs</code>로 하여 <code>Millimeters</code>에 대해 <code>Add</code>를 구현할 수 있습니다.</p>
<Listing number="20-16" file-name="src/lib.rs" caption="Implementing the `Add` trait on `Millimeters` to add `Millimeters` to `Meters`">
<pre><code class="language-rust noplayground">use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add&lt;Meters&gt; for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -&gt; Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}</code></pre>
</Listing>
<p><code>Millimeters</code>와 <code>Meters</code>를 더하기 위해, <code>Self</code>인 기본값 대신 <code>Rhs</code> 타입 파라미터의 값을 설정하도록 <code>impl Add&lt;Meters&gt;</code>를 지정합니다.</p>
<p>기본 타입 파라미터는 주로 다음 두 가지 방식으로 사용됩니다.</p>
<ol>
<li>기존 코드를 깨뜨리지 않고 타입을 확장하기 위해</li>
<li>대부분의 사용자가 필요로 하지 않는 특정 사례에서 커스터마이징을 허용하기 위해</li>
</ol>
<p>표준 라이브러리의 <code>Add</code> 트레이트는 두 번째 목적의 예입니다. 보통은 동일한 두 타입을 더하겠지만, <code>Add</code> 트레이트는 그 이상의 커스터마이징 기능을 제공합니다. <code>Add</code> 트레이트 정의에서 기본 타입 파라미터를 사용한다는 것은 대부분의 경우 추가 파라미터를 지정할 필요가 없음을 의미합니다. 즉, 약간의 구현 상용구(boilerplate)가 필요하지 않으므로 트레이트를 더 쉽게 사용할 수 있습니다.</p>
<p>첫 번째 목적은 두 번째와 비슷하지만 반대의 경우입니다. 기존 트레이트에 타입 파라미터를 추가하고 싶을 때, 기존 구현 코드를 깨뜨리지 않고 트레이트 기능을 확장할 수 있도록 기본값을 제공할 수 있습니다.</p>
<h3 id="모호성-해소를-위한-완전-정규화-문법-이름이-같은-메서드-호출하기"><a class="header" href="#모호성-해소를-위한-완전-정규화-문법-이름이-같은-메서드-호출하기">모호성 해소를 위한 완전 정규화 문법: 이름이 같은 메서드 호출하기</a></h3>
<p>러스트에서 트레이트가 다른 트레이트의 메서드와 같은 이름을 가진 메서드를 갖는 것을 막지 않으며, 한 타입에 두 트레이트를 모두 구현하는 것도 막지 않습니다. 또한 트레이트의 메서드와 같은 이름의 메서드를 타입에 직접 구현하는 것도 가능합니다.</p>
<p>같은 이름의 메서드를 호출할 때, 러스트에게 어떤 메서드를 사용하고 싶은지 알려주어야 합니다. 예제 20-17의 코드를 살펴보세요. 여기서는 모두 <code>fly</code>라는 이름의 메서드를 가진 <code>Pilot</code>과 <code>Wizard</code>라는 두 트레이트를 정의했습니다. 그런 다음 이미 <code>fly</code>라는 이름의 메서드가 직접 구현되어 있는 <code>Human</code> 타입에 이 두 트레이트를 모두 구현합니다. 각 <code>fly</code> 메서드는 서로 다른 동작을 수행합니다.</p>
<Listing number="20-17" file-name="src/main.rs" caption="Two traits are defined to have a ` method and are implemented on the `Human` type, and a `fly` method is implemented on `Human` directly">
<pre><pre class="playground"><code class="language-rust edition2021">trait Pilot {
    fn fly(&amp;self);
}

trait Wizard {
    fn fly(&amp;self);
}

struct Human;

impl Pilot for Human {
    fn fly(&amp;self) {
        println!("기장입니다. 안내 말씀 드립니다.");
    }
}

impl Wizard for Human {
    fn fly(&amp;self) {
        println!("상승!");
    }
}

impl Human {
    fn fly(&amp;self) {
        println!("*팔을 미친듯이 흔드는 중*");
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p><code>Human</code>의 인스턴스에서 <code>fly</code>를 호출하면, 컴파일러는 예제 20-18에 표시된 대로 타입에 직접 구현된 메서드를 호출하는 것을 기본으로 합니다.</p>
<Listing number="20-18" file-name="src/main.rs" caption="Calling `fly` on an instance of `Human`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("기장입니다. 안내 말씀 드립니다.");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("상승!");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("*팔을 미친듯이 흔드는 중*");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    person.fly();
}</code></pre></pre>
</Listing>
<p>이 코드를 실행하면 <code>*팔을 미친듯이 흔드는 중*</code>이 출력되며, 이는 러스트가 <code>Human</code>에 직접 구현된 <code>fly</code> 메서드를 호출했음을 보여줍니다.</p>
<p><code>Pilot</code> 트레이트나 <code>Wizard</code> 트레이트 중 하나의 <code>fly</code> 메서드를 호출하려면, 우리가 의도하는 <code>fly</code> 메서드가 무엇인지 명시하기 위해 더 구체적인 문법을 사용해야 합니다. 예제 20-19에서 이 문법을 보여줍니다.</p>
<Listing number="20-19" file-name="src/main.rs" caption="Specifying which trait’s `fly` method we want to call">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("기장입니다. 안내 말씀 드립니다.");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("상승!");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!("*팔을 미친듯이 흔드는 중*");
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    Pilot::fly(&amp;person);
    Wizard::fly(&amp;person);
    person.fly();
}</code></pre></pre>
</Listing>
<p>메서드 이름 앞에 트레이트 이름을 지정하면 우리가 호출하고자 하는 <code>fly</code> 구현이 무엇인지 러스트에게 명확하게 전달됩니다. 또한 <code>Human::fly(&amp;person)</code>라고 쓸 수도 있는데, 이는 예제 20-19에서 사용한 <code>person.fly()</code>와 동일하지만 모호성을 해소할 필요가 없다면 조금 더 길게 쓰는 셈이 됩니다.</p>
<p>이 코드를 실행하면 다음과 같이 출력됩니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.46s
     Running `target/debug/traits-example`
기장입니다. 안내 말씀 드립니다.
상승!
*팔을 미친듯이 흔드는 중*
</code></pre>
<p><code>fly</code> 메서드는 <code>self</code> 파라미터를 받기 때문에, 만약 한 트레이트를 구현하는 두 _타입_이 있다면 러스트는 <code>self</code>의 타입에 기반하여 어떤 트레이트 구현을 사용할지 알아낼 수 있습니다.</p>
<p>하지만 메서드가 아닌 연관 함수는 <code>self</code> 파라미터가 없습니다. 같은 이름의 메서드가 아닌 함수를 정의하는 여러 타입이나 트레이트가 있을 때, _완전 정규화 문법(fully qualified syntax)_을 사용하지 않으면 러스트는 여러분이 어떤 타입을 의도하는지 항상 알 수 있는 것은 아닙니다. 예를 들어, 예제 20-20에서는 모든 새끼 강아지의 이름을 _Spot_이라고 짓고 싶어 하는 동물 보호소를 위한 트레이트를 만듭니다. 메서드가 아닌 연관 함수 <code>baby_name</code>을 가진 <code>Animal</code> 트레이트를 만듭니다. <code>Dog</code> 구조체에 대해 <code>Animal</code> 트레이트를 구현하고, <code>Dog</code>에 직접 메서드가 아닌 연관 함수 <code>baby_name</code>을 제공합니다.</p>
<Listing number="20-20" file-name="src/main.rs" caption="A trait with an associated function and a type with an associated function of the same name that also implements the trait">
<pre><pre class="playground"><code class="language-rust edition2021">trait Animal {
    fn baby_name() -&gt; String;
}

struct Dog;

impl Dog {
    fn baby_name() -&gt; String {
        String::from("Spot")
    }
}

impl Animal for Dog {
    fn baby_name() -&gt; String {
        String::from("강아지")
    }
}

fn main() {
    println!("새끼 개는 {}라고 불립니다", Dog::baby_name());
}</code></pre></pre>
</Listing>
<p>모든 강아지의 이름을 Spot으로 짓는 코드를 <code>Dog</code>에 정의된 <code>baby_name</code> 연관 함수에 구현합니다. <code>Dog</code> 타입은 또한 모든 동물이 가진 특성을 묘사하는 <code>Animal</code> 트레이트를 구현합니다. 새끼 개는 강아지(puppy)라고 불리며, 이는 <code>Animal</code> 트레이트와 연관된 <code>baby_name</code> 함수 내의 <code>Dog</code>에 대한 <code>Animal</code> 트레이트 구현에서 표현됩니다.</p>
<p><code>main</code>에서 <code>Dog::baby_name</code> 함수를 호출하면 <code>Dog</code>에 직접 정의된 연관 함수가 호출됩니다. 이 코드는 다음과 같이 출력됩니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.54s
     Running `target/debug/traits-example`
새끼 개는 Spot이라고 불립니다
</code></pre>
<p>이 출력은 우리가 원하던 것이 아닙니다. 우리는 <code>Dog</code>에 구현된 <code>Animal</code> 트레이트의 일부인 <code>baby_name</code> 함수를 호출하여 <code>새끼 개는 강아지라고 불립니다</code>가 출력되기를 원합니다. 예제 20-19에서 사용했던 트레이트 이름을 지정하는 기술은 여기서 도움이 되지 않습니다. <code>main</code>을 예제 20-21의 코드로 변경하면 컴파일 에러가 발생합니다.</p>
<Listing number="20-21" file-name="src/main.rs" caption="Attempting to call the `baby_name` function from the `Animal` trait, but Rust doesn’t know which implementation to use">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("Spot")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("강아지")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!("새끼 개는 {}라고 불립니다", Animal::baby_name());
}</code></pre>
</Listing>
<p><code>Animal::baby_name</code>은 <code>self</code> 파라미터가 없고, <code>Animal</code> 트레이트를 구현하는 다른 타입들이 있을 수 있기 때문에, 러스트는 우리가 어떤 <code>Animal::baby_name</code> 구현을 원하는지 알아낼 수 없습니다. 다음과 같은 컴파일러 에러가 발생합니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0790]: cannot call associated function on trait without specifying the corresponding `impl` type
  --&gt; src/main.rs:20:43
   |
2  |     fn baby_name() -&gt; String;
   |     ------------------------- `Animal::baby_name` defined here
...
20 |     println!("A baby dog is called a {}", Animal::baby_name());
   |                                           ^^^^^^^^^^^^^^^^^^^ cannot call associated function of trait
   |
help: use the fully-qualified path to the only available implementation
   |
20 |     println!("A baby dog is called a {}", &lt;Dog as Animal&gt;::baby_name());
   |                                           +++++++       +

For more information about this error, try `rustc --explain E0790`.
error: could not compile `traits-example` (bin "traits-example") due to 1 previous error
</code></pre>
<p>모호성을 해소하고 다른 타입에 대한 <code>Animal</code> 구현이 아닌 <code>Dog</code>에 대한 <code>Animal</code> 구현을 사용하고 싶다고 러스트에게 알리려면, 완전 정규화 문법을 사용해야 합니다. 예제 20-22에서 완전 정규화 문법을 사용하는 방법을 보여줍니다.</p>
<Listing number="20-22" file-name="src/main.rs" caption="Using fully qualified syntax to specify that we want to call the `baby_name` function from the `Animal` trait as implemented on `Dog`">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("Spot")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from("강아지")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!("새끼 개는 {}라고 불립니다", &lt;Dog as Animal&gt;::baby_name());
}</code></pre></pre>
</Listing>
<p>우리는 꺾쇠괄호 안에 타입 어노테이션을 제공하여, 이 함수 호출을 위해 <code>Dog</code> 타입을 <code>Animal</code>로 취급하고 싶다고 말함으로써 <code>Dog</code>에 구현된 <code>Animal</code> 트레이트의 <code>baby_name</code> 메서드를 호출하고 싶다는 것을 러스트에 명시합니다. 이제 이 코드는 우리가 원하던 것을 출력합니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/traits-example`
새끼 개는 강아지라고 불립니다
</code></pre>
<p>일반적으로 완전 정규화 문법은 다음과 같이 정의됩니다.</p>
<pre><code class="language-rust ignore">&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);</code></pre>
<p>메서드가 아닌 연관 함수의 경우 <code>receiver</code>가 없으며, 다른 인수들의 목록만 있게 됩니다. 함수나 메서드를 호출하는 모든 곳에서 완전 정규화 문법을 사용할 수 있습니다. 하지만 프로그램의 다른 정보로부터 러스트가 파악할 수 있는 부분은 생략할 수 있습니다. 같은 이름을 사용하는 여러 구현이 있어서 러스트가 여러분이 호출하고자 하는 구현이 무엇인지 식별하는 데 도움이 필요한 경우에만 이 더 장황한 문법을 사용하면 됩니다.</p>
<h3 id="슈퍼트레이트를-사용하여-한-트레이트-내에서-다른-트레이트의-기능-요구하기"><a class="header" href="#슈퍼트레이트를-사용하여-한-트레이트-내에서-다른-트레이트의-기능-요구하기">슈퍼트레이트를 사용하여 한 트레이트 내에서 다른 트레이트의 기능 요구하기</a></h3>
<p>때때로 다른 트레이트에 의존하는 트레이트 정의를 작성해야 할 수도 있습니다. 즉, 어떤 타입이 첫 번째 트레이트를 구현하려면 해당 타입이 두 번째 트레이트도 구현하도록 요구하고 싶은 경우입니다. 이렇게 하면 여러분의 트레이트 정의에서 두 번째 트레이트의 연관 아이템들을 활용할 수 있습니다. 여러분의 트레이트 정의가 의존하고 있는 트레이트를 해당 트레이트의 _슈퍼트레이트(supertrait)_라고 부릅니다.</p>
<p>예를 들어, 주어진 값을 별표(*)로 감싸서 출력하는 <code>outline_print</code> 메서드를 가진 <code>OutlinePrint</code> 트레이트를 만들고 싶다고 해봅시다. 즉, 표준 라이브러리 트레이트인 <code>Display</code>를 구현하여 <code>(x, y)</code>라는 결과를 내는 <code>Point</code> 구조체가 있을 때, <code>x</code>가 <code>1</code>이고 <code>y</code>가 <code>3</code>인 <code>Point</code> 인스턴스에서 <code>outline_print</code>를 호출하면 다음과 같이 출력되어야 합니다.</p>
<pre><code class="language-text">**********
*        *
* (1, 3) *
*        *
**********
</code></pre>
<p><code>outline_print</code> 메서드 구현에서 <code>Display</code> 트레이트의 기능을 사용하고 싶습니다. 따라서 <code>OutlinePrint</code> 트레이트는 <code>Display</code>를 구현하고 <code>OutlinePrint</code>가 필요로 하는 기능을 제공하는 타입에 대해서만 작동하도록 지정해야 합니다. 트레이트 정의에서 <code>OutlinePrint: Display</code>라고 명시함으로써 이를 수행할 수 있습니다. 이 기술은 트레이트에 트레이트 바운드(trait bound)를 추가하는 것과 유사합니다. 예제 20-23은 <code>OutlinePrint</code> 트레이트의 구현을 보여줍니다.</p>
<Listing number="20-23" file-name="src/main.rs" caption="Implementing the `OutlinePrint` trait that requires the functionality from `Display`">
<pre><pre class="playground"><code class="language-rust edition2021">use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&amp;self) {
        let output = self.to_string();
        let len = output.len();
        println!("{}", "*".repeat(len + 4));
        println!("*{}*", " ".repeat(len + 2));
        println!("* {output} *");
        println!("*{}*", " ".repeat(len + 2));
        println!("{}", "*".repeat(len + 4));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p><code>OutlinePrint</code>가 <code>Display</code> 트레이트를 필요로 하도록 지정했기 때문에, <code>Display</code>를 구현하는 모든 타입에 대해 자동으로 구현되는 <code>to_string</code> 함수를 사용할 수 있습니다. 트레이트 이름 뒤에 콜론을 찍고 <code>Display</code> 트레이트를 지정하지 않은 채 <code>to_string</code>을 사용하려고 시도하면, 현재 스코프의 <code>&amp;Self</code> 타입에 대해 <code>to_string</code>이라는 이름의 메서드를 찾을 수 없다는 에러가 발생합니다.</p>
<p><code>Point</code> 구조체와 같이 <code>Display</code>를 구현하지 않은 타입에 <code>OutlinePrint</code>를 구현하려고 시도하면 어떤 일이 발생하는지 살펴봅시다.</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("* {output} *");
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}</span></code></pre>
</Listing>
<p><code>Display</code>가 필요하지만 구현되지 않았다는 에러가 발생합니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --&gt; src/main.rs:20:23
   |
20 | impl OutlinePrint for Point {}
   |                       ^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
note: required by a bound in `OutlinePrint`
  --&gt; src/main.rs:3:21
   |
3  | trait OutlinePrint: fmt::Display {
   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint`

error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --&gt; src/main.rs:24:7
   |
24 |     p.outline_print();
   |       ^^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
note: required by a bound in `OutlinePrint::outline_print`
  --&gt; src/main.rs:3:21
   |
3  | trait OutlinePrint: fmt::Display {
   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint::outline_print`
4  |     fn outline_print(&amp;self) {
   |        ------------- required by a bound in this associated function

For more information about this error, try `rustc --explain E0277`.
error: could not compile `traits-example` (bin "traits-example") due to 2 previous errors
</code></pre>
<p>이를 해결하기 위해, 다음과 같이 <code>Point</code>에 <code>Display</code>를 구현하여 <code>OutlinePrint</code>가 요구하는 제약 조건을 충족시킵니다.</p>
<Listing file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("* {output} *");
</span><span class="boring">        println!("*{}*", " ".repeat(len + 2));
</span><span class="boring">        println!("{}", "*".repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl OutlinePrint for Point {}
</span><span class="boring">
</span>use std::fmt;

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>그러면 <code>Point</code>에 <code>OutlinePrint</code> 트레이트를 구현하는 것이 성공적으로 컴파일될 것이며, <code>Point</code> 인스턴스에서 <code>outline_print</code>를 호출하여 별표 테두리 안에 이를 표시할 수 있습니다.</p>
<h3 id="외부-타입에-외부-트레이트를-구현하기-위해-뉴타입-패턴-사용하기"><a class="header" href="#외부-타입에-외부-트레이트를-구현하기-위해-뉴타입-패턴-사용하기">외부 타입에 외부 트레이트를 구현하기 위해 뉴타입 패턴 사용하기</a></h3>
<p>10장의 <a href="ch10-02-traits.html#implementing-a-trait-on-a-type">“타입에 트레이트 구현하기”</a><!-- ignore -->에서 우리는 트레이트나 타입 중 하나가 우리 크레이트에 로컬인 경우에만 타입에 트레이트를 구현할 수 있다는 고립 규칙(orphan rule)에 대해 언급했습니다. 튜플 구조체에서 새로운 타입을 생성하는 _뉴타입 패턴(newtype pattern)_을 사용하면 이 제한을 우회할 수 있습니다. (우리는 5장의 <a href="ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types">“이름이 없는 필드를 가진 튜플 구조체를 사용하여 다른 타입 만들기”</a><!-- ignore -->에서 튜플 구조체를 다루었습니다.) 튜플 구조체는 하나의 필드를 가지며 우리가 트레이트를 구현하고자 하는 타입을 감싸는 얇은 래퍼(wrapper)가 됩니다. 그러면 이 래퍼 타입은 우리 크레이트에 로컬이 되므로, 우리는 래퍼에 트레이트를 구현할 수 있습니다. _뉴타입(Newtype)_은 하스켈(Haskell) 프로그래밍 언어에서 유래한 용어입니다. 이 패턴을 사용한다고 해서 런타임 성능 저하가 발생하지는 않으며, 래퍼 타입은 컴파일 시간에 생략됩니다.</p>
<p>예를 들어, <code>Vec&lt;T&gt;</code>에 <code>Display</code>를 구현하고 싶다고 해봅시다. 고립 규칙은 <code>Display</code> 트레이트와 <code>Vec&lt;T&gt;</code> 타입 모두 우리 크레이트 외부에서 정의되었기 때문에 우리가 이를 직접 하는 것을 방지합니다. 우리는 <code>Vec&lt;T&gt;</code> 인스턴스를 보관하는 <code>Wrapper</code> 구조체를 만들 수 있습니다. 그런 다음 예제 20-24에 표시된 대로 <code>Wrapper</code>에 <code>Display</code>를 구현하고 <code>Vec&lt;T&gt;</code> 값을 사용할 수 있습니다.</p>
<Listing number="20-24" file-name="src/main.rs" caption="Creating a `Wrapper` type around `Vec<String>` to implement `Display`">
<pre><pre class="playground"><code class="language-rust edition2021">use std::fmt;

struct Wrapper(Vec&lt;String&gt;);

impl fmt::Display for Wrapper {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}

fn main() {
    let w = Wrapper(vec![String::from("hello"), String::from("world")]);
    println!("w = {w}");
}</code></pre></pre>
</Listing>
<p><code>Wrapper</code>는 튜플 구조체이고 <code>Vec&lt;T&gt;</code>는 튜플의 인덱스 0에 있는 아이템이므로, <code>Display</code> 구현에서는 <code>self.0</code>을 사용하여 내부의 <code>Vec&lt;T&gt;</code>에 접근합니다. 이제 <code>Wrapper</code>에서 <code>Display</code> 트레이트의 기능을 사용할 수 있습니다.</p>
<p>이 기술을 사용하는 것의 단점은 <code>Wrapper</code>가 새로운 타입이기 때문에, 자신이 들고 있는 값의 메서드들을 가지고 있지 않다는 점입니다. 우리는 <code>Wrapper</code>가 정확히 <code>Vec&lt;T&gt;</code>처럼 취급될 수 있도록, 모든 메서드가 <code>self.0</code>으로 위임되는 <code>Vec&lt;T&gt;</code>의 모든 메서드들을 <code>Wrapper</code>에 직접 구현해야 할 것입니다. 만약 새로운 타입이 내부 타입이 가진 모든 메서드를 갖기를 원한다면, 15장의 <a href="ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait">“<code>Deref</code> 트레이트로 스마트 포인터를 일반 참조처럼 다루기”</a><!-- ignore -->에서 다룬 <code>Deref</code> 트레이트를 <code>Wrapper</code>에 구현하여 내부 타입을 반환하도록 하는 것이 해결책이 될 수 있습니다. 만약 <code>Wrapper</code> 타입이 내부 타입의 모든 메서드를 갖기를 원하지 않는다면 (예를 들어 <code>Wrapper</code> 타입의 동작을 제한하고 싶다면), 우리가 원하는 메서드들만 수동으로 구현해야 합니다.</p>
<p>이 뉴타입 패턴은 트레이트와 관련이 없을 때도 유용합니다. 이제 화제를 돌려 러스트의 타입 시스템과 상호작용하는 몇 가지 고급 방법들을 살펴보겠습니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch20-01-unsafe-rust.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch20-03-advanced-types.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch20-01-unsafe-rust.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch20-03-advanced-types.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
