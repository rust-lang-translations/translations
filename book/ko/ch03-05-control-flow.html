<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>제어 흐름 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch03-05-control-flow.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch03-05-control-flow.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="제어-흐름"><a class="header" href="#제어-흐름">제어 흐름</a></h2>
<p>The ability to run some code depending on whether a condition is <code>true</code> and the ability to run some code repeatedly while a condition is <code>true</code> are basic building blocks in most programming languages. The most common constructs that let you control the flow of execution of Rust code are <code>if</code> expressions and loops.</p>
<h3 id="if-표현식"><a class="header" href="#if-표현식"><code>if</code> 표현식</a></h3>
<p><code>if</code> 표현식은 조건에 따라 코드를 분기할 수 있게 해줍니다. 조건을 제공한 다음 “이 조건이 충족되면 이 코드 블록을 실행하세요. 조건이 충족되지 않으면 이 코드 블록을 실행하지 마세요.”라고 명시합니다.</p>
<p><code>if</code> 표현식을 탐색하기 위해 <em>projects</em> 디렉토리에 _branches_라는 새 프로젝트를 만드세요. <em>src/main.rs</em> 파일에 다음을 입력하세요.</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let number = 3;

    if number &lt; 5 {
        println!("조건이 참이었습니다");
    } else {
        println!("조건이 거짓이었습니다");
    }
}</code></pre></pre>
<p>모든 <code>if</code> 표현식은 <code>if</code> 키워드로 시작하고 그 뒤에 조건이 옵니다. 이 경우 조건은 <code>number</code> 변수의 값이 5보다 작은지 여부를 확인합니다. 조건이 <code>true</code>일 때 실행할 코드 블록은 조건 바로 뒤에 중괄호 안에 배치합니다. <code>if</code> 표현식의 조건과 관련된 코드 블록은 2장의 <a href="ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">“추측을 비밀 번호와 비교하기”</a><!--
 ignore --> 섹션에서 논의한 <code>match</code> 표현식의 암(arm)과 마찬가지로 때때로 _암(arm)_이라고 불립니다.</p>
<p>선택적으로, <code>else</code> 표현식을 포함할 수도 있습니다. 여기서는 조건이 <code>false</code>로 평가될 경우 프로그램이 실행할 대체 코드 블록을 제공하기 위해 그렇게 했습니다. <code>else</code> 표현식을 제공하지 않고 조건이 <code>false</code>이면 프로그램은 <code>if</code> 블록을 건너뛰고 다음 코드 부분으로 넘어갑니다.</p>
<p>이 코드를 실행해 보세요. 다음과 같은 출력이 표시되어야 합니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was true
</code></pre>
<p><code>number</code>의 값을 조건을 <code>false</code>로 만드는 값으로 변경하여 어떤 일이 발생하는지 살펴보겠습니다.</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    let number = 7;
<span class="boring">
</span><span class="boring">    if number &lt; 5 {
</span><span class="boring">        println!("조건이 참이었습니다");
</span><span class="boring">    } else {
</span><span class="boring">        println!("조건이 거짓이었습니다");
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>프로그램을 다시 실행하고 출력을 확인하세요.</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was false
</code></pre>
<p>이 코드의 조건은 <code>bool</code>이어야 한다는 점도 주목할 가치가 있습니다. 조건이 <code>bool</code>이 아니면 오류가 발생합니다. 예를 들어 다음 코드를 실행해 보세요.</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let number = 3;

    if number {
        println!("숫자는 3이었습니다");
    }
}</code></pre>
<p>이번에는 <code>if</code> 조건이 <code>3</code> 값으로 평가되고, 러스트는 오류를 발생시킵니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: mismatched types
 --&gt; src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected `bool`, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` (bin "branches") due to 1 previous error
</code></pre>
<p>오류는 러스트가 <code>bool</code>을 예상했지만 정수를 받았음을 나타냅니다. Ruby 및 JavaScript와 같은 언어와 달리 러스트는 비불리언 타입을 자동으로 불리언으로 변환하려고 시도하지 않습니다. 명시적으로 <code>if</code>에 항상 불리언을 조건으로 제공해야 합니다. 예를 들어 숫자가 <code>0</code>과 같지 않을 때만 <code>if</code> 코드 블록을 실행하려면 <code>if</code> 표현식을 다음과 같이 변경할 수 있습니다.</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let number = 3;

    if number != 0 {
        println!("숫자는 0이 아니었습니다");
    }
}</code></pre></pre>
<p>이 코드를 실행하면 <code>숫자는 0이 아니었습니다</code>가 출력됩니다.</p>
<h4 id="else-if로-여러-조건-처리하기"><a class="header" href="#else-if로-여러-조건-처리하기"><code>else if</code>로 여러 조건 처리하기</a></h4>
<p><code>else if</code> 표현식에서 <code>if</code>와 <code>else</code>를 결합하여 여러 조건을 사용할 수 있습니다. 예를 들어:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("숫자는 4로 나누어집니다");
    } else if number % 3 == 0 {
        println!("숫자는 3으로 나누어집니다");
    } else if number % 2 == 0 {
        println!("숫자는 2로 나누어집니다");
    } else {
        println!("숫자는 4, 3, 2로 나누어지지 않습니다");
    }
}</code></pre></pre>
<p>이 프로그램은 네 가지 가능한 경로를 가질 수 있습니다. 실행 후 다음과 같은 출력이 표시되어야 합니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
number is divisible by 3
</code></pre>
<p>이 프로그램이 실행되면 각 <code>if</code> 표현식을 차례로 확인하고 조건이 <code>true</code>로 평가되는 첫 번째 본문을 실행합니다. 6은 2로 나누어지지만, <code>number is divisible by 2</code>라는 출력이나 <code>else</code> 블록의 <code>number is not divisible by 4, 3, or 2</code> 텍스트는 볼 수 없습니다. 이는 러스트가 첫 번째 <code>true</code> 조건에 대한 블록만 실행하고, 하나를 찾으면 나머지는 확인하지 않기 때문입니다.</p>
<p>너무 많은 <code>else if</code> 표현식을 사용하면 코드가 복잡해질 수 있으므로, 하나 이상인 경우 코드를 리팩토링하는 것이 좋습니다. 6장에서는 이러한 경우를 위한 <code>match</code>라는 강력한 러스트 분기 구문에 대해 설명합니다.</p>
<h4 id="let-문에서-if-사용하기"><a class="header" href="#let-문에서-if-사용하기"><code>let</code> 문에서 <code>if</code> 사용하기</a></h4>
<p><code>if</code>는 표현식이므로, 목록 3-2와 같이 <code>let</code> 문의 오른쪽에 사용하여 결과를 변수에 할당할 수 있습니다.</p>
<Listing number="3-2" file-name="src/main.rs" caption="Assigning the result of an `if` expression to a variable">
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("숫자의 값은: {number}");
}</code></pre></pre>
</Listing>
<p><code>number</code> 변수는 <code>if</code> 표현식의 결과에 따라 값에 바인딩됩니다. 이 코드를 실행하여 어떤 일이 발생하는지 확인하세요.</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/branches`
The value of number is: 5
</code></pre>
<p>코드 블록은 마지막 표현식으로 평가되며, 숫자 자체도 표현식이라는 것을 기억하세요. 이 경우 전체 <code>if</code> 표현식의 값은 어떤 코드 블록이 실행되는지에 따라 달라집니다. 이는 <code>if</code>의 각 암(arm)에서 결과가 될 수 있는 값들이 동일한 타입이어야 함을 의미합니다. 목록 3-2에서 <code>if</code> 암과 <code>else</code> 암의 결과는 모두 <code>i32</code> 정수였습니다. 다음 예제와 같이 타입이 일치하지 않으면 오류가 발생합니다.</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let condition = true;

    let number = if condition { 5 } else { "여섯" };

    println!("숫자의 값은: {number}");
}</code></pre>
<p>이 코드를 컴파일하려고 하면 오류가 발생합니다. <code>if</code>와 <code>else</code> 암(arm)은 호환되지 않는 값 타입을 가지며, 러스트는 프로그램에서 문제가 있는 정확한 위치를 알려줍니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: `if` and `else` have incompatible types
 --&gt; src/main.rs:4:44
  |
4 |     let number = if condition { 5 } else { "six" };
  |                                 -          ^^^^^ expected integer, found `&amp;str`
  |                                 |
  |                                 expected because of this

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` (bin "branches") due to 1 previous error
</code></pre>
<p>The expression in the <code>if</code> block evaluates to an integer, and the expression in the <code>else</code> block evaluates to a string. This won’t work, because variables must have a single type, and Rust needs to know definitively at compile time what type the <code>number</code> variable is. Knowing the type of <code>number</code> lets the compiler verify the type is valid everywhere we use <code>number</code>. Rust wouldn’t be able to do that if the type of <code>number</code> was only determined at runtime; the compiler would be more complex and would make fewer guarantees about the code if it had to keep track of multiple hypothetical types for any variable.</p>
<h3 id="반복문으로-반복하기"><a class="header" href="#반복문으로-반복하기">반복문으로 반복하기</a></h3>
<p>코드 블록을 여러 번 실행하는 것이 종종 유용합니다. 이 작업을 위해 러스트는 여러 _루프_를 제공합니다. 루프는 루프 본문 안의 코드를 끝까지 실행한 다음 즉시 처음으로 돌아갑니다. 루프를 실험하기 위해 _loops_라는 새 프로젝트를 만들어 보겠습니다.</p>
<p>러스트에는 <code>loop</code>, <code>while</code>, <code>for</code> 세 가지 종류의 루프가 있습니다. 각각을 시도해 보겠습니다.</p>
<h4 id="loop로-코드-반복하기"><a class="header" href="#loop로-코드-반복하기"><code>loop</code>로 코드 반복하기</a></h4>
<p>The <code>loop</code> keyword tells Rust to execute a block of code over and over again either forever or until you explicitly tell it to stop.</p>
<p>예를 들어, <em>loops</em> 디렉토리의 <em>src/main.rs</em> 파일을 다음과 같이 변경하세요.</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!("다시!");
    }
}</code></pre>
<p>When we run this program, we’ll see <code>again!</code> printed over and over continuously until we stop the program manually. Most terminals support the keyboard shortcut <kbd>ctrl</kbd>-<kbd>C</kbd> to interrupt a program that is stuck in a continual loop. Give it a try:</p>
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-32-loop
cargo run
CTRL-C
-->
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.08s
     Running `target/debug/loops`
again!
again!
again!
again!
^Cagain!
</code></pre>
<p>The symbol <code>^C</code> represents where you pressed <kbd>ctrl</kbd>-<kbd>C</kbd>.</p>
<p>You may or may not see the word <code>again!</code> printed after the <code>^C</code>, depending on where the code was in the loop when it received the interrupt signal.</p>
<p>다행히 러스트는 코드를 사용하여 루프를 빠져나오는 방법도 제공합니다. <code>break</code> 키워드를 루프 안에 배치하여 프로그램이 루프 실행을 언제 중지해야 하는지 알려줄 수 있습니다. 2장의 <a href="ch02-00-guessing-game-tutorial.html#quitting-after-a-correct-guess">“정답 맞춘 후 종료하기”</a><!-- ignore
 --> 섹션에서 사용자가 정답을 맞춰 게임에서 이겼을 때 프로그램을 종료하기 위해 이 작업을 수행했습니다.</p>
<p>또한 추측 게임에서 <code>continue</code>를 사용했습니다. 이는 루프에서 프로그램에게 현재 루프 반복의 나머지 코드를 건너뛰고 다음 반복으로 이동하도록 지시합니다.</p>
<h4 id="루프에서-값-반환하기"><a class="header" href="#루프에서-값-반환하기">루프에서 값 반환하기</a></h4>
<p>One of the uses of a <code>loop</code> is to retry an operation you know might fail, such as checking whether a thread has completed its job. You might also need to pass the result of that operation out of the loop to the rest of your code. To do this, you can add the value you want returned after the <code>break</code> expression you use to stop the loop; that value will be returned out of the loop so that you can use it, as shown here:</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("결과는 {result}입니다");
}</code></pre></pre>
<p>Before the loop, we declare a variable named <code>counter</code> and initialize it to <code>0</code>. Then, we declare a variable named <code>result</code> to hold the value returned from the loop. On every iteration of the loop, we add <code>1</code> to the <code>counter</code> variable, and then check whether the <code>counter</code> is equal to <code>10</code>. When it is, we use the <code>break</code> keyword with the value <code>counter * 2</code>. After the loop, we use a semicolon to end the statement that assigns the value to <code>result</code>. Finally, we print the value in <code>result</code>, which in this case is <code>20</code>.</p>
<p>루프 안에서 <code>return</code>할 수도 있습니다. <code>break</code>는 현재 루프만 종료하지만, <code>return</code>은 항상 현재 함수를 종료합니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="loop-labels-to-disambiguate-between-multiple-loops"></a></p>
<h4 id="disambiguating-with-loop-labels"><a class="header" href="#disambiguating-with-loop-labels">Disambiguating with Loop Labels</a></h4>
<p>루프 안에 루프가 있는 경우, <code>break</code>와 <code>continue</code>는 해당 지점의 가장 안쪽 루프에 적용됩니다. 선택적으로 루프에 _루프 레이블_을 지정할 수 있으며, 이 레이블을 <code>break</code> 또는 <code>continue</code>와 함께 사용하여 해당 키워드가 가장 안쪽 루프 대신 레이블이 지정된 루프에 적용되도록 지정할 수 있습니다. 루프 레이블은 작은따옴표로 시작해야 합니다. 다음은 두 개의 중첩된 루프 예시입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {count}");
        let mut remaining = 10;

        loop {
            println!("remaining = {remaining}");
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("최종 count = {count}");
}</code></pre></pre>
<p>바깥쪽 루프에는 <code>'counting_up</code> 레이블이 있으며, 0부터 2까지 카운트합니다. 레이블이 없는 안쪽 루프는 10부터 9까지 카운트합니다. 레이블을 지정하지 않은 첫 번째 <code>break</code>는 안쪽 루프만 종료합니다. <code>break 'counting_up;</code> 문은 바깥쪽 루프를 종료합니다. 이 코드는 다음을 출력합니다.</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running `target/debug/loops`
count = 0
remaining = 10
remaining = 9
count = 1
remaining = 10
remaining = 9
count = 2
remaining = 10
End count = 2
</code></pre>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="conditional-loops-with-while"></a></p>
<h4 id="streamlining-conditional-loops-with-while"><a class="header" href="#streamlining-conditional-loops-with-while">Streamlining Conditional Loops with while</a></h4>
<p>A program will often need to evaluate a condition within a loop. While the condition is <code>true</code>, the loop runs. When the condition ceases to be <code>true</code>, the program calls <code>break</code>, stopping the loop. It’s possible to implement behavior like this using a combination of <code>loop</code>, <code>if</code>, <code>else</code>, and <code>break</code>; you could try that now in a program, if you’d like. However, this pattern is so common that Rust has a built-in language construct for it, called a <code>while</code> loop. In Listing 3-3, we use <code>while</code> to loop the program three times, counting down each time, and then, after the loop, to print a message and exit.</p>
<Listing number="3-3" file-name="src/main.rs" caption="Using a `while` loop to run code while a condition evaluates to `true`">
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{number}!");

        number -= 1;
    }

    println!("발사!!!");
}</code></pre></pre>
</Listing>
<p>이 구문은 <code>loop</code>, <code>if</code>, <code>else</code>, <code>break</code>를 사용했을 때 필요했을 많은 중첩을 제거하며, 더 명확합니다. 조건이 <code>true</code>로 평가되는 동안 코드가 실행되고, 그렇지 않으면 루프를 종료합니다.</p>
<h4 id="for로-컬렉션-반복하기"><a class="header" href="#for로-컬렉션-반복하기"><code>for</code>로 컬렉션 반복하기</a></h4>
<p>You can choose to use the <code>while</code> construct to loop over the elements of a collection, such as an array. For example, the loop in Listing 3-4 prints each element in the array <code>a</code>.</p>
<Listing number="3-4" file-name="src/main.rs" caption="Looping through each element of a collection using a `while` loop">
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }
}</code></pre></pre>
</Listing>
<p>Here, the code counts up through the elements in the array. It starts at index <code>0</code> and then loops until it reaches the final index in the array (that is, when <code>index &lt; 5</code> is no longer <code>true</code>). Running this code will print every element in the array:</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.32s
     Running `target/debug/loops`
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50
</code></pre>
<p>예상대로 다섯 개의 배열 값이 모두 터미널에 나타납니다. <code>index</code>가 어느 시점에서 <code>5</code>에 도달하더라도, 루프는 배열에서 여섯 번째 값을 가져오려고 시도하기 전에 실행을 중지합니다.</p>
<p>However, this approach is error-prone; we could cause the program to panic if the index value or test condition is incorrect. For example, if you changed the definition of the <code>a</code> array to have four elements but forgot to update the condition to <code>while index &lt; 4</code>, the code would panic. It’s also slow, because the compiler adds runtime code to perform the conditional check of whether the index is within the bounds of the array on every iteration through the loop.</p>
<p>더 간결한 대안으로, <code>for</code> 루프를 사용하여 컬렉션의 각 항목에 대해 일부 코드를 실행할 수 있습니다. <code>for</code> 루프는 목록 3-5의 코드와 같습니다.</p>
<Listing number="3-5" file-name="src/main.rs" caption="Looping through each element of a collection using a `for` loop">
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("값은: {element}입니다");
    }
}</code></pre></pre>
</Listing>
<p>When we run this code, we’ll see the same output as in Listing 3-4. More importantly, we’ve now increased the safety of the code and eliminated the chance of bugs that might result from going beyond the end of the array or not going far enough and missing some items. Machine code generated from <code>for</code> loops can be more efficient as well because the index doesn’t need to be compared to the length of the array at every iteration.</p>
<p><code>for</code> 루프를 사용하면 목록 3-4에서 사용된 메서드처럼 배열의 값 수를 변경하더라도 다른 코드를 변경할 필요가 없습니다.</p>
<p><code>for</code> 루프의 안전성과 간결성은 러스트에서 가장 일반적으로 사용되는 루프 구문입니다. 목록 3-3의 <code>while</code> 루프를 사용한 카운트다운 예제처럼 특정 횟수만큼 코드를 실행하려는 상황에서도 대부분의 러스트 개발자는 <code>for</code> 루프를 사용할 것입니다. 그렇게 하려면 표준 라이브러리에서 제공하는 <code>Range</code>를 사용해야 합니다. <code>Range</code>는 한 숫자부터 시작하여 다른 숫자 앞에서 끝나는 모든 숫자를 순서대로 생성합니다.</p>
<p>다음은 <code>for</code> 루프와 아직 이야기하지 않은 다른 메서드인 <code>rev</code>를 사용하여 범위를 역순으로 만드는 카운트다운의 모습입니다.</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    for number in (1..4).rev() {
        println!("{number}!");
    }
    println!("발사!!!");
}</code></pre></pre>
<p>이 코드가 좀 더 깔끔하죠?</p>
<h2 id="요약"><a class="header" href="#요약">요약</a></h2>
<p>You made it! This was a sizable chapter: You learned about variables, scalar and compound data types, functions, comments, <code>if</code> expressions, and loops! To practice with the concepts discussed in this chapter, try building programs to do the following:</p>
<ul>
<li>화씨와 섭씨 온도 변환.</li>
<li>_n_번째 피보나치 수 생성.</li>
<li>크리스마스 캐럴 “The Twelve Days of Christmas”의 가사를 노래의 반복을 활용하여 출력합니다.</li>
</ul>
<p>다음으로 넘어갈 준비가 되면, 다른 프로그래밍 언어에는 일반적으로 존재하지 않는 러스트의 개념인 소유권에 대해 이야기하겠습니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch03-04-comments.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch04-00-understanding-ownership.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch03-04-comments.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch04-00-understanding-ownership.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
