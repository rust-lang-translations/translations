<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>추측 게임 프로그래밍 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch02-00-guessing-game-tutorial.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch02-00-guessing-game-tutorial.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="추측-게임-프로그래밍"><a class="header" href="#추측-게임-프로그래밍">추측 게임 프로그래밍</a></h1>
<p>함께 실습 프로젝트를 통해 Rust에 뛰어들어 봅시다! 이 장에서는 몇 가지 일반적인 Rust 개념을 실제 프로그램에서 사용하는 방법을 보여줌으로써 소개합니다. <code>let</code>, <code>match</code>, 메서드, 연관 함수, 외부 크레이트 등에 대해 배울 것입니다! 다음 장에서는 이러한 아이디어를 더 자세히 탐구할 것입니다. 이 장에서는 기본 사항만 연습할 것입니다.</p>
<p>We’ll implement a classic beginner programming problem: a guessing game. Here’s how it works: The program will generate a random integer between 1 and 100. It will then prompt the player to enter a guess. After a guess is entered, the program will indicate whether the guess is too low or too high. If the guess is correct, the game will print a congratulatory message and exit.</p>
<h2 id="새-프로젝트-설정하기"><a class="header" href="#새-프로젝트-설정하기">새 프로젝트 설정하기</a></h2>
<p>새 프로젝트를 설정하려면 1장에서 만든 <em>projects</em> 디렉토리로 이동하여 Cargo를 사용하여 새 프로젝트를 만드세요. 다음과 같이요:</p>
<pre><code class="language-console">$ cargo new guessing_game
$ cd guessing_game
</code></pre>
<p>첫 번째 명령인 <code>cargo new</code>는 프로젝트 이름(<code>guessing_game</code>)을 첫 번째 인수로 받습니다. 두 번째 명령은 새 프로젝트 디렉토리로 변경합니다.</p>
<p>생성된 <em>Cargo.toml</em> 파일을 살펴보세요:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial
rm -rf no-listing-01-cargo-new
cargo new no-listing-01-cargo-new --name guessing_game
cd no-listing-01-cargo-new
cargo run > output.txt 2>&1
cd ../../..
-->
<p><span class="filename">파일명: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
version = "0.1.0"
edition = "2024"

[dependencies]
</code></pre>
<p>1장에서 보았듯이 <code>cargo new</code>는 "Hello, world!" 프로그램을 생성합니다. <em>src/main.rs</em> 파일을 확인하세요:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    println!("헬로, 월드!");
}</code></pre></pre>
<p>이제 <code>cargo run</code> 명령을 사용하여 이 "Hello, world!" 프로그램을 컴파일하고 같은 단계에서 실행해 봅시다:</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.08s
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
<p><code>run</code> 명령은 이 게임에서처럼 프로젝트를 빠르게 반복해야 할 때 유용합니다. 다음 반복으로 넘어가기 전에 각 반복을 빠르게 테스트합니다.</p>
<p><em>src/main.rs</em> 파일을 다시 여세요. 이 파일에 모든 코드를 작성할 것입니다.</p>
<h2 id="추측-처리하기"><a class="header" href="#추측-처리하기">추측 처리하기</a></h2>
<p>추측 게임 프로그램의 첫 번째 부분은 사용자 입력을 요청하고, 그 입력을 처리하고, 입력이 예상된 형식인지 확인합니다. 시작하려면, 플레이어가 추측을 입력하도록 허용할 것입니다. 목록 2-1의 코드를 _src/main.rs_에 입력하세요.</p>
<Listing number="2-1" file-name="src/main.rs" caption="Code that gets a guess from the user and prints it">
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!("숫자를 맞춰보세요!");

    println!(추측을 입력하세요.);

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("줄 읽기 실패");

    println!("당신의 추측: {guess}");
}</code></pre>
</Listing>
<p>이 코드는 많은 정보를 담고 있으므로, 한 줄씩 살펴보겠습니다. 사용자 입력을 받고 그 결과를 출력으로 인쇄하려면, <code>io</code> 입출력 라이브러리를 스코프로 가져와야 합니다. <code>io</code> 라이브러리는 <code>std</code>로 알려진 표준 라이브러리에서 제공됩니다:</p>
<pre><code class="language-rust ignore">use std::io;
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    println!(추측을 입력하세요.);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("줄 읽기 실패");
</span><span class="boring">
</span><span class="boring">    println!("당신의 추측: {guess}");
</span><span class="boring">}</span></code></pre>
<p>기본적으로, 러스트는 모든 프로그램의 스코프로 가져오는 표준 라이브러리에 정의된 아이템 세트를 가지고 있습니다. 이 세트를 _프렐류드_라고 하며, <a href="../std/prelude/index.html">표준 라이브러리 문서</a>에서 모든 것을 볼 수 있습니다.</p>
<p>사용하려는 타입이 프렐류드에 없으면, <code>use</code> 문을 사용하여 해당 타입을 명시적으로 스코프로 가져와야 합니다. <code>std::io</code> 라이브러리를 사용하면 사용자 입력을 받는 기능을 포함하여 여러 유용한 기능을 사용할 수 있습니다.</p>
<p>1장에서 보았듯이, <code>main</code> 함수는 프로그램의 진입점입니다:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span>fn main() {
<span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    println!(추측을 입력하세요.);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("줄 읽기 실패");
</span><span class="boring">
</span><span class="boring">    println!("당신의 추측: {guess}");
</span><span class="boring">}</span></code></pre>
<p><code>fn</code> 구문은 새 함수를 선언하고, 괄호 <code>()</code>는 매개변수가 없음을 나타내며, 중괄호 <code>{</code>는 함수 본문의 시작을 나타냅니다.</p>
<p>1장에서 배운 것처럼, <code>println!</code>은 화면에 문자열을 출력하는 매크로입니다:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    println!("숫자를 맞춰보세요!");

    println!(추측을 입력하세요.);
<span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("줄 읽기 실패");
</span><span class="boring">
</span><span class="boring">    println!("당신의 추측: {guess}");
</span><span class="boring">}</span></code></pre>
<p>이 코드는 게임이 무엇인지 알리고 사용자로부터 입력을 요청하는 프롬프트를 출력합니다.</p>
<h3 id="변수로-값-저장하기"><a class="header" href="#변수로-값-저장하기">변수로 값 저장하기</a></h3>
<p>다음으로, 사용자 입력을 저장할 _변수_를 다음과 같이 생성합니다:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    println!(추측을 입력하세요.);
</span><span class="boring">
</span>    let mut guess = String::new();
<span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("줄 읽기 실패");
</span><span class="boring">
</span><span class="boring">    println!("당신의 추측: {guess}");
</span><span class="boring">}</span></code></pre>
<p>이제 프로그램이 흥미로워졌습니다! 이 작은 한 줄에 많은 일이 일어나고 있습니다. <code>let</code> 문을 사용하여 변수를 생성합니다. 다음은 또 다른 예입니다:</p>
<pre><code class="language-rust ignore">let apples = 5;</code></pre>
<p>This line creates a new variable named <code>apples</code> and binds it to the value <code>5</code>. In Rust, variables are immutable by default, meaning once we give the variable a value, the value won’t change. We’ll be discussing this concept in detail in the <a href="ch03-01-variables-and-mutability.html#variables-and-mutability">“Variables and Mutability”</a><!-- ignore --> section in Chapter 3. To make a variable mutable, we add <code>mut</code> before the variable name:</p>
<pre><code class="language-rust ignore">let apples = 5; // 불변
let mut bananas = 5; // 가변</code></pre>
<blockquote>
<p>참고: <code>//</code> 구문은 줄 끝까지 계속되는 주석을 시작합니다. 러스트는 주석의 모든 것을 무시합니다. 주석에 대해서는 <a href="ch03-04-comments.html">3장</a><!-- ignore -->에서 더 자세히 다룰 것입니다.</p>
</blockquote>
<p>추측 게임 프로그램으로 돌아가서, 이제 <code>let mut guess</code>가 <code>guess</code>라는 가변 변수를 도입한다는 것을 알게 되었습니다. 등호(<code>=</code>)는 러스트에게 지금 변수에 무언가를 바인딩하고 싶다고 알려줍니다. 등호 오른쪽에는 <code>guess</code>가 바인딩되는 값이 있는데, 이는 <code>String</code>의 새 인스턴스를 반환하는 함수인 <code>String::new</code>를 호출한 결과입니다. <a href="../std/string/struct.String.html"><code>String</code></a><!-- ignore -->은 표준 라이브러리에서 제공하는 문자열 타입으로, 커질 수 있는 UTF-8 인코딩된 텍스트 조각입니다.</p>
<p><code>::new</code> 줄의 <code>::</code> 구문은 <code>new</code>가 <code>String</code> 타입의 연관 함수임을 나타냅니다. _연관 함수_는 타입에 구현된 함수이며, 이 경우 <code>String</code>입니다. 이 <code>new</code> 함수는 새롭고 비어있는 문자열을 만듭니다. 많은 타입에서 <code>new</code> 함수를 찾을 수 있는데, 이는 어떤 종류의 새 값을 만드는 함수의 일반적인 이름이기 때문입니다.</p>
<p>전체적으로, <code>let mut guess = String::new();</code> 줄은 현재 <code>String</code>의 새롭고 비어있는 인스턴스에 바인딩된 가변 변수를 생성했습니다. 휴!</p>
<h3 id="사용자-입력-받기"><a class="header" href="#사용자-입력-받기">사용자 입력 받기</a></h3>
<p>프로그램의 첫 줄에 <code>use std::io;</code>로 표준 라이브러리에서 입출력 기능을 포함시켰던 것을 기억하세요. 이제 <code>io</code> 모듈에서 <code>stdin</code> 함수를 호출하여 사용자 입력을 처리할 수 있도록 할 것입니다:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    println!(추측을 입력하세요.);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span>    io::stdin()
        .read_line(&amp;mut guess)
<span class="boring">        .expect("줄 읽기 실패");
</span><span class="boring">
</span><span class="boring">    println!("당신의 추측: {guess}");
</span><span class="boring">}</span></code></pre>
<p>If we hadn’t imported the <code>io</code> module with <code>use std::io;</code> at the beginning of the program, we could still use the function by writing this function call as <code>std::io::stdin</code>. The <code>stdin</code> function returns an instance of <a href="../std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore -->, which is a type that represents a handle to the standard input for your terminal.</p>
<p>Next, the line <code>.read_line(&amp;mut guess)</code> calls the <a href="../std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a><!--
ignore --> method on the standard input handle to get input from the user. We’re also passing <code>&amp;mut guess</code> as the argument to <code>read_line</code> to tell it what string to store the user input in. The full job of <code>read_line</code> is to take whatever the user types into standard input and append that into a string (without overwriting its contents), so we therefore pass that string as an argument. The string argument needs to be mutable so that the method can change the string’s content.</p>
<p><code>&amp;</code>는 이 인수가 _참조_임을 나타내며, 이는 코드의 여러 부분이 데이터를 메모리에 여러 번 복사할 필요 없이 데이터 한 조각에 액세스할 수 있는 방법을 제공합니다. 참조는 복잡한 기능이며, 러스트의 주요 장점 중 하나는 참조를 사용하는 것이 얼마나 안전하고 쉬운가 하는 것입니다. 이 프로그램을 마치기 위해 이러한 세부 사항을 많이 알 필요는 없습니다. 지금은 변수와 마찬가지로 참조도 기본적으로 불변이라는 것만 알면 됩니다. 따라서 가변으로 만들려면 <code>&amp;guess</code>가 아닌 <code>&amp;mut guess</code>를 작성해야 합니다. (4장에서 참조에 대해 더 자세히 설명할 것입니다.)</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="handling-potential-failure-with-the-result-type"></a></p>
<h3 id="result로-잠재적-실패-처리하기"><a class="header" href="#result로-잠재적-실패-처리하기"><code>Result</code>로 잠재적 실패 처리하기</a></h3>
<p>우리는 아직 이 코드 라인에서 작업 중입니다. 이제 세 번째 텍스트 라인을 논의하고 있지만, 이것이 여전히 단일 논리적 코드 라인의 일부라는 점에 유의하세요. 다음 부분은 이 메서드입니다:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    println!(추측을 입력하세요.);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span>        .expect("줄 읽기 실패");
<span class="boring">
</span><span class="boring">    println!("당신의 추측: {guess}");
</span><span class="boring">}</span></code></pre>
<p>이 코드를 다음과 같이 작성할 수도 있었습니다:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess).expect("줄 읽기 실패");</code></pre>
<p>그러나 한 줄이 길면 읽기 어려우므로 나누는 것이 가장 좋습니다. <code>.method_name()</code> 구문으로 메서드를 호출할 때 긴 줄을 나누는 데 도움이 되도록 줄 바꿈 및 기타 공백을 도입하는 것이 현명할 때가 많습니다. 이제 이 줄이 무엇을 하는지 논의해 보겠습니다.</p>
<p>앞서 언급했듯이, <code>read_line</code>은 사용자가 입력하는 모든 것을 우리가 전달하는 문자열에 넣지만, <code>Result</code> 값도 반환합니다. <a href="../std/result/enum.Result.html"><code>Result</code></a><!--
무시 -->는 종종 _열거형_이라고 불리는 <a href="ch06-00-enums.html"><em>열거형</em></a><!-- 무시 -->이며, 여러 가능한 상태 중 하나일 수 있는 타입입니다. 우리는 각 가능한 상태를 _variant_라고 부릅니다.</p>
<p><a href="ch06-00-enums.html">6장</a><!-- ignore -->에서 열거형에 대해 더 자세히 다룰 것입니다. 이러한 <code>Result</code> 타입의 목적은 오류 처리 정보를 인코딩하는 것입니다.</p>
<p><code>Result</code>의 variant는 <code>Ok</code>와 <code>Err</code>입니다. <code>Ok</code> variant는 작업이 성공했음을 나타내며, 성공적으로 생성된 값을 포함합니다. <code>Err</code> variant는 작업이 실패했음을 의미하며, 작업이 실패한 방법이나 이유에 대한 정보를 포함합니다.</p>
<p>Values of the <code>Result</code> type, like values of any type, have methods defined on them. An instance of <code>Result</code> has an <a href="../std/result/enum.Result.html#method.expect"><code>expect</code> method</a><!-- ignore --> that you can call. If this instance of <code>Result</code> is an <code>Err</code> value, <code>expect</code> will cause the program to crash and display the message that you passed as an argument to <code>expect</code>. If the <code>read_line</code> method returns an <code>Err</code>, it would likely be the result of an error coming from the underlying operating system. If this instance of <code>Result</code> is an <code>Ok</code> value, <code>expect</code> will take the return value that <code>Ok</code> is holding and return just that value to you so that you can use it. In this case, that value is the number of bytes in the user’s input.</p>
<p><code>expect</code>를 호출하지 않으면 프로그램은 컴파일되지만, 경고가 표시됩니다:</p>
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `Result` that must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
10 |     let _ = io::stdin().read_line(&amp;mut guess);
   |     +++++++

warning: `guessing_game` (bin "guessing_game") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>러스트는 <code>read_line</code>에서 반환된 <code>Result</code> 값을 사용하지 않았다고 경고하며, 이는 프로그램이 가능한 오류를 처리하지 않았음을 나타냅니다.</p>
<p>경고를 억제하는 올바른 방법은 실제로 오류 처리 코드를 작성하는 것이지만, 이 경우에는 문제가 발생했을 때 프로그램을 충돌시키고 싶기 때문에 <code>expect</code>를 사용할 수 있습니다. 오류로부터 복구하는 방법에 대해서는 <a href="ch09-02-recoverable-errors-with-result.html">9장</a><!-- ignore -->에서 배울 것입니다.</p>
<h3 id="println-플레이스홀더로-값-출력하기"><a class="header" href="#println-플레이스홀더로-값-출력하기"><code>println!</code> 플레이스홀더로 값 출력하기</a></h3>
<p>닫는 중괄호를 제외하고, 지금까지 코드에서 논의할 줄은 한 줄 더 있습니다:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    println!(추측을 입력하세요.);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("줄 읽기 실패");
</span><span class="boring">
</span>    println!("당신의 추측: {guess}");
<span class="boring">}</span></code></pre>
<p>This line prints the string that now contains the user’s input. The <code>{}</code> set of curly brackets is a placeholder: Think of <code>{}</code> as little crab pincers that hold a value in place. When printing the value of a variable, the variable name can go inside the curly brackets. When printing the result of evaluating an expression, place empty curly brackets in the format string, then follow the format string with a comma-separated list of expressions to print in each empty curly bracket placeholder in the same order. Printing a variable and the result of an expression in one call to <code>println!</code> would look like this:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = 10;

println!("x = {x} and y + 2 = {}", y + 2);
<span class="boring">}</span></code></pre></pre>
<p>이 코드는 <code>x = 5 and y + 2 = 12</code>를 출력할 것입니다.</p>
<h3 id="첫-번째-부분-테스트하기"><a class="header" href="#첫-번째-부분-테스트하기">첫 번째 부분 테스트하기</a></h3>
<p>추측 게임의 첫 번째 부분을 테스트해 봅시다. <code>cargo run</code>을 사용하여 실행하세요:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-01/
cargo clean
cargo run
input 6 -->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
``````console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
</code></pre>
<p>At this point, the first part of the game is done: We’re getting input from the keyboard and then printing it.</p>
<h2 id="비밀-번호-생성하기"><a class="header" href="#비밀-번호-생성하기">비밀 번호 생성하기</a></h2>
<p>Next, we need to generate a secret number that the user will try to guess. The secret number should be different every time so that the game is fun to play more than once. We’ll use a random number between 1 and 100 so that the game isn’t too difficult. Rust doesn’t yet include random number functionality in its standard library. However, the Rust team does provide a <a href="https://crates.io/crates/rand"><code>rand</code> crate</a> with said functionality.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="using-a-crate-to-get-more-functionality"></a></p>
<h3 id="increasing-functionality-with-a-crate"><a class="header" href="#increasing-functionality-with-a-crate">Increasing Functionality with a Crate</a></h3>
<p>Remember that a crate is a collection of Rust source code files. The project we’ve been building is a binary crate, which is an executable. The <code>rand</code> crate is a library crate, which contains code that is intended to be used in other programs and can’t be executed on its own.</p>
<p>Cargo의 외부 크레이트 조정은 Cargo가 정말 빛을 발하는 부분입니다. <code>rand</code>를 사용하는 코드를 작성하기 전에, <code>rand</code> 크레이트를 의존성으로 포함하도록 <em>Cargo.toml</em> 파일을 수정해야 합니다. 지금 그 파일을 열고 Cargo가 생성한 <code>[dependencies]</code> 섹션 헤더 아래 맨 아래에 다음 줄을 추가하세요. 여기에 있는 버전 번호와 정확히 동일하게 <code>rand</code>를 지정해야 합니다. 그렇지 않으면 이 튜토리얼의 코드 예제가 작동하지 않을 수 있습니다:</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
* ch14-03-cargo-workspaces.md
-->
<p><span class="filename">파일명: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = "0.8.5"
</code></pre>
<p>In the <em>Cargo.toml</em> file, everything that follows a header is part of that section that continues until another section starts. In <code>[dependencies]</code>, you tell Cargo which external crates your project depends on and which versions of those crates you require. In this case, we specify the <code>rand</code> crate with the semantic version specifier <code>0.8.5</code>. Cargo understands <a href="http://semver.org">Semantic Versioning</a><!-- ignore --> (sometimes called <em>SemVer</em>), which is a standard for writing version numbers. The specifier <code>0.8.5</code> is actually shorthand for <code>^0.8.5</code>, which means any version that is at least 0.8.5 but below 0.9.0.</p>
<p>Cargo considers these versions to have public APIs compatible with version 0.8.5, and this specification ensures that you’ll get the latest patch release that will still compile with the code in this chapter. Any version 0.9.0 or greater is not guaranteed to have the same API as what the following examples use.</p>
<p>이제 코드를 변경하지 않고, 목록 2-2와 같이 프로젝트를 빌드해 보겠습니다.</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
rm Cargo.lock
cargo clean
cargo build -->
<Listing number="2-2" caption="The output from running `cargo build` after adding the `rand` crate as a dependency">
<pre><code class="language-console">$ cargo build
  Updating crates.io index
   Locking 15 packages to latest Rust 1.85.0 compatible versions
    Adding rand v0.8.5 (available: v0.9.0)
 Compiling proc-macro2 v1.0.93
 Compiling unicode-ident v1.0.17
 Compiling libc v0.2.170
 Compiling cfg-if v1.0.0
 Compiling byteorder v1.5.0
 Compiling getrandom v0.2.15
 Compiling rand_core v0.6.4
 Compiling quote v1.0.38
 Compiling syn v2.0.98
 Compiling zerocopy-derive v0.7.35
 Compiling zerocopy v0.7.35
 Compiling ppv-lite86 v0.2.20
 Compiling rand_chacha v0.3.1
 Compiling rand v0.8.5
 Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
  Finished `dev` profile [unoptimized + debuginfo] target(s) in 2.48s
</code></pre>
</Listing>
<p>다른 버전 번호(하지만 SemVer 덕분에 모두 코드와 호환됩니다!)와 다른 줄(운영 체제에 따라 다름)이 표시될 수 있으며, 줄 순서가 다를 수 있습니다.</p>
<p>외부 의존성을 포함하면, Cargo는 해당 의존성이 필요로 하는 모든 것의 최신 버전을 _레지스트리_에서 가져옵니다. 레지스트리는 <a href="https://crates.io/">Crates.io</a>의 데이터 사본입니다. Crates.io는 러스트 생태계의 사람들이 다른 사람들이 사용할 수 있도록 오픈 소스 러스트 프로젝트를 게시하는 곳입니다.</p>
<p>레지스트리를 업데이트한 후, Cargo는 <code>[dependencies]</code> 섹션을 확인하고 아직 다운로드되지 않은 모든 크레이트를 다운로드합니다. 이 경우, 우리는 <code>rand</code>만 의존성으로 나열했지만, Cargo는 <code>rand</code>가 작동하는 데 의존하는 다른 크레이트도 가져왔습니다. 크레이트를 다운로드한 후, 러스트는 그것들을 컴파일한 다음 사용 가능한 의존성으로 프로젝트를 컴파일합니다.</p>
<p>변경 사항 없이 즉시 <code>cargo build</code>를 다시 실행하면, <code>Finished</code> 줄 외에는 아무런 출력도 얻지 못할 것입니다. Cargo는 이미 의존성을 다운로드하고 컴파일했으며, <em>Cargo.toml</em> 파일에서 의존성에 대해 아무것도 변경하지 않았다는 것을 알고 있습니다. Cargo는 또한 코드에 대해 아무것도 변경하지 않았다는 것을 알고 있으므로, 그것도 다시 컴파일하지 않습니다. 할 일이 없으면, 그냥 종료됩니다.</p>
<p><em>src/main.rs</em> 파일을 열고, 사소한 변경을 한 다음, 저장하고 다시 빌드하면, 두 줄의 출력만 보게 될 것입니다:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
touch src/main.rs
cargo build -->
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s
</code></pre>
<p>이 줄들은 Cargo가 <em>src/main.rs</em> 파일에 대한 작은 변경 사항으로만 빌드를 업데이트한다는 것을 보여줍니다. 의존성은 변경되지 않았으므로, Cargo는 이미 다운로드하고 컴파일한 것을 재사용할 수 있다는 것을 알고 있습니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="ensuring-reproducible-builds-with-the-cargo-lock-file"></a></p>
<h4 id="ensuring-reproducible-builds"><a class="header" href="#ensuring-reproducible-builds">Ensuring Reproducible Builds</a></h4>
<p>Cargo has a mechanism that ensures that you can rebuild the same artifact every time you or anyone else builds your code: Cargo will use only the versions of the dependencies you specified until you indicate otherwise. For example, say that next week version 0.8.6 of the <code>rand</code> crate comes out, and that version contains an important bug fix, but it also contains a regression that will break your code. To handle this, Rust creates the <em>Cargo.lock</em> file the first time you run <code>cargo build</code>, so we now have this in the <em>guessing_game</em> directory.</p>
<p>프로젝트를 처음 빌드할 때, Cargo는 기준에 맞는 모든 의존성 버전을 파악한 다음 <em>Cargo.lock</em> 파일에 씁니다. 나중에 프로젝트를 빌드할 때, Cargo는 <em>Cargo.lock</em> 파일이 존재하는 것을 보고 버전 파악 작업을 다시 수행하는 대신 거기에 지정된 버전을 사용합니다. 이를 통해 자동으로 재현 가능한 빌드를 가질 수 있습니다. 즉, <em>Cargo.lock</em> 파일 덕분에 명시적으로 업그레이드할 때까지 프로젝트는 0.8.5 버전에 머물러 있을 것입니다. <em>Cargo.lock</em> 파일은 재현 가능한 빌드에 중요하기 때문에, 종종 프로젝트의 나머지 코드와 함께 소스 제어에 체크인됩니다.</p>
<h4 id="새-버전을-얻기-위해-크레이트-업데이트하기"><a class="header" href="#새-버전을-얻기-위해-크레이트-업데이트하기">새 버전을 얻기 위해 크레이트 업데이트하기</a></h4>
<p>When you <em>do</em> want to update a crate, Cargo provides the command <code>update</code>, which will ignore the <em>Cargo.lock</em> file and figure out all the latest versions that fit your specifications in <em>Cargo.toml</em>. Cargo will then write those versions to the <em>Cargo.lock</em> file. Otherwise, by default, Cargo will only look for versions greater than 0.8.5 and less than 0.9.0. If the <code>rand</code> crate has released the two new versions 0.8.6 and 0.999.0, you would see the following if you ran <code>cargo update</code>:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
cargo update
assuming there is a new 0.8.x version of rand; otherwise use another update
as a guide to creating the hypothetical output shown here -->
<pre><code class="language-console">$ cargo update
    Updating crates.io index
     Locking 1 package to latest Rust 1.85.0 compatible version
    Updating rand v0.8.5 -&gt; v0.8.6 (available: v0.999.0)
</code></pre>
<p>Cargo ignores the 0.999.0 release. At this point, you would also notice a change in your <em>Cargo.lock</em> file noting that the version of the <code>rand</code> crate you are now using is 0.8.6. To use <code>rand</code> version 0.999.0 or any version in the 0.999.<em>x</em> series, you’d have to update the <em>Cargo.toml</em> file to look like this instead (don’t actually make this change because the following examples assume you’re using <code>rand</code> 0.8):</p>
<pre><code class="language-toml">[dependencies]
rand = "0.999.0"
</code></pre>
<p>다음에 <code>cargo build</code>를 실행하면, Cargo는 사용 가능한 크레이트의 레지스트리를 업데이트하고 지정한 새 버전에 따라 <code>rand</code> 요구 사항을 다시 평가합니다.</p>
<p><a href="https://doc.rust-lang.org/cargo/">Cargo</a><!-- ignore -->와 <a href="https://doc.rust-lang.org/cargo/reference/publishing.html">그 생태계</a><!-- ignore -->에 대해 할 말이 더 많지만, 14장에서 논의할 것이고, 지금은 이것만 알면 됩니다. Cargo는 라이브러리를 매우 쉽게 재사용할 수 있게 해주므로, 러스트 개발자들은 여러 패키지로 조립된 더 작은 프로젝트를 작성할 수 있습니다.</p>
<h3 id="난수-생성하기"><a class="header" href="#난수-생성하기">난수 생성하기</a></h3>
<p><code>rand</code>를 사용하여 추측할 숫자를 생성해 보겠습니다. 다음 단계는 목록 2-3과 같이 _src/main.rs_를 업데이트하는 것입니다.</p>
<Listing number="2-3" file-name="src/main.rs" caption="Adding code to generate a random number">
<pre><code class="language-rust ignore">use std::io;

use rand::Rng;

fn main() {
    println!("숫자를 맞춰보세요!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    println!("비밀 번호는: {secret_number}");

    println!(추측을 입력하세요.);

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("줄 읽기 실패");

    println!("당신의 추측: {guess}");
}</code></pre>
</Listing>
<p>First, we add the line <code>use rand::Rng;</code>. The <code>Rng</code> trait defines methods that random number generators implement, and this trait must be in scope for us to use those methods. Chapter 10 will cover traits in detail.</p>
<p>Next, we’re adding two lines in the middle. In the first line, we call the <code>rand::thread_rng</code> function that gives us the particular random number generator we’re going to use: one that is local to the current thread of execution and is seeded by the operating system. Then, we call the <code>gen_range</code> method on the random number generator. This method is defined by the <code>Rng</code> trait that we brought into scope with the <code>use rand::Rng;</code> statement. The <code>gen_range</code> method takes a range expression as an argument and generates a random number in the range. The kind of range expression we’re using here takes the form <code>start..=end</code> and is inclusive on the lower and upper bounds, so we need to specify <code>1..=100</code> to request a number between 1 and 100.</p>
<blockquote>
<p>참고: 어떤 트레이트를 사용해야 하고, 어떤 메서드와 함수를 크레이트에서 호출해야 하는지 그냥 알 수는 없으므로, 각 크레이트에는 사용 지침이 포함된 문서가 있습니다. Cargo의 또 다른 멋진 기능은 <code>cargo doc --open</code> 명령을 실행하면 모든 의존성에서 제공하는 문서를 로컬에서 빌드하고 브라우저에서 열어준다는 것입니다. 예를 들어, <code>rand</code> 크레이트의 다른 기능에 관심이 있다면, <code>cargo doc --open</code>을 실행하고 왼쪽 사이드바에서 <code>rand</code>를 클릭하세요.</p>
</blockquote>
<p>두 번째 새 줄은 비밀 번호를 출력합니다. 이것은 프로그램을 개발하는 동안 테스트할 수 있도록 유용하지만, 최종 버전에서는 삭제할 것입니다. 프로그램이 시작하자마자 답을 출력하면 게임이 별로 재미없으니까요!</p>
<p>프로그램을 몇 번 실행해보세요:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-03/
cargo run
4
cargo run
5
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4

$ cargo run
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
</code></pre>
<p>다른 난수를 얻어야 하며, 모두 1에서 100 사이의 숫자여야 합니다. 잘했습니다!</p>
<h2 id="추측을-비밀-번호와-비교하기"><a class="header" href="#추측을-비밀-번호와-비교하기">추측을 비밀 번호와 비교하기</a></h2>
<p>이제 사용자 입력과 난수가 있으므로 비교할 수 있습니다. 그 단계는 목록 2-4에 나와 있습니다. 설명하겠지만, 이 코드는 아직 컴파일되지 않습니다.</p>
<Listing number="2-4" file-name="src/main.rs" caption="Handling the possible return values of comparing two numbers">
<pre><code class="language-rust ignore does_not_compile">use std::cmp::Ordering;
use std::io;

use rand::Rng;

fn main() {
    // --생략--
<span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("비밀 번호는: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!(추측을 입력하세요.);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("줄 읽기 실패");
</span>
    println!("당신의 추측: {guess}");

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!("너무 작아요!"),
        Ordering::Greater =&gt; println!("너무 커요!"),
        Ordering::Equal =&gt; println!("당신이 이겼습니다!"),
    }
}</code></pre>
</Listing>
<p>First, we add another <code>use</code> statement, bringing a type called <code>std::cmp::Ordering</code> into scope from the standard library. The <code>Ordering</code> type is another enum and has the variants <code>Less</code>, <code>Greater</code>, and <code>Equal</code>. These are the three outcomes that are possible when you compare two values.</p>
<p>Then, we add five new lines at the bottom that use the <code>Ordering</code> type. The <code>cmp</code> method compares two values and can be called on anything that can be compared. It takes a reference to whatever you want to compare with: Here, it’s comparing <code>guess</code> to <code>secret_number</code>. Then, it returns a variant of the <code>Ordering</code> enum we brought into scope with the <code>use</code> statement. We use a <a href="ch06-02-match.html"><code>match</code></a><!-- ignore --> expression to decide what to do next based on which variant of <code>Ordering</code> was returned from the call to <code>cmp</code> with the values in <code>guess</code> and <code>secret_number</code>.</p>
<p>A <code>match</code> expression is made up of <em>arms</em>. An arm consists of a <em>pattern</em> to match against, and the code that should be run if the value given to <code>match</code> fits that arm’s pattern. Rust takes the value given to <code>match</code> and looks through each arm’s pattern in turn. Patterns and the <code>match</code> construct are powerful Rust features: They let you express a variety of situations your code might encounter, and they make sure you handle them all. These features will be covered in detail in Chapter 6 and Chapter 19, respectively.</p>
<p>여기서 사용하는 <code>match</code> 표현식의 예를 살펴보겠습니다. 사용자가 50을 추측했고 이번에 무작위로 생성된 비밀 번호가 38이라고 가정해 보겠습니다.</p>
<p>코드가 50을 38과 비교할 때, <code>cmp</code> 메서드는 50이 38보다 크기 때문에 <code>Ordering::Greater</code>를 반환합니다. <code>match</code> 표현식은 <code>Ordering::Greater</code> 값을 얻고 각 arm의 패턴을 확인하기 시작합니다. 첫 번째 arm의 패턴인 <code>Ordering::Less</code>를 보고, <code>Ordering::Greater</code> 값이 <code>Ordering::Less</code>와 일치하지 않음을 확인하고, 해당 arm의 코드를 무시하고 다음 arm으로 이동합니다. 다음 arm의 패턴은 <code>Ordering::Greater</code>이며, 이는 <code>Ordering::Greater</code>와 <em>일치합니다</em>! 해당 arm의 연관 코드가 실행되고 화면에 <code>Too big!</code>을 출력합니다. <code>match</code> 표현식은 첫 번째 성공적인 매치 후에 종료되므로, 이 시나리오에서는 마지막 arm을 보지 않습니다.</p>
<p>그러나 목록 2-4의 코드는 아직 컴파일되지 않습니다. 시도해 보겠습니다:</p>
<!--
The error numbers in this output should be that of the code **WITHOUT** the
anchor or snip comments
-->
<pre><code class="language-console">$ cargo build
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_core v0.6.2
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  --&gt; src/main.rs:23:21
   |
23 |     match guess.cmp(&amp;secret_number) {
   |                 --- ^^^^^^^^^^^^^^ expected `&amp;String`, found `&amp;{integer}`
   |                 |
   |                 arguments to this method are incorrect
   |
   = note: expected reference `&amp;String`
              found reference `&amp;{integer}`
note: method defined here
  --&gt; /rustc/1159e78c4747b02ef996e55082b704c09b970588/library/core/src/cmp.rs:979:8

For more information about this error, try `rustc --explain E0308`.
error: could not compile `guessing_game` (bin "guessing_game") due to 1 previous error
</code></pre>
<p>오류의 핵심은 _일치하지 않는 타입_이 있다는 것입니다. 러스트는 강력한 정적 타입 시스템을 가지고 있습니다. 그러나 타입 추론도 가지고 있습니다. <code>let mut guess = String::new()</code>를 작성했을 때, 러스트는 <code>guess</code>가 <code>String</code>이어야 한다고 추론할 수 있었고, 우리가 타입을 작성하도록 강요하지 않았습니다. 반면에 <code>secret_number</code>는 숫자 타입입니다. 러스트의 몇 가지 숫자 타입은 1에서 100 사이의 값을 가질 수 있습니다: <code>i32</code>, 32비트 숫자; <code>u32</code>, 부호 없는 32비트 숫자; <code>i64</code>, 64비트 숫자; 등등. 달리 명시하지 않는 한, 러스트는 <code>i32</code>를 기본값으로 사용하며, 다른 곳에서 러스트가 다른 숫자 타입을 추론하도록 하는 타입 정보를 추가하지 않는 한 <code>secret_number</code>의 타입입니다. 오류의 이유는 러스트가 문자열과 숫자 타입을 비교할 수 없기 때문입니다.</p>
<p>Ultimately, we want to convert the <code>String</code> the program reads as input into a number type so that we can compare it numerically to the secret number. We do so by adding this line to the <code>main</code> function body:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">use rand::Rng;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("비밀 번호는: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!(추측을 입력하세요.);
</span><span class="boring">
</span>    // --생략--

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("줄 읽기 실패");

    let guess: u32 = guess.trim().parse().expect("숫자를 입력해주세요!");

    println!("당신의 추측: {guess}");

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!("너무 작아요!"),
        Ordering::Greater =&gt; println!("너무 커요!"),
        Ordering::Equal =&gt; println!("당신이 이겼습니다!"),
    }
<span class="boring">}</span></code></pre>
<p>해당 줄은 다음과 같습니다:</p>
<pre><code class="language-rust ignore">let guess: u32 = guess.trim().parse().expect("숫자를 입력해주세요!");</code></pre>
<p><code>guess</code>라는 이름의 변수를 만듭니다. 하지만 잠깐, 프로그램에 이미 <code>guess</code>라는 이름의 변수가 있지 않나요? 그렇습니다. 하지만 고맙게도 러스트는 이전 <code>guess</code> 값을 새 값으로 섀도잉할 수 있도록 허용합니다. _섀도잉_을 사용하면 예를 들어 <code>guess_str</code>과 <code>guess</code>와 같이 두 개의 고유한 변수를 만들도록 강요하는 대신 <code>guess</code> 변수 이름을 재사용할 수 있습니다. 이에 대해서는 <a href="ch03-01-variables-and-mutability.html#shadowing">3장</a><!-- ignore -->에서 더 자세히 다룰 것이지만, 지금은 이 기능이 한 타입의 값을 다른 타입으로 변환하고 싶을 때 자주 사용된다는 점만 알아두세요.</p>
<p>우리는 이 새로운 변수를 <code>guess.trim().parse()</code> 표현식에 바인딩합니다. 표현식의 <code>guess</code>는 입력값을 문자열로 담고 있던 원래 <code>guess</code> 변수를 가리킵니다. <code>String</code> 인스턴스의 <code>trim</code> 메서드는 시작과 끝의 모든 공백을 제거합니다. 이는 문자열을 숫자 데이터만 담을 수 있는 <code>u32</code>로 변환하기 전에 반드시 해야 하는 작업입니다. 사용자가 <code>read_line</code>을 만족시키고 추측값을 입력하려면 <kbd>enter</kbd>를 눌러야 하는데, 이때 문자열에 줄바꿈 문자가 추가됩니다. 예를 들어, 사용자가 <kbd>5</kbd>를 입력하고 <kbd>enter</kbd>를 누르면 <code>guess</code>는 <code>5\n</code>과 같이 보입니다. <code>\n</code>은 '줄바꿈'을 나타냅니다. (윈도우에서 <kbd>enter</kbd>를 누르면 캐리지 리턴과 줄바꿈인 <code>\r\n</code>이 발생합니다.) <code>trim</code> 메서드는 <code>\n</code> 또는 <code>\r\n</code>을 제거하여 딱 <code>5</code>만 남게 합니다.</p>
<p>문자열의 <a href="../std/primitive.str.html#method.parse"><code>parse</code> 메서드</a><!-- ignore -->는 문자열을 다른 타입으로 변환합니다. 여기서는 문자열을 숫자로 변환하는 데 사용합니다. <code>let guess: u32</code>를 사용하여 러스트에게 우리가 원하는 정확한 숫자 타입을 알려줄 필요가 있습니다. <code>guess</code> 뒤의 콜론(<code>:</code>)은 변수의 타입을 어노테이션할 것임을 러스트에게 알려줍니다. 러스트에는 몇 가지 내장된 숫자 타입이 있습니다. 여기서 보는 <code>u32</code>는 부호 없는 32비트 정수입니다. 이는 작은 양수에 대한 좋은 기본 선택입니다. <a href="ch03-02-data-types.html#integer-types">3장</a><!-- ignore -->에서 다른 숫자 타입에 대해 배우게 될 것입니다.</p>
<p>Additionally, the <code>u32</code> annotation in this example program and the comparison with <code>secret_number</code> means Rust will infer that <code>secret_number</code> should be a <code>u32</code> as well. So, now the comparison will be between two values of the same type!</p>
<p>The <code>parse</code> method will only work on characters that can logically be converted into numbers and so can easily cause errors. If, for example, the string contained <code>A👍%</code>, there would be no way to convert that to a number. Because it might fail, the <code>parse</code> method returns a <code>Result</code> type, much as the <code>read_line</code> method does (discussed earlier in <a href="#handling-potential-failure-with-result">“Handling Potential Failure with <code>Result</code>”</a><!-- ignore -->). We’ll treat this <code>Result</code> the same way by using the <code>expect</code> method again. If <code>parse</code> returns an <code>Err</code> <code>Result</code> variant because it couldn’t create a number from the string, the <code>expect</code> call will crash the game and print the message we give it. If <code>parse</code> can successfully convert the string to a number, it will return the <code>Ok</code> variant of <code>Result</code>, and <code>expect</code> will return the number that we want from the <code>Ok</code> value.</p>
<p>이제 프로그램을 실행해 봅시다:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/
touch src/main.rs
cargo run
  76
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.26s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
</code></pre>
<p>Nice! Even though spaces were added before the guess, the program still figured out that the user guessed 76. Run the program a few times to verify the different behavior with different kinds of input: Guess the number correctly, guess a number that is too high, and guess a number that is too low.</p>
<p>이제 대부분의 게임이 작동하지만, 사용자는 한 번만 추측할 수 있습니다. 반복문을 추가하여 그것을 변경해 봅시다!</p>
<h2 id="반복문으로-여러-번-추측-허용하기"><a class="header" href="#반복문으로-여러-번-추측-허용하기">반복문으로 여러 번 추측 허용하기</a></h2>
<p><code>loop</code> 키워드는 무한 루프를 만듭니다. 사용자가 숫자를 추측할 기회를 더 많이 주기 위해 루프를 추가할 것입니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">use rand::Rng;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    // --생략--

    println!("비밀 번호는: {secret_number}");

    loop {
        println!(추측을 입력하세요.);

        // --생략--

<span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("줄 읽기 실패");
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect("숫자를 입력해주세요!");
</span><span class="boring">
</span><span class="boring">        println!("당신의 추측: {guess}");
</span><span class="boring">
</span>        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("너무 작아요!"),
            Ordering::Greater =&gt; println!("너무 커요!"),
            Ordering::Equal =&gt; println!("당신이 이겼습니다!"),
        }
    }
}</code></pre>
<p>보시다시피, 추측 입력 프롬프트부터 모든 것을 루프 안으로 옮겼습니다. 루프 안의 줄들을 각각 네 칸씩 더 들여쓰고 프로그램을 다시 실행하세요. 이제 프로그램은 영원히 다른 추측을 요구할 것이며, 이는 실제로 새로운 문제를 야기합니다. 사용자가 종료할 수 없는 것 같습니다!</p>
<p>The user could always interrupt the program by using the keyboard shortcut <kbd>ctrl</kbd>-<kbd>C</kbd>. But there’s another way to escape this insatiable monster, as mentioned in the <code>parse</code> discussion in <a href="#comparing-the-guess-to-the-secret-number">“Comparing the Guess to the Secret Number”</a><!-- ignore -->: If the user enters a non-number answer, the program will crash. We can take advantage of that to allow the user to quit, as shown here:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-04-looping/
touch src/main.rs
cargo run
(too small guess)
(too big guess)
(correct guess)
quit
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.23s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit

thread 'main' panicked at src/main.rs:28:47:
Please type a number!: ParseIntError { kind: InvalidDigit }
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p><code>quit</code>을 입력하면 게임이 종료되지만, 눈치채셨겠지만, 다른 숫자가 아닌 입력을 입력해도 마찬가지입니다. 이것은 좋지 않은 방법입니다. 우리는 정답을 맞췄을 때도 게임이 멈추기를 원합니다.</p>
<h3 id="정답-맞춘-후-종료하기"><a class="header" href="#정답-맞춘-후-종료하기">정답 맞춘 후 종료하기</a></h3>
<p><code>break</code> 문을 추가하여 사용자가 이겼을 때 게임이 종료되도록 프로그래밍해 봅시다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">use rand::Rng;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("비밀 번호는: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(추측을 입력하세요.);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("줄 읽기 실패");
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect("숫자를 입력해주세요!");
</span><span class="boring">
</span><span class="boring">        println!("당신의 추측: {guess}");
</span><span class="boring">
</span>        // --생략--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("너무 작아요!"),
            Ordering::Greater =&gt; println!("너무 커요!"),
            Ordering::Equal =&gt; {
                println!("당신이 이겼습니다!");
                break;
            }
        }
    }
}</code></pre>
<p><code>You win!</code> 뒤에 <code>break</code> 줄을 추가하면 사용자가 비밀 번호를 정확하게 추측했을 때 프로그램이 루프를 종료합니다. 루프를 종료하는 것은 또한 프로그램을 종료하는 것을 의미합니다. 왜냐하면 루프는 <code>main</code>의 마지막 부분이기 때문입니다.</p>
<h3 id="잘못된-입력-처리하기"><a class="header" href="#잘못된-입력-처리하기">잘못된 입력 처리하기</a></h3>
<p>To further refine the game’s behavior, rather than crashing the program when the user inputs a non-number, let’s make the game ignore a non-number so that the user can continue guessing. We can do that by altering the line where <code>guess</code> is converted from a <code>String</code> to a <code>u32</code>, as shown in Listing 2-5.</p>
<Listing number="2-5" file-name="src/main.rs" caption="Ignoring a non-number guess and asking for another guess instead of crashing the program">
<pre><code class="language-rust ignore"><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">use rand::Rng;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("비밀 번호는: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(추측을 입력하세요.);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span>        // --생략--

        io::stdin()
            .read_line(&amp;mut guess)
            .expect("줄 읽기 실패");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!("당신의 추측: {guess}");

        // --생략--
<span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!("너무 작아요!"),
</span><span class="boring">            Ordering::Greater =&gt; println!("너무 커요!"),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!("당신이 이겼습니다!");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>오류 발생 시 충돌하는 것에서 오류를 처리하는 것으로 이동하기 위해 <code>expect</code> 호출에서 <code>match</code> 표현식으로 전환합니다. <code>parse</code>가 <code>Result</code> 타입을 반환하고 <code>Result</code>가 <code>Ok</code>와 <code>Err</code> variant를 갖는 열거형임을 기억하세요. <code>cmp</code> 메서드의 <code>Ordering</code> 결과와 마찬가지로 여기서도 <code>match</code> 표현식을 사용하고 있습니다.</p>
<p><code>parse</code>가 문자열을 숫자로 성공적으로 변환할 수 있으면, 결과 숫자를 포함하는 <code>Ok</code> 값을 반환합니다. 해당 <code>Ok</code> 값은 첫 번째 arm의 패턴과 일치하며, <code>match</code> 표현식은 <code>parse</code>가 생성하여 <code>Ok</code> 값 안에 넣은 <code>num</code> 값을 반환합니다. 그 숫자는 우리가 생성하는 새 <code>guess</code> 변수에서 원하는 바로 그 위치에 있게 됩니다.</p>
<p>If <code>parse</code> is <em>not</em> able to turn the string into a number, it will return an <code>Err</code> value that contains more information about the error. The <code>Err</code> value does not match the <code>Ok(num)</code> pattern in the first <code>match</code> arm, but it does match the <code>Err(_)</code> pattern in the second arm. The underscore, <code>_</code>, is a catch-all value; in this example, we’re saying we want to match all <code>Err</code> values, no matter what information they have inside them. So, the program will execute the second arm’s code, <code>continue</code>, which tells the program to go to the next iteration of the <code>loop</code> and ask for another guess. So, effectively, the program ignores all errors that <code>parse</code> might encounter!</p>
<p>이제 프로그램의 모든 것이 예상대로 작동해야 합니다. 시도해 보겠습니다:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-05/
cargo run
(too small guess)
(too big guess)
foo
(correct guess)
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
</code></pre>
<p>멋지네요! 마지막으로 작은 수정 하나만 더 하면 추측 게임을 완성할 수 있습니다. 프로그램이 여전히 비밀 번호를 출력하고 있다는 것을 기억하세요. 테스트에는 효과적이었지만, 게임의 재미를 망칩니다. 비밀 번호를 출력하는 <code>println!</code>을 삭제합시다. 목록 2-6은 최종 코드를 보여줍니다.</p>
<Listing number="2-6" file-name="src/main.rs" caption="Complete guessing game code">
<pre><code class="language-rust ignore">use std::cmp::Ordering;
use std::io;

use rand::Rng;

fn main() {
    println!("숫자를 맞춰보세요!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    loop {
        println!(추측을 입력하세요.);

        let mut guess = String::new();

        io::stdin()
            .read_line(&amp;mut guess)
            .expect("줄 읽기 실패");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!("당신의 추측: {guess}");

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("너무 작아요!"),
            Ordering::Greater =&gt; println!("너무 커요!"),
            Ordering::Equal =&gt; {
                println!("당신이 이겼습니다!");
                break;
            }
        }
    }
}</code></pre>
</Listing>
<p>이 시점에서, 당신은 성공적으로 추측 게임을 만들었습니다. 축하합니다!</p>
<h2 id="요약"><a class="header" href="#요약">요약</a></h2>
<p>이 프로젝트는 <code>let</code>, <code>match</code>, 함수, 외부 크레이트 사용 등 많은 새로운 러스트 개념을 소개하는 실습 방법이었습니다. 다음 몇 장에서는 이러한 개념에 대해 더 자세히 배울 것입니다. 3장에서는 변수, 데이터 타입, 함수와 같이 대부분의 프로그래밍 언어가 가지고 있는 개념을 다루고, 러스트에서 사용하는 방법을 보여줍니다. 4장에서는 러스트를 다른 언어와 다르게 만드는 기능인 소유권을 탐구합니다. 5장에서는 구조체와 메서드 구문을 논의하고, 6장에서는 열거형이 어떻게 작동하는지 설명합니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch01-03-hello-cargo.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch03-00-common-programming-concepts.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch01-03-hello-cargo.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch03-00-common-programming-concepts.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
