<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>추측 게임 프로그래밍 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch02-00-guessing-game-tutorial.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch02-00-guessing-game-tutorial.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="추측-게임-프로그래밍"><a class="header" href="#추측-게임-프로그래밍">추측 게임 프로그래밍</a></h1>
<p>함께 실습 프로젝트를 통해 Rust에 뛰어들어 봅시다! 이 장에서는 몇 가지 일반적인 Rust 개념을 실제 프로그램에서 사용하는 방법을 보여줌으로써 소개합니다. <code>let</code>, <code>match</code>, 메서드, 연관 함수, 외부 크레이트 등에 대해 배울 것입니다! 다음 장에서는 이러한 아이디어를 더 자세히 탐구할 것입니다. 이 장에서는 기본 사항만 연습할 것입니다.</p>
<p>고전적인 초보자 프로그래밍 문제인 숫자 맞추기 게임을 구현할 것입니다. 작동 방식은 다음과 같습니다. 프로그램은 1에서 100 사이의 무작위 정수를 생성합니다. 그런 다음 플레이어에게 추측을 입력하라는 메시지를 표시합니다. 추측이 입력되면 프로그램은 추측이 너무 낮은지 또는 너무 높은지 나타냅니다. 추측이 맞으면 게임은 축하 메시지를 인쇄하고 종료합니다.</p>
<h2 id="새-프로젝트-설정하기"><a class="header" href="#새-프로젝트-설정하기">새 프로젝트 설정하기</a></h2>
<p>새 프로젝트를 설정하려면 1장에서 만든 <em>projects</em> 디렉토리로 이동하여 Cargo를 사용하여 새 프로젝트를 만드세요. 다음과 같이요:</p>
<pre><code class="language-console">$ cargo new guessing_game
$ cd guessing_game
</code></pre>
<p>첫 번째 명령인 <code>cargo new</code>는 프로젝트 이름(<code>guessing_game</code>)을 첫 번째 인수로 받습니다. 두 번째 명령은 새 프로젝트 디렉토리로 변경합니다.</p>
<p>생성된 <em>Cargo.toml</em> 파일을 살펴보세요:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial
rm -rf no-listing-01-cargo-new
cargo new no-listing-01-cargo-new --name guessing_game
cd no-listing-01-cargo-new
cargo run > output.txt 2>&1
cd ../../..
-->
<p><span class="filename">파일명: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = "guessing_game"
version = "0.1.0"
edition = "2021"

[dependencies]
</code></pre>
<p>1장에서 보았듯이 <code>cargo new</code>는 "Hello, world!" 프로그램을 생성합니다. <em>src/main.rs</em> 파일을 확인하세요:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    println!("헬로, 월드!");
}</code></pre></pre>
<p>이제 <code>cargo run</code> 명령을 사용하여 이 "Hello, world!" 프로그램을 컴파일하고 같은 단계에서 실행해 봅시다:</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.20s
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
<p><code>run</code> 명령은 이 게임에서처럼 프로젝트를 빠르게 반복해야 할 때 유용합니다. 다음 반복으로 넘어가기 전에 각 반복을 빠르게 테스트합니다.</p>
<p><em>src/main.rs</em> 파일을 다시 여세요. 이 파일에 모든 코드를 작성할 것입니다.</p>
<h2 id="추측-처리하기"><a class="header" href="#추측-처리하기">추측 처리하기</a></h2>
<p>추측 게임 프로그램의 첫 번째 부분은 사용자 입력을 요청하고, 그 입력을 처리하고, 입력이 예상된 형식인지 확인합니다. 시작하려면, 플레이어가 추측을 입력하도록 허용할 것입니다. 목록 2-1의 코드를 _src/main.rs_에 입력하세요.</p>
<Listing number="2-1" file-name="src/main.rs" caption="Code that gets a guess from the user and prints it">
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!("숫자를 맞춰보세요!");

    println!(추측을 입력하세요.);

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("줄 읽기 실패");

    println!("당신의 추측: {}", guess);
}</code></pre>
</Listing>
<p>이 코드는 많은 정보를 담고 있으므로, 한 줄씩 살펴보겠습니다. 사용자 입력을 받고 그 결과를 출력으로 인쇄하려면, <code>io</code> 입출력 라이브러리를 스코프로 가져와야 합니다. <code>io</code> 라이브러리는 <code>std</code>로 알려진 표준 라이브러리에서 제공됩니다:</p>
<pre><code class="language-rust ignore">use std::io;
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    println!(추측을 입력하세요.);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("줄 읽기 실패");
</span><span class="boring">
</span><span class="boring">    println!("당신의 추측: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>기본적으로, 러스트는 모든 프로그램의 스코프로 가져오는 표준 라이브러리에 정의된 아이템 세트를 가지고 있습니다. 이 세트를 _프렐류드_라고 하며, <a href="../std/prelude/index.html">표준 라이브러리 문서</a>에서 모든 것을 볼 수 있습니다.</p>
<p>사용하려는 타입이 프렐류드에 없으면, <code>use</code> 문을 사용하여 해당 타입을 명시적으로 스코프로 가져와야 합니다. <code>std::io</code> 라이브러리를 사용하면 사용자 입력을 받는 기능을 포함하여 여러 유용한 기능을 사용할 수 있습니다.</p>
<p>1장에서 보았듯이, <code>main</code> 함수는 프로그램의 진입점입니다:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span>fn main() {
<span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    println!(추측을 입력하세요.);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("줄 읽기 실패");
</span><span class="boring">
</span><span class="boring">    println!("당신의 추측: {}", guess);
</span><span class="boring">}</span></code></pre>
<p><code>fn</code> 구문은 새 함수를 선언하고, 괄호 <code>()</code>는 매개변수가 없음을 나타내며, 중괄호 <code>{</code>는 함수 본문의 시작을 나타냅니다.</p>
<p>1장에서 배운 것처럼, <code>println!</code>은 화면에 문자열을 출력하는 매크로입니다:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    println!("숫자를 맞춰보세요!");

    println!(추측을 입력하세요.);
<span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("줄 읽기 실패");
</span><span class="boring">
</span><span class="boring">    println!("당신의 추측: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>이 코드는 게임이 무엇인지 알리고 사용자로부터 입력을 요청하는 프롬프트를 출력합니다.</p>
<h3 id="변수로-값-저장하기"><a class="header" href="#변수로-값-저장하기">변수로 값 저장하기</a></h3>
<p>다음으로, 사용자 입력을 저장할 _변수_를 다음과 같이 생성합니다:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    println!(추측을 입력하세요.);
</span><span class="boring">
</span>    let mut guess = String::new();
<span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("줄 읽기 실패");
</span><span class="boring">
</span><span class="boring">    println!("당신의 추측: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>이제 프로그램이 흥미로워졌습니다! 이 작은 한 줄에 많은 일이 일어나고 있습니다. <code>let</code> 문을 사용하여 변수를 생성합니다. 다음은 또 다른 예입니다:</p>
<pre><code class="language-rust ignore">let apples = 5;</code></pre>
<p>이 줄은 <code>apples</code>라는 새 변수를 만들고 값 5에 바인딩합니다. 러스트에서 변수는 기본적으로 불변이므로, 일단 변수에 값을 주면 그 값은 변하지 않습니다. 이 개념에 대해서는 3장의 <a href="ch03-01-variables-and-mutability.html#variables-and-mutability">“변수와 가변성”</a><!-- ignore --> 섹션에서 자세히 다룰 것입니다. 변수를 가변으로 만들려면, 변수 이름 앞에 <code>mut</code>를 추가합니다:</p>
<pre><code class="language-rust ignore">let apples = 5; // 불변
let mut bananas = 5; // 가변</code></pre>
<blockquote>
<p>참고: <code>//</code> 구문은 줄 끝까지 계속되는 주석을 시작합니다. 러스트는 주석의 모든 것을 무시합니다. 주석에 대해서는 <a href="ch03-04-comments.html">3장</a><!-- ignore -->에서 더 자세히 다룰 것입니다.</p>
</blockquote>
<p>추측 게임 프로그램으로 돌아가서, 이제 <code>let mut guess</code>가 <code>guess</code>라는 가변 변수를 도입한다는 것을 알게 되었습니다. 등호(<code>=</code>)는 러스트에게 지금 변수에 무언가를 바인딩하고 싶다고 알려줍니다. 등호 오른쪽에는 <code>guess</code>가 바인딩되는 값이 있는데, 이는 <code>String</code>의 새 인스턴스를 반환하는 함수인 <code>String::new</code>를 호출한 결과입니다. <a href="../std/string/struct.String.html"><code>String</code></a><!-- ignore -->은 표준 라이브러리에서 제공하는 문자열 타입으로, 커질 수 있는 UTF-8 인코딩된 텍스트 조각입니다.</p>
<p><code>::new</code> 줄의 <code>::</code> 구문은 <code>new</code>가 <code>String</code> 타입의 연관 함수임을 나타냅니다. _연관 함수_는 타입에 구현된 함수이며, 이 경우 <code>String</code>입니다. 이 <code>new</code> 함수는 새롭고 비어있는 문자열을 만듭니다. 많은 타입에서 <code>new</code> 함수를 찾을 수 있는데, 이는 어떤 종류의 새 값을 만드는 함수의 일반적인 이름이기 때문입니다.</p>
<p>전체적으로, <code>let mut guess = String::new();</code> 줄은 현재 <code>String</code>의 새롭고 비어있는 인스턴스에 바인딩된 가변 변수를 생성했습니다. 휴!</p>
<h3 id="사용자-입력-받기"><a class="header" href="#사용자-입력-받기">사용자 입력 받기</a></h3>
<p>프로그램의 첫 줄에 <code>use std::io;</code>로 표준 라이브러리에서 입출력 기능을 포함시켰던 것을 기억하세요. 이제 <code>io</code> 모듈에서 <code>stdin</code> 함수를 호출하여 사용자 입력을 처리할 수 있도록 할 것입니다:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    println!(추측을 입력하세요.);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span>    io::stdin()
        .read_line(&amp;mut guess)
<span class="boring">        .expect("줄 읽기 실패");
</span><span class="boring">
</span><span class="boring">    println!("당신의 추측: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>만약 프로그램 시작 부분에 <code>use std::io;</code>로 <code>io</code> 라이브러리를 가져오지 않았다면, 이 함수 호출을 <code>std::io::stdin</code>으로 작성하여 함수를 계속 사용할 수 있습니다. <code>stdin</code> 함수는 터미널의 표준 입력을 나타내는 타입인 <a href="../std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore -->의 인스턴스를 반환합니다.</p>
<p>다음으로, <code>.read_line(&amp;mut guess)</code> 줄은 표준 입력 핸들에서 <a href="../std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a><!--
무시 --> 메서드를 호출하여 사용자로부터 입력을 받습니다. 또한 <code>read_line</code>에 <code>&amp;mut guess</code>를 인수로 전달하여 사용자 입력을 저장할 문자열을 알려줍니다. <code>read_line</code>의 전체 작업은 사용자가 표준 입력에 입력하는 모든 것을 가져와 문자열에 추가하는 것(내용을 덮어쓰지 않고)이므로, 따라서 해당 문자열을 인수로 전달합니다. 메서드가 문자열의 내용을 변경할 수 있도록 문자열 인수는 가변적이어야 합니다.</p>
<p><code>&amp;</code>는 이 인수가 _참조_임을 나타내며, 이는 코드의 여러 부분이 데이터를 메모리에 여러 번 복사할 필요 없이 데이터 한 조각에 액세스할 수 있는 방법을 제공합니다. 참조는 복잡한 기능이며, 러스트의 주요 장점 중 하나는 참조를 사용하는 것이 얼마나 안전하고 쉬운가 하는 것입니다. 이 프로그램을 마치기 위해 이러한 세부 사항을 많이 알 필요는 없습니다. 지금은 변수와 마찬가지로 참조도 기본적으로 불변이라는 것만 알면 됩니다. 따라서 가변으로 만들려면 <code>&amp;guess</code>가 아닌 <code>&amp;mut guess</code>를 작성해야 합니다. (4장에서 참조에 대해 더 자세히 설명할 것입니다.)</p>
<!-- Old heading. Do not remove or links may break. -->
<p><a id="handling-potential-failure-with-the-result-type"></a></p>
<h3 id="result로-잠재적-실패-처리하기"><a class="header" href="#result로-잠재적-실패-처리하기"><code>Result</code>로 잠재적 실패 처리하기</a></h3>
<p>우리는 아직 이 코드 라인에서 작업 중입니다. 이제 세 번째 텍스트 라인을 논의하고 있지만, 이것이 여전히 단일 논리적 코드 라인의 일부라는 점에 유의하세요. 다음 부분은 이 메서드입니다:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    println!(추측을 입력하세요.);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span>        .expect("줄 읽기 실패");
<span class="boring">
</span><span class="boring">    println!("당신의 추측: {}", guess);
</span><span class="boring">}</span></code></pre>
<p>이 코드를 다음과 같이 작성할 수도 있었습니다:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess).expect("줄 읽기 실패");</code></pre>
<p>그러나 한 줄이 길면 읽기 어려우므로 나누는 것이 가장 좋습니다. <code>.method_name()</code> 구문으로 메서드를 호출할 때 긴 줄을 나누는 데 도움이 되도록 줄 바꿈 및 기타 공백을 도입하는 것이 현명할 때가 많습니다. 이제 이 줄이 무엇을 하는지 논의해 보겠습니다.</p>
<p>앞서 언급했듯이, <code>read_line</code>은 사용자가 입력하는 모든 것을 우리가 전달하는 문자열에 넣지만, <code>Result</code> 값도 반환합니다. <a href="../std/result/enum.Result.html"><code>Result</code></a><!--
무시 -->는 종종 _열거형_이라고 불리는 <a href="ch06-00-enums.html"><em>열거형</em></a><!-- 무시 -->이며, 여러 가능한 상태 중 하나일 수 있는 타입입니다. 우리는 각 가능한 상태를 _variant_라고 부릅니다.</p>
<p><a href="ch06-00-enums.html">6장</a><!-- ignore -->에서 열거형에 대해 더 자세히 다룰 것입니다. 이러한 <code>Result</code> 타입의 목적은 오류 처리 정보를 인코딩하는 것입니다.</p>
<p><code>Result</code>의 variant는 <code>Ok</code>와 <code>Err</code>입니다. <code>Ok</code> variant는 작업이 성공했음을 나타내며, 성공적으로 생성된 값을 포함합니다. <code>Err</code> variant는 작업이 실패했음을 의미하며, 작업이 실패한 방법이나 이유에 대한 정보를 포함합니다.</p>
<p><code>Result</code> 타입의 값은 다른 타입의 값과 마찬가지로 메서드가 정의되어 있습니다. <code>Result</code>의 인스턴스에는 호출할 수 있는 <a href="../std/result/enum.Result.html#method.expect"><code>expect</code> 메서드</a><!-- ignore -->가 있습니다. 이 <code>Result</code> 인스턴스가 <code>Err</code> 값이면, <code>expect</code>는 프로그램을 충돌시키고 <code>expect</code>에 인수로 전달한 메시지를 표시합니다. <code>read_line</code> 메서드가 <code>Err</code>를 반환하면, 이는 기본 운영 체제에서 발생하는 오류의 결과일 가능성이 높습니다. 이 <code>Result</code> 인스턴스가 <code>Ok</code> 값이면, <code>expect</code>는 <code>Ok</code>가 가지고 있는 반환 값을 가져와서 사용할 수 있도록 해당 값만 반환합니다. 이 경우, 그 값은 사용자 입력의 바이트 수입니다.</p>
<p><code>expect</code>를 호출하지 않으면 프로그램은 컴파일되지만, 경고가 표시됩니다:</p>
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `Result` that must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
10 |     let _ = io::stdin().read_line(&amp;mut guess);
   |     +++++++

warning: `guessing_game` (bin "guessing_game") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>러스트는 <code>read_line</code>에서 반환된 <code>Result</code> 값을 사용하지 않았다고 경고하며, 이는 프로그램이 가능한 오류를 처리하지 않았음을 나타냅니다.</p>
<p>경고를 억제하는 올바른 방법은 실제로 오류 처리 코드를 작성하는 것이지만, 이 경우에는 문제가 발생했을 때 프로그램을 충돌시키고 싶기 때문에 <code>expect</code>를 사용할 수 있습니다. 오류로부터 복구하는 방법에 대해서는 <a href="ch09-02-recoverable-errors-with-result.html">9장</a><!-- ignore -->에서 배울 것입니다.</p>
<h3 id="println-플레이스홀더로-값-출력하기"><a class="header" href="#println-플레이스홀더로-값-출력하기"><code>println!</code> 플레이스홀더로 값 출력하기</a></h3>
<p>닫는 중괄호를 제외하고, 지금까지 코드에서 논의할 줄은 한 줄 더 있습니다:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    println!(추측을 입력하세요.);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("줄 읽기 실패");
</span><span class="boring">
</span>    println!("당신의 추측: {}", guess);
<span class="boring">}</span></code></pre>
<p>이 줄은 이제 사용자 입력을 포함하는 문자열을 출력합니다. <code>{}</code> 중괄호 세트는 플레이스홀더입니다: <code>{}</code>를 값을 제자리에 고정하는 작은 게 집게라고 생각하세요. 변수 값을 출력할 때, 변수 이름은 중괄호 안에 들어갈 수 있습니다. 표현식 평가 결과를 출력할 때, 형식 문자열에 빈 중괄호를 넣은 다음, 형식 문자열 뒤에 쉼표로 구분된 표현식 목록을 각 빈 중괄호 플레이스홀더에 같은 순서로 출력합니다. <code>println!</code> 한 번의 호출로 변수와 표현식 결과를 출력하는 것은 다음과 같습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = 10;

println!("x = {x} and y + 2 = {}", y + 2);
<span class="boring">}</span></code></pre></pre>
<p>이 코드는 <code>x = 5 and y + 2 = 12</code>를 출력할 것입니다.</p>
<h3 id="첫-번째-부분-테스트하기"><a class="header" href="#첫-번째-부분-테스트하기">첫 번째 부분 테스트하기</a></h3>
<p>추측 게임의 첫 번째 부분을 테스트해 봅시다. <code>cargo run</code>을 사용하여 실행하세요:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-01/
cargo clean
cargo run
input 6 -->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
</code></pre>
<p>이 시점에서 게임의 첫 번째 부분이 완료되었습니다: 키보드에서 입력을 받아 출력하고 있습니다.</p>
<h2 id="비밀-번호-생성하기"><a class="header" href="#비밀-번호-생성하기">비밀 번호 생성하기</a></h2>
<p>다음으로, 사용자가 추측할 비밀 번호를 생성해야 합니다. 게임을 여러 번 즐길 수 있도록 비밀 번호는 매번 달라야 합니다. 게임이 너무 어렵지 않도록 1에서 100 사이의 난수를 사용할 것입니다. 러스트는 아직 표준 라이브러리에 난수 기능을 포함하고 있지 않습니다. 그러나 러스트 팀은 해당 기능을 가진 <a href="https://crates.io/crates/rand"><code>rand</code> 크레이트</a>를 제공합니다.</p>
<h3 id="크레이트를-사용하여-더-많은-기능-얻기"><a class="header" href="#크레이트를-사용하여-더-많은-기능-얻기">크레이트를 사용하여 더 많은 기능 얻기</a></h3>
<p>크레이트는 러스트 소스 코드 파일의 모음이라는 것을 기억하세요. 우리가 빌드해 온 프로젝트는 실행 파일인 _바이너리 크레이트_입니다. <code>rand</code> 크레이트는 다른 프로그램에서 사용하도록 의도된 코드를 포함하고 자체적으로 실행할 수 없는 _라이브러리 크레이트_입니다.</p>
<p>Cargo의 외부 크레이트 조정은 Cargo가 정말 빛을 발하는 부분입니다. <code>rand</code>를 사용하는 코드를 작성하기 전에, <code>rand</code> 크레이트를 의존성으로 포함하도록 <em>Cargo.toml</em> 파일을 수정해야 합니다. 지금 그 파일을 열고 Cargo가 생성한 <code>[dependencies]</code> 섹션 헤더 아래 맨 아래에 다음 줄을 추가하세요. 여기에 있는 버전 번호와 정확히 동일하게 <code>rand</code>를 지정해야 합니다. 그렇지 않으면 이 튜토리얼의 코드 예제가 작동하지 않을 수 있습니다:</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
* ch14-03-cargo-workspaces.md
-->
<p><span class="filename">파일명: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = "0.8.5"
</code></pre>
<p><em>Cargo.toml</em> 파일에서 헤더 뒤에 오는 모든 것은 다른 섹션이 시작될 때까지 해당 섹션의 일부입니다. <code>[dependencies]</code>에서 Cargo에게 프로젝트가 의존하는 외부 크레이트와 필요한 크레이트의 버전을 알려줍니다. 이 경우, 우리는 의미론적 버전 지정자 <code>0.8.5</code>로 <code>rand</code> 크레이트를 지정합니다. Cargo는 버전 번호를 작성하는 표준인 <a href="http://semver.org">의미론적 버전 관리</a><!-- ignore --> (때로는 _SemVer_라고도 함)를 이해합니다. 지정자 <code>0.8.5</code>는 실제로는 <code>^0.8.5</code>의 약식이며, 이는 0.8.5 이상이지만 0.9.0 미만인 모든 버전을 의미합니다.</p>
<p>Cargo는 이러한 버전이 0.8.5 버전과 호환되는 공개 API를 가지고 있다고 간주하며, 이 사양은 이 장의 코드와 여전히 컴파일될 최신 패치 릴리스를 얻을 수 있도록 보장합니다. 0.9.0 이상의 모든 버전은 다음 예제에서 사용하는 것과 동일한 API를 가지고 있다고 보장되지 않습니다.</p>
<p>이제 코드를 변경하지 않고, 목록 2-2와 같이 프로젝트를 빌드해 보겠습니다.</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
rm Cargo.lock
cargo clean
cargo build -->
<Listing number="2-2" caption="The output from running `cargo build` after adding the rand crate as a dependency">
<pre><code class="language-console">$ cargo build
    Updating crates.io index
     Locking 16 packages to latest compatible versions
      Adding wasi v0.11.0+wasi-snapshot-preview1 (latest: v0.13.3+wasi-0.2.2)
      Adding zerocopy v0.7.35 (latest: v0.8.9)
      Adding zerocopy-derive v0.7.35 (latest: v0.8.9)
  Downloaded syn v2.0.87
  Downloaded 1 crate (278.1 KB) in 0.16s
   Compiling proc-macro2 v1.0.89
   Compiling unicode-ident v1.0.13
   Compiling libc v0.2.161
   Compiling cfg-if v1.0.0
   Compiling byteorder v1.5.0
   Compiling getrandom v0.2.15
   Compiling rand_core v0.6.4
   Compiling quote v1.0.37
   Compiling syn v2.0.87
   Compiling zerocopy-derive v0.7.35
   Compiling zerocopy v0.7.35
   Compiling ppv-lite86 v0.2.20
   Compiling rand_chacha v0.3.1
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 3.69s
</code></pre>
</Listing>
<p>다른 버전 번호(하지만 SemVer 덕분에 모두 코드와 호환됩니다!)와 다른 줄(운영 체제에 따라 다름)이 표시될 수 있으며, 줄 순서가 다를 수 있습니다.</p>
<p>외부 의존성을 포함하면, Cargo는 해당 의존성이 필요로 하는 모든 것의 최신 버전을 _레지스트리_에서 가져옵니다. 레지스트리는 <a href="https://crates.io/">Crates.io</a>의 데이터 사본입니다. Crates.io는 러스트 생태계의 사람들이 다른 사람들이 사용할 수 있도록 오픈 소스 러스트 프로젝트를 게시하는 곳입니다.</p>
<p>레지스트리를 업데이트한 후, Cargo는 <code>[dependencies]</code> 섹션을 확인하고 아직 다운로드되지 않은 모든 크레이트를 다운로드합니다. 이 경우, 우리는 <code>rand</code>만 의존성으로 나열했지만, Cargo는 <code>rand</code>가 작동하는 데 의존하는 다른 크레이트도 가져왔습니다. 크레이트를 다운로드한 후, 러스트는 그것들을 컴파일한 다음 사용 가능한 의존성으로 프로젝트를 컴파일합니다.</p>
<p>변경 사항 없이 즉시 <code>cargo build</code>를 다시 실행하면, <code>Finished</code> 줄 외에는 아무런 출력도 얻지 못할 것입니다. Cargo는 이미 의존성을 다운로드하고 컴파일했으며, <em>Cargo.toml</em> 파일에서 의존성에 대해 아무것도 변경하지 않았다는 것을 알고 있습니다. Cargo는 또한 코드에 대해 아무것도 변경하지 않았다는 것을 알고 있으므로, 그것도 다시 컴파일하지 않습니다. 할 일이 없으면, 그냥 종료됩니다.</p>
<p><em>src/main.rs</em> 파일을 열고, 사소한 변경을 한 다음, 저장하고 다시 빌드하면, 두 줄의 출력만 보게 될 것입니다:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
touch src/main.rs
cargo build -->
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s
</code></pre>
<p>이 줄들은 Cargo가 <em>src/main.rs</em> 파일에 대한 작은 변경 사항으로만 빌드를 업데이트한다는 것을 보여줍니다. 의존성은 변경되지 않았으므로, Cargo는 이미 다운로드하고 컴파일한 것을 재사용할 수 있다는 것을 알고 있습니다.</p>
<h4 id="cargolock-파일로-재현-가능한-빌드-보장하기"><a class="header" href="#cargolock-파일로-재현-가능한-빌드-보장하기"><em>Cargo.lock</em> 파일로 재현 가능한 빌드 보장하기</a></h4>
<p>Cargo에는 당신이나 다른 사람이 코드를 빌드할 때마다 동일한 아티팩트를 다시 빌드할 수 있도록 보장하는 메커니즘이 있습니다: Cargo는 당신이 달리 명시할 때까지 지정한 의존성 버전만 사용합니다. 예를 들어, 다음 주에 <code>rand</code> 크레이트의 0.8.6 버전이 나오고, 그 버전에 중요한 버그 수정이 포함되어 있지만, 코드를 손상시키는 회귀도 포함되어 있다고 가정해 보겠습니다. 이를 처리하기 위해, 러스트는 <code>cargo build</code>를 처음 실행할 때 <em>Cargo.lock</em> 파일을 생성하므로, 이제 <em>guessing_game</em> 디렉토리에 이 파일이 있습니다.</p>
<p>프로젝트를 처음 빌드할 때, Cargo는 기준에 맞는 모든 의존성 버전을 파악한 다음 <em>Cargo.lock</em> 파일에 씁니다. 나중에 프로젝트를 빌드할 때, Cargo는 <em>Cargo.lock</em> 파일이 존재하는 것을 보고 버전 파악 작업을 다시 수행하는 대신 거기에 지정된 버전을 사용합니다. 이를 통해 자동으로 재현 가능한 빌드를 가질 수 있습니다. 즉, <em>Cargo.lock</em> 파일 덕분에 명시적으로 업그레이드할 때까지 프로젝트는 0.8.5 버전에 머물러 있을 것입니다. <em>Cargo.lock</em> 파일은 재현 가능한 빌드에 중요하기 때문에, 종종 프로젝트의 나머지 코드와 함께 소스 제어에 체크인됩니다.</p>
<h4 id="새-버전을-얻기-위해-크레이트-업데이트하기"><a class="header" href="#새-버전을-얻기-위해-크레이트-업데이트하기">새 버전을 얻기 위해 크레이트 업데이트하기</a></h4>
<p>크레이트를 업데이트하고 싶을 때, Cargo는 <code>update</code> 명령을 제공합니다. 이 명령은 <em>Cargo.lock</em> 파일을 무시하고 _Cargo.toml_의 사양에 맞는 모든 최신 버전을 파악합니다. 그런 다음 Cargo는 해당 버전을 <em>Cargo.lock</em> 파일에 씁니다. 이 경우, Cargo는 0.8.5보다 크고 0.9.0보다 작은 버전만 찾습니다. <code>rand</code> 크레이트가 0.8.6과 0.9.0이라는 두 가지 새 버전을 출시했다면, <code>cargo update</code>를 실행하면 다음과 같이 표시됩니다:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
cargo update
assuming there is a new 0.8.x version of rand; otherwise use another update
as a guide to creating the hypothetical output shown here -->
<pre><code class="language-console">$ cargo update
    Updating crates.io index
    Updating rand v0.8.5 -&gt; v0.8.6
</code></pre>
<p>Cargo는 0.9.0 릴리스를 무시합니다. 이 시점에서, 당신은 또한 <em>Cargo.lock</em> 파일에서 현재 사용하고 있는 <code>rand</code> 크레이트의 버전이 0.8.6이라는 변경 사항을 발견하게 될 것입니다. <code>rand</code> 버전 0.9.0 또는 0.9.<em>x</em> 시리즈의 버전을 사용하려면, 대신 <em>Cargo.toml</em> 파일을 다음과 같이 업데이트해야 합니다:</p>
<pre><code class="language-toml">[dependencies]
rand = "0.9.0"
</code></pre>
<p>다음에 <code>cargo build</code>를 실행하면, Cargo는 사용 가능한 크레이트의 레지스트리를 업데이트하고 지정한 새 버전에 따라 <code>rand</code> 요구 사항을 다시 평가합니다.</p>
<p><a href="https://doc.rust-lang.org/cargo/">Cargo</a><!-- ignore -->와 <a href="https://doc.rust-lang.org/cargo/reference/publishing.html">그 생태계</a><!-- ignore -->에 대해 할 말이 더 많지만, 14장에서 논의할 것이고, 지금은 이것만 알면 됩니다. Cargo는 라이브러리를 매우 쉽게 재사용할 수 있게 해주므로, 러스트 개발자들은 여러 패키지로 조립된 더 작은 프로젝트를 작성할 수 있습니다.</p>
<h3 id="난수-생성하기"><a class="header" href="#난수-생성하기">난수 생성하기</a></h3>
<p><code>rand</code>를 사용하여 추측할 숫자를 생성해 보겠습니다. 다음 단계는 목록 2-3과 같이 _src/main.rs_를 업데이트하는 것입니다.</p>
<Listing number="2-3" file-name="src/main.rs" caption="Adding code to generate a random number">
<pre><code class="language-rust ignore">use std::io;
use rand::Rng;

fn main() {
    println!("숫자를 맞춰보세요!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    println!("비밀 번호는: {secret_number}");

    println!(추측을 입력하세요.);

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("줄 읽기 실패");

    println!("당신의 추측: {guess}");
}</code></pre>
</Listing>
<p>먼저 <code>use rand::Rng;</code> 줄을 추가합니다. <code>Rng</code> 트레이트는 난수 생성기가 구현하는 메서드를 정의하며, 이 트레이트는 해당 메서드를 사용하기 위해 스코프 내에 있어야 합니다. 10장에서 트레이트에 대해 자세히 다룰 것입니다.</p>
<p>다음으로, 중간에 두 줄을 추가합니다. 첫 번째 줄에서는, 우리가 사용할 특정 난수 생성기를 제공하는 <code>rand::thread_rng</code> 함수를 호출합니다: 현재 실행 스레드에 로컬이며 운영 체제에 의해 시드됩니다. 그런 다음 난수 생성기에서 <code>gen_range</code> 메서드를 호출합니다. 이 메서드는 <code>use rand::Rng;</code> 문으로 스코프에 가져온 <code>Rng</code> 트레이트에 의해 정의됩니다. <code>gen_range</code> 메서드는 범위 표현식을 인수로 사용하고 범위 내에서 난수를 생성합니다. 여기서 사용하는 범위 표현식의 종류는 <code>start..=end</code> 형식을 취하며 하한과 상한을 포함하므로, 1에서 100 사이의 숫자를 요청하려면 <code>1..=100</code>을 지정해야 합니다.</p>
<blockquote>
<p>참고: 어떤 트레이트를 사용해야 하고, 어떤 메서드와 함수를 크레이트에서 호출해야 하는지 그냥 알 수는 없으므로, 각 크레이트에는 사용 지침이 포함된 문서가 있습니다. Cargo의 또 다른 멋진 기능은 <code>cargo doc --open</code> 명령을 실행하면 모든 의존성에서 제공하는 문서를 로컬에서 빌드하고 브라우저에서 열어준다는 것입니다. 예를 들어, <code>rand</code> 크레이트의 다른 기능에 관심이 있다면, <code>cargo doc --open</code>을 실행하고 왼쪽 사이드바에서 <code>rand</code>를 클릭하세요.</p>
</blockquote>
<p>두 번째 새 줄은 비밀 번호를 출력합니다. 이것은 프로그램을 개발하는 동안 테스트할 수 있도록 유용하지만, 최종 버전에서는 삭제할 것입니다. 프로그램이 시작하자마자 답을 출력하면 게임이 별로 재미없으니까요!</p>
<p>프로그램을 몇 번 실행해보세요:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-03/
cargo run
4
cargo run
5
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4

$ cargo run
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
</code></pre>
<p>다른 난수를 얻어야 하며, 모두 1에서 100 사이의 숫자여야 합니다. 잘했습니다!</p>
<h2 id="추측을-비밀-번호와-비교하기"><a class="header" href="#추측을-비밀-번호와-비교하기">추측을 비밀 번호와 비교하기</a></h2>
<p>이제 사용자 입력과 난수가 있으므로 비교할 수 있습니다. 그 단계는 목록 2-4에 나와 있습니다. 설명하겠지만, 이 코드는 아직 컴파일되지 않습니다.</p>
<Listing number="2-4" file-name="src/main.rs" caption="Handling the possible return values of comparing two numbers">
<pre><code class="language-rust ignore does_not_compile">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --생략--
<span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("비밀 번호는: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!(추측을 입력하세요.);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect("줄 읽기 실패");
</span>
    println!("당신의 추측: {guess}");

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!("너무 작아요!"),
        Ordering::Greater =&gt; println!("너무 커요!"),
        Ordering::Equal =&gt; println!("당신이 이겼습니다!"),
    }
}</code></pre>
</Listing>
<p>먼저 또 다른 <code>use</code> 문을 추가하여, 표준 라이브러리에서 <code>std::cmp::Ordering</code>이라는 타입을 스코프로 가져옵니다. <code>Ordering</code> 타입은 또 다른 열거형이며 <code>Less</code>, <code>Greater</code>, <code>Equal</code> variant를 가집니다. 이것들은 두 값을 비교할 때 가능한 세 가지 결과입니다.</p>
<p>그런 다음 <code>Ordering</code> 타입을 사용하는 다섯 줄의 새 코드를 맨 아래에 추가합니다. <code>cmp</code> 메서드는 두 값을 비교하며, 비교할 수 있는 모든 것에서 호출할 수 있습니다. 비교하려는 대상에 대한 참조를 인수로 받습니다: 여기서는 <code>guess</code>를 <code>secret_number</code>와 비교합니다. 그런 다음 <code>use</code> 문으로 스코프에 가져온 <code>Ordering</code> 열거형의 variant를 반환합니다. <code>guess</code>와 <code>secret_number</code>의 값으로 <code>cmp</code>를 호출하여 반환된 <code>Ordering</code>의 variant에 따라 다음에 무엇을 할지 결정하기 위해 <a href="ch06-02-match.html"><code>match</code></a><!-- ignore --> 표현식을 사용합니다.</p>
<p><code>match</code> 표현식은 _arm_으로 구성됩니다. arm은 매치할 _패턴_과 <code>match</code>에 주어진 값이 해당 arm의 패턴에 맞을 경우 실행되어야 하는 코드로 구성됩니다. 러스트는 <code>match</code>에 주어진 값을 가져와 각 arm의 패턴을 차례로 살펴봅니다. 패턴과 <code>match</code> 구조는 강력한 러스트 기능입니다: 코드가 마주칠 수 있는 다양한 상황을 표현할 수 있게 해주며, 모든 상황을 처리하도록 보장합니다. 이러한 기능은 각각 6장과 19장에서 자세히 다룰 것입니다.</p>
<p>여기서 사용하는 <code>match</code> 표현식의 예를 살펴보겠습니다. 사용자가 50을 추측했고 이번에 무작위로 생성된 비밀 번호가 38이라고 가정해 보겠습니다.</p>
<p>코드가 50을 38과 비교할 때, <code>cmp</code> 메서드는 50이 38보다 크기 때문에 <code>Ordering::Greater</code>를 반환합니다. <code>match</code> 표현식은 <code>Ordering::Greater</code> 값을 얻고 각 arm의 패턴을 확인하기 시작합니다. 첫 번째 arm의 패턴인 <code>Ordering::Less</code>를 보고, <code>Ordering::Greater</code> 값이 <code>Ordering::Less</code>와 일치하지 않음을 확인하고, 해당 arm의 코드를 무시하고 다음 arm으로 이동합니다. 다음 arm의 패턴은 <code>Ordering::Greater</code>이며, 이는 <code>Ordering::Greater</code>와 <em>일치합니다</em>! 해당 arm의 연관 코드가 실행되고 화면에 <code>Too big!</code>을 출력합니다. <code>match</code> 표현식은 첫 번째 성공적인 매치 후에 종료되므로, 이 시나리오에서는 마지막 arm을 보지 않습니다.</p>
<p>그러나 목록 2-4의 코드는 아직 컴파일되지 않습니다. 시도해 보겠습니다:</p>
<!--
The error numbers in this output should be that of the code **WITHOUT** the
anchor or snip comments
-->
<pre><code class="language-console">$ cargo build
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_core v0.6.2
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
   --&gt; src/main.rs:22:21
    |
22  |     match guess.cmp(&amp;secret_number) {
    |                 --- ^^^^^^^^^^^^^^ expected `&amp;String`, found `&amp;{integer}`
    |                 |
    |                 arguments to this method are incorrect
    |
    = note: expected reference `&amp;String`
               found reference `&amp;{integer}`
note: method defined here
   --&gt; file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/core/src/cmp.rs:838:8
    |
838 |     fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering;
    |        ^^^

For more information about this error, try `rustc --explain E0308`.
error: could not compile `guessing_game` (bin "guessing_game") due to 1 previous error
</code></pre>
<p>오류의 핵심은 _일치하지 않는 타입_이 있다는 것입니다. 러스트는 강력한 정적 타입 시스템을 가지고 있습니다. 그러나 타입 추론도 가지고 있습니다. <code>let mut guess = String::new()</code>를 작성했을 때, 러스트는 <code>guess</code>가 <code>String</code>이어야 한다고 추론할 수 있었고, 우리가 타입을 작성하도록 강요하지 않았습니다. 반면에 <code>secret_number</code>는 숫자 타입입니다. 러스트의 몇 가지 숫자 타입은 1에서 100 사이의 값을 가질 수 있습니다: <code>i32</code>, 32비트 숫자; <code>u32</code>, 부호 없는 32비트 숫자; <code>i64</code>, 64비트 숫자; 등등. 달리 명시하지 않는 한, 러스트는 <code>i32</code>를 기본값으로 사용하며, 다른 곳에서 러스트가 다른 숫자 타입을 추론하도록 하는 타입 정보를 추가하지 않는 한 <code>secret_number</code>의 타입입니다. 오류의 이유는 러스트가 문자열과 숫자 타입을 비교할 수 없기 때문입니다.</p>
<p>궁극적으로, 프로그램이 입력으로 읽는 <code>String</code>을 숫자 타입으로 변환하여 비밀 번호와 숫자로 비교하고 싶습니다. <code>main</code> 함수 본문에 이 줄을 추가하여 그렇게 합니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("비밀 번호는: {secret_number}");
</span><span class="boring">
</span><span class="boring">    println!(추측을 입력하세요.);
</span><span class="boring">
</span>    // --생략--

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("줄 읽기 실패");

    let guess: u32 = guess.trim().parse().expect("숫자를 입력해주세요!");

    println!("당신의 추측: {guess}");

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!("너무 작아요!"),
        Ordering::Greater =&gt; println!("너무 커요!"),
        Ordering::Equal =&gt; println!("당신이 이겼습니다!"),
    }
<span class="boring">}</span></code></pre>
<p>해당 줄은 다음과 같습니다:</p>
<pre><code class="language-rust ignore">let guess: u32 = guess.trim().parse().expect("숫자를 입력해주세요!");</code></pre>
<p><code>guess</code>라는 이름의 변수를 만듭니다. 하지만 잠깐, 프로그램에 이미 <code>guess</code>라는 이름의 변수가 있지 않나요? 그렇습니다. 하지만 고맙게도 러스트는 이전 <code>guess</code> 값을 새 값으로 섀도잉할 수 있도록 허용합니다. _섀도잉_을 사용하면 예를 들어 <code>guess_str</code>과 <code>guess</code>와 같이 두 개의 고유한 변수를 만들도록 강요하는 대신 <code>guess</code> 변수 이름을 재사용할 수 있습니다. 이에 대해서는 <a href="ch03-01-variables-and-mutability.html#shadowing">3장</a><!-- ignore -->에서 더 자세히 다룰 것이지만, 지금은 이 기능이 한 타입의 값을 다른 타입으로 변환하고 싶을 때 자주 사용된다는 점만 알아두세요.</p>
<p>We bind this new variable to the expression <code>guess.trim().parse()</code>. The <code>guess</code> in the expression refers to the original <code>guess</code> variable that contained the input as a string. The <code>trim</code> method on a <code>String</code> instance will eliminate any whitespace at the beginning and end, which we must do before we can convert the string to a <code>u32</code>, which can only contain numerical data. The user must press <kbd>enter</kbd> to satisfy <code>read_line</code> and input their guess, which adds a newline character to the string. For example, if the user types <kbd>5</kbd> and presses <kbd>enter</kbd>, <code>guess</code> looks like this: <code>5\n</code>. The <code>\n</code> represents “newline.” (On Windows, pressing <kbd>enter</kbd> results in a carriage return and a newline, <code>\r\n</code>.) The <code>trim</code> method eliminates <code>\n</code> or <code>\r\n</code>, resulting in just <code>5</code>.</p>
<p>The <a href="../std/primitive.str.html#method.parse"><code>parse</code> method on strings</a><!-- ignore --> converts a string to another type. Here, we use it to convert from a string to a number. We need to tell Rust the exact number type we want by using <code>let guess: u32</code>. The colon (<code>:</code>) after <code>guess</code> tells Rust we’ll annotate the variable’s type. Rust has a few built-in number types; the <code>u32</code> seen here is an unsigned, 32-bit integer. It’s a good default choice for a small positive number. You’ll learn about other number types in <a href="ch03-02-data-types.html#integer-types">Chapter 3</a><!-- ignore -->.</p>
<p>Additionally, the <code>u32</code> annotation in this example program and the comparison with <code>secret_number</code> means Rust will infer that <code>secret_number</code> should be a <code>u32</code> as well. So now the comparison will be between two values of the same type!</p>
<p>The <code>parse</code> method will only work on characters that can logically be converted into numbers and so can easily cause errors. If, for example, the string contained <code>A👍%</code>, there would be no way to convert that to a number. Because it might fail, the <code>parse</code> method returns a <code>Result</code> type, much as the <code>read_line</code> method does (discussed earlier in <a href="#handling-potential-failure-with-result">“Handling Potential Failure with <code>Result</code>”</a><!-- ignore-->). We’ll treat this <code>Result</code> the same way by using the <code>expect</code> method again. If <code>parse</code> returns an <code>Err</code> <code>Result</code> variant because it couldn’t create a number from the string, the <code>expect</code> call will crash the game and print the message we give it. If <code>parse</code> can successfully convert the string to a number, it will return the <code>Ok</code> variant of <code>Result</code>, and <code>expect</code> will return the number that we want from the <code>Ok</code> value.</p>
<p>이제 프로그램을 실행해 봅시다:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/
touch src/main.rs
cargo run
  76
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.26s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
</code></pre>
<p>좋아요! 추측 앞에 공백이 추가되었음에도 불구하고, 프로그램은 사용자가 76을 추측했다는 것을 알아냈습니다. 프로그램을 몇 번 실행하여 다른 종류의 입력에 대한 다른 동작을 확인하세요: 숫자를 정확하게 추측하고, 너무 높은 숫자를 추측하고, 너무 낮은 숫자를 추측하세요.</p>
<p>이제 대부분의 게임이 작동하지만, 사용자는 한 번만 추측할 수 있습니다. 반복문을 추가하여 그것을 변경해 봅시다!</p>
<h2 id="반복문으로-여러-번-추측-허용하기"><a class="header" href="#반복문으로-여러-번-추측-허용하기">반복문으로 여러 번 추측 허용하기</a></h2>
<p><code>loop</code> 키워드는 무한 루프를 만듭니다. 사용자가 숫자를 추측할 기회를 더 많이 주기 위해 루프를 추가할 것입니다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    // --생략--

    println!("비밀 번호는: {secret_number}");

    loop {
        println!(추측을 입력하세요.);

        // --생략--

<span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("줄 읽기 실패");
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect("숫자를 입력해주세요!");
</span><span class="boring">
</span><span class="boring">        println!("당신의 추측: {guess}");
</span><span class="boring">
</span>        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("너무 작아요!"),
            Ordering::Greater =&gt; println!("너무 커요!"),
            Ordering::Equal =&gt; println!("당신이 이겼습니다!"),
        }
    }
}</code></pre>
<p>보시다시피, 추측 입력 프롬프트부터 모든 것을 루프 안으로 옮겼습니다. 루프 안의 줄들을 각각 네 칸씩 더 들여쓰고 프로그램을 다시 실행하세요. 이제 프로그램은 영원히 다른 추측을 요구할 것이며, 이는 실제로 새로운 문제를 야기합니다. 사용자가 종료할 수 없는 것 같습니다!</p>
<p>The user could always interrupt the program by using the keyboard shortcut <kbd>ctrl</kbd>-<kbd>c</kbd>. But there’s another way to escape this insatiable monster, as mentioned in the <code>parse</code> discussion in <a href="#comparing-the-guess-to-the-secret-number">“Comparing the Guess to the Secret Number”</a><!-- ignore -->: if the user enters a non-number answer, the program will crash. We can take advantage of that to allow the user to quit, as shown here:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-04-looping/
touch src/main.rs
cargo run
(too small guess)
(too big guess)
(correct guess)
quit
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.23s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/main.rs:28:47
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p><code>quit</code>을 입력하면 게임이 종료되지만, 눈치채셨겠지만, 다른 숫자가 아닌 입력을 입력해도 마찬가지입니다. 이것은 좋지 않은 방법입니다. 우리는 정답을 맞췄을 때도 게임이 멈추기를 원합니다.</p>
<h3 id="정답-맞춘-후-종료하기"><a class="header" href="#정답-맞춘-후-종료하기">정답 맞춘 후 종료하기</a></h3>
<p><code>break</code> 문을 추가하여 사용자가 이겼을 때 게임이 종료되도록 프로그래밍해 봅시다:</p>
<p><span class="filename">파일명: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("비밀 번호는: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(추측을 입력하세요.);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("줄 읽기 실패");
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect("숫자를 입력해주세요!");
</span><span class="boring">
</span><span class="boring">        println!("당신의 추측: {guess}");
</span><span class="boring">
</span>        // --생략--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("너무 작아요!"),
            Ordering::Greater =&gt; println!("너무 커요!"),
            Ordering::Equal =&gt; {
                println!("당신이 이겼습니다!");
                break;
            }
        }
    }
}</code></pre>
<p><code>You win!</code> 뒤에 <code>break</code> 줄을 추가하면 사용자가 비밀 번호를 정확하게 추측했을 때 프로그램이 루프를 종료합니다. 루프를 종료하는 것은 또한 프로그램을 종료하는 것을 의미합니다. 왜냐하면 루프는 <code>main</code>의 마지막 부분이기 때문입니다.</p>
<h3 id="잘못된-입력-처리하기"><a class="header" href="#잘못된-입력-처리하기">잘못된 입력 처리하기</a></h3>
<p>게임의 동작을 더욱 개선하기 위해, 사용자가 숫자가 아닌 값을 입력했을 때 프로그램을 충돌시키는 대신, 게임이 숫자가 아닌 값을 무시하도록 하여 사용자가 계속 추측할 수 있도록 만들어 봅시다. 목록 2-5와 같이 <code>guess</code>가 <code>String</code>에서 <code>u32</code>로 변환되는 줄을 변경하여 그렇게 할 수 있습니다.</p>
<Listing number="2-5" file-name="src/main.rs" caption="Ignoring a non-number guess and asking for another guess instead of crashing the program">
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!("비밀 번호는: {secret_number}");
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(추측을 입력하세요.);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span>        // --생략--

        io::stdin()
            .read_line(&amp;mut guess)
            .expect("줄 읽기 실패");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!("당신의 추측: {guess}");

        // --생략--
<span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!("너무 작아요!"),
</span><span class="boring">            Ordering::Greater =&gt; println!("너무 커요!"),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!("당신이 이겼습니다!");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>오류 발생 시 충돌하는 것에서 오류를 처리하는 것으로 이동하기 위해 <code>expect</code> 호출에서 <code>match</code> 표현식으로 전환합니다. <code>parse</code>가 <code>Result</code> 타입을 반환하고 <code>Result</code>가 <code>Ok</code>와 <code>Err</code> variant를 갖는 열거형임을 기억하세요. <code>cmp</code> 메서드의 <code>Ordering</code> 결과와 마찬가지로 여기서도 <code>match</code> 표현식을 사용하고 있습니다.</p>
<p><code>parse</code>가 문자열을 숫자로 성공적으로 변환할 수 있으면, 결과 숫자를 포함하는 <code>Ok</code> 값을 반환합니다. 해당 <code>Ok</code> 값은 첫 번째 arm의 패턴과 일치하며, <code>match</code> 표현식은 <code>parse</code>가 생성하여 <code>Ok</code> 값 안에 넣은 <code>num</code> 값을 반환합니다. 그 숫자는 우리가 생성하는 새 <code>guess</code> 변수에서 원하는 바로 그 위치에 있게 됩니다.</p>
<p><code>parse</code>가 문자열을 숫자로 변환할 수 <em>없는</em> 경우, 오류에 대한 자세한 정보가 포함된 <code>Err</code> 값을 반환합니다. <code>Err</code> 값은 첫 번째 <code>match</code> arm의 <code>Ok(num)</code> 패턴과 일치하지 않지만, 두 번째 arm의 <code>Err(_)</code> 패턴과 일치합니다. 밑줄 <code>_</code>는 모든 것을 포괄하는 값입니다. 이 예에서는 내부에 어떤 정보가 있든 모든 <code>Err</code> 값과 일치시키고 싶다고 말하는 것입니다. 따라서 프로그램은 두 번째 arm의 코드인 <code>continue</code>를 실행하며, 이는 프로그램에게 <code>loop</code>의 다음 반복으로 이동하여 다른 추측을 요청하도록 지시합니다. 따라서 효과적으로 프로그램은 <code>parse</code>가 마주칠 수 있는 모든 오류를 무시합니다!</p>
<p>이제 프로그램의 모든 것이 예상대로 작동해야 합니다. 시도해 보겠습니다:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-05/
cargo run
(too small guess)
(too big guess)
foo
(correct guess)
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
</code></pre>
<p>멋지네요! 마지막으로 작은 수정 하나만 더 하면 추측 게임을 완성할 수 있습니다. 프로그램이 여전히 비밀 번호를 출력하고 있다는 것을 기억하세요. 테스트에는 효과적이었지만, 게임의 재미를 망칩니다. 비밀 번호를 출력하는 <code>println!</code>을 삭제합시다. 목록 2-6은 최종 코드를 보여줍니다.</p>
<Listing number="2-6" file-name="src/main.rs" caption="Complete guessing game code">
<pre><code class="language-rust ignore">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!("숫자를 맞춰보세요!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    loop {
        println!(추측을 입력하세요.);

        let mut guess = String::new();

        io::stdin()
            .read_line(&amp;mut guess)
            .expect("줄 읽기 실패");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!("당신의 추측: {guess}");

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("너무 작아요!"),
            Ordering::Greater =&gt; println!("너무 커요!"),
            Ordering::Equal =&gt; {
                println!("당신이 이겼습니다!");
                break;
            }
        }
    }
}</code></pre>
</Listing>
<p>이 시점에서, 당신은 성공적으로 추측 게임을 만들었습니다. 축하합니다!</p>
<h2 id="요약"><a class="header" href="#요약">요약</a></h2>
<p>이 프로젝트는 <code>let</code>, <code>match</code>, 함수, 외부 크레이트 사용 등 많은 새로운 러스트 개념을 소개하는 실습 방법이었습니다. 다음 몇 장에서는 이러한 개념에 대해 더 자세히 배울 것입니다. 3장에서는 변수, 데이터 타입, 함수와 같이 대부분의 프로그래밍 언어가 가지고 있는 개념을 다루고, 러스트에서 사용하는 방법을 보여줍니다. 4장에서는 러스트를 다른 언어와 다르게 만드는 기능인 소유권을 탐구합니다. 5장에서는 구조체와 메서드 구문을 논의하고, 6장에서는 열거형이 어떻게 작동하는지 설명합니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch01-03-hello-cargo.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch03-00-common-programming-concepts.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch01-03-hello-cargo.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch03-00-common-programming-concepts.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
