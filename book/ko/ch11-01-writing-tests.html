<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>테스트 작성 방법 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch11-01-writing-tests.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch11-01-writing-tests.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="테스트-작성-방법"><a class="header" href="#테스트-작성-방법">테스트 작성 방법</a></h2>
<p><em>Tests</em> are Rust functions that verify that the non-test code is functioning in the expected manner. The bodies of test functions typically perform these three actions:</p>
<ul>
<li>필요한 데이터 또는 상태를 설정합니다.</li>
<li>테스트하려는 코드를 실행합니다.</li>
<li>결과가 예상한 것과 일치하는지 단언합니다.</li>
</ul>
<p>러스트가 이러한 작업을 수행하는 테스트 작성을 위해 특별히 제공하는 기능을 살펴보겠습니다. 여기에는 <code>test</code> 속성, 몇 가지 매크로, 그리고 <code>should_panic</code> 속성이 포함됩니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="the-anatomy-of-a-test-function"></a></p>
<h3 id="structuring-test-functions"><a class="header" href="#structuring-test-functions">Structuring Test Functions</a></h3>
<p>가장 간단하게, 러스트의 테스트는 <code>test</code> 속성으로 주석이 달린 함수입니다. 속성은 러스트 코드 조각에 대한 메타데이터입니다. 한 가지 예는 5장에서 구조체와 함께 사용했던 <code>derive</code> 속성입니다. 함수를 테스트 함수로 변경하려면 <code>fn</code> 앞에 <code>#[test]</code>를 추가합니다. <code>cargo test</code> 명령으로 테스트를 실행하면, 러스트는 주석이 달린 함수를 실행하고 각 테스트 함수가 통과했는지 실패했는지 보고하는 테스트 러너 바이너리를 빌드합니다.</p>
<p>Whenever we make a new library project with Cargo, a test module with a test function in it is automatically generated for us. This module gives you a template for writing your tests so that you don’t have to look up the exact structure and syntax every time you start a new project. You can add as many additional test functions and as many test modules as you want!</p>
<p>We’ll explore some aspects of how tests work by experimenting with the template test before we actually test any code. Then, we’ll write some real-world tests that call some code that we’ve written and assert that its behavior is correct.</p>
<p>두 숫자를 더하는 <code>adder</code>라는 새 라이브러리 프로젝트를 만들어 보겠습니다:</p>
<pre><code class="language-console">$ cargo new adder --lib
     Created library `adder` project
$ cd adder
</code></pre>
<p>여러분의 <code>adder</code> 라이브러리의 <em>src/lib.rs</em> 파일 내용은 목록 11-1과 같아야 합니다.</p>
<Listing number="11-1" file-name="src/lib.rs" caption="The code generated automatically by `cargo new`">
<!-- manual-regeneration
cd listings/ch11-writing-automated-tests
rm -rf listing-11-01
cargo new listing-11-01 --lib --name adder
cd listing-11-01
echo "$ cargo test" > output.txt
RUSTFLAGS="-A unused_variables -A dead_code" RUST_TEST_THREADS=1 cargo test >> output.txt 2>&1
git diff output.txt # commit any relevant changes; discard irrelevant ones
cd ../../..
-->
<pre><code class="language-rust noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
</Listing>
<p>The file starts with an example <code>add</code> function so that we have something to test.</p>
<p>For now, let’s focus solely on the <code>it_works</code> function. Note the <code>#[test]</code> annotation: This attribute indicates this is a test function, so the test runner knows to treat this function as a test. We might also have non-test functions in the <code>tests</code> module to help set up common scenarios or perform common operations, so we always need to indicate which functions are tests.</p>
<p>예제 함수 본문은 <code>assert_eq!</code> 매크로를 사용하여 2와 2를 더한 <code>add</code> 호출의 결과인 <code>result</code>가 4와 같음을 단언합니다. 이 단언은 일반적인 테스트 형식의 예시 역할을 합니다. 이 테스트가 통과하는지 확인하기 위해 실행해 봅시다.</p>
<p>목록 11-2에 나온 것처럼 <code>cargo test</code> 명령은 프로젝트의 모든 테스트를 실행합니다.</p>
<Listing number="11-2" caption="The output from running the automatically generated test">
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.57s
     Running unittests src/lib.rs (target/debug/deps/adder-01ad14159ff659ab)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
</Listing>
<p>Cargo가 테스트를 컴파일하고 실행했습니다. <code>running 1 test</code> 줄이 보입니다. 다음 줄은 생성된 테스트 함수 <code>tests::it_works</code>의 이름과 해당 테스트 실행 결과가 <code>ok</code>임을 보여줍니다. 전체 요약 <code>test result: ok.</code>는 모든 테스트가 통과했음을 의미하며, <code>1 passed; 0 failed</code> 부분은 통과하거나 실패한 테스트의 총 개수를 나타냅니다.</p>
<p>It’s possible to mark a test as ignored so that it doesn’t run in a particular instance; we’ll cover that in the <a href="ch11-02-running-tests.html#ignoring-tests-unless-specifically-requested">“Ignoring Tests Unless Specifically Requested”</a><!-- ignore --> section later in this chapter. Because we haven’t done that here, the summary shows <code>0 ignored</code>. We can also pass an argument to the <code>cargo test</code> command to run only tests whose name matches a string; this is called <em>filtering</em>, and we’ll cover it in the <a href="ch11-02-running-tests.html#running-a-subset-of-tests-by-name">“Running a Subset of Tests by Name”</a><!-- ignore --> section. Here, we haven’t filtered the tests being run, so the end of the summary shows <code>0 filtered out</code>.</p>
<p><code>0 measured</code> 통계는 성능을 측정하는 벤치마크 테스트를 위한 것입니다. 벤치마크 테스트는 이 글을 쓰는 시점에는 nightly Rust에서만 사용할 수 있습니다. 자세한 내용은 <a href="../unstable-book/library-features/test.html">벤치마크 테스트에 대한 문서</a>를 참조하세요.</p>
<p><code>Doc-tests adder</code>에서 시작하는 테스트 출력의 다음 부분은 모든 문서 테스트 결과에 대한 것입니다. 아직 문서 테스트는 없지만, 러스트는 API 문서에 나타나는 모든 코드 예제를 컴파일할 수 있습니다. 이 기능은 문서와 코드를 동기화하는 데 도움이 됩니다! 14장의 <a href="ch14-02-publishing-to-crates-io.html#documentation-comments-as-tests">“테스트로서의 문서 주석”</a><!-- ignore --> 섹션에서 문서 테스트를 작성하는 방법을 논의할 것입니다. 지금은 <code>Doc-tests</code> 출력을 무시하겠습니다.</p>
<p>이제 테스트를 우리의 필요에 맞게 사용자 정의해 봅시다. 먼저 <code>it_works</code> 함수의 이름을 <code>exploration</code>과 같은 다른 이름으로 변경합니다. 다음과 같이 말이죠:</p>
<p><span class="filename">파일명: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn exploration() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<p>Then, run <code>cargo test</code> again. The output now shows <code>exploration</code> instead of <code>it_works</code>:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.59s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>이제 또 다른 테스트를 추가할 것입니다. 하지만 이번에는 실패하는 테스트를 만들 것입니다! 테스트 함수 내에서 무언가가 패닉을 일으키면 테스트는 실패합니다. 각 테스트는 새 스레드에서 실행되며, 메인 스레드가 테스트 스레드가 종료된 것을 확인하면 테스트는 실패로 표시됩니다. 9장에서 가장 간단한 패닉 방법은 <code>panic!</code> 매크로를 호출하는 것이라고 이야기했습니다. 새 테스트를 <code>another</code>라는 함수로 입력하면 <em>src/lib.rs</em> 파일은 목록 11-3과 같아집니다.</p>
<Listing number="11-3" file-name="src/lib.rs" caption="Adding a second test that will fail because we call the `panic!` macro">
<pre><code class="language-rust panics noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn exploration() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }

    #[test]
    fn another() {
        panic!("이 테스트를 실패하게 만드세요");
    }
}</code></pre>
</Listing>
<p><code>cargo test</code>를 사용하여 테스트를 다시 실행합니다. 출력은 목록 11-4와 같아야 하며, <code>exploration</code> 테스트는 통과하고 <code>another</code> 테스트는 실패했음을 보여줍니다.</p>
<Listing number="11-4" caption="Test results when one test passes and one test fails">
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.72s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::another ... FAILED
test tests::exploration ... ok

failures:

---- tests::another stdout ----

thread 'tests::another' panicked at src/lib.rs:17:9:
Make this test fail
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
</Listing>
<!-- manual-regeneration
rg panicked listings/ch11-writing-automated-tests/listing-11-03/output.txt
check the line number of the panic matches the line number in the following paragraph
 -->
<p>Instead of <code>ok</code>, the line <code>test tests::another</code> shows <code>FAILED</code>. Two new sections appear between the individual results and the summary: The first displays the detailed reason for each test failure. In this case, we get the details that <code>tests::another</code> failed because it panicked with the message <code>Make this test fail</code> on line 17 in the <em>src/lib.rs</em> file. The next section lists just the names of all the failing tests, which is useful when there are lots of tests and lots of detailed failing test output. We can use the name of a failing test to run just that test to debug it more easily; we’ll talk more about ways to run tests in the <a href="ch11-02-running-tests.html#controlling-how-tests-are-run">“Controlling How Tests Are Run”</a><!-- ignore --> section.</p>
<p>The summary line displays at the end: Overall, our test result is <code>FAILED</code>. We had one test pass and one test fail.</p>
<p>이제 다양한 시나리오에서 테스트 결과가 어떻게 보이는지 확인했으니, 테스트에 유용한 <code>panic!</code> 외의 다른 매크로들을 살펴보겠습니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="checking-results-with-the-assert-macro"></a></p>
<h3 id="checking-results-with-assert"><a class="header" href="#checking-results-with-assert">Checking Results with <code>assert!</code></a></h3>
<p>표준 라이브러리에서 제공하는 <code>assert!</code> 매크로는 테스트의 어떤 조건이 <code>true</code>임을 보장하고 싶을 때 유용합니다. <code>assert!</code> 매크로에는 불리언으로 평가되는 인수를 전달합니다. 값이 <code>true</code>이면 아무 일도 일어나지 않고 테스트는 통과합니다. 값이 <code>false</code>이면 <code>assert!</code> 매크로는 <code>panic!</code>을 호출하여 테스트를 실패하게 만듭니다. <code>assert!</code> 매크로를 사용하면 우리 코드가 의도한 대로 작동하는지 확인하는 데 도움이 됩니다.</p>
<p>5장 목록 5-15에서 <code>Rectangle</code> 구조체와 <code>can_hold</code> 메서드를 사용했는데, 이는 목록 11-5에 다시 반복됩니다. 이 코드를 <em>src/lib.rs</em> 파일에 넣고, <code>assert!</code> 매크로를 사용하여 몇 가지 테스트를 작성해 봅시다.</p>
<Listing number="11-5" file-name="src/lib.rs" caption="The `Rectangle` struct and its `can_hold` method from Chapter 5">
<pre><code class="language-rust noplayground">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}</code></pre>
</Listing>
<p><code>can_hold</code> 메서드는 불리언을 반환하므로, <code>assert!</code> 매크로에 완벽한 사용 사례입니다. 목록 11-6에서는 너비 8, 높이 7인 <code>Rectangle</code> 인스턴스를 생성하고, 너비 5, 높이 1인 다른 <code>Rectangle</code> 인스턴스를 담을 수 있음을 단언하여 <code>can_hold</code> 메서드를 테스트하는 코드를 작성합니다.</p>
<Listing number="11-6" file-name="src/lib.rs" caption="A test for `can_hold` that checks whether a larger rectangle can indeed hold a smaller rectangle">
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(larger.can_hold(&amp;smaller));
    }
}</code></pre>
</Listing>
<p>Note the <code>use super::*;</code> line inside the <code>tests</code> module. The <code>tests</code> module is a regular module that follows the usual visibility rules we covered in Chapter 7 in the <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“Paths for Referring to an Item in the Module Tree”</a><!-- ignore --> section. Because the <code>tests</code> module is an inner module, we need to bring the code under test in the outer module into the scope of the inner module. We use a glob here, so anything we define in the outer module is available to this <code>tests</code> module.</p>
<p>We’ve named our test <code>larger_can_hold_smaller</code>, and we’ve created the two <code>Rectangle</code> instances that we need. Then, we called the <code>assert!</code> macro and passed it the result of calling <code>larger.can_hold(&amp;smaller)</code>. This expression is supposed to return <code>true</code>, so our test should pass. Let’s find out!</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>통과했습니다! 이제 다른 테스트를 추가해 봅시다. 이번에는 더 작은 사각형이 더 큰 사각형을 담을 수 없음을 단언하는 테스트입니다:</p>
<p><span class="filename">파일명: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        // --생략--
<span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span>    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(!smaller.can_hold(&amp;larger));
    }
}</code></pre>
<p>이 경우 <code>can_hold</code> 함수의 올바른 결과는 <code>false</code>이므로, <code>assert!</code> 매크로에 전달하기 전에 그 결과를 부정해야 합니다. 결과적으로 <code>can_hold</code>가 <code>false</code>를 반환하면 테스트는 통과할 것입니다:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... ok
test tests::smaller_cannot_hold_larger ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Two tests that pass! Now let’s see what happens to our test results when we introduce a bug in our code. We’ll change the implementation of the <code>can_hold</code> method by replacing the greater-than sign (<code>&gt;</code>) with a less-than sign (<code>&lt;</code>) when it compares the widths:</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>// --생략--
impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &lt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn larger_can_hold_smaller() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn smaller_cannot_hold_larger() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(!smaller.can_hold(&amp;larger));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>이제 테스트를 실행하면 다음과 같은 결과가 나옵니다:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... FAILED
test tests::smaller_cannot_hold_larger ... ok

failures:

---- tests::larger_can_hold_smaller stdout ----

thread 'tests::larger_can_hold_smaller' panicked at src/lib.rs:28:9:
assertion failed: larger.can_hold(&amp;smaller)
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>우리 테스트가 버그를 잡았습니다! <code>larger.width</code>는 <code>8</code>이고 <code>smaller.width</code>는 <code>5</code>이므로, <code>can_hold</code>에서의 너비 비교는 이제 <code>false</code>를 반환합니다. 8은 5보다 작지 않기 때문입니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="testing-equality-with-the-assert_eq-and-assert_ne-macros"></a></p>
<h3 id="testing-equality-with-assert_eq-and-assert_ne"><a class="header" href="#testing-equality-with-assert_eq-and-assert_ne">Testing Equality with <code>assert_eq!</code> and <code>assert_ne!</code></a></h3>
<p>기능을 검증하는 일반적인 방법은 테스트 중인 코드의 결과와 코드가 반환할 것으로 기대하는 값 사이의 일치 여부를 테스트하는 것입니다. 이는 <code>assert!</code> 매크로에 <code>==</code> 연산자를 사용하는 표현식을 전달하여 수행할 수 있습니다. 하지만 이는 매우 흔한 테스트이므로, 표준 라이브러리는 이 테스트를 더 편리하게 수행할 수 있도록 <code>assert_eq!</code>와 <code>assert_ne!</code>라는 한 쌍의 매크로를 제공합니다. 이 매크로들은 각각 두 인수를 비교하여 같은지 또는 다른지 확인합니다. 또한 단언(assertion)이 실패할 경우 두 값을 모두 출력하므로, 테스트가 <em>왜</em> 실패했는지 더 쉽게 알 수 있습니다. 반면 <code>assert!</code> 매크로는 <code>==</code> 표현식에 대해 <code>false</code> 값을 얻었다는 것만 알려줄 뿐, <code>false</code> 값을 유도한 두 값들을 출력하지는 않습니다.</p>
<p>In Listing 11-7, we write a function named <code>add_two</code> that adds <code>2</code> to its parameter, and then we test this function using the <code>assert_eq!</code> macro.</p>
<Listing number="11-7" file-name="src/lib.rs" caption="Testing the function `add_two` using the `assert_eq!` macro">
<pre><code class="language-rust noplayground">pub fn add_two(a: u64) -&gt; u64 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        let result = add_two(2);
        assert_eq!(result, 4);
    }
}</code></pre>
</Listing>
<p>통과하는지 확인해 봅시다!</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>We create a variable named <code>result</code> that holds the result of calling <code>add_two(2)</code>. Then, we pass <code>result</code> and <code>4</code> as the arguments to the <code>assert_eq!</code> macro. The output line for this test is <code>test tests::it_adds_two ... ok</code>, and the <code>ok</code> text indicates that our test passed!</p>
<p>실패했을 때 <code>assert_eq!</code>가 어떻게 보이는지 확인하기 위해 코드에 버그를 도입해 봅시다. <code>add_two</code> 함수의 구현을 <code>2</code> 대신 <code>3</code>을 더하도록 변경합니다:</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn add_two(a: u64) -&gt; u64 {
    a + 3
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_adds_two() {
</span><span class="boring">        let result = add_two(2);
</span><span class="boring">        assert_eq!(result, 4);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>테스트를 다시 실행합니다:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----

thread 'tests::it_adds_two' panicked at src/lib.rs:12:9:
assertion `left == right` failed
  left: 5
 right: 4
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Our test caught the bug! The <code>tests::it_adds_two</code> test failed, and the message tells us that the assertion that failed was <code>left == right</code> and what the <code>left</code> and <code>right</code> values are. This message helps us start debugging: The <code>left</code> argument, where we had the result of calling <code>add_two(2)</code>, was <code>5</code>, but the <code>right</code> argument was <code>4</code>. You can imagine that this would be especially helpful when we have a lot of tests going on.</p>
<p>Note that in some languages and test frameworks, the parameters to equality assertion functions are called <code>expected</code> and <code>actual</code>, and the order in which we specify the arguments matters. However, in Rust, they’re called <code>left</code> and <code>right</code>, and the order in which we specify the value we expect and the value the code produces doesn’t matter. We could write the assertion in this test as <code>assert_eq!(4, result)</code>, which would result in the same failure message that displays <code>assertion `left == right` failed</code>.</p>
<p>The <code>assert_ne!</code> macro will pass if the two values we give it are not equal and will fail if they are equal. This macro is most useful for cases when we’re not sure what a value <em>will</em> be, but we know what the value definitely <em>shouldn’t</em> be. For example, if we’re testing a function that is guaranteed to change its input in some way, but the way in which the input is changed depends on the day of the week that we run our tests, the best thing to assert might be that the output of the function is not equal to the input.</p>
<p>내부적으로 <code>assert_eq!</code>와 <code>assert_ne!</code> 매크로는 각각 <code>==</code>와 <code>!=</code> 연산자를 사용합니다. 단언이 실패할 경우, 이 매크로들은 디버그 포맷팅을 사용하여 인수들을 출력합니다. 이는 비교 대상이 되는 값들이 반드시 <code>PartialEq</code>와 <code>Debug</code> 트레이트를 구현해야 함을 의미합니다. 모든 기본 타입들과 대부분의 표준 라이브러리 타입들은 이 트레이트들을 구현하고 있습니다. 직접 정의한 구조체나 열거형의 경우, 해당 타입의 일치 여부를 단언하려면 <code>PartialEq</code>를 구현해야 합니다. 또한 단언이 실패했을 때 값을 출력하려면 <code>Debug</code>도 구현해야 합니다. 5장의 목록 5-12에서 언급했듯이 두 트레이트 모두 파생 가능한(derivable) 트레이트이므로, 구조체나 열거형 정의 위에 <code>#[derive(PartialEq, Debug)]</code> 어노테이션을 추가하는 것만으로 충분한 경우가 많습니다. 이 트레이트들과 다른 파생 가능한 트레이트들에 대한 자세한 내용은 부록 C, <a href="appendix-03-derivable-traits.html">“파생 가능한 트레이트”</a><!-- ignore -->를 참조하세요.</p>
<h3 id="커스텀-실패-메시지-추가하기"><a class="header" href="#커스텀-실패-메시지-추가하기">커스텀 실패 메시지 추가하기</a></h3>
<p>You can also add a custom message to be printed with the failure message as optional arguments to the <code>assert!</code>, <code>assert_eq!</code>, and <code>assert_ne!</code> macros. Any arguments specified after the required arguments are passed along to the <code>format!</code> macro (discussed in <a href="ch08-02-strings.html#concatenating-with--or-format">“Concatenating with <code>+</code> or <code>format!</code>”</a><!--
ignore --> in Chapter 8), so you can pass a format string that contains <code>{}</code> placeholders and values to go in those placeholders. Custom messages are useful for documenting what an assertion means; when a test fails, you’ll have a better idea of what the problem is with the code.</p>
<p>예를 들어, 사람의 이름을 받아 인사를 하는 함수가 있고, 함수에 전달한 이름이 출력 결과에 포함되는지 테스트하고 싶다고 가정해 봅시다:</p>
<p><span class="filename">파일명: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    format!("Hello {name}!")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting("Carol");
        assert!(result.contains("Carol"));
    }
}</code></pre>
<p>이 프로그램의 요구사항은 아직 합의되지 않았으며, 인삿말 시작 부분의 <code>Hello</code>라는 텍스트가 바뀔 것이 거의 확실합니다. 우리는 요구사항이 바뀔 때마다 테스트를 업데이트하고 싶지 않으므로, <code>greeting</code> 함수에서 반환된 값과 정확히 일치하는지 확인하는 대신, 출력이 입력 매개변수의 텍스트를 포함하고 있는지만 단언하기로 결정했습니다.</p>
<p>이제 기본 테스트 실패가 어떻게 보이는지 확인하기 위해, <code>greeting</code>에서 <code>name</code>을 제외하도록 코드를 수정하여 버그를 도입해 봅시다:</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    String::from("Hello!")
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greeting_contains_name() {
</span><span class="boring">        let result = greeting("Carol");
</span><span class="boring">        assert!(result.contains("Carol"));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>이 테스트를 실행하면 다음과 같은 결과가 나옵니다:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----

thread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:
assertion failed: result.contains("Carol")
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>이 결과는 단지 단언이 실패했다는 것과 단언이 몇 번째 줄에 있는지만을 알려줍니다. 더 유용한 실패 메시지는 <code>greeting</code> 함수로부터 얻은 값을 출력하는 것입니다. <code>greeting</code> 함수로부터 실제로 얻은 값을 자리표시자에 채워 넣는 포맷 문자열로 구성된 커스텀 실패 메시지를 추가해 봅시다:</p>
<pre><code class="language-rust ignore"><span class="boring">pub fn greeting(name: &amp;str) -&gt; String {
</span><span class="boring">    String::from("Hello!")
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn greeting_contains_name() {
        let result = greeting("Carol");
        assert!(
            result.contains("Carol"),
            "Greeting did not contain name, value was `{result}`"
        );
    }
<span class="boring">}</span></code></pre>
<p>이제 테스트를 실행하면 더 많은 정보를 담은 에러 메시지를 얻게 됩니다:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.93s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----

thread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:
Greeting did not contain name, value was `Hello!`
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>테스트 출력에서 실제로 얻은 값을 확인할 수 있으며, 이는 우리가 기대했던 일 대신 어떤 일이 일어났는지 디버깅하는 데 도움이 될 것입니다.</p>
<h3 id="should_panic을-이용한-패닉-확인"><a class="header" href="#should_panic을-이용한-패닉-확인"><code>should_panic</code>을 이용한 패닉 확인</a></h3>
<p>반환 값을 확인하는 것뿐만 아니라, 우리 코드가 예상대로 에러 조건을 처리하는지 확인하는 것도 중요합니다. 예를 들어, 9장의 목록 9-13에서 만들었던 <code>Guess</code> 타입을 생각해 봅시다. <code>Guess</code>를 사용하는 다른 코드들은 <code>Guess</code> 인스턴스가 1에서 100 사이의 값만을 포함한다는 보장에 의존합니다. 우리는 해당 범위를 벗어나는 값으로 <code>Guess</code> 인스턴스를 생성하려 할 때 패닉이 발생하는지 보장하는 테스트를 작성할 수 있습니다.</p>
<p>이는 테스트 함수에 <code>should_panic</code> 속성을 추가함으로써 가능합니다. 이 속성이 추가된 테스트는 함수 내부의 코드가 패닉을 일으키면 통과하고, 패닉을 일으키지 않으면 실패합니다.</p>
<p>목록 11-8은 <code>Guess::new</code>의 에러 조건이 우리가 예상한 대로 발생하는지 확인하는 테스트를 보여줍니다.</p>
<Listing number="11-8" file-name="src/lib.rs" caption="Testing that a condition will cause a `panic!`">
<pre><code class="language-rust noplayground">pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(추측 값은 1에서 100 사이여야 합니다. {value}를 받았습니다.);
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}</code></pre>
</Listing>
<p><code>#[should_panic]</code> 속성은 <code>#[test]</code> 속성 뒤, 그리고 해당 속성이 적용될 테스트 함수 앞에 배치합니다. 이 테스트가 통과했을 때의 결과를 살펴봅시다:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests guessing_game

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>좋군요! 이제 100보다 큰 값일 때 <code>new</code> 함수가 패닉을 일으켜야 한다는 조건을 제거하여 코드에 버그를 도입해 봅시다:</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --생략--
impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(추측 값은 1에서 100 사이여야 합니다. {value}를 받았습니다.);
        }

        Guess { value }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>목록 11-8의 테스트를 실행하면, 다음과 같이 실패할 것입니다:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
note: test did not panic as expected at src/lib.rs:21:8

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>이 경우에는 아주 도움이 되는 메시지를 얻지는 못하지만, 테스트 함수를 살펴보면 <code>#[should_panic]</code>이 달려 있는 것을 볼 수 있습니다. 우리가 받은 실패는 테스트 함수 내의 코드가 패닉을 일으키지 않았음을 의미합니다.</p>
<p><code>should_panic</code>을 사용하는 테스트는 부정확할 수 있습니다. 우리가 예상한 이유와 다른 이유로 패닉이 발생하더라도 <code>should_panic</code> 테스트는 통과될 수 있기 때문입니다. <code>should_panic</code> 테스트를 더 정확하게 만들기 위해 <code>should_panic</code> 속성에 선택적인 <code>expected</code> 매개변수를 추가할 수 있습니다. 테스트 하네스는 실패 메시지가 제공된 텍스트를 포함하는지 확인합니다. 예를 들어, 목록 11-9와 같이 값이 너무 작거나 큰지에 따라 다른 메시지로 패닉을 일으키도록 수정된 <code>Guess</code> 코드를 생각해 봅시다.</p>
<Listing number="11-9" file-name="src/lib.rs" caption="Testing for a `panic!` with a panic message containing a specified substring">
<pre><code class="language-rust noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --생략--

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(
                "Guess value must be greater than or equal to 1, got {value}."
            );
        } else if value &gt; 100 {
            panic!(
                "Guess value must be less than or equal to 100, got {value}."
            );
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = "less than or equal to 100")]
    fn greater_than_100() {
        Guess::new(200);
    }
}</code></pre>
</Listing>
<p>이 테스트는 통과하는데, <code>should_panic</code> 속성의 <code>expected</code> 매개변수에 넣은 값이 <code>Guess::new</code> 함수가 패닉을 일으킬 때의 메시지의 부분 문자열이기 때문입니다. 우리가 기대하는 전체 패닉 메시지를 지정할 수도 있었는데, 이 경우에는 <code>Guess value must be less than or equal to 100, got 200</code>이 될 것입니다. 무엇을 지정할지는 패닉 메시지의 얼마나 많은 부분이 고유하거나 동적인지, 그리고 테스트를 얼마나 정밀하게 만들고 싶은지에 따라 달라집니다. 이번 경우에는 패닉 메시지의 부분 문자열만으로도 테스트 함수의 코드가 <code>else if value &gt; 100</code> 케이스를 실행하는지 보장하기에 충분합니다.</p>
<p><code>expected</code> 메시지가 있는 <code>should_panic</code> 테스트가 실패하면 어떤 일이 일어나는지 확인하기 위해, <code>if value &lt; 1</code> 블록과 <code>else if value &gt; 100</code> 블록의 본문을 서로 바꿔서 코드에 다시 버그를 도입해 봅시다:</p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Guess {
</span><span class="boring">    pub fn new(value: i32) -&gt; Guess {
</span>        if value &lt; 1 {
            panic!(
                "Guess value must be less than or equal to 100, got {value}."
            );
        } else if value &gt; 100 {
            panic!(
                "Guess value must be greater than or equal to 1, got {value}."
            );
        }
<span class="boring">
</span><span class="boring">        Guess { value }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic(expected = "less than or equal to 100")]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>이번에 <code>should_panic</code> 테스트를 실행하면, 다음과 같이 실패할 것입니다:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----

thread 'tests::greater_than_100' panicked at src/lib.rs:12:13:
Guess value must be greater than or equal to 1, got 200.
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
note: panic did not contain expected string
      panic message: "Guess value must be greater than or equal to 1, got 200."
 expected substring: "less than or equal to 100"

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>The failure message indicates that this test did indeed panic as we expected, but the panic message did not include the expected string <code>less than or equal to 100</code>. The panic message that we did get in this case was <code>Guess value must be greater than or equal to 1, got 200</code>. Now we can start figuring out where our bug is!</p>
<h3 id="테스트에서-resultt-e-사용하기"><a class="header" href="#테스트에서-resultt-e-사용하기">테스트에서 <code>Result&lt;T, E&gt;</code> 사용하기</a></h3>
<p>All of our tests so far panic when they fail. We can also write tests that use <code>Result&lt;T, E&gt;</code>! Here’s the test from Listing 11-1, rewritten to use <code>Result&lt;T, E&gt;</code> and return an <code>Err</code> instead of panicking:</p>
<pre><code class="language-rust noplayground"><span class="boring">pub fn add(left: u64, right: u64) -&gt; u64 {
</span><span class="boring">    left + right
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() -&gt; Result&lt;(), String&gt; {
        let result = add(2, 2);

        if result == 4 {
            Ok(())
        } else {
            Err(String::from("two plus two does not equal four"))
        }
    }
}</code></pre>
<p>이제 <code>it_works</code> 함수는 <code>Result&lt;(), String&gt;</code> 반환 타입을 가집니다. 함수 본문에서 <code>assert_eq!</code> 매크로를 호출하는 대신, 테스트가 통과하면 <code>Ok(())</code>를 반환하고 테스트가 실패하면 <code>String</code>을 담은 <code>Err</code>을 반환합니다.</p>
<p>Writing tests so that they return a <code>Result&lt;T, E&gt;</code> enables you to use the question mark operator in the body of tests, which can be a convenient way to write tests that should fail if any operation within them returns an <code>Err</code> variant.</p>
<p><code>Result&lt;T, E&gt;</code>를 사용하는 테스트에는 <code>#[should_panic]</code> 어노테이션을 사용할 수 없습니다. 어떤 연산이 <code>Err</code> 변형을 반환함을 단언하려면, <code>Result&lt;T, E&gt;</code> 값에 물음표 연산자를 사용하지 <em>마세요</em>. 대신 <code>assert!(value.is_err())</code>를 사용하세요.</p>
<p>이제 테스트를 작성하는 여러 가지 방법을 알게 되었으니, 테스트를 실행할 때 어떤 일이 일어나는지 살펴보고 <code>cargo test</code>와 함께 사용할 수 있는 다양한 옵션들을 탐구해 봅시다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch11-00-testing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch11-02-running-tests.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch11-00-testing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch11-02-running-tests.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
