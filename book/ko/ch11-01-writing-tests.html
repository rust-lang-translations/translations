<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>테스트 작성 방법 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch11-01-writing-tests.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch11-01-writing-tests.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="테스트-작성-방법"><a class="header" href="#테스트-작성-방법">테스트 작성 방법</a></h2>
<p>테스트는 비테스트 코드가 예상대로 작동하는지 확인하는 러스트 함수입니다. 테스트 함수의 본문은 일반적으로 다음 세 가지 작업을 수행합니다:</p>
<ul>
<li>필요한 데이터 또는 상태를 설정합니다.</li>
<li>테스트하려는 코드를 실행합니다.</li>
<li>결과가 예상한 것과 일치하는지 단언합니다.</li>
</ul>
<p>러스트가 이러한 작업을 수행하는 테스트 작성을 위해 특별히 제공하는 기능을 살펴보겠습니다. 여기에는 <code>test</code> 속성, 몇 가지 매크로, 그리고 <code>should_panic</code> 속성이 포함됩니다.</p>
<h3 id="테스트-함수의-구조"><a class="header" href="#테스트-함수의-구조">테스트 함수의 구조</a></h3>
<p>가장 간단하게, 러스트의 테스트는 <code>test</code> 속성으로 주석이 달린 함수입니다. 속성은 러스트 코드 조각에 대한 메타데이터입니다. 한 가지 예는 5장에서 구조체와 함께 사용했던 <code>derive</code> 속성입니다. 함수를 테스트 함수로 변경하려면 <code>fn</code> 앞에 <code>#[test]</code>를 추가합니다. <code>cargo test</code> 명령으로 테스트를 실행하면, 러스트는 주석이 달린 함수를 실행하고 각 테스트 함수가 통과했는지 실패했는지 보고하는 테스트 러너 바이너리를 빌드합니다.</p>
<p>Cargo로 새 라이브러리 프로젝트를 만들 때마다 테스트 함수가 포함된 테스트 모듈이 자동으로 생성됩니다. 이 모듈은 테스트 작성을 위한 템플릿을 제공하므로 새 프로젝트를 시작할 때마다 정확한 구조와 구문을 찾아볼 필요가 없습니다. 원하는 만큼 추가 테스트 함수와 테스트 모듈을 추가할 수 있습니다!</p>
<p>실제로 코드를 테스트하기 전에 템플릿 테스트를 실험하여 테스트가 어떻게 작동하는지 몇 가지 측면을 탐구할 것입니다. 그런 다음 우리가 작성한 코드를 호출하고 그 동작이 올바른지 단언하는 실제 테스트를 작성할 것입니다.</p>
<p>두 숫자를 더하는 <code>adder</code>라는 새 라이브러리 프로젝트를 만들어 보겠습니다:</p>
<pre><code class="language-console">$ cargo new adder --lib
     Created library `adder` project
$ cd adder
</code></pre>
<p>여러분의 <code>adder</code> 라이브러리의 <em>src/lib.rs</em> 파일 내용은 목록 11-1과 같아야 합니다.</p>
<Listing number="11-1" file-name="src/lib.rs" caption="The code generated automatically by `cargo new`">
<!-- manual-regeneration
cd listings/ch11-writing-automated-tests
rm -rf listing-11-01
cargo new listing-11-01 --lib --name adder
cd listing-11-01
echo "$ cargo test" > output.txt
RUSTFLAGS="-A unused_variables -A dead_code" RUST_TEST_THREADS=1 cargo test >> output.txt 2>&1
git diff output.txt # commit any relevant changes; discard irrelevant ones
cd ../../..
-->
<pre><code class="language-rust noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
</Listing>
<p>파일은 예제 <code>add</code> 함수로 시작하므로, 테스트할 무언가가 있습니다.</p>
<p>지금은 <code>it_works</code> 함수에만 집중해 봅시다. <code>#[test]</code> 어노테이션에 주목하세요. 이 속성은 이것이 테스트 함수임을 나타내므로, 테스트 러너는 이 함수를 테스트로 처리해야 한다는 것을 압니다. <code>tests</code> 모듈에는 공통 시나리오를 설정하거나 공통 작업을 수행하는 데 도움이 되는 비테스트 함수도 있을 수 있으므로, 어떤 함수가 테스트인지 항상 표시해야 합니다.</p>
<p>예제 함수 본문은 <code>assert_eq!</code> 매크로를 사용하여 2와 2를 더한 <code>add</code> 호출의 결과인 <code>result</code>가 4와 같음을 단언합니다. 이 단언은 일반적인 테스트 형식의 예시 역할을 합니다. 이 테스트가 통과하는지 확인하기 위해 실행해 봅시다.</p>
<p>목록 11-2에 나온 것처럼 <code>cargo test</code> 명령은 프로젝트의 모든 테스트를 실행합니다.</p>
<Listing number="11-2" caption="The output from running the automatically generated test">
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.57s
     Running unittests src/lib.rs (file:///projects/adder/target/debug/deps/adder-7acb243c25ffd9dc)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
</Listing>
<p>Cargo가 테스트를 컴파일하고 실행했습니다. <code>running 1 test</code> 줄이 보입니다. 다음 줄은 생성된 테스트 함수 <code>tests::it_works</code>의 이름과 해당 테스트 실행 결과가 <code>ok</code>임을 보여줍니다. 전체 요약 <code>test result: ok.</code>는 모든 테스트가 통과했음을 의미하며, <code>1 passed; 0 failed</code> 부분은 통과하거나 실패한 테스트의 총 개수를 나타냅니다.</p>
<p>특정 인스턴스에서 실행되지 않도록 테스트를 무시로 표시할 수 있습니다. 이에 대해서는 이 장의 뒷부분에 있는 <a href="ch11-02-running-tests.html#ignoring-some-tests-unless-specifically-requested">“특별히 요청하지 않는 한 일부 테스트 무시하기”</a><!-- ignore --> 섹션에서 다룰 것입니다. 여기서는 그렇게 하지 않았으므로 요약에는 <code>0 ignored</code>가 표시됩니다. <code>cargo test</code> 명령에 문자열과 이름이 일치하는 테스트만 실행하도록 인수를 전달할 수도 있습니다. 이를 _필터링_이라고 하며, <a href="ch11-02-running-tests.html#running-a-subset-of-tests-by-name">“이름으로 테스트 하위 집합 실행하기”</a><!-- ignore --> 섹션에서 다룰 것입니다. 여기서는 실행되는 테스트를 필터링하지 않았으므로 요약 끝에는 <code>0 filtered out</code>이 표시됩니다.</p>
<p><code>0 measured</code> 통계는 성능을 측정하는 벤치마크 테스트를 위한 것입니다. 벤치마크 테스트는 이 글을 쓰는 시점에는 nightly Rust에서만 사용할 수 있습니다. 자세한 내용은 <a href="../unstable-book/library-features/test.html">벤치마크 테스트에 대한 문서</a>를 참조하세요.</p>
<p><code>Doc-tests adder</code>에서 시작하는 테스트 출력의 다음 부분은 모든 문서 테스트 결과에 대한 것입니다. 아직 문서 테스트는 없지만, 러스트는 API 문서에 나타나는 모든 코드 예제를 컴파일할 수 있습니다. 이 기능은 문서와 코드를 동기화하는 데 도움이 됩니다! 14장의 <a href="ch14-02-publishing-to-crates-io.html#documentation-comments-as-tests">“테스트로서의 문서 주석”</a><!-- ignore --> 섹션에서 문서 테스트를 작성하는 방법을 논의할 것입니다. 지금은 <code>Doc-tests</code> 출력을 무시하겠습니다.</p>
<p>이제 테스트를 우리의 필요에 맞게 사용자 정의해 봅시다. 먼저 <code>it_works</code> 함수의 이름을 <code>exploration</code>과 같은 다른 이름으로 변경합니다. 다음과 같이 말이죠:</p>
<p><span class="filename">파일명: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn exploration() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<p>그런 다음 <code>cargo test</code>를 다시 실행합니다. 이제 출력은 <code>it_works</code> 대신 <code>exploration</code>을 보여줍니다:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.59s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>이제 또 다른 테스트를 추가할 것입니다. 하지만 이번에는 실패하는 테스트를 만들 것입니다! 테스트 함수 내에서 무언가가 패닉을 일으키면 테스트는 실패합니다. 각 테스트는 새 스레드에서 실행되며, 메인 스레드가 테스트 스레드가 종료된 것을 확인하면 테스트는 실패로 표시됩니다. 9장에서 가장 간단한 패닉 방법은 <code>panic!</code> 매크로를 호출하는 것이라고 이야기했습니다. 새 테스트를 <code>another</code>라는 함수로 입력하면 <em>src/lib.rs</em> 파일은 목록 11-3과 같아집니다.</p>
<Listing number="11-3" file-name="src/lib.rs" caption="Adding a second test that will fail because we call the `panic!` macro">
<pre><code class="language-rust panics noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn exploration() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }

    #[test]
    fn another() {
        panic!("이 테스트를 실패하게 만드세요");
    }
}</code></pre>
</Listing>
<p><code>cargo test</code>를 사용하여 테스트를 다시 실행합니다. 출력은 목록 11-4와 같아야 하며, <code>exploration</code> 테스트는 통과하고 <code>another</code> 테스트는 실패했음을 보여줍니다.</p>
<Listing number="11-4" caption="Test results when one test passes and one test fails">
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.72s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::another ... FAILED
test tests::exploration ... ok

failures:

---- tests::another stdout ----
thread 'tests::another' panicked at src/lib.rs:17:9:
Make this test fail
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
</Listing>
<!-- manual-regeneration
rg panicked listings/ch11-writing-automated-tests/listing-11-03/output.txt
check the line number of the panic matches the line number in the following paragraph
 -->
<p><code>ok</code> 대신 <code>test tests::another</code> 줄은 <code>FAILED</code>를 보여줍니다. 개별 결과와 요약 사이에 두 개의 새로운 섹션이 나타납니다. 첫 번째 섹션은 각 테스트 실패에 대한 자세한 이유를 표시합니다. 이 경우 <code>another</code>가 <em>src/lib.rs</em> 파일의 17번째 줄에서 <code>panicked at 'Make this test fail'</code>로 인해 실패했다는 세부 정보를 얻습니다. 다음 섹션은 실패한 모든 테스트의 이름만 나열하며, 이는 많은 테스트와 많은 자세한 실패 테스트 출력이 있을 때 유용합니다. 실패한 테스트의 이름을 사용하여 해당 테스트만 실행하여 더 쉽게 디버깅할 수 있습니다. <a href="ch11-02-running-tests.html#controlling-how-tests-are-run">“테스트 실행 방법 제어하기”</a><!-- ignore --> 섹션에서 테스트 실행 방법에 대해 더 자세히 이야기할 것입니다.</p>
<p>요약 줄은 마지막에 표시됩니다. 전체적으로 테스트 결과는 <code>FAILED</code>입니다. 하나의 테스트가 통과했고 하나의 테스트가 실패했습니다.</p>
<p>이제 다양한 시나리오에서 테스트 결과가 어떻게 보이는지 확인했으니, 테스트에 유용한 <code>panic!</code> 외의 다른 매크로들을 살펴보겠습니다.</p>
<h3 id="assert-매크로로-결과-확인하기"><a class="header" href="#assert-매크로로-결과-확인하기"><code>assert!</code> 매크로로 결과 확인하기</a></h3>
<p>표준 라이브러리에서 제공하는 <code>assert!</code> 매크로는 테스트의 어떤 조건이 <code>true</code>임을 보장하고 싶을 때 유용합니다. <code>assert!</code> 매크로에는 불리언으로 평가되는 인수를 전달합니다. 값이 <code>true</code>이면 아무 일도 일어나지 않고 테스트는 통과합니다. 값이 <code>false</code>이면 <code>assert!</code> 매크로는 <code>panic!</code>을 호출하여 테스트를 실패하게 만듭니다. <code>assert!</code> 매크로를 사용하면 우리 코드가 의도한 대로 작동하는지 확인하는 데 도움이 됩니다.</p>
<p>5장 목록 5-15에서 <code>Rectangle</code> 구조체와 <code>can_hold</code> 메서드를 사용했는데, 이는 목록 11-5에 다시 반복됩니다. 이 코드를 <em>src/lib.rs</em> 파일에 넣고, <code>assert!</code> 매크로를 사용하여 몇 가지 테스트를 작성해 봅시다.</p>
<Listing number="11-5" file-name="src/lib.rs" caption="The `Rectangle` struct and its `can_hold` method from Chapter 5">
<pre><code class="language-rust noplayground">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}</code></pre>
</Listing>
<p><code>can_hold</code> 메서드는 불리언을 반환하므로, <code>assert!</code> 매크로에 완벽한 사용 사례입니다. 목록 11-6에서는 너비 8, 높이 7인 <code>Rectangle</code> 인스턴스를 생성하고, 너비 5, 높이 1인 다른 <code>Rectangle</code> 인스턴스를 담을 수 있음을 단언하여 <code>can_hold</code> 메서드를 테스트하는 코드를 작성합니다.</p>
<Listing number="11-6" file-name="src/lib.rs" caption="A test for `can_hold` that checks whether a larger rectangle can indeed hold a smaller rectangle">
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(larger.can_hold(&amp;smaller));
    }
}</code></pre>
</Listing>
<p>Note the <code>use super::*;</code> line inside the <code>tests</code> module. The <code>tests</code> module is a regular module that follows the usual visibility rules we covered in Chapter 7 in the <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“Paths for Referring to an Item in the Module Tree”</a><!-- ignore --> section. Because the <code>tests</code> module is an inner module, we need to bring the code under test in the outer module into the scope of the inner module. We use a glob here, so anything we define in the outer module is available to this <code>tests</code> module.</p>
<p>우리는 테스트 이름을 <code>larger_can_hold_smaller</code>로 지정했고, 필요한 두 <code>Rectangle</code> 인스턴스를 생성했습니다. 그런 다음 <code>assert!</code> 매크로를 호출하고 <code>larger.can_hold(&amp;smaller)</code> 호출 결과를 전달했습니다. 이 표현식은 <code>true</code>를 반환해야 하므로 테스트는 통과해야 합니다. 확인해 봅시다!</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>통과했습니다! 이제 다른 테스트를 추가해 봅시다. 이번에는 더 작은 사각형이 더 큰 사각형을 담을 수 없음을 단언하는 테스트입니다:</p>
<p><span class="filename">파일명: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        // --생략--
<span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span>    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(!smaller.can_hold(&amp;larger));
    }
}</code></pre>
<p>이 경우 <code>can_hold</code> 함수의 올바른 결과는 <code>false</code>이므로, <code>assert!</code> 매크로에 전달하기 전에 그 결과를 부정해야 합니다. 결과적으로 <code>can_hold</code>가 <code>false</code>를 반환하면 테스트는 통과할 것입니다:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... ok
test tests::smaller_cannot_hold_larger ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>두 개의 테스트가 통과했습니다! 이제 코드에 버그를 도입했을 때 테스트 결과가 어떻게 되는지 살펴봅시다. 너비를 비교할 때 <code>can_hold</code> 메서드의 구현에서 크다 기호를 작다 기호로 변경할 것입니다:</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>// --생략--
impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &lt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn larger_can_hold_smaller() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn smaller_cannot_hold_larger() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(!smaller.can_hold(&amp;larger));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>이제 테스트를 실행하면 다음과 같은 결과가 나옵니다:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... FAILED
test tests::smaller_cannot_hold_larger ... ok

failures:

---- tests::larger_can_hold_smaller stdout ----
thread 'tests::larger_can_hold_smaller' panicked at src/lib.rs:28:9:
assertion failed: larger.can_hold(&amp;smaller)
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>우리 테스트가 버그를 잡았습니다! <code>larger.width</code>는 <code>8</code>이고 <code>smaller.width</code>는 <code>5</code>이므로, <code>can_hold</code>에서의 너비 비교는 이제 <code>false</code>를 반환합니다. 8은 5보다 작지 않기 때문입니다.</p>
<h3 id="assert_eq와-assert_ne-매크로를-이용한-공통성-테스트"><a class="header" href="#assert_eq와-assert_ne-매크로를-이용한-공통성-테스트"><code>assert_eq!</code>와 <code>assert_ne!</code> 매크로를 이용한 공통성 테스트</a></h3>
<p>기능을 검증하는 일반적인 방법은 테스트 중인 코드의 결과와 코드가 반환할 것으로 기대하는 값 사이의 일치 여부를 테스트하는 것입니다. 이는 <code>assert!</code> 매크로에 <code>==</code> 연산자를 사용하는 표현식을 전달하여 수행할 수 있습니다. 하지만 이는 매우 흔한 테스트이므로, 표준 라이브러리는 이 테스트를 더 편리하게 수행할 수 있도록 <code>assert_eq!</code>와 <code>assert_ne!</code>라는 한 쌍의 매크로를 제공합니다. 이 매크로들은 각각 두 인수를 비교하여 같은지 또는 다른지 확인합니다. 또한 단언(assertion)이 실패할 경우 두 값을 모두 출력하므로, 테스트가 <em>왜</em> 실패했는지 더 쉽게 알 수 있습니다. 반면 <code>assert!</code> 매크로는 <code>==</code> 표현식에 대해 <code>false</code> 값을 얻었다는 것만 알려줄 뿐, <code>false</code> 값을 유도한 두 값들을 출력하지는 않습니다.</p>
<p>목록 11-7에서는 매개변수에 <code>2</code>를 더하는 <code>add_two</code> 함수를 작성하고, <code>assert_eq!</code> 매크로를 사용하여 이 함수를 테스트합니다.</p>
<Listing number="11-7" file-name="src/lib.rs" caption="Testing the function `add_two` using the `assert_eq!` macro">
<pre><code class="language-rust noplayground">pub fn add_two(a: usize) -&gt; usize {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        let result = add_two(2);
        assert_eq!(result, 4);
    }
}</code></pre>
</Listing>
<p>통과하는지 확인해 봅시다!</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p><code>add_two(2)</code>를 호출한 결과를 담는 <code>result</code>라는 변수를 생성합니다. 그런 다음 <code>result</code>와 <code>4</code>를 <code>assert_eq!</code>의 인수로 전달합니다. 이 테스트의 출력 라인은 <code>test tests::it_adds_two ... ok</code>이며, <code>ok</code> 텍스트는 우리 테스트가 통과했음을 나타냅니다!</p>
<p>실패했을 때 <code>assert_eq!</code>가 어떻게 보이는지 확인하기 위해 코드에 버그를 도입해 봅시다. <code>add_two</code> 함수의 구현을 <code>2</code> 대신 <code>3</code>을 더하도록 변경합니다:</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn add_two(a: usize) -&gt; usize {
    a + 3
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_adds_two() {
</span><span class="boring">        let result = add_two(2);
</span><span class="boring">        assert_eq!(result, 4);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>테스트를 다시 실행합니다:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----
thread 'tests::it_adds_two' panicked at src/lib.rs:12:9:
assertion `left == right` failed
  left: 5
 right: 4
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>우리 테스트가 버그를 잡았습니다! <code>it_adds_two</code> 테스트가 실패했고, 메시지는 실패한 단언이 <code>assertion `left == right` failed</code>라는 것과 <code>left</code> 및 <code>right</code> 값이 무엇인지 알려줍니다. 이 메시지는 디버깅을 시작하는 데 도움이 됩니다. <code>add_two(2)</code>를 호출한 결과인 <code>left</code> 인수는 <code>5</code>였지만, <code>right</code> 인수는 <code>4</code>였습니다. 테스트가 많을 때 이 메시지가 특히 얼마나 도움이 될지 상상하실 수 있을 것입니다.</p>
<p>어떤 언어나 테스트 프레임워크에서는 일치 여부 단언 함수의 매개변수를 <code>expected</code>와 <code>actual</code>이라고 부르며, 인수를 지정하는 순서가 중요합니다. 하지만 러스트에서는 <code>left</code>와 <code>right</code>라고 부르며, 우리가 기대하는 값과 코드가 생성한 값의 순서는 중요하지 않습니다. 이 테스트의 단언을 <code>assert_eq!(4, result)</code>라고 작성할 수도 있으며, 이 경우에도 여전히 <code>assertion failed: `(left == right)`</code>라는 동일한 실패 메시지가 나타날 것입니다.</p>
<p><code>assert_ne!</code> 매크로는 우리가 전달한 두 값이 서로 같지 않으면 통과하고, 같으면 실패합니다. 이 매크로는 어떤 값이 <em>무엇이 될지</em> 확신할 수는 없지만, 무엇이 <em>되어서는 안 되는지</em> 확실히 알고 있는 경우에 가장 유용합니다. 예를 들어, 입력값을 어떤 식으로든 변경하는 것이 보장된 함수를 테스트하는데, 그 변경 방식이 테스트를 실행하는 요일에 따라 달라진다면, 함수의 출력값이 입력값과 같지 않음을 단언하는 것이 가장 좋은 방법일 수 있습니다.</p>
<p>내부적으로 <code>assert_eq!</code>와 <code>assert_ne!</code> 매크로는 각각 <code>==</code>와 <code>!=</code> 연산자를 사용합니다. 단언이 실패할 경우, 이 매크로들은 디버그 포맷팅을 사용하여 인수들을 출력합니다. 이는 비교 대상이 되는 값들이 반드시 <code>PartialEq</code>와 <code>Debug</code> 트레이트를 구현해야 함을 의미합니다. 모든 기본 타입들과 대부분의 표준 라이브러리 타입들은 이 트레이트들을 구현하고 있습니다. 직접 정의한 구조체나 열거형의 경우, 해당 타입의 일치 여부를 단언하려면 <code>PartialEq</code>를 구현해야 합니다. 또한 단언이 실패했을 때 값을 출력하려면 <code>Debug</code>도 구현해야 합니다. 5장의 목록 5-12에서 언급했듯이 두 트레이트 모두 파생 가능한(derivable) 트레이트이므로, 구조체나 열거형 정의 위에 <code>#[derive(PartialEq, Debug)]</code> 어노테이션을 추가하는 것만으로 충분한 경우가 많습니다. 이 트레이트들과 다른 파생 가능한 트레이트들에 대한 자세한 내용은 부록 C, <a href="appendix-03-derivable-traits.html">“파생 가능한 트레이트”</a><!-- ignore -->를 참조하세요.</p>
<h3 id="커스텀-실패-메시지-추가하기"><a class="header" href="#커스텀-실패-메시지-추가하기">커스텀 실패 메시지 추가하기</a></h3>
<p><code>assert!</code>, <code>assert_eq!</code>, <code>assert_ne!</code> 매크로의 선택적 인수로 실패 메시지와 함께 출력될 커스텀 메시지를 추가할 수도 있습니다. 필수 인수 뒤에 지정된 모든 인수는 <code>format!</code> 매크로(8장의 <a href="ch08-02-strings.html#concatenation-with-the--operator-or-the-format-macro">“<code>+</code> 연산자나 <code>format!</code> 매크로를 이용한 연결”</a><!-- ignore -->에서 다룸)로 전달되므로, <code>{}</code> 자리표시자와 그 안에 들어갈 값들을 포함한 포맷 문자열을 전달할 수 있습니다. 커스텀 메시지는 단언이 무엇을 의미하는지 문서화하는 데 유용하며, 테스트가 실패했을 때 코드의 어떤 부분이 문제인지 더 잘 파악할 수 있게 해줍니다.</p>
<p>예를 들어, 사람의 이름을 받아 인사를 하는 함수가 있고, 함수에 전달한 이름이 출력 결과에 포함되는지 테스트하고 싶다고 가정해 봅시다:</p>
<p><span class="filename">파일명: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    format!("Hello {name}!")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting("Carol");
        assert!(result.contains("Carol"));
    }
}</code></pre>
<p>이 프로그램의 요구사항은 아직 합의되지 않았으며, 인삿말 시작 부분의 <code>Hello</code>라는 텍스트가 바뀔 것이 거의 확실합니다. 우리는 요구사항이 바뀔 때마다 테스트를 업데이트하고 싶지 않으므로, <code>greeting</code> 함수에서 반환된 값과 정확히 일치하는지 확인하는 대신, 출력이 입력 매개변수의 텍스트를 포함하고 있는지만 단언하기로 결정했습니다.</p>
<p>이제 기본 테스트 실패가 어떻게 보이는지 확인하기 위해, <code>greeting</code>에서 <code>name</code>을 제외하도록 코드를 수정하여 버그를 도입해 봅시다:</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    String::from("Hello!")
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greeting_contains_name() {
</span><span class="boring">        let result = greeting("Carol");
</span><span class="boring">        assert!(result.contains("Carol"));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>이 테스트를 실행하면 다음과 같은 결과가 나옵니다:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:
assertion failed: result.contains("Carol")
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>이 결과는 단지 단언이 실패했다는 것과 단언이 몇 번째 줄에 있는지만을 알려줍니다. 더 유용한 실패 메시지는 <code>greeting</code> 함수로부터 얻은 값을 출력하는 것입니다. <code>greeting</code> 함수로부터 실제로 얻은 값을 자리표시자에 채워 넣는 포맷 문자열로 구성된 커스텀 실패 메시지를 추가해 봅시다:</p>
<pre><code class="language-rust ignore"><span class="boring">pub fn greeting(name: &amp;str) -&gt; String {
</span><span class="boring">    String::from("Hello!")
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn greeting_contains_name() {
        let result = greeting("Carol");
        assert!(
            result.contains("Carol"),
            "Greeting did not contain name, value was `{result}`"
        );
    }
<span class="boring">}</span></code></pre>
<p>이제 테스트를 실행하면 더 많은 정보를 담은 에러 메시지를 얻게 됩니다:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.93s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:
Greeting did not contain name, value was `Hello!`
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>테스트 출력에서 실제로 얻은 값을 확인할 수 있으며, 이는 우리가 기대했던 일 대신 어떤 일이 일어났는지 디버깅하는 데 도움이 될 것입니다.</p>
<h3 id="should_panic을-이용한-패닉-확인"><a class="header" href="#should_panic을-이용한-패닉-확인"><code>should_panic</code>을 이용한 패닉 확인</a></h3>
<p>반환 값을 확인하는 것뿐만 아니라, 우리 코드가 예상대로 에러 조건을 처리하는지 확인하는 것도 중요합니다. 예를 들어, 9장의 목록 9-13에서 만들었던 <code>Guess</code> 타입을 생각해 봅시다. <code>Guess</code>를 사용하는 다른 코드들은 <code>Guess</code> 인스턴스가 1에서 100 사이의 값만을 포함한다는 보장에 의존합니다. 우리는 해당 범위를 벗어나는 값으로 <code>Guess</code> 인스턴스를 생성하려 할 때 패닉이 발생하는지 보장하는 테스트를 작성할 수 있습니다.</p>
<p>이는 테스트 함수에 <code>should_panic</code> 속성을 추가함으로써 가능합니다. 이 속성이 추가된 테스트는 함수 내부의 코드가 패닉을 일으키면 통과하고, 패닉을 일으키지 않으면 실패합니다.</p>
<p>목록 11-8은 <code>Guess::new</code>의 에러 조건이 우리가 예상한 대로 발생하는지 확인하는 테스트를 보여줍니다.</p>
<Listing number="11-8" file-name="src/lib.rs" caption="Testing that a condition will cause a `panic!`">
<pre><code class="language-rust noplayground">pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(추측 값은 1에서 100 사이여야 합니다. {value}를 받았습니다.);
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}</code></pre>
</Listing>
<p><code>#[should_panic]</code> 속성은 <code>#[test]</code> 속성 뒤, 그리고 해당 속성이 적용될 테스트 함수 앞에 배치합니다. 이 테스트가 통과했을 때의 결과를 살펴봅시다:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests guessing_game

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>좋군요! 이제 100보다 큰 값일 때 <code>new</code> 함수가 패닉을 일으켜야 한다는 조건을 제거하여 코드에 버그를 도입해 봅시다:</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --생략--
impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(추측 값은 1에서 100 사이여야 합니다. {value}를 받았습니다.);
        }

        Guess { value }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>목록 11-8의 테스트를 실행하면, 다음과 같이 실패할 것입니다:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
note: test did not panic as expected

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>이 경우에는 아주 도움이 되는 메시지를 얻지는 못하지만, 테스트 함수를 살펴보면 <code>#[should_panic]</code>이 달려 있는 것을 볼 수 있습니다. 우리가 받은 실패는 테스트 함수 내의 코드가 패닉을 일으키지 않았음을 의미합니다.</p>
<p><code>should_panic</code>을 사용하는 테스트는 부정확할 수 있습니다. 우리가 예상한 이유와 다른 이유로 패닉이 발생하더라도 <code>should_panic</code> 테스트는 통과될 수 있기 때문입니다. <code>should_panic</code> 테스트를 더 정확하게 만들기 위해 <code>should_panic</code> 속성에 선택적인 <code>expected</code> 매개변수를 추가할 수 있습니다. 테스트 하네스는 실패 메시지가 제공된 텍스트를 포함하는지 확인합니다. 예를 들어, 목록 11-9와 같이 값이 너무 작거나 큰지에 따라 다른 메시지로 패닉을 일으키도록 수정된 <code>Guess</code> 코드를 생각해 봅시다.</p>
<Listing number="11-9" file-name="src/lib.rs" caption="Testing for a `panic!` with a panic message containing a specified substring">
<pre><code class="language-rust noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --생략--

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(
                "Guess value must be greater than or equal to 1, got {value}."
            );
        } else if value &gt; 100 {
            panic!(
                "Guess value must be less than or equal to 100, got {value}."
            );
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = "less than or equal to 100")]
    fn greater_than_100() {
        Guess::new(200);
    }
}</code></pre>
</Listing>
<p>이 테스트는 통과하는데, <code>should_panic</code> 속성의 <code>expected</code> 매개변수에 넣은 값이 <code>Guess::new</code> 함수가 패닉을 일으킬 때의 메시지의 부분 문자열이기 때문입니다. 우리가 기대하는 전체 패닉 메시지를 지정할 수도 있었는데, 이 경우에는 <code>Guess value must be less than or equal to 100, got 200</code>이 될 것입니다. 무엇을 지정할지는 패닉 메시지의 얼마나 많은 부분이 고유하거나 동적인지, 그리고 테스트를 얼마나 정밀하게 만들고 싶은지에 따라 달라집니다. 이번 경우에는 패닉 메시지의 부분 문자열만으로도 테스트 함수의 코드가 <code>else if value &gt; 100</code> 케이스를 실행하는지 보장하기에 충분합니다.</p>
<p><code>expected</code> 메시지가 있는 <code>should_panic</code> 테스트가 실패하면 어떤 일이 일어나는지 확인하기 위해, <code>if value &lt; 1</code> 블록과 <code>else if value &gt; 100</code> 블록의 본문을 서로 바꿔서 코드에 다시 버그를 도입해 봅시다:</p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Guess {
</span><span class="boring">    pub fn new(value: i32) -&gt; Guess {
</span>        if value &lt; 1 {
            panic!(
                "Guess value must be less than or equal to 100, got {value}."
            );
        } else if value &gt; 100 {
            panic!(
                "Guess value must be greater than or equal to 1, got {value}."
            );
        }
<span class="boring">
</span><span class="boring">        Guess { value }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic(expected = "less than or equal to 100")]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>이번에 <code>should_panic</code> 테스트를 실행하면, 다음과 같이 실패할 것입니다:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
thread 'tests::greater_than_100' panicked at src/lib.rs:12:13:
Guess value must be greater than or equal to 1, got 200.
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
note: panic did not contain expected string
      panic message: `"Guess value must be greater than or equal to 1, got 200."`,
 expected substring: `"less than or equal to 100"`

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>실패 메시지는 이 테스트가 우리가 예상한 대로 실제로 패닉을 일으켰음을 나타내지만, 패닉 메시지에 기대했던 문자열인 <code>less than or equal to 100</code>이 포함되지 않았습니다. 이 경우 우리가 실제로 받은 패닉 메시지는 <code>Guess value must be greater than or equal to 1, got 200.</code>이었습니다. 이제 우리 버그가 어디에 있는지 파악하기 시작할 수 있습니다!</p>
<h3 id="테스트에서-resultt-e-사용하기"><a class="header" href="#테스트에서-resultt-e-사용하기">테스트에서 <code>Result&lt;T, E&gt;</code> 사용하기</a></h3>
<p>지금까지의 테스트들은 실패할 때 모두 패닉을 일으켰습니다. <code>Result&lt;T, E&gt;</code>를 사용하는 테스트를 작성할 수도 있습니다! 목록 11-1의 테스트를 패닉 대신 <code>Result&lt;T, E&gt;</code>를 사용하고 <code>Err</code>을 반환하도록 다시 작성하면 다음과 같습니다:</p>
<pre><code class="language-rust noplayground"><span class="boring">pub fn add(left: u64, right: u64) -&gt; u64 {
</span><span class="boring">    left + right
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn it_works() -&gt; Result&lt;(), String&gt; {
        let result = add(2, 2);

        if result == 4 {
            Ok(())
        } else {
            Err(String::from("two plus two does not equal four"))
        }
    }
<span class="boring">}</span></code></pre>
<p>이제 <code>it_works</code> 함수는 <code>Result&lt;(), String&gt;</code> 반환 타입을 가집니다. 함수 본문에서 <code>assert_eq!</code> 매크로를 호출하는 대신, 테스트가 통과하면 <code>Ok(())</code>를 반환하고 테스트가 실패하면 <code>String</code>을 담은 <code>Err</code>을 반환합니다.</p>
<p>테스트가 <code>Result&lt;T, E&gt;</code>를 반환하도록 작성하면 테스트 본문에서 물음표 연산자를 사용할 수 있습니다. 이는 내부의 어떤 연산이라도 <code>Err</code> 변형을 반환할 경우 실패해야 하는 테스트를 작성하는 편리한 방법이 될 수 있습니다.</p>
<p><code>Result&lt;T, E&gt;</code>를 사용하는 테스트에는 <code>#[should_panic]</code> 어노테이션을 사용할 수 없습니다. 어떤 연산이 <code>Err</code> 변형을 반환함을 단언하려면, <code>Result&lt;T, E&gt;</code> 값에 물음표 연산자를 사용하지 <em>마세요</em>. 대신 <code>assert!(value.is_err())</code>를 사용하세요.</p>
<p>이제 테스트를 작성하는 여러 가지 방법을 알게 되었으니, 테스트를 실행할 때 어떤 일이 일어나는지 살펴보고 <code>cargo test</code>와 함께 사용할 수 있는 다양한 옵션들을 탐구해 봅시다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch11-00-testing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch11-02-running-tests.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch11-00-testing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch11-02-running-tests.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
