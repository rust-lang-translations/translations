<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>테스트 작성 방법 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch11-01-writing-tests.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch11-01-writing-tests.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="테스트-작성-방법"><a class="header" href="#테스트-작성-방법">테스트 작성 방법</a></h2>
<p>테스트는 비테스트 코드가 예상대로 작동하는지 확인하는 러스트 함수입니다. 테스트 함수의 본문은 일반적으로 다음 세 가지 작업을 수행합니다:</p>
<ul>
<li>필요한 데이터 또는 상태를 설정합니다.</li>
<li>테스트하려는 코드를 실행합니다.</li>
<li>결과가 예상한 것과 일치하는지 단언합니다.</li>
</ul>
<p>러스트가 이러한 작업을 수행하는 테스트 작성을 위해 특별히 제공하는 기능을 살펴보겠습니다. 여기에는 <code>test</code> 속성, 몇 가지 매크로, 그리고 <code>should_panic</code> 속성이 포함됩니다.</p>
<h3 id="테스트-함수의-구조"><a class="header" href="#테스트-함수의-구조">테스트 함수의 구조</a></h3>
<p>가장 간단하게, 러스트의 테스트는 <code>test</code> 속성으로 주석이 달린 함수입니다. 속성은 러스트 코드 조각에 대한 메타데이터입니다. 한 가지 예는 5장에서 구조체와 함께 사용했던 <code>derive</code> 속성입니다. 함수를 테스트 함수로 변경하려면 <code>fn</code> 앞에 <code>#[test]</code>를 추가합니다. <code>cargo test</code> 명령으로 테스트를 실행하면, 러스트는 주석이 달린 함수를 실행하고 각 테스트 함수가 통과했는지 실패했는지 보고하는 테스트 러너 바이너리를 빌드합니다.</p>
<p>Cargo로 새 라이브러리 프로젝트를 만들 때마다 테스트 함수가 포함된 테스트 모듈이 자동으로 생성됩니다. 이 모듈은 테스트 작성을 위한 템플릿을 제공하므로 새 프로젝트를 시작할 때마다 정확한 구조와 구문을 찾아볼 필요가 없습니다. 원하는 만큼 추가 테스트 함수와 테스트 모듈을 추가할 수 있습니다!</p>
<p>실제로 코드를 테스트하기 전에 템플릿 테스트를 실험하여 테스트가 어떻게 작동하는지 몇 가지 측면을 탐구할 것입니다. 그런 다음 우리가 작성한 코드를 호출하고 그 동작이 올바른지 단언하는 실제 테스트를 작성할 것입니다.</p>
<p>Let’s create a new library project called <code>adder</code> that will add two numbers:</p>
<pre><code class="language-console">$ cargo new adder --lib
     Created library `adder` project
$ cd adder
</code></pre>
<p>여러분의 <code>adder</code> 라이브러리의 <em>src/lib.rs</em> 파일 내용은 목록 11-1과 같아야 합니다.</p>
<Listing number="11-1" file-name="src/lib.rs" caption="The code generated automatically by `cargo new`">
<!-- manual-regeneration
cd listings/ch11-writing-automated-tests
rm -rf listing-11-01
cargo new listing-11-01 --lib --name adder
cd listing-11-01
echo "$ cargo test" > output.txt
RUSTFLAGS="-A unused_variables -A dead_code" RUST_TEST_THREADS=1 cargo test >> output.txt 2>&1
git diff output.txt # commit any relevant changes; discard irrelevant ones
cd ../../..
-->
<pre><code class="language-rust noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
</Listing>
<p>파일은 예제 <code>add</code> 함수로 시작하므로, 테스트할 무언가가 있습니다.</p>
<p>지금은 <code>it_works</code> 함수에만 집중해 봅시다. <code>#[test]</code> 어노테이션에 주목하세요. 이 속성은 이것이 테스트 함수임을 나타내므로, 테스트 러너는 이 함수를 테스트로 처리해야 한다는 것을 압니다. <code>tests</code> 모듈에는 공통 시나리오를 설정하거나 공통 작업을 수행하는 데 도움이 되는 비테스트 함수도 있을 수 있으므로, 어떤 함수가 테스트인지 항상 표시해야 합니다.</p>
<p>예제 함수 본문은 <code>assert_eq!</code> 매크로를 사용하여 2와 2를 더한 <code>add</code> 호출의 결과인 <code>result</code>가 4와 같음을 단언합니다. 이 단언은 일반적인 테스트 형식의 예시 역할을 합니다. 이 테스트가 통과하는지 확인하기 위해 실행해 봅시다.</p>
<p>The <code>cargo test</code> command runs all tests in our project, as shown in Listing 11-2.</p>
<Listing number="11-2" caption="The output from running the automatically generated test">
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.57s
     Running unittests src/lib.rs (file:///projects/adder/target/debug/deps/adder-7acb243c25ffd9dc)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
</Listing>
<p>Cargo가 테스트를 컴파일하고 실행했습니다. <code>running 1 test</code> 줄이 보입니다. 다음 줄은 생성된 테스트 함수 <code>tests::it_works</code>의 이름과 해당 테스트 실행 결과가 <code>ok</code>임을 보여줍니다. 전체 요약 <code>test result: ok.</code>는 모든 테스트가 통과했음을 의미하며, <code>1 passed; 0 failed</code> 부분은 통과하거나 실패한 테스트의 총 개수를 나타냅니다.</p>
<p>특정 인스턴스에서 실행되지 않도록 테스트를 무시로 표시할 수 있습니다. 이에 대해서는 이 장의 뒷부분에 있는 <a href="ch11-02-running-tests.html#ignoring-some-tests-unless-specifically-requested">“특별히 요청하지 않는 한 일부 테스트 무시하기”</a><!-- ignore --> 섹션에서 다룰 것입니다. 여기서는 그렇게 하지 않았으므로 요약에는 <code>0 ignored</code>가 표시됩니다. <code>cargo test</code> 명령에 문자열과 이름이 일치하는 테스트만 실행하도록 인수를 전달할 수도 있습니다. 이를 _필터링_이라고 하며, <a href="ch11-02-running-tests.html#running-a-subset-of-tests-by-name">“이름으로 테스트 하위 집합 실행하기”</a><!-- ignore --> 섹션에서 다룰 것입니다. 여기서는 실행되는 테스트를 필터링하지 않았으므로 요약 끝에는 <code>0 filtered out</code>이 표시됩니다.</p>
<p><code>0 measured</code> 통계는 성능을 측정하는 벤치마크 테스트를 위한 것입니다. 벤치마크 테스트는 이 글을 쓰는 시점에는 nightly Rust에서만 사용할 수 있습니다. 자세한 내용은 <a href="../unstable-book/library-features/test.html">벤치마크 테스트에 대한 문서</a>를 참조하세요.</p>
<p><code>Doc-tests adder</code>에서 시작하는 테스트 출력의 다음 부분은 모든 문서 테스트 결과에 대한 것입니다. 아직 문서 테스트는 없지만, 러스트는 API 문서에 나타나는 모든 코드 예제를 컴파일할 수 있습니다. 이 기능은 문서와 코드를 동기화하는 데 도움이 됩니다! 14장의 <a href="ch14-02-publishing-to-crates-io.html#documentation-comments-as-tests">“테스트로서의 문서 주석”</a><!-- ignore --> 섹션에서 문서 테스트를 작성하는 방법을 논의할 것입니다. 지금은 <code>Doc-tests</code> 출력을 무시하겠습니다.</p>
<p>이제 테스트를 우리의 필요에 맞게 사용자 정의해 봅시다. 먼저 <code>it_works</code> 함수의 이름을 <code>exploration</code>과 같은 다른 이름으로 변경합니다. 다음과 같이 말이죠:</p>
<p><span class="filename">파일명: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn exploration() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<p>그런 다음 <code>cargo test</code>를 다시 실행합니다. 이제 출력은 <code>it_works</code> 대신 <code>exploration</code>을 보여줍니다:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.59s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>이제 또 다른 테스트를 추가할 것입니다. 하지만 이번에는 실패하는 테스트를 만들 것입니다! 테스트 함수 내에서 무언가가 패닉을 일으키면 테스트는 실패합니다. 각 테스트는 새 스레드에서 실행되며, 메인 스레드가 테스트 스레드가 종료된 것을 확인하면 테스트는 실패로 표시됩니다. 9장에서 가장 간단한 패닉 방법은 <code>panic!</code> 매크로를 호출하는 것이라고 이야기했습니다. 새 테스트를 <code>another</code>라는 함수로 입력하면 <em>src/lib.rs</em> 파일은 목록 11-3과 같아집니다.</p>
<Listing number="11-3" file-name="src/lib.rs" caption="Adding a second test that will fail because we call the `panic!` macro">
<pre><code class="language-rust panics noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn exploration() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }

    #[test]
    fn another() {
        panic!("이 테스트를 실패하게 만드세요");
    }
}</code></pre>
</Listing>
<p><code>cargo test</code>를 사용하여 테스트를 다시 실행합니다. 출력은 목록 11-4와 같아야 하며, <code>exploration</code> 테스트는 통과하고 <code>another</code> 테스트는 실패했음을 보여줍니다.</p>
<Listing number="11-4" caption="Test results when one test passes and one test fails">
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.72s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::another ... FAILED
test tests::exploration ... ok

failures:

---- tests::another stdout ----
thread 'tests::another' panicked at src/lib.rs:17:9:
Make this test fail
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
</Listing>
<!-- manual-regeneration
rg panicked listings/ch11-writing-automated-tests/listing-11-03/output.txt
check the line number of the panic matches the line number in the following paragraph
 -->
<p><code>ok</code> 대신 <code>test tests::another</code> 줄은 <code>FAILED</code>를 보여줍니다. 개별 결과와 요약 사이에 두 개의 새로운 섹션이 나타납니다. 첫 번째 섹션은 각 테스트 실패에 대한 자세한 이유를 표시합니다. 이 경우 <code>another</code>가 <em>src/lib.rs</em> 파일의 17번째 줄에서 <code>panicked at 'Make this test fail'</code>로 인해 실패했다는 세부 정보를 얻습니다. 다음 섹션은 실패한 모든 테스트의 이름만 나열하며, 이는 많은 테스트와 많은 자세한 실패 테스트 출력이 있을 때 유용합니다. 실패한 테스트의 이름을 사용하여 해당 테스트만 실행하여 더 쉽게 디버깅할 수 있습니다. <a href="ch11-02-running-tests.html#controlling-how-tests-are-run">“테스트 실행 방법 제어하기”</a><!-- ignore --> 섹션에서 테스트 실행 방법에 대해 더 자세히 이야기할 것입니다.</p>
<p>요약 줄은 마지막에 표시됩니다. 전체적으로 테스트 결과는 <code>FAILED</code>입니다. 하나의 테스트가 통과했고 하나의 테스트가 실패했습니다.</p>
<p>이제 다양한 시나리오에서 테스트 결과가 어떻게 보이는지 확인했으니, 테스트에 유용한 <code>panic!</code> 외의 다른 매크로들을 살펴보겠습니다.</p>
<h3 id="assert-매크로로-결과-확인하기"><a class="header" href="#assert-매크로로-결과-확인하기"><code>assert!</code> 매크로로 결과 확인하기</a></h3>
<p>The <code>assert!</code> macro, provided by the standard library, is useful when you want to ensure that some condition in a test evaluates to <code>true</code>. We give the <code>assert!</code> macro an argument that evaluates to a Boolean. If the value is <code>true</code>, nothing happens and the test passes. If the value is <code>false</code>, the <code>assert!</code> macro calls <code>panic!</code> to cause the test to fail. Using the <code>assert!</code> macro helps us check that our code is functioning in the way we intend.</p>
<p>5장 목록 5-15에서 <code>Rectangle</code> 구조체와 <code>can_hold</code> 메서드를 사용했는데, 이는 목록 11-5에 다시 반복됩니다. 이 코드를 <em>src/lib.rs</em> 파일에 넣고, <code>assert!</code> 매크로를 사용하여 몇 가지 테스트를 작성해 봅시다.</p>
<Listing number="11-5" file-name="src/lib.rs" caption="The `Rectangle` struct and its `can_hold` method from Chapter 5">
<pre><code class="language-rust noplayground">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}</code></pre>
</Listing>
<p><code>can_hold</code> 메서드는 불리언을 반환하므로, <code>assert!</code> 매크로에 완벽한 사용 사례입니다. 목록 11-6에서는 너비 8, 높이 7인 <code>Rectangle</code> 인스턴스를 생성하고, 너비 5, 높이 1인 다른 <code>Rectangle</code> 인스턴스를 담을 수 있음을 단언하여 <code>can_hold</code> 메서드를 테스트하는 코드를 작성합니다.</p>
<Listing number="11-6" file-name="src/lib.rs" caption="A test for `can_hold` that checks whether a larger rectangle can indeed hold a smaller rectangle">
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(larger.can_hold(&amp;smaller));
    }
}</code></pre>
</Listing>
<p>Note the <code>use super::*;</code> line inside the <code>tests</code> module. The <code>tests</code> module is a regular module that follows the usual visibility rules we covered in Chapter 7 in the <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“Paths for Referring to an Item in the Module Tree”</a><!-- ignore --> section. Because the <code>tests</code> module is an inner module, we need to bring the code under test in the outer module into the scope of the inner module. We use a glob here, so anything we define in the outer module is available to this <code>tests</code> module.</p>
<p>우리는 테스트 이름을 <code>larger_can_hold_smaller</code>로 지정했고, 필요한 두 <code>Rectangle</code> 인스턴스를 생성했습니다. 그런 다음 <code>assert!</code> 매크로를 호출하고 <code>larger.can_hold(&amp;smaller)</code> 호출 결과를 전달했습니다. 이 표현식은 <code>true</code>를 반환해야 하므로 테스트는 통과해야 합니다. 확인해 봅시다!</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>통과했습니다! 이제 다른 테스트를 추가해 봅시다. 이번에는 더 작은 사각형이 더 큰 사각형을 담을 수 없음을 단언하는 테스트입니다:</p>
<p><span class="filename">파일명: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        // --생략--
<span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span>    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(!smaller.can_hold(&amp;larger));
    }
}</code></pre>
<p>이 경우 <code>can_hold</code> 함수의 올바른 결과는 <code>false</code>이므로, <code>assert!</code> 매크로에 전달하기 전에 그 결과를 부정해야 합니다. 결과적으로 <code>can_hold</code>가 <code>false</code>를 반환하면 테스트는 통과할 것입니다:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... ok
test tests::smaller_cannot_hold_larger ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>두 개의 테스트가 통과했습니다! 이제 코드에 버그를 도입했을 때 테스트 결과가 어떻게 되는지 살펴봅시다. 너비를 비교할 때 <code>can_hold</code> 메서드의 구현에서 크다 기호를 작다 기호로 변경할 것입니다:</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>// --생략--
impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &lt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn larger_can_hold_smaller() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn smaller_cannot_hold_larger() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(!smaller.can_hold(&amp;larger));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>이제 테스트를 실행하면 다음과 같은 결과가 나옵니다:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... FAILED
test tests::smaller_cannot_hold_larger ... ok

failures:

---- tests::larger_can_hold_smaller stdout ----
thread 'tests::larger_can_hold_smaller' panicked at src/lib.rs:28:9:
assertion failed: larger.can_hold(&amp;smaller)
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Our tests caught the bug! Because <code>larger.width</code> is <code>8</code> and <code>smaller.width</code> is <code>5</code>, the comparison of the widths in <code>can_hold</code> now returns <code>false</code>: 8 is not less than 5.</p>
<h3 id="testing-equality-with-the-assert_eq-and-assert_ne-macros"><a class="header" href="#testing-equality-with-the-assert_eq-and-assert_ne-macros">Testing Equality with the <code>assert_eq!</code> and <code>assert_ne!</code> Macros</a></h3>
<p>A common way to verify functionality is to test for equality between the result of the code under test and the value you expect the code to return. You could do this by using the <code>assert!</code> macro and passing it an expression using the <code>==</code> operator. However, this is such a common test that the standard library provides a pair of macros—<code>assert_eq!</code> and <code>assert_ne!</code>—to perform this test more conveniently. These macros compare two arguments for equality or inequality, respectively. They’ll also print the two values if the assertion fails, which makes it easier to see <em>why</em> the test failed; conversely, the <code>assert!</code> macro only indicates that it got a <code>false</code> value for the <code>==</code> expression, without printing the values that led to the <code>false</code> value.</p>
<p>In Listing 11-7, we write a function named <code>add_two</code> that adds <code>2</code> to its parameter, then we test this function using the <code>assert_eq!</code> macro.</p>
<Listing number="11-7" file-name="src/lib.rs" caption="Testing the function `add_two` using the `assert_eq!` macro">
<pre><code class="language-rust noplayground">pub fn add_two(a: usize) -&gt; usize {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        let result = add_two(2);
        assert_eq!(result, 4);
    }
}</code></pre>
</Listing>
<p>Let’s check that it passes!</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>We create a variable named <code>result</code> that holds the result of calling <code>add_two(2)</code>. Then we pass <code>result</code> and <code>4</code> as the arguments to <code>assert_eq!</code>. The output line for this test is <code>test tests::it_adds_two ... ok</code>, and the <code>ok</code> text indicates that our test passed!</p>
<p>Let’s introduce a bug into our code to see what <code>assert_eq!</code> looks like when it fails. Change the implementation of the <code>add_two</code> function to instead add <code>3</code>:</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn add_two(a: usize) -&gt; usize {
    a + 3
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_adds_two() {
</span><span class="boring">        let result = add_two(2);
</span><span class="boring">        assert_eq!(result, 4);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Run the tests again:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----
thread 'tests::it_adds_two' panicked at src/lib.rs:12:9:
assertion `left == right` failed
  left: 5
 right: 4
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>Our test caught the bug! The <code>it_adds_two</code> test failed, and the message tells us that the assertion that failed was <code>assertion `left == right` failed</code> and what the <code>left</code> and <code>right</code> values are. This message helps us start debugging: the <code>left</code> argument, where we had the result of calling <code>add_two(2)</code>, was <code>5</code> but the <code>right</code> argument was <code>4</code>. You can imagine that this would be especially helpful when we have a lot of tests going on.</p>
<p>Note that in some languages and test frameworks, the parameters to equality assertion functions are called <code>expected</code> and <code>actual</code>, and the order in which we specify the arguments matters. However, in Rust, they’re called <code>left</code> and <code>right</code>, and the order in which we specify the value we expect and the value the code produces doesn’t matter. We could write the assertion in this test as <code>assert_eq!(4, result)</code>, which would result in the same failure message that that displays <code>assertion failed: `(left == right)`</code>.</p>
<p>The <code>assert_ne!</code> macro will pass if the two values we give it are not equal and fail if they’re equal. This macro is most useful for cases when we’re not sure what a value <em>will</em> be, but we know what the value definitely <em>shouldn’t</em> be. For example, if we’re testing a function that is guaranteed to change its input in some way, but the way in which the input is changed depends on the day of the week that we run our tests, the best thing to assert might be that the output of the function is not equal to the input.</p>
<p>Under the surface, the <code>assert_eq!</code> and <code>assert_ne!</code> macros use the operators <code>==</code> and <code>!=</code>, respectively. When the assertions fail, these macros print their arguments using debug formatting, which means the values being compared must implement the <code>PartialEq</code> and <code>Debug</code> traits. All primitive types and most of the standard library types implement these traits. For structs and enums that you define yourself, you’ll need to implement <code>PartialEq</code> to assert equality of those types. You’ll also need to implement <code>Debug</code> to print the values when the assertion fails. Because both traits are derivable traits, as mentioned in Listing 5-12 in Chapter 5, this is usually as straightforward as adding the <code>#[derive(PartialEq, Debug)]</code> annotation to your struct or enum definition. See Appendix C, <a href="appendix-03-derivable-traits.html">“Derivable Traits,”</a><!-- ignore --> for more details about these and other derivable traits.</p>
<h3 id="adding-custom-failure-messages"><a class="header" href="#adding-custom-failure-messages">Adding Custom Failure Messages</a></h3>
<p>You can also add a custom message to be printed with the failure message as optional arguments to the <code>assert!</code>, <code>assert_eq!</code>, and <code>assert_ne!</code> macros. Any arguments specified after the required arguments are passed along to the <code>format!</code> macro (discussed in <a href="ch08-02-strings.html#concatenation-with-the--operator-or-the-format-macro">“Concatenation with the <code>+</code> Operator or the <code>format!</code> Macro”</a><!--
ignore --> in Chapter 8), so you can pass a format string that contains <code>{}</code> placeholders and values to go in those placeholders. Custom messages are useful for documenting what an assertion means; when a test fails, you’ll have a better idea of what the problem is with the code.</p>
<p>For example, let’s say we have a function that greets people by name and we want to test that the name we pass into the function appears in the output:</p>
<p><span class="filename">파일명: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    format!("Hello {name}!")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting("Carol");
        assert!(result.contains("Carol"));
    }
}</code></pre>
<p>The requirements for this program haven’t been agreed upon yet, and we’re pretty sure the <code>Hello</code> text at the beginning of the greeting will change. We decided we don’t want to have to update the test when the requirements change, so instead of checking for exact equality to the value returned from the <code>greeting</code> function, we’ll just assert that the output contains the text of the input parameter.</p>
<p>Now let’s introduce a bug into this code by changing <code>greeting</code> to exclude <code>name</code> to see what the default test failure looks like:</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    String::from("Hello!")
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greeting_contains_name() {
</span><span class="boring">        let result = greeting("Carol");
</span><span class="boring">        assert!(result.contains("Carol"));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Running this test produces the following:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:
assertion failed: result.contains("Carol")
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>This result just indicates that the assertion failed and which line the assertion is on. A more useful failure message would print the value from the <code>greeting</code> function. Let’s add a custom failure message composed of a format string with a placeholder filled in with the actual value we got from the <code>greeting</code> function:</p>
<pre><code class="language-rust ignore"><span class="boring">pub fn greeting(name: &amp;str) -&gt; String {
</span><span class="boring">    String::from("Hello!")
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn greeting_contains_name() {
        let result = greeting("Carol");
        assert!(
            result.contains("Carol"),
            "Greeting did not contain name, value was `{result}`"
        );
    }
<span class="boring">}</span></code></pre>
<p>Now when we run the test, we’ll get a more informative error message:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.93s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'tests::greeting_contains_name' panicked at src/lib.rs:12:9:
Greeting did not contain name, value was `Hello!`
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>We can see the value we actually got in the test output, which would help us debug what happened instead of what we were expecting to happen.</p>
<h3 id="checking-for-panics-with-should_panic"><a class="header" href="#checking-for-panics-with-should_panic">Checking for Panics with <code>should_panic</code></a></h3>
<p>In addition to checking return values, it’s important to check that our code handles error conditions as we expect. For example, consider the <code>Guess</code> type that we created in Chapter 9, Listing 9-13. Other code that uses <code>Guess</code> depends on the guarantee that <code>Guess</code> instances will contain only values between 1 and 100. We can write a test that ensures that attempting to create a <code>Guess</code> instance with a value outside that range panics.</p>
<p>We do this by adding the attribute <code>should_panic</code> to our test function. The test passes if the code inside the function panics; the test fails if the code inside the function doesn’t panic.</p>
<p>Listing 11-8 shows a test that checks that the error conditions of <code>Guess::new</code> happen when we expect them to.</p>
<Listing number="11-8" file-name="src/lib.rs" caption="Testing that a condition will cause a `panic!`">
<pre><code class="language-rust noplayground">pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(추측 값은 1에서 100 사이여야 합니다. {value}를 받았습니다.);
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}</code></pre>
</Listing>
<p>We place the <code>#[should_panic]</code> attribute after the <code>#[test]</code> attribute and before the test function it applies to. Let’s look at the result when this test passes:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests guessing_game

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Looks good! Now let’s introduce a bug in our code by removing the condition that the <code>new</code> function will panic if the value is greater than 100:</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --생략--
impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(추측 값은 1에서 100 사이여야 합니다. {value}를 받았습니다.);
        }

        Guess { value }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>When we run the test in Listing 11-8, it will fail:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
note: test did not panic as expected

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>We don’t get a very helpful message in this case, but when we look at the test function, we see that it’s annotated with <code>#[should_panic]</code>. The failure we got means that the code in the test function did not cause a panic.</p>
<p>Tests that use <code>should_panic</code> can be imprecise. A <code>should_panic</code> test would pass even if the test panics for a different reason from the one we were expecting. To make <code>should_panic</code> tests more precise, we can add an optional <code>expected</code> parameter to the <code>should_panic</code> attribute. The test harness will make sure that the failure message contains the provided text. For example, consider the modified code for <code>Guess</code> in Listing 11-9 where the <code>new</code> function panics with different messages depending on whether the value is too small or too large.</p>
<Listing number="11-9" file-name="src/lib.rs" caption="Testing for a `panic!` with a panic message containing a specified substring">
<pre><code class="language-rust noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --생략--

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(
                "Guess value must be greater than or equal to 1, got {value}."
            );
        } else if value &gt; 100 {
            panic!(
                "Guess value must be less than or equal to 100, got {value}."
            );
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = "less than or equal to 100")]
    fn greater_than_100() {
        Guess::new(200);
    }
}</code></pre>
</Listing>
<p>This test will pass because the value we put in the <code>should_panic</code> attribute’s <code>expected</code> parameter is a substring of the message that the <code>Guess::new</code> function panics with. We could have specified the entire panic message that we expect, which in this case would be <code>Guess value must be less than or equal to 100, got 200</code>. What you choose to specify depends on how much of the panic message is unique or dynamic and how precise you want your test to be. In this case, a substring of the panic message is enough to ensure that the code in the test function executes the <code>else if value &gt; 100</code> case.</p>
<p>To see what happens when a <code>should_panic</code> test with an <code>expected</code> message fails, let’s again introduce a bug into our code by swapping the bodies of the <code>if value &lt; 1</code> and the <code>else if value &gt; 100</code> blocks:</p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Guess {
</span><span class="boring">    pub fn new(value: i32) -&gt; Guess {
</span>        if value &lt; 1 {
            panic!(
                "Guess value must be less than or equal to 100, got {value}."
            );
        } else if value &gt; 100 {
            panic!(
                "Guess value must be greater than or equal to 1, got {value}."
            );
        }
<span class="boring">
</span><span class="boring">        Guess { value }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic(expected = "less than or equal to 100")]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>This time when we run the <code>should_panic</code> test, it will fail:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
thread 'tests::greater_than_100' panicked at src/lib.rs:12:13:
Guess value must be greater than or equal to 1, got 200.
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
note: panic did not contain expected string
      panic message: `"Guess value must be greater than or equal to 1, got 200."`,
 expected substring: `"less than or equal to 100"`

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>The failure message indicates that this test did indeed panic as we expected, but the panic message did not include the expected string <code>less than or equal to 100</code>. The panic message that we did get in this case was <code>Guess value must be greater than or equal to 1, got 200.</code> Now we can start figuring out where our bug is!</p>
<h3 id="using-resultt-e-in-tests"><a class="header" href="#using-resultt-e-in-tests">Using <code>Result&lt;T, E&gt;</code> in Tests</a></h3>
<p>Our tests so far all panic when they fail. We can also write tests that use <code>Result&lt;T, E&gt;</code>! Here’s the test from Listing 11-1, rewritten to use <code>Result&lt;T, E&gt;</code> and return an <code>Err</code> instead of panicking:</p>
<pre><code class="language-rust noplayground"><span class="boring">pub fn add(left: u64, right: u64) -&gt; u64 {
</span><span class="boring">    left + right
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn it_works() -&gt; Result&lt;(), String&gt; {
        let result = add(2, 2);

        if result == 4 {
            Ok(())
        } else {
            Err(String::from("two plus two does not equal four"))
        }
    }
<span class="boring">}</span></code></pre>
<p>The <code>it_works</code> function now has the <code>Result&lt;(), String&gt;</code> return type. In the body of the function, rather than calling the <code>assert_eq!</code> macro, we return <code>Ok(())</code> when the test passes and an <code>Err</code> with a <code>String</code> inside when the test fails.</p>
<p>Writing tests so they return a <code>Result&lt;T, E&gt;</code> enables you to use the question mark operator in the body of tests, which can be a convenient way to write tests that should fail if any operation within them returns an <code>Err</code> variant.</p>
<p>You can’t use the <code>#[should_panic]</code> annotation on tests that use <code>Result&lt;T, E&gt;</code>. To assert that an operation returns an <code>Err</code> variant, <em>don’t</em> use the question mark operator on the <code>Result&lt;T, E&gt;</code> value. Instead, use <code>assert!(value.is_err())</code>.</p>
<p>Now that you know several ways to write tests, let’s look at what is happening when we run our tests and explore the different options we can use with <code>cargo test</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch11-00-testing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch11-02-running-tests.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch11-00-testing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch11-02-running-tests.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
