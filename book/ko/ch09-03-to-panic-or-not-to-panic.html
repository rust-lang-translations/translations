<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>panic!을 사용할지 말지 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch09-03-to-panic-or-not-to-panic.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch09-03-to-panic-or-not-to-panic.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="panic을-사용할지-말지"><a class="header" href="#panic을-사용할지-말지"><code>panic!</code>을 사용할지 말지</a></h2>
<p>그렇다면 언제 <code>panic!</code>을 호출하고 언제 <code>Result</code>를 반환해야 할지 어떻게 결정할까요? 코드가 패닉을 일으키면 복구할 방법이 없습니다. 복구할 방법이 있든 없든 모든 에러 상황에 대해 <code>panic!</code>을 호출할 수 있지만, 그렇게 하면 호출하는 코드를 대신하여 상황이 복구 불가능하다고 결정하는 것입니다. <code>Result</code> 값을 반환하기로 선택하면 호출하는 코드에 선택권을 줍니다. 호출하는 코드는 상황에 맞는 방식으로 복구를 시도할 수도 있고, 이 경우의 <code>Err</code> 값이 복구 불가능하다고 판단하여 <code>panic!</code>을 호출하고 복구 가능한 에러를 복구 불가능한 에러로 바꿀 수도 있습니다. 따라서 실패할 수 있는 함수를 정의할 때는 <code>Result</code>를 반환하는 것이 좋은 기본 선택입니다.</p>
<p>예제, 프로토타입 코드, 테스트와 같은 상황에서는 <code>Result</code>를 반환하는 대신 패닉을 일으키는 코드를 작성하는 것이 더 적절합니다. 그 이유를 알아보고, 컴파일러는 실패가 불가능하다는 것을 알 수 없지만 사람은 알 수 있는 상황에 대해 논의해 보겠습니다. 이 장은 라이브러리 코드에서 패닉을 일으킬지 여부를 결정하는 방법에 대한 몇 가지 일반적인 지침으로 마무리할 것입니다.</p>
<h3 id="예제-프로토타입-코드-그리고-테스트"><a class="header" href="#예제-프로토타입-코드-그리고-테스트">예제, 프로토타입 코드, 그리고 테스트</a></h3>
<p>어떤 개념을 설명하기 위해 예제를 작성할 때, 견고한 에러 처리 코드까지 포함하면 예제가 덜 명확해질 수 있습니다. 예제에서 패닉을 일으킬 수 있는 <code>unwrap</code> 같은 메서드를 호출하는 것은 여러분이 애플리케이션에서 에러를 처리하고자 하는 방식에 대한 자리 표시자로 이해되며, 이는 나머지 코드가 수행하는 작업에 따라 달라질 수 있습니다.</p>
<p>마찬가지로, <code>unwrap</code>과 <code>expect</code> 메서드는 에러 처리 방법을 결정하기 전인 프로토타이핑 단계에서 매우 편리합니다. 이것들은 나중에 프로그램을 더 견고하게 만들 준비가 되었을 때를 위해 코드에 명확한 표시를 남깁니다.</p>
<p>테스트에서 메서드 호출이 실패하면, 해당 메서드가 테스트 대상 기능이 아니더라도 전체 테스트가 실패하기를 원할 것입니다. <code>panic!</code>은 테스트가 실패로 표시되는 방식이므로, <code>unwrap</code>이나 <code>expect</code>를 호출하는 것이 정확히 일어나야 할 일입니다.</p>
<h3 id="컴파일러보다-여러분이-더-많은-정보를-가지고-있는-경우"><a class="header" href="#컴파일러보다-여러분이-더-많은-정보를-가지고-있는-경우">컴파일러보다 여러분이 더 많은 정보를 가지고 있는 경우</a></h3>
<p><code>Result</code>가 <code>Ok</code> 값을 가질 것임을 보장하는 다른 로직이 있지만, 컴파일러가 그 로직을 이해하지 못할 때 <code>unwrap</code>이나 <code>expect</code>를 호출하는 것도 적절할 것입니다. 여러분은 여전히 처리해야 할 <code>Result</code> 값을 가지고 있습니다: 여러분이 호출하는 작업은 여러분의 특정 상황에서는 논리적으로 불가능하더라도 일반적으로는 여전히 실패할 가능성이 있습니다. 코드를 직접 검사하여 <code>Err</code> 변형이 절대 발생하지 않을 것임을 확신할 수 있다면 <code>unwrap</code>을 호출하는 것은 전적으로 허용되며, <code>expect</code> 텍스트에 <code>Err</code> 변형이 절대 발생하지 않을 것이라고 생각하는 이유를 문서화하는 것이 더 좋습니다. 여기 예제가 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    use std::net::IpAddr;

    let home: IpAddr = "127.0.0.1"
        .parse()
        .expect("하드코딩된 IP 주소는 유효해야 합니다");
<span class="boring">}</span></code></pre></pre>
<p>우리는 하드코딩된 문자열을 파싱하여 <code>IpAddr</code> 인스턴스를 생성하고 있습니다. <code>127.0.0.1</code>이 유효한 IP 주소라는 것을 알 수 있으므로, 여기서 <code>expect</code>를 사용하는 것은 허용됩니다. 하지만 하드코딩된 유효한 문자열이 있다고 해서 <code>parse</code> 메서드의 반환 타입이 바뀌지는 않습니다: 우리는 여전히 <code>Result</code> 값을 얻고, 컴파일러는 이 문자열이 항상 유효한 IP 주소라는 것을 알 만큼 똑똑하지 않기 때문에 여전히 <code>Err</code> 변형이 가능한 것처럼 <code>Result</code>를 처리하게 할 것입니다. 만약 IP 주소 문자열이 프로그램에 하드코딩된 것이 아니라 사용자로부터 입력받은 것이어서 실패할 가능성이 <em>있다면</em>, 우리는 분명히 <code>Result</code>를 더 견고한 방식으로 처리하고 싶을 것입니다. 이 IP 주소가 하드코딩되었다는 가정을 언급하면, 나중에 다른 소스에서 IP 주소를 가져와야 할 경우 <code>expect</code>를 더 나은 에러 처리 코드로 변경하도록 유도할 것입니다.</p>
<h3 id="에러-처리-가이드라인"><a class="header" href="#에러-처리-가이드라인">에러 처리 가이드라인</a></h3>
<p>코드가 나쁜 상태에 빠질 수 있을 때 코드가 패닉을 일으키도록 하는 것이 좋습니다. 이 문맥에서 _나쁜 상태_란 유효하지 않은 값, 모순되는 값, 또는 누락된 값이 코드에 전달되는 것과 같이 일부 가정, 보장, 계약 또는 불변성이 깨진 경우를 말하며, 여기에 더해 다음 중 하나 이상에 해당할 때입니다:</p>
<ul>
<li>나쁜 상태는 사용자가 잘못된 형식의 데이터를 입력하는 것처럼 가끔 일어날 가능성이 있는 것이 아니라 예상치 못한 것입니다.</li>
<li>이 시점 이후의 코드는 매 단계마다 문제를 확인하는 대신 이 나쁜 상태에 있지 않다는 점에 의존해야 합니다.</li>
<li>사용하는 타입에 이 정보를 인코딩할 좋은 방법이 없습니다. 18장의 <a href="ch18-03-oo-design-patterns.html#encoding-states-and-behavior-as-types">“상태와 동작을 타입으로 인코딩하기”</a><!-- ignore -->에서 이것이 무슨 뜻인지 예제를 통해 살펴볼 것입니다.</li>
</ul>
<p>누군가 여러분의 코드를 호출하고 말이 안 되는 값을 전달한다면, 가능하다면 에러를 반환하여 라이브러리 사용자가 그 경우에 무엇을 할지 결정할 수 있게 하는 것이 가장 좋습니다. 그러나 계속 진행하는 것이 안전하지 않거나 해로울 수 있는 경우, 가장 좋은 선택은 <code>panic!</code>을 호출하여 라이브러리를 사용하는 사람에게 코드의 버그를 알리고 개발 중에 수정할 수 있게 하는 것일 수 있습니다. 마찬가지로, 통제할 수 없는 외부 코드를 호출했는데 해결할 방법이 없는 유효하지 않은 상태를 반환하는 경우에도 <code>panic!</code>이 적절한 경우가 많습니다.</p>
<p>하지만 실패가 예상될 때는 <code>panic!</code> 호출보다는 <code>Result</code>를 반환하는 것이 더 적절합니다. 파서에 잘못된 형식의 데이터가 주어지거나 HTTP 요청이 속도 제한에 도달했음을 나타내는 상태를 반환하는 경우를 예로 들 수 있습니다. 이러한 경우 <code>Result</code>를 반환하는 것은 실패가 예상되는 가능성이며 호출하는 코드가 이를 처리하는 방법을 결정해야 함을 나타냅니다.</p>
<p>유효하지 않은 값을 사용하여 호출될 경우 사용자를 위험에 빠뜨릴 수 있는 작업을 코드가 수행할 때, 코드는 먼저 값이 유효한지 확인하고 유효하지 않으면 패닉을 일으켜야 합니다. 이는 주로 안전상의 이유 때문입니다: 유효하지 않은 데이터에 대한 작업 시도는 코드를 취약점에 노출시킬 수 있습니다. 이것이 범위를 벗어난 메모리 접근을 시도할 때 표준 라이브러리가 <code>panic!</code>을 호출하는 주된 이유입니다: 현재 데이터 구조에 속하지 않는 메모리에 접근하려고 하는 것은 일반적인 보안 문제입니다. 함수는 종종 _계약_을 가집니다: 입력이 특정 요구사항을 충족할 때만 동작이 보장됩니다. 계약이 위반되었을 때 패닉을 일으키는 것은 타당한데, 계약 위반은 항상 호출자 측 버그를 나타내며, 호출하는 코드가 명시적으로 처리해야 하는 종류의 에러가 아니기 때문입니다. 사실, 호출하는 코드가 복구할 수 있는 합리적인 방법은 없습니다; 호출하는 _프로그래머_가 코드를 수정해야 합니다. 함수에 대한 계약, 특히 위반 시 패닉을 유발하는 계약은 함수의 API 문서에 설명되어야 합니다.</p>
<p>하지만 모든 함수에 많은 오류 검사를 넣는 것은 장황하고 번거로울 것입니다. 다행히 러스트의 타입 시스템(따라서 컴파일러가 수행하는 타입 검사)을 사용하여 많은 검사를 대신 수행할 수 있습니다. 함수가 특정 타입을 매개변수로 가진다면, 컴파일러가 이미 유효한 값을 가지고 있음을 보장했으므로 코드의 로직을 진행할 수 있습니다. 예를 들어, <code>Option</code> 대신 타입을 가지고 있다면, 프로그램은 _아무것도 없음_이 아니라 _무언가_를 가질 것으로 예상합니다. 그러면 코드는 <code>Some</code>과 <code>None</code> variant에 대해 두 가지 경우를 처리할 필요가 없습니다. 확실히 값을 가지는 한 가지 경우만 처리하면 됩니다. 함수에 아무것도 전달하지 않으려는 코드는 컴파일조차 되지 않으므로, 함수는 런타임에 해당 경우를 확인할 필요가 없습니다. 또 다른 예는 매개변수가 절대 음수가 아님을 보장하는 <code>u32</code>와 같은 부호 없는 정수 타입을 사용하는 것입니다.</p>
<h3 id="유효성-검사를-위한-사용자-정의-타입-생성하기"><a class="header" href="#유효성-검사를-위한-사용자-정의-타입-생성하기">유효성 검사를 위한 사용자 정의 타입 생성하기</a></h3>
<p>러스트의 타입 시스템을 사용하여 유효한 값을 보장하는 아이디어를 한 단계 더 나아가 유효성 검사를 위한 사용자 정의 타입을 생성하는 방법을 살펴보겠습니다. 2장의 추측 게임에서 우리 코드가 사용자에게 1에서 100 사이의 숫자를 추측하도록 요청했던 것을 기억하세요. 우리는 사용자의 추측이 비밀 숫자와 비교하기 전에 해당 숫자들 사이에 있는지 유효성 검사를 하지 않았습니다. 단지 추측이 양수인지 여부만 유효성 검사했습니다. 이 경우 결과는 그리 심각하지 않았습니다. "너무 높음" 또는 "너무 낮음"이라는 출력은 여전히 올바를 것입니다. 하지만 사용자가 유효한 추측을 하도록 안내하고, 사용자가 범위를 벗어난 숫자를 추측하거나 예를 들어 문자를 입력할 때 다른 동작을 하도록 하는 유용한 개선 사항이 될 것입니다.</p>
<p>이를 수행하는 한 가지 방법은 추측을 <code>u32</code> 대신 <code>i32</code>로 파싱하여 잠재적으로 음수를 허용하고, 그런 다음 다음과 같이 숫자가 범위 내에 있는지 확인하는 검사를 추가하는 것입니다:</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    loop {
        // --생략--

<span class="boring">        println!(추측을 입력하세요.);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("줄 읽기 실패");
</span><span class="boring">
</span>        let guess: i32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        if guess &lt; 1 || guess &gt; 100 {
            println!("비밀 숫자는 1에서 100 사이입니다.");
            continue;
        }

        match guess.cmp(&amp;secret_number) {
            // --생략--
<span class="boring">            Ordering::Less =&gt; println!("너무 작아요!"),
</span><span class="boring">            Ordering::Greater =&gt; println!("너무 커요!"),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!("당신이 이겼습니다!");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span>    }
<span class="boring">}</span></code></pre>
</Listing>
<p><code>if</code> 표현식은 값이 범위를 벗어났는지 확인하고, 사용자에게 문제를 알리고, <code>continue</code>를 호출하여 루프의 다음 반복을 시작하고 다른 추측을 요청합니다. <code>if</code> 표현식 이후에는 <code>guess</code>가 1에서 100 사이임을 알고 <code>guess</code>와 비밀 숫자 간의 비교를 진행할 수 있습니다.</p>
<p>하지만 이것은 이상적인 해결책이 아닙니다. 만약 프로그램이 1에서 100 사이의 값으로만 작동하는 것이 절대적으로 중요하고, 이러한 요구 사항을 가진 함수가 많다면, 모든 함수에 이러한 검사를 포함하는 것은 지루할 것이며 (성능에 영향을 미칠 수도 있습니다).</p>
<p>대신, 새로운 타입을 만들고 유효성 검사를 함수에 넣어 타입의 인스턴스를 생성하도록 할 수 있습니다. 이렇게 하면 모든 곳에서 유효성 검사를 반복할 필요가 없습니다. 그렇게 하면 함수가 시그니처에서 새로운 타입을 안전하게 사용하고 받은 값을 확신을 가지고 사용할 수 있습니다. 목록 9-13은 <code>new</code> 함수가 1에서 100 사이의 값을 받을 때만 <code>Guess</code>의 인스턴스를 생성하는 <code>Guess</code> 타입을 정의하는 한 가지 방법을 보여줍니다.</p>
<Listing number="9-13" caption="A `Guess` type that will only continue with values between 1 and 100">
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(추측 값은 1에서 100 사이여야 합니다. {value}를 받았습니다.);
        }

        Guess { value }
    }

    pub fn value(&amp;self) -&gt; i32 {
        self.value
    }
}
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>먼저 <code>value</code>라는 <code>i32</code> 타입의 필드를 가진 <code>Guess</code>라는 구조체를 정의합니다. 여기에 숫자가 저장될 것입니다.</p>
<p>그런 다음 <code>Guess</code>에 <code>new</code>라는 연관 함수를 구현하여 <code>Guess</code> 값의 인스턴스를 생성합니다. <code>new</code> 함수는 <code>i32</code> 타입의 <code>value</code>라는 매개변수 하나를 가지고 <code>Guess</code>를 반환하도록 정의됩니다. <code>new</code> 함수의 본문 코드는 <code>value</code>가 1에서 100 사이인지 확인합니다. 만약 <code>value</code>가 이 테스트를 통과하지 못하면 <code>panic!</code> 호출을 발생시켜, 호출 코드를 작성하는 프로그래머에게 수정해야 할 버그가 있음을 알립니다. 왜냐하면 이 범위를 벗어난 <code>value</code>로 <code>Guess</code>를 생성하는 것은 <code>Guess::new</code>가 의존하는 계약을 위반하기 때문입니다. <code>Guess::new</code>가 패닉을 일으킬 수 있는 조건은 공개 API 문서에서 논의되어야 합니다. 14장에서 생성할 API 문서에서 <code>panic!</code> 가능성을 나타내는 문서화 규칙을 다룰 것입니다. 만약 <code>value</code>가 테스트를 통과하면, <code>value</code> 필드가 <code>value</code> 매개변수로 설정된 새로운 <code>Guess</code>를 생성하고 <code>Guess</code>를 반환합니다.</p>
<p>다음으로, <code>self</code>를 빌리고 다른 매개변수는 없으며 <code>i32</code>를 반환하는 <code>value</code>라는 메서드를 구현합니다. 이러한 종류의 메서드는 필드에서 데이터를 가져와 반환하는 것이 목적이므로 때때로 _게터_라고 불립니다. 이 공개 메서드는 <code>Guess</code> 구조체의 <code>value</code> 필드가 비공개이기 때문에 필요합니다. <code>value</code> 필드가 비공개인 것이 중요한데, 이는 <code>Guess</code> 구조체를 사용하는 코드가 <code>value</code>를 직접 설정할 수 없도록 하기 위함입니다. 모듈 외부의 코드는 <code>Guess::new</code> 함수를 사용하여 <code>Guess</code> 인스턴스를 생성해야 하며, 이를 통해 <code>Guess</code>가 <code>Guess::new</code> 함수의 조건에 의해 확인되지 않은 <code>value</code>를 가질 수 없도록 보장합니다.</p>
<p>매개변수를 가지거나 1에서 100 사이의 숫자만 반환하는 함수는 시그니처에서 <code>i32</code> 대신 <code>Guess</code>를 받거나 반환한다고 선언할 수 있으며, 본문에서 추가적인 검사를 할 필요가 없습니다.</p>
<h2 id="요약"><a class="header" href="#요약">요약</a></h2>
<p>러스트의 오류 처리 기능은 더 견고한 코드를 작성하는 데 도움이 되도록 설계되었습니다. <code>panic!</code> 매크로는 프로그램이 처리할 수 없는 상태에 있음을 알리고, 유효하지 않거나 잘못된 값으로 계속 진행하려고 시도하는 대신 프로세스를 중지하도록 지시합니다. <code>Result</code> 열거형은 러스트의 타입 시스템을 사용하여 코드가 복구할 수 있는 방식으로 작업이 실패할 수 있음을 나타냅니다. <code>Result</code>를 사용하여 코드를 호출하는 코드에 잠재적인 성공 또는 실패를 처리해야 한다고 알릴 수 있습니다. 적절한 상황에서 <code>panic!</code>과 <code>Result</code>를 사용하면 피할 수 없는 문제에 직면했을 때 코드를 더 안정적으로 만들 수 있습니다.</p>
<p>이제 표준 라이브러리가 <code>Option</code> 및 <code>Result</code> 열거형과 함께 제네릭을 사용하는 유용한 방법을 보았으니, 제네릭이 어떻게 작동하고 코드에서 어떻게 사용할 수 있는지에 대해 이야기할 것입니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch09-02-recoverable-errors-with-result.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch10-00-generics.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch09-02-recoverable-errors-with-result.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch10-00-generics.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
