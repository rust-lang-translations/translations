<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>panic!을 사용할지 말지 - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/book";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/ch09-03-to-panic-or-not-to-panic.md`;
                    } else {
                        canonical_href = `${base}/${lang}/ch09-03-to-panic-or-not-to-panic.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ru"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="panic을-사용할지-말지"><a class="header" href="#panic을-사용할지-말지"><code>panic!</code>을 사용할지 말지</a></h2>
<p>So, how do you decide when you should call <code>panic!</code> and when you should return <code>Result</code>? When code panics, there’s no way to recover. You could call <code>panic!</code> for any error situation, whether there’s a possible way to recover or not, but then you’re making the decision that a situation is unrecoverable on behalf of the calling code. When you choose to return a <code>Result</code> value, you give the calling code options. The calling code could choose to attempt to recover in a way that’s appropriate for its situation, or it could decide that an <code>Err</code> value in this case is unrecoverable, so it can call <code>panic!</code> and turn your recoverable error into an unrecoverable one. Therefore, returning <code>Result</code> is a good default choice when you’re defining a function that might fail.</p>
<p>예제, 프로토타입 코드, 테스트와 같은 상황에서는 <code>Result</code>를 반환하는 대신 패닉을 일으키는 코드를 작성하는 것이 더 적절합니다. 그 이유를 알아보고, 컴파일러는 실패가 불가능하다는 것을 알 수 없지만 사람은 알 수 있는 상황에 대해 논의해 보겠습니다. 이 장은 라이브러리 코드에서 패닉을 일으킬지 여부를 결정하는 방법에 대한 몇 가지 일반적인 지침으로 마무리할 것입니다.</p>
<h3 id="예제-프로토타입-코드-그리고-테스트"><a class="header" href="#예제-프로토타입-코드-그리고-테스트">예제, 프로토타입 코드, 그리고 테스트</a></h3>
<p>어떤 개념을 설명하기 위해 예제를 작성할 때, 견고한 에러 처리 코드까지 포함하면 예제가 덜 명확해질 수 있습니다. 예제에서 패닉을 일으킬 수 있는 <code>unwrap</code> 같은 메서드를 호출하는 것은 여러분이 애플리케이션에서 에러를 처리하고자 하는 방식에 대한 자리 표시자로 이해되며, 이는 나머지 코드가 수행하는 작업에 따라 달라질 수 있습니다.</p>
<p>Similarly, the <code>unwrap</code> and <code>expect</code> methods are very handy when you’re prototyping and you’re not yet ready to decide how to handle errors. They leave clear markers in your code for when you’re ready to make your program more robust.</p>
<p>테스트에서 메서드 호출이 실패하면, 해당 메서드가 테스트 대상 기능이 아니더라도 전체 테스트가 실패하기를 원할 것입니다. <code>panic!</code>은 테스트가 실패로 표시되는 방식이므로, <code>unwrap</code>이나 <code>expect</code>를 호출하는 것이 정확히 일어나야 할 일입니다.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="cases-in-which-you-have-more-information-than-the-compiler"></a></p>
<h3 id="when-you-have-more-information-than-the-compiler"><a class="header" href="#when-you-have-more-information-than-the-compiler">When You Have More Information Than the Compiler</a></h3>
<p>It would also be appropriate to call <code>expect</code> when you have some other logic that ensures that the <code>Result</code> will have an <code>Ok</code> value, but the logic isn’t something the compiler understands. You’ll still have a <code>Result</code> value that you need to handle: Whatever operation you’re calling still has the possibility of failing in general, even though it’s logically impossible in your particular situation. If you can ensure by manually inspecting the code that you’ll never have an <code>Err</code> variant, it’s perfectly acceptable to call <code>expect</code> and document the reason you think you’ll never have an <code>Err</code> variant in the argument text. Here’s an example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    use std::net::IpAddr;

    let home: IpAddr = "127.0.0.1"
        .parse()
        .expect("하드코딩된 IP 주소는 유효해야 합니다");
<span class="boring">}</span></code></pre></pre>
<p>We’re creating an <code>IpAddr</code> instance by parsing a hardcoded string. We can see that <code>127.0.0.1</code> is a valid IP address, so it’s acceptable to use <code>expect</code> here. However, having a hardcoded, valid string doesn’t change the return type of the <code>parse</code> method: We still get a <code>Result</code> value, and the compiler will still make us handle the <code>Result</code> as if the <code>Err</code> variant is a possibility because the compiler isn’t smart enough to see that this string is always a valid IP address. If the IP address string came from a user rather than being hardcoded into the program and therefore <em>did</em> have a possibility of failure, we’d definitely want to handle the <code>Result</code> in a more robust way instead. Mentioning the assumption that this IP address is hardcoded will prompt us to change <code>expect</code> to better error-handling code if, in the future, we need to get the IP address from some other source instead.</p>
<h3 id="에러-처리-가이드라인"><a class="header" href="#에러-처리-가이드라인">에러 처리 가이드라인</a></h3>
<p>코드가 나쁜 상태에 빠질 수 있을 때 코드가 패닉을 일으키도록 하는 것이 좋습니다. 이 문맥에서 _나쁜 상태_란 유효하지 않은 값, 모순되는 값, 또는 누락된 값이 코드에 전달되는 것과 같이 일부 가정, 보장, 계약 또는 불변성이 깨진 경우를 말하며, 여기에 더해 다음 중 하나 이상에 해당할 때입니다:</p>
<ul>
<li>나쁜 상태는 사용자가 잘못된 형식의 데이터를 입력하는 것처럼 가끔 일어날 가능성이 있는 것이 아니라 예상치 못한 것입니다.</li>
<li>이 시점 이후의 코드는 매 단계마다 문제를 확인하는 대신 이 나쁜 상태에 있지 않다는 점에 의존해야 합니다.</li>
<li>사용하는 타입에 이 정보를 인코딩할 좋은 방법이 없습니다. 18장의 <a href="ch18-03-oo-design-patterns.html#encoding-states-and-behavior-as-types">“상태와 동작을 타입으로 인코딩하기”</a><!-- ignore -->에서 이것이 무슨 뜻인지 예제를 통해 살펴볼 것입니다.</li>
</ul>
<p>If someone calls your code and passes in values that don’t make sense, it’s best to return an error if you can so that the user of the library can decide what they want to do in that case. However, in cases where continuing could be insecure or harmful, the best choice might be to call <code>panic!</code> and alert the person using your library to the bug in their code so that they can fix it during development. Similarly, <code>panic!</code> is often appropriate if you’re calling external code that is out of your control and returns an invalid state that you have no way of fixing.</p>
<p>하지만 실패가 예상될 때는 <code>panic!</code> 호출보다는 <code>Result</code>를 반환하는 것이 더 적절합니다. 파서에 잘못된 형식의 데이터가 주어지거나 HTTP 요청이 속도 제한에 도달했음을 나타내는 상태를 반환하는 경우를 예로 들 수 있습니다. 이러한 경우 <code>Result</code>를 반환하는 것은 실패가 예상되는 가능성이며 호출하는 코드가 이를 처리하는 방법을 결정해야 함을 나타냅니다.</p>
<p>When your code performs an operation that could put a user at risk if it’s called using invalid values, your code should verify the values are valid first and panic if the values aren’t valid. This is mostly for safety reasons: Attempting to operate on invalid data can expose your code to vulnerabilities. This is the main reason the standard library will call <code>panic!</code> if you attempt an out-of-bounds memory access: Trying to access memory that doesn’t belong to the current data structure is a common security problem. Functions often have <em>contracts</em>: Their behavior is only guaranteed if the inputs meet particular requirements. Panicking when the contract is violated makes sense because a contract violation always indicates a caller-side bug, and it’s not a kind of error you want the calling code to have to explicitly handle. In fact, there’s no reasonable way for calling code to recover; the calling <em>programmers</em> need to fix the code. Contracts for a function, especially when a violation will cause a panic, should be explained in the API documentation for the function.</p>
<p>However, having lots of error checks in all of your functions would be verbose and annoying. Fortunately, you can use Rust’s type system (and thus the type checking done by the compiler) to do many of the checks for you. If your function has a particular type as a parameter, you can proceed with your code’s logic knowing that the compiler has already ensured that you have a valid value. For example, if you have a type rather than an <code>Option</code>, your program expects to have <em>something</em> rather than <em>nothing</em>. Your code then doesn’t have to handle two cases for the <code>Some</code> and <code>None</code> variants: It will only have one case for definitely having a value. Code trying to pass nothing to your function won’t even compile, so your function doesn’t have to check for that case at runtime. Another example is using an unsigned integer type such as <code>u32</code>, which ensures that the parameter is never negative.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="creating-custom-types-for-validation"></a></p>
<h3 id="custom-types-for-validation"><a class="header" href="#custom-types-for-validation">Custom Types for Validation</a></h3>
<p>Let’s take the idea of using Rust’s type system to ensure that we have a valid value one step further and look at creating a custom type for validation. Recall the guessing game in Chapter 2 in which our code asked the user to guess a number between 1 and 100. We never validated that the user’s guess was between those numbers before checking it against our secret number; we only validated that the guess was positive. In this case, the consequences were not very dire: Our output of “Too high” or “Too low” would still be correct. But it would be a useful enhancement to guide the user toward valid guesses and have different behavior when the user guesses a number that’s out of range versus when the user types, for example, letters instead.</p>
<p>이를 수행하는 한 가지 방법은 추측을 <code>u32</code> 대신 <code>i32</code>로 파싱하여 잠재적으로 음수를 허용하고, 그런 다음 다음과 같이 숫자가 범위 내에 있는지 확인하는 검사를 추가하는 것입니다:</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!("숫자를 맞춰보세요!");
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    loop {
        // --생략--

<span class="boring">        println!(추측을 입력하세요.);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect("줄 읽기 실패");
</span><span class="boring">
</span>        let guess: i32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        if guess &lt; 1 || guess &gt; 100 {
            println!("비밀 숫자는 1에서 100 사이입니다.");
            continue;
        }

        match guess.cmp(&amp;secret_number) {
            // --생략--
<span class="boring">            Ordering::Less =&gt; println!("너무 작아요!"),
</span><span class="boring">            Ordering::Greater =&gt; println!("너무 커요!"),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!("당신이 이겼습니다!");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span>    }
<span class="boring">}</span></code></pre>
</Listing>
<p><code>if</code> 표현식은 값이 범위를 벗어났는지 확인하고, 사용자에게 문제를 알리고, <code>continue</code>를 호출하여 루프의 다음 반복을 시작하고 다른 추측을 요청합니다. <code>if</code> 표현식 이후에는 <code>guess</code>가 1에서 100 사이임을 알고 <code>guess</code>와 비밀 숫자 간의 비교를 진행할 수 있습니다.</p>
<p>However, this is not an ideal solution: If it were absolutely critical that the program only operated on values between 1 and 100, and it had many functions with this requirement, having a check like this in every function would be tedious (and might impact performance).</p>
<p>Instead, we can make a new type in a dedicated module and put the validations in a function to create an instance of the type rather than repeating the validations everywhere. That way, it’s safe for functions to use the new type in their signatures and confidently use the values they receive. Listing 9-13 shows one way to define a <code>Guess</code> type that will only create an instance of <code>Guess</code> if the <code>new</code> function receives a value between 1 and 100.</p>
<Listing number="9-13" caption="A `Guess` type that will only continue with values between 1 and 100" file-name="src/guessing_game.rs">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(추측 값은 1에서 100 사이여야 합니다. {value}를 받았습니다.);
        }

        Guess { value }
    }

    pub fn value(&amp;self) -&gt; i32 {
        self.value
    }
}
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>Note that this code in <em>src/guessing_game.rs</em> depends on adding a module declaration <code>mod guessing_game;</code> in <em>src/lib.rs</em> that we haven’t shown here. Within this new module’s file, we define a struct named <code>Guess</code> that has a field named <code>value</code> that holds an <code>i32</code>. This is where the number will be stored.</p>
<p>Then, we implement an associated function named <code>new</code> on <code>Guess</code> that creates instances of <code>Guess</code> values. The <code>new</code> function is defined to have one parameter named <code>value</code> of type <code>i32</code> and to return a <code>Guess</code>. The code in the body of the <code>new</code> function tests <code>value</code> to make sure it’s between 1 and 100. If <code>value</code> doesn’t pass this test, we make a <code>panic!</code> call, which will alert the programmer who is writing the calling code that they have a bug they need to fix, because creating a <code>Guess</code> with a <code>value</code> outside this range would violate the contract that <code>Guess::new</code> is relying on. The conditions in which <code>Guess::new</code> might panic should be discussed in its public-facing API documentation; we’ll cover documentation conventions indicating the possibility of a <code>panic!</code> in the API documentation that you create in Chapter 14. If <code>value</code> does pass the test, we create a new <code>Guess</code> with its <code>value</code> field set to the <code>value</code> parameter and return the <code>Guess</code>.</p>
<p>Next, we implement a method named <code>value</code> that borrows <code>self</code>, doesn’t have any other parameters, and returns an <code>i32</code>. This kind of method is sometimes called a <em>getter</em> because its purpose is to get some data from its fields and return it. This public method is necessary because the <code>value</code> field of the <code>Guess</code> struct is private. It’s important that the <code>value</code> field be private so that code using the <code>Guess</code> struct is not allowed to set <code>value</code> directly: Code outside the <code>guessing_game</code> module <em>must</em> use the <code>Guess::new</code> function to create an instance of <code>Guess</code>, thereby ensuring that there’s no way for a <code>Guess</code> to have a <code>value</code> that hasn’t been checked by the conditions in the <code>Guess::new</code> function.</p>
<p>매개변수를 가지거나 1에서 100 사이의 숫자만 반환하는 함수는 시그니처에서 <code>i32</code> 대신 <code>Guess</code>를 받거나 반환한다고 선언할 수 있으며, 본문에서 추가적인 검사를 할 필요가 없습니다.</p>
<h2 id="요약"><a class="header" href="#요약">요약</a></h2>
<p>러스트의 오류 처리 기능은 더 견고한 코드를 작성하는 데 도움이 되도록 설계되었습니다. <code>panic!</code> 매크로는 프로그램이 처리할 수 없는 상태에 있음을 알리고, 유효하지 않거나 잘못된 값으로 계속 진행하려고 시도하는 대신 프로세스를 중지하도록 지시합니다. <code>Result</code> 열거형은 러스트의 타입 시스템을 사용하여 코드가 복구할 수 있는 방식으로 작업이 실패할 수 있음을 나타냅니다. <code>Result</code>를 사용하여 코드를 호출하는 코드에 잠재적인 성공 또는 실패를 처리해야 한다고 알릴 수 있습니다. 적절한 상황에서 <code>panic!</code>과 <code>Result</code>를 사용하면 피할 수 없는 문제에 직면했을 때 코드를 더 안정적으로 만들 수 있습니다.</p>
<p>이제 표준 라이브러리가 <code>Option</code> 및 <code>Result</code> 열거형과 함께 제네릭을 사용하는 유용한 방법을 보았으니, 제네릭이 어떻게 작동하고 코드에서 어떻게 사용할 수 있는지에 대해 이야기할 것입니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch09-02-recoverable-errors-with-result.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch10-00-generics.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch09-02-recoverable-errors-with-result.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch10-00-generics.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
