<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>소멸자 - The Rust Reference</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/reference";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/destructors.md`;
                    } else {
                        canonical_href = `${base}/${lang}/destructors.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/reference.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/reference/edit/master/src/destructors.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="소멸자"><a class="header" href="#소멸자">소멸자</a></h1>
<div class="rule" id="r-destructors.intro"><a class="rule-link" href="#r-destructors.intro" title="destructors.intro"><span>[destructors<wbr>.intro]<span/></a></div>
<p><a href="glossary.html#initialized">초기화된(initialized)</a> <a href="variables.html">변수</a> 또는 <a href="expressions.html#temporaries">임시 값(temporary)</a>이 <a href="#drop-scopes">스코프(scope)</a>를 벗어나면, 해당 값의 _소멸자(destructor)_가 실행되거나 해당 값이 _드롭(dropped)_됩니다. <a href="expressions/operator-expr.html#assignment-expressions">할당(Assignment)</a> 또한 좌항 피연산자가 초기화된 상태라면 그 소멸자를 실행합니다. 변수가 부분적으로만 초기화된 경우, 초기화된 필드만 드롭됩니다.</p>
<div class="rule" id="r-destructors.operation"><a class="rule-link" href="#r-destructors.operation" title="destructors.operation"><span>[destructors<wbr>.operation]<span/></a></div>
<p>타입 <code>T</code>의 소멸자는 다음과 같이 구성됩니다.</p>
<ol>
<li><code>T: Drop</code>인 경우, <a href="../core/ops/drop/trait.Drop.html#tymethod.drop"><code>&lt;T as std::ops::Drop&gt;::drop</code></a> 호출</li>
<li>모든 필드에 대해 재귀적으로 소멸자 실행.
<ul>
<li><a href="types/struct.html">구조체(struct)</a>의 필드들은 선언된 순서대로 드롭됩니다.</li>
<li>활성 <a href="types/enum.html">열거형 변형(enum variant)</a>의 필드들은 선언된 순서대로 드롭됩니다.</li>
<li><a href="types/tuple.html">튜플(tuple)</a>의 필드들은 순서대로 드롭됩니다.</li>
<li><a href="types/array.html">배열(array)</a> 또는 소유권이 있는 <a href="types/slice.html">슬라이스(slice)</a>의 요소들은 첫 번째 요소부터 마지막 요소 순으로 드롭됩니다.</li>
<li><a href="types/closure.html">클로저(closure)</a>가 이동(move)으로 캡처한 변수들은 지정되지 않은 순서대로 드롭됩니다.</li>
<li><a href="types/trait-object.html">트레잇 객체(Trait objects)</a>는 기저 타입(underlying type)의 소멸자를 실행합니다.</li>
<li>다른 타입들은 추가적인 드롭을 발생시키지 않습니다.</li>
</ul>
</li>
</ol>
<div class="rule" id="r-destructors.drop_in_place"><a class="rule-link" href="#r-destructors.drop_in_place" title="destructors.drop_in_place"><span>[destructors<wbr>.drop_in_place]<span/></a></div>
<p>자신만의 스마트 포인터를 구현할 때와 같이 소멸자를 수동으로 실행해야 하는 경우, <a href="../core/ptr/fn.drop_in_place.html"><code>std::ptr::drop_in_place</code></a>를 사용할 수 있습니다.</p>
<p>몇 가지 예제:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct PrintOnDrop(&amp;'static str);

impl Drop for PrintOnDrop {
    fn drop(&amp;mut self) {
        println!("{}", self.0);
    }
}

let mut overwritten = PrintOnDrop("덮어써질 때 드롭됨");
overwritten = PrintOnDrop("스코프가 끝날 때 드롭됨");

let tuple = (PrintOnDrop("튜플 첫 번째"), PrintOnDrop("튜플 두 번째"));

let moved;
// 할당 시 소멸자가 실행되지 않음.
moved = PrintOnDrop("이동될 때 드롭됨");
// 지금 드롭되지만, 그 후에는 초기화되지 않은 상태가 됩니다.
moved;

// 초기화되지 않은 상태에서는 드롭되지 않습니다.
let uninitialized: PrintOnDrop;

// 부분 이동 후에는 남아 있는 필드만 드롭됩니다.
let mut partial_move = (PrintOnDrop("first"), PrintOnDrop("잊힘(forgotten)"));
// 부분 이동을 수행하여 `partial_move.0`만 초기화된 상태로 남깁니다.
core::mem::forget(partial_move.1);
// partial_move의 스코프가 끝나면 첫 번째 필드만 드롭됩니다.
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-destructors.scope"><a class="rule-link" href="#r-destructors.scope" title="destructors.scope"><span>[destructors<wbr>.scope]<span/></a></div>
<h2 id="드롭-스코프"><a class="header" href="#드롭-스코프">드롭 스코프</a></h2>
<div class="rule" id="r-destructors.scope.intro"><a class="rule-link" href="#r-destructors.scope.intro" title="destructors.scope.intro"><span>[destructors<wbr>.scope<wbr>.intro]<span/></a></div>
<p>각 변수나 임시 값은 _드롭 스코프(drop scope)_와 연관됩니다. 제어 흐름이 드롭 스코프를 벗어나면 해당 스코프와 연관된 모든 변수는 선언된 역순으로, 임시 값은 생성된 역순으로 드롭됩니다.</p>
<div class="rule" id="r-destructors.scope.desugaring"><a class="rule-link" href="#r-destructors.scope.desugaring" title="destructors.scope.desugaring"><span>[destructors<wbr>.scope<wbr>.desugaring]<span/></a></div>
<p>드롭 스코프는 <a href="expressions/loop-expr.html#iterator-loops"><code>for</code></a>, <a href="expressions/if-expr.html#if-let-expressions"><code>if let</code></a>, <a href="expressions/loop-expr.html#predicate-pattern-loops"><code>while let</code></a> 표현식을 <a href="expressions/match-expr.html"><code>match</code></a>를 사용한 등가의 표현식으로 대체한 후에 결정됩니다.</p>
<div class="rule" id="r-destructors.scope.operators"><a class="rule-link" href="#r-destructors.scope.operators" title="destructors.scope.operators"><span>[destructors<wbr>.scope<wbr>.operators]<span/></a></div>
<p>오버로드된 연산자는 내장 연산자와 구별되지 않으며, <a href="patterns.html#binding-modes">바인딩 모드(binding modes)</a>는 고려되지 않습니다.</p>
<div class="rule" id="r-destructors.scope.list"><a class="rule-link" href="#r-destructors.scope.list" title="destructors.scope.list"><span>[destructors<wbr>.scope<wbr>.list]<span/></a></div>
<p>함수 또는 클로저가 주어지면, 다음과 같은 것들에 대한 드롭 스코프가 존재합니다.</p>
<div class="rule" id="r-destructors.scope.function"><a class="rule-link" href="#r-destructors.scope.function" title="destructors.scope.function"><span>[destructors<wbr>.scope<wbr>.function]<span/></a></div>
<ul>
<li>함수 전체</li>
</ul>
<div class="rule" id="r-destructors.scope.statement"><a class="rule-link" href="#r-destructors.scope.statement" title="destructors.scope.statement"><span>[destructors<wbr>.scope<wbr>.statement]<span/></a></div>
<ul>
<li>각 <a href="statements.html">구문(statement)</a></li>
</ul>
<div class="rule" id="r-destructors.scope.expression"><a class="rule-link" href="#r-destructors.scope.expression" title="destructors.scope.expression"><span>[destructors<wbr>.scope<wbr>.expression]<span/></a></div>
<ul>
<li>각 <a href="expressions.html">표현식(expression)</a></li>
</ul>
<div class="rule" id="r-destructors.scope.block"><a class="rule-link" href="#r-destructors.scope.block" title="destructors.scope.block"><span>[destructors<wbr>.scope<wbr>.block]<span/></a></div>
<ul>
<li>함수 본문을 포함한 각 블록
<ul>
<li><a href="expressions/block-expr.html">블록 표현식(block expression)</a>의 경우, 블록의 스코프와 표현식의 스코프는 동일합니다.</li>
</ul>
</li>
</ul>
<div class="rule" id="r-destructors.scope.match-arm"><a class="rule-link" href="#r-destructors.scope.match-arm" title="destructors.scope.match-arm"><span>[destructors<wbr>.scope<wbr>.match-arm]<span/></a></div>
<ul>
<li><code>match</code> 표현식의 각 암(arm)</li>
</ul>
<div class="rule" id="r-destructors.scope.nesting"><a class="rule-link" href="#r-destructors.scope.nesting" title="destructors.scope.nesting"><span>[destructors<wbr>.scope<wbr>.nesting]<span/></a></div>
<p>드롭 스코프들은 다음과 같이 서로 중첩됩니다. 함수에서 반환될 때와 같이 여러 스코프를 한꺼번에 벗어날 때, 변수들은 안쪽에서 바깥쪽 순서로 드롭됩니다.</p>
<div class="rule" id="r-destructors.scope.nesting.function"><a class="rule-link" href="#r-destructors.scope.nesting.function" title="destructors.scope.nesting.function"><span>[destructors<wbr>.scope<wbr>.nesting<wbr>.function]<span/></a></div>
<ul>
<li>함수 전체 스코프가 최외곽 스코프입니다.</li>
</ul>
<div class="rule" id="r-destructors.scope.nesting.function-body"><a class="rule-link" href="#r-destructors.scope.nesting.function-body" title="destructors.scope.nesting.function-body"><span>[destructors<wbr>.scope<wbr>.nesting<wbr>.function-body]<span/></a></div>
<ul>
<li>함수 본문 블록은 함수 전체 스코프 내에 포함됩니다.</li>
</ul>
<div class="rule" id="r-destructors.scope.nesting.expr-statement"><a class="rule-link" href="#r-destructors.scope.nesting.expr-statement" title="destructors.scope.nesting.expr-statement"><span>[destructors<wbr>.scope<wbr>.nesting<wbr>.expr-statement]<span/></a></div>
<ul>
<li>표현식 구문 내 표현식의 부모는 해당 구문의 스코프입니다.</li>
</ul>
<div class="rule" id="r-destructors.scope.nesting.let-initializer"><a class="rule-link" href="#r-destructors.scope.nesting.let-initializer" title="destructors.scope.nesting.let-initializer"><span>[destructors<wbr>.scope<wbr>.nesting<wbr>.let-initializer]<span/></a></div>
<ul>
<li><a href="statements.html#let-statements"><code>let</code> 구문(let statement)</a>의 초기화식의 부모는 해당 <code>let</code> 구문의 스코프입니다.</li>
</ul>
<div class="rule" id="r-destructors.scope.nesting.statement"><a class="rule-link" href="#r-destructors.scope.nesting.statement" title="destructors.scope.nesting.statement"><span>[destructors<wbr>.scope<wbr>.nesting<wbr>.statement]<span/></a></div>
<ul>
<li>구문 스코프의 부모는 해당 구문을 포함하는 블록의 스코프입니다.</li>
</ul>
<div class="rule" id="r-destructors.scope.nesting.match-guard"><a class="rule-link" href="#r-destructors.scope.nesting.match-guard" title="destructors.scope.nesting.match-guard"><span>[destructors<wbr>.scope<wbr>.nesting<wbr>.match-guard]<span/></a></div>
<ul>
<li><code>match</code> 가드(guard) 표현식의 부모는 해당 가드가 속한 매치 암의 스코프입니다.</li>
</ul>
<div class="rule" id="r-destructors.scope.nesting.match-arm"><a class="rule-link" href="#r-destructors.scope.nesting.match-arm" title="destructors.scope.nesting.match-arm"><span>[destructors<wbr>.scope<wbr>.nesting<wbr>.match-arm]<span/></a></div>
<ul>
<li><code>match</code> 표현식에서 <code>=&gt;</code> 뒤에 오는 표현식의 부모는 그것이 속한 매치 암의 스코프입니다.</li>
</ul>
<div class="rule" id="r-destructors.scope.nesting.match"><a class="rule-link" href="#r-destructors.scope.nesting.match" title="destructors.scope.nesting.match"><span>[destructors<wbr>.scope<wbr>.nesting<wbr>.match]<span/></a></div>
<ul>
<li>매치 암 스코프의 부모는 그것이 속한 <code>match</code> 표현식의 스코프입니다.</li>
</ul>
<div class="rule" id="r-destructors.scope.nesting.other"><a class="rule-link" href="#r-destructors.scope.nesting.other" title="destructors.scope.nesting.other"><span>[destructors<wbr>.scope<wbr>.nesting<wbr>.other]<span/></a></div>
<ul>
<li>그 외 모든 스코프의 부모는 그것을 직접 감싸고 있는 표현식의 스코프입니다.</li>
</ul>
<div class="rule" id="r-destructors.scope.params"><a class="rule-link" href="#r-destructors.scope.params" title="destructors.scope.params"><span>[destructors<wbr>.scope<wbr>.params]<span/></a></div>
<h3 id="함수-매개변수의-스코프"><a class="header" href="#함수-매개변수의-스코프">함수 매개변수의 스코프</a></h3>
<p>모든 함수 매개변수는 함수 본문 전체의 스코프에 속하므로, 함수가 평가될 때 가장 마지막에 드롭됩니다. 각 실제 함수 매개변수는 해당 매개변수의 패턴에서 도입된 모든 바인딩이 드롭된 후에 드롭됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct PrintOnDrop(&amp;'static str);
</span><span class="boring">impl Drop for PrintOnDrop {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!("드롭({})", self.0);
</span><span class="boring">    }
</span><span class="boring">}
</span>// `y`가 드롭되고, 그다음 두 번째 매개변수, 그다음 `x`, 그다음 첫 번째 매개변수 순으로 드롭됩니다.
fn patterns_in_parameters(
    (x, _): (PrintOnDrop, PrintOnDrop),
    (_, y): (PrintOnDrop, PrintOnDrop),
) {}

// 드롭 순서는 3 2 0 1입니다.
patterns_in_parameters(
    (PrintOnDrop("0"), PrintOnDrop("1")),
    (PrintOnDrop("2"), PrintOnDrop("3")),
);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-destructors.scope.bindings"><a class="rule-link" href="#r-destructors.scope.bindings" title="destructors.scope.bindings"><span>[destructors<wbr>.scope<wbr>.bindings]<span/></a></div>
<h3 id="지역-변수의-스코프"><a class="header" href="#지역-변수의-스코프">지역 변수의 스코프</a></h3>
<div class="rule" id="r-destructors.scope.bindings.intro"><a class="rule-link" href="#r-destructors.scope.bindings.intro" title="destructors.scope.bindings.intro"><span>[destructors<wbr>.scope<wbr>.bindings<wbr>.intro]<span/></a></div>
<p><code>let</code> 구문에서 선언된 지역 변수는 해당 <code>let</code> 구문을 포함하는 블록의 스코프와 연관됩니다. <code>match</code> 표현식에서 선언된 지역 변수는 그것이 선언된 <code>match</code> 암의 암 스코프와 연관됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct PrintOnDrop(&amp;'static str);
</span><span class="boring">impl Drop for PrintOnDrop {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!("드롭({})", self.0);
</span><span class="boring">    }
</span><span class="boring">}
</span>let declared_first = PrintOnDrop("바깥쪽 스코프에서 마지막에 드롭됨");
{
    let declared_in_block = PrintOnDrop("안쪽 스코프에서 드롭됨");
}
let declared_last = PrintOnDrop("바깥쪽 스코프에서 먼저 드롭됨");
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-destructors.scope.bindings.match-pattern-order"><a class="rule-link" href="#r-destructors.scope.bindings.match-pattern-order" title="destructors.scope.bindings.match-pattern-order"><span>[destructors<wbr>.scope<wbr>.bindings<wbr>.match-pattern-order]<span/></a></div>
<p><code>match</code> 표현식의 동일한 암(arm)에서 여러 패턴이 사용되는 경우, 지정되지 않은 패턴 중 하나가 드롭 순서를 결정하는 데 사용됩니다.</p>
<div class="rule" id="r-destructors.scope.temporary"><a class="rule-link" href="#r-destructors.scope.temporary" title="destructors.scope.temporary"><span>[destructors<wbr>.scope<wbr>.temporary]<span/></a></div>
<h3 id="임시-스코프"><a class="header" href="#임시-스코프">임시 스코프</a></h3>
<div class="rule" id="r-destructors.scope.temporary.intro"><a class="rule-link" href="#r-destructors.scope.temporary.intro" title="destructors.scope.temporary.intro"><span>[destructors<wbr>.scope<wbr>.temporary<wbr>.intro]<span/></a></div>
<p>어떤 표현식의 _임시 스코프(temporary scope)_는 해당 표현식이 <a href="expressions.html#place-expressions-and-value-expressions">장소 컨텍스트(place context)</a>에서 사용될 때 그 결과를 보관하는 임시 변수에 사용되는 스코프입니다. 다만 해당 표현식이 <a href="destructors.html#constant-promotion">승격(promoted)</a>된 경우는 제외합니다.</p>
<div class="rule" id="r-destructors.scope.temporary.enclosing"><a class="rule-link" href="#r-destructors.scope.temporary.enclosing" title="destructors.scope.temporary.enclosing"><span>[destructors<wbr>.scope<wbr>.temporary<wbr>.enclosing]<span/></a></div>
<p>라이프타임 확장을 제외하면, 표현식의 임시 스코프는 해당 표현식을 포함하는 가장 작은 스코프이며 다음 중 하나입니다.</p>
<ul>
<li>함수 전체.</li>
<li>구문(statement).</li>
<li><a href="expressions/if-expr.html#if-expressions"><code>if</code></a>, <a href="expressions/loop-expr.html#predicate-loops"><code>while</code></a> 또는 <a href="expressions/loop-expr.html#infinite-loops"><code>loop</code></a> 표현식의 본문.</li>
<li><code>if</code> 표현식의 <code>else</code> 블록.</li>
<li><code>if</code> 또는 <code>while</code> 표현식의 조건식, 혹은 <code>match</code> 가드(guard).</li>
<li>매치 암의 본문 표현식.</li>
<li><a href="expressions/operator-expr.html#lazy-boolean-operators">지연 불리언 표현식(lazy boolean expression)</a>의 각 피연산자.</li>
<li><a href="expressions/if-expr.html#if-let-expressions"><code>if let</code></a>의 패턴 매칭 조건과 그에 따른 본문 (<a href="destructors.html#r-destructors.scope.temporary.edition2024">destructors.scope.temporary.edition2024</a>).</li>
<li>블록 꼬리 표현식(tail expression)의 전체 (<a href="destructors.html#r-destructors.scope.temporary.edition2024">destructors.scope.temporary.edition2024</a>).</li>
</ul>
<blockquote>
<p><strong>참고</strong>:</p>
<p><code>match</code> 표현식의 <a href="glossary.html#scrutinee">스크루티니(scrutinee)</a>는 임시 스코프가 아니므로, 스크루티니 내의 임시 값들은 <code>match</code> 표현식 이후에 드롭될 수 있습니다. 예를 들어, <code>match 1 { ref mut z =&gt; z };</code>에서 <code>1</code>을 위한 임시 값은 구문이 끝날 때까지 유지됩니다.</p>
</blockquote>
<div class="rule" id="r-destructors.scope.temporary.edition2024"><a class="rule-link" href="#r-destructors.scope.temporary.edition2024" title="destructors.scope.temporary.edition2024"><span>[destructors<wbr>.scope<wbr>.temporary<wbr>.edition2024]<span/></a></div>
<blockquote>
<p><strong>에디션 차이</strong>: 2024 에디션에는 두 가지 새로운 임시 스코프 축소 규칙이 추가되었습니다. <code>if let</code> 임시 값은 <code>else</code> 블록 이전에 드롭되며, 블록 꼬리 표현식의 임시 값은 꼬리 표현식이 평가된 직후에 드롭됩니다.</p>
</blockquote>
<p>몇 가지 예제:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct PrintOnDrop(&amp;'static str);
</span><span class="boring">impl Drop for PrintOnDrop {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!("드롭({})", self.0);
</span><span class="boring">    }
</span><span class="boring">}
</span>let local_var = PrintOnDrop("지역 변수");

// 조건이 평가되면 드롭됨
if PrintOnDrop("If 조건").0 == "If 조건" {
    // 블록 끝에서 드롭됨
    PrintOnDrop("If 본문").0
} else {
    unreachable!()
};

if let "if let 스크루티니" = PrintOnDrop("if let 스크루티니").0 {
    PrintOnDrop("if let 결과절").0
    // `if let 결과절`이 여기서 드롭됨
}
// `if let 스크루티니`가 여기서 드롭됨
else {
    PrintOnDrop("if let else").0
    // `if let else`가 여기서 드롭됨
};

// 첫 번째 || 이전에 드롭됨
(PrintOnDrop("첫 번째 피연산자").0 == ""
// ) 이전에 드롭됨
|| PrintOnDrop("두 번째 피연산자").0 == "")
// ; 이전에 드롭됨
|| PrintOnDrop("세 번째 피연산자").0 == "";

// 스크루티니는 함수의 끝에서 지역 변수들 이전에 드롭됩니다
// (이것이 함수 본문 블록의 꼬리 표현식이기 때문입니다).
match PrintOnDrop("최종 표현식의 매치된 값") {
    // 조건이 평가되면 드롭됨
    _ if PrintOnDrop("가드 조건").0 == "" =&gt; (),
    _ =&gt; (),
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-destructors.scope.operands"><a class="rule-link" href="#r-destructors.scope.operands" title="destructors.scope.operands"><span>[destructors<wbr>.scope<wbr>.operands]<span/></a></div>
<h3 id="피연산자"><a class="header" href="#피연산자">피연산자</a></h3>
<p>다른 피연산자가 평가되는 동안 표현식의 피연산자 결과를 보관하기 위해 임시 값이 생성되기도 합니다. 이러한 임시 값은 해당 피연산자가 속한 표현식의 스코프와 연관됩니다. 표현식이 평가되면 임시 값으로부터 데이터가 이동하므로, 표현식의 피연산자 중 하나가 표현식을 벗어나거나(break), 반환되거나(return), 패닉(panic)이 발생하지 않는 한 이들을 드롭하는 것은 아무런 효과가 없습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct PrintOnDrop(&amp;'static str);
</span><span class="boring">impl Drop for PrintOnDrop {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!("드롭({})", self.0);
</span><span class="boring">    }
</span><span class="boring">}
</span>loop {
    // 튜플 표현식의 평가가 완료되지 않았으므로 피연산자들이 역순으로 드롭됩니다.
    (
        PrintOnDrop("바깥쪽 튜플 첫 번째"),
        PrintOnDrop("바깥쪽 튜플 두 번째"),
        (
            PrintOnDrop("안쪽 튜플 첫 번째"),
            PrintOnDrop("안쪽 튜플 두 번째"),
            break,
        ),
        PrintOnDrop("절대로 생성되지 않음"),
    );
}
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-destructors.scope.const-promotion"><a class="rule-link" href="#r-destructors.scope.const-promotion" title="destructors.scope.const-promotion"><span>[destructors<wbr>.scope<wbr>.const-promotion]<span/></a></div>
<h3 id="상수-승격"><a class="header" href="#상수-승격">상수 승격</a></h3>
<p>값 표현식을 <code>'static</code> 슬롯으로 승격시키는 것은, 해당 표현식을 상수로 작성하여 차용할 수 있고, 그 차용을 원래 표현식이 작성된 위치에서 런타임 동작의 변경 없이 역참조할 수 있을 때 발생합니다. 즉, 승격된 표현식은 컴파일 타임에 평가될 수 있어야 하며, 그 결과값은 <a href="interior-mutability.html">내부 가변성(interior mutability)</a>이나 <a href="destructors.html">소멸자(destructors)</a>를 포함하지 않아야 합니다 (이러한 속성들은 가능한 경우 값을 기반으로 결정됩니다. 예를 들어, <code>&amp;None</code>은 허용되지 않는 것을 아무것도 포함하지 않으므로 항상 <code>&amp;'static Option&lt;_&gt;</code> 타입을 가집니다).</p>
<div class="rule" id="r-destructors.scope.lifetime-extension"><a class="rule-link" href="#r-destructors.scope.lifetime-extension" title="destructors.scope.lifetime-extension"><span>[destructors<wbr>.scope<wbr>.lifetime-extension]<span/></a></div>
<h3 id="임시-라이프타임-확장"><a class="header" href="#임시-라이프타임-확장">임시 라이프타임 확장</a></h3>
<blockquote>
<p><strong>참고</strong>: 임시 라이프타임 확장의 정확한 규칙은 변경될 수 있습니다. 여기서는 현재의 동작만을 설명합니다.</p>
</blockquote>
<div class="rule" id="r-destructors.scope.lifetime-extension.let"><a class="rule-link" href="#r-destructors.scope.lifetime-extension.let" title="destructors.scope.lifetime-extension.let"><span>[destructors<wbr>.scope<wbr>.lifetime-extension<wbr>.let]<span/></a></div>
<p><code>let</code> 구문의 표현식에 대한 임시 스코프는 때때로 <code>let</code> 구문을 포함하는 블록의 스코프로 _확장(extended)_되기도 합니다. 이는 특정한 구문 규칙에 따라 일반적인 임시 스코프가 너무 작을 때 수행됩니다. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = &amp;mut 0;
// 보통이라면 임시 값은 지금쯤 드롭되었겠지만, `0`을 위한 임시 값은 블록 끝까지 유지됩니다.
println!("{}", x);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-destructors.scope.lifetime-extension.static"><a class="rule-link" href="#r-destructors.scope.lifetime-extension.static" title="destructors.scope.lifetime-extension.static"><span>[destructors<wbr>.scope<wbr>.lifetime-extension<wbr>.static]<span/></a></div>
<p>라이프타임 확장은 <code>static</code> 및 <code>const</code> 아이템에도 적용되어, 임시 값이 프로그램이 종료될 때까지 유지되게 합니다. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const C: &amp;Vec&lt;i32&gt; = &amp;Vec::new();
// 보통이라면 `Vec`은 `C`의 초기화식 내부에만 존재하므로 이는 댕글링 참조(dangling reference)가 되겠지만,
// 대신 차용(borrow)이 라이프타임 확장되어 사실상 `'static` 라이프타임을 갖게 됩니다.
println!("{:?}", C);
<span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-destructors.scope.lifetime-extension.sub-expressions"><a class="rule-link" href="#r-destructors.scope.lifetime-extension.sub-expressions" title="destructors.scope.lifetime-extension.sub-expressions"><span>[destructors<wbr>.scope<wbr>.lifetime-extension<wbr>.sub-expressions]<span/></a></div>
<p><a href="expressions/operator-expr.html#borrow-operators">차용(borrow)</a>, <a href="expressions/operator-expr.html#the-dereference-operator">역참조(dereference)</a>, <a href="expressions/field-expr.html">필드(field)</a>, 또는 <a href="expressions/tuple-expr.html#tuple-indexing-expressions">튜플 인덱싱 표현식(tuple indexing expression)</a>이 연장된 임시 스코프를 갖는다면 그 피연산자도 마찬가지입니다. 만약 <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">인덱싱 표현식(indexing expression)</a>이 연장된 임시 스코프를 갖는다면 인덱싱되는 표현식도 연장된 임시 스코프를 갖습니다.</p>
<div class="rule" id="r-destructors.scope.lifetime-extension.patterns"><a class="rule-link" href="#r-destructors.scope.lifetime-extension.patterns" title="destructors.scope.lifetime-extension.patterns"><span>[destructors<wbr>.scope<wbr>.lifetime-extension<wbr>.patterns]<span/></a></div>
<h4 id="패턴에-기반한-연장"><a class="header" href="#패턴에-기반한-연장">패턴에 기반한 연장</a></h4>
<div class="rule" id="r-destructors.scope.lifetime-extension.patterns.extending"><a class="rule-link" href="#r-destructors.scope.lifetime-extension.patterns.extending" title="destructors.scope.lifetime-extension.patterns.extending"><span>[destructors<wbr>.scope<wbr>.lifetime-extension<wbr>.patterns<wbr>.extending]<span/></a></div>
<p>_연장 패턴(extending pattern)_은 다음 중 하나입니다.</p>
<ul>
<li>참조 또는 가변 참조로 바인딩하는 <a href="patterns.html#identifier-patterns">식별자 패턴(identifier pattern)</a>.</li>
<li>직접적인 하위 패턴 중 적어도 하나가 연장 패턴인 <a href="patterns.html#struct-patterns">구조체(struct)</a>, <a href="patterns.html#tuple-patterns">튜플(tuple)</a>, <a href="patterns.html#tuple-struct-patterns">튜플 구조체(tuple struct)</a>, 또는 <a href="patterns.html#slice-patterns">슬라이스(slice)</a> 패턴.</li>
</ul>
<p>따라서 <code>ref x</code>, <code>V(ref x)</code>, <code>[ref x, y]</code>는 모두 연장 패턴이지만, <code>x</code>, <code>&amp;ref x</code>, <code>&amp;(ref x,)</code>는 그렇지 않습니다.</p>
<div class="rule" id="r-destructors.scope.lifetime-extension.patterns.let"><a class="rule-link" href="#r-destructors.scope.lifetime-extension.patterns.let" title="destructors.scope.lifetime-extension.patterns.let"><span>[destructors<wbr>.scope<wbr>.lifetime-extension<wbr>.patterns<wbr>.let]<span/></a></div>
<p><code>let</code> 구문의 패턴이 연장 패턴이면 초기화식 표현식의 임시 스코프가 연장됩니다.</p>
<div class="rule" id="r-destructors.scope.lifetime-extension.exprs"><a class="rule-link" href="#r-destructors.scope.lifetime-extension.exprs" title="destructors.scope.lifetime-extension.exprs"><span>[destructors<wbr>.scope<wbr>.lifetime-extension<wbr>.exprs]<span/></a></div>
<h4 id="표현식에-기반한-연장"><a class="header" href="#표현식에-기반한-연장">표현식에 기반한 연장</a></h4>
<p>초기화식이 있는 let 구문의 경우, _연장 표현식(extending expression)_은 다음 중 하나인 표현식입니다.</p>
<ul>
<li>초기화식 표현식.</li>
<li>연장 <a href="expressions/operator-expr.html#borrow-operators">차용 표현식(borrow expression)</a>의 피연산자.</li>
<li>연장 <a href="expressions/array-expr.html#array-expressions">배열(array)</a>, <a href="expressions/operator-expr.html#type-cast-expressions">캐스트(cast)</a>, <a href="expressions/struct-expr.html">중괄호 구조체(braced struct)</a>, 또는 <a href="expressions/tuple-expressions">튜플(tuple)</a> 표현식의 피연산자(들).</li>
<li>모든 연장 <a href="expressions/block-expr.html">블록 표현식(block expression)</a>의 최종 표현식.</li>
</ul>
<p>따라서 <code>&amp;mut 0</code>, <code>(&amp;1, &amp;mut 2)</code>, <code>Some { 0: &amp;mut 3 }</code>에 있는 차용 표현식은 모두 연장 표현식입니다. <code>&amp;0 + &amp;1</code>과 <code>Some(&amp;mut 0)</code>에 있는 차용은 연장 표현식이 아닙니다. 후자는 구문론적으로 함수 호출 표현식이기 때문입니다.</p>
<p>모든 연장 차용 표현식의 피연산자는 그 임시 스코프가 연장됩니다.</p>
<h4 id="예시"><a class="header" href="#예시">예시</a></h4>
<p>다음은 표현식이 연장된 임시 스코프를 갖는 몇 가지 예입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn temp() {}
</span><span class="boring">trait Use { fn use_temp(&amp;self) -&gt; &amp;Self { self } }
</span><span class="boring">impl Use for () {}
</span>// 이 경우 `temp()`의 결과를 저장하는 임시 값은
// x와 동일한 스코프 동안 유지됩니다.
let x = &amp;temp();
let x = &amp;temp() as &amp;dyn Send;
let x = (&amp;*&amp;temp(),);
let x = { [Some { 0: &amp;temp(), }] };
let ref x = temp();
let ref x = *&amp;temp();
<span class="boring">x;
</span><span class="boring">}</span></code></pre></pre>
<p>다음은 표현식이 연장된 임시 스코프를 갖지 않는 몇 가지 예입니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn temp() {}
</span><span class="boring">trait Use { fn use_temp(&amp;self) -&gt; &amp;Self { self } }
</span><span class="boring">impl Use for () {}
</span>// 이 경우 `temp()`의 결과를 저장하는 임시 값은
// let 구문이 끝날 때까지만 유지됩니다.

let x = Some(&amp;temp());         // 오류
let x = (&amp;temp()).use_temp();  // 오류
<span class="boring">x;
</span><span class="boring">}</span></code></pre></pre>
<div class="rule" id="r-destructors.forget"><a class="rule-link" href="#r-destructors.forget" title="destructors.forget"><span>[destructors<wbr>.forget]<span/></a></div>
<h2 id="소멸자를-실행하지-않는-경우"><a class="header" href="#소멸자를-실행하지-않는-경우">소멸자를 실행하지 않는 경우</a></h2>
<p><a href="../core/mem/fn.forget.html"><code>std::mem::forget</code></a>은 변수의 소멸자가 실행되는 것을 방지하기 위해 사용될 수 있으며, <a href="../core/mem/manually_drop/struct.ManuallyDrop.html"><code>std::mem::ManuallyDrop</code></a>은 변수나 필드가 자동으로 드롭되는 것을 방지하는 래퍼를 제공합니다.</p>
<blockquote>
<p>참고: <a href="../core/mem/fn.forget.html"><code>std::mem::forget</code></a> 또는 다른 수단을 통해 소멸자가 실행되는 것을 방지하는 것은 해당 타입이 <code>'static</code>이 아니더라도 안전합니다. 이 문서에서 정의된 소멸자 실행이 보장되는 장소들 외에, 타입들은 건전성(soundness)을 위해 소멸자가 실행되는 것에 안전하게 의존할 수 <em>없을</em> 수도 있습니다.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="type-coercions.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="lifetime-elision.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="type-coercions.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="lifetime-elision.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/reference.js"></script>
        <script src="theme/language-picker.js"></script>


    </div>
    </body>
</html>
