<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>클로저 타입 - The Rust Reference</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/reference";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/types/closure.md`;
                    } else {
                        canonical_href = `${base}/${lang}/types/closure.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/reference.css">
        <link rel="stylesheet" href="../theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/reference/edit/master/src/types/closure.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>r[type.closure]</p>
<h1 id="클로저-타입"><a class="header" href="#클로저-타입">클로저 타입</a></h1>
<p>r[type.closure.intro] A <a href="../expressions/closure-expr.html">closure expression</a> produces a closure value with a unique, anonymous type that cannot be written out. A closure type is approximately equivalent to a struct which contains the captured values. For instance, the following closure:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct Point { x: i32, y: i32 }
struct Rectangle { left_top: Point, right_bottom: Point }

fn f&lt;F : FnOnce() -&gt; String&gt; (g: F) {
    println!("{}", g());
}

let mut rect = Rectangle {
    left_top: Point { x: 1, y: 1 },
    right_bottom: Point { x: 0, y: 0 }
};

let c = || {
    rect.left_top.x += 1;
    rect.right_bottom.x += 1;
    format!("{:?}", rect.left_top)
};
f(c); // "Point { x: 2, y: 1 }"을 출력합니다.
<span class="boring">}</span></code></pre></pre>
<p>대략 다음과 같은 클로저 타입을 생성합니다:</p>
<!-- ignore: simplified -->
<pre><code class="language-rust ignore">// 참고: 이것은 실제 번역되는 방식과 정확히 일치하지 않으며, 단지 설명을 위한 것입니다.

struct Closure&lt;'a&gt; {
    left_top : &amp;'a mut Point,
    right_bottom_x : &amp;'a mut i32,
}

impl&lt;'a&gt; FnOnce&lt;()&gt; for Closure&lt;'a&gt; {
    type Output = String;
    extern "rust-call" fn call_once(self, args: ()) -&gt; String {
        self.left_top.x += 1;
        *self.right_bottom_x += 1;
        format!("{:?}", self.left_top)
    }
}</code></pre>
<p>그리하여 <code>f</code>에 대한 호출이 다음과 같이 작동하도록 합니다:</p>
<!-- ignore: continuation of above -->
<pre><code class="language-rust ignore">f(Closure{ left_top: &amp;mut rect.left_top, right_bottom_x: &amp;mut rect.right_bottom.x });</code></pre>
<p>r[type.closure.capture]</p>
<h2 id="캡처-모드"><a class="header" href="#캡처-모드">캡처 모드</a></h2>
<p>r[type.closure.capture.intro] A <em>capture mode</em> determines how a <a href="../expressions.html#place-expressions-and-value-expressions">place expression</a> from the environment is borrowed or moved into the closure. The capture modes are:</p>
<ol>
<li>불변 차용 (<code>ImmBorrow</code>) — 장소 표현식이 <a href="pointer.html#references--and-mut">공유 참조</a>로 캡처됩니다.</li>
<li>고유 불변 차용 (<code>UniqueImmBorrow</code>) — 이는 불변 차용과 유사하지만, <a href="#unique-immutable-borrows-in-captures">아래</a>에 설명된 대로 고유해야 합니다.</li>
<li>가변 차용 (<code>MutBorrow</code>) — 장소 표현식이 <a href="pointer.html#mutable-references-mut">가변 참조</a>로 캡처됩니다.</li>
<li>이동 (<code>ByValue</code>) — <a href="../expressions.html#moved-and-copied-types">값을 이동</a>시켜서 장소 표현식을 캡처합니다.</li>
</ol>
<p>r[type.closure.capture.precedence] Place expressions from the environment are captured from the first mode that is compatible with how the captured value is used inside the closure body. The mode is not affected by the code surrounding the closure, such as the lifetimes of involved variables or fields, or of the closure itself.</p>
<p>r[type.closure.capture.copy]</p>
<h3 id="copy-값"><a class="header" href="#copy-값"><code>Copy</code> 값</a></h3>
<p>클로저 내부로 이동된 <a href="../special-types-and-traits.html#copy"><code>Copy</code></a>를 구현하는 값은 <code>ImmBorrow</code> 모드로 캡처됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = [0; 1024];
let c = || {
    let y = x; // x는 ImmBorrow로 캡처됨
};
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.async.input]</p>
<h3 id="비동기-입력-캡처"><a class="header" href="#비동기-입력-캡처">비동기 입력 캡처</a></h3>
<p>비동기 클로저는 본문에서 사용되는지 여부에 관계없이 항상 모든 입력 인자를 캡처합니다.</p>
<h2 id="capture-precision"><a class="header" href="#capture-precision">Capture precision</a></h2>
<p>r[type.closure.capture.precision.capture-path] A <em>capture path</em> is a sequence starting with a variable from the environment followed by zero or more place projections from that variable.</p>
<p>r[type.closure.capture.precision.place-projection] A <em>place projection</em> is a <a href="../expressions/field-expr.html">field access</a>, <a href="../expressions/tuple-expr.html#tuple-indexing-expressions">tuple index</a>, <a href="../expressions/operator-expr.html#the-dereference-operator">dereference</a> (and automatic dereferences), <a href="../expressions/array-expr.html#array-and-slice-indexing-expressions">array or slice index</a> expression, or <a href="patterns.destructure">pattern destructuring</a> applied to a variable.</p>
<blockquote>
<p>[!NOTE] In <code>rustc</code>, pattern destructuring desugars into a series of dereferences and field or element accesses.</p>
</blockquote>
<p>r[type.closure.capture.precision.intro] The closure borrows or moves the capture path, which may be truncated based on the rules described below.</p>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SomeStruct {
    f1: (i32, i32),
}
let s = SomeStruct { f1: (1, 2) };

let c = || {
    let x = s.f1.1; // s.f1.1은 ImmBorrow로 캡처됨
};
c();
<span class="boring">}</span></code></pre></pre>
<p>여기서 캡처 경로는 로컬 변수 <code>s</code>, 필드 접근 <code>.f1</code>, 그리고 튜플 인덱스 <code>.1</code>로 이어집니다. 이 클로저는 <code>s.f1.1</code>의 불변 차용을 캡처합니다.</p>
<p>r[type.closure.capture.precision.shared-prefix]</p>
<h3 id="공유-접두어"><a class="header" href="#공유-접두어">공유 접두어</a></h3>
<p>In the case where a capture path and one of the ancestors of that path are both captured by a closure, the ancestor path is captured with the highest capture mode among the two captures, <code>CaptureMode = max(AncestorCaptureMode, DescendantCaptureMode)</code>, using the strict weak ordering:</p>
<p><code>ImmBorrow &lt; UniqueImmBorrow &lt; MutBorrow &lt; ByValue</code></p>
<p>이는 재귀적으로 적용되어야 할 수도 있음에 유의하십시오.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 이 예시에서, 공유된 조상을 가진 세 가지 서로 다른 캡처 경로가 있습니다:
<span class="boring">fn move_value&lt;T&gt;(_: T){}
</span>let s = String::from("S");
let t = (s, String::from("T"));
let mut u = (t, String::from("U"));

let c = || {
    println!("{:?}", u); // u는 ImmBorrow로 캡처됨
    u.1.truncate(0); // u.0은 MutBorrow로 캡처됨
    move_value(u.0.0); // u.0.0은 ByValue로 캡처됨
};
c();
<span class="boring">}</span></code></pre></pre>
<p>전체적으로 이 클로저는 <code>u</code>를 <code>ByValue</code>로 캡처하게 됩니다.</p>
<p>r[type.closure.capture.precision.dereference-shared]</p>
<h3 id="가장-오른쪽-공유-참조-자르기"><a class="header" href="#가장-오른쪽-공유-참조-자르기">가장 오른쪽 공유 참조 자르기</a></h3>
<p>공유 참조에 대해 역참조가 적용되는 경우, 캡처 경로는 가장 오른쪽 역참조 지점에서 잘립니다.</p>
<p>이러한 자르기가 허용되는 이유는 공유 참조를 통해 읽는 필드는 항상 공유 참조나 복사를 통해 읽히기 때문입니다. 이는 추가적인 정밀도가 차용 검사 관점에서 아무런 이득을 주지 않을 때 캡처 크기를 줄이는 데 도움이 됩니다.</p>
<p><em>가장 오른쪽</em> 역참조인 이유는 필요 이상으로 짧은 라이프타임을 피하기 위해서입니다. 다음 예시를 보십시오:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Int(i32);
struct B&lt;'a&gt;(&amp;'a i32);

struct MyStruct&lt;'a&gt; {
   a: &amp;'static Int,
   b: B&lt;'a&gt;,
}

fn foo&lt;'a, 'b&gt;(m: &amp;'a MyStruct&lt;'b&gt;) -&gt; impl FnMut() + 'static {
    let c = || drop(&amp;m.a.0);
    c
}
<span class="boring">}</span></code></pre></pre>
<p>만약 이것이 <code>m</code>을 캡처한다면, <code>m</code>은 <code>'a</code>로 제한되어 있으므로 클로저는 더 이상 <code>'static</code>보다 오래 살 수 없게 됩니다. 대신, <code>(*(*m).a)</code>를 <code>ImmBorrow</code>로 캡처합니다.</p>
<p>r[type.closure.capture.precision.wildcard]</p>
<h3 id="와일드카드-패턴-바인딩"><a class="header" href="#와일드카드-패턴-바인딩">와일드카드 패턴 바인딩</a></h3>
<p>r[type.closure.capture.precision.wildcard.reads] Closures only capture data that needs to be read. Binding a value with a <a href="../patterns.html#wildcard-pattern">wildcard pattern</a> does not read the value, so the place is not captured.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S; // A non-`Copy` type.
let x = S;
let c = || {
    let _ = x;  // Does not capture `x`.
};
let c = || match x {
    _ =&gt; (), // Does not capture `x`.
};
x; // OK: `x` can be moved here.
c();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.wildcard.destructuring] Destructuring tuples, structs, and single-variant enums does not, by itself, cause a read or the place to be captured.</p>
<blockquote>
<p>[!NOTE] Enums marked with [<code>#[non_exhaustive]</code>][attributes.type-system.non_exhaustive] from other crates are always treated as having multiple variants. See <em>[type.closure.capture.precision.discriminants.non_exhaustive]</em>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S; // A non-`Copy` type.

// Destructuring tuples does not cause a read or capture.
let x = (S,);
let c = || {
    let (..) = x; // Does not capture `x`.
};
x; // OK: `x` can be moved here.
c();

// Destructuring unit structs does not cause a read or capture.
let x = S;
let c = || {
    let S = x; // Does not capture `x`.
};
x; // OK: `x` can be moved here.
c();

// Destructuring structs does not cause a read or capture.
struct W&lt;T&gt;(T);
let x = W(S);
let c = || {
    let W(..) = x; // Does not capture `x`.
};
x; // OK: `x` can be moved here.
c();

// Destructuring single-variant enums does not cause a read
// or capture.
enum E&lt;T&gt; { V(T) }
let x = E::V(S);
let c = || {
    let E::V(..) = x; // Does not capture `x`.
};
x; // OK: `x` can be moved here.
c();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.wildcard.fields] Fields matched against [RestPattern] (<code>..</code>) or [StructPatternEtCetera] (also <code>..</code>) are not read, and those fields are not captured.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S; // A non-`Copy` type.
let x = (S, S);
let c = || {
    let (x0, ..) = x;  // Captures `x.0` by `ByValue`.
};
// Only the first tuple field was captured by the closure.
x.1; // OK: `x.1` can be moved here.
c();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.wildcard.array-slice] Partial captures of arrays and slices are not supported; the entire slice or array is always captured even if used with wildcard pattern matching, indexing, or sub-slicing.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0382 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S; // A non-`Copy` type.
let mut x = [S, S];
let c = || {
    let [x0, _] = x; // Captures all of `x` by `ByValue`.
};
let _ = &amp;mut x[1]; // ERROR: Borrow of moved value.
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.wildcard.initialized] Values that are matched with wildcards must still be initialized.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0381 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: u8;
let c = || {
    let _ = x; // ERROR: Binding `x` isn't initialized.
};
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.discriminants]</p>
<h3 id="capturing-for-discriminant-reads"><a class="header" href="#capturing-for-discriminant-reads">Capturing for discriminant reads</a></h3>
<p>r[type.closure.capture.precision.discriminants.reads] If pattern matching reads a discriminant, the place containing that discriminant is captured by <code>ImmBorrow</code>.</p>
<p>r[type.closure.capture.precision.discriminants.multiple-variant] Matching against a variant of an enum that has more than one variant reads the discriminant, capturing the place by <code>ImmBorrow</code>.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0502 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S; // A non-`Copy` type.
let mut x = (Some(S), S);
let c = || match x {
    (None, _) =&gt; (),
//   ^^^^
// This pattern requires reading the discriminant, which
// causes `x.0` to be captured by `ImmBorrow`.
    _ =&gt; (),
};
let _ = &amp;mut x.0; // ERROR: Cannot borrow `x.0` as mutable.
//           ^^^
// The closure is still live, so `x.0` is still immutably
// borrowed here.
c();
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct S; // A non-`Copy` type.
</span><span class="boring">let x = (Some(S), S);
</span>let c = || match x { // Captures `x.0` by `ImmBorrow`.
    (None, _) =&gt; (),
    _ =&gt; (),
};
// Though `x.0` is captured due to the discriminant read,
// `x.1` is not captured.
x.1; // OK: `x.1` can be moved here.
c();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.discriminants.single-variant] Matching against the only variant of a single-variant enum does not read the discriminant and does not capture the place.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum E&lt;T&gt; { V(T) } // A single-variant enum.
let x = E::V(());
let c = || {
    let E::V(_) = x; // Does not capture `x`.
};
x; // OK: `x` can be moved here.
c();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.discriminants.non_exhaustive] If [<code>#[non_exhaustive]</code>][attributes.type-system.non_exhaustive] is applied to an enum defined in an external crate, the enum is treated as having multiple variants for the purpose of deciding whether a read occurs, even if it actually has only one variant.</p>
<p>r[type.closure.capture.precision.discriminants.uninhabited-variants] Even if all variants but the one being matched against are uninhabited, making the pattern [irrefutable][patterns.refutable], the discriminant is still read if it otherwise would be.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0502 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Empty {}
let mut x = Ok::&lt;_, Empty&gt;(42);
let c = || {
    let Ok(_) = x; // Captures `x` by `ImmBorrow`.
};
let _ = &amp;mut x; // ERROR: Cannot borrow `x` as mutable.
c();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.range-patterns]</p>
<h3 id="capturing-and-range-patterns"><a class="header" href="#capturing-and-range-patterns">Capturing and range patterns</a></h3>
<p>r[type.closure.capture.precision.range-patterns.reads] Matching against a [range pattern][patterns.range] reads the place being matched, even if the range includes all possible values of the type, and captures the place by <code>ImmBorrow</code>.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0502 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 0u8;
let c = || {
    let 0..=u8::MAX = x; // Captures `x` by `ImmBorrow`.
};
let _ = &amp;mut x; // ERROR: Cannot borrow `x` as mutable.
c();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.slice-patterns]</p>
<h3 id="capturing-and-slice-patterns"><a class="header" href="#capturing-and-slice-patterns">Capturing and slice patterns</a></h3>
<p>r[type.closure.capture.precision.slice-patterns.slices] Matching a slice against a [slice pattern][patterns.slice] other than one with only a single [rest pattern][patterns.rest] (i.e. <code>[..]</code>) is treated as a read of the length from the slice and captures the slice by <code>ImmBorrow</code>.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0502 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: &amp;mut [u8] = &amp;mut [];
let c = || match x { // Captures `*x` by `ImmBorrow`.
    &amp;mut [] =&gt; (),
//       ^^
// This matches a slice of exactly zero elements. To know whether the
// scrutinee matches, the length must be read, causing the slice to
// be captured.
    _ =&gt; (),
};
let _ = &amp;mut *x; // ERROR: Cannot borrow `*x` as mutable.
c();
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: &amp;mut [u8] = &amp;mut [];
let c = || match x { // Does not capture `*x`.
    [..] =&gt; (),
//   ^^ Rest pattern.
};
let _ = &amp;mut *x; // OK: `*x` can be borrow here.
c();
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] Perhaps surprisingly, even though the length is contained in the (wide) <em>pointer</em> to the slice, it is the place of the <em>pointee</em> (the slice) that is treated as read and is captured.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;'l: 's, 's&gt;(x: &amp;'s mut &amp;'l [u8]) -&gt; impl Fn() + 'l {
    // The closure outlives `'l` because it captures `**x`. If
    // instead it captured `*x`, it would not live long enough
    // to satisfy the `impl Fn() + 'l` bound.
    || match *x { // Captures `**x` by `ImmBorrow`.
        &amp;[] =&gt; (),
        _ =&gt; (),
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In this way, the behavior is consistent with dereferencing to the slice in the scrutinee.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;'l: 's, 's&gt;(x: &amp;'s mut &amp;'l [u8]) -&gt; impl Fn() + 'l {
    || match **x { // Captures `**x` by `ImmBorrow`.
        [] =&gt; (),
        _ =&gt; (),
    }
}
<span class="boring">}</span></code></pre></pre>
<p>For details, see <a href="https://github.com/rust-lang/rust/pull/138961">Rust PR #138961</a>.</p>
</blockquote>
<p>r[type.closure.capture.precision.slice-patterns.arrays] As the length of an array is fixed by its type, matching an array against a slice pattern does not by itself capture the place.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: [u8; 1] = [0];
let c = || match x { // Does not capture `x`.
    [_] =&gt; (), // Length is fixed.
};
x; // OK: `x` can be moved here.
c();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.move-dereference]</p>
<h3 id="이동-컨텍스트에서의-참조-캡처"><a class="header" href="#이동-컨텍스트에서의-참조-캡처">이동 컨텍스트에서의 참조 캡처</a></h3>
<p>참조에서 필드를 끄집어내어 이동하는 것은 허용되지 않으므로, <code>move</code> 클로저는 참조의 첫 번째 역참조 전까지의 캡처 경로 접두어만 캡처합니다. 참조 자체는 클로저 내부로 이동됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct T(String, String);

let mut t = T(String::from("foo"), String::from("bar"));
let t_mut_ref = &amp;mut t;
let mut c = move || {
    t_mut_ref.0.push_str("123"); // `t_mut_ref`를 ByValue로 캡처함
};
c();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.raw-pointer-dereference]</p>
<h3 id="원시-포인터-역참조"><a class="header" href="#원시-포인터-역참조">원시 포인터 역참조</a></h3>
<p>원시 포인터를 역참조하는 것은 <code>unsafe</code>하므로, 클로저는 원시 포인터의 첫 번째 역참조 전까지의 캡처 경로 접두어만 캡처합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct T(String, String);

let t = T(String::from("foo"), String::from("bar"));
let t_ptr = &amp;t as *const T;

let c = || unsafe {
    println!("{}", (*t_ptr).0); // `t_ptr`을 ImmBorrow로 캡처함
};
c();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.union]</p>
<h3 id="공용체-필드"><a class="header" href="#공용체-필드">공용체 필드</a></h3>
<p>공용체 필드에 접근하는 것은 <code>unsafe</code>하므로, 클로저는 공용체 자체까지만의 캡처 경로 접두어를 캡처합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>union U {
    a: (i32, i32),
    b: bool,
}
let u = U { a: (123, 456) };

let c = || {
    let x = unsafe { u.a.0 }; // `u`를 ByValue로 캡처함
};
c();

// 이는 필드에 쓰는 경우도 포함합니다.
let mut u = U { a: (123, 456) };

let mut c = || {
    u.b = true; // `u`를 MutBorrow로 캡처함
};
c();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.unaligned]</p>
<h3 id="정렬되지-않은-struct로의-참조"><a class="header" href="#정렬되지-않은-struct로의-참조">정렬되지 않은 <code>struct</code>로의 참조</a></h3>
<p>Because it is <a href="../behavior-considered-undefined.html">undefined behavior</a> to create references to unaligned fields in a structure, closures will only capture the prefix of the capture path that runs up to, but not including, the first field access into a structure that uses <a href="../type-layout.html#the-alignment-modifiers">the <code>packed</code> representation</a>. This includes all fields, even those that are aligned, to protect against compatibility concerns should any of the fields in the structure change in the future.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(packed)]
struct T(i32, i32);

let t = T(2, 5);
let c = || {
    let a = t.0; // `t`를 ImmBorrow로 캡처함
};
// `t`에서 복사하는 것은 괜찮습니다.
let (a, b) = (t.0, t.1);
c();
<span class="boring">}</span></code></pre></pre>
<p>마찬가지로, 정렬되지 않은 필드의 주소를 취하는 것도 구조체 전체를 캡처합니다:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0505 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(packed)]
struct T(String, String);

let mut t = T(String::new(), String::new());
let c = || {
    let a = std::ptr::addr_of!(t.1); // `t`를 ImmBorrow로 캡처함
};
let a = t.0; // ERROR: `t.0`이 차용되었으므로 이동할 수 없음
c();
<span class="boring">}</span></code></pre></pre>
<p>하지만 packed가 아니라면 필드를 정밀하게 캡처하므로 위 코드가 작동합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct T(String, String);

let mut t = T(String::new(), String::new());
let c = || {
    let a = std::ptr::addr_of!(t.1); // `t.1`을 ImmBorrow로 캡처함
};
// 여기서의 이동은 허용됩니다.
let a = t.0;
c();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.box-deref]</p>
<h3 id="box-대-다른-deref-구현체"><a class="header" href="#box-대-다른-deref-구현체"><code>Box</code> 대 다른 <code>Deref</code> 구현체</a></h3>
<p><code>Box</code>에 대한 <a href="../special-types-and-traits.html#deref-and-derefmut"><code>Deref</code></a> 트레잇 구현은 특별한 엔티티로 간주되어 다른 <code>Deref</code> 구현과 다르게 취급됩니다.</p>
<p>예를 들어, <code>Rc</code>와 <code>Box</code>가 포함된 예시를 보겠습니다. <code>*rc</code>는 <code>Rc</code>에 정의된 트레잇 메서드 <code>deref</code>의 호출로 디슈거링(desugar)되지만, <code>*box</code>는 다르게 취급되므로 <code>Box</code> 내부 콘텐츠의 정밀한 캡처가 가능합니다.</p>
<p>r[type.closure.capture.precision.box-non-move.not-moved]</p>
<h4 id="non-move-클로저에서의-box"><a class="header" href="#non-move-클로저에서의-box">non-<code>move</code> 클로저에서의 <code>Box</code></a></h4>
<p>non-<code>move</code> 클로저에서 <code>Box</code>의 내용물이 클로저 본문으로 이동되지 않는다면, <code>Box</code>의 내용물은 정밀하게 캡처됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S(String);

let b = Box::new(S(String::new()));
let c_box = || {
    let x = &amp;(*b).0; // `(*b).0`을 ImmBorrow로 캡처함
};
c_box();

// `Box`를 Deref를 구현하는 다른 타입과 비교해 보십시오:
let r = std::rc::Rc::new(S(String::new()));
let c_rc = || {
    let x = &amp;(*r).0; // `r`을 ImmBorrow로 캡처함
};
c_rc();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.box-non-move.moved] However, if the contents of the <code>Box</code> are moved into the closure, then the box is entirely captured. This is done so the amount of data that needs to be moved into the closure is minimized.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 클로저가 참조를 취하는 대신 값을 이동시킨다는 점을 제외하면 위 예시와 동일합니다.

struct S(String);

let b = Box::new(S(String::new()));
let c_box = || {
    let x = (*b).0; // `b`를 ByValue로 캡처함
};
c_box();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.box-move.read]</p>
<h4 id="move-클로저에서의-box"><a class="header" href="#move-클로저에서의-box"><code>move</code> 클로저에서의 <code>Box</code></a></h4>
<p>non-<code>move</code> 클로저에서 <code>Box</code>의 내용을 이동시키는 것과 유사하게, <code>move</code> 클로저에서 <code>Box</code>의 내용을 읽는 것은 <code>Box</code> 전체를 캡처하게 됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S(i32);

let b = Box::new(S(10));
let c_box = move || {
    let x = (*b).0; // `b`를 ByValue로 캡처함
};
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.unique-immutable]</p>
<h2 id="캡처에서의-고유-불변-차용"><a class="header" href="#캡처에서의-고유-불변-차용">캡처에서의 고유 불변 차용</a></h2>
<p>캡처는 _고유 불변 차용(unique immutable borrow)_이라고 불리는 특수한 종류의 차용을 통해 발생할 수 있습니다. 이는 언어의 다른 어디에서도 사용될 수 없으며 명시적으로 작성할 수도 없습니다. 다음 예시와 같이 가변 참조의 대상(referent)을 수정할 때 발생합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut b = false;
let x = &amp;mut b;
let mut c = || {
    // `x`의 ImmBorrow 및 MutBorrow.
    let a = &amp;x;
    *x = true; // `x`는 UniqueImmBorrow로 캡처됨
};
// 다음 줄은 오류입니다:
// let y = &amp;x;
c();
// 그러나 다음은 괜찮습니다.
let z = &amp;x;
<span class="boring">}</span></code></pre></pre>
<p>In this case, borrowing <code>x</code> mutably is not possible, because <code>x</code> is not <code>mut</code>. But at the same time, borrowing <code>x</code> immutably would make the assignment illegal, because a <code>&amp; &amp;mut</code> reference might not be unique, so it cannot safely be used to modify a value. So a unique immutable borrow is used: it borrows <code>x</code> immutably, but like a mutable borrow, it must be unique.</p>
<p>위의 예시에서 <code>y</code>의 선언을 주석 해제하면 클로저의 <code>x</code> 차용에 대한 고유성을 위반하므로 오류가 발생합니다. z의 선언은 블록 끝에서 클로저의 라이프타임이 만료되어 차용이 해제되었으므로 유효합니다.</p>
<p>r[type.closure.call]</p>
<h2 id="호출-트레잇-및-강제-변환"><a class="header" href="#호출-트레잇-및-강제-변환">호출 트레잇 및 강제 변환</a></h2>
<p>r[type.closure.call.intro] Closure types all implement [<code>FnOnce</code>], indicating that they can be called once by consuming ownership of the closure. Additionally, some closures implement more specific call traits:</p>
<p>r[type.closure.call.fn-mut]</p>
<ul>
<li>A closure which does not move out of any captured variables implements [<code>FnMut</code>], indicating that it can be called by mutable reference.</li>
</ul>
<p>r[type.closure.call.fn]</p>
<ul>
<li>A closure which does not mutate or move out of any captured variables implements [<code>Fn</code>], indicating that it can be called by shared reference.</li>
</ul>
<blockquote>
<p>[!NOTE] <code>move</code> closures may still implement [<code>Fn</code>] or [<code>FnMut</code>], even though they capture variables by move. This is because the traits implemented by a closure type are determined by what the closure does with captured values, not how it captures them.</p>
</blockquote>
<p>r[type.closure.non-capturing] <em>Non-capturing closures</em> are closures that don’t capture anything from their environment. Non-async, non-capturing closures can be coerced to function pointers (e.g., <code>fn()</code>) with the matching signature.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let add = |x, y| x + y;

let mut x = add(5,7);

type Binop = fn(i32, i32) -&gt; i32;
let bo: Binop = add;
x = bo(5,7);
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.async.traits]</p>
<h3 id="비동기-클로저-트레잇"><a class="header" href="#비동기-클로저-트레잇">비동기 클로저 트레잇</a></h3>
<p>r[type.closure.async.traits.fn-family] Async closures have a further restriction of whether or not they implement [<code>FnMut</code>] or [<code>Fn</code>].</p>
<p>The [<code>Future</code>] returned by the async closure has similar capturing characteristics as a closure. It captures place expressions from the async closure based on how they are used. The async closure is said to be <em>lending</em> to its [<code>Future</code>] if it has either of the following properties:</p>
<ul>
<li><code>Future</code>가 가변 캡처를 포함하는 경우.</li>
<li>비동기 클로저가 값으로 캡처하는 경우 (단, 역참조 투영을 통해 값에 접근하는 경우는 제외).</li>
</ul>
<p>If the async closure is lending to its <code>Future</code>, then [<code>FnMut</code>] and [<code>Fn</code>] are <em>not</em> implemented. [<code>FnOnce</code>] is always implemented.</p>
<blockquote>
<p><strong>예시</strong>: 가변 캡처에 대한 첫 번째 조건은 다음과 같이 설명될 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn takes_callback&lt;Fut: Future&gt;(c: impl FnMut() -&gt; Fut) {}

fn f() {
    let mut x = 1i32;
    let c = async || {
        x = 2;  // x는 MutBorrow로 캡처됨
    };
    takes_callback(c);  // ERROR: 비동기 클로저가 `FnMut`를 구현하지 않음
}
<span class="boring">}</span></code></pre></pre>
<p>일반 값 캡처에 대한 두 번째 조건은 다음과 같이 설명될 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn takes_callback&lt;Fut: Future&gt;(c: impl Fn() -&gt; Fut) {}

fn f() {
    let x = &amp;1i32;
    let c = async move || {
        let a = x + 2;  // x는 ByValue로 캡처됨
    };
    takes_callback(c);  // ERROR: 비동기 클로저가 `Fn`을 구현하지 않음
}
<span class="boring">}</span></code></pre></pre>
<p>두 번째 조건의 예외는 역참조를 사용하여 설명될 수 있으며, 이 경우 <code>Fn</code> 및 <code>FnMut</code> 구현이 허용됩니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn takes_callback&lt;Fut: Future&gt;(c: impl Fn() -&gt; Fut) {}

fn f() {
    let x = &amp;1i32;
    let c = async move || {
        let a = *x + 2;
    };
    takes_callback(c);  // OK: `Fn`을 구현함
}
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[type.closure.async.traits.async-family] Async closures implement [<code>AsyncFn</code>], [<code>AsyncFnMut</code>], and [<code>AsyncFnOnce</code>] in an analogous way as regular closures implement [<code>Fn</code>], [<code>FnMut</code>], and [<code>FnOnce</code>]; that is, depending on the use of the captured variables in its body.</p>
<p>r[type.closure.traits]</p>
<h3 id="기타-트레잇"><a class="header" href="#기타-트레잇">기타 트레잇</a></h3>
<p>r[type.closure.traits.intro] All closure types implement <a href="../special-types-and-traits.html#sized"><code>Sized</code></a>. Additionally, closure types implement the following traits if allowed to do so by the types of the captures it stores:</p>
<ul>
<li><a href="../special-types-and-traits.html#clone"><code>Clone</code></a></li>
<li><a href="../special-types-and-traits.html#copy"><code>Copy</code></a></li>
<li><a href="../special-types-and-traits.html#sync"><code>Sync</code></a></li>
<li><a href="../special-types-and-traits.html#send"><code>Send</code></a></li>
</ul>
<p>r[type.closure.traits.behavior] The rules for <a href="../special-types-and-traits.html#send"><code>Send</code></a> and <a href="../special-types-and-traits.html#sync"><code>Sync</code></a> match those for normal struct types, while <a href="../special-types-and-traits.html#clone"><code>Clone</code></a> and <a href="../special-types-and-traits.html#copy"><code>Copy</code></a> behave as if <a href="../attributes/derive.html">derived</a>. For <a href="../special-types-and-traits.html#clone"><code>Clone</code></a>, the order of cloning of the captured values is left unspecified.</p>
<p>캡처는 종종 참조에 의해 발생하므로 다음과 같은 일반적인 규칙이 나타납니다:</p>
<ul>
<li>모든 캡처된 값이 <a href="../special-types-and-traits.html#sync"><code>Sync</code></a>이면 클로저는 <a href="../special-types-and-traits.html#sync"><code>Sync</code></a>입니다.</li>
<li>비고유 불변 참조로 캡처된 모든 값이 <a href="../special-types-and-traits.html#sync"><code>Sync</code></a>이고, 고유 불변 참조나 가변 참조, 복사 또는 이동으로 캡처된 모든 값이 <a href="../special-types-and-traits.html#send"><code>Send</code></a>이면 클로저는 <a href="../special-types-and-traits.html#send"><code>Send</code></a>입니다.</li>
<li>클로저가 고유 불변 참조나 가변 참조로 값을 캡처하지 않고, 복사나 이동으로 캡처하는 모든 값이 각각 <a href="../special-types-and-traits.html#clone"><code>Clone</code></a> 또는 <a href="../special-types-and-traits.html#copy"><code>Copy</code></a>이면 클로저는 <a href="../special-types-and-traits.html#clone"><code>Clone</code></a> 또는 <a href="../special-types-and-traits.html#copy"><code>Copy</code></a>입니다.</li>
</ul>
<p>r[type.closure.drop-order]</p>
<h2 id="drop-order"><a class="header" href="#drop-order">Drop order</a></h2>
<p>클로저가 구조체, 튜플, 열거형과 같은 복합 타입의 필드를 값으로 캡처하면, 해당 필드의 라이프타임은 이제 클로저에 묶이게 됩니다. 결과적으로 복합 타입의 서로 다른 필드들이 서로 다른 시점에 드롭될 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let tuple =
      (String::from("foo"), String::from("bar")); // --+
    { //                                               |
        let c = || { // ----------------------------+  |
            // tuple.0은 클로저 내부로 캡처됨 |  |
            drop(tuple.0); //                       |  |
        }; //                                       |  |
    } // 'c'와 'tuple.0'이 여기서 드롭됨 ------------+  |
} // tuple.1이 여기서 드롭됨 -----------------------------+
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.edition2018.entirety]</p>
<h2 id="2018-에디션-및-이전"><a class="header" href="#2018-에디션-및-이전">2018 에디션 및 이전</a></h2>
<h3 id="클로저-타입의-차이점"><a class="header" href="#클로저-타입의-차이점">클로저 타입의 차이점</a></h3>
<p>2018 에디션 및 이전 버전에서, 클로저는 항상 변수 전체를 캡처하며 정밀한 캡처 경로를 사용하지 않습니다. 이는 <a href="#closure-types">클로저 타입</a> 섹션에서 사용된 예시의 경우, 생성된 클로저 타입이 대신 다음과 같은 모습이 됨을 의미합니다:</p>
<!-- ignore: simplified -->
<pre><code class="language-rust ignore">struct Closure&lt;'a&gt; {
    rect : &amp;'a mut Rectangle,
}

impl&lt;'a&gt; FnOnce&lt;()&gt; for Closure&lt;'a&gt; {
    type Output = String;
    extern "rust-call" fn call_once(self, args: ()) -&gt; String {
        self.rect.left_top.x += 1;
        self.rect.right_bottom.x += 1;
        format!("{:?}", self.rect.left_top)
    }
}</code></pre>
<p>그리고 <code>f</code>에 대한 호출은 다음과 같이 작동합니다:</p>
<!-- ignore: continuation of above -->
<pre><code class="language-rust ignore">f(Closure { rect: rect });</code></pre>
<p>r[type.closure.capture.precision.edition2018.composite]</p>
<h3 id="캡처-정밀도의-차이"><a class="header" href="#캡처-정밀도의-차이">캡처 정밀도의 차이</a></h3>
<p>구조체, 튜플, 열거형과 같은 복합 타입은 개별 필드가 아니라 항상 전체가 캡처됩니다. 결과적으로, 단일 필드만 캡처하려면 로컬 변수로 차용해야 할 수도 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">
</span>struct SetVec {
    set: HashSet&lt;u32&gt;,
    vec: Vec&lt;u32&gt;
}

impl SetVec {
    fn populate(&amp;mut self) {
        let vec = &amp;mut self.vec;
        self.set.iter().for_each(|&amp;n| {
            vec.push(n);
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<p>만약 클로저가 <code>self.vec</code>을 직접 사용했다면 <code>self</code>를 가변 참조로 캡처하려고 시도했을 것입니다. 하지만 <code>self.set</code>이 이미 반복을 위해 차용된 상태이므로 코드가 컴파일되지 않았을 것입니다.</p>
<p>r[type.closure.capture.precision.edition2018.move] If the <code>move</code> keyword is used, then all captures are by move or, for <code>Copy</code> types, by copy, regardless of whether a borrow would work. The <code>move</code> keyword is usually used to allow the closure to outlive the captured values, such as if the closure is being returned or used to spawn a new thread.</p>
<p>r[type.closure.capture.precision.edition2018.wildcard] Regardless of if the data will be read by the closure, i.e. in case of wild card patterns, if a variable defined outside the closure is mentioned within the closure the variable will be captured in its entirety.</p>
<p>r[type.closure.capture.precision.edition2018.drop-order]</p>
<h3 id="드롭-순서의-차이"><a class="header" href="#드롭-순서의-차이">드롭 순서의 차이</a></h3>
<p>복합 타입은 전체가 캡처되므로, 이러한 복합 타입 중 하나를 값으로 캡처하는 클로저는 클로저가 드롭될 때 캡처된 변수 전체를 동시에 드롭합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let tuple =
      (String::from("foo"), String::from("bar"));
    {
        let c = || { // --------------------------+
            // tuple은 클로저 내부로 캡처됨 |
// --------------------------+
            // tuple은 클로저 내부로 캡처됨 |
            drop(tuple.0); //                     |
        }; //                                     |
    } // 'c'와 'tuple'이 여기서 드롭됨 ------------+
}
<span class="boring">}</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../types/function-item.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../types/pointer.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../types/function-item.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../types/pointer.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/reference.js"></script>
        <script src="../theme/language-picker.js"></script>


    </div>
    </body>
</html>
