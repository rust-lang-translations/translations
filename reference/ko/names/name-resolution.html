<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>이름 확인 - The Rust Reference</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/reference";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/names/name-resolution.md`;
                    } else {
                        canonical_href = `${base}/${lang}/names/name-resolution.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/reference.css">
        <link rel="stylesheet" href="../theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/reference/edit/master/src/names/name-resolution.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>r[names.resolution]</p>
<h1 id="이름-확인"><a class="header" href="#이름-확인">이름 확인</a></h1>
<p>r[names.resolution.intro] <em>Name resolution</em> is the process of tying paths and other identifiers to the declarations of those entities. Names are segregated into different <a href="../names/namespaces.html">namespaces</a>, allowing entities in different namespaces to share the same name without conflict. Each name is valid within a <a href="../names/scopes.html">scope</a>, or a region of source text where that name may be referenced. Access to a name may be restricted based on its <a href="../visibility-and-privacy.html">visibility</a>.</p>
<p>Name resolution is split into three stages throughout the compilation process. The first stage, <em>expansion-time resolution</em>, resolves all <a href="../items/use-declarations.html"><code>use</code> declarations</a> and <a href="../macros.html#macro-invocation">macro invocations</a>. The second stage, <em>primary resolution</em>, resolves all names that have not yet been resolved and that do not depend on type information to resolve. The last stage, <em>type-relative resolution</em>, resolves the remaining names once type information is available.</p>
<blockquote>
<p>[!NOTE] Expansion-time resolution is also known as <em>early resolution</em>. Primary resolution is also known as <em>late resolution</em>.</p>
</blockquote>
<p>r[names.resolution.general]</p>
<h2 id="general"><a class="header" href="#general">General</a></h2>
<p>r[names.resolution.general.intro] The rules within this section apply to all stages of name resolution.</p>
<p>r[names.resolution.general.scopes]</p>
<h3 id="스코프"><a class="header" href="#스코프">스코프</a></h3>
<p>r[names.resolution.general.scopes.intro]</p>
<blockquote>
<p>[!NOTE] This is a placeholder for future expansion about resolution of names within various scopes.</p>
</blockquote>
<p>r[names.resolution.expansion]</p>
<h2 id="expansion-time-name-resolution"><a class="header" href="#expansion-time-name-resolution">Expansion-time name resolution</a></h2>
<p>r[names.resolution.expansion.intro] Expansion-time name resolution is the stage of name resolution necessary to complete macro expansion and fully generate a crate’s <a href="glossary.ast">AST</a>. This stage requires the resolution of macro invocations and <code>use</code> declarations. Resolving <code>use</code> declarations is required for macro invocations that resolve via <a href="../macros.html#r-macro.invocation.name-resolution">path-based scope</a>. Resolving macro invocations is required in order to expand them.</p>
<p>r[names.resolution.expansion.unresolved-invocations] After expansion-time name resolution, the AST must not contain any unexpanded macro invocations. Every macro invocation resolves to a valid definition that exists in the final AST or in an external crate.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>m!(); // ERROR: Cannot find macro `m` in this scope.
<span class="boring">}</span></code></pre></pre>
<p>r[names.resolution.expansion.expansion-order-stability] The resolution of names must be stable. After expansion, names in the fully expanded AST must resolve to the same definition regardless of the order in which macros are expanded and imports are resolved.</p>
<p>r[names.resolution.expansion.speculation] All name resolution candidates selected during macro expansion are considered speculative. Once the crate has been fully expanded, all speculative import resolutions are validated to ensure that macro expansion did not introduce any new ambiguities.</p>
<blockquote>
<p>[!NOTE] Due to the iterative nature of macro expansion, this causes so-called time traveling ambiguities, such as when a macro or glob import introduces an item that is ambiguous with its own base path.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0659 edition2024"><span class="boring">fn main() {}
</span>macro_rules! f {
    () =&gt; {
        mod m {
            pub(crate) use f;
        }
    }
}
f!();

const _: () = {
    // Initially, we speculatively resolve `m` to the module in
    // the crate root.
    //
    // Expansion of `f` introduces a second `m` module inside this
    // body.
    //
    // Expansion-time resolution finalizes resolutions by re-
    // resolving all imports and macro invocations, sees the
    // introduced ambiguity and reports it as an error.
    m::f!(); // ERROR: `m` is ambiguous.
};</code></pre></pre>
</blockquote>
<p>r[names.resolution.expansion.imports]</p>
<h3 id="imports"><a class="header" href="#imports">Imports</a></h3>
<p>r[names.resolution.expansion.imports.intro] All <code>use</code> declarations are fully resolved during this stage of resolution. <a href="names.resolution.type-relative">Type-relative paths</a> cannot be resolved at this stage and will produce an error.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod m {
    pub const C: () = ();
    pub enum E { V }
    pub type A = E;
    impl E {
        pub const C: () = ();
    }
}

// Valid imports resolved at expansion-time:
use m::C; // OK.
use m::E; // OK.
use m::A; // OK.
use m::E::V; // OK.

// Valid expressions resolved during type-relative resolution:
let _ = m::A::V; // OK.
let _ = m::E::C; // OK.
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail E0432 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">mod m {
</span><span class="boring">    pub const C: () = ();
</span><span class="boring">    pub enum E { V }
</span><span class="boring">    pub type A = E;
</span><span class="boring">    impl E {
</span><span class="boring">        pub const C: () = ();
</span><span class="boring">    }
</span><span class="boring">}
</span>// Invalid type-relative imports that can't resolve at expansion-time:
use m::A::V; // ERROR: Unresolved import `m::A::V`.
use m::E::C; // ERROR: Unresolved import `m::E::C`.
<span class="boring">}</span></code></pre></pre>
<p>r[names.resolution.expansion.imports.shadowing] Names introduced via <code>use</code> declarations in an <a href="#r-names.resolution.general.scopes">outer scope</a> are shadowed by candidates in the same namespace with the same name from an inner scope except where otherwise restricted by <a href="#r-names.resolution.expansion.imports.ambiguity">name resolution ambiguities</a>.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod m1 {
    pub mod ambig {
        pub const C: u8 = 1;
    }
}

pub mod m2 {
    pub mod ambig {
        pub const C: u8 = 2;
    }
}

// This introduces the name `ambig` in the outer scope.
use m1::ambig;
const _: () = {
    // This shadows `ambig` in the inner scope.
    use m2::ambig;
    // The inner candidate is selected here
    // as the resolution of `ambig`.
    use ambig::C;
    assert!(C == 2);
};
<span class="boring">}</span></code></pre></pre>
<p>r[names.resolution.expansion.imports.shadowing.shared-scope] Shadowing of names introduced via <code>use</code> declarations within a single scope is permitted in the following situations:</p>
<ul>
<li><a href="../items/use-declarations.html#r-items.use.glob.shadowing"><code>use</code> glob shadowing</a></li>
<li><a href="../macros-by-example.html#r-macro.decl.scope.textual.shadow">Macro textual scope shadowing</a></li>
</ul>
<p>r[names.resolution.expansion.imports.ambiguity]</p>
<h4 id="모호성"><a class="header" href="#모호성">모호성</a></h4>
<p>r[names.resolution.expansion.imports.ambiguity.intro] There are certain situations during expansion-time resolution where there are multiple macro definitions, <code>use</code> declarations, or modules an import or macro invocation’s name could refer to where the compiler cannot consistently determine which candidate should shadow the other. Shadowing cannot be permitted in these situations and the compiler instead emits ambiguity errors.</p>
<p>r[names.resolution.expansion.imports.ambiguity.glob-vs-glob] Names may not be resolved through ambiguous glob imports. Glob imports are allowed to import conflicting names in the same namespace as long as the name is not used. Names with conflicting candidates from ambiguous glob imports may still be shadowed by non-glob imports and used without producing an error. The errors occur at time of use, not time of import.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0659 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod m1 {
    pub struct Ambig;
}

mod m2 {
    pub struct Ambig;
}

// OK: This brings conficting names in the same namespace into scope
// but they have not been used yet.
use m1::*;
use m2::*;

const _: () = {
    // The error happens when the name with the conflicting candidates
    // is used.
    let x = Ambig; // ERROR: `Ambig` is ambiguous.
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">mod m1 {
</span><span class="boring">    pub struct Ambig;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod m2 {
</span><span class="boring">    pub struct Ambig;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use m1::*;
</span><span class="boring">use m2::*; // OK: No name conflict.
</span>const _: () = {
    // This is permitted, since resolution is not through the
    // ambiguous globs.
    struct Ambig;
    let x = Ambig; // OK.
};
<span class="boring">}</span></code></pre></pre>
<p>Multiple glob imports are allowed to import the same name, and that name is allowed to be used if the imports are of the same item (following reexports). The visibility of the name is the maximum visibility of the imports.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024">mod m1 {
    pub struct Ambig;
}

mod m2 {
    // This reexports the same `Ambig` item from a second module.
    pub use super::m1::Ambig;
}

mod m3 {
    // These both import the same `Ambig`.
    //
    // The visibility of `Ambig` is `pub` because that is the
    // maximum visibility between these two `use` declarations.
    pub use super::m1::*;
    use super::m2::*;
}

mod m4 {
    // `Ambig` can be used through the `m3` globs and still has
    // `pub` visibility.
    pub use crate::m3::Ambig;
}

const _: () = {
    // Therefore, we can use it here.
    let _ = m4::Ambig; // OK.
};
<span class="boring">fn main() {}</span></code></pre></pre>
<p>r[names.resolution.expansion.imports.ambiguity.glob-vs-outer] Names in imports and macro invocations may not be resolved through glob imports when there is another candidate available in an <a href="#r-names.resolution.general.scopes">outer scope</a>.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0659 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod glob {
    pub mod ambig {
        pub struct Name;
    }
}

// Outer `ambig` candidate.
pub mod ambig {
    pub struct Name;
}

const _: () = {
    // Cannot resolve `ambig` through this glob
    // because of the outer `ambig` candidate above.
    use glob::*;
    use ambig::Name; // ERROR: `ambig` is ambiguous.
};
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail E0659 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// As above, but with macros.
pub mod m {
    macro_rules! f {
        () =&gt; {};
    }
    pub(crate) use f;
}
pub mod glob {
    macro_rules! f {
        () =&gt; {};
    }
    pub(crate) use f as ambig;
}

use m::f as ambig;

const _: () = {
    use glob::*;
    ambig!(); // ERROR: `ambig` is ambiguous.
};
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] These ambiguity errors are specific to expansion-time resolution. Having multiple candidates available for a given name during later stages of resolution is not considered an error. So long as none of the imports themselves are ambiguous, there will always be a single unambiguous closest resolution.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod glob {
    pub const AMBIG: u8 = 1;
}

mod outer {
    pub const AMBIG: u8 = 2;
}

use outer::AMBIG;

const C: () = {
    use glob::*;
    assert!(AMBIG == 1);
    //      ^---- This `AMBIG` is resolved during primary resolution.
};
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[names.resolution.expansion.imports.ambiguity.path-vs-textual-macro] Names may not be resolved through ambiguous macro reexports. Macro reexports are ambiguous when they would shadow a textual macro candidate for the same name in an <a href="#r-names.resolution.general.scopes">outer scope</a>.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0659 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Textual macro candidate.
macro_rules! ambig {
    () =&gt; {}
}

// Path-based macro candidate.
macro_rules! path_based {
    () =&gt; {}
}

pub fn f() {
    // This reexport of the `path_based` macro definition
    // as `ambig` may not shadow the `ambig` macro definition
    // which is resolved via textual macro scope.
    use path_based as ambig;
    ambig!(); // ERROR: `ambig` is ambiguous.
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] This restriction is needed due to implementation details in the compiler, specifically the current scope visitation logic and the complexity of supporting this behavior. This ambiguity error may be removed in the future.</p>
</blockquote>
<p>r[names.resolution.expansion.macros]</p>
<h3 id="매크로"><a class="header" href="#매크로">매크로</a></h3>
<p>r[names.resolution.expansion.macros.intro] Macros are resolved by iterating through the available scopes to find the available candidates. Macros are split into two sub-namespaces, one for function-like macros, and the other for attributes and derives. Resolution candidates from the incorrect sub-namespace are ignored.</p>
<p>r[names.resolution.expansion.macros.visitation-order] The available scope kinds are visited in the following order. Each of these scope kinds represent one or more scopes.</p>
<ul>
<li><a href="../procedural-macros.html#r-macro.proc.derive.attributes">Derive helpers</a></li>
<li><a href="../macros-by-example.html#r-macro.decl.scope.textual">Textual scope macros</a></li>
<li><a href="../macros.html#r-macro.invocation.name-resolution">Path-based scope macros</a></li>
<li><a href="./preludes.html#r-names.preludes.macro_use"><code>macro_use</code> prelude</a></li>
<li><a href="./preludes.html#r-names.preludes.std">Standard library prelude</a></li>
<li><a href="./preludes.html#r-names.preludes.lang">Builtin attributes</a></li>
</ul>
<blockquote>
<p>[!NOTE] The compiler will attempt to resolve derive helpers that are used before their associated macro introduces them into scope. This scope is visited after the scope for resolving derive helper candidates that are correctly in scope. This behavior is slated for removal.</p>
<p>For more info see <a href="../procedural-macros.html#r-macro.proc.derive.attributes.scope">derive helper scope</a>.</p>
</blockquote>
<blockquote>
<p>[!NOTE] This visitation order may change in the future, such as interleaving the visitation of textual and path-based scope candidates based on their lexical scopes.</p>
</blockquote>
<blockquote>
<p>[!EDITION-2018] Starting in edition 2018 the <code>#[macro_use]</code> prelude is not visited when [<code>#[no_implicit_prelude]</code>][names.preludes.no_implicit_prelude] is present.</p>
</blockquote>
<p>r[names.resolution.expansion.macros.reserved-names] The names <code>cfg</code> and <code>cfg_attr</code> are reserved in the macro attribute <a href="../names/namespaces.html#r-names.namespaces.sub-namespaces">sub-namespace</a>.</p>
<p>r[names.resolution.expansion.macros.ambiguity]</p>
<h4 id="모호성-1"><a class="header" href="#모호성-1">모호성</a></h4>
<p>r[names.resolution.expansion.macros.ambiguity.more-expanded-vs-outer] Names may not be resolved through ambiguous candidates inside of macro expansions. Candidates inside of macro expansions are ambiguous when they would shadow a candidate for the same name from outside of the first candidate’s macro expansion and the invocation of the name being resolved is also from outside of the first candidate’s macro expansion.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0659 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! define_ambig {
    () =&gt; {
        macro_rules! ambig {
            () =&gt; {}
        }
    }
}

// Introduce outer candidate definition for `ambig` macro invocation.
macro_rules! ambig {
    () =&gt; {}
}

// Introduce a second candidate definition for `ambig` inside of a
// macro expansion.
define_ambig!();

// The definition of `ambig` from the second invocation
// of `define_ambig` is the innermost canadidate.
//
// The definition of `ambig` from the first invocation of
// `define_ambig` is the second candidate.
//
// The compiler checks that the first candidate is inside of a macro
// expansion, that the second candidate is not from within the same
// macro expansion, and that the name being resolved is not from
// within the same macro expansion.
ambig!(); // ERROR: `ambig` is ambiguous.
<span class="boring">}</span></code></pre></pre>
<p>The reverse is not considered ambiguous.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">macro_rules! define_ambig {
</span><span class="boring">    () =&gt; {
</span><span class="boring">        macro_rules! ambig {
</span><span class="boring">            () =&gt; {}
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span>// Swap order of definitions.
define_ambig!();
macro_rules! ambig {
    () =&gt; {}
}
// The innermost candidate is now less expanded so it may shadow more
// the macro expanded definition above it.
ambig!();
<span class="boring">}</span></code></pre></pre>
<p>Nor is it ambiguous if the invocation being resolved is within the innermost candidate’s expansion.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! ambig {
    () =&gt; {}
}

macro_rules! define_and_invoke_ambig {
    () =&gt; {
        // Define innermost candidate.
        macro_rules! ambig {
            () =&gt; {}
        }

        // Invocation of `ambig` is in the same expansion as the
        // innermost candidate.
        ambig!(); // OK
    }
}

define_and_invoke_ambig!();
<span class="boring">}</span></code></pre></pre>
<p>It doesn’t matter if both definitions come from invocations of the same macro; the outermost candidate is still considered “less expanded” because it is not within the expansion containing the innermost candidate’s definition.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0659 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">macro_rules! define_ambig {
</span><span class="boring">    () =&gt; {
</span><span class="boring">        macro_rules! ambig {
</span><span class="boring">            () =&gt; {}
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span>define_ambig!();
define_ambig!();
ambig!(); // ERROR: `ambig` is ambiguous.
<span class="boring">}</span></code></pre></pre>
<p>This also applies to imports so long as the innermost candidate for the name is from within a macro expansion.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0659 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! define_ambig {
    () =&gt; {
        mod ambig {
            pub struct Name;
        }
    }
}

mod ambig {
    pub struct Name;
}

const _: () = {
    // Introduce innermost candidate for
    // `ambig` mod in this macro expansion.
    define_ambig!();
    use ambig::Name; // ERROR: `ambig` is ambiguous.
};
<span class="boring">}</span></code></pre></pre>
<p>r[names.resolution.expansion.macros.ambiguity.built-in-attr] User-defined attributes or derive macros may not shadow built-in non-macro attributes (e.g. inline).</p>
<!-- ignore: test doesn't support proc-macro -->
<pre><code class="language-rust ignore">// with-helper/src/lib.rs
<span class="boring">use proc_macro::TokenStream;
</span>#[proc_macro_derive(WithHelperAttr, attributes(non_exhaustive))]
//                                             ^^^^^^^^^^^^^^
//                                   User-defined attribute candidate.
// ...
<span class="boring">pub fn derive_with_helper_attr(_item: TokenStream) -&gt; TokenStream {
</span><span class="boring">    TokenStream::new()
</span><span class="boring">}</span></code></pre>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">// src/lib.rs
#[derive(with_helper::WithHelperAttr)]
#[non_exhaustive] // ERROR: `non_exhaustive` is ambiguous.
struct S;</code></pre>
<blockquote>
<p>[!NOTE] This applies regardless of the name the built-in attribute is a candidate for:</p>
<!-- ignore: test doesn't support proc-macro -->
<pre><code class="language-rust ignore">// with-helper/src/lib.rs
<span class="boring">use proc_macro::TokenStream;
</span><span class="boring">
</span>#[proc_macro_derive(WithHelperAttr, attributes(helper))]
//                                             ^^^^^^
//                                 User-defined attribute candidate.
// ...
<span class="boring">pub fn derive_with_helper_attr(_item: TokenStream) -&gt; TokenStream {
</span><span class="boring">    TokenStream::new()
</span><span class="boring">}</span></code></pre>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">// src/lib.rs
use inline as helper;
//            ^----- Built-in attribute candidate via reexport.

#[derive(with_helper::WithHelperAttr)]
#[helper] // ERROR: `helper` is ambiguous.
struct S;</code></pre>
</blockquote>
<p>r[names.resolution.primary]</p>
<h2 id="primary-name-resolution"><a class="header" href="#primary-name-resolution">Primary name resolution</a></h2>
<blockquote>
<p>[!NOTE] This is a placeholder for future expansion about primary name resolution.</p>
</blockquote>
<p>r[names.resolution.type-relative]</p>
<h2 id="type-relative-resolution"><a class="header" href="#type-relative-resolution">Type-relative resolution</a></h2>
<blockquote>
<p>[!NOTE] This is a placeholder for future expansion about type-dependent resolution.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../paths.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../visibility-and-privacy.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../paths.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../visibility-and-privacy.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/reference.js"></script>
        <script src="../theme/language-picker.js"></script>


    </div>
    </body>
</html>
