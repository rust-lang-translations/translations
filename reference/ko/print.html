<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Rust Reference</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/reference";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/print.md`;
                    } else {
                        canonical_href = `${base}/${lang}/print.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/reference.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="소개"><a class="header" href="#소개">소개</a></h1>
<p>This book is the primary reference for the Rust programming language.</p>
<blockquote>
<p>[!NOTE] For known bugs and omissions in this book, see our <a href="https://github.com/rust-lang/reference/issues">GitHub issues</a>. If you see a case where the compiler behavior and the text here do not agree, file an issue so we can think about which is correct.</p>
</blockquote>
<h2 id="러스트-릴리스"><a class="header" href="#러스트-릴리스">러스트 릴리스</a></h2>
<p>Rust has a new language release every six weeks. The first stable release of the language was Rust 1.0.0, followed by Rust 1.1.0 and so on. Tools (<code>rustc</code>, <code>cargo</code>, etc.) and documentation (<a href="std">Standard library</a>, this book, etc.) are released with the language release.</p>
<p>최신 Rust 버전에 해당하는 이 책의 최신 릴리스는 항상 <a href="https://doc.rust-lang.org/reference/">https://doc.rust-lang.org/reference/</a>에서 찾을 수 있습니다. 이전 버전은 “reference” 디렉토리 앞에 Rust 버전을 추가하여 찾을 수 있습니다. 예를 들어, Rust 1.49.0에 대한 참조는 <a href="https://doc.rust-lang.org/1.49.0/reference/">https://doc.rust-lang.org/1.49.0/reference/</a>에 있습니다.</p>
<h2 id="_참조_가-아닌-것"><a class="header" href="#_참조_가-아닌-것">_참조_가 아닌 것</a></h2>
<p>이 책은 언어 입문서가 아닙니다. 언어에 대한 기본적인 지식이 있다고 가정합니다. 이러한 배경 지식을 습득하는 데 도움이 되는 별도의 <a href="../book/index.html">책</a>이 있습니다.</p>
<p>This book also does not serve as a reference to the <a href="std">standard library</a> included in the language distribution. Those libraries are documented separately by extracting documentation attributes from their source code. Many of the features that one might expect to be language features are library features in Rust, so what you’re looking for may be there, not here.</p>
<p>마찬가지로, 이 책은 일반적으로 <code>rustc</code> 도구 또는 Cargo의 세부 사항을 문서화하지 않습니다. <code>rustc</code>에는 자체 <a href="../rustc/index.html">책</a>이 있습니다. Cargo에는 <a href="../cargo/reference/index.html">참조</a>가 포함된 <a href="../cargo/index.html">책</a>이 있습니다. <a href="linkage.html">연결</a>과 같은 몇몇 페이지는 여전히 <code>rustc</code>의 작동 방식을 설명합니다.</p>
<p>이 책은 또한 안정적인 Rust에서 사용할 수 있는 기능에 대한 참조 역할만 합니다. 개발 중인 불안정한 기능에 대해서는 <a href="https://doc.rust-lang.org/nightly/unstable-book/">불안정 책</a>을 참조하십시오.</p>
<p><code>rustc</code>를 포함한 Rust 컴파일러는 최적화를 수행합니다. 참조는 어떤 최적화가 허용되거나 허용되지 않는지 명시하지 않습니다. 대신, 컴파일된 프로그램을 블랙박스로 생각하십시오. 프로그램을 실행하고 입력을 제공하며 출력을 관찰함으로써만 탐색할 수 있습니다. 그렇게 발생하는 모든 것은 참조가 말하는 바를 따라야 합니다.</p>
<h2 id="이-책을-사용하는-방법"><a class="header" href="#이-책을-사용하는-방법">이 책을 사용하는 방법</a></h2>
<p>이 책은 순차적으로 읽는다고 가정하지 않습니다. 각 장은 일반적으로 독립적으로 읽을 수 있지만, 언급하지만 논의하지 않는 언어의 측면에 대해서는 다른 장으로 상호 연결됩니다.</p>
<p>이 문서를 읽는 두 가지 주요 방법이 있습니다.</p>
<p>첫 번째는 특정 질문에 답하는 것입니다. 해당 질문에 답하는 장을 알고 있다면 목차에서 해당 장으로 이동할 수 있습니다. 그렇지 않으면 <code>s</code>를 누르거나 상단 바의 돋보기를 클릭하여 질문과 관련된 키워드를 검색할 수 있습니다. 예를 들어, let 문에서 생성된 임시 값이 언제 삭제되는지 알고 싶다고 가정해 봅시다. <a href="expressions.html#temporaries">임시 값의 수명</a>이 <a href="expressions.html">표현식 장</a>에 정의되어 있다는 것을 이미 알고 있지 못했다면, “temporary let“을 검색하면 첫 번째 검색 결과가 해당 섹션으로 안내할 것입니다.</p>
<p>두 번째는 언어의 한 측면에 대한 지식을 일반적으로 향상시키는 것입니다. 이 경우, 더 알고 싶은 것을 볼 때까지 목차를 탐색하고 읽기 시작하십시오. 링크가 흥미로워 보이면 클릭하여 해당 섹션을 읽으십시오.</p>
<p>그렇다고 해서 이 책을 읽는 데 잘못된 방법은 없습니다. 가장 도움이 된다고 생각하는 방식으로 읽으십시오.</p>
<h3 id="규약"><a class="header" href="#규약">규약</a></h3>
<p>모든 기술 서적과 마찬가지로 이 책은 정보를 표시하는 방식에 있어 특정 규칙을 따릅니다. 이러한 규칙은 여기에 문서화되어 있습니다.</p>
<ul>
<li>
<p>용어를 정의하는 문장은 해당 용어를 _이탤릭체_로 포함합니다. 해당 용어가 해당 장 외부에서 사용될 때마다 일반적으로 이 정의가 있는 섹션에 대한 링크입니다.</p>
<p>_예시 용어_는 정의되는 용어의 예시입니다.</p>
</li>
<li>
<p>The main text describes the latest stable edition. Differences to previous editions are separated in edition blocks:</p>
<blockquote>
<p>[!EDITION-2018] Before the 2018 edition, the behavior was this. As of the 2018 edition, the behavior is that.</p>
</blockquote>
</li>
<li>
<p>Notes that contain useful information about the state of the book or point out useful, but mostly out of scope, information are in note blocks.</p>
<blockquote>
<p>[!NOTE] This is an example note.</p>
</blockquote>
</li>
<li>
<p>Example blocks show an example that demonstrates some rule or points out some interesting aspect. Some examples may have hidden lines which can be viewed by clicking the eye icon that appears when hovering or tapping the example.</p>
<blockquote>
<p>[!EXAMPLE] This is a code example.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!("hello world");
<span class="boring">}</span></code></pre></pre>
</blockquote>
</li>
<li>
<p>언어의 불안정한 동작 또는 언어 기능의 혼란스러운 상호 작용을 보여주는 경고는 특별 경고 상자에 있습니다.</p>
<blockquote>
<p>[!WARNING] This is an example warning.</p>
</blockquote>
</li>
<li>
<p>텍스트 내의 코드 스니펫은 <code>&lt;code&gt;</code> 태그 안에 있습니다.</p>
<p>더 긴 코드 예제는 구문 강조 표시된 상자에 있으며, 오른쪽 상단 모서리에 복사, 실행 및 숨겨진 줄 표시를 위한 컨트롤이 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">// 이것은 숨겨진 줄입니다.
</span>fn main() {
    println!("이것은 코드 예시입니다");
}</code></pre></pre>
<p>모든 예제는 별도로 명시되지 않는 한 최신 에디션을 기준으로 작성되었습니다.</p>
</li>
<li>
<p>The grammar and lexical productions are described in the <a href="notation.html">Notation</a> chapter.</p>
</li>
</ul>
<p>r[example.rule.label]</p>
<ul>
<li>
<p>Rule identifiers appear before each language rule enclosed in square brackets. These identifiers provide a way to refer to and link to a specific rule in the language (<a href="example.rule.label">e.g.</a>). The rule identifier uses periods to separate sections from most general to most specific ([destructors.scope.nesting.function-body] for example). On narrow screens, the rule name will collapse to display <code>[*]</code>.</p>
<p>규칙 이름을 클릭하면 해당 규칙으로 연결됩니다.</p>
<blockquote>
<p>[!WARNING] The organization of the rules is currently in flux. For the time being, these identifier names are not stable between releases, and links to these rules may fail if they are changed. We intend to stabilize these once the organization has settled so that links to the rule names will not break between releases.</p>
</blockquote>
</li>
<li>
<p>Rules that have associated tests will include a <code>Tests</code> link below them (on narrow screens, the link is <code>[T]</code>). Clicking the link will pop up a list of tests, which can be clicked to view the test. For example, see [input.encoding.utf8].</p>
<p>Linking rules to tests is an ongoing effort. See the <a href="test-summary.html">Test summary</a> chapter for an overview.</p>
</li>
</ul>
<h2 id="기여하기"><a class="header" href="#기여하기">기여하기</a></h2>
<p>모든 종류의 기여를 환영합니다.</p>
<p>You can contribute to this book by opening an issue or sending a pull request to <a href="https://github.com/rust-lang/reference/">the Rust Reference repository</a>. If this book does not answer your question, and you think its answer is in scope of it, please do not hesitate to <a href="https://github.com/rust-lang/reference/issues">file an issue</a> or ask about it in the <code>t-lang/doc</code> stream on <a href="https://rust-lang.zulipchat.com/#narrow/stream/237824-t-lang.2Fdoc">Zulip</a>. Knowing what people use this book for the most helps direct our attention to making those sections the best that they can be. And of course, if you see anything that is wrong or is non-normative but not specifically called out as such, please also <a href="https://github.com/rust-lang/reference/issues">file an issue</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[notation]</p>
<h1 id="표기법"><a class="header" href="#표기법">표기법</a></h1>
<p>r[notation.grammar]</p>
<h2 id="문법"><a class="header" href="#문법">문법</a></h2>
<p>r[notation.grammar.syntax]</p>
<p>다음 표기법은 <em>렉서</em> 및 <em>구문</em> 문법 스니펫에서 사용됩니다.</p>
<div class="table-wrapper"><table><thead><tr><th>표기법</th><th>예시</th><th>의미</th></tr></thead><tbody>
<tr><td>대문자</td><td>KW_IF, 정수_리터럴</td><td>렉서가 생성한 토큰</td></tr>
<tr><td><em>이탤릭카멜케이스</em></td><td><em>Let문</em>, <em>아이템</em></td><td>구문 생성</td></tr>
<tr><td><code>문자열</code></td><td><code>x</code>, <code>while</code>, <code>*</code></td><td>정확한 문자(들)</td></tr>
<tr><td>x<sup>?</sup></td><td><code>pub</code><sup>?</sup></td><td>선택적 항목</td></tr>
<tr><td>x<sup>*</sup></td><td><em>외부속성</em><sup>*</sup></td><td>x가 0개 이상</td></tr>
<tr><td>x<sup>+</sup></td><td><em>매크로매치</em><sup>+</sup></td><td>x가 1개 이상</td></tr>
<tr><td>x<sup>a..b</sup></td><td>16진수_숫자<sup>1..6</sup></td><td>x의 a부터 b까지 반복</td></tr>
<tr><td>Rule1 Rule2</td><td><code>fn</code> <em>Name</em> <em>Parameters</em></td><td>Sequence of rules in order</td></tr>
<tr><td>|</td><td><code>u8</code> | <code>u16</code>, 블록 | 아이템</td><td>둘 중 하나</td></tr>
<tr><td>[ ]</td><td>[<code>b</code> <code>B</code>]</td><td>나열된 문자 중 하나</td></tr>
<tr><td>[ - ]</td><td>[<code>a</code>-<code>z</code>]</td><td>범위 내의 문자 중 하나</td></tr>
<tr><td>~[ ]</td><td>~[<code>b</code> <code>B</code>]</td><td>나열된 문자를 제외한 모든 문자</td></tr>
<tr><td>~<code>문자열</code></td><td>~<code> </code>, ~<code>*/</code></td><td>이 시퀀스를 제외한 모든 문자</td></tr>
<tr><td>( )</td><td>(<code>,</code> <em>매개변수</em>)<sup>?</sup></td><td>항목 그룹화</td></tr>
<tr><td>U+xxxx</td><td>U+0060</td><td>A single unicode character</td></tr>
<tr><td>&lt;text&gt;</td><td>&lt;any ASCII char except CR&gt;</td><td>An English description of what should be matched</td></tr>
<tr><td>Rule <sub>suffix</sub></td><td>IDENTIFIER_OR_KEYWORD <sub><em>except <code>crate</code></em></sub></td><td>A modification to the previous rule</td></tr>
<tr><td>// Comment.</td><td>// Single line comment.</td><td>A comment extending to the end of the line.</td></tr>
</tbody></table>
</div>
<p>Sequences have a higher precedence than <code>|</code> alternation.</p>
<p>r[notation.grammar.string-tables]</p>
<h3 id="문자열-테이블-생성"><a class="header" href="#문자열-테이블-생성">문자열 테이블 생성</a></h3>
<p>문법의 일부 규칙(특히 <a href="expressions/operator-expr.html#borrow-operators">단항 연산자</a>, <a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">이항 연산자</a> 및 <a href="keywords.html">키워드</a>)은 인쇄 가능한 문자열 목록으로 단순화된 형태로 제공됩니다. 이러한 경우는 <a href="tokens.html">토큰</a> 규칙에 관한 규칙의 하위 집합을 형성하며, <abbr title="결정론적 유한 오토마톤">DFA</abbr>에 의해 구동되는 어휘 분석 단계가 파서에 공급하는 결과로 간주되며, 이러한 모든 문자열 테이블 항목의 논리합에 대해 작동합니다.</p>
<p>문법 내에서 <code>monospace</code> 글꼴의 문자열이 나타나면, 이는 해당 문자열 테이블 생성의 단일 멤버에 대한 암시적 참조입니다. 자세한 내용은 <a href="tokens.html">토큰</a>을 참조하십시오.</p>
<p>r[notation.grammar.visualizations]</p>
<h3 id="grammar-visualizations"><a class="header" href="#grammar-visualizations">Grammar visualizations</a></h3>
<p>Below each grammar block is a button to toggle the display of a <a href="https://en.wikipedia.org/wiki/Syntax_diagram">syntax diagram</a>. A square element is a non-terminal rule, and a rounded rectangle is a terminal.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="어휘-구조"><a class="header" href="#어휘-구조">어휘 구조</a></h1>
<!-- Editor Note: Oh, there's nothing here -->
<div style="break-before: page; page-break-before: always;"></div><p>r[input]</p>
<h1 id="입력-형식"><a class="header" href="#입력-형식">입력 형식</a></h1>
<p>r[input.syntax]</p>
<pre><code class="language-grammar lexer">@root CHAR -&gt; &lt;a Unicode scalar value&gt;

NUL -&gt; U+0000
</code></pre>
<p>r[input.intro] This chapter describes how a source file is interpreted as a sequence of tokens.</p>
<p>프로그램이 파일로 구성되는 방법에 대한 설명은 <a href="crates-and-source-files.html">크레이트 및 소스 파일</a>을 참조하십시오.</p>
<p>r[input.encoding]</p>
<h2 id="소스-인코딩"><a class="header" href="#소스-인코딩">소스 인코딩</a></h2>
<p>r[input.encoding.utf8] Each source file is interpreted as a sequence of Unicode characters encoded in UTF-8.</p>
<p>r[input.encoding.invalid] It is an error if the file is not valid UTF-8.</p>
<p>r[input.byte-order-mark]</p>
<h2 id="바이트-순서-마크-제거"><a class="header" href="#바이트-순서-마크-제거">바이트 순서 마크 제거</a></h2>
<p>시퀀스의 첫 번째 문자가 <code>U+FEFF</code>(<a href="https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8">바이트 순서 마크</a>)이면 제거됩니다.</p>
<p>r[input.crlf]</p>
<h2 id="crlf-정규화"><a class="header" href="#crlf-정규화">CRLF 정규화</a></h2>
<p>Each pair of characters <code>U+000D</code> (CR) immediately followed by <code>U+000A</code> (LF) is replaced by a single <code>U+000A</code> (LF). This happens once, not repeatedly, so after the normalization, there can still exist <code>U+000D</code> (CR) immediately followed by <code>U+000A</code> (LF) in the input (e.g. if the raw input contained “CR CR LF LF”).</p>
<p><code>U+000D</code> (CR) 문자의 다른 발생은 그대로 유지됩니다(이들은 <a href="whitespace.html">공백</a>으로 처리됩니다).</p>
<p>r[input.shebang]</p>
<h2 id="쉬뱅-제거"><a class="header" href="#쉬뱅-제거">쉬뱅 제거</a></h2>
<p>r[input.shebang.intro] If the remaining sequence begins with the characters <code>#!</code>, the characters up to and including the first <code>U+000A</code> (LF) are removed from the sequence.</p>
<p>예를 들어, 다음 파일의 첫 번째 줄은 무시됩니다:</p>
<!-- ignore: tests don't like shebang -->
<pre><code class="language-rust ignore">#!/usr/bin/env rustx

fn main() {
    println!("안녕하세요!");
}</code></pre>
<p>r[input.shebang.inner-attribute] As an exception, if the <code>#!</code> characters are followed (ignoring intervening <a href="comments.html">comments</a> or <a href="whitespace.html">whitespace</a>) by a <code>[</code> token, nothing is removed. This prevents an <a href="attributes.html">inner attribute</a> at the start of a source file being removed.</p>
<p>r[input.tokenization]</p>
<h2 id="토큰화"><a class="header" href="#토큰화">토큰화</a></h2>
<p>결과 문자 시퀀스는 이 장의 나머지 부분에 설명된 대로 토큰으로 변환됩니다.</p>
<blockquote>
<p>[!NOTE] The standard library [<code>include!</code>] macro applies the following transformations to the file it reads:</p>
<ul>
<li>Byte order mark removal.</li>
<li>CRLF normalization.</li>
<li>Shebang removal when invoked in an item context (as opposed to expression or statement contexts).</li>
</ul>
<p>The [<code>include_str!</code>] and [<code>include_bytes!</code>] macros do not apply these transformations.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>r[lex.keywords]</p>
<h1 id="키워드"><a class="header" href="#키워드">키워드</a></h1>
<p>러스트는 키워드를 세 가지 범주로 나눕니다:</p>
<ul>
<li><a href="keywords.html#strict-keywords">엄격</a></li>
<li><a href="keywords.html#reserved-keywords">예약됨</a></li>
<li><a href="keywords.html#weak-keywords">약함</a></li>
</ul>
<p>r[lex.keywords.strict]</p>
<h2 id="엄격한-키워드"><a class="header" href="#엄격한-키워드">엄격한 키워드</a></h2>
<p>r[lex.keywords.strict.intro] These keywords can only be used in their correct contexts. They cannot be used as the names of:</p>
<ul>
<li><a href="items.html">아이템</a></li>
<li><a href="variables.html">변수</a> 및 함수 매개변수</li>
<li>필드 및 <a href="items/enumerations.html">변형</a></li>
<li><a href="types/parameters.html">타입 매개변수</a></li>
<li>라이프타임 매개변수 또는 <a href="expressions/loop-expr.html#loop-labels">루프 레이블</a></li>
<li><a href="macros.html">매크로</a> 또는 <a href="attributes.html">속성</a></li>
<li><a href="macros-by-example.html">매크로 플레이스홀더</a></li>
<li><a href="crates-and-source-files.html">크레이트</a></li>
</ul>
<p>r[lex.keywords.strict.list] The following keywords are in all editions:</p>
<ul>
<li><code>_</code></li>
<li><code>as</code></li>
<li><code>async</code></li>
<li><code>await</code></li>
<li><code>break</code></li>
<li><code>const</code></li>
<li><code>continue</code></li>
<li><code>crate</code></li>
<li><code>dyn</code></li>
<li><code>else</code></li>
<li><code>enum</code></li>
<li><code>extern</code></li>
<li><code>false</code></li>
<li><code>fn</code></li>
<li><code>for</code></li>
<li><code>if</code></li>
<li><code>impl</code></li>
<li><code>in</code></li>
<li><code>let</code></li>
<li><code>loop</code></li>
<li><code>match</code></li>
<li><code>mod</code></li>
<li><code>move</code></li>
<li><code>mut</code></li>
<li><code>pub</code></li>
<li><code>ref</code></li>
<li><code>return</code></li>
<li><code>self</code></li>
<li><code>Self</code></li>
<li><code>static</code></li>
<li><code>struct</code></li>
<li><code>super</code></li>
<li><code>trait</code></li>
<li><code>true</code></li>
<li><code>type</code></li>
<li><code>unsafe</code></li>
<li><code>use</code></li>
<li><code>where</code></li>
<li><code>while</code></li>
</ul>
<p>r[lex.keywords.strict.edition2018]</p>
<blockquote>
<p>[!EDITION-2018] The following keywords were added in the 2018 edition:</p>
<ul>
<li><code>async</code></li>
<li><code>await</code></li>
<li><code>dyn</code></li>
</ul>
</blockquote>
<p>r[lex.keywords.reserved]</p>
<h2 id="예약된-키워드"><a class="header" href="#예약된-키워드">예약된 키워드</a></h2>
<p>r[lex.keywords.reserved.intro] These keywords aren’t used yet, but they are reserved for future use. They have the same restrictions as strict keywords. The reasoning behind this is to make current programs forward compatible with future versions of Rust by forbidding them to use these keywords.</p>
<p>r[lex.keywords.reserved.list]</p>
<ul>
<li><code>abstract</code></li>
<li><code>become</code></li>
<li><code>box</code></li>
<li><code>do</code></li>
<li><code>final</code></li>
<li><code>gen</code></li>
<li><code>macro</code></li>
<li><code>override</code></li>
<li><code>priv</code></li>
<li><code>try</code></li>
<li><code>typeof</code></li>
<li><code>unsized</code></li>
<li><code>virtual</code></li>
<li><code>yield</code></li>
</ul>
<p>r[lex.keywords.reserved.edition2018]</p>
<blockquote>
<p>[!EDITION-2018] The <code>try</code> keyword was added as a reserved keyword in the 2018 edition.</p>
</blockquote>
<p>r[lex.keywords.reserved.edition2024]</p>
<blockquote>
<p>[!EDITION-2024] The <code>gen</code> keyword was added as a reserved keyword in the 2024 edition.</p>
</blockquote>
<p>r[lex.keywords.weak]</p>
<h2 id="약한-키워드"><a class="header" href="#약한-키워드">약한 키워드</a></h2>
<p>r[lex.keywords.weak.intro] These keywords have special meaning only in certain contexts. For example, it is possible to declare a variable or method with the name <code>union</code>.</p>
<ul>
<li><code>'static</code></li>
<li><code>macro_rules</code></li>
<li><code>raw</code></li>
<li><code>safe</code></li>
<li><code>union</code></li>
</ul>
<p>r[lex.keywords.weak.macro_rules]</p>
<ul>
<li><code>macro_rules</code>는 사용자 정의 <a href="macros.html">매크로</a>를 생성하는 데 사용됩니다.</li>
</ul>
<p>r[lex.keywords.weak.union]</p>
<ul>
<li><code>union</code>은 <a href="items/unions.html">유니온</a>을 선언하는 데 사용되며, 유니온 선언에서 사용될 때만 키워드입니다.</li>
</ul>
<p>r[lex.keywords.weak.lifetime-static]</p>
<ul>
<li>
<p><code>'static</code>은 정적 라이프타임에 사용되며, <a href="items/generics.html">제네릭 라이프타임 매개변수</a> 또는 <a href="expressions/loop-expr.html#loop-labels">루프 레이블</a>로 사용될 수 없습니다.</p>
<pre><code class="language-compile_fail">// error[E0262]: 잘못된 라이프타임 매개변수 이름: `'static`
fn invalid_lifetime_parameter&lt;'static&gt;(s: &amp;'static str) -&gt; &amp;'static str { s }
</code></pre>
</li>
</ul>
<p>r[lex.keywords.weak.safe]</p>
<ul>
<li><code>safe</code>는 함수와 정적에 사용되며, <a href="items/external-blocks.html">외부 블록</a>에서 의미를 가집니다.</li>
</ul>
<p>r[lex.keywords.weak.raw]</p>
<ul>
<li><code>raw</code>는 <a href="expressions/operator-expr.html#raw-borrow-operators">원시 차용 연산자</a>에 사용되며, 원시 차용 연산자 형식(예: <code>&amp;raw const expr</code> 또는 <code>&amp;raw mut expr</code>)과 일치할 때만 키워드입니다.</li>
</ul>
<p>r[lex.keywords.weak.dyn.edition2018]</p>
<blockquote>
<p>[!EDITION-2018] In the 2015 edition, <a href="types/trait-object.html"><code>dyn</code></a> is a keyword when used in a type position followed by a path that does not start with <code>::</code> or <code>&lt;</code>, a lifetime, a question mark, a <code>for</code> keyword or an opening parenthesis.</p>
<p>2018년 에디션부터 <code>dyn</code>은 엄격한 키워드로 승격되었습니다.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>r[ident]</p>
<h1 id="식별자"><a class="header" href="#식별자">식별자</a></h1>
<p>r[ident.syntax]</p>
<pre><code class="language-grammar lexer">IDENTIFIER_OR_KEYWORD -&gt; ( XID_Start | `_` ) XID_Continue*

XID_Start -&gt; &lt;`XID_Start` defined by Unicode&gt;

XID_Continue -&gt; &lt;`XID_Continue` defined by Unicode&gt;

RAW_IDENTIFIER -&gt; `r#` IDENTIFIER_OR_KEYWORD

NON_KEYWORD_IDENTIFIER -&gt; IDENTIFIER_OR_KEYWORD _except a [strict][lex.keywords.strict] or [reserved][lex.keywords.reserved] keyword_

IDENTIFIER -&gt; NON_KEYWORD_IDENTIFIER | RAW_IDENTIFIER

RESERVED_RAW_IDENTIFIER -&gt;
    `r#` (`_` | `crate` | `self` | `Self` | `super`) _not immediately followed by XID_Continue_
</code></pre>
<!-- When updating the version, update the UAX links, too. -->
<p>r[ident.unicode] Identifiers follow the specification in <a href="https://www.unicode.org/reports/tr31/tr31-43.html">Unicode Standard Annex #31</a> for Unicode version 17.0, with the additions described below. Some examples of identifiers:</p>
<ul>
<li><code>foo</code></li>
<li><code>_identifier</code></li>
<li><code>r#true</code></li>
<li><code>Москва</code></li>
<li><code>東京</code></li>
</ul>
<p>r[ident.profile] The profile used from UAX #31 is:</p>
<ul>
<li>시작 := <a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Start%3A%5D&amp;abb=on&amp;g=&amp;i="><code>XID_Start</code></a>, 더하기 밑줄 문자 (U+005F)</li>
<li>계속 := <a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Continue%3A%5D&amp;abb=on&amp;g=&amp;i="><code>XID_Continue</code></a></li>
<li>중간 := 비어 있음</li>
</ul>
<blockquote>
<p>[!NOTE] Identifiers starting with an underscore are typically used to indicate an identifier that is intentionally unused, and will silence the unused warning in <code>rustc</code>.</p>
</blockquote>
<p>r[ident.keyword] Identifiers may not be a <a href="keywords.html#strict-keywords">strict</a> or <a href="keywords.html#reserved-keywords">reserved</a> keyword without the <code>r#</code> prefix described below in <a href="identifiers.html#raw-identifiers">raw identifiers</a>.</p>
<p>r[ident.zero-width-chars] Zero width non-joiner (ZWNJ U+200C) and zero width joiner (ZWJ U+200D) characters are not allowed in identifiers.</p>
<p>r[ident.ascii-limitations] Identifiers are restricted to the ASCII subset of <a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Start%3A%5D&amp;abb=on&amp;g=&amp;i="><code>XID_Start</code></a> and <a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Continue%3A%5D&amp;abb=on&amp;g=&amp;i="><code>XID_Continue</code></a> in the following situations:</p>
<ul>
<li><a href="items/extern-crates.html"><code>extern crate</code></a> declarations (except the [AsClause] identifier)</li>
<li><a href="paths.html">경로</a>에서 참조되는 외부 크레이트 이름</li>
<li><a href="items/modules.html#the-path-attribute"><code>path</code> 속성</a> 없이 파일 시스템에서 로드된 <a href="items/modules.html">모듈</a> 이름</li>
<li><a href="abi.html#the-no_mangle-attribute"><code>no_mangle</code></a> 속성 항목</li>
<li><a href="items/external-blocks.html">외부 블록</a>의 아이템 이름</li>
</ul>
<p>r[ident.normalization]</p>
<h2 id="정규화"><a class="header" href="#정규화">정규화</a></h2>
<p>Identifiers are normalized using Normalization Form C (NFC) as defined in <a href="https://www.unicode.org/reports/tr15/tr15-57.html">Unicode Standard Annex #15</a>. Two identifiers are equal if their NFC forms are equal.</p>
<p><a href="procedural-macros.html">절차적</a> 및 <a href="macros-by-example.html">선언적</a> 매크로는 입력에서 정규화된 식별자를 받습니다.</p>
<p>r[ident.raw]</p>
<h2 id="원시-식별자"><a class="header" href="#원시-식별자">원시 식별자</a></h2>
<p>r[ident.raw.intro] A raw identifier is like a normal identifier, but prefixed by <code>r#</code>. (Note that the <code>r#</code> prefix is not included as part of the actual identifier.)</p>
<p>r[ident.raw.allowed] Unlike a normal identifier, a raw identifier may be any strict or reserved keyword except the ones listed above for <code>RAW_IDENTIFIER</code>.</p>
<p>r[ident.raw.reserved] It is an error to use the [RESERVED_RAW_IDENTIFIER] token.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[comments]</p>
<h1 id="주석"><a class="header" href="#주석">주석</a></h1>
<p>r[comments.syntax]</p>
<pre><code class="language-grammar lexer">@root LINE_COMMENT -&gt;
      `//` (~[`/` `!` LF] | `//`) ~LF*
    | `//`

BLOCK_COMMENT -&gt;
      `/*`
        ( ~[`*` `!`] | `**` | BLOCK_COMMENT_OR_DOC )
        ( BLOCK_COMMENT_OR_DOC | ~`*/` )*
      `*/`
    | `/**/`
    | `/***/`

@root INNER_LINE_DOC -&gt;
    `//!` ~[LF CR]*

INNER_BLOCK_DOC -&gt;
    `/*!` ( BLOCK_COMMENT_OR_DOC | ~[`*/` CR] )* `*/`

@root OUTER_LINE_DOC -&gt;
    `///` (~`/` ~[LF CR]*)?

OUTER_BLOCK_DOC -&gt;
    `/**`
      ( ~`*` | BLOCK_COMMENT_OR_DOC )
      ( BLOCK_COMMENT_OR_DOC | ~[`*/` CR] )*
    `*/`

@root BLOCK_COMMENT_OR_DOC -&gt;
      BLOCK_COMMENT
    | OUTER_BLOCK_DOC
    | INNER_BLOCK_DOC
</code></pre>
<p>r[comments.normal]</p>
<h2 id="비-문서-주석"><a class="header" href="#비-문서-주석">비 문서 주석</a></h2>
<p>주석은 일반적인 C++ 스타일의 라인 (<code>//</code>) 및 블록 (<code>/* ... */</code>) 주석 형식을 따릅니다. 중첩된 블록 주석이 지원됩니다.</p>
<p>r[comments.normal.tokenization] Non-doc comments are interpreted as a form of whitespace.</p>
<p>r[comments.doc]</p>
<h2 id="문서-주석"><a class="header" href="#문서-주석">문서 주석</a></h2>
<p>r[comments.doc.syntax] Line doc comments beginning with exactly <em>three</em> slashes (<code>///</code>), and block doc comments (<code>/** ... */</code>), both outer doc comments, are interpreted as a special syntax for <a href="../rustdoc/the-doc-attribute.html"><code>doc</code> attributes</a>.</p>
<p>r[comments.doc.attributes] That is, they are equivalent to writing <code>#[doc="..."]</code> around the body of the comment, i.e., <code>/// Foo</code> turns into <code>#[doc="Foo"]</code> and <code>/** Bar */</code> turns into <code>#[doc="Bar"]</code>. They must therefore appear before something that accepts an outer attribute.</p>
<p>r[comments.doc.inner-syntax] Line comments beginning with <code>//!</code> and block comments <code>/*! ... */</code> are doc comments that apply to the parent of the comment, rather than the item that follows.</p>
<p>r[comments.doc.inner-attributes] That is, they are equivalent to writing <code>#![doc="..."]</code> around the body of the comment. <code>//!</code> comments are usually used to document modules that occupy a source file.</p>
<p>r[comments.doc.bare-crs] The character <code>U+000D</code> (CR) is not allowed in doc comments.</p>
<blockquote>
<p>[!NOTE] It is conventional for doc comments to contain Markdown, as expected by <code>rustdoc</code>. However, the comment syntax does not respect any internal Markdown. <code>/** `glob = "*/*.rs";` */</code> terminates the comment at the first <code>*/</code>, and the remaining code would cause a syntax error. This slightly limits the content of block doc comments compared to line doc comments.</p>
</blockquote>
<blockquote>
<p>[!NOTE] The sequence <code>U+000D</code> (CR) immediately followed by <code>U+000A</code> (LF) would have been previously transformed into a single <code>U+000A</code> (LF).</p>
</blockquote>
<h2 id="예시"><a class="header" href="#예시">예시</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! 이 크레이트의 암시적 익명 모듈에 적용되는 문서 주석

pub mod outer_module {

    //!  - 내부 라인 문서
    //!! - 여전히 내부 라인 문서 (하지만 시작에 느낌표가 있음)

    /*!  - 내부 블록 문서 */
    /*!! - 여전히 내부 블록 문서 (하지만 시작에 느낌표가 있음) */

    //   - 단순 주석
    ///  - 외부 라인 문서 (정확히 슬래시 3개)
    //// - 단순 주석

    /*   - 단순 주석 */
    /**  - 외부 블록 문서 (정확히) 별표 2개 */
    /*** - 단순 주석 */

    pub mod inner_module {}

    pub mod nested_comments {
        /* Rust에서는 /* /* 주석을 중첩할 수 있습니다 */ */ */

        // 세 가지 유형의 블록 주석은 다른 유형 내에 포함되거나 중첩될 수 있습니다:

        /*   /* */  /** */  /*! */  */
        /*!  /* */  /** */  /*! */  */
        /**  /* */  /** */  /*! */  */
        pub mod dummy_item {}
    }

    pub mod degenerate_cases {
        // 비어 있는 내부 라인 문서
        //!

        // 비어 있는 내부 블록 문서
        /*!*/

        // 비어 있는 라인 주석
        //

        // 비어 있는 외부 라인 문서
        ///

        // 비어 있는 블록 주석
        /**/

        pub mod dummy_item {}

        // 비어 있는 2-별표 블록은 문서 블록이 아니라 블록 주석입니다.
        /***/

    }

    /* 다음은 외부 문서 주석이 문서를 받을 항목을 요구하기 때문에 허용되지 않습니다 */

    /// 내 항목은 어디에 있나요?
<span class="boring">  mod boo {}
</span>}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p>r[lex.whitespace]</p>
<h1 id="공백"><a class="header" href="#공백">공백</a></h1>
<p>r[whitespace.syntax]</p>
<pre><code class="language-grammar lexer">@root WHITESPACE -&gt;
      U+0009 // Horizontal tab, `'\t'`
    | U+000A // Line feed, `'\n'`
    | U+000B // Vertical tab
    | U+000C // Form feed
    | U+000D // Carriage return, `'\r'`
    | U+0020 // Space, `' '`
    | U+0085 // Next line
    | U+200E // Left-to-right mark
    | U+200F // Right-to-left mark
    | U+2028 // Line separator
    | U+2029 // Paragraph separator

TAB -&gt; U+0009 // Horizontal tab, `'\t'`

LF -&gt; U+000A  // Line feed, `'\n'`

CR -&gt; U+000D  // Carriage return, `'\r'`
</code></pre>
<p>r[lex.whitespace.intro] Whitespace is any non-empty string containing only characters that have the <a href="https://www.unicode.org/reports/tr31/"><code>Pattern_White_Space</code></a> Unicode property.</p>
<p>r[lex.whitespace.token-sep] Rust is a “free-form” language, meaning that all forms of whitespace serve only to separate <em>tokens</em> in the grammar, and have no semantic significance.</p>
<p>r[lex.whitespace.replacement] A Rust program has identical meaning if each whitespace element is replaced with any other legal whitespace element, such as a single space character.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[lex.token]</p>
<h1 id="토큰"><a class="header" href="#토큰">토큰</a></h1>
<p>r[lex.token.syntax]</p>
<pre><code class="language-grammar lexer">Token -&gt;
      RESERVED_TOKEN
    | RAW_IDENTIFIER
    | CHAR_LITERAL
    | STRING_LITERAL
    | RAW_STRING_LITERAL
    | BYTE_LITERAL
    | BYTE_STRING_LITERAL
    | RAW_BYTE_STRING_LITERAL
    | C_STRING_LITERAL
    | RAW_C_STRING_LITERAL
    | FLOAT_LITERAL
    | INTEGER_LITERAL
    | LIFETIME_TOKEN
    | PUNCTUATION
    | IDENTIFIER_OR_KEYWORD
</code></pre>
<p>r[lex.token.intro] Tokens are primitive productions in the grammar defined by regular (non-recursive) languages.  Rust source input can be broken down into the following kinds of tokens:</p>
<ul>
<li><a href="keywords.html">키워드</a></li>
<li><a href="identifiers.html">식별자</a></li>
<li><a href="tokens.html#literals">리터럴</a></li>
<li><a href="tokens.html#lifetimes-and-loop-labels">라이프타임</a></li>
<li><a href="tokens.html#punctuation">구두점</a></li>
<li><a href="tokens.html#delimiters">구분자</a></li>
</ul>
<p>이 문서의 문법에서 “단순” 토큰은 <a href="notation.html#string-table-productions">문자열 테이블 생성</a> 형식으로 주어지며, <code>monospace</code> 글꼴로 나타납니다.</p>
<p>r[lex.token.literal]</p>
<h2 id="리터럴"><a class="header" href="#리터럴">리터럴</a></h2>
<p>리터럴은 <a href="expressions/literal-expr.html">리터럴 표현식</a>에 사용되는 토큰입니다.</p>
<h3 id="예시-1"><a class="header" href="#예시-1">예시</a></h3>
<h4 id="문자와-문자열"><a class="header" href="#문자와-문자열">문자와 문자열</a></h4>
<div class="table-wrapper"><table><thead><tr><th></th><th>예시</th><th><code>#</code> 세트<sup class="footnote-reference"><a href="#nsets">1</a></sup></th><th>문자</th><th>이스케이프</th></tr></thead><tbody>
<tr><td><a href="tokens.html#character-literals">문자</a></td><td><code>'H'</code></td><td>0</td><td>모든 유니코드</td><td><a href="tokens.html#quote-escapes">인용</a> &amp; <a href="tokens.html#ascii-escapes">ASCII</a> &amp; <a href="tokens.html#unicode-escapes">유니코드</a></td></tr>
<tr><td><a href="tokens.html#string-literals">문자열</a></td><td><code>"hello"</code></td><td>0</td><td>모든 유니코드</td><td><a href="tokens.html#quote-escapes">인용</a> &amp; <a href="tokens.html#ascii-escapes">ASCII</a> &amp; <a href="tokens.html#unicode-escapes">유니코드</a></td></tr>
<tr><td><a href="tokens.html#raw-string-literals">원시 문자열</a></td><td><code>r#"hello"#</code></td><td>&lt;256</td><td>모든 유니코드</td><td><code>N/A</code></td></tr>
<tr><td><a href="tokens.html#byte-literals">바이트</a></td><td><code>b'H'</code></td><td>0</td><td>모든 ASCII</td><td><a href="tokens.html#quote-escapes">인용</a> &amp; <a href="tokens.html#byte-escapes">바이트</a></td></tr>
<tr><td><a href="tokens.html#byte-string-literals">바이트 문자열</a></td><td><code>b"hello"</code></td><td>0</td><td>모든 ASCII</td><td><a href="tokens.html#quote-escapes">인용</a> &amp; <a href="tokens.html#byte-escapes">바이트</a></td></tr>
<tr><td><a href="tokens.html#raw-byte-string-literals">원시 바이트 문자열</a></td><td><code>br#"hello"#</code></td><td>&lt;256</td><td>모든 ASCII</td><td><code>N/A</code></td></tr>
<tr><td><a href="tokens.html#c-string-literals">C 문자열</a></td><td><code>c"hello"</code></td><td>0</td><td>모든 유니코드</td><td><a href="tokens.html#quote-escapes">인용</a> &amp; <a href="tokens.html#byte-escapes">바이트</a> &amp; <a href="tokens.html#unicode-escapes">유니코드</a></td></tr>
<tr><td><a href="tokens.html#raw-c-string-literals">원시 C 문자열</a></td><td><code>cr#"hello"#</code></td><td>&lt;256</td><td>모든 유니코드</td><td><code>N/A</code></td></tr>
</tbody></table>
</div>
<div class="footnote-definition" id="nsets"><sup class="footnote-definition-label">1</sup>
<p>동일한 리터럴의 각 면에 있는 <code>#</code>의 수는 동일해야 합니다.</p>
</div>
<h4 id="ascii-이스케이프"><a class="header" href="#ascii-이스케이프">ASCII 이스케이프</a></h4>
<div class="table-wrapper"><table><thead><tr><th></th><th>이름</th></tr></thead><tbody>
<tr><td><code>\x41</code></td><td>7-bit character code (exactly 2 hex digits, up to 0x7F)</td></tr>
<tr><td><code>\n</code></td><td>새 줄</td></tr>
<tr><td><code>\r</code></td><td>캐리지 리턴</td></tr>
<tr><td><code>\t</code></td><td>탭</td></tr>
<tr><td><code>\\</code></td><td>백슬래시</td></tr>
<tr><td><code>\0</code></td><td>널</td></tr>
</tbody></table>
</div>
<h4 id="바이트-이스케이프"><a class="header" href="#바이트-이스케이프">바이트 이스케이프</a></h4>
<div class="table-wrapper"><table><thead><tr><th></th><th>이름</th></tr></thead><tbody>
<tr><td><code>\x7F</code></td><td>8-bit character code (exactly 2 hex digits)</td></tr>
<tr><td><code>\n</code></td><td>새 줄</td></tr>
<tr><td><code>\r</code></td><td>캐리지 리턴</td></tr>
<tr><td><code>\t</code></td><td>탭</td></tr>
<tr><td><code>\\</code></td><td>백슬래시</td></tr>
<tr><td><code>\0</code></td><td>널</td></tr>
</tbody></table>
</div>
<h4 id="유니코드-이스케이프"><a class="header" href="#유니코드-이스케이프">유니코드 이스케이프</a></h4>
<div class="table-wrapper"><table><thead><tr><th></th><th>이름</th></tr></thead><tbody>
<tr><td><code>\u{7FFF}</code></td><td>24-bit Unicode character code (up to 6 hex digits)</td></tr>
</tbody></table>
</div>
<h4 id="인용-이스케이프"><a class="header" href="#인용-이스케이프">인용 이스케이프</a></h4>
<div class="table-wrapper"><table><thead><tr><th></th><th>이름</th></tr></thead><tbody>
<tr><td><code>\'</code></td><td>작은따옴표</td></tr>
<tr><td>큰따옴표</td><td>큰따옴표</td></tr>
</tbody></table>
</div>
<h4 id="숫자"><a class="header" href="#숫자">숫자</a></h4>
<div class="table-wrapper"><table><thead><tr><th><a href="tokens.html#number-literals">숫자 리터럴</a><sup class="footnote-reference"><a href="#nl">2</a></sup></th><th>예시</th><th>지수</th></tr></thead><tbody>
<tr><td>10진수 정수</td><td><code>98_222</code></td><td><code>N/A</code></td></tr>
<tr><td>16진수 정수</td><td><code>0xff</code></td><td><code>N/A</code></td></tr>
<tr><td>8진수 정수</td><td><code>0o77</code></td><td><code>N/A</code></td></tr>
<tr><td>2진수 정수</td><td><code>0b1111_0000</code></td><td><code>N/A</code></td></tr>
<tr><td>부동 소수점</td><td><code>123.0E+77</code></td><td><code>선택 사항</code></td></tr>
</tbody></table>
</div>
<div class="footnote-definition" id="nl"><sup class="footnote-definition-label">2</sup>
<p>모든 숫자 리터럴은 <code>_</code>를 시각적 구분자로 허용합니다: <code>1_234.0E+18f64</code></p>
</div>
<p>r[lex.token.literal.suffix]</p>
<h4 id="접미사"><a class="header" href="#접미사">접미사</a></h4>
<p>r[lex.token.literal.literal.suffix.intro] A suffix is a sequence of characters following the primary part of a literal (without intervening whitespace), of the same form as a non-raw identifier or keyword.</p>
<p>r[lex.token.literal.suffix.syntax]</p>
<pre><code class="language-grammar lexer">SUFFIX -&gt; IDENTIFIER_OR_KEYWORD _except `_`_

SUFFIX_NO_E -&gt; SUFFIX _not beginning with `e` or `E`_
</code></pre>
<p>r[lex.token.literal.suffix.validity] Any kind of literal (string, integer, etc) with any suffix is valid as a token.</p>
<p>어떤 접미사가 붙은 리터럴 토큰도 오류 없이 매크로에 전달될 수 있습니다. 매크로 자체는 그러한 토큰을 해석하는 방법과 오류를 발생시킬지 여부를 결정합니다. 특히, 예제 매크로의 <code>literal</code> 프래그먼트 지정자는 임의의 접미사가 붙은 리터럴 토큰과 일치합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! blackhole { ($tt:tt) =&gt; () }
macro_rules! blackhole_lit { ($l:literal) =&gt; () }

blackhole!("string"suffix); // OK
blackhole_lit!(1suffix); // OK
<span class="boring">}</span></code></pre></pre>
<p>r[lex.token.literal.suffix.parse] However, suffixes on literal tokens which are interpreted as literal expressions or patterns are restricted. Any suffixes are rejected on non-numeric literal tokens, and numeric literal tokens are accepted only with suffixes from the list below.</p>
<div class="table-wrapper"><table><thead><tr><th>정수</th><th>부동 소수점</th></tr></thead><tbody>
<tr><td><code>u8</code>, <code>i8</code>, <code>u16</code>, <code>i16</code>, <code>u32</code>, <code>i32</code>, <code>u64</code>, <code>i64</code>, <code>u128</code>, <code>i128</code>, <code>usize</code>, <code>isize</code></td><td><code>f32</code>, <code>f64</code></td></tr>
</tbody></table>
</div>
<h3 id="문자-및-문자열-리터럴"><a class="header" href="#문자-및-문자열-리터럴">문자 및 문자열 리터럴</a></h3>
<p>r[lex.token.literal.char]</p>
<h4 id="문자-리터럴"><a class="header" href="#문자-리터럴">문자 리터럴</a></h4>
<p>r[lex.token.literal.char.syntax]</p>
<pre><code class="language-grammar lexer">CHAR_LITERAL -&gt;
    `'`
        ( ~[`'` `\` LF CR TAB] | QUOTE_ESCAPE | ASCII_ESCAPE | UNICODE_ESCAPE )
    `'` SUFFIX?

QUOTE_ESCAPE -&gt; `\'` | `\"`

ASCII_ESCAPE -&gt;
      `\x` OCT_DIGIT HEX_DIGIT
    | `\n` | `\r` | `\t` | `\\` | `\0`

UNICODE_ESCAPE -&gt;
    `\u{` ( HEX_DIGIT `_`* ){1..6} _valid hex char value_ `}`[^valid-hex-char]
</code></pre>
<div class="footnote-definition" id="valid-hex-char"><sup class="footnote-definition-label">3</sup>
<p>See [lex.token.literal.char-escape.unicode].</p>
</div>
<p>r[lex.token.literal.char.intro] A <em>character literal</em> is a single Unicode character enclosed within two <code>U+0027</code> (single-quote) characters, with the exception of <code>U+0027</code> itself, which must be <em>escaped</em> by a preceding <code>U+005C</code> character (<code>\</code>).</p>
<p>r[lex.token.literal.str]</p>
<h4 id="문자열-리터럴"><a class="header" href="#문자열-리터럴">문자열 리터럴</a></h4>
<p>r[lex.token.literal.str.syntax]</p>
<pre><code class="language-grammar lexer">STRING_LITERAL -&gt;
    `"` (
        ~[`"` `\` CR]
      | QUOTE_ESCAPE
      | ASCII_ESCAPE
      | UNICODE_ESCAPE
      | STRING_CONTINUE
    )* `"` SUFFIX?

STRING_CONTINUE -&gt; `\` LF
</code></pre>
<p>r[lex.token.literal.str.intro] A <em>string literal</em> is a sequence of any Unicode characters enclosed within two <code>U+0022</code> (double-quote) characters, with the exception of <code>U+0022</code> itself, which must be <em>escaped</em> by a preceding <code>U+005C</code> character (<code>\</code>).</p>
<p>r[lex.token.literal.str.linefeed] Line-breaks, represented by the  character <code>U+000A</code> (LF), are allowed in string literals. The character <code>U+000D</code> (CR) may not appear in a string literal. When an unescaped <code>U+005C</code> character (<code>\</code>) occurs immediately before a line break, the line break does not appear in the string represented by the token. See <a href="expressions/literal-expr.html#string-continuation-escapes">String continuation escapes</a> for details.</p>
<p>r[lex.token.literal.char-escape]</p>
<h4 id="문자-이스케이프"><a class="header" href="#문자-이스케이프">문자 이스케이프</a></h4>
<p>r[lex.token.literal.char-escape.intro] Some additional <em>escapes</em> are available in either character or non-raw string literals. An escape starts with a <code>U+005C</code> (<code>\</code>) and continues with one of the following forms:</p>
<p>r[lex.token.literal.char-escape.ascii]</p>
<ul>
<li>_7비트 코드 포인트 이스케이프_는 <code>U+0078</code>(<code>x</code>)로 시작하며, <code>0x7F</code>까지의 값을 가진 정확히 두 개의 _16진수 숫자_가 뒤따릅니다. 이는 제공된 16진수 값과 동일한 값을 가진 ASCII 문자를 나타냅니다. 더 높은 값은 유니코드 코드 포인트를 의미하는지 바이트 값을 의미하는지 모호하기 때문에 허용되지 않습니다.</li>
</ul>
<p>r[lex.token.literal.char-escape.unicode]</p>
<ul>
<li>A <em>24-bit code point escape</em> starts with <code>U+0075</code> (<code>u</code>) and is followed by up to six <em>hex digits</em> surrounded by braces <code>U+007B</code> (<code>{</code>) and <code>U+007D</code> (<code>}</code>). It denotes the Unicode code point equal to the provided hex value. The value must be a valid Unicode scalar value.</li>
</ul>
<p>r[lex.token.literal.char-escape.whitespace]</p>
<ul>
<li>_공백 이스케이프_는 <code>U+006E</code>(<code>n</code>), <code>U+0072</code>(<code>r</code>), 또는 <code>U+0074</code>(<code>t</code>) 문자 중 하나이며, 각각 유니코드 값 <code>U+000A</code>(LF), <code>U+000D</code>(CR) 또는 <code>U+0009</code>(HT)를 나타냅니다.</li>
</ul>
<p>r[lex.token.literal.char-escape.null]</p>
<ul>
<li>_널 이스케이프_는 <code>U+0030</code>(<code>0</code>) 문자이며 유니코드 값 <code>U+0000</code>(NUL)을 나타냅니다.</li>
</ul>
<p>r[lex.token.literal.char-escape.slash]</p>
<ul>
<li>The <em>backslash escape</em> is the character <code>U+005C</code> (<code>\</code>) which must be escaped in order to denote itself.</li>
</ul>
<p>r[lex.token.literal.str-raw]</p>
<h4 id="원시-문자열-리터럴"><a class="header" href="#원시-문자열-리터럴">원시 문자열 리터럴</a></h4>
<p>r[lex.token.literal.str-raw.syntax]</p>
<pre><code class="language-grammar lexer">RAW_STRING_LITERAL -&gt; `r` RAW_STRING_CONTENT SUFFIX?

RAW_STRING_CONTENT -&gt;
      `"` ( ~CR )*? `"`
    | `#` RAW_STRING_CONTENT `#`
</code></pre>
<p>r[lex.token.literal.str-raw.intro] Raw string literals do not process any escapes. They start with the character <code>U+0072</code> (<code>r</code>), followed by fewer than 256 of the character <code>U+0023</code> (<code>#</code>) and a <code>U+0022</code> (double-quote) character.</p>
<p>r[lex.token.literal.str-raw.body] The <em>raw string body</em> can contain any sequence of Unicode characters other than <code>U+000D</code> (CR). It is terminated only by another <code>U+0022</code> (double-quote) character, followed by the same number of <code>U+0023</code> (<code>#</code>) characters that preceded the opening <code>U+0022</code> (double-quote) character.</p>
<p>r[lex.token.literal.str-raw.content] All Unicode characters contained in the raw string body represent themselves, the characters <code>U+0022</code> (double-quote) (except when followed by at least as many <code>U+0023</code> (<code>#</code>) characters as were used to start the raw string literal) or <code>U+005C</code> (<code>\</code>) do not have any special meaning.</p>
<p>문자열 리터럴 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>"foo"; r"foo";                     // foo
"\"foo\""; r#""foo""#;             // "foo"

"foo #\"# bar";
r##"foo #"# bar"##;                // foo #"# bar

"\x52"; "R"; r"R";                 // R
"\\x52"; r"\x52";                  // \x52
<span class="boring">}</span></code></pre></pre>
<h3 id="바이트-및-바이트-문자열-리터럴"><a class="header" href="#바이트-및-바이트-문자열-리터럴">바이트 및 바이트 문자열 리터럴</a></h3>
<p>r[lex.token.byte]</p>
<h4 id="바이트-리터럴"><a class="header" href="#바이트-리터럴">바이트 리터럴</a></h4>
<p>r[lex.token.byte.syntax]</p>
<pre><code class="language-grammar lexer">BYTE_LITERAL -&gt;
    `b'` ( ASCII_FOR_CHAR | BYTE_ESCAPE )  `'` SUFFIX?

ASCII_FOR_CHAR -&gt;
    &lt;any ASCII (i.e. 0x00 to 0x7F) except `'`, `\`, LF, CR, or TAB&gt;

BYTE_ESCAPE -&gt;
      `\x` HEX_DIGIT HEX_DIGIT
    | `\n` | `\r` | `\t` | `\\` | `\0` | `\'` | `\"`
</code></pre>
<p>r[lex.token.byte.intro] A <em>byte literal</em> is a single ASCII character (in the <code>U+0000</code> to <code>U+007F</code> range) or a single <em>escape</em> preceded by the characters <code>U+0062</code> (<code>b</code>) and <code>U+0027</code> (single-quote), and followed by the character <code>U+0027</code>. If the character <code>U+0027</code> is present within the literal, it must be <em>escaped</em> by a preceding <code>U+005C</code> (<code>\</code>) character. It is equivalent to a <code>u8</code> unsigned 8-bit integer <em>number literal</em>.</p>
<p>r[lex.token.str-byte]</p>
<h4 id="바이트-문자열-리터럴"><a class="header" href="#바이트-문자열-리터럴">바이트 문자열 리터럴</a></h4>
<p>r[lex.token.str-byte.syntax]</p>
<pre><code class="language-grammar lexer">BYTE_STRING_LITERAL -&gt;
    `b"` ( ASCII_FOR_STRING | BYTE_ESCAPE | STRING_CONTINUE )* `"` SUFFIX?

ASCII_FOR_STRING -&gt;
    &lt;any ASCII (i.e 0x00 to 0x7F) except `"`, `\`, or CR&gt;
</code></pre>
<p>r[lex.token.str-byte.intro] A non-raw <em>byte string literal</em> is a sequence of ASCII characters and <em>escapes</em>, preceded by the characters <code>U+0062</code> (<code>b</code>) and <code>U+0022</code> (double-quote), and followed by the character <code>U+0022</code>. If the character <code>U+0022</code> is present within the literal, it must be <em>escaped</em> by a preceding <code>U+005C</code> (<code>\</code>) character. Alternatively, a byte string literal can be a <em>raw byte string literal</em>, defined below.</p>
<p>r[lex.token.str-byte.linefeed] Line-breaks, represented by the  character <code>U+000A</code> (LF), are allowed in byte string literals. The character <code>U+000D</code> (CR) may not appear in a byte string literal. When an unescaped <code>U+005C</code> character (<code>\</code>) occurs immediately before a line break, the line break does not appear in the string represented by the token. See <a href="expressions/literal-expr.html#string-continuation-escapes">String continuation escapes</a> for details.</p>
<p>r[lex.token.str-byte.escape] Some additional <em>escapes</em> are available in either byte or non-raw byte string literals. An escape starts with a <code>U+005C</code> (<code>\</code>) and continues with one of the following forms:</p>
<p>r[lex.token.str-byte.escape-byte]</p>
<ul>
<li>_바이트 이스케이프_는 <code>U+0078</code>(<code>x</code>)로 시작하며, 정확히 두 개의 _16진수 숫자_가 뒤따릅니다. 이는 제공된 16진수 값과 동일한 바이트를 나타냅니다.</li>
</ul>
<p>r[lex.token.str-byte.escape-whitespace]</p>
<ul>
<li>_공백 이스케이프_는 <code>U+006E</code>(<code>n</code>), <code>U+0072</code>(<code>r</code>), 또는 <code>U+0074</code>(<code>t</code>) 문자 중 하나이며, 각각 바이트 값 <code>0x0A</code>(ASCII LF), <code>0x0D</code>(ASCII CR) 또는 <code>0x09</code>(ASCII HT)를 나타냅니다.</li>
</ul>
<p>r[lex.token.str-byte.escape-null]</p>
<ul>
<li>_널 이스케이프_는 <code>U+0030</code>(<code>0</code>) 문자이며 바이트 값 <code>0x00</code>(ASCII NUL)을 나타냅니다.</li>
</ul>
<p>r[lex.token.str-byte.escape-slash]</p>
<ul>
<li>The <em>backslash escape</em> is the character <code>U+005C</code> (<code>\</code>) which must be escaped in order to denote its ASCII encoding <code>0x5C</code>.</li>
</ul>
<p>r[lex.token.str-byte-raw]</p>
<h4 id="원시-바이트-문자열-리터럴"><a class="header" href="#원시-바이트-문자열-리터럴">원시 바이트 문자열 리터럴</a></h4>
<p>r[lex.token.str-byte-raw.syntax]</p>
<pre><code class="language-grammar lexer">RAW_BYTE_STRING_LITERAL -&gt;
    `br` RAW_BYTE_STRING_CONTENT SUFFIX?

RAW_BYTE_STRING_CONTENT -&gt;
      `"` ASCII_FOR_RAW*? `"`
    | `#` RAW_BYTE_STRING_CONTENT `#`

ASCII_FOR_RAW -&gt;
    &lt;any ASCII (i.e. 0x00 to 0x7F) except CR&gt;
</code></pre>
<p>r[lex.token.str-byte-raw.intro] Raw byte string literals do not process any escapes. They start with the character <code>U+0062</code> (<code>b</code>), followed by <code>U+0072</code> (<code>r</code>), followed by fewer than 256 of the character <code>U+0023</code> (<code>#</code>), and a <code>U+0022</code> (double-quote) character.</p>
<p>r[lex.token.str-byte-raw.body] The <em>raw string body</em> can contain any sequence of ASCII characters other than <code>U+000D</code> (CR). It is terminated only by another <code>U+0022</code> (double-quote) character, followed by the same number of <code>U+0023</code> (<code>#</code>) characters that preceded the opening <code>U+0022</code> (double-quote) character. A raw byte string literal can not contain any non-ASCII byte.</p>
<p>r[lex.token.literal.str-byte-raw.content] All characters contained in the raw string body represent their ASCII encoding, the characters <code>U+0022</code> (double-quote) (except when followed by at least as many <code>U+0023</code> (<code>#</code>) characters as were used to start the raw string literal) or <code>U+005C</code> (<code>\</code>) do not have any special meaning.</p>
<p>바이트 문자열 리터럴 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>b"foo"; br"foo";                     // foo
b"\"foo\""; br#""foo""#;             // "foo"

b"foo #\"# bar";
br##"foo #"# bar"##;                 // foo #"# bar

b"\x52"; b"R"; br"R";                // R
b"\\x52"; br"\x52";                  // \x52
<span class="boring">}</span></code></pre></pre>
<h3 id="c-문자열-및-원시-c-문자열-리터럴"><a class="header" href="#c-문자열-및-원시-c-문자열-리터럴">C 문자열 및 원시 C 문자열 리터럴</a></h3>
<p>r[lex.token.str-c]</p>
<h4 id="c-문자열-리터럴"><a class="header" href="#c-문자열-리터럴">C 문자열 리터럴</a></h4>
<p>r[lex.token.str-c.syntax]</p>
<pre><code class="language-grammar lexer">C_STRING_LITERAL -&gt;
    `c"` (
        ~[`"` `\` CR NUL]
      | BYTE_ESCAPE _except `\0` or `\x00`_
      | UNICODE_ESCAPE _except `\u{0}`, `\u{00}`, …, `\u{000000}`_
      | STRING_CONTINUE
    )* `"` SUFFIX?

</code></pre>
<p>r[lex.token.str-c.intro] A <em>C string literal</em> is a sequence of Unicode characters and <em>escapes</em>, preceded by the characters <code>U+0063</code> (<code>c</code>) and <code>U+0022</code> (double-quote), and followed by the character <code>U+0022</code>. If the character <code>U+0022</code> is present within the literal, it must be <em>escaped</em> by a preceding <code>U+005C</code> (<code>\</code>) character. Alternatively, a C string literal can be a <em>raw C string literal</em>, defined below.</p>
<p>r[lex.token.str-c.null] C strings are implicitly terminated by byte <code>0x00</code>, so the C string literal <code>c""</code> is equivalent to manually constructing a <code>&amp;CStr</code> from the byte string literal <code>b"\x00"</code>. Other than the implicit terminator, byte <code>0x00</code> is not permitted within a C string.</p>
<p>r[lex.token.str-c.linefeed] Line-breaks, represented by the  character <code>U+000A</code> (LF), are allowed in C string literals. The character <code>U+000D</code> (CR) may not appear in a C string literal. When an unescaped <code>U+005C</code> character (<code>\</code>) occurs immediately before a line break, the line break does not appear in the string represented by the token. See <a href="expressions/literal-expr.html#string-continuation-escapes">String continuation escapes</a> for details.</p>
<p>r[lex.token.str-c.escape] Some additional <em>escapes</em> are available in non-raw C string literals. An escape starts with a <code>U+005C</code> (<code>\</code>) and continues with one of the following forms:</p>
<p>r[lex.token.str-c.escape-byte]</p>
<ul>
<li>_바이트 이스케이프_는 <code>U+0078</code>(<code>x</code>)로 시작하며, 정확히 두 개의 _16진수 숫자_가 뒤따릅니다. 이는 제공된 16진수 값과 동일한 바이트를 나타냅니다.</li>
</ul>
<p>r[lex.token.str-c.escape-unicode]</p>
<ul>
<li>_24비트 코드 포인트 이스케이프_는 <code>U+0075</code>(<code>u</code>)로 시작하고 중괄호 <code>U+007B</code>(<code>{</code>) 및 <code>U+007D</code>(<code>}</code>)로 둘러싸인 최대 6개의 _16진수 숫자_가 뒤따릅니다. 제공된 16진수 값과 동일한 유니코드 코드 포인트를 나타내며 UTF-8로 인코딩됩니다.</li>
</ul>
<p>r[lex.token.str-c.escape-whitespace]</p>
<ul>
<li>_공백 이스케이프_는 <code>U+006E</code>(<code>n</code>), <code>U+0072</code>(<code>r</code>), 또는 <code>U+0074</code>(<code>t</code>) 문자 중 하나이며, 각각 바이트 값 <code>0x0A</code>(ASCII LF), <code>0x0D</code>(ASCII CR) 또는 <code>0x09</code>(ASCII HT)를 나타냅니다.</li>
</ul>
<p>r[lex.token.str-c.escape-slash]</p>
<ul>
<li>The <em>backslash escape</em> is the character <code>U+005C</code> (<code>\</code>) which must be escaped in order to denote its ASCII encoding <code>0x5C</code>.</li>
</ul>
<p>r[lex.token.str-c.char-unicode] A C string represents bytes with no defined encoding, but a C string literal may contain Unicode characters above <code>U+007F</code>. Such characters will be replaced with the bytes of that character’s UTF-8 representation.</p>
<p>다음 C 문자열 리터럴은 동일합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>c"æ";        // 라틴어 소문자 AE (U+00E6)
c"\u{00E6}";
c"\xC3\xA6";
<span class="boring">}</span></code></pre></pre>
<p>r[lex.token.str-c.edition2021]</p>
<blockquote>
<p>[!EDITION-2021] C string literals are accepted in the 2021 edition or later. In earlier editions the token <code>c""</code> is lexed as <code>c ""</code>.</p>
</blockquote>
<p>r[lex.token.str-c-raw]</p>
<h4 id="원시-c-문자열-리터럴"><a class="header" href="#원시-c-문자열-리터럴">원시 C 문자열 리터럴</a></h4>
<p>r[lex.token.str-c-raw.syntax]</p>
<pre><code class="language-grammar lexer">RAW_C_STRING_LITERAL -&gt;
    `cr` RAW_C_STRING_CONTENT SUFFIX?

RAW_C_STRING_CONTENT -&gt;
      `"` ( ~[CR NUL] )*? `"`
    | `#` RAW_C_STRING_CONTENT `#`
</code></pre>
<p>r[lex.token.str-c-raw.intro] Raw C string literals do not process any escapes. They start with the character <code>U+0063</code> (<code>c</code>), followed by <code>U+0072</code> (<code>r</code>), followed by fewer than 256 of the character <code>U+0023</code> (<code>#</code>), and a <code>U+0022</code> (double-quote) character.</p>
<p>r[lex.token.str-c-raw.body] The <em>raw C string body</em> can contain any sequence of Unicode characters other than <code>U+0000</code> (NUL) and <code>U+000D</code> (CR). It is terminated only by another <code>U+0022</code> (double-quote) character, followed by the same number of <code>U+0023</code> (<code>#</code>) characters that preceded the opening <code>U+0022</code> (double-quote) character.</p>
<p>r[lex.token.str-c-raw.content] All characters contained in the raw C string body represent themselves in UTF-8 encoding. The characters <code>U+0022</code> (double-quote) (except when followed by at least as many <code>U+0023</code> (<code>#</code>) characters as were used to start the raw C string literal) or <code>U+005C</code> (<code>\</code>) do not have any special meaning.</p>
<p>r[lex.token.str-c-raw.edition2021]</p>
<blockquote>
<p>[!EDITION-2021] Raw C string literals are accepted in the 2021 edition or later. In earlier editions the token <code>cr""</code> is lexed as <code>cr ""</code>, and <code>cr#""#</code> is lexed as <code>cr #""#</code> (which is non-grammatical).</p>
</blockquote>
<h4 id="c-문자열-및-원시-c-문자열-리터럴의-예"><a class="header" href="#c-문자열-및-원시-c-문자열-리터럴의-예">C 문자열 및 원시 C 문자열 리터럴의 예</a></h4>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>c"foo"; cr"foo";                     // foo
c"\"foo\""; cr#""foo""#;             // "foo"

c"foo #\"# bar";
cr##"foo #"# bar"##;                 // foo #"# bar

c"\x52"; c"R"; cr"R";                // R
c"\\x52"; cr"\x52";                  // \x52
<span class="boring">}</span></code></pre></pre>
<p>r[lex.token.literal.num]</p>
<h3 id="숫자-리터럴"><a class="header" href="#숫자-리터럴">숫자 리터럴</a></h3>
<p>_숫자 리터럴_은 <em>정수 리터럴</em> 또는 _부동 소수점 리터럴_입니다. 두 종류의 리터럴을 인식하는 문법은 혼합되어 있습니다.</p>
<p>r[lex.token.literal.int]</p>
<h4 id="정수-리터럴"><a class="header" href="#정수-리터럴">정수 리터럴</a></h4>
<p>r[lex.token.literal.int.syntax]</p>
<pre><code class="language-grammar lexer">INTEGER_LITERAL -&gt;
    ( BIN_LITERAL | OCT_LITERAL | HEX_LITERAL | DEC_LITERAL ) SUFFIX_NO_E?

DEC_LITERAL -&gt; DEC_DIGIT (DEC_DIGIT|`_`)*

BIN_LITERAL -&gt; `0b` `_`* BIN_DIGIT (BIN_DIGIT|`_`)*

OCT_LITERAL -&gt; `0o` `_`* OCT_DIGIT (OCT_DIGIT|`_`)*

HEX_LITERAL -&gt; `0x` `_`* HEX_DIGIT (HEX_DIGIT|`_`)*

BIN_DIGIT -&gt; [`0`-`1`]

OCT_DIGIT -&gt; [`0`-`7`]

DEC_DIGIT -&gt; [`0`-`9`]

HEX_DIGIT -&gt; [`0`-`9` `a`-`f` `A`-`F`]
</code></pre>
<p>r[lex.token.literal.int.kind] An <em>integer literal</em> has one of four forms:</p>
<p>r[lex.token.literal.int.kind-dec]</p>
<ul>
<li>_십진수 리터럴_은 _십진수 숫자_로 시작하고 _십진수 숫자_와 _밑줄_의 혼합으로 이어집니다.</li>
</ul>
<p>r[lex.token.literal.int.kind-hex]</p>
<ul>
<li>_16진수 리터럴_은 문자 시퀀스 <code>U+0030</code> <code>U+0078</code>(<code>0x</code>)로 시작하고 16진수 숫자와 밑줄의 혼합(최소 한 자리 이상)으로 이어집니다.</li>
</ul>
<p>r[lex.token.literal.int.kind-oct]</p>
<ul>
<li>_8진수 리터럴_은 문자 시퀀스 <code>U+0030</code> <code>U+006F</code>(<code>0o</code>)로 시작하고 8진수 숫자와 밑줄의 혼합(최소 한 자리 이상)으로 이어집니다.</li>
</ul>
<p>r[lex.token.literal.int.kind-bin]</p>
<ul>
<li>_2진수 리터럴_은 문자 시퀀스 <code>U+0030</code> <code>U+0062</code>(<code>0b</code>)로 시작하고 2진수 숫자와 밑줄의 혼합(최소 한 자리 이상)으로 이어집니다.</li>
</ul>
<p>r[lex.token.literal.int.restriction] Like any literal, an integer literal may be followed (immediately, without any spaces) by a suffix as described above. The suffix may not begin with <code>e</code> or <code>E</code>, as that would be interpreted as the exponent of a floating-point literal. See <a href="expressions/literal-expr.html#integer-literal-expressions">Integer literal expressions</a> for the effect of these suffixes.</p>
<p>리터럴 표현식으로 허용되는 정수 리터럴의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![allow(overflowing_literals)]
</span>123;
123i32;
123u32;
123_u32;

0xff;
0xff_u8;
0x01_f32; // 정수 7986, 부동 소수점 1.0 아님
0x01_e3;  // 정수 483, 부동 소수점 1000.0 아님

0o70;
0o70_i16;

0b1111_1111_1001_0000;
0b1111_1111_1001_0000i64;
0b________1;

0usize;

// 이것들은 타입에 비해 너무 크지만, 리터럴 표현식으로 허용됩니다.
128_i8;
256_u8;

// 이것은 정수 리터럴이며, 부동 소수점 리터럴 표현식으로 허용됩니다.
5f32;
<span class="boring">}</span></code></pre></pre>
<p>예를 들어 <code>-1i8</code>은 <code>-</code>와 <code>1i8</code>의 두 토큰으로 분석됩니다.</p>
<p>리터럴 표현식으로 허용되지 않는 정수 리터럴의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(false)] {
</span>0invalidSuffix;
123AFB43;
0b010a;
0xAB_CD_EF_GH;
0b1111_f32;
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>r[lex.token.literal.int.tuple-field]</p>
<h4 id="튜플-인덱스"><a class="header" href="#튜플-인덱스">튜플 인덱스</a></h4>
<p>r[lex.token.literal.int.tuple-field.syntax]</p>
<pre><code class="language-grammar lexer">TUPLE_INDEX -&gt; DEC_LITERAL | BIN_LITERAL | OCT_LITERAL | HEX_LITERAL
</code></pre>
<p>r[lex.token.literal.int.tuple-field.intro] A tuple index is used to refer to the fields of <a href="types/tuple.html">tuples</a>, <a href="items/structs.html">tuple structs</a>, and <a href="items/enumerations.html">tuple enum variants</a>.</p>
<p>r[lex.token.literal.int.tuple-field.eq] Tuple indices are compared with the literal token directly. Tuple indices start with <code>0</code> and each successive index increments the value by <code>1</code> as a decimal value. Thus, only decimal values will match, and the value must not have any extra <code>0</code> prefix characters.</p>
<p>Tuple indices may not include any suffixes (such as <code>usize</code>).</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let example = (개, "cat", 말);
let dog = example.0;
let cat = example.1;
// 다음 예제는 유효하지 않습니다.
let cat = example.01;  // 오류: `01`이라는 필드가 없습니다
let horse = example.0b10;  // 오류: `0b10`이라는 필드가 없습니다
let unicorn = example.0usize; // ERROR suffixes on a tuple index are invalid
let underscore = example.0_0; // ERROR no field `0_0` on type `(&amp;str, &amp;str, &amp;str)`
<span class="boring">}</span></code></pre></pre>
<p>r[lex.token.literal.float]</p>
<h4 id="부동-소수점-리터럴"><a class="header" href="#부동-소수점-리터럴">부동 소수점 리터럴</a></h4>
<p>r[lex.token.literal.float.syntax]</p>
<pre><code class="language-grammar lexer">FLOAT_LITERAL -&gt;
      DEC_LITERAL (`.` DEC_LITERAL)? FLOAT_EXPONENT SUFFIX?
    | DEC_LITERAL `.` DEC_LITERAL SUFFIX_NO_E?
    | DEC_LITERAL `.` _not immediately followed by `.`, `_` or an XID_Start character_

FLOAT_EXPONENT -&gt;
    (`e`|`E`) (`+`|`-`)? `_`* DEC_DIGIT (DEC_DIGIT|`_`)*
</code></pre>
<p>r[lex.token.literal.float.form] A <em>floating-point literal</em> has one of two forms:</p>
<ul>
<li><em>십진수 리터럴</em> 뒤에 마침표 문자 <code>U+002E</code>(<code>.</code>)가 옵니다. 선택적으로 다른 십진수 리터럴과 선택적 _지수_가 뒤따를 수 있습니다.</li>
<li>단일 <em>십진수 리터럴</em> 뒤에 _지수_가 옵니다.</li>
</ul>
<p>r[lex.token.literal.float.suffix] Like integer literals, a floating-point literal may be followed by a suffix, so long as the pre-suffix part does not end with <code>U+002E</code> (<code>.</code>). The suffix may not begin with <code>e</code> or <code>E</code> if the literal does not include an exponent. See <a href="expressions/literal-expr.html#floating-point-literal-expressions">Floating-point literal expressions</a> for the effect of these suffixes.</p>
<p>리터럴 표현식으로 허용되는 부동 소수점 리터럴의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>123.0f64;
0.1f64;
0.1f32;
12E+99_f64;
let x: f64 = 2.;
<span class="boring">}</span></code></pre></pre>
<p>This last example is different because it is not possible to use the suffix syntax with a floating point literal ending in a period. <code>2.f64</code> would attempt to call a method named <code>f64</code> on <code>2</code>.</p>
<p>예를 들어 <code>-1.0</code>은 <code>-</code>와 <code>1.0</code>의 두 토큰으로 분석됩니다.</p>
<p>리터럴 표현식으로 허용되지 않는 부동 소수점 리터럴의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(false)] {
</span>2.0f80;
2e5f80;
2e5e6;
2.0e5e6;
1.3e10u64;
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>r[lex.token.literal.reserved]</p>
<h4 id="숫자-리터럴과-유사한-예약된-형식"><a class="header" href="#숫자-리터럴과-유사한-예약된-형식">숫자 리터럴과 유사한 예약된 형식</a></h4>
<p>r[lex.token.literal.reserved.syntax]</p>
<pre><code class="language-grammar lexer">RESERVED_NUMBER -&gt;
      BIN_LITERAL [`2`-`9`]
    | OCT_LITERAL [`8`-`9`]
    | ( BIN_LITERAL | OCT_LITERAL | HEX_LITERAL ) `.` _not immediately followed by `.`, `_` or an XID_Start character_
    | ( BIN_LITERAL | OCT_LITERAL ) (`e`|`E`)
    | `0b` `_`* &lt;end of input or not BIN_DIGIT&gt;
    | `0o` `_`* &lt;end of input or not OCT_DIGIT&gt;
    | `0x` `_`* &lt;end of input or not HEX_DIGIT&gt;
    | DEC_LITERAL ( `.` DEC_LITERAL )? (`e` | `E`) (`+` | `-`)? &lt;end of input or not DEC_DIGIT&gt;

</code></pre>
<p>r[lex.token.literal.reserved.intro] The following lexical forms similar to number literals are <em>reserved forms</em>. Due to the possible ambiguity these raise, they are rejected by the tokenizer instead of being interpreted as separate tokens.</p>
<p>r[lex.token.literal.reserved.out-of-range]</p>
<ul>
<li>접미사가 없는 2진수 또는 8진수 리터럴 뒤에 공백 없이 해당 기수 범위를 벗어나는 10진수 숫자가 오는 경우.</li>
</ul>
<p>r[lex.token.literal.reserved.period]</p>
<ul>
<li>접미사가 없는 2진수, 8진수 또는 16진수 리터럴 뒤에 공백 없이 마침표 문자가 오는 경우(마침표 뒤에 오는 내용에 대한 제한은 부동 소수점 리터럴과 동일).</li>
</ul>
<p>r[lex.token.literal.reserved.exp]</p>
<ul>
<li>접미사가 없는 2진수 또는 8진수 리터럴 뒤에 공백 없이 <code>e</code> 또는 <code>E</code> 문자가 오는 경우.</li>
</ul>
<p>r[lex.token.literal.reserved.empty-with-radix]</p>
<ul>
<li>기수 접두사 중 하나로 시작하지만 유효한 2진수, 8진수 또는 16진수 리터럴이 아닌 입력 (숫자를 포함하지 않기 때문에).</li>
</ul>
<p>r[lex.token.literal.reserved.empty-exp]</p>
<ul>
<li>지수에 숫자가 없는 부동 소수점 리터럴 형식을 갖는 입력.</li>
</ul>
<p>예약된 형식의 예:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>0b0102;  // 이것은 `0b010` 뒤에 `2`가 오는 것이 아닙니다
0o1279;  // 이것은 `0o127` 뒤에 `9`가 오는 것이 아닙니다
0x80.0;  // 이것은 `0x80` 뒤에 `.`와 `0`이 오는 것이 아닙니다
0b101e;  // 이것은 접미사가 붙은 리터럴이 아니거나, `0b101` 뒤에 `e`가 오는 것이 아닙니다
0b;      // 이것은 정수 리터럴이 아니거나, `0` 뒤에 `b`가 오는 것이 아닙니다
0b_;     // 이것은 정수 리터럴이 아니거나, `0` 뒤에 `b_`가 오는 것이 아닙니다
2e;      // 이것은 부동 소수점 리터럴이 아니거나, `2` 뒤에 `e`가 오는 것이 아닙니다
2.0e;    // 이것은 부동 소수점 리터럴이 아니거나, `2.0` 뒤에 `e`가 오는 것이 아닙니다
2em;     // 이것은 접미사가 붙은 리터럴이 아니거나, `2` 뒤에 `em`이 오는 것이 아닙니다
2.0em;   // 이것은 접미사가 붙은 리터럴이 아니거나, `2.0` 뒤에 `em`이 오는 것이 아닙니다
<span class="boring">}</span></code></pre></pre>
<p>r[lex.token.life]</p>
<h2 id="라이프타임과-루프-레이블"><a class="header" href="#라이프타임과-루프-레이블">라이프타임과 루프 레이블</a></h2>
<p>r[lex.token.life.syntax]</p>
<pre><code class="language-grammar lexer">LIFETIME_TOKEN -&gt;
      RAW_LIFETIME
    | `'` IDENTIFIER_OR_KEYWORD _not immediately followed by `'`_

LIFETIME_OR_LABEL -&gt;
      RAW_LIFETIME
    | `'` NON_KEYWORD_IDENTIFIER _not immediately followed by `'`_

RAW_LIFETIME -&gt;
    `'r#` IDENTIFIER_OR_KEYWORD _not immediately followed by `'`_

RESERVED_RAW_LIFETIME -&gt; `'r#` (`_` | `crate` | `self` | `Self` | `super`) _not immediately followed by `'`_
</code></pre>
<p>r[lex.token.life.intro] Lifetime parameters and <a href="expressions/loop-expr.html">loop labels</a> use LIFETIME_OR_LABEL tokens. Any LIFETIME_TOKEN will be accepted by the lexer, and for example, can be used in macros.</p>
<p>r[lex.token.life.raw.intro] A raw lifetime is like a normal lifetime, but its identifier is prefixed by <code>r#</code>. (Note that the <code>r#</code> prefix is not included as part of the actual lifetime.)</p>
<p>r[lex.token.life.raw.allowed] Unlike a normal lifetime, a raw lifetime may be any strict or reserved keyword except the ones listed above for <code>RAW_LIFETIME</code>.</p>
<p>r[lex.token.life.raw.reserved] It is an error to use the [RESERVED_RAW_LIFETIME] token.</p>
<p>r[lex.token.life.raw.edition2021]</p>
<blockquote>
<p>[!EDITION-2021] Raw lifetimes are accepted in the 2021 edition or later. In earlier editions the token <code>'r#lt</code> is lexed as <code>'r # lt</code>.</p>
</blockquote>
<p>r[lex.token.punct]</p>
<h2 id="구두점"><a class="header" href="#구두점">구두점</a></h2>
<p>r[lex.token.punct.intro] Punctuation tokens are used as operators, separators, and other parts of the grammar.</p>
<p>r[lex.token.punct.syntax]</p>
<pre><code class="language-grammar lexer">PUNCTUATION -&gt;
      `...`
    | `..=`
    | `&lt;&lt;=`
    | `&gt;&gt;=`
    | `!=`
    | `%=`
    | `&amp;&amp;`
    | `&amp;=`
    | `*=`
    | `+=`
    | `-=`
    | `-&gt;`
    | `..`
    | `/=`
    | `::`
    | `&lt;-`
    | `&lt;&lt;`
    | `&lt;=`
    | `==`
    | `=&gt;`
    | `&gt;=`
    | `&gt;&gt;`
    | `&gt;`
    | `^=`
    | `|=`
    | `||`
    | `!`
    | `#`
    | `$`
    | `%`
    | `&amp;`
    | `(`
    | `)`
    | `*`
    | `+`
    | `,`
    | `-`
    | `.`
    | `/`
    | `:`
    | `;`
    | `&lt;`
    | `=`
    | `?`
    | `@`
    | `[`
    | `]`
    | `^`
    | `{`
    | `|`
    | `}`
    | `~`
</code></pre>
<blockquote>
<p>[!NOTE] See the <a href="syntax-index.html#operators-and-punctuation">syntax index</a> for links to how punctuation characters are used.</p>
</blockquote>
<p>r[lex.token.delim]</p>
<h2 id="구분자"><a class="header" href="#구분자">구분자</a></h2>
<p>대괄호 구두점은 문법의 다양한 부분에서 사용됩니다. 여는 대괄호는 항상 닫는 대괄호와 짝을 이루어야 합니다. 대괄호와 그 안의 토큰은 <a href="macros-by-example.html">매크로</a>에서 “토큰 트리“라고 합니다. 세 가지 유형의 대괄호는 다음과 같습니다.</p>
<div class="table-wrapper"><table><thead><tr><th>대괄호</th><th>유형</th></tr></thead><tbody>
<tr><td><code>{</code> <code>}</code></td><td>중괄호</td></tr>
<tr><td><code>[</code> <code>]</code></td><td>대괄호</td></tr>
<tr><td><code>(</code> <code>)</code></td><td>괄호</td></tr>
</tbody></table>
</div>
<p>r[lex.token.reserved]</p>
<h2 id="reserved-tokens"><a class="header" href="#reserved-tokens">Reserved tokens</a></h2>
<p>r[lex.token.reserved.intro] Several token forms are reserved for future use or to avoid confusion. It is an error for the source input to match one of these forms.</p>
<p>r[lex.token.reserved.syntax]</p>
<pre><code class="language-grammar lexer">RESERVED_TOKEN -&gt;
      RESERVED_GUARDED_STRING_LITERAL
    | RESERVED_NUMBER
    | RESERVED_POUNDS
    | RESERVED_RAW_IDENTIFIER
    | RESERVED_RAW_LIFETIME
    | RESERVED_TOKEN_DOUBLE_QUOTE
    | RESERVED_TOKEN_LIFETIME
    | RESERVED_TOKEN_POUND
    | RESERVED_TOKEN_SINGLE_QUOTE
</code></pre>
<p>r[lex.token.reserved-prefix]</p>
<h2 id="예약된-접두사"><a class="header" href="#예약된-접두사">예약된 접두사</a></h2>
<p>r[lex.token.reserved-prefix.syntax]</p>
<pre><code class="language-grammar lexer">RESERVED_TOKEN_DOUBLE_QUOTE -&gt;
    IDENTIFIER_OR_KEYWORD _except `b` or `c` or `r` or `br` or `cr`_ `"`

RESERVED_TOKEN_SINGLE_QUOTE -&gt;
    IDENTIFIER_OR_KEYWORD _except `b`_ `'`

RESERVED_TOKEN_POUND -&gt;
    IDENTIFIER_OR_KEYWORD _except `r` or `br` or `cr`_ `#`

RESERVED_TOKEN_LIFETIME -&gt;
    `'` IDENTIFIER_OR_KEYWORD _except `r`_ `#`
</code></pre>
<p>r[lex.token.reserved-prefix.intro] Some lexical forms known as <em>reserved prefixes</em> are reserved for future use.</p>
<p>r[lex.token.reserved-prefix.id] Source input which would otherwise be lexically interpreted as a non-raw identifier (or a keyword) which is immediately followed by a <code>#</code>, <code>'</code>, or <code>"</code> character (without intervening whitespace) is identified as a reserved prefix.</p>
<p>r[lex.token.reserved-prefix.raw-token] Note that raw identifiers, raw string literals, and raw byte string literals may contain a <code>#</code> character but are not interpreted as containing a reserved prefix.</p>
<p>r[lex.token.reserved-prefix.strings] Similarly the <code>r</code>, <code>b</code>, <code>br</code>, <code>c</code>, and <code>cr</code> prefixes used in raw string literals, byte literals, byte string literals, raw byte string literals, C string literals, and raw C string literals are not interpreted as reserved prefixes.</p>
<p>r[lex.token.reserved-prefix.life] Source input which would otherwise be lexically interpreted as a non-raw lifetime (or a keyword) which is immediately followed by a <code>#</code> character (without intervening whitespace) is identified as a reserved lifetime prefix.</p>
<p>r[lex.token.reserved-prefix.edition2021]</p>
<blockquote>
<p>[!EDITION-2021] Starting with the 2021 edition, reserved prefixes are reported as an error by the lexer (in particular, they cannot be passed to macros).</p>
<p>2021 에디션 이전에는 예약된 접두사가 렉서에 의해 허용되고 여러 토큰으로 해석됩니다(예: 식별자 또는 키워드에 대한 하나의 토큰 뒤에 <code>#</code> 토큰이 옴).</p>
<p>모든 에디션에서 허용되는 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! lexes {($($_:tt)*) =&gt; {}}
lexes!{a #foo}
lexes!{continue 'foo}
lexes!{match "..." {}}
lexes!{r#let#foo}         // 세 개의 토큰: r#let # foo
lexes!{'prefix #lt}
<span class="boring">}</span></code></pre></pre>
<p>2021 에디션 이전에는 허용되었지만 이후에는 거부된 예:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! lexes {($($_:tt)*) =&gt; {}}
lexes!{a#foo}
lexes!{continue'foo}
lexes!{match"..." {}}
lexes!{'prefix#lt}
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[lex.token.reserved-guards]</p>
<h2 id="예약된-가드"><a class="header" href="#예약된-가드">예약된 가드</a></h2>
<p>r[lex.token.reserved-guards.syntax]</p>
<pre><code class="language-grammar lexer">RESERVED_GUARDED_STRING_LITERAL -&gt; `#`+ STRING_LITERAL

RESERVED_POUNDS -&gt; `#`{2..}
</code></pre>
<p>r[lex.token.reserved-guards.intro] The reserved guards are syntax reserved for future use, and will generate a compile error if used.</p>
<p>r[lex.token.reserved-guards.string-literal] The <em>reserved guarded string literal</em> is a token of one or more <code>U+0023</code> (<code>#</code>) immediately followed by a [STRING_LITERAL].</p>
<p>r[lex.token.reserved-guards.pounds] The <em>reserved pounds</em> is a token of two or more <code>U+0023</code> (<code>#</code>).</p>
<p>r[lex.token.reserved-guards.edition2024]</p>
<blockquote>
<p>[!EDITION-2024] Before the 2024 edition, reserved guards are accepted by the lexer and interpreted as multiple tokens. For example, the <code>#"foo"#</code> form is interpreted as three tokens. <code>##</code> is interpreted as two tokens.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>r[macro]</p>
<h1 id="매크로"><a class="header" href="#매크로">매크로</a></h1>
<p>r[macro.intro] The functionality and syntax of Rust can be extended with custom definitions called macros. They are given names, and invoked through a consistent syntax: <code>some_extension!(...)</code>.</p>
<p>새 매크로를 정의하는 두 가지 방법이 있습니다.</p>
<ul>
<li><a href="macros-by-example.html">예제를 통한 매크로</a>는 더 높은 수준의 선언적 방식으로 새로운 구문을 정의합니다.</li>
<li><a href="procedural-macros.html">절차적 매크로</a>는 입력 토큰에 대해 작동하는 함수를 사용하여 함수와 유사한 매크로, 사용자 지정 파생 및 사용자 지정 속성을 정의합니다.</li>
</ul>
<p>r[macro.invocation]</p>
<h2 id="macro-invocation"><a class="header" href="#macro-invocation">Macro invocation</a></h2>
<p>r[macro.invocation.syntax]</p>
<pre><code class="language-grammar macros">MacroInvocation -&gt;
    SimplePath `!` DelimTokenTree

DelimTokenTree -&gt;
      `(` TokenTree* `)`
    | `[` TokenTree* `]`
    | `{` TokenTree* `}`

TokenTree -&gt;
    Token _except [delimiters][lex.token.delim]_ | DelimTokenTree

MacroInvocationSemi -&gt;
      SimplePath `!` `(` TokenTree* `)` `;`
    | SimplePath `!` `[` TokenTree* `]` `;`
    | SimplePath `!` `{` TokenTree* `}`
</code></pre>
<p>r[macro.invocation.intro] A macro invocation expands a macro at compile time and replaces the invocation with the result of the macro. Macros may be invoked in the following situations:</p>
<p>r[macro.invocation.expr]</p>
<ul>
<li><a href="expressions.html">표현식</a> 및 <a href="statements.html">문</a></li>
</ul>
<p>r[macro.invocation.pattern]</p>
<ul>
<li><a href="patterns.html">패턴</a></li>
</ul>
<p>r[macro.invocation.type]</p>
<ul>
<li><a href="types.html">유형</a></li>
</ul>
<p>r[macro.invocation.item]</p>
<ul>
<li><a href="items.html">항목</a> 포함 <a href="items/associated-items.html">연관 항목</a></li>
</ul>
<p>r[macro.invocation.nested]</p>
<ul>
<li><a href="macros-by-example.html"><code>macro_rules</code></a> 트랜스크라이버</li>
</ul>
<p>r[macro.invocation.extern]</p>
<ul>
<li><a href="items/external-blocks.html">외부 블록</a></li>
</ul>
<p>r[macro.invocation.item-statement] When used as an item or a statement, the [MacroInvocationSemi] form is used where a semicolon is required at the end when not using curly braces. <a href="visibility-and-privacy.html">Visibility qualifiers</a> are never allowed before a macro invocation or <a href="macros-by-example.html"><code>macro_rules</code></a> definition.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 표현식으로 사용됩니다.
let x = vec![1,2,3];

// 문으로 사용됩니다.
println!("안녕하세요!");

// 패턴에서 사용됩니다.
macro_rules! pat {
    ($i:ident) =&gt; (Some($i))
}

if let pat!(x) = Some(1) {
    assert_eq!(x, 1);
}

// 유형에서 사용됩니다.
macro_rules! Tuple {
    { $A:ty, $B:ty } =&gt; { ($A, $B) };
}

type N2 = Tuple!(i32, i32);

// 항목으로 사용됩니다.
<span class="boring">use std::cell::RefCell;
</span>thread_local!(static FOO: RefCell&lt;u32&gt; = RefCell::new(1));

// Used as an associated item.
macro_rules! const_maker {
    ($t:ty, $v:tt) =&gt; { const CONST: $t = $v; };
}
trait T {
    const_maker!{i32, 7}
}

// Macro calls within macros.
macro_rules! example {
    () =&gt; { println!("매크로 내의 매크로 호출!") };
}
// 외부 매크로 `example`이 확장된 후, 내부 매크로 `println`이 확장됩니다.
example!();
<span class="boring">}</span></code></pre></pre>
<p>r[macro.invocation.name-resolution]</p>
<p>Macros invocations can be resolved via two kinds of scopes:</p>
<ul>
<li>텍스트 범위
<ul>
<li><a href="macros-by-example.html#r-macro.decl.scope.textual">Textual scope <code>macro_rules</code></a></li>
</ul>
</li>
<li>Path-based scope
<ul>
<li><a href="macros-by-example.html#r-macro.decl.scope.path-based">Path-based scope <code>macro_rules</code></a></li>
<li><a href="procedural-macros.html">Procedural macros</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>r[macro.decl]</p>
<h1 id="macros-by-example"><a class="header" href="#macros-by-example">Macros by example</a></h1>
<p>r[macro.decl.syntax]</p>
<pre><code class="language-grammar macros">MacroRulesDefinition -&gt;
    `macro_rules` `!` IDENTIFIER MacroRulesDef

MacroRulesDef -&gt;
      `(` MacroRules `)` `;`
    | `[` MacroRules `]` `;`
    | `{` MacroRules `}`

MacroRules -&gt;
    MacroRule ( `;` MacroRule )* `;`?

MacroRule -&gt;
    MacroMatcher `=&gt;` MacroTranscriber

MacroMatcher -&gt;
      `(` MacroMatch* `)`
    | `[` MacroMatch* `]`
    | `{` MacroMatch* `}`

MacroMatch -&gt;
      Token _except `$` and [delimiters][lex.token.delim]_
    | MacroMatcher
    | `$` ( IDENTIFIER_OR_KEYWORD _except `crate`_ | RAW_IDENTIFIER ) `:` MacroFragSpec
    | `$` `(` MacroMatch+ `)` MacroRepSep? MacroRepOp

MacroFragSpec -&gt;
      `block` | `expr` | `expr_2021` | `ident` | `item` | `lifetime` | `literal`
    | `meta` | `pat` | `pat_param` | `path` | `stmt` | `tt` | `ty` | `vis`

MacroRepSep -&gt; Token _except [delimiters][lex.token.delim] and [MacroRepOp]_

MacroRepOp -&gt; `*` | `+` | `?`

MacroTranscriber -&gt; DelimTokenTree
</code></pre>
<p>r[macro.decl.intro] <code>macro_rules</code> allows users to define syntax extension in a declarative way.  We call such extensions “macros by example” or simply “macros”.</p>
<p>각 예제별 매크로에는 이름과 하나 이상의 _규칙_이 있습니다. 각 규칙에는 두 부분이 있습니다. 일치하는 구문을 설명하는 _매처_와 성공적으로 일치한 호출을 대체할 구문을 설명하는 _트랜스크라이버_입니다. 매처와 트랜스크라이버는 모두 구분 기호로 둘러싸여 있어야 합니다. 매크로는 표현식, 문, 항목(트레이트, impl 및 외부 항목 포함), 유형 또는 패턴으로 확장될 수 있습니다.</p>
<p>r[macro.decl.transcription]</p>
<h2 id="트랜스크라이빙"><a class="header" href="#트랜스크라이빙">트랜스크라이빙</a></h2>
<p>r[macro.decl.transcription.intro] When a macro is invoked, the macro expander looks up macro invocations by name, and tries each macro rule in turn. It transcribes the first successful match; if this results in an error, then future matches are not tried.</p>
<p>r[macro.decl.transcription.lookahead] When matching, no lookahead is performed; if the compiler cannot unambiguously determine how to parse the macro invocation one token at a time, then it is an error. In the following example, the compiler does not look ahead past the identifier to see if the following token is a <code>)</code>, even though that would allow it to parse the invocation unambiguously:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! ambiguity {
    ($($i:ident)* $j:ident) =&gt; { };
}

ambiguity!(error); // 오류: 지역적 모호성
<span class="boring">}</span></code></pre></pre>
<p>r[macro.decl.transcription.syntax] In both the matcher and the transcriber, the <code>$</code> token is used to invoke special behaviours from the macro engine (described below in <a href="macros-by-example.html#metavariables">Metavariables</a> and <a href="macros-by-example.html#repetitions">Repetitions</a>). Tokens that aren’t part of such an invocation are matched and transcribed literally, with one exception. The exception is that the outer delimiters for the matcher will match any pair of delimiters. Thus, for instance, the matcher <code>(())</code> will match <code>{()}</code> but not <code>{{}}</code>. The character <code>$</code> cannot be matched or transcribed literally.</p>
<p>r[macro.decl.transcription.fragment]</p>
<h3 id="일치된-조각-전달"><a class="header" href="#일치된-조각-전달">일치된 조각 전달</a></h3>
<p>일치된 조각을 다른 예제별 매크로로 전달할 때 두 번째 매크로의 매처는 조각 유형의 불투명한 AST를 보게 됩니다. 두 번째 매크로는 매처의 조각을 일치시키기 위해 리터럴 토큰을 사용할 수 없으며 동일한 유형의 조각 지정자만 사용할 수 있습니다. <code>ident</code>, <code>lifetime</code> 및 <code>tt</code> 조각 유형은 예외이며 리터럴 토큰으로 일치시킬 수 있습니다. 다음은 이 제한 사항을 보여줍니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! foo {
    ($l:expr) =&gt; { bar!($l); }
// 오류:               ^^ 매크로 호출에서 이 토큰을 예상한 규칙이 없습니다
}

macro_rules! bar {
    (3) =&gt; {}
}

foo!(3);
<span class="boring">}</span></code></pre></pre>
<p>다음은 ‘tt’ 조각을 일치시킨 후 토큰을 직접 일치시키는 방법을 보여줍니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 컴파일 OK
macro_rules! foo {
    ($l:tt) =&gt; { bar!($l); }
}

macro_rules! bar {
    (3) =&gt; {}
}

foo!(3);
<span class="boring">}</span></code></pre></pre>
<p>r[macro.decl.meta]</p>
<h2 id="메타변수"><a class="header" href="#메타변수">메타변수</a></h2>
<p>r[macro.decl.meta.intro] In the matcher, <code>$</code> <em>name</em> <code>:</code> <em>fragment-specifier</em> matches a Rust syntax fragment of the kind specified and binds it to the metavariable <code>$</code><em>name</em>.</p>
<p>r[macro.decl.meta.specifier] Valid fragment specifiers are:</p>
<ul>
<li><code>block</code>: a [BlockExpression]</li>
<li><code>expr</code>: an [Expression]</li>
<li><code>expr_2021</code>: an [Expression] except [UnderscoreExpression] and [ConstBlockExpression] (see [macro.decl.meta.edition2024])</li>
<li><code>ident</code>: an [IDENTIFIER_OR_KEYWORD] except <code>_</code>, [RAW_IDENTIFIER], or <a href="macro.decl.hygiene.crate"><code>$crate</code></a></li>
<li><code>item</code>: an [Item]</li>
<li><code>lifetime</code>: a [LIFETIME_TOKEN]</li>
<li><code>literal</code>: matches <code>-</code><sup>?</sup>[LiteralExpression]</li>
<li><code>meta</code>: an [Attr], the contents of an attribute</li>
<li><code>pat</code>: a [Pattern] (see [macro.decl.meta.edition2021])</li>
<li><code>pat_param</code>: a [PatternNoTopAlt]</li>
<li><code>path</code>: a [TypePath] style path</li>
<li><code>stmt</code>: a [Statement][grammar-Statement] without the trailing semicolon (except for item statements that require semicolons)</li>
<li><code>tt</code>: a [TokenTree] (a single <a href="tokens.html">token</a> or tokens in matching delimiters <code>()</code>, <code>[]</code>, or <code>{}</code>)</li>
<li><code>ty</code>: a [Type][grammar-Type]</li>
<li><code>vis</code>: a possibly empty [Visibility] qualifier</li>
</ul>
<p>r[macro.decl.meta.transcription] In the transcriber, metavariables are referred to simply by <code>$</code><em>name</em>, since the fragment kind is specified in the matcher. Metavariables are replaced with the syntax element that matched them. Metavariables can be transcribed more than once or not at all.</p>
<p>r[macro.decl.meta.dollar-crate] The keyword metavariable <a href="macro.decl.hygiene.crate"><code>$crate</code></a> can be used to refer to the current crate.</p>
<p>r[macro.decl.meta.edition2021]</p>
<blockquote>
<p>[!EDITION-2021] Starting with the 2021 edition, <code>pat</code> fragment-specifiers match top-level or-patterns (that is, they accept [Pattern]).</p>
<p>Before the 2021 edition, they match exactly the same fragments as <code>pat_param</code> (that is, they accept [PatternNoTopAlt]).</p>
<p>관련 에디션은 <code>macro_rules!</code> 정의에 적용되는 에디션입니다.</p>
</blockquote>
<p>r[macro.decl.meta.edition2024]</p>
<blockquote>
<p>[!EDITION-2024] Before the 2024 edition, <code>expr</code> fragment specifiers do not match [UnderscoreExpression] or [ConstBlockExpression] at the top level. They are allowed within subexpressions.</p>
<p>The <code>expr_2021</code> 조각 지정자는 2024 이전 에디션과의 하위 호환성을 유지하기 위해 존재합니다.</p>
</blockquote>
<p>r[macro.decl.repetition]</p>
<h2 id="반복"><a class="header" href="#반복">반복</a></h2>
<p>r[macro.decl.repetition.intro] In both the matcher and transcriber, repetitions are indicated by placing the tokens to be repeated inside <code>$(</code>…<code>)</code>, followed by a repetition operator, optionally with a separator token between.</p>
<p>r[macro.decl.repetition.separator] The separator token can be any token other than a delimiter or one of the repetition operators, but <code>;</code> and <code>,</code> are the most common. For instance, <code>$( $i:ident ),*</code> represents any number of identifiers separated by commas. Nested repetitions are permitted.</p>
<p>r[macro.decl.repetition.operators] The repetition operators are:</p>
<ul>
<li><code>*</code> — 임의의 횟수 반복을 나타냅니다.</li>
<li><code>+</code> — 임의의 횟수이지만 최소 한 번 이상을 나타냅니다.</li>
<li><code>?</code> — 0 또는 1회 발생하는 선택적 조각을 나타냅니다.</li>
</ul>
<p>r[macro.decl.repetition.optional-restriction] Since <code>?</code> represents at most one occurrence, it cannot be used with a separator.</p>
<p>r[macro.decl.repetition.fragment] The repeated fragment both matches and transcribes to the specified number of the fragment, separated by the separator token. Metavariables are matched to every repetition of their corresponding fragment. For instance, the <code>$( $i:ident ),*</code> example above matches <code>$i</code> to all of the identifiers in the list.</p>
<p>트랜스크립션 중에는 컴파일러가 반복을 올바르게 확장하는 방법을 알 수 있도록 반복에 추가 제한 사항이 적용됩니다.</p>
<ol>
<li>A metavariable must appear in exactly the same number, kind, and nesting order of repetitions in the transcriber as it did in the matcher. So for the matcher <code>$( $i:ident ),*</code>, the transcribers <code>=&gt; { $i }</code>, <code>=&gt; { $( $( $i )* )* }</code>, and <code>=&gt; { $( $i )+ }</code> are all illegal, but <code>=&gt; { $( $i );* }</code> is correct and replaces a comma-separated list of identifiers with a semicolon-separated list.</li>
<li>트랜스크라이버의 각 반복에는 확장 횟수를 결정하기 위해 최소한 하나의 메타변수가 포함되어야 합니다. 동일한 반복에 여러 메타변수가 나타나면 동일한 수의 조각에 바인딩되어야 합니다. 예를 들어, <code>( $( $i:ident ),* ; $( $j:ident ),* ) =&gt; (( $( ($i,$j) ),* ))</code>는 <code>$j</code> 조각과 동일한 수의 <code>$i</code> 조각을 바인딩해야 합니다. 즉, <code>(a, b, c; d, e, f)</code>로 매크로를 호출하는 것은 합법이며 <code>((a,d), (b,e), (c,f))</code>로 확장되지만, <code>(a, b, c; d, e)</code>는 동일한 수가 아니므로 불법입니다. 이 요구 사항은 중첩된 반복의 모든 계층에 적용됩니다.</li>
</ol>
<p>r[macro.decl.scope]</p>
<h2 id="scoping-exporting-and-importing"><a class="header" href="#scoping-exporting-and-importing">Scoping, exporting, and importing</a></h2>
<p>r[macro.decl.scope.intro] For historical reasons, the scoping of macros by example does not work entirely like items. Macros have two forms of scope: textual scope, and path-based scope. Textual scope is based on the order that things appear in source files, or even across multiple files, and is the default scoping. It is explained further below. Path-based scope works exactly the same way that item scoping does. The scoping, exporting, and importing of macros is controlled largely by attributes.</p>
<p>r[macro.decl.scope.unqualified] When a macro is invoked by an unqualified identifier (not part of a multi-part path), it is first looked up in textual scoping. If this does not yield any results, then it is looked up in path-based scoping. If the macro’s name is qualified with a path, then it is only looked up in path-based scoping.</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">use lazy_static::lazy_static; // 경로 기반 가져오기.

macro_rules! lazy_static { // 텍스트 정의.
    (lazy) =&gt; {};
}

lazy_static!{lazy} // 텍스트 조회는 먼저 우리 매크로를 찾습니다.
self::lazy_static!{} // 경로 기반 조회는 우리 매크로를 무시하고 가져온 매크로를 찾습니다.</code></pre>
<p>r[macro.decl.scope.textual]</p>
<h3 id="textual-scope"><a class="header" href="#textual-scope">Textual scope</a></h3>
<p>r[macro.decl.scope.textual.intro] Textual scope is based largely on the order that things appear in source files, and works similarly to the scope of local variables declared with <code>let</code> except it also applies at the module level. When <code>macro_rules!</code> is used to define a macro, the macro enters the scope after the definition (note that it can still be used recursively, since names are looked up from the invocation site), up until its surrounding scope, typically a module, is closed. This can enter child modules and even span across multiple files:</p>
<!-- ignore: requires external modules -->
<pre><code class="language-rust ignore">//// src/lib.rs
mod has_macro {
    // m!{} // 오류: m이 범위에 없습니다.

    macro_rules! m {
        () =&gt; {};
    }
    m!{} // OK: m 선언 후에 나타납니다.

    mod uses_macro;
}

// m!{} // 오류: m이 범위에 없습니다.

//// src/has_macro/uses_macro.rs

m!{} // OK: src/lib.rs에서 m 선언 후에 나타납니다</code></pre>
<p>r[macro.decl.scope.textual.shadow] It is not an error to define a macro multiple times; the most recent declaration will shadow the previous one unless it has gone out of scope.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! m {
    (1) =&gt; {};
}

m!(1);

mod inner {
    m!(1);

    macro_rules! m {
        (2) =&gt; {};
    }
    // m!(1); // 오류: '1'과 일치하는 규칙이 없습니다
    m!(2);

    macro_rules! m {
        (3) =&gt; {};
    }
    m!(3);
}

m!(1);
<span class="boring">}</span></code></pre></pre>
<p>매크로는 함수 내부에서도 로컬로 선언하고 사용할 수 있으며 유사하게 작동합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    // m!(); // 오류: m이 범위에 없습니다.
    macro_rules! m {
        () =&gt; {};
    }
    m!();
}

// m!(); // 오류: m이 범위에 없습니다.
<span class="boring">}</span></code></pre></pre>
<p>r[macro.decl.scope.textual.shadow.path-based] Textual scope name bindings for macros shadow path-based scope bindings to macros.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! m2 {
    () =&gt; {
        println!("m2");
    };
}

// Resolves to path-based candidate from use declaration below.
m!(); // prints "m2\n"

// Introduce second candidate for `m` with textual scope.
//
// This shadows path-based candidate from below for the rest of this
// example.
macro_rules! m {
    () =&gt; {
        println!("m");
    };
}

// Introduce `m2` macro as path-based candidate.
//
// This item is in scope for this entire example, not just below the
// use declaration.
use m2 as m;

// Resolves to the textual macro candidate from above the use
// declaration.
m!(); // prints "m\n"
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] For areas where shadowing is not allowed, see <a href="names/name-resolution.html#r-names.resolution.expansion.imports.ambiguity">name resolution ambiguities</a>.</p>
</blockquote>
<p>r[macro.decl.scope.path-based]</p>
<h3 id="path-based-scope"><a class="header" href="#path-based-scope">Path-based scope</a></h3>
<p>r[macro.decl.scope.path-based.intro] By default, a macro has no path-based scope. Macros can gain path-based scope in two ways:</p>
<ul>
<li><a href="items/use-declarations.html#use-visibility">Use declaration re-export</a></li>
<li><a href="macros-by-example.html#the-macro_export-attribute"><code>macro_export</code></a></li>
</ul>
<p>r[macro.decl.scope.path.reexport] Macros can be re-exported to give them path-based scope from a module other than the crate root.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mac::m!(); // OK: Path-based lookup finds `m` in the mac module.

mod mac {
    // Introduce macro `m` with textual scope.
    macro_rules! m {
        () =&gt; {};
    }

    // Reexport with path-based scope from within `m`'s textual scope.
    pub(crate) use m;
}
<span class="boring">}</span></code></pre></pre>
<p>r[macro.decl.scope.path-based.visibility] Macros have an implicit visibility of <code>pub(crate)</code>. <code>#[macro_export]</code> changes the implicit visibility to <code>pub</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Implicit visibility is `pub(crate)`.
macro_rules! private_m {
    () =&gt; {};
}

// Implicit visibility is `pub`.
#[macro_export]
macro_rules! pub_m {
    () =&gt; {};
}

pub(crate) use private_m as private_macro; // OK.
pub use pub_m as pub_macro; // OK.
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail E0364 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">// Implicit visibility is `pub(crate)`.
</span><span class="boring">macro_rules! private_m {
</span><span class="boring">    () =&gt; {};
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Implicit visibility is `pub`.
</span><span class="boring">#[macro_export]
</span><span class="boring">macro_rules! pub_m {
</span><span class="boring">    () =&gt; {};
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub(crate) use private_m as private_macro; // OK.
</span><span class="boring">pub use pub_m as pub_macro; // OK.
</span><span class="boring">
</span>pub use private_m; // ERROR: `private_m` is only public within
                   // the crate and cannot be re-exported outside.
<span class="boring">}</span></code></pre></pre>
<!-- template:attributes -->
<p>r[macro.decl.scope.macro_use]</p>
<h3 id="macro_use-속성"><a class="header" href="#macro_use-속성"><code>macro_use</code> 속성</a></h3>
<p>r[macro.decl.scope.macro_use.intro] The <em><code>macro_use</code> [attribute][attributes]</em> has two purposes: it may be used on modules to extend the scope of macros defined within them, and it may be used on [<code>extern crate</code>][items.extern-crate] to import macros from another crate into the <a href="names/preludes.html#macro_use-prelude"><code>macro_use</code> prelude</a>.</p>
<blockquote>
<p>[!EXAMPLE]</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_use]
mod inner {
    macro_rules! m {
        () =&gt; {};
    }
}
m!();
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-rust ignore">#[macro_use]
extern crate log;</code></pre>
</blockquote>
<p>r[macro.decl.scope.macro_use.syntax] When used on modules, the <code>macro_use</code> attribute uses the [MetaWord] syntax.</p>
<p>When used on <code>extern crate</code>, it uses the [MetaWord] and [MetaListIdents] syntaxes. For more on how these syntaxes may be used, see [macro.decl.scope.macro_use.prelude].</p>
<p>r[macro.decl.scope.macro_use.allowed-positions] The <code>macro_use</code> attribute may be applied to modules or <code>extern crate</code>.</p>
<blockquote>
<p>[!NOTE] <code>rustc</code> ignores use in other positions but lints against it. This may become an error in the future.</p>
</blockquote>
<p>r[macro.decl.scope.macro_use.extern-crate-self] The <code>macro_use</code> attribute may not be used on <a href="items.extern-crate.self"><code>extern crate self</code></a>.</p>
<p>r[macro.decl.scope.macro_use.duplicates] The <code>macro_use</code> attribute may be used any number of times on a form.</p>
<p>Multiple instances of <code>macro_use</code> in the [MetaListIdents] syntax may be specified. The union of all specified macros will be imported.</p>
<blockquote>
<p>[!NOTE] On modules, <code>rustc</code> lints against any [MetaWord] <code>macro_use</code> attributes following the first.</p>
<p>On <code>extern crate</code>, <code>rustc</code> lints against any <code>macro_use</code> attributes that have no effect due to not importing any macros not already imported by another <code>macro_use</code> attribute. If two or more [MetaListIdents] <code>macro_use</code> attributes import the same macro, the first is linted against. If any [MetaWord] <code>macro_use</code> attributes are present, all [MetaListIdents] <code>macro_use</code> attributes are linted against. If two or more [MetaWord] <code>macro_use</code> attributes are present, the ones following the first are linted against.</p>
</blockquote>
<p>r[macro.decl.scope.macro_use.mod-decl] When <code>macro_use</code> is used on a module, the module’s macro scope extends beyond the module’s lexical scope.</p>
<blockquote>
<p>[!EXAMPLE]</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_use]
mod inner {
    macro_rules! m {
        () =&gt; {};
    }
}
m!(); // OK
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[macro.decl.scope.macro_use.prelude] Specifying <code>macro_use</code> on an <code>extern crate</code> declaration in the crate root imports exported macros from that crate.</p>
<p>Macros imported this way are imported into the <a href="names/preludes.html#macro_use-prelude"><code>macro_use</code> prelude</a>, not textually, which means that they can be shadowed by any other name. Macros imported by <code>macro_use</code> can be used before the import statement.</p>
<blockquote>
<p>[!NOTE] <code>rustc</code> currently prefers the last macro imported in case of conflict. Don’t rely on this. This behavior is unusual, as imports in Rust are generally order-independent. This behavior of <code>macro_use</code> may change in the future.</p>
<p>For details, see <a href="https://github.com/rust-lang/rust/issues/148025">Rust issue #148025</a>.</p>
</blockquote>
<p>When using the [MetaWord] syntax, all exported macros are imported. When using the [MetaListIdents] syntax, only the specified macros are imported.</p>
<blockquote>
<p>[!EXAMPLE]</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">#[macro_use(lazy_static)] // Or `#[macro_use]` to import all macros.
extern crate lazy_static;

lazy_static!{}
// self::lazy_static!{} // ERROR: lazy_static is not defined in `self`.</code></pre>
</blockquote>
<p>r[macro.decl.scope.macro_use.export] Macros to be imported with <code>macro_use</code> must be exported with [<code>macro_export</code>][macro.decl.scope.macro_export].</p>
<!-- template:attributes -->
<p>r[macro.decl.scope.macro_export]</p>
<h3 id="the-macro_export-attribute"><a class="header" href="#the-macro_export-attribute">The <code>macro_export</code> attribute</a></h3>
<p>r[macro.decl.scope.macro_export.intro] The <em><code>macro_export</code> [attribute][attributes]</em> exports the macro from the crate and makes it available in the root of the crate for path-based resolution.</p>
<blockquote>
<p>[!EXAMPLE]</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self::m!();
//  ^^^^ OK: Path-based lookup finds `m` in the current module.
m!(); // As above.

mod inner {
    super::m!();
    crate::m!();
}

mod mac {
    #[macro_export]
    macro_rules! m {
        () =&gt; {};
    }
}
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[macro.decl.scope.macro_export.syntax] The <code>macro_export</code> attribute uses the [MetaWord] and [MetaListIdents] syntaxes. With the [MetaListIdents] syntax, it accepts a single [<code>local_inner_macros</code>][macro.decl.scope.macro_export.local_inner_macros] value.</p>
<p>r[macro.decl.scope.macro_export.allowed-positions] The <code>macro_export</code> attribute may be applied to <code>macro_rules</code> definitions.</p>
<blockquote>
<p>[!NOTE] <code>rustc</code> ignores use in other positions but lints against it. This may become an error in the future.</p>
</blockquote>
<p>r[macro.decl.scope.macro_export.duplicates] Only the first use of <code>macro_export</code> on a macro has effect.</p>
<blockquote>
<p>[!NOTE] <code>rustc</code> lints against any use following the first.</p>
</blockquote>
<p>r[macro.decl.scope.macro_export.path-based] By default, macros only have [textual scope][macro.decl.scope.textual] and cannot be resolved by path. When the <code>macro_export</code> attribute is used, the macro is made available in the crate root and can be referred to by its path.</p>
<blockquote>
<p>[!EXAMPLE] Without <code>macro_export</code>, macros only have textual scope, so path-based resolution of the macro fails.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0433 edition2024">macro_rules! m {
    () =&gt; {};
}
self::m!(); // 오류
crate::m!(); // 오류
<span class="boring">fn main() {}</span></code></pre></pre>
<p>With <code>macro_export</code>, path-based resolution works.</p>
<pre><pre class="playground"><code class="language-rust edition2024">#[macro_export]
macro_rules! m {
    () =&gt; {};
}
self::m!(); // OK
crate::m!(); // OK
<span class="boring">fn main() {}</span></code></pre></pre>
</blockquote>
<p>r[macro.decl.scope.macro_export.export] The <code>macro_export</code> attribute causes a macro to be exported from the crate root so that it can be referred to in other crates by path.</p>
<blockquote>
<p>[!EXAMPLE] Given the following in a <code>log</code> crate:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! warn {
    ($message:expr) =&gt; { eprintln!("WARN: {}", $message) };
}
<span class="boring">}</span></code></pre></pre>
<p>From another crate, you can refer to the macro by path:</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">fn main() {
    log::warn!("example warning");
}</code></pre>
</blockquote>
<p>r[macro.decl.scope.macro_export.macro_use] <code>macro_export</code> allows the use of [<code>macro_use</code>][macro.decl.scope.macro_use] on an <code>extern crate</code> to import the macro into the <a href="names/preludes.html#macro_use-prelude"><code>macro_use</code> prelude</a>.</p>
<blockquote>
<p>[!EXAMPLE] Given the following in a <code>log</code> crate:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! warn {
    ($message:expr) =&gt; { eprintln!("WARN: {}", $message) };
}
<span class="boring">}</span></code></pre></pre>
<p>Using <code>macro_use</code> in a dependent crate allows you to use the macro from the prelude:</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">#[macro_use]
extern crate log;

pub mod util {
    pub fn do_thing() {
        // Resolved via macro prelude.
        warn!("example warning");
    }
}</code></pre>
</blockquote>
<p>r[macro.decl.scope.macro_export.local_inner_macros] Adding <code>local_inner_macros</code> to the <code>macro_export</code> attribute causes all single-segment macro invocations in the macro definition to have an implicit <code>$crate::</code> prefix.</p>
<blockquote>
<p>[!NOTE] This is intended primarily as a tool to migrate code written before <a href="macro.decl.hygiene.crate"><code>$crate</code></a> was added to the language to work with Rust 2018’s path-based imports of macros. Its use is discouraged in new code.</p>
</blockquote>
<blockquote>
<p>[!EXAMPLE]</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export(local_inner_macros)]
macro_rules! helped {
    () =&gt; { helper!() } // 자동으로 $crate::helper!()로 변환됩니다.
}

#[macro_export]
macro_rules! helper {
    () =&gt; { () }
}
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[macro.decl.hygiene]</p>
<h2 id="위생"><a class="header" href="#위생">위생</a></h2>
<p>r[macro.decl.hygiene.intro] Macros by example have <em>mixed-site hygiene</em>. This means that <a href="expressions/loop-expr.html#loop-labels">loop labels</a>, <a href="expr.loop.block-labels">block labels</a>, and local variables are looked up at the macro definition site while other symbols are looked up at the macro invocation site. For example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 1;
fn func() {
    unreachable!("이것은 절대 호출되지 않습니다")
}

macro_rules! check {
    () =&gt; {
        assert_eq!(x, 1); // 정의 사이트의 `x`를 사용합니다.
        func();           // 호출 사이트의 `func`를 사용합니다.
    };
}

{
    let x = 2;
    fn func() { /* 패닉하지 않습니다 */ }
    check!();
}
<span class="boring">}</span></code></pre></pre>
<p>매크로 확장에서 정의된 레이블과 지역 변수는 호출 간에 공유되지 않으므로 이 코드는 컴파일되지 않습니다.매크로 확장 시 정의된 레이블과 지역 변수는 호출 간에 공유되지 않으므로 이 코드는 컴파일되지 않습니다:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0425 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! m {
    (define) =&gt; {
        let x = 1;
    };
    (refer) =&gt; {
        dbg!(x);
    };
}

m!(define);
m!(refer);
<span class="boring">}</span></code></pre></pre>
<p>r[macro.decl.hygiene.crate] A special case is the <code>$crate</code> metavariable. It refers to the crate defining the macro, and can be used at the start of the path to look up items or macros which are not in scope at the invocation site.</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">//// `helper_macro` 크레이트의 정의.
#[macro_export]
macro_rules! helped {
    // () =&gt; { helper!() } // 'helper'가 범위에 없기 때문에 오류가 발생할 수 있습니다.
// () =&gt; { helper!() } // 'helper'가 범위에 없기 때문에 오류가 발생할 수 있습니다.
    () =&gt; { $crate::helper!() }
}

#[macro_export]
macro_rules! helper {
    () =&gt; { () }
}

//// 다른 크레이트에서 사용.
// `helper_macro::helper`는 가져오지 않았습니다!
//// 다른 크레이트에서 사용.
// `helper_macro::helper`는 임포트되지 않았습니다!
use helper_macro::helped;

fn unit() {
    helped!();
}</code></pre>
<p>참고: <code>$crate</code>는 현재 크레이트를 참조하므로 매크로가 아닌 항목을 참조할 때는 정규화된 모듈 경로와 함께 사용해야 합니다.참고로, <code>$crate</code>는 현재 크레이트를 참조하므로, 매크로가 아닌 아이템을 참조할 때는 정규화된 모듈 경로와 함께 사용해야 합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod inner {
    #[macro_export]
    macro_rules! call_foo {
        () =&gt; { $crate::inner::foo() };
    }

    pub fn foo() {}
}
<span class="boring">}</span></code></pre></pre>
<p>r[macro.decl.hygiene.vis] Additionally, even though <code>$crate</code> allows a macro to refer to items within its own crate when expanding, its use has no effect on visibility. An item or macro referred to must still be visible from the invocation site. In the following example, any attempt to invoke <code>call_foo!()</code> from outside its crate will fail because <code>foo()</code> is not public.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! call_foo {
    () =&gt; { $crate::foo() };
}

fn foo() {}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] Prior to Rust 1.30, <code>$crate</code> and [<code>local_inner_macros</code>][macro.decl.scope.macro_export.local_inner_macros] were unsupported. They were added alongside [path-based imports of macros][macro.decl.scope.macro_export], to ensure that helper macros did not need to be manually imported by users of a macro-exporting crate. Crates written for earlier versions of Rust that use helper macros need to be modified to use <code>$crate</code> or <code>local_inner_macros</code> to work well with path-based imports.</p>
</blockquote>
<p>r[macro.decl.follow-set]</p>
<h2 id="follow-set-ambiguity-restrictions"><a class="header" href="#follow-set-ambiguity-restrictions">Follow-set ambiguity restrictions</a></h2>
<p>r[macro.decl.follow-set.intro] The parser used by the macro system is reasonably powerful, but it is limited in order to prevent ambiguity in current or future versions of the language.</p>
<p>r[macro.decl.follow-set.token-restriction] In particular, in addition to the rule about ambiguous expansions, a nonterminal matched by a metavariable must be followed by a token which has been decided can be safely used after that kind of match.</p>
<p>예를 들어, <code>$i:expr [ , ]</code>와 같은 매크로 매처는 <code>[,]</code>가 합법적인 표현식의 일부가 될 수 없으므로 구문 분석이 항상 명확하기 때문에 오늘날 Rust에서 이론적으로 허용될 수 있습니다. 그러나 <code>[</code>는 후행 표현식을 시작할 수 있으므로 <code>[</code>는 표현식 뒤에 오는 것으로 안전하게 배제할 수 있는 문자가 아닙니다. 나중에 Rust 버전에서 <code>[,]</code>가 허용되면 이 매처는 모호해지거나 잘못 구문 분석되어 작동하는 코드를 손상시킬 수 있습니다. 그러나 <code>,</code>와 <code>;</code>는 합법적인 표현식 구분 기호이므로 <code>$i:expr,</code> 또는 <code>$i:expr;</code>와 같은 매처는 합법적입니다. 구체적인 규칙은 다음과 같습니다.예를 들어, <code>$i:expr [ , ]</code>와 같은 매크로 매처는 오늘날 Rust에서 이론적으로 받아들여질 수 있습니다. 왜냐하면 <code>[,]</code>는 합법적인 표현식의 일부가 될 수 없으므로 파싱이 항상 명확하기 때문입니다. 그러나 <code>[</code>는 후행 표현식을 시작할 수 있기 때문에, <code>[</code>는 표현식 뒤에 오는 것으로 안전하게 배제할 수 있는 문자가 아닙니다. 만약 <code>[,]</code>가 이후 버전의 Rust에서 허용된다면, 이 매처는 모호해지거나 잘못 파싱되어 작동하는 코드를 깨뜨릴 것입니다. 그러나 <code>,</code>와 <code>;</code>는 합법적인 표현식 구분자이므로 <code>$i:expr,</code> 또는 <code>$i:expr;</code>와 같은 매처는 합법적일 것입니다. 구체적인 규칙은 다음과 같습니다:</p>
<p>r[macro.decl.follow-set.token-expr-stmt]</p>
<ul>
<li><code>expr</code>과 <code>stmt</code>는 <code>=&gt;</code>, <code>,</code>, 또는 <code>;</code> 중 하나만 뒤에 올 수 있습니다.</li>
</ul>
<p>r[macro.decl.follow-set.token-pat_param]</p>
<ul>
<li><code>pat_param</code>은 <code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>|</code>, <code>if</code> 또는 <code>in</code> 중 하나만 뒤따를 수 있습니다.<code>pat_param</code>은 <code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>|</code>, <code>if</code>, 또는 <code>in</code> 중 하나만 뒤에 올 수 있습니다.</li>
</ul>
<p>r[macro.decl.follow-set.token-pat]</p>
<ul>
<li><code>pat</code>은 <code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>if</code>, 또는 <code>in</code> 중 하나만 뒤에 올 수 있습니다.</li>
</ul>
<p>r[macro.decl.follow-set.token-path-ty]</p>
<ul>
<li><code>path</code>와 <code>ty</code>는 <code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>|</code>, <code>;</code>, <code>:</code>, <code>&gt;</code>, <code>&gt;&gt;</code>, <code>[</code>, <code>{</code>, <code>as</code>, <code>where</code> 또는 <code>block</code> 조각 지정자의 매크로 변수 중 하나만 뒤따를 수 있습니다.<code>path</code>와 <code>ty</code>는 <code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>|</code>, <code>;</code>, <code>:</code>, <code>&gt;</code>, <code>&gt;&gt;</code>, <code>[</code>, <code>{</code>, <code>as</code>, <code>where</code> 또는 <code>block</code> 프래그먼트 지정자의 매크로 변수 중 하나만 뒤에 올 수 있습니다.</li>
</ul>
<p>r[macro.decl.follow-set.token-vis]</p>
<ul>
<li><code>vis</code>는 <code>,</code>, 비-원시 <code>priv</code>가 아닌 식별자, 유형을 시작할 수 있는 모든 토큰 또는 <code>ident</code>, <code>ty</code> 또는 <code>path</code> 조각 지정자가 있는 메타변수 중 하나만 뒤따를 수 있습니다.<code>vis</code>는 <code>,</code>, 비-원시 <code>priv</code>가 아닌 식별자, 타입을 시작할 수 있는 모든 토큰, 또는 <code>ident</code>, <code>ty</code>, 또는 <code>path</code> 프래그먼트 지정자를 가진 메타변수 중 하나만 뒤에 올 수 있습니다.</li>
</ul>
<p>r[macro.decl.follow-set.token-other]</p>
<ul>
<li>다른 모든 조각 지정자에는 제한이 없습니다.</li>
</ul>
<p>r[macro.decl.follow-set.edition2021]</p>
<blockquote>
<p>[!EDITION-2021] Before the 2021 edition, <code>pat</code> may also be followed by <code>|</code>.</p>
</blockquote>
<p>r[macro.decl.follow-set.repetition] When repetitions are involved, then the rules apply to every possible number of expansions, taking separators into account. This means:</p>
<ul>
<li>반복에 구분 기호가 포함된 경우, 해당 구분 기호는 반복의 내용을 따를 수 있어야 합니다.</li>
<li>반복이 여러 번 반복될 수 있는 경우(<code>*</code> 또는 <code>+</code>), 내용은 스스로를 따를 수 있어야 합니다.</li>
<li>반복의 내용은 이전에 오는 모든 것을 따를 수 있어야 하며, 뒤에 오는 모든 것은 반복의 내용을 따를 수 있어야 합니다.반복의 내용은 이전에 오는 모든 것을 따를 수 있어야 하며, 뒤에 오는 모든 것은 반복의 내용을 따를 수 있어야 합니다.</li>
<li>반복이 0번 일치할 수 있는 경우(<code>*</code> 또는 <code>?</code>), 뒤에 오는 모든 것은 이전에 오는 모든 것을 따를 수 있어야 합니다.반복이 0번 일치할 수 있는 경우(<code>*</code> 또는 <code>?</code>), 뒤에 오는 모든 것은 이전에 오는 모든 것을 따를 수 있어야 합니다.</li>
</ul>
<p>자세한 내용은 <a href="macro-ambiguity.html">공식 사양</a>을 참조하십시오.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[macro.proc]</p>
<h1 id="procedural-macros"><a class="header" href="#procedural-macros">Procedural macros</a></h1>
<p>r[macro.proc.intro] <em>Procedural macros</em> allow creating syntax extensions as execution of a function. Procedural macros come in one of three flavors:</p>
<ul>
<li><a href="procedural-macros.html#the-proc_macro-attribute">Function-like macros</a> - <code>custom!(...)</code></li>
<li><a href="macro.proc.derive">Derive macros</a> - <code>#[derive(CustomDerive)]</code></li>
<li><a href="procedural-macros.html#the-proc_macro_attribute-attribute">Attribute macros</a> - <code>#[CustomAttribute]</code></li>
</ul>
<p>절차적 매크로를 사용하면 컴파일 타임에 Rust 구문을 사용하고 생성하는 코드를 실행할 수 있습니다. 절차적 매크로를 AST에서 다른 AST로의 함수로 생각할 수 있습니다.</p>
<p>r[macro.proc.def] Procedural macros must be defined in the root of a crate with the <a href="linkage.html">crate type</a> of <code>proc-macro</code>. The macros may not be used from the crate where they are defined, and can only be used when imported in another crate.</p>
<blockquote>
<p>[!NOTE] When using Cargo, Procedural macro crates are defined with the <code>proc-macro</code> key in your manifest:</p>
<pre><code class="language-toml">[lib]
proc-macro = true
</code></pre>
</blockquote>
<p>r[macro.proc.result] As functions, they must either return syntax, panic, or loop endlessly. Returned syntax either replaces or adds the syntax depending on the kind of procedural macro. Panics are caught by the compiler and are turned into a compiler error. Endless loops are not caught by the compiler which hangs the compiler.</p>
<p>절차적 매크로는 컴파일 중에 실행되므로 컴파일러와 동일한 리소스를 갖습니다. 예를 들어, 표준 입력, 오류 및 출력은 컴파일러가 액세스할 수 있는 것과 동일합니다. 마찬가지로 파일 액세스도 동일합니다. 이 때문에 절차적 매크로는 <a href="../cargo/reference/build-scripts.html">Cargo의 빌드 스크립트</a>와 동일한 보안 문제를 가지고 있습니다.</p>
<p>r[macro.proc.error] Procedural macros have two ways of reporting errors. The first is to panic. The second is to emit a [<code>compile_error</code>] macro invocation.</p>
<p>r[macro.proc.proc_macro-crate]</p>
<h2 id="proc_macro-크레이트"><a class="header" href="#proc_macro-크레이트">proc_macro 크레이트</a></h2>
<p>r[macro.proc.proc_macro-crate.intro] Procedural macro crates almost always will link to the compiler-provided <a href="proc_macro"><code>proc_macro</code> crate</a>. The <code>proc_macro</code> crate provides types required for writing procedural macros and facilities to make it easier.</p>
<p>r[macro.proc.proc_macro-crate.token-stream] This crate primarily contains a <a href="proc_macro::TokenStream"><code>TokenStream</code></a> type. Procedural macros operate over <em>token streams</em> instead of AST nodes, which is a far more stable interface over time for both the compiler and for procedural macros to target. A <em>token stream</em> is roughly equivalent to <code>Vec&lt;TokenTree&gt;</code> where a <code>TokenTree</code> can roughly be thought of as lexical token. For example <code>foo</code> is an <code>Ident</code> token, <code>.</code> is a <code>Punct</code> token, and <code>1.2</code> is a <code>Literal</code> token. The <code>TokenStream</code> type, unlike <code>Vec&lt;TokenTree&gt;</code>, is cheap to clone.</p>
<p>r[macro.proc.proc_macro-crate.span] All tokens have an associated <code>Span</code>. A <code>Span</code> is an opaque value that cannot be modified but can be manufactured. <code>Span</code>s represent an extent of source code within a program and are primarily used for error reporting. While you cannot modify a <code>Span</code> itself, you can always change the <code>Span</code> <em>associated</em> with any token, such as through getting a <code>Span</code> from another token.</p>
<p>r[macro.proc.hygiene]</p>
<h2 id="절차적-매크로-위생"><a class="header" href="#절차적-매크로-위생">절차적 매크로 위생</a></h2>
<p>절차적 매크로는 _비위생적_입니다. 이는 출력 토큰 스트림이 바로 옆 코드에 인라인으로 작성된 것처럼 동작함을 의미합니다. 이는 외부 항목의 영향을 받고 외부 임포트에도 영향을 미친다는 것을 의미합니다.</p>
<p>매크로 작성자는 이 제한 사항을 감안할 때 가능한 한 많은 컨텍스트에서 매크로가 작동하도록 주의해야 합니다. 여기에는 종종 라이브러리의 아이템에 대한 절대 경로를 사용하거나(예: <code>Option</code> 대신 <code>::std::option::Option</code>) 생성된 함수가 다른 함수와 충돌할 가능성이 없는 이름을 갖도록 하는 것(예: <code>foo</code> 대신 <code>__internal_foo</code>)이 포함됩니다.</p>
<!-- TODO: rule name needs improvement -->
<!-- template:attributes -->
<p>r[macro.proc.proc_macro]</p>
<h2 id="the-proc_macro-attribute"><a class="header" href="#the-proc_macro-attribute">The <code>proc_macro</code> attribute</a></h2>
<p>r[macro.proc.proc_macro.intro] The <em><code>proc_macro</code> <a href="attributes.html">attribute</a></em> defines a [function-like][macro.invocation] procedural macro.</p>
<blockquote>
<p>[!EXAMPLE] This macro definition ignores its input and emits a function <code>answer</code> into its scope.</p>
<!-- ignore: test doesn't support proc-macro -->
<pre><code class="language-rust ignore"><span class="boring">#![crate_type = "proc-macro"]
</span>extern crate proc_macro;
use proc_macro::TokenStream;

#[proc_macro]
pub fn make_answer(_item: TokenStream) -&gt; TokenStream {
    "fn answer() -&gt; u32 { 42 }".parse().unwrap()
}</code></pre>
<p>We can use it in a binary crate to print “42” to standard output.</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">extern crate proc_macro_examples;
use proc_macro_examples::make_answer;

make_answer!();

fn main() {
    println!("{}", answer());
}</code></pre>
</blockquote>
<p>r[macro.proc.proc_macro.syntax] The <code>proc_macro</code> attribute uses the [MetaWord] syntax.</p>
<p>r[macro.proc.proc_macro.allowed-positions] The <code>proc_macro</code> attribute may only be applied to a <code>pub</code> function of type <code>fn(TokenStream) -&gt; TokenStream</code> where <a href="proc_macro::TokenStream"><code>TokenStream</code></a> comes from the <a href="proc_macro"><code>proc_macro</code> crate</a>. It must have the [“Rust” ABI][items.fn.extern]. No other function qualifiers are allowed. It must be located in the root of the crate.</p>
<p>r[macro.proc.proc_macro.duplicates] The <code>proc_macro</code> attribute may only be specified once on a function.</p>
<p>r[macro.proc.proc_macro.namespace] The <code>proc_macro</code> attribute publicly defines the macro in the <a href="names/namespaces.html">macro namespace</a> in the root of the crate with the same name as the function.</p>
<p>r[macro.proc.proc_macro.behavior] A function-like macro invocation of a function-like procedural macro will pass what is inside the delimiters of the macro invocation as the input <a href="proc_macro::TokenStream"><code>TokenStream</code></a> argument and replace the entire macro invocation with the output <a href="proc_macro::TokenStream"><code>TokenStream</code></a> of the function.</p>
<p>r[macro.proc.proc_macro.invocation] Function-like procedural macros may be invoked in any macro invocation position, which includes:</p>
<ul>
<li><a href="statements.html">Statements</a></li>
<li><a href="expressions.html">Expressions</a></li>
<li><a href="patterns.html">패턴</a></li>
<li><a href="types.html#type-expressions">Type expressions</a></li>
<li><a href="items.html">Item</a> positions, including items in <a href="items/external-blocks.html"><code>extern</code> blocks</a></li>
<li>Inherent and trait <a href="items/implementations.html">implementations</a></li>
<li><a href="items/traits.html">Trait definitions</a></li>
</ul>
<!-- template:attributes -->
<p>r[macro.proc.derive]</p>
<h2 id="the-proc_macro_derive-attribute"><a class="header" href="#the-proc_macro_derive-attribute">The <code>proc_macro_derive</code> attribute</a></h2>
<p>r[macro.proc.derive.intro] Applying the <em><code>proc_macro_derive</code> <a href="attributes.html">attribute</a></em> to a function defines a <em>derive macro</em> that can be invoked by the <a href="attributes/derive.html"><code>derive</code> attribute</a>. These macros are given the token stream of a <a href="items/structs.html">struct</a>, <a href="items/enumerations.html">enum</a>, or <a href="items/unions.html">union</a> definition and can emit new <a href="items.html">items</a> after it. They can also declare and use <a href="procedural-macros.html#derive-macro-helper-attributes">derive macro helper attributes</a>.</p>
<blockquote>
<p>[!EXAMPLE] This derive macro ignores its input and appends tokens that define a function.</p>
<!-- ignore: test doesn't support proc-macro -->
<pre><code class="language-rust ignore"><span class="boring">#![crate_type = "proc-macro"]
</span>extern crate proc_macro;
use proc_macro::TokenStream;

#[proc_macro_derive(AnswerFn)]
pub fn derive_answer_fn(_item: TokenStream) -&gt; TokenStream {
    "fn answer() -&gt; u32 { 42 }".parse().unwrap()
}</code></pre>
<p>To use it, we might write:</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">extern crate proc_macro_examples;
use proc_macro_examples::AnswerFn;

#[derive(AnswerFn)]
struct Struct;

fn main() {
    assert_eq!(42, answer());
}</code></pre>
</blockquote>
<p>r[macro.proc.derive.syntax] The syntax for the <code>proc_macro_derive</code> attribute is:</p>
<pre><code class="language-grammar attributes">@root ProcMacroDeriveAttribute -&gt;
    `proc_macro_derive` `(` DeriveMacroName ( `,` DeriveMacroAttributes )? `,`? `)`

DeriveMacroName -&gt; IDENTIFIER

DeriveMacroAttributes -&gt;
    `attributes` `(` ( IDENTIFIER (`,` IDENTIFIER)* `,`?)? `)`
</code></pre>
<p>The name of the derive macro is given by [DeriveMacroName]. The optional <code>attributes</code> argument is described in [macro.proc.derive.attributes].</p>
<p>r[macro.proc.derive.allowed-positions] The <code>proc_macro_derive</code> attribute may only be applied to a <code>pub</code> function with the [Rust ABI][items.fn.extern] defined in the root of the crate with a type of <code>fn(TokenStream) -&gt; TokenStream</code>  where <a href="proc_macro::TokenStream"><code>TokenStream</code></a> comes from the <a href="proc_macro"><code>proc_macro</code> crate</a>. The function may be <code>const</code> and may use <code>extern</code> to explicitly specify the Rust ABI, but it may not use any other [qualifiers][FunctionQualifiers] (e.g. it may not be <code>async</code> or <code>unsafe</code>).</p>
<p>r[macro.proc.derive.duplicates] The <code>proc_macro_derive</code> attribute may be used only once on a function.</p>
<p>r[macro.proc.derive.namespace] The <code>proc_macro_derive</code> attribute publicly defines the derive macro in the <a href="names/namespaces.html">macro namespace</a> in the root of the crate.</p>
<p>r[macro.proc.derive.output] The input <a href="proc_macro::TokenStream"><code>TokenStream</code></a> is the token stream of the item to which the <code>derive</code> attribute is applied. The output <a href="proc_macro::TokenStream"><code>TokenStream</code></a> must be a (possibly empty) set of items. These items are appended following the input item within the same <a href="items/modules.html">module</a> or <a href="expressions/block-expr.html">block</a>.</p>
<p>r[macro.proc.derive.attributes]</p>
<h3 id="파생-매크로-헬퍼-속성"><a class="header" href="#파생-매크로-헬퍼-속성">파생 매크로 헬퍼 속성</a></h3>
<p>r[macro.proc.derive.attributes.intro] Derive macros can declare <em>derive macro helper attributes</em> to be used within the scope of the <a href="items.html">item</a> to which the derive macro is applied. These <a href="attributes.html">attributes</a> are <a href="attributes.html#active-and-inert-attributes">inert</a>. While their purpose is to be used by the macro that declared them, they can be seen by any macro.</p>
<p>r[macro.proc.derive.attributes.decl] A helper attribute for a derive macro is declared by adding its identifier to the <code>attributes</code> list in the <code>proc_macro_derive</code> attribute.</p>
<blockquote>
<p>[!EXAMPLE] This declares a helper attribute and then ignores it.</p>
<!-- ignore: test doesn't support proc-macro -->
<pre><code class="language-rust ignore"><span class="boring">#![crate_type="proc-macro"]
</span><span class="boring">extern crate proc_macro;
</span><span class="boring">use proc_macro::TokenStream;
</span><span class="boring">
</span>#[proc_macro_derive(WithHelperAttr, attributes(helper))]
pub fn derive_with_helper_attr(_item: TokenStream) -&gt; TokenStream {
    TokenStream::new()
}</code></pre>
<p>To use it, we might write:</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">#[derive(WithHelperAttr)]
struct Struct {
    #[helper] field: (),
}</code></pre>
</blockquote>
<p>r[macro.proc.derive.attributes.scope] When a derive macro invocation is applied to an item, the helper attributes introduced by that derive macro become in scope 1) for attributes that are applied to that item and are applied lexically after the derive macro invocation and 2) for attributes that are applied to fields and variants inside of the item.</p>
<blockquote>
<p>[!NOTE] rustc currently allows derive helpers to be used before the macro that introduces them. Such derive helpers used out of order may not shadow other attribute macros. This behavior is deprecated and slated for removal.</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">#[helper] // Deprecated, hard error in the future.
#[derive(WithHelperAttr)]
struct Struct {
    field: (),
}</code></pre>
<p>For more details, see <a href="https://github.com/rust-lang/rust/issues/79202">Rust issue #79202</a>.</p>
</blockquote>
<!-- template:attributes -->
<p>r[macro.proc.attribute]</p>
<h2 id="the-proc_macro_attribute-attribute"><a class="header" href="#the-proc_macro_attribute-attribute">The <code>proc_macro_attribute</code> attribute</a></h2>
<p>r[macro.proc.attribute.intro] The <em><code>proc_macro_attribute</code> <a href="attributes.html">attribute</a></em> defines an <em>attribute macro</em> which can be used as an <a href="attributes.html">outer attribute</a>.</p>
<blockquote>
<p>[!EXAMPLE] This attribute macro takes the input stream and emits it as-is, effectively being a no-op attribute.</p>
<!-- ignore: test doesn't support proc-macro -->
<pre><code class="language-rust ignore"><span class="boring">#![crate_type = "proc-macro"]
</span><span class="boring">extern crate proc_macro;
</span><span class="boring">use proc_macro::TokenStream;
</span>
#[proc_macro_attribute]
pub fn return_as_is(_attr: TokenStream, item: TokenStream) -&gt; TokenStream {
    item
}</code></pre>
</blockquote>
<blockquote>
<p>[!EXAMPLE] This shows, in the output of the compiler, the stringified <a href="proc_macro::TokenStream"><code>TokenStream</code>s</a> that attribute macros see.</p>
<!-- ignore: test doesn't support proc-macro -->
<pre><code class="language-rust ignore">// my-macro/src/lib.rs
<span class="boring">extern crate proc_macro;
</span><span class="boring">use proc_macro::TokenStream;
</span>#[proc_macro_attribute]
pub fn show_streams(attr: TokenStream, item: TokenStream) -&gt; TokenStream {
    println!("attr: \"{attr}\"");
    println!("item: \"{item}\"");
    item
}</code></pre>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">// src/lib.rs
extern crate my_macro;

use my_macro::show_streams;

// Example: Basic function.
#[show_streams]
fn invoke1() {}
// out: attr: ""
// out: item: "fn invoke1() {}"

// Example: Attribute with input.
#[show_streams(bar)]
fn invoke2() {}
// out: attr: "bar"
// out: item: "fn invoke2() {}"

// Example: Multiple tokens in the input.
#[show_streams(multiple =&gt; tokens)]
fn invoke3() {}
// out: attr: "multiple =&gt; tokens"
// out: item: "fn invoke3() {}"

// Example: Delimiters in the input.
#[show_streams { delimiters }]
fn invoke4() {}
// out: attr: "delimiters"
// out: item: "fn invoke4() {}"</code></pre>
</blockquote>
<p>r[macro.proc.attribute.syntax] The <code>proc_macro_attribute</code> attribute uses the [MetaWord] syntax.</p>
<p>r[macro.proc.attribute.allowed-positions] The <code>proc_macro_attribute</code> attribute may only be applied to a <code>pub</code> function of type <code>fn(TokenStream, TokenStream) -&gt; TokenStream</code> where <a href="proc_macro::TokenStream"><code>TokenStream</code></a> comes from the <a href="proc_macro"><code>proc_macro</code> crate</a>. It must have the [“Rust” ABI][items.fn.extern]. No other function qualifiers are allowed. It must be located in the root of the crate.</p>
<p>r[macro.proc.attribute.duplicates] The <code>proc_macro_attribute</code> attribute may only be specified once on a function.</p>
<p>r[macro.proc.attribute.namespace] The <code>proc_macro_attribute</code> attribute defines the attribute in the <a href="names/namespaces.html">macro namespace</a> in the root of the crate with the same name as the function.</p>
<p>r[macro.proc.attribute.use-positions] Attribute macros can only be used on:</p>
<ul>
<li><a href="items.html">아이템</a></li>
<li>Items in <a href="items/external-blocks.html"><code>extern</code> blocks</a></li>
<li>Inherent and trait <a href="items/implementations.html">implementations</a></li>
<li><a href="items/traits.html">Trait definitions</a></li>
</ul>
<p>r[macro.proc.attribute.behavior] The first <a href="proc_macro::TokenStream"><code>TokenStream</code></a> parameter is the delimited token tree following the attribute’s name but not including the outer delimiters. If the applied attribute contains only the attribute name or the attribute name followed by empty delimiters, the <a href="proc_macro::TokenStream"><code>TokenStream</code></a> is empty.</p>
<p>The second <a href="proc_macro::TokenStream"><code>TokenStream</code></a> is the rest of the <a href="items.html">item</a>, including other <a href="attributes.html">attributes</a> on the <a href="items.html">item</a>.</p>
<p>The item to which the attribute is applied is replaced by the zero or more items in the returned <a href="proc_macro::TokenStream"><code>TokenStream</code></a>.</p>
<p>r[macro.proc.token]</p>
<h2 id="선언적-매크로-토큰과-절차적-매크로-토큰"><a class="header" href="#선언적-매크로-토큰과-절차적-매크로-토큰">선언적 매크로 토큰과 절차적 매크로 토큰</a></h2>
<p>r[macro.proc.token.intro] Declarative <code>macro_rules</code> macros and procedural macros use similar, but different definitions for tokens (or rather <a href="proc_macro::TokenTree"><code>TokenTree</code>s</a>.)</p>
<p>r[macro.proc.token.macro_rules] Token trees in <code>macro_rules</code> (corresponding to <code>tt</code> matchers) are defined as</p>
<ul>
<li>구분된 그룹 (<code>(...)</code>, <code>{...}</code> 등)</li>
<li>언어에서 지원하는 모든 연산자, 단일 문자 및 다중 문자 연산자 모두 포함(<code>+</code>, <code>+=</code>).
<ul>
<li>이 집합에는 작은따옴표 <code>'</code>가 포함되지 않음에 유의하세요.</li>
</ul>
</li>
<li>리터럴 (<code>"string"</code>, <code>1</code> 등)
<ul>
<li>부정(예: <code>-1</code>)은 절대 리터럴 토큰의 일부가 아니며, 별도의 연산자 토큰임에 유의하세요.</li>
</ul>
</li>
<li>키워드를 포함한 식별자 (<code>ident</code>, <code>r#ident</code>, <code>fn</code>)</li>
<li>라이프타임 (<code>'ident</code>)</li>
<li><code>macro_rules</code>의 메타변수 치환 (예: <code>mac</code>의 확장 후 <code>macro_rules! mac { ($my_expr: expr) =&gt; { $my_expr } }</code>에서의 <code>$my_expr</code>. 전달된 표현식과 관계없이 단일 토큰 트리로 간주됨)</li>
</ul>
<p>r[macro.proc.token.tree] Token trees in procedural macros are defined as</p>
<ul>
<li>구분된 그룹 (<code>(...)</code>, <code>{...}</code> 등)</li>
<li>언어에서 지원하는 연산자에 사용되는 모든 구두점 문자(<code>+</code>, 단 <code>+=</code>는 아님) 및 작은따옴표 <code>'</code> 문자(주로 라이프타임에 사용됨. 라이프타임 분리 및 결합 동작은 아래 참조)</li>
<li>리터럴 (<code>"string"</code>, <code>1</code> 등)
<ul>
<li>부정(예: <code>-1</code>)은 정수 및 부동 소수점 리터럴의 일부로 지원됩니다.</li>
</ul>
</li>
<li>키워드를 포함한 식별자 (<code>ident</code>, <code>r#ident</code>, <code>fn</code>)</li>
</ul>
<p>r[macro.proc.token.conversion.intro] Mismatches between these two definitions are accounted for when token streams are passed to and from procedural macros.<br />
Note that the conversions below may happen lazily, so they might not happen if the tokens are not actually inspected.</p>
<p>r[macro.proc.token.conversion.to-proc_macro] When passed to a proc-macro</p>
<ul>
<li>모든 다중 문자 연산자는 단일 문자로 분리됩니다.</li>
<li>라이프타임은 <code>'</code> 문자와 식별자로 분리됩니다.</li>
<li>The keyword metavariable <a href="macro.decl.hygiene.crate"><code>$crate</code></a> is passed as a single identifier.</li>
<li>All other metavariable substitutions are represented as their underlying token streams.
<ul>
<li>Such token streams may be wrapped into delimited groups (<a href="proc_macro::Group"><code>Group</code></a>) with implicit delimiters (<a href="proc_macro::Delimiter::None"><code>Delimiter::None</code></a>) when it’s necessary for preserving parsing priorities.</li>
<li><code>tt</code> 및 <code>ident</code> 치환은 절대 이러한 그룹으로 래핑되지 않으며 항상 기본 토큰 트리로 표현됩니다.</li>
</ul>
</li>
</ul>
<p>r[macro.proc.token.conversion.from-proc_macro] When emitted from a proc macro</p>
<ul>
<li>구두점 문자는 가능한 경우 다중 문자 연산자로 결합됩니다.</li>
<li>식별자와 결합된 작은따옴표 <code>'</code>는 라이프타임으로 결합됩니다.</li>
<li>Negative literals are converted into two tokens (the <code>-</code> and the literal) possibly wrapped into a delimited group (<a href="proc_macro::Group"><code>Group</code></a>) with implicit delimiters (<a href="proc_macro::Delimiter::None"><code>Delimiter::None</code></a>) when it’s necessary for preserving parsing priorities.</li>
</ul>
<p>r[macro.proc.token.doc-comment] Note that neither declarative nor procedural macros support doc comment tokens (e.g. <code>/// Doc</code>), so they are always converted to token streams representing their equivalent <code>#[doc = r"str"]</code> attributes when passed to macros.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[crate]</p>
<h1 id="크레이트와-소스-파일"><a class="header" href="#크레이트와-소스-파일">크레이트와 소스 파일</a></h1>
<p>r[crate.syntax]</p>
<pre><code class="language-grammar items">@root Crate -&gt;
    InnerAttribute*
    Item*
</code></pre>
<blockquote>
<p>[!NOTE] Although Rust, like any other language, can be implemented by an interpreter as well as a compiler, the only existing implementation is a compiler, and the language has always been designed to be compiled. For these reasons, this section assumes a compiler.</p>
</blockquote>
<p>r[crate.compile-time] Rust’s semantics obey a <em>phase distinction</em> between compile-time and run-time.<sup class="footnote-reference"><a href="#phase-distinction">1</a></sup> Semantic rules that have a <em>static interpretation</em> govern the success or failure of compilation, while semantic rules that have a <em>dynamic interpretation</em> govern the behavior of the program at run-time.</p>
<p>r[crate.unit] The compilation model centers on artifacts called <em>crates</em>. Each compilation processes a single crate in source form, and if successful, produces a single crate in binary form: either an executable or some sort of library.<sup class="footnote-reference"><a href="#cratesourcefile">2</a></sup></p>
<p>r[crate.module] A <em>crate</em> is a unit of compilation and linking, as well as versioning, distribution, and runtime loading. A crate contains a <em>tree</em> of nested <a href="items/modules.html">module</a> scopes. The top level of this tree is a module that is anonymous (from the point of view of paths within the module) and any item within a crate has a canonical <a href="paths.html">module path</a> denoting its location within the crate’s module tree.</p>
<p>r[crate.input-source] The Rust compiler is always invoked with a single source file as input, and always produces a single output crate. The processing of that source file may result in other source files being loaded as modules. Source files have the extension <code>.rs</code>.</p>
<p>r[crate.module-def] A Rust source file describes a module, the name and location of which — in the module tree of the current crate — are defined from outside the source file: either by an explicit [Module][grammar-Module] item in a referencing source file, or by the name of the crate itself.</p>
<p>r[crate.inline-module] Every source file is a module, but not every module needs its own source file: <a href="items/modules.html">module definitions</a> can be nested within one file.</p>
<p>r[crate.items] Each source file contains a sequence of zero or more [Item] definitions, and may optionally begin with any number of <a href="attributes.html">attributes</a> that apply to the containing module, most of which influence the behavior of the compiler.</p>
<p>r[crate.attributes] The anonymous crate module can have additional attributes that apply to the crate as a whole.</p>
<blockquote>
<p>[!NOTE] The file’s contents may be preceded by a <a href="input-format.html#shebang-removal">shebang</a>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 크레이트 이름을 지정합니다.
#![crate_name = "projx"]

// 출력 아티팩트의 타입을 지정합니다.
#![crate_type = "lib"]

// 경고를 활성화합니다.
// 이 작업은 익명 크레이트 모듈뿐만 아니라 모든 모듈에서 수행할 수 있습니다.
#![warn(non_camel_case_types)]
<span class="boring">}</span></code></pre></pre>
<p>r[crate.main]</p>
<h2 id="main-functions"><a class="header" href="#main-functions">Main functions</a></h2>
<p>r[crate.main.general] A crate that contains a <code>main</code> <a href="items/functions.html">function</a> can be compiled to an executable.</p>
<p>r[crate.main.restriction] If a <code>main</code> function is present, it must take no arguments, must not declare any <a href="trait-bounds.html">trait or lifetime bounds</a>, must not have any <a href="items/generics.html#where-clauses">where clauses</a>, and its return type must implement the <a href="std::process::Termination"><code>Termination</code></a> trait.</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() -&gt; ! {
    std::process::exit(0);
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() -&gt; impl std::process::Termination {
    std::process::ExitCode::SUCCESS
}</code></pre></pre>
<p>r[crate.main.import] The <code>main</code> function may be an import, e.g. from an external crate or from the current one.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod foo {
    pub fn bar() {
        println!("Hello, world!");
    }
}
use foo::bar as main;
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] Types with implementations of <a href="std::process::Termination"><code>Termination</code></a> in the standard library include:</p>
<ul>
<li><code>()</code></li>
<li><a href="types/never.html"><code>!</code></a></li>
<li><a href="std::convert::Infallible"><code>Infallible</code></a></li>
<li><a href="std::process::ExitCode"><code>ExitCode</code></a></li>
<li><code>Result&lt;T, E&gt; where T: Termination, E: Debug</code></li>
</ul>
</blockquote>
<!-- If the previous section needs updating (from "must take no arguments"
  onwards, also update it in the testing.md file -->
<p>r[crate.uncaught-foreign-unwinding]</p>
<h3 id="uncaught-foreign-unwinding"><a class="header" href="#uncaught-foreign-unwinding">Uncaught foreign unwinding</a></h3>
<p>When a “foreign” unwind (e.g. an exception thrown from C++ code, or a <code>panic!</code> in Rust code using a different panic handler) propagates beyond the <code>main</code> function, the process will be safely terminated. This may take the form of an abort, in which case it is not guaranteed that any <code>Drop</code> calls will be executed, and the error output may be less informative than if the runtime had been terminated by a “native” Rust <code>panic</code>.</p>
<p>For more information, see the <a href="panic.html#unwinding-across-ffi-boundaries">panic documentation</a>.</p>
<p>r[crate.no_main]</p>
<h3 id="no_main-속성"><a class="header" href="#no_main-속성"><code>no_main</code> 속성</a></h3>
<p>The _<code>no_main</code> <a href="attributes.html">속성</a>_은 실행 가능한 바이너리에 대해 <code>main</code> 기호 내보내기를 비활성화하기 위해 크레이트 수준에서 적용될 수 있습니다. 이것은 연결되는 다른 일부 개체가 <code>main</code>을 정의할 때 유용합니다.</p>
<p>r[crate.crate_name]</p>
<h2 id="crate_name-속성"><a class="header" href="#crate_name-속성"><code>crate_name</code> 속성</a></h2>
<p>r[crate.crate_name.general] The <em><code>crate_name</code> <a href="attributes.html">attribute</a></em> may be applied at the crate level to specify the name of the crate with the [MetaNameValueStr] syntax.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span>#![crate_name = "mycrate"]
<span class="boring">fn main() {
</span><span class="boring">}</span></code></pre></pre>
<p>r[crate.crate_name.restriction] The crate name must not be empty, and must only contain <a href="char::is_alphanumeric">Unicode alphanumeric</a> or <code>_</code> (U+005F) characters.</p>
<div class="footnote-definition" id="phase-distinction"><sup class="footnote-definition-label">1</sup>
<p>이러한 구별은 인터프리터에도 존재합니다. 구문 분석, 유형 검사 및 린트와 같은 정적 검사는 프로그램이 실행되는 시점과 관계없이 프로그램이 실행되기 전에 수행되어야 합니다.</p>
</div>
<div class="footnote-definition" id="cratesourcefile"><sup class="footnote-definition-label">2</sup>
<p>크레이트는 ECMA-335 CLI 모델의 <em>어셈블리</em>, SML/NJ 컴파일 관리자의 <em>라이브러리</em>, Owens 및 Flatt 모듈 시스템의 <em>단위</em> 또는 Mesa의 _구성_과 다소 유사합니다.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><p>r[cfg]</p>
<h1 id="조건부-컴파일"><a class="header" href="#조건부-컴파일">조건부 컴파일</a></h1>
<p>r[cfg.syntax]</p>
<pre><code class="language-grammar configuration">ConfigurationPredicate -&gt;
      ConfigurationOption
    | ConfigurationAll
    | ConfigurationAny
    | ConfigurationNot
    | `true`
    | `false`

ConfigurationOption -&gt;
    IDENTIFIER ( `=` ( STRING_LITERAL | RAW_STRING_LITERAL ) )?

ConfigurationAll -&gt;
    `all` `(` ConfigurationPredicateList? `)`

ConfigurationAny -&gt;
    `any` `(` ConfigurationPredicateList? `)`

ConfigurationNot -&gt;
    `not` `(` ConfigurationPredicate `)`

ConfigurationPredicateList -&gt;
    ConfigurationPredicate (`,` ConfigurationPredicate)* `,`?
</code></pre>
<p>r[cfg.general] <em>Conditionally compiled source code</em> is source code that is compiled only under certain conditions.</p>
<p>r[cfg.attributes-macro] Source code can be made conditionally compiled using the <a href="conditional-compilation.html#the-cfg-attribute"><code>cfg</code></a> and <a href="conditional-compilation.html#the-cfg_attr-attribute"><code>cfg_attr</code></a> <a href="attributes.html">attributes</a> and the built-in <a href="conditional-compilation.html#the-cfg-macro"><code>cfg</code> macro</a>.</p>
<p>r[cfg.conditional] Whether to compile can depend on the target architecture of the compiled crate, arbitrary values passed to the compiler, and other things further described below.</p>
<p>r[cfg.predicate] Each form of conditional compilation takes a <em>configuration predicate</em> that evaluates to true or false. The predicate is one of the following:</p>
<p>r[cfg.predicate.option]</p>
<ul>
<li>구성 옵션. 옵션이 설정되면 술어는 참이고 설정되지 않으면 거짓입니다.</li>
</ul>
<p>r[cfg.predicate.all]</p>
<ul>
<li><code>all()</code>은 쉼표로 구분된 구성 술어 목록과 함께 사용됩니다. 주어진 모든 술어가 참이거나 목록이 비어 있으면 참입니다.</li>
</ul>
<p>r[cfg.predicate.any]</p>
<ul>
<li><code>any()</code>은 쉼표로 구분된 구성 술어 목록과 함께 사용됩니다. 주어진 술어 중 하나 이상이 참이면 참입니다. 술어가 없으면 거짓입니다.</li>
</ul>
<p>r[cfg.predicate.not]</p>
<ul>
<li><code>not()</code>은 구성 술어와 함께 사용됩니다. 술어가 거짓이면 참이고 술어가 참이면 거짓입니다.</li>
</ul>
<p>r[cfg.predicate.literal]</p>
<ul>
<li><code>true</code> or <code>false</code> literals, which are always true or false respectively.</li>
</ul>
<p>r[cfg.option-spec] <em>Configuration options</em> are either names or key-value pairs, and are either set or unset.</p>
<p>r[cfg.option-name] Names are written as a single identifier, such as <code>unix</code>.</p>
<p>r[cfg.option-key-value] Key-value pairs are written as an identifier, <code>=</code>, and then a string, such as <code>target_arch = "x86_64"</code>.</p>
<blockquote>
<p>[!NOTE] Whitespace around the <code>=</code> is ignored, so <code>foo="bar"</code> and <code>foo = "bar"</code> are equivalent.</p>
</blockquote>
<p>r[cfg.option-key-uniqueness] Keys do not need to be unique. For example, both <code>feature = "std"</code> and <code>feature = "serde"</code> can be set at the same time.</p>
<p>r[cfg.options.set]</p>
<h2 id="set-configuration-options"><a class="header" href="#set-configuration-options">Set configuration options</a></h2>
<p>r[cfg.options.general] Which configuration options are set is determined statically during the compilation of the crate.</p>
<p>r[cfg.options.target] Some options are <em>compiler-set</em> based on data about the compilation.</p>
<p>r[cfg.options.other] Other options are <em>arbitrarily-set</em> based on input passed to the compiler outside of the code.</p>
<p>r[cfg.options.crate] It is not possible to set a configuration option from within the source code of the crate being compiled.</p>
<blockquote>
<p>[!NOTE] For <code>rustc</code>, arbitrary-set configuration options are set using the <a href="../rustc/command-line-arguments.html#--cfg-configure-the-compilation-environment"><code>--cfg</code></a> flag. Configuration values for a specified target can be displayed with <code>rustc --print cfg --target $TARGET</code>.</p>
</blockquote>
<blockquote>
<p>[!NOTE] Configuration options with the key <code>feature</code> are a convention used by <a href="../cargo/reference/features.html">Cargo</a> for specifying compile-time options and optional dependencies.</p>
</blockquote>
<p>r[cfg.target_arch]</p>
<h3 id="target_arch"><a class="header" href="#target_arch"><code>target_arch</code></a></h3>
<p>r[cfg.target_arch.gen] Key-value option set once with the target’s CPU architecture. The value is similar to the first element of the platform’s target triple, but not identical.</p>
<p>r[cfg.target_arch.values] Example values:</p>
<ul>
<li><code>"x86"</code></li>
<li><code>"x86_64"</code></li>
<li><code>"mips"</code></li>
<li><code>"powerpc"</code></li>
<li><code>"powerpc64"</code></li>
<li><code>"arm"</code></li>
<li><code>"aarch64"</code></li>
</ul>
<p>r[cfg.target_feature]</p>
<h3 id="target_feature"><a class="header" href="#target_feature"><code>target_feature</code></a></h3>
<p>r[cfg.target_feature.general] Key-value option set for each platform feature available for the current compilation target.</p>
<p>r[cfg.target_feature.values] Example values:</p>
<ul>
<li><code>"avx"</code></li>
<li><code>"avx2"</code></li>
<li><code>"crt-static"</code></li>
<li><code>"rdrand"</code></li>
<li><code>"sse"</code></li>
<li><code>"sse2"</code></li>
<li><code>"sse4.1"</code></li>
</ul>
<p>사용 가능한 기능에 대한 자세한 내용은 <a href="attributes/codegen.html#the-target_feature-attribute"><code>target_feature</code> 속성</a>을 참조하십시오.</p>
<p>r[cfg.target_feature.crt_static] An additional feature of <code>crt-static</code> is available to the <code>target_feature</code> option to indicate that a <a href="linkage.html#static-and-dynamic-c-runtimes">static C runtime</a> is available.</p>
<p>r[cfg.target_os]</p>
<h3 id="target_os"><a class="header" href="#target_os"><code>target_os</code></a></h3>
<p>r[cfg.target_os.general] Key-value option set once with the target’s operating system. This value is similar to the second and third element of the platform’s target triple.</p>
<p>r[cfg.target_os.values] Example values:</p>
<ul>
<li><code>"windows"</code></li>
<li><code>"macos"</code></li>
<li><code>"ios"</code></li>
<li><code>"linux"</code></li>
<li><code>"android"</code></li>
<li><code>"freebsd"</code></li>
<li><code>"dragonfly"</code></li>
<li><code>"openbsd"</code></li>
<li><code>"netbsd"</code></li>
<li><code>"none"</code> (임베디드 대상의 경우 일반적)</li>
</ul>
<p>r[cfg.target_family]</p>
<h3 id="target_family"><a class="header" href="#target_family"><code>target_family</code></a></h3>
<p>r[cfg.target_family.general] Key-value option providing a more generic description of a target, such as the family of the operating systems or architectures that the target generally falls into. Any number of <code>target_family</code> key-value pairs can be set.</p>
<p>r[cfg.target_family.values] Example values:</p>
<ul>
<li><code>"unix"</code></li>
<li><code>"windows"</code></li>
<li><code>"wasm"</code></li>
<li><code>"unix"</code>와 <code>"wasm"</code> 모두</li>
</ul>
<p>r[cfg.target_family.unix]</p>
<h3 id="unix-및-windows"><a class="header" href="#unix-및-windows"><code>unix</code> 및 <code>windows</code></a></h3>
<p><code>unix</code>는 <code>target_family = "unix"</code>가 설정되면 설정됩니다.</p>
<p>r[cfg.target_family.windows] <code>windows</code> is set if <code>target_family = "windows"</code> is set.</p>
<p>r[cfg.target_env]</p>
<h3 id="target_env"><a class="header" href="#target_env"><code>target_env</code></a></h3>
<p>r[cfg.target_env.general] Key-value option set with further disambiguating information about the target platform with information about the ABI or <code>libc</code> used. For historical reasons, this value is only defined as not the empty-string when actually needed for disambiguation. Thus, for example, on many GNU platforms, this value will be empty. This value is similar to the fourth element of the platform’s target triple. One difference is that embedded ABIs such as <code>gnueabihf</code> will simply define <code>target_env</code> as <code>"gnu"</code>.</p>
<p>r[cfg.target_env.values] Example values:</p>
<ul>
<li><code>""</code></li>
<li><code>"gnu"</code></li>
<li><code>"msvc"</code></li>
<li><code>"musl"</code></li>
<li><code>"sgx"</code></li>
<li><code>"sim"</code></li>
<li><code>"macabi"</code></li>
</ul>
<p>r[cfg.target_abi]</p>
<h3 id="target_abi"><a class="header" href="#target_abi"><code>target_abi</code></a></h3>
<p>r[cfg.target_abi.general] Key-value option set to further disambiguate the target with information about the target ABI.</p>
<p>r[cfg.target_abi.disambiguation] For historical reasons, this value is only defined as not the empty-string when actually needed for disambiguation. Thus, for example, on many GNU platforms, this value will be empty.</p>
<p>r[cfg.target_abi.values] Example values:</p>
<ul>
<li><code>""</code></li>
<li><code>"llvm"</code></li>
<li><code>"eabihf"</code></li>
<li><code>"abi64"</code></li>
</ul>
<p>r[cfg.target_endian]</p>
<h3 id="target_endian"><a class="header" href="#target_endian"><code>target_endian</code></a></h3>
<p>키-값 옵션은 대상의 CPU 엔디안에 따라 “little” 또는 “big” 값으로 한 번 설정됩니다.</p>
<p>r[cfg.target_pointer_width]</p>
<h3 id="target_pointer_width"><a class="header" href="#target_pointer_width"><code>target_pointer_width</code></a></h3>
<p>r[cfg.target_pointer_width.general] Key-value option set once with the target’s pointer width in bits.</p>
<p>r[cfg.target_pointer_width.values] Example values:</p>
<ul>
<li><code>"16"</code></li>
<li><code>"32"</code></li>
<li><code>"64"</code></li>
</ul>
<p>r[cfg.target_vendor]</p>
<h3 id="target_vendor"><a class="header" href="#target_vendor"><code>target_vendor</code></a></h3>
<p>r[cfg.target_vendor.general] Key-value option set once with the vendor of the target.</p>
<p>r[cfg.target_vendor.values] Example values:</p>
<ul>
<li><code>"apple"</code></li>
<li><code>"fortanix"</code></li>
<li><code>"pc"</code></li>
<li><code>"unknown"</code></li>
</ul>
<p>r[cfg.target_has_atomic]</p>
<h3 id="target_has_atomic"><a class="header" href="#target_has_atomic"><code>target_has_atomic</code></a></h3>
<p>r[cfg.target_has_atomic.general] Key-value option set for each bit width that the target supports atomic loads, stores, and compare-and-swap operations.</p>
<p>r[cfg.target_has_atomic.stdlib] When this cfg is present, all of the stable [<code>core::sync::atomic</code>] APIs are available for the relevant atomic width.</p>
<p>r[cfg.target_has_atomic.values] Possible values:</p>
<ul>
<li><code>"8"</code></li>
<li><code>"16"</code></li>
<li><code>"32"</code></li>
<li><code>"64"</code></li>
<li><code>"128"</code></li>
<li><code>"ptr"</code></li>
</ul>
<p>r[cfg.test]</p>
<h3 id="test"><a class="header" href="#test"><code>test</code></a></h3>
<p>테스트 하네스를 컴파일할 때 활성화됩니다. <code>rustc</code>로 <a href="../rustc/command-line-arguments.html#--test-build-a-test-harness"><code>--test</code></a> 플래그를 사용하여 수행됩니다. 테스트 지원에 대한 자세한 내용은 <a href="attributes/testing.html">테스팅</a>을 참조하십시오.</p>
<p>r[cfg.debug_assertions]</p>
<h3 id="debug_assertions"><a class="header" href="#debug_assertions"><code>debug_assertions</code></a></h3>
<p>Enabled by default when compiling without optimizations. This can be used to enable extra debugging code in development but not in production.  For example, it controls the behavior of the standard library’s [<code>debug_assert!</code>] macro.</p>
<p>r[cfg.proc_macro]</p>
<h3 id="proc_macro"><a class="header" href="#proc_macro"><code>proc_macro</code></a></h3>
<p>컴파일 중인 크레이트가 <code>proc_macro</code> <a href="linkage.html">크레이트 타입</a>으로 컴파일될 때 설정됩니다.</p>
<p>r[cfg.panic]</p>
<h3 id="panic"><a class="header" href="#panic"><code>panic</code></a></h3>
<p>r[cfg.panic.general] Key-value option set depending on the <a href="panic.html#panic-strategy">panic strategy</a>. Note that more values may be added in the future.</p>
<p>r[cfg.panic.values] Example values:</p>
<ul>
<li><code>"abort"</code></li>
<li><code>"unwind"</code></li>
</ul>
<h2 id="조건부-컴파일의-형태"><a class="header" href="#조건부-컴파일의-형태">조건부 컴파일의 형태</a></h2>
<!-- template:attributes -->
<p>r[cfg.attr]</p>
<h3 id="cfg-속성"><a class="header" href="#cfg-속성"><code>cfg</code> 속성</a></h3>
<p>r[cfg.attr.intro] The <em><code>cfg</code> <a href="attributes.html">attribute</a></em> conditionally includes the form to which it is attached based on a configuration predicate.</p>
<blockquote>
<p>[!EXAMPLE]</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 이 함수는 macOS용으로 컴파일할 때만 빌드에 포함됩니다.
#[cfg(target_os = "macos")]
fn macos_only() {
  // ...
}

// 이 함수는 foo 또는 bar 중 하나가 정의된 경우에만 포함됩니다.
#[cfg(any(foo, bar))]
fn needs_foo_or_bar() {
  // ...
}

// This function is only included when compiling for a unixish OS with a 32-bit
// architecture
#[cfg(all(unix, target_pointer_width = "32"))]
fn on_32bit_unix() {
  // ...
}

// 이 함수는 foo가 정의되지 않은 경우에만 포함됩니다.
#[cfg(not(foo))]
fn needs_not_foo() {
  // ...
}

// 이 함수는 패닉 전략이 unwind로 설정된 경우에만 포함됩니다.
#[cfg(panic = "unwind")]
fn when_unwinding() {
  // ...
}
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[cfg.attr.syntax] The syntax for the <code>cfg</code> attribute is:</p>
<pre><code class="language-grammar configuration">@root CfgAttribute -&gt; `cfg` `(` ConfigurationPredicate `)`
</code></pre>
<p>r[cfg.attr.allowed-positions] The <code>cfg</code> attribute may be used anywhere attributes are allowed.</p>
<p>r[cfg.attr.duplicates] The <code>cfg</code> attribute may be used any number of times on a form. The form to which the attributes are attached will not be included if any of the <code>cfg</code> predicates are false except as described in [cfg.attr.crate-level-attrs].</p>
<p>r[cfg.attr.effect] If the predicates are true, the form is rewritten to not have the <code>cfg</code> attributes on it. If any predicate is false, the form is removed from the source code.</p>
<p>r[cfg.attr.crate-level-attrs] When a crate-level <code>cfg</code> has a false predicate, the crate itself still exists. Any crate attributes preceding the <code>cfg</code> are kept, and any crate attributes following the <code>cfg</code> are removed as well as removing all of the following crate contents.</p>
<blockquote>
<p>[!EXAMPLE] The behavior of not removing the preceding attributes allows you to do things such as include <code>#![no_std]</code> to avoid linking <code>std</code> even if a <code>#![cfg(...)]</code> has otherwise removed the contents of the crate. For example:</p>
<!-- ignore: test infrastructure can't handle no_std -->
<pre><code class="language-rust ignore">// This `no_std` attribute is kept even though the crate-level `cfg`
// attribute is false.
#![no_std]
#![cfg(false)]

// This function is not included.
pub fn example() {}</code></pre>
</blockquote>
<!-- template:attributes -->
<p>r[cfg.cfg_attr]</p>
<h3 id="cfg_attr-속성"><a class="header" href="#cfg_attr-속성"><code>cfg_attr</code> 속성</a></h3>
<p>r[cfg.cfg_attr.intro] The <em><code>cfg_attr</code> <a href="attributes.html">attribute</a></em> conditionally includes attributes based on a configuration predicate.</p>
<blockquote>
<p>[!EXAMPLE] The following module will either be found at <code>linux.rs</code> or <code>windows.rs</code> based on the target.</p>
<!-- ignore: `mod` needs multiple files -->
<pre><code class="language-rust ignore">#[cfg_attr(target_os = "linux", path = "linux.rs")]
#[cfg_attr(windows, path = "windows.rs")]
mod os;</code></pre>
</blockquote>
<p>r[cfg.cfg_attr.syntax] The syntax for the <code>cfg_attr</code> attribute is:</p>
<pre><code class="language-grammar configuration">@root CfgAttrAttribute -&gt; `cfg_attr` `(` ConfigurationPredicate `,` CfgAttrs? `)`

CfgAttrs -&gt; Attr (`,` Attr)* `,`?
</code></pre>
<p>r[cfg.cfg_attr.allowed-positions] The <code>cfg_attr</code> attribute may be used anywhere attributes are allowed.</p>
<p>r[cfg.cfg_attr.duplicates] The <code>cfg_attr</code> attribute may be used any number of times on a form.</p>
<p>r[cfg.cfg_attr.attr-restriction] The <a href="linkage.html"><code>crate_type</code></a> and <a href="crates-and-source-files.html#the-crate_name-attribute"><code>crate_name</code></a> attributes cannot be used with <code>cfg_attr</code>.</p>
<p>r[cfg.cfg_attr.behavior] When the configuration predicate is true, <code>cfg_attr</code> expands out to the attributes listed after the predicate.</p>
<p>r[cfg.cfg_attr.attribute-list] Zero, one, or more attributes may be listed. Multiple attributes will each be expanded into separate attributes.</p>
<blockquote>
<p>[!EXAMPLE]</p>
<!-- ignore: fake attributes -->
<pre><code class="language-rust ignore">#[cfg_attr(feature = "magic", sparkles, crackles)]
fn bewitched() {}

// `magic` 피처 플래그가 활성화되면, 위 코드는 다음과 같이 확장됩니다:
#[sparkles]
#[crackles]
fn bewitched() {}</code></pre>
</blockquote>
<blockquote>
<p>[!NOTE] The <code>cfg_attr</code> can expand to another <code>cfg_attr</code>. For example, <code>#[cfg_attr(target_os = "linux", cfg_attr(feature = "multithreaded", some_other_attribute))]</code> is valid. This example would be equivalent to <code>#[cfg_attr(all(target_os = "linux", feature = "multithreaded"), some_other_attribute)]</code>.</p>
</blockquote>
<p>r[cfg.macro]</p>
<h3 id="cfg-매크로"><a class="header" href="#cfg-매크로"><code>cfg</code> 매크로</a></h3>
<p>내장된 <code>cfg</code> 매크로는 단일 구성 조건자를 취하며, 조건자가 참이면 <code>true</code> 리터럴로, 거짓이면 <code>false</code> 리터럴로 평가됩니다.</p>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let machine_kind = if cfg!(unix) {
  "unix"
} else if cfg!(windows) {
  "windows"
} else {
  "unknown"
};

println!("저는 {} 머신에서 실행 중입니다!", machine_kind);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p>r[items]</p>
<h1 id="아이템"><a class="header" href="#아이템">아이템</a></h1>
<p>r[items.syntax]</p>
<pre><code class="language-grammar items">Item -&gt;
    OuterAttribute* ( VisItem | MacroItem )

VisItem -&gt;
    Visibility?
    (
        Module
      | ExternCrate
      | UseDeclaration
      | Function
      | TypeAlias
      | Struct
      | Enumeration
      | Union
      | ConstantItem
      | StaticItem
      | Trait
      | Implementation
      | ExternBlock
    )

MacroItem -&gt;
      MacroInvocationSemi
    | MacroRulesDefinition
</code></pre>
<p>r[items.intro] An <em>item</em> is a component of a crate. Items are organized within a crate by a nested set of <a href="items/modules.html">modules</a>. Every crate has a single “outermost” anonymous module; all further items within the crate have <a href="paths.html">paths</a> within the module tree of the crate.</p>
<p>r[items.static-def] Items are entirely determined at compile-time, generally remain fixed during execution, and may reside in read-only memory.</p>
<p>r[items.kinds] There are several kinds of items:</p>
<ul>
<li><a href="items/modules.html">모듈</a></li>
<li><a href="items/extern-crates.html"><code>extern crate</code> 선언</a></li>
<li><a href="items/use-declarations.html"><code>use</code> 선언</a></li>
<li><a href="items/functions.html">함수 정의</a></li>
<li><a href="items/type-aliases.html">type alias definitions</a></li>
<li><a href="items/structs.html">구조체 정의</a></li>
<li><a href="items/enumerations.html">열거형 정의</a></li>
<li><a href="items/unions.html">공용체 정의</a></li>
<li><a href="items/constant-items.html">상수 아이템</a></li>
<li><a href="items/static-items.html">정적 아이템</a></li>
<li><a href="items/traits.html">트레잇 정의</a></li>
<li><a href="items/implementations.html">구현</a></li>
<li><a href="items/external-blocks.html"><code>extern</code> 블록</a></li>
</ul>
<p>r[items.locations] Items may be declared in the <a href="crates-and-source-files.html">root of the crate</a>, a <a href="items/modules.html">module</a>, or a <a href="expressions/block-expr.html">block expression</a>.</p>
<p>r[items.associated-locations] A subset of items, called <a href="items/associated-items.html">associated items</a>, may be declared in <a href="items/traits.html">traits</a> and <a href="items/implementations.html">implementations</a>.</p>
<p>r[items.extern-locations] A subset of items, called external items, may be declared in <a href="items/external-blocks.html"><code>extern</code> blocks</a>.</p>
<p>r[items.decl-order] Items may be defined in any order, with the exception of <a href="macros-by-example.html"><code>macro_rules</code></a> which has its own scoping behavior.</p>
<p>r[items.name-resolution] <a href="names/name-resolution.html">Name resolution</a> of item names allows items to be defined before or after where the item is referred to in the module or block.</p>
<p>아이템의 스코프 규칙에 대한 정보는 <a href="names/scopes.html#item-scopes">아이템 스코프</a>를 참조하십시오.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[items.mod]</p>
<h1 id="모듈"><a class="header" href="#모듈">모듈</a></h1>
<p>r[items.mod.syntax]</p>
<pre><code class="language-grammar items">Module -&gt;
      `unsafe`? `mod` IDENTIFIER `;`
    | `unsafe`? `mod` IDENTIFIER `{`
        InnerAttribute*
        Item*
      `}`
</code></pre>
<p>r[items.mod.intro] A module is a container for zero or more <a href="items/../items.html">items</a>.</p>
<p>r[items.mod.def] A <em>module item</em> is a module, surrounded in braces, named, and prefixed with the keyword <code>mod</code>. A module item introduces a new, named module into the tree of modules making up a crate.</p>
<p>r[items.mod.nesting] Modules can nest arbitrarily.</p>
<p>모듈의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod math {
    type Complex = (f64, f64);
    fn sin(f: f64) -&gt; f64 {
        /* ... */
<span class="boring">      unimplemented!();
</span>    }
    fn cos(f: f64) -&gt; f64 {
        /* ... */
<span class="boring">      unimplemented!();
</span>    }
    fn tan(f: f64) -&gt; f64 {
        /* ... */
<span class="boring">      unimplemented!();
</span>    }
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.mod.namespace] Modules are defined in the <a href="items/../names/namespaces.html">type namespace</a> of the module or block where they are located.</p>
<p>r[items.mod.multiple-items] It is an error to define multiple items with the same name in the same namespace within a module. See the <a href="items/../names/scopes.html">scopes chapter</a> for more details on restrictions and shadowing behavior.</p>
<p>r[items.mod.unsafe] The <code>unsafe</code> keyword is syntactically allowed to appear before the <code>mod</code> keyword, but it is rejected at a semantic level. This allows macros to consume the syntax and make use of the <code>unsafe</code> keyword, before removing it from the token stream.</p>
<p>r[items.mod.outlined]</p>
<h2 id="module-source-filenames"><a class="header" href="#module-source-filenames">Module source filenames</a></h2>
<p>r[items.mod.outlined.intro] A module without a body is loaded from an external file. When the module does not have a <code>path</code> attribute, the path to the file mirrors the logical <a href="items/../paths.html">module path</a>.</p>
<p>r[items.mod.outlined.search] Ancestor module path components are directories, and the module’s contents are in a file with the name of the module plus the <code>.rs</code> extension. For example, the following module structure can have this corresponding filesystem structure:</p>
<div class="table-wrapper"><table><thead><tr><th>모듈 경로</th><th>파일시스템 경로</th><th>파일 내용</th></tr></thead><tbody>
<tr><td><code>crate</code></td><td><code>lib.rs</code></td><td><code>mod util;</code></td></tr>
<tr><td><code>crate::util</code></td><td><code>util.rs</code></td><td><code>mod config;</code></td></tr>
<tr><td><code>crate::util::config</code></td><td><code>util/config.rs</code></td><td></td></tr>
</tbody></table>
</div>
<p>r[items.mod.outlined.search-mod] Module filenames may also be the name of the module as a directory with the contents in a file named <code>mod.rs</code> within that directory. The above example can alternately be expressed with <code>crate::util</code>’s contents in a file named <code>util/mod.rs</code>. It is not allowed to have both <code>util.rs</code> and <code>util/mod.rs</code>.</p>
<blockquote>
<p>[!NOTE] Prior to <code>rustc</code> 1.30, using <code>mod.rs</code> files was the way to load a module with nested children. It is encouraged to use the new naming convention as it is more consistent, and avoids having many files named <code>mod.rs</code> within a project.</p>
</blockquote>
<p>r[items.mod.outlined.path]</p>
<h3 id="path-속성"><a class="header" href="#path-속성"><code>path</code> 속성</a></h3>
<p>r[items.mod.outlined.path.intro] The directories and files used for loading external file modules can be influenced with the <code>path</code> attribute.</p>
<p>r[items.mod.outlined.path.search] For <code>path</code> attributes on modules not inside inline module blocks, the file path is relative to the directory the source file is located. For example, the following code snippet would use the paths shown based on where it is located:</p>
<!-- ignore: requires external files -->
<pre><code class="language-rust ignore">#[path = "foo.rs"]
mod c;</code></pre>
<div class="table-wrapper"><table><thead><tr><th>소스 파일</th><th><code>c</code>의 파일 위치</th><th><code>c</code>의 모듈 경로</th></tr></thead><tbody>
<tr><td><code>src/a/b.rs</code></td><td><code>src/a/foo.rs</code></td><td><code>crate::a::b::c</code></td></tr>
<tr><td><code>src/a/mod.rs</code></td><td><code>src/a/foo.rs</code></td><td><code>crate::a::c</code></td></tr>
</tbody></table>
</div>
<p>r[items.mod.outlined.path.search-nested] For <code>path</code> attributes inside inline module blocks, the relative location of the file path depends on the kind of source file the <code>path</code> attribute is located in. “mod-rs” source files are root modules (such as <code>lib.rs</code> or <code>main.rs</code>) and modules with files named <code>mod.rs</code>. “non-mod-rs” source files are all other module files. Paths for <code>path</code> attributes inside inline module blocks in a mod-rs file are relative to the directory of the mod-rs file including the inline module components as directories. For non-mod-rs files, it is the same except the path starts with a directory with the name of the non-mod-rs module. For example, the following code snippet would use the paths shown based on where it is located:</p>
<!-- ignore: requires external files -->
<pre><code class="language-rust ignore">mod inline {
    #[path = "other.rs"]
    mod inner;
}</code></pre>
<div class="table-wrapper"><table><thead><tr><th>소스 파일</th><th><code>inner</code>의 파일 위치</th><th><code>inner</code>의 모듈 경로</th></tr></thead><tbody>
<tr><td><code>src/a/b.rs</code></td><td><code>src/a/b/inline/other.rs</code></td><td><code>crate::a::b::inline::inner</code></td></tr>
<tr><td><code>src/a/mod.rs</code></td><td><code>src/a/inline/other.rs</code></td><td><code>crate::a::inline::inner</code></td></tr>
</tbody></table>
</div>
<p>인라인 모듈의 <code>path</code> 속성 규칙과 그 내부의 중첩된 모듈 규칙을 결합한 예(mod-rs 파일과 non-mod-rs 파일 모두에 적용됨):</p>
<!-- ignore: requires external files -->
<pre><code class="language-rust ignore">#[path = "thread_files"]
mod thread {
    // 이 소스 파일의 디렉토리를 기준으로 `thread_files/tls.rs`에서 `local_data` 모듈을 로드합니다.
    #[path = "tls.rs"]
    mod local_data;
}</code></pre>
<p>r[items.mod.attributes]</p>
<h2 id="attributes-on-modules"><a class="header" href="#attributes-on-modules">Attributes on modules</a></h2>
<p>r[items.mod.attributes.intro] Modules, like all items, accept outer attributes. They also accept inner attributes: either after <code>{</code> for a module with a body, or at the beginning of the source file, after the optional BOM and shebang.</p>
<p>r[items.mod.attributes.supported] The built-in attributes that have meaning on a module are <a href="items/../conditional-compilation.html"><code>cfg</code></a>, <a href="items/../attributes/diagnostics.html#the-deprecated-attribute"><code>deprecated</code></a>, <a href="items/../../rustdoc/the-doc-attribute.html"><code>doc</code></a>, <a href="items/../attributes/diagnostics.html#lint-check-attributes">the lint check attributes</a>, <a href="items/modules.html#the-path-attribute"><code>path</code></a>, and <a href="items/../names/preludes.html#the-no_implicit_prelude-attribute"><code>no_implicit_prelude</code></a>. Modules also accept macro attributes.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[items.extern-crate]</p>
<h1 id="외부-크레이트-선언"><a class="header" href="#외부-크레이트-선언">외부 크레이트 선언</a></h1>
<p>r[items.extern-crate.syntax]</p>
<pre><code class="language-grammar items">ExternCrate -&gt; `extern` `crate` CrateRef AsClause? `;`

CrateRef -&gt; IDENTIFIER | `self`

AsClause -&gt; `as` ( IDENTIFIER | `_` )
</code></pre>
<p>r[items.extern-crate.intro] An <em><code>extern crate</code> declaration</em> specifies a dependency on an external crate.</p>
<p>r[items.extern-crate.namespace] The external crate is then bound into the declaring scope as the given <a href="items/../identifiers.html">identifier</a> in the <a href="items/../names/namespaces.html">type namespace</a>.</p>
<p>r[items.extern-crate.extern-prelude] Additionally, if the <code>extern crate</code> appears in the crate root, then the crate name is also added to the <a href="items/../names/preludes.html#extern-prelude">extern prelude</a>, making it automatically in scope in all modules.</p>
<p>r[items.extern-crate.as] The <code>as</code> clause can be used to bind the imported crate to a different name.</p>
<p>r[items.extern-crate.lookup] The external crate is resolved to a specific <code>soname</code> at compile time, and a runtime linkage requirement to that <code>soname</code> is passed to the linker for loading at runtime. The <code>soname</code> is resolved at compile time by scanning the compiler’s library path and matching the optional <code>crate_name</code> provided against the <a href="items/../crates-and-source-files.html#the-crate_name-attribute"><code>crate_name</code> attributes</a> that were declared on the external crate when it was compiled. If no <code>crate_name</code> is provided, a default <code>name</code> attribute is assumed, equal to the <a href="items/../identifiers.html">identifier</a> given in the <code>extern crate</code> declaration.</p>
<p>r[items.extern-crate.self] The <code>self</code> crate may be imported which creates a binding to the current crate. In this case the <code>as</code> clause must be used to specify the name to bind it to.</p>
<p><code>extern crate</code> 선언의 세 가지 예시:</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">extern crate pcre;

extern crate std; // extern crate std as std;와 동일합니다.

extern crate std as ruststd; // 다른 이름으로 'std'를 링크합니다.</code></pre>
<p>r[items.extern-crate.name-restrictions] When naming Rust crates, hyphens are disallowed. However, Cargo packages may make use of them. In such case, when <code>Cargo.toml</code> doesn’t specify a crate name, Cargo will transparently replace <code>-</code> with <code>_</code> (Refer to <a href="https://github.com/rust-lang/rfcs/blob/master/text/0940-hyphens-considered-harmful.md">RFC 940</a> for more details).</p>
<p>예시는 다음과 같습니다:</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">// hello-world Cargo 패키지 임포트
extern crate hello_world; // 하이픈이 밑줄로 대체됨</code></pre>
<p>r[items.extern-crate.underscore]</p>
<h2 id="underscore-imports"><a class="header" href="#underscore-imports">Underscore imports</a></h2>
<p>r[items.extern-crate.underscore.intro] An external crate dependency can be declared without binding its name in scope by using an underscore with the form <code>extern crate foo as _</code>. This may be useful for crates that only need to be linked, but are never referenced, and will avoid being reported as unused.</p>
<p>r[items.extern-crate.underscore.macro_use] The <a href="items/../macros-by-example.html#the-macro_use-attribute"><code>macro_use</code> attribute</a> works as usual and imports the macro names into the <a href="items/../names/preludes.html#macro_use-prelude"><code>macro_use</code> prelude</a>.</p>
<!-- template:attributes -->
<p>r[items.extern-crate.no_link]</p>
<h2 id="no_link-속성"><a class="header" href="#no_link-속성"><code>no_link</code> 속성</a></h2>
<p>r[items.extern-crate.no_link.intro] The <em><code>no_link</code> [attribute][attributes]</em> may be applied to an <code>extern crate</code> item to prevent linking the crate.</p>
<blockquote>
<p>[!NOTE] This is helpful, e.g., when only the macros of a crate are needed.</p>
</blockquote>
<blockquote>
<p>[!EXAMPLE]</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">#[no_link]
extern crate other_crate;

other_crate::some_macro!();</code></pre>
</blockquote>
<p>r[items.extern-crate.no_link.syntax] The <code>no_link</code> attribute uses the [MetaWord] syntax.</p>
<p>r[items.extern-crate.no_link.allowed-positions] The <code>no_link</code> attribute may only be applied to an <code>extern crate</code> declaration.</p>
<blockquote>
<p>[!NOTE] <code>rustc</code> ignores use in other positions but lints against it. This may become an error in the future.</p>
</blockquote>
<p>r[items.extern-crate.no_link.duplicates] Only the first use of <code>no_link</code> on an <code>extern crate</code> declaration has effect.</p>
<blockquote>
<p>[!NOTE] <code>rustc</code> lints against any use following the first. This may become an error in the future.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>r[items.use]</p>
<h1 id="use-선언"><a class="header" href="#use-선언">Use 선언</a></h1>
<p>r[items.use.syntax]</p>
<pre><code class="language-grammar items">UseDeclaration -&gt; `use` UseTree `;`

UseTree -&gt;
      (SimplePath? `::`)? `*`
    | (SimplePath? `::`)? `{` (UseTree ( `,`  UseTree )* `,`?)? `}`
    | SimplePath ( `as` ( IDENTIFIER | `_` ) )?
</code></pre>
<p>r[items.use.intro] A <em>use declaration</em> creates one or more local name bindings synonymous with some other <a href="items/../paths.html">path</a>. Usually a <code>use</code> declaration is used to shorten the path required to refer to a module item. These declarations may appear in <a href="items/modules.html">modules</a> and <a href="items/../expressions/block-expr.html">blocks</a>, usually at the top. A <code>use</code> declaration is also sometimes called an <em>import</em>, or, if it is public, a <em>re-export</em>.</p>
<p>r[items.use.forms] Use declarations support a number of convenient shortcuts:</p>
<p>r[items.use.forms.multiple]</p>
<ul>
<li><code>use a::b::{c, d, e::f, g::h::i};</code>와 같이 중괄호 구문을 사용하여 공통 접두사를 가진 경로 목록을 동시에 바인딩합니다.</li>
</ul>
<p>r[items.use.forms.self]</p>
<ul>
<li><code>use a::b::{self, c, d::e};</code>와 같이 <code>self</code> 키워드를 사용하여 공통 접두사를 가진 경로 목록과 그들의 공통 부모 모듈을 동시에 바인딩합니다.</li>
</ul>
<p>r[items.use.forms.as]</p>
<ul>
<li><code>use p::q::r as x;</code> 구문을 사용하여 대상 이름을 새로운 로컬 이름으로 다시 바인딩합니다. 이는 앞의 두 기능과 함께 사용될 수도 있습니다: <code>use a::b::{self as ab, c as abc}</code>.</li>
</ul>
<p>r[items.use.forms.glob]</p>
<ul>
<li>별표 와일드카드 구문인 <code>use a::b::*;</code>를 사용하여 주어진 접두사와 일치하는 모든 경로를 바인딩합니다.</li>
</ul>
<p>r[items.use.forms.nesting]</p>
<ul>
<li><code>use a::b::{self as ab, c, d::{*, e::f}};</code>와 같이 이전 기능들의 그룹을 여러 번 중첩하여 사용합니다.</li>
</ul>
<p><code>use</code> 선언의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::collections::hash_map::{self, HashMap};

fn foo&lt;T&gt;(_: T){}
fn bar(map1: HashMap&lt;String, usize&gt;, map2: hash_map::HashMap&lt;String, usize&gt;){}

fn main() {
    // use 선언은 함수 내부에도 존재할 수 있습니다
    use std::option::Option::{Some, None};

    // 'foo(vec![std::option::Option::Some(1.0f64),
    // std::option::Option::None]);'와 동일합니다.
    foo(vec![Some(1.0f64), None]);

    // `hash_map`과 `HashMap` 모두 스코프에 있습니다.
    let map1 = HashMap::new();
    let map2 = hash_map::HashMap::new();
    bar(map1, map2);
}</code></pre></pre>
<p>r[items.use.visibility]</p>
<h2 id="use-가시성"><a class="header" href="#use-가시성"><code>use</code> 가시성</a></h2>
<p>r[items.use.visibility.intro] Like items, <code>use</code> declarations are private to the containing module, by default. Also like items, a <code>use</code> declaration can be public, if qualified by the <code>pub</code> keyword. Such a <code>use</code> declaration serves to <em>re-export</em> a name. A public <code>use</code> declaration can therefore <em>redirect</em> some public name to a different target definition: even a definition with a private canonical path, inside a different module.</p>
<p>r[items.use.visibility.unambiguous] If a sequence of such redirections form a cycle or cannot be resolved unambiguously, they represent a compile-time error.</p>
<p>다시 내보내기(re-exporting)의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024">mod quux {
    pub use self::foo::{bar, baz};
    pub mod foo {
        pub fn bar() {}
        pub fn baz() {}
    }
}

fn main() {
    quux::bar();
    quux::baz();
}</code></pre></pre>
<p>이 예제에서 <code>quux</code> 모듈은 <code>foo</code>에 정의된 두 개의 공개 이름을 다시 내보냅니다.</p>
<p>r[items.use.path]</p>
<h2 id="use-경로"><a class="header" href="#use-경로"><code>use</code> 경로</a></h2>
<p>r[items.use.path.intro] The <a href="items/../paths.html">paths</a> that are allowed in a <code>use</code> item follow the [SimplePath] grammar and are similar to the paths that may be used in an expression. They may create bindings for:</p>
<ul>
<li>이름을 지을 수 있는 <a href="items/../items.html">아이템</a></li>
<li><a href="items/enumerations.html">열거형 변형</a></li>
<li><a href="items/../types.html">내장 타입</a></li>
<li><a href="items/../attributes.html">속성</a></li>
<li><a href="items/macro.proc.derive">Derive macros</a></li>
<li><a href="items/../macros-by-example.html"><code>macro_rules</code></a></li>
</ul>
<p>r[items.use.path.disallowed] They cannot import <a href="items/associated-items.html">associated items</a>, <a href="items/generics.html">generic parameters</a>, <a href="items/../variables.html">local variables</a>, paths with <a href="items/../paths.html#self"><code>Self</code></a>, or <a href="items/../attributes.html#tool-attributes">tool attributes</a>. More restrictions are described below.</p>
<p>r[items.use.path.namespace] <code>use</code> will create bindings for all <a href="items/../names/namespaces.html">namespaces</a> from the imported entities, with the exception that a <code>self</code> import will only import from the type namespace (as described below). For example, the following illustrates creating bindings for the same name in two namespaces:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod stuff {
    pub struct Foo(pub i32);
}

// `Foo` 타입과 `Foo` 생성자를 임포트합니다.
use stuff::Foo;

fn example() {
    let ctor = Foo; // 값 네임스페이스에서 `Foo`를 사용합니다.
    let x: Foo = ctor(123); // 타입 네임스페이스에서 `Foo`를 사용합니다.
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.use.path.edition2018]</p>
<blockquote>
<p>[!EDITION-2018] In the 2015 edition, <code>use</code> paths are relative to the crate root. For example:</p>
<pre><pre class="playground"><code class="language-rust edition2015">mod foo {
    pub mod example { pub mod iter {} }
    pub mod baz { pub fn foobaz() {} }
}
mod bar {
    // 크레이트 루트에서 `foo`를 확인합니다.
    use foo::example::iter;
    // `::` 접두사는 명시적으로 `foo`를 확인합니다.
    // 크레이트 루트로부터.
    use ::foo::baz::foobaz;
}

<span class="boring">fn main() {}</span></code></pre></pre>
<p>2015 에디션은 use 선언이 <a href="items/../names/preludes.html#extern-prelude">extern 프렐류드</a>를 참조하는 것을 허용하지 않습니다. 따라서 2015 에디션에서 use 선언으로 외부 크레이트를 참조하려면 여전히 <a href="items/extern-crates.html"><code>extern crate</code></a> 선언이 필요합니다. 2018 에디션부터는 <code>use</code> 선언에서 <code>extern crate</code>와 동일한 방식으로 외부 크레이트 의존성을 지정할 수 있습니다.</p>
</blockquote>
<p>r[items.use.as]</p>
<h2 id="as를-이용한-이름-변경"><a class="header" href="#as를-이용한-이름-변경"><code>as</code>를 이용한 이름 변경</a></h2>
<p><code>as</code> 키워드는 임포트된 엔티티의 이름을 변경하는 데 사용될 수 있습니다. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 함수 `foo`에 대한 비공개 별칭 `bar`를 생성합니다.
use inner::foo as bar;

mod inner {
    pub fn foo() {}
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.use.multiple-syntax]</p>
<h2 id="중괄호-구문"><a class="header" href="#중괄호-구문">중괄호 구문</a></h2>
<p>r[items.use.multiple-syntax.intro] Braces can be used in the last segment of the path to import multiple entities from the previous segment, or, if there are no previous segments, from the current scope. Braces can be nested, creating a tree of paths, where each grouping of segments is logically combined with its parent to create a full path.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 다음에 대한 바인딩을 생성합니다:
// - `std::collections::BTreeSet`
// - `std::collections::hash_map`
// - `std::collections::hash_map::HashMap`
// 다음에 대한 바인딩을 생성합니다:
// - `std::collections::BTreeSet`
// - `std::collections::hash_map`
// - `std::collections::hash_map::HashMap`
use std::collections::{BTreeSet, hash_map::{self, HashMap}};
<span class="boring">}</span></code></pre></pre>
<p>r[items.use.multiple-syntax.empty] An empty brace does not import anything, though the leading path is validated that it is accessible.</p>
<!-- This is slightly wrong, see: https://github.com/rust-lang/rust/issues/61826 -->
<p>r[items.use.multiple-syntax.edition2018]</p>
<blockquote>
<p>[!EDITION-2018] In the 2015 edition, paths are relative to the crate root, so an import such as <code>use {foo, bar};</code> will import the names <code>foo</code> and <code>bar</code> from the crate root, whereas starting in 2018, those names are relative to the current scope.</p>
</blockquote>
<p>r[items.use.self]</p>
<h2 id="self-임포트"><a class="header" href="#self-임포트"><code>self</code> 임포트</a></h2>
<p>r[items.use.self.intro] The keyword <code>self</code> may be used within <a href="items/use-declarations.html#brace-syntax">brace syntax</a> to create a binding of the parent entity under its own name.</p>
<pre><pre class="playground"><code class="language-rust edition2024">mod stuff {
    pub fn foo() {}
    pub fn bar() {}
}
mod example {
    // `stuff`와 `foo`에 대한 바인딩을 생성합니다.
    use crate::stuff::{self, foo};
    pub fn baz() {
        foo();
        stuff::bar();
    }
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>r[items.use.self.namespace] <code>self</code> only creates a binding from the <a href="items/../names/namespaces.html">type namespace</a> of the parent entity. For example, in the following, only the <code>foo</code> mod is imported:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024">mod bar {
    pub mod foo {}
    pub fn foo() {}
}

// 이는 `foo` 모듈만 임포트합니다. `foo` 함수는 값 네임스페이스에 존재하므로 임포트되지 않습니다.
use bar::foo::{self};

fn main() {
    foo(); //~ 오류: `foo`는 모듈입니다.
}</code></pre></pre>
<blockquote>
<p>[!NOTE] <code>self</code> may also be used as the first segment of a path. The usage of <code>self</code> as the first segment and inside a <code>use</code> brace is logically the same; it means the current module of the parent segment, or the current module if there is no parent segment. See <a href="items/../paths.html#self"><code>self</code></a> in the paths chapter for more information on the meaning of a leading <code>self</code>.</p>
</blockquote>
<p>r[items.use.glob]</p>
<h2 id="글로브-임포트"><a class="header" href="#글로브-임포트">글로브 임포트</a></h2>
<p>r[items.use.glob.intro] The <code>*</code> character may be used as the last segment of a <code>use</code> path to import all importable entities from the entity of the preceding segment. For example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `bar`에 대한 비공개 별칭을 생성합니다.
use foo::*;

mod foo {
    fn i_am_private() {}
    enum Example {
        V1,
        V2,
    }
    pub fn bar() {
        // `Example` 열거형의 `V1`과 `V2`에 대한
        // 지역 별칭을 생성합니다.
        use Example::*;
        let x = V1;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.use.glob.shadowing] Items and named imports are allowed to shadow names from glob imports in the same <a href="items/../names/namespaces.html">namespace</a>. That is, if there is a name already defined by another item in the same namespace, the glob import will be shadowed. For example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 이것은 `clashing::Foo` 튜플 구조체 생성자에 대한 바인딩을 생성하지만,
// 여기에 정의된 `Foo` 구조체와 충돌하기 때문에 그 타입은 임포트하지
// 않습니다.
//
// 여기서 정의 순서는 중요하지 않음에 유의하세요.
use clashing::*;
struct Foo {
    field: f32,
}

fn do_stuff() {
    // `clashing::Foo`의 생성자를 사용합니다.
    let f1 = Foo(123);
    // 구조체 표현식은 위에서 정의된
    // `Foo` 구조체의 타입을 사용합니다.
    let f2 = Foo { field: 1.0 };
    // 글로브 임포트로 인해 `Bar`도 스코프에 있습니다.
    let z = Bar {};
}

mod clashing {
    pub struct Foo(pub i32);
    pub struct Bar {}
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] For areas where shadowing is not allowed, see <a href="items/names.resolution.expansion.imports.ambiguity">name resolution ambiguities</a>.</p>
</blockquote>
<p>r[items.use.glob.last-segment-only] <code>*</code> cannot be used as the first or intermediate segments.</p>
<p>r[items.use.glob.self-import] <code>*</code> cannot be used to import a module’s contents into itself (such as <code>use self::*;</code>).</p>
<p>r[items.use.glob.edition2018]</p>
<blockquote>
<p>[!EDITION-2018] In the 2015 edition, paths are relative to the crate root, so an import such as <code>use *;</code> is valid, and it means to import everything from the crate root. This cannot be used in the crate root itself.</p>
</blockquote>
<p>r[items.use.as-underscore]</p>
<h2 id="underscore-imports-1"><a class="header" href="#underscore-imports-1">Underscore imports</a></h2>
<p>r[items.use.as-underscore.intro] Items can be imported without binding to a name by using an underscore with the form <code>use path as _</code>. This is particularly useful to import a trait so that its methods may be used without importing the trait’s symbol, for example if the trait’s symbol may conflict with another symbol. Another example is to link an external crate without importing its name.</p>
<p>r[items.use.as-underscore.glob] Asterisk glob imports will import items imported with <code>_</code> in their unnameable form.</p>
<pre><pre class="playground"><code class="language-rust edition2024">mod foo {
    pub trait Zoo {
        fn zoo(&amp;self) {}
    }

    impl&lt;T&gt; Zoo for T {}
}

use self::foo::Zoo as _;
struct Zoo;  // 밑줄 임포트는 이 아이템과의 이름 충돌을 방지합니다.

fn main() {
    let z = Zoo;
    z.zoo();
}</code></pre></pre>
<p>r[items.use.as-underscore.macro] The unique, unnameable symbols are created after macro expansion so that macros may safely emit multiple references to <code>_</code> imports. For example, the following should not produce an error:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! m {
    ($item: item) =&gt; { $item $item }
}

m!(use std as _;);
// 다음과 같이 확장됩니다:
// use std as _;
// use std as _;
<span class="boring">}</span></code></pre></pre>
<p>r[items.use.restrictions]</p>
<h2 id="제약-사항"><a class="header" href="#제약-사항">제약 사항</a></h2>
<p>다음은 유효한 <code>use</code> 선언에 대한 제약 사항입니다:</p>
<p>r[items.use.restrictions.crate]</p>
<ul>
<li><code>use crate;</code>는 크레이트 루트를 바인딩할 이름을 정의하기 위해 반드시 <code>as</code>를 사용해야 합니다.</li>
</ul>
<p>r[items.use.restrictions.self]</p>
<ul>
<li><code>use {self};</code>는 오류입니다. <code>self</code>를 사용할 때는 반드시 선행 세그먼트가 있어야 합니다.</li>
</ul>
<p>r[items.use.restrictions.duplicate-name]</p>
<ul>
<li>다른 아이템 정의와 마찬가지로, <code>use</code> 임포트는 모듈이나 블록 내의 동일한 네임스페이스에서 같은 이름으로 중복 바인딩을 생성할 수 없습니다.</li>
</ul>
<p>r[items.use.restrictions.macro-crate]</p>
<ul>
<li><code>$crate</code>를 포함한 <code>use</code> 경로는 <a href="items/../macros-by-example.html"><code>macro_rules</code></a> 확장 내에서 허용되지 않습니다.</li>
</ul>
<p>r[items.use.restrictions.variant]</p>
<ul>
<li><code>use</code> 경로는 <a href="items/type-aliases.html">타입 별칭</a>을 통해 열거형 변형을 참조할 수 없습니다. 예를 들어:
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum MyEnum {
    MyVariant
}
type TypeAlias = MyEnum;

use MyEnum::MyVariant; //~ OK
use TypeAlias::MyVariant; //~ 오류
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>r[items.fn]</p>
<h1 id="함수"><a class="header" href="#함수">함수</a></h1>
<p>r[items.fn.syntax]</p>
<pre><code class="language-grammar items">Function -&gt;
    FunctionQualifiers `fn` IDENTIFIER GenericParams?
        `(` FunctionParameters? `)`
        FunctionReturnType? WhereClause?
        ( BlockExpression | `;` )

FunctionQualifiers -&gt; `const`? `async`?[^async-edition] ItemSafety?[^extern-qualifiers] (`extern` Abi?)?

ItemSafety -&gt; `safe`[^extern-safe] | `unsafe`

Abi -&gt; STRING_LITERAL | RAW_STRING_LITERAL

FunctionParameters -&gt;
      SelfParam `,`?
    | (SelfParam `,`)? FunctionParam (`,` FunctionParam)* `,`?

SelfParam -&gt; OuterAttribute* ( ShorthandSelf | TypedSelf )

ShorthandSelf -&gt; (`&amp;` | `&amp;` Lifetime)? `mut`? `self`

TypedSelf -&gt; `mut`? `self` `:` Type

FunctionParam -&gt; OuterAttribute* ( FunctionParamPattern | `...` | Type[^fn-param-2015] )

FunctionParamPattern -&gt; PatternNoTopAlt `:` ( Type | `...` )

FunctionReturnType -&gt; `-&gt;` Type
</code></pre>
<div class="footnote-definition" id="async-edition"><sup class="footnote-definition-label">1</sup>
<p><code>async</code> 한정자는 2015 에디션에서 허용되지 않습니다.</p>
</div>
<div class="footnote-definition" id="extern-safe"><sup class="footnote-definition-label">2</sup>
<p><code>safe</code> 함수 한정자는 시맨틱적으로 <code>extern</code> 블록 내에서만 허용됩니다.</p>
</div>
<div class="footnote-definition" id="extern-qualifiers"><sup class="footnote-definition-label">3</sup>
<p><em>Rust 2024 이전 에디션 관련</em>: <code>extern</code> 블록 내에서, <code>safe</code> 또는 <code>unsafe</code> 함수 한정자는 <code>extern</code>이 <code>unsafe</code>로 한정될 때만 허용됩니다.</p>
</div>
<div class="footnote-definition" id="fn-param-2015"><sup class="footnote-definition-label">4</sup>
<p>타입만 있는 함수 매개변수는 2015 에디션에서 <a href="items/traits.html">트레잇 아이템</a>의 연관 함수에서만 허용됩니다.</p>
</div>
<p>r[items.fn.intro] A <em>function</em> consists of a <a href="items/../expressions/block-expr.html">block</a> (that’s the <em>body</em> of the function), along with a name, a set of parameters, and an output type. Other than a name, all these are optional.</p>
<p>r[items.fn.namespace] Functions are declared with the keyword <code>fn</code> which defines the given name in the <a href="items/../names/namespaces.html">value namespace</a> of the module or block where it is located.</p>
<p>r[items.fn.signature] Functions may declare a set of <em>input</em> <a href="items/../variables.html"><em>variables</em></a> as parameters, through which the caller passes arguments into the function, and the <em>output</em> <a href="items/../types.html#type-expressions"><em>type</em></a> of the value the function will return to its caller on completion.</p>
<p>r[items.fn.implicit-return] If the output type is not explicitly stated, it is the <a href="items/../types/tuple.html">unit type</a>.</p>
<p>r[items.fn.fn-item-type] When referred to, a <em>function</em> yields a first-class <em>value</em> of the corresponding zero-sized <a href="items/../types/function-item.html"><em>function item type</em></a>, which when called evaluates to a direct call to the function.</p>
<p>예를 들어, 이것은 간단한 함수입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn answer_to_life_the_universe_and_everything() -&gt; i32 {
    return 42;
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.fn.safety-qualifiers] The <code>safe</code> function is semantically only allowed when used in an <a href="items/external-blocks.html"><code>extern</code> block</a>.</p>
<p>r[items.fn.params]</p>
<h2 id="함수-매개변수"><a class="header" href="#함수-매개변수">함수 매개변수</a></h2>
<p>r[items.fn.params.intro] Function parameters are irrefutable <a href="items/../patterns.html">patterns</a>, so any pattern that is valid in an else-less <code>let</code> binding is also valid as a parameter:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn first((value, _): (i32, i32)) -&gt; i32 { value }
<span class="boring">}</span></code></pre></pre>
<p>r[items.fn.params.self-pat] If the first parameter is a [SelfParam], this indicates that the function is a <a href="items/associated-items.html#methods">method</a>.</p>
<p>r[items.fn.params.self-restriction] Functions with a self parameter may only appear as an <a href="items/associated-items.html#associated-functions-and-methods">associated function</a> in a <a href="items/traits.html">trait</a> or <a href="items/implementations.html">implementation</a>.</p>
<p>r[items.fn.params.varargs] A parameter with the <code>...</code> token indicates a <a href="items/external-blocks.html#variadic-functions">variadic function</a>, and may only be used as the last parameter of an <a href="items/external-blocks.html">external block</a> function. The variadic parameter may have an optional identifier, such as <code>args: ...</code>.</p>
<p>r[items.fn.body]</p>
<h2 id="함수-본문"><a class="header" href="#함수-본문">함수 본문</a></h2>
<p>r[items.fn.body.intro] The body block of a function is conceptually wrapped in another block that first binds the argument patterns and then <code>return</code>s the value of the function’s body. This means that the tail expression of the block, if evaluated, ends up being returned to the caller. As usual, an explicit return expression within the body of the function will short-cut that implicit return, if reached.</p>
<p>예를 들어, 위의 함수는 마치 다음과 같이 작성된 것처럼 동작합니다:</p>
<!-- ignore: example expansion -->
<pre><code class="language-rust ignore">// argument_0은 호출자로부터 전달된 실제 첫 번째 인자입니다.
let (value, _) = argument_0;
return {
    value
};</code></pre>
<p>r[items.fn.body.bodyless] Functions without a body block are terminated with a semicolon. This form may only appear in a <a href="items/traits.html">trait</a> or <a href="items/external-blocks.html">external block</a>.</p>
<p>r[items.fn.generics]</p>
<h2 id="제네릭-함수"><a class="header" href="#제네릭-함수">제네릭 함수</a></h2>
<p>r[items.fn.generics.intro] A <em>generic function</em> allows one or more <em>parameterized types</em> to appear in its signature. Each type parameter must be explicitly declared in an angle-bracket-enclosed and comma-separated list, following the function name.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// foo는 A와 B에 대해 제네릭합니다.

fn foo&lt;A, B&gt;(x: A, y: B) {
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>r[items.fn.generics.param-names] Inside the function signature and body, the name of the type parameter can be used as a type name.</p>
<p>r[items.fn.generics.param-bounds] <a href="items/traits.html">Trait</a> bounds can be specified for type parameters to allow methods with that trait to be called on values of that type. This is specified using the <code>where</code> syntax:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::fmt::Debug;
</span>fn foo&lt;T&gt;(x: T) where T: Debug {
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>r[items.fn.generics.mono] When a generic function is referenced, its type is instantiated based on the context of the reference. For example, calling the <code>foo</code> function here:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Debug;

fn foo&lt;T&gt;(x: &amp;[T]) where T: Debug {
    // 세부 사항 생략
}

foo(&amp;[1, 2]);
<span class="boring">}</span></code></pre></pre>
<p>타입 매개변수 <code>T</code>를 <code>i32</code>로 인스턴스화할 것입니다.</p>
<p>r[items.fn.generics.explicit-arguments] The type parameters can also be explicitly supplied in a trailing <a href="items/../paths.html">path</a> component after the function name. This might be necessary if there is not sufficient context to determine the type parameters. For example, <code>mem::size_of::&lt;u32&gt;() == 4</code>.</p>
<p>r[items.fn.extern]</p>
<h2 id="외부-함수-한정자"><a class="header" href="#외부-함수-한정자">외부 함수 한정자</a></h2>
<p>r[items.fn.extern.intro] The <code>extern</code> function qualifier allows providing function <em>definitions</em> that can be called with a particular ABI:</p>
<!-- ignore: fake ABI -->
<pre><code class="language-rust ignore">extern "ABI" fn foo() { /* ... */ }</code></pre>
<p>r[items.fn.extern.def] These are often used in combination with <a href="items/external-blocks.html">external block</a> items which provide function <em>declarations</em> that can be used to call functions without providing their <em>definition</em>:</p>
<!-- ignore: fake ABI -->
<pre><code class="language-rust ignore">unsafe extern "ABI" {
  unsafe fn foo(); /* 본문 없음 */
  safe fn bar(); /* 본문 없음 */
}
unsafe { foo() };
bar();</code></pre>
<p>r[items.fn.extern.default-abi] When <code>"extern" Abi?*</code> is omitted from <code>FunctionQualifiers</code> in function items, the ABI <code>"Rust"</code> is assigned. For example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {}
<span class="boring">}</span></code></pre></pre>
<p>다음과 동일합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern "Rust" fn foo() {}
<span class="boring">}</span></code></pre></pre>
<p>r[items.fn.extern.foreign-call] Functions can be called by foreign code, and using an ABI that differs from Rust allows, for example, to provide functions that can be called from other programming languages like C:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// "C" ABI를 가진 함수를 선언합니다.
extern "C" fn new_i32() -&gt; i32 { 0 }

// "stdcall" ABI를 가진 함수를 선언합니다.
<span class="boring">#[cfg(any(windows, target_arch = "x86"))]
</span>extern "stdcall" fn new_i32_stdcall() -&gt; i32 { 0 }
<span class="boring">}</span></code></pre></pre>
<p>r[items.fn.extern.default-extern] Just as with <a href="items/external-blocks.html">external block</a>, when the <code>extern</code> keyword is used and the <code>"ABI"</code> is omitted, the ABI used defaults to <code>"C"</code>. That is, this:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern fn new_i32() -&gt; i32 { 0 }
let fptr: extern fn() -&gt; i32 = new_i32;
<span class="boring">}</span></code></pre></pre>
<p>다음과 동일합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern "C" fn new_i32() -&gt; i32 { 0 }
let fptr: extern "C" fn() -&gt; i32 = new_i32;
<span class="boring">}</span></code></pre></pre>
<p>r[items.fn.extern.unwind]</p>
<h3 id="unwinding"><a class="header" href="#unwinding">Unwinding</a></h3>
<p>r[items.fn.extern.unwind.intro] Most ABI strings come in two variants, one with an <code>-unwind</code> suffix and one without. The <code>Rust</code> ABI always permits unwinding, so there is no <code>Rust-unwind</code> ABI. The choice of ABI, together with the runtime <a href="items/../panic.html#the-panic_handler-attribute">panic handler</a>, determines the behavior when unwinding out of a function.</p>
<p>r[items.fn.extern.unwind.behavior] The table below indicates the behavior of an unwinding operation reaching each type of ABI boundary (function declaration or definition using the corresponding ABI string). Note that the Rust runtime is not affected by, and cannot have an effect on, any unwinding that occurs entirely within another language’s runtime, that is, unwinds that are thrown and caught without reaching a Rust ABI boundary.</p>
<p>The <code>panic</code>-unwind column refers to <a href="items/../panic.html">panicking</a> via the <code>panic!</code> macro and similar standard library mechanisms, as well as to any other Rust operations that cause a panic, such as out-of-bounds array indexing or integer overflow.</p>
<p>The “unwinding” ABI category refers to <code>"Rust"</code> (the implicit ABI of Rust functions not marked <code>extern</code>), <code>"C-unwind"</code>, and any other ABI with <code>-unwind</code> in its name. The “non-unwinding” ABI category refers to all other ABI strings, including <code>"C"</code> and <code>"stdcall"</code>.</p>
<p>Native unwinding is defined per-target. On targets that support throwing and catching C++ exceptions, it refers to the mechanism used to implement this feature. Some platforms implement a form of unwinding referred to as <a href="https://rust-lang.github.io/rfcs/2945-c-unwind-abi.html#forced-unwinding">“forced unwinding”</a>; <code>longjmp</code> on Windows and <code>pthread_exit</code> in <code>glibc</code> are implemented this way. Forced unwinding is explicitly excluded from the “Native unwind” column in the table.</p>
<div class="table-wrapper"><table><thead><tr><th>panic runtime</th><th>ABI</th><th><code>panic</code>-unwind</th><th>Native unwind (unforced)</th></tr></thead><tbody>
<tr><td><code>panic=unwind</code></td><td>unwinding</td><td>unwind</td><td>unwind</td></tr>
<tr><td><code>panic=unwind</code></td><td>non-unwinding</td><td>abort (see notes below)</td><td><a href="items/../behavior-considered-undefined.html">undefined behavior</a></td></tr>
<tr><td><code>panic=abort</code></td><td>unwinding</td><td><code>panic</code> aborts without unwinding</td><td>abort</td></tr>
<tr><td><code>panic=abort</code></td><td>non-unwinding</td><td><code>panic</code> aborts without unwinding</td><td><a href="items/../behavior-considered-undefined.html">undefined behavior</a></td></tr>
</tbody></table>
</div>
<p>r[items.fn.extern.abort] With <code>panic=unwind</code>, when a <code>panic</code> is turned into an abort by a non-unwinding ABI boundary, either no destructors (<code>Drop</code> calls) will run, or all destructors up until the ABI boundary will run. It is unspecified which of those two behaviors will happen.</p>
<p>For other considerations and limitations regarding unwinding across FFI boundaries, see the <a href="items/../panic.html#unwinding-across-ffi-boundaries">relevant section in the Panic documentation</a>.</p>
<p>r[items.fn.const]</p>
<h2 id="const-함수"><a class="header" href="#const-함수">const 함수</a></h2>
<p>See <a href="items/../const_eval.html#const-functions">const functions</a> for the definition of const functions.</p>
<p>r[items.fn.async]</p>
<h2 id="비동기-함수"><a class="header" href="#비동기-함수">비동기 함수</a></h2>
<p>r[items.fn.async.intro] Functions may be qualified as async, and this can also be combined with the <code>unsafe</code> qualifier:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn regular_example() { }
async unsafe fn unsafe_example() { }
<span class="boring">}</span></code></pre></pre>
<p>r[items.fn.async.future] Async functions do no work when called: instead, they capture their arguments into a future. When polled, that future will execute the function’s body.</p>
<p>r[items.fn.async.desugar-brief] An async function is roughly equivalent to a function that returns <a href="items/../types/impl-trait.html"><code>impl Future</code></a> and with an <a href="items/../expressions/block-expr.html#async-blocks"><code>async move</code> block</a> as its body:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 소스
async fn example(x: &amp;str) -&gt; usize {
    x.len()
}
<span class="boring">}</span></code></pre></pre>
<p>다음과 거의 동일합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::future::Future;
</span>// 디슈거링(Desugared)
fn example&lt;'a&gt;(x: &amp;'a str) -&gt; impl Future&lt;Output = usize&gt; + 'a {
    async move { x.len() }
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.fn.async.desugar] The actual desugaring is more complex:</p>
<p>r[items.fn.async.lifetime-capture]</p>
<ul>
<li>디슈거링에서의 반환 타입은 <code>async fn</code> 선언의 모든 라이프타임 매개변수를 캡처한다고 가정합니다. 이는 위의 디슈거링 예시에서 <code>'a</code>보다 명시적으로 오래 살며, 따라서 이를 캡처하는 것에서 확인할 수 있습니다.</li>
</ul>
<p>r[items.fn.async.param-capture]</p>
<ul>
<li>본문의 <a href="items/../expressions/block-expr.html#async-blocks"><code>async move</code> 블록</a>은 사용되지 않거나 <code>_</code> 패턴에 바인딩된 매개변수를 포함하여 모든 함수 매개변수를 캡처합니다. 이는 함수가 비동기가 아닐 때와 동일한 순서로 함수 매개변수가 드롭되도록 보장하지만, 드롭은 반환된 퓨처가 완전히 어웨이트(awaited)되었을 때 발생한다는 점이 다릅니다.</li>
</ul>
<p>비동기의 효과에 대한 자세한 내용은 <a href="items/../expressions/block-expr.html#async-blocks"><code>async</code> 블록</a>을 참조하십시오.</p>
<p>r[items.fn.async.edition2018]</p>
<blockquote>
<p>[!EDITION-2018] Async functions are only available beginning with Rust 2018.</p>
</blockquote>
<p>r[items.fn.async.safety]</p>
<h3 id="async와-unsafe-결합하기"><a class="header" href="#async와-unsafe-결합하기"><code>async</code>와 <code>unsafe</code> 결합하기</a></h3>
<p>r[items.fn.async.safety.intro] It is legal to declare a function that is both async and unsafe. The resulting function is unsafe to call and (like any async function) returns a future. This future is just an ordinary future and thus an <code>unsafe</code> context is not required to “await” it:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 어웨이트되었을 때 `x`를 역참조하는 퓨처를 반환합니다.
//
// 건전성 조건: 결과 퓨처가 완료될 때까지 `x`를 안전하게 역참조할 수 있어야 합니다.
async unsafe fn unsafe_example(x: *const i32) -&gt; i32 {
  *x
}

async fn safe_example() {
    // 함수를 처음 호출하려면 `unsafe` 블록이 필요합니다.
    let p = 22;
    let future = unsafe { unsafe_example(&amp;p) };

    // 하지만 여기서는 `unsafe` 블록이 필요하지 않습니다. 이는 `p`의 값을 읽을 것입니다.
    let q = future.await;
}
<span class="boring">}</span></code></pre></pre>
<p>이 동작은 <code>impl Future</code>를 반환하는 함수로의 디슈거링 결과입니다. 이 경우 디슈거링된 함수는 <code>unsafe</code> 함수이지만, 반환 값은 동일하게 유지됩니다.</p>
<p>Unsafe는 다른 함수에서 사용되는 것과 정확히 동일한 방식으로 비동기 함수에서 사용됩니다. 이는 함수가 건전성을 보장하기 위해 호출자에게 몇 가지 추가적인 의무를 부과함을 나타냅니다. 다른 모든 unsafe 함수와 마찬가지로, 이러한 조건은 초기 호출 자체를 넘어 확장될 수 있습니다. 예를 들어, 위의 스니펫에서 <code>unsafe_example</code> 함수는 포인터 <code>x</code>를 인자로 받았고, (어웨이트되었을 때) 해당 포인터를 역참조했습니다. 이는 퓨처가 실행을 마칠 때까지 <code>x</code>가 유효해야 함을 의미하며, 이를 보장하는 것은 호출자의 책임입니다.</p>
<p>r[items.fn.attributes]</p>
<h2 id="함수의-속성"><a class="header" href="#함수의-속성">함수의 속성</a></h2>
<p>r[items.fn.attributes.intro] <a href="items/../attributes.html">Outer attributes</a> are allowed on functions. <a href="items/../attributes.html">Inner attributes</a> are allowed directly after the <code>{</code> inside its body <a href="items/../expressions/block-expr.html">block</a>.</p>
<p>이 예시는 함수의 내부 속성을 보여줍니다. 이 함수는 단지 “Example“이라는 단어로 문서화됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn documented() {
    #![doc = "예시"]
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] Except for lints, it is idiomatic to only use outer attributes on function items.</p>
</blockquote>
<p>r[items.fn.attributes.builtin-attributes] The attributes that have meaning on a function are:</p>
<ul>
<li><a href="items/../conditional-compilation.html#the-cfg_attr-attribute"><code>cfg_attr</code></a></li>
<li><a href="items/../conditional-compilation.html#the-cfg-attribute"><code>cfg</code></a></li>
<li><a href="items/../attributes/codegen.html#the-cold-attribute"><code>cold</code></a></li>
<li><a href="items/../attributes/diagnostics.html#the-deprecated-attribute"><code>deprecated</code></a></li>
<li><a href="items/../../rustdoc/the-doc-attribute.html"><code>doc</code></a></li>
<li><a href="items/../abi.html#the-export_name-attribute"><code>export_name</code></a></li>
<li><a href="items/../attributes/codegen.html#the-inline-attribute"><code>inline</code></a></li>
<li><a href="items/../abi.html#the-link_section-attribute"><code>link_section</code></a></li>
<li><a href="items/../attributes/diagnostics.html#the-must_use-attribute"><code>must_use</code></a></li>
<li><a href="items/../abi.html#the-no_mangle-attribute"><code>no_mangle</code></a></li>
<li><a href="items/../attributes/diagnostics.html#lint-check-attributes">Lint check attributes</a></li>
<li><a href="items/macro.proc.attribute">Procedural macro attributes</a></li>
<li><a href="items/../attributes/testing.html">Testing attributes</a></li>
</ul>
<p>r[items.fn.param-attributes]</p>
<h2 id="함수-매개변수의-속성"><a class="header" href="#함수-매개변수의-속성">함수 매개변수의 속성</a></h2>
<p>r[items.fn.param-attributes.intro] <a href="items/../attributes.html">Outer attributes</a> are allowed on function parameters and the permitted <a href="items/../attributes.html#built-in-attributes-index">built-in attributes</a> are restricted to <code>cfg</code>, <code>cfg_attr</code>, <code>allow</code>, <code>warn</code>, <code>deny</code>, and <code>forbid</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn len(
    #[cfg(windows)] slice: &amp;[u16],
    #[cfg(not(windows))] slice: &amp;[u8],
) -&gt; usize {
    slice.len()
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.fn.param-attributes.parsed-attributes] Inert helper attributes used by procedural macro attributes applied to items are also allowed but be careful to not include these inert attributes in your final <code>TokenStream</code>.</p>
<p>예를 들어, 다음 코드는 어디에도 공식적으로 정의되지 않은 비활성 <code>some_inert_attribute</code> 속성을 정의하고, <code>some_proc_macro_attribute</code> 절차적 매크로가 그 존재를 감지하여 출력 토큰 스트림에서 제거하는 역할을 담당합니다.</p>
<!-- ignore: requires proc macro -->
<pre><code class="language-rust ignore">#[some_proc_macro_attribute]
fn foo_oof(#[some_inert_attribute] arg: u8) {
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>r[items.type]</p>
<h1 id="타입-별칭"><a class="header" href="#타입-별칭">타입 별칭</a></h1>
<p>r[items.type.syntax]</p>
<pre><code class="language-grammar items">TypeAlias -&gt;
    `type` IDENTIFIER GenericParams? ( `:` TypeParamBounds )?
        WhereClause?
        ( `=` Type WhereClause?)? `;`
</code></pre>
<p>r[items.type.intro] A <em>type alias</em> defines a new name for an existing <a href="items/../types.html">type</a> in the <a href="items/../names/namespaces.html">type namespace</a> of the module or block where it is located. Type aliases are declared with the keyword <code>type</code>. Every value has a single, specific type, but may implement several different traits, and may be compatible with several different type constraints.</p>
<p>예를 들어, 다음은 <code>Point</code> 타입을 <code>(u8, u8)</code>(부호 없는 8비트 정수 쌍의 타입)의 동의어로 정의합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Point = (u8, u8);
let p: Point = (41, 68);
<span class="boring">}</span></code></pre></pre>
<p>r[items.type.constructor-alias] A type alias to a tuple-struct or unit-struct cannot be used to qualify that type’s constructor:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyStruct(u32);

use MyStruct as UseAlias;
type TypeAlias = MyStruct;

let _ = UseAlias(5); // OK
let _ = TypeAlias(5); // 작동하지 않음
<span class="boring">}</span></code></pre></pre>
<p>r[items.type.associated-type] A type alias, when not used as an <a href="items/associated-items.html#associated-types">associated type</a>, must include a [Type][grammar-Type] and may not include [TypeParamBounds].</p>
<p>r[items.type.associated-trait] A type alias, when used as an <a href="items/associated-items.html#associated-types">associated type</a> in a <a href="items/traits.html">trait</a>, must not include a [Type][grammar-Type] specification but may include [TypeParamBounds].</p>
<p>r[items.type.associated-impl] A type alias, when used as an <a href="items/associated-items.html#associated-types">associated type</a> in a <a href="items/implementations.html#trait-implementations">trait impl</a>, must include a [Type][grammar-Type] specification and may not include [TypeParamBounds].</p>
<p>r[items.type.deprecated] Where clauses before the equals sign on a type alias in a <a href="items/implementations.html#trait-implementations">trait impl</a> (like <code>type TypeAlias&lt;T&gt; where T: Foo = Bar&lt;T&gt;</code>) are deprecated. Where clauses after the equals sign (like <code>type TypeAlias&lt;T&gt; = Bar&lt;T&gt; where T: Foo</code>) are preferred.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[items.struct]</p>
<h1 id="구조체"><a class="header" href="#구조체">구조체</a></h1>
<p>r[items.struct.syntax]</p>
<pre><code class="language-grammar items">Struct -&gt;
      StructStruct
    | TupleStruct

StructStruct -&gt;
    `struct` IDENTIFIER GenericParams? WhereClause? ( `{` StructFields? `}` | `;` )

TupleStruct -&gt;
    `struct` IDENTIFIER GenericParams? `(` TupleFields? `)` WhereClause? `;`

StructFields -&gt; StructField (`,` StructField)* `,`?

StructField -&gt; OuterAttribute* Visibility? IDENTIFIER `:` Type

TupleFields -&gt; TupleField (`,` TupleField)* `,`?

TupleField -&gt; OuterAttribute* Visibility? Type
</code></pre>
<p>r[items.struct.intro] A <em>struct</em> is a nominal <a href="items/../types/struct.html">struct type</a> defined with the keyword <code>struct</code>.</p>
<p>r[items.struct.namespace] A struct declaration defines the given name in the <a href="items/../names/namespaces.html">type namespace</a> of the module or block where it is located.</p>
<p><code>struct</code> 아이템과 그 사용 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {x: i32, y: i32}
let p = Point {x: 10, y: 11};
let px: i32 = p.x;
<span class="boring">}</span></code></pre></pre>
<p>r[items.struct.tuple] A <em>tuple struct</em> is a nominal <a href="items/../types/tuple.html">tuple type</a>, and is also defined with the keyword <code>struct</code>. In addition to defining a type, it also defines a constructor of the same name in the <a href="items/../names/namespaces.html">value namespace</a>. The constructor is a function which can be called to create a new instance of the struct. For example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point(i32, i32);
let p = Point(10, 11);
let px: i32 = match p { Point(x, _) =&gt; x };
<span class="boring">}</span></code></pre></pre>
<p>r[items.struct.unit] A <em>unit-like struct</em> is a struct without any fields, defined by leaving off the list of fields entirely. Such a struct implicitly defines a <a href="items/constant-items.html">constant</a> of its type with the same name. For example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Cookie;
let c = [Cookie, Cookie {}, Cookie, Cookie {}];
<span class="boring">}</span></code></pre></pre>
<p>다음과 동일합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Cookie {}
const Cookie: Cookie = Cookie {};
let c = [Cookie, Cookie {}, Cookie, Cookie {}];
<span class="boring">}</span></code></pre></pre>
<p>r[items.struct.layout] The precise memory layout of a struct is not specified. One can specify a particular layout using the <a href="items/../type-layout.html#representations"><code>repr</code> attribute</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[items.enum]</p>
<h1 id="열거형"><a class="header" href="#열거형">열거형</a></h1>
<p>r[items.enum.syntax]</p>
<pre><code class="language-grammar items">Enumeration -&gt;
    `enum` IDENTIFIER GenericParams? WhereClause? `{` EnumVariants? `}`

EnumVariants -&gt; EnumVariant ( `,` EnumVariant )* `,`?

EnumVariant -&gt;
    OuterAttribute* Visibility?
    IDENTIFIER ( EnumVariantTuple | EnumVariantStruct )? EnumVariantDiscriminant?

EnumVariantTuple -&gt; `(` TupleFields? `)`

EnumVariantStruct -&gt; `{` StructFields? `}`

EnumVariantDiscriminant -&gt; `=` Expression
</code></pre>
<p>r[items.enum.intro] An <em>enumeration</em>, also referred to as an <em>enum</em>, is a simultaneous definition of a nominal <a href="items/../types/enum.html">enumerated type</a> as well as a set of <em>constructors</em>, that can be used to create or pattern-match values of the corresponding enumerated type.</p>
<p>r[items.enum.decl] Enumerations are declared with the keyword <code>enum</code>.</p>
<p>r[items.enum.namespace] The <code>enum</code> declaration defines the enumeration type in the <a href="items/../names/namespaces.html">type namespace</a> of the module or block where it is located.</p>
<p><code>enum</code> 아이템과 그 사용 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Animal {
    Dog,
    Cat,
}

let mut a: Animal = Animal::Dog;
a = Animal::Cat;
<span class="boring">}</span></code></pre></pre>
<p>r[items.enum.constructor] Enum constructors can have either named or unnamed fields:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Animal {
    Dog(String, f64),
    Cat { name: String, weight: f64 },
}

let mut a: Animal = Animal::Dog("Cocoa".to_string(), 37.2);
a = Animal::Cat { name: "Spotty".to_string(), weight: 2.7 };
<span class="boring">}</span></code></pre></pre>
<p>이 예제에서 <code>Cat</code>은 _구조체형 열거형 변형(struct-like enum variant)_인 반면, <code>Dog</code>는 단순히 열거형 변형이라고 부릅니다.</p>
<p>r[items.enum.fieldless] An enum where no constructors contain fields is called a <em><span id="field-less-enum">field-less enum</span></em>. For example, this is a fieldless enum:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Fieldless {
    Tuple(),
    Struct{},
    Unit,
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.enum.unit-only] If a field-less enum only contains unit variants, the enum is called an <em><span id="unit-only-enum">unit-only enum</span></em>. For example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Enum {
    Foo = 3,
    Bar = 2,
    Baz = 1,
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.enum.constructor-names] Variant constructors are similar to <a href="items/structs.html">struct</a> definitions, and can be referenced by a path from the enumeration name, including in <a href="items/use-declarations.html">use declarations</a>.</p>
<p>r[items.enum.constructor-namespace] Each variant defines its type in the <a href="items/../names/namespaces.html">type namespace</a>, though that type cannot be used as a type specifier. Tuple-like and unit-like variants also define a constructor in the <a href="items/../names/namespaces.html">value namespace</a>.</p>
<p>r[items.enum.struct-expr] A struct-like variant can be instantiated with a <a href="items/../expressions/struct-expr.html">struct expression</a>.</p>
<p>r[items.enum.tuple-expr] A tuple-like variant can be instantiated with a <a href="items/../expressions/call-expr.html">call expression</a> or a <a href="items/../expressions/struct-expr.html">struct expression</a>.</p>
<p>r[items.enum.path-expr] A unit-like variant can be instantiated with a <a href="items/../expressions/path-expr.html">path expression</a> or a <a href="items/../expressions/struct-expr.html">struct expression</a>. For example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Examples {
    UnitLike,
    TupleLike(i32),
    StructLike { value: i32 },
}

use Examples::*; // 모든 변형에 대한 별칭을 생성합니다.
let x = UnitLike; // 상수 아이템의 경로 표현식.
let x = UnitLike {}; // 구조체 표현식.
let y = TupleLike(123); // 호출 표현식.
let y = TupleLike { 0: 123 }; // 정수 필드 이름을 사용하는 구조체 표현식.
let z = StructLike { value: 123 }; // 구조체 표현식.
<span class="boring">}</span></code></pre></pre>
<p><span id="custom-discriminant-values-for-fieldless-enumerations"></span> r[items.enum.discriminant]</p>
<h2 id="판별자"><a class="header" href="#판별자">판별자</a></h2>
<p>r[items.enum.discriminant.intro] Each enum instance has a <em>discriminant</em>: an integer logically associated to it that is used to determine which variant it holds.</p>
<p>r[items.enum.discriminant.repr-rust] Under the <a href="items/../type-layout.html#the-rust-representation"><code>Rust</code> representation</a>, the discriminant is interpreted as an <code>isize</code> value. However, the compiler is allowed to use a smaller type (or another means of distinguishing variants) in its actual memory layout.</p>
<h3 id="판별자-값-할당"><a class="header" href="#판별자-값-할당">판별자 값 할당</a></h3>
<p>r[items.enum.discriminant.explicit]</p>
<h4 id="명시적-판별자"><a class="header" href="#명시적-판별자">명시적 판별자</a></h4>
<p>r[items.enum.discriminant.explicit.intro] In two circumstances, the discriminant of a variant may be explicitly set by following the variant name with <code>=</code> and a <a href="items/../const_eval.html#constant-expressions">constant expression</a>:</p>
<p>r[items.enum.discriminant.explicit.unit-only]</p>
<ol>
<li>열거형이 “<a href="items/enumerations.html#unit-only-enum">유닛 전용</a>“인 경우.</li>
</ol>
<p>r[items.enum.discriminant.explicit.primitive-repr] 2. if a <a href="items/../type-layout.html#primitive-representations">primitive representation</a> is used. For example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(u8)]
enum Enum {
    Unit = 3,
    Tuple(u16),
    Struct {
        a: u8,
        b: u16,
    } = 1,
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.enum.discriminant.implicit]</p>
<h4 id="암시적-판별자"><a class="header" href="#암시적-판별자">암시적 판별자</a></h4>
<p>변형에 대한 판별자가 지정되지 않으면, 선언 내 이전 변형의 판별자보다 1 큰 값으로 설정됩니다. 선언의 첫 번째 변형의 판별자가 지정되지 않으면, 0으로 설정됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Foo {
    Bar,            // 0
    Baz = 123,      // 123
    Quux,           // 124
}

let baz_discriminant = Foo::Baz as u32;
assert_eq!(baz_discriminant, 123);
<span class="boring">}</span></code></pre></pre>
<p>r[items.enum.discriminant.restrictions]</p>
<h4 id="제약-사항-1"><a class="header" href="#제약-사항-1">제약 사항</a></h4>
<p>r[items.enum.discriminant.restrictions.same-discriminant] It is an error when two variants share the same discriminant.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum SharedDiscriminantError {
    SharedA = 1,
    SharedB = 1
}

enum SharedDiscriminantError2 {
    Zero,       // 0
    One,        // 1
    OneToo = 1  // 1 (이전과 충돌!)
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.enum.discriminant.restrictions.above-max-discriminant] It is also an error to have an unspecified discriminant where the previous discriminant is the maximum value for the size of the discriminant.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(u8)]
enum OverflowingDiscriminantError {
    Max = 255,
    MaxPlusOne // 256이어야 하지만, 열거형을 오버플로합니다.
}

#[repr(u8)]
enum OverflowingDiscriminantError2 {
    MaxMinusOne = 254, // 254
    Max,               // 255
    MaxPlusOne         // 256이어야 하지만, 열거형을 오버플로합니다.
}
<span class="boring">}</span></code></pre></pre>
<h3 id="판별자-접근"><a class="header" href="#판별자-접근">판별자 접근</a></h3>
<h4 id="memdiscriminant를-통해"><a class="header" href="#memdiscriminant를-통해"><code>mem::discriminant</code>를 통해</a></h4>
<p>r[items.enum.discriminant.access-opaque]</p>
<p>[<code>std::mem::discriminant</code>] returns an opaque reference to the discriminant of an enum value which can be compared. This cannot be used to get the value of the discriminant.</p>
<p>r[items.enum.discriminant.coercion]</p>
<h4 id="캐스팅"><a class="header" href="#캐스팅">캐스팅</a></h4>
<p>r[items.enum.discriminant.coercion.intro] If an enumeration is <a href="items/enumerations.html#unit-only-enum">unit-only</a> (with no tuple and struct variants), then its discriminant can be directly accessed with a <a href="items/../expressions/operator-expr.html#semantics">numeric cast</a>; e.g.:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Enum {
    Foo,
    Bar,
    Baz,
}

assert_eq!(0, Enum::Foo as isize);
assert_eq!(1, Enum::Bar as isize);
assert_eq!(2, Enum::Baz as isize);
<span class="boring">}</span></code></pre></pre>
<p>r[items.enum.discriminant.coercion.fieldless] <a href="items/enumerations.html#field-less-enum">Field-less enums</a> can be cast if they do not have explicit discriminants, or where only unit variants are explicit.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Fieldless {
    Tuple(),
    Struct{},
    Unit,
}

assert_eq!(0, Fieldless::Tuple() as isize);
assert_eq!(1, Fieldless::Struct{} as isize);
assert_eq!(2, Fieldless::Unit as isize);

#[repr(u8)]
enum FieldlessWithDiscriminants {
    First = 10,
    Tuple(),
    Second = 20,
    Struct{},
    Unit,
}

assert_eq!(10, FieldlessWithDiscriminants::First as u8);
assert_eq!(11, FieldlessWithDiscriminants::Tuple() as u8);
assert_eq!(20, FieldlessWithDiscriminants::Second as u8);
assert_eq!(21, FieldlessWithDiscriminants::Struct{} as u8);
assert_eq!(22, FieldlessWithDiscriminants::Unit as u8);
<span class="boring">}</span></code></pre></pre>
<h4 id="포인터-캐스팅"><a class="header" href="#포인터-캐스팅">포인터 캐스팅</a></h4>
<p>r[items.enum.discriminant.access-memory]</p>
<p>열거형이 <a href="items/../type-layout.html#primitive-representations">원시 표현</a>을 지정하는 경우, <code>unsafe</code> 포인터 캐스팅을 통해 판별자에 안정적으로 접근할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(u8)]
enum Enum {
    Unit,
    Tuple(bool),
    Struct{a: bool},
}

impl Enum {
    fn discriminant(&amp;self) -&gt; u8 {
        unsafe { *(self as *const Self as *const u8) }
    }
}

let unit_like = Enum::Unit;
let tuple_like = Enum::Tuple(true);
let struct_like = Enum::Struct{a: false};

assert_eq!(0, unit_like.discriminant());
assert_eq!(1, tuple_like.discriminant());
assert_eq!(2, struct_like.discriminant());
<span class="boring">}</span></code></pre></pre>
<p>r[items.enum.empty]</p>
<h2 id="0-변형-열거형"><a class="header" href="#0-변형-열거형">0-변형 열거형</a></h2>
<p>r[items.enum.empty.intro] Enums with zero variants are known as <em>zero-variant enums</em>. As they have no valid values, they cannot be instantiated.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum ZeroVariants {}
<span class="boring">}</span></code></pre></pre>
<p>r[items.enum.empty.uninhabited] Zero-variant enums are equivalent to the <a href="items/../types/never.html">never type</a>, but they cannot be coerced into other types.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">enum ZeroVariants {}
</span>let x: ZeroVariants = panic!();
let y: u32 = x; // 타입 불일치 오류
<span class="boring">}</span></code></pre></pre>
<p>r[items.enum.variant-visibility]</p>
<h2 id="변형-가시성"><a class="header" href="#변형-가시성">변형 가시성</a></h2>
<p>Enum variants syntactically allow a [Visibility] annotation, but this is rejected when the enum is validated. This allows items to be parsed with a unified syntax across different contexts where they are used.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! mac_variant {
    ($vis:vis $name:ident) =&gt; {
        enum $name {
            $vis Unit,

            $vis Tuple(u8, u16),

            $vis Struct { f: u8 },
        }
    }
}

// 빈 `vis`는 허용됩니다.
mac_variant! { E }

// 검증되기 전에 제거되므로 허용됩니다.
#[cfg(false)]
enum E {
    pub U,
    pub(crate) T(u8),
    pub(super) T { f: String }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p>r[items.union]</p>
<h1 id="공용체"><a class="header" href="#공용체">공용체</a></h1>
<p>r[items.union.syntax]</p>
<pre><code class="language-grammar items">Union -&gt;
    `union` IDENTIFIER GenericParams? WhereClause? `{` StructFields? `}`
</code></pre>
<p>r[items.union.intro] A union declaration uses the same syntax as a struct declaration, except with <code>union</code> in place of <code>struct</code>.</p>
<p>r[items.union.namespace] A union declaration defines the given name in the <a href="items/../names/namespaces.html">type namespace</a> of the module or block where it is located.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
union MyUnion {
    f1: u32,
    f2: f32,
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.union.common-storage] The key property of unions is that all fields of a union share common storage. As a result, writes to one field of a union can overwrite its other fields, and size of a union is determined by the size of its largest field.</p>
<p>r[items.union.field-restrictions] Union field types are restricted to the following subset of types:</p>
<p>r[items.union.field-copy]</p>
<ul>
<li><code>Copy</code> 타입</li>
</ul>
<p>r[items.union.field-references]</p>
<ul>
<li>참조(임의의 <code>T</code>에 대한 <code>&amp;T</code> 및 <code>&amp;mut T</code>)</li>
</ul>
<p>r[items.union.field-manually-drop]</p>
<ul>
<li><code>ManuallyDrop&lt;T&gt;</code> (임의의 <code>T</code>에 대해)</li>
</ul>
<p>r[items.union.field-tuple]</p>
<ul>
<li>허용된 공용체 필드 타입만 포함하는 튜플 및 배열</li>
</ul>
<p>r[items.union.drop] This restriction ensures, in particular, that union fields never need to be dropped. Like for structs and enums, it is possible to <code>impl Drop</code> for a union to manually define what happens when it gets dropped.</p>
<p>r[items.union.fieldless] Unions without any fields are not accepted by the compiler, but can be accepted by macros.</p>
<p>r[items.union.init]</p>
<h2 id="공용체-초기화"><a class="header" href="#공용체-초기화">공용체 초기화</a></h2>
<p>r[items.union.init.intro] A value of a union type can be created using the same syntax that is used for struct types, except that it must specify exactly one field:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">union MyUnion { f1: u32, f2: f32 }
</span><span class="boring">
</span>let u = MyUnion { f1: 1 };
<span class="boring">}</span></code></pre></pre>
<p>r[items.union.init.result] The expression above creates a value of type <code>MyUnion</code> and initializes the storage using field <code>f1</code>. The union can be accessed using the same syntax as struct fields:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">union MyUnion { f1: u32, f2: f32 }
</span><span class="boring">
</span><span class="boring">let u = MyUnion { f1: 1 };
</span>let f = unsafe { u.f1 };
<span class="boring">}</span></code></pre></pre>
<p>r[items.union.fields]</p>
<h2 id="공용체-필드-읽기-및-쓰기"><a class="header" href="#공용체-필드-읽기-및-쓰기">공용체 필드 읽기 및 쓰기</a></h2>
<p>r[items.union.fields.intro] Unions have no notion of an “active field”. Instead, every union access just interprets the storage as the type of the field used for the access.</p>
<p>r[items.union.fields.read] Reading a union field reads the bits of the union at the field’s type.</p>
<p>r[items.union.fields.offset] Fields might have a non-zero offset (except when <a href="items/../type-layout.html#reprc-unions">the C representation</a> is used); in that case the bits starting at the offset of the fields are read</p>
<p>r[items.union.fields.validity] It is the programmer’s responsibility to make sure that the data is valid at the field’s type. Failing to do so results in <a href="items/../behavior-considered-undefined.html">undefined behavior</a>. For example, reading the value <code>3</code> from a field of the <a href="items/../types/boolean.html">boolean type</a> is undefined behavior. Effectively, writing to and then reading from a union with <a href="items/../type-layout.html#reprc-unions">the C representation</a> is analogous to a <a href="std::mem::transmute"><code>transmute</code></a> from the type used for writing to the type used for reading.</p>
<p>r[items.union.fields.read-safety] Consequently, all reads of union fields have to be placed in <code>unsafe</code> blocks:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">union MyUnion { f1: u32, f2: f32 }
</span><span class="boring">let u = MyUnion { f1: 1 };
</span><span class="boring">
</span>unsafe {
    let f = u.f1;
}
<span class="boring">}</span></code></pre></pre>
<p>일반적으로 공용체를 사용하는 코드는 안전하지 않은 공용체 필드 접근에 대한 안전한 래퍼를 제공합니다.</p>
<p>r[items.union.fields.write-safety] In contrast, writes to union fields are safe, since they just overwrite arbitrary data, but cannot cause undefined behavior. (Note that union field types can never have drop glue, so a union field write will never implicitly drop anything.)</p>
<p>r[items.union.pattern]</p>
<h2 id="공용체-패턴-매칭"><a class="header" href="#공용체-패턴-매칭">공용체 패턴 매칭</a></h2>
<p>r[items.union.pattern.intro] Another way to access union fields is to use pattern matching.</p>
<p>r[items.union.pattern.one-field] Pattern matching on union fields uses the same syntax as struct patterns, except that the pattern must specify exactly one field.</p>
<p>r[items.union.pattern.safety] Since pattern matching is like reading the union with a particular field, it has to be placed in <code>unsafe</code> blocks as well.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">union MyUnion { f1: u32, f2: f32 }
</span><span class="boring">
</span>fn f(u: MyUnion) {
    unsafe {
        match u {
            MyUnion { f1: 10 } =&gt; { println!("ten"); }
            MyUnion { f2 } =&gt; { println!("{}", f2); }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.union.pattern.subpattern] Pattern matching may match a union as a field of a larger structure. In particular, when using a Rust union to implement a C tagged union via FFI, this allows matching on the tag and the corresponding field simultaneously:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(u32)]
enum Tag { I, F }

#[repr(C)]
union U {
    i: i32,
    f: f32,
}

#[repr(C)]
struct Value {
    tag: Tag,
    u: U,
}

fn is_zero(v: Value) -&gt; bool {
    unsafe {
        match v {
            Value { tag: Tag::I, u: U { i: 0 } } =&gt; true,
            Value { tag: Tag::F, u: U { f: num } } if num == 0.0 =&gt; true,
            _ =&gt; false,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.union.ref]</p>
<h2 id="공용체-필드에-대한-참조"><a class="header" href="#공용체-필드에-대한-참조">공용체 필드에 대한 참조</a></h2>
<p>r[items.union.ref.intro] Since union fields share common storage, gaining write access to one field of a union can give write access to all its remaining fields.</p>
<p>r[items.union.ref.borrow] Borrow checking rules have to be adjusted to account for this fact. As a result, if one field of a union is borrowed, all its remaining fields are borrowed as well for the same lifetime.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">union MyUnion { f1: u32, f2: f32 }
</span>// 오류: `u`를 (`u.f2`를 통해) 한 번에 두 번 이상 가변으로 대여할 수 없습니다
fn test() {
    let mut u = MyUnion { f1: 1 };
    unsafe {
        let b1 = &amp;mut u.f1;
//                    ---- 첫 번째 가변 대여가 여기서 발생합니다 (`u.f1`을 통해)
        let b2 = &amp;mut u.f2;
//                    ^^^^ 두 번째 가변 대여가 여기서 발생합니다 (`u.f2`를 통해)
        *b1 = 5;
    }
//  - 첫 번째 대여가 여기서 끝납니다
    assert_eq!(unsafe { u.f1 }, 5);
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.union.ref.usage] As you could see, in many aspects (except for layouts, safety, and ownership) unions behave exactly like structs, largely as a consequence of inheriting their syntactic shape from structs. This is also true for many unmentioned aspects of Rust language (such as privacy, name resolution, type inference, generics, trait implementations, inherent implementations, coherence, pattern checking, etc etc etc).</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[items.const]</p>
<h1 id="상수-아이템"><a class="header" href="#상수-아이템">상수 아이템</a></h1>
<p>r[items.const.syntax]</p>
<pre><code class="language-grammar items">ConstantItem -&gt;
    `const` ( IDENTIFIER | `_` ) `:` Type ( `=` Expression )? `;`
</code></pre>
<p>r[items.const.intro] A <em>constant item</em> is an optionally named <em><a href="items/../const_eval.html#constant-expressions">constant value</a></em> which is not associated with a specific memory location in the program.</p>
<p>r[items.const.behavior] Constants are essentially inlined wherever they are used, meaning that they are copied directly into the relevant context when used. This includes usage of constants from external crates, and non-<a href="items/../special-types-and-traits.html#copy"><code>Copy</code></a> types. References to the same constant are not necessarily guaranteed to refer to the same memory address.</p>
<p>r[items.const.namespace] The constant declaration defines the constant value in the <a href="items/../names/namespaces.html">value namespace</a> of the module or block where it is located.</p>
<p>r[items.const.static] Constants must be explicitly typed. The type must have a <code>'static</code> lifetime: any references in the initializer must have <code>'static</code> lifetimes. References in the type of a constant default to <code>'static</code> lifetime; see <a href="items/../lifetime-elision.html#const-and-static-elision">static lifetime elision</a>.</p>
<p>r[items.const.static-temporary] A reference to a constant will have <code>'static</code> lifetime if the constant value is eligible for <a href="items/destructors.scope.const-promotion">promotion</a>; otherwise, a temporary will be created.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const BIT1: u32 = 1 &lt;&lt; 0;
const BIT2: u32 = 1 &lt;&lt; 1;

const BITS: [u32; 2] = [BIT1, BIT2];
const STRING: &amp;'static str = "bitstring";

struct BitsNStrings&lt;'a&gt; {
    mybits: [u32; 2],
    mystring: &amp;'a str,
}

const BITS_N_STRINGS: BitsNStrings&lt;'static&gt; = BitsNStrings {
    mybits: BITS,
    mystring: STRING,
};
<span class="boring">}</span></code></pre></pre>
<p>r[items.const.expr-omission] The constant expression may only be omitted in a <a href="items/traits.html">trait definition</a>.</p>
<p>r[items.const.destructor]</p>
<h2 id="constants-with-destructors"><a class="header" href="#constants-with-destructors">Constants with destructors</a></h2>
<p>상수는 소멸자를 포함할 수 있습니다. 소멸자는 값이 스코프를 벗어날 때 실행됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TypeWithDestructor(i32);

impl Drop for TypeWithDestructor {
    fn drop(&amp;mut self) {
        println!("Dropped. Held {}.", self.0);
    }
}

const ZERO_WITH_DESTRUCTOR: TypeWithDestructor = TypeWithDestructor(0);

fn create_and_drop_zero_with_destructor() {
    let x = ZERO_WITH_DESTRUCTOR;
    // x는 함수가 끝날 때 드롭되어 drop을 호출합니다.
    // "Dropped. Held 0."을 출력합니다.
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.const.unnamed]</p>
<h2 id="이름-없는-상수"><a class="header" href="#이름-없는-상수">이름 없는 상수</a></h2>
<p>r[items.const.unnamed.intro] Unlike an <a href="items/../items/associated-items.html#associated-constants">associated constant</a>, a <a href="items/../glossary.html#free-item">free</a> constant may be unnamed by using an underscore instead of the name. For example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const _: () =  { struct _SameNameTwice; };

// 위와 같은 이름이지만 괜찮습니다:
const _: () =  { struct _SameNameTwice; };
<span class="boring">}</span></code></pre></pre>
<p>r[items.const.unnamed.repetition] As with <a href="items/use-declarations.html#underscore-imports">underscore imports</a>, macros may safely emit the same unnamed constant in the same scope more than once. For example, the following should not produce an error:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! m {
    ($item: item) =&gt; { $item $item }
}

m!(const _: () = (););
// 다음과 같이 확장됩니다:
// const _: () = ();
// const _: () = ();
<span class="boring">}</span></code></pre></pre>
<p>r[items.const.eval]</p>
<h2 id="평가"><a class="header" href="#평가">평가</a></h2>
<p><a href="items/../glossary.html#free-item">자유(Free)</a> 상수는 항상 컴파일 타임에 <a href="items/../const_eval.html">평가되어</a> 패닉을 드러냅니다. 이는 사용되지 않는 함수 내에서도 발생합니다:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 컴파일 타임 패닉
const PANIC: () = std::unimplemented!();

fn unused_generic_function&lt;T&gt;() {
    // 실패하는 컴파일 타임 어설션
    const _: () = assert!(usize::BITS == 0);
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p>r[items.static]</p>
<h1 id="정적-아이템"><a class="header" href="#정적-아이템">정적 아이템</a></h1>
<p>r[items.static.syntax]</p>
<pre><code class="language-grammar items">StaticItem -&gt;
    ItemSafety?[^extern-safety] `static` `mut`? IDENTIFIER `:` Type ( `=` Expression )? `;`
</code></pre>
<div class="footnote-definition" id="extern-safety"><sup class="footnote-definition-label">1</sup>
<p><code>safe</code> 및 <code>unsafe</code> 함수 한정자는 시맨틱적으로 <code>extern</code> 블록 내에서만 허용됩니다.</p>
</div>
<p>r[items.static.intro] A <em>static item</em> is similar to a <a href="items/constant-items.html">constant</a>, except that it represents an allocation in the program that is initialized with the initializer expression. All references and raw pointers to the static refer to the same allocation.</p>
<p>r[items.static.lifetime] Static items have the <code>static</code> lifetime, which outlives all other lifetimes in a Rust program. Static items do not call <a href="items/../destructors.html"><code>drop</code></a> at the end of the program.</p>
<p>r[items.static.storage-disjointness] If the <code>static</code> has a size of at least 1 byte, this allocation is disjoint from all other such <code>static</code> allocations as well as heap allocations and stack-allocated variables. However, the storage of immutable <code>static</code> items can overlap with allocations that do not themselves have a unique address, such as <a href="items/../destructors.html#constant-promotion">promoteds</a> and <a href="items/constant-items.html"><code>const</code> items</a>.</p>
<p>r[items.static.namespace] The static declaration defines a static value in the <a href="items/../names/namespaces.html">value namespace</a> of the module or block where it is located.</p>
<p>r[items.static.init] The static initializer is a <a href="items/../const_eval.html#constant-expressions">constant expression</a> evaluated at compile time. Static initializers may refer to and read from other statics. When reading from mutable statics, they read the initial value of that static.</p>
<p>r[items.static.read-only] Non-<code>mut</code> static items that contain a type that is not <a href="items/../interior-mutability.html">interior mutable</a> may be placed in read-only memory.</p>
<p>r[items.static.safety] All access to a static is safe, but there are a number of restrictions on statics:</p>
<p>r[items.static.sync]</p>
<ul>
<li>The type must have the <a href="std::marker::Sync"><code>Sync</code></a> trait bound to allow thread-safe access.</li>
</ul>
<p>r[items.static.init.omission] The initializer expression must be omitted in an <a href="items/external-blocks.html">external block</a>, and must be provided for free static items.</p>
<p>r[items.static.safety-qualifiers] The <code>safe</code> and <code>unsafe</code> qualifiers are semantically only allowed when used in an <a href="items/external-blocks.html">external block</a>.</p>
<p>r[items.static.generics]</p>
<h2 id="정적-아이템과-제네릭"><a class="header" href="#정적-아이템과-제네릭">정적 아이템과 제네릭</a></h2>
<p>제네릭 스코프(예: blanket 또는 기본 구현)에 정의된 정적 아이템은 정적 정의가 현재 스코프 밖으로 나와 모듈로 이동한 것처럼 정확히 하나의 정적 아이템만 정의되는 결과를 낳습니다. 모노모르포화(monomorphization)마다 하나의 아이템이 생성되는 것은 <em>아닙니다</em>.</p>
<p>이 코드는:</p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::sync::atomic::{AtomicUsize, Ordering};

trait Tr {
    fn default_impl() {
        static COUNTER: AtomicUsize = AtomicUsize::new(0);
        println!("default_impl: 카운터는 {}였습니다", COUNTER.fetch_add(1, Ordering::Relaxed));
    }

    fn blanket_impl();
}

struct Ty1 {}
struct Ty2 {}

impl&lt;T&gt; Tr for T {
    fn blanket_impl() {
        static COUNTER: AtomicUsize = AtomicUsize::new(0);
        println!("blanket_impl: 카운터는 {}였습니다", COUNTER.fetch_add(1, Ordering::Relaxed));
    }
}

fn main() {
    &lt;Ty1 as Tr&gt;::default_impl();
    &lt;Ty2 as Tr&gt;::default_impl();
    &lt;Ty1 as Tr&gt;::blanket_impl();
    &lt;Ty2 as Tr&gt;::blanket_impl();
}</code></pre></pre>
<p>다음과 같이 출력합니다:</p>
<pre><code class="language-text">default_impl: counter was 0
default_impl: counter was 1
blanket_impl: counter was 0
blanket_impl: counter was 1
</code></pre>
<p>r[items.static.mut]</p>
<h2 id="가변-정적-아이템"><a class="header" href="#가변-정적-아이템">가변 정적 아이템</a></h2>
<p>r[items.static.mut.intro] If a static item is declared with the <code>mut</code> keyword, then it is allowed to be modified by the program. One of Rust’s goals is to make concurrency bugs hard to run into, and this is obviously a very large source of race conditions or other bugs.</p>
<p>r[items.static.mut.safety] For this reason, an <code>unsafe</code> block is required when either reading or writing a mutable static variable. Care should be taken to ensure that modifications to a mutable static are safe with respect to other threads running in the same process.</p>
<p>r[items.static.mut.extern] Mutable statics are still very useful, however. They can be used with C libraries and can also be bound from C libraries in an <code>extern</code> block.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn atomic_add(_: *mut u32, _: u32) -&gt; u32 { 2 }
</span>
static mut LEVELS: u32 = 0;

// 이것은 공유 상태가 없다는 아이디어를 위반하며, 내부적으로 경쟁 상태로부터
// 보호하지 않으므로, 이 함수는 `unsafe`입니다
unsafe fn bump_levels_unsafe() -&gt; u32 {
    unsafe {
        let ret = LEVELS;
        LEVELS += 1;
        return ret;
    }
}

// `bump_levels_unsafe`의 대안으로, 이전 값을 반환하는 atomic_add 함수가
// 있다고 가정할 때 이 함수는 안전합니다. 이 함수는 다른 코드가 비원자적(non-atomic)
// 방식으로 정적 변수에 접근하지 않는 경우에만 안전합니다. 만약 그러한 접근이 가능하다면
// (`bump_levels_unsafe`에서처럼), 호출자에게 동시 접근을 여전히 막아야 함을
// 알리기 위해 `unsafe`여야 합니다.
fn bump_levels_safe() -&gt; u32 {
    unsafe {
        return atomic_add(&amp;raw mut LEVELS, 1);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.static.mut.sync] Mutable statics have the same restrictions as normal statics, except that the type does not have to implement the <code>Sync</code> trait.</p>
<p>r[items.static.alternate]</p>
<h2 id="using-statics-or-consts"><a class="header" href="#using-statics-or-consts">Using statics or consts</a></h2>
<p>상수 아이템을 사용해야 할지 정적 아이템을 사용해야 할지 혼란스러울 수 있습니다. 다음 중 하나가 참이 아니라면 일반적으로 상수가 정적 아이템보다 선호되어야 합니다:</p>
<ul>
<li>대량의 데이터를 저장하고 있다.</li>
<li>정적 아이템의 단일 주소 속성이 필요하다.</li>
<li>내부 가변성(interior mutability)이 필요하다.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>r[items.traits]</p>
<h1 id="트레잇"><a class="header" href="#트레잇">트레잇</a></h1>
<p>r[items.traits.syntax]</p>
<pre><code class="language-grammar items">Trait -&gt;
    `unsafe`? `trait` IDENTIFIER GenericParams? ( `:` TypeParamBounds? )? WhereClause?
    `{`
        InnerAttribute*
        AssociatedItem*
    `}`
</code></pre>
<p>r[items.traits.intro] A <em>trait</em> describes an abstract interface that types can implement. This interface consists of <a href="items/associated-items.html">associated items</a>, which come in three varieties:</p>
<ul>
<li><a href="items/associated-items.html#associated-functions-and-methods">함수</a></li>
<li><a href="items/associated-items.html#associated-types">타입</a></li>
<li><a href="items/associated-items.html#associated-constants">상수</a></li>
</ul>
<p>r[items.traits.namespace] The trait declaration defines a trait in the <a href="items/../names/namespaces.html">type namespace</a> of the module or block where it is located.</p>
<p>r[items.traits.associated-item-namespaces] Associated items are defined as members of the trait within their respective namespaces. Associated types are defined in the type namespace. Associated constants and associated functions are defined in the value namespace.</p>
<p>r[items.traits.self-param] All traits define an implicit type parameter <code>Self</code> that refers to “the type that is implementing this interface”. Traits may also contain additional type parameters. These type parameters, including <code>Self</code>, may be constrained by other traits and so forth <a href="items/generics.html">as usual</a>.</p>
<p>r[items.traits.impls] Traits are implemented for specific types through separate <a href="items/implementations.html">implementations</a>.</p>
<p>r[items.traits.associated-item-decls] Trait functions may omit the function body by replacing it with a semicolon. This indicates that the implementation must define the function. If the trait function defines a body, this definition acts as a default for any implementation which does not override it. Similarly, associated constants may omit the equals sign and expression to indicate implementations must define the constant value. Associated types must never define the type, the type may only be specified in an implementation.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 정의가 있거나 없는 연관 트레잇 아이템의 예시.
trait Example {
    const CONST_NO_DEFAULT: i32;
    const CONST_WITH_DEFAULT: i32 = 99;
    type TypeNoDefault;
    fn method_without_default(&amp;self);
    fn method_with_default(&amp;self) {}
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.traits.const-fn] Trait functions are not allowed to be <a href="items/functions.html#const-functions"><code>const</code></a>.</p>
<p>r[items.traits.bounds]</p>
<h2 id="트레잇-바운드"><a class="header" href="#트레잇-바운드">트레잇 바운드</a></h2>
<p>제네릭 아이템은 타입 매개변수에 대한 <a href="items/../trait-bounds.html">바운드</a>로 트레잇을 사용할 수 있습니다.</p>
<p>r[items.traits.generic]</p>
<h2 id="제네릭-트레잇"><a class="header" href="#제네릭-트레잇">제네릭 트레잇</a></h2>
<p>타입 매개변수를 지정하여 트레잇을 제네릭으로 만들 수 있습니다. 이는 <a href="items/functions.html#generic-functions">제네릭 함수</a>에서 사용되는 것과 동일한 구문을 사용하여 트레잇 이름 뒤에 나타납니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Seq&lt;T&gt; {
    fn len(&amp;self) -&gt; u32;
    fn elt_at(&amp;self, n: u32) -&gt; T;
    fn iter&lt;F&gt;(&amp;self, f: F) where F: Fn(T);
}
<span class="boring">}</span></code></pre></pre>
<p><a id="object-safety"></a> r[items.traits.dyn-compatible]</p>
<h2 id="dyn-호환성"><a class="header" href="#dyn-호환성">Dyn 호환성</a></h2>
<p>r[items.traits.dyn-compatible.intro] A dyn-compatible trait can be the base trait of a <a href="items/../types/trait-object.html">trait object</a>. A trait is <em>dyn compatible</em> if it has the following qualities:</p>
<p>r[items.traits.dyn-compatible.supertraits]</p>
<ul>
<li>모든 <a href="items/traits.html#supertraits">슈퍼트레잇</a>도 dyn 호환이어야 합니다.</li>
</ul>
<p>r[items.traits.dyn-compatible.sized]</p>
<ul>
<li><code>Sized</code>는 <a href="items/traits.html#supertraits">슈퍼트레잇</a>이 아니어야 합니다. 다시 말해, <code>Self: Sized</code>를 요구하지 않아야 합니다.</li>
</ul>
<p>r[items.traits.dyn-compatible.associated-consts]</p>
<ul>
<li>연관 상수를 갖지 않아야 합니다.</li>
</ul>
<p>r[items.traits.dyn-compatible.associated-types]</p>
<ul>
<li>제네릭을 포함한 연관 타입을 갖지 않아야 합니다.</li>
</ul>
<p>r[items.traits.dyn-compatible.associated-functions]</p>
<ul>
<li>모든 연관 함수는 트레잇 객체에서 디스패치 가능하거나(dispatchable) 명시적으로 디스패치 불가능해야 합니다:
<ul>
<li>디스패치 가능한 함수는 다음 조건을 만족해야 합니다:
<ul>
<li>타입 매개변수를 갖지 않아야 합니다(라이프타임 매개변수는 허용됨).</li>
<li>수신자(receiver)의 타입 이외에는 <code>Self</code>를 사용하지 않는 <a href="items/associated-items.html#methods">메서드</a>여야 합니다.</li>
<li>다음 중 하나의 타입을 가진 수신자를 가져야 합니다:
<ul>
<li><code>&amp;Self</code> (즉, <code>&amp;self</code>)</li>
<li><code>&amp;mut Self</code> (즉, <code>&amp;mut self</code>)</li>
<li><a href="items/../special-types-and-traits.html#boxt"><code>Box&lt;Self&gt;</code></a></li>
<li><a href="items/../special-types-and-traits.html#rct"><code>Rc&lt;Self&gt;</code></a></li>
<li><a href="items/../special-types-and-traits.html#arct"><code>Arc&lt;Self&gt;</code></a></li>
<li><a href="items/../special-types-and-traits.html#pinp"><code>Pin&lt;P&gt;</code></a> (여기서 <code>P</code>는 위의 타입 중 하나)</li>
</ul>
</li>
<li>불투명한(opaque) 반환 타입을 갖지 않아야 합니다. 즉,
<ul>
<li><code>async fn</code>이 아니어야 합니다(숨겨진 <code>Future</code> 타입을 가짐).</li>
<li>반환 위치 <code>impl Trait</code> 타입을 갖지 않아야 합니다(<code>fn example(&amp;self) -&gt; impl Trait</code>).</li>
</ul>
</li>
<li><code>where Self: Sized</code> 바운드를 갖지 않아야 합니다(<code>Self</code> 수신자 타입(즉, <code>self</code>)은 이를 암시합니다).</li>
</ul>
</li>
<li>명시적으로 디스패치 불가능한 함수는 다음을 요구합니다:
<ul>
<li><code>where Self: Sized</code> 바운드를 가져야 합니다(<code>Self</code> 수신자 타입(즉, <code>self</code>)은 이를 암시합니다).</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>r[items.traits.dyn-compatible.async-traits]</p>
<ul>
<li>The [<code>AsyncFn</code>], [<code>AsyncFnMut</code>], and [<code>AsyncFnOnce</code>] traits are not dyn-compatible.</li>
</ul>
<blockquote>
<p>[!NOTE] This concept was formerly known as <em>object safety</em>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::pin::Pin;
</span>// dyn 호환 메서드의 예시.
trait TraitMethods {
    fn by_ref(self: &amp;Self) {}
    fn by_ref_mut(self: &amp;mut Self) {}
    fn by_box(self: Box&lt;Self&gt;) {}
    fn by_rc(self: Rc&lt;Self&gt;) {}
    fn by_arc(self: Arc&lt;Self&gt;) {}
    fn by_pin(self: Pin&lt;&amp;Self&gt;) {}
    fn with_lifetime&lt;'a&gt;(self: &amp;'a Self) {}
    fn nested_pin(self: Pin&lt;Arc&lt;Self&gt;&gt;) {}
}
<span class="boring">struct S;
</span><span class="boring">impl TraitMethods for S {}
</span><span class="boring">let t: Box&lt;dyn TraitMethods&gt; = Box::new(S);
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 이 트레잇은 dyn 호환이지만, 이 메서드들은 트레잇 객체에서 디스패치될 수 없습니다.
trait NonDispatchable {
    // 비-메서드(Non-methods)는 디스패치될 수 없습니다.
    fn foo() where Self: Sized {}
    // Self 타입은 런타임까지 알 수 없습니다.
    fn returns(&amp;self) -&gt; Self where Self: Sized;
    // `other`는 수신자와 다른 구체적인 타입일 수 있습니다.
    fn param(&amp;self, other: Self) where Self: Sized {}
    // 제네릭은 vtable과 호환되지 않습니다.
    fn typed&lt;T&gt;(&amp;self, x: T) where Self: Sized {}
}

struct S;
impl NonDispatchable for S {
    fn returns(&amp;self) -&gt; Self where Self: Sized { S }
}
let obj: Box&lt;dyn NonDispatchable&gt; = Box::new(S);
obj.returns(); // 오류: Self 반환으로 호출할 수 없음
obj.param(S);  // 오류: Self 매개변수로 호출할 수 없음
obj.typed(1);  // 오류: 제네릭 타입으로 호출할 수 없음
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::rc::Rc;
</span>// dyn 호환이 아닌 트레잇의 예시.
trait DynIncompatible {
    const CONST: i32 = 1;  // 오류: 연관 상수를 가질 수 없음

    fn foo() {}  // 오류: Sized 없는 연관 함수
    fn returns(&amp;self) -&gt; Self; // 오류: 반환 타입에 `Self`가 있음
    fn typed&lt;T&gt;(&amp;self, x: T) {} // 오류: 제네릭 타입 매개변수가 있음
    fn nested(self: Rc&lt;Box&lt;Self&gt;&gt;) {} // ERROR: nested receiver cannot be dispatched on
}

struct S;
impl DynIncompatible for S {
    fn returns(&amp;self) -&gt; Self { S }
}
let obj: Box&lt;dyn DynIncompatible&gt; = Box::new(S); // 오류
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `Self: Sized` 트레잇은 dyn 호환이 아닙니다.
trait TraitWithSize where Self: Sized {}

struct S;
impl TraitWithSize for S {}
let obj: Box&lt;dyn TraitWithSize&gt; = Box::new(S); // 오류
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `Self`가 타입 인수인 경우 dyn 호환이 아닙니다.
trait Super&lt;A&gt; {}
trait WithSelf: Super&lt;Self&gt; where Self: Sized {}

struct S;
impl&lt;A&gt; Super&lt;A&gt; for S {}
impl WithSelf for S {}
let obj: Box&lt;dyn WithSelf&gt; = Box::new(S); // 오류: `Self` 타입 매개변수를 사용할 수 없음
<span class="boring">}</span></code></pre></pre>
<p>r[items.traits.supertraits]</p>
<h2 id="슈퍼트레잇"><a class="header" href="#슈퍼트레잇">슈퍼트레잇</a></h2>
<p>r[items.traits.supertraits.intro] <strong>Supertraits</strong> are traits that are required to be implemented for a type to implement a specific trait. Furthermore, anywhere a <a href="items/generics.html">generic</a> or <a href="items/../types/trait-object.html">trait object</a> is bounded by a trait, it has access to the associated items of its supertraits.</p>
<p>r[items.traits.supertraits.decl] Supertraits are declared by trait bounds on the <code>Self</code> type of a trait and transitively the supertraits of the traits declared in those trait bounds. It is an error for a trait to be its own supertrait.</p>
<p>r[items.traits.supertraits.subtrait] The trait with a supertrait is called a <strong>subtrait</strong> of its supertrait.</p>
<p>다음은 <code>Shape</code>를 <code>Circle</code>의 슈퍼트레잇으로 선언하는 예입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Shape { fn area(&amp;self) -&gt; f64; }
trait Circle: Shape { fn radius(&amp;self) -&gt; f64; }
<span class="boring">}</span></code></pre></pre>
<p>그리고 다음은 <a href="items/generics.html#where-clauses">Where 절</a>을 사용한 것을 제외하고는 동일한 예입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Shape { fn area(&amp;self) -&gt; f64; }
trait Circle where Self: Shape { fn radius(&amp;self) -&gt; f64; }
<span class="boring">}</span></code></pre></pre>
<p>다음 예제는 <code>Shape</code>의 <code>area</code> 함수를 사용하여 <code>radius</code>에 기본 구현을 제공합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Shape { fn area(&amp;self) -&gt; f64; }
</span>trait Circle where Self: Shape {
    fn radius(&amp;self) -&gt; f64 {
        // A = pi * r^2
        // 따라서 대수적으로,
        // r = sqrt(A / pi)
        (self.area() / std::f64::consts::PI).sqrt()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>다음 예제는 제네릭 매개변수에서 슈퍼트레잇 메서드를 호출합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Shape { fn area(&amp;self) -&gt; f64; }
</span><span class="boring">trait Circle: Shape { fn radius(&amp;self) -&gt; f64; }
</span>fn print_area_and_radius&lt;C: Circle&gt;(c: C) {
    // 여기서 우리는 `Circle`의 슈퍼트레잇 `Shape`의 area 메서드를 호출합니다.
    println!("면적: {}", c.area());
    println!("반지름: {}", c.radius());
}
<span class="boring">}</span></code></pre></pre>
<p>마찬가지로, 다음은 트레잇 객체에서 슈퍼트레잇 메서드를 호출하는 예입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Shape { fn area(&amp;self) -&gt; f64; }
</span><span class="boring">trait Circle: Shape { fn radius(&amp;self) -&gt; f64; }
</span><span class="boring">struct UnitCircle;
</span><span class="boring">impl Shape for UnitCircle { fn area(&amp;self) -&gt; f64 { std::f64::consts::PI } }
</span><span class="boring">impl Circle for UnitCircle { fn radius(&amp;self) -&gt; f64 { 1.0 } }
</span><span class="boring">let circle = UnitCircle;
</span>let circle = Box::new(circle) as Box&lt;dyn Circle&gt;;
let nonsense = circle.radius() * circle.area();
<span class="boring">}</span></code></pre></pre>
<p>r[items.traits.safety]</p>
<h2 id="unsafe-트레잇"><a class="header" href="#unsafe-트레잇">Unsafe 트레잇</a></h2>
<p>r[items.traits.safety.intro] Traits items that begin with the <code>unsafe</code> keyword indicate that <em>implementing</em> the trait may be <a href="items/../unsafety.html">unsafe</a>. It is safe to use a correctly implemented unsafe trait. The <a href="items/implementations.html#trait-implementations">trait implementation</a> must also begin with the <code>unsafe</code> keyword.</p>
<p><a href="items/../special-types-and-traits.html#sync"><code>Sync</code></a>와 <a href="items/../special-types-and-traits.html#send"><code>Send</code></a>는 unsafe 트레잇의 예입니다.</p>
<p>r[items.traits.params]</p>
<h2 id="매개변수-패턴"><a class="header" href="#매개변수-패턴">매개변수 패턴</a></h2>
<p>r[items.traits.params.patterns-no-body] Parameters in associated functions without a body only allow [IDENTIFIER] or <code>_</code> <a href="items/../patterns.html#wildcard-pattern">wild card</a> patterns, as well as the form allowed by [SelfParam]. <code>mut</code> [IDENTIFIER] is currently allowed, but it is deprecated and will become a hard error in the future.</p>
<!-- https://github.com/rust-lang/rust/issues/35203 -->
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait T {
    fn f1(&amp;self);
    fn f2(x: Self, _: i32);
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail E0642 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait T {
    fn f2(&amp;x: &amp;i32); // ERROR: patterns aren't allowed in functions without bodies
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.traits.params.patterns-with-body] Parameters in associated functions with a body only allow irrefutable patterns.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait T {
    fn f1((a, b): (i32, i32)) {} // OK: is irrefutable
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail E0005 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait T {
    fn f1(123: i32) {} // ERROR: pattern is refutable
    fn f2(Some(x): Option&lt;i32&gt;) {} // ERROR: pattern is refutable
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.traits.params.pattern-required.edition2018]</p>
<blockquote>
<p>[!EDITION-2018] Prior to the 2018 edition, the pattern for an associated function parameter is optional:</p>
<pre><pre class="playground"><code class="language-rust edition2015"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 2015 에디션
trait T {
    fn f(i32); // OK: parameter identifiers are not required
}
<span class="boring">}</span></code></pre></pre>
<p>Beginning in the 2018 edition, patterns are no longer optional.</p>
</blockquote>
<p>r[items.traits.params.restriction-patterns.edition2018]</p>
<blockquote>
<p>[!EDITION-2018] Prior to the 2018 edition, parameters in associated functions with a body are limited to the following kinds of patterns:</p>
<ul>
<li>[IDENTIFIER]</li>
<li><code>mut</code> [IDENTIFIER]</li>
<li><a href="items/../patterns.html#wildcard-pattern"><code>_</code></a></li>
<li><code>&amp;</code> [IDENTIFIER]</li>
<li><code>&amp;&amp;</code> [IDENTIFIER]</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2015 compile_fail E0642"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 2015 에디션
trait T {
    fn f1((a, b): (i32, i32)) {} // ERROR: pattern not allowed
}
<span class="boring">}</span></code></pre></pre>
<p>Beginning in 2018, all irrefutable patterns are allowed as described in [items.traits.params.patterns-with-body].</p>
</blockquote>
<p>r[items.traits.associated-visibility]</p>
<h2 id="아이템-가시성"><a class="header" href="#아이템-가시성">아이템 가시성</a></h2>
<p>r[items.traits.associated-visibility.intro] Trait items syntactically allow a [Visibility] annotation, but this is rejected when the trait is validated. This allows items to be parsed with a unified syntax across different contexts where they are used. As an example, an empty <code>vis</code> macro fragment specifier can be used for trait items, where the macro rule may be used in other situations where visibility is allowed.</p>
<pre><pre class="playground"><code class="language-rust edition2024">macro_rules! create_method {
    ($vis:vis $name:ident) =&gt; {
        $vis fn $name(&amp;self) {}
    };
}

trait T1 {
    // 빈 `vis`는 허용됩니다.
    create_method! { method_of_t1 }
}

struct S;

impl S {
    // 여기서 가시성은 허용됩니다.
    create_method! { pub method_of_s }
}

impl T1 for S {}

fn main() {
    let s = S;
    s.method_of_t1();
    s.method_of_s();
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p>r[items.impl]</p>
<h1 id="구현"><a class="header" href="#구현">구현</a></h1>
<p>r[items.impl.syntax]</p>
<pre><code class="language-grammar items">Implementation -&gt; InherentImpl | TraitImpl

InherentImpl -&gt;
    `impl` GenericParams? Type WhereClause? `{`
        InnerAttribute*
        AssociatedItem*
    `}`

TraitImpl -&gt;
    `unsafe`? `impl` GenericParams? `!`? TypePath `for` Type
    WhereClause?
    `{`
        InnerAttribute*
        AssociatedItem*
    `}`
</code></pre>
<p>r[items.impl.intro] An <em>implementation</em> is an item that associates items with an <em>implementing type</em>. Implementations are defined with the keyword <code>impl</code> and contain functions that belong to an instance of the type that is being implemented or to the type statically.</p>
<p>r[items.impl.kinds] There are two types of implementations:</p>
<ul>
<li>고유 구현(inherent implementations)</li>
<li><a href="items/traits.html">트레잇(trait)</a> 구현</li>
</ul>
<p>r[items.impl.inherent]</p>
<h2 id="inherent-implementations"><a class="header" href="#inherent-implementations">Inherent implementations</a></h2>
<p>r[items.impl.inherent.intro] An inherent implementation is defined as the sequence of the <code>impl</code> keyword, generic type declarations, a path to a nominal type, a where clause, and a bracketed set of associable items.</p>
<p>r[items.impl.inherent.implementing-type] The nominal type is called the <em>implementing type</em> and the associable items are the <em>associated items</em> to the implementing type.</p>
<p>r[items.impl.inherent.associated-items] Inherent implementations associate the contained items to the implementing type.</p>
<p>r[items.impl.inherent.associated-items.allowed-items] Inherent implementations can contain <a href="items/associated-items.html#associated-functions-and-methods">associated functions</a> (including <a href="items/associated-items.html#methods">methods</a>) and <a href="items/associated-items.html#associated-constants">associated constants</a>.</p>
<p>r[items.impl.inherent.type-alias] They cannot contain associated type aliases.</p>
<p>r[items.impl.inherent.associated-item-path] The <a href="items/../paths.html">path</a> to an associated item is any path to the implementing type, followed by the associated item’s identifier as the final path component.</p>
<p>r[items.impl.inherent.coherence] A type can also have multiple inherent implementations. An implementing type must be defined within the same crate as the original type definition.</p>
<pre><pre class="playground"><code class="language-rust edition2024">pub mod color {
    pub struct Color(pub u8, pub u8, pub u8);

    impl Color {
        pub const WHITE: Color = Color(255, 255, 255);
    }
}

mod values {
    use super::color::Color;
    impl Color {
        pub fn red() -&gt; Color {
            Color(255, 0, 0)
        }
    }
}

pub use self::color::Color;
fn main() {
    // 같은 모듈 내의 구현 타입과 구현에 대한 실제 경로.
    color::Color::WHITE;

    // 서로 다른 모듈에 있는 구현 블록들도 여전히 타입을 통한 경로로 접근됩니다.
    color::Color::red();

    // 구현 타입에 대해 다시 내보내기(re-exported)된 경로들도 작동합니다.
    Color::red();

    // 작동하지 않습니다. `values` 내의 사용(use)이 pub이 아니기 때문입니다.
    // values::Color::red();
}</code></pre></pre>
<p>r[items.impl.trait]</p>
<h2 id="trait-implementations"><a class="header" href="#trait-implementations">Trait implementations</a></h2>
<p>r[items.impl.trait.intro] A <em>trait implementation</em> is defined like an inherent implementation except that the optional generic type declarations are followed by a <a href="items/traits.html">trait</a>, followed by the keyword <code>for</code>, followed by a path to a nominal type.</p>
<!-- To understand this, you have to back-reference to the previous section. :( -->
<p>r[items.impl.trait.implemented-trait] The trait is known as the <em>implemented trait</em>. The implementing type implements the implemented trait.</p>
<p>r[items.impl.trait.def-requirement] A trait implementation must define all non-default associated items declared by the implemented trait, may redefine default associated items defined by the implemented trait, and cannot define any other items.</p>
<p>r[items.impl.trait.associated-item-path] The path to the associated items is <code>&lt;</code> followed by a path to the implementing type followed by <code>as</code> followed by a path to the trait followed by <code>&gt;</code> as a path component followed by the associated item’s path component.</p>
<p>r[items.impl.trait.safety] <a href="items/traits.html#unsafe-traits">Unsafe traits</a> require the trait implementation to begin with the <code>unsafe</code> keyword.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Copy, Clone)]
</span><span class="boring">struct Point {x: f64, y: f64};
</span><span class="boring">type Surface = i32;
</span><span class="boring">struct BoundingBox {x: f64, y: f64, width: f64, height: f64};
</span><span class="boring">trait Shape { fn draw(&amp;self, s: Surface); fn bounding_box(&amp;self) -&gt; BoundingBox; }
</span><span class="boring">fn do_draw_circle(s: Surface, c: Circle) { }
</span>struct Circle {
    radius: f64,
    center: Point,
}

impl Copy for Circle {}

impl Clone for Circle {
    fn clone(&amp;self) -&gt; Circle { *self }
}

impl Shape for Circle {
    fn draw(&amp;self, s: Surface) { do_draw_circle(s, *self); }
    fn bounding_box(&amp;self) -&gt; BoundingBox {
        let r = self.radius;
        BoundingBox {
            x: self.center.x - r,
            y: self.center.y - r,
            width: 2.0 * r,
            height: 2.0 * r,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.impl.trait.coherence]</p>
<h3 id="trait-implementation-coherence"><a class="header" href="#trait-implementation-coherence">Trait implementation coherence</a></h3>
<p>r[items.impl.trait.coherence.intro] A trait implementation is considered incoherent if either the orphan rules check fails or there are overlapping implementation instances.</p>
<p>r[items.impl.trait.coherence.overlapping] Two trait implementations overlap when there is a non-empty intersection of the traits the implementation is for, the implementations can be instantiated with the same type. <!-- This is probably wrong? Source: No two implementations can
be instantiable with the same set of types for the input type parameters. --></p>
<p>r[items.impl.trait.orphan-rule]</p>
<h4 id="고아-규칙"><a class="header" href="#고아-규칙">고아 규칙</a></h4>
<p>r[items.impl.trait.orphan-rule.intro] The <em>orphan rule</em> states that a trait implementation is only allowed if either the trait or at least one of the types in the implementation is defined in the current crate. It prevents conflicting trait implementations across different crates and is key to ensuring coherence.</p>
<p>An orphan implementation is one that implements a foreign trait for a foreign type. If these were freely allowed, two crates could implement the same trait for the same type in incompatible ways, creating a situation where adding or updating a dependency could break compilation due to conflicting implementations.</p>
<p>The orphan rule enables library authors to add new implementations to their traits without fear that they’ll break downstream code. Without these restrictions, a library couldn’t add an implementation like <code>impl&lt;T: Display&gt; MyTrait for T</code> without potentially conflicting with downstream implementations.</p>
<p>r[items.impl.trait.orphan-rule.general] Given <code>impl&lt;P1..=Pn&gt; Trait&lt;T1..=Tn&gt; for T0</code>, an <code>impl</code> is valid only if at least one of the following is true:</p>
<ul>
<li><code>Trait</code>가 <a href="items/../glossary.html#local-trait">로컬 트레잇</a>인 경우</li>
<li>다음 모두를 만족하는 경우
<ul>
<li>타입 <code>T0..=Tn</code> 중 적어도 하나는 <a href="items/../glossary.html#local-type">로컬 타입</a>이어야 합니다. 이러한 첫 번째 타입을 <code>Ti</code>라고 합시다.</li>
<li><code>T0..Ti</code>(<code>Ti</code> 제외)에는 <a href="items/../glossary.html#uncovered-type">덮이지 않은 타입(uncovered type)</a> 매개변수 <code>P1..=Pn</code>이 나타날 수 없습니다.</li>
</ul>
</li>
</ul>
<p>r[items.impl.trait.uncovered-param] Only the appearance of <em>uncovered</em> type parameters is restricted.</p>
<p>r[items.impl.trait.fundamental] Note that for the purposes of coherence, <a href="items/../glossary.html#fundamental-type-constructors">fundamental types</a> are special. The <code>T</code> in <code>Box&lt;T&gt;</code> is not considered covered, and <code>Box&lt;LocalType&gt;</code> is considered local.</p>
<p>r[items.impl.generics]</p>
<h2 id="generic-implementations"><a class="header" href="#generic-implementations">Generic implementations</a></h2>
<p>r[items.impl.generics.intro] An implementation can take <a href="items/generics.html">generic parameters</a>, which can be used in the rest of the implementation. Implementation parameters are written directly after the <code>impl</code> keyword.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Seq&lt;T&gt; { fn dummy(&amp;self, _: T) { } }
</span>impl&lt;T&gt; Seq&lt;T&gt; for Vec&lt;T&gt; {
    /* ... */
}
impl Seq&lt;bool&gt; for u32 {
    /* 정수를 비트 시퀀스로 취급 */
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.impl.generics.usage] Generic parameters <em>constrain</em> an implementation if the parameter appears at least once in one of:</p>
<ul>
<li>구현된 트레잇(있는 경우)</li>
<li>구현 타입</li>
<li>구현을 제약하는 다른 매개변수를 포함하는 타입의 <a href="items/../trait-bounds.html">바운드</a>에 있는 <a href="items/associated-items.html#associated-types">연관 타입</a>으로서</li>
</ul>
<p>r[items.impl.generics.constrain] Type and const parameters must always constrain the implementation. Lifetimes must constrain the implementation if the lifetime is used in an associated type.</p>
<p>제약하는 상황의 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait{}
</span><span class="boring">trait GenericTrait&lt;T&gt; {}
</span><span class="boring">trait HasAssocType { type Ty; }
</span><span class="boring">struct Struct;
</span><span class="boring">struct GenericStruct&lt;T&gt;(T);
</span><span class="boring">struct ConstGenericStruct&lt;const N: usize&gt;([(); N]);
</span>// T는 GenericTrait의 인수가 됨으로써 제약합니다.
impl&lt;T&gt; GenericTrait&lt;T&gt; for i32 { /* ... */ }

// T는 GenericStruct의 인수가 됨으로써 제약합니다.
impl&lt;T&gt; Trait for GenericStruct&lt;T&gt; { /* ... */ }

// 마찬가지로, N은 ConstGenericStruct의 인수가 됨으로써 제약합니다.
impl&lt;const N: usize&gt; Trait for ConstGenericStruct&lt;N&gt; { /* ... */ }

// T는 트레잇을 제약하는 제네릭 매개변수인 타입 `U`에 대한 바운드의
// 연관 타입 안에 있음으로써 제약합니다.
impl&lt;T, U&gt; GenericTrait&lt;U&gt; for u32 where U: HasAssocType&lt;Ty = T&gt; { /* ... */ }

// 이전과 비슷하지만, 타입이 `(U, isize)`라는 점이 다릅니다. `U`는 `T`를 포함하는
// 타입 내부에 나타나며, 타입 자체는 아닙니다.
impl&lt;T, U&gt; GenericStruct&lt;U&gt; where (U, isize): HasAssocType&lt;Ty = T&gt; { /* ... */ }
<span class="boring">}</span></code></pre></pre>
<p>제약하지 않는 상황의 예시:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The rest of these are errors, since they have type or const parameters that
// do not constrain.

// T는 전혀 나타나지 않으므로 제약하지 않습니다.
impl&lt;T&gt; Struct { /* ... */ }

// N도 같은 이유로 제약하지 않습니다.
impl&lt;const N: usize&gt; Struct { /* ... */ }

// 구현 내부에서의 T의 사용은 구현을 제약하지 않습니다.
impl&lt;T&gt; Struct {
    fn uses_t(t: &amp;T) { /* ... */ }
}

// T는 U에 대한 바운드의 연관 타입으로 사용되지만, U가 제약하지 않습니다.
impl&lt;T, U&gt; Struct where U: HasAssocType&lt;Ty = T&gt; { /* ... */ }

// T는 바운드에서 사용되지만, 연관 타입으로서가 아니므로 제약하지 않습니다.
impl&lt;T, U&gt; GenericTrait&lt;U&gt; for u32 where U: GenericTrait&lt;T&gt; {}
<span class="boring">}</span></code></pre></pre>
<p>허용되는, 제약하지 않는 라이프타임 매개변수의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Struct;
</span>impl&lt;'a&gt; Struct {}
<span class="boring">}</span></code></pre></pre>
<p>허용되지 않는, 제약하지 않는 라이프타임 매개변수의 예:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Struct;
</span><span class="boring">trait HasAssocType { type Ty; }
</span>impl&lt;'a&gt; HasAssocType for Struct {
    type Ty = &amp;'a Struct;
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.impl.attributes]</p>
<h2 id="attributes-on-implementations"><a class="header" href="#attributes-on-implementations">Attributes on implementations</a></h2>
<p>구현은 <code>impl</code> 키워드 앞에 외부 <a href="items/../attributes.html">속성</a>을, 연관 아이템을 포함하는 중괄호 안에 내부 <a href="items/../attributes.html">속성</a>을 가질 수 있습니다. 내부 속성은 반드시 모든 연관 아이템보다 먼저 와야 합니다. 여기서 의미를 갖는 속성은 <a href="items/../conditional-compilation.html"><code>cfg</code></a>, <a href="items/../attributes/diagnostics.html#the-deprecated-attribute"><code>deprecated</code></a>, <a href="items/../../rustdoc/the-doc-attribute.html"><code>doc</code></a>, 그리고 <a href="items/../attributes/diagnostics.html#lint-check-attributes">린트 검사 속성</a>입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[items.extern]</p>
<h1 id="외부-블록"><a class="header" href="#외부-블록">외부 블록</a></h1>
<p>r[items.extern.syntax]</p>
<pre><code class="language-grammar items">ExternBlock -&gt;
    `unsafe`?[^unsafe-2024] `extern` Abi? `{`
        InnerAttribute*
        ExternalItem*
    `}`

ExternalItem -&gt;
    OuterAttribute* (
        MacroInvocationSemi
      | Visibility? StaticItem
      | Visibility? Function
    )
</code></pre>
<div class="footnote-definition" id="unsafe-2024"><sup class="footnote-definition-label">1</sup>
<p>2024 에디션부터는 <code>unsafe</code> 키워드가 시맨틱적으로 요구됩니다.</p>
</div>
<p>r[items.extern.intro] External blocks provide <em>declarations</em> of items that are not <em>defined</em> in the current crate and are the basis of Rust’s foreign function interface. These are akin to unchecked imports.</p>
<p>r[items.extern.allowed-kinds] Two kinds of item <em>declarations</em> are allowed in external blocks: <a href="items/functions.html">functions</a> and <a href="items/static-items.html">statics</a>.</p>
<p>r[items.extern.safety] Calling unsafe functions or accessing unsafe statics that are declared in external blocks is only allowed in an <a href="items/../unsafe-keyword.html"><code>unsafe</code> context</a>.</p>
<p>r[items.extern.namespace] The external block defines its functions and statics in the <a href="items/../names/namespaces.html">value namespace</a> of the module or block where it is located.</p>
<p>r[items.extern.unsafe-required] The <code>unsafe</code> keyword is semantically required to appear before the <code>extern</code> keyword on external blocks.</p>
<p>r[items.extern.edition2024]</p>
<blockquote>
<p>[!EDITION-2024] Prior to the 2024 edition, the <code>unsafe</code> keyword is optional. The <code>safe</code> and <code>unsafe</code> item qualifiers are only allowed if the external block itself is marked as <code>unsafe</code>.</p>
</blockquote>
<p>r[items.extern.fn]</p>
<h2 id="함수-1"><a class="header" href="#함수-1">함수</a></h2>
<p>r[items.extern.fn.body] Functions within external blocks are declared in the same way as other Rust functions, with the exception that they must not have a body and are instead terminated by a semicolon.</p>
<p>r[items.extern.fn.param-patterns] Patterns are not allowed in parameters, only [IDENTIFIER] or <code>_</code> may be used.</p>
<p>r[items.extern.fn.qualifiers] The <code>safe</code> and <code>unsafe</code> function qualifiers are allowed, but other function qualifiers (e.g. <code>const</code>, <code>async</code>, <code>extern</code>) are not.</p>
<p>r[items.extern.fn.foreign-abi] Functions within external blocks may be called by Rust code, just like functions defined in Rust. The Rust compiler automatically translates between the Rust ABI and the foreign ABI.</p>
<p>r[items.extern.fn.safety] A function declared in an extern block is implicitly <code>unsafe</code> unless the <code>safe</code> function qualifier is present.</p>
<p>r[items.extern.fn.fn-ptr] When coerced to a function pointer, a function declared in an extern block has type <code>extern "abi" for&lt;'l1, ..., 'lm&gt; fn(A1, ..., An) -&gt; R</code>, where <code>'l1</code>, … <code>'lm</code> are its lifetime parameters, <code>A1</code>, …, <code>An</code> are the declared types of its parameters, and <code>R</code> is the declared return type.</p>
<p>r[items.extern.static]</p>
<h2 id="정적-아이템-1"><a class="header" href="#정적-아이템-1">정적 아이템</a></h2>
<p>r[items.extern.static.intro] Statics within external blocks are declared in the same way as <a href="items/static-items.html">statics</a> outside of external blocks, except that they do not have an expression initializing their value.</p>
<p>r[items.extern.static.safety] Unless a static item declared in an extern block is qualified as <code>safe</code>, it is <code>unsafe</code> to access that item, whether or not it’s mutable, because there is nothing guaranteeing that the bit pattern at the static’s memory is valid for the type it is declared with, since some arbitrary (e.g. C) code is in charge of initializing the static.</p>
<p>r[items.extern.static.mut] Extern statics can be either immutable or mutable just like <a href="items/static-items.html">statics</a> outside of external blocks.</p>
<p>r[items.extern.static.read-only] An immutable static <em>must</em> be initialized before any Rust code is executed. It is not enough for the static to be initialized before Rust code reads from it. Once Rust code runs, mutating an immutable static (from inside or outside Rust) is UB, except if the mutation happens to bytes inside of an <code>UnsafeCell</code>.</p>
<p>r[items.extern.abi]</p>
<h2 id="abi"><a class="header" href="#abi">ABI</a></h2>
<p>r[items.extern.abi.intro] The <code>extern</code> keyword can be followed by an optional <a href="items/glossary.abi">ABI</a> string. The ABI specifies the calling convention of the functions in the block. The calling convention defines a low-level interface for functions, such as how arguments are placed in registers or on the stack, how return values are passed, and who is responsible for cleaning up the stack.</p>
<blockquote>
<p>[!EXAMPLE]</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Interface to the Windows API.
unsafe extern "system" { /* ... */ }
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[items.extern.abi.default] If the ABI string is not specified, it defaults to <code>"C"</code>.</p>
<blockquote>
<p>[!NOTE] The <code>extern</code> syntax without an explicit ABI is being phased out, so it’s better to always write the ABI explicitly.</p>
<p>For more details, see <a href="https://github.com/rust-lang/rust/issues/134986">Rust issue #134986</a>.</p>
</blockquote>
<p>r[items.extern.abi.standard] The following ABI strings are supported on all platforms:</p>
<p>r[items.extern.abi.rust]</p>
<ul>
<li><code>unsafe extern "Rust"</code> — The native calling convention for Rust functions and closures. This is the default when a function is declared without using <a href="items/items.fn.extern"><code>extern fn</code></a>. The Rust ABI offers no stability guarantees.</li>
</ul>
<p>r[items.extern.abi.c]</p>
<ul>
<li><code>unsafe extern "C"</code> — The “C” ABI matches the default ABI chosen by the dominant C compiler for the target.</li>
</ul>
<p>r[items.extern.abi.system]</p>
<ul>
<li>
<p><code>unsafe extern "system"</code> — This is equivalent to <code>extern "C"</code> except on Windows x86_32 where it is equivalent to <code>"stdcall"</code> for non-variadic functions, and equivalent to <code>"C"</code> for variadic functions.</p>
<blockquote>
<p>[!NOTE] As the correct underlying ABI on Windows is target-specific, it’s best to use <code>extern "system"</code> when attempting to link Windows API functions that don’t use an explicitly defined ABI.</p>
</blockquote>
</li>
</ul>
<p>r[items.extern.abi.unwind]</p>
<ul>
<li><code>extern "C-unwind"</code> and <code>extern "system-unwind"</code> — Identical to <code>"C"</code> and <code>"system"</code>, respectively, but with <a href="items/functions.html#unwinding">different behavior</a> when the callee unwinds (by panicking or throwing a C++ style exception).</li>
</ul>
<p>r[items.extern.abi.platform] There are also some platform-specific ABI strings:</p>
<p>r[items.extern.abi.cdecl]</p>
<ul>
<li>
<p><code>unsafe extern "cdecl"</code> — The calling convention typically used with x86_32 C code.</p>
<ul>
<li>Only available on x86_32 targets.</li>
<li>Corresponds to MSVC’s <code>__cdecl</code> and GCC and clang’s <code>__attribute__((cdecl))</code>.</li>
</ul>
<blockquote>
<p>[!NOTE] For details, see:</p>
<ul>
<li><a href="https://learn.microsoft.com/en-us/cpp/cpp/cdecl">https://learn.microsoft.com/en-us/cpp/cpp/cdecl</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86_calling_conventions#cdecl">https://en.wikipedia.org/wiki/X86_calling_conventions#cdecl</a></li>
</ul>
</blockquote>
</li>
</ul>
<p>r[items.extern.abi.stdcall]</p>
<ul>
<li>
<p><code>unsafe extern "stdcall"</code> — The calling convention typically used by the <a href="https://learn.microsoft.com/en-us/windows/win32/api/">Win32 API</a> on x86_32.</p>
<ul>
<li>Only available on x86_32 targets.</li>
<li>Corresponds to MSVC’s <code>__stdcall</code> and GCC and clang’s <code>__attribute__((stdcall))</code>.</li>
</ul>
<blockquote>
<p>[!NOTE] For details, see:</p>
<ul>
<li><a href="https://learn.microsoft.com/en-us/cpp/cpp/stdcall">https://learn.microsoft.com/en-us/cpp/cpp/stdcall</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86_calling_conventions#stdcall">https://en.wikipedia.org/wiki/X86_calling_conventions#stdcall</a></li>
</ul>
</blockquote>
</li>
</ul>
<p>r[items.extern.abi.win64]</p>
<ul>
<li>
<p><code>unsafe extern "win64"</code> — The Windows x64 ABI.</p>
<ul>
<li>Only available on x86_64 targets.</li>
<li>“win64” is the same as the “C” ABI on Windows x86_64 targets.</li>
<li>Corresponds to GCC and clang’s <code>__attribute__((ms_abi))</code>.</li>
</ul>
<blockquote>
<p>[!NOTE] For details, see:</p>
<ul>
<li><a href="https://learn.microsoft.com/en-us/cpp/build/x64-software-conventions">https://learn.microsoft.com/en-us/cpp/build/x64-software-conventions</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86_calling_conventions#Microsoft_x64_calling_convention">https://en.wikipedia.org/wiki/X86_calling_conventions#Microsoft_x64_calling_convention</a></li>
</ul>
</blockquote>
</li>
</ul>
<p>r[items.extern.abi.sysv64]</p>
<ul>
<li>
<p><code>unsafe extern "sysv64"</code> — The System V ABI.</p>
<ul>
<li>Only available on x86_64 targets.</li>
<li>“sysv64” is the same as the “C” ABI on non-Windows x86_64 targets.</li>
<li>Corresponds to GCC and clang’s <code>__attribute__((sysv_abi))</code>.</li>
</ul>
<blockquote>
<p>[!NOTE] For details, see:</p>
<ul>
<li><a href="https://wiki.osdev.org/System_V_ABI">https://wiki.osdev.org/System_V_ABI</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI">https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI</a></li>
</ul>
</blockquote>
</li>
</ul>
<p>r[items.extern.abi.aapcs]</p>
<ul>
<li>
<p><code>unsafe extern "aapcs"</code> — The soft-float ABI for ARM.</p>
<ul>
<li>Only available on ARM32 targets.</li>
<li>“aapcs” is the same as the “C” ABI on soft-float ARM32.</li>
<li>Corresponds to clang’s <code>__attribute__((pcs("aapcs")))</code>.</li>
</ul>
<blockquote>
<p>[!NOTE] For details, see:</p>
<ul>
<li><a href="https://developer.arm.com/documentation/107656/0101/Getting-started-with-Armv8-M-based-systems/Procedure-Call-Standard-for-Arm-Architecture--AAPCS-">Arm Procedure Call Standard</a></li>
</ul>
</blockquote>
</li>
</ul>
<p>r[items.extern.abi.fastcall]</p>
<ul>
<li>
<p><code>unsafe extern "fastcall"</code> — A “fast” variant of stdcall that passes some arguments in registers.</p>
<ul>
<li>Only available on x86_32 targets.</li>
<li>Corresponds to MSVC’s <code>__fastcall</code> and GCC and clang’s <code>__attribute__((fastcall))</code>.</li>
</ul>
<blockquote>
<p>[!NOTE] For details, see:</p>
<ul>
<li><a href="https://learn.microsoft.com/en-us/cpp/cpp/fastcall">https://learn.microsoft.com/en-us/cpp/cpp/fastcall</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86_calling_conventions#Microsoft_fastcall">https://en.wikipedia.org/wiki/X86_calling_conventions#Microsoft_fastcall</a></li>
</ul>
</blockquote>
</li>
</ul>
<p>r[items.extern.abi.thiscall]</p>
<ul>
<li>
<p><code>unsafe extern "thiscall"</code> — The calling convention typically used on C++ class member functions on x86_32 MSVC.</p>
<ul>
<li>Only available on x86_32 targets.</li>
<li>Corresponds to MSVC’s <code>__thiscall</code> and GCC and clang’s <code>__attribute__((thiscall))</code>.</li>
</ul>
<blockquote>
<p>[!NOTE] For details, see:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/X86_calling_conventions#thiscall">https://en.wikipedia.org/wiki/X86_calling_conventions#thiscall</a></li>
<li><a href="https://learn.microsoft.com/en-us/cpp/cpp/thiscall">https://learn.microsoft.com/en-us/cpp/cpp/thiscall</a></li>
</ul>
</blockquote>
</li>
</ul>
<p>r[items.extern.abi.efiapi]</p>
<ul>
<li><code>unsafe extern "efiapi"</code> — The ABI used for <a href="https://uefi.org/specifications">UEFI</a> functions.
<ul>
<li>Only available on x86 and ARM targets (32bit and 64bit).</li>
</ul>
</li>
</ul>
<p>r[items.extern.abi.platform-unwind-variants] Like <code>"C"</code> and <code>"system"</code>, most platform-specific ABI strings also have a <a href="items/functions.html#unwinding">corresponding <code>-unwind</code> variant</a>; specifically, these are:</p>
<ul>
<li><code>"aapcs-unwind"</code></li>
<li><code>"cdecl-unwind"</code></li>
<li><code>"fastcall-unwind"</code></li>
<li><code>"stdcall-unwind"</code></li>
<li><code>"sysv64-unwind"</code></li>
<li><code>"thiscall-unwind"</code></li>
<li><code>"win64-unwind"</code></li>
</ul>
<p>r[items.extern.variadic]</p>
<h2 id="가변-인자-함수"><a class="header" href="#가변-인자-함수">가변 인자 함수</a></h2>
<p>외부 블록 내의 함수는 마지막 인수로 <code>...</code>을 지정하여 가변 인자 함수가 될 수 있습니다. 가변 인자 매개변수는 선택적으로 식별자를 가질 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe extern "C" {
    unsafe fn foo(...);
    unsafe fn bar(x: i32, ...);
    unsafe fn with_name(format: *const u8, args: ...);
    // SAFETY: This function guarantees it will not access
    // variadic arguments.
    safe fn ignores_variadic_arguments(x: i32, ...);
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!WARNING] The <code>safe</code> qualifier should not be used on a function in an <code>extern</code> block unless that function guarantees that it will not access the variadic arguments at all. Passing an unexpected number of arguments or arguments of unexpected type to a variadic function may lead to [undefined behavior][undefined].</p>
</blockquote>
<p>r[items.extern.variadic.conventions] Variadic parameters can only be specified within <code>extern</code> blocks with the following ABI strings or their corresponding [<code>-unwind</code> variants][items.fn.extern.unwind]:</p>
<ul>
<li><code>"aapcs"</code></li>
<li><code>"C"</code></li>
<li><code>"cdecl"</code></li>
<li><code>"efiapi"</code></li>
<li><code>"system"</code></li>
<li><code>"sysv64"</code></li>
<li><code>"win64"</code></li>
</ul>
<p>r[items.extern.attributes]</p>
<h2 id="외부-블록의-속성"><a class="header" href="#외부-블록의-속성">외부 블록의 속성</a></h2>
<p>r[items.extern.attributes.intro] The following <a href="items/../attributes.html">attributes</a> control the behavior of external blocks.</p>
<p>r[items.extern.attributes.link]</p>
<h3 id="link-속성"><a class="header" href="#link-속성"><code>link</code> 속성</a></h3>
<p>r[items.extern.attributes.link.intro] The <em><code>link</code> attribute</em> specifies the name of a native library that the compiler should link with for the items within an <code>extern</code> block.</p>
<p>r[items.extern.attributes.link.syntax] It uses the [MetaListNameValueStr] syntax to specify its inputs. The <code>name</code> key is the name of the native library to link. The <code>kind</code> key is an optional value which specifies the kind of library with the following possible values:</p>
<p>r[items.extern.attributes.link.dylib]</p>
<ul>
<li><code>dylib</code> — 동적 라이브러리임을 나타냅니다. <code>kind</code>가 지정되지 않은 경우의 기본값입니다.</li>
</ul>
<p>r[items.extern.attributes.link.static]</p>
<ul>
<li><code>static</code> — 정적 라이브러리임을 나타냅니다.</li>
</ul>
<p>r[items.extern.attributes.link.framework]</p>
<ul>
<li><code>framework</code> — macOS 프레임워크임을 나타냅니다. macOS 타겟인 경우에만 유효합니다.</li>
</ul>
<p>r[items.extern.attributes.link.raw-dylib]</p>
<ul>
<li><code>raw-dylib</code> — 컴파일러가 링크를 위해 임포트 라이브러리를 생성할 동적 라이브러리임을 나타냅니다(자세한 내용은 아래의 <a href="items/external-blocks.html#dylib-versus-raw-dylib"><code>dylib</code> 대 <code>raw-dylib</code></a> 섹션을 참조하세요). Windows 타겟인 경우에만 유효합니다.</li>
</ul>
<p>r[items.extern.attributes.link.name-requirement] The <code>name</code> key must be included if <code>kind</code> is specified.</p>
<p>r[items.extern.attributes.link.modifiers] The optional <code>modifiers</code> argument is a way to specify linking modifiers for the library to link.</p>
<p>r[items.extern.attributes.link.modifiers.syntax] Modifiers are specified as a comma-delimited string with each modifier prefixed with either a <code>+</code> or <code>-</code> to indicate that the modifier is enabled or disabled, respectively.</p>
<p>r[items.extern.attributes.link.modifiers.multiple] Specifying multiple <code>modifiers</code> arguments in a single <code>link</code> attribute, or multiple identical modifiers in the same <code>modifiers</code> argument is not currently supported.<br />
Example: <code>#[link(name = "mylib", kind = "static", modifiers = "+whole-archive")]</code>.</p>
<p>r[items.extern.attributes.link.wasm_import_module] The <code>wasm_import_module</code> key may be used to specify the <a href="https://webassembly.github.io/spec/core/syntax/modules.html">WebAssembly module</a> name for the items within an <code>extern</code> block when importing symbols from the host environment. The default module name is <code>env</code> if <code>wasm_import_module</code> is not specified.</p>
<!-- ignore: requires extern linking -->
<pre><code class="language-rust ignore">#[link(name = "crypto")]
unsafe extern {
    // …
}

#[link(name = "CoreFoundation", kind = "framework")]
unsafe extern {
    // …
}

#[link(wasm_import_module = "foo")]
unsafe extern {
    // …
}</code></pre>
<p>r[items.extern.attributes.link.empty-block] It is valid to add the <code>link</code> attribute on an empty extern block. You can use this to satisfy the linking requirements of extern blocks elsewhere in your code (including upstream crates) instead of adding the attribute to each extern block.</p>
<p>r[items.extern.attributes.link.modifiers.bundle]</p>
<h4 id="링크-수정자-bundle"><a class="header" href="#링크-수정자-bundle">링크 수정자: <code>bundle</code></a></h4>
<p>r[items.extern.attributes.link.modifiers.bundle.allowed-kinds] This modifier is only compatible with the <code>static</code> linking kind. Using any other kind will result in a compiler error.</p>
<p>r[items.extern.attributes.link.modifiers.bundle.behavior] When building a rlib or staticlib <code>+bundle</code> means that the native static library will be packed into the rlib or staticlib archive, and then retrieved from there during linking of the final binary.</p>
<p>r[items.extern.attributes.link.modifiers.bundle.behavior-negative] When building a rlib <code>-bundle</code> means that the native static library is registered as a dependency of that rlib “by name”, and object files from it are included only during linking of the final binary, the file search by that name is also performed during final linking.<br />
When building a staticlib <code>-bundle</code> means that the native static library is simply not included into the archive and some higher level build system will need to add it later during linking of the final binary.</p>
<p>r[items.extern.attributes.link.modifiers.bundle.no-effect] This modifier has no effect when building other targets like executables or dynamic libraries.</p>
<p>r[items.extern.attributes.link.modifiers.bundle.default] The default for this modifier is <code>+bundle</code>.</p>
<p>이 수정자에 대한 더 자세한 구현 세부 사항은 <a href="items/../../rustc/command-line-arguments.html#linking-modifiers-bundle">rustc의 <code>bundle</code> 문서</a>에서 확인할 수 있습니다.</p>
<p>r[items.extern.attributes.link.modifiers.whole-archive]</p>
<h4 id="링크-수정자-whole-archive"><a class="header" href="#링크-수정자-whole-archive">링크 수정자: <code>whole-archive</code></a></h4>
<p>r[items.extern.attributes.link.modifiers.whole-archive.allowed-kinds] This modifier is only compatible with the <code>static</code> linking kind. Using any other kind will result in a compiler error.</p>
<p>r[items.extern.attributes.link.modifiers.whole-archive.behavior] <code>+whole-archive</code> means that the static library is linked as a whole archive without throwing any object files away.</p>
<p>r[items.extern.attributes.link.modifiers.whole-archive.default] The default for this modifier is <code>-whole-archive</code>.</p>
<p>이 수정자에 대한 더 자세한 구현 세부 사항은 <a href="items/../../rustc/command-line-arguments.html#linking-modifiers-whole-archive">rustc의 <code>whole-archive</code> 문서</a>에서 확인할 수 있습니다.</p>
<p>r[items.extern.attributes.link.modifiers.verbatim]</p>
<h3 id="링크-수정자-verbatim"><a class="header" href="#링크-수정자-verbatim">링크 수정자: <code>verbatim</code></a></h3>
<p>r[items.extern.attributes.link.modifiers.verbatim.allowed-kinds] This modifier is compatible with all linking kinds.</p>
<p>r[items.extern.attributes.link.modifiers.verbatim.behavior] <code>+verbatim</code> means that rustc itself won’t add any target-specified library prefixes or suffixes (like <code>lib</code> or <code>.a</code>) to the library name, and will try its best to ask for the same thing from the linker.</p>
<p>r[items.extern.attributes.link.modifiers.verbatim.behavior-negative] <code>-verbatim</code> means that rustc will either add a target-specific prefix and suffix to the library name before passing it to linker, or won’t prevent linker from implicitly adding it.</p>
<p>r[items.extern.attributes.link.modifiers.verbatim.default] The default for this modifier is <code>-verbatim</code>.</p>
<p>이 수정자에 대한 더 자세한 구현 세부 사항은 <a href="items/../../rustc/command-line-arguments.html#linking-modifiers-verbatim">rustc의 <code>verbatim</code> 문서</a>에서 확인할 수 있습니다.</p>
<p>r[items.extern.attributes.link.kind-raw-dylib]</p>
<h4 id="dylib-대-raw-dylib"><a class="header" href="#dylib-대-raw-dylib"><code>dylib</code> 대 <code>raw-dylib</code></a></h4>
<p>r[items.extern.attributes.link.kind-raw-dylib.intro] On Windows, linking against a dynamic library requires that an import library is provided to the linker: this is a special static library that declares all of the symbols exported by the dynamic library in such a way that the linker knows that they have to be dynamically loaded at runtime.</p>
<p>r[items.extern.attributes.link.kind-raw-dylib.import] Specifying <code>kind = "dylib"</code> instructs the Rust compiler to link an import library based on the <code>name</code> key. The linker will then use its normal library resolution logic to find that import library. Alternatively, specifying <code>kind = "raw-dylib"</code> instructs the compiler to generate an import library during compilation and provide that to the linker instead.</p>
<p>r[items.extern.attributes.link.kind-raw-dylib.platform-specific] <code>raw-dylib</code> is only supported on Windows. Using it when targeting other platforms will result in a compiler error.</p>
<p>r[items.extern.attributes.link.import_name_type]</p>
<h4 id="import_name_type-키"><a class="header" href="#import_name_type-키"><code>import_name_type</code> 키</a></h4>
<p>r[items.extern.attributes.link.import_name_type.intro] On x86 Windows, names of functions are “decorated” (i.e., have a specific prefix and/or suffix added) to indicate their calling convention. For example, a <code>stdcall</code> calling convention function with the name <code>fn1</code> that has no arguments would be decorated as <code>_fn1@0</code>. However, the <a href="https://learn.microsoft.com/windows/win32/debug/pe-format#import-name-type">PE Format</a> does also permit names to have no prefix or be undecorated. Additionally, the MSVC and GNU toolchains use different decorations for the same calling conventions which means, by default, some Win32 functions cannot be called using the <code>raw-dylib</code> link kind via the GNU toolchain.</p>
<p>r[items.extern.attributes.link.import_name_type.values] To allow for these differences, when using the <code>raw-dylib</code> link kind you may also specify the <code>import_name_type</code> key with one of the following values to change how functions are named in the generated import library:</p>
<ul>
<li><code>decorated</code>: 함수 이름이 MSVC 툴체인 형식을 사용하여 완전히 장식됩니다.</li>
<li><code>noprefix</code>: 함수 이름이 MSVC 툴체인 형식을 사용하여 장식되지만, 앞의 <code>?</code>, <code>@</code> 또는 선택적으로 <code>_</code>를 생략합니다.</li>
<li><code>undecorated</code>: 함수 이름이 장식되지 않습니다.</li>
</ul>
<p>r[items.extern.attributes.link.import_name_type.default] If the <code>import_name_type</code> key is not specified, then the function name will be fully-decorated using the target toolchain’s format.</p>
<p>r[items.extern.attributes.link.import_name_type.variables] Variables are never decorated and so the <code>import_name_type</code> key has no effect on how they are named in the generated import library.</p>
<p>r[items.extern.attributes.link.import_name_type.platform-specific] The <code>import_name_type</code> key is only supported on x86 Windows. Using it when targeting other platforms will result in a compiler error.</p>
<!-- template:attributes -->
<p>r[items.extern.attributes.link_name]</p>
<h3 id="link_name-속성"><a class="header" href="#link_name-속성"><code>link_name</code> 속성</a></h3>
<p>r[items.extern.attributes.link_name.intro] The <em><code>link_name</code> <a href="items/../attributes.html">attribute</a></em> may be applied to declarations inside an <code>extern</code> block to specify the symbol to import for the given function or static.</p>
<blockquote>
<p>[!EXAMPLE]</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe extern "C" {
    #[link_name = "actual_symbol_name"]
    safe fn name_in_rust();
}
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[items.extern.attributes.link_name.syntax] The <code>link_name</code> attribute uses the [MetaNameValueStr] syntax.</p>
<p>r[items.extern.attributes.link_name.allowed-positions] The <code>link_name</code> attribute may only be applied to a function or static item in an <code>extern</code> block.</p>
<blockquote>
<p>[!NOTE] <code>rustc</code> ignores use in other positions but lints against it. This may become an error in the future.</p>
</blockquote>
<p>r[items.extern.attributes.link_name.duplicates] Only the last use of <code>link_name</code> on an item has effect.</p>
<blockquote>
<p>[!NOTE] <code>rustc</code> lints against any use preceding the last. This may become an error in the future.</p>
</blockquote>
<p>r[items.extern.attributes.link_name.link_ordinal] The <code>link_name</code> attribute may not be used with the <a href="items/items.extern.attributes.link_ordinal"><code>link_ordinal</code></a> attribute.</p>
<p>r[items.extern.attributes.link_ordinal]</p>
<h3 id="link_ordinal-속성"><a class="header" href="#link_ordinal-속성"><code>link_ordinal</code> 속성</a></h3>
<p>r[items.extern.attributes.link_ordinal.intro] The <em><code>link_ordinal</code> attribute</em> can be applied on declarations inside an <code>extern</code> block to indicate the numeric ordinal to use when generating the import library to link against. An ordinal is a unique number per symbol exported by a dynamic library on Windows and can be used when the library is being loaded to find that symbol rather than having to look it up by name.</p>
<blockquote>
<p>[!WARNING] <code>link_ordinal</code> should only be used in cases where the ordinal of the symbol is known to be stable: if the ordinal of a symbol is not explicitly set when its containing binary is built then one will be automatically assigned to it, and that assigned ordinal may change between builds of the binary.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(all(windows, target_arch = "x86"))]
</span>#[link(name = "exporter", kind = "raw-dylib")]
unsafe extern "stdcall" {
    #[link_ordinal(15)]
    safe fn imported_function_stdcall(i: i32);
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.extern.attributes.link_ordinal.allowed-kinds] This attribute is only used with the <code>raw-dylib</code> linking kind. Using any other kind will result in a compiler error.</p>
<p>r[items.extern.attributes.link_ordinal.exclusive] Using this attribute with the <code>link_name</code> attribute will result in a compiler error.</p>
<p>r[items.extern.attributes.fn-parameters]</p>
<h3 id="함수-매개변수의-속성-1"><a class="header" href="#함수-매개변수의-속성-1">함수 매개변수의 속성</a></h3>
<p>외부 함수의 매개변수에 붙는 속성들은 <a href="items/functions.html#attributes-on-function-parameters">일반 함수 매개변수</a>와 동일한 규칙 및 제약 사항을 따릅니다.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[items.generics]</p>
<h1 id="제네릭-파라미터"><a class="header" href="#제네릭-파라미터">제네릭 파라미터</a></h1>
<p>r[items.generics.syntax]</p>
<pre><code class="language-grammar items">GenericParams -&gt; `&lt;` ( GenericParam (`,` GenericParam)* `,`? )? `&gt;`

GenericParam -&gt; OuterAttribute* ( LifetimeParam | TypeParam | ConstParam )

LifetimeParam -&gt; Lifetime ( `:` LifetimeBounds )?

TypeParam -&gt; IDENTIFIER ( `:` TypeParamBounds? )? ( `=` Type )?

ConstParam -&gt;
    `const` IDENTIFIER `:` Type
    ( `=` ( BlockExpression | IDENTIFIER | `-`?LiteralExpression ) )?
</code></pre>
<p>r[items.generics.syntax.intro] <a href="items/functions.html">Functions</a>, <a href="items/type-aliases.html">type aliases</a>, <a href="items/structs.html">structs</a>, <a href="items/enumerations.html">enumerations</a>, <a href="items/unions.html">unions</a>, <a href="items/traits.html">traits</a>, and <a href="items/implementations.html">implementations</a> may be <em>parameterized</em> by types, constants, and lifetimes. These parameters are listed in angle <span class="parenthetical">brackets (<code>&lt;...&gt;</code>)</span>, usually immediately after the name of the item and before its definition. For implementations, which don’t have a name, they come directly after <code>impl</code>.</p>
<p>r[items.generics.syntax.decl-order] The order of generic parameters is restricted to lifetime parameters and then type and const parameters intermixed.</p>
<p>r[items.generics.syntax.duplicate-params] The same parameter name may not be declared more than once in a [GenericParams] list.</p>
<p>타입, 상수, 라이프타임 매개변수를 가진 아이템의 몇 가지 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;'a, T&gt;() {}
trait A&lt;U&gt; {}
struct Ref&lt;'a, T&gt; where T: 'a { r: &amp;'a T }
struct InnerArray&lt;T, const N: usize&gt;([T; N]);
struct EitherOrderWorks&lt;const N: bool, U&gt;(U);
<span class="boring">}</span></code></pre></pre>
<p>r[items.generics.syntax.scope] Generic parameters are in scope within the item definition where they are declared. They are not in scope for items declared within the body of a function as described in <a href="items/../statements.html#item-declarations">item declarations</a>. See <a href="items/../names/scopes.html#generic-parameter-scopes">generic parameter scopes</a> for more details.</p>
<p>r[items.generics.builtin-generic-types] <a href="items/../types/pointer.html#shared-references-">References</a>, <a href="items/../types/pointer.html#raw-pointers-const-and-mut">raw pointers</a>, <a href="items/../types/array.html">arrays</a>, <a href="items/../types/slice.html">slices</a>, <a href="items/../types/tuple.html">tuples</a>, and <a href="items/../types/function-pointer.html">function pointers</a> have lifetime or type parameters as well, but are not referred to with path syntax.</p>
<p>r[items.generics.invalid-lifetimes] <code>'_</code> and <code>'static</code> are not valid lifetime parameter names.</p>
<p>r[items.generics.const]</p>
<h3 id="상수-제네릭"><a class="header" href="#상수-제네릭">상수 제네릭</a></h3>
<p>r[items.generics.const.intro] <em>Const generic parameters</em> allow items to be generic over constant values.</p>
<p>r[items.generics.const.namespace] The const identifier introduces a name in the <a href="items/../names/namespaces.html">value namespace</a> for the constant parameter, and all instances of the item must be instantiated with a value of the given type.</p>
<p>r[items.generics.const.allowed-types] The only allowed types of const parameters are <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, <code>usize</code>, <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, <code>isize</code>, <code>char</code> and <code>bool</code>.</p>
<p>r[items.generics.const.usage] Const parameters can be used anywhere a <a href="items/constant-items.html">const item</a> can be used, with the exception that when used in a <a href="items/../types.html">type</a> or <a href="items/../expressions/array-expr.html">array repeat expression</a>, it must be standalone (as described below). That is, they are allowed in the following places:</p>
<ol>
<li>해당 아이템 시그니처의 일부를 형성하는 모든 타입에 적용된 상수로 사용될 때.</li>
<li><a href="items/associated-items.html#associated-constants">연관 상수</a>를 정의하는 데 사용되는 상수 표현식의 일부로 사용되거나, <a href="items/associated-items.html#associated-types">연관 타입</a>의 매개변수로 사용될 때.</li>
<li>해당 아이템 내 모든 함수의 본문에 있는 모든 런타임 표현식의 값으로 사용될 때.</li>
<li>해당 아이템 내 모든 함수의 본문에서 사용되는 모든 타입의 매개변수로 사용될 때.</li>
<li>해당 아이템 내 모든 필드의 타입의 일부로 사용될 때.</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 상수 제네릭 매개변수를 사용할 수 있는 예시.

// 아이템 자체의 시그니처에서 사용됨.
fn foo&lt;const N: usize&gt;(arr: [i32; N]) {
    // 함수 본문 내에서 타입으로 사용됨.
    let x: [i32; N];
    // 표현식으로 사용됩니다.
    println!("{}", N * 2);
}

// 구조체의 필드로 사용됨.
struct Foo&lt;const N: usize&gt;([i32; N]);

impl&lt;const N: usize&gt; Foo&lt;N&gt; {
    // 연관 상수로 사용됨.
    const CONST: usize = N * 4;
}

trait Trait {
    type Output;
}

impl&lt;const N: usize&gt; Trait for Foo&lt;N&gt; {
    // 연관 타입으로 사용됨.
    type Output = [i32; N];
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 상수 제네릭 매개변수를 사용할 수 없는 예시.
fn foo&lt;const N: usize&gt;() {
    // 함수 본문 내의 아이템 정의에서는 사용할 수 없음.
    const BAD_CONST: [usize; N] = [1; N];
    static BAD_STATIC: [usize; N] = [1; N];
    fn inner(bad_arg: [usize; N]) {
        let bad_value = N * 2;
    }
    type BadAlias = [usize; N];
    struct BadStruct([usize; N]);
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.generics.const.standalone] As a further restriction, const parameters may only appear as a standalone argument inside of a <a href="items/../types.html">type</a> or <a href="items/../expressions/array-expr.html">array repeat expression</a>. In those contexts, they may only be used as a single segment <a href="items/../expressions/path-expr.html">path expression</a>, possibly inside a <a href="items/../expressions/block-expr.html">block</a> (such as <code>N</code> or <code>{N}</code>). That is, they cannot be combined with other expressions.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 상수 매개변수를 사용할 수 없는 예시.

// 타입 내에서 다른 표현식과 결합하는 것은 허용되지 않습니다. 예를 들어
// 여기 반환 타입에 있는 산술 표현식과 같은 경우입니다.
fn bad_function&lt;const N: usize&gt;() -&gt; [u8; {N + 1}] {
    // 배열 반복 표현식에서도 마찬가지로 허용되지 않습니다.
    [1; {N + 1}]
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.generics.const.argument] A const argument in a <a href="items/../paths.html">path</a> specifies the const value to use for that item.</p>
<p>r[items.generics.const.argument.const-expr] The argument must either be an <a href="items/items.generics.const.inferred">inferred const</a> or be a <a href="items/../const_eval.html#constant-expressions">const expression</a> of the type ascribed to the const parameter. The const expression must be a <a href="items/../expressions/block-expr.html">block expression</a> (surrounded with braces) unless it is a single path segment (an [IDENTIFIER]) or a <a href="items/../expressions/literal-expr.html">literal</a> (with a possibly leading <code>-</code> token).</p>
<blockquote>
<p>[!NOTE] This syntactic restriction is necessary to avoid requiring infinite lookahead when parsing an expression inside of a type.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S&lt;const N: i64&gt;;
const C: i64 = 1;
fn f&lt;const N: i64&gt;() -&gt; S&lt;N&gt; { S }

let _ = f::&lt;1&gt;(); // Literal.
let _ = f::&lt;-1&gt;(); // Negative literal.
let _ = f::&lt;{ 1 + 2 }&gt;(); // Constant expression.
let _ = f::&lt;C&gt;(); // Single segment path.
let _ = f::&lt;{ C + 1 }&gt;(); // Constant expression.
let _: S&lt;1&gt; = f::&lt;_&gt;(); // Inferred const.
let _: S&lt;1&gt; = f::&lt;(((_)))&gt;(); // Inferred const.
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] In a generic argument list, an <a href="items/items.generics.const.inferred">inferred const</a> is parsed as an [inferred type][InferredType] but then semantically treated as a separate kind of <a href="items/items.generics.const.argument">const generic argument</a>.</p>
</blockquote>
<p>r[items.generics.const.inferred] Where a const argument is expected, an <code>_</code> (optionally surrounded by any number of matching parentheses), called the <em>inferred const</em> ([path rules][paths.expr.complex-const-params], [array expression rules][expr.array.length-restriction]), can be used instead. This asks the compiler to infer the const argument if possible based on surrounding information.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn make_buf&lt;const N: usize&gt;() -&gt; [u8; N] {
    [0; _]
    //  ^ Infers `N`.
}
let _: [u8; 1024] = make_buf::&lt;_&gt;();
//                             ^ Infers `1024`.
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] An <a href="items/items.generics.const.inferred">inferred const</a> is not semantically an [expression][Expression] and so is not accepted within braces.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;const N: usize&gt;() -&gt; [u8; N] { [0; _] }
let _: [_; 1] = f::&lt;{ _ }&gt;();
//                    ^ ERROR `_` not allowed here
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[items.generics.const.inferred.constraint] The inferred const cannot be used in item signatures.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;const N: usize&gt;(x: [u8; N]) -&gt; [u8; _] { x }
//                                       ^ ERROR not allowed
<span class="boring">}</span></code></pre></pre>
<p>r[items.generics.const.type-ambiguity] When there is ambiguity if a generic argument could be resolved as either a type or const argument, it is always resolved as a type. Placing the argument in a block expression can force it to be interpreted as a const argument.</p>
<!-- TODO: Rewrite the paragraph above to be in terms of namespaces, once
    namespaces are introduced, and it is clear which namespace each parameter
    lives in. -->
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type N = u32;
struct Foo&lt;const N: usize&gt;;
// 다음은 오류입니다. `N`이 타입 별칭 `N`으로 해석되기 때문입니다.
fn foo&lt;const N: usize&gt;() -&gt; Foo&lt;N&gt; { todo!() } // 오류
// 중괄호로 감싸서 강제로 상수 매개변수 `N`으로 해석되게 함으로써
// 해결할 수 있습니다.
fn bar&lt;const N: usize&gt;() -&gt; Foo&lt;{ N }&gt; { todo!() } // ok
<span class="boring">}</span></code></pre></pre>
<p>r[items.generics.const.variance] Unlike type and lifetime parameters, const parameters can be declared without being used inside of a parameterized item, with the exception of implementations as described in <a href="items/implementations.html#generic-implementations">generic implementations</a>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ok
struct Foo&lt;const N: usize&gt;;
enum Bar&lt;const M: usize&gt; { A, B }

// 오류: 사용되지 않은 매개변수
struct Baz&lt;T&gt;;
struct Biz&lt;'a&gt;;
struct Unconstrained;
impl&lt;const N: usize&gt; Unconstrained {}
<span class="boring">}</span></code></pre></pre>
<p>r[items.generics.const.exhaustiveness] When resolving a trait bound obligation, the exhaustiveness of all implementations of const parameters is not considered when determining if the bound is satisfied. For example, in the following, even though all possible const values for the <code>bool</code> type are implemented, it is still an error that the trait bound is not satisfied:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;const B: bool&gt;;
trait Bar {}
impl Bar for Foo&lt;true&gt; {}
impl Bar for Foo&lt;false&gt; {}

fn needs_bar(_: impl Bar) {}
fn generic&lt;const B: bool&gt;() {
    let v = Foo::&lt;B&gt;;
    needs_bar(v); // 오류: 트레잇 바운드 `Foo&lt;B&gt;: Bar`가 충족되지 않음
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.generics.where]</p>
<h2 id="where-절"><a class="header" href="#where-절">Where 절</a></h2>
<p>r[items.generics.where.syntax]</p>
<pre><code class="language-grammar items">WhereClause -&gt; `where` ( WhereClauseItem `,` )* WhereClauseItem?

WhereClauseItem -&gt;
      LifetimeWhereClauseItem
    | TypeBoundWhereClauseItem

LifetimeWhereClauseItem -&gt; Lifetime `:` LifetimeBounds

TypeBoundWhereClauseItem -&gt; ForLifetimes? Type `:` TypeParamBounds?
</code></pre>
<p>r[items.generics.where.intro] <em>Where clauses</em> provide another way to specify bounds on type and lifetime parameters as well as a way to specify bounds on types that aren’t type parameters.</p>
<p>r[items.generics.where.higher-ranked-lifetimes] The <code>for</code> keyword can be used to introduce <a href="items/../trait-bounds.html#higher-ranked-trait-bounds">higher-ranked lifetimes</a>. It only allows [LifetimeParam] parameters.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A&lt;T&gt;
where
    T: Iterator,            // 대신 A&lt;T: Iterator&gt;를 사용할 수 있습니다.
    T::Item: Copy,          // 연관 타입에 대한 바운드
    String: PartialEq&lt;T&gt;,   // 타입 매개변수를 사용하여 `String`에 대한 바운드 지정
    i32: Default,           // 허용되지만 유용하지는 않음
{
    f: T,
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.generics.attributes]</p>
<h2 id="속성"><a class="header" href="#속성">속성</a></h2>
<p>제네릭 라이프타임 및 타입 매개변수에는 <a href="items/../attributes.html">속성</a>을 붙일 수 있습니다. 이 위치에서 무언가를 수행하는 내장 속성은 없지만, 커스텀 derive 속성이 여기에 의미를 부여할 수 있습니다.</p>
<p>이 예시는 커스텀 derive 속성을 사용하여 제네릭 매개변수의 의미를 수정하는 방법을 보여줍니다.</p>
<!-- ignore: requires proc macro derive -->
<pre><code class="language-rust ignore">// MyFlexibleClone에 대한 derive가 `my_flexible_clone`을 이해할 수 있는
// 속성으로 선언했다고 가정합니다.
#[derive(MyFlexibleClone)]
struct Foo&lt;#[my_flexible_clone(unbounded)] H&gt; {
    a: *const H
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>r[items.associated]</p>
<h1 id="associated-items"><a class="header" href="#associated-items">Associated items</a></h1>
<p>r[items.associated.syntax]</p>
<pre><code class="language-grammar items">AssociatedItem -&gt;
    OuterAttribute* (
        MacroInvocationSemi
      | ( Visibility? ( TypeAlias | ConstantItem | Function ) )
    )
</code></pre>
<p>r[items.associated.intro] <em>Associated Items</em> are the items declared in <a href="items/traits.html">traits</a> or defined in <a href="items/implementations.html">implementations</a>. They are called this because they are defined on an associate type — the type in the implementation.</p>
<p>r[items.associated.kinds] They are a subset of the kinds of items you can declare in a module. Specifically, there are <a href="items/associated-items.html#associated-functions-and-methods">associated functions</a> (including methods), <a href="items/associated-items.html#associated-types">associated types</a>, and <a href="items/associated-items.html#associated-constants">associated constants</a>.</p>
<p>r[items.associated.related] Associated items are useful when the associated item is logically related to the associating item. For example, the <code>is_some</code> method on <code>Option</code> is intrinsically related to Options, so should be associated.</p>
<p>r[items.associated.decl-def] Every associated item kind comes in two varieties: definitions that contain the actual implementation and declarations that declare signatures for definitions.</p>
<p>r[items.associated.trait-items] It is the declarations that make up the contract of traits and what is available on generic types.</p>
<p>r[items.associated.fn]</p>
<h2 id="연관-함수와-메서드"><a class="header" href="#연관-함수와-메서드">연관 함수와 메서드</a></h2>
<p>r[items.associated.fn.intro] <em>Associated functions</em> are <a href="items/functions.html">functions</a> associated with a type.</p>
<p>r[items.associated.fn.decl] An <em>associated function declaration</em> declares a signature for an associated function definition. It is written as a function item, except the function body is replaced with a <code>;</code>.</p>
<p>r[items.associated.name] The identifier is the name of the function.</p>
<p>r[items.associated.same-signature] The generics, parameter list, return type, and where clause of the associated function must be the same as the associated function declarations’s.</p>
<p>r[items.associated.fn.def] An <em>associated function definition</em> defines a function associated with another type. It is written the same as a <a href="items/../types/function-item.html">function item</a>.</p>
<blockquote>
<p>[!NOTE] A common example is an associated function named <code>new</code> that returns a value of the type with which it is associated.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2024">struct Struct {
    field: i32
}

impl Struct {
    fn new() -&gt; Struct {
        Struct {
            field: 0i32
        }
    }
}

fn main () {
    let _struct = Struct::new();
}</code></pre></pre>
<p>r[items.associated.fn.qualified-self] When the associated function is declared on a trait, the function can also be called with a <a href="items/../paths.html">path</a> that is a path to the trait appended by the name of the trait. When this happens, it is substituted for <code>&lt;_ as Trait&gt;::function_name</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Num {
    fn from_i32(n: i32) -&gt; Self;
}

impl Num for f64 {
    fn from_i32(n: i32) -&gt; f64 { n as f64 }
}

// 이 경우 이 4가지는 모두 동일합니다.
let _: f64 = Num::from_i32(42);
let _: f64 = &lt;_ as Num&gt;::from_i32(42);
let _: f64 = &lt;f64 as Num&gt;::from_i32(42);
let _: f64 = f64::from_i32(42);
<span class="boring">}</span></code></pre></pre>
<p>r[items.associated.fn.method]</p>
<h3 id="메서드"><a class="header" href="#메서드">메서드</a></h3>
<p>r[items.associated.fn.method.intro] Associated functions whose first parameter is named <code>self</code> are called <em>methods</em> and may be invoked using the <a href="items/../expressions/method-call-expr.html">method call operator</a>, for example, <code>x.foo()</code>, as well as the usual function call notation.</p>
<p>r[items.associated.fn.method.self-ty] If the type of the <code>self</code> parameter is specified, it is limited to types resolving to one generated by the following grammar (where <code>'lt</code> denotes some arbitrary lifetime):</p>
<pre><code class="language-text">P = &amp;'lt S | &amp;'lt mut S | Box&lt;S&gt; | Rc&lt;S&gt; | Arc&lt;S&gt; | Pin&lt;P&gt;
S = Self | P
</code></pre>
<p>이 문법에서 <code>Self</code> 터미널(terminal)은 구현 타입으로 해석되는 타입을 나타냅니다. 여기에는 문맥적 타입 별칭 <code>Self</code>, 다른 타입 별칭, 또는 구현 타입으로 해석되는 연관 타입 투영(associated type projections)이 포함될 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::pin::Pin;
</span>// `Example` 구조체에 구현된 메서드의 예시.
struct Example;
type Alias = Example;
trait Trait { type Output; }
impl Trait for Example { type Output = Example; }
impl Example {
    fn by_value(self: Self) {}
    fn by_ref(self: &amp;Self) {}
    fn by_ref_mut(self: &amp;mut Self) {}
    fn by_box(self: Box&lt;Self&gt;) {}
    fn by_rc(self: Rc&lt;Self&gt;) {}
    fn by_arc(self: Arc&lt;Self&gt;) {}
    fn by_pin(self: Pin&lt;&amp;Self&gt;) {}
    fn explicit_type(self: Arc&lt;Example&gt;) {}
    fn with_lifetime&lt;'a&gt;(self: &amp;'a Self) {}
    fn nested&lt;'a&gt;(self: &amp;mut &amp;'a Arc&lt;Rc&lt;Box&lt;Alias&gt;&gt;&gt;) {}
    fn via_projection(self: &lt;Example as Trait&gt;::Output) {}
}
<span class="boring">}</span></code></pre></pre>
<p>r[associated.fn.method.self-pat-shorthands] Shorthand syntax can be used without specifying a type, which have the following equivalents:</p>
<div class="table-wrapper"><table><thead><tr><th>단축 구문</th><th>동등한 표현</th></tr></thead><tbody>
<tr><td><code>self</code></td><td><code>self: Self</code></td></tr>
<tr><td><code>&amp;'lifetime self</code></td><td><code>self: &amp;'lifetime Self</code></td></tr>
<tr><td><code>&amp;'lifetime mut self</code></td><td><code>self: &amp;'lifetime mut Self</code></td></tr>
</tbody></table>
</div>
<blockquote>
<p>[!NOTE] Lifetimes can be, and usually are, elided with this shorthand.</p>
</blockquote>
<p>r[associated.fn.method.self-pat-mut] If the <code>self</code> parameter is prefixed with <code>mut</code>, it becomes a mutable variable, similar to regular parameters using a <code>mut</code> <a href="items/../patterns.html#identifier-patterns">identifier pattern</a>. For example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Changer: Sized {
    fn change(mut self) {}
    fn modify(mut self: Box&lt;Self&gt;) {}
}
<span class="boring">}</span></code></pre></pre>
<p>트레잇의 메서드 예시는 다음과 같습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">type Surface = i32;
</span><span class="boring">type BoundingBox = i32;
</span>trait Shape {
    fn draw(&amp;self, surface: Surface);
    fn bounding_box(&amp;self) -&gt; BoundingBox;
}
<span class="boring">}</span></code></pre></pre>
<p>이것은 두 개의 메서드를 가진 트레잇을 정의합니다. 트레잇이 스코프 내에 있는 동안 이 트레잇의 <a href="items/implementations.html">구현</a>을 가진 모든 값은 <code>draw</code> 및 <code>bounding_box</code> 메서드를 호출할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">type Surface = i32;
</span><span class="boring">type BoundingBox = i32;
</span><span class="boring">trait Shape {
</span><span class="boring">    fn draw(&amp;self, surface: Surface);
</span><span class="boring">    fn bounding_box(&amp;self) -&gt; BoundingBox;
</span><span class="boring">}
</span><span class="boring">
</span>struct Circle {
    // ...
}

impl Shape for Circle {
    // ...
<span class="boring">  fn draw(&amp;self, _: Surface) {}
</span><span class="boring">  fn bounding_box(&amp;self) -&gt; BoundingBox { 0i32 }
</span>}

<span class="boring">impl Circle {
</span><span class="boring">    fn new() -&gt; Circle { Circle{} }
</span><span class="boring">}
</span><span class="boring">
</span>let circle_shape = Circle::new();
let bounding_box = circle_shape.bounding_box();
<span class="boring">}</span></code></pre></pre>
<p>r[items.associated.fn.params.edition2018]</p>
<blockquote>
<p>[!EDITION-2018] In the 2015 edition, it is possible to declare trait methods with anonymous parameters (e.g. <code>fn foo(u8)</code>). This is deprecated and an error as of the 2018 edition. All parameters must have an argument name.</p>
</blockquote>
<p>r[items.associated.fn.param-attributes]</p>
<h4 id="메서드-매개변수의-속성"><a class="header" href="#메서드-매개변수의-속성">메서드 매개변수의 속성</a></h4>
<p>메서드 매개변수의 속성은 <a href="items/functions.html#attributes-on-function-parameters">일반 함수 매개변수</a>와 동일한 규칙 및 제약 사항을 따릅니다.</p>
<p>r[items.associated.type]</p>
<h2 id="associated-types"><a class="header" href="#associated-types">Associated types</a></h2>
<p>r[items.associated.type.intro] <em>Associated types</em> are <a href="items/type-aliases.html">type aliases</a> associated with another type.</p>
<p>r[items.associated.type.restrictions] Associated types cannot be defined in <a href="items/implementations.html#inherent-implementations">inherent implementations</a> nor can they be given a default implementation in traits.</p>
<p>r[items.associated.type.decl] An <em>associated type declaration</em> declares a signature for associated type definitions. It is written in one of the following forms, where <code>Assoc</code> is the name of the associated type, <code>Params</code> is a comma-separated list of type, lifetime or const parameters, <code>Bounds</code> is a plus-separated list of trait bounds that the associated type must meet, and <code>WhereBounds</code> is a comma-separated list of bounds that the parameters must meet:</p>
<!-- ignore: illustrative example forms -->
<pre><code class="language-rust ignore">type Assoc;
type Assoc: Bounds;
type Assoc&lt;Params&gt;;
type Assoc&lt;Params&gt;: Bounds;
type Assoc&lt;Params&gt; where WhereBounds;
type Assoc&lt;Params&gt;: Bounds where WhereBounds;</code></pre>
<p>r[items.associated.type.name] The identifier is the name of the declared type alias.</p>
<p>r[items.associated.type.impl-fulfillment] The optional trait bounds must be fulfilled by the implementations of the type alias.</p>
<p>r[items.associated.type.sized] There is an implicit <a href="items/../special-types-and-traits.html#sized"><code>Sized</code></a> bound on associated types that can be relaxed using the special <code>?Sized</code> bound.</p>
<p>r[items.associated.type.def] An <em>associated type definition</em> defines a type alias for the implementation of a trait on a type.</p>
<p>r[items.associated.type.def.restriction] They are written similarly to an <em>associated type declaration</em>, but cannot contain <code>Bounds</code>, but instead must contain a <code>Type</code>:</p>
<!-- ignore: illustrative example forms -->
<pre><code class="language-rust ignore">type Assoc = Type;
type Assoc&lt;Params&gt; = Type; // 여기서 `Type` 타입은 `Params`를 참조할 수 있습니다
type Assoc&lt;Params&gt; = Type where WhereBounds;
type Assoc&lt;Params&gt; where WhereBounds = Type; // 사용 중단됨(deprecated), 위의 형식을 선호하세요</code></pre>
<p>r[items.associated.type.alias] If a type <code>Item</code> has an associated type <code>Assoc</code> from a trait <code>Trait</code>, then <code>&lt;Item as Trait&gt;::Assoc</code> is a type that is an alias of the type specified in the associated type definition.</p>
<p>r[items.associated.type.param] Furthermore, if <code>Item</code> is a type parameter, then <code>Item::Assoc</code> can be used in type parameters.</p>
<p>r[items.associated.type.generic] Associated types may include <a href="items/generics.html">generic parameters</a> and <a href="items/generics.html#where-clauses">where clauses</a>; these are often referred to as <em>generic associated types</em>, or <em>GATs</em>. If the type <code>Thing</code> has an associated type <code>Item</code> from a trait <code>Trait</code> with the generics <code>&lt;'a&gt;</code> , the type can be named like <code>&lt;Thing as Trait&gt;::Item&lt;'x&gt;</code>, where <code>'x</code> is some lifetime in scope. In this case, <code>'x</code> will be used wherever <code>'a</code> appears in the associated type definitions on impls.</p>
<pre><pre class="playground"><code class="language-rust edition2024">trait AssociatedType {
    // 연관 타입 선언
    type Assoc;
}

struct Struct;

struct OtherStruct;

impl AssociatedType for Struct {
    // 연관 타입 정의
    type Assoc = OtherStruct;
}

impl OtherStruct {
    fn new() -&gt; OtherStruct {
        OtherStruct
    }
}

fn main() {
    // &lt;Struct as AssociatedType&gt;::Assoc와 같이 OtherStruct를 참조하기 위해 연관 타입을 사용함
    let _other_struct: OtherStruct = &lt;Struct as AssociatedType&gt;::Assoc::new();
}</code></pre></pre>
<p>제네릭과 where 절을 사용한 연관 타입의 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024">struct ArrayLender&lt;'a, T&gt;(&amp;'a mut [T; 16]);

trait Lend {
    // 제네릭 연관 타입 선언
    type Lender&lt;'a&gt; where Self: 'a;
    fn lend&lt;'a&gt;(&amp;'a mut self) -&gt; Self::Lender&lt;'a&gt;;
}

impl&lt;T&gt; Lend for [T; 16] {
    // 제네릭 연관 타입 정의
    type Lender&lt;'a&gt; = ArrayLender&lt;'a, T&gt; where Self: 'a;

    fn lend&lt;'a&gt;(&amp;'a mut self) -&gt; Self::Lender&lt;'a&gt; {
        ArrayLender(self)
    }
}

fn borrow&lt;'a, T: Lend&gt;(array: &amp;'a mut T) -&gt; &lt;T as Lend&gt;::Lender&lt;'a&gt; {
    array.lend()
}

fn main() {
    let mut array = [0usize; 16];
    let lender = borrow(&amp;mut array);
}</code></pre></pre>
<h3 id="associated-types-container-example"><a class="header" href="#associated-types-container-example">Associated types container example</a></h3>
<p>다음 <code>Container</code> 트레잇 예시를 고려해 보세요. 해당 타입이 메서드 시그니처에서 사용 가능하다는 점에 주목하세요:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Container {
    type E;
    fn empty() -&gt; Self;
    fn insert(&amp;mut self, elem: Self::E);
}
<span class="boring">}</span></code></pre></pre>
<p>어떤 타입이 이 트레잇을 구현하기 위해서는, 모든 메서드에 대한 구현을 제공해야 할 뿐만 아니라 타입 <code>E</code>를 명시해야 합니다. 다음은 표준 라이브러리 타입 <code>Vec</code>에 대한 <code>Container</code> 구현입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Container {
</span><span class="boring">    type E;
</span><span class="boring">    fn empty() -&gt; Self;
</span><span class="boring">    fn insert(&amp;mut self, elem: Self::E);
</span><span class="boring">}
</span>impl&lt;T&gt; Container for Vec&lt;T&gt; {
    type E = T;
    fn empty() -&gt; Vec&lt;T&gt; { Vec::new() }
    fn insert(&amp;mut self, x: T) { self.push(x); }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="bounds와-wherebounds-사이의-관계"><a class="header" href="#bounds와-wherebounds-사이의-관계"><code>Bounds</code>와 <code>WhereBounds</code> 사이의 관계</a></h3>
<p>이 예시에서:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::fmt::Debug;
</span>trait Example {
    type Output&lt;T&gt;: Ord where T: Debug;
}
<span class="boring">}</span></code></pre></pre>
<p><code>&lt;X as Example&gt;::Output&lt;Y&gt;</code>와 같은 연관 타입에 대한 참조가 주어지면, 연관 타입 자체는 반드시 <code>Ord</code>여야 하고, 타입 <code>Y</code>는 반드시 <code>Debug</code>여야 합니다.</p>
<p>r[items.associated.type.generic-where-clause]</p>
<h3 id="제네릭-연관-타입에-요구되는-where-절"><a class="header" href="#제네릭-연관-타입에-요구되는-where-절">제네릭 연관 타입에 요구되는 where 절</a></h3>
<p>r[items.associated.type.generic-where-clause.intro] Generic associated type declarations on traits currently may require a list of where clauses, dependent on functions in the trait and how the GAT is used. These rules may be loosened in the future; updates can be found <a href="https://rust-lang.github.io/generic-associated-types-initiative/explainer/required_bounds.html">on the generic associated types initiative repository</a>.</p>
<p>r[items.associated.type.generic-where-clause.valid-fn] In a few words, these where clauses are required in order to maximize the allowed definitions of the associated type in impls. To do this, any clauses that <em>can be proven to hold</em> on functions (using the parameters of the function or trait) where a GAT appears as an input or output must also be written on the GAT itself.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait LendingIterator {
    type Item&lt;'x&gt; where Self: 'x;
    fn next&lt;'a&gt;(&amp;'a mut self) -&gt; Self::Item&lt;'a&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>위의 <code>next</code> 함수에서, <code>&amp;'a mut self</code>로부터 암시된 바운드 덕분에 <code>Self: 'a</code>임을 증명할 수 있습니다. 따라서 GAT 자체에 동일한 바운드인 <code>where Self: 'x</code>를 작성해야 합니다.</p>
<p>r[items.associated.type.generic-where-clause.intersection] When there are multiple functions in a trait that use the GAT, then the <em>intersection</em> of the bounds from the different functions are used, rather than the union.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Check&lt;T&gt; {
    type Checker&lt;'x&gt;;
    fn create_checker&lt;'a&gt;(item: &amp;'a T) -&gt; Self::Checker&lt;'a&gt;;
    fn do_check(checker: Self::Checker&lt;'_&gt;);
}
<span class="boring">}</span></code></pre></pre>
<p>이 예시에서는 <code>type Checker&lt;'a&gt;;</code>에 아무런 바운드가 요구되지 않습니다. <code>create_checker</code>에서는 <code>T: 'a</code>임을 알 수 있지만, <code>do_check</code>에서는 이를 알 수 없기 때문입니다. 하지만 만약 <code>do_check</code>가 주석 처리된다면, <code>Checker</code>에 <code>where T: 'x</code> 바운드가 요구될 것입니다.</p>
<p>r[items.associated.type.generic-where-clause.forward] The bounds on associated types also propagate required where clauses.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Iterable {
    type Item&lt;'a&gt; where Self: 'a;
    type Iterator&lt;'a&gt;: Iterator&lt;Item = Self::Item&lt;'a&gt;&gt; where Self: 'a;
    fn iter&lt;'a&gt;(&amp;'a self) -&gt; Self::Iterator&lt;'a&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>여기서 <code>iter</code> 때문에 <code>Item</code>에 <code>where Self: 'a</code>가 요구됩니다. 그런데 <code>Item</code>이 <code>Iterator</code>의 바운드에서 사용되므로, <code>where Self: 'a</code> 절이 거기서도 요구됩니다.</p>
<p>r[items.associated.type.generic-where-clause.static] Finally, any explicit uses of <code>'static</code> on GATs in the trait do not count towards the required bounds.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait StaticReturn {
    type Y&lt;'a&gt;;
    fn foo(&amp;self) -&gt; Self::Y&lt;'static&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>r[items.associated.const]</p>
<h2 id="associated-constants"><a class="header" href="#associated-constants">Associated constants</a></h2>
<p>r[items.associated.const.intro] <em>Associated constants</em> are <a href="items/constant-items.html">constants</a> associated with a type.</p>
<p>r[items.associated.const.decl] An <em>associated constant declaration</em> declares a signature for associated constant definitions. It is written as <code>const</code>, then an identifier, then <code>:</code>, then a type, finished by a <code>;</code>.</p>
<p>r[items.associated.const.name] The identifier is the name of the constant used in the path. The type is the type that the definition has to implement.</p>
<p>r[items.associated.const.def] An <em>associated constant definition</em> defines a constant associated with a type. It is written the same as a <a href="items/constant-items.html">constant item</a>.</p>
<p>r[items.associated.const.eval] Associated constant definitions undergo <a href="items/../const_eval.html">constant evaluation</a> only when referenced. Further, definitions that include <a href="items/generics.html">generic parameters</a> are evaluated after monomorphization.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024">struct Struct;
struct GenericStruct&lt;const ID: i32&gt;;

impl Struct {
    // 정의가 즉시 평가되지 않음
    const PANIC: () = panic!("컴파일 타임 패닉");
}

impl&lt;const ID: i32&gt; GenericStruct&lt;ID&gt; {
    // 정의가 즉시 평가되지 않음
    const NON_ZERO: () = if ID == 0 {
        panic!("모순")
    };
}

fn main() {
    // Struct::PANIC을 참조하면 컴파일 오류가 발생함
    let _ = Struct::PANIC;

    // 괜찮음, ID가 0이 아님
    let _ = GenericStruct::&lt;1&gt;::NON_ZERO;

    // ID=0으로 NON_ZERO를 평가할 때 발생하는 컴파일 오류
    let _ = GenericStruct::&lt;0&gt;::NON_ZERO;
}</code></pre></pre>
<h3 id="associated-constants-examples"><a class="header" href="#associated-constants-examples">Associated constants examples</a></h3>
<p>기본 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024">trait ConstantId {
    const ID: i32;
}

struct Struct;

impl ConstantId for Struct {
    const ID: i32 = 1;
}

fn main() {
    assert_eq!(1, Struct::ID);
}</code></pre></pre>
<p>기본값 사용하기:</p>
<pre><pre class="playground"><code class="language-rust edition2024">trait ConstantIdDefault {
    const ID: i32 = 1;
}

struct Struct;
struct OtherStruct;

impl ConstantIdDefault for Struct {}

impl ConstantIdDefault for OtherStruct {
    const ID: i32 = 5;
}

fn main() {
    assert_eq!(1, Struct::ID);
    assert_eq!(5, OtherStruct::ID);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p>r[attributes]</p>
<h1 id="속성-1"><a class="header" href="#속성-1">속성</a></h1>
<p>r[attributes.syntax]</p>
<pre><code class="language-grammar attributes">InnerAttribute -&gt; `#` `!` `[` Attr `]`

OuterAttribute -&gt; `#` `[` Attr `]`

Attr -&gt;
      SimplePath AttrInput?
    | `unsafe` `(` SimplePath AttrInput? `)`

AttrInput -&gt;
      DelimTokenTree
    | `=` Expression
</code></pre>
<p>r[attributes.intro] An <em>attribute</em> is a general, free-form metadatum that is interpreted according to name, convention, language, and compiler version. Attributes are modeled on Attributes in <a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-335/">ECMA-335</a>, with the syntax coming from <a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-334/">ECMA-334</a> (C#).</p>
<p>r[attributes.inner] <em>Inner attributes</em>, written with a bang (<code>!</code>) after the hash (<code>#</code>), apply to the form that the attribute is declared within.</p>
<blockquote>
<p>[!EXAMPLE]</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 둘러싼 모듈이나 크레이트에 적용되는 일반 메타데이터입니다.
#![crate_type = "lib"]

// 내부 속성은 함수 전체에 적용됩니다.
fn some_unused_variables() {
  #![allow(unused_variables)]

  let x = ();
  let y = ();
  let z = ();
}
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[attributes.outer] <em>Outer attributes</em>, written without the bang after the hash, apply to the form that follows the attribute.</p>
<blockquote>
<p>[!EXAMPLE]</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 유닛 테스트로 표시된 함수입니다.
#[test]
fn test_foo() {
    /* ... */
}

// 조건부 컴파일되는 모듈입니다.
#[cfg(target_os = "linux")]
mod bar {
    /* ... */
}

// 경고/오류를 억제하기 위해 사용되는 린트(lint) 속성입니다.
#[allow(non_camel_case_types)]
type int8_t = i8;
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[attributes.input] The attribute consists of a path to the attribute, followed by an optional delimited token tree whose interpretation is defined by the attribute. Attributes other than macro attributes also allow the input to be an equals sign (<code>=</code>) followed by an expression. See the <a href="attributes.html#meta-item-attribute-syntax">meta item syntax</a> below for more details.</p>
<p>r[attributes.safety] An attribute may be unsafe to apply. To avoid undefined behavior when using these attributes, certain obligations that cannot be checked by the compiler must be met.  To assert these have been, the attribute is wrapped in <code>unsafe(..)</code>, e.g. <code>#[unsafe(no_mangle)]</code>.</p>
<p>다음 속성들은 안전하지 않습니다:</p>
<ul>
<li><a href="abi.html#the-export_name-attribute"><code>export_name</code></a></li>
<li><a href="abi.html#the-link_section-attribute"><code>link_section</code></a></li>
<li><a href="attributes/codegen.html#the-naked-attribute"><code>naked</code></a></li>
<li><a href="abi.html#the-no_mangle-attribute"><code>no_mangle</code></a></li>
</ul>
<p>r[attributes.kind] Attributes can be classified into the following kinds:</p>
<ul>
<li><a href="attributes.html#built-in-attributes-index">내장 속성</a></li>
<li><a href="procedural-macros.html#the-proc_macro_attribute-attribute">Proc macro attributes</a></li>
<li><a href="procedural-macros.html#derive-macro-helper-attributes">Derive 매크로 도우미 속성</a></li>
<li><a href="attributes.html#tool-attributes">도구 속성</a></li>
</ul>
<p>r[attributes.allowed-position] Attributes may be applied to many forms in the language:</p>
<ul>
<li>모든 <a href="items.html">아이템 선언</a>은 외부 속성을 허용하며, <a href="items/external-blocks.html">외부 블록</a>, <a href="items/functions.html">함수</a>, <a href="items/implementations.html">구현</a>, <a href="items/modules.html">모듈</a>은 내부 속성을 허용합니다.</li>
<li>대부분의 <a href="statements.html">구문</a>은 외부 속성을 허용합니다 (표현식 구문에 대한 제약 사항은 <a href="expressions.html#expression-attributes">표현식 속성</a>을 참조하세요).</li>
<li><a href="expressions/block-expr.html">블록 표현식</a>은 외부 및 내부 속성을 허용하지만, <a href="statements.html#expression-statements">표현식 구문</a>의 외부 표현식이거나 다른 블록 표현식의 마지막 표현식인 경우에만 해당합니다.</li>
<li><a href="items/enumerations.html">열거형</a> 변형과 <a href="items/structs.html">구조체</a> 및 <a href="items/unions.html">공용체</a> 필드는 외부 속성을 허용합니다.</li>
<li><a href="expressions/match-expr.html">매치 표현식 암(Match expression arms)</a>은 외부 속성을 허용합니다.</li>
<li><a href="items/generics.html">제네릭 라이프타임 또는 타입 매개변수</a>는 외부 속성을 허용합니다.</li>
<li>표현식은 제한적인 상황에서 외부 속성을 허용합니다. 자세한 내용은 <a href="expressions.html#expression-attributes">표현식 속성</a>을 참조하세요.</li>
<li><a href="items/functions.html">함수</a>, <a href="expressions/closure-expr.html">클로저</a> 및 <a href="types/function-pointer.html">함수 포인터</a> 매개변수는 외부 속성을 허용합니다. 여기에는 함수 포인터와 <a href="items/external-blocks.html#variadic-functions">외부 블록</a>에서 <code>...</code>로 표시된 가변 매개변수에 대한 속성도 포함됩니다.</li>
<li><a href="inline-assembly.html">Inline assembly</a> template strings and operands accept outer attributes. Only certain attributes are accepted semantically; for details, see [asm.attributes.supported-attributes].</li>
</ul>
<p>r[attributes.meta]</p>
<h2 id="meta-item-attribute-syntax"><a class="header" href="#meta-item-attribute-syntax">Meta item attribute syntax</a></h2>
<p>r[attributes.meta.intro] A “meta item” is the syntax used for the [Attr] rule by most <a href="attributes.html#built-in-attributes-index">built-in attributes</a>. It has the following grammar:</p>
<p>r[attributes.meta.syntax]</p>
<pre><code class="language-grammar attributes">@root MetaItem -&gt;
      SimplePath
    | SimplePath `=` Expression
    | SimplePath `(` MetaSeq? `)`

MetaSeq -&gt;
    MetaItemInner ( `,` MetaItemInner )* `,`?

MetaItemInner -&gt;
      MetaItem
    | Expression
</code></pre>
<p>r[attributes.meta.literal-expr] Expressions in meta items must macro-expand to literal expressions, which must not include integer or float type suffixes. Expressions which are not literal expressions will be syntactically accepted (and can be passed to proc-macros), but will be rejected after parsing.</p>
<p>r[attributes.meta.order] Note that if the attribute appears within another macro, it will be expanded after that outer macro. For example, the following code will expand the <code>Serialize</code> proc-macro first, which must preserve the <code>include_str!</code> call in order for it to be expanded:</p>
<pre><code class="language-rust ignore">#[derive(Serialize)]
struct Foo {
    #[doc = include_str!("x.md")]
    x: u32
}</code></pre>
<p>r[attributes.meta.order-macro] Additionally, macros in attributes will be expanded only after all other attributes applied to the item:</p>
<pre><code class="language-rust ignore">#[macro_attr1] // 첫 번째로 확장됨
#[doc = mac!()] // `mac!`은 네 번째로 확장됨
#[macro_attr2] // 두 번째로 확장됨
#[derive(MacroDerive1, MacroDerive2)] // 세 번째로 확장됨
fn foo() {}</code></pre>
<p>r[attributes.meta.builtin] Various built-in attributes use different subsets of the meta item syntax to specify their inputs. The following grammar rules show some commonly used forms:</p>
<p>r[attributes.meta.builtin.syntax]</p>
<pre><code class="language-grammar attributes">@root MetaWord -&gt;
    IDENTIFIER

MetaNameValueStr -&gt;
    IDENTIFIER `=` (STRING_LITERAL | RAW_STRING_LITERAL)

@root MetaListPaths -&gt;
    IDENTIFIER `(` ( SimplePath (`,` SimplePath)* `,`? )? `)`

@root MetaListIdents -&gt;
    IDENTIFIER `(` ( IDENTIFIER (`,` IDENTIFIER)* `,`? )? `)`

@root MetaListNameValueStr -&gt;
    IDENTIFIER `(` ( MetaNameValueStr (`,` MetaNameValueStr)* `,`? )? `)`
</code></pre>
<p>메타 아이템의 몇 가지 예시는 다음과 같습니다:</p>
<div class="table-wrapper"><table><thead><tr><th>스타일</th><th>예시</th></tr></thead><tbody>
<tr><td>[MetaWord]</td><td><code>no_std</code></td></tr>
<tr><td>[MetaNameValueStr]</td><td><code>doc = "example"</code></td></tr>
<tr><td>[MetaListPaths]</td><td><code>allow(unused, clippy::inline_always)</code></td></tr>
<tr><td>[MetaListIdents]</td><td><code>macro_use(foo, bar)</code></td></tr>
<tr><td>[MetaListNameValueStr]</td><td><code>link(name = "CoreFoundation", kind = "framework")</code></td></tr>
</tbody></table>
</div>
<p>r[attributes.activity]</p>
<h2 id="활성-및-비활성-속성"><a class="header" href="#활성-및-비활성-속성">활성 및 비활성 속성</a></h2>
<p>r[attributes.activity.intro] An attribute is either active or inert. During attribute processing, <em>active attributes</em> remove themselves from the form they are on while <em>inert attributes</em> stay on.</p>
<p>The <a href="conditional-compilation.html#the-cfg-attribute"><code>cfg</code></a> and <a href="conditional-compilation.html#the-cfg_attr-attribute"><code>cfg_attr</code></a> attributes are active. <a href="procedural-macros.html#the-proc_macro_attribute-attribute">Attribute macros</a> are active. All other attributes are inert.</p>
<p>r[attributes.tool]</p>
<h2 id="도구-속성"><a class="header" href="#도구-속성">도구 속성</a></h2>
<p>r[attributes.tool.intro] The compiler may allow attributes for external tools where each tool resides in its own module in the <a href="names/preludes.html#tool-prelude">tool prelude</a>. The first segment of the attribute path is the name of the tool, with one or more additional segments whose interpretation is up to the tool.</p>
<p>r[attributes.tool.ignored] When a tool is not in use, the tool’s attributes are accepted without a warning. When the tool is in use, the tool is responsible for processing and interpretation of its attributes.</p>
<p>r[attributes.tool.prelude] Tool attributes are not available if the <a href="names/preludes.html#the-no_implicit_prelude-attribute"><code>no_implicit_prelude</code></a> attribute is used.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// rustfmt 도구에게 다음 요소를 포맷팅하지 않도록 지시합니다.
#[rustfmt::skip]
struct S {
}

// clippy 도구의 "순환 복잡도(cyclomatic complexity)" 임계값을 제어합니다.
#[clippy::cyclomatic_complexity = "100"]
pub fn f() {}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] <code>rustc</code> currently recognizes the tools “clippy”, “rustfmt”, “diagnostic”, “miri”, and “rust_analyzer”.</p>
</blockquote>
<p>r[attributes.builtin]</p>
<h2 id="내장-속성-색인"><a class="header" href="#내장-속성-색인">내장 속성 색인</a></h2>
<p>다음은 모든 내장 속성의 색인입니다.</p>
<ul>
<li>
<p>조건부 컴파일</p>
<ul>
<li><a href="conditional-compilation.html#the-cfg-attribute"><code>cfg</code></a> — 조건부 컴파일을 제어합니다.</li>
<li><a href="conditional-compilation.html#the-cfg_attr-attribute"><code>cfg_attr</code></a> — 속성을 조건부로 포함합니다.</li>
</ul>
</li>
<li>
<p>테스팅</p>
<ul>
<li><a href="attributes/testing.html#the-test-attribute"><code>test</code></a> — 함수를 테스트로 표시합니다.</li>
<li><a href="attributes/testing.html#the-ignore-attribute"><code>ignore</code></a> — 테스트 함수를 비활성화합니다.</li>
<li><a href="attributes/testing.html#the-should_panic-attribute"><code>should_panic</code></a> — 테스트가 패닉을 발생시켜야 함을 나타냅니다.</li>
</ul>
</li>
<li>
<p>파생</p>
<ul>
<li><a href="attributes/derive.html"><code>derive</code></a> — 트레잇 자동 구현.</li>
<li><a href="attributes/derive.html#the-automatically_derived-attribute"><code>automatically_derived</code></a> — <code>derive</code>에 의해 생성된 구현을 위한 마커입니다.</li>
</ul>
</li>
<li>
<p>매크로</p>
<ul>
<li><a href="macros-by-example.html#the-macro_export-attribute"><code>macro_export</code></a> — Exports a <code>macro_rules</code> macro for cross-crate usage.</li>
<li><a href="macros-by-example.html#the-macro_use-attribute"><code>macro_use</code></a> — 매크로 가시성을 확장하거나 다른 크레이트에서 매크로를 임포트합니다.</li>
<li><a href="procedural-macros.html#the-proc_macro-attribute"><code>proc_macro</code></a> — Defines a function-like macro.</li>
<li><a href="macro.proc.derive"><code>proc_macro_derive</code></a> — Defines a derive macro.</li>
<li><a href="procedural-macros.html#the-proc_macro_attribute-attribute"><code>proc_macro_attribute</code></a> — Defines an attribute macro.</li>
</ul>
</li>
<li>
<p>진단</p>
<ul>
<li><a href="attributes/diagnostics.html#lint-check-attributes"><code>allow</code></a>, <a href="attributes/diagnostics.html#lint-check-attributes"><code>expect</code></a>, <a href="attributes/diagnostics.html#lint-check-attributes"><code>warn</code></a>, <a href="attributes/diagnostics.html#lint-check-attributes"><code>deny</code></a>, <a href="attributes/diagnostics.html#lint-check-attributes"><code>forbid</code></a> — 기본 린트(lint) 레벨을 변경합니다.</li>
<li><a href="attributes/diagnostics.html#the-deprecated-attribute"><code>deprecated</code></a> — 사용 중단(deprecation) 공지를 생성합니다.</li>
<li><a href="attributes/diagnostics.html#the-must_use-attribute"><code>must_use</code></a> — 사용되지 않은 값에 대해 린트를 생성합니다.</li>
<li><a href="attributes/diagnostics.html#the-diagnosticon_unimplemented-attribute"><code>diagnostic::on_unimplemented</code></a> — 트레잇이 구현되지 않은 경우 특정 에러 메시지를 내보내도록 컴파일러에 힌트를 줍니다.</li>
<li><a href="attributes/diagnostics.html#the-diagnosticdo_not_recommend-attribute"><code>diagnostic::do_not_recommend</code></a> — 에러 메시지에서 특정 트레잇 구현을 표시하지 않도록 컴파일러에 힌트를 줍니다.</li>
</ul>
</li>
<li>
<p>ABI, 링크, 심볼 및 FFI</p>
<ul>
<li><a href="items/external-blocks.html#the-link-attribute"><code>link</code></a> — <code>extern</code> 블록과 링크할 네이티브 라이브러리를 지정합니다.</li>
<li><a href="items/external-blocks.html#the-link_name-attribute"><code>link_name</code></a> — <code>extern</code> 블록 내의 함수나 정적 아이템을 위한 심볼 이름을 지정합니다.</li>
<li><a href="items/external-blocks.html#the-link_ordinal-attribute"><code>link_ordinal</code></a> — <code>extern</code> 블록 내의 함수나 정적 아이템을 위한 심볼의 오디널(ordinal)을 지정합니다.</li>
<li><a href="items/extern-crates.html#the-no_link-attribute"><code>no_link</code></a> — 외부 크레이트가 링크되는 것을 방지합니다.</li>
<li><a href="type-layout.html#representations"><code>repr</code></a> — 타입 레이아웃을 제어합니다.</li>
<li><a href="linkage.html"><code>crate_type</code></a> — 크레이트의 종류(라이브러리, 실행 파일 등)를 지정합니다.</li>
<li><a href="crates-and-source-files.html#the-no_main-attribute"><code>no_main</code></a> — <code>main</code> 심볼 내보내기를 비활성화합니다.</li>
<li><a href="abi.html#the-export_name-attribute"><code>export_name</code></a> — 함수나 정적 아이템에 대해 내보낼 심볼 이름을 지정합니다.</li>
<li><a href="abi.html#the-link_section-attribute"><code>link_section</code></a> — 함수나 정적 아이템에 사용할 객체 파일의 섹션을 지정합니다.</li>
<li><a href="abi.html#the-no_mangle-attribute"><code>no_mangle</code></a> — 심볼 이름 인코딩(mangling)을 비활성화합니다.</li>
<li><a href="abi.html#the-used-attribute"><code>used</code></a> — 컴파일러가 출력 객체 파일에서 정적 아이템을 유지하도록 강제합니다.</li>
<li><a href="crates-and-source-files.html#the-crate_name-attribute"><code>crate_name</code></a> — 크레이트 이름을 지정합니다.</li>
</ul>
</li>
<li>
<p>코드 생성</p>
<ul>
<li><a href="attributes/codegen.html#the-inline-attribute"><code>inline</code></a> — 코드 인라이닝에 대한 힌트입니다.</li>
<li><a href="attributes/codegen.html#the-cold-attribute"><code>cold</code></a> — 함수가 거의 호출되지 않을 것임을 나타내는 힌트입니다.</li>
<li><a href="attributes/codegen.html#the-naked-attribute"><code>naked</code></a> — Prevent the compiler from emitting a function prologue and epilogue.</li>
<li><a href="attributes/codegen.html#the-no_builtins-attribute"><code>no_builtins</code></a> — 특정 내장 함수들의 사용을 비활성화합니다.</li>
<li><a href="attributes/codegen.html#the-target_feature-attribute"><code>target_feature</code></a> — 플랫폼별 코드 생성을 구성합니다.</li>
<li><a href="attributes/codegen.html#the-track_caller-attribute"><code>track_caller</code></a> — 부모 호출 위치를 <code>std::panic::Location::caller()</code>로 전달합니다.</li>
<li><a href="attributes/codegen.html#the-instruction_set-attribute"><code>instruction_set</code></a> — Specify the instruction set used to generate a function’s code.</li>
</ul>
</li>
<li>
<p>문서화</p>
<ul>
<li><code>doc</code> — 문서를 지정합니다. 자세한 내용은 <a href="../rustdoc/the-doc-attribute.html">Rustdoc 책</a>을 참조하세요. <a href="comments.html#doc-comments">문서 주석</a>은 <code>doc</code> 속성으로 변환됩니다.</li>
</ul>
</li>
<li>
<p>프렐류드</p>
<ul>
<li><a href="names/preludes.html#the-no_std-attribute"><code>no_std</code></a> — 프렐류드에서 std를 제거합니다.</li>
<li><a href="names/preludes.html#the-no_implicit_prelude-attribute"><code>no_implicit_prelude</code></a> — 모듈 내에서 프렐류드 조회를 비활성화합니다.</li>
</ul>
</li>
<li>
<p>모듈</p>
<ul>
<li><a href="items/modules.html#the-path-attribute"><code>path</code></a> — 모듈의 파일 이름을 지정합니다.</li>
</ul>
</li>
<li>
<p>제한</p>
<ul>
<li><a href="attributes/limits.html#the-recursion_limit-attribute"><code>recursion_limit</code></a> — 특정 컴파일 타임 연산에 대한 최대 재귀 한도를 설정합니다.</li>
<li><a href="attributes/limits.html#the-type_length_limit-attribute"><code>type_length_limit</code></a> — 다형성 타입(polymorphic type)의 최대 크기를 설정합니다.</li>
</ul>
</li>
<li>
<p>런타임</p>
<ul>
<li><a href="panic.html#the-panic_handler-attribute"><code>panic_handler</code></a> — Sets the function to handle panics.</li>
<li><a href="runtime.html#the-global_allocator-attribute"><code>global_allocator</code></a> — 전역 메모리 할당자를 설정합니다.</li>
<li><a href="runtime.html#the-windows_subsystem-attribute"><code>windows_subsystem</code></a> — 링크할 Windows 하위 시스템을 지정합니다.</li>
</ul>
</li>
<li>
<p>기능(Features)</p>
<ul>
<li><code>feature</code> — 불안정하거나 실험적인 컴파일러 기능을 활성화하는 데 사용됩니다. <code>rustc</code>에 구현된 기능들에 대해서는 <a href="../unstable-book/index.html">Unstable Book</a>을 참조하세요.</li>
</ul>
</li>
<li>
<p>타입 시스템</p>
<ul>
<li><a href="attributes/type_system.html#the-non_exhaustive-attribute"><code>non_exhaustive</code></a> — 미래에 타입에 더 많은 필드나 변형이 추가될 것임을 나타냅니다.</li>
</ul>
</li>
<li>
<p>디버거</p>
<ul>
<li><a href="attributes/debugger.html#the-debugger_visualizer-attribute"><code>debugger_visualizer</code></a> — 타입에 대한 디버거 출력을 지정하는 파일을 포함시킵니다.</li>
<li><a href="attributes/debugger.html#the-collapse_debuginfo-attribute"><code>collapse_debuginfo</code></a> — 디버그 정보에서 매크로 호출이 인코딩되는 방식을 제어합니다.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>r[attributes.testing]</p>
<h1 id="테스팅-속성"><a class="header" href="#테스팅-속성">테스팅 속성</a></h1>
<p>다음 <a href="attributes/../attributes.html">속성들</a>은 테스트를 수행하기 위한 함수를 지정하는 데 사용됩니다. 크레이트를 “test” 모드로 컴파일하면 테스트를 실행하기 위한 테스트 하네스와 함께 테스트 함수들이 빌드됩니다. 테스트 모드를 활성화하면 <a href="attributes/../conditional-compilation.html#test"><code>test</code> 조건부 컴파일 옵션</a>도 활성화됩니다.</p>
<!-- template:attributes -->
<p>r[attributes.testing.test]</p>
<h2 id="test-속성"><a class="header" href="#test-속성"><code>test</code> 속성</a></h2>
<p>r[attributes.testing.test.intro] The <em><code>test</code> <a href="attributes/../attributes.html">attribute</a></em> marks a function to be executed as a test.</p>
<blockquote>
<p>[!EXAMPLE]</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub fn add(left: u64, right: u64) -&gt; u64 { left + right }
</span>#[test]
fn it_works() {
    let result = add(2, 2);
    assert_eq!(result, 4);
}
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[attributes.testing.test.syntax] The <code>test</code> attribute uses the [MetaWord] syntax.</p>
<p>r[attributes.testing.test.allowed-positions] The <code>test</code> attribute may only be applied to <a href="attributes/../glossary.html#free-item">free functions</a> that are monomorphic, that take no arguments, and where the return type implements the <a href="std::process::Termination"><code>Termination</code></a> trait.</p>
<blockquote>
<p>[!NOTE] Some of types that implement the <a href="std::process::Termination"><code>Termination</code></a> trait include:</p>
<ul>
<li><code>()</code></li>
<li><code>Result&lt;T, E&gt; where T: Termination, E: Debug</code></li>
</ul>
</blockquote>
<p>r[attributes.testing.test.duplicates] Only the first use of <code>test</code> on a function has effect.</p>
<blockquote>
<p>[!NOTE] <code>rustc</code> lints against any use following the first. This may become an error in the future.</p>
</blockquote>
<!-- TODO: This is a minor lie. Currently rustc warns that duplicates are ignored, but it then generates multiple test entries with the same name. I would vote for rejecting this in the future. -->
<p>r[attributes.testing.test.stdlib] The <code>test</code> attribute is exported from the standard library prelude as [<code>std::prelude::v1::test</code>].</p>
<p>r[attributes.testing.test.enabled] These functions are only compiled when in test mode.</p>
<blockquote>
<p>[!NOTE] The test mode is enabled by passing the <code>--test</code> argument to <code>rustc</code> or using <code>cargo test</code>.</p>
</blockquote>
<p>r[attributes.testing.test.success] The test harness calls the returned value’s <a href="std::process::Termination::report"><code>report</code></a> method, and classifies the test as passed or failed depending on whether the resulting <a href="std::process::ExitCode"><code>ExitCode</code></a> represents successful termination. In particular:</p>
<ul>
<li><code>()</code>를 반환하는 테스트는 종료되고 패닉이 발생하지 않는 한 통과합니다.</li>
<li><code>Result&lt;(), E&gt;</code>를 반환하는 테스트는 <code>Ok(())</code>를 반환하는 한 통과합니다.</li>
<li><code>ExitCode::SUCCESS</code>를 반환하는 테스트는 통과하고, <code>ExitCode::FAILURE</code>를 반환하는 테스트는 실패합니다.</li>
<li>종료되지 않는 테스트는 통과도 실패도 하지 않습니다.</li>
</ul>
<blockquote>
<p>[!EXAMPLE]</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::io;
</span><span class="boring">fn setup_the_thing() -&gt; io::Result&lt;i32&gt; { Ok(1) }
</span><span class="boring">fn do_the_thing(s: &amp;i32) -&gt; io::Result&lt;()&gt; { Ok(()) }
</span>#[test]
fn test_the_thing() -&gt; io::Result&lt;()&gt; {
    let state = setup_the_thing()?; // 성공할 것으로 예상됨
    do_the_thing(&amp;state)?;          // 성공할 것으로 예상됨
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
</blockquote>
<!-- template:attributes -->
<p>r[attributes.testing.ignore]</p>
<h2 id="ignore-속성"><a class="header" href="#ignore-속성"><code>ignore</code> 속성</a></h2>
<p>r[attributes.testing.ignore.intro] The <em><code>ignore</code> <a href="attributes/../attributes.html">attribute</a></em> can be used with the [<code>test</code> attribute][attributes.testing.test] to tell the test harness to not execute that function as a test.</p>
<blockquote>
<p>[!EXAMPLE]</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
#[ignore]
fn check_thing() {
    // …
}
<span class="boring">}</span></code></pre></pre>
</blockquote>
<blockquote>
<p>[!NOTE] The <code>rustc</code> test harness supports the <code>--include-ignored</code> flag to force ignored tests to be run.</p>
</blockquote>
<p>r[attributes.testing.ignore.syntax] The <code>ignore</code> attribute uses the [MetaWord] and [MetaNameValueStr] syntaxes.</p>
<p>r[attributes.testing.ignore.reason] The [MetaNameValueStr] form of the <code>ignore</code> attribute provides a way to specify a reason why the test is ignored.</p>
<blockquote>
<p>[!EXAMPLE]</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
#[ignore = "아직 구현되지 않음"]
fn mytest() {
    // …
}
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[attributes.testing.ignore.allowed-positions] The <code>ignore</code> attribute may only be applied to functions annotated with the <code>test</code> attribute.</p>
<blockquote>
<p>[!NOTE] <code>rustc</code> ignores use in other positions but lints against it. This may become an error in the future.</p>
</blockquote>
<p>r[attributes.testing.ignore.duplicates] Only the first use of <code>ignore</code> on a function has effect.</p>
<blockquote>
<p>[!NOTE] <code>rustc</code> lints against any use following the first. This may become an error in the future.</p>
</blockquote>
<p>r[attributes.testing.ignore.behavior] Ignored tests are still compiled when in test mode, but they are not executed.</p>
<!-- template:attributes -->
<p>r[attributes.testing.should_panic]</p>
<h2 id="should_panic-속성"><a class="header" href="#should_panic-속성"><code>should_panic</code> 속성</a></h2>
<p>r[attributes.testing.should_panic.intro] The <em><code>should_panic</code> <a href="attributes/../attributes.html">attribute</a></em> causes a test to pass only if the [test function][attributes.testing.test] to which the attribute is applied panics.</p>
<blockquote>
<p>[!EXAMPLE]</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
#[should_panic(expected = "값들이 일치하지 않음")]
fn mytest() {
    assert_eq!(1, 2, "값들이 일치하지 않음");
}
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[attributes.testing.should_panic.syntax] The <code>should_panic</code> attribute has these forms:</p>
<ul>
<li>
<p>[MetaWord]</p>
<blockquote>
<p>[!EXAMPLE]</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
#[should_panic]
fn mytest() { panic!("error: some message, and more"); }
<span class="boring">}</span></code></pre></pre>
</blockquote>
</li>
<li>
<p>[MetaNameValueStr] — The given string must appear within the panic message for the test to pass.</p>
<blockquote>
<p>[!EXAMPLE]</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
#[should_panic = "some message"]
fn mytest() { panic!("error: some message, and more"); }
<span class="boring">}</span></code></pre></pre>
</blockquote>
</li>
<li>
<p>[MetaListNameValueStr] — As with the [MetaNameValueStr] syntax, the given string must appear within the panic message.</p>
<blockquote>
<p>[!EXAMPLE]</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
#[should_panic(expected = "some message")]
fn mytest() { panic!("error: some message, and more"); }
<span class="boring">}</span></code></pre></pre>
</blockquote>
</li>
</ul>
<p>r[attributes.testing.should_panic.allowed-positions] The <code>should_panic</code> attribute may only be applied to functions annotated with the <code>test</code> attribute.</p>
<blockquote>
<p>[!NOTE] <code>rustc</code> ignores use in other positions but lints against it. This may become an error in the future.</p>
</blockquote>
<p>r[attributes.testing.should_panic.duplicates] Only the first use of <code>should_panic</code> on a function has effect.</p>
<blockquote>
<p>[!NOTE] <code>rustc</code> lints against any use following the first with a future-compatibility warning. This may become an error in the future.</p>
</blockquote>
<p>r[attributes.testing.should_panic.expected] When the [MetaNameValueStr] form or the [MetaListNameValueStr] form with the <code>expected</code> key is used, the given string must appear somewhere within the panic message for the test to pass.</p>
<p>r[attributes.testing.should_panic.return] The return type of the test function must be <code>()</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- template:attributes -->
<p>r[attributes.derive]</p>
<h1 id="파생"><a class="header" href="#파생">파생</a></h1>
<p>r[attributes.derive.intro] The <em><code>derive</code> [attribute][attributes]</em> invokes one or more <a href="attributes/macro.proc.derive">derive macros</a>, allowing new <a href="attributes/../items.html">items</a> to be automatically generated for data structures. You can create <code>derive</code> macros with <a href="attributes/macro.proc.derive">procedural macros</a>.</p>
<blockquote>
<p>[!EXAMPLE] The [<code>PartialEq</code>][macro@PartialEq] derive macro emits an <a href="attributes/../items/implementations.html">implementation</a> of [<code>PartialEq</code>] for <code>Foo&lt;T&gt; where T: PartialEq</code>. The [<code>Clone</code>][macro@Clone] derive macro does likewise for [<code>Clone</code>].</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(PartialEq, Clone)]
struct Foo&lt;T&gt; {
    a: i32,
    b: T,
}
<span class="boring">}</span></code></pre></pre>
<p>The generated <code>impl</code> items are equivalent to:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Foo&lt;T&gt; { a: i32, b: T }
</span>impl&lt;T: PartialEq&gt; PartialEq for Foo&lt;T&gt; {
    fn eq(&amp;self, other: &amp;Foo&lt;T&gt;) -&gt; bool {
        self.a == other.a &amp;&amp; self.b == other.b
    }
}

impl&lt;T: Clone&gt; Clone for Foo&lt;T&gt; {
    fn clone(&amp;self) -&gt; Self {
        Foo { a: self.a.clone(), b: self.b.clone() }
    }
}
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[attributes.derive.syntax] The <code>derive</code> attribute uses the [MetaListPaths] syntax to specify a list of paths to <a href="attributes/macro.proc.derive">derive macros</a> to invoke.</p>
<p>r[attributes.derive.allowed-positions] The <code>derive</code> attribute may only be applied to [structs][items.struct], [enums][items.enum], and [unions][items.union].</p>
<p>r[attributes.derive.duplicates] The <code>derive</code> attribute may be used any number of times on an item. All derive macros listed in all attributes are invoked.</p>
<p>r[attributes.derive.stdlib] The <code>derive</code> attribute is exported in the standard library prelude as [<code>core::prelude::v1::derive</code>].</p>
<p>r[attributes.derive.built-in] Built-in derives are defined in the [language prelude][names.preludes.lang]. The list of built-in derives are:</p>
<ul>
<li>[<code>Clone</code>]</li>
<li>[<code>Copy</code>]</li>
<li>[<code>Debug</code>]</li>
<li>[<code>Default</code>]</li>
<li>[<code>Eq</code>]</li>
<li>[<code>Hash</code>]</li>
<li>[<code>Ord</code>]</li>
<li>[<code>PartialEq</code>]</li>
<li>[<code>PartialOrd</code>]</li>
</ul>
<p>r[attributes.derive.built-in-automatically_derived] The built-in derives include the [<code>automatically_derived</code> attribute][attributes.derive.automatically_derived] on the implementations they generate.</p>
<p>r[attributes.derive.behavior] During macro expansion, for each element in the list of derives, the corresponding derive macro expands to zero or more <a href="attributes/../items.html">items</a>.</p>
<!-- template:attributes -->
<p>r[attributes.derive.automatically_derived]</p>
<h2 id="automatically_derived-속성"><a class="header" href="#automatically_derived-속성"><code>automatically_derived</code> 속성</a></h2>
<p>r[attributes.derive.automatically_derived.intro] The <em><code>automatically_derived</code> [attribute][attributes]</em> is used to annotate an <a href="attributes/../items/implementations.html">implementation</a> to indicate that it was automatically created by a <a href="attributes/macro.proc.derive">derive macro</a>. It has no direct effect, but it may be used by tools and diagnostic lints to detect these automatically generated implementations.</p>
<blockquote>
<p>[!EXAMPLE] Given [<code>#[derive(Clone)]</code>][macro@Clone] on <code>struct Example</code>, the <a href="attributes/macro.proc.derive">derive macro</a> may produce:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Example;
</span>#[automatically_derived]
impl ::core::clone::Clone for Example {
    #[inline]
    fn clone(&amp;self) -&gt; Self {
        Example
    }
}
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[attributes.derive.automatically_derived.syntax] The <code>automatically_derived</code> attribute uses the [MetaWord] syntax.</p>
<p>r[attributes.derive.automatically_derived.allowed-positions] The <code>automatically_derived</code> attribute may only be applied to an <a href="attributes/../items/implementations.html">implementation</a>.</p>
<blockquote>
<p>[!NOTE] <code>rustc</code> ignores use in other positions but lints against it. This may become an error in the future.</p>
</blockquote>
<p>r[attributes.derive.automatically_derived.duplicates] Using <code>automatically_derived</code> more than once on an implementation has the same effect as using it once.</p>
<blockquote>
<p>[!NOTE] <code>rustc</code> lints against any use following the first.</p>
</blockquote>
<p>r[attributes.derive.automatically_derived.behavior] The <code>automatically_derived</code> attribute has no behavior.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[attributes.diagnostics]</p>
<h1 id="진단-속성"><a class="header" href="#진단-속성">진단 속성</a></h1>
<p>다음 <a href="attributes/../attributes.html">속성들</a>은 컴파일 중에 진단 메시지를 제어하거나 생성하는 데 사용됩니다.</p>
<p>r[attributes.diagnostics.lint]</p>
<h2 id="린트lint-체크-속성"><a class="header" href="#린트lint-체크-속성">린트(Lint) 체크 속성</a></h2>
<p>린트 체크는 도달할 수 없는 코드나 누락된 문서와 같이 잠재적으로 바람직하지 않은 코딩 패턴을 지적합니다.</p>
<p>r[attributes.diagnostics.lint.level] The lint attributes <code>allow</code>, <code>expect</code>, <code>warn</code>, <code>deny</code>, and <code>forbid</code> use the [MetaListPaths] syntax to specify a list of lint names to change the lint level for the entity to which the attribute applies.</p>
<p>임의의 린트 체크 <code>C</code>에 대해:</p>
<p>r[attributes.diagnostics.lint.allow]</p>
<ul>
<li><code>#[allow(C)]</code>는 <code>C</code>에 대한 체크를 무시하여 위반 사항이 보고되지 않도록 합니다.</li>
</ul>
<p>r[attributes.diagnostics.lint.expect]</p>
<ul>
<li><code>#[expect(C)]</code>는 린트 <code>C</code>가 발생할 것으로 예상됨을 나타냅니다. 이 속성은 <code>C</code>의 발생을 억제하거나, 예상이 충족되지 않은 경우 경고를 발생시킵니다.</li>
</ul>
<p>r[attributes.diagnostics.lint.warn]</p>
<ul>
<li><code>#[warn(C)]</code>는 <code>C</code> 위반에 대해 경고하지만 컴파일을 계속합니다.</li>
</ul>
<p>r[attributes.diagnostics.lint.deny]</p>
<ul>
<li><code>#[deny(C)]</code>는 <code>C</code> 위반을 발견하면 에러를 발생시킵니다.</li>
</ul>
<p>r[attributes.diagnostics.lint.forbid]</p>
<ul>
<li><code>#[forbid(C)]</code>는 <code>deny(C)</code>와 동일하지만, 이후에 린트 레벨을 변경하는 것도 금지합니다.</li>
</ul>
<blockquote>
<p>[!NOTE] The lint checks supported by <code>rustc</code> can be found via <code>rustc -W help</code>, along with their default settings and are documented in the <a href="attributes/../../rustc/lints/index.html">rustc book</a>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod m1 {
    // 여기서 누락된 문서는 무시됩니다.
    #[allow(missing_docs)]
    pub fn undocumented_one() -&gt; i32 { 1 }

    // 여기서 누락된 문서는 경고를 발생시킵니다.
    #[warn(missing_docs)]
    pub fn undocumented_too() -&gt; i32 { 2 }

    // 여기서 누락된 문서는 에러를 발생시킵니다.
    #[deny(missing_docs)]
    pub fn undocumented_end() -&gt; i32 { 3 }
}
<span class="boring">}</span></code></pre></pre>
<p>r[attributes.diagnostics.lint.override] Lint attributes can override the level specified from a previous attribute, as long as the level does not attempt to change a forbidden lint (except for <code>deny</code>, which is allowed inside a <code>forbid</code> context, but ignored). Previous attributes are those from a higher level in the syntax tree, or from a previous attribute on the same entity as listed in left-to-right source order.</p>
<p>이 예시는 <code>allow</code>와 <code>warn</code>을 사용하여 특정 체크를 켜고 끄는 방법을 보여줍니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[warn(missing_docs)]
pub mod m2 {
    #[allow(missing_docs)]
    pub mod nested {
        // 여기서 누락된 문서는 무시됩니다.
        pub fn undocumented_one() -&gt; i32 { 1 }

        // 위의 allow에도 불구하고,
        // 여기서 누락된 문서는 경고를 발생시킵니다.
        #[warn(missing_docs)]
        pub fn undocumented_two() -&gt; i32 { 2 }
    }

    // 여기서 누락된 문서는 경고를 발생시킵니다.
    pub fn undocumented_too() -&gt; i32 { 3 }
}
<span class="boring">}</span></code></pre></pre>
<p>이 예시는 특정 린트 체크에 대해 <code>allow</code>나 <code>expect</code>를 사용하는 것을 금지하기 위해 <code>forbid</code>를 사용하는 방법을 보여줍니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[forbid(missing_docs)]
pub mod m3 {
    // 경고를 토글하려고 시도하면 여기서 에러가 발생합니다.
    #[allow(missing_docs)]
    /// 2를 반환합니다.
    pub fn undocumented_too() -&gt; i32 { 2 }
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] <code>rustc</code> allows setting lint levels on the <a href="attributes/../../rustc/lints/levels.html#via-compiler-flag">command-line</a>, and also supports <a href="attributes/../../rustc/lints/levels.html#capping-lints">setting caps</a> on the lints that are reported.</p>
</blockquote>
<p>r[attributes.diagnostics.lint.reason]</p>
<h3 id="lint-reasons"><a class="header" href="#lint-reasons">Lint reasons</a></h3>
<p>모든 린트 속성은 특정 속성이 추가된 이유에 대한 문맥을 제공하기 위해 추가적인 <code>reason</code> 매개변수를 지원합니다. 이 사유는 린트가 정의된 레벨에서 내보내질 때 린트 메시지의 일부로 표시됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2015 compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `keyword_idents`는 기본적으로 허용됩니다. 여기서는 에디션을 업데이트할 때
// 식별자 마이그레이션을 피하기 위해 이를 거부(deny)합니다.
#![deny(
    keyword_idents,
    reason = "미래 호환성을 위해 이러한 식별자들을 피하고 싶습니다"
)]

// 이 이름은 Rust 2015 에디션에서 허용되었습니다. 우리는 여전히 피하고자 합니다
// 미래 호환성을 확보하고 최종 사용자에게 혼란을 주지 않기 위함입니다.
fn dyn() {}
<span class="boring">}</span></code></pre></pre>
<p>사유와 함께 린트를 허용한 또 다른 예시입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::path::PathBuf;

pub fn get_path() -&gt; PathBuf {
    // `allow` 속성의 `reason` 매개변수는 독자를 위한 문서 역할을 합니다.
    #[allow(unused_mut, reason = "이것은 일부 플랫폼에서만 수정됩니다")]
    let mut file_name = PathBuf::from("git");

    #[cfg(target_os = "windows")]
    file_name.set_extension("exe");

    file_name
}
<span class="boring">}</span></code></pre></pre>
<p>r[attributes.diagnostics.expect]</p>
<h3 id="expect-속성"><a class="header" href="#expect-속성"><code>#[expect]</code> 속성</a></h3>
<p>r[attributes.diagnostics.expect.intro] The <code>#[expect(C)]</code> attribute creates a lint expectation for lint <code>C</code>. The expectation will be fulfilled, if a <code>#[warn(C)]</code> attribute at the same location would result in a lint emission. If the expectation is unfulfilled, because lint <code>C</code> would not be emitted, the <code>unfulfilled_lint_expectations</code> lint will be emitted at the attribute.</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    // 이 `#[expect]` 속성은 `unused_variables` 린트가 다음 문장에서 발생할 것이라는
    // 린트 기대를 생성합니다. `question` 변수가 `println!` 매크로에 의해
    // 사용되므로 이 기대는 충족되지 않습니다. 따라서 해당 속성 위치에서
    // `unfulfilled_lint_expectations` 린트가 발생합니다.
    #[expect(unused_variables)]
    let question = "누가 바다 저 깊은 곳 파인애플에 살까요?";
    println!("{question}");

    // 이 `#[expect]` 속성은 `answer` 변수가 전혀 사용되지 않으므로 충족될
    // 린트 기대를 생성합니다. 평소라면 발생했을 `unused_variables` 린트는
    // 억제됩니다. 해당 문장이나 속성에 대해 어떤 경고도 발생하지 않습니다.
    #[expect(unused_variables)]
    let answer = "네모네모 스폰지밥!";
}</code></pre></pre>
<p>r[attributes.diagnostics.expect.fulfillment] The lint expectation is only fulfilled by lint emissions which have been suppressed by the <code>expect</code> attribute. If the lint level is modified in the scope with other level attributes like <code>allow</code> or <code>warn</code>, the lint emission will be handled accordingly and the expectation will remain unfulfilled.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[expect(unused_variables)]
fn select_song() {
    // 이것은 `warn` 속성에 정의된 대로 `unused_variables` 린트를 warn 레벨로
    // 내보낼 것입니다. 이는 함수 위에 있는 기대를 충족시키지 못합니다.
    #[warn(unused_variables)]
    let song_name = "Crab Rave";

    // `allow` 속성은 린트 발생을 억제합니다. 이는 `expect` 속성이 아닌
    // `allow` 속성에 의해 억제되었으므로 함수 위의 기대를
    // 충족시키지 못합니다.
    #[allow(unused_variables)]
    let song_creator = "Noisestorm";

    // 이 `expect` 속성은 변수 위치에서 `unused_variables` 린트 발생을
    // 억제할 것입니다. 이 린트 발생은 지역적인 expect 속성에 의해
    // 억제되었으므로 함수 위의 `expect` 속성은 여전히 충족되지 않습니다.
    #[expect(unused_variables)]
    let song_version = "Monstercat Release";
}
<span class="boring">}</span></code></pre></pre>
<p>r[attributes.diagnostics.expect.independent] If the <code>expect</code> attribute contains several lints, each one is expected separately. For a lint group it’s enough if one lint inside the group has been emitted:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 이 기대는 함수 내부의 사용되지 않은 값에 의해 충족될 것입니다.
// 발생한 `unused_variables` 린트가 `unused` 린트 그룹에 속하기 때문입니다.
#[expect(unused)]
pub fn thoughts() {
    let unused = "예시가 떨어져 가고 있어요";
}

pub fn another_example() {
    // 이 속성은 두 개의 린트 기대를 생성합니다. `unused_mut` 린트는
    // 억제되며 첫 번째 기대를 충족시킬 것입니다. `unused_variables` 린트는
    // 변수가 사용되므로 발생하지 않을 것입니다. 따라서 그 기대는 충족되지
    // 않은 상태로 남게 되며, 경고가 발생할 것입니다.
    #[expect(unused_mut, unused_variables)]
    let mut link = "https://www.rust-lang.org/";

    println!("우리 커뮤니티에 오신 것을 환영합니다: {link}");
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] The behavior of <code>#[expect(unfulfilled_lint_expectations)]</code> is currently defined to always generate the <code>unfulfilled_lint_expectations</code> lint.</p>
</blockquote>
<p>r[attributes.diagnostics.lint.group]</p>
<h3 id="린트-그룹"><a class="header" href="#린트-그룹">린트 그룹</a></h3>
<p>린트들은 관련된 린트들의 레벨을 함께 조정할 수 있도록 명명된 그룹으로 조직될 수 있습니다. 명명된 그룹을 사용하는 것은 해당 그룹 내의 린트들을 나열하는 것과 동일합니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 이는 "unused" 그룹의 모든 린트를 허용합니다.
#[allow(unused)]
// 이는 "unused" 그룹의 "unused_must_use" 린트를
// deny 레벨로 오버라이드합니다.
#[deny(unused_must_use)]
fn example() {
    // "unused_variables" 린트가 "unused" 그룹에 속해 있으므로
    // 경고를 생성하지 않습니다.
    let x = 1;
    // 결과가 사용되지 않았고 "unused_must_use"가 "deny"로 설정되었으므로
    // 에러를 생성합니다.
    std::fs::remove_file("some_file"); // 에러: 반드시 사용되어야 할 `Result`가 사용되지 않음
}
<span class="boring">}</span></code></pre></pre>
<p>r[attributes.diagnostics.lint.group.warnings] There is a special group named “warnings” which includes all lints at the “warn” level. The “warnings” group ignores attribute order and applies to all lints that would otherwise warn within the entity.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">unsafe fn an_unsafe_fn() {}
</span>// 이 두 속성의 순서는 중요하지 않습니다.
#[deny(warnings)]
// unsafe_code 린트는 보통 기본적으로 "allow"입니다.
#[warn(unsafe_code)]
fn example_err() {
    // `unsafe_code` 경고가 "deny"로 격상되었으므로 이것은 에러입니다.
    unsafe { an_unsafe_fn() } // 에러: `unsafe` 블록 사용
}
<span class="boring">}</span></code></pre></pre>
<p>r[attributes.diagnostics.lint.tool]</p>
<h3 id="도구-린트-속성"><a class="header" href="#도구-린트-속성">도구 린트 속성</a></h3>
<p>r[attributes.diagnostics.lint.tool.intro] Tool lints allows using scoped lints, to <code>allow</code>, <code>warn</code>, <code>deny</code> or <code>forbid</code> lints of certain tools.</p>
<p>r[attributes.diagnostics.lint.tool.activation] Tool lints only get checked when the associated tool is active. If a lint attribute, such as <code>allow</code>, references a nonexistent tool lint, the compiler will not warn about the nonexistent lint until you use the tool.</p>
<p>그 외에는 일반 린트 속성과 동일하게 작동합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024">// clippy의 `pedantic` 린트 그룹 전체를 warn으로 설정합니다.
#![warn(clippy::pedantic)]
// clippy의 `filter_map` 린트 경고를 억제합니다.
#![allow(clippy::filter_map)]

fn main() {
    // ...
}

// 이 함수에서만 clippy의 `cmp_nan` 린트를 억제합니다.
#[allow(clippy::cmp_nan)]
fn foo() {
    // ...
}</code></pre></pre>
<blockquote>
<p>[!NOTE] <code>rustc</code> currently recognizes the tool lints for “<a href="https://github.com/rust-lang/rust-clippy">clippy</a>” and “<a href="attributes/../../rustdoc/lints.html">rustdoc</a>”.</p>
</blockquote>
<p>r[attributes.diagnostics.deprecated]</p>
<h2 id="deprecated-속성"><a class="header" href="#deprecated-속성"><code>deprecated</code> 속성</a></h2>
<p>r[attributes.diagnostics.deprecated.intro] The <em><code>deprecated</code> attribute</em> marks an item as deprecated. <code>rustc</code> will issue warnings on usage of <code>#[deprecated]</code> items. <code>rustdoc</code> will show item deprecation, including the <code>since</code> version and <code>note</code>, if available.</p>
<p>r[attributes.diagnostics.deprecated.syntax] The <code>deprecated</code> attribute has several forms:</p>
<ul>
<li><code>deprecated</code> — 일반적인 메시지를 발생시킵니다.</li>
<li><code>deprecated = "message"</code> — 사용 중단 메시지에 주어진 문자열을 포함합니다.</li>
<li>[MetaListNameValueStr] syntax with two optional fields:
<ul>
<li><code>since</code> — 아이템이 사용 중단된 버전 번호를 지정합니다. <code>rustc</code>는 현재 이 문자열을 해석하지 않지만, <a href="https://github.com/rust-lang/rust-clippy">Clippy</a>와 같은 외부 도구가 이 값의 유효성을 검사할 수 있습니다.</li>
<li><code>note</code> — 사용 중단 메시지에 포함되어야 할 문자열을 지정합니다. 이는 일반적으로 사용 중단에 대한 설명과 권장되는 대안을 제공하는 데 사용됩니다.</li>
</ul>
</li>
</ul>
<p>r[attributes.diagnostic.deprecated.allowed-positions] The <code>deprecated</code> attribute may be applied to any <a href="attributes/../items.html">item</a>, <a href="attributes/../items/traits.html">trait item</a>, <a href="attributes/../items/enumerations.html">enum variant</a>, <a href="attributes/../items/structs.html">struct field</a>, <a href="attributes/../items/external-blocks.html">external block item</a>, or <a href="attributes/../macros-by-example.html">macro definition</a>. It cannot be applied to <a href="attributes/../items/implementations.html#trait-implementations">trait implementation items</a>. When applied to an item containing other items, such as a <a href="attributes/../items/modules.html">module</a> or <a href="attributes/../items/implementations.html">implementation</a>, all child items inherit the deprecation attribute.</p>
<!-- NOTE: It is only rejected for trait impl items
(AnnotationKind::Prohibited). In all other locations, it is silently ignored.
Tuple struct fields are ignored.
-->
<p>예시는 다음과 같습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[deprecated(since = "5.2.0", note = "foo는 거의 사용되지 않았습니다. 사용자들은 대신 bar를 사용해야 합니다")]
pub fn foo() {}

pub fn bar() {}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/1270-deprecation.md">RFC</a>에 동기와 자세한 내용이 포함되어 있습니다.</p>
<p>r[attributes.diagnostics.must_use]</p>
<h2 id="must_use-속성"><a class="header" href="#must_use-속성"><code>must_use</code> 속성</a></h2>
<p>r[attributes.diagnostics.must_use.intro] The <em><code>must_use</code> attribute</em> is used to issue a diagnostic warning when a value is not “used”.</p>
<p>r[attributes.diagnostics.must_use.allowed-positions] The <code>must_use</code> attribute can be applied to user-defined composite types (<a href="attributes/../items/structs.html"><code>struct</code>s</a>, <a href="attributes/../items/enumerations.html"><code>enum</code>s</a>, and <a href="attributes/../items/unions.html"><code>union</code>s</a>), <a href="attributes/../items/functions.html">functions</a>, and <a href="attributes/../items/traits.html">traits</a>.</p>
<p>r[attributes.diagnostics.must_use.message] The <code>must_use</code> attribute may include a message by using the [MetaNameValueStr] syntax such as <code>#[must_use = "example message"]</code>. The message will be given alongside the warning.</p>
<p>r[attributes.diagnostics.must_use.type] When used on user-defined composite types, if the <a href="attributes/../expressions.html">expression</a> of an <a href="attributes/../statements.html#expression-statements">expression statement</a> has that type, then the <code>unused_must_use</code> lint is violated.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[must_use]
struct MustUse {
    // 몇몇 필드들
}

<span class="boring">impl MustUse {
</span><span class="boring">  fn new() -&gt; MustUse { MustUse {} }
</span><span class="boring">}
</span><span class="boring">
</span>// `unused_must_use` 린트를 위반합니다.
MustUse::new();
<span class="boring">}</span></code></pre></pre>
<p>r[attributes.diagnostics.must_use.fn] When used on a function, if the <a href="attributes/../expressions.html">expression</a> of an <a href="attributes/../statements.html#expression-statements">expression statement</a> is a <a href="attributes/../expressions/call-expr.html">call expression</a> to that function, then the <code>unused_must_use</code> lint is violated.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[must_use]
fn five() -&gt; i32 { 5i32 }

// `unused_must_use` 린트를 위반합니다.
five();
<span class="boring">}</span></code></pre></pre>
<p>r[attributes.diagnostics.must_use.trait] When used on a <a href="attributes/../items/traits.html">trait declaration</a>, a <a href="attributes/../expressions/call-expr.html">call expression</a> of an <a href="attributes/../statements.html#expression-statements">expression statement</a> to a function that returns an <a href="attributes/../types/impl-trait.html">impl trait</a> or a <a href="attributes/../types/trait-object.html">dyn trait</a> of that trait violates the <code>unused_must_use</code> lint.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[must_use]
trait Critical {}
impl Critical for i32 {}

fn get_critical() -&gt; impl Critical {
    4i32
}

// `unused_must_use` 린트를 위반합니다.
get_critical();
<span class="boring">}</span></code></pre></pre>
<p>r[attributes.diagnostics.must_use.trait-function] When used on a function in a trait declaration, then the behavior also applies when the call expression is a function from an implementation of the trait.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    #[must_use]
    fn use_me(&amp;self) -&gt; i32;
}

impl Trait for i32 {
    fn use_me(&amp;self) -&gt; i32 { 0i32 }
}

// `unused_must_use` 린트를 위반합니다.
5i32.use_me();
<span class="boring">}</span></code></pre></pre>
<p>r[attributes.diagnostics.must_use.trait-impl-function] When used on a function in a trait implementation, the attribute does nothing.</p>
<blockquote>
<p>[!NOTE] Trivial no-op expressions containing the value will not violate the lint. Examples include wrapping the value in a type that does not implement <a href="attributes/../special-types-and-traits.html#drop"><code>Drop</code></a> and then not using that type and being the final expression of a <a href="attributes/../expressions/block-expr.html">block expression</a> that is not used.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[must_use]
fn five() -&gt; i32 { 5i32 }

// 이들 중 어느 것도 `unused_must_use` 린트를 위반하지 않습니다.
(five(),);
Some(five());
{ five() };
if true { five() } else { 0i32 };
match true {
    _ =&gt; five()
};
<span class="boring">}</span></code></pre></pre>
</blockquote>
<blockquote>
<p>[!NOTE] It is idiomatic to use a <a href="attributes/../statements.html#let-statements">let statement</a> with a pattern of <code>_</code> when a must-used value is purposely discarded.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[must_use]
fn five() -&gt; i32 { 5i32 }

// `unused_must_use` 린트를 위반하지 않습니다.
let _ = five();
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[attributes.diagnostic.namespace]</p>
<h2 id="diagnostic-도구-속성-네임스페이스"><a class="header" href="#diagnostic-도구-속성-네임스페이스"><code>diagnostic</code> 도구 속성 네임스페이스</a></h2>
<p>r[attributes.diagnostic.namespace.intro] The <code>#[diagnostic]</code> attribute namespace is a home for attributes to influence compile-time error messages. The hints provided by these attributes are not guaranteed to be used.</p>
<p>r[attributes.diagnostic.namespace.unknown-invalid-syntax] Unknown attributes in this namespace are accepted, though they may emit warnings for unused attributes. Additionally, invalid inputs to known attributes will typically be a warning (see the attribute definitions for details). This is meant to allow adding or discarding attributes and changing inputs in the future to allow changes without the need to keep the non-meaningful attributes or options working.</p>
<p>r[attributes.diagnostic.on_unimplemented]</p>
<h3 id="diagnosticon_unimplemented-속성"><a class="header" href="#diagnosticon_unimplemented-속성"><code>diagnostic::on_unimplemented</code> 속성</a></h3>
<p>r[attributes.diagnostic.on_unimplemented.intro] The <code>#[diagnostic::on_unimplemented]</code> attribute is a hint to the compiler to supplement the error message that would normally be generated in scenarios where a trait is required but not implemented on a type.</p>
<p>r[attributes.diagnostic.on_unimplemented.allowed-positions] The attribute should be placed on a <a href="attributes/../items/traits.html">trait declaration</a>, though it is not an error to be located in other positions.</p>
<p>r[attributes.diagnostic.on_unimplemented.syntax] The attribute uses the [MetaListNameValueStr] syntax to specify its inputs, though any malformed input to the attribute is not considered as an error to provide both forwards and backwards compatibility.</p>
<p>r[attributes.diagnostic.on_unimplemented.keys] The following keys have the given meaning:</p>
<ul>
<li><code>message</code> — 최상위 레벨 에러 메시지를 위한 텍스트입니다.</li>
<li><code>label</code> — 에러 메시지에서 잘못된 코드 내에 표시될 라벨을 위한 텍스트입니다.</li>
<li><code>note</code> — 추가적인 노트를 제공합니다.</li>
</ul>
<p>r[attributes.diagnostic.on_unimplemented.note-repetition] The <code>note</code> option can appear several times, which results in several note messages being emitted.</p>
<p>r[attributes.diagnostic.on_unimplemented.repetition] If any of the other options appears several times the first occurrence of the relevant option specifies the actually used value. Subsequent occurrences generates a warning.</p>
<p>r[attributes.diagnostic.on_unimplemented.unknown-keys] A warning is generated for any unknown keys.</p>
<p>r[attributes.diagnostic.on_unimplemented.format-string] All three options accept a string as an argument, interpreted using the same formatting as a [<code>std::fmt</code>] string.</p>
<p>r[attributes.diagnostic.on_unimplemented.format-parameters] Format parameters with the given named parameter will be replaced with the following text:</p>
<ul>
<li><code>{Self}</code> — 트레잇을 구현하는 타입의 이름입니다.</li>
<li><code>{</code> <em>제네릭매개변수이름</em> <code>}</code> — 주어진 제네릭 매개변수에 대한 제네릭 인수의 타입 이름입니다.</li>
</ul>
<p>r[attributes.diagnostic.on_unimplemented.invalid-formats] Any other format parameter will generate a warning, but will otherwise be included in the string as-is.</p>
<p>r[attributes.diagnostic.on_unimplemented.invalid-string] Invalid format strings may generate a warning, but are otherwise allowed, but may not display as intended. Format specifiers may generate a warning, but are otherwise ignored.</p>
<p>이 예시에서:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0277 edition2024">#[diagnostic::on_unimplemented(
    message = "`{Self}`에 구현된 `ImportantTrait&lt;{A}&gt;`에 대한 메시지",
    label = "나의 라벨",
    note = "노트 1",
    note = "노트 2"
)]
trait ImportantTrait&lt;A&gt; {}

fn use_my_trait(_: impl ImportantTrait&lt;i32&gt;) {}

fn main() {
    use_my_trait(String::new());
}</code></pre></pre>
<p>컴파일러는 다음과 같은 에러 메시지를 생성할 수 있습니다:</p>
<pre><code class="language-text">error[E0277]: My Message for `ImportantTrait&lt;i32&gt;` implemented for `String`
  --&gt; src/main.rs:14:18
   |
14 |     use_my_trait(String::new());
   |     ------------ ^^^^^^^^^^^^^ My Label
   |     |
   |     required by a bound introduced by this call
   |
   = help: the trait `ImportantTrait&lt;i32&gt;` is not implemented for `String`
   = note: Note 1
   = note: Note 2
</code></pre>
<p>r[attributes.diagnostic.do_not_recommend]</p>
<h3 id="diagnosticdo_not_recommend-속성"><a class="header" href="#diagnosticdo_not_recommend-속성"><code>diagnostic::do_not_recommend</code> 속성</a></h3>
<p>r[attributes.diagnostic.do_not_recommend.intro] The <code>#[diagnostic::do_not_recommend]</code> attribute is a hint to the compiler to not show the annotated trait implementation as part of a diagnostic message.</p>
<blockquote>
<p>[!NOTE] Suppressing the recommendation can be useful if you know that the recommendation would normally not be useful to the programmer. This often occurs with broad, blanket impls. The recommendation may send the programmer down the wrong path, or the trait implementation may be an internal detail that you don’t want to expose, or the bounds may not be able to be satisfied by the programmer.</p>
<p>예를 들어, 요구되는 트레잇을 구현하지 않은 타입에 대한 에러 메시지에서, 컴파일러는 트레잇 구현 내의 특정 바운드만 아니었다면 요구 사항을 충족했을 트레잇 구현을 찾을 수도 있습니다. 컴파일러는 사용자에게 구현이 존재하지만 트레잇 구현 내의 바운드가 문제라고 말할 수 있습니다. <code>#[diagnostic::do_not_recommend]</code> 속성은 컴파일러에게 해당 트레잇 구현에 대해 사용자에게 알리지 <em>말고</em>, 대신 단순히 해당 타입이 요구되는 트레잇을 구현하지 않는다고 알리도록 하는 데 사용될 수 있습니다.</p>
</blockquote>
<p>r[attributes.diagnostic.do_not_recommend.allowed-positions] The attribute should be placed on a <a href="attributes/../items/implementations.html#trait-implementations">trait implementation item</a>, though it is not an error to be located in other positions.</p>
<p>r[attributes.diagnostic.do_not_recommend.syntax] The attribute does not accept any arguments, though unexpected arguments are not considered as an error.</p>
<p>다음 예시에는 SQL 라이브러리에서 사용되는 <code>Expression</code> 타입으로 임의의 타입을 캐스팅하는 데 사용되는 <code>AsExpression</code>이라는 트레잇이 있습니다. 여기에는 <code>AsExpression</code>을 인수로 받는 <code>check</code>라는 메서드가 있습니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0277 edition2024"><span class="boring">pub trait Expression {
</span><span class="boring">    type SqlType;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub trait AsExpression&lt;ST&gt; {
</span><span class="boring">    type Expression: Expression&lt;SqlType = ST&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Text;
</span><span class="boring">pub struct Integer;
</span><span class="boring">
</span><span class="boring">pub struct Bound&lt;T&gt;(T);
</span><span class="boring">pub struct SelectInt;
</span><span class="boring">
</span><span class="boring">impl Expression for SelectInt {
</span><span class="boring">    type SqlType = Integer;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Expression for Bound&lt;T&gt; {
</span><span class="boring">    type SqlType = T;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl AsExpression&lt;Integer&gt; for i32 {
</span><span class="boring">    type Expression = Bound&lt;Integer&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl AsExpression&lt;Text&gt; for &amp;'_ str {
</span><span class="boring">    type Expression = Bound&lt;Text&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Foo for T where T: Expression {}
</span>
// 권장 사항을 변경하려면 이 라인의 주석을 해제하세요.
// #[diagnostic::do_not_recommend]
impl&lt;T, ST&gt; AsExpression&lt;ST&gt; for T
where
    T: Expression&lt;SqlType = ST&gt;,
{
    type Expression = T;
}

trait Foo: Expression + Sized {
    fn check&lt;T&gt;(&amp;self, _: T) -&gt; &lt;T as AsExpression&lt;&lt;Self as Expression&gt;::SqlType&gt;&gt;::Expression
    where
        T: AsExpression&lt;Self::SqlType&gt;,
    {
        todo!()
    }
}

fn main() {
    SelectInt.check("bar");
}</code></pre></pre>
<p><code>SelectInt</code> 타입의 <code>check</code> 메서드는 <code>Integer</code> 타입을 기대합니다. <code>AsExpression</code> 트레잇에 의해 <code>i32</code> 타입이 <code>Integer</code>로 변환되므로 <code>i32</code> 타입으로 호출하는 것은 작동합니다. 하지만 문자열로 호출하는 것은 작동하지 않으며, 다음과 같은 에러를 발생시킬 수 있습니다.</p>
<pre><code class="language-text">error[E0277]: the trait bound `&amp;str: Expression` is not satisfied
  --&gt; src/main.rs:53:15
   |
53 |     SelectInt.check("bar");
   |               ^^^^^ the trait `Expression` is not implemented for `&amp;str`
   |
   = help: the following other types implement trait `Expression`:
             Bound&lt;T&gt;
             SelectInt
note: required for `&amp;str` to implement `AsExpression&lt;Integer&gt;`
  --&gt; src/main.rs:45:13
   |
45 | impl&lt;T, ST&gt; AsExpression&lt;ST&gt; for T
   |             ^^^^^^^^^^^^^^^^     ^
46 | where
47 |     T: Expression&lt;SqlType = ST&gt;,
   |        ------------------------ unsatisfied trait bound introduced here
</code></pre>
<p>By adding the <code>#[diagnostic::do_not_recommend]</code> attribute to the blanket <code>impl</code> for <code>AsExpression</code>, the message changes to:</p>
<pre><code class="language-text">error[E0277]: the trait bound `&amp;str: AsExpression&lt;Integer&gt;` is not satisfied
  --&gt; src/main.rs:53:15
   |
53 |     SelectInt.check("bar");
   |               ^^^^^ the trait `AsExpression&lt;Integer&gt;` is not implemented for `&amp;str`
   |
   = help: the trait `AsExpression&lt;Integer&gt;` is not implemented for `&amp;str`
           but trait `AsExpression&lt;Text&gt;` is implemented for it
   = help: for that trait implementation, expected `Text`, found `Integer`
</code></pre>
<p>The first error message includes a somewhat confusing error message about the relationship of <code>&amp;str</code> and <code>Expression</code>, as well as the unsatisfied trait bound in the blanket impl. After adding <code>#[diagnostic::do_not_recommend]</code>, it no longer considers the blanket impl for the recommendation. The message should be a little clearer, with an indication that a string cannot be converted to an <code>Integer</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[attributes.codegen]</p>
<h1 id="코드-생성-속성"><a class="header" href="#코드-생성-속성">코드 생성 속성</a></h1>
<p>다음 <a href="attributes/../attributes.html">속성들</a>은 코드 생성을 제어하는 데 사용됩니다.</p>
<!-- template:attributes -->
<p>r[attributes.codegen.inline]</p>
<h3 id="inline-속성"><a class="header" href="#inline-속성"><code>inline</code> 속성</a></h3>
<p>r[attributes.codegen.inline.intro] The <em><code>inline</code> <a href="attributes/../attributes.html">attribute</a></em> suggests whether a copy of the attributed function’s code should be placed in the caller rather than generating a call to the function.</p>
<blockquote>
<p>[!EXAMPLE]</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline]
pub fn example1() {}

#[inline(always)]
pub fn example2() {}

#[inline(never)]
pub fn example3() {}
<span class="boring">}</span></code></pre></pre>
</blockquote>
<blockquote>
<p>[!NOTE] <code>rustc</code> automatically inlines functions when doing so seems worthwhile. Use this attribute carefully as poor decisions about what to inline can slow down programs.</p>
</blockquote>
<p>r[attributes.codegen.inline.syntax] The syntax for the <code>inline</code> attribute is:</p>
<pre><code class="language-grammar attributes">@root InlineAttribute -&gt;
      `inline` `(` `always` `)`
    | `inline` `(` `never` `)`
    | `inline`
</code></pre>
<p>r[attributes.codegen.inline.allowed-positions] The <code>inline</code> attribute may only be applied to functions with <a href="attributes/items.fn.body">bodies</a> — <a href="attributes/expr.closure">closures</a>, <a href="attributes/expr.block.async">async blocks</a>, <a href="attributes/items.fn">free functions</a>, <a href="attributes/items.associated.fn">associated functions</a> in an <a href="attributes/items.impl.inherent">inherent impl</a> or <a href="attributes/items.impl.trait">trait impl</a>, and associated functions in a <a href="attributes/items.traits">trait definition</a> when those functions have a <a href="attributes/items.traits.associated-item-decls">default definition</a> .</p>
<blockquote>
<p>[!NOTE] <code>rustc</code> ignores use in other positions but lints against it. This may become an error in the future.</p>
</blockquote>
<blockquote>
<p>[!NOTE] Though the attribute can be applied to <a href="attributes/expr.closure">closures</a> and <a href="attributes/expr.block.async">async blocks</a>, the usefulness of this is limited as we do not yet support attributes on expressions.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// We allow attributes on statements.
#[inline] || (); // OK
#[inline] async {}; // OK
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail E0658 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// We don't yet allow attributes on expressions.
let f = #[inline] || (); // 오류
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[attributes.codegen.inline.duplicates] Only the first use of <code>inline</code> on a function has effect.</p>
<blockquote>
<p>[!NOTE] <code>rustc</code> lints against any use following the first. This may become an error in the future.</p>
</blockquote>
<p>r[attributes.codegen.inline.modes] The <code>inline</code> attribute supports these modes:</p>
<ul>
<li><code>#[inline]</code> <em>suggests</em> performing inline expansion.</li>
<li><code>#[inline(always)]</code> <em>suggests</em> that inline expansion should always be performed.</li>
<li><code>#[inline(never)]</code> <em>suggests</em> that inline expansion should never be performed.</li>
</ul>
<blockquote>
<p>[!NOTE] In every form the attribute is a hint. The compiler may ignore it.</p>
</blockquote>
<p>r[attributes.codegen.inline.trait] When <code>inline</code> is applied to a function in a <a href="attributes/items.traits">trait</a>, it applies only to the code of the <a href="attributes/items.traits.associated-item-decls">default definition</a>.</p>
<p>r[attributes.codegen.inline.async] When <code>inline</code> is applied to an <a href="attributes/items.fn.async">async function</a> or <a href="attributes/expr.closure.async">async closure</a>, it applies only to the code of the generated <code>poll</code> function.</p>
<blockquote>
<p>[!NOTE] For more details, see <a href="https://github.com/rust-lang/rust/issues/129347">Rust issue #129347</a>.</p>
</blockquote>
<p>r[attributes.codegen.inline.externally-exported] The <code>inline</code> attribute is ignored if the function is externally exported with <a href="attributes/abi.no_mangle"><code>no_mangle</code></a> or <a href="attributes/abi.export_name"><code>export_name</code></a>.</p>
<!-- template:attributes -->
<p>r[attributes.codegen.cold]</p>
<h3 id="cold-속성"><a class="header" href="#cold-속성"><code>cold</code> 속성</a></h3>
<p>r[attributes.codegen.cold.intro] The <em><code>cold</code> <a href="attributes/../attributes.html">attribute</a></em> suggests that the attributed function is unlikely to be called which may help the compiler produce better code.</p>
<blockquote>
<p>[!EXAMPLE]</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cold]
pub fn example() {}
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[attributes.codegen.cold.syntax] The <code>cold</code> attribute uses the [MetaWord] syntax.</p>
<p>r[attributes.codegen.cold.allowed-positions] The <code>cold</code> attribute may only be applied to functions with <a href="attributes/items.fn.body">bodies</a> — <a href="attributes/expr.closure">closures</a>, <a href="attributes/expr.block.async">async blocks</a>, <a href="attributes/items.fn">free functions</a>, <a href="attributes/items.associated.fn">associated functions</a> in an <a href="attributes/items.impl.inherent">inherent impl</a> or <a href="attributes/items.impl.trait">trait impl</a>, and associated functions in a <a href="attributes/items.traits">trait definition</a> when those functions have a <a href="attributes/items.traits.associated-item-decls">default definition</a> .</p>
<blockquote>
<p>[!NOTE] <code>rustc</code> ignores use in other positions but lints against it. This may become an error in the future.</p>
</blockquote>
<blockquote>
<p>[!NOTE] Though the attribute can be applied to <a href="attributes/expr.closure">closures</a> and <a href="attributes/expr.block.async">async blocks</a>, the usefulness of this is limited as we do not yet support attributes on expressions.</p>
</blockquote>
<!-- TODO: rustc currently seems to allow cold on a trait function without a body, but it appears to be ignored. I think that may be a bug, and it should at least warn if not reject (like inline does). -->
<p>r[attributes.codegen.cold.duplicates] Only the first use of <code>cold</code> on a function has effect.</p>
<blockquote>
<p>[!NOTE] <code>rustc</code> lints against any use following the first. This may become an error in the future.</p>
</blockquote>
<p>r[attributes.codegen.cold.trait] When <code>cold</code> is applied to a function in a <a href="attributes/items.traits">trait</a>, it applies only to the code of the <a href="attributes/items.traits.associated-item-decls">default definition</a>.</p>
<p>r[attributes.codegen.naked]</p>
<h2 id="the-naked-attribute"><a class="header" href="#the-naked-attribute">The <code>naked</code> attribute</a></h2>
<p>r[attributes.codegen.naked.intro] The <em><code>naked</code> <a href="attributes/../attributes.html">attribute</a></em> prevents the compiler from emitting a function prologue and epilogue for the attributed function.</p>
<p>r[attributes.codegen.naked.body] The <a href="attributes/../items/functions.html#function-body">function body</a> must consist of exactly one <a href="attributes/../inline-assembly.html"><code>naked_asm!</code></a> macro invocation.</p>
<p>r[attributes.codegen.naked.prologue-epilogue] No function prologue or epilogue is generated for the attributed function. The assembly code in the <code>naked_asm!</code> block constitutes the full body of a naked function.</p>
<p>r[attributes.codegen.naked.unsafe-attribute] The <code>naked</code> attribute is an <a href="attributes/../attributes.html#r-attributes.safety">unsafe attribute</a>. Annotating a function with <code>#[unsafe(naked)]</code> comes with the safety obligation that the body must respect the function’s calling convention, uphold its signature, and either return or diverge (i.e., not fall through past the end of the assembly code).</p>
<p>r[attributes.codegen.naked.call-stack] The assembly code may assume that the call stack and register state are valid on entry as per the signature and calling convention of the function.</p>
<p>r[attributes.codegen.naked.no-duplication] The assembly code may not be duplicated by the compiler except when monomorphizing polymorphic functions.</p>
<blockquote>
<p>[!NOTE] Guaranteeing when the assembly code may or may not be duplicated is important for naked functions that define symbols.</p>
</blockquote>
<p>r[attributes.codegen.naked.unused-variables] The <a href="attributes/../../rustc/lints/listing/warn-by-default.html#unused-variables"><code>unused_variables</code></a> lint is suppressed within naked functions.</p>
<p>r[attributes.codegen.naked.inline] The <a href="attributes/codegen.html#the-inline-attribute"><code>inline</code></a> attribute cannot by applied to a naked function.</p>
<p>r[attributes.codegen.naked.track_caller] The <a href="attributes/codegen.html#the-track_caller-attribute"><code>track_caller</code></a> attribute cannot be applied to a naked function.</p>
<p>r[attributes.codegen.naked.testing] The <a href="attributes/testing.html">testing attributes</a> cannot be applied to a naked function.</p>
<!-- template:attributes -->
<p>r[attributes.codegen.no_builtins]</p>
<h2 id="no_builtins-속성"><a class="header" href="#no_builtins-속성"><code>no_builtins</code> 속성</a></h2>
<p>r[attributes.codegen.no_builtins.intro] The <em><code>no_builtins</code> <a href="attributes/../attributes.html">attribute</a></em> disables optimization of certain code patterns related to calls to library functions that are assumed to exist.</p>
<!-- TODO: This needs expanding, see <https://github.com/rust-lang/reference/issues/542>. -->
<blockquote>
<p>[!EXAMPLE]</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span>#![no_builtins]
<span class="boring">fn main() {
</span><span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[attributes.codegen.no_builtins.syntax] The <code>no_builtins</code> attribute uses the [MetaWord] syntax.</p>
<p>r[attributes.codegen.no_builtins.allowed-positions] The <code>no_builtins</code> attribute can only be applied to the crate root.</p>
<p>r[attributes.codegen.no_builtins.duplicates] Only the first use of the <code>no_builtins</code> attribute has effect.</p>
<blockquote>
<p>[!NOTE] <code>rustc</code> lints against any use following the first.</p>
</blockquote>
<p>r[attributes.codegen.target_feature]</p>
<h2 id="target_feature-속성"><a class="header" href="#target_feature-속성"><code>target_feature</code> 속성</a></h2>
<p>r[attributes.codegen.target_feature.intro] The <em><code>target_feature</code> <a href="attributes/../attributes.html">attribute</a></em> may be applied to a function to enable code generation of that function for specific platform architecture features. It uses the [MetaListNameValueStr] syntax with a single key of <code>enable</code> whose value is a string of comma-separated feature names to enable.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_feature = "avx2")]
</span>#[target_feature(enable = "avx2")]
fn foo_avx2() {}
<span class="boring">}</span></code></pre></pre>
<p>r[attributes.codegen.target_feature.arch] Each <a href="attributes/../conditional-compilation.html#target_arch">target architecture</a> has a set of features that may be enabled. It is an error to specify a feature for a target architecture that the crate is not being compiled for.</p>
<p>r[attributes.codegen.target_feature.closures] Closures defined within a <code>target_feature</code>-annotated function inherit the attribute from the enclosing function.</p>
<p>r[attributes.codegen.target_feature.target-ub] It is <a href="attributes/../behavior-considered-undefined.html">undefined behavior</a> to call a function that is compiled with a feature that is not supported on the current platform the code is running on, <em>except</em> if the platform explicitly documents this to be safe.</p>
<p>r[attributes.codegen.target_feature.safety-restrictions] The following restrictions apply unless otherwise specified by the platform rules below:</p>
<ul>
<li>안전한(safe) <code>#[target_feature]</code> 함수(및 속성을 상속받은 클로저)는 호출자가 피호출자가 활성화한 모든 <code>target_feature</code>를 활성화한 경우에만 안전하게 호출될 수 있습니다. 이 제약 사항은 <code>unsafe</code> 컨텍스트에서는 적용되지 않습니다.</li>
<li>안전한 <code>#[target_feature]</code> 함수(및 속성을 상속받은 클로저)는 강제 변환되는 위치가 피강제변환자가 활성화한 모든 <code>target_feature</code>를 활성화한 컨텍스트인 경우에만 <em>안전한</em> 함수 포인터로 강제 변환될 수 있습니다. 이 제약 사항은 <code>unsafe</code> 함수 포인터에는 적용되지 않습니다.</li>
</ul>
<p>암시적으로 활성화된 기능들도 이 규칙에 포함됩니다. 예를 들어 <code>sse2</code> 함수는 <code>sse</code>로 표시된 함수를 호출할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_feature = "sse2")] {
</span>#[target_feature(enable = "sse")]
fn foo_sse() {}

fn bar() {
    // 여기서 `foo_sse`를 호출하는 것은 안전하지 않습니다. 비록 타겟 플랫폼에서
    // `sse`가 기본적으로 활성화되어 있거나 컴파일러 플래그로 수동 활성화되어 있더라도,
    // 먼저 SSE를 사용할 수 있는지 확인해야 하기 때문입니다.
    unsafe {
        foo_sse();
    }
}

#[target_feature(enable = "sse")]
fn bar_sse() {
    // 여기서 `foo_sse`를 호출하는 것은 안전합니다.
    foo_sse();
    || foo_sse();
}

#[target_feature(enable = "sse2")]
fn bar_sse2() {
    // `sse2`는 `sse`를 포함하므로 여기서 `foo_sse`를 호출하는 것은 안전합니다.
    foo_sse();
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>r[attributes.codegen.target_feature.fn-traits] A function with a <code>#[target_feature]</code> attribute <em>never</em> implements the <code>Fn</code> family of traits, although closures inheriting features from the enclosing function do.</p>
<p>r[attributes.codegen.target_feature.allowed-positions] The <code>#[target_feature]</code> attribute is not allowed on the following places:</p>
<ul>
<li>[the <code>main</code> function][crate.main]</li>
<li>a [<code>panic_handler</code> function][panic.panic_handler]</li>
<li>안전한 트레잇 메서드</li>
<li>트레잇의 안전한 기본 함수</li>
</ul>
<p>r[attributes.codegen.target_feature.inline] Functions marked with <code>target_feature</code> are not inlined into a context that does not support the given features. The <code>#[inline(always)]</code> attribute may not be used with a <code>target_feature</code> attribute.</p>
<p>r[attributes.codegen.target_feature.availability]</p>
<h3 id="사용-가능한-기능"><a class="header" href="#사용-가능한-기능">사용 가능한 기능</a></h3>
<p>다음은 사용 가능한 기능 이름의 목록입니다.</p>
<p>r[attributes.codegen.target_feature.x86]</p>
<h4 id="x86-또는-x86_64"><a class="header" href="#x86-또는-x86_64"><code>x86</code> 또는 <code>x86_64</code></a></h4>
<p>Executing code with unsupported features is undefined behavior on this platform. Hence on this platform usage of <code>#[target_feature]</code> functions follows the [above restrictions][attributes.codegen.target_feature.safety-restrictions].</p>
<div class="table-wrapper"><table><thead><tr><th>기능(Feature)</th><th>암시적으로 활성화함</th><th>설명</th></tr></thead><tbody>
<tr><td><code>adx</code></td><td></td><td><a href="https://en.wikipedia.org/wiki/Intel_ADX">ADX</a> — 다중 정밀도 덧셈-올림수(Multi-Precision Add-Carry) 명령어 확장</td></tr>
<tr><td><code>aes</code></td><td><code>sse2</code></td><td><a href="https://en.wikipedia.org/wiki/AES_instruction_set">AES</a> — 고급 암호화 표준(Advanced Encryption Standard)</td></tr>
<tr><td><code>avx</code></td><td><code>sse4.2</code></td><td><a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX</a> — 고급 벡터 확장(Advanced Vector Extensions)</td></tr>
<tr><td><code>avx2</code></td><td><code>avx</code></td><td><a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions#AVX2">AVX2</a> — 고급 벡터 확장 2(Advanced Vector Extensions 2)</td></tr>
<tr><td><code>avx512bf16</code></td><td><code>avx512bw</code></td><td><a href="https://en.wikipedia.org/wiki/AVX-512#BF16">AVX512-BF16</a> — Advanced Vector Extensions 512-bit - Bfloat16 Extensions</td></tr>
<tr><td><code>avx512bitalg</code></td><td><code>avx512bw</code></td><td><a href="https://en.wikipedia.org/wiki/AVX-512#VPOPCNTDQ_and_BITALG">AVX512-BITALG</a> — Advanced Vector Extensions 512-bit - Bit Algorithms</td></tr>
<tr><td><code>avx512bw</code></td><td><code>avx512f</code></td><td><a href="https://en.wikipedia.org/wiki/AVX-512#BW,_DQ_and_VBMI">AVX512-BW</a> — Advanced Vector Extensions 512-bit - Byte and Word Instructions</td></tr>
<tr><td><code>avx512cd</code></td><td><code>avx512f</code></td><td><a href="https://en.wikipedia.org/wiki/AVX-512#Conflict_detection">AVX512-CD</a> — Advanced Vector Extensions 512-bit - Conflict Detection Instructions</td></tr>
<tr><td><code>avx512dq</code></td><td><code>avx512f</code></td><td><a href="https://en.wikipedia.org/wiki/AVX-512#BW,_DQ_and_VBMI">AVX512-DQ</a> — Advanced Vector Extensions 512-bit - Doubleword and Quadword Instructions</td></tr>
<tr><td><code>avx512f</code></td><td><code>avx2</code>, <code>fma</code>, <code>f16c</code></td><td><a href="https://en.wikipedia.org/wiki/AVX-512">AVX512-F</a> — Advanced Vector Extensions 512-bit - Foundation</td></tr>
<tr><td><code>avx512fp16</code></td><td><code>avx512bw</code></td><td><a href="https://en.wikipedia.org/wiki/AVX-512#FP16">AVX512-FP16</a> — Advanced Vector Extensions 512-bit - Float16 Extensions</td></tr>
<tr><td><code>avx512ifma</code></td><td><code>avx512f</code></td><td><a href="https://en.wikipedia.org/wiki/AVX-512#IFMA">AVX512-IFMA</a> — Advanced Vector Extensions 512-bit - Integer Fused Multiply Add</td></tr>
<tr><td><code>avx512vbmi</code></td><td><code>avx512bw</code></td><td><a href="https://en.wikipedia.org/wiki/AVX-512#BW,_DQ_and_VBMI">AVX512-VBMI</a> — Advanced Vector Extensions 512-bit - Vector Byte Manipulation Instructions</td></tr>
<tr><td><code>avx512vbmi2</code></td><td><code>avx512bw</code></td><td><a href="https://en.wikipedia.org/wiki/AVX-512#VBMI2">AVX512-VBMI2</a> — Advanced Vector Extensions 512-bit - Vector Byte Manipulation Instructions 2</td></tr>
<tr><td><code>avx512vl</code></td><td><code>avx512f</code></td><td><a href="https://en.wikipedia.org/wiki/AVX-512">AVX512-VL</a> — Advanced Vector Extensions 512-bit - Vector Length Extensions</td></tr>
<tr><td><code>avx512vnni</code></td><td><code>avx512f</code></td><td><a href="https://en.wikipedia.org/wiki/AVX-512#VNNI">AVX512-VNNI</a> — Advanced Vector Extensions 512-bit - Vector Neural Network Instructions</td></tr>
<tr><td><code>avx512vp2intersect</code></td><td><code>avx512f</code></td><td><a href="https://en.wikipedia.org/wiki/AVX-512#VP2INTERSECT">AVX512-VP2INTERSECT</a> — Advanced Vector Extensions 512-bit - Vector Pair Intersection to a Pair of Mask Registers</td></tr>
<tr><td><code>avx512vpopcntdq</code></td><td><code>avx512f</code></td><td><a href="https://en.wikipedia.org/wiki/AVX-512#VPOPCNTDQ_and_BITALG">AVX512-VPOPCNTDQ</a> — Advanced Vector Extensions 512-bit - Vector Population Count Instruction</td></tr>
<tr><td><code>avxifma</code></td><td><code>avx2</code></td><td><a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions#AVX-VNNI,_AVX-IFMA">AVX-IFMA</a> — Advanced Vector Extensions - Integer Fused Multiply Add</td></tr>
<tr><td><code>avxneconvert</code></td><td><code>avx2</code></td><td><a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions#AVX-VNNI,_AVX-IFMA">AVX-NE-CONVERT</a> — Advanced Vector Extensions - No-Exception Floating-Point conversion Instructions</td></tr>
<tr><td><code>avxvnni</code></td><td><code>avx2</code></td><td><a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions#AVX-VNNI,_AVX-IFMA">AVX-VNNI</a> — Advanced Vector Extensions - Vector Neural Network Instructions</td></tr>
<tr><td><code>avxvnniint16</code></td><td><code>avx2</code></td><td><a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions#AVX-VNNI,_AVX-IFMA">AVX-VNNI-INT16</a> — Advanced Vector Extensions - Vector Neural Network Instructions with 16-bit Integers</td></tr>
<tr><td><code>avxvnniint8</code></td><td><code>avx2</code></td><td><a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions#AVX-VNNI,_AVX-IFMA">AVX-VNNI-INT8</a> — Advanced Vector Extensions - Vector Neural Network Instructions with 8-bit Integers</td></tr>
<tr><td><code>bmi1</code></td><td></td><td><a href="https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets">BMI1</a> — 비트 조작 명령어 집합(Bit Manipulation Instruction Sets)</td></tr>
<tr><td><code>bmi2</code></td><td></td><td><a href="https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets#BMI2">BMI2</a> — 비트 조작 명령어 집합 2(Bit Manipulation Instruction Sets 2)</td></tr>
<tr><td><code>cmpxchg16b</code></td><td></td><td><a href="https://www.felixcloutier.com/x86/cmpxchg8b:cmpxchg16b"><code>cmpxchg16b</code></a> — 16바이트(128비트) 데이터를 원자적으로 비교 및 교환</td></tr>
<tr><td><code>f16c</code></td><td><code>avx</code></td><td><a href="https://en.wikipedia.org/wiki/F16C">F16C</a> — 16비트 부동 소수점 변환 명령어</td></tr>
<tr><td><code>fma</code></td><td><code>avx</code></td><td><a href="https://en.wikipedia.org/wiki/FMA_instruction_set">FMA3</a> — 3-피연산자 융합 곱셈-더하기(Three-operand fused multiply-add)</td></tr>
<tr><td><code>fxsr</code></td><td></td><td><a href="https://www.felixcloutier.com/x86/fxsave"><code>fxsave</code></a> 및 <a href="https://www.felixcloutier.com/x86/fxrstor"><code>fxrstor</code></a> — x87 FPU, MMX 기술 및 SSE 상태 저장 및 복원</td></tr>
<tr><td><code>gfni</code></td><td><code>sse2</code></td><td><a href="https://en.wikipedia.org/wiki/AVX-512#GFNI">GFNI</a> — Galois Field New Instructions</td></tr>
<tr><td><code>kl</code></td><td><code>sse2</code></td><td><a href="https://en.wikipedia.org/wiki/List_of_x86_cryptographic_instructions#Intel_Key_Locker_instructions">KEYLOCKER</a> — Intel Key Locker Instructions</td></tr>
<tr><td><code>lzcnt</code></td><td></td><td><a href="https://www.felixcloutier.com/x86/lzcnt"><code>lzcnt</code></a> — 선행 제로 카운트(Leading zeros count)</td></tr>
<tr><td><code>movbe</code></td><td></td><td><a href="https://www.felixcloutier.com/x86/movbe"><code>movbe</code></a> — 바이트 스왑 후 데이터 이동</td></tr>
<tr><td><code>pclmulqdq</code></td><td><code>sse2</code></td><td><a href="https://www.felixcloutier.com/x86/pclmulqdq"><code>pclmulqdq</code></a> — 팩형 올림수 없는 곱셈 쿼드워드(Packed carry-less multiplication quadword)</td></tr>
<tr><td><code>popcnt</code></td><td></td><td><a href="https://www.felixcloutier.com/x86/popcnt"><code>popcnt</code></a> — 1로 설정된 비트의 개수</td></tr>
<tr><td><code>rdrand</code></td><td></td><td><a href="https://en.wikipedia.org/wiki/RdRand"><code>rdrand</code></a> — 난수 읽기</td></tr>
<tr><td><code>rdseed</code></td><td></td><td><a href="https://en.wikipedia.org/wiki/RdRand"><code>rdseed</code></a> — 난수 시드 읽기</td></tr>
<tr><td><code>sha</code></td><td><code>sse2</code></td><td><a href="https://en.wikipedia.org/wiki/Intel_SHA_extensions">SHA</a> — 안전한 해시 알고리즘(Secure Hash Algorithm)</td></tr>
<tr><td><code>sha512</code></td><td><code>avx2</code></td><td><a href="https://en.wikipedia.org/wiki/Intel_SHA_extensions">SHA512</a> — Secure Hash Algorithm with 512-bit digest</td></tr>
<tr><td><code>sm3</code></td><td><code>avx</code></td><td><a href="https://en.wikipedia.org/wiki/List_of_x86_cryptographic_instructions#Intel_SHA_and_SM3_instructions">SM3</a> — ShangMi 3 Hash Algorithm</td></tr>
<tr><td><code>sm4</code></td><td><code>avx2</code></td><td><a href="https://en.wikipedia.org/wiki/List_of_x86_cryptographic_instructions#Intel_SHA_and_SM3_instructions">SM4</a> — ShangMi 4 Cipher Algorithm</td></tr>
<tr><td><code>sse</code></td><td></td><td><a href="https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions">SSE</a> — 스트리밍 <abbr title="Single Instruction Multiple Data">SIMD</abbr> 확장</td></tr>
<tr><td><code>sse2</code></td><td><code>sse</code></td><td><a href="https://en.wikipedia.org/wiki/SSE2">SSE2</a> — 스트리밍 SIMD 확장 2</td></tr>
<tr><td><code>sse3</code></td><td><code>sse2</code></td><td><a href="https://en.wikipedia.org/wiki/SSE3">SSE3</a> — 스트리밍 SIMD 확장 3</td></tr>
<tr><td><code>sse4.1</code></td><td><code>ssse3</code></td><td><a href="https://en.wikipedia.org/wiki/SSE4#SSE4.1">SSE4.1</a> — 스트리밍 SIMD 확장 4.1</td></tr>
<tr><td><code>sse4.2</code></td><td><code>sse4.1</code></td><td><a href="https://en.wikipedia.org/wiki/SSE4#SSE4.2">SSE4.2</a> — 스트리밍 SIMD 확장 4.2</td></tr>
<tr><td><code>sse4a</code></td><td><code>sse3</code></td><td><a href="https://en.wikipedia.org/wiki/SSE4#SSE4a">SSE4a</a> — Streaming SIMD Extensions 4a</td></tr>
<tr><td><code>ssse3</code></td><td><code>sse3</code></td><td><a href="https://en.wikipedia.org/wiki/SSSE3">SSSE3</a> — Supplemental Streaming SIMD Extensions 3</td></tr>
<tr><td><code>tbm</code></td><td></td><td><a href="https://en.wikipedia.org/wiki/X86_Bit_manipulation_instruction_set#TBM_(Trailing_Bit_Manipulation)">TBM</a> — Trailing Bit Manipulation</td></tr>
<tr><td><code>vaes</code></td><td><code>avx2</code>, <code>aes</code></td><td><a href="https://en.wikipedia.org/wiki/AVX-512#VAES">VAES</a> — Vector AES Instructions</td></tr>
<tr><td><code>vpclmulqdq</code></td><td><code>avx</code>, <code>pclmulqdq</code></td><td><a href="https://en.wikipedia.org/wiki/AVX-512#VPCLMULQDQ">VPCLMULQDQ</a> — Vector Carry-less multiplication of Quadwords</td></tr>
<tr><td><code>widekl</code></td><td><code>kl</code></td><td><a href="https://en.wikipedia.org/wiki/List_of_x86_cryptographic_instructions#Intel_Key_Locker_instructions">KEYLOCKER_WIDE</a> — Intel Wide Keylocker Instructions</td></tr>
<tr><td><code>xsave</code></td><td></td><td><a href="https://www.felixcloutier.com/x86/xsave"><code>xsave</code></a> — 프로세서 확장 상태 저장</td></tr>
<tr><td><code>xsavec</code></td><td></td><td><a href="https://www.felixcloutier.com/x86/xsavec"><code>xsavec</code></a> — 압축을 사용한 프로세서 확장 상태 저장</td></tr>
<tr><td><code>xsaveopt</code></td><td></td><td><a href="https://www.felixcloutier.com/x86/xsaveopt"><code>xsaveopt</code></a> — 최적화된 프로세서 확장 상태 저장</td></tr>
<tr><td><code>xsaves</code></td><td></td><td><a href="https://www.felixcloutier.com/x86/xsaves"><code>xsaves</code></a> — 관리자용 프로세서 확장 상태 저장</td></tr>
</tbody></table>
</div><!-- Keep links near each table to make it easier to move and update. -->
<p>r[attributes.codegen.target_feature.aarch64]</p>
<h4 id="aarch64"><a class="header" href="#aarch64"><code>aarch64</code></a></h4>
<p>On this platform the usage of <code>#[target_feature]</code> functions follows the [above restrictions][attributes.codegen.target_feature.safety-restrictions].</p>
<p>이러한 기능들에 대한 추가 문서는 <a href="https://developer.arm.com/documentation/ddi0487/latest">ARM 아키텍처 참조 매뉴얼</a> 또는 <a href="https://developer.arm.com">developer.arm.com</a>에서 찾을 수 있습니다.</p>
<blockquote>
<p>[!NOTE] The following pairs of features should both be marked as enabled or disabled together if used:</p>
<ul>
<li><code>paca</code> 및 <code>pacg</code> (LLVM은 현재 이를 하나의 기능으로 구현함).</li>
</ul>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>기능(Feature)</th><th>암시적으로 활성화함</th><th>기능 이름</th></tr></thead><tbody>
<tr><td><code>aes</code></td><td><code>neon</code></td><td>FEAT_AES &amp; FEAT_PMULL — 고급 <abbr title="Single Instruction Multiple Data">SIMD</abbr> AES 및 PMULL 명령어</td></tr>
<tr><td><code>bf16</code></td><td></td><td>FEAT_BF16 — BFloat16 명령어</td></tr>
<tr><td><code>bti</code></td><td></td><td>FEAT_BTI — 분기 타겟 식별(Branch Target Identification)</td></tr>
<tr><td><code>crc</code></td><td></td><td>FEAT_CRC — CRC32 체크섬 명령어</td></tr>
<tr><td><code>dit</code></td><td></td><td>FEAT_DIT  — Data Independent Timing instructions</td></tr>
<tr><td><code>dotprod</code></td><td><code>neon</code></td><td>FEAT_DotProd — 고급 SIMD Int8 내적(dot product) 명령어</td></tr>
<tr><td><code>dpb</code></td><td></td><td>FEAT_DPB — 영속성 지점까지의 데이터 캐시 클린(Data cache clean to point of persistence)</td></tr>
<tr><td><code>dpb2</code></td><td><code>dpb</code></td><td>FEAT_DPB2 — 깊은 영속성 지점까지의 데이터 캐시 클린(Data cache clean to point of deep persistence)</td></tr>
<tr><td><code>f32mm</code></td><td><code>sve</code></td><td>FEAT_F32MM — SVE 단정밀도 부동 소수점 행렬 곱셈 명령어</td></tr>
<tr><td><code>f64mm</code></td><td><code>sve</code></td><td>FEAT_F64MM — SVE 배정밀도 부동 소수점 행렬 곱셈 명령어</td></tr>
<tr><td><code>fcma</code></td><td><code>neon</code></td><td>FEAT_FCMA — 부동 소수점 복소수 지원</td></tr>
<tr><td><code>fhm</code></td><td><code>fp16</code></td><td>FEAT_FHM — 반정밀도 부동 소수점 FMLAL 명령어</td></tr>
<tr><td><code>flagm</code></td><td></td><td>FEAT_FLAGM — Conditional flag manipulation</td></tr>
<tr><td><code>fp16</code></td><td><code>neon</code></td><td>FEAT_FP16 — 반정밀도 부동 소수점 데이터 처리</td></tr>
<tr><td><code>frintts</code></td><td></td><td>FEAT_FRINTTS — 부동 소수점에서 정수로의 변환 도우미 명령어</td></tr>
<tr><td><code>i8mm</code></td><td></td><td>FEAT_I8MM — Int8 행렬 곱셈</td></tr>
<tr><td><code>jsconv</code></td><td><code>neon</code></td><td>FEAT_JSCVT — 자바스크립트 변환 명령어</td></tr>
<tr><td><code>lor</code></td><td></td><td>FEAT_LOR — 제한된 순서 영역(Limited Ordering Regions) 확장</td></tr>
<tr><td><code>lse</code></td><td></td><td>FEAT_LSE — Large System Extensions</td></tr>
<tr><td><code>mte</code></td><td></td><td>FEAT_MTE &amp; FEAT_MTE2 — 메모리 태깅 확장(Memory Tagging Extension)</td></tr>
<tr><td><code>neon</code></td><td></td><td>FEAT_AdvSimd &amp; FEAT_FP — Floating Point and Advanced SIMD extension</td></tr>
<tr><td><code>paca</code></td><td></td><td>FEAT_PAUTH — Pointer Authentication (address authentication)</td></tr>
<tr><td><code>pacg</code></td><td></td><td>FEAT_PAUTH — Pointer Authentication (generic authentication)</td></tr>
<tr><td><code>pan</code></td><td></td><td>FEAT_PAN — 특권층 액세스 금지(Privileged Access-Never) 확장</td></tr>
<tr><td><code>pmuv3</code></td><td></td><td>FEAT_PMUv3 — 성능 모니터 확장 (v3)</td></tr>
<tr><td><code>rand</code></td><td></td><td>FEAT_RNG — 난수 생성기(Random Number Generator)</td></tr>
<tr><td><code>ras</code></td><td></td><td>FEAT_RAS &amp; FEAT_RASv1p1 — 신뢰성, 가용성 및 서비스성(Reliability, Availability and Serviceability) 확장</td></tr>
<tr><td><code>rcpc</code></td><td></td><td>FEAT_LRCPC — 릴리스 일관성 프로세서 일관성(Release consistent Processor Consistent)</td></tr>
<tr><td><code>rcpc2</code></td><td><code>rcpc</code></td><td>FEAT_LRCPC2 — 즉시 오프셋을 포함한 RcPc</td></tr>
<tr><td><code>rdm</code></td><td><code>neon</code></td><td>FEAT_RDM — 반올림 이중 곱셈 누산(Rounding Double Multiply accumulate)</td></tr>
<tr><td><code>sb</code></td><td></td><td>FEAT_SB — 투기적 실행 배리어(Speculation Barrier)</td></tr>
<tr><td><code>sha2</code></td><td><code>neon</code></td><td>FEAT_SHA1 &amp; FEAT_SHA256 — 고급 SIMD SHA 명령어</td></tr>
<tr><td><code>sha3</code></td><td><code>sha2</code></td><td>FEAT_SHA512 &amp; FEAT_SHA3 — 고급 SIMD SHA 명령어</td></tr>
<tr><td><code>sm4</code></td><td><code>neon</code></td><td>FEAT_SM3 &amp; FEAT_SM4 — 고급 SIMD SM3/4 명령어</td></tr>
<tr><td><code>spe</code></td><td></td><td>FEAT_SPE — 통계적 프로파일링 확장(Statistical Profiling Extension)</td></tr>
<tr><td><code>ssbs</code></td><td></td><td>FEAT_SSBS &amp; FEAT_SSBS2 — 투기적 저장소 우회 안전(Speculative Store Bypass Safe)</td></tr>
<tr><td><code>sve</code></td><td><code>neon</code></td><td>FEAT_SVE — 가변 벡터 확장(Scalable Vector Extension)</td></tr>
<tr><td><code>sve2</code></td><td><code>sve</code></td><td>FEAT_SVE2 — 가변 벡터 확장 2</td></tr>
<tr><td><code>sve2-aes</code></td><td><code>sve2</code>, <code>aes</code></td><td>FEAT_SVE_AES &amp; FEAT_SVE_PMULL128 — SVE AES instructions</td></tr>
<tr><td><code>sve2-bitperm</code></td><td><code>sve2</code></td><td>FEAT_SVE2_BitPerm — SVE Bit Permute</td></tr>
<tr><td><code>sve2-sha3</code></td><td><code>sve2</code>, <code>sha3</code></td><td>FEAT_SVE2_SHA3 — SVE SHA3 instructions</td></tr>
<tr><td><code>sve2-sm4</code></td><td><code>sve2</code>, <code>sm4</code></td><td>FEAT_SVE2_SM4 — SVE SM4 instructions</td></tr>
<tr><td><code>tme</code></td><td></td><td>FEAT_TME — 트랜잭셔널 메모리 확장(Transactional Memory Extension)</td></tr>
<tr><td><code>vh</code></td><td></td><td>FEAT_VHE — 가상화 호스트 확장(Virtualization Host Extensions)</td></tr>
</tbody></table>
</div>
<p>r[attributes.codegen.target_feature.loongarch]</p>
<h4 id="loongarch"><a class="header" href="#loongarch"><code>loongarch</code></a></h4>
<p>On this platform the usage of <code>#[target_feature]</code> functions follows the [above restrictions][attributes.codegen.target_feature.safety-restrictions].</p>
<div class="table-wrapper"><table><thead><tr><th>기능(Feature)</th><th>암시적으로 활성화함</th><th>설명</th></tr></thead><tbody>
<tr><td><code>f</code></td><td></td><td><a href="https://loongson.github.io/LoongArch-Documentation/LoongArch-Vol1-EN.html#cpucfg-fp_sp">F</a> — Single-precision float-point instructions</td></tr>
<tr><td><code>d</code></td><td><code>f</code></td><td><a href="https://loongson.github.io/LoongArch-Documentation/LoongArch-Vol1-EN.html#cpucfg-fp_dp">D</a> — Double-precision float-point instructions</td></tr>
<tr><td><code>frecipe</code></td><td></td><td><a href="https://loongson.github.io/LoongArch-Documentation/LoongArch-Vol1-EN.html#cpucfg-frecipe">FRECIPE</a> — Reciprocal approximation instructions</td></tr>
<tr><td><code>lasx</code></td><td><code>lsx</code></td><td><a href="https://loongson.github.io/LoongArch-Documentation/LoongArch-Vol1-EN.html#cpucfg-lasx">LASX</a> — 256-bit vector instructions</td></tr>
<tr><td><code>lbt</code></td><td></td><td><a href="https://loongson.github.io/LoongArch-Documentation/LoongArch-Vol1-EN.html#cpucfg-lbt_x86">LBT</a> — Binary translation instructions</td></tr>
<tr><td><code>lsx</code></td><td><code>d</code></td><td><a href="https://loongson.github.io/LoongArch-Documentation/LoongArch-Vol1-EN.html#cpucfg-lsx">LSX</a> — 128-bit vector instructions</td></tr>
<tr><td><code>lvz</code></td><td></td><td><a href="https://loongson.github.io/LoongArch-Documentation/LoongArch-Vol1-EN.html#cpucfg-lvz">LVZ</a> — Virtualization instructions</td></tr>
</tbody></table>
</div><!-- Keep links near each table to make it easier to move and update. -->
<p>r[attributes.codegen.target_feature.riscv]</p>
<h4 id="riscv32-또는-riscv64"><a class="header" href="#riscv32-또는-riscv64"><code>riscv32</code> 또는 <code>riscv64</code></a></h4>
<p>On this platform the usage of <code>#[target_feature]</code> functions follows the [above restrictions][attributes.codegen.target_feature.safety-restrictions].</p>
<p>Further documentation on these features can be found in their respective specification. Many specifications are described in the <a href="https://github.com/riscv/riscv-isa-manual">RISC-V ISA Manual</a>, <a href="https://github.com/riscv/riscv-isa-manual/tree/20250508">version 20250508</a>, or in another manual hosted on the <a href="https://github.com/riscv">RISC-V GitHub Account</a>.</p>
<div class="table-wrapper"><table><thead><tr><th>기능(Feature)</th><th>암시적으로 활성화함</th><th>설명</th></tr></thead><tbody>
<tr><td><code>a</code></td><td><code>zaamo</code>, <code>zalrsc</code></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/a-st-ext.adoc">A</a> — Atomic instructions</td></tr>
<tr><td><code>b</code></td><td><code>zba</code>, <code>zbc</code>, <code>zbs</code></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/b-st-ext.adoc">B</a> — Bit Manipulation instructions</td></tr>
<tr><td><code>c</code></td><td><code>zca</code></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/c-st-ext.adoc">C</a> — Compressed instructions</td></tr>
<tr><td><code>m</code></td><td></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/m-st-ext.adoc">M</a> — Integer Multiplication and Division instructions</td></tr>
<tr><td><code>za64rs</code></td><td><code>za128rs</code></td><td><a href="https://github.com/riscv/riscv-profiles/blob/rva23-rvb23-ratified/src/rva23-profile.adoc">Za64rs</a> — Platform Behavior: Naturally aligned Reservation sets with ≦ 64 Bytes</td></tr>
<tr><td><code>za128rs</code></td><td></td><td><a href="https://github.com/riscv/riscv-profiles/blob/v1.0/profiles.adoc">Za128rs</a> — Platform Behavior: Naturally aligned Reservation sets with ≦ 128 Bytes</td></tr>
<tr><td><code>zaamo</code></td><td></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/a-st-ext.adoc">Zaamo</a> — Atomic Memory Operation instructions</td></tr>
<tr><td><code>zabha</code></td><td><code>zaamo</code></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/zabha.adoc">Zabha</a> — Byte and Halfword Atomic Memory Operation instructions</td></tr>
<tr><td><code>zacas</code></td><td><code>zaamo</code></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/zacas.adoc">Zacas</a> — Atomic Compare-and-Swap (CAS) instructions</td></tr>
<tr><td><code>zalrsc</code></td><td></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/a-st-ext.adoc">Zalrsc</a> — Load-Reserved/Store-Conditional instructions</td></tr>
<tr><td><code>zama16b</code></td><td></td><td><a href="https://github.com/riscv/riscv-profiles/blob/rva23-rvb23-ratified/src/rva23-profile.adoc">Zama16b</a> — Platform Behavior: Misaligned loads, stores, and AMOs to main memory regions that do not cross a naturally aligned 16-byte boundary are atomic</td></tr>
<tr><td><code>zawrs</code></td><td></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/zawrs.adoc">Zawrs</a> — Wait-on-Reservation-Set instructions</td></tr>
<tr><td><code>zba</code></td><td></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/b-st-ext.adoc">Zba</a> — Address Generation instructions</td></tr>
<tr><td><code>zbb</code></td><td></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/b-st-ext.adoc">Zbb</a> — Basic bit-manipulation</td></tr>
<tr><td><code>zbc</code></td><td><code>zbkc</code></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/b-st-ext.adoc">Zbc</a> — Carry-less multiplication</td></tr>
<tr><td><code>zbkb</code></td><td></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/b-st-ext.adoc">Zbkb</a> — Bit Manipulation Instructions for Cryptography</td></tr>
<tr><td><code>zbkc</code></td><td></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/b-st-ext.adoc">Zbkc</a> — Carry-less multiplication for Cryptography</td></tr>
<tr><td><code>zbkx</code></td><td></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/b-st-ext.adoc">Zbkx</a> — Crossbar permutations</td></tr>
<tr><td><code>zbs</code></td><td></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/b-st-ext.adoc">Zbs</a> — Single-bit instructions</td></tr>
<tr><td><code>zca</code></td><td></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/zc.adoc">Zca</a> — Compressed instructions: integer part subset</td></tr>
<tr><td><code>zcb</code></td><td><code>zca</code></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/zc.adoc">Zcb</a> — Simple Code-size Saving Compressed instructions</td></tr>
<tr><td><code>zcmop</code></td><td><code>zca</code></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/zimop.adoc">Zcmop</a> — Compressed May-Be-Operations</td></tr>
<tr><td><code>zic64b</code></td><td></td><td><a href="https://github.com/riscv/riscv-profiles/blob/v1.0/profiles.adoc">Zic64b</a> — Platform Behavior: Naturally aligned 64 byte Cache blocks</td></tr>
<tr><td><code>zicbom</code></td><td></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/cmo.adoc">Zicbom</a> — Cache-Block Management instructions</td></tr>
<tr><td><code>zicbop</code></td><td></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/cmo.adoc">Zicbop</a> — Cache-Block Prefetch Hint instructions</td></tr>
<tr><td><code>zicboz</code></td><td></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/cmo.adoc">Zicboz</a> — Cache-Block Zero instruction</td></tr>
<tr><td><code>ziccamoa</code></td><td></td><td><a href="https://github.com/riscv/riscv-profiles/blob/v1.0/profiles.adoc">Ziccamoa</a> — Platform Behavior: Cacheable and Coherent Main memory supports all basic atomic operations</td></tr>
<tr><td><code>ziccif</code></td><td></td><td><a href="https://github.com/riscv/riscv-profiles/blob/v1.0/profiles.adoc">Ziccif</a> — Platform Behavior: Cacheable and Coherent Main memory supports instruction fetch and fetches of naturally aligned power-of-2 sizes up to <code>min(ILEN,XLEN)</code> are atomic</td></tr>
<tr><td><code>zicclsm</code></td><td></td><td><a href="https://github.com/riscv/riscv-profiles/blob/v1.0/profiles.adoc">Zicclsm</a> — Platform Behavior: Cacheable and Coherent Main memory supports misaligned load/store accesses</td></tr>
<tr><td><code>ziccrse</code></td><td></td><td><a href="https://github.com/riscv/riscv-profiles/blob/v1.0/profiles.adoc">Ziccrse</a> — Platform Behavior: Cacheable and Coherent Main memory guarantees eventual success on LR/SC sequences</td></tr>
<tr><td><code>zicntr</code></td><td><code>zicsr</code></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/counters.adoc">Zicntr</a> — Base Counters and Timers</td></tr>
<tr><td><code>zicond</code></td><td></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/zicond.adoc">Zicond</a> — Integer Conditional Operation instructions</td></tr>
<tr><td><code>zicsr</code></td><td></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/zicsr.adoc">Zicsr</a> — Control and Status Register (CSR) instructions</td></tr>
<tr><td><code>zifencei</code></td><td></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/zifencei.adoc">Zifencei</a> — Instruction-Fetch Fence instruction</td></tr>
<tr><td><code>zihintntl</code></td><td></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/zihintntl.adoc">Zihintntl</a> — Non-Temporal Locality Hint instructions</td></tr>
<tr><td><code>zihintpause</code></td><td></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/zihintpause.adoc">Zihintpause</a> — Pause Hint instruction</td></tr>
<tr><td><code>zihpm</code></td><td><code>zicsr</code></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/counters.adoc">Zihpm</a> — Hardware Performance Counters</td></tr>
<tr><td><code>zimop</code></td><td></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/zimop.adoc">Zimop</a> — May-Be-Operations</td></tr>
<tr><td><code>zk</code></td><td><code>zkn</code>, <code>zkr</code>, <code>zks</code>, <code>zkt</code>, <code>zbkb</code>, <code>zbkc</code>, <code>zkbx</code></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/scalar-crypto.adoc">Zk</a> — Scalar Cryptography</td></tr>
<tr><td><code>zkn</code></td><td><code>zknd</code>, <code>zkne</code>, <code>zknh</code>, <code>zbkb</code>, <code>zbkc</code>, <code>zkbx</code></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/scalar-crypto.adoc">Zkn</a> — NIST Algorithm suite extension</td></tr>
<tr><td><code>zknd</code></td><td></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/scalar-crypto.adoc">Zknd</a> — NIST Suite: AES Decryption</td></tr>
<tr><td><code>zkne</code></td><td></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/scalar-crypto.adoc">Zkne</a> — NIST Suite: AES Encryption</td></tr>
<tr><td><code>zknh</code></td><td></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/scalar-crypto.adoc">Zknh</a> — NIST Suite: Hash Function Instructions</td></tr>
<tr><td><code>zkr</code></td><td></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/scalar-crypto.adoc">Zkr</a> — Entropy Source Extension</td></tr>
<tr><td><code>zks</code></td><td><code>zksed</code>, <code>zksh</code>, <code>zbkb</code>, <code>zbkc</code>, <code>zkbx</code></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/scalar-crypto.adoc">Zks</a> — ShangMi Algorithm Suite</td></tr>
<tr><td><code>zksed</code></td><td></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/scalar-crypto.adoc">Zksed</a> — ShangMi Suite: SM4 Block Cipher Instructions</td></tr>
<tr><td><code>zksh</code></td><td></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/scalar-crypto.adoc">Zksh</a> — ShangMi Suite: SM3 Hash Function Instructions</td></tr>
<tr><td><code>zkt</code></td><td></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/scalar-crypto.adoc">Zkt</a> — Data Independent Execution Latency Subset</td></tr>
<tr><td><code>ztso</code></td><td></td><td><a href="https://github.com/riscv/riscv-isa-manual/blob/20250508/src/ztso-st-ext.adoc">Ztso</a> — Total Store Ordering</td></tr>
</tbody></table>
</div><!-- Keep links near each table to make it easier to move and update. -->
<p>r[attributes.codegen.target_feature.wasm]</p>
<h4 id="wasm32-또는-wasm64"><a class="header" href="#wasm32-또는-wasm64"><code>wasm32</code> 또는 <code>wasm64</code></a></h4>
<p>Wasm 플랫폼에서 안전한(safe) <code>#[target_feature]</code> 함수는 항상 안전한 컨텍스트에서 사용될 수 있습니다. <code>#[target_feature]</code> 속성을 통해 정의되지 않은 동작을 유발하는 것은 불가능합니다. 왜냐하면 Wasm 엔진이 지원하지 않는 명령어를 사용하려는 시도는 로드 시점에 실패하며, 컴파일러가 예상한 것과 다르게 해석될 위험이 없기 때문입니다.</p>
<div class="table-wrapper"><table><thead><tr><th>기능(Feature)</th><th>암시적으로 활성화함</th><th>설명</th></tr></thead><tbody>
<tr><td><code>bulk-memory</code></td><td></td><td><a href="https://github.com/WebAssembly/bulk-memory-operations">WebAssembly 대량 메모리 연산 제안(bulk memory operations proposal)</a></td></tr>
<tr><td><code>extended-const</code></td><td></td><td><a href="https://github.com/WebAssembly/extended-const">WebAssembly 확장 상수 표현식 제안(extended const expressions proposal)</a></td></tr>
<tr><td><code>mutable-globals</code></td><td></td><td><a href="https://github.com/WebAssembly/mutable-global">WebAssembly 가변 전역 변수 제안(mutable global proposal)</a></td></tr>
<tr><td><code>nontrapping-fptoint</code></td><td></td><td><a href="https://github.com/WebAssembly/nontrapping-float-to-int-conversions">WebAssembly 비-트래핑 부동 소수점-정수 변환 제안(non-trapping float-to-int conversion proposal)</a></td></tr>
<tr><td><code>relaxed-simd</code></td><td><code>simd128</code></td><td><a href="https://github.com/WebAssembly/relaxed-simd">WebAssembly relaxed SIMD 제안</a></td></tr>
<tr><td><code>sign-ext</code></td><td></td><td><a href="https://github.com/WebAssembly/sign-extension-ops">WebAssembly 부호 확장 연산자 제안(sign extension operators Proposal)</a></td></tr>
<tr><td><code>simd128</code></td><td></td><td><a href="https://github.com/webassembly/simd">WebAssembly SIMD 제안</a></td></tr>
<tr><td><code>multivalue</code></td><td></td><td><a href="https://github.com/webassembly/multi-value">WebAssembly multivalue 제안</a></td></tr>
<tr><td><code>reference-types</code></td><td></td><td><a href="https://github.com/webassembly/reference-types">WebAssembly reference-types 제안</a></td></tr>
<tr><td><code>tail-call</code></td><td></td><td><a href="https://github.com/webassembly/tail-call">WebAssembly tail-call 제안</a></td></tr>
</tbody></table>
</div>
<p>r[attributes.codegen.target_feature.s390x]</p>
<h4 id="s390x"><a class="header" href="#s390x"><code>s390x</code></a></h4>
<p>On <code>s390x</code> targets, use of functions with the <code>#[target_feature]</code> attribute follows the [above restrictions][attributes.codegen.target_feature.safety-restrictions].</p>
<p>Further documentation on these features can be found in the “Additions to z/Architecture” section of Chapter 1 of the <em><a href="https://publibfp.dhe.ibm.com/epubs/pdf/a227832d.pdf">z/Architecture Principles of Operation</a></em>.</p>
<div class="table-wrapper"><table><thead><tr><th>기능(Feature)</th><th>암시적으로 활성화함</th><th>설명</th></tr></thead><tbody>
<tr><td><code>vector</code></td><td></td><td>128-bit vector instructions</td></tr>
<tr><td><code>vector-enhancements-1</code></td><td><code>vector</code></td><td>vector enhancements 1</td></tr>
<tr><td><code>vector-enhancements-2</code></td><td><code>vector-enhancements-1</code></td><td>vector enhancements 2</td></tr>
<tr><td><code>vector-enhancements-3</code></td><td><code>vector-enhancements-2</code></td><td>vector enhancements 3</td></tr>
<tr><td><code>vector-packed-decimal</code></td><td><code>vector</code></td><td>vector packed-decimal</td></tr>
<tr><td><code>vector-packed-decimal-enhancement</code></td><td><code>vector-packed-decimal</code></td><td>vector packed-decimal enhancement</td></tr>
<tr><td><code>vector-packed-decimal-enhancement-2</code></td><td><code>vector-packed-decimal-enhancement-2</code></td><td>vector packed-decimal enhancement 2</td></tr>
<tr><td><code>vector-packed-decimal-enhancement-3</code></td><td><code>vector-packed-decimal-enhancement-3</code></td><td>vector packed-decimal enhancement 3</td></tr>
<tr><td><code>nnp-assist</code></td><td><code>vector</code></td><td>nnp assist</td></tr>
<tr><td><code>miscellaneous-extensions-2</code></td><td></td><td>miscellaneous extensions 2</td></tr>
<tr><td><code>miscellaneous-extensions-3</code></td><td></td><td>miscellaneous extensions 3</td></tr>
<tr><td><code>miscellaneous-extensions-4</code></td><td></td><td>miscellaneous extensions 4</td></tr>
</tbody></table>
</div>
<p>r[attributes.codegen.target_feature.info]</p>
<h3 id="추가-정보"><a class="header" href="#추가-정보">추가 정보</a></h3>
<p>r[attributes.codegen.target_feature.remark-cfg] See the <a href="attributes/../conditional-compilation.html#target_feature"><code>target_feature</code> conditional compilation option</a> for selectively enabling or disabling compilation of code based on compile-time settings. Note that this option is not affected by the <code>target_feature</code> attribute, and is only driven by the features enabled for the entire crate.</p>
<p>r[attributes.codegen.target_feature.remark-rt] Whether a feature is enabled can be checked at runtime using a platform-specific macro from the standard library, for instance <a href="attributes/../../std/arch/macro.is_x86_feature_detected.html"><code>is_x86_feature_detected</code></a> or <a href="attributes/../../std/arch/macro.is_aarch64_feature_detected.html"><code>is_aarch64_feature_detected</code></a>.</p>
<blockquote>
<p>[!NOTE] <code>rustc</code> has a default set of features enabled for each target and CPU. The CPU may be chosen with the <a href="attributes/../../rustc/codegen-options/index.html#target-cpu"><code>-C target-cpu</code></a> flag. Individual features may be enabled or disabled for an entire crate with the <a href="attributes/../../rustc/codegen-options/index.html#target-feature"><code>-C target-feature</code></a> flag.</p>
</blockquote>
<p>r[attributes.codegen.track_caller]</p>
<h2 id="track_caller-속성"><a class="header" href="#track_caller-속성"><code>track_caller</code> 속성</a></h2>
<p>r[attributes.codegen.track_caller.allowed-positions] The <code>track_caller</code> attribute may be applied to any function with <a href="attributes/../items/external-blocks.html#abi"><code>"Rust"</code> ABI</a> with the exception of the entry point <code>fn main</code>.</p>
<p>r[attributes.codegen.track_caller.traits] When applied to functions and methods in trait declarations, the attribute applies to all implementations. If the trait provides a default implementation with the attribute, then the attribute also applies to override implementations.</p>
<p>r[attributes.codegen.track_caller.extern] When applied to a function in an <code>extern</code> block the attribute must also be applied to any linked implementations, otherwise undefined behavior results. When applied to a function which is made available to an <code>extern</code> block, the declaration in the <code>extern</code> block must also have the attribute, otherwise undefined behavior results.</p>
<p>r[attributes.codegen.track_caller.behavior]</p>
<h3 id="동작"><a class="header" href="#동작">동작</a></h3>
<p>Applying the attribute to a function <code>f</code> allows code within <code>f</code> to get a hint of the <a href="core::panic::Location"><code>Location</code></a> of the “topmost” tracked call that led to <code>f</code>’s invocation. At the point of observation, an implementation behaves as if it walks up the stack from <code>f</code>’s frame to find the nearest frame of an <em>unattributed</em> function <code>outer</code>, and it returns the <a href="core::panic::Location"><code>Location</code></a> of the tracked call in <code>outer</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[track_caller]
fn f() {
    println!("{}", std::panic::Location::caller());
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] <code>core</code> provides [<code>core::panic::Location::caller</code>] for observing caller locations. It wraps the [<code>core::intrinsics::caller_location</code>] intrinsic implemented by <code>rustc</code>.</p>
</blockquote>
<blockquote>
<p>[!NOTE] Because the resulting <code>Location</code> is a hint, an implementation may halt its walk up the stack early. See <a href="attributes/codegen.html#limitations">Limitations</a> for important caveats.</p>
</blockquote>
<h4 id="예시-2"><a class="header" href="#예시-2">예시</a></h4>
<p><code>f</code>가 <code>calls_f</code>에 의해 직접 호출될 때, <code>f</code> 내부의 코드는 <code>calls_f</code> 내의 호출 지점(callsite)을 관찰합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[track_caller]
</span><span class="boring">fn f() {
</span><span class="boring">    println!("{}", std::panic::Location::caller());
</span><span class="boring">}
</span>fn calls_f() {
    f(); // &lt;-- f()가 이 위치를 출력함
}
<span class="boring">}</span></code></pre></pre>
<p><code>f</code>가 속성이 붙은 다른 함수 <code>g</code>에 의해 호출되고, <code>g</code>가 다시 <code>calls_g</code>에 의해 호출될 때, <code>f</code>와 <code>g</code> 모두의 코드는 <code>calls_g</code> 내의 <code>g</code> 호출 지점을 관찰합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[track_caller]
</span><span class="boring">fn f() {
</span><span class="boring">    println!("{}", std::panic::Location::caller());
</span><span class="boring">}
</span>#[track_caller]
fn g() {
    println!("{}", std::panic::Location::caller());
    f();
}

fn calls_g() {
    g(); // &lt;-- g()가 이 위치를 두 번 출력함 (한 번은 자기 자신, 한 번은 f()로부터)
}
<span class="boring">}</span></code></pre></pre>
<p><code>g</code>가 속성이 붙은 다른 함수 <code>h</code>에 의해 호출되고, <code>h</code>가 다시 <code>calls_h</code>에 의해 호출될 때, <code>f</code>, <code>g</code>, <code>h</code> 내부의 모든 코드는 <code>calls_h</code> 내의 <code>h</code> 호출 지점을 관찰합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[track_caller]
</span><span class="boring">fn f() {
</span><span class="boring">    println!("{}", std::panic::Location::caller());
</span><span class="boring">}
</span><span class="boring">#[track_caller]
</span><span class="boring">fn g() {
</span><span class="boring">    println!("{}", std::panic::Location::caller());
</span><span class="boring">    f();
</span><span class="boring">}
</span>#[track_caller]
fn h() {
    println!("{}", std::panic::Location::caller());
    g();
}

fn calls_h() {
    h(); // &lt;-- 이 위치를 세 번 출력함 (한 번은 자기 자신, 한 번은 g()로부터, 한 번은 f()로부터)
}
<span class="boring">}</span></code></pre></pre>
<p>기타 등등.</p>
<p>r[attributes.codegen.track_caller.limits]</p>
<h3 id="제한-사항"><a class="header" href="#제한-사항">제한 사항</a></h3>
<p>r[attributes.codegen.track_caller.hint] This information is a hint and implementations are not required to preserve it.</p>
<p>r[attributes.codegen.track_caller.decay] In particular, coercing a function with <code>#[track_caller]</code> to a function pointer creates a shim which appears to observers to have been called at the attributed function’s definition site, losing actual caller information across virtual calls. A common example of this coercion is the creation of a trait object whose methods are attributed.</p>
<blockquote>
<p>[!NOTE] The aforementioned shim for function pointers is necessary because <code>rustc</code> implements <code>track_caller</code> in a codegen context by appending an implicit parameter to the function ABI, but this would be unsound for an indirect call because the parameter is not a part of the function’s type and a given function pointer type may or may not refer to a function with the attribute. The creation of a shim hides the implicit parameter from callers of the function pointer, preserving soundness.</p>
</blockquote>
<!-- template:attributes -->
<p>r[attributes.codegen.instruction_set]</p>
<h2 id="instruction_set-속성"><a class="header" href="#instruction_set-속성"><code>instruction_set</code> 속성</a></h2>
<p>r[attributes.codegen.instruction_set.intro] The <em><code>instruction_set</code> <a href="attributes/../attributes.html">attribute</a></em> specifies the instruction set that a function will use during code generation. This allows mixing more than one instruction set in a single program.</p>
<blockquote>
<p>[!EXAMPLE]</p>
<!-- ignore: arm-only -->
<pre><code class="language-rust ignore">#[instruction_set(arm::a32)]
fn arm_code() {}

#[instruction_set(arm::t32)]
fn thumb_code() {}</code></pre>
</blockquote>
<p>r[attributes.codegen.instruction_set.syntax] The <code>instruction_set</code> attribute uses the [MetaListPaths] syntax to specify a single path consisting of the architecture family name and instruction set name.</p>
<p>r[attributes.codegen.instruction_set.allowed-positions] The <code>instruction_set</code> attribute may only be applied to functions with <a href="attributes/items.fn.body">bodies</a> — <a href="attributes/expr.closure">closures</a>, <a href="attributes/expr.block.async">async blocks</a>, <a href="attributes/items.fn">free functions</a>, <a href="attributes/items.associated.fn">associated functions</a> in an <a href="attributes/items.impl.inherent">inherent impl</a> or <a href="attributes/items.impl.trait">trait impl</a>, and associated functions in a <a href="attributes/items.traits">trait definition</a> when those functions have a <a href="attributes/items.traits.associated-item-decls">default definition</a> .</p>
<blockquote>
<p>[!NOTE] <code>rustc</code> ignores use in other positions but lints against it. This may become an error in the future.</p>
</blockquote>
<blockquote>
<p>[!NOTE] Though the attribute can be applied to <a href="attributes/expr.closure">closures</a> and <a href="attributes/expr.block.async">async blocks</a>, the usefulness of this is limited as we do not yet support attributes on expressions.</p>
</blockquote>
<p>r[attributes.codegen.instruction_set.duplicates] The <code>instruction_set</code> attribute may be used only once on a function.</p>
<p>r[attributes.codegen.instruction_set.target-limits] The <code>instruction_set</code> attribute may only be used with a target that supports the given value.</p>
<p>r[attributes.codegen.instruction_set.inline-asm] When the <code>instruction_set</code> attribute is used, any inline assembly in the function must use the specified instruction set instead of the target default.</p>
<p>r[attributes.codegen.instruction_set.arm]</p>
<h3 id="instruction_set-on-arm"><a class="header" href="#instruction_set-on-arm"><code>instruction_set</code> on ARM</a></h3>
<p>When targeting the <code>ARMv4T</code> and <code>ARMv5te</code> architectures, the supported values for <code>instruction_set</code> are:</p>
<ul>
<li><code>arm::a32</code> — 함수를 A32 “ARM” 코드로 생성합니다.</li>
<li><code>arm::t32</code> — 함수를 T32 “Thumb” 코드로 생성합니다.</li>
</ul>
<p>If the address of the function is taken as a function pointer, the low bit of the address will depend on the selected instruction set:</p>
<ul>
<li>For <code>arm::a32</code> (“ARM”), it will be 0.</li>
<li>For <code>arm::t32</code> (“Thumb”), it will be 1.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>r[attributes.limits]</p>
<h1 id="제한"><a class="header" href="#제한">제한</a></h1>
<p>다음 <a href="attributes/../attributes.html">속성들</a>은 컴파일 타임 제한에 영향을 줍니다.</p>
<p>r[attributes.limits.recursion_limit]</p>
<h2 id="recursion_limit-속성"><a class="header" href="#recursion_limit-속성"><code>recursion_limit</code> 속성</a></h2>
<p>r[attributes.limits.recursion_limit.intro] The <em><code>recursion_limit</code> attribute</em> may be applied at the <a href="attributes/../crates-and-source-files.html">crate</a> level to set the maximum depth for potentially infinitely-recursive compile-time operations like macro expansion or auto-dereference.</p>
<p>r[attributes.limits.recursion_limit.syntax] It uses the [MetaNameValueStr] syntax to specify the recursion depth.</p>
<blockquote>
<p>[!NOTE] The default in <code>rustc</code> is 128.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span>#![recursion_limit = "4"]

<span class="boring">fn main() {
</span>macro_rules! a {
    () =&gt; { a!(1); };
    (1) =&gt; { a!(2); };
    (2) =&gt; { a!(3); };
    (3) =&gt; { a!(4); };
    (4) =&gt; { };
}

// 이는 4보다 큰 재귀 깊이를 요구하므로 확장에 실패합니다.
a!{}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span>#![recursion_limit = "1"]

<span class="boring">fn main() {
</span>// 이는 자동 역참조를 위해 두 번의 재귀 단계가 필요하므로 실패합니다.
(|_: &amp;u8| {})(&amp;&amp;&amp;1);
<span class="boring">}</span></code></pre></pre>
<!-- template:attributes -->
<p>r[attributes.limits.type_length_limit]</p>
<h2 id="type_length_limit-속성"><a class="header" href="#type_length_limit-속성"><code>type_length_limit</code> 속성</a></h2>
<p>r[attributes.limits.type_length_limit.intro] The <em><code>type_length_limit</code> <a href="attributes/../attributes.html">attribute</a></em> sets the maximum number of type substitutions allowed when constructing a concrete type during monomorphization.</p>
<blockquote>
<p>[!NOTE] <code>rustc</code> only enforces the limit when the nightly <code>-Zenforce-type-length-limit</code> flag is active.</p>
<p>For more information, see <a href="https://github.com/rust-lang/rust/pull/127670">Rust PR #127670</a>.</p>
</blockquote>
<blockquote>
<p>[!EXAMPLE]</p>
<!-- ignore: not enforced without nightly flag -->
<pre><code class="language-rust ignore">#![type_length_limit = "4"]

fn f&lt;T&gt;(x: T) {}

// This fails to compile because monomorphizing to
// `f::&lt;((((i32,), i32), i32), i32)&gt;` requires more
// than 4 type elements.
f(((((1,), 2), 3), 4));</code></pre>
</blockquote>
<blockquote>
<p>[!NOTE] The default value in <code>rustc</code> is <code>1048576</code>.</p>
</blockquote>
<p>r[attributes.limits.type_length_limit.syntax] The <code>type_length_limit</code> attribute uses the [MetaNameValueStr] syntax. The value in the string must be a non-negative number.</p>
<p>r[attributes.limits.type_length_limit.allowed-positions] The <code>type_length_limit</code> attribute may only be applied to the crate root.</p>
<blockquote>
<p>[!NOTE] <code>rustc</code> ignores use in other positions but lints against it. This may become an error in the future.</p>
</blockquote>
<p>r[attributes.limits.type_length_limit.duplicates] Only the first use of <code>type_length_limit</code> on an item has effect.</p>
<blockquote>
<p>[!NOTE] <code>rustc</code> lints against any use following the first. This may become an error in the future.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>r[attributes.type-system]</p>
<h1 id="타입-시스템-속성"><a class="header" href="#타입-시스템-속성">타입 시스템 속성</a></h1>
<p>다음 <a href="attributes/../attributes.html">속성들</a>은 타입이 사용되는 방식을 변경하는 데 사용됩니다.</p>
<p>r[attributes.type-system.non_exhaustive]</p>
<h2 id="non_exhaustive-속성"><a class="header" href="#non_exhaustive-속성"><code>non_exhaustive</code> 속성</a></h2>
<p>r[attributes.type-system.non_exhaustive.intro] The <em><code>non_exhaustive</code> attribute</em> indicates that a type or variant may have more fields or variants added in the future.</p>
<p>r[attributes.type-system.non_exhaustive.allowed-positions] It can be applied to <a href="attributes/../items/structs.html"><code>struct</code>s</a>, <a href="attributes/../items/enumerations.html"><code>enum</code>s</a>, and <code>enum</code> variants.</p>
<p>r[attributes.type-system.non_exhaustive.syntax] The <code>non_exhaustive</code> attribute uses the [MetaWord] syntax and thus does not take any inputs.</p>
<p>r[attributes.type-system.non_exhaustive.same-crate] Within the defining crate, <code>non_exhaustive</code> has no effect.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[non_exhaustive]
pub struct Config {
    pub window_width: u16,
    pub window_height: u16,
}

#[non_exhaustive]
pub struct Token;

#[non_exhaustive]
pub struct Id(pub u64);

#[non_exhaustive]
pub enum Error {
    Message(String),
    Other,
}

pub enum Message {
    #[non_exhaustive] Send { from: u32, to: u32, contents: String },
    #[non_exhaustive] Reaction(u32),
    #[non_exhaustive] Quit,
}

// 비완전(non-exhaustive) 구조체는 정의하는 크레이트 내에서 평소와 같이 생성될 수 있습니다.
let config = Config { window_width: 640, window_height: 480 };
let token = Token;
let id = Id(4);

// 비완전 구조체는 정의하는 크레이트 내에서 완전하게(exhaustively) 매칭될 수 있습니다.
let Config { window_width, window_height } = config;
let Token = token;
let Id(id_number) = id;

let error = Error::Other;
let message = Message::Reaction(3);

// 비완전 열거형은 정의하는 크레이트 내에서 완전하게 매칭될 수 있습니다.
match error {
    Error::Message(ref s) =&gt; { },
    Error::Other =&gt; { },
}

match message {
    // 비완전 변형은 정의하는 크레이트 내에서 완전하게 매칭될 수 있습니다.
    Message::Send { from, to, contents } =&gt; { },
    Message::Reaction(id) =&gt; { },
    Message::Quit =&gt; { },
}
<span class="boring">}</span></code></pre></pre>
<p>r[attributes.type-system.non_exhaustive.external-crate] Outside of the defining crate, types annotated with <code>non_exhaustive</code> have limitations that preserve backwards compatibility when new fields or variants are added.</p>
<p>r[attributes.type-system.non_exhaustive.construction] Non-exhaustive types cannot be constructed outside of the defining crate:</p>
<ul>
<li>Non-exhaustive variants (<a href="attributes/../items/structs.html"><code>struct</code></a> or <a href="attributes/../items/enumerations.html"><code>enum</code> variant</a>) cannot be constructed with a [StructExpression] (including with <a href="attributes/../expressions/struct-expr.html#functional-update-syntax">functional update syntax</a>).</li>
<li><a href="attributes/../items/structs.html">유닛 유사 구조체</a>의 암시적으로 정의된 동일 이름의 상수나, <a href="attributes/../items/structs.html">튜플 구조체</a>의 동일 이름의 생성자 함수는 <code>pub(crate)</code>보다 크지 않은 <a href="attributes/../visibility-and-privacy.html">가시성</a>을 가집니다. 즉, 구조체의 가시성이 <code>pub</code>인 경우 상수나 생성자의 가시성은 <code>pub(crate)</code>가 되며, 그 외의 경우 두 아이템의 가시성은 동일합니다 (<code>#[non_exhaustive]</code>가 없는 경우와 같습니다).</li>
<li><a href="attributes/../items/enumerations.html"><code>열거형(enum)</code></a> 인스턴스는 생성될 수 있습니다.</li>
</ul>
<p>정의하는 크레이트 외부에서는 다음과 같은 생성 예시들이 컴파일되지 않습니다.</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">// 이들은 업스트림 크레이트에서 `#[non_exhaustive]`가 주석 처리된 상태로 정의된 타입들입니다.
use upstream::{Config, Token, Id, Error, Message};

// `Config` 인스턴스를 생성할 수 없습니다. 만약 업스트림의 새로운 버전에서
// 새로운 필드가 추가된다면 컴파일에 실패할 것이므로, 이를 불허합니다.
let config = Config { window_width: 640, window_height: 480 };

// `Token` 인스턴스를 생성할 수 없습니다. 만약 새로운 필드가 추가된다면
// 더 이상 유닛 유사 구조체가 아닐 것이므로, 유닛 유사 구조체로서 생성된
// 동일 이름의 상수는 크레이트 외부에서 공개되지 않습니다.
// 이 코드는 컴파일에 실패합니다.
let token = Token;

// `Id` 인스턴스를 생성할 수 없습니다. 만약 새로운 필드가 추가된다면
// 생성자 함수의 시그니처가 변경될 것이므로, 생성자 함수가 크레이트 외부에서
// 공개되지 않습니다. 이 코드는 컴파일에 실패합니다.
let id = Id(5);

// `Error` 인스턴스는 생성할 수 있습니다. 새로운 변형이 도입되더라도
// 이 코드가 컴파일에 실패하는 결과로 이어지지는 않기 때문입니다.
let error = Error::Message("foo".to_string());

// `Message::Send` 또는 `Message::Reaction` 인스턴스를 생성할 수 없습니다.
// 만약 업스트림의 새로운 버전에서 새로운 필드가 추가된다면
// 컴파일에 실패할 것이므로, 이를 불허합니다.
let message = Message::Send { from: 0, to: 1, contents: "foo".to_string(), };
let message = Message::Reaction(0);

// Cannot construct an instance of `Message::Quit`; if this were converted to
// a tuple enum variant `upstream`, this would fail to compile.
let message = Message::Quit;</code></pre>
<p>r[attributes.type-system.non_exhaustive.match] There are limitations when matching on non-exhaustive types outside of the defining crate:</p>
<ul>
<li>When pattern matching on a non-exhaustive variant (<a href="attributes/../items/structs.html"><code>struct</code></a> or <a href="attributes/../items/enumerations.html"><code>enum</code> variant</a>), a [StructPattern] must be used which must include a <code>..</code>. A tuple enum variant’s constructor’s <a href="attributes/../visibility-and-privacy.html">visibility</a> is reduced to be no greater than <code>pub(crate)</code>.</li>
<li>When pattern matching on a non-exhaustive <a href="attributes/../items/enumerations.html"><code>enum</code></a>, matching on a variant does not contribute towards the exhaustiveness of the arms. The following examples of matching do not compile when outside the defining crate:</li>
</ul>
<!-- ignore: requires external crates -->
<pre><code class="language-rust  ignore">// 이들은 업스트림 크레이트에서 `#[non_exhaustive]`가 주석 처리된 상태로 정의된 타입들입니다.
use upstream::{Config, Token, Id, Error, Message};

// 와일드카드 암(arm)을 포함하지 않고는 비완전 열거형을 매칭할 수 없습니다.
match error {
  Error::Message(ref s) =&gt; { },
  Error::Other =&gt; { },
  // `_ =&gt; {},`를 추가하면 컴파일됩니다.
}

// 와일드카드 없이 비완전 구조체를 매칭할 수 없습니다.
if let Ok(Config { window_width, window_height }) = config {
    // `..`을 추가하면 컴파일됩니다.
}

// 중괄호 구조체 구문과 와일드카드를 사용하지 않고는 비완전 유닛 유사 또는 튜플 구조체를 매칭할 수 없습니다.
// 이는 `let Token { .. } = token;`으로 작성해야 컴파일됩니다.
let Token = token;
// 이는 `let Id { 0: id_number, .. } = id;`로 작성해야 컴파일됩니다.
let Id(id_number) = id;

match message {
  // 와일드카드를 포함하지 않고는 비완전 구조체형 열거형 변형을 매칭할 수 없습니다.
  Message::Send { from, to, contents } =&gt; { },
  // 비완전 튜플형 또는 유닛형 열거형 변형은 매칭할 수 없습니다.
  Message::Reaction(type) =&gt; { },
  Message::Quit =&gt; { },
}</code></pre>
<p>또한 하나 이상의 비완전 변형을 포함하는 열거형에 대해서는 숫자 캐스팅(<code>as</code>)을 사용하는 것이 허용되지 않습니다.</p>
<p>예를 들어, 다음 열거형은 비완전 변형을 포함하지 않으므로 캐스팅할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[non_exhaustive]
pub enum Example {
    First,
    Second
}
<span class="boring">}</span></code></pre></pre>
<p>하지만 열거형이 단 하나의 비완전 변형이라도 포함하고 있다면, 캐스팅은 에러가 됩니다. 동일한 열거형의 수정된 버전을 고려해 보세요.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[non_exhaustive]
pub enum EnumWithNonExhaustiveVariants {
    First,
    #[non_exhaustive]
    Second
}
<span class="boring">}</span></code></pre></pre>
<!-- ignore: needs multiple crates -->
<pre><code class="language-rust ignore">use othercrate::EnumWithNonExhaustiveVariants;

// 에러: 다른 크레이트에 정의된 비완전 변형을 가진 열거형은 캐스팅할 수 없습니다.
let _ = EnumWithNonExhaustiveVariants::First as u8;</code></pre>
<p>비완전 타입은 다운스트림 크레이트에서 항상 거주하는(inhabited) 타입으로 간주됩니다.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[attributes.debugger]</p>
<h1 id="디버거-속성"><a class="header" href="#디버거-속성">디버거 속성</a></h1>
<p>다음 <a href="attributes/../attributes.html">속성들</a>은 GDB나 WinDbg와 같은 서드파티 디버거를 사용할 때 디버깅 경험을 향상시키기 위해 사용됩니다.</p>
<!-- template:attributes -->
<p>r[attributes.debugger.debugger_visualizer]</p>
<h2 id="debugger_visualizer-속성"><a class="header" href="#debugger_visualizer-속성"><code>debugger_visualizer</code> 속성</a></h2>
<p>r[attributes.debugger.debugger_visualizer.intro] The <em><code>debugger_visualizer</code> <a href="attributes/../attributes.html">attribute</a></em> can be used to embed a debugger visualizer file into the debug information. This improves the debugger experience when displaying values.</p>
<blockquote>
<p>[!EXAMPLE]</p>
<!-- ignore: requires external files-->
<pre><code class="language-rust ignore">#![debugger_visualizer(natvis_file = "Example.natvis")]
#![debugger_visualizer(gdb_script_file = "example.py")]</code></pre>
</blockquote>
<p>r[attributes.debugger.debugger_visualizer.syntax] The <code>debugger_visualizer</code> attribute uses the [MetaListNameValueStr] syntax to specify its inputs. One of the following keys must be specified:</p>
<ul>
<li>[<code>natvis_file</code>][attributes.debugger.debugger_visualizer.natvis]</li>
<li>[<code>gdb_script_file</code>][attributes.debugger.debugger_visualizer.gdb]</li>
</ul>
<p>r[attributes.debugger.debugger_visualizer.allowed-positions] The <code>debugger_visualizer</code> attribute may only be applied to a <a href="attributes/../items/modules.html">module</a> or to the crate root.</p>
<p>r[attributes.debugger.debugger_visualizer.duplicates] The <code>debugger_visualizer</code> attribute may be used any number of times on a form. All specified visualizer files will be loaded.</p>
<p>r[attributes.debugger.debugger_visualizer.natvis]</p>
<h3 id="natvis와-함께-debugger_visualizer-사용하기"><a class="header" href="#natvis와-함께-debugger_visualizer-사용하기">Natvis와 함께 <code>debugger_visualizer</code> 사용하기</a></h3>
<p>r[attributes.debugger.debugger_visualizer.natvis.intro] Natvis is an XML-based framework for Microsoft debuggers (such as Visual Studio and WinDbg) that uses declarative rules to customize the display of types. For detailed information on the Natvis format, refer to Microsoft’s <a href="https://docs.microsoft.com/en-us/visualstudio/debugger/create-custom-views-of-native-objects">Natvis documentation</a>.</p>
<p>r[attributes.debugger.debugger_visualizer.natvis.msvc] This attribute only supports embedding Natvis files on <code>-windows-msvc</code> targets.</p>
<p>r[attributes.debugger.debugger_visualizer.natvis.path] The path to the Natvis file is specified with the <code>natvis_file</code> key, which is a path relative to the source file.</p>
<blockquote>
<p>[!EXAMPLE]</p>
<!-- ignore: requires external files and msvc -->
<pre><code class="language-rust ignore">#![debugger_visualizer(natvis_file = "Rectangle.natvis")]

struct FancyRect {
    x: f32,
    y: f32,
    dx: f32,
    dy: f32,
}

fn main() {
    let fancy_rect = FancyRect { x: 10.0, y: 10.0, dx: 5.0, dy: 5.0 };
    println!("set breakpoint here");
}</code></pre>
<p><code>Rectangle.natvis</code> contains:</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;AutoVisualizer xmlns="http://schemas.microsoft.com/vstudio/debugger/natvis/2010"&gt;
    &lt;Type Name="foo::FancyRect"&gt;
      &lt;DisplayString&gt;({x},{y}) + ({dx}, {dy})&lt;/DisplayString&gt;
      &lt;Expand&gt;
        &lt;Synthetic Name="LowerLeft"&gt;
          &lt;DisplayString&gt;({x}, {y})&lt;/DisplayString&gt;
        &lt;/Synthetic&gt;
        &lt;Synthetic Name="UpperLeft"&gt;
          &lt;DisplayString&gt;({x}, {y + dy})&lt;/DisplayString&gt;
        &lt;/Synthetic&gt;
        &lt;Synthetic Name="UpperRight"&gt;
          &lt;DisplayString&gt;({x + dx}, {y + dy})&lt;/DisplayString&gt;
        &lt;/Synthetic&gt;
        &lt;Synthetic Name="LowerRight"&gt;
          &lt;DisplayString&gt;({x + dx}, {y})&lt;/DisplayString&gt;
        &lt;/Synthetic&gt;
      &lt;/Expand&gt;
    &lt;/Type&gt;
&lt;/AutoVisualizer&gt;
</code></pre>
<p>WinDbg에서 볼 때, <code>fancy_rect</code> 변수는 다음과 같이 표시될 것입니다:</p>
<pre><code class="language-text">&gt; Variables:
  &gt; fancy_rect: (10.0, 10.0) + (5.0, 5.0)
    &gt; LowerLeft: (10.0, 10.0)
    &gt; UpperLeft: (10.0, 15.0)
    &gt; UpperRight: (15.0, 15.0)
    &gt; LowerRight: (15.0, 10.0)
</code></pre>
</blockquote>
<p>r[attributes.debugger.debugger_visualizer.gdb]</p>
<h3 id="gdb와-함께-debugger_visualizer-사용하기"><a class="header" href="#gdb와-함께-debugger_visualizer-사용하기">GDB와 함께 <code>debugger_visualizer</code> 사용하기</a></h3>
<p>r[attributes.debugger.debugger_visualizer.gdb.pretty] GDB supports the use of a structured Python script, called a <em>pretty printer</em>, that describes how a type should be visualized in the debugger view. For detailed information on pretty printers, refer to GDB’s <a href="https://sourceware.org/gdb/onlinedocs/gdb/Pretty-Printing.html">pretty printing documentation</a>.</p>
<blockquote>
<p>[!NOTE] Embedded pretty printers are not automatically loaded when debugging a binary under GDB.</p>
<p>There are two ways to enable auto-loading embedded pretty printers:</p>
<ol>
<li>자동 로드 안전 경로에 디렉터리나 바이너리를 명시적으로 추가하기 위해 추가 인수를 사용하여 GDB를 실행합니다: <code>gdb -iex "add-auto-load-safe-path safe-path path/to/binary" path/to/binary</code>. 자세한 내용은 GDB의 <a href="https://sourceware.org/gdb/onlinedocs/gdb/Auto_002dloading-safe-path.html">자동 로드 문서</a>를 참조하세요.</li>
<li><code>$HOME/.config/gdb</code> 아래에 <code>gdbinit</code>이라는 파일을 생성합니다(디렉터리가 없으면 생성해야 할 수도 있습니다). 해당 파일에 다음 라인을 추가합니다: <code>add-auto-load-safe-path path/to/binary</code>.</li>
</ol>
</blockquote>
<p>r[attributes.debugger.debugger_visualizer.gdb.path] These scripts are embedded using the <code>gdb_script_file</code> key, which is a path relative to the source file.</p>
<blockquote>
<p>[!EXAMPLE]</p>
<!-- ignore: requires external files -->
<pre><code class="language-rust ignore">#![debugger_visualizer(gdb_script_file = "printer.py")]

struct Person {
    name: String,
    age: i32,
}

fn main() {
    let bob = Person { name: String::from("Bob"), age: 10 };
    println!("set breakpoint here");
}</code></pre>
<p><code>printer.py</code> contains:</p>
<pre><code class="language-python">import gdb

class PersonPrinter:
    "Person 출력"

    def __init__(self, val):
        self.val = val
        self.name = val["이름"]
        self.age = int(val["나이"])

    def to_string(self):
        return "{}는 {}살입니다.".format(self.name, self.age)

def lookup(val):
    lookup_tag = val.type.tag
    if lookup_tag is None:
        return None
    if "foo::Person" == lookup_tag:
        return PersonPrinter(val)

    return None

gdb.current_objfile().pretty_printers.append(lookup)
</code></pre>
<p>크레이트의 디버그 실행 파일이 GDB<sup class="footnote-reference"><a href="#rust-gdb">1</a></sup>로 전달되면, <code>print bob</code>은 다음과 같이 표시될 것입니다:</p>
<pre><code class="language-text">"Bob" is 10 years old.
</code></pre>
<div class="footnote-definition" id="rust-gdb"><sup class="footnote-definition-label">1</sup>
<p>참고: 이는 <code>String</code>과 같은 표준 라이브러리 타입에 대해 프리티 프린터를 구성하는 <code>rust-gdb</code> 스크립트를 사용하고 있다고 가정합니다.</p>
</div>
</blockquote>
<!-- template:attributes -->
<p>r[attributes.debugger.collapse_debuginfo]</p>
<h2 id="collapse_debuginfo-속성"><a class="header" href="#collapse_debuginfo-속성"><code>collapse_debuginfo</code> 속성</a></h2>
<p>r[attributes.debugger.collapse_debuginfo.intro] The <em><code>collapse_debuginfo</code> <a href="attributes/../attributes.html">attribute</a></em> controls whether code locations from a macro definition are collapsed into a single location associated with the macro’s call site when generating debuginfo for code calling this macro.</p>
<blockquote>
<p>[!EXAMPLE]</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[collapse_debuginfo(yes)]
macro_rules! example {
    () =&gt; {
        println!("hello!");
    };
}
<span class="boring">}</span></code></pre></pre>
<p>When using a debugger, invoking the <code>example</code> macro may appear as though it is calling a function. That is, when you step to the invocation site, it may show the macro invocation rather than the expanded code.</p>
</blockquote>
<!-- TODO: I think it would be nice to extend this to explain a little more about why this is useful, and the kinds of scenarios where you would want one vs the other. See https://github.com/rust-lang/rfcs/pull/2117 for some guidance. -->
<p>r[attributes.debugger.collapse_debuginfo.syntax] The syntax for the <code>collapse_debuginfo</code> attribute is:</p>
<pre><code class="language-grammar attributes">@root CollapseDebuginfoAttribute -&gt; `collapse_debuginfo` `(` CollapseDebuginfoOption `)`

CollapseDebuginfoOption -&gt;
      `yes`
    | `no`
    | `external`
</code></pre>
<p>r[attributes.debugger.collapse_debuginfo.allowed-positions] The <code>collapse_debuginfo</code> attribute may only be applied to a <a href="attributes/../macros-by-example.html"><code>macro_rules</code> definition</a>.</p>
<p>r[attributes.debugger.collapse_debuginfo.duplicates] The <code>collapse_debuginfo</code> attribute may used only once on a macro.</p>
<p>r[attributes.debugger.collapse_debuginfo.options] The <code>collapse_debuginfo</code> attribute accepts these options:</p>
<ul>
<li><code>#[collapse_debuginfo(yes)]</code> — Code locations in debuginfo are collapsed.</li>
<li><code>#[collapse_debuginfo(no)]</code> — Code locations in debuginfo are not collapsed.</li>
<li><code>#[collapse_debuginfo(external)]</code> — Code locations in debuginfo are collapsed only if the macro comes from a different crate.</li>
</ul>
<p>r[attributes.debugger.collapse_debuginfo.default] The <code>external</code> behavior is the default for macros that don’t have this attribute unless they are built-in macros. For built-in macros the default is <code>yes</code>.</p>
<blockquote>
<p>[!NOTE] <code>rustc</code> has a <a href="attributes/../../rustc/codegen-options/index.html#collapse-macro-debuginfo"><code>-C collapse-macro-debuginfo</code></a> CLI option to override both the default behavior and the values of any <code>#[collapse_debuginfo]</code> attributes.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>r[stmt-expr]</p>
<h1 id="구문과-표현식"><a class="header" href="#구문과-표현식">구문과 표현식</a></h1>
<p>Rust는 <em>주로</em> 표현식(expression) 언어입니다. 이는 대부분의 값을 생성하거나 부수 효과를 일으키는 평가가 _표현식_이라는 통일된 구문 범주에 의해 유도됨을 의미합니다. 각 종류의 표현식은 일반적으로 다른 종류의 표현식 내에 _중첩_될 수 있으며, 표현식의 평가 규칙에는 표현식에 의해 생성되는 값과 그 하위 표현식들이 평가되는 순서를 모두 명시하는 것이 포함됩니다.</p>
<p>반면, 구문(statement)은 <em>주로</em> 표현식 평가를 포함하고 명시적으로 순서를 지정하는 역할을 합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[statement]</p>
<h1 id="구문"><a class="header" href="#구문">구문</a></h1>
<p>r[statement.syntax]</p>
<pre><code class="language-grammar statements">Statement -&gt;
      `;`
    | Item
    | LetStatement
    | ExpressionStatement
    | OuterAttribute* MacroInvocationSemi
</code></pre>
<p>r[statement.intro] A <em>statement</em> is a component of a <a href="expressions/block-expr.html">block</a>, which is in turn a component of an outer <a href="expressions.html">expression</a> or <a href="items/functions.html">function</a>.</p>
<p>r[statement.kind] Rust has two kinds of statement: <a href="statements.html#declaration-statements">declaration statements</a> and <a href="statements.html#expression-statements">expression statements</a>.</p>
<p>r[statement.decl]</p>
<h2 id="선언-구문"><a class="header" href="#선언-구문">선언 구문</a></h2>
<p>_선언 구문(declaration statement)_은 둘러싼 구문 블록에 하나 이상의 _이름_을 도입하는 구문입니다. 선언된 이름은 새로운 변수나 새로운 <a href="items.html">아이템</a>을 나타낼 수 있습니다.</p>
<p>선언 구문의 두 가지 종류는 아이템 선언과 <code>let</code> 구문입니다.</p>
<p>r[statement.item]</p>
<h3 id="아이템-선언"><a class="header" href="#아이템-선언">아이템 선언</a></h3>
<p>r[statement.item.intro] An <em>item declaration statement</em> has a syntactic form identical to an <a href="items.html">item declaration</a> within a <a href="items/modules.html">module</a>.</p>
<p>r[statement.item.scope] Declaring an item within a statement block restricts its <a href="names/scopes.html">scope</a> to the block containing the statement. The item is not given a <a href="paths.html#canonical-paths">canonical path</a> nor are any sub-items it may declare.</p>
<p>r[statement.item.associated-scope] The exception to this is that associated items defined by <a href="items/implementations.html">implementations</a> are still accessible in outer scopes as long as the item and, if applicable, trait are accessible. It is otherwise identical in meaning to declaring the item inside a module.</p>
<p>r[statement.item.outer-generics] There is no implicit capture of the containing function’s generic parameters, parameters, and local variables. For example, <code>inner</code> may not access <code>outer_var</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn outer() {
  let outer_var = true;

  fn inner() { /* 여기서 outer_var는 스코프에 없습니다 */ }

  inner();
}
<span class="boring">}</span></code></pre></pre>
<p>r[statement.let]</p>
<h3 id="let-구문"><a class="header" href="#let-구문"><code>let</code> 구문</a></h3>
<p>r[statement.let.syntax]</p>
<pre><code class="language-grammar statements">LetStatement -&gt;
    OuterAttribute* `let` PatternNoTopAlt ( `:` Type )?
    (
          `=` Expression
        | `=` Expression _except [LazyBooleanExpression] or end with a `}`_ `else` BlockExpression
    )? `;`
</code></pre>
<p>r[statement.let.intro] A <em><code>let</code> statement</em> introduces a new set of <a href="variables.html">variables</a>, given by a <a href="patterns.html">pattern</a>. The pattern is followed optionally by a type annotation and then either ends, or is followed by an initializer expression plus an optional <code>else</code> block.</p>
<p>r[statement.let.inference] When no type annotation is given, the compiler will infer the type, or signal an error if insufficient type information is available for definite inference.</p>
<p>r[statement.let.scope] Any variables introduced by a variable declaration are visible from the point of declaration until the end of the enclosing block scope, except when they are shadowed by another variable declaration.</p>
<p>r[statement.let.constraint] If an <code>else</code> block is not present, the pattern must be irrefutable. If an <code>else</code> block is present, the pattern may be refutable.</p>
<p>r[statement.let.behavior] If the pattern does not match (this requires it to be refutable), the <code>else</code> block is executed. The <code>else</code> block must always diverge (evaluate to the <a href="types/never.html">never type</a>).</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (mut v, w) = (vec![1, 2, 3], 42); // 바인딩은 mut 또는 const일 수 있습니다
let Some(t) = v.pop() else { // 반박 가능한 패턴은 else 블록을 요구합니다
    panic!(); // else 블록은 반드시 발산해야 합니다
};
let [u, v] = [v[0], v[1]] else { // 이 패턴은 반박 불가능하므로, 컴파일러는 else 블록이
                                 // 불필요하다는 린트를 발생시킬 것입니다.
    panic!();
};
<span class="boring">}</span></code></pre></pre>
<p>r[statement.expr]</p>
<h2 id="표현식-구문"><a class="header" href="#표현식-구문">표현식 구문</a></h2>
<p>r[statement.expr.syntax]</p>
<pre><code class="language-grammar statements">ExpressionStatement -&gt;
      ExpressionWithoutBlock `;`
    | ExpressionWithBlock `;`?
</code></pre>
<p>r[statement.expr.intro] An <em>expression statement</em> is one that evaluates an <a href="expressions.html">expression</a> and ignores its result. As a rule, an expression statement’s purpose is to trigger the effects of evaluating its expression.</p>
<p>r[statement.expr.restriction-semicolon] An expression that consists of only a <a href="expressions/block-expr.html">block expression</a> or control flow expression, if used in a context where a statement is permitted, can omit the trailing semicolon. This can cause an ambiguity between it being parsed as a standalone statement and as a part of another expression; in this case, it is parsed as a statement.</p>
<p>r[statement.expr.constraint-block] The type of [ExpressionWithBlock] expressions when used as statements must be the unit type.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let mut v = vec![1, 2, 3];
</span>v.pop();          // pop에서 반환된 요소를 무시합니다
if v.is_empty() {
    v.push(5);
} else {
    v.remove(0);
}                 // 세미콜론은 생략될 수 있습니다.
[1];              // 별개의 표현식 구문이며, 인덱싱 표현식이 아닙니다.
<span class="boring">}</span></code></pre></pre>
<p>마지막 세미콜론이 생략된 경우, 결과는 반드시 <code>()</code> 타입이어야 합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 나쁨: 블록의 타입이 ()가 아니라 i32임
// 에러: 기본 반환 타입 때문에 `()`가 기대됨
// if true {
//   1
// }

// 좋음: 블록의 타입이 i32임
if true {
  1
} else {
  2
};
<span class="boring">}</span></code></pre></pre>
<p>r[statement.attribute]</p>
<h2 id="attributes-on-statements"><a class="header" href="#attributes-on-statements">Attributes on statements</a></h2>
<p>구문은 <a href="attributes.html">외부 속성</a>을 허용합니다. 구문에서 의미를 갖는 속성은 <a href="conditional-compilation.html"><code>cfg</code></a>와 <a href="attributes/diagnostics.html#lint-check-attributes">린트 체크 속성</a>입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[expr]</p>
<h1 id="표현식"><a class="header" href="#표현식">표현식</a></h1>
<p>r[expr.syntax]</p>
<pre><code class="language-grammar expressions">Expression -&gt;
      ExpressionWithoutBlock
    | ExpressionWithBlock

ExpressionWithoutBlock -&gt;
    OuterAttribute*
    (
        LiteralExpression
      | PathExpression
      | OperatorExpression
      | GroupedExpression
      | ArrayExpression
      | AwaitExpression
      | IndexExpression
      | TupleExpression
      | TupleIndexingExpression
      | StructExpression
      | CallExpression
      | MethodCallExpression
      | FieldExpression
      | ClosureExpression
      | AsyncBlockExpression
      | ContinueExpression
      | BreakExpression
      | RangeExpression
      | ReturnExpression
      | UnderscoreExpression
      | MacroInvocation
    )

ExpressionWithBlock -&gt;
    OuterAttribute*
    (
        BlockExpression
      | ConstBlockExpression
      | UnsafeBlockExpression
      | LoopExpression
      | IfExpression
      | MatchExpression
    )
</code></pre>
<p>r[expr.intro] An expression may have two roles: it always produces a <em>value</em>, and it may have <em>effects</em> (otherwise known as “side effects”).</p>
<p>r[expr.evaluation] An expression <em>evaluates to</em> a value, and has effects during <em>evaluation</em>.</p>
<p>r[expr.operands] Many expressions contain sub-expressions, called the <em>operands</em> of the expression.</p>
<p>r[expr.behavior] The meaning of each kind of expression dictates several things:</p>
<ul>
<li>표현식을 평가할 때 피연산자를 평가할지 여부</li>
<li>피연산자를 평가하는 순서</li>
<li>표현식의 값을 얻기 위해 피연산자들의 값을 결합하는 방법</li>
</ul>
<p>r[expr.structure] In this way, the structure of expressions dictates the structure of execution. Blocks are just another kind of expression, so blocks, statements, expressions, and blocks again can recursively nest inside each other to an arbitrary depth.</p>
<blockquote>
<p>[!NOTE] We give names to the operands of expressions so that we may discuss them, but these names are not stable and may be changed.</p>
</blockquote>
<p>r[expr.precedence]</p>
<h2 id="표현식-우선순위"><a class="header" href="#표현식-우선순위">표현식 우선순위</a></h2>
<p>Rust 연산자와 표현식의 우선순위는 다음과 같으며, 강한 것부터 약한 것 순으로 나열되어 있습니다. 동일한 우선순위 수준의 이항 연산자들은 그들의 결합성(associativity)에 따라 그룹화됩니다.</p>
<div class="table-wrapper"><table><thead><tr><th>연산자/표현식</th><th>결합성</th></tr></thead><tbody>
<tr><td>[Paths][expr.path]</td><td></td></tr>
<tr><td>[Method calls][expr.method]</td><td></td></tr>
<tr><td>[Field expressions][expr.field]</td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td>[Function calls][expr.call], [array indexing][expr.array.index]</td><td></td></tr>
<tr><td>[<code>?</code>][expr.try]</td><td></td></tr>
<tr><td>Unary [<code>-</code>][expr.negate] [<code>!</code>][expr.negate] [<code>*</code>][expr.deref] [borrow][expr.operator.borrow]</td><td></td></tr>
<tr><td>[<code>as</code>][expr.as]</td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td>[<code>*</code>][expr.arith-logic] [<code>/</code>][expr.arith-logic] [<code>%</code>][expr.arith-logic]</td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td>[<code>+</code>][expr.arith-logic] [<code>-</code>][expr.arith-logic]</td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td>[<code>&lt;&lt;</code>][expr.arith-logic] [<code>&gt;&gt;</code>][expr.arith-logic]</td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td>[<code>&amp;</code>][expr.arith-logic]</td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td>[<code>^</code>][expr.arith-logic]</td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td>[<code>|</code>][expr.arith-logic]</td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td>[<code>==</code>][expr.cmp] [<code>!=</code>][expr.cmp] [<code>&lt;</code>][expr.cmp] [<code>&gt;</code>][expr.cmp] [<code>&lt;=</code>][expr.cmp] [<code>&gt;=</code>][expr.cmp]</td><td>괄호 필요</td></tr>
<tr><td>[<code>&amp;&amp;</code>][expr.bool-logic]</td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td>[<code>||</code>][expr.bool-logic]</td><td>왼쪽에서 오른쪽으로</td></tr>
<tr><td>[<code>..</code>][expr.range] [<code>..=</code>][expr.range]</td><td>괄호 필요</td></tr>
<tr><td>[<code>=</code>][expr.assign] [<code>+=</code>][expr.compound-assign] [<code>-=</code>][expr.compound-assign] [<code>*=</code>][expr.compound-assign] [<code>/=</code>][expr.compound-assign] [<code>%=</code>][expr.compound-assign] <br> [<code>&amp;=</code>][expr.compound-assign] [<code>|=</code>][expr.compound-assign] [<code>^=</code>][expr.compound-assign] [<code>&lt;&lt;=</code>][expr.compound-assign] [<code>&gt;&gt;=</code>][expr.compound-assign]</td><td>오른쪽에서 왼쪽으로</td></tr>
<tr><td>[<code>return</code>][expr.return] [<code>break</code>][expr.loop.break] [closures][expr.closure]</td><td></td></tr>
</tbody></table>
</div>
<p>r[expr.operand-order]</p>
<h2 id="피연산자의-평가-순서"><a class="header" href="#피연산자의-평가-순서">피연산자의 평가 순서</a></h2>
<p>r[expr.operand-order.default] The following list of expressions all evaluate their operands the same way, as described after the list. Other expressions either don’t take operands or evaluate them conditionally as described on their respective pages.</p>
<ul>
<li>역참조 표현식</li>
<li>에러 전파 표현식</li>
<li>부정 표현식</li>
<li>산술 및 논리 이항 연산자</li>
<li>비교 연산자</li>
<li>타입 캐스트 표현식</li>
<li>그룹화된 표현식</li>
<li>배열 표현식</li>
<li>Await 표현식</li>
<li>인덱스 표현식</li>
<li>튜플 표현식</li>
<li>튜플 인덱스 표현식</li>
<li>구조체 표현식</li>
<li>호출 표현식</li>
<li>메서드 호출 표현식</li>
<li>필드 표현식</li>
<li>Break 표현식</li>
<li>범위 표현식</li>
<li>Return 표현식</li>
</ul>
<p>r[expr.operand-order.operands-before-primary] The operands of these expressions are evaluated prior to applying the effects of the expression. Expressions taking multiple operands are evaluated left to right as written in the source code.</p>
<blockquote>
<p>[!NOTE] Which subexpressions are the operands of an expression is determined by expression precedence as per the previous section.</p>
</blockquote>
<p>예를 들어, 두 개의 <code>next</code> 메서드 호출은 항상 동일한 순서로 호출됩니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">// 참조를 피하기 위해 배열 대신 vec를 사용합니다.
</span><span class="boring">// 이 예제가 작성된 시점에는 안정적인 소유권 있는(owned) 배열 반복자가
</span><span class="boring">// 없었기 때문입니다.
</span>let mut one_two = vec![1, 2].into_iter();
assert_eq!(
    (1, 2),
    (one_two.next().unwrap(), one_two.next().unwrap())
);
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] Since this is applied recursively, these expressions are also evaluated from innermost to outermost, ignoring siblings until there are no inner subexpressions.</p>
</blockquote>
<p>r[expr.place-value]</p>
<h2 id="place-expressions-and-value-expressions"><a class="header" href="#place-expressions-and-value-expressions">Place expressions and value expressions</a></h2>
<p>r[expr.place-value.intro] Expressions are divided into two main categories: place expressions and value expressions; there is also a third, minor category of expressions called assignee expressions. Within each expression, operands may likewise occur in either place context or value context. The evaluation of an expression depends both on its own category and the context it occurs within.</p>
<p>r[expr.place-value.place-memory-location] A <em>place expression</em> is an expression that represents a memory location.</p>
<p>r[expr.place-value.place-expr-kinds] These expressions are <a href="expressions/path-expr.html">paths</a> which refer to local variables, <a href="items/static-items.html">static variables</a>, <a href="expressions/operator-expr.html#the-dereference-operator">dereferences</a> (<code>*expr</code>), <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">array indexing</a> expressions (<code>expr[expr]</code>), <a href="expressions/field-expr.html">field</a> references (<code>expr.f</code>) and parenthesized place expressions.</p>
<p>r[expr.place-value.value-expr-kinds] All other expressions are value expressions.</p>
<p>r[expr.place-value.value-result] A <em>value expression</em> is an expression that represents an actual value.</p>
<p>r[expr.place-value.place-context] The following contexts are <em>place expression</em> contexts:</p>
<ul>
<li><a href="expressions/operator-expr.html#compound-assignment-expressions">복합 할당(compound assignment)</a> 표현식의 왼쪽 피연산자.</li>
<li>단항 <a href="expressions/operator-expr.html#borrow-operators">차용(borrow)</a>, <a href="expressions/operator-expr.html#raw-borrow-operators">원시 차용(raw borrow)</a> 또는 <a href="expressions/operator-expr.html#the-dereference-operator">역참조(dereference)</a> 연산자의 피연산자.</li>
<li>필드 표현식의 피연산자.</li>
<li>배열 인덱싱 표현식의 인덱스된 피연산자.</li>
<li>임의의 <a href="expressions.html#implicit-borrows">암시적 차용(implicit borrow)</a>의 피연산자.</li>
<li><a href="statements.html#let-statements">let 문</a>의 초기화 식(initializer).</li>
<li>The <a href="glossary.html#scrutinee">scrutinee</a> of an <a href="expressions/if-expr.html#if-let-patterns"><code>if let</code></a>, <a href="expressions/match-expr.html"><code>match</code></a>, or <a href="expressions/loop-expr.html#while-let-patterns"><code>while let</code></a> expression.</li>
<li><a href="expressions/struct-expr.html#functional-update-syntax">함수형 업데이트(functional update)</a> 구조체 표현식의 베이스(base).</li>
</ul>
<blockquote>
<p>[!NOTE] Historically, place expressions were called <em>lvalues</em> and value expressions were called <em>rvalues</em>.</p>
</blockquote>
<p>r[expr.place-value.assignee] An <em>assignee expression</em> is an expression that appears in the left operand of an <a href="expressions/operator-expr.html#assignment-expressions">assignment</a> expression. Explicitly, the assignee expressions are:</p>
<ul>
<li>장소 표현식.</li>
<li><a href="expressions/underscore-expr.html">밑줄(Underscores)</a>.</li>
<li>피할당자 표현식의 <a href="expressions/tuple-expr.html">튜플</a>.</li>
<li>[Slices][expr.array.index] of assignee expressions.</li>
<li><a href="items.struct.tuple">Tuple structs</a> of assignee expressions.</li>
<li><a href="expr.struct">Structs</a> of assignee expressions (with optionally named fields).</li>
<li><a href="items.struct.unit">Unit structs</a></li>
</ul>
<p>r[expr.place-value.parenthesis] Arbitrary parenthesisation is permitted inside assignee expressions.</p>
<p>r[expr.move]</p>
<h3 id="이동-및-복사-타입"><a class="header" href="#이동-및-복사-타입">이동 및 복사 타입</a></h3>
<p>r[expr.move.intro] When a place expression is evaluated in a value expression context, or is bound by value in a pattern, it denotes the value held <em>in</em> that memory location.</p>
<p>r[expr.move.copy] If the type of that value implements <a href="special-types-and-traits.html#copy"><code>Copy</code></a>, then the value will be copied.</p>
<p>r[expr.move.requires-sized] In the remaining situations, if that type is <a href="special-types-and-traits.html#sized"><code>Sized</code></a>, then it may be possible to move the value.</p>
<p>r[expr.move.movable-place] Only the following place expressions may be moved out of:</p>
<ul>
<li>현재 차용(borrow)되지 않은 <a href="variables.html">변수</a>.</li>
<li><a href="expressions.html#temporaries">임시 값</a>.</li>
<li>값을 이동시킬 수 있는 장소 표현식의 <a href="expressions/field-expr.html">필드</a>들 중 <a href="special-types-and-traits.html#drop"><code>Drop</code></a>을 구현하지 않은 것.</li>
<li>The result of <a href="expressions/operator-expr.html#the-dereference-operator">dereferencing</a> an expression with type [<code>Box&lt;T&gt;</code>] and that can also be moved out of.</li>
</ul>
<p>r[expr.move.deinitialization] After moving out of a place expression that evaluates to a local variable, the location is deinitialized and cannot be read from again until it is reinitialized.</p>
<p>r[expr.move.place-invalid] In all other cases, trying to use a place expression in a value expression context is an error.</p>
<p>r[expr.mut]</p>
<h3 id="가변성mutability"><a class="header" href="#가변성mutability">가변성(Mutability)</a></h3>
<p>r[expr.mut.intro] For a place expression to be <a href="expressions/operator-expr.html#assignment-expressions">assigned</a> to, mutably <a href="expressions/operator-expr.html#borrow-operators">borrowed</a>, <a href="expressions.html#implicit-borrows">implicitly mutably borrowed</a>, or bound to a pattern containing <code>ref mut</code>, it must be <em>mutable</em>. We call these <em>mutable place expressions</em>. In contrast, other place expressions are called <em>immutable place expressions</em>.</p>
<p>r[expr.mut.valid-places] The following expressions can be mutable place expression contexts:</p>
<ul>
<li>현재 차용되지 않은 가변 <a href="variables.html">변수(variables)</a>.</li>
<li><a href="items/static-items.html#mutable-statics">가변 <code>static</code> 아이템</a>.</li>
<li><a href="expressions.html#temporaries">임시 값</a>.</li>
<li><a href="expressions/field-expr.html">필드(Fields)</a>: 이는 하위 표현식을 가변 장소 표현식 컨텍스트에서 평가합니다.</li>
<li><code>*mut T</code> 포인터의 <a href="expressions/operator-expr.html#the-dereference-operator">역참조(Dereferences)</a>.</li>
<li><code>&amp;mut T</code> 타입을 가진 변수 또는 변수 필드의 역참조. 참고: 이는 다음 규칙의 요구 사항에 대한 예외입니다.</li>
<li><code>DerefMut</code>를 구현하는 타입의 역참조: 이는 역참조되는 값이 가변 장소 표현식 컨텍스트에서 평가될 것을 요구합니다.</li>
<li><code>IndexMut</code>를 구현하는 타입의 <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">배열 인덱싱(Array indexing)</a>: 이는 인덱싱되는 값을 가변 장소 표현식 컨텍스트에서 평가하지만, 인덱스는 그렇지 않습니다.</li>
</ul>
<p>r[expr.temporary]</p>
<h3 id="임시-값temporaries"><a class="header" href="#임시-값temporaries">임시 값(Temporaries)</a></h3>
<p>대부분의 장소 표현식 컨텍스트에서 값 표현식을 사용할 때, 이름 없는 임시 메모리 위치가 생성되고 해당 값으로 초기화됩니다. 표현식은 <code>static</code>으로 <a href="destructors.html#constant-promotion">승격(promoted)</a>되지 않는 한 해당 위치로 평가됩니다. 임시 값의 <a href="destructors.html#drop-scopes">드롭 스코프(drop scope)</a>는 보통 이를 둘러싼 구문의 끝입니다.</p>
<p>r[expr.super-macros]</p>
<h3 id="super-macros"><a class="header" href="#super-macros">Super macros</a></h3>
<p>r[expr.super-macros.intro] Certain built-in macros may create <a href="expr.temporary">temporaries</a> whose <a href="destructors.scope.temporary">scopes</a> may be <a href="destructors.scope.lifetime-extension">extended</a>. These temporaries are <em>super temporaries</em> and these macros are <em>super macros</em>. <a href="macro.invocation">Invocations</a> of these macros are <em>super macro call expressions</em>. Arguments to these macros may be <em>super operands</em>.</p>
<blockquote>
<p>[!NOTE] When a super macro call expression is an <a href="destructors.scope.lifetime-extension.exprs">extending expression</a>, its super operands are <a href="destructors.scope.lifetime-extension.exprs">extending expressions</a> and the <a href="destructors.scope.temporary">scopes</a> of the super temporaries are <a href="destructors.scope.lifetime-extension">extended</a>. See [destructors.scope.lifetime-extension.exprs].</p>
</blockquote>
<p>r[expr.super-macros.format_args]</p>
<h4 id="format_args"><a class="header" href="#format_args"><code>format_args!</code></a></h4>
<p>r[expr.super-macros.format_args.super-operands] Except for the format string argument, all arguments passed to <a href="core::format_args"><code>format_args!</code></a> are <em>super operands</em>.</p>
<pre><pre class="playground"><code class="language-rust edition2024 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn temp() -&gt; String { String::from("") }
</span>// Due to the call being an extending expression and the argument
// being a super operand, the inner block is an extending expression,
// so the scope of the temporary created in its trailing expression
// is extended.
let _ = format_args!("{}", { &amp;temp() }); // OK
<span class="boring">}</span></code></pre></pre>
<p>r[expr.super-macros.format_args.super-temporaries] The super operands of <a href="core::format_args"><code>format_args!</code></a> are <a href="expr.implicit-borrow">implicitly borrowed</a> and are therefore <a href="expr.place-value">place expression contexts</a>. When a <a href="expr.place-value">value expression</a> is passed as an argument, it creates a <em>super temporary</em>.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn temp() -&gt; String { String::from("") }
</span>let x = format_args!("{}", temp());
x; // &lt;-- The temporary is extended, allowing use here.
<span class="boring">}</span></code></pre></pre>
<p>The expansion of a call to <a href="core::format_args"><code>format_args!</code></a> sometimes creates other internal <em>super temporaries</em>.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0716 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = {
    // This call creates an internal temporary.
    let x = format_args!("{:?}", 0);
    x // &lt;-- The temporary is extended, allowing its use here.
}; // &lt;-- The temporary is dropped here.
x; // 오류
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This call doesn't create an internal temporary.
let x = { let x = format_args!("{}", 0); x };
x; // OK
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] The details of when <a href="core::format_args"><code>format_args!</code></a> does or does not create internal temporaries are currently unspecified.</p>
</blockquote>
<p>r[expr.super-macros.pin]</p>
<h4 id="pin"><a class="header" href="#pin"><code>pin!</code></a></h4>
<p>r[expr.super-macros.pin.super-operands] The argument to <a href="core::pin::pin"><code>pin!</code></a> is a <em>super operand</em>.</p>
<pre><pre class="playground"><code class="language-rust edition2024 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use core::pin::pin;
</span><span class="boring">fn temp() {}
</span>// As above for `format_args!`.
let _ = pin!({ &amp;temp() }); // OK
<span class="boring">}</span></code></pre></pre>
<p>r[expr.super-macros.pin.super-temporaries] The argument to <a href="core::pin::pin"><code>pin!</code></a> is a <a href="expr.place-value">value expression context</a> and creates a <em>super temporary</em>.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use core::pin::pin;
</span><span class="boring">fn temp() {}
</span>// The argument is evaluated into a super temporary.
let x = pin!(temp());
// The temporary is extended, allowing its use here.
x; // OK
<span class="boring">}</span></code></pre></pre>
<p>r[expr.implicit-borrow]</p>
<h3 id="implicit-borrows"><a class="header" href="#implicit-borrows">Implicit borrows</a></h3>
<p>r[expr.implicit-borrow-intro] Certain expressions will treat an expression as a place expression by implicitly borrowing it. For example, it is possible to compare two unsized <a href="types/slice.html">slices</a> for equality directly, because the <code>==</code> operator implicitly borrows its operands:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let c = [1, 2, 3];
</span><span class="boring">let d = vec![1, 2, 3];
</span>let a: &amp;[i32];
let b: &amp;[i32];
<span class="boring">a = &amp;c;
</span><span class="boring">b = &amp;d;
</span>// ...
*a == *b;
// 동등한 형태:
::std::cmp::PartialEq::eq(&amp;*a, &amp;*b);
<span class="boring">}</span></code></pre></pre>
<p>r[expr.implicit-borrow.application] Implicit borrows may be taken in the following expressions:</p>
<ul>
<li><a href="expressions/method-call-expr.html">메서드 호출(method-call)</a> 표현식의 왼쪽 피연산자.</li>
<li><a href="expressions/field-expr.html">필드(field)</a> 표현식의 왼쪽 피연산자.</li>
<li><a href="expressions/call-expr.html">호출 표현식(call expressions)</a>의 왼쪽 피연산자.</li>
<li><a href="expressions/array-expr.html#array-and-slice-indexing-expressions">배열 인덱싱(array indexing)</a> 표현식의 왼쪽 피연산자.</li>
<li><a href="expressions/operator-expr.html#the-dereference-operator">역참조 연산자(dereference operator)</a> (<code>*</code>)의 피연산자.</li>
<li><a href="expressions/operator-expr.html#comparison-operators">비교(comparison)</a>의 피연산자들.</li>
<li><a href="expressions/operator-expr.html#compound-assignment-expressions">복합 할당(compound assignment)</a>의 왼쪽 피연산자들.</li>
<li>Arguments to <a href="core::format_args"><code>format_args!</code></a> except the format string.</li>
</ul>
<p>r[expr.overload]</p>
<h2 id="overloading-traits"><a class="header" href="#overloading-traits">Overloading traits</a></h2>
<p>다음 중 많은 연산자와 표현식들은 <code>std::ops</code>나 <code>std::cmp</code>에 있는 트레잇들을 사용하여 다른 타입에 대해 오버로드될 수 있습니다. 이러한 트레잇들은 <code>core::ops</code> 및 <code>core::cmp</code>에도 동일한 이름으로 존재합니다.</p>
<p>r[expr.attr]</p>
<h2 id="expression-attributes"><a class="header" href="#expression-attributes">Expression attributes</a></h2>
<p>r[expr.attr.restriction] <a href="attributes.html">Outer attributes</a> before an expression are allowed only in a few specific cases:</p>
<ul>
<li><a href="statements.html">구문(statement)</a>으로 사용된 표현식 앞에 올 때.</li>
<li><a href="expressions/array-expr.html">배열 표현식(array expressions)</a>, <a href="expressions/tuple-expr.html">튜플 표현식(tuple expressions)</a>, <a href="expressions/call-expr.html">호출 표현식(call expressions)</a>, 그리고 튜플 스타일 <a href="expressions/struct-expr.html">구조체(struct)</a> 표현식의 요소들에 올 때.</li>
<li><a href="expressions/block-expr.html">블록 표현식(block expressions)</a>의 마지막 표현식(tail expression)에 올 때.</li>
</ul>
<!-- Keep list in sync with block-expr.md -->
<p>r[expr.attr.never-before] They are never allowed before:</p>
<ul>
<li><a href="expressions/range-expr.html">범위(Range)</a> 표현식 앞.</li>
<li>Binary operator expressions ([ArithmeticOrLogicalExpression], [ComparisonExpression], [LazyBooleanExpression], [TypeCastExpression], [AssignmentExpression], [CompoundAssignmentExpression]).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>r[expr.literal]</p>
<h1 id="리터럴-표현식"><a class="header" href="#리터럴-표현식">리터럴 표현식</a></h1>
<p>r[expr.literal.syntax]</p>
<pre><code class="language-grammar expressions">LiteralExpression -&gt;
      CHAR_LITERAL
    | STRING_LITERAL
    | RAW_STRING_LITERAL
    | BYTE_LITERAL
    | BYTE_STRING_LITERAL
    | RAW_BYTE_STRING_LITERAL
    | C_STRING_LITERAL
    | RAW_C_STRING_LITERAL
    | INTEGER_LITERAL
    | FLOAT_LITERAL
    | `true`
    | `false`
</code></pre>
<p>r[expr.literal.intro] A <em>literal expression</em> is an expression consisting of a single token, rather than a sequence of tokens, that immediately and directly denotes the value it evaluates to, rather than referring to it by name or some other evaluation rule.</p>
<p>r[expr.literal.const-expr] A literal is a form of <a href="expressions/../const_eval.html#constant-expressions">constant expression</a>, so is evaluated (primarily) at compile time.</p>
<p>r[expr.literal.literal-token] Each of the lexical <a href="expressions/../tokens.html#literals">literal</a> forms described earlier can make up a literal expression, as can the keywords <code>true</code> and <code>false</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>"hello";   // 문자열 타입
'5';       // 문자 타입
5;         // 정수 타입
<span class="boring">}</span></code></pre></pre>
<p>r[expr.literal.string-representation] In the descriptions below, the <em>string representation</em> of a token is the sequence of characters from the input which matched the token’s production in a <em>Lexer</em> grammar snippet.</p>
<blockquote>
<p>[!NOTE] This string representation never includes a character <code>U+000D</code> (CR) immediately followed by <code>U+000A</code> (LF): this pair would have been previously transformed into a single <code>U+000A</code> (LF).</p>
</blockquote>
<p>r[expr.literal.escape]</p>
<h2 id="이스케이프"><a class="header" href="#이스케이프">이스케이프</a></h2>
<p>r[expr.literal.escape.intro] The descriptions of textual literal expressions below make use of several forms of <em>escape</em>.</p>
<p>r[expr.literal.escape.sequence] Each form of escape is characterised by:</p>
<ul>
<li><em>이스케이프 시퀀스(escape sequence)</em>: 항상 <code>U+005C</code> (<code>\</code>)로 시작하는 문자 시퀀스</li>
<li><em>이스케이프된 값(escaped value)</em>: 단일 문자 또는 빈 문자 시퀀스</li>
</ul>
<p>아래의 이스케이프 정의에서:</p>
<ul>
<li>_8진수 숫자(octal digit)_는 <code>0</code>-<code>7</code> 범위의 문자 중 하나입니다.</li>
<li>_16진수 숫자(hexadecimal digit)_는 <code>0</code>-<code>9</code>, <code>a</code>-<code>f</code>, 또는 <code>A</code>-<code>F</code> 범위의 문자 중 하나입니다.</li>
</ul>
<p>r[expr.literal.escape.simple]</p>
<h3 id="단순-이스케이프"><a class="header" href="#단순-이스케이프">단순 이스케이프</a></h3>
<p>다음 표의 첫 번째 열에 나타나는 각 문자 시퀀스는 이스케이프 시퀀스입니다.</p>
<p>각 경우에, 이스케이프된 값은 두 번째 열의 해당 항목에 주어진 문자입니다.</p>
<div class="table-wrapper"><table><thead><tr><th>이스케이프 시퀀스</th><th>이스케이프된 값</th></tr></thead><tbody>
<tr><td><code>\0</code></td><td>U+0000 (NUL)</td></tr>
<tr><td><code>\t</code></td><td>U+0009 (HT)</td></tr>
<tr><td><code>\n</code></td><td>U+000A (LF)</td></tr>
<tr><td><code>\r</code></td><td>U+000D (CR)</td></tr>
<tr><td>큰따옴표</td><td>U+0022 (큰따옴표)</td></tr>
<tr><td><code>\'</code></td><td>U+0027 (작은따옴표)</td></tr>
<tr><td><code>\\</code></td><td>U+005C (역슬래시)</td></tr>
</tbody></table>
</div>
<p>r[expr.literal.escape.hex-octet]</p>
<h3 id="8비트-이스케이프"><a class="header" href="#8비트-이스케이프">8비트 이스케이프</a></h3>
<p>이스케이프 시퀀스는 <code>\x</code> 뒤에 두 개의 16진수 숫자가 오는 것으로 구성됩니다.</p>
<p>The escaped value is the character whose <a href="http://www.unicode.org/glossary/#unicode_scalar_value">Unicode scalar value</a> is the result of interpreting the final two characters in the escape sequence as a hexadecimal integer, as if by [<code>u8::from_str_radix</code>] with radix 16.</p>
<blockquote>
<p>[!NOTE] The escaped value therefore has a <a href="http://www.unicode.org/glossary/#unicode_scalar_value">Unicode scalar value</a> in the range of <a href="expressions/../types/numeric.html"><code>u8</code></a>.</p>
</blockquote>
<p>r[expr.literal.escape.hex-ascii]</p>
<h3 id="7비트-이스케이프"><a class="header" href="#7비트-이스케이프">7비트 이스케이프</a></h3>
<p>이스케이프 시퀀스는 <code>\x</code> 뒤에 8진수 숫자 하나와 16진수 숫자 하나가 차례로 오는 것으로 구성됩니다.</p>
<p>The escaped value is the character whose <a href="http://www.unicode.org/glossary/#unicode_scalar_value">Unicode scalar value</a> is the result of interpreting the final two characters in the escape sequence as a hexadecimal integer, as if by [<code>u8::from_str_radix</code>] with radix 16.</p>
<p>r[expr.literal.escape.unicode]</p>
<h3 id="유니코드-이스케이프-1"><a class="header" href="#유니코드-이스케이프-1">유니코드 이스케이프</a></h3>
<p>이스케이프 시퀀스는 <code>\u{</code> 뒤에 16진수 숫자 또는 <code>_</code>로 구성된 문자 시퀀스가 오고, 그 뒤에 <code>}</code>가 오는 것으로 구성됩니다.</p>
<p>The escaped value is the character whose <a href="http://www.unicode.org/glossary/#unicode_scalar_value">Unicode scalar value</a> is the result of interpreting the hexadecimal digits contained in the escape sequence as a hexadecimal integer, as if by [<code>u32::from_str_radix</code>] with radix 16.</p>
<blockquote>
<p>[!NOTE] The permitted forms of a [CHAR_LITERAL] or [STRING_LITERAL] token ensure that there is such a character.</p>
</blockquote>
<p>r[expr.literal.continuation]</p>
<h3 id="문자열-연속-이스케이프"><a class="header" href="#문자열-연속-이스케이프">문자열 연속 이스케이프</a></h3>
<p>이스케이프 시퀀스는 <code>\</code> 뒤에 즉시 <code>U+000A</code> (LF)가 오고, 그다음 비-공백 문자 전까지의 모든 공백 문자들로 구성됩니다. 이 목적을 위해 공백 문자는 <code>U+0009</code> (HT), <code>U+000A</code> (LF), <code>U+000D</code> (CR), 그리고 <code>U+0020</code> (SPACE)입니다.</p>
<p>이스케이프된 값은 빈 문자 시퀀스입니다.</p>
<blockquote>
<p>[!NOTE] The effect of this form of escape is that a string continuation skips following whitespace, including additional newlines. Thus <code>a</code>, <code>b</code> and <code>c</code> are equal:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = "foobar";
let b = "foo\
         bar";
let c = "foo\

     bar";

assert_eq!(a, b);
assert_eq!(b, c);
<span class="boring">}</span></code></pre></pre>
<p>추가적인 줄 바꿈을 건너뛰는 것(예시 c와 같은 경우)은 잠재적으로 혼란스럽고 예상치 못한 일일 수 있습니다. 이 동작은 미래에 조정될 수 있습니다. 결정이 내려지기 전까지는 라인 연속 기능을 사용하여 여러 줄 바꿈을 건너뛰는 것에 의존하지 않는 것이 권장됩니다. 자세한 내용은 <a href="https://github.com/rust-lang/reference/pull/1042">이 이슈</a>를 참조하세요.</p>
</blockquote>
<p>r[expr.literal.char]</p>
<h2 id="문자-리터럴-표현식"><a class="header" href="#문자-리터럴-표현식">문자 리터럴 표현식</a></h2>
<p>r[expr.literal.char.intro] A character literal expression consists of a single [CHAR_LITERAL] token.</p>
<p>r[expr.literal.char.type] The expression’s type is the primitive <a href="expressions/../types/textual.html"><code>char</code></a> type.</p>
<p>r[expr.literal.char.no-suffix] The token must not have a suffix.</p>
<p>r[expr.literal.char.literal-content] The token’s <em>literal content</em> is the sequence of characters following the first <code>U+0027</code> (<code>'</code>) and preceding the last <code>U+0027</code> (<code>'</code>) in the string representation of the token.</p>
<p>r[expr.literal.char.represented] The literal expression’s <em>represented character</em> is derived from the literal content as follows:</p>
<p>r[expr.literal.char.escape]</p>
<ul>
<li>리터럴 내용이 다음 형태의 이스케이프 시퀀스 중 하나인 경우, 표현된 문자는 해당 이스케이프 시퀀스의 이스케이프된 값입니다.
<ul>
<li><a href="expressions/literal-expr.html#simple-escapes">단순 이스케이프</a></li>
<li><a href="expressions/literal-expr.html#7-bit-escapes">7비트 이스케이프</a></li>
<li><a href="expressions/literal-expr.html#unicode-escapes">유니코드 이스케이프</a></li>
</ul>
</li>
</ul>
<p>r[expr.literal.char.single]</p>
<ul>
<li>그렇지 않은 경우, 표현된 문자는 리터럴 내용을 구성하는 단일 문자입니다.</li>
</ul>
<p>r[expr.literal.char.result] The expression’s value is the <a href="expressions/../types/textual.html"><code>char</code></a> corresponding to the represented character’s <a href="http://www.unicode.org/glossary/#unicode_scalar_value">Unicode scalar value</a>.</p>
<blockquote>
<p>[!NOTE] The permitted forms of a [CHAR_LITERAL] token ensure that these rules always produce a single character.</p>
</blockquote>
<p>문자 리터럴 표현식의 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>'R';                               // R
'\'';                              // '
'\x52';                            // R
'\u{00E6}';                        // 라틴어 소문자 AE (U+00E6)
<span class="boring">}</span></code></pre></pre>
<p>r[expr.literal.string]</p>
<h2 id="문자열-리터럴-표현식"><a class="header" href="#문자열-리터럴-표현식">문자열 리터럴 표현식</a></h2>
<p>r[expr.literal.string.intro] A string literal expression consists of a single [STRING_LITERAL] or [RAW_STRING_LITERAL] token.</p>
<p>r[expr.literal.string.type] The expression’s type is a shared reference (with <code>static</code> lifetime) to the primitive <a href="expressions/../types/textual.html"><code>str</code></a> type. That is, the type is <code>&amp;'static str</code>.</p>
<p>r[expr.literal.string.no-suffix] The token must not have a suffix.</p>
<p>r[expr.literal.string.literal-content] The token’s <em>literal content</em> is the sequence of characters following the first <code>U+0022</code> (<code>"</code>) and preceding the last <code>U+0022</code> (<code>"</code>) in the string representation of the token.</p>
<p>r[expr.literal.string.represented] The literal expression’s <em>represented string</em> is a sequence of characters derived from the literal content as follows:</p>
<p>r[expr.literal.string.escape]</p>
<ul>
<li>
<p>If the token is a [STRING_LITERAL], each escape sequence of any of the following forms occurring in the literal content is replaced by the escape sequence’s escaped value.</p>
<ul>
<li><a href="expressions/literal-expr.html#simple-escapes">단순 이스케이프</a></li>
<li><a href="expressions/literal-expr.html#7-bit-escapes">7비트 이스케이프</a></li>
<li><a href="expressions/literal-expr.html#unicode-escapes">유니코드 이스케이프</a></li>
<li><a href="expressions/literal-expr.html#string-continuation-escapes">문자열 연속 이스케이프</a>
이러한 대체는 왼쪽에서 오른쪽 순서로 발생합니다. 예를 들어, <code>"\\x41"</code> 토큰은 문자 <code>\</code>, <code>x</code>, <code>4</code>, <code>1</code>로 변환됩니다.</li>
</ul>
</li>
</ul>
<p>r[expr.literal.string.raw]</p>
<ul>
<li>If the token is a [RAW_STRING_LITERAL], the represented string is identical to the literal content.</li>
</ul>
<p>r[expr.literal.string.result] The expression’s value is a reference to a statically allocated <a href="expressions/../types/textual.html"><code>str</code></a> containing the UTF-8 encoding of the represented string.</p>
<p>문자열 리터럴 표현식의 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>"foo"; r"foo";                     // foo
"\"foo\""; r#""foo""#;             // "foo"

"foo #\"# bar";
r##"foo #"# bar"##;                // foo #"# bar

"\x52"; "R"; r"R";                 // R
"\\x52"; r"\x52";                  // \x52
<span class="boring">}</span></code></pre></pre>
<p>r[expr.literal.byte-char]</p>
<h2 id="바이트-리터럴-표현식"><a class="header" href="#바이트-리터럴-표현식">바이트 리터럴 표현식</a></h2>
<p>r[expr.literal.byte-char.intro] A byte literal expression consists of a single [BYTE_LITERAL] token.</p>
<p>r[expr.literal.byte-char.literal] The expression’s type is the primitive <a href="expressions/../types/numeric.html"><code>u8</code></a> type.</p>
<p>r[expr.literal.byte-char.no-suffix] The token must not have a suffix.</p>
<p>r[expr.literal.byte-char.literal-content] The token’s <em>literal content</em> is the sequence of characters following the first <code>U+0027</code> (<code>'</code>) and preceding the last <code>U+0027</code> (<code>'</code>) in the string representation of the token.</p>
<p>r[expr.literal.byte-char.represented] The literal expression’s <em>represented character</em> is derived from the literal content as follows:</p>
<p>r[expr.literal.byte-char.escape]</p>
<ul>
<li>리터럴 내용이 다음 형태의 이스케이프 시퀀스 중 하나인 경우, 표현된 문자는 해당 이스케이프 시퀀스의 이스케이프된 값입니다.
<ul>
<li><a href="expressions/literal-expr.html#simple-escapes">단순 이스케이프</a></li>
<li><a href="expressions/literal-expr.html#8-bit-escapes">8비트 이스케이프</a></li>
</ul>
</li>
</ul>
<p>r[expr.literal.byte-char.single]</p>
<ul>
<li>그렇지 않은 경우, 표현된 문자는 리터럴 내용을 구성하는 단일 문자입니다.</li>
</ul>
<p>r[expr.literal.byte-char.result] The expression’s value is the represented character’s <a href="http://www.unicode.org/glossary/#unicode_scalar_value">Unicode scalar value</a>.</p>
<blockquote>
<p>[!NOTE] The permitted forms of a [BYTE_LITERAL] token ensure that these rules always produce a single character, whose Unicode scalar value is in the range of <a href="expressions/../types/numeric.html"><code>u8</code></a>.</p>
</blockquote>
<p>바이트 리터럴 표현식의 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>b'R';                              // 82
b'\'';                             // 39
b'\x52';                           // 82
b'\xA0';                           // 160
<span class="boring">}</span></code></pre></pre>
<p>r[expr.literal.byte-string]</p>
<h2 id="바이트-문자열-리터럴-표현식"><a class="header" href="#바이트-문자열-리터럴-표현식">바이트 문자열 리터럴 표현식</a></h2>
<p>r[expr.literal.byte-string.intro] A byte string literal expression consists of a single [BYTE_STRING_LITERAL] or [RAW_BYTE_STRING_LITERAL] token.</p>
<p>r[expr.literal.byte-string.type] The expression’s type is a shared reference (with <code>static</code> lifetime) to an array whose element type is <a href="expressions/../types/numeric.html"><code>u8</code></a>. That is, the type is <code>&amp;'static [u8; N]</code>, where <code>N</code> is the number of bytes in the represented string described below.</p>
<p>r[expr.literal.byte-string.no-suffix] The token must not have a suffix.</p>
<p>r[expr.literal.byte-string.literal-content] The token’s <em>literal content</em> is the sequence of characters following the first <code>U+0022</code> (<code>"</code>) and preceding the last <code>U+0022</code> (<code>"</code>) in the string representation of the token.</p>
<p>r[expr.literal.byte-string.represented] The literal expression’s <em>represented string</em> is a sequence of characters derived from the literal content as follows:</p>
<p>r[expr.literal.byte-string.escape]</p>
<ul>
<li>
<p>If the token is a [BYTE_STRING_LITERAL], each escape sequence of any of the following forms occurring in the literal content is replaced by the escape sequence’s escaped value.</p>
<ul>
<li><a href="expressions/literal-expr.html#simple-escapes">단순 이스케이프</a></li>
<li><a href="expressions/literal-expr.html#8-bit-escapes">8비트 이스케이프</a></li>
<li><a href="expressions/literal-expr.html#string-continuation-escapes">문자열 연속 이스케이프</a>
이러한 대체는 왼쪽에서 오른쪽 순서로 발생합니다. 예를 들어, <code>b"\\x41"</code> 토큰은 문자 <code>\</code>, <code>x</code>, <code>4</code>, <code>1</code>로 변환됩니다.</li>
</ul>
</li>
</ul>
<p>r[expr.literal.byte-string.raw]</p>
<ul>
<li>If the token is a [RAW_BYTE_STRING_LITERAL], the represented string is identical to the literal content.</li>
</ul>
<p>r[expr.literal.byte-string.result] The expression’s value is a reference to a statically allocated array containing the <a href="http://www.unicode.org/glossary/#unicode_scalar_value">Unicode scalar values</a> of the characters in the represented string, in the same order.</p>
<blockquote>
<p>[!NOTE] The permitted forms of [BYTE_STRING_LITERAL] and [RAW_BYTE_STRING_LITERAL] tokens ensure that these rules always produce array element values in the range of <a href="expressions/../types/numeric.html"><code>u8</code></a>.</p>
</blockquote>
<p>바이트 문자열 리터럴 표현식의 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>b"foo"; br"foo";                     // foo
b"\"foo\""; br#""foo""#;             // "foo"

b"foo #\"# bar";
br##"foo #"# bar"##;                 // foo #"# bar

b"\x52"; b"R"; br"R";                // R
b"\\x52"; br"\x52";                  // \x52
<span class="boring">}</span></code></pre></pre>
<p>r[expr.literal.c-string]</p>
<h2 id="c-문자열-리터럴-표현식"><a class="header" href="#c-문자열-리터럴-표현식">C 문자열 리터럴 표현식</a></h2>
<p>r[expr.literal.c-string.intro] A C string literal expression consists of a single [C_STRING_LITERAL] or [RAW_C_STRING_LITERAL] token.</p>
<p>r[expr.literal.c-string.type] The expression’s type is a shared reference (with <code>static</code> lifetime) to the standard library <a href="core::ffi::CStr">CStr</a> type. That is, the type is <code>&amp;'static core::ffi::CStr</code>.</p>
<p>r[expr.literal.c-string.no-suffix] The token must not have a suffix.</p>
<p>r[expr.literal.c-string.literal-content] The token’s <em>literal content</em> is the sequence of characters following the first <code>"</code> and preceding the last <code>"</code> in the string representation of the token.</p>
<p>r[expr.literal.c-string.represented] The literal expression’s <em>represented bytes</em> are a sequence of bytes derived from the literal content as follows:</p>
<p>r[expr.literal.c-string.escape]</p>
<ul>
<li>If the token is a [C_STRING_LITERAL], the literal content is treated as a sequence of items, each of which is either a single Unicode character other than <code>\</code> or an <a href="expressions/literal-expr.html#escapes">escape</a>. The sequence of items is converted to a sequence of bytes as follows:
<ul>
<li>각 단일 유니코드 문자는 자신의 UTF-8 표현을 기여합니다.</li>
<li>각 <a href="expressions/literal-expr.html#simple-escapes">단순 이스케이프</a>는 이스케이프된 값의 <a href="http://www.unicode.org/glossary/#unicode_scalar_value">유니코드 스칼라 값</a>을 기여합니다.</li>
<li>각 <a href="expressions/literal-expr.html#8-bit-escapes">8비트 이스케이프</a>는 이스케이프된 값의 <a href="http://www.unicode.org/glossary/#unicode_scalar_value">유니코드 스칼라 값</a>을 포함하는 단일 바이트를 기여합니다.</li>
<li>각 <a href="expressions/literal-expr.html#unicode-escapes">유니코드 이스케이프</a>는 이스케이프된 값의 UTF-8 표현을 기여합니다.</li>
<li>각 <a href="expressions/literal-expr.html#string-continuation-escapes">문자열 연속 이스케이프</a>는 어떠한 바이트도 기여하지 않습니다.</li>
</ul>
</li>
</ul>
<p>r[expr.literal.c-string.raw]</p>
<ul>
<li>If the token is a [RAW_C_STRING_LITERAL], the represented bytes are the UTF-8 encoding of the literal content.</li>
</ul>
<blockquote>
<p>[!NOTE] The permitted forms of [C_STRING_LITERAL] and [RAW_C_STRING_LITERAL] tokens ensure that the represented bytes never include a null byte.</p>
</blockquote>
<p>r[expr.literal.c-string.result] The expression’s value is a reference to a statically allocated <a href="core::ffi::CStr">CStr</a> whose array of bytes contains the represented bytes followed by a null byte.</p>
<p>C 문자열 리터럴 표현식의 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>c"foo"; cr"foo";                     // foo
c"\"foo\""; cr#""foo""#;             // "foo"

c"foo #\"# bar";
cr##"foo #"# bar"##;                 // foo #"# bar

c"\x52"; c"R"; cr"R";                // R
c"\\x52"; cr"\x52";                  // \x52

c"æ";                                // 라틴어 소문자 AE (U+00E6)
c"\u{00E6}";                         // 라틴어 소문자 AE (U+00E6)
c"\xC3\xA6";                         // 라틴어 소문자 AE (U+00E6)

c"\xE6".to_bytes();                  // [230]
c"\u{00E6}".to_bytes();              // [195, 166]
<span class="boring">}</span></code></pre></pre>
<p>r[expr.literal.int]</p>
<h2 id="정수-리터럴-표현식"><a class="header" href="#정수-리터럴-표현식">정수 리터럴 표현식</a></h2>
<p>r[expr.literal.int.intro] An integer literal expression consists of a single [INTEGER_LITERAL] token.</p>
<p>r[expr.literal.int.suffix] If the token has a <a href="expressions/../tokens.html#suffixes">suffix</a>, the suffix must be the name of one of the <a href="expressions/../types/numeric.html">primitive integer types</a>: <code>u8</code>, <code>i8</code>, <code>u16</code>, <code>i16</code>, <code>u32</code>, <code>i32</code>, <code>u64</code>, <code>i64</code>, <code>u128</code>, <code>i128</code>, <code>usize</code>, or <code>isize</code>, and the expression has that type.</p>
<p>r[expr.literal.int.infer] If the token has no suffix, the expression’s type is determined by type inference:</p>
<p>r[expr.literal.int.inference-unique-type]</p>
<ul>
<li>주변 프로그램 문맥으로부터 정수 타입을 <em>유일하게</em> 결정할 수 있다면, 표현식은 해당 타입을 가집니다.</li>
</ul>
<p>r[expr.literal.int.inference-default]</p>
<ul>
<li>프로그램 문맥이 타입을 충분히 제약하지 않는 경우, 기본값으로 부호 있는 32비트 정수인 <code>i32</code>가 사용됩니다.</li>
</ul>
<p>r[expr.literal.int.inference-error]</p>
<ul>
<li>프로그램 문맥이 타입을 과도하게 제약하는 경우, 정적 타입 에러로 간주됩니다.</li>
</ul>
<p>정수 리터럴 표현식의 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>123;                               // i32 타입
123i32;                            // i32 타입
123u32;                            // u32 타입
123_u32;                           // u32 타입
let a: u64 = 123;                  // u64 타입

0xff;                              // i32 타입
0xff_u8;                           // u8 타입

0o70;                              // i32 타입
0o70_i16;                          // i16 타입

0b1111_1111_1001_0000;             // i32 타입
0b1111_1111_1001_0000i64;          // i64 타입

0usize;                            // usize 타입
<span class="boring">}</span></code></pre></pre>
<p>r[expr.literal.int.representation] The value of the expression is determined from the string representation of the token as follows:</p>
<p>r[expr.literal.int.radix]</p>
<ul>
<li>
<p>정수 기수(radix)는 문자열의 처음 두 문자를 조사하여 다음과 같이 결정됩니다:</p>
<ul>
<li><code>0b</code>는 기수 2를 나타냅니다.</li>
<li><code>0o</code>는 기수 8을 나타냅니다.</li>
<li><code>0x</code>는 기수 16을 나타냅니다.</li>
<li>그 외의 경우 기수는 10입니다.</li>
</ul>
</li>
</ul>
<p>r[expr.literal.int.radix-prefix-stripped]</p>
<ul>
<li>기수가 10이 아닌 경우, 처음 두 문자가 문자열에서 제거됩니다.</li>
</ul>
<p>r[expr.literal.int.type-suffix-stripped]</p>
<ul>
<li>모든 접미사는 문자열에서 제거됩니다.</li>
</ul>
<p>r[expr.literal.int.separators-stripped]</p>
<ul>
<li>모든 밑줄(<code>_</code>)은 문자열에서 제거됩니다.</li>
</ul>
<p>r[expr.literal.int.u128-value]</p>
<ul>
<li>The string is converted to a <code>u128</code> value as if by [<code>u128::from_str_radix</code>] with the chosen radix. If the value does not fit in <code>u128</code>, it is a compiler error.</li>
</ul>
<p>r[expr.literal.int.cast]</p>
<ul>
<li><code>u128</code> 값은 <a href="expressions/operator-expr.html#numeric-cast">숫자 캐스트(numeric cast)</a>를 통해 표현식의 타입으로 변환됩니다.</li>
</ul>
<blockquote>
<p>[!NOTE] The final cast will truncate the value of the literal if it does not fit in the expression’s type. <code>rustc</code> includes a <a href="expressions/../attributes/diagnostics.html#lint-check-attributes">lint check</a> named <code>overflowing_literals</code>, defaulting to <code>deny</code>, which rejects expressions where this occurs.</p>
</blockquote>
<blockquote>
<p>[!NOTE] <code>-1i8</code>, for example, is an application of the <a href="expressions/operator-expr.html#negation-operators">negation operator</a> to the literal expression <code>1i8</code>, not a single integer literal expression. See <a href="expressions/operator-expr.html#overflow">Overflow</a> for notes on representing the most negative value for a signed type.</p>
</blockquote>
<p>r[expr.literal.float]</p>
<h2 id="부동-소수점-리터럴-표현식"><a class="header" href="#부동-소수점-리터럴-표현식">부동 소수점 리터럴 표현식</a></h2>
<p>r[expr.literal.float.intro] A floating-point literal expression has one of two forms:</p>
<ul>
<li>a single [FLOAT_LITERAL] token</li>
<li>a single [INTEGER_LITERAL] token which has a suffix and no radix indicator</li>
</ul>
<p>r[expr.literal.float.suffix] If the token has a <a href="expressions/../tokens.html#suffixes">suffix</a>, the suffix must be the name of one of the <a href="expressions/../types/numeric.html#floating-point-types">primitive floating-point types</a>: <code>f32</code> or <code>f64</code>, and the expression has that type.</p>
<p>r[expr.literal.float.infer] If the token has no suffix, the expression’s type is determined by type inference:</p>
<p>r[expr.literal.float.inference-unique-type]</p>
<ul>
<li>주변 프로그램 문맥으로부터 부동 소수점 타입을 <em>유일하게</em> 결정할 수 있다면, 표현식은 해당 타입을 가집니다.</li>
</ul>
<p>r[expr.literal.float.inference-default]</p>
<ul>
<li>프로그램 문맥이 타입을 충분히 제약하지 않는 경우, 기본값으로 <code>f64</code>가 사용됩니다.</li>
</ul>
<p>r[expr.literal.float.inference-error]</p>
<ul>
<li>프로그램 문맥이 타입을 과도하게 제약하는 경우, 정적 타입 에러로 간주됩니다.</li>
</ul>
<p>부동 소수점 리터럴 표현식의 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>123.0f64;        // f64 타입
0.1f64;          // f64 타입
0.1f32;          // f32 타입
12E+99_f64;      // f64 타입
5f32;            // f32 타입
let x: f64 = 2.; // f64 타입
<span class="boring">}</span></code></pre></pre>
<p>r[expr.literal.float.result] The value of the expression is determined from the string representation of the token as follows:</p>
<p>r[expr.literal.float.type-suffix-stripped]</p>
<ul>
<li>모든 접미사는 문자열에서 제거됩니다.</li>
</ul>
<p>r[expr.literal.float.separators-stripped]</p>
<ul>
<li>모든 밑줄(<code>_</code>)은 문자열에서 제거됩니다.</li>
</ul>
<p>r[expr.literal.float.value]</p>
<ul>
<li>문자열은 <a href="expressions/../../core/primitive.f32.html#method.from_str"><code>f32::from_str</code></a> 또는 <a href="expressions/../../core/primitive.f64.html#method.from_str"><code>f64::from_str</code></a>을 사용한 것처럼 표현식의 타입으로 변환됩니다.</li>
</ul>
<blockquote>
<p>[!NOTE] <code>-1.0</code>, for example, is an application of the <a href="expressions/operator-expr.html#negation-operators">negation operator</a> to the literal expression <code>1.0</code>, not a single floating-point literal expression.</p>
</blockquote>
<blockquote>
<p>[!NOTE] <code>inf</code> and <code>NaN</code> are not literal tokens. The [<code>f32::INFINITY</code>], [<code>f64::INFINITY</code>], [<code>f32::NAN</code>], and [<code>f64::NAN</code>] constants can be used instead of literal expressions. In <code>rustc</code>, a literal large enough to be evaluated as infinite will trigger the <code>overflowing_literals</code> lint check.</p>
</blockquote>
<p>r[expr.literal.bool]</p>
<h2 id="불리언-리터럴-표현식"><a class="header" href="#불리언-리터럴-표현식">불리언 리터럴 표현식</a></h2>
<p>r[expr.literal.bool.intro] A boolean literal expression consists of one of the keywords <code>true</code> or <code>false</code>.</p>
<p>r[expr.literal.bool.result] The expression’s type is the primitive <a href="expressions/../types/boolean.html">boolean type</a>, and its value is:</p>
<ul>
<li>키워드가 <code>true</code>인 경우 true</li>
<li>키워드가 <code>false</code>인 경우 false</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>r[expr.path]</p>
<h1 id="경로-표현식"><a class="header" href="#경로-표현식">경로 표현식</a></h1>
<p>r[expr.path.syntax]</p>
<pre><code class="language-grammar expressions">PathExpression -&gt;
      PathInExpression
    | QualifiedPathInExpression
</code></pre>
<p>r[expr.path.intro] A <a href="expressions/../paths.html">path</a> used as an expression context denotes either a local variable or an item.</p>
<p>r[expr.path.place] Path expressions that resolve to local or static variables are <a href="expressions/../expressions.html#place-expressions-and-value-expressions">place expressions</a>; other paths are <a href="expressions/../expressions.html#place-expressions-and-value-expressions">value expressions</a>.</p>
<p>r[expr.path.safety] Using a <a href="expressions/../items/static-items.html#mutable-statics"><code>static mut</code></a> variable requires an <a href="expressions/block-expr.html#unsafe-blocks"><code>unsafe</code> block</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">mod globals {
</span><span class="boring">    pub static STATIC_VAR: i32 = 5;
</span><span class="boring">    pub static mut STATIC_MUT_VAR: i32 = 7;
</span><span class="boring">}
</span><span class="boring">let local_var = 3;
</span>local_var;
globals::STATIC_VAR;
unsafe { globals::STATIC_MUT_VAR };
let some_constructor = Some::&lt;i32&gt;;
let push_integer = Vec::&lt;i32&gt;::push;
let slice_reverse = &lt;[i32]&gt;::reverse;
<span class="boring">}</span></code></pre></pre>
<p>r[expr.path.const] Evaluation of associated constants is handled the same way as <a href="expressions/block-expr.html#const-blocks"><code>const</code> blocks</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[expr.block]</p>
<h1 id="블록-표현식"><a class="header" href="#블록-표현식">블록 표현식</a></h1>
<p>r[expr.block.syntax]</p>
<pre><code class="language-grammar expressions">BlockExpression -&gt;
    `{`
        InnerAttribute*
        Statements?
    `}`

Statements -&gt;
      Statement+
    | Statement+ ExpressionWithoutBlock
    | ExpressionWithoutBlock
</code></pre>
<p>r[expr.block.intro] A <em>block expression</em>, or <em>block</em>, is a control flow expression and anonymous namespace scope for items and variable declarations.</p>
<p>r[expr.block.sequential-evaluation] As a control flow expression, a block sequentially executes its component non-item declaration statements and then its final optional expression.</p>
<p>r[expr.block.namespace] As an anonymous namespace scope, item declarations are only in scope inside the block itself and variables declared by <code>let</code> statements are in scope from the next statement until the end of the block. See the <a href="expressions/../names/scopes.html">scopes</a> chapter for more details.</p>
<p>r[expr.block.inner-attributes] The syntax for a block is <code>{</code>, then any <a href="expressions/../attributes.html">inner attributes</a>, then any number of <a href="expressions/../statements.html">statements</a>, then an optional expression, called the final operand, and finally a <code>}</code>.</p>
<p>r[expr.block.statements] Statements are usually required to be followed by a semicolon, with two exceptions:</p>
<ol>
<li>아이템 선언 구문 뒤에는 세미콜론이 붙을 필요가 없습니다.</li>
<li>표현식 구문은 보통 뒤에 세미콜론이 필요하지만, 해당 구문의 외부 표현식이 흐름 제어 표현식인 경우는 제외합니다.</li>
</ol>
<p>r[expr.block.null-statement] Furthermore, extra semicolons between statements are allowed, but these semicolons do not affect semantics.</p>
<p>r[expr.block.evaluation] When evaluating a block expression, each statement, except for item declaration statements, is executed sequentially.</p>
<p>r[expr.block.result] Then the final operand is executed, if given.</p>
<p>r[expr.block.type] The type of a block is the type of the final operand, or <code>()</code> if the final operand is omitted.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn fn_call() {}
</span>let _: () = {
    fn_call();
};

let five: i32 = {
    fn_call();
    5
};

assert_eq!(5, five);
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] As a control flow expression, if a block expression is the outer expression of an expression statement, the expected type is <code>()</code> unless it is followed immediately by a semicolon.</p>
</blockquote>
<p>r[expr.block.value] Blocks are always <a href="expressions/../expressions.html#place-expressions-and-value-expressions">value expressions</a> and evaluate the last operand in value expression context.</p>
<blockquote>
<p>[!NOTE] This can be used to force moving a value if really needed. For example, the following example fails on the call to <code>consume_self</code> because the struct was moved out of <code>s</code> in the block expression.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Struct;

impl Struct {
    fn consume_self(self) {}
    fn borrow_self(&amp;self) {}
}

fn move_by_block_expression() {
    let s = Struct;

    // 블록 표현식 내에서 `s`로부터 값을 이동시킵니다.
    (&amp;{ s }).borrow_self();

    // `s`가 이동되었으므로 실행에 실패합니다.
    s.consume_self();
}
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[expr.block.async]</p>
<h2 id="async-블록"><a class="header" href="#async-블록"><code>async</code> 블록</a></h2>
<p>r[expr.block.async.syntax]</p>
<pre><code class="language-grammar expressions">AsyncBlockExpression -&gt; `async` `move`? BlockExpression
</code></pre>
<p>r[expr.block.async.intro] An <em>async block</em> is a variant of a block expression which evaluates to a future.</p>
<p>r[expr.block.async.future-result] The final expression of the block, if present, determines the result value of the future.</p>
<p>r[expr.block.async.anonymous-type] Executing an async block is similar to executing a closure expression: its immediate effect is to produce and return an anonymous type.</p>
<p>r[expr.block.async.future] Whereas closures return a type that implements one or more of the [<code>std::ops::Fn</code>] traits, however, the type returned for an async block implements the [<code>std::future::Future</code>] trait.</p>
<p>r[expr.block.async.layout-unspecified] The actual data format for this type is unspecified.</p>
<blockquote>
<p>[!NOTE] The future type that rustc generates is roughly equivalent to an enum with one variant per <code>await</code> point, where each variant stores the data needed to resume from its corresponding point.</p>
</blockquote>
<p>r[expr.block.async.edition2018]</p>
<blockquote>
<p>[!EDITION-2018] Async blocks are only available beginning with Rust 2018.</p>
</blockquote>
<p>r[expr.block.async.capture]</p>
<h3 id="캡처-모드"><a class="header" href="#캡처-모드">캡처 모드</a></h3>
<p>비동기 블록은 클로저와 동일한 <a href="expressions/../types/closure.html#capture-modes">캡처 모드</a>를 사용하여 환경으로부터 변수를 캡처합니다. 클로저와 마찬가지로, <code>async { .. }</code>라고 작성하면 각 변수에 대한 캡처 모드가 블록의 내용으로부터 추론됩니다. 반면 <code>async move { .. }</code> 블록은 참조된 모든 변수를 결과 퓨처로 이동(move)시킵니다.</p>
<p>r[expr.block.async.context]</p>
<h3 id="비동기-컨텍스트"><a class="header" href="#비동기-컨텍스트">비동기 컨텍스트</a></h3>
<p>비동기 블록은 퓨처를 생성하므로, 다시 <a href="expressions/await-expr.html"><code>await</code> 표현식</a>을 포함할 수 있는 **비동기 컨텍스트(async context)**를 정의합니다. 비동기 컨텍스트는 비동기 블록뿐만 아니라, 비동기 블록의 관점에서 시맨틱이 정의되는 비동기 함수의 본문에 의해 형성됩니다.</p>
<p>r[expr.block.async.function]</p>
<h3 id="제어-흐름-연산자"><a class="header" href="#제어-흐름-연산자">제어 흐름 연산자</a></h3>
<p>r[expr.block.async.function.intro] Async blocks act like a function boundary, much like closures.</p>
<p>r[expr.block.async.function.return-try] Therefore, the <code>?</code> operator and <code>return</code> expressions both affect the output of the future, not the enclosing function or other context. That is, <code>return &lt;expr&gt;</code> from within an async block will return the result of <code>&lt;expr&gt;</code> as the output of the future. Similarly, if <code>&lt;expr&gt;?</code> propagates an error, that error is propagated as the result of the future.</p>
<p>r[expr.block.async.function.control-flow] Finally, the <code>break</code> and <code>continue</code> keywords cannot be used to branch out from an async block. Therefore the following is illegal:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    async move {
        break; // error[E0267]: `async` 블록 내부의 `break`
    }
}
<span class="boring">}</span></code></pre></pre>
<p>r[expr.block.const]</p>
<h2 id="const-블록"><a class="header" href="#const-블록"><code>const</code> 블록</a></h2>
<p>r[expr.block.const.syntax]</p>
<pre><code class="language-grammar expressions">ConstBlockExpression -&gt; `const` BlockExpression
</code></pre>
<p>r[expr.block.const.intro] A <em>const block</em> is a variant of a block expression whose body evaluates at compile-time instead of at runtime.</p>
<p>r[expr.block.const.context] Const blocks allows you to define a constant value without having to define new <a href="expressions/../items/constant-items.html">constant items</a>, and thus they are also sometimes referred as <em>inline consts</em>. It also supports type inference so there is no need to specify the type, unlike <a href="expressions/../items/constant-items.html">constant items</a>.</p>
<p>r[expr.block.const.generic-params] Const blocks have the ability to reference generic parameters in scope, unlike <a href="expressions/../glossary.html#free-item">free</a> constant items. They are desugared to constant items with generic parameters in scope (similar to associated constants, but without a trait or type they are associated with). For example, this code:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T&gt;() -&gt; usize {
    const { std::mem::size_of::&lt;T&gt;() + 1 }
}
<span class="boring">}</span></code></pre></pre>
<p>다음과 동일합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T&gt;() -&gt; usize {
    {
        struct Const&lt;T&gt;(T);
        impl&lt;T&gt; Const&lt;T&gt; {
            const CONST: usize = std::mem::size_of::&lt;T&gt;() + 1;
        }
        Const::&lt;T&gt;::CONST
    }
}
<span class="boring">}</span></code></pre></pre>
<p>r[expr.block.const.evaluation]</p>
<p>const 블록 표현식이 런타임에 실행되면, 반환 값이 무시되더라도 해당 상수는 반드시 평가됨이 보장됩니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T&gt;() -&gt; usize {
    // 이 코드가 실행된다면, 해당 어설션(assertion)은 분명히 컴파일 타임에
    // 평가된 것입니다.
    const { assert!(std::mem::size_of::&lt;T&gt;() &gt; 0); }
    // 여기서 타입이 0 크기가 아님에 의존하는 unsafe 코드를 가질 수 있습니다.
    /* ... */
    42
}
<span class="boring">}</span></code></pre></pre>
<p>r[expr.block.const.not-executed]</p>
<p>const 블록 표현식이 런타임에 실행되지 않는 경우, 평가될 수도 있고 되지 않을 수도 있습니다:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if false {
    // 프로그램이 빌드될 때 패닉이 발생할 수도 있고 발생하지 않을 수도 있습니다.
    const { panic!(); }
}
<span class="boring">}</span></code></pre></pre>
<p>r[expr.block.unsafe]</p>
<h2 id="unsafe-블록"><a class="header" href="#unsafe-블록"><code>unsafe</code> 블록</a></h2>
<p>r[expr.block.unsafe.syntax]</p>
<pre><code class="language-grammar expressions">UnsafeBlockExpression -&gt; `unsafe` BlockExpression
</code></pre>
<p>r[expr.block.unsafe.intro] <em>See <a href="expressions/../unsafe-keyword.html#unsafe-blocks-unsafe-"><code>unsafe</code> blocks</a> for more information on when to use <code>unsafe</code></em>.</p>
<p>코드 블록 앞에 <code>unsafe</code> 키워드를 붙여 <a href="expressions/../unsafety.html">안전하지 않은 연산(unsafe operations)</a>을 허용할 수 있습니다. 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe {
    let b = [13u8, 17u8];
    let a = &amp;b[0] as *const u8;
    assert_eq!(*a, 13);
    assert_eq!(*a.offset(1), 17);
}

<span class="boring">unsafe fn an_unsafe_fn() -&gt; i32 { 10 }
</span>let a = unsafe { an_unsafe_fn() };
<span class="boring">}</span></code></pre></pre>
<p>r[expr.block.label]</p>
<h2 id="labeled-block-expressions"><a class="header" href="#labeled-block-expressions">Labeled block expressions</a></h2>
<p>Labeled block expressions are documented in the <a href="expressions/expr.loop.block-labels">Loops and other breakable expressions</a> section.</p>
<p>r[expr.block.attributes]</p>
<h2 id="블록-표현식의-속성"><a class="header" href="#블록-표현식의-속성">블록 표현식의 속성</a></h2>
<p>r[expr.block.attributes.inner-attributes] <a href="expressions/../attributes.html">Inner attributes</a> are allowed directly after the opening brace of a block expression in the following situations:</p>
<ul>
<li><a href="expressions/../items/functions.html">함수</a> 및 <a href="expressions/../items/associated-items.html#methods">메서드</a> 본문.</li>
<li>Loop bodies (<a href="expressions/loop-expr.html#infinite-loops"><code>loop</code></a>, <a href="expressions/loop-expr.html#predicate-loops"><code>while</code></a>, and <a href="expressions/loop-expr.html#iterator-loops"><code>for</code></a>).</li>
<li><a href="expressions/../statements.html">구문</a>으로 사용된 블록 표현식.</li>
<li><a href="expressions/array-expr.html">배열 표현식</a>, <a href="expressions/tuple-expr.html">튜플 표현식</a>, <a href="expressions/call-expr.html">호출 표현식</a>, 그리고 튜플 스타일 <a href="expressions/struct-expr.html">구조체</a> 표현식의 요소로서의 블록 표현식.</li>
<li>다른 블록 표현식의 꼬리 표현식으로서의 블록 표현식.</li>
</ul>
<!-- Keep list in sync with expressions.md -->
<p>r[expr.block.attributes.valid] The attributes that have meaning on a block expression are <a href="expressions/../conditional-compilation.html"><code>cfg</code></a> and <a href="expressions/../attributes/diagnostics.html#lint-check-attributes">the lint check attributes</a>.</p>
<p>예를 들어, 이 함수는 유닉스 플랫폼에서는 <code>true</code>를 반환하고 다른 플랫폼에서는 <code>false</code>를 반환합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_unix_platform() -&gt; bool {
    #[cfg(unix)] { true }
    #[cfg(not(unix))] { false }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p>r[expr.operator]</p>
<h1 id="연산자-표현식"><a class="header" href="#연산자-표현식">연산자 표현식</a></h1>
<p>r[expr.operator.syntax]</p>
<pre><code class="language-grammar expressions">OperatorExpression -&gt;
      BorrowExpression
    | DereferenceExpression
    | TryPropagationExpression
    | NegationExpression
    | ArithmeticOrLogicalExpression
    | ComparisonExpression
    | LazyBooleanExpression
    | TypeCastExpression
    | AssignmentExpression
    | CompoundAssignmentExpression
</code></pre>
<p>r[expr.operator.intro] Operators are defined for built in types by the Rust language.</p>
<p>r[expr.operator.trait] Many of the following operators can also be overloaded using traits in <code>std::ops</code> or <code>std::cmp</code>.</p>
<p>r[expr.operator.int-overflow]</p>
<h2 id="오버플로"><a class="header" href="#오버플로">오버플로</a></h2>
<p>r[expr.operator.int-overflow.intro] Integer operators will panic when they overflow when compiled in debug mode. The <code>-C debug-assertions</code> and <code>-C overflow-checks</code> compiler flags can be used to control this more directly. The following things are considered to be overflow:</p>
<p>r[expr.operator.int-overflow.binary-arith]</p>
<ul>
<li><code>+</code>, <code>*</code> 또는 이항 <code>-</code>가 저장할 수 있는 최대값보다 크거나 최소값보다 작은 값을 생성할 때.</li>
</ul>
<p>r[expr.operator.int-overflow.unary-neg]</p>
<ul>
<li>피연산자가 <a href="expressions/literal-expr.html#integer-literal-expressions">리터럴 표현식</a> (또는 하나 이상의 <a href="expressions/grouped-expr.html">그룹화된 표현식</a> 내에 단독으로 있는 리터럴 표현식)이 아닌 경우, 부호 있는 정수 타입의 가장 작은 음수 값에 단항 <code>-</code>를 적용할 때.</li>
</ul>
<p>r[expr.operator.int-overflow.div]</p>
<ul>
<li>왼쪽 인수가 부호 있는 정수 타입의 가장 작은 정수이고 오른쪽 인수가 <code>-1</code>인 경우 <code>/</code> 또는 <code>%</code> 사용. 이러한 검사는 레거시 이유로 <code>-C overflow-checks</code>가 비활성화된 경우에도 발생합니다.</li>
</ul>
<p>r[expr.operator.int-overflow.shift]</p>
<ul>
<li>오른쪽 인수가 왼쪽 인수 타입의 비트 수보다 크거나 같거나 음수인 경우 <code>&lt;&lt;</code> 또는 <code>&gt;&gt;</code> 사용.</li>
</ul>
<blockquote>
<p>[!NOTE] The exception for literal expressions behind unary <code>-</code> means that forms such as <code>-128_i8</code> or <code>let j: i8 = -(128)</code> never cause a panic and have the expected value of -128.</p>
<p>이러한 경우, <a href="expressions/literal-expr.html#integer-literal-expressions">정수 리터럴 표현식</a>의 설명에 따라 정수 리터럴이 해당 타입으로 잘리기 때문에 리터럴 표현식은 이미 해당 타입에 대해 가장 작은 음수 값을 가집니다(예: <code>128_i8</code>은 값 -128을 가짐).</p>
<p>이러한 가장 작은 음수 값의 부정은 2의 보수 오버플로 규칙으로 인해 값이 변경되지 않고 그대로 유지됩니다.</p>
<p><code>rustc</code>에서 이러한 가장 작은 음수 표현식은 <code>overflowing_literals</code> 린트 검사에서도 무시됩니다.</p>
</blockquote>
<p>r[expr.operator.borrow]</p>
<h2 id="차용-연산자"><a class="header" href="#차용-연산자">차용 연산자</a></h2>
<p>r[expr.operator.borrow.syntax]</p>
<pre><code class="language-grammar expressions">BorrowExpression -&gt;
      (`&amp;`|`&amp;&amp;`) Expression
    | (`&amp;`|`&amp;&amp;`) `mut` Expression
    | (`&amp;`|`&amp;&amp;`) `raw` `const` Expression
    | (`&amp;`|`&amp;&amp;`) `raw` `mut` Expression
</code></pre>
<p>r[expr.operator.borrow.intro] The <code>&amp;</code> (shared borrow) and <code>&amp;mut</code> (mutable borrow) operators are unary prefix operators.</p>
<p>r[expr.operator.borrow.result] When applied to a <a href="expressions/../expressions.html#place-expressions-and-value-expressions">place expression</a>, this expressions produces a reference (pointer) to the location that the value refers to.</p>
<p>r[expr.operator.borrow.lifetime] The memory location is also placed into a borrowed state for the duration of the reference. For a shared borrow (<code>&amp;</code>), this implies that the place may not be mutated, but it may be read or shared again. For a mutable borrow (<code>&amp;mut</code>), the place may not be accessed in any way until the borrow expires.</p>
<p>r[expr.operator.borrow.mut] <code>&amp;mut</code> evaluates its operand in a mutable place expression context.</p>
<p>r[expr.operator.borrow.temporary] If the <code>&amp;</code> or <code>&amp;mut</code> operators are applied to a <a href="expressions/../expressions.html#place-expressions-and-value-expressions">value expression</a>, then a <a href="expressions/../expressions.html#temporaries">temporary value</a> is created.</p>
<p>이 연산자들은 오버로딩할 수 없습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    // 이 스코프 동안 지속되는 값 7을 가진 임시 값이 생성됩니다.
    let shared_reference = &amp;7;
}
let mut array = [-2, 3, 9];
{
    // 이 스코프 동안 `array`를 가변적으로 차용합니다.
    // `array`는 `mutable_reference`를 통해서만 사용할 수 있습니다.
    let mutable_reference = &amp;mut array;
}
<span class="boring">}</span></code></pre></pre>
<p>r[expr.borrow.and-and-syntax] Even though <code>&amp;&amp;</code> is a single token (<a href="expressions/operator-expr.html#lazy-boolean-operators">the lazy ‘and’ operator</a>), when used in the context of borrow expressions it works as two borrows:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 같은 의미:
let a = &amp;&amp;  10;
let a = &amp; &amp; 10;

// 같은 의미:
let a = &amp;&amp;&amp;&amp;  mut 10;
let a = &amp;&amp; &amp;&amp; mut 10;
let a = &amp; &amp; &amp; &amp; mut 10;
<span class="boring">}</span></code></pre></pre>
<p>r[expr.borrow.raw]</p>
<h3 id="원시-차용-연산자"><a class="header" href="#원시-차용-연산자">원시 차용 연산자</a></h3>
<p>r[expr.borrow.raw.intro] <code>&amp;raw const</code> and <code>&amp;raw mut</code> are the <em>raw borrow operators</em>.</p>
<p>r[expr.borrow.raw.place] The operand expression of these operators is evaluated in place expression context.</p>
<p>r[expr.borrow.raw.result] <code>&amp;raw const expr</code> then creates a const raw pointer of type <code>*const T</code> to the given place, and <code>&amp;raw mut expr</code> creates a mutable raw pointer of type <code>*mut T</code>.</p>
<p>r[expr.borrow.raw.invalid-ref] The raw borrow operators must be used instead of a borrow operator whenever the place expression could evaluate to a place that is not properly aligned or does not store a valid value as determined by its type, or whenever creating a reference would introduce incorrect aliasing assumptions. In those situations, using a borrow operator would cause <a href="expressions/../behavior-considered-undefined.html">undefined behavior</a> by creating an invalid reference, but a raw pointer may still be constructed.</p>
<p>다음은 <code>packed</code> 구조체를 통해 정렬되지 않은 장소에 대한 원시 포인터를 생성하는 예입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(packed)]
struct Packed {
    f1: u8,
    f2: u16,
}

let packed = Packed { f1: 1, f2: 2 };
// `&amp;packed.f2`는 정렬되지 않은 참조를 생성하므로 정의되지 않은 동작이 됩니다!
let raw_f2 = &amp;raw const packed.f2;
assert_eq!(unsafe { raw_f2.read_unaligned() }, 2);
<span class="boring">}</span></code></pre></pre>
<p>다음은 유효한 값을 포함하지 않는 장소에 대한 원시 포인터를 생성하는 예입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem::MaybeUninit;

struct Demo {
    field: bool,
}

let mut uninit = MaybeUninit::&lt;Demo&gt;::uninit();
// `&amp;uninit.as_mut().field`는 초기화되지 않은 `bool`에 대한 참조를 생성하므로,
// 정의되지 않은 동작이 됩니다!
let f1_ptr = unsafe { &amp;raw mut (*uninit.as_mut_ptr()).field };
unsafe { f1_ptr.write(true); }
let init = unsafe { uninit.assume_init() };
<span class="boring">}</span></code></pre></pre>
<p>r[expr.deref]</p>
<h2 id="역참조-연산자"><a class="header" href="#역참조-연산자">역참조 연산자</a></h2>
<p>r[expr.deref.syntax]</p>
<pre><code class="language-grammar expressions">DereferenceExpression -&gt; `*` Expression
</code></pre>
<p>r[expr.deref.intro] The <code>*</code> (dereference) operator is also a unary prefix operator.</p>
<p>r[expr.deref.result] When applied to a <a href="expressions/../types/pointer.html">pointer</a> it denotes the pointed-to location.</p>
<p>r[expr.deref.mut] If the expression is of type <code>&amp;mut T</code> or <code>*mut T</code>, and is either a local variable, a (nested) field of a local variable or is a mutable <a href="expressions/../expressions.html#place-expressions-and-value-expressions">place expression</a>, then the resulting memory location can be assigned to.</p>
<p>r[expr.deref.safety] Dereferencing a raw pointer requires <code>unsafe</code>.</p>
<p>r[expr.deref.traits] On non-pointer types <code>*x</code> is equivalent to <code>*std::ops::Deref::deref(&amp;x)</code> in an <a href="expressions/../expressions.html#mutability">immutable place expression context</a> and <code>*std::ops::DerefMut::deref_mut(&amp;mut x)</code> in a mutable place expression context.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = &amp;7;
assert_eq!(*x, 7);
let y = &amp;mut 9;
*y = 11;
assert_eq!(*y, 11);
<span class="boring">}</span></code></pre></pre>
<p>r[expr.try]</p>
<h2 id="the-try-propagation-expression"><a class="header" href="#the-try-propagation-expression">The try propagation expression</a></h2>
<p>r[expr.try.syntax]</p>
<pre><code class="language-grammar expressions">TryPropagationExpression -&gt; Expression `?`
</code></pre>
<p>r[expr.try.intro] The try propagation expression uses the value of the inner expression and the <a href="core::ops::Try"><code>Try</code></a> trait to decide whether to produce a value, and if so, what value to produce, or whether to return a value to the caller, and if so, what value to return.</p>
<blockquote>
<p>[!EXAMPLE]</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::num::ParseIntError;
</span>fn try_to_parse() -&gt; Result&lt;i32, ParseIntError&gt; {
    let x: i32 = "123".parse()?; // `x` is `123`.
    let y: i32 = "24a".parse()?; // Returns an `Err()` immediately.
    Ok(x + y)                    // 실행되지 않습니다.
}

let res = try_to_parse();
println!("{res:?}");
<span class="boring">assert!(res.is_err())
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn try_option_some() -&gt; Option&lt;u8&gt; {
    let val = Some(1)?;
    Some(val)
}
assert_eq!(try_option_some(), Some(1));

fn try_option_none() -&gt; Option&lt;u8&gt; {
    let val = None?;
    Some(val)
}
assert_eq!(try_option_none(), None);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024">use std::ops::ControlFlow;

pub struct TreeNode&lt;T&gt; {
    value: T,
    left: Option&lt;Box&lt;TreeNode&lt;T&gt;&gt;&gt;,
    right: Option&lt;Box&lt;TreeNode&lt;T&gt;&gt;&gt;,
}

impl&lt;T&gt; TreeNode&lt;T&gt; {
    pub fn traverse_inorder&lt;B&gt;(&amp;self, f: &amp;mut impl FnMut(&amp;T) -&gt; ControlFlow&lt;B&gt;) -&gt; ControlFlow&lt;B&gt; {
        if let Some(left) = &amp;self.left {
            left.traverse_inorder(f)?;
        }
        f(&amp;self.value)?;
        if let Some(right) = &amp;self.right {
            right.traverse_inorder(f)?;
        }
        ControlFlow::Continue(())
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let n = TreeNode {
</span><span class="boring">        value: 1,
</span><span class="boring">        left: Some(Box::new(TreeNode{value: 2, left: None, right: None})),
</span><span class="boring">        right: None,
</span><span class="boring">    };
</span><span class="boring">    let v = n.traverse_inorder(&amp;mut |t| {
</span><span class="boring">        if *t == 2 {
</span><span class="boring">            ControlFlow::Break("found")
</span><span class="boring">        } else {
</span><span class="boring">            ControlFlow::Continue(())
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">    assert_eq!(v, ControlFlow::Break("found"));
</span><span class="boring">}</span></code></pre></pre>
</blockquote>
<blockquote>
<p>[!NOTE] The <a href="core::ops::Try"><code>Try</code></a> trait is currently unstable, and thus cannot be implemented for user types.</p>
<p>The try propagation expression is currently roughly equivalent to:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![ feature(try_trait_v2) ]
</span><span class="boring">fn example() -&gt; Result&lt;(), ()&gt; {
</span><span class="boring">let expr = Ok(());
</span>match core::ops::Try::branch(expr) {
    core::ops::ControlFlow::Continue(val) =&gt; val,
    core::ops::ControlFlow::Break(residual) =&gt;
        return core::ops::FromResidual::from_residual(residual),
}
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
</blockquote>
<blockquote>
<p>[!NOTE] The try propagation operator is sometimes called <em>the question mark operator</em>, <em>the <code>?</code> operator</em>, or <em>the try operator</em>.</p>
</blockquote>
<p>r[expr.try.restricted-types] The try propagation operator can be applied to expressions with the type of:</p>
<ul>
<li>[<code>Result&lt;T, E&gt;</code>]
<ul>
<li><code>Result::Ok(val)</code> evaluates to <code>val</code>.</li>
<li><code>Result::Err(e)</code> returns <code>Result::Err(From::from(e))</code>.</li>
</ul>
</li>
<li>[<code>Option&lt;T&gt;</code>]
<ul>
<li><code>Option::Some(val)</code> evaluates to <code>val</code>.</li>
<li><code>Option::None</code> returns <code>Option::None</code>.</li>
</ul>
</li>
<li>[<code>ControlFlow&lt;B, C&gt;</code>][core::ops::ControlFlow]
<ul>
<li><code>ControlFlow::Continue(c)</code> evaluates to <code>c</code>.</li>
<li><code>ControlFlow::Break(b)</code> returns <code>ControlFlow::Break(b)</code>.</li>
</ul>
</li>
<li>[<code>Poll&lt;Result&lt;T, E&gt;&gt;</code>][core::task::Poll]
<ul>
<li><code>Poll::Ready(Ok(val))</code> evaluates to <code>Poll::Ready(val)</code>.</li>
<li><code>Poll::Ready(Err(e))</code> returns <code>Poll::Ready(Err(From::from(e)))</code>.</li>
<li><code>Poll::Pending</code> evaluates to <code>Poll::Pending</code>.</li>
</ul>
</li>
<li>[<code>Poll&lt;Option&lt;Result&lt;T, E&gt;&gt;&gt;</code>][<code>core::task::Poll</code>]
<ul>
<li><code>Poll::Ready(Some(Ok(val)))</code> evaluates to <code>Poll::Ready(Some(val))</code>.</li>
<li><code>Poll::Ready(Some(Err(e)))</code> returns <code>Poll::Ready(Some(Err(From::from(e))))</code>.</li>
<li><code>Poll::Ready(None)</code> evaluates to <code>Poll::Ready(None)</code>.</li>
<li><code>Poll::Pending</code> evaluates to <code>Poll::Pending</code>.</li>
</ul>
</li>
</ul>
<p>r[expr.negate]</p>
<h2 id="부정-연산자"><a class="header" href="#부정-연산자">부정 연산자</a></h2>
<p>r[expr.negate.syntax]</p>
<pre><code class="language-grammar expressions">NegationExpression -&gt;
      `-` Expression
    | `!` Expression
</code></pre>
<p>r[expr.negate.intro] These are the last two unary operators.</p>
<p>r[expr.negate.results] This table summarizes the behavior of them on primitive types and which traits are used to overload these operators for other types. Remember that signed integers are always represented using two’s complement. The operands of all of these operators are evaluated in <a href="expressions/../expressions.html#place-expressions-and-value-expressions">value expression context</a> so are moved or copied.</p>
<div class="table-wrapper"><table><thead><tr><th>기호</th><th>정수</th><th><code>bool</code></th><th>부동 소수점</th><th>오버로딩 트레잇</th></tr></thead><tbody>
<tr><td><code>-</code></td><td>부정*</td><td></td><td>부정</td><td><code>std::ops::Neg</code></td></tr>
<tr><td><code>!</code></td><td>비트 NOT</td><td><a href="expressions/../types/boolean.html#logical-not">논리적 NOT</a></td><td></td><td><code>std::ops::Not</code></td></tr>
</tbody></table>
</div>
<ul>
<li>부호 있는 정수 타입에만 해당.</li>
</ul>
<p>다음은 이러한 연산자의 몇 가지 예입니다</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 6;
assert_eq!(-x, -6);
assert_eq!(!x, -7);
assert_eq!(true, !false);
<span class="boring">}</span></code></pre></pre>
<p>r[expr.arith-logic]</p>
<h2 id="산술-및-논리-이항-연산자"><a class="header" href="#산술-및-논리-이항-연산자">산술 및 논리 이항 연산자</a></h2>
<p>r[expr.arith-logic.syntax]</p>
<pre><code class="language-grammar expressions">ArithmeticOrLogicalExpression -&gt;
      Expression `+` Expression
    | Expression `-` Expression
    | Expression `*` Expression
    | Expression `/` Expression
    | Expression `%` Expression
    | Expression `&amp;` Expression
    | Expression `|` Expression
    | Expression `^` Expression
    | Expression `&lt;&lt;` Expression
    | Expression `&gt;&gt;` Expression
</code></pre>
<p>r[expr.arith-logic.intro] Binary operators expressions are all written with infix notation.</p>
<p>r[expr.arith-logic.behavior] This table summarizes the behavior of arithmetic and logical binary operators on primitive types and which traits are used to overload these operators for other types. Remember that signed integers are always represented using two’s complement. The operands of all of these operators are evaluated in <a href="expressions/../expressions.html#place-expressions-and-value-expressions">value expression context</a> so are moved or copied.</p>
<div class="table-wrapper"><table><thead><tr><th>기호</th><th>정수</th><th><code>bool</code></th><th>부동 소수점</th><th>오버로딩 트레잇</th><th>복합 할당 트레잇 오버로딩</th></tr></thead><tbody>
<tr><td><code>+</code></td><td>덧셈</td><td></td><td>덧셈</td><td><code>std::ops::Add</code></td><td><code>std::ops::AddAssign</code></td></tr>
<tr><td><code>-</code></td><td>뺄셈</td><td></td><td>뺄셈</td><td><code>std::ops::Sub</code></td><td><code>std::ops::SubAssign</code></td></tr>
<tr><td><code>*</code></td><td>곱셈</td><td></td><td>곱셈</td><td><code>std::ops::Mul</code></td><td><code>std::ops::MulAssign</code></td></tr>
<tr><td><code>/</code></td><td>나눗셈*†</td><td></td><td>나눗셈</td><td><code>std::ops::Div</code></td><td><code>std::ops::DivAssign</code></td></tr>
<tr><td><code>%</code></td><td>나머지**†</td><td></td><td>나머지</td><td><code>std::ops::Rem</code></td><td><code>std::ops::RemAssign</code></td></tr>
<tr><td><code>&amp;</code></td><td>비트 AND</td><td><a href="expressions/../types/boolean.html#logical-and">논리적 AND</a></td><td></td><td><code>std::ops::BitAnd</code></td><td><code>std::ops::BitAndAssign</code></td></tr>
<tr><td><code>|</code></td><td>비트 OR</td><td><a href="expressions/../types/boolean.html#logical-or">논리적 OR</a></td><td></td><td><code>std::ops::BitOr</code></td><td><code>std::ops::BitOrAssign</code></td></tr>
<tr><td><code>^</code></td><td>비트 XOR</td><td><a href="expressions/../types/boolean.html#logical-xor">논리적 XOR</a></td><td></td><td><code>std::ops::BitXor</code></td><td><code>std::ops::BitXorAssign</code></td></tr>
<tr><td><code>&lt;&lt;</code></td><td>왼쪽 시프트</td><td></td><td></td><td><code>std::ops::Shl</code></td><td><code>std::ops::ShlAssign</code></td></tr>
<tr><td><code>&gt;&gt;</code></td><td>오른쪽 시프트***</td><td></td><td></td><td><code>std::ops::Shr</code></td><td><code>std::ops::ShrAssign</code></td></tr>
</tbody></table>
</div>
<ul>
<li>정수 나눗셈은 0을 향해 반올림합니다.</li>
</ul>
<p>** Rust는 <a href="https://en.wikipedia.org/wiki/Modulo_operation#Variants_of_the_definition">절단 나눗셈</a>으로 정의된 나머지를 사용합니다. <code>remainder = dividend % divisor</code>라고 할 때, 나머지는 피제수(dividend)와 같은 부호를 가집니다.</p>
<p>*** 부호 있는 정수 타입에서는 산술 오른쪽 시프트, 부호 없는 정수 타입에서는 논리 오른쪽 시프트입니다.</p>
<p>† 정수 타입의 경우, 0으로 나누면 패닉이 발생합니다.</p>
<p>다음은 이러한 연산자가 사용되는 예입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(3 + 6, 9);
assert_eq!(5.5 - 1.25, 4.25);
assert_eq!(-5 * 14, -70);
assert_eq!(14 / 3, 4);
assert_eq!(100 % 7, 2);
assert_eq!(0b1010 &amp; 0b1100, 0b1000);
assert_eq!(0b1010 | 0b1100, 0b1110);
assert_eq!(0b1010 ^ 0b1100, 0b110);
assert_eq!(13 &lt;&lt; 3, 104);
assert_eq!(-10 &gt;&gt; 2, -3);
<span class="boring">}</span></code></pre></pre>
<p>r[expr.cmp]</p>
<h2 id="비교-연산자"><a class="header" href="#비교-연산자">비교 연산자</a></h2>
<p>r[expr.cmp.syntax]</p>
<pre><code class="language-grammar expressions">ComparisonExpression -&gt;
      Expression `==` Expression
    | Expression `!=` Expression
    | Expression `&gt;` Expression
    | Expression `&lt;` Expression
    | Expression `&gt;=` Expression
    | Expression `&lt;=` Expression
</code></pre>
<p>r[expr.cmp.intro] Comparison operators are also defined both for primitive types and many types in the standard library.</p>
<p>r[expr.cmp.paren-chaining] Parentheses are required when chaining comparison operators. For example, the expression <code>a == b == c</code> is invalid and may be written as <code>(a == b) == c</code>.</p>
<p>r[expr.cmp.trait] Unlike arithmetic and logical operators, the traits for overloading these operators are used more generally to show how a type may be compared and will likely be assumed to define actual comparisons by functions that use these traits as bounds. Many functions and macros in the standard library can then use that assumption (although not to ensure safety).</p>
<p>r[expr.cmp.place] Unlike the arithmetic and logical operators above, these operators implicitly take shared borrows of their operands, evaluating them in <a href="expressions/../expressions.html#place-expressions-and-value-expressions">place expression context</a>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let a = 1;
</span><span class="boring">let b = 1;
</span>a == b;
// 다음과 동일합니다
::std::cmp::PartialEq::eq(&amp;a, &amp;b);
<span class="boring">}</span></code></pre></pre>
<p>이는 피연산자를 밖으로 이동시킬 필요가 없음을 의미합니다.</p>
<p>r[expr.cmp.behavior]</p>
<div class="table-wrapper"><table><thead><tr><th>기호</th><th>의미</th><th>오버로딩 메서드</th></tr></thead><tbody>
<tr><td><code>==</code></td><td>같음</td><td><code>std::cmp::PartialEq::eq</code></td></tr>
<tr><td><code>!=</code></td><td>같지 않음</td><td><code>std::cmp::PartialEq::ne</code></td></tr>
<tr><td><code>&gt;</code></td><td>보다 큼</td><td><code>std::cmp::PartialOrd::gt</code></td></tr>
<tr><td><code>&lt;</code></td><td>보다 작음</td><td><code>std::cmp::PartialOrd::lt</code></td></tr>
<tr><td><code>&gt;=</code></td><td>보다 크거나 같음</td><td><code>std::cmp::PartialOrd::ge</code></td></tr>
<tr><td><code>&lt;=</code></td><td>보다 작거나 같음</td><td><code>std::cmp::PartialOrd::le</code></td></tr>
</tbody></table>
</div>
<p>다음은 비교 연산자가 사용되는 예입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert!(123 == 123);
assert!(23 != -12);
assert!(12.5 &gt; 12.2);
assert!([1, 2, 3] &lt; [1, 3, 4]);
assert!('A' &lt;= 'B');
assert!("World" &gt;= "Hello");
<span class="boring">}</span></code></pre></pre>
<p>r[expr.bool-logic]</p>
<h2 id="지연-불리언-연산자"><a class="header" href="#지연-불리언-연산자">지연 불리언 연산자</a></h2>
<p>r[expr.bool-logic.syntax]</p>
<pre><code class="language-grammar expressions">LazyBooleanExpression -&gt;
      Expression `||` Expression
    | Expression `&amp;&amp;` Expression
</code></pre>
<p>r[expr.bool-logic.intro] The operators <code>||</code> and <code>&amp;&amp;</code> may be applied to operands of boolean type. The <code>||</code> operator denotes logical ‘or’, and the <code>&amp;&amp;</code> operator denotes logical ‘and’.</p>
<p>r[expr.bool-logic.conditional-evaluation] They differ from <code>|</code> and <code>&amp;</code> in that the right-hand operand is only evaluated when the left-hand operand does not already determine the result of the expression. That is, <code>||</code> only evaluates its right-hand operand when the left-hand operand evaluates to <code>false</code>, and <code>&amp;&amp;</code> only when it evaluates to <code>true</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = false || true; // 참(true)
let y = false &amp;&amp; panic!(); // 거짓(false), `panic!()`을 평가하지 않음
<span class="boring">}</span></code></pre></pre>
<p>r[expr.as]</p>
<h2 id="타입-캐스트-표현식"><a class="header" href="#타입-캐스트-표현식">타입 캐스트 표현식</a></h2>
<p>r[expr.as.syntax]</p>
<pre><code class="language-grammar expressions">TypeCastExpression -&gt; Expression `as` TypeNoBounds
</code></pre>
<p>r[expr.as.intro] A type cast expression is denoted with the binary operator <code>as</code>.</p>
<p>r[expr.as.result] Executing an <code>as</code> expression casts the value on the left-hand side to the type on the right-hand side.</p>
<p><code>as</code> 표현식의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn sum(values: &amp;[f64]) -&gt; f64 { 0.0 }
</span><span class="boring">fn len(values: &amp;[f64]) -&gt; i32 { 0 }
</span>fn average(values: &amp;[f64]) -&gt; f64 {
    let sum: f64 = sum(values);
    let size: f64 = len(values) as f64;
    sum / size
}
<span class="boring">}</span></code></pre></pre>
<p>r[expr.as.coercions] <code>as</code> can be used to explicitly perform <a href="expressions/../type-coercions.html">coercions</a>, as well as the following additional casts. Any cast that does not fit either a coercion rule or an entry in the table is a compiler error. Here <code>*T</code> means either <code>*const T</code> or <code>*mut T</code>. <code>m</code> stands for optional <code>mut</code> in reference types and <code>mut</code> or <code>const</code> in pointer types.</p>
<div class="table-wrapper"><table><thead><tr><th><code>e</code>의 타입</th><th><code>U</code></th><th><code>e as U</code>에 의해 수행되는 캐스트</th></tr></thead><tbody>
<tr><td>정수 또는 부동 소수점 타입</td><td>정수 또는 부동 소수점 타입</td><td>[Numeric cast][expr.as.numeric]</td></tr>
<tr><td>열거형</td><td>정수 타입</td><td>[Enum cast][expr.as.enum]</td></tr>
<tr><td><code>bool</code> 또는 <code>char</code></td><td>정수 타입</td><td>[Primitive to integer cast][expr.as.bool-char-as-int]</td></tr>
<tr><td><code>u8</code></td><td><code>char</code></td><td>[<code>u8</code> to <code>char</code> cast][expr.as.u8-as-char]</td></tr>
<tr><td><code>*T</code></td><td><code>*V</code> <sup class="footnote-reference"><a href="#meta-compat">1</a></sup></td><td>[Pointer to pointer cast][expr.as.pointer]</td></tr>
<tr><td><code>*T</code> (여기서 <code>T: Sized</code>)</td><td>정수 타입</td><td>[Pointer to address cast][expr.as.pointer-as-int]</td></tr>
<tr><td>정수 타입</td><td><code>*V</code> (여기서 <code>V: Sized</code>)</td><td>[Address to pointer cast][expr.as.int-as-pointer]</td></tr>
<tr><td><code>&amp;m₁ [T; n]</code></td><td><code>*m₂ T</code> <sup class="footnote-reference"><a href="#lessmut">2</a></sup></td><td>배열에서 포인터로의 캐스트</td></tr>
<tr><td><code>*m₁ [T; n]</code></td><td><code>*m₂ T</code> <sup class="footnote-reference"><a href="#lessmut">2</a></sup></td><td>배열에서 포인터로의 캐스트</td></tr>
<tr><td><a href="expressions/../types/function-item.html">함수 아이템</a></td><td><a href="expressions/../types/function-pointer.html">함수 포인터</a></td><td>함수 아이템에서 함수 포인터로의 캐스트</td></tr>
<tr><td><a href="expressions/../types/function-item.html">함수 아이템</a></td><td><code>*V</code> (여기서 <code>V: Sized</code>)</td><td>함수 아이템에서 포인터로의 캐스트</td></tr>
<tr><td><a href="expressions/../types/function-item.html">함수 아이템</a></td><td>정수</td><td>함수 아이템에서 주소로의 캐스트</td></tr>
<tr><td><a href="expressions/../types/function-pointer.html">함수 포인터</a></td><td><code>*V</code> (여기서 <code>V: Sized</code>)</td><td>함수 포인터에서 포인터로의 캐스트</td></tr>
<tr><td><a href="expressions/../types/function-pointer.html">함수 포인터</a></td><td>정수</td><td>함수 포인터에서 주소로의 캐스트</td></tr>
<tr><td>클로저 <sup class="footnote-reference"><a href="#no-capture">3</a></sup></td><td>함수 포인터</td><td>클로저에서 함수 포인터로의 캐스트</td></tr>
</tbody></table>
</div>
<div class="footnote-definition" id="meta-compat"><sup class="footnote-definition-label">1</sup>
<p>Where <code>T</code> and <code>V</code> have compatible metadata: * <code>V: Sized</code>, or * Both slice metadata (<code>*[u16]</code> -&gt; <code>*[u8]</code>, <code>*str</code> -&gt; <code>*(u8, [u32])</code>), or * Both the same trait object metadata, modulo dropping auto traits (<code>*dyn Debug</code> -&gt; <code>*(u16, dyn Debug)</code>, <code>*dyn Debug + Send</code> -&gt; <code>*dyn Debug</code>) * <strong>Note</strong>: <em>adding</em> auto traits is only allowed if the principal trait has the auto trait as a super trait (given <code>trait T: Send {}</code>, <code>*dyn T</code> -&gt; <code>*dyn T + Send</code> is valid, but <code>*dyn Debug</code> -&gt; <code>*dyn Debug + Send</code> is not) * <strong>Note</strong>: Generics (including lifetimes) must match (<code>*dyn T&lt;'a, A&gt;</code> -&gt; <code>*dyn T&lt;'b, B&gt;</code> requires <code>'a = 'b</code> and <code>A = B</code>)</p>
</div>
<div class="footnote-definition" id="lessmut"><sup class="footnote-definition-label">2</sup>
<p>Only when <code>m₁</code> is <code>mut</code> or <code>m₂</code> is <code>const</code>. Casting <code>mut</code> reference/pointer to <code>const</code> pointer is allowed.</p>
</div>
<div class="footnote-definition" id="no-capture"><sup class="footnote-definition-label">3</sup>
<p>Only closures that do not capture (close over) any local variables can be cast to function pointers.</p>
</div>
<h3 id="의미론"><a class="header" href="#의미론">의미론</a></h3>
<p>r[expr.as.numeric]</p>
<h4 id="숫자-캐스트"><a class="header" href="#숫자-캐스트">숫자 캐스트</a></h4>
<p>r[expr.as.numeric.int-same-size]</p>
<ul>
<li>
<p>같은 크기의 두 정수 간 캐스팅(예: i32 -&gt; u32)은 무연산(no-op)입니다(러스트는 고정 정수의 음수 값에 2의 보수를 사용합니다).</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(42i8 as u8, 42u8);
assert_eq!(-1i8 as u8, 255u8);
assert_eq!(255u8 as i8, -1i8);
assert_eq!(-1i16 as u16, 65535u16);
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<p>r[expr.as.numeric.int-truncation]</p>
<ul>
<li>
<p>더 큰 정수에서 더 작은 정수로의 캐스팅(예: u32 -&gt; u8)은 잘라냅니다(truncate).</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(42u16 as u8, 42u8);
assert_eq!(1234u16 as u8, 210u8);
assert_eq!(0xabcdu16 as u8, 0xcdu8);

assert_eq!(-42i16 as i8, -42i8);
assert_eq!(1234u16 as i8, -46i8);
assert_eq!(0xabcdi32 as i8, -51i8);
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<p>r[expr.as.numeric.int-extension]</p>
<ul>
<li>
<p>더 작은 정수에서 더 큰 정수로의 캐스팅(예: u8 -&gt; u32)은 다음과 같습니다.</p>
<ul>
<li>소스가 부호 없으면 0으로 확장(zero-extend)</li>
<li>소스가 부호 있으면 부호 확장(sign-extend)</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(42i8 as i16, 42i16);
assert_eq!(-17i8 as i16, -17i16);
assert_eq!(0b1000_1010u8 as u16, 0b0000_0000_1000_1010u16, "0으로 확장");
assert_eq!(0b0000_1010i8 as i16, 0b0000_0000_0000_1010i16, "부호 확장 0");
assert_eq!(0b1000_1010u8 as i8 as i16, 0b1111_1111_1000_1010u16 as i16, "부호 확장 1");
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<p>r[expr.as.numeric.float-as-int]</p>
<ul>
<li>
<p>부동 소수점에서 정수로의 캐스팅은 부동 소수점을 0을 향해 반올림합니다.</p>
<ul>
<li><code>NaN</code>은 <code>0</code>을 반환합니다.</li>
<li><code>INFINITY</code>를 포함하여 최대 정수 값보다 큰 값은 정수 타입의 최대 값으로 포화(saturate)됩니다.</li>
<li><code>NEG_INFINITY</code>를 포함하여 최소 정수 값보다 작은 값은 정수 타입의 최소 값으로 포화(saturate)됩니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(42.9f32 as i32, 42);
assert_eq!(-42.9f32 as i32, -42);
assert_eq!(42_000_000f32 as i32, 42_000_000);
assert_eq!(std::f32::NAN as i32, 0);
assert_eq!(1_000_000_000_000_000f32 as i32, 0x7fffffffi32);
assert_eq!(std::f32::NEG_INFINITY as i32, -0x80000000i32);
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<p>r[expr.as.numeric.int-as-float]</p>
<ul>
<li>
<p>정수에서 부동 소수점으로의 캐스팅은 가능한 가장 가까운 부동 소수점을 생성합니다 *</p>
<ul>
<li>필요한 경우, 반올림은 <code>roundTiesToEven</code> 모드에 따릅니다 ***</li>
<li>오버플로 시 무한대(입력과 같은 부호)가 생성됩니다</li>
<li>참고: 현재 숫자 타입 세트에서는 <code>f32::MAX + (0.5 ULP)</code>보다 크거나 같은 값에 대해 <code>u128 as f32</code>에서만 오버플로가 발생할 수 있습니다</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(1337i32 as f32, 1337f32);
assert_eq!(123_456_789i32 as f32, 123_456_790f32, "반올림됨");
assert_eq!(0xffffffff_ffffffff_ffffffff_ffffffff_u128 as f32, std::f32::INFINITY);
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<p>r[expr.as.numeric.float-widening]</p>
<ul>
<li>
<p>f32에서 f64로의 캐스팅은 완벽하며 손실이 없습니다</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(1_234.5f32 as f64, 1_234.5f64);
assert_eq!(std::f32::INFINITY as f64, std::f64::INFINITY);
assert!((std::f32::NAN as f64).is_nan());
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<p>r[expr.as.numeric.float-narrowing]</p>
<ul>
<li>
<p>f64에서 f32로의 캐스팅은 가능한 가장 가까운 f32를 생성합니다 **</p>
<ul>
<li>필요한 경우, 반올림은 <code>roundTiesToEven</code> 모드에 따릅니다 ***</li>
<li>오버플로 시 무한대(입력과 같은 부호)가 생성됩니다</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(1_234.5f64 as f32, 1_234.5f32);
assert_eq!(1_234_567_891.123f64 as f32, 1_234_567_890f32, "반올림됨");
assert_eq!(std::f64::INFINITY as f32, std::f32::INFINITY);
assert!((std::f64::NAN as f32).is_nan());
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<p>* 이 반올림 모드와 오버플로 동작을 사용하는 정수-부동 소수점 캐스팅이 하드웨어에서 기본적으로 지원되지 않는 경우, 이러한 캐스팅은 예상보다 느릴 수 있습니다.</p>
<p>** 이 반올림 모드와 오버플로 동작을 사용하는 f64-f32 캐스팅이 하드웨어에서 기본적으로 지원되지 않는 경우, 이러한 캐스팅은 예상보다 느릴 수 있습니다.</p>
<p>*** IEEE 754-2008 §4.3.1에 정의된 대로: 가장 가까운 부동 소수점 숫자를 선택하고, 두 부동 소수점 숫자 사이의 정확히 중간인 경우 최하위 자릿수가 짝수인 것을 선호합니다.</p>
<p>r[expr.as.enum]</p>
<h4 id="열거형-캐스트"><a class="header" href="#열거형-캐스트">열거형 캐스트</a></h4>
<p>r[expr.as.enum.discriminant] Casts an enum to its discriminant, then uses a numeric cast if needed. Casting is limited to the following kinds of enumerations:</p>
<ul>
<li><a href="expressions/../items/enumerations.html#unit-only-enum">유닛 전용 열거형</a></li>
<li><a href="expressions/../items/enumerations.html#explicit-discriminants">명시적 판별자</a>가 없는 <a href="expressions/../items/enumerations.html#field-less-enum">필드 없는 열거형</a>, 또는 유닛 변형만 명시적 판별자를 갖는 경우</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Enum { A, B, C }
assert_eq!(Enum::A as i32, 0);
assert_eq!(Enum::B as i32, 1);
assert_eq!(Enum::C as i32, 2);
<span class="boring">}</span></code></pre></pre>
<p>r[expr.as.enum.no-drop] Casting is not allowed if the enum implements [<code>Drop</code>].</p>
<p>r[expr.as.bool-char-as-int]</p>
<h4 id="기본-타입에서-정수로의-캐스트"><a class="header" href="#기본-타입에서-정수로의-캐스트">기본 타입에서 정수로의 캐스트</a></h4>
<ul>
<li><code>false</code>는 <code>0</code>으로, <code>true</code>는 <code>1</code>로 캐스팅됩니다</li>
<li><code>char</code>는 코드 포인트 값으로 캐스팅된 다음 필요한 경우 숫자 캐스트를 사용합니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(false as i32, 0);
assert_eq!(true as i32, 1);
assert_eq!('A' as i32, 65);
assert_eq!('Ö' as i32, 214);
<span class="boring">}</span></code></pre></pre>
<p>r[expr.as.u8-as-char]</p>
<h4 id="u8에서-char로의-캐스트"><a class="header" href="#u8에서-char로의-캐스트"><code>u8</code>에서 <code>char</code>로의 캐스트</a></h4>
<p>해당 코드 포인트를 가진 <code>char</code>로 캐스팅합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(65u8 as char, 'A');
assert_eq!(214u8 as char, 'Ö');
<span class="boring">}</span></code></pre></pre>
<p>r[expr.as.pointer-as-int]</p>
<h4 id="포인터에서-주소로의-캐스트"><a class="header" href="#포인터에서-주소로의-캐스트">포인터에서 주소로의 캐스트</a></h4>
<p>원시 포인터에서 정수로의 캐스팅은 참조된 메모리의 기계 주소를 생성합니다. 정수 타입이 포인터 타입보다 작은 경우 주소가 잘릴 수 있습니다. <code>usize</code>를 사용하면 이를 방지할 수 있습니다.</p>
<p>r[expr.as.int-as-pointer]</p>
<h4 id="주소에서-포인터로의-캐스트"><a class="header" href="#주소에서-포인터로의-캐스트">주소에서 포인터로의 캐스트</a></h4>
<p>정수에서 원시 포인터로의 캐스팅은 정수를 메모리 주소로 해석하고 해당 메모리를 참조하는 포인터를 생성합니다.</p>
<blockquote>
<p>[!WARNING] This interacts with the Rust memory model, which is still under development. A pointer obtained from this cast may suffer additional restrictions even if it is bitwise equal to a valid pointer. Dereferencing such a pointer may be <a href="expressions/../behavior-considered-undefined.html">undefined behavior</a> if aliasing rules are not followed.</p>
</blockquote>
<p>건전한 주소 연산의 간단한 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut values: [i32; 2] = [1, 2];
let p1: *mut i32 = values.as_mut_ptr();
let first_address = p1 as usize;
let second_address = first_address + 4; // 4 == size_of::&lt;i32&gt;()
let p2 = second_address as *mut i32;
unsafe {
    *p2 += 1;
}
assert_eq!(values[1], 3);
<span class="boring">}</span></code></pre></pre>
<p>r[expr.as.pointer]</p>
<h4 id="포인터에서-포인터로의-캐스트"><a class="header" href="#포인터에서-포인터로의-캐스트">포인터에서 포인터로의 캐스트</a></h4>
<p>r[expr.as.pointer.behavior] <code>*const T</code> / <code>*mut T</code> can be cast to <code>*const U</code> / <code>*mut U</code> with the following behavior:</p>
<p>r[expr.as.pointer.sized]</p>
<ul>
<li><code>T</code>와 <code>U</code>가 모두 크기가 있는(sized) 경우, 포인터는 변경되지 않고 반환됩니다.</li>
</ul>
<p>r[expr.as.pointer.unsized]</p>
<ul>
<li>
<p><code>T</code>와 <code>U</code>가 모두 크기가 없는(unsized) 경우, 포인터도 변경되지 않고 반환됩니다. 특히 메타데이터는 정확하게 보존됩니다.</p>
<p>예를 들어, <code>*const [T]</code>에서 <code>*const [U]</code>로의 캐스트는 요소 수를 보존합니다. 결과적으로 이러한 캐스트는 포인터가 참조하는 대상의 크기를 반드시 보존하지는 않는다는 점에 유의하십시오(예: <code>*const [u16]</code>을 <code>*const [u8]</code>로 캐스팅하면 원본 크기의 절반인 객체를 참조하는 원시 포인터가 됩니다). <code>str</code> 및 <code>struct Foo(i32, [u8])</code> 또는 <code>(u64, Foo)</code>와 같이 크기가 없는 꼬리가 슬라이스 타입인 복합 타입에도 동일하게 적용됩니다.</p>
</li>
</ul>
<p>r[expr.as.pointer.discard-metadata]</p>
<ul>
<li><code>T</code>는 크기가 없고 <code>U</code>는 크기가 있는 경우, 캐스트는 넓은 포인터(wide pointer) <code>T</code>를 완성하는 모든 메타데이터를 버리고 크기가 없는 포인터의 데이터 부분으로 구성된 얇은 포인터(thin pointer) <code>U</code>를 생성합니다.</li>
</ul>
<p>r[expr.assign]</p>
<h2 id="할당-표현식"><a class="header" href="#할당-표현식">할당 표현식</a></h2>
<p>r[expr.assign.syntax]</p>
<pre><code class="language-grammar expressions">AssignmentExpression -&gt; Expression `=` Expression
</code></pre>
<p>r[expr.assign.intro] An <em>assignment expression</em> moves a value into a specified place.</p>
<p>r[expr.assign.assignee] An assignment expression consists of a <a href="expressions/../expressions.html#mutability">mutable</a> <a href="expressions/../expressions.html#place-expressions-and-value-expressions">assignee expression</a>, the <em>assignee operand</em>, followed by an equals sign (<code>=</code>) and a <a href="expressions/../expressions.html#place-expressions-and-value-expressions">value expression</a>, the <em>assigned value operand</em>.</p>
<p>r[expr.assign.behavior-basic] In its most basic form, an assignee expression is a <a href="expressions/../expressions.html#place-expressions-and-value-expressions">place expression</a>, and we discuss this case first.</p>
<p>r[expr.assign.behavior-destructuring] The more general case of destructuring assignment is discussed below, but this case always decomposes into sequential assignments to place expressions, which may be considered the more fundamental case.</p>
<p>r[expr.assign.basic]</p>
<h3 id="기본-할당"><a class="header" href="#기본-할당">기본 할당</a></h3>
<p>r[expr.assign.evaluation-order] Evaluating assignment expressions begins by evaluating its operands. The assigned value operand is evaluated first, followed by the assignee expression.</p>
<p>r[expr.assign.destructuring-order] For destructuring assignment, subexpressions of the assignee expression are evaluated left-to-right.</p>
<blockquote>
<p>[!NOTE] This is different than other expressions in that the right operand is evaluated before the left one.</p>
</blockquote>
<p>r[expr.assign.drop-target] It then has the effect of first <a href="expressions/../destructors.html">dropping</a> the value at the assigned place, unless the place is an uninitialized local variable or an uninitialized field of a local variable.</p>
<p>r[expr.assign.behavior] Next it either <a href="expressions/../expressions.html#moved-and-copied-types">copies or moves</a> the assigned value to the assigned place.</p>
<p>r[expr.assign.result] An assignment expression always produces <a href="expressions/../types/tuple.html">the unit value</a>.</p>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 0;
let y = 0;
x = y;
<span class="boring">}</span></code></pre></pre>
<p>r[expr.assign.destructure]</p>
<h3 id="구조-분해-할당"><a class="header" href="#구조-분해-할당">구조 분해 할당</a></h3>
<p>r[expr.assign.destructure.intro] Destructuring assignment is a counterpart to destructuring pattern matches for variable declaration, permitting assignment to complex values, such as tuples or structs. For instance, we may swap two mutable variables:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (mut a, mut b) = (0, 1);
// 구조 분해 할당을 사용하여 `a`와 `b`를 교환합니다.
(b, a) = (a, b);
<span class="boring">}</span></code></pre></pre>
<p>r[expr.assign.destructure.assignee] In contrast to destructuring declarations using <code>let</code>, patterns may not appear on the left-hand side of an assignment due to syntactic ambiguities. Instead, a group of expressions that correspond to patterns are designated to be <a href="expressions/../expressions.html#place-expressions-and-value-expressions">assignee expressions</a>, and permitted on the left-hand side of an assignment. Assignee expressions are then desugared to pattern matches followed by sequential assignment.</p>
<p>r[expr.assign.destructure.irrefutable] The desugared patterns must be irrefutable: in particular, this means that only slice patterns whose length is known at compile-time, and the trivial slice <code>[..]</code>, are permitted for destructuring assignment.</p>
<p>탈설탕 방법은 간단하며, 예제로 설명하는 것이 가장 좋습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Struct { x: u32, y: u32 }
</span><span class="boring">let (mut a, mut b) = (0, 0);
</span>(a, b) = (3, 4);

[a, b] = [3, 4];

Struct { x: a, y: b } = Struct { x: 3, y: 4};

// 다음과 같이 탈설탕됩니다:

{
    let (_a, _b) = (3, 4);
    a = _a;
    b = _b;
}

{
    let [_a, _b] = [3, 4];
    a = _a;
    b = _b;
}

{
    let Struct { x: _a, y: _b } = Struct { x: 3, y: 4};
    a = _a;
    b = _b;
}
<span class="boring">}</span></code></pre></pre>
<p>r[expr.assign.destructure.repeat-ident] Identifiers are not forbidden from being used multiple times in a single assignee expression.</p>
<p>r[expr.assign.destructure.discard-value] <a href="expressions/./underscore-expr.html">Underscore expressions</a> and empty <a href="expressions/./range-expr.html">range expressions</a> may be used to ignore certain values, without binding them.</p>
<p>r[expr.assign.destructure.default-binding] Note that default binding modes do not apply for the desugared expression.</p>
<p>r[expr.assign.destructure.tmp-scopes]</p>
<blockquote>
<p>[!NOTE] The desugaring restricts the <a href="expressions/destructors.scope.temporary">temporary scope</a> of the assigned value operand (the RHS) of a destructuring assignment.</p>
<p>In a basic assignment, the <a href="expressions/expr.temporary">temporary</a> is dropped at the end of the enclosing temporary scope. Below, that’s the statement. Therefore, the assignment and use is allowed.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn temp() {}
</span>fn f&lt;T&gt;(x: T) -&gt; T { x }
let x;
(x = f(&amp;temp()), x); // OK
<span class="boring">}</span></code></pre></pre>
<p>Conversely, in a destructuring assignment, the temporary is dropped at the end of the <code>let</code> statement in the desugaring. As that happens before we try to assign to <code>x</code>, below, it fails.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0716 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn temp() {}
</span><span class="boring">fn f&lt;T&gt;(x: T) -&gt; T { x }
</span><span class="boring">let x;
</span>[x] = [f(&amp;temp())]; // 오류
<span class="boring">}</span></code></pre></pre>
<p>This desugars to:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0716 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn temp() {}
</span><span class="boring">fn f&lt;T&gt;(x: T) -&gt; T { x }
</span><span class="boring">let x;
</span>{
    let [_x] = [f(&amp;temp())];
    //                     ^
    //      The temporary is dropped here.
    x = _x; // 오류
}
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[expr.assign.destructure.tmp-ext]</p>
<blockquote>
<p>[!NOTE] Due to the desugaring, the assigned value operand (the RHS) of a destructuring assignment is an <a href="expressions/destructors.scope.lifetime-extension.exprs">extending expression</a> within a newly-introduced block.</p>
<p>Below, because the <a href="expressions/destructors.scope.temporary">temporary scope</a> is extended to the end of this introduced block, the assignment is allowed.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn temp() {}
</span><span class="boring">let x;
</span>[x] = [&amp;temp()]; // OK
<span class="boring">}</span></code></pre></pre>
<p>This desugars to:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn temp() {}
</span><span class="boring">let x;
</span>{ let [_x] = [&amp;temp()]; x = _x; } // OK
<span class="boring">}</span></code></pre></pre>
<p>However, if we try to use <code>x</code>, even within the same statement, we’ll get an error because the <a href="expressions/expr.temporary">temporary</a> is dropped at the end of this introduced block.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0716 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn temp() {}
</span><span class="boring">let x;
</span>([x] = [&amp;temp()], x); // 오류
<span class="boring">}</span></code></pre></pre>
<p>This desugars to:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0716 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn temp() {}
</span><span class="boring">let x;
</span>(
    {
        let [_x] = [&amp;temp()];
        x = _x;
    }, // &lt;-- The temporary is dropped here.
    x, // 오류
);
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[expr.compound-assign]</p>
<h2 id="복합-할당-표현식"><a class="header" href="#복합-할당-표현식">복합 할당 표현식</a></h2>
<p>r[expr.compound-assign.syntax]</p>
<pre><code class="language-grammar expressions">CompoundAssignmentExpression -&gt;
      Expression `+=` Expression
    | Expression `-=` Expression
    | Expression `*=` Expression
    | Expression `/=` Expression
    | Expression `%=` Expression
    | Expression `&amp;=` Expression
    | Expression `|=` Expression
    | Expression `^=` Expression
    | Expression `&lt;&lt;=` Expression
    | Expression `&gt;&gt;=` Expression
</code></pre>
<p>r[expr.compound-assign.intro] <em>Compound assignment expressions</em> combine arithmetic and logical binary operators with assignment expressions.</p>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 5;
x += 1;
assert!(x == 6);
<span class="boring">}</span></code></pre></pre>
<p>복합 할당의 구문은 <a href="expressions/../expressions.html#mutability">가변</a> <a href="expressions/../expressions.html#place-expressions-and-value-expressions">장소 표현식</a>(<em>할당된 피연산자</em>), 그 다음에 단일 토큰(공백 없음)으로 <code>=</code>이 뒤따르는 연산자 중 하나, 그리고 <a href="expressions/../expressions.html#place-expressions-and-value-expressions">값 표현식</a>(<em>수정하는 피연산자</em>)입니다.</p>
<p>r[expr.compound-assign.place] Unlike other place operands, the assigned place operand must be a place expression.</p>
<p>r[expr.compound-assign.no-value] Attempting to use a value expression is a compiler error rather than promoting it to a temporary.</p>
<p>r[expr.compound-assign.operand-order] Evaluation of compound assignment expressions depends on the types of the operands.</p>
<p>r[expr.compound-assign.primitives] If the types of both operands are known, prior to monomorphization, to be primitive, the right hand side is evaluated first, the left hand side is evaluated next, and the place given by the evaluation of the left hand side is mutated by applying the operator to the values of both sides.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use core::{num::Wrapping, ops::AddAssign};
</span><span class="boring">
</span>trait Equate {}
impl&lt;T&gt; Equate for (T, T) {}

fn f1(x: (u8,)) {
    let mut order = vec![];
    // The RHS is evaluated first as both operands are of primitive
    // type.
    { order.push(2); x }.0 += { order.push(1); x }.0;
    assert!(order.is_sorted());
}

fn f2(x: (Wrapping&lt;u8&gt;,)) {
    let mut order = vec![];
    // The LHS is evaluated first as `Wrapping&lt;_&gt;` is not a primitive
    // type.
    { order.push(1); x }.0 += { order.push(2); (0u8,) }.0;
    assert!(order.is_sorted());
}

fn f3&lt;T: AddAssign&lt;u8&gt; + Copy&gt;(x: (T,)) where (T, u8): Equate {
    let mut order = vec![];
    // The LHS is evaluated first as one of the operands is a generic
    // parameter, even though that generic parameter can be unified
    // with a primitive type due to the where clause bound.
    { order.push(1); x }.0 += { order.push(2); (0u8,) }.0;
    assert!(order.is_sorted());
}

fn main() {
    f1((0u8,));
    f2((Wrapping(0u8),));
    // We supply a primitive type as the generic argument, but this
    // does not affect the evaluation order in `f3` when
    // monomorphized.
    f3::&lt;u8&gt;((0u8,));
}</code></pre></pre>
<blockquote>
<p>[!NOTE] This is unusual. Elsewhere left to right evaluation is the norm.</p>
<p>See the <a href="https://github.com/rust-lang/rust/blob/1.58.0/src/test/ui/expr/compound-assignment/eval-order.rs">eval order test</a> for more examples.</p>
</blockquote>
<p>r[expr.compound-assign.trait] Otherwise, this expression is syntactic sugar for using the corresponding trait for the operator (see [expr.arith-logic.behavior]) and calling its method with the left hand side as the <a href="expressions/expr.method.intro">receiver</a> and the right hand side as the next argument.</p>
<p>For example, the following two statements are equivalent:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::ops::AddAssign;
</span>fn f&lt;T: AddAssign + Copy&gt;(mut x: T, y: T) {
    x += y; // Statement 1.
    x.add_assign(y); // Statement 2.
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] Surprisingly, desugaring this further to a fully qualified method call is not equivalent, as there is special borrow checker behavior when the mutable reference to the first operand is taken via <a href="expressions/expr.method.candidate-receivers-refs">autoref</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::ops::AddAssign;
</span>fn f&lt;T: AddAssign + Copy&gt;(mut x: T) {
    // Here we used `x` as both the LHS and the RHS. Because the
    // mutable borrow of the LHS needed to call the trait method
    // is taken implicitly by autoref, this is OK.
    x += x; //~ OK
    x.add_assign(x); //~ OK
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail E0503 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::ops::AddAssign;
</span>fn f&lt;T: AddAssign + Copy&gt;(mut x: T) {
    // We can't desugar the above to the below, as once we take the
    // mutable borrow of `x` to pass the first argument, we can't
    // pass `x` by value in the second argument because the mutable
    // reference is still live.
    &lt;T as AddAssign&gt;::add_assign(&amp;mut x, x);
    //~^ ERROR cannot use `x` because it was mutably borrowed
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail E0503 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::ops::AddAssign;
</span>fn f&lt;T: AddAssign + Copy&gt;(mut x: T) {
    // As above.
    (&amp;mut x).add_assign(x);
    //~^ ERROR cannot use `x` because it was mutably borrowed
}
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[expr.compound-assign.result] As with normal assignment expressions, compound assignment expressions always produce <a href="expressions/../types/tuple.html">the unit value</a>.</p>
<blockquote>
<p>[!WARNING] Avoid writing code that depends on the evaluation order of operands in compound assignments as it can be unusual and surprising.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>r[expr.paren]</p>
<h1 id="그룹화된-표현식"><a class="header" href="#그룹화된-표현식">그룹화된 표현식</a></h1>
<p>r[expr.paren.syntax]</p>
<pre><code class="language-grammar expressions">GroupedExpression -&gt; `(` Expression `)`
</code></pre>
<p>r[expr.paren.intro] A <em>parenthesized expression</em> wraps a single expression, evaluating to that expression. The syntax for a parenthesized expression is a <code>(</code>, then an expression, called the <em>enclosed operand</em>, and then a <code>)</code>.</p>
<p>r[expr.paren.evaluation] Parenthesized expressions evaluate to the value of the enclosed operand.</p>
<p>r[expr.paren.place-or-value] Unlike other expressions, parenthesized expressions are both <a href="expressions/../expressions.html#place-expressions-and-value-expressions">place expressions and value expressions</a>. When the enclosed operand is a place expression, it is a place expression and when the enclosed operand is a value expression, it is a value expression.</p>
<p>r[expr.paren.override-precedence] Parentheses can be used to explicitly modify the precedence order of subexpressions within an expression.</p>
<p>괄호로 묶인 표현식의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: i32 = 2 + 3 * 4; // 괄호로 묶이지 않음
let y: i32 = (2 + 3) * 4; // 괄호로 묶임
assert_eq!(x, 14);
assert_eq!(y, 20);
<span class="boring">}</span></code></pre></pre>
<p>괄호가 반드시 필요한 경우의 예는 구조체의 멤버인 함수 포인터를 호출할 때입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct A {
</span><span class="boring">   f: fn() -&gt; &amp;'static str
</span><span class="boring">}
</span><span class="boring">impl A {
</span><span class="boring">   fn f(&amp;self) -&gt; &amp;'static str {
</span><span class="boring">       "메서드 f"
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">let a = A{f: || "필드 f"};
</span><span class="boring">
</span>assert_eq!( a.f (), "메서드 f");
assert_eq!((a.f)(), "필드 f");
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p>r[expr.array]</p>
<h1 id="배열-및-배열-인덱스-표현식"><a class="header" href="#배열-및-배열-인덱스-표현식">배열 및 배열 인덱스 표현식</a></h1>
<h2 id="배열-표현식"><a class="header" href="#배열-표현식">배열 표현식</a></h2>
<p>r[expr.array.syntax]</p>
<pre><code class="language-grammar expressions">ArrayExpression -&gt; `[` ArrayElements? `]`

ArrayElements -&gt;
      Expression ( `,` Expression )* `,`?
    | Expression `;` Expression
</code></pre>
<p>r[expr.array.constructor] <em>Array expressions</em> construct <a href="expressions/../types/array.html">arrays</a>. Array expressions come in two forms.</p>
<p>r[expr.array.array] The first form lists out every value in the array.</p>
<p>r[expr.array.array-syntax] The syntax for this form is a comma-separated list of expressions of uniform type enclosed in square brackets.</p>
<p>r[expr.array.array-behavior] This produces an array containing each of these values in the order they are written.</p>
<p>r[expr.array.repeat] The syntax for the second form is two expressions separated by a semicolon (<code>;</code>) enclosed in square brackets.</p>
<p>r[expr.array.repeat-operand] The expression before the <code>;</code> is called the <em>repeat operand</em>.</p>
<p>r[expr.array.length-operand] The expression after the <code>;</code> is called the <em>length operand</em>.</p>
<p>r[expr.array.length-restriction] The length operand must either be an <a href="expressions/items.generics.const.inferred">inferred const</a> or be a <a href="expressions/../const_eval.html#constant-expressions">constant expression</a> of type <code>usize</code> (e.g. a <a href="expressions/../tokens.html#literals">literal</a> or a <a href="expressions/../items/constant-items.html">constant item</a>).</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const C: usize = 1;
let _: [u8; C] = [0; 1]; // Literal.
let _: [u8; C] = [0; C]; // Constant item.
let _: [u8; C] = [0; _]; // Inferred const.
let _: [u8; C] = [0; (((_)))]; // Inferred const.
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] In an array expression, an <a href="expressions/items.generics.const.inferred">inferred const</a> is parsed as an [expression][Expression] but then semantically treated as a separate kind of <a href="expressions/items.generics.const.argument">const generic argument</a>.</p>
</blockquote>
<p>r[expr.array.repeat-behavior] An array expression of this form creates an array with the length of the value of the length operand with each element being a copy of the repeat operand. That is, <code>[a; b]</code> creates an array containing <code>b</code> copies of the value of <code>a</code>.</p>
<p>r[expr.array.repeat-copy] If the length operand has a value greater than 1 then this requires the repeat operand to have a type that implements <a href="expressions/../special-types-and-traits.html#copy"><code>Copy</code></a>, to be a <a href="expressions/expr.block.const">const block expression</a>, or to be a <a href="expressions/path-expr.html">path</a> to a constant item.</p>
<p>r[expr.array.repeat-const-item] When the repeat operand is a const block or a path to a constant item, it is evaluated the number of times specified in the length operand.</p>
<p>r[expr.array.repeat-evaluation-zero] If that value is <code>0</code>, then the const block or constant item is not evaluated at all.</p>
<p>r[expr.array.repeat-non-const] For expressions that are neither a const block nor a path to a constant item, it is evaluated exactly once, and then the result is copied the length operand’s value times.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[1, 2, 3, 4];
["a", "b", "c", "d"];
[0; 128];              // 128개의 0을 가진 배열
[0u8, 0u8, 0u8, 0u8,];
[[1, 0, 0], [0, 1, 0], [0, 0, 1]]; // 2차원 배열
const EMPTY: Vec&lt;i32&gt; = Vec::new();
[EMPTY; 2];
<span class="boring">}</span></code></pre></pre>
<p>r[expr.array.index]</p>
<h2 id="배열-및-슬라이스-인덱싱-표현식"><a class="header" href="#배열-및-슬라이스-인덱싱-표현식">배열 및 슬라이스 인덱싱 표현식</a></h2>
<p>r[expr.array.index.syntax]</p>
<pre><code class="language-grammar expressions">IndexExpression -&gt; Expression `[` Expression `]`
</code></pre>
<p>r[expr.array.index.array] <a href="expressions/../types/array.html">Array</a> and <a href="expressions/../types/slice.html">slice</a>-typed values can be indexed by writing a square-bracket-enclosed expression of type <code>usize</code> (the index) after them. When the array is mutable, the resulting <a href="expressions/../expressions.html#place-expressions-and-value-expressions">memory location</a> can be assigned to.</p>
<p>r[expr.array.index.trait] For other types an index expression <code>a[b]</code> is equivalent to <code>*std::ops::Index::index(&amp;a, b)</code>, or <code>*std::ops::IndexMut::index_mut(&amp;mut a, b)</code> in a mutable place expression context. Just as with methods, Rust will also insert dereference operations on <code>a</code> repeatedly to find an implementation.</p>
<p>r[expr.array.index.zero-index] Indices are zero-based for arrays and slices.</p>
<p>r[expr.array.index.const] Array access is a <a href="expressions/../const_eval.html#constant-expressions">constant expression</a>, so bounds can be checked at compile-time with a constant index value. Otherwise a check will be performed at run-time that will put the thread in a <a href="expressions/../panic.html"><em>panicked state</em></a> if it fails.</p>
<pre><pre class="playground"><code class="language-rust should_panic edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 린트는 기본적으로 거부(deny)됩니다.
#![warn(unconditional_panic)]

([1, 2, 3, 4])[2];        // 3으로 평가됩니다

let b = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
b[1][2];                  // 다차원 배열 인덱싱

let x = (["a", "b"])[10]; // 경고: 인덱스가 범위를 벗어남

let n = 10;
let y = (["a", "b"])[n];  // 패닉 발생

let arr = ["a", "b"];
arr[10];                  // 경고: 인덱스가 범위를 벗어남
<span class="boring">}</span></code></pre></pre>
<p>r[expr.array.index.trait-impl] The array index expression can be implemented for types other than arrays and slices by implementing the <a href="std::ops::Index">Index</a> and <a href="std::ops::IndexMut">IndexMut</a> traits.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[expr.tuple]</p>
<h1 id="튜플-및-튜플-인덱싱-표현식"><a class="header" href="#튜플-및-튜플-인덱싱-표현식">튜플 및 튜플 인덱싱 표현식</a></h1>
<h2 id="튜플-표현식"><a class="header" href="#튜플-표현식">튜플 표현식</a></h2>
<p>r[expr.tuple.syntax]</p>
<pre><code class="language-grammar expressions">TupleExpression -&gt; `(` TupleElements? `)`

TupleElements -&gt; ( Expression `,` )+ Expression?
</code></pre>
<p>r[expr.tuple.result] A <em>tuple expression</em> constructs <a href="expressions/../types/tuple.html">tuple values</a>.</p>
<p>r[expr.tuple.intro] The syntax for tuple expressions is a parenthesized, comma separated list of expressions, called the <em>tuple initializer operands</em>.</p>
<p>r[expr.tuple.unary-tuple-restriction] 1-ary tuple expressions require a comma after their tuple initializer operand to be disambiguated with a <a href="expressions/grouped-expr.html">parenthetical expression</a>.</p>
<p>r[expr.tuple.value] Tuple expressions are a <a href="expressions/../expressions.html#place-expressions-and-value-expressions">value expression</a> that evaluate into a newly constructed value of a tuple type.</p>
<p>r[expr.tuple.type] The number of tuple initializer operands is the arity of the constructed tuple.</p>
<p>r[expr.tuple.unit] Tuple expressions without any tuple initializer operands produce the unit tuple.</p>
<p>r[expr.tuple.fields] For other tuple expressions, the first written tuple initializer operand initializes the field <code>0</code> and subsequent operands initializes the next highest field. For example, in the tuple expression <code>('a', 'b', 'c')</code>, <code>'a'</code> initializes the value of the field <code>0</code>, <code>'b'</code> field <code>1</code>, and <code>'c'</code> field <code>2</code>.</p>
<p>튜플 표현식과 그 타입의 예:</p>
<div class="table-wrapper"><table><thead><tr><th>표현식</th><th>유형</th></tr></thead><tbody>
<tr><td><code>()</code></td><td><code>()</code> (유닛)</td></tr>
<tr><td><code>(0.0, 4.5)</code></td><td><code>(f64, f64)</code></td></tr>
<tr><td><code>("x".to_string(), )</code></td><td><code>(String, )</code></td></tr>
<tr><td><code>("a", 4usize, true)</code></td><td><code>(&amp;'static str, usize, bool)</code></td></tr>
</tbody></table>
</div>
<p>r[expr.tuple-index]</p>
<h2 id="튜플-인덱싱-표현식"><a class="header" href="#튜플-인덱싱-표현식">튜플 인덱싱 표현식</a></h2>
<p>r[expr.tuple-index.syntax]</p>
<pre><code class="language-grammar expressions">TupleIndexingExpression -&gt; Expression `.` TUPLE_INDEX
</code></pre>
<p>r[expr.tuple-index.intro] A <em>tuple indexing expression</em> accesses fields of <a href="expressions/../types/tuple.html">tuples</a> and <a href="expressions/../types/struct.html">tuple structs</a>.</p>
<p>튜플 인덱스 표현식의 구문은 _튜플 피연산자_라고 하는 표현식, 그 다음 <code>.</code>, 그리고 마지막으로 튜플 인덱스입니다.</p>
<p>r[expr.tuple-index.index-syntax] The syntax for the <em>tuple index</em> is a <a href="expressions/../tokens.html#integer-literals">decimal literal</a> with no leading zeros, underscores, or suffix. For example <code>0</code> and <code>2</code> are valid tuple indices but not <code>01</code>, <code>0_</code>, nor <code>0i32</code>.</p>
<p>r[expr.tuple-index.required-type] The type of the tuple operand must be a <a href="expressions/../types/tuple.html">tuple type</a> or a <a href="expressions/../types/struct.html">tuple struct</a>.</p>
<p>r[expr.tuple-index.index-name-operand] The tuple index must be a name of a field of the type of the tuple operand.</p>
<p>r[expr.tuple-index.result] Evaluation of tuple index expressions has no side effects beyond evaluation of its tuple operand. As a <a href="expressions/../expressions.html#place-expressions-and-value-expressions">place expression</a>, it evaluates to the location of the field of the tuple operand with the same name as the tuple index.</p>
<p>튜플 인덱싱 표현식의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 튜플 인덱싱
let pair = ("문자열", 2);
assert_eq!(pair.1, 2);

// 튜플 구조체 인덱싱
<span class="boring">struct Point(f32, f32);
</span>let point = Point(1.0, 0.0);
assert_eq!(point.0, 1.0);
assert_eq!(point.1, 0.0);
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] Unlike field access expressions, tuple index expressions can be the function operand of a <a href="expressions/./call-expr.html">call expression</a> as it cannot be confused with a method call since method names cannot be numbers.</p>
</blockquote>
<blockquote>
<p>[!NOTE] Although arrays and slices also have elements, you must use an <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">array or slice indexing expression</a> or a <a href="expressions/../patterns.html#slice-patterns">slice pattern</a> to access their elements.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>r[expr.struct]</p>
<h1 id="구조체-표현식"><a class="header" href="#구조체-표현식">구조체 표현식</a></h1>
<p>r[expr.struct.syntax]</p>
<pre><code class="language-grammar expressions">StructExpression -&gt;
    PathInExpression `{` (StructExprFields | StructBase)? `}`

StructExprFields -&gt;
    StructExprField (`,` StructExprField)* (`,` StructBase | `,`?)

StructExprField -&gt;
    OuterAttribute*
    (
        IDENTIFIER
      | (IDENTIFIER | TUPLE_INDEX) `:` Expression
    )

StructBase -&gt; `..` Expression
</code></pre>
<p>r[expr.struct.intro] A <em>struct expression</em> creates a struct, enum, or union value. It consists of a path to a <a href="expressions/../items/structs.html">struct</a>, <a href="expressions/../items/enumerations.html">enum variant</a>, or <a href="expressions/../items/unions.html">union</a> item followed by the values for the fields of the item.</p>
<p>다음은 구조체 표현식의 예입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Point { x: f64, y: f64 }
</span><span class="boring">struct NothingInMe { }
</span><span class="boring">mod game { pub struct User&lt;'a&gt; { pub name: &amp;'a str, pub age: u32, pub score: usize } }
</span><span class="boring">enum Enum { Variant {} }
</span>Point {x: 10.0, y: 20.0};
NothingInMe {};
let u = game::User {name: "Joe", age: 35, score: 100_000};
Enum::Variant {};
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] Tuple structs and tuple enum variants are typically instantiated using a [call expression][expr.call] referring to the [constructor in the value namespace][items.struct.tuple]. These are distinct from a struct expression using curly braces referring to the constructor in the type namespace.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Position(i32, i32, i32);
Position(0, 0, 0);  // 튜플 구조체를 생성하는 전형적인 방법.
let c = Position;  // `c`는 3개의 인수를 받는 함수입니다.
let pos = c(8, 6, 7);  // `Position` 값을 생성합니다.

enum Version { Triple(i32, i32, i32) };
Version::Triple(0, 0, 0);
let f = Version::Triple;
let ver = f(8, 6, 7);
<span class="boring">}</span></code></pre></pre>
<p>The last segment of the call path cannot refer to a type alias:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Tr { type T; }
impl&lt;T&gt; Tr for T { type T = T; }

struct Tuple();
enum Enum { Tuple() }

// &lt;Unit as Tr&gt;::T(); // causes an error -- `::T` is a type, not a value
&lt;Enum as Tr&gt;::T::Tuple(); // OK
<span class="boring">}</span></code></pre></pre>
<hr />
<p>Unit structs and unit enum variants are typically instantiated using a [path expression][expr.path] referring to the [constant in the value namespace][items.struct.unit].</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Gamma;
// Gamma unit value, referring to the const in the value namespace.
let a = Gamma;
// Exact same value as `a`, but constructed using a struct expression
// referring to the type namespace.
let b = Gamma {};

enum ColorSpace { Oklch }
let c = ColorSpace::Oklch;
let d = ColorSpace::Oklch {};
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[expr.struct.field]</p>
<h2 id="필드-구조체-표현식"><a class="header" href="#필드-구조체-표현식">필드 구조체 표현식</a></h2>
<p>r[expr.struct.field.intro] A struct expression with fields enclosed in curly braces allows you to specify the value for each individual field in any order. The field name is separated from its value with a colon.</p>
<p>r[expr.struct.field.union-constraint] A value of a <a href="expressions/../items/unions.html">union</a> type can only be created using this syntax, and it must specify exactly one field.</p>
<p>r[expr.struct.update]</p>
<h2 id="함수형-업데이트-구문"><a class="header" href="#함수형-업데이트-구문">함수형 업데이트 구문</a></h2>
<p>r[expr.struct.update.intro] A struct expression that constructs a value of a struct type can terminate with the syntax <code>..</code> followed by an expression to denote a functional update.</p>
<p>r[expr.struct.update.base-same-type] The expression following <code>..</code> (the base) must have the same struct type as the new struct type being formed.</p>
<p>r[expr.struct.update.fields] The entire expression uses the given values for the fields that were specified and moves or copies the remaining fields from the base expression.</p>
<p>r[expr.struct.update.visibility-constraint] As with all struct expressions, all of the fields of the struct must be <a href="expressions/../visibility-and-privacy.html">visible</a>, even those not explicitly named.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Point3d { x: i32, y: i32, z: i32 }
</span>let mut base = Point3d {x: 1, y: 2, z: 3};
let y_ref = &amp;mut base.y;
Point3d {y: 0, z: 10, .. base}; // OK, base.x만 접근됩니다
drop(y_ref);
<span class="boring">}</span></code></pre></pre>
<p>r[expr.struct.brace-restricted-positions] Struct expressions can’t be used directly in a <a href="expressions/loop-expr.html">loop</a> or <a href="expressions/if-expr.html#if-expressions">if</a> expression’s head, or in the <a href="expressions/../glossary.html#scrutinee">scrutinee</a> of an <a href="expressions/if-expr.html#if-let-patterns">if let</a> or <a href="expressions/match-expr.html">match</a> expression. However, struct expressions can be used in these situations if they are within another expression, for example inside <a href="expressions/grouped-expr.html">parentheses</a>.</p>
<p>r[expr.struct.tuple-field] The field names can be decimal integer values to specify indices for constructing tuple structs. This can be used with base structs to fill out the remaining indices not specified:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Color(u8, u8, u8);
let c1 = Color(0, 0, 0);  // 튜플 구조체를 생성하는 전형적인 방법.
let c2 = Color{0: 255, 1: 127, 2: 0};  // 인덱스로 필드 지정.
let c3 = Color{1: 0, ..c2};  // 기본 구조체를 사용하여 다른 모든 필드를 채웁니다.
<span class="boring">}</span></code></pre></pre>
<p>r[expr.struct.field.named]</p>
<h3 id="구조체-필드-초기화-단축형"><a class="header" href="#구조체-필드-초기화-단축형">구조체 필드 초기화 단축형</a></h3>
<p>명명된(번호가 매겨지지 않은) 필드가 있는 데이터 구조(구조체, 열거형, 공용체)를 초기화할 때, <code>fieldname: fieldname</code>의 약어로 <code>fieldname</code>을 작성할 수 있습니다. 이를 통해 중복이 적은 간결한 구문을 사용할 수 있습니다. 예를 들면:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Point3d { x: i32, y: i32, z: i32 }
</span><span class="boring">let x = 0;
</span><span class="boring">let y_value = 0;
</span><span class="boring">let z = 0;
</span>Point3d { x: x, y: y_value, z: z };
Point3d { x, y: y_value, z };
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p>r[expr.call]</p>
<h1 id="호출-표현식"><a class="header" href="#호출-표현식">호출 표현식</a></h1>
<p>r[expr.call.syntax]</p>
<pre><code class="language-grammar expressions">CallExpression -&gt; Expression `(` CallParams? `)`

CallParams -&gt; Expression ( `,` Expression )* `,`?
</code></pre>
<p>r[expr.call.intro] A <em>call expression</em> calls a function. The syntax of a call expression is an expression, called the <em>function operand</em>, followed by a parenthesized comma-separated list of expression, called the <em>argument operands</em>.</p>
<p>r[expr.call.convergence] If the function eventually returns, then the expression completes.</p>
<p>r[expr.call.trait] For <a href="expressions/../types/function-item.html">non-function types</a>, the expression <code>f(...)</code> uses the method on one of the following traits based on the function operand:</p>
<ul>
<li>[<code>Fn</code>] or [<code>AsyncFn</code>] — shared reference.</li>
<li>[<code>FnMut</code>] or [<code>AsyncFnMut</code>] — mutable reference.</li>
<li>[<code>FnOnce</code>] or [<code>AsyncFnOnce</code>] — value.</li>
</ul>
<p>r[expr.call.autoref-deref] An automatic borrow will be taken if needed. The function operand will also be <a href="expressions/field-expr.html#automatic-dereferencing">automatically dereferenced</a> as required.</p>
<p>호출 표현식의 몇 가지 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn add(x: i32, y: i32) -&gt; i32 { 0 }
</span>let three: i32 = add(1i32, 2i32);
let name: &amp;'static str = (|| "Rust")();
<span class="boring">}</span></code></pre></pre>
<p>r[expr.call.desugar]</p>
<h2 id="disambiguating-function-calls"><a class="header" href="#disambiguating-function-calls">Disambiguating function calls</a></h2>
<p>r[expr.call.desugar.fully-qualified] All function calls are sugar for a more explicit <a href="expressions/../paths.html#qualified-paths">fully-qualified syntax</a>.</p>
<p>r[expr.call.desugar.ambiguity] Function calls may need to be fully qualified, depending on the ambiguity of a call in light of in-scope items.</p>
<blockquote>
<p>[!NOTE] In the past, the terms “Unambiguous Function Call Syntax”, “Universal Function Call Syntax”, or “UFCS”, have been used in documentation, issues, RFCs, and other community writings. However, these terms lack descriptive power and potentially confuse the issue at hand. We mention them here for searchability’s sake.</p>
</blockquote>
<p>r[expr.call.desugar.limits] Several situations often occur which result in ambiguities about the receiver or referent of method or associated function calls. These situations may include:</p>
<ul>
<li>여러 스코프 내 트레잇이 동일한 타입에 대해 동일한 이름의 메서드를 정의하는 경우</li>
<li>자동 <code>deref</code>가 바람직하지 않은 경우; 예를 들어, 스마트 포인터 자체의 메서드와 포인터가 참조하는 대상의 메서드를 구별하는 경우</li>
<li>Methods which take no arguments, like <a href="std::default::Default::default"><code>default()</code></a>, and return properties of a type, like <a href="std::mem::size_of"><code>size_of()</code></a></li>
</ul>
<p>r[expr.call.desugar.explicit-path] To resolve the ambiguity, the programmer may refer to their desired method or function using more specific paths, types, or traits.</p>
<p>예를 들어,</p>
<pre><pre class="playground"><code class="language-rust edition2024">trait Pretty {
    fn print(&amp;self);
}

trait Ugly {
    fn print(&amp;self);
}

struct Foo;
impl Pretty for Foo {
    fn print(&amp;self) {}
}

struct Bar;
impl Pretty for Bar {
    fn print(&amp;self) {}
}
impl Ugly for Bar {
    fn print(&amp;self) {}
}

fn main() {
    let f = Foo;
    let b = Bar;

    // `Foo`에 대해 `print`라고 불리는 아이템이 하나만 있기 때문에 이렇게 할 수 있습니다
    f.print();
    // 더 명시적이며, `Foo`의 경우 필요하지 않습니다
    Foo::print(&amp;f);
    // 간결함을 선호하지 않는다면
    &lt;Foo as Pretty&gt;::print(&amp;f);

    // b.print(); // 오류: 여러 개의 'print' 발견됨
    // Bar::print(&amp;b); // 여전히 오류: 여러 개의 `print` 발견됨

    // `print`를 정의하는 스코프 내 아이템 때문에 필요함
    &lt;Bar as Pretty&gt;::print(&amp;b);
}</code></pre></pre>
<p>자세한 내용과 동기는 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0132-ufcs.md">RFC 132</a>를 참조하십시오.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[expr.method]</p>
<h1 id="메서드-호출-표현식"><a class="header" href="#메서드-호출-표현식">메서드 호출 표현식</a></h1>
<p>r[expr.method.syntax]</p>
<pre><code class="language-grammar expressions">MethodCallExpression -&gt; Expression `.` PathExprSegment `(`CallParams? `)`
</code></pre>
<p>r[expr.method.intro] A <em>method call</em> consists of an expression (the <em>receiver</em>) followed by a single dot, an expression path segment, and a parenthesized expression-list.</p>
<p>r[expr.method.target] Method calls are resolved to associated <a href="expressions/../items/associated-items.html#methods">methods</a> on specific traits, either statically dispatching to a method if the exact <code>self</code>-type of the left-hand-side is known, or dynamically dispatching if the left-hand-side expression is an indirect <a href="expressions/../types/trait-object.html">trait object</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pi: Result&lt;f32, _&gt; = "3.14".parse();
let log_pi = pi.unwrap_or(1.0).log(2.72);
<span class="boring">assert!(1.14 &lt; log_pi &amp;&amp; log_pi &lt; 1.15)
</span><span class="boring">}</span></code></pre></pre>
<p>r[expr.method.autoref-deref] When looking up a method call, the receiver may be automatically dereferenced or borrowed in order to call a method. This requires a more complex lookup process than for other functions, since there may be a number of possible methods to call. The following procedure is used:</p>
<p>r[expr.method.candidate-receivers] The first step is to build a list of candidate receiver types. Obtain these by repeatedly <a href="expressions/operator-expr.html#the-dereference-operator">dereferencing</a> the receiver expression’s type, adding each type encountered to the list, then finally attempting an <a href="expressions/../type-coercions.html#unsized-coercions">unsized coercion</a> at the end, and adding the result type if that is successful.</p>
<p>r[expr.method.candidate-receivers-refs] Then, for each candidate <code>T</code>, add <code>&amp;T</code> and <code>&amp;mut T</code> to the list immediately after <code>T</code>.</p>
<p>예를 들어, 수신자의 타입이 <code>Box&lt;[i32;2]&gt;</code>인 경우 후보 타입은 <code>Box&lt;[i32;2]&gt;</code>, <code>&amp;Box&lt;[i32;2]&gt;</code>, <code>&amp;mut Box&lt;[i32;2]&gt;</code>, <code>[i32; 2]</code> (역참조에 의해), <code>&amp;[i32; 2]</code>, <code>&amp;mut [i32; 2]</code>, <code>[i32]</code> (크기 없는 강제 변환에 의해), <code>&amp;[i32]</code>, 마지막으로 <code>&amp;mut [i32]</code>가 됩니다.</p>
<p>r[expr.method.candidate-search] Then, for each candidate type <code>T</code>, search for a <a href="expressions/../visibility-and-privacy.html">visible</a> method with a receiver of that type in the following places:</p>
<ol>
<li><code>T</code>의 고유 메서드 (<code>T</code>에 직접 구현된 메서드).</li>
<li><code>T</code>에 의해 구현된 <a href="expressions/../visibility-and-privacy.html">보이는</a> 트레잇이 제공하는 메서드 중 하나. <code>T</code>가 타입 매개변수인 경우 <code>T</code>의 트레잇 바운드가 제공하는 메서드가 먼저 조회됩니다. 그런 다음 스코프에 있는 나머지 모든 메서드가 조회됩니다.</li>
</ol>
<blockquote>
<p>[!NOTE] The lookup is done for each type in order, which can occasionally lead to surprising results. The below code will print “In trait impl!”, because <code>&amp;self</code> methods are looked up first, the trait method is found before the struct’s <code>&amp;mut self</code> method is found.</p>
<pre><pre class="playground"><code class="language-rust edition2024">struct Foo {}

trait Bar {
  fn bar(&amp;self);
}

impl Foo {
  fn bar(&amp;mut self) {
    println!("In struct impl!")
  }
}

impl Bar for Foo {
  fn bar(&amp;self) {
    println!("In trait impl!")
  }
}

fn main() {
  let mut f = Foo{};
  f.bar();
}</code></pre></pre>
</blockquote>
<p>r[expr.method.ambiguous-target] If this results in multiple possible candidates, then it is an error, and the receiver must be <a href="expressions/call-expr.html#disambiguating-function-calls">converted</a> to an appropriate receiver type to make the method call.</p>
<p>r[expr.method.receiver-constraints] This process does not take into account the mutability or lifetime of the receiver, or whether a method is <code>unsafe</code>. Once a method is looked up, if it can’t be called for one (or more) of those reasons, the result is a compiler error.</p>
<p>r[expr.method.ambiguous-search] If a step is reached where there is more than one possible method, such as where generic methods or traits are considered the same, then it is a compiler error. These cases require a <a href="expressions/call-expr.html#disambiguating-function-calls">disambiguating function call syntax</a> for method and function invocation.</p>
<p>r[expr.method.edition2021]</p>
<blockquote>
<p>[!EDITION-2021] Before the 2021 edition, during the search for visible methods, if the candidate receiver type is an <a href="expressions/../types/array.html">array type</a>, methods provided by the standard library <a href="std::iter::IntoIterator"><code>IntoIterator</code></a> trait are ignored.</p>
<p>이 목적에 사용되는 에디션은 메서드 이름을 나타내는 토큰에 의해 결정됩니다.</p>
<p>이 특별한 경우는 나중에 제거될 수 있습니다.</p>
</blockquote>
<blockquote>
<p>[!WARNING] For <a href="expressions/../types/trait-object.html">trait objects</a>, if there is an inherent method of the same name as a trait method, it will give a compiler error when trying to call the method in a method call expression. Instead, you can call the method using <a href="expressions/call-expr.html#disambiguating-function-calls">disambiguating function call syntax</a>, in which case it calls the trait method, not the inherent method. There is no way to call the inherent method. Just don’t define inherent methods on trait objects with the same name as a trait method and you’ll be fine.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>r[expr.field]</p>
<h1 id="필드-접근-표현식"><a class="header" href="#필드-접근-표현식">필드 접근 표현식</a></h1>
<p>r[expr.field.syntax]</p>
<pre><code class="language-grammar expressions">FieldExpression -&gt; Expression `.` IDENTIFIER
</code></pre>
<p>r[expr.field.intro] A <em>field expression</em> is a <a href="expressions/../expressions.html#place-expressions-and-value-expressions">place expression</a> that evaluates to the location of a field of a <a href="expressions/../items/structs.html">struct</a> or <a href="expressions/../items/unions.html">union</a>.</p>
<p>r[expr.field.mut] When the operand is <a href="expressions/../expressions.html#mutability">mutable</a>, the field expression is also mutable.</p>
<p>r[expr.field.form] The syntax for a field expression is an expression, called the <em>container operand</em>, then a <code>.</code>, and finally an <a href="expressions/../identifiers.html">identifier</a>.</p>
<p>r[expr.field.not-method-call] Field expressions cannot be followed by a parenthetical comma-separated list of expressions, as that is instead parsed as a <a href="expressions/method-call-expr.html">method call expression</a>. That is, they cannot be the function operand of a <a href="expressions/call-expr.html">call expression</a>.</p>
<blockquote>
<p>[!NOTE] Wrap the field expression in a <a href="expressions/grouped-expr.html">parenthesized expression</a> to use it in a call expression.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct HoldsCallable&lt;F: Fn()&gt; { callable: F }
</span>let holds_callable = HoldsCallable { callable: || () };

// 잘못됨: 메서드 "callable" 호출로 파싱됨
// holds_callable.callable();

// 유효함
(holds_callable.callable)();
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>예:</p>
<!-- ignore: needs lots of support code -->
<pre><code class="language-rust ignore">mystruct.myfield;
foo().x;
(Struct {a: 10, b: 20}).a;
(mystruct.function_field)() // 필드 표현식을 포함하는 호출 표현식</code></pre>
<p>r[expr.field.autoref-deref]</p>
<h2 id="자동-역참조"><a class="header" href="#자동-역참조">자동 역참조</a></h2>
<p>컨테이너 피연산자의 타입이 피연산자의 <a href="expressions/../expressions.html#mutability">가변성</a>에 따라 <a href="expressions/../special-types-and-traits.html#deref-and-derefmut"><code>Deref</code></a> 또는 <a href="expressions/../special-types-and-traits.html#deref-and-derefmut"><code>DerefMut</code></a>를 구현하는 경우, 필드 접근이 가능하도록 필요한 횟수만큼 _자동으로 역참조_됩니다. 이 과정을 줄여서 _자동 역참조(autoderef)_라고도 합니다.</p>
<p>r[expr.field.borrow]</p>
<h2 id="차용"><a class="header" href="#차용">차용</a></h2>
<p>The fields of a struct or a reference to a struct are treated as separate entities when borrowing. If the struct does not implement <a href="expressions/../special-types-and-traits.html#drop"><code>Drop</code></a> and is stored in a local variable, this also applies to moving out of each of its fields. This also does not apply if automatic dereferencing is done through user-defined types other than <a href="expressions/../special-types-and-traits.html#boxt"><code>Box</code></a>.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A { f1: String, f2: String, f3: String }
let mut x: A;
<span class="boring">x = A {
</span><span class="boring">    f1: "f1".to_string(),
</span><span class="boring">    f2: "f2".to_string(),
</span><span class="boring">    f3: "f3".to_string()
</span><span class="boring">};
</span>let a: &amp;mut String = &amp;mut x.f1; // x.f1 가변적으로 차용됨
let b: &amp;String = &amp;x.f2;         // x.f2 불변적으로 차용됨
let c: &amp;String = &amp;x.f2;         // 다시 차용 가능
let d: String = x.f3;           // x.f3에서 이동
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p>r[expr.closure]</p>
<h1 id="클로저-표현식"><a class="header" href="#클로저-표현식">클로저 표현식</a></h1>
<p>r[expr.closure.syntax]</p>
<pre><code class="language-grammar expressions">ClosureExpression -&gt;
    `async`?[^cl-async-edition]
    `move`?
    ( `||` | `|` ClosureParameters? `|` )
    (Expression | `-&gt;` TypeNoBounds BlockExpression)

ClosureParameters -&gt; ClosureParam (`,` ClosureParam)* `,`?

ClosureParam -&gt; OuterAttribute* PatternNoTopAlt ( `:` Type )?
</code></pre>
<div class="footnote-definition" id="cl-async-edition"><sup class="footnote-definition-label">1</sup>
<p><code>async</code> 한정자는 2015 에디션에서 허용되지 않습니다.</p>
</div>
<p>r[expr.closure.intro] A <em>closure expression</em>, also known as a lambda expression or a lambda, defines a <a href="expressions/../types/closure.html">closure type</a> and evaluates to a value of that type. The syntax for a closure expression is an optional <code>async</code> keyword, an optional <code>move</code> keyword, then a pipe-symbol-delimited (<code>|</code>) comma-separated list of <a href="expressions/../patterns.html">patterns</a>, called the <em>closure parameters</em> each optionally followed by a <code>:</code> and a type, then an optional <code>-&gt;</code> and type, called the <em>return type</em>, and then an expression, called the <em>closure body operand</em>.</p>
<p>r[expr.closure.param-type] The optional type after each pattern is a type annotation for the pattern.</p>
<p>r[expr.closure.explicit-type-body] If there is a return type, the closure body must be a <a href="expressions/block-expr.html">block</a>.</p>
<p>r[expr.closure.parameter-restriction] A closure expression denotes a function that maps a list of parameters onto the expression that follows the parameters. Just like a <a href="expressions/../statements.html#let-statements"><code>let</code> binding</a>, the closure parameters are irrefutable <a href="expressions/../patterns.html">patterns</a>, whose type annotation is optional and will be inferred from context if not given.</p>
<p>r[expr.closure.unique-type] Each closure expression has a unique, anonymous type.</p>
<p>r[expr.closure.captures] Significantly, closure expressions <em>capture their environment</em>, which regular <a href="expressions/../items/functions.html">function definitions</a> do not.</p>
<p>r[expr.closure.capture-inference] Without the <code>move</code> keyword, the closure expression <a href="expressions/../types/closure.html#capture-modes">infers how it captures each variable from its environment</a>, preferring to capture by shared reference, effectively borrowing all outer variables mentioned inside the closure’s body.</p>
<p>r[expr.closure.capture-mut-ref] If needed the compiler will infer that instead mutable references should be taken, or that the values should be moved or copied (depending on their type) from the environment.</p>
<p>r[expr.closure.capture-move] A closure can be forced to capture its environment by copying or moving values by prefixing it with the <code>move</code> keyword. This is often used to ensure that the closure’s lifetime is <code>'static</code>.</p>
<p>r[expr.closure.trait-impl]</p>
<h2 id="클로저-트레잇-구현"><a class="header" href="#클로저-트레잇-구현">클로저 트레잇 구현</a></h2>
<p>클로저 타입이 구현하는 트레잇은 변수가 캡처되는 방식, 캡처된 변수의 타입, 그리고 <code>async</code>의 존재 여부에 따라 달라집니다. 클로저가 <code>Fn</code>, <code>FnMut</code>, <code>FnOnce</code>를 어떻게 그리고 언제 구현하는지에 대해서는 <a href="expressions/../types/closure.html#call-traits-and-coercions">호출 트레잇 및 강제 변환</a> 장을 참조하십시오. 캡처된 모든 변수의 타입도 해당 트레잇을 구현하는 경우 클로저 타입은 <a href="expressions/../special-types-and-traits.html#send"><code>Send</code></a> 및 <a href="expressions/../special-types-and-traits.html#sync"><code>Sync</code></a>를 구현합니다.</p>
<p>r[expr.closure.async]</p>
<h2 id="비동기-클로저"><a class="header" href="#비동기-클로저">비동기 클로저</a></h2>
<p>r[expr.closure.async.intro] Closures marked with the <code>async</code> keyword indicate that they are asynchronous in an analogous way to an [async function][items.fn.async].</p>
<p>r[expr.closure.async.future] Calling the async closure does not perform any work, but instead evaluates to a value that implements [<code>Future</code>] that corresponds to the computation of the body of the closure.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn takes_async_callback(f: impl AsyncFn(u64)) {
    f(0).await;
    f(1).await;
}

async fn example() {
    takes_async_callback(async |i| {
        core::future::ready(i).await;
        println!("{i} 완료.");
    }).await;
}
<span class="boring">}</span></code></pre></pre>
<p>r[expr.closure.async.edition2018]</p>
<blockquote>
<p>[!EDITION-2018] Async closures are only available beginning with Rust 2018.</p>
</blockquote>
<h2 id="예시-3"><a class="header" href="#예시-3">예시</a></h2>
<p>이 예제에서는 고차 함수 인수를 받는 함수 <code>ten_times</code>를 정의한 다음, 이를 클로저 표현식을 인수로 호출하고, 그 뒤에 환경에서 값을 이동하는 클로저 표현식을 사용하여 호출합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn ten_times&lt;F&gt;(f: F) where F: Fn(i32) {
    for index in 0..10 {
        f(index);
    }
}

ten_times(|j| println!("안녕하세요, {}", j));
// 타입 주석 포함
ten_times(|j: i32| -&gt; () { println!("안녕하세요, {}", j) });

let word = "곤니찌와".to_owned();
ten_times(move |j| println!("{}, {}", word, j));
<span class="boring">}</span></code></pre></pre>
<h2 id="클로저-매개변수의-속성"><a class="header" href="#클로저-매개변수의-속성">클로저 매개변수의 속성</a></h2>
<p>r[expr.closure.param-attributes] Attributes on closure parameters follow the same rules and restrictions as <a href="expressions/../items/functions.html#attributes-on-function-parameters">regular function parameters</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[expr.loop]</p>
<h1 id="루프-및-기타-중단-가능한-표현식"><a class="header" href="#루프-및-기타-중단-가능한-표현식">루프 및 기타 중단 가능한 표현식</a></h1>
<p>r[expr.loop.syntax]</p>
<pre><code class="language-grammar expressions">LoopExpression -&gt;
    LoopLabel? (
        InfiniteLoopExpression
      | PredicateLoopExpression
      | IteratorLoopExpression
      | LabelBlockExpression
    )
</code></pre>
<p>r[expr.loop.intro] Rust supports four loop expressions:</p>
<ul>
<li><a href="expressions/loop-expr.html#infinite-loops"><code>loop</code> 표현식</a>은 무한 루프를 나타냅니다.</li>
<li><a href="expressions/loop-expr.html#predicate-loops"><code>while</code> 표현식</a>은 조건자가 거짓이 될 때까지 반복합니다.</li>
<li><a href="expressions/loop-expr.html#iterator-loops"><code>for</code> 표현식</a>은 반복자에서 값을 추출하여 반복자가 빌 때까지 반복합니다.</li>
<li>A [labeled block expression][expr.loop.block-labels] runs a loop exactly once, but allows exiting the loop early with <code>break</code>.</li>
</ul>
<p>r[expr.loop.break-label] All four types of loop support <a href="expressions/loop-expr.html#break-expressions"><code>break</code> expressions</a>, and <a href="expressions/loop-expr.html#loop-labels">labels</a>.</p>
<p>r[expr.loop.continue-label] All except labeled block expressions support <a href="expressions/loop-expr.html#continue-expressions"><code>continue</code> expressions</a>.</p>
<p>r[expr.loop.explicit-result] Only <code>loop</code> and labeled block expressions support <a href="expressions/loop-expr.html#break-and-loop-values">evaluation to non-trivial values</a>.</p>
<p>r[expr.loop.infinite]</p>
<h2 id="무한-루프"><a class="header" href="#무한-루프">무한 루프</a></h2>
<p>r[expr.loop.infinite.syntax]</p>
<pre><code class="language-grammar expressions">InfiniteLoopExpression -&gt; `loop` BlockExpression
</code></pre>
<p>r[expr.loop.infinite.intro] A <code>loop</code> expression repeats execution of its body continuously: <code>loop { println!("I live."); }</code>.</p>
<p>r[expr.loop.infinite.diverging] A <code>loop</code> expression without an associated <code>break</code> expression is diverging and has type <a href="expressions/../types/never.html"><code>!</code></a>.</p>
<p>r[expr.loop.infinite.break] A <code>loop</code> expression containing associated <a href="expressions/loop-expr.html#break-expressions"><code>break</code> expression(s)</a> may terminate, and must have type compatible with the value of the <code>break</code> expression(s).</p>
<p>r[expr.loop.while]</p>
<h2 id="조건자-루프"><a class="header" href="#조건자-루프">조건자 루프</a></h2>
<p>r[expr.loop.while.grammar]</p>
<pre><code class="language-grammar expressions">PredicateLoopExpression -&gt; `while` Conditions BlockExpression
</code></pre>
<p>r[expr.loop.while.intro] A <code>while</code> loop expression allows repeating the evaluation of a block while a set of conditions remain true.</p>
<p>r[expr.loop.while.syntax] The syntax of a <code>while</code> expression is a sequence of one or more condition operands separated by <code>&amp;&amp;</code>, followed by a [BlockExpression].</p>
<p>r[expr.loop.while.condition] Condition operands must be either an [Expression] with a <a href="expressions/../types/boolean.html">boolean type</a> or a conditional <code>let</code> match. If all of the condition operands evaluate to <code>true</code> and all of the <code>let</code> patterns successfully match their <a href="expressions/../glossary.html#scrutinee">scrutinee</a>s, then the loop body block executes.</p>
<p>r[expr.loop.while.repeat] After the loop body successfully executes, the condition operands are re-evaluated to determine if the body should be executed again.</p>
<p>r[expr.loop.while.exit] If any condition operand evaluates to <code>false</code> or any <code>let</code> pattern does not match its scrutinee, the body is not executed and execution continues after the <code>while</code> expression.</p>
<p>r[expr.loop.while.eval] A <code>while</code> expression evaluates to <code>()</code>.</p>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut i = 0;

while i &lt; 10 {
    println!("hello");
    i = i + 1;
}
<span class="boring">}</span></code></pre></pre>
<p>r[expr.loop.while.let]</p>
<h3 id="while-let-patterns"><a class="header" href="#while-let-patterns"><code>while let</code> patterns</a></h3>
<p>r[expr.loop.while.let.intro] <code>let</code> patterns in a <code>while</code> condition allow binding new variables into scope when the pattern matches successfully. The following examples illustrate bindings using <code>let</code> patterns:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = vec![1, 2, 3];

while let Some(y) = x.pop() {
    println!("y = {}", y);
}

while let _ = 5 {
    println!("반박할 수 없는 패턴은 항상 참입니다");
    break;
}
<span class="boring">}</span></code></pre></pre>
<p>r[expr.loop.while.let.desugar] A <code>while let</code> loop is equivalent to a <code>loop</code> expression containing a <a href="expressions/match-expr.html"><code>match</code> expression</a> as follows.</p>
<!-- ignore: expansion example -->
<pre><code class="language-rust ignore">'label: while let PATS = EXPR {
    /* 루프 본문 */
}</code></pre>
<p>다음과 동일합니다.</p>
<!-- ignore: expansion example -->
<pre><code class="language-rust ignore">'label: loop {
    match EXPR {
        PATS =&gt; { /* 루프 본문 */ },
        _ =&gt; break,
    }
}</code></pre>
<p>r[expr.loop.while.let.or-pattern] Multiple patterns may be specified with the <code>|</code> operator. This has the same semantics as with <code>|</code> in <code>match</code> expressions:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut vals = vec![2, 3, 1, 2, 2];
while let Some(v @ 1) | Some(v @ 2) = vals.pop() {
    // 2, 2, 그 다음 1을 출력합니다
    println!("{}", v);
}
<span class="boring">}</span></code></pre></pre>
<p>r[expr.loop.while.chains]</p>
<h3 id="while-condition-chains"><a class="header" href="#while-condition-chains"><code>while</code> condition chains</a></h3>
<p>r[expr.loop.while.chains.intro] Multiple condition operands can be separated with <code>&amp;&amp;</code>. These have the same semantics and restrictions as <a href="expressions/if-expr.html#chains-of-conditions"><code>if</code> condition chains</a>.</p>
<p>The following is an example of chaining multiple expressions, mixing <code>let</code> bindings and boolean expressions, and with expressions able to reference pattern bindings from previous expressions:</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let outer_opt = Some(Some(1i32));

    while let Some(inner_opt) = outer_opt
        &amp;&amp; let Some(number) = inner_opt
        &amp;&amp; number == 1
    {
        println!("Peek a boo");
        break;
    }
}</code></pre></pre>
<p>r[expr.loop.for]</p>
<h2 id="반복자-루프"><a class="header" href="#반복자-루프">반복자 루프</a></h2>
<p>r[expr.loop.for.syntax]</p>
<pre><code class="language-grammar expressions">IteratorLoopExpression -&gt;
    `for` Pattern `in` Expression _except [StructExpression]_ BlockExpression
</code></pre>
<!-- TODO: The exception above isn't accurate, see https://github.com/rust-lang/reference/issues/569 -->
<p>r[expr.loop.for.intro] A <code>for</code> expression is a syntactic construct for looping over elements provided by an implementation of <code>std::iter::IntoIterator</code>.</p>
<p>r[expr.loop.for.condition] If the iterator yields a value, that value is matched against the irrefutable pattern, the body of the loop is executed, and then control returns to the head of the <code>for</code> loop. If the iterator is empty, the <code>for</code> expression completes.</p>
<p>배열의 내용에 대한 <code>for</code> 루프의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = &amp;["사과", "케이크", "커피"];

for text in v {
    println!("저는 {}를 좋아합니다.", text);
}
<span class="boring">}</span></code></pre></pre>
<p>일련의 정수에 대한 for 루프의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut sum = 0;
for n in 1..11 {
    sum += n;
}
assert_eq!(sum, 55);
<span class="boring">}</span></code></pre></pre>
<p>r[expr.loop.for.desugar] A <code>for</code> loop is equivalent to a <code>loop</code> expression containing a <a href="expressions/match-expr.html"><code>match</code> expression</a> as follows:</p>
<!-- ignore: expansion example -->
<pre><code class="language-rust ignore">'label: for PATTERN in iter_expr {
    /* 루프 본문 */
}</code></pre>
<p>다음과 동일합니다.</p>
<!-- ignore: expansion example -->
<pre><code class="language-rust ignore">{
    let result = match IntoIterator::into_iter(iter_expr) {
        mut iter =&gt; 'label: loop {
            let mut next;
            match Iterator::next(&amp;mut iter) {
                Option::Some(val) =&gt; next = val,
                Option::None =&gt; break,
            };
            let PATTERN = next;
            let () = { /* 루프 본문 */ };
        },
    };
    result
}</code></pre>
<p>r[expr.loop.for.lang-items] <code>IntoIterator</code>, <code>Iterator</code>, and <code>Option</code> are always the standard library items here, not whatever those names resolve to in the current scope.</p>
<p>변수 이름 <code>next</code>, <code>iter</code>, <code>val</code>은 설명용일 뿐이며, 실제로 사용자가 입력할 수 있는 이름은 아닙니다.</p>
<blockquote>
<p>[!NOTE] The outer <code>match</code> is used to ensure that any <a href="expressions/../expressions.html#temporaries">temporary values</a> in <code>iter_expr</code> don’t get dropped before the loop is finished. <code>next</code> is declared before being assigned because it results in types being inferred correctly more often.</p>
</blockquote>
<p>r[expr.loop.label]</p>
<h2 id="루프-레이블"><a class="header" href="#루프-레이블">루프 레이블</a></h2>
<p>r[expr.loop.label.syntax]</p>
<pre><code class="language-grammar expressions">LoopLabel -&gt; LIFETIME_OR_LABEL `:`
</code></pre>
<p>r[expr.loop.label.intro] A loop expression may optionally have a <em>label</em>. The label is written as a lifetime preceding the loop expression, as in <code>'foo: loop { break 'foo; }</code>, <code>'bar: while false {}</code>, <code>'humbug: for _ in 0..0 {}</code>.</p>
<p>r[expr.loop.label.control-flow] If a label is present, then labeled <code>break</code> and <code>continue</code> expressions nested within this loop may exit out of this loop or return control to its head. See <a href="expressions/loop-expr.html#break-expressions">break expressions</a> and <a href="expressions/loop-expr.html#continue-expressions">continue expressions</a>.</p>
<p>r[expr.loop.label.ref] Labels follow the hygiene and shadowing rules of local variables. For example, this code will print “outer loop”:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>'a: loop {
    'a: loop {
        break 'a;
    }
    print!("outer loop");
    break 'a;
}
<span class="boring">}</span></code></pre></pre>
<p><code>'_</code>는 유효한 루프 레이블이 아닙니다.</p>
<p>r[expr.loop.break]</p>
<h2 id="break-표현식"><a class="header" href="#break-표현식"><code>break</code> 표현식</a></h2>
<p>r[expr.loop.break.syntax]</p>
<pre><code class="language-grammar expressions">BreakExpression -&gt; `break` LIFETIME_OR_LABEL? Expression?
</code></pre>
<p>r[expr.loop.break.intro] When <code>break</code> is encountered, execution of the associated loop body is immediately terminated, for example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut last = 0;
for x in 1..100 {
    if x &gt; 12 {
        break;
    }
    last = x;
}
assert_eq!(last, 12);
<span class="boring">}</span></code></pre></pre>
<p>r[expr.loop.break.label] A <code>break</code> expression is normally associated with the innermost <code>loop</code>, <code>for</code> or <code>while</code> loop enclosing the <code>break</code> expression, but a <a href="expressions/loop-expr.html#loop-labels">label</a> can be used to specify which enclosing loop is affected. Example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>'outer: loop {
    while true {
        break 'outer;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>r[expr.loop.break.value] A <code>break</code> expression is only permitted in the body of a loop, and has one of the forms <code>break</code>, <code>break 'label</code> or (<a href="expressions/loop-expr.html#break-and-loop-values">see below</a>) <code>break EXPR</code> or <code>break 'label EXPR</code>.</p>
<p>r[expr.loop.block-labels]</p>
<h2 id="labeled-block-expressions-1"><a class="header" href="#labeled-block-expressions-1">Labeled block expressions</a></h2>
<p>r[expr.loop.block-labels.syntax]</p>
<pre><code class="language-grammar expressions">LabelBlockExpression -&gt; BlockExpression
</code></pre>
<p>r[expr.loop.block-labels.intro] Labeled block expressions are exactly like block expressions, except that they allow using <code>break</code> expressions within the block.</p>
<p>r[expr.loop.block-labels.break] Unlike loops, <code>break</code> expressions within a labeled block expression <em>must</em> have a label (i.e. the label is not optional).</p>
<p>r[expr.loop.block-labels.label-required] Similarly, labeled block expressions <em>must</em> begin with a label.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn do_thing() {}
</span><span class="boring">fn condition_not_met() -&gt; bool { true }
</span><span class="boring">fn do_next_thing() {}
</span><span class="boring">fn do_last_thing() {}
</span>let result = 'block: {
    do_thing();
    if condition_not_met() {
        break 'block 1;
    }
    do_next_thing();
    if condition_not_met() {
        break 'block 2;
    }
    do_last_thing();
    3
};
<span class="boring">}</span></code></pre></pre>
<p>r[expr.loop.continue]</p>
<h2 id="continue-표현식"><a class="header" href="#continue-표현식"><code>continue</code> 표현식</a></h2>
<p>r[expr.loop.continue.syntax]</p>
<pre><code class="language-grammar expressions">ContinueExpression -&gt; `continue` LIFETIME_OR_LABEL?
</code></pre>
<p>r[expr.loop.continue.intro] When <code>continue</code> is encountered, the current iteration of the associated loop body is immediately terminated, returning control to the loop <em>head</em>.</p>
<p>r[expr.loop.continue.while] In the case of a <code>while</code> loop, the head is the conditional operands controlling the loop.</p>
<p>r[expr.loop.continue.for] In the case of a <code>for</code> loop, the head is the call-expression controlling the loop.</p>
<p>r[expr.loop.continue.label] Like <code>break</code>, <code>continue</code> is normally associated with the innermost enclosing loop, but <code>continue 'label</code> may be used to specify the loop affected.</p>
<p>r[expr.loop.continue.in-loop-only] A <code>continue</code> expression is only permitted in the body of a loop.</p>
<p>r[expr.loop.break-value]</p>
<h2 id="break와-루프-값"><a class="header" href="#break와-루프-값"><code>break</code>와 루프 값</a></h2>
<p>r[expr.loop.break-value.intro] When associated with a <code>loop</code>, a break expression may be used to return a value from that loop, via one of the forms <code>break EXPR</code> or <code>break 'label EXPR</code>, where <code>EXPR</code> is an expression whose result is returned from the <code>loop</code>. For example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (mut a, mut b) = (1, 1);
let result = loop {
    if b &gt; 10 {
        break b;
    }
    let c = a + b;
    a = b;
    b = c;
};
// 피보나치 수열에서 10을 넘는 첫 번째 수:
assert_eq!(result, 13);
<span class="boring">}</span></code></pre></pre>
<p>r[expr.loop.break-value.loop] In the case a <code>loop</code> has an associated <code>break</code>, it is not considered diverging, and the <code>loop</code> must have a type compatible with each <code>break</code> expression. <code>break</code> without an expression is considered identical to <code>break</code> with expression <code>()</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[expr.range]</p>
<h1 id="범위-표현식"><a class="header" href="#범위-표현식">범위 표현식</a></h1>
<p>r[expr.range.syntax]</p>
<pre><code class="language-grammar expressions">RangeExpression -&gt;
      RangeExpr
    | RangeFromExpr
    | RangeToExpr
    | RangeFullExpr
    | RangeInclusiveExpr
    | RangeToInclusiveExpr

RangeExpr -&gt; Expression `..` Expression

RangeFromExpr -&gt; Expression `..`

RangeToExpr -&gt; `..` Expression

RangeFullExpr -&gt; `..`

RangeInclusiveExpr -&gt; Expression `..=` Expression

RangeToInclusiveExpr -&gt; `..=` Expression
</code></pre>
<p>r[expr.range.behavior] The <code>..</code> and <code>..=</code> operators will construct an object of one of the <code>std::ops::Range</code> (or <code>core::ops::Range</code>) variants, according to the following table:</p>
<div class="table-wrapper"><table><thead><tr><th>생성</th><th>구문</th><th>유형</th><th>범위</th></tr></thead><tbody>
<tr><td>[RangeExpr]</td><td>start<code>..</code>end</td><td>[std::ops::Range]</td><td>start ≤ x &lt; end</td></tr>
<tr><td>[RangeFromExpr]</td><td>start<code>..</code></td><td>[std::ops::RangeFrom]</td><td>start ≤ x</td></tr>
<tr><td>[RangeToExpr]</td><td><code>..</code>end</td><td>[std::ops::RangeTo]</td><td>x &lt; end</td></tr>
<tr><td>[RangeFullExpr]</td><td><code>..</code></td><td>[std::ops::RangeFull]</td><td>-</td></tr>
<tr><td>[RangeInclusiveExpr]</td><td>start<code>..=</code>end</td><td>[std::ops::RangeInclusive]</td><td>start ≤ x ≤ end</td></tr>
<tr><td>[RangeToInclusiveExpr]</td><td><code>..=</code>end</td><td>[std::ops::RangeToInclusive]</td><td>x ≤ end</td></tr>
</tbody></table>
</div>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>1..2;   // std::ops::Range
3..;    // std::ops::RangeFrom
..4;    // std::ops::RangeTo
..;     // std::ops::RangeFull
5..=6;  // std::ops::RangeInclusive
..=7;   // std::ops::RangeToInclusive
<span class="boring">}</span></code></pre></pre>
<p>r[expr.range.equivalence] The following expressions are equivalent.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = std::ops::Range {start: 0, end: 10};
let y = 0..10;

assert_eq!(x, y);
<span class="boring">}</span></code></pre></pre>
<p>r[expr.range.for] Ranges can be used in <code>for</code> loops:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for i in 1..11 {
    println!("{}", i);
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p>r[expr.if]</p>
<h1 id="if-표현식"><a class="header" href="#if-표현식"><code>if</code> 표현식</a></h1>
<p>r[expr.if.syntax]</p>
<pre><code class="language-grammar expressions">IfExpression -&gt;
    `if` Conditions BlockExpression
    (`else` ( BlockExpression | IfExpression ) )?

Conditions -&gt;
      Expression _except [StructExpression]_
    | LetChain

LetChain -&gt; LetChainCondition ( `&amp;&amp;` LetChainCondition )*

LetChainCondition -&gt;
      Expression _except [ExcludedConditions]_
    | OuterAttribute* `let` Pattern `=` Scrutinee _except [ExcludedConditions]_

@root ExcludedConditions -&gt;
      StructExpression
    | LazyBooleanExpression
    | RangeExpr
    | RangeFromExpr
    | RangeInclusiveExpr
    | AssignmentExpression
    | CompoundAssignmentExpression
</code></pre>
<!-- TODO: The struct exception above needs clarification, see https://github.com/rust-lang/reference/issues/1808
     The chain grammar could use some work, see https://github.com/rust-lang/reference/issues/1811
-->
<p>r[expr.if.intro] The syntax of an <code>if</code> expression is a sequence of one or more condition operands separated by <code>&amp;&amp;</code>, followed by a consequent block, any number of <code>else if</code> conditions and blocks, and an optional trailing <code>else</code> block.</p>
<p>r[expr.if.condition] Condition operands must be either an [Expression] with a <a href="expressions/../types/boolean.html">boolean type</a> or a conditional <code>let</code> match.</p>
<p>r[expr.if.condition-true] If all of the condition operands evaluate to <code>true</code> and all of the <code>let</code> patterns successfully match their <a href="expressions/../glossary.html#scrutinee">scrutinee</a>s, the consequent block is executed and any subsequent <code>else if</code> or <code>else</code> block is skipped.</p>
<p>r[expr.if.else-if] If any condition operand evaluates to <code>false</code> or any <code>let</code> pattern does not match its scrutinee, the consequent block is skipped and any subsequent <code>else if</code> condition is evaluated.</p>
<p>r[expr.if.else] If all <code>if</code> and <code>else if</code> conditions evaluate to <code>false</code> then any <code>else</code> block is executed.</p>
<p>r[expr.if.result] An <code>if</code> expression evaluates to the same value as the executed block, or <code>()</code> if no block is evaluated.</p>
<p>r[expr.if.type] An <code>if</code> expression must have the same type in all situations.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let x = 3;
</span>if x == 4 {
    println!("x는 4");
} else if x == 3 {
    println!("x는 3");
} else {
    println!("x는 다른 것");
}

// `if` can be used as an expression.
let y = if 12 * 15 &gt; 150 {
    "더 큼"
} else {
    "더 작음"
};
assert_eq!(y, "더 큼");
<span class="boring">}</span></code></pre></pre>
<p>r[expr.if.let]</p>
<h2 id="if-let-patterns"><a class="header" href="#if-let-patterns"><code>if let</code> patterns</a></h2>
<p>r[expr.if.let.intro] <code>let</code> patterns in an <code>if</code> condition allow binding new variables into scope when the pattern matches successfully.</p>
<p>The following examples illustrate bindings using <code>let</code> patterns:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let dish = ("햄", "달걀");

// This body will be skipped because the pattern is refuted.
if let ("베이컨", b) = dish {
    println!("베이컨은 {}와(과) 함께 제공됩니다", b);
} else {
    // 대신 이 블록이 평가됩니다.
    println!("베이컨은 제공되지 않습니다");
}

// This body will execute.
if let ("햄", b) = dish {
    println!("햄은 {}와(과) 함께 제공됩니다", b);
}

if let _ = 5 {
    println!("반박할 수 없는 패턴은 항상 참입니다");
}
<span class="boring">}</span></code></pre></pre>
<p>r[expr.if.let.or-pattern] Multiple patterns may be specified with the <code>|</code> operator. This has the same semantics as with <code>|</code> in <a href="expressions/match-expr.html"><code>match</code> expressions</a>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum E {
    X(u8),
    Y(u8),
    Z(u8),
}
let v = E::Y(12);
if let E::X(n) | E::Y(n) = v {
    assert_eq!(n, 12);
}
<span class="boring">}</span></code></pre></pre>
<p>r[expr.if.chains]</p>
<h2 id="chains-of-conditions"><a class="header" href="#chains-of-conditions">Chains of conditions</a></h2>
<p>r[expr.if.chains.intro] Multiple condition operands can be separated with <code>&amp;&amp;</code>.</p>
<p>r[expr.if.chains.order] Similar to a <code>&amp;&amp;</code> [LazyBooleanExpression], each operand is evaluated from left-to-right until an operand evaluates as <code>false</code> or a <code>let</code> match fails, in which case the subsequent operands are not evaluated.</p>
<p>r[expr.if.chains.bindings] The bindings of each pattern are put into scope to be available for the next condition operand and the consequent block.</p>
<p>The following is an example of chaining multiple expressions, mixing <code>let</code> bindings and boolean expressions, and with expressions able to reference pattern bindings from previous expressions:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn single() {
    let outer_opt = Some(Some(1i32));

    if let Some(inner_opt) = outer_opt
        &amp;&amp; let Some(number) = inner_opt
        &amp;&amp; number == 1
    {
        println!("Peek a boo");
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The above is equivalent to the following without using chains of conditions:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn nested() {
    let outer_opt = Some(Some(1i32));

    if let Some(inner_opt) = outer_opt {
        if let Some(number) = inner_opt {
            if number == 1 {
                println!("Peek a boo");
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>r[expr.if.chains.or] If any condition operand is a <code>let</code> pattern, then none of the condition operands can be a <code>||</code> [lazy boolean operator expression][expr.bool-logic] due to ambiguity and precedence with the <code>let</code> scrutinee. If a <code>||</code> expression is needed, then parentheses can be used. For example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let foo = Some(123);
</span><span class="boring">let condition1 = true;
</span><span class="boring">let condition2 = false;
</span>// Parentheses are required here.
if let Some(x) = foo &amp;&amp; (condition1 || condition2) { /*...*/ }
<span class="boring">}</span></code></pre></pre>
<p>r[expr.if.edition2024]</p>
<blockquote>
<p>[!EDITION-2024] Before the 2024 edition, let chains are not supported. That is, the [LetChain] grammar is not allowed in an <code>if</code> expression.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>r[expr.match]</p>
<h1 id="match-표현식"><a class="header" href="#match-표현식"><code>match</code> 표현식</a></h1>
<p>r[expr.match.syntax]</p>
<pre><code class="language-grammar expressions">MatchExpression -&gt;
    `match` Scrutinee `{`
        InnerAttribute*
        MatchArms?
    `}`

Scrutinee -&gt; Expression _except [StructExpression]_

MatchArms -&gt;
    ( MatchArm `=&gt;` ( ExpressionWithoutBlock `,` | ExpressionWithBlock `,`? ) )*
    MatchArm `=&gt;` Expression `,`?

MatchArm -&gt; OuterAttribute* Pattern MatchArmGuard?

MatchArmGuard -&gt; `if` Expression
</code></pre>
<!-- TODO: The exception above isn't accurate, see https://github.com/rust-lang/reference/issues/569 -->
<p>r[expr.match.intro] A <em><code>match</code> expression</em> branches on a pattern. The exact form of matching that occurs depends on the <a href="expressions/../patterns.html">pattern</a>.</p>
<p>r[expr.match.scrutinee] A <code>match</code> expression has a <em><a href="expressions/../glossary.html#scrutinee">scrutinee</a> expression</em>, which is the value to compare to the patterns.</p>
<p>r[expr.match.scrutinee-constraint] The scrutinee expression and the patterns must have the same type.</p>
<p>r[expr.match.scrutinee-behavior] A <code>match</code> behaves differently depending on whether or not the scrutinee expression is a <a href="expressions/../expressions.html#place-expressions-and-value-expressions">place expression or value expression</a>.</p>
<p>r[expr.match.scrutinee-value] If the scrutinee expression is a <a href="expressions/../expressions.html#place-expressions-and-value-expressions">value expression</a>, it is first evaluated into a temporary location, and the resulting value is sequentially compared to the patterns in the arms until a match is found. The first arm with a matching pattern is chosen as the branch target of the <code>match</code>, any variables bound by the pattern are assigned to local variables in the arm’s block, and control enters the block.</p>
<p>r[expr.match.scrutinee-place] When the scrutinee expression is a <a href="expressions/../expressions.html#place-expressions-and-value-expressions">place expression</a>, the match does not allocate a temporary location; however, a by-value binding may copy or move from the memory location. When possible, it is preferable to match on place expressions, as the lifetime of these matches inherits the lifetime of the place expression rather than being restricted to the inside of the match.</p>
<p><code>match</code> 표현식의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 1;

match x {
    1 =&gt; println!("하나"),
    2 =&gt; println!("둘"),
    3 =&gt; println!("셋"),
    4 =&gt; println!("넷"),
    5 =&gt; println!("다섯"),
    _ =&gt; println!("그 외의 것"),
}
<span class="boring">}</span></code></pre></pre>
<p>r[expr.match.pattern-vars] Variables bound within the pattern are scoped to the match guard and the arm’s expression.</p>
<p>r[expr.match.pattern-var-binding] The <a href="expressions/../patterns.html#binding-modes">binding mode</a> (move, copy, or reference) depends on the pattern.</p>
<p>r[expr.match.or-pattern] Multiple match patterns may be joined with the <code>|</code> operator. Each pattern will be tested in left-to-right sequence until a successful match is found.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 9;
let message = match x {
    0 | 1  =&gt; "많지 않음",
    2 ..= 9 =&gt; "약간",
    _      =&gt; "많음"
};

assert_eq!(message, "약간");

// 패턴 매칭 순서 예시.
struct S(i32, i32);

match S(1, 2) {
    S(z @ 1, _) | S(_, z @ 2) =&gt; assert_eq!(z, 1),
    _ =&gt; panic!(),
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] The <code>2..=9</code> is a <a href="expressions/../patterns.html#range-patterns">Range Pattern</a>, not a <a href="expressions/range-expr.html">Range Expression</a>. Thus, only those types of ranges supported by range patterns can be used in match arms.</p>
</blockquote>
<p>r[expr.match.or-patterns-restriction] Every binding in each <code>|</code> separated pattern must appear in all of the patterns in the arm.</p>
<p>r[expr.match.binding-restriction] Every binding of the same name must have the same type, and have the same binding mode.</p>
<p>r[expr.match.guard]</p>
<h2 id="매치-가드"><a class="header" href="#매치-가드">매치 가드</a></h2>
<p>r[expr.match.guard.intro] Match arms can accept <em>match guards</em> to further refine the criteria for matching a case.</p>
<p>r[expr.match.guard.type] Pattern guards appear after the pattern and consist of a <code>bool</code>-typed expression following the <code>if</code> keyword.</p>
<p>r[expr.match.guard.behavior] When the pattern matches successfully, the pattern guard expression is executed. If the expression evaluates to true, the pattern is successfully matched against.</p>
<p>r[expr.match.guard.next] Otherwise, the next pattern, including other matches with the <code>|</code> operator in the same arm, is tested.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let maybe_digit = Some(0);
</span><span class="boring">fn process_digit(i: i32) { }
</span><span class="boring">fn process_other(i: i32) { }
</span>let message = match maybe_digit {
    Some(x) if x &lt; 10 =&gt; process_digit(x),
    Some(x) =&gt; process_other(x),
    None =&gt; panic!(),
};
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] Multiple matches using the <code>|</code> operator can cause the pattern guard and the side effects it has to execute multiple times. For example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::cell::Cell;
</span>let i : Cell&lt;i32&gt; = Cell::new(0);
match 1 {
    1 | _ if { i.set(i.get() + 1); false } =&gt; {}
    _ =&gt; {}
}
assert_eq!(i.get(), 2);
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[expr.match.guard.bound-variables] A pattern guard may refer to the variables bound within the pattern they follow.</p>
<p>r[expr.match.guard.shared-ref] Before evaluating the guard, a shared reference is taken to the part of the scrutinee the variable matches on. While evaluating the guard, this shared reference is then used when accessing the variable.</p>
<p>r[expr.match.guard.value] Only when the guard evaluates to true is the value moved, or copied, from the scrutinee into the variable. This allows shared borrows to be used inside guards without moving out of the scrutinee in case guard fails to match.</p>
<p>r[expr.match.guard.no-mutation] Moreover, by holding a shared reference while evaluating the guard, mutation inside guards is also prevented.</p>
<p>r[expr.match.attributes]</p>
<h2 id="매치-분기의-속성"><a class="header" href="#매치-분기의-속성">매치 분기의 속성</a></h2>
<p>r[expr.match.attributes.outer] Outer attributes are allowed on match arms. The only attributes that have meaning on match arms are <a href="expressions/../conditional-compilation.html"><code>cfg</code></a> and the <a href="expressions/../attributes/diagnostics.html#lint-check-attributes">lint check attributes</a>.</p>
<p>r[expr.match.attributes.inner] <a href="expressions/../attributes.html">Inner attributes</a> are allowed directly after the opening brace of the match expression in the same expression contexts as <a href="expressions/block-expr.html#attributes-on-block-expressions">attributes on block expressions</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[expr.return]</p>
<h1 id="return-표현식"><a class="header" href="#return-표현식"><code>return</code> 표현식</a></h1>
<p>r[expr.return.syntax]</p>
<pre><code class="language-grammar expressions">ReturnExpression -&gt; `return` Expression?
</code></pre>
<p>r[expr.return.intro] Return expressions are denoted with the keyword <code>return</code>.</p>
<p>r[expr.return.behavior] Evaluating a <code>return</code> expression moves its argument into the designated output location for the current function call, destroys the current function activation frame, and transfers control to the caller frame.</p>
<p><code>return</code> 표현식의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn max(a: i32, b: i32) -&gt; i32 {
    if a &gt; b {
        return a;
    }
    return b;
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p>r[expr.await]</p>
<h1 id="await-표현식"><a class="header" href="#await-표현식">await 표현식</a></h1>
<p>r[expr.await.syntax]</p>
<pre><code class="language-grammar expressions">AwaitExpression -&gt; Expression `.` `await`
</code></pre>
<p>r[expr.await.intro] An <code>await</code> expression is a syntactic construct for suspending a computation provided by an implementation of <code>std::future::IntoFuture</code> until the given future is ready to produce a value.</p>
<p>r[expr.await.construct] The syntax for an await expression is an expression with a type that implements the <a href="std::future::IntoFuture"><code>IntoFuture</code></a> trait, called the <em>future operand</em>, then the token <code>.</code>, and then the <code>await</code> keyword.</p>
<p>r[expr.await.allowed-positions] Await expressions are legal only within an <a href="expressions/../expressions/block-expr.html#async-context">async context</a>, like an <a href="expressions/../items/functions.html#async-functions"><code>async fn</code></a>, <a href="expressions/closure-expr.html#async-closures"><code>async</code> closure</a>, or <a href="expressions/block-expr.html#async-blocks"><code>async</code> block</a>.</p>
<p>r[expr.await.effects] More specifically, an await expression has the following effect.</p>
<ol>
<li>Create a future by calling <a href="std::future::IntoFuture::into_future"><code>IntoFuture::into_future</code></a> on the future operand.</li>
<li>Evaluate the future to a <a href="std::future::Future">future</a> <code>tmp</code>;</li>
<li>Pin <code>tmp</code> using <a href="std::pin::Pin::new_unchecked"><code>Pin::new_unchecked</code></a>;</li>
<li>This pinned future is then polled by calling the <a href="std::future::Future::poll"><code>Future::poll</code></a> method and passing it the current <a href="expressions/await-expr.html#task-context">task context</a>;</li>
<li>If the call to <code>poll</code> returns <a href="std::task::Poll::Pending"><code>Poll::Pending</code></a>, then the future returns <code>Poll::Pending</code>, suspending its state so that, when the surrounding async context is re-polled, execution returns to step 3;</li>
<li>Otherwise the call to <code>poll</code> must have returned <a href="std::task::Poll::Ready"><code>Poll::Ready</code></a>, in which case the value contained in the <a href="std::task::Poll::Ready"><code>Poll::Ready</code></a> variant is used as the result of the <code>await</code> expression itself.</li>
</ol>
<p>r[expr.await.edition2018]</p>
<blockquote>
<p>[!EDITION-2018] Await expressions are only available beginning with Rust 2018.</p>
</blockquote>
<p>r[expr.await.task]</p>
<h2 id="태스크-컨텍스트"><a class="header" href="#태스크-컨텍스트">태스크 컨텍스트</a></h2>
<p>The task context refers to the <a href="std::task::Context"><code>Context</code></a> which was supplied to the current <a href="expressions/../expressions/block-expr.html#async-context">async context</a> when the async context itself was polled. Because <code>await</code> expressions are only legal in an async context, there must be some task context available.</p>
<p>r[expr.await.desugar]</p>
<h2 id="대략적인-탈설탕"><a class="header" href="#대략적인-탈설탕">대략적인 탈설탕</a></h2>
<p>사실상, await 표현식은 다음의 비규범적 탈설탕과 대략적으로 동일합니다:</p>
<!-- ignore: example expansion -->
<pre><code class="language-rust ignore">match operand.into_future() {
    mut pinned =&gt; loop {
        let mut pin = unsafe { Pin::new_unchecked(&amp;mut pinned) };
        match Pin::future::poll(Pin::borrow(&amp;mut pin), &amp;mut current_context) {
            Poll::Ready(r) =&gt; break r,
            Poll::Pending =&gt; yield Poll::Pending,
        }
    }
}</code></pre>
<p>여기서 <code>yield</code> 의사 코드는 <code>Poll::Pending</code>을 반환하고, 다시 호출될 때 해당 지점에서 실행을 재개합니다. 변수 <code>current_context</code>는 비동기 환경에서 가져온 컨텍스트를 나타냅니다.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[expr.placeholder]</p>
<h1 id="_-표현식"><a class="header" href="#_-표현식"><code>_</code> 표현식</a></h1>
<p>r[expr.placeholder.syntax]</p>
<pre><code class="language-grammar expressions">UnderscoreExpression -&gt; `_`
</code></pre>
<p>r[expr.placeholder.intro] Underscore expressions, denoted with the symbol <code>_</code>, are used to signify a placeholder in a destructuring assignment.</p>
<p>r[expr.placeholder.lhs-assignment-only] They may only appear in the left-hand side of an assignment.</p>
<p>r[expr.placeholder.pattern] Note that this is distinct from the <a href="expressions/../patterns.html#wildcard-pattern">wildcard pattern</a>.</p>
<p><code>_</code> 표현식의 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let p = (1, 2);
let mut a = 0;
(_, a) = p;

struct Position {
    x: u32,
    y: u32,
}

Position { x: a, y: _ } = Position{ x: 2, y: 3 };

// 사용되지 않는 결과, 의도를 선언하고 경고를 제거하기 위해 `_`에 할당함
_ = 2 + 2;
// unused_must_use 경고 발생
// 2 + 2;

// let 바인딩에서 와일드카드 패턴을 사용하는 동일한 기법
let _ = 2 + 2;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p>r[patterns]</p>
<h1 id="패턴"><a class="header" href="#패턴">패턴</a></h1>
<p>r[patterns.syntax]</p>
<pre><code class="language-grammar patterns">Pattern -&gt; `|`? PatternNoTopAlt  ( `|` PatternNoTopAlt )*

PatternNoTopAlt -&gt;
      PatternWithoutRange
    | RangePattern

PatternWithoutRange -&gt;
      LiteralPattern
    | IdentifierPattern
    | WildcardPattern
    | RestPattern
    | ReferencePattern
    | StructPattern
    | TupleStructPattern
    | TuplePattern
    | GroupedPattern
    | SlicePattern
    | PathPattern
    | MacroInvocation
</code></pre>
<p>r[patterns.intro] Patterns are used to match values against structures and to, optionally, bind variables to values inside these structures. They are also used in variable declarations and parameters for functions and closures.</p>
<p>다음 예제의 패턴은 네 가지 작업을 수행합니다:</p>
<ul>
<li><code>person</code>의 <code>car</code> 필드가 무언가로 채워져 있는지 테스트합니다.</li>
<li>사람의 <code>age</code> 필드가 13에서 19 사이인지 테스트하고, 그 값을 <code>person_age</code> 변수에 바인딩합니다.</li>
<li><code>name</code> 필드에 대한 참조를 <code>person_name</code> 변수에 바인딩합니다.</li>
<li><code>person</code>의 나머지 필드를 무시합니다. 나머지 필드는 어떤 값이든 가질 수 있으며 어떤 변수에도 바인딩되지 않습니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Car;
</span><span class="boring">struct Computer;
</span><span class="boring">struct Person {
</span><span class="boring">    name: String,
</span><span class="boring">    car: Option&lt;Car&gt;,
</span><span class="boring">    computer: Option&lt;Computer&gt;,
</span><span class="boring">    age: u8,
</span><span class="boring">}
</span><span class="boring">let person = Person {
</span><span class="boring">    name: String::from("John"),
</span><span class="boring">    car: Some(Car),
</span><span class="boring">    computer: None,
</span><span class="boring">    age: 15,
</span><span class="boring">};
</span>if let
    Person {
        car: Some(_),
        age: person_age @ 13..=19,
        name: ref person_name,
        ..
    } = person
{
    println!("{}는 차가 있고 {}살입니다.", person_name, person_age);
}
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.usage] Patterns are used in:</p>
<p>r[patterns.let]</p>
<ul>
<li><a href="statements.html#let-statements"><code>let</code> 선언</a></li>
</ul>
<p>r[patterns.param]</p>
<ul>
<li><a href="items/functions.html">함수</a> 및 <a href="expressions/closure-expr.html">클로저</a> 매개변수</li>
</ul>
<p>r[patterns.match]</p>
<ul>
<li><a href="expressions/match-expr.html"><code>match</code> 표현식</a></li>
</ul>
<p>r[patterns.if-let]</p>
<ul>
<li><a href="expressions/if-expr.html"><code>if let</code> 표현식</a></li>
</ul>
<p>r[patterns.while-let]</p>
<ul>
<li><a href="expressions/loop-expr.html#while-let-patterns"><code>while let</code> expressions</a></li>
</ul>
<p>r[patterns.for]</p>
<ul>
<li><a href="expressions/loop-expr.html#iterator-loops"><code>for</code> 표현식</a></li>
</ul>
<p>r[patterns.destructure]</p>
<h2 id="구조-분해"><a class="header" href="#구조-분해">구조 분해</a></h2>
<p>r[patterns.destructure.intro] Patterns can be used to <em>destructure</em> <a href="items/structs.html">structs</a>, <a href="items/enumerations.html">enums</a>, and <a href="types/tuple.html">tuples</a>. Destructuring breaks up a value into its component pieces. The syntax used is almost the same as when creating such values.</p>
<p>r[patterns.destructure.wildcard] In a pattern whose <a href="glossary.html#scrutinee">scrutinee</a> expression has a <code>struct</code>, <code>enum</code> or <code>tuple</code> type, a <a href="patterns.html#wildcard-pattern">wildcard pattern</a> (<code>_</code>) stands in for a <em>single</em> data field, whereas an <a href="patterns.html#grammar-StructPatternEtCetera">et cetera</a> or [rest pattern][patterns.rest] (<code>..</code>) stands in for <em>all</em> the remaining fields of a particular variant.</p>
<p>r[patterns.destructure.named-field-shorthand] When destructuring a data structure with named (but not numbered) fields, it is allowed to write <code>fieldname</code> as a shorthand for <code>fieldname: fieldname</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">enum Message {
</span><span class="boring">    Quit,
</span><span class="boring">    WriteString(String),
</span><span class="boring">    Move { x: i32, y: i32 },
</span><span class="boring">    ChangeColor(u8, u8, u8),
</span><span class="boring">}
</span><span class="boring">let message = Message::Quit;
</span>match message {
    Message::Quit =&gt; println!("Quit"),
    Message::WriteString(write) =&gt; println!("{}", &amp;write),
    Message::Move{ x, y: 0 } =&gt; println!("가로로 {}만큼 이동", x),
    Message::Move{ .. } =&gt; println!("다른 이동"),
    Message::ChangeColor { 0: red, 1: green, 2: _ } =&gt; {
        println!("색상 변경, 빨강: {}, 초록: {}", red, green);
    }
};
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.refutable]</p>
<h2 id="반박-가능성"><a class="header" href="#반박-가능성">반박 가능성</a></h2>
<p>패턴이 비교 대상 값과 일치하지 않을 가능성이 있는 경우를 _반박 가능(refutable)_하다고 합니다. 반면에 _반박 불가능(irrefutable)_한 패턴은 비교 대상 값과 항상 일치합니다. 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (x, y) = (1, 2);               // "(x, y)"는 반박 불가능한 패턴입니다

if let (a, 3) = (1, 2) {           // "(a, 3)"은 반박 가능하며, 일치하지 않을 수 있습니다
    panic!("여기에 도달해서는 안 됩니다");
} else if let (a, 4) = (3, 4) {    // "(a, 4)"는 반박 가능하며, 일치하게 됩니다
    println!("({}, 4)와 일치함", a);
}
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.literal]</p>
<h2 id="리터럴-패턴"><a class="header" href="#리터럴-패턴">리터럴 패턴</a></h2>
<p>r[patterns.literal.syntax]</p>
<pre><code class="language-grammar patterns">LiteralPattern -&gt; `-`? LiteralExpression
</code></pre>
<p>r[patterns.literal.intro] <em>Literal patterns</em> match exactly the same value as what is created by the literal. Since negative numbers are not <a href="expressions/literal-expr.html">literals</a>, literals in patterns may be prefixed by an optional minus sign, which acts like the negation operator.</p>
<blockquote>
<p>[!WARNING] C string and raw C string literals are accepted in literal patterns, but <code>&amp;CStr</code> doesn’t implement structural equality (<code>#[derive(Eq, PartialEq)]</code>) and therefore any such <code>match</code> on a <code>&amp;CStr</code> will be rejected with a type error.</p>
</blockquote>
<p>r[patterns.literal.refutable] Literal patterns are always refutable.</p>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for i in -2..5 {
    match i {
        -1 =&gt; println!("마이너스 1입니다"),
        1 =&gt; println!("1입니다"),
        2|4 =&gt; println!("2 또는 4입니다"),
        _ =&gt; println!("어떠한 매치 암(arm)과도 일치하지 않았습니다"),
    }
}
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.ident]</p>
<h2 id="식별자-패턴"><a class="header" href="#식별자-패턴">식별자 패턴</a></h2>
<p>r[patterns.ident.syntax]</p>
<pre><code class="language-grammar patterns">IdentifierPattern -&gt; `ref`? `mut`? IDENTIFIER ( `@` PatternNoTopAlt )?
</code></pre>
<p>r[patterns.ident.intro] Identifier patterns bind the value they match to a variable in the <a href="names.namespaces.kinds">value namespace</a>.</p>
<p>r[patterns.ident.unique] The identifier must be unique within the pattern.</p>
<p>r[patterns.ident.scope] The variable will shadow any variables of the same name in scope. The <a href="names/scopes.html">scope</a> of the new binding depends on the context of where the pattern is used (such as a <code>let</code> binding or a <code>match</code> arm).</p>
<p>r[patterns.ident.bare] Patterns that consist of only an identifier, possibly with a <code>mut</code>, match any value and bind it to that identifier. This is the most commonly used pattern in variable declarations and parameters for functions and closures.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut variable = 10;
fn sum(x: i32, y: i32) -&gt; i32 {
<span class="boring">   x + y
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>r[patterns.ident.scrutinized] To bind the matched value of a pattern to a variable, use the syntax <code>variable @ subpattern</code>. For example, the following binds the value 2 to <code>e</code> (not the entire range: the range here is a range subpattern).</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 2;

match x {
    e @ 1 ..= 5 =&gt; println!("범위 요소 {}를 얻음", e),
    _ =&gt; println!("아무거나"),
}
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.ident.move] By default, identifier patterns bind a variable to a copy of or move from the matched value depending on whether the matched value implements <a href="special-types-and-traits.html#copy"><code>Copy</code></a>.</p>
<p>r[patterns.ident.ref] This can be changed to bind to a reference by using the <code>ref</code> keyword, or to a mutable reference using <code>ref mut</code>. For example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let a = Some(10);
</span>match a {
    None =&gt; (),
    Some(value) =&gt; (),
}

match a {
    None =&gt; (),
    Some(ref value) =&gt; (),
}
<span class="boring">}</span></code></pre></pre>
<p>첫 번째 match 표현식에서 값은 복사(또는 이동)됩니다. 두 번째 match에서 동일한 메모리 위치에 대한 참조가 변수 값에 바인딩됩니다. 구조 분해 서브패턴에서는 <code>&amp;</code> 연산자를 값의 필드에 적용할 수 없기 때문에 이 구문이 필요합니다. 예를 들어, 다음은 유효하지 않습니다:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Person {
</span><span class="boring">   name: String,
</span><span class="boring">   age: u8,
</span><span class="boring">}
</span><span class="boring">let value = Person { name: String::from("John"), age: 23 };
</span>if let Person { name: &amp;person_name, age: 18..=150 } = value { }
<span class="boring">}</span></code></pre></pre>
<p>이를 유효하게 만들려면 다음과 같이 작성하십시오:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Person {
</span><span class="boring">   name: String,
</span><span class="boring">   age: u8,
</span><span class="boring">}
</span><span class="boring">let value = Person { name: String::from("John"), age: 23 };
</span>if let Person { name: ref person_name, age: 18..=150 } = value { }
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.ident.ref-ignored] Thus, <code>ref</code> is not something that is being matched against. Its objective is exclusively to make the matched binding a reference, instead of potentially copying or moving what was matched.</p>
<p>r[patterns.ident.precedent] <a href="patterns.html#path-patterns">Path patterns</a> take precedence over identifier patterns.</p>
<blockquote>
<p>[!NOTE] When a pattern is a single-segment identifier, the grammar is ambiguous whether it means an [IdentifierPattern] or a [PathPattern]. This ambiguity can only be resolved after <a href="names/name-resolution.html">name resolution</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const EXPECTED_VALUE: u8 = 42;
//    ^^^^^^^^^^^^^^ That this constant is in scope affects how the
//                   patterns below are treated.

fn check_value(x: u8) -&gt; Result&lt;u8, u8&gt; {
    match x {
        EXPECTED_VALUE =&gt; Ok(x),
    //  ^^^^^^^^^^^^^^ Parsed as a `PathPattern` that resolves to
    //                 the constant `42`.
        other_value =&gt; Err(x),
    //  ^^^^^^^^^^^ Parsed as an `IdentifierPattern`.
    }
}

// If `EXPECTED_VALUE` were treated as an `IdentifierPattern` above,
// that pattern would always match, making the function always return
// `Ok(_) regardless of the input.
assert_eq!(check_value(42), Ok(42));
assert_eq!(check_value(43), Err(43));
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[patterns.ident.constraint] It is an error if <code>ref</code> or <code>ref mut</code> is specified and the identifier shadows a constant.</p>
<p>r[patterns.ident.refutable] Identifier patterns are irrefutable if the <code>@</code> subpattern is irrefutable or the subpattern is not specified.</p>
<p>r[patterns.ident.binding]</p>
<h3 id="바인딩-모드"><a class="header" href="#바인딩-모드">바인딩 모드</a></h3>
<p>r[patterns.ident.binding.intro] To service better ergonomics, patterns operate in different <em>binding modes</em> in order to make it easier to bind references to values. When a reference value is matched by a non-reference pattern, it will be automatically treated as a <code>ref</code> or <code>ref mut</code> binding. Example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: &amp;Option&lt;i32&gt; = &amp;Some(3);
if let Some(y) = x {
    // y는 `ref y`로 변환되었으며 타입은 &amp;i32입니다
}
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.ident.binding.non-reference] <em>Non-reference patterns</em> include all patterns except bindings, <a href="patterns.html#wildcard-pattern">wildcard patterns</a> (<code>_</code>), <a href="patterns.html#path-patterns"><code>const</code> patterns</a> of reference types, and <a href="patterns.html#reference-patterns">reference patterns</a>.</p>
<p>r[patterns.ident.binding.default-mode] If a binding pattern does not explicitly have <code>ref</code>, <code>ref mut</code>, or <code>mut</code>, then it uses the <em>default binding mode</em> to determine how the variable is bound.</p>
<p>r[patterns.ident.binding.move] The default binding mode starts in “move” mode which uses move semantics.</p>
<p>r[patterns.ident.binding.top-down] When matching a pattern, the compiler starts from the outside of the pattern and works inwards.</p>
<p>r[patterns.ident.binding.auto-deref] Each time a reference is matched using a non-reference pattern, it will automatically dereference the value and update the default binding mode.</p>
<p>r[patterns.ident.binding.ref] References will set the default binding mode to <code>ref</code>.</p>
<p>r[patterns.ident.binding.ref-mut] Mutable references will set the mode to <code>ref mut</code> unless the mode is already <code>ref</code> in which case it remains <code>ref</code>.</p>
<p>r[patterns.ident.binding.nested-references] If the automatically dereferenced value is still a reference, it is dereferenced and this process repeats.</p>
<p>r[patterns.ident.binding.mode-limitations-binding] The binding pattern may only explicitly specify a <code>ref</code> or <code>ref mut</code> binding mode, or specify mutability with <code>mut</code>, when the default binding mode is “move”. For example, these are not accepted:</p>
<pre><pre class="playground"><code class="language-rust edition2024 compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let [mut x] = &amp;[()]; //~ 오류
let [ref x] = &amp;[()]; //~ 오류
let [ref mut x] = &amp;mut [()]; //~ 오류
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.ident.binding.mode-limitations.edition2024]</p>
<blockquote>
<p>[!EDITION-2024] Before the 2024 edition, bindings could explicitly specify a <code>ref</code> or <code>ref mut</code> binding mode even when the default binding mode was not “move”, and they could specify mutability on such bindings with <code>mut</code>. In these editions, specifying <code>mut</code> on a binding set the binding mode to “move” regardless of the current default binding mode.</p>
</blockquote>
<p>r[patterns.ident.binding.mode-limitations-reference] Similarly, a reference pattern may only appear when the default binding mode is “move”. For example, this is not accepted:</p>
<pre><pre class="playground"><code class="language-rust edition2024 compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let [&amp;x] = &amp;[&amp;()]; //~ 오류
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.ident.binding.mode-limitations-reference.edition2024]</p>
<blockquote>
<p>[!EDITION-2024] Before the 2024 edition, reference patterns could appear even when the default binding mode was not “move”, and had both the effect of matching against the scrutinee and of causing the default binding mode to be reset to “move”.</p>
</blockquote>
<p>r[patterns.ident.binding.mixed] Move bindings and reference bindings can be mixed together in the same pattern. Doing so will result in partial move of the object bound to and the object cannot be used afterwards. This applies only if the type cannot be copied.</p>
<p>아래 예시에서 <code>name</code>은 <code>person</code>에서 이동됩니다. <code>person</code> 전체를 사용하거나 <code>person.name</code>을 사용하려고 하면 _부분 이동_으로 인해 오류가 발생합니다.</p>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Person {
</span><span class="boring">   name: String,
</span><span class="boring">   age: u8,
</span><span class="boring">}
</span><span class="boring">let person = Person{ name: String::from("John"), age: 23 };
</span>// `name`은 person에서 이동되고 `age`는 참조됩니다
let Person { name, ref age } = person;
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.wildcard]</p>
<h2 id="와일드카드-패턴"><a class="header" href="#와일드카드-패턴">와일드카드 패턴</a></h2>
<p>r[patterns.wildcard.syntax]</p>
<pre><code class="language-grammar patterns">WildcardPattern -&gt; `_`
</code></pre>
<p>r[patterns.wildcard.intro] The <em>wildcard pattern</em> (an underscore symbol) matches any value. It is used to ignore values when they don’t matter.</p>
<p>r[patterns.wildcard.struct-matcher] Inside other patterns it matches a single data field (as opposed to the <code>..</code> which matches the remaining fields).</p>
<p>r[patterns.wildcard.no-binding] Unlike identifier patterns, it does not copy, move or borrow the value it matches.</p>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let x = 20;
</span>let (a, _) = (10, x);   // x는 항상 _와 매치됩니다
<span class="boring">assert_eq!(a, 10);
</span>
// 함수/클로저 매개변수를 무시합니다
let real_part = |a: f64, _: f64| { a };

// 구조체의 필드를 무시합니다
<span class="boring">struct RGBA {
</span><span class="boring">   r: f32,
</span><span class="boring">   g: f32,
</span><span class="boring">   b: f32,
</span><span class="boring">   a: f32,
</span><span class="boring">}
</span><span class="boring">let color = RGBA{r: 0.4, g: 0.1, b: 0.9, a: 0.5};
</span>let RGBA{r: red, g: green, b: blue, a: _} = color;
<span class="boring">assert_eq!(color.r, red);
</span><span class="boring">assert_eq!(color.g, green);
</span><span class="boring">assert_eq!(color.b, blue);
</span>
// 어떤 값이든 Some이면 허용합니다
<span class="boring">let x = Some(10);
</span>if let Some(_) = x {}
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.wildcard.refutable] The wildcard pattern is always irrefutable.</p>
<p>r[patterns.rest]</p>
<h2 id="rest-pattern"><a class="header" href="#rest-pattern">Rest pattern</a></h2>
<p>r[patterns.rest.syntax]</p>
<pre><code class="language-grammar patterns">RestPattern -&gt; `..`
</code></pre>
<p>r[patterns.rest.intro] The <em>rest pattern</em> (the <code>..</code> token) acts as a variable-length pattern which matches zero or more elements that haven’t been matched already before and after.</p>
<p>r[patterns.rest.allowed-patterns] It may only be used in <a href="patterns.html#tuple-patterns">tuple</a>, <a href="patterns.html#tuple-struct-patterns">tuple struct</a>, and <a href="patterns.html#slice-patterns">slice</a> patterns, and may only appear once as one of the elements in those patterns. It is also allowed in an <a href="patterns.html#identifier-patterns">identifier pattern</a> for <a href="patterns.html#slice-patterns">slice patterns</a> only.</p>
<p>r[patterns.rest.refutable] The rest pattern is always irrefutable.</p>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let words = vec!["a", "b", "c"];
</span><span class="boring">let slice = &amp;words[..];
</span>match slice {
    [] =&gt; println!("슬라이스가 비어 있음"),
    [one] =&gt; println!("단일 요소 {}", one),
    [head, tail @ ..] =&gt; println!("head={} tail={:?}", head, tail),
}

match slice {
    // "!"여야 하는 마지막 요소를 제외한 모든 것을 무시합니다.
    [.., "!"] =&gt; println!("!!!"),

    // `start`는 "z"여야 하는 마지막 요소를 제외한 모든 것의 슬라이스입니다.
    [start @ .., "z"] =&gt; println!("다음으로 시작함: {:?}", start),

    // `end`는 "a"여야 하는 첫 번째 요소를 제외한 모든 것의 슬라이스입니다.
    ["a", end @ ..] =&gt; println!("다음으로 끝남: {:?}", end),

    // 'whole'은 전체 슬라이스이고 `last`는 마지막 요소입니다
    whole @ [.., last] =&gt; println!("{:?}의 마지막 요소는 {}입니다", whole, last),

    rest =&gt; println!("{:?}", rest),
}

if let [.., penultimate, _] = slice {
    println!("마지막에서 두 번째는 {}입니다", penultimate);
}

<span class="boring">let tuple = (1, 2, 3, 4, 5);
</span>// The rest pattern may also be used in tuple and tuple
// struct patterns.
match tuple {
    (1, .., y, z) =&gt; println!("y={} z={}", y, z),
    (.., 5) =&gt; println!("꼬리(tail)는 5여야 함"),
    (..) =&gt; println!("그 외 모든 것과 일치함"),
}
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.range]</p>
<h2 id="범위-패턴"><a class="header" href="#범위-패턴">범위 패턴</a></h2>
<p>r[patterns.range.syntax]</p>
<pre><code class="language-grammar patterns">RangePattern -&gt;
      RangeExclusivePattern
    | RangeInclusivePattern
    | RangeFromPattern
    | RangeToExclusivePattern
    | RangeToInclusivePattern
    | ObsoleteRangePattern[^obsolete-range-edition]

RangeExclusivePattern -&gt;
      RangePatternBound `..` RangePatternBound

RangeInclusivePattern -&gt;
      RangePatternBound `..=` RangePatternBound

RangeFromPattern -&gt;
      RangePatternBound `..`

RangeToExclusivePattern -&gt;
      `..` RangePatternBound

RangeToInclusivePattern -&gt;
      `..=` RangePatternBound

ObsoleteRangePattern -&gt;
    RangePatternBound `...` RangePatternBound

RangePatternBound -&gt;
      LiteralPattern
    | PathExpression
</code></pre>
<div class="footnote-definition" id="obsolete-range-edition"><sup class="footnote-definition-label">1</sup>
<p>The [ObsoleteRangePattern] syntax has been removed in the 2021 edition.</p>
</div>
<p>r[patterns.range.intro] <em>Range patterns</em> match scalar values within the range defined by their bounds. They comprise a <em>sigil</em> (<code>..</code> or <code>..=</code>) and a bound on one or both sides.</p>
<p>A bound on the left of the sigil is called a <em>lower bound</em>. A bound on the right is called an <em>upper bound</em>.</p>
<p>r[patterns.range.exclusive] The <em>exclusive range pattern</em> matches all values from the lower bound up to, but not including the upper bound. It is written as its lower bound, followed by <code>..</code>, followed by the upper bound.</p>
<p>For example, a pattern <code>'m'..'p'</code> will match only <code>'m'</code>, <code>'n'</code> and <code>'o'</code>, specifically <strong>not</strong> including <code>'p'</code>.</p>
<p>r[patterns.range.inclusive] The <em>inclusive range pattern</em> matches all values from the lower bound up to and including the upper bound. It is written as its lower bound, followed by <code>..=</code>, followed by the upper bound.</p>
<p>For example, a pattern <code>'m'..='p'</code> will match only the values <code>'m'</code>, <code>'n'</code>, <code>'o'</code>, and <code>'p'</code>.</p>
<p>r[patterns.range.from] The <em>from range pattern</em> matches all values greater than or equal to the lower bound. It is written as its lower bound followed by <code>..</code>.</p>
<p>For example, <code>1..</code> will match any integer greater than or equal to 1, such as 1, 9, or 9001, or 9007199254740991 (if it is of an appropriate size), but not 0, and not negative numbers for signed integers.</p>
<p>r[patterns.range.to-exclusive] The <em>to exclusive range pattern</em> matches all values less than the upper bound. It is written as <code>..</code> followed by the upper bound.</p>
<p>For example, <code>..10</code> will match any integer less than 10, such as 9, 1, 0, and for signed integer types, all negative values.</p>
<p>r[patterns.range.to-inclusive] The <em>to inclusive range pattern</em> matches all values less than or equal to the upper bound. It is written as <code>..=</code> followed by the upper bound.</p>
<p>For example, <code>..=10</code> will match any integer less than or equal to 10, such as 10, 1, 0, and for signed integer types, all negative values.</p>
<p>r[patterns.range.constraint-nonempty] A range pattern must be nonempty; it must span at least one value in the set of possible values for its type. In other words:</p>
<ul>
<li>In <code>a..=b</code>, a ≤ b must be the case. For example, it is an error to have a range pattern <code>10..=0</code>, but <code>10..=10</code> is allowed.</li>
<li>In <code>a..b</code>, a &lt; b must be the case. For example, it is an error to have a range pattern <code>10..0</code> or <code>10..10</code>.</li>
<li>In <code>..b</code>, b must not be the smallest value of its type. For example, it is an error to have a range pattern <code>..-128i8</code> or <code>..f64::NEG_INFINITY</code>.</li>
</ul>
<p>r[patterns.range.bound] A bound is written as one of:</p>
<ul>
<li>문자, 바이트, 정수 또는 부동 소수점 리터럴.</li>
<li>정수 또는 부동 소수점 리터럴 앞에 <code>-</code>가 붙은 형태.</li>
<li>A <a href="expressions/path-expr.html">path</a>.</li>
</ul>
<blockquote>
<p>[!NOTE]</p>
<p>We syntactically accept more than this for a <em>[RangePatternBound]</em>. We later reject the other things semantically.</p>
</blockquote>
<p>r[patterns.range.constraint-bound-path] If a bound is written as a path, after macro resolution, the path must resolve to a constant item of the type <code>char</code>, an integer type, or a float type.</p>
<p>r[patterns.range.type] The range pattern matches the type of its upper and lower bounds, which must be the same type.</p>
<p>r[patterns.range.path-value] If a bound is a <a href="expressions/path-expr.html">path</a>, the bound matches the type and has the value of the <a href="items/constant-items.html">constant</a> the path resolves to.</p>
<p>r[patterns.range.literal-value] If a bound is a literal, the bound matches the type and has the value of the corresponding <a href="expressions/literal-expr.html">literal expression</a>.</p>
<p>r[patterns.range.negation] If a bound is a literal preceded by a <code>-</code>, the bound matches the same type as the corresponding <a href="expressions/literal-expr.html">literal expression</a> and has the value of <a href="expressions/operator-expr.html#negation-operators">negating</a> the value of the corresponding literal expression.</p>
<p>r[patterns.range.float-restriction] For float range patterns, the constant may not be a <code>NaN</code>.</p>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let c = 'f';
</span>let valid_variable = match c {
    'a'..='z' =&gt; true,
    'A'..='Z' =&gt; true,
    'α'..='ω' =&gt; true,
    _ =&gt; false,
};

<span class="boring">let ph = 10;
</span>println!("{}", match ph {
    0..7 =&gt; "산성",
    7 =&gt; "중성",
    8..=14 =&gt; "염기성",
    _ =&gt; unreachable!(),
});

<span class="boring">let uint: u32 = 5;
</span>match uint {
    0 =&gt; "0입니다!",
    1.. =&gt; "양수입니다!",
};

// 상수에 대한 경로 사용:
<span class="boring">const TROPOSPHERE_MIN : u8 = 6;
</span><span class="boring">const TROPOSPHERE_MAX : u8 = 20;
</span><span class="boring">
</span><span class="boring">const STRATOSPHERE_MIN : u8 = TROPOSPHERE_MAX + 1;
</span><span class="boring">const STRATOSPHERE_MAX : u8 = 50;
</span><span class="boring">
</span><span class="boring">const MESOSPHERE_MIN : u8 = STRATOSPHERE_MAX + 1;
</span><span class="boring">const MESOSPHERE_MAX : u8 = 85;
</span><span class="boring">
</span><span class="boring">let altitude = 70;
</span><span class="boring">
</span>println!("{}", match altitude {
    TROPOSPHERE_MIN..=TROPOSPHERE_MAX =&gt; "대류권",
    STRATOSPHERE_MIN..=STRATOSPHERE_MAX =&gt; "성층권",
    MESOSPHERE_MIN..=MESOSPHERE_MAX =&gt; "중간권",
    _ =&gt; "아마도 외계 공간",
});

<span class="boring">pub mod binary {
</span><span class="boring">    pub const MEGA : u64 = 1024*1024;
</span><span class="boring">    pub const GIGA : u64 = 1024*1024*1024;
</span><span class="boring">}
</span><span class="boring">let n_items = 20_832_425;
</span><span class="boring">let bytes_per_item = 12;
</span>if let size @ binary::MEGA..=binary::GIGA = n_items * bytes_per_item {
    println!("크기가 적절하며 {}바이트를 차지함", size);
}

<span class="boring">trait MaxValue {
</span><span class="boring">    const MAX: u64;
</span><span class="boring">}
</span><span class="boring">impl MaxValue for u8 {
</span><span class="boring">    const MAX: u64 = (1 &lt;&lt; 8) - 1;
</span><span class="boring">}
</span><span class="boring">impl MaxValue for u16 {
</span><span class="boring">    const MAX: u64 = (1 &lt;&lt; 16) - 1;
</span><span class="boring">}
</span><span class="boring">impl MaxValue for u32 {
</span><span class="boring">    const MAX: u64 = (1 &lt;&lt; 32) - 1;
</span><span class="boring">}
</span>// 정규화된 경로 사용:
println!("{}", match 0xfacade {
    0 ..= &lt;u8 as MaxValue&gt;::MAX =&gt; "u8에 맞음",
    0 ..= &lt;u16 as MaxValue&gt;::MAX =&gt; "u16에 맞음",
    0 ..= &lt;u32 as MaxValue&gt;::MAX =&gt; "u32에 맞음",
    _ =&gt; "너무 큼",
});
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.range.refutable] Range patterns for fix-width integer and <code>char</code> types are irrefutable when they span the entire set of possible values of a type. For example, <code>0u8..=255u8</code> is irrefutable.</p>
<p>r[patterns.range.refutable-integer] The range of values for an integer type is the closed range from its minimum to maximum value.</p>
<p>r[patterns.range.refutable-char] The range of values for a <code>char</code> type are precisely those ranges containing all Unicode Scalar Values: <code>'\u{0000}'..='\u{D7FF}'</code> and <code>'\u{E000}'..='\u{10FFFF}'</code>.</p>
<p>r[patterns.range.constraint-slice] [RangeFromPattern] cannot be used as a top-level pattern for subpatterns in <a href="patterns.html#slice-patterns">slice patterns</a>. For example, the pattern <code>[1.., _]</code> is not a valid pattern.</p>
<p>r[patterns.range.edition2021]</p>
<blockquote>
<p>[!EDITION-2021] Before the 2021 edition, range patterns with both a lower and upper bound may also be written using <code>...</code> in place of <code>..=</code>, with the same meaning.</p>
</blockquote>
<p>r[patterns.ref]</p>
<h2 id="참조-패턴"><a class="header" href="#참조-패턴">참조 패턴</a></h2>
<p>r[patterns.ref.syntax]</p>
<pre><code class="language-grammar patterns">ReferencePattern -&gt; (`&amp;`|`&amp;&amp;`) `mut`? PatternWithoutRange
</code></pre>
<p>r[patterns.ref.intro] Reference patterns dereference the pointers that are being matched and, thus, borrow them.</p>
<p>예를 들어, <code>x: &amp;i32</code>에 대한 다음 두 매치는 동일합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let int_reference = &amp;3;

let a = match *int_reference { 0 =&gt; "0", _ =&gt; "some" };
let b = match int_reference { &amp;0 =&gt; "0", _ =&gt; "some" };

assert_eq!(a, b);
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.ref.ref-ref] The grammar production for reference patterns has to match the token <code>&amp;&amp;</code> to match a reference to a reference because it is a token by itself, not two <code>&amp;</code> tokens.</p>
<p>r[patterns.ref.mut] Adding the <code>mut</code> keyword dereferences a mutable reference. The mutability must match the mutability of the reference.</p>
<p>r[patterns.ref.refutable] Reference patterns are always irrefutable.</p>
<p>r[patterns.struct]</p>
<h2 id="구조체-패턴"><a class="header" href="#구조체-패턴">구조체 패턴</a></h2>
<p>r[patterns.struct.syntax]</p>
<pre><code class="language-grammar patterns">StructPattern -&gt;
    PathInExpression `{`
        StructPatternElements?
    `}`

StructPatternElements -&gt;
      StructPatternFields (`,` | `,` StructPatternEtCetera)?
    | StructPatternEtCetera

StructPatternFields -&gt;
    StructPatternField (`,` StructPatternField)*

StructPatternField -&gt;
    OuterAttribute*
    (
        TUPLE_INDEX `:` Pattern
      | IDENTIFIER `:` Pattern
      | `ref`? `mut`? IDENTIFIER
    )

StructPatternEtCetera -&gt; `..`
</code></pre>
<p>r[patterns.struct.intro] Struct patterns match struct, enum, and union values that match all criteria defined by its subpatterns. They are also used to <a href="patterns.html#destructuring">destructure</a> a struct, enum, or union value.</p>
<p>r[patterns.struct.ignore-rest] On a struct pattern, the fields are referenced by name, index (in the case of tuple structs) or ignored by use of <code>..</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Point {
</span><span class="boring">    x: u32,
</span><span class="boring">    y: u32,
</span><span class="boring">}
</span><span class="boring">let s = Point {x: 1, y: 1};
</span><span class="boring">
</span>match s {
    Point {x: 10, y: 20} =&gt; (),
    Point {y: 10, x: 20} =&gt; (),    // 순서는 중요하지 않음
    Point {x: 10, ..} =&gt; (),
    Point {..} =&gt; (),
}

<span class="boring">struct PointTuple (
</span><span class="boring">    u32,
</span><span class="boring">    u32,
</span><span class="boring">);
</span><span class="boring">let t = PointTuple(1, 2);
</span><span class="boring">
</span>match t {
    PointTuple {0: 10, 1: 20} =&gt; (),
    PointTuple {1: 10, 0: 20} =&gt; (),   // 순서는 중요하지 않음
    PointTuple {0: 10, ..} =&gt; (),
    PointTuple {..} =&gt; (),
}

<span class="boring">enum Message {
</span><span class="boring">    Quit,
</span><span class="boring">    Move { x: i32, y: i32 },
</span><span class="boring">}
</span><span class="boring">let m = Message::Quit;
</span><span class="boring">
</span>match m {
    Message::Quit =&gt; (),
    Message::Move {x: 10, y: 20} =&gt; (),
    Message::Move {..} =&gt; (),
}
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.struct.constraint-struct] If <code>..</code> is not used, a struct pattern used to match a struct is required to specify all fields:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Struct {
</span><span class="boring">   a: i32,
</span><span class="boring">   b: char,
</span><span class="boring">   c: bool,
</span><span class="boring">}
</span><span class="boring">let mut struct_value = Struct{a: 10, b: 'X', c: false};
</span><span class="boring">
</span>match struct_value {
    Struct{a: 10, b: 'X', c: false} =&gt; (),
    Struct{a: 10, b: 'X', ref c} =&gt; (),
    Struct{a: 10, b: 'X', ref mut c} =&gt; (),
    Struct{a: 10, b: 'X', c: _} =&gt; (),
    Struct{a: _, b: _, c: _} =&gt; (),
}
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.struct.constraint-union] A struct pattern used to match a union must specify exactly one field (see <a href="items/unions.html#pattern-matching-on-unions">Pattern matching on unions</a>).</p>
<p>r[patterns.struct.binding-shorthand] The [IDENTIFIER] syntax matches any value and binds it to a variable with the same name as the given field. It is a shorthand for <code>fieldname: fieldname</code>. The <code>ref</code> and <code>mut</code> qualifiers can be included with the behavior as described in [patterns.ident.ref].</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Struct {
</span><span class="boring">   a: i32,
</span><span class="boring">   b: char,
</span><span class="boring">   c: bool,
</span><span class="boring">}
</span><span class="boring">let struct_value = Struct{a: 10, b: 'X', c: false};
</span><span class="boring">
</span>let Struct { a, b, c } = struct_value;
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.struct.refutable] A struct pattern is refutable if the [PathInExpression] resolves to a constructor of an enum with more than one variant, or one of its subpatterns is refutable.</p>
<p>r[patterns.struct.namespace] A struct pattern matches against the struct, union, or enum variant whose constructor is resolved from [PathInExpression] in the <a href="names.namespaces.kinds">type namespace</a>. See [patterns.tuple-struct.namespace] for more details.</p>
<p>r[patterns.tuple-struct]</p>
<h2 id="튜플-구조체-패턴"><a class="header" href="#튜플-구조체-패턴">튜플 구조체 패턴</a></h2>
<p>r[patterns.tuple-struct.syntax]</p>
<pre><code class="language-grammar patterns">TupleStructPattern -&gt; PathInExpression `(` TupleStructItems? `)`

TupleStructItems -&gt; Pattern ( `,` Pattern )* `,`?
</code></pre>
<p>r[patterns.tuple-struct.intro] Tuple struct patterns match tuple struct and enum values that match all criteria defined by its subpatterns. They are also used to <a href="patterns.html#destructuring">destructure</a> a tuple struct or enum value.</p>
<p>r[patterns.tuple-struct.refutable] A tuple struct pattern is refutable if the [PathInExpression] resolves to a constructor of an enum with more than one variant, or one of its subpatterns is refutable.</p>
<p>r[patterns.tuple-struct.namespace] A tuple struct pattern matches against the tuple struct or <a href="items.enum.tuple-expr">tuple-like enum variant</a> whose constructor is resolved from [PathInExpression] in the <a href="names.namespaces.kinds">value namespace</a>.</p>
<blockquote>
<p>[!NOTE] Conversely, a struct pattern for a tuple struct or <a href="items.enum.tuple-expr">tuple-like enum variant</a>, e.g. <code>S { 0: _ }</code>, matches against the tuple struct or variant whose constructor is resolved in the <a href="names.namespaces.kinds">type namespace</a>.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024">enum E1 { V(u16) }
enum E2 { V(u32) }

// Import `E1::V` from the type namespace only.
mod _0 {
    const V: () = (); // For namespace masking.
    pub(super) use super::E1::*;
}
use _0::*;

// Import `E2::V` from the value namespace only.
mod _1 {
    struct V {} // For namespace masking.
    pub(super) use super::E2::*;
}
use _1::*;

fn f() {
    // This struct pattern matches against the tuple-like
    // enum variant whose constructor was found in the type
    // namespace.
    let V { 0: ..=u16::MAX } = (loop {}) else { loop {} };
    // This tuple struct pattern matches against the tuple-like
    // enum variant whose constructor was found in the value
    // namespace.
    let V(..=u32::MAX) = (loop {}) else { loop {} };
}
<span class="boring">// Required due to the odd behavior of `super` within functions.
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>The Lang team has made certain decisions, such as in <a href="https://github.com/rust-lang/rust/pull/138458">PR #138458</a>, that raise questions about the desirability of using the value namespace in this way for patterns, as described in <a href="https://github.com/rust-lang/rust/pull/140593#issuecomment-2972338457">PR #140593</a>. It might be prudent to not intentionally rely on this nuance in your code.</p>
</blockquote>
<p>r[patterns.tuple]</p>
<h2 id="튜플-패턴"><a class="header" href="#튜플-패턴">튜플 패턴</a></h2>
<p>r[patterns.tuple.syntax]</p>
<pre><code class="language-grammar patterns">TuplePattern -&gt; `(` TuplePatternItems? `)`

TuplePatternItems -&gt;
      Pattern `,`
    | RestPattern
    | Pattern (`,` Pattern)+ `,`?
</code></pre>
<p>r[patterns.tuple.intro] Tuple patterns match tuple values that match all criteria defined by its subpatterns. They are also used to <a href="patterns.html#destructuring">destructure</a> a tuple.</p>
<p>r[patterns.tuple.rest-syntax] The form <code>(..)</code> with a single [RestPattern] is a special form that does not require a comma, and matches a tuple of any size.</p>
<p>r[patterns.tuple.refutable] The tuple pattern is refutable when one of its subpatterns is refutable.</p>
<p>튜플 패턴 사용 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pair = (10, "ten");
let (a, b) = pair;

assert_eq!(a, 10);
assert_eq!(b, "ten");
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.paren]</p>
<h2 id="그룹화된-패턴"><a class="header" href="#그룹화된-패턴">그룹화된 패턴</a></h2>
<p>r[patterns.paren.syntax]</p>
<pre><code class="language-grammar patterns">GroupedPattern -&gt; `(` Pattern `)`
</code></pre>
<p>r[patterns.paren.intro] Enclosing a pattern in parentheses can be used to explicitly control the precedence of compound patterns. For example, a reference pattern next to a range pattern such as <code>&amp;0..=5</code> is ambiguous and is not allowed, but can be expressed with parentheses.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let int_reference = &amp;3;
match int_reference {
    &amp;(0..=5) =&gt; (),
    _ =&gt; (),
}
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.slice]</p>
<h2 id="슬라이스-패턴"><a class="header" href="#슬라이스-패턴">슬라이스 패턴</a></h2>
<p>r[patterns.slice.syntax]</p>
<pre><code class="language-grammar patterns">SlicePattern -&gt; `[` SlicePatternItems? `]`

SlicePatternItems -&gt; Pattern (`,` Pattern)* `,`?
</code></pre>
<p>r[patterns.slice.intro] Slice patterns can match both arrays of fixed size and slices of dynamic size.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 고정 크기
let arr = [1, 2, 3];
match arr {
    [1, _, _] =&gt; "1로 시작함",
    [a, b, c] =&gt; "다른 것으로 시작함",
};
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 동적 크기
let v = vec![1, 2, 3];
match v[..] {
    [a, b] =&gt; { /* 이 암(arm)은 길이가 일치하지 않으므로 적용되지 않습니다 */ }
    [a, b, c] =&gt; { /* 이 암(arm)이 적용됩니다 */ }
    _ =&gt; { /* 길이를 정적으로 알 수 없으므로 이 와일드카드가 필요합니다 */ }
};
<span class="boring">}</span></code></pre></pre>
<p>r[patterns.slice.refutable-array] Slice patterns are irrefutable when matching an array as long as each element is irrefutable.</p>
<p>r[patterns.slice.refutable-slice] When matching a slice, it is irrefutable only in the form with a single <code>..</code> [rest pattern][patterns.rest] or <a href="patterns.html#identifier-patterns">identifier pattern</a> with the <code>..</code> rest pattern as a subpattern.</p>
<p>r[patterns.slice.restriction] Within a slice, a range pattern without both lower and upper bound must be enclosed in parentheses, as in <code>(a..)</code>, to clarify it is intended to match against a single slice element. A range pattern with both lower and upper bound, like <code>a..=b</code>, is not required to be enclosed in parentheses.</p>
<p>r[patterns.path]</p>
<h2 id="경로-패턴"><a class="header" href="#경로-패턴">경로 패턴</a></h2>
<p>r[patterns.path.syntax]</p>
<pre><code class="language-grammar patterns">PathPattern -&gt; PathExpression
</code></pre>
<p>r[patterns.path.intro] <em>Path patterns</em> are patterns that refer either to constant values or to structs or enum variants that have no fields.</p>
<p>r[patterns.path.unqualified] Unqualified path patterns can refer to:</p>
<ul>
<li>열거형 변형</li>
<li>구조체</li>
<li>상수</li>
<li>연관 상수</li>
</ul>
<p>r[patterns.path.qualified] Qualified path patterns can only refer to associated constants.</p>
<p>r[patterns.path.refutable] Path patterns are irrefutable when they refer to structs or an enum variant when the enum has only one variant or a constant whose type is irrefutable. They are refutable when they refer to refutable constants or enum variants for enums with multiple variants.</p>
<p>r[patterns.const]</p>
<h3 id="상수-패턴"><a class="header" href="#상수-패턴">상수 패턴</a></h3>
<p>r[patterns.const.partial-eq] When a constant <code>C</code> of type <code>T</code> is used as a pattern, we first check that <code>T: PartialEq</code>.</p>
<p>r[patterns.const.structural-equality] Furthermore we require that the value of <code>C</code> <em>has (recursive) structural equality</em>, which is defined recursively as follows:</p>
<p>r[patterns.const.primitive]</p>
<ul>
<li>정수뿐만 아니라 <code>str</code>, <code>bool</code>, <code>char</code> 값은 항상 구조적 동등성을 갖습니다.</li>
</ul>
<p>r[patterns.const.builtin-aggregate]</p>
<ul>
<li>튜플, 배열, 슬라이스는 모든 필드/요소가 구조적 동등성을 가지면 구조적 동등성을 갖습니다. (특히, <code>()</code>와 <code>[]</code>는 항상 구조적 동등성을 갖습니다.)</li>
</ul>
<p>r[patterns.const.ref]</p>
<ul>
<li>참조는 가리키는 값이 구조적 동등성을 가지면 구조적 동등성을 갖습니다.</li>
</ul>
<p>r[patterns.const.aggregate]</p>
<ul>
<li><code>struct</code> 또는 <code>enum</code> 타입의 값은 <code>PartialEq</code> 인스턴스가 <code>#[derive(PartialEq)]</code>를 통해 파생되었고, 모든 필드(열거형의 경우 현재 활성화된 변형의 필드)가 구조적 동등성을 가지면 구조적 동등성을 갖습니다.</li>
</ul>
<p>r[patterns.const.pointer]</p>
<ul>
<li>원시 포인터는 상수 정수로 정의된 경우(그 후 캐스팅되거나 transmute된 경우) 구조적 동등성을 갖습니다.</li>
</ul>
<p>r[patterns.const.float]</p>
<ul>
<li>부동 소수점 값은 <code>NaN</code>이 아니면 구조적 동등성을 갖습니다.</li>
</ul>
<p>r[patterns.const.exhaustive]</p>
<ul>
<li>그 외에는 구조적 동등성을 갖지 않습니다.</li>
</ul>
<p>r[patterns.const.generic] In particular, the value of <code>C</code> must be known at pattern-building time (which is pre-monomorphization). This means that associated consts that involve generic parameters cannot be used as patterns.</p>
<p>r[patterns.const.immutable] The value of <code>C</code> must not contain any references to mutable statics (<code>static mut</code> items or interior mutable <code>static</code> items) or <code>extern</code> statics.</p>
<p>r[patterns.const.translation] After ensuring all conditions are met, the constant value is translated into a pattern, and now behaves exactly as-if that pattern had been written directly. In particular, it fully participates in exhaustiveness checking. (For raw pointers, constants are the only way to write such patterns. Only <code>_</code> is ever considered exhaustive for these types.)</p>
<p>r[patterns.or]</p>
<h2 id="or-패턴"><a class="header" href="#or-패턴">Or 패턴</a></h2>
<p><em>Or-patterns</em> are patterns that match on one of two or more sub-patterns (for example <code>A | B | C</code>). They can nest arbitrarily. Syntactically, or-patterns are allowed in any of the places where other patterns are allowed (represented by the [Pattern] production), with the exceptions of <code>let</code>-bindings and function and closure parameters (represented by the [PatternNoTopAlt] production).</p>
<p>r[patterns.constraints]</p>
<h3 id="정적-시맨틱"><a class="header" href="#정적-시맨틱">정적 시맨틱</a></h3>
<p>r[patterns.constraints.pattern]</p>
<ol>
<li>
<p>임의의 패턴 <code>p</code>와 <code>q</code>에 대해 어떤 깊이에서든 <code>p | q</code> 패턴이 주어졌을 때, 다음의 경우 해당 패턴은 잘못 형성된(ill-formed) 것으로 간주됩니다:</p>
<ul>
<li><code>p</code>에 대해 추론된 타입이 <code>q</code>에 대해 추론된 타입과 통합(unify)되지 않거나,</li>
<li><code>p</code>와 <code>q</code>에서 동일한 바인딩 집합이 도입되지 않거나,</li>
<li><code>p</code>와 <code>q</code>에 있는 동일한 이름의 두 바인딩 타입이 타입 또는 바인딩 모드 관점에서 통합되지 않는 경우.
타입 통합은 모든 인스턴스에서 앞서 언급한 대로 정확해야 하며, 암시적인 <a href="type-coercions.html">타입 강제 변환</a>은 적용되지 않습니다.</li>
</ul>
</li>
</ol>
<p>r[patterns.constraints.match-type-check] 2. When type checking an expression <code>match e_s { a_1 =&gt; e_1, ... a_n =&gt; e_n }</code>, for each match arm <code>a_i</code> which contains a pattern of form <code>p_i | q_i</code>, the pattern <code>p_i | q_i</code> is considered ill formed if, at the depth <code>d</code> where it exists the fragment of <code>e_s</code> at depth <code>d</code>, the type of the expression fragment does not unify with <code>p_i | q_i</code>.</p>
<p>r[patterns.constraints.exhaustiveness-or-pattern] 3. With respect to exhaustiveness checking, a pattern <code>p | q</code> is considered to cover <code>p</code> as well as <code>q</code>. For some constructor <code>c(x, ..)</code> the distributive law applies such that <code>c(p | q, ..rest)</code> covers the same set of value as <code>c(p, ..rest) | c(q, ..rest)</code> does. This can be applied recursively until there are no more nested patterns of form <code>p | q</code> other than those that exist at the top level.</p>
<p>여기서 _“생성자”_는 튜플 구조체 패턴만을 가리키는 것이 아니라, 모든 곱 타입(product type)에 대한 패턴을 의미합니다. 여기에는 열거형 변형, 튜플 구조체, 이름 있는 필드가 있는 구조체, 배열, 튜플, 슬라이스가 포함됩니다.</p>
<p>r[patterns.behavior]</p>
<h3 id="동적-시맨틱"><a class="header" href="#동적-시맨틱">동적 시맨틱</a></h3>
<p>r[patterns.behavior.nested-or-patterns]</p>
<ol>
<li>조사 대상 표현식 <code>e_s</code>를 깊이 <code>d</code>에서 <code>c(p | q, ..rest)</code> 패턴(여기서 <code>c</code>는 어떤 생성자, <code>p</code>와 <code>q</code>는 임의의 패턴, <code>rest</code>는 <code>c</code>의 나머지 선택적 요소)과 매치하는 동적 시맨틱은 <code>c(p, ..rest) | c(q, ..rest)</code>와 동일한 것으로 정의됩니다.</li>
</ol>
<p>r[patterns.precedence]</p>
<h3 id="구분-기호가-없는-다른-패턴과의-우선순위"><a class="header" href="#구분-기호가-없는-다른-패턴과의-우선순위">구분 기호가 없는 다른 패턴과의 우선순위</a></h3>
<p>이 장의 다른 곳에서 보여준 것처럼, 식별자 패턴, 참조 패턴, Or 패턴을 포함하여 구문상으로 구분 기호가 없는(undelimited) 여러 유형의 패턴이 있습니다. Or 패턴은 항상 가장 낮은 우선순위를 갖습니다. 이를 통해 향후 타입 어스크립션(type ascription) 기능을 위한 구문적 공간을 확보하고 모호성을 줄일 수 있습니다. 예를 들어, <code>x @ A(..) | B(..)</code>는 <code>x</code>가 모든 패턴에 바인딩되지 않았다는 오류를 발생시킵니다. <code>&amp;A(x) | B(x)</code>는 서로 다른 서브패턴에 있는 <code>x</code> 사이의 타입 불일치를 발생시킵니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="타입-시스템"><a class="header" href="#타입-시스템">타입 시스템</a></h1>
<div style="break-before: page; page-break-before: always;"></div><p>r[type]</p>
<h1 id="타입"><a class="header" href="#타입">타입</a></h1>
<p>r[type.intro] Every variable, item, and value in a Rust program has a type. The <em>type</em> of a <em>value</em> defines the interpretation of the memory holding it and the operations that may be performed on the value.</p>
<p>r[type.builtin] Built-in types are tightly integrated into the language, in nontrivial ways that are not possible to emulate in user-defined types.</p>
<p>r[type.user-defined] User-defined types have limited capabilities.</p>
<p>r[type.kinds] The list of types is:</p>
<ul>
<li>기본 타입(Primitive types):
<ul>
<li><a href="types/boolean.html">불리언</a> — <code>bool</code></li>
<li><a href="types/numeric.html">숫자</a> — 정수 및 부동 소수점</li>
<li><a href="types/textual.html">텍스트</a> — <code>char</code> 및 <code>str</code></li>
<li><a href="types/never.html">네버</a> — <code>!</code> — 값이 없는 타입</li>
</ul>
</li>
<li>시퀀스 타입:
<ul>
<li><a href="types/tuple.html">튜플</a></li>
<li><a href="types/array.html">배열</a></li>
<li><a href="types/slice.html">슬라이스</a></li>
</ul>
</li>
<li>사용자 정의 타입:
<ul>
<li><a href="types/struct.html">구조체</a></li>
<li><a href="types/enum.html">열거형</a></li>
<li><a href="types/union.html">공용체</a></li>
</ul>
</li>
<li>함수 타입:
<ul>
<li><a href="types/function-item.html">함수</a></li>
<li><a href="types/closure.html">클로저</a></li>
</ul>
</li>
<li>포인터 타입:
<ul>
<li><a href="types/pointer.html#shared-references-">참조</a></li>
<li><a href="types/pointer.html#raw-pointers-const-and-mut">원시 포인터</a></li>
<li><a href="types/function-pointer.html">함수 포인터</a></li>
</ul>
</li>
<li>트레잇 타입:
<ul>
<li><a href="types/trait-object.html">트레잇 객체</a></li>
<li><a href="types/impl-trait.html">Impl 트레잇</a></li>
</ul>
</li>
</ul>
<p>r[type.name]</p>
<h2 id="타입-표현식"><a class="header" href="#타입-표현식">타입 표현식</a></h2>
<p>r[type.name.syntax]</p>
<pre><code class="language-grammar types">Type -&gt;
      TypeNoBounds
    | ImplTraitType
    | TraitObjectType

TypeNoBounds -&gt;
      ParenthesizedType
    | ImplTraitTypeOneBound
    | TraitObjectTypeOneBound
    | TypePath
    | TupleType
    | NeverType
    | RawPointerType
    | ReferenceType
    | ArrayType
    | SliceType
    | InferredType
    | QualifiedPathInType
    | BareFunctionType
    | MacroInvocation
</code></pre>
<p>r[type.name.intro] A <em>type expression</em> as defined in the [Type] grammar rule above is the syntax for referring to a type. It may refer to:</p>
<p>r[type.name.sequence]</p>
<ul>
<li>시퀀스 타입 (<a href="types/tuple.html">튜플</a>, <a href="types/array.html">배열</a>, <a href="types/slice.html">슬라이스</a>).</li>
</ul>
<p>r[type.name.path]</p>
<ul>
<li>다음을 참조할 수 있는 <a href="paths.html#paths-in-types">타입 경로</a>:
<ul>
<li>기본 타입 (<a href="types/boolean.html">불리언</a>, <a href="types/numeric.html">숫자</a>, <a href="types/textual.html">텍스트</a>).</li>
<li><a href="items.html">아이템</a>으로의 경로 (<a href="types/struct.html">구조체</a>, <a href="types/enum.html">열거형</a>, <a href="types/union.html">공용체</a>, <a href="items/type-aliases.html">타입 별칭</a>, <a href="types/trait-object.html">트레잇</a>).</li>
<li><code>Self</code>가 구현 타입인 <a href="paths.html#self-1"><code>Self</code> 경로</a>.</li>
<li>제네릭 <a href="types/parameters.html">타입 파라미터</a>.</li>
</ul>
</li>
</ul>
<p>r[type.name.pointer]</p>
<ul>
<li>포인터 타입 (<a href="types/pointer.html#shared-references-">참조</a>, <a href="types/pointer.html#raw-pointers-const-and-mut">원시 포인터</a>, <a href="types/function-pointer.html">함수 포인터</a>).</li>
</ul>
<p>r[type.name.inference]</p>
<ul>
<li>컴파일러에게 타입을 결정하도록 요청하는 <a href="types/inferred.html">추론된 타입</a>.</li>
</ul>
<p>r[type.name.grouped]</p>
<ul>
<li>모호성을 제거하기 위해 사용되는 <a href="types.html#parenthesized-types">괄호</a>.</li>
</ul>
<p>r[type.name.trait]</p>
<ul>
<li>트레잇 타입: <a href="types/trait-object.html">트레잇 객체</a> 및 <a href="types/impl-trait.html">impl 트레잇</a>.</li>
</ul>
<p>r[type.name.never]</p>
<ul>
<li><a href="types/never.html">네버</a> 타입.</li>
</ul>
<p>r[type.name.macro-expansion]</p>
<ul>
<li>타입 표현식으로 확장되는 <a href="macros.html">매크로</a>.</li>
</ul>
<p>r[type.name.parenthesized]</p>
<h3 id="괄호로-둘러싸인-타입"><a class="header" href="#괄호로-둘러싸인-타입">괄호로 둘러싸인 타입</a></h3>
<p>r[type.name.parenthesized.syntax]</p>
<pre><code class="language-grammar types">ParenthesizedType -&gt; `(` Type `)`
</code></pre>
<p>r[type.name.parenthesized.intro] In some situations the combination of types may be ambiguous. Use parentheses around a type to avoid ambiguity. For example, the <code>+</code> operator for <a href="trait-bounds.html">type boundaries</a> within a <a href="types/pointer.html#shared-references-">reference type</a> is unclear where the boundary applies, so the use of parentheses is required. Grammar rules that require this disambiguation use the [TypeNoBounds] rule instead of [Type][grammar-Type].</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::any::Any;
</span>type T&lt;'a&gt; = &amp;'a (dyn Any + Send);
<span class="boring">}</span></code></pre></pre>
<p>r[type.recursive]</p>
<h2 id="재귀적-타입"><a class="header" href="#재귀적-타입">재귀적 타입</a></h2>
<p>r[type.recursive.intro] Nominal types — <a href="types/struct.html">structs</a>, <a href="types/enum.html">enumerations</a>, and <a href="types/union.html">unions</a> — may be recursive. That is, each <code>enum</code> variant or <code>struct</code> or <code>union</code> field may refer, directly or indirectly, to the enclosing <code>enum</code> or <code>struct</code> type itself.</p>
<p>r[type.recursive.constraint] Such recursion has restrictions:</p>
<ul>
<li>재귀적 타입은 재귀 과정에 반드시 명목적 타입을 포함해야 합니다(단순한 <a href="items/type-aliases.html">타입 별칭</a>이나 <a href="types/array.html">배열</a>, <a href="types/tuple.html">튜플</a>과 같은 다른 구조적 타입만으로는 안 됩니다). 따라서 <code>type Rec = &amp;'static [Rec]</code>은 허용되지 않습니다.</li>
<li>재귀적 타입의 크기는 유한해야 합니다. 다시 말해, 해당 타입의 재귀적 필드는 반드시 <a href="types/pointer.html">포인터 타입</a>이어야 합니다.</li>
</ul>
<p><em>재귀적</em> 타입과 그 사용 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum List&lt;T&gt; {
    Nil,
    Cons(T, Box&lt;List&lt;T&gt;&gt;)
}

let a: List&lt;i32&gt; = List::Cons(7, Box::new(List::Cons(13, Box::new(List::Nil))));
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p>r[type.bool]</p>
<h1 id="불리언-타입"><a class="header" href="#불리언-타입">불리언 타입</a></h1>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let b: bool = true;
<span class="boring">}</span></code></pre></pre>
<p>r[type.bool.intro] The <em>boolean type</em> or <em>bool</em> is a primitive data type that can take on one of two values, called <em>true</em> and <em>false</em>.</p>
<p>r[type.bool.literal] Values of this type may be created using a <a href="types/../expressions/literal-expr.html">literal expression</a> using the keywords <code>true</code> and <code>false</code> corresponding to the value of the same name.</p>
<p>r[type.bool.namespace] This type is a part of the <a href="types/../names/preludes.html#language-prelude">language prelude</a> with the <a href="types/../names.html">name</a> <code>bool</code>.</p>
<p>r[type.bool.layout] An object with the boolean type has a <a href="types/../type-layout.html#size-and-alignment">size and alignment</a> of 1 each.</p>
<p>r[type.bool.repr] The value false has the bit pattern <code>0x00</code> and the value true has the bit pattern <code>0x01</code>. It is <a href="types/../behavior-considered-undefined.html">undefined behavior</a> for an object with the boolean type to have any other bit pattern.</p>
<p>r[type.bool.usage] The boolean type is the type of many operands in various <a href="types/../expressions.html">expressions</a>:</p>
<p>r[type.bool.usage-condition]</p>
<ul>
<li><a href="types/../expressions/if-expr.html#if-expressions"><code>if</code> 표현식</a> 및 <a href="types/../expressions/loop-expr.html#predicate-loops"><code>while</code> 표현식</a>의 조건 피연산자</li>
</ul>
<p>r[type.bool.usage-lazy-operator]</p>
<ul>
<li><a href="types/../expressions/operator-expr.html#lazy-boolean-operators">지연 불리언 연산자 표현식</a>의 피연산자</li>
</ul>
<blockquote>
<p>[!NOTE] The boolean type acts similarly to but is not an <a href="types/enum.html">enumerated type</a>. In practice, this mostly means that constructors are not associated to the type (e.g. <code>bool::true</code>).</p>
</blockquote>
<p>r[type.bool.traits] Like all primitives, the boolean type <a href="types/../items/implementations.html">implements</a> the <a href="types/../items/traits.html">traits</a> <a href="types/../special-types-and-traits.html#clone"><code>Clone</code></a>, <a href="types/../special-types-and-traits.html#copy"><code>Copy</code></a>, <a href="types/../special-types-and-traits.html#sized"><code>Sized</code></a>, <a href="types/../special-types-and-traits.html#send"><code>Send</code></a>, and <a href="types/../special-types-and-traits.html#sync"><code>Sync</code></a>.</p>
<blockquote>
<p>[!NOTE] See the <a href="types/bool">standard library docs</a> for library operations.</p>
</blockquote>
<p>r[type.bool.expr]</p>
<h2 id="불리언-값에-대한-연산"><a class="header" href="#불리언-값에-대한-연산">불리언 값에 대한 연산</a></h2>
<p>When using certain operator expressions with a boolean type for its operands, they evaluate using the rules of <a href="https://en.wikipedia.org/wiki/Boolean_algebra">boolean logic</a>.</p>
<p>r[type.bool.expr.not]</p>
<h3 id="논리-부정-logical-not"><a class="header" href="#논리-부정-logical-not">논리 부정 (Logical not)</a></h3>
<div class="table-wrapper"><table><thead><tr><th><code>b</code></th><th><a href="types/../expressions/operator-expr.html#negation-operators"><code>!b</code></a></th></tr></thead><tbody>
<tr><td><code>true</code></td><td><code>false</code></td></tr>
<tr><td><code>false</code></td><td><code>true</code></td></tr>
</tbody></table>
</div>
<p>r[type.bool.expr.or]</p>
<h3 id="논리-합-logical-or"><a class="header" href="#논리-합-logical-or">논리 합 (Logical or)</a></h3>
<div class="table-wrapper"><table><thead><tr><th><code>a</code></th><th><code>b</code></th><th><a href="types/../expressions/operator-expr.html#arithmetic-and-logical-binary-operators"><code>a | b</code></a></th></tr></thead><tbody>
<tr><td><code>true</code></td><td><code>true</code></td><td><code>true</code></td></tr>
<tr><td><code>true</code></td><td><code>false</code></td><td><code>true</code></td></tr>
<tr><td><code>false</code></td><td><code>true</code></td><td><code>true</code></td></tr>
<tr><td><code>false</code></td><td><code>false</code></td><td><code>false</code></td></tr>
</tbody></table>
</div>
<p>r[type.bool.expr.and]</p>
<h3 id="논리-곱-logical-and"><a class="header" href="#논리-곱-logical-and">논리 곱 (Logical and)</a></h3>
<div class="table-wrapper"><table><thead><tr><th><code>a</code></th><th><code>b</code></th><th><a href="types/../expressions/operator-expr.html#arithmetic-and-logical-binary-operators"><code>a &amp; b</code></a></th></tr></thead><tbody>
<tr><td><code>true</code></td><td><code>true</code></td><td><code>true</code></td></tr>
<tr><td><code>true</code></td><td><code>false</code></td><td><code>false</code></td></tr>
<tr><td><code>false</code></td><td><code>true</code></td><td><code>false</code></td></tr>
<tr><td><code>false</code></td><td><code>false</code></td><td><code>false</code></td></tr>
</tbody></table>
</div>
<p>r[type.bool.expr.xor]</p>
<h3 id="논리-배타적-합-logical-xor"><a class="header" href="#논리-배타적-합-logical-xor">논리 배타적 합 (Logical xor)</a></h3>
<div class="table-wrapper"><table><thead><tr><th><code>a</code></th><th><code>b</code></th><th><a href="types/../expressions/operator-expr.html#arithmetic-and-logical-binary-operators"><code>a ^ b</code></a></th></tr></thead><tbody>
<tr><td><code>true</code></td><td><code>true</code></td><td><code>false</code></td></tr>
<tr><td><code>true</code></td><td><code>false</code></td><td><code>true</code></td></tr>
<tr><td><code>false</code></td><td><code>true</code></td><td><code>true</code></td></tr>
<tr><td><code>false</code></td><td><code>false</code></td><td><code>false</code></td></tr>
</tbody></table>
</div>
<p>r[type.bool.expr.cmp]</p>
<h3 id="비교"><a class="header" href="#비교">비교</a></h3>
<p>r[type.bool.expr.cmp.eq]</p>
<div class="table-wrapper"><table><thead><tr><th><code>a</code></th><th><code>b</code></th><th><a href="types/../expressions/operator-expr.html#comparison-operators"><code>a == b</code></a></th></tr></thead><tbody>
<tr><td><code>true</code></td><td><code>true</code></td><td><code>true</code></td></tr>
<tr><td><code>true</code></td><td><code>false</code></td><td><code>false</code></td></tr>
<tr><td><code>false</code></td><td><code>true</code></td><td><code>false</code></td></tr>
<tr><td><code>false</code></td><td><code>false</code></td><td><code>true</code></td></tr>
</tbody></table>
</div>
<p>r[type.bool.expr.cmp.greater]</p>
<div class="table-wrapper"><table><thead><tr><th><code>a</code></th><th><code>b</code></th><th><a href="types/../expressions/operator-expr.html#comparison-operators"><code>a &gt; b</code></a></th></tr></thead><tbody>
<tr><td><code>true</code></td><td><code>true</code></td><td><code>false</code></td></tr>
<tr><td><code>true</code></td><td><code>false</code></td><td><code>true</code></td></tr>
<tr><td><code>false</code></td><td><code>true</code></td><td><code>false</code></td></tr>
<tr><td><code>false</code></td><td><code>false</code></td><td><code>false</code></td></tr>
</tbody></table>
</div>
<p>r[type.bool.expr.cmp.not-eq]</p>
<ul>
<li><code>a != b</code>는 <code>!(a == b)</code>와 동일합니다</li>
</ul>
<p>r[type.bool.expr.cmp.greater-eq]</p>
<ul>
<li><code>a &gt;= b</code>는 <code>a == b | a &gt; b</code>와 동일합니다</li>
</ul>
<p>r[type.bool.expr.cmp.less]</p>
<ul>
<li><code>a &lt; b</code>는 <code>!(a &gt;= b)</code>와 동일합니다</li>
</ul>
<p>r[type.bool.expr.cmp.less-eq]</p>
<ul>
<li><code>a &lt;= b</code>는 <code>a == b | a &lt; b</code>와 동일합니다</li>
</ul>
<p>r[type.bool.validity]</p>
<h2 id="비트-유효성"><a class="header" href="#비트-유효성">비트 유효성</a></h2>
<p><code>bool</code>의 단일 바이트는 초기화됨이 보장됩니다 (다시 말해, <code>transmute::&lt;bool, u8&gt;(...)</code>는 항상 안전(sound)합니다. 하지만 일부 비트 패턴은 유효하지 않은 <code>bool</code> 값이므로, 그 역은 항상 안전하지는 않습니다).</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[type.numeric]</p>
<h1 id="숫자-타입"><a class="header" href="#숫자-타입">숫자 타입</a></h1>
<p>r[type.numeric.int]</p>
<h2 id="정수-타입"><a class="header" href="#정수-타입">정수 타입</a></h2>
<p>r[type.numeric.int.unsigned] The unsigned integer types consist of:</p>
<div class="table-wrapper"><table><thead><tr><th>유형</th><th>최소값</th><th>최대값</th></tr></thead><tbody>
<tr><td><code>u8</code></td><td>0</td><td>2<sup>8</sup>-1</td></tr>
<tr><td><code>u16</code></td><td>0</td><td>2<sup>16</sup>-1</td></tr>
<tr><td><code>u32</code></td><td>0</td><td>2<sup>32</sup>-1</td></tr>
<tr><td><code>u64</code></td><td>0</td><td>2<sup>64</sup>-1</td></tr>
<tr><td><code>u128</code></td><td>0</td><td>2<sup>128</sup>-1</td></tr>
</tbody></table>
</div>
<p>r[type.numeric.int.signed] The signed two’s complement integer types consist of:</p>
<div class="table-wrapper"><table><thead><tr><th>유형</th><th>최소값</th><th>최대값</th></tr></thead><tbody>
<tr><td><code>i8</code></td><td>-(2<sup>7</sup>)</td><td>2<sup>7</sup>-1</td></tr>
<tr><td><code>i16</code></td><td>-(2<sup>15</sup>)</td><td>2<sup>15</sup>-1</td></tr>
<tr><td><code>i32</code></td><td>-(2<sup>31</sup>)</td><td>2<sup>31</sup>-1</td></tr>
<tr><td><code>i64</code></td><td>-(2<sup>63</sup>)</td><td>2<sup>63</sup>-1</td></tr>
<tr><td><code>i128</code></td><td>-(2<sup>127</sup>)</td><td>2<sup>127</sup>-1</td></tr>
</tbody></table>
</div>
<p>r[type.numeric.float]</p>
<h2 id="부동-소수점-타입"><a class="header" href="#부동-소수점-타입">부동 소수점 타입</a></h2>
<p>IEEE 754-2008 “binary32” 및 “binary64” 부동 소수점 타입은 각각 <code>f32</code>와 <code>f64</code>입니다.</p>
<p>r[type.numeric.int.size]</p>
<h2 id="머신-의존적-정수-타입"><a class="header" href="#머신-의존적-정수-타입">머신 의존적 정수 타입</a></h2>
<p>r[type.numeric.int.size.usize] The <code>usize</code> type is an unsigned integer type with the same number of bits as the platform’s pointer type. It can represent every memory address in the process.</p>
<blockquote>
<p>[!NOTE] While a <code>usize</code> can represent every <em>address</em>, converting a <em>pointer</em> to a <code>usize</code> is not necessarily a reversible operation. For more information, see the documentation for <a href="types/../expressions/operator-expr.html#type-cast-expressions">type cast expressions</a>, [<code>std::ptr</code>], and [provenance][std::ptr#provenance] in particular.</p>
</blockquote>
<p>r[type.numeric.int.size.isize] The <code>isize</code> type is a signed two’s complement integer type with the same number of bits as the platform’s pointer type. The theoretical upper bound on object and array size is the maximum <code>isize</code> value. This ensures that <code>isize</code> can be used to calculate differences between pointers into an object or array and can address every byte within an object along with one byte past the end.</p>
<p>r[type.numeric.int.size.minimum] <code>usize</code> and <code>isize</code> are at least 16-bits wide.</p>
<blockquote>
<p>[!NOTE] Many pieces of Rust code may assume that pointers, <code>usize</code>, and <code>isize</code> are either 32-bit or 64-bit. As a consequence, 16-bit pointer support is limited and may require explicit care and acknowledgment from a library to support.</p>
</blockquote>
<p>r[type.numeric.validity]</p>
<h2 id="비트-유효성-1"><a class="header" href="#비트-유효성-1">비트 유효성</a></h2>
<p>모든 숫자 타입 <code>T</code>에 대해, <code>T</code>의 비트 유효성은 <code>[u8; size_of::&lt;T&gt;()]</code>의 비트 유효성과 동일합니다. 초기화되지 않은 바이트는 유효한 <code>u8</code>이 아닙니다.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[type.text]</p>
<h1 id="텍스트-타입"><a class="header" href="#텍스트-타입">텍스트 타입</a></h1>
<p>r[type.text.intro] The types <code>char</code> and <code>str</code> hold textual data.</p>
<p>r[type.text.char-value] A value of type <code>char</code> is a <a href="http://www.unicode.org/glossary/#unicode_scalar_value">Unicode scalar value</a> (i.e. a code point that is not a surrogate), represented as a 32-bit unsigned word in the 0x0000 to 0xD7FF or 0xE000 to 0x10FFFF range.</p>
<p>r[type.text.char-precondition] It is immediate <a href="types/../behavior-considered-undefined.html">undefined behavior</a> to create a <code>char</code> that falls outside this range. A <code>[char]</code> is effectively a UCS-4 / UTF-32 string of length 1.</p>
<p>r[type.text.str-value] A value of type <code>str</code> is represented the same way as <code>[u8]</code>, a slice of 8-bit unsigned bytes. However, the Rust standard library makes extra assumptions about <code>str</code>: methods working on <code>str</code> assume and ensure that the data in there is valid UTF-8. Calling a <code>str</code> method with a non-UTF-8 buffer can cause <a href="types/../behavior-considered-undefined.html">undefined behavior</a> now or in the future.</p>
<p>r[type.text.str-unsized] Since <code>str</code> is a <a href="types/../dynamically-sized-types.html">dynamically sized type</a>, it can only be instantiated through a pointer type, such as <code>&amp;str</code>. The layout of <code>&amp;str</code> is the same as the layout of <code>&amp;[u8]</code>.</p>
<p>r[type.text.layout]</p>
<h2 id="레이아웃-및-비트-유효성"><a class="header" href="#레이아웃-및-비트-유효성">레이아웃 및 비트 유효성</a></h2>
<p>r[type.layout.char-layout] <code>char</code> is guaranteed to have the same size and alignment as <code>u32</code> on all platforms.</p>
<p>r[type.layout.char-validity] Every byte of a <code>char</code> is guaranteed to be initialized (in other words, <code>transmute::&lt;char, [u8; size_of::&lt;char&gt;()]&gt;(...)</code> is always sound – but since some bit patterns are invalid <code>char</code>s, the inverse is not always sound).</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[type.never]</p>
<h1 id="결코-리턴하지-않는-타입"><a class="header" href="#결코-리턴하지-않는-타입">결코 리턴하지 않는 타입</a></h1>
<p>r[type.never.syntax]</p>
<pre><code class="language-grammar types">NeverType -&gt; `!`
</code></pre>
<p>r[type.never.intro] The never type <code>!</code> is a type with no values, representing the result of computations that never complete.</p>
<p>r[type.never.coercion] Expressions of type <code>!</code> can be coerced into any other type.</p>
<p>r[type.never.constraint] The <code>!</code> type can <strong>only</strong> appear in function return types presently, indicating it is a diverging function that never returns.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() -&gt; ! {
    panic!("이 호출은 결코 반환되지 않습니다.");
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe extern "C" {
    pub safe fn no_return_extern_func() -&gt; !;
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p>r[type.tuple]</p>
<h1 id="튜플-타입"><a class="header" href="#튜플-타입">튜플 타입</a></h1>
<p>r[type.tuple.syntax]</p>
<pre><code class="language-grammar types">TupleType -&gt;
      `(` `)`
    | `(` ( Type `,` )+ Type? `)`
</code></pre>
<p>r[type.tuple.intro] <em>Tuple types</em> are a family of structural types<sup class="footnote-reference"><a href="#1">1</a></sup> for heterogeneous lists of other types.</p>
<p>튜플 타입의 구문은 괄호로 둘러싸인, 쉼표로 구분된 타입 목록입니다.</p>
<p>r[type.tuple.restriction] 1-ary tuples require a comma after their element type to be disambiguated with a <a href="types/../types.html#parenthesized-types">parenthesized type</a>.</p>
<p>r[type.tuple.field-number] A tuple type has a number of fields equal to the length of the list of types. This number of fields determines the <em>arity</em> of the tuple. A tuple with <code>n</code> fields is called an <em>n-ary tuple</em>. For example, a tuple with 2 fields is a 2-ary tuple.</p>
<p>r[type.tuple.field-name] Fields of tuples are named using increasing numeric names matching their position in the list of types. The first field is <code>0</code>. The second field is <code>1</code>. And so on. The type of each field is the type of the same position in the tuple’s list of types.</p>
<p>r[type.tuple.unit] For convenience and historical reasons, the tuple type with no fields (<code>()</code>) is often called <em>unit</em> or <em>the unit type</em>. Its one value is also called <em>unit</em> or <em>the unit value</em>.</p>
<p>튜플 타입의 몇 가지 예시:</p>
<ul>
<li><code>()</code> (유닛)</li>
<li><code>(i32,)</code> (1-항 튜플)</li>
<li><code>(f64, f64)</code></li>
<li><code>(String, i32)</code></li>
<li><code>(i32, String)</code> (이전 예시와는 다른 타입임)</li>
<li><code>(i32, f64, Vec&lt;String&gt;, Option&lt;bool&gt;)</code></li>
</ul>
<p>r[type.tuple.constructor] Values of this type are constructed using a <a href="types/../expressions/tuple-expr.html#tuple-expressions">tuple expression</a>. Furthermore, various expressions will produce the unit value if there is no other meaningful value for it to evaluate to.</p>
<p>r[type.tuple.access] Tuple fields can be accessed by either a <a href="types/../expressions/tuple-expr.html#tuple-indexing-expressions">tuple index expression</a> or <a href="types/../patterns.html#tuple-patterns">pattern matching</a>.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>구조적 타입은 내부 타입들이 동일하면 항상 동일한 것으로 간주됩니다. 튜플의 명목적 버전(nominal version)에 대해서는 <a href="types/./struct.html">튜플 구조체</a>를 참조하십시오.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><p>r[type.array]</p>
<h1 id="배열-타입"><a class="header" href="#배열-타입">배열 타입</a></h1>
<p>r[type.array.syntax]</p>
<pre><code class="language-grammar types">ArrayType -&gt; `[` Type `;` Expression `]`
</code></pre>
<p>r[type.array.intro] An array is a fixed-size sequence of <code>N</code> elements of type <code>T</code>. The array type is written as <code>[T; N]</code>.</p>
<p>r[type.array.constraint] The size is a <a href="types/../const_eval.html#constant-expressions">constant expression</a> that evaluates to a <a href="types/numeric.html#machine-dependent-integer-types"><code>usize</code></a>.</p>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 스택에 할당된 배열
let array: [i32; 3] = [1, 2, 3];

// 힙에 할당된 배열, 슬라이스로 강제 변환됨
let boxed_array: Box&lt;[i32]&gt; = Box::new([1, 2, 3]);
<span class="boring">}</span></code></pre></pre>
<p>r[type.array.index] All elements of arrays are always initialized, and access to an array is always bounds-checked in safe methods and operators.</p>
<blockquote>
<p>[!NOTE] The [<code>Vec&lt;T&gt;</code>] standard library type provides a heap-allocated resizable array type.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>r[type.slice]</p>
<h1 id="슬라이스-타입"><a class="header" href="#슬라이스-타입">슬라이스 타입</a></h1>
<p>r[type.slice.syntax]</p>
<pre><code class="language-grammar types">SliceType -&gt; `[` Type `]`
</code></pre>
<p>r[type.slice.intro] A slice is a <a href="types/../dynamically-sized-types.html">dynamically sized type</a> representing a ‘view’ into a sequence of elements of type <code>T</code>. The slice type is written as <code>[T]</code>.</p>
<p>r[type.slice.unsized] Slice types are generally used through pointer types. For example:</p>
<ul>
<li><code>&amp;[T]</code>: ’공유 슬라이스’로, 흔히 그냥 ’슬라이스’라고 불립니다. 가리키는 데이터를 소유하지 않고 차용합니다.</li>
<li><code>&amp;mut [T]</code>: ’가변 슬라이스’입니다. 가리키는 데이터를 가변적으로 차용합니다.</li>
<li><code>Box&lt;[T]&gt;</code>: ‘박스드 슬라이스(boxed slice)’</li>
</ul>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 힙에 할당된 배열, 슬라이스로 강제 변환됨
let boxed_array: Box&lt;[i32]&gt; = Box::new([1, 2, 3]);

// 배열에 대한 (공유) 슬라이스
let slice: &amp;[i32] = &amp;boxed_array[..];
<span class="boring">}</span></code></pre></pre>
<p>r[type.slice.safe] All elements of slices are always initialized, and access to a slice is always bounds-checked in safe methods and operators.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[type.struct]</p>
<h1 id="구조체-타입"><a class="header" href="#구조체-타입">구조체 타입</a></h1>
<p>r[type.struct.intro] A <code>struct</code> <em>type</em> is a heterogeneous product of other types, called the <em>fields</em> of the type.<sup class="footnote-reference"><a href="#structtype">1</a></sup></p>
<p>r[type.struct.constructor] New instances of a <code>struct</code> can be constructed with a <a href="types/../expressions/struct-expr.html">struct expression</a>.</p>
<p>r[type.struct.layout] The memory layout of a <code>struct</code> is undefined by default to allow for compiler optimizations like field reordering, but it can be fixed with the <a href="types/../type-layout.html#representations"><code>repr</code> attribute</a>. In either case, fields may be given in any order in a corresponding struct <em>expression</em>; the resulting <code>struct</code> value will always have the same memory layout.</p>
<p>r[type.struct.field-visibility] The fields of a <code>struct</code> may be qualified by <a href="types/../visibility-and-privacy.html">visibility modifiers</a>, to allow access to data in a struct outside a module.</p>
<p>r[type.struct.tuple] A <em>tuple struct</em> type is just like a struct type, except that the fields are anonymous.</p>
<p>r[type.struct.unit] A <em>unit-like struct</em> type is like a struct type, except that it has no fields. The one value constructed by the associated <a href="types/../expressions/struct-expr.html">struct expression</a> is the only value that inhabits such a type.</p>
<div class="footnote-definition" id="structtype"><sup class="footnote-definition-label">1</sup>
<p><code>struct</code> 타입은 C의 <code>struct</code> 타입, ML 언어군의 <em>레코드(record)</em> 타입, 또는 Lisp 언어군의 <em>struct</em> 타입과 유사합니다.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><p>r[type.enum]</p>
<h1 id="열거-타입"><a class="header" href="#열거-타입">열거 타입</a></h1>
<p>r[type.enum.intro] An <em>enumerated type</em> is a nominal, heterogeneous disjoint union type, denoted by the name of an <a href="types/../items/enumerations.html"><code>enum</code> item</a>. <sup class="footnote-reference"><a href="#enumtype">1</a></sup></p>
<p>r[type.enum.declaration] An <a href="types/../items/enumerations.html"><code>enum</code> item</a> declares both the type and a number of <em>variants</em>, each of which is independently named and has the syntax of a struct, tuple struct or unit-like struct.</p>
<p>r[type.enum.constructor] New instances of an <code>enum</code> can be constructed with a <a href="types/../expressions/struct-expr.html">struct expression</a>.</p>
<p>r[type.enum.value] Any <code>enum</code> value consumes as much memory as the largest variant for its corresponding <code>enum</code> type, as well as the size needed to store a discriminant.</p>
<p>r[type.enum.name] Enum types cannot be denoted <em>structurally</em> as types, but must be denoted by named reference to an <a href="types/../items/enumerations.html"><code>enum</code> item</a>.</p>
<div class="footnote-definition" id="enumtype"><sup class="footnote-definition-label">1</sup>
<p><code>enum</code> 타입은 Haskell의 <code>data</code> 생성자 선언이나 Limbo의 _pick ADT_와 유사합니다.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><p>r[type.union]</p>
<h1 id="공용체-타입"><a class="header" href="#공용체-타입">공용체 타입</a></h1>
<p>r[type.union.intro] A <em>union type</em> is a nominal, heterogeneous C-like union, denoted by the name of a <a href="types/../items/unions.html"><code>union</code> item</a>.</p>
<p>r[type.union.access] Unions have no notion of an “active field”. Instead, every union access transmutes parts of the content of the union to the type of the accessed field.</p>
<p>r[type.union.safety] Since transmutes can cause unexpected or undefined behaviour, <code>unsafe</code> is required to read from a union field.</p>
<p>r[type.union.constraint] Union field types are also restricted to a subset of types which ensures that they never need dropping. See the <a href="types/../items/unions.html">item</a> documentation for further details.</p>
<p>r[type.union.layout] The memory layout of a <code>union</code> is undefined by default (in particular, fields do <em>not</em> have to be at offset 0), but the <code>#[repr(...)]</code> attribute can be used to fix a layout.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[type.fn-item]</p>
<h1 id="함수-아이템-타입"><a class="header" href="#함수-아이템-타입">함수 아이템 타입</a></h1>
<p>r[type.fn-item.intro] When referred to, a function item, or the constructor of a tuple-like struct or enum variant, yields a zero-sized value of its <em>function item type</em>.</p>
<p>r[type.fn-item.unique] That type explicitly identifies the function - its name, its type arguments, and its early-bound lifetime arguments (but not its late-bound lifetime arguments, which are only assigned when the function is called) - so the value does not need to contain an actual function pointer, and no indirection is needed when the function is called.</p>
<p>r[type.fn-item.name] There is no syntax that directly refers to a function item type, but the compiler will display the type as something like <code>fn(u32) -&gt; i32 {fn_name}</code> in error messages.</p>
<p>함수 아이템 타입은 함수를 명시적으로 식별하기 때문에, 서로 다른 함수(서로 다른 아이템, 또는 제네릭이 다른 동일 아이템)의 아이템 타입은 구별되며, 이들을 혼합하면 타입 오류가 발생합니다:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0308 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T&gt;() { }
let x = &amp;mut foo::&lt;i32&gt;;
*x = foo::&lt;u32&gt;; //~ ERROR 타입 불일치
<span class="boring">}</span></code></pre></pre>
<p>r[type.fn-item.coercion] However, there is a <a href="types/../type-coercions.html">coercion</a> from function items to <a href="types/function-pointer.html">function pointers</a> with the same signature, which is triggered not only when a function item is used when a function pointer is directly expected, but also when different function item types with the same signature meet in different arms of the same <code>if</code> or <code>match</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let want_i32 = false;
</span><span class="boring">fn foo&lt;T&gt;() { }
</span>
// 여기서 `foo_ptr_1`은 함수 포인터 타입 `fn()`을 가집니다
let foo_ptr_1: fn() = foo::&lt;i32&gt;;

// ... `foo_ptr_2`도 마찬가지입니다 - 이 코드는 타입 검사를 통과합니다.
let foo_ptr_2 = if want_i32 {
    foo::&lt;i32&gt;
} else {
    foo::&lt;u32&gt;
};
<span class="boring">}</span></code></pre></pre>
<p>r[type.fn-item.traits] All function items implement <a href="types/../special-types-and-traits.html#copy"><code>Copy</code></a>, <a href="types/../special-types-and-traits.html#clone"><code>Clone</code></a>, <a href="types/../special-types-and-traits.html#send"><code>Send</code></a>, and <a href="types/../special-types-and-traits.html#sync"><code>Sync</code></a>.</p>
<p>[<code>Fn</code>], [<code>FnMut</code>], and [<code>FnOnce</code>] are implemented unless the function has any of the following:</p>
<ul>
<li>an [<code>unsafe</code>][unsafe.fn] qualifier</li>
<li>a [<code>target_feature</code> attribute][attributes.codegen.target_feature]</li>
<li>an [ABI][items.fn.extern] other than <code>"Rust"</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>r[type.closure]</p>
<h1 id="클로저-타입"><a class="header" href="#클로저-타입">클로저 타입</a></h1>
<p>r[type.closure.intro] A <a href="types/../expressions/closure-expr.html">closure expression</a> produces a closure value with a unique, anonymous type that cannot be written out. A closure type is approximately equivalent to a struct which contains the captured values. For instance, the following closure:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct Point { x: i32, y: i32 }
struct Rectangle { left_top: Point, right_bottom: Point }

fn f&lt;F : FnOnce() -&gt; String&gt; (g: F) {
    println!("{}", g());
}

let mut rect = Rectangle {
    left_top: Point { x: 1, y: 1 },
    right_bottom: Point { x: 0, y: 0 }
};

let c = || {
    rect.left_top.x += 1;
    rect.right_bottom.x += 1;
    format!("{:?}", rect.left_top)
};
f(c); // "Point { x: 2, y: 1 }"을 출력합니다.
<span class="boring">}</span></code></pre></pre>
<p>대략 다음과 같은 클로저 타입을 생성합니다:</p>
<!-- ignore: simplified -->
<pre><code class="language-rust ignore">// 참고: 이것은 실제 번역되는 방식과 정확히 일치하지 않으며, 단지 설명을 위한 것입니다.

struct Closure&lt;'a&gt; {
    left_top : &amp;'a mut Point,
    right_bottom_x : &amp;'a mut i32,
}

impl&lt;'a&gt; FnOnce&lt;()&gt; for Closure&lt;'a&gt; {
    type Output = String;
    extern "rust-call" fn call_once(self, args: ()) -&gt; String {
        self.left_top.x += 1;
        *self.right_bottom_x += 1;
        format!("{:?}", self.left_top)
    }
}</code></pre>
<p>그리하여 <code>f</code>에 대한 호출이 다음과 같이 작동하도록 합니다:</p>
<!-- ignore: continuation of above -->
<pre><code class="language-rust ignore">f(Closure{ left_top: &amp;mut rect.left_top, right_bottom_x: &amp;mut rect.right_bottom.x });</code></pre>
<p>r[type.closure.capture]</p>
<h2 id="캡처-모드-1"><a class="header" href="#캡처-모드-1">캡처 모드</a></h2>
<p>r[type.closure.capture.intro] A <em>capture mode</em> determines how a <a href="types/../expressions.html#place-expressions-and-value-expressions">place expression</a> from the environment is borrowed or moved into the closure. The capture modes are:</p>
<ol>
<li>불변 차용 (<code>ImmBorrow</code>) — 장소 표현식이 <a href="types/pointer.html#references--and-mut">공유 참조</a>로 캡처됩니다.</li>
<li>고유 불변 차용 (<code>UniqueImmBorrow</code>) — 이는 불변 차용과 유사하지만, <a href="types/closure.html#unique-immutable-borrows-in-captures">아래</a>에 설명된 대로 고유해야 합니다.</li>
<li>가변 차용 (<code>MutBorrow</code>) — 장소 표현식이 <a href="types/pointer.html#mutable-references-mut">가변 참조</a>로 캡처됩니다.</li>
<li>이동 (<code>ByValue</code>) — <a href="types/../expressions.html#moved-and-copied-types">값을 이동</a>시켜서 장소 표현식을 캡처합니다.</li>
</ol>
<p>r[type.closure.capture.precedence] Place expressions from the environment are captured from the first mode that is compatible with how the captured value is used inside the closure body. The mode is not affected by the code surrounding the closure, such as the lifetimes of involved variables or fields, or of the closure itself.</p>
<p>r[type.closure.capture.copy]</p>
<h3 id="copy-값"><a class="header" href="#copy-값"><code>Copy</code> 값</a></h3>
<p>클로저 내부로 이동된 <a href="types/../special-types-and-traits.html#copy"><code>Copy</code></a>를 구현하는 값은 <code>ImmBorrow</code> 모드로 캡처됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = [0; 1024];
let c = || {
    let y = x; // x는 ImmBorrow로 캡처됨
};
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.async.input]</p>
<h3 id="비동기-입력-캡처"><a class="header" href="#비동기-입력-캡처">비동기 입력 캡처</a></h3>
<p>비동기 클로저는 본문에서 사용되는지 여부에 관계없이 항상 모든 입력 인자를 캡처합니다.</p>
<h2 id="capture-precision"><a class="header" href="#capture-precision">Capture precision</a></h2>
<p>r[type.closure.capture.precision.capture-path] A <em>capture path</em> is a sequence starting with a variable from the environment followed by zero or more place projections from that variable.</p>
<p>r[type.closure.capture.precision.place-projection] A <em>place projection</em> is a <a href="types/../expressions/field-expr.html">field access</a>, <a href="types/../expressions/tuple-expr.html#tuple-indexing-expressions">tuple index</a>, <a href="types/../expressions/operator-expr.html#the-dereference-operator">dereference</a> (and automatic dereferences), <a href="types/../expressions/array-expr.html#array-and-slice-indexing-expressions">array or slice index</a> expression, or <a href="types/patterns.destructure">pattern destructuring</a> applied to a variable.</p>
<blockquote>
<p>[!NOTE] In <code>rustc</code>, pattern destructuring desugars into a series of dereferences and field or element accesses.</p>
</blockquote>
<p>r[type.closure.capture.precision.intro] The closure borrows or moves the capture path, which may be truncated based on the rules described below.</p>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SomeStruct {
    f1: (i32, i32),
}
let s = SomeStruct { f1: (1, 2) };

let c = || {
    let x = s.f1.1; // s.f1.1은 ImmBorrow로 캡처됨
};
c();
<span class="boring">}</span></code></pre></pre>
<p>여기서 캡처 경로는 로컬 변수 <code>s</code>, 필드 접근 <code>.f1</code>, 그리고 튜플 인덱스 <code>.1</code>로 이어집니다. 이 클로저는 <code>s.f1.1</code>의 불변 차용을 캡처합니다.</p>
<p>r[type.closure.capture.precision.shared-prefix]</p>
<h3 id="공유-접두어"><a class="header" href="#공유-접두어">공유 접두어</a></h3>
<p>In the case where a capture path and one of the ancestors of that path are both captured by a closure, the ancestor path is captured with the highest capture mode among the two captures, <code>CaptureMode = max(AncestorCaptureMode, DescendantCaptureMode)</code>, using the strict weak ordering:</p>
<p><code>ImmBorrow &lt; UniqueImmBorrow &lt; MutBorrow &lt; ByValue</code></p>
<p>이는 재귀적으로 적용되어야 할 수도 있음에 유의하십시오.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 이 예시에서, 공유된 조상을 가진 세 가지 서로 다른 캡처 경로가 있습니다:
<span class="boring">fn move_value&lt;T&gt;(_: T){}
</span>let s = String::from("S");
let t = (s, String::from("T"));
let mut u = (t, String::from("U"));

let c = || {
    println!("{:?}", u); // u는 ImmBorrow로 캡처됨
    u.1.truncate(0); // u.0은 MutBorrow로 캡처됨
    move_value(u.0.0); // u.0.0은 ByValue로 캡처됨
};
c();
<span class="boring">}</span></code></pre></pre>
<p>전체적으로 이 클로저는 <code>u</code>를 <code>ByValue</code>로 캡처하게 됩니다.</p>
<p>r[type.closure.capture.precision.dereference-shared]</p>
<h3 id="가장-오른쪽-공유-참조-자르기"><a class="header" href="#가장-오른쪽-공유-참조-자르기">가장 오른쪽 공유 참조 자르기</a></h3>
<p>공유 참조에 대해 역참조가 적용되는 경우, 캡처 경로는 가장 오른쪽 역참조 지점에서 잘립니다.</p>
<p>이러한 자르기가 허용되는 이유는 공유 참조를 통해 읽는 필드는 항상 공유 참조나 복사를 통해 읽히기 때문입니다. 이는 추가적인 정밀도가 차용 검사 관점에서 아무런 이득을 주지 않을 때 캡처 크기를 줄이는 데 도움이 됩니다.</p>
<p><em>가장 오른쪽</em> 역참조인 이유는 필요 이상으로 짧은 라이프타임을 피하기 위해서입니다. 다음 예시를 보십시오:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Int(i32);
struct B&lt;'a&gt;(&amp;'a i32);

struct MyStruct&lt;'a&gt; {
   a: &amp;'static Int,
   b: B&lt;'a&gt;,
}

fn foo&lt;'a, 'b&gt;(m: &amp;'a MyStruct&lt;'b&gt;) -&gt; impl FnMut() + 'static {
    let c = || drop(&amp;m.a.0);
    c
}
<span class="boring">}</span></code></pre></pre>
<p>만약 이것이 <code>m</code>을 캡처한다면, <code>m</code>은 <code>'a</code>로 제한되어 있으므로 클로저는 더 이상 <code>'static</code>보다 오래 살 수 없게 됩니다. 대신, <code>(*(*m).a)</code>를 <code>ImmBorrow</code>로 캡처합니다.</p>
<p>r[type.closure.capture.precision.wildcard]</p>
<h3 id="와일드카드-패턴-바인딩"><a class="header" href="#와일드카드-패턴-바인딩">와일드카드 패턴 바인딩</a></h3>
<p>r[type.closure.capture.precision.wildcard.reads] Closures only capture data that needs to be read. Binding a value with a <a href="types/../patterns.html#wildcard-pattern">wildcard pattern</a> does not read the value, so the place is not captured.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S; // A non-`Copy` type.
let x = S;
let c = || {
    let _ = x;  // Does not capture `x`.
};
let c = || match x {
    _ =&gt; (), // Does not capture `x`.
};
x; // OK: `x` can be moved here.
c();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.wildcard.destructuring] Destructuring tuples, structs, and single-variant enums does not, by itself, cause a read or the place to be captured.</p>
<blockquote>
<p>[!NOTE] Enums marked with [<code>#[non_exhaustive]</code>][attributes.type-system.non_exhaustive] from other crates are always treated as having multiple variants. See <em>[type.closure.capture.precision.discriminants.non_exhaustive]</em>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S; // A non-`Copy` type.

// Destructuring tuples does not cause a read or capture.
let x = (S,);
let c = || {
    let (..) = x; // Does not capture `x`.
};
x; // OK: `x` can be moved here.
c();

// Destructuring unit structs does not cause a read or capture.
let x = S;
let c = || {
    let S = x; // Does not capture `x`.
};
x; // OK: `x` can be moved here.
c();

// Destructuring structs does not cause a read or capture.
struct W&lt;T&gt;(T);
let x = W(S);
let c = || {
    let W(..) = x; // Does not capture `x`.
};
x; // OK: `x` can be moved here.
c();

// Destructuring single-variant enums does not cause a read
// or capture.
enum E&lt;T&gt; { V(T) }
let x = E::V(S);
let c = || {
    let E::V(..) = x; // Does not capture `x`.
};
x; // OK: `x` can be moved here.
c();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.wildcard.fields] Fields matched against [RestPattern] (<code>..</code>) or [StructPatternEtCetera] (also <code>..</code>) are not read, and those fields are not captured.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S; // A non-`Copy` type.
let x = (S, S);
let c = || {
    let (x0, ..) = x;  // Captures `x.0` by `ByValue`.
};
// Only the first tuple field was captured by the closure.
x.1; // OK: `x.1` can be moved here.
c();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.wildcard.array-slice] Partial captures of arrays and slices are not supported; the entire slice or array is always captured even if used with wildcard pattern matching, indexing, or sub-slicing.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0382 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S; // A non-`Copy` type.
let mut x = [S, S];
let c = || {
    let [x0, _] = x; // Captures all of `x` by `ByValue`.
};
let _ = &amp;mut x[1]; // ERROR: Borrow of moved value.
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.wildcard.initialized] Values that are matched with wildcards must still be initialized.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0381 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: u8;
let c = || {
    let _ = x; // ERROR: Binding `x` isn't initialized.
};
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.discriminants]</p>
<h3 id="capturing-for-discriminant-reads"><a class="header" href="#capturing-for-discriminant-reads">Capturing for discriminant reads</a></h3>
<p>r[type.closure.capture.precision.discriminants.reads] If pattern matching reads a discriminant, the place containing that discriminant is captured by <code>ImmBorrow</code>.</p>
<p>r[type.closure.capture.precision.discriminants.multiple-variant] Matching against a variant of an enum that has more than one variant reads the discriminant, capturing the place by <code>ImmBorrow</code>.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0502 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S; // A non-`Copy` type.
let mut x = (Some(S), S);
let c = || match x {
    (None, _) =&gt; (),
//   ^^^^
// This pattern requires reading the discriminant, which
// causes `x.0` to be captured by `ImmBorrow`.
    _ =&gt; (),
};
let _ = &amp;mut x.0; // ERROR: Cannot borrow `x.0` as mutable.
//           ^^^
// The closure is still live, so `x.0` is still immutably
// borrowed here.
c();
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct S; // A non-`Copy` type.
</span><span class="boring">let x = (Some(S), S);
</span>let c = || match x { // Captures `x.0` by `ImmBorrow`.
    (None, _) =&gt; (),
    _ =&gt; (),
};
// Though `x.0` is captured due to the discriminant read,
// `x.1` is not captured.
x.1; // OK: `x.1` can be moved here.
c();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.discriminants.single-variant] Matching against the only variant of a single-variant enum does not read the discriminant and does not capture the place.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum E&lt;T&gt; { V(T) } // A single-variant enum.
let x = E::V(());
let c = || {
    let E::V(_) = x; // Does not capture `x`.
};
x; // OK: `x` can be moved here.
c();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.discriminants.non_exhaustive] If [<code>#[non_exhaustive]</code>][attributes.type-system.non_exhaustive] is applied to an enum defined in an external crate, the enum is treated as having multiple variants for the purpose of deciding whether a read occurs, even if it actually has only one variant.</p>
<p>r[type.closure.capture.precision.discriminants.uninhabited-variants] Even if all variants but the one being matched against are uninhabited, making the pattern [irrefutable][patterns.refutable], the discriminant is still read if it otherwise would be.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0502 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Empty {}
let mut x = Ok::&lt;_, Empty&gt;(42);
let c = || {
    let Ok(_) = x; // Captures `x` by `ImmBorrow`.
};
let _ = &amp;mut x; // ERROR: Cannot borrow `x` as mutable.
c();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.range-patterns]</p>
<h3 id="capturing-and-range-patterns"><a class="header" href="#capturing-and-range-patterns">Capturing and range patterns</a></h3>
<p>r[type.closure.capture.precision.range-patterns.reads] Matching against a [range pattern][patterns.range] reads the place being matched, even if the range includes all possible values of the type, and captures the place by <code>ImmBorrow</code>.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0502 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 0u8;
let c = || {
    let 0..=u8::MAX = x; // Captures `x` by `ImmBorrow`.
};
let _ = &amp;mut x; // ERROR: Cannot borrow `x` as mutable.
c();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.slice-patterns]</p>
<h3 id="capturing-and-slice-patterns"><a class="header" href="#capturing-and-slice-patterns">Capturing and slice patterns</a></h3>
<p>r[type.closure.capture.precision.slice-patterns.slices] Matching a slice against a [slice pattern][patterns.slice] other than one with only a single [rest pattern][patterns.rest] (i.e. <code>[..]</code>) is treated as a read of the length from the slice and captures the slice by <code>ImmBorrow</code>.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0502 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: &amp;mut [u8] = &amp;mut [];
let c = || match x { // Captures `*x` by `ImmBorrow`.
    &amp;mut [] =&gt; (),
//       ^^
// This matches a slice of exactly zero elements. To know whether the
// scrutinee matches, the length must be read, causing the slice to
// be captured.
    _ =&gt; (),
};
let _ = &amp;mut *x; // ERROR: Cannot borrow `*x` as mutable.
c();
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: &amp;mut [u8] = &amp;mut [];
let c = || match x { // Does not capture `*x`.
    [..] =&gt; (),
//   ^^ Rest pattern.
};
let _ = &amp;mut *x; // OK: `*x` can be borrow here.
c();
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] Perhaps surprisingly, even though the length is contained in the (wide) <em>pointer</em> to the slice, it is the place of the <em>pointee</em> (the slice) that is treated as read and is captured.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;'l: 's, 's&gt;(x: &amp;'s mut &amp;'l [u8]) -&gt; impl Fn() + 'l {
    // The closure outlives `'l` because it captures `**x`. If
    // instead it captured `*x`, it would not live long enough
    // to satisfy the `impl Fn() + 'l` bound.
    || match *x { // Captures `**x` by `ImmBorrow`.
        &amp;[] =&gt; (),
        _ =&gt; (),
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In this way, the behavior is consistent with dereferencing to the slice in the scrutinee.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;'l: 's, 's&gt;(x: &amp;'s mut &amp;'l [u8]) -&gt; impl Fn() + 'l {
    || match **x { // Captures `**x` by `ImmBorrow`.
        [] =&gt; (),
        _ =&gt; (),
    }
}
<span class="boring">}</span></code></pre></pre>
<p>For details, see <a href="https://github.com/rust-lang/rust/pull/138961">Rust PR #138961</a>.</p>
</blockquote>
<p>r[type.closure.capture.precision.slice-patterns.arrays] As the length of an array is fixed by its type, matching an array against a slice pattern does not by itself capture the place.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: [u8; 1] = [0];
let c = || match x { // Does not capture `x`.
    [_] =&gt; (), // Length is fixed.
};
x; // OK: `x` can be moved here.
c();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.move-dereference]</p>
<h3 id="이동-컨텍스트에서의-참조-캡처"><a class="header" href="#이동-컨텍스트에서의-참조-캡처">이동 컨텍스트에서의 참조 캡처</a></h3>
<p>참조에서 필드를 끄집어내어 이동하는 것은 허용되지 않으므로, <code>move</code> 클로저는 참조의 첫 번째 역참조 전까지의 캡처 경로 접두어만 캡처합니다. 참조 자체는 클로저 내부로 이동됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct T(String, String);

let mut t = T(String::from("foo"), String::from("bar"));
let t_mut_ref = &amp;mut t;
let mut c = move || {
    t_mut_ref.0.push_str("123"); // `t_mut_ref`를 ByValue로 캡처함
};
c();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.raw-pointer-dereference]</p>
<h3 id="원시-포인터-역참조"><a class="header" href="#원시-포인터-역참조">원시 포인터 역참조</a></h3>
<p>원시 포인터를 역참조하는 것은 <code>unsafe</code>하므로, 클로저는 원시 포인터의 첫 번째 역참조 전까지의 캡처 경로 접두어만 캡처합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct T(String, String);

let t = T(String::from("foo"), String::from("bar"));
let t_ptr = &amp;t as *const T;

let c = || unsafe {
    println!("{}", (*t_ptr).0); // `t_ptr`을 ImmBorrow로 캡처함
};
c();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.union]</p>
<h3 id="공용체-필드"><a class="header" href="#공용체-필드">공용체 필드</a></h3>
<p>공용체 필드에 접근하는 것은 <code>unsafe</code>하므로, 클로저는 공용체 자체까지만의 캡처 경로 접두어를 캡처합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>union U {
    a: (i32, i32),
    b: bool,
}
let u = U { a: (123, 456) };

let c = || {
    let x = unsafe { u.a.0 }; // `u`를 ByValue로 캡처함
};
c();

// 이는 필드에 쓰는 경우도 포함합니다.
let mut u = U { a: (123, 456) };

let mut c = || {
    u.b = true; // `u`를 MutBorrow로 캡처함
};
c();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.unaligned]</p>
<h3 id="정렬되지-않은-struct로의-참조"><a class="header" href="#정렬되지-않은-struct로의-참조">정렬되지 않은 <code>struct</code>로의 참조</a></h3>
<p>Because it is <a href="types/../behavior-considered-undefined.html">undefined behavior</a> to create references to unaligned fields in a structure, closures will only capture the prefix of the capture path that runs up to, but not including, the first field access into a structure that uses <a href="types/../type-layout.html#the-alignment-modifiers">the <code>packed</code> representation</a>. This includes all fields, even those that are aligned, to protect against compatibility concerns should any of the fields in the structure change in the future.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(packed)]
struct T(i32, i32);

let t = T(2, 5);
let c = || {
    let a = t.0; // `t`를 ImmBorrow로 캡처함
};
// `t`에서 복사하는 것은 괜찮습니다.
let (a, b) = (t.0, t.1);
c();
<span class="boring">}</span></code></pre></pre>
<p>마찬가지로, 정렬되지 않은 필드의 주소를 취하는 것도 구조체 전체를 캡처합니다:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0505 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(packed)]
struct T(String, String);

let mut t = T(String::new(), String::new());
let c = || {
    let a = std::ptr::addr_of!(t.1); // `t`를 ImmBorrow로 캡처함
};
let a = t.0; // ERROR: `t.0`이 차용되었으므로 이동할 수 없음
c();
<span class="boring">}</span></code></pre></pre>
<p>하지만 packed가 아니라면 필드를 정밀하게 캡처하므로 위 코드가 작동합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct T(String, String);

let mut t = T(String::new(), String::new());
let c = || {
    let a = std::ptr::addr_of!(t.1); // `t.1`을 ImmBorrow로 캡처함
};
// 여기서의 이동은 허용됩니다.
let a = t.0;
c();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.box-deref]</p>
<h3 id="box-대-다른-deref-구현체"><a class="header" href="#box-대-다른-deref-구현체"><code>Box</code> 대 다른 <code>Deref</code> 구현체</a></h3>
<p><code>Box</code>에 대한 <a href="types/../special-types-and-traits.html#deref-and-derefmut"><code>Deref</code></a> 트레잇 구현은 특별한 엔티티로 간주되어 다른 <code>Deref</code> 구현과 다르게 취급됩니다.</p>
<p>예를 들어, <code>Rc</code>와 <code>Box</code>가 포함된 예시를 보겠습니다. <code>*rc</code>는 <code>Rc</code>에 정의된 트레잇 메서드 <code>deref</code>의 호출로 디슈거링(desugar)되지만, <code>*box</code>는 다르게 취급되므로 <code>Box</code> 내부 콘텐츠의 정밀한 캡처가 가능합니다.</p>
<p>r[type.closure.capture.precision.box-non-move.not-moved]</p>
<h4 id="non-move-클로저에서의-box"><a class="header" href="#non-move-클로저에서의-box">non-<code>move</code> 클로저에서의 <code>Box</code></a></h4>
<p>non-<code>move</code> 클로저에서 <code>Box</code>의 내용물이 클로저 본문으로 이동되지 않는다면, <code>Box</code>의 내용물은 정밀하게 캡처됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S(String);

let b = Box::new(S(String::new()));
let c_box = || {
    let x = &amp;(*b).0; // `(*b).0`을 ImmBorrow로 캡처함
};
c_box();

// `Box`를 Deref를 구현하는 다른 타입과 비교해 보십시오:
let r = std::rc::Rc::new(S(String::new()));
let c_rc = || {
    let x = &amp;(*r).0; // `r`을 ImmBorrow로 캡처함
};
c_rc();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.box-non-move.moved] However, if the contents of the <code>Box</code> are moved into the closure, then the box is entirely captured. This is done so the amount of data that needs to be moved into the closure is minimized.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 클로저가 참조를 취하는 대신 값을 이동시킨다는 점을 제외하면 위 예시와 동일합니다.

struct S(String);

let b = Box::new(S(String::new()));
let c_box = || {
    let x = (*b).0; // `b`를 ByValue로 캡처함
};
c_box();
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.box-move.read]</p>
<h4 id="move-클로저에서의-box"><a class="header" href="#move-클로저에서의-box"><code>move</code> 클로저에서의 <code>Box</code></a></h4>
<p>non-<code>move</code> 클로저에서 <code>Box</code>의 내용을 이동시키는 것과 유사하게, <code>move</code> 클로저에서 <code>Box</code>의 내용을 읽는 것은 <code>Box</code> 전체를 캡처하게 됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S(i32);

let b = Box::new(S(10));
let c_box = move || {
    let x = (*b).0; // `b`를 ByValue로 캡처함
};
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.unique-immutable]</p>
<h2 id="캡처에서의-고유-불변-차용"><a class="header" href="#캡처에서의-고유-불변-차용">캡처에서의 고유 불변 차용</a></h2>
<p>캡처는 _고유 불변 차용(unique immutable borrow)_이라고 불리는 특수한 종류의 차용을 통해 발생할 수 있습니다. 이는 언어의 다른 어디에서도 사용될 수 없으며 명시적으로 작성할 수도 없습니다. 다음 예시와 같이 가변 참조의 대상(referent)을 수정할 때 발생합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut b = false;
let x = &amp;mut b;
let mut c = || {
    // `x`의 ImmBorrow 및 MutBorrow.
    let a = &amp;x;
    *x = true; // `x`는 UniqueImmBorrow로 캡처됨
};
// 다음 줄은 오류입니다:
// let y = &amp;x;
c();
// 그러나 다음은 괜찮습니다.
let z = &amp;x;
<span class="boring">}</span></code></pre></pre>
<p>In this case, borrowing <code>x</code> mutably is not possible, because <code>x</code> is not <code>mut</code>. But at the same time, borrowing <code>x</code> immutably would make the assignment illegal, because a <code>&amp; &amp;mut</code> reference might not be unique, so it cannot safely be used to modify a value. So a unique immutable borrow is used: it borrows <code>x</code> immutably, but like a mutable borrow, it must be unique.</p>
<p>위의 예시에서 <code>y</code>의 선언을 주석 해제하면 클로저의 <code>x</code> 차용에 대한 고유성을 위반하므로 오류가 발생합니다. z의 선언은 블록 끝에서 클로저의 라이프타임이 만료되어 차용이 해제되었으므로 유효합니다.</p>
<p>r[type.closure.call]</p>
<h2 id="호출-트레잇-및-강제-변환"><a class="header" href="#호출-트레잇-및-강제-변환">호출 트레잇 및 강제 변환</a></h2>
<p>r[type.closure.call.intro] Closure types all implement [<code>FnOnce</code>], indicating that they can be called once by consuming ownership of the closure. Additionally, some closures implement more specific call traits:</p>
<p>r[type.closure.call.fn-mut]</p>
<ul>
<li>A closure which does not move out of any captured variables implements [<code>FnMut</code>], indicating that it can be called by mutable reference.</li>
</ul>
<p>r[type.closure.call.fn]</p>
<ul>
<li>A closure which does not mutate or move out of any captured variables implements [<code>Fn</code>], indicating that it can be called by shared reference.</li>
</ul>
<blockquote>
<p>[!NOTE] <code>move</code> closures may still implement [<code>Fn</code>] or [<code>FnMut</code>], even though they capture variables by move. This is because the traits implemented by a closure type are determined by what the closure does with captured values, not how it captures them.</p>
</blockquote>
<p>r[type.closure.non-capturing] <em>Non-capturing closures</em> are closures that don’t capture anything from their environment. Non-async, non-capturing closures can be coerced to function pointers (e.g., <code>fn()</code>) with the matching signature.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let add = |x, y| x + y;

let mut x = add(5,7);

type Binop = fn(i32, i32) -&gt; i32;
let bo: Binop = add;
x = bo(5,7);
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.async.traits]</p>
<h3 id="비동기-클로저-트레잇"><a class="header" href="#비동기-클로저-트레잇">비동기 클로저 트레잇</a></h3>
<p>r[type.closure.async.traits.fn-family] Async closures have a further restriction of whether or not they implement [<code>FnMut</code>] or [<code>Fn</code>].</p>
<p>The [<code>Future</code>] returned by the async closure has similar capturing characteristics as a closure. It captures place expressions from the async closure based on how they are used. The async closure is said to be <em>lending</em> to its [<code>Future</code>] if it has either of the following properties:</p>
<ul>
<li><code>Future</code>가 가변 캡처를 포함하는 경우.</li>
<li>비동기 클로저가 값으로 캡처하는 경우 (단, 역참조 투영을 통해 값에 접근하는 경우는 제외).</li>
</ul>
<p>If the async closure is lending to its <code>Future</code>, then [<code>FnMut</code>] and [<code>Fn</code>] are <em>not</em> implemented. [<code>FnOnce</code>] is always implemented.</p>
<blockquote>
<p><strong>예시</strong>: 가변 캡처에 대한 첫 번째 조건은 다음과 같이 설명될 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn takes_callback&lt;Fut: Future&gt;(c: impl FnMut() -&gt; Fut) {}

fn f() {
    let mut x = 1i32;
    let c = async || {
        x = 2;  // x는 MutBorrow로 캡처됨
    };
    takes_callback(c);  // ERROR: 비동기 클로저가 `FnMut`를 구현하지 않음
}
<span class="boring">}</span></code></pre></pre>
<p>일반 값 캡처에 대한 두 번째 조건은 다음과 같이 설명될 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn takes_callback&lt;Fut: Future&gt;(c: impl Fn() -&gt; Fut) {}

fn f() {
    let x = &amp;1i32;
    let c = async move || {
        let a = x + 2;  // x는 ByValue로 캡처됨
    };
    takes_callback(c);  // ERROR: 비동기 클로저가 `Fn`을 구현하지 않음
}
<span class="boring">}</span></code></pre></pre>
<p>두 번째 조건의 예외는 역참조를 사용하여 설명될 수 있으며, 이 경우 <code>Fn</code> 및 <code>FnMut</code> 구현이 허용됩니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn takes_callback&lt;Fut: Future&gt;(c: impl Fn() -&gt; Fut) {}

fn f() {
    let x = &amp;1i32;
    let c = async move || {
        let a = *x + 2;
    };
    takes_callback(c);  // OK: `Fn`을 구현함
}
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[type.closure.async.traits.async-family] Async closures implement [<code>AsyncFn</code>], [<code>AsyncFnMut</code>], and [<code>AsyncFnOnce</code>] in an analogous way as regular closures implement [<code>Fn</code>], [<code>FnMut</code>], and [<code>FnOnce</code>]; that is, depending on the use of the captured variables in its body.</p>
<p>r[type.closure.traits]</p>
<h3 id="기타-트레잇"><a class="header" href="#기타-트레잇">기타 트레잇</a></h3>
<p>r[type.closure.traits.intro] All closure types implement <a href="types/../special-types-and-traits.html#sized"><code>Sized</code></a>. Additionally, closure types implement the following traits if allowed to do so by the types of the captures it stores:</p>
<ul>
<li><a href="types/../special-types-and-traits.html#clone"><code>Clone</code></a></li>
<li><a href="types/../special-types-and-traits.html#copy"><code>Copy</code></a></li>
<li><a href="types/../special-types-and-traits.html#sync"><code>Sync</code></a></li>
<li><a href="types/../special-types-and-traits.html#send"><code>Send</code></a></li>
</ul>
<p>r[type.closure.traits.behavior] The rules for <a href="types/../special-types-and-traits.html#send"><code>Send</code></a> and <a href="types/../special-types-and-traits.html#sync"><code>Sync</code></a> match those for normal struct types, while <a href="types/../special-types-and-traits.html#clone"><code>Clone</code></a> and <a href="types/../special-types-and-traits.html#copy"><code>Copy</code></a> behave as if <a href="types/../attributes/derive.html">derived</a>. For <a href="types/../special-types-and-traits.html#clone"><code>Clone</code></a>, the order of cloning of the captured values is left unspecified.</p>
<p>캡처는 종종 참조에 의해 발생하므로 다음과 같은 일반적인 규칙이 나타납니다:</p>
<ul>
<li>모든 캡처된 값이 <a href="types/../special-types-and-traits.html#sync"><code>Sync</code></a>이면 클로저는 <a href="types/../special-types-and-traits.html#sync"><code>Sync</code></a>입니다.</li>
<li>비고유 불변 참조로 캡처된 모든 값이 <a href="types/../special-types-and-traits.html#sync"><code>Sync</code></a>이고, 고유 불변 참조나 가변 참조, 복사 또는 이동으로 캡처된 모든 값이 <a href="types/../special-types-and-traits.html#send"><code>Send</code></a>이면 클로저는 <a href="types/../special-types-and-traits.html#send"><code>Send</code></a>입니다.</li>
<li>클로저가 고유 불변 참조나 가변 참조로 값을 캡처하지 않고, 복사나 이동으로 캡처하는 모든 값이 각각 <a href="types/../special-types-and-traits.html#clone"><code>Clone</code></a> 또는 <a href="types/../special-types-and-traits.html#copy"><code>Copy</code></a>이면 클로저는 <a href="types/../special-types-and-traits.html#clone"><code>Clone</code></a> 또는 <a href="types/../special-types-and-traits.html#copy"><code>Copy</code></a>입니다.</li>
</ul>
<p>r[type.closure.drop-order]</p>
<h2 id="drop-order"><a class="header" href="#drop-order">Drop order</a></h2>
<p>클로저가 구조체, 튜플, 열거형과 같은 복합 타입의 필드를 값으로 캡처하면, 해당 필드의 라이프타임은 이제 클로저에 묶이게 됩니다. 결과적으로 복합 타입의 서로 다른 필드들이 서로 다른 시점에 드롭될 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let tuple =
      (String::from("foo"), String::from("bar")); // --+
    { //                                               |
        let c = || { // ----------------------------+  |
            // tuple.0은 클로저 내부로 캡처됨 |  |
            drop(tuple.0); //                       |  |
        }; //                                       |  |
    } // 'c'와 'tuple.0'이 여기서 드롭됨 ------------+  |
} // tuple.1이 여기서 드롭됨 -----------------------------+
<span class="boring">}</span></code></pre></pre>
<p>r[type.closure.capture.precision.edition2018.entirety]</p>
<h2 id="2018-에디션-및-이전"><a class="header" href="#2018-에디션-및-이전">2018 에디션 및 이전</a></h2>
<h3 id="클로저-타입의-차이점"><a class="header" href="#클로저-타입의-차이점">클로저 타입의 차이점</a></h3>
<p>2018 에디션 및 이전 버전에서, 클로저는 항상 변수 전체를 캡처하며 정밀한 캡처 경로를 사용하지 않습니다. 이는 <a href="types/closure.html#closure-types">클로저 타입</a> 섹션에서 사용된 예시의 경우, 생성된 클로저 타입이 대신 다음과 같은 모습이 됨을 의미합니다:</p>
<!-- ignore: simplified -->
<pre><code class="language-rust ignore">struct Closure&lt;'a&gt; {
    rect : &amp;'a mut Rectangle,
}

impl&lt;'a&gt; FnOnce&lt;()&gt; for Closure&lt;'a&gt; {
    type Output = String;
    extern "rust-call" fn call_once(self, args: ()) -&gt; String {
        self.rect.left_top.x += 1;
        self.rect.right_bottom.x += 1;
        format!("{:?}", self.rect.left_top)
    }
}</code></pre>
<p>그리고 <code>f</code>에 대한 호출은 다음과 같이 작동합니다:</p>
<!-- ignore: continuation of above -->
<pre><code class="language-rust ignore">f(Closure { rect: rect });</code></pre>
<p>r[type.closure.capture.precision.edition2018.composite]</p>
<h3 id="캡처-정밀도의-차이"><a class="header" href="#캡처-정밀도의-차이">캡처 정밀도의 차이</a></h3>
<p>구조체, 튜플, 열거형과 같은 복합 타입은 개별 필드가 아니라 항상 전체가 캡처됩니다. 결과적으로, 단일 필드만 캡처하려면 로컬 변수로 차용해야 할 수도 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">
</span>struct SetVec {
    set: HashSet&lt;u32&gt;,
    vec: Vec&lt;u32&gt;
}

impl SetVec {
    fn populate(&amp;mut self) {
        let vec = &amp;mut self.vec;
        self.set.iter().for_each(|&amp;n| {
            vec.push(n);
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<p>만약 클로저가 <code>self.vec</code>을 직접 사용했다면 <code>self</code>를 가변 참조로 캡처하려고 시도했을 것입니다. 하지만 <code>self.set</code>이 이미 반복을 위해 차용된 상태이므로 코드가 컴파일되지 않았을 것입니다.</p>
<p>r[type.closure.capture.precision.edition2018.move] If the <code>move</code> keyword is used, then all captures are by move or, for <code>Copy</code> types, by copy, regardless of whether a borrow would work. The <code>move</code> keyword is usually used to allow the closure to outlive the captured values, such as if the closure is being returned or used to spawn a new thread.</p>
<p>r[type.closure.capture.precision.edition2018.wildcard] Regardless of if the data will be read by the closure, i.e. in case of wild card patterns, if a variable defined outside the closure is mentioned within the closure the variable will be captured in its entirety.</p>
<p>r[type.closure.capture.precision.edition2018.drop-order]</p>
<h3 id="드롭-순서의-차이"><a class="header" href="#드롭-순서의-차이">드롭 순서의 차이</a></h3>
<p>복합 타입은 전체가 캡처되므로, 이러한 복합 타입 중 하나를 값으로 캡처하는 클로저는 클로저가 드롭될 때 캡처된 변수 전체를 동시에 드롭합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let tuple =
      (String::from("foo"), String::from("bar"));
    {
        let c = || { // --------------------------+
            // tuple은 클로저 내부로 캡처됨 |
// --------------------------+
            // tuple은 클로저 내부로 캡처됨 |
            drop(tuple.0); //                     |
        }; //                                     |
    } // 'c'와 'tuple'이 여기서 드롭됨 ------------+
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p>r[type.pointer]</p>
<h1 id="포인터-타입"><a class="header" href="#포인터-타입">포인터 타입</a></h1>
<p>r[type.pointer.intro] All pointers are explicit first-class values. They can be moved or copied, stored into data structs, and returned from functions.</p>
<p>r[type.pointer.reference]</p>
<h2 id="참조--및-mut"><a class="header" href="#참조--및-mut">참조 (<code>&amp;</code> 및 <code>&amp;mut</code>)</a></h2>
<p>r[type.pointer.reference.syntax]</p>
<pre><code class="language-grammar types">ReferenceType -&gt; `&amp;` Lifetime? `mut`? TypeNoBounds
</code></pre>
<p>r[type.pointer.reference.shared]</p>
<h3 id="공유-참조-"><a class="header" href="#공유-참조-">공유 참조 (<code>&amp;</code>)</a></h3>
<p>r[type.pointer.reference.shared.intro] Shared references point to memory which is owned by some other value.</p>
<p>r[type.pointer.reference.shared.constraint-mutation] When a shared reference to a value is created, it prevents direct mutation of the value. <a href="types/../interior-mutability.html">Interior mutability</a> provides an exception for this in certain circumstances. As the name suggests, any number of shared references to a value may exist. A shared reference type is written <code>&amp;type</code>, or <code>&amp;'a type</code> when you need to specify an explicit lifetime.</p>
<p>r[type.pointer.reference.shared.copy] Copying a reference is a “shallow” operation: it involves only copying the pointer itself, that is, pointers are <code>Copy</code>. Releasing a reference has no effect on the value it points to, but referencing of a <a href="types/../expressions.html#temporaries">temporary value</a> will keep it alive during the scope of the reference itself.</p>
<p>r[type.pointer.reference.mut]</p>
<h3 id="가변-참조-mut"><a class="header" href="#가변-참조-mut">가변 참조 (<code>&amp;mut</code>)</a></h3>
<p>r[type.pointer.reference.mut.intro] Mutable references point to memory which is owned by some other value. A mutable reference type is written <code>&amp;mut type</code> or <code>&amp;'a mut type</code>.</p>
<p>r[type.pointer.reference.mut.copy] A mutable reference (that hasn’t been borrowed) is the only way to access the value it points to, so is not <code>Copy</code>.</p>
<p>r[type.pointer.raw]</p>
<h2 id="원시-포인터-const-및-mut"><a class="header" href="#원시-포인터-const-및-mut">원시 포인터 (<code>*const</code> 및 <code>*mut</code>)</a></h2>
<p>r[type.pointer.raw.syntax]</p>
<pre><code class="language-grammar types">RawPointerType -&gt; `*` ( `mut` | `const` ) TypeNoBounds
</code></pre>
<p>r[type.pointer.raw.intro] Raw pointers are pointers without safety or liveness guarantees. Raw pointers are written as <code>*const T</code> or <code>*mut T</code>. For example <code>*const i32</code> means a raw pointer to a 32-bit integer.</p>
<p>r[type.pointer.raw.copy] Copying or dropping a raw pointer has no effect on the lifecycle of any other value.</p>
<p>r[type.pointer.raw.safety] Dereferencing a raw pointer is an <a href="types/../unsafety.html"><code>unsafe</code> operation</a>.</p>
<p>이는 원시 포인터를 다시 차용(<code>&amp;*</code> 또는 <code>&amp;mut *</code>)하여 참조로 변환하는 데에도 사용될 수 있습니다. 원시 포인터는 일반적으로 권장되지 않습니다. 이들은 외부 코드와의 상호 운용성을 지원하고, 성능에 민감하거나 저수준 함수를 작성하기 위해 존재합니다.</p>
<p>r[type.pointer.raw.cmp] When comparing raw pointers they are compared by their address, rather than by what they point to. When comparing raw pointers to <a href="types/../dynamically-sized-types.html">dynamically sized types</a> they also have their additional data compared.</p>
<p>r[type.pointer.raw.constructor] Raw pointers can be created directly using <code>&amp;raw const</code> for <code>*const</code> pointers and <code>&amp;raw mut</code> for <code>*mut</code> pointers.</p>
<p>r[type.pointer.smart]</p>
<h2 id="smart-pointers"><a class="header" href="#smart-pointers">Smart pointers</a></h2>
<p>표준 라이브러리는 참조와 원시 포인터 외에도 추가적인 ‘스마트 포인터’ 타입을 포함합니다.</p>
<p>r[type.pointer.validity]</p>
<h2 id="비트-유효성-2"><a class="header" href="#비트-유효성-2">비트 유효성</a></h2>
<p>r[type.pointer.validity.pointer-fragment] Despite pointers and references being similar to <code>usize</code>s in the machine code emitted on most platforms, the semantics of transmuting a reference or pointer type to a non-pointer type is currently undecided. Thus, it may not be valid to transmute a pointer or reference type, <code>P</code>, to a <code>[u8; size_of::&lt;P&gt;()]</code>.</p>
<p>r[type.pointer.validity.raw] For thin raw pointers (i.e., for <code>P = *const T</code> or <code>P = *mut T</code> for <code>T: Sized</code>), the inverse direction (transmuting from an integer or array of integers to <code>P</code>) is always valid. However, the pointer produced via such a transmutation may not be dereferenced (not even if <code>T</code> has size zero).</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[type.fn-pointer]</p>
<h1 id="함수-포인터-타입"><a class="header" href="#함수-포인터-타입">함수 포인터 타입</a></h1>
<p>r[type.fn-pointer.syntax]</p>
<pre><code class="language-grammar types">BareFunctionType -&gt;
    ForLifetimes? FunctionTypeQualifiers `fn`
       `(` FunctionParametersMaybeNamedVariadic? `)` BareFunctionReturnType?

FunctionTypeQualifiers -&gt; `unsafe`? (`extern` Abi?)?

BareFunctionReturnType -&gt; `-&gt;` TypeNoBounds

FunctionParametersMaybeNamedVariadic -&gt;
    MaybeNamedFunctionParameters | MaybeNamedFunctionParametersVariadic

MaybeNamedFunctionParameters -&gt;
    MaybeNamedParam ( `,` MaybeNamedParam )* `,`?

MaybeNamedParam -&gt;
    OuterAttribute* ( ( IDENTIFIER | `_` ) `:` )? Type

MaybeNamedFunctionParametersVariadic -&gt;
    ( MaybeNamedParam `,` )* MaybeNamedParam `,` OuterAttribute* `...`
</code></pre>
<p>r[type.fn-pointer.intro] A function pointer type, written using the <code>fn</code> keyword, refers to a function whose identity is not necessarily known at compile-time.</p>
<p><code>Binop</code>이 함수 포인터 타입으로 정의된 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(x: i32, y: i32) -&gt; i32 {
    x + y
}

let mut x = add(5,7);

type Binop = fn(i32, i32) -&gt; i32;
let bo: Binop = add;
x = bo(5,7);
<span class="boring">}</span></code></pre></pre>
<p>r[type.fn-pointer.coercion] Function pointers can be created via a coercion from both <a href="types/function-item.html">function items</a> and non-capturing, non-async <a href="types/closure.html">closures</a>.</p>
<p>r[type.fn-pointer.qualifiers] The <code>unsafe</code> qualifier indicates that the type’s value is an <a href="types/../unsafe-keyword.html">unsafe function</a>, and the <code>extern</code> qualifier indicates it is an <a href="types/../items/functions.html#extern-function-qualifier">extern function</a>.</p>
<p>r[type.fn-pointer.constraint-variadic] For the function to be variadic, its <code>extern</code> ABI must be one of those listed in [items.extern.variadic.conventions].</p>
<p>r[type.fn-pointer.attributes]</p>
<h2 id="함수-포인터-매개변수의-속성"><a class="header" href="#함수-포인터-매개변수의-속성">함수 포인터 매개변수의 속성</a></h2>
<p>함수 포인터 매개변수의 속성은 <a href="types/../items/functions.html#attributes-on-function-parameters">일반 함수 매개변수</a>와 동일한 규칙 및 제한을 따릅니다.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[type.trait-object]</p>
<h1 id="트레잇-객체"><a class="header" href="#트레잇-객체">트레잇 객체</a></h1>
<p>r[type.trait-object.syntax]</p>
<pre><code class="language-grammar types">TraitObjectType -&gt; `dyn`? TypeParamBounds

TraitObjectTypeOneBound -&gt; `dyn`? TraitBound
</code></pre>
<p>r[type.trait-object.intro] A <em>trait object</em> is an opaque value of another type that implements a set of traits. The set of traits is made up of a <a href="types/../items/traits.html#dyn-compatibility">dyn compatible</a> <em>base trait</em> plus any number of <a href="types/../special-types-and-traits.html#auto-traits">auto traits</a>.</p>
<p>r[type.trait-object.impls] Trait objects implement the base trait, its auto traits, and any <a href="types/../items/traits.html#supertraits">supertraits</a> of the base trait.</p>
<p>r[type.trait-object.name] Trait objects are written as the keyword <code>dyn</code> followed by a set of trait bounds, but with the following restrictions on the trait bounds.</p>
<p>r[type.trait-object.constraint] There may not be more than one non-auto trait, no more than one lifetime, and opt-out bounds (e.g. <code>?Sized</code>) are not allowed. Furthermore, paths to traits may be parenthesized.</p>
<p>예를 들어, <code>Trait</code>라는 트레잇이 주어졌을 때, 다음은 모두 트레잇 객체입니다:</p>
<ul>
<li><code>dyn Trait</code></li>
<li><code>dyn Trait + Send</code></li>
<li><code>dyn Trait + Send + Sync</code></li>
<li><code>dyn Trait + 'static</code></li>
<li><code>dyn Trait + Send + 'static</code></li>
<li><code>dyn Trait +</code></li>
<li><code>dyn 'static + Trait</code>.</li>
<li><code>dyn (Trait)</code></li>
</ul>
<p>r[type.trait-object.syntax-edition2021]</p>
<blockquote>
<p>[!EDITION-2021] Before the 2021 edition, the <code>dyn</code> keyword may be omitted.</p>
</blockquote>
<p>r[type.trait-object.syntax-edition2018]</p>
<blockquote>
<p>[!EDITION-2018] In the 2015 edition, if the first bound of the trait object is a path that starts with <code>::</code>, then the <code>dyn</code> will be treated as a part of the path. The first path can be put in parenthesis to get around this. As such, if you want a trait object with the trait <code>::your_module::Trait</code>, you should write it as <code>dyn (::your_module::Trait)</code>.</p>
<p>2018 에디션부터 <code>dyn</code>은 진정한 키워드이며 경로에 허용되지 않으므로, 괄호가 필요하지 않습니다.</p>
</blockquote>
<p>r[type.trait-object.alias] Two trait object types alias each other if the base traits alias each other and if the sets of auto traits are the same and the lifetime bounds are the same. For example, <code>dyn Trait + Send + UnwindSafe</code> is the same as <code>dyn Trait + UnwindSafe + Send</code>.</p>
<p>r[type.trait-object.unsized] Due to the opaqueness of which concrete type the value is of, trait objects are <a href="types/../dynamically-sized-types.html">dynamically sized types</a>. Like all <abbr title="dynamically sized types">DSTs</abbr>, trait objects are used behind some type of pointer; for example <code>&amp;dyn SomeTrait</code> or <code>Box&lt;dyn SomeTrait&gt;</code>. Each instance of a pointer to a trait object includes:</p>
<ul>
<li><code>SomeTrait</code>를 구현하는 타입 <code>T</code>의 인스턴스에 대한 포인터</li>
<li><em>가상 메서드 테이블</em>(흔히 _vtable_이라고 함)은 <code>T</code>가 구현하는 <code>SomeTrait</code> 및 그 <a href="types/../items/traits.html#supertraits">상위 트레잇</a>의 각 메서드에 대해 <code>T</code>의 구현에 대한 포인터(즉, 함수 포인터)를 포함합니다.</li>
</ul>
<p>트레잇 객체의 목적은 메서드의 “지연 바인딩(late binding)“을 허용하는 것입니다. 트레잇 객체에서 메서드를 호출하면 런타임에 가상 디스패치(virtual dispatch)가 발생합니다. 즉, 트레잇 객체 vtable에서 함수 포인터를 로드하여 간접적으로 호출합니다. 각 vtable 항목에 대한 실제 구현은 객체마다 다를 수 있습니다.</p>
<p>트레잇 객체의 예시:</p>
<pre><pre class="playground"><code class="language-rust edition2024">trait Printable {
    fn stringify(&amp;self) -&gt; String;
}

impl Printable for i32 {
    fn stringify(&amp;self) -&gt; String { self.to_string() }
}

fn print(a: Box&lt;dyn Printable&gt;) {
    println!("{}", a.stringify());
}

fn main() {
    print(Box::new(10) as Box&lt;dyn Printable&gt;);
}</code></pre></pre>
<p>이 예시에서, 트레잇 <code>Printable</code>은 <code>print</code>의 타입 시그니처와 <code>main</code>의 캐스트 표현식 양쪽 모두에서 트레잇 객체로 나타납니다.</p>
<p>r[type.trait-object.lifetime-bounds]</p>
<h2 id="trait-object-lifetime-bounds"><a class="header" href="#trait-object-lifetime-bounds">Trait object lifetime bounds</a></h2>
<p>트레잇 객체는 참조를 포함할 수 있으므로, 해당 참조들의 라이프타임은 트레잇 객체의 일부로 표현되어야 합니다. 이 라이프타임은 <code>Trait + 'a</code>로 작성됩니다. <a href="types/../lifetime-elision.html#default-trait-object-lifetimes">기본값</a>이 있어 보통은 이 라이프타임이 합리적인 선택으로 추론될 수 있게 합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[type.impl-trait]</p>
<h1 id="impl-트레잇"><a class="header" href="#impl-트레잇">Impl 트레잇</a></h1>
<p>r[type.impl-trait.syntax]</p>
<pre><code class="language-grammar types">ImplTraitType -&gt; `impl` TypeParamBounds

ImplTraitTypeOneBound -&gt; `impl` TraitBound
</code></pre>
<p>r[type.impl-trait.intro] <code>impl Trait</code> provides ways to specify unnamed but concrete types that implement a specific trait. It can appear in two sorts of places: argument position (where it can act as an anonymous type parameter to functions), and return position (where it can act as an abstract return type).</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {}
<span class="boring">impl Trait for () {}
</span>
// 인자 위치: 익명 타입 매개변수
fn foo(arg: impl Trait) {
}

// 반환 위치: 추상 반환 타입
fn bar() -&gt; impl Trait {
}
<span class="boring">}</span></code></pre></pre>
<p>r[type.impl-trait.param]</p>
<h2 id="익명-타입-매개변수"><a class="header" href="#익명-타입-매개변수">익명 타입 매개변수</a></h2>
<blockquote>
<p>[!NOTE] This is often called “impl Trait in argument position”. (The term “parameter” is more correct here, but “impl Trait in argument position” is the phrasing used during the development of this feature, and it remains in parts of the implementation.)</p>
</blockquote>
<p>r[type.impl-trait.param.intro] Functions can use <code>impl</code> followed by a set of trait bounds to declare a parameter as having an anonymous type. The caller must provide a type that satisfies the bounds declared by the anonymous type parameter, and the function can only use the methods available through the trait bounds of the anonymous type parameter.</p>
<p>예를 들어, 다음 두 형식은 거의 동일합니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {}

// 제네릭 타입 매개변수
fn with_generic_type&lt;T: Trait&gt;(arg: T) {
}

// 인자 위치의 impl Trait
fn with_impl_trait(arg: impl Trait) {
}
<span class="boring">}</span></code></pre></pre>
<p>r[type.impl-trait.param.generic] That is, <code>impl Trait</code> in argument position is syntactic sugar for a generic type parameter like <code>&lt;T: Trait&gt;</code>, except that the type is anonymous and doesn’t appear in the [GenericParams] list.</p>
<blockquote>
<p>[!NOTE] For function parameters, generic type parameters and <code>impl Trait</code> are not exactly equivalent. With a generic parameter such as <code>&lt;T: Trait&gt;</code>, the caller has the option to explicitly specify the generic argument for <code>T</code> at the call site using [GenericArgs], for example, <code>foo::&lt;usize&gt;(1)</code>. Changing a parameter from either one to the other can constitute a breaking change for the callers of a function, since this changes the number of generic arguments.</p>
</blockquote>
<p>r[type.impl-trait.return]</p>
<h2 id="추상-반환-타입"><a class="header" href="#추상-반환-타입">추상 반환 타입</a></h2>
<blockquote>
<p>[!NOTE] This is often called “impl Trait in return position”.</p>
</blockquote>
<p>r[type.impl-trait.return.intro] Functions can use <code>impl Trait</code> to return an abstract return type. These types stand in for another concrete type where the caller may only use the methods declared by the specified <code>Trait</code>.</p>
<p>r[type.impl-trait.return.constraint-body] Each possible return value from the function must resolve to the same concrete type.</p>
<p>반환 위치의 <code>impl Trait</code>는 함수가 박싱되지 않은(unboxed) 추상 타입을 반환할 수 있게 합니다. 이는 <a href="types/closure.html">클로저</a> 및 반복자와 함께 사용할 때 특히 유용합니다. 예를 들어, 클로저는 작성할 수 없는 고유한 타입을 가집니다. 이전에는 함수에서 클로저를 반환하는 유일한 방법이 <a href="types/trait-object.html">트레잇 객체</a>를 사용하는 것이었습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}
<span class="boring">}</span></code></pre></pre>
<p>이는 힙 할당 및 동적 디스패치로 인한 성능 저하를 초래할 수 있습니다. 클로저의 타입을 완전히 명시하는 것은 불가능했고, 오직 <code>Fn</code> 트레잇만 사용할 수 있었습니다. 즉, 트레잇 객체가 필요하다는 뜻입니다. 하지만 <code>impl Trait</code>를 사용하면 이를 더 간단하게 작성할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {
    |x| x + 1
}
<span class="boring">}</span></code></pre></pre>
<p>이는 또한 박싱된 트레잇 객체 사용의 단점을 피할 수 있게 해줍니다.</p>
<p>마찬가지로, 반복자의 구체적인 타입은 체인에 있는 이전의 모든 반복자의 타입을 포함하여 매우 복잡해질 수 있습니다. <code>impl Iterator</code>를 반환한다는 것은 함수가 관련된 다른 모든 반복자 타입을 명시적으로 지정하는 대신, 반환 타입에 대한 바운드로서 <code>Iterator</code> 트레잇만을 노출한다는 것을 의미합니다.</p>
<p>r[type.impl-trait.return-in-trait]</p>
<h2 id="트레잇-및-트레잇-구현에서의-반환-위치-impl-trait"><a class="header" href="#트레잇-및-트레잇-구현에서의-반환-위치-impl-trait">트레잇 및 트레잇 구현에서의 반환 위치 <code>impl Trait</code></a></h2>
<p>r[type.impl-trait.return-in-trait.intro] Functions in traits may also use <code>impl Trait</code> as a syntax for an anonymous associated type.</p>
<p>r[type.impl-trait.return-in-trait.desugaring] Every <code>impl Trait</code> in the return type of an associated function in a trait is desugared to an anonymous associated type. The return type that appears in the implementation’s function signature is used to determine the value of the associated type.</p>
<p>r[type.impl-trait.generic-captures]</p>
<h2 id="캡처링"><a class="header" href="#캡처링">캡처링</a></h2>
<p>각 반환 위치 <code>impl Trait</code> 추상 타입 뒤에는 숨겨진 구체적인 타입이 있습니다. 이 구체적인 타입이 제네릭 매개변수를 사용하려면, 해당 제네릭 매개변수가 추상 타입에 의해 _캡처_되어야 합니다.</p>
<p>r[type.impl-trait.generic-capture.auto]</p>
<h2 id="자동-캡처링"><a class="header" href="#자동-캡처링">자동 캡처링</a></h2>
<p>r[type.impl-trait.generic-capture.auto.intro] Return-position <code>impl Trait</code> abstract types automatically capture all in-scope generic parameters, including generic type, const, and lifetime parameters (including higher-ranked ones).</p>
<p>r[type.impl-trait.generic-capture.edition2024]</p>
<blockquote>
<p>[!EDITION-2024] Before the 2024 edition, on free functions and on associated functions and methods of inherent impls, generic lifetime parameters that do not appear in the bounds of the abstract return type are not automatically captured.</p>
</blockquote>
<p>r[type.impl-trait.generic-capture.precise]</p>
<h2 id="정밀-캡처링"><a class="header" href="#정밀-캡처링">정밀 캡처링</a></h2>
<p>r[type.impl-trait.generic-capture.precise.use] The set of generic parameters captured by a return-position <code>impl Trait</code> abstract type may be explicitly controlled with a <a href="types/../trait-bounds.html#use-bounds"><code>use&lt;..&gt;</code> bound</a>.  If present, only the generic parameters listed in the <code>use&lt;..&gt;</code> bound will be captured.  E.g.:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn capture&lt;'a, 'b, T&gt;(x: &amp;'a (), y: T) -&gt; impl Sized + use&lt;'a, T&gt; {
  //                                      ~~~~~~~~~~~~~~~~~~~~~~~
  //                                     오직 `'a`와 `T`만 캡처합니다.
  (x, y)
}
<span class="boring">}</span></code></pre></pre>
<p>r[type.impl-trait.generic-capture.precise.constraint-single] Currently, only one <code>use&lt;..&gt;</code> bound may be present in a bounds list, all in-scope type and const generic parameters must be included, and all lifetime parameters that appear in other bounds of the abstract type must be included.</p>
<p>r[type.impl-trait.generic-capture.precise.constraint-lifetime] Within the <code>use&lt;..&gt;</code> bound, any lifetime parameters present must appear before all type and const generic parameters, and the elided lifetime (<code>'_</code>) may be present if it is otherwise allowed to appear within the <code>impl Trait</code> return type.</p>
<p>r[type.impl-trait.generic-capture.precise.constraint-param-impl-trait] Because all in-scope type parameters must be included by name, a <code>use&lt;..&gt;</code> bound may not be used in the signature of items that use argument-position <code>impl Trait</code>, as those items have anonymous type parameters in scope.</p>
<p>r[type.impl-trait.generic-capture.precise.constraint-in-trait] Any <code>use&lt;..&gt;</code> bound that is present in an associated function in a trait definition must include all generic parameters of the trait, including the implicit <code>Self</code> generic type parameter of the trait.</p>
<h2 id="반환-위치에서의-제네릭과-impl-trait의-차이점"><a class="header" href="#반환-위치에서의-제네릭과-impl-trait의-차이점">반환 위치에서의 제네릭과 <code>impl Trait</code>의 차이점</a></h2>
<p>인자 위치에서 <code>impl Trait</code>는 의미론적으로 제네릭 타입 매개변수와 매우 유사합니다. 그러나 반환 위치에서는 둘 사이에 중요한 차이가 있습니다. <code>impl Trait</code>를 사용하면 제네릭 타입 매개변수와 달리 함수가 반환 타입을 선택하며, 호출자는 반환 타입을 선택할 수 없습니다.</p>
<p>다음 함수는:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait {}
</span>fn foo&lt;T: Trait&gt;() -&gt; T {
    // ...
<span class="boring">panic!()
</span>}
<span class="boring">}</span></code></pre></pre>
<p>호출자가 반환 타입 <code>T</code>를 결정하도록 허용하며, 함수는 해당 타입을 반환합니다.</p>
<p>다음 함수는:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait {}
</span><span class="boring">impl Trait for () {}
</span>fn foo() -&gt; impl Trait {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>호출자가 반환 타입을 결정하는 것을 허용하지 않습니다. 대신 함수가 반환 타입을 선택하지만, 오직 그 타입이 <code>Trait</code>를 구현한다는 것만 약속합니다.</p>
<p>r[type.impl-trait.constraint]</p>
<h2 id="제한-사항-1"><a class="header" href="#제한-사항-1">제한 사항</a></h2>
<p><code>impl Trait</code>는 <code>extern</code>이 아닌 함수의 매개변수 또는 반환 타입으로만 나타날 수 있습니다. <code>let</code> 바인딩의 타입이나 필드 타입이 될 수 없으며, 타입 별칭 내부에 나타날 수 없습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[type.generic]</p>
<h1 id="타입-파라미터"><a class="header" href="#타입-파라미터">타입 파라미터</a></h1>
<p>타입 매개변수 선언이 있는 아이템의 본문 내에서, 해당 타입 매개변수의 이름은 타입입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn to_vec&lt;A: Clone&gt;(xs: &amp;[A]) -&gt; Vec&lt;A&gt; {
    if xs.is_empty() {
        return vec![];
    }
    let first: A = xs[0].clone();
    let mut rest: Vec&lt;A&gt; = to_vec(&amp;xs[1..]);
    rest.insert(0, first);
    rest
}
<span class="boring">}</span></code></pre></pre>
<p>여기서 <code>first</code>는 <code>to_vec</code>의 <code>A</code> 타입 매개변수를 참조하는 <code>A</code> 타입을 가지며, <code>rest</code>는 요소 타입이 <code>A</code>인 벡터 <code>Vec&lt;A&gt;</code> 타입을 가집니다.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[type.inferred]</p>
<h1 id="추론된-타입"><a class="header" href="#추론된-타입">추론된 타입</a></h1>
<p>r[type.inferred.syntax]</p>
<pre><code class="language-grammar types">InferredType -&gt; `_`
</code></pre>
<p>r[type.inferred.intro] The inferred type asks the compiler to infer the type if possible based on the surrounding information available.</p>
<blockquote>
<p>[!EXAMPLE] The inferred type is often used in generic arguments:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: Vec&lt;_&gt; = (0..10).collect();
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[type.inferred.constraint] The inferred type cannot be used in item signatures.</p>
<!--
  What else should be said here?
  The only documentation I am aware of is https://rustc-dev-guide.rust-lang.org/type-inference.html
  There should be a broader discussion of type inference somewhere.
-->
<div style="break-before: page; page-break-before: always;"></div><p>r[dynamic-sized]</p>
<h1 id="dynamically-sized-types"><a class="header" href="#dynamically-sized-types">Dynamically sized types</a></h1>
<p>r[dynamic-sized.intro] Most types have a fixed size that is known at compile time and implement the trait <a href="special-types-and-traits.html#sized"><code>Sized</code></a>. A type with a size that is known only at run-time is called a <em>dynamically sized type</em> (<em>DST</em>) or, informally, an unsized type.  <a href="types/slice.html">Slices</a>, <a href="types/trait-object.html">trait objects</a>, and <a href="types/textual.html">str</a> are examples of <abbr title="dynamically sized types">DSTs</abbr>.</p>
<p>r[dynamic-sized.restriction] Such types can only be used in certain cases:</p>
<p>r[dynamic-sized.pointer-types]</p>
<ul>
<li><abbr title="dynamically sized types">DST</abbr>에 대한 <a href="types/pointer.html">포인터 타입</a>은 크기가 있지만, 크기가 있는 타입에 대한 포인터보다 두 배의 크기를 가집니다.
<ul>
<li>Pointers to slices and <code>str</code> also store the number of elements.</li>
<li>트레잇 객체에 대한 포인터는 vtable에 대한 포인터도 저장합니다.</li>
</ul>
</li>
</ul>
<p>r[dynamic-sized.question-sized]</p>
<ul>
<li><abbr title="dynamically sized types">DST</abbr>는 특별한 <code>?Sized</code> 바운드를 가진 제네릭 타입 매개변수에 타입 인자로 제공될 수 있습니다. 또한 대응하는 연관 타입 선언에 <code>?Sized</code> 바운드가 있을 때 연관 타입 정의에도 사용될 수 있습니다. 기본적으로 모든 타입 매개변수나 연관 타입은 <code>?Sized</code>를 사용하여 완화되지 않는 한 <code>Sized</code> 바운드를 가집니다.</li>
</ul>
<p>r[dynamic-sized.trait-impl]</p>
<ul>
<li>트레잇은 <abbr title="dynamically sized types">DST</abbr>에 대해 구현될 수 있습니다. 제네릭 타입 매개변수와 달리, 트레잇 정의에서는 <code>Self: ?Sized</code>가 기본값입니다.</li>
</ul>
<p>r[dynamic-sized.struct-field]</p>
<ul>
<li>구조체는 마지막 필드로 <abbr title="dynamically sized type">DST</abbr>를 포함할 수 있으며, 이 경우 구조체 자체도 <abbr title="dynamically sized type">DST</abbr>가 됩니다.</li>
</ul>
<blockquote>
<p>[!NOTE] <a href="variables.html">Variables</a>, function parameters, <a href="items/constant-items.html">const</a> items, and <a href="items/static-items.html">static</a> items must be <code>Sized</code>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>r[layout]</p>
<h1 id="타입-레이아웃"><a class="header" href="#타입-레이아웃">타입 레이아웃</a></h1>
<p>r[layout.intro] The layout of a type is its size, alignment, and the relative offsets of its fields. For enums, how the discriminant is laid out and interpreted is also part of type layout.</p>
<p>r[layout.guarantees] Type layout can be changed with each compilation. Instead of trying to document exactly what is done, we only document what is guaranteed today.</p>
<p>동일한 레이아웃을 가진 타입이라도 함수 경계를 넘어 전달되는 방식은 다를 수 있다는 점에 유의하십시오. 타입의 함수 호출 ABI 호환성에 대해서는 <a href="../core/primitive.fn.html#abi-compatibility">여기</a>를 참조하십시오.</p>
<p>r[layout.properties]</p>
<h2 id="size-and-alignment"><a class="header" href="#size-and-alignment">Size and alignment</a></h2>
<p>모든 값은 정렬과 크기를 가집니다.</p>
<p>r[layout.properties.align] The <em>alignment</em> of a value specifies what addresses are valid to store the value at. A value of alignment <code>n</code> must only be stored at an address that is a multiple of n. For example, a value with an alignment of 2 must be stored at an even address, while a value with an alignment of 1 can be stored at any address. Alignment is measured in bytes, and must be at least 1, and always a power of 2. The alignment of a value can be checked with the <a href="std::mem::align_of_val"><code>align_of_val</code></a> function.</p>
<p>r[layout.properties.size] The <em>size</em> of a value is the offset in bytes between successive elements in an array with that item type including alignment padding. The size of a value is always a multiple of its alignment. Note that some types are zero-sized; 0 is considered a multiple of any alignment (for example, on some platforms, the type <code>[u16; 0]</code> has size 0 and alignment 2). The size of a value can be checked with the <a href="std::mem::size_of_val"><code>size_of_val</code></a> function.</p>
<p>r[layout.properties.sized] Types where all values have the same size and alignment, and both are known at compile time, implement the <a href="std::marker::Sized"><code>Sized</code></a> trait and can be checked with the <a href="std::mem::size_of"><code>size_of</code></a> and <a href="std::mem::align_of"><code>align_of</code></a> functions. Types that are not <a href="std::marker::Sized"><code>Sized</code></a> are known as <a href="dynamically-sized-types.html">dynamically sized types</a>. Since all values of a <code>Sized</code> type share the same size and alignment, we refer to those shared values as the size of the type and the alignment of the type respectively.</p>
<p>r[layout.primitive]</p>
<h2 id="primitive-data-layout"><a class="header" href="#primitive-data-layout">Primitive data layout</a></h2>
<p>r[layout.primitive.size] The size of most primitives is given in this table.</p>
<div class="table-wrapper"><table><thead><tr><th>유형</th><th><code>size_of::&lt;Type&gt;()</code></th></tr></thead><tbody>
<tr><td><code>bool</code></td><td>1</td></tr>
<tr><td><code>u8</code> / <code>i8</code></td><td>1</td></tr>
<tr><td><code>u16</code> / <code>i16</code></td><td>2</td></tr>
<tr><td><code>u32</code> / <code>i32</code></td><td>4</td></tr>
<tr><td><code>u64</code> / <code>i64</code></td><td>8</td></tr>
<tr><td><code>u128</code> / <code>i128</code></td><td>16</td></tr>
<tr><td><code>usize</code> / <code>isize</code></td><td>아래 참조</td></tr>
<tr><td><code>f32</code></td><td>4</td></tr>
<tr><td><code>f64</code></td><td>8</td></tr>
<tr><td><code>char</code></td><td>4</td></tr>
</tbody></table>
</div>
<p>r[layout.primitive.size-int] <code>usize</code> and <code>isize</code> have a size big enough to contain every address on the target platform. For example, on a 32 bit target, this is 4 bytes, and on a 64 bit target, this is 8 bytes.</p>
<p>r[layout.primitive.align] The alignment of primitives is platform-specific. In most cases, their alignment is equal to their size, but it may be less. In particular, <code>i128</code> and <code>u128</code> are often aligned to 4 or 8 bytes even though their size is 16, and on many 32-bit platforms, <code>i64</code>, <code>u64</code>, and <code>f64</code> are only aligned to 4 bytes, not 8.</p>
<p>r[layout.pointer]</p>
<h2 id="pointers-and-references-layout"><a class="header" href="#pointers-and-references-layout">Pointers and references layout</a></h2>
<p>r[layout.pointer.intro] Pointers and references have the same layout. Mutability of the pointer or reference does not change the layout.</p>
<p>r[layout.pointer.thin] Pointers to sized types have the same size and alignment as <code>usize</code>.</p>
<p>r[layout.pointer.unsized] Pointers to unsized types are sized. The size and alignment is guaranteed to be at least equal to the size and alignment of a pointer.</p>
<blockquote>
<p>[!NOTE] Though you should not rely on this, all pointers to <abbr title="Dynamically Sized Types">DSTs</abbr> are currently twice the size of the size of <code>usize</code> and have the same alignment.</p>
</blockquote>
<p>r[layout.array]</p>
<h2 id="array-layout"><a class="header" href="#array-layout">Array layout</a></h2>
<p><code>[T; N]</code> 배열은 <code>size_of::&lt;T&gt;() * N</code>의 크기를 가지며 <code>T</code>와 동일한 정렬을 가집니다. 배열은 0부터 시작하는 <code>nth</code> 요소가 배열 시작점으로부터 <code>n * size_of::&lt;T&gt;()</code> 바이트만큼 오프셋되도록 배치됩니다.</p>
<p>r[layout.slice]</p>
<h2 id="slice-layout"><a class="header" href="#slice-layout">Slice layout</a></h2>
<p>슬라이스는 자신이 슬라이싱하는 배열 섹션과 동일한 레이아웃을 가집니다.</p>
<blockquote>
<p>[!NOTE] This is about the raw <code>[T]</code> type, not pointers (<code>&amp;[T]</code>, <code>Box&lt;[T]&gt;</code>, etc.) to slices.</p>
</blockquote>
<p>r[layout.str]</p>
<h2 id="str-레이아웃"><a class="header" href="#str-레이아웃"><code>str</code> 레이아웃</a></h2>
<p>String slices are a UTF-8 representation of characters that have the same layout as slices of type <code>[u8]</code>. A reference <code>&amp;str</code> has the same layout as a reference <code>&amp;[u8]</code>.</p>
<p>r[layout.tuple]</p>
<h2 id="tuple-layout"><a class="header" href="#tuple-layout">Tuple layout</a></h2>
<p>r[layout.tuple.general] Tuples are laid out according to the <a href="type-layout.html#the-rust-representation"><code>Rust</code> representation</a>.</p>
<p>r[layout.tuple.unit] The exception to this is the unit tuple (<code>()</code>), which is guaranteed as a zero-sized type to have a size of 0 and an alignment of 1.</p>
<p>r[layout.trait-object]</p>
<h2 id="trait-object-layout"><a class="header" href="#trait-object-layout">Trait object layout</a></h2>
<p>트레잇 객체는 해당 트레잇 객체가 나타내는 값과 동일한 레이아웃을 가집니다.</p>
<blockquote>
<p>[!NOTE] This is about the raw trait object types, not pointers (<code>&amp;dyn Trait</code>, <code>Box&lt;dyn Trait&gt;</code>, etc.) to trait objects.</p>
</blockquote>
<p>r[layout.closure]</p>
<h2 id="closure-layout"><a class="header" href="#closure-layout">Closure layout</a></h2>
<p>클로저는 레이아웃 보장이 없습니다.</p>
<p>r[layout.repr]</p>
<h2 id="표현-representations"><a class="header" href="#표현-representations">표현 (Representations)</a></h2>
<p>r[layout.repr.intro] All user-defined composite types (<code>struct</code>s, <code>enum</code>s, and <code>union</code>s) have a <em>representation</em> that specifies what the layout is for the type.</p>
<p>r[layout.repr.kinds] The possible representations for a type are:</p>
<ul>
<li><a href="type-layout.html#the-rust-representation"><code>Rust</code></a> (기본값)</li>
<li><a href="type-layout.html#the-c-representation"><code>C</code></a></li>
<li><a href="type-layout.html#primitive-representations">기본 표현(primitive representations)</a></li>
<li><a href="type-layout.html#the-transparent-representation"><code>transparent</code></a></li>
</ul>
<p>r[layout.repr.attribute] The representation of a type can be changed by applying the <code>repr</code> attribute to it. The following example shows a struct with a <code>C</code> representation.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
struct ThreeInts {
    first: i16,
    second: i8,
    third: i32
}
<span class="boring">}</span></code></pre></pre>
<p>r[layout.repr.align-packed] The alignment may be raised or lowered with the <code>align</code> and <code>packed</code> modifiers respectively. They alter the representation specified in the attribute. If no representation is specified, the default one is altered.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 기본 표현, 정렬이 2로 낮아짐.
#[repr(packed(2))]
struct PackedStruct {
    first: i16,
    second: i8,
    third: i32
}

// C 표현, 정렬이 8로 높아짐
#[repr(C, align(8))]
struct AlignedStruct {
    first: i16,
    second: i8,
    third: i32
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] As a consequence of the representation being an attribute on the item, the representation does not depend on generic parameters. Any two types with the same name have the same representation. For example, <code>Foo&lt;Bar&gt;</code> and <code>Foo&lt;Baz&gt;</code> both have the same representation.</p>
</blockquote>
<p>r[layout.repr.inter-field] The representation of a type can change the padding between fields, but does not change the layout of the fields themselves. For example, a struct with a <code>C</code> representation that contains a struct <code>Inner</code> with the <code>Rust</code> representation will not change the layout of <code>Inner</code>.</p>
<p><a id="the-default-representation"></a> r[layout.repr.rust]</p>
<h3 id="the-rust-representation"><a class="header" href="#the-rust-representation">The <code>Rust</code> representation</a></h3>
<p>r[layout.repr.rust.intro] The <code>Rust</code> representation is the default representation for nominal types without a <code>repr</code> attribute. Using this representation explicitly through a <code>repr</code> attribute is guaranteed to be the same as omitting the attribute entirely.</p>
<p>r[layout.repr.rust.layout] The only data layout guarantees made by this representation are those required for soundness. They are:</p>
<ol>
<li>필드들이 올바르게 정렬됩니다.</li>
<li>필드들이 겹치지 않습니다.</li>
<li>타입의 정렬은 최소한 그 필드들의 최대 정렬 이상입니다.</li>
</ol>
<p>r[layout.repr.rust.alignment] Formally, the first guarantee means that the offset of any field is divisible by that field’s alignment.</p>
<p>r[layout.repr.rust.field-storage] The second guarantee means that the fields can be ordered such that the offset plus the size of any field is less than or equal to the offset of the next field in the ordering. The ordering does not have to be the same as the order in which the fields are specified in the declaration of the type.</p>
<p>두 번째 보장이 필드들이 서로 다른 주소를 갖는다는 것을 의미하지는 않음에 유의하십시오. 크기가 0인 타입은 동일한 구조체 내의 다른 필드와 같은 주소를 가질 수 있습니다.</p>
<p>r[layout.repr.rust.unspecified] There are no other guarantees of data layout made by this representation.</p>
<p>r[layout.repr.c]</p>
<h3 id="the-c-representation"><a class="header" href="#the-c-representation">The <code>C</code> representation</a></h3>
<p>r[layout.repr.c.intro] The <code>C</code> representation is designed for dual purposes. One purpose is for creating types that are interoperable with the C Language. The second purpose is to create types that you can soundly perform operations on that rely on data layout such as reinterpreting values as a different type.</p>
<p>이러한 이중 목적 때문에, C 프로그래밍 언어와의 인터페이스에는 유용하지 않은 타입을 생성하는 것도 가능합니다.</p>
<p>r[layout.repr.c.constraint] This representation can be applied to structs, unions, and enums. The exception is <a href="items/enumerations.html#zero-variant-enums">zero-variant enums</a> for which the <code>C</code> representation is an error.</p>
<p>r[layout.repr.c.struct]</p>
<h4 id="reprc-구조체"><a class="header" href="#reprc-구조체"><code>#[repr(C)]</code> 구조체</a></h4>
<p>r[layout.repr.c.struct.align] The alignment of the struct is the alignment of the most-aligned field in it.</p>
<p>r[layout.repr.c.struct.size-field-offset] The size and offset of fields is determined by the following algorithm.</p>
<p>현재 오프셋 0바이트로 시작합니다.</p>
<p>구조체의 선언 순서대로 각 필드에 대해, 먼저 필드의 크기와 정렬을 결정합니다. 현재 오프셋이 필드의 정렬의 배수가 아니라면, 필드 정렬의 배수가 될 때까지 현재 오프셋에 패딩 바이트를 추가합니다. 해당 필드의 오프셋은 현재 오프셋 값이 됩니다. 그런 다음 현재 오프셋을 필드의 크기만큼 증가시킵니다.</p>
<p>마지막으로, 구조체의 크기는 현재 오프셋을 구조체의 정렬의 가장 가까운 배수로 올림한 값입니다.</p>
<p>다음은 의사코드로 설명된 이 알고리즘입니다.</p>
<!-- ignore: pseudocode -->
<pre><code class="language-rust ignore">/// 다음 주소가 `alignment`에 맞춰 정렬되도록 하기 위해
/// `offset` 뒤에 필요한 패딩의 양을 반환합니다.
fn padding_needed_for(offset: usize, alignment: usize) -&gt; usize {
    let misalignment = offset % alignment;
    if misalignment &gt; 0 {
        // `alignment`의 다음 배수로 올림
        alignment - misalignment
    } else {
        // 이미 `alignment`의 배수임
        0
    }
}

struct.alignment = struct.fields().map(|field| field.alignment).max();

let current_offset = 0;

for field in struct.fields_in_declaration_order() {
    // 현재 오프셋을 증가시켜 이 필드의 정렬의 배수가 되도록 합니다.
    // 첫 번째 필드의 경우, 이는 항상 0이 됩니다.
    // 건너뛴 바이트를 패딩 바이트라고 합니다.
    current_offset += padding_needed_for(current_offset, field.alignment);

    struct[field].offset = current_offset;

    current_offset += field.size;
}

struct.size = current_offset + padding_needed_for(current_offset, struct.alignment);</code></pre>
<blockquote>
<p>[!WARNING] This pseudocode uses a naive algorithm that ignores overflow issues for the sake of clarity. To perform memory layout computations in actual code, use <a href="std::alloc::Layout"><code>Layout</code></a>.</p>
</blockquote>
<blockquote>
<p>[!NOTE] This algorithm can produce zero-sized structs. In C, an empty struct declaration like <code>struct Foo { }</code> is illegal. However, both gcc and clang support options to enable such structs, and assign them size zero. C++, in contrast, gives empty structs a size of 1, unless they are inherited from or they are fields that have the <code>[[no_unique_address]]</code> attribute, in which case they do not increase the overall size of the struct.</p>
</blockquote>
<p>r[layout.repr.c.union]</p>
<h4 id="reprc-공용체"><a class="header" href="#reprc-공용체"><code>#[repr(C)]</code> 공용체</a></h4>
<p>r[layout.repr.c.union.intro] A union declared with <code>#[repr(C)]</code> will have the same size and alignment as an equivalent C union declaration in the C language for the target platform.</p>
<p>r[layout.repr.c.union.size-align] The union will have a size of the maximum size of all of its fields rounded to its alignment, and an alignment of the maximum alignment of all of its fields. These maximums may come from different fields.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
union Union {
    f1: u16,
    f2: [u8; 4],
}

assert_eq!(std::mem::size_of::&lt;Union&gt;(), 4);  // f2에서 옴
assert_eq!(std::mem::align_of::&lt;Union&gt;(), 2); // f1에서 옴

#[repr(C)]
union SizeRoundedUp {
   a: u32,
   b: [u16; 3],
}

assert_eq!(std::mem::size_of::&lt;SizeRoundedUp&gt;(), 8);  // b에서 크기 6,
                                                      // a의 정렬에 따라
                                                      // 8로 올림.
assert_eq!(std::mem::align_of::&lt;SizeRoundedUp&gt;(), 4); // a에서 옴
<span class="boring">}</span></code></pre></pre>
<p>r[layout.repr.c.enum]</p>
<h4 id="reprc-필드-없는-열거형"><a class="header" href="#reprc-필드-없는-열거형"><code>#[repr(C)]</code> 필드 없는 열거형</a></h4>
<p><a href="items/enumerations.html#field-less-enum">필드 없는 열거형</a>의 경우, <code>C</code> 표현은 대상 플랫폼의 C ABI에 대한 기본 <code>enum</code> 크기 및 정렬과 동일한 크기 및 정렬을 가집니다.</p>
<blockquote>
<p>[!NOTE] The enum representation in C is implementation defined, so this is really a “best guess”. In particular, this may be incorrect when the C code of interest is compiled with certain flags.</p>
</blockquote>
<blockquote>
<p>[!WARNING] There are crucial differences between an <code>enum</code> in the C language and Rust’s <a href="items/enumerations.html#field-less-enum">field-less enums</a> with this representation. An <code>enum</code> in C is mostly a <code>typedef</code> plus some named constants; in other words, an object of an <code>enum</code> type can hold any integer value. For example, this is often used for bitflags in <code>C</code>. In contrast, Rust’s <a href="items/enumerations.html#field-less-enum">field-less enums</a> can only legally hold the discriminant values, everything else is <a href="behavior-considered-undefined.html">undefined behavior</a>. Therefore, using a field-less enum in FFI to model a C <code>enum</code> is often wrong.</p>
</blockquote>
<p>r[layout.repr.c.adt]</p>
<h4 id="reprc-필드-있는-열거형"><a class="header" href="#reprc-필드-있는-열거형"><code>#[repr(C)]</code> 필드 있는 열거형</a></h4>
<p>r[layout.repr.c.adt.intro] The representation of a <code>repr(C)</code> enum with fields is a <code>repr(C)</code> struct with two fields, also called a “tagged union” in C:</p>
<p>r[layout.repr.c.adt.tag]</p>
<ul>
<li>모든 필드가 제거된 열거형의 <code>repr(C)</code> 버전 (“태그”)</li>
</ul>
<p>r[layout.repr.c.adt.fields]</p>
<ul>
<li>필드를 가진 각 변형의 필드들을 위한 <code>repr(C)</code> 구조체들의 <code>repr(C)</code> 공용체 (“페이로드”)</li>
</ul>
<blockquote>
<p>[!NOTE] Due to the representation of <code>repr(C)</code> structs and unions, if a variant has a single field there is no difference between putting that field directly in the union or wrapping it in a struct; any system which wishes to manipulate such an <code>enum</code>’s representation may therefore use whichever form is more convenient or consistent for them.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 이 Enum은 다음 구조체와 동일한 표현을 가집니다 ...
#[repr(C)]
enum MyEnum {
    A(u32),
    B(f32, u64),
    C { x: u32, y: u8 },
    D,
 }

// ... 이 구조체와.
#[repr(C)]
struct MyEnumRepr {
    tag: MyEnumDiscriminant,
    payload: MyEnumFields,
}

// 이것은 판별자 열거형입니다.
#[repr(C)]
enum MyEnumDiscriminant { A, B, C, D }

// 이것은 변형 공용체입니다.
#[repr(C)]
union MyEnumFields {
    A: MyAFields,
    B: MyBFields,
    C: MyCFields,
    D: MyDFields,
}

#[repr(C)]
#[derive(Copy, Clone)]
struct MyAFields(u32);

#[repr(C)]
#[derive(Copy, Clone)]
struct MyBFields(f32, u64);

#[repr(C)]
#[derive(Copy, Clone)]
struct MyCFields { x: u32, y: u8 }

// 이 구조체는 생략될 수 있으며(0크기 타입임), C/C++ 헤더에 있어야 합니다.
#[repr(C)]
#[derive(Copy, Clone)]
struct MyDFields;
<span class="boring">}</span></code></pre></pre>
<p>r[layout.repr.primitive]</p>
<h3 id="기본-표현-primitive-representations"><a class="header" href="#기본-표현-primitive-representations">기본 표현 (Primitive representations)</a></h3>
<p>r[layout.repr.primitive.intro] The <em>primitive representations</em> are the representations with the same names as the primitive integer types. That is: <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, <code>usize</code>, <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, and <code>isize</code>.</p>
<p>r[layout.repr.primitive.constraint] Primitive representations can only be applied to enumerations and have different behavior whether the enum has fields or no fields. It is an error for <a href="items/enumerations.html#zero-variant-enums">zero-variant enums</a> to have a primitive representation. Combining two primitive representations together is an error.</p>
<p>r[layout.repr.primitive.enum]</p>
<h4 id="primitive-representation-of-field-less-enums"><a class="header" href="#primitive-representation-of-field-less-enums">Primitive representation of field-less enums</a></h4>
<p><a href="items/enumerations.html#field-less-enum">필드 없는 열거형</a>의 경우, 기본 표현은 크기와 정렬을 동일한 이름의 기본 타입과 같게 설정합니다. 예를 들어, <code>u8</code> 표현을 가진 필드 없는 열거형은 0에서 255(포함) 사이의 판별자만 가질 수 있습니다.</p>
<p>r[layout.repr.primitive.adt]</p>
<h4 id="primitive-representation-of-enums-with-fields"><a class="header" href="#primitive-representation-of-enums-with-fields">Primitive representation of enums with fields</a></h4>
<p>기본 표현 열거형의 표현은 <code>repr(C)</code> 공용체입니다</p>
<blockquote>
<p>[!NOTE] This representation is unchanged if the tag is given its own member in the union, should that make manipulation more clear for you (although to follow the C++ standard the tag member should be wrapped in a <code>struct</code>).</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 이 열거형은 다음 공용체와 동일한 표현을 가집니다 ...
#[repr(u8)]
enum MyEnum {
    A(u32),
    B(f32, u64),
    C { x: u32, y: u8 },
    D,
 }

// ... 이 공용체와.
#[repr(C)]
union MyEnumRepr {
    A: MyVariantA,
    B: MyVariantB,
    C: MyVariantC,
    D: MyVariantD,
}

// 이것은 판별자 열거형입니다.
#[repr(u8)]
#[derive(Copy, Clone)]
enum MyEnumDiscriminant { A, B, C, D }

#[repr(C)]
#[derive(Clone, Copy)]
struct MyVariantA(MyEnumDiscriminant, u32);

#[repr(C)]
#[derive(Clone, Copy)]
struct MyVariantB(MyEnumDiscriminant, f32, u64);

#[repr(C)]
#[derive(Clone, Copy)]
struct MyVariantC { tag: MyEnumDiscriminant, x: u32, y: u8 }

#[repr(C)]
#[derive(Clone, Copy)]
struct MyVariantD(MyEnumDiscriminant);
<span class="boring">}</span></code></pre></pre>
<p>r[layout.repr.primitive-c]</p>
<h4 id="필드가-있는-열거형의-기본-표현과-reprc-결합하기"><a class="header" href="#필드가-있는-열거형의-기본-표현과-reprc-결합하기">필드가 있는 열거형의 기본 표현과 <code>#[repr(C)]</code> 결합하기</a></h4>
<p>필드가 있는 열거형의 경우, <code>repr(C)</code>와 기본 표현을 결합하는 것도 가능합니다(예: <code>repr(C, u8)</code>). 이는 판별자 열거형의 표현을 선택된 기본 타입으로 변경함으로써 <a href="type-layout.html#reprc-enums-with-fields"><code>repr(C)</code></a>를 수정합니다. 따라서 <code>u8</code> 표현을 선택했다면, 판별자 열거형은 1바이트의 크기와 정렬을 갖게 됩니다.</p>
<p><a href="type-layout.html#reprc-enums-with-fields">앞서</a> 나온 예시의 판별자 열거형은 다음과 같이 됩니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C, u8)] // `u8`이 추가됨
enum MyEnum {
    A(u32),
    B(f32, u64),
    C { x: u32, y: u8 },
    D,
 }

// ...

#[repr(u8)] // 따라서 여기서 `C` 대신 `u8`이 사용됨
enum MyEnumDiscriminant { A, B, C, D }

// ...
<span class="boring">}</span></code></pre></pre>
<p>예를 들어, <code>repr(C, u8)</code> 열거형은 257개의 고유한 판별자(“태그”)를 가질 수 없는 반면, <code>repr(C)</code> 속성만 있는 동일한 열거형은 문제없이 컴파일됩니다.</p>
<p><code>repr(C)</code>에 더해 기본 표현을 사용하면 <code>repr(C)</code> 형태로부터 열거형의 크기가 변경될 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
enum EnumC {
    Variant0(u8),
    Variant1,
}

#[repr(C, u8)]
enum Enum8 {
    Variant0(u8),
    Variant1,
}

#[repr(C, u16)]
enum Enum16 {
    Variant0(u8),
    Variant1,
}

// The size of the C representation is platform dependent
assert_eq!(std::mem::size_of::&lt;EnumC&gt;(), 8);
// 판별자를 위한 1바이트와 Enum8::Variant0의 값을 위한 1바이트
assert_eq!(std::mem::size_of::&lt;Enum8&gt;(), 2);
// 판별자를 위한 2바이트와 Enum16::Variant0의 값을 위한 1바이트
// 더하기 1바이트의 패딩.
assert_eq!(std::mem::size_of::&lt;Enum16&gt;(), 4);
<span class="boring">}</span></code></pre></pre>
<p>r[layout.repr.alignment]</p>
<h3 id="정렬-수정자"><a class="header" href="#정렬-수정자">정렬 수정자</a></h3>
<p>r[layout.repr.alignment.intro] The <code>align</code> and <code>packed</code> modifiers can be used to respectively raise or lower the alignment of <code>struct</code>s and <code>union</code>s. <code>packed</code> may also alter the padding between fields (although it will not alter the padding inside of any field). On their own, <code>align</code> and <code>packed</code> do not provide guarantees about the order of fields in the layout of a struct or the layout of an enum variant, although they may be combined with representations (such as <code>C</code>) which do provide such guarantees.</p>
<p>r[layout.repr.alignment.constraint-alignment] The alignment is specified as an integer parameter in the form of <code>#[repr(align(x))]</code> or <code>#[repr(packed(x))]</code>. The alignment value must be a power of two from 1 up to 2<sup>29</sup>. For <code>packed</code>, if no value is given, as in <code>#[repr(packed)]</code>, then the value is 1.</p>
<p>r[layout.repr.alignment.align] For <code>align</code>, if the specified alignment is less than the alignment of the type without the <code>align</code> modifier, then the alignment is unaffected.</p>
<p>r[layout.repr.alignment.packed] For <code>packed</code>, if the specified alignment is greater than the type’s alignment without the <code>packed</code> modifier, then the alignment and layout is unaffected.</p>
<p>r[layout.repr.alignment.packed-fields] The alignments of each field, for the purpose of positioning fields, is the smaller of the specified alignment and the alignment of the field’s type.</p>
<p>r[layout.repr.alignment.packed-padding] Inter-field padding is guaranteed to be the minimum required in order to satisfy each field’s (possibly altered) alignment (although note that, on its own, <code>packed</code> does not provide any guarantee about field ordering). An important consequence of these rules is that a type with <code>#[repr(packed(1))]</code> (or <code>#[repr(packed)]</code>) will have no inter-field padding.</p>
<p>r[layout.repr.alignment.constraint-exclusive] The <code>align</code> and <code>packed</code> modifiers cannot be applied on the same type and a <code>packed</code> type cannot transitively contain another <code>align</code>ed type. <code>align</code> and <code>packed</code> may only be applied to the <a href="type-layout.html#the-rust-representation"><code>Rust</code></a> and <a href="type-layout.html#the-c-representation"><code>C</code></a> representations.</p>
<p>r[layout.repr.alignment.enum] The <code>align</code> modifier can also be applied on an <code>enum</code>. When it is, the effect on the <code>enum</code>’s alignment is the same as if the <code>enum</code> was wrapped in a newtype <code>struct</code> with the same <code>align</code> modifier.</p>
<blockquote>
<p>[!NOTE] References to unaligned fields are not allowed because it is <a href="behavior-considered-undefined.html">undefined behavior</a>. When fields are unaligned due to an alignment modifier, consider the following options for using references and dereferences:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(packed)]
struct Packed {
    f1: u8,
    f2: u16,
}
let mut e = Packed { f1: 1, f2: 2 };
// 필드에 대한 참조를 생성하는 대신, 값을 로컬 변수로 복사하십시오.
let x = e.f2;
// 또는 참조를 생성하는 `println!`과 같은 상황에서는 중괄호를 사용하여
// 값의 복사본으로 변경하십시오.
println!("{}", {e.f2});
// 포인터가 필요한 경우, 포인터를 직접 역참조하는 대신
// 읽기 및 쓰기에 정렬되지 않은 메서드를 사용하십시오.
let ptr: *const u16 = &amp;raw const e.f2;
let value = unsafe { ptr.read_unaligned() };
let mut_ptr: *mut u16 = &amp;raw mut e.f2;
unsafe { mut_ptr.write_unaligned(3) }
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[layout.repr.transparent]</p>
<h3 id="the-transparent-representation"><a class="header" href="#the-transparent-representation">The <code>transparent</code> representation</a></h3>
<p>r[layout.repr.transparent.constraint-field] The <code>transparent</code> representation can only be used on a <a href="items/structs.html"><code>struct</code></a> or an <a href="items/enumerations.html"><code>enum</code></a> with a single variant that has:</p>
<ul>
<li>크기가 0이고 정렬이 1인 임의 개수의 필드 (예: <a href="special-types-and-traits.html#phantomdatat"><code>PhantomData&lt;T&gt;</code></a>), 그리고</li>
<li>최대 하나의 다른 필드.</li>
</ul>
<p>r[layout.repr.transparent.layout-abi] Structs and enums with this representation have the same layout and ABI as the only non-size 0 non-alignment 1 field, if present, or unit otherwise.</p>
<p>이는 <code>C</code> 표현과는 다릅니다. <code>C</code> 표현을 가진 구조체는 항상 <code>C</code> <code>struct</code>의 ABI를 갖는 반면, 예를 들어 기본(primitive) 필드를 가진 <code>transparent</code> 표현의 구조체는 해당 기본 필드의 ABI를 갖기 때문입니다.</p>
<p>r[layout.repr.transparent.constraint-exclusive] Because this representation delegates type layout to another type, it cannot be used with any other representation.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[interior-mut]</p>
<h1 id="내부-가변성"><a class="header" href="#내부-가변성">내부 가변성</a></h1>
<p>r[interior-mut.intro] Sometimes a type needs to be mutated while having multiple aliases. In Rust this is achieved using a pattern called <em>interior mutability</em>.</p>
<p>r[interior-mut.shared-ref] A type has interior mutability if its internal state can be changed through a <a href="types/pointer.html#shared-references-">shared reference</a> to it.</p>
<p>r[interior-mut.no-constraint] This goes against the usual <a href="behavior-considered-undefined.html">requirement</a> that the value pointed to by a shared reference is not mutated.</p>
<p>r[interior-mut.unsafe-cell] [<code>std::cell::UnsafeCell&lt;T&gt;</code>] type is the only allowed way to disable this requirement. When <code>UnsafeCell&lt;T&gt;</code> is immutably aliased, it is still safe to mutate, or obtain a mutable reference to, the <code>T</code> it contains.</p>
<p>r[interior-mut.mut-unsafe-cell] As with all other types, it is undefined behavior to have multiple <code>&amp;mut UnsafeCell&lt;T&gt;</code> aliases.</p>
<p>r[interior-mut.abstraction] Other types with interior mutability can be created by using <code>UnsafeCell&lt;T&gt;</code> as a field. The standard library provides a variety of types that provide safe interior mutability APIs.</p>
<p>r[interior-mut.ref-cell] For example, [<code>std::cell::RefCell&lt;T&gt;</code>] uses run-time borrow checks to ensure the usual rules around multiple references.</p>
<p>r[interior-mut.atomic] The [<code>std::sync::atomic</code>] module contains types that wrap a value that is only accessed with atomic operations, allowing the value to be shared and mutated across threads.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[subtype]</p>
<h1 id="subtyping-and-variance"><a class="header" href="#subtyping-and-variance">Subtyping and variance</a></h1>
<p>r[subtype.intro] Subtyping is implicit and can occur at any stage in type checking or inference.</p>
<p>r[subtype.kinds] Subtyping is restricted to two cases: variance with respect to lifetimes and between types with higher ranked lifetimes. If we were to erase lifetimes from types, then the only subtyping would be due to type equality.</p>
<p>다음 예시를 고려해보십시오: 문자열 리터럴은 항상 <code>'static</code> 라이프타임을 가집니다. 그럼에도 불구하고 우리는 <code>s</code>를 <code>t</code>에 할당할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn bar&lt;'a&gt;() {
    let s: &amp;'static str = "hi";
    let t: &amp;'a str = s;
}
<span class="boring">}</span></code></pre></pre>
<p><code>'static</code>은 라이프타임 매개변수 <code>'a</code>보다 오래 생존하므로, <code>&amp;'static str</code>은 <code>&amp;'a str</code>의 서브타입입니다.</p>
<p>r[subtype.higher-ranked] <a href="../nomicon/hrtb.html">Higher-ranked</a> <a href="types/function-pointer.html">function pointers</a> and <a href="types/trait-object.html">trait objects</a> have another subtype relation. They are subtypes of types that are given by substitutions of the higher-ranked lifetimes. Some examples:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 여기서 'a는 'static으로 대체됩니다
let subtype: &amp;(for&lt;'a&gt; fn(&amp;'a i32) -&gt; &amp;'a i32) = &amp;((|x| x) as fn(&amp;_) -&gt; &amp;_);
let supertype: &amp;(fn(&amp;'static i32) -&gt; &amp;'static i32) = subtype;

// 이는 트레잇 객체에 대해서도 유사하게 작동합니다
let subtype: &amp;(dyn for&lt;'a&gt; Fn(&amp;'a i32) -&gt; &amp;'a i32) = &amp;|x| x;
let supertype: &amp;(dyn Fn(&amp;'static i32) -&gt; &amp;'static i32) = subtype;

// 하나의 고차원 라이프타임을 다른 것으로 대체할 수도 있습니다
let subtype: &amp;(for&lt;'a, 'b&gt; fn(&amp;'a i32, &amp;'b i32)) = &amp;((|x, y| {}) as fn(&amp;_, &amp;_));
let supertype: &amp;for&lt;'c&gt; fn(&amp;'c i32, &amp;'c i32) = subtype;
<span class="boring">}</span></code></pre></pre>
<p>r[subtyping.variance]</p>
<h2 id="가변성-variance"><a class="header" href="#가변성-variance">가변성 (Variance)</a></h2>
<p>r[subtyping.variance.intro] Variance is a property that generic types have with respect to their arguments. A generic type’s <em>variance</em> in a parameter is how the subtyping of the parameter affects the subtyping of the type.</p>
<p>r[subtyping.variance.covariant]</p>
<ul>
<li><code>T</code>가 <code>U</code>의 서브타입일 때 <code>F&lt;T&gt;</code>가 <code>F&lt;U&gt;</code>의 서브타입이면, <code>F&lt;T&gt;</code>는 <code>T</code>에 대해 _공변적(covariant)_입니다 (서브타이핑이 “통과“함).</li>
</ul>
<p>r[subtyping.variance.contravariant]</p>
<ul>
<li><code>T</code>가 <code>U</code>의 서브타입일 때 <code>F&lt;U&gt;</code>가 <code>F&lt;T&gt;</code>의 서브타입이면, <code>F&lt;T&gt;</code>는 <code>T</code>에 대해 _반변적(contravariant)_입니다.</li>
</ul>
<p>r[subtyping.variance.invariant]</p>
<ul>
<li>그렇지 않으면 <code>F&lt;T&gt;</code>는 <code>T</code>에 대해 _불변적(invariant)_입니다 (서브타입 관계가 유도될 수 없음)</li>
</ul>
<p>r[subtyping.variance.builtin-types] Variance of types is automatically determined as follows</p>
<div class="table-wrapper"><table><thead><tr><th>유형</th><th><code>'a</code>에 대한 가변성</th><th><code>T</code>에 대한 가변성</th></tr></thead><tbody>
<tr><td><code>&amp;'a T</code></td><td>공변적</td><td>공변적</td></tr>
<tr><td><code>&amp;'a mut T</code></td><td>공변적</td><td>불변적</td></tr>
<tr><td><code>*const T</code></td><td></td><td>공변적</td></tr>
<tr><td><code>*mut T</code></td><td></td><td>불변적</td></tr>
<tr><td><code>[T]</code> 및 <code>[T; n]</code></td><td></td><td>공변적</td></tr>
<tr><td><code>fn() -&gt; T</code></td><td></td><td>공변적</td></tr>
<tr><td><code>fn(T) -&gt; ()</code></td><td></td><td>반변적</td></tr>
<tr><td><code>std::cell::UnsafeCell&lt;T&gt;</code></td><td></td><td>불변적</td></tr>
<tr><td><code>std::marker::PhantomData&lt;T&gt;</code></td><td></td><td>공변적</td></tr>
<tr><td><code>dyn Trait&lt;T&gt; + 'a</code></td><td>공변적</td><td>불변적</td></tr>
</tbody></table>
</div>
<p>r[subtyping.variance.user-composite-types] The variance of other <code>struct</code>, <code>enum</code>, and <code>union</code> types is decided by looking at the variance of the types of their fields. If the parameter is used in positions with different variances then the parameter is invariant. For example the following struct is covariant in <code>'a</code> and <code>T</code> and invariant in <code>'b</code>, <code>'c</code>, and <code>U</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::UnsafeCell;
struct Variance&lt;'a, 'b, 'c, T, U: 'a&gt; {
    x: &amp;'a U,               // 이것은 `Variance`를 'a에 대해 공변적으로 만들고,
// U에 대해서도 공변적으로 만들겠지만, U는 나중에 사용됩니다
    y: *const T,            // T에 대해 공변적
    z: UnsafeCell&lt;&amp;'b f64&gt;, // 'b에 대해 불변적
    w: *mut U,              // U에 대해 불변적이며, 전체 구조체를 불변적으로 만듦

    f: fn(&amp;'c ()) -&gt; &amp;'c () // 공변적이면서 동시에 반변적이므로, 구조체 내에서 'c를 불변적으로 만듭니다.
}
<span class="boring">}</span></code></pre></pre>
<p>r[subtyping.variance.builtin-composite-types] When used outside of an <code>struct</code>, <code>enum</code>, or <code>union</code>, the variance for parameters is checked at each location separately.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::cell::UnsafeCell;
</span>fn generic_tuple&lt;'short, 'long: 'short&gt;(
    // 'long은 튜플 내부의 공변적 위치와 불변적 위치 모두에서 사용됩니다.
    x: (&amp;'long u32, UnsafeCell&lt;&amp;'long u32&gt;),
) {
    // 이 위치들에서의 가변성은 개별적으로 계산되므로,
    // 공변적 위치에서 'long을 자유롭게 줄일 수 있습니다.
    let _: (&amp;'short u32, UnsafeCell&lt;&amp;'long u32&gt;) = x;
}

fn takes_fn_ptr&lt;'short, 'middle: 'short&gt;(
    // 'middle은 공변적 위치와 반변적 위치 모두에서 사용됩니다.
    f: fn(&amp;'middle ()) -&gt; &amp;'middle (),
) {
    // 이 위치들에서의 가변성은 개별적으로 계산되므로,
    // 공변적 위치에서 'middle을 자유롭게 줄일 수 있고
    // 반변적 위치에서 늘릴 수 있습니다.
    let _: fn(&amp;'static ()) -&gt; &amp;'short () = f;
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p>r[bound]</p>
<h1 id="트레잇과-라이프타임-바운드"><a class="header" href="#트레잇과-라이프타임-바운드">트레잇과 라이프타임 바운드</a></h1>
<p>r[bound.syntax]</p>
<pre><code class="language-grammar miscellaneous">TypeParamBounds -&gt; TypeParamBound ( `+` TypeParamBound )* `+`?

TypeParamBound -&gt; Lifetime | TraitBound | UseBound

TraitBound -&gt;
      ( `?` | ForLifetimes )? TypePath
    | `(` ( `?` | ForLifetimes )? TypePath `)`

LifetimeBounds -&gt; ( Lifetime `+` )* Lifetime?

Lifetime -&gt;
      LIFETIME_OR_LABEL
    | `'static`
    | `'_`

UseBound -&gt; `use` UseBoundGenericArgs

UseBoundGenericArgs -&gt;
      `&lt;` `&gt;`
    | `&lt;` ( UseBoundGenericArg `,`)* UseBoundGenericArg `,`? `&gt;`

UseBoundGenericArg -&gt;
      Lifetime
    | IDENTIFIER
    | `Self`
</code></pre>
<p>r[bound.intro] <a href="items/traits.html#trait-bounds">Trait</a> and lifetime bounds provide a way for <a href="items/generics.html">generic items</a> to restrict which types and lifetimes are used as their parameters. Bounds can be provided on any type in a <a href="items/generics.html#where-clauses">where clause</a>. There are also shorter forms for certain common cases:</p>
<ul>
<li><a href="items/generics.html">제네릭 매개변수</a> 선언 뒤에 작성된 바운드: <code>fn f&lt;A: Copy&gt;() {}</code>는 <code>fn f&lt;A&gt;() where A: Copy {}</code>와 같습니다.</li>
<li>트레잇 선언에서 <a href="items/traits.html#supertraits">상위 트레잇(supertraits)</a>으로서: <code>trait Circle : Shape {}</code>는 <code>trait Circle where Self : Shape {}</code>와 동일합니다.</li>
<li>트레잇 선언에서 <a href="items/associated-items.html#associated-types">연관 타입</a>에 대한 바운드로서: <code>trait A { type B: Copy; }</code>는 <code>trait A where Self::B: Copy { type B; }</code>와 동일합니다.</li>
</ul>
<p>r[bound.satisfaction] Bounds on an item must be satisfied when using the item. When type checking and borrow checking a generic item, the bounds can be used to determine that a trait is implemented for a type. For example, given <code>Ty: Trait</code></p>
<ul>
<li>제네릭 함수의 본문에서, <code>Trait</code>의 메서드를 <code>Ty</code> 값에 대해 호출할 수 있습니다. 마찬가지로 <code>Trait</code>의 연관 상수도 사용할 수 있습니다.</li>
<li><code>Trait</code>의 연관 타입을 사용할 수 있습니다.</li>
<li><code>T: Trait</code> 바운드가 있는 제네릭 함수 및 타입은 <code>T</code> 대신 <code>Ty</code>를 사용하여 사용될 수 있습니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">type Surface = i32;
</span>trait Shape {
    fn draw(&amp;self, surface: Surface);
    fn name() -&gt; &amp;'static str;
}

fn draw_twice&lt;T: Shape&gt;(surface: Surface, sh: T) {
    sh.draw(surface);           // T: Shape이므로 메서드 호출 가능
    sh.draw(surface);
}

fn copy_and_draw_twice&lt;T: Copy&gt;(surface: Surface, sh: T) where T: Shape {
    let shape_copy = sh;        // T: Copy이므로 sh를 이동시키지 않음
    draw_twice(surface, sh);    // T: Shape이므로 제네릭 함수 사용 가능
}

struct Figure&lt;S: Shape&gt;(S, S);

fn name_figure&lt;U: Shape&gt;(
    figure: Figure&lt;U&gt;,          // U: Shape이므로 타입 Figure&lt;U&gt;는 잘 형성됨(well-formed)
) {
    println!(
        "두 개의 {} 모양",
        U::name(),              // 연관 함수 사용 가능
    );
}
<span class="boring">}</span></code></pre></pre>
<p>r[bound.trivial] Bounds that don’t use the item’s parameters or <a href="trait-bounds.html#higher-ranked-trait-bounds">higher-ranked lifetimes</a> are checked when the item is defined. It is an error for such a bound to be false.</p>
<p>r[bound.special] [<code>Copy</code>], [<code>Clone</code>], and [<code>Sized</code>] bounds are also checked for certain generic types when using the item, even if the use does not provide a concrete type. It is an error to have <code>Copy</code> or <code>Clone</code> as a bound on a mutable reference, <a href="types/trait-object.html">trait object</a>, or <a href="types/slice.html">slice</a>. It is an error to have <code>Sized</code> as a bound on a trait object or slice.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A&lt;'a, T&gt;
where
    i32: Default,           // 허용되지만 유용하지는 않음
    i32: Iterator,          // 오류: `i32`는 반복자가 아님
    &amp;'a mut T: Copy,        // (사용 시) 오류: 트레잇 바운드가 만족되지 않음
    [T]: Sized,             // (사용 시) 오류: 컴파일 시에 크기를 알 수 없음
{
    f: &amp;'a T,
}
struct UsesA&lt;'a, T&gt;(A&lt;'a, T&gt;);
<span class="boring">}</span></code></pre></pre>
<p>r[bound.trait-object] Trait and lifetime bounds are also used to name <a href="types/trait-object.html">trait objects</a>.</p>
<p>r[bound.sized]</p>
<h2 id="sized"><a class="header" href="#sized"><code>?Sized</code></a></h2>
<p><code>?</code> is only used to relax the implicit [<code>Sized</code>] trait bound for <a href="types/parameters.html">type parameters</a> or <a href="items/associated-items.html#associated-types">associated types</a>. <code>?Sized</code> may not be used as a bound for other types.</p>
<p>r[bound.lifetime]</p>
<h2 id="라이프타임-바운드"><a class="header" href="#라이프타임-바운드">라이프타임 바운드</a></h2>
<p>r[bound.lifetime.intro] Lifetime bounds can be applied to types or to other lifetimes.</p>
<p>r[bound.lifetime.outlive-lifetime] The bound <code>'a: 'b</code> is usually read as <code>'a</code> <em>outlives</em> <code>'b</code>. <code>'a: 'b</code> means that <code>'a</code> lasts at least as long as <code>'b</code>, so a reference <code>&amp;'a ()</code> is valid whenever <code>&amp;'b ()</code> is valid.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;'a, 'b&gt;(x: &amp;'a i32, mut y: &amp;'b i32) where 'a: 'b {
    y = x;                      // 'a: 'b이므로 &amp;'a i32는 &amp;'b i32의 서브타입입니다
    let r: &amp;'b &amp;'a i32 = &amp;&amp;0;   // 'a: 'b이므로 &amp;'b &amp;'a i32는 잘 형성되었습니다
}
<span class="boring">}</span></code></pre></pre>
<p>r[bound.lifetime.outlive-type] <code>T: 'a</code> means that all lifetime parameters of <code>T</code> outlive <code>'a</code>. For example, if <code>'a</code> is an unconstrained lifetime parameter, then <code>i32: 'static</code> and <code>&amp;'static str: 'a</code> are satisfied, but <code>Vec&lt;&amp;'a ()&gt;: 'static</code> is not.</p>
<p>r[bound.higher-ranked]</p>
<h2 id="고차원-트레잇-바운드"><a class="header" href="#고차원-트레잇-바운드">고차원 트레잇 바운드</a></h2>
<p>r[bound.higher-ranked.syntax]</p>
<pre><code class="language-grammar miscellaneous">ForLifetimes -&gt; `for` GenericParams
</code></pre>
<p>r[bound.higher-ranked.intro] Trait bounds may be <em>higher ranked</em> over lifetimes. These bounds specify a bound that is true <em>for all</em> lifetimes. For example, a bound such as <code>for&lt;'a&gt; &amp;'a T: PartialEq&lt;i32&gt;</code> would require an implementation like</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct T;
</span>impl&lt;'a&gt; PartialEq&lt;i32&gt; for &amp;'a T {
    // ...
<span class="boring">   fn eq(&amp;self, other: &amp;i32) -&gt; bool {true}
</span>}
<span class="boring">}</span></code></pre></pre>
<p>그러면 어떤 라이프타임을 가진 <code>&amp;'a T</code>라도 <code>i32</code>와 비교하는 데 사용될 수 있습니다.</p>
<p>여기서는 고차원 바운드만 사용될 수 있는데, 이는 참조의 라이프타임이 함수의 모든 가능한 라이프타임 매개변수보다 짧기 때문입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn call_on_ref_zero&lt;F&gt;(f: F) where for&lt;'a&gt; F: Fn(&amp;'a i32) {
    let zero = 0;
    f(&amp;zero);
}
<span class="boring">}</span></code></pre></pre>
<p>r[bound.higher-ranked.trait] Higher-ranked lifetimes may also be specified just before the trait: the only difference is the <a href="names/scopes.html#higher-ranked-trait-bound-scopes">scope</a> of the lifetime parameter, which extends only to the end of the following trait instead of the whole bound. This function is equivalent to the last one.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn call_on_ref_zero&lt;F&gt;(f: F) where F: for&lt;'a&gt; Fn(&amp;'a i32) {
    let zero = 0;
    f(&amp;zero);
}
<span class="boring">}</span></code></pre></pre>
<p>r[bound.implied]</p>
<h2 id="함축된-바운드"><a class="header" href="#함축된-바운드">함축된 바운드</a></h2>
<p>r[bound.implied.intro] Lifetime bounds required for types to be well-formed are sometimes inferred.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn requires_t_outlives_a&lt;'a, T&gt;(x: &amp;'a T) {}
<span class="boring">}</span></code></pre></pre>
<p>타입 <code>&amp;'a T</code>가 잘 형성되기 위해서는 타입 매개변수 <code>T</code>가 <code>'a</code>보다 오래 살아야 합니다. 이는 함수 시그니처에 <code>T: 'a</code>가 성립해야만 유효한 <code>&amp;'a T</code> 타입이 포함되어 있기 때문에 추론됩니다.</p>
<p>r[bound.implied.context] Implied bounds are added for all parameters and outputs of functions. Inside of <code>requires_t_outlives_a</code> you can assume <code>T: 'a</code> to hold even if you don’t explicitly specify this:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn requires_t_outlives_a_not_implied&lt;'a, T: 'a&gt;() {}

fn requires_t_outlives_a&lt;'a, T&gt;(x: &amp;'a T) {
    // 이 코드는 컴파일됩니다. 참조 타입 `&amp;'a T`에 의해
    // `T: 'a`가 함축되기 때문입니다.
    requires_t_outlives_a_not_implied::&lt;'a, T&gt;();
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail E0309 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn requires_t_outlives_a_not_implied&lt;'a, T: 'a&gt;() {}
</span>fn not_implied&lt;'a, T&gt;() {
    // 이 코드는 오류가 발생합니다. 함수 시그니처에 의해
    // `T: 'a`가 함축되지 않기 때문입니다.
    requires_t_outlives_a_not_implied::&lt;'a, T&gt;();
}
<span class="boring">}</span></code></pre></pre>
<p>r[bound.implied.trait] Only lifetime bounds are implied, trait bounds still have to be explicitly added. The following example therefore causes an error:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0277 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Debug;
struct IsDebug&lt;T: Debug&gt;(T);
// error[E0277]: `T`가 `Debug`를 구현하지 않음
fn doesnt_specify_t_debug&lt;T&gt;(x: IsDebug&lt;T&gt;) {}
<span class="boring">}</span></code></pre></pre>
<p>r[bound.implied.def] Lifetime bounds are also inferred for type definitions and impl blocks for any type:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Struct&lt;'a, T&gt; {
    // 이것이 잘 형성되기 위해서는 `T: 'a`가 필요하며,
    // 이는 컴파일러에 의해 추론됩니다.
    field: &amp;'a T,
}

enum Enum&lt;'a, T&gt; {
    // 이것이 잘 형성되기 위해서는 `T: 'a`가 필요하며,
    // 이는 컴파일러에 의해 추론됩니다.
    //
    // `Enum::OtherVariant`만 사용하는 경우에도
    // `T: 'a`가 필요함에 유의하세요.
    SomeVariant(&amp;'a T),
    OtherVariant,
}

trait Trait&lt;'a, T: 'a&gt; {}

// 이 코드는 오류가 발생합니다. impl 헤더의 어떤 타입에 의해서도
// `T: 'a`가 함축되지 않기 때문입니다.
//     impl&lt;'a, T&gt; Trait&lt;'a, T&gt; for () {}

// 이 코드는 컴파일됩니다. 셀프 타입 `&amp;'a T`에 의해 `T: 'a`가 함축되기 때문입니다.
impl&lt;'a, T&gt; Trait&lt;'a, T&gt; for &amp;'a T {}
<span class="boring">}</span></code></pre></pre>
<p>r[bound.use]</p>
<h2 id="사용-바운드"><a class="header" href="#사용-바운드">사용 바운드</a></h2>
<p>일부 바운드 목록에는 <code>impl Trait</code> <a href="types/impl-trait.html#abstract-return-types">추상 반환 타입(abstract return type)</a>에 의해 캡처되는 제네릭 매개변수를 제어하기 위해 <code>use&lt;..&gt;</code> 바운드가 포함될 수 있습니다. 자세한 내용은 <a href="types/impl-trait.html#precise-capturing">정밀한 캡처(precise capturing)</a>를 참조하세요.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[coerce]</p>
<h1 id="타입-강제-변환"><a class="header" href="#타입-강제-변환">타입 강제 변환</a></h1>
<p>r[coerce.intro] <strong>Type coercions</strong> are implicit operations that change the type of a value. They happen automatically at specific locations and are highly restricted in what types actually coerce.</p>
<p>r[coerce.as] Any conversions allowed by coercion can also be explicitly performed by the <a href="expressions/operator-expr.html#type-cast-expressions">type cast operator</a>, <code>as</code>.</p>
<p>강제 변환은 원래 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md">RFC 401</a>에서 정의되었으며, <a href="https://github.com/rust-lang/rfcs/blob/master/text/1558-closure-to-fn-coercion.md">RFC 1558</a>에서 확장되었습니다.</p>
<p>r[coerce.site]</p>
<h2 id="강제-변환-지점"><a class="header" href="#강제-변환-지점">강제 변환 지점</a></h2>
<p>r[coerce.site.intro] A coercion can only occur at certain coercion sites in a program; these are typically places where the desired type is explicit or can be derived by propagation from explicit types (without type inference). Possible coercion sites are:</p>
<p>r[coerce.site.let]</p>
<ul>
<li>
<p>명시적인 타입이 주어진 <code>let</code> 구문.</p>
<p>예를 들어, 다음 코드에서 <code>&amp;mut 42</code>는 <code>&amp;i8</code> 타입으로 강제 변환됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _: &amp;i8 = &amp;mut 42;
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<p>r[coerce.site.value]</p>
<ul>
<li><code>static</code> 및 <code>const</code> 아이템 선언 (<code>let</code> 구문과 유사함).</li>
</ul>
<p>r[coerce.site.argument]</p>
<ul>
<li>
<p>함수 호출 인자</p>
<p>강제 변환되는 값은 실제 매개변수(actual parameter)이며, 이는 형식 매개변수(formal parameter)의 타입으로 강제 변환됩니다.</p>
<p>예를 들어, 다음 코드에서 <code>&amp;mut 42</code>는 <code>&amp;i8</code> 타입으로 강제 변환됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn bar(_: &amp;i8) { }

fn main() {
    bar(&amp;mut 42);
}</code></pre></pre>
<p>메서드 호출의 경우, 리시버(<code>self</code> 매개변수) 타입은 다르게 강제 변환됩니다. 자세한 내용은 <a href="expressions/method-call-expr.html">메서드 호출 표현식(method-call expressions)</a> 문서를 참조하세요.</p>
</li>
</ul>
<p>r[coerce.site.constructor]</p>
<ul>
<li>
<p>구조체, 공용체, 또는 열거형 변형 필드의 인스턴스화</p>
<p>예를 들어, 다음 코드에서 <code>&amp;mut 42</code>는 <code>&amp;i8</code> 타입으로 강제 변환됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024">struct Foo&lt;'a&gt; { x: &amp;'a i8 }

fn main() {
    Foo { x: &amp;mut 42 };
}</code></pre></pre>
</li>
</ul>
<p>r[coerce.site.return]</p>
<ul>
<li>
<p>함수 결과 — 세미콜론으로 끝나지 않은 블록의 마지막 줄 또는 <code>return</code> 구문의 모든 표현식</p>
<p>예를 들어, 다음 코드에서 <code>x</code>는 <code>&amp;dyn Display</code> 타입으로 강제 변환됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Display;
fn foo(x: &amp;u32) -&gt; &amp;dyn Display {
    x
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<p>r[coerce.site.subexpr] If the expression in one of these coercion sites is a coercion-propagating expression, then the relevant sub-expressions in that expression are also coercion sites. Propagation recurses from these new coercion sites. Propagating expressions and their relevant sub-expressions are:</p>
<p>r[coerce.site.array]</p>
<ul>
<li>배열 리터럴 (배열의 타입이 <code>[U; n]</code>인 경우). 배열 리터럴의 각 하위 표현식은 <code>U</code> 타입으로의 강제 변환을 위한 강제 변환 지점입니다.</li>
</ul>
<p>r[coerce.site.repeat]</p>
<ul>
<li>반복 구문을 사용하는 배열 리터럴 (배열의 타입이 <code>[U; n]</code>인 경우). 반복되는 하위 표현식은 <code>U</code> 타입으로의 강제 변환을 위한 강제 변환 지점입니다.</li>
</ul>
<p>r[coerce.site.tuple]</p>
<ul>
<li>튜플 (튜플이 <code>(U_0, U_1, ..., U_n)</code> 타입으로의 강제 변환 지점인 경우). 각 하위 표현식은 해당 타입으로의 강제 변환 지점입니다. 예를 들어, 0번째 하위 표현식은 <code>U_0</code> 타입으로의 강제 변환 지점입니다.</li>
</ul>
<p>r[coerce.site.parenthesis]</p>
<ul>
<li>괄호로 묶인 하위 표현식 (<code>(e)</code>): 표현식의 타입이 <code>U</code>인 경우, 하위 표현식은 <code>U</code>로의 강제 변환 지점입니다.</li>
</ul>
<p>r[coerce.site.block]</p>
<ul>
<li>블록: 블록의 타입이 <code>U</code>인 경우, 블록의 마지막 표현식(세미콜론으로 끝나지 않은 경우)은 <code>U</code>로의 강제 변환 지점입니다. 여기에는 블록이 알려진 타입을 가진 경우 <code>if</code>/<code>else</code>와 같은 제어 흐름 구문의 일부인 블록도 포함됩니다.</li>
</ul>
<p>r[coerce.types]</p>
<h2 id="강제-변환-타입"><a class="header" href="#강제-변환-타입">강제 변환 타입</a></h2>
<p>r[coerce.types.intro] Coercion is allowed between the following types:</p>
<p>r[coerce.types.reflexive]</p>
<ul>
<li><code>T</code>가 <code>U</code>의 <a href="subtyping.html">서브타입(subtype)</a>인 경우 <code>T</code>에서 <code>U</code>로 (<em>반사적 사례</em>)</li>
</ul>
<p>r[coerce.types.transitive]</p>
<ul>
<li>
<p><code>T_1</code>이 <code>T_2</code>로 강제 변환되고 <code>T_2</code>가 <code>T_3</code>으로 강제 변환되는 경우 <code>T_1</code>에서 <code>T_3</code>으로 (<em>이행적 사례</em>)</p>
<p>이는 아직 완전히 지원되지 않음에 유의하세요.</p>
</li>
</ul>
<p>r[coerce.types.mut-reborrow]</p>
<ul>
<li><code>&amp;mut T</code>에서 <code>&amp;T</code>로</li>
</ul>
<p>r[coerce.types.mut-pointer]</p>
<ul>
<li><code>*mut T</code>에서 <code>*const T</code>로</li>
</ul>
<p>r[coerce.types.ref-to-pointer]</p>
<ul>
<li><code>&amp;T</code>에서 <code>*const T</code>로</li>
</ul>
<p>r[coerce.types.mut-to-pointer]</p>
<ul>
<li><code>&amp;mut T</code>에서 <code>*mut T</code>로</li>
</ul>
<p>r[coerce.types.deref]</p>
<ul>
<li>
<p><code>T</code>가 <code>Deref&lt;Target = U&gt;</code>를 구현하는 경우 <code>&amp;T</code> 또는 <code>&amp;mut T</code>에서 <code>&amp;U</code>로. 예를 들어:</p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::ops::Deref;

struct CharContainer {
    value: char,
}

impl Deref for CharContainer {
    type Target = char;

    fn deref&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a char {
        &amp;self.value
    }
}

fn foo(arg: &amp;char) {}

fn main() {
    let x = &amp;mut CharContainer { value: 'y' };
    foo(x); //&amp;mut CharContainer가 &amp;char로 강제 변환됩니다.
}</code></pre></pre>
</li>
</ul>
<p>r[coerce.types.deref-mut]</p>
<ul>
<li><code>T</code>가 <code>DerefMut&lt;Target = U&gt;</code>를 구현하는 경우 <code>&amp;mut T</code>에서 <code>&amp;mut U</code>로.</li>
</ul>
<p>r[coerce.types.unsize]</p>
<ul>
<li>
<p>TyCtor(<code>T</code>)에서 TyCtor(<code>U</code>)로. 여기서 TyCtor(<code>T</code>)는 다음 중 하나입니다.</p>
<ul>
<li>
<p><code>&amp;T</code></p>
</li>
<li>
<p><code>&amp;mut T</code></p>
</li>
<li>
<p><code>*const T</code></p>
</li>
<li>
<p><code>*mut T</code></p>
</li>
<li>
<p><code>Box&lt;T&gt;</code>
여기서 <code>U</code>는 <a href="type-coercions.html#unsized-coercions">크기 미지정 강제 변환(unsized coercion)</a>을 통해 <code>T</code>로부터 얻을 수 있는 타입입니다.</p>
<!--In the future, coerce_inner will be recursively extended to tuples and
structs. In addition, coercions from subtraits to supertraits will be
added. See [RFC 401] for more details.-->
</li>
</ul>
</li>
</ul>
<p>r[coerce.types.fn]</p>
<ul>
<li>함수 아이템 타입에서 <code>fn</code> 포인터로</li>
</ul>
<p>r[coerce.types.closure]</p>
<ul>
<li>캡처하지 않는 클로저에서 <code>fn</code> 포인터로</li>
</ul>
<p>r[coerce.types.never]</p>
<ul>
<li><code>!</code>에서 임의의 <code>T</code>로</li>
</ul>
<p>r[coerce.unsize]</p>
<h3 id="unsized-coercions"><a class="header" href="#unsized-coercions">Unsized coercions</a></h3>
<p>r[coerce.unsize.intro] The following coercions are called <code>unsized coercions</code>, since they relate to converting types to unsized types, and are permitted in a few cases where other coercions are not, as described above. They can still happen anywhere else a coercion can occur.</p>
<p>r[coerce.unsize.trait] Two traits, <a href="std::marker::Unsize"><code>Unsize</code></a> and <a href="std::ops::CoerceUnsized"><code>CoerceUnsized</code></a>, are used to assist in this process and expose it for library use. The following coercions are built-ins and, if <code>T</code> can be coerced to <code>U</code> with one of them, then an implementation of <code>Unsize&lt;U&gt;</code> for <code>T</code> will be provided:</p>
<p>r[coerce.unsize.slice]</p>
<ul>
<li><code>[T; n]</code>에서 <code>[T]</code>로.</li>
</ul>
<p>r[coerce.unsize.trait-object]</p>
<ul>
<li><code>T</code>가 <code>U + Sized</code>를 구현하고 <code>U</code>가 <a href="items/traits.html#dyn-compatibility">dyn 호환(dyn compatible)</a>인 경우, <code>T</code>에서 <code>dyn U</code>로.</li>
</ul>
<p>r[coerce.unsize.trait-upcast]</p>
<ul>
<li><code>U</code>가 <code>T</code>의 <a href="items/traits.html#supertraits">상위 트레잇(supertraits)</a> 중 하나인 경우, <code>dyn T</code>에서 <code>dyn U</code>로.
<ul>
<li>이는 자동 트레잇을 제거하는 것을 허용합니다. 즉, <code>dyn T + Auto</code>에서 <code>dyn U</code>로의 강제 변환이 허용됩니다.</li>
<li>주요 트레잇(principal trait)이 자동 트레잇을 상위 트레잇으로 가지고 있는 경우 자동 트레잇을 추가하는 것을 허용합니다. 즉, <code>trait T: U + Send {}</code>가 주어지면, <code>dyn T</code>에서 <code>dyn T + Send</code> 또는 <code>dyn U + Send</code>로의 강제 변환이 허용됩니다.</li>
</ul>
</li>
</ul>
<p>r[coerce.unsized.composite]</p>
<ul>
<li>다음의 경우, <code>Foo&lt;..., T, ...&gt;</code>에서 <code>Foo&lt;..., U, ...&gt;</code>로.
<ul>
<li><code>Foo</code>는 구조체입니다.</li>
<li><code>T</code>가 <code>Unsize&lt;U&gt;</code>를 구현합니다.</li>
<li><code>Foo</code>의 마지막 필드가 <code>T</code>를 포함하는 타입을 가집니다.</li>
<li>해당 필드의 타입이 <code>Bar&lt;T&gt;</code>라면, <code>Bar&lt;T&gt;</code>는 <code>Unsize&lt;Bar&lt;U&gt;&gt;</code>를 구현합니다.</li>
<li><code>T</code>가 다른 필드의 타입에는 포함되지 않습니다.</li>
</ul>
</li>
</ul>
<p>r[coerce.unsized.pointer] Additionally, a type <code>Foo&lt;T&gt;</code> can implement <code>CoerceUnsized&lt;Foo&lt;U&gt;&gt;</code> when <code>T</code> implements <code>Unsize&lt;U&gt;</code> or <code>CoerceUnsized&lt;Foo&lt;U&gt;&gt;</code>. This allows it to provide an unsized coercion to <code>Foo&lt;U&gt;</code>.</p>
<blockquote>
<p>[!NOTE] While the definition of the unsized coercions and their implementation has been stabilized, the traits themselves are not yet stable and therefore can’t be used directly in stable Rust.</p>
</blockquote>
<p>r[coerce.least-upper-bound]</p>
<h2 id="최소-상한-강제-변환"><a class="header" href="#최소-상한-강제-변환">최소 상한 강제 변환</a></h2>
<p>r[coerce.least-upper-bound.intro] In some contexts, the compiler must coerce together multiple types to try and find the most general type. This is called a “Least Upper Bound” coercion. LUB coercion is used and only used in the following situations:</p>
<ul>
<li>일련의 if 분기들에 대한 공통 타입을 찾을 때.</li>
<li>일련의 매치 암(match arms)들에 대한 공통 타입을 찾을 때.</li>
<li>배열 요소들에 대한 공통 타입을 찾을 때.</li>
<li>여러 개의 return 문이 있는 클로저의 반환 타입을 찾을 때.</li>
<li>여러 개의 return 문이 있는 함수의 반환 타입을 검사할 때.</li>
</ul>
<p>r[coerce.least-upper-bound.target] In each such case, there are a set of types <code>T0..Tn</code> to be mutually coerced to some target type <code>T_t</code>, which is unknown to start.</p>
<p>r[coerce.least-upper-bound.computation] Computing the LUB coercion is done iteratively. The target type <code>T_t</code> begins as the type <code>T0</code>. For each new type <code>Ti</code>, we consider whether</p>
<p>r[coerce.least-upper-bound.computation-identity]</p>
<ul>
<li><code>Ti</code>가 현재 대상 타입 <code>T_t</code>로 강제 변환될 수 있다면, 아무런 변경도 하지 않습니다.</li>
</ul>
<p>r[coerce.least-upper-bound.computation-replace]</p>
<ul>
<li>그렇지 않은 경우, <code>T_t</code>가 <code>Ti</code>로 강제 변환될 수 있는지 확인합니다. 만약 가능하다면, <code>T_t</code>는 <code>Ti</code>로 변경됩니다. (이 확인 과정은 지금까지 고려된 모든 소스 표현식들에 암시적 강제 변환이 있는지 여부도 조건으로 합니다.)</li>
</ul>
<p>r[coerce.least-upper-bound.computation-unify]</p>
<ul>
<li>그렇지 않다면, <code>T_t</code>와 <code>Ti</code> 사이의 상호 상위 타입(mutual supertype) 계산을 시도하며, 이것이 새로운 대상 타입이 됩니다.</li>
</ul>
<h3 id="예"><a class="header" href="#예">예:</a></h3>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let (a, b, c) = (0, 1, 2);
</span>// if 분기들의 경우
let bar = if true {
    a
} else if false {
    b
} else {
    c
};

// 매치 암들의 경우
let baw = match 42 {
    0 =&gt; a,
    1 =&gt; b,
    _ =&gt; c,
};

// 배열 요소들의 경우
let bax = [a, b, c];

// 여러 개의 return 문이 있는 클로저의 경우
let clo = || {
    if true {
        a
    } else if false {
        b
    } else {
        c
    }
};
let baz = clo();

// 여러 개의 return 문이 있는 함수의 타입 검사의 경우
fn foo() -&gt; i32 {
    let (a, b, c) = (0, 1, 2);
    match 42 {
        0 =&gt; a,
        1 =&gt; b,
        _ =&gt; c,
    }
}
<span class="boring">}</span></code></pre></pre>
<p>이 예제들에서 <code>ba*</code> 변수들의 타입은 LUB 강제 변환을 통해 찾아집니다. 그리고 컴파일러는 함수 <code>foo</code>를 처리하는 과정에서 <code>a</code>, <code>b</code>, <code>c</code>의 LUB 강제 변환 결과가 <code>i32</code>인지 확인합니다.</p>
<h3 id="주의-사항"><a class="header" href="#주의-사항">주의 사항</a></h3>
<p>이 설명은 분명히 비공식적인 것입니다. 이를 더 정밀하게 만드는 작업은 러스트 타입 검사기를 더 정밀하게 명세하려는 전반적인 노력의 일환으로 진행될 예정입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r<a href="destructors.html">destructors</a></p>
<h1 id="소멸자"><a class="header" href="#소멸자">소멸자</a></h1>
<p>r[destructors.intro] When an <a href="glossary.html#initialized">initialized</a> <a href="variables.html">variable</a> or <a href="expressions.html#temporaries">temporary</a> goes out of <a href="destructors.html#drop-scopes">scope</a>, its <em>destructor</em> is run or it is <em>dropped</em>. <a href="expressions/operator-expr.html#assignment-expressions">Assignment</a> also runs the destructor of its left-hand operand, if it’s initialized. If a variable has been partially initialized, only its initialized fields are dropped.</p>
<p>r[destructors.operation] The destructor of a type <code>T</code> consists of:</p>
<ol>
<li>If <code>T: Drop</code>, calling <a href="core::ops::Drop::drop"><code>&lt;T as core::ops::Drop&gt;::drop</code></a></li>
<li>모든 필드에 대해 재귀적으로 소멸자 실행.
<ul>
<li><a href="types/struct.html">구조체(struct)</a>의 필드들은 선언된 순서대로 드롭됩니다.</li>
<li>활성 <a href="types/enum.html">열거형 변형(enum variant)</a>의 필드들은 선언된 순서대로 드롭됩니다.</li>
<li><a href="types/tuple.html">튜플(tuple)</a>의 필드들은 순서대로 드롭됩니다.</li>
<li><a href="types/array.html">배열(array)</a> 또는 소유권이 있는 <a href="types/slice.html">슬라이스(slice)</a>의 요소들은 첫 번째 요소부터 마지막 요소 순으로 드롭됩니다.</li>
<li><a href="types/closure.html">클로저(closure)</a>가 이동(move)으로 캡처한 변수들은 지정되지 않은 순서대로 드롭됩니다.</li>
<li><a href="types/trait-object.html">트레잇 객체(Trait objects)</a>는 기저 타입(underlying type)의 소멸자를 실행합니다.</li>
<li>다른 타입들은 추가적인 드롭을 발생시키지 않습니다.</li>
</ul>
</li>
</ol>
<p>r[destructors.drop_in_place] If a destructor must be run manually, such as when implementing your own smart pointer, [<code>core::ptr::drop_in_place</code>] can be used.</p>
<p>몇 가지 예제:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct PrintOnDrop(&amp;'static str);

impl Drop for PrintOnDrop {
    fn drop(&amp;mut self) {
        println!("{}", self.0);
    }
}

let mut overwritten = PrintOnDrop("덮어써질 때 드롭됨");
overwritten = PrintOnDrop("스코프가 끝날 때 드롭됨");

let tuple = (PrintOnDrop("튜플 첫 번째"), PrintOnDrop("튜플 두 번째"));

let moved;
// 할당 시 소멸자가 실행되지 않음.
moved = PrintOnDrop("이동될 때 드롭됨");
// 지금 드롭되지만, 그 후에는 초기화되지 않은 상태가 됩니다.
moved;

// 초기화되지 않은 상태에서는 드롭되지 않습니다.
let uninitialized: PrintOnDrop;

// 부분 이동 후에는 남아 있는 필드만 드롭됩니다.
let mut partial_move = (PrintOnDrop("first"), PrintOnDrop("잊힘(forgotten)"));
// 부분 이동을 수행하여 `partial_move.0`만 초기화된 상태로 남깁니다.
core::mem::forget(partial_move.1);
// partial_move의 스코프가 끝나면 첫 번째 필드만 드롭됩니다.
<span class="boring">}</span></code></pre></pre>
<p>r[destructors.scope]</p>
<h2 id="드롭-스코프"><a class="header" href="#드롭-스코프">드롭 스코프</a></h2>
<p>r[destructors.scope.intro] Each variable or temporary is associated to a <em>drop scope</em>. When control flow leaves a drop scope all variables associated to that scope are dropped in reverse order of declaration (for variables) or creation (for temporaries).</p>
<p>r[destructors.scope.desugaring] Drop scopes can be determined by replacing <a href="expressions/loop-expr.html#iterator-loops"><code>for</code></a>, <a href="expressions/if-expr.html#if-expressions"><code>if</code></a>, and <a href="expressions/loop-expr.html#predicate-loops"><code>while</code></a> expressions with equivalent expressions using <a href="expressions/match-expr.html"><code>match</code></a>, <a href="expressions/loop-expr.html#infinite-loops"><code>loop</code></a> and <code>break</code>.</p>
<p>r[destructors.scope.operators] Overloaded operators are not distinguished from built-in operators and <a href="patterns.html#binding-modes">binding modes</a> are not considered.</p>
<p>r[destructors.scope.list] Given a function, or closure, there are drop scopes for:</p>
<p>r[destructors.scope.function]</p>
<ul>
<li>함수 전체</li>
</ul>
<p>r[destructors.scope.statement]</p>
<ul>
<li>각 <a href="statements.html">구문(statement)</a></li>
</ul>
<p>r[destructors.scope.expression]</p>
<ul>
<li>각 <a href="expressions.html">표현식(expression)</a></li>
</ul>
<p>r[destructors.scope.block]</p>
<ul>
<li>함수 본문을 포함한 각 블록
<ul>
<li><a href="expressions/block-expr.html">블록 표현식(block expression)</a>의 경우, 블록의 스코프와 표현식의 스코프는 동일합니다.</li>
</ul>
</li>
</ul>
<p>r[destructors.scope.match-arm]</p>
<ul>
<li><code>match</code> 표현식의 각 암(arm)</li>
</ul>
<p>r[destructors.scope.nesting] Drop scopes are nested within one another as follows. When multiple scopes are left at once, such as when returning from a function, variables are dropped from the inside outwards.</p>
<p>r[destructors.scope.nesting.function]</p>
<ul>
<li>함수 전체 스코프가 최외곽 스코프입니다.</li>
</ul>
<p>r[destructors.scope.nesting.function-body]</p>
<ul>
<li>함수 본문 블록은 함수 전체 스코프 내에 포함됩니다.</li>
</ul>
<p>r[destructors.scope.nesting.expr-statement]</p>
<ul>
<li>표현식 구문 내 표현식의 부모는 해당 구문의 스코프입니다.</li>
</ul>
<p>r[destructors.scope.nesting.let-initializer]</p>
<ul>
<li><a href="statements.html#let-statements"><code>let</code> 구문(let statement)</a>의 초기화식의 부모는 해당 <code>let</code> 구문의 스코프입니다.</li>
</ul>
<p>r[destructors.scope.nesting.statement]</p>
<ul>
<li>구문 스코프의 부모는 해당 구문을 포함하는 블록의 스코프입니다.</li>
</ul>
<p>r[destructors.scope.nesting.match-guard]</p>
<ul>
<li><code>match</code> 가드(guard) 표현식의 부모는 해당 가드가 속한 매치 암의 스코프입니다.</li>
</ul>
<p>r[destructors.scope.nesting.match-arm]</p>
<ul>
<li><code>match</code> 표현식에서 <code>=&gt;</code> 뒤에 오는 표현식의 부모는 그것이 속한 매치 암의 스코프입니다.</li>
</ul>
<p>r[destructors.scope.nesting.match]</p>
<ul>
<li>매치 암 스코프의 부모는 그것이 속한 <code>match</code> 표현식의 스코프입니다.</li>
</ul>
<p>r[destructors.scope.nesting.other]</p>
<ul>
<li>그 외 모든 스코프의 부모는 그것을 직접 감싸고 있는 표현식의 스코프입니다.</li>
</ul>
<p>r[destructors.scope.params]</p>
<h3 id="함수-매개변수의-스코프"><a class="header" href="#함수-매개변수의-스코프">함수 매개변수의 스코프</a></h3>
<p>모든 함수 매개변수는 함수 본문 전체의 스코프에 속하므로, 함수가 평가될 때 가장 마지막에 드롭됩니다. 각 실제 함수 매개변수는 해당 매개변수의 패턴에서 도입된 모든 바인딩이 드롭된 후에 드롭됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct PrintOnDrop(&amp;'static str);
</span><span class="boring">impl Drop for PrintOnDrop {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!("드롭({})", self.0);
</span><span class="boring">    }
</span><span class="boring">}
</span>// `y`가 드롭되고, 그다음 두 번째 매개변수, 그다음 `x`, 그다음 첫 번째 매개변수 순으로 드롭됩니다.
fn patterns_in_parameters(
    (x, _): (PrintOnDrop, PrintOnDrop),
    (_, y): (PrintOnDrop, PrintOnDrop),
) {}

// 드롭 순서는 3 2 0 1입니다.
patterns_in_parameters(
    (PrintOnDrop("0"), PrintOnDrop("1")),
    (PrintOnDrop("2"), PrintOnDrop("3")),
);
<span class="boring">}</span></code></pre></pre>
<p>r[destructors.scope.bindings]</p>
<h3 id="지역-변수의-스코프"><a class="header" href="#지역-변수의-스코프">지역 변수의 스코프</a></h3>
<p>r[destructors.scope.bindings.intro] Local variables declared in a <code>let</code> statement are associated to the scope of the block that contains the <code>let</code> statement. Local variables declared in a <code>match</code> expression are associated to the arm scope of the <code>match</code> arm that they are declared in.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct PrintOnDrop(&amp;'static str);
</span><span class="boring">impl Drop for PrintOnDrop {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!("드롭({})", self.0);
</span><span class="boring">    }
</span><span class="boring">}
</span>let declared_first = PrintOnDrop("바깥쪽 스코프에서 마지막에 드롭됨");
{
    let declared_in_block = PrintOnDrop("안쪽 스코프에서 드롭됨");
}
let declared_last = PrintOnDrop("바깥쪽 스코프에서 먼저 드롭됨");
<span class="boring">}</span></code></pre></pre>
<p>r[destructors.scope.bindings.patterns] Variables in patterns are dropped in reverse order of declaration within the pattern.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct PrintOnDrop(&amp;'static str);
</span><span class="boring">impl Drop for PrintOnDrop {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!("드롭({})", self.0);
</span><span class="boring">    }
</span><span class="boring">}
</span>let (declared_first, declared_last) = (
    PrintOnDrop("Dropped last"),
    PrintOnDrop("Dropped first"),
);
<span class="boring">}</span></code></pre></pre>
<p>r[destructors.scope.bindings.or-patterns] For the purpose of drop order, <a href="patterns.html#or-patterns">or-patterns</a> declare bindings in the order given by the first subpattern.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct PrintOnDrop(&amp;'static str);
</span><span class="boring">impl Drop for PrintOnDrop {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!("드롭({})", self.0);
</span><span class="boring">    }
</span><span class="boring">}
</span>// Drops `x` before `y`.
fn or_pattern_drop_order&lt;T&gt;(
    (Ok([x, y]) | Err([y, x])): Result&lt;[T; 2], [T; 2]&gt;
//   ^^^^^^^^^^   ^^^^^^^^^^^ This is the second subpattern.
//   |
//   This is the first subpattern.
//
//   In the first subpattern, `x` is declared before `y`. Since it is
//   the first subpattern, that is the order used even if the second
//   subpattern, where the bindings are declared in the opposite
//   order, is matched.
) {}

// Here we match the first subpattern, and the drops happen according
// to the declaration order in the first subpattern.
or_pattern_drop_order(Ok([
    PrintOnDrop("Declared first, dropped last"),
    PrintOnDrop("Declared last, dropped first"),
]));

// Here we match the second subpattern, and the drops still happen
// according to the declaration order in the first subpattern.
or_pattern_drop_order(Err([
    PrintOnDrop("Declared last, dropped first"),
    PrintOnDrop("Declared first, dropped last"),
]));
<span class="boring">}</span></code></pre></pre>
<p>r[destructors.scope.temporary]</p>
<h3 id="임시-스코프"><a class="header" href="#임시-스코프">임시 스코프</a></h3>
<p>r[destructors.scope.temporary.intro] The <em>temporary scope</em> of an expression is the scope that is used for the temporary variable that holds the result of that expression when used in a <a href="expressions.html#place-expressions-and-value-expressions">place context</a>, unless it is <a href="destructors.html#constant-promotion">promoted</a>.</p>
<p>r[destructors.scope.temporary.enclosing] Apart from lifetime extension, the temporary scope of an expression is the smallest scope that contains the expression and is one of the following:</p>
<ul>
<li>함수 전체.</li>
<li>구문(statement).</li>
<li><a href="expressions/if-expr.html#if-expressions"><code>if</code></a>, <a href="expressions/loop-expr.html#predicate-loops"><code>while</code></a> 또는 <a href="expressions/loop-expr.html#infinite-loops"><code>loop</code></a> 표현식의 본문.</li>
<li><code>if</code> 표현식의 <code>else</code> 블록.</li>
<li>The non-pattern matching condition expression of an <code>if</code> or <code>while</code> expression, or a <code>match</code> guard.</li>
<li>매치 암의 본문 표현식.</li>
<li><a href="expressions/operator-expr.html#lazy-boolean-operators">지연 불리언 표현식(lazy boolean expression)</a>의 각 피연산자.</li>
<li>The pattern-matching condition(s) and consequent body of <a href="expressions/if-expr.html#if-expressions"><code>if</code></a> ([destructors.scope.temporary.edition2024]).</li>
<li>The pattern-matching condition and loop body of <a href="expressions/loop-expr.html#predicate-loops"><code>while</code></a>.</li>
<li>The entirety of the tail expression of a block ([destructors.scope.temporary.edition2024]).</li>
</ul>
<blockquote>
<p>[!NOTE] The <a href="glossary.html#scrutinee">scrutinee</a> of a <code>match</code> expression is not a temporary scope, so temporaries in the scrutinee can be dropped after the <code>match</code> expression. For example, the temporary for <code>1</code> in <code>match 1 { ref mut z =&gt; z };</code> lives until the end of the statement.</p>
</blockquote>
<blockquote>
<p>[!NOTE] The desugaring of a <a href="expr.assign.destructure">destructuring assignment</a> restricts the temporary scope of its assigned value operand (the RHS). For details, see [expr.assign.destructure.tmp-scopes].</p>
</blockquote>
<p>r[destructors.scope.temporary.edition2024]</p>
<blockquote>
<p>[!EDITION-2024] The 2024 edition added two new temporary scope narrowing rules: <code>if let</code> temporaries are dropped before the <code>else</code> block, and temporaries of tail expressions of blocks are dropped immediately after the tail expression is evaluated.</p>
</blockquote>
<p>몇 가지 예제:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![allow(irrefutable_let_patterns)]
</span><span class="boring">struct PrintOnDrop(&amp;'static str);
</span><span class="boring">impl Drop for PrintOnDrop {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!("드롭({})", self.0);
</span><span class="boring">    }
</span><span class="boring">}
</span>let local_var = PrintOnDrop("지역 변수");

// 조건이 평가되면 드롭됨
if PrintOnDrop("If 조건").0 == "If 조건" {
    // 블록 끝에서 드롭됨
    PrintOnDrop("If 본문").0
} else {
    unreachable!()
};

if let "if let 스크루티니" = PrintOnDrop("if let 스크루티니").0 {
    PrintOnDrop("if let 결과절").0
    // `if let 결과절`이 여기서 드롭됨
}
// `if let 스크루티니`가 여기서 드롭됨
else {
    PrintOnDrop("if let else").0
    // `if let else`가 여기서 드롭됨
};

while let x = PrintOnDrop("while let scrutinee").0 {
    PrintOnDrop("while let loop body").0;
    break;
    // `while let loop body` dropped here.
    // `while let scrutinee` dropped here.
}

// 첫 번째 || 이전에 드롭됨
(PrintOnDrop("첫 번째 피연산자").0 == ""
// ) 이전에 드롭됨
|| PrintOnDrop("두 번째 피연산자").0 == "")
// ; 이전에 드롭됨
|| PrintOnDrop("세 번째 피연산자").0 == "";

// 스크루티니는 함수의 끝에서 지역 변수들 이전에 드롭됩니다
// (이것이 함수 본문 블록의 꼬리 표현식이기 때문입니다).
match PrintOnDrop("최종 표현식의 매치된 값") {
    // 조건이 평가되면 드롭됨
    _ if PrintOnDrop("가드 조건").0 == "" =&gt; (),
    _ =&gt; (),
}
<span class="boring">}</span></code></pre></pre>
<p>r[destructors.scope.operands]</p>
<h3 id="피연산자"><a class="header" href="#피연산자">피연산자</a></h3>
<p>Temporaries are also created to hold the result of operands to an expression while the other operands are evaluated. The temporaries are associated to the scope of the expression with that operand. Since the temporaries are moved from once the expression is evaluated, dropping them has no effect unless one of the operands to an expression breaks out of the expression, returns, or <a href="panic.html">panics</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct PrintOnDrop(&amp;'static str);
</span><span class="boring">impl Drop for PrintOnDrop {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!("드롭({})", self.0);
</span><span class="boring">    }
</span><span class="boring">}
</span>loop {
    // 튜플 표현식의 평가가 완료되지 않았으므로 피연산자들이 역순으로 드롭됩니다.
    (
        PrintOnDrop("바깥쪽 튜플 첫 번째"),
        PrintOnDrop("바깥쪽 튜플 두 번째"),
        (
            PrintOnDrop("안쪽 튜플 첫 번째"),
            PrintOnDrop("안쪽 튜플 두 번째"),
            break,
        ),
        PrintOnDrop("절대로 생성되지 않음"),
    );
}
<span class="boring">}</span></code></pre></pre>
<p>r[destructors.scope.const-promotion]</p>
<h3 id="상수-승격"><a class="header" href="#상수-승격">상수 승격</a></h3>
<p>값 표현식을 <code>'static</code> 슬롯으로 승격시키는 것은, 해당 표현식을 상수로 작성하여 차용할 수 있고, 그 차용을 원래 표현식이 작성된 위치에서 런타임 동작의 변경 없이 역참조할 수 있을 때 발생합니다. 즉, 승격된 표현식은 컴파일 타임에 평가될 수 있어야 하며, 그 결과값은 <a href="interior-mutability.html">내부 가변성(interior mutability)</a>이나 <a href="destructors.html">소멸자(destructors)</a>를 포함하지 않아야 합니다 (이러한 속성들은 가능한 경우 값을 기반으로 결정됩니다. 예를 들어, <code>&amp;None</code>은 허용되지 않는 것을 아무것도 포함하지 않으므로 항상 <code>&amp;'static Option&lt;_&gt;</code> 타입을 가집니다).</p>
<p>r[destructors.scope.lifetime-extension]</p>
<h3 id="임시-라이프타임-확장"><a class="header" href="#임시-라이프타임-확장">임시 라이프타임 확장</a></h3>
<blockquote>
<p>[!NOTE] The exact rules for temporary lifetime extension are subject to change. This is describing the current behavior only.</p>
</blockquote>
<p>r[destructors.scope.lifetime-extension.let] The temporary scopes for expressions in <code>let</code> statements are sometimes <em>extended</em> to the scope of the block containing the <code>let</code> statement. This is done when the usual temporary scope would be too small, based on certain syntactic rules. For example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = &amp;mut 0;
// 보통이라면 임시 값은 지금쯤 드롭되었겠지만, `0`을 위한 임시 값은 블록 끝까지 유지됩니다.
println!("{}", x);
<span class="boring">}</span></code></pre></pre>
<p>r[destructors.scope.lifetime-extension.static] Lifetime extension also applies to <code>static</code> and <code>const</code> items, where it makes temporaries live until the end of the program. For example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const C: &amp;Vec&lt;i32&gt; = &amp;Vec::new();
// 보통이라면 `Vec`은 `C`의 초기화식 내부에만 존재하므로 이는 댕글링 참조(dangling reference)가 되겠지만,
// 대신 차용(borrow)이 라이프타임 확장되어 사실상 `'static` 라이프타임을 갖게 됩니다.
println!("{:?}", C);
<span class="boring">}</span></code></pre></pre>
<p>r[destructors.scope.lifetime-extension.sub-expressions] If a <a href="expr.operator.borrow">borrow</a>, <a href="expressions/operator-expr.html#the-dereference-operator">dereference</a>, <a href="expressions/field-expr.html">field</a>, or <a href="expressions/tuple-expr.html#tuple-indexing-expressions">tuple indexing expression</a> has an extended temporary scope, then so does its operand. If an <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">indexing expression</a> has an extended temporary scope, then the indexed expression also has an extended temporary scope.</p>
<p>r[destructors.scope.lifetime-extension.patterns]</p>
<h4 id="패턴에-기반한-연장"><a class="header" href="#패턴에-기반한-연장">패턴에 기반한 연장</a></h4>
<p>r[destructors.scope.lifetime-extension.patterns.extending] An <em>extending pattern</em> is either:</p>
<ul>
<li>
<p>참조 또는 가변 참조로 바인딩하는 <a href="patterns.html#identifier-patterns">식별자 패턴(identifier pattern)</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn temp() {}
</span>let ref x = temp(); // Binds by reference.
<span class="boring">x;
</span>let ref mut x = temp(); // Binds by mutable reference.
<span class="boring">x;
</span><span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>A <a href="patterns.html#struct-patterns">struct</a>, <a href="patterns.html#tuple-patterns">tuple</a>, <a href="patterns.html#tuple-struct-patterns">tuple struct</a>, <a href="patterns.html#slice-patterns">slice</a>, or <a href="patterns.html#or-patterns">or-pattern</a> where at least one of the direct subpatterns is an extending pattern.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use core::sync::atomic::{AtomicU64, Ordering::Relaxed};
</span><span class="boring">static X: AtomicU64 = AtomicU64::new(0);
</span>struct W&lt;T&gt;(T);
<span class="boring">impl&lt;T&gt; Drop for W&lt;T&gt; { fn drop(&amp;mut self) { X.fetch_add(1, Relaxed); } }
</span>let W { 0: ref x } = W(()); // Struct pattern.
<span class="boring">x;
</span>let W(ref x) = W(()); // Tuple struct pattern.
<span class="boring">x;
</span>let (W(ref x),) = (W(()),); // Tuple pattern.
<span class="boring">x;
</span>let [W(ref x), ..] = [W(())]; // Slice pattern.
<span class="boring">x;
</span>let (Ok(W(ref x)) | Err(&amp;ref x)) = Ok(W(())); // Or pattern.
<span class="boring">x;
</span>//
// All of the temporaries above are still live here.
<span class="boring">assert_eq!(0, X.load(Relaxed));
</span><span class="boring">}</span></code></pre></pre>
</li>
</ul>
<p>따라서 <code>ref x</code>, <code>V(ref x)</code>, <code>[ref x, y]</code>는 모두 연장 패턴이지만, <code>x</code>, <code>&amp;ref x</code>, <code>&amp;(ref x,)</code>는 그렇지 않습니다.</p>
<p>r[destructors.scope.lifetime-extension.patterns.let] If the pattern in a <code>let</code> statement is an extending pattern then the temporary scope of the initializer expression is extended.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn temp() {}
</span>// This is an extending pattern, so the temporary scope is extended.
let ref x = *&amp;temp(); // OK
<span class="boring">x;
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail E0716 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn temp() {}
</span>// This is neither an extending pattern nor an extending expression,
// so the temporary is dropped at the semicolon.
let &amp;ref x = *&amp;&amp;temp(); // 오류
<span class="boring">x;
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn temp() {}
</span>// This is not an extending pattern but it is an extending expression,
// so the temporary lives beyond the `let` statement.
let &amp;ref x = &amp;*&amp;temp(); // OK
<span class="boring">x;
</span><span class="boring">}</span></code></pre></pre>
<p>r[destructors.scope.lifetime-extension.exprs]</p>
<h4 id="표현식에-기반한-연장"><a class="header" href="#표현식에-기반한-연장">표현식에 기반한 연장</a></h4>
<p>r[destructors.scope.lifetime-extension.exprs.extending] For a let statement with an initializer, an <em>extending expression</em> is an expression which is one of the following:</p>
<ul>
<li>초기화식 표현식.</li>
<li>The operand of an extending <a href="expr.operator.borrow">borrow</a> expression.</li>
<li>The <a href="expr.super-macros">super operands</a> of an extending <a href="expr.super-macros">super macro call</a> expression.</li>
<li>연장 <a href="expressions/array-expr.html#array-expressions">배열(array)</a>, <a href="expressions/operator-expr.html#type-cast-expressions">캐스트(cast)</a>, <a href="expressions/struct-expr.html">중괄호 구조체(braced struct)</a>, 또는 <a href="expressions/tuple-expressions">튜플(tuple)</a> 표현식의 피연산자(들).</li>
<li>The arguments to an extending <a href="type.struct.tuple">tuple struct</a> or <a href="type.enum.declaration">tuple enum variant</a> constructor expression.</li>
<li>The final expression of an extending <a href="expressions/block-expr.html">block expression</a> except for an <a href="expr.block.async">async block expression</a>.</li>
<li>The final expression of an extending <a href="expressions/if-expr.html#if-expressions"><code>if</code></a> expression’s consequent, <code>else if</code>, or <code>else</code> block.</li>
<li>An arm expression of an extending <a href="expressions/match-expr.html"><code>match</code></a> expression.</li>
</ul>
<blockquote>
<p>[!NOTE] The desugaring of a <a href="expr.assign.destructure">destructuring assignment</a> makes its assigned value operand (the RHS) an extending expression within a newly-introduced block. For details, see [expr.assign.destructure.tmp-ext].</p>
</blockquote>
<p>So the borrow expressions in <code>&amp;mut 0</code>, <code>(&amp;1, &amp;mut 2)</code>, and <code>Some(&amp;mut 3)</code> are all extending expressions. The borrows in <code>&amp;0 + &amp;1</code> and <code>f(&amp;mut 0)</code> are not.</p>
<p>r[destructors.scope.lifetime-extension.exprs.borrows] The operand of an extending <a href="expr.operator.borrow">borrow</a> expression has its <a href="destructors.scope.temporary">temporary scope</a> <a href="destructors.scope.lifetime-extension">extended</a>.</p>
<p>r[destructors.scope.lifetime-extension.exprs.super-macros] The <a href="expr.super-macros">super temporaries</a> of an extending <a href="expr.super-macros">super macro call</a> expression have their <a href="destructors.scope.temporary">scopes</a> <a href="destructors.scope.lifetime-extension">extended</a>.</p>
<blockquote>
<p>[!NOTE] <code>rustc</code> does not treat <a href="expr.array.repeat-operand">array repeat operands</a> of extending <a href="types/array.html">array</a> expressions as extending expressions. Whether it should is an open question.</p>
<p>For details, see <a href="https://github.com/rust-lang/rust/issues/146092">Rust issue #146092</a>.</p>
</blockquote>
<h4 id="예시-4"><a class="header" href="#예시-4">예시</a></h4>
<p>다음은 표현식이 연장된 임시 스코프를 갖는 몇 가지 예입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use core::pin::pin;
</span><span class="boring">use core::sync::atomic::{AtomicU64, Ordering::Relaxed};
</span><span class="boring">static X: AtomicU64 = AtomicU64::new(0);
</span><span class="boring">#[derive(Debug)] struct S;
</span><span class="boring">impl Drop for S { fn drop(&amp;mut self) { X.fetch_add(1, Relaxed); } }
</span><span class="boring">const fn temp() -&gt; S { S }
</span>let x = &amp;temp(); // Operand of borrow.
<span class="boring">x;
</span>let x = &amp;raw const *&amp;temp(); // Operand of raw borrow.
<span class="boring">assert_eq!(X.load(Relaxed), 0);
</span>let x = &amp;temp() as &amp;dyn Send; // Operand of cast.
<span class="boring">x;
</span>let x = (&amp;*&amp;temp(),); // Operand of tuple constructor.
<span class="boring">x;
</span>struct W&lt;T&gt;(T);
let x = W(&amp;temp()); // Argument to tuple struct constructor.
<span class="boring">x;
</span>let x = Some(&amp;temp()); // Argument to tuple enum variant constructor.
<span class="boring">x;
</span>let x = { [Some(&amp;temp())] }; // Final expr of block.
<span class="boring">x;
</span>let x = const { &amp;temp() }; // Final expr of `const` block.
<span class="boring">x;
</span>let x = unsafe { &amp;temp() }; // Final expr of `unsafe` block.
<span class="boring">x;
</span>let x = if true { &amp;temp() } else { &amp;temp() };
//              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//           Final exprs of `if`/`else` blocks.
<span class="boring">x;
</span>let x = match () { _ =&gt; &amp;temp() }; // `match` arm expression.
<span class="boring">x;
</span>let x = pin!(temp()); // Super operand of super macro call expression.
<span class="boring">x;
</span>let x = pin!({ &amp;mut temp() }); // As above.
<span class="boring">x;
</span>let x = format_args!("{:?}", temp()); // As above.
<span class="boring">x;
</span>//
// All of the temporaries above are still live here.
<span class="boring">assert_eq!(0, X.load(Relaxed));
</span><span class="boring">}</span></code></pre></pre>
<p>다음은 표현식이 연장된 임시 스코프를 갖지 않는 몇 가지 예입니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0716 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn temp() {}
</span>// Arguments to function calls are not extending expressions. The
// temporary is dropped at the semicolon.
let x = core::convert::identity(&amp;temp()); // 오류
<span class="boring">x;
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail E0716 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn temp() {}
</span><span class="boring">trait Use { fn use_temp(&amp;self) -&gt; &amp;Self { self } }
</span><span class="boring">impl Use for () {}
</span>// Receivers of method calls are not extending expressions.
let x = (&amp;temp()).use_temp(); // 오류
<span class="boring">x;
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail E0716 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn temp() {}
</span>// Scrutinees of match expressions are not extending expressions.
let x = match &amp;temp() { x =&gt; x }; // 오류
<span class="boring">x;
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail E0515 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn temp() {}
</span>// Final expressions of `async` blocks are not extending expressions.
let x = async { &amp;temp() }; // 오류
<span class="boring">x;
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail E0515 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn temp() {}
</span>// Final expressions of closures are not extending expressions.
let x = || &amp;temp(); // 오류
<span class="boring">x;
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail E0716 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn temp() {}
</span>// Operands of loop breaks are not extending expressions.
let x = loop { break &amp;temp() }; // 오류
<span class="boring">x;
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail E0716 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn temp() {}
</span>// Operands of breaks to labels are not extending expressions.
let x = 'a: { break 'a &amp;temp() }; // 오류
<span class="boring">x;
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024 compile_fail E0716 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use core::pin::pin;
</span><span class="boring">fn temp() {}
</span>// The argument to `pin!` is only an extending expression if the call
// is an extending expression. Since it's not, the inner block is not
// an extending expression, so the temporaries in its trailing
// expression are dropped immediately.
pin!({ &amp;temp() }); // 오류
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024 compile_fail E0716 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn temp() {}
</span>// As above.
format_args!("{:?}", { &amp;temp() }); // 오류
<span class="boring">}</span></code></pre></pre>
<p>r[destructors.forget]</p>
<h2 id="소멸자를-실행하지-않는-경우"><a class="header" href="#소멸자를-실행하지-않는-경우">소멸자를 실행하지 않는 경우</a></h2>
<p>r[destructors.manually-suppressing]</p>
<h3 id="manually-suppressing-destructors"><a class="header" href="#manually-suppressing-destructors">Manually suppressing destructors</a></h3>
<p>[<code>core::mem::forget</code>] can be used to prevent the destructor of a variable from being run, and [<code>core::mem::ManuallyDrop</code>] provides a wrapper to prevent a variable or field from being dropped automatically.</p>
<blockquote>
<p>[!NOTE] Preventing a destructor from being run via [<code>core::mem::forget</code>] or other means is safe even if it has a type that isn’t <code>'static</code>. Besides the places where destructors are guaranteed to run as defined by this document, types may <em>not</em> safely rely on a destructor being run for soundness.</p>
</blockquote>
<p>r[destructors.process-termination]</p>
<h3 id="process-termination-without-unwinding"><a class="header" href="#process-termination-without-unwinding">Process termination without unwinding</a></h3>
<p>There are some ways to terminate the process without <a href="panic.html#unwinding">unwinding</a>, in which case destructors will not be run.</p>
<p>The standard library provides [<code>std::process::exit</code>] and [<code>std::process::abort</code>] to do this explicitly. Additionally, if the [panic handler][panic.panic_handler.std] is set to <code>abort</code>, panicking will always terminate the process without destructors being run.</p>
<p>There is one additional case to be aware of: when a panic reaches a <a href="items/functions.html#unwinding">non-unwinding ABI boundary</a>, either no destructors will run, or all destructors up until the ABI boundary will run.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[lifetime-elision]</p>
<h1 id="라이프타임-생략"><a class="header" href="#라이프타임-생략">라이프타임 생략</a></h1>
<p>러스트에는 컴파일러가 합리적인 기본 선택을 추론할 수 있는 다양한 위치에서 라이프타임을 생략할 수 있게 해주는 규칙들이 있습니다.</p>
<p>r[lifetime-elision.function]</p>
<h2 id="함수에서의-라이프타임-생략"><a class="header" href="#함수에서의-라이프타임-생략">함수에서의 라이프타임 생략</a></h2>
<p>r[lifetime-elision.function.intro] In order to make common patterns more ergonomic, lifetime arguments can be <em>elided</em> in <a href="types/function-item.html">function item</a>, <a href="types/function-pointer.html">function pointer</a>, and <a href="types/closure.html">closure trait</a> signatures. The following rules are used to infer lifetime parameters for elided lifetimes.</p>
<p>r[lifetime-elision.function.lifetimes-not-inferred] It is an error to elide lifetime parameters that cannot be inferred.</p>
<p>r[lifetime-elision.function.explicit-placeholder] The placeholder lifetime, <code>'_</code>, can also be used to have a lifetime inferred in the same way. For lifetimes in paths, using <code>'_</code> is preferred.</p>
<p>r[lifetime-elision.function.only-functions] Trait object lifetimes follow different rules discussed <a href="lifetime-elision.html#default-trait-object-lifetimes">below</a>.</p>
<p>r[lifetime-elision.function.implicit-lifetime-parameters]</p>
<ul>
<li>파라미터에서 생략된 각 라이프타임은 별개의 라이프타임 파라미터가 됩니다.</li>
</ul>
<p>r[lifetime-elision.function.output-lifetime]</p>
<ul>
<li>파라미터에서 사용된 라이프타임(생략되었든 아니든)이 정확히 하나라면, 그 라이프타임이 <em>모든</em> 생략된 출력 라이프타임에 할당됩니다.</li>
</ul>
<p>r[lifetime-elision.function.receiver-lifetime] In method signatures there is another rule</p>
<ul>
<li>리시버(receiver)가 <code>&amp;Self</code> 또는 <code>&amp;mut Self</code> 타입을 가지면, 그 <code>Self</code>에 대한 참조의 라이프타임이 모든 생략된 출력 라이프타임 파라미터에 할당됩니다.</li>
</ul>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait T {}
</span><span class="boring">trait ToCStr {}
</span><span class="boring">struct Thing&lt;'a&gt; {f: &amp;'a i32}
</span><span class="boring">struct Command;
</span><span class="boring">
</span><span class="boring">trait Example {
</span>fn print1(s: &amp;str);                                   // 생략됨
fn print2(s: &amp;'_ str);                                // 역시 생략됨
fn print3&lt;'a&gt;(s: &amp;'a str);                            // 확장됨

fn debug1(lvl: usize, s: &amp;str);                       // 생략됨
fn debug2&lt;'a&gt;(lvl: usize, s: &amp;'a str);                // 확장됨

fn substr1(s: &amp;str, until: usize) -&gt; &amp;str;            // 생략됨
fn substr2&lt;'a&gt;(s: &amp;'a str, until: usize) -&gt; &amp;'a str;  // 확장됨

fn get_mut1(&amp;mut self) -&gt; &amp;mut dyn T;                 // 생략됨
fn get_mut2&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a mut dyn T;       // 확장됨

fn args1&lt;T: ToCStr&gt;(&amp;mut self, args: &amp;[T]) -&gt; &amp;mut Command;                  // 생략됨
fn args2&lt;'a, 'b, T: ToCStr&gt;(&amp;'a mut self, args: &amp;'b [T]) -&gt; &amp;'a mut Command; // 확장됨

fn other_args1&lt;'a&gt;(arg: &amp;str) -&gt; &amp;'a str;             // 생략됨
fn other_args2&lt;'a, 'b&gt;(arg: &amp;'b str) -&gt; &amp;'a str;      // 확장됨

fn new1(buf: &amp;mut [u8]) -&gt; Thing&lt;'_&gt;;                 // 생략됨 - 선호됨
fn new2(buf: &amp;mut [u8]) -&gt; Thing;                     // 생략됨
fn new3&lt;'a&gt;(buf: &amp;'a mut [u8]) -&gt; Thing&lt;'a&gt;;          // 확장됨
<span class="boring">}
</span>
type FunPtr1 = fn(&amp;str) -&gt; &amp;str;                      // 생략됨
type FunPtr2 = for&lt;'a&gt; fn(&amp;'a str) -&gt; &amp;'a str;        // 확장됨

type FunTrait1 = dyn Fn(&amp;str) -&gt; &amp;str;                // 생략됨
type FunTrait2 = dyn for&lt;'a&gt; Fn(&amp;'a str) -&gt; &amp;'a str;  // 확장됨
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 다음 예제들은 라이프타임 파라미터를 생략할 수 없는 상황들을 보여줍니다.

<span class="boring">trait Example {
</span>// 추론할 수 있는 파라미터가 없기 때문에 추론할 수 없습니다.
fn get_str() -&gt; &amp;str;                                 // 허용되지 않음

// 첫 번째 파라미터에서 차용된 것인지 두 번째 파라미터에서 차용된 것인지 모호하기 때문에 추론할 수 없습니다.
fn frob(s: &amp;str, t: &amp;str) -&gt; &amp;str;                    // 허용되지 않음
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>r[lifetime-elision.trait-object]</p>
<h2 id="기본-트레잇-객체-라이프타임"><a class="header" href="#기본-트레잇-객체-라이프타임">기본 트레잇 객체 라이프타임</a></h2>
<p>r[lifetime-elision.trait-object.intro] The assumed lifetime of references held by a <a href="types/trait-object.html">trait object</a> is called its <em>default object lifetime bound</em>. These were defined in <a href="https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md">RFC 599</a> and amended in <a href="https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md">RFC 1156</a>.</p>
<p>r[lifetime-elision.trait-object.explicit-bound] These default object lifetime bounds are used instead of the lifetime parameter elision rules defined above when the lifetime bound is omitted entirely.</p>
<p>r[lifetime-elision.trait-object.explicit-placeholder] If <code>'_</code> is used as the lifetime bound then the bound follows the usual elision rules.</p>
<p>r[lifetime-elision.trait-object.containing-type] If the trait object is used as a type argument of a generic type then the containing type is first used to try to infer a bound.</p>
<p>r[lifetime-elision.trait-object.containing-type-unique]</p>
<ul>
<li>포함하는 타입으로부터 유일한 바운드가 있다면 그것이 기본값이 됩니다.</li>
</ul>
<p>r[lifetime-elision.trait-object.containing-type-explicit]</p>
<ul>
<li>포함하는 타입으로부터 둘 이상의 바운드가 있다면 명시적인 바운드를 지정해야 합니다.</li>
</ul>
<p>r[lifetime-elision.trait-object.trait-bounds] If neither of those rules apply, then the bounds on the trait are used:</p>
<p>r[lifetime-elision.trait-object.trait-unique]</p>
<ul>
<li>트레잇이 단일 라이프타임 _바운드_와 함께 정의되었다면 그 바운드가 사용됩니다.</li>
</ul>
<p>r[lifetime-elision.trait-object.static-lifetime]</p>
<ul>
<li>어떤 라이프타임 바운드에라도 <code>'static</code>이 사용되었다면 <code>'static</code>이 사용됩니다.</li>
</ul>
<p>r[lifetime-elision.trait-object.default]</p>
<ul>
<li>트레잇에 라이프타임 바운드가 없다면, 라이프타임은 표현식 내에서는 추론되고 표현식 외부에서는 <code>'static</code>이 됩니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 다음 트레잇에 대하여...
trait Foo { }

// Box&lt;T&gt;는 T에 대한 라이프타임 바운드가 없으므로 이 둘은 동일합니다.
type T1 = Box&lt;dyn Foo&gt;;
type T2 = Box&lt;dyn Foo + 'static&gt;;

// ...그리고 다음의 경우들도 그렇습니다:
impl dyn Foo {}
impl dyn Foo + 'static {}

// ...&amp;'a T가 T: 'a를 요구하므로 다음의 경우들도 그렇습니다:
type T3&lt;'a&gt; = &amp;'a dyn Foo;
type T4&lt;'a&gt; = &amp;'a (dyn Foo + 'a);

// std::cell::Ref&lt;'a, T&gt; 역시 T: 'a를 요구하므로 이들은 동일합니다.
type T5&lt;'a&gt; = std::cell::Ref&lt;'a, dyn Foo&gt;;
type T6&lt;'a&gt; = std::cell::Ref&lt;'a, dyn Foo + 'a&gt;;
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 이는 오류의 한 예입니다.
<span class="boring">trait Foo { }
</span>struct TwoBounds&lt;'a, 'b, T: ?Sized + 'a + 'b&gt; {
    f1: &amp;'a i32,
    f2: &amp;'b i32,
    f3: T,
}
type T7&lt;'a, 'b&gt; = TwoBounds&lt;'a, 'b, dyn Foo&gt;;
//                                  ^^^^^^^
// 오류: 이 객체 타입에 대한 라이프타임 바운드를 문맥으로부터 추론할 수 없습니다.
<span class="boring">}</span></code></pre></pre>
<p>r[lifetime-elision.trait-object.innermost-type] Note that the innermost object sets the bound, so <code>&amp;'a Box&lt;dyn Foo&gt;</code> is still <code>&amp;'a Box&lt;dyn Foo + 'static&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 다음 트레잇에 대하여...
trait Bar&lt;'a&gt;: 'a { }

// ...이 둘은 동일합니다:
type T1&lt;'a&gt; = Box&lt;dyn Bar&lt;'a&gt;&gt;;
type T2&lt;'a&gt; = Box&lt;dyn Bar&lt;'a&gt; + 'a&gt;;

// ...그리고 다음의 경우들도 그렇습니다:
impl&lt;'a&gt; dyn Bar&lt;'a&gt; {}
impl&lt;'a&gt; dyn Bar&lt;'a&gt; + 'a {}
<span class="boring">}</span></code></pre></pre>
<p>r[lifetime-elision.const-static]</p>
<h2 id="const-및-static-생략"><a class="header" href="#const-및-static-생략"><code>const</code> 및 <code>static</code> 생략</a></h2>
<p>r[lifetime-elision.const-static.implicit-static] Both <a href="items/constant-items.html">constant</a> and <a href="items/static-items.html">static</a> declarations of reference types have <em>implicit</em> <code>'static</code> lifetimes unless an explicit lifetime is specified. As such, the constant declarations involving <code>'static</code> above may be written without the lifetimes.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// STRING: &amp;'static str
const STRING: &amp;str = "bitstring";

struct BitsNStrings&lt;'a&gt; {
    mybits: [u32; 2],
    mystring: &amp;'a str,
}

// BITS_N_STRINGS: BitsNStrings&lt;'static&gt;
const BITS_N_STRINGS: BitsNStrings&lt;'_&gt; = BitsNStrings {
    mybits: [1, 2],
    mystring: STRING,
};
<span class="boring">}</span></code></pre></pre>
<p>r[lifetime-elision.const-static.fn-references] Note that if the <code>static</code> or <code>const</code> items include function or closure references, which themselves include references, the compiler will first try the standard elision rules. If it is unable to resolve the lifetimes by its usual rules, then it will error. By way of example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Foo;
</span><span class="boring">struct Bar;
</span><span class="boring">struct Baz;
</span><span class="boring">fn somefunc(a: &amp;Foo, b: &amp;Bar, c: &amp;Baz) -&gt; usize {42}
</span>// `for&lt;'a&gt; fn(&amp;'a str) -&gt; &amp;'a str`로 해결됩니다.
const RESOLVED_SINGLE: fn(&amp;str) -&gt; &amp;str = |x| x;

// `for&lt;'a, 'b, 'c&gt; Fn(&amp;'a Foo, &amp;'b Bar, &amp;'c Baz) -&gt; usize`로 해결됩니다.
const RESOLVED_MULTIPLE: &amp;dyn Fn(&amp;Foo, &amp;Bar, &amp;Baz) -&gt; usize = &amp;somefunc;
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Foo;
</span><span class="boring">struct Bar;
</span><span class="boring">struct Baz;
</span><span class="boring">fn somefunc&lt;'a,'b&gt;(a: &amp;'a Foo, b: &amp;'b Bar) -&gt; &amp;'a Baz {unimplemented!()}
</span>// 인자 라이프타임과 관련하여 반환 참조 라이프타임을 제한할 정보가 충분하지 않으므로, 이는 오류입니다.
const RESOLVED_STATIC: &amp;dyn Fn(&amp;Foo, &amp;Bar) -&gt; &amp;Baz = &amp;somefunc;
//                                            ^
// 이 함수의 반환 타입은 차용된 값을 포함하지만, 시그니처에는 이것이 인자 1에서 차용된 것인지 인자 2에서 차용된 것인지 명시되어 있지 않습니다.
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p>r[lang-types]</p>
<h1 id="특수-타입과-트레잇"><a class="header" href="#특수-타입과-트레잇">특수 타입과 트레잇</a></h1>
<p>r[lang-types.intro] Certain types and traits that exist in <a href="std">the standard library</a> are known to the Rust compiler. This chapter documents the special features of these types and traits.</p>
<p>r[lang-types.box]</p>
<h2 id="boxt"><a class="header" href="#boxt"><code>Box&lt;T&gt;</code></a></h2>
<p>r[lang-types.box.intro] [<code>Box&lt;T&gt;</code>] has a few special features that Rust doesn’t currently allow for user defined types.</p>
<p>r[lang-types.box.deref]</p>
<ul>
<li><code>Box&lt;T&gt;</code>에 대한 <a href="expressions/operator-expr.html#the-dereference-operator">역참조 연산자(dereference operator)</a>는 데이터를 이동(move)할 수 있는 장소(place)를 생성합니다. 이는 <code>*</code> 연산자와 <code>Box&lt;T&gt;</code>의 소멸자가 언어 자체에 내장되어 있음을 의미합니다.</li>
</ul>
<p>r[lang-types.box.receiver]</p>
<ul>
<li><a href="items/associated-items.html#associated-functions-and-methods">메서드(Methods)</a>는 <code>Box&lt;Self&gt;</code>를 리시버로 취할 수 있습니다.</li>
</ul>
<p>r[lang-types.box.fundamental]</p>
<ul>
<li><a href="items/implementations.html#trait-implementation-coherence">고아 규칙(orphan rules)</a>이 다른 제네릭 타입에 대해서는 금지하는 것과 달리, <code>T</code>와 동일한 크레이트에서 <code>Box&lt;T&gt;</code>에 대해 트레잇을 구현할 수 있습니다.</li>
</ul>
<!-- Editor Note: This is nowhere close to an exhaustive list -->
<p>r[lang-types.rc]</p>
<h2 id="rct"><a class="header" href="#rct"><code>Rc&lt;T&gt;</code></a></h2>
<p>r[lang-types.rc.receiver] <a href="items/associated-items.html#associated-functions-and-methods">Methods</a> can take <a href="std::rc::Rc"><code>Rc&lt;Self&gt;</code></a> as a receiver.</p>
<p>r[lang-types.arc]</p>
<h2 id="arct"><a class="header" href="#arct"><code>Arc&lt;T&gt;</code></a></h2>
<p>r[lang-types.arc.receiver] <a href="items/associated-items.html#associated-functions-and-methods">Methods</a> can take <a href="std::sync::Arc"><code>Arc&lt;Self&gt;</code></a> as a receiver.</p>
<p>r[lang-types.pin]</p>
<h2 id="pinp"><a class="header" href="#pinp"><code>Pin&lt;P&gt;</code></a></h2>
<p>r[lang-types.pin.receiver] <a href="items/associated-items.html#associated-functions-and-methods">Methods</a> can take <a href="std::pin::Pin"><code>Pin&lt;P&gt;</code></a> as a receiver.</p>
<p>r[lang-types.unsafe-cell]</p>
<h2 id="unsafecellt"><a class="header" href="#unsafecellt"><code>UnsafeCell&lt;T&gt;</code></a></h2>
<p>r[lang-types.unsafe-cell.interior-mut] [<code>std::cell::UnsafeCell&lt;T&gt;</code>] is used for <a href="interior-mutability.html">interior mutability</a>. It ensures that the compiler doesn’t perform optimisations that are incorrect for such types.</p>
<p>r[lang-types.unsafe-cell.read-only-alloc] It also ensures that <a href="items/static-items.html"><code>static</code> items</a> which have a type with interior mutability aren’t placed in memory marked as read only.</p>
<p>r[lang-types.phantom-data]</p>
<h2 id="phantomdatat"><a class="header" href="#phantomdatat"><code>PhantomData&lt;T&gt;</code></a></h2>
<p>[<code>std::marker::PhantomData&lt;T&gt;</code>] is a zero-sized, minimum alignment, type that is considered to own a <code>T</code> for the purposes of <a href="subtyping.html#variance">variance</a>, <a href="../nomicon/dropck.html">drop check</a>, and <a href="special-types-and-traits.html#auto-traits">auto traits</a>.</p>
<p>r[lang-types.ops]</p>
<h2 id="operator-traits"><a class="header" href="#operator-traits">Operator traits</a></h2>
<p>The traits in [<code>std::ops</code>] and [<code>std::cmp</code>] are used to overload <a href="expressions/operator-expr.html">operators</a>, <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">indexing expressions</a>, and <a href="expressions/call-expr.html">call expressions</a>.</p>
<p>r[lang-types.deref]</p>
<h2 id="deref-및-derefmut"><a class="header" href="#deref-및-derefmut"><code>Deref</code> 및 <code>DerefMut</code></a></h2>
<p>As well as overloading the unary <code>*</code> operator, <a href="std::ops::Deref"><code>Deref</code></a> and <a href="std::ops::DerefMut"><code>DerefMut</code></a> are also used in <a href="expressions/method-call-expr.html">method resolution</a> and <a href="type-coercions.html#coercion-types">deref coercions</a>.</p>
<p>r[lang-types.drop]</p>
<h2 id="drop"><a class="header" href="#drop"><code>Drop</code></a></h2>
<p>The [<code>Drop</code>] trait provides a <a href="destructors.html">destructor</a>, to be run whenever a value of this type is to be destroyed.</p>
<p>r[lang-types.copy]</p>
<h2 id="copy"><a class="header" href="#copy"><code>Copy</code></a></h2>
<p>r[lang-types.copy.intro] The [<code>Copy</code>] trait changes the semantics of a type implementing it.</p>
<p>r[lang-types.copy.behavior] Values whose type implements <code>Copy</code> are copied rather than moved upon assignment.</p>
<p>r[lang-types.copy.constraint] <code>Copy</code> can only be implemented for types which do not implement <code>Drop</code>, and whose fields are all <code>Copy</code>. For enums, this means all fields of all variants have to be <code>Copy</code>. For unions, this means all variants have to be <code>Copy</code>.</p>
<p>r[lang-types.copy.builtin-types] <code>Copy</code> is implemented by the compiler for</p>
<p>r[lang-types.copy.tuple]</p>
<ul>
<li><code>Copy</code> 타입들로 구성된 <a href="types/tuple.html">튜플(Tuples)</a></li>
</ul>
<p>r[lang-types.copy.fn-pointer]</p>
<ul>
<li><a href="types/function-pointer.html">함수 포인터</a></li>
</ul>
<p>r[lang-types.copy.fn-item]</p>
<ul>
<li><a href="types/function-item.html">함수 아이템(Function items)</a></li>
</ul>
<p>r[lang-types.copy.closure]</p>
<ul>
<li>아무 값도 캡처하지 않거나 <code>Copy</code> 타입의 값만 캡처하는 <a href="types/closure.html">클로저(Closures)</a></li>
</ul>
<p>r[lang-types.clone]</p>
<h2 id="clone"><a class="header" href="#clone"><code>Clone</code></a></h2>
<p>r[lang-types.clone.intro] The [<code>Clone</code>] trait is a supertrait of <code>Copy</code>, so it also needs compiler generated implementations.</p>
<p>r[lang-types.clone.builtin-types] It is implemented by the compiler for the following types:</p>
<p>r[lang-types.clone.builtin-copy]</p>
<ul>
<li>내장된 <code>Copy</code> 구현을 가진 타입 (위 참조)</li>
</ul>
<p>r[lang-types.clone.tuple]</p>
<ul>
<li><code>Clone</code> 타입들로 구성된 <a href="types/tuple.html">튜플(Tuples)</a></li>
</ul>
<p>r[lang-types.clone.closure]</p>
<ul>
<li><code>Clone</code> 타입의 값만 캡처하거나 환경에서 아무 값도 캡처하지 않는 <a href="types/closure.html">클로저(Closures)</a></li>
</ul>
<p>r[lang-types.send]</p>
<h2 id="send"><a class="header" href="#send"><code>Send</code></a></h2>
<p>The [<code>Send</code>] trait indicates that a value of this type is safe to send from one thread to another.</p>
<p>r[lang-types.sync]</p>
<h2 id="sync"><a class="header" href="#sync"><code>Sync</code></a></h2>
<p>r[lang-types.sync.intro] The [<code>Sync</code>] trait indicates that a value of this type is safe to share between multiple threads.</p>
<p>r[lang-types.sync.static-constraint] This trait must be implemented for all types used in immutable <a href="items/static-items.html"><code>static</code> items</a>.</p>
<p>r[lang-types.termination]</p>
<h2 id="termination"><a class="header" href="#termination"><code>Termination</code></a></h2>
<p>The <a href="std::process::Termination"><code>Termination</code></a> trait indicates the acceptable return types for the <a href="crates-and-source-files.html#main-functions">main function</a> and <a href="attributes/testing.html#the-test-attribute">test functions</a>.</p>
<p>r[lang-types.auto-traits]</p>
<h2 id="자동-트레잇auto-traits"><a class="header" href="#자동-트레잇auto-traits">자동 트레잇(Auto traits)</a></h2>
<p>The [<code>Send</code>], [<code>Sync</code>], <a href="std::marker::Unpin"><code>Unpin</code></a>, <a href="std::panic::UnwindSafe"><code>UnwindSafe</code></a>, and <a href="std::panic::RefUnwindSafe"><code>RefUnwindSafe</code></a> traits are <em>auto traits</em>. Auto traits have special properties.</p>
<p>r[lang-types.auto-traits.auto-impl] If no explicit implementation or negative implementation is written out for an auto trait for a given type, then the compiler implements it automatically according to the following rules:</p>
<p>r[lang-types.auto-traits.builtin-composite]</p>
<ul>
<li><code>T</code>가 해당 트레잇을 구현하면 <code>&amp;T</code>, <code>&amp;mut T</code>, <code>*const T</code>, <code>*mut T</code>, <code>[T; n]</code>, 그리고 <code>[T]</code>도 이를 구현합니다.</li>
</ul>
<p>r[lang-types.auto-traits.fn-item-pointer]</p>
<ul>
<li>함수 아이템 타입과 함수 포인터는 자동으로 트레잇을 구현합니다.</li>
</ul>
<p>r[lang-types.auto-traits.aggregate]</p>
<ul>
<li>구조체, 열거형, 공용체, 그리고 튜플은 모든 필드가 해당 트레잇을 구현하면 이를 구현합니다.</li>
</ul>
<p>r[lang-types.auto-traits.closure]</p>
<ul>
<li>클로저는 캡처한 모든 것의 타입이 해당 트레잇을 구현하면 이를 구현합니다. <code>T</code>를 공유 참조로 캡처하고 <code>U</code>를 값으로 캡처하는 클로저는 <code>&amp;T</code>와 <code>U</code>가 모두 구현하는 자동 트레잇들을 구현합니다.</li>
</ul>
<p>r[lang-types.auto-traits.generic-impl] For generic types (counting the built-in types above as generic over <code>T</code>), if a generic implementation is available, then the compiler does not automatically implement it for types that could use the implementation except that they do not meet the requisite trait bounds. For instance, the standard library implements <code>Send</code> for all <code>&amp;T</code> where <code>T</code> is <code>Sync</code>; this means that the compiler will not implement <code>Send</code> for <code>&amp;T</code> if <code>T</code> is <code>Send</code> but not <code>Sync</code>.</p>
<p>r[lang-types.auto-traits.negative] Auto traits can also have negative implementations, shown as <code>impl !AutoTrait for T</code> in the standard library documentation, that override the automatic implementations. For example <code>*mut T</code> has a negative implementation of <code>Send</code>, and so <code>*mut T</code> is not <code>Send</code>, even if <code>T</code> is. There is currently no stable way to specify additional negative implementations; they exist only in the standard library.</p>
<p>r[lang-types.auto-traits.trait-object-marker] Auto traits may be added as an additional bound to any <a href="types/trait-object.html">trait object</a>, even though normally only one trait is allowed. For instance, <code>Box&lt;dyn Debug + Send + UnwindSafe&gt;</code> is a valid type.</p>
<p>r[lang-types.sized]</p>
<h2 id="sized-1"><a class="header" href="#sized-1"><code>Sized</code></a></h2>
<p>r[lang-types.sized.intro] The [<code>Sized</code>] trait indicates that the size of this type is known at compile-time; that is, it’s not a <a href="dynamically-sized-types.html">dynamically sized type</a>.</p>
<p>r[lang-types.sized.implicit-sized] <a href="types/parameters.html">Type parameters</a> (except <code>Self</code> in traits) are <code>Sized</code> by default, as are <a href="items/associated-items.html#associated-types">associated types</a>.</p>
<p>r[lang-types.sized.implicit-impl] <code>Sized</code> is always implemented automatically by the compiler, not by <a href="items/implementations.html">implementation items</a>.</p>
<p>r[lang-types.sized.relaxation] These implicit <code>Sized</code> bounds may be relaxed by using the special <code>?Sized</code> bound.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[names]</p>
<h1 id="이름"><a class="header" href="#이름">이름</a></h1>
<p>r[names.intro] An <em>entity</em> is a language construct that can be referred to in some way within the source program, usually via a <a href="paths.html">path</a>. Entities include <a href="types.html">types</a>, <a href="items.html">items</a>, <a href="items/generics.html">generic parameters</a>, <a href="patterns.html">variable bindings</a>, <a href="expressions/loop-expr.html#loop-labels">loop labels</a>, <a href="tokens.html#lifetimes-and-loop-labels">lifetimes</a>, <a href="expressions/field-expr.html">fields</a>, <a href="attributes.html">attributes</a>, and <a href="attributes/diagnostics.html#lint-check-attributes">lints</a>.</p>
<p>_선언(declaration)_은 엔티티를 참조하기 위한 _이름_을 도입할 수 있는 구문론적 구성 요소입니다. 엔티티 이름은 <a href="names/scopes.html"><em>스코프(scope)</em></a>(해당 이름이 참조될 수 있는 소스 텍스트의 영역) 내에서 유효합니다.</p>
<p>일부 엔티티는 소스 코드에서 <a href="names.html#explicitly-declared-entities">명시적으로 선언</a>되며, 일부는 언어의 일부나 컴파일러 확장의 일환으로 <a href="names.html#implicitly-declared-entities">암시적으로 선언</a>됩니다.</p>
<p><a href="paths.html"><em>경로(Paths)</em></a>는 엔티티(다른 모듈이나 타입에 있을 수 있음)를 참조하는 데 사용됩니다.</p>
<p>라이프타임과 루프 레이블은 앞에 따옴표가 붙는 <a href="tokens.html#lifetimes-and-loop-labels">전용 구문</a>을 사용합니다.</p>
<p>이름은 서로 다른 <a href="names/namespaces.html"><em>네임스페이스(namespaces)</em></a>로 격리되어, 서로 다른 네임스페이스에 있는 엔티티들이 충돌 없이 동일한 이름을 공유할 수 있게 합니다.</p>
<p><a href="names/name-resolution.html"><em>이름 확인(Name resolution)</em></a>은 경로, 식별자, 레이블을 엔티티 선언에 연결하는 컴파일 타임 프로세스입니다.</p>
<p>특정 이름에 대한 접근은 해당 이름의 <a href="visibility-and-privacy.html"><em>가시성(visibility)</em></a>에 따라 제한될 수 있습니다.</p>
<p>r[names.explicit]</p>
<h2 id="명시적으로-선언된-엔티티"><a class="header" href="#명시적으로-선언된-엔티티">명시적으로 선언된 엔티티</a></h2>
<p>r[names.explicit.list] Entities that explicitly introduce a name in the source code are:</p>
<p>r[names.explicit.item-decl]</p>
<ul>
<li><a href="items.html">아이템(Items)</a>:
<ul>
<li><a href="items/modules.html">모듈 선언</a></li>
<li><a href="items/extern-crates.html">외부 크레이트 선언</a></li>
<li><a href="items/use-declarations.html">Use 선언</a></li>
<li><a href="items/functions.html">함수 선언</a> 및 <a href="items/functions.html#function-parameters">함수 매개변수</a></li>
<li><a href="items/type-aliases.html">타입 별칭</a></li>
<li><a href="items/structs.html">구조체</a>, <a href="items/unions.html">공용체</a>, <a href="items/enumerations.html">열거형</a>, 열거형 변형 선언 및 이름 있는 필드들</li>
<li><a href="items/constant-items.html">상수 아이템 선언</a></li>
<li><a href="items/static-items.html">정적 아이템 선언</a></li>
<li><a href="items/traits.html">트레잇 아이템 선언</a> 및 <a href="items/associated-items.html">연관 아이템</a></li>
<li><a href="items/external-blocks.html">외부 블록 아이템</a></li>
<li><a href="macros-by-example.html"><code>macro_rules</code> 선언</a> 및 <a href="macros-by-example.html#metavariables">매처 메타변수</a></li>
<li><a href="items/implementations.html">구현</a> 연관 아이템</li>
</ul>
</li>
</ul>
<p>r[names.explicit.expr]</p>
<ul>
<li><a href="expressions.html">표현식</a>:
<ul>
<li><a href="expressions/closure-expr.html">클로저</a> 매개변수</li>
<li><a href="expressions/loop-expr.html#while-let-patterns"><code>while let</code></a> pattern bindings</li>
<li><a href="expressions/loop-expr.html#iterator-loops"><code>for</code></a> 패턴 바인딩</li>
<li><a href="expressions/if-expr.html#if-let-patterns"><code>if let</code></a> pattern bindings</li>
<li><a href="expressions/match-expr.html"><code>match</code></a> 패턴 바인딩</li>
<li><a href="expressions/loop-expr.html#loop-labels">루프 레이블</a></li>
</ul>
</li>
</ul>
<p>r[names.explicit.generics]</p>
<ul>
<li><a href="items/generics.html">제네릭 파라미터</a></li>
</ul>
<p>r[names.explicit.higher-ranked-bounds]</p>
<ul>
<li><a href="trait-bounds.html#higher-ranked-trait-bounds">고차 트레잇 바운드</a></li>
</ul>
<p>r[names.explicit.binding]</p>
<ul>
<li><a href="statements.html#let-statements"><code>let</code> 문</a> 패턴 바인딩</li>
</ul>
<p>r[names.explicit.macro_use]</p>
<ul>
<li><code>macro_use</code> 속성](macros-by-example.md#the-macro_use-attribute)은 다른 크레이트에서 매크로 이름을 가져올 수 있습니다.</li>
</ul>
<p>r[names.explicit.macro_export]</p>
<ul>
<li>The <a href="macros-by-example.html#the-macro_export-attribute"><code>macro_export</code> attribute</a> can introduce an alias for the macro into the crate root</li>
</ul>
<p>r[names.explicit.macro-invocation] Additionally, <a href="macros.html#macro-invocation">macro invocations</a> and <a href="attributes.html">attributes</a> can introduce names by expanding to one of the above items.</p>
<p>r[names.implicit]</p>
<h2 id="암시적으로-선언된-엔티티"><a class="header" href="#암시적으로-선언된-엔티티">암시적으로 선언된 엔티티</a></h2>
<p>r[names.implicit.list] The following entities are implicitly defined by the language, or are introduced by compiler options and extensions:</p>
<p>r[names.implicit.primitive-types]</p>
<ul>
<li><a href="names/preludes.html#language-prelude">언어 프렐류드</a>:
<ul>
<li><a href="types/boolean.html">불리언 타입</a> — <code>bool</code></li>
<li><a href="types/textual.html">텍스트 타입</a> — <code>char</code> 및 <code>str</code></li>
<li><a href="types/numeric.html#integer-types">정수 타입</a> — <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code></li>
<li><a href="types/numeric.html#machine-dependent-integer-types">머신 의존적 정수 타입</a> — <code>usize</code> 및 <code>isize</code></li>
<li><a href="types/numeric.html#floating-point-types">부동 소수점 타입</a> — <code>f32</code> 및 <code>f64</code></li>
</ul>
</li>
</ul>
<p>r[names.implicit.builtin-attributes]</p>
<ul>
<li><a href="attributes.html#built-in-attributes-index">내장 속성</a></li>
</ul>
<p>r[names.implicit.prelude]</p>
<ul>
<li><a href="names/preludes.html#standard-library-prelude">표준 라이브러리 프렐류드</a> 아이템, 속성 및 매크로</li>
</ul>
<p>r[names.implicit.stdlib]</p>
<ul>
<li>루트 모듈의 <a href="names/preludes.html#extern-prelude">표준 라이브러리</a> 크레이트</li>
</ul>
<p>r[names.implicit.extern-prelude]</p>
<ul>
<li>컴파일러에 의해 링크된 <a href="names/preludes.html#extern-prelude">외부 크레이트</a></li>
</ul>
<p>r[names.implicit.tool-attributes]</p>
<ul>
<li><a href="attributes.html#tool-attributes">도구 속성</a></li>
</ul>
<p>r[names.implicit.lints]</p>
<ul>
<li><a href="attributes/diagnostics.html#lint-check-attributes">린트</a> 및 <a href="attributes/diagnostics.html#tool-lint-attributes">도구 린트 속성</a></li>
</ul>
<p>r[names.implicit.derive-helpers]</p>
<ul>
<li><a href="procedural-macros.html#derive-macro-helper-attributes">Derive 헬퍼 속성</a>은 명시적으로 가져오지 않아도 아이템 내에서 유효합니다.</li>
</ul>
<p>r[names.implicit.lifetime-static]</p>
<ul>
<li><a href="keywords.html#weak-keywords"><code>'static</code></a> 라이프타임</li>
</ul>
<p>r[names.implicit.root] Additionally, the crate root module does not have a name, but can be referred to with certain <a href="paths.html#path-qualifiers">path qualifiers</a> or aliases.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[names.namespaces]</p>
<h1 id="네임스페이스"><a class="header" href="#네임스페이스">네임스페이스</a></h1>
<p>r[names.namespaces.intro] A <em>namespace</em> is a logical grouping of declared <a href="names/../names.html">names</a>. Names are segregated into separate namespaces based on the kind of entity the name refers to. Namespaces allow the occurrence of a name in one namespace to not conflict with the same name in another namespace.</p>
<p>각각 다른 종류의 엔티티를 포함하는 여러 가지 네임스페이스가 있습니다. 이름의 사용은 <a href="names/name-resolution.html">이름 해석</a> 장에서 설명한 대로 문맥에 따라 다른 네임스페이스에서 해당 이름의 선언을 찾습니다.</p>
<p>r[names.namespaces.kinds] The following is a list of namespaces, with their corresponding entities:</p>
<ul>
<li>타입 네임스페이스
<ul>
<li><a href="names/../items/modules.html">모듈 선언</a></li>
<li><a href="names/../items/extern-crates.html">외부 크레이트 선언</a></li>
<li><a href="names/preludes.html#extern-prelude">외부 크레이트 프렐류드</a> 아이템</li>
<li><a href="names/../items/structs.html">구조체</a>, <a href="names/../items/unions.html">공용체</a>, <a href="names/../items/enumerations.html">열거형</a>, 열거형 변형 선언</li>
<li><a href="names/../items/traits.html">트레잇 아이템 선언</a></li>
<li><a href="names/../items/type-aliases.html">타입 별칭</a></li>
<li><a href="names/../items/associated-items.html#associated-types">연관 타입 선언</a></li>
<li>내장 타입: <a href="names/../types/boolean.html">불리언</a>, <a href="names/../types/numeric.html">숫자</a>, <a href="names/../types/textual.html">텍스트</a></li>
<li><a href="names/../items/generics.html">제네릭 타입 매개변수</a></li>
<li><a href="names/../paths.html#self-1"><code>Self</code> 타입</a></li>
<li><a href="names/../attributes.html#tool-attributes">도구 속성 모듈</a></li>
</ul>
</li>
<li>값 네임스페이스
<ul>
<li><a href="names/../items/functions.html">함수 선언</a></li>
<li><a href="names/../items/constant-items.html">상수 아이템 선언</a></li>
<li><a href="names/../items/static-items.html">정적 아이템 선언</a></li>
<li><a href="names/../items/structs.html">구조체 생성자</a></li>
<li><a href="names/../items/enumerations.html">열거형 변형 생성자</a></li>
<li><a href="names/../paths.html#self-1"><code>Self</code> 생성자</a></li>
<li><a href="names/../items/generics.html#const-generics">제네릭 상수 매개변수</a></li>
<li><a href="names/../items/associated-items.html#associated-constants">연관 상수 선언</a></li>
<li><a href="names/../items/associated-items.html#associated-functions-and-methods">연관 함수 선언</a></li>
<li>Local bindings — <a href="names/../statements.html#let-statements"><code>let</code></a>, <a href="names/../expressions/if-expr.html#if-let-patterns"><code>if let</code></a>, <a href="names/../expressions/loop-expr.html#while-let-patterns"><code>while let</code></a>, <a href="names/../expressions/loop-expr.html#iterator-loops"><code>for</code></a>, <a href="names/../expressions/match-expr.html"><code>match</code></a> arms, <a href="names/../items/functions.html#function-parameters">function parameters</a>, <a href="names/../expressions/closure-expr.html">closure parameters</a></li>
<li>캡처된 <a href="names/../expressions/closure-expr.html">클로저</a> 변수</li>
</ul>
</li>
<li>매크로 네임스페이스
<ul>
<li><a href="names/../macros-by-example.html"><code>macro_rules</code> 선언</a></li>
<li><a href="names/../attributes.html#built-in-attributes-index">내장 속성</a></li>
<li><a href="names/../attributes.html#tool-attributes">도구 속성</a></li>
<li><a href="names/../procedural-macros.html#the-proc_macro-attribute">Function-like procedural macros</a></li>
<li><a href="names/macro.proc.derive">Derive macros</a></li>
<li><a href="names/../procedural-macros.html#derive-macro-helper-attributes">Derive 매크로 도우미</a></li>
<li><a href="names/../procedural-macros.html#the-proc_macro_attribute-attribute">Attribute macros</a></li>
</ul>
</li>
<li>라이프타임 네임스페이스
<ul>
<li><a href="names/../items/generics.html">제네릭 라이프타임 매개변수</a></li>
</ul>
</li>
<li>레이블 네임스페이스
<ul>
<li><a href="names/../expressions/loop-expr.html#loop-labels">루프 레이블</a></li>
<li><a href="names/expr.loop.block-labels">Block labels</a></li>
</ul>
</li>
</ul>
<p>다른 네임스페이스에서 겹치는 이름을 모호하지 않게 사용하는 예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Foo는 타입 네임스페이스에 타입을 도입하고 값 네임스페이스에
// 생성자를 도입합니다.
struct Foo(u32);

// `Foo` 매크로는 매크로 네임스페이스에 선언됩니다.
macro_rules! Foo {
    () =&gt; {};
}

// `f` 매개변수 타입의 `Foo`는 타입 네임스페이스의 `Foo`를 참조합니다.
// `'Foo`는 라이프타임 네임스페이스에 새로운 라이프타임을 도입합니다.
fn example&lt;'Foo&gt;(f: Foo) {
    // `Foo`는 값 네임스페이스의 `Foo` 생성자를 참조합니다.
    let ctor = Foo;
    // `Foo`는 매크로 네임스페이스의 `Foo` 매크로를 참조합니다.
    Foo!{}
    // `'Foo`는 레이블 네임스페이스에 레이블을 도입합니다.
    'Foo: loop {
        // `'Foo`는 `'Foo` 라이프타임 매개변수를 참조하며, `Foo`는
        // 타입 네임스페이스를 참조합니다.
        let x: &amp;'Foo Foo;
        // `'Foo`는 레이블을 참조합니다.
        break 'Foo;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>r[names.namespaces.without]</p>
<h2 id="네임스페이스가-없는-명명된-엔터티"><a class="header" href="#네임스페이스가-없는-명명된-엔터티">네임스페이스가 없는 명명된 엔터티</a></h2>
<p>다음 엔터티는 명시적인 이름을 가지고 있지만, 그 이름은 특정 네임스페이스의 일부가 아닙니다.</p>
<h3 id="필드"><a class="header" href="#필드">필드</a></h3>
<p>r[names.namespaces.without.fields] Even though struct, enum, and union fields are named, the named fields do not live in an explicit namespace. They can only be accessed via a <a href="names/../expressions/field-expr.html">field expression</a>, which only inspects the field names of the specific type being accessed.</p>
<h3 id="use-선언-1"><a class="header" href="#use-선언-1">Use 선언</a></h3>
<p>r[names.namespaces.without.use] A <a href="names/../items/use-declarations.html">use declaration</a> has named aliases that it imports into scope, but the <code>use</code> item itself does not belong to a specific namespace. Instead, it can introduce aliases into multiple namespaces, depending on the item kind being imported.</p>
<p>r[names.namespaces.sub-namespaces]</p>
<h2 id="서브-네임스페이스"><a class="header" href="#서브-네임스페이스">서브 네임스페이스</a></h2>
<p>r[names.namespaces.sub-namespaces.intro] The macro namespace is split into two sub-namespaces: one for <a href="names/../macros.html">bang-style macros</a> and one for <a href="names/../attributes.html">attributes</a>. When an attribute is resolved, any bang-style macros in scope will be ignored. And conversely resolving a bang-style macro will ignore attribute macros in scope. This prevents one style from shadowing another.</p>
<p>예를 들어, <a href="names/../conditional-compilation.html#the-cfg-attribute"><code>cfg</code> 속성</a>과 <a href="names/../conditional-compilation.html#the-cfg-macro"><code>cfg</code> 매크로</a>는 매크로 네임스페이스에서 같은 이름을 가진 서로 다른 두 엔터티이지만, 여전히 각각의 컨텍스트에서 사용할 수 있습니다.</p>
<!-- ignore: requires external crates -->
<blockquote>
<p>[!NOTE] <code>use</code> imports still cannot create duplicate bindings of the same name in a module or block, regardless of sub-namespace.</p>
<pre><code class="language-rust ignore">#[macro_export]
macro_rules! mymac {
    () =&gt; {};
}

use myattr::mymac; // error[E0252]: the name `mymac` is defined multiple times.</code></pre>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>r[names.scopes]</p>
<h1 id="스코프"><a class="header" href="#스코프">스코프</a></h1>
<p>r[names.scopes.intro] A <em>scope</em> is the region of source text where a named <a href="names/../names.html">entity</a> may be referenced with that name. The following sections provide details on the scoping rules and behavior, which depend on the kind of entity and where it is declared. The process of how names are resolved to entities is described in the <a href="names/name-resolution.html">name resolution</a> chapter. More information on “drop scopes” used for the purpose of running destructors may be found in the <a href="names/../destructors.html">destructors</a> chapter.</p>
<p>r[names.scopes.items]</p>
<h2 id="아이템-스코프"><a class="header" href="#아이템-스코프">아이템 스코프</a></h2>
<p>r[names.scopes.items.module] The name of an <a href="names/../items.html">item</a> declared directly in a <a href="names/../items/modules.html">module</a> has a scope that extends from the start of the module to the end of the module. These items are also members of the module and can be referred to with a <a href="names/../paths.html">path</a> leading from their module.</p>
<p>r[names.scopes.items.statement] The name of an item declared as a <a href="names/../statements.html">statement</a> has a scope that extends from the start of the block the item statement is in until the end of the block.</p>
<p>r[names.scopes.items.duplicate] It is an error to introduce an item with a duplicate name of another item in the same <a href="names/namespaces.html">namespace</a> within the same module or block. <a href="names/../items/use-declarations.html">Asterisk glob imports</a> have special behavior for dealing with duplicate names and shadowing, see the linked chapter for more details.</p>
<p>r[names.scopes.items.shadow-prelude] Items in a module may shadow items in a <a href="names/scopes.html#prelude-scopes">prelude</a>.</p>
<p>r[names.scopes.items.nested-modules] Item names from outer modules are not in scope within a nested module. A <a href="names/../paths.html">path</a> may be used to refer to an item in another module.</p>
<p>r[names.scopes.associated-items]</p>
<h3 id="연관-아이템-스코프"><a class="header" href="#연관-아이템-스코프">연관 아이템 스코프</a></h3>
<p>r[names.scopes.associated-items.scope] <a href="names/../items/associated-items.html">Associated items</a> are not scoped and can only be referred to by using a <a href="names/../paths.html">path</a> leading from the type or trait they are associated with. <a href="names/../items/associated-items.html#methods">Methods</a> can also be referred to via <a href="names/../expressions/call-expr.html">call expressions</a>.</p>
<p>r[names.scopes.associated-items.duplicate] Similar to items within a module or block,  it is an error to introduce an item within a trait or implementation that is a duplicate of another item in the trait or impl in the same namespace.</p>
<p>r[names.scopes.pattern-bindings]</p>
<h2 id="패턴-바인딩-스코프"><a class="header" href="#패턴-바인딩-스코프">패턴 바인딩 스코프</a></h2>
<p>지역 변수 <a href="names/../patterns.html">패턴</a> 바인딩의 스코프는 사용되는 위치에 따라 다릅니다:</p>
<p>r[names.scopes.pattern-bindings.let]</p>
<ul>
<li><a href="names/../statements.html#let-statements"><code>let</code> statement</a> bindings range from just after the <code>let</code> statement until the end of the block where it is declared. r[names.scopes.pattern-bindings.parameter]</li>
<li><a href="names/../items/functions.html#function-parameters">Function parameter</a> bindings are within the body of the function. r[names.scopes.pattern-bindings.closure]</li>
<li><a href="names/../expressions/closure-expr.html">Closure parameter</a> bindings are within the closure body. r[names.scopes.pattern-bindings.loop]</li>
<li><a href="names/../expressions/loop-expr.html#iterator-loops"><code>for</code></a> bindings are within the loop body. r[names.scopes.pattern-bindings.let-chains]</li>
<li><a href="names/../expressions/if-expr.html#if-let-patterns"><code>if let</code></a> and <a href="names/../expressions/loop-expr.html#while-let-patterns"><code>while let</code></a> bindings are valid in the following conditions as well as the consequent block. r[names.scopes.pattern-bindings.match-arm]</li>
<li><a href="names/../expressions/match-expr.html"><code>match</code> 암</a> 바인딩은 <a href="names/../expressions/match-expr.html#match-guards">매치 가드</a> 및 매치 암 표현식 내에 있습니다.</li>
</ul>
<p>r[names.scopes.pattern-bindings.items] Local variable scopes do not extend into item declarations.</p>
<!-- Not entirely, see https://github.com/rust-lang/rust/issues/33118 -->
<h3 id="패턴-바인딩-가림"><a class="header" href="#패턴-바인딩-가림">패턴 바인딩 가림</a></h3>
<p>r[names.scopes.pattern-bindings.shadow] Pattern bindings are allowed to shadow any name in scope with the following exceptions which are an error:</p>
<ul>
<li><a href="names/../items/generics.html#const-generics">상수 제네릭 매개변수</a></li>
<li><a href="names/../items/static-items.html">정적 아이템</a></li>
<li><a href="names/../items/constant-items.html">상수 아이템</a></li>
<li><a href="names/../items/structs.html">구조체</a> 및 <a href="names/../items/enumerations.html">열거형</a>의 생성자</li>
</ul>
<p>다음 예제는 지역 바인딩이 아이템 선언을 어떻게 가릴 수 있는지 보여줍니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn shadow_example() {
    // 아직 스코프에 지역 변수가 없으므로, 이것은 함수로 확인됩니다.
    foo(); // `function` 출력
    let foo = || println!("클로저");
    fn foo() { println!("함수"); }
    // 아이템을 가리므로 이것은 지역 클로저로 확인됩니다.
    foo(); // `closure` 출력
}
<span class="boring">}</span></code></pre></pre>
<p>r[names.scopes.generic-parameters]</p>
<h2 id="제네릭-매개변수-스코프"><a class="header" href="#제네릭-매개변수-스코프">제네릭 매개변수 스코프</a></h2>
<p>r[names.scopes.generic-parameters.param-list] Generic parameters are declared in a [GenericParams] list. The scope of a generic parameter is within the item it is declared on.</p>
<p>r[names.scopes.generic-parameters.order-independent] All parameters are in scope within the generic parameter list regardless of the order they are declared. The following shows some examples where a parameter may be referenced before it is declared:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 'b 바운드는 선언되기 전에 참조됩니다.
fn params_scope&lt;'a: 'b, 'b&gt;() {}

<span class="boring">trait SomeTrait&lt;const Z: usize&gt; {}
</span>// 상수 N은 선언되기 전에 트레잇 바운드에서 참조됩니다.
fn f&lt;T: SomeTrait&lt;N&gt;, const N: usize&gt;() {}
<span class="boring">}</span></code></pre></pre>
<p>r[names.scopes.generic-parameters.bounds] Generic parameters are also in scope for type bounds and where clauses, for example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait SomeTrait&lt;'a, T&gt; {}
</span>// `SomeTrait`의 &lt;'a, U&gt;는 `bounds_scope`의 'a와 U 매개변수를 참조합니다.
fn bounds_scope&lt;'a, T: SomeTrait&lt;'a, U&gt;, U&gt;() {}

fn where_scope&lt;'a, T, U&gt;()
    where T: SomeTrait&lt;'a, U&gt;
{}
<span class="boring">}</span></code></pre></pre>
<p>r[names.scopes.generic-parameters.inner-items] It is an error for <a href="names/../items.html">items</a> declared inside a function to refer to a generic parameter from their outer scope.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn example&lt;T&gt;() {
    fn inner(x: T) {} // 오류: 외부 함수의 제네릭 매개변수를 사용할 수 없습니다
}
<span class="boring">}</span></code></pre></pre>
<h3 id="제네릭-매개변수-가리기shadowing"><a class="header" href="#제네릭-매개변수-가리기shadowing">제네릭 매개변수 가리기(Shadowing)</a></h3>
<p>r[names.scopes.generic-parameters.shadow] It is an error to shadow a generic parameter with the exception that items declared within functions are allowed to shadow generic parameter names from the function.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn example&lt;'a, T, const N: usize&gt;() {
    // 함수 내의 아이템은 스코프 내의 제네릭 매개변수를 가릴 수 있습니다.
    fn inner_lifetime&lt;'a&gt;() {} // OK
    fn inner_type&lt;T&gt;() {} // OK
    fn inner_const&lt;const N: usize&gt;() {} // OK
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait SomeTrait&lt;'a, T, const N: usize&gt; {
    fn example_lifetime&lt;'a&gt;() {} // 오류: 'a는 이미 사용 중입니다
    fn example_type&lt;T&gt;() {} // 오류: T는 이미 사용 중입니다
    fn example_const&lt;const N: usize&gt;() {} // 오류: N은 이미 사용 중입니다
    fn example_mixed&lt;const T: usize&gt;() {} // 오류: T는 이미 사용 중입니다
}
<span class="boring">}</span></code></pre></pre>
<p>r[names.scopes.lifetimes]</p>
<h3 id="라이프타임-스코프"><a class="header" href="#라이프타임-스코프">라이프타임 스코프</a></h3>
<p>Lifetime parameters are declared in a [GenericParams] list and <a href="names/../trait-bounds.html#higher-ranked-trait-bounds">higher-ranked trait bounds</a>.</p>
<p>r[names.scopes.lifetimes.special] The <code>'static</code> lifetime and <a href="names/../lifetime-elision.html">placeholder lifetime</a> <code>'_</code> have a special meaning and cannot be declared as a parameter.</p>
<h4 id="라이프타임-제네릭-매개변수-스코프"><a class="header" href="#라이프타임-제네릭-매개변수-스코프">라이프타임 제네릭 매개변수 스코프</a></h4>
<p>r[names.scopes.lifetimes.generic] <a href="names/../items/constant-items.html">Constant</a> and <a href="names/../items/static-items.html">static</a> items and <a href="names/../const_eval.html#const-context">const contexts</a> only ever allow <code>'static</code> lifetime references, so no other lifetime may be in scope within them. <a href="names/../items/associated-items.html#associated-constants">Associated consts</a> do allow referring to lifetimes declared in their trait or implementation.</p>
<h4 id="고차-트레잇-바운드-스코프"><a class="header" href="#고차-트레잇-바운드-스코프">고차 트레잇 바운드 스코프</a></h4>
<p>r[names.scopes.lifetimes.higher-ranked] The scope of a lifetime parameter declared as a <a href="names/../trait-bounds.html#higher-ranked-trait-bounds">higher-ranked trait bound</a> depends on the scenario where it is used.</p>
<ul>
<li>As a [TypeBoundWhereClauseItem] the declared lifetimes are in scope in the type and the type bounds.</li>
<li>As a [TraitBound] the declared lifetimes are in scope within the bound type path.</li>
<li>As a [BareFunctionType] the declared lifetimes are in scope within the function parameters and return type.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait&lt;'a&gt;{}
</span>
fn where_clause&lt;T&gt;()
    // 'a는 타입과 타입 바운드 모두에서 스코프에 있습니다.
    where for &lt;'a&gt; &amp;'a T: Trait&lt;'a&gt;
{}

fn bound&lt;T&gt;()
    // 'a는 바운드 내에서 스코프에 있습니다.
    where T: for &lt;'a&gt; Trait&lt;'a&gt;
{}

<span class="boring">struct Example&lt;'a&gt; {
</span><span class="boring">    field: &amp;'a u32
</span><span class="boring">}
</span>
// 'a는 매개변수와 반환 타입 모두에서 스코프에 있습니다.
type FnExample = for&lt;'a&gt; fn(x: Example&lt;'a&gt;) -&gt; Example&lt;'a&gt;;
<span class="boring">}</span></code></pre></pre>
<h4 id="impl-트레잇-제약"><a class="header" href="#impl-트레잇-제약">Impl 트레잇 제약</a></h4>
<p>r[names.scopes.lifetimes.impl-trait] <a href="names/../types/impl-trait.html">Impl trait</a> types can only reference lifetimes declared on a function or implementation.</p>
<!-- not able to demonstrate the scope error because the compiler panics
     https://github.com/rust-lang/rust/issues/67830
-->
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait1 {
</span><span class="boring">    type Item;
</span><span class="boring">}
</span><span class="boring">trait Trait2&lt;'a&gt; {}
</span><span class="boring">
</span><span class="boring">struct Example;
</span><span class="boring">
</span><span class="boring">impl Trait1 for Example {
</span><span class="boring">    type Item = Element;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Element;
</span><span class="boring">impl&lt;'a&gt; Trait2&lt;'a&gt; for Element {}
</span><span class="boring">
</span>// 여기의 `impl Trait2`는 'b를 참조할 수 없지만 'a를 참조하는 것은
// 허용됩니다.
fn foo&lt;'a&gt;() -&gt; impl for&lt;'b&gt; Trait1&lt;Item = impl Trait2&lt;'a&gt; + use&lt;'a&gt;&gt; {
    // ...
<span class="boring">   Example
</span>}
<span class="boring">}</span></code></pre></pre>
<p>r[names.scopes.loop-label]</p>
<h2 id="루프-레이블-스코프"><a class="header" href="#루프-레이블-스코프">루프 레이블 스코프</a></h2>
<p>r[names.scopes.loop-label.scope] <a href="names/../expressions/loop-expr.html#loop-labels">Loop labels</a> may be declared by a <a href="names/../expressions/loop-expr.html">loop expression</a>. The scope of a loop label is from the point it is declared till the end of the loop expression. The scope does not extend into <a href="names/../items.html">items</a>, <a href="names/../expressions/closure-expr.html">closures</a>, <a href="names/../expressions/block-expr.html#async-blocks">async blocks</a>, <a href="names/../items/generics.html#const-generics">const arguments</a>, <a href="names/../const_eval.html#const-context">const contexts</a>, and the iterator expression of the defining <a href="names/../expressions/loop-expr.html#iterator-loops"><code>for</code> loop</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>'a: for n in 0..3 {
    if n % 2 == 0 {
        break 'a;
    }
    fn inner() {
        // 여기서 'a를 사용하는 것은 오류입니다.
        // break 'a;
    }
}

// 레이블은 `while` 루프의 표현식에 대한 스코프에 있습니다.
'a: while break 'a {}         // 루프가 실행되지 않습니다.
'a: while let _ = break 'a {} // 루프가 실행되지 않습니다.

// 레이블은 정의하는 `for` 루프에서 스코프에 있지 않습니다:
'a: for outer in 0..5 {
    // 이것은 외부 루프를 중단하여 내부 루프를 건너뛰고
    // 외부 루프를 멈춥니다.
    'a: for inner in { break 'a; 0..1 } {
        println!("{}", inner); // 이것은 실행되지 않습니다.
    }
    println!("{}", outer); // 이것도 실행되지 않습니다.
}

<span class="boring">}</span></code></pre></pre>
<p>r[names.scopes.loop-label.shadow] Loop labels may shadow labels of the same name in outer scopes. References to a label refer to the closest definition.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 루프 레이블 가림 예제.
'a: for outer in 0..5 {
    'a: for inner in 0..5 {
        // 이것은 내부 루프를 종료하지만, 외부 루프는 계속 실행됩니다.
        break 'a;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>r[names.scopes.prelude]</p>
<h2 id="프렐류드-스코프"><a class="header" href="#프렐류드-스코프">프렐류드 스코프</a></h2>
<p>r[names.scopes.prelude.intro] <a href="names/preludes.html">Preludes</a> bring entities into scope of every module. The entities are not members of the module, but are implicitly queried during <a href="names/name-resolution.html">name resolution</a>.</p>
<p>r[names.scopes.prelude.shadow] The prelude names may be shadowed by declarations in a module.</p>
<p>r[names.scopes.prelude.layers] The preludes are layered such that one shadows another if they contain entities of the same name. The order that preludes may shadow other preludes is the following where earlier entries may shadow later ones:</p>
<ol>
<li><a href="names/preludes.html#extern-prelude">외부 프렐류드</a></li>
<li><a href="names/preludes.html#tool-prelude">도구 프렐류드</a></li>
<li><a href="names/preludes.html#macro_use-prelude"><code>macro_use</code> 프렐류드</a></li>
<li><a href="names/preludes.html#standard-library-prelude">표준 라이브러리 프렐류드</a></li>
<li><a href="names/preludes.html#language-prelude">언어 프렐류드</a></li>
</ol>
<p>r[names.scopes.macro_rules]</p>
<h2 id="macro_rules-스코프"><a class="header" href="#macro_rules-스코프"><code>macro_rules</code> 스코프</a></h2>
<p>The scope of <code>macro_rules</code> macros is described in the <a href="names/../macros-by-example.html">Macros By Example</a> chapter. The behavior depends on the use of the <a href="names/../macros-by-example.html#the-macro_use-attribute"><code>macro_use</code></a> and <a href="names/../macros-by-example.html#the-macro_export-attribute"><code>macro_export</code></a> attributes.</p>
<p>r[names.scopes.derive]</p>
<h2 id="파생-매크로-헬퍼-속성-1"><a class="header" href="#파생-매크로-헬퍼-속성-1">파생 매크로 헬퍼 속성</a></h2>
<p>r[names.scopes.derive.scope] <a href="names/../procedural-macros.html#derive-macro-helper-attributes">Derive macro helper attributes</a> are in scope in the item where their corresponding <a href="names/../attributes/derive.html"><code>derive</code> attribute</a> is specified. The scope extends from just after the <code>derive</code> attribute to the end of the item. <!-- Note: Not strictly true, see https://github.com/rust-lang/rust/issues/79202, but this is the intention. --></p>
<p>r[names.scopes.derive.shadow] Helper attributes shadow other attributes of the same name in scope.</p>
<p>r[names.scopes.self]</p>
<h2 id="self-스코프"><a class="header" href="#self-스코프"><code>Self</code> 스코프</a></h2>
<p>r[names.scopes.self.intro] Although <a href="names/../paths.html#self-1"><code>Self</code></a> is a keyword with special meaning, it interacts with name resolution in a way similar to normal names.</p>
<p>r[names.scopes.self.def-scope] The implicit <code>Self</code> type in the definition of a <a href="names/../items/structs.html">struct</a>, <a href="names/../items/enumerations.html">enum</a>, <a href="names/../items/unions.html">union</a>, <a href="names/../items/traits.html">trait</a>, or <a href="names/../items/implementations.html">implementation</a> is treated similarly to a <a href="names/scopes.html#generic-parameter-scopes">generic parameter</a>, and is in scope in the same way as a generic type parameter.</p>
<p>r[names.scopes.self.impl-scope] The implicit <code>Self</code> constructor in the value <a href="names/namespaces.html">namespace</a> of an <a href="names/../items/implementations.html">implementation</a> is in scope within the body of the implementation (the implementation’s <a href="names/../items/associated-items.html">associated items</a>).</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 구조체 정의 내의 Self 타입.
struct Recursive {
    f1: Option&lt;Box&lt;Self&gt;&gt;
}

// 제네릭 매개변수 내의 Self 타입.
struct SelfGeneric&lt;T: Into&lt;Self&gt;&gt;(T);

// 구현 내의 Self 값 생성자.
struct ImplExample();
impl ImplExample {
    fn example() -&gt; Self { // Self 타입
        Self() // Self 값 생성자
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p>r[names.preludes]</p>
<h1 id="프렐류드"><a class="header" href="#프렐류드">프렐류드</a></h1>
<p>r[names.preludes.intro] A <em>prelude</em> is a collection of names that are automatically brought into scope of every module in a crate.</p>
<p>These prelude names are not part of the module itself: they are implicitly queried during <a href="names/name-resolution.html">name resolution</a>. For example, even though something like [<code>Box</code>] is in scope in every module, you cannot refer to it as <code>self::Box</code> because it is not a member of the current module.</p>
<p>r[names.preludes.kinds] There are several different preludes:</p>
<ul>
<li><a href="names/names.preludes.std">Standard library prelude</a></li>
<li><a href="names/preludes.html#extern-prelude">외부 프렐류드</a></li>
<li><a href="names/preludes.html#language-prelude">언어 프렐류드</a></li>
<li><a href="names/preludes.html#macro_use-prelude"><code>macro_use</code> 프렐류드</a></li>
<li><a href="names/preludes.html#tool-prelude">도구 프렐류드</a></li>
</ul>
<p>r[names.preludes.std]</p>
<h2 id="표준-라이브러리-프렐류드"><a class="header" href="#표준-라이브러리-프렐류드">표준 라이브러리 프렐류드</a></h2>
<p>r[names.preludes.std.intro] Each crate has a standard library prelude, which consists of the names from a single standard library module.</p>
<p>r[names.preludes.std.module] The module used depends on the crate’s edition, and on whether the <a href="names/preludes.html#the-no_std-attribute"><code>no_std</code> attribute</a> is applied to the crate:</p>
<div class="table-wrapper"><table><thead><tr><th>에디션</th><th><code>no_std</code> 적용되지 않음</th><th><code>no_std</code> 적용됨</th></tr></thead><tbody>
<tr><td>2015</td><td>[<code>std::prelude::rust_2015</code>]</td><td>[<code>core::prelude::rust_2015</code>]</td></tr>
<tr><td>2018</td><td>[<code>std::prelude::rust_2018</code>]</td><td>[<code>core::prelude::rust_2018</code>]</td></tr>
<tr><td>2021</td><td>[<code>std::prelude::rust_2021</code>]</td><td>[<code>core::prelude::rust_2021</code>]</td></tr>
<tr><td>2024</td><td>[<code>std::prelude::rust_2024</code>]</td><td>[<code>core::prelude::rust_2024</code>]</td></tr>
</tbody></table>
</div>
<blockquote>
<p>[!NOTE] [<code>std::prelude::rust_2015</code>] and [<code>std::prelude::rust_2018</code>] have the same contents as [<code>std::prelude::v1</code>].</p>
<p>[<code>core::prelude::rust_2015</code>] and [<code>core::prelude::rust_2018</code>] have the same contents as [<code>core::prelude::v1</code>].</p>
</blockquote>
<p>r[names.preludes.extern]</p>
<h2 id="외부-프렐류드"><a class="header" href="#외부-프렐류드">외부 프렐류드</a></h2>
<p>r[names.preludes.extern.intro] External crates imported with <a href="names/../items/extern-crates.html"><code>extern crate</code></a> in the root module or provided to the compiler (as with the <code>--extern</code> flag with <code>rustc</code>) are added to the <em>extern prelude</em>. If imported with an alias such as <code>extern crate orig_name as new_name</code>, then the symbol <code>new_name</code> is instead added to the prelude.</p>
<p>r[names.preludes.extern.core] The [<code>core</code>] crate is always added to the extern prelude.</p>
<p>r[names.preludes.extern.std] The [<code>std</code>] crate is added as long as the <a href="names/preludes.html#the-no_std-attribute"><code>no_std</code> attribute</a> is not specified in the crate root.</p>
<p>r[names.preludes.extern.edition2018]</p>
<blockquote>
<p>[!EDITION-2018] In the 2015 edition, crates in the extern prelude cannot be referenced via <a href="names/../items/use-declarations.html">use declarations</a>, so it is generally standard practice to include <code>extern crate</code> declarations to bring them into scope.</p>
<p>2018 에디션부터 <a href="names/../items/use-declarations.html">use 선언</a>은 외부 프렐류드의 크레이트를 참조할 수 있으므로, <code>extern crate</code>를 사용하는 것은 관용적이지(unidiomatic) 않은 것으로 간주됩니다.</p>
</blockquote>
<blockquote>
<p>[!NOTE] Additional crates that ship with <code>rustc</code>, such as [<code>alloc</code>], and <a href="names/mod@test"><code>test</code></a>, are not automatically included with the <code>--extern</code> flag when using Cargo. They must be brought into scope with an <code>extern crate</code> declaration, even in the 2018 edition.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate alloc;
use alloc::rc::Rc;
<span class="boring">}</span></code></pre></pre>
<p>Cargo는 오직 절차적 매크로(proc-macro) 크레이트에 대해서만 <code>proc_macro</code>를 외부 프렐류드로 가져옵니다.</p>
</blockquote>
<!--
See https://github.com/rust-lang/rust/issues/57288 for more about the
alloc/test limitation.
-->
<!-- template:attributes -->
<p>r[names.preludes.extern.no_std]</p>
<h3 id="no_std-속성"><a class="header" href="#no_std-속성"><code>no_std</code> 속성</a></h3>
<p>r[names.preludes.extern.no_std.intro] The <em><code>no_std</code> [attribute][attributes]</em> causes the [<code>std</code>] crate to not be linked automatically, the <a href="names/names.preludes.std">standard library prelude</a> to instead use the <code>core</code> prelude, and the <a href="names/preludes.html#macro_use-prelude"><code>macro_use</code> prelude</a> to instead use the macros exported from the <code>core</code> crate.</p>
<blockquote>
<p>[!EXAMPLE]</p>
<!-- ignore: test infrastructure can't handle no_std -->
<pre><code class="language-rust ignore">#![no_std]</code></pre>
</blockquote>
<blockquote>
<p>[!NOTE] Using <code>no_std</code> is useful when either the crate is targeting a platform that does not support the standard library or is purposefully not using the capabilities of the standard library. Those capabilities are mainly dynamic memory allocation (e.g. <code>Box</code> and <code>Vec</code>) and file and network capabilities (e.g. <code>std::fs</code> and <code>std::io</code>).</p>
</blockquote>
<blockquote>
<p>[!WARNING] Using <code>no_std</code> does not prevent the standard library from being linked. It is still valid to write <code>extern crate std</code> in the crate or in one of its dependencies; this will cause the compiler to link the <code>std</code> crate into the program.</p>
</blockquote>
<p>r[names.preludes.extern.no_std.syntax] The <code>no_std</code> attribute uses the [MetaWord] syntax.</p>
<p>r[names.preludes.extern.no_std.allowed-positions] The <code>no_std</code> attribute may only be applied to the crate root.</p>
<p>r[names.preludes.extern.no_std.duplicates] The <code>no_std</code> attribute may be used any number of times on a form.</p>
<blockquote>
<p>[!NOTE] <code>rustc</code> lints against any use following the first.</p>
</blockquote>
<p>r[names.preludes.extern.no_std.module] The <code>no_std</code> attribute changes the <a href="names/names.preludes.std">standard library prelude</a> to use the <code>core</code> prelude instead of the <code>std</code> prelude.</p>
<p>r[names.preludes.extern.no_std.macro_use] By default, all macros exported from the <code>std</code> crate are added to the <a href="names/preludes.html#macro_use-prelude"><code>macro_use</code> prelude</a>. If the <code>no_std</code> attribute is specified, then all macros exported from the <code>core</code> crate are placed into the <a href="names/preludes.html#macro_use-prelude"><code>macro_use</code> prelude</a> instead.</p>
<p>r[names.preludes.extern.no_std.edition2018]</p>
<blockquote>
<p>[!EDITION-2018] Before the 2018 edition, <code>std</code> is injected into the crate root by default. If <code>no_std</code> is specified, <code>core</code> is injected instead. Starting with the 2018 edition, regardless of <code>no_std</code> being specified, neither is injected into the crate root.</p>
</blockquote>
<p>r[names.preludes.lang]</p>
<h2 id="언어-프렐류드"><a class="header" href="#언어-프렐류드">언어 프렐류드</a></h2>
<p>r[names.preludes.lang.intro] The language prelude includes names of types and attributes that are built-in to the language. The language prelude is always in scope.</p>
<p>r[names.preludes.lang.entities] It includes the following:</p>
<ul>
<li><a href="names/namespaces.html">타입 네임스페이스</a>
<ul>
<li><a href="names/../types/boolean.html">불리언 타입</a> — <code>bool</code></li>
<li><a href="names/../types/textual.html">텍스트 타입</a> — <code>char</code> 및 <code>str</code></li>
<li><a href="names/../types/numeric.html#integer-types">정수 타입</a> — <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code></li>
<li><a href="names/../types/numeric.html#machine-dependent-integer-types">머신 의존적 정수 타입</a> — <code>usize</code> 및 <code>isize</code></li>
<li><a href="names/../types/numeric.html#floating-point-types">부동 소수점 타입</a> — <code>f32</code> 및 <code>f64</code></li>
</ul>
</li>
<li><a href="names/namespaces.html">매크로 네임스페이스</a>
<ul>
<li><a href="names/../attributes.html#built-in-attributes-index">내장 속성</a></li>
<li>[Built-in derive macros][attributes.derive.built-in]</li>
</ul>
</li>
</ul>
<p>r[names.preludes.macro_use]</p>
<h2 id="macro_use-프렐류드"><a class="header" href="#macro_use-프렐류드"><code>macro_use</code> 프렐류드</a></h2>
<p>r[names.preludes.macro_use.intro] The <code>macro_use</code> prelude includes macros from external crates that were imported by the <a href="names/../macros-by-example.html#the-macro_use-attribute"><code>macro_use</code> attribute</a> applied to an <a href="names/../items/extern-crates.html"><code>extern crate</code></a>.</p>
<p>r[names.preludes.tool]</p>
<h2 id="도구-프렐류드"><a class="header" href="#도구-프렐류드">도구 프렐류드</a></h2>
<p>r[names.preludes.tool.intro] The tool prelude includes tool names for external tools in the <a href="names/namespaces.html">type namespace</a>. See the <a href="names/../attributes.html#tool-attributes">tool attributes</a> section for more details.</p>
<!-- template:attributes -->
<p>r[names.preludes.no_implicit_prelude]</p>
<h2 id="no_implicit_prelude-속성"><a class="header" href="#no_implicit_prelude-속성"><code>no_implicit_prelude</code> 속성</a></h2>
<p>r[names.preludes.no_implicit_prelude.intro] The <em><code>no_implicit_prelude</code> <a href="names/../attributes.html">attribute</a></em> is used to prevent implicit preludes from being brought into scope.</p>
<blockquote>
<p>[!EXAMPLE]</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The attribute can be applied to the crate root to affect
// all modules.
#![no_implicit_prelude]

// Or it can be applied to a module to only affect that module
// and its descendants.
#[no_implicit_prelude]
mod example {
    // ...
}
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[names.preludes.no_implicit_prelude.syntax] The <code>no_implicit_prelude</code> attribute uses the [MetaWord] syntax.</p>
<p>r[names.preludes.no_implicit_prelude.allowed-positions] The <code>no_implicit_prelude</code> attribute may only be applied to the crate or to a module.</p>
<blockquote>
<p>[!NOTE] <code>rustc</code> ignores use in other positions but lints against it. This may become an error in the future.</p>
</blockquote>
<p>r[names.preludes.no_implicit_prelude.duplicates] The <code>no_implicit_prelude</code> attribute may be used any number of times on a form.</p>
<blockquote>
<p>[!NOTE] <code>rustc</code> lints against any use following the first.</p>
</blockquote>
<p>r[names.preludes.no_implicit_prelude.excluded-preludes] The <code>no_implicit_prelude</code> attribute prevents the <a href="names/names.preludes.std">standard library prelude</a>, <a href="names/preludes.html#extern-prelude">extern prelude</a>, <a href="names/preludes.html#macro_use-prelude"><code>macro_use</code> prelude</a>, and the <a href="names/preludes.html#tool-prelude">tool prelude</a> from being brought into scope for the module and its descendants.</p>
<p>r[names.preludes.no_implicit_prelude.lang] The <code>no_implicit_prelude</code> attribute does not affect the <a href="names/preludes.html#language-prelude">language prelude</a>.</p>
<p>r[names.preludes.no_implicit_prelude.edition2018]</p>
<blockquote>
<p>[!EDITION-2018] In the 2015 edition, the <code>no_implicit_prelude</code> attribute does not affect the <a href="names/preludes.html#macro_use-prelude"><code>macro_use</code> prelude</a>, and all macros exported from the standard library are still included in the <code>macro_use</code> prelude. Starting in the 2018 edition, the attribute does remove the <code>macro_use</code> prelude.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>r[paths]</p>
<h1 id="경로"><a class="header" href="#경로">경로</a></h1>
<p>r[paths.intro] A <em>path</em> is a sequence of one or more path segments separated by <code>::</code> tokens. Paths are used to refer to <a href="items.html">items</a>, values, <a href="types.html">types</a>, <a href="macros.html">macros</a>, and <a href="attributes.html">attributes</a>.</p>
<p>식별자 세그먼트로만 구성된 단순 경로의 두 가지 예:</p>
<!-- ignore: syntax fragment -->
<pre><code class="language-rust ignore">x;
x::y::z;</code></pre>
<h2 id="경로의-종류"><a class="header" href="#경로의-종류">경로의 종류</a></h2>
<p>r[paths.simple]</p>
<h3 id="simple-paths"><a class="header" href="#simple-paths">Simple paths</a></h3>
<p>r[paths.simple.syntax]</p>
<pre><code class="language-grammar paths">SimplePath -&gt;
    `::`? SimplePathSegment (`::` SimplePathSegment)*

SimplePathSegment -&gt;
    IDENTIFIER | `super` | `self` | `crate` | `$crate`
</code></pre>
<p>r[paths.simple.intro] Simple paths are used in <a href="visibility-and-privacy.html">visibility</a> markers, <a href="attributes.html">attributes</a>, <a href="macros-by-example.html">macros</a>, and <a href="items/use-declarations.html"><code>use</code></a> items. For example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{self, Write};
mod m {
    #[clippy::cyclomatic_complexity = "0"]
    pub (in super) fn f1() {}
}
<span class="boring">}</span></code></pre></pre>
<p>r[paths.expr]</p>
<h3 id="표현식에서의-경로"><a class="header" href="#표현식에서의-경로">표현식에서의 경로</a></h3>
<p>r[paths.expr.syntax]</p>
<pre><code class="language-grammar paths">PathInExpression -&gt;
    `::`? PathExprSegment (`::` PathExprSegment)*

PathExprSegment -&gt;
    PathIdentSegment (`::` GenericArgs)?

PathIdentSegment -&gt;
    IDENTIFIER | `super` | `self` | `Self` | `crate` | `$crate`

GenericArgs -&gt;
      `&lt;` `&gt;`
    | `&lt;` ( GenericArg `,` )* GenericArg `,`? `&gt;`

GenericArg -&gt;
    Lifetime | Type | GenericArgsConst | GenericArgsBinding | GenericArgsBounds

GenericArgsConst -&gt;
      BlockExpression
    | LiteralExpression
    | `-` LiteralExpression
    | SimplePathSegment

GenericArgsBinding -&gt;
    IDENTIFIER GenericArgs? `=` Type

GenericArgsBounds -&gt;
    IDENTIFIER GenericArgs? `:` TypeParamBounds
</code></pre>
<p>r[paths.expr.intro] Paths in expressions allow for paths with generic arguments to be specified. They are used in various places in <a href="expressions.html">expressions</a> and <a href="patterns.html">patterns</a>.</p>
<p>r[paths.expr.turbofish] The <code>::</code> token is required before the opening <code>&lt;</code> for generic arguments to avoid ambiguity with the less-than operator. This is colloquially known as “turbofish” syntax.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(0..10).collect::&lt;Vec&lt;_&gt;&gt;();
Vec::&lt;u8&gt;::with_capacity(1024);
<span class="boring">}</span></code></pre></pre>
<p>r[paths.expr.argument-order] The order of generic arguments is restricted to lifetime arguments, then type arguments, then const arguments, then equality constraints.</p>
<p>r[paths.expr.complex-const-params] Const arguments must be surrounded by braces unless they are a <a href="expressions/literal-expr.html">literal</a>, an <a href="items.generics.const.inferred">inferred const</a>, or a single segment path. An <a href="items.generics.const.inferred">inferred const</a> may not be surrounded by braces.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod m {
    pub const C: usize = 1;
}
const C: usize = m::C;
fn f&lt;const N: usize&gt;() -&gt; [u8; N] { [0; N] }

let _ = f::&lt;1&gt;(); // Literal.
let _: [_; 1] = f::&lt;_&gt;(); // Inferred const.
let _: [_; 1] = f::&lt;(((_)))&gt;(); // Inferred const.
let _ = f::&lt;C&gt;(); // Single segment path.
let _ = f::&lt;{ m::C }&gt;(); // Multi-segment path must be braced.
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;const N: usize&gt;() -&gt; [u8; N] { [0; _] }
let _: [_; 1] = f::&lt;{ _ }&gt;();
//                    ^ ERROR `_` not allowed here
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] In a generic argument list, an <a href="items.generics.const.inferred">inferred const</a> is parsed as an [inferred type][InferredType] but then semantically treated as a separate kind of <a href="items.generics.const.argument">const generic argument</a>.</p>
</blockquote>
<p>r[paths.expr.impl-trait-params] The synthetic type parameters corresponding to <code>impl Trait</code> types are implicit, and these cannot be explicitly specified.</p>
<p>r[paths.qualified]</p>
<h2 id="정규화된-경로qualified-paths"><a class="header" href="#정규화된-경로qualified-paths">정규화된 경로(Qualified paths)</a></h2>
<p>r[paths.qualified.syntax]</p>
<pre><code class="language-grammar paths">QualifiedPathInExpression -&gt; QualifiedPathType (`::` PathExprSegment)+

QualifiedPathType -&gt; `&lt;` Type (`as` TypePath)? `&gt;`

QualifiedPathInType -&gt; QualifiedPathType (`::` TypePathSegment)+
</code></pre>
<p>r[paths.qualified.intro] Fully qualified paths allow for disambiguating the path for <a href="items/implementations.html#trait-implementations">trait implementations</a> and for specifying <a href="paths.html#canonical-paths">canonical paths</a>. When used in a type specification, it supports using the type syntax specified below.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S;
impl S {
    fn f() { println!("S"); }
}
trait T1 {
    fn f() { println!("T1 f"); }
}
impl T1 for S {}
trait T2 {
    fn f() { println!("T2 f"); }
}
impl T2 for S {}
S::f();  // 내재적 구현(inherent impl)을 호출합니다.
&lt;S as T1&gt;::f();  // T1 트레잇 함수를 호출합니다.
&lt;S as T2&gt;::f();  // T2 트레잇 함수를 호출합니다.
<span class="boring">}</span></code></pre></pre>
<p>r[paths.type]</p>
<h3 id="타입에서의-경로"><a class="header" href="#타입에서의-경로">타입에서의 경로</a></h3>
<p>r[paths.type.syntax]</p>
<pre><code class="language-grammar paths">TypePath -&gt; `::`? TypePathSegment (`::` TypePathSegment)*

TypePathSegment -&gt; PathIdentSegment (`::`? (GenericArgs | TypePathFn))?

TypePathFn -&gt; `(` TypePathFnInputs? `)` (`-&gt;` TypeNoBounds)?

TypePathFnInputs -&gt; Type (`,` Type)* `,`?
</code></pre>
<p>r[paths.type.intro] Type paths are used within type definitions, trait bounds, type parameter bounds, and qualified paths.</p>
<p>r[paths.type.turbofish] Although the <code>::</code> token is allowed before the generics arguments, it is not required because there is no ambiguity like there is in [PathInExpression].</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">mod ops {
</span><span class="boring">    pub struct Range&lt;T&gt; {f1: T}
</span><span class="boring">    pub trait Index&lt;T&gt; {}
</span><span class="boring">    pub struct Example&lt;'a&gt; {f1: &amp;'a i32}
</span><span class="boring">}
</span><span class="boring">struct S;
</span>impl ops::Index&lt;ops::Range&lt;usize&gt;&gt; for S { /*...*/ }
fn i&lt;'a&gt;() -&gt; impl Iterator&lt;Item = ops::Example&lt;'a&gt;&gt; {
    // ...
<span class="boring">   const EXAMPLE: Vec&lt;ops::Example&lt;'static&gt;&gt; = Vec::new();
</span><span class="boring">   EXAMPLE.into_iter()
</span>}
type G = std::boxed::Box&lt;dyn std::ops::FnOnce(isize) -&gt; isize&gt;;
<span class="boring">}</span></code></pre></pre>
<p>r[paths.qualifiers]</p>
<h2 id="경로-한정자path-qualifiers"><a class="header" href="#경로-한정자path-qualifiers">경로 한정자(Path qualifiers)</a></h2>
<p>경로는 해석 방식의 의미를 변경하기 위해 앞에 다양한 한정자를 붙여 표시할 수 있습니다.</p>
<p>r[paths.qualifiers.global-root]</p>
<h3 id=""><a class="header" href="#"><code>::</code></a></h3>
<p>r[paths.qualifiers.global-root.intro] Paths starting with <code>::</code> are considered to be <em>global paths</em> where the segments of the path start being resolved from a place which differs based on edition. Each identifier in the path must resolve to an item.</p>
<p>r[paths.qualifiers.global-root.edition2018]</p>
<blockquote>
<p>[!EDITION-2018] In the 2015 Edition, identifiers resolve from the “crate root” (<code>crate::</code> in the 2018 edition), which contains a variety of different items, including external crates, default crates such as <code>std</code> or <code>core</code>, and items in the top level of the crate (including <code>use</code> imports).</p>
<p>2018 에디션부터 <code>::</code>로 시작하는 경로는 <a href="names/preludes.html#extern-prelude">외부 프렐류드(extern prelude)</a>에 있는 크레이트에서 해석됩니다. 즉, 그 뒤에는 반드시 크레이트 이름이 와야 합니다.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn foo() {
    // 2018 에디션에서는 외부 프렐류드를 통해 `std`에 접근합니다.
    // 2015 에디션에서는 크레이트 루트를 통해 `std`에 접근합니다.
    let now = ::std::time::Instant::now();
    println!("{:?}", now);
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2015">// 2015 에디션
mod a {
    pub fn foo() {}
}
mod b {
    pub fn foo() {
        ::a::foo(); // `a`의 foo 함수를 호출합니다.
        // Rust 2018에서 `::a`는 크레이트 `a`로 해석됩니다.
    }
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>r[paths.qualifiers.mod-self]</p>
<h3 id="self"><a class="header" href="#self"><code>self</code></a></h3>
<p>r[paths.qualifiers.mod-self.intro] <code>self</code> resolves the path relative to the current module.</p>
<p>r[paths.qualifiers.mod-self.restriction] <code>self</code> can only be used as the first segment, without a preceding <code>::</code>.</p>
<p>r[paths.qualifiers.self-pat] In a method body, a path which consists of a single <code>self</code> segment resolves to the method’s self parameter.</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn foo() {}
fn bar() {
    self::foo();
}
struct S(bool);
impl S {
  fn baz(self) {
        self.0;
    }
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>r[paths.qualifiers.type-self]</p>
<h3 id="self-1"><a class="header" href="#self-1"><code>Self</code></a></h3>
<p>r[paths.qualifiers.type-self.intro] <code>Self</code>, with a capital “S”, is used to refer to the current type being implemented or defined. It may be used in the following situations:</p>
<p>r[paths.qualifiers.type-self.trait]</p>
<ul>
<li><a href="items/traits.html">트레잇(trait)</a> 정의에서, 이는 해당 트레잇을 구현하는 타입을 참조합니다.</li>
</ul>
<p>r[paths.qualifiers.type-self.impl]</p>
<ul>
<li><a href="items/implementations.html">구현(implementation)</a>에서, 이는 구현되고 있는 타입을 참조합니다. 튜플 또는 유닛 <a href="items/structs.html">구조체(struct)</a>를 구현할 때는 <a href="names/namespaces.html">값 네임스페이스</a>의 생성자도 참조합니다.</li>
</ul>
<p>r[paths.qualifiers.type-self.type]</p>
<ul>
<li><a href="items/structs.html">구조체</a>, <a href="items/enumerations.html">열거형(enumeration)</a> 또는 <a href="items/unions.html">공용체(union)</a>의 정의에서, 이는 정의되고 있는 타입을 참조합니다. 정의가 무한히 재귀적일 수는 없습니다(반드시 간접 참조(indirection)가 있어야 합니다).</li>
</ul>
<p>r[paths.qualifiers.type-self.scope] The scope of <code>Self</code> behaves similarly to a generic parameter; see the <a href="names/scopes.html#self-scope"><code>Self</code> scope</a> section for more details.</p>
<p>r[paths.qualifiers.type-self.allowed-positions] <code>Self</code> can only be used as the first segment, without a preceding <code>::</code>.</p>
<p>r[paths.qualifiers.type-self.no-generics] The <code>Self</code> path cannot include generic arguments (as in <code>Self::&lt;i32&gt;</code>).</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait T {
    type Item;
    const C: i32;
    // `Self`는 `T`를 구현하는 어떤 타입이든 될 수 있습니다.
    fn new() -&gt; Self;
    // `Self::Item`은 구현체에서의 타입 별칭(type alias)이 됩니다.
    fn f(&amp;self) -&gt; Self::Item;
}
struct S;
impl T for S {
    type Item = i32;
    const C: i32 = 9;
    fn new() -&gt; Self {           // `Self`는 `S` 타입입니다.
        S
    }
    fn f(&amp;self) -&gt; Self::Item {  // `Self::Item`은 `i32` 타입입니다.
        Self::C                  // `Self::C`는 상수 값 `9`입니다.
    }
}

// `Self`는 트레잇 정의의 제네릭 내에서 스코프에 있으며,
// 정의되고 있는 타입을 참조합니다.
trait Add&lt;Rhs = Self&gt; {
    type Output;
    // `Self`는 또한 구현되고 있는 타입의
    // 연관 아이템을 참조할 수 있습니다.
    fn add(self, rhs: Rhs) -&gt; Self::Output;
}

struct NonEmptyList&lt;T&gt; {
    head: T,
    // 구조체는 자기 자신을 참조할 수 있습니다(무한히
    // 재귀적이지 않은 한).
    tail: Option&lt;Box&lt;Self&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>r[paths.qualifiers.super]</p>
<h3 id="super"><a class="header" href="#super"><code>super</code></a></h3>
<p>r[paths.qualifiers.super.intro] <code>super</code> in a path resolves to the parent module.</p>
<p>r[paths.qualifiers.super.allowed-positions] It may only be used in leading segments of the path, possibly after an initial <code>self</code> segment.</p>
<pre><pre class="playground"><code class="language-rust edition2024">mod a {
    pub fn foo() {}
}
mod b {
    pub fn foo() {
        super::a::foo(); // a의 foo 함수를 호출합니다.
    }
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>r[paths.qualifiers.super.repetition] <code>super</code> may be repeated several times after the first <code>super</code> or <code>self</code> to refer to ancestor modules.</p>
<pre><pre class="playground"><code class="language-rust edition2024">mod a {
    fn foo() {}

    mod b {
        mod c {
            fn foo() {
                super::super::foo(); // a의 foo 함수를 호출합니다.
                self::super::super::foo(); // a의 foo 함수를 호출합니다.
            }
        }
    }
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>r[paths.qualifiers.crate]</p>
<h3 id="crate"><a class="header" href="#crate"><code>crate</code></a></h3>
<p>r[paths.qualifiers.crate.intro] <code>crate</code> resolves the path relative to the current crate.</p>
<p>r[paths.qualifiers.crate.allowed-positions] <code>crate</code> can only be used as the first segment, without a preceding <code>::</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn foo() {}
mod a {
    fn bar() {
        crate::foo();
    }
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>r[paths.qualifiers.macro-crate]</p>
<h3 id="crate-1"><a class="header" href="#crate-1"><code>$crate</code></a></h3>
<p>r[paths.qualifiers.macro-crate.allowed-positions] <a href="macro.decl.hygiene.crate"><code>$crate</code></a> is only used within <a href="macros-by-example.html">macro transcribers</a>, and can only be used as the first segment, without a preceding <code>::</code>.</p>
<p>r[paths.qualifiers.macro-crate.hygiene] <a href="macro.decl.hygiene.crate"><code>$crate</code></a> will expand to a path to access items from the top level of the crate where the macro is defined, regardless of which crate the macro is invoked.</p>
<pre><pre class="playground"><code class="language-rust edition2024">pub fn increment(x: u32) -&gt; u32 {
    x + 1
}

#[macro_export]
macro_rules! inc {
    ($x:expr) =&gt; ( $crate::increment($x) )
}
<span class="boring">fn main() { }</span></code></pre></pre>
<p>r[paths.canonical]</p>
<h2 id="표준-경로canonical-paths"><a class="header" href="#표준-경로canonical-paths">표준 경로(Canonical paths)</a></h2>
<p>r[paths.canonical.intro] Items defined in a module or implementation have a <em>canonical path</em> that corresponds to where within its crate it is defined.</p>
<p>r[paths.canonical.alias] All other paths to these items are aliases.</p>
<p>r[paths.canonical.def] The canonical path is defined as a <em>path prefix</em> appended by the path segment the item itself defines.</p>
<p>r[paths.canonical.non-canonical] <a href="items/implementations.html">Implementations</a> and <a href="items/use-declarations.html">use declarations</a> do not have canonical paths, although the items that implementations define do have them. Items defined in block expressions do not have canonical paths. Items defined in a module that does not have a canonical path do not have a canonical path. Associated items defined in an implementation that refers to an item without a canonical path, e.g. as the implementing type, the trait being implemented, a type parameter or bound on a type parameter, do not have canonical paths.</p>
<p>r[paths.canonical.module-prefix] The path prefix for modules is the canonical path to that module.</p>
<p>r[paths.canonical.bare-impl-prefix] For bare implementations, it is the canonical path of the item being implemented surrounded by <span class="parenthetical">angle (<code>&lt;&gt;</code>)</span> brackets.</p>
<p>r[paths.canonical.trait-impl-prefix] For <a href="items/implementations.html#trait-implementations">trait implementations</a>, it is the canonical path of the item being implemented followed by <code>as</code> followed by the canonical path to the trait all surrounded in <span class="parenthetical">angle (<code>&lt;&gt;</code>)</span> brackets.</p>
<p>r[paths.canonical.local-canonical-path] The canonical path is only meaningful within a given crate. There is no global namespace across crates; an item’s canonical path merely identifies it within the crate.</p>
<pre><pre class="playground"><code class="language-rust edition2024">// 주석은 아이템의 표준 경로를 나타냅니다.

mod a { // crate::a
    pub struct Struct; // crate::a::Struct

    pub trait Trait { // crate::a::Trait
        fn f(&amp;self); // crate::a::Trait::f
    }

    impl Trait for Struct {
        fn f(&amp;self) {} // &lt;crate::a::Struct as crate::a::Trait&gt;::f
    }

    impl Struct {
        fn g(&amp;self) {} // &lt;crate::a::Struct&gt;::g
    }
}

mod without { // crate::without
    fn canonicals() { // crate::without::canonicals
        struct OtherStruct; // 없음(None)

        trait OtherTrait { // 없음(None)
            fn g(&amp;self); // 없음(None)
        }

        impl OtherTrait for OtherStruct {
            fn g(&amp;self) {} // 없음(None)
        }

        impl OtherTrait for crate::a::Struct {
            fn g(&amp;self) {} // 없음(None)
        }

        impl crate::a::Trait for OtherStruct {
            fn f(&amp;self) {} // 없음(None)
        }
    }
}

<span class="boring">fn main() {}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p>r[names.resolution]</p>
<h1 id="이름-확인"><a class="header" href="#이름-확인">이름 확인</a></h1>
<p>r[names.resolution.intro] <em>Name resolution</em> is the process of tying paths and other identifiers to the declarations of those entities. Names are segregated into different <a href="names/../names/namespaces.html">namespaces</a>, allowing entities in different namespaces to share the same name without conflict. Each name is valid within a <a href="names/../names/scopes.html">scope</a>, or a region of source text where that name may be referenced. Access to a name may be restricted based on its <a href="names/../visibility-and-privacy.html">visibility</a>.</p>
<p>Name resolution is split into three stages throughout the compilation process. The first stage, <em>expansion-time resolution</em>, resolves all <a href="names/../items/use-declarations.html"><code>use</code> declarations</a> and <a href="names/../macros.html#macro-invocation">macro invocations</a>. The second stage, <em>primary resolution</em>, resolves all names that have not yet been resolved and that do not depend on type information to resolve. The last stage, <em>type-relative resolution</em>, resolves the remaining names once type information is available.</p>
<blockquote>
<p>[!NOTE] Expansion-time resolution is also known as <em>early resolution</em>. Primary resolution is also known as <em>late resolution</em>.</p>
</blockquote>
<p>r[names.resolution.general]</p>
<h2 id="general"><a class="header" href="#general">General</a></h2>
<p>r[names.resolution.general.intro] The rules within this section apply to all stages of name resolution.</p>
<p>r[names.resolution.general.scopes]</p>
<h3 id="스코프-1"><a class="header" href="#스코프-1">스코프</a></h3>
<p>r[names.resolution.general.scopes.intro]</p>
<blockquote>
<p>[!NOTE] This is a placeholder for future expansion about resolution of names within various scopes.</p>
</blockquote>
<p>r[names.resolution.expansion]</p>
<h2 id="expansion-time-name-resolution"><a class="header" href="#expansion-time-name-resolution">Expansion-time name resolution</a></h2>
<p>r[names.resolution.expansion.intro] Expansion-time name resolution is the stage of name resolution necessary to complete macro expansion and fully generate a crate’s <a href="names/glossary.ast">AST</a>. This stage requires the resolution of macro invocations and <code>use</code> declarations. Resolving <code>use</code> declarations is required for macro invocations that resolve via <a href="names/../macros.html#r-macro.invocation.name-resolution">path-based scope</a>. Resolving macro invocations is required in order to expand them.</p>
<p>r[names.resolution.expansion.unresolved-invocations] After expansion-time name resolution, the AST must not contain any unexpanded macro invocations. Every macro invocation resolves to a valid definition that exists in the final AST or in an external crate.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>m!(); // ERROR: Cannot find macro `m` in this scope.
<span class="boring">}</span></code></pre></pre>
<p>r[names.resolution.expansion.expansion-order-stability] The resolution of names must be stable. After expansion, names in the fully expanded AST must resolve to the same definition regardless of the order in which macros are expanded and imports are resolved.</p>
<p>r[names.resolution.expansion.speculation] All name resolution candidates selected during macro expansion are considered speculative. Once the crate has been fully expanded, all speculative import resolutions are validated to ensure that macro expansion did not introduce any new ambiguities.</p>
<blockquote>
<p>[!NOTE] Due to the iterative nature of macro expansion, this causes so-called time traveling ambiguities, such as when a macro or glob import introduces an item that is ambiguous with its own base path.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0659 edition2024"><span class="boring">fn main() {}
</span>macro_rules! f {
    () =&gt; {
        mod m {
            pub(crate) use f;
        }
    }
}
f!();

const _: () = {
    // Initially, we speculatively resolve `m` to the module in
    // the crate root.
    //
    // Expansion of `f` introduces a second `m` module inside this
    // body.
    //
    // Expansion-time resolution finalizes resolutions by re-
    // resolving all imports and macro invocations, sees the
    // introduced ambiguity and reports it as an error.
    m::f!(); // ERROR: `m` is ambiguous.
};</code></pre></pre>
</blockquote>
<p>r[names.resolution.expansion.imports]</p>
<h3 id="imports"><a class="header" href="#imports">Imports</a></h3>
<p>r[names.resolution.expansion.imports.intro] All <code>use</code> declarations are fully resolved during this stage of resolution. <a href="names/names.resolution.type-relative">Type-relative paths</a> cannot be resolved at this stage and will produce an error.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod m {
    pub const C: () = ();
    pub enum E { V }
    pub type A = E;
    impl E {
        pub const C: () = ();
    }
}

// Valid imports resolved at expansion-time:
use m::C; // OK.
use m::E; // OK.
use m::A; // OK.
use m::E::V; // OK.

// Valid expressions resolved during type-relative resolution:
let _ = m::A::V; // OK.
let _ = m::E::C; // OK.
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail E0432 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">mod m {
</span><span class="boring">    pub const C: () = ();
</span><span class="boring">    pub enum E { V }
</span><span class="boring">    pub type A = E;
</span><span class="boring">    impl E {
</span><span class="boring">        pub const C: () = ();
</span><span class="boring">    }
</span><span class="boring">}
</span>// Invalid type-relative imports that can't resolve at expansion-time:
use m::A::V; // ERROR: Unresolved import `m::A::V`.
use m::E::C; // ERROR: Unresolved import `m::E::C`.
<span class="boring">}</span></code></pre></pre>
<p>r[names.resolution.expansion.imports.shadowing] Names introduced via <code>use</code> declarations in an <a href="names/name-resolution.html#r-names.resolution.general.scopes">outer scope</a> are shadowed by candidates in the same namespace with the same name from an inner scope except where otherwise restricted by <a href="names/name-resolution.html#r-names.resolution.expansion.imports.ambiguity">name resolution ambiguities</a>.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod m1 {
    pub mod ambig {
        pub const C: u8 = 1;
    }
}

pub mod m2 {
    pub mod ambig {
        pub const C: u8 = 2;
    }
}

// This introduces the name `ambig` in the outer scope.
use m1::ambig;
const _: () = {
    // This shadows `ambig` in the inner scope.
    use m2::ambig;
    // The inner candidate is selected here
    // as the resolution of `ambig`.
    use ambig::C;
    assert!(C == 2);
};
<span class="boring">}</span></code></pre></pre>
<p>r[names.resolution.expansion.imports.shadowing.shared-scope] Shadowing of names introduced via <code>use</code> declarations within a single scope is permitted in the following situations:</p>
<ul>
<li><a href="names/../items/use-declarations.html#r-items.use.glob.shadowing"><code>use</code> glob shadowing</a></li>
<li><a href="names/../macros-by-example.html#r-macro.decl.scope.textual.shadow">Macro textual scope shadowing</a></li>
</ul>
<p>r[names.resolution.expansion.imports.ambiguity]</p>
<h4 id="모호성"><a class="header" href="#모호성">모호성</a></h4>
<p>r[names.resolution.expansion.imports.ambiguity.intro] There are certain situations during expansion-time resolution where there are multiple macro definitions, <code>use</code> declarations, or modules an import or macro invocation’s name could refer to where the compiler cannot consistently determine which candidate should shadow the other. Shadowing cannot be permitted in these situations and the compiler instead emits ambiguity errors.</p>
<p>r[names.resolution.expansion.imports.ambiguity.glob-vs-glob] Names may not be resolved through ambiguous glob imports. Glob imports are allowed to import conflicting names in the same namespace as long as the name is not used. Names with conflicting candidates from ambiguous glob imports may still be shadowed by non-glob imports and used without producing an error. The errors occur at time of use, not time of import.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0659 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod m1 {
    pub struct Ambig;
}

mod m2 {
    pub struct Ambig;
}

// OK: This brings conficting names in the same namespace into scope
// but they have not been used yet.
use m1::*;
use m2::*;

const _: () = {
    // The error happens when the name with the conflicting candidates
    // is used.
    let x = Ambig; // ERROR: `Ambig` is ambiguous.
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">mod m1 {
</span><span class="boring">    pub struct Ambig;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod m2 {
</span><span class="boring">    pub struct Ambig;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use m1::*;
</span><span class="boring">use m2::*; // OK: No name conflict.
</span>const _: () = {
    // This is permitted, since resolution is not through the
    // ambiguous globs.
    struct Ambig;
    let x = Ambig; // OK.
};
<span class="boring">}</span></code></pre></pre>
<p>Multiple glob imports are allowed to import the same name, and that name is allowed to be used if the imports are of the same item (following reexports). The visibility of the name is the maximum visibility of the imports.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024">mod m1 {
    pub struct Ambig;
}

mod m2 {
    // This reexports the same `Ambig` item from a second module.
    pub use super::m1::Ambig;
}

mod m3 {
    // These both import the same `Ambig`.
    //
    // The visibility of `Ambig` is `pub` because that is the
    // maximum visibility between these two `use` declarations.
    pub use super::m1::*;
    use super::m2::*;
}

mod m4 {
    // `Ambig` can be used through the `m3` globs and still has
    // `pub` visibility.
    pub use crate::m3::Ambig;
}

const _: () = {
    // Therefore, we can use it here.
    let _ = m4::Ambig; // OK.
};
<span class="boring">fn main() {}</span></code></pre></pre>
<p>r[names.resolution.expansion.imports.ambiguity.glob-vs-outer] Names in imports and macro invocations may not be resolved through glob imports when there is another candidate available in an <a href="names/name-resolution.html#r-names.resolution.general.scopes">outer scope</a>.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0659 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod glob {
    pub mod ambig {
        pub struct Name;
    }
}

// Outer `ambig` candidate.
pub mod ambig {
    pub struct Name;
}

const _: () = {
    // Cannot resolve `ambig` through this glob
    // because of the outer `ambig` candidate above.
    use glob::*;
    use ambig::Name; // ERROR: `ambig` is ambiguous.
};
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail E0659 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// As above, but with macros.
pub mod m {
    macro_rules! f {
        () =&gt; {};
    }
    pub(crate) use f;
}
pub mod glob {
    macro_rules! f {
        () =&gt; {};
    }
    pub(crate) use f as ambig;
}

use m::f as ambig;

const _: () = {
    use glob::*;
    ambig!(); // ERROR: `ambig` is ambiguous.
};
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] These ambiguity errors are specific to expansion-time resolution. Having multiple candidates available for a given name during later stages of resolution is not considered an error. So long as none of the imports themselves are ambiguous, there will always be a single unambiguous closest resolution.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod glob {
    pub const AMBIG: u8 = 1;
}

mod outer {
    pub const AMBIG: u8 = 2;
}

use outer::AMBIG;

const C: () = {
    use glob::*;
    assert!(AMBIG == 1);
    //      ^---- This `AMBIG` is resolved during primary resolution.
};
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[names.resolution.expansion.imports.ambiguity.path-vs-textual-macro] Names may not be resolved through ambiguous macro reexports. Macro reexports are ambiguous when they would shadow a textual macro candidate for the same name in an <a href="names/name-resolution.html#r-names.resolution.general.scopes">outer scope</a>.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0659 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Textual macro candidate.
macro_rules! ambig {
    () =&gt; {}
}

// Path-based macro candidate.
macro_rules! path_based {
    () =&gt; {}
}

pub fn f() {
    // This reexport of the `path_based` macro definition
    // as `ambig` may not shadow the `ambig` macro definition
    // which is resolved via textual macro scope.
    use path_based as ambig;
    ambig!(); // ERROR: `ambig` is ambiguous.
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] This restriction is needed due to implementation details in the compiler, specifically the current scope visitation logic and the complexity of supporting this behavior. This ambiguity error may be removed in the future.</p>
</blockquote>
<p>r[names.resolution.expansion.macros]</p>
<h3 id="매크로-1"><a class="header" href="#매크로-1">매크로</a></h3>
<p>r[names.resolution.expansion.macros.intro] Macros are resolved by iterating through the available scopes to find the available candidates. Macros are split into two sub-namespaces, one for function-like macros, and the other for attributes and derives. Resolution candidates from the incorrect sub-namespace are ignored.</p>
<p>r[names.resolution.expansion.macros.visitation-order] The available scope kinds are visited in the following order. Each of these scope kinds represent one or more scopes.</p>
<ul>
<li><a href="names/../procedural-macros.html#r-macro.proc.derive.attributes">Derive helpers</a></li>
<li><a href="names/../macros-by-example.html#r-macro.decl.scope.textual">Textual scope macros</a></li>
<li><a href="names/../macros.html#r-macro.invocation.name-resolution">Path-based scope macros</a></li>
<li><a href="names/./preludes.html#r-names.preludes.macro_use"><code>macro_use</code> prelude</a></li>
<li><a href="names/./preludes.html#r-names.preludes.std">Standard library prelude</a></li>
<li><a href="names/./preludes.html#r-names.preludes.lang">Builtin attributes</a></li>
</ul>
<blockquote>
<p>[!NOTE] The compiler will attempt to resolve derive helpers that are used before their associated macro introduces them into scope. This scope is visited after the scope for resolving derive helper candidates that are correctly in scope. This behavior is slated for removal.</p>
<p>For more info see <a href="names/../procedural-macros.html#r-macro.proc.derive.attributes.scope">derive helper scope</a>.</p>
</blockquote>
<blockquote>
<p>[!NOTE] This visitation order may change in the future, such as interleaving the visitation of textual and path-based scope candidates based on their lexical scopes.</p>
</blockquote>
<blockquote>
<p>[!EDITION-2018] Starting in edition 2018 the <code>#[macro_use]</code> prelude is not visited when [<code>#[no_implicit_prelude]</code>][names.preludes.no_implicit_prelude] is present.</p>
</blockquote>
<p>r[names.resolution.expansion.macros.reserved-names] The names <code>cfg</code> and <code>cfg_attr</code> are reserved in the macro attribute <a href="names/../names/namespaces.html#r-names.namespaces.sub-namespaces">sub-namespace</a>.</p>
<p>r[names.resolution.expansion.macros.ambiguity]</p>
<h4 id="모호성-1"><a class="header" href="#모호성-1">모호성</a></h4>
<p>r[names.resolution.expansion.macros.ambiguity.more-expanded-vs-outer] Names may not be resolved through ambiguous candidates inside of macro expansions. Candidates inside of macro expansions are ambiguous when they would shadow a candidate for the same name from outside of the first candidate’s macro expansion and the invocation of the name being resolved is also from outside of the first candidate’s macro expansion.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0659 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! define_ambig {
    () =&gt; {
        macro_rules! ambig {
            () =&gt; {}
        }
    }
}

// Introduce outer candidate definition for `ambig` macro invocation.
macro_rules! ambig {
    () =&gt; {}
}

// Introduce a second candidate definition for `ambig` inside of a
// macro expansion.
define_ambig!();

// The definition of `ambig` from the second invocation
// of `define_ambig` is the innermost canadidate.
//
// The definition of `ambig` from the first invocation of
// `define_ambig` is the second candidate.
//
// The compiler checks that the first candidate is inside of a macro
// expansion, that the second candidate is not from within the same
// macro expansion, and that the name being resolved is not from
// within the same macro expansion.
ambig!(); // ERROR: `ambig` is ambiguous.
<span class="boring">}</span></code></pre></pre>
<p>The reverse is not considered ambiguous.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">macro_rules! define_ambig {
</span><span class="boring">    () =&gt; {
</span><span class="boring">        macro_rules! ambig {
</span><span class="boring">            () =&gt; {}
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span>// Swap order of definitions.
define_ambig!();
macro_rules! ambig {
    () =&gt; {}
}
// The innermost candidate is now less expanded so it may shadow more
// the macro expanded definition above it.
ambig!();
<span class="boring">}</span></code></pre></pre>
<p>Nor is it ambiguous if the invocation being resolved is within the innermost candidate’s expansion.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! ambig {
    () =&gt; {}
}

macro_rules! define_and_invoke_ambig {
    () =&gt; {
        // Define innermost candidate.
        macro_rules! ambig {
            () =&gt; {}
        }

        // Invocation of `ambig` is in the same expansion as the
        // innermost candidate.
        ambig!(); // OK
    }
}

define_and_invoke_ambig!();
<span class="boring">}</span></code></pre></pre>
<p>It doesn’t matter if both definitions come from invocations of the same macro; the outermost candidate is still considered “less expanded” because it is not within the expansion containing the innermost candidate’s definition.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0659 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">macro_rules! define_ambig {
</span><span class="boring">    () =&gt; {
</span><span class="boring">        macro_rules! ambig {
</span><span class="boring">            () =&gt; {}
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span>define_ambig!();
define_ambig!();
ambig!(); // ERROR: `ambig` is ambiguous.
<span class="boring">}</span></code></pre></pre>
<p>This also applies to imports so long as the innermost candidate for the name is from within a macro expansion.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0659 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! define_ambig {
    () =&gt; {
        mod ambig {
            pub struct Name;
        }
    }
}

mod ambig {
    pub struct Name;
}

const _: () = {
    // Introduce innermost candidate for
    // `ambig` mod in this macro expansion.
    define_ambig!();
    use ambig::Name; // ERROR: `ambig` is ambiguous.
};
<span class="boring">}</span></code></pre></pre>
<p>r[names.resolution.expansion.macros.ambiguity.built-in-attr] User-defined attributes or derive macros may not shadow built-in non-macro attributes (e.g. inline).</p>
<!-- ignore: test doesn't support proc-macro -->
<pre><code class="language-rust ignore">// with-helper/src/lib.rs
<span class="boring">use proc_macro::TokenStream;
</span>#[proc_macro_derive(WithHelperAttr, attributes(non_exhaustive))]
//                                             ^^^^^^^^^^^^^^
//                                   User-defined attribute candidate.
// ...
<span class="boring">pub fn derive_with_helper_attr(_item: TokenStream) -&gt; TokenStream {
</span><span class="boring">    TokenStream::new()
</span><span class="boring">}</span></code></pre>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">// src/lib.rs
#[derive(with_helper::WithHelperAttr)]
#[non_exhaustive] // ERROR: `non_exhaustive` is ambiguous.
struct S;</code></pre>
<blockquote>
<p>[!NOTE] This applies regardless of the name the built-in attribute is a candidate for:</p>
<!-- ignore: test doesn't support proc-macro -->
<pre><code class="language-rust ignore">// with-helper/src/lib.rs
<span class="boring">use proc_macro::TokenStream;
</span><span class="boring">
</span>#[proc_macro_derive(WithHelperAttr, attributes(helper))]
//                                             ^^^^^^
//                                 User-defined attribute candidate.
// ...
<span class="boring">pub fn derive_with_helper_attr(_item: TokenStream) -&gt; TokenStream {
</span><span class="boring">    TokenStream::new()
</span><span class="boring">}</span></code></pre>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">// src/lib.rs
use inline as helper;
//            ^----- Built-in attribute candidate via reexport.

#[derive(with_helper::WithHelperAttr)]
#[helper] // ERROR: `helper` is ambiguous.
struct S;</code></pre>
</blockquote>
<p>r[names.resolution.primary]</p>
<h2 id="primary-name-resolution"><a class="header" href="#primary-name-resolution">Primary name resolution</a></h2>
<blockquote>
<p>[!NOTE] This is a placeholder for future expansion about primary name resolution.</p>
</blockquote>
<p>r[names.resolution.type-relative]</p>
<h2 id="type-relative-resolution"><a class="header" href="#type-relative-resolution">Type-relative resolution</a></h2>
<blockquote>
<p>[!NOTE] This is a placeholder for future expansion about type-dependent resolution.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>r[vis]</p>
<h1 id="가시성과-프라이버시"><a class="header" href="#가시성과-프라이버시">가시성과 프라이버시</a></h1>
<p>r[vis.syntax]</p>
<pre><code class="language-grammar items">Visibility -&gt;
      `pub`
    | `pub` `(` `crate` `)`
    | `pub` `(` `self` `)`
    | `pub` `(` `super` `)`
    | `pub` `(` `in` SimplePath `)`
</code></pre>
<p>r[vis.intro] These two terms are often used interchangeably, and what they are attempting to convey is the answer to the question “Can this item be used at this location?”</p>
<p>r[vis.name-hierarchy] Rust’s name resolution operates on a global hierarchy of namespaces. Each level in the hierarchy can be thought of as some item. The items are one of those mentioned above, but also include external crates. Declaring or defining a new module can be thought of as inserting a new tree into the hierarchy at the location of the definition.</p>
<p>r[vis.privacy] To control whether interfaces can be used across modules, Rust checks each use of an item to see whether it should be allowed or not. This is where privacy warnings are generated, or otherwise “you used a private item of another module and weren’t allowed to.”</p>
<p>r[vis.default] By default, everything is <em>private</em>, with two exceptions: Associated items in a <code>pub</code> Trait are public by default; Enum variants in a <code>pub</code> enum are also public by default. When an item is declared as <code>pub</code>, it can be thought of as being accessible to the outside world. For example:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {}
</span>// 비공개(private) 구조체를 선언합니다.
struct Foo;

// 비공개 필드를 가진 공개(public) 구조체를 선언합니다.
pub struct Bar {
    field: i32,
}

// 두 개의 공개 변형(variants)을 가진 공개 열거형을 선언합니다.
pub enum State {
    PubliclyAccessibleState,
    PubliclyAccessibleState2,
}</code></pre></pre>
<p>r[vis.access] With the notion of an item being either public or private, Rust allows item accesses in two cases:</p>
<ol>
<li>아이템이 공개라면, 모듈 <code>m</code>에서 아이템의 모든 조상 모듈에 접근할 수 있는 경우 <code>m</code> 외부에서 해당 아이템에 접근할 수 있습니다. 또한 재내보내기(re-exports)를 통해 해당 아이템의 이름을 지정할 수도 있습니다. 아래를 참조하십시오.</li>
<li>아이템이 비공개라면, 현재 모듈과 그 하위 모듈들에서만 접근할 수 있습니다.</li>
</ol>
<p>이 두 가지 경우는 내부 구현 세부 사항을 숨기면서 공개 API를 노출하는 모듈 계층 구조를 만드는 데 매우 강력합니다. 설명을 돕기 위해 몇 가지 유스케이스와 그에 따른 결과를 소개합니다:</p>
<ul>
<li>
<p>라이브러리 개발자는 자신의 라이브러리에 링크하는 크레이트들에 기능을 노출해야 합니다. 첫 번째 경우의 결과로서, 이는 외부에서 사용 가능한 모든 것이 루트부터 대상 아이템까지 <code>pub</code>이어야 함을 의미합니다. 체인의 어느 한 아이템이라도 비공개라면 외부 접근이 허용되지 않습니다.</p>
</li>
<li>
<p>크레이트 내에서 전역적으로 사용 가능한 “도우미 모듈“이 필요하지만, 이를 공개 API로 노출하고 싶지 않을 수 있습니다. 이를 위해 크레이트 계층 구조의 루트에 비공개 모듈을 두고, 그 내부에 “공개 API“를 갖게 합니다. 크레이트 전체가 루트의 하위 모듈이므로, 두 번째 경우를 통해 로컬 크레이트 전체가 이 비공개 모듈에 접근할 수 있습니다.</p>
</li>
<li>
<p>모듈에 대한 유닛 테스트를 작성할 때, 테스트 대상 모듈의 직계 자식 모듈로 <code>mod test</code>를 두는 것이 일반적인 관례입니다. 이 모듈은 두 번째 경우를 통해 부모 모듈의 모든 아이템에 접근할 수 있으며, 이는 내부 구현 세부 사항도 자식 모듈에서 원활하게 테스트될 수 있음을 의미합니다.</p>
</li>
</ul>
<p>두 번째 경우에서 비공개 아이템이 현재 모듈과 그 하위 모듈들에 의해 “접근될 수 있다“고 언급했는데, 아이템에 접근한다는 것의 정확한 의미는 아이템이 무엇인지에 따라 다릅니다.</p>
<p>r[vis.usage] Accessing a module, for example, would mean looking inside of it (to import more items). On the other hand, accessing a function would mean that it is invoked. Additionally, path expressions and import statements are considered to access an item in the sense that the import/expression is only valid if the destination is in the current visibility scope.</p>
<p>위에서 설명한 세 가지 경우를 보여주는 프로그램의 예입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024">// 이 모듈은 비공개이므로 외부 크레이트가 접근할 수 없습니다.
// 하지만 이 현재 크레이트의 루트에서는 비공개이므로,
// 크레이트 내의 모든 모듈은 이 모듈 내의 공개적으로 표시되는 아이템에 접근할 수 있습니다.
mod crate_helper_module {

    // 이 함수는 현재 크레이트 내의 무엇이든 사용할 수 있습니다.
    pub fn crate_helper() {}

    // 이 함수는 크레이트 내의 다른 어떤 곳에서도 사용할 수 *없습니다*.
// `crate_helper_module` 외부에서는 공개적으로 보이지 않으므로,
// 오직 이 현재 모듈과 그 하위 모듈들만 접근할 수 있습니다.
    fn implementation_detail() {}
}

// 이 함수는 "루트에 공개"되어 있으므로 이 라이브러리에 링크하는
// 외부 크레이트가 사용할 수 있습니다.
pub fn public_api() {}

// 'public_api'와 마찬가지로 이 모듈은 공개되어 있어 외부 크레이트가
// 내부를 들여다볼 수 있습니다.
pub mod submodule {
    use crate::crate_helper_module;

    pub fn my_method() {
        // 로컬 크레이트의 모든 아이템은 위의 두 규칙의 조합을 통해
        // 도우미 모듈의 공개 인터페이스를 호출할 수 있습니다.
        crate_helper_module::crate_helper();
    }

    // 이 함수는 `submodule`의 하위 모듈이 아닌 모듈에는 숨겨집니다.
    fn my_implementation() {}

    #[cfg(test)]
    mod test {

        #[test]
        fn test_my_implementation() {
            // 이 모듈은 `submodule`의 하위 모듈이므로 프라이버시 위반 없이
            // `submodule` 내부의 비공개 아이템에 접근하는 것이 허용됩니다.
            super::my_implementation();
        }
    }
}

<span class="boring">fn main() {}</span></code></pre></pre>
<p>러스트 프로그램이 프라이버시 검사 단계를 통과하려면 모든 경로가 위에서 언급한 두 규칙에 따라 유효한 접근이어야 합니다. 여기에는 모든 use 문, 표현식, 타입 등이 포함됩니다.</p>
<p>r[vis.scoped]</p>
<h2 id="pubin-path-pubcrate-pubsuper-그리고-pubself"><a class="header" href="#pubin-path-pubcrate-pubsuper-그리고-pubself"><code>pub(in path)</code>, <code>pub(crate)</code>, <code>pub(super)</code>, 그리고 <code>pub(self)</code></a></h2>
<p>r[vis.scoped.intro] In addition to public and private, Rust allows users to declare an item as visible only within a given scope. The rules for <code>pub</code> restrictions are as follows:</p>
<p>r[vis.scoped.in]</p>
<ul>
<li><code>pub(in path)</code>는 제공된 <code>path</code> 내에서 아이템을 볼 수 있게 합니다. <code>path</code>는 가시성이 선언되는 아이템의 조상 모듈로 해석되는 단순 경로(simple path)여야 합니다. <code>path</code> 내의 각 식별자는 모듈을 직접 참조해야 합니다(<code>use</code> 문에 의해 도입된 이름이 아니어야 합니다).</li>
</ul>
<p>r[vis.scoped.crate]</p>
<ul>
<li><code>pub(crate)</code>는 현재 크레이트 내에서 아이템을 볼 수 있게 합니다.</li>
</ul>
<p>r[vis.scoped.super]</p>
<ul>
<li><code>pub(super)</code>는 부모 모듈에서 아이템을 볼 수 있게 합니다. 이는 <code>pub(in super)</code>와 동일합니다.</li>
</ul>
<p>r[vis.scoped.self]</p>
<ul>
<li><code>pub(self)</code>는 현재 모듈에서 아이템을 볼 수 있게 합니다. 이는 <code>pub(in self)</code>와 동일하거나 <code>pub</code>을 전혀 사용하지 않는 것과 같습니다.</li>
</ul>
<p>r[vis.scoped.edition2018]</p>
<blockquote>
<p>[!EDITION-2018] Starting with the 2018 edition, paths for <code>pub(in path)</code> must start with <code>crate</code>, <code>self</code>, or <code>super</code>. The 2015 edition may also use paths starting with <code>::</code> or modules from the crate root.</p>
</blockquote>
<p>예제입니다:</p>
<pre><pre class="playground"><code class="language-rust edition2015">pub mod outer_mod {
    pub mod inner_mod {
        // 이 함수는 `outer_mod` 내에서 볼 수 있습니다.
        pub(in crate::outer_mod) fn outer_mod_visible_fn() {}
        // 위와 동일하며, 2015 에디션에서만 유효합니다.
        pub(in outer_mod) fn outer_mod_visible_fn_2015() {}

        // 이 함수는 크레이트 전체에서 볼 수 있습니다.
        pub(crate) fn crate_visible_fn() {}

        // 이 함수는 `outer_mod` 내에서 볼 수 있습니다.
        pub(super) fn super_mod_visible_fn() {
            // 동일한 `mod`에 있으므로 이 함수를 볼 수 있습니다.
            inner_mod_visible_fn();
        }

        // 이 함수는 오직 `inner_mod` 내에서만 볼 수 있으며,
        // 이는 비공개로 두는 것과 같습니다.
        pub(self) fn inner_mod_visible_fn() {}
    }
    pub fn foo() {
        inner_mod::outer_mod_visible_fn();
        inner_mod::crate_visible_fn();
        inner_mod::super_mod_visible_fn();

        // `inner_mod` 외부에 있으므로 이 함수는 더 이상 보이지 않습니다.
        // 오류! `inner_mod_visible_fn`은 비공개입니다.
        //inner_mod::inner_mod_visible_fn();
    }
}

fn bar() {
    // 동일한 크레이트에 있으므로 이 함수는 여전히 보입니다.
    outer_mod::inner_mod::crate_visible_fn();

    // `outer_mod` 외부에 있으므로 이 함수는 더 이상 보이지 않습니다.
    // 오류! `super_mod_visible_fn`은 비공개입니다.
    //outer_mod::inner_mod::super_mod_visible_fn();

    // `outer_mod` 외부에 있으므로 이 함수는 더 이상 보이지 않습니다.
    // 오류! `outer_mod_visible_fn`은 비공개입니다.
    //outer_mod::inner_mod::outer_mod_visible_fn();

    outer_mod::foo();
}

fn main() { bar() }</code></pre></pre>
<blockquote>
<p>[!NOTE] This syntax only adds another restriction to the visibility of an item. It does not guarantee that the item is visible within all parts of the specified scope. To access an item, all of its parent items up to the current scope must still be visible as well.</p>
</blockquote>
<p>r[vis.reexports]</p>
<h2 id="re-exporting-and-visibility"><a class="header" href="#re-exporting-and-visibility">Re-exporting and visibility</a></h2>
<p>r[vis.reexports.intro] Rust allows publicly re-exporting items through a <code>pub use</code> directive. Because this is a public directive, this allows the item to be used in the current module through the rules above. It essentially allows public access into the re-exported item. For example, this program is valid:</p>
<pre><pre class="playground"><code class="language-rust edition2024">pub use self::implementation::api;

mod implementation {
    pub mod api {
        pub fn f() {}
    }
}

<span class="boring">fn main() {}</span></code></pre></pre>
<p>즉, <code>implementation::api::f</code>를 참조하는 외부 크레이트는 프라이버시 위반 오류를 받게 되지만, <code>api::f</code> 경로는 허용됩니다.</p>
<p>r[vis.reexports.private-item] When re-exporting a private item, it can be thought of as allowing the “privacy chain” being short-circuited through the reexport instead of passing through the namespace hierarchy as it normally would.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[memory]</p>
<h1 id="메모리-모델"><a class="header" href="#메모리-모델">메모리 모델</a></h1>
<blockquote>
<p>[!WARNING] The memory model of Rust is incomplete and not fully decided.</p>
</blockquote>
<p>r[memory.bytes]</p>
<h2 id="bytes"><a class="header" href="#bytes">Bytes</a></h2>
<p>r[memory.bytes.intro] The most basic unit of memory in Rust is a byte.</p>
<blockquote>
<p>[!NOTE] While bytes are typically lowered to hardware bytes, Rust uses an “abstract” notion of bytes that can make distinctions which are absent in hardware, such as being uninitialized, or storing part of a pointer. Those distinctions can affect whether your program has undefined behavior, so they still have tangible impact on how compiled Rust programs behave.</p>
</blockquote>
<p>r[memory.bytes.contents] Each byte may have one of the following values:</p>
<p>r[memory.bytes.init]</p>
<ul>
<li>An initialized byte containing a <code>u8</code> value and optional [provenance][std::ptr#provenance],</li>
</ul>
<p>r[memory.bytes.uninit]</p>
<ul>
<li>An uninitialized byte.</li>
</ul>
<blockquote>
<p>[!NOTE] The above list is not yet guaranteed to be exhaustive.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>r[alloc]</p>
<h1 id="메모리-할당과-라이프타임"><a class="header" href="#메모리-할당과-라이프타임">메모리 할당과 라이프타임</a></h1>
<p>r[alloc.static] The <em>items</em> of a program are those functions, modules, and types that have their value calculated at compile-time and stored uniquely in the memory image of the rust process. Items are neither dynamically allocated nor freed.</p>
<p>r[alloc.dynamic] The <em>heap</em> is a general term that describes boxes.  The lifetime of an allocation in the heap depends on the lifetime of the box values pointing to it. Since box values may themselves be passed in and out of frames, or stored in the heap, heap allocations may outlive the frame they are allocated within. An allocation in the heap is guaranteed to reside at a single location in the heap for the whole lifetime of the allocation - it will never be relocated as a result of moving a box value.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[variable]</p>
<h1 id="변수"><a class="header" href="#변수">변수</a></h1>
<p>r[variable.intro] A <em>variable</em> is a component of a stack frame, either a named function parameter, an anonymous <a href="expressions.html#temporaries">temporary</a>, or a named local variable.</p>
<p>r[variable.local] A <em>local variable</em> (or <em>stack-local</em> allocation) holds a value directly, allocated within the stack’s memory. The value is a part of the stack frame.</p>
<p>r[variable.local-mut] Local variables are immutable unless declared otherwise. For example: <code>let mut x = ...</code>.</p>
<p>r[variable.param-mut] Function parameters are immutable unless declared with <code>mut</code>. The <code>mut</code> keyword applies only to the following parameter. For example: <code>|mut x, y|</code> and <code>fn f(mut x: Box&lt;i32&gt;, y: Box&lt;i32&gt;)</code> declare one mutable variable <code>x</code> and one immutable variable <code>y</code>.</p>
<p>r[variable.init] Local variables are not initialized when allocated. Instead, the entire frame worth of local variables are allocated, on frame-entry, in an uninitialized state. Subsequent statements within a function may or may not initialize the local variables. Local variables can be used only after they have been initialized through all reachable control flow paths.</p>
<p>다음 예제에서 <code>init_after_if</code>는 <a href="expressions/if-expr.html#if-expressions"><code>if</code> 표현식</a> 이후에 초기화되지만, <code>uninit_after_if</code>는 <code>else</code> 케이스에서 초기화되지 않으므로 초기화되지 않은 상태로 남습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn random_bool() -&gt; bool { true }
</span>fn initialization_example() {
    let init_after_if: ();
    let uninit_after_if: ();

    if random_bool() {
        init_after_if = ();
        uninit_after_if = ();
    } else {
        init_after_if = ();
    }

    init_after_if; // ok
    // uninit_after_if; // err: 초기화되지 않았을 가능성이 있는 `uninit_after_if` 사용
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p>r[panic]</p>
<h1 id="panic-1"><a class="header" href="#panic-1">Panic</a></h1>
<p>r[panic.intro] Rust provides a mechanism to prevent a function from returning normally, and instead “panic,” which is a response to an error condition that is typically not expected to be recoverable within the context in which the error is encountered.</p>
<p>r[panic.lang-ops] Some language constructs, such as out-of-bounds <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">array indexing</a>, panic automatically.</p>
<p>r[panic.control] There are also language features that provide a level of control over panic behavior:</p>
<ul>
<li>A <a href="panic.html#the-panic_handler-attribute"><em>panic handler</em></a> defines the behavior of a panic.</li>
<li><a href="items/functions.html#unwinding">FFI ABIs</a> may alter how panics behave.</li>
</ul>
<blockquote>
<p>[!NOTE] The standard library provides the capability to explicitly panic via the [<code>panic!</code> macro][panic!].</p>
</blockquote>
<p>r[panic.panic_handler]</p>
<h2 id="panic_handler-속성"><a class="header" href="#panic_handler-속성"><code>panic_handler</code> 속성</a></h2>
<p>r[panic.panic_handler.intro] The <em><code>panic_handler</code> attribute</em> can be applied to a function to define the behavior of panics.</p>
<p>r[panic.panic_handler.allowed-positions] The <code>panic_handler</code> attribute can only be applied to a function with signature <code>fn(&amp;PanicInfo) -&gt; !</code>.</p>
<blockquote>
<p>[!NOTE] The <a href="core::panic::PanicInfo"><code>PanicInfo</code></a> struct contains information about the location of the panic.</p>
</blockquote>
<p>r[panic.panic_handler.unique] There must be a single <code>panic_handler</code> function in the dependency graph.</p>
<p>아래는 패닉 메시지를 기록한 다음 스레드를 중단시키는 <code>panic_handler</code> 함수의 예시입니다.</p>
<!-- ignore: test infrastructure can't handle no_std -->
<pre><code class="language-rust ignore">#![no_std]

use core::fmt::{self, Write};
use core::panic::PanicInfo;

struct Sink {
    // ..
<span class="boring">   _0: (),
</span>}
<span class="boring">
</span><span class="boring">impl Sink {
</span><span class="boring">    fn new() -&gt; Sink { Sink { _0: () }}
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl fmt::Write for Sink {
</span><span class="boring">    fn write_str(&amp;mut self, _: &amp;str) -&gt; fmt::Result { Ok(()) }
</span><span class="boring">}
</span>
#[panic_handler]
fn panic(info: &amp;PanicInfo) -&gt; ! {
    let mut sink = Sink::new();

    // "panicked at '$reason', src/main.rs:27:4"를 어떤 `sink`에 기록함
    let _ = writeln!(sink, "{}", info);

    loop {}
}</code></pre>
<p>r[panic.panic_handler.std]</p>
<h3 id="표준-동작"><a class="header" href="#표준-동작">표준 동작</a></h3>
<p>r[panic.panic_handler.std.kinds] <code>std</code> provides two different panic handlers:</p>
<ul>
<li><code>unwind</code> — unwinds the stack and is potentially recoverable.</li>
<li><code>abort</code> –– aborts the process and is non-recoverable.</li>
</ul>
<p>Not all targets may provide the <code>unwind</code> handler.</p>
<blockquote>
<p>[!NOTE] The panic handler used when linking with <code>std</code> can be set with the <a href="../rustc/codegen-options/index.html#panic"><code>-C panic</code></a> CLI flag. The default for most targets is <code>unwind</code>.</p>
<p>The standard library’s panic behavior can be modified at runtime with the [<code>std::panic::set_hook</code>] function.</p>
</blockquote>
<p>r[panic.panic_handler.std.no_std] Linking a <a href="names/preludes.html#the-no_std-attribute"><code>no_std</code></a> binary, dylib, cdylib, or staticlib will require specifying your own panic handler.</p>
<p>r[panic.strategy]</p>
<h2 id="panic-strategy"><a class="header" href="#panic-strategy">Panic strategy</a></h2>
<p>r[panic.strategy.intro] The <em>panic strategy</em> defines the kind of panic behavior that a crate is built to support.</p>
<blockquote>
<p>[!NOTE] The panic strategy can be chosen in <code>rustc</code> with the <a href="../rustc/codegen-options/index.html#panic"><code>-C panic</code></a> CLI flag.</p>
<p>When generating a binary, dylib, cdylib, or staticlib and linking with <code>std</code>, the <code>-C panic</code> CLI flag also influences which <a href="panic.html#the-panic_handler-attribute">panic handler</a> is used.</p>
</blockquote>
<blockquote>
<p>[!NOTE] When compiling code with the <code>abort</code> panic strategy, the optimizer may assume that unwinding across Rust frames is impossible, which can result in both code-size and runtime speed improvements.</p>
</blockquote>
<blockquote>
<p>[!NOTE] See [link.unwinding] for restrictions on linking crates with different panic strategies. An implication is that crates built with the <code>unwind</code> strategy can use the <code>abort</code> panic handler, but the <code>abort</code> strategy cannot use the <code>unwind</code> panic handler.</p>
</blockquote>
<p>r[panic.unwind]</p>
<h2 id="unwinding-1"><a class="header" href="#unwinding-1">Unwinding</a></h2>
<p>r[panic.unwind.intro] Panicking may either be recoverable or non-recoverable, though it can be configured (by choosing a non-unwinding panic handler) to always be non-recoverable. (The converse is not true: the <code>unwind</code> handler does not guarantee that all panics are recoverable, only that panicking via the <code>panic!</code> macro and similar standard library mechanisms is recoverable.)</p>
<p>r[panic.unwind.destruction] When a panic occurs, the <code>unwind</code> handler “unwinds” Rust frames, just as C++’s <code>throw</code> unwinds C++ frames, until the panic reaches the point of recovery (for instance at a thread boundary). This means that as the panic traverses Rust frames, live objects in those frames that <a href="destructors.html">implement <code>Drop</code></a> will have their <code>drop</code> methods called. Thus, when normal execution resumes, no-longer-accessible objects will have been “cleaned up” just as if they had gone out of scope normally.</p>
<blockquote>
<p>[!NOTE] As long as this guarantee of resource-cleanup is preserved, “unwinding” may be implemented without actually using the mechanism used by C++ for the target platform.</p>
</blockquote>
<blockquote>
<p>[!NOTE] The standard library provides two mechanisms for recovering from a panic, [<code>std::panic::catch_unwind</code>] (which enables recovery within the panicking thread) and [<code>std::thread::spawn</code>] (which automatically sets up panic recovery for the spawned thread so that other threads may continue running).</p>
</blockquote>
<p>r[panic.unwind.ffi]</p>
<h3 id="unwinding-across-ffi-boundaries"><a class="header" href="#unwinding-across-ffi-boundaries">Unwinding across FFI boundaries</a></h3>
<p>r[panic.unwind.ffi.intro] It is possible to unwind across FFI boundaries using an <a href="items/functions.html#unwinding">appropriate ABI declaration</a>. While useful in certain cases, this creates unique opportunities for undefined behavior, especially when multiple language runtimes are involved.</p>
<p>r[panic.unwind.ffi.undefined] Unwinding with the wrong ABI is undefined behavior:</p>
<ul>
<li>Causing an unwind into Rust code from a foreign function that was called via a function declaration or pointer declared with a non-unwinding ABI, such as <code>"C"</code>, <code>"system"</code>, etc. (For example, this case occurs when such a function written in C++ throws an exception that is uncaught and propagates to Rust.)</li>
<li>Calling a Rust <code>extern</code> function that unwinds (with <code>extern "C-unwind"</code> or another ABI that permits unwinding) from code that does not support unwinding, such as code compiled with GCC or Clang using <code>-fno-exceptions</code></li>
</ul>
<p>r[panic.unwind.ffi.catch-foreign] Catching a foreign unwinding operation (such as a C++ exception) using [<code>std::panic::catch_unwind</code>], [<code>std::thread::JoinHandle::join</code>], or by letting it propagate beyond the Rust <code>main()</code> function or thread root will have one of two behaviors, and it is unspecified which will occur:</p>
<ul>
<li>The process aborts.</li>
<li>The function returns a [<code>Result::Err</code>] containing an opaque type.</li>
</ul>
<blockquote>
<p>[!NOTE] Rust code compiled or linked with a different instance of the Rust standard library counts as a “foreign exception” for the purpose of this guarantee. Thus, a library that uses <code>panic!</code> and is linked against one version of the Rust standard library, invoked from an application that uses a different version of the standard library, may cause the entire application to abort even if the library is only used within a child thread.</p>
</blockquote>
<p>r[panic.unwind.ffi.dispose-panic] There are currently no guarantees about the behavior that occurs when a foreign runtime attempts to dispose of, or rethrow, a Rust <code>panic</code> payload. In other words, an unwind originated from a Rust runtime must either lead to termination of the process or be caught by the same runtime.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[link]</p>
<h1 id="연결"><a class="header" href="#연결">연결</a></h1>
<blockquote>
<p>[!NOTE] This section is described more in terms of the compiler than of the language.</p>
</blockquote>
<p>r[link.intro] The compiler supports various methods to link crates together both statically and dynamically. This section will explore the various methods to link crates together, and more information about native libraries can be found in the <a href="../book/ch19-01-unsafe-rust.html#using-extern-functions-to-call-external-code">FFI section of the book</a>.</p>
<p>r[link.type] In one session of compilation, the compiler can generate multiple artifacts through the usage of either command line flags or the <code>crate_type</code> attribute. If one or more command line flags are specified, all <code>crate_type</code> attributes will be ignored in favor of only building the artifacts specified by command line.</p>
<p>r[link.bin]</p>
<ul>
<li><code>--crate-type=bin</code>, <code>#![crate_type = "bin"]</code> - 실행 가능한 프로그램이 생성됩니다. 이 경우 프로그램이 실행될 때 호출될 <code>main</code> 함수가 크레이트 내에 반드시 있어야 합니다. 모든 러스트 및 네이티브 의존성을 링크하여 배포 가능한 단일 바이너리를 생성합니다. 이것이 기본 크레이트 타입입니다.</li>
</ul>
<p>r[link.lib]</p>
<ul>
<li><code>--crate-type=lib</code>, <code>#![crate_type = "lib"]</code> - 러스트 라이브러리가 생성됩니다. 라이브러리는 여러 형태로 나타날 수 있기 때문에 무엇이 정확히 생성되는지는 모호할 수 있습니다. 이 일반적인 <code>lib</code> 옵션의 목적은 “컴파일러가 권장하는” 스타일의 라이브러리를 생성하는 것입니다. 생성된 라이브러리는 항상 rustc에서 사용할 수 있지만, 실제 라이브러리 타입은 수시로 바뀔 수 있습니다. 나머지 출력 타입들은 모두 서로 다른 종류의 라이브러리들이며, <code>lib</code> 타입은 그 중 하나에 대한 별칭으로 볼 수 있습니다(실제 타입은 컴파일러가 정의합니다).</li>
</ul>
<p>r[link.dylib]</p>
<ul>
<li><code>--crate-type=dylib</code>, <code>#![crate_type = "dylib"]</code> - 동적 러스트 라이브러리가 생성됩니다. 이는 <code>lib</code> 출력 타입과 달리 동적 라이브러리 생성을 강제합니다. 생성된 동적 라이브러리는 다른 라이브러리나 실행 파일의 의존성으로 사용될 수 있습니다. 이 출력 타입은 리눅스에서는 <code>*.so</code>, macOS에서는 <code>*.dylib</code>, 윈도우에서는 <code>*.dll</code> 파일을 생성합니다.</li>
</ul>
<p>r[link.staticlib]</p>
<ul>
<li>
<p><code>--crate-type=staticlib</code>, <code>#![crate_type = "staticlib"]</code> - 정적 시스템 라이브러리가 생성됩니다. 이는 다른 라이브러리 출력과 달리, 컴파일러가 <code>staticlib</code> 출력에 링크하려고 시도하지 않습니다. 이 출력 타입의 목적은 로컬 크레이트의 모든 코드와 모든 업스트림 의존성을 포함하는 정적 라이브러리를 만드는 것입니다. 이 출력 타입은 리눅스, macOS 및 윈도우(MinGW)에서는 <code>*.a</code> 파일을, 윈도우(MSVC)에서는 <code>*.lib</code> 파일을 생성합니다. 이 형식은 다른 러스트 코드에 대한 동적 의존성이 없기 때문에, 기존의 비-러스트 애플리케이션에 러스트 코드를 링크하는 것과 같은 상황에서 사용하는 것을 권장합니다.</p>
<p>정적 라이브러리가 가질 수 있는 모든 동적 의존성(예: 시스템 라이브러리에 대한 의존성, 또는 동적 라이브러리로 컴파일된 러스트 라이브러리에 대한 의존성)은 해당 정적 라이브러리를 어딘가에서 링크할 때 수동으로 지정해야 함에 유의하십시오. <code>--print=native-static-libs</code> 플래그가 이 작업에 도움이 될 수 있습니다.</p>
<p>생성된 정적 라이브러리는 표준 라이브러리를 포함한 모든 의존성의 코드를 포함하고 이들의 모든 공개 심볼을 내보내기 때문에, 정적 라이브러리를 실행 파일이나 공유 라이브러리에 링크할 때는 특별한 주의가 필요할 수 있음에 유의하십시오. 공유 라이브러리의 경우, 내보낼 심볼 목록을 링커나 심볼 버전 스크립트, 내보낸 심볼 목록(macOS) 또는 모듈 정의 파일(윈도우) 등을 통해 제한해야 합니다. 또한, 실제로 사용되지 않는 의존성 코드를 모두 제거하기 위해 사용되지 않는 섹션을 제거할 수 있습니다 (예: <code>--gc-sections</code> 또는 macOS의 <code>-dead_strip</code>).</p>
</li>
</ul>
<p>r[link.cdylib]</p>
<ul>
<li><code>--crate-type=cdylib</code>, <code>#![crate_type = "cdylib"]</code> - 동적 시스템 라이브러리가 생성됩니다. 이는 다른 언어에서 로드할 동적 라이브러리를 컴파일할 때 사용됩니다. 이 출력 타입은 리눅스에서는 <code>*.so</code>, macOS에서는 <code>*.dylib</code>, 윈도우에서는 <code>*.dll</code> 파일을 생성합니다.</li>
</ul>
<p>r[link.rlib]</p>
<ul>
<li><code>--crate-type=rlib</code>, <code>#![crate_type = "rlib"]</code> - “러스트 라이브러리” 파일이 생성됩니다. 이는 중간 생성물로 사용되며 “정적 러스트 라이브러리“라고 생각할 수 있습니다. 이러한 <code>rlib</code> 파일은 <code>staticlib</code> 파일과 달리 향후 링크 시 컴파일러에 의해 해석됩니다. 이는 본질적으로 <code>rustc</code>가 동적 라이브러리에서 메타데이터를 찾는 것처럼 <code>rlib</code> 파일에서도 메타데이터를 찾는다는 것을 의미합니다. 이 출력 형식은 정적으로 링크된 실행 파일과 <code>staticlib</code> 출력을 생성하는 데 사용됩니다.</li>
</ul>
<p>r[link.proc-macro]</p>
<ul>
<li><code>--crate-type=proc-macro</code>, <code>#![crate_type = "proc-macro"]</code> - 생성되는 출력은 명시되지 않았지만, <code>-L</code> 경로가 제공되면 컴파일러는 출력 결과물을 매크로로 인식하고 프로그램에 로드할 수 있습니다. 이 크레이트 타입으로 컴파일된 크레이트는 반드시 <a href="procedural-macros.html">절차적 매크로</a>만 내보내야 합니다. 컴파일러는 자동으로 <code>proc_macro</code> <a href="conditional-compilation.html">설정 옵션</a>을 설정합니다. 크레이트는 항상 컴파일러 자체가 빌드된 것과 동일한 타겟으로 컴파일됩니다. 예를 들어, 리눅스 <code>x86_64</code> CPU에서 컴파일러를 실행 중이라면, 다른 타겟을 위해 빌드 중인 다른 크레이트의 의존성일지라도 타겟은 <code>x86_64-unknown-linux-gnu</code>가 됩니다.</li>
</ul>
<p>r[link.repetition] Note that these outputs are stackable in the sense that if multiple are specified, then the compiler will produce each form of output without having to recompile. However, this only applies for outputs specified by the same method. If only <code>crate_type</code> attributes are specified, then they will all be built, but if one or more <code>--crate-type</code> command line flags are specified, then only those outputs will be built.</p>
<p>r[link.dependency] With all these different kinds of outputs, if crate A depends on crate B, then the compiler could find B in various different forms throughout the system. The only forms looked for by the compiler, however, are the <code>rlib</code> format and the dynamic library format. With these two options for a dependent library, the compiler must at some point make a choice between these two formats. With this in mind, the compiler follows these rules when determining what format of dependencies will be used:</p>
<p>r[link.dependency-staticlib]</p>
<ol>
<li>
<p>정적 라이브러리가 생성되는 경우, 모든 업스트림 의존성은 <code>rlib</code> 형식으로 사용 가능해야 합니다. 이 요구 사항은 동적 라이브러리를 정적 형식으로 변환할 수 없다는 이유에서 비롯됩니다.</p>
<p>정적 라이브러리에 네이티브 동적 의존성을 링크하는 것은 불가능하며, 이 경우 링크되지 않은 모든 네이티브 동적 의존성에 대한 경고가 출력됨에 유의하십시오.</p>
</li>
</ol>
<p>r[link.dependency-rlib]</p>
<ol start="2">
<li>
<p><code>rlib</code> 파일이 생성되는 경우, 업스트림 의존성이 어떤 형식으로 제공되는지에 대한 제한은 없습니다. 단지 메타데이터를 읽기 위해 모든 업스트림 의존성이 사용 가능해야 합니다.</p>
<p><code>rlib</code> 파일이 <code>libstd.rlib</code> 사본을 포함한다면 그다지 효율적이지 않을 것입니다!</p>
</li>
</ol>
<p>r[link.dependency-prefer-dynamic]</p>
<ol start="3">
<li>실행 파일이 생성되고 <code>-C prefer-dynamic</code> 플래그가 지정되지 않은 경우, 먼저 <code>rlib</code> 형식의 의존성을 찾으려고 시도합니다. 일부 의존성을 rlib 형식으로 사용할 수 없는 경우, 동적 링크가 시도됩니다(아래 참조).</li>
</ol>
<p>r[link.dependency-dynamic]</p>
<ol start="4">
<li>
<p>동적 라이브러리나 동적으로 링크되는 실행 파일이 생성되는 경우, 컴파일러는 최종 결과물을 만들기 위해 사용 가능한 의존성들을 rlib 또는 dylib 형식 중에서 조정하려고 시도합니다.</p>
<p>컴파일러의 주요 목표는 라이브러리가 어떤 결과물에서도 두 번 이상 나타나지 않도록 보장하는 것입니다. 예를 들어, 만약 동적 라이브러리 B와 C가 각각 라이브러리 A에 정적으로 링크되어 있다면, A의 사본이 두 개가 되기 때문에 어떤 크레이트도 B와 C를 동시에 링크할 수 없습니다. 컴파일러는 rlib와 dylib 형식의 혼합을 허용하지만, 이 제한 사항은 반드시 준수되어야 합니다.</p>
<p>컴파일러는 현재 라이브러리를 어떤 형식으로 링크해야 하는지에 대한 힌트를 제공하는 방법을 구현하고 있지 않습니다. 동적 링크 시 컴파일러는 일부 의존성을 rlib를 통해 링크하는 것을 허용하면서도 동적 의존성을 최대화하려고 시도합니다.</p>
<p>대부분의 상황에서, 동적 링크를 하는 경우 모든 라이브러리를 dylib로 사용할 수 있도록 하는 것이 권장됩니다. 다른 상황에서 컴파일러는 각 라이브러리를 어떤 형식으로 링크해야 할지 결정할 수 없는 경우 경고를 출력합니다.</p>
</li>
</ol>
<p>일반적으로 모든 컴파일 요구 사항에 대해 <code>--crate-type=bin</code> 또는 <code>--crate-type=lib</code>로 충분하며, 다른 옵션들은 크레이트의 출력 형식에 대해 더 세밀한 제어가 필요한 경우에만 사용 가능합니다.</p>
<p>r[link.crt]</p>
<h2 id="정적-및-동적-c-런타임"><a class="header" href="#정적-및-동적-c-런타임">정적 및 동적 C 런타임</a></h2>
<p>r[link.crt.intro] The standard library in general strives to support both statically linked and dynamically linked C runtimes for targets as appropriate. For example the <code>x86_64-pc-windows-msvc</code> and <code>x86_64-unknown-linux-musl</code> targets typically come with both runtimes and the user selects which one they’d like. All targets in the compiler have a default mode of linking to the C runtime. Typically targets are linked dynamically by default, but there are exceptions which are static by default such as:</p>
<ul>
<li><code>arm-unknown-linux-musleabi</code></li>
<li><code>arm-unknown-linux-musleabihf</code></li>
<li><code>armv7-unknown-linux-musleabihf</code></li>
<li><code>i686-unknown-linux-musl</code></li>
<li><code>x86_64-unknown-linux-musl</code></li>
</ul>
<p>r[link.crt.crt-static] The linkage of the C runtime is configured to respect the <code>crt-static</code> target feature. These target features are typically configured from the command line via flags to the compiler itself. For example to enable a static runtime you would execute:</p>
<pre><code class="language-sh">rustc -C target-feature=+crt-static foo.rs
</code></pre>
<p>반면 C 런타임에 동적으로 링크하려면 다음과 같이 실행합니다.</p>
<pre><code class="language-sh">rustc -C target-feature=-crt-static foo.rs
</code></pre>
<p>r[link.crt.ineffective] Targets which do not support switching between linkage of the C runtime will ignore this flag. It’s recommended to inspect the resulting binary to ensure that it’s linked as you would expect after the compiler succeeds.</p>
<p>r[link.crt.target_feature] Crates may also learn about how the C runtime is being linked. Code on MSVC, for example, needs to be compiled differently (e.g. with <code>/MT</code> or <code>/MD</code>) depending on the runtime being linked. This is exported currently through the <a href="conditional-compilation.html#target_feature"><code>cfg</code> attribute <code>target_feature</code> option</a>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(target_feature = "crt-static")]
fn foo() {
    println!("C 런타임은 정적으로 링크되어야 함");
}

#[cfg(not(target_feature = "crt-static"))]
fn foo() {
    println!("C 런타임은 동적으로 링크되어야 함");
}
<span class="boring">}</span></code></pre></pre>
<p>또한 Cargo 빌드 스크립트는 <a href="../cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts">환경 변수</a>를 통해 이 기능에 대해 알 수 있습니다. 빌드 스크립트에서는 다음과 같이 링크 여부를 감지할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::env;

fn main() {
    let linkage = env::var("CARGO_CFG_TARGET_FEATURE").unwrap_or(String::new());

    if linkage.contains("crt-static") {
        println!("C 런타임은 정적으로 링크될 것임");
    } else {
        println!("C 런타임은 동적으로 링크될 것임");
    }
}</code></pre></pre>
<p>로컬에서 이 기능을 사용하려면 일반적으로 <code>RUSTFLAGS</code> 환경 변수를 사용하여 Cargo를 통해 컴파일러 플래그를 지정합니다. 예를 들어 MSVC에서 정적으로 링크된 바이너리를 컴파일하려면 다음과 같이 실행합니다:</p>
<pre><code class="language-sh">RUSTFLAGS='-C target-feature=+crt-static' cargo build --target x86_64-pc-windows-msvc
</code></pre>
<p>r[link.foreign-code]</p>
<h2 id="러스트와-외부-코드베이스의-혼합"><a class="header" href="#러스트와-외부-코드베이스의-혼합">러스트와 외부 코드베이스의 혼합</a></h2>
<p>r[link.foreign-code.foreign-linkers] If you are mixing Rust with foreign code (e.g. C, C++) and wish to make a single binary containing both types of code, you have two approaches for the final binary link:</p>
<ul>
<li><code>rustc</code>를 사용합니다. 비-러스트 라이브러리는 <code>rustc</code> 인자인 <code>-L &lt;directory&gt;</code> 및 <code>-l&lt;library&gt;</code>를 사용하거나 러스트 코드의 <code>#[link]</code> 지시어를 통해 전달합니다. <code>.o</code> 파일에 링크해야 한다면 <code>-Clink-arg=file.o</code>를 사용할 수 있습니다.</li>
<li>외부 링커를 사용합니다. 이 경우, 먼저 러스트 <code>staticlib</code> 타겟을 생성하고 이를 외부 링커 호출 시 전달해야 합니다. 여러 개의 러스트 서브시스템을 링크해야 한다면, 여러 개의 <code>extern crate</code> 문을 사용하여 여러 러스트 <code>rlib</code>를 포함하는 단일 <code>staticlib</code>를 생성해야 할 수도 있습니다. 여러 개의 러스트 <code>staticlib</code> 파일은 충돌할 가능성이 높습니다.</li>
</ul>
<p>러스트 <code>rlib</code>를 외부 링커에 직접 전달하는 것은 현재 지원되지 않습니다.</p>
<blockquote>
<p>[!NOTE] Rust code compiled or linked with a different instance of the Rust runtime counts as “foreign code” for the purpose of this section.</p>
</blockquote>
<p>r[link.unwinding]</p>
<h3 id="prohibited-linkage-and-unwinding"><a class="header" href="#prohibited-linkage-and-unwinding">Prohibited linkage and unwinding</a></h3>
<p>r[link.unwinding.intro] Panic unwinding can only be used if the binary is built consistently according to the following rules.</p>
<p>r[link.unwinding.potential] A Rust artifact is called <em>potentially unwinding</em> if any of the following conditions is met:</p>
<ul>
<li>The artifact uses the [<code>unwind</code> panic handler][panic.panic_handler].</li>
<li>The artifact contains a crate built with the <code>unwind</code> <a href="panic.html#panic-strategy">panic strategy</a> that makes a call to a function using a <code>-unwind</code> ABI.</li>
<li>The artifact makes a <code>"Rust"</code> ABI call to code running in another Rust artifact that has a separate copy of the Rust runtime, and that other artifact is potentially unwinding.</li>
</ul>
<blockquote>
<p>[!NOTE] This definition captures whether a <code>"Rust"</code> ABI call inside a Rust artifact can ever unwind.</p>
</blockquote>
<p>r[link.unwinding.prohibited] If a Rust artifact is potentially unwinding, then all its crates must be built with the <code>unwind</code> <a href="panic.html#panic-strategy">panic strategy</a>. Otherwise, unwinding can cause undefined behavior.</p>
<blockquote>
<p>[!NOTE] If you are using <code>rustc</code> to link, these rules are enforced automatically. If you are <em>not</em> using <code>rustc</code> to link, you must take care to ensure that unwinding is handled consistently across the entire binary. Linking without <code>rustc</code> includes using <code>dlopen</code> or similar facilities where linking is done by the system runtime without <code>rustc</code> being involved. This can only happen when mixing code with different <a href="../rustc/codegen-options/index.html#panic"><code>-C panic</code></a> flags, so most users do not have to be concerned about this.</p>
</blockquote>
<blockquote>
<p>[!NOTE] To guarantee that a library will be sound (and linkable with <code>rustc</code>) regardless of the panic runtime used at link-time, the <a href="../rustc/lints/listing/allowed-by-default.html#ffi-unwind-calls"><code>ffi_unwind_calls</code> lint</a> may be used. The lint flags any calls to <code>-unwind</code> foreign functions or function pointers.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>r[asm]</p>
<h1 id="인라인-어셈블리"><a class="header" href="#인라인-어셈블리">인라인 어셈블리</a></h1>
<p>r[asm.intro] Support for inline assembly is provided via the <a href="core::arch::asm"><code>asm!</code></a>, <a href="core::arch::naked_asm"><code>naked_asm!</code></a>, and <a href="core::arch::global_asm"><code>global_asm!</code></a> macros. It can be used to embed handwritten assembly in the assembly output generated by the compiler.</p>
<p>r[asm.stable-targets] Support for inline assembly is stable on the following architectures:</p>
<ul>
<li>x86 및 x86-64</li>
<li>ARM</li>
<li>AArch64 및 Arm64EC</li>
<li>RISC-V</li>
<li>LoongArch</li>
<li>s390x</li>
</ul>
<p>The compiler will emit an error if an assembly macro is used on an unsupported target.</p>
<p>r[asm.example]</p>
<h2 id="예시-5"><a class="header" href="#예시-5">예시</a></h2>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>use std::arch::asm;

// 시프트와 덧셈을 사용하여 x에 6을 곱합니다.
let mut x: u64 = 4;
unsafe {
    asm!(
        "mov {tmp}, {x}",
        "shl {tmp}, 1",
        "shl {x}, 2",
        "add {x}, {tmp}",
        x = inout(reg) x,
        tmp = out(reg) _,
    );
}
assert_eq!(x, 4 * 6);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.syntax]</p>
<h2 id="구문-1"><a class="header" href="#구문-1">구문</a></h2>
<p>The following grammar specifies the arguments that can be passed to the <code>asm!</code>, <code>global_asm!</code> and <code>naked_asm!</code> macros.</p>
<pre><code class="language-grammar assembly">@root AsmArgs -&gt; AsmAttrFormatString (`,` AsmAttrFormatString)* (`,` AsmAttrOperand)* `,`?

FormatString -&gt; STRING_LITERAL | RAW_STRING_LITERAL | MacroInvocation

AsmAttrFormatString -&gt; (OuterAttribute)* FormatString

AsmOperand -&gt;
      ClobberAbi
    | AsmOptions
    | RegOperand

AsmAttrOperand -&gt; (OuterAttribute)* AsmOperand

ClobberAbi -&gt; `clobber_abi` `(` Abi (`,` Abi)* `,`? `)`

AsmOptions -&gt;
    `options` `(` ( AsmOption (`,` AsmOption)* `,`? )? `)`

AsmOption -&gt;
      `pure`
    | `nomem`
    | `readonly`
    | `preserves_flags`
    | `noreturn`
    | `nostack`
    | `att_syntax`
    | `raw`

RegOperand -&gt; (ParamName `=`)?
    (
          DirSpec `(` RegSpec `)` Expression
        | DualDirSpec `(` RegSpec `)` DualDirSpecExpression
        | `sym` PathExpression
        | `const` Expression
        | `label` `{` Statements? `}`
    )

ParamName -&gt; IDENTIFIER_OR_KEYWORD | RAW_IDENTIFIER

DualDirSpecExpression -&gt;
      Expression
    | Expression `=&gt;` Expression

RegSpec -&gt; RegisterClass | ExplicitRegister

RegisterClass -&gt; IDENTIFIER_OR_KEYWORD

ExplicitRegister -&gt; STRING_LITERAL

DirSpec -&gt;
      `in`
    | `out`
    | `lateout`

DualDirSpec -&gt;
      `inout`
    | `inlateout`
</code></pre>
<p>r[asm.scope]</p>
<h2 id="스코프-2"><a class="header" href="#스코프-2">스코프</a></h2>
<p>r[asm.scope.intro] Inline assembly can be used in one of three ways.</p>
<p>r[asm.scope.asm] With the <code>asm!</code> macro, the assembly code is emitted in a function scope and integrated into the compiler-generated assembly code of a function. This assembly code must obey <a href="inline-assembly.html#rules-for-inline-assembly">strict rules</a> to avoid undefined behavior. Note that in some cases the compiler may choose to emit the assembly code as a separate function and generate a call to it.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>unsafe { core::arch::asm!("/* {} */", in(reg) 0); }
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.scope.naked_asm] With the <code>naked_asm!</code> macro, the assembly code is emitted in a function scope and constitutes the full assembly code of a function. The <code>naked_asm!</code> macro is only allowed in <a href="attributes/codegen.html#the-naked-attribute">naked functions</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span><span class="boring">#[unsafe(naked)]
</span><span class="boring">extern "C" fn wrapper() {
</span>core::arch::naked_asm!("/* {} */", const 0);
<span class="boring">}
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.scope.global_asm] With the <code>global_asm!</code> macro, the assembly code is emitted in a global scope, outside a function. This can be used to hand-write entire functions using assembly code, and generally provides much more freedom to use arbitrary registers and assembler directives.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {}
</span><span class="boring">#[cfg(target_arch = "x86_64")]
</span>core::arch::global_asm!("/* {} */", const 0);</code></pre></pre>
<p>r[asm.ts-args]</p>
<h2 id="템플릿-문자열-인자"><a class="header" href="#템플릿-문자열-인자">템플릿 문자열 인자</a></h2>
<p>r[asm.ts-args.syntax] The assembler template uses the same syntax as <a href="std::fmt#syntax">format strings</a> (i.e. placeholders are specified by curly braces).</p>
<p>r[asm.ts-args.order] The corresponding arguments are accessed in order, by index, or by name.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let x: i64;
let y: i64;
let z: i64;
// 이것과
unsafe { core::arch::asm!("mov {}, {}", out(reg) x, in(reg) 5); }
// ... 이것
unsafe { core::arch::asm!("mov {0}, {1}", out(reg) y, in(reg) 5); }
// ... 그리고 이것은
unsafe { core::arch::asm!("mov {out}, {in}", out = out(reg) z, in = in(reg) 5); }
// 모두 동일하게 동작합니다.
assert_eq!(x, y);
assert_eq!(y, z);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.ts-args.no-implicit] However, implicit named arguments (introduced by <a href="https://github.com/rust-lang/rfcs/pull/2795">RFC #2795</a>) are not supported.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let x = 5;
// 스코프에서 직접 `x`를 참조할 수 없으며, `in(reg) x`와 같은 피연산자가 필요합니다.
unsafe { core::arch::asm!("/* {x} */"); } // 오류: x라는 이름의 인자가 없습니다.
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.ts-args.one-or-more] An <code>asm!</code> invocation may have one or more template string arguments; an <code>asm!</code> with multiple template string arguments is treated as if all the strings were concatenated with a <code>\n</code> between them. The expected usage is for each template string argument to correspond to a line of assembly code.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let x: i64;
let y: i64;
// 여러 문자열을 마치 함께 작성된 것처럼 분리할 수 있습니다.
unsafe { core::arch::asm!("mov eax, 5", "mov ecx, eax", out("rax") x, out("rcx") y); }
assert_eq!(x, y);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.ts-args.before-other-args] All template string arguments must appear before any other arguments.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">#[cfg(target_arch = "x86_64")] {
</span>// 템플릿 문자열은 asm 호출에서 가장 먼저 나타나야 합니다.
unsafe { core::arch::asm!("/* {x} */", x = const 5, "ud2"); } // 오류: 예상치 못한 토큰
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.ts-args.positional-first] As with format strings, positional arguments must appear before named arguments and explicit <a href="inline-assembly.html#register-operands">register operands</a>.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>// 명명된 피연산자는 위치 기반 피연산자 뒤에 와야 합니다.
unsafe { core::arch::asm!("/* {x} {} */", x = const 5, in(reg) 5); }
// 오류: 위치 기반 인자는 명명된 인자나 명시적 레지스터 인자 뒤에 올 수 없습니다.
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>// 또한 위치 기반 피연산자 앞에 명시적 레지스터를 둘 수 없습니다.
unsafe { core::arch::asm!("/* {} */", in("eax") 0, in(reg) 5); }
// 오류: 위치 기반 인자는 명명된 인자나 명시적 레지스터 인자 뒤에 올 수 없습니다.
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.ts-args.register-operands] Explicit register operands cannot be used by placeholders in the template string.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>// 명시적 레지스터 피연산자는 치환되지 않으므로, 문자열에서 `eax`를 명시적으로 사용하십시오.
unsafe { core::arch::asm!("/* {} */", in("eax") 5); }
// 오류: 인덱스 0의 인자에 대한 잘못된 참조
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.ts-args.at-least-once] All other named and positional operands must appear at least once in the template string, otherwise a compiler error is generated.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>// 포맷 문자열에서 모든 피연산자의 이름을 지정해야 합니다.
unsafe { core::arch::asm!("", in(reg) 5, x = const 5); }
// 오류: 사용되지 않은 여러 개의 asm 인자가 있습니다.
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.ts-args.opaque] The exact assembly code syntax is target-specific and opaque to the compiler except for the way operands are substituted into the template string to form the code passed to the assembler.</p>
<p>r[asm.ts-args.llvm-syntax] Currently, all supported targets follow the assembly code syntax used by LLVM’s internal assembler which usually corresponds to that of the GNU assembler (GAS). On x86, the <code>.intel_syntax noprefix</code> mode of GAS is used by default. On ARM, the <code>.syntax unified</code> mode is used. These targets impose an additional restriction on the assembly code: any assembler state (e.g. the current section which can be changed with <code>.section</code>) must be restored to its original value at the end of the asm string. Assembly code that does not conform to the GAS syntax will result in assembler-specific behavior. Further constraints on the directives used by inline assembly are indicated by <a href="inline-assembly.html#directives-support">Directives Support</a>.</p>
<p>r[asm.attributes]</p>
<h2 id="속성-2"><a class="header" href="#속성-2">속성</a></h2>
<p>r[asm.attributes.supported-attributes] Only the <a href="conditional-compilation.html#the-cfg-attribute"><code>cfg</code></a> and <a href="conditional-compilation.html#the-cfg_attr-attribute"><code>cfg_attr</code></a> attributes are accepted semantically on inline assembly template strings and operands. Other attributes are parsed but rejected when the assembly macro is expanded.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {}
</span><span class="boring">#[cfg(target_arch = "x86_64")]
</span>core::arch::global_asm!(
    #[cfg(not(panic = "abort"))]
    ".cfi_startproc",
    // ...
    "ret",
    #[cfg(not(panic = "abort"))]
    ".cfi_endproc",
);</code></pre></pre>
<blockquote>
<p>[!NOTE] In <code>rustc</code>, the assembly macros implement handling of these attributes separately from the normal system that handles similar attributes in the language. This accounts for the limited kinds of attributes supported and may give rise to subtle differences in behavior.</p>
</blockquote>
<p>r[asm.attributes.starts-with-template] Syntactically there must be at least one template string before the first operand.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This is rejected because `a = out(reg) x` does not parse as a
// template string.
core::arch::asm!(
    #[cfg(false)]
    a = out(reg) x, // ERROR.
    "",
);
<span class="boring">}</span></code></pre></pre>
<p>r[asm.operand-type]</p>
<h2 id="피연산자-타입"><a class="header" href="#피연산자-타입">피연산자 타입</a></h2>
<p>r[asm.operand-type.supported-operands] Several types of operands are supported:</p>
<p>r[asm.operand-type.supported-operands.in]</p>
<ul>
<li><code>in(&lt;reg&gt;) &lt;expr&gt;</code>
<ul>
<li><code>&lt;reg&gt;</code>는 레지스터 클래스 또는 명시적 레지스터를 참조할 수 있습니다. 할당된 레지스터 이름이 asm 템플릿 문자열에 치환됩니다.</li>
<li>The allocated register will contain the value of <code>&lt;expr&gt;</code> at the start of the assembly code.</li>
<li>The allocated register must contain the same value at the end of the assembly code (except if a <code>lateout</code> is allocated to the same register).</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>// `in`은 인라인 어셈블리에 값을 전달하는 데 사용될 수 있습니다...
unsafe { core::arch::asm!("/* {} */", in(reg) 5); }
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.operand-type.supported-operands.out]</p>
<ul>
<li><code>out(&lt;reg&gt;) &lt;expr&gt;</code>
<ul>
<li><code>&lt;reg&gt;</code>는 레지스터 클래스 또는 명시적 레지스터를 참조할 수 있습니다. 할당된 레지스터 이름이 asm 템플릿 문자열에 치환됩니다.</li>
<li>The allocated register will contain an undefined value at the start of the assembly code.</li>
<li><code>&lt;expr&gt;</code> must be a (possibly uninitialized) place expression, to which the contents of the allocated register are written at the end of the assembly code.</li>
<li>An underscore (<code>_</code>) may be specified instead of an expression, which will cause the contents of the register to be discarded at the end of the assembly code (effectively acting as a clobber).</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let x: i64;
// 그리고 `out`은 값을 다시 러스트로 전달하는 데 사용될 수 있습니다.
unsafe { core::arch::asm!("/* {} */", out(reg) x); }
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.operand-type.supported-operands.lateout]</p>
<ul>
<li><code>lateout(&lt;reg&gt;) &lt;expr&gt;</code>
<ul>
<li><code>out</code>과 동일하지만, 레지스터 할당기가 <code>in</code>에 할당된 레지스터를 재사용할 수 있습니다.</li>
<li>모든 입력이 읽힌 후에만 레지스터에 기록해야 합니다. 그렇지 않으면 입력을 덮어쓸(clobber) 수 있습니다.</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let x: i64;
// `lateout`은 `out`과 동일하지만,
// 우리가 값을 덮어쓸 시점에 입력값들에 대해 더 이상 신경 쓰지 않는다는 것을
// 컴파일러가 알고 있습니다.
unsafe { core::arch::asm!("mov {}, 5", lateout(reg) x); }
assert_eq!(x, 5)
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.operand-type.supported-operands.inout]</p>
<ul>
<li><code>inout(&lt;reg&gt;) &lt;expr&gt;</code>
<ul>
<li><code>&lt;reg&gt;</code>는 레지스터 클래스 또는 명시적 레지스터를 참조할 수 있습니다. 할당된 레지스터 이름이 asm 템플릿 문자열에 치환됩니다.</li>
<li>The allocated register will contain the value of <code>&lt;expr&gt;</code> at the start of the assembly code.</li>
<li><code>&lt;expr&gt;</code> must be a mutable initialized place expression, to which the contents of the allocated register are written at the end of the assembly code.</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let mut x: i64 = 4;
// `inout`은 레지스터 내에서 값을 수정하는 데 사용될 수 있습니다.
unsafe { core::arch::asm!("inc {}", inout(reg) x); }
assert_eq!(x, 5);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.operand-type.supported-operands.inout-arrow]</p>
<ul>
<li><code>inout(&lt;reg&gt;) &lt;in expr&gt; =&gt; &lt;out expr&gt;</code>
<ul>
<li><code>inout</code>과 동일하지만, 레지스터의 초기값이 <code>&lt;in expr&gt;</code>의 값에서 취해집니다.</li>
<li><code>&lt;out expr&gt;</code> must be a (possibly uninitialized) place expression, to which the contents of the allocated register are written at the end of the assembly code.</li>
<li>An underscore (<code>_</code>) may be specified instead of an expression for <code>&lt;out expr&gt;</code>, which will cause the contents of the register to be discarded at the end of the assembly code (effectively acting as a clobber).</li>
<li><code>&lt;in expr&gt;</code>과 <code>&lt;out expr&gt;</code>은 서로 다른 타입을 가질 수 있습니다.</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let x: i64;
// `inout`은 또한 값을 다른 장소로 이동시킬 수 있습니다.
unsafe { core::arch::asm!("inc {}", inout(reg) 4u64=&gt;x); }
assert_eq!(x, 5);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.operand-type.supported-operands.inlateout]</p>
<ul>
<li><code>inlateout(&lt;reg&gt;) &lt;expr&gt;</code> / <code>inlateout(&lt;reg&gt;) &lt;in expr&gt; =&gt; &lt;out expr&gt;</code>
<ul>
<li><code>inout</code>과 동일하지만, 레지스터 할당기가 <code>in</code>에 할당된 레지스터를 재사용할 수 있습니다(이는 컴파일러가 <code>in</code>이 <code>inlateout</code>과 동일한 초기값을 갖는다는 것을 아는 경우 발생할 수 있습니다).</li>
<li>모든 입력이 읽힌 후에만 레지스터에 기록해야 합니다. 그렇지 않으면 입력을 덮어쓸(clobber) 수 있습니다.</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let mut x: i64 = 4;
// `inlateout`은 `lateout`을 사용하는 `inout`입니다.
unsafe { core::arch::asm!("inc {}", inlateout(reg) x); }
assert_eq!(x, 5);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.operand-type.supported-operands.sym]</p>
<ul>
<li><code>sym &lt;path&gt;</code>
<ul>
<li><code>&lt;path&gt;</code>는 <code>fn</code> 또는 <code>static</code>을 참조해야 합니다.</li>
<li>해당 아이템을 참조하는 맹글링된(mangled) 심볼 이름이 asm 템플릿 문자열에 치환됩니다.</li>
<li>치환된 문자열에는 어떠한 수식어(예: GOT, PLT, 재배치(relocations) 등)도 포함되지 않습니다.</li>
<li><code>&lt;path&gt;</code> is allowed to point to a <code>#[thread_local]</code> static, in which case the assembly code can combine the symbol with relocations (e.g. <code>@plt</code>, <code>@TPOFF</code>) to read from thread-local data.</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>extern "C" fn foo() {
    println!("Hello from inline assembly")
}
// `sym`은 (직접 쓸 수 있는 외부 이름이 없는 경우에도) 함수를 참조하는 데 사용될 수 있습니다.
unsafe { core::arch::asm!("call {}", sym foo, clobber_abi("C")); }
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.operand-type.supported-operands.const]</p>
<ul>
<li><code>const &lt;expr&gt;</code>
<ul>
<li><code>&lt;expr&gt;</code>은 정수 상수 표현식이어야 합니다. 이 표현식은 인라인 <code>const</code> 블록과 동일한 규칙을 따릅니다.</li>
<li>표현식의 타입은 모든 정수 타입이 될 수 있지만, 정수 리터럴과 마찬가지로 기본값은 <code>i32</code>입니다.</li>
<li>표현식의 값은 문자열로 포맷되어 asm 템플릿 문자열에 직접 치환됩니다.</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>// swizzle [0, 1, 2, 3] =&gt; [3, 2, 0, 1]
const SHUFFLE: u8 = 0b01_00_10_11;
let x: core::arch::x86_64::__m128 = unsafe { core::mem::transmute([0u32, 1u32, 2u32, 3u32]) };
let y: core::arch::x86_64::__m128;
// `pshufd`와 같이 즉시값(immediate)을 기대하는 명령어에 상수 값을 전달합니다.
unsafe {
    core::arch::asm!("pshufd {xmm}, {xmm}, {shuffle}",
        xmm = inlateout(xmm_reg) x=&gt;y,
        shuffle = const SHUFFLE
    );
}
let y: [u32; 4] = unsafe { core::mem::transmute(y) };
assert_eq!(y, [3, 2, 0, 1]);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.operand-type.supported-operands.label]</p>
<ul>
<li><code>label &lt;block&gt;</code>
<ul>
<li>The address of the block is substituted into the asm template string. The assembly code may jump to the substituted address.</li>
<li>For targets that distinguish between direct jumps and indirect jumps (e.g. x86-64 with <code>cf-protection</code> enabled), the assembly code must not jump to the substituted address indirectly.</li>
<li>After execution of the block, the <code>asm!</code> expression returns.</li>
<li>The type of the block must be unit or <code>!</code> (never).</li>
<li>The block starts a new safety context; unsafe operations within the <code>label</code> block must be wrapped in an inner <code>unsafe</code> block, even though the entire <code>asm!</code> expression is already wrapped in <code>unsafe</code>.</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")]
</span>unsafe {
    core::arch::asm!("jmp {}", label {
        println!("Hello from inline assembly label");
    });
}
<span class="boring">}</span></code></pre></pre>
<p>r[asm.operand-type.left-to-right] Operand expressions are evaluated from left to right, just like function call arguments. After the <code>asm!</code> has executed, outputs are written to in left to right order. This is significant if two outputs point to the same place: that place will contain the value of the rightmost output.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let mut y: i64;
// y는 첫 번째 출력이 아니라 두 번째 출력에서 값을 가져옵니다.
unsafe { core::arch::asm!("mov {}, 0", "mov {}, 1", out(reg) y, out(reg) y); }
assert_eq!(y, 1);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.operand-type.naked_asm-restriction] Because <code>naked_asm!</code> defines a whole function body and the compiler cannot emit any additional code to handle operands, it can only use <code>sym</code> and <code>const</code> operands.</p>
<p>r[asm.operand-type.global_asm-restriction] Because <code>global_asm!</code> exists outside a function, it can only use <code>sym</code> and <code>const</code> operands.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">fn main() {}
</span>// 함수 내부에 있지 않으므로 레지스터 피연산자는 허용되지 않습니다.
<span class="boring">#[cfg(target_arch = "x86_64")]
</span>core::arch::global_asm!("", in(reg) 5);
// 오류: `in` 피연산자는 `global_asm!`과 함께 사용될 수 없습니다.
<span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {}
</span>fn foo() {}

<span class="boring">#[cfg(target_arch = "x86_64")]
</span>// 하지만 `const`와 `sym`은 모두 허용됩니다.
core::arch::global_asm!("/* {} {} */", const 0, sym foo);</code></pre></pre>
<p>r[asm.register-operands]</p>
<h2 id="레지스터-피연산자"><a class="header" href="#레지스터-피연산자">레지스터 피연산자</a></h2>
<p>r[asm.register-operands.register-or-class] Input and output operands can be specified either as an explicit register or as a register class from which the register allocator can select a register. Explicit registers are specified as string literals (e.g. <code>"eax"</code>) while register classes are specified as identifiers (e.g. <code>reg</code>).</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let mut y: i64;
// `reg` 또는 `eax`와 같은 명시적 레지스터를 지정하여 정수 레지스터를 얻을 수 있습니다.
unsafe { core::arch::asm!("mov eax, {:e}", in(reg) 5, lateout("eax") y); }
assert_eq!(y, 5);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.register-operands.equivalence-to-base-register] Note that explicit registers treat register aliases (e.g. <code>r14</code> vs <code>lr</code> on ARM) and smaller views of a register (e.g. <code>eax</code> vs <code>rax</code>) as equivalent to the base register.</p>
<p>r[asm.register-operands.error-two-operands] It is a compile-time error to use the same explicit register for two input operands or two output operands.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>// eax를 두 번 지정할 수 없습니다.
unsafe { core::arch::asm!("", in("eax") 5, in("eax") 4); }
// 오류: `eax` 레지스터가 `eax` 레지스터와 충돌합니다.
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>// ... 서로 다른 별칭을 사용하더라도 마찬가지입니다.
unsafe { core::arch::asm!("", in("ax") 5, in("rax") 4); }
// 오류: `rax` 레지스터가 `ax` 레지스터와 충돌합니다.
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.register-operands.error-overlapping] Additionally, it is also a compile-time error to use overlapping registers (e.g. ARM VFP) in input operands or in output operands.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>// al은 ax와 겹치므로 둘 다 지정할 수 없습니다.
unsafe { core::arch::asm!("", in("ax") 5, in("al") 4i8); }
// 오류: `al` 레지스터가 `ax` 레지스터와 충돌합니다.
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.register-operands.allowed-types] Only the following types are allowed as operands for inline assembly:</p>
<ul>
<li>정수 (부호 있는 것과 부호 없는 것)</li>
<li>부동 소수점 숫자</li>
<li>포인터 (thin 포인터만)</li>
<li>함수 포인터</li>
<li>SIMD 벡터 (<code>#[repr(simd)]</code>로 정의되고 <code>Copy</code>를 구현하는 구조체). 이는 <code>std::arch</code>에 정의된 아키텍처별 벡터 타입(예: x86의 <code>__m128</code> 또는 ARM의 <code>int8x16_t</code>)을 포함합니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>extern "C" fn foo() {}

// 정수는 허용됩니다...
let y: i64 = 5;
unsafe { core::arch::asm!("/* {} */", in(reg) y); }

// 포인터도 허용되며...
let py = &amp;raw const y;
unsafe { core::arch::asm!("/* {} */", in(reg) py); }

// 부동 소수점 역시 허용됩니다...
let f = 1.0f32;
unsafe { core::arch::asm!("/* {} */", in(xmm_reg) f); }

// 함수 포인터와 simd 벡터까지도 허용됩니다.
let func: extern "C" fn() = foo;
unsafe { core::arch::asm!("/* {} */", in(reg) func); }

let z = unsafe { core::arch::x86_64::_mm_set_epi64x(1, 0) };
unsafe { core::arch::asm!("/* {} */", in(xmm_reg) z); }
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>struct Foo;
let x: Foo = Foo;
// 구조체와 같은 복합 타입은 허용되지 않습니다.
unsafe { core::arch::asm!("/* {} */", in(reg) x); }
// 오류: 인라인 어셈블리에 `Foo` 타입의 값을 사용할 수 없습니다.
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.register-operands.supported-register-classes] Here is the list of currently supported register classes:</p>
<div class="table-wrapper"><table><thead><tr><th>아키텍처</th><th>레지스터 클래스</th><th>레지스터</th><th>LLVM 제약 코드</th></tr></thead><tbody>
<tr><td>x86</td><td><code>reg</code></td><td><code>ax</code>, <code>bx</code>, <code>cx</code>, <code>dx</code>, <code>si</code>, <code>di</code>, <code>bp</code>, <code>r[8-15]</code> (x86-64 전용)</td><td><code>r</code></td></tr>
<tr><td>x86</td><td><code>reg_abcd</code></td><td><code>ax</code>, <code>bx</code>, <code>cx</code>, <code>dx</code></td><td><code>Q</code></td></tr>
<tr><td>x86-32</td><td><code>reg_byte</code></td><td><code>al</code>, <code>bl</code>, <code>cl</code>, <code>dl</code>, <code>ah</code>, <code>bh</code>, <code>ch</code>, <code>dh</code></td><td><code>q</code></td></tr>
<tr><td>x86-64</td><td><code>reg_byte</code>*</td><td><code>al</code>, <code>bl</code>, <code>cl</code>, <code>dl</code>, <code>sil</code>, <code>dil</code>, <code>bpl</code>, <code>r[8-15]b</code></td><td><code>q</code></td></tr>
<tr><td>x86</td><td><code>xmm_reg</code></td><td><code>xmm[0-7]</code> (x86) <code>xmm[0-15]</code> (x86-64)</td><td><code>x</code></td></tr>
<tr><td>x86</td><td><code>ymm_reg</code></td><td><code>ymm[0-7]</code> (x86) <code>ymm[0-15]</code> (x86-64)</td><td><code>x</code></td></tr>
<tr><td>x86</td><td><code>zmm_reg</code></td><td><code>zmm[0-7]</code> (x86) <code>zmm[0-31]</code> (x86-64)</td><td><code>v</code></td></tr>
<tr><td>x86</td><td><code>kreg</code></td><td><code>k[1-7]</code></td><td><code>Yk</code></td></tr>
<tr><td>x86</td><td><code>kreg0</code></td><td><code>k0</code></td><td>클로버(clobbers) 전용</td></tr>
<tr><td>x86</td><td><code>x87_reg</code></td><td><code>st([0-7])</code></td><td>클로버(clobbers) 전용</td></tr>
<tr><td>x86</td><td><code>mmx_reg</code></td><td><code>mm[0-7]</code></td><td>클로버(clobbers) 전용</td></tr>
<tr><td>x86-64</td><td><code>tmm_reg</code></td><td><code>tmm[0-7]</code></td><td>클로버(clobbers) 전용</td></tr>
<tr><td>AArch64</td><td><code>reg</code></td><td><code>x[0-30]</code></td><td><code>r</code></td></tr>
<tr><td>AArch64</td><td><code>vreg</code></td><td><code>v[0-31]</code></td><td><code>w</code></td></tr>
<tr><td>AArch64</td><td><code>vreg_low16</code></td><td><code>v[0-15]</code></td><td><code>x</code></td></tr>
<tr><td>AArch64</td><td><code>preg</code></td><td><code>p[0-15]</code>, <code>ffr</code></td><td>클로버(clobbers) 전용</td></tr>
<tr><td>Arm64EC</td><td><code>reg</code></td><td><code>x[0-12]</code>, <code>x[15-22]</code>, <code>x[25-27]</code>, <code>x30</code></td><td><code>r</code></td></tr>
<tr><td>Arm64EC</td><td><code>vreg</code></td><td><code>v[0-15]</code></td><td><code>w</code></td></tr>
<tr><td>Arm64EC</td><td><code>vreg_low16</code></td><td><code>v[0-15]</code></td><td><code>x</code></td></tr>
<tr><td>ARM (ARM/Thumb2)</td><td><code>reg</code></td><td><code>r[0-12]</code>, <code>r14</code></td><td><code>r</code></td></tr>
<tr><td>ARM (Thumb1)</td><td><code>reg</code></td><td><code>r[0-7]</code></td><td><code>r</code></td></tr>
<tr><td>ARM</td><td><code>sreg</code></td><td><code>s[0-31]</code></td><td><code>t</code></td></tr>
<tr><td>ARM</td><td><code>sreg_low16</code></td><td><code>s[0-15]</code></td><td><code>x</code></td></tr>
<tr><td>ARM</td><td><code>dreg</code></td><td><code>d[0-31]</code></td><td><code>w</code></td></tr>
<tr><td>ARM</td><td><code>dreg_low16</code></td><td><code>d[0-15]</code></td><td><code>t</code></td></tr>
<tr><td>ARM</td><td><code>dreg_low8</code></td><td><code>d[0-8]</code></td><td><code>x</code></td></tr>
<tr><td>ARM</td><td><code>qreg</code></td><td><code>q[0-15]</code></td><td><code>w</code></td></tr>
<tr><td>ARM</td><td><code>qreg_low8</code></td><td><code>q[0-7]</code></td><td><code>t</code></td></tr>
<tr><td>ARM</td><td><code>qreg_low4</code></td><td><code>q[0-3]</code></td><td><code>x</code></td></tr>
<tr><td>RISC-V</td><td><code>reg</code></td><td><code>x1</code>, <code>x[5-7]</code>, <code>x[9-15]</code>, <code>x[16-31]</code> (non-RV32E)</td><td><code>r</code></td></tr>
<tr><td>RISC-V</td><td><code>freg</code></td><td><code>f[0-31]</code></td><td><code>f</code></td></tr>
<tr><td>RISC-V</td><td><code>vreg</code></td><td><code>v[0-31]</code></td><td>클로버(clobbers) 전용</td></tr>
<tr><td>LoongArch</td><td><code>reg</code></td><td><code>$r1</code>, <code>$r[4-20]</code>, <code>$r[23,30]</code></td><td><code>r</code></td></tr>
<tr><td>LoongArch</td><td><code>freg</code></td><td><code>$f[0-31]</code></td><td><code>f</code></td></tr>
<tr><td>s390x</td><td><code>reg</code></td><td><code>r[0-10]</code>, <code>r[12-14]</code></td><td><code>r</code></td></tr>
<tr><td>s390x</td><td><code>reg_addr</code></td><td><code>r[1-10]</code>, <code>r[12-14]</code></td><td><code>a</code></td></tr>
<tr><td>s390x</td><td><code>freg</code></td><td><code>f[0-15]</code></td><td><code>f</code></td></tr>
<tr><td>s390x</td><td><code>vreg</code></td><td><code>v[0-31]</code></td><td>클로버(clobbers) 전용</td></tr>
<tr><td>s390x</td><td><code>areg</code></td><td><code>a[2-15]</code></td><td>클로버(clobbers) 전용</td></tr>
</tbody></table>
</div>
<blockquote>
<p>[!NOTE]</p>
<ul>
<li>x86에서 <code>reg_byte</code>는 <code>reg</code>와 다르게 취급됩니다. 그 이유는 컴파일러가 <code>al</code>과 <code>ah</code>를 별도로 할당할 수 있는 반면, <code>reg</code>는 레지스터 전체를 예약하기 때문입니다.</li>
<li>x86-64에서 고위 바이트 레지스터(예: <code>ah</code>)는 <code>reg_byte</code> 레지스터 클래스에서 사용할 수 없습니다.</li>
<li>일부 레지스터 클래스는 “클로버 전용(Only clobbers)“으로 표시되어 있습니다. 이는 해당 클래스의 레지스터를 입력이나 출력에 사용할 수 없으며, 오직 <code>out(&lt;explicit register&gt;) _</code> 또는 <code>lateout(&lt;explicit register&gt;) _</code> 형식의 클로버로만 사용할 수 있음을 의미합니다.</li>
</ul>
</blockquote>
<p>r[asm.register-operands.value-type-constraints] Each register class has constraints on which value types they can be used with. This is necessary because the way a value is loaded into a register depends on its type. For example, on big-endian systems, loading a <code>i32x4</code> and a <code>i8x16</code> into a SIMD register may result in different register contents even if the byte-wise memory representation of both values is identical. The availability of supported types for a particular register class may depend on what target features are currently enabled.</p>
<div class="table-wrapper"><table><thead><tr><th>아키텍처</th><th>레지스터 클래스</th><th>타겟 기능</th><th>허용되는 타입</th></tr></thead><tbody>
<tr><td>x86-32</td><td><code>reg</code></td><td>없음</td><td><code>i16</code>, <code>i32</code>, <code>f32</code></td></tr>
<tr><td>x86-64</td><td><code>reg</code></td><td>없음</td><td><code>i16</code>, <code>i32</code>, <code>f32</code>, <code>i64</code>, <code>f64</code></td></tr>
<tr><td>x86</td><td><code>reg_byte</code></td><td>없음</td><td><code>i8</code></td></tr>
<tr><td>x86</td><td><code>xmm_reg</code></td><td><code>sse</code></td><td><code>i32</code>, <code>f32</code>, <code>i64</code>, <code>f64</code>, <br> <code>i8x16</code>, <code>i16x8</code>, <code>i32x4</code>, <code>i64x2</code>, <code>f32x4</code>, <code>f64x2</code></td></tr>
<tr><td>x86</td><td><code>ymm_reg</code></td><td><code>avx</code></td><td><code>i32</code>, <code>f32</code>, <code>i64</code>, <code>f64</code>, <br> <code>i8x16</code>, <code>i16x8</code>, <code>i32x4</code>, <code>i64x2</code>, <code>f32x4</code>, <code>f64x2</code> <br> <code>i8x32</code>, <code>i16x16</code>, <code>i32x8</code>, <code>i64x4</code>, <code>f32x8</code>, <code>f64x4</code></td></tr>
<tr><td>x86</td><td><code>zmm_reg</code></td><td><code>avx512f</code></td><td><code>i32</code>, <code>f32</code>, <code>i64</code>, <code>f64</code>, <br> <code>i8x16</code>, <code>i16x8</code>, <code>i32x4</code>, <code>i64x2</code>, <code>f32x4</code>, <code>f64x2</code> <br> <code>i8x32</code>, <code>i16x16</code>, <code>i32x8</code>, <code>i64x4</code>, <code>f32x8</code>, <code>f64x4</code> <br> <code>i8x64</code>, <code>i16x32</code>, <code>i32x16</code>, <code>i64x8</code>, <code>f32x16</code>, <code>f64x8</code></td></tr>
<tr><td>x86</td><td><code>kreg</code></td><td><code>avx512f</code></td><td><code>i8</code>, <code>i16</code></td></tr>
<tr><td>x86</td><td><code>kreg</code></td><td><code>avx512bw</code></td><td><code>i32</code>, <code>i64</code></td></tr>
<tr><td>x86</td><td><code>mmx_reg</code></td><td>해당 없음 (N/A)</td><td>클로버(clobbers) 전용</td></tr>
<tr><td>x86</td><td><code>x87_reg</code></td><td>해당 없음 (N/A)</td><td>클로버(clobbers) 전용</td></tr>
<tr><td>x86</td><td><code>tmm_reg</code></td><td>해당 없음 (N/A)</td><td>클로버(clobbers) 전용</td></tr>
<tr><td>AArch64</td><td><code>reg</code></td><td>없음</td><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>f32</code>, <code>i64</code>, <code>f64</code></td></tr>
<tr><td>AArch64</td><td><code>vreg</code></td><td><code>neon</code></td><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>f32</code>, <code>i64</code>, <code>f64</code>, <br> <code>i8x8</code>, <code>i16x4</code>, <code>i32x2</code>, <code>i64x1</code>, <code>f32x2</code>, <code>f64x1</code>, <br> <code>i8x16</code>, <code>i16x8</code>, <code>i32x4</code>, <code>i64x2</code>, <code>f32x4</code>, <code>f64x2</code></td></tr>
<tr><td>AArch64</td><td><code>preg</code></td><td>해당 없음 (N/A)</td><td>클로버(clobbers) 전용</td></tr>
<tr><td>Arm64EC</td><td><code>reg</code></td><td>없음</td><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>f32</code>, <code>i64</code>, <code>f64</code></td></tr>
<tr><td>Arm64EC</td><td><code>vreg</code></td><td><code>neon</code></td><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>f32</code>, <code>i64</code>, <code>f64</code>, <br> <code>i8x8</code>, <code>i16x4</code>, <code>i32x2</code>, <code>i64x1</code>, <code>f32x2</code>, <code>f64x1</code>, <br> <code>i8x16</code>, <code>i16x8</code>, <code>i32x4</code>, <code>i64x2</code>, <code>f32x4</code>, <code>f64x2</code></td></tr>
<tr><td>ARM</td><td><code>reg</code></td><td>없음</td><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>f32</code></td></tr>
<tr><td>ARM</td><td><code>sreg</code></td><td><code>vfp2</code></td><td><code>i32</code>, <code>f32</code></td></tr>
<tr><td>ARM</td><td><code>dreg</code></td><td><code>vfp2</code></td><td><code>i64</code>, <code>f64</code>, <code>i8x8</code>, <code>i16x4</code>, <code>i32x2</code>, <code>i64x1</code>, <code>f32x2</code></td></tr>
<tr><td>ARM</td><td><code>qreg</code></td><td><code>neon</code></td><td><code>i8x16</code>, <code>i16x8</code>, <code>i32x4</code>, <code>i64x2</code>, <code>f32x4</code></td></tr>
<tr><td>RISC-V32</td><td><code>reg</code></td><td>없음</td><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>f32</code></td></tr>
<tr><td>RISC-V64</td><td><code>reg</code></td><td>없음</td><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>f32</code>, <code>i64</code>, <code>f64</code></td></tr>
<tr><td>RISC-V</td><td><code>freg</code></td><td><code>f</code></td><td><code>f32</code></td></tr>
<tr><td>RISC-V</td><td><code>freg</code></td><td><code>d</code></td><td><code>f64</code></td></tr>
<tr><td>RISC-V</td><td><code>vreg</code></td><td>해당 없음 (N/A)</td><td>클로버(clobbers) 전용</td></tr>
<tr><td>LoongArch32</td><td><code>reg</code></td><td>없음</td><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>f32</code></td></tr>
<tr><td>LoongArch64</td><td><code>reg</code></td><td>없음</td><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>f32</code>, <code>f64</code></td></tr>
<tr><td>LoongArch</td><td><code>freg</code></td><td><code>f</code></td><td><code>f32</code></td></tr>
<tr><td>LoongArch</td><td><code>freg</code></td><td><code>d</code></td><td><code>f64</code></td></tr>
<tr><td>s390x</td><td><code>reg</code>, <code>reg_addr</code></td><td>없음</td><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code></td></tr>
<tr><td>s390x</td><td><code>freg</code></td><td>없음</td><td><code>f32</code>, <code>f64</code></td></tr>
<tr><td>s390x</td><td><code>vreg</code></td><td>해당 없음 (N/A)</td><td>클로버(clobbers) 전용</td></tr>
<tr><td>s390x</td><td><code>areg</code></td><td>해당 없음 (N/A)</td><td>클로버(clobbers) 전용</td></tr>
</tbody></table>
</div>
<blockquote>
<p>[!NOTE] For the purposes of the above table pointers, function pointers and <code>isize</code>/<code>usize</code> are treated as the equivalent integer type (<code>i16</code>/<code>i32</code>/<code>i64</code> depending on the target).</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let x = 5i32;
let y = -1i8;
let z = unsafe { core::arch::x86_64::_mm_set_epi64x(1, 0) };

// `reg`는 `i32`에 유효하고, `reg_byte`는 `i8`에 유효하며, `xmm_reg`는 `__m128i`에 유효합니다.
// `tmm0`는 입력이나 출력으로 사용할 수 없지만, 클로버(clobber)할 수는 있습니다.
unsafe { core::arch::asm!("/* {} {} {} */", in(reg) x, in(reg_byte) y, in(xmm_reg) z, out("tmm0") _); }
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let z = unsafe { core::arch::x86_64::_mm_set_epi64x(1, 0) };
// `__m128i`를 `reg` 입력으로 전달할 수 없습니다.
unsafe { core::arch::asm!("/* {} */", in(reg) z); }
// 오류: `__m128i` 타입은 이 레지스터 클래스에 사용할 수 없습니다.
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.register-operands.smaller-value] If a value is of a smaller size than the register it is allocated in then the upper bits of that register will have an undefined value for inputs and will be ignored for outputs. The only exception is the <code>freg</code> register class on RISC-V where <code>f32</code> values are NaN-boxed in a <code>f64</code> as required by the RISC-V architecture.</p>
<!--no_run, this test has a non-deterministic runtime behavior-->
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let mut x: i64;
// 32비트 값을 64비트 값으로 옮기기, 이런.
#[allow(asm_sub_register)] // rustc는 이 동작에 대해 경고합니다.
unsafe { core::arch::asm!("mov {}, {}", lateout(reg) x, in(reg) 4i32); }
// 상위 32비트는 불확정적입니다.
assert_eq!(x, 4); // 이 단언(assertion)은 성공이 보장되지 않습니다.
assert_eq!(x &amp; 0xFFFFFFFF, 4); // 하지만 이것은 성공할 것입니다.
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.register-operands.separate-input-output] When separate input and output expressions are specified for an <code>inout</code> operand, both expressions must have the same type. The only exception is if both operands are pointers or integers, in which case they are only required to have the same size. This restriction exists because the register allocators in LLVM and GCC sometimes cannot handle tied operands with different types.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>// 포인터와 정수는 (크기가 같다면) 혼용될 수 있습니다.
let x: isize = 0;
let y: *mut ();
// 인라인 어셈블리의 마법을 사용하여 `isize`를 `*mut ()`로 변환(transmute)합니다.
unsafe { core::arch::asm!("/*{}*/", inout(reg) x=&gt;y); }
assert!(y.is_null()); // 널 포인터를 만드는 지극히 우회적인 방법
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let x: i32 = 0;
let y: f32;
// 하지만 이런 식으로 `i32`를 `f32`로 재해석할 수는 없습니다.
unsafe { core::arch::asm!("/* {} */", inout(reg) x=&gt;y); }
// 오류: asm inout 인자의 타입이 호환되지 않습니다.
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.register-names]</p>
<h2 id="레지스터-이름"><a class="header" href="#레지스터-이름">레지스터 이름</a></h2>
<p>r[asm.register-names.supported-register-aliases] Some registers have multiple names. These are all treated by the compiler as identical to the base register name. Here is the list of all supported register aliases:</p>
<div class="table-wrapper"><table><thead><tr><th>아키텍처</th><th>기본 레지스터</th><th>별칭</th></tr></thead><tbody>
<tr><td>x86</td><td><code>ax</code></td><td><code>eax</code>, <code>rax</code></td></tr>
<tr><td>x86</td><td><code>bx</code></td><td><code>ebx</code>, <code>rbx</code></td></tr>
<tr><td>x86</td><td><code>cx</code></td><td><code>ecx</code>, <code>rcx</code></td></tr>
<tr><td>x86</td><td><code>dx</code></td><td><code>edx</code>, <code>rdx</code></td></tr>
<tr><td>x86</td><td><code>si</code></td><td><code>esi</code>, <code>rsi</code></td></tr>
<tr><td>x86</td><td><code>di</code></td><td><code>edi</code>, <code>rdi</code></td></tr>
<tr><td>x86</td><td><code>bp</code></td><td><code>bpl</code>, <code>ebp</code>, <code>rbp</code></td></tr>
<tr><td>x86</td><td><code>sp</code></td><td><code>spl</code>, <code>esp</code>, <code>rsp</code></td></tr>
<tr><td>x86</td><td><code>ip</code></td><td><code>eip</code>, <code>rip</code></td></tr>
<tr><td>x86</td><td><code>st(0)</code></td><td><code>st</code></td></tr>
<tr><td>x86</td><td><code>r[8-15]</code></td><td><code>r[8-15]b</code>, <code>r[8-15]w</code>, <code>r[8-15]d</code></td></tr>
<tr><td>x86</td><td><code>xmm[0-31]</code></td><td><code>ymm[0-31]</code>, <code>zmm[0-31]</code></td></tr>
<tr><td>AArch64</td><td><code>x[0-30]</code></td><td><code>w[0-30]</code></td></tr>
<tr><td>AArch64</td><td><code>x29</code></td><td><code>fp</code></td></tr>
<tr><td>AArch64</td><td><code>x30</code></td><td><code>lr</code></td></tr>
<tr><td>AArch64</td><td><code>sp</code></td><td><code>wsp</code></td></tr>
<tr><td>AArch64</td><td><code>xzr</code></td><td><code>wzr</code></td></tr>
<tr><td>AArch64</td><td><code>v[0-31]</code></td><td><code>b[0-31]</code>, <code>h[0-31]</code>, <code>s[0-31]</code>, <code>d[0-31]</code>, <code>q[0-31]</code></td></tr>
<tr><td>Arm64EC</td><td><code>x[0-30]</code></td><td><code>w[0-30]</code></td></tr>
<tr><td>Arm64EC</td><td><code>x29</code></td><td><code>fp</code></td></tr>
<tr><td>Arm64EC</td><td><code>x30</code></td><td><code>lr</code></td></tr>
<tr><td>Arm64EC</td><td><code>sp</code></td><td><code>wsp</code></td></tr>
<tr><td>Arm64EC</td><td><code>xzr</code></td><td><code>wzr</code></td></tr>
<tr><td>Arm64EC</td><td><code>v[0-15]</code></td><td><code>b[0-15]</code>, <code>h[0-15]</code>, <code>s[0-15]</code>, <code>d[0-15]</code>, <code>q[0-15]</code></td></tr>
<tr><td>ARM</td><td><code>r[0-3]</code></td><td><code>a[1-4]</code></td></tr>
<tr><td>ARM</td><td><code>r[4-9]</code></td><td><code>v[1-6]</code></td></tr>
<tr><td>ARM</td><td><code>r9</code></td><td><code>rfp</code></td></tr>
<tr><td>ARM</td><td><code>r10</code></td><td><code>sl</code></td></tr>
<tr><td>ARM</td><td><code>r11</code></td><td><code>fp</code></td></tr>
<tr><td>ARM</td><td><code>r12</code></td><td><code>ip</code></td></tr>
<tr><td>ARM</td><td><code>r13</code></td><td><code>sp</code></td></tr>
<tr><td>ARM</td><td><code>r14</code></td><td><code>lr</code></td></tr>
<tr><td>ARM</td><td><code>r15</code></td><td><code>pc</code></td></tr>
<tr><td>RISC-V</td><td><code>x0</code></td><td><code>zero</code></td></tr>
<tr><td>RISC-V</td><td><code>x1</code></td><td><code>ra</code></td></tr>
<tr><td>RISC-V</td><td><code>x2</code></td><td><code>sp</code></td></tr>
<tr><td>RISC-V</td><td><code>x3</code></td><td><code>gp</code></td></tr>
<tr><td>RISC-V</td><td><code>x4</code></td><td><code>tp</code></td></tr>
<tr><td>RISC-V</td><td><code>x[5-7]</code></td><td><code>t[0-2]</code></td></tr>
<tr><td>RISC-V</td><td><code>x8</code></td><td><code>fp</code>, <code>s0</code></td></tr>
<tr><td>RISC-V</td><td><code>x9</code></td><td><code>s1</code></td></tr>
<tr><td>RISC-V</td><td><code>x[10-17]</code></td><td><code>a[0-7]</code></td></tr>
<tr><td>RISC-V</td><td><code>x[18-27]</code></td><td><code>s[2-11]</code></td></tr>
<tr><td>RISC-V</td><td><code>x[28-31]</code></td><td><code>t[3-6]</code></td></tr>
<tr><td>RISC-V</td><td><code>f[0-7]</code></td><td><code>ft[0-7]</code></td></tr>
<tr><td>RISC-V</td><td><code>f[8-9]</code></td><td><code>fs[0-1]</code></td></tr>
<tr><td>RISC-V</td><td><code>f[10-17]</code></td><td><code>fa[0-7]</code></td></tr>
<tr><td>RISC-V</td><td><code>f[18-27]</code></td><td><code>fs[2-11]</code></td></tr>
<tr><td>RISC-V</td><td><code>f[28-31]</code></td><td><code>ft[8-11]</code></td></tr>
<tr><td>LoongArch</td><td><code>$r0</code></td><td><code>$zero</code></td></tr>
<tr><td>LoongArch</td><td><code>$r1</code></td><td><code>$ra</code></td></tr>
<tr><td>LoongArch</td><td><code>$r2</code></td><td><code>$tp</code></td></tr>
<tr><td>LoongArch</td><td><code>$r3</code></td><td><code>$sp</code></td></tr>
<tr><td>LoongArch</td><td><code>$r[4-11]</code></td><td><code>$a[0-7]</code></td></tr>
<tr><td>LoongArch</td><td><code>$r[12-20]</code></td><td><code>$t[0-8]</code></td></tr>
<tr><td>LoongArch</td><td><code>$r21</code></td><td></td></tr>
<tr><td>LoongArch</td><td><code>$r22</code></td><td><code>$fp</code>, <code>$s9</code></td></tr>
<tr><td>LoongArch</td><td><code>$r[23-31]</code></td><td><code>$s[0-8]</code></td></tr>
<tr><td>LoongArch</td><td><code>$f[0-7]</code></td><td><code>$fa[0-7]</code></td></tr>
<tr><td>LoongArch</td><td><code>$f[8-23]</code></td><td><code>$ft[0-15]</code></td></tr>
<tr><td>LoongArch</td><td><code>$f[24-31]</code></td><td><code>$fs[0-7]</code></td></tr>
</tbody></table>
</div>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let z = 0i64;
// rax는 eax 및 ax의 별칭입니다.
unsafe { core::arch::asm!("", in("rax") z); }
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.register-names.not-for-io] Some registers cannot be used for input or output operands:</p>
<div class="table-wrapper"><table><thead><tr><th>아키텍처</th><th>지원되지 않는 레지스터</th><th>이유</th></tr></thead><tbody>
<tr><td>모두</td><td><code>sp</code>, <code>r15</code> (s390x)</td><td>The stack pointer must be restored to its original value at the end of the assembly code or before jumping to a <code>label</code> block.</td></tr>
<tr><td>모두</td><td><code>bp</code> (x86), <code>x29</code> (AArch64 및 Arm64EC), <code>x8</code> (RISC-V), <code>$fp</code> (LoongArch), <code>r11</code> (s390x)</td><td>프레임 포인터(fp)는 입력 또는 출력으로 사용할 수 없습니다.</td></tr>
<tr><td>ARM</td><td><code>r7</code> 또는 <code>r11</code></td><td>ARM에서 프레임 포인터는 타겟에 따라 <code>r7</code> 또는 <code>r11</code>이 될 수 있습니다. 프레임 포인터는 입력 또는 출력으로 사용할 수 없습니다.</td></tr>
<tr><td>모두</td><td><code>si</code> (x86-32), <code>bx</code> (x86-64), <code>r6</code> (ARM), <code>x19</code> (AArch64 및 Arm64EC), <code>x9</code> (RISC-V), <code>$s8</code> (LoongArch)</td><td>이는 복잡한 스택 프레임을 가진 함수를 위해 LLVM에서 내부적으로 “베이스 포인터“로 사용됩니다.</td></tr>
<tr><td>x86</td><td><code>ip</code></td><td>이것은 프로그램 카운터(pc)이며, 실제 레지스터가 아닙니다.</td></tr>
<tr><td>AArch64</td><td><code>xzr</code></td><td>이것은 수정할 수 없는 상수 제로 레지스터입니다.</td></tr>
<tr><td>AArch64</td><td><code>x18</code></td><td>이는 일부 AArch64 타겟에서 OS가 예약한 레지스터입니다.</td></tr>
<tr><td>Arm64EC</td><td><code>xzr</code></td><td>이것은 수정할 수 없는 상수 제로 레지스터입니다.</td></tr>
<tr><td>Arm64EC</td><td><code>x18</code></td><td>이것은 OS가 예약한 레지스터입니다.</td></tr>
<tr><td>Arm64EC</td><td><code>x13</code>, <code>x14</code>, <code>x23</code>, <code>x24</code>, <code>x28</code>, <code>v[16-31]</code>, <code>p[0-15]</code>, <code>ffr</code></td><td>이들은 Arm64EC에서 지원되지 않는 AArch64 레지스터들입니다.</td></tr>
<tr><td>ARM</td><td><code>pc</code></td><td>이것은 프로그램 카운터(pc)이며, 실제 레지스터가 아닙니다.</td></tr>
<tr><td>ARM</td><td><code>r9</code></td><td>이는 일부 ARM 타겟에서 OS가 예약한 레지스터입니다.</td></tr>
<tr><td>RISC-V</td><td><code>x0</code></td><td>이것은 수정할 수 없는 상수 제로 레지스터입니다.</td></tr>
<tr><td>RISC-V</td><td><code>gp</code>, <code>tp</code></td><td>이 레지스터들은 예약되어 있으며 입력이나 출력으로 사용할 수 없습니다.</td></tr>
<tr><td>LoongArch</td><td><code>$r0</code> 또는 <code>$zero</code></td><td>이것은 수정할 수 없는 상수 제로 레지스터입니다.</td></tr>
<tr><td>LoongArch</td><td><code>$r2</code> 또는 <code>$tp</code></td><td>이는 TLS를 위해 예약되어 있습니다.</td></tr>
<tr><td>LoongArch</td><td><code>$r21</code></td><td>이는 ABI에 의해 예약되어 있습니다.</td></tr>
<tr><td>s390x</td><td><code>c[0-15]</code></td><td>커널에 의해 예약되어 있습니다.</td></tr>
<tr><td>s390x</td><td><code>a[0-1]</code></td><td>시스템 사용을 위해 예약되어 있습니다.</td></tr>
</tbody></table>
</div>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>// bp는 예약되어 있습니다.
unsafe { core::arch::asm!("", in("bp") 5i32); }
// 오류: 잘못된 레지스터 `bp`: 프레임 포인터는 인라인 asm의 피연산자로 사용할 수 없습니다.
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.register-names.fp-bp-reserved] The frame pointer and base pointer registers are reserved for internal use by LLVM. While <code>asm!</code> statements cannot explicitly specify the use of reserved registers, in some cases LLVM will allocate one of these reserved registers for <code>reg</code> operands. Assembly code making use of reserved registers should be careful since <code>reg</code> operands may use the same registers.</p>
<p>r[asm.template-modifiers]</p>
<h2 id="템플릿-수식어"><a class="header" href="#템플릿-수식어">템플릿 수식어</a></h2>
<p>r[asm.template-modifiers.intro] The placeholders can be augmented by modifiers which are specified after the <code>:</code> in the curly braces. These modifiers do not affect register allocation, but change the way operands are formatted when inserted into the template string.</p>
<p>r[asm.template-modifiers.only-one] Only one modifier is allowed per template placeholder.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>// `r`과 `e`를 동시에 지정할 수는 없습니다.
unsafe { core::arch::asm!("/* {:er}", in(reg) 5i32); }
// 오류: asm 템플릿 수식어는 단일 문자여야 합니다.
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.template-modifiers.supported-modifiers] The supported modifiers are a subset of LLVM’s (and GCC’s) <a href="http://llvm.org/docs/LangRef.html#asm-template-argument-modifiers">asm template argument modifiers</a>, but do not use the same letter codes.</p>
<div class="table-wrapper"><table><thead><tr><th>아키텍처</th><th>레지스터 클래스</th><th>수식어</th><th>출력 예시</th><th>LLVM 수식어</th></tr></thead><tbody>
<tr><td>x86-32</td><td><code>reg</code></td><td>없음</td><td><code>eax</code></td><td><code>k</code></td></tr>
<tr><td>x86-64</td><td><code>reg</code></td><td>없음</td><td><code>rax</code></td><td><code>q</code></td></tr>
<tr><td>x86-32</td><td><code>reg_abcd</code></td><td><code>l</code></td><td><code>al</code></td><td><code>b</code></td></tr>
<tr><td>x86-64</td><td><code>reg</code></td><td><code>l</code></td><td><code>al</code></td><td><code>b</code></td></tr>
<tr><td>x86</td><td><code>reg_abcd</code></td><td><code>h</code></td><td><code>ah</code></td><td><code>h</code></td></tr>
<tr><td>x86</td><td><code>reg</code></td><td><code>x</code></td><td><code>ax</code></td><td><code>w</code></td></tr>
<tr><td>x86</td><td><code>reg</code></td><td><code>e</code></td><td><code>eax</code></td><td><code>k</code></td></tr>
<tr><td>x86-64</td><td><code>reg</code></td><td><code>r</code></td><td><code>rax</code></td><td><code>q</code></td></tr>
<tr><td>x86</td><td><code>reg_byte</code></td><td>없음</td><td><code>al</code> / <code>ah</code></td><td>없음</td></tr>
<tr><td>x86</td><td><code>xmm_reg</code></td><td>없음</td><td><code>xmm0</code></td><td><code>x</code></td></tr>
<tr><td>x86</td><td><code>ymm_reg</code></td><td>없음</td><td><code>ymm0</code></td><td><code>t</code></td></tr>
<tr><td>x86</td><td><code>zmm_reg</code></td><td>없음</td><td><code>zmm0</code></td><td><code>g</code></td></tr>
<tr><td>x86</td><td><code>*mm_reg</code></td><td><code>x</code></td><td><code>xmm0</code></td><td><code>x</code></td></tr>
<tr><td>x86</td><td><code>*mm_reg</code></td><td><code>y</code></td><td><code>ymm0</code></td><td><code>t</code></td></tr>
<tr><td>x86</td><td><code>*mm_reg</code></td><td><code>z</code></td><td><code>zmm0</code></td><td><code>g</code></td></tr>
<tr><td>x86</td><td><code>kreg</code></td><td>없음</td><td><code>k1</code></td><td>없음</td></tr>
<tr><td>AArch64/Arm64EC</td><td><code>reg</code></td><td>없음</td><td><code>x0</code></td><td><code>x</code></td></tr>
<tr><td>AArch64/Arm64EC</td><td><code>reg</code></td><td><code>w</code></td><td><code>w0</code></td><td><code>w</code></td></tr>
<tr><td>AArch64/Arm64EC</td><td><code>reg</code></td><td><code>x</code></td><td><code>x0</code></td><td><code>x</code></td></tr>
<tr><td>AArch64/Arm64EC</td><td><code>vreg</code></td><td>없음</td><td><code>v0</code></td><td>없음</td></tr>
<tr><td>AArch64/Arm64EC</td><td><code>vreg</code></td><td><code>v</code></td><td><code>v0</code></td><td>없음</td></tr>
<tr><td>AArch64/Arm64EC</td><td><code>vreg</code></td><td><code>b</code></td><td><code>b0</code></td><td><code>b</code></td></tr>
<tr><td>AArch64/Arm64EC</td><td><code>vreg</code></td><td><code>h</code></td><td><code>h0</code></td><td><code>h</code></td></tr>
<tr><td>AArch64/Arm64EC</td><td><code>vreg</code></td><td><code>s</code></td><td><code>s0</code></td><td><code>s</code></td></tr>
<tr><td>AArch64/Arm64EC</td><td><code>vreg</code></td><td><code>d</code></td><td><code>d0</code></td><td><code>d</code></td></tr>
<tr><td>AArch64/Arm64EC</td><td><code>vreg</code></td><td><code>q</code></td><td><code>q0</code></td><td><code>q</code></td></tr>
<tr><td>ARM</td><td><code>reg</code></td><td>없음</td><td><code>r0</code></td><td>없음</td></tr>
<tr><td>ARM</td><td><code>sreg</code></td><td>없음</td><td><code>s0</code></td><td>없음</td></tr>
<tr><td>ARM</td><td><code>dreg</code></td><td>없음</td><td><code>d0</code></td><td><code>P</code></td></tr>
<tr><td>ARM</td><td><code>qreg</code></td><td>없음</td><td><code>q0</code></td><td><code>q</code></td></tr>
<tr><td>ARM</td><td><code>qreg</code></td><td><code>e</code> / <code>f</code></td><td><code>d0</code> / <code>d1</code></td><td><code>e</code> / <code>f</code></td></tr>
<tr><td>RISC-V</td><td><code>reg</code></td><td>없음</td><td><code>x1</code></td><td>없음</td></tr>
<tr><td>RISC-V</td><td><code>freg</code></td><td>없음</td><td><code>f0</code></td><td>없음</td></tr>
<tr><td>LoongArch</td><td><code>reg</code></td><td>없음</td><td><code>$r1</code></td><td>없음</td></tr>
<tr><td>LoongArch</td><td><code>freg</code></td><td>없음</td><td><code>$f0</code></td><td>없음</td></tr>
<tr><td>s390x</td><td><code>reg</code></td><td>없음</td><td><code>%r0</code></td><td>없음</td></tr>
<tr><td>s390x</td><td><code>reg_addr</code></td><td>없음</td><td><code>%r1</code></td><td>없음</td></tr>
<tr><td>s390x</td><td><code>freg</code></td><td>없음</td><td><code>%f0</code></td><td>없음</td></tr>
</tbody></table>
</div>
<blockquote>
<p>[!NOTE]</p>
<ul>
<li>ARM의 <code>e</code> / <code>f</code>: 이는 NEON 쿼드(128비트) 레지스터의 하위 또는 상위 더블워드(doubleword) 레지스터 이름을 출력합니다.</li>
<li>x86: 수식어가 없는 <code>reg</code>에 대한 우리의 동작은 GCC와 다릅니다. GCC는 피연산자 값 타입을 기반으로 수식어를 추론하지만, 우리는 기본적으로 전체 레지스터 크기를 사용합니다.</li>
<li>x86 <code>xmm_reg</code>: <code>x</code>, <code>t</code> 및 <code>g</code> LLVM 수식어는 아직 LLVM에 구현되지 않았지만(이들은 GCC에서만 지원됨), 이는 간단한 변경사항일 것입니다.</li>
</ul>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let mut x = 0x10u16;

// `xchg`를 사용한 u16::swap_bytes
// `{x}`의 하위 절반은 `{x:l}`로, 상위 절반은 `{x:h}`로 참조됩니다.
unsafe { core::arch::asm!("xchg {x:l}, {x:h}", x = inout(reg_abcd) x); }
assert_eq!(x, 0x1000u16);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.template-modifiers.smaller-value] As stated in the previous section, passing an input value smaller than the register width will result in the upper bits of the register containing undefined values. This is not a problem if the inline asm only accesses the lower bits of the register, which can be done by using a template modifier to use a subregister name in the assembly code (e.g. <code>ax</code> instead of <code>rax</code>). Since this an easy pitfall, the compiler will suggest a template modifier to use where appropriate given the input type. If all references to an operand already have modifiers then the warning is suppressed for that operand.</p>
<p>r[asm.abi-clobbers]</p>
<h2 id="abi-클로버clobbers"><a class="header" href="#abi-클로버clobbers">ABI 클로버(Clobbers)</a></h2>
<p>r[asm.abi-clobbers.intro] The <code>clobber_abi</code> keyword can be used to apply a default set of clobbers to the assembly code. This will automatically insert the necessary clobber constraints as needed for calling a function with a particular calling convention: if the calling convention does not fully preserve the value of a register across a call then <code>lateout("...") _</code> is implicitly added to the operands list (where the <code>...</code> is replaced by the register’s name).</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>extern "C" fn foo() -&gt; i32 { 0 }

let z: i32;
// 함수를 호출하려면, 피호출자 저장(callee saved) 레지스터를 클로버하고 있음을 컴파일러에 알려야 합니다.
unsafe { core::arch::asm!("call {}", sym foo, out("rax") z, clobber_abi("C")); }
assert_eq!(z, 0);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.abi-clobbers.many] <code>clobber_abi</code> may be specified any number of times. It will insert a clobber for all unique registers in the union of all specified calling conventions.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>extern "sysv64" fn foo() -&gt; i32 { 0 }
extern "win64" fn bar(x: i32) -&gt; i32 { x + 1}

let z: i32;
// 심지어 서로 다른 규약과 서로 다른 저장된 레지스터를 가진 여러 함수를 호출할 수도 있습니다.
unsafe {
    core::arch::asm!(
        "call {}",
        "mov ecx, eax",
        "call {}",
        sym foo,
        sym bar,
        out("rax") z,
        clobber_abi("C")
    );
}
assert_eq!(z, 1);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.abi-clobbers.must-specify] Generic register class outputs are disallowed by the compiler when <code>clobber_abi</code> is used: all outputs must specify an explicit register.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>extern "C" fn foo(x: i32) -&gt; i32 { 0 }

let z: i32;
// 실수로 겹치지 않도록 명시적 레지스터를 사용해야 합니다.
unsafe {
    core::arch::asm!(
        "mov eax, {:e}",
        "call {}",
        out(reg) z,
        sym foo,
        clobber_abi("C")
    );
    // 오류: `clobber_abi`를 사용하는 asm은 출력에 대해 명시적 레지스터를 지정해야 합니다.
}
assert_eq!(z, 0);
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.abi-clobbers.explicit-have-precedence] Explicit register outputs have precedence over the implicit clobbers inserted by <code>clobber_abi</code>: a clobber will only be inserted for a register if that register is not used as an output.</p>
<p>r[asm.abi-clobbers.supported-abis] The following ABIs can be used with <code>clobber_abi</code>:</p>
<div class="table-wrapper"><table><thead><tr><th>아키텍처</th><th>ABI 이름</th><th>클로버된 레지스터</th></tr></thead><tbody>
<tr><td>x86-32</td><td><code>"C"</code>, <code>"system"</code>, <code>"efiapi"</code>, <code>"cdecl"</code>, <code>"stdcall"</code>, <code>"fastcall"</code></td><td><code>ax</code>, <code>cx</code>, <code>dx</code>, <code>xmm[0-7]</code>, <code>mm[0-7]</code>, <code>k[0-7]</code>, <code>st([0-7])</code></td></tr>
<tr><td>x86-64</td><td><code>"C"</code>, <code>"system"</code> (윈도우 전용), <code>"efiapi"</code>, <code>"win64"</code></td><td><code>ax</code>, <code>cx</code>, <code>dx</code>, <code>r[8-11]</code>, <code>xmm[0-31]</code>, <code>mm[0-7]</code>, <code>k[0-7]</code>, <code>st([0-7])</code>, <code>tmm[0-7]</code></td></tr>
<tr><td>x86-64</td><td><code>"C"</code>, <code>"system"</code> (윈도우 제외), <code>"sysv64"</code></td><td><code>ax</code>, <code>cx</code>, <code>dx</code>, <code>si</code>, <code>di</code>, <code>r[8-11]</code>, <code>xmm[0-31]</code>, <code>mm[0-7]</code>, <code>k[0-7]</code>, <code>st([0-7])</code>, <code>tmm[0-7]</code></td></tr>
<tr><td>AArch64</td><td><code>"C"</code>, <code>"system"</code>, <code>"efiapi"</code></td><td><code>x[0-17]</code>, <code>x18</code>*, <code>x30</code>, <code>v[0-31]</code>, <code>p[0-15]</code>, <code>ffr</code></td></tr>
<tr><td>Arm64EC</td><td><code>"C"</code>, <code>"system"</code></td><td><code>x[0-12]</code>, <code>x[15-17]</code>, <code>x30</code>, <code>v[0-15]</code></td></tr>
<tr><td>ARM</td><td><code>"C"</code>, <code>"system"</code>, <code>"efiapi"</code>, <code>"aapcs"</code></td><td><code>r[0-3]</code>, <code>r12</code>, <code>r14</code>, <code>s[0-15]</code>, <code>d[0-7]</code>, <code>d[16-31]</code></td></tr>
<tr><td>RISC-V</td><td><code>"C"</code>, <code>"system"</code>, <code>"efiapi"</code></td><td><code>x1</code>, <code>x[5-7]</code>, <code>x[10-17]</code><em>, <code>x[28-31]</code></em>, <code>f[0-7]</code>, <code>f[10-17]</code>, <code>f[28-31]</code>, <code>v[0-31]</code></td></tr>
<tr><td>LoongArch</td><td><code>"C"</code>, <code>"system"</code></td><td><code>$r1</code>, <code>$r[4-20]</code>, <code>$f[0-23]</code></td></tr>
<tr><td>s390x</td><td><code>"C"</code>, <code>"system"</code></td><td><code>r[0-5]</code>, <code>r14</code>, <code>f[0-7]</code>, <code>v[0-31]</code>, <code>a[2-15]</code></td></tr>
</tbody></table>
</div>
<blockquote>
<p>[!NOTE]</p>
<ul>
<li>AArch64에서 <code>x18</code>은 타겟에서 예약된 레지스터로 간주되지 않는 경우에만 클로버 목록에 포함됩니다.</li>
<li>RISC-V에서 <code>x[16-17]</code> 및 <code>x[28-31]</code>은 타겟에서 예약된 레지스터로 간주되지 않는 경우에만 클로버 목록에 포함됩니다.</li>
</ul>
</blockquote>
<p>각 ABI에 대한 클로버된 레지스터 목록은 아키텍처에 새로운 레지스터가 추가됨에 따라 rustc에서 업데이트됩니다. 이는 LLVM이 생성된 코드에서 이러한 새로운 레지스터를 사용하기 시작할 때 <code>asm!</code> 클로버가 계속해서 올바르게 작동하도록 보장합니다.</p>
<p>r[asm.options]</p>
<h2 id="옵션"><a class="header" href="#옵션">옵션</a></h2>
<p>r[asm.options.supported-options] Flags are used to further influence the behavior of the inline assembly code. Currently the following options are defined:</p>
<p>r[asm.options.supported-options.pure]</p>
<ul>
<li><code>pure</code>: The assembly code has no side effects, must eventually return, and its outputs depend only on its direct inputs (i.e. the values themselves, not what they point to) or values read from memory (unless the <code>nomem</code> options is also set). This allows the compiler to execute the assembly code fewer times than specified in the program (e.g. by hoisting it out of a loop) or even eliminate it entirely if the outputs are not used. The <code>pure</code> option must be combined with either the <code>nomem</code> or <code>readonly</code> options, otherwise a compile-time error is emitted.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let x: i32 = 0;
let z: i32;
// `pure`는 어셈블리에 부작용이 없다고 가정하여 최적화하는 데 사용될 수 있습니다.
unsafe { core::arch::asm!("inc {}", inout(reg) x =&gt; z, options(pure, nomem)); }
assert_eq!(z, 1);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let x: i32 = 0;
let z: i32;
// 메모리 읽기 허용 여부를 나타내기 위해 nomem 또는 readonly 중 하나를 만족해야 합니다.
unsafe { core::arch::asm!("inc {}", inout(reg) x =&gt; z, options(pure)); }
// 오류: `pure` 옵션은 `nomem` 또는 `readonly` 중 하나와 결합되어야 합니다.
assert_eq!(z, 0);
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.options.supported-options.nomem]</p>
<ul>
<li><code>nomem</code>: The assembly code does not read from or write to any memory accessible outside of the assembly code. This allows the compiler to cache the values of modified global variables in registers across execution of the assembly code since it knows that they are not read from or written to by it. The compiler also assumes that the assembly code does not perform any kind of synchronization with other threads, e.g. via fences.</li>
</ul>
<!-- no_run: This test has unpredictable or undefined behavior at runtime -->
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let mut x = 0i32;
let z: i32;
// Accessing outside memory from assembly when `nomem` is
// specified is disallowed
unsafe {
    core::arch::asm!("mov {val:e}, dword ptr [{ptr}]",
        ptr = in(reg) &amp;mut x,
        val = lateout(reg) z,
        options(nomem)
    )
}

// Writing to outside memory from assembly when `nomem` is
// specified is also undefined behaviour
unsafe {
    core::arch::asm!("mov  dword ptr [{ptr}], {val:e}",
        ptr = in(reg) &amp;mut x,
        val = in(reg) z,
        options(nomem)
    )
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let x: i32 = 0;
let z: i32;
// 하지만 `push` 등을 통해 우리만의 메모리를 할당한다면
// 여전히 그것을 사용할 수 있습니다.
unsafe {
    core::arch::asm!("push {x}", "add qword ptr [rsp], 1", "pop {x}",
        x = inout(reg) x =&gt; z,
        options(nomem)
    );
}
assert_eq!(z, 1);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.options.supported-options.readonly]</p>
<ul>
<li><code>readonly</code>: The assembly code does not write to any memory accessible outside of the assembly code. This allows the compiler to cache the values of unmodified global variables in registers across execution of the assembly code since it knows that they are not written to by it. The compiler also assumes that this assembly code does not perform any kind of synchronization with other threads, e.g. via fences.</li>
</ul>
<!-- no_run: This test has undefined behaviour at runtime -->
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let mut x = 0;
// We cannot modify outside memory when `readonly` is specified
unsafe {
    core::arch::asm!("mov dword ptr[{}], 1", in(reg) &amp;mut x, options(readonly))
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let x: i64 = 0;
let z: i64;
// 하지만 여전히 읽을 수는 있습니다.
unsafe {
    core::arch::asm!("mov {x}, qword ptr [{x}]",
        x = inout(reg) &amp;x =&gt; z,
        options(readonly)
    );
}
assert_eq!(z, 0);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let x: i64 = 0;
let z: i64;
// nomem과 동일한 예외가 적용됩니다.
unsafe {
    core::arch::asm!("push {x}", "add qword ptr [rsp], 1", "pop {x}",
        x = inout(reg) x =&gt; z,
        options(readonly)
    );
}
assert_eq!(z, 1);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.options.supported-options.preserves_flags]</p>
<ul>
<li><code>preserves_flags</code>: The assembly code does not modify the flags register (defined in the rules below). This allows the compiler to avoid recomputing the condition flags after execution of the assembly code.</li>
</ul>
<p>r[asm.options.supported-options.noreturn]</p>
<ul>
<li><code>noreturn</code>: The assembly code does not fall through; behavior is undefined if it does. It may still jump to <code>label</code> blocks. If any <code>label</code> blocks return unit, the <code>asm!</code> block will return unit. Otherwise it will return <code>!</code> (never). As with a call to a function that does not return, local variables in scope are not dropped before execution of the assembly code.</li>
</ul>
<!-- no_run: This test aborts at runtime -->
<pre><pre class="playground"><code class="language-rust no_run edition2024">fn main() -&gt; ! {
<span class="boring">#[cfg(target_arch = "x86_64")] {
</span>    // noreturn 블록 내부에서 실행을 트랩(trap)하기 위해 명령어를 사용할 수 있습니다.
    unsafe { core::arch::asm!("ud2", options(noreturn)); }
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] panic!("no return");
</span>}</code></pre></pre>
<!-- no_run: Test has undefined behavior at runtime -->
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>// noreturn asm 블록의 끝을 지나치지 않도록 할 책임은 사용자에게 있습니다.
unsafe { core::arch::asm!("", options(noreturn)); }
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")]
</span>let _: () = unsafe {
    // You may still jump to a `label` block
    core::arch::asm!("jmp {}", label {
        println!();
    }, options(noreturn));
};
<span class="boring">}</span></code></pre></pre>
<p>r[asm.options.supported-options.nostack]</p>
<ul>
<li><code>nostack</code>: The assembly code does not push data to the stack, or write to the stack red-zone (if supported by the target). If this option is <em>not</em> used then the stack pointer is guaranteed by the compiler at the start of the assembly code to be suitably aligned (according to the target ABI) for a function call.</li>
</ul>
<!-- no_run: Test has undefined behavior at runtime -->
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>// nostack과 함께 `push` 및 `pop`을 사용하는 것은 정의되지 않은 동작(UB)입니다.
unsafe { core::arch::asm!("push rax", "pop rax", options(nostack)); }
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.options.supported-options.att_syntax]</p>
<ul>
<li><code>att_syntax</code>: 이 옵션은 x86에서만 유효하며, 어셈블러가 GNU 어셈블러의 <code>.att_syntax prefix</code> 모드를 사용하도록 합니다. 레지스터 피연산자는 앞에 <code>%</code>가 붙은 상태로 치환됩니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let x: i32;
let y = 1i32;
// 여기서는 AT&amp;T 구문을 사용해야 합니다. 피연산자 순서는 src, dest입니다.
unsafe {
    core::arch::asm!("mov {y:e}, {x:e}",
        x = lateout(reg) x,
        y = in(reg) y,
        options(att_syntax)
    );
}
assert_eq!(x, y);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.options.supported-options.raw]</p>
<ul>
<li><code>raw</code>: 템플릿 문자열을 원시 어셈블리 문자열로 파싱하게 하며, <code>{</code> 및 <code>}</code>에 대한 특별한 처리를 하지 않습니다. 이는 주로 <code>include_str!</code>을 사용하여 외부 파일에서 원시 어셈블리 코드를 포함할 때 유용합니다.</li>
</ul>
<p>r[asm.options.checks] The compiler performs some additional checks on options:</p>
<p>r[asm.options.checks.mutually-exclusive]</p>
<ul>
<li><code>nomem</code>과 <code>readonly</code> 옵션은 상호 배타적입니다. 두 옵션을 모두 지정하는 것은 컴파일 타임 오류입니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>// nomem은 readonly보다 엄격하게 강력하므로 함께 지정할 수 없습니다.
unsafe { core::arch::asm!("", options(nomem, readonly)); }
// 오류: `nomem`과 `readonly` 옵션은 상호 배타적입니다.
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.options.checks.pure]</p>
<ul>
<li><code>pure</code>를 출력이 없거나 버려지는 출력(<code>_</code>)만 있는 asm 블록에 지정하는 것은 컴파일 타임 오류입니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>// pure 블록은 최소 하나 이상의 출력이 필요합니다.
unsafe { core::arch::asm!("", options(pure)); }
// 오류: `pure` 옵션을 사용하는 asm은 최소 하나 이상의 출력이 있어야 합니다.
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.options.checks.noreturn]</p>
<ul>
<li>It is a compile-time error to specify <code>noreturn</code> on an asm block with outputs and without labels.</li>
</ul>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let z: i32;
// noreturn은 출력을 가질 수 없습니다.
unsafe { core::arch::asm!("mov {:e}, 1", out(reg) z, options(noreturn)); }
// 오류: `noreturn` 옵션에서는 asm 출력이 허용되지 않습니다.
<span class="boring">}
</span><span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.options.checks.label-with-outputs]</p>
<ul>
<li>It is a compile-time error to have any <code>label</code> blocks in an asm block with outputs.</li>
</ul>
<p>r[asm.options.naked_asm-restriction] <code>naked_asm!</code> only supports the <code>att_syntax</code> and <code>raw</code> options. The remaining options are not meaningful because the inline assembly defines the whole function body.</p>
<p>r[asm.options.global_asm-restriction] <code>global_asm!</code> only supports the <code>att_syntax</code> and <code>raw</code> options. The remaining options are not meaningful for global-scope inline assembly.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">fn main() {}
</span><span class="boring">#[cfg(target_arch = "x86_64")]
</span>// global_asm!에서 nomem은 무의미합니다.
core::arch::global_asm!("", options(nomem));
<span class="boring">#[cfg(not(target_arch = "x86_64"))] core::compile_error!("이 아키텍처에서는 테스트가 지원되지 않습니다");</span></code></pre></pre>
<p>r[asm.rules]</p>
<h2 id="인라인-어셈블리-규칙"><a class="header" href="#인라인-어셈블리-규칙">인라인 어셈블리 규칙</a></h2>
<p>r[asm.rules.intro] To avoid undefined behavior, these rules must be followed when using function-scope inline assembly (<code>asm!</code>):</p>
<p>r[asm.rules.reg-not-input]</p>
<ul>
<li>Any registers not specified as inputs will contain an undefined value on entry to the assembly code.
<ul>
<li>인라인 어셈블리 문맥에서 “정의되지 않은 값“이란, 해당 레지스터가 아키텍처에서 허용하는 가능한 값들 중 하나를 (비결정적으로) 가질 수 있음을 의미합니다. 특히 이는 읽을 때마다 값이 달라질 수 있는 LLVM의 <code>undef</code>와는 다릅니다(어셈블리 코드에는 그러한 개념이 존재하지 않기 때문입니다).</li>
</ul>
</li>
</ul>
<p>r[asm.rules.reg-not-output]</p>
<ul>
<li>Any registers not specified as outputs must have the same value upon exiting the assembly code as they had on entry, otherwise behavior is undefined.
<ul>
<li>이는 입력 또는 출력으로 지정될 수 있는 레지스터에만 적용됩니다. 다른 레지스터들은 타겟별 규칙을 따릅니다.</li>
<li><code>lateout</code>이 <code>in</code>과 동일한 레지스터에 할당될 수 있으며, 이 경우 이 규칙은 적용되지 않음에 유의하십시오. 하지만 이는 레지스터 할당 결과에 의존하므로 코드가 이에 의존해서는 안 됩니다.</li>
</ul>
</li>
</ul>
<p>r[asm.rules.unwind]</p>
<ul>
<li>Behavior is undefined if execution unwinds out of the assembly code.
<ul>
<li>어셈블리 코드가 호출한 함수가 언와인드되는 경우에도 마찬가지로 적용됩니다.</li>
</ul>
</li>
</ul>
<p>r[asm.rules.mem-same-as-ffi]</p>
<ul>
<li>어셈블리 코드가 읽고 쓸 수 있도록 허용된 메모리 위치의 집합은 FFI 함수에 허용된 것과 동일합니다.
<ul>
<li>만약 <code>readonly</code> 옵션이 설정되어 있다면, 메모리 읽기만 허용됩니다.</li>
<li>만약 <code>nomem</code> 옵션이 설정되어 있다면, 메모리에 대한 어떠한 읽기나 쓰기도 허용되지 않습니다.</li>
<li>These rules do not apply to memory which is private to the assembly code, such as stack space allocated within it.</li>
</ul>
</li>
</ul>
<p>r[asm.rules.black-box]</p>
<ul>
<li>The compiler cannot assume that the instructions in the assembly code are the ones that will actually end up executed.
<ul>
<li>This effectively means that the compiler must treat the assembly code as a black box and only take the interface specification into account, not the instructions themselves.</li>
<li>런타임 코드 패칭(patching)은 타겟별 메커니즘을 통해 허용됩니다.</li>
<li>However there is no guarantee that each block of assembly code in the source directly corresponds to a single instance of instructions in the object file; the compiler is free to duplicate or deduplicate the assembly code in <code>asm!</code> blocks.</li>
</ul>
</li>
</ul>
<p>r[asm.rules.stack-below-sp]</p>
<ul>
<li>Unless the <code>nostack</code> option is set, assembly code is allowed to use stack space below the stack pointer.
<ul>
<li>On entry to the assembly code the stack pointer is guaranteed to be suitably aligned (according to the target ABI) for a function call.</li>
<li>스택 오버플로가 발생하지 않도록 할 책임은 사용자에게 있습니다(예: 가드 페이지에 도달하도록 스택 프로빙(stack probing) 사용).</li>
<li>타겟 ABI의 요구에 따라 스택 메모리를 할당할 때는 스택 포인터를 조정해야 합니다.</li>
<li>The stack pointer must be restored to its original value before leaving the assembly code.</li>
</ul>
</li>
</ul>
<p>r[asm.rules.noreturn]</p>
<ul>
<li>If the <code>noreturn</code> option is set then behavior is undefined if execution falls through the end of the assembly code.</li>
</ul>
<p>r[asm.rules.pure]</p>
<ul>
<li><code>pure</code> 옵션이 설정된 경우, <code>asm!</code>이 직접적인 출력 이외의 부작용을 가지면 동작은 정의되지 않습니다. 또한 동일한 입력에 대해 두 번의 <code>asm!</code> 실행이 서로 다른 출력을 내는 경우에도 동작은 정의되지 않습니다.
<ul>
<li><code>nomem</code> 옵션과 함께 사용될 때, “입력“은 오직 <code>asm!</code>의 직접적인 입력만을 의미합니다.</li>
<li>When used with the <code>readonly</code> option, “inputs” comprise the direct inputs of the assembly code and any memory that it is allowed to read.</li>
</ul>
</li>
</ul>
<p>r[asm.rules.preserved-registers]</p>
<ul>
<li>These flags registers must be restored upon exiting the assembly code if the <code>preserves_flags</code> option is set:
<ul>
<li>x86
<ul>
<li><code>EFLAGS</code>의 상태 플래그 (CF, PF, AF, ZF, SF, OF).</li>
<li>부동 소수점 상태 워드 (전체).</li>
<li><code>MXCSR</code>의 부동 소수점 예외 플래그 (PE, UE, OE, ZE, DE, IE).</li>
</ul>
</li>
<li>ARM
<ul>
<li><code>CPSR</code>의 조건 플래그 (N, Z, C, V)</li>
<li><code>CPSR</code>의 포화(Saturation) 플래그 (Q)</li>
<li><code>CPSR</code>의 크거나 같음(Greater than or equal) 플래그 (GE).</li>
<li><code>FPSCR</code>의 조건 플래그 (N, Z, C, V)</li>
<li><code>FPSCR</code>의 포화(Saturation) 플래그 (QC)</li>
<li><code>FPSCR</code>의 부동 소수점 예외 플래그 (IDC, IXC, UFC, OFC, DZC, IOC).</li>
</ul>
</li>
<li>AArch64 및 Arm64EC
<ul>
<li>조건 플래그 (<code>NZCV</code> 레지스터).</li>
<li>부동 소수점 상태 (<code>FPSR</code> 레지스터).</li>
</ul>
</li>
<li>RISC-V
<ul>
<li><code>fcsr</code>의 부동 소수점 예외 플래그 (<code>fflags</code>).</li>
<li>Vector extension state (<code>vtype</code>, <code>vl</code>, <code>vxsat</code>, and <code>vxrm</code>).</li>
</ul>
</li>
<li>LoongArch
<ul>
<li><code>$fcc[0-7]</code>의 부동 소수점 조건 플래그.</li>
</ul>
</li>
<li>s390x
<ul>
<li>조건 코드 레지스터 <code>cc</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>r[asm.rules.x86-df]</p>
<ul>
<li>On x86, the direction flag (DF in <code>EFLAGS</code>) is clear on entry to the assembly code and must be clear on exit.
<ul>
<li>Behavior is undefined if the direction flag is set on exiting the assembly code.</li>
</ul>
</li>
</ul>
<p>r[asm.rules.x86-x87]</p>
<ul>
<li>x86에서, 모든 <code>st([0-7])</code> 레지스터들이 <code>out("st(0)") _, out("st(1)") _, ...</code>와 같이 클로버된 것으로 표시되지 않는 한, x87 부동 소수점 레지스터 스택은 변경되지 않은 상태로 유지되어야 합니다.
<ul>
<li>If all x87 registers are clobbered then the x87 register stack is guaranteed to be empty upon entering the assembly code. Assembly code must ensure that the x87 register stack is also empty when exiting the assembly code.</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#[cfg(target_arch = "x86_64")]
</span>pub fn fadd(x: f64, y: f64) -&gt; f64 {
  let mut out = 0f64;
  let mut top = 0u16;
  // 전체 x87 스택을 클로버하면 x87로 복잡한 작업을 수행할 수 있습니다.
  unsafe { core::arch::asm!(
    "fld qword ptr [{x}]",
    "fld qword ptr [{y}])",
    "faddp",
    "fstp qword ptr [{out}]",
    "xor eax, eax",
    "fstsw ax",
    "shl eax, 11",
    x = in(reg) &amp;x,
    y = in(reg) &amp;y,
    out = in(reg) &amp;mut out,
    out("st(0)") _, out("st(1)") _, out("st(2)") _, out("st(3)") _,
    out("st(4)") _, out("st(5)") _, out("st(6)") _, out("st(7)") _,
    out("eax") top
  );}

  assert_eq!(top &amp; 0x7, 0);
  out
}

pub fn main() {
<span class="boring">#[cfg(target_arch = "x86_64")]{
</span>  assert_eq!(fadd(1.0, 1.0), 2.0);
<span class="boring">}
</span>}</code></pre></pre>
<p>r[asm.rules.arm64ec]</p>
<ul>
<li>arm64ec에서는 함수를 호출할 때 <a href="https://learn.microsoft.com/en-us/windows/arm/arm64ec-abi#authoring-arm64ec-in-assembly">적절한 펑크(thunks)가 있는 호출 검사기(call checkers)</a>가 필수입니다.</li>
</ul>
<p>r[asm.rules.only-on-exit]</p>
<ul>
<li>The requirement of restoring the stack pointer and non-output registers to their original value only applies when exiting the assembly code.
<ul>
<li>This means that assembly code that does not fall through and does not jump to any <code>label</code> blocks, even if not marked <code>noreturn</code>, doesn’t need to preserve these registers.</li>
<li>When returning to the assembly code of a different <code>asm!</code> block than you entered (e.g. for context switching), these registers must contain the value they had upon entering the <code>asm!</code> block that you are <em>exiting</em>.
<ul>
<li>You cannot exit the assembly code of an <code>asm!</code> block that has not been entered. Neither can you exit the assembly code of an <code>asm!</code> block whose assembly code has already been exited (without first entering it again).</li>
<li>모든 타겟별 상태(예: 스레드 로컬 저장소, 스택 바운드)를 전환할 책임은 사용자에게 있습니다.</li>
<li>동일한 함수나 블록 내일지라도, 서로 다른 두 <code>asm!</code> 블록 사이를 점프할 때는 그 문맥(context)이 잠재적으로 다를 수 있음을 고려하고 문맥 전환(context switching)을 수행해야 합니다. 두 <code>asm!</code> 블록 사이에서 특정 문맥 값(예: 현재 스택 포인터 또는 스택 포인터 아래의 임시 값)이 변하지 않은 상태로 유지될 것이라고 가정할 수 없습니다.</li>
<li>접근할 수 있는 메모리 위치의 집합은 진입한 <code>asm!</code> 블록과 나가는 <code>asm!</code> 블록에서 허용된 위치들의 교집합입니다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>r[asm.rules.not-successive]</p>
<ul>
<li>소스 코드상에서 인접한 두 <code>asm!</code> 블록이 사이에 다른 코드가 없더라도, 바이너리 상에서 사이에 다른 명령어 없이 연속된 주소에 위치할 것이라고 가정할 수 없습니다.</li>
</ul>
<p>r[asm.rules.not-exactly-once]</p>
<ul>
<li><code>asm!</code> 블록이 출력 바이너리에 정확히 한 번 나타날 것이라고 가정할 수 없습니다. 컴파일러는 <code>asm!</code> 블록을 포함하는 함수가 여러 곳에 인라인되는 경우와 같이 <code>asm!</code> 블록의 여러 복사본을 인스턴스화할 수 있습니다.</li>
</ul>
<p>r[asm.rules.x86-prefix-restriction]</p>
<ul>
<li>x86에서, 인라인 어셈블리는 컴파일러가 생성한 명령어에 적용될 수 있는 명령어 접두사(예: <code>LOCK</code>)로 끝나서는 안 됩니다.
<ul>
<li>현재 컴파일러는 인라인 어셈블리가 컴파일되는 방식 때문에 이를 감지할 수 없지만, 향후에는 이를 포착하여 거부할 수 있습니다.</li>
</ul>
</li>
</ul>
<p>r[asm.rules.preserves_flags]</p>
<blockquote>
<p>[!NOTE] As a general rule, the flags covered by <code>preserves_flags</code> are those which are <em>not</em> preserved when performing a function call.</p>
</blockquote>
<p>r[asm.naked-rules]</p>
<h2 id="rules-for-naked-inline-assembly"><a class="header" href="#rules-for-naked-inline-assembly">Rules for naked inline assembly</a></h2>
<p>r[asm.naked-rules.intro] To avoid undefined behavior, these rules must be followed when using function-scope inline assembly in naked functions (<code>naked_asm!</code>):</p>
<p>r[asm.naked-rules.reg-not-input]</p>
<ul>
<li>Any registers not used for function inputs according to the calling convention and function signature will contain an undefined value on entry to the <code>naked_asm!</code> block.
<ul>
<li>인라인 어셈블리 문맥에서 “정의되지 않은 값“이란, 해당 레지스터가 아키텍처에서 허용하는 가능한 값들 중 하나를 (비결정적으로) 가질 수 있음을 의미합니다. 특히 이는 읽을 때마다 값이 달라질 수 있는 LLVM의 <code>undef</code>와는 다릅니다(어셈블리 코드에는 그러한 개념이 존재하지 않기 때문입니다).</li>
</ul>
</li>
</ul>
<p>r[asm.naked-rules.callee-saved-registers]</p>
<ul>
<li>All callee-saved registers must have the same value upon return as they had on entry.</li>
</ul>
<p>r[asm.naked-rules.caller-saved-registers]</p>
<ul>
<li>Caller-saved registers may be used freely.</li>
</ul>
<p>r[asm.naked-rules.noreturn]</p>
<ul>
<li>Behavior is undefined if execution falls through past the end of the assembly code.
<ul>
<li>Every path through the assembly code is expected to terminate with a return instruction or to diverge.</li>
</ul>
</li>
</ul>
<p>r[asm.naked-rules.mem-same-as-ffi]</p>
<ul>
<li>어셈블리 코드가 읽고 쓸 수 있도록 허용된 메모리 위치의 집합은 FFI 함수에 허용된 것과 동일합니다.</li>
</ul>
<p>r[asm.naked-rules.black-box]</p>
<ul>
<li>The compiler cannot assume that the instructions in the <code>naked_asm!</code> block are the ones that will actually be executed.
<ul>
<li>This effectively means that the compiler must treat the <code>naked_asm!</code> as a black box and only take the interface specification into account, not the instructions themselves.</li>
<li>런타임 코드 패칭(patching)은 타겟별 메커니즘을 통해 허용됩니다.</li>
</ul>
</li>
</ul>
<p>r[asm.naked-rules.unwind]</p>
<ul>
<li>Unwinding out of a <code>naked_asm!</code> block is allowed.
<ul>
<li>For correct behavior, the appropriate assembler directives that emit unwinding metadata must be used.</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>#[unsafe(naked)]
extern "sysv64-unwind" fn unwinding_naked() {
    core::arch::naked_asm!(
        // "CFI" here stands for "call frame information".
        ".cfi_startproc",
        // The CFA (canonical frame address) is the value of `rsp`
        // before the `call`, i.e. before the return address, `rip`,
        // was pushed to `rsp`, so it's eight bytes higher in memory
        // than `rsp` upon function entry (after `rip` has been
        // pushed).
        //
        // This is the default, so we don't have to write it.
        //".cfi_def_cfa rsp, 8",
        //
        // The traditional thing to do is to preserve the base
        // pointer, so we'll do that.
        "push rbp",
        // Since we've now extended the stack downward by 8 bytes in
        // memory, we need to adjust the offset to the CFA from `rsp`
        // by another 8 bytes.
        ".cfi_adjust_cfa_offset 8",
        // We also then annotate where we've stored the caller's value
        // of `rbp`, relative to the CFA, so that when unwinding into
        // the caller we can find it, in case we need it to calculate
        // the caller's CFA relative to it.
        //
        // Here, we've stored the caller's `rbp` starting 16 bytes
        // below the CFA.  I.e., starting from the CFA, there's first
        // the `rip` (which starts 8 bytes below the CFA and continues
        // up to it), then there's the caller's `rbp` that we just
        // pushed.
        ".cfi_offset rbp, -16",
        // As is traditional, we set the base pointer to the value of
        // the stack pointer.  This way, the base pointer stays the
        // same throughout the function body.
        "mov rbp, rsp",
        // We can now track the offset to the CFA from the base
        // pointer.  This means we don't need to make any further
        // adjustments until the end, as we don't change `rbp`.
        ".cfi_def_cfa_register rbp",
        // We can now call a function that may panic.
        "call {f}",
        // Upon return, we restore `rbp` in preparation for returning
        // ourselves.
        "pop rbp",
        // Now that we've restored `rbp`, we must specify the offset
        // to the CFA again in terms of `rsp`.
        ".cfi_def_cfa rsp, 8",
        // Now we can return.
        "ret",
        ".cfi_endproc",
        f = sym may_panic,
    )
}

extern "sysv64-unwind" fn may_panic() {
    panic!("unwind");
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE]</p>
<p>For more information on the <code>cfi</code> assembler directives above, see these resources:</p>
<ul>
<li><a href="https://sourceware.org/binutils/docs/as/CFI-directives.html">Using <code>as</code> - CFI directives</a></li>
<li><a href="https://dwarfstd.org/doc/DWARF5.pdf">DWARF Debugging Information Format Version 5</a></li>
<li><a href="https://www.imperialviolet.org/2017/01/18/cfi.html">ImperialViolet - CFI directives in assembly files</a></li>
</ul>
</blockquote>
<p>r[asm.validity]</p>
<h3 id="correctness-and-validity"><a class="header" href="#correctness-and-validity">Correctness and validity</a></h3>
<p>r[asm.validity.necessary-but-not-sufficient] In addition to all of the previous rules, the string argument to <code>asm!</code> must ultimately become— after all other arguments are evaluated, formatting is performed, and operands are translated— assembly that is both syntactically correct and semantically valid for the target architecture. The formatting rules allow the compiler to generate assembly with correct syntax. Rules concerning operands permit valid translation of Rust operands into and out of the assembly code. Adherence to these rules is necessary, but not sufficient, for the final expanded assembly to be both correct and valid. For instance:</p>
<ul>
<li>인자들이 포맷팅된 후 구문적으로 잘못된 위치에 배치될 수 있습니다.</li>
<li>명령어는 올바르게 작성되었으나 아키텍처적으로 유효하지 않은 피연산자가 제공될 수 있습니다.</li>
<li>아키텍처적으로 명시되지 않은 명령어가 명시되지 않은 코드로 어셈블될 수 있습니다.</li>
<li>각각은 정확하고 유효한 명령어 집합일지라도, 연달아 배치될 경우 정의되지 않은 동작을 초래할 수 있습니다.</li>
</ul>
<p>r[asm.validity.non-exhaustive] As a result, these rules are <em>non-exhaustive</em>. The compiler is not required to check the correctness and validity of the initial string nor the final assembly that is generated. The assembler may check for correctness and validity but is not required to do so. When using <code>asm!</code>, a typographical error may be sufficient to make a program unsound, and the rules for assembly may include thousands of pages of architectural reference manuals. Programmers should exercise appropriate care, as invoking this <code>unsafe</code> capability comes with assuming the responsibility of not violating rules of both the compiler or the architecture.</p>
<p>r[asm.directives]</p>
<h3 id="directives-support"><a class="header" href="#directives-support">Directives support</a></h3>
<p>r[asm.directives.subset-supported] Inline assembly supports a subset of the directives supported by both GNU AS and LLVM’s internal assembler, given as follows. The result of using other directives is assembler-specific (and may cause an error, or may be accepted as-is).</p>
<p>r[asm.directives.stateful] If inline assembly includes any “stateful” directive that modifies how subsequent assembly is processed, the assembly code must undo the effects of any such directives before the inline assembly ends.</p>
<p>r[asm.directives.supported-directives] The following directives are guaranteed to be supported by the assembler:</p>
<ul>
<li><code>.2byte</code></li>
<li><code>.4byte</code></li>
<li><code>.8byte</code></li>
<li><code>.align</code></li>
<li><code>.alt_entry</code></li>
<li><code>.ascii</code></li>
<li><code>.asciz</code></li>
<li><code>.balign</code></li>
<li><code>.balignl</code></li>
<li><code>.balignw</code></li>
<li><code>.bss</code></li>
<li><code>.byte</code></li>
<li><code>.comm</code></li>
<li><code>.data</code></li>
<li><code>.def</code></li>
<li><code>.double</code></li>
<li><code>.endef</code></li>
<li><code>.equ</code></li>
<li><code>.equiv</code></li>
<li><code>.eqv</code></li>
<li><code>.fill</code></li>
<li><code>.float</code></li>
<li><code>.global</code></li>
<li><code>.globl</code></li>
<li><code>.inst</code></li>
<li><code>.insn</code></li>
<li><code>.lcomm</code></li>
<li><code>.long</code></li>
<li><code>.octa</code></li>
<li><code>.option</code></li>
<li><code>.p2align</code></li>
<li><code>.popsection</code></li>
<li><code>.private_extern</code></li>
<li><code>.pushsection</code></li>
<li><code>.quad</code></li>
<li><code>.scl</code></li>
<li><code>.section</code></li>
<li><code>.set</code></li>
<li><code>.short</code></li>
<li><code>.size</code></li>
<li><code>.skip</code></li>
<li><code>.sleb128</code></li>
<li><code>.space</code></li>
<li><code>.string</code></li>
<li><code>.text</code></li>
<li><code>.type</code></li>
<li><code>.uleb128</code></li>
<li><code>.word</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_arch = "x86_64")] {
</span>let bytes: *const u8;
let len: usize;
unsafe {
    core::arch::asm!(
        "jmp 3f", "2: .ascii \"Hello World!\"",
        "3: lea {bytes}, [2b+rip]",
        "mov {len}, 12",
        bytes = out(reg) bytes,
        len = out(reg) len
    );
}

let s = unsafe { core::str::from_utf8_unchecked(core::slice::from_raw_parts(bytes, len)) };

assert_eq!(s, "Hello World!");
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>r[asm.target-specific-directives]</p>
<h4 id="target-specific-directive-support"><a class="header" href="#target-specific-directive-support">Target specific directive support</a></h4>
<p>r[asm.target-specific-directives.dwarf-unwinding]</p>
<h5 id="dwarf-unwinding"><a class="header" href="#dwarf-unwinding">Dwarf unwinding</a></h5>
<p>DWARF 언와인딩 정보를 지원하는 ELF 타겟에서 다음 지시어들이 지원됩니다:</p>
<ul>
<li><code>.cfi_adjust_cfa_offset</code></li>
<li><code>.cfi_def_cfa</code></li>
<li><code>.cfi_def_cfa_offset</code></li>
<li><code>.cfi_def_cfa_register</code></li>
<li><code>.cfi_endproc</code></li>
<li><code>.cfi_escape</code></li>
<li><code>.cfi_lsda</code></li>
<li><code>.cfi_offset</code></li>
<li><code>.cfi_personality</code></li>
<li><code>.cfi_register</code></li>
<li><code>.cfi_rel_offset</code></li>
<li><code>.cfi_remember_state</code></li>
<li><code>.cfi_restore</code></li>
<li><code>.cfi_restore_state</code></li>
<li><code>.cfi_return_column</code></li>
<li><code>.cfi_same_value</code></li>
<li><code>.cfi_sections</code></li>
<li><code>.cfi_signal_frame</code></li>
<li><code>.cfi_startproc</code></li>
<li><code>.cfi_undefined</code></li>
<li><code>.cfi_window_save</code></li>
</ul>
<p>r[asm.target-specific-directives.structured-exception-handling]</p>
<h5 id="structured-exception-handling"><a class="header" href="#structured-exception-handling">Structured exception handling</a></h5>
<p>구조화된 예외 처리를 사용하는 타겟에서는 다음의 추가 지시어들이 지원됨이 보장됩니다:</p>
<ul>
<li><code>.seh_endproc</code></li>
<li><code>.seh_endprologue</code></li>
<li><code>.seh_proc</code></li>
<li><code>.seh_pushreg</code></li>
<li><code>.seh_savereg</code></li>
<li><code>.seh_setframe</code></li>
<li><code>.seh_stackalloc</code></li>
</ul>
<p>r[asm.target-specific-directives.x86]</p>
<h5 id="x86-32비트-및-64비트"><a class="header" href="#x86-32비트-및-64비트">x86 (32비트 및 64비트)</a></h5>
<p>32비트 및 64비트 x86 타겟 모두에서 다음의 추가 지시어들이 지원됨이 보장됩니다:</p>
<ul>
<li><code>.nops</code></li>
<li><code>.code16</code></li>
<li><code>.code32</code></li>
<li><code>.code64</code></li>
</ul>
<p>Use of <code>.code16</code>, <code>.code32</code>, and <code>.code64</code> directives are only supported if the state is reset to the default before exiting the assembly code. 32-bit x86 uses <code>.code32</code> by default, and x86_64 uses <code>.code64</code> by default.</p>
<p>r[asm.target-specific-directives.arm-32-bit]</p>
<h5 id="arm-32비트"><a class="header" href="#arm-32비트">ARM (32비트)</a></h5>
<p>ARM에서 다음의 추가 지시어들이 지원됨이 보장됩니다:</p>
<ul>
<li><code>.even</code></li>
<li><code>.fnstart</code></li>
<li><code>.fnend</code></li>
<li><code>.save</code></li>
<li><code>.movsp</code></li>
<li><code>.code</code></li>
<li><code>.thumb</code></li>
<li><code>.thumb_func</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>r[safety]</p>
<h1 id="안전하지-않음"><a class="header" href="#안전하지-않음">안전하지 않음</a></h1>
<p>r[safety.intro] Unsafe operations are those that can potentially violate the memory-safety guarantees of Rust’s static semantics.</p>
<p>r[safety.unsafe-ops] The following language level features cannot be used in the safe subset of Rust:</p>
<p>r[safety.unsafe-deref]</p>
<ul>
<li><a href="types/pointer.html">원시 포인터(raw pointer)</a>를 역참조하는 것.</li>
</ul>
<p>r[safety.unsafe-static]</p>
<ul>
<li>Reading or writing a <a href="items/static-items.html#mutable-statics">mutable</a> or unsafe <a href="items/external-blocks.html">external</a> static variable.</li>
</ul>
<p>r[safety.unsafe-union-access]</p>
<ul>
<li>값을 할당하는 경우를 제외하고 <a href="items/unions.html"><code>유니온(union)</code></a>의 필드에 접근하는 것.</li>
</ul>
<p>r[safety.unsafe-call]</p>
<ul>
<li>Calling an unsafe function.</li>
</ul>
<p>r[safety.unsafe-target-feature-call]</p>
<ul>
<li>Calling a safe function marked with a [<code>target_feature</code>][attributes.codegen.target_feature] from a function that does not have a <code>target_feature</code> attribute enabling the same features (see [attributes.codegen.target_feature.safety-restrictions]).</li>
</ul>
<p>r[safety.unsafe-impl]</p>
<ul>
<li><a href="items/traits.html#unsafe-traits">안전하지 않은 트레잇(unsafe trait)</a>을 구현하는 것.</li>
</ul>
<p>r[safety.unsafe-extern]</p>
<ul>
<li><a href="items/external-blocks.html"><code>extern</code></a> 블록을 선언하는 것<sup class="footnote-reference"><a href="#extern-2024">1</a></sup>.</li>
</ul>
<p>r[safety.unsafe-attribute]</p>
<ul>
<li>아이템에 <a href="attributes.html">안전하지 않은 속성(unsafe attribute)</a>을 적용하는 것.</li>
</ul>
<div class="footnote-definition" id="extern-2024"><sup class="footnote-definition-label">1</sup>
<p>2024 에디션 이전에는 extern 블록을 <code>unsafe</code> 없이 선언할 수 있었습니다.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><p>r[unsafe]</p>
<h1 id="unsafe-키워드"><a class="header" href="#unsafe-키워드"><code>unsafe</code> 키워드</a></h1>
<p>r[unsafe.intro] The <code>unsafe</code> keyword is used to create or discharge the obligation to prove something safe. Specifically:</p>
<ul>
<li>It is used to mark code that <em>defines</em> extra safety conditions that must be upheld elsewhere.
<ul>
<li>This includes <code>unsafe fn</code>, <code>unsafe static</code>, and <code>unsafe trait</code>.</li>
</ul>
</li>
<li>It is used to mark code that the programmer <em>asserts</em> satisfies safety conditions defined elsewhere.
<ul>
<li>This includes <code>unsafe {}</code>, <code>unsafe impl</code>, <code>unsafe fn</code> without <a href="../rustc/lints/listing/allowed-by-default.html#unsafe-op-in-unsafe-fn"><code>unsafe_op_in_unsafe_fn</code></a>, <code>unsafe extern</code>, and <code>#[unsafe(attr)]</code>.</li>
</ul>
</li>
</ul>
<p>다음은 각 경우에 대해 설명합니다. 몇 가지 예시는 <a href="../std/keyword.unsafe.html">키워드 문서</a>를 참조하십시오.</p>
<p>r[unsafe.positions] The <code>unsafe</code> keyword can occur in several different contexts:</p>
<ul>
<li>unsafe functions (<code>unsafe fn</code>)</li>
<li>unsafe blocks (<code>unsafe {}</code>)</li>
<li>unsafe traits (<code>unsafe trait</code>)</li>
<li>unsafe trait implementations (<code>unsafe impl</code>)</li>
<li>unsafe external blocks (<code>unsafe extern</code>)</li>
<li>unsafe external statics (<code>unsafe static</code>)</li>
<li>unsafe attributes (<code>#[unsafe(attr)]</code>)</li>
</ul>
<p>r[unsafe.fn]</p>
<h2 id="안전하지-않은-함수-unsafe-fn"><a class="header" href="#안전하지-않은-함수-unsafe-fn">안전하지 않은 함수 (<code>unsafe fn</code>)</a></h2>
<p>r[unsafe.fn.intro] Unsafe functions are functions that are not safe in all contexts and/or for all possible inputs. We say they have <em>extra safety conditions</em>, which are requirements that must be upheld by all callers and that the compiler does not check. For example, <a href="slice::get_unchecked"><code>get_unchecked</code></a> has the extra safety condition that the index must be in-bounds. The unsafe function should come with documentation explaining what those extra safety conditions are.</p>
<p>r[unsafe.fn.safety] Such a function must be prefixed with the keyword <code>unsafe</code> and can only be called from inside an <code>unsafe</code> block, or inside <code>unsafe fn</code> without the <a href="../rustc/lints/listing/allowed-by-default.html#unsafe-op-in-unsafe-fn"><code>unsafe_op_in_unsafe_fn</code></a> lint.</p>
<p>r[unsafe.block]</p>
<h2 id="안전하지-않은-블록-unsafe-"><a class="header" href="#안전하지-않은-블록-unsafe-">안전하지 않은 블록 (<code>unsafe {}</code>)</a></h2>
<p>r[unsafe.block.intro] A block of code can be prefixed with the <code>unsafe</code> keyword to permit using the unsafe actions as defined in the <a href="unsafety.html">Unsafety</a> chapter, such as calling other unsafe functions or dereferencing raw pointers.</p>
<p>r[unsafe.block.fn-body] By default, the body of an unsafe function is also considered to be an unsafe block; this can be changed by enabling the <a href="../rustc/lints/listing/allowed-by-default.html#unsafe-op-in-unsafe-fn"><code>unsafe_op_in_unsafe_fn</code></a> lint.</p>
<p>연산들을 <code>unsafe</code> 블록 안에 넣음으로써, 프로그래머는 해당 블록 내부의 모든 연산에 대한 추가 안전 조건을 충족하도록 조치를 취했음을 선언합니다.</p>
<p>안전하지 않은 블록은 안전하지 않은 함수와 논리적으로 대칭을 이룹니다. 안전하지 않은 함수가 호출자가 준수해야 하는 증명 책임(proof obligation)을 정의한다면, 안전하지 않은 블록은 블록 내부에서 호출된 함수나 연산의 모든 관련 증명 책임이 완료되었음을 나타냅니다. 증명 책임을 완료하는 방법은 많습니다. 예를 들어, 특정 속성이 확실히 참임을 보장하는 런타임 검사나 데이터 구조의 불변성(invariants)이 있을 수 있습니다. 또는 안전하지 않은 블록이 <code>unsafe fn</code> 내부에 있는 경우, 해당 블록은 그 함수의 증명 책임을 사용하여 블록 내부에서 발생하는 증명 책임을 완료할 수 있습니다.</p>
<p>안전하지 않은 블록은 외부 라이브러리를 래핑하거나, 하드웨어를 직접 사용하거나, 언어에 직접 존재하지 않는 기능을 구현할 때 사용됩니다. 예를 들어, 러스트는 메모리 안전한 동시성을 구현하는 데 필요한 언어적 기능을 제공하지만, 표준 라이브러리의 스레드 및 메시지 패싱 구현은 안전하지 않은 블록을 사용합니다.</p>
<p>러스트의 타입 시스템은 동적 안전성 요구 사항에 대한 보수적인 근사치이므로, 어떤 경우에는 안전한 코드를 사용하는 데 성능 비용이 발생합니다. 예를 들어, 이중 연결 리스트는 트리 구조가 아니며 안전한 코드에서는 참조 횟수 계산(RC) 포인터로만 표현될 수 있습니다. <code>unsafe</code> 블록을 사용하여 역방향 링크를 원시 포인터로 표현하면 참조 횟수 계산 없이 구현할 수 있습니다. (이 예제에 대한 더 심도 있는 탐구는 <a href="https://rust-unofficial.github.io/too-many-lists/">“Learn Rust With Entirely Too Many Linked Lists”</a>를 참조하십시오.)</p>
<p>r[unsafe.trait]</p>
<h2 id="안전하지-않은-트레잇-unsafe-trait"><a class="header" href="#안전하지-않은-트레잇-unsafe-trait">안전하지 않은 트레잇 (<code>unsafe trait</code>)</a></h2>
<p>r[unsafe.trait.intro] An unsafe trait is a trait that comes with extra safety conditions that must be upheld by <em>implementations</em> of the trait. The unsafe trait should come with documentation explaining what those extra safety conditions are.</p>
<p>r[unsafe.trait.safety] Such a trait must be prefixed with the keyword <code>unsafe</code> and can only be implemented by <code>unsafe impl</code> blocks.</p>
<p>r[unsafe.impl]</p>
<h2 id="안전하지-않은-트레잇-구현-unsafe-impl"><a class="header" href="#안전하지-않은-트레잇-구현-unsafe-impl">안전하지 않은 트레잇 구현 (<code>unsafe impl</code>)</a></h2>
<p>안전하지 않은 트레잇을 구현할 때, 구현체 앞에 <code>unsafe</code> 키워드를 붙여야 합니다. <code>unsafe impl</code>을 작성함으로써, 프로그래머는 트레잇에서 요구하는 추가 안전 조건을 충족하도록 조치를 취했음을 선언합니다.</p>
<p>안전하지 않은 트레잇 구현은 안전하지 않은 트레잇과 논리적으로 대칭을 이룹니다. 안전하지 않은 트레잇이 구현체가 준수해야 하는 증명 책임을 정의한다면, 안전하지 않은 구현은 모든 관련 증명 책임이 완료되었음을 나타냅니다.</p>
<p>r[unsafe.extern]</p>
<h2 id="안전하지-않은-외부-블록-unsafe-extern"><a class="header" href="#안전하지-않은-외부-블록-unsafe-extern">안전하지 않은 외부 블록 (<code>unsafe extern</code>)</a></h2>
<p><a href="items/external-blocks.html">외부 블록</a>을 선언하는 프로그래머는 내부에 포함된 아이템의 시그니처가 정확함을 보장해야 합니다. 그렇지 않으면 정의되지 않은 동작으로 이어질 수 있습니다. 이러한 의무가 충족되었음을 <code>unsafe extern</code>을 작성하여 나타냅니다.</p>
<p>r[unsafe.extern.edition2024]</p>
<blockquote>
<p>[!EDITION-2024] Prior to edition 2024, <code>extern</code> blocks were allowed without being qualified as <code>unsafe</code>.</p>
</blockquote>
<p>r[unsafe.attribute]</p>
<h2 id="안전하지-않은-속성-unsafeattr"><a class="header" href="#안전하지-않은-속성-unsafeattr">안전하지 않은 속성 (<code>#[unsafe(attr)]</code>)</a></h2>
<p><a href="attributes.html">안전하지 않은 속성</a>은 속성을 사용할 때 준수해야 하는 추가 안전 조건이 있는 속성입니다. 컴파일러는 이러한 조건이 준수되었는지 확인할 수 없습니다. 조건이 충족되었음을 단언하기 위해, 이러한 속성들은 <code>unsafe(..)</code>로 감싸야 합니다. 예를 들어, <code>#[unsafe(no_mangle)]</code>과 같습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[undefined]</p>
<h1 id="정의되지-않은-동작으로-간주되는-경우"><a class="header" href="#정의되지-않은-동작으로-간주되는-경우">정의되지 않은 동작으로 간주되는 경우</a></h1>
<p>r[undefined.general] Rust code is incorrect if it exhibits any of the behaviors in the following list. This includes code within <code>unsafe</code> blocks and <code>unsafe</code> functions. <code>unsafe</code> only means that avoiding undefined behavior is on the programmer; it does not change anything about the fact that Rust programs must never cause undefined behavior.</p>
<p>r[undefined.soundness] It is the programmer’s responsibility when writing <code>unsafe</code> code to ensure that any safe code interacting with the <code>unsafe</code> code cannot trigger these behaviors. <code>unsafe</code> code that satisfies this property for any safe client is called <em>sound</em>; if <code>unsafe</code> code can be misused by safe code to exhibit undefined behavior, it is <em>unsound</em>.</p>
<blockquote>
<p>[!WARNING] The following list is not exhaustive; it may grow or shrink. There is no formal model of Rust’s semantics for what is and is not allowed in unsafe code, so there may be more behavior considered unsafe. We also reserve the right to make some of the behavior in that list defined in the future. In other words, this list does not say that anything will <em>definitely</em> always be undefined in all future Rust version (but we might make such commitments for some list items in the future).</p>
<p>안전하지 않은 코드를 작성하기 전에 <a href="../nomicon/index.html">러스트노미콘(Rustonomicon)</a>을 읽어보시기 바랍니다.</p>
</blockquote>
<p>r[undefined.race]</p>
<ul>
<li>데이터 경합 (Data races).</li>
</ul>
<p>r[undefined.pointer-access]</p>
<ul>
<li><a href="behavior-considered-undefined.html#dangling-pointers">매달린 포인터(dangling pointer)</a>이거나 <a href="behavior-considered-undefined.html#places-based-on-misaligned-pointers">정렬되지 않은 포인터에 기반한</a> 위치에 접근(로드 또는 스토어)하는 것.</li>
</ul>
<p>r[undefined.place-projection]</p>
<ul>
<li>Performing a place projection that violates the requirements of <a href="pointer#method.offset">in-bounds pointer arithmetic</a>. A place projection is a <a href="expressions/field-expr.html">field expression</a>, a <a href="expressions/tuple-expr.html#tuple-indexing-expressions">tuple index expression</a>, or an <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">array/slice index expression</a>.</li>
</ul>
<p>r[undefined.alias]</p>
<ul>
<li>
<p>Breaking the pointer aliasing rules. The exact aliasing rules are not determined yet, but here is an outline of the general principles: <code>&amp;T</code> must point to memory that is not mutated while they are live (except for data inside an <a href="std::cell::UnsafeCell"><code>UnsafeCell&lt;U&gt;</code></a>), and <code>&amp;mut T</code> must point to memory that is not read or written by any pointer not derived from the reference and that no other reference points to while they are live. <code>Box&lt;T&gt;</code> is treated similar to <code>&amp;'static mut T</code> for the purpose of these rules. The exact liveness duration is not specified, but some bounds exist:</p>
<ul>
<li>참조의 경우, 생존 기간의 상한선은 대여 검사기(borrow checker)가 할당한 구문상 라이프타임입니다. 즉, 그 라이프타임보다 <em>더 길게</em> 살아있을 수 없습니다.</li>
<li>Each time a reference or box is dereferenced or reborrowed, it is considered live.</li>
<li>참조나 박스가 함수로 전달되거나 함수에서 반환될 때마다, 그것은 살아있는 것으로 간주됩니다.</li>
<li>When a reference (but not a <code>Box</code>!) is passed to a function, it is live at least as long as that function call, again except if the <code>&amp;T</code> contains an <a href="std::cell::UnsafeCell"><code>UnsafeCell&lt;U&gt;</code></a>.
이 모든 사항은 이러한 타입의 값들이 복합 타입의 (중첩된) 필드로 전달될 때도 적용되지만, 포인터 간접 참조(indirections) 뒤에 있는 경우는 제외됩니다.</li>
</ul>
</li>
</ul>
<p>r[undefined.immutable]</p>
<ul>
<li>
<p>Mutating immutable bytes. All bytes reachable through a <a href="destructors.html#constant-promotion">const-promoted</a> expression are immutable, as well as bytes reachable through borrows in <code>static</code> and <code>const</code> initializers that have been <a href="destructors.html#temporary-lifetime-extension">lifetime-extended</a> to <code>'static</code>. The bytes owned by an immutable binding or immutable <code>static</code> are immutable, unless those bytes are part of an <a href="std::cell::UnsafeCell"><code>UnsafeCell&lt;U&gt;</code></a>.</p>
<p>게다가, 공유 참조가 <a href="behavior-considered-undefined.html#pointed-to-bytes">가리키는</a> 바이트들은 다른 참조(공유 및 가변 모두)와 <code>Box</code>를 통한 전이적 참조를 포함하여 모두 불변입니다. 전이성에는 복합 타입의 필드에 저장된 참조들도 포함됩니다.</p>
<p>수정이란 관련 바이트 중 어느 하나라도 겹치는 0바이트 이상의 모든 쓰기 연산을 의미합니다(해당 쓰기가 메모리 내용을 변경하지 않더라도 마찬가지입니다).</p>
</li>
</ul>
<p>r[undefined.intrinsic]</p>
<ul>
<li>컴파일러 내장 함수(intrinsics)를 통해 정의되지 않은 동작을 유발하는 것.</li>
</ul>
<p>r[undefined.target-feature]</p>
<ul>
<li>현재 플랫폼이 지원하지 않는 플랫폼 기능을 사용하여 컴파일된 코드를 실행하는 것(<a href="attributes/codegen.html#the-target_feature-attribute"><code>target_feature</code></a> 참조). 단, 플랫폼에서 이를 안전하다고 명시적으로 문서화한 경우는 제외합니다.</li>
</ul>
<p>r[undefined.call]</p>
<ul>
<li>Calling a function with the wrong <a href="items/external-blocks.html#abi">call ABI</a>, or unwinding past a stack frame that does not allow unwinding (e.g. by calling a <code>"C-unwind"</code> function imported or transmuted as a <code>"C"</code> function or function pointer).</li>
</ul>
<p>r[undefined.invalid]</p>
<ul>
<li><a href="behavior-considered-undefined.html#invalid-values">유효하지 않은 값</a>을 생성하는 것. 값을 “생성“한다는 것은 값이 장소(place)에 할당되거나 장소로부터 읽힐 때, 함수/기본 연산으로 전달되거나 함수/기본 연산으로부터 반환될 때마다 발생합니다.</li>
</ul>
<p>r[undefined.asm]</p>
<ul>
<li>인라인 어셈블리의 잘못된 사용. 자세한 내용은 인라인 어셈블리를 사용하는 코드를 작성할 때 따라야 할 <a href="inline-assembly.html#rules-for-inline-assembly">규칙</a>을 참조하십시오.</li>
</ul>
<p>r[undefined.runtime]</p>
<ul>
<li>Violating assumptions of the Rust runtime. Most assumptions of the Rust runtime are currently not explicitly documented.
<ul>
<li>For assumptions specifically related to unwinding, see the <a href="panic.html#unwinding-across-ffi-boundaries">panic documentation</a>.</li>
<li>The runtime assumes that a Rust stack frame is not deallocated without executing destructors for local variables owned by the stack frame. This assumption can be violated by C functions like <code>longjmp</code>.</li>
</ul>
</li>
</ul>
<blockquote>
<p>[!NOTE] Undefined behavior affects the entire program. For example, calling a function in C that exhibits undefined behavior of C means your entire program contains undefined behaviour that can also affect the Rust code. And vice versa, undefined behavior in Rust can cause adverse affects on code executed by any FFI calls to other languages.</p>
</blockquote>
<p>r[undefined.pointed-to]</p>
<h2 id="가리키는-바이트-pointed-to-bytes"><a class="header" href="#가리키는-바이트-pointed-to-bytes">가리키는 바이트 (Pointed-to bytes)</a></h2>
<p>포인터나 참조가 “가리키는” 바이트 범위는 포인터 값과 피지시체(pointee) 타입의 크기(<code>size_of_val</code> 사용)에 의해 결정됩니다.</p>
<p>r[undefined.misaligned]</p>
<h2 id="잘못-정렬된-포인터에-기반한-장소-places-based-on-misaligned-pointers"><a class="header" href="#잘못-정렬된-포인터에-기반한-장소-places-based-on-misaligned-pointers">잘못 정렬된 포인터에 기반한 장소 (Places based on misaligned pointers)</a></h2>
<p>r[undefined.misaligned.general] A place is said to be “based on a misaligned pointer” if the last <code>*</code> projection during place computation was performed on a pointer that was not aligned for its type. (If there is no <code>*</code> projection in the place expression, then this is accessing the field of a local or <code>static</code> and rustc will guarantee proper alignment. If there are multiple <code>*</code> projection, then each of them incurs a load of the pointer-to-be-dereferenced itself from memory, and each of these loads is subject to the alignment constraint. Note that some <code>*</code> projections can be omitted in surface Rust syntax due to automatic dereferencing; we are considering the fully expanded place expression here.)</p>
<p>예를 들어, <code>ptr</code>의 타입이 <code>*const S</code>이고 <code>S</code>의 정렬(alignment)이 8이라면, <code>ptr</code>은 반드시 8로 정렬되어야 합니다. 그렇지 않으면 <code>(*ptr).f</code>는 “잘못 정렬된 포인터에 기반한” 것이 됩니다. 이는 필드 <code>f</code>의 타입이 <code>u8</code>(즉, 정렬이 1인 타입)인 경우에도 마찬가지입니다. 다시 말해, 정렬 요구 사항은 접근하려는 필드의 타입이 아니라 역참조된 포인터의 타입에서 비롯됩니다.</p>
<p>r[undefined.misaligned.load-store] Note that a place based on a misaligned pointer only leads to undefined behavior when it is loaded from or stored to.</p>
<p>r[undefined.misaligned.raw] <code>&amp;raw const</code>/<code>&amp;raw mut</code> on such a place is allowed.</p>
<p>r[undefined.misaligned.reference] <code>&amp;</code>/<code>&amp;mut</code> on a place requires the alignment of the field type (or else the program would be “producing an invalid value”), which generally is a less restrictive requirement than being based on an aligned pointer.</p>
<p>r[undefined.misaligned.packed] Taking a reference will lead to a compiler error in cases where the field type might be more aligned than the type that contains it, i.e., <code>repr(packed)</code>. This means that being based on an aligned pointer is always sufficient to ensure that the new reference is aligned, but it is not always necessary.</p>
<p>r[undefined.dangling]</p>
<h2 id="매달린-포인터-dangling-pointers"><a class="header" href="#매달린-포인터-dangling-pointers">매달린 포인터 (Dangling pointers)</a></h2>
<p>r[undefined.dangling.general] A reference/pointer is “dangling” if not all of the bytes it <a href="behavior-considered-undefined.html#pointed-to-bytes">points to</a> are part of the same live allocation (so in particular they all have to be part of <em>some</em> allocation).</p>
<p>r[undefined.dangling.zero-size] If the size is 0, then the pointer is trivially never “dangling” (even if it is a null pointer).</p>
<p>r[undefined.dangling.dynamic-size] Note that dynamically sized types (such as slices and strings) point to their entire range, so it is important that the length metadata is never too large.</p>
<p>r[undefined.dangling.alloc-limit] In particular, the dynamic size of a Rust value (as determined by <code>size_of_val</code>) must never exceed <code>isize::MAX</code>, since it is impossible for a single allocation to be larger than <code>isize::MAX</code>.</p>
<p>r[undefined.validity]</p>
<h2 id="유효하지-않은-값-invalid-values"><a class="header" href="#유효하지-않은-값-invalid-values">유효하지 않은 값 (Invalid values)</a></h2>
<p>r[undefined.validity.general] The Rust compiler assumes that all values produced during program execution are “valid”, and producing an invalid value is hence immediate UB.</p>
<p>값이 유효한지 여부는 타입에 따라 다릅니다:</p>
<p>r[undefined.validity.bool]</p>
<ul>
<li><a href="types/boolean.html"><code>bool</code></a> 값은 <code>false</code> (<code>0</code>) 또는 <code>true</code> (<code>1</code>)여야 합니다.</li>
</ul>
<p>r[undefined.validity.fn-pointer]</p>
<ul>
<li><code>fn</code> 포인터 값은 널(null)이 아니어야 합니다.</li>
</ul>
<p>r[undefined.validity.char]</p>
<ul>
<li><code>char</code> 값은 써로게이트(surrogate, 즉 <code>0xD800..=0xDFFF</code> 범위 내의 값)가 아니어야 하며, <code>char::MAX</code>보다 작거나 같아야 합니다.</li>
</ul>
<p>r[undefined.validity.never]</p>
<ul>
<li><code>!</code> 값은 결코 존재해서는 안 됩니다.</li>
</ul>
<p>r[undefined.validity.scalar]</p>
<ul>
<li>An integer (<code>i*</code>/<code>u*</code>), floating point value (<code>f*</code>), or raw pointer must be initialized, i.e., must not be obtained from uninitialized memory.</li>
</ul>
<p>r[undefined.validity.str]</p>
<ul>
<li><code>str</code> 값은 <code>[u8]</code>과 같이 취급됩니다. 즉, 반드시 초기화되어야 합니다.</li>
</ul>
<p>r[undefined.validity.enum]</p>
<ul>
<li>열거형(<code>enum</code>)은 유효한 판별자(discriminant)를 가져야 하며, 해당 판별자가 나타내는 변형(variant)의 모든 필드는 각각의 타입에 대해 유효해야 합니다.</li>
</ul>
<p>r[undefined.validity.struct]</p>
<ul>
<li>구조체(<code>struct</code>), 튜플, 배열은 모든 필드/요소가 각각의 타입에 대해 유효할 것을 요구합니다.</li>
</ul>
<p>r[undefined.validity.union]</p>
<ul>
<li>유니온(<code>union</code>)의 경우, 정확한 유효성 요구 사항은 아직 결정되지 않았습니다. 분명히, 안전한 코드만으로 생성할 수 있는 모든 값은 유효합니다. 만약 유니온이 크기가 0인 필드를 가지고 있다면, 가능한 모든 값이 유효합니다. 더 자세한 내용은 <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/438">여전히 논의 중</a>입니다.</li>
</ul>
<p>r[undefined.validity.reference-box]</p>
<ul>
<li>A reference or [<code>Box&lt;T&gt;</code>] must be aligned and non-null, it cannot be <a href="behavior-considered-undefined.html#dangling-pointers">dangling</a>, and it must point to a valid value (in case of dynamically sized types, using the actual dynamic type of the pointee as determined by the metadata). Note that the last point (about pointing to a valid value) remains a subject of some debate.</li>
</ul>
<p>r[undefined.validity.wide]</p>
<ul>
<li>The metadata of a wide reference, [<code>Box&lt;T&gt;</code>], or raw pointer must match the type of the unsized tail:
<ul>
<li><code>dyn Trait</code> 메타데이터는 컴파일러가 생성한 <code>Trait</code>용 vtable에 대한 포인터여야 합니다. (원시 포인터의 경우, 이 요구 사항은 여전히 논의 중입니다.)</li>
<li>Slice (<code>[T]</code>) metadata must be a valid <code>usize</code>. Furthermore, for wide references and [<code>Box&lt;T&gt;</code>], slice metadata is invalid if it makes the total size of the pointed-to value bigger than <code>isize::MAX</code>.</li>
</ul>
</li>
</ul>
<p>r[undefined.validity.valid-range]</p>
<ul>
<li>
<p>If a type has a custom range of a valid values, then a valid value must be in that range. In the standard library, this affects <a href="core::ptr::NonNull"><code>NonNull&lt;T&gt;</code></a> and <a href="core::num::NonZero"><code>NonZero&lt;T&gt;</code></a>.</p>
<blockquote>
<p>[!NOTE] <code>rustc</code> achieves this with the unstable <code>rustc_layout_scalar_valid_range_*</code> attributes.</p>
</blockquote>
</li>
</ul>
<p>r[undefined.validity.const-provenance]</p>
<ul>
<li>
<p><strong>In <a href="const-eval.const-context">const contexts</a></strong>: In addition to what is described above, further provenance-related requirements apply during const evaluation. Any value that holds pure integer data (the <code>i*</code>/<code>u*</code>/<code>f*</code> types as well as <code>bool</code> and <code>char</code>, enum discriminants, and slice metadata) must not carry any provenance. Any value that holds pointer data (references, raw pointers, function pointers, and <code>dyn Trait</code> metadata) must either carry no provenance, or all bytes must be fragments of the same original pointer value in the correct order.</p>
<p>This implies that transmuting or otherwise reinterpreting a pointer (reference, raw pointer, or function pointer) into a non-pointer type (such as integers) is undefined behavior if the pointer had provenance.</p>
<blockquote>
<p>[!EXAMPLE] All of the following are UB:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use core::mem::MaybeUninit;
</span><span class="boring">use core::ptr;
</span>// We cannot reinterpret a pointer with provenance as an integer,
// as then the bytes of the integer will have provenance.
const _: usize = {
    let ptr = &amp;0;
    unsafe { (&amp;raw const ptr as *const usize).read() }
};

// We cannot rearrange the bytes of a pointer with provenance and
// then interpret them as a reference, as then a value holding
// pointer data will have pointer fragments in the wrong order.
const _: &amp;i32 = {
    let mut ptr = &amp;0;
    let ptr_bytes = &amp;raw mut ptr as *mut MaybeUninit::&lt;u8&gt;;
    unsafe { ptr::swap(ptr_bytes.add(1), ptr_bytes.add(2)) };
    ptr
};
<span class="boring">}</span></code></pre></pre>
</blockquote>
</li>
</ul>
<p>r[undefined.validity.undef] <strong>Note:</strong> Uninitialized memory is also implicitly invalid for any type that has a restricted set of valid values. In other words, the only cases in which reading uninitialized memory is permitted are inside <code>union</code>s and in “padding” (the gaps between the fields of a type).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unsafe로-간주되지-않는-동작"><a class="header" href="#unsafe로-간주되지-않는-동작"><code>unsafe</code>로 간주되지 않는 동작</a></h1>
<p>러스트 컴파일러는 다음의 동작들을 _안전하지 않다(unsafe)_고 간주하지 않습니다. 비록 프로그래머가 이를 바람직하지 않거나, 예상치 못했거나, 잘못된 것으로 생각할지라도 말입니다.</p>
<ul>
<li>데드락 (Deadlocks)</li>
<li>메모리 및 기타 리소스 누수 (Leaks)</li>
<li>소멸자(destructor)를 호출하지 않고 종료하는 것</li>
<li>포인터 누수를 통해 무작위화된 베이스 주소를 노출하는 것</li>
</ul>
<h2 id="정수-오버플로-integer-overflow"><a class="header" href="#정수-오버플로-integer-overflow">정수 오버플로 (Integer overflow)</a></h2>
<p>프로그램에 산술 오버플로가 포함되어 있다면, 이는 프로그래머의 실수입니다. 이어지는 논의에서, 우리는 산술 오버플로와 래핑(wrapping) 산술 연산을 구분합니다. 전자는 잘못된 것이고, 후자는 의도된 것입니다.</p>
<p>프로그래머가 <code>debug_assert!</code> 단언을 활성화한 경우(예: 최적화되지 않은 빌드), 구현체는 오버플로 시 <code>panic</code>을 일으키는 동적 검사를 삽입해야 합니다. 다른 종류의 빌드에서는 구현체의 재량에 따라 오버플로 시 <code>panic</code>이 발생하거나 조용히 값이 래핑될 수 있습니다.</p>
<p>암시적으로 래핑되는 오버플로의 경우, 구현체는 2의 보수 오버플로 관례를 사용하여 잘 정의된(여전히 오류로 간주될지라도) 결과를 제공해야 합니다.</p>
<p>정수 타입들은 프로그래머가 명시적으로 래핑 산술 연산을 수행할 수 있도록 내재적 메서드들을 제공합니다. 예를 들어, <code>i32::wrapping_add</code>는 2의 보수 래핑 덧셈을 제공합니다.</p>
<p>표준 라이브러리는 또한 <code>T</code>에 대한 모든 표준 산술 연산이 래핑 세만틱을 갖도록 보장하는 <code>Wrapping&lt;T&gt;</code> 뉴타입(newtype)을 제공합니다.</p>
<p>오류 조건, 근거, 그리고 정수 오버플로에 대한 더 자세한 내용은 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0560-integer-overflow.md">RFC 560</a>을 참조하십시오.</p>
<h2 id="논리-오류-logic-errors"><a class="header" href="#논리-오류-logic-errors">논리 오류 (Logic errors)</a></h2>
<p>안전한 코드는 컴파일 타임이나 런타임에 확인할 수 없는 추가적인 논리적 제약을 부과할 수 있습니다. 프로그램이 이러한 제약을 위반할 경우, 동작은 명시되지 않을 수 있으나 정의되지 않은 동작으로 이어지지는 않습니다. 여기에는 패닉, 잘못된 결과, 중단(abort), 그리고 종료되지 않음(non-termination) 등이 포함될 수 있습니다. 동작은 실행, 빌드, 또는 빌드 종류에 따라 달라질 수도 있습니다.</p>
<p>예를 들어, <code>Hash</code>와 <code>Eq</code>를 모두 구현할 때는 동일하다고 간주되는 값들이 동일한 해시 값을 가져야 한다는 요구 사항이 있습니다. 또 다른 예로 <code>BinaryHeap</code>, <code>BTreeMap</code>, <code>BTreeSet</code>, <code>HashMap</code>, <code>HashSet</code>과 같은 데이터 구조들은 데이터 구조에 포함된 동안 키(key)의 수정에 대한 제약 조건을 기술합니다. 이러한 제약 조건을 위반하는 것은 안전하지 않은(unsafe) 것으로 간주되지는 않지만, 프로그램은 오류가 있는 것으로 간주되며 그 동작은 예측할 수 없게 됩니다.</p>
<div style="break-before: page; page-break-before: always;"></div><p>r[const-eval]</p>
<h1 id="상수-평가-constant-evaluation"><a class="header" href="#상수-평가-constant-evaluation">상수 평가 (Constant evaluation)</a></h1>
<p>r[const-eval.general] Constant evaluation is the process of computing the result of <a href="expressions.html">expressions</a> during compilation. Only a subset of all expressions can be evaluated at compile-time.</p>
<p>r[const-eval.const-expr]</p>
<h2 id="상수-표현식"><a class="header" href="#상수-표현식">상수 표현식</a></h2>
<p>r[const-eval.const-expr.general] Certain forms of expressions, called constant expressions, can be evaluated at compile time.</p>
<p>r[const-eval.const-expr.const-context] Expressions in a <a href="const_eval.html#const-context">const context</a> must be constant expressions.</p>
<p>r[const-eval.const-expr.evaluation] Expressions in const contexts are always evaluated at compile time.</p>
<p>r[const-eval.const-expr.runtime-context] Outside of const contexts, constant expressions <em>may</em> be, but are not guaranteed to be, evaluated at compile time.</p>
<p>r[const-eval.const-expr.error] Behaviors such as out of bounds <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">array indexing</a> or <a href="expressions/operator-expr.html#overflow">overflow</a> are compiler errors if the value must be evaluated at compile time (i.e. in const contexts). Otherwise, these behaviors are warnings, but will likely panic at run-time.</p>
<p>r[const-eval.const-expr.list] The following expressions are constant expressions, so long as any operands are also constant expressions and do not cause any <a href="destructors.html"><code>Drop::drop</code></a> calls to be run.</p>
<p>r[const-eval.const-expr.literal]</p>
<ul>
<li><a href="expressions/literal-expr.html">리터럴</a>.</li>
</ul>
<p>r[const-eval.const-expr.parameter]</p>
<ul>
<li><a href="items/generics.html">상수 파라미터</a>.</li>
</ul>
<p>r[const-eval.const-expr.path-item]</p>
<ul>
<li><a href="items/functions.html">함수</a> 및 <a href="items/constant-items.html">상수</a>에 대한 <a href="expressions/path-expr.html">경로</a>. 상수를 재귀적으로 정의하는 것은 허용되지 않습니다.</li>
</ul>
<p>r[const-eval.const-expr.path-static]</p>
<ul>
<li>
<p>다음 제약 사항이 있는 <a href="items/static-items.html">정적 변수(statics)</a>에 대한 경로:</p>
<ul>
<li><code>static</code> 아이템에 쓰는 것은 어떠한 상수 평가 컨텍스트에서도 허용되지 않습니다.</li>
<li><code>extern</code> 정적 변수로부터 읽는 것은 어떠한 상수 평가 컨텍스트에서도 허용되지 않습니다.</li>
<li>평가가 <code>static</code> 아이템의 초기화 식 내에서 수행되는 것이 <em>아니라면</em>, 가변 <code>static</code>으로부터 읽는 것은 허용되지 않습니다. 가변 <code>static</code>은 <code>static mut</code> 아이템이거나, 내부 가변성(interior-mutable) 타입을 가진 <code>static</code> 아이템을 의미합니다.
이러한 요구 사항들은 상수가 평가될 때만 확인됩니다. 다시 말해, 이러한 접근이 상수 컨텍스트에서 구문상으로 나타나는 것은 실제로 실행되지 않는 한 허용됩니다.</li>
</ul>
</li>
</ul>
<p>r[const-eval.const-expr.tuple]</p>
<ul>
<li><a href="expressions/tuple-expr.html">튜플 표현식</a>.</li>
</ul>
<p>r[const-eval.const-expr.array]</p>
<ul>
<li><a href="expressions/array-expr.html">배열 표현식</a>.</li>
</ul>
<p>r[const-eval.const-expr.constructor]</p>
<ul>
<li><a href="expressions/struct-expr.html">Struct expressions</a>.</li>
</ul>
<p>r[const-eval.const-expr.block]</p>
<ul>
<li><code>unsafe</code> 및 <code>const</code> 블록을 포함한 <a href="expressions/block-expr.html">블록 표현식</a>.
<ul>
<li><a href="statements.html#let-statements">let 문</a> 및 그에 따른 가변 바인딩을 포함한 반박 불가능한(irrefutable) <a href="patterns.html">패턴</a></li>
<li><a href="expressions/operator-expr.html#assignment-expressions">대입 표현식</a></li>
<li><a href="expressions/operator-expr.html#compound-assignment-expressions">복합 대입 표현식</a></li>
<li><a href="statements.html#expression-statements">표현식 구문</a></li>
</ul>
</li>
</ul>
<p>r[const-eval.const-expr.field]</p>
<ul>
<li><a href="expressions/field-expr.html">필드</a> 표현식.</li>
</ul>
<p>r[const-eval.const-expr.index]</p>
<ul>
<li>인덱스 표현식, <code>usize</code>를 사용한 <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">배열 인덱싱</a> 또는 <a href="types/slice.html">슬라이스</a>.</li>
</ul>
<p>r[const-eval.const-expr.range]</p>
<ul>
<li><a href="expressions/range-expr.html">범위 표현식</a>.</li>
</ul>
<p>r[const-eval.const-expr.closure]</p>
<ul>
<li>환경으로부터 변수를 캡처하지 않는 <a href="expressions/closure-expr.html">클로저 표현식</a>.</li>
</ul>
<p>r[const-eval.const-expr.builtin-arith-logic]</p>
<ul>
<li>정수 및 부동 소수점 타입, <code>bool</code>, <code>char</code>에 사용되는 내장 <a href="expressions/operator-expr.html#negation-operators">부정</a>, <a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">산술</a>, <a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">논리</a>, <a href="expressions/operator-expr.html#comparison-operators">비교</a> 또는 <a href="expressions/operator-expr.html#lazy-boolean-operators">지연 평가 불리언(lazy boolean)</a> 연산자.</li>
</ul>
<p>r[const-eval.const-expr.borrows]</p>
<ul>
<li>
<p>All forms of <a href="expressions/operator-expr.html#borrow-operators">borrow</a>s, including raw borrows, except borrows of expressions whose temporary scopes would be extended (see <a href="destructors.scope.lifetime-extension">temporary lifetime extension</a>) to the end of the program and which are either:</p>
<ul>
<li>Mutable borrows.</li>
<li>Shared borrows of expressions that result in values with <a href="interior-mutability.html">interior mutability</a>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust compile_fail E0764 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Due to being in tail position, this borrow extends the scope of the
// temporary to the end of the program. Since the borrow is mutable,
// this is not allowed in a const expression.
const C: &amp;u8 = &amp;mut 0; // ERROR not allowed
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail E0764 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Const blocks are similar to initializers of `const` items.
let _: &amp;u8 = const { &amp;mut 0 }; // ERROR not allowed
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail E0492 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use core::sync::atomic::AtomicU8;
</span>// This is not allowed as 1) the temporary scope is extended to the
// end of the program and 2) the temporary has interior mutability.
const C: &amp;AtomicU8 = &amp;AtomicU8::new(0); // ERROR not allowed
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail E0492 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use core::sync::atomic::AtomicU8;
</span>// As above.
let _: &amp;_ = const { &amp;AtomicU8::new(0) }; // ERROR not allowed
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![allow(static_mut_refs)]
</span>// Even though this borrow is mutable, it's not of a temporary, so
// this is allowed.
const C: &amp;u8 = unsafe { static mut S: u8 = 0; &amp;mut S }; // OK
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use core::sync::atomic::AtomicU8;
</span>// Even though this borrow is of a value with interior mutability,
// it's not of a temporary, so this is allowed.
const C: &amp;AtomicU8 = {
    static S: AtomicU8 = AtomicU8::new(0); &amp;S // OK
};
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use core::sync::atomic::AtomicU8;
</span>// This shared borrow of an interior mutable temporary is allowed
// because its scope is not extended.
const C: () = { _ = &amp;AtomicU8::new(0); }; // OK
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Even though the borrow is mutable and the temporary lives to the
// end of the program due to promotion, this is allowed because the
// borrow is not in tail position and so the scope of the temporary
// is not extended via temporary lifetime extension.
const C: () = { let _: &amp;'static mut [u8] = &amp;mut []; }; // OK
//                                              ~~
//                                     Promoted temporary.
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>[!NOTE] In other words — to focus on what’s allowed rather than what’s not allowed — shared borrows of interior mutable data and mutable borrows are only allowed in a <a href="const_eval.html#const-context">const context</a> when the borrowed <a href="expr.place-value.place-memory-location">place expression</a> is <em>transient</em>, <em>indirect</em>, or <em>static</em>.</p>
<p>A place expression is <em>transient</em> if it is a variable local to the current const context or an expression whose temporary scope is contained inside the current const context.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The borrow is of a variable local to the initializer, therefore
// this place expression is transient.
const C: () = { let mut x = 0; _ = &amp;mut x; };
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The borrow is of a temporary whose scope has not been extended,
// therefore this place expression is transient.
const C: () = { _ = &amp;mut 0u8; };
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// When a temporary is promoted but not lifetime extended, its
// place expression is still treated as transient.
const C: () = { let _: &amp;'static mut [u8] = &amp;mut []; };
<span class="boring">}</span></code></pre></pre>
<p>A place expression is <em>indirect</em> if it is a <a href="expr.deref">dereference expression</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const C: () = { _ = &amp;mut *(&amp;mut 0); };
<span class="boring">}</span></code></pre></pre>
<p>A place expression is <em>static</em> if it is a <code>static</code> item.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![allow(static_mut_refs)]
</span>const C: &amp;u8 = unsafe { static mut S: u8 = 0; &amp;mut S };
<span class="boring">}</span></code></pre></pre>
</blockquote>
<blockquote>
<p>[!NOTE] One surprising consequence of these rules is that we allow this,</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const C: &amp;[u8] = { let x: &amp;mut [u8] = &amp;mut []; x }; // OK
//                                    ~~~~~~~
// Empty arrays are promoted even behind mutable borrows.
<span class="boring">}</span></code></pre></pre>
<p>but we disallow this similar code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0764 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const C: &amp;[u8] = &amp;mut []; // 오류
//               ~~~~~~~
//           Tail expression.
<span class="boring">}</span></code></pre></pre>
<p>The difference between these is that, in the first, the empty array is <a href="destructors.html#constant-promotion">promoted</a> but its scope does not undergo <a href="destructors.scope.lifetime-extension">temporary lifetime extension</a>, so we consider the <a href="expr.place-value.place-memory-location">place expression</a> to be transient (even though after promotion the place indeed lives to the end of the program). In the second, the scope of the empty array temporary does undergo lifetime extension, and so it is rejected due to being a mutable borrow of a lifetime-extended temporary (and therefore borrowing a non-transient place expression).</p>
<p>The effect is surprising because temporary lifetime extension, in this case, causes less code to compile than would without it.</p>
<p>See <a href="https://github.com/rust-lang/rust/issues/143129">issue #143129</a> for more details.</p>
</blockquote>
</li>
</ul>
<p>r[const-eval.const-expr.deref]</p>
<ul>
<li>
<p><a href="expr.deref">Dereference expressions</a>.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use core::cell::UnsafeCell;
</span>const _: u8 = unsafe {
    let x: *mut u8 = &amp;raw mut *&amp;mut 0;
    //                        ^^^^^^^
    //             Dereference of mutable reference.
    *x = 1; // Dereference of mutable pointer.
    *(x as *const u8) // Dereference of constant pointer.
};
const _: u8 = unsafe {
    let x = &amp;UnsafeCell::new(0);
    *x.get() = 1; // Mutation of interior mutable value.
    *x.get()
};
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<p>r[const-eval.const-expr.group]</p>
<ul>
<li><a href="expressions/grouped-expr.html">그룹화된(Grouped)</a> 표현식.</li>
</ul>
<p>r[const-eval.const-expr.cast]</p>
<ul>
<li>다음 경우를 제외한 <a href="expressions/operator-expr.html#type-cast-expressions">캐스트</a> 표현식:
<ul>
<li>포인터를 주소로 변환하는 캐스트 및</li>
<li>함수 포인터를 주소로 변환하는 캐스트.</li>
</ul>
</li>
</ul>
<p>r[const-eval.const-expr.const-fn]</p>
<ul>
<li><a href="items/functions.html#const-functions">상수 함수(const functions)</a> 및 상수 메서드 호출.</li>
</ul>
<p>r[const-eval.const-expr.loop]</p>
<ul>
<li><a href="expressions/loop-expr.html#infinite-loops">loop</a> and <a href="expressions/loop-expr.html#predicate-loops">while</a> expressions.</li>
</ul>
<p>r[const-eval.const-expr.if-match]</p>
<ul>
<li><a href="expressions/if-expr.html#if-expressions">if</a> and <a href="expressions/match-expr.html">match</a> expressions.</li>
</ul>
<p>r[const-eval.const-context]</p>
<h2 id="상수-컨텍스트-const-context"><a class="header" href="#상수-컨텍스트-const-context">상수 컨텍스트 (Const context)</a></h2>
<p>r[const-eval.const-context.general] A <em>const context</em> is one of the following:</p>
<p>r[const-eval.const-context.array-length]</p>
<ul>
<li><a href="types/array.html">배열 타입 길이 표현식</a></li>
</ul>
<p>r[const-eval.const-context.repeat-length]</p>
<ul>
<li><a href="expressions/array-expr.html">배열 반복 길이 표현식</a></li>
</ul>
<p>r[const-eval.const-context.init]</p>
<ul>
<li>다음의 초기화 식:
<ul>
<li><a href="items/constant-items.html">상수(constants)</a></li>
<li><a href="items/static-items.html">정적 변수(statics)</a></li>
<li><a href="items/enumerations.html#discriminants">열거형 판별자(enum discriminants)</a></li>
</ul>
</li>
</ul>
<p>r[const-eval.const-context.generic]</p>
<ul>
<li><a href="items/generics.html#const-generics">상수 제네릭 인자(const generic argument)</a></li>
</ul>
<p>r[const-eval.const-context.block]</p>
<ul>
<li><a href="expressions/block-expr.html#const-blocks">상수 블록(const block)</a></li>
</ul>
<p>r[const-eval.const-context.outer-generics] Const contexts that are used as parts of types (array type and repeat length expressions as well as const generic arguments) can only make restricted use of surrounding generic parameters: such an expression must either be a single bare const generic parameter, or an arbitrary expression not making use of any generics.</p>
<p>r[const-eval.const-fn]</p>
<h2 id="const-함수-1"><a class="header" href="#const-함수-1">const 함수</a></h2>
<p>r[const-eval.const-fn.intro] A <em>const function</em> is a function that can be called from a const context. It is defined with the <code>const</code> qualifier, and also includes <a href="items/structs.html">tuple struct</a> and <a href="items/enumerations.html">tuple enum variant</a> constructors.</p>
<blockquote>
<p>[!EXAMPLE]</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn square(x: i32) -&gt; i32 { x * x }

const VALUE: i32 = square(12);
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[const-eval.const-fn.const-context] When called from a const context, a const function is interpreted by the compiler at compile time. The interpretation happens in the environment of the compilation target and not the host. So <code>usize</code> is <code>32</code> bits if you are compiling against a <code>32</code> bit system, irrelevant of whether you are building on a <code>64</code> bit or a <code>32</code> bit system.</p>
<p>r[const-eval.const-fn.outside-context] When a const function is called from outside a const context, it behaves the same as if it did not have the <code>const</code> qualifier.</p>
<p>r[const-eval.const-fn.body-restriction] The body of a const function may only use <a href="const_eval.html#constant-expressions">constant expressions</a>.</p>
<p>r[const-eval.const-fn.async] Const functions are not allowed to be <a href="items/functions.html#async-functions">async</a>.</p>
<p>r[const-eval.const-fn.type-restrictions] The types of a const function’s parameters and return type are restricted to those that are compatible with a const context.</p>
<!-- TODO: Define the type restrictions. -->
<div style="break-before: page; page-break-before: always;"></div><p>r[abi]</p>
<h1 id="application-binary-interface-abi"><a class="header" href="#application-binary-interface-abi">Application binary interface (ABI)</a></h1>
<p>r[abi.intro] This section documents features that affect the ABI of the compiled output of a crate.</p>
<p>함수를 내보내기 위해 ABI를 지정하는 방법에 대한 정보는 _<a href="items/functions.html#extern-function-qualifier">외부 함수(extern functions)</a>_를 참조하십시오. 외부 라이브러리를 링크하기 위해 ABI를 지정하는 방법에 대한 정보는 _<a href="items/external-blocks.html">외부 블록(external blocks)</a>_을 참조하십시오.</p>
<p>r[abi.used]</p>
<h2 id="used-속성"><a class="header" href="#used-속성"><code>used</code> 속성</a></h2>
<p>r[abi.used.intro] The <em><code>used</code> attribute</em> can only be applied to <a href="items/static-items.html"><code>static</code> items</a>. This <a href="attributes.html">attribute</a> forces the compiler to keep the variable in the output object file (.o, .rlib, etc. excluding final binaries) even if the variable is not used, or referenced, by any other item in the crate. However, the linker is still free to remove such an item.</p>
<p>아래는 컴파일러가 어떤 조건 하에서 <code>static</code> 아이템을 출력 목적 파일에 유지하는지 보여주는 예제입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// foo.rs

// 이는 `#[used]` 때문에 유지됩니다:
#[used]
static FOO: u32 = 0;

// 이는 사용되지 않으므로 제거 가능합니다:
#[allow(dead_code)]
static BAR: u32 = 0;

// 이는 공개적으로 도달 가능하므로 유지됩니다:
pub static BAZ: u32 = 0;

// 이는 공개적으로 도달 가능한 함수에 의해 참조되므로 유지됩니다:
static QUUX: u32 = 0;

pub fn quux() -&gt; &amp;'static u32 {
    &amp;QUUX
}

// 이는 비공개이며 사용되지 않는(dead) 함수에 의해 참조되므로 제거 가능합니다:
static CORGE: u32 = 0;

#[allow(dead_code)]
fn corge() -&gt; &amp;'static u32 {
    &amp;CORGE
}
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-console">$ rustc -O --emit=obj --crate-type=rlib foo.rs

$ nm -C foo.o
0000000000000000 R foo::BAZ
0000000000000000 r foo::FOO
0000000000000000 R foo::QUUX
0000000000000000 T foo::quux
</code></pre>
<p>r[abi.no_mangle]</p>
<h2 id="no_mangle-속성"><a class="header" href="#no_mangle-속성"><code>no_mangle</code> 속성</a></h2>
<p>r[abi.no_mangle.intro] The <em><code>no_mangle</code> attribute</em> may be used on any <a href="items.html">item</a> to disable standard symbol name mangling. The symbol for the item will be the identifier of the item’s name.</p>
<p>r[abi.no_mangle.publicly-exported] Additionally, the item will be publicly exported from the produced library or object file, similar to the <a href="abi.html#the-used-attribute"><code>used</code> attribute</a>.</p>
<p>r[abi.no_mangle.unsafe] This attribute is unsafe as an unmangled symbol may collide with another symbol with the same name (or with a well-known symbol), leading to undefined behavior.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[unsafe(no_mangle)]
extern "C" fn foo() {}
<span class="boring">}</span></code></pre></pre>
<p>r[abi.no_mangle.edition2024]</p>
<blockquote>
<p>[!EDITION-2024] Before the 2024 edition it is allowed to use the <code>no_mangle</code> attribute without the <code>unsafe</code> qualification.</p>
</blockquote>
<p>r[abi.link_section]</p>
<h2 id="link_section-속성"><a class="header" href="#link_section-속성"><code>link_section</code> 속성</a></h2>
<p>r[abi.link_section.intro] The <em><code>link_section</code> attribute</em> specifies the section of the object file that a <a href="items/functions.html">function</a> or <a href="items/static-items.html">static</a>’s content will be placed into.</p>
<p>r[abi.link_section.syntax] The <code>link_section</code> attribute uses the [MetaNameValueStr] syntax to specify the section name.</p>
<!-- no_run: don't link. The format of the section name is platform-specific. -->
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[unsafe(no_mangle)]
#[unsafe(link_section = ".example_section")]
pub static VAR1: u32 = 1;
<span class="boring">}</span></code></pre></pre>
<p>r[abi.link_section.unsafe] This attribute is unsafe as it allows users to place data and code into sections of memory not expecting them, such as mutable data into read-only areas.</p>
<p>r[abi.link_section.edition2024]</p>
<blockquote>
<p>[!EDITION-2024] Before the 2024 edition it is allowed to use the <code>link_section</code> attribute without the <code>unsafe</code> qualification.</p>
</blockquote>
<p>r[abi.export_name]</p>
<h2 id="export_name-속성"><a class="header" href="#export_name-속성"><code>export_name</code> 속성</a></h2>
<p>r[abi.export_name.intro] The <em><code>export_name</code> attribute</em> specifies the name of the symbol that will be exported on a <a href="items/functions.html">function</a> or <a href="items/static-items.html">static</a>.</p>
<p>r[abi.export_name.syntax] The <code>export_name </code>attribute uses the [MetaNameValueStr] syntax to specify the symbol name.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[unsafe(export_name = "exported_symbol_name")]
pub fn name_in_rust() { }
<span class="boring">}</span></code></pre></pre>
<p>r[abi.export_name.unsafe] This attribute is unsafe as a symbol with a custom name may collide with another symbol with the same name (or with a well-known symbol), leading to undefined behavior.</p>
<p>r[abi.export_name.edition2024]</p>
<blockquote>
<p>[!EDITION-2024] Before the 2024 edition it is allowed to use the <code>export_name</code> attribute without the <code>unsafe</code> qualification.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>r[runtime]</p>
<h1 id="러스트-런타임"><a class="header" href="#러스트-런타임">러스트 런타임</a></h1>
<p>이 섹션은 러스트 런타임의 일부 측면을 정의하는 기능들을 설명합니다.</p>
<!-- template:attributes -->
<p>r[runtime.global_allocator]</p>
<h2 id="global_allocator-속성"><a class="header" href="#global_allocator-속성"><code>global_allocator</code> 속성</a></h2>
<p>r[runtime.global_allocator.intro] The <em><code>global_allocator</code> [attribute][attributes]</em> selects a [memory allocator][std::alloc].</p>
<blockquote>
<p>[!EXAMPLE]</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use core::alloc::{GlobalAlloc, Layout};
use std::alloc::System;

struct MyAllocator;

unsafe impl GlobalAlloc for MyAllocator {
    unsafe fn alloc(&amp;self, layout: Layout) -&gt; *mut u8 {
        unsafe { System.alloc(layout) }
    }
    unsafe fn dealloc(&amp;self, ptr: *mut u8, layout: Layout) {
        unsafe { System.dealloc(ptr, layout) }
    }
}

#[global_allocator]
static GLOBAL: MyAllocator = MyAllocator;
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[runtime.global_allocator.syntax] The <code>global_allocator</code> attribute uses the [MetaWord] syntax.</p>
<p>r[runtime.global_allocator.allowed-positions] The <code>global_allocator</code> attribute may only be applied to a <a href="items/static-items.html">static item</a> whose type implements the <a href="alloc::alloc::GlobalAlloc"><code>GlobalAlloc</code></a> trait.</p>
<p>r[runtime.global_allocator.duplicates] The <code>global_allocator</code> attribute may only be used once on an item.</p>
<p>r[runtime.global_allocator.single] The <code>global_allocator</code> attribute may only be used once in the crate graph.</p>
<p>r[runtime.global_allocator.stdlib] The <code>global_allocator</code> attribute is exported from the [standard library prelude][core::prelude::v1].</p>
<!-- template:attributes -->
<p>r[runtime.windows_subsystem]</p>
<h2 id="windows_subsystem-속성"><a class="header" href="#windows_subsystem-속성"><code>windows_subsystem</code> 속성</a></h2>
<p>r[runtime.windows_subsystem.intro] The <em><code>windows_subsystem</code> [attribute][attributes]</em> sets the <a href="https://msdn.microsoft.com/en-us/library/fcc1zstk.aspx">subsystem</a> when linking on a Windows target.</p>
<blockquote>
<p>[!EXAMPLE]</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span>#![windows_subsystem = "windows"]
<span class="boring">fn main() {
</span><span class="boring">}</span></code></pre></pre>
</blockquote>
<p>r[runtime.windows_subsystem.syntax] The <code>windows_subsystem</code> attribute uses the [MetaNameValueStr] syntax. Accepted values are <code>"console"</code> and <code>"windows"</code>.</p>
<p>r[runtime.windows_subsystem.allowed-positions] The <code>windows_subsystem</code> attribute may only be applied to the crate root.</p>
<p>r[runtime.windows_subsystem.duplicates] Only the first use of <code>windows_subsystem</code> has effect.</p>
<blockquote>
<p>[!NOTE] <code>rustc</code> lints against any use following the first. This may become an error in the future.</p>
</blockquote>
<p>r[runtime.windows_subsystem.ignored] The <code>windows_subsystem</code> attribute is ignored on non-Windows targets and non-<code>bin</code> <a href="linkage.html">crate types</a>.</p>
<p>r[runtime.windows_subsystem.console] The <code>"console"</code> subsystem is the default. If a console process is run from an existing console then it will be attached to that console; otherwise a new console window will be created.</p>
<p>r[runtime.windows_subsystem.windows] The <code>"windows"</code> subsystem will run detached from any existing console.</p>
<blockquote>
<p>[!NOTE] The <code>"windows"</code> subsystem is commonly used by GUI applications that do not want to display a console window on startup.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="부록"><a class="header" href="#부록">부록</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grammar-summary"><a class="header" href="#grammar-summary">Grammar summary</a></h1>
<p>The following is a summary of the grammar production rules. For details on the syntax of this grammar, see <em>[notation.grammar.syntax]</em>.</p>
<p>{{ grammar-summary }}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syntax-index"><a class="header" href="#syntax-index">Syntax index</a></h1>
<p>This appendix provides an index of tokens and common forms with links to where those elements are defined.</p>
<h2 id="키워드-1"><a class="header" href="#키워드-1">키워드</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Keyword</th><th>Use</th></tr></thead><tbody>
<tr><td><code>_</code></td><td><a href="patterns.wildcard">wildcard pattern</a>, <a href="items.generics.const.inferred">inferred const</a>, <a href="type.inferred">inferred type</a>, <a href="lifetime-elision.function.explicit-placeholder">placeholder lifetime</a>, <a href="items.const">constant items</a>, <a href="items.extern-crate">extern crate</a>, <a href="items.use">use declarations</a>, <a href="expr.placeholder">destructuring assignment</a></td></tr>
<tr><td><code>abstract</code></td><td><a href="lex.keywords.reserved">reserved keyword</a></td></tr>
<tr><td><code>as</code></td><td>[extern crate][items.extern-crate.as], [use declarations][items.use.forms.as], <a href="expr.as">type cast expressions</a>, <a href="paths.qualified">qualified paths</a></td></tr>
<tr><td><code>async</code></td><td><a href="items.fn.async">async functions</a>, <a href="expr.block.async">async blocks</a>, <a href="expr.closure.async">async closures</a></td></tr>
<tr><td><code>await</code></td><td><a href="expr.await">await expressions</a></td></tr>
<tr><td><code>become</code></td><td><a href="lex.keywords.reserved">reserved keyword</a></td></tr>
<tr><td><code>box</code></td><td><a href="lex.keywords.reserved">reserved keyword</a></td></tr>
<tr><td><code>break</code></td><td><a href="expr.loop.break">break expressions</a></td></tr>
<tr><td><code>const</code></td><td><a href="const-eval.const-fn">const functions</a>, <a href="items.const">const items</a>, <a href="items.generics.const">const generics</a>, <a href="expr.block.const">const blocks</a>, <a href="expr.borrow.raw">raw borrow operator</a>, <a href="type.pointer.raw">raw pointer type</a>, <a href="asm.operand-type.supported-operands.const">const assembly operands</a></td></tr>
<tr><td><code>continue</code></td><td><a href="expr.loop.continue">continue expressions</a></td></tr>
<tr><td><code>crate</code></td><td><a href="items.extern-crate">extern crate</a>, <a href="vis">visibility</a>, [paths]</td></tr>
<tr><td><code>do</code></td><td><a href="lex.keywords.reserved">reserved keyword</a></td></tr>
<tr><td><code>dyn</code></td><td><a href="type.trait-object">trait objects</a></td></tr>
<tr><td><code>else</code></td><td><a href="statement.let">let statements</a>, <a href="expr.if">if expressions</a></td></tr>
<tr><td><code>enum</code></td><td><a href="items.enum">enumerations</a></td></tr>
<tr><td><code>extern</code></td><td><a href="items.extern-crate">extern crate</a>, <a href="items.fn.extern">extern function qualifier</a>, <a href="items.extern">external blocks</a>, <a href="type.fn-pointer.qualifiers">extern function pointer types</a></td></tr>
<tr><td><code>false</code></td><td><a href="type.bool">boolean type</a>, <a href="expr.literal">boolean expressions</a>, <a href="cfg">configuration predicates</a></td></tr>
<tr><td><code>final</code></td><td><a href="lex.keywords.reserved">reserved keyword</a></td></tr>
<tr><td><code>fn</code></td><td><a href="items.fn">functions</a>, <a href="type.fn-pointer">function pointer types</a></td></tr>
<tr><td><code>for</code></td><td><a href="items.impl.trait">trait implementations</a>, <a href="expr.loop.for">iterator loops</a>, <a href="bound.higher-ranked">higher-ranked trait bounds</a></td></tr>
<tr><td><code>gen</code></td><td><a href="lex.keywords.reserved">reserved keyword</a></td></tr>
<tr><td><code>if</code></td><td><a href="expr.if">if expressions</a>, <a href="expr.match.guard">match guards</a></td></tr>
<tr><td><code>impl</code></td><td><a href="items.impl.inherent">inherent impls</a>, <a href="items.impl.trait">trait impls</a>, <a href="type.impl-trait.return">impl trait types</a>, <a href="type.impl-trait.param">anonymous type parameters</a></td></tr>
<tr><td><code>in</code></td><td><a href="vis">visibility</a>, <a href="expr.loop.for">iterator loops</a>, <a href="asm.operand-type.supported-operands.in">assembly operands</a></td></tr>
<tr><td><code>let</code></td><td><a href="statement.let">let statements</a>, <a href="expr.if.let"><code>if let</code> patterns</a></td></tr>
<tr><td><code>loop</code></td><td><a href="expr.loop.infinite">infinite loops</a></td></tr>
<tr><td><code>macro_rules</code></td><td><a href="macro.decl">macros by example</a></td></tr>
<tr><td><code>macro</code></td><td><a href="lex.keywords.reserved">reserved keyword</a></td></tr>
<tr><td><code>match</code></td><td><a href="expr.match">match expressions</a></td></tr>
<tr><td><code>mod</code></td><td><a href="items.mod">modules</a></td></tr>
<tr><td><code>move</code></td><td><a href="expr.closure">closure expressions</a>, <a href="expr.block.async">async blocks</a></td></tr>
<tr><td><code>mut</code></td><td><a href="expr.operator.borrow">borrow expressions</a>, <a href="patterns.ident">identifier patterns</a>, <a href="patterns.ref">reference patterns</a>, <a href="patterns.struct">struct patterns</a>, <a href="type.pointer.reference">reference types</a>, <a href="type.pointer.raw">raw pointer types</a>, <a href="items.fn.params.self-pat">self parameters</a>, <a href="items.static">static items</a></td></tr>
<tr><td><code>override</code></td><td><a href="lex.keywords.reserved">reserved keyword</a></td></tr>
<tr><td><code>priv</code></td><td><a href="lex.keywords.reserved">reserved keyword</a></td></tr>
<tr><td><code>pub</code></td><td><a href="vis">visibility</a></td></tr>
<tr><td><code>raw</code></td><td><a href="expr.operator.borrow">borrow expressions</a>, <a href="asm.options.supported-options.raw">raw assembly</a></td></tr>
<tr><td><code>ref</code></td><td><a href="patterns.ident">identifier patterns</a>, <a href="patterns.struct">struct patterns</a></td></tr>
<tr><td><code>return</code></td><td><a href="expr.return">return expressions</a></td></tr>
<tr><td><code>safe</code></td><td><a href="items.extern.fn">external block functions</a>, <a href="items.extern.static">external block statics</a></td></tr>
<tr><td><code>self</code></td><td>[extern crate][items.extern-crate.self], <a href="items.fn.params.self-pat">self parameters</a>, <a href="vis">visibility</a>, <a href="paths.qualifiers.mod-self"><code>self</code> paths</a></td></tr>
<tr><td><code>Self</code></td><td><a href="paths.qualifiers.type-self"><code>Self</code> type paths</a>, <a href="bound.use">use bounds</a></td></tr>
<tr><td><code>static</code></td><td><a href="items.static">static items</a>, <a href="bound"><code>'static</code> lifetimes</a></td></tr>
<tr><td><code>struct</code></td><td><a href="items.struct">structs</a></td></tr>
<tr><td><code>super</code></td><td><a href="paths.qualifiers.super">super paths</a>, <a href="vis">visibility</a></td></tr>
<tr><td><code>trait</code></td><td><a href="items.traits">trait items</a></td></tr>
<tr><td><code>true</code></td><td><a href="type.bool">boolean type</a>, <a href="expr.literal">boolean expressions</a>, <a href="cfg">configuration predicates</a></td></tr>
<tr><td><code>try</code></td><td><a href="lex.keywords.reserved">reserved keyword</a></td></tr>
<tr><td><code>type</code></td><td><a href="items.type">type aliases</a></td></tr>
<tr><td><code>typeof</code></td><td><a href="lex.keywords.reserved">reserved keyword</a></td></tr>
<tr><td><code>union</code></td><td><a href="items.union">union items</a></td></tr>
<tr><td><code>unsafe</code></td><td><a href="expr.block.unsafe">unsafe blocks</a>, <a href="attributes.safety">unsafe attributes</a>, <a href="items.mod.unsafe">unsafe modules</a>, <a href="unsafe.fn">unsafe functions</a>, <a href="unsafe.extern">unsafe external blocks</a>, <a href="items.extern.fn.safety">unsafe external functions</a>, <a href="items.extern.static.safety">unsafe external statics</a>, <a href="items.traits.safety">unsafe traits</a>, <a href="items.impl.trait.safety">unsafe trait implementations</a></td></tr>
<tr><td><code>unsized</code></td><td><a href="lex.keywords.reserved">reserved keyword</a></td></tr>
<tr><td><code>use</code></td><td><a href="items.use">use items</a>, <a href="bound.use">use bounds</a></td></tr>
<tr><td><code>virtual</code></td><td><a href="lex.keywords.reserved">reserved keyword</a></td></tr>
<tr><td><code>where</code></td><td><a href="items.generics.where">where clauses</a></td></tr>
<tr><td><code>while</code></td><td><a href="expr.loop.while">predicate loops</a></td></tr>
<tr><td><code>yield</code></td><td><a href="lex.keywords.reserved">reserved keyword</a></td></tr>
</tbody></table>
</div>
<h2 id="operators-and-punctuation"><a class="header" href="#operators-and-punctuation">Operators and punctuation</a></h2>
<div class="table-wrapper"><table><thead><tr><th>기호</th><th>이름</th><th>Use</th></tr></thead><tbody>
<tr><td><code>+</code></td><td>더하기</td><td><a href="expr.arith-logic">addition</a>, <a href="bound">trait bounds</a>, <a href="macro.decl.repetition">macro Kleene matcher</a></td></tr>
<tr><td><code>-</code></td><td>빼기</td><td><a href="expr.arith-logic">subtraction</a>, <a href="expr.negate">negation</a></td></tr>
<tr><td><code>*</code></td><td>별</td><td><a href="expr.arith-logic">multiplication</a>, <a href="expr.deref">dereference</a>, <a href="type.pointer.raw">raw pointers</a>, <a href="macro.decl.repetition">macro Kleene matcher</a>, <a href="items.use.glob">glob imports</a></td></tr>
<tr><td><code>/</code></td><td>슬래시</td><td><a href="expr.arith-logic">division</a></td></tr>
<tr><td><code>%</code></td><td>백분율</td><td><a href="expr.arith-logic">remainder</a></td></tr>
<tr><td><code>^</code></td><td>캐럿</td><td><a href="expr.arith-logic">bitwise and logical XOR</a></td></tr>
<tr><td><code>!</code></td><td>아님</td><td><a href="expr.negate">bitwise and logical NOT</a>, <a href="macro.invocation">macro calls</a>, [inner attributes][attributes], <a href="type.never">never type</a>, <a href="items.impl">negative impls</a></td></tr>
<tr><td><code>&amp;</code></td><td>그리고</td><td><a href="expr.arith-logic">bitwise and logical AND</a>, <a href="expr.operator.borrow">borrow</a>, <a href="type.pointer.reference">references</a>, <a href="patterns.ref">reference patterns</a></td></tr>
<tr><td><code>|</code></td><td>또는</td><td><a href="expr.arith-logic">bitwise and logical OR</a>, <a href="expr.closure">closures</a>, <a href="patterns.or">or patterns</a>, <a href="expr.if.let">if let</a>, <a href="expr.loop.while.let">while let</a></td></tr>
<tr><td><code>&amp;&amp;</code></td><td>그리고 그리고</td><td><a href="expr.bool-logic">lazy AND</a>, <a href="expr.operator.borrow">borrow</a>, <a href="type.pointer.reference">references</a>, <a href="patterns.ref">reference patterns</a></td></tr>
<tr><td><code>||</code></td><td>또는 또는</td><td><a href="expr.bool-logic">lazy OR</a>, <a href="expr.closure">closures</a></td></tr>
<tr><td><code>&lt;&lt;</code></td><td>Shl</td><td><a href="expr.arith-logic">shift left</a>, <a href="items.generics">nested generics</a></td></tr>
<tr><td><code>&gt;&gt;</code></td><td>Shr</td><td><a href="expr.arith-logic">shift right</a>, <a href="items.generics">nested generics</a></td></tr>
<tr><td><code>+=</code></td><td>PlusEq</td><td><a href="expr.compound-assign">addition assignment</a></td></tr>
<tr><td><code>-=</code></td><td>MinusEq</td><td><a href="expr.compound-assign">subtraction assignment</a></td></tr>
<tr><td><code>*=</code></td><td>StarEq</td><td><a href="expr.compound-assign">multiplication assignment</a></td></tr>
<tr><td><code>/=</code></td><td>SlashEq</td><td><a href="expr.compound-assign">division assignment</a></td></tr>
<tr><td><code>%=</code></td><td>PercentEq</td><td><a href="expr.compound-assign">remainder assignment</a></td></tr>
<tr><td><code>^=</code></td><td>CaretEq</td><td><a href="expr.compound-assign">bitwise XOR assignment</a></td></tr>
<tr><td><code>&amp;=</code></td><td>AndEq</td><td><a href="expr.compound-assign">bitwise AND assignment</a></td></tr>
<tr><td><code>|=</code></td><td>OrEq</td><td><a href="expr.compound-assign">bitwise OR assignment</a></td></tr>
<tr><td><code>&lt;&lt;=</code></td><td>ShlEq</td><td><a href="expr.compound-assign">shift left assignment</a></td></tr>
<tr><td><code>&gt;&gt;=</code></td><td>ShrEq</td><td><a href="expr.compound-assign">shift right assignment</a>, <a href="items.generics">nested generics</a></td></tr>
<tr><td><code>=</code></td><td>Eq</td><td><a href="expr.assign">assignment</a>, <a href="statement.let">let statements</a>, [attributes], various type definitions</td></tr>
<tr><td><code>==</code></td><td>EqEq</td><td><a href="expr.cmp">equal</a></td></tr>
<tr><td><code>!=</code></td><td>Ne</td><td><a href="expr.cmp">not equal</a></td></tr>
<tr><td><code>&gt;</code></td><td>Gt</td><td><a href="expr.cmp">greater than</a>, <a href="items.generics">generics</a>, [paths], <a href="bound.use">use bounds</a></td></tr>
<tr><td><code>&lt;</code></td><td>Lt</td><td><a href="expr.cmp">less than</a>, <a href="items.generics">generics</a>, [paths], <a href="bound.use">use bounds</a></td></tr>
<tr><td><code>&gt;=</code></td><td>Ge</td><td><a href="expr.cmp">greater than or equal to</a>, <a href="items.generics">generics</a></td></tr>
<tr><td><code>&lt;=</code></td><td>Le</td><td><a href="expr.cmp">less than or equal to</a></td></tr>
<tr><td><code>@</code></td><td>At</td><td><a href="patterns.ident.scrutinized">subpattern binding</a></td></tr>
<tr><td><code>.</code></td><td>점</td><td><a href="expr.field">field access</a>, <a href="expr.tuple-index">tuple index</a></td></tr>
<tr><td><code>..</code></td><td>점점</td><td>[range expressions][expr.range], <a href="expr.struct">struct expressions</a>, <a href="patterns.rest">rest pattern</a>, <a href="patterns.range">range patterns</a>, <a href="patterns.struct">struct patterns</a></td></tr>
<tr><td><code>...</code></td><td>점점점</td><td><a href="items.extern.variadic">variadic functions</a>, <a href="patterns.range">range patterns</a></td></tr>
<tr><td><code>..=</code></td><td>DotDotEq</td><td>[inclusive range expressions][expr.range], <a href="patterns.range">range patterns</a></td></tr>
<tr><td><code>,</code></td><td>쉼표</td><td>various separators</td></tr>
<tr><td><code>;</code></td><td>세미콜론</td><td>terminator for various items and statements, <a href="expr.array">array expressions</a>, <a href="type.array">array types</a></td></tr>
<tr><td><code>:</code></td><td>콜론</td><td>various separators</td></tr>
<tr><td><code>::</code></td><td>PathSep</td><td>[path separator][paths]</td></tr>
<tr><td><code>-&gt;</code></td><td>RArrow</td><td><a href="items.fn">functions</a>, <a href="expr.closure">closures</a>, <a href="type.fn-pointer">function pointer type</a></td></tr>
<tr><td><code>=&gt;</code></td><td>FatArrow</td><td><a href="expr.match">match arms</a>, <a href="macro.decl">macros</a></td></tr>
<tr><td><code>&lt;-</code></td><td>LArrow</td><td>The left arrow symbol has been unused since before Rust 1.0, but it is still treated as a single token.</td></tr>
<tr><td><code>#</code></td><td>파운드</td><td>[attributes], <a href="lex.token.literal.str-raw">raw string literals</a>, <a href="lex.token.str-byte-raw">raw byte string literals</a>, <a href="lex.token.str-c-raw">raw C string literals</a></td></tr>
<tr><td><code>$</code></td><td>달러</td><td><a href="macro.decl">macros</a></td></tr>
<tr><td><code>?</code></td><td>물음표</td><td><a href="expr.try">try propagation expressions</a>, <a href="bound.sized">relaxed trait bounds</a>, <a href="macro.decl.repetition">macro Kleene matcher</a></td></tr>
<tr><td><code>~</code></td><td>물결표</td><td>The tilde operator has been unused since before Rust 1.0, but its token may still be used.</td></tr>
</tbody></table>
</div>
<h2 id="주석-1"><a class="header" href="#주석-1">주석</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Comment</th><th>Use</th></tr></thead><tbody>
<tr><td><code>//</code></td><td>[line comment][comments]</td></tr>
<tr><td><code>//!</code></td><td>[inner line comment][comments]</td></tr>
<tr><td><code>///</code></td><td>[outer line doc comment][comments]</td></tr>
<tr><td><code>/*…*/</code></td><td>[block comment][comments]</td></tr>
<tr><td><code>/*!…*/</code></td><td>[inner block doc comment][comments]</td></tr>
<tr><td><code>/**…*/</code></td><td>[outer block doc comment][comments]</td></tr>
</tbody></table>
</div>
<h2 id="other-tokens"><a class="header" href="#other-tokens">Other tokens</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Token</th><th>Use</th></tr></thead><tbody>
<tr><td><code>ident</code></td><td><a href="ident">identifiers</a></td></tr>
<tr><td><code>r#ident</code></td><td><a href="ident.raw">raw identifiers</a></td></tr>
<tr><td><code>'ident</code></td><td><a href="lex.token.life">lifetimes and loop labels</a></td></tr>
<tr><td><code>'r#ident</code></td><td><a href="lex.token.life">raw lifetimes and loop labels</a></td></tr>
<tr><td><code>…u8</code>, <code>…i32</code>, <code>…f64</code>, <code>…usize</code>, …</td><td><a href="lex.token.literal.num">number literals</a></td></tr>
<tr><td><code>"…"</code></td><td><a href="lex.token.literal.str">string literals</a></td></tr>
<tr><td><code>r"…"</code>, <code>r#"…"#</code>, <code>r##"…"##</code>, …</td><td><a href="lex.token.literal.str-raw">raw string literals</a></td></tr>
<tr><td><code>b"…"</code></td><td><a href="lex.token.str-byte">byte string literals</a></td></tr>
<tr><td><code>br"…"</code>, <code>br#"…"#</code>, <code>br##"…"##</code>, …</td><td><a href="lex.token.str-byte-raw">raw byte string literals</a></td></tr>
<tr><td><code>'…'</code></td><td><a href="lex.token.literal.char">character literals</a></td></tr>
<tr><td><code>b'…'</code></td><td><a href="lex.token.byte">byte literals</a></td></tr>
<tr><td><code>c"…"</code></td><td><a href="lex.token.str-c">C string literals</a></td></tr>
<tr><td><code>cr"…"</code>, <code>cr#"…"#</code>, <code>cr##"…"##</code>, …</td><td><a href="lex.token.str-c-raw">raw C string literals</a></td></tr>
</tbody></table>
</div>
<h2 id="매크로-2"><a class="header" href="#매크로-2">매크로</a></h2>
<div class="table-wrapper"><table><thead><tr><th>구문</th><th>Use</th></tr></thead><tbody>
<tr><td><code>ident!(…)</code><br><code>ident! {…}</code><br><code>ident![…]</code></td><td><a href="macro.invocation">macro invocations</a></td></tr>
<tr><td><code>$ident</code></td><td><a href="macro.decl.meta">macro metavariable</a></td></tr>
<tr><td><code>$ident:kind</code></td><td><a href="macro.decl.meta.specifier">macro matcher fragment specifier</a></td></tr>
<tr><td><code>$(…)…</code></td><td><a href="macro.decl.repetition">macro repetition</a></td></tr>
</tbody></table>
</div>
<h2 id="속성-3"><a class="header" href="#속성-3">속성</a></h2>
<div class="table-wrapper"><table><thead><tr><th>구문</th><th>Use</th></tr></thead><tbody>
<tr><td><code>#[meta]</code></td><td><a href="attributes.outer">outer attribute</a></td></tr>
<tr><td><code>#![meta]</code></td><td><a href="attributes.inner">inner attribute</a></td></tr>
</tbody></table>
</div>
<h2 id="표현식-1"><a class="header" href="#표현식-1">표현식</a></h2>
<div class="table-wrapper"><table><thead><tr><th>표현식</th><th>Use</th></tr></thead><tbody>
<tr><td><code>|…| expr</code><br><code>|…| -&gt; Type { … }</code></td><td><a href="expr.closure">closures</a></td></tr>
<tr><td><code>ident::…</code></td><td>[paths]</td></tr>
<tr><td><code>::crate_name::…</code></td><td><a href="paths.qualifiers.global-root">explicit crate paths</a></td></tr>
<tr><td><code>crate::…</code></td><td><a href="paths.qualifiers.crate">crate-relative paths</a></td></tr>
<tr><td><code>self::…</code></td><td><a href="paths.qualifiers.mod-self">module-relative paths</a></td></tr>
<tr><td><code>super::…</code></td><td><a href="paths.qualifiers.super">parent module paths</a></td></tr>
<tr><td><code>Type::…</code><br><code>&lt;Type as Trait&gt;::ident</code></td><td><a href="items.associated">associated items</a></td></tr>
<tr><td><code>&lt;Type&gt;::…</code></td><td><a href="paths.qualified">qualified paths</a> which can be used for types without names such as <code>&lt;&amp;T&gt;::…</code>, <code>&lt;[T]&gt;::…</code>, etc.</td></tr>
<tr><td><code>Trait::method(…)</code><br><code>Type::method(…)</code><br><code>&lt;Type as Trait&gt;::method(…)</code></td><td><a href="expr.call.desugar">disambiguated method calls</a></td></tr>
<tr><td><code>method::&lt;…&gt;(…)</code><br><code>path::&lt;…&gt;</code></td><td><a href="items.generics">generic arguments</a>, aka turbofish</td></tr>
<tr><td><code>()</code></td><td><a href="type.tuple.unit">unit</a></td></tr>
<tr><td><code>(expr)</code></td><td><a href="expr.paren">parenthesized expressions</a></td></tr>
<tr><td><code>(expr,)</code></td><td><a href="expr.tuple">single-element tuple expressions</a></td></tr>
<tr><td><code>(expr, …)</code></td><td><a href="expr.tuple">tuple expressions</a></td></tr>
<tr><td><code>expr(expr, …)</code></td><td><a href="expr.call">call expressions</a></td></tr>
<tr><td><code>expr.0</code>, <code>expr.1</code>, …</td><td><a href="expr.tuple-index">tuple indexing expressions</a></td></tr>
<tr><td><code>expr.ident</code></td><td><a href="expr.field">field access expressions</a></td></tr>
<tr><td><code>{…}</code></td><td><a href="expr.block">block expressions</a></td></tr>
<tr><td><code>Type {…}</code></td><td><a href="expr.struct">struct expressions</a></td></tr>
<tr><td><code>Type(…)</code></td><td><a href="items.struct.tuple">tuple struct constructors</a></td></tr>
<tr><td><code>[…]</code></td><td><a href="expr.array">array expressions</a></td></tr>
<tr><td><code>[expr; len]</code></td><td><a href="expr.array">repeat array expressions</a></td></tr>
<tr><td><code>expr[..]</code>, <code>expr[a..]</code>, <code>expr[..b]</code>, <code>expr[a..b]</code>, <code>expr[a..=b]</code>, <code>expr[..=b]</code></td><td><a href="expr.array.index">array and slice indexing expressions</a></td></tr>
<tr><td><code>if expr {…} else {…}</code></td><td><a href="expr.if">if expressions</a></td></tr>
<tr><td><code>match expr { pattern =&gt; {…} }</code></td><td><a href="expr.match">match expressions</a></td></tr>
<tr><td><code>loop {…}</code></td><td><a href="expr.loop.infinite">infinite loop expressions</a></td></tr>
<tr><td><code>while expr {…}</code></td><td><a href="expr.loop.while">predicate loop expressions</a></td></tr>
<tr><td><code>for pattern in expr {…}</code></td><td><a href="expr.loop.for">iterator loops</a></td></tr>
<tr><td><code>&amp;expr</code><br><code>&amp;mut expr</code></td><td><a href="expr.operator.borrow">borrow expressions</a></td></tr>
<tr><td><code>&amp;raw const expr</code><br><code>&amp;raw mut expr</code></td><td><a href="expr.borrow.raw">raw borrow expressions</a></td></tr>
<tr><td><code>*expr</code></td><td><a href="expr.deref">dereference expressions</a></td></tr>
<tr><td><code>expr?</code></td><td><a href="expr.try">try propagation expressions</a></td></tr>
<tr><td><code>-expr</code></td><td><a href="expr.negate">negation expressions</a></td></tr>
<tr><td><code>!expr</code></td><td><a href="expr.negate">bitwise and logical NOT expressions</a></td></tr>
<tr><td><code>expr as Type</code></td><td><a href="expr.as">type cast expressions</a></td></tr>
</tbody></table>
</div>
<h2 id="아이템-1"><a class="header" href="#아이템-1">아이템</a></h2>
<p>[Items] are the components of a crate.</p>
<div class="table-wrapper"><table><thead><tr><th>Item</th><th>Use</th></tr></thead><tbody>
<tr><td><code>mod ident;</code><br><code>mod ident {…}</code></td><td><a href="items.mod">modules</a></td></tr>
<tr><td><code>use path;</code></td><td><a href="items.use">use declarations</a></td></tr>
<tr><td><code>fn ident(…) {…}</code></td><td><a href="items.fn">functions</a></td></tr>
<tr><td><code>type Type = Type;</code></td><td><a href="items.type">type aliases</a></td></tr>
<tr><td><code>struct ident {…}</code></td><td><a href="items.struct">structs</a></td></tr>
<tr><td><code>enum ident {…}</code></td><td><a href="items.enum">enumerations</a></td></tr>
<tr><td><code>union ident {…}</code></td><td><a href="items.union">unions</a></td></tr>
<tr><td><code>trait ident {…}</code></td><td><a href="items.traits">traits</a></td></tr>
<tr><td><code>impl Type {…}</code><br><code>impl Type for Trait {…}</code></td><td><a href="items.impl">implementations</a></td></tr>
<tr><td><code>const ident = expr;</code></td><td><a href="items.const">constant items</a></td></tr>
<tr><td><code>static ident = expr;</code></td><td><a href="items.static">static items</a></td></tr>
<tr><td><code>extern "C" {…}</code></td><td><a href="items.extern">external blocks</a></td></tr>
<tr><td><code>fn ident&lt;…&gt;(…) …</code><br><code>struct ident&lt;…&gt; {…}</code><br><code>enum ident&lt;…&gt; {…}</code><br><code>impl&lt;…&gt; Type&lt;…&gt; {…}</code></td><td><a href="items.generics">generic definitions</a></td></tr>
</tbody></table>
</div>
<h2 id="타입-표현식-1"><a class="header" href="#타입-표현식-1">타입 표현식</a></h2>
<p><a href="type.name">Type expressions</a> are used to refer to types.</p>
<div class="table-wrapper"><table><thead><tr><th>유형</th><th>Use</th></tr></thead><tbody>
<tr><td><code>bool</code>, <code>u8</code>, <code>f64</code>, <code>str</code>, …</td><td><a href="type.kinds">primitive types</a></td></tr>
<tr><td><code>for&lt;…&gt;</code></td><td><a href="bound.higher-ranked">higher-ranked trait bounds</a></td></tr>
<tr><td><code>T: TraitA + TraitB</code></td><td><a href="bound">trait bounds</a></td></tr>
<tr><td><code>T: 'a + 'b</code></td><td><a href="bound.lifetime">lifetime bounds</a></td></tr>
<tr><td><code>T: TraitA + 'a</code></td><td><a href="bound">trait and lifetime bounds</a></td></tr>
<tr><td><code>T: ?Sized</code></td><td><a href="bound.sized">relaxed trait bounds</a></td></tr>
<tr><td><code>[Type; len]</code></td><td><a href="type.array">array types</a></td></tr>
<tr><td><code>(Type, …)</code></td><td><a href="type.tuple">tuple types</a></td></tr>
<tr><td><code>[Type]</code></td><td><a href="type.slice">slice types</a></td></tr>
<tr><td><code>(Type)</code></td><td><a href="type.name.parenthesized">parenthesized types</a></td></tr>
<tr><td><code>impl Trait</code></td><td><a href="type.impl-trait.return">impl trait types</a>, <a href="type.impl-trait.param">anonymous type parameters</a></td></tr>
<tr><td><code>dyn Trait</code></td><td><a href="type.trait-object">trait object types</a></td></tr>
<tr><td><code>ident</code><br><code>ident::…</code></td><td><a href="type.name.path">type paths</a> (can refer to <a href="items.struct">structs</a>, <a href="items.enum">enumerations</a>, <a href="items.union">unions</a>, <a href="items.type">type aliases</a>, <a href="items.traits">traits</a>, <a href="items.generics">generics</a>, etc.)</td></tr>
<tr><td><code>Type&lt;…&gt;</code><br><code>Trait&lt;…&gt;</code></td><td><a href="items.generics">generic arguments</a> (e.g. <code>Vec&lt;u8&gt;</code>)</td></tr>
<tr><td><code>Trait&lt;ident = Type&gt;</code></td><td><a href="paths.expr">associated type bindings</a> (e.g. <code>Iterator&lt;Item = T&gt;</code>)</td></tr>
<tr><td><code>Trait&lt;ident: …&gt;</code></td><td><a href="paths.expr">associated type bounds</a> (e.g. <code>Iterator&lt;Item: Send&gt;</code>)</td></tr>
<tr><td><code>&amp;Type</code><br><code>&amp;mut Type</code></td><td><a href="type.pointer.reference">reference types</a></td></tr>
<tr><td><code>*mut Type</code><br><code>*const Type</code></td><td><a href="type.pointer.raw">raw pointer types</a></td></tr>
<tr><td><code>fn(…) -&gt; Type</code></td><td><a href="type.fn-pointer">function pointer types</a></td></tr>
<tr><td><code>_</code></td><td><a href="type.inferred">inferred type</a>, <a href="items.generics.const.inferred">inferred const</a></td></tr>
<tr><td><code>'_</code></td><td><a href="lifetime-elision.function.explicit-placeholder">placeholder lifetime</a></td></tr>
<tr><td><code>!</code></td><td><a href="type.never">never type</a></td></tr>
</tbody></table>
</div>
<h2 id="패턴-1"><a class="header" href="#패턴-1">패턴</a></h2>
<p>[Patterns] are used to match values.</p>
<div class="table-wrapper"><table><thead><tr><th>Pattern</th><th>Use</th></tr></thead><tbody>
<tr><td><code>"foo"</code>, <code>'a'</code>, <code>123</code>, <code>2.4</code>, …</td><td><a href="patterns.literal">literal patterns</a></td></tr>
<tr><td><code>ident</code></td><td><a href="patterns.ident">identifier patterns</a></td></tr>
<tr><td><code>_</code></td><td><a href="patterns.wildcard">wildcard pattern</a></td></tr>
<tr><td><code>..</code></td><td><a href="patterns.rest">rest pattern</a></td></tr>
<tr><td><code>a..</code>, <code>..b</code>, <code>a..b</code>, <code>a..=b</code>, <code>..=b</code></td><td><a href="patterns.range">range patterns</a></td></tr>
<tr><td><code>&amp;pattern</code><br><code>&amp;mut pattern</code></td><td><a href="patterns.ref">reference patterns</a></td></tr>
<tr><td><code>path {…}</code></td><td><a href="patterns.struct">struct patterns</a></td></tr>
<tr><td><code>path(…)</code></td><td><a href="patterns.tuple-struct">tuple struct patterns</a></td></tr>
<tr><td><code>(pattern, …)</code></td><td><a href="patterns.tuple">tuple patterns</a></td></tr>
<tr><td><code>(pattern)</code></td><td><a href="patterns.paren">grouped patterns</a></td></tr>
<tr><td><code>[pattern, …]</code></td><td><a href="patterns.slice">slice patterns</a></td></tr>
<tr><td><code>CONST</code>, <code>Enum::Variant</code>, …</td><td><a href="patterns.path">path patterns</a></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><p>r[macro.ambiguity]</p>
<h1 id="appendix-macro-follow-set-ambiguity-formal-specification"><a class="header" href="#appendix-macro-follow-set-ambiguity-formal-specification">Appendix: Macro follow-set ambiguity formal specification</a></h1>
<p>이 페이지는 <a href="macros-by-example.html">예제를 통한 매크로</a>를 위한 follow 규칙의 공식 명세를 문서화합니다. 이 규칙들은 원래 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.md">RFC 550</a>에서 명시되었으며, 이 텍스트의 대부분은 해당 RFC에서 복사되고 이후의 RFC들에서 확장된 것입니다.</p>
<p>r[macro.ambiguity.convention]</p>
<h2 id="definitions--conventions"><a class="header" href="#definitions--conventions">Definitions &amp; conventions</a></h2>
<p>r[macro.ambiguity.convention.defs]</p>
<ul>
<li><code>macro</code>: 소스 코드에서 <code>foo!(...)</code>와 같이 호출 가능한 모든 것.</li>
<li><code>MBE</code>: 예제를 통한 매크로(macro-by-example), <code>macro_rules</code>에 의해 정의된 매크로.</li>
<li><code>matcher</code>: <code>macro_rules</code> 호출 내 규칙의 왼쪽 부분(LHS), 또는 그 일부분.</li>
<li><code>macro parser</code>: 모든 매처(matchers)로부터 파생된 문법을 사용하여 입력을 파싱하는 러스트 파서 내의 코드 조각.</li>
<li><code>fragment</code>: 주어진 매처가 수용할(또는 “일치시킬”) 러스트 구문 클래스.</li>
<li><code>repetition</code>: 규칙적인 반복 패턴을 따르는 프래그먼트.</li>
<li><code>NT</code>: 비단말(non-terminal), 매처에 나타날 수 있는 다양한 “메타 변수” 또는 반복 매처. MBE 구문에서 시작 부분의 <code>$</code> 문자로 지정됩니다.</li>
<li><code>simple NT</code>: “메타 변수” 비단말 (아래에서 더 자세히 논의됨).</li>
<li><code>complex NT</code>: 반복 연산자(<code>*</code>, <code>+</code>, <code>?</code>)를 통해 지정된, 반복 일치 비단말.</li>
<li><code>token</code>: 매처의 원자적 요소. 즉, 식별자, 연산자, 여는/닫는 구분자, <em>그리고</em> 단순 NT(simple NT).</li>
<li><code>token tree</code>: 토큰(리프), 복합 NT(complex NT), 그리고 토큰 트리의 유한 시퀀스로 형성된 트리 구조.</li>
<li><code>delimiter token</code>: 한 프래그먼트의 끝과 다음 프래그먼트의 시작을 나누기 위한 토큰.</li>
<li><code>separator token</code>: 복합 NT에서 일치된 반복의 각 요소 쌍을 구분하는 선택적인 구분자 토큰.</li>
<li><code>separated complex NT</code>: 자체 구분자 토큰을 가진 복합 NT.</li>
<li><code>delimited sequence</code>: 시퀀스의 시작과 끝에 적절한 여는 구분자와 닫는 구분자가 있는 토큰 트리 시퀀스.</li>
<li><code>empty fragment</code>: 토큰을 구분하는 보이지 않는 러스트 구문 클래스. 즉, 공백(whitespace) 또는 (일부 어휘 문맥에서) 빈 토큰 시퀀스.</li>
<li><code>fragment specifier</code>: 단순 NT(simple NT)에서 해당 NT가 수용하는 프래그먼트를 지정하는 식별자.</li>
<li><code>language</code>: 문맥 자유 언어(context-free language).</li>
</ul>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! i_am_an_mbe {
    (start $foo:expr $($i:ident),* end) =&gt; ($foo)
}
<span class="boring">}</span></code></pre></pre>
<p>r[macro.ambiguity.convention.matcher] <code>(start $foo:expr $($i:ident),* end)</code> is a matcher. The whole matcher is a delimited sequence (with open- and close-delimiters <code>(</code> and <code>)</code>), and <code>$foo</code> and <code>$i</code> are simple NT’s with <code>expr</code> and <code>ident</code> as their respective fragment specifiers.</p>
<p>r[macro.ambiguity.convention.complex-nt] <code>$(i:ident),*</code> is <em>also</em> an NT; it is a complex NT that matches a comma-separated repetition of identifiers. The <code>,</code> is the separator token for the complex NT; it occurs in between each pair of elements (if any) of the matched fragment.</p>
<p>형태의 프래그먼트 중 <code>hi &lt;expr&gt;;</code>가 최소 한 번 이상 나타나는 것과 일치합니다. 이 복합 NT는 전용 구분자 토큰을 가지고 있지 않음에 유의하십시오.</p>
<p>(러스트의 파서는 구분된 시퀀스가 항상 토큰 트리 구조의 적절한 중첩과 여는/닫는 구분자의 올바른 일치와 함께 발생하도록 보장함에 유의하십시오.)</p>
<p>r[macro.ambiguity.convention.vars] We will tend to use the variable “M” to stand for a matcher, variables “t” and “u” for arbitrary individual tokens, and the variables “tt” and “uu” for arbitrary token trees. (The use of “tt” does present potential ambiguity with its additional role as a fragment specifier; but it will be clear from context which interpretation is meant.)</p>
<p>r[macro.ambiguity.convention.set] “SEP” will range over separator tokens, “OP” over the repetition operators <code>*</code>, <code>+</code>, and <code>?</code>, “OPEN”/“CLOSE” over matching token pairs surrounding a delimited sequence (e.g. <code>[</code> and <code>]</code>).</p>
<p>r[macro.ambiguity.convention.sequence-vars] Greek letters “α” “β” “γ” “δ”  stand for potentially empty token-tree sequences. (However, the Greek letter “ε” (epsilon) has a special role in the presentation and does not stand for a token-tree sequence.)</p>
<ul>
<li>이 그리스 문자 관례는 대개 시퀀스의 존재가 기술적인 세부 사항일 때만 채택됩니다. 특히, 우리가 토큰 트리 시퀀스에 대해 작업하고 있음을 _강조_하고자 할 때는 그리스 문자가 아닌 “tt …“라는 표기법을 사용합니다.</li>
</ul>
<p>매처는 단지 하나의 토큰 트리라는 점에 유의하십시오. 위에서 언급했듯이 “단순 NT“는 메타 변수 NT이며, 따라서 반복이 아닙니다. 예를 들어 <code>$foo:ty</code>는 단순 NT이지만 <code>$($foo:ty)+</code>는 복합 NT입니다.</p>
<p>또한 이 형식화된 체계(formalism)의 문맥에서 “토큰“이라는 용어는 일반적으로 단순 NT를 _포함_함에 유의하십시오.</p>
<p>마지막으로, 독자 여러분은 이 형식화된 체계의 정의에 따라 어떤 단순 NT도 빈 프래그먼트와 일치하지 않으며, 마찬가지로 어떤 토큰도 러스트 구문의 빈 프래그먼트와 일치하지 않는다는 점을 기억하는 것이 유용합니다. (따라서 빈 프래그먼트와 일치할 수 있는 <em>유일한</em> NT는 복합 NT뿐입니다.) 이는 실제로 사실이 아닌데, 왜냐하면 <code>vis</code> 매처는 빈 프래그먼트와 일치할 수 있기 때문입니다. 따라서 이 체계의 목적을 위해 우리는 <code>$v:vis</code>를 실제로는 <code>$($v:vis)?</code>인 것처럼 취급할 것이며, 매처가 빈 프래그먼트와 일치해야 한다는 요구 사항을 둘 것입니다.</p>
<p>r[macro.ambiguity.invariant]</p>
<h3 id="the-matcher-invariants"><a class="header" href="#the-matcher-invariants">The matcher invariants</a></h3>
<p>r[macro.ambiguity.invariant.list] To be valid, a matcher must meet the following three invariants. The definitions of FIRST and FOLLOW are described later.</p>
<ol>
<li>매처 <code>M</code> 내의 임의의 두 연속된 토큰 트리 시퀀스(<code>M = ... tt uu ...</code>)에 대해 <code>uu ...</code>가 비어 있지 않다면, FOLLOW(<code>... tt</code>) ∪ {ε} ⊇ FIRST(<code>uu ...</code>)를 만족해야 합니다.</li>
<li>매처 내의 임의의 구분된 복합 NT <code>M = ... $(tt ...) SEP OP ...</code>에 대해, <code>SEP</code> ∈ FOLLOW(<code>tt ...</code>)여야 합니다.</li>
<li>매처 내의 구분되지 않은 복합 NT <code>M = ... $(tt ...) OP ...</code>에 대해, OP = <code>*</code> 또는 <code>+</code>인 경우, FOLLOW(<code>tt ...</code>) ⊇ FIRST(<code>tt ...</code>)여야 합니다.</li>
</ol>
<p>r[macro.ambiguity.invariant.follow-matcher] The first invariant says that whatever actual token that comes after a matcher, if any, must be somewhere in the predetermined follow set.  This ensures that a legal macro definition will continue to assign the same determination as to where <code>... tt</code> ends and <code>uu ...</code> begins, even as new syntactic forms are added to the language.</p>
<p>r[macro.ambiguity.invariant.separated-complex-nt] The second invariant says that a separated complex NT must use a separator token that is part of the predetermined follow set for the internal contents of the NT. This ensures that a legal macro definition will continue to parse an input fragment into the same delimited sequence of <code>tt ...</code>’s, even as new syntactic forms are added to the language.</p>
<p>r[macro.ambiguity.invariant.unseparated-complex-nt] The third invariant says that when we have a complex NT that can match two or more copies of the same thing with no separation in between, it must be permissible for them to be placed next to each other as per the first invariant. This invariant also requires they be nonempty, which eliminates a possible ambiguity.</p>
<p><strong>참고: 세 번째 불변성은 과거의 실수와 해당 동작에 대한 상당한 의존성 때문에 현재 강제되지 않고 있습니다. 앞으로 이에 대해 어떻게 할지는 현재 결정되지 않았습니다. 이 동작을 준수하지 않는 매크로는 미래의 러스트 에디션에서 유효하지 않게 될 수 있습니다. <a href="https://github.com/rust-lang/rust/issues/56575">트래킹 이슈</a>를 참조하십시오.</strong></p>
<p>r[macro.ambiguity.sets]</p>
<h3 id="비공식적인-first-및-follow"><a class="header" href="#비공식적인-first-및-follow">비공식적인 FIRST 및 FOLLOW</a></h3>
<p>r[macro.ambiguity.sets.intro] A given matcher M maps to three sets: FIRST(M), LAST(M) and FOLLOW(M).</p>
<p>이 세 가지 집합은 각각 토큰들로 구성됩니다. FIRST(M)과 LAST(M)은 또한 M이 빈 프래그먼트와 일치할 수 있음을 나타내는 구별된 비토큰 요소 ε(“입실론”)을 포함할 수 있습니다. (단, FOLLOW(M)은 항상 토큰들의 집합입니다.)</p>
<p>비공식적으로는 다음과 같습니다:</p>
<p>r[macro.ambiguity.sets.first]</p>
<ul>
<li>FIRST(M): 프래그먼트를 M과 일치시킬 때 잠재적으로 가장 먼저 사용되는 토큰들을 수집합니다.</li>
</ul>
<p>r[macro.ambiguity.sets.last]</p>
<ul>
<li>LAST(M): 프래그먼트를 M과 일치시킬 때 잠재적으로 가장 마지막에 사용되는 토큰들을 수집합니다.</li>
</ul>
<p>r[macro.ambiguity.sets.follow]</p>
<ul>
<li>
<p>FOLLOW(M): M과 일치하는 어떤 프래그먼트 직후에 올 수 있도록 허용된 토큰들의 집합입니다.</p>
<p>다시 말해, t ∈ FOLLOW(M)일 필요충분조건은 다음을 만족하는 (잠재적으로 비어 있을 수 있는) 토큰 시퀀스 α, β, γ, δ가 존재하는 것입니다.</p>
<ul>
<li>
<p>M이 β와 일치하고,</p>
</li>
<li>
<p>t가 γ와 일치하며,</p>
</li>
<li>
<p>α β γ δ를 연결한 결과가 파싱 가능한 러스트 프로그램인 경우.</p>
</li>
</ul>
</li>
</ul>
<p>r[macro.ambiguity.sets.universe] We use the shorthand ANYTOKEN to denote the set of all tokens (including simple NTs). For example, if any token is legal after a matcher M, then FOLLOW(M) = ANYTOKEN.</p>
<p>(위의 비공식적인 설명에 대한 이해를 점검하기 위해, 독자 여러분은 공식 정의를 읽기 전에 <a href="macro-ambiguity.html#examples-of-first-and-last">FIRST/LAST의 예시</a>로 건너뛰어 확인해 볼 수 있습니다.)</p>
<p>r[macro.ambiguity.sets.def]</p>
<h3 id="first-last"><a class="header" href="#first-last">FIRST, LAST</a></h3>
<p>r[macro.ambiguity.sets.def.intro] Below are formal inductive definitions for FIRST and LAST.</p>
<p>r[macro.ambiguity.sets.def.notation] “A ∪ B” denotes set union, “A ∩ B” denotes set intersection, and “A \ B” denotes set difference (i.e. all elements of A that are not present in B).</p>
<p>r[macro.ambiguity.sets.def.first]</p>
<h4 id="first"><a class="header" href="#first">FIRST</a></h4>
<p>r[macro.ambiguity.sets.def.first.intro] FIRST(M) is defined by case analysis on the sequence M and the structure of its first token-tree (if any):</p>
<p>r[macro.ambiguity.sets.def.first.epsilon]</p>
<ul>
<li>M이 빈 시퀀스라면, FIRST(M) = { ε }입니다.</li>
</ul>
<p>r[macro.ambiguity.sets.def.first.token]</p>
<ul>
<li>
<p>M이 토큰 t로 시작한다면, FIRST(M) = { t }입니다.</p>
<p>(참고: 이는 M이 구분된 토큰 트리 시퀀스로 시작하는 경우 <code>M = OPEN tt ... CLOSE ...</code>를 포함하며, 이 경우 <code>t = OPEN</code>이므로 FIRST(M) = { <code>OPEN</code> }이 됩니다.)</p>
<p>(참고: 이는 어떤 단순 NT도 빈 프래그먼트와 일치하지 않는다는 속성에 결정적으로 의존합니다.)</p>
</li>
</ul>
<p>r[macro.ambiguity.sets.def.first.complex]</p>
<ul>
<li>
<p>그 외의 경우, M은 복합 NT로 시작하는 토큰 트리 시퀀스입니다: <code>M = $( tt ... ) OP α</code>, 또는 <code>M = $( tt ... ) SEP OP α</code> (여기서 <code>α</code>는 매처의 나머지 부분인, 잠재적으로 비어 있을 수 있는 토큰 트리 시퀀스입니다).</p>
<ul>
<li>SEP가 존재하고 ε ∈ FIRST(<code>tt ...</code>)라면 SEP_SET(M) = { SEP }이고, 그렇지 않으면 SEP_SET(M) = {}라고 합시다.</li>
</ul>
</li>
<li>
<p>OP가 <code>*</code> 또는 <code>?</code>라면 ALPHA_SET(M) = FIRST(<code>α</code>)이고, OP가 <code>+</code>라면 ALPHA_SET(M) = {}라고 합시다.</p>
</li>
<li>
<p>FIRST(M) = (FIRST(<code>tt ...</code>) \ {ε}) ∪ SEP_SET(M) ∪ ALPHA_SET(M)입니다.</p>
</li>
</ul>
<p>복합 NT에 대한 정의는 정당화될 필요가 있습니다. SEP_SET(M)은 구분자가 정의되어 있고 반복되는 프래그먼트가 비어 있을 수 있는 경우, 구분자가 M의 유효한 첫 번째 토큰이 될 수 있는 가능성을 정의합니다. ALPHA_SET(M)은 복합 NT가 비어 있을 수 있는 가능성을 정의하며, 이는 M의 유효한 첫 번째 토큰들이 뒤따르는 토큰 트리 시퀀스 <code>α</code>의 토큰들임을 의미합니다. 이는 <code>*</code> 또는 <code>?</code>가 사용되어 반복 횟수가 0일 수 있는 경우에 발생합니다. 이론적으로는 잠재적으로 비어 있을 수 있는 반복 프래그먼트와 함께 <code>+</code>가 사용된 경우에도 발생할 수 있으나, 이는 세 번째 불변성에 의해 금지됩니다.</p>
<p>그 지점으로부터, FIRST(M)은 SEP_SET(M) 또는 ALPHA_SET(M)의 모든 토큰을 포함할 수 있으며, 복합 NT 일치가 비어 있지 않다면 FIRST(<code>tt ...</code>)로 시작하는 모든 토큰 또한 가능합니다. 마지막으로 고려할 부분은 ε입니다. SEP_SET(M)과 FIRST(<code>tt ...</code>) \ {ε}은 ε을 포함할 수 없지만, ALPHA_SET(M)은 포함할 수 있습니다. 따라서 이 정의는 ε ∈ ALPHA_SET(M)인 경우에만 M이 ε을 수용하도록 허용합니다. 이는 복합 NT 사례에서 M이 ε을 수용하려면 복합 NT와 α가 모두 이를 수용해야 하기 때문에 정확합니다. 만약 OP = <code>+</code>라면, 복합 NT가 비어 있을 수 없음을 의미하므로 정의에 따라 ε ∉ ALPHA_SET(M)입니다. 그 외의 경우 복합 NT는 0번의 반복을 수용할 수 있으며, 이때 ALPHA_SET(M) = FOLLOW(<code>α</code>)가 됩니다. 따라서 이 정의는 ε에 대해서도 정확합니다.</p>
<p>r[macro.ambiguity.sets.def.last]</p>
<h4 id="last"><a class="header" href="#last">LAST</a></h4>
<p>r[macro.ambiguity.sets.def.last.intro] LAST(M), defined by case analysis on M itself (a sequence of token-trees):</p>
<p>r[macro.ambiguity.sets.def.last.empty]</p>
<ul>
<li>M이 빈 시퀀스라면, LAST(M) = { ε }입니다.</li>
</ul>
<p>r[macro.ambiguity.sets.def.last.token]</p>
<ul>
<li>M이 단일 토큰 t라면, LAST(M) = { t }입니다.</li>
</ul>
<p>r[macro.ambiguity.sets.def.last.rep-star]</p>
<ul>
<li>
<p>M이 0번 이상 반복되는 단일 복합 NT인 경우, <code>M = $( tt ... ) *</code> 또는 <code>M = $( tt ... ) SEP *</code>입니다.</p>
<ul>
<li>
<p>SEP가 존재한다면 sep_set = { SEP }이고, 그렇지 않으면 sep_set = {}라고 합시다.</p>
</li>
<li>
<p>ε ∈ LAST(<code>tt ...</code>)라면 LAST(M) = LAST(<code>tt ...</code>) ∪ sep_set입니다.</p>
</li>
<li>
<p>그 외의 경우, 시퀀스 <code>tt ...</code>는 반드시 비어 있지 않아야 합니다. LAST(M) = LAST(<code>tt ...</code>) ∪ {ε}입니다.</p>
</li>
</ul>
</li>
</ul>
<p>r[macro.ambiguity.sets.def.last.rep-plus]</p>
<ul>
<li>
<p>M이 1번 이상 반복되는 단일 복합 NT인 경우, <code>M = $( tt ... ) +</code> 또는 <code>M = $( tt ... ) SEP +</code>입니다.</p>
<ul>
<li>
<p>SEP가 존재한다면 sep_set = { SEP }이고, 그렇지 않으면 sep_set = {}라고 합시다.</p>
</li>
<li>
<p>ε ∈ LAST(<code>tt ...</code>)라면 LAST(M) = LAST(<code>tt ...</code>) ∪ sep_set입니다.</p>
</li>
<li>
<p>그 외의 경우, 시퀀스 <code>tt ...</code>는 반드시 비어 있지 않아야 합니다. LAST(M) = LAST(<code>tt ...</code>)입니다.</p>
</li>
</ul>
</li>
</ul>
<p>r[macro.ambiguity.sets.def.last.rep-question]</p>
<ul>
<li>M이 0번 또는 1번 반복되는 단일 복합 NT인 경우(<code>M = $( tt ...) ?</code>), LAST(M) = LAST(<code>tt ...</code>) ∪ {ε}입니다.</li>
</ul>
<p>r[macro.ambiguity.sets.def.last.delim]</p>
<ul>
<li>M이 구분된 토큰 트리 시퀀스 <code>OPEN tt ... CLOSE</code>인 경우, LAST(M) = { <code>CLOSE</code> }입니다.</li>
</ul>
<p>r[macro.ambiguity.sets.def.last.sequence]</p>
<ul>
<li>
<p>M이 비어 있지 않은 토큰 트리 시퀀스 <code>tt uu ...</code>인 경우,</p>
<ul>
<li>
<p>ε ∈ LAST(<code>uu ...</code>)라면, LAST(M) = LAST(<code>tt</code>) ∪ (LAST(<code>uu ...</code>) \ { ε })입니다.</p>
</li>
<li>
<p>그 외의 경우, 시퀀스 <code>uu ...</code>는 반드시 비어 있지 않아야 하며, LAST(M) = LAST(<code>uu ...</code>)입니다.</p>
</li>
</ul>
</li>
</ul>
<h3 id="first-및-last의-예시"><a class="header" href="#first-및-last의-예시">FIRST 및 LAST의 예시</a></h3>
<p>다음은 FIRST와 LAST의 몇 가지 예시입니다. (특히 입력 조각들 사이의 상호 작용에 따라 특별한 ε 요소가 어떻게 도입되고 제거되는지 유의하십시오.)</p>
<p>첫 번째 예시는 매처 분석이 어떻게 구성되는지 상세히 설명하기 위해 트리 구조로 제시됩니다. (일부 단순한 서브트리들은 생략되었습니다.)</p>
<pre><code class="language-text">INPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+   g
            ~~~~~~~~   ~~~~~~~                ~
                |         |                   |
FIRST:   { $d:ident }  { $e:expr }          { h }


INPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+
            ~~~~~~~~~~~~~~~~~~             ~~~~~~~           ~~~
                        |                      |               |
FIRST:          { $d:ident }               { h, ε }         { f }

INPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+   g
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~    ~~~~~~~~~~~~~~    ~~~~~~~~~   ~
                        |                       |              |       |
FIRST:        { $d:ident, ε }            {  h, ε, ;  }      { f }   { g }


INPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+   g
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                                        |
FIRST:                       { $d:ident, h, ;,  f }
</code></pre>
<p>따라서:</p>
<ul>
<li>FIRST(<code>$($d:ident $e:expr );* $( $(h)* );* $( f ;)+ g</code>) = { <code>$d:ident</code>, <code>h</code>, <code>;</code>, <code>f</code> }</li>
</ul>
<p>하지만 다음 사항에 유의하십시오:</p>
<ul>
<li>FIRST(<code>$($d:ident $e:expr );* $( $(h)* );* $($( f ;)+ g)*</code>) = { <code>$d:ident</code>, <code>h</code>, <code>;</code>, <code>f</code>, ε }</li>
</ul>
<p>다음은 LAST에 대한 유사한 예시들입니다.</p>
<ul>
<li>LAST(<code>$d:ident $e:expr</code>) = { <code>$e:expr</code> }</li>
<li>LAST(<code>$( $d:ident $e:expr );*</code>) = { <code>$e:expr</code>, ε }</li>
<li>LAST(<code>$( $d:ident $e:expr );* $(h)*</code>) = { <code>$e:expr</code>, ε, <code>h</code> }</li>
<li>LAST(<code>$( $d:ident $e:expr );* $(h)* $( f ;)+</code>) = { <code>;</code> }</li>
<li>LAST(<code>$( $d:ident $e:expr );* $(h)* $( f ;)+ g</code>) = { <code>g</code> }</li>
</ul>
<p>r[macro.ambiguity.sets.def.follow]</p>
<h3 id="followm"><a class="header" href="#followm">FOLLOW(M)</a></h3>
<p>r[macro.ambiguity.sets.def.follow.intro] Finally, the definition for FOLLOW(M) is built up as follows. pat, expr, etc. represent simple nonterminals with the given fragment specifier.</p>
<p>r[macro.ambiguity.sets.def.follow.pat]</p>
<ul>
<li>FOLLOW(pat) = {<code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>|</code>, <code>if</code>, <code>in</code>}입니다.</li>
</ul>
<p>r[macro.ambiguity.sets.def.follow.expr-stmt]</p>
<ul>
<li>FOLLOW(expr) = FOLLOW(expr_2021) = FOLLOW(stmt) =  {<code>=&gt;</code>, <code>,</code>, <code>;</code>}입니다.</li>
</ul>
<p>r[macro.ambiguity.sets.def.follow.ty-path]</p>
<ul>
<li>FOLLOW(ty) = FOLLOW(path) = {<code>{</code>, <code>[</code>, <code>,</code>, <code>=&gt;</code>, <code>:</code>, <code>=</code>, <code>&gt;</code>, <code>&gt;&gt;</code>, <code>;</code>, <code>|</code>, <code>as</code>, <code>where</code>, block 비단말}입니다.</li>
</ul>
<p>r[macro.ambiguity.sets.def.follow.vis]</p>
<ul>
<li>FOLLOW(vis) = {<code>,</code>l 원시(raw)가 아닌 <code>priv</code>를 제외한 모든 키워드 또는 식별자; 타입을 시작할 수 있는 모든 토큰; ident, ty, 그리고 path 비단말}입니다.</li>
</ul>
<p>r[macro.ambiguity.sets.def.follow.simple]</p>
<ul>
<li>FOLLOW(t) = ANYTOKEN (block, ident, tt, item, lifetime, literal, meta 단순 비단말 및 모든 단말(terminals)을 포함한 다른 모든 단순 토큰의 경우).</li>
</ul>
<p>r[macro.ambiguity.sets.def.follow.other-matcher]</p>
<ul>
<li>다른 모든 M에 대해 FOLLOW(M)은, t가 (LAST(M) \ {ε})의 범위에 있을 때 FOLLOW(t)의 교집합으로 정의됩니다.</li>
</ul>
<p>r[macro.ambiguity.sets.def.follow.type-first] The tokens that can begin a type are, as of this writing, {<code>(</code>, <code>[</code>, <code>!</code>, <code>*</code>, <code>&amp;</code>, <code>&amp;&amp;</code>, <code>?</code>, lifetimes, <code>&gt;</code>, <code>&gt;&gt;</code>, <code>::</code>, any non-keyword identifier, <code>super</code>, <code>self</code>, <code>Self</code>, <code>extern</code>, <code>crate</code>, <code>$crate</code>, <code>_</code>, <code>for</code>, <code>impl</code>, <code>fn</code>, <code>unsafe</code>, <code>typeof</code>, <code>dyn</code>}, although this list may not be complete because people won’t always remember to update the appendix when new ones are added.</p>
<p>복합 M에 대한 FOLLOW의 예시:</p>
<ul>
<li>FOLLOW(<code>$( $d:ident $e:expr )*</code>) = FOLLOW(<code>$e:expr</code>)</li>
<li>FOLLOW(<code>$( $d:ident $e:expr )* $(;)*</code>) = FOLLOW(<code>$e:expr</code>) ∩ ANYTOKEN = FOLLOW(<code>$e:expr</code>)</li>
<li>FOLLOW(<code>$( $d:ident $e:expr )* $(;)* $( f |)+</code>) = ANYTOKEN</li>
</ul>
<h3 id="유효하거나-유효하지-않은-매처의-예시"><a class="header" href="#유효하거나-유효하지-않은-매처의-예시">유효하거나 유효하지 않은 매처의 예시</a></h3>
<p>위의 명세를 바탕으로, 특정 매처가 왜 적법하고 다른 것들은 그렇지 않은지에 대한 논거를 제시할 수 있습니다.</p>
<ul>
<li>
<p><code>($ty:ty &lt; foo ,)</code> : 부적법. FIRST(<code>&lt; foo ,</code>) = { <code>&lt;</code> } ⊈ FOLLOW(<code>ty</code>)이기 때문입니다.</p>
</li>
<li>
<p><code>($ty:ty , foo &lt;)</code> : 적법. FIRST(<code>, foo &lt;</code>) = { <code>,</code> } ⊆ FOLLOW(<code>ty</code>)이기 때문입니다.</p>
</li>
<li>
<p><code>($pa:pat $pb:pat $ty:ty ,)</code> : 부적법. FIRST(<code>$pb:pat $ty:ty ,</code>) = { <code>$pb:pat</code> } ⊈ FOLLOW(<code>pat</code>)이고, 또한 FIRST(<code>$ty:ty ,</code>) = { <code>$ty:ty</code> } ⊈ FOLLOW(<code>pat</code>)이기 때문입니다.</p>
</li>
<li>
<p><code>( $($a:tt $b:tt)* ; )</code> : 적법. FIRST(<code>$b:tt</code>) = { <code>$b:tt</code> } ⊆ FOLLOW(<code>tt</code>) = ANYTOKEN이고, FIRST(<code>;</code>) = { <code>;</code> } 또한 ⊆ ANYTOKEN이기 때문입니다.</p>
</li>
<li>
<p><code>( $($t:tt),* , $(t:tt),* )</code> : 적법. (단, 실제로 이 매크로를 사용하려고 시도하면 확장 과정에서 지역적 모호성 오류가 발생합니다.)</p>
</li>
<li>
<p><code>($ty:ty $(; not sep)* -)</code> : 부적법. FIRST(<code>$(; not sep)* -</code>) = { <code>;</code>, <code>-</code> }가 FOLLOW(<code>ty</code>)에 없기 때문입니다.</p>
</li>
<li>
<p><code>($($ty:ty)-+)</code> : 부적법. 구분자 <code>-</code>가 FOLLOW(<code>ty</code>)에 없기 때문입니다.</p>
</li>
<li>
<p><code>($($e:expr)*)</code> : 부적법. expr NT들이 FOLLOW(expr NT)에 없기 때문입니다.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="영향"><a class="header" href="#영향">영향</a></h1>
<p>러스트는 특별히 독창적인 언어는 아니며, 광범위한 소스에서 유래한 설계 요소들을 가지고 있습니다. 그중 일부는 다음과 같습니다(이후에 제거된 요소 포함):</p>
<ul>
<li>SML, OCaml: 대수적 데이터 타입, 패턴 매칭, 타입 추론, 세미콜론을 이용한 구문 분리</li>
<li>C++: 참조, RAII, 스마트 포인터, 이동 세만틱, 단일화(monomorphization), 메모리 모델</li>
<li>ML Kit, Cyclone: 리전(region) 기반 메모리 관리</li>
<li>Haskell (GHC): 타입 클래스, 타입 패밀리</li>
<li>Newsqueak, Alef, Limbo: 채널, 동시성</li>
<li>Erlang: message passing, thread failure, <del>linked thread failure</del>, <del>lightweight concurrency</del></li>
<li>Swift: 옵셔널 바인딩</li>
<li>Scheme: 위생적(hygienic) 매크로</li>
<li>C#: 속성 (attributes)</li>
<li>Ruby: closure syntax, <del>block syntax</del></li>
<li>NIL, Hermes: <del>typestate</del></li>
<li><a href="http://www.unicode.org/reports/tr31/">Unicode Annex #31</a>: 식별자 및 패턴 구문</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="테스트-요약"><a class="header" href="#테스트-요약">테스트 요약</a></h1>
<p>다음은 레퍼런스 내의 개별 규칙 식별자에 연결된 총 테스트 요약입니다.</p>
<p>{{summary-table}}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="용어집"><a class="header" href="#용어집">용어집</a></h1>
<p>r[glossary.ast]</p>
<h3 id="추상-구문-트리-abstract-syntax-tree"><a class="header" href="#추상-구문-트리-abstract-syntax-tree">추상 구문 트리 (Abstract syntax tree)</a></h3>
<p>‘추상 구문 트리’ 또는 ‘AST’는 컴파일러가 프로그램을 컴파일할 때 사용하는 프로그램 구조의 중간 표현입니다.</p>
<h3 id="정렬-alignment"><a class="header" href="#정렬-alignment">정렬 (Alignment)</a></h3>
<p>값의 정렬은 값이 시작되는 선호되는 주소를 지정합니다. 항상 2의 거듭제곱입니다. 값에 대한 참조는 반드시 정렬되어야 합니다. <a href="type-layout.html#size-and-alignment">자세히</a>.</p>
<p>r[glossary.abi]</p>
<h3 id="application-binary-interface-abi-1"><a class="header" href="#application-binary-interface-abi-1">Application binary interface (ABI)</a></h3>
<p>An <em>application binary interface</em> (ABI) defines how compiled code interacts with other compiled code. With <a href="items.extern"><code>extern</code> blocks</a> and <a href="items.fn.extern"><code>extern fn</code></a>, <em>ABI strings</em> affect:</p>
<ul>
<li><strong>Calling convention</strong>: How function arguments are passed, values are returned (e.g., in registers or on the stack), and who is responsible for cleaning up the stack.</li>
<li><strong>Unwinding</strong>: Whether stack unwinding is allowed. For example, the <code>"C-unwind"</code> ABI allows unwinding across the FFI boundary, while the <code>"C"</code> ABI does not.</li>
</ul>
<h3 id="항수-arity"><a class="header" href="#항수-arity">항수 (Arity)</a></h3>
<p>항수는 함수나 연산자가 취하는 인자의 개수를 의미합니다. 예를 들어, <code>f(2, 3)</code>와 <code>g(4, 6)</code>는 항수가 2이고, <code>h(8, 2, 6)</code>는 항수가 3입니다. <code>!</code> 연산자는 항수가 1입니다.</p>
<h3 id="배열-array"><a class="header" href="#배열-array">배열 (Array)</a></h3>
<p>배열(array)은 때로 고정 크기 배열 또는 인라인 배열이라고도 하며, 프로그램이 실행 시간에 계산할 수 있는 인덱스로 각각 선택되는 요소들의 컬렉션을 설명하는 값입니다. 메모리의 연속적인 영역을 차지합니다.배열(array)은 때로 고정 크기 배열 또는 인라인 배열이라고도 하며, 프로그램이 실행 시간에 계산할 수 있는 인덱스로 각각 선택되는 요소들의 컬렉션을 설명하는 값입니다. 메모리의 연속적인 영역을 차지합니다.</p>
<h3 id="연관-아이템"><a class="header" href="#연관-아이템">연관 아이템</a></h3>
<p>연관 아이템은 다른 아이템과 연관된 아이템입니다. 연관 아이템은 <a href="items/implementations.html">구현</a>에 정의되고 <a href="items/traits.html">트레잇</a>에 선언됩니다. 함수, 상수, 타입 별칭만 연관될 수 있습니다. <a href="glossary.html#free-item">자유 아이템</a>과 대조됩니다.</p>
<h3 id="블랭킷-구현"><a class="header" href="#블랭킷-구현">블랭킷 구현</a></h3>
<p>타입이 <a href="glossary.html#uncovered-type">커버되지 않은</a> 상태로 나타나는 모든 구현. <code>impl&lt;T&gt; Foo for T</code>, <code>impl&lt;T&gt; Bar&lt;T&gt; for T</code>, <code>impl&lt;T&gt; Bar&lt;Vec&lt;T&gt;&gt; for T</code>, 그리고 <code>impl&lt;T&gt; Bar&lt;T&gt; for Vec&lt;T&gt;</code>는 블랭킷 구현으로 간주됩니다. 하지만 <code>impl&lt;T&gt; Bar&lt;Vec&lt;T&gt;&gt; for Vec&lt;T&gt;</code>는 이 <code>impl</code>에 나타나는 모든 <code>T</code> 인스턴스가 <code>Vec</code>에 의해 커버되므로 블랭킷 구현이 아닙니다.</p>
<h3 id="바운드"><a class="header" href="#바운드">바운드</a></h3>
<p>바운드는 타입이나 트레잇에 대한 제약 조건입니다. 예를 들어, 함수가 받는 인자에 바운드가 지정되면 해당 함수에 전달되는 타입은 해당 제약 조건을 준수해야 합니다.</p>
<h3 id="컴비네이터"><a class="header" href="#컴비네이터">컴비네이터</a></h3>
<p>컴비네이터는 함수와 이전에 정의된 컴비네이터만을 적용하여 인자로부터 결과를 제공하는 고차 함수입니다. 모듈식으로 제어 흐름을 관리하는 데 사용할 수 있습니다.</p>
<h3 id="크레이트"><a class="header" href="#크레이트">크레이트</a></h3>
<p>크레이트는 컴파일 및 링크의 단위입니다. 라이브러리나 실행 파일과 같은 다양한 <a href="linkage.html">크레이트 종류</a>가 있습니다. 크레이트는 외부 크레이트라고 하는 다른 라이브러리 크레이트를 링크하고 참조할 수 있습니다. 크레이트는 크레이트 루트라고 하는 이름 없는 루트 모듈에서 시작하는 자체 포함된 <a href="items/modules.html">모듈</a> 트리를 가집니다. <a href="items.html">아이템</a>은 공개 모듈의 <a href="paths.html">경로</a>를 포함하여 크레이트 루트에서 공개로 표시하여 다른 크레이트에서 볼 수 있도록 할 수 있습니다. <a href="crates-and-source-files.html">더 보기</a>.</p>
<h3 id="디스패치"><a class="header" href="#디스패치">디스패치</a></h3>
<p>Dispatch is the mechanism to determine which specific version of code is actually run when it involves polymorphism. Two major forms of dispatch are static dispatch and dynamic dispatch. Rust supports dynamic dispatch through the use of [trait objects][type.trait-object].</p>
<h3 id="동적-크기-타입"><a class="header" href="#동적-크기-타입">동적 크기 타입</a></h3>
<p>동적 크기 타입(DST)은 정적으로 알려진 크기나 정렬이 없는 타입입니다.</p>
<h3 id="엔티티"><a class="header" href="#엔티티">엔티티</a></h3>
<p><a href="names.html"><em>엔티티</em></a>는 소스 프로그램 내에서 어떤 방식으로든, 보통 <a href="paths.html">경로</a>를 통해 참조될 수 있는 언어 구성 요소입니다. 엔티티에는 <a href="types.html">타입</a>, <a href="items.html">아이템</a>, <a href="items/generics.html">제네릭 파라미터</a>, <a href="patterns.html">변수 바인딩</a>, <a href="tokens.html#lifetimes-and-loop-labels">루프 레이블</a>, <a href="tokens.html#lifetimes-and-loop-labels">라이프타임</a>, <a href="expressions/field-expr.html">필드</a>, <a href="attributes.html">속성</a>, <a href="attributes/diagnostics.html#lint-check-attributes">린트</a>가 포함됩니다.</p>
<h3 id="표현식-2"><a class="header" href="#표현식-2">표현식</a></h3>
<p>표현식은 값, 상수, 변수, 연산자 및 함수의 조합으로, 부수 효과가 있거나 없을 수 있으며 단일 값으로 평가됩니다.</p>
<p>예를 들어, <code>2 + (3 * 4)</code>는 값 14를 반환하는 표현식입니다.</p>
<h3 id="자유-아이템"><a class="header" href="#자유-아이템">자유 아이템</a></h3>
<p><a href="items/implementations.html">구현</a>의 멤버가 아닌 <a href="items.html">아이템</a>으로, <em>자유 함수</em> 또는 _자유 상수_와 같은 것입니다. <a href="glossary.html#associated-item">연관 아이템</a>과 대조됩니다.</p>
<h3 id="기본-트레잇"><a class="header" href="#기본-트레잇">기본 트레잇</a></h3>
<p>기본 트레잇은 기존 타입에 대해 구현을 추가하는 것이 파괴적인 변경이 되는 트레잇입니다. <code>Fn</code> 트레잇과 <code>Sized</code>가 기본 트레잇입니다.</p>
<h3 id="기본-타입-생성자"><a class="header" href="#기본-타입-생성자">기본 타입 생성자</a></h3>
<p>기본 타입 생성자는 그 위에 <a href="glossary.html#blanket-implementation">블랭킷 구현</a>을 구현하는 것이 파괴적인 변경이 되는 타입입니다. <code>&amp;</code>, <code>&amp;mut</code>, <code>Box</code>, <code>Pin</code>이 기본 타입 생성자입니다.</p>
<p>타입 <code>T</code>가 <a href="glossary.html#local-type">로컬</a>로 간주될 때마다 <code>&amp;T</code>, <code>&amp;mut T</code>, <code>Box&lt;T&gt;</code>, <code>Pin&lt;T&gt;</code>도 로컬로 간주됩니다. 기본 타입 생성자는 다른 타입을 <a href="glossary.html#uncovered-type">커버</a>할 수 없습니다. “커버된 타입“이라는 용어가 사용될 때마다 <code>&amp;T</code>, <code>&amp;mut T</code>, <code>Box&lt;T&gt;</code>, <code>Pin&lt;T&gt;</code>의 <code>T</code>는 커버된 것으로 간주되지 않습니다.</p>
<h3 id="인해비티드"><a class="header" href="#인해비티드">인해비티드</a></h3>
<p>타입은 생성자가 있어 인스턴스화할 수 있는 경우 인해비티드(inhabited)됩니다. 인해비티드 타입은 해당 타입의 값이 있을 수 있다는 의미에서 “비어 있지” 않습니다. <a href="glossary.html#uninhabited">언인해비티드</a>의 반대입니다.</p>
<h3 id="고유-구현"><a class="header" href="#고유-구현">고유 구현</a></h3>
<p>트레잇-타입 쌍이 아닌 명목 타입에 적용되는 <a href="items/implementations.html">구현</a>입니다. <a href="items/implementations.html#inherent-implementations">더 보기</a>.</p>
<h3 id="고유-메서드"><a class="header" href="#고유-메서드">고유 메서드</a></h3>
<p>트레잇 구현이 아닌 <a href="items/implementations.html#inherent-implementations">고유 구현</a>에 정의된 <a href="items/associated-items.html#methods">메서드</a>입니다.</p>
<h3 id="초기화됨"><a class="header" href="#초기화됨">초기화됨</a></h3>
<p>변수는 값이 할당되고 그 이후로 이동되지 않은 경우 초기화됩니다. 다른 모든 메모리 위치는 초기화되지 않은 것으로 간주됩니다. 안전하지 않은 Rust만이 초기화하지 않고 메모리 위치를 생성할 수 있습니다.</p>
<h3 id="로컬-트레잇"><a class="header" href="#로컬-트레잇">로컬 트레잇</a></h3>
<p>현재 크레이트에서 정의된 <code>trait</code>입니다. 트레잇 정의는 적용된 타입 인자와 독립적으로 로컬이거나 로컬이 아닐 수 있습니다. <code>trait Foo&lt;T, U&gt;</code>가 주어졌을 때, <code>T</code>와 <code>U</code>에 대해 대체된 타입에 관계없이 <code>Foo</code>는 항상 로컬입니다.</p>
<h3 id="로컬-타입"><a class="header" href="#로컬-타입">로컬 타입</a></h3>
<p>현재 크레이트에서 정의된 <code>struct</code>, <code>enum</code> 또는 <code>union</code>입니다. 이것은 적용된 타입 인자에 영향을 받지 않습니다. <code>struct Foo</code>는 로컬로 간주되지만 <code>Vec&lt;Foo&gt;</code>는 그렇지 않습니다. <code>LocalType&lt;ForeignType&gt;</code>은 로컬입니다. 타입 별칭은 지역성에 영향을 주지 않습니다.</p>
<h3 id="모듈-1"><a class="header" href="#모듈-1">모듈</a></h3>
<p>모듈은 0개 이상의 <a href="items.html">아이템</a>을 담는 컨테이너입니다. 모듈은 크레이트 루트 또는 루트 모듈이라고 하는 루트의 이름 없는 모듈에서 시작하는 트리로 구성됩니다. <a href="paths.html">경로</a>는 다른 모듈의 아이템을 참조하는 데 사용될 수 있으며, 이는 <a href="visibility-and-privacy.html">가시성 규칙</a>에 의해 제한될 수 있습니다. <a href="items/modules.html">더 보기</a></p>
<h3 id="이름-1"><a class="header" href="#이름-1">이름</a></h3>
<p><a href="names.html"><em>이름</em></a>은 <a href="glossary.html#entity">엔티티</a>를 참조하는 <a href="identifiers.html">식별자</a> 또는 <a href="tokens.html#lifetimes-and-loop-labels">라이프타임 또는 루프 레이블</a>입니다. _이름 바인딩_은 엔티티 선언이 해당 엔티티와 연관된 식별자 또는 레이블을 도입할 때입니다. <a href="paths.html">경로</a>, 식별자 및 레이블은 엔티티를 참조하는 데 사용됩니다.</p>
<h3 id="이름-확인-1"><a class="header" href="#이름-확인-1">이름 확인</a></h3>
<p><a href="names/name-resolution.html"><em>이름 확인(Name resolution)</em></a>은 컴파일 타임에 <a href="paths.html">경로</a>, <a href="identifiers.html">식별자</a>, <a href="tokens.html#lifetimes-and-loop-labels">레이블</a>을 <a href="glossary.html#entity">엔티티</a> 선언에 연결하는 프로세스입니다.</p>
<h3 id="네임스페이스-namespace"><a class="header" href="#네임스페이스-namespace">네임스페이스 (Namespace)</a></h3>
<p>_네임스페이스_는 이름이 참조하는 <a href="glossary.html#entity">엔티티</a>의 종류에 따른 선언된 <a href="glossary.html#name">이름</a>들의 논리적 그룹화입니다. 네임스페이스를 통해 한 네임스페이스에 있는 이름이 다른 네임스페이스에 있는 동일한 이름과 충돌하지 않도록 할 수 있습니다.</p>
<p>네임스페이스 내에서 이름은 계층 구조로 조직되며, 계층 구조의 각 레벨은 자신만의 명명된 엔티티 컬렉션을 가집니다.</p>
<h3 id="공칭-타입-nominal-types"><a class="header" href="#공칭-타입-nominal-types">공칭 타입 (Nominal types)</a></h3>
<p>경로를 통해 직접 참조할 수 있는 타입입니다. 구체적으로는 <a href="items/enumerations.html">열거형</a>, <a href="items/structs.html">구조체</a>, <a href="items/unions.html">유니온</a>, 그리고 <a href="types/trait-object.html">트레잇 객체 타입</a>을 의미합니다.</p>
<h3 id="dyn-호환-트레잇-dyn-compatible-traits"><a class="header" href="#dyn-호환-트레잇-dyn-compatible-traits">Dyn 호환 트레잇 (Dyn-compatible traits)</a></h3>
<p><a href="types/trait-object.html">트레잇 객체 타입</a> (<code>dyn Trait</code>)에서 사용될 수 있는 <a href="items/traits.html">트레잇</a>입니다. 특정한 <a href="items/traits.html#dyn-compatibility">규칙</a>을 따르는 트레잇만이 _dyn 호환_됩니다.</p>
<p>이들은 이전에 <em>객체 안전한(object safe)</em> 트레잇으로 알려져 있었습니다.</p>
<h3 id="경로-path"><a class="header" href="#경로-path">경로 (Path)</a></h3>
<p><a href="paths.html"><em>경로</em></a>는 현재 스코프나 다른 레벨의 <a href="glossary.html#namespace">네임스페이스</a> 계층 구조에 있는 <a href="glossary.html#entity">엔티티</a>를 참조하기 위해 사용되는 하나 이상의 경로 세그먼트 시퀀스입니다.</p>
<h3 id="프렐류드-prelude"><a class="header" href="#프렐류드-prelude">프렐류드 (Prelude)</a></h3>
<p>프렐류드(또는 러스트 프렐류드)는 모든 크레이트의 모든 모듈로 임포트되는 아이템들(주로 트레잇)의 작은 모음입니다. 프렐류드에 포함된 트레잇들은 어디에서나 사용됩니다.</p>
<h3 id="스코프-3"><a class="header" href="#스코프-3">스코프</a></h3>
<p><a href="names/scopes.html"><em>스코프</em></a>는 명명된 <a href="glossary.html#entity">엔티티</a>가 해당 이름으로 참조될 수 있는 소스 텍스트의 영역입니다.</p>
<h3 id="검사-대상-scrutinee"><a class="header" href="#검사-대상-scrutinee">검사 대상 (Scrutinee)</a></h3>
<p>검사 대상(scrutinee)은 <code>match</code> 표현식이나 유사한 패턴 매칭 구문에서 매칭의 대상이 되는 표현식입니다. 예를 들어, <code>match x { A =&gt; 1, B =&gt; 2 }</code>에서 표현식 <code>x</code>가 검사 대상입니다.</p>
<h3 id="크기-size"><a class="header" href="#크기-size">크기 (Size)</a></h3>
<p>값의 크기에는 두 가지 정의가 있습니다.</p>
<p>첫 번째는 해당 값을 저장하기 위해 얼마나 많은 메모리가 할당되어야 하는가입니다.</p>
<p>두 번째는 해당 아이템 타입을 가진 배열에서 연속된 요소들 사이의 바이트 단위 오프셋입니다.</p>
<p>이는 0을 포함하여 정렬의 배수입니다. 크기는 컴파일러 버전(새로운 최적화가 도입됨에 따라)이나 타겟 플랫폼(<code>usize</code>가 플랫폼마다 다른 것과 마찬가지)에 따라 달라질 수 있습니다.</p>
<p><a href="type-layout.html#size-and-alignment">자세히</a>.</p>
<h3 id="슬라이스-slice"><a class="header" href="#슬라이스-slice">슬라이스 (Slice)</a></h3>
<p>슬라이스는 연속된 시퀀스에 대한 동적 크기 뷰(view)이며, <code>[T]</code>로 작성됩니다.</p>
<p>주로 가변 또는 공유 형태의 차용된 형태로 나타납니다. 공유 슬라이스 타입은 <code>&amp;[T]</code>이며, 가변 슬라이스 타입은 <code>&amp;mut [T]</code>입니다. 여기서 <code>T</code>는 요소의 타입을 나타냅니다.</p>
<h3 id="구문-statement"><a class="header" href="#구문-statement">구문 (Statement)</a></h3>
<p>구문은 컴퓨터에 동작을 수행하도록 명령하는 프로그래밍 언어의 가장 작은 독립 요소입니다.</p>
<h3 id="문자열-리터럴-string-literal"><a class="header" href="#문자열-리터럴-string-literal">문자열 리터럴 (String literal)</a></h3>
<p>문자열 리터럴은 최종 바이너리에 직접 저장되는 문자열이며, 따라서 <code>'static</code> 기간 동안 유효합니다.</p>
<p>그 타입은 <code>'static</code> 기간의 차용된 문자열 슬라이스인 <code>&amp;'static str</code>입니다.</p>
<h3 id="문자열-슬라이스-string-slice"><a class="header" href="#문자열-슬라이스-string-slice">문자열 슬라이스 (String slice)</a></h3>
<p>문자열 슬라이스는 러스트에서 가장 기본적인 문자열 타입으로, <code>str</code>로 작성됩니다. 주로 가변 또는 공유 형태의 차용된 형태로 나타납니다. 공유 문자열 슬라이스 타입은 <code>&amp;str</code>이며, 가변 문자열 슬라이스 타입은 <code>&amp;mut str</code>입니다.</p>
<p>문자열 슬라이스는 항상 유효한 UTF-8입니다.</p>
<h3 id="트레잇-trait"><a class="header" href="#트레잇-trait">트레잇 (Trait)</a></h3>
<p>트레잇은 타입이 제공해야 하는 기능을 설명하는 데 사용되는 언어 아이템입니다. 이를 통해 타입은 자신의 동작에 대해 특정한 약속을 할 수 있습니다.</p>
<p>제네릭 함수와 제네릭 구조체는 트레잇을 사용하여 받아들이는 타입을 제한하거나 바인딩(bound)할 수 있습니다.</p>
<h3 id="터보피쉬-turbofish"><a class="header" href="#터보피쉬-turbofish">터보피쉬 (Turbofish)</a></h3>
<p>표현식에서 제네릭 파라미터를 포함하는 경로는 여는 괄호 앞에 <code>::</code>를 붙여야 합니다. 제네릭을 위한 화살괄호와 결합하면 <code>::&lt;&gt;</code>와 같이 물고기처럼 보입니다. 이 때문에 이 구문은 구어체로 터보피쉬 구문이라고 불립니다.</p>
<p>예:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ok_num = Ok::&lt;_, ()&gt;(5);
let vec = [1, 2, 3].iter().map(|n| n * 2).collect::&lt;Vec&lt;_&gt;&gt;();
<span class="boring">}</span></code></pre></pre>
<p>이 <code>::</code> 접두사는 쉼표로 구분된 목록에서 여러 비교 연산이 포함된 제네릭 경로의 모호성을 해결하기 위해 필요합니다. 접두사가 없을 때 모호해질 수 있는 예시는 <a href="https://github.com/rust-lang/rust/blob/1.58.0/src/test/ui/parser/bastion-of-the-turbofish.rs">the bastion of the turbofish</a>를 참조하십시오.</p>
<h3 id="비피복-타입-uncovered-type"><a class="header" href="#비피복-타입-uncovered-type">비피복 타입 (Uncovered type)</a></h3>
<p>다른 타입의 인자로 나타나지 않는 타입입니다. 예를 들어, <code>T</code>는 피복되지 않았지만(uncovered), <code>Vec&lt;T&gt;</code>에서의 <code>T</code>는 피복되었습니다(covered). 이는 타입 인자에서만 의미가 있습니다.</p>
<h3 id="정의되지-않은-동작-undefined-behavior"><a class="header" href="#정의되지-않은-동작-undefined-behavior">정의되지 않은 동작 (Undefined behavior)</a></h3>
<p>명시되지 않은 컴파일 타임 또는 런타임 동작입니다. 이는 프로세스 종료나 손상, 부적절하거나 부정확하거나 의도하지 않은 계산, 또는 플랫폼별 결과 등을 초래할 수 있으나 이에 국한되지 않습니다. <a href="behavior-considered-undefined.html">자세히</a>.</p>
<h3 id="비거주-uninhabited"><a class="header" href="#비거주-uninhabited">비거주 (Uninhabited)</a></h3>
<p>생성자가 없어서 인스턴스화할 수 없는 타입입니다. 비거주 타입은 해당 타입의 값이 없다는 의미에서 “비어 있음“을 뜻합니다. 비거주 타입의 대표적인 예로는 <a href="types/never.html">never 타입</a> <code>!</code> 또는 변형이 없는 열거형인 <code>enum Never { }</code>가 있습니다. <a href="glossary.html#inhabited">거주(Inhabited)</a>의 반대말입니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/reference.js"></script>
        <script src="theme/language-picker.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
